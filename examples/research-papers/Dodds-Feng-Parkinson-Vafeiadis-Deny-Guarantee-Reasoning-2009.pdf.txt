

Deny-Guarantee Reasoning
Mike Dodds1, Xinyu Feng2, Matthew Parkinson1, and Viktor Vafeiadis3

1 University of Cambridge, UK
2 Toyota Technological Institute at Chicago, USA

3 Microsoft Research Cambridge, UK

Abstract. Rely-guarantee is a well-established approach to reasoning about concurrent programs that use parallel composition. However, parallel composition is
not how concurrency is structured in real systems. Instead, threads are started by
`fork' and collected with `join' commands. This style of concurrency cannot be
reasoned about using rely-guarantee, as the life-time of a thread can be scoped
dynamically. With parallel composition the scope is static.

In this paper, we introduce deny-guarantee reasoning, a reformulation of relyguarantee that enables reasoning about dynamically scoped concurrency. We build
on ideas from separation logic to allow interference to be dynamically split and
recombined, in a similar way that separation logic splits and joins heaps. To allow
this splitting, we use deny and guarantee permissions: a deny permission specifies
that the environment cannot do an action, and guarantee permission allow us to do
an action. We illustrate the use of our proof system with examples, and show that
it can encode all the original rely-guarantee proofs. We also present the semantics
and soundness of the deny-guarantee method.

1 Introduction
Rely-guarantee [10] is a well-established compositional proof method for reasoning
about concurrent programs that use parallel composition. Parallel composition provides
a structured form of concurrency: the lifetime of each thread is statically scoped, and
therefore interference between threads is also statically known. In real systems, however, concurrency is not structured like this. Instead, threads are started by a `fork' and
collected with `join' commands. The lifetime of such a thread is dynamically scoped in
a similar way to the lifetime of heap-allocated data.

In this paper, we introduce deny-guarantee reasoning, a reformulation of rely-guarantee that enables reasoning about such dynamically scoped concurrency. We build on
ideas from separation logic to allow interference to be dynamically split and recombined, in a similar way that separation logic splits and joins heaps.

In rely-guarantee, interference is described using two binary relations: the rely, R,
and the guarantee, G. Specifications of programs consist of a precondition, a postcondition and an interference specification. This setup is sufficient to reason about
lexically-scoped parallel composition, but not about dynamically-scoped threads. With
dynamically-scoped threads, the interference at the end of the program may be quite
different from the interference at the beginning of the program, because during execution other threads may have been forked or joined. Therefore, just as in Hoare logic

G. Castagna (Ed.): ESOP 2009, LNCS 5502, pp. 363-377, 2009.

c\Theta  Springer-Verlag Berlin Heidelberg 2009

364 M. Dodds et al.
a program's precondition and postcondition may differ from each other, so in denyguarantee logic a thread's pre-interference and post-interference specification may differ from each other.

Main results. The main contributions of this paper are summarized below:

- We introduce deny-guarantee logic and apply it to an example (see g*3 and g*4).
- We present an encoding of rely-guarantee into deny-guarantee, and show that every

rely-guarantee proof can be translated into a deny-guarantee proof (see g*5).
- We prove that our proof rules are sound (see g*6).
- We have formalized our logic and all the proofs in Isabelle [4].

For clarity of exposition, we shall present deny-guarantee in a very simple setting where
the memory consists only of a pre-allocated set of global variables. Our solution extends
easily to a setting including memory allocation and deallocation (see g*7).

Related work. Other work on concurrency verification has generally ignored fork/join,
preferring to concentrate on the simpler case of parallel composition. This is true of all
of the work on traditional rely-guarantee reasoning [10, 11]. This is unsurprising, as the
development of deny-guarantee depends closely on the abstract characterization of separation logic [3]. However, even approaches such as SAGL [5] and RGSep [12] which
combine rely-guarantee with separation logic omit fork/join from their languages.

There exist already some approaches to concurrency that handle fork. Feng et al. [6]
and Hobor et al. [9] both handle fork. However, both omit join with the justification
that it can be handled by synchronization between threads. However, this approach
is not compositional: it forces us to specify interference globally. Gotsman et al. [7]
propose an approach to locks in the heap which includes both fork and join. However,
this is achieved by defining an invariant over protected sections of the heap, which
makes compositional reasoning about inter-thread interference impossible (see the next
section for an example of this). Haack and Hurlin [8] have extended Gotsman et al.'s
work to reason about fork and join in Java, where a thread can be joined multiple times.

2 Towards Deny-Guarantee Logic

L0: x := 0;
L1: t1 := fork(if(x==1) error;

x := 1);
L2: t2 := fork(x := 2;

if (x==3) error);
L3: join t1;
L4: x := 2;
L5: join t2;

Fig. 1. Illustration of fork/join

Consider the very simple program given in
Fig. 1. If we run the program in an empty environment, then at the end, we will get x = 2.
This happens because the main thread will
block at line L3 until thread t1 terminates.
Hence, the last assignment to x will either be
that of thread t2 or of the main thread, both of
which write the value 2 into x. We also know
that the error in the forked code on L1 and
L2 will never be reached.

Now, suppose we want to prove that this program indeed satisfies the postcondition
x = 2. Unfortunately, this is not possible with existing compositional proof methods.

Deny-Guarantee Reasoning 365
Invariant-based techniques (such as Gotsman et al. [7]) cannot handle this case, because
they cannot describe interference. Unless we introduce auxiliary state to specify a more
complex invariant, we cannot prove the postcondition, as it does not hold throughout
the execution of the program.

Rely-guarantee can describe interference, but still cannot handle this program. Consider the parallel rule:

R1,G1 \Lambda  -P1"" C1 -Q1"" G1 \Xi  R2 R2,G2 \Lambda  -P2"" C2 -Q2"" G2 \Xi  R1

R1 \Pi  R2,G1 \Sigma  G2 \Lambda  -P1\Upsilon P2"" C1 \Phi  C2 -Q1\Upsilon Q2""

In this rule, the interference is described by the rely, R, which describes what the environment can do, and the guarantee, G, which describes what the code is allowed to
do. The rely and guarantee do not change throughout the execution of the code, they
are `statically scoped' interference, whereas the scope of the interference introduced by
fork and join commands is dynamic.

Separation logic solves this kind of problem for dynamically allocated memory, also
known as the heap. It uses the star operator to partition the heap into heap portions
and to pass the portions around dynamically. The star operator on heaps is then lifted
to assertions about heaps. In this work, we shall use the star operator to partition the
interference between threads, and then lift it to assertions about the interference.Let us assume we have an assertion language which can describe interference. It has

a separation-logic-like star operation. We would like to use this star to split and joininterference, so that we can use simple rules to deal with

fork and join:

-P1"" C -P2"" ...-
P*P1"" x := fork C -P*Thread(x, P2)"" (fork)

...-
P*Thread(E, P\Omega )"" join E -P*P\Omega "" (join)

The fork rule simply removes the interference, P1, required by the forked code, C, and
returns a token Thread(x, P2) describing the final state of the thread.

-T1 *G2 * D3 * L * x \Theta  1""

t1 := fork (if(x==1) error;

x := 1);-
G2 * D3 * L * Thread(t1,T1)""

t2 := fork (x := 2;

if(x==3) error );-
L * Thread(t1, T1) * Thread(t2,G2 * D3)""

join t1;-
T1 * L * Thread(t2,G2 * D3)""

x := 2;-
T1 * L * Thread(t2,G2 * D3) * x = 2""

join t2-
T1 *G2 * D3 * L * x = 2""

Fig. 2. Proof outline

The join rule, knowing the thread E is dead,
simply takes over its final state1.

Now, we will consider how we might
prove our motivating example. Let us imagine
we have some assertions that both allow us to
do updates to the state, and forbid the environment from doing certain updates. We provide the full details in g*4, and simply present
the outline (Fig. 2) and an informal explanation of the permissions here. The first thread
we fork can be verified using the T1 and x \Theta  1,
where T1 allows us to update x to be 1, and
prevents any other thread updating x to be
1. Next, we use G2 which allows us to update x to be 2; and D3 which prevents the

1 As in the pthread library, we allow a thread to be joined only once. We could also adapt the

work of Haack and Hurlin [8] to our deny-guarantee setting to handle Java-style join.

366 M. Dodds et al.
environment from updating x to be 3. These two permissions are sufficient to verify the second thread. Finally, L is a leftover permission which prevents any other
thread updating x to be any value other than 1 or 2. When we get to the assignment, we have T1 * L which forbids the environment performing any update except
assigning x with 2. Hence, we know that the program will terminate with x = 2.

1

0

(me, ~env)

(~me, ~env)
(~me, env)
(me, env)

guar deny

Fig. 3. Possible interference

Now, we consider how to build a logic to represent the permission on interference used in the
proof outline. Let us consider the information
contained in a rely-guarantee pair. For each state
change it has one of four possibilities presented
in Fig. 3: guar permission, allowed by both the
thread and the environment (me,env); 1 permission, allowed by the thread, and not allowed for
the environment (me,n^env); 0 permission, not allowed by the thread, but allowed by the environment (n^me,env); and deny permission,
not allowed by the thread or the environment (n^me,n^env).

To allow inter-thread reasoning about interference, we want to split full permissions
1 into either deny permissions or guar permissions. We also want to further split deny,
or guar, permissions into smaller deny or guar permissions respectively. The arrows
of Fig. 3 show the order of permission strength captured by splitting. If a thread has
a deny on a state change, it can give another thread a deny and keep one itself while
preserving the fact that the state change is prohibited for itself and the environment. The
same holds for guar.

To preserve soundness, we cannot allow unrestricted copying of permissions - we
must treat them as resources. Following Boyland [2] and Bornat et al. [1] we attach
weights to splittable resources. In particular we use fractions in the interval (0,1). For
example, we can split an (a + b)deny into an (a)deny and a (b)deny, and similarly for
guar permissions. We can also split a full permission 1 into (a)deny and (b)deny, or
(a)guar and (b)guar, where a + b = 1.

In the following sections we will show how these permissions can be used to build
deny-guarantee, a separation logic for interference.

Aside. Starting with the parallel composition rules of rely-guarantee and of separation
logic, you might wonder if we can define our star as (R1,G1) * (R2,G2) = (R1 \Pi  R2,G1 \Sigma 
G2) provided G1 \Xi  R2 and G2 \Xi  R1, and otherwise it is undefined. Here we have taken

the way rely-guarantee combines the relations, and added it to the definition of *.

This definition, however, does not work. The star we have defined is not cancellative,
a condition that is required for proving that separation is sound [3]. Cancellativity says
that for all x, y and z, if x * y is defined and x * y = x * z, then y = z. Intuitively, the
problem is that \Pi  and \Sigma  lose information about the overlap.

3 The Logic
Language. The language is defined in Fig. 4. This is a standard language with two
additional commands for forking a new thread and for joining with an existing thread.

Deny-Guarantee Reasoning 367
(Expr) E ::= x -- n -- E + E -- E - E -- .. .
(BExp) B ::= true -- false -- E = E -- E \Theta  E -- ...
(Stmts) C ::= x := E -- skip -- C;C -- if B then C else C -- while B do C -- x := fork C -- join E

Fig. 4. The Language
Informally, the x := fork C command allocates an unused thread identifier t, creates a
new thread with thread identifier t and body C, and makes it run in parallel with the rest
of the program. Finally, it returns the thread identifier t by storing it in x. The command
join E blocks until thread E terminates; it fails if E is not a valid thread identifier.
For simplicity, we assume each primitive operation is atomic. The formal operational
semantics is presented in g*6.

Deny-Guarantee Permissions. The main component of our logic is the set of denyguarantee permissions, PermDG. A deny-guarantee permission is a function that maps
each action altering a single variable2 to a certain deny-guarantee fraction:

Vars def= -x, y, z, . . . ""
n ff Vals def= Z
\Theta  ff States def= Vars fi Vals

a ff Actions def= -\Theta [x flfi n], \Theta [x flfi n\Omega ] -- \Theta  ff States \Upsilon  n \Theta  n\Omega ""

f ff FractionDG def= -(deny, \Lambda ) -- \Lambda  ff (0, 1)"" \Sigma  -(guar, \Lambda ) -- \Lambda  ff (0, 1)"" \Sigma  -0, 1""
pr ff PermDG def= Actions fi FractionDG

We sometimes write deny-guarantee fractions in FractionDG in shorthand, with \Lambda d for
(deny, \Lambda ), and \Lambda g for (guar, \Lambda ).

The fractions represent a permission or a prohibition to perform a certain action. The
first two kinds of fractions are symmetric: (deny, \Lambda ) says that nobody can do the action;
(guar, \Lambda ) says that everybody can do the action. The last two are not: 1 represents full
control over the action (only I can do the action), whereas 0 represents no control over
an action (others can do it, but I cannot).

From a deny-guarantee permission, pr, we can extract a pair of rely-guarantee conditions. The rely contains those actions permitted to the environment, while the guarantee
contains those permitted to the thread (see Fig. 3).

\Lambda  \Xi  ff PermDG fi P(Actions) * P(Actions)
\Lambda pr\Xi  def= (-a -- pr(a) = (guar, ) ffi pr(a) = 0"",-

a -- pr(a) = (guar, ) ffi pr(a) = 1"")

As shorthand notations, we will use pr.R and pr.G to represent the first and the second
element in \Lambda pr\Xi  respectively.

2 We do not consider updates to simultaneous locations as it complicates the presentation.

368 M. Dodds et al.

\Theta , pr, \Xi  --= B ffli ([[B]]\Theta  = tt) \Upsilon  (ja. pr(a) = 0) \Upsilon  (\Xi  = `)
\Theta , pr, \Xi  --= pr\Omega  ffli (\Xi  = `) \Upsilon  (pr = pr\Omega )
\Theta , pr, \Xi  --= full ffli (\Xi  = `) \Upsilon  (ja. pr(a) = 1)
\Theta , pr, \Xi  --= Thread(E, P) ffli \Xi  = [[[E]]\Theta  flfi P]
\Theta , pr, \Xi  --= P1 * P2 ffli 'pr1, pr2, \Xi 1, \Xi 2. pr = pr1 ^ pr2 \Upsilon  \Xi  = \Xi 1 * \Xi 2\Upsilon 

(\Theta , pr1,\Xi 1 --= P1) \Upsilon  (\Theta , pr2, \Xi 2 --= P2)
where * means the union of disjoint sets.

\Theta , pr, \Xi  --= P1 L/* P2 ffli jpr1, pr2, \Xi 1, \Xi 2. pr2 = pr ^ pr1 \Upsilon  \Xi 2 = \Xi  * \Xi 1\Upsilon 

(\Theta , pr1,\Xi 1 --= P1) implies (\Theta , pr2,\Xi 2 --= P2)

Fig. 5. Semantics of Assertions
Note that the deny and guar labels come with a fractional coefficient. These coeffi-
cients are used in defining the addition of two deny-guarantee fractions.

0 ^ x def= x ^ 0 def= x
(deny, \Lambda ) ^ (deny, \Lambda \Omega ) def= if \Lambda  + \Lambda \Omega  < 1 then (deny, \Lambda  + \Lambda \Omega )

else if \Lambda  + \Lambda \Omega  = 1 then 1 else undef

(guar, \Lambda ) ^ (guar, \Lambda \Omega ) def= if \Lambda  + \Lambda \Omega  < 1 then (guar, \Lambda  + \Lambda \Omega )

else if \Lambda  + \Lambda \Omega  = 1 then 1 else undef

1 ^ x def= x ^ 1 def= if x = 0 then 1 else undef

The addition of two deny-guarantee permissions, pr = pr1 ^ pr2, is defined so that for all
a ff Actions, pr(a) = pr1(a) ^ pr2(a). The permission inverse inv is defined so inv(1) = 0,
inv(0) = 1, inv(guar, \Lambda ) = (guar, 1 L/ \Lambda ), and inv(deny, \Lambda ) = (deny, 1 L/ \Lambda ).

It is easy to show that addition is commutative, associative, cancellative, and has 0
as a unit element. This allows us to define a separation logic over PermDG.

Assertions and Judgements. The assertions are defined below.

P, Q ::= B -- pr -- full -- false -- Thread(E, P) -- P i Q -- P * Q -- P L/* Q -- 'x. P
An assertion P is interpreted as a predicate over a program state \Theta , a permission
token pr, and a thread queue \Xi . A thread queue, as defined below, is a finite partial
function mapping thread identifiers to the postcondition established by the thread when
it terminates.

t ff ThreadIDs def= N \Xi  ff ThreadQueues def= ThreadIDs \Pi fin Assertions
Semantics of assertions is defined in Fig. 5.

The judgments for commands are in the form of -P"" C -Q"". As in Hoare Logic, a
command is specified by a precondition (P) and a postcondition (Q). Informally, it
means that if the precondition, P, holds in the initial configuration and the environment

Deny-Guarantee Reasoning 369
P1 precise -P1"" C -P2"" x \Pi  fv(P1 * P3)
Thread(x, P2) * P3 i P4 allowed([[x := *]],P3)-

P1 * P3"" x := fork[P1,P2] C -P4"" (fork)

-P * Thread(E, P\Omega )"" join E -P * P\Omega "" (join)

P1 i P\Omega 1 -P\Omega 1"" C -P\Omega 2"" P\Omega 2 i P2-

P1"" C -P2"" (cons)

-P"" C -P\Omega "" stable(P0)-

P * P0"" C -P\Omega  * P0"" (frame)

P i [E/x]P\Omega  allowed([[x := E]],P)-

P"" x := E -P\Omega "" (assn)

Fig. 6. Proof Rules
adheres to its specification, then the command C is safe to execute; moreover every
forked thread will fulfil its specification and if C terminates, the final configuration will
satisfy Q. A formal definition of the semantics is presented in g*6.

The main proof rules are shown in Fig. 6. The proof rules are covered by a general
side-condition requiring that any assertion we write in a triple is stable. Intuitively this
means that the assertion still holds under any interference from the environment, as
expressed in the deny. Requiring stability for every assertion in a triple removes the need
for including explicit stability checks in the proof rules, simplifying the presentation.

Definition 1 (Stability). An assertion P is stable (written stable(P)) if and only if, for
all \Theta , \Theta \Omega , pr and \Xi , if \Theta , pr, \Xi  --= P and (\Theta , \Theta \Omega ) ff pr.R, then \Theta \Omega , pr, \Xi  --= P.

The fork and assign rules include allowed-statements, which assert that particular rewrites are permitted by deny-guarantee assertions. Rewrites are given as relations over
states. In the rules, we write \Lambda x := E\Xi  for the relation over states denoted by assigning

E to x, where E can be * for non-deterministic assignment.

Definition 2 (Allowed). Let K be a relation over states. Then allowed(K, P) holds if
and only if, for all \Theta , \Theta \Omega , pr and \Xi , if \Theta , pr, \Xi  --= P and (\Theta , \Theta \Omega ) ff K, then (\Theta , \Theta \Omega ) ff pr.G.

The assignment rule is an adaptation of Hoare's assignment axiom for sequential programs. In order to deal with concurrency, it checks that the command has enough permission (pr) to update the shared state.

The fork and join rules modify the rules given in [7]. The fork rule takes a precondition and converts it into a Thread-predicate recording the thread's expected postcondition. The rule checks that any pr satisfying the context P3 is sufficient to allow
assignment to the thread variable x. It requires that the variable x used to store the thread
identifier is not in fv(P1 * P3), the free variables for the precondition. As with Gotsman
et al. [7], the rule also requires that the precondition P1 is precise.

The join rule takes a thread predicate and replaces it with the corresponding postcondition. The frame and consequence rules are modified from standard separationlogic rules. Other rules are identical to the standard Hoare logic rules.

370 M. Dodds et al.

1 -T1 *G2 *G2 * D3 * D3 * L\Omega  * x \Theta  1""
2 t1 := fork[T1*(x\Theta 1),T1] (if(x==1) error; x := 1)
3 -G2 *G2 * D3 * D3 * L\Omega  * Thread(t1,T1)""
4 t2 := fork[G2*D3,G2*D3] (x := 2; if(x==3) error)
5 -G2 * D3 * L\Omega  * Thread(t1, T1) * Thread(t2,G2 * D3)""
6 join t1;
7 -T1 *G2 * D3 * L\Omega  * Thread(t2,G2 * D3)""
8 x := 2;
9 -T1 *G2 * D3 * L\Omega  * Thread(t2,G2 * D3) * x = 2""
10 join t2;
11 -T1 *G2 *G2 * D3 * D3 * L\Omega  * x = 2""

where T1 def= [x: Z \Theta  1]1, G2 def= [x: Z \Theta  2] 12 g, D3 def= [x: Z \Theta  3] 12 d,

and L\Omega  def= [x: Z \Theta  -1, 2,3""]1 L/* full

Fig. 7. Proof outline of the fork / join example

4 Two-Thread Example
In g*2 we said that the program shown in Fig. 1 cannot be verified in conventional
rely-guarantee reasoning. We now show that deny-guarantee allows us to verify this
example. The proof outline is given in Fig. 7.

We use the following notation to represent permissions. Here x ff Vars, A, B \Xi  Vals
and f ff FractionDG.

x : A \Theta  B def= -(\Theta [x flfi v], \Theta [x flfi v\Omega ]) -- \Theta  ff State \Upsilon  v ff A \Upsilon  v\Omega  ff B \Upsilon  v \Theta  v\Omega ""

[X] f def= \Sigma a. \Theta \Lambda \Lambda \Xi \Lambda \Lambda \Pi  f if a ff X0 otherwise

Lemma 3 (Permission splitting).

[x : A \Theta  B * B\Omega ] f ffli [x : A \Theta  B] f * [x : A \Theta  B\Omega ] f

[x : A \Theta  B] f ^ f \Omega  ffli [x : A \Theta  B] f * [x : A \Theta  B] f \Omega 

Lemma 4 (Permission subtraction). If P is precise and satisfiable, then (P L/* full) *

P ffli full.

Proof. Holds because (P L/* Q) * P ffli Q \Upsilon  (P * true) and full i P * true hold for any
precise and satisfiable P and any Q. \Lambda 

The fork / join program has precondition -full * x \Theta  1"", giving the full permission, 1, on
every action. The permission [x : Z \Theta  -1, 2, 3""]1 permits any rewrite of the variable x to
the value 1, 2 or 3, and prohibits all other rewrites. By Lemma 4,

full ffli ([x : Z \Theta  -1, 2, 3""]1 L/* full) * [x : Z \Theta  -1, 2, 3""]1

Deny-Guarantee Reasoning 371
By Lemma 3 can split [x : Z \Theta  -1, 2, 3""]1 as follows

[x : Z \Theta  -1, 2, 3""]1 ffli [x : Z \Theta  1]1 * [x : Z \Theta  2]1 * [x : Z \Theta  3]1ffli

T1 * G2 * G2 * D3 * D3

where T1, G2 and D3 are defined in Fig. 7. We define L\Omega  as ([x : Z \Theta  -1, 2, 3""]1 L/* full)
(the L used in the proof sketch in Fig. 2 is L\Omega  * G2 * D3). Consequently, we can derive
the precondition -T1 * G2 * G2 * D3 * D3 * L\Omega  * x \Theta  1""

The specification for thread t1 is shown below. Note that x \Theta  1 is stable because T1
prevents the environment from writing 1 into x. The post-condition does not include
x = 1, because T1 does not prohibit the environment from writing other values into x.

- T1 * x \Theta  1"" if(x==1) error; x := 1; - T1""
The specification for thread t2 is shown below. The assertion x \Theta  3 is stable because
the permission D3 is a deny prohibiting the environment from writing 3 in x. Note that
a deny is used rather than full permission because another instance of D3 is needed to
ensure stability of the assertion on line 9, before the main thread joins t2.

-G2 * D3"" x := 2; -G2 * D3 * x \Theta  3"" if(x==3) error -G2 * D3""
The specifications for t1 and t2 allow us to apply the fork rule (lines 2 and 4).
We then join the thread t1 and recover the permission T1 (line 6). Then we apply the
assignment rule for the assignment x := 2 (line 8).

The post-condition x = 2 on line 9 is stable because T1 * L\Omega  gives the exclusive permission, 1, on every rewrite except rewrites of x with value 2 or 3, and the deny D3
prohibits rewrites of x with value 3. Consequently the only permitted interference from
the environment is to write 2 into x, so x = 2 is stable.

Finally we apply the join rule, collect the permissions held by the thread t2, and
complete the proof.

5 Encoding Rely-Guarantee Reasoning
In this section, we show that the traditional rely-guarantee reasoning can be embedded
into our deny-guarantee reasoning. First, we present an encoding of parallel composition using the fork and join commands, and derive a proof rule. Then, we prove that
every rely-guarantee proof for programs using parallel composition can be translated
into a corresponding deny-guarantee proof.

5.1 Adding Parallel Composition
We encode parallel composition into our language by the following translation:

C1 \Phi (x,P1,Q1) C2 def= x := fork[P1,Q1] C1; C2; join x
Here the annotations P1, Q1 are required to provide the translation onto the fork , which
requires annotations. x is an intermediate variable used to hold the identifier for thread

372 M. Dodds et al.
C1. We assume that x is a fresh variable that is not used in C1 or C2. The parallel

composition rule for deny-guarantee is as follows:-

P1"" C1 -Q1"" -P2"" C2 -Q2"" x \Pi  fv(P1, P2,C1,C2, Q1, Q2) P1 precise-

P1 * P2 * full(x)"" C1 \Phi (x,P1,Q1) C2 -Q1 * Q2 * full(x)"" (par)

Modulo the side-conditions about x and precision, and the full(x) star-conjunct, this is
the same rule as in separation logic. The assertion full(x) stands for the full permission
on the variable x; that is, we have full permission to assign any value to x.

full(x)(\Theta , \Theta \Omega ) def= if \Theta [x flfi v] = \Theta \Omega  \Upsilon  v \Theta  \Theta (x) then 1, else 0
We extend this notation to sets of variables: full(-x1, . . . , xn"") def= full(x1) ^ . . . ^ full(xn).

Precision is required as the underlying fork rule requires it. This makes this rule
weaker than if we directly represented the parallel composition in the semantics.

Lemma 5. The parallel composition rule can be derived from the rules given in Fig. 6.
Proof. The proof has the following outline.-

P1 * P2 * full(x)""

x := fork[P1,Q1] C1-
Thread(x, Q1) * P2 * full(x)""

C2-
Thread(x, Q1) * Q2 * full(x)""

join x-
Q1 * Q2 * full(x)""

The first step uses the first premise, and the frame and fork rules. The second step usesthe second premise and the frame rule. The final step uses the frame and join rules.

5.2 Translation
Now let us consider the translation of rely-guarantee proofs into the deny-guarantee
framework. The encoding of parallel composition into fork and join introduces extra
variables, so we partition variables in constructed fork-join programs into two kinds:
Vars, the original program variables, and TVars, variables introduced to carry thread
identifiers. We will assume that the relies and guarantees from the original proof assume
that the TVars are unchanged.

In g*3, we showed how to extract a pair of rely-guarantee conditions from permissions
pr ff PermDG. Conversely, we can encode rely-guarantee pairs into sets of PermDG
permissions as follows:

\Lambda  \Xi  ff P(Actions) * P(Actions) fi P(PermDG)
\Lambda R,G\Xi  def= -_R,G*F -- F ff Actions fi (0, 1)""

_R,G*F def= \Sigma a. \Theta \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Xi \Lambda \Lambda \Lambda \Lambda \Lambda \Lambda \Pi 

(guar, F(a)) a ff R \Upsilon  a ff G
0 a ff R \Upsilon  a \Pi  G
1 a \Pi  R \Upsilon  a ff G
(deny, F(a)) a \Pi  R \Upsilon  a \Pi  G

Deny-Guarantee Reasoning 373
First, we show that our translation is non-empty: each pair maps to something:
Lemma 6 (Non-empty translation). jR,G. \Lambda R,G\Xi  \Theta  `
By algebraic manipulation, we can show that the definition above corresponds to the
following more declarative definition:

Lemma 7. \Lambda R,G\Xi  = -pr -- \Lambda pr\Xi  = (R,G)""
Moreover, as R and G assume that the TVars are unchanged, the following lemma holds:

Lemma 8. If pr ff \Lambda R,G\Xi , and X \Xi  TVars, then full(X) ^ pr is defined.
Now, we can translate rely-guarantee judgements into a non-empty set of equivalent
triples in deny-guarantee. Non-emptiness follows from Lemmas 6 and 8.

Definition 9 (Triple translation).

\Lambda R,G \Lambda rg -P"" C -Q""\Xi X def= jpr ff \Lambda R,G\Xi . 'C\Omega . \Lambda  -P * pr * full(X)"" C\Omega  -Q * pr * full(X)""\Upsilon 

C = erase(C\Omega )

where the set X \Xi  TVars carries the set of identifiers used in the parallel compositions,
and erase(C\Omega ) is C\Omega  with all annotations removed from parallel compositions.

Note that the judgement R,G \Lambda rg -P"" C -Q"" in traditional rely-guarantee reasoning does
not need annotations in C. The C is a cleaned-up version of some annotated statement
C\Omega . We elide the standard rely-guarantee rules here. This translation allows us to state

the following theorem:

Theorem 10 (Complete embedding). If R,G \Lambda rg -P"" C -Q"" is derivable according to
the rely-guarantee proof rules, then \Lambda R,G \Lambda rg -P"" C -Q""\Xi X holds.

In other words, given a proof in rely-guarantee, we can construct an equivalent proof
using deny-guarantee. We prove this theorem by considering each rely-guarantee proof
rule separately, and showing that the translated versions of the rely-guarantee
proof rules are sound in deny-guarantee. Below we give proofs of the two most interesting rules: the rule of parallel composition and of weakening. For each of these,
we first need a corresponding helper lemma for the translation of the rely-guarantee
conditions. These helper lemmas follow from the definitions of PermDG and \Lambda R,G\Xi .

Lemma 11 (Composition). If G1 \Xi  R2, G2 \Xi  R1, and pr ff \Lambda R1 \Pi  R2,G1 \Sigma  G2\Xi , then
there exist pr1, pr2 such that pr = pr1 ^ pr2 and pr1 ff \Lambda R1,G1\Xi  and pr2 ff \Lambda R2,G2\Xi .

Lemma 12 (Soundness of translated parallel rule).
If G2 \Xi  R1, G1 \Xi  R2, \Lambda R1,G1 \Lambda rg -P1""C1-Q1""\Xi X and \Lambda R2,G2 \Lambda rg -P2""C2-Q2""\Xi Y ,
then \Lambda R1 \Pi  R2,G1 \Sigma  G2 \Lambda rg -P1 \Upsilon  P2""C1 \Phi  C2-Q1 \Upsilon  Q2""\Xi -x""*X*Y

Lemma 13 (Weakening). If R2 \Xi  R1, G1 \Xi  G2, and pr ff \Lambda R2,G2\Xi  then there exist permissions pr1, pr2 such that pr = pr1 ^ pr2 and pr1 ff \Lambda R1,G1\Xi .

Lemma 14 (Soundness of translated weakening rule). If R2 \Xi  R1, G1 \Xi  G2, and
\Lambda R1,G1 \Lambda rg -P""C -Q""\Xi X, then \Lambda R2,G2 \Lambda rg -P""C -Q""\Xi X.

374 M. Dodds et al.
6 Semantics and Soundness
The operational semantics of the language is defined in Fig. 8. The semantics is divided into two parts: the local semantics and the global semantics. The local semantics
is closely related to the interpretation of the logical judgements, while the global semantics can easily be erased to a machine semantics. This erasure and other additional
definitions and proofs can be found in the associated technical report [4].

Local Semantics. The local semantics represents the view of execution from a single
thread. It is defined using the constructs described in g*3. The commands all work with
an abstraction of the environment: \Xi  abstracts the other threads, and carries their final
states; and pr abstracts the interference from other threads and the interference that
it is allowed to generate. The semantics will result in abort if it does not respect the
abstraction.

The first two rules, in Fig. 8, deal with assignment. If the assignment is allowed by
pr, then it executes successfully, otherwise the program aborts signalling an error. The
next two rules handle the joining of threads. If the thread being joined with is in \Xi , then
that thread's terminal pr\Omega  and \Xi \Omega  are added to the current thread before the current thread
continues executing. We annotate the transition with join (t, pr\Omega , \Xi \Omega ), so the semantics
can be reused in the global semantics. If the thread identifier is not in \Xi , we signal an
error as we are joining on a thread that we do not have permission to join. The next two
rules deal with forking new threads. If part of the state satisfies P then we remove that
part of the state, and extend our environment with a new thread that will terminate in a
state satisfying Q. If there is no part of the state satisfying P, then we will raise an error
as we do not have the permission to give to the new thread. The remaining local rules
deal with sequential composition.

In the next section of Fig. 8, we define r\Sigma  , which represents the environment performing an action. We also define \Sigma * as the transitive and reflexive closure of the
operational semantics extended with the environment action.

Given this semantics, we say a local thread is safe if it will not reach an error state.

Definition 15. \Lambda  (C, \Theta , pr, \Xi ) safe ffli n^((C, \Theta , pr, \Xi ) \Sigma * abort)
We can give the semantics of the judgements from earlier in terms of this local operational semantics.

Definition 16 (Semantics of a triple). --= -P""C-Q"" asserts that, if \Theta , pr, \Xi  --= P, then

- (1) \Lambda  (C, \Theta , pr, \Xi ) safe; and- (2) if (C

, \Theta , pr, \Xi ) \Sigma * (skip, \Theta \Omega , pr\Omega , \Xi \Omega ), then \Theta \Omega , pr\Omega , \Xi \Omega  --= Q.

As the programs carry annotations for each fork, we need to define programs that are
well-annotated, that is, the code for each fork satisfies its specification.

Definition 17 (Well-annotated command). We define a command as well-annotated,\Lambda 

C wa, as follows \Lambda 

fork[P,Q] C wa ffli --= -P""C-Q"" \Upsilon  \Lambda  C wa\Lambda 

skip wa ffli always\Lambda 
C1;C2 wa ffli \Lambda  C1 wa \Upsilon  \Lambda  C2 wa

. . .

Deny-Guarantee Reasoning 375
Local semantics

[[E]]\Theta  = n (\Theta ,\Theta [x flfi n]) ff pr.G
(x := E,\Theta , pr,\Xi ) \Sigma  (skip, \Theta [x flfi n], pr,\Xi )

[[E]]\Theta  = n (\Theta ,\Theta [x flfi n]) \Pi  pr.G

(x := E, \Theta , pr,\Xi ) \Sigma  abort

[[E]]\Theta  = t \Xi (t) = Q \Theta , pr\Omega , \Xi \Omega  --= Q
(join E,\Theta , pr,\Xi ) join (t,pr

\Omega ,\Xi \Omega )\Sigma  (skip

,\Theta , pr ^ pr\Omega ,(\Xi  \ t) * \Xi \Omega )

[[E]]\Theta  = t t \Pi  dom(\Xi )
(join E,\Theta , pr, \Xi ) \Sigma  abort

t \Pi  dom(\Xi ) \Theta , pr\Omega ,\Xi \Omega  --= P pr = pr\Omega  ^ pr\Omega \Omega  \Xi  = \Xi \Omega  * \Xi \Omega \Omega  (\Theta ,\Theta [x flfi t]) ff pr.G

(x := fork[P,Q] C,\Theta , pr, \Xi ) fork (t,C,pr

\Omega ,\Xi \Omega )\Sigma  (skip

, \Theta [x flfi t], pr\Omega \Omega ,\Xi \Omega \Omega [t flfi Q])

\Theta , pr,\Xi  ,--= P * true
(x := fork[P,Q] C, \Theta , pr, \Xi ) \Sigma  abort

(\Theta ,\Theta [x flfi t]) \Pi  pr.G
(x := fork[P,Q] C,\Theta , pr,\Xi ) \Sigma  abort

(C,\Theta , pr, \Xi ) \Sigma  (C\Omega , \Theta \Omega , pr\Omega ,\Xi \Omega )
(C;C\Omega \Omega , \Theta , pr,\Xi ) \Sigma  (C\Omega ;C\Omega \Omega ,\Theta \Omega , pr\Omega ,\Xi \Omega ) (skip;C,\Theta , pr, \Xi ) \Sigma  (C,\Theta , pr,\Xi )

(C, \Theta , pr,\Xi ) \Sigma  abort
(C;C\Omega ,\Theta , pr, \Xi ) \Sigma  abort

Interference

(\Theta , \Theta \Omega ) ff pr.R
(C,\Theta , pr,\Xi ) r\Sigma  (C, \Theta \Omega , pr,\Xi )

j(t flfi C, pr, \Xi ) ff \Upsilon . (\Theta ,\Theta \Omega ) ff pr.R

(\Theta ,\Upsilon ) r\Upsilon =i (\Theta \Omega ,\Upsilon )

Global semantics

(C,\Theta , pr, \Xi ) \Sigma  (C\Omega ,\Theta \Omega , pr\Omega , \Xi \Omega ) (\Theta ,\Upsilon ) r\Upsilon =i (\Theta \Omega , \Upsilon \Omega )
(\Theta ,[t flfi C, pr,\Xi ] * \Upsilon ) \Upsilon =i (\Theta \Omega , [t flfi C\Omega , pr\Omega , \Xi \Omega ] * \Upsilon \Omega )

(C, \Theta , pr,\Xi ) fork (t2,C2,pr2,\Xi 2)\Sigma  (C\Omega ,\Theta \Omega , pr\Omega ,\Xi \Omega ) (\Theta ,\Upsilon ) r\Upsilon =i (\Theta \Omega ,\Upsilon \Omega )
(\Theta ,[t1 flfi C, pr,\Xi ] * \Upsilon ) \Upsilon =i (\Theta \Omega , [t flfi C\Omega , pr\Omega , \Xi \Omega ] * [t2 flfi C2, pr2, \Xi 2] * \Upsilon \Omega )

(C,\Theta , pr, \Xi ) join (t2,pr2,\Xi 2)\Sigma  (C\Omega ,\Theta \Omega , pr\Omega , \Xi \Omega ) (\Theta ,\Upsilon ) r\Upsilon =i (\Theta \Omega , \Upsilon \Omega )
(\Theta ,[t1 flfi C, pr,\Xi ] * [t2 flfi skip, pr2,\Xi 2] * \Upsilon ) \Upsilon =i (\Theta \Omega ,[t flfi C\Omega , pr\Omega ,\Xi \Omega ] * \Upsilon \Omega )

(C,\Theta , pr,\Xi ) \Sigma  abort
(\Theta , [t flfi C, pr,\Xi ] * \Upsilon ) \Upsilon =i abort

(C,\Theta , pr,\Xi ) L/\Sigma  (C, \Theta \Omega , pr\Omega ,\Xi \Omega ) n^('\Upsilon \Omega . (\Theta ,\Upsilon ) r\Upsilon =i (\Theta \Omega ,\Upsilon \Omega ))

(\Theta , [t flfi C, pr,\Xi ] * \Upsilon ) \Upsilon =i abort

(C,\Theta , pr,\Xi ) join (t2,pr3,\Xi 3)\Sigma  (C\Omega , \Theta \Omega , pr\Omega ,\Xi \Omega ) n^((C,\Theta , pr,\Xi ) join (t2,pr2,\Xi 2)\Sigma  (C\Omega ,\Theta \Omega , pr\Omega , \Xi \Omega ) )

(\Theta , [t1 flfi C, pr, \Xi ] * [t2 flfi skip, pr2, \Xi 2] * \Upsilon ) \Upsilon =i abort

Fig. 8. Operational Semantics

376 M. Dodds et al.

Given these definitions we can now state soundness of our logic with respect to the
local semantics.

Theorem 18 (Local soundness). If \Lambda  -P""C-Q"", then --= -P""C-Q"" and \Lambda  C wa.

Global Semantics. Now we will consider the operational semantics of the whole machine, that is, for all the threads. This semantics is designed as a stepping stone between
the local semantics and the concrete machine semantics. We need an additional abstraction of the global thread-queue.

\Upsilon  ff GThrdQ def= ThreadIDs \Pi fin Stmts * PermDG * ThreadQueues
In the third part of Fig. 8, we present the global operational semantics. The first rule
progresses one thread, and advances the rest with a corresponding environment action.
The second rule deals with removing a thread from a machine when it is successfully
joined. Here the label ensures that the local semantics uses the same final state for the
thread as it actually has. The third rule creates a new thread. Again the label carries the
information required to ensure the local thread semantics has the same operation as the
global machine.

The three remaining rules deal with the cases when something goes wrong. The
first rule says that if the local semantics can fault, then the global semantics can also.
The second raises an error if a thread performs an action that cannot be accepted as a
legal environment action by other threads. The final rule raises an error if a thread has
terminated and another thread tries to join on it, but cannot join with the right final state.

We can prove the soundness of our logic with respect to this global semantics.

Theorem 19 (Global soundness). If \Lambda  -P""C-Q"" and \Theta , 1, ` --= P, then

- n^((\Theta , [t flfi C, 1, `]) \Upsilon =i* abort); and-

if (\Theta , [t flfi C, 1, `]) \Upsilon =i* (\Theta \Omega , [t flfi skip, pr, \Xi ]) then \Theta \Omega , pr, \Xi  --= Q.

This says, if we have proved a program and it does not initially require any other threads,
then we can execute it without reaching abort, and if it terminates the final state will
satisfy the postcondition.

7 Conclusions and Future Developments
In this paper we have demonstrated that deny-guarantee enables reasoning about programs using dynamically scoped threads, that is, programs using fork to create new
threads and join to wait for their termination. Rely-guarantee cannot reason about this
form of concurrency. Our extension borrows ideas from separation logic to enable an
interference to be split dynamically with a logical operation, *.

We have applied the deny-guarantee method to a setting with only a pre-allocated
set of global variables. However, deny-guarantee extends naturally to a setting with
memory allocation and deallocation.

Deny-guarantee can be applied to separation logic in much the same way as relyguarantee, because the deny-guarantee approach is largely orthogonal to the presence
of the heap. Deny-guarantee permissions can be made into heap permissions by defining
actions as binary relations over heaps, rather than over states with fixed global variables.

Deny-Guarantee Reasoning 377
The SAGL [5] and RGSep [12] approaches can be easily extended to a setting with fork
and join by using heap permissions in place of relies and guarantees.

Finally, deny-guarantee may allow progress on the problem of reasoning about dynamically-allocated locks in the heap. Previous work in this area, such as [7] and [9],
has associated locks with invariants. With deny-guarantee we can associate locks with
heap permissions, and make use of compositional deny-guarantee reasoning. However,
considerable challenges remain, in particular the problems of recursive stability checking and of locks which refer to themselves (Landin's `knots in the store'). We will
address these challenges in future work.

Acknowledgements. We should like to thank Alexey Gotsman, Tony Hoare, Tom Ridge,
Kristin Rozier, Sam Staton, John Wickerson and the anonymous referees for comments
on this paper. We acknowledge funding from EPSRC grant EP/F019394/1 (Parkinson
and Dodds) and a Royal Academy of Engineering / EPSRC fellowship (Parkinson).

References

[1] Bornat, R., Calcagno, C., O'Hearn, P., Parkinson, M.: Permission accounting in separation

logic. In: POPL 2005, pp. 259-270. ACM Press, New York (2005)
[2] Boyland, J.: Checking interference with fractional permissions. In: Cousot, R. (ed.) SAS

2003. LNCS, vol. 2694, pp. 55-72. Springer, Heidelberg (2003)
[3] Calcagno, C., O'Hearn, P.W., Yang, H.: Local action and abstract separation logic. In: LICS

2007, pp. 366-378. IEEE Computer Society, Los Alamitos (2007)
[4] Dodds, M., Feng, X., Parkinson, M., Vafeiadis, V.: Deny-guarantee reasoning (extended

version and formalization in Isabelle). Technical Report UCAM-CL-TR-736, University of
Cambridge (2009),
http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-736.html
[5] Feng, X., Ferreira, R., Shao, Z.: On the relationship between concurrent separation logic

and assume-guarantee reasoning. In: De Nicola, R. (ed.) ESOP 2007. LNCS, vol. 4421, pp.
173-188. Springer, Heidelberg (2007)
[6] Feng, X., Shao, Z.: Modular verification of concurrent assembly code with dynamic thread

creation and termination. In: Proc. ICFP 2005, pp. 254-267. ACM Press, New York (2005)
[7] Gotsman, A., Berdine, J., Cook, B., Rinetzky, N., Sagiv, M.: Local reasoning for storable

locks and threads. In: Shao, Z. (ed.) APLAS 2007. LNCS, vol. 4807, pp. 19-37. Springer,
Heidelberg (2007)
[8] Haack, C., Hurlin, C.: Separation logic contracts for a java-like language with fork/join.

In: Meseguer, J., Ros,u, G. (eds.) AMAST 2008. LNCS, vol. 5140, pp. 199-215. Springer,
Heidelberg (2008)
[9] Hobor, A., Appel, A.W., Nardelli, F.Z.: Oracle semantics for concurrent separation logic. In:

Drossopoulou, S. (ed.) ESOP 2008. LNCS, vol. 4960, pp. 353-367. Springer, Heidelberg
(2008)
[10] Jones, C.B.: Tentative steps toward a development method for interfering programs. ACM

Trans. Program. Lang. Syst. 5(4), 596-619 (1983)
[11] Jones, C.B.: Annoted bibliography on rely/guarantee conditions (2007),

http://homepages.cs.ncl.ac.uk/cliff.jones/ftp-stuff/rg-hist.pdf
[12] Vafeiadis, V., Parkinson, M.: A marriage of rely/guarantee and separation logic. In: Caires,

L., Vasconcelos, V.T. (eds.) CONCUR 2007. LNCS, vol. 4703, pp. 256-271. Springer,
Heidelberg (2007)