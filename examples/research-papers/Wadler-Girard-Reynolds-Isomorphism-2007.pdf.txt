

Theoretical Computer Science 375 (2007) 201-226

www.elsevier.com/locate/tcs

The Girard-Reynolds isomorphism (second edition)

Philip Wadler
Department of Informatics, University of Edinburgh, James Clerk Maxwell Building, The King's Buildings, Mayfield Road,

Edinburgh EH9 3JZ, Scotland, United Kingdom

Abstract

Jean-Yves Girard and John Reynolds independently discovered the second-order polymorphic lambda calculus, F2. Girard
additionally proved a Representation Theorem: every function on natural numbers that can be proved total in second-order
intuitionistic predicate logic, P2, can be represented in F2. Reynolds additionally proved an Abstraction Theorem: every term
in F2 satisfies a suitable notion of logical relation; and formulated a notion of parametricity satisfied by well-behaved models.

We observe that the essence of Girard's result is a projection from P2 into F2, and that the essence of Reynolds's result is an
embedding of F2 into P2, and that the Reynolds embedding followed by the Girard projection is the identity. We show that the
inductive naturals are exactly those values of type natural that satisfy Reynolds's notion of parametricity, and as a consequence
characterize situations in which the Girard projection followed by the Reynolds embedding is also the identity.

An earlier version of this paper used a logic over untyped terms. This version uses a logic over typed term, similar to ones
considered by Abadi and Plotkin and by Takeuti, which better clarifies the relationship between F2 and P2.

This paper uses colour to enhance its presentation. If the link below is not blue, follow it for the colour version.
http://homepages.inf.ed.ac.uk/wadlercfl
2007 Elsevier B.V. All rights reserved.

Keywords: Girard-Reynolds type system; System F; Polymorphic lambda calculus; Abstraction Theorem; Representation Theorem; Curry-Howard

1. Introduction

Double-barrelled names in science indicate cooperation or coincidence: they may label ideas refined by twocollaborators or ideas revealed by two discoverers.

Curry-Howard is a name of the first sort that guarantees theexistence of names of the second sort, such as Hindley-Milner and Girard-Reynolds.

The Curry-Howard isomorphism consists of a correspondence between logic and computation. Propositionscorrespond to types and proofs correspond to terms. Further, reduction of proofs corresponds to reduction of terms,
hence we have no mere bijection but a true isomorphism.Curry formulated this principle for combinatory logic and combinator terms [6], and Howard observed that it
applies to intuitionistic logic and typed lambda calculus [18]. The correspondence extends to a logic with propositionalvariables and a calculus with type variables, which explains why the logician Roger Hindley and the computer
scientist Robin Milner independently discovered the type system underlying ML and Haskell [17,26,10]. It also

E-mail address: wadler@inf.ed.ac.uk.
0304-3975/$ - see front matter cfl 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.tcs.2006.12.042

202 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
extends to a logic with quantifiers over propositions and a calculus with quantifiers over types, which explains whythe logician Jean-Yves Girard and the computer scientist John Reynolds independently discovered the polymorphic
lambda calculus [14,35,36].Girard and Reynolds each made additional discoveries about the calculus that bears their name, here referred
to as F2. Girard proved a Representation Theorem: every function on natural numbers that can be proved total insecond-order predicate calculus P2 can be represented in F2. Reynolds proved an

Abstraction Theorem: every term inF2 satisfies a suitable notion of logical relation; and formulated a notion of parametricity satisfied by well-behaved

models. (The presentation of P2 in this paper is similar in spirit but different in detail to that used by Girard; inparticular, the version used here is typed, as discussed below.)

The calculus P2 is larger than the image under the Curry-Howard isomorphism of F2: the former has threequantifiers (over individuals, types, and predicates), while the latter has only one (over types). Nonetheless, the essence
of Girard's result is a projection from P2 onto F2 that is similar to the Curry-Howard isomorphism, in that it takespropositions to types and proofs to terms, but differs in that it erases information about individuals. This mapping
preserves reductions, hence it is no mere surjection but a true epimorphism.Reynolds's result traditionally concerns binary relations, but it extends to other notions of relation, including a
degenerate unary case. In the unary version, the essence of Reynolds's result is an embedding from F2 into P2 that issimilar to the Curry-Howard isomorphism, in that it takes types to predicates and terms to proofs, but differs in that
it adds information about individuals. This mapping too preserves reductions, hence it is no mere injection but a truemonomorphism.

Furthermore, the result on binary relations can be recovered from the result on unary relations by a doublingoperation, an embedding from P2 into P2 that takes formulas into formulas, proofs into proofs, and preserves
reductions. Reynolds's Abstraction Theorem is an immediate consequence of the Reynolds embedding followed bydoubling.

Christopher Strachey distinguished two types of polymorphism, where the meaning of a term depends upon a type[43]. In parametric polymorphism, the meaning of the term varies uniformly with the type (an example is the length
function), while in ad hoc polymorphism, the meaning of the term at different types may not be related (an example isplus, which may have quite different meanings on integers, floats, and strings). Reynolds introduced a parametricity
condition to capture a semantic notion corresponding to Strachey's parametric polymorphism.The Reynolds embedding followed by the Girard projection is the identity. Remarkably, I can find no place in the
literature where this is remarked! While reading between the lines suggests that some researchers have intuitivelygrasped that there is a connection between the constructs underlying Reynolds's and Girard's proofs, its precise
description seems to have been more elusive.Going the other way, it is unreasonable to expect that the Girard projection followed by the Reynolds embedding
should also yield the identity, because the projection discards all information about individuals.We will demonstrate the above by considering two different approaches to defining the naturals. Here is the standard
inductive definition of the naturals in P2.

N j {nN | 8X N. (8mN. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X }
Here N is the type of naturals (an uninterpreted sort), and s denotes successor (an uninterpreted term of sort N ! N)and z denotes zero (an uninterpreted term of sort N). The above statement gives the usual induction principle for the

naturals--if a property X holds for zero, and if whenever property X holds for m then it also holds for the successorof m, then the property holds for every natural number n--and then defines N to be the predicate that holds exactly
for such n. It is not hard to prove the following.

n 2 N ! s n 2 N z 2 N
(The formal proofs appear in Figs. 6 and 7.) Hence, the terms satisfying N must include z, s z, s (s z), and so on. Wename terms satisfying this predicate the inductive naturals.

By definition, a term can only satisfy predicate N if it has type N, but we make no assumption in the oppositedirection. In some models there may be terms of type N that do not satisfy N. For example, in a model that supports
fixpoints at all types, bottom would be such a term.So far, we have taken N, s, and z to be uninterpreted: the definition of N makes sense for any type N whatsoever,
and for any terms s and z whatsoever, so long as they have the given types.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 203
Now, however, we apply the Girard projection to derive particular definitions of these. In particular, applying theGirard projection to the predicate N in P2 yields a type in F2, which we take to be N.

N j Nffi j 8X. (X ! X) ! (X ! X)
And applying the Girard projection to the two proofs of the statements in P2 above yields two terms in F2, which wetake to be z and s. (The precise terms appear in Figs. 6 and 7.) The type derived for N is the usual type of the Church

numerals, and the terms derived for z and s are the usual definitions of zero and successor on the Church numerals.

Having used the Girard projection to go from P2 to F2, we now use the Reynolds embedding to go back the otherway. Applying the Reynolds embedding to the type s in F2 yields the following predicate in P2.

N* j {nN | 8X. 8X X . 8s X!X . (8m X . m 2 X ! s m 2 X ) ! 8zX . z 2 X ! n X s z 2 X }
This predicate does not look much like N. Unlike before, it makes sense only if N is the type of the Church numerals,since it applies

n to specific arguments; and it does not mention s or z. We name terms satisfying this predicate the
deductive naturals.

In short, we can use arbitrary definitions of N, s, and z, for the inductive naturals, but we must fix these definitionsto correspond to the Church numerals in order to define the deductive naturals. Having done so, it is easy to show that

every inductive natural is also a deductive natural. The converse does not hold in general. However, we will show theinductive naturals are exactly the deductive naturals that satisfy Reynolds's notion of binary parametricity.

Thus, in the important case where binary parametricity holds for the Church numerals, not only does the Girardprojection take N to N, but also the Reynolds embedding takes N to N, and we have no mere embedding-projection
pair but a true isomorphism.

Given a proof m that a term n is an inductive natural, the Girard projection yields a lambda term mffi, and then theReynolds embedding yields a proof that this new term is a deductive natural. Using a realizability technique due to

Krivine and Parigot [20], we will further show that mffi = n, strengthening the sense in which the Girard projectionand the Reynolds embedding are inverses. From this result we will derive Girard's Representation Theorem.

Girard attributes the representation of the natural numbers in polymorphic lambda calculus to Per Martin-L"of [25](the original paper was written in 1970, but only published recently). The natural numbers are a special case of an
algebraic type. The representation of algebraic types in polymorphic lambda calculus was first proposed by B"ohmand Berarducci [4], who characterized the algebraic types as equivalent to polymorphic types of rank two with all
qualifiers on the outside. A closely related treatment of algebraic types as data systems has been explored by Leivant[21,22] and Krivine and Parigot [20]. All of the results given here for naturals extend straightforwardly to any data
system.

Proofs of Reynolds's Abstraction Theorem and Girard's Representation Theorem will emerge naturally from ourdevelopment, almost as corollaries. These are not so much new proofs, as old proofs clarified. Setting Girard's and

Reynolds's proofs in a common framework highlights the relationship between them.
1.1. Relation to other work

Both Girard's and Reynolds's results have spawned large bodies of related work. Girard's Representation Theoremhas been further explored by Leivant [21,22] and by Krivine and Parigot [20], among others. Reynolds's Abstraction
Theorem and parametricity has been further explored by Reynolds [37,38,29], Reynolds and Plotkin [40], Pitts [30-32], Bainbridge, Freyd, Scedrov and Scott [3], Robinson and Rosolini [41], Hasegawa [16], and Wadler [45,46],
among others. Formulations of the Abstraction Theorem and parametricity in terms of logics have been examinedby Mairson [23], in various combinations by Abadi, Cardelli, Curien, and Plotkin [1,33,34], and by Takeuti [44].
Tutorials have been written by Girard, Taylor, and Lafont [15] and Reynolds [39].

Moggi [27], Breazu-Tannen and Coquand [5], Freyd [12] and Hyland, Robinson, and Rosolini [19] give modelswhere the type of Boolean has just two elements or the type of N contains just the Church numerals. Ivar Rummelhoff

[42] shows that there are PER models where the interpretation of N contains a "nonstandard" value that is not aChurch numeral, and hence does not satisfy binary parametricity. Rasmus Mo/gelberg [28] claims that in every PER
model every value of N does satisfy unary parametricity. This shows that unary parametricity does not imply binaryparametricity.

204 P. Wadler / Theoretical Computer Science 375 (2007) 201-226

In addition to the work of Girard and Reynolds, particularly strong influences on this work include: B"ohm andBerarducci [4], who first showed how to represent algebraic types in polymorphic lambda calculus; Leivant [22],
who presents Girard's result as a projection from a logic into F2; Mairson [23], who presents Reynolds's result as anembedding form F2 into a logic; Krivine and Parigot [20], who present a realizability result similar to the one given
here; and Plotkin and Abadi [33] and Takeuti [44], who relate parametricity to a logic of typed terms essentially thesame as P2.

The basic structure of the proofs in Section 5 was suggested, independently, by Wadler [46] and Hasegawa [16].Wadler's proof was not published, but it circulated informally, and influenced the work of Abadi, Cardelli, and Curien
[1] and the subsequent work of Plotkin and Abadi [33]. The notion that parametricity implies that algebraic types havethe usual universal properties goes back to Reynolds [37], while the converse seems to have first been suggested by
Hasegawa [16]. This paper is the first (so far as I know) to observe that the inductive naturals are exactly those valuesof type N that satisfy parametricity, even when not all values of that type are parametric.

Mairson [23] appears to have grasped the inverse relation between the Reynolds embedding and the Girardprojection, though he does not quite manage to state it. However, Mairson does seem to have missed the power of
parametricity. He mislabels as "parametricity" the analogue of Reynolds's Abstraction Theorem, and he never statesan analogue of Reynolds's parametricity condition or the Identity Extension Lemma. Thus when he writes "proofs of
these equivalences still seem to require structural induction, as well as stronger assumptions than parametricity" [23],I believe this is misleading: the equivalences he refers to cannot be proved using the Abstraction Theorem alone, but
can indeed be proved in the presence of parametricity.

The Curry-Howard isomorphism has informed the development of powerful lambda calculi with dependent types,such as de Bruijn's Automath [9], Howard's constructions [18], Martin-L"of's type theory [24], Constable's Nuprl [8],

Coquand and Huet's calculus of constructions [7], and Barendregt's lambda cube [2]. Each of these calculi introducesdependent types to map quantifiers over individuals into the type system. In contrast, the Girard projection discards
all information about individuals. To quote Leivant [22],

we pursue a dual approach: rather than enriching the type systems to match logic, we impoverish logic to matchthe type structure.

What is remarkable is that even after this impoverishment enough power remains to capture the naturals and otheralgebraic types.

1.2. Introduction to the second edition

This paper has previously appeared twice, in a conference and a journal [47,48]. What justifies a third outing? Theearlier versions used a logic over untyped lambda terms, similar to that considered by Mairson [23] and Krivine and
Parigot [20]. This "second edition" uses a logic over polymorphically typed lambda terms, similar to that considered byPlotkin and Abadi [33] and by Takeuti [44]. In the previous paper, I claimed it "appears straightforward" to transpose
the results from an untyped to a typed logic. Having now performed the exercise, I can say it was straightforward butnot trivial -- getting the formulation right required some care. This new version differs in many details of presentation,
and clarifies the structure of the proofs. In particular, this paper gives a sharper characterization of the connectionbetween the inductive naturals and binary parametricity.

Previously, I observed:

Girard's Representation Theorem requires a logic with untyped terms, since the whole point of the theorem isto demonstrate that functions defined in a language without types may be represented in a language with types.

I no longer believe that is correct. In the definition of the naturals given above, N, s, and z are uninterpreted symbols,requiring only that s have type N ! N and z have type N - in short, the types impose no constraints other than those
one finds in an algebraic specification with sorts. From this algebraic definition, one can then derive the representation,in which N, s, and z are as usual for Church numerals.

So there is no serious disadvantage in moving to a typed version, and some advantages. In the untyped setting,extensionality is problematic and the only model known to satisfy parametricity is a term model; while in the typed
setting, extensionality is unproblematic and there are many models satisfying parametricity. The untyped model is

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 205
Syntax

Type variables X, Y , ZTypes

A, B, C ::= X | A ! B | 8X. BIndividual variables x

, y, z
Terms s, t, u ::= x A | *x A. u | s t | \Lambda X. u | s A

Rules [

x A]***

u B !-Ix
(*x A. u)A!B

s A!B t A !-E

(s t)B

u B 8-I X does not escape
(\Lambda X. u)8X. B

s8X. B 8-E
(s A)B[A/X]
Reductions[

x A]***

u B !-Ix
(*x A. u)A!B

***
t A !-E
((*x A. u) t)B

) ***u[t

/x]B

***
u B 8-I
(\Lambda X. u)8X. B 8-E
((\Lambda X. u) A)B[A/X]

) ***u[A

/X]B[A/X]

Fig. 1. Second-order lambda calculus, F2.
inconsistent if one assumes parametricity at all types (as shown in the first edition [47,48]), while the typed model isconsistent if one assumes parametricity at all types (as shown by Takeuti [44]).

This version is an extensive rewrite of the previous versions. Two changes are worth particular note. First, previousversions use a sequent presentation of natural deduction, where all the hypotheses of a formula are written to the left
of a turnstyle; while this version reverts to the original format of Gentzen [13], where only new hypotheses are written,eliminating much repetition. (I am grateful to Clemens Szyperski for inspiring this step, by asking "How can one get
to the meat in inference rules?") Second, this version is in colour.

The remainder of this paper is organized as follows. Section 2 introduces the second-order lambda calculus F2 andthe second-order logic P2. Section 3 describes the Girard projection and the Reynolds embedding. Section 4 explains

doubling and parametricity. Section 5 explores the relation between induction and parametricity. Section 6 applies arealizability interpretation to prove Girard's Representation Theorem.

2. Systems F2 and P2

The second-order lambda calculus F2 is summarized in Fig. 1, and second-order intuitionistic logic P2 issummarized in Fig. 2.
Derivations of typings in F2 and proofs of propositions in P2 are written in the natural deduction style of Gentzen[13], with hypotheses in square brackets. Write j for syntactic equivalence of terms, propositions, predicates,
derivations, or proofs, and write ) for reductions between terms, propositions, derivations, or proofs.

Related concepts are denoted with the same letters, using fonts to distinguish syntactic categories. Let x, y, z rangeover individual variables in F2 and P2 and bold x

, y, z range over labels of hypotheses in P2. Let t, u, v range overterms in F2 and P2 and bold s
, t, u range over proofs in P2. Let X, Y, Z range over type variables in F2 and P2, andcalligraphic X
, Y, Z range over predicate variables in P2. Let A, B, C range over types in F2 and P2, bold A, B, Crange over propositions in P2, and calligraphic A

, B, C range over predicates in P2.

206 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
Syntax

Hypothesis labels x, y, zProofs s

, t, uPredicate variables X

, Y
Propositions A, B ::= tC 2 AC | A ! B | 8X C . B | 8xC . B | 8X. B
Predicates A, B ::= X C | {xC | A}

Rules [

A]x***

B !-Ix
A ! B

A ! B A !-E

B

B 8-I X does not escape8X

C . B 8X

C . B 8-E

B[AC /X ]
B 81-I x does not escape8
xC . B 8

xC . B 81-E
B[tC /x]

B 82-I X does not escape8
X. B 8

X. B 82-E
B[A/ X]

A fi A =

fi BB

Reductions[

A]x***

u
B !-Ix

A ! B

*** t
A !-E
B

) *** u[t/x]B

*** u
B 8-I8X

C . B 8-E

B[AC /X ]

) *** u[A

C /X ]

B[AC /X ]

*** u
B 81-I8
xC . B 81-E
B[tC /x]

) *** u[t

C /x]

B[tC /x]

*** u
B 82-I8
X. B 82-E
B[A/ X]

) *** u[A/ X]B[ A/ X]

Fig. 2. Second-order propositional logic, P2.
We write u[t/x] for term u with term t substituted for individual variable x; and B[A/ X] for type B with type Asubstituted for type variable

X; and B[A/X ] for proposition B with predicate A substituted for predicate variableX . All substitutions rename bound variables as necessary to avoid capture.

We superscript individual variables, terms, predicate variables, and predicates with their types. The grammarrequires these superscripts to always be present, but in what follows they will be dropped when no confusion results.
Types are formed from type variables X, functions A ! B, and quantification over types 8X. B. Terms are formedfrom individual variables x A, abstraction

*x A. u, application s t, type abstraction \Lambda X. u, and type application s A.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 207
Each well-typed term t uniquely determines its typing derivation. We write*

**
t A
to indicate that there is a derivation of term t of type A. Derivations have hypotheses of the form

[x A]
to indicate that individual variable x has type A.

There are introduction and elimination rules for functions and quantification over types. In the introduction rule forfunctions, each instance of the rule is superscripted with the name x of the variable hypothesis that is discharged by

that rule. In the introduction rule for quantifiers, the phrase "X does not escape" means that the type variable does notappear free in any undischarged hypothesis of the derivation.

A derivation reduces when an introduction rule is followed by an elimination rule for the same connective,corresponding to the usual

fi rules for term and type applications. We write t =fi u if t and u can be shown equivalentby
fi reduction.
Propositions are formed from tests that a term satisfies a predicate tC 2 AC , implication A ! B, quantificationover individuals 8

xC . B, quantification over types 8X. B, and quantification over predicates 8X C . B. Predicates areformed from predicate variables X C and comprehensions {xC | A}; both of these are over individuals of type C. Here

C is any type of F2, possibly including free type variables.

Unlike with typing derivations, proofs are not uniquely determined by their conclusions. We let s, t, u range overproofs, and write

*** t
A
to indicate that proof t concludes with proposition A. Proofs have hypotheses of the form

[ A]x
where A is a proposition and x is a hypothesis label.

There are introduction and elimination rules for implication and quantification over individuals, types, andpredicates. In the introduction rule for implication, each instance of the rule is superscripted with the label x of

the hypothesis that is discharged by that rule. In the introduction rules for quantifiers, the phrase "x/X/X does notescape" means that the individual/type/predicate variable does not appear free in any undischarged hypothesis of the
derivation.

Beta equality on terms corresponds to the equivalent reductions for F2.

(*x T . u) t =fi u[t/x]
(\Lambda X. u) A =fi u[A/ X]

Take =fi to be the smallest congruence on propositions that respects the two equations above and one additionalequation below.

Notationally, predicates are treated as sets, so tC 2 AC indicates that term t of type C satisfies predicate A overindividuals of type

C, and {xC | A} stands for the predicate over individual variable x of type C that holds whenproposition A is satisfied. This gives us an additional notion of

fi equality between propositions.

tC 2 {xC | A} =fi A[t/x]
(Some authors write A t instead of t 2 A, and *x. A instead of {x | A}.)

A proof reduces when an introduction rule is followed by an elimination rule for the same connective. We writeu[t

/x] to stand for the proof u with each occurrence of a hypothesis with label x is replaced by proof t. We also writeu[
t/x], u[A/ X], and u[A/X ] to stand for proofs with substitution of a term for an individual variable, a types for atype variables, or a predicate for a predicate variable.

208 P. Wadler / Theoretical Computer Science 375 (2007) 201-226

In addition to the listed reductions, we also have commuting conversions for (fi). Here is a commuting conversionthat pushes a use of (

fi) from the principle formula in (!-E) down to the conclusion. Assume B =fi B0.

***
A ! B fi
A ! B0

***
A !-E
B0

)

***
A ! B

***
A !-E
B fi
B0
There are similar conversions for each introduction and elimination rule. These commuting conversions are requiredif the Reynolds embedding is to preserves reductions, and they will be referred to in Proposition 1.

We can simulate proposition variables (nullary predicates) and relation variables (binary predicates) by definingunit types and pair types in the term calculus.

1 j 8X. X ! X* j

\Lambda X. *x X . x{* | C} j {

z1 | C}

A * B j 8X. (A ! B ! X) ! X
(t A, u B) j \Lambda X. *k A!B!X . k t ufst

(s A*B) j s A (*x A. *y B. x)snd

(s A*B) j s B (*x A. *y B. y){
(x A, y B) | C} j {z A*B | C[fst(z)/x, snd(z)/y]}

(Here z should not appear free in A.) As required, we have

* 2 {* | A} =fi A
(t, u) 2 {(x A, y B) | A} =fi A[t/x, u/y]

True, false, conjunction, disjunction, and equivalence can be defined in terms of the connectives already given.

? j 8X 1. * 2 X ! * 2 X? j 8X 1

. * 2 XA ^ B j 8X 1
. ( A ! B ! * 2 X ) ! * 2 X
A . B j 8X 1. ( A ! * 2 X ) ! (B ! * 2 X ) ! * 2 XA $ B j

( A ! B) ^ (B ! A)

(Here X should not appear free in A or B.)

Implication and equivalence of predicates are written with the usual set-theoretic notation.

A ` B j 8x. x 2 A ! x 2 BA = B j

(A ` B) ^ (B ` A)

Remarkably, P2 is powerful enough to express equality between terms. Following Leibniz, two terms are equal ifevery predicate that holds of the first also holds of the second.

t A = u A j 8X A. t 2 X ! u 2 X
It is easy to see that equality is reflexive.

t = tj defn
8X . t 2 X ! t 2 X

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 209
It is more subtle to see that it is symmetric.

t = uj defn

8X . t 2 X ! u 2 X! instantiate {x | x = t}

/X
t = t ! u = tj equality is reflexive

u = t
One may similarly show transitivity, and that t =fi u implies t = u.Extensionality is given by two families of axioms.

8 f A!B, g A!B. (8x A. f x = g x) ! f = g8

f 8X. B, g8X. B. (8X. f X = g X) ! f = g

3. The Girard projection and the Reynolds embedding

The Girard projection takes a proposition A into a type Affi and a proof t into a term tffi such that` *

** t
A '

ffi j ***

tffi Affi.
The Girard projection is defined in Fig. 3. It maps implication in P2 into function types in F2, quantification overpredicates in P2 into quantification over types in F2, and discards quantification over individuals and types in P2. The

Girard projection also takes a predicate AC into a type Affi. It maps a predicate variable into the corresponding typevariable, and a comprehension into the Girard projection of the corresponding proposition.

The Reynolds embedding takes a type A into a predicate A* A, and a term t into a proof t* such that *

**
t A!

* j *** t*

t 2 A*.
The Reynolds embedding is defined in Fig. 4. It expands functions in F2 into quantification over individuals and intoimplication in P2, and quantification over types in F2 into quantification over types and predicates in P2.

It is easy to check that the Girard projection and Reynolds embedding preserve substitution, (B[A/X ])ffi jBffi[Affi

/ X] and (B[A/ X])* j B*[A*/X ], and that the Girard projection is invariant under fi reduction, if A =fi Bthen Affi j Bffi.

Proposition 1 (The Girard Projection and Reynolds Embedding Preserve Reduction).`

*** t
A )

*** u
A '

ffi j ***

tffi Affi )

***
uffi Affi 

***
t A )

***
u B!

* j *** t*

t 2 A* )

*** u*
u 2 A* fi

t 2 A*

.

(An earlier version of this paper [47] failed to note the role of fi rules in the preservation of reductions for the Reynoldsembedding.)
Proof. The Girard projection takes reduction of an implication into reduction of a function; takes reduction ofquantification over predicates into reduction of quantification over types; and removes reduction of quantification
over individuals or types. The Reynolds embedding takes reduction of a function into reduction of a quantificationover individuals followed by reduction of an implication, with a

fi rule remaining; and takes reduction of quantificationover types into reduction of quantification over types followed by reduction of quantification over predicates, with a

firule remaining. The commuting rules for
fi described in the previous section may be used to push remaining fi rulesdown to the conclusion of the proof. \Lambda 

It is easy to see that the Reynolds embedding followed by the Girard projection is the identity.

210 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
Propositions

(tC 2 AC )ffi j Affi
( A ! B)ffi j Affi ! Bffi
(8X C . B)ffi j 8X. Bffi
(8xC . B)ffi j Bffi
(8X. B)ffi j Bffi

Predicates

(X C )ffi j X
({xC | A})ffi j Affi

Proofs0BB

@

[ A]x***

u
B !-Ix

A ! B

1CCAffi

j

[x Affi]***

uffi Bffi !-Ix
(*x Affi. uffi)Affi!Bffi

0B@ *** s

A ! B

*** t
A !-E
B

1CAffi

j

***
sffi Affi!Bffi

***
tffi Affi !-E
(sffi tffi)Bffi0

B@ *** uB 8

-I8X C . B 1CA

ffi

j

***
uffi Bffi 8-I
(\Lambda X. uffi)8X. Bffi

0B@ *** s

8X C . B 8-E
B[AC /X ]

1CAffi

j

***
sffi8X. Bffi 8-E
(sffi Affi)Bffi[Affi/X]0B

@

*** u
B 81-I8
xC . B

1CAffi

j ***uffi Bffi 0B@

*** s
8xC . B 81-E
B[tC /x]

1CAffi

j ***sffi Bffi0

B@ *** uB 8

2-I8
X. B

1CAffi

j ***uffi Bffi 0B@ ***

s8
X. B 82-E

B[A/ X]

1CAffi

j ***sffi Bffi0

B@ *** tA

fiB 1CA

ffi

j ***tffi Affi

Fig. 3. The Girard projection.
Proposition 2 (Girard Inverts Reynolds).

A*ffi j A  ***t A!

*ffi j ***

t A

.

For example, here is the type of the Church numerals in F2.

N j 8X. (X ! X) ! X ! X
Applying the Reynolds embedding yields the following predicate in P2.

N* j {nN | 8X. 8X X . 8s X!X . (8m X . m 2 X ! s m 2 X ) ! 8z X . z 2 X ! n X s z 2 X }

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 211
Types

(X)* j X X
(A ! B)* j {z A!B | 8x A. x 2 A* ! z x 2 B*}
(8X. B)* j {z8X. B | 8X. 8X X . z X 2 B*}

Proofs 0

BBB@ [x

A]**

*u B

!-Ix(*x A. u)A!B

1CCCA*

j

[x 2 A*]x***

u*
u 2 B* fi

(*x A. u) x 2 B* !-Ix
x 2 A* ! (*x A. u) x 2 B* 81-I8
x A. x 2 A* ! (*x A. u) x 2 B*0

B@ ***s A!B ***t A !

-E(s t)B 1CA

*

j

*** s*
8x A. x 2 A* ! s x 2 B* 81-E

t 2 A* ! s t 2 B*

*** t*
t 2 A* !-E
s t 2 B*0

B@ ***uB 8

-I(\Lambda X. u)8X. B 1CA

*

j

*** u*
u 2 B* fi
(\Lambda X. u) X 2 B* 8-I8X

X . (\Lambda X. u) X 2 B* 82

-I8X. 8X X . (\Lambda X. u) X 2 B*0

B@ ***s8X. B 8

-E(s A)B[A/X] 1CA

*

j

*** s*
8X. 8X X . s X 2 B* 82-E8X

A. s A 2 B*[A/ X] 8-E

s A 2 B*[A/ X, A*/X ]

Fig. 4. The Reynolds embedding.
Applying the Girard projection then yields the original type.

N*ffi j 8X. (X ! X) ! X ! X
Define 2N = \Lambda X. *s X!X . *z X . s (s z). Then 2 2 N* and 2*ffi j 2. *

**
2N!

*ffi j ` *** 2*

2 2 N*'

ffi j ***

2N
Note that the Girard projection takes equality into the unit type.

(t = u)ffi j (8X . t 2 X ! u 2 X )ffi j 8X. X ! X j 1
Hence, the Girard projection erases any information content in the proof of an equality judgement. Similarly, onemay extend the Girard projection so that it maps the extensionality axioms into the identity function at the unit type,

(*x1. x)1!1.

212 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
4. Doubling and parametricity

4.1. Doubling

The Reynolds embedding corresponds to a unary version of Reynolds's Abstraction Theorem. We can recover thebinary version by means of a doubling mapping from P2 to P2.
Doubling is defined with the aid of operations that rename variables. For each individual variable x there is arenaming x0, and for each type variable X there is a renaming X0. We write t0 for the term that results from renaming
all the free individual and type variables in t.

Doubling takes a proposition A into a proposition AE^, a predicate AC into a predicate AE^C*C0, and a proof t intoa proof tE^ such that`

*** u
B '

E^ j *** uE^

BE^.
Doubling is defined in Fig. 5. It maps implication into itself, quantification over unary predicates into quantificationover binary predicates, and quantifications over individuals and types into pairs of quantifications.

Doubling preserves substitution and fi equality, (B[AC /X C ])E^ j BE^[AE^C*C0/X C*C0], and if A =fi B then
AE^ j BE^.

Like the Girard projection and the Reynolds embedding, doubling is a homomorphism.

Proposition 3 (Doubling Preserves Reductions).`

*** t
A )

*** u
A '

E^ j *** tE^

AE^ )

*** uE^
AE^

.

What Reynolds calls the Abstraction Theorem [36] and what Plotkin and Abadi call the Logical Relations Lemma[33] arises as the composition of Reynolds embedding with doubling.

Proposition 4 (Abstraction Theorem).

***
t A!

*E^ j *** t*E^

(t, t0) 2 A*E^

.

In other places, the statement of the Abstraction Theorem must explicitly mention that the free variables of term tmust satisfy logical relations corresponding to their types; this is implicit in the notation adopted here. The proof of
the theorem is implicit in its statement, as it follows immediately from the definitions of the Reynolds embedding anddoubling.

Here again is the type of the Church numerals in F2.

N j 8X. (X ! X) ! X ! X
Applying the Reynolds embedding followed by doubling yields the following predicate in P2.

N*E^ j {(nN, n0N) | 8X. 8X0. 8X X*X0.8

s X!X . 8s0X0!X0. (8m X . 8m0X0. (m, m0) 2 X ! (s m, s0 m0) 2 X ) !8

zX . 8z0X0. (z, z0) 2 X ! (n X s z, n0 X0 s0 z0) 2 X }

Define 2N = \Lambda X. *s X!X . *zX . s (s z). Then (2, 2) 2 N*E^.

***
2N!

*E^ j ` *** 2*

2 2 N*'

E^ j *** 2*E^

(2, 2) 2 N*E^

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 213
Propositions

(tC 2 AC )E^ j (tC , t0C0) 2 AE^C*C0
( A ! B)E^ j AE^ ! BE^
(8X C . B)E^ j 8X C*C0. BE^
(8xC . B)E^ j 8xC , x0C0. BE^
(8X. B)E^ j 8X, X0. BE^

Predicates

(X C )E^ j X C*C0
({xC | A})E^ j {(xC , x0C0) | AE^}

Proofs 0BB

@

[ A]x***

u
B !-Ix

A ! B

1CCAE^

j

[ AE^]x***

uE^

BE^ !-Ix
AE^ ! BE^

0B@ *** s

A ! B

*** t
A !-E
B

1CAE^

j

*** sE^

AE^ ! BE^

*** tE^
AE^ !-E
BE^0

B@ *** uB 8

-I8X C . B 1CA

E^

j

*** uE^

BE^ 8-I8X
C*C0. BE^

0B@ *** s

8X C . B 8-E
B[AC /X ]

1CAE^

j

*** sE^
8X C*C0. BE^ 8-E
BE^[AE^C*C0/X ]0B

@

*** u
B 81-I8
xC . B

1CAE^

j

*** uE^

BE^ 81-I twice8
xC , x0C0. BE^

0B@ *** s

8xC . B 81-E
B[tC /x]

1CAE^

j

*** sE^
8xC , x0C0. BE^ 81-E twice
BE^[tC /x, t0C0/x0]0B

@

*** u
B 82-I8
X. B

1CAE^

j

*** uE^

BE^ 82-I twice8
X, X0. BE^

0B@ *** s

8X. B 82-E
B[A/ X]

1CAE^

j

*** sE^
8X, X0. BE^ 82-E twice
BE^[A/ X, A0/ X0]0B

@

*** t
A fi

B

1CAE^

j

*** tE^

AE^ fi twice

BE^

Fig. 5. The doubling embedding.
4.2. Parametricity

It is convenient to introduce the notion of an identity relation at a type and at a predicate.
Definition 5. The identity relation at type A is defined by

A= j {(x A, x0A) | x = x0}.
Definition 6. The identity relation at a predicate AA is defined by

A= j {(x A, x0A) | x = x0 ^ x 2 A}.

214 P. Wadler / Theoretical Computer Science 375 (2007) 201-226

The parametric closure of a type is the doubling of the Reynolds embedding of that type, with the relationcorresponding to each free type variable taken to be the identity relation at that type.

Definition 7. The parametric closure on type A is defined by

Ass j A*E^[X1/ X01, X1=/X 1, . . . , Xn/ X0n, Xn=/X n]
where X1, . . . , Xn are the free type variables in A.
It is easy to verify that Ass is symmetric and transitive. If A is a closed type, then Ass j A*E^, for example, Nss j N*E^.

A type is parametric when all values of that type belong to the parametric closure, and is extensive when valuesare related by the parametric closure only if they are equal.

Definition 8. Type A is parametric when A= ` Ass and extensive when Ass ` A=.
Equivalently, A is parametric when 8x A. (x, x) 2 Ass and extensive when 8x A, x0 A. (x, x0) 2 Ass ! x = x0. Notethat we distinguish

extensiveness as given here from extensionality as given at the end of Section 2.
Reynolds's Parametricity Postulate assumes that every quantified type is parametric. An immediate consequenceis the following.

Proposition 9 (Identity Extension Lemma). If every quantified type 8X. B is parametric, then every type is bothparametric and extensive, Ass = A=.
Proof. The proof is by induction on the structure of types, and has five parts.

(i) Every type variable X is parametric and extensive. Immediate.
(ii) If A is parametric and B is extensive then A ! B is extensive.

(z, z0) 2 (A ! B)ssj definition parametric closure

8x, x0. (x, x0) 2 (A)ss ! (z x, z0 x0) 2 (B)ss! induction hypothesis
8x, x0. x = x0 ! z x = z0 x0j extensionality

z = z0
(iii) If A is extensive and B is parametric then A ! B is parametric. Similar to (ii).

(iv) If B is extensive then 8X. B is extensive. Let X, _Y be the free variables of B.

(z, z0) 2 (8X. B)ssj

definition parametric closure8
X, X0. 8X . (z X, z0 X0) 2 B*E^[ _Y / _Y 0, _Y =/ _Y]!

instantiate X/ X0, X=/X8
X. (z X, z0 X) 2 B*E^[X/ X0, X=/X , _Y / _Y 0, _Y =/ _Y]!

induction hypothesis8
X. z X = z0 Xj

extensionality
z = z0

(v) 8X. B is parametric. Given. \Lambda 

Plotkin and Abadi [33] take parametricity at every quantified type and extensionality as axioms of their logic.Takeuti [44] takes parametricity and extensiveness at every type as axioms of his logic. It is not difficult to show these

two sets of axioms are equivalent. Takeuti also shows that these assumptions are consistent, in that adding them to thelogic does not permit derivation of the proposition false.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 215
0BBBB
BB@

[z 2 X ]z !-Iz
z 2 X ! z 2 X !-Is
(8mN. m 2 X ! s m 2 X ) ! z 2 X ! z 2 X 8-I8X

N. (8mN. m 2 X ! s m 2 X ) ! z 2 X ! z 2 X

fiz 2 N

1CCCC
CCA

ffi

j

[z X ] !-Iz
*zX . z X!X !-Is
*s X!X . *z X . z(X!X)!X!X 8-I

\Lambda X. *s X!X . *zX . zN

Fig. 6. Zero.
However, we will make no use of the Parametricity Postulate or the Identity Extension Lemma in what follows.We assume extensionality, but not parametricity or extensiveness.

5. Parametricity is inductive

In this section we consider relations between parametricity and inductive definitions for the natural numbers. Theresults extend to any

data system of the style considered by B"ohm and Berarducci [4], Leivant [22], and Krivine andParigot [20].

We consider two interpretations of the natural numbers, an inductive interpretation, N, and a deductiveinterpretation N. The inductive interpretation N corresponds to the induction principle for natural numbers.

N j {n | 8X. 8X . (8m. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X }
To prove a property of natural numbers by induction, one must show that for all m, if m has the property then itssuccessor s m has the property, and one must show that z has the property. The above definition states that a value

is a natural number if one can prove a property of it by induction. The idea of classifying induction principles usingsecond-order propositional variables, and of defining a type via its induction principle, goes back to Frege [11].

One immediate consequence of the definition is that s and z do indeed construct natural numbers.
Proposition 10 (Constructor Lemma). The following are provable in P2.

n 2 N ! s n 2 N z 2 N
Proof. Straightforward. The proofs appear in the top parts of Figs. 6 and 7. \Lambda 

The inductive interpretation and the Constructor Lemma do not depend in any way on the structure of N, s, and z,and they may be chosen to be uninterpreted constants. However, we will see there is good reason to choose N, s, and
z to be their usual representations under the Church numerals, which we call the deductive interpretation.

N j 8X. (X ! X) ! (X ! X)
sN!N j *mN. \Lambda X. *s X!X . *zX . s (m s z)
zN j \Lambda X. *s X!X . *zX . z

216 P. Wadler / Theoretical Computer Science 375 (2007) 201-226

0 BBBBBBBBBBBBBBBBBBBBBBBBBB@[8

mN
.m2

X!
sm2
X]
s 81

-E

n2X
!
sn2

X

[n2
N]
n

fi

8X
N.

(8m

N.m

2X
!
sm2

X
)!

z2X

!
n2X

8-E

(8m
N.m

2X
!
sm2

X
)!

z2X

!
n2X

[8m
N.m

2X
!
sm2

X]
s !

-E

z2X
!
n2X

[z2
X]
z !

-E

n2X

!-E

sn2
X

!-I
z

z2X
!
sn2

X

!-I
s

(8m
N.m

2X
!
sm2

X
)!

z2X

!
sn2

X

8-I

8X
N.

(8m

N.m

2X
!
sm2

X
)!

z2X

!
sn2

X

fi

sn2
N

!-I
n

n2
N!

sn2
N

81-I

8n
N.n

2N
!
sn2

N

1 CCCCCCCCCCCCCCCCCCCCCCCCCCAffi

j
[sX!

X]

[nN]

8-E

(n
X)
(X!

X)!
X!
X

[sX!
X] !

-E

(n
Xs

)X!

X

[zX]

!-E

(n
Xs

z)X !

-E

(s
(n

Xs

z))
X

!-I
z

(*z
X.s

(n
Xs

z))
X!

X

!-I
s

(*s
X!
X.

*z
X.s

(n
Xs

z))
(X!

X)!
X!
X 8

-I

(\Lambda X
.*s
X!
X.

*z
X.s

(n
Xs

z))
N

!-I
n

(*n
N.\Lambda 

X.
*s
X!

X.

*z
X.s

(n
Xs

z))
N!

N

Fig.
7.Successor

.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 217
The deductive interpretation is the Girard projection of the inductive interpretation.

Proposition 11 (Deduction Lemma). Let N be the inductive interpretation of the naturals, and s and z be the proofsin the Constructor Lemma; in which N, s, and z may be taken to be uninterpreted constants. The definitions of N, s,
and z given above may be derived from these by applying the Girard projection.

Nffi j N ` *** sn 2 N ! s n 2 N'ffi j sN!N ` *** zz 2 N'ffi j zN
Proof. Straightforward. The Girard projection for zero and successor appears in Figs. 6 and 7. \Lambda 

In what follows, we assume N, s, and z have their deductive definitions. With this assumption, we will be ableto demonstrate a close relation between parametricity and inductivity. We will show that the naturals satisfying
parametricity are exactly the same as the naturals satisfying induction,

N*E^ = N=.
Equivalently, 8n, n0. (n, n0) 2 N*E^ $ n = n0 ^ n 2 N.

Reynolds and Plotkin [40] were the first to suggest that parametricity implies inductivity, and Hasegawa [16] wasthe first to suggest the converse. What we show here is that the values of type N satisfying induction are exactly the

same as the values satisfying binary parametricity. This is a stronger result -- Reynolds and Plotkin and Hasegawa(and, in earlier work, myself), only consider the case where all values satisfy binary parametricity, and hence N
contains exactly the inductive naturals. The result above holds even if some values fail to satisfy binary parametricity.In particular, the result given here applies to models that include ? as a value of type N, though ? is not an inductive
natural and fails to satisfy parametricity. (The earlier versions of this paper contain essentially the same proofs, butdid not extract the stronger conclusion.)

We begin with some useful lemmas. Binary parametricity implies equality, and binary parametricity implies unaryparametricity.

Proposition 12 (Extensive Lemma). 8n, n0. (n, n0) 2 N*E^ ! n = n0.
Proof.

(n, n0) 2 N*E^j

definition8
X, X0. 8X X*X0. 8s, s0. (8m, m0. (m, m0) 2 X ! (s m, s0 m0) 2 X ) !8

z, z0. (z, z0) 2 X ! (n X s z, n0 X0 s0 z0) 2 X!

instantiate {(n, n0) | n = n0}/X8
X. 8s, s0. (8m, m0. m = m0 ! s m = s0 m0) ! 8z, z0. z = z0 ! n X s z = n0 X0 s0 z0!

simplify8
X. 8s. 8z. n X s z = n0 X s z!

extensionality
n = n0 \Lambda 

Proposition 13 (Halving Lemma). 8n, n0. (n, n0) 2 N*E^ ! n 2 N*

218 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
Proof.

(n, n0) 2 N*E^j

definition8
X, X0. 8X X*X0. 8s, s0. (8m, m0. (m, m0) 2 X ! (s m, s0 m0) 2 X ) !8

z, z0. (z, z0) 2 X ! (n X s z, n0 X0 s0 z0) 2 X!

instantiate X/ X, X0/ X0, {(x, x0) | x 2 X X }/X X*X0, generalize over X, X X8
X. 8X X . 8s. (8m. m 2 X ! s m 2 X ) ! 8z. z 2 X ! n X s z 2 X!

definition
n 2 N* \Lambda 

B"ohm and Berarducci [4, Theorem 7.3] observe every term n of type N in F2 satisfies n N s z = n, where equalityis
fij equality. Here we show a similar result for any terms satisfying binary parametricity.

Proposition 14 (B"ohm and Berarducci's Lemma). 8n. (n, n) 2 N*E^ ! n N s z = n.
Proof.

(n, n) 2 N*E^j

definition8
X, X0. 8X X*X0. 8s, s0. (8m, m0. (m, m0) 2 X ! (s m, s0 m0) 2 X ) !8

z, z0. (z, z0) 2 X ! (n X s z, n X0 s0 z0) 2 X!

instantiate N/ X, X/ X0, {(n, x) | n X s z = x}/X , s/s, s/s0, z/z, z/z0
(8m, m0. m X s z = m0 ! (s m) X s z = s m0) !

z X s z = z ! (n N s z) X s z = n X s z!

simplify
(8m, m0. (s m) X s z = s (m X s z)) ! z X s z = z ! (n N s z) X s z = n X s z!

definition s, z
(n N s z) X s z = n X s z!

extensionality
n N s z = n \Lambda 

Next, we show that every natural that satisfies induction satisfies unary and binary parametricity. The two proofsare quite similar.

Proposition 15 (Inductive Implies Deductive). 8n. n 2 N ! n 2 N*.
Proof.

n 2 Nj

definition inductive naturals8X
N. (8m. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X

! instantiate N*/X

(8m. m 2 N* ! s m 2 N*) ! z 2 N* ! n 2 N*!

Reynolds embedding applied to s and z
n 2 N* \Lambda 

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 219
Proposition 16 (Inductive Implies Parametric). 8n. n 2 N ! (n, n) 2 N*E^
Proof.

n 2 Nj

definition8X
N. (8m. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X

! instantiate {n | (n, n) 2 N*E^}/X

(8m. (m, m) 2 N*E^ ! (s m, s m) 2 N*E^) ! (z, z) 2 N*E^ ! (n, n) 2 N*E^!

Abstraction Theorem applied to s and z
(n, n) 2 N*E^ \Lambda 

Finally, we show that the values satisfying parametricity are the inductive naturals.
Proposition 17 (Parametric Implies Inductive). 8n. (n, n) 2 N*E^ ! n 2 N
Proof.

(n, n) 2 N*E^!

Halving lemma
n 2 N*j

definition8
X. 8X . 8s. (8m. m 2 X ! s m 2 X ) ! 8z. z 2 X ! n X s z 2 X!

instantiate N/ X, N/X , s/s, z/z
(8m. m 2 N ! s m 2 N) ! z 2 N ! n N s z 2 N!

Constructor Lemma
n N s z 2 N!

B"ohm and Berarducci's Lemma
n 2 N \Lambda 

Combining the above gives the desired result.
Proposition 18 (Parametricity is Inductive).

N*E^ = N=
An immediate consequence is that N = N* if and only if N*E^ = N*=. Hence, the Girard projection followed by theReynolds embedding is the identity for the induction over the naturals exactly when binary parametricity is equivalent

to unary parametricity.
6. Realizability and Girard's Representation Theorem

Apply the Girard projection followed by the Reynolds embedding to the assertion that a given term is a naturalnumber.`

*** m
n 2 N'

ffi* j  ***

mffiN!

* j *** mffi*

mffi 2 N*
In the previous section, we saw that N = N* exactly when N*= = N*E^. In this section, we will show that in theabove situation that mffi =

n is provable in P2, further strengthening the sense in which the Girard projection and theReynolds embedding are inverses. From this result we will derive Girard's Representation Theorem [14,15,22].

220 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
Propositions

(tC 2 AC )C j {z A | (tC , z A) 2 ACC*Affi}
( A ! B)C j {z A!B | 8x A. x 2 AC ! z x 2 BC}
(8X C . B)C j {z8X. B | 8X. 8X C*X . z X 2 BC}
(8xC . B)C j {z B | 8xC . z 2 BC}
(8X. B)C j {z B | 8X. z 2 BC}

Predicates

(X C )C j X C*X
({xC | A})C j {(xC , zAffi) | z 2 AC}

Fig. 8. The realizability interpretation (Part 1).
The key to the proof is a realizability interpretation, similar to those studied by Krivine and Parigot [20] andTakeuti [44]. Krivine and Parigot's interpretation is for a logic in which terms are untyped, and is presented in terms
of a particular term model of that logic, but it is the direct inspiration for the translation presented here. Takeuti'sinterpretation is for a logic essentially the same as the one described here, but the interpretation itself differ in several
particulars. As we shall see, the realizability interpretation given here is related to both the Girard projection and theReynolds embedding.

Recall that the Girard projection takes a proposition A into a type Affi, and a proof t into a term tffi, such that`

*** t
A '

ffi j ***

tffi Affi.
The realizability interpretation takes a proposition A into a predicate AC over terms of type Affi, and a proof t into aproof tC, such that`

*** t
A '

C j *** tC

tffi 2 AC.
The Realizability interpretation is defined in Figs. 8 and 9. It maps implication into a predicate over terms of functiontype, and quantification over predicates into a predicate over terms of quantified type. The realizability interpretation

also takes a predicate A over individuals of type C into a predicate AC over pairs of type C * Affi.

The existence of the realizability interpretation corresponds to Krivine and Parigot's Conservation Lemma, and themapping from proofs to proofs shown in Fig. 9 amounts to a diagrammatic display of their proof of that lemma.

The realizability interpretation preserves substitution for terms and predicates, (B[t/x])C j BC[t/x] and
(B[A/X C ])C j BC[AC/X C*Affi].

As we have seen, the realizability interpretation is closely related to the Girard projection. Surprisingly, it is alsoclosely related to the Reynolds embedding and doubling.

Proposition 19 (Realizability and the Reynolds Embedding). For all types A,

A*C = A*E^.
Equivalently, 8z, z0. z0 2 (z 2 A*)C j (z, z0) 2 A*E^.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 221
Proofs 0

BB@ [ A]

x**

* uB !

-IxA ! B

1CCAC

j

[x 2 AC]x***

uC

uffi 2 BC fi

(*x A. uffi) x 2 BC !-Ix
x 2 AC ! (*x A. uffi) x 2 BC 81-I8
x A. x 2 AC ! (*x A. uffi) x 2 BC0

B@ *** sA ! B *** tA !

-EB 1CA

C

j

*** sC
8x A. x 2 AC ! sffi x 2 BC 81-E

tffi 2 AC ! sffi tffi 2 BC

*** tC
tffi 2 AC !-E
sffi tffi 2 BC0

B@ *** uB 8

-I8X C . B 1CA

C

j

*** uC
uffi 2 BC fi
(\Lambda X. uffi) X 2 BC 8-I8X
C*X . (\Lambda X. uffi) X 2 BC 82

-I8X. 8X C*X . (\Lambda X. uffi) X 2 BC0

B@ *** s8X C . B 8

-EB[AC /X ] 1CA

C

j

*** sC
8X. 8X C*X . sffi X 2 BC 82-E8X

C*A. sffi A 2 BC[A/ X ] 8-E

sffi A 2 BC[A/ X, ACC*A/X ]0B

@

*** u
B 81-I8
xC . B

1CAC

j

*** uC

uffi 2 BC 81-I8
xC . uffi 2 BC

0B@ *** s

8xC . B 81-E
B[tC /x]

1CAC

j

*** sC
8xC . sffi 2 BC 81-E
sffi 2 BC[tC /x]0B

@

*** u
B 82-I8
X. B

1CAC

j

*** uC

uffi 2 BC 82-I8
X. uffi 2 BC

0B@ *** s

8X. B 82-E
B[A/ X]

1CAC

j

*** sC
8X. sffi 2 BC 82-E
sffi 2 BC[A/ X]0B

@

*** t
A fi

B

1CAC

j

*** tC

tffi 2 AC fi
tffi 2 BC

Fig. 9. The realizability interpretation (Part 2).

222 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
Proof. By induction over the structure of types. Below is the case for A ! B, the cases for X and 8X. B are similar.

z0 2 (z 2 (A ! B)*)Cj

definition Reynolds embedding
z0 2 (8x. x 2 A* ! z x 2 B*)Cj

definition realizability interpretation8
x. 8x0. x0 2 (x 2 A*)C ! z0 x0 2 (z x 2 B*)Cj

induction hypothesis8
x. 8x0. (x, x0) 2 A*E^ ! (z x, z0 x0) 2 B*E^j

definition Reynolds embedding, doubling
(z, z0) 2 (A ! B)*E^ \Lambda 

Combining the above with the results of the previous section, we see that N*C = N*E^ = N=. Next we give asimilar result, where N* is replaced by N.

Proposition 20 (Krivine and Parigot's Lemma).

NC = N=.
Equivalently, 8n, n0. n0 2 (n 2 N)C $ n = n0 ^ n 2 N.
Proof. The proof has three parts.

(i) n0 2 (n 2 N)C ! n = n0. The proof is similar to that of B"ohm and Berarducci's Lemma.

n0 2 (n 2 N)Cj

definition
n0 2 (8X N. (8m. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X )Cj

definition8
X. 8X N*X . 8s. (8m. 8m0. (m, m0) 2 X ! (s m, s m0) 2 X ) ! 8z. (z, z) 2 X ! (n, n0 X s z) 2 X!

instantiate X/ X, {(n, n0) | n X s z = n0}/X , s/s, z/z
(8m. 8m0. m s z = m0 ! (s m) X s z = s m0) ! z X s z = z ! n X s z = n0 X s z!

definition s, z
n X s z = n0 X s z!

extensionality
n = n0

(ii) n0 2 (n 2 N)C ! n 2 N. This is straightforward.

n0 2 (n 2 N)Cj

definition8
X. 8X N*X . 8s. (8m. 8m0. (m, m0) 2 X ! (s m, s m0) 2 X ) ! 8z. (z, z) 2 X ! (n, n0 X s z) 2 X!

instantiate X/ X, {(n, x) | n 2 X }/X , s/s, z/z, generalize on X8X
N. (8m. m 2 X ! s m 2 X ) ! z 2 X ! n 2 X

j definition

n 2 N

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 223
(iii) n 2 N ! n 2 (n 2 N)C. We use the fact that n 2 N implies (n, n) 2 N*E^. The proof exploits B"ohm andBerarducci's Lemma.

(n, n) 2 N*E^j

definition8
X, X0. 8X X*X0. 8s, s0. (8m, m0. (m, m0) 2 X ! (s m, s0 m0) 2 X ) !8

z, z0. (z, z0) 2 X ! (n X s z, n X0 s0 z0) 2 X!

instantiate N/ X, X/ X0, s/s, s/s0, z/z, z/z08
X. 8X N*X . 8s. (8m, m0. (m, m0) 2 X ! (s m, s m0) 2 X ) !8

z. (z, z) 2 X ! (n N s z, n X s z) 2 X!

B"ohm and Berarducci's Lemma8
X. 8X N*X . 8s. (8m, m0. (m, m0) 2 X ! (s m, s m0) 2 X ) !8

z. (z, z) 2 X ! (n, n X s z) 2 Xj

definition
n 2 (n 2 N)C \Lambda 

As a corollary, we have that the Girard projection takes a proof that a term belongs to the inductive naturals into
the same term in the deductive naturals.

Proposition 21 (Value Representation). Let m be a proof that some term n satisfies N. Then` *

** m
n 2 N'

ffi j ***

mffiNffi
and mffi = n is provable in P2.

Proof. The realizability interpretation gives us`

*** m
n 2 N'

C j *** mC

mffi 2 (n 2 N)C
from which Krivine and Parigot's Lemma deduces mffi = n. \Lambda 

For example, let 2 = s (s z), and say we have a proof m in P2 that 2 2 N. It is easy to find a proof such that itsGirard projection mffi is the second Church numeral, but can we be sure that this is true for any such proof? This is

ensured by value representation, which guarantees mffi = n.

A similar result holds for functions. We give the result here for unary functions, but it extends easily to any numberof arguments.

Proposition 22 (Representation Theorem). Let f be a proof that 8x. x 2 N ! g x 2 N, in which g may be an
uninterpreted constant known only to satisfy some equations. Then the Girard projection f ffi is a term of polymorphiclambda calculus that represents g, in that f ffi n = g n for all n 2 N.

Proof. Let m be a proof that n 2 N for some term n. Then0BB

BB@

*** f
8x. x 2 N ! g x 2 N 81-E

n 2 N ! g n 2 N

*** m
n 2 N !-E
g n 2 N

1CCCC
A

ffi

j

***
f ffiN!N

***
mffiN !-E
( f ffi mffi)N

We have mffi = n and f ffi mffi = g n by Krivine and Parigot's lemma. \Lambda 

224 P. Wadler / Theoretical Computer Science 375 (2007) 201-226

0 BBBBBBBBBBBBBBBBBB@

[m2
N]
m

fi

8X
N.

(8m

N.m

2X
!
sm2

X
)!

z2X

!
m2

X

8-E

(8m
N.m

+n2

N!
(sm
)+
n2
N)!

z+
n2
N!

m+
n2
N

* * *s

8n
N.n2

N!
sn2
N

81-E

m+
n2
N!

s(m
+n
)2
N

fi+

m+
n2
N!

(sm
)+
n2
N

81-I

8m
N.m

+n2

N!
(sm
)+
n2
N !

-E

z+
n2
N!

m+
n2
N

[n2
N]
n fi

+

z+
n2
N !

-E

m+
n2
N

!-I
n

n2
N!

m+
n2
N

!-I
m

m2
N!

n2
N!

m+
n2
N

1 CCCCCCCCCCCCCCCCCCAffi

j
[m
N]

8-E

(m
N)
(N!

N)!
N!
N

* * * sN!N

!-E

(m
Ns
)N!

N

[nN]

!-E

(m
Ns

n)N

!-I
n

(*n
N.m

Ns
n)N
!N

!-I
m

(*m
N.

*n
N.m

Ns
n)N
!N

Fig.
10.
Plus.

P. Wadler / Theoretical Computer Science 375 (2007) 201-226 225
For example, let pN!N!N be an uninterpreted symbol satisfying the following equations, where we write m + nfor p

m n.

z + n = n
(s m) + n = s (m + n)

Say there is a proof p in P2 that the sum of two naturals is a natural. Applying the Girard projection to that proofyields a term pffi in F2 that takes two naturals into a natural.`

*** p
8m, n. m 2 N ! n 2 N ! m + n 2 N'

ffi j ***

pffiN!N!N
It follows from the Representation Theorem that pffi m n = m + n, so from a proof in P2 that sum takes naturals tonaturals we have derived a term in F2 that computes sums. An example of such a proof p and the corresponding term

pffi is displayed in Fig. 10. In this figure, the two rules labelled fi+ are appeals to the equations given above, the proofs the term s j sffi are as in Fig. 7.

This is remarkable. We start with a proof in which p is an uninterpreted symbol. The Girard projection throws awayall occurrences of p, indeed it throws away all terms in the proof, as well as all quantifiers over individuals and types.
Yet it is guaranteed that the constructed lambda term represents the original function! It almost seems like magic, and,as with the best of magic tricks, knowing how it is done makes it more magical still.

Acknowledgements

My thanks to Rasmus Mo/gelberg, Martin Odersky, Andrew Pitts, Gordon Plotkin, Jon Riecke, Colin Runciman,Clemens Szyperski, Ren'e Vestergaard, to referees of POPL 1999, LICS 2000, TACS 2001, Information and
Computation, and Theoretical Computer Science, and to seminar audiences at JAIST, Bath, and Birmingham. Thanksalso to Don Sanella for editing this article, and to the anonymous reviewers.

References

[1] M. Abadi, L. Cardelli, P.-L. Curien, Formal parametric polymorphism, Theoretical Computer Science 121 (1-2) (1993) 9-58. (Part of A

Collection of Contributions in Honour of Corrado Boehm on the Occasion of his 70th Birthday.) Also appeared as SRC Research Report 109.
[2] H. Barendregt, Introduction to generalized types systems, Journal of Functional Programming 1 (2) (1991) 125-154.
[3] E.S. Bainbridge, P.J. Freyd, A. Scedrov, P.J. Scott, Functorial polymorphism, in: G. Huet (Ed.), Logical Foundations of Functional

Programming, Addison-Wesley, 1990, pp. 315-330.
[4] C. B"ohm, A. Berarducci, Automatic synthesis of typed \Lambda -programs on term algebras, Theoretical Computer Science 39 (2-3) (1985) 135-154.
[5] V. Breazu-Tannen, T. Coquand, Extensional models for polymorphism, Theoretical Computer Science 59 (1988) 85-114.
[6] H.B. Curry, R. Feys, Combinatory Logic, North Holland, 1958.
[7] T. Coquand, G. Huet, The calculus of constructions, Information and Computation 76 (1988) 95-120.
[8] R. Constable, et al., Implementing mathematics with the Nuprl proof development system, Prentice-Hall, 1986.
[9] N.G. de Bruijn, The mathematical language of AUTOMATH, its usage and some of its extensions, in: Proceedings of the Symposium on

Automatic Demonstration, in: LNCS, vol. 125, Springer-Verlag, 1970.
[10] L. Damas, R. Milner, Principal type schemes for functional programs, in: 9'th Annual Symposium on Principles of Programming Languages,

Albuquerque, N.M., ACM, January 1982.
[11] G. Frege, Begriffsschrift, a formula language, modeled upon that of arithmetic, for pure thought (1879), in: Jan van Heijenoort (Ed.), From

Frege to G"odel: A Source Book in Mathematical Logic, Harvard University Press, 1967, pp. 1879-1931.
[12] P. Freyd, POLYNAT in PER, Contemporary Mathematics 92 (1989) 67-68.
[13] G. Gentzen, Investigations into logical deduction, Mathematische Zeitschrift 39 (1935) 176-210, 405-431. Reprinted in M.E. Szabo, editor,

The collected papers of Gerhard Gentzen, North Holland, 1969.
[14] J.-Y. Girard, Interpr'etation functionelle et 'elimination des coupures dans l'arithm'etique d'ordre sup'erieure, Ph.D. Thesis, Universit'e Paris VII,

1972.
[15] J.-Y. Girard, Y. Lafont, P. Taylor, Proofs and Types, Cambridge University Press, 1989.
[16] R. Hasegawa, Categorical data types in parametric polymorphism, Mathematical Structures in Computer Science 4 (1994) 71-109.
[17] R. Hindley, The principal type scheme of an object in combinatory logic, Transactions of the American Mathematical Society 146 (1969)

29-60.
[18] W.A. Howard, The formulae-as-types notion of construction, in: J.P. Seldin, J.R. Hindley (Eds.), To H.B. Curry: Essays on Combinatory

Logic, Lambda Calculus, and Formalism, Academic Press, 1980 (The original version was circulated privately in 1969).
[19] J.M.E. Hyland, E.P. Robinson, G. Rosolini, Algebraic types in PER models, in: Mathematical Foundations of Programming Semantics, New

Orleans, in: LNCS, vol. 442, Springer-Verlag, 1989, pp. 333-350.

226 P. Wadler / Theoretical Computer Science 375 (2007) 201-226
[20] J.-L. Krivine, M. Parigot, Programming with proofs, Journal of Information Processing and Cybernetics (EIK) 26 (3) (1990) 149-167. Revised

version of a lecture presented at the 6'th International Symposium on Computation Theory, SCT '87, Wednisch-Rietz, GDR, 30 November-4
December 1987.
[21] D. Leivant, Reasoning about functional programs and complexity classes associated with type disciplines, in: 24'th Symposium on

Foundations of Computer Science, IEEE, Washington, DC, 1983, pp. 460-469.
[22] D. Leivant, Contracting proofs to programs, in: P. Odifreddi (Ed.), Logic and Computer Science, Academic Press, 1990.
[23] H. Mairson, Outline of a proof theory of parametricity, in: J. Hughes (Ed.), 5'th International Conference on Functional Programming

Languages and Computer Architecture, Cambridge, Massachusetts, in: LNCS, vol. 523, Springer-Verlag, August 1991.
[24] P. Martin-L"of, Constructive mathematics and computer programming, in: 6'th International Congress for Logic, Methodology, and Philosophy

of Science, North Holland, 1982, pp. 153-175.
[25] P. Martin-L"of, A construction of the provable well-orderings of a theory of species, in: A. Anderson, M. Zeleny (Eds.), Logic, Meaning and

Computation: Essays in Memory of Alonzo Church, Kluwer-Academic, 2001.
[26] R. Milner, A theory of type polymorphism in programming, Journal of Computers and Systems Science 17 (1978) 348-375.
[27] E. Moggi, Communication to the Types electronic forum, 10 February 1986.
[28] Rasmus Mo/gelberg, Private communication, March 2004.
[29] Q. Ma, J.C. Reynolds, Types, abstraction, and parametric polymorphism, part 2, in: S. Brookes, et al. (Eds.), Mathematical Foundations of

Programming Semantics, in: LNCS, Springer-Verlag, 1991.
[30] A.M. Pitts, Polymorphism Is Set Theoretic, Constructively, in: D.H. Pitt, A. Poign'e, D.E. Rydeheard (Eds.), Category Theory and Computer

Science, Edinburgh, 1987 pp. 12-39.
[31] A.M. Pitts, Non-trivial power types can't be subtypes of polymorphic types, in: 4th Annual Symposium on Logic in Computer Science, IEEE

Computer Society Press, Washington, 1989, pp. 6-13.
[32] A.M. Pitts, Parametric polymorphism and operational equivalence, Technical report 453, Cambridge University Computer Laboratory, 1998.
[33] G. Plotkin, M. Abadi, A logic for parametric polymorphism, in: M. Bezem, J.F. Groote (Eds.), Typed Lambda Calculi and Applications,

in: LNCS, vol. 664, Springer-Verlag, March 1993, pp. 361-375.
[34] G. Plotkin, M. Abadi, L. Cardelli, Subtyping and parametricity, in: 9'th Annual Symposium on Logic in Computer Science, July 1994, pp.

310-319.
[35] J.C. Reynolds, Towards a theory of type structure, in: B. Robinet (Ed.), Colloque sur la Programmation, in: LNCS, vol. 19, Springer-Verlag,

1974.
[36] J.C. Reynolds, Types, abstraction, and parametric polymorphism, in: R.E.A. Mason (Ed.), Information Processing, vol. 83, North-Holland,

Amsterdam, 1983, pp. 513-523.
[37] J.C. Reynolds, Polymorphism is not set theoretic, in: G. Kahn, D. MacQueen, G. Plotkin (Eds.), Semantics of Data Types, Sophia-Antipolis,

France, in: LNCS, vol. 173, Springer-Verlag, 1984, pp. 145-156.
[38] J.C. Reynolds, Introduction to part II: Polymorphic lambda calculus, in: G. Huet (Ed.), Logical Foundations of Functional Programming,

Addison-Wesley, 1990.
[39] J.C. Reynolds, Three approaches to type structure, in: Mathematical Foundations of Software Development, in: LNCS, vol. 185, SpringerVerlag, 1985.
[40] J.C. Reynolds, G.D. Plotkin, On Functors Expressible in the polymorphic typed lambda calculus, in: G. Huet (Ed.), Logical Foundations of

Functional Programming, Addison-Wesley, 1990, pp. 127-152.
[41] E.P. Robinson, G. Rosolini, Reflexive graphs and parametric polymorphism, in: S. Abramsky (Ed.), 9th Symposium in Logic in Computer

Science, IEEE Computer Society, 1994.
[42] I. Rummelhoff, Polynat is not universal in all PER-models. Manuscript, University of Oslo, September 2003.
[43] C. Strachey, Fundamental concepts in programming languages, in: Lecture notes, International Summer School in Computer Programming,

Copenhagen, August 1967. Reprinted in Higher-Order and Symbolic Computation 13 (1-2) (2000) 11-49.
[44] I. Takeuti, An axiomatic system of parametricity, Fundamenta Informaticae 33 (1998) 397-432. IOS Press.
[45] P. Wadler, Theorems for free!, in: 4'th International Conference on Functional Programming Languages and Computer Architecture, ACM

Press, London, September 1989.
[46] P. Wadler, Recursive types for free!, manuscript, 1991.
[47] P. Wadler, The Girard-Reynolds isomorphism, in: N. Kobayashi, B. Pierce (Eds.), Theoretical Aspects of Computer Software, in: LNCS, vol.

2215, Springer-Verlag, Sendai, Japan, October 2001, pp. 468-491.
[48] P. Wadler, The Girard-Reynolds isomorphism, Information and Computation 186 (2) (2003) 260-284. Special issue of best papers from TACS

2001.