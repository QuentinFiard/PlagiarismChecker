

Static Analysis of PostScript Code

R. Nigel Horspool and Jan Vitek
Dept. of Computer Science, University of Victoria

P.O. Box 3055, Victoria, BC, Canada V8W 3P6
nigelh@csr.uvic.ca  jvitek@csr.uvic.ca

 Stack-based languages, such as PostScript, present a major challenge to static analysis techniques because of their
almost unlimited polymorphism. We introduce a regular expression notation that is used to represent allowed combinations of types on the stack at different points in a PostScript program. Our abstract interpretation algorithm may
then be used to perform static type analysis. The analysis
has applications in detecting probable errors in the PostScript code or, ultimately, in permitting full or partial compilation of portions of code.

1. Introduction
The PostScript 1 language has become prominent as adevice-independent programming language used to control

high-resolution graphical output devices. It is an exampleof a stack-based language where every operator obtains its
arguments by popping values from a stack and pushes itsresult(s) back onto that stack. Other stack-based languages,
such as Forth and the command language of the UNIX  dc(desk calculator) program, exist. The techniques described
in this paper should be applicable to most other stack-based languages too.

The PostScript language provides a challenge to staticanalysis techniques because it is inherently polymorphic.
Not only can a function accept arguments with varyingtypes, but a function can accept differing numbers of arguments. For example, it would be an easy matter to programa function 

SumN whose first argument is an integer  N thatspecifies that 

N more numeric arguments are to be totalledand the sum returned as the function result. Thus, one

example call might be

123 -23 100 3 SumNwhich would leave a result of 200 on the stack. Another

sample call might be

1.5 2.3  2 SumNand that would leave a result of 3.8 on the stack. There are

no type declarations in PostScript nor any declarations toindicate the number of parameters that a function expects.
The only way to discover the argument structure of a func-tion like 

SumN is to trace through and analyze its code. Byobserving the effect on the stack and by inference of the

types of values popped from the stack, it  may be possibleto deduce a type signature for 

SumN. In general, the typeinference problem for a language like PostScript is undecidable. But, as in all problems where abstract interpreta-tion techniques are applied, it is possible to approximate
and the approximate results are often adequate.We have chosen to concentrate on type analysis. Our
goal is to deduce the patterns of types for values on thestack that exist before and after each operation in a PostScript program. Although we currently handle only a sub-set of PostScript and our techniques are (intentionally)
approximate in nature, we consider the results to be highlyencouraging. Further work to extend the language subset
and investigation of alternative analysis functions andalternative representations for stack states is planned.
Although abstract interpretation techniques [1] have beenused for type inference in functional languages and in Prolog, they have not, to our knowledge, previously beenapplied to a stack-based language. Stack-based languages
introduce a number of interesting problems that do nothave obvious solutions. Our initial implementation of a
static analyzer successfully performs type inference for asubset of PostScript, even if functions accept varying numbers and types of arguments, as with the  SumN example,above.

It might be argued that PostScript was never intended tobe a normal programming language where programs are
written by people. More usually, PostScript code is auto-matically generated by text formatting or graphics drawing
software. Furthermore, the PostScript code is intended tobe executed once only, rendering an image on the output
device, and then discarded. Why, therefore, should we beinterested in analyzing and verifying the correctness of
PostScript code? Why not just execute the code and find1. PostScript is a trademark of Adobe Systems Incorporated.

out if it works as intended? If one actually looks at thePostScript code generated by software, there is typically a
fixed structure. An initial segment of code containing astandard collection of functions is defined. Following this,
the actual formatted text or numeric descriptions of graph-ics images are supplied as arguments in calls to the previously defined functions. The functions are  not automati-cally generated (formatting software is not yet that clever),
they have been pre-programmed by a human programmerand they are simply copied into every PostScript file generated by the software. Since these functions will be usedevery time the software sends its output to the graphics
device, it is vitally important that they be efficient and becorrect. Static analysis can help to achieve both goals.
And, although PostScript was designed as a language to be
generated by software rather than people, there are indeedmany programmers who use PostScript to implement

graphical user interfaces (such as in the NeWS systemfrom SUN Microsystems). These programmers should
benefit from a tool that can direct their attention to possibleerrors in their code. A longer term goal of the research is in
the development of optimization techniques and, perhaps,a form of compilation for PostScript code.

The innovative feature of our work is in the use of arestricted form of regular expression notation to describe
combinations of types on the stack. These regular expres-sions represent particular values in the abstract domain
used in the analysis. We will then show how abstract inter-pretation may be applied in both the forwards and the
backwards directions to perform type inference on collec-tions of PostScript functions and to derive appropriate type
signatures. As a direct consequence of this analysis it ispossible to identify regions of the code that are 

definitelyerroneous (in the sense that if control should ever enter one

of these regions then abnormal termination of the programis certain to follow). A similar analysis could also identify
those regions of the program that might be erroneous. As apreview of the kind of analysis that we perform, consider a
PostScript program that performs the following series ofsix actions: 

1 Push a string constant.
2 Push n integers.
3 Push the integer n.
4 Invoke the SumN function.
5 Pop and output an integer (the result from

SumN).
6 Pop and output a string.In a forwards analysis of this code sequence, assuming

an initially empty stack, we can derive the followingsequence of stack states:

Position  i corresponds to the stack state immediatelyfollowing step number 

i in the code sequence, with posi-tion 0 corresponding to the initial stack state.  Each stack

state is written as a regular expression (RE) where therightmost symbol generated by the RE corresponds to the
topmost stack element. Observe that immediately after thecall to 

SumN in step 4, the analysis shows the possibilitythat additional integers remain on the stack below the function result.  Unless the stack states retain the value of n andunless the analysis uses this value to track the number of
times that  SumN pops an argument integer, we cannot besure that 

SumN pops all the integers that were supplied.However, when the analysis reaches step 6 where a string

needs to be popped, the analysis deduces that the  I* com-ponent of the pattern must actually be empty for the program to be correct. Backwards analysis may now be usedto make the stack state descriptions more precise.  Starting
with the result stack state, \Delta , at step 6, the analysis deducesthat the stack state should have been 

S at step 5.  Then, pro-ceeding one step further back, it deduces that the state

should have been  SI at step 4.  (The other stack states arenot changed.)

Abstract interpretation is concerned with static determi-nation of certain dynamic properties of programs. In other
words, abstract interpretation provides information on run-time properties of a program. Following the work of
Cousot [3], many practical frameworks have been speci-fied and implemented, notably in the field of functional
programming to perform strictness analysis or in-placeupdate analysis, and in PROLOG for mode and determinacy analysis. Abstract interpretation has also been usedfor automatic parallelization of imperative [5] and functional [6] programs. The technique relies on a mappingfrom the semantics of the original program with respect to
a certain property into approximate semantics. Approxi-mation is inevitable since any non-trivial analysis would
be based on dynamic control flow patterns and those areuncomputable.

A correct abstract interpretation will  always  find ananswer which 

includes the true answer. Equivalently, wesay that the approximation is 

conservative and that theanalysis procedure is guaranteed to terminate.

2. The abstract model
An interpreter for the PostScript language deals with typedvalues. Amongst the simple values that it must handle are

integers (such as 1, 99, -23), floating-point numbers (suchas 1.5, -3.0e-5), booleans (true and false), and strings (such
as "abc"). The model used for static analysis representsthese values by codes that denote only their types. We use
I to stand for integer values,  R for floating-point values, Bfor boolean values and 

S for string values. The effect of aPos
0 1 2 3 4 5 6

State \Delta  S S(I)* S(I)*I S(I)* S(I)* \Delta 

function or a block of code in PostScript can be understoodonly in term of its effect on the value stack. In the course of
execution of an actual PostScript interpreter, the entirecontents of the stack might, at one execution point, be

<5.0, "abc", -45, 123>
where the integer 123 is at the top of the stack. We repre-sent this stack by the type code sequence 

RSII. Sincefunctions and operators2 may be polymorphic, we need to

use sets of stack states when describing the effect of afunction or operator on the stack. The static semantics of
our Postscript subset can be expressed in terms of opera-tions on elements of the lattice L(S*), defined as follows.

Definition Let S be the set of type codes and S* be the setof type code sequences.   L(S*) is the complete lattice
formed by all the subsets of  S*, with partial ordering  \Theta , atop element or greatest upper bound  S*, a bottom element
or least upper bound  \Lambda ,  and meet and join operationsequivalent to the set operations \Sigma  and \Upsilon , respectively.

The sets that form the elements of L(S*) are potentially
unbounded in size (limited only by the maximum stackdepth permitted by a particular PostScript interpreter).

Therefore a representation that requires an explicit enu-meration of the elements of the sets is unsuitable for use by
static analysis algorithms. We believe that sequences oftypes that occur at the top of the stack will usually follow
simple patterns, and that regular expression notation isadequate to describe the patterns. For example, the type
signature of the SumN function, above, may be written as

SumN: (I|R)*I \Phi  (I|R)
Similarly, a function that draws lines connecting a series ofpoints on the page would possibly accept a sequence of

coordinate pairs as its arguments and the stack state priorto a call to this a function could be represented by the regular expression (RR)*.In the course of performing analysis by abstract interpretation, we will need to construct unions of sets of typecode sequences where control flow paths merge. Intersections of sets will be required to combine results of forwardand backwards analysis. Ideally, we would like to use a lattice whose elements are REs and where the glb (meet) andlub (join) operations correspond to intersection and union
of the sets. Unfortunately, we have not been able to con-struct a suitable lattice. Full RE notation does not guarantee compact representations for sets of stack states and alsoprovides many representations for the same stack state.
Instead, we have chosen to use a simplified and highlyrestricted form of RE notation, as explained below.

2.1 Alternation-free regular expressions.
In principle, algorithms to test for inclusion between tworegular expressions and to construct the union or intersection of two regular expressions as a new regular expressionexist. In practice, however, the algorithms are non-trivial
and too inefficient for use by an abstract interpretation pro-cedure that must iterate a large number of times over sections of PostScript code. We therefore use a subset of reg-ular expressions, a subset that we will refer to as 

Alternation-Free Regular Expression notation or AF-RE for short.The syntax of AF-REs is defined by the context-free grammar shown in Figure 1. Curly braces are grammatical nota-tion to represent zero or more repetitions of the enclosed
symbols. The partially ordered set  S# = S \Upsilon  {N,X} represents any of the elementary type designator codes ( I, R, S,
B,...) augmented by two extra type codes. N, for numeric, is
equivalent to the regular expression  (I | R) while  X, for
unknown, is equivalent to  ( I | R | S | ...). The partial orderrelation for elements of S# is defined as follows

I <=t N, R <=t N, N <=t N, N <=t X, X <=t X

\Omega  <=t X  and  \Omega  <=t \Omega ,      \Omega ff S# 
The relation <=s which compares two type codes sequencesof equal length is defined as the conjunction of  <=

t on pairsof corresponding type codes:

\Omega 1....\Omega n <=s fl1...fln, if  \Omega i <=t fli and i  ff [1, n]
 The implicit alternations inherent in the meanings of N and
X are the only forms of alternation provided in the AF-REnotation. Recalling that AF-REs are just a notation we use

to describe sets of sequences of types codes,  \Delta  representsthe empty sequence, the top symbol   is used to denote
the set of all possible sequences, and the bottom symbol  ffiis the empty set (meaning that no valid stack state exists).
As is conventional in regular expression notation, a super-script asterisk denotes zero or more occurrences of the preceding term and a superscript question mark denotes zeroor one occurrences. Thus the following five expressions
are valid instances of AF-REs.

(S)?RN(SIS)* (I)*I (RR)*I \Delta  X*
The final expression,  X*, denotes the universal set of
type code sequences and is equivalent to the top element,. The expression  \Delta  denotes an empty stack, which is a

legitimate stack state. Note that, as well as omitting

2.  This includes the standard Postscript control flow operators such as 
ifelse and loop.

afre \Phi  ffiafre \Phi  
afre \Phi  \Delta afre \Phi  conj {conj}

conj \Phi  (  S# {S# } )*conj \Phi  (  S# {S# } )?
conj \Phi  S# 
ffi

Figure 1   AF-RE grammar. 

ffi
ffi

explicit alternation, the notation does not permit nesting ofexpressions. For example, the expression 

(I(R)*)? is nota valid AF-RE.

2.2 Notational convention
In the remainder of the paper we adopt the following con-ventions: 

r and s denote arbitrary AF-REs, c and d are usedfor conjuncts that make up an AF-RE (e.g. (

I)*), Greek let-ters \Omega  and  fl represent single type codes (elements of  S#)

and * and _ represent sequences of type codes. Superscripthash marks are used to indicate abstraction. Juxtaposition
of terms, e.g. rs, denotes concatenation of AF-REs.
2.3 AF-RE operations
The AF-RE notation, as presented above, still providesmore then one expression to denote the same set of type

code sequences. To simplify algorithms that manipulateAF-REs, it is desirable to work with a simplified subset of
the AF-RE notation that restricts the number of differentrepresentations of a single set. A simplification procedure
that converts an arbitrary AF-RE into a restricted AF-REmay be written as a series of rewrite rules. These rules are
shown in Figure 2.An example of simplification for

 (SI)*S(IS)* is

(SI)*S(IS)*  *  (SI)*(SI)*S  * (SI)*S
The <=a relation between two AF-REs denotes inclusionof the corresponding sets of type code sequences. The truth

of the relationship  r <=a s for two simplified AF-REs maybe tested by the rules shown in Figure 3. In these rules a
sequence of zero conjuncts should be replaced by  \Delta  whenappropriate. The rules may be used to derive, for example,
I <=a (I)?(S)*.The AF-RE notation cannot describe all possible sets of
type code sequences. A consequence is that, given two AF-REs 

r and s, AF-REs that are equivalent to r \Upsilon  s or to r \Sigma  smay not exist. Algorithms that compute  

r \Upsilon s and  r \Sigma  smust, in general, be approximate. We require such algorithms for the abstract interpretation and we are thereforeforced to provide conservative approximations to the
results. These approximations to  \Upsilon  and  \Sigma , together withthe <=

a relation of Figure 3, do not form a lattice where the

elements are AF-REs. It is to be understood that theabstract domain for our analysis is  L(S#*), but that our
analysis uses only elements of the domain that have repre-sentations as AF-REs. Note that the only difference
between  L(S*) and L(S#*) is that the latter possesses addi-tional 

N and X codes. A partial diagram of the L(S#*) latticeindicating some lattice elements that have equivalent AFRE representations and one that does not is shown in Fig-ure 4. As the figure shows, the {

II,IS} value cannot berepresented by an AF-RE. If this value should arise in an

analysis, it must be approximated. Any higher value thatcan be represented by an AF-RE would be suitable.

We use the notation  , to represent our conservativeapproximate implementation of the join, \Upsilon , and ss to represent the conservative approximate implementation of themeet,  \Sigma  . In general, the implementations ensure that

 and   hold.

(*)*(_)*  *  (*)*,   if  _ <=s *
(*)*(_)*  *  (_)*,   if  *  <=s _
(*)*(_)?  *  (*)*,   if  _  <=s *
(*)?(_)*  *  (_)*, if *  <=s _
\Omega (\Omega *)*  *  (*\Omega )*\Omega 
\Omega (\Omega *)?  *  (*\Omega )?\Omega 

Figure 2   AF-RE Simplification Rules.

ffi  <=a r
r <=a T
\Delta   <=a \Delta 
r\Omega   <=a sfl if \Omega  <=t fl and r <=a s
r(*)*  <=a s(_)*, iff (* <=s_ and r <=a s) or r(*)* <=a s
r(*)?  <=a s, if r* <=a s and r <=a s
r(*)* <=a s, if r(*)** <=a s and r <=a s
r  <=a s(\Omega )?_, if r <=a s\Omega  or r <=a s
r  <=a s(\Omega )*_, if r <=as(\Omega )*\Omega  or r <=a s

ffi

ffi
  I   S  \Delta    II  SI...

  I* { SI, II }

  S?I?I   I?S?I

  I*S*

...

Figure 3   Inclusion Relation for AF-REs.
Figure 4   A Small Part of the L(S#*) Lattice. 
The shaded set of stack states does not have an AF...
...

...
...

r s\Upsilon  r s,\Theta  r s\Sigma  r sss\Theta 

The meet and join operations are essential to theabstract interpretation: the join is used whenever two control flow paths merge to unify information on the twopaths. The meet is used to refine the approximation
obtained from backward and forward passes of the analysisalgorithm. Meets and joins will be performed with great
frequency, so their cost dominates the overall cost of theanalysis. Efficiently computable conservative approximations to the true meet and join operations of the  L(S#*) lat-tice are therefore desirable. The actual meet operation,  ss,
used in our analysis is defined in terms of a disjointnessrelation,  

r # s, by the four rules shown in Figure 5. The dis-jointness relation provides a quick test as to whether two

sets of stack states are incompatible - that is, whether their
intersection  is  empty.  In  the  interests  of  execution  efficiency, the test is not required to return true in  all caseswhen the intersection is empty. That is, the  #  relationship

is defined so that  r # s implies that the intersection of thecorresponding sets in L(S#*), r \Sigma  s, is empty. The converse
does not necessarily hold. One suitable, simple, definitionis provided by the five rules given in Figure 6.

Similarly, the join operation on AF-REs is a conserva-tive approximation of set union. As an example of the possibilities,  BI  ,  SI  may be joined   as  (B)?(S)?I,
(BI)?(IS)? or even  XI. All are valid but different
approximations to the true set union, {BI,SI}. Dependingon the purpose of the analysis, we may prefer one approximation over another. For instance, the third form preservesinformation on the depth of the stack, the second keeps
related sequences of type codes in the same conjunct,while the first and third retain the fact that the top stack
element has the type code I.A non-deterministic definition for the join operation is
provided by the transformations of Figure 7 plus three

more  transformations  that  are  the  same  as  rules  6-8  withthe operands of , interchanged.

Of these transformations, the first two are the only onesthat do not introduce any approximation in the result.
Hence, when several results are possible, a result that usesthe first two transformations the most often is preferred.

3. The abstract interpretation algorithm
The PostScript language was designed for interpretationrather than compilation. The goal is most apparent in the

language's elegant but spartan syntax: a program is simplya sequence of operations, be they integers, operators or
code blocks. Each operation has a meaning that can beexpressed in terms of simple stack operations. An integer
constant, for example, should be viewed as an operationthat pushes an integer onto the stack.

The abstract interpretation algorithm will take advan-tage of that simple structure. We perform static analysis by
propagating abstract stack states through the program,alternating between forward and backward passes. The
AF-RE notation is used to represent these stack states. Foreach point in the program, forward analysis computes the
effect of the next operation in the sequence on the currentstack state, the result is then intersected with the previous
estimate. This guarantees that each pass can only give amore accurate result, in other words that we progress down
the lattice. Thus, for a program consisting of a linearsequence of 

n operations, we have n formulae of the form:

pp'i+1 := ci(ppi) ss ppi+1
which, given initial approximations to two consecutivestack states 

ppi and ppi+1, computes a better approximation
pp'i+1. Of course, each operation  ci is defined on theabstract domain.

For non-sequential programs such as programs usingthe conditional operator 

ifelse, the generalization isobvious: we take the union,  ,, of all predecessors of a

point.Backwards analysis reconstructs possible stack states
from the results of applying an operator. We need to perr ss s = r, if r <=a s
r ss s = s, if s <=a r
r ss s = ffi, if r # s
r ss s = r or s, otherwise

Figure 5   The Meet Operation ss
r\Omega  # \Delta 
\Delta  # r\Omega 
r\Omega  # sfl, if r # s or

  not (\Omega  |<=t fl or fl |<=t \Omega )
rc # s if r # s
r # sc if r # s

Figure 6   The Disjointness Function #

1 r\Omega  , sfl * (r , s)\Omega , if  fl <=t \Omega 2

r\Omega  , sfl * (r , s)fl, if  \Omega  <=t fl

3 rI , sR * (r , s)N
4 rR , sI * (r , s)N
5 r\Omega  , sfl * (\Omega  , s)X
6 r\Omega  , sfl  * (r , s) (fl)?(\Omega )?
7 r , s(*)? * (r , s)(*)?
8 r , s(*)* * (r , s)(*)*

Figure 7   The Join Operation ,

form backwards passes for two reasons. First, to analyzethe type of a function we need to know what it expects on
the stack before being invoked; forwards analysis can onlygive answers on the state of the stack 

after the function hasbeen executed. Second, to improve the result of the analysis by propagating information on how values are used. Forinstance, consider a program that contains a conditional
branch which, if executed, leaves a string on the stack. Ifthe conditional branch is followed by an arithmetic operation, we can conclude that the program is erroneous (or, atleast, redundant) since, if that branch is ever taken, a runtime error is guaranteed to occur. Backwards analysis usesabstract inverse functions,  c

i-1, to describe the inverseeffects of operations on the stack. For each program point,

ppi, we apply a formula

pp'i := ci-1(ppi+1, ppi) ss ppi
that yields a more precise estimate of the stack state at ppi.For backwards analysis in a conventional language like

Pascal, the inverse function used in the formula would takethe form  c

i-1(ppi+1). However, as we explain later, theinverse functions for certain PostScript operations (such as

the ifelse operator) require additional information to beable to compute a useful result.

The overall analysis is performed by a simple iterativealgorithm (similar to one given in [2]). The initial assumption is that at each program point any stack state is possi-ble. (If a complete program is being analyzed, the initial
stack state may be set to empty.) The algorithm stops if nostack state changes in the course of one iteration.

for i := 0 to n do

ppi := X* -- Recall that X* is

 -- equivalent to  .
repeat

for i := 0 to n-1 do

ppi+1 := ci(ppi) ss ppi+1
for i := n downto 1 do

ppi := ci-1(ppi+1, ppi) ss ppi
until a fixpoint is achieved

3.1 Abstract operators
So far we have not discussed the meanings of individual
PostScript operators. Abstract interpretation requires thatall operations in the concrete domain be mapped into corresponding operations in the abstract domain with respectto their effects on the stack.  In addition, backwards analysis requires that the inverse of every operation be defined.All of these operations may be defined in terms of two
stack manipulation operations: pushing a value onto thestack, and popping a value off the stack. Our push # and
pop# operations have unconventional definitions, however,because they operate on sets of stack states. That is, push #
must prefix a type code to every element of the set of
states, whereas pop# must attempt to remove a leading type

code from every element of the set  - discarding elementsthat would be inconsistent with the pop operation. To
improve the precision of the analysis, pop# tries to removea particular type code from the stack. For example
pop#(I, S*) = ffi, because no stack state described by  S*has an 

I at its top. On the other hand, pop#(I, I(S)?) = \Delta and pop#(

I, I(S)?I?) = I?S?.Definitions for push# and pop# are given in Figure 8. As

before, we use * to denote a sequence of conjuncts, \Omega  as anarbitrary sequence of type codes, and 

t and u stand for sin-gle type codes.  Needless to say, the results of the push #

and pop# operations usually require simplification.The analysis of a simple PostScript function, 

triple,

/triple { 3 mult } def
which multiplies its argument by three can now be demon-strated. This function first pushes the integer 3 on the

stack, then the multiplication operator pops the two top-most elements and pushes their product back on the stack.
The semantic equations for triple are shown in Figure 9. Inthe semantic equations, 

3#, mult#, 3#-1 and mult#-1 rep-resent the given abstract functions and their inverses. (The

definitions for  mult and  mult#-1 assume that both argu-ments are integers; a more general definition for the polymorphic case is given later.)The stack states at the three program points marked in
the code are named pp1, pp2 and pp3. If we begin with theassumption that the stack state at program point  

pp1 is X*(representing an unknown stack state), just one iteration

with the forwards and backwards equations will deduce thestack states shown in the following table.

ffi

0 1f 1b
pp1 X*I
pp2 X*I X*II
pp3 X*I X*I

pop#(\Omega , ) = 
pop#(\Omega , sfl) = s, if \Omega  |<=t fl
pop#(\Omega , s(*fl)?) = pop#(\Omega , s) , s*, if \Omega  |<=t fl
pop#(\Omega , s(*fl)?) = pop#(\Omega , s), if not \Omega  |<=t fl
pop#(\Omega , s(*fl)*) = pop#(\Omega , s) , s(*fl)**, if \Omega  |<=t fl
pop#(\Omega , s(*fl)*) = pop#(\Omega , s), if not \Omega  |<=t fl
pop#(\Omega , s) = ffi, otherwise

push#(\Omega , ffi) = ffi
push#(\Omega , s) = s\Omega 

Figure 8   Abstract Stack Manipulation Operations

ffi ffi

ffi ffi
ffi
ffi

The column headed  0 shows the initial stack states, thecolumn headed 1f  shows the states after the forward pass
(computed in the order   pp1, pp2, pp3), while the  1b col-umn shows them after the backward pass (computed in the
order pp3, pp2, pp1). It is possible to deduce from the  pp1and 

pp3 states (and the fact that the  X* component of thestack description is never expanded) that the signature of

the triple function is I \Phi  I.
4. The extended abstract model
4.1 Using values
Some primitive operators in PostScript require more pre-cise analysis than that permitted by AF-RE descriptions of

stack states if we wish to derive useful signatures for user-defined functions. PostScript has some polymorphic operators whose effect on the stack depend on the values of oneor more of their arguments. To be able to perform useful
analyses, it is essential to know these values. The analysisused in our implementation attempts to keep track of two
kinds of values - integer values and code block values.Integer values are essential for determining the effect of
the roll operator. It is used to perform a circular shift on asegment of the stack. The 

roll operation first pops twointegers 
j and n. It then rotates the next n stack elements by
j positions. For example applying the  roll operation tothe stack state 

<"b",4,"a",  3,  1> results in the state
<"a","b",  4> and applying it to  <"b",4,"a", 2, 1>results in 

<"b","a", 4>. Clearly, we would usually needto know the values of the two control integers in order to

be able to construct a description of the stack state after
roll is executed.

Code block values are needed if we are to be able tohandle control constructs as simple as an if-then-else or a
while loop. Any sequence of operations may be enclosedby curly braces to form a code block. When the bracketed
group is encountered in a program, the interpreter pushes areference to that code block on to the stack. The operations
inside that code block are not executed at that time. A con-trol flow operation, such as 

ifelse, may be used to selecta code block and execute it. The 

ifelse operation takestwo code blocks and a boolean as its arguments. Depending on the boolean value, it executes one of the two codeblocks, discarding the other. Consider, for example, a
function that takes three integers as its arguments. If thefirst integer is zero, it returns the sum of the two other integers. Otherwise, it returns the difference of the two otherintegers. The signature and the code for the function are

add_or_sub: I I I \Phi  I
/add_or_sub {0 eq {add} {sub} ifelse} 
def

where eq is the equality test. As well as illustrating code
blocks, the example is also intended to convince you that itis impossible to construct a standard control flow graph for

PostScript without first performing reaching analysis oncode block values. If it fails to do that, consider the following (ugly) example:

{add}{sub} 3 1 roll 0 eq 3 1 roll ifelse
Here the code block values accessed by the ifelse cannotbe discerned without analyzing the effects of the two uses

of the  roll operator. Even more inscrutable exampleswould be easy to construct.

We handle values by extending S#, making it a lattice.For instance, each 

I type code that appears in an AF-REhas an associated value attribute. The attribute may hold an

integer value, or it may hold a code to indicate that novalue is known, or finally it may hold a code to indicate
that there is no unique integer value. The attribute valuesof course form a trivial lattice, with a suitable  <=

t relation.The abstract semantics of an integer constant operator such

as 2 are expanded to set the value attribute of the  I typecode in the resulting stack state description. Similarly, the

abstract semantics of arithmetic operations such as  addand 

mult are expanded to compute resultant valueattributes when possible. Whenever two 

I type codes withconflicting values must be unified (perhaps as a result of

simplifying), the value attribute is tagged to show multiplevalues are possible. This simple analysis of integer values
is normally sufficient to handle an operator like  roll.(Inspection of typical PostScript code shows that 

roll isalmost always used with integer constants for its first two

arguments.) When the value attribute is important to theanalysis, we will show the value as a subscript. Thus, the

3 multpp1 pp2 pp3
Forwards Equations

pp2 = 3#(pp1) ss pp2

pp3 = mult#(pp2) ss pp3
Backwards Equations

pp1 = 3#-1(pp2,pp1) ss pp1

pp2 =  mult#-1(pp3,pp2) ss pp2
where 3#       = o/s.push#(

I,s)

3#-1      = o/s.o/s'.pop#(I,s)
mult#     = o/s.push#(I,pop#(I,pop#(I,s)))
mult#-1 = o/s.o/s'.pop#(I,push#(I,push#(I,s)))

Figure 9   Semantic Equations for Triple Function

stack state at the program point immediately before the
roll operation in

"b" 4 "a" 3 1 roll
would be written as SI4SI3I1.Code blocks are handled in an analogous manner. Each

code block that appears in the PostScript program is sim-ply numbered. A reference to a code block on the stack is
represented by a type code of C with a subscript to identifythe particular code block. Thus, if the two code blocks in
the add_or_sub example are numbered 1 and 2, the stackstate immediately before the 

ifelse operation would bedescribed by 
BC1C2. Forwards analysis of the  ifelseoperation requires that the operations contained in both

code blocks be analyzed and the resulting stack states arethen joined. If either of the code blocks cannot be identified, the resulting stack state will be represented by  X*.Backwards analysis is a little more complicated because
the stack state that follows the  ifelse does not showwhich code blocks form the 

then and  else components ofthe operation. Our solution is to include the stack state

immediately before the  ifelse in the backwards equa-tion.

4.2 Using function signatures
PostScript functions and operators only affect the top ofthe stack, so when representing their type signatures only

the topmost elements of the stack state that are actuallyused will be represented, the remainder of the stack will be
assumed to be unchanged. As an example, the primitiveoperator for addition requires nine type signatures to
describe it fully:

add: II \Phi  I add: IR \Phi  R add: RI \Phi  R
add: RR \Phi  R add: IN \Phi  N add: RN \Phi  R
add: NI \Phi  N add: NR \Phi  R add: NN \Phi  NThe signatures determine the corresponding abstract functions for addition and its inverse (used in the backwardsanalysis). The forwards equation may be written as:3

add# = o/s.( push#(I,pop#(I,pop#(I,s))) ,

 push#(R,pop#(R,pop#(I,s))) ,
 push#(R,pop#(I,pop#(R,s))) ,
 push#(R,pop#(R,pop#(R,s))) )

And the inverse operation used in the backwards analysismay be written as:

add#-1 = o/s.( push#(I,push#(I,pop#(I,s))),

 push#(N,push#(N,pop#(R,s))) )

The numeric type code  N must be used in the inversefunction because a result type of 

R does not unambiguouslyimply the types of the two input arguments. However,

intersection of the AF-RE generated by  add#-1 with theprevious estimate of the stack state would often cause the 

Nto be replaced by 
I or R again.

5. Abstract interpretation of loops and 

recursion

5.1 Widening
A simple loop that pushes a value on the stack with eachiteration is a potential problem. For example, if the extra

value is an integer, the stack state after one iteration mightbe 

I. A second iteration would lead to the stack state  II,and joining with the result of the first iteration leads to the

set of possible stack states being { I, II} (to allow for the
possibility that the loop exits after either one or two itera-tions). Similarly, a third iteration leads to {

I, II, III},
and so on. The join operation that is used to combine thestates into a single AF-RE would generate successive

results of I, I?I, I?I?I, and so on. It is clear that no mat-ter how many iterations are analyzed, we will not reach a
fixpoint, and the analysis will never terminate. It is a well-known problem in abstract interpretation [6].

A standard solution to the termination problem is towork with a lattice with a finite height. You would then be
guaranteed that a fixed number of analysis iterationsthrough any loop will reach a fixpoint, even if that fixpoint
is  . In our case, we could make the lattice finite byrestricting the number of terms in an AF-RE. However,
that would introduce an arbitrary degree of approximationin our static analysis. An alternative approach, named 

widening, has been proposed by Cousot [3]. Stransky has usedthe technique for analyzing Lisp [6]. Widening corresponds to the intuitive approach of guessing a pattern to thesequence of abstract values and thereby allowing a direct
jump to the limiting value. In the case of the particularsequence 

I, I?I, I?I?I, a human would probably have no
trouble in guessing that  (I?)nI would describe the  n-thvalue. The limit of the sequence is obviously 

I*I, and that
would be the fixpoint.We implement the widening approach too, and that

forced us to specify the most general patterns that wewould look for in successive stack state representations.
We check for two different patterns. The first pattern cor-responds to a stack that is growing because of values being
left on the stack by each iteration or recursive call. It is:

r1 r2 r3 * r1 * r2 _ r3  * ... *  r1 (*)* r2 (_)* r3
where each r represents a group of conjuncts in our AF-REnotation and Greek letters represent sequences of type

codes. The  r1 is intended to correspond to the bottomregion of the stack that is unaffected by the loop or recursion. The r3 is intended to correspond to, for example, loop
3. A variant of pop# that extracts two type codes from the stack would 
(sometimes) yield more precise results. It would also simplify these 
semantic equations.

ffi
control values that are pushed onto the stack at the end ofan iteration in order to be consumed by the loop control
test. The fundamental pattern is really

r * * r _ * ... * (*)* r (_)* 
The * term corresponds to values that are pushed ontothe stack before a recursive call, and the  _ term corresponds to values pushed after a recursive call. Of course,either or both of the  *  and  _ terms may be empty. The
same pattern should describe the effect of a typical loopthat generates values on the stack.

The second pattern corresponds to a loop or functionthat consumes values (our 

SumN function would be anexample). The pattern we look for is:

r1 * r2 * r1 (*)? r2
In this case, we do not need to predict the fixpoint becauseonly a finite number of iterations (determined by the complexity of the initial AF-RE) will be needed before a limit-ing value is reached. For example, an analysis of a recursive formulation of SumN called with four integers initiallyon the stack would likely progress through the sequence of
states IIII, III? I, II?I?I, and  I?I?I?I. The finalexpression is the limit value. (The final state is not 

Ibecause, unless we use the value of the count integer, we

cannot be sure that all the integers are arguments con-sumed by 

SumN.)We implement widening by a function    that  takes

three arguments: two AF-RE values and an integer N, rep-resenting the number of iterations that have been performed. The AF-REs represent the stack states on the latesttwo iterations.

The result of   is an approximation to these AF-REarguments, with a precision controlled by 

N. If our imple-mentation of (S

1, S2, N) finds that the second pattern (acontracting stack) is applicable, the result is simply S

2. Ifour implementation finds the first pattern (a growing stack)

is applicable, the result for N=1 and N=2 is S 2. For N=3,the result is the predicted limit value of the sequence. For

N>3, the result is S 1 if S 1 and S2 are equal, otherwise theresult is 

X* (a totally arbitrary stack). The N>3 case han-dles the situation when the predicted limit value turns out

not to be a fixpoint. Since  X* is the top of the lattice, it isguaranteed to be a fixpoint, but one that unfortunately
throws away all information about the loop or function.Finally, if the sequence of stack states does not fit either of
our patterns, the result is again X*.If we keep iterating through the code of a loop or a
recursive function and apply  after each iteration, we areguaranteed that we will reach a fixpoint in a finite number
of steps (at most four steps for the growing stack pattern).We cannot, of course, guarantee that the fixpoint is the
least fixpoint (which would give the most precise descrip-tion of the effect of the code).

5.2 An example
Our example is a function  ReadList that inputs a series ofnumbers, until a zero is read. The result of the function is

the count of the number of values read followed by thosevalues. (Thus, 

ReadList could be used to set up argumentvalues for the 
SumN function used as an earlier example.)The code for 

ReadList uses an auxiliary function
ReadList1. They are defined as follows:

/ReadList {0 ReadList1} def
/ReadList1 {ReadInt dup 0 eq 

{2 1 roll 1 add ReadList1} {pop}
ifelse} def

(ReadInt is assumed to be a function that reads an integervalue onto the stack.)

We begin with a brief explanation of the code. On entryto the 

ReadList1 function, the stack is assumed to alreadyhold a count followed by that number of integers. For

example, the stack state might be <23, 7, 15, 3>. Supposethat 

ReadInt obtains 17 as the next value, leaving it on thestack. Then 

dup will duplicate that value, and 0 will push azero to obtain the state <23, 7, 15, 3, 17, 17, 0>. Next, 

eqpops and compares the top two values for equality, replacing them by the result false. The ifelse operator is there-fore reached with the stack holding <23, 7, 15, 3, 17, false,
c1, c 2> where c2 and c1 denote references to the two codeblocks. The 

ifelse operator pops three values and selectscode block c

1 for execution. The code block is entered witha stack state of <23, 7, 15, 3, 17>. It uses roll to rotate the

top two values, yielding <23, 7, 15, 17, 3>. It adds one tothe top value yielding <23, 7, 15, 17, 4> and then recursively calls  ReadList1 again. The function is re-enteredwith the stack again holding a count followed by that number of values. Finally, when a zero is read, the  ifelseexecutes the 

pop to remove the zero value from the stackand the recursion unwinds.

If our algorithm is asked to analyze the calling code:

" total" ReadList SumN PrintInt PrintStr
it will compute the sequence of stack state values shown inthe table below. These are the values at a program point

located just after a return from the call to ReadList1 locatedinside 

ReadList..

Iteration,N PreviousValue, S

1

New Value,

S2 (N,S1,S2)

1 X* SI SI
2 SI SII? SII?
3 SII? SII?I? SII?I**

 SII**
 SI*I

4 SI*I SI*I SI*I

The effect of the widening function   is shown explic-itly in the table. Initially, the stack state at the program
point is shown as X*. When forwards analysis reaches thatprogram point for the first time, a stack state of 

IS isobtained. These two stack states, plus the iteration number

(1), are supplied as arguments to  yielding a result of IS.Two more iterations through the function definition generate the states shown, reaching line 3 where wideningextrapolates the effect of the function to 

SII?I*. Simplifi-cation of this expression yields the form

 SI *I and onefinal iteration verifies that this is indeed a fixpoint.

6. Discussion
The results achieved so far are only a beginning. The prob-lem of analyzing a stack-based language like PostScript

has turned out to be an order of magnitude more difficultthan analysis of a typical imperative language like Pascal.
It is also considerably more difficult than for a polymor-phic language like ML or Prolog. We feel, however, that
we have achieved our initial goals successfully. We areable to analyze a rich subset of PostScript, describing the
stack states using a notation, AF-RE, that is readily intelli-gible to people. The analysis techniques achieve precise
results on simple code and approximate, but conservative,results on more involved code. The results of the analysis
can assist program verification by identifying erroneouscode and could form the basis for a PostScript compiler or
optimizer by finding function arguments that have fixedtypes.

In the future, we intend to explore alternative analysistechniques to see whether they can achieve more precise
results without becoming computationally infeasible. Onepossibility is to drop the use of regular expression notation
for stack states and use finite state automata (FSAs)instead. Since the regular languages are closed under union
and intersection, we could use FSAs as the lattice of valuesin the abstract domain, (We wonder, however, whether we
would be able to invent a suitable widening operator foruse with FSA values.)

We are, of course, still a long way from handling thefull PostScript language. Variables are, perhaps, the biggest omission. In full PostScript, a value may be bound to aname in the same way as a function definition is bound to
the function's name. For example,

/counter 0 def
(the / prefix indicates a name as opposed to a value). Subsequently, the identifier  counter (without the prefix) maybe used to refer to the associated value, 0. Since the 

defoperator may also be used to re-define the value of

counter, counter acts like a variable. Our current subset ofPostScript does not include variables because of the
dynamic scope structure of PostScript. The PostScript

interpreter maintains a separate stack of dictionaries, andeach dictionary holds bindings of names to values. A name
lookup involves a search of these dictionaries in stackorder. A PostScript program may create new dictionary
objects dynamically and may manipulate the dictionarystack. We therefore cannot handle variables in a manner
that would be true to the spirit of PostScript until we haveincorporated dictionary objects into our analysis. (The
NeWS dialect encourages extensive use of dictionaries toemulate objects in an object-oriented style of programming.)Static analysis of the 

full PostScript language is animpossible goal. In principle, it is possible to re-bind any

predefined operator to make it execute different code.
When  combined  with  the  possibility  that  a  program  mayread or create a text string and dynamically convert that

string into a code block with the  cvx operator (convert toexecutable), a safe static analysis could not continue after a
use of cvx. After that point, you could not be sure that anyoperator still performed the same operation. A permanent
restriction to a subset of PostScript where operators mayonly be re-bound to code with identical function signatures
would appear to be necessary (and quite sensible too).PostScript is truly an interesting language.

References
[1] S. Abramsky and C. Hankin, An Introduction to AbstractInterpretation in Abstract Interpretation of Declarative

Languages, Abramsky and Hankin, Ellis Horwood, 1987.
[2] A. V. Aho, R. Sethi and J. D. Ullman,  Compilers: Prin-ciples, Techniques and Tools, Addison-Wesley (1986).

[3] P. Cousot and R. Cousot,  "Abstract Interpretation: A Uni-fied Lattice Model for Static Analysis of Program by Construction or Approximation of Fixpoints," 4th POPL , LosAngeles, CA (January 1977).

[4] P. Cousot,  "Semantic Foundations of Program Analysis, "in Program Flow Analysis: Theory and Applications, S. S.

Munchnick, and N. D. Jones (editors), Prentice Hall, 1981.
[5] L. J. Hendren,  "Parallelizing Programs with RecursiveData Structures," Ph.D Thesis, TR-90-1114, Cornell University, April 1990.
[6] J. Stransky, "Analyse se'mantique de structures de donne'esdynamiques avec applications au cas particulier de langages LISPiens," PhD Thesis, Universite' de Paris-Sud, Centred'Orsay, June 1988.