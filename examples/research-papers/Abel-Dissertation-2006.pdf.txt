

A Polymorphic Lambda-Calculus

with Sized Higher-Order Types

Andreas Abel

June 19, 2006

2
Contents
1 Introduction 71.1 Why Termination? . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.2 Approaches to Termination . . . . . . . . . . . . . . . . . . . . . 91.3 Why Type-Based Termination Matters . . . . . . . . . . . . . . . 10
1.4 Informal Account of Type-Based Termination . . . . . . . . . . . 121.4.1 A Semantical Account of Type-Based Termination . . . . 12

1.4.2 From Semantics to Syntax . . . . . . . . . . . . . . . . . . 141.5 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2 Sized Higher-Order Subtyping 192.1 Constructors and Polarized Kinds . . . . . . . . . . . . . . . . . 19

2.1.1 Polarities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192.1.2 Kinds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.1.3 Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . 212.1.4 Kinding . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.1.5 Equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272.2 Higher-Order Subtyping . . . . . . . . . . . . . . . . . . . . . . . 28
2.3 Semantics and Soundness . . . . . . . . . . . . . . . . . . . . . . 292.3.1 Interpretation of Kinds . . . . . . . . . . . . . . . . . . . . 30

2.3.2 Semantics of Constructors . . . . . . . . . . . . . . . . . . 32
3 Type-Based Termination 373.1 Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

3.1.1 The Language . . . . . . . . . . . . . . . . . . . . . . . . . 373.1.2 Typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.1.3 Operational Semantics . . . . . . . . . . . . . . . . . . . . 413.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.2.1 Fibonacci Numbers . . . . . . . . . . . . . . . . . . . . . . 463.2.2 Co-Natural Numbers . . . . . . . . . . . . . . . . . . . . . 46
3.2.3 Some Pathological Cases . . . . . . . . . . . . . . . . . . . 463.2.4 Huffman Trees . . . . . . . . . . . . . . . . . . . . . . . . 47
3.2.5 Prime Numbers . . . . . . . . . . . . . . . . . . . . . . . . 503.2.6 Sorting by Merging . . . . . . . . . . . . . . . . . . . . . . 50
3.2.7 A Heterogeneous Data Type of Lambda Terms . . . . . . 52

3

4 CONTENTS

3.2.8 Substitution for Finite and Infinite Lambda-Terms . . . . 54
3.3 Limits, Iteration, and Fixed-Points . . . . . . . . . . . . . . . . . 56

3.3.1 Limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
3.3.2 Operator Iteration . . . . . . . . . . . . . . . . . . . . . . 57
3.3.3 Fixed points . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.3.4 Inductive and Coinductive Constructors . . . . . . . . . 60
3.3.5 Soundness of *-Dropping . . . . . . . . . . . . . . . . . . 61
3.4 Semantical Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

3.4.1 Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.4.2 Admissible Types for Recursion . . . . . . . . . . . . . . 65
3.4.3 Refined Saturation . . . . . . . . . . . . . . . . . . . . . . 66
3.4.4 Admissible Types for Corecursion . . . . . . . . . . . . . 68
3.4.5 Lattice of Saturated Sets . . . . . . . . . . . . . . . . . . . 69
3.5 Soundness of Typing . . . . . . . . . . . . . . . . . . . . . . . . . 72

3.5.1 Admissible Types for Recursion, Syntactically . . . . . . 72
3.5.2 Admissible Types for Corecursion, Syntactically . . . . . 73
3.5.3 Soundness Proof . . . . . . . . . . . . . . . . . . . . . . . 74
3.6 Strong Normalization . . . . . . . . . . . . . . . . . . . . . . . . . 77

3.6.1 A Few Remarks on the Method . . . . . . . . . . . . . . . 77
3.6.2 Inductive Characterization . . . . . . . . . . . . . . . . . 78
3.6.3 Soundness of the Inductive Characterization . . . . . . . 81

4 Embeddings into F!b 85

4.1 An Iso-Recursive Version of F!b . . . . . . . . . . . . . . . . . . . 85
4.2 Some Systems for Termination . . . . . . . . . . . . . . . . . . . 87
4.3 Some Systems For Productivity . . . . . . . . . . . . . . . . . . . 88
4.4 Iteration and Primitive Recursion . . . . . . . . . . . . . . . . . . 89

5 Continuity 93

5.1 On the Necessity of Criterion 2 . . . . . . . . . . . . . . . . . . . 94
5.2 Semi-Continuity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
5.3 Type Constructors and Semi-Continuity . . . . . . . . . . . . . . 97

5.3.1 Function Space . . . . . . . . . . . . . . . . . . . . . . . . 99
5.3.2 Universal Quantification . . . . . . . . . . . . . . . . . . . 100
5.3.3 Coinductive Types . . . . . . . . . . . . . . . . . . . . . . 101
5.3.4 Inductive Types . . . . . . . . . . . . . . . . . . . . . . . . 103
5.3.5 Product and Sum Types . . . . . . . . . . . . . . . . . . . 107
5.4 A Kinding System for Semi-Continuity . . . . . . . . . . . . . . 107
5.5 Semantical Soundness of Continuity Derivations . . . . . . . . . 110
5.6 Type-Based Termination with Continuous Types . . . . . . . . . 114
5.7 Related and Future Work . . . . . . . . . . . . . . . . . . . . . . . 114

CONTENTS 5
6 Examples 1176.1 Breadth-First Tree Traversal . . . . . . . . . . . . . . . . . . . . . 117

6.2 Continuous Normalization of Infinite De Bruijn Terms . . . . . . 1216.3 Normalization of Simply-Typed De Bruijn Terms . . . . . . . . . 123
6.4 Data Types with Higher-Order Parameters . . . . . . . . . . . . 1266.5 Generic Programming . . . . . . . . . . . . . . . . . . . . . . . . 128
6.6 Impredicative Data Types . . . . . . . . . . . . . . . . . . . . . . 1336.7 Inductive Proofs as Recursive Functions . . . . . . . . . . . . . . 134

7 Extensions 1377.1 Mutual Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

7.2 More Admissible Types . . . . . . . . . . . . . . . . . . . . . . . 140
8 Conclusion 1438.1 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

8.1.1 Termination Proofs . . . . . . . . . . . . . . . . . . . . . . 1448.1.2 Termination Checking . . . . . . . . . . . . . . . . . . . . 146
8.1.3 Sized Types . . . . . . . . . . . . . . . . . . . . . . . . . . 148
A Summary of F!b 151A.1 Kinds and Constructors . . . . . . . . . . . . . . . . . . . . . . . 151

A.2 Terms, Typing and Reduction . . . . . . . . . . . . . . . . . . . . 153A.2.1 Static Semantics . . . . . . . . . . . . . . . . . . . . . . . . 154

A.2.2 Admissible Recursion Types . . . . . . . . . . . . . . . . 154A.2.3 Dynamic Semantics . . . . . . . . . . . . . . . . . . . . . . 155
A.3 Semi-Continuous Types for Recursion . . . . . . . . . . . . . . . 155
B Iso-Coinductive Constructors 157B.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

B.2 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158B.3 Strong Normalization . . . . . . . . . . . . . . . . . . . . . . . . . 162

C Galois Connections 167
Bibliography 169
Index 183

6 CONTENTS
Chapter 1
Introduction
This thesis is on termination of computer programs. By termination we meanthat the task given to a computer is processed in a certain amount of time, as
opposed to taking infinitely long. Termination is the expected behavior of acomputer; it does not make sense to wait infinitely long for its response. Some
tasks take longer, e. g., booting, or calculating an airline schedule. Some takeshorter, like, after a key press in a word processing program, displaying the
new letter on the screen. Some take a variable time, like executing a commandat the command prompt. Some tasks might indeed never end, like producing
an even number greater or equal to four which is not the sum of two primenumbers. This task, call it

goldbach, will run forever, if, as Goldbach con-jectured,1 there exists no such number. Since the Goldbach conjecture is neither proven correct nor refuted,2 with our current knowledge we cannot judgewhether

goldbach will terminate or not.Of course, we would like to know whether a computer program terminates

before we start it. Otherwise we might sit there and wait for termination like onewaits for a late bus, which will, by Murphy's law, arrive exactly the minute
after one has taken a taxi instead. The only way to tell whether a programwill terminate without running it is to look at its internal structure, e. g., the
sequence of instructions which make up the program. Compare this to a biolo-gist who cuts up a frog in order to understand its behavior. Although a frog is
magnitudes more complex in functionality3 than the biggest information sys-tem ever constructed, this analogy gives some intuition on what it means to
grasp the meaning of a large computer program. In this light, the followingnegative solution to the Halteproblem, which is as old as the first computers,
does not surprise:

There is no computer program which can take any (other) computerprogram and decide whether it terminates on some given input.

1The "Goldbach conjecture" in this form is actually due to Euler, see MathWorld [Wei05].
2As of today, the Goldbach conjecture has been confirmed for number up to 2 * 1017 [Wei05].
3The reader may excuse my comparison of a higher living being to something entirely mechanical like a computer program.

7

8 CHAPTER 1. INTRODUCTION
This theorem has a simple proof by contradiction: Suppose there is such aprogram D. Then we can write a program E which takes the code of some
program P as input, asks D whether P terminates on input P, and enters aninfinite loop if D says "yes". Now run E on its own code. If E terminates on

E, then D says "yes", hence E does not terminate on E. Otherwise, if E doesnot terminate on E, D will say "no", hence E will terminate on E. This is a
contradiction, 4 and thus, program D cannot exist.The negative solution to the Halteproblem destroys the hope of finding a
automated termination checker which works on any kind of program. Thereare two escapes from this dilemma:

1. Use human intuition and reasoning to check termination.
2. Write a termination checker which works on a certain, restricted class ofprograms.

In practice, both methods are indispensable. In this thesis, we describe someclass of terminating programs. But however big one may make the class, there
will always be an interesting program whose termination cannot be verifiedcompletely automatically but requires at least some hint by a human who understands the program.

1.1 Why Termination?
But is termination really interesting? Would we not rather want to know howlong the execution of a program takes? This is certainly true in real-time and
embedded systems, like the hard- and software assisting the navigation of au-tomobiles and planes. There, the system must react instantaneously, e. g., within
milliseconds; termination is surely not sufficient. But there are other applica-tions for termination:

1. Verified termination increases the chance that the program is correct. Thisargument has been put forward by Xi [Xi01] and has an analogy in static

typing. Empirically, programs in strongly typed languages like Haskelland ML often work correctly already after they passed the compiler. The
type checker spots many bugs, which would--in the absence of typechecking-- have surfaced one after another at runtime. In the same way,
a termination checker could spot additional bugs which cannot be de-tected by the type checker. 5

4The propositions A =) ~A and ~A =) A are contradictory even in intuitionistic logics.
5For example, I had written the following ML function.

fun fromto (from, to) = if from ? to then [] else from :: fromto (from*1, to)
This program should output a list of integers starting with from and ending in to. The type infer-ence of ML assigns it the expected type

int * int -? int list, but upon execution, e. g., fromto
(2, 641), it loops. It is supposed to return the empty list if from is greater or equal to to, and,otherwise, the element

from plus the sequence from+1..to which is computed recursively. Here

1.2. APPROACHES TO TERMINATION 9

2. It is agreeable that compilers and program generators should terminate.However, to optimize the target program, they might have to partially

evaluate the source code. Partial evaluation has to be restricted to theseparts of the source which terminate; hence, termination has to be checked
before evaluation. This is the motivation for Neil Jones' research on ter-mination. [JG02]

3. Program verification has been traditionally separated into two parts: prov-ing partial correctness, meaning "if the program terminates then it satisfies its specification", and proving termination. If termination can beestablished in a canonical way, a proof of partial correctness implies total
correctness.
4. Interactive theorem provers with inductive types like Agda [CC99], Coq[BC04], Lego [Pol94] and Twelf [PS99] make use of the Curry-Howard

isomorphism and allow proofs by induction to be written as recursivefunctions. But only terminating functions correspond to valid proofs,
hence, termination is vital to maintain soundness of the proof system.This is the original motivation for my continuing research on termination
and strong normalization.
In the following we consider systems--these could be programming lan-guages, abstract calculi or logics--which have an expression language or a term
language and a notion of computation.

1.2 Approaches to Termination
There are two fundamental kinds of systems: systems with partiality and totalsystems. In the first class, each expression has a meaning, even those expressions whose computation does not terminate. This class covers most program-ming languages, but also, e. g., the Logic of Computable Functions (LCF) and
logics with undefinedness (Beeson [Bee04], Farmer [Far04]). The fact that anexpression terminates (i. e., is defined) has to be proven in the logics.

In total systems, each valid expression is terminating. We can distinguishsystems with or without recursion. For example, the simply-typed

*-calculusis a system without recursion. So is Girard's [Gir72] System
F!, but a limitedform of recursion, iteration, is definable in it [GLT89, chap. 11] [BB85, RP93,

PDM89, Geu92, Mat98, AMU05]. In HOL, even well-founded recursion is de-finable [Sli96]. Other systems have explicit recursion, which has to be tamed by
some formalism to preserve termination of all expressions. Most notably, thereare term rewriting systems (TRS). For TRS, many criteria have been developed

we spot the bug: I had typed an asterix * instead of a plus + who are only a shift apart on a Ger-man keyboard. To locate this error in a bigger program took me more than an hour, since I had
not expected the slip in such a simple function. A termination checker could have warned me thatthere might be a problem.

10 CHAPTER 1. INTRODUCTION
for termination: polynomial interpretations, the recursive-path ordering, sim-plification orderings [Ste95], and dependency pairs [AG00]. These criteria are
syntactical, as opposed to type-based; they work on untyped rewrite rules. Syn-tactical methods have also been applied to termination of logic programs and
higher-order logic programs [Pie01]. The Fixpoint declaration of Coq, whichintroduces dependently-typed recursive functions, uses as of today a syntactical termination check, and Agda uses an implementation of the terminationchecker

foetus [AA02].

This thesis investigates type-based termination; by this we mean that termi-nation checking is integrated with type checking: a program which passes the

type-checker is guaranteed to terminate on all inputs.

1.3 Why Type-Based Termination Matters
I am convinced that the types paradigm is fruitful also for termination. Theintegration of termination checking into type checking has the following advantages.

Communication. The idea that each wellformed program fragment has a cer-tain type seems still to be spreading in computing. Most firmly rooted is this
view in strongly typed functional programming: in ML, each program musthave a type which is inferable by the compiler. In practical software development, it has been fruitful to write down types as a documentation for theprogrammer. The type of a program gives an abstract idea which operation
it implements, and this type, since checked by the compiler, is documentationwhich is always up-to-date. JAVA is a success story for a strongly typed language. Its design is quite contrary to ML, however: The type system is rathersimple. It lacks higher-order functions, and subtyping is based on names, not
on structure. The type of each variable has to be written down by the pro-grammer and each exception a method can throw has to be declared, which
makes JAVA a bit bureaucratic. A good compromise has been found in the de-sign of Haskell: not each type must be inferable, but also not each type must
be declared. Haskell's type system not only features higher-order functions,higher-order and nested data types, and type classes, but also polymorphic recursion and higher-rank polymorphism with explicit quantification. Throughprogramming practice, a Haskell programmer learns to think in a quite complex type language.

Once a programmer has learned to think in types, type-based terminationof a program can be easily communicated to him. Once a program can be

given a certain type, its termination ensues. The main thing a programmerneeds to understand in order to master type-based termination as presented in
this thesis, is that each data structure carries an upper bound for its size in itstype, and that in a recursive call, this size must decrease.

1.3. WHY TYPE-BASED TERMINATION MATTERS 11
Certification. Besides communicating termination to a human there is theproblem of communicating termination to a machine, or more precisely, providing a machine-checkable certificate that a program terminates. For type-based termination, this question is already answered: a correct typing derivation
for a program certifies its termination. The proof of this fact for a polymorphicfunctional language with higher-order data types, which we call

F!b, is the maintechnical contribution of this thesis.

A simple theoretical justification. Type-based termination can be reduced toa simple concept: induction on the size parameter. For polynomial datatypes
like lists and binary search trees, natural numbers suffice as size indices, forinfinitely branching trees, streams, and processes we need ordinal indices and
transfinite induction. However, even in this case the programmer does notneed ordinal notations and can continue to think of sizes as natural numbers.

Orthogonality. Type-based termination rests on the principle of sized datatypes and requires subtyping and restricted use of recursion. But these are the
only parts of a purely functional language which are affected.6 Other languageconstructs, like higher-order functions, tuples and records, variants and disjoint sums, native types and operations like integers and reals can be addedwithout having to change the termination machinery. All one has to do is
to extend type checking and subtyping for the language--and this has to bedone anyway. This is not true if termination checking is a separate module,
e. g., some syntactic method. Then each extension of the language requires anextension of the termination checker, or even new research how termination
checking can be extended to the new language constructs.

Robustness. A consequence of orthogonality is that the soundness of type-based termination is robust with regard to language extensions. As we show in
this thesis, it is compatible with impredicative polymorphism. This does not holdfor certain syntactic methods based on structural term orderings, as already
pointed out by Coquand [Coq92] [AA02, page 3].

Higher-order functions. As another consequence of orthogonality, type-basedtermination plays its strength when applied to higher-order functions or higherrank polymorphism. Since sizes are integrated into types, one can specify thata higher-order argument of a function should be a non size-increasing operation, which can be safely applied to the recursion argument without destroyingsize information important for termination. In Section 6.5 we will see an example where typing with rank-2 polymorphism will be crucial for the terminationof a generic merge function.

6It is well-known that higher-order references can simulate recursion, see, e. g., Xi [Xi02, section 4.6]. I/O and process communication can also be a source of non-termination, for instance, inform of deadlocks. Such impure language features are not treated in this thesis.

12 CHAPTER 1. INTRODUCTION
1.4 Informal Account of Type-Based Termination
What do we mean by type-based termination? In its broadest sense, the phraserefers to any type system which ensures that well-typed programs terminate.
Very basic representatives of such systems are the simply or the polymorphi-cally typed lambda-calculus. We want be more specific and refer only to languages with recursion (or, on the imperative side, loops), whose use is restrictedby a type system such that it cannot introduce non-termination. Again, there
are different ways to implement this idea. This thesis is about about type-basedtermination as coined by Barthe et al. [BFG+04], which builds on work by
Mendler [Men87, Men91], Gime'nez [Gim98], and Amadio and Coupet-Grimal[ACG98], and has independently been invented by Hughes, Pareto, and Sabry
[HPS96]. To simplify the following explanation of type-based termination, wewill first refer to types in an informal, semantical fashion as sets of terms, but
later we will be more precise and use types as syntactical objects, which areinterpreted as sets of terms.

1.4.1 A Semantical Account of Type-Based Termination
General recursion can be implemented by adding a fixed-point combinator fix toa functional language based on a typed

*-calculus. This combinator is axiom-atized as follows:

f 2 A ! A

fix f 2 A fix f = f (fix f )

That means: If f is a endo-function on type A, then fix f inhabits A; and fix fbehaves as f (

fix f ). General recursion makes a language inconsistent as a logic,since every type is inhabited, and introduces non-termination, if the equation is

read as a computation rule. (For both claims, take f to be the identity function.)To maintain termination, the use of

fix has to be restricted in some way.Keeping only the axiom
fix f = f (fix f ), we make the following observa-tion. Let i and n range over natural numbers, and Ai be some type dependent

on i. Further let ? denote the all-type, i. e., each program is of this type withoutfurther requirements. Then the following typing rule for

fix is admissible, i. e.,provable using just the typing rules of
*-calculus:

A0 = ? f 2 Ai ! Ai+1 for all i

fix f 2 An

The proof proceeds by induction on n: If n = 0, then fix f 2 ? = A0. Nowassume

fix f 2 An. Since f 2 An ! An+1 by assumption, f (fix f ) = fix f 2An+1. Now the rough idea behind the work of Hughes, Pareto, and Sabry

[HPS96] is: if Tn2N An is "interesting" [Par00, p. 129], then fix f has interestingproperties, like termination or productivity. Interesting types are, e.g., An =

{m | m < n} ! N; then Tn2N An = N ! N, and we can use the typing rule for
fix to introduce total functions over natural numbers.

1.4. INFORMAL ACCOUNT OF TYPE-BASED TERMINATION 13

A typical application would be the following. Let Ln denote the type oflists of natural numbers of length

< n and L1 = Sn2N Ln the type of all nat-ural number lists. Using the type An := Ln ! L1, we can define a recursive

function which eliminates all zeros from a list. Since L0 is empty, A0 is iso-morphic to the all-type (under the standard semantics of the function type,

A ! B = { f | f a 2 B for all a 2 A}). Using pattern matching notation we candefine the following functional f .

f 2 Ti((Li ! L1) ! Li+1 ! L1)f :=

*filter0*l. match l with

nil 7! nil
cons 0 t 7! filter0 t
cons h t 7! cons h (filter0 t)

Then filter0 := fix f 2 Tn(Ln ! L1) is the desired filtering function which canbe applied to lists of any length. Of course, we need to make sure f is welltyped. For example, if the input list l = cons h t 2 Li+1 has length < i + 1, thenthe length of the tail t is certainly below i, which implies that the recursive call
filter0 t is well-typed and, thus, justified.

Lists are a special case of an inductive type; list of bounded length are aspecial case of a sized inductive type. In general, if F is an isotone operator on

term sets, then u1F denotes the inductive type which is the least fixed pointof F. In case of lists of natural numbers, we have F(X) = {

nil} [ {cons h t | h 2N and t 2 X}. A sized inductive type is obtained by ordinal iteration of F:

u0F = ? (the empty type)
uff+1F = F(uff F)
u* F = Sff<* uff F (* limit ordinal)

It is easy to see that unF, for the list-specific F given above, contains exactlythe lists of length

< n, hence Ln = unF. Since all lists have finite length, theleast fixed point L1 = S

n2N Ln = Sn<! unF = u!F is reached at the smallestinfinite ordinal
!. However, there are inductive types with a higher closureordinal, for example, the second number class with the generating operator

F(X) = {ozero} [ {osucc o | o 2 X} [ {olim f | f 2 N ! X}. If Ordff de-notes the

ff-iterate of this operator, then the constructors have the followingtypes:

ozero 2 Tff Ordff+1
osucc 2 Tff(Ordff ! Ordff+1)
olim 2 Tff((N ! Ordff) ! Ordff+1)

If h 2 N ! Ord! is given by h(0) = ozero and h(n + 1) = osucc(h(n)), then
olim h 2 Ord!+1 appears for the first time at the iterate ! + 1, hence, there areterms of transfinite height in the second number class.

Consequently, a recursive function over elements of type Ord must treatalso transfinite iterates

Ordff for ff >= !. To account for the limit iterates, we

14 CHAPTER 1. INTRODUCTION
extend our introduction rule for recursive functions as follows:

A0 = ? f 2 Aff ! Aff+1 for all ff Tff<* Aff ` A* for all limits * > 0

fix f 2 Afi

Again, this rule is provable, this time by transfinite induction on fi: Base andstep case work as before, for the limit case we need to show

fix f 2 A* underthe induction hypothesis
fix f 2 Aff for all ff < *. But exactly this is given bythe new assumption. Now, if we summarize the two conditions on the type A,

1. A0 = ?, and
2. Tff<* Aff ` A* for all limits *,
into the predicate A adm, we get a rule which looks quite similar to the rule forgeneral recursion:

f 2 Aff ! Aff+1 for all ff

fix f 2 Afi A adm

1.4.2 From Semantics to Syntax
The goal of this thesis is to turn the semantical recursion rule into syntax, i. e.,into a typing rule, and show that all well-typed programs are strongly normalizing. If we take a close look at the syntactical components of the semanticaltypes we used in the constructors and the recursion rule in the last section, we
find the following elements:

* types indexed by ordinal variables ff, their successor ff + 1 or the closureordinal 1,

* function types !,

* infimum Tff of a family of types indexed by ff, and

* a condition A adm on types for recursion.
Surprisingly, there are only these few elements and they can be turned into syn-tax directly. To the type language of a simple or polymorphic lambda-calculus

we add a language of size expressions a : ord composed from size variables i,successor +1, and 1, which denotes a large ordinal at which the iteration processes for all inductive types of the system close. The infimum Tff is expressedby size polymorphism 8i. Finally, we formulate a syntactic criterion on types

A adm which entails the semantic one. This leads to the syntactic recursion rule

f : 8i. Ai ! Ai+1 a : ord

fix f : Aa A adm.

There is natural order on size expressions a induced by a <= a + 1 anda <= 1. Since the approximation stages of an inductive type are ordered ascendingly by inclusion, we get a natural subtype relation uaF <= ubF for a <= b.

1.5. CONTRIBUTION 15
The first part of this thesis deals with the subtyping induced by sizes in thepresence of co- and contravariant type constructors.

The distinguished feature of our approach is that we speak about ordinalindices in our type system without requiring an ordinal notation system, like
Cantor normal forms. The user can think of sizes as natural numbers insteadof ordinals without making mistakes.

1.5 Contribution
This thesis is not the first one on typed-based termination. Pareto [Par00] hasexplored this paradigm in the area of functional programming. He developed
Synchronous Haskell, the core of a functional language with type-based termina-tion and productivity checking, which is summarized in Hughes et al. [HPS96].
He proves the soundness of his system by non-standard denotational seman-tics, interpreting types as upward-closed sets of values. Pareto considers only
ordinals up to !, and, thus only inductive data types without embedded func-tion spaces, excluding the type

Ord.

Frade's thesis [Fra03] introduces *b , an extension of *-calculus with ML-polymorphism by sized inductive types, which is summarized in Barthe et al.

[BFG+04]. She does treat inductive types with embedded function spaces andshe proves subject reduction and strong normalization for

*b.

Our contribution, in relation to the above theses and to other systems oftype-based termination, is progress in the following areas:

Higher-order inductive types. Our inductive types can contain embeddedfunction spaces and, at the same time, be of higher kind. Therefore, neither
iteration to the first infinite ordinal, !, as in Pareto's case, nor to the first un-countable ordinal,

\Omega , as in Frade's case seems sufficient. The upper bound forour closure ordinal is the

!th uncountable.

A theory of semi-continuous types. Frade restricts result types of recursivefunctions to be monotone in their size argument. Pareto is more liberal, allowing types which are, in his terminology, !-undershooting. He gives somecriteria how to classify such admissible types, but in a rather ad-hoc manner.
We show that similar types are admissible in our semantics where types aresets of strongly normalizing terms, which is quite distinct from his domaintheoretic semantics. However, since we allow infinite branching, inductivetypes will fall in a different class in our case. We put his ad-hoc analysis of
admissible types on a more solid basis by classifying types as upper or lowersemi-continuous, which are standard concepts in analysis. Furthermore, we
cast or results in kinding rules for semi-continuous types, thus, mechanizingthe quest for admissible types.

16 CHAPTER 1. INTRODUCTION
Heterogeneous data types. We are the first to consider typed-based termi-nation for heterogeneous or nested data types. Heterogeneous data types can
be viewed as fixed points of type constructors of a higher kind, such that thefixed point is not a type but a type constructor. Such heterogeneous types have
been analyzed in the mathematics of program construction and in Haskell byHinze [Hin98, Hin99, Hin00a, Hin00b, Hin01] Bird and Meertens [BM98], Bird
and Paterson [BP99a], Martin and Gibbons [MG01] and Bayley [MGB04] and inthe context of System

F! by Pierce, Dietzen, and Michaylov [PDM89], Matthes[Mat01], Matthes and myself [AM03, AM04], and with Uustalu [AMU03, AMU05].

Note that heterogeneous data types are not a special case of inductive families[Dyb94].

Equi-(co)inductive types. In contrast to many predecessors [Geu92, Alt93,Mat98, Alt99, AA00, BJO01, BFG+04] of our work, we do not use the common iso-recursive approach to (co)inductive types, but the equi-recursive one,hence, we consider equi-(co)inductive types. For example, take the Haskell data
type of binary trees:

data BT a = Leaf

-- Node (BT a) a (BT a)

The finite binary trees can be modeled by an inductive type. Using equi-inductivetypes, one can decompose a data type into recursion and a labeled sum. For this

example, the decomposition would read

BTF : * ! * ! *
BTF := *A*X. Leaf 1 + Node (X * A * X)

BT : * ! *
BT := *A. u(BTF A),

where 1 is the unit type, c1 A1 + * * * + cn An is the labeled sum of the typesA

1..n, and u is the least fixed-point combinator, fulfilling the type equation
u F = F (u F). The constructors of the labeled sum can be reused directly asconstructors for binary trees.

Iso-inductive types, however, fold and unfold noisily: Special terms in :F (
u F) ! u F and out : u F ! F (u F) construct and destruct iso-inductivetypes, and

u F is only isomorphic to F (u F) (hence, the name). The constructorsfor binary trees now read

in ffi Leaf and in ffi Node. This seems less direct and less-intuitive than the equi-inductive approach. On the other hand, the metatheory

of iso-inductive types is simpler, because we know that each canonical inhabi-tant of an inductive type is of the form

in t.In this thesis, we analyze the more challenging metatheory of equi-inductive

and -coinductive types. Especially the combination of equi-induction and equi-coinduction will have some unpleasant effects when it comes to a strongly normalizing reduction system. Anyhow, we fight our way through, but if youwant to avoid hardship, stick to iso-coinductive types!

1.5. CONTRIBUTION 17
A unified language for types and size expressions. In contrast to previouswork on sized types, we unify the languages of sizes and types by introducing
a new base kind ord of sizes into F!. This enables us to give precise types topolymorphic higher-order functions such as

foldr. In our calculus, it can begiven the type

foldr : 8A : *. 8B : ord +! *.(8i :

ord. A ! B i ! B (i + 1)) !(8i :
ord. B (i + 1)) !(8i :
ord. Listi A ! B i).

By giving size information to polymorphic combinators such as foldr, evenfunctions built-up from these combinators can have sized types. This is a novelty with regard to existing systems of type-based termination, like Barthe et al.[BFG+04], Hughes et al. [HPS96], and Xi [Xi02].

18 CHAPTER 1. INTRODUCTION
Chapter 2
Sized Higher-OrderSubtyping

In this chapter, we define the kind and constructor level of F!b, the higher-orderpolymorphic

*-calculus with sized types. We present rules for equality andsubtyping and show their soundness through a set-theoretic model.

2.1 Constructors and Polarized Kinds
The higher-order polymorphic lambda-calculus introduces the notion of typeconstructor or just constructor. In the first intuition, it is a function which takes
one or several types and produces a type, a so called type transformer. For ex-ample, the Cartesian product * is a constructor: It takes two types A and B and
produces the product type A * B whose canonical elements are pairs (r, s) ofterms r : A and s : B. The notion of constructor is then taken to higher orders:
A type is a constructor, a function on constructors is a constructor itself.

2.1.1 Polarities
We aim to distinguish constructors with regard to their monotonicity or vari-ance. For instance, the product constructor * is isotone or covariant in both of

its arguments. If one enlarges the type A or B, more terms inhabit A * B. Theopposite behavior is called antitone or contravariant. Finally, a function F might
not exhibit a uniform behavior, it might grow or shrink with its argument, orwe just do not know how F behaves. This is the general case, we call it nonvariant. Each of the behaviors is called a polarity and abbreviated by one of thefollowing symbols:

Pol 3 p, q ::= ffi non-variant| + covariant

| - contravariant

19

20 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
The polarities are related: Since "non-variant" just means we do not have anyinformation about the function, and we can forget our knowledge, each function is non-variant. The inclusion order between the three sets of co-, contra-,and non-variant functions induces a partial information order <= on

Pol. Thesmaller a set is, the more information it carries. Hence ffi <= p, and p <= p for all

p. We visualize the partial order on Pol as follows:

+ -

ffi
@@@@

@@@ ~~~~~~~

Remark 2.1 In notation and order of polarities we follow Duggan and Com-pagnoni [DC99]. Detailed studies of polarized subtyping have been performed
by Steffen [Ste98]. He uses a different notation and considers the dual ordering.

Polarity of composed functions. Let F, G be two functions such that the com-position F ffi G is well-defined. If F has polarity p and G has polarity q, we denote the polarity of the composed function F ffi G by pq. It is clear that polaritycomposition is isotone: if one gets more information about F or G, certainly
one cannot have less information about F ffi G. Then, if one of the functions isnon-variant, the same holds for the composition. In the remaining cases, the
composition is covariant if F and G have the same variance, otherwise it iscontravariant. We obtain the following multiplication table:

ffi + -ffi ffi ffi ffi
+ ffi + -- ffi - +

Polarity composition, as function composition, is associative. It is even com-mutative, but not a priori, since function composition is not commutative.
Remark 2.2 Instead of polarities we could take signs s 2 {0, +1, -1} withordinary multiplication and the non-standard order s <= s0 () s = s0 . |s|

<|s0|.

Remark 2.3 (? polarity) Steffen [Ste98] and Duggan and Compagnoni [DC99]include a fourth polarity, called ? in second loc. cit., which indicates that a function is invariant or constant. The symbol "?" is justified since a constant func-tion is both isotone and antitone. The ordering on polarities is extended by

p <= ? for all p. For our purposes, ? is not interesting.

2.1.2 Kinds
Constructors are classified by their kind, i. e., as types, functions on types, func-tions on such functions etc. Extending the kinds of

F!, we introduce a second

2.1. CONSTRUCTORS AND POLARIZED KINDS 21
base kind ord. Constructors of this kind are syntactic representations of ordi-nals.

Kind 3 ^ ::= * types|

ord ordinals| p

^1 ! ^2 p-variant constructor transformers

A constructor of kind p^1 ! ^2 is a p-variant function which maps constructorsof kind

^1 to constructors of kind ^2. We introduce the following abbreviations:

~p~^ ! ^0 for p1^1 ! * * * ! pn^n ! ^0,
^ p! ^0 for p^ ! ^0, and

~^ ~p! ^0 for ~p~^ ! ^0.

Using the vector notation (first line) for kinds includes the assumption |~p| =|

~^| = n. Our base kinds, sometimes denoted by ^0, are * and ord. It is clear thatevery kind can be written in vector notation

~p~^ ! ^0 with potentially emptyvectors
~p and ~^. Especially, every kind can be written in this vector notationsuch that

^0 is a base kind.Pure kinds are kinds which do not mention base kind "

ord". These are thekinds of Steffen's polarized
F!<= and given by the following grammar.

^* ::= * | p^* ! ^0*
The rank rk(^) 2 N of a kind ^ is defined recursively as follows:

rk(^0) = 0 ^0 2 {*, ord}
rk(p^ ! ^0) = max(rk(^) + 1, rk(^0))

With n := |~^| we have rk(~p~^ ! ^0) = max{1 + rk(^i) | 1 <= i <= n}. If n 6= 0,then even

rk(~p~^ ! ^0) = 1 + max{rk(^i) | 1 <= i <= n}.

2.1.3 Constructors
Constructors are given by the following Curry-style type-level lambda-calculuswith some constants. The meta-variable X ranges over a countably infinite set

TyVar of constructor variables.

a, b, A, B, F, G ::= C | X | *XF | F G
In most cases, we will use F, G, and H for constructors of arbitrary kind, Aand B for types (kind *) and a and b for ordinal expressions, i. e., constructors
of kind ord. Ordinal variables will be denoted by i and j whereas construc-tor variables of arbitrary kind will be denoted by X, Y and Z. As usual,

*XFbinds variable X in F. We identify constructors under
ff-equivalence, i. e., un-der renaming of bound variables.
FV(F) shall denote the set of free variablesof constructor F.

22 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
Signature. The constructor constants C are taken from a fixed signature \Sigma which contains at least the following constants together with their kinding.

! : * -! * +! * function space8

^ : (^ ffi! *) +! * quantification
u^* : ord +! (^* +! ^*) +! ^* inductive constructors

*^* : ord -! (^* +! ^*) +! ^* coinductive constructors

s : ord +! ord successor of ordinal1 :

ord infinity ordinal

We often denote one of u^* , *^* as r^* . Note that the indices ^* of these con-stants are pure kinds. Otherwise, we could define ordinals as least or greatest fixed points of some ordinal function. When clear from the context ofdiscourse, we omit the indices of inductive and coinductive constructors and
quantification. We introduce the following notations:8

X :^. A for 8^ *XA,8X A for 8

*XA,raX :
^. F for r^ a *XF,raX F for r a

*XF, andra

^ for r^ a.

The last notation is generalized to any constructor F : ord p! ^ on ordinals: Weallow the notation Fa for application F a.

Remark 2.4 In the above signature, the only closed constructors of kind ord areof the form

s (s . . . (s 1)) for a finite number of successors s. Semantically, allthese ordinals are equal to 1. Hughes, Pareto, and Sabry [HPS96] add a constant 0 : ord denoting the ordinal zero, in order to get a more precise typing forconstant objects of inductive type. Our syntax of ordinals is equivalent to the
stage expressions of Barthe et al. [BFG+04].
Example 2.5 (Impredicative encodings) Constructors for Cartesian product *,disjoint sum +, and existential type 9 can be defined by the following impredicative encodings.

* : * +! * +! ** :=

*X*Y8Z : *. (X ! Y ! Z) ! Z

+ : * +! * +! *+ :=

*X*Y8Z : *. (X ! Z) ! (Y ! Z) ! Z

9^ : (^ ffi! *) +! *9

^ := *F8Z : *. (8X :^. F X ! Z) ! Z

We will use * and + in infix notation and right associative. Later we willpresent a method to check that these definitions are well-kinded and do possess

their claimed variance.

2.1. CONSTRUCTORS AND POLARIZED KINDS 23
Example 2.6 (Types with finitely many inhabitants) We define 0 := 8X : *. X,1 := 8X : *. X ! X, and

Bool := 2 := 1 + 1. It is clear how we could go on anddefine 3, 4, etc.

Example 2.7 (Regular data types) In the following examples, we define someinductive types. They are called regular data types because all of them are fixed
points of a type transformer (u*). The first type represents natural numbers inunary encoding, the second type polymorphic lists, the third one trees branching over type B with node-labels of type A, and the fourth one Brouwer ordi-nals.

Nat : ord +! *
Nat := *i. uiX. 1 + X

List : ord +! * +! *
List := *i*A. uiX. 1 + A * X

Tree := ord +! * -! * +! *
Tree := *i*B*A. uiX. 1 + A * (B ! X)

Ord := ord +! *
Ord := *i. uiX. 1 + X + (Nat1 ! X)

The first argument of the constructors in this example is an ordinal numberdescribing the bound for the height of elements, when viewed as trees, in this
data type. The height of a tree is defined as one plus the least upper bound ofthe heights of its immediate subtrees. There are no trees of height zero. Natural
numbers and lists are linear trees, hence, their height is equal to one plus thelength of the list resp. the unary encoding of the natural number. For finitely
branching trees, the height is a finite ordinal, but for infinitely branching trees,it might be infinite. For instance, consider a

Nat1 branching tree whose nthimmediate subtree has height n. Then the height of the whole tree is

! + 1.

Types like Nata and Lista A are called sized types since they carry a bound forthe size of their inhabitants. Closely related sized type systems are

*b (Bartheet al. [BFG+04]) and the one of Hughes, Pareto, and Sabry [HPS96]. The latter

one rejects infinitely branching trees and, hence, considers only ordinals up to
!.

Example 2.8 (Non-regular data types) The following heterogeneous or nested datatypes are well-known from the literature on functional programming. Elements
of PLista A are power lists [BGJ00], i. e., list of length 2n for some n < a, or, alter-natively, perfect trees [Hin99], i. e., perfectly balanced leaf-labeled binary trees.
The second type Busha A, bushy lists, models finite maps from unlabeled bi-nary trees of height

< a into A [Alt01, Hin00b]. An the third type, Lama A, isinhabited by de Bruijn representations of untyped lambda terms of height

< a

24 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
with free variables in A [BP99b, AR99].

PList : ord +! * +! *
PList := *i. uiX*A. A + X (A * A)

Bush : ord +! * +! *
Bush := *i. uiX*A. 1 + A * X (X A)

Lam : ord +! * +! *
Lam := *i. uiX*A. A + X A * X A + X (1 + A)

Example 2.9 (Coinductive types) The prime example of a coinductive type,
Streama A, contains infinite lists of elements in A that are at least defined upto depth a. In other words, retrieving the nth element of a stream is guaranteed to succeed if n < a.

Stream : ord -! * +! *
Stream := *i*A. *i*X. A * X

2.1.4 Kinding
In this section, we present rules of kinding, i. e., assigning kinds to constructors.The rules extend the kinding rules of

F! by the treatment of polarities.

Positive and negative occurrence. In the simply typed lambda-calculus andin System

F there are simple syntactic definitions of positive and negative oc-currence of type variables in types. Let A be a type expression, viewed as a

tree. A type variable X is said to occur positively in A if the path from theroot to X takes the left branch of an !-node an even number of times; otherwise, X occurs negatively. This simple syntactic criterion does not scale to ahigher-order type system like

F!b, the system under consideration, hence wewill define positivity and negativity via the kinding judgement, following previous work [AM04]. Nevertheless, the simple criterion might serve the readeras a first intuition.

Polarized contexts. A polarized context \Delta  fixes a polarity p and a kind ^ foreach free variable X of a constructor F. If p = +, then X may only appear
positively in F; this ensures that *XF is an isotone function. Similarly, if p = -,then X may only occur negatively, and if p = ffi, then X may appear in both
positive and negative positions.

PCxt 3 \Delta  ::= \Pi  empty context|

\Delta , X : p^ extended context (X 62 dom(\Delta ))

The domain dom(\Delta ) is the set of constructor variables \Delta  mentions. Naturally,each variable can appear in the context only once.

2.1. CONSTRUCTORS AND POLARIZED KINDS 25
Ordering on contexts. We say context \Delta 0 is more liberal than context \Delta , writ-ten

\Delta 0 <= \Delta , iff

(X : p^) 2 \Delta  implies (X : p0^) 2 \Delta 0 for some p0 <= p
In particular, \Delta 0 may declare more variables than \Delta  and assign weaker polari-ties to them. The intuition is that all constructors which are well-kinded in

\Delta are also well-kinded in a more permissive context
\Delta 0.The empty context is the most strict context since

\Delta  <= \Pi  for any \Delta . Incontrast, there is no most liberal context.

Application of polarities to contexts. We define application p\Delta  of a polarityp to a polarized context

\Delta . It composes p with every polarity assigned to a vari-able in
\Delta . It is easy to see that +\Delta  = \Delta  and p(q\Delta ) = (pq)\Delta  since + is the neu-tral element of

Pol and polarity composition is associative, hence, --\Delta  = \Delta and ffiffi
\Delta  = ffi\Delta . The last operation removes all polarity information from a con-text, making it isomorphic to a classical kinding context for System

F!, exceptfor the polarities within types. Application inherits monotonicity from polarity

composition: p\Delta  <= p0\Delta 0 if p <= p0 and \Delta  <= \Delta 0. An instance of monotonicity isthe law -

\Delta  <= \Delta 0 () \Delta  <= -\Delta 0.

Kinding. We will introduce a judgement \Delta  ` F : ^ which combines the usualnotions of well-kindedness and positive and negative occurrences of type variables. A candidate for the application rule is

\Delta  ` F : p^ ! ^0 \Delta 0 ` G : ^

\Delta  ` F G : ^0 \Delta  <= p\Delta 0.

The side condition is motivated by polarity composition. Consider the casethat X 62

FV(F). If G is viewed as a function of X, then F G is the compositionof F and G. Now if G is q-variant in X, then F G is pq-variant in X. This means

that all q-variant variables of \Delta 0 must appear in \Delta  with a polarity of at most pq.Now if X 2

FV(F), it could be that it is actually declared in \Delta  with a polaritysmaller than pq. Also, variables which are not free in G are not affected by the

application F G, hence they can carry the same polarity in F G as in F. Togetherthis motivates the condition

\Delta  <= p\Delta 0.To eliminate the side condition from the application rule, we need a function which computes the most liberal context \Delta 0 from \Delta  which satisfies bothconditions.

Inverse application of polarities. We are looking for an inverse to applica-tion, p-1

\Delta , which should be the least \Delta 0 such that \Delta  <= p\Delta 0. If such an inverseapplication exists, it is monotone and forms a Galois connection with the application operation, i. e.,

p-1\Delta  <= \Delta 0 () \Delta  <= p\Delta 0.

26 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
This inverse indeed exists and obeys the equations +-1\Delta  = \Delta , --1\Delta  = -\Delta ,and ffi-1

\Delta  = {X : p^ 2 \Delta  | p = ffi}, respectively.1 In all three cases, p-1(p\Delta ) <=
\Delta , and the side condition \Delta  <= p(p-1\Delta ) holds.

Kinding (continued). Now we are ready to introduce a judgement \Delta  ` F : ^inductively by the following rules:

KIND-C C :^ 2 \Sigma \Delta  ` C : ^ KIND-VAR X : p^ 2 \Delta  p <= +\Delta  ` X : ^

KIND-ABS \Delta , X : p^ ` F : ^0\Delta  ` *XF : p^ ! ^0
KIND-APP \Delta  ` F : p^ ! ^0 p-

1\Delta  ` G : ^

\Delta  ` F G : ^0

To understand these rules, it is useful to think of F in the context \Delta  = ~X : ~p~^
as a function F(~X). The judgement \Delta  ` F : ^ should be valid if both F haskind

^ and F grows (weakly) whenever the positive arguments to F grow, thenegative shrink and the non-variant stay fixed.

Hence, rule KIND-VAR can only allow non-negative variables to be fetchedfrom the context. In contrast, constants may appear with any polarity (

KIND-C).The rule
KIND-ABS for abstraction is suggestive.

Explanation of the application rule. Because of its central role, rule KIND-APPis given again a very detailed explanation. First, observe that whenever F
grows (with fixed G), then also the application F G grows. Hence, the polarityof the variables in F is the same as those in F G. To see how the application
behaves if we modify G, let us consider the cases p = +, -, ffi separately:

KIND-APP+ \Delta  ` F : +^ ! ^0 \Delta  ` G : ^\Delta  ` F G : ^0
In the first case, F is a monotone function, hence whenever its argument Ggrows, the application F G grows as well. Hence, the polarity of the variables
in G matches the polarity of the variables in F G.

KIND-APP- \Delta  ` F : -^ ! ^0 -\Delta  ` G : ^\Delta  ` F G : ^0
If F is antitone, the application F G will grow if G shrinks. Hence, the polarityof the variables in G must be opposite (-

\Delta ) to the one of the variables in theapplication (
\Delta ). Imagine a variable X appearing negatively in G. If it grows, G

1Unlike for integers, reversing the sign does not reverse the inequality: We have -\Delta  <= \Delta 0 ()
\Delta  <= -\Delta 0.

2.1. CONSTRUCTORS AND POLARIZED KINDS 27
will shrink, hence F G will grow. Therefore X appears positively in the appli-cation.

KIND-APPffi \Delta  ` F : ffi^ ! ^0 ffi-

1\Delta  ` G : ^

\Delta  ` F G : ^0In the non-variant case, we do not know how F behaves if we modify its argument. To satisfy our informal semantics, F G needs to grow if we grow thevariables declared in

\Delta  to be positive, shrink the negative variables, and leavethe non-variant ones fixed. If one of the positive or negative variables appeared

in G, the argument to F would change which would result in an unpredictableshift of the value of F G. If we want to verify that F G grows we need to ensure
that no positive or negative variables occur in G. This is done by erasing allnon-variant variables from the context through the operation ffi-1

\Delta .

Example 2.10 (Derived rules for function space and quantification) The follow-ing rules are derivable:

-\Delta  ` A : * \Delta  ` B : *

\Delta  ` A ! B : *

\Delta , X : ffi^ ` A : *
\Delta  ` 8X :^. A : *

2.1.5 Equality
Type constructors are considered equal modulo fij. Further, the successor ofthe closure ordinal is considered equal to the closure ordinal. The judgement

\Delta  ` F = F0 : ^ is defined inductively by the following rules:

Computation axioms.

EQ-fi \Delta , X : p^ ` F : ^0 p-

1\Delta  ` G : ^

\Delta  ` (*XF) G = [G/X]F : ^0

EQ-j \Delta  ` F : p^ ! ^0\Delta  ` (*X. F X) = F : p^ ! ^0

EQ-1 \Delta  ` s 1 = 1 : ord
Congruence rules. In rule EQ-APP we have to modify the polarities of thevariables in G and G0 in the same way as in the application rule of the kinding
judgement: We inverse-apply p to the context \Delta .

EQ-C C :^ 2 \Sigma \Delta  ` C = C : ^ EQ-VAR X : p^ 2 \Delta  p <= +\Delta  ` X = X : ^

EQ-* \Delta , X : p^ ` F = F0 : ^0\Delta  ` *XF = *XF0 : p^ ! ^0
EQ-APP \Delta  ` F = F0 : p^ ! ^0 p-

1\Delta  ` G = G0 : ^

\Delta  ` F G = F0 G0 : ^0

28 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING

Symmetry and transitivity.

EQ-SYM \Delta  ` F = F0 : ^\Delta  ` F0 = F : ^

EQ-TRANS \Delta  ` F1 = F2 : ^ \Delta  ` F2 = F3 : ^\Delta  ` F1 = F3 : ^
The rule for reflexivity is admissible thanks to the congruence rules:
Lemma 2.11 (Reflexivity) If D :: \Delta  ` F : ^ then \Delta  ` F = F : ^.
Proof. By induction on D. \Lambda 

Lemma 2.12 (Validity) If D :: \Delta  ` F = F0 : ^ then \Delta  ` F : ^ and \Delta  ` F0 : ^.
Proof. By induction on D. \Lambda 

Together, \Delta  ` F : ^ holds if and only if \Delta  ` F = F : ^.
Remark 2.13 The rules for kinding and equality are in essence those used inprevious work of the author with Matthes [AM04], extended by

EQ-1. Notethat in loc. cit., the inverse application p-1
\Delta  of a polarity to a context was writ-ten p
\Delta .

2.2 Higher-Order Subtyping
In this section, we specify subtyping for constructors of polarized kinds. Therules are inspired by Steffen [Ste98].

Reflexivity, transitivity and antisymmetry. These three properties make sub-typing a partial order on constructors of the same kind.

LEQ-REFL \Delta  ` F = F0 : ^\Delta  ` F <= F0 : ^
LEQ-TRANS \Delta  ` F1 <= F2 : ^ \Delta  ` F2 <= F3 : ^\Delta  ` F1 <= F3 : ^
LEQ-ANTISYM \Delta  ` F <= F0 : ^ \Delta  ` F0 <= F : ^\Delta  ` F = F0 : ^
The reflexivity rule includes the subtyping axioms for variables and constantsas special cases. Reflexivity and transitivity together ensure that subtyping
is compatible with equality. The antisymmetry rule potentially enlarges ournotion of equality.

2.3. SEMANTICS AND SOUNDNESS 29
Abstraction.

LEQ-* \Delta , X : p^ ` F <= F0 : ^0\Delta  ` *XF <= *XF0 : p^ ! ^0

Application. There are two kinds of congruence rules for application: onekind states that if functions F and F0 are in the subtyping relation, so are their
values F G and F0 G at a certain argument G.

LEQ-APP \Delta  ` F <= F0 : p^ ! ^0 p-

1\Delta  ` G : ^

\Delta  ` F G <= F0 G : ^0

The other kind of rules concern the opposite case: If F is a function and twoarguments G and G0 are in a subtyping relation, so are the values F G and F G0

of the function at these arguments. However, such a relation can only exist if Fis either covariant or contravariant.

LEQ-APP+ \Delta  ` F : +^ ! ^0 \Delta  ` G <= G0 : ^\Delta  ` F G <= F G0 : ^0
LEQ-APP- \Delta  ` F : -^ ! ^0 -\Delta  ` G0 <= G : ^\Delta  ` F G <= F G0 : ^0
What about a comparable rule for non-variant constructors? It is derivable:

\Delta  ` F : ffi^ ! ^0 ffi

-1\Delta  ` G <= G0 : ^ ffi-1\Delta  ` G0 <= G : ^

ffi-1\Delta  ` G = G0 : ^
\Delta  ` F G = F G0 : ^0
\Delta  ` F G <= F G0 : ^0

Successor and infinity.

LEQ-S-R \Delta  ` a : ord\Delta  ` a <= s a : ord LEQ-1 \Delta  ` a : ord\Delta  ` a <= 1 : ord

Lemma 2.14 (Validity II) If D :: \Delta  ` F <= F0 : ^ then \Delta  ` F : ^ and \Delta  ` F0 : ^.
Proof. By induction on D, using validity of equality (Lemma 2.12) in case of

LEQ-REFL. \Lambda 

2.3 Semantics and Soundness
In this section we give a semantics to kinds and constructors and show sound-ness of kinding, constructor equality and subtyping.

30 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
2.3.1 Interpretation of Kinds
Constructors F of kind ^ will be interpreted as operators F which live in thedenotation [[

^]] of their kinds. Each kind will be interpreted as a poset (partiallyordered set) ([[

^]], v^), which is even a complete lattice in each case.

Interpretation of base kind *. For the moment, we assume a complete lattice[[*]] of countable sets A 2 [[*]] ordered by inclusion, with a maximal set ?* 2

[[*]] such that A ` ?* for all A 2 [[*]]. Later, we will let [[*]] be the collectionof all saturated sets `

SN where ?* = SN is the set of strongly normalizingterms. So, let

[[*]] : complete lattice of setsA v* A0 :() A ` A0d

* A := T A (where A ` [[*]]).

By assumption, the poset ([[*]], v*) is closed under infima, i. e., for a non-emptysubset

A ` [[*]] the infimum d* A 2 [[*]] exists and is equal to the intersectionT
A. Intersection can be extended to empty collections by letting d* ; = ?*.Once empty intersections are defined, we can define arbitrary suprema byF

* A := d*{B 2 [[*]] | B w* A for all A 2 A}. Note that we do not require that
the supremum is the union of sets; it might actually be something bigger. Onthe set [[*]] we assume a binary operation "!" (function space construction)

such that A ! B v* A0 ! B0 if A0 v* A and B v* B0.

Interpretation of base kind ord. Constructors "a" of kind ord denote set-theoretic ordinals in our semantics. We choose an initial segment [0; ?

ord] =:

[[ord]] of the ordinals for the interpretation of ord. At the moment we leave it
open which ordinal ?ord denotes; we will fill it in later.

[[ord]] := ?ord + 1
ff vord ff0 :() ff <= ff0

Notation. We introduce a notation F vp^ F 0 for polarized inclusion and thenotion F vp F 0 2 [[

^]] which expresses polarized inclusion for two operatorsF , F 0 plus the fact that both are in the set [[

^]].

F v+^ F 0 :() F v^ F 0F v-

^ F 0 :() F 0 v^ FF vffi

^ F 0 :() F v^ F 0 and F 0 v^ F

F vp F 0 2 [[^]] :() F , F 0 2 [[^]] and F vp^ F 0F v F 0 2 [[

^]] :() F v+ F 0 2 [[^]]

2.3. SEMANTICS AND SOUNDNESS 31
Interpretation of function kinds. Semantically, a constructor F of kind p^ !
^0 is a covariant (p = +), contravariant (p = -) or non-variant (p = ffi) opera-tor. We define the posets ([[

^]], v^) for higher kinds by induction on ^.

[[p^ ! ^0]] := {F 2 [[^]] ! [[^0]] | F (G) v F (G0) 2 [[^0]]for all G vp G0 2 [[

^]]}

F vp^!^0 F 0 :() F (G) v^0 F 0(G) for all G 2 [[^]]

Lemma 2.15 (Partial order) For each kind ^, the relation v^ denotes a partial orderon [[

^]].

Proof. By induction on ^. For base kinds ^0 2 {*, ord} reflexivity, transitivityand antisymmetry hold by definition. To prove transitivity for higher kinds,

assume ^ = p^1 ! ^2 and F1 v F2 2 [[^]], F2 v F3 2 [[^]], and an arbitrary G 2[[

^1]]. Since by ind. hyp. G v^1 G, we have F1(G) v F2(G) 2 [[^2]] and F2(G) vF

3(G) 2 [[^2]] by definition. By induction hypothesis F1(G) v^2 F3(G), andsince G was arbitrary F

1 vp^1!^2 F3. Reflexivity and antisymmetry are provenanalogously. \Lambda 

Pointwise infima, upper bounds and suprema. For higher kinds, we defineinductively pointwise infimum and maximal element as follows.d

p^!^0 F 2 [[^]] ! [[^0]] for F ` [[p^ ! ^0]]
(dp^!^0 F)(G) := d^0 {F (G) | F 2 F}

?p^!^0 2 [[p^ ! ^0]]?

p^!^0 (G) := ?^0

A simple proof by induction on ^ shows that ?^ is really the maximal elementof [[

^]] for any kind ^. Extending the observations for kind *, we can now defineempty infima and arbitrary suprema for all kinds.d

^ ; := ?^F
^ F := d^{H 2 [[^]] | H w^ F for all F 2 F}

Lemma 2.16 (Supremum is pointwise) (Fp^!^0 F)(G) = F^0 {F (G) | F 2 F}.
The posets [[^]] now are equipped with everything required for complete lat-tices.

Lemma 2.17 (Complete lattice) For all kinds ^, the triple ([[^]], d^, F^) forms acomplete lattice.
Proof. We only need to show that d^ F 2 [[^]] is the well-defined greatest lowerbound for

F ` [[^]] by induction on ^. For base kinds, there is nothing to prove.

32 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING

1. Well-definedness: Show dp^!^0 F 2 [[p^ ! ^0]]. Assume G vp G0 2 [[^]].Then F (G) v F (G0) 2 [[

^0]] for all F 2 F. Since the infimum is well-defined at kind
^0 by induction hypothesis, this entails

(dp^!^0 F)(G) = d^0 {F (G) | F 2 F} v^0

v^0 d^0 {F (G0) | F 2 F} = (dp^!^0 F)(G0).

2. Lower bound: Show dp^!^0 F vp^!^0 F for all F 2 F. Assume G 2 [[^]]

arbitrary. Since by induction hypothesis, d^0 is a lower bound,

(dp^!^0 F)(G) = d^0 {F (G) | F 2 F} v^0 F (G)
for any F 2 F.
3. Greatest lower bound: Let H v F 2 [[p^ ! ^0]] for all F 2 F. ShowH v

p^!^0 dp^!^0 F. For G 2 [[^]] arbitrary, H(G) v^0 F (G) for any

F 2 F by assumption. Since by induction hypothesis d^0 is a greatestlower bound,

H(G) v^0 d^0 {F (G) | F 2 F} = (dp^!^0 F)(G).

\Lambda 

2.3.2 Semantics of Constructors
In the following we develop a semantics of constructors through their deriva-tions of well-kindedness. This indirect path is necessary since the constructors

are domain-free. E. g., it is not determined which function is denoted by theconstructor

*XX; it could be the identity function on [[^]] for any kind ^. Injoint work with Ralph Matthes I have investigated polarized kinding and semantics of Church-style constructors [AM04]. There, *X : +^.X denotes exactlyone set-theoretic function: the identity on [[

^]]. The following development re-sembles closely the cited work, however, we take the detour via derivations

here.

Sound valuations. Let ` be a mapping from constructor variables to sets. Wesay

` 2 [[\Delta ]] if `(X) 2 [[^]] for all (X : p^) 2 \Delta . A partial order on valuations isestablished as follows:

` v `0 2 [[\Delta ]] :() `(X) vp `0(X) 2 [[^]] for all (X : p^) 2 \Delta 
We use v- for w and vffi for =, and v+ as synonym for v. It is clear that
` vq `0 2 [[\Delta ]] iff `(X) vpq `0(X) 2 [[^]] for all (X : p^) 2 \Delta .

2.3. SEMANTICS AND SOUNDNESS 33
Lemma 2.18 If ` v `0 2 [[\Delta ]], then ` vp `0 2 [[p-1\Delta ]].
Proof. By cases on p. Interesting is only case p = ffi. Assume X : q^ 2 [[ffi-1\Delta ]],which is only possible if q = ffi and X : ffi

^ 2 [[\Delta ]]. We have to show `(X) vffiffi
`0(X) 2 [[^]] which follows from the premise of the lemma. \Lambda 

Remark 2.19 The opposite implication does not hold in case p = ffi.
Denotation of constructors. If D :: \Delta  ` F : ^ and ` is a function from typevariables to sets, we define the set [[D]]

` by recursion on D as follows.

Case D

= X : p^ 2 \Delta  p <= +\Delta  ` X : ^

We define [[D]]` = `(X).
Case D

= C :^ 2 \Sigma \Delta  ` C : ^

In this case, we simply return the semantics of C, which is defined else-where: [[D]]

` = Sem(C).

Case

D =

D0
\Delta , X : p^ ` F : ^0

\Delta  ` *XF : p^ ! ^0

The semantics of D is a function over [[^]], defined by [[D]]`(G 2 [[^]]) :=[[D0]]

`[X7!G]. Note that this is only possible if we know the domain of thefunction (

^, in this case). This is the reason why we define the seman-tics of derivations instead of constructors (where we would not have the

domain available).
Case

D =

D1
\Delta  ` F : p^ ! ^0 D

2p-1
\Delta  ` G : ^

\Delta  ` F G : ^0

Let F := [[D1]]` and G := [[D2]]`. We simply define [[D]]` := [[D1]]`([[D2]]`).If F is not a function or G not in the domain of F , then the application is

defined to be the empty set.
Lemma 2.20 (Well-definedness and monotonicity) Let D :: \Delta  ` F : ^. If ` v
`0 2 [[\Delta ]] then [[D]]` v [[D]]`0 2 [[^]].

The lemma generalizes to p-monotonicity:

34 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
Corollary 2.21 (p-monotonicity) Let D :: p-1\Delta  ` F : ^. If ` v `0 2 [[\Delta ]] then[[D]]

` vp [[D]]`0 2 [[^]].

Proof. By case distinction on p, using Lemma 2.18. \Lambda 

Proof of the lemma. By induction on D.

Case D

= X : p^ 2 \Delta  p <= +\Delta  ` X : ^

Recall that [[D]]` = `(X). Assuming ` v `0 2 [[\Delta ]], we implicitly require--since p <= +--that

`(X) v `0(X) 2 [[^]]. Hence [[D]]` v [[D]]`0 2 [[^]].

Case D

= C :^ 2 \Sigma \Delta  ` C : ^

We require that Sem(C) 2 [[^]] for all (C :^) 2 \Sigma .
Case

D =

D0
\Delta , X : p^ ` F : ^0

\Delta  ` *XF : p^ ! ^0

Recall that [[D]]`(G 2 [[^]]) = [[D0]]`[X7!G]. Assuming G vp G0 2 [[^]], we
have `[X 7! G] v `0[X 7! G0] 2 [[\Delta , X : p^]]. By induction hypothesis,[[D]]

`(G) v [[D]]`0 (G0) 2 [[^0]], which implies [[D]]` v [[D]]`0 2 [[p^ ! ^0]].

Case

D =

D1
\Delta  ` F : p^ ! ^0 D

2p-1
\Delta  ` G : ^

\Delta  ` F G : ^0
Assume ` v `0 2 [[\Delta ]]. By induction hypothesis, [[D1]]` v [[D1]]`0 2[[p

^ ! ^0]]. By second induction hypothesis, using the corollary, we have[[D

2]]` vp [[D2]]`0 2 [[^]]. Hence, the application [[D]]` = [[D1]]`([[D2]]`) 2[[
^0]] is well-defined, and further, [[D]]` v [[D]]`0 2 [[^0]]. \Lambda 

The remainder of this section is devoted to the proof that two well-kinded-ness derivations for the same constructors do not yield different semantics.
More precisely, assume two derivations D :: \Delta  ` F : ^ and D0 :: \Delta 0 ` F :
^ and two valuations ` 2 [[\Delta ]] and `0 2 [[\Delta 0]]. If `(X) = `0(X) for all X 2

FV(F), then [[D]]` = [[D0]]`0 . This result is not completely trivial, i. e., cannot beproven directly by induction on the derivations, since in derivations for nonfi-normal F, some kinds in the middle of derivations can be canceled out. Forexample, consider F = (

*XY) G. Some kind ^ for X (and G) is mentioned inthe middle of a well-kindness derivation of F, but it can differ from derivation

to derivation. Still, the semantics of F in environment ` should be just `(Y),independent of kind

^.

2.3. SEMANTICS AND SOUNDNESS 35
fi-normal forms are given by the grammar

V ::= C ~V | X ~V | *XV.
One step fi-reduction on constructorsbeta-red@fi-reduction of constructors F -!fiF0 is defined as usual. Since the simply-typed

*-calculus is strongly normaliz-ing, it is clear that well-kinded constructors
\Delta  ` F : ^ reach a normal form:F -!*

fi V for some V.

Lemma 2.22 (Derivation-independence for normal forms) Assume two deriva-tions D1 ::

\Delta 1 ` V : ^ and D2 :: \Delta 2 ` V : ^ of well-kindedness for the same normalform V, and two valuations

`1 2 [[\Delta 1]] and `2 2 [[\Delta 2]]. If `1(X) = `2(X) for allX 2
FV(F), then [[D1]]`1 = [[D2]]`2 .

Proof. By induction on V. This is easy, since both derivations are determinis-tic.

Case V = X ~V. For j = 1, 2 the derivation D j has the shape

(X :~p~^ ! ^) 2 \Delta j D

ji
p-1i \Delta j ` Vi : ^i for i = 1, . . . , |~^|
\Delta j ` X ~V : ^ .

For all i we have Gi := [[D1i ]]`1 = [[D2i ]]`2 by induction hypothesis. SinceF

:= `1(X) = `2(X) by assumption, it follows that [[D1]]`1 = F ~G =[[D2]]

`2 .

Case V = C ~V. Analogously.
Case V = *XV0. For j = 1, 2 the derivation D j has the shape

E j
\Delta j, X : p^1 ` V0 : ^2

\Delta j ` *XV0 : p^1 ! ^2 .

Let F j(G) := [[E j]]`j[X7!G]. Since by induction hypothesis F 1(G) = F 2(G)
for all G 2 [[^1]], we have [[D1]]`1 = F 1 = F 2 = [[D2]]`2. \Lambda 

Lemma 2.23 (Substitution) Let D1 :: \Delta , X : p^ ` F : ^0 and D2 :: p-1\Delta  ` G : ^.Then there exists a derivation E ::

\Delta  ` [G/X]F : ^0. Further, assume ` 2 [[\Delta ]] and letF (G) := [[D

1]]`[X7!G] and G := [[D2]]`. Then [[E ]]` = F (G).

Proof. By induction on D1. \Lambda 

Lemma 2.24 (Subject reduction) Let ` 2 [[\Delta ]]. If D :: \Delta  ` F : ^ and F -!fi F0then exists a derivation E ::

\Delta  ` F0 : ^ with [[E ]]` = [[D]]`.

36 CHAPTER 2. SIZED HIGHER-ORDER SUBTYPING
Proof. By induction on F -!fi F0, using Lemma 2.23 in case of a fi-contraction.\Lambda 

Corollary 2.25 The lemma generalizes to multi-step reduction F -!*fi F0.
Theorem 2.26 (Derivation-independence of semantics) Assume two derivationsD ::

\Delta  ` F : ^ and D0 :: \Delta 0 ` F : ^ and two valuations ` 2 [[\Delta ]] and `0 2 [[\Delta 0]]. If
`(X) = `0(X) for all X 2 FV(F), then [[D]]` = [[D0]]`0.

Proof. By normalization of fi-reduction F -!fi* V. The theorem follows fromLemma 2.22 and the last corollary. \Lambda 

This result justifies the notation [[F]]^` as shorthand for [[D]]` where D :: \Delta  `F :

^ for some \Delta  such that ` 2 [[\Delta ]]. If ^ is clear form the context of discourse,we will omit it.

Theorem 2.27 (Soundness of constructor equality and subtyping)

1. If D :: \Delta  ` F = F0 : ^ and ` vp `0 2 [[\Delta ]], then [[F]]` vp [[F]]`0 2 [[^]].
2. If D :: \Delta  ` F <= F0 : ^ and ` v `0 2 [[\Delta ]], then [[F]]` v [[F]]`0 2 [[^]].
Proof. Simultaneously by induction on D. \Lambda 

Chapter 3
Type-Based Termination
In this chapter, we present the term or program level of F!b. We introduce rulesfor typing and reduction and show their soundness through a term model. As
a consequence, each program of F!b is terminating, and even strongly normal-izing.

3.1 Specification
In this section, we introduce the terms of F!b with their typing and reductionrules.

3.1.1 The Language
Terms. The term language we use in this chapter is quite simple, it consistsof the Curry-style

*-calculus with two special constants for recursion and core-cursion.

Tm 3 r, s, t ::= x | *xt | r s *-calculus| c constant
Const 3 c ::= fixun funct. def. by recursion on n + 1st argument|

fix*n corecursive function with n arguments

We use fixrn to denote either fixun or fix*n. The default for subscript n is 0, hence,
fixu denotes recursion on the first argument, and fix* means the construction ofan infinite object.

In spite of its economic spirit, the untyped *-calculus can express all com-putable functions: it is Turing-complete. We heavily restrict its power through
typing, but it is well-known that already in the simply-typed *-calculus, manydata structures can be simulated through continuation passing.

37

38 CHAPTER 3. TYPE-BASED TERMINATION
Example 3.1 (Pairs and Variants) Pairs with projections and variants (elementsof a disjoint sum) with case distinction can be implemented as follows:

K := *x*yx constant function constructor
K0 := *x*yy identity function constructor

pair := *x*y. *k. k x y constructor
fst := *p. p K first
snd := *p. p K0 second projection

inl := *x. *k*l. k x left injection
inr := *y. *k*l. l y right injection
case := *i*k*l. i k l

3.1.2 Typing
Typing contexts. We extend our notion of context: Now a context may notonly assign kinds and polarities to type variables X, but also types to term

variables x.

\Gamma  ::= \Pi  empty context|

\Gamma  , X : p^ extension by constructor variable|
\Gamma  , x : A extension by term variable

The default polarity is non-variant; extension of a context by a non-variant typevariable may be written

\Gamma  , X :^ instead of \Gamma  , X : ffi^.Typing contexts
\Gamma  will also be used in kinding judgements like \Gamma  ` F :
^, as defined in Section 2.1.4. In this case, the term variable declarations areirrelevant and should be considered absent.

Well-formed typing contexts \Gamma  cxt. Contexts for typing must contain onlynon-variant type variable declarations; and each term variable must be declared with a well-formed type.

CXT-EMPTY \Pi  cxt CXT-TYVAR \Gamma  cxt\Gamma  , X : ffi^ cxt

CXT-VAR \Gamma  cxt \Gamma  ` A : *\Gamma  , x : A cxt
The restriction to non-variant type variables in rule CXT-TYVAR will be under-stood when the typing rules are given below. The only typing rule which introduces type variables is generalization, TY-GEN, and it only introduces non-variant variables. However, allowing all polarities in the grammar for typing
contexts \Gamma  pays off when we pass from typing to kinding judgements \Gamma  ` F : ^,because those derivations introduce also co- and contravariant type variables
(and they do not impose a well-formedness criterion).
Lemma 3.2 If D :: \Gamma  cxt and (x : A) 2 \Gamma  then \Gamma  ` A : *.

3.1. SPECIFICATION 39
Proof. By induction on D. \Lambda 

Notation. Addition a + n of a size expression a : ord and a natural numbern 2 N.

a + 0 = aa + (n + 1) =

s a + n

Typing \Gamma  ` t : A.

Lambda-calculus. These rules are standard:

TY-VAR (x : A) 2 \Gamma  \Gamma  cxt\Gamma  ` x : A TY-ABS \Gamma  , x : A ` t : B\Gamma  ` *xt : A ! B

TY-APP \Gamma  ` r : A ! B \Gamma  ` s : A\Gamma  ` r s : B
Quantification. Since 8^ : (^ ffi! *) +! * (see Section 2.1.3), the constructor
F is of kind ^ ffi! * in the following rules:

TY-GEN \Gamma  , X :^ ` t : F X\Gamma  ` t : 8

^ F X 62 FV(F) TY-INST

\Gamma  ` t : 8^ F \Gamma  ` G : ^

\Gamma  ` t : F G

For rule TY-INST note that since \Gamma  ` F : ^ ffi! *, the application F G is onlywell-kinded in

\Gamma  if the context for G : ^ mentions only non-variant variables(see kinding rule

KIND-APPffi in Section 2.1.4). But this is the case, since \Gamma  iswell-formed (see Lemma 3.4).

Subsumption. (Subtyping has been defined in Section 2.2.)

TY-SUB \Gamma  ` t : A \Gamma  ` A <= B : *\Gamma  ` t : B

Folding and unfolding for (co)inductive types (r 2 {u, *}).

TY-FOLD \Gamma  ` t : F (r^ a F) ~G\Gamma  ` t : r

^ (a + 1) F ~G

TY-UNFOLD \Gamma  ` r : r^ (a + 1) F ~G\Gamma  ` r : F (r

^ a F) ~G

Recursion (r = u) and corecursion (r = *).

TY-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord \Gamma  cxt\Gamma  ` fixr

n : (8i : ord. A i ! A (i + 1)) ! A a

The condition A fixrn-adm ensures that we only use TY-REC to define recur-sive (r =

u) or corecursive (r = *) functions. Dropping the condition

40 CHAPTER 3. TYPE-BASED TERMINATION
we could immediately introduce non-terminating programs, e. g., for A(i) =
Nat1 ! Nat1 which does not depend on the size index, the diverging pro-gram

fixu0 * f *x. succ ( f x) would be accepted.
For A fixun-adm we say that A is admissible for recursion on the n + 1st argu-ment. Similarly, A

fix*n-adm is pronounced A is admissible for corecursion with narguments. A definition of these predicates is given below.

Example 3.3 (Typing for Pairs and Variants) The following type assignmentsshow that the constructors and destructors given in Example 3.1 introduce and
eliminate Cartesian product and disjoint sum type as presented in Example 2.5(impredicative encodings).

pair : 8A8B. A ! B ! A * B
fst : 8A8B. A * B ! A
snd : 8A8B. A * B ! B

inl : 8A8B. A ! A + B
inr : 8A8B. B ! A + B
case : 8A8B8C. A + B ! (A ! C) ! (B ! C) ! C

Lemma 3.4 If D :: \Gamma  ` t : A then \Gamma  cxt.
Proof. By induction on D. At the leaves (TY-VAR and TY-REC) of the typingderivation,

\Gamma  cxt is checked, and no rule, read downwards, extends the context.\Lambda 

Lemma 3.5 If D :: \Gamma  ` t : A then \Gamma  ` A : *.
Proof. By induction on D. In most rules the type of the conclusion is simplyassembled from components of the type(s) of the premise(s). In rule

TY-SUB,the premise
\Gamma  ` A <= B : * entails \Gamma  ` B : * (by Lemma 2.14). \Lambda 

Notation for size index. We sometimes write the size index superscript, e. g.,
ui instead of u i, or *i instead of * i.

Natural transformations. Let n >= 0. For constructors F1, . . . Fn and G with~F, G :

~p~^ ! *, let

~F ) G :() 8~X :~^. F1 ~X ! . . . Fn ~X ! G ~X.

Also, we abbreviate *~X. F(H1 ~X) . . . (Hn ~X) by F ffi ~H.

3.1. SPECIFICATION 41
Admissible types for recursion and corecursion must meet certain require-ments. For completeness of the typing system, we give the judgements

\Gamma  `
A fixrn -adm for r 2 {u, *} here. We will motivate and repeat them in sections3.5.1 and 3.5.2.

\Gamma  ` A fixun-adm :() \Gamma  , i : ord ` A i = (~G, (uiF) ffi ~H ) G) : * (i 62 FV(A))

for some F, G, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : +ord ` G : ^0 for some ^0 = ffi~^0 ! *,
\Gamma  , ' : -ord ` Gi : ^0 for 1 <= i <= n, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

\Gamma  ` A fix*n-adm :() \Gamma  , i : ord ` A i = (~G ) (*iF) ffi ~H) : * (i 62 FV(A))

for some F, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : -ord ` Gi : ^0 (all i) for some ^0 = ffi~^0 ! *, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

Example 3.6 (Admissible types for recursive functions) These A(i) are fixun-admfor some n.

Nati ! Nat1 ! Nat1 addition and multiplication
Nati ! Nat1 ! Nati subtraction and division
Listi A ! ListiB list map
Listi A ! Listi A * Listi A list splitting

The following types types are not admissible according to the current criterion,but will be admissible after a relaxation in Chapter 5.

Nati ! Nati ! Nati minimum and maximum
Listi A ! ListiB ! ListiC list zip-with

Example 3.7 (Repeat function) The term repeat a constructs an infinite streamof as.

repeat a := fix*0 *repeat. pair a repeat
*a. repeat a : 8A. A ! Stream1 A

It is well-typed, since *repeat. pair a repeat can be assigned type 8i. Streami A !
Streami+1 A, and *i. Streami A is trivially fix*0 -adm (empty ~G, ~H).

3.1.3 Operational Semantics
In the following, we give the operational semantics of F!b. It is clear that, inorder to obtain a strongly normalizing calculus, the unrolling of recursion has

to be restricted. It is safe to unroll a recursive function if all of its arguments

42 CHAPTER 3. TYPE-BASED TERMINATION
are values, however, it is sufficient if the recursive argument is a value (i. e., theargument which decreases in the recursive call). In

F!b, the number of the re-cursive argument is associated with the index n of the recursion operator. A

candidate for the unrolling rule is

fixun s t1..n (*xr) -! s (fixun s) t1..n (*xr),
since a *-abstraction is the canonical value in F!b. Considering this for anothermoment, we see that recursive and corecursive functions must also count as
values, since they are not eagerly unrolled, and under-applied constants, suchas a bare

fixum, should also be included. Anyhow, when we extend F!b with moreprimitive type constructors, more values will arise. So we trade the rule for the

following:

fixun s t1..n v -! s (fixun s) t1..n v.

What about corecursion? A corecursive function should also only be un-rolled on demand. Could we use the same rule for

fix*n--which would makethe distinction between
fixu and fix* superfluous? Actually, the above rule istoo strict for corecursion, it prevents sensible reductions. Consider, the type of

Burroni conatural numbers1 and their mapping function:

Bur : ord +! * +! *
Bur := *i*A. *i*X. A + X=

*i*A. *i*X8C. (A ! C) ! (X ! C) ! C

bmap : 8A8B. (A ! B) ! 8i. Buri A ! Buri B
bmap := * f . fix*1 *bmap*n. case n (*a. inl ( f a)) (*m. inr (bmap m))=

* f . fix*1 *bmap*n. n (*a. *g*h. g ( f a)) (*m. *g*h. h (bmap m))

Now we expect case (bmap f (inl a)) g h to reduce to g ( f a) even for variables f ,g, and h. Expanding

case and inl this simplifies to

(fix*1 (*bmap . . . ) (*g0*h0. g0 a)) g h.
Since variable g is not a value, this term would be stuck with the evaluationrule for

fixu. Unrolling on demand means for corecursive elements: unrolling inany evaluation context. This can be application to a variable like g, or being

applied to a recursive function.It is also clear that a corecursive function cannot be unrolled before all of its
arguments have been supplied and the result is demanded. For instance, wecannot allow a reduction rule like

e (fix*n s t1..m) -! e (s (fix*n s) t1..m) where m <= n.
1Capretta [Cap05] interprets Bur1A as computations of type A: Either it is a value of type A
(inl) or it is a "step" containing a computation of type A (inr). "Step" could be read as "hello, Iknow you are waiting for the result, I just want to tell you that I am still alive and busy with the

computation". A diverging computation is an infinite sequence of steps (fix*0 inr).

3.1. SPECIFICATION 43
This rule leads to divergence of well-typed terms if m < n. For example, con-sider the coinductive type of

Bool-hungry functions *i*X. Bool ! X and thefunction (communicated to me by Tarmo Uustalu during the APPSEM meeting

in Nottingham 2003)

veryHungry : 8i. Bool ! *i*X. Bool ! X
veryHungry := fix*1 *veryHungry*b*b0. veryHungry true.

Then veryHungry true would reduce in several steps to *b0. veryHungry true and,hence, diverge. But the above reduction rule is sound for m = n. This we will
show in the remainder of the chapter.

Evaluation frames and contexts.

Eframe 3 e ::= _ s application|

fixun s t1..n _ recursive function call

Ecxt 3 E ::= Id empty stack| E ffi e push frame

Frames and contexts can be interpreted as endo-functions on terms in the ob-vious way, i.e.,

(_ s)(r) := r s(
fixun s~t _)(r) := fixun s~t r

Id(r) := r(E ffi e)(r) := E(e(r))

Hence, by abuse of notation, Eframe, Ecxt ` Tm ! Tm.The head of a term t is the shortest term r such that E(r) = t for some
evaluation context E. For example if t = fixun s t1..n ((*xr0) s0), then *xr0 is thehead of t.

(Lazy) Values. While a normal form is a term which cannot be reduced further,we will refer to a canonical form as a value.

Val 3 v ::= *xt|

fixrn|
fixrn s~t where 0 <= |~t| <= n

Reduction. The contraction relation t ae t0 is given by the following axiomschemata:

RED-fi (*xt) s ae [s/x]t
RED-REC fixun s t1..n v ae s (fixun s) t1..n v if v 6= fix*n0 s0 t1..n0
RED-COREC e(fix*n s t1..n) ae e(s (fix*n s) t1..n) if e 6= fixun0 s0 t1..n0 _

44 CHAPTER 3. TYPE-BASED TERMINATION
Furthermore, we define the one-step reduction relation -! as closure of ae un-der all term constructors, -!+ as the transitive closure of -! and -!* as the
reflexive-transitive closure.

Remark 3.8 (On the choice of RED-REC) Why have we restricted the unfold-ing of recursive functions to call-by-value? First, note that the completely unrestricted unrolling of fixed points, fixun s -! s (fixun s), gives immediately rise toinfinite reduction sequences. Secondly, we need recursive functions to be evaluation contexts, i. e., a recursive function applied to a variable may not unfoldthe function definition. Otherwise, each function definition which contains a
recursive call will immediately loop under full reduction.

Remark 3.9 (Confluence) If we omit the side conditions in the fixed-point un-rolling rules

RED-REC and RED-COREC, then reduction would not be confluent,not even locally confluent for closed terms. Critical pairs would arise when in

RED-REC, the value v was a corecursive function, or in RED-COREC, the evalu-ation frame e was a recursive function; in this case, both rules could fire. For
instance, let s = *_*xx, f = fixu0 s, and v = fix*0 s. On one hand, f v -! s f v,whose only reducts are (

*xx) v and v. On the other hand, f v -! f (s v) whichreduces further only to f

*xx, s f *xx, (*xx) *xx and *xx. The deeper reasonfor non-confluence is that we cannot unfold all fixed-points, since we want to

ensure normalization.

In order to overcome this defect, we have inserted restrictions that removethe critical pairs, make reduction confluent and weak head reduction deterministic.

Remark 3.10 (Why prevent both reductions?) For a term with clashing fixedpoints, e. g., t :=

fixu0 s (fix*0 s0), we currently allow no contraction. As we haveseen in the previous remark, allowing both fixed-point reductions would lead

to non-confluence, and it would even break a crucial property of strongly nor-malizing terms: they are closed under weak head expansion2 (see Remark 3.27).
But could we not give priority to one kind of fixed-points and keep one reduc-tion of the two? This would break symmetry, but does it do any harm? Yes, as
we will see in the proofs of lemmata 3.32 and 3.37. The term t would not beconsidered neutral; removing the reduction of

fixu would break the first lemma(3.32), and removing the reduction of
fix* would break the second one (3.37).

For system F!b, we are only interested in strong normalization. We willpresent a better behaved, iso-(co)inductive, system in Section 4.1 and show
that its normalization can be inherited from F!b.

Example 3.11 (Reduction for repeat) Let A be a type and a : A. Recall that

2Here, we mean a restricted form of weak head expansion, which usually preserves strong
normalization. E.g., [s/x]t only expands to (*xt) s if s is strongly normalizing.

3.2. EXAMPLES 45
repeat a = fix*0 (*repeat. pair a repeat). We have the following reduction sequences

fst (repeat a) -! (repeat a) K-! (

*repeat. pair a repeat) (repeat a) K-!
pair a (repeat a) K-!3
K a (repeat a)-!2 a

snd (repeat a) -!+ K0 a (repeat a)-!

repeat a

Note that repeat a does neither reduce by itself, nor as argument to a non-recursive function like

pair, K, etc. (lines 2-4). It only reduces if it is appliedto something (line 1). This fixed-point unfolding on demand is a generalization

of the strategy of Amadio and Coupet-Grimal [ACG98], Gime'nez [Gim98], andBarthe et al. [BFG+04], who unfold corecursive definition only under case distinction.Although there are variations on the order of reductions, one will find that
there is no possibility that the fixed-point repeat a is unfolded more than once.Each unfolding "eats" one destructor (like

fst or snd), which guarantees termi-nation.

Lemma 3.12 (Substitution) Reduction is closed under substitution.

1. If t -! t0 then [s/x]t -! [s/x]t0.
2. If s -! s0 then [s/x]t -!* [s0/x]t.

Proof. The first by induction on t -! t0, the second by induction on t. \Lambda 

Example 3.13 (Types not admissible for recursion) There are types which areOK in the domain-theoretic semantics of Hughes, Pareto, and Sabry [HPS96],
but not in our current reduction semantics:

Nati * Nat1 ! Nat1 addition and multiplication (uncurried)
Listi A * ListiB ! ListiC list zip-with (uncurried)

We discuss modification of our semantics in Section 7.2.But these types are not admissible and lead to undefined recursive functions.

List1(Nati) ! C admits function fixu0 * f *_. f nil
Nati ! (Nat ! Nati) ! C see Section 5.1(

Nat ! Nati) ! C ditto

3.2 Examples
To flesh out the definition of F!b, we present some simple examples in this sec-tion. More examples will be given in Chapter 6. If clear from the context, we
will write Nat for Nat1 to denote the type of all natural numbers.

46 CHAPTER 3. TYPE-BASED TERMINATION
3.2.1 Fibonacci Numbers
A basic exercise in lazy functional programming is to code up the stream ofFibonacci numbers in one line, assuming we have the standard library function

zipWith : 8A8B8C. (A ! B ! C) !8i.

Streami A ! StreamiB ! StreamiC

zipWith := * f . fix*2 *zip*s*t. pair ( f (fst s) (fst t)) (zip (snd s) (snd t)).

Note that the type of zipWith is admissible for corecursion, since i appears neg-atively in

Streami A and StreamiB. In F!b, the Fibonacci stream can be defined asfollows (assuming 0, 1 :

Nat and + : Nat ! Nat ! Nat).

fib : Stream1Nat
fib := pair 0 (fix*0 *zip. pair 1 (zipWith (+) zip (pair 0 zip))).

The body of the corecursive definition is well-typed. We assign the followingtypes:

zip : Streami Nat
pair 0 zip : Streami+1 Nat <= Streami Nat(

zipWith . . . ) : Streami Nat
pair 1 (zipWith . . . ) : Streami+1 Nat

It is instructive to understand why the alternative definition of the Fibonaccistream as

fix*0 *fib. pair 0 (pair 1 (zipWith (+) (snd fib) fib)
is not well-typed in F!b.

3.2.2 Co-Natural Numbers
Non-standard natural numbers are given by the type CoNat = *1*X. 1 + X.We can define all natural numbers plus infinity:

0 := inl()
1 := inr 0
2 := inr 1.

..
! := fix*0 inr

All these values inhabit CoNat.

3.2.3 Some Pathological Cases
Datatypes like Emptya := ua**XX are called unguarded since their unfoldingdoes not produce a "real" data type constructor like +, *, or !, which would

enable production of inhabitants. Since [[Empty]](ff + 1) = [[Empty]](ff), we have

3.2. EXAMPLES 47

[[Empty]] = ?*. It is easy to check that fixu0 *xx : 8C8i. Emptyi ! C, so the
Empty type can be eliminated through a recursive function. A bit counterintu-itively, this function, which is the primary example of a looping definition in

functional programming, is termination on all inputs--simply because we cannever construct a value of

Emptya.
Dually, the unguarded coinductive type Unita := *a**XX is inhabited by
fix*0 *xx. This function is normalizing as well because there is no well-typedevaluation context for elements of type

Unita.

3.2.4 Huffman Trees
Huffman codes are space-optimal and prefix-free. To decode a Huffman-codedbit stream, one uses a Huffman tree, i. e., a binary tree whose leaves are labeled

by the characters whose code is the path to their leaf. In Haskell, we can im-plement the decoding function as follows.3

data Huffman b c = Leaf c

-- Node (b -? Huffman b c)

decode :: Huffman b c -? [b] -? [c]
decode t0 = dec0

where dec0 = dec1 t0

where dec1 (Leaf c) bs = c : dec0 bs

dec1 (Node f) (b:bs) = dec1 (f b) bs

There are two subroutines: the corecursive dec0 of type [b] -? [c] decodes astream starting with the full Huffman-tree

t0, whereas dec1, of the same typeas
decode, is defined by recursion on subtrees of t0. Observe that the recursivecall to

dec0 is guarded by the stream constructor (:), although not according toCoquand's conditions [Coq93], because it is inside another fixed point.

In F!b, we can define the type Huffmana B C of B-branching C-leaf labeledtrees of height

< a as follows:

Huffman : ord +! * -! * +! *
Huffman := *i*B*C. ui**X. C + (B ! X)

leaf : 8B8C8i. C ! Huffmani+1 B C
leaf := inl

node : 8B8C8i. (B ! Huffmani B C) ! Huffmani+1 B C
node := inr

3Yong Luo observed that decode (Leaf c) [] produces an infinite stream of cs. This shows
that decode is not necessarily terminating on finite input, although it is, as we will prove in thefollowing, productive. One could ask whether

decode's behavior on the singleton Huffman tree
Leaf c makes sense. I think "yes", because an infinite text over an alphabet with a single charactercontains no information. Regardless what the input stream of Huffman codes is, the output will

just consist of cs. In this case, we do not even have to look at the input.

48 CHAPTER 3. TYPE-BASED TERMINATION
The decoding function takes a Huffman-tree t and a B-stream s. If the t is anode

inr f , we take the first element b from the stream and continue with theb-th subtree of t, i. e., f b, and the remaining stream. If t is a leaf

inl c, we canoutput c and continue with the original Huffman tree t

0.

decode : 8B8C. Huffman1 B C ! Stream1 B ! Stream1 C
decode := *t0. fix*1 *dec0.\Gamma 

fixu0 *dec1.*t*s. case t(

*c. pair c (dec0 s))(
* f . dec1 ( f (fst s)) (snd s))\Delta  t0

This code is a close translation of the Haskell program, one clearly sees theouter corecursion (

fix*1 *dec0) and the inner recursion (fixu0 *dec1). We can assignthe following types to variables and subterms:

t0 : Huffman1 B Cdec

0 : Stream1 B ! Streami Cdec
1 : Huffmanj B C ! Stream1 B ! Streami+1 Ct :

Huffmanj+1 B Cs :
Stream1 Bc : C

pair c (dec0 s) : Streami+1 Cf : B !

Huffmanj B Cf (
fst s) : Huffmanj B C
dec1 ( f (fst s)) (snd s) : Streami+1 C\Gamma 

fixu0 . . . \Delta  : Huffman1 B C ! Stream1 B ! Streami+1 C

The type of dec0 is admissible for corecursion with one argument, fix*1 -adm,since it is a function type into a coinductive type

*i . . . , and the domain ismonotone in the size variable i, since it does not mention it. Similarly, the

type of dec1 is admissible for recursion on the first argument, fixu0 -adm, since itsdomain is an inductive type and its codomain is trivially monotone in the size
variable j.This example could be handled in the calculus of Barthe et al. [BFG+04]
and in my TLCA system [Abe03], but not in the system of Hughes, Pareto, andSabry [HPS96, Par00], since they forbid function spaces in data types.

In the following, we allow ourselves some syntactic sugar and write the
case-expression as pattern matching:

match t with

leaf c 7! pair . . .
node f 7! dec1 . . .

Creating a Huffman tree. Huffman [Huf52] presented an algorithm how tocreate a optimal prefix-free binary code for a set of characters from their relative frequencies. This algorithm can be coded directly in F!b. For simplicity,

3.2. EXAMPLES 49
assume that the characters and their frequencies are given as a list of pairs(n

1, leaf c1), ..., (nk leaf ck) of natural numbers and singleton Huffman trees.Assume further, this list is sorted ascendingly by frequencies (if not, sort it

first--sorting can also be coded in F!b, as we will see later).

We abbreviate the type of frequency-tree pairs by WT. Two pairs can bejoined by adding the frequencies and constructing a node with the two given

trees as subtrees:

WT : *
WT := Nat * Huffman1 Bool Char

join : WT ! WT ! WT
join := *x*y. pair (fst x + fst y) (*b. snd (if b then x else y))

Huffman's algorithm works as follows: Pick the pairs with the least frequen-cies, join them and solve the remaining problem. If we start with a sorted list,
we have to insert the joined pair into the remaining list in order, before we re-cursively process the remainder. It is crucial that

insert is defined in such a waythat our type system can "see" that the extended list is only one element larger.

But this is the case for the obvious recursive definition of insert, as for examplepresent in the Haskell prelude. Here, we give a version slightly optimized for
our purposes: it returns head and tail of the result list separately, in order tostatically exclude the impossible case that an empty list is returned. (In the following, we consider frequency comparison x <= y for x, y 2 WT to be alreadydefined.)

insert : 8i. WT ! Listi WT ! WT * Listi WT
insert := fixu1 *insert*x*xs. match xs with

inl _ 7! pair x xs
inr (pair y ys) 7! if x <= y then pair x xs

else pair y (inr (insert x ys))

huffman : 8i. WT ! Listi WT ! Huffman1 Bool Char
huffman := fixu1 *huffman*x*xs. match xs with

nil 7! snd x
cons y ys 7! uncurry huffman (insert (join x y) ys)

Herein, uncurry is an auxiliary function defined as usual.

uncurry : 8A8B8C. (A ! B ! C) ! A * B ! C
uncurry := * f *p. f (fst p) (snd p)

Using the impredicative encoding A * B = 8C. (A ! B ! C) ! C of prod-ucts, we can state the last case without

uncurry directly as

insert (join x y) ys huffman.

50 CHAPTER 3. TYPE-BASED TERMINATION
It is easy to see that the recursive call to huffman is justified. Some types are:

xs : Listi WT <= Listi+1 WTys :

Listi WT
insert (join x y) ys : WT * Listi WT
uncurry huffman : WT * Listi WT ! Huffman1 Bool Char

Finally, Huffman encoding can also be coded in F!b, although for this, weneed another data structure, mapping characters to Huffman codes.

3.2.5 Prime Numbers
Productivity of certain streams depends on non-trivial mathematical results.For example, the stream of prime numbers is productive since there are infinitely many primes. If the converse was true, i. e., if there were only n primesand m the product of these primes, then m + 1 would be relatively prime to
all n primes. This proof by Euclid guarantees a prime number between n + 1and m + 1. We can exploit this fact to define a stream of prime numbers in

F!b.The definition is an adaption of Miculan and Gianantonio's function p(m, n)

[GM03, tenth page]:

p(m, n) = n n :: p(m * n, n + 1) if gcd(m, n) = 1p(m, n + 1) else
If F!b, we require a dummy argument k to count down the maximum numberof steps until the next prime is found.

pr : 8i. Nat ! 8j. Nat ! Natj ! Streami Nat
pr := fix*3 *pr*m.

fixu1 *pr0*n*k. match k with

zero 7! . . .
succ k0 7! if gcd m n = 1 then

pair n (pr (m * n) (n + 1) ((m - 1) * n + 1))
else pr0 (n + 1) k0

primes : Stream1Nat
primes := pr 1 2 1

Herein, gcd : Nat ! Nat ! Nat computes the greatest common divisor and+ and * denote sum and product of natural numbers. Since in each executed

function instance pr m n k the invariant m + 2 = n + k holds, the case k = 0 isimpossible; otherwise the counter n would have stepped over m + 1 without
finding a prime. Hence, the dots ". . . " in the first match-branch will never bereached and can be replace with any term of the right type.

3.2.6 Sorting by Merging
The sorting algorithm whose termination is most easy to establish is insertionsort: insertion is primitive recursive, and sorting is performed by iteratively

3.2. EXAMPLES 51
inserting elements into a list which is empty in the beginning. Quick sort ismore difficult, since the recursive calls happen on indirect sublists. It has been
treated elsewhere [Abe04]. This time, we treat merge sort. Let A be some typewith a total order <=: A ! A !

Bool. Sorted merging can be defined bylexicographic recursion on the two input lists.

merge : 8i. Listi A ! 8j. Listj A ! List1 A
merge : fixu0 *merge0*l1. match l1 with

nil 7! *l2. l2
cons x xs 7! fixu0 *merge1*l2. match l2 with

nil 7! l1
cons y ys 7! if x <= y then cons x (merge0 xs l2)

else cons y (merge1 ys)

A more precise type for merge would be 8i8j. Listi A ! Listj+1 A ! Listi+j A(since the index counts the number of constructors as opposed to the length of
the list, the +1 in the type of the second list is necessary--one nil constructor isdiscarded during the merge). But our type system, unlike Hughes, Pareto, and
Sabry's [HPS96], does not handle addition of sizes. 4Merge sort recursively splits the input list, until only singleton lists remain,
and then merges the lists together in a sorted fashion. For our type systemto accept merge sort, it is crucial to know that both output lists of the split
operation are not longer than the input list (in most, but not all cases, theywill be strictly shorter, namely half the length). The natural type for

split is8A8i. Listi A !
Listi A * Listi A; with the impredicative encoding of products
split can be written tail-recursive, in continuation-passing style (CPS).

split : 8A8i. Listi A ! 8C. (Listi A ! Listi A ! C) ! C
split := fixu0 *split*l*k. match l with

nil 7! k nil nil
cons x xs 7! split xs (*ys*zs. k (cons x zs) ys)

We assign the following types.

split : Listi A ! 8C. (Listi A ! Listi A ! C) ! C

l : Listi+1 A
k : 8C. (Listi+1 A ! Listi+1 A ! C) ! Cx : A

xs : Listi Asplit xs : (

Listi A ! Listi A ! C) ! Cys, zs :
Listi A
cons x zs, ys : Listi+1 Ak (

cons x zs) ys : C

4Although there is an addition on ordinals, it is not commutative and hence would be a bit
misleading in a type system (since most programmers would think of natural number addition).We could, however, introduce another kind

nat of finite sizes which supports addition.

52 CHAPTER 3. TYPE-BASED TERMINATION
The type of split is fixu0 -adm since the result type 8C. (Listi A ! Listi A ! C) !C is positive in size variable i.

Finally, we define merge sort msort via an auxiliary function msort0 suchthat

msort0 a as sorts the list cons a as by merging.

msort : List1 A ! List1 A
msort := *l. match l with

nil 7! nil
cons a as 7! msort0 a as

msort0 : A ! List1 A ! List1 A
msort0 := fixu1 *msort*a*xs. match xs with

nil 7! cons a nil
cons b l 7! split l (*as*bs. merge (msort a as) (msort b bs))

The recursive calls to msort are legal because of the typing of split. Indeed, wecan assign the following types:

msort : A ! Listi A ! List1 Aa, b : A
xs : Listi+1 Al :

Listi Aas, bs :
Listi A

Altenkirch, McBride, and McKinna [AMM05] demonstrate that sorting by merg-ing can be implemented in a structurally recursive fashion by explicating the
computation pattern into an inductive data type. Applying short-cut fusion5to their program, one arrives at the usual functional formulation of merge sort.
They point out that Turner [Tur95] has also defused quick sort, arriving at thestructural tree sort [Bur69].

3.2.7 A Heterogeneous Data Type of Lambda Terms
In Haskell, we can define heterogeneous, also called nested, data types, for in-stance:

data TLam a = Var a

-- App (TLam a) (TLam a)
-- Abs Ty (TLam (Maybe a))

(Herein, Ty denotes some Haskell type of object-level type expressions.) Thetype

TLam a is called heterogeneous, since the argument to the data type con-structor

TLam varies in a recursive occurrence on the right hand side. It is inhab-ited by de Bruijn representations of typed lambda terms over a set of free variables "a". A similar type has been studied by Altenkirch and Reus [AR99] and

5Intermediate tree structures are eliminated by the acid rain theorem.

3.2. EXAMPLES 53
Bird and Paterson [BP99b]; a precursor has been considered already by Pfen-ning and Lee [PL89] and Pierce, Dietzen, and Michaylov [PDM89]. The constructor for lambda-abstraction Abs expects the type of the abstracted variableand a term over the extended set of free variables

Maybe a, which is the Haskellrepresentation of the sum type 1 +
a. The disjoint sum reflects the choice fora bound variable under the abstraction: either it is the variable freshly bound

(left injection into the unit set "1") or it is one of the variables that have beenavailable already (right injection into "

a").In
F!b, we can express the type constructor TLam by a least fixed point of

kind * +! *.

Ty : *
TLam : ord +! * +! *
TLam := *i. ui* +!**X*A. A + (X A * X A + Ty * X (1 + A))

var : 8i8A. A ! TLami+1 A
var := *x. inl x

app : 8i8A. TLami A ! TLami A ! TLami+1 A
app := *r*s. inr (inl hr, si)

abs : 8i8A. Ty1 ! TLami (1 + A) ! TLami+1 A
abs := *a*r. inr (inr ha, ri)

A whole article [AMU05] has been devoted to functions defined by iterationover heterogeneous data types.

F!b can simulate all the systems discussedin that article, hence, all examples in that article can be replayed in

F!b. In
F!b, some functions can be given more precise typings, e. g., the functorial-ity/monotonicity witness of

TLam:

mapTLam : 8i8A8B. (A ! B) ! TLami A ! TLamiB
mapTLam := fixu1 *mapTLam* f *t. match t with

var x 7! var ( f x)
app r s 7! app (mapTLam f r) (mapTLam f s)
abs a r 7! abs a (mapTLam (lift f ) r)

lift : 8A8B. (A ! B) ! (1 + A ! 1 + B)
lift := * f *t. match t with

inl hi 7! inl hi
inr x 7! inr ( f x)

The call mapTLam f t renames all free variables in t according to f ; the structureof t remains unchanged, which is partially reflected in the type of

mapTLam: itexpresses that the output term is not higher than the input term. The type of

recursion is polymorphic:

C(i) = 8A8B. (A ! B) ! TLami A ! TLamiB.
This is typical for functions over heterogeneous data types; in our example,since in the recursive call

mapTLam (lift f ) r the argument r has type TLami (1 +

54 CHAPTER 3. TYPE-BASED TERMINATION

A), the variable A of the recursion type C(i) has to be instantiated to 1 + A. Itis well-known that type reconstruction for polymorphic recursion is undecidable [Hen93, KTU93], hence, we cannot hope for an autonomous type inferencealgorithm for

F!b.This example will be continued in Section 6.3.

3.2.8 Substitution for Finite and Infinite Lambda-Terms
Altenkirch and Reus [AR99] describe a substitution function for de Bruijn-stylelambda-terms as a heterogeneous data type. During substitution under a abstraction, a new free variable is temporarily introduced, hence, all free vari-ables in the substitute terms have to be lifted (renamed). Altenkirch and Reus
perform this lifting operation also using substitution, and give a lexicographictermination argument. McBride [McB06] has, besides generalizing it to typed
lambda-terms, exhibited the primitive recursive structure behind this algo-rithm, by giving a single traversal function for lambda-terms that is then instantiated to yield renaming or substitution. In the following, we demonstratethat we can replay his development in

F!b, although only for untyped terms,and that the same algorithm is recognized to be productive for infinite lambdaterms.The generating type constructor for untyped de Bruijn terms is

LamF, fromwhich we get the types of finite (
Lam) and infinite (CoLam) terms:

LamF : (* +! *) +! * +! *
LamF := *X*A. A + (X A * X A + X (1 + A))

Lam : ord +! * +! *
Lam := *i. ui* +!*LamF

CoLam : ord -! * +! *
CoLam := *i. *i* +!*LamF

The data constructors are uniformly definable for finite (r = u) and infinite(r =

*) terms:

var : 8i8A. A ! ri+1LamF A
var := *x. inl x

app : 8i8A. riLamF A ! riLamF A ! ri+1LamF A
app := *r*s. inr (inl hr, si)

abs : 8i8A. riLamF (1 + A) ! ri+1LamF A
abs := *r. inr (inr r)

In the absence of sized types, renaming and substitution can be subsumed un-der the common type

8A8B. (A ! F B) ! rLamF A ! rLamF B,

3.2. EXAMPLES 55
where F is instantiated with the identity in case of renaming, and with Lam incase of substitution. We are dealing with sized types, however, and in the case
of infinite terms we would like that both renaming and substitution are of type
CoLami A ! CoLamiB. This means that the result of renaming and substitutionis defined at least up to the same depth than the input. Hence, we let F depend

on a size argument and obtain the type

8i8A8B. (A ! Fi B) ! CoLami A ! CoLamiB.
McBride parameterizes the generic traversal function for de Bruijn terms by akit that is passed as an extra argument to the traversal function. The kit contains

three functions: a mapping from variables into F, a mapping from F to terms,and a lifting function on F. For our purposes is more convenient to separate
the second function from the rest. We say F has term structure if it is pointedand supports lifting:

TmStr : (ord -! * +! *) ffi! *
TmStr := *F8i8A.(A ! Fi+1 A) * (Fi A ! Fi(

1 + A))

We have chosen F to be antitonic in the size index since we will later instantiateit with

CoLam.If F has term structure, we can lift functions f : A ! Fi+1B to make room

for one extra variable:

lift : 8F : ord -! * +! *. TmStr F !8

i8A8B. (A ! Fi+1B) ! (1 + A ! Fi+1(1 + B))

lift := *hvr, wki* f *ma. match ma with

inl hi 7! vr (inl hi)
inr a 7! wk ( f a)

Generic traversal now works for all F which can be converted to terms usingthe parameter tm. It is defined as follows:

trav : 8F : ord -! * +! *. TmStr F ! (8i8B. Fi+1B ! ri+1LamF B) !8i8A8B. (A ! Fi B) ! (ri

LamF A ! riLamF B)

trav : *k*tm. fixr *trav* f *t. match t with

var a 7! tm ( f a)
abs r 7! abs (trav (lift k f ) r)

app r s 7! app (trav f r) (trav f s)

Note that f : A ! Fi+1B, but, in the recursive call, trav f s expects f to be oftype A ! FiB. This is fine because F is antitone in its size argument, hence

A ! Fi+1B <= A ! FiB. In case of r = u, fixr has to be instantiated with fixu1 ,and with

fix*2 in case of r = *. In both cases, the type

C(i) = 8A8B. (A ! Fi B) ! (riLamF A ! riLamF B)

56 CHAPTER 3. TYPE-BASED TERMINATION
is admissible for (co)recursion, again since F is antitonic.Instantiating F with

*i*A.A, we obtain the renaming function for free vari-ables:

rename : 8i8A8B. (A ! B) ! riLamF A ! riLamF B
rename := trav hid, inri var

Substitution for infinite terms is obtained by the instantiation F = CoLam:

subst : 8i8A8B. (A ! CoLamiB) ! CoLami A ! CoLamiB
subst := trav hvar, rename inri id

The best type we can give to substitution of finite terms in F!b is (A !
Lam1B) ! Lam1 A ! Lam1B. We first have to type-check trav with a spe-cialized type, and then instantiate it with F =

*i. Lam1:

trav : 8F : * +! *. TmStr (*iF) ! (8B. F B ! Lam1B) !8i8A8B. (A ! F B) ! (

Lami A ! Lam1B)

subst : 8A8B. (A ! Lam1B) ! Lam1 A ! Lam1B
subst := trav hvar, rename inri id.

3.3 Limits, Iteration, and Fixed-Points
In this section, we will define transfinite iteration to give a semantics to inductive and coinductive types. We will calculate the closure ordinal ?ord ofiteration, such that,

u1 and *1 are indeed fixed-points. This will justify therules
TY-FOLD and TY-UNFOLD for the case a = 1.

3.3.1 Limits
Let (O, <=) be some complete linear ordering, e.g., the set of ordinals up to ?ordand (

L, v, inf, sup) some complete lattice. For f 2 O ! L and * > 0 a limitordinal in

O we define:

inf* f := infff<* f (ff) infimumsup

* f := supff<* f (ff) supremum

lim inf* f := supff0<* infff0<=ff<* f (ff) limes inferior
lim sup* f := infff0<* supff0<=ff<* f (ff) limes superior

Lemma 3.14 (Relationships) In the above context, if * 6= 0,

inf* f v lim inf* f v lim sup

* f v sup* f .

If lim inf* f = lim sup* f = x for some x 2 L, we say that the limit of f at *exists and set lim

* f = x.

3.3. LIMITS, ITERATION, AND FIXED-POINTS 57
Lemma 3.15 (Limes inferior of monotone function) If f is monotone below *,i. e., f (

ff) v f (fi) for all ff < fi < *, then lim inf* f = sup* f .

Proof. For monotone f it holds that infff0<=ff<* f (ff) = f (ff0). \Lambda 

Corollary 3.16 If f is monotone below *, then lim* f = sup* f .
Lemma 3.17 (Limes superior of antitone function) If f is antitone below *, thenlim sup

* f = inf* f .

Proof. For antitone f it holds that supff0<=ff<* f (ff) = f (ff0). \Lambda 

Corollary 3.18 If f is antitone below *, then lim* f = inf* f .

A function f is continuous in *, if f (*) = lim* f . Here we mean continu-ous in the sense of classical analysis, not in the sense of domain theory, where

continuity includes monotonicity.

3.3.2 Operator Iteration
By the theorem of Knaster and Tarski we know that in each complete lattice
L least and greatest fixed-points of monotone operators F 2 L ! L exist.The least fixed-point of F , for instance, can be defined either "from above" as

inf{G | F (G) v G} or from below as the ffth iterate Fff(?) for some suffi-ciently large ordinal

ff. We choose the second alternative since our system F!balso speaks about approximations F

fi(?) for fi < ff. In the following we will

make it clear what we mean by transfinite iteration Fff(G) in arbitrary com-plete lattices

L--we will of course only use the notion for our operator lattices[[
^]], but the specifics about the lattice do not matter for iteration and fixed-points.

Transfinite iteration. Let F 2 L ! L be an endo-function, G 2 L and ff anordinal number. We define the

ff-iterate Iff F G of F at G by transfinite recursionon
ff.

I0 F G := G

Iff+1 F G := F (Iff F G)

I* F G := lim infff!*(Iff F G)

We use Fff(G) as a shorthand for Iff F G. For the limit case, we chose to use thelimes superior, as Danner [Dan99]. Note that iteration is well-defined for any

F , in particular, non-monotonic F . However, many reasonable properties oniteration hold only for a monotonic F .

Lemma 3.19 (Iteration of monotonic function) If F v F 0 2 L +! L then Iff F v
Iff F 0 2 L +! L for any ff 2 On.

58 CHAPTER 3. TYPE-BASED TERMINATION
Proof. By induction on ff. \Lambda 

For iteration to be monotonic in the ordinal index, we need to start iterationat an element G 2

L for which F is inflationary, meaning F (G) w G. Whenwe use iteration to define the semantics of

u, iteration will start at G = ?, forwhich any F is trivially inflationary, hence the semantics of

u will be monotonein the ordinal argument for any monotone F .

Lemma 3.20 (Iteration of inflationary function6) Let F 2 L +! L and G 2 Lwith G v F (G). Then

1. Fff(G) v Ffi(G) for ff <= fi, and
2. Ffi(G) v Ffi+1(G).
Proof. Simultaneously by induction on fi. Since v is reflexive, it is sufficientto show F

ff(G) v Ffi(G) for ff < fi instead of proposition 1.

Case fi = 0. For part 1, there is nothing to show, part 2 follows by assumption.
Case fi = fi0 + 1. For part 1, assume ff < fi0 + 1. By induction hypothesis 1,F

ff(G) v Ffi0 (G), and by induction hypothesis 2, Ffi0 (G) v Ffi0+1(G).

Hence the claim follows by transitivity. For part 2, just use monotonicityof F on the induction hypothesis.

Case fi = * limit ordinal. For part 1, assume ff < *. Since by induction hy-pothesis 1 function

ff 7! Fff(G) is monotone below *, by Lemma 3.15it is sufficient to show that F

ff(G) v supff<* Fff(G)--which trivially

holds. For part 2 we can apply Lemma 3.15 similarly which leaves us thegoal sup

ff<* Fff(G) v F *+1(G). Assume an arbitrary ff < *. By induc-tion hypothesis 1, Fff(G) v F *(G), hence by monotonicity Fff+1(G) v

F *+1(G). Since ff was arbitrary and F 0(G) v F 1(G) by assumption, itholds for all

ff < * that Fff(G) v F *+1(G). Hence, we are done. \Lambda 

6Our formulation of Lemma 3.20 is actually equivalent to Danner's Lemma 3.5 [Dan99]. He
states instead (in our notation):

If I,+1 F x w I, F x, then for all fl > ff >= ,, Ifl F x w Iff F x.
Letting G := I, F x, his premise states that F should be inflationary on G. His conclusion can bereformulated to

for all fl0 > ff0, Ifl0 F G w Iff0 F G
where fl = , + fl0 andff = , +ff0. The new formulation is identical to the old since ordinal additiondistributes over iteration in the following way:

I,+ff F = Iff F ffi I, F
This equation can be proven by transfinite induction on ff (note that ordinal addition is defined byrecursion on the second argument) and holds without any assumptions on F. The equation also

appears in Danner's Theorem 3.7, but only for monotone F.

3.3. LIMITS, ITERATION, AND FIXED-POINTS 59

If F is monotone and deflationary, F (G) v G, for the start value G, theniteration will be antitonic in the ordinal index. This is, for instance, the case if
we choose G = ?, as we will do for the interpretation of *.
Lemma 3.21 (Iteration of deflationary function) Let F 2 L +! L and G 2 Lwith G w F (G). Then

1. Fff(G) w Ffi(G) for ff <= fi, and
2. Ffi(G) w Ffi+1(G).
Proof. Analogously to Lemma 3.20. \Lambda 

Summarizing, we can say that for a monotone F which is inflationary (de-flationary) for G, we get a monotone (antitone) function f (

ff) = Iff F G. In bothcases, the limes inferior of f at some limit ordinal
* coincides with the limessuperior (lemmas 3.15 and 3.17), and, by definition of f , with the actual value

f (*) of f at *, hence f is continuous at all limit ordinals.

3.3.3 Fixed points
By the theorem of Knaster and Tarski [Tar55], each monotonic operator F 2
L ! L in a complete lattice L has a least fixed point. This fixed point canbe reached "from below" by transfinite iteration of F , starting at the bottom

element ? of the lattice. By Lemma 3.20, the iterates Fff(?) form an ascendingchain. If for some ordinal

fl

F (Ffl(?)) v Ffl(?),
i.e., the fl-iterate is a prefixed point of F , then the least fixed point of F has beenreached and we call

fl the closure ordinal of operator F .Analogously, the greatest fixed point does exist which can be reached "from

above" by starting at the top element ? of the lattice. By Lemma 3.21, theapproximations F

ff(?) form a descending chain. For some ordinal fl it holds

that F (F

fl(?)) w Ffl(?),

i.e., the fl-iterate is a postfixed point of F , and the greatest fixed point has beenreached.

Cardinalities for pure kinds. Since each A 2 [[*]] is a subset of the countableset ?* by definition, the cardinality of [[*]] is at most i

1 = |P (N)|, an uncount-able cardinal number. With i
n+1 we denote the cardinality of the power setP (i
n) of the previous cardinal in. Let ^ = ~p~^ ! * be a pure kind, then[[
~p~^ ! *]] ae P ([[^1]] * . . . * [[^n]] * [[*]]) hence the following lemma holds:

Lemma 3.22 (Upper bound for cardinality) For pure kind ^,

|[[^]]| <= irk(^)+1.

60 CHAPTER 3. TYPE-BASED TERMINATION
Proof. By induction on ^. Base case ^ = * follows by assumption. For the stepcase, let n >= 1 and

^ = ~p~^ ! *.

|[[~p~^ ! *]]| <= |P ([[^1]] * . . . * [[^n]] * [[*]])| set-theoretic function space<= |P

(irk(^1)+1 * . . . * irk(^n)+1 * i1)| induction hypothesis<= |P

(imax{rk(^i)+1|1<=i<=n})| cardinal multiplication<=
i1+maxi rk(^i)+1 definition of in
= irk(^)+1 definition of rank

\Lambda 

Closure ordinal. At which ordinal fl will least and greatest fixed point besurely reached for any monotone operator? We can give a "brute-force" upper
bound for fl as follows: Assume we want to construct a fixed point in lattice
L = [[^]] for some ^ by a chain (Fff) of approximations. Since the cardinalityof

L is bounded by in where n = rk(^) + 1 (see Lemma 3.22), the chain canenumerate less then i

n elements Fff where 0 <= ff < in. Hence, the elementF
in must be the fixed point. An upper bound fl for the closure ordinal for allmonotone operators F in all lattices [[

^]] with ^ pure kind is the supremum ofall i

n, the ordinal i!. Now we can complete the definition of [[ord]] setting

?ord := i!.

3.3.4 Inductive and Coinductive Constructors
Now, we can fix the semantics of u^ and *^. Recalling that [[C]]` was defined as
Sem(C), we set

Sem(u^)(ff)(F ) := Fff(?^), and
Sem(*^)(ff)(F ) := Fff(?^).

Lemma 3.23 (Semantics of (co)inductive constructors fulfill specification) Wehave

[[u^]] 2 [[ord]] +! ([[^]] +! [[^]]) +! [[^]],
[[*^]] 2 [[ord]] -! ([[^]] +! [[^]]) +! [[^]].

Proof. By definition and lemmata 3.19, 3.20, and 3.21. \Lambda 

Theorem 3.24 (Soundness of folding and unfolding) Let r^ 2 {u^, *^}, F 2

[[^]] +! [[^]], and ff 2 [[ord]]. We set

G := F ([[r^]] ff F ) (unfolded) ,H := [[r

^]]([[s]]ff) F (folded) .

Then G v^ H and H v^ G.

3.4. SEMANTICAL TYPES 61
Proof. We consider the inductive case r^ = u^, the case of coinductive constructors is proven analogously. Observe that G = Fff+1(?) and H = F [[s]]ff(?).
Since [[s]]ff = ff + 1 for ff < ?ord, the only interesting case is ff = ?ord. Then,

[[s]]ff = ?ord, but G v H still holds since F ?ord (?) is a fixed point of F . \Lambda 

The soundness of rules TY-FOLD and TY-UNFOLD is a consequence of this the-orem.

3.3.5 Soundness of *-Dropping
The least fixpoint of a constructor equation

X : ^
X ~A = F X ~A

can mechanically be expressed as u1^ *X* ~A. F X ~A. However, if F is of a reg-ular structure, the rank of the fixed-point can be decreased. For instance, the
equation

List A = 1 + A * List A

has, besides the mechanical solution u1* +!**X*A. 1 + A * X A with a rank-2fixed-point, the rank-1 solution

*A. u1* *Y. 1 + A * Y. The second constructorhas been obtained from the first by lambda dropping. With our semantics, we can

prove that the two solutions describe the same lists. More generally, assume aconstructor

\Gamma  , i : ord ` F : ^2 +! ^1 p! ^2
and a family of valuations `(ff) := `[i 7! ff] for some ` 2 [[\Gamma  ]]. Then for all
ff 2 [[ord]],

[[ri* p!**X*A. F (XA) A]]`(ff) = [[*A. ri^2 *Y. F YA]]`(ff)
The proof proceeds by transfinite induction on ff without difficulties.

3.4 Semantical Types
In this section, we give a generic term model for our calculus, showing thatthe typing rules are sound. Later we will instantiate this model to obtain a
proof of strong normalization. A generic soundness proof can, for instance, befound in work of Vouillon [Vou04] and Mellie`s [VM04]. The idea is to consider
types as closed sets of terms between a (minimal) set N of neutral terms and a(maximal) set S of safe terms. Informally a set is closed if for each of its terms t
it also contains all terms t0 which behave the same as t (for instance, weak headreducts of t). The result of the soundness proof is that each typable term is
safe. Safe can mean different things: e.g., that the term evaluates without error;in our case a safe term will be a strongly normalizing one. Although we have

62 CHAPTER 3. TYPE-BASED TERMINATION
taken some ideas from Vouillon and Mellie`s to structure our soundness proof,it needs to be stressed that their method does not directly apply, since we are
interested in strong and not just weak normalization. For instance, we have tointroduce the concepts of safe evaluation contexts and safe reduction. Matthes
[Mat05] defines such safe contexts for a classical system F with sum types; safeevaluation is only implicit in his inductive definition of strongly normalizing
terms.Vaux [Vau04] and the author, in joint work with Coquand [AC05], have carried out a generic soundness proof where semantical types were not requiredto be closed sets. This was possible since in their model

fi-equal terms wereidentified. From such a model, however, one can only harvest a proof of weak

normalization. A proof of strong normalization cannot be extracted, since theproperty "strongly normalizing" is not preserved under

fi-equality.7 Hence,we need to fall back to closed sets; in our case, we use a form of saturated sets

[Tai75, Luo90], which are a variant of Girard's reducibility candidates [GLT89].In the following we will develop requirements for our model and exhibit
them with labels with the prefix REQ.

Function space. Many models of the *-calculus define the function space be-tween sets of terms A and B as

A ! B := {r | r s 2 B for all s 2 A}.
In other words, every term which behaves as a function--because it can beapplied--is considered a function.8 The function space A ! B will be a closed

set if B is closed and A is a set of safe terms.

Type interval. Each semantical type [[A]] must contain only safe terms andcontain all neutral terms. In the following, we assume a set S `

Tm of safeterms and a set N `
Tm of neutral terms such that

REQ-N -SUB-S N ` S,
REQ-S -VAL if t 2 S \ N then t B v 2 Val.

Herein, B is a to-be-defined evaluation relation. One could think of t B v as "tevaluates to v without error"; then a choice for S would be the terms whose

evaluation does not throw an exception, but might diverge, and N would con-tain the diverging terms. In our case B will be a variant of weak head reduction, and N will consist of the non-values which do not weak head reduce.

7If t is strongly normalizing and \Omega  diverging, then (*_t) \Omega  is fi-equal to t but only weakly
normalizing.8Matthes [Mat00] calls this definition elimination based. The alternative is to define the function space introduction based as the closure of the set of all function constructions, in our case *-abstractions, recursive and corecursive functions. The elimination-based approach has the obvious
advantage of succinctness and spares us from defining a closure operator. The introduction-basedapproach, however, has other advantages: it provides a predicative semantics of disjoint sums
[AA00] [Mat05, Sect. 4] or other constructions which have an elimination into an arbitrary type(e.g., unary sums as in the computational

*-calculus [LS05]).

3.4. SEMANTICAL TYPES 63
Each semantical type A will be in the interval [N , S], i. e., N ` A ` S. In thefollowing we establish the requirements for ! to be an operator on term sets
in this interval.

Safe evaluation contexts are isolated by the judgements e 2 Sframe and E 2
Scxt.

SF-APP s 2 S_ s 2 Sframe SF-REC s, t1 . . . tn 2 Sfixun s t1..n _ 2 Sframe

SC-ID Id 2 Scxt SC-PUSH E 2 Scxt e 2 SframeE ffi e 2 Scxt
A strict function is one which is undefined for undefined arguments, or, whichdiverges if called with a diverging argument. We generalize "diverging" to
"neutral" and call a function strict which maps neutral terms to neutral terms.Safe evaluation frames must be strict functions [Vou04], i. e.,

REQ-STRICT e(N ) ` N for all e 2 Sframe.
A trivial consequence is that all safe evaluation contexts are strict as well.

Lemma 3.25 (Function space is above N ) If A ` S and N ` B then N `A ! B.

Proof. Since REQ-STRICT can be rewritten as N ` e-1(N ) for all e 2 Sframe,the lemma becomes obvious if rewrite the definition of function space to

A ! B = "

s2A(_ s)

-1(B).

(By SF-APP we have N s ` N ` B for all s 2 A, hence, N ` (_ s)-1(B).)Alternatively, the lemma follows from monotonicity of function space, since

REQ-STRICT implies N ` S ! N . \Lambda 

Vouillon [Vou04] defines the function space as the set of safe terms whichbehave as a function. In our model instance, all functions will turn out to be

safe, hence, we make this a requirement.

REQ-FUN-SAFE N ! S ` S
(This condition is one property of what Vaux [Vau04] calls a stable pair (N , S).)

Lemma 3.26 (Functions are safe) If N ` A and B ` S then A ! B ` S.
Proof. Since, the function space construction is contravariant on its domainand covariant on its codomain, the lemma follows directly from

REQ-FUN-SAFE.\Lambda 

Summing up, the requirements guarantee that function space remains withinthe type interval, i. e., [N , S] ! [N , S] ` [N , S].

64 CHAPTER 3. TYPE-BASED TERMINATION
3.4.1 Saturation
In this section, we axiomatize the evaluation relation B and define a genericnotion of saturated set.

Safe weak head reduction. We assume a relation B on terms with the follow-ing properties.

REQ-fi (*xt) s B [s/x]t if s 2 S
REQ-REC fixun s t1..n v B s (fixun s) t1..n v if v 6= fix*n0 s0 t1..n0
REQ-COREC e(fix*n s t1..n) B e(s (fix*n s) t1..n) if e 6= fixun0 s0 t1..n0 _

REQ-ECXT E(t) B E(t0) if t B t0
REQ-TRANS B is transitive
The least relation satisfying these requirements would be weak head reduction ifwe omitted the side condition s 2 S in

REQ-fi. In the presence of this condi-tion, thinking of S as the set of strongly normalizing terms, two related terms

behave equivalently with respect to strong normalization.9 Consequently, werequire that S is closed under B in both directions.

REQ-S -CLOSED If t 2 S and t B t0 or t C t0 then t0 2 S.
Remark 3.27 Here, we give another justification that we need to prevent fixed-point unfolding in a term of the shape

fixu s (fix* s0). Assume there were no sideconditions on the reduction rules for fixed points. Let s =

*_.x and e = fixu id _.Then

e(s (fix* s)) -! e(x) neutral, bute(

fix* s) -!+ e(fix* s) diverging.

Hence, the rolled and unrolled version do not behave the same, and at least therule

REQ-COREC would be unsound.

Saturated sets. A set A is saturated, A 2 SAT, if N ` A ` S and A is closedunder B-reduction and -expansion.

Remark 3.28 If A is a set of safe terms and closed under B-reduction, thenproperty

REQ-S -VAL is inherited from S to A. This holds especially for A 2
SAT.

Lemma 3.29 (Function space is closed) If B is closed, then so is A ! B.

9In the absence of the side condition, [s/x]t could be strongly normalizing while (*xt) s is not
(if x 62 FV(t)). The side condition can also be meaningful in different contexts. E. g., if "safe"means "evaluating without error" [Vou04, VM04], and s evaluates to an error, then the

fi-reduction(
*xt) s B [s/x]t is not semantics-preserving in call-by-value languages.

3.4. SEMANTICAL TYPES 65
Proof. Let r 2 A ! B. For r0 B r we show r0 2 A ! B by assuming anarbitrary s 2 A and deriving r0 s 2 B. But this follows from r s 2 B, since both
r0 s B r s by REQ-ECXT and B is closed under B-expansion. In the same way,closure under B-reduction is inherited from B to A ! B. By the previous
remark, we are done. \Lambda 
Corollary 3.30 (Function space is saturated) If N ` A ` S and B 2 SAT thenA ! B 2

SAT.

Proof. By the previous lemma, the function space A ! B is closed. It isbetween N and S by lemmata 3.25 and 3.26. \Lambda 

Corollary 3.31 (Abstractions are functions) Let A, B 2 SAT. If [s/x]t 2 B forall s 2 A, then

*xt 2 A ! B.

Proof. For s 2 A ` S we have to show (*xt) s 2 B. This follows from(

*xt) s B [s/x]t 2 B, since B is closed under B-expansion. \Lambda 

3.4.2 Admissible Types for Recursion
In the last section, we have established that semantic types model abstractionand application. Now we turn our attention to the recursion combinators that

extend the *-calculus.Let

O be an initial segment of the ordinal numbers.

Admissible semantic types for recursion. The semantic type family A 2
O ! SAT is admissible for recursion on the n + 1st argument if

ADM-u-SHAPE A(ff) = Tk2K(B1..n(k, ff) ! I(k, ff) ! C(k, ff))for some index set K

and B1, . . . , Bn, I, C 2 K * O ! SAT,
ADM-u-START I(k, 0) ` N for all k 2 K, and
ADM-u-LIMIT infff<* A(ff) ` A(*) for all limits 0 6= * 2 O.

For the soundness of this criterion we need a recursive function applied toa corecursive value to be neutral.

REQ-FIXu FIX* fixun s t1..n (fix*n0 s0 t01..n0 ) 2 N if s,~t, s0,~t0 2 S
However, now there are closed neutral terms, which is quite uncommon. Thismeans that semantically, all types are inhabited by closed terms, which in turn

means that we cannot use this semantics to show that the type theory is consis-tent. More concretely, we cannot show that 8A.A does not have closed inhabitants. But this is not important for strong normalization.A summary of accumulated requirements is given in Table 3.1.

66 CHAPTER 3. TYPE-BASED TERMINATION

Cat. Page RequirementN

62 REQ-N -SUB-S N ` S63

REQ-STRICT Scxt(N ) ` N65
REQ-FIXu FIX* fixun s t1..n(fix*m s0 t01..m) 2 NS
62 REQ-S -VAL if t 2 S \ N then t B v63

REQ-FUN-SAFE N ! S ` S64
REQ-S -CLOSED SB ` S, BS ` SB
64 REQ-fi (*xt) s B [s/x]t64

REQ-REC fixun s t1..n v B s (fixun s) t1..n v64
REQ-COREC e(fix*n s t1..n) B e(s (fix*n s) t1..n)64
REQ-ECXT if t B t0 then E(t) B E(t0)64
REQ-TRANS B is transitive

Table 3.1: Summary of requirements.

Lemma 3.32 (Recursion is a function) Let A 2 O ! SAT be admissible for re-cursion on the n + 1st argument. If s 2 A(

ff) ! A(ff + 1) for all ff + 1 2 O, then
fixun s 2 A(fi) for all fi 2 O.

Proof. By transfinite induction on fi 2 O.

The limit case is a direct consequence of ADM-u-LIMIT.
For the remaining cases, using ADM-u-SHAPE, assume k 2 K, ti 2 Bi(k, fi)for 1 <= i <= n, and r 2 I(k,

fi) and show fixun s~t r 2 C(k, fi). Since all ti are safeand s is safe by assumption, e :=

fixun s~t _ is a safe evaluation frame. Hence,if r 2 N , then e(r) 2 N ` C(k,
fi), and in case fi = 0 we are done, since, by
ADM-u-START, the set I(k, 0) contains only neutral terms.

Finally, we consider fi = ff + 1 and r B v. If v = fix*n0 s0 t01..n0 , then e(v) 2N ` C

(k, ff + 1) by REQ-FIXuFIX*. Otherwise, note that s (fixun s) 2 A(ff + 1)by assumption and induction hypothesis. Since e(r) B e(v) B s (

fixun s)~t v 2C(k,
ff + 1), we conclude by closure of C(k, ff + 1) under B-expansion. \Lambda 

3.4.3 Refined Saturation
In this section, we will refine our notion of saturation, to prepare for the treat-ment of corecursion.

Orthogonality. An orthogonality relation t ? E between term t and evaluationcontext E is given by

t ? E :() E(t) 2 S.
For a set A of terms we can compute its orthogonal, the set E of evaluationcontext in which all terms t 2 A behave well, i. e., evaluate safely. In another

iteration, we take the orthogonal of this set E of evaluation contexts, i. e., all

3.4. SEMANTICAL TYPES 67
terms which behave well in all contexts E 2 E, and arrive at the biorthogo-nal of the original term set. The biorthogonal is closed and can serve as a semantical type--this idea is implicit in Girard's semantics of linear logic andresurfaces in Ludics [Gir01]. Girard has not written up the idea clearly himself, but it slowly spread in the (French) research community. Parigot [Par97,page 1469] defines a saturated set (which is a semantical type in the context of
strong normalization proofs) as a set A of terms that are strongly normalizingwhen applied any list

~s 2 E of strongly normalizing terms contained in a cer-tain set E of term lists. Applying to a list of terms is a special case of putting

into an evaluation context--hence, Parigot effectively uses Girard's technique(without reference), albeit not the intuition of orthogonality. Matthes [Mat05]
builds on the work of Parigot and extends it to arbitrary evaluation contexts.A nice presentation of orthogonality can be found in the recent work of Vouillon [Vou04] and Mellie's [VM04]---this is where I draw my terminology from.However, they do not show strong normalization; I had to add the concept
of safe evaluation context to make it work in my case. Recently, Lindley andStark [LS05] have used biorthogonality to show strong normalization of the
computational *-calculus and they refer to Andrew Pitts. In personal commu-nication, Andrew Pitts claimed to have invented the technique independently
of the French School.After having given honor to our teachers, we now can define:

E ? := {t 2 Tm | t ? E for all E 2 E } for E ` Ecxt
SAT? := {E | {Id} ` E ` Scxt}
SAT := {E ? | E 2 SAT?}N

:= Scxt?

Note that (_)? is an antitonic operation. Since S = {Id}?, it is clear that S isthe greatest and N the least saturated set.10 By definition, the set of neutral

terms N also fulfills the requirements REQ-N -SUB-S and REQ-STRICT. Therequirement

REQ-FIXuFIX* is now phrased in terms of S:

REQ-FIXuFIX* E(fixun s t1..n (fix*n0 s0 t01..n0 )) 2 S for all E 2 Scxt

Lemma 3.33 (E ? is closed) If for t 2 E ? it holds that t B t0 or t0 B t, then t0 2 E ?.
Proof. We need to show E(t0) 2 S for all E 2 E. This holds since B is closedunder evaluation contexts and S is closed under B. \Lambda 

Corollary 3.34 The new notion of SAT is a refinement of the old one.
We need to show that the function space is still an operation on SAT.

Lemma 3.35 (Function space in SAT) If N ` A ` S and B 2 SAT then A !B 2

SAT.

10The converse, S? = {Id} is not true if we let S be the set SN of strongly normalizing terms:
Because r 2 SN implies r x 2 SN for any variable x, we have (_ x) 2 SN?.

68 CHAPTER 3. TYPE-BASED TERMINATION
Proof. Let E ? = B. By definition, A ! B = ^E ? with ^E := {E ffi (_ s) | E 2E and s 2 A} `

Scxt. Since (A ! B) " S = A ! B by REQ-FUN-SAFE, wehave A ! B = ^E ? " {

Id}? = ( ^E [ {Id})?. The last step is formally proven inLemma 3.38. \Lambda 

For the semantical justification of the typing rule for corecursion, which willbe given in the next section, we require

fix* to be safe, if applied to a numberof safe arguments up to its arity.

REQ-FIX* fix*n 2 Sn+1 ! S.
The remaining requirements are displayed in Table 3.2.

Cat. Page RequirementS

67 REQ-FIXuFIX* Scxt(fixun s t1..n(fix*m s0 t01..m)) ` S62

REQ-S -VAL if t 2 S \ N then t B v63
REQ-FUN-SAFE N ! S ` S64
REQ-S -CLOSED SB ` S, BS ` S
68 REQ-FIX* fix*n 2 Sn+1 ! SB
64 REQ-fi (*xt) s B [s/x]t64

REQ-REC fixun s t1..n v B s (fixun s) t1..n v64
REQ-COREC e(fix*n s t1..n) B e(s (fix*n s) t1..n)64
REQ-ECXT if t B t0 then E(t) B E(t0)64
REQ-TRANS B is transitive

Table 3.2: Summary of refined requirements.
A bit surprisingly, corecursive values can be found in N :
Lemma 3.36 (Neutral corecursive values) neutral corecursive values If s, t1..n 2S and s (

fix*n s) t1..n 2 N then v := fix*n s t1..n 2 N .

Proof. We have to show that E(v) 2 S for all E 2 Scxt. In case E = Id,we have v 2 S by

REQ-FIX*. Otherwise E = E0 ffi e. Either e is a recursivefunction, then E0(e(v)) is safe by

REQ-FIXuFIX*, or e is an applicative evaluationframe and E0(e(v)) B E0(e(s (
fix*n s) t1..n)) which is neutral by assumption and
REQ-STRICT, hence, E0(e(v)) 2 S by Lemma 3.33. \Lambda 

An example for such a neutral term is fix*0 *_x

3.4.4 Admissible Types for Corecursion
Admissible semantic types for corecursion. The semantic type family A 2
O ! SAT is admissible for corecursion with n arguments if

ADM-*-SHAPE A(ff) = Tk2K(B1..n(k, ff) ! C(k, ff))for some index set K and B

1..n, C 2 K * O ! SAT,
ADM-*-START S ` C(k, 0) for all k 2 K, and

ADM-*-LIMIT infff<* A(ff) ` A(*) for all limits 0 6= * 2 O.

3.4. SEMANTICAL TYPES 69
Lemma 3.37 (Corecursion is a function) Let A 2 O ! SAT be admissible forcorecursion with n arguments. If s 2 A(

ff) ! A(ff + 1) for all ff + 1 2 O, then
fix*n s 2 A(fi) for all fi 2 O.

Proof. By transfinite induction on fi 2 O.The limit case is a direct consequence of

ADM-*-LIMIT.For the remaining cases, using
ADM-*-SHAPE, assume k 2 K, ti 2 Bi(k, fi)for 1 <= i <= n and show v :=
fix*n s~t 2 C(k, fi). Note that s and ti are safe, hence,v 2 S by
REQ-FIX*. Since S ` C(k, 0), we are done in case of fi = 0.For case

fi = ff + 1, let E ` Scxt be a set of evaluation contexts such thatE ? = C(k,
ff + 1). Assume an arbitrary E 2 E and show E(v) 2 S. If E =
Id, there is nothing new to show, otherwise E = E0 ffi e. If e = fixun0 s0 t1..n0 _,then E(v) 2 S by

REQ-FIXu FIX*. Otherwise, note that s (fix*n s) 2 A(ff + 1)by assumption and induction hypothesis. Since E(v) B E(s (

fix*n s)~t) 2 S, weconclude by closure of S. \Lambda 

3.4.5 Lattice of Saturated Sets
In this section we will establish that SAT is a complete lattice of sets. This willjustify the interpretation of universal quantification as intersection and enable

the choice [[*]] := SAT. Since A ` S for A 2 SAT, we set ?* := S.

De Morgan laws. The orthogonality operation E ? is an intuitionistic nega-tion. The following de Morgan laws hold:

Lemma 3.38 (De Morgan) Let I some non-empty index set and Ei ` Ecxt for alli 2 I. Then, T

i2I E ?i = (Si2I Ei)?, andS
i2I E ?i ` (Ti2I Ei)?.

Proof.

t 2 Ti2I E ?i () for all i 2 I, t ? E for all E 2 Ei() t ? E for all E 2 S

i2I Ei() t 2 (S
i2I Ei)?

t 2 Si2I E ?i =) for some i 2 I, t ? E for all E 2 Ei=) t ? E for all E 2 T

i2I Ei=) t 2 (T
i2I Ei)?

\Lambda 

The de Morgan laws can also be read topologically: Let the closed term setsbe the saturated ones. Then intersections of closed sets (even infinite intersections), are still closed, whereas this need not hold for unions. In the followingwe show by example that the missing de Morgan law does indeed not hold.

70 CHAPTER 3. TYPE-BASED TERMINATION
Lemma 3.39 (Orthogonality not classical) Let the set of safe terms S contain ex-actly the strongly normalizing ones. There are E

1, E2 ` Ecxt such that (E1 " E2)? 6`E ?
1 [ E ?2 .

Proof. Let ffi := *x. x x and ffi0 := *k. k ffi, E1 := {Id, (_ ffi)}, and E2 := {Id, (_ ffi0)}.Then (E

1 " E2)? = {Id}? = S, and the normal term ffi is safe. But ffi 62 E ?1 , since
ffi ffi -! ffi ffi, and ffi 62 E ?2 , since ffi ffi0 -! ffi0 ffi0 -! ffi0 ffi -! ffi ffi. \Lambda 

Remark 3.40 (Maximal sets of contexts) This counterexample is not completelysatisfying, because E ?

1 = E ?2 , hence, E1 and E2 are just incompatible represen-tations of the same saturated set A. This suggests that the representation of

a saturated set A should be the biggest set of contexts E such that E ? = A.Whether such maximal sets would satisfy the missing de Morgan law, is unclear to me and left as an open question.
As a consequence of the de Morgan laws, saturated sets form a complete lattice.

Corollary 3.41 (SAT closed under intersection) If A ` SAT, then T A 2 SAT.
Proof. If A is empty, we set T A = S. Otherwise, let E0 := S{E | E ? 2 A}.
Then E0 2 SAT? and E ?0 = A. \Lambda 

Since N is the least saturated set, ?* = T SAT = N .It follows that ([[*]], d*, ?*) := (

SAT, T, S) is a complete lattice of sets andcan serve as basis for our model of kinds, constructors, and subtyping as developed in Section 2.3. Soundness of the subtyping rule TY-SUB is an immediateconsequence of Theorem 2.27. Setting the interpretation of quantification to

[[8^]]` (F ) = Sem(8^)(F ) := "G2

[[^]] F (G),

soundness of the generalization and instantiation rules TY-GEN and TY-INST,follows immediately.

Supremum. The supremum of the lattice [[*]] is formally defined asF

*i2I Ai := d*{A 2 SAT | A w* Ai for all i 2 I}

= T{E ? | E 2 SAT? and E ? ' Ai for all i 2 I}
Vouillon [Vou04] presents another definition of the union of semantical types.Let

A? := {E 2 Scxt | t ? E for all t 2 A}
for a set of terms A. For reasons of symmetry, the de Morgan laws hold for A?as for E ?. Since for A `

Tm and E ` Scxt,

A? ' E () A ` E ?,

3.4. SEMANTICAL TYPES 71
the two orthogonality operations form a Galois connection between sets of terms(P (

Tm), `) ordered by inclusion and sets of safe evaluation contexts (Scxt, ')ordered by the superset relation (see Appendix C). Hence, the function which

maps A ` Tm to A

:= A??

is a closure operator on sets of terms.

Lemma 3.42 If A ` S then A? 2 SAT? and A 2 SAT.
Proof. If A ` S then Id 2 A?. Furthermore A? ` Scxt by definition. \Lambda 

We can now define union of term sets A 2 A as follows:S

A := S A

Remark 3.43 The closure operation plays a crucial role when we construct thesemantics of inductive types. Consider the approximations Nat

ff of the semantical type of natural numbers. For ff < !, Natff contains only boundednumbers, which can be characterized by a set of finite observations E. But Nat

!

cannot be characterized by finite observations alone; recursive evaluation con-texts (like the identity function on

Nat) are required. These come in throughthe closure operation that is involved in the supremum: Nat

! = S

ff<! Nat

ff.

Lemma 3.44 Let I be some index set and Ai ` S for all i 2 I. ThenF

*i2I Ai = S i2IAi.

Proof. Note that (*) (Si2I Ai)? 2 SAT? by Lemma 3.42.F

*i2I Ai = T{E ? | E 2 SAT? and E ? ' Ai for all i 2 I} definition

= T{E ? | E 2 SAT? and E ` A?i for all i 2 I} Galois conn.
= T{E ? | E 2 SAT? and E ` Ti2I A?i }
= \Gamma S{E | E 2 SAT? and E ` (Si2I Ai)?}\Delta ? de Morgan
= \Gamma Si2I Ai)?? (*)
= S i2I Ai definition

\Lambda 
The supremum of saturated term sets is the closure of their set-theoreticalunion, but not necessarily identical to it, which is the case for the more traditional notion of saturation as found in Section 3.4.1 and in, e. g., Luo [Luo90],Altenkirch [Alt93, AA00], Matthes [Mat98, Mat00], Barthe et al. [BFG+04], and
previous work of the author [Abe03, Abe04].We have now given a semantical justification for each typing rule. We will
assemble these pieces in the next section, where we give a term model of ourcalculus.

72 CHAPTER 3. TYPE-BASED TERMINATION
3.5 Soundness of Typing
3.5.1 Admissible Types for Recursion, Syntactically
Having a semantical characterization of admissible types for recursion we canturn it into a syntactical one. For now, we give a simple characterization: A
recursive function goes from an inductive type to a result type which dependsmonotonically on the ordinal index. This is the shape of types from Barthe et al.
[BFG+04] and from previous work of the author [Abe04]. Examples wouldbe

Nati ! A and Listi A ! Nati, where A does not depend on the ordinalindex i. Excluded would be types like

Nati ! Streami A (since Streami A isantitone in i) or
Nati ! Nati ! Nati, the latter being the type of the maxi-mum function. Since we also have inductive constructors, the general shape of

the recursive argument is uiF~H. Then we allow the recursive function to be anatural transformation, i. e., of the shape 8X :

^0. uiF (H1 X) . . . (Hn X) ! G X.Of course, we can quantify over several constructor variables, arriving at the

shape 8~X :~^0. uiF (H1 ~X) . . . (Hn ~X) ! G ~X, or, using the abbreviation for natural transformations, at (uiF) ffi ~H ) G. As a final relaxation, we do not requirethe inductive argument to be the first one. The function may have n parameters

before the inductive argument, but their types must be antitone in the ordinalindex.

\Gamma  ` A fixun-adm :() \Gamma  , i : ord ` A i = (~G, (uiF) ffi ~H ) G) : * (i 62 FV(A))

for some F, G, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : +ord ` G : ^0 for some ^0 = ffi~^0 ! *,
\Gamma  , ' : -ord ` Gi : ^0 for 1 <= i <= n, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

We now prove this criterion sound. To this end, we will make use of the se-mantics of declarative kinding and equality (see Section 2.3).

Lemma 3.45 (Soundness of admissible recursion types) If \Gamma  ` A fixun-adm and
` 2 [[\Gamma  ]], then [[A]]` is admissible for recursion on the n + 1st argument, where O maybe any initial segment of [[

ord]].

Proof. Since \Gamma  , i : ord ` A i = (~G, (uiF) ffi ~H ) G) : * and i 62 FV(A), we knowby Thm. 2.27 that for each

ff 2 O,

[[A i]]`[i7!ff] = [[A]]`(ff) = [[~G, (uiF) ffi ~H ) G]]`[i7!ff] 2 [[*]] = SAT.
Hence, A := [[A]]` 2 O ! SAT. In the following, we verify the conditions

ADM-u-SHAPE, ADM-u-START, and ADM-u-LIMIT.

3.5. SOUNDNESS OF TYPING 73

ADM-u-SHAPE Show A(ff) = Tk2K B1..n(k, ff) ! I(k, ff) ! C(k, ff). We set

K := [[^01]] * * * * * [[^0m]] where m := |~^0|,B

i( ~X , ff) := [[Gi]]`[i7!ff] ~X for 1 <= i <= n,I( ~X

, ff) := (Iff [[F]]` ?^)([[H1]]` ~X ) . . . ([[Hl]]` ~X ) where l := |~^|, andC
( ~X , ff) := [[G]]`[i7!ff] ~X .

ADM-u-START Show I( ~X , 0) ` N . This is clear since I0 [[F]]` ?^ = ?^ and?

^ H1 . . . Hl = ?* = N for any ~H.

ADM-u-LIMIT Show inf* A ` A(*). We assume f 2 inf* A and prove

f 2 B1..n( ~X , *) ! I( ~X , *) ! C( ~X , *).
To this end, fix arbitrary ti 2 Bi( ~X , *) and r 2 I( ~X , *). By Lemma 3.15,
the inductive type at a limit I( ~X , *) = supff<* I( ~X , ff), hence r 2 I( ~X , ff)
for some ff < *. Since \Gamma  , ' : -ord ` Gi : ^0, the families Bi( ~X , _) are
antitone, hence ti 2 Bi( ~X , ff). Together, f ~t r 2 C( ~X , ff) ` C( ~X , *) by
monotonicity of C( ~X , _), which we obtain from \Gamma  , ' : +ord ` G : ^0. \Lambda 

3.5.2 Admissible Types for Corecursion, Syntactically
Similarly to the admissible types for recursion one can motivate the ones forcorecursion. The most important requirement is that the result type of a corecursive function must be coinductive. In essence, our rule is the one of Bartheet al. [BFG+04], lifted to coinductive constructors and natural transformations.

\Gamma  ` A fix*n-adm :() \Gamma  , i : ord ` A i = (~G ) (*iF) ffi ~H) : * (i 62 FV(A))

for some F, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : -ord ` Gi : ^0 (all i) for some ^0 = ffi~^0 ! *, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

Lemma 3.46 (Soundness of admissible corecursion types) If \Gamma  ` A fix*n-admand

` 2 [[\Gamma  ]], then [[A]]` is admissible for corecursion with n arguments (where O maybe any initial segment of [[

ord]]).

Proof. Since \Gamma  , i : ord ` A i = (~G ) (*iF) ffi ~H) : * and i 62 FV(A), we knowby Thm. 2.27 that for each

ff 2 O,

[[A i]]`[i7!ff] = [[A]]`(ff) = [[~G ) (*iF) ffi ~H]]`[i7!ff] 2 [[*]] = SAT.
Hence, A := [[A]]` 2 O ! SAT. In the following, we verify the conditions

ADM-*-SHAPE, ADM-*-START, and ADM-*-LIMIT.

74 CHAPTER 3. TYPE-BASED TERMINATION

ADM-*-SHAPE Show A(ff) = Tk2K B1..n(k, ff) ! C(k, ff). We set

K := [[^01]] * * * * * [[^0m]] where m := |~^0|,B

i( ~X , ff) := [[Gi]]`[i7!ff] ~X for 1 <= i <= n, andC( ~X

, ff) := (Iff [[F]]` ?^)([[H1]]` ~X ) . . . ([[Hl]]` ~X ) where l := |~^|.

ADM-*-START Show S ` C( ~X , 0). This is clear since I0 [[F]]` ?^ = ?^ and?

^ H1 . . . Hl = ?* = S for any ~H.

ADM-*-LIMIT Show inf* A ` A(*). We assume f 2 inf* A and prove

f 2 B1..n( ~X , *) ! C( ~X , *).
To this end, fix arbitrary ti 2 Bi( ~X , *) and show f ~t 2 C( ~X , *). By
Lemma 3.17, the coinductive type at a limit C( ~X , *) = infff<* C( ~X , ff),
hence, we need to show f ~t 2 C( ~X , ff) for arbitrary ff < *. Since \Gamma  , ' :-

ord ` Gi : ^0, the families Bi( ~X , _) are antitone, hence ti 2 Bi( ~X , ff).
Together, f ~t 2 C( ~X , ff) by assumption. \Lambda 

3.5.3 Soundness Proof
Valuations. For the remainder of this chapter, we consider valuations ` 2(

TyVar [ Var) ! (S^[[^]] [ Tm) which map constructor variables X to seman-tical constructors F 2 [[

^]] for some ^ and term variables to terms. Since aconstructor F does not depend on term variables, it is easy to see that [[F]]

` =[[F]]
`_TyVar. The denotation LtM` of a term t under a valuation ` is defined asfollows: L

cM` := cLxM

` := `(x)Lr sM

` := LrM` LsM`L
*xtM` := *x. LtM`[x7!x] if x is singular in LtM`

By x singular in LtM`, we mean that x 62 FV(`(y)) for any y 2 FV(t) which isdifferent from x.11 Singularity is important to avoid variable capture in terms

of the substitution ` by the *-abstraction, which has moved to the outside. Wecan express singularity by the equivalent condition x 62

FVL*xtM`. Note thatsingularity can always be achieved by renaming of the bound variable x, since

FVLtM` is finite.
Lemma 3.47 (Substitution for singular variable) If x is singular in LtM`, then wehave [s

/x]LtM`[x7!x] = LtM`[x7!s].

Proof. By induction on t. \Lambda 

11This is the variable condition in the corresponding part of Barthe et al. [BFG+04].

3.5. SOUNDNESS OF TYPING 75
Sound valuations. We define the proposition ` 2 [[\Gamma  ]] by recursion on \Gamma  .

` 2 [[\Pi ]] :() true
` 2 [[\Gamma  , X : p^]] :() ` 2 [[\Gamma  ]] and `(X) 2 [[^]]
` 2 [[\Gamma  , x : A]] :() ` 2 [[\Gamma  ]] and `(x) 2 [[A]]`

This notion is compatible with ` 2 [[\Delta ]] from Section 2.3: If \Delta  is the restrictionof

\Gamma  to constructor variable declarations, then ` 2 [[\Gamma  ]] implies ` 2 [[\Delta ]].

Lemma 3.48 (Sound context lookup) If \Gamma  cxt and both (x : A) 2 \Gamma  and ` 2 [[\Gamma  ]]then

`(x) 2 [[A]]` 2 [[*]].

Proof. By induction on \Gamma  cxt, using Lem. 2.20. \Lambda 

Theorem 3.49 (Soundness of typing) If \Gamma  ` t : A and ` 2 [[\Gamma  ]] then LtM` 2 [[A]]`.
Proof. By induction on the typing derivation.

Case

TY-VAR (x : A) 2 \Gamma  \Gamma  cxt\Gamma  ` x : A

By Lemma 3.48, since LxM` = `(x).
Case

TY-ABS \Gamma  , x : A ` t : B\Gamma  ` *xt : A ! B

Let A := [[A]]` and B := [[B]]`. Since, by Lemma 3.4, the context \Gamma  , x : A iswellformed, we have by Lemma 3.48 that A 2

SAT. Likewise, B 2 SATby Lemma 2.20, since Lemma 3.5 entails
\Gamma  ` B : *. W. l. o. g., x is singularin LtM

`. To show that L*xtM` = *x.LtM`[x7!x] 2 A ! B, by Corollary 3.31 itis sufficient to show [s

/x]LtM`[x7!x] 2 B for arbitrary s 2 A. This, however,

follows from the induction hypothesis, since `[x 7! s] 2 [[\Gamma  , x : A]], and[s

/x]LtM`[x7!x] = LtM`[x7!s] by Lemma 3.47.

Case

TY-APP \Gamma  ` r : A ! B \Gamma  ` s : A\Gamma  ` r s : B

Let A := [[A]]` and B := [[B]]`. By induction hypothesis, LrM` 2 A ! Band LsM

` 2 A, thus Lr sM` = LrM` LsM` 2 B by definition of the functionspace.

Case

TY-GEN \Gamma  , X :^ ` t : F X\Gamma  ` t : 8

^ F X 62 FV(F)

By definition of [[8^]], we have to show LtM` 2 [[F]]`(G) for all G 2 [[^]].This follows by induction hypothesis, since

`[X 7! G] 2 [[\Gamma  , X : ^]], and[[F X]]

`[X7!G] = [[F]]`(G) because X 62 FV(F).

76 CHAPTER 3. TYPE-BASED TERMINATION

Case

TY-INST \Gamma  ` t : 8^ F \Gamma  ` G : ^\Gamma  ` t : F G

By induction hypothesis, LtM` 2 TG2[[^]][[F]]`(G) and [[G]]` 2 [[^]]. HenceL

tM` 2 [[F G]]`.

Case

TY-SUB \Gamma  ` t : A \Gamma  ` A <= B : *\Gamma  ` t : B

By induction hypothesis LtM` 2 [[A]]`, which is a subset of [[B]]` by Lemma 2.20.
Case

TY-FOLD \Gamma  ` t : F (r^ a F) ~G\Gamma  ` t : r

^ (a + 1) F ~G

By Lemma 3.5 we have \Gamma  ` F (r^ a F) ~G : *, which entails \Gamma  ` F : +^ !
^ and \Gamma  ` a : ord, as well as \Gamma  ` Gi : ^i for 1 <= i <= |~^|, if we define

~p~^ ! * := ^. Hence, F := [[F]]` 2 [[^]] +! [[^]] and ff := [[a]]` 2 [[ord]] andwe can conclude by Theorem 3.24.

Case

TY-UNFOLD \Gamma  ` r : r^ (a + 1) F ~G\Gamma  ` r : F (r

^ a F) ~G

Analogously to case TY-FOLD.

Case

TY-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord \Gamma  cxt\Gamma  ` fixr

n : (8i : ord. A i ! A (i + 1)) ! A a

By lemmata 3.45 and 3.46 the family A := [[A]]` 2 [[ord]] ! [[*]] is admis-sible for (co)recursion. We assume s 2 T

ff2[[ord]] A(ff) ! A([[s]]ff) whichentails that s 2 A(
ff) ! A(ff + 1) for all ff < ?ord. By lemma 3.32 resp.
3.37 we conclude fixrn s 2 A([[a]]`). \Lambda 

A consequence of soundness is that all typable terms are safe, if variables areneutral.

Corollary 3.50 (Typable terms are safe) Assume Var ` N . If \Gamma  ` t : B thent 2 S.
Proof. Let ` be a valuation with `(X) = ?^ for all (X :^) 2 \Gamma  and `(x) = x forall (x : A) 2

\Gamma  . Since x 2 N ` [[A]]`, the valuation ` is sound w. r. t. context \Gamma  .Soundness of typing entails t = LtM

` 2 [[B]]` ` S. \Lambda 

3.6. STRONG NORMALIZATION 77
3.6 Strong Normalization
In this section, we will instantiate the set of safe terms S by an inductivelydefined set

SN of strongly normalizing terms and harvest a proof of strongnormalization from the soundness proof of typing.

3.6.1 A Few Remarks on the Method
The usual (classical) definition of strongly normalizing terms is: those terms,which have no infinite reduction sequences. This definition has quite nice closure

properties, which are intuitively obvious: for example, if a term has no infinitereduction sequences, then this is true for all of its subterms as well. Defining S
as the set of (classically) strongly normalizing terms, we see immediately that

REQ-FUN-SAFE, N ! S ` S, holds for non-empty N : If r 2 N ! S, then r sis strongly normalizing for any s 2 N , hence, r is strongly normalizing.

Barthe et al. [BFG+04] use this definition of strong normalization, albeit in apositive formulation. For us, this is not sufficient, since we also require that all
non-neutral terms in S reduce to a value. Usually, after having shown strongnormalization, this fact is a consequence of type preservation (subject reduction)
and progress [Pie02]. But we need it already to show strong normalization.

Why do we require this and Barthe et al. do not? Because we are workingin an equi-recursive system where an inhabitant of

uaF can be of any shape.Hence, a recursive function is unrolled when it is applied to any value. In an

iso-recursive system, which is used in far more normalization proofs [AA00,Abe03, Abe04, Mat05] a canonical inhabitant of

uaF is of the form in t where
in is a constructor. The semantics of uaF can be defined as those terms whichare neutral or reduce to

in t for some t. A recursive function f : uaF ! Cis only unrolled when applied to a constructor. In the normalization proof,

when looking at f r we know that r 2 [[ua+1F]] is either neutral or reduces to
in t. Then we can unroll the recursive function and conclude the reasoning byinduction hypothesis [Abe04, Thm. 5.10]. Similarly, in Lemma 3.32 we need

to know that r reduces to a value, but since ua+1F = F (uaF) can be any type(product type, function type, polymorphic type etc.), we need to know that the
non-neutral inhabitants of all semantical types reduce to a value. This is mostdirectly achieved by requiring that it holds for all safe terms.

A byproduct of this decision is that we also get more in the end: We notonly exclude non-termination; non-neutral terms also do not get stuck. Hence,
we get both strong normalization and progress.

The search for a suitable definition of S lead us to an inductive character-ization of strongly normalizing terms. For the lambda calculus, this was first

given by van Raamsdonk et al. [vRS95, vRSSX99], but it was already implicitin Goguen's work on typed operational semantics [Gog94, Gog95, Gog99].
Joachimski and Matthes used it to give a combinatorial normalization prooffor the simply-typed

*-calculus [JM03], and Matthes extended it to other cal-culi [Mat98, Mat00, Mat05].

78 CHAPTER 3. TYPE-BASED TERMINATION
3.6.2 Inductive Characterization
We set S := SN and B := -!*SN both of which will be defined below.

Strong(-ly normalizing) head reduction t -!SN t0 is defined inductively bythe following rules.

SHR-fi s 2 SN(*xt) s -!

SN [s/x]t SHR-FRAME

r -!SN r0
e(r) -!SN e(r0)

SHR-REC fixun s t1..n v -!

SN s (fixun s) t1..n v v 6= fix

*n0 s0 t01..n0

SHR-COREC fix*n s t1..n r -!

SN s (fix*n s) t1..n r

Note that due to the additional argument r, the last rule is just short for

SHR-COREC e(fix*n s t1..n) -!

SN e(s (fix*n s) t1..n) e 6= fix

un0 s0 t01..n0 _.

The crucial property is that the strong head expansion of a strongly normal-izing term is strongly normalizing as well. The reflexive-transitive closure of
strong head reduction fulfills the desired properties of B from Section 3.4.1.
Lemma 3.51 (-!SN is deterministic) If D :: r -!SN r0 and r -!SN r00 thenr0 = r00.

Proof. By induction on D. \Lambda 
Lemma 3.52 (REQ-ECXT) If t -!+SN t0 then E(t) -!+SN E(t0).
Proof. From SHR-FRAME by induction on E and -!+SN. \Lambda 
Corollary 3.53 The relation B :=-!*SN fulfills the five requirements REQ-fi, REQ-REC,

REQ-COREC, REQ-ECXT, and REQ-TRANS.

Strongly neutral terms r 2 SNe are defined inductively by the followingrules.

SNE-VAR x 2 SNe SNE-FRAME r 2 SNe e 2 Sframee(r) 2 SNe

SNE-FIXuFIX*

ez ""-- -
fixun s t1..n _ 2 Sframe

vz ""-- -
fix*n0 s0 t01..n0 2 SN
e(v) 2 SNe

Since the definition of Sframe rests on the definition of S = SN, strongly neutralterms are defined simultaneously with

SN below. Rule SNE-FIXuFIX* fulfillsrequirement
REQ-FIXuFIX*.

3.6. STRONG NORMALIZATION 79
Strongly normalizing terms t 2 SN.

SN-SNE r 2 SNer 2 SN SN-ABS t 2 SN*xt 2 SN SN-FIX ~t 2 SNfixr

n ~t 2 SN |

~t| <= n + 1

SN-EXP r -!SN r0 r0 2 SNr 2 SN SN-ROLL s (fix

*n s)~t 2 SN

fix*n s~t 2 SN |~t| <= n
The set SN consists of strongly neutral terms (SN-SNE) and strongly normaliz-ing values (

SN-ABS, SN-FIX) and is closed under strong head expansion (SN-EXP).Rule
SN-FIX fulfills requirement REQ-FIX*. The rule SN-ROLL is admissible, butwe have explicitely added it to simplify the proof of requirement

REQ-FUN-SAFE(see below).

Lemma 3.54 (SN is closed under B-expansion) If t -!*SN t0 and t0 2 SN thent 2

SN.

Proof. By rule SN-EXP. \Lambda 

It is clear that SN is also closed under B-reduction.
Lemma 3.55 (SN is closed under B-reduction) If t 2 SN and t -!*SN t0 thent0 2

SN.

Proof. By induction on t -!*SN t0. If the reduction sequence is empty (incase t = t0), there is nothing to show. Otherwise, we perform case analysis on

t 2 SN. The only rule which introduces redexes is SN-EXP.

SN-EXP t -!SN t00 t00 2 SNt 2 SN
Since -!SN is deterministic, the first reduction in the sequence t -!+SN t0 ist -!

SN t00. Thus, t0 2 SN follows by induction hypothesis. \Lambda 

Thus, SN fulfills requirement REQ-S -CLOSED.In contrast to the definition of strong normalization as the absence of infinite reduction sequences, the inductive characterization of SN also guaranteesthat every t 2

SN reduces to a weak head value, i. e., there are no stuck non-neutral terms.

Lemma 3.56 (SN is weak head normalizing) If r 2 SN then either r B r0 2 SNeor r B v 2

Val " SN.

Proof. By induction on r 2 SN. If the last rule was SN-EXP, we proceed byinduction hypothesis. All other rules introduce neutral terms or values. \Lambda 

Let BA := {r | r B r0 with r0 2 A} be the closure of a term set A underB-expansion.

80 CHAPTER 3. TYPE-BASED TERMINATION
Lemma 3.57 (Neutral terms) BSNe ` N .
Proof. Recall that N = Scxt?. Assume r B r0 2 SNe and E 2 Scxt and showE(r) 2

SN. Since E(r0) 2 SNe by iterated application of SNE-FRAME and SNe `
SN by rule SN-SNE, it follows that E(r0) 2 SN. Because E(r) B E(r0) and SN isclosed under B-expansion, E(r) 2

SN. \Lambda 

In particular, all variables are in N , which is a precondition of Cor. 3.50. Puttingthe last two lemmata together, we see that every term in S \ N reduces to a
strongly normalizing value v 2 SN under strong head reduction. Hence, SNfulfills

REQ-S -VAL.

Remark 3.58 (N 6= BSNe) The proposition N ` BSNe, which complementsLemma 3.57, does not hold: In Lemma 3.36 we have shown that some corecursive values inhabit N , but they are not in SNe. (If not for REQ-FIXuFIX*,this proposition would hold: We could show that no value v can be safely inserted into all safe contexts by exhibiting a safe context e = fixu0 (* f *y. f *xx) _in which all values would loop, even the strongly normalizing ones.)

In the following we show validity of REQ-FUN-SAFE, i. e., r 2 SN if r s 2 SNfor all s 2 N .

Lemma 3.59 (Extensionality) If D :: r x 2 SN or D :: r x 2 SNe then r 2 SN.
Proof. By induction on D.

Case

SNE-FRAME r 2 SNer x 2 SNe

By SN-SNE, r 2 SN.
Case Let |~t| = n.

SNE-FRAME s,~t 2 SNfixu

n s~t x 2 SNe

By SN-FIX, fixun s~t 2 SN.

Case

SN-SNE r x 2 SNer x 2 SN

By induction hypothesis.
Case

SN-FIX ~t 2 SNfixr

n ~t x 2 SN |

~t| <= n

Then fixrn ~t 2 SN by SN-FIX.

3.6. STRONG NORMALIZATION 81

Case

SN-EXP (*xt) x -!SN t t 2 SN(*xt) x 2 SN

Since t 2 SN, *xt 2 SN by SN-ABS.
Case

SN-EXP fix

*n s~t x -!SN s (fix*n s)~t x s (fix*n s)~t x 2 SN

fix*n s~t x 2 SN
By induction hypothesis, s (fix*n s)~t 2 SN. Hence, fix*n s~t 2 SN by SN-ROLL.
Case r -!

SN r0 SHR-FRAME

r x -!SN r0 x r0 x 2 SN SN-EXP

r x 2 SN
By induction hypothesis, r0 2 SN, hence r 2 SN by SN-EXP.

Case

SN-ROLL s (fix

*n s)~t x 2 SN

fix*n s~t x 2 SN |~t| < n
By induction hypothesis s (fix*n s)~t 2 SN, hence, fix*n s~t 2 SN by SN-ROLL.
Case

SN-ROLL x (fix

*n x) 2 SN

fix*n x 2 SN
Then fix*n 2 SN by SN-FIX. \Lambda 

Corollary 3.60 (REQ-FUN-SAFE) N ! SN ` SN.
Proof. {r | r s 2 SN for all s 2 N } ` {r | r x 2 SN} ` SN by the lemma. \Lambda 

By Cor. 3.50, each typable term is in SN. What remains to show that if t 2 SNthen t indeed admits no infinite reduction sequences.

3.6.3 Soundness of the Inductive Characterization
Classically, a term t is strongly normalizing if there are no infinite reductionsequences starting with t. Constructively, the set of strongly normalizing terms

sn is the accessible part of Tm w. r. t. the one-step reduction relation. Hence, itcan be defined as the smallest set

sn ` Tm closed under the rule

8t0 - t. t0 2 sn

t 2 sn

In this section, we show that SN ` sn.

82 CHAPTER 3. TYPE-BASED TERMINATION
Immediate closure properties of sn. By analyzing the possible reductions ofa term t depending on its shape, we immediately obtain the following closure
properties of sn:

c 2 sn x 2 sn

t 2 sn
*xt 2 sn

r, s 2 sn 8t oe r s. t 2 sn

r s 2 sn

Since E(x) is not a value, e(E(x)) is never a redex. Thus, the following twoclosure properties are a consequence of the closure property for application:

E(x) 2 sn s 2 sn

E(x) s 2 sn

E(x) 2 sn s, t1..n 2 sn

fixun s t1..n E(x) 2 sn

Similarly, fixrn ~t is not a redex if |~t| <= n + 1. Hence, we can add another closureproperty:

~t 2 sn
fixrn ~t 2 sn |~t| <= n + 1

Lemma 3.61 (Closure under subterm) The set of strongly normalizing terms isclosed under subterm formation.

1. If D :: *xt 2 sn then D0 :: t 2 sn.
2. If D :: r s 2 sn then D0 :: r 2 sn.
3. If D :: r s 2 sn then D0 :: s 2 sn.
In each case, #D0 <= #D.
Proof. Each by induction on D. \Lambda 

Corollary 3.62 If E(r) 2 sn then E(x), r 2 sn.
Lemma 3.63 (Closure under splitting) If D :: [s/x]t 2 sn then D0 :: t 2 sn and#D0 <= #D.

Proof. By induction on D. \Lambda 

Closure under strong head expansion. We define a relation t -!sn t0 by thesame rules as t -!

SN t0 except that we require s 2 sn instead of SN in the ruleSHRfi. Our goal is to show that sn is closed under -!sn-expansion.

Lemma 3.64 (Closure under strong head expansion axioms)

1. If s, [s/x]t 2 sn then (*xt) s 2 sn.
2. If s (fixun s) t1..n v 2 sn then fixun s t1..n v 2 sn.

3.6. STRONG NORMALIZATION 83

3. If E(s (fix*n s) t1..n) 2 sn then E(fix*n s t1..n) 2 sn.
Proof. 1. By Lemma 3.63 t 2 sn. We perform induction on s, t 2 sn and analyzethe possible reducts of (

*xt) s. 2. By induction on s, t1..n, v 2 sn. 3. By inductionon s, t

1..n, E(x) 2 sn. \Lambda 

Lemma 3.65 (sn closed under strong head expansion)

t0 -!sn t1 t1 2 sn

t0 2 sn

Proof. By induction on t0 -!sn t1. In case of SHR-fi, SHR-REC, or SHR-COREC,apply Lemma 3.64. In case e(t

0) -!sn e(t1), we have t0 2 sn by induc-tion hypothesis, since t
1 2 sn by Cor. 3.62. We proceed by side induction one(x), t
0 2 sn. Since e(t0) is not a redex, each reduction must be either in e(x) ort
0. By side induction hypothesis each reduction of e(t0) is in sn. \Lambda 

For each introduction rule of SN we have established a corresponding clo-sure property of

sn. Hence, proving SN ` sn amounts to a routine induction.

Lemma 3.66 (Inductive SN is sound)

1. If D :: t -!SN t0 then t -!sn t0.
2. If D :: t 2 SNe then t = E(x) 2 sn for some E and x.
3. If D :: t 2 SN then t 2 sn.
Proof. Simultaneously by induction on D. \Lambda 

Theorem 3.67 (Strong normalization) If \Gamma  ` t : A, then there are no infinitereduction sequences starting with t.
Proof. By Cor. 3.50 and the previous lemma, t 2 sn. By induction on t 2 sn wecan prove that t -!* t0 6-!, i. e., t reduces to a normal form in finitely many
steps. \Lambda 

84 CHAPTER 3. TYPE-BASED TERMINATION
Chapter 4
Embeddings into F!b
In this chapter, we consider type and reduction preserving embeddings ofsome total type systems into

F!b. Such embeddings provide a translation func-tion p*q for terms, types, and possibly kinds of the source language into the

target language F!b. An embedding is type preserving if for all \Gamma  ` t : A of thesource language, it holds that p

\Gamma  q ` ptq : pAq in the target language. Similarly,if a source reduction step t -! t0 maps to a sequence ptq -!+ pt0q of target

reduction steps, we speak of a reduction preserving embedding.For the purpose of embeddings, it is important that

F!b is strongly normaliz-ing. If
F!b was only normalizing w. r. t. a very specific reduction strategy, thenthe reductions of the source language would not likely map to

F!b reductionsthat are covered by the strategy. Therefore we have shown strong normalization of F!b, as opposed to showing just weak normalization.

4.1 An Iso-Recursive Version of F!b
In our presentation of F!b, we decided that inductive and coinductive typesshould be equi-recursive: By the rules

TY-FOLD and TY-UNFOLD, a fixed pointr 1 F is identical to its unfolded version F (r 1 F). Alternatively, we can

present the system iso-recursively: We drop the rules TY-FOLD and TY-UNFOLDand introduce two new term constructors:

Tm 3 r, s, t ::= * * * | in t | out t.
These two terms witness the isomorphism between the fixed point and its un-folded version. Hence, they are typed as follows:

TY-IN \Gamma  ` t : F (r^ a F) ~G\Gamma  ` in t : r

^ (a + 1) F ~G r 2 {

u, *}

TY-OUT \Gamma  ` t : r^ (a + 1) F ~G\Gamma  ` out t : F (r

^ a F) ~G r 2 {

u, *}

85

86 CHAPTER 4. EMBEDDINGS INTO F!b
We overline u and * to distinguish them from the inductive and coinductiveconstructors of the equi-recursive system. The contraction rules for recursive
and corecursive functions are replaced by the following ones, and we add areduction witnessing that (

in, out) is a retraction pair.

ISO-REC fixun s t1..n (in r) ae s (fixun s) t1..n (in r)
ISO-COREC out (fix*n s t1..n) ae out (s (fix*n s) t1..n)
ISO-fir out (in t) ae t

The corresponding reduction relation -! is confluent in a natural way, in con-trast to the equi-recursive system, where we had to introduce restrictions to
remove critical pairs (see Remark 3.9).

In previous work [Abe03, Abe04], we have considered such iso-recursivesystems. They seem to be easier to handle than their equi-recursive counterparts. The reduction rule ISO-REC for recursive functions is more concrete thanits counterpart

RED-REC in F!b. Here, recursive functions can be unfolded if ap-plied to a data constructor, in this case,

in. There, the argument can be any kindof value. Similarly, corecursive functions are only unfolded under a destructor,

out, whereas it can be any kind of evaluation context in F!b. Critical pairs like
fixu0 s (fix*0 s0) do not arise in the iso-recursive version.

Proofs of strong normalization using saturated sets are considerably sim-pler for iso-recursive systems than for their equi-recursive counterparts. This

is because the semantics of an iso-inductive type is quite concrete: it containsall terms which evaluate to a constructor expression (plus neutral terms). In
contrast, the semantics of an equi-inductive type is just its unfolding, we donot get an information on the shape of its inhabitants. We therefore require
in our soundness proof in Section 3.5 that all non-neutral terms in a semanti-cal type reduce to a value, which makes strong normalization harder to prove
than in the iso-recursive case. To handle equi-coinductive types we even hadto refine our notion of saturated set in Section 3.4.3, which is not necessary for
iso-coinductive types [AA00, Abe03]. In the following, however, we establishstrong normalization of the iso-recursive system effortlessly by embedding it
into the equi-recursive one.

Let 1 := 8A : *. A ! A and id := *xx : 1. We define a translation p_q, whichmaps terms of the iso-recursive system to terms of

F!b, constructors to construc-tors, and typing contexts to typing contexts. It is defined homomorphically for

all constructions except the following:

pr^q = *a*F. r^ a (*X*~G. 1 ! F X ~G)

where ^ = ~p~^ ! * and |~G| = |~^|

pin tq = *k. k ptq k 62 FV(t)p

out rq = prq id

4.2. SOME SYSTEMS FOR TERMINATION 87
The translation preserves well-typedness. Consider the derivation:

ptq : F (pr*q a F)
ptq : F (r* a (*X. 1 ! F X))
*k. k ptq : 1 ! F (r* a (*X. 1 ! F X))

*k. k ptq : r* (a + 1) (*X. 1 ! F X)

pin tq : pr*q (a + 1) F

This derivation can be lifted to r^ for higher kinds ^, and a similar deriva-tion can be constructed for p

out rq. Since all other constructions are translatedhomomorphically, the first part of the following theorem is a routine induction:

Theorem 4.1 (Typing and reduction are simulated)

1. If \Gamma  ` t : A in the iso-recursive system, then p\Gamma  q ` ptq : pAq in F!b.
2. If t -! t0 in the iso-recursive system, then ptq -!+ pt0q in F!b.
Simulation of reduction is easy as well. We have chosen the translation suchthat p

in tq is a non-recursive value and pout _q is a non-recursive evaluationframe. Hence,

fixu0 s pin tq -! s (fixu0 s) pin tq, andp

out (fix*0 s)q -! pout (s (fix*0 s))q,

which can be lifted to (co)recursive functions with more arguments. It is alsoclear that p

out (in t)q = (*k. k ptq) id -!+ ptq. It follows that strong normal-ization of the iso-recursive system is inherited from

F!b.

Remark 4.2 Embedding the equi-recursive into the iso-recursive seems muchharder, we need at least to translate the typing derivations. This suggests that
the equi-recursive is more foundational than the iso-recursive one and justifiesour choice of

F!b.

4.2 Some Systems for Termination
In the following, we discuss the embedding of several systems which can beseen as precursors to

F!b. Here, we concentrate on terminating systems withinductive types, and in the next section we switch to the dual case of productive

systems with coinductive types.

The calculus *b. The closest relative to F!b is definitively *b, a calculus intro-duced by Barthe, Frade, Gime'nez, Pinto, and Uustalu [BFG+04] and in depth
studied in Frade's Ph.D. thesis [Fra03]. It is a simply-typed *-calculus withsized iso-inductive types and a reduction rule for recursive functions which is

88 CHAPTER 4. EMBEDDINGS INTO F!b
similar to ISO-REC. It does not have first-class polymorphism (it features ML-polymorphism for types and sizes) nor inductive type constructors. The extension of admissible types we will consider in Chapter 5 is also not present intheir system. We claim here that

*b smoothly embeds into F!b which is strictlymore powerful. The only technical work involved to construct an embedding

is the translation of *b's Haskell-style inductive types into our equi-recursivetypes, but this is standard: use product and disjoint sum types.

My calculus \Lambda +u [Abe04]has simple iso-inductive types and their approxima-tions, which are an notational variant of sized types with the disadvantage that
they do not integrate well with polymorphism.1 Similar problematic formula-tions have been devised by Amadio and Coupet-Grimal [ACG98], Gime'nez
[Gim98], and Barras [Bar99]. The type syntax of *b and F!b, which resemblesHughes, Pareto, and Sabry's Synchronous Haskell [HPS96, Par00], is a clear improvement: it is both more intuitive and more powerful since it is orthogonal
to all other type constructions, like, for instance, polymorphism. \Lambda +u embedsinto

*b, and, even more directly, into F!b.

Some syntactic termination criteria. Gime'nez proposed a termination crite-rion on well-typed terms called guarded by destructors. Barthe et al. [BFG+04]
formalized it in the calculus *G , which embeds into *b, therefore also into F!b.In previous work [Abe00] I have described functional language

foetus with inductive types and nested recursion, which embeds into \Lambda +u . Note, however,that the termination checker

foetus that is described in [AA02] handles alsocases of mutual recursion that cannot be expressed by nested recursion, and,

thus, not be simulated in F!b.

4.3 Some Systems For Productivity
Barthe et al. [BFG+04] sketch an extension of *b by coinductive types. Theydo not extend the proofs of subject reduction and strong normalization, but
no complications are to be expected there, partly because they work with iso-coinductive types. (In the case of equi-coinductive types, the definition of saturated set needs to be refined, see Section 3.4.3.) The extension of *b by coin-duction also embeds into

F!b.

1\Lambda +u uses bounded quantification to model approximations of an inductive type, whereas F!b
uses size polymorphism. Consider the type of the list filter function:

F!b (A ! Bool) ! 8i. ListiA ! ListiA

\Lambda +u (A ! Bool) ! 8Y <=List A. Y ! Y

This worked ok, but the type of the map function (A ! B) ! ListiA ! ListiB cannot be expressed
in \Lambda +u .

4.4. ITERATION AND PRIMITIVE RECURSION 89
My calculus *fixu* [Abe03]is an extension of \Lambda +u [Abe04] by coinductive typesand continuity (which will be discussed in Chapter 5). It allows corecursive
functions to return pairs, which is not allowed in F!b. But taking away thisslightly buggy feature2,

*fixu* embeds into F!b.

The guard condition by Amadio and Coupet-Grimal [ACG98]. They presenta

*-calculus with coinductive types and nested corecursion, with a more re-strictive syntax than

*fixu*. Besides proving strong normalization with Girard'sreducibility method, they also give a PER model to reason about corecursive

programs. The version of their calculus with reduction rules embeds into *fixu*,therefore also into

F!b.

Syntactic guardedness. Coquand [Coq93] first described a syntactic criterionfor productivity: each recursive call must be guarded, i. e., occur under a constructor. This condition is easy to check, but quite restrictive; it rejects ad-vanced corecursion schemes, as, for instance, used for the Huffman decoder
in Section 3.2.4. Coquand's criterion is subsumed by Amadio and Coupet-Grimal's calculus.

4.4 Iteration and Primitive Recursion
There are a number of calculi without explicit recursion that are normalizingby virtue of typing: the simply-typed

*-calculus, the polymorphic *-calculus(System
F) and the higher-order polymorphic *-calculus (System F!), to namea few examples. In System

F, a limited form of recursion, so-called iteration,can be simulated, but not primitive recursion, a strengthening of iteration. This

negative result has been proven for the fi-version of System F by Splawski andUrzyczyn [SU99], for

fij it is conjectured. Primitive recursion can be simulatedin the presence of positive fixed-point types [Geu92]. The emphasis is on positive, as opposed to strictly positive. Since F!b has non-strictly positive least andgreatest fixed-point types, this simulation of primitive recursion can be carried
out in F!b, even without the use of fix.Using

fix, primitive recursion is even directly definable, which is not reallysurprising, considering the flexibility of the typing of

fix. For example, therecursor for lists can be programmed as follows:

primRec : 8A8B. B ! (A ! List1 A ! B ! B) ! List1 A ! B
primRec := *n*c. fixu0 *primRec*l. match l with

nil 7! n
cons a as 7! c a as (primRec as)

(Better known is the iterator for lists, called foldr in Haskell, which we getfrom the recursor if we omit the argument as :

List1 to c.)

2I later discovered that in *fixu* there are not enough reductions for corecursive functions
[Abe05].

90 CHAPTER 4. EMBEDDINGS INTO F!b

The type we have given to primRec above is its usual System F type. In F!b,we can give it a more precise type:

primRec : 8A 8B : ord +! *.(8i. B (i + 1)) !

(8i. A ! Listi A ! B i ! B (i + 1)) !8i.

Listi A ! B i

Mendler-style recursion. Mendler was the first to present formulations of(co)iteration [Men91] and primitive (co)recursion [Men87] that resemble generalized recursion, but are in their power limited through typing. His achieve-ments make him the "father" of type-based termination. The systems discussed in the last two sections are inspired by Mendler and tried to improve onhis work. Mendler proved strong normalization of his iteration and recursion
constructs by transfinite induction, similarly to how we motivate and verifyour recursion rule. The semantic model behind Mendler's recursion rule

MRec : (8X. (X ! u F) ! (X ! C) ! F X ! C) ! u F ! C
is very nicely summarized by Splawski and Urzyczyn [SU99]: the variableX stands for any approximation

uff F of the inductive type uF, and F X =F (
uff F) = uff+1F for the next approximation. If one defines a function

MRec (*emb*rec*t.s)
by Mendler recursion, then the function body s : C constructs a result fromargument t :

uff+1F where it may invoke recursion rec : uff F ! C on induc-tive data of the previous approximation stage. Additionally, it can convert this

piece of data into the full inductive type using emb : uff F ! u1F (this conver-sion option is absent in case of Mendler iteration).

Semantically, Mendler already used sized types, but he decided to concealthem using a type variable X. This way, he does not extend the type syntax
of polymorphic *-calculus, which makes his solution quite elegant.3 However,subsequent research seems to have been fixed to this type variable representation of approximations uff F of an inductive type. The resulting type systems byGime'nez [Gim98] and myself [Abe03, Abe04] were a bit clumsy. Introduction
of sizes into the type system, which was done by Hughes, Pareto, and Sabry[HPS96] in the functional programming community, cleaned up this messy
syntax: Barthe et al. [BFG+04] first realized that these sizes can be interpretedas ordinals, and

F!b features the quite intuitive syntax uiF.Mendler uses positive iso-inductive types with the constructor

in : F (uF) !
uF. His recursion scheme is directly definable in the iso-recursive version of

F!b:

MRec = *s. fixu0 *mrec*t. s id mrec (out t)

3The syntax seems to be a sacred cow in the logic, type theory, and programming language
community: Syntax extensions and changes might not be accepted by the fellow researchers. Onthe other hand, new and better notation is a catalyzer for new ideas, as the history of mathematics

shows.

4.4. ITERATION AND PRIMITIVE RECURSION 91
It was later observed by Matthes [Mat98] and Uustalu and Vene [UV99] thatMendler-style inductive types do not have to be positive, since there is no destructor out : uF ! F (uF). In the absence of a destructor, negative types donot jeopardize normalization since for them the recursion principle

MRec issimply useless. The non-positive version of Mendler inductive types cannot be

simulated directly, but via the usual encoding into positive fixed-point types[Geu92].

Iteration and primitive recursion for inductive constructors. For (co)induc-tive constructors of higher kind, Mendler (co)iteration and (co)recursion can be
defined analogously. This has been demonstrated in joint work with Matthesand Uustalu [AMU03, AMU05]. The encoding of

MRec given above can belifted to higher kinds and makes crucial use of inductive constructors of higher

kind, which are present in F!b but not in *b . For non-positive Mendler-styleconstructors, the recursion schemes can be encoded into positive fixed-point
constructors as shown in joint work with Matthes [AM04]. Conventional it-eration for inductive constructors [AM03] embeds into Mendler-style iteration
[AMU05]; but conventional primitive recursion for higher kinds has not yetbeen studied.

We have mainly considered the inductive case, but all embeddings dualizeto coinduction.

92 CHAPTER 4. EMBEDDINGS INTO F!b
Chapter 5
Continuity
In this chapter, we turn our attention to the question which types are admis-sible for (co)recursive functions. In sections 3.4.2 and 3.4.4 we have given semantical criteria. The syntactical criteria in Section 3.1 were quite crude ap-proximations, now we try to do better.

As described in the introduction, there are two criteria for admissible (se-mantical) types A :

ord ! *.

1. A(0) must be the biggest type, the universe of terms,
2. infff<* A(ff) ` A(*).

The first criterion is fulfilled by the general shape of the type: In case ofrecursion, A must be a function type with one domain which is an inductive
type, in case of corecursion, it must be an coinductive type or a function typewith a coinductive type as codomain. We will not try to relax the first criterion here, some directions of future work are hinted at in Section 7.2. Hughes,Pareto, and Sabry [HPS96] do have a wider criterion, but they only give a denotational semantics and do not have to deal with the extra complications wehave by allowing reduction in any order and under binders. Their criterion is
not sound in our reduction semantics.

The second criterion looks like a continuity property, if we write it as

infff<* A(ff) ` A(sup

ff<*

ff).

However, it talks about infimum and supremum instead of limits and it is aninequation instead of an equation. In previous work [Abe03] we characterized some types that fulfill this condition syntactically. In the following, wegeneralize this work to polymorphism and type constructors. At the end of
this chapter, we will have a syntactical derivation system for admissible typeswhich is much less restrictive than the original one in Section 3.1.

93

94 CHAPTER 5. CONTINUITY
Supremum on [[*]]. In Section 3.4 we introduced two flavors of saturated sets.The second version defined a saturated set as the orthogonal of a set of evaluation contexts, and we could not establish that the supremum of saturatedsets is identical to their union. However, for the development in this chapter,
especially the proof of the central lemma 5.8, we require that t 2 supi2I Ai im-plies t 2 A

i for some i. It could be that this property holds for saturated sets inthe refined sense, but we do not know. However, it holds for saturated sets in

the original sense, therefore, we revert to the original definition. The price wehave to pay is that coinductive constructors can no longer be treated in "equi"
style but we have to switch to "iso" style. The necessary changes to F!b and itssoundness proof are spelled out in Appendix B. In the following, we assume
that the supremum on [[*]] is the set-theoretical union.

5.1 On the Necessity of Criterion 2
In a previous article [Abe04, Sec. 6.1] we proved that the type-based termina-tion system indeed becomes unsound if we drop criterion 2: In the absence
of this criterion, one can construct a looping term. In the following, we willconvert this example to

F!b:

Assume sized type Nat with the two constructors zero : 8i. Nati+1 and succ :8
i. Nati ! Nati+1. For simplicity of presentation, we assume that we have asimple pattern-matching facility. We define the following functions:

shift : 8i. (Nat1 ! Nati+2) ! Nat1 ! Nati+1
shift := * f *n. match f (succ n) with

zero 7! zero
succ m 7! m

plus2 : Nat1 ! Nat1
plus2 := *n. succ (succ n)

It is easy to see that plus2 is a fixed point of shift:

shift plus2 : Nat1 ! Nat1
shift plus2 -!+ plus2

Disregarding Criterion 2, the following function is well-typed:

loop : 8i. Nati ! (Nat1 ! Nati+1) ! Nat1
loop := fixu0 *loop*_* f . match ( f zero) with

zero 7! zero
succ n 7! match n with

zero 7! zero
succ m 7! loop m (shift f )

To see well-typedness, here some help with the types of the bound variables

5.2. SEMI-CONTINUITY 95
and some subterms:

loop : Nati ! (Nat1 ! Nati+1) ! Nat1
_ : Nati+1

f : Nat1 ! Nati+2
n : Nati+1m :

Nati
shift f : Nat1 ! Nati+1

Now a certain function call loops:

loop zero plus2 -!+ loop zero (shift plus2) -!+ loop zero plus2.
It is also not the case that the occurrence of i + 1 in the type of loop is caus-ing the non-termination. We can modify the counterexample such that the

+1 disappears from the type of loop. To this end, introduce a free variableerr : 8A. A. If we modify the definition of

shift such that in the case zero the
variable err is returned, then shift can be given type 8i. (Nat1 ! Nati+1) !
Nat1 ! Nati. If we remove one pattern matching layer from loop it gets type8i.

Nati ! (Nat1 ! Nati) ! Nat1, and loop zero (*n. succ n) loops. Thus,

it is really the negative occurrence of the type Nat1 ! Nati[+1] that enables alooping term.

5.2 Semi-Continuity
When we define a (co-)recursive object t of type 8i : ord. A(i), we prove in the
semantics that t 2 A(ff) for all ordinals ff <= ?ord by transfinite induction on
ff. In the case of a limit ordinal *, we have t 2 Tff<* A(ff) = infff<* A(ff) andneed to show t 2 A(

*). Hence, A must be a function over ordinals with theproperty

inf* A ` A(*). (5.1)
We are looking for a syntactical characterization of types that fulfill (5.1). Forinstance, what is required of A and B such that C i = A i ! B i has this property? We would expect that B has to fulfill (5.1) and A some dual property.However, it is not that simple: To show inf

ff<*(A(ff) ! B(ff)) ` A(*) !B(
*) from inf* B ` B(*) requires that A(*) ` inf* A, which is not even ful-filled if A(

ff) denotes the natural numbers below ff. This means that not evenfor type
Nati ! Nati we can show property (5.1) directly.The next idea is to strengthen the requirement to lim

* A ` A(*) which byLemma 3.14 entails (5.1). Here we hit the problem that many function spaces

do not have limits. For example, let T (ff) = Nat(ff) ! Nat(ff) denote thefamily of endo-functions on natural numbers below

ff. Consider the functionf which increases even numbers by one, but leaves odd numbers unchanged.

This function inhabits T (ff) for infinitely many ff < ! (namely every second
ff), hence f 2 lim sup! T . But there is no ff0 < ! such that f 2 T (ff) for all

96 CHAPTER 5. CONTINUITY
ff between ff0 and !, hence, f 62 lim inf! T . Since limes superior and inferiordiffer, lim

! T does not exist.Although limits might not exist, it has been observed by Hughes, Pareto

and Sabry [HPS96] and the author [Abe03] that the modified requirement

lim inf* A ` A(*) (5.2)

can be lifted over function types:
Proposition 5.1 Let O be some initial segment of the ordinal numbers, * 2 O a limitordinal, and A, B 2

O ! SAT. If A(*) ` lim inf* A and lim inf* B ` B(*) thenlim inf

ff!* (A(ff) ! B(ff)) ` A(*) ! B(*).

This proposition is true, and the condition on A, A(*) ` lim inf* A, is exactlywhat we need. The condition on B is sufficient, but rather ad hoc, and we will

replace it by the stronger requirement

lim sup

* B ` B(

*) (5.3)

which is the dual to the requirement on A. The nature of his choice is nottechnical but aesthetical: symmetry. Further, now the requirements on A and

B correspond to already-known mathematical concepts:

Semi-continuity. Let (L, v, inf, sup) be a complete lattice, O some initial seg-ment of the ordinal numbers and

* 2 O a limit ordinal. A function A 2 O ! Lis called upper semi-continuous in
* if

lim sup

* A v A(

*). (5.4)

It is called lower semi-continuous in * if

A(*) v lim inf* A. (5.5)

The function A is upper/lower semi-continuous, if it is so in all limit ordinals * 2
O. A function is called !-overshooting by Hughes, Pareto, and Sabry [HPS96],if it is lower semi-continuous in

!.The term semi-continuity is justified by the following observation:

Lemma 5.2 If A is both upper and lower semi-continuous in *, then it is continuousin

*.

Proof. By assumption, lim sup* A v A(*) v lim inf* A. By Lemma 3.14, thelimes inferior is below the limes superior, hence both are equal and the limit

lim* A exists. Since A(*) is sandwiched between the limit on both sides, it isequal to the limit. Thus, A is continuous in

*. \Lambda 

5.3. TYPE CONSTRUCTORS AND SEMI-CONTINUITY 97
Remark 5.3 (Undershooting + overshooting 6= continuous) Property (5.2),lim inf

* A v A(*), which we have called paracontinuous in previous work[Abe03], and which would be called

*-undershooting following Hughes, Pareto,and Sabry [HPS96], is not strong enough to complement lower semi-continuity.

For instance, consider the function A 2 O ! L which maps all odd finite or-dinals to ? and all others to ?. It is both

!-under- and -overshooting, sincelim inf

! A = A(!) = ?, but not continuous in !, since lim sup! A = ?.

Set of semi-continuous functions. We denote the set of upper semi-continuous
functions from O to L by O \Phi ! L, and the set of lower semi-continuous functions by O \Psi ! L.

Lemma 5.4 (Variance and semi-continuity) (O +! L) ` (O \Phi ! L) and (O -!
L) ` (O \Psi ! L).

Example 5.5 (Ordinal successor) The ordinal successor is upper semi-continuous,since it is monotone, but not lower semi-continuous.

The concepts (5.4) and (5.5) are clearly subconcepts of continuity. Familiarsubconcepts are continuity from the left/right, but since we are considering functions over ordinals, every function is continuous from the right.1 But we couldask the following question: what makes a monotone function on ordinals continuous (from the left)? We find:

1. An antitone function is already continuous if it is upper semi-continuous.
2. An isotone function is already continuous if it is lower semi-continuous.
So we could say that an upper semi-continuous function is continuous whenfalling and a lower semi-continuous function is continuous when climbing.

5.3 Type Constructors and Semi-Continuity
In the following, we will analyze which type constructors preserve upper andlower semi-continuity. For the first kind, we need to push an upper limit under
the type constructor, for the second kind, we need to pull a limit out from theargument of a type constructor.

Preservation of upper semi-continuity. We say lim sup pushes through f 2
L ! L0 if for all g 2 O ! L and all * 2 O it holds that

lim sup

ff!* f (g(

ff)) v f (lim sup

ff!* g(

ff)).

1Minima always exists on the ordinals, hence, limits of falling sequences are all trivial, and since
the ordinals are wellfounded, there are no infinite strictly falling sequences.

98 CHAPTER 5. CONTINUITY
We also say that f is a lim sup-pushable function.

Most of our type constructors are covariant. This allows the following reasoning: If F 2 L +! L0 is lim sup-pushable and A 2 O ! L is upper semi-continuous, then

lim sup

ff!* F (A(

ff)) v F (lim sup

ff!* A(

ff)) v F (A(*)),

hence, F preserves upper semi-continuity.
Remark 5.6 (Covariance alone not sufficient) In general, covariance is not suf-ficient to preserve upper semi-continuity. Consider the function g : [0, 1] !

[0, 1] on the real or rational unit interval with g(x) = 1 - x. Then clearly g is(left) upper semi-continuous at 1, since g is even continuous. However, taking

f to be the sign function such that f (x) = 1 if x > 0 and f (0) = 0, we havelim sup

x!1 f (g(x)) = 1, but f (g(1)) = 0.

Preservation of lower semi-continuity. We say lim inf can be pulled throughf 2

L ! L0 if for all g 2 O ! L and all * 2 O it holds that

f (lim infff!* g(ff)) v lim infff!* f (g(ff)).

We also say that f is a lim inf-pullable function.

If F 2 L +! L0 is lim inf-pullable and A 2 O ! L is lower semi-continuous,then

F (A(*)) v F (lim infff!* A(ff)) v lim infff!* F (A(ff)),
thus, F preserves lower semi-continuity.

Contravariant constructors. If F is contravariant and a lim sup can be pushedinto F , becoming a lim inf, then F turns lower semi-continuous functions into
upper semi-continuous ones. If a lim sup can be pulled out from F as a lim inf,then F maps a upper semi-continuous function to an lower semi-continuous
one.

Lemma 5.7 Let f 2 O * O ! L and * 2 O proper limit. Then

lim sup

ff!* f (

ff, ff) v lim sup

fi!* lim supfl!* f (

fi, fl)

lim inffi!* lim inffl!* f (fi, fl) v lim infff!* f (ff, ff)

5.3. TYPE CONSTRUCTORS AND SEMI-CONTINUITY 99
Proof. Let all ordinals range below *.

sup
ff>=ff0 f (

ff, ff) v sup

fi>=ff0 supfl>=ff0 f (

fi, fl) for all ff0

= inffi

0<=ff0 inffl0<=ff0 supfi>=fi0 supfl>=fl0 f (fi, fl)

infff

0 supff>=ff0 f (ff, ff) v infff0 inffi0<=ff0 inffl0<=ff0 supfi>=fi0 supfl>=fl0 f (fi, fl) taking inf on both sides

= inffi

0 inffl0 supfi>=fi0 supfl>=fl0 f (fi, fl)

= inffi

0 supfi>=fi0 inffl0 supfl>=fl0 f (fi, fl)

This means that lim supff!* f (ff, ff) v lim supfi!* lim supfl!* f (fi, fl). Thesecond claim follows by dualization. \Lambda 

5.3.1 Function Space
In this section, we show that function spaces can be upper semi-continuous,but not lower semi-continuous.2

Lemma 5.8 (Pushing lim sup through function space) Let A, B 2 O ! P (Tm)and

* 2 O a limit ordinal. Then

lim sup

ff!* (A(

ff) ! B(ff)) ` (lim inf* A) ! lim sup

* B.

Proof. We assume a function term r 2 lim supff!* (A(ff) ! B(ff)) and anargument term s 2 sup

ff0<* infff0<=ff<=* A(ff) and show that the application r s 2inf
fi0<* supfi0<=fi<* B(fi). In the following, let all ordinals range below *. Wefix an arbitrary ordinal

fi0. We know that there exists some ff0 such that s 2A(
ff) for all ff >= ff0. Furthermore, r 2 A(fi) ! B(fi) for some ordinal fi >max(

ff0, fi0). Since s 2 A(fi), we conclude r s 2 B(fi). \Lambda 

Corollary 5.9 Let A 2 O \Psi ! P (Tm), B 2 O \Phi ! P (Tm) and F (ff) := A(ff) !B

(ff). Then F 2 O \Phi ! P (Tm).

Proof. Fix some limit ordinal * 2 O. Since A(*) ` lim inf* A and lim sup* B `B(

*), the desired inequation

lim sup

ff!* (A(

ff) ! B(ff)) ` A(*) ! B(*)

2An exception could be functions over finite domains, which are lower semi-continuous in
their codomain. But we do not distinguish between finite and infinite here, this would require asyntactical calculus of finiteness later.

100 CHAPTER 5. CONTINUITY
follows from the previous lemma, since the function space is contravariant onthe domain and covariant on the codomain. \Lambda 

The converse lemma to derive that A(ff) ! B(ff) is lower semi-continuousdoes not hold. For instance F (

ff) := Nat! ! Natff is not lower semi-continuous,although Nat
ff is: the identity function is in F (!), but not in F (ff) for any

ff < !.

Remark 5.10 (Cannot pull lim inf out of function space) We show that not gen-erally (lim sup

ff A(ff)) ! B ` lim infff(A(ff) ! B). Clearly, the bigger(lim inf
ff A(ff)) ! B is then also not below lim infff(A(ff) ! B) in general.Take A(n) = Natn ! Nat and B = Nat. First, we show

* f . f ( f 0) 2 (lim supn (Natn ! Nat)) ! Nat.
We assume that for all n0 there is some n >= n0 such that f 2 Natn ! Nat andshow f ( f 0) 2 Nat. Since 0 2 Nat1 we have f 2 Natn ! Nat for some n >= 1
and therefore f 0 2 Nat. Since Nat = Sn0 Natn0, there must be a n0 such thatf 0 2 Natn

0 . Thus, f ( f 0) 2 Nat for some n >= n0. Now, we prove

* f . f ( f 0) 62 lim infn ((Natn ! Nat) ! Nat).
We show even that * f . f ( f 0) is in none of the sets (Natn ! Nat) ! Nat.Assume an arbitrary n

< !. Let f be the function which returns n for inputsless than n and diverges for all input greater or equal than n. Then f 2 Natn !

Nat. But since f 0 evaluates to n, f ( f 0) diverges and, hence, cannot be in Nat.

5.3.2 Universal Quantification
Universal quantification is semantically interpreted by intersection. We canonly show that quantification preserves upper semi-continuity.

Lemma 5.11 (Pushing lim sup through infimum) Let I some index set, f 2 O *I !

L, and * 2 O some limit ordinal. Then

lim sup

ff!* infi2I f (

ff, i) v infi2I lim sup

ff!* f (

ff, i).

Proof. For all i 2 I it holds that infi2I f (ff, i) v f (ff, i). Since inequation is pre-served under limit formation, lim sup

ff!* infi2I f (ff, i) v lim supff!* f (ff, i)for all i 2 I, which entails our claim. \Lambda 

Corollary 5.12 The space of upper semi-continuous functions O \Phi ! L forms a com-plete lattice under pointwise ordering, pointwise infimum, and pointwise maximal
element.

5.3. TYPE CONSTRUCTORS AND SEMI-CONTINUITY 101
Proof. To see that O \Phi ! L is closed under pointwise infimum, assume a familyF

i 2 O ! L (for i 2 I) with lim supff!* Fi(ff) v Fi(*) for all i 2 I. Minimiz-ing both sides, we obtain

lim sup

ff!* (infi2I Fi)(

ff) v infi2I (lim sup

ff!* Fi(

ff)) v (infi2I Fi)(*)

by pulling the upper limit out to the left (previous lemma). \Lambda 

Example 5.13 (Supremum on O \Phi ! L not pointwise) The supremum of the lat-tice, sup

i2I Fi = inf {F | F w Fi for all i 2 I}, however, is not the pointwiseone. For example, take the two element lattice ? v ? and the family

Ai : [0; !] ! {?, ?} for 0 <= i < !,A

i(ff) := ? if i < ff,A
i(ff) := ? else.

Then Ai(!) = ? w Ai(ff) for all ff >= i, hence each Ai is upper semi-continuousin

!. However, the pointwise supremum A(ff) := supi<! Ai(ff) takes thevalue ? below

!, hence lim sup! A = ? 6v A(!) = ?.

On the contrary, lower semi-continuous functions are not closed under point-wise infimum. This becomes clear if we consider the same example on the dual

lattice, i. e., we swap inf and sup, and v and w (which means that ? becomesthe maximal element and ? the minimal). With the same trick, we harvest a
relationship between supremum and limes inferior:
Lemma 5.14 (Pulling lim inf out of a supremum) Let I some index set, f 2 O *I !

L, and * 2 O some limit ordinal. Then

sup

i2I lim infff!* f (

ff, i) v lim infff!* sup

i2I f (

ff, i).

We could now turn O \Psi ! L into a complete lattice using the pointwise supre-mum. But we withstand this temptation since this would trick us into believing
we could interpret universal quantification on this lattice.
Remark 5.15 One would think that, if Ai is lower semi-continuous, then also8X. Ai. But it is not true in our semantics. It is not clear whether it holds in
another semantics, e. g., one with parametricity.

5.3.3 Coinductive Types
Clearly, coinductive types are not lower semi-continuous in general. For ex-ample, consider the stream of subsequent natural numbers 0, 1, . . . which is an

102 CHAPTER 5. CONTINUITY
element of Stream!(Nat!). Since for all ff < !, this stream is not contained in
Stream!(Natff), the latter type family cannot be lower semi-continuous in !.

However, coinductive types map upper semi-continuous types to uppersemi-continuous types under some conditions. We introduce a new symbol for

antitone iteration, which is used to construct the semantics of coinductive types:

* 2 O -! (L +! L) +! L
*ff(F ) = Fff(?)

By Lemma 3.21, * is antitone in its first argument, hence by Lemma 3.17 wecan replace the limit by an infimum at limit iterates:

** = infff<* *ff. This willenable us to reason about semi-continuity.

Lemma 5.16 Let OE 2 O ! O and I ` O. Then

1. supff2I *OE(ff) v *infI OE,

2. supff2I *OE(ff) w *infI OE,
3. infff2I *OE(ff) w *supI OE, and
4. infff2I *OE(ff) v *supI OE.
Proof. 1. and 3. follow directly from antitonicity. For 2., remember that each setof ordinals is left-closed, hence inf

I OE = OE(ff) for some ff 2 I. The remainingproposition 4. is proven by cases on sup

I OE. If supI OE is not a limit ordinalthen sup
I OE = OE(ff) for some ff 2 I. For this ff, clearly *OE(ff) v *supI OE, whichentails the lemma. Otherwise, if sup

I OE is a limit ordinal, then by definition of
* at limits we have to show infff2I *OE(ff) v *fi for all fi < supI OE. By definition

of the supremum, fi < OE(ff) for some ff. Since * is antitone, *OE(ff) v *fi fromwhich we infer our subgoal by forming the infimum on the left hand side. \Lambda 

Hence, we can push a supremum as an infimum under antitone iteration, andvice versa.
Corollary 5.17 lim supff<* *OE(ff) = *lim infff<* OE(ff).
Lemma 5.18 (Coinductive types are lim sup-pushable) Let (Fff)ff2O be a fam-ily of lim sup-pushable isotone endo-functions on a complete lattice

L with pointwiseinfimum and supremum. Then

lim sup

ff!*

*fiFff v *fi lim sup

ff!* F

ff.

5.3. TYPE CONSTRUCTORS AND SEMI-CONTINUITY 103
Proof. By induction on fi. In case fi = 0, both sides become the maximumelement of

L. In the successor case we have

lim supff!* *fi+1Fff = lim supff!* Fff(*fiFff)v

lim supff!* lim supfl!* Fff(*fiFfl) Lemma 5.7v
lim supff!* Fff(lim supfl!* *fiFfl) Fff pushablev
lim supff!* Fff(*fi(lim supfl!* Ffl)) Fff isotone, i.h.
= (lim supff!* Fff)(*fi(lim supff!* Fff)) inf, sup pointwise=

*fi+1(lim supff!* Fff).

Note that in the last step we used that lim sup is defined pointwise on func-tions. In the remaining case

fi = * we exploit that lim sup pushes throughinfima (Lemma 5.11). \Lambda 

Corollary 5.19 Under the assumptions of the last lemma.

lim sup

ff!*

*OE(ff)Fff v *lim inf* OE lim sup

ff!* F

ff,

Proof. We combine Cor. 5.17 and Lemma 5.18.

lim supff!* *OE(ff)Fff v lim supff!* lim supfl!* *OE(ff)Ffl Lemma 5.7v

lim supff!* *OE(ff)(lim supfl!* Ffl) Lemma 5.18v
*lim infff!* OE(ff) lim supff!* Fff Cor. 5.17 \Lambda 

Corollary 5.20 (Coinductive types preserve upper semi-continuity) For ff 2 O,
let Fff 2 L +! L be lim sup-pushable. The family Fff be upper semi-continuous.Then

lim sup

ff!*

*OE(ff)Fff v *lim inf* OEF*.

Proof. By the last corollary and upper semi-continuity of Fff. \Lambda 

5.3.4 Inductive Types
The result of the last section can be dualized to inductive types. We defineisotone iteration,

uffF = Fff(?).

Lemma 5.21 Let OE 2 O ! O and I ` O. Then usupI OE = supff2I uOE(ff) and
uinfI OE = infff2I uOE(ff).

Corollary 5.22 ulim inf* OE = lim infff!* uOE(ff).

104 CHAPTER 5. CONTINUITY
Lemma 5.23 (Inductive types are lim inf-pullable) For ff 2 O, let Fff 2 L +! Lbe lim inf-pullable. Then isotone iteration

ufiFff is lim inf-pullable, i. e.,

ufi lim infff!* Fff v lim infff!* ufiFff.

Corollary 5.24 Let OE be a lower semi-continuous function on ordinals. In the contextof the lemma,

uOE(*) lim infff!* Fff v lim infff!* uOE(ff)Fff.

Corollary 5.25 (Inductive types preserve lower semi-continuity) Under the assumptions of the last corollary isotone iteration uOE(ff)Fff is lower semi-continuous,i. e.,

uOE(*)F* v lim infff!* uOE(ff)Fff,
if the family Fff is lower semi-continuous.

Since isotone types are upper semi-continuous, many inductive types aretrivially upper semi-continuous. First, every type

uffF where F does not de-pend on
ff, but also, for example Listff(Natff) and Treeff(Nat, Natff).
But there are other types which are upper semi-continuous as well, for in-stance List

ff(Streamff(Nat)). This type is acceptable since it's generator Fff(X ) =U

nit + Streamff(Nat) * X is infimum continuous3, which means that

Fff(X ) " Ffi(Y ) ` Unit + (Streamff(Nat) " Streamfi(Nat)) * (X " Y ).
Pareto calls such generators lenient [Par00, p. 122], recasting the conditions asF

ff(X ) " Ffi(Y ) ` Fff(X " Y ). Since Pareto's type generators are infimumcontinuous by definition ([HPS96, Restriction 3.2]), they are also lenient, hence,

each inductive type is upper semi-continuous.

On the contrary, our type iterators are not lenient. This is because we allowfunction spaces in data types. Consider F

i(X ) = Nati ! X which constructsNati-hungry functions. Then the identity function is in F

j+1(Natj+1) and inF

j(Natj), but not in Fj+1(Natj+1 " Natj) = Natj+1 ! Natj.If all inductive types would preserve upper semi-continuity, we would have

the chain

lim sup

i!!

ufiFi ` ufi lim sup

i!! Fi `

ufiF! (5.6)

for a isotone, upper semi-continuous type constructor which is lim sup-pushable.In the following, we will construct a counterexample to our hypothesis.

3A function f is infimum continuous if infi2I f (xi) = f (infi2I xi) for all sequences (xi)i2I.
An infimum continuous function is isotone. An isotone function is infimum continuous ifinf

i2I f (xi) <= f (infi2I xi). This last condition is what I called "continuous" in earlier work [Abe03].

5.3. TYPE CONSTRUCTORS AND SEMI-CONTINUITY 105
An inductive type which is not upper semi-continuous. A minor variant ofthe last example, F

i(X ) = 1 + (Nati ! X ) constructs the family of treeswhich have at least i "good" branches at each node. First, we observe that,

using upper semi-continuity of sums and function space,

lim supi!! Fi(Xi) ` 1 + (lim supi!!(Nati ! Xi))`

1 + ((lim infi!! Nati) ! (lim supi!! Xi))= 1 + (Nat

! ! (lim supi!! Xi))

= F!(lim supi!! Xi).

Hence, the functor family F is lim sup-pushable, but, as we will show, isotoneiteration of F is upper semi-continuous.

The !th iteration u!Fi contains the i-branching trees of finite height. Lett
i be a !-branching tree of height i for all i < !. Consider the tree t(n) = tn,whose root has infinitely many branches, containing the t

i in order. The first 0branches are good and of height < 0 (empty quantification), the first 1 branches

are good and of height < 1, the first 2 branches are good and of height < 2 etc.This implies that

t 2 infi<

! supj<! u

jFi = lim sup

i!!

u!Fi. (5.7)

But it is not true that t is an infinitely branching tree of finite height, i. e.,

t 62 sup

j<!

u jF! = u!F!. (5.8)

This invalidates the inequation 5.6 for ordinal fi = !; inductive types do notgenerally preserve upper semi-continuity.

Could we nevertheless accept all inductive types as result types of recursivefunctions without jeopardizing termination? After all, our semantics might be
defective, ruling out a class of functions for internal reasons? The answer isno. In the following, we show how to construct a looping term if the inductive
type of Nat-hungry functions Hungryi(Nati) = ui X. Nati ! X is accepted asresult of a recursive function.

Constructing a looping term. We assume that the natural numbers are con-structed by the two closed normal forms

zero and succ and that there is a elim-ination
caseNat. We postulate the following typings and reductions.

zero : 8i. Nati+1
succ : 8i. Nati ! Nati+1

caseNat : 8X8i. X ! (Nati ! X) ! Nati+1 ! X
caseNat z s zero -!+ z
caseNat z s (succ n) -!+ s n

Since zero and succ are closed and normal, they must be weak-head values,hence, trigger unfolding of recursive functions. We can define a predecessor

106 CHAPTER 5. CONTINUITY
function on positive numbers as follows:

err : 8X.X
pred : 8i. Nati+1 ! Nati
pred := caseNat err id

Herein, we had to assume a variable err which inhabits every type. Note that
there cannot be a closed term pred of type 8i. Nati+1 ! Nati, since then pred zerowould be a closed normal form in the type 8i.

Nati whose semantics Nat0 con-tains only neutral, i. e., open normal forms. The assumption of variable err

is unproblematic, since we are refuting strong normalization in this example,and strong normalization treats also reduction of open terms. It is clear that
pred (succ t) -!+ t, hence by induction on n, also

predn (succn t) -!+ t
for any term t.Next, we define a function which transforms a

Natj-hungry function into
a Natj+1-hungry function. In the visualization of A-hungry functions as A-branching trees, this means that we insert a left-most branch at each node.

s : 8j8i. Hungryi(Natj) ! Hungryi(Natj+1)
s := fixu0 *s*h. s ffi h ffi pred

sn v -!+ sn ffi v ffi predn

At this, point we can construct a hungry function h recursively, if we disregardthat

Hungryi(Nati) does not denote a upper semi-continuous function. Since the typeof hungry functions does not contain values semantically, this is clearly pathological already. Later we will exploit h to construct a non-normalizing term.

h : 8i. Nati ! Hungryi(Nati)
h := fixu0 *h*_. s ffi h ffi pred

h v -!+ s ffi h ffi pred

To implement a diverging term, we need the inverse p of s. Intuitively, it cutsthe left-most branch of each node.

p : 8j8i. Hungryi(Natj+1) ! Hungryi(Natj)
p := fixu0 *p*h. p ffi h ffi succ

pn v -!+ pn ffi v ffi succn

Finally, we define a "traversal" function tr which diverges on h v.

tr : Hungry1(Nat1) ! 0
tr := fixu0 *tr*h. tr ((p ffi h ffi succ) zero)

tr v -!+ tr ((p ffi v ffi succ) zero)

5.4. A KINDING SYSTEM FOR SEMI-CONTINUITY 107
Now, we construct the following reduction sequence for any n 2 N.

tr (pn (sn (h zero))) -!+ tr (pn (sn (s ffi h ffi pred)))-!*

tr (pn (sn+1 ffi h ffi predn+1))-!*
tr (pn ffi sn+1 ffi h ffi predn+1 ffi succn)-!+
tr ((pn+1 ffi sn+1 ffi h ffi predn+1 ffi succn+1) zero)-!+
tr (pn+1 (sn+1 (h zero)))

It is clear that tr (h zero) diverges.

5.3.5 Product and Sum Types
Product and sum type are both upper and lower semi-continuous. This hasbeen shown by Pareto [Par00] for a denotational semantics, and by myself

[Abe03] for a SN semantics for a type system with iso-(co)inductive types.However, I do not know whether this can be shown for the impredicative encodings of sum and product from Example 3.3. In the following, we assumewe have the continuity property for sum and product. This might require to
add them as primitive notions to F!b.
Lemma 5.26 Let A, B 2 O ! P (Tm). Then for all limit ordinals * 2 O,

(a) lim supff!*(A(ff) * B(ff)) ` (lim sup* A) * (lim sup* B),
(b) lim supff!*(A(ff) + B(ff)) ` (lim sup* A) + (lim sup* B),
(c) (lim inf* A) * (lim inf* B) ` lim infff!*(A(ff) * B(ff)), and
(d) (lim inf* A) + (lim inf* B) ` lim infff!*(A(ff) + B(ff)).

Corollary 5.27 (Product and sum preserve semi-continuity) Let q 2 {\Phi , \Psi } andA

, B 2 O q! P (Tm). Then (ff 7! A(ff) + B(ff)), (ff 7! A(ff) * B(ff)) 2 O q!P (

Tm).

5.4 A Kinding System for Semi-Continuity
In this section we define a calculus to derive semi-continuous constructors.This calculus will be part of the new criterion for admissible types for (co)recursion.

Polarities for semi-continuous functions. Similar to the polarities +, -, andffi for co-, contra-, and non-variant constructors we introduce two new polarities for semi-continuous constructors:

HPol 3 q ::= \Phi  upper semi-continuity| \Psi  lower semi-continuity

108 CHAPTER 5. CONTINUITY
Positive contexts. We define contexts \Pi  2 Cxt+ ` PCxt in which each vari-able has positive polarity and each kind is pure:

Cxt+ 3 \Pi  ::= \Pi  empty context|

\Pi , X : +^* positive constructor variable

Well-formed size expressions. The judgement \Delta  ` a ord singles out well-formed

*-free constructors of kind ord. With this separate judgement, it is veryeasy to show that every well-formed a is either an affine function in one size

variable, or equal to ?ord.

ORD-1 \Delta  ` 1 ord ORD-VAR (i : pord) 2 \Delta  p <= +\Delta  ` i ord ORD-s \Delta  ` a ord\Delta  ` s a ord

Derivation system for kinds and semi-continuity. Let \Delta  be a polarized context with (i : pord) 2 \Delta  for some p. We define the judgement \Delta ; ~X : +~^* `iq F : ^
inductively by the following rules. Variables ~X can only appear strictly positivein F, and they are disjoint from the variables in

\Delta . The intended semantics ofthe judgement depends on q: If q = \Phi  then F is a well-kinded, upper semicontinuous constructor in ordinal variable i, and a lim sup can be pushed into
its arguments ~X. If q = \Psi  then F is lower semi-continuous and a lim inf can be
pulled out from its arguments ~X.The first three rules enable us to derive semi-continuity from an ordinary

kinding judgement \Delta  ` F : ^.

CONT-IN \Delta  ` F : ^\Delta , i : pord; \Pi  `iq F : ^

CONT-CO \Delta , i : +ord ` F : ^ p <= +\Delta , i : pord; \Pi  `i\Phi  F : ^
CONT-CONTRA \Delta , i : -ord ` F : ^ p <= -\Delta , i : pord; \Pi  `i\Psi  F : ^
These rules are justified by the fact that each invariant function is continuous,each covariant function is upper semi-continuous and each contravariant function is lower semi-continuous. The next rules are for the pure *-calculus partof the constructor grammar.

CONT-VAR X : p^ 2 \Delta , \Pi  p <= +\Delta ; \Pi  `iq X : ^
CONT-ABS \Delta , X : p^; \Pi  `

iq F : ^0

\Delta ; \Pi  `iq *XF : p^ ! ^0 X 6= i

CONT-APP \Delta , i : p0ord; \Pi  `

iq F : p^ ! ^0 p-1\Delta  ` G : ^

\Delta , i : p0ord; \Pi  `iq F G : ^0

5.4. A KINDING SYSTEM FOR SEMI-CONTINUITY 109
Note that in the application rule, we require the argument G to be constantin i. The background is that the composition of F and G has trivially all the
continuity and variance properties of F if G is constant. Of course, with thisrule we could never derive, e. g., that A ! B is upper semi-continuous in i if

B is upper semi-continuous and A is lower semi-continuous. Hence, we needspecialized rules for the constants, which implement the observations from the
last section.

CONT-SUM \Delta ; \Pi  `

iq A, B : *

\Delta ; \Pi  `iq A + B : * CONT-PROD

\Delta ; \Pi  `iq A, B : *
\Delta ; \Pi  `iq A * B : *

CONT-ARR -\Delta ; \Pi  `

i\Psi  A : * \Delta ; \Pi  `i\Phi  B : *

\Delta ; \Pi  `i\Phi  A ! B : *

CONT-8 \Delta ; \Pi  `

i\Phi  F : ffi^ ! *

\Delta ; \Pi  `i\Phi  8^ F : *

CONT-MU \Delta ; \Pi , X : +^* `

i\Psi  F : ^* \Delta  `i\Psi  a : ord

\Delta ; \Pi  `i\Psi  uaXF : ^*

CONT-NU \Delta ; \Pi , X : +^* `

i\Phi  F : ^* \Delta  ` a ord

\Delta ; \Pi  `i\Phi  *aXF : ^*

We abbreviate \Delta ; \Pi  `iq F : ^ by \Delta  `iq F : ^.

Example 5.28 (Type of minimum function) Recall that Nati = uiX. 1 + X. First,we derive that

Nat is lower semi-continuous:

CONT-VARi : ffiord; X : +* `i\Psi  X : *

CONT-SUMi : ffiord; X : +* `i\Psi  1 + X : * CONT-VARi : ffiord `i\Psi  i : ord

CONT-MUi : ffiord; \Pi  `i\Psi  Nati : *

Since Nat : ord +! * is also upper semi-continuous, we can derive that the typeof the minimum and maximum functions is upper semi-continuous. We omit

: * and empty positive contexts \Pi  in the derivation:

i : ffiord `i\Psi  Nati

i : ffiord `i\Psi  Nati

i : +ord ` Nati CONT-CO
i : ffiord `i\Phi  Nati CONT-ARR
i : ffiord `i\Phi  Nati ! Nati CONT-ARR
i : ffiord `i\Phi  Nati ! Nati ! Nati

Example 5.29 (Stream of natural numbers) Let Streami A = *iX. A * X, as de110 CHAPTER 5. CONTINUITY
fined in Example 2.9. The type Streami Nati is upper semi-continuous.

i : +ord ` Nati CONT-CO
i : ffiord; X : +* `i\Phi  Nati CONT-VARi : ffiord; X : +* `i\Phi  X CONT-PROD

i : ffiord; X : +* `i\Phi  Nati * X CONT-NU

i : ffiord `i\Phi  Streami Nati
Example 5.30 (Finitely branching trees) Node-labeled forests of height < i withless than

j branches can be implemented as uiX. Listj (A * X). If we let the twoindices coincide, we obtain

uiX. Listi (A * X), which is upper semi-continuous(since isotone), but also lower semi-continuous. This is an example with two

strictly positive variables:

CONT-VAR. . . X, Y : +* `i\Psi  X

CONT-PROD. . . X, Y : +* `i\Psi  (A * X) CONT-VAR. . . X, Y : +* `i\Psi  Y

CONT-PROD. . . X, Y : +* `i\Psi  (A * X) * Y
CONT-SUMi : +ord; X, Y : +* `i\Psi  1 + (A * X) * Y
CONT-MUi : +ord; X : +* `i\Psi  Listi (A * X)
CONT-MUi : +ord; \Pi  `i\Psi  uiX. Listi (A * X)

Lemma 5.31 (Soundness of judgement for size expressions) If D :: \Delta  ` a ordthen

\Delta  ` a : ord.

Proof. By induction on D. \Lambda 

Theorem 5.32 (Erasure of continuity) If D :: \Delta ; \Pi  `iq F : ^ then \Delta , \Pi  ` F : ^.
Proof. By induction on D. \Lambda 

A consequence of the erasure theorem is that all derivations of semi-continuousconstructors produce only well-kinded constructors.

5.5 Semantical Soundness of Continuity Derivations
In the following, we will show that all types that are kindable by the calculusof the last section indeed have the postulated semi-continuity properties. We
will make use of all the semantical propositions proven in Section 5.3.
Lemma 5.33 If D :: \Delta  ` a ord, then for all ` 2 [[\Delta ]] and ordinal variables i,

OE := (ff 7! [[a]]`[i7!ff]) 2 [[ord]] ! [[ord]]

is either the constant function OE(ff) = ?ord or a function of the shape OE(ff) =min{

ff + n, ?ord} for some natural number n.

5.5. SEMANTICAL SOUNDNESS OF CONTINUITY DERIVATIONS 111
Proof. By induction on D. \Lambda 

Theorem 5.34 (Semantical soundness) Let ` 2 [[\Delta , \Pi ]], (X : +^0) 2 \Pi , G 2[[

ord]] ! [[^0]], and * 2 [[ord]] a limit ordinal.

1. If D :: \Delta ; \Pi  `i\Phi  F : ^ then

(a) lim supff!*[[F]]`[i7!ff] v^ [[F]]`[i7!*], and
(b) lim supff!*[[F]]`[X7!G(ff)] v^ [[F]]`[X7!lim sup* G].

2. If D :: \Delta ; \Pi  `i\Psi  F : ^ then

(a) [[F]]`[i7!*] v^ lim infff!*[[F]]`[i7!ff], and
(b) [[F]]`[X7!lim inf* G] v^ lim infff!*[[F]]`[X7!G(ff)].

Proof. By induction on D.

Case CONT-IN. A constant function is trivially continuous.
Case CONT-CO. Isotone functions are upper semi-continuous (Lemma 5.4).
Case CONT-CONTRA. Analogously.
Case CONT-VAR. By assumption.
Case CONT-ABS. \Delta , X : p^; \Pi  `iq F : ^0

\Delta ; \Pi  `iq *XF : p^ ! ^0 X 6= i
For subcase q = \Phi , we need to show that (a),

lim sup

ff!* ([[

*XF]]`[i7!ff]) vp^!^0 [[*XF]]`[i7!*].

It is sufficient that for all G 2 [[^]],

(lim supff!*[[*XF]]`[i7!ff]) G = lim supff!*([[*XF]]`[i7!ff] G)

= lim supff!*([[F]]`[i7!ff][X7!G])
= lim supff!*([[F]]`[X7!G][i7!ff])v

^0 [[F]]`[X7!G][i7!*]

= [[*XF]]`[i7!*] G,

which follows by induction hypothesis. Goal (b) follows similarly, andcase q = \Psi  analogously. We have used that infimum and supremum
are defined pointwise on lattices [[^]], if ^ is an ordinary polarized kindwithout continuity restrictions (Lemma 2.16).4

4On lattices with continuity, e. g., O \Phi ! L, the supremum might not be the pointwise one (Example 5.13!).

112 CHAPTER 5. CONTINUITY

Case CONT-APP. Similarly, by pointwise infimum and supremum.
Case CONT-SUM and CONT-PROD. By Cor. 5.27.
Case CONT-ARR. By Cor. 5.9.
Case CONT-8. By Cor. 5.12.
Case CONT-MU.

\Delta ; \Pi , X : +^* `i\Psi  F : ^* \Delta  `i\Psi  a : ord

\Delta ; \Pi  `i\Psi  uaXF : ^*

By induction hypothesis, OE := ff 7! [[a]]`[i7!ff] is a lower semi-continuous
function on ordinals. Let Fff(H) = [[F]]`[X7!H][i7!ff]. By induction hypothesis we have for all limits * 2 [[ord]], H 2 [[^*]], fi 2 [[ord]], G 2 [[ord]] ![[

^*]] that

(a) [[F]]`[X7!H][i7!*] = F*(H) v lim infff!* Fff(H),
(b) [[F]]`[X7!lim inf* G][i7!fi] = Ffi(lim inf* G) v lim infff!* Ffi(G(ff)),

thus, F is both lower semi-continuous and lim inf-pullable. Goal (a),

uOE(*)F* v lim infff!* uOE(ff)Fff

follows by Cor 5.25.
To show (b) for some variable (Y : +^0) 2 \Pi , let fi = [[a]]` and F (G)(H) =[[F]]

`[Y7!G][X7!H]. Then [[uaXF]]`[Y7!G] = ufiF (G). By induction hypothe-sis (b), for all G0 2 [[

^0]], H 2 [[^*]], G 2 ord ! [[^0]], and * limit

(b.1) F (G0)(lim inf* H) v lim inffi!* F (G0)(H(fi)) and(b.2) F (lim inf

* G) v lim infff!* F (G(ff)).

Since by (b.1) Tff = F (G(ff)) is lim inf-pullable, we can apply Lemma 5.23,we have for all G,

ufi lim infff!* F (G(ff)) v lim infff!* ufiF (G(ff)).
Combining this with (b.2), we can prove our goal

ufiF (lim inf* G) v lim infff!* ufiF (G(ff)).

Case CONT-NU.

\Delta ; \Pi , X : +^* `i\Phi  F : ^* \Delta  ` a ord

\Delta ; \Pi  `i\Phi  *aXF : ^*

Let Fff(H) = [[F]]`[X7!H][i7!ff]. By induction hypothesis we have for all
limits * 2 [[ord]], H 2 [[^*]], fi 2 [[ord]], G 2 [[ord]] ! [[^*]] that

(a) lim supff!* Fff(H) v F*(H) = [[F]]`[X7!H][i7!*],
(b) lim supff!* Ffi(G(ff)) v Ffi(lim sup* G) = [[F]]`[X7!lim sup* G][i7!fi],

5.5. SEMANTICAL SOUNDNESS OF CONTINUITY DERIVATIONS 113

thus, F is both upper semi-continuous and lim sup-pushable. First, weobserve that the greatest fixed point of F

fi is already reached at iterate !,because

*!Ffi = lim supff!! Ffffi

= lim supff!! Ffi(Ffffi )v F

fi(lim supff!! Ffffi )= F
fi(*!Ffi)=
*!+1Ffi.

(It is well-known that strictly positive coinductive types close at !.) ByCor. 5.20, we have

lim sup

ff!*

*OE(ff)Fff v *lim inf* OEF*.

Now, by Lemma 5.33, OE := ff 7! [[a]]`[i7!ff] is either affine or constantly?

ord. In both cases, OE(*) >= ! and lim inf* OE >= !, hence, goal (a),

lim sup

ff!*

*OE(ff)Fff v *OE(*)F*

follows since the fixed-point is reached at !.
To show (b) for some variable (Y : +^0) 2 \Pi , let fi = [[a]]` and F (G)(H) =[[F]]

`[Y7!G][X7!H]. Then [[*aXF]]`[Y7!G] = *fiF (G). By induction hypothe-sis (b), for all G0 2 [[

^0]], H 2 [[^*]], G 2 ord ! [[^0]], and * limit

(b.1) lim supfi!* F (G0)(H(fi)) v F (G0)(lim sup* H) and
(b.2) lim supff!* F (G(ff)) v F (lim sup* G).

Since by (b.1) Tff = F (G(ff)) is lim sup-pushable, we can apply Lemma 5.18,yielding for all G,

lim sup

ff!*

*fiF (G(ff)) v *fi lim sup

ff!* F (G(

ff)).

Combining this with (b.2), we can prove our goal

lim sup

ff!*

*fiF (G(ff)) v *fiF (lim sup

* G).

Uff! \Lambda 

114 CHAPTER 5. CONTINUITY
5.6 Type-Based Termination with Continuous Types
We replace the conditions for admissible (co)recursion types from Section 3.1.2by the following, which use the new judgments for semi-continuity:

\Gamma  ` A fixun-adm iff \Gamma  , i : ord ` A i = (~G, (uiF) ffi ~H ) G) : *

and \Gamma  , i : ord `i\Phi  ~G, (uiF) ffi ~H ) G : *

for some F, G, ~G, ~H with |~G| = n

\Gamma  ` A fix*n-adm iff \Gamma  , i : ord ` A i = (~G ) (*iF) ffi ~H) : *

and \Gamma  , i : ord `i\Phi  ~G ) (*iF) ffi ~H : *

for some F, ~G, ~H with |~G| = n

Example 5.35 (Stream of natural numbers) We can now assign a precise typeto the stream of natural numbers 0,1,. . . .

mapStream : 8A8B. (A ! B) ! 8i. Streami A ! StreamiB
mapStream := * f . fix*0 *mapStream*s. h f (fst s), mapStream (snd s)i

nats : 8i. Streami Nati
nats := fix*0 *nats. hzero, mapStream succ natsi

Here are the types of some subexpressions of nats:

nats : Streami Nati
succ : Nati ! Nati+1
mapStream succ nats : Streami Nati+1
zero : Nati+1h

zero, mapStream succ natsi : Streami+1Nati+1

Since Streami Nati is upper semi-continuous (Example 5.29) it is admissible forcorecursion. Note that it was not admissible according to the previous criterion
(Section 3.1.2).

More examples for definitions that require the new criterion will be givenin sections 6.1 (breath-first traversal of finitely branching trees), 6.4, (equality

for monadic lists), 6.5 (a generic merge function), and 6.7 (transitivity of simplesubtyping derivations).

5.7 Related and Future Work
The author [Abe03] has investigated admissible recursion types on the basisof slightly different concept. Roughly, lower semi-continuity of f is replaced
by the weaker condition (1) f (*) v sup* f and upper semi-continuity by theweaker condition (2) lim inf

* f v f (*). He shows the following main lemma:If A(
*) v sup* A and lim inf* B v B(*), then lim infff!*(A(ff) ! B(ff)) v

5.7. RELATED AND FUTURE WORK 115

A(*) ! B(*). One could think that, since the conditions are weaker, moretypes are admissible. But the opposite is the case. Since (1) distributes only
over a product A(ff) * B(ff) if A and B are monotonic, products that involvean antitonic component are rejected by the syntactic calculus "

cocont" whichincarnates (1). However, in this thesis such types, for instance,

Listi(Nati) *(
Nati ! Bool), are accepted as lower semi-continuous.Pareto [Par00] has investigated properties of types similar to semi-continuity.

His setting differs considerably from ours: He considers only fixed-points oftype constructors that are reached at iteration

!. These are inductive typeswithout embedded function spaces, and strictly positive coinductive types.

Size variables range over natural numbers and, consequently, 8i. A(i) quan-tifies only over natural numbers. However, for certain A the variable i may
be instantiated by !: Pareto describes a class of valid types which he calls !-undershooting. These types have the property lim inf

i!! A(i) ` A(!). Func-tion types are
!-undershooting if their codomain is so and if their domain is

!-overshooting, A(!) ` lim infi!! A(i). We have generalized the term !-overshooting to arbitrary limit ordinals and called it lower semi-continuous.

Also, we have demonstrated that our notion of upper semi-continuity, whichuses lim sup, is as useful as Pareto's notion of

!-undershooting, which useslim inf.

We have shown that, in contrast to Pareto, we rightfully refuse inductivetypes as preservers of upper semi-continuity, since we allow embedded function spaces in inductive types.We have given a syntax-directed derivation system for semi-continuous types.
This was possible since we also created the new concepts of lim sup-pushableand lim inf-pullable type constructors on the semantical side. Our calculus is
still weak on the higher-order features, and this is an area of future research.Ideally, we could extend our annotation of function kinds to express how a

lim sup could be pushed into or a lim inf could be pulled out of a constructor.Then we would not need special rules for !, 8, etc, but the kinding of these
constants would take care of continuity properties--as it does currently withvariance properties (polarities +, -, and ffi).

116 CHAPTER 5. CONTINUITY
Chapter 6
Examples
In this chapter, we present several examples, some of which exhibit an inter-esting recursion scheme (breadth-first traversal in Section 6.1, normalization
procedures in sections 6.2 and 6.3, generic programming in Section 6.5) andothers that are interesting for theoretical reasons (impredicative datatypes in
Section 6.6, inductive proofs in Section 6.7). Pareto provided many functionson natural numbers, lists, and streams in his thesis [Par00]. Most of these are
also typable in F!b, except those that use addition of size variables, what we donot support.

In the examples we use syntactic sugar like pattern matching, which is aconservative extension of

F!b. It can be reduced to the primitives as describedin section 2.4 of the article [AMU05].

6.1 Breadth-First Tree Traversal
Breadth-first traversal of a tree is not a structurally recursive program. In thefollowing, we will refine the standard definition such that it is typable in

F!b.
Recall that in Haskell, [a] is the type of lists with constructors nil :: [a]and

(:) :: a -? [a] -? [a] and a function (++) :: [a] -? [a] -? [a],which concatenates two lists. Since in Haskell least and greatest solutions of

type equations coincide, there is no distinction between inductive and coin-ductive types, and

[a] contains finite and infinite lists. For this example, wemean only finite lists. Rose trees are finitely-branching labeled trees with one

constructor Rose :: a -? [Rose a] -? Rose a. A rose forest is a list of rosetrees. Breadth-first flattening of a rose forest can be implemented as follows:

data Rose a = Rose a [Rose a]
bf0 :: [Rose a] -? [a]
bf0 [] = []
bf0 (Rose a rs : rs') = a : bf0 (rs' ++ rs)

117

118 CHAPTER 6. EXAMPLES
Other breadth-first operations like breadth-first left or right folding can be ex-pressed similarly. The definition of

bf0 uses general recursion, since the recur-sive argument
rs' ++ rs is not a subterm of Rose a rs : rs'. Terminationcould be shown by a decreasing measure: the number of

Rose constructors inthe forest. We show termination by massaging the definition until it fits our

type system.Looking a bit closer, we see that the traversal of the forest can be separated
into phases: In the first phase, we process the roots of all rose trees. In the nextphase, we do the same for the subtrees which emerged by cutting the roots in
the first phase. Etc.
step :: [Rose a] -? ([a], [Rose a])
step [] = ([], [])
step (Rose a rs' : rs) =

let (as, rs'') = step rs

in (a : as, rs' ++ rs'')

The step function makes such a run over the forest, returning a list of rootsand the subforest. It is a simple iterative function and returns rose trees which

are strictly less tall than the input trees. This is recognized by its typing in F!b:

Rose : ord +! * +! *
Rose := *i*A. ui**X. A * List1X

step : 8A8j8i. Listj(Rosei+1 A) ! Listj A * List1(Rosei A)
step := fixu0 *step*l. match l with

nil 7! hnil, nili
cons ha, rs0i rs 7! match step rs withhas, rs00i 7! h

cons a as, append rs0 rs00i

The type B(j) = Listj(Rosei+1 A) ! Listj A * List1(Rosei A) of the recursionis admissible, the second size variable i does not interfere with admissibility.

Iterating step, we can perform a complete breadth-first traversal.
bf1 :: [Rose a] -? [a]
bf1 rs =

let (as, rs') = step rs

in as ++ bf1 rs'

However, its type C(i) = List1(Rosei A) ! List1 A is not admissible for re-cursion. And indeed,

bf1 is not terminating on the empty forest, which meansthat it eventually loops on every input. If we introduce a special clause for the

empty forest, we regain termination.
bf2 :: [Rose a] -? [a]
bf2 [] = []
bf2 rs =

let (as, rs') = step rs

in as ++ bf2 rs'

6.1. BREADTH-FIRST TREE TRAVERSAL 119
But since we have not improved on the type of bf2, our type system will stillreject it. We need to make explicit that we deal with non-empty forests in the
recursion.

bf3 :: [Rose a] -? [a]
bf3 [] = []
bf3 (r:rs) = bf3' r rs

bf3' :: Rose a -? [Rose a] -? [a]
bf3' r rs =

case step (r:rs) of

(as, []) -? as
(as, r' : rs') -? as ++ bf3' r' rs'

The recursion in function bf3' can be given the type

C(i) = Rosei A ! List1(Rosei A) ! List1 A
which is admissible in the extension of F!b introduced in Chapter 5. For this,we have to show

A : ffi*, i : ffiord; \Pi  `i\Phi  Rosei A ! List1(Rosei A) ! List1 A : *.
The non-obvious part of this goal is to show that List1(Rosei A) is lower semi-continuous. In the following derivation, let

\Gamma  := A : ffi*, i : ffiord. We further savespace by dropping inessential parts of the derivation and its judgements.

\Gamma ; X, Y, Z `i\Psi  1 + Y * Z

\Gamma ; X, Y `i\Psi  List1Y
\Gamma ; X, Y `i\Psi  A * List1Y \Gamma ; X `i\Psi  i : ord

\Gamma ; X `i\Psi  Rosei A \Gamma ; X `i\Psi  X

\Gamma ; X `i\Psi  1 + Rosei A * X

\Gamma ; \Pi  `i\Psi  List1(Rosei A)

As a thumb rule, a type is lower semi-continuous, if its composed only of con-stant types, sum, product, and strictly positive inductive types.

This is the encoding of bf3' in F!b:

bf03 : 8A8i. Rosei A ! List1(Rosei A) ! List1 A
bf03 := fixu0 *bf *r*rs. match step (cons r rs) withhas,

nili 7! ashas,
cons r0 rs0i 7! append as (bf r0 rs0)

120 CHAPTER 6. EXAMPLES
We can assign the following types:

bf : Rosei A ! List1(Rosei A) ! List1 A

r : Rosei+1 A
rs : List1(Rosei+1 A)
cons r rs : List1(Rosei+1 A)
step (cons r rs) : List1 A * List1(Rosei A)r0 :

Rosei Ars0 :
List1(Rosei A)bf r0 rs0 :
List1 A

Looking at bf3 we recognize that step is only called with non-empty forests.This enables the following optimization:

step4 :: Rose a -? [Rose a] -? ([a], [Rose a])
step4 (Rose a rs') [] = ([a], rs')
step4 (Rose a rs') (r:rs) =

let (as, rs'') = step4 r rs

in (a : as, rs' ++ rs'')

bf4' :: Rose a -? [Rose a] -? [a]
bf4' r rs =

case step4 r rs of

(as, []) -? as
(as, r' : rs') -? as ++ bf4' r' rs'

We have successfully turned breadth-first traversal into a program which isaccepted by our type system, by exhibiting a structure that was implicit in the

original program. Well, the resulting program is much longer than the original,have we gained anything? Indeed, the refined program runs even faster than
the original! For a literal translation of these programs into SML/NJ, Version110.0.7, I have obtained the following running times on a SuSE Linux 9.1 system with an Intel Rfl Pentium Rfl III 1066MHz Mobile CPU and 256 MB systemRAM.

Depth Size Rep bf0 bf2 bf4
1 2 1000000 0.112 0.128 0.107
2 5 318641 0.119 0.136 0.105
3 16 52006 0.092 0.081 0.075
4 65 5281 0.109 0.034 0.032
5 326 371 0.176 0.013 0.012
6 1957 20 0.380 0.006 0.005
7 13700 1 1.984 0.006 0.005

The first two columns display quantitative information about traversed rosetrees and the third column the number of repetitions. The remaining columns

list the running times of the three programs in seconds. The speed-up can be

6.2. CONTINUOUS NORMALIZATION OF INFINITE DE BRUIJN TERMS121
explained by a more economic use of concatenation: The original program ap-pends each subforest immediately to the (possibly very long) traversed forest,
which can be a quite expensive operation. The refined programs only prepend(relatively short) subforests to an intermediate forest, which will be the traversed forest in the next phase. This is, in comparison, a cheap operation.

6.2 Continuous Normalization of Infinite De Bruijn

Terms

Whether a normalizer/evaluator terminates depends on the object languageand on the object expression that is to be evaluated. Usually, an evaluator cannot be implemented in a total meta language. In Section 6.3 we will present anexception: normalization of simply typed lambda-terms can actually be implemented in F!b. But even evaluators for partial object languages, which might beinvoked on non-terminating object programs, can be implemented in

F!b usingcoinduction. The trick is to produce the result step by step, and if no new piece

of output can be guaranteed in the next step, instead produce a tick, whichmeans wait for more output. (Of course, nothing guarantees that there will not
be an infinite succession of ticks.) Such evaluation techniques are known underthe slogan continuous normalization in proof theory and have been introduced
by Mints [Min78] for the sequent calculus and adopted for natural deductionstyle term systems by Ruckert [Ruc85] and Schwichtenberg [Sch98], who built
upon Buchholz's infinite notations of sequent proofs [Buc91].Aehlig and Joachimski [AJ05] describe continuous normalization of infinite

*-terms by guarded corecursion in the sense of Coquand [Coq93]. They givethe following grammar for infinite de Bruijn terms with two "repetition" symbols R and fi [AJ05, page 43] .

\Lambda coR 3 r, s ::=co k | *r | r s | Rr | fir
(Herein, k denotes a de Bruijn index.) After defining substitution r[s] of s forthe 0th variable in r, they give the following recursive definition of a function
r@~s, which continuously fi-normalizes the term r~s (where~s is a possibly empty,finite list of terms)[AJ05, page 46].

k @ (s1, . . . , sn) = k (s1@()) . . . (sn@())(
*r) @ (s,~s) = fi(r[s]@~s)(
*r) @ () = *(r@())(r s) @

~s = R(r@(s,~s))(Rr) @
~s = R(r@~s)(
fir) @~s = fi(r@~s)

Since each recursive call is under a term constructor, these equations define acorecursive function according to the guarded-by-constructors principle [Coq93,
Gim95]. The constructors R and fi do not contribute to the semantics of a

122 CHAPTER 6. EXAMPLES
lambda-term, but act as a notification that computation is still ongoing, but theoutermost constructor of the lambda-term is not yet known. The symbol R
is produced whenever an application is evaluated (fourth equation), the sym-bol

fi when a fi-reduction has been performed. It is remarked that continuousnormalization could be defined without the

fi-constructor. Then, the recursivecall in the second equation is no longer under a constructor, thus, violates the

guardedness condition. But the recursive call is justified since the length of thesecond argument has been decreased. Hence, the "termination" argument is
lexicographic: Either the definedness of the output is increased (the second ar-gument might be increased, as in the case of application), or the definedness of
the output is not increased, but the size of the second argument is decreased.To make this precise, we express the normalization algorithm in

F!b.

In F!b, we can define a coinductive type dB : ord ! * with the followingconstructors:

var : 8i. Nat ! dBi+1
abs : 8i. dBi ! dBi+1
app : 8i. dBi ! dBi ! dBi+1
rep : 8i. dBi ! dBi+1

We assume we have already defined substitution subst : dB1 ! dB1 ! dB1(such that

subst r s returns r[s]) and the library function for lists,

foldl : 8A8B. (B ! A ! B) ! B ! List1 A ! B
foldl o e [a1, . . . , an] = e o a1 o . . . o an

where [a1, . . . , an] denotes, as in ML and Haskell, the list cons a1 (. . . cons annil),and o is a binary operation written infix. Then we can implement the normalization function @ by the following definition:

napp : 8i8j. dB1 ! Listj dB1 ! dBi
napp := fix*2 *napp0.

fixu1 *napp1.

*t*l. match t with

var k 7! foldl (*r0*s. app r0 (napp0 s nil)) t l
abs r 7! match l with

nil 7! abs (napp0 r nil)
cons s l0 7! napp1 (subst r s) l0
app r s 7! rep (napp0 r (cons s l))
rep r 7! rep (napp0 r l)

This definition is well-typed, since we can assign the following types to vari6.3. NORMALIZATION OF SIMPLY-TYPED DE BRUIJN TERMS 123
ables and subexpressions:

napp0 : 8j. dB1 ! ListjdB1 ! dBi
napp1 : dB1 ! ListjdB1 ! dBi+1r, s, t :

dB1
l : Listj+1dB1
r0 : dBi+1 <= dBi
app r0 (napp0 s nil) : dBi+1
foldl (. . . ) t l : dBi+1
abs (napp0 r nil) : dBi+1l0 :

ListjdB1
napp1 (subst r s) l0 : dBi+1
rep (napp0 . . . ) : dBi+1

An equivalently precise type of napp is the instantiation dB1 ! List1dB1 !
dB1, but we used the size variables i and j to indicate that napp is defined bylexicographic induction over (i,

j).

Remark 6.1 The function napp's modulus of continuity is not the identity; wecannot assign to it the more precise type 8i.

dBi ! List1dBi ! dBi. This would
require subst to be of type 8i. dBi ! dBi+1 ! dBi+1 which is clearly invalid: ifin the call

subst r s, the first argument r does not contain the 0th variable, thenthe result is r which only has type

dBi. Hence, the most precise type for substis 8i.
dBi ! dBi ! dBi.

6.3 Normalization of Simply-Typed De Bruijn Terms
We continue the example of Section 3.2.7. Simple types over a fixed type Atomof base types can be represented by the following constructors, which are easily
definable F!b:

Ty : ord +! *
atom : 8i. Atom ! Tyi+1
arr : 8i. Tyi ! Tyi ! Tyi+1

Joachimski and Matthes [JM03] describe a normalization procedure for simply-typed

*-terms; a similar algorithm has been found by Watkins, Cervesato,Pfenning, and Walker [WCPW03] for a term language of intuitionistic linear

logic. At its heart lies an operation r@sA which produces a the fi-normal formof r s where r and s are normal and s is of type A. It uses a normalizing substitution function [s/x : A]r which returns the normal form of the substitution[s

/x]r if r and s are normal and s is of type A. The termination order of these

124 CHAPTER 6. EXAMPLES
mutual recursive functions is the lexicographic product of A and r.

(*x : A. r)@sA = [s/x : A]r(

x~r)@sA = x~r s

[s/x : A](*y : B. r) = *y : B. [s/x : A]r w. l. o. g., y 62 FV(s) and x 6= y
[s/x : A](r t) = r0 ([s/x : A]t) if r0 := [s/x : A]r neutral=

r0@([s/x : A]t)C otherwise (then C is smaller than A)

[s/x : A]y = sA if x = y= y otherwise

The result of substitution into a neutral term is either a neutral term or a normalterm plus its type. We encode these alternatives in the type

Resi A, where i isan upper bound on the size of the type and A is the set of free variables which

might occur in the result term.

Res : ord +! * +! *
Res := *i*A. (1 + Tyi) * TLam1 A

resNe : 8i. TLam1 A ! Resi A
resNe := *r. hinl hi, ri

resNf : 8i. Tyi ! TLam1 A ! Resi A
resNf := *a*r. hinr a, ri

weakRes : 8i8A. Resi A ! Resi (1 + A)
weakRes := *hm, ri. hm, mapTLam inr ri

The function weakRes lifts the free variables in a result term by one (the function
mapTLam is defined in Section 3.2.7).

The implementation of [s/x : A]r is problematic, since for our encoding ofde Bruijn terms only r

ae of all free variables is directly implementable. Sub-stitution of a single variable is then implemented as a special case of parallel

substitution. But for the termination of normalizing substitution, the size oftype A is important, so we expose it in the mapping

ae.

(*x : A. r)@sA = r(ae0[x 7! sA])(

x~r)@sA = x~r s

(*y : B. r)aeA = *y : B. r(ae[y 7! y])A w. l. o. g., y singular in ae
(r s)aeA = r0 (saeA) if r0 := raeA neutral=

r0@(saeA)C otherwise (then C is smaller than A)

yaeA = ae(y)

In the first line, ae0 denotes the identity substitution. A sharp look reveals thatthe mapping

ae assigns exactly to one variable a non-trivial term, namely s to x,all other variables are mapped to themselves. A generalization of this invariant

6.3. NORMALIZATION OF SIMPLY-TYPED DE BRUIJN TERMS 125
can be expressed in the type Substi A B of ae:

Subst : ord +! * -! * +! *
Subst := *i*A*B. A ! ResiB

sgSubst : 8i8A. TLam1 A ! Tyi ! Substi (1 + A) A
sgSubst := *s*a*mx. match mx with

inl hi 7! resNf a s
inr x 7! resNe (var x)

liftSubst : 8i8A8B. Substi A B ! Substi (1 + A) (1 + B)
liftSubst := *rho*mx. match mx with

inl hi 7! resNe (var (inl hi))
inr x 7! weakRes (rho x)

The call sgSubst s a : Substi (1 + A) A corresponds to ae0[x 7! sA]; it generates asubstitution which maps the variable x in 1 to

resNf a s and the variables y in Ato
resNe (var y). The extension ae[y 7! y] of a substitution ae is implemented by
liftSubst rho.

tm : 8A. Res1 A ! TLam1 A
tm := *hm, ri. r

absRes : 8i8A. Ty1 ! Res1(1 + A) ! Resi A
absRes := *a*p. hinl hi, abs a (tm p)i

appNf : 8A. Ty1 ! TLam1 A ! TLam1 A ! TLam1 A
appNf := fixu0 *app.

let subst =

fixu0 *subst*t*rho. match t with

abs c u 7! absRes c (subst u (liftSubst rho))
var y 7! rho y
app r s 7! match subst r rho with

resNe r0 7! resNe (app r0 (tm (subst s rho)))
resNf (arr a b) r0 7! resNf b (app a r0 (tm (subst s rho)))
in *a*r*s. match r with

abs _ t 7! tm (subst t (sgSubst s a))
var _ 7! app r s
app _ _ 7! app r s

The matching of p := subst r rho is not complete, we have omitted the case
resNf (atoma) r0. This case is excluded by an invariant we cannot express in ourtype system: that r, and also the parallel substitution of r have function type.

In practice, this clause is never needed, so we could return anything suitable.

The body of appNf is quite complex; to increase readability we have useda
let x = s in t construct as syntactic sugar for (*xt) s. First we consider the

126 CHAPTER 6. EXAMPLES
typing of subst:

app : Tyi ! 8A. TLam1 A ! TLam1 A ! TLam1 A
subst : 8A8B. TLamj A ! Substi+1 A B ! Resi+1B

t : TLamj+1 A
rho : Substi+1 A Bc :

Ty1u :
TLamj(1 + A)
liftSubst rho : Substi+1 (1 + A) (1 + B)
subst u (liftSubst rho) : Resi+1(1 + B)
absRes c (. . . ) : Resi+1By : A

rho y : Resi+1Br, s :

TLamj A
subst r rho : Resi+1 Br0,

tm (subst s vrho) : TLam1B
resNe (app r0 (. . . )) : Resi+1 B
arr a b : Tyi+1a, b :

Tyiapp a r0 (. . . ) :
TLam1B
resNf b (. . . ) : ResiB <= Resi+1B
subst : 8A8B. TLam1 A ! Substi+1 A B ! Resi+1B

Well-typedness of appNf now follows:

app : Tyi ! 8A. TLam1 A ! TLam1 A ! TLam1 A
subst : 8A8B. TLam1 A ! Substi+1 A B ! Resi+1B

a : Tyi+1r, s :

TLam1 At :
TLam1 (1 + A)
sgSubst s a : Substi+1 (1 + A) A
subst t (. . . ) : Resi+1 A
tm (. . . ), app r s : TLam1 A

6.4 Data Types with Higher-Order Parameters
Type-based termination, unlike termination using structural term orderings,scales effortlessly to data types with higher-order parameters. For example,
consider the type of monadic lists

MList : ord +! (* +! *) +! * +! *
MList := *i*M*A. ui*X. 1 + M A * M X

6.4. DATA TYPES WITH HIGHER-ORDER PARAMETERS 127
with constructors

mnil : 8i. 8M : (* +! *). 8A.

MListi+1 M A
mnil := inl hi

mcons : 8i. 8M : (* +! *). 8A.

M A ! M (MListi+1 M A) ! MListi+1 M A
mcons := *ma*mas. inr hma, masi.

Equality-test for monadic lists MListi M A must necessarily be parameterizedby an equality for A and an equality transformer for M, meaning a function
which turns an equality for an arbitrary type A into an equality for type M A.

Eq : * ! *
Eq := *A. A ! A ! Bool

eqMList : 8M. (8A. Eq A ! Eq (M A)) ! 8A. Eq A ! Eq (MList1 M A)
eqMList := *meq*eq. fixu0 *eqMList.

*k*l.match hk, li withh

mnil, mnili 7! trueh
mcons ma mas,
mcons mb mbsi 7! meq eq ma mb andmeq eqMList mas mbs

_ 7! false
The function eqMList exhibits a funny recursion pattern: instead of having arecursive call in which the function is applied to some structurally smaller arguments, in the "recursive call" meq eqMList, it is passed itself as an argument toone of the function arguments. Now this behavior is surely problematic: If we
do not know how meq handles its argument, there is no way we could justifytermination. For instance, the execution of meq eqMList could involve an application of eqMList to some non-empty constant lists. In this case eqMList wouldclearly diverge. Fortunately, the parametric type 8A.

Eq A ! Eq (M A) of meqprevents such a use of eqMList. And indeed,
eqMList is terminates on all inputs,since it is well-typed in
F!b:

eqMList : Eq (MListi M A)

k, l : MListi+1 M Amas, mbs : M (

MListi M A)meq : 8A.

Eq A ! Eq (M A)meq eqMList :
Eq (M (MListi M A))meq eqMList mas mbs :
Bool

This was a first instance of a non-standard recursion behavior; in the next sec-tion we will see more such examples.

128 CHAPTER 6. EXAMPLES
6.5 Generic Programming
Jansson and Jeuring [JJ97] and Hinze [Hin02] describe frameworks for poly-typic and generic programming. In these, both types and values can be constructed by recursion on some index type. A common feature is that the behav-ior is only specified for the type and constructor constants like

Nat, 1, + and *,and this uniquely defines the constructed type or value. In the following we

propose an ad-hoc extension by sized types, sized polytypic programming. Thisframework is good enough to model Hinze's generalized tries [Hin00b], but
whether it scales to other examples requires more research.

Type-indexed types are of kind-indexed kinds. A type-indexed constructor
TypehF :^i has kind-indexed kind TYPEh^i. In the polytypic framework, eachsuch constructor

TypehFi and each such kind TYPEh^i must obey the followinglaws:

TYPEhordi = ord
TYPEh^1 p! ^2i = TYPEh^1i p! TYPEh^2i

TypehXi = X
Typeh*XFi = *X. TypehFi
TypehF Gi = TypehFi TypehGi
Typehr^i = rTYPEh^i
Typehsi = s
Typeh1i = 1

This means, function kinds are always mapped to function kinds, applica-tion to application, fixed point to fixed point etc. Hence, a kind-indexed kind

TYPEh^i is determined by the value of TYPEh*i, and a type-indexed type
TypehFi by the value of TypehCi for the constants C which appear in F.

Proposition 6.2 (Well-kindedness of type-indexed types) Let \Sigma  a signature ofconstructor constants. If

TypehCi : TYPEh^i for all (C : ^) 2 \Sigma , and D :: X1 :p

1^1, . . . , Xn : pn^n ` F : ^, then X1 : p1TYPEh^1i, . . . , Xn : pnTYPEh^ni `
TypehFi : TYPEh^i.

Proof. By induction on D. \Lambda 

Remark 6.3 Note that the presence of polarities restricts the choices for TypehCi.However, if index types are constructed in a signature without polymorphism
and function space, as it is usual in the generic programming community, allfunction kinds are covariant and we do not have to worry about polarities.

Example: finite maps via generalized tries. Hinze [Hin00b] defines general-ized tries

MaphFi by recursion on F. In particular, MaphK : *i V is the type of

6.5. GENERIC PROGRAMMING 129
finite maps from domain K to codomain V. The following representation us-ing type-level

* can be found in his article on type-indexed data types [HJL04,page 139].

MAPh*i := * +! *
MaphInti := *V. efficient implementation of Int !fin V
MaphChari := *V. efficient implementation of Char !fin V
Maph1i := *V. 1 + V
Maph+i := *F*G*V. 1 + F V * G V
Maph*i := *F*G*V. F (G V)

Well-kindedness of these definitions is immediate, except maybe for Maph*i
which must be of kind (* +! *) +! (* +! *) +! (* +! *). For Maph+i we haveused the variant of spotted products (or lifted products) which Hinze mentions

in section 4.1 of his article [Hin00b]. This way we avoid that certain emptytries have a infinite normal form (see [Hin00b, page 341]) which requires lazy
evaluation. The constructor for finite maps over strings can now be computedas follows:

Maph*i. Listi Chari=
Maph*i. u* i *X. 1 + Char * Xi=

*i. u* +!* i *X. Maph+i Maph1i (Maph*i MaphChari X)

= *i. u* +!* i *X*V. 1 + (1 + V) * MaphChari (X V)
(= *i*V. u* i *Y. 1 + (1 + V) * MaphChari Y)

For the last (and optional) step, we have applied *-dropping (see Sec. 3.3.5), toturn the second-order fixed point into a first-order one. The matching kind is

MAPhord +! *i = ord +! * +! *.
Type-index values polyhF :^i are of kind-indexed types. These types PolyhF :
^i are defined by recursion on ^, and F is just a parameter. The kind ^ must fitinto the grammar

^ ::= * | ord p! ^ | ^1 p! ^2.
Note that Hinze, Jeuring, and Lo"h [HJL04, page 142] allow kind-indexed types
Polyh. . . i with several constructor parameters. For our examples, however, asingle parameter is sufficient.

The following laws hold for all constructor-indexed values polyhF : ^i and

130 CHAPTER 6. EXAMPLES
kind-indexed types PolyhF :^i in the framework:

PolyhF : ord p! ^i = 8i : ord. PolyhF i :^i
PolyhF :^1 p! ^2i = 8G :^1. PolyhG :^1i ! PolyhF G :^2i

polyhXi = x
polyh*iF : ord ! ^i = polyhFi
polyh*XF : ^1 ! ^2i = *x. polyhFi where ^1 6= ord
polyhr^ ai = fixrn for some n
polyhF Gi = polyhFi polyhGi where F 6= r

In order to ignore size expressions, which do not contribute to the compu-tational behavior of the generic value

polyhFi, we ignore size abstractions andsize parameters to fixed points. To make this work, the constructor parameter F

must be in normal form, and constants C of the signature should not take a sizeargument. A polytypic value of an (co)inductive constructor is (co)recursive.
The parameter n in fixrn must be given appropriately.Note that kind-indexed types need not be compositional, i. e., in general
PolyhF Gi = PolyhFi PolyhGi does not hold. On the other hand, they are para-metric in the constructor argument, since only a single equation

PolyhA : *i =. . . is given by the user, which does not analyze the structure of A.

Example: finite map lookup. We give an adaption of Hinze's generic lookupfunction to our setting. Herein, we use the bind operation AE= for the Maybe
monad *V. 1 + V. It obeys the laws inl() AE= f -!+ inl() and inr v AE=f -!+ f v. Note that in this section, we will write pairs as (r, s) instead of hr, si
and the empty tuple as () instead of hi, to avoid confusions with the notationfor type indices.

LookuphK : *i := 8V. K ! MaphKi V ! 1 + V
lookuph1i : 8V. 1 ! 1 + V ! 1 + V
lookuph1i := *k*m. m

lookuph+i : 8A : *. LookuphAi ! 8B : *. LookuphBi !8V. A + B ! 1 + (

MaphAi V) * (MaphBi V) ! 1 + V

lookuph+i := *la*lb*ab*tab. tab AE= *(ta, tb).

match ab with

inl a 7! la a ta
inr b 7! lb b tb

lookuph*i : 8A : *. LookuphAi ! 8B : *. LookuphBi !8V. A * B !

MaphAi (MaphBi V) ! 1 + V

lookuph*i := *la*lb*(a, b)*tab. la a tab AE= *tb. lb b tb

All these definitions are well-typed, which is easy to check since there are noreferences to sizes.

6.5. GENERIC PROGRAMMING 131
Example: lookup for list-shaped keys. The previous definitions determinethe instance of the generic lookup function for the type constructor of lists.

lookuphListi:

LookuphListi: 8i8K : *.

LookuphKi ! LookuphListi Ki: 8i8K : *.
LookuphKi ! 8V. ListiK ! MaphListiKi ! 1 + V: 8i8K : *.
LookuphKi ! 8V. ListiK ! (ui*Y. 1 + (1 + V) * Y) ! 1 + V

lookuphListi=

lookuph*i*K. ui*X. 1 + K * Xi=

*lookupK. fixu0 *lookup. lookuph+i lookuph1i (lookuph*i lookupK lookup)=
*lookupK. fixu0 *lookup*l*m. m AE= *(n, c).

match l with

nil 7! n
cons k l0 7! lookupK k c AE= *m0. lookup l0 m0

Note that the type of lookuphListi mentions the size variable i twice, as indexto both inductive arguments. This makes sense, since the length of the search

keys determines the depth of the trie. Welltypedness can be ensured on anabstract level:

lookupK : LookuphKilookup :

LookuphListiKi
lookuph*i lookupK lookup =: r : LookuphK * ListiKi
lookuph+i lookuph1i r =: s : Lookuph1 + K * ListiKi

: LookuphListi+1Ki
fixu0 *lookup. s : LookuphListiKi

Finally, the type LookuphListiKi is admissible for recursion on the first argu-ment, since the first argument is of shape

uiF and the whole type LookuphListiKiis upper semi-continuous in i.

Trie merging. Hinze [Hin00b] presents three elementary operations to con-struct finite tries:

empty, single, and merge. In the following we replay theconstruction of
merge in our framework, since it exhibits a most interestingrecursion scheme.

First we define the type Bin V for binary operations on V and a function
comb which lifts a merging function for V to a merging function for 1 + V.

Bin : * ffi! *
Bin := *V. V ! V ! V

comb : 8V. (V ! V ! V) ! (1 + V ! 1 + V ! 1 + V)
comb := *c*m1*m2. match (m1, m2) with(

inl(), _) 7! m2(_,

inl()) 7! m1(
inr v1, inr v2) 7! inr (c v1 v2)

132 CHAPTER 6. EXAMPLES
The following definitions determine a generic merging function.

MergehK : *i := 8V. Bin V ! Bin (MaphKi V)
mergeh1i : Mergeh1i
mergeh1i := comb

mergeh+i : 8A. MergehAi ! 8B. MergehBi ! 8V. Bin V !

Bin (1 + MaphAi V * MaphBi V)

mergeh+i := *ma*mb*c. comb

*(ta1, tb1)*(ta2, tb2). (ma c ta1 ta2, mb c tb1 tb2)

mergeh*i : 8A. MergehAi ! 8B. MergehBi ! 8V. Bin V !

Bin (MaphAi (MaphBi V))

mergeh*i := *ma*mb*c. ma (mb c)

The instance for list tries can be computed as follows:

mergehListi:

MergehListi: 8i8K.

MergehKi ! MergehListiKi: 8i8K. (8V.

Bin V ! Bin (MaphKi V)) !8W.
Bin W ! Bin (MaphListiKi W)

mergehListi=

mergeh*i*K. ui*X. 1 + K * Xi=

*mergeK. fixu1 *merge. mergeh+i mergeh1i (mergeh*i mergeK merge)=
*mergeK. fixu1 *merge*c. comb

*(mv1, t1)*(mv2, t2). (comb c mv1 mv2, mergeK (merge c) t1t2)[=
*mergeK*c. fixu0 *merge. comb

*(mv1, t1)*(mv2, t2). (comb c mv1 mv2, mergeK merge t1 t2)]

In the last step, we have decreased the rank of recursion by *-dropping. Sur-prisingly, recursion happens not by invoking merge on structurally smaller arguments, but by passing the function itself to a parameter, mergeK. Here, type-based termination reveals its strength; it is not possible to show termination of
mergehListi disregarding its type. With sized types, however, the terminationproof is again just a typing derivation, as easy as for

lookuphListi. We reasonagain on the abstract level:

mergeK : MergehKimerge :

MergehListiKi
mergeh*i mergeK merge =: r : MergehK * ListiKi
mergeh+i mergeh1i r =: s : Mergeh1 + K * ListiKi

: MergehListi+1Ki
fixu1 *merge. s : MergehListiKi

6.6. IMPREDICATIVE DATA TYPES 133
The type MergehListiKi is admissible for recursion on the second argument (thefirst argument is of type

Bin V): The whole type is of shape 8V. Bin V ! uiF !
uiF ! uiF for some F which does not depend on the size variable i. Hence, thetype is upper semi-continuous.

Merging bushy tries. An even more dazzling recursion pattern is exhibitedby the merge function for "bushy" tries, i. e., finite maps over bushy lists.

Bush : ord +! * +! *
Bush := *i. u* +!* i *X*K. 1 + K * X (X K)

MaphBushi : ord +! (* +! *) +! (* +! *)
MaphBushi = *i. u(* +!*) +!(* +!*) i *X*F*V. 1 + (1 + V) * F (X (X F) V)

The merge function for bush-indexed tries can be derived routinely:

mergehBushi=

mergeh*i. ui *X*K. 1 + K * X (X K)i=
fixu2 *merge*mergeK.

mergeh+i mergeh1i (mergeh*i mergeK (merge (merge mergeK)))=
fixu2 *merge*mergeK

*c. comb *(mv1, t1)*(mv2, t2).(

comb c mv1 mv2, mergeK (merge (merge mergeK) c) t1 t2)

The recursion pattern of mergehBushi is adventurous. Not only is the recur-sive instance merge passed to an argument to the function merge

K, but also thisfunction is modified during recursion: it is replaced by (merge merge

K), whichinvolves the recursive instance again! All these complications are "miraculously" resolved by typing!

Related work. Hinze, Jeuring, and Lo"h [HJL04] present generic program-ming with type-indexed datatypes and type-indexed value both in Haskell and
the higher-order polymorphic *-calculus with a standard model. Altenkirch[Alt01] investigates the representation of total functions over inductive types
as higher-order coinductive types. He establishes isomorphisms in a categori-cal semantics.

6.6 Impredicative Data Types
Some kinds of structural orderings for termination do not scale to impredica-tivity. On such ordering is described by Coquand [Coq92] and implemented in
the termination checker foetus [AA02, Abe99]. It rests on the axioms

t < c t, if c is a data constructor, andf t <= f .

134 CHAPTER 6. EXAMPLES
In the presence of datatypes with impredicativity, this ordering is not well-founded. Coquand demonstrates this using a type

V with a single constructor

c : (8A. A ! A) ! V.
With id = *xx we obtain the cycle c id > id >= id (c id) = c id. Hence, a ter-mination checker based on this ordering would accept the recursive program

f (c g) = f (g (c g)). Let us analyze this paradox with sized types:

V : ord +! *
V := *i. ui**_. 8A. A ! A

loop : 8i. Vi ! 0
loop := fixu0 * f *g. f (g g)

Type-based termination rejects this program: We have

g : 8A. A ! Ag

: Vi+1
g g : Vi+1,

but f : Vi ! 0 does not accept this argument.

6.7 Inductive Proofs as Recursive Functions
In this section, we will demonstrate how F!b can be used to certify termina-tion of recursive functions which correspond to proofs by induction in some
dependent type theory.As example theorem, we consider transitivity for a simple inductively defined subtyping relation. A similar example has been given by Wahlstedt [Wah04],who uses size-change termination [LJBA01].

We consider a language of simple types oe, o/ with a least type ? and a great-est type ?.

Ty 3 oe, o/ ::= ? | ? | oe * o/ | oe ) o/
Subtyping is defined inductively by the following rules:

SBot ? <: o/ STop o/ <: ?

SProd oe1 <: oe2 o/1 <: o/2oe1 * o/1 <: oe2 * o/2 SArr oe2 <: oe1 o/1 <: o/2oe1 ) o/1 <: oe2 ) o/2
We represent this subtyping relation by an inductive family Sub : Ty ! Ty !
Prop with four constructors:

SBot : Sub ? o/
STop : Sub o/ ?
SProd : Sub oe1 oe2 ! Sub o/1 o/2 ! Sub (oe1 * o/1) (oe2 * o/2)
SArr : Sub oe2 oe1 ! Sub o/1 o/2 ! Sub (oe1 ) o/1) (oe2 ) o/2)

6.7. INDUCTIVE PROOFS AS RECURSIVE FUNCTIONS 135
We have suppressed the arguments of type Ty for all constructors: SBot and
SBot take an additional hidden argument o/, and SProd and SArr take four hid-den arguments

oe1, oe2, o/1, and o/2.
The relation <: is transitive, and it can be shown by induction on the sumof the heights of the two input derivations. In type theory, the proof can be

implemented as a recursive function

trans : Sub o/1 o/2 ! Sub o/2 o/3 ! Sub o/1 o/3.
Again, we consider o/1, o/2, and o/3 hidden arguments of trans. Each case in theproof of transitivity corresponds to one pattern matching clause of

trans. Usingthe type dependencies, the following matching is complete:

trans SBot _ = SBot
trans _ STop = STop
trans (SProd d1 d01) (SProd d2 d02) = SProd (trans d1 d2) (trans d01 d02)
trans (SArr d1 d01) (SArr d2 d02) = SArr (trans d2 d1) (trans d01 d02)

This function is not just defined by structural recursion on the first argumentor by lexicographic recursion on both arguments, since in the last line, a subterm (d2) of the second argument appears as first argument to a recursive call(

trans d2 d1) and vice versa. A valid termination measure would be the sum ofthe size of both arguments. We can also certify its termination by typing it in

F!b. To this end, we have to erase all dependencies.

In F!b, we set Subi := ui *X. 1 + 1 + X * X + X * X. The four constructorsare now definable:

SBot : 8i. Subi+1
STop : 8i. Subi+1
SProd : 8i. Subi ! Subi ! Subi+1
SArr : 8i. Subi ! Subi ! Subi+1

The recursive function can now be given the type

trans : 8i. Subi ! Subi ! Subi.
One problem remains: In F!b, we have no partiality, but without dependencies,the four patterns defining

trans do not cover the full value space. This problemcan be mended by adding a catch-all clause

trans _ _ = SBot, or by extending
F!b by partiality. For instance, one could have four eliminations of the disjointsum type,

caseS, for S ` {l, r}, with typing

case{} : 8A8B8C. A + B ! C
case{l} : 8A8B8C. A + B ! (A ! C) ! C
case{r} : 8A8B8C. A + B ! (B ! C) ! C
case{l,r} : 8A8B8C. A + B ! (A ! C) ! (B ! C) ! C

136 CHAPTER 6. EXAMPLES
and the reduction rules

case{l} (inl r) s ae s r
case{r} (inr r) t ae t r
case{l,r} (inl r) s t ae s r
case{l,r} (inr r) s t ae t r.

A term caseS (ink r) with k 62 S would be considered neutral.Chapter 7

Extensions

In this chapter, we sketch some useful extensions of F!b.
7.1 Mutual Recursion
Normal de Bruijn terms can be defined by two mutually recursive type con-structors in Haskell:

data Ne a = Var a

-- App (Ne a) (Nf a)

data Nf a = Ne (Ne a)

-- Abs (Nf (Maybe a))

In F!b, there is no notion of mutual recursion, but it can be simulated withnested recursion.1 For mutual type constructors, the standard encoding into
nested inductive type constructors works smoothly:

NeF, NfF : (* +! *) +! (* +! *) +! * +! *
NeF := *X*Y*A. A + Y A * X A
NfF := *X*Y*Y. Y A + X (1 + A)

Ne, Nf : ord +! * +! *
Ne := *i. ui* +!**Y. NeF (u* +!**X. NfF X Y) Y

Nf := *i. ui* +!**X. NfF X (u* +!**Y. NeF X Y)

1Nested is also called interleaving [AA00].

137

138 CHAPTER 7. EXTENSIONS
As usual, we can define the following data constructors:

var : 8A8i. A ! Nei+1 A
var := *x. inl x

app : 8A8i. Nei A ! Nfi A ! Nei+1 A
app := *r*s. inr hr, si

ne : 8A8i. Nei A ! Nfi+1 A
ne := *r. inl r

abs : 8A8i. Nfi A ! Nfi+1 A
abs := *r. inr r

To encode mutual recursion on the term level, we need to extend the typesystem of

F!b. We basically need a well-founded recursion rule and a boundedrecursion rule:

TY-WF-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord\Gamma  ` fixr

n : (8i : ord. (8j <= i. A j) ! A (i + 1)) ! A a

TY-BD-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord\Gamma  ` fixr

n : (8i <= a. A i ! A (i + 1)) ! A a0 a

0 2 {a, s a}

Bounded quantification 8X <= G : ^. A is to be understood as usual. It hasbeen studied extensively in the last decade, e. g., by Pierce and Steffen [PS97,
Ste98] and Duggan and Compagnoni [DC99]. In our calculus, we could add itthrough a constant and some defined notation:

8<=^ : ^ -! (^ ffi! *) +! *8

X <= G :^. A := 8<=^ G (*XA)

Adding a top kind Top^ : ^ for all kinds (for ord it is 1), we can then define
usual quantification by 8^ := 8<=^ Top^. We replace the generalization and in-stantiation rules by the following:

TY-GEN \Gamma  , X <= G :^ ` t : F X\Gamma  ` t : 8<=

^ G F

TY-INST \Gamma  ` t : 8<=^ H F \Gamma  ` G <= H : ^\Gamma  ` t : F G

Figure 7.1 displays the mapping terms of normal and neutral de Bruijnterms. The term

mapNf reuses the lifting operation from Section 3.2.7. We haveused the standard encoding of mutual recursion into nested recursion, and it is

compatible with our extension of F!bas the following type assignment for mapNfin Figure 7.1 shows.

Bounded and well-founded recursion can be combined into bounded well-founded recursion.

TY-BD-WF-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord\Gamma  ` fixr

n : (8i <= a. (8j <= i. A j) ! A (i + 1)) ! A a0 a

0 2 {a, s a}

7.1. MUTUAL RECURSION 139
Mapping terms.

MapNe, MapNf : ord ffi! *
MapNe := *i. 8A8B. (A ! B) ! Nei A ! NeiB
MapNf := *i. 8A8B. (A ! B) ! Nei A ! NeiB

mapNeF : 8i. MapNf i ! MapNei ! MapNe(i + 1)
mapNeF := *mapNf *mapNe* f *t. match t with

var x 7! var ( f x)
app r s 7! app (mapNe f r) (mapNf f s)

mapNfF : 8i. MapNf i ! MapNei ! MapNf (i + 1)
mapNfF := *mapNf *mapNe* f *t. match t with

ne r 7! ne (mapNe f r)
abs r 7! abs (mapNf (lift f ) r)

mapNe : 8i. MapNei
mapNe := fixu1 *mapNe. mapNeF (fixu1 *mapNf . mapNfF mapNf mapNe) mapNe

mapNf : 8i. MapNf i
mapNf := fixu1 *mapNf . mapNfF mapNf (fixu1 *mapNe. mapNeF mapNf mapNe)

Type assignment for mapNf .

mapNf : 8j <= i. MapNf j assumption

j <= i assumptionmap

Ne : MapNf j assumptionmap
Nf : MapNf i instantiationmap

NeF mapNf mapNe : MapNe(j + 1)(fixu

0 *mapNe . . . ) : MapNei TY-BD-RECmap

Nf : MapNf i instantiationmap

NfF mapNf (. . . ) : MapNf (i + 1) TY-WF-REC

Figure 7.1: Functoriality for normal de Bruijn terms.

140 CHAPTER 7. EXTENSIONS
The presence of bounded type assumptions X <= G : ^ in \Gamma  , especially i <= a forordinals, does not jeopardize our normalization result. The induction principle behind TY-BD-WF-REC can easily justified by transfinite induction. A morenatural formulation of this rule would one using strict inequality of ordinals:

\Gamma  ` A fixrn-adm \Gamma  ` a : ord
\Gamma  ` fixrn : (8i < a. (8j < i. A j) ! A i) ! A a

But how to prove normalization in presence of strict inequality assumptionsi

< a in \Gamma  requires further thought.

Mutual Recursion Via Products. Alternatively, mutual recursion can be addedas a new principle, realized via products. This has been carried out by Pareto
[Par00, p. 152] and Xi [Xi02]. To implement mutual recursion on the construc-tor level we need product kinds.

7.2 More Admissible Types
Our criterion for types of recursive functions admits the type 8i. Nati ! Nati !
Nati, e. g., as type of the minimum or maximum function for natural numbers,but not the isomorphic type 8i.

Nati * Nati ! Nati. Using this type, the mini-mum function would be coded as follows:

min : 8i. Nati * Nati ! Nati
min := fixu0 *min*hx, yi. match hx, yi withh

zero, _i 7! zeroh_,

zeroi 7! zeroh
succ x0, succ y0i 7! succ (min hx0, y0i)

However, in our reduction semantics, min is not strongly normalizing, sincethe pair hx0, y0i counts as a value and triggers unfolding of recursion:

min hx, yi -!+ match . . . succ (min hx0, y0i)-!+

match . . . succ (match . . . succ (min hx00, y00i))-!+ . . .

The most promising solution to this problem is add patterns as a primitivelanguage construct and to tie unfolding recursion to pattern matching:

min : 8i. Nati * Nati ! Nati
min := fixu0 *min* 0@ h

zero, _i 7! zeroh_,

zeroi 7! zeroh
succ x0, succ y0i 7! succ (min hx0, y0i) 1A

The reduction semantics has to be adapted such that min hx, yi is no longera redex, only

min hzero, yi and min hx, zeroi, which both reduce to zero, and
min hsucc x0, succ y0i, which reduces to succ (min hx0, y0i) in one step.

7.2. MORE ADMISSIBLE TYPES 141

Since products of the form A * A are isomorphic to Bool ! A, one couldimagine a type system which also accept the following, a little artificial, variant
of the minimum function:

min : 8i. (Bool ! Nati) ! Nati
min := fixu0 *min* f . match h f true, f falsei withh

zero, _i 7! zeroh_,

zeroi 7! zeroh
succ x0, succ y0i 7! succ (min (*b. if b then x0 else y0))

Since a *-abstraction is a value, this definition of min is not strongly normaliz-ing for similar reasons as the first definition with products. However, in this
case, it seems impossible to salvage strong normalization. But if one is onlyinterested in the termination of closed programs, this definition is fine, and
indeed, the type system of Hughes, Pareto, and Sabry [HPS96] accepts it.

142 CHAPTER 7. EXTENSIONS
Chapter 8
Conclusion
In this thesis, I have presented a simple but powerful type system which certi-fies termination and productivity for higher-order functional programs with
higher-rank polymorphism and higher-order and heterogeneous data typesthat can contain both infinitely deep and infinitely branching trees. Its practical applicability has been demonstrated by numerous non-trivial examples.It has been shown that the marriage of types with termination analysis can effortlessly treat the case of higher-order functional programs which are hard fortermination analyses based on term orderings. The types paradigm has again
proven an effective tool to structure program analysis.

Some problems have been left open in this thesis. For one thing, more workhas to be done on models of

F!b. The current model proves strong normaliza-tion, but it does not give much information about the impredicative encodings

of disjoint sum and product. It would be desirable to have a model where theimpredicative encodings have semi-continuity properties, but it is unclear to
me whether this can be achieved.1

Also, the types-as-sets-of-evaluation-contexts model needs refinement. Onewould like that t ? T

i2I Ei implies t ? Ei for some i 2 I, if the Ei are sets ofevaluation contexts with certain closure properties and form a sequence of a

certain form, e.g., a chain or a directed sequence. With that property, one couldprove semi-continuity properties for the refined saturation model which was

necessary for equi-coinductive types. Again, this is future research.

Finally, I am looking for a model of type-based termination and produc-tivity that is simpler than the ones known to me: (1) types as sets of strongly

normalizing terms (this thesis, Barthe et al. [BFG+04], Blanqui [Bla04]) and (2)types as upward closed subsets of a domain with ?-element (Pareto [HPS96,
Par00]). It seems funny that in order to reason about terminating and produc-tive functional programs, which never produce an undefined result, one either
has to generalize evaluation to symbolic computation and speak about strong

1Christine Paulin-Mohring has told me that the impredicative encodings are not adequate--
they contain junk.

143

144 CHAPTER 8. CONCLUSION
normalization, or one has to add a ?-element and show that it is never a re-sult of a well-typed program. A promising direction is Xi`s work [Xi02] which
gives a much simpler call-by-value semantics. However, he cannot handle in-finite objects like streams. Maybe coinductive types can be modeled as sets of
evaluation contexts, as in this thesis, but on the basis of a simpler operationalsemantics, e. g., a big-step call-by-name semantics for closed programs.

8.1 Related Work
There is an abundant literature on termination. We will only consider a fewrecent publications. We divide them into two categories: papers which deal
with fully automated termination checking, and those which presents methodshow to (partially) automate termination proofs.

8.1.1 Termination Proofs
A very general method to define function is by well-founded recursion. Nord-stro"m has demonstrated its use in Martin-Lo"f Type Theory [Nor88]. In the

Calculus of Inductive Constructions, this recursion scheme is an instance ofprimitive recursion over the accessibility predicate, which is the constructive
version of well-foundedness and can be defined as an infinitely-branching in-ductive data type. Balaa and Bertot [BB00] demonstrate how to recover the
fixed-point equation from well-founded recursion in Coq.

From a recursive function definition, an induction scheme can be extracted[Wal92, Hut92]. Each function clause corresponds to one case, and each recursive call in this clause to one induction hypothesis available in this case.One way to prove termination of the function is to first establish the induction
scheme and use it to show termination. The second part can often be fullymechanized. In the following, we describe some works which follow roughly
this technique.

In Higher-Order Logic, as implemented in the Isabelle [Pau90] interactivetheorem prover, a fixed-point combinator WFREC for well-founded recursion

is definable. Slind [Sli96] wrote the TFL package which translates recursivefunctions defined by pattern matching into WFREC-expressions, and extracts
termination conditions as proof obligations. Special tactics attempt to dis-charge these obligations with the help of a user-supplied measure. This approach is very flexible and works quite well in practice. Unfortunately, it can-not be used to construct proofs by induction, since derivations are not first class
objects in HOL and cannot be manipulated by functions (the Curry-Howardisomorphism breaks down).

A similar mechanism is implemented in PVS [ORS92]. With a recursivedefinition the user has to supply a termination measure and prove the arising
termination conditions. PVS has powerful proof automation, hence, discharg-ing the conditions causes in most cases not much trouble.

8.1. RELATED WORK 145

Bove and Capretta [BC05a] take a recursive definition and generate its in-ductive domain predicate such that the induction scheme associated to this
predicate corresponds to the above describe induction scheme associated withthe recursive function. The recursive definition is translated into Type Theory
as a partial function which is well-defined on the inductive domain. To showthat a function is total one has to prove that all values inhabit the inductive
domain. Recently Bove and Capretta have extended their approach to higher-order domains [BC05b].

Bertot [Ber05] uses domain predicates to define corecursive stream filter-ing functions. He requires the selection predicate to hold infinitely often on
the input streams to obtain productive output streams. Since "infinitely often"means at each point "eventually" and he uses an inductive definition of "eventually", he can define the filtering function using recursion inside corecursion.With his technique he manages to define the Sieve of Eratosthenes by corecursion in Coq. Mixed recursion/corecursion is also possible in F!b (see Huffmandecoding example, Section 3.2.4), but to see that the Sieve of Eratosthenes is
productive requires mathematical knowledge, which is beyond our system.

Ultrametric spaces and Banach's fixed-point theorem. Buchholz [Buc05] in-vestigates recursive and corecursive definitions as fixed-points of functionals
on ultrametric spaces. For instance, streams of natural numbers S form an ul-trametric space with the equivalence relations ss

n` S * S for n 2 N definedby

s ss0 s0 () trues ss

n+1 s0 () hd s = hd s0 and tl s ssn tl s0.

Banach's fixed-point theorem guarantees such definitions to be well-defined ifthe underlying functional is contractive. Buchholz turns this principle into a

system for "type-based termination" by decorating function arrows with mod-uli

OE : N ! N. The modulus of a function expresses how well its argumentsmust be related for its results to be related, or more precisely,

f 2 A OE! B () 8l 2 N8a, a0 2 A. a ssOE(l) a0 =) f a ssl f a0 2 B.
Then, the tail function tl can be given type S +1! S and stream construction
cons : N ! S -1! S. In terms of Buchholz' systems, F!b is restricted to moduliof the form +-k and uses a fixed ultrametric arising from the approximation

of (co)inductive fixed points. I think Buchholz can simulate the simply-typedstrictly-positive fragment of

F!b, but I am not sure whether he can define recur-sive functions over inductive datatypes with a closure ordinal

> !.A conceptual difference between rewriting in
F!b and Buchholz' system isthat in
F!b, fixed points are unrolled on demand, whereas in Buchholz' systema term is given an amount of "fuel" and each fixed-point unrolling costs one

unit. The amount of initial fuel depends on the modulus of the term and onhow precise the result of the term should be approximated.

146 CHAPTER 8. CONCLUSION

Buchholz does not treat polymorphism.
Gianantonio and Miculan [GM03] generalize ultrametric spaces further toordered families of equivalences (OFE). Basically, there is a collection of equivalence relations j indexed by any well-ordered set (in Buchholz' case, this wasalways N). Otherwise, their method is very similar to Buchholz'. Their main
selling point is that they can treat mixed recursive/corecursive definitions;as the Huffman-decoder examples of Huffman decoding and prime numbers
show (see sections 3.2.4 and 3.2.5), this is also possible in F!b.

Finally, Matthews [Mat99] has explored the use of converging equivalencerelations (CERs), which are a variant of OFEs to define corecursive objects in

Isabelle. His results are similar to Gianantonio and Miculan's.

8.1.2 Termination Checking
Size-change principle. Lee, Jones, and Ben-Amram [LJBA01] have coined theterm size-change principle for termination: A program terminates on all inputs if
every infinite call sequence . . . would cause an infinite descent in some data values.Checking size-change termination is in general PSPACE-complete, but with
some restrictions it becomes polynomial [Lee02].

Jones and Bohr [JB04] apply size-change termination to closed lambda-termsunder deterministic call-by-value evaluation. One lambda-expression calls another if the evaluation of the first depends on the evaluation of the second. Us-ing an operational semantics with environments (explicit substitutions), they
maintain the invariant that the set of subexpressions is not increased underevaluation and call. Since the initial lambda-expression has only a finite number of subexpressions, a call graph can be constructed on these using abstractinterpretation. Sereni [Ser04], also with Jones [SJ05], refines the abstract interpretation and refutes the conjecture that the size-change principle certifiestermination for all simply-typed closed lambda-terms [Ser05]. This suggests
that (simple) typing and size-change are complementary principles.

The size-change termination analysis for closed lambda-expressions cannotdirectly be extended to open expressions since it hinges on the subexpressionproperty, which fails for open expressions: Let n denote the nth Church nu-meral. Then n (m f ) x has O(n + m) subexpressions, but its evaluation, f nm x,
has O(nm) subexpressions.

In own work with Altenkirch [AA02], simple typing has been combinedwith a termination criterion based on call graphs which likens the one of Jones

et al.In essence, it does not accept functions which swap their parameters in re-cursive calls, otherwise, it is isomorphic to Jones et al.. The tool

foetus [Abe98]detects lexicographic termination orderings for simply-typed functional programs and inductive types.

Wahlstedt [Wah04] combines size-change termination with dependent typesand first-order inductive datatypes. His normalization proof uses a reducibility semantics and Ramsey's theorem.

8.1. RELATED WORK 147
Abstract interpretation and types. Telford and Turner [TT00, TT97] checktermination and productivity of recursive functions by an abstract interpretation. They track size-change on an abstract domain and can handle first-orderfunctional programs quite well. However, type-based termination seems the
more promising approach, since then type analysis and size analysis are inte-grated into one language and can benefit from each other.

Amadio and Coupet-Grimal [ACG98] extend the simply-typed *-calculusby non-nested coinductive types and describe a type system for well-defined
corecursion via a fixed-point combinator. The typing rule for fixed-points ismotivated by transfinite induction, but no closure ordinal is provided. Soundness of the system is proven through a model of partial equivalence relations(PER). The PER model validates an equality consisting of

fi, j, and fixed-pointunfolding axioms, plus a uniqueness theorem for fixed points. They also give

confluent fi and fixed-point reduction rules, whose termination is shown via amodel of reducibility candidates. Their system subsumes Coquand's guard
condition [Coq93], but since it does not have size polymorphism, it is outmatched by Barthe et al. [BFG+04] and my system *fixu* [Abe03], which inturn are both subsumed by this thesis.

McBride, the principal implementor of Epigram [MM04] seems to followthe slogan every total program is structurally recursive, i. e., he tries to unveil hidden structures and defuse functional programs to arrive at components whichare all primitive recursive. For instance, as already noted by Turner [Tur95],
quick-sort is just a deforested version of tree-sort. Altenkirch, McBride, andMcKinna [AMM05] defuse also merge-sort by introducing some kind of balanced tree as intermediate structure. Sized types, as presented in this thesis,can elegantly capture structural recursion, but can do more than that. By expressing size relations between input and output of functions, e. g., for thesubtraction function, recursive functions such as Euclidean division that are
not structurally recursive in the strict sense are acceptable as strongly nor-malizing by the type system. While it may be a intellectually satisfying and
understanding-heightening enterprise to exhibit deeper mathematical struc-tures in generally recursive programs and turn them into primitive recursive
ones, it is certainly desirable to have a type system that accepts as many termi-nating recursive programs as possible.

Altenkirch has suggested to me to represent type-based termination withindependent type theory, since sized types are in some sense "poor mans dependent types". However, this would require the implementation of ordinalnotation systems in type theory [CHS97], a non-trivial task. It seems impossible to implement the ordinal 1 of F!b in type theory, since it serves a the closureordinal of all inductive definitions of the theory, hence, it should be inaccessible
within the theory.

148 CHAPTER 8. CONCLUSION
8.1.3 Sized Types
The work of Hughes, Pareto and Sabry [HPS96] and Pareto's thesis [Par00], aswell as the work of Gime'nez [Gim98], Frade [Fra03], and Barthe et al. [BFG+04],

which are closest to this thesis, have already been related to our approach (e. g.,see Section 1.5).

Barthe, Gregoire, and Pastawski [BGP05] have extended System F a` la Churchwith sized inductive inductive types, arriving at System

Fb. It is roughly theChurch-version of
*b with quantification over types. For this system they haveimplemented a type inference algorithm with computes and generalizes size

constraints, and proven its soundness and completeness. Introducing dummyabstractions and applications to model type abstraction and application,

Fbcan be embedded into our calculus
F!b, which is in Curry-style, in a reductionpreserving way. Data types in
F!b can be contravariant, interleaved, heteroge-neous, and coinductive, which is not possible for data types in

Fb.
Blanqui [Bla04, Bla05] decorates the inductive types of his Calculus of Al-gebraic Constructions, which is an extension of the Calculus of Inductive Constructions underlying Coq [BC04], with sizes of the same expressiveness as in
F!b and *b . He proves that reduction rules which adhere to the type-basedtermination criterion are strongly normalizing and presents a constraint-based

algorithm for checking sized types. His system is quite powerful, featuring de-pendent types and reduction rules that go beyond computation (

fi). However,our system is not subsumed since he does not feature size polymorphism or,

since his positivity condition on data types is syntactical and not kind-based asin our approach, interesting heterogeneous data types.

Chin and Khoo [CK01], also with Xu [CKX01], extend the approach ofHughes, Pareto, and Sabry on sized types. They describe an algorithm how
to infer lower and upper size bounds for a strict functional language with al-gebraic data types. Sizes are constrained by Presburger arithmetic formulas.
They do not treat sizes > ! that arise for data types with embedded functionspaces.

Zenger [Zen98], introduces indexed types, which are a shallow form of de-pendent types, in the sense that they can express data invariants over decidable
constraint domains, but cannot type more programs than a non-dependent lan-guage like Haskell. Zenger's approach is similar to the one by Chin and Khoo.
He cannot certify termination with his type system.

Portillo, Hammond, Loidl, and Vasconcelos [PHLV02] describe a cost infer-ence algorithm for higher-order and polymorphic, but non-recursive functional

programs. To estimated computation costs, they also need sized types. Theytreat the special case of sized natural numbers and sized lists, but their size
language is more expressive than ours, featuring sum, difference, product, andmaximum. Polymorphic combinators such as folds are problematic in their approach because all size information is lost. They could benefit from our ideato make size expressions first-class citizens in the type language, then list folds
could be assigned a more precise type (see Section 1.5). Their approach hasbeen extended to recursive functions by Vasconcelos and Hammond [VH04].

8.1. RELATED WORK 149
Rich size languages. Crary and Weirich [CW99] present a intermediate lan-guage, LX, for a typed compiler with a rich constructor level: Constructors
form a strongly normalizing purely functional language on their own, withdata structures and primitive recursion. Consequently, besides function kinds,
they have product, sum, and inductive kinds, with a natural number kind asa special case. Data structures on the level of programs can be connected to
their abstraction on the level of constructors, since recursive types can be pa-rameterized by shapes, which are elements of inductive kinds. For example,
a type of trees parameterized by a perfectly balanced constructor-level tree ofsize n contains only perfectly balanced object-level trees of size n. This way,
structure invariants of data types can be represented in LX. To certify execu-tion time bounds, the type system of LX is extended by a virtual clock [CW00].
The new language, LXres, can determine primitive-recursive execution costs,which are represented as constructors of kind

Nat. To specify cost-functions,Crary and Weirich use a variant of Mendler-style primitive recursion (see Section 4.4) on the constructor level. It is not unthinkable to transfer our approachto terminating recursion to the constructor level of LXres. Our whole development would then occur one level higher; we would require sized inductivekinds, subkinding, and a sort of ordinals, sort then being the fourth syntactic
level (objects, constructors, kinds, sorts).Hongwei Xi [Xi02] presents a framework for type-based termination within
DML, recently extended to ATS, which are a form of dependently typed pro-gramming languages, only that the program and type level expressions are
syntactically separated (as in LX), but put into relation through singleton types.His sizes for types can be exact (as opposed to our system, where they are
only upper bounds), and he allows termination on measures which are lexico-graphic products of natural numbers. He can treat many practical first- and
higher-order functional programs. However, infinitely branching trees andcoinductive structures are not covered by his approach.

150 CHAPTER 8. CONCLUSION
Appendix A
Summary of F!b
In the following, we summarize the syntactic rules of F!b.
A.1 Kinds and Constructors
Polarities. Order given by ffi <= p and p <= p.

p ::= + covariant| - contravariant

| ffi non-variant

Kinds. Pure kinds ^* do not mention ord.

^ ::= * types|

ord ordinals| p

^1 ! ^2 co-/contra-/non-variant constructor transformers

Constructors are given by the following Curry-style type-level lambda-calculuswith some constants.

a, b, A, B, F, G ::= C | X | *XF | F G
Signature. The constructor constants C are taken from a fixed signature \Sigma which contains at least the following constants together with their kinding.

! : * -! * +! * function space8

^ : (^ ffi! *) +! * quantification
u^* : ord +! (^* +! ^*) +! ^* inductive constructors

*^* : ord -! (^* +! ^*) +! ^* coinductive constructors

s : ord +! ord successor of ordinal1 :

ord infinity ordinal

151

152 APPENDIX A. SUMMARY OF F!b
Polarized contexts.

\Delta  ::= \Pi  | \Delta , X : p^

Operations on polarities and contexts. Negation of a polarity -p is given bythe three equations -(+) = -, -(-) = + and -(ffi) = ffi. We define inverse
application p-1\Delta  of a polarity p to a polarized context \Delta .

+-1\Delta  = \Delta 
--1(\Pi ) = \Pi --1(

\Delta , X : p^) = --1\Delta , X : (-p)^

ffi-1(\Pi ) = \Pi ffi-1(

\Delta , X : ffi^) = ffi-1\Delta , X : ffi^ffi-1(
\Delta , X : +^) = ffi-1\Delta ffi-1(
\Delta , X : -^) = ffi-1\Delta 

Kinding. \Delta  ` F : ^

KIND-C C :^ 2 \Sigma \Delta  ` C : ^ KIND-VAR X : p^ 2 \Delta  p <= +\Delta  ` X : ^

KIND-ABS \Delta , X : p^ ` F : ^0\Delta  ` *XF : p^ ! ^0 KIND-APP \Delta  ` F : p^ ! ^0 p-

1\Delta  ` G : ^

\Delta  ` F G : ^0

Constructor equality. Computation axioms.

EQ-fi \Delta , X : p^ ` F : ^0 p-

1\Delta  ` G : ^

\Delta  ` (*XF) G = [G/X]F : ^0

EQ-j \Delta  ` F : p^ ! ^0\Delta  ` (*X. F X) = F : p^ ! ^0

EQ-1 \Delta  ` s 1 = 1 : ord
Congruences.

EQ-C C :^ 2 \Sigma \Delta  ` C = C : ^ EQ-VAR X : p^ 2 \Delta  p <= +\Delta  ` X = X : ^

EQ-APP \Delta  ` F = F0 : p^ ! ^0 p-

1\Delta  ` G = G0 : ^

\Delta  ` F G = F0 G0 : ^0

EQ-* \Delta , X : p^ ` F = F0 : ^0\Delta  ` *XF = *XF0 : p^ ! ^0

A.2. TERMS, TYPING AND REDUCTION 153
Symmetry and transitivity.

EQ-SYM \Delta  ` F = F0 : ^\Delta  ` F0 = F : ^
EQ-TRANS \Delta  ` F1 = F2 : ^ \Delta  ` F2 = F3 : ^\Delta  ` F1 = F3 : ^

Declarative Higher-Order Subtyping. Reflexivity, transitivity, antisymme-try.

LEQ-REFL \Delta  ` F = F0 : ^\Delta  ` F <= F0 : ^
LEQ-TRANS \Delta  ` F1 <= F2 : ^ \Delta  ` F2 <= F3 : ^\Delta  ` F1 <= F3 : ^
LEQ-ANTISYM \Delta  ` F <= F0 : ^ \Delta  ` F0 <= F : ^\Delta  ` F = F0 : ^
Abstraction and application.

LEQ-* \Delta , X : p^ ` F <= F0 : ^0\Delta  ` *XF <= *XF0 : p^ ! ^0

LEQ-APP \Delta  ` F <= F0 : p^ ! ^0 p-

1\Delta  ` G : ^

\Delta  ` F G <= F0 G : ^0

LEQ-APP+ \Delta  ` F : +^ ! ^0 \Delta  ` G <= G0 : ^\Delta  ` F G <= F G0 : ^0

LEQ-APP- \Delta  ` F : -^ ! ^0 --

1\Delta  ` G0 <= G : ^

\Delta  ` F G <= F G0 : ^0

Successor and infinity.

LEQ-S-R \Delta  ` a : ord\Delta  ` a <= s a : ord LEQ-1 \Delta  ` a : ord\Delta  ` a <= 1 : ord

A.2 Terms, Typing and Reduction
Terms.

r, s, t ::= x | *xt | r s | fixun | fix*n

154 APPENDIX A. SUMMARY OF F!b
A.2.1 Static Semantics
Typing contexts.

\Gamma  ::= \Pi  | \Gamma  , x : A | \Gamma  , X : p^

Wellformed contexts.

CXT-EMPTY \Pi  cxt CXT-TYVAR \Gamma  cxt\Gamma  , X : ffi^ cxt CXT-VAR \Gamma  cxt \Gamma  ` A : *\Gamma  , x : A cxt

Typing. \Gamma  ` t : ALambda-calculus.

TY-VAR (x : A) 2 \Gamma  \Gamma  cxt\Gamma  ` x : A TY-ABS \Gamma  , x : A ` t : B\Gamma  ` *xt : A ! B

TY-APP \Gamma  ` r : A ! B \Gamma  ` s : A\Gamma  ` r s : B
Quantification.

TY-GEN \Gamma  , X :^ ` t : F X\Gamma  ` t : 8

^ F X 62 FV(F) TY-INST

\Gamma  ` t : 8^ F \Gamma  ` G : ^

\Gamma  ` t : F G

Subsumption.

TY-SUB \Gamma  ` t : A \Gamma  ` A <= B : *\Gamma  ` t : B

Folding and unfolding for (co)inductive types (r 2 {u, *}).

TY-FOLD \Gamma  ` t : F (r^ a F) ~G\Gamma  ` t : r

^ (a + 1) F ~G

TY-UNFOLD \Gamma  ` r : r^ (a + 1) F ~G\Gamma  ` r : F (r

^ a F) ~G

Recursion (r = u) and corecursion (r = *).

TY-REC \Gamma  ` A fixrn-adm \Gamma  ` a : ord\Gamma  ` fixr

n : (8i : ord. A i ! A (i + 1)) ! A a

A.2.2 Admissible Recursion Types
Notation for size index. We sometimes write the size index superscript, e. g.,
ui instead of u i, or *i instead of * i.

Natural transformations. For constructors ~F, G : ~p~^ ! *, let

~F ) G :() 8~X :~^. F1 ~X ! . . . Fn ~X ! G ~X.

Also, we abbreviate *~X. F(H1 ~X) . . . (Hn ~X) by F ffi ~H.

A.3. SEMI-CONTINUOUS TYPES FOR RECURSION 155
Admissible types for recursion and corecursion.

\Gamma  ` A fixun-adm :() \Gamma  , i : ord ` A i = (~G, uiF ffi ~H ) G) : * (i 62 FV(A))

for some F, G, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : +ord ` G : ^0 for some ^0 = ffi~^0 ! *,
\Gamma  , ' : -ord ` Gi : ^0 for 1 <= i <= n, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

\Gamma  ` A fix*n-adm :() \Gamma  , i : ord ` A i = (~G ) *iF ffi ~H) : * (i 62 FV(A))

for some F, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : -ord ` Gi : ^0 (all i) for some ^0 = ffi~^0 ! *, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

A.2.3 Dynamic Semantics
(Lazy) Values.

Val 3 v ::= *xt|

fixrn ~t where |~t| <= n + 1

Evaluation frames.

e(_) ::= _ s | fixun s t1..n _

Reduction. t -! t0

(*xt) s -!fi [s/x]t
fixun s t1..n v -!fi s (fixun s) t1..n v if v 6= fix*n0 s0 t1..n0

e(fix*n s t1..n) -!fi e(s (fix*n s) t1..n) if e 6= fixun0 s0 t1..n0 _

plus congruences for all term constructors.

A.3 Semi-Continuous Types for Recursion
Positive contexts.

Cxt+ 3 \Pi  ::= \Pi  | \Pi , X : +^*

156 APPENDIX A. SUMMARY OF F!b
Derivation system for semi-continuity. \Delta ; \Pi  `iq F : ^ for q 2 {\Phi , \Psi }Converting ordinary derivations.

CONT-IN \Delta  ` F : ^\Delta , i : pord; \Pi  `iq F : ^ CONT-CO \Delta , i : +ord ` F : ^ p <= +\Delta , i : pord; \Pi  `i\Phi  F : ^

CONT-CONTRA \Delta , i : -ord ` F : ^ p <= -\Delta , i : pord; \Pi  `i\Psi  F : ^
*-calculus part.

CONT-VAR X : p^ 2 \Delta , \Pi  p <= +\Delta ; \Pi  `iq X : ^

CONT-ABS \Delta , X : p^; \Pi  `

iq F : ^0

\Delta ; \Pi  `iq *XF : p^ ! ^0 X 6= i

CONT-APP \Delta , i : p0ord; \Pi  `

iq F : p^ ! ^0 p-1\Delta  ` G : ^

\Delta , i : p0ord; \Pi  `iq F G : ^0

Built-in constructors:

CONT-SUM \Delta ; \Pi  `

iq A, B : *

\Delta ; \Pi  `iq A + B : * CONT-PROD

\Delta ; \Pi  `iq A, B : *
\Delta ; \Pi  `iq A * B : *

CONT-ARR -\Delta ; \Pi  `

i\Psi  A : * \Delta ; \Pi  `i\Phi  B : *

\Delta ; \Pi  `i\Phi  A ! B : *

CONT-8 \Delta ; \Pi  `

i\Phi  F : ffi^ ! *

\Delta ; \Pi  `i\Phi  8^ F : *

CONT-MU \Delta ; \Pi , X : +^* `

i\Psi  F : ^* \Delta  `i\Psi  a : ord

\Delta ; \Pi  `i\Psi  uaXF : ^*

CONT-NU \Delta ; \Pi , X : +^* `

i\Phi  F : ^* \Delta  ` a ord

\Delta ; \Pi  `i\Phi  *aXF : ^*

Improved criterion for admissible types.

\Gamma  ` A fixun-adm iff \Gamma  , i : ffiord ` A i = (G1..n, uiF ffi ~H ) G) : *

and \Gamma  , i : ffiord; \Pi  `i\Phi  G1..n, uiF ffi ~H ) G : *

\Gamma  ` A fix*n-adm iff \Gamma  , i : ffiord ` A i = (G1..n ) *iF ffi ~H) : *

and \Gamma  , i : ffiord; \Pi  `i\Phi  G1..n ) *iF ffi ~H : *

Appendix B
Iso-Coinductive Constructors
In this section, we present a variant of F!b which still has equi-inductive con-structors, but iso-coinductive constructors, i. e., folding and unfolding coinductive types is no longer silent on the term level. It is clear that the iso-version of asystem is strongly normalizing if the equi-version is (see Section 4.1). However,
the normalization proof is easier: it can be carried out with the original, moreconstructive definition of saturated term sets. The main advantage is that saturated sets in the original sense are closed under unions. Of course, now thesymmetry between induction and coinduction is somewhat broken. But this
has also an advantage: The pathological neutral terms, recursive functions ap-plied to corecursive values, disappear. Now, every neutral term is bound to
have a free variable, so no closed term will get stuck.In the following, we summarize the changes to system definition and soundness proof.

B.1 Syntax
Terms. We extend the language of terms by two new constants:

Const 3 c ::= in* codata constructor|

out* codata destructor

Typing. The folding and unfolding rules are replaced by the following:

TY-FOLDu \Gamma  ` t : F (u^ a F) ~G\Gamma  ` t : u

^ (a + 1) F ~G

TY-UNFOLDu \Gamma  ` r : u^ (a + 1) F ~G\Gamma  ` r : F (u

^ a F) ~G

TY-FOLD* \Gamma  ` t : F (*^ a F) ~G\Gamma  ` in* t : *

^ (a + 1) F ~G

TY-UNFOLD* \Gamma  ` r : *^ (a + 1) F ~G\Gamma  ` out* r : F (*

^ a F) ~G

The rules for *-terms, quantification, subsumption, recursion and corecursionstay in place.

157

158 APPENDIX B. ISO-COINDUCTIVE CONSTRUCTORS
Example B.1 (Repeat function, revisited) In the new system, the body of repeatis wrapped into a codata constructor.

repeat a := fix*0 *repeat. in* (pair a repeat)
*a. repeat a : 8A. A ! Stream1 A

Evaluation frames. The codata destructor is a new atomic evaluation context:

Eframe 3 e ::= _ s application|

fixun s t1..n _ recursive function call|
out* _ codata destruction

Evaluation context are compositions of evaluation frames, as before.

Values. The new constants give rise to new values. As before, each under-applied constant is a value, but also codata construction

in* t.

Val 3 v ::= *xt|

fixrn|
fixrn s~t where 0 <= |~t| <= n|
out* | in* | in* t

Reduction. Corecursive functions are only unrolled under a codata destruc-tor. We get the following contractions:

RED-fi (*xt) s ae [s/x]t
RED-REC fixun s t1..n v ae s (fixun s) t1..n v
RED-COREC out* (fix*n s t1..n) ae out* (s (fix*n s) t1..n)
RED-fi* out* (in* r) ae r

By requiring explicit folding and unfolding for codata, we have syntacticallyremoved the critical application of recursive functions to corecursive values.

The term fixun s t1..n (fix*n0 s0 t1..n0 ) now has only one sensible reduction: unrollingrecursion; corecursion requires a destructor to be unrolled.

Example B.2 (Reduction for repeat) The codata destructor triggers one unrollingand then vanishes with the freshly created codata constructor.

out* (repeat a) -! out* ((*repeat. in* (pair a repeat)) (repeat a))-!

out* (in* (pair a (repeat a))-!
pair a (repeat a)

B.2 Soundness
Safe evaluation contexts. Codata destruction is an additional safe evaluationcontext.

SF-OUT out* _ 2 Sframe

B.2. SOUNDNESS 159
Safe weak head reduction now also accounts for fi*-contractions.

REQ-fi (*xt) s B [s/x]t if s 2 S
REQ-REC fixun s t1..n v B s (fixun s) t1..n v
REQ-COREC out* (fix*n s t1..n) B out* (s (fix*n s) t1..n)
REQ-fi* out* (in* r) B r

REQ-ECXT E(t) B E(t0) if t B t0
REQ-TRANS B is transitive
The requirement

REQ-FIXu FIX* fixun s t1..n (fix*n0 s0 t01..n0 ) 2 N if s,~t, s0,~t0 2 S
can be dropped, since REQ-REC now covers also the application of a recursivefunction to a corecursive value.

We still require

REQ-FIX* fix*n 2 Sn+1 ! S.

Saturated sets. We revert to our old definition: A set A is saturated, A 2 SAT,if N ` A ` S and A is closed under B-reduction and -expansion.

Lemma B.3 If A is saturated, then also A0 := {r | out* r 2 A}.
Proof. To show N ` A0, we require out*(N ) ` A. Since N ` A, by assump-tion, we conclude with

REQ-STRICT. The next goal, A0 ` S follows from thenew requirement

REQ-OUT* out* r 2 S implies r 2 S.
Finally, we need to show that A0 is closed under B-reduction and -expansion.This property is inherited from A by

REQ-ECXT. \Lambda 

Lattice of saturated sets. SAT forms a complete lattice under the set-theoreticintersection and union. That we now have sup

A = S A = S A for A ` SAT, isthe main gain of this development.

Lemma B.4 Let A ` SAT. Then T A 2 SAT and S A 2 SAT.
Proof. If A is empty, then T A = S and S A = N . Otherwise, let t 2 S A.Then there exists some A 2

A such that t 2 A. Now if t B t0 or t C t0, thent0 2 A ` S
A, hence, S A is closed. If t 2 T A then t 2 A for all A 2 A. Sinceall A are closed, each B-reduction or -expansion t0 of t is in every A, hence,

also in T A. \Lambda 

160 APPENDIX B. ISO-COINDUCTIVE CONSTRUCTORS
Semantics of u and *. Let ^ = ~p~^ ! * and | ~H| = |~^|.

out-1*^ : ([[^]] +! [[^]]) +! [[^]] +! [[^]]
out-1*^ (F )(G)( ~H) := {r | out* r 2 F (G)( ~H)}

Sem(u^)(ff)(F ) := Fff(?^)
Sem(*^)(ff)(F ) := (out-1*^ (F ))ff(?^).

Since [[*]] = SAT, we have [[*^]] = Sem(*^) 2 [[ord]] -! ([[^]] +! [[^]]) +! [[^]],hence, the semantics of coinductive types is sound.

Lemma B.5 (Soundness of codata construction) Let A 2 SAT. If t 2 A then
in* t 2 {r | out* r 2 A}.

Proof. out* (in* t) B t, and A is closed under B-expansion. \Lambda 

Lemma B.6 (Soundness of (un)folding for coinductive constructors) Let ^ =
~p~^ ! *, Hi 2 [[^i]] F 2 [[^]] +! [[^]], and ff 2 [[ord]]. We set

A := F ([[*^]] ff F )( ~H) (unfolded)B

:= ([[*^]]([[s]]ff) F )( ~H) (folded)

Then in*(A) ` B and out*(B) ` A.
Proof. If ff < ?ord, then

B = out-1*^ (F )([[*^]]ff F )( ~H),
which means that t 2 B () out* t 2 A. With Lemma B.5, our claim follows.In case

ff = ?ord the equation for B is still valid, since the fixed point is reachedat the closure ordinal. \Lambda 

The soundness of rules TY-FOLD* and TY-UNFOLD* is a consequence of thistheorem.

Admissible semantic types for corecursion. We need to prove soundness ofcorecursion again, now for our old definition of

SAT. The reasoning power wehave lost by reverting to the old definition of
SAT is compensated by a newrequirement
ADM-*-STEP.The semantic type family A 2

O ! SAT is admissible for corecursion with narguments if the following four conditions are met:

ADM-*-SHAPE A(ff) = Tk2K(B1..n(k, ff) ! C(k, ff))for some index set K and B

1..n, C 2 K * O ! SAT,
ADM-*-START S ` C(k, 0) for all k 2 K,

ADM-*-STEP t0 2 C(k, ff + 1) and out* t B out* t0 imply t 2 C(k, ff + 1),
ADM-*-LIMIT infff<* A(ff) ` A(*) for all limits 0 6= * 2 O.

B.2. SOUNDNESS 161
Lemma B.7 (Corecursion is a function) Let A 2 O ! SAT be admissible forcorecursion with n arguments. If s 2 A(

ff) ! A(ff + 1) for all ff + 1 2 O, then
fix*n s 2 A(fi) for all fi 2 O.

Proof. By transfinite induction on fi 2 O. The new proof differs from the oldone in the step case.

The limit case is a direct consequence of ADM-*-LIMIT.For the remaining cases, using

ADM-*-SHAPE, assume k 2 K, ti 2 Bi(k, fi)for 1 <= i <= n and show v :=
fix*n s~t 2 C(k, fi). Note that s and ti are safe,hence, v 2 S by
REQ-FIX*. Since S ` C(k, 0), we are done in case of fi = 0.For case
fi = ff + 1, we have s (fix* s) 2 A(ff + 1) by induction hypothesisand assumption, hence, s (

fix* s)~t 2 C(k, ff + 1). Since out* v B out* (s (fix* s)~t),by
ADM-*-STEP it follows that v 2 C(k, ff + 1). \Lambda 

Admissible types for corecursion, syntactically. We recapitulate the crite-rion on types for corecursion:

\Gamma  ` A fix*n-adm :() \Gamma  , i : ord ` A i = (~G ) (*iF) ffi ~H) : * (i 62 FV(A))

for some F, ~G, ~H with |~G| = n and

\Gamma  ` F : +^ ! ^ for some pure ^ = ~p~^ ! *,
\Gamma  , ' : -ord ` Gi : ^0 (all i) for some ^0 = ffi~^0 ! *, and
\Gamma  ` Hi : ffi~^0 ! ^i for 1 <= i <= |~^|.

Lemma B.8 (Soundness of admissible corecursion types) If \Gamma  ` A fix*n-admand

` 2 [[\Gamma  ]], then [[A]]` is admissible for corecursion with n arguments.

Proof. As in proof of the corresponding lemma 3.46, we set

A(ff) = [[A]]`(ff) = [[~G ) (*iF) ffi ~H]]`[i7!ff]
In the following, we verify the conditions ADM-*-SHAPE and ADM-*-STEP;

ADM-*-START and ADM-*-LIMIT are proven as before.

ADM-*-SHAPE Show A(ff) = Tk2K B1..n(k, ff) ! C(k, ff). We set

K := [[^01]] * * * * * [[^0m]] where m := |~^0|,B

i( ~X , ff) := [[Gi]]`[i7!ff] ~X for 1 <= i <= n, andF :=

out-1*^ ([[F]]`)H

i( ~X ) := [[Hi]]` ~X for 1 <= i <= |~^|C( ~X ,

ff) := (Iff F ?^)( ~H( ~X )).

ADM-*-STEP Assume t0 2 C( ~X , ff + 1) = F (Iff F ?)( ~H( ~X )) and out* t B out* t0.

By assumption, out* t0 2 [[F]]`(Iff F ?)( ~H( ~X )), and since this set is closed
by B-expansion, out* t inhabits it as well. But this means that t 2 C( ~X , ff +1), as required. \Lambda 

162 APPENDIX B. ISO-COINDUCTIVE CONSTRUCTORS
Theorem B.9 (Soundness of typing) If \Gamma  ` t : A and ` 2 [[\Gamma  ]] then LtM` 2 [[A]]`.
Proof. By induction on the typing derivation. We do the new cases. For in-ductive constructors, nothing changes;

TY-FOLDu can be handled as TY-FOLDbefore, and the same holds for unfolding. The cases for coinductive constructors are:

Case

TY-FOLD* \Gamma  ` t : F (*^ a F) ~G\Gamma  ` in* t : *

^ (a + 1) F ~G

By Lemma 3.5 we have \Gamma  ` F (*^ a F) ~G : *, which entails \Gamma  ` F : +^ ! ^and

\Gamma  ` a : ord, as well as \Gamma  ` Gi : ^i for 1 <= i <= |~^|, if we define

~p~^ ! * := ^. Hence, F := [[F]]` 2 [[^]] +! [[^]] and ff := [[a]]` 2 [[ord]] andwe can conclude by Lemma B.6.

Case

TY-UNFOLD* \Gamma  ` r : *^ (a + 1) F ~G\Gamma  ` out* r : F (*

^ a F) ~G

Analogously to case TY-FOLD*.

\Lambda 

B.3 Strong Normalization
Strong(-ly normalising) head reduction t -!SN t0 is defined inductively bythe following rules.

SHR-fi s 2 SN(*xt) s -!

SN [s/x]t SHR-FRAME

r -!SN r0
e(r) -!SN e(r0)

SHR-REC fixun s t1..n v -!

SN s (fixun s) t1..n v

SHR-COREC out* (fix*n s t1..n) -!

SN out* (s (fix*n s) t1..n)

SHR-fi* out*(in* t) -!

SN t

It is easy to see that -!SN is deterministic and closed under evaluation con-texts, hence we can set its reflexive-transitive extension -!*

SN to be B.

Strongly neutral terms r 2 SNe are defined inductively by the followingrules. The pathological case

SNE-FIXuFIX* has disappeared.

SNE-VAR x 2 SNe SNE-FRAME r 2 SNe e 2 Sframee(r) 2 SNe

B.3. STRONG NORMALIZATION 163
Strongly normalizing terms t 2 SN. The last three rules account for the newconstants.

SN-SNE r 2 SNer 2 SN SN-ABS t 2 SN*xt 2 SN SN-FIX ~t 2 SNfixr

n ~t 2 SN |

~t| <= n + 1

SN-EXP t -!SN t0 t0 2 SNt 2 SN SN-ROLL s (fix

*n s)~t 2 SN

fix*n s~t 2 SN |~t| <= n

SN-IN t 2 SNin* t 2 SN SN-IN in* 2 SN SN-OUT out* 2 SN
(We have reused the rule name SN-IN in the same sense as we have reused thename

SN-FIX.)It is clear that

SN is closed under B-expansion (rule SN-EXP) and -reduction(each head redex must have been introduced by

SN-EXP). Hence, we can setS =
SN, and REQ-S -CLOSED is fulfilled. We also see that each term in SNstrong head reduces either to a value or to a strongly neutral term. Setting

N = BSNe, the requirement REQ-S -VAL becomes true: each term t 2 S \ Nreduces to a value, t B v. Of course N ` S (

REQ-N -SUB-S) and e(N ) ` N(
REQ-STRICT) are validated immediately as well. The requirement REQ-FIX* isan instances of the rules

SN-FIX; the requirement REQ-OUT* is fulfilled by thefollowing lemma.

Lemma B.10 (REQ-OUT*) If D :: out* r 2 SN then r 2 SN.
Proof. By induction on D.

Case

SN-SNE

SNE-FRAME r 2 SNout* r 2 SN

out* r 2 SN
By assumption r 2 SN.

Case

SN-EXP out

* (fix*n s t1..n) -!sn out* (s (fix*n s) t1..n) 2 SN

out* (fix*n s t1..n) 2 SN
By induction hypothesis, s (fix*n s) t1..n 2 SN. Then by SN-ROLL, fix*n s t1..n 2
SN.

Case

SN-EXP out

* (in* t) -!sn t t 2 SN

out* (in* t) 2 SN
By SN-IN, in* t 2 SN. \Lambda 

164 APPENDIX B. ISO-COINDUCTIVE CONSTRUCTORS
Proof of REQ-FUN-SAFE N ! SN ` SN. It is sufficient to show that r x 2 SNimplies r 2

SN.
The following lemma holds in the new setting since corecursion is no longerunrolled under application.

Lemma B.11 If D :: r x -!SN t then either r = *xt or t = r0 x with r -!SN r0.
Proof. By induction on D. \Lambda 

Lemma B.12 (Extensionality) If D :: r x 2 SN or D :: r x 2 SNe then r 2 SN.
Proof. By induction on D.

Case

SNE-FRAME r 2 SNer x 2 SNe

By SN-SNE, r 2 SN.
Case Let |~t| = n.

SNE-FRAME s,~t 2 SNfixu

n s~t x 2 SNe

By SN-FIX, fixun s~t 2 SN.

Case

SN-SNE r x 2 SNer x 2 SN

By induction hypothesis.
Case

SN-FIX ~t 2 SNfixr

n ~t x 2 SN |

~t| <= n

Then fixrn ~t 2 SN by SN-FIX.
Case

SN-ROLL s (fix

*n s)~t x 2 SN

fix*n s~t x 2 SN |~t| < n
By induction hypothesis s (fix*n s)~t 2 SN, hence, fix*n s~t 2 SN by SN-ROLL.
Case

SN-ROLL x (fix

*n x) 2 SN

fix*n x 2 SN
Then fix*n 2 SN by SN-FIX.

B.3. STRONG NORMALIZATION 165

Case

SN-EXP r x -!SN t t 2 SNr x 2 SN

By Lemma B.11, we can distinguish two cases. If r = *xt, then r 2 SNby

SN-ABS. Otherwise, t = r0 x and r -!SN r0. By induction hypothesis,r0 2

SN, hence, r 2 SN by SN-EXP.

Case

SN-IN x 2 SNin* x 2 SN

By SN-IN we have in* 2 SN. \Lambda 

Corollary B.13 (REQ-FUN-SAFE) N ! SN ` SN.
Proof. {r | r s 2 SN for all s 2 N } ` {r | r x 2 SN} ` SN by the lemma. \Lambda 

Soundness for the inductive characterization, SN ` sn, can be proven asbefore.

166 APPENDIX B. ISO-COINDUCTIVE CONSTRUCTORS
Appendix C
Galois Connections
We follow Vouillon [Vou04].
Definition C.1 (Galois connection) Let (X, <=X) and (Y, <=Y) be partially or-dered sets. A pair of functions ( f , g) 2 (X ! Y) * (Y ! X) is called a Galois
connection between X and Y iff

f (x) <=Y y () x <=X g(y).

Lemma C.2 The pair ( f , g) is a Galois connection iff

1. f ffi g is contractive, g ffi f is extensive, and
2. f and g are isotone.
Proof. 1. Since g(y) <= g(y), we have f (g(y)) <= y. Likewise, x <= g( f (x))follows from f (x) <= f (x). 2. The assumption x <= x0 implies x <= g( f (x0) since

g ffi f is extensive, hence f (x) <= f (x0). Isotonicity of g is proven analogously.

For the converse direction, first assume f (x) <= y. This entails x <= g( f (x)) <=g(y). The reverse implication is equally trivial. \Lambda 

Corollary C.3

1. Both f ffi g ffi f = f and g ffi f ffi g = g.
2. f ffi g and g ffi f are idempotent.

Definition C.4 (Closure operator) A function x 7! x is a closure operator on(X, <=) if it is isotone, extensive, and idempotent.

Corollary C.5 If ( f , g) is a Galois connection between X and Y, then g ffi f is a closureoperator on X.

167

168 APPENDIX C. GALOIS CONNECTIONS
Lemma C.6 (Polarity) Let R ` X * Y be a relation and

f 2 P (X) ! P (Y)
f (A) := AR := {y 2 Y | x R y for all x 2 A}

g 2 P (Y) ! P (X)g(B)

:= BR := {x 2 X | x R y for all y 2 B}

Then ( f , g) is a Galois connection between (P (X), `) and (P (Y), '), called thepolarity.

Proof.

f (A) ' B () (8y 2 B8x 2 A. x R y)() (8x 2 A8y 2 B. x R y) () A ` g(B)

\Lambda 
Example C.7 (Orthogonality) Consider a set of safe terms S ` Tm. The or-thogonality relation ? `

Tm * Ecxt between terms and evaluation contexts isgiven by

t ? E () E(t) 2 S.
Then the function A 7! A := A?? is a closure operator on sets of terms, andfor E `

Ecxt the set of terms E ? is closed.

Bibliography
[AA00] Andreas Abel and Thorsten Altenkirch. A predicative strongnormalisation proof for a

*-calculus with interleaving inductivetypes. In T. Coquand, P. Dybjer, B. Nordstro"m, and J. Smith, editors, Types for Proof and Programs, International Workshop, TYPES'99, volume 1956 of Lecture Notes in Computer Science, pages 21-40.
Springer-Verlag, 2000.
[AA02] Andreas Abel and Thorsten Altenkirch. A predicative analysis ofstructural recursion. Journal of Functional Programming, 12(1):1-41,

January 2002.
[Abe98] Andreas Abel. foetus - termination checker for simple functionalprograms. Programming Lab Report, 1998.

[Abe99] Andreas Abel. A semantic analysis of structural recursion. Mas-ter's thesis, Ludwig-Maximilians-University Munich, 1999.
[Abe00] Andreas Abel. Specification and verification of a formal system forstructurally recursive functions. In Thierry Coquand, Peter Dybjer, Bengt Nordstro"m, and Jan Smith, editors, Types for Proof andPrograms, International Workshop, TYPES '99, volume 1956 of Lecture Notes in Computer Science, pages 1-20. Springer-Verlag, 2000.
[Abe03] Andreas Abel. Termination and guardedness checking with con-tinuous types. In M. Hofmann, editor, Typed Lambda Calculi and

Applications (TLCA 2003), Valencia, Spain, volume 2701 of LectureNotes in Computer Science, pages 1-15. Springer-Verlag, June 2003.

[Abe04] Andreas Abel. Termination checking with types. RAIRO - Theoret-ical Informatics and Applications, 38(4):277-319, 2004. Special Issue:

Fixed Points in Computer Science (FICS'03).
[Abe05] Andreas Abel. Termination and productivitychecking with continuous types--second thoughts.

http://www.tcs.ifi.lmu.de/~abel/errata-tlca03.pdf, January2005.

169

170 BIBLIOGRAPHY
[AC05] Andreas Abel and Thierry Coquand. Untyped algorithmic equal-ity for Martin-Lo"f's logical framework with surjective pairs. In

Pawel/ Urzyczyn, editor, Typed Lambda Calculi and Applications(TLCA 2005), Nara, Japan, volume 3461 of Lecture Notes in Computer
Science, pages 23-38. Springer-Verlag, April 2005.
[ACG98] Roberto M. Amadio and Solange Coupet-Grimal. Analysis of aguard condition in type theory. In Maurice Nivat, editor, Foundations of Software Science and Computation Structures, First Interna-tional Conference, FoSSaCS'98, volume 1378 of Lecture Notes in Computer Science, pages 48-62. Springer-Verlag, 1998.
[AG00] Thomas Arts and Ju"rgen Giesl. Termination of term rewriting us-ing dependency pairs. Theoretical Computer Science, 236:133-178,

2000.
[AJ05] Klaus Aehlig and Felix Joachimski. Continuous normalization forthe lambda-calculus and Go"del's T. Annals of Pure and Applied

Logic, 133:39-71, 2005.
[Alt93] Thorsten Altenkirch. Constructions, Inductive Types and Strong Nor-malization. PhD thesis, University of Edinburgh, November 1993.

[Alt99] Thorsten Altenkirch. Logical relations and inductive/coinductivetypes. In G. Gottlob, E. Grandjean, and K. Seyr, editors, Computer

Science Logic, 12th International Workshop, CSL '98, Annual Confer-ence of the EACSL, Brno, Czech Republic, August 24-28, 1998, Proceedings, Lecture Notes in Computer Science, pages 343-354. Springer-Verlag, 1999.

[Alt01] Thorsten Altenkirch. Representations of first order function typesas terminal coalgebras. In Typed Lambda Calculi and Applications,

TLCA 2001, number 2044 in Lecture Notes in Computer Science,pages 8 - 21. Springer-Verlag, 2001.

[AM03] Andreas Abel and Ralph Matthes. (Co-)iteration for higher-ordernested datatypes. In H. Geuvers and F. Wiedijk, editors, Types for

Proofs and Programs, International Workshop, TYPES 2002, volume2646 of Lecture Notes in Computer Science, pages 1-20, Berg en Dal,
The Netherlands, 2003. Springer-Verlag.
[AM04] Andreas Abel and Ralph Matthes. Fixed points of type construc-tors and primitive recursion. In Jerzy Marcinkowski and Andrzej

Tarlecki, editors, Computer Science Logic, CSL'04, volume 3210 ofLecture Notes in Computer Science, pages 190-204. Springer-Verlag,
2004.
[AMM05] Thorsten Altenkirch, Conor McBride, and James McKinna. Whydependent types matter. Manuscript, available online, April 2005.

BIBLIOGRAPHY 171
[AMU03] Andreas Abel, Ralph Matthes, and Tarmo Uustalu. Generalizediteration and coiteration for higher-order nested datatypes. In

A. Gordon, editor, Foundations of Software Science and ComputationStructures (FoSSaCS 2003), volume 2620 of Lecture Notes in Computer Science, pages 54-69, Warsaw, Poland, April 2003. Springer-Verlag.

[AMU05] Andreas Abel, Ralph Matthes, and Tarmo Uustalu. Iterationschemes for higher-order and nested datatypes. Theoretical Computer Science, 333(1-2):3-66, 2005.
[AR99] Thorsten Altenkirch and Bernhard Reus. Monadic presentations oflambda terms using generalized inductive types. In Jo"rg Flum and

Mario Rodri'guez-Artalejo, editors, Computer Science Logic, 13th In-ternational Workshop, CSL '99, 8th Annual Conference of the EACSL,
Madrid, Spain, September 20-25, 1999, Proceedings, volume 1683 ofLecture Notes in Computer Science, pages 453-468. Springer-Verlag,
1999.
[Bar99] Bruno Barras. Auto-validation d'un syse`me de preuves avec famillesinductives. PhD thesis, Universit'e Paris 7, 1999.

[BB85] Corrado Bo"hm and Alessandro Berarducci. Automatic synthesisof typed

*-programs on term algebras. Theoretical Computer Sci-ence, 39:135-154, 1985.

[BB00] Antonia Balaa and Yves Bertot. Fix-point equations for well-founded recursion in type theory. In Mark Aagaard and John Harrison, editors, Theorem Proving in Higher Order Logics, 13th Inter-national Conference, TPHOLs 2000, Portland, Oregon, USA, August
14-18, 2000, Proceedings, volume 1869 of Lecture Notes in ComputerScience, pages 1-16. Springer-Verlag, 2000.

[BC04] Yves Bertot and Pierre Caste'ran. Interactive Theorem Proving andProgram Development. Coq'Art: The Calculus of Inductive Constructions. Texts in Theoretical Computer Science. An EATCS Series.Springer-Verlag, Berlin, May 2004.

[BC05a] Ana Bove and Venanzio Capretta. Modelling general recursion intype theory. Mathematical Structures in Computer Science, 15(4):671-

708, 2005.
[BC05b] Ana Bove and Venanzio Capretta. Recursive functions with higherorder domains. In Pawel Urzyczyn, editor, Typed Lambda Calculi

and Applications (TLCA 2005), Nara, Japan, volume 3461 of LectureNotes in Computer Science, pages 116-130. Springer-Verlag, 2005.

172 BIBLIOGRAPHY
[Bee04] Michael Beeson. Lambda logic. In D. Basin and M. Rusinowitch,editors, Automated Reasoning, 2nd International Joint Conference, IJCAR 2004, volume 3097 of Lecture Notes in Artificial Intelligence,pages 440-474, Cork, Ireland, July 2004. Springer-Verlag.

[Ber05] Yves Bertot. Filters on coinductive streams, an application to er-atosthenes' sieve. In Pawel Urzyczyn, editor, Typed Lambda Calculi

and Applications (TLCA 2005), Nara, Japan, volume 3461 of LectureNotes in Computer Science, pages 102-115. Springer-Verlag, 2005.

[BFG+04] G. Barthe, M. J. Frade, E. Gime'nez, L. Pinto, and T. Uustalu. Type-based termination of recursive definitions. Mathematical Structures

in Computer Science, 14(1):1-45, 2004.
[BGJ00] Richard Bird, Jeremy Gibbons, and Geraint Jones. Program op-timisation, naturally. In Millenial Perspectives in Computer Science,

Palgrave, 2000.
[BGP05] Gilles Barthe, Benjamin Gre'goire, and Fernando Pastawski. Practi-cal inference for type-based termination in a polymorphic setting.

In Pawel Urzyczyn, editor, Typed Lambda Calculi and Applications(TLCA 2005), Nara, Japan, volume 3461 of Lecture Notes in Computer
Science, pages 71-85. Springer-Verlag, 2005.
[BJO01] Fre'de'ric Blanqui, Jean-Pierre Jouannaud, and Mitsuhiro Okada.Inductive data type systems. Theoretical Computer Science, 277,

2001.
[Bla04] Fre'de'ric Blanqui. A type-based termination criterion fordependently-typed higher-order rewrite systems. In Vincent van

Oostrom, editor, Rewriting Techniques and Applications, 15th Interna-tional Conference, RTA 2004, Aachen, Germany, June 3 - 5, 2004, Proceedings, volume 3091 of Lecture Notes in Computer Science, pages24-39. Springer-Verlag, 2004.

[Bla05] Fre'de'ric Blanqui. Decidability of type-checking in the Calculusof Algebraic Constructions with size annotations. In C.-H. Luke

Ong, editor, Computer Science Logic, 19th International Workshop,CSL 2005, 14th Annual Conference of the EACSL, Oxford, UK, August
22-25, 2005, Proceedings, volume 3634 of Lecture Notes in ComputerScience, pages 135-150. Springer-Verlag, 2005.

[BM98] Richard Bird and Lambert Meertens. Nested datatypes. In JohanJeuring, editor, Mathematics of Program Construction, MPC'98, Proceedings, volume 1422 of Lecture Notes in Computer Science, pages52-67. Springer-Verlag, 1998.

[BP99a] Richard Bird and Ross Paterson. Generalised folds for nesteddatatypes. Formal Aspects of Computing, 11(2):200-222, 1999.

BIBLIOGRAPHY 173
[BP99b] Richard S. Bird and Ross Paterson. De Bruijn notation as a nesteddatatype. Journal of Functional Programming, 9(1):77-91, 1999.

[Buc91] Wilfried Buchholz. Notation systems for infinite derivations.Archive of Mathematical Logic, 30:277-296, 1991.
[Buc05] Wilfried Buchholz. A term calculus for (co-)recursive definitionson streamlike data-structures. Annals of Pure and Applied Logic,

136(1-2):75-90, 2005.
[Bur69] Rod Burstall. Proving properties of programs by structural induc-tion. Computer Journal, 12(1):41-48, 1969.

[Cap05] Venanzio Capretta. General recursion via coinductive types. Logi-cal Methods in Computer Science, 2005. To appear.
[CC99] Catarina Coquand and Thierry Coquand. Structured type theory.In Workshop on Logical Frameworks and Meta-languages (LFM'99),

Paris, France, September 1999.
[CHS97] Thierry Coquand, Peter Hancock, and Anton Setzer. Ordinals intype theory. Slides, August 1997. Aarhus.

[CK01] Wei-Ngan Chin and Siau-Cheng Khoo. Calculating sized types.Higher-Order and Symbolic Computation, 14(2-3):261-300, 2001.
[CKX01] Wei-Ngan Chin, Siau-Cheng Khoo, and Dana N. Xu. Higher-orderpolymorphic sized types for safety checks. In The Second Asian

Workshop on Programming Languages and Systems, APLAS'01, KoreaAdvanced Institute of Science and Technology, Daejeon, Korea, December 17-18, 2001, Proceedings, pages 117-131, 2001.
[Coq92] Thierry Coquand. Pattern matching with dependent types. InBengt Nordstro"m, Kent Pettersson, and Gordon Plotkin, editors,

Proceedings of the 1992 Workshop on Types for Proofs and Programs,Ba*stad, Sweden, June 1992, pages 71-83, 1992.

[Coq93] Thierry Coquand. Infinite objects in type theory. In H. Baren-dregt and T. Nipkow, editors, Types for Proofs and Programs (TYPES

'93), volume 806 of Lecture Notes in Computer Science, pages 62-78.Springer-Verlag, 1993.

[CW99] Karl Crary and Stephanie Weirich. Flexible type analysis. InProceedings of the fourth ACM SIGPLAN International Conference on

Functional Programming (ICFP '99), Paris, France, volume 34 of SIG-PLAN Notices, pages 233-248. ACM Press, 1999.

[CW00] Karl Crary and Stephanie Weirich. Resource bound certification.In Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on

Principles of Programming Languages, pages 184-198, Boston, Mas-sachusetts, USA, January 2000.

174 BIBLIOGRAPHY
[Dan99] Norman Danner. Transfinite iteration functionals and ordinalarithmetic. arXiv.org e-Print archive, August 1999.

[DC99] Dominic Duggan and Adriana Compagnoni. Subtyping for objecttype constructors, January 1999. Presented at FOOL 6.
[Dyb94] Peter Dybjer. Inductive families. Formal Aspects of Computing,6(4):440-465, 1994.
[Far04] William M. Farmer. Formalizing undefinedness arising in calcu-lus. In D. Basin and M. Rusinowitch, editors, Automated Reasoning, 2nd International Joint Conference, IJCAR 2004, volume 3097 ofLecture Notes in Artificial Intelligence, pages 475-489, Cork, Ireland,
July 2004. Springer-Verlag.
[Fra03] Maria Joa~o Frade. Type-Based Termination of Recursive Definitionsand Constructor Subtyping in Typed Lambda Calculi. PhD thesis, Universidade do Minho, Departamento de Informa'tica, 2003.
[Geu92] Herman Geuvers. Inductive and coinductive types with iterationand recursion. In Bengt Nordstro"m, Kent Pettersson, and Gordon

Plotkin, editors, Proceedings of the 1992 Workshop on Types for Proofsand Programs, Ba*stad, Sweden, June 1992, pages 193-217, 1992.

[Gim95] Eduardo Gime'nez. Codifying guarded definitions with recur-sive schemes. In Peter Dybjer, Bengt Nordstro"m, and Jan

Smith, editors, Types for Proofs and Programs, International WorkshopTYPES'94, Ba*stad, Sweden, June 6-10, 1994, Selected Papers, volume
996 of LNCS, pages 39-59. Springer, 1995.
[Gim98] Eduardo Gime'nez. Structural recursive definitions in type theory.In K. G. Larsen, S. Skyum, and G. Winskel, editors, Automata, Languages and Programming, 25th International Colloquium, ICALP'98,Aalborg, Denmark, July 13-17, 1998, Proceedings, volume 1443 of
Lecture Notes in Computer Science, pages 397-408. Springer-Verlag,1998.

[Gir72] Jean-Yves Girard. Interpre'tation fonctionnelle et e'limination descoupures dans l'arithme'tique d'ordre supe'rieur. The`se de Doctorat

d'E'tat, Universite' de Paris VII, 1972.
[Gir01] Jean-Yves Girard. Locus solum: From the rules of logic to the logicof rules. Mathematical Structures in Computer Science, 11(3):301-506,

2001.
[GLT89] Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types,volume 7 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1989.

BIBLIOGRAPHY 175
[GM03] Pietro Di Gianantonio and Marino Miculan. A unifying approachto recursive and co-recursive definitions. In H. Geuvers and

F. Wiedijk, editors, Types for Proofs and Programs, Second Interna-tional Workshop, TYPES 2002, Berg en Dal, The Netherlands, April 24-
28, 2002, Selected Papers, volume 2646 of Lecture Notes in ComputerScience. Springer-Verlag, 2003.

[Gog94] Healfdene Goguen. A Typed Operational Semantics for Type Theory.PhD thesis, University of Edinburgh, August 1994. Available as

LFCS Report ECS-LFCS-94-304.
[Gog95] Healfdene Goguen. Typed operational semantics. In M. Deziani-Ciancaglini and G. D. Plotkin, editors, Typed Lambda Calculi and

Applications (TLCA 1995), volume 902 of Lecture Notes in ComputerScience, pages 186-200. Springer-Verlag, 1995.

[Gog99] Healfdene Goguen. Soundness of the logical framework for itstyped operational semantics. In Jean-Yves Girard, editor, Typed

Lambda Calculi and Applications, TLCA 1999, volume 1581 of LectureNotes in Computer Science, L'Aquila, Italy, 1999. Springer-Verlag.

[Hen93] Fritz Henglein. Type inference with polymorphic recursion. ACMTransactions on Programming Languages and Systems (TOPLAS),

15(2):253-289, 1993.
[Hin98] Ralf Hinze. Numerical representations as higher-order nesteddatatypes. Technical Report IAI-TR-98-12, Institut fu"r Informatik

III, Universita"t Bonn, December 1998.
[Hin99] Ralf Hinze. Polytypic functions over nested datatypes. DiscreteMathematics & Theoretical Computer Science, 3(4):193-214, 1999.

[Hin00a] Ralf Hinze. Efficient generalized folds. In Johan Jeuring, editor,Proceedings of the Second Workshop on Generic Programming, WGP

2000, Ponte de Lima, Portugal, July 2000.
[Hin00b] Ralf Hinze. Generalizing generalized tries. Journal of FunctionalProgramming, 10(4):327-351, July 2000.

[Hin01] Ralf Hinze. Manufacturing datatypes. Journal of Functional Pro-gramming, 11(5):493-524, 2001.
[Hin02] Ralf Hinze. Polytypic values possess polykinded types. MPC Spe-cial Issue, Science of Computer Programming, 43:129-159, 2002.
[HJL04] Ralf Hinze, Johan Jeuring, and Andres Lo"h. Type-indexed datatypes. MPC Special Issue, Science of Computer Programming, 51:117-

151, 2004.

176 BIBLIOGRAPHY
[HPS96] John Hughes, Lars Pareto, and Amr Sabry. Proving the correctnessof reactive systems using sized types. In 23rd Symposium on Principles of Programming Languages, POPL'96, pages 410-423, 1996.
[Huf52] D. Huffman. My famous paper on Huffman trees. In Proc. IRE,volume 40, pages 1098-1101, 1952.

[Hut92] Dieter Hutter. Automatisierung der vollsta"ndigen Induktion. Old-enbourgh Verlag, 1992.
[JB04] Neil Jones and Nina Bohr. Termination analysis of the untyped

*-calculus. In Vincent van Oostrom, editor, Rewriting Techniquesand Applications, 15th International Conference, RTA 2004, Aachen,

Germany, June 3 - 5, 2004, Proceedings, volume 3091 of Lecture Notesin Computer Science, pages 1-23. Springer-Verlag, 2004.

[JG02] Neil D. Jones and Arne J. Glenstrup. Abstract and conclusions ofPLI invited paper: program generation, termination, and bindingtime analysis. In Proceedings of the 4th ACM SIGPLAN Interna-tional Conference on Principles and Practice of Declarative Programming, pages 1-1. ACM Press, 2002.
[JJ97] Patrik Jansson and Johan Jeuring. PolyP--a polytypic program-ming extension. In 24th Symposium on Principles of Programming

Languages, POPL'97, Paris, France, pages 470-482. ACM Press,1997.

[JM03] Felix Joachimski and Ralph Matthes. Short proofs of normaliza-tion. Archive of Mathematical Logic, 42(1):59-87, 2003.
[KTU93] Assaf Kfoury, Jerzy Tiuryn, and Pawel/ Urzyczyn. Type reconstruc-tion in the presence of polymorphic recursion. ACM Transactions

on Programming Languages and Systems (TOPLAS), 15(2):290-311,1993.

[Lee02] Chin Soon Lee. Program termination analysis in polynomialtime. In Don S. Batory, Charles Consel, and Walid Taha, editors, Generative Programming and Component Engineering, ACMSIGPLAN/SIGSOFT Conference, GPCE 2002, Pittsburgh, PA, USA,
October 6-8, 2002, Proceedings, volume 2487 of Lecture Notes in Com-puter Science, pages 218-235. Springer-Verlag, 2002.

[LJBA01] Chin Soon Lee, Neil D. Jones, and Amir M. Ben-Amram. The size-change principle for program termination. In ACM Symposium on

Principles of Programming Languages (POPL'01), London, UK, Jan-uary 2001. ACM Press.

[LS05] Sam Lindley and Ian Stark. Reducibility and ??-lifting for com-putation types. In Pawel/ Urzyczyn, editor, Typed Lambda Calculi

BIBLIOGRAPHY 177

and Applications (TLCA 2005), Nara, Japan, volume 3461 of LectureNotes in Computer Science. Springer-Verlag, 2005.

[Luo90] Zhaohui Luo. ECC: An Extended Calculus of Constructions. PhDthesis, University of Edinburgh, 1990.
[Mat98] Ralph Matthes. Extensions of System F by Iteration and Primi-tive Recursion on Monotone Inductive Types. PhD thesis, LudwigMaximilians-University, May 1998.
[Mat99] John Matthews. Recursive function definition over coinductivetypes. In Yves Bertot, Gilles Dowek, Andre' Hirschowitz, C. Paulin,

and Laurent The'ry, editors, Theorem Proving in Higher Order Log-ics, 12th International Conference, TPHOLs '99, Nice, France, volume
1690 of Lecture Notes in Computer Science, pages 73-90. Springer-Verlag, 1999.

[Mat00] Ralph Matthes. Characterizing strongly normalizing terms of acalculus with generalized applications via intersection types. In

ITRS 00, ICALP Satellite Workshops 2000, pages 339-354, 2000.
[Mat01] Ralph Matthes. Monotone inductive and coinductive construc-tors of rank 2. In Laurent Fribourg, editor, Computer Science Logic,

15th International Workshop, CSL 2001. 10th Annual Conference of theEACSL, Paris, France, September 10-13, 2001, Proceedings, volume
2142 of Lecture Notes in Computer Science, pages 600-614. Springer-Verlag, 2001.

[Mat05] Ralph Matthes. Non-strictly positive fixed-points for classical nat-ural deduction. APAL, 2005. To appear.
[McB06] Conor McBride. Type-preserving renaming and substitution. Jour-nal of Functional Programming, 2006. Functional Pearl. To appear.
[Men87] Nax P. Mendler. Recursive types and type constraints in second-order lambda calculus. In Proceedings of the Second Annual IEEE

Symposium on Logic in Computer Science, Ithaca, N.Y., pages 30-36.IEEE Computer Society Press, 1987.

[Men91] Nax Paul Mendler. Inductive types and type constraints in thesecond-order lambda calculus. Annals of Pure and Applied Logic,

51(1-2):159-172, 1991.
[MG01] Clare Martin and Jeremy Gibbons. On the semantics of nesteddatatypes. Information Processing Letters, 80(5):233-238, December

2001.
[MGB04] Clare Martin, Jeremy Gibbons, and Ian Bayley. Disciplined, ef-ficient, generalised folds for nested datatypes. Formal Aspects of

Computing, 16(1):19-35, 2004.

178 BIBLIOGRAPHY
[Min78] Grigori Mints. Finite investigations of transfinite derivations. Jour-nal of Soviet Mathematics, 10:548-596, 1978. Translated from: Zap.

Nauchn. Semin. LOMI 49 (1975).
[MM04] Connor McBride and James McKinna. The view from the left. Jour-nal of Functional Programming, 2004.

[Nor88] Bengt Nordstro"m. Terminating general recursion. BIT, 28(3):605-619, 1988.
[ORS92] S. Owre, J. M. Rushby, and N. Shankar. PVS: A prototype verifi-cation system. In Deepak Kapur, editor, 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notesin Artificial Intelligence, pages 748-752, Saratoga, NY, June 1992.
Springer-Verlag.
[Par97] Michel Parigot. Proofs of strong normalization for second orderclassical natural deduction. Journal of Symbolic Logic, 62(4):1461-

1479, 1997.
[Par00] Lars Pareto. Types for Crash Prevention. PhD thesis, Chalmers Uni-versity of Technology, 2000.

[Pau90] Lawrence Paulson. Isabelle: The next 700 theorem provers. InP. Odifreddi, editor, Logic and Computer Science, pages 361-386.

Academic Press, 1990.
[PDM89] Benjamin Pierce, Scott Dietzen, and Spiro Michaylov. Program-ming in higher-order typed lambda-calculi. Technical report,

Carnegie Mellon University, 1989.
[PHLV02] A.J. Rebon Portillo, K. Hammond, H-W. Loidl, and P. Vasconcelos.Cost analysis using automatic size and time inference. In IFL'02

International Workshop on the Implementation of Functional LanguagesMadrid, Spain, September 16-18, 2002, volume 2670 of Lecture Notes
in Computer Science, pages 232-247. Springer-Verlag, 2002.
[Pie01] Brigitte Pientka. Termination and reduction checking for higher-order logic programs. In Rajeev Gore', Alexander Leitsch, and Tobias Nipkow, editors, Automated Reasoning, First International JointConference, IJCAR 2001, volume 2083 of Lecture Notes in Artificial
Intelligence, pages 401-415. Springer-Verlag, 2001.
[Pie02] Benjamin C. Pierce. Types and Programming Languages. MIT Press,2002.

[PL89] Frank Pfenning and Peter Lee. LEAP: A language with eval andpolymorphism. In TAPSOFT, Vol.2, volume 352 of Lecture Notes in

Computer Science, pages 345-359. Springer-Verlag, 1989.

BIBLIOGRAPHY 179
[Pol94] Randy Pollack. The Theory of LEGO. PhD thesis, University ofEdinburgh, 1994.

[PS97] Benjamin C. Pierce and Martin Steffen. Higher order subtyping.Theoretical Computer Science, 176(1,2):235-282, 1997.
[PS99] Frank Pfenning and Carsten Schu"rmann. System description:Twelf - a meta-logical framework for deductive systems. In

H. Ganzinger, editor, Proceedings of the 16th International Confer-ence on Automated Deduction (CADE-16), volume 1632 of Lecture
Notes in Artificial Intelligence, pages 202-206, Trento, Italy, July1999. Springer-Verlag.

[RP93] J. C. Reynolds and G. D. Plotkin. On functors expressible in thepolymorphic typed lambda calculus. Information and Computation,

105:1-29, 1993.
[Ruc85] Martin Ruckert. Church-Rosser Theorem und Normalisierung fu"rTermkalku"le mit unendlichen Termen unter Einschluss permutativer

Reduktionen. PhD thesis, Mathematisches Institut der LMUMu"nchen, 1985.

[Sch98] Helmut Schwichtenberg. Finite notations for infinite terms. Annalsof Pure and Applied Logic, 94(1-3):201-222, 1998.
[Ser04] Damien Sereni. Size-change termination for higher-order func-tional programs. Technical report, Oxford University Computing

Laboratory, 2004.
[Ser05] Damien Sereni. Simply-typed *-calculus and SCT. Unpublishednote, 2005.

[SJ05] Damien Sereni and Neil D. Jones. Termination analysis of higher-order functional programs. In Kwangkeun Yi, editor, Programming Languages and Systems, Third Asian Symposium, APLAS 2005,Tsukuba, Japan, November 2-5, 2005, Proceedings, volume 3780 of
Lecture Notes in Computer Science, pages 281-297. Springer-Verlag,2005.

[Sli96] Konrad Slind. Function definition in higher order logic. In Pro-ceedings of TPHOLs 96, volume 1125 of Lecture Notes in Computer

Science. Springer-Verlag, 1996.
[Ste95] Joachim Steinbach. Simplification orderings: History of results.Fundamenta Informaticae, 24(1/2):47-87, 1995.

[Ste98] Martin Steffen. Polarized Higher-Order Subtyping. PhD thesis, Tech-nische Fakulta"t, Universita"t Erlangen, 1998.

180 BIBLIOGRAPHY
[SU99] Zdzisl/aw Spl/awski and Pawel/ Urzyczyn. Type fixpoints: Itera-tion vs. recursion. In Proceedings of the fourth ACM SIGPLAN International Conference on Functional Programming (ICFP '99), Paris,France, volume 34 of SIGPLAN Notices, pages 102-113. ACM Press,
1999.
[Tai75] William W. Tait. A realizability interpretation of the theory ofspecies. In R. Parikh, editor, Logic Colloquium Boston 1971/72, volume 453 of Lecture Notes in Mathematics, pages 240-251. Springer-Verlag, 1975.

[Tar55] Alfred Tarski. A lattice-theoretical fixpoint theorem and its appli-cations. Pacific Journal of Mathematics, 5:285-309, 1955.
[TT97] Alastair J. Telford and David A. Turner. Ensuring streams flow. InAlgebraic Methodology and Software Technology (AMAST '97), volume 1349 of Lecture Notes in Computer Science, pages 509-523.Springer-Verlag, 1997.

[TT00] Alastair J. Telford and David A. Turner. Ensuring termination inESFP. Journal of Universal Computer Science, 6(4):474-488, April

2000. Proceedings of BCTCS 15 (1999).
[Tur95] David Turner. Elementary strong functional programming. InProgramming Languages in Education, First International Symposium,

volume 1022 of Lecture Notes in Computer Science. Springer-Verlag,1995.

[UV99] Tarmo Uustalu and Varmo Vene. Mendler-style inductive types,categorically. Nordic J. of Computing, 6(3):343-361, 1999.
[Vau04] Lionel Vaux. A type system with implicit types. English versionof his me'moire de mai^trise, June 2004.
[VH04] Pedro B. Vasconcelos and Kevin Hammond. Inferring cost equa-tions for recursive, polymorphic and higher-order functional programs. In Philip W. Trinder, Greg Michaelson, and Ricardo Pena,editors, Implementation of Functional Languages, 15th International
Workshop, IFL 2003, Edinburgh, UK, September 8-11, 2003, RevisedPapers, volume 3145 of Lecture Notes in Computer Science, pages 86-
101. Springer-Verlag, 2004.
[VM04] Je'ro^me Vouillon and Paul-Andre' Mellie`s. Semantic types: A freshlook at the ideal model for types. In Neil D. Jones and Xavier

Leroy, editors, Proceedings of the 31st ACM SIGPLAN-SIGACT Sym-posium on Principles of Programming Languages, POPL 2004, Venice,
Italy, January 14-16, 2004, pages 52-63. ACM Press, 2004.

BIBLIOGRAPHY 181
[Vou04] Je'ro^me Vouillon. Subtyping union types. In Jerzy Marcinkowskiand Andrzej Tarlecki, editors, Computer Science Logic, CSL'04, volume 3210 of Lecture Notes in Computer Science, pages 415-429.Springer-Verlag, 2004.

[vRS95] Femke van Raamsdonk and Paula Severi. On normalisation. Tech-nical Report CS-R9545, CWI, 1995.
[vRSSX99] Femke van Raamsdonk, Paula Severi, Morten Heine So/rensen,and Hongwei Xi. Perpetual reductions in lambda calculus. Information and Computation, 149(2):173-225, March 1999.
[Wah04] David Wahlstedt. Type theory with first-order data types andsize-change termination. Licentiate Thesis, Chalmers University

of Technology, September 2004.
[Wal92] Christoph Walther. Computing induction axioms. In InternationalConference on Logic Programming and Automated Reasoning - LPAR

92, volume 624 of Lecture Notes in Artificial Intelligence, St. Peters-burg, 1992. Springer-Verlag.

[WCPW03] Kevin Watkins, Iliano Cervesato, Frank Pfenning, and DavidWalker. A concurrent logical framework I: Judgements and properties. Technical report, School of Computer Science, CarnegieMellon University, Pittsburgh, 2003.

[Wei05] Eric W. Weisstein. Goldbach conjecture.From MathWorld-A Wolfram Web Resource.

http://mathworld.wolfram.com/GoldbachConjecture.html,2005.

[Xi01] Hongwei Xi. Dependent types for program termination verifica-tion. In Proceedings of 16th IEEE Symposium on Logic in Computer

Science, Boston, USA, June 2001.
[Xi02] Hongwei Xi. Dependent types for program termination verifica-tion. Journal of Higher-Order and Symbolic Computation, 15(1):91-

131, October 2002.
[Zen98] Christoph Zenger. Indizierte Typen. PhD thesis, Fakulta"t fu"r Infor-matik der Universita"t Kalsruhe, 1998.

182 BIBLIOGRAPHY
Index

*b, 87
*fixu*, 89
\Lambda +u , 88

abstract interpretation, 147accessibility, 144
addition, 41admissible for corecursion, 40, 41,

68, 73, 93, 160admissible for recursion, 40, 41, 65,
72, 93antitone, 19
antitone iteration, 102application of polarities to contexts,

25approximation, 57
approximation stages, 14ascending chain, 59

Banach's fixed-point theorem, 145base kinds, 21
fi-reduction of constructors, 35biorthogonal, 67

breadth-first traversal, 117Brouwer ordinals, 23
Burroni conatural numbers, 42
calculus for semi-continuity, 107Calculus of Algebraic Constructions,

148Calculus of Inductive Constructions,
144, 148canonical form, 43
cardinal, 59Cartesian product, 22, 107
case distinction, 38Church-style constructors, 32

closed, 61, 64, 67closure operator, 71, 167
closure ordinal, 13, 59, 60, 147codata constructor, 157
codata destructor, 157coinduction, 121
coinductive, 22, 101complete lattice, 31
confluent, 44constructor, 19, 21
constructor equality, 27context, 24
continuation passing, 37continuous, 57
continuous normalization, 121contraction, 43
contractive, 145contravariant, 19
converging equivalence relations, 146Coq, 144, 148
corecursion, 37, 39, 68, 147, 160cost inference, 148
covariant, 19Curry-Howard isomorphism, 9, 144
Curry-style *-calculus, 37
data constructor, 86de Bruijn term, 121, 124
de Morgan laws, 69defuse, 52, 147
denotation of terms, 74denotation of types, 33
derivation-independence of seman-tics, 36
descending chain, 59disjoint sum, 22, 107
diverging, 62
183

184 INDEX
division, 41domain, 24
domain predicate, 145domain-free constructors, 32

elimination based, 62embedding, 85
Epigram, 147equi-coinductive, 16, 143
equi-inductive, 16, 157equi-recursive, 16, 77, 85
equivalence relations, 145evaluation context, 43
evaluation frame, 43evaluation relation, 64
evaluator, 121existential type, 22

Fibonacci numbers, 46finite observations, 71
finitely branching tree, 110fixed point, 59
fixed-point unfolding, 45
foetus, 146folding, 39, 157

fuel, 145function space, 22, 30, 62, 67, 99

Galois connection, 25, 71, 167general recursion, 12
generalization, 39, 70greatest fixed point, 59
guard condition, 89guarded by constructors, 121
guarded by destructors, 88guarded corecursion, 121
guarded, syntactically, 89
Halteproblem, 7Haskell, 117
head, 43height, 23
heterogeneous data types, 16, 23higher-order functions, 11
Higher-Order Logic, 144higher-order subtyping, 28

Huffman codes, 47
impredicative encodings, 22, 40, 143impredicative polymorphism, 11
inaccessible, 147indexed types, 148
induction scheme, 144, 145inductive, 22
inductive characterization of stronglynormalizing terms, 77
inductive kind, 149inductive type, 13, 103
infimum, 30, 56infimum continuous, 104
infinite height, 23infinite ordinal, 15
infinite term, 121infinitely branching, 11, 15, 144, 149
infinity ordinal, 22inflationary, 58
information order, 20instantiation, 39, 70
interpretation of kinds, 30intersection, 30, 100, 159
introduction based, 62intuitionistic negation, 69
inverse application of polarities, 25Isabelle, 144
iso-coinductive, 157iso-inductive, 16
iso-recursive, 16, 85isotone, 19
isotone iteration, 103iterate, 13, 57
iteration, 89
kind, 20kind interpretation, 30
kind semantics, 30kinding, 24, 26
Knaster, 59
labeled sum, 16lambda dropping, 61
lambda-calculus, 39lattice, 69, 159

INDEX 185
least fixed point, 59lenient, 104
lexicographic termination orderings,146
liberal, 25lim inf-pullable, 98
lim sup-pushable, 98limes inferior, 56
limes superior, 56limit, 56, 95
list, 23list map, 41
list splitting, 41list zip-with, 41
locally confluent, 44lower semi-continuous, 96

Martin-Lo"f Type Theory, 144maximal element, 30, 31
maximum, 41measure, 144
Mendler-style recursion, 90minimum, 41, 109, 140
mixed recursion-corecursion, 48, 145,146
model, 61modulus, 145
monotonicity, 19multiplication, 41
mutual recursion, 137
natural transformation, 40, 72negative occurrence, 24
nested data types, 16, 23nested recursion, 137
neutral corecursive values, 68neutral terms, 61, 162
non size-increasing, 11non-strictly positive, 89
non-variant, 19normal form, 43
normalization, 123normalizer, 121

!-overshooting, 97, 115
!-undershooting, 97, 115

one-step reduction, 44operator iteration, 57
ordered families of equivalences, 146ordinal expressions, 21
ordinal iteration, 13ordinal notation, 11, 147
ordinal variables, 21ordinals, 21
orthogonal, 66orthogonality, 66, 168
overshooting, 96, 115
pair, 38paracontinuous, 97
parallel substitution, 124Partial evaluation, 9
partial order, 31partiality, 9, 135
partially ordered set, 30pattern matching, 117, 140
pointwise infimum, 31pointwise supremum, 31
polarity, 19, 107polarity composition, 20
polarized context, 24polarized inclusion, 30
poset, 30positive occurrence, 24
positive context, 108positivity condition, 24, 89, 148
power lists, 23prime numbers, 50
primitive recursion, 89, 147product type, 22, 107
program analysis, 143projection, 38
pullable, 98pulled through, 98
Pure kinds, 21pushable, 98
pushes through, 97PVS, 144

quantification, 22, 39, 100
rank, 21

186 INDEX
rank-2 polymorphism, 11recursion, 37, 39, 65
recursion, Mendler-style, 90recursive argument, 42
reducibility candidates, 62reduction, 43
reduction preserving embedding, 85reflexivity, 28
regular data types, 23repeat, 41
requirements, 65, 68rose tree, 117

Safe, 61safe evaluation context, 63
safe terms, 61safe weak head reduction, 64, 159
saturated, 62, 64, 94, 157, 159saturation, 66, 143
semantical type, 62semantics of constructors, 32
semantics of kinding derivations, 33semantics of kinds, 30
semantics of types, 32semi-continuity, 95, 96, 143
semi-continuous types, 15Sieve of Eratosthenes, 145
signature, 22singular, 74
size-change principle, 146size-change termination, 146
sized inductive type, 13sized types, 23
soundness, 36, 61, 110, 162stage expressions, 22
stream, 109stream filtering, 145
strict, 63strictly positive, 89, 108
strong head reduction, 78, 162strong normalization, 61, 162
strong normalization, inductive char-acterization, 77
strongly neutral terms, 78, 162strongly normalizing terms, 79, 163
subject reduction, 35, 77

substitution, 123subsumption, 39
subtraction, 41subtyping, 28
successor of ordinal, 22sum type, 22, 107
supremum, 30, 56, 70, 94, 101, 159Synchronous Haskell, 15, 88
syntactic guardedness, 89systems with partiality, 9

Tarski, 59term, 37
term model, 61termination, 7
termination checking, 144termination conditions, 144
termination proof, 144top element, 31
total correctness, 9total systems, 9
transfinite induction, 95transfinite iteration, 57
tree, 23type constructor, 19
type equality, 27type interpretation, 33
type interval, 62type preservation, 77
type preserving embedding, 85type transformer, 19
type variable, 90type-based termination, 10, 12
typed intermediate language, 149types paradigm, 143
typing context, 38typing derivation, 11

ultrametric space, 145uncountable, 15, 59
undershooting, 97, 115unfolding, 39, 157
union, 30, 70, 94, 157, 159universal quantification, 100
upper semi-continuous, 96
validity, 28, 29

INDEX 187
valuation, 32, 74value, 43
variance, 19
weak head reduction, 64well-formed context, 38
well-founded recursion, 144