

Theoretical Informatics and Applications Will be set by the publisher
Informatique Th'eorique et Applications

AN ABSTRACT MONADIC SEMANTICS FOR

VALUE RECURSION *, **

Eugenio Moggi1 and Amr Sabry2
Abstract. This paper proposes an operational semantics for value recursion in the context of monadic metalanguages. Our technique for
combining value recursion with computational effects works uniformly
for all monads. The operational nature of our approach is related to
the implementation of recursion in Scheme and its monadic version
proposed by Friedman and Sabry, but it defines a different semantics
and does not rely on assignments. When contrasted to the axiomatic
approach proposed by Erk"ok and Launchbury, our semantics for the
continuation monad invalidates one of the axioms, adding to the evidence that this axiom is problematic in the presence of continuations.

1991 Mathematics Subject Classification. 68N18, 68Q55 .

Introduction
How should recursive definitions interact with computational effects like assign-ments and jumps? Consider a term

fix x.e where fix is some fixed point operatorand
e is an expression whose evaluation has side-effects. There are at least twonatural meanings for the term:

(1) the term is equivalent to the unfolding e{x = fix x.e}, and the side-effectsare duplicated by the unfolding;
(2) the side-effects are performed the first time e is evaluated to a value v andthen the term becomes equivalent to the unfolding

v{x = fix x.v}.

The first meaning corresponds to the standard mathematical view [7]. The secondmeaning corresponds to the standard operational view defined since the SECD machine [12, 32] and as implemented in Scheme for example [31]. The two meanings

* Supported by EU project DART IST-2001-33477 and APPSEM-II IST-2001-38957.
** Supported by the NSF under Grants No. CCR 0196063 and CCR 0204389.

1 DISI, Univ. di Genova, email: moggi@disi.unige.it
2 Dept. of Computer Science, Indiana Univ., email: sabry@indiana.edu

cfl EDP Sciences 1999

2 TITLE WILL BE SET BY THE PUBLISHER

are observationally equivalent in a pure functional language but not in the pres-ence of effects. When the computational effects are expressed using monads, Erk"ok
and Launchbury [19-21] introduced the phrase value recursion in monadic com-putations for the second meaning and the name

mfix for the corresponding fixedpoint operator. Since we also work in the context of monadic metalanguages, we

adopt the same terminology but use the capitalized name Mfix to distinguish ourapproach.

Value recursion has applications in modeling stream-oriented computations likehardware circuits [33] and in modeling objects [10] and module systems [18, 26].
We give a simple example here and refer to Section 6 for more details. In thefollowing code fragment,

f is a recursive procedure representing an object whoselocal state is represented by the location

r:

Mfix f.do r  new 0; ret (*x. . . . f . . . r . . .)
Clearly the creation of a new location r is not intended to be unfolded and repeatedevery time

f is called. Instead the creation and initialization of the location rshould happen the first time the body of

Mfix is evaluated; when this evaluationproduces the value
ret (*x. . . . f . . . r . . .), the recursive variable f is bound to it;subsequent calls and recursive calls to

f do not re-create the location.The example outlines a simple uniform operational technique for combining

monadic effects with value recursion. Computing the result of Mfix x.e requiresthree rules:

(1) A rule to initiate the computation of e. Since this computation happensunder a binder, care must be taken to rename any other bound instance

of x that we might later encounter.(2) If the computation of

e returns a value v (in a monadic metalanguage avalue is simply a term of the form

ret e0) then all free occurrences of xare replaced by
fix x.v (where fix is the standard mathematical fixed pointoperator). Naturally the computation of

e may perform computationaleffects but it cannot use
x.(3) If the computation of
e attempts to use x, we signal an error.

In the second rule, the notion that "e returns a value v" is quite informal atthis point. Indeed depending on the computational effects in question,

e mightterminate without returning a proper value (in the case of exceptions), or it might

return more than one value (in the case of non-determinism), or it might returnmore than once (in the case of continuations). One of the main benefits of our
abstract approach is that it provides a formal semantics for value recursion in allthese situations. Indeed we show that the rules above are robust in the sense
that they can be uniformly applied to a wide range of monads giving a semanticsfor value recursion in every case: we give examples for the monads of state, nondeterminism, exceptions, parallelism, and continuations.Our semantics is operational in nature but unlike the SECD and Scheme semantics, it doesn't rely on assignments to realize the second rule. The presence of

TITLE WILL BE SET BY THE PUBLISHER 3
assignments in the other operational approaches yields a different semantics, com-plicates reasoning, and invalidates some equational axioms. Section 5 includes a
discussion of this point. We point however that the question of which transforma-tions are invalidated depends on the details of the implementation: for example, a
more careful implementation of the Scheme semantics does not invalidate as manytransformations as the straightforward implementation [39].

In contrast, the work by Erk"ok and Launchbury [19,20] advocates an axiomaticapproach to defining value recursion by proposing several desirable axioms. In their
approach one has to find for each given monad over some category (or defined inHaskell [29]) a fixed point operator that satisfies the axioms (up to observational
equivalence). The endeavor has to be repeated for each monad individually. Forthe continuation monad there are no known fixed point operators that satisfy all
the desired axioms.
Summary. Sections 1 and 2 illustrate the technique by taking an existing monadic
metalanguage MMLS with ML-style references [35, Sec.3] and extending it withvalue recursion. Section 3 explains our technique in general terms and illustrates

its robustness via three additional short examples: non-determinism, exceptions,and parallelism. Section 4 discusses in detail the important case of the continuation monad: it explains the full subtleties of value recursion in the presenceof continuations and state and gives a proof of type safety for the resulting language. Section 5 recalls the equational axioms for value recursion in [19], anddiscusses them in our context, providing a counterexample to the left-shrinking
axiom. Finally Section 6 concludes and discusses related work.

1. A Monadic Metalanguage with References
We introduce a monadic metalanguage MMLS for imperative computations,namely a subset of Haskell with the IO-monad. Its operational semantics is given
according to the general pattern proposed in [35], i.e., we specify a confluent sim-plification relation

> (defined as the compatible closure of a set of rewriterules), and a computation relation

> describing how the configurations ofthe (closed) system may evolve. This is possible because in a monadic metalanguage there is a clear distinction between term-constructors for building terms ofcomputational types, and the other term-constructors that are computationally irrelevant (i.e., have no effects). For computationally irrelevant term-constructors itsuffices to give local simplification rules, that can be applied non-deterministically
(because they are semantic preserving). In contrast, computationally relevantterm-constructors must be evaluated in the order specified by the monadic combinators. For such terms, we adopt well-established techniques for specifying theoperational semantics of programming languages using evaluation contexts and
abstract machine transitions (see [40]).

The syntax of MMLS is abstracted over basic types b, variables x 2 X, andlocations

l 2 L.*

Types o/ 2 T : : = b | o/1 ! o/2 | Mo/ | Ro/

4 TITLE WILL BE SET BY THE PUBLISHER

var \Gamma (x) = o/\Gamma  `

\Sigma  x: o/ abs

\Gamma , x: o/1 `\Sigma  e: o/2
\Gamma  `\Sigma  *x.e: o/1 ! o/2 app

\Gamma  `\Sigma  e1: o/1 ! o/2\Gamma  `

\Sigma  e2: o/1
\Gamma  `\Sigma  e1e2: o/2

ret \Gamma  `\Sigma  e: o/\Gamma  `

\Sigma  ret e: Mo/ do

\Gamma  `\Sigma  e1: Mo/1 \Gamma , x: o/1 `\Sigma  e2: Mo/2

\Gamma  `\Sigma  do x  e1; e2: Mo/2

loc \Sigma (l) = Ro/\Gamma  `

\Sigma  l: Ro/ new

\Gamma  `\Sigma  e: o/
\Gamma  `\Sigma  new e: M(Ro/ ) get

\Gamma  `\Sigma  e: Ro/
\Gamma  `\Sigma  get e: Mo/

set \Gamma  `\Sigma  e1: Ro/ \Gamma  `\Sigma  e2: o/\Gamma  `

\Sigma  set e1 e2: M(Ro/ )

Table 1. Type System for MMLS

* Terms e 2 E : : = x | *x.e | e1e2 | ret e | do x  e1; e2 |

l | new e | get e | set e1 e2

In addition to the basic types, we have function types o/1 ! o/2, reference types Ro/for locations containing values of type

o/ , and computational types Mo/ for (effect-full) programs computing values of type

o/ . The terms do x  e1; e2 and ret eare used to sequence and terminate computations, the other monadic operations

are: new e which creates a new reference with contents e, get e which returns thecontents of the reference

e, and set e1 e2 which updates the contents of reference
e1 to be e2. In order to specify the semantics of the language, the set of terms alsoincludes locations

l.Table 1 gives the typing rules for deriving judgments of the form \Gamma  `

\Sigma  e: o/ ,
where \Gamma : X fin! T is a type assignment for variables x: o/ and \Sigma : L fin! T is a signaturefor locations

l: Ro/.The operational semantics is given by two relations (as outlined above): a

simplification relation for pure evaluation and a computation relation for monadicevaluation. Simplification

> is given by fi-reduction, i.e., the compatibleclosure of (
*x.e2)e1 > e2{x: = e1}.The computation relation Id

> Id0 | done (see Table 2) is defined using theadditional notions of evaluation contexts, stores and configurations Id 2

Conf:*

Evaluation contexts E 2 EC : : = \Lambda  | E[do x  \Lambda ; e]

* Stores u 2 S \Delta = L fin! E map locations to their contents which are expres-sions (not necessarily "values").

* Configurations (u, e, E) 2 Conf \Delta = S *E *EC consist of the current store u,the program fragment

e under consideration, and its evaluation context E.

The first three rules are administrative: (A.1) finds the first simple command toexecute recording the rest of the computation in the context; the context is popped

by (A.2) when the current command returns; but if the context is empty, (A.0)

TITLE WILL BE SET BY THE PUBLISHER 5

Administrative steps
(A.0) (u, ret e, \Lambda ) > done(A.1) (

u, do x  e1; e2, E) > (u, e1, E[do x  \Lambda ; e2])(A.2) (
u, ret e1, E[do x  \Lambda ; e2]) > (u, e2{x: = e1}, E)

Imperative steps
(new) (u, new e, E) > (u{l: e}, ret l, E) where l /2 dom(u)(get) (

u, get l, E) > (u, ret e, E) with e = u(l)(set) (
u, set l e, E) > (u{l = e}, ret l, E) with l 2 dom(u)

Table 2. Computation Relation for MMLS

terminates the execution. The next three rules formalize the semantics of the state-specific operations. When modifying the store, we write

u{l: e} for initializing anew location
l with e and u{l = e} for updating an existing location l with e.The simplification relation

> on terms extends in the obvious way to arelation (denoted
> ) on stores, evaluation contexts and configurations.There are alternative ways to give semantics to a programming language, but

all of them should agree on basic observations of program behavior. Termination
is among the most basic observations, and for MMLS it can be defined as follows.

Definition 1.1 (Termination). Given a well-typed program e, i.e., ; `; e: Mo/ , we
say that e terminates \Delta () (;, e, \Lambda ) ===* ) done, where ===) = > [ > .

In other words, e terminates, if there is a sequence of simplification and com-putation steps starting from the initial configuration (;

, e, \Lambda ) and leading to done.Once the meaning of basic observations has been given, one can introduce a Morris's style contextual equivalence [36].
Definition 1.2 (Observational Equivalence). We say that e1 is observationallyequivalent to

e2, written e1 ss e2, if for all contexts C such that C[e1] and C[e2] arewell-typed programs, we have that

C[e1] terminates if and only if C[e2] terminates.

2. Extension with Value Recursion
We now describe the monadic metalanguage MMLSfix obtained by extending
MMLS with two fixed point constructs: fix x.e for ordinary recursion, and Mfix x.efor value recursion. The expression

fix x.e simplifies to its unfolding. For comput-ing the value of
Mfix x.e, the subexpression e is first evaluated to a monadic value
ret e0. This evaluation might perform computational effects but cannot use x.Then all occurrences of

x in e0 are bound to the monadic value itself using fix sothat any unfolding will not redo the computational effects.

The extension MMLSfix is an instance of a general pattern (only the extension
of the computation relation is non-trivial), that will become clearer in the nextsection.

6 TITLE WILL BE SET BY THE PUBLISHER

* Terms e 2 E += fix x.e | Mfix x.e

* Evaluation contexts E 2 EC += E[Mfix x.\Lambda ]

* Configurations (X|u, e, E) 2 Conf \Delta = Pfin (X) * S * E * EC . The additionalcomponent

X is a set which records the recursive variables generated sofar, thus
X grows as the computation progresses.

Despite their different semantics, the two fixed points have similar typing rules:

\Gamma , x: Mo/ `\Sigma  e: Mo/

\Gamma  `\Sigma  fix x.e: Mo/

\Gamma , x: Mo/ `\Sigma  e: Mo/
\Gamma  `\Sigma  Mfix x.e: Mo/
The simplification relation is extended with the rule fix x.e > e{x: = fix x.e}for

fix-unfolding.The computation relation Id

> Id0 | done | err may now raise an error and isdefined by the rules in Table 2, modified to propagate the set

X unchanged, andthe following new rules for recursive monadic bindings:

(M.1) (X|u, Mfix x.e, E) > (X, x|u, e, E[Mfix x.\Lambda ]) with x renamed to avoidclashes with

X(M.2) (
X|u, ret e, E[Mfix x.\Lambda ]) > (X|u, ret e, E) where* stands for *{

x: = fix x.ret e}(err) (
X|u, x, E) > err where x 2 X (attempt to use an unresolved variable)

In the context Mfix x.\Lambda  the hole is within the scope of a binder, thus it requiresevaluation of open terms:

* The rule (M.1) ensures freshness of x. As the computation progresses xmay leak anywhere in the configuration (depending on the computational

effects available in the language).* The rule (M.2) does the reverse, it replaces all free occurrences of

x in theconfiguration with the term
fix x.ret e, in which x is not free. This rule isquite subtle, because the definition of substitution on evaluation contexts

must take the captured variables into account (see Definition 4.6).
Definition 1.1 of termination (and consequently of observational equivalence)
extends straightforwardly to MMLSfix.

Definition 2.1 (Termination). Given a well-typed program e, we say that e terminates \Delta () (;|;, e, \Lambda ) ===* ) done.

2.1. Discussion
Divergence. In the proposed extension we have added fix-unfolding to simplifica-tion, thus we have endorsed the view that divergence (and general recursion) is not

a computational effect. However, a purist approach should consider fix-unfoldinga computation rule:

(M.0) (X|u, fix x.e, E) > (X|u, e{x: = fix x.e}, E)

TITLE WILL BE SET BY THE PUBLISHER 7
Types. In [19] the fixed point constructs have a slightly different typing:

* For mfix the bound variable is of type o/ not Mo/ : \Gamma , x: o/ `\Sigma  e: Mo/\Gamma  `

\Sigma  mfix x.e: Mo/

This rule allows the use of x at type o/ before the recursion is resolved,as in (

mfix x.set x 0): M(R int). In [19] this premature attempt to use xis identified with divergence, while we consider it a monadic error (which

could be prevented by more refined type systems [10,18]). The difference oftyping reflects this desire and is not an intrinsic limitation of our approach.

* Similarly for fix the bound variable is of type o/ not Mo/ : \Gamma , x: o/ `\Sigma  e: o/\Gamma  `

\Sigma  fix x.e: o/

This typing requires recursive definitions at all types; we only require themat computational types.

Encoding fix. Is it necessary to have two recursive constructs fix x.e and Mfix x.e?No, we show that

Mfix subsumes fix. First, we reformulate the computationrule (M.2), so that the operational semantics of

Mfix is given independently from
fix (see the purity axiom in Section 5):

(M.2)0 (X|u, ret e, E[Mfix x.\Lambda ]) > (X|u, ret e, E) where* stands for *{

x: = Mfix x.ret e}

Then, we define fix in terms of Mfix

fix x.e j force (Mfix x0.ret e{x: = force x0}) where force e j do x  e; x
The definition uses Mfix at type M2o/ to define fix at type Mo/ . Since the body ofthe

Mfix definition has no effects (it is of the form ret . . .), the Mfix computation
returns immediately computing an x0 of type M2o/ . After the recursion is resolved,the final result and all uses of

x0 are forced to remove the outer (trivial) computa-tion layer. Indeed, one can show that the definition of

fix using Mfix is well-typedand that the computation rule (M.0) for
fix-unfolding is derivable. But despite theabove definability result,
fix has a simpler semantics, given by the simplificationrule for
fix-unfolding, thus it is more natural to use fix whenever possible.

Recursion Variables. In the specific case of MMLSfix we can simplify the operational semantics, by exploiting the following invariant (where FV and CV are setsof variables formally defined in Definition 4.6).

Lemma 2.2. If (X|u, e, E) > (X0|u0, e0, E0), FV(u, e) ` CV(E) ` X andFV(

E) = ;, then FV(u0, e0) ` CV(E0) ` X0 and FV(E0) = ;.

In other words, since the initial configuration (;|;, e, \Lambda ) has an evaluation con-text with no free variables, then in all reachable configurations we have that

FV(E) = ; and there is no need to consider substitution instances of E. Further-more, the only free variables in the configuration are those currently "captured"
by the evaluation context and recorded in X. Thus, when an evaluation context
Mfix x.\Lambda  is popped, we can remove the corresponding x from the set X, effectively

8 TITLE WILL BE SET BY THE PUBLISHER

treating X as a stack (one can go further, see [2], and identify X with CV(E)).
Summing up, in the case of MMLSfix, we can simplify (M.2) to:

(M.2)S (X|u, ret e, E[Mfix x.\Lambda ]) > (X\x|u, ret e, E) where* stands for *{

x: = fix x.ret e}

However, our aim is an operational semantics that works with arbitrary compu-tational effects, and an invariant like the one above does not hold in the case of

continuations (Section 4).

3. General Construction with Examples
We now outline a general methodology for adding value recursion to a monadicmetalanguage

MML. The methodology is not a formal construction. One of themain difficulties in formalizing it is that the shape of configurations may differ

greatly depending on the computational effects. In the following, the shape ofconfigurations is general enough to handle the monads of state, non-determinism,
exceptions, parallelism, and continuations.We denote with

X, E, EC and Conf the syntactic categories for variables, terms,evaluation contexts and configurations of

MML, but there could be other syntac-tic categories. For each syntactic category

C of MML, there is a correspondingsyntactic category
Cfix of MMLfix, defined as follows:

* e 2 Efix : : = fix x.e | Mfix x.e | and the productions of E

* E 2 ECfix : : = E[Mfix x.\Lambda ] | and the productions of EC*

Cfix : : = same productions of C for other syntactic categories*
(X|Id) 2 Conffix : : = (X| . . .) where X `fin X and . . . production for Conf
We write Id [-] for a configuration with one hole for a thread, where a threadis represented by a pair (

e, E), and Id [(e, E)] for the configuration obtained byplacing a thread (
e, E) in the hole.The simplification relation

fix> for MMLfix is the compatible closure of thesimplification rules for
MML and fix-unfolding fix x.e > e{x: = fix x.e}.For the computation relation (

X|Id ) fix> (X0|Id 0) | done | err of MMLfix, the

extension is more involved:*

the old rules Id > Id 0 | done of MML are adapted to propagate theadditional components.

(old.0) (X|Id ) fix> done if Id > done is a computation rule of MML and

similarly for other answers like done in the range of the computationrelation.

(old.1) (X|Id ) fix> (X|Id 0) if Id > Id0 is a computation rule of MML*

The introduction of a new clause for evaluation contexts for Mfix requiresour three rules for pushing and returning from the new context:

(M.1) (X|Id [(Mfix x.e, E)]) fix> (X, x|Id [(e, E[Mfix x.\Lambda ])]) with x renamed

to avoid clashes with X

TITLE WILL BE SET BY THE PUBLISHER 9
(M.2) (X|Id [(ret e, E[Mfix x.\Lambda ])]) fix> (X|Id [(ret e, E)]) where*

stands for *{x: = fix x.ret e}(err) (
X|Id [(x, E)]) fix> err where x 2 X*

The introduction of the new clause of evaluation contexts may requireadditional rules depending on the effects. For example, in the case of

exceptions below, the interaction between the effect of raising an exceptionand the new evaluation context requires an additional rule.

3.1. Non-determinism

We consider the extension of MMLS (and MMLSfix) with non-deterministic choice
(e1 or e2), whose typing rule is:

\Gamma  `\Sigma  e1: Mo/ \Gamma  `\Sigma  e2: Mo/

\Gamma  `\Sigma  e1 or e2: Mo/

The configurations for MMLS and MMLSfix are unchanged. The computation
relations are modified to become non-deterministic, namely:*

for MMLS, we add the rules (u, e1 or e2, E) > (u, ei, E);*
for MMLSfix, we add the rules (X|u, e1 or e2, E) > (X|u, ei, E).

The list monad in Haskell can be related to the non-determinism semanticsgiven above using the following intuition: the list (of configurations) represents

the frontier of an expanding tree of reachable configurations. Therefore, insteadof having two rules for the choice operator, a small-step semantics would describe
how to advance the frontier

L1@[(X|u, e1 or e2, E)]@L2 > L1@[(X|u, e1, E), (X|u, e2, E)]@L2
This implies that each configuration in the list maintains its own store and setof recursion variables: further choices or modifications to the store done in one
branch will not affect the other branches.To help illustrate this point, consider the following term in an extension of the
monadic metalanguage with constants and recursive data:

data o/ = Rec(Int, Mo/ )
p = Mfix x.(ret Rec(1, x)) or (ret Rec(2, x))

According to the computation rules, we push the evaluation context Mfix x.\Lambda  andthen make a non-deterministic choice. The evaluation thus proceeds according to
one of the following sequences:

. . . > (X, x|u, ret Rec(1, x), Mfix x.\Lambda ) > (X, x|u, ret Rec(1, fix x.ret Rec(1, x)), \Lambda )
. . . > (X, x|u, ret Rec(2, x), Mfix x.\Lambda ) > (X, x|u, ret Rec(2, fix x.ret Rec(2, x)), \Lambda )

10 TITLE WILL BE SET BY THE PUBLISHER

where it is clear that the recursion is resolved independently for each possible choice(this separation is not apparent when one maintains all possible configurations in
a list).

3.2. Exceptions

We consider the extension of MMLS (and MMLSfix) with the ability to raise an
exception fail, and a construct handle e1 e2 for handling an exception raised duringthe evaluation of

e1. The typing rules for these two constructs are:

\Gamma  `\Sigma  fail: Mo/

\Gamma  `\Sigma  e1: Mo/ \Gamma  `\Sigma  e2: Mo/

\Gamma  `\Sigma  handle e1 e2: Mo/

The addition of exceptions introduces a new form of termination Id > fail forthe computation relation, due to an uncaught exception. The configurations for

MMLS and MMLSfix are unchanged, but the BNF for evaluation contexts has an
extra clause E 2 EC += E[handle \Lambda  e] , which delimits the scope of the exception
handler e. The computation relation for MMLS is extended with the followingrules:

(F.0) (u, fail, \Lambda ) > fail, i.e., computation terminates due to an uncaughtexception
(F.do) (u, fail, E[do x  \Lambda ; e2]) > (u, fail, E), i.e., an exception is propagateduntil it is caught by an handler

(H.1) (u, handle e1 e2, E) > (u, e1, E[handle \Lambda  e2]), i.e., the handler e2 ispushed on

E(H.2) (
u, ret e1, E[handle \Lambda  e2]) > (u, ret e1, E), i.e., the handler e2 is ignored(H.3) (
u, fail, E[handle \Lambda  e2]) > (u, e2, E), i.e., the handler e2 is executed

With exceptions the computation relation fix> for MMLSfix is given according
to the general methodology which adapts the old rules and adds the three rulesfor value recursion. We also have two additional rules to deal with the additional

form of termination and the interaction between fail and Mfix-contexts:
(old.F) (X|Id) fix> fail if Id > fail is a computation rule of MML
(F.Mfix) (X|Id[(fail, E[Mfix x.\Lambda ])]) fix> (X|Id [(fail, E)]), i.e., we propagate the

exception as in (F.do).
As a simple example, consider the following term Mfix x.fail which consistsof a recursive computation that does not return a proper value. The evaluation

proceeds as follows:

(X|u, Mfix x.fail, \Lambda ) > (X, x|u, fail, Mfix x.\Lambda ) > (X, x|u, fail, \Lambda ) > fail
This semantics is consistent with the axiomatization of Erk"ok and Launchbury [19]which implies

mfix x.e = e, when x does not occur free in e.

TITLE WILL BE SET BY THE PUBLISHER 11
3.3. Parallelism

We consider the extension of MMLS (and MMLSfix) with a construct spawn e1 e2
to spawn a thread executing e1 in parallel with the current thread which continueswith the execution of

e2. The typing rule for spawn is:

\Gamma  `\Sigma  e1: Mo/1 \Gamma  `\Sigma  e2: Mo/2

\Gamma  `\Sigma  spawn e1 e2: Mo/2

The configurations for MMLS become hu, N i 2 Conf \Delta = S * Mfin (E * EC), i.e.,instead of one thread (

e, E) we have a finite multi-set N of threads sharing thestore
u, and the computation relation Id > Id 0 | done is defined by the rules:*

Administrative steps: threads act independently(done) h

u, ;i > done termination occurs when all threads have completed(A.0) h
u, (ret e, \Lambda ) ] N i > hu, Ni(A.1) h
u, (do x  e1; e2, E) ] N i > hu, (e1, E[do x  \Lambda ; e2]) ] N i(A.2) h
u, (ret e1, E[do x  \Lambda ; e2]) ] N i > hu, (e2{x: = e1}, E) ] N i* Imperative steps: each thread can operate on the shared store

(new) hu, (new e, E) ] N i > hu{l: e}, (ret l, E) ] Ni where l /2 dom(u)(get) h

u, (get l, E) ] N i > hu, (ret e, E) ] N i with e = u(l)(set) h
u, (set l e, E) ] N i > hu{l = e}, (ret l, E) ] N i with l 2 dom(u)* Step for spawning a new thread

(spawn) hu, (spawn e1 e2, E) ] N i > hu, (e1, \Lambda ) ] (e2, E) ] N i
Configurations for MMLSfix become hX|u, Ni 2 Conf \Delta = Pfin (X) * S * Mfin (E *
EC), i.e., the threads in the multi-set share also the set X of recursive variablesgenerated so far. The computation relation Id

> Id 0 | done | err is defined bythe rules above (modified to propagate
X unchanged) and the following rules for
Mfix x.e:

(M.1) hX|u, (Mfix x.e, E) ] N i > hX, x|u, (e, E[Mfix x.\Lambda ]) ] N i with x re-named to avoid clashes with

X(M.2) h
X|u, (ret e, E[Mfix x.\Lambda ]) ] N i > hX|u, (ret e, E) ] N i where* stands for *{

x: = fix x.ret e}(err) h
X|u, (x, E) ] N i > err where x 2 X

When a recursive variable x is resolved (M.2), its value is propagated to all threads.When an error occurs in a thread (err), the whole computation crashes.

4. References and Continuations
In this section we consider in full detail the monadic metalanguage MMLSKfix ,
obtained from MMLSfix by adding continuations (to make the technical exposition
self-contained we define MMLSKfix from scratch). This special case is very appropriate to expose the subtleties of value recursion. In particular, we outline a proofof type safety (see Section 4.2), by identifying the key technical lemmas. The

type system we use is rather weak, since it cannot statically detect attempts to

12 TITLE WILL BE SET BY THE PUBLISHER

var \Gamma (x) = o/\Gamma  `

\Sigma  x: o/ abs

\Gamma , x: o/1 `\Sigma  e: o/2
\Gamma  `\Sigma  *x.e: o/1 ! o/2 app

\Gamma  `\Sigma  e1: o/1 ! o/2\Gamma  `

\Sigma  e2: o/1
\Gamma  `\Sigma  e1e2: o/2

ret \Gamma  `\Sigma  e: o/\Gamma  `

\Sigma  ret e: Mo/ do

\Gamma  `\Sigma  e1: Mo/1 \Gamma , x: o/1 `\Sigma  e2: Mo/2

\Gamma  `\Sigma  do x  e1; e2: Mo/2

fix \Gamma , x: Mo/ `\Sigma  e: Mo/\Gamma  `

\Sigma  fix x.e: Mo/ Mfix

\Gamma , x: Mo/ `\Sigma  e: Mo/
\Gamma  `\Sigma  Mfix x.e: Mo/

loc \Sigma (l) = Ro/\Gamma  `

\Sigma  l: Ro/ new

\Gamma  `\Sigma  e: o/
\Gamma  `\Sigma  new e: M(Ro/ ) get

\Gamma  `\Sigma  e: Ro/
\Gamma  `\Sigma  get e: Mo/

set \Gamma  `\Sigma  e1: Ro/ \Gamma  `\Sigma  e2: o/\Gamma  `

\Sigma  set e1 e2: M(Ro/ )

cont \Sigma (k) = Ko/\Gamma  `

\Sigma  k: Ko/ callcc

\Gamma , x: Ko/ `\Sigma  e: Mo/
\Gamma  `\Sigma  callcc x.e: Mo/

throw \Gamma  `\Sigma  e1: Ko/ \Gamma  `\Sigma  e2: Mo/\Gamma  `

\Sigma  throw e1 e2: Mo/ 0

Table 3. Type System for MMLSKfix

use a recursive variable before it is resolved. However, the main purpose of thissection is to serve as a template to establish similar (type safety) results for other
monadic metalanguages with value recursion, and to provide the formal definitionsand technical properties that have been avoided so far.

4.1. Syntax, Types, and Semantics

The syntax of MMLSKfix is abstracted over basic types b, variables x 2 X, locations
l 2 L and continuations k 2 K:*

Types o/ 2 T : : = b | o/1 ! o/2 | Mo/ | Ro/ | Ko/

* Terms e 2 E : : = x | *x.e | e1e2 | fix x.e |

ret e | do x  e1; e2 | Mfix x.e |
l | new e | get e | set e1 e2 |
k | callcc x.e | throw e1e2

The type Ko/ is the type of continuations which can be invoked on arguments oftype

Mo/ (invoking the continuation aborts the current context). The expression
callcc x.e binds the current continuation to x and continues with the executionof

e; the execution of the expression throw e1e2 ignores the current continuationand executes

e2 in the context of the continuation e1 instead. This effectively"jumps" to the point where the continuation

e1 was captured by callcc with e2

TITLE WILL BE SET BY THE PUBLISHER 13
as the result of the callcc expression. By jumping to the same continuation morethan once, it is thus possible for the associated

callcc expression to return morethan once with a different value each time.

Table 3 gives the typing rules for deriving judgments of the form \Gamma  `\Sigma  e: o/ ,
where \Gamma : X fin! T is a type assignment for variables x: o/ and \Sigma : L [ K fin! T is asignature for locations

l: Ro/ and continuations k: Ko/.The simplification relation

> on terms is given by the compatible closureof the following rewrite rules:

fi: (*x.e2)e1 > e2{x: = e1}fix:

fix x.e > e{x: = fix x.e}

Definition 4.1. The compatible closure R> of a binary relation R on terms(s.t.

e R e0 implies FV(e0) ` FV(e)) is given by:

e1 R> e2 \Delta () e1 j C[e] and e2 j C[e0] with e R e0 and C context with one hole.

We write = for the reflexive, symmetric and transitive closure of > . Thefollowing are desirable properties of simplification (identified in [35]), among them

only Proposition 4.4 is relevant to the proof of type safety.
Proposition 4.2 (Congr). The equivalence = induced by > is a congruence.

Proof. Clearly = is an equivalence, it is a congruence, i.e., e1 = e2C[e

1] = C[e2] ,because > is the compatible closure of a relation. \Lambda 

Proposition 4.3 (CR). The simplification relation > is confluent.
Proof. The rewriting rules defining > are left-linear and non-overlapping,thus

> is confluent by a general result on combinatory reduction systems.The proof uses an auxiliary relation

1AE , called 1-step parallel reduction, s.t.
> ` 1AE ` *> and satisfying the diamond property. \Lambda 

Proposition 4.4 (SR). If \Gamma  `\Sigma  e: o/ and e > e0, then \Gamma  `\Sigma  e0: o/.
Proof. The proof relies on two properties of the type system: substitution and
replacement. subst \Gamma  `\Sigma  e1: o/1 \Gamma , x: o/1 `\Sigma  e2: o/2\Gamma  `

\Sigma  e2{x: = e1}: o/2 allows to prove SR for thetwo rewriting rules defining > . While the replacement property

If \Gamma  `\Sigma  C[e]: o/ , then exists \Gamma 0 and o/ 0 s.t.\Gamma 0 `

\Sigma  e: o/ 0 and \Gamma  `\Sigma  C[e0]: o/ whenever \Gamma 0 `\Sigma  e0: o/ 0
allows to derive SR for the compatible closure R> from SR for R. \Lambda 

To define the computation relation Id > Id 0 | done | err (see Table 4), we needthe auxiliary notions of evaluation contexts, stores, continuation environments and

configurations Id 2 Conf (while computational redexes are used only in technicalstatements):

* Evaluation contexts E 2 EC : : = \Lambda  | E[do x  \Lambda ; e] | E[Mfix x.\Lambda ]

14 TITLE WILL BE SET BY THE PUBLISHER

* Stores u 2 S \Delta = L fin! E and continuation environments ae 2 KE \Delta = K fin! EC*

Configurations (X|u, ae, e, E) 2 Conf \Delta = Pfin (X) *S *KE* E *EC consist ofthe current store

u and continuation environment ae, the program fragment
e under consideration and its evaluation context E. The set X records therecursive variables generated so far, thus

X grows as the computationprogresses.

* Computational redexes

r 2 R : : = ret e | do x  e1; e2 | x | Mfix x.e |

new e | get l | set l e |
callcc x.e | throw k e

Remark 4.5. In the absence of Mfix x.e, the hole \Lambda  of an evaluation context Eis never within the scope of a binder. Therefore one can represent

E as a *-abstraction
*x.E[x], where x /2 FV(E). This is how continuations are modeled inthe
*-calculus, in particular the operation E[e] of replacing the hole in E with aterm

e becomes simplification of the fi-redex (*x.E[x]) e. This representation ofcontinuations is adopted also in the reduction semantics of functional languages

with control operators [40]. In such reduction semantics there is no need to keep acontinuation environment

ae, because a continuation k with ae(k) = E is representedby the
*-abstraction *x.E[x]. In the presence of Mfix x.e (or when modeling par-tial evaluation, multi-stage programming, and call-by-need [5, 6, 34]), evaluation

may take place within the scope of a binder, and one can no longer represent anevaluation context with a

*-abstraction, because the operation E[e] may capturefree variables in
e. In this case, continuation environments are very convenient,since the subtle issues regarding variable capture are confined to the level of configurations, and do not percolate in terms and other syntactic categories.

In an evaluation context the hole \Lambda  can be within the scope of a binder, thus anevaluation context

E has not only a set of free variables, but also a set of capturedvariables. Moreover, the definition of

E{x0: = e0} differs from the capture-avoidingsubstitution
e{x0: = e0} for terms, because captured variables cannot be renamed.

Definition 4.6. The sets CV(E) and FV(E) of captured and free variables andthe substitution

E{x0: = e0} are defined by induction on E:

* CV(\Lambda ) \Delta = FV(\Lambda ) \Delta = ; and \Lambda {x0: = e0} \Delta = \Lambda *

CV(E[do x  \Lambda ; e]) \Delta = CV(E),
FV(E[do x  \Lambda ; e]) \Delta = FV(E) [ (FV(e)\(CV(E) [ x)) and

(E[do x  \Lambda ; e]){x0: = e0} \Delta = ae E0[do x  \Lambda ; e] x0 2 CV(E)E0[do x  \Lambda ; e{x0: = e0}] otherwise
with E0 j E{x0: = e0} (the bound variable x can be renamed to be differentfrom

x0 and from any of the free variables of e0).*

CV(E[Mfix x.\Lambda ]) \Delta = CV(E) [ x, FV(E[Mfix x.\Lambda ]) \Delta = FV(E) and
(E[Mfix x.\Lambda ]){x0: = e0} \Delta = E0[Mfix x.\Lambda ] with E0 j E{x0: = e0}

TITLE WILL BE SET BY THE PUBLISHER 15

Administrative steps
(A.0) (X|u, ae, ret e, \Lambda ) > done(A.1) (

X|u, ae, do x  e1; e2, E) > (X|u, ae, e1, E[do x  \Lambda ; e2])(A.2) (
X|u, ae, ret e1, E[do x  \Lambda ; e2]) > (X|u, ae, e2{x: = e1}, E)

Steps for recursive monadic binding
(M.1) (X|u, ae, Mfix x.e, E) > (X, x|u, ae, e, E[Mfix x.\Lambda ]) with x renamed toavoid clashes with

X(M.2) (
X|u, ae, ret e, E[Mfix x.\Lambda ]) > (X|u, ae, ret e, E) where* stands for *{

x: = fix x.ret e} (the free occurrences of variable x arereplaced anywhere in the configuration)

(err) (X|u, ae, x, E) > err where x 2 X (attempt to use unresolved variable)

Imperative steps
(new) (X|u, ae, new e, E) > (X|u{l: e}, ae, ret l, E) where l /2 dom(u)(get) (

X|u, ae, get l, E) > (X|u, ae, ret e, E) with e = u(l)(set) (
X|u, ae, set l e, E) > (X|u{l = e}, ae, ret l, E) with l 2 dom(u)

Control steps
(callcc) (X|u, ae, callcc x.e, E) > (X|u, ae{k: E}, e{x: = k}, E) where k /2 dom(ae)(throw) (

X|u, ae, throw k e, E) > (X|u, ae, e, Ek) with Ek = ae(k)

Table 4. Computation Relation for MMLSKfix

The confluent simplification relation > on terms extends in the obvious wayto a confluent relation (denoted

> ) on stores, evaluation contexts and con-figurations. The following lemma establishes a useful invariant on configurations

independent from typing, namely every configuration (X|u, ae, e, E) reachable froman initial one (;|;

, ;, e0, \Lambda ) satisfies the property FV(u, ae, e, E) [ CV(ae, E) ` X.Since the property is trivially satisfied on initial configurations with all the sets

empty, it suffices to show that it is preserved by simplification and computationsteps.

Lemma 4.7. If (X|u, ae, e, E) > (X0|u0, ae0, e0, E0), then
X = X0, dom(u0) = dom(u), dom(ae0) = dom(ae) and*

FV(e0) ` FV(e), CV(E0) = CV(E) and FV(E0) ` FV(E)* FV(

e0l) ` FV(el) for el = u(l) and e0l = u0(l)* CV(

E0k) = CV(Ek) and FV(E0k) ` FV(Ek) for Ek = ae(k) and E0k = ae0(k)

If (X|u, ae, e, E) > (X0|u0, ae0, e0, E0) and FV(u, ae, e, E) [ CV(ae, E) ` X, then
X ` X0, dom(u) ` dom(u0), dom(ae) ` dom(ae0) andFV(

u0, ae0, e0, E0) [ CV(ae0, E0) ` X0.

Proof. The property of simplification follows from FV(e0) ` FV(e) whenever
e > e0, and the fact that simplification cannot modify the shape of a store,evaluation context or continuation environment. The property of computation

is proved by considering each computation rule separately, and exploiting basicproperties of substitution {

x: = e}. We consider two cases:

16 TITLE WILL BE SET BY THE PUBLISHER

(A.2) (X|u, ae, ret e1, E[do x  \Lambda ; e2]) > (X|u, ae, e2{x: = e1}, E). Since X, uand

ae do not change, it suffices to derive FV(e2{x: = e1}, E)[ CV(E) ` Xfrom FV(

e1, E[do x  \Lambda ; e2]) [ CV(E[do x  \Lambda ; e2]) ` X.CV(
E) ` X because CV(E) = CV(E[do x  \Lambda ; e2]).FV(
E) ` X because FV(E) ` FV(E[do x  \Lambda ; e2]).FV(
e2{x: = e1}) ` (FV(e2)\x) [ FV(e1) ` X because FV(e1) ` X andFV(
e2) ` FV(E[do x  \Lambda ; e2]) [ CV(E) [ x ` X [ x.
(M.2) (X|u, ae, ret e, E[Mfix x.\Lambda ]) > (X|u, ae, ret e, E) where * stands for*{

x: = fix x.ret e}. We have to derive FV(u, ae, e, E) [ CV(ae, E) ` Xfrom FV(

u, ae, e, E) [ CV(E) [ x ` X. We focus on e and E, since thereasoning for

u and ae is similar.FV(
e, E) ` X because FV(e, E) ` X and FV(fix x.ret e) ae X.
CV(E) ` X because CV(E) = CV(E).

\Lambda 

The following property is not relevant for type safety, but establishes a keyproperty of simplification, namely if a computation rule is enabled in a configuration, it is still enabled if the configuration is simplified. Moreover, if the programfragment under consideration is a computational redex, further simplification does
not enable more computational rules.
Theorem 4.8 (Bisim). If Id j (X|u, ae, e, E) with e 2 R and Id * > Id 0, then

(1) Id > D implies 9D0 s.t. Id0 > D0 and D * > D0
(2) Id 0 > D0 implies 9D s.t. Id > D and D * > D0
where D and D0 range over Conf [ {done, err}.

Proof. An equivalent statement, but easier to prove, is obtained by replacing *>with 1-step parallel reduction

1AE . A key observation for proving the bisim-ulation result is that simplification applied to a computational redex r and an

evaluation context E does not change the relevant structure (of r and E) fordetermining the computation step among those in Table 4. \Lambda 

4.2. Type Safety

We prove that in MMLSKfix execution of a well-typed program ; `; e0: Mo/
does not get stuck, i.e., every configuration Id reachable from the initial one(;|;

, ;, e0, \Lambda ) can progress Id ====) by a simplification or computation step.Thus execution of

e0 stops either because of termination (done) or because of anattempt to use an unresolved variable (

err). Following [40] we prove type safetyby establishing Subject Reduction and Progress for well-formed configurations.

The definitions of well-formed configurations \Delta  `\Sigma  Id : o/ 0 and evaluation con-texts \Delta 

, \Lambda : Mo/ `\Sigma  E: Mo/0 must take into account the set X. Thus we need a typeassignment \Delta  mapping

x 2 X to computational types Mo/ .

TITLE WILL BE SET BY THE PUBLISHER 17

\Lambda  \Delta , \Lambda : Mo/ `

\Sigma  \Lambda : Mo/

E-do \Delta , \Lambda : Mo/2 `\Sigma  E: Mo/ 0 \Delta , x: o/1 `\Sigma  e: Mo/2\Delta , \Lambda : Mo/

1 `\Sigma  E[do x  \Lambda ; e]: Mo/ 0

E-Mfix \Delta , \Lambda : Mo/ `\Sigma  E: Mo/ 0\Delta , \Lambda : Mo/ `

\Sigma  E[Mfix x.\Lambda ]: Mo/ 0 \Delta (x) = Mo/

Table 5. Well-formed Evaluation Contexts for MMLSKfix

Definition 4.9. \Delta  `\Sigma  (X|u, ae, e, E): o/ 0 \Delta () dom(\Sigma ) = dom(u) ] dom(ae),
dom(\Delta ) = X and*

\Delta  `\Sigma  e: Mo/ and \Delta , \Lambda : Mo/ `\Sigma  E: Mo/ 0 are derivable (see Table 5) for sometype

o/* \Delta  `

\Sigma  el: o/l is derivable when el = u(l) and Ro/l = \Sigma (l)* \Delta 
, \Lambda : Mo/k `\Sigma  Ek: Mo/ 0 is derivable when Ek = ae(k) and Ko/k = \Sigma (k)

The formation rules of Table 5 for deriving \Delta , \Lambda : Mo/ `\Sigma  E: Mo/ 0 ensure that \Delta assigns a computational type to all captured variables of

E. Moreover, we havethe following substitution lemma for evaluation contexts.

Lemma 4.10. The following rule is admissible
E-subst \Delta  `\Sigma  e0: Mo/0 \Delta , x0: Mo/0, \Lambda : Mo/ `\Sigma  E: Mo/ 0\Delta , x

0: Mo/0, \Lambda : Mo/ `\Sigma  E{x0: = e0}: Mo/ 0

Proof. By induction on the derivation of \Delta , x0: Mo/0, \Lambda : Mo/ `\Sigma  E: Mo/ 0.We write * for *{

x0: = e0}. The only interesting case is the (E-do) rule,
when we have to derive \Delta , x0: Mo/0, \Lambda : Mo/1 `\Sigma  E[do x  \Lambda ; e]: Mo/ 0 from both\Delta 

, x0: Mo/0, \Lambda : Mo/2 `\Sigma  E: Mo/ 0 and \Delta , x0: Mo/0, x: o/1 `\Sigma  e: Mo/2.By IH we have \Delta 

, x0: Mo/0, \Lambda : Mo/2 `\Sigma  E: Mo/ 0. If x0 2 CV(E), then we have that
E[do x  \Lambda ; e] j E[do x  \Lambda ; e], and the conclusion is immediate. Otherwise
E[do x  \Lambda ; e] j E[do x  \Lambda ; e], thus we need \Delta , x0: Mo/0, x: o/1 `\Sigma  e: Mo/2, whichfollows from substitution and weakening for the type system. \Lambda 

We can now formulate the SR and progress properties for MMLSKfix .
Theorem 4.11 (SR).

(1) If \Delta  `\Sigma  Id1: o/ 0 and Id 1 > Id2, then \Delta  `\Sigma  Id 2: o/0(2) If \Delta 

1 `\Sigma 1 Id 1: o/ 0 and Id 1 > Id2, then exists \Sigma 2 ' \Sigma 1 and \Delta 2 ' \Delta 1 s.t.\Delta 
2 `\Sigma 2 Id2: o/ 0.

Proof. The first claim is an easy consequence of Proposition 4.4. The second isproved by case-analysis on the computation rules of Table 4. The most interesting

case is (M.2). We know \Delta  `\Sigma  (X|u, ae, ret e, E[Mfix x.\Lambda ]): o/ 0 and we want to derive
\Delta  `\Sigma  (X|u, ae, ret e, E): o/0 where * stands for *{x: = fix x.ret e}.

18 TITLE WILL BE SET BY THE PUBLISHER

Let o/ be s.t. \Delta  `\Sigma  ret e: Mo/ and \Delta , \Lambda : Mo/ `\Sigma  E[Mfix x.\Lambda ]: Mo/ 0, thus we musthave \Delta (

x) = Mo/ and \Delta , \Lambda : Mo/ `\Sigma  E: Mo/ 0. By (fix) and weakening we derive
\Delta  `\Sigma  fix x.ret e: Mo/. We can now prove \Delta  `\Sigma  (X|u, ae, ret e, E): o/ 0.*

\Delta  `\Sigma  ret e: Mo/ by substitution and weakening* \Delta 

, \Lambda : Mo/ `\Sigma  E: Mo/ 0 by Lemma 4.10

the properties of u and ae (in Definition 4.9) are proved by similar arguments. \Lambda 

Lemma 4.12. If \Delta  `\Sigma  e: o/ 0 and e is a > -normal form, then*

o/ 0 j Mo/ implies e is a computational redex*
o/ 0 j (o/1 ! o/2) implies e is a *-abstraction*
o/ 0 j Ro/ implies e is a location l*
o/ 0 j Ko/ implies e is a continuation k

Proof. By induction on e. The only cases that use the IH are: e1e2, get e, set e1 e2and

throw e1 e2.

e1e2: if \Delta  `\Sigma  e1e2: o/2 and in normal form, the we must have (for some o/1)\Delta  `

\Sigma  e1: o/1 ! o/2 and in normal form. Thus e1 must be a *-abstraction(by IH for

e1), and e1e2 is a fi-redex. This contradict the assumption that

e1e2 is in normal form.
get e: if \Delta  `\Sigma  get e: o/ 0 and in normal form, then we must have (for some o/ )

o/ 0 = Mo/ and \Delta  `\Sigma  e: Ro/ and in normal form. Thus e must be a location
l (by IH for e), and get e is a computational redex.

The cases set e1 e2 and throw e1 e2 are similar to get e. \Lambda 

In a well-typed configuration there must be a way to make progress eitherby making a simplification step or a computational step. In the latter case the

computational step might lead to another configuration, to done indicating propertermination, or to

err indicating an attempt to use an unresolved recursion variable.

Theorem 4.13 (Progress). If \Delta  `\Sigma  (X|u, ae, e, E): o/ 0, then

(1) e 2 R and (X|u, ae, e, E) > , or(2)

e /2 R and e > .

Proof. We have (for some o/ ) that \Delta  `\Sigma  e: Mo/ . When e 2 R we show that(

X|u, ae, e, E) > by case analysis on the structure of computational redexes.

ret e: rules (A.0), (A.2) or (M.2) are applicable, depending on E
do x  e1; e2: rule (A.1) is applicable
x: rule (err) is applicable, because x 2 dom(\Delta ) = X by well-formedness ofthe configuration

get l: rule (get) is applicable, because l 2 dom(\Sigma ) = dom(u) by the well-formedness of the configuration

The other cases are similar to either do x  e1; e2 or get l. When e /2 R, then ecannot be a

> -normal form, because of Lemma 4.12. \Lambda 

Given subject reduction and progress, we thus have type safety for the monadicmetalanguage with continuations and state.

TITLE WILL BE SET BY THE PUBLISHER 19
Corollary 4.14. If ; `; e0: Mo/ and (;|;, ;, e0, \Lambda ) ===* ) Id, then Id ===) .

Continuations and state are so expressive that they can define or simulate manyother monads [22]. But the type safety result does not immediately carry over to

other monads. For example, in situations involving communication and paral-lelism, type safety need to be formulated differently, since a well-typed program
may deadlock.

5. Axioms for Value Recursion
We discuss two of the main axioms for defining value recursion in [19], clamingvalidity for one of them and providing a counterexample for the other.

5.1. Purity

The purity axiom:

mfix x.ret e = ret (fix x.e)

is the property which ensures that mfix coincides with fix for pure computations.In our case, because of the differences in typing between

mfix and Mfix, thiscorresponding axiom would be that
Mfix x.ret e = fix x.ret e.In an operational setting the way to validate an equational axiom

e1 = e2 isto prove that it is observationally valid, i.e.,
e1 ss e2. A standard strategy forproving
e1 ss e2 is the bisimulation proof technique. In our setting it amounts tofind a binary relation

R on Conf with the following properties:

(1) (;|;, ;, C[e1], \Lambda )R(;|;, ;, C[e2], \Lambda ) for any program (closing) context C

(2) Id 1RId2 and Id 1 ===) D1 imply Id 2 ===* ) D2 and D1 ~RD2 for some D2
(3) Id 1RId2 and Id 2 ===) D2 imply Id 1 ===* ) D1 and D1 ~RD2 for some D1
where ===) = > [ > and ~R extends R to Conf | done | err, namely~
R = R [ {(done, done), (err, err)}.For instance, to prove that

e1 ss e2 when e1 > e2 one could use the following

relation Id 1RId2 \Delta () Id1 * > Id2. To check that R has the required propertieswe have to exploit Theorems 4.3 and 4.8.

Indeed it is possible to prove the purity axiom using our semantics.
Proposition 5.1 (Purity). Mfix x.ret e ss fix x.ret e

5.2. Left-Shrinking

The left-shrinking axiom:

mfix x.(do x1  e1; e2) = do x1  e1; mfix x.e2 when x /2 FV(e1)
states that computations which do not refer to the recursive variable can be movedoutside the recursive definition.

20 TITLE WILL BE SET BY THE PUBLISHER

The axiom is known to be satisfied in many monads [19]. However a relatedequivalence is known to be incorrect in Scheme due to the presence of callcc [8].
It was argued [19] that the failure of left-shrinking is due to the idiosyncrasies ofScheme. In fact left-shrinking is invalidated by our semantics and in other known
combinations of value recursion and continuations [14,23]. We provide a completecounterexample to this axiom to illustrate the extreme subtlety and complications
of using value recursion with general effects which include continuations, and tosuggest that it is unlikely that value recursion can satisfy a large class of "interesting" axioms in the general case.The example (inspired by examples by Bawden [8] and Carlsson [14]) is written
in a Haskell-like extension of MMLSKfix with booleans, pairs, etc. (but Mfix is not a
legal Haskell identifier, as it starts with an uppercase letter). We will arrange forthe final result of our example to be a recursive pair whose first component is an

Int and whose second component is a computation producing another recursivepair as formalized by the type RP m below (and where m is the monadic type
constructor). The basic idea in the counterexample is to use continuations toexecute the same computation more than once returning a different value each
time. This requires a recursive type like V m below (where again m is the monadictype constructor):

data RP m = RP (m (Int, RP m))data V m = Ret (K (RP m)) | Jump (K (V m))
Values of type V m are continuations which either accept the final value or whichjump back and restart the computation again with a new continuation.

The following two terms should be equal by left-shrinking:
lhs : : Monad m ) m (Int, RP m)lhs = Mfix (\ x !

do p  callcc (\ k ! return (Jump k ))

case p ofJump k !

do v  callcc (\ c ! throw k (return (Ret c)))return (1

, v )Ret c ! throw c (return (RP x )))

rhs : : Monad m ) m (Int, RP m)rhs = do p  callcc (\ k ! return (Jump k))

Mfix (\ x !case p of

Jump k ! do v  callcc (\ c ! throw k (return (Ret c)))return (1

, v )Ret c ! throw c (return (RP x )))

In our semantics (extended with simplification rules for booleans, pairs, etc) thetwo terms evaluate differently. In the lhs, the evaluation enters the Mfix expression

TITLE WILL BE SET BY THE PUBLISHER 21
and then continuations are captured and invoked within the body of the Mfixexpression. Eventually the body of Mfix evaluates to (return (1

, RP x )) where xis the recursive variable, and the whole expression produces the well-defined value

(1, RP (fix x . return (1, RP x ))).In more detail, the evaluation of the lhs consists of the following macro steps:

* x : recursive variable x is created.* k: continuation k is bound to the evaluation context

Ek = Mfix (\ x ! do p  \Lambda ; e) where

e = case p ofJump k ! do v  callcc (\ c ! throw k (return (Ret c)))

return (1, v)Ret c ! throw c (return (RP x ))

* c: branch Jump k is selected, and continuation c is bound toE

c = Mfix (\ x ! do v  \Lambda ; return (1, v))* throw k: return (Ret c) is thrown to E

k , thus branch Ret c is selected.* throw c: return (RP x ) is thrown to E
c which producesMfix (\ x ! do v  return (RP x ) ; return (1

, v))* mfix: the evaluation of the body of Mfix returns

Mfix (\ x ! return (1, (RP x )))* resolve x : the final answer is return (1

, (RP fix x . (1, (RP x ))))

In the case of the rhs, a continuation is captured before we ever start evaluatingthe Mfix expression. Then p gets bound to the value (Jump k ) and the Mfix expression is entered a first time with recursive variable x . This however immediatelyjumps back and rebinds p to a new value (Ret c) where c is a continuation which
refers to the captured recursive variable x . But jumping back and rebinding pto (Ret c) starts a new evaluation of the Mfix expression with recursive variable
x 0 this time. This evaluation invokes c with the value (RP x 0) which results inthe body of the original evaluation of Mfix (with recursive variable x ) to produce
(return (1, RP x 0)). Thus the rhs produces the value (1, RP x 0) which has a freeunresolved recursive variable.

In more detail the evaluation consists of the following steps:*

k: continuation k is bound the evaluation contextE 0

k = do p  \Lambda ; Mfix (\ x ! e) where e is the term in macro step kin the evaluation of the lhs.

* x : recursive variable x is created.* c: branch Jump k is selected, and continuation c is bound to the evaluation

context Ec introduced in macro step c in the evaluation of the lhs.* throw k: return (Ret c) is thrown to E 0

k , which binds p to Ret c.* x 0: recursive variable x 0, different from x , is created.

* throw c: branch Ret c is selected, and return (RP x 0) is thrown to Ecwhich produces

Mfix (\ x ! do v  return (RP x 0) ; return (1, v))

22 TITLE WILL BE SET BY THE PUBLISHER

* mfix: the evaluation of the body of Mfix returnsMfix (\ x ! return (1

, RP x 0))* resolve x : the final answer is return (1

, RP x 0), with x 0 unresolved.

5.3. Scheme semantics

Our semantics also differs from the Scheme semantics. The semantics of aletrec expression in Scheme is given as follows [31]:

(letrec ((x e)) e0) = (let ((x (void)))(let ((v e))

(begin (set! x v ) e0)))
To understand the definition, one should note the nature of variables in Scheme:a variable declaration implicitly allocates a location and a variable use implicitly

reads the corresponding location. This is unlike our presentation so far in whichvariables always refer to values and locations are explicitly created and read with
new and get. Given this understanding, the meaning of a letrec expression is asfollows:

* Allocate a location and initialize it to an unusable value.* Evaluate the right hand side e; this evaluation cannot read the contents

of the location, i.e., it cannot use x in an evaluation context position.* Update the location with the resulting value and evaluate the body.
The differences between our approach and the Scheme semantics become moreevident if we attempt to define a fixed point operator that captures the Scheme
semantics: one might be tempted to use the following definition:
(schemeFix f ) = (letrec ((x (f x ))) x )
but unfortunately the application (f x ) attempts to prematurely read the locationassociated with x .

Indeed the presence of locations and assignments cannot be encapsulated in thedefinition of

letrec: a judicious use of callcc exposes them and can be used todefine first-class reference cells [8, 23].

6. Conclusion and Related Work
Recursion is a pervasive feature in many general purpose programming lan-guages. Cook [15] has demonstrated its importance in clarifying the semantics
of object-oriented languages. Bracha [13] has abstracted from the object-orientedparadigm and proposed mixins and related operations as a way for supporting
modularity in a variety of programming languages. Ancona and Zucca [1, 4] haveproposed CMS as a foundational calculus for mixins more suitable for theoretical studies, although able to express (in term of few primitives) the variety ofoperations identified by Bracha. All these works show that recursion, and more

TITLE WILL BE SET BY THE PUBLISHER 23
specifically the management of mutually recursive definitions, is important alsofor programming in the large.

This paper investigates the interaction of recursion with computational effects.We have worked in the setting monadic metalanguages, since they provide a general
framework for computational effects, and have proposed a uniform way of addingvalue recursion to a monadic metalanguage equipped with an abstract operational
semantics described by a simplification and computation relation.Other researchers have looked (or are looking) at value recursion at a different
level of abstraction or with a different focus. We attempt a classification of researchtopics that are related to value recursion, and mention some of the most significant
contributions (without any attempt to be exhaustive).

* Value Recursion and Monads [19, 20]. While using Haskell for modelinghardware circuits and stream-oriented computations, Launchbury, Lewis,

and Cook realized that the monadic infrastructure could not be used indescribing recursive circuits [33]. This observation led Erk"ok and Launchbury to abstract from the specific application domain, investigate the se-mantics of value recursion, and implement it as an extension to Haskell.
Their work is also prominent for taking an axiomatic approach and pro-viding equational reasoning principles for value recursion. Paterson [37]
provides similar results in the more general framework of arrows [28].* Axiomatic/Categorical Treatments of Recursion. The semantics of value
recursion has been considered also in a categorical setting, in particular [9]has adapted the notion of trace to premonoidal categories [38], which
include the Kleisli category for a strong monad.* Implementations of Value Recursion. For specific constrained notions of
computations, for example for state, I/O, and several other monads, itis possible to implement value recursion in terms of the usual fixed point
construct. For example, given a simple state monad defined by the con-structor:

M a = Int ! (a, Int), one can define:

Mfix x.e = *s.(fix p.(*x.e) (ret (fst p)) s)
which is how current Haskell implementations [24, 30] deal with value re-cursion for the state and IO monads (replacing our

Mfix with mfix). Inthe general setting where the notion of computation is not restricted, all

known implementations of value recursion rely on a variant of the SECDupdate-in-place trick [17, 31, 32]. This implementation strategy can often
be optimized, but sometimes with some imposed restrictions [12,18,27,39].* Value Recursion and Objects. The semantics of objects proposed by
Cook [16] identifies a class c with a function f: R ! R (from recordsto records); a new object

o of class c is (the record) obtained by takingthe fixed point of
f. When objects have a state, some computations (ini-tialization) have to be done once, at object-creation time. If computations

during initialization are heavily constrained, one could model a class as

24 TITLE WILL BE SET BY THE PUBLISHER

a computation of a function f0: M(R ! R), but in general a more subtleform of recursion is needed [10], namely value recursion.

* Value Recursion and Modules [2, 4, 18, 25, 26]. The importance of sup-porting recursion at the module level has been observed by Bracha, who

proposed the notion of mixin. Even for rich module languages, like ML-modules, there is a need for extensions supporting inter-module recursion.
One of the stumbling blocks in designing such extensions is the interac-tion of module-level recursion and core-level computational effects. Value
recursion offers (in combination with standard recursion) an enhancedcontrol of this interaction.

* Type Systems for Value Recursion [11, 18, 25, 26]. Value recursion intro-duces a new form of error, caused by an attempt to use a recursive variable

before it is bound to a value (we call such a variable unresolved). It is desir-able to have type systems (or program analyses) allowing static detection
of such errors.

Acknowledgments
We would like to thank Levent Erk"ok and Magnus Carlsson for very fruitfuldiscussions and comments. We would also like to thank Sungwoo Park for pointing
out an error in one of the examples in an earlier version of the paper. Finally thecomments and questions by the referees were quite helpful in improving the paper
and its presentation.

References
[1] Ancona, D. Modular Formal Frameworks for Module Systems. PhD thesis, Univ. di Pisa,

1998.
[2] Ancona, D., Fagorzi, S., Moggi, E., and Zucca, E. Mixin modules and computational

effects. In Proc. 30th Int'l Coll. Automata, Languages, and Programming (2003), vol. 2719
of LNCS, Springer-Verlag.
[3] Ancona, D., and Zucca, E. A primitive calculus for module systems. In Proc. Int'l Conf.

Principles & Practice Declarative Programming (1999), vol. 1702 of LNCS, Springer-Verlag,
pp. 62-79.
[4] Ancona, D., and Zucca, E. A calculus of module systems. J. Funct. Programming 12, 2

(March 2002), 91-132. Extended version of [3].
[5] Ariola, Z. M., and Felleisen, M. The call-by-need lambda calculus. Journal of Functional

Programming 7, 3 (May 1997), 265-301.
[6] Ariola, Z. M., Maraist, J., Odersky, M., Felleisen, M., and Wadler, P. A call-byneed lambda calculus. In Conference record of POPL '95, 22nd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages: papers presented at the Symposium:
San Francisco, California, January 22-25, 1995 (New York, NY, USA, 1995), ACM Press,
pp. 233-246.
[7] Barendregt, H. P. The Lambda Calculus: Its Syntax and Semantics, revised ed. NorthHolland, 1984.
[8] Bawden, A. Letrec and callcc implement references. Message to comp.lang.scheme, 1988.

TITLE WILL BE SET BY THE PUBLISHER 25
[9] Benton, N., and Hyland, M. Traced pre-monoidal categories. In Fixed Points in Computer

Science (July 20-21 2002), Z. 'Esik and A. Ing'olfsd'ottir, Eds., vol. NS-02-2 of BRICS Notes
Series, pp. 12-19.
[10] Boudol, G. The recursive record semantics of objects revisited. Lecture Notes in Computer

Science 2028 (2001), 269-283.
[11] Boudol, G. The recursive record semantics of objects revisited. J. Funct. Programming

(2002). To appear.
[12] Boudol, G., and Zimmer, P. Recursion in the call-by-value *-calculus. In Fixed Points in

Computer Science, BRICS Notes Series NS-02-2 (2002).
[13] Bracha, G. The Programming Language Jigsaw: Mixins, Modularity, and Multiple Inheritance. PhD thesis, Univ. of Utah, Mar. 1992.
[14] Carlsson, M. Value recursion in the continuation monad. Unpublished Note, Jan. 2003.
[15] Cook, W. A Denotational Semantics of Inheritance. PhD thesis, Brown University, 1989.
[16] Cook, W., and Palsberg, J. A denotational semantics of inheritance and its correctness.

In Conf. on Object-Oriented Programming:Systems, Languages and Applications (1989),
ACM.
[17] Cousineau, G., Curien, P. L., and Mauny, M. The categorical abstract machine. In Functional Programming Languages and Computer Architecture (Sept. 1985), J.-P. Jouannaud,
Ed., vol. 201 of Lecture Notes in Computer Science, Springer Verlag, pp. 50-64.
[18] Dreyer, D., Harper, R., and Crary, K. A type system for well-founded recursion. Tech.

Rep. CMU-CS-03-163, Carnegie Mellon University, 2003.
[19] Erk"ok, L. Value Recursion in Monadic Computations. PhD thesis, OGI School of Science

and Engineering, OHSU, Portland, Oregon, 2002.
[20] Erk"ok, L., and Launchbury, J. Recursive monadic bindings. In Proceedings of the ACM

Sigplan International Conference on Functional Programming (ICFP-00) (N.Y., Sept. 18-
21 2000), vol. 35.9 of ACM Sigplan Notices, ACM Press, pp. 174-185.
[21] Erk"ok, L., Launchbury, J., and Moran, A. Semantics of value recursion for monadic

input/output. Journal of Theoretical Informatics and Applications 36, 2 (2002), 155-180.
[22] Filinski, A. Representing monads. In Conf. Record of 21st ACM SIGPLAN-SIGACT Symp.

on Principles of Programming Languages, POPL'94, Portland, OR, USA, 17-21 Jan. 1994.
ACM Press, New York, 1994, pp. 446-457.
[23] Friedman, D. P., and Sabry, A. Recursion is a computational effect. Tech. Rep. 546,

Computer Science Department, Indiana University, Dec. 2000.
[24] GHC Team, T. The glasgow haskell compiler user's guide, version 4.08. Available online

from http://haskell.org/ghc/. Viewed on 12/28/2000.
[25] Hirschowitz, T. Mixin Modules, Modules and Extended Value Binding in a Call-By-Value

Setting. PhD thesis, Univ. Paris 7, 2003.
[26] Hirschowitz, T., and Leroy, X. Mixin modules in a call-by-value setting. In Programming

Languages & Systems, 11th European Symp. Programming (2002), vol. 2305 of LNCS,
Springer-Verlag, pp. 6-20.
[27] Hirschowitz, T., Leroy, X., and Wells, J. B. Compilation of extended recursion in callby-value functional languages. In Proc. 5th Int'l Conf. Principles & Practice Declarative
Programming (2003).
[28] Hughes, J. Generalising monads to arrows. Sci. Comput. Program. 37, 1-3 (2000), 67-111.
[29] Report on the programming language Haskell 98, Feb. 1999.
[30] Jones, M. P., and Peterson, J. C. Hugs 1.4 User Manual. Research Report

YALEU/DCS/RR-1123, Yale University, Department of Computer Science, 1997.
[31] Kelsey, R., Clinger, W., and (Editors), J. R. Revised5 report on the algorithmic language Scheme. ACM SIGPLAN Notices 33, 9 (Sept. 1998), 26-76.
[32] Landin, P. J. The mechanical evaluation of expressions. The Computer Journal 6, 4 (Jan.

1964), 308-320.
[33] Launchbury, J., Lewis, J. R., and Cook, B. On embedding a microarchitectural design

language within Haskell. In Proc. 1999 Int'l Conf. Functional Programming (1999), ACM
Press, pp. 60-69.

26 TITLE WILL BE SET BY THE PUBLISHER

[34] Maraist, J., Odersky, M., and Wadler, P. The call-by-need lambda calculus. Journal of

Functional Programming 8, 3 (May 1998), 275-317.
[35] Moggi, E., and Fagorzi, S. A monadic multi-stage metalanguage. In Proc. FoSSaCS '03

(2003), vol. 2620 of LNCS, Springer-Verlag.
[36] Morris, J. H. Lambda-Calculus Method of Programming Language. PhD thesis, MIT, Dec.

1968.
[37] Paterson, R. A new notation for arrows. In Proceedings of the sixth ACM SIGPLAN

international conference on Functional programming (2001), ACM Press, pp. 229-240.
[38] Power, J., and Robinson, E. Premonoidal categories and notions of computation. Mathematical Structures in Computer Science 7, 5 (1997), 453-468.
[39] Waddell, O., Sarkar, D., and Dybvig, R. K. Robust and effective transformation of

letrec. In Scheme Workshop (Oct. 2002).
[40] Wright, A., and Felleisen, M. A syntactic approach to type soundness. Information and

Computation 115, 1 (1994), 38-94.

Communicated by (The editor will be set by the publisher).
(The dates will be set by the publisher).