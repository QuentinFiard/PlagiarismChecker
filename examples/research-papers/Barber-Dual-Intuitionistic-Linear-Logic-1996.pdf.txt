

Dual Intuitionistic Linear Logic

Andrew Barber
Department of Computer Science

University of Edinburgh

September 23, 1996

Abstract: We present a new intuitionistic linear logic, Dual Intuitionistic Linear Logic, designed to reflect the motivation of exponentials as translations of intuitionistic types, and provide it with a term calculus, proving associated standard
type-theoretic results. We give a sound and complete categorical semantics for the
type-system, and consider the relationship of the new type-theory to the more familiar presentation found for example in [4].

1 Introduction and Motivation
1.1 Background
Linear Logic is a resource logic introduced by Girard in [7]. One focus of attention in thisfield has been the type theory of various intuitionistic versions of Linear Logic, which in

general have as their term calculi resource-sensitive versions of the *-calculus. For example,
[4, 13, 14, 1] all propose systems of this form.In this report, we will refer to [4] for a commonly used and well understood term

calculus for Intuitionistic Linear Logic, ILL. We recall the most important rules of thatsystem in a natural deduction form, with their term annotation:

Weakening \Gamma  ` t : B \Delta  ` u :!A\Gamma , \Delta  ` discard u in t : B Dereliction \Gamma  ` t :!A\Gamma  ` derelict(t) : A

Contraction \Gamma , x :!A, y :!A ` t : B \Delta  ` u :!A\Gamma , \Delta  ` copy u as x, y in t : B
Promotion x1 :!A1, . . . , xn :!An ` t : B {\Delta i ` ui :!Ai}i=1..n\Delta 

1, . . . , \Delta n ` promote ~u for ~x in t :!B

The reason for the complexity of these rules is that previous calculi [1] were not ableto prove the following important substitution property:

\Gamma  ` t : A and \Delta , x : A ` u : B imply \Gamma , \Delta  ` u[t/x] : B

1

Now in this presentation we can immediately see that in constrast to the normal situ-ation of natural deduction, the !-connective has rules which do not fall easily into the
introduction/elimination mould. In the term calculus, this has the consequence that we donot have a constructor and a destructor for the !, but instead we have four term constructs
with a correspondingly high number of equalities.We therefore introduce an alternative formulation of

ILL, called Dual Intuitionistic
Linear Logic (DILL), in which the exponential is seen as a way of translating from anintuitionistic context to a linear one. The name `Dual' is intended to refer to the double

context on the left, rather than any potential duality; the typing context of the logicis divided into two parts, one linear and one intuitionistic. A general sequent has the
form \Gamma ; \Delta  ` A, which is interpreted as meaning that from intuitionistic assumptions in \Gamma and linear assumptions in \Delta  we can deduce

A. This splitting of the context leads to anextra intuitionistic axiom form, but the remainder of the rules are very similar to their

counterparts in ILL.Having outlined the form of the logic, we can see that the term calculus will be different to those referenced above, because of the split context. The introduction and elim-ination rules for ! are reflected in two new term constructs, one !

t :!A and the other
let !x : A be u :!A in t, which are a constructor-destructor pair analogous to those familiarin term assignment systems.

1.2 Related Work
As mentioned above, linear term calculi for variants of intuitionistic linear logic are notrare. The features of this presentation are essentially the split context, and the form of

the rules. The first of these seems originally to have been inspired by Girard [8], whoused the idea in an all-encompassing system,

LU. Then Miller remarked on the possibilityof adapting the idea to Plotkin, who designed the system considered here [11]. In fact,

DILL corresponds at the level of provability to the so-called "intuitionistic fragment" of LU,although it is not clear whether this holds at the level of proofs.

Wadler [15, 14] also adapted Girard's idea to an intuitionistic framework, but with aslightly different syntax and development to ours. Another approach which is different
in focus is Benton's [2]; there, he develops a logic and term calculus for a particular set
of categorical models of ILL, which we will mention later in the discussion on semantics.His logic is somewhat non-standard in that it has two notions of sequent, one to represent

the intuitionistic case and one to represent the linear case. This is because his categoricalmodels take the form of an adjunction between a cartesian closed category (CCC) and a
symmetric monoidal closed category (SMCC).We should note that the idea of using a SMCC with a monoidal adjunction to a CCC
as a model of ILL is due to a number of researchers. In particular, this model is presentedin Benton's paper as cited above, and its motivation is presented in Bierman [6].

2

1.3 Structure of the Report
The structure of this report is as follows. Firstly, we present the logic, DILL and show someequivalences which are inherent in the rules. We then present the type-system associated

with the logic, give the equality relation on the terms, and prove some fundamental type-theoretic results about the system. Having established the syntactic framework, we go on
to consider categorical models, and prove that the term-system is sound and complete withrespect to a certain class of categorical models.

We then consider the relationship between DILL and ILL. We map DILL into ILL andv.v., and show that the two mappings make

DILL a conservative extension of ILL at the levelof proofs, or equivalently terms. Finally, we give some category-theoretic consequences of

this result and consider further work.

2 The Logic
We now introduce the logic. In order to make it more applicable, we incorporate primitivetypes and functions of one argument over those primitive types. We can express this

information in the form of a graph.
A Base Graph of Objects and Arrows We assume that there exists a graph G ofobjects

Ob(G) and arrows between them G(A, B) for A, B 2 Ob(G) as a basis for the typesystem.

We will refer to the new logic as D(G)or simply DILL where no confusion is likely.We consider formulae:

A, B ::= Y 2 Ob(G) | I | A-ffiB | A \Omega  B | !A
A sequent in this system has the form: \Gamma ; \Delta  ` A, where we understand \Gamma  to be a set offormulae (the intuitionistic assumptions), and \Delta  to be a multiset of formulae (the linear
assumptions), with A a formula. Note that we use the "," to mean either set union ormultiset union as appropriate to the context.

3

2.1 The Rules

(I nt - Ax) \Gamma , A; ` A (Lin - Ax) \Gamma ; A ` A

(Graph) \Gamma ; \Delta  ` B\Gamma ; \Delta  ` A (if G(A, B) 6= ;)

(I - I) \Gamma ; ` I (I - E) \Gamma ; \Delta 1 ` I \Gamma ; \Delta 2 ` A\Gamma ; \Delta 1, \Delta 2 ` A
(\Omega  - I) \Gamma ; \Delta 1 ` A \Gamma ; \Delta 2 ` B\Gamma ; \Delta 1, \Delta 2 ` A \Omega  B (\Omega  - E) \Gamma ; \Delta 1 ` A \Omega  B \Gamma ; \Delta 2, A, B ` C\Gamma ; \Delta 1, \Delta 2 ` C
(-ffiI ) \Gamma ; \Delta , A ` B\Gamma ; \Delta  ` A-ffiB (-ffiE) \Gamma ; \Delta 1 ` A-ffiB \Gamma ; \Delta 2 ` A\Gamma ; \Delta 1, \Delta 2 ` B
(! - I) \Gamma ; ` A\Gamma ; `!A (! - E) \Gamma ; \Delta 1 `!A \Gamma , A; \Delta 2 ` B\Gamma ; \Delta 1, \Delta 2 ` B
As remarked in the introduction, we have replaced the four rules involving the !-connective in the original form of

ILL with the introduction-elimination pair seen above.The contraction and weakening rules previously used are now derivable by virtue of the

fact that we allow contraction and weakening in the intuitionistic side of the context.It is also important to notice that in the rule !-I, we specify that a particular sequent
use no linear assumptions. This is intuitively because we need to be able to use the sequentrepeatedly.

2.2 The Cut Rules
Because we have a logic with two different regions on the left, there will be two cut rules,one in which the cut formula occurs to the left of the semicolon (the intuitionistic region)

and one in which the cut formula occurs to the right of the semicolon (the linear region.These are stated as follows:

(I - Cut) \Gamma , A; \Delta  ` B \Gamma ; ` A\Gamma ; \Delta  ` B (L - Cut) \Gamma ; \Delta 1, A ` B \Gamma ; \Delta 2 ` A\Gamma ; \Delta 1, \Delta 2 ` B
Note that in the intuitionistic cut rule, the linear region of the sequent proving the cutformula is constrained to be empty. This is because the sequent using the cut formula as
an intuitionistic assumption may use it arbitrarily many times (or none).
Cut-Elimination Having introduced these cut rules, we can immediately show that theyare admissible in the system without cuts:

Lemma 2.1 (Intuitionistic Cut)If \Gamma 

, A; \Delta  ` B and \Gamma ; ` A, then \Gamma ; \Delta  ` B without using cuts.

4

Lemma 2.2 (Linear Cut)If \Gamma ; \Delta 

1, A ` B and \Gamma ; \Delta 2 ` A, then \Gamma ; \Delta 1, \Delta 2 ` B without using cuts.

We give the proofs of these lemmas in the typing section, where they will be restatedas substitution lemmas.

2.3 Equivalences
We now go on to state a number of defining equivalences for the connectives, which confirmtheir behaviour as that familiar in a more conventional presentation of intuitionistic linear

logic. The justification for this new system is based in large part on the fact that everyproof using an exponential type is equivalent to one using an intuitionistic type (which is
the base type of the exponential).
Lemma 2.3 (!-Equivalence)In the presence of the cut rules, the two-way proof rule:

\Gamma , A; \Delta  ` B
\Gamma ; !A, \Delta  ` B

is equivalent in strength to the (! - I), (! - E) pair introduced earlier.

Proof If we have the two-way proof rule and the cut rules, then we can use the followingdeduction to give ! -

I:

\Gamma ; ` A

; !A `!A
A; `!A
\Gamma ; \Delta  `!A

Further, we can prove ! - E with the following derivation:

\Gamma ; \Delta 1 `!A

\Gamma , A; \Delta 2 ` B
\Gamma ; !A, \Delta 2 ` B
\Gamma ; \Delta 1, \Delta 2 ` B

Going the other way, it is easy to derive both directions of the equivalence given the(! -

I ), (! - E) pair. The forward direction follows from one use of !-E, and the otherdirection is an instance of linear cut and derived weakening:

\Gamma , A; ` A
\Gamma , A; `!A \Gamma , A; !A, \Delta  ` B

\Gamma , A; \Delta  ` B

\Xi 

We give similar results for the other connectives:

5

Lemma 2.4 (Equivalences)In the presence of the linear cut rule:

* The two-way proof equivalence \Gamma ; \Delta  ` C\Gamma ; \Delta , I ` C is equal in strength to the I - I, I - E

pair.

* The two way proof equivalence \Gamma ; \Delta , A, B ` C\Gamma ; \Delta , A \Omega  B ` C is equal in strength to the \Omega -I , \Omega -E

pair.

* The two way proof equivalence \Gamma ; \Delta , A ` B\Gamma ; \Delta  ` A-ffiB is equal in strength to the -ffi-I , -ffi- E

pair.

These are all proved in a similar way to that for !.
We also have:

Lemma 2.5\Gamma ;

A, \Delta  ` B implies \Gamma , A; \Delta  ` B.

Proof This is also proved via a straightforward weakening and linear cut.

3 The Type System and its Basic Theory
We construct pre-terms as follows:

t ::= x | f (t) for f 2 G(A, B) | * | let * be t in u | t1 \Omega  t2|

let x \Omega  y : A \Omega  B be t in u | *x : A.t | tu | !t | let !x : A be t in u

where x ranges over a countably infinite set of variables. The notion of free variables of apre-term

t, written FV(t), is defined inductively over the structure of t as follows:

FV(x) = {x}
FV(f (t)) = FV(t)

FV(*) = ;
FV(let * be u in t) = FV(u) [ FV(t)

FV(t \Omega  u) = FV(t) [ FV(u)
FV(let x \Omega  y be u in t) = FV(u) [ (FV(t) - {x, y})

FV(*x.t) = FV(t) - {x}

FV(tu) = FV(t) [ FV(u)
FV(let !x be u in t) = FV(u) [ (FV(t) - {x})

FV(!t) = FV(t)

6

We define substitution for free variables and hence ff-conversion as normal, noting onlythat

(let x \Omega  y be t in u)[v/z] = let x \Omega  y be t[v/z] in u[v/z] if y 62 {x, y})
and similarly for let !x be t in u.Although we have defined pre-terms with type information incorporated, in the rest of

this report we will omit the types for derivable terms, where they can be inferred from the
derivation.

3.1 The Term Rules
Define a typing to be a pair x : A where x is a variable and A is a formula of the logic.We now define an environment to be a pair of sequences of typings in which no variable

occurs twice. The intention is that the first sequence in the pair is the sequence of typingsof `intuitionistic' formulae (those to the left of the semicolon) and the second sequence in
the pair is the sequence of typings of the `linear' formulae.We commonly write a type assignment in this system as \Gamma ; \Delta  `

t : A, where \Gamma ; \Delta  isan environment. In the following, it is assumed that in addition (\Gamma 

1; \Delta 1) and (\Gamma 2; \Delta 2) areenvironments.

(Int - Ax) \Gamma , x : A; ` x : A (Lin - Ax) \Gamma ; x : A ` x : A
(Graph) \Gamma ; \Delta  ` t : A\Gamma ; ` f (t) : B (f 2 G(A, B))

(I - I) \Gamma ; ` * : I (I - E) \Gamma ; \Delta 1 ` t : I \Gamma ; \Delta 2 ` u : A\Gamma ; \Delta 1, \Delta 2 ` let * be t in u : A
(\Omega  - I ) \Gamma ; \Delta 1 ` t : A \Gamma ; \Delta 2 ` u : B\Gamma ; \Delta 1, \Delta 2 ` t \Omega  u : A \Omega  B (\Omega -E) \Gamma ; \Delta 1 ` u : A\Omega B \Gamma ; \Delta 2, x : A, y : B ` t : C\Gamma ; \Delta 1, \Delta 2 ` let x\Omega y : A\Omega B be u in t : C
(-ffiI) \Gamma ; \Delta , x : A ` t : B\Gamma ; \Delta  ` (*x : A.t) : (A-ffiB) (-ffiE) \Gamma ; \Delta 1 ` u : A-ffiB \Gamma ; \Delta 2 ` t : A\Gamma ; \Delta 1, \Delta 2 ` (ut) : B
(! - I ) \Gamma ; ` t : A\Gamma ; `!t :!A (! - E) \Gamma ; \Delta 1 ` u :!A \Gamma , x : A; \Delta 2 ` t : B\Gamma ; \Delta 1, \Delta 2 ` let !x : A be u in t : B

A term is a pre-term of the term calculus DILL over the graph G (which we will writeD(
G)) which can be shown to annotate the conclusion of a sequent using these rules. Wewill represent a term and the sequent which witnesses it as the typing \Gamma ; \Delta  `

t : A ingeneral.

3.2 Results
We now give some easy type-theoretic results about this system, including weakening andstrengthening (both in the intuitionistic assumptions) and prove subject reduction.

7

Lemma 3.1 (Typing Properties)We have the following in the type system

DILL:

Free Variables I If \Gamma ; \Delta  ` t : A, then FV(t) ` dom(\Gamma ) [ dom(\Delta ).
Free Variables II If \Gamma ; \Delta , x : A ` t : B, then x is free precisely once in t.
Intuitionistic Weakening If \Gamma ; \Delta  ` t : A, then \Gamma , x : B; \Delta  ` t : A.
Intuitionistic Strengthening If x : A, \Gamma ; \Delta  ` t : B and x 62 FV(t), then \Gamma ; \Delta  ` t : B.
Environment Weakening If \Gamma ; \Delta , x : A ` t : B, then \Gamma , x : A; \Delta  ` t : B.
Environment Strengthening If \Gamma , x : A; \Delta  ` t : B and x occurs precisely once free, notunder a !-construct, in

t, then \Gamma ; \Delta , x : A ` t : B.

!-Equivalence if \Gamma ; x :!A, \Delta  ` u : B, then

\Gamma , y : A; \Delta  ` u[!y/x] : B
and if \Gamma , y : A; \Delta  ` v : B, then

\Gamma ; x :!A, \Delta  ` let !y be x in v : B
Further, the maps u 7! u[!y/x] and v 7! let !y be x in v are inverse in both directions.
Linear Cut If \Gamma ; \Delta 1, x : A ` t : B and \Gamma ; \Delta 2 ` u : A, then \Gamma ; \Delta 1, \Delta 2 ` t[u/x] : B.
Intuitionistic Cut If \Gamma , x : A; \Delta  ` t : B and \Gamma ; ` u : A, then \Gamma ; \Delta  ` t[u/x] : B.

As an example, we outline the proof of the linear cut lemma. That of the intuitionisticcut is similar.

Proof: The proof proceeds by induction on the structure of t. Note that since x : A is alinear typing,

x must be free in t, by our previous result.

If t is y then y is x, since x is free in y, and hence the required sequent is the secondpremise.

If t is *y : B.v then we know that we must have a derivation:

\Gamma , y : B; x : A0\Delta 1 ` v : C
\Gamma ; x : A, \Delta 1 ` (*y : B.v) : B ! C

By the induction hypothesis on the premise, we now have:

\Gamma , y : B, \Delta 1, \Delta 2 ` v[u/x] : C
and the required sequent follows by one abstraction.

8

If t is let !z : c be w in v : B then we know that we have a derivation:

\Gamma , z : C; \Delta 1 ` v : B \Gamma ; \Delta 01 ` w :!C
\Gamma ; \Delta 1, \Delta 01 ` (let !z : C be w in v : B) : B

where x : A occurs in either \Delta 1 or \Delta 2. In either case we can use the induc-tion hypothesis to obtain the result required, since substitution commutes with the
let construction by definition.
Other Cases The other cases proceed similarly.

Intuitionistic and Linear Free Variables In view of the first free-variable lemmaabove, we say that

x 2 FV(t) is a linear free variable of a derivation \Gamma ; \Delta  ` t : A if for some
B we have x : B 2 \Delta . Correspondingly, x is an intuitionistic free variable if for some Bwe have

x : B 2 \Gamma .

3.3 Term Contexts
In order to present the type theory, we will need to define a notion of contexts, where thesemay be linear (ie, use their `argument' linearly) or intuitionistic (eg, use their argument

inside a !-construct).We define a general context as follows:

[Contexts] A context C[ ] is an object constructed recursively as follows:
C[ ] := | let * be C[ ] in t | let * be t in C[ ] | t \Omega  C[ ] | C[ ] \Omega  t |

let x \Omega  y be C[ ] in t | let x \Omega  y be t in C[ ] | *x.C[ ] | C[ ]t | tC[ ] |
!C[ ] | let !x be C[ ] in t | let !x be t in C[ ]

Note that this definition implies that there will be precisely one occurence of the symbolin every context.

We say that a context is linear if it is constructed from the above structure withoutthe use of the clause !

C[ ]. Further, a context binds a variable x if the context is constructed with the use of clauses let x \Omega  y be t in C[ ], let y \Omega  x be t in C[ ], *x.C[ ] orlet !

x be t in C[ ].Now define

C[t] for a given context C[ ] and term t to be the context C[ ] with theunique occurence of the symbol replaced by the term

t. We can easily show by inductionover contexts that
C[t] is a pre-term.

3.4 The Term Equality
We present the equality we will use on the terms. An assertion of equality has the followingform: \Gamma ; \Delta  `

t =A u where this is well formed iff both t and u are typable of type A in thegiven environment \Gamma ; \Delta .

9

We first need to specify that the equality is reflexive, transitive and symmetric:

\Gamma ; \Delta  ` t : A
\Gamma ; \Delta  ` t =A t

\Gamma ; \Delta  ` t =A u \Gamma ; \Delta  ` u =A v

\Gamma ; \Delta  ` t =A v

\Gamma ; \Delta  ` t =A u
\Gamma ; \Delta  ` u =A t

Now we allow equality inside generic contexts C[ ].

\Gamma ; \Delta  ` t =A u \Gamma ; \Delta 0 ` C[t] : B \Gamma ; \Delta 0 ` C[u] : B

\Gamma ; \Delta , \Delta 0 ` C[t] =B C[u]

The fi and j equalities are as follows:

(Ifi) \Gamma ; \Delta  ` let * be * in t : A\Gamma ; \Delta  ` let * be * in t =

A t (Ij)

\Gamma ; \Delta  ` let * be t in * : I
\Gamma ; \Delta  ` let * be t in * =I t

(\Omega fi) \Gamma ; \Delta  ` let x\Omega y be v \Omega u in t : C\Gamma ; \Delta  ` let x\Omega y be v \Omega u in t =

C t[v, u/x, y] (\Omega j)

\Gamma ; \Delta  ` let x\Omega y be v in x\Omega y : A\Omega B
\Gamma ; \Delta  ` let x\Omega y be v in x\Omega y =A\Omega B t

(-ffifi) \Gamma ; \Delta  ` (*x : A.t)u : A\Gamma ; \Delta  ` (*x : A.t)u =

A t[u/x] (-ffi

j) \Gamma ; \Delta  ` *x : A.(tx) : A-ffiB\Gamma ; \Delta  ` *x : A.(tx) =

A-ffiB t

(!fi) \Gamma ; \Delta  ` let !x : A be !u in t : B\Gamma ; \Delta  ` let !x : A be !u in t =

B t[u/x] (!j)

\Gamma ; \Delta  ` let !x : A be u in !x :!A
\Gamma ; \Delta  ` let !x : A be u in !x =!A u

Further to these equalities, we need some extra equalities which correspond to proof-rule
permutations (the so-called commuting conversions). In other presentations of term calculifor

ILL, the proof permutations are expressed as a large number of primitive equalities suchas:

\Gamma ; \Delta  ` let x \Omega  y be t in u \Omega  v
\Gamma ; \Delta  ` u \Omega  (let x \Omega  y be t in v)

where x, y are not free in u.We replace these by schematic versions where a general context is used to bring together

the primitive equalities into classes. For example, the equality above would be an instanceof our second equality rule, where the context

C is v \Omega  .

* For linear contexts C:

\Gamma ; \Delta  ` let * be t in C[u] : A
\Gamma ; \Delta  ` let * be t in C[u] =A C[let * be t in u]

* For linear contexts C which do not bind x : A or y : B:

\Gamma ; \Delta  ` let x \Omega  y be t in C[u] : A
\Gamma ; \Delta  ` let x \Omega  y be t in C[u] =A C[let x \Omega  y be t in u]

10

* For linear contexts C which do not bind x : A:

\Gamma ; \Delta  ` let !x be t in C[u] : A
\Gamma ; \Delta  ` let !x be t in C[u] =A C[let !x be t in u]

Note that when we use these rules to prove an equality between two terms, becausesuch an equality is only well-formed when both terms are typable, we must demonstrate

that this is the case for our candidate terms. Fortunately, this is normally trivial and sowe will freely omit these typings except where necessary.

Although there is an obvious way to give a rewrite system for this equality, we do notpursue this possibility here. Instead, we discuss this in the further work section of this
report.
A Note on the Commuting Conversions of ! - E Notice that the restriction on thecontext in the !-commuting conversion rules out the following (well-typed) equality:

y :!A; `!(let !x be y in x) =A let !x be y in !x
This equality corresponds to imposing an extra requirement on models which cannot bemotivated from the proof structure of linear logic.

3.5 A Definable Intuitionistic Function Space
We now briefly present a definable extension to the logic and term calculus given above.In order to make the syntax more useable, we show how we can define the types and terms

associated with an intuitionistic arrow type purely in terms of the structures we alreadyhave.

Formulae and Types We define the formula A ! B in our new system as the formula!

A-ffiB. Now we have the derived introduction/elimination pair:

(! -I) \Gamma , A; \Delta  ` B\Gamma ; \Delta  ` A ! B (! -E) \Gamma ; \Delta  ` A ! B \Gamma ; ` A\Gamma ; \Delta  ` B
On terms, we define the abstraction and application as follows (where we use fl for theabstraction):

flx : A. t = *x0 :!A let !x be x0 in t

tu = t(!u)
Now it can be proved that using the equalities already defined we have the following:

(! fi) \Gamma ; \Delta  ` (flx : A.t)u : A\Gamma ; \Delta  ` (flx : A.t)u =

A t[u/x] (! j)

\Gamma ; \Delta  ` flx : A.(tx) : A ! B

\Gamma ; \Delta  ` flx : A.(tx) =A!B t

Hence this construct and its associated terms and equalities can be used as primitivewithout changing the development to follow. Other definitions of this function space are

possible via more complex embeddings of intuitionistic logic into linear logic; for examplesee Benton [5] or Schellinx [12].

11

4 Categorical Semantics
We now show that DILL can be soundly and completely mapped into a class of models forlinear logic. By this we mean that we can map proofs in the logic, as terms, to morphisms
in the model in such a way that any two proofs are equal in the logic if and only if theyare equal in every model of the class.

We start by presenting the class of models we will consider.

4.1 Linear-non-Linear Models
The models we will consider are called Linear-non-Linear models (commonly abbreviated to
LNL-models) by Benton in his paper [2]. These are symmetric monoidal closed categories(SMCC's) which have a monoidal adjunction to a cartesian closed category (CCC). The

intention behind the construction is that the normal power of intuitionistic logic shouldbe modelled in the CCC, with the intuitionistic linear logic being as usual modelled in the
SMCC. This idea emerged in 1993 from discussions between a number of people, includingPlotkin, Benton and Hyland. However, it was only during further work by Benton [2] that
it became clear that it was necessary to impose the requirement that the adjunction bemonoidal. In the referenced work by Benton there is an extensive comparison between
these models and the previously proposed models [4]. We discuss further the connectionsbetween this work and ours at the end of this report.

4.2 Definitions
We now present the definition of LNL model, in stages. For brevity, we present the coher-ence diagrams in the form of equalities.

Symmetric Monoidal Closed Categories A Symmetric Monoidal Closed Category isa category C with a bifunctor \Omega  : C * C ! C and natural isomorphisms

ffA,B,C : (A \Omega  B) \Omega  C ! A \Omega  (B \Omega  C)

riA : I \Omega  A ! A

liA : A \Omega  I ! A
oeA,B : A \Omega  B ! B \Omega  A

s.t.

12

(ffA,B,C \Omega  idD); ffA,(B\Omega C),D; (idA \Omega  ffB,C,D) = ff(A\Omega B),C,D; ffA,B,(C\Omega D)(1)

ffA,I,B; (idA \Omega  ilB) = (irA \Omega  idB) (2)

liI = riI (3)
(oeA,B \Omega  idC); ffB,A,C; l(idB \Omega  oeA,C ) = ffA,B,C; oeA,(B\Omega C); ffB,C,A(4)

oe-1A,B = oeB,A (5)
oeI,A; ilA = irA (6)

and s.t. \Omega  B a B-ffi , or

C(A \Omega  B, C) ' C(A, B-ffiC)
where the isomorphism is natural in A and C.

Cartesian Closed Categories We assume familiarity with the standard definition ofCartesian Closed Categories (CCC's henceforth). However, it is important to note that a
CCC is merely a SMCC in which the tensor is Cartesian.
Symmetric Monoidal Functor We now need to define the concept of functor betweentwo SMCCs. A symmetric monoidal functor

(F, mA,B , mI ) : (C, \Omega , I , ff, li, ri, oe) ! (C0, \Omega 0, I 0, ff0, li0, ri0, oe0)
is a functor F : C ! C0 with a map mI : I0 ! F (I) and a natural transformation
mA,B : F (A) \Omega 0 F (B) ! F (A \Omega  B) s.t.

ff0F A,FB,F C ; (idFA \Omega 0 mB,C); mA,B\Omega C = (mA,B \Omega 0 idF C ); mA\Omega B,C ; F (ffA,B,C)(7)

ri0FA = (mI \Omega  idF A); mI,A; F (riA) (8)
oe0F A,F B; mB,A = mA,B; F (oeA,B) (9)

Under this definition it is easy to check that given two symmetric monoidal functors(
F, mI , mA,B) and (G, nI0, nA,B) their compose is symmetric monoidal when equipped withmaps:

(GF, (nI0; G(mI )), (nF A,F B; G(mA,B)))

13

Monoidal Natural Transformation A monoidal natural transformation from one sym-metric monoidal functor (

F, mI0 , mA,B) to another (G, nI0, nA,B) is a natural transformation
fi : F ! G s.t.

mA,B ; fiA\Omega B = (fiA \Omega 0 fiB); nA,B (10)

mI0; fiI = nI0 (11)

4.2.1 LNL-Models
Now we define an LNL model to be a pair of categories (S, C) of which the first, S, is aSMCC and the second, C, is a CCC, with two symmetric monoidal functors

F : C ! Sand
G : S ! C which are adjoint, G ` F .

4.2.2 Contexts
We now make some definitions to simplify the interpretation. First, for a sequence ofobjects in the category S, ~

A = A1, A2, . . . An, we define N ~A to be the left-bracketedtensor of this sequence, or: O

~A = (..(A1 \Omega  A2) \Omega  . . . An)
Now for a sequence of objects ~A = A1 . . . An we define F G ~A to be the sequence F GA1, F GA2,. . . F GAn.Also, for a sequence of types

A1, . . . An, we define !(A1, . . . An) =!A1, . . .!An.

4.3 Interpretation
We now define an interpretation [[ ]] : D(G) ! (S, C) which takes the types and sequentsof

DILL over a graph G to a model M as follows:

Definition of [[ ]] on Types

[[X]] = I(X) for X 2 Ob(G)[[

I]] = I
[[A \Omega  B]] = [[A]] \Omega  [[B]][[

A-ffiB]] = [[A]]-ffi[[B]][[!

A]] = F G([[A]])

We extend this firstly to lists by saying that for a list A1 . . . An of types, [[A1, . . . An]] =N
([[A1]], . . . [[An]]) Secondly, we extend the definition to contexts by saying that for a context
A1, . . . An; B1, . . . Bn,

[[A1, . . . An; B1, . . . Bn]] = [[!A1, . . .!An, B1, . . . Bn]]

14

Now in order to interpret the sequents of DILL over a graph G into a LNL-model (S, C),we will need a primitive interpretation function I :

G ! S such that I : G(A, B) !S([[
A]], [[B]]) which tells us that we have enough morphisms in the category to model theprimitive graph.

Context Manipulation Arrows We can now define some context-manipulation arrows,using the structure we have in the model.

Define

perm ~A, ~B, ~C, ~D :([[ ~A]] \Omega  [[ ~B]]) \Omega  ([[ ~C]] \Omega  [[ ~D]]) ! ([[ ~A]] \Omega  [[ ~C]]) \Omega  ([[ ~B]] \Omega  [[ ~D]])

derA :[[!A]] ! [[A]]
lcon\Delta 1,\Delta 2 :[[\Delta 1, \Delta 2]] ! [[\Delta 1]] \Omega  [[\Delta 2]]
dupA1,...An :[[!(A1, . . . An)]] ! [[!(A1, . . . An)]] \Omega  [[!(A1, . . . An)]]

str\Gamma ,\Delta 1,\Delta 2 :[[\Gamma ; \Delta 1\Delta 2]] ! [[\Gamma ; \Delta 1]] \Omega  [[\Gamma ; \Delta 2]]
discA1,...An :[[!(A1, . . . An)]] ! I

prom\Gamma  :[[!(A1, . . . An)]] ! [[!!(A1, . . . An)]]

as follows:

perm ~A, ~B, ~C, ~D = ff[[ ~A]],[[ ~B]],[[ ~C]]\Omega [[ ~D]]; (id[[ ~A]] \Omega  ff-1[[ ~B]],[[ ~C]],[[ ~D]]); (id[[ ~A]] \Omega  (oe[[ ~B]],[[ ~C]] \Omega  id[[ ~D]]));

(id[[ ~A]] \Omega  ff[[ ~C]],[[ ~B]],[[ ~D]]); ff-1[[ ~A]],[[ ~C]],([[~B]]\Omega [[ ~D]])
derA = ffl[[A]]

lcon\Delta 1,\Delta 2 = 8????!????:

(lcon\Delta 1,\Delta 02 \Omega  id[[A]]); ff[[\Delta 1]],[[\Delta 02]],A;

(id[[\Delta 1]] \Omega  lcon-1\Delta 02,A) where \Delta 1 6= and \Delta 2 = \Delta 02, A
ri-1[[\Delta 2]] if \Delta 1 =
li-1[[\Delta 1]] if \Delta 2 =

dup\Gamma  = 8?!?:

dup\Gamma 0,A \Omega  (F (cG[[B]]); m-1G[[B]],G[[B]]); perm!(\Gamma 0,A),!(\Gamma 0,A),!B,!B if \Gamma  = \Gamma 0, A, B
F (cG[[A]]); m-1G[[A]],G[[A]] if \Gamma  = A
riI if \Gamma  =
str\Gamma ,\Delta 1,\Delta 2 = lcon!\Gamma ,(\Delta 1,\Delta 2); (dup\Gamma  \Omega  lcon\Delta 1,\Delta 2 ); perm!\Gamma ,!\Gamma ,\Delta 1,\Delta 2; (lcon-1!\Gamma ,\Delta 1 \Omega  lcon-1!\Gamma ,\Delta 2)

disc\Gamma  = 8?!?:

disc\Gamma 0,B \Omega  (F (dG[[A]]); m-11 ); ri-1I if \Gamma  = \Gamma 0, B, A
F (dG[[A]]); m-11 if \Gamma  = A
idI if \Gamma  =

prom\Gamma  = 8?!?:

prom\Gamma 0,B \Omega  F (jG[[A]]) if \Gamma  = \Gamma 0, B, A
F (jG[[A]]) if \Gamma  = A
idI if \Gamma  =

15

Definition of [[ ]] on Sequents: The interpretation will take a sequent \Gamma ; \Delta  ` t : A toan arrow

[[\Gamma ; \Delta  ` t : A]] : [[\Gamma ; \Delta ]] ! [[A]]
in the LNL category.[[ ]] is defined inductively over the structure of the derivation:

Linear Axiom Here we have:

[[\Gamma ; x : A ` x : A]] : [[\Gamma ; A]] ! [[A]]
= lcon!\Gamma ,A; (disc\Gamma  \Omega  id[[A]]); ri[[A]]

Intuitionistic Axiom Here, we have

[[\Gamma , x : A; ` x : A]] : [[\Gamma , A; ]] ! [[A]]
= lcon!\Gamma ,!A; (disc\Gamma  \Omega  derA); ri[[A]]

Primitive Arrow Rule We need to interpret the derivation:

\Gamma ; \Delta  ` t : A
\Gamma ; \Delta  ` f (t); B (for f 2 G(A, B))

Given an arrow [[\Gamma ; \Delta  ` t : A]] : [[\Gamma ; \Delta ]] ! [[A]], all we do is take the arrow

[[\Gamma ; \Delta  ` t : A]]; I(f ) : [[\Gamma ; \Delta ]] ! [[B]]

I-introduction Here we have:

[[\Gamma ; ` * : I]] : [[\Gamma ; ]] ! [[I]]

= disc\Gamma 

I-elimination We need to interpret the derivation

\Gamma ; \Delta 1 ` t : I \Gamma ; \Delta 2 ` u : A
\Gamma ; \Delta 1, \Delta 2 ` let * be t in u : A

In this case, we have arrows

f : [[\Gamma ; \Delta 1]] ! [[I]]

g : [[\Gamma ; \Delta 2]] ! [[A]]

Hence we have

[[\Gamma ; \Delta 1, \Delta 2 ` let * be t in u : A]] : [[\Gamma ; \Delta 1, \Delta 2]] ! [[A]]

= str\Gamma ,\Delta 1,\Delta 2; (f \Omega  g); ri[[A]]

16

\Omega -introduction The rule is:

\Gamma ; \Delta 1 ` t : A \Gamma ; \Delta 2 ` u : B

\Gamma ; \Delta 1, \Delta 2 ` t \Omega  u : A \Omega  B

Using the premises, we already have arrows

f : [[\Gamma ; \Delta 1]] ! [[A]]

g : [[\Gamma ; \Delta 2]] ! [[B]]

Hence we have

[[\Gamma ; \Delta 1, \Delta 2 ` t \Omega  u : A \Omega  B]] : [[\Gamma ; \Delta 1, \Delta 2]] ! [[A \Omega  B]]

= str\Gamma ,\Delta 1,\Delta 2 ; (f \Omega  g)

\Omega -Elimination The rule is

\Gamma ; \Delta 1 ` u : (A \Omega  B) \Gamma ; \Delta 2, x : A, y : B ` t : C

\Gamma ; \Delta 1, \Delta 2 ` let x \Omega  y be u in t : C

We have arrows:

f : [[\Gamma ; \Delta 1]] ! [[A \Omega  B]]

g : [[\Gamma ; \Delta 2, A, B]] ! [[C]]

Hence we have

[[\Gamma ; \Delta 1, \Delta 2 ` let x \Omega  y be u in t : C]] :[[\Gamma ; \Delta 1, \Delta 2]] ! [[C]]
= str\Gamma ,\Delta 1,\Delta 2 ; oe[[\Gamma ;\Delta 1]],[[\Gamma ;\Delta 2]]; (id[[\Gamma ;\Delta 2]] \Omega  f ); ff-1[[\Gamma ;\Delta 2]],[[A]],[[B]]; g

-ffi-introduction The rule is as follows:

\Gamma ; \Delta , x : A ` t : B
\Gamma ; \Delta  ` *x.t : A-ffiB

so we have an arrow:

f : [[\Gamma ; \Delta , A]] ! [[B]]

Hence we have

[[\Gamma ; \Delta  ` *x.t : A-ffiB]] :[[\Gamma ; \Delta ]] ! [[A-ffiB]]

= *(lcon-1(!\Gamma ,\Delta ),A; f )

17

-ffi-elimination The rule is:

\Gamma ; \Delta 1 ` u : (A-ffiB) \Gamma ; \Delta 2 ` t : A

\Gamma ; \Delta 1, \Delta 2 ` (ut) : B

so we have arrows:

f : [[\Gamma ; \Delta 1]] ! [[A-ffiB]]

g : [[\Gamma ; \Delta 2]] ! [[A]]

Hence we have

[[\Gamma ; \Delta 1, \Delta 2 ` (ut) : B]] : [[\Gamma ; \Delta 1, \Delta 2]] ! [[B]]
= str\Gamma ,\Delta 1,\Delta 2 ; (f \Omega  g); ap[[A]],[[B]]

!-introduction The rule is: \Gamma ; ` t : A

\Gamma ; `!t :!A
so we have an arrow:

f : [[\Gamma ; ]] ! [[A]]

Hence we have

[[\Gamma ; `!t :!A]] :[[\Gamma ; ]] ! [[!A]]
= prom\Gamma ; F G(f )

!-elimination The rule is:

\Gamma ; \Delta 1 ` u :!A \Gamma , x : A; \Delta 2 ` t : B

\Gamma ; \Delta 1, \Delta 2 ` let !x be u in t : B

Hence we have arrows:

f : [[\Gamma ; \Delta 1]] ! [[!A]]

g : [[\Gamma , A; \Delta 2]] ! [[B]]

Hence we have

[[\Gamma ; \Delta 1, \Delta 2 ` let !x be u in t : B]] : [[\Gamma ; ffi1, \Delta 2]] ! [[B]]
= str\Gamma ,\Delta 1,\Delta 2; (f \Omega  id[[\Gamma ;\Delta 2]]); (id[[!A]] \Omega  lcon!\Gamma ,\Delta 2 );ff-1[[!A]],[[!\Gamma ]],[[\Delta 2]]; (oe[[!A]],[[!\Gamma ]] \Omega  id[[\Delta 2]]);

(lcon-1!\Gamma ,!A \Omega  id[[\Delta 2]]); lcon-1(!\Gamma ,A),\Delta 2; g

18

4.4 Soundness
Having given the interpretation function [[ ]]M which takes terms of DILL into (the SMCCpart of) the LNL-model M, we now need to show that the interpretation is sound. That

is, we need to demonstrate that all the term equalities we have given in DILL are mappedto equalities in any LNL-model.

First we need to prove two technical lemmas, which show what the image of the twosubstitutions are in the model:

Lemma 4.1If [[\Gamma ; \Delta  `

t : A]] = f and [[\Gamma ; \Delta 0, x : A ` u : B]] = g, then

[[\Gamma ; \Delta , \Delta 0 ` u[t/x] : B]] = str\Gamma ,\Delta ,\Delta 0 ;(f \Omega  id[[\Gamma ;\Delta 0]]); oe[[A]]),[[\Gamma ;\Delta 0]]; lcon-1(!\Gamma ,\Delta ),A; g
Lemma 4.2If [[\Gamma ; `

t : A]] = f and [[x : A, \Gamma ; \Delta  ` u : B]] = g, then

[[\Gamma ; \Delta  ` u[t/x] : B]] = str\Gamma , ,\Delta ;((prom\Gamma ; F G(f )) \Omega  id[[\Gamma ;\Delta ]]); (id[[!A]] \Omega  lcon!\Gamma ,\Delta 2);

(oe[[!A]],[[!\Gamma ]] \Omega  id[[\Delta 2]]); (lcon-1!\Gamma ,!A \Omega  id[[\Delta 2]]); lcon-1!(\Gamma ,A),\Delta 2; g

These lemmas are proved by induction over the structure of the first term. The proofsare again left to the reader.

Now we are able to prove soundness by considering the derivation of any equality in
DILL.

Theorem 1 (Soundness)If \Gamma ; \Delta  `

t =A u then [[\Gamma ; \Delta  `

t : A]] = [[\Gamma ; \Delta  ` u : A]]

Proof
I - fi In this case, we have \Gamma ; \Delta  `

let * be * in t =A t

The interpretation of the left hand side is the arrow

str\Gamma , ,\Delta ; (disc\Gamma  \Omega  g); ri[[A]]
but

str\Gamma , ,\Delta ; (disc\Gamma  \Omega  id[[\Gamma ;\Delta ]]) = ri-1[[\Gamma ;\Delta ]]

so this is just g by naturality of ri.

I - j In this case we have \Gamma ; \Delta  `

let * be t in * =I t

The interpretation of the left-hand side of this is the arrow

str\Gamma ,\Delta , ; (f \Omega  disc\Gamma ); riI

19

but by a symmetric equality to that used above we have that this is

li-1[[\Gamma ;\Delta ]]; (f \Omega  idI ); riI
but now since riI = liI this is just f .
\Omega  - j First, note that

[[\Gamma ; x : A, y : B ` x \Omega  y : A \Omega  B]] = str\Gamma ,A,B; ((lcon!\Gamma ,A; (disc\Gamma  \Omega  id[[A]]); ri[[A]])\Omega 

(lcon!\Gamma ,B; (disc\Gamma  \Omega  id[[B]]); ri[[B]]))
= lcon!\Gamma ,(A,B); (disc\Gamma  \Omega  id[[A\Omega B]]); ri[[A\Omega B]]

This means that

[[\Gamma ; \Delta  ` let x \Omega  y be t in x \Omega  y]] = str\Gamma , ,\Delta ; (id[[\Gamma ; ]] \Omega  f ); ff-1[[\Gamma ; ]],A,B; lcon!\Gamma ,(AB);

(disc\Gamma  \Omega  idA\Omega B ); ri[[A]])
= str\Gamma , ,\Delta ; (id[[\Gamma ; ]] \Omega  f ); (disc\Gamma  \Omega  idA\Omega B); riA\Omega B
= str\Gamma , ,\Delta ; (disc\Gamma  \Omega  f ); riA\Omega B
= f

! - fi In this case,

[[\Gamma ; \Delta  ` let !x be !t in u : B]] =str\Gamma , ,\Delta ; ((prom\Gamma ; F G(f )) \Omega  id[[\Gamma ;\Delta ]]); (id[[!A]] \Omega  lcon!\Gamma ,\Delta 2 );

(oe[[!A]],[[!\Gamma ]] \Omega  id[[\Delta 2]]); (lcon-1!\Gamma ,!A \Omega  id[[\Delta 2]]); lcon-1!(\Gamma ,A),\Delta 2; g

which is just the interpretation of u[t/x].
* - fi In this case, assuming that [[\Gamma ; \Delta 1, A ` t : B]] = f and [[\Gamma ; \Delta 2 ` u : A]] = g, we have

[[\Gamma ; \Delta 1, \Delta 2 ` (*x.t)u : B]] =str\Gamma ,(\Delta 1,A),\Delta 2; (*(lcon-1(!\Gamma ,\Delta 1),A; f ) \Omega  g); ap[[A]],[[B]]

=str\Gamma ,\Delta 1,\Delta 2 ; (id[[\Gamma ;\Delta 1]] \Omega  g); lcon-1!\Gamma ,\Delta 1 ; f
=[[\Gamma ; \Delta 1, \Delta 2 ` t[u/x] : B]]

Reflexivity, Transitivity and Symmetry These cases are all trivial because categor-ical equality is a congruence.

Contexts It can be shown by induction over the structure of an arbitrary context that if

u = t, then [[C[u]]] = [[C[t]]], assuming this is a well-formed equality.

This shows soundness. \Xi 

20

4.5 Constructing the Term Model
The first stage in establishing completeness is to define the term model of DILL. It is clearthat we will as normal construct the term category to form the SMCC part of the model,

but we will need to use a somewhat more complex construction to provide the CCC part.
4.5.1 The Term Category
We define the term category T (G) for the graph G as follows:*

Ob(T (G) ) are the types of DILL over the graph G

* T (G) (A, B) = {[(x, t)]| ; x : A ` t : B}, where [(x, t)] is the equivalence class of(

x, t) over the equivalence j defined by:

(x, t) j (x, u) if ; x : A ` t =B u(
x, t) j (y, t[y/x])

Now define identities and substitution:*

idA = [(x, x)]

* [(x, t)]; [(y, u)] = [(x, u[t/y])]
Now it is easily demonstrated that these definitions give a category, given primitiveresults on substitution proved earlier. Further, we certainly have an appropriate interpretation function I which interprets the graph G into T (G) ; it is defined as follows:

I(f ) = (z, f (z)) : A ! B
where f 2 G(A, B).The next step is to show that the term category is in fact a SMCC. First we define:

[(x, t)] \Omega  [(y, u)] = [(z, let x \Omega  y be z in t \Omega  u)]
riA : I \Omega  A ! A = (z, let x \Omega  y be z in let * be x in y)
ri-1A : A ! I \Omega  A = (x, * \Omega  x)

liA : A \Omega  I ! A = (z, let x \Omega  y be z in let * be y in x)
li-1A : A ! A \Omega  I = (x, x \Omega  *)
ffA,B,C : A \Omega  (B \Omega  C) ! (A \Omega  B) \Omega  C = (w, let x \Omega  u be w in let y \Omega  z be u in (x \Omega  y) \Omega  z)
ff-1A,B,C : (A \Omega  B) \Omega  C ! A \Omega  (B \Omega  C) = (w, let u \Omega  z be w in let x \Omega  y be u in x \Omega  (y \Omega  z))

oeA,B : A \Omega  B ! B \Omega  A = (z, let x \Omega  y be z in y \Omega  x)
oe-1A,B : B \Omega  A ! A \Omega  B = oeB,A

21

4.5.2 N is a Functor
We need to show that the definition given above of the tensor is functorial. This amountsto showing that identities are preserved:

[(x, x)] \Omega  [(y, y)] = (w, let x \Omega  y be w in x \Omega  y)= (

w, w)=

id

and that composition is preserved. We show this in the second place of the functor, butthe proof for the first place is analogous.

[(x, x)] \Omega  ([(y, t)]; [(z, u)])= [(

w, let x \Omega  y be w in x \Omega  (u[t/z]))]= [(
w, let x \Omega  z be let x \Omega  y be w in x \Omega  t in x \Omega  u)]= ([(

x, x)] \Omega  [(y, t)]); ([(x, x)] \Omega  [(z, u)])

4.5.3 Naturality Issues
A SMCC must have natural isomorphisms as given above for the tensor. We need to checkthe naturality squares of each of these transformations in each variable.

riA There is one diagram to check here for naturality, and two equalities for isomorphism.

riA; (x, t)= (

z, t[let x0 \Omega  y0 be z in let * be x0 in y/x])
= (z, let x0 \Omega  y0 be z in let * be x0 in t[y/x])= (

z0, let x00 \Omega  x be z0 in let * be x00 in t)= (
z0, let x0 \Omega  y0 be let x00 \Omega  x be z0 in x00 \Omega  t in let * be x0 in y0)= (

idI \Omega  (x, t)); riB

This shows the naturality of ri. Now we check that it is a natural isomorphism; inone direction we have:

riA; ri-1A = (z, * \Omega  let x \Omega  y be z in let * be x in y)= (

z, z)

and in the other we have:

ri-1A ; riA = (w, let x \Omega  y be * \Omega  w in let * be x in y)= (

w, w)

liA The diagrams in this case are exactly analogous to the above ones, and hence areomitted.

22

ffA,B,C We first check naturality for this arrow.

ffA,B,C; ((x, t) \Omega  (y, u)) \Omega  (z, v)= (

w, let x0 \Omega  z
be (let x00 \Omega  w00 be w in let y00 \Omega  z00 be w00 in (x00 \Omega  y00) \Omega  z00)in let

x \Omega  y be x0 in (t \Omega  u) \Omega  v)
= (w, let x \Omega  w0 be w in let y \Omega  z be w00 in (t \Omega  u) \Omega  v)= (

w00, let x0 \Omega  w0
be let x \Omega  w000 be w00 in let y \Omega  z be w000 in t \Omega  (u \Omega  v)
in let y0 \Omega  z0 be w0 in (x0 \Omega  y0) \Omega  z0= (

x, t) \Omega  ((y, u) \Omega  (z, v)); ffD,E,F

The isomorphism is easily seen.
oeA,B We need to show naturality:

(x, t) \Omega  (y, u); oeA,B= (

z, let x0 \Omega  y0 be let x \Omega  y be z in t \Omega  u in y0 \Omega  x0)= (

z, let x \Omega  y be z in u \Omega  t)= (
z, let y \Omega  x be let x0 \Omega  y0 be z in y0 \Omega  x0 in u \Omega  t)

Again, the isomorphism is easily seen.

4.5.4 Coherence Diagrams
Now we need to show that the coherence equalities given earlier hold in the term category.We check these by number based on the numbering given in the definition. Because the

demonstration for larger equalities consists of equalities between huge terms of DILL, wecheck here only equalities 2,3,5 and 6.

(2) LHS =

(z, let u \Omega  v be let u0 \Omega  z0 be z in let x0 \Omega  y0 be u0 in x0 \Omega  (y0 \Omega  z0)
in u \Omega  (let x \Omega  y be v in let * be x in y))
= (z, let u0 \Omega  z0 be z in let x0 \Omega  y0 be u0 in x0 \Omega  (let * be y0 in z0))
= (z, let u0 \Omega  z0 be z in let x0 \Omega  y0 be u0 in let * be y0 in (x0 \Omega  z0))
= (z, let u0 \Omega  z0 be z in (let x0 \Omega  y0 be u0 in let * be y0 in x0) \Omega  z0)
= RHS

(3) LHS =

(z, let x \Omega  y be z in let * be y in x)
= (z, let x \Omega  y be z in let * be y in let * be x in *)
= (z, let x \Omega  y be z in let * be x in y)
= RHS

23

(5) We show this by demonstrating oeA,B; oeB,A = id.

LHS = (z, let x \Omega  y be let x0 \Omega  y0 be z in y0 \Omega  x0 in y \Omega  x)

= (z, z)

(6) LHS =

(z, let x \Omega  y be let x0 \Omega  y0 be z in y0 \Omega  x0 in let * be y in x)
= (z, let x0 \Omega  y0 be z in let * be x0 in y0)
= RHS

At this point we have shown that the term category is an SMC. It only remains todemonstrate that a suitable candidate exists for the right adjoint of the tensor.

4.5.5 Closedness of the SMC
Define D(G)(A, B) = {(x, t)| ; x : A ` t : B}. Then we have that

T (G)(A, B) = {[(x, t)]|(x, t) 2 D(G)(A, B)}
We have the following series of isomorphisms:

D(G)(A \Omega  B, C) defined {(x, t)| ; x : A \Omega  B ` t : C}' {(

y, z, u)| ; y : A, z : B ` u : C}' {(

y, v)| ; y : A ` v : B-ffiC}defines D(

G)(A, B-ffiC)

Now T (G) (A \Omega  B, C) = {[(x, t)]|(x, t) 2 D(G)(A \Omega  B, C)} but by the isomorphism, thisis the same as

{[(x, t)]|(x, t) 2 D(G)(A, B-ffiC)}
which is the definition of T (G) (A, B-ffiC)Hence -ffi is the required right adjoint to the tensor and we have an SMCC.

Having shown that the term category is a SMCC, and hence forms part of an LNLmodel, we now need to find a suitable candidate for the CCC part of this model. To do
this, we will need an intermediate construction.

4.6 A Multicategory Construction
We give a construction which for any closed multicategory gives us a CCC in a uniformway. We can then construct a suitable CCC part for the term category as the CCC

corresponding to a multicategory induced by the intuitionistic part of the context of DILL.

24

4.6.1 Definition of Multicategories
A Multicategory (as defined for example in [9]) is a structure M having:

* A set of base objects Ob(M).

* For each sequence of objects _A and single object B, a set of morphisms M( _A, B).

* A composition

; _A, _B,C : (*Bi2 _BM( _A, Bi)) * M( _B, C) ! M( _A, C)
which for fi : M( _A, Bi) and g : M( _B, C), is written

< fi >i=1..n; g : M( _A, C)
The composition is associative, by which we mean

< _f ; gi >i=1..n; h = _f ; (< gi >i=1..n; h)
for all morphisms of appropriate types.

* Identities idA : M(< A >, A) for each object A which have the property that < f >;

idA = f for all arrows f having domain A.

* Projections ssi : M(< Aj >j=1..n, Ai) s.t. the following equations hold:

fi < fi >i=1..n; ssj = fj
j < ssi >i=1..n; f = f

This is the definition of multicategory with a cartesian-product-style interpretationof the sequence. There is a corresponding definition which interprets the sequence as a

tensor-product; this has no projections.We now define a closed multicategory.

4.6.2 Closed Multicategory
A Closed Multicategory is a multicategory M whose objects are closed under the binaryoperation ! such that:

M( _AB; C) = M( _A; B ! C)

25

4.7 Closed Multicategory to CCC
We now make explicit the connection between closed multicategories and CCCs by defininga category M

seq based upon the closed multicategory M, which will be a CCC.Let the objects of M

seq be sequences of objects of M, {< Ai >i=1..n |Ai 2 Ob(M)}.Now define the morphisms

Mseq( _A, < Bi >i=1..n) = {< fi >i=1..n |fj 2 M( _A, Bj )}
Now we define the identities on Mseq. Define id<Ai> as follows:

* If < Ai > is the empty sequence, then the identity is the unique empty sequence ofarrows.

* If < Ai > has length 1, then the identity is the sequence of length one containingjust the identity arrow

idA1 :< A1 >! A1 from the multicategory.

* If < Ai >i=1..n has length greater than one, then id<Ai> for i = 1..n is the sequence

< ssi >i=1..n of projections in the multicategory.

We define the composition of two morphisms < fi >i=1..n and < gj >j=1..m as follows:

< fi >i=1..n; < gj >j=1..m=< ( _f ; gj) >j=1..m
Now we can show that Mseq is a category. The identity equations are satisfied byvirtue of the projection equalities in the multicategory, and the associativity of composition
follows from that of the multicategory composition.
CCC We now give the definitions required to turn this into a CCC. Define _A * _B = _A _B.Then the projections are given by

< ssi >:< Aj >j=1..n!< Ai >, and the pairing of twoarrows _
f and _g is the concatenation of the sequences _f _g.The projections and pairing satisfy the equalities of a CCC by virtue of the projection

equalities of the multicategory.Define 1 = hi. Then an arrow from any type to 1 is the by the empty sequence of
arrows, which is necessarily unique. So we have: 1 _A = hi : _A ! 1Define

< Ai >i=1..n!< Bj >j=1..m=< Ai ! (A2.. ! (An ! Bj)..) >j=1..m
Now we can show the Cartesian closedness of the category with this definition of !since

Mseq( _AB, < Ci >i=1..n)definition = {

< fi >i=1..n |fj 2 M( _AB; Cj)}multicategory closure ' {
< fi >i=1..n |fj 2 M( _A; B ! Cj)}
definition = Mseq( _A, < B ! Ci >i=1..n)definition = M

seq( _A, < B >!< Ci >i=1..n)

So we have that Mseq is a CCC for any multicategory M.

26

CCC to Closed Multicategory In a straightforward way, given any CCC C it is pos-sible to define a closed multicategory C

mul. We will not use this fact in the development,but we note that (M
seq)mul = M.

4.8 The Term Multicategory T M(G)
Now we can provide an appropriate CCC for the term LNL-model as T Mseq for a suitableclosed multicategory T M. We define this multicategory as follows:

The objects of the multicategory T M(G)will be precisely the objects of the term cat-egory T (

G) , which are the types of D(G).Now the morphisms of T M(

G) are as follows:

T M(G)( _A, B) = {[(_x, t)]|x1 : A1, ..., xn : An; ` t : B}
where [(_x, t)] is the equivalence class of pairs under the equivalence jM defined:

(_x, t) jM (_y, u) iff _x : \Gamma ; ` t =A u[_x/_y]
Now we can give the identities, projections and composition on the multicategory:

idA :< A >! A = [(< x >, x)]
ssi :< Aj >j=1..n! Ai = [(< xj >j=1..n, xi)] if i 2 1..n

< [(_x, ti)] >i=1..n; [(< yi >i=1..n, u)] = [(_x, u[ti/yi]i=1..n)]
Now we need to verify that these definitions satisfy the multicategory equations.
Associativity of Composition: The right-hand side of the equation is defined as follows,where we let

fi be (ti, _x), gi be (uj, _y) and h be (v, _z)

[(_x, ti)]; [(_y, v[ui/zi])] = [(_x, v[ui/zi][tj/yj])]

= [(_x, v[ui[tj/yj ]/zi])]
= [(_x, uj[ti/yi])]; [(_z, v)]
as required.
The fi-product rule: The left-hand side of the rule is as follows, where we use [(_y, tj)]for

fj : [(_

y, xi[tj/xj])] = [(_y, ti)]

again as required.

The j-product rule: The left-hand side of the rule is as follows, where we use [(_y, t)] for

f : [(_

x, t[xj/yj])] = [(_y, t)]

by ff-conversion, as required.

27

Now we can show that the multicategory T M(G) is a closed multicategory; let thebinary operation

A ! B be defined by !A-ffiB over the objects of the multicategory.To show that the closure property of the ! is satisfied, observe that:

T M(G)( _AB; C) = {[(_xy, t)]|_x : _A, y : B; ` t : C}= {[(_

xy, u0)]|_x : _A; y :!B ` u0 : C}= {[(_
x, u00)]|_x : _A; ` u00 :!B-ffiC}

But this is the definition of the operator ! in the multicategory.Hence we have established that T M(

G) is indeed a multicategory, and hence using themulticategory to CCC result given earlier, we have a CCC T M(

G)seq.

Convention From now on, we will abbreviate an arrow

< [(< xi >i=1..n, tj)] >j=1..m
as

[(< xi >i=1..n, < tj >j=1..m)]

4.9 T (G) is monoidally adjoint to T M(G)seq
In order to prove that the two categories we have given (T (G) and T M(G)seq ) form a LNLmodel, we need to demonstrate that there exists a monoidal adjunction between them.

4.9.1 Functors F and G
We define the functors G : T (G) ! T M(G)seq and F : T M(G)seq ! T (G) :

G(A) = < A >
G([(x, t)]) = < [(< x >, t)] >

F (< Ai >i=1..n) = Ni=1..n!Ai
F (< [(_xj=1..m, ti)] >i=1..n) = [(z, let * be z in Ni=1..n!ti)] if m = 0[(

z, let \Omega j=1..mym be z
in let !_xj=1..m be _y in Ni=1..n!ti)] if w > 0

where Ni=1..0!ti = * and Ni=1..0!Ai = I.We show that these definitions are functorial. It is easy to see that

G preserves identities
and composition, but more tricky for F . To show that it preserves identities:

28

F (idhi)
= F (hi, hi)= [(

z, let * be z in Ni=1..0!ti)]= [(

z, let * be z in *)]=

idI

F (id<Ai>i=1..(n+1) )
= F (< ssi=1..(n+1) >)= (

z, let Nj=1..(n+1) yj be z in let !_xj=1..(n+1) be _y in (Ni=1..(n+1)!xi))
= (z, let Nj=1..(n+1) yj be z in Ni=1..(n+1)(let !xi be yi in !xi))
= (z, let Nj=1..(n+1) yj be z in (Ni=1..(n+1) yi))
= (z, z)=

id(Ni=1..(n+1)!Ai)

To show that it preserves composition, there are a number of cases:

* If [(< xi >i=1..(n+1), hi)] :< Ai >i=1..(n+1)! hi and

[(hi, < tj >)]j=1..(m+1) = g : hi !< Bj >j=1..(m+1)
then F (hi; g)

= F ([(< xi >, hi)]; [(hi, < tj >)])=

F (< [(< xi >, tj)] >)= (
z, let \Omega i=1..(n+1)yi be z in let !_x be _y in Nj=1..(m+1)!tj)
= (z, let \Omega i=1..(n+1)yi be z in let !_x be _y in *);(

z, let * be z in Nj=1..(m+1)!tj)
= F (hi); F (g)

* If [(hi, < ti >)] =< fi >i=1..(n+1): hi !< Ai >i=1..(n+1) and

[(< yi >, < uj >)] =< gj >j=1..m:< Ai >i=1..(n+1)!< Bj >j=1..m
then F (< f

i >; < gj >)=
F (< [(hi, ti)] >; < [(< yi >, uj)] >)=

F (< [(hi, uj[_t/_y])] >)= (
z, let * be y in (Nj=1..m!uj[_t/_y]))
= (w, let \Omega _z be (let * be w in N!ti in )let !_y be _z in N!uj)
= F ([(hi, < ti >)]); F ([(_y, < uj >)])=

F (< fi >); F (< gj >)

29

* If

< [(_xi=1..(n+1), tj)] >=< fj >j=1..(m+1):< Ai >i=1..(n+1)!< Bj >j=1..(m+1)
and

< [(< yj >, uk)] >=< gk >k=1..m:< Bj >j=1..(m+1)!< Ck >k=1..p

then

F (< fj >; < gk >)=
F (< [(_x, tj)] >; < [(_y, uk)] >)=

F (< [(_x, uk[_t/_y])] >)= (
z, let \Omega _y be z in let !_x be _y in N!uk[_t/_y])= (
w, let \Omega _v be (let \Omega  _y0 be w in let !_x be _y0 in N!tj) in let !_y be _v in N!uk)=

F (< [(_x, tj)] >); F ([(_y, uk)])=

F (< fj >); F (< gk >)

4.9.2 The Adjunction
We need to establish that there is an adjunction between T (G) and T M(G)seq.

T M(G)seq(< Ai >i=1..n, G(B)) def= T M(G)seq(< Ai >i=1..n, < B >)

def= {< f > |f 2 T M(G)(< A

i >i=1..n, B)}
def= {< [(< x

i >i=1..n, t)] > |x1 : A1, ...xn : An; ` t : B}' {

< (y, u) > | ; y : Ni=1..n!Ai) ` u : B}' {

< f > |f 2 T (G) (F (< Ai >i=1..n), B)}' T (

G) (F (< Ai >i=1..n), B)

4.9.3 Monoidality
We now need to check that the adjunction is monoidal. This involves various steps.

Monoidal Functors We need to show that both F and G are monoidal functors. Thisinvolves giving natural transformations:

(hi, < * >) = mGhi : hi ! G(I )
(< x, y >, < x \Omega  y >) = mGA,B : G(A)G(B) ! G(A \Omega  B)

(z, z) = mFI : I ! F (hi)(

z, z) = mFA,B : F ( _A) \Omega  F ( _B) ! F ( _A _B)

for _A 6= hi 6= _B
liF _A = mF_A,hi : F ( _A) \Omega  F (hi) ! F ( _A)

riF _A = mFhi, _A : F (hi) \Omega  F ( _A) ! F ( _A)

We must now check naturality and certain coherence conditions. We first observe thatnaturality is trivial for the identity.

30

Naturality of mG Assume that f = (x, < t >) and that g = (y, < u >). Then

LHS = (G(f ) * G(g)); mG

= (< xy >, < tu >); (< xy >, < x \Omega  y >)
= (< xy >, t \Omega  u)
= (< xy >, < x \Omega  y >); (< z >, < let x \Omega  y be z in t \Omega  u >)
= mG; G(f \Omega  g)
= RHS

(8) for mF Since mF is the identity, this equality is trivial by definition.
(9) for mF

LHS = (z, let x \Omega  y be z in y \Omega  x)

= (z, let x0 \Omega  y0 be z in let ! < xy > be < x0y0 > in !y\Omega !x)
= F (< xy >, < yx >)
= RHS

(8) for mG LHS =

(< x >, < x >)
= (< x >, < * \Omega  x >); (< z >, < let x \Omega  y be z in let * be x in y >)
= (< x >, < *x >); (xy, < x \Omega  y >);

G(z, let x \Omega  y be z in let * be x in y)
= RHS

(9) for mG

LHS = (< xy >, < yx >); (< xy >, < x \Omega  y >)

= (< xy >, < y \Omega  x >)
= (< xy >, < x \Omega  y >); (< z >, < let x \Omega  y be z in y \Omega  x >)
= (< xy >, < x \Omega  y >); G(z, let x \Omega  y be z in y \Omega  x)
= RHS

Monoidal Adjunction We also need to show that the adjunction is monoidal, ie thatthe unit and counit of the adjunction are monoidal natural transformations. We give the

31

unit and counit, and the composite monoidality maps for F G and GF :

(z, let !x be z in x) : fflA : F GA ! A
(< xi >i=1..n, < Ni=1..n!xi >) : j _A : _A ! GF ( _A)

(z, let * be z in !*) : mF GI : I ! F GI(

z, let x \Omega  y be z in
let ! < x0y0 > be < xy > in !(x \Omega  y)) : mF GA,B : F GA \Omega  F GB ! F G(A \Omega  B)

(hi, < * >) : mGFhi : hi ! GF (hi)
(< _x_y >), (< xy >, < x \Omega  y >) : mGF_A, _B : GF _AGF _B ! GF ( _A _B)

We now need to check certain coherence conditions:
(10) for ffl

LHS
= (z, let x \Omega  y be z in let !x0 be x in x0 \Omega  let !y0 be y in y0)
= (z, let x \Omega  y be z in let ! < x0y0 > be < xy > in x0 \Omega  y0)
= (z, let !x00 be let x \Omega  y be z in let ! < x0y0 > be < xy > in !(x0 \Omega  y0) in x00)
= (z, let x \Omega  y be z in let ! < x0y0 > be < xy > in !(x0 \Omega  y0)); (z, let !x00 be z in x00)
= RHS

(11) for ffl

LHS = (z, let * be z in !*); (z, let !x be z in x)

= (z, z)
= RHS

(10) for j

LHS
= (< xi, yj >i=1..n,j=1..m, < O

i=1..n!

xi, O

j=1..m!

yj >); (< xy >, < x \Omega  y >)

= (< xi, yj >i=1..n,j=1..m, < O

i=1..n,j=1..m!

xi, yj >)

= RHS
(11) for j

LHS = (hi, < O

i=1..0!

xi >)

= (hi, < * >)
= RHS

32

We have now demonstrated that T (G) is monoidally adjoint to T M(G)seq , and hencethis pair forms a term LNL-model, as originally required.
4.10 Completeness
We now have a term model of D(G) which is an LNL model. In order to prove completeness,
it now suffices to prove a lemma:

Lemma 4.3[[_

x : \Gamma ; _y : \Delta  ` t : A]] = (w, let _z _y be w in let !_x be _z in t) in the SMCC part of the termmodel.

Proof We prove this lemma by induction over the structure of the term.Now completeness is easy:
Theorem 2 (Completeness)For terms

t and u provable in the same context \Gamma ; \Delta :\Gamma ; \Delta  `

t =A u if and only if [[\Gamma ; \Delta  ` t : A]] = [[\Gamma ; \Delta  ` u : A]] in every LNL model ofD(
G).

Proof We have the forward direction of the implication as soundness proved earlier. Asfor the other direction, assume that [[

t]] = [[u]]. Then since the term model is an LNL model
we have by the lemma that

(w, let _z _y be w in let !_x be _z in t) = (w, let _z _y be w in let !_x be _z in u)
and hence we have

; w : O

A2!\Gamma ,\Delta (

A) ` let _z _y be w in let !_x be _z in t =B let _z _y be w in let !_x be _z in t

But now it follows that if we substitute N!_x, _y for w in both terms we still have an equality.However, under this substitution, we have:

let _z _y be (N!_x, _y) in let !_x be _z in t =fij-cc t
and hence

\Gamma ; \Delta  ` t =B u

as required. \Xi 

33

5 Relating DILL and ILL
We now show that DILL is a conservative extension of ILL, by which we mean that we givea translation from

DILL to ILL and one in the reverse direction, such that two terms areequal in
ILL if and only if their images are equal in DILL. Further, we show that the subtype-system of DILL consisting of terms

t derivable with no intuitionistic assumptions,; \Delta  `
t : A, is isomorphic to the type system ILL.

5.1 The System ILL
We give the equalities and rules for the exponential part of the system of ILL we will use inthe appendix. Wherever numbers are used to refer to particular equalities, those numbers

are as given in the appendix.
Vector Notation We use a vector notation in order to reduce the complexity of the rules.We take

~t to represent a sequence of terms t1, t2..tn for some n, and denote the empty vector

by hi. This construction, and in particular the case where all the terms ti are variables (de-noted

x1, x2...xn for some n) is used in the promote construct. Also, following Benton, weuse the form (

discard ~t in u) to abbreviate (discard x1 in discard x2 in... in u). We also use(
copy ~t for ~x, ~y in u) to abbreviate (copy t1 for x1, y1 in copy t2 for x2, y2 in .... in u). Fur-ther, when we come to define the translations, we will use the analogous abbreviation

(let !~x be ~u in t) to indicate the term

let !x1 be u1 in let !x2 be u2 in ...t
in DILL type theory.We use a subscript on the turnstile to differentiate between proof systems where necessary, so that for example the statement of lemma 5.1.1 below is to be read:

If \Delta  ` t : A in the type system ILL, then ; \Delta  ` \Phi (t) : A in the type system
DILL

5.2 The Translations
We will define two translations, having types:

\Phi  : ILL ! DILL\Psi 

V : DILL ! ILL

The subscript V in the translation \Psi  is a vector indicating which variables are to beregarded as intuitionistic. This is necessary since we use the same global variable set for

both types of environment.These translations will be the identity on types, further reinforcing the intuition that the
type constructors of DILL are those familiar in ILL. We summarise their crucial propertieshere; we will prove:

34

Lemma 5.1 (Properties of the Translations)The following are properties of \Phi  and \Psi :

1. If \Delta  `ILL t : A, then ; \Delta  `DILL \Phi (t) : A
2. If ~x : \Gamma ; \Delta  `DILL u : A, then ~x :!\Gamma , \Delta  `ILL \Psi ~x(u) : A
3. If \Delta  `ILL t =A u, then ; \Delta  `DILL \Phi (t) =A \Phi (u)
4. If ~x : \Gamma ; \Delta  `DILL t =A u, then ~x :!\Gamma , \Delta  `ILL \Psi ~x(t) =A \Psi ~x(u)
5. If \Delta  `ILL t : A, then \Delta  `ILL \Psi hi(\Phi (t)) =A t

6. If ; \Delta  `DILL t : A, then ; \Delta  `DILL \Phi (\Psi hi(t)) =A t

Given these lemmas, we can prove:
Theorem 3 (Conservative Extension)* \Delta  `

ILL t =A u iff ; \Delta  `DILL \Phi (t) =A \Phi (u)*

; \Delta  `DILL t =A u iff \Delta  `ILL \Psi hi(t) =A \Psi hi(u)

Proof The two proofs are almost identical. Consider the first case. We already have theimplication

\Delta  `ILL t =A u implies ; \Delta  `DILL \Phi (t) =A \Phi (u)
Now assume ; \Delta  `DILL \Phi (t) = \Phi (u). By lemma 5.1.4, we have that \Delta  `ILL \Psi hi(\Phi (t)) =A
\Psi hi(\Phi (u)), but we also have by lemma 5.1.5 that \Delta  `ILL \Psi hi(\Phi (t)) =A t, and hence the
other direction of the implication holds.The proof of the second case uses the analogous results in lemma 5.1.3 and 5.1.6 \Xi 

We now proceed to prove lemma 5.1, and hence the results of theorem 3 hold. Thosereaders not wishing to examine the somewhat complex term manipulations which these
proofs consist of can readily skip to the end of this section.

5.3 From Intuitionistic Linear Logic to DILL
Now we can define the translation of terms \Phi  from intuitionistic linear type theory ILL to
DILL. In order to make this definition, we need to assume that we are using ILL over thesame graph

G of primitive types and arrows.

5.3.1 Definition of \Phi 
On Types we define \Phi  to be the identity, since every type in DILL is intended to havethe same interpretation as the corresponding type of

ILL.

35

On Terms we define \Phi  as follows:

\Phi (x) = x\Phi (

f (t)) = f (\Phi (t))\Phi (*) = *

\Phi (let * be t in u) = let * be \Phi (t) in \Phi (u)\Phi (

t \Omega  u) = \Phi (t) \Omega  \Phi (u)\Phi (
let x \Omega  y : A \Omega  B be t in v) = let x \Omega  y : A \Omega  B be \Phi (t) in \Phi (v)\Phi (

*x : A.t) = *x : A.\Phi (t)

\Phi (tu) = \Phi (t)\Phi (u)\Phi (
discard t in u) = let !z be \Phi (t) in \Phi (u)\Phi (
copy t for x :!A, y :!A in u) = let !z : A be \Phi (t) in \Phi (u)[!z/x, y]\Phi (

derelict(t)) = let !z be \Phi (t) in z

\Phi (promote ~t for ~x : ~!A in u) = let !~z : ~A be ~\Phi (t) in !(\Phi (u)[!~z/~x])

where in the last four rules z is taken from an infinite set of fresh free variables.Now we need to prove the lemma.

Lemma 5.1.1 If \Delta  `ILL t : A, then ; \Delta  `DILL \Phi (t) : A.
Proof This proof is by induction over the structure of the term t. We give a summaryproof only.

Axiom Instance: In this case, we have x : A ` x : A, so that the translation is ; x : A `

x : A, which is derivable.

Primitive arrow, Unit-I and Unit-E: In these cases there is almost nothing to show,as the corresponding typing rules in

DILL are analogous. We note the requirementthat we have the same primitive arrows in each type theory.

\Omega -Introduction: We present this case as an example of these simple cases. We have the

derivation \Delta 

1 ` v : A \Delta 2 ` u : B\Delta 

1, \Delta 2 ` v \Omega  u : A \Omega  B (\Omega  - I)

By the inductive hypothesis, we have ; \Delta 1 ` \Phi (v) : A, and ; \Delta 2 ` \Phi (u) : A, sowe have ; \Delta 

1, \Delta 2 ` \Phi (v) \Omega  \Phi (u) : A \Omega  B via the \Omega -introduction rule of DILL. But\Phi (
v \Omega  u) = \Phi (v) \Omega  \Phi (u), so we are done.

\Omega -E,-ffi-I and -ffi-E: Again these rules in ILL are exactly parallelled in DILL.
Weakening Rule: In this case, we have the derivation

\Delta 1 ` t : B \Delta 2 ` u :!A\Delta 

1, \Delta 2 ` discard u in t : B
By intuitionistic weakening and our inductive hypothesis, we have z : A; \Delta 1 ` \Phi (t) :
B. Now by one application of our !-E rule gives us ; \Delta 1, \Delta 2 ` let !z be \Phi (u) in \Phi (t) :
B, which is precisely \Phi (discard u in t).

36

Contraction: In this case, we have the derivation in ILL:

\Delta  ` u :!A \Gamma , x :!A, y :!A ` v : B

\Delta , \Gamma  ` copy u for x, y in v : B

Now by the inductive hypothesis, we have the derivations:

; \Delta  ` \Phi (u) :!A
and ; \Gamma 

, x :!A, y :!A ` \Phi (v) : B

in DILL. But now, using the substitution lemmas of DILL and the !-I,E pair, we havethe following derivation:

; \Gamma , \Delta  ` let !z be \Phi (u) in \Phi (v)[!z/x, y]
which proves the case.
Dereliction: In this case we have the derivation

\Gamma  ` t :!A\Gamma  ` derelict

t : A

in ILL. Using the inductive hypothesis, we have in DILL that

; \Gamma  ` \Phi (t) :!A
so using one instance of !-E we have

; \Gamma  ` let !z be \Phi (t) in z : A
as required.
Promotion Rule: The derivation here is

\Delta i ` ti :!Ai {xi :!Ai}i2I ` u : B

\Delta i ` promote ~t for ~x in u : B

By our remark, and the inductive hypothesis, we have {zi : Ai}i2I; ` \Phi (u)[!~z/~x] : B.Hence, by the promotion rule of

DILL, we have

{zi : Ai}i2I; `!\Phi (u)[!~z/~x] :!B
We also have ; \Delta i ` \Phi (ti) :!Ai for each i 2 I. Hence, by I applications of the !-Erule, we have

; \Delta i ` let ~!z be ~\Phi (t) in !\Phi (u)[!~z/~x] : B
since we understand let ~!z be in to be a sequence of let constructions. This is pre-cisely what is given in the translations. \Xi 

37

We now give one auxiliary lemma:
Lemma 5.2We have that for terms

t : B and u : A of ILL, where t has a free variable x : A,

\Phi (t[u/x]) = \Phi (t)[\Phi (u)/x]
This is easily proved by induction over the first term, t, and we leave them to thereader.

Another important lemma is as follows:
Lemma 5.1.3 If \Delta  `ILL t =A u, then ; \Delta  `DILL \Phi (t) =A \Phi (u).

Proof This is proved by induction over the derivation of the equality t =A u in ILL. Firstwe consider all the one-step derivations, ie those consisting of basic equalities. However,
since there are a large number of these, most of which are identical to the equalitiesalready given in

DILL, we give the proof only for the substantially different ones, that isthose equalities concerning the ! term constructs which are summarised in the appendix.

We also need to mention the basic logical rules for equality, which we have assumed arepresented in the same way for

ILL as we have presented them for DILL. Having said that,the reflexivity, transitivity and congruence of the image of the equality on

ILL is easy toshow. The numbers refer to the numbering of the equalities in the appendix.

1): In this case, \Phi (t) is

let !w be (let ~!z be ~\Phi (e) in !\Phi (t)[!~z/~x]) in w

This is equivalent by a commuting conversion (since w and zi are fresh) to

let ~!z be ~\Phi (e) in (let !w be !\Phi (t)[!~z/~x] in w)
In this term, (let !w be !\Phi (t)[!~z/~x] in w) is fi-equal to \Phi (t)[!~z/~x]. This gives us

(let ~!z be ~\Phi (e) in (\Phi (t)[!~z/~x]))
Now by using commuting conversions and j-equality, this reduces to \Phi (t)[ ~\Phi (e)/~x],which is \Phi  applied to the right-hand side.

2): In this case, \Phi (t) is

let !w be (let ~!z be ~\Phi (e) in !\Phi (t)[!~z/~x]) in \Phi (u)
This is equivalent by a commuting conversion (since w and zi are fresh) to

let ~!z be ~\Phi (e) in (let !w be !\Phi (t)[!~z/~x] in \Phi (u))
We know, however, that w does not occur in \Phi (u), as it is fresh, so this is equal to
(let ~!z be ~\Phi (e) in \Phi (u)), which is precisely \Phi  applied to the right-hand side.

38

3): In this case we have that the image of the left hand side is let !w be \Phi (u) in \Phi (C)[\Phi (v)].Now by the fact that the context in

ILL is linear, and the translation of the linearcontext
C[ ] to DILL is linear, we have by commuting conversions that this is equalto

\Phi (C)[let w be \Phi (u) in \Phi (v)]
which is precisely the image of the right-hand side.

4): This case is analogous to the previous one, since this is another commuting conversion.
5): In this case, \Phi (t) is

let !w1 be z in !(let !w2 be x in w2)[!w1/x]
This is

let !w1 be z in !(let !w2 be !w1 in w2)

which fi-reduces to

let !w1 be z in !w1

which is j-equal to z, which is \Phi (z).

6): In this case, the image of the left-hand side is:

let !w be \Phi (e) in \Phi (u)[!w/x, y]
which is easily seen to be the image of the right-hand side since we are using amultiple substitution (substitution of a term simultaneously for a set of variables).

7): In this case the image of the left-hand side is

let !w1 be \Phi (e) in (let !w2 be x in \Phi (u))[!w1/x, y]
which is equal to

let !w1 be \Phi (e) in (let !w2 be !w1 in \Phi (u))[!w1/y]
but by one fi-equality this is

let !w1 be \Phi (e) in \Phi (u)[!w1/y]
so we can now see that via commuting conversions and an j-equality this is the imageof the right-hand side, ie \Phi (

v)[\Phi (e)/y]

8): In this case the left hand side of the equality has image

let !w1 be \Phi (e) in (let !w2 be w in \Phi (u)[!w2/y, z])[!w1/x, w]

39

but this is equal to

let !w1 be \Phi (e) in (let !w2 be !w1 in \Phi (u)[!w2/y, z])[!w1/x]
However, by a fi-equality this is equal to

let !w1 be \Phi (e) in \Phi (u)[!w1/x, y, z]
and by a similar process we can see that the image of the right-hand side is also equalto this term.

9): In this case, \Phi (t) is

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !(let !w3 be y in \Phi (v))[!w1, ! ~w2/y, ~x]
which is

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !(let !w3 be !w1 in \Phi (v))[! ~w2/~x]

which is fi-equal to

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !\Phi (v)[w1, ! ~w2/w3, ~x]

This is

let !w1 be \Phi (f ) in (let ! ~w2 be ~\Phi (e) in !\Phi (v)[w1, ! ~w2/w3, ~x])

but we know that w3 does not occur in \Phi (v), so this is

let !w1 be \Phi (f ) in (let ! ~w2 be ~\Phi (e) in !\Phi (v)[! ~w2/~x])
which is \Phi (u).
10): In this case, \Phi (t) is

let !w1 be (let ~!w2 be ~\Phi (e) in !\Phi (t)[! ~w2/~x]) in \Phi (u)[!w1/y, z]
This is equivalent, again by a commuting conversion, to

let ~!w2 be ~\Phi (e) in (let !w1 be !\Phi (t)[! ~w2/~x] in \Phi (u)[!w1/y, z])
Now this is fi-equal to

let ~!w2 be ~\Phi (e) in (!\Phi (u)[!\Phi (t)[! ~w2/~x]/y, z])

But !\Phi (u)[!\Phi (t)[! ~w2/~x]/y, z] is fi-equal to

!\Phi (u)[let ! ~w3 be ! ~w2 in !\Phi (t)[! ~w3/~x]/y,z ]

40

And this in turn is the same as

!\Phi (u)[(let ! ~w3 be ~x0 in !\Phi (t)[! ~w3/~x]), (let ! ~w3 be ~x00 in !\Phi (t)[! ~w3/~x])/y,z][! ~w2/~x0, ~x00]
which is

\Phi (u[(promote ~x0 for x in t), (promote ~x00 for x in t)/y, z][! ~w2/~x0, ~x00])

Therefore,

\Phi (t) =fi let ! ~w2 be ~\Phi (e) in

(\Phi (u[(promote ~x0 for x in t), (promote ~x00 for x in t)/y, z][! ~w2/~x0, ~x00]))

But this is precisely

\Phi (copy ~e for ~x0, ~x00 in u[(promote ~x0 for ~x in t), (promote ~x00 for ~x in t)/y,z ])
so we are done.
11): In this case, \Phi (t) is

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !(let !w3 be w in \Phi (v)[!w3/x, y])[!w1, ! ~w2/w, ~z]
This is

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !(let !w3 be !w1 in \Phi (v)[!w3/x, y, ! ~w2/~z])

which is fi-equal to

let !w1, ! ~w2 be \Phi (f ), ~\Phi (e) in !(\Phi (v)[!w1/x, y, ! ~w2/~z])
and this is j-equal to

let !w1 be \Phi (f ) in (let ! ~w2 be ~\Phi (e) in !(\Phi (v)[!w1/x, y, ! ~w2/~z]))

But this is j-equal to the translation of the right-hand side.
12): The image of the left-hand side of this equality is

let !w1, ! ~w2 be (let ! ~w3 be ~z in !\Phi (f )[! ~w3/~z]), ~w in !\Phi (g)[!w1, ! ~w2/y, ~y]
By commuting conversions this is equal to

let ! ~w3 be ~z in (let !w1, ! ~w2 be !\Phi (f )[! ~w3/~z], ~w in !\Phi (g)[!w1, ! ~w2/y, ~y])
This then is j-equal to

let ! ~w3 be ~z in (let ! ~w2 be ~w in !\Phi (g)[!\Phi (f )[! ~w3/~z], ! ~w2/y, ~y])

41

This is abbreviated to

let ! ~w3, ! ~w2 be ~z, ~w in (!\Phi (g)[!\Phi (f )[! ~w3/~z], ! ~w2/y, ~y])
But by an j-equality this is equal to

let ! ~w3, ! ~w2 be ~z, ~w in (!\Phi (g)[(let ! ~w4 be ! ~w3 in !\Phi (f )[! ~w4/~z]), ! ~w2/y, ~y])
and this can be written as

let ! ~w3, ! ~w2 be ~z, ~w in (!\Phi (g)[let ! ~w4 be !~z0 in !\Phi (f )[! ~w4/~z]/y])[! ~w3, ! ~w2/~z0, ~y]
But now this is the image of the right-hand side.

\Xi 

5.4 From DILL to Intuitionistic Linear Logic
There is a slight complication to the translation from DILL to ILL, because we need to makea distinction between variables which annotate types in the intuitionistic segment and those

which annotate variables in the linear segment. Hence we annotate the mapping \Psi  witha subscripted vector

V which indicates those variables supposed to annotate intuitionisticassumptions.

5.4.1 Definition of \Psi 
Again, we need to assume that we are using the same graph of primitive type and functionsin both systems.

Define \Psi V on types as the identity.Define \Psi 

V on terms as follows.

42

\Psi ~y(x : A) = discard ~y in x if x 62 ~y
\Psi ~yx(x : A) = discard ~y in derelict x

\Psi ~y(f (t)) = f (\Psi ~y(t))

\Psi ~y(*) = discard ~y in *
\Psi ~y(let * be t in u) = copy ~y for ~y1, ~y2 in (let * be \Psi  ~y1 (t[ ~y1/~y]) in \Psi  ~y2(u[ ~y2/~y]))

\Psi ~y(t \Omega  u) = copy ~y for ~y1, ~y2 in \Psi  ~y1 (t[ ~y1/~y]) \Omega  \Psi  ~y2 (u[ ~y2/~y])
\Psi ~y(let x \Omega  z : A \Omega  B be t in u) = copy ~y for ~y1, ~y2 in p1

where p1 = (let x \Omega  z : A \Omega  B be \Psi  ~y1 (t[ ~y1/~y]) in \Psi  ~y2(u[ ~y2/~y]))

\Psi ~y(*x : A.t) = *x : A.\Psi ~y(t)

\Psi ~y(tu) = copy ~y for ~y1, ~y2 in \Psi  ~y1 (t[ ~y1/~y])\Psi  ~y2(u[ ~y2/~y])

\Psi ~y(!t) = promote ~y for ~y1 in \Psi  ~y1 (t[ ~y1/~y])
\Psi ~y(let !x : A be t in u) = copy ~y for ~y1, ~y2 in \Psi  ~y2,x(u[ ~y2/~y])[\Psi  ~y1(t[ ~y1/~y])/x]

where ~y1 and ~y2 are vectors of variables taken from the infinite set of unused variables.Now we prove the first, and fundamental, lemma about this translation:
Lemma 5.1.2 If ~y; \Gamma ; \Delta  `DILL t : A, then ~y :!\Gamma , \Delta  `ILL \Psi ~y(t) : A.
Proof This is proved by induction over the first derivation. We leave most of this proof,as it is routine, but we consider the tensor introduction as a sample case, and also the rules
for ! as they are significantly different.
Axioms, Unit Rules and Primitive Arrow: These cases are all essentially trivial, andwe leave them here.

Tensor Introduction We have in this case that there is a deduction in DILL

~y : \Gamma ; \Delta 1 ` u : A ~y : \Gamma ; \Delta 2 ` v : B

~y : \Gamma ; \Delta 1, \Delta 2 ` u \Omega  v : A \Omega  B

By the inductive hypothesis we have that there exist derivations in ILL (using some
ff-conversion):

~y1 :!\Gamma , \Delta 1 ` \Psi  ~y1 (u[ ~y1/~y]) : A \Omega  B

and

~y2 :!\Gamma , \Delta 2 ` \Psi  ~y2 (v[ ~y2/~y]) : A \Omega  B

Now we have by the tensor introduction in ILL

~y1 :!\Gamma , ~y2 :!\Gamma , \Delta 1, \Delta 2 ` \Psi  ~y1 (u[ ~y1/~y]) \Omega  \Psi  ~y2 (v[ ~y2/~y]) : A \Omega  B

43

But by a sequence of copies, we can now obtain:

~y :!\Gamma , \Delta 1, \Delta 2 ` copy ~y for ~y1, ~y2 in \Psi  ~y1 (u[ ~y1/~y]) \Omega  \Psi  ~y2 (v[ ~y2/~y]) : A \Omega  B
which is precisely the image of the tensor. In fact, the technique of modelling theshared intuitionistic context with repeated contractions accounts for all of the copy

constructs in the definition of \Psi .
!-Introduction In this case, we have the following deduction in DILL:

~y : \Gamma ; ` t : A
~y : \Gamma ; `!t :!A

By the inductive hypothesis, we have a derivation in ILL (using some ff-conversion)

~y0 :!\Gamma  ` \Psi ~y0 (t[~y0/~y]) : A

Now by one use of promotion, we have

~y :!\Gamma  ` promote ~y for ~y0 in \Psi ~y0 (t[~y0/~y]) :!A
wehich is precisely the image of !t under \Psi .
!-Elimination In This case, we have the following derivation in DILL.

~y : \Gamma ; \Delta 1 ` t :!A ~y : \Gamma , x : A; \Delta 2 ` u : B

~y : \Gamma ; \Delta !, \Delta 2 ` let !x be t in u : B

Hence again by the inductive hypothesis we have the following derivations in ILL(using some

ff-conversion:

~y1 :!\Gamma , \Delta 1 ` \Psi  ~y1(t[ ~y1/~y]) :!A
and

~y2 :!\Gamma , x :!A, \Delta  ` \Psi  ~y2(u[ ~y2/~y]) : B

Now by the admissible cut rule in ILL we have

~y1 :!\Gamma , ~y2 :!\Gamma , \Delta 1, \Delta 2 ` \Psi  ~y2(u[ ~y2/~y])[\Psi  ~y1(t[ ~y1/~y])/x] : B
Now by the familiar series of contractions, we have

~y :!\Gamma , \Delta 1, \Delta 2 ` copy ~y for ~y1, ~y2 in \Psi  ~y2 (u[ ~y2/~y])[\Psi  ~y1(t[ ~y1/~y])/x] : B

\Xi 
We now give auxiliary lemmas relating intuitionistic and linear substitions in DILL tosubstitution in

ILL.

44

Lemma 5.3 (Linear Substitution)If we consider the substitution:

~y : \Gamma ; \Delta 1, x : A `DILL t : B ~y : \Gamma ; \Delta 2 `DILL u : A

~y : \Gamma ; \Delta 1, \Delta 2 `DILL t[u/x] : B

then \Psi 

~y(t[u/x]) = copy _y for _y1, _y2 in \Psi  ~y1 (t[ _y1/_x])[\Psi (u) ~y2[ _y2/_x]/x]

Lemma 5.4 (Intuitionistic Substitution)If we consider the substitution:

~y : \Gamma , x : A; \Delta  `DILL t : B ~y : \Gamma ; `DILL u : A

~y : \Gamma ; \Delta  `DILL t[u/x] : B

then we have that

\Psi ~y(t[u/x]) = copy _y for _y1, _y2 in \Psi  ~y1,x(t[ _y1/_y])[promote _y2 for _y3 in \Psi  ~y3 (u[ _y3/_y])/x]
These are both routine inductions over the structure of the first term, and are left tothe reader.

Now we can prove the equality lemma:
Lemma 5.1.4 If ~y : \Gamma ; \Delta  `DILL t =A u, then ~y :!\Gamma , \Delta  `ILL \Psi ~y(t) =A \Psi ~y(u)

Proof This is proved again by induction over the length of the derivation of equalityin

DILL. We consider only the exponential equalities, as it is easy but time-consumingto show that the other components of the equality rule system over

DILL correspond toequalities on
ILL.

!-fi This equality is:

~y : \Gamma ; \Delta  ` let !x be !u in v =A v[u/x]

The left-hand side of this translates into ILL as the following:

copy ~y for ~y1, ~y2 in \Psi  ~y1 (v[ ~y1/~y])[promote ~y2 for ~y3 in \Psi  ~y3 (u[ ~y3/~y]/x])
But this is just the image of intuitionistic substitution in ILL.
!-j This equality is

~y : \Gamma ; \Delta  ` let !x be t in !x =!A t

The image of the left-hand side is

copy ~y for ~y1, ~y2 in (discard ~y2 in promote x for x0 in derelict x0 )[\Psi  ~y1(t[ ~y1/~y])/x]
By equality (5) of ILL we have that this is precisely

copy ~y for ~y1, ~y2 in (discard ~y2 in \Psi  ~y1 (t[ ~y1/~y]))
However, using equality (7) this is just \Psi ~y(t)

45

Commuting Conversions are dealt with easily, as they translate to the commuting con-versions in

ILL.

\Xi 

Lemma 5.1.5 For any term \Delta  `ILL t : A of ILL, \Delta  `ILL \Psi hi(\Phi (t)) =A t.
Proof We note first that the translation \Phi  is effectively the identity on terms other thanthose containing the exponential constructors. Moreover, since \Phi  translates sequents to
sequents derivable from no intuitionistic assumptions, applying \Psi  to these sequents givesthe identity (as we need no

copy or discard constructs). Hence we know that \Psi (\Phi (t)) is theidentity except perhaps on terms involving the exponential constructors.

We prove that the translation satisfies the property above by consideration of thestructure of

t. We consider only the exponential cases.

derelict: In this case, we have that t has the form derelict(u), and hence that \Phi (t) has theform

let !z be \Phi (u) in z. This must have the following derivation in DILL:

z : A; ` z : A ; \Delta  ` \Phi (u) :!A

; \Delta  ` let !z be \Phi (u) in z : A

The translation \Psi  takes this derivation to

z :!A ` derelict (z) : A \Delta  ` \Psi hi(\Phi (u)) :!A

\Psi (\Delta ) ` derelict (z)[\Psi hi(\Phi (u))/z] : \Psi (A)

which is derelict(\Psi hi(\Phi (u))), but this is fij-equal to derelict (u) by the inductive
hypothesis.

discard: In this case, t has the form discard u in v, so that \Phi (t) is let !z be \Phi (u) in \Phi (v).

This must have the following derivation in DILL:

z : A; \Delta 1 ` \Phi (v) : B ; \Delta 2 ` \Phi (u) :!A

; \Delta 1, \Delta 2 ` let !z be \Phi (u) in \Phi (v) : B

\Psi  applied to this derivation gives the following:

z :!A, \Delta 1 ` discard z in \Psi hi(\Phi (v)) : B \Delta 2 ` \Psi hi(\Phi (u)) :!A

\Delta 1, \Delta 2 ` discard z in (\Psi hi(\Phi (v)))[\Psi hi(\Phi (u))/z] : B

but since z does not occur in \Phi (v) and hence in \Psi hi(\Phi (v)), this is precisely discard
\Psi hi(\Phi (u)) in (\Psi hi(\Phi (v))) which is fij-equal to discard u in v by hypothesis.

46

copy: Here, \Phi (t) has the form let !z be \Phi (u) in \Phi (v)[!z/x, y], and therefore has the deriva-tion:

z : A; \Delta 1 ` \Phi (v)[!z/x, y] : B ; \Delta 2 ` \Phi (u) :!A

; \Delta 1, \Delta 2 ` let !z be \Phi (u) in \Phi (v)[!z/x, y] : B

Under \Psi , this derivation becomes

z :!A, \Delta 1 ` copy z for x, y in \Psi hi(\Phi (v)) : B \Delta 2 ` \Psi hi(\Phi (u)) :!A

\Delta 1, \Delta 2 ` copy z for x, y in \Psi hi(\Phi (v))[\Psi hi(\Phi (u))/z] : B

which is copy \Psi hi(\Phi (u)) for x, y in \Psi hi(\Phi (v)), which is by hypothesis equal to copy
u for x, y in v, or t.

promote: In this case, t has the form promote ~u for ~x in v. Hence we know that \Phi (t) is

let !~z be \Phi (~u) in !\Phi (v)[!~z/~x].

This has the derivation

~z : ~A; `!\Phi (v)[!~z/~x] : B ; \Delta i ` \Phi (ui) :!Ai

; ~\Delta  ` let !~z be ~\Phi (u) in !\Phi (v)[!~z/~x] : B

When \Psi  is applied, this becomes

~z : ~!A ` promote ~z for ~x in \Psi hi(\Phi (v)) : B \Delta i ` \Psi hi(\Phi (ui)) :!Ai

~\Delta  ` (promote ~z for ~x in \Psi hi(\Phi (v)))[ ~\Psi hi(\Phi (u))/~z] : B

but this final term is just promote ~\Psi hi(\Phi (u)) for ~x in \Psi hi(\Phi (v)), which is equal to
the original term.

We can prove an analogous lemma for the alternative direction:

Lemma 5.1.6 For any term ; \Delta  ` t : A of DILL, ; \Delta  ` \Phi (\Psi hi(t)).

This is easily proved in the same manner as the previous lemma.Now by virtue of the proof at the beginning of this section, we have the results:

Theorem 3.1 \Delta  `ILL t =A u iff ; \Delta  `DILL \Phi (t) =A \Phi (u)
Theorem 3.2 ; \Delta  `DILL t =A u iff \Delta  `ILL \Psi hi(t) =A \Psi hi(u)

47

6 Further Category-Theoretic Issues
6.1 Implications of Completeness
Our proof of completeness above has certain easy corollaries. Firstly, since we have shownthat the term system

ILL together with its fij-cc equality is isomorphic to a subsystem of
DILL, with its fij-cc equality, we know that the models of DILL wil be very closely relatedto models of

ILL. We give some results which are easily proved.

Lemma 6.1 (Interpretation for ILL)If \Delta  `

ILL t : A, then we have an arrow [[ ; \Delta  ` \Phi (t) : A]] : [[\Delta ]] ! [[A]] in the SMCC part ofany LNL model.

This is obvious from the form of the maps [[ ]] and \Phi .
Corollary 3.1 (Soundness for ILL)If \Delta  `

ILL t =A u, then the arrows [[ ; \Delta  ` \Phi (t) : A]] and [[ ; \Delta  ` \Phi (u) : A]] are equal in theSMCC part of any LNL model.

This follows from the fact that \Phi  preserves equalities, and from the fact that [[ ]] issound.
Corollary 3.2 (Completeness for ILL)For terms

t and u provable in the same context \Delta , \Delta  ` t =A u if and only if

[[ ; \Delta  ` \Phi (t) : A]] = [[ ; \Delta  ` \Phi (u) : A]]
in the SMCC part of every LNL model.

Proof Assume that the interpretation of two ILL terms t and u are equal in every LNL
model. Then it follows that via completeness for [[ ]] the two DILL terms \Phi (t) and \Phi (u) are
fij-cc equal unless they have different contexts. But then it follows by the correspondenceresults proved earlier that the two

ILL terms t and u are fij-cc equal unless they havedifferent contexts. This shows completeness, when taken with the earlier soundness result.

Hence we have shown that ILL in its original formulation is complete for LNL models.We can also give a corresponding result in the reverse direction:

Corollary 3.3If

ILL has a complete model C with an interpretation function \Theta C : ILL ! C in the samesense as previously used, ie

For terms t and u provable in ILL in the same context \Delta , \Delta  `ILL t =A u iff\Theta 
C(t) = \Theta C(u) in C.

then for terms t and u provable in DILL in the same context \Gamma ; \Delta ,\Gamma ; \Delta  `

DILL t =A u iff \Theta C (\Psi (t)) = \Theta C(\Psi (u)) in C.

48

Proof Working with terms t and u of DILL provable in the context \Gamma ; \Delta , we have:

\Gamma ; \Delta  `DILL t =A u iff !\Gamma , \Delta  `ILL \Psi (t) =A \Psi (u) iff \Theta C(\Psi (t)) = \Theta C (\Psi (u)) in C
Hence the result is shown. \Xi 
This demonstrates that models DILL and models of ILL are essentially the same.

6.2 Relating LNL models and Cambridge Models
We now recall that together with the original presentation of ILL, in [4], a categorical modelwas given based on a SMCC with a comonoidal comonad. These models were referred to

as linear categories, or sometimes as Cambridge categories. It is natural to ask how thismodel of Linear Logic relates to the LNL models we have used, and indeed this question
has been raised in detail by Benton in [2]. We summarise his results in this area.
Lemma 6.2 (Benton, [2], Corollary 8)Any LNL model has as its SMCC part a linear category.

Lemma 6.3 (Benton, [2], Corollary 17)
Any linear category is the SMCC part of at least one LNL model.

This last lemma is of particular interest because the construction of a suitable CCCpart to make the LNL model can be accomplished in a variety of ways. This is precisely

the point which was made when we constructed a term-multicategory to form the CCCpart of our term LNL-model; it was conceivable that there would be other possible choices
of CCC which would satisfy the adjunction requirements.We can make this more concrete by giving a lemma.

Lemma 6.4If we have a Cambridge category C, then we can use a multicategory construction having
the following arrows:

M(C)(< Ai >i=1..n, B) = C(( O

i=1..n!

Ai), B)

to give us a CCC M(C)seq. Further, the pair C and M(C)seq form a LNL model.
We will not prove this here; however, the proof is straightforward, and is largely similar
to the equivalent proof for the particular case when the Cambridge category C is taken tobe the term category.

It is an open question as to which of Benton's two constructions this syntactic con-struction corresponds to, if either.
We can now prove the following lemma, which neatly confirms the claim made in [3]:

49

Theorem 4 (Completeness of ILL for Cambridge Categories)For two terms

t and u of ILL provable in the same context \Delta , \Delta  `ILL t =A u iff

[[ ; \Delta  ` \Phi (t) : A]] = [[ ; \Delta  ` \Phi (u) : A]]
in the Cambridge category.

6.2.1 Proof
First observe that for any Cambridge category, by Benton's lemma there is a LNL modelwhich has the Cambridge category as its SMCC part. This justifies the fact that we are

using our function [[ ]] to map into a Cambridge category, since the co-domain of thisfunction is the SMCC part of the LNL model.

Soundness We can prove this direction by observing that as previously, since \Phi  and [[ ]]preserve the relevant equality, their compostion must do.
Completeness For this direction, assume that every Cambridge category makes [[\Phi (t)]]and [[\Phi (

u)]] equal. Then observe that since the SMCC part of the term LNL-model is aCambridge category, [[\Phi (

t)]] and [[\Phi (u)]] are equal in the term LNL-model. However, we
have previously shown that this implies \Delta  `ILL t =A u if both terms are provable in context\Delta . Hence we have the result. \Xi 

7 Further Work
7.1 Additives
We might wish to extend the syntax of DILL with the additive constructs of Linear Logic.

The Product Adding the product construct is simply a matter of introducing the termconstructs

ss1,2 and < t, u > as normal, and augmenting the given equality with the fi and
j rules for these connectives. We have proved that the results on the translations between
ILL and DILL still hold with this extension. The situation with the categorical semantics isless definite; results of Benton (op. cit.) and Bierman [6] have shown that in the case where

the Cambridge category has products, the co-Kleisli category is a CCC and is the uniqueCCC which makes the pair a LNL model. This then means that Cambridge categories
with products and LNL models with the SMCC part having products are isomorphic, andwe would expect therefore that

DILL with these product constructions would be completefor that class of models. However, this has not been proved as yet.

50

The co-Product Adding the co-product is again simple at the level of terms, sincewe need only to add the constructs (

inl t), (inr t) and (case t of x in u or y in v). Again,we have shown that adding this to
DILL makes it isomorphic to ILL with the equivalentconstruct added in the same sense as previously shown. However, the category theory is

less clear; certainly it is not obviously the case that a Cambridge model with co-productsgives rise to a LNL model, since it not obvious whether there is a suitable CCC having
coproducts.

7.2 Rewriting
In considering linear *-calculi, it is traditional to adopt the reductions of *-calculus as faras possible, although of course it is not clear what direction if any should be assigned to the

commuting conversions. We have disregarded this here in favour of a uniform treatment,since it is well known also that standard theorems such as strong normalisation are difficult
to prove even in the simple case having just the connectives I, \Omega  and -ffi. However, onevirtue of

DILL is that the treatment of ! enables us to give convincing orientations to allthe equalities save the commuting conversions, and indeed this is reflected in our choice

of presentation when the equalities were first given. Unfortunately, with these obviousdirections assigned to the equalities,

DILL fails to be confluent, as can be seen by consideringthe term
let * be x in * \Omega  * which has two reductions, to * \Omega  x and x \Omega  * respectively. Wenote that this problem will stop any term calculus with this treatment of the tensor unit

from being confluent, which includes the majority of term calculi. The fact that thisproblem occurs with such a blameless connective shows that at a very basic level there
is a problem with our representation of linear logic in a term calculus way, at least withrespect to the dynamics. For this reason I am presently working on a new style of syntax
for linear logic, to provide a good account of the dynamics as well as the semantics.

8 Acknowledgements
The system presented in this report was suggested by my supervisor, Gordon Plotkin, in[10]. I have benefited greatly from discussions with him and also with Philippa Gardner
and Alex Simpson.

References

[1] Samson Abramsky. Computational Interpretations of Linear Logic. Journal of Theor-etical Computer Science, 111:3-57, 1993. Earlier version appeared as Imperial College

Technical Report DOC 90/20, October 1990.
[2] N. Benton. A mixed linear and non-linear logic; proofs, terms and models. In Pro-ceedings of Computer Science Logic '94, number 933 in LNCS. Verlag, June 1995. 15

page version.

51

[3] N. Benton, G. Bierman, V. de Paiva, and J.M.E. Hyland. Linear lambda-calculus andcategorical models revisited. In Computer Science Logic '92, Selected Papers, pages

61-84. Springer LNCS, vol. 702, 1993.
[4] N. Benton, G. Bierman, V. de Paiva, and M. Hyland. A term calculus for intuitionistic

linear logic. In Proceedings of the International Conference on Typed Lambda Calculiand Applications, number 664 in LNCS. Springer-Verlang, 1993.

[5] N. Benton and P. Wadler. Linear logic, monads and the lambda calculus. In Proceed-ings of LICS '96, 1996.
[6] G. Bierman. What is a categorical model of intuitionistic linear logic? In Proceedings

of the Second International Conference on Typed Lambda Calculus, number 902 inLNCS. Springer Verlag, April 1995.

[7] Jean-Yves Girard. Linear Logic. Theoretical Computer Science, 50(1):1-102, 1987.
[8] Jean-Yves Girard. On the unity of logic. Annals of Pure and Applied Logic, 59:201-217, 1993.

[9] Joachim Lambek. Multicategories revisited. In J. W. Gray and A. Scedrov, editors,Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics,

pages 217-240, 1989.
[10] G. Plotkin. Second-order propositional intuitionistic linear logic. Unpublished Notes,1993.

[11] G. Plotkin. Type theory and recursion. In Proceedings of the Eigth Symposium ofLogic in Computer Science, Montreal, page 374. IEEE Computer Society Press, 1993.

(Abstract).
[12] H. Schellinx. The Noble Art of Linear Decorating. PhD thesis, Institute of Logic, Lan-guage and Computation, University of Amsterdam, 1994. ILLC-Dissertation Series,

1994-1.
[13] Philip Wadler. There's no substitute for linear logic. In Eighth International Con-ference on the Mathematical Foundations of Programming Semantics, Oxford, April

1992.
[14] Philip Wadler. A syntax for linear logic. In Ninth International Coference on theMathematical Foundations of Programming Semantics, volume 802 of LNCS. Springer

Verlag, April 1993.
[15] Philip Wadler. A taste of linear logic. In LNCS 711, volume LNCS 711 of Mathematical

Foundations of Computer Science, Gdansk, August 1993. Springer Verlag.

52

A The System ILL
As mentioned in the introduction, we will follow closely the term assignment and present-ation of [4], for the fragment of the logic containing the same connectives as those of

DILL,namely
I, \Omega , -ffi and !. The rules for the exponential ! in that presentation are moder-ately familiar, and are presented at the beginning of this report. However, we gather the

significant term rules and equality rules of the system together here for convenience.

A.1 The Exponential Rules

Weakening \Gamma  ` t : B \Delta  ` u :!A\Gamma , \Delta  ` discard u in t : B Dereliction \Gamma  ` t :!A\Gamma  ` derelict(t) : A

Contraction \Gamma , x :!A, y :!A ` t : B \Delta  ` u :!A\Gamma , \Delta  ` copy u as x, y in t : B
Promotion x1 :!A1, . . . , xn :!An ` t : B {\Delta i ` ui :!Ai}i=1..n\Delta 

1, . . . , \Delta n ` promote ~u for ~x in t :!B

The rules for the other connectives are essentially those for the corresponding parts of
DILL with the omission of the intutionistic environment \Gamma .

A.2 The Equality
We assume that a suitable system of rules for equality including reflexivity, transitivity andcongruence has been presented, together with a definition of linear and binding contexts,

all in a similar manner to those given earlier for the DILL type theory. Further, we assume
that one-step equalities on the familiar non-exponential constructors have been given,analogously to those of

DILL. In that context, the one step equalities for the exponentialpresented here should be understood as abbreviations for their corresponding one-step

equality rules.

53

derelict (promote ~e for ~x in t) = t[~e/~x] (1)
discard (promote ~e for ~x in t) in u = discard ~e in u (2)

discard u in C[v] = C[discard u in v] (3)
copy u for x, y in C[v] = C[copy u for x, y in v] (4)
promote t for x in derelict (x) = t (5)

copy e for x, y in u = copy e for y, x in u (6)
copy e for x, y in (discard x in u) = u[e/y] (7)
copy e for x, w in copy w for y, z in u = copy e for w, z in copy w for x, y in u (8)

promote e, ~e for x, ~x in (discard x in t) = discard e in (promote ~e for ~x in t) (9)
copy (promote ~e for ~x in t) for y, z in u = copy ~e for ~x0, ~x00 in u[p1, p2/y, z] (10)

where p1 = promote ~x0 for ~x in t
and p2 = promote ~x00 for ~x in t
promote e, ~e for x, ~x in (copy x for y, z in t) = copy e for y0, z0 in p3 (11)

where p3 = promote ~e, y0, z0 for ~x, y, x in t

promote (promote ~z for ~x in f ), ~w for y, ~y in g = promote ~z, ~w for ~z0, ~y in g[p4/y] (12)

where p4 = promote ~z0 for ~x in f

where equation (3) is subject to the side condition that C is linear and binds none of thefree variables of the

ui, and equation (4) is subject to the side condition that C is linear,
does not bind any of the free variables of u, and does not contain x or y free.

54