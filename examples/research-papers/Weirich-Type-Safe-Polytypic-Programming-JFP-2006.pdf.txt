

Under consideration for publication in J. Functional Programming 1

Type-Safe Run-time Polytypic Programming

STEPHANIE WEIRICH
Department of Computer and Information Science

University of Pennsylvania
Philadelphia, PA 19104, USA

Abstract
Polytypic programming is a way of defining type-indexed operations, such as map, fold
and zip, based on type information. Run-time polytypic programming allows that type information to be dynamically computed--this support is essential in modern programming
languages that support separate compilation, first-class type abstraction, or polymorphic
recursion.

However, in previous work we defined run-time polytypic programming with a typepassing semantics. Although it is natural to define polytypic programs as operating over
first-class types, such a semantics suffers from a number of drawbacks. This paper describes how to recast that work in a type-erasure semantics, where terms represent type
information in a safe manner. The resulting language is simple and easy to implement--we
present a prototype implementation of the necessary machinery as a small Haskell library.

1 Polytypic programming
Some functions are naturally defined by the type structure of their arguments. For
example, a polytypic pretty printer can format any data structure by using type
information to decompose it into basic parts. Without such a mechanism, one must
write separate pretty printers for all data types and constantly update them as
data types evolve. Polytypic programming simplifies the maintenance of software
by allowing functions to automatically adapt to changes in the representation of
data. Other classic examples of polytypic operations include reductions, comparison
functions and mapping functions. The theory behind such operations has been
developed in a variety of frameworks (Abadi et al., 1991; Abadi et al., 1995; Crary
& Weirich, 1999; Dubois et al., 1995; Harper & Morrisett, 1995; Hinze, 2000; Jansson
& Jeuring, 1997; Jay et al., 1998; Ruehr, 1998; Sheard, 1993; Trifonov et al., 2000;
Wadler & Blott, 1989).

Many of these frameworks generate polytypic operations at compile time through
a source-to-source translation determined by static type information. In contrast,
run-time polytypic programming (also called higher-order intensional type analysis (Weirich, 2002a)) defines polytypic operations with run-time analysis of dynamic
type information. Run-time type analysis has two advantages over static forms of
polytypism: First, run-time analysis may index polytypic operations by types that

2 S. Weirich
are not known at compile time, allowing the language to support separate compilation, dynamic loading and polymorphic recursion. Second, run-time analysis may
index polytypic operations by universal and existential types. Many polytypic operations defined for these types require type information for the abstracted types.
Therefore, to define these operations, the semantics of the programming language
must provide this type information at run time.

Run-time type analysis is naturally defined by a type-passing semantics because
types play an essential role in the execution of programs. However, there are several
significant reasons to prefer a semantics where types are erased prior to execution:

* A type-passing semantics always constructs and passes type information to

polymorphic functions. It cannot support abstract data types because the
identity of any type may be determined at run time. Furthermore, parametricity theorems (Reynolds, 1983; Wadler, 1989) about polymorphic terms
are not valid with this semantics.*
Because both terms and type constructors describe run-time behavior, type
passing results in considerable complexity in the semantics of languages that
precisely describe execution. For example, a language that makes memory
allocation explicit (Morrisett et al., 1995; Morrisett & Harper, 1997) uses a
formal heap to model how data is stored; with run-time types it is necessary
to add a second heap (and all the attendant machinery) for type data.*
Operators that implement type analysis in a type-erasure semantics are easier
to incorporate with existing languages (such as Haskell and ML) that already
have this form of semantics. Extending these languages with this form of type
analysis does not require global changes to their implementations. In fact, for
some languages it is possible to define type analysis operators with library
routines written in that language. For example, Weirich (Weirich, 2001) shows
how to encode first-order run-time type analysis in F! (Girard, 1971) and
Cheney and Hinze (Cheney & Hinze, 2002) implement the same capabilities
in the Haskell language (Peyton Jones, 2003).

In first-order type analysis, types such as int and bool * string are the subject
of analysis--an operator called typerec computes a catamorphism over the structure of run-time types. The idea behind higher-order analysis is that the structure
of parameterized types (i.e. higher-order type constructors) is examined. In this
framework, typerec acts like an environment-based interpreter of the type language
during execution. Higher-order analysis can define more polytypic operations than
first order analysis. For example, a polytypic function that counts the number of
values of type ff in a parameterized data structure of type o/ ff must analyze the type
constructor o/ . Many of the most important examples of polytypic programming are
only definable by higher-order analysis, including maps, zips, folds and reductions.

Crary, Weirich and Morrisett (Crary et al., 2002) (CWM) describe how to support
first-order type analysis in a language with a type-erasure semantics. In their language *R, typerec examines terms that represent types instead of analyzing types.
In a type-erasure version of higher-order analysis, typerec should examine term
representations of higher-order type constructors. However, although CWM define

Type-Safe Run-time Polytypic Programming 3

Type analysis Semantics
*R (Crary et al., 2002) First-order Type-erasure
LH (Weirich, 2002a) Higher-order Type-passing
LHR This paper Higher-order Type-erasure

Fig. 1. Language comparison
representations of higher-order type constructors in *R, these representations cannot be used for higher-order analysis. For technical reasons discussed in Section 4,
we cannot define a term that operates over these type constructor representations
in the same way as the type-passing typerec term operates over type constructors.
These difficulties prohibit an easy definition of a type-erasure language that may
define higher-order polytypic operations.

In this paper, we show how to reconcile higher-order analysis with type erasure.
Our specific contributions include:

* A language, called LHR, that supports higher-order type analysis in a typeerasure semantics. Surprisingly, in some respects LHR is a simpler calculus
than the type-passing version of higher-order type analysis.*
A translation between the type-passing version of higher-order type analysis
and LHR, with a proof of correctness.*
A prototype implementation of LHR as a Haskell library that is simple, yet
specialized to the Haskell type system, allowing polytypic functions to operate
over built-in Haskell datatypes.

The structure of this paper is as follows. Section 3 reviews higher-order type
analysis (formalized with the language LH) and Section 4 discusses the problems
with defining a type-erasure version of this language. In Section 5 we present the
type-erasure language called LHR. We describe the translation between LH and
LHR in Section 6. Section 7 describes the prototype implementation of LHR as
a Haskell library. In Section 8 we discuss extensions of this translation, and in
Section 9 we present related work and conclude. Appendix A contains the proof of
correctness of the translation.

2 First-order type analysis with typerec
As a gentle introduction, we start with a common, first-order example of how typerec
works in a language with a type-passing semantics. The language that this example
is written in is an explicitly-typed polymorphic lambda calculus, much like System
F. However, unlike System F, type arguments cannot be erased prior to execution
as they are necessary for the typerec operator.

Figure 2 contains the archetypical tostring example that demonstrates the use
of type analysis to automatically generate marshalling functions for any type.
This functionality is reflected in the type of tostring: given any type ff it returned a function that converts ff's to strings. For example, the application
tostring[int * int](3, 4) returns the string "(3,4)".

4 S. Weirich

tostring :: 8ff: ? .ff ! string
tostring = \Lambda ff: ? .typerec[*ff.ff ! string]ff of `

where ` ={

int = string of int
unit = x:unit."()"*

= \Lambda fi: ? .*x:(fi ! string).\Lambda fl: ? .*y:(fl ! string).

*v:(fi * fl).

"(" ++ x(ss1v)++ "," ++ y(ss2v)++ ")"!
= \Lambda fi: ? .*x:(fi ! string).\Lambda fl: ? .*y:(fl ! string).

*v : (fi ! fl)."unprintable function"
+ = \Lambda fi: ? .*x:(fi ! string).\Lambda fl: ? .*y:(fl ! string).

*v : (fi + fl).case v of

(inj 1 z ) "inj1 (" ++(xz)++ ")"|

inj 2 z ) "inj2 (" ++(yz)++ ")" )}

Fig. 2. Example: tostring
The typerec operator works by folding over its argument type ff. The [*ff.ff !
string] annotation is used for type checking. The branches ` tell what to do for
each type constructor: For example, if ff is int then a primitive function mapping
integers to strings is returned. Some type constructors, such as *, ! and + must
be applied to arguments to form types. In the branches for those type constructors,
typerec provides the arguments fi and fl as well as marshallers for those types.

Unfortunately, the simple version of typerec described in this section is not expressive enough to define some polytypic operations, its argument must have base
kind ?. In the next section, we discuss an extension of typerec that can analyze arguments of any kind. Furthermore, to be precise about the semantics of this extension,
we completely specify the LH language that contains it.

3 LH: Higher-order analysis with type-passing
The LH language (Figure 3) is a lightweight characterization of higher-order type
analysis that captures the core ideas of the language of Weirich (Weirich, 2002a).
It is a call-by-name variant of the Girard-Reynolds polymorphic lambda calculus (Girard, 1972; Girard, 1971; Reynolds, 1983) plus the typerec term to define
polytypic operations.1 The choice of call-by-value or call-by-name is not significant,
and call-by-name slightly simplifies the presentation. Also for simplicity, the formal language contains only integers, functions, and polymorphic terms, although
we will include additional forms (such as products, sums, and term and type recursion, with their usual semantics) in the examples. The behavior of typerec on these
new type forms is analogous to that for integers, functions and polymorphic types.

1 Unlike other languages with intensional type analysis such as *MLi (Harper & Morrisett, 1995)

and *R (Crary et al., 2002), LH does not include Typerec--a type constructor that defines other
types by intensional analysis.

Type-Safe Run-time Polytypic Programming 5
(kinds) ^ ::= ? | ^1 ! ^2
(operators) \Phi  ::= int | ! | 8?
(type constructors) o/ ::= ff | *ff:^.o/ | o/1o/2 | \Phi 
(types) oe ::= o/ | int | oe1 ! oe2 | 8ff:^.oe
(terms) e ::= i | x | *x:oe.e | e1e2|

\Lambda ff:^.e | e[o/]|
typerec[o/0]ho/ : ^i of `, j

(typerec branches) ` ::= ; | `{\Phi  ) e}
(term environment) j ::= ; | j{ff ) (^, o/, e)}
(tycon context) \Delta  ::= ; | \Delta {ff ) ^}
(term context) \Gamma  ::= ; | \Gamma {x ) oe}
(operator signature) \Sigma  ::= { int ) ?,! )

? ! ? ! ?,8
? ) (? ! ?) ! ?}

Fig. 3. Syntax of LH
Types, oe, which describe terms, are separated from type constructors, o/ , although
we often call type constructors of base kind, ?, types. The operators, \Phi , are a set
of constants of the type constructor language. These constants correspond to the
various forms of types: for example, the constant ! applied to o/1 and o/2 is equivalent
to the function type o/1 ! o/2, and 8?o/ is equivalent to the type 8ff: ? .o/ ff.2 The
signature, \Sigma , is a fixed finite map that describes the kinds of the operators. We use
the notation \Sigma (\Phi ) to refer to the kind of the operator \Phi .

The language includes several other finite maps, such as `, j, etc. We write the
empty map as ;, add a new binding to ` with `{\Phi  ) e} (defined only when\Phi  62

Dom(`)) and retrieve a binding with `(\Phi ) (defined only when \Phi  2 Dom(`)).
The notation for the other maps is analogous.

The term typerec[o/ 0]ho/ : ^i of `, j defines polytypic operations. Essentially, it
behaves like an interpreter of the type constructor language, translating the type
constructor o/ (of kind ^) to an element of the term language using the branches
` for the interpretation of operators and the environment j for the interpretation
of type variables. The typerec term is the binding occurrence for the variables that
might appear in o/ at run-time--those that have a definition in the environment j.
This environment maps a type variable ff to a triple (^, o/, e), describing the kind
of ff, a substitution for ff when it appears outside the scope of the typerec, and its
interpretation. We use the notation \Delta (j) to create a type context from the variables
bound by j and the notation j(o/ ) to substitute for those type variables that appear
free in the type constructor o/ .

In a typerec term, the type constructor o/ 0 is an annotation that makes type
checking syntax directed. We call it the return type constructor and usually use the
metavariable o/ 0 to refer to it. The return type constructor is used to determined

2 There are no type constructors analogous to polymorphic types (8ff:^.oe) when ^ is not ?.

Including them would require either an infinite number of operators or kind polymorphism.

6 S. Weirich

size =

\Lambda ff:? ! ?. typerec[*fi: ? .fi ! int]hff : ? ! ?i of `, ;

where ` ={

int ) *y: int .0
unit ) *y: unit .0* )

\Lambda fi: ? .*x:(fi ! int).\Lambda fl: ? .*y:(fl ! int).

*v:(fi * fl).

x(ss1v) + y(ss2v)! )
undefined
+ ) \Lambda fi: ? .*x:(fi ! int).\Lambda fl: ? .*y:(fl ! int).

*v:(fi + fl). case v of

(inj 1 z ) x(z) | inj 2 z ) y(z))8

? ) undefined9
? ) \Lambda ff:? ! ?.*r:(8fi: ? .(fi ! int) ! fffi ! int).

*x:9ff.

lethfi, yi = unpack x in

(r [fi] (*x:fi.0) y)
u? ) \Lambda ff:? ! ?.

*x:(8fi: ? .(fi ! int) ! fffi ! int).

fix f:(u?ff) ! int .

*y:u?ff. (x [u?ff] f (unroll y))}

Fig. 4. Example: size
the type of an analysis of a type constructor o/ of kind ^, defined to be [o/ 0]hj(o/ ) : ^i
using the definition of a polykinded type, below.

Definition 3.1
A polykinded type, written [o/ 0]ho/ : ^i, where o/ 0 has kind ? ! ? and o/ has kind ^, is
defined by induction on ^ by:

[o/ 0]ho/ : ?i def= o/ 0o/
[o/ 0]ho/ : ^1 ! ^2i def= 8ff:^1.[o/ 0]hff : ^1i ! [o/ 0]ho/ ff : ^2i

A simple example of a typerec term is

typerec [*fi: ? .fi]hff : ?i of {int ) 0}, {ff ) (?, int, 3)}
The environment for this term maps the type variable ff to the number 3. This
term has type [*fi: ? .fi]hint : ?i = ((*fi: ? .fi) int) = int.

The function size in Figure 4 is a more realistic example of a polytypic function
defined with typerec. This function is defined over type constructors of kind ? ! ?.
For example, lists are defined in this language as

List def= *fi: ? .u?(*ff : ?. unit +(fi * ff))
The type application size[List] is a function that takes a method to compute the
size of values of type fi (i.e. a function of type fi ! int), and returns a function to
compute the size of the entire list of type List fi.

Type-Safe Run-time Polytypic Programming 7

\Delta ; \Gamma [o/0] ` j

\Delta ; \Gamma [o/0] ` ;
\Delta ; \Gamma [o/0] ` j \Delta ; \Gamma  ` e : [o/0]ho/ : ^i \Delta  ` o/ : ^ fi 62 Dom(\Delta , j)

\Delta ; \Gamma [o/0] ` j{fi ) (^, o/, e)}

\Delta ; \Gamma  ` e : oe

\Delta  ` o/0 : ? ! ? \Delta ; \Gamma [o/0] ` j \Delta , \Delta (j) ` o/ : ^

\Delta ; \Gamma  ` `(\Phi ) : [o/0]h\Phi  : \Sigma (\Phi )i (8\Phi  2 Dom(\Sigma ))

\Delta ; \Gamma  ` typerec[o/0]ho/ : ^i of `, j : [o/0]hj(o/) : ^i

Fig. 5. Static Semantics of LH typerec

e 7!h e0 {

ff ) (^, o/, e)} 2 j
typerec[o/0]hff : ^i of `, j 7!h e

typerec[o/0]h(*ff:^0.o/1) : ^0 ! ^i of `, j 7!h

\Lambda fi:^0.*x:[o/0]hfi : ^0i.

typerec[o/0]ho/1 : ^i of `, j{ff ) (^0, fi, x)}

\Delta (j) ` o/2 : ^0
typerec[o/0]ho/1o/2 : ^i of `, j 7!h

(typerec[o/0]ho/1 : ^0 ! ^i of `, j) [j(o/2)] (typerec[o/0]ho/2 : ^0i of `, j)

typerec[o/0]h\Phi  : \Sigma (\Phi )i of `, j 7!h `(\Phi )
Fig. 6. Dynamic semantics of LH typerec
In size, the return type constructor is (*fi: ? .fi ! int) so the type of size is

8ff:? ! ?.[*fi: ? .fi ! int]hff : ? ! ?i

= 8ff:? ! ?.8fi: ? .(fi ! int) ! (fffi) ! int .

We can use size to generate the length function for lists if we supply the constant
function (*x:fi.1) to compute the size of the list elements. In other words, length =
\Lambda fi: ? .size[List][fi](*x:fi.1). Likewise, if we would like a function that counts the
number of values stored in a tree or the number of values in a Maybe (either 1 or 0),

we replace the type constructor argument List above with T ree def= *fi: ? .u?(*ff :
?.fi + (ff * ff)) or Maybe def= *fi : ?. unit +fi.

The branches ` define interpretations for the operators. For the types int and
unit, size returns the constant function 0 because we only wish to count values of
type ff. Because the * constructor must be applied to two types fi and fl to produce
a product type, its interpretation uses the size functions for fi and fl to produce the
size function for a product type fi * fl. The size of a product type is the sum of the

8 S. Weirich
sizes of the two components of the product. Likewise, the size function for a sum
type determines the case of the sum and applies the appropriate size function. Like
many polytypic functions, size is undefined for functions and polymorphic terms
and will produce an error if these operators appear in its argument. For existential
types, size unpacks the existential and then computes the size of the body, using
the constant zero function as the size of the abstract type fi. Finally, for recursive
types, the argument x will compute the size function of the body of the recursive
type if it is given the size function for the recursive type itself; this function is
defined using fix .

The static semantics of LH (Figure 5) includes a judgment of the form \Delta ; \Gamma  ` e : oe
to indicate that a term e has type oe in type context \Delta  and term context \Gamma . \Delta  maps
type variables to kinds and \Gamma  maps term variables to types. Most of the rules
for deriving this judgment are standard and are not described in this paper. We
describe the rule for typerec below.

In the expression typerec[o/ 0]ho/ : ^i of `, j, the environment j used to interpret
those type variables. We check that j is well-formed with the judgment form
\Delta ; \Gamma [o/0] ` j. This judgment declares that j maps type variables to appropriate
terms for the return type constructor [o/ 0], and to types of the appropriate kind.
The first two inference rules in Figure 5 show when this judgment may be derived.

With this judgment, we can state the formation rule for higher-order typerec (the
last rule in Figure 5). If the return type constructor is well formed, the environment
is well formed, the argument o/ is well formed (with context extended by the variables
bound in the environment, \Delta (j)) and all branches are described by the appropriate
polykinded type (where \Sigma (\Phi ) is the kind of \Phi ), then the typerec term is well formed.

The operational semantics for typerec (Figure 6) precisely describes how typerec
interprets its argument o/. If o/ is a type variable ff, typerec looks up the interpretation of that variable in the environment j. If o/ is a type function (*ff:^.o/1), typerec
steps to a polymorphic term function that, after receiving x (the interpretation of
ff), interprets o/1. If o/ is a type application o/1o/2, typerec steps to an application of
the interpretation of o/1 to the type o/2 and its interpretation. Because o/2 escapes the
scope of typerec in the type application, we use j to substitute for the variables. If
o/ is an operator \Phi , typerec retrieves that branch from `.

For example, Haskell's M aybe (or ML's option) type constructor is defined
as *ff: unit +ff. We can use size to define a function that returns 0 when no
data is present (the first case of the sum) and 1 otherwise. The expression
size[M aybe][unit](*x : unit .1) does so for arguments of type Maybe unit. We
can trace the evaluation of this term as follows. Let j be the environment {ff )
?, unit, (*x: unit .1)}, let ` be the branches for size and let o/ 0 be the return type
constructor (*ff: ? .ff ! int)):

Type-Safe Run-time Polytypic Programming 9
size[*ff: ? .ff + unit][unit](*x: unit .1)7!

h (\Lambda fi: ? .*w:(ff ! int).*v:(ff * unit).typerec[

o/0]hff + unit : ?i

of `, {ff ) ?, fi, w}) [unit](*x: unit .1)7!

h typerec[o/ 0]hff + unit : ?i of `, j7!
h (typerec[o/0]h+ : ? ! ? ! ?i)[unit](typerec[

o/ 0]hff : ?i of `, j)

[unit](typerec[o/ 0]hunit : ?i of `, j)7!

h (\Lambda fi: ? .*x:(fi ! int).\Lambda fl: ? .*y:(fl ! int).
*v:(fi + fl). case v of

(inj 1 z ) x(z) | inj 2 z ) y(z)))
[unit](typerec[o/ 0]hff : ?i of `, j)
[unit](typerec[o/ 0]hunit : ?i of `, j)7!

h *v:(unit + unit). case v of(inj

1 z ) (typerec[o/ 0]hff : ?i of `, j)(z)| inj

2 z ) (typerec[o/ 0]hunit : ?i of `, j)(z))

Reduction shows that this result is equivalent to:
*v:(unit + unit). case v of (inj 1 z ) 1 | inj 2 z ) 0)

4 The problem with type constructor representations
The LH language requires a type-passing semantics. The operational semantics of
typerec examines type constructors that must be present at run-time. However,
for many reasons we might want to add the facilities of higher-order typerec to
a language with a type-erasure semantics. Crary Weirich and Morrisett (Crary
et al., 2002) (CWM) defined the *R language that has a type-erasure semantics
and operations for first-order type analysis. We can use ideas from that language
as the basis of a type-erasure language that supports higher-order analysis.

In *R, typerec analyzes terms that represent types instead of types. A special
type R o/ is the type of the representation of o/ . This language also includes term
constants to represent types, such as Rint that represents the integer type and so
has type R int, and R* that represents o/1 * o/2 when applied to the representations
of o/1 and o/2. R* has type 8ff: ? .Rff ! 8fi: ? .Rfi ! R(ff * fi).

CWM define representations for the entire type constructor language, including higher-order type constructors, so that it is conceivable that we could extend
CWM's typerec to the representations of higher-order type constructors. The execution of higher-order typerec in LH depends on the syntactic form of its type constructor argument: whether it is a variable ff, a function *ff:^.o/ , an application o/1o/2
or a constant (such as int or !). It would seem reasonable for a type-erasure typerec
to determine whether the syntactic form of its argument is the representation of a
variable, the representation of a function, the representation of an application or
the representation of a constant.

10 S. Weirich

However, there is a problem with this idea. Not all terms with representation
types are syntactically equal to the representation of some type constructor. CWM
represent a type variable with a term variable, a type function with a polymorphic
term function, a type application with term application, and a type operator with
a new representation constant. More specifically, R[[o/ ]], the representation of the
type o/ is defined as:

R[[ff]] = xffR
[[*ff:^.o/ ]] = \Lambda ff:^.*xff:[R]hff : ^i.R[[o/ ]]R

[[o/1o/2]] = (R[[o/1]])[o/2](R[[o/2]])R

[[\Phi ]] = R\Phi 

The type of a representation term is determined by the kind of the constructor it
represents. If o/ has kind ^, then R[[o/]] has the polykinded type [R]ho/ : ^i. However,
because other terms besides R[[o/]] have type [R]ho/ : ^i, it is difficult to define an
operational semantics for typerec based on matching R[[o/ ]]. Consider trying to match
the representation of a type function. The type of the argument is the representation
of a constructor of kind ^ ! ^0 so it has type 8:^.[R]hff : ^i ! [R]ho/ ff : ^0i. The
type-erasure version of typerec must determine if that argument is exactly a type
abstraction surrounding a term abstraction, a variable, a representation constant
or an application of a representation to a type and another representation. These
rules do not cover every case. For example, the term

\Lambda ff:^.((*y:[R]hff : ^i ! [R]ho/ff : ^0i.y)(*xff:[R]hff : ^i.e))
has type 8:^.[R]hff : ^i ! [R]ho/ ff : ^0i. Even if the operational semantics evaluates
the argument before analyzing it with typerec, it will still not produce a syntactic
* as the subterm of the type abstraction. Because evaluation will not reduce the
application under the type abstraction, this term will be stuck and evaluation of
the typerec will not continue.

We solve this problem by reconsidering the operational semantics of typerec. We
can redefine the operational semantics of typerec so that we never have to determine
whether its argument is a syntactic type function. (See the relation 7!^ in Figure 7.)
This new semantics first determines the kind of the argument to typerec. If that
argument is of kind type, it cannot be a type function. Therefore, we weak-head
normalize it and then use the relation )^ to examine its syntax.

If the argument to typerec has a function kind then we make the following observation: Because typerec in LH interprets a type constructor, it is not important
whether it analyzes the type constructor o/ or its eta-expansion (*ff : ?.o/ ff). Both
arguments to typerec should produce the same result. Because something of a function kind is always equivalent to a literal type function, we know it will always step
to a term function in LH. So with this semantics, an argument of function kind will
always step to a term function. Though it may proceed in a different evaluation
order than that of LH, this operational semantics will eventually produce the same
result (see Weirich (2002b) for a formalization and proof of this statement.)

In a type-erasure language, we do not want to make the operational semantics
depend on any type information, including its kind. However, because that kind is

Type-Safe Run-time Polytypic Programming 11
Paths

ae ::= ff | \Phi  | ae o/

o/ wh ae

ff wh ff \Phi  wh \Phi 
o/1[o/2/ff] wh ae

(*ff:^.o/1)o/2 wh ae

o/1 wh ae
o/1o/2 wh ae o/2
e )k e0 {

ff ) (^1 ! . . . ! ^n ! ?, o/, e)} 2 j

typerec[o/0]hff o/1 . . . o/n : ?i of `, j)

k e [j(o/1)] (typerec[o/0]ho/1 : ^1i of `, j) . . . [j(o/n)] (typerec[o/0]ho/n : ^ni of `, j)

\Sigma (\Phi ) = ^1 ! . . . ! ^n ! ?
typerec[o/0]h\Phi  o/1 . . . o/n : ?i of `, j)

k `(\Phi ) [j(o/1)] (typerec[o/0]ho/1 : ^1i of `, j) . . . [j(o/n)] (typerec[o/0]ho/n : ^ni of `, j)
e 7!k e0

o/ wh ae
typerec[o/0]hae : ?i of `, j )k e

typerec[o/0]ho/ : ?i of `, j 7!k e

typerec[o/0]ho/ : ^1 ! ^2i of `, j7!

k \Lambda fi:^1. *x:[o/0]hfi : ^1i.

typerec[o/0]ho/fl : ^2i of `, (j{fl ) (^1, fi, x)})

Fig. 7. Kind-directed operational semantics

known at compile-time, higher-order typerec is definable as a "macro" in the erasure
language. A typerec on an argument of kind ^1 ! ^2 can always be replaced by a
typerec on argument of ^2. As a result, the erasure language restricts analysis to
arguments that represent constructors of kind ?.

An additional concern is one of linguistic complexity. Because the type-passing
version of typerec examines arguments with type variables, we need to evaluate
terms with free term variables (the representations of those type variables.) Extending the semantics to include the evaluation of open terms would require many
new rules.

Instead, there is a simpler way to define the type-erasure calculus, based on an
implementation of induction over higher-order abstract syntax (Fegaras & Sheard,
1996; Washburn & Weirich, 2003). To avoid evaluating representations with free
term variables, we change how typerec interprets type variables. Instead of using an
environment to store the interpretations of variables, we use substitution. We add
a special inverse operator (called untyrec) to immediately substitute the interpretation of a variable for its representation.

5 LHR: Higher-order analysis in a type-erasure language
Figure 8 shows the syntax of the LHR language. This language has a type-erasure
semantics. Unlike Figure 6, no rule in the dynamic semantics of typerec (Figure 9)

12 S. Weirich

(kinds) ^ ::= ? | ^1 ! ^2
(operators) \Phi  ::= int | ! | 8?
(type con's) o/ ::= ff | *ff:^.o/ | o/1o/2 | \Phi 

(types) oe ::= o/ | int | oe1 ! oe2 | 8ff:^.oe | Ro/0o/

(operator rep's) R\Phi ::= Rint | R! | R8?
(terms) e ::= i | x | *x:oe.e | e1e2|

\Lambda ff:^.v | e[o/] | R\Phi |

typerec[o/0] e of ` | untyrec[o/0] e
(values) v ::= i | *x:oe.e | \Lambda ff:^.v|

p | untyrec[o/0] e

(paths) p ::= R\Phi [o/0] | p [o/] e1 e2

Fig. 8. Syntax of LHR

e 7!LHR e0
typerec[o/0] (untyrec[o/0] e) of ` 7!LHR e

typerec[o/0] (Rint ) of ` 7!LHR `(int)
typerec[o/0] (R! [o/0][o/1] e0o/1 eo/1 [o/2] e0o/2 eo/2) of `7!

LHR `(!) [o/1] e0o/1 (typerec[o/0] eo/1 of `)

[o/2] e0o/2 (typerec[o/0] eo/2 of `)

typerec[o/0] (R8? [o/0][o/1]e0o/1eo/1) of `7!

LHR `(8?) [o/1] e0o/1 (\Lambda fi: ? .*xfi: bRhfi : ?i.*y:(o/0fi).

typerec[o/0] (eo/1 [fi] xfi (untyrec[o/0] y)) of `)

e 7!LHR e0
typerec[o/0] e of ` 7!LHR typerec[o/0] e0 of `

Fig. 9. LHR: Operational semantics of typerec
examines the syntax of a type constructor. Instead, typerec analyzes the term representations of type constructors formed from the representations of the operators
Rint , R! and R8?. Furthermore, in this language typerec may only analyze the
representations of constructors of kind ?, but as we describe below, that will is not
a limitation to its expressiveness.

Each rule for a specific operator of LHR in Figure 9 is generated from the following
general rule that corresponds to )k evaluation of an operator of kind ^1 ! . . . !
^n ! ?.

typerec[o/ 0] (R\Phi  [o/0] [o/1] e01 e1 . . . [o/n] e0n en) of ` 7!

`(\Phi ) [o/1] e01 (typerec[o/0]he1 : ^1i of `) . . .

[o/n] e0n (typerec[o/0]hen : ^ni of `)

With term representations of types and the restriction of typerec to the representation of types, LHR bears many similarities to *R. However, there is one crucial

Type-Safe Run-time Polytypic Programming 13
LHR Polykinded types
[o/0]hho/ : ?ii def= o/0o/
[o/0]hho/ : ^1 ! ^2ii def= 8ff:^1. bRhff : ^1i ! [o/0]hhff : ^1ii ! [o/0]hho/ff : ^2iib

Rho/ : ^i def= 8ff:^.[Rff]hho/ : ^ii

\Delta  ` oe

\Delta  ` o/0 : ? ! ? \Delta  ` o/ : ?

\Delta  ` R o/0 o/

\Delta  ` oe = oe0

\Delta  ` o/0 = o/00 : ? ! ? \Delta  ` o/1 = o/2 : ?

\Delta  ` R o/0 o/1 = R o/00 o/2

\Delta  ` o/ : ? ! ?
\Delta  ` 8?o/ = 8ff: ? . bRhff : ?i ! o/ff

\Delta ; \Gamma  ` e : oe

\Delta  ` \Phi  : \Sigma (\Phi )
\Delta ; \Gamma  ` R\Phi  : bRh\Phi  : \Sigma (\Phi )i

\Delta  ` o/ : ? \Delta  ` o/0 : ? ! ? \Delta ; \Gamma  ` e : R o/0o/
\Delta ; \Gamma  ` `(\Phi ) : [o/0]hh\Phi  : \Sigma (\Phi )ii (8\Phi  2 Dom(\Sigma ))

\Delta ; \Gamma  ` typerec[o/0] e of ` : o/0o/

\Delta  ` o/ : ? \Delta  ` o/0 : ? ! ? \Delta ; \Gamma  ` e : o/0o/

\Delta ; \Gamma  ` untyrec[o/0] e : R o/0o/

Fig. 10. LHR: Static Semantics (excerpt)

difference between this language and *R that allows the embedding of higher-order
typerec. LHR includes an "inverse" operator to typerec, called untyrec. When typerec
analyzes (untyrec[o/0]e), the embedded term e is returned. This inverse plays the role
of j in higher-order typerec by recording the interpretation of type variables. Where
we might analyze an argument with a free type variable in LH:

typerec[o/ 0]hfi : ?i of `, j{fi ) (?, o/, e)}
we will translate that term to the LHR term:

typerec[o/ 0] (untyrec[o/ 0] e) of `
Figure 10 shows the static semantics for the representation terms, typerec and
untyrec. For type soundness, we must restrict what terms may be the argument to
untyrec. Essentially, untyrec coerces any term into a representation of some type.
If an arbitrary term were allowed, analysis of an untyrec term could result in the

14 S. Weirich

typerec[o/0]heo/ : ?iof ` def= typerec[o/0] eo/ of `
typerec[o/0]heo/ : ^1 ! ^2iof ` def= \Lambda ff:^1.*x: bRhff : ^1i.*y:[o/0]hhff : ^1ii.N

where
N = typerec[o/0]h(eo/ [ff] x M) : ^2iof `
M = untyrec[o/0]hy : ^1iof `

untyrec[o/0]heo/ : ?iof ` def= untyrec[o/0] eo/
untyrec[o/0]heo/ : ^1 ! ^2iof ` def= \Lambda ff:^1.*x: bRhff : ^1i.*y:[o/0]hhff : ^1ii.N

where
N = untyrec[o/0]h(eo/ [ff] x M) : ^2iof `
M = typerec[o/0]hy : ^1iof `

Fig. 11. Higher-order typerec in LHR

wrong type. The coercion is sound if we restrict the type of analysis allowed for the
resulting representation. Therefore LHR parameterizes the R type with an extra
argument to describe the result of type analysis allowed for that representation.
When a term representation is polymorphic over this return type constructor (for
example, if it is of type 8fi:? ! ?.Rfio/ ) then it may be used for any analysis. We
use the notation bRho/ : ^i as type of the representation of o/ of kind ^ that may be
used for any analysis.

The notation bRho/ : ^i is also used for the type of the representation constants.
If \Phi  is an arbitrary type constructor constant, such as int, !, 8? in LHR, R\Phi  is
its term representation. If \Phi  is of kind \Sigma (\Phi ), then the type of R\Phi  is bRh\Phi  : \Sigma (\Phi )i.

The type bRho/ : ^i is mutually defined in terms of the LHR definition of
polykinded types, [o/0]hho/ : ^ii (at the top of Figure 10). The difference between
these polykinded types and those of LH is the additional representation argument.
LHR polykinded types are also used to type the branches of typerec. That way,
branches such as * or + receive the representation of their type arguments.

A similar change is to the type equivalence rule for the operator 8?. (If 9? were in
our formal language, we would define its equivalence rule similarly.) Some polytypic
functions defined over quantified types need to analyze the hidden type. By changing
the type equivalence rule in this way, we make sure the representation of that bound
variable is accessible for analysis. It is also possible to add the operator ^8? to this
calculus, such that ^8?o/ = 8ff: ? .o/ ff. This operator produces the type of parametric
functions that cannot analyze their type arguments. This operator makes no sense
in LH, because all types are analyzable.

The untyrec term allows us to implement higher-order typerec. Consider analyzing
the List type constructor in LH:

typerec[o/ 0]hList : ? ! ?i of `, j
In LHR, the representations of type constructors of higher kinds are term functions.
For example, if eList is the representation of List then it is a function from the representation of some type ff to the representation of the type List ff. Therefore, in
LHR, we can analyze the list constructor with a term that abstracts the interpreType-Safe Run-time Polytypic Programming 15
tation of ff and then analyzes the result of applying eList to untyrec surrounding
that interpretation.

\Lambda ff: ? .*xff: bRhff : ?i.*y:(o/ 0ff).

typerec[o/ 0] (eList [ff] xff (untyrec[o/ 0] y)) of `.

LHR does not include a higher-order version of typerec because it may encode
such terms. If eo/ is the representation of the type o/ of kind ^, the general encoding
of the analysis of eo/ , notated typerec[o/ 0]heo/ : ^i of `, is in Figure 11. This operation is defined in conjunction with its inverse, a higher-order version of untyrec.
Both operations are defined by induction on ^, the kind of the represented type
constructor.

This completes the description of LHR. As is standard, we have shown that the
static semantics agrees with the dynamic semantics.

Theorem 5.1 (Type Safety)
If ; ` e : oe then e either evaluates to a value or diverges.

Proof
(Sketch) Proof follows from the usual progress and preservation theorems.

In the next section, we will show that LHR is as expressive as LH by defining a
translation between the two languages. To gain an intuition behind this translation,
we end this section with an example in Figure 12, size written in the type-erasure
language. This function analyzes xff, the representation of the type ff. Even though
ff must be a type, we can still use this size to define length for lists below, where
eList is the representation of the List type constructor.

length = \Lambda ff: ? .*xff: bRhff : ?i.

size[List ff](eList [ff] xff (untyrec[*fi: ? .fi ! int](*x:ff.1)))

There are two key differences between this version and the LH version of size.
Whenever a type is abstracted its representation is also abstracted (for example, in
the branches for * and +). Whenever a type is applied, its representation is also
applied. (In the u branch, the application of x to the type [u?ff] is followed by the
representation of u?ff, the term bR[[u?ff]] defined in the next section.)

6 Translating LH to LHR
The translation between LH and LHR is based on a process called phase splitting. This process separates the static and dynamic roles of types by producing
type representations in the target language for each type in the source language.
The translation for types T [[oe]] and terms E[[e]] appears in Figure 14. Kinds and
type constructors are unchanged. We use a number of auxiliary definitions in this
translation, listed in Figure 13. An invariant of this translation is that whenever a
type variable, ff, is in scope, its term representation is also in scope as variable xff.
Therefore, every type abstraction (\Lambda ff) is immediately followed by an abstraction of
its representation (*xff). Consequently, the type translation for polymorphic types

16 S. Weirich

size = \Lambda ff: ? .*xff:R(*fi: ? .fi ! int) ff.

typerec[*fi: ? .fi ! int] xff of `

where ` ={

int ) *y: int .0
unit ) *y: unit .0* )

\Lambda fi: ? .*xfi: bRhfi : ?i.*x:(fi ! int).
\Lambda fl: ? .*xfl: bRhfl : ?i.*y:(fl ! int).

*v:(fi * fl).

x(ss1v) + y(ss2v)! )
undefined
+ ) \Lambda fi: ? .*xfi: bRhfi : ?i.*x:(fi ! int).

\Lambda fl: ? .*xfi: bRhfl : ?i.*y:(fl ! int).

*v:(fi + fl). case v of

(inj 1 z ) x(z) | inj 2 z ) y(z))8

? ) undefined9
? ) \Lambda ff:? ! ?.*xff: bRhff : ? ! ?i.

*r:(8fi: ? . bRhfi : ?i ! (fi ! int) ! fffi ! int).

*x:(9fi : ?. bRhfi : ?i * (fffi)).

lethfi, hxfi, yii = unpack x in

(r [fi] xfi (*x:fi.0) y)
u? ) \Lambda ff:? ! ?.*xff: bRhff : ? ! ?i.

*x:(8fi: ? . bRhfi : ?i ! (fi ! int) ! fffi ! int).

fix f:(u?ff ! int).

*y:u?ff. (x [u?ff] bR[[u?ff]] f (unroll y))}

Fig. 12. Example: Erasure version of size
Translation from LH to LHR
Type translation T [[oe]] (Figure 14)
Term translation E[[e]] (Figure 14)

Derived forms in LHR
LHR Polykinded type [o/0]hho/ : ^ii (Figure 10)
Higher-order typerec typerec[o/0]he : ^iof ` (Figure 11)
Higher-order untyrec untyrec[o/0]he : ^iof ` (Figure 11)
General type representation bR[[o/]] (Figure 15)
Specialized representation R[[o/]](\Delta ,o/0) (Figure 15)

Fig. 13. Notation used in the translation
includes the type of this additional argument. When a polymorphic term is applied
to a type argument o/ , that argument is followed by its term representation, bR[[o/ ]].

The most important part of this translation is the translation of typerec, at the
bottom of Figure 14. This translation replaces the argument to typerec, not with
the standard representation of the type argument, but one that is specialized to
the typerec term. The appropriate typerec argument is constructed in two phases:

Type-Safe Run-time Polytypic Programming 17

T [[o/]] = o/T

[[int]] = intT
[[oe1 ! oe2]] = T [[oe1]] ! T [[oe2]]T

[[8ff:^.oe]] = 8ff:^. bRhff : ^i ! T [[oe]]T

[[Ro/o/0]] = R o/ o/0

E[[i]] = iE
[[*x:oe.e]] = *x:T [[oe]].E[[e]]E

[[e1e2]] = E[[e1]]E[[e2]]E
[[\Lambda ff:^.e]] = \Lambda ff:^.*xff: bRhff : ^i.E[[e]]E

[[e[o/]]] = E[[e]] [o/] bR[[o/]]E
[[ typerec[o/0]ho/ : ^i of `, j ]] = typerec[o/0]h\Phi (R[[o/]](\Delta ,o/0)) : ^iof E[[`]]

where for each {ff ) (^ff, o/ff, e)} 2 j

\Delta (ff) = ^ff
\Phi (ff) = o/ff
\Phi (xff) = bR[[o/ff]]
\Phi (yff) = untyrec[o/0]hE[[e]] : ^ffi of E[[`]]

Fig. 14. Translation of LH to LHR

R[[o/]](\Delta ,o/0) : [Ro/0]hho/ : ^ii
R[[\Phi ]](\Delta ,o/0) def= R\Phi [o/0]

R[[ff]](\Delta ,o/0) def= j yff if ff 2 Dom \Delta x

ff[o/0] otherwiseR

[[*ff:^.o/1]](\Delta ,o/0) def= \Lambda ff:^.*xff: bRhff : ^i.*yff:[Ro/0]hhff : ^ii.R[[o/1]](\Delta {ff)^},o/0)R

[[o/1o/2]](\Delta ,o/0) def= R[[o/1]](\Delta ,o/0) [o/2] bR[[o/2]] R[[o/2]](\Delta ,o/0)b

R[[o/]] : bRho/ : ^i = 8ff:? ! ?.[Rff]hho/ : ^iib
R[[o/]] def= \Lambda ff:? ! ?.R[[o/]](;,ff)

Fig. 15. Representation of LHR type constructors
First a "specialized representation" R[[o/]](\Delta ,o/0) is constructed, which may contains
references to the term variables xff and yff for each ff in the domain of the environment j. We describe this process in the next section--briefly, the xff indicate where
the representation of the type o/ff is needed, and the yff mark where untyrec should
embed the branch for ff. After the construction of the specialized representation,
all occurrences of ff, xff and yff are replaced by the substitution \Phi .

6.1 Representing the constructor language
The definition of type representations ( bR[[o/ ]]) and specialized representations
(R[[o/ ]](\Delta ,o/0)) is in Figure 15. Type representations are defined in terms of specialized
representations at the bottom of the figure.

18 S. Weirich

Specialized representations are used for the argument to typerec. These representation are specialized to o/ 0 the return type constructor of an analysis of this
term, and to \Delta , a context containing type variables. As before, type variables are
represented by term variables, but here, each type variable has both a "specialized
representation", yff, of type [Ro/ 0]hhff : ^ii as well as its standard representation, xff,
of type bRhff : ^i). The context \Delta  determines which term variable should be used,
the specialized representation or an instantiation of the general one.

Most of the time, the specialized representation should be used. To enable this,
type-level abstractions are translated to abstractions that provide not just the general representation of a type argument, but its specialized representation as well.

A general type representation (defined in the last line of the figure) abstracts
over the return type constructor, so that it may be used in any analysis. Because
the type of the yff depend on the return type constructor, they should not be used
for type variables that are currently in scope. Instead, a general type representation
uses the empty context, and represents any currently in scope type variables with
xff[o/ 0], the general representation for that type variable instantiated with the return
type constructor.

For example, bR[[*ff: ? .ff ! int]] expands to

\Lambda fi:? ! ?.\Lambda ff: ? .*xff: bRhff : ?i.*yff:[Rfi]hhff : ?ii.

R![fi] [ff] (\Lambda fl:? ! ?.xff[fl]) yff [int] (\Lambda fl:? ! ?. Rint [fl]) (Rint [fi])

Here, we instantiate R! with the return constructor fi, the first component of the
arrow type ff, along with its general representation xff and its specialized representation yff, and the second component of the product type int, along with its general
representation Rint and its specialized representation Rint [fi].

Why must R! be applied to both the specialized and general representations of
its subcomponents? The branch for ! in typerec expects both the general representation and the iteration over the specialized representation for each component.
Recall the dynamic semantics for this branch:

typerec[o/ 0] (R! [o/0][o/1] e0o/1 eo/1 [o/2] e0o/2 eo/2) of `7!

LHR `(!) [o/1] e0o/1 (typerec[o/ 0] eo/1 of `)[

o/2] e0o/2 (typerec[o/ 0] eo/2 of `)

We cannot generate the general representations from the specialized representations, yet we must produce them as the `(!) branch may use them as the arguments
to other polytypic functions.

7 Implementation
In this section we describe an implementation of a simplified version of LHR to show
how these ideas could be incorporated into a language like Haskell. For simplicity,
our implementation is a Haskell library 3. An extension to Haskell might be more

3 This implementation requires the extensions of first-class polymorphism and existential

types (Odersky & L"aufer, 1996) supported by the implementations GHC and Hugs.

Type-Safe Run-time Polytypic Programming 19
attractive to programmers, but the important details of the implementation are
present in this version.

The interface to this implementation is the following:

type R c a
rint :: R c Int
runit :: R c ()
rtimes :: R c a -> R c b -> R c (a, b)
rname :: (String, [DataCon (R c) b]) -> R c b
rex :: (forall b. R c b -> R c (a b))

-> R c (Ex a)

typerec :: Theta c -> R c a -> c a
untyrec :: c a -> R c a

data Theta c = Theta {

int :: c Int,
unit :: c (),
times :: forall a b. c a -> c b -> c (a, b),
name :: forall b. (String, [DC c b]) -> c b,
ex :: forall a. (forall b. c b -> c (a b)) -> c (Ex a)
}

This implementation includes definitions of the R type constructor, constants for
the representations of type operators R\Phi , the untyrec operator, and the type analysis operator typerec. The datatype Theta is a record that describes the types of
the branches to typerec.

The name branch in Theta is for the analysis of Haskell data types and newtypes.
These type forms represent recursive types such as lists and trees. There is a list
of DCs in the argument to the name branch that corresponds to the constructors of
the datatype.

data DC c a = forall b. DC String (c b) (b -> a) (a -> Maybe b)

For each data constructor, this datatype contains the name of that constructor, the result of typerec for the argument of that constructor (for uniformity we
uncurry data constructors), the constructor itself, and a "matching" function to
determine if an element of type a is the specified constructor.

For example, we represent the list type constructor by a term function. This
function uses rname to create a representation of [a] given the information about
the named type: the string "List" and the representations of the data constructors
nil and cons. The string can be used to augment a generic function with a special
case for a particular named type.

rlist :: R c a -> R c [a]
rlist ra = rname ("List", [rnil, rcons ra])
rnil :: DC (R c) [a]
rnil = DC "[]" runit (\x -> [])

20 S. Weirich

(\x -> case x of

[] -> Just ()
( ) -> Nothing)
rcons :: R c a -> DC (R c) [a]
rcons ra = DC ":" (rtimes ra (rlist ra))

(\(t1,t2) -> t1 : t2)
(\x -> case x of

(t1:t2) -> Just(t1,t2)
( ) -> Nothing)

The last branch of Theta is for existential types. We use the following datatype to
represent an existential type that includes the general representation of the hidden
type (i.e. 9a.(8c. R c a * f a)).

data Ex f = forall a. Ex (forall c. (R c a, f a))
We could also omit the general representation from the existential type constructor
but the polytypic operations that we could instantiate with this constructor are
limited because we do not have access to the representation of the hidden type
variable.

The difference between this interface and LHR is that here the branches for
typerec do not provide the general representation of the subcomponents of the
types or the result of typerec for that subcomponent. Otherwise, the type of the
times branch would be:

times :: forall a b.

(forall c. R c a) -> c a -> c a
-> (forall c. R c b) -> c b -> c b
-> c (a, b)

This omission means that type representations also do not carry general representations. Extending this implementation to include those representations is tedious
but not difficult. General representations would allow our polytypic operations to
be defined in terms of other polytypic operations.

However, even without general representations, we have enough information to
implement the size example. To pass the return type constructor (*ff: ? .ff ! int)
as an argument to the R type constructor requires that we first give it a name with
a newtype. (Haskell does not allow type-level lambdas).

newtype Size a = S (a -> Int)
unS (S a) = a

size :: R Size a -> a -> Int
size ra = unS . (typerec theta size ra)

The branches for size are very similar to the ones in Figure 12, except for the
coercions into the newtype Size. For example, in the int branch, we use S to coerce
the constant zero function to be of type Size Int.

Type-Safe Run-time Polytypic Programming 21
theta size :: Theta Size
theta size = Theta {

int = S (\x -> 0),
unit = S (\x -> 0),
times = \xa xb -> S $ \v ->

unS xa (fst v) + unS xb (snd v),
name = (string, cons) ->

S $ \v ->
let loop (DC xa inn out: rest) =

case (out v) of

Just y -> unS xa y
Nothing -> loop rest
loop [] = error "impossible"
in loop cons,
ex = \xa -> S $ \(Ex w) ->

let (rep,z) = w in
unS (xa (S $ \x -> 0)) z
}

As before, we can use size to implement length for lists by using (*x:ff.1) as the
size function for ff.

length :: [a] -> Int
length = size (rlist (untyrec (S $ \x -> 1)))

We can apply length to Haskell lists. For example, length [1,2,3] = 3.

We can also use this facility to implement first-order polytypic operations (such
as those usually implemented by type classes). For example, instead of defining the
Show type class, we can implement rshow:

newtype RepShow a = RS (a -> String)
unRS (RS a) = a
rshow :: R RepShow a -> a -> String
rshow ra = unRS . (typerec theta show ra)
theta show :: Theta RepShow
theta show = Theta {

int = RS showInt,
unit = RS (const "()"),
times = \xa xb -> RS $ \v ->

"(" ++ unRS xa (fst v) ++ ","

++ unRS xb (snd v) ++ ")",
name = \(string, cons) ->

RS $ \v ->
let loop (DC str xa inn out : rest) =

case (out v) of

Just s ->

let s' = unRS xa s in

22 S. Weirich

if s' == "()" then str
else str ++ " " ++ s'
Nothing -> loop rest
loop [] = error "impossible"
in loop cons,
ex = \xa -> RS $ \ (Ex w) ->

let (rep,z) = w in
unRS (xa (typerec thetaShow rep)) z
}

rshow (rlist rint) [1, 2, 3]

= ": (1,: (2,: (3,[])))"

The result of rshow is different from how we might want to display lists because
rshow does not use infix notation or precedence rules. Below, we describe how to
modify rshow to use infix. (It is also possible to account for precedence). To show
cons with infix, we change the case for data constructors above so that it checks
the string to see if it is cons (:). If so, we use the polytypic infixshow to show the
argument to cons. We are able to call infixshow because it returns the same type
of result as rshow and so we can call it with the specific representation. For most
flexibility in calling other polytypic functions, we need the general representations.

case (out v) of

Just s ->

if str == ":" then infixshow xa s
else let s' = rshow xa s in ....

The infixshow function behaves just like rshow except that in the case of a pair
it shows the first component, then ":" and then the second component.

infixshow :: R RepShow a -> a -> String
infixshow = unRS . (typerec (theta show {

times = \xa xb -> RS $ \v ->

"(" ++ rshow xa (fst v) ++ "):("

++ rshow xb (snd v) ++ ")"}))

rshow (rlist rint) [1, 2, 3]

= "(1):((2):((3):([])))"

Unlike type classes, rshow extends to existential types. An extension to type
classes that supports existential types would still be problematic because it would
only work for existentials that contain the right dictionaries. Because this version
requires a general representation of the type instead of a specific dictionary, we can
use it for existentials.

For example, we can represent the type 9ff. int *ff with:

type Hidden = Ex ( (,) Int)
rhidden :: R c Hidden
rhidden = rex (rtimes rint)

Type-Safe Run-time Polytypic Programming 23
hidden int :: Hidden
hidden int = Ex (rint, (3, 4))

The branch for existentials prints out the entire term, including those parts with
the abstract type. For example, rshow rhidden hidden int = "(3,4)". However,
the branch for existentials can also hide components of abstract type by providing
a constant function:

ex = \xa -> RS $ \ (Ex w) ->

let (rep,z) = w in

unRS (xa (RS $ const "XXX" )) z

With the above branch, any values of the abstract type appear as "XXX". In other
words, rshow rhidden hidden int = "(3,XXX)".

We implement type representations in Haskell in a manner similar to representing
Church numerals--each type representation is implemented as its elimination form.
Because of that, we define the R type to be a function from the record of typerec
branches to the return type.

newtype R c b = R (Theta c -> c b)
The implementation of typerec applies its representation argument to the branches
to get the result. The definition of untyrec takes those branches, ignores them, and
returns its argument x.

typerec :: Theta c -> R c a -> c a
typerec theta (R rep) = rep theta
untyrec :: c a -> R c a
untyrec x = R (\theta -> x)

The type representations each select the corresponding component from theta. (For
each record label, Haskell defines a function with the same name that projects that
label from a record.) For example, in the definition of rint, int is a function that
retrieves the int component of theta. Therefore, it is of type Theta c -> c Int,
and the R data constructor coerces it to be of type R c Int.

rint :: R c Int
rint = R int
runit :: R c ()
runit = R unit

The times branch of theta needs the representations of the two subcomponents t1
and t2. The name branch needs the name of the type and the representations of the
data constructors. Furthermore, the existential branch just needs the representation
of its subcomponent.

rtimes :: R c a -> R c b -> R c (a, b)
rtimes t1 t2 = R (\theta -> times theta (typerec theta t1) (typerec theta t2))
rname :: (String, [DC (R c) b]) -> R c b
rname = \(str,cons) -> R (\x -> name x (str,cons))

24 S. Weirich
rname = \(str,cons) -> R (\x -> name x (str,loop x cons))

where loop x [] = []

loop x (DC str rep inn out : rest) =

DC str (typerec x rep) inn out : loop x rest
rex :: (forall b. R c b -> R c (a b)) -> R c (Ex a)
rex t1 = R (\x -> ex x (\y -> (typerec x (t1 (untyrec y)))))

8 Extensions
LH is only a subset of the language described by Weirich (Weirich, 2002a). The LH
language is lacking two features that complicate (but do not prohibit) the translation to the type-erasure language. The first is that the full language (following
Hinze (Hinze, 2000)) generalizes polykinded types to a relation of n arguments
for more expressiveness. For example, the polytypic definition of map requires two
arguments and the definition of zip requires three. A type-erasure version must
have multiple representations and multiple typerecs, one for each n. However, all of
these representations and typerecs have the same erasure, so a direct implementation (instead of the Haskell library implementation) could use the same terms at
runtime.

A second difference is that the full language includes kind polymorphism and extends typerec to constructors with polymorphic kind. There are two reasons for this
extension. First, a polytypic function in LH (such as size) must specify and therefore restrict the kind of its type argument. This restriction is artificial in LH because
typerec may iterate over type constructors with any kind. However, the lack of kind
polymorphism does not restrict LHR, as typerec in LHR is not kind-polymorphic.
We do not need to make a polytypic function kind-polymorphic because we can
apply such a function to the representations of higher-kinded constructors by first
using untyrec.

The second reason for kind polymorphism is that polymorphic types (universal
and existential) bind type variables with many kinds. Kind polymorphism allows
typerec to handle all such types with one branch. We believe that it is possible,
though complicated, to add kind polymorphism to LHR. The complexity arises
in the definition of typerec[o/ 0]he : ^iof ` and untyrec[o/ 0]he : ^iof ` when ^ is an
abstract kind O/. The translation to LHR must provide this information. Therefore,
all kind abstractions must also abstract a term that knows how to implement typerec
for that kind of argument.

9 Summary and related work
This paper develops a type-erasure language supporting higher-order type analysis, necessary for run-time polytypic programming. While type-erasure versions
of several other type analyzing languages have been previously developed (Crary
et al., 2002; Saha et al., 2000), several aspects of the source language made this a
not-so-straightforward task.

The largest difficulty was to develop a kind-directed operational semantics for

Type-Safe Run-time Polytypic Programming 25
typerec so that we did not need to rely on the syntactic properties of the representations of higher kinds. This operational semantics is similar to Stone and Harper's
language with singleton kinds (Stone & Harper, 2000), which was inspired by Coquand's approach to fij-equivalence for a type theory with \Pi  types and one universe (Coquand, 1991). Because equivalence of constructors in Stone and Harper's
language strongly depends on the kind at which they are compared, their procedure drives the kind of the compared terms to the base form before weak-head
normalizing and comparing structurally.

A second issue with creating the type-erasure language was that we did not
want to define a version of evaluation for terms with free variables. Instead, we
chose to directly replace those variables with a place holder for the result of their
interpretation. This place holder draws inspiration from the calculus of Trifonov et
al. (Trifonov et al., 2000) who themselves refer to Fegaras and Sheard (Fegaras &
Sheard, 1996). Fegaras and Sheard designed their calculus to extend catamorphisms
to datatypes with parametric function spaces, employing a place holder as the trivial
inverse of the iterator. Trifonov et al. adapted this idea in a type-level Typerec
for recursive types. Like the parameterized return constructor of the R-type in
this calculus, they parameterize the return kind of a Typerec iteration. Such an
extension to LHR would allow a higher-order type-level Typerec. Washburn and
Weirich (Washburn & Weirich, 2003) examine the general technique of using a place
holder to implement induction over higher-order abstract syntax. In particular, they
are able to show a close connection between using this technique in F! and the
modal calculus of Sch"urmann, Despeyroux and Pfenning (Sch"urmann et al., 2001).

The result of this paper, however, is a fairly simple type-erasure language that
supports higher-order type analysis. Such a language is an important step in the implementation of a system that allows run-time polytypic programming. The calculus
that we have defined is simple to implement: we give a prototype implementation in
only a few lines. Closely related work to this paper is a proposal for DependencyStyle Generic Haskell (L"oh et al., 2003) that addresses the problem in Generic
Haskell of defining polytypic operations that depend on one another. Because general representations to the branches of polytypic operations are already provided,
that capability already exists in LHR to some extent. Furthermore, by not allowing
type interpretation at run-time (or any sort of general run-time type information),
Generic Haskell cannot allow types to be defined in separate modules from generic
operations or analyze first-class abstract types.

Important future work is the integration of type-level type analysis to this language, as is found in intensional type. Although there are many examples of polytypism where the result of a type-analyzing function can be described parametrically in
terms of its argument, this is not always the case. For example, Hinze et al. (Hinze
et al., 2002) describe how the type of generalized tries depends on the key type.

Other future work includes a practical implementation based on the LHR language in this paper. The prototype implementation has the advantage of being
small and implementable as a Haskell library. However, if these facilities were provided as a Haskell extension, they might be made more easy for programmers to
use. For example, some of the complexity of defining polytypic operations comes

26 S. Weirich
from using a newtype to specify the return type constructor. A specialized extension could integrate some form of local type inference (Pierce & Turner, 1998) to
specify this type constructor and not require the coercions to and from the newtype.
Furthermore, defining the branches of the polytypic function as records is somewhat awkward, and could be improved with specialized syntax. Finally, a Haskell
extension could automatically define the representations of user defined datatypes,
instead of requiring that they be supplied by users.

References
Abadi, M., Cardelli, L., Pierce, B. and Plotkin, G. (1991) Dynamic typing in a staticallytyped language. ACM Transactions on Programming Languages and Systems 13(2):237-
268.

Abadi, M., Cardelli, L., Pierce, B. and R'emy, D. (1995) Dynamic typing in polymorphic

languages. Journal of Functional Programming 5(1):111-130.

Cheney, J. and Hinze, R. (2002) Poor man's dynamics and generics. Chakravarty, M. M.

(ed), Proceedings of the ACM SIGPLAN 2002 Haskell Workshop. ACM Press.

Coquand, T. (1991) An algorithm for testing conversion in type theory. Huet, G. and

Plotkin, G. (eds), Logical Frameworks pp. 255-277. Cambridge University Press.

Crary, K. and Weirich, S. (1999) Flexible type analysis. Proceedings of the Fourth ACM

SIGPLAN International Conference on Functional Programming (ICFP) pp. 233-248.

Crary, K., Weirich, S. and Morrisett, G. (2002) Intensional polymorphism in type erasure

semantics. Journal of Functional Programming 12(6):567-600.

Dubois, C., Rouaix, F. and Weis, P. (1995) Extensional polymorphism. Twenty-Second

ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)
pp. 118-129.

Fegaras, L. and Sheard, T. (1996) Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer space). Conf. Record 23rd ACM SIGPLAN/SIGACT Symp. on Principles of Programming Languages, POPL'96, St. Petersburg Beach, FL, USA, 21-24 Jan. 1996, pp. 284-294. ACM Press.

Girard, J.-Y. (1971) Une extension de l'interpr'etation de G"odel `a l'analyse, et son application `a l''elimination de coupures dans l'analyse et la th'eorie des types. Fenstad,
J. E. (ed), Proceedings of the Second Scandinavian Logic Symposium pp. 63-92. NorthHolland Publishing Co.

Girard, J.-Y. (1972) Interpr'etation fonctionelle et 'elimination des coupures de

l'arithm'etique d'ordre sup'erieur. PhD thesis, Universit'e Paris VII.

Harper, R. and Morrisett, G. (1995) Compiling polymorphism using intensional type

analysis. Twenty-Second ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL) pp. 130-141.

Hinze, R. (2000) Polytypic values possess polykinded types. Backhouse, R. and Oliveira,

J. (eds), Proceedings of the Fifth International Conference on Mathematics of Program
Construction (MPC 2000) pp. 2-27.

Hinze, R., Jeuring, J. and L"oh, A. (2002) Type-indexed data types. Eerke Boiten, B. M.

(ed), Proceedings of the Sixth International Conference on Mathematics of Program
Construction (MPC 2002) pp. 148-174.

Jansson, P. and Jeuring, J. (1997) PolyP--A polytypic programming language extension. Twenty-Fourth ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL) pp. 470-482.

Type-Safe Run-time Polytypic Programming 27
Jay, C. B., Bell`e, G. and Moggi, E. (1998) Functorial ML. Journal of Functional Programming 8(6):573-619.

L"oh, A., Clarke, D. and Juering, J. (2003) Dependency-style Generic Haskell. ACM

SIGPLAN International Conference on Functional Programming (ICFP). To appear.

Morrisett, G. and Harper, R. (1997) Semantics of memory management for polymorphic

languages. Gordon, A. D. and Pitts, A. M. (eds), Higher Order Operational Techniques
in Semantics. Cambridge University Press.

Morrisett, G., Felleisen, M. and Harper, R. (1995) Abstract models of memory management. FPCA95: Conference on Functional Programming Languages and Computer
Architecture (FPLCA) pp. 66-77.

Odersky, M. and L"aufer, K. (1996) Putting type annotations to work. Conference Record

of POPL '96: The 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, St. Petersberg Beach, Florida pp. 54-67.

Peyton Jones, S. (ed). (2003) Haskell 98 Language and Libraries: The Revised Report.

Cambridge University Press.

Pierce, B. C. and Turner, D. N. (1998) Local type inference. Conference Record of POPL

98: The 25TH ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages pp. 252-265.

Reynolds, J. C. (1983) Types, abstraction and parametric polymorphism. Information

Processing '83 pp. 513-523. North-Holland. Proceedings of the IFIP 9th World Computer Congress.

Ruehr, F. (1998) Structural polymorphism. Backhouse, R. and Sheard, T. (eds), Informal

Proceedings Workshop on Generic Programming, WGP'98, Marstrand, Sweden, 18 June
1998.

Saha, B., Trifonov, V. and Shao, Z. (2000) Fully reflexive intensional type analysis in type

erasure semantics. Third ACM SIGPLAN Workshop on Types in Compilation.

Sch"urmann, C., Despeyroux, J. and Pfenning, F. (2001) Primitive recursion for higherorder abstract syntax. Theoretical Computer Science 266(1-2):1-58.

Sheard, T. (1993) Type parametric programming. Tech. rept. CSE 93-018. Oregon Graduate Institute.

Stone, C. and Harper, R. (2000) Deciding type equivalence in a language with singleton

kinds. Twenty-Seventh ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL) pp. 214-225.

Trifonov, V., Saha, B. and Shao, Z. (2000) Fully reflexive intensional type analysis. Fifth

ACM SIGPLAN International Conference on Functional Programming (ICFP) pp. 82-
93.

Wadler, P. (1989) Theorems for free! FPCA89: Conference on Functional Programming

Languages and Computer Architecture (FPLCA).

Wadler, P. and Blott, S. (1989) How to make ad-hoc polymorphism less ad hoc. Sixteenth

ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)
pp. 60-76. ACM Press.

Washburn, G. and Weirich, S. (2003) Boxes go bananas: Encoding higher-order abstract

syntax with parametric polymorphism. ACM SIGPLAN International Conference on
Functional Programming (ICFP) pp. 249-262.

Weirich, S. (2001) Encoding intensional type analysis. Sands, D. (ed), 10th European

Symposium on Programming (ESOP) pp. 92-106.

Weirich, S. (2002a) Higher-order intensional type analysis. M'etayer, D. L. (ed), 11th

European Symposium on Programming (ESOP) pp. 98-114.

Weirich, S. (2002b) Programming With Types. PhD thesis, Cornell University. 238 pages.

28 S. Weirich

A Correctness of Embedding
We call the LH language with the operational semantic of Figure 7 LK. Below we
prove the correctness of the translation between LK and LHR.

A.1 Static correctness
The static correctness of this translation follows from a straightforward set of inductive arguments. To prove that the translation of a LK term is well-typed in
LHR, we must show that the representation of a LK-constructor has the correct
representation type.

Because we essentially have two versions of type representations--one for constructors that may have variables bound by an enclosing typerec, and one for constructors that are in other contexts, there are two lemmas about the type soundness
of the representations.

In these two results, we must define two different translations of \Delta  to produce the
context for the type representations variables. In the first case, the translation is
specialized by a return type constructor. The type of each representation variable
must be specialized to this constructor. In the second case, for those variables
bound by a term-level type abstraction (\Lambda ), the types of the representations must
be polymorphic over the return type.

|\Delta , ff:^|c = |\Delta |o/0, yff : [o/ 0]hhff : ^ii

|\Delta , ff:^| = |\Delta |, xff : bRhff : ^i
In the following two lemmas, we show that the representation of a constructor o/ is
well-typed. The free variables of o/ may be bound in many different situations. We
let \Delta 1 refer to all of those bound by enclosing term-level type abstractions (\Lambda ), \Delta 2
refer to variables bound by type level type abstractions (*) or by enclosing typerec
expressions.

Lemma A.1
Let \Delta  = \Delta 1, \Delta 2. If \Delta  ` o/ : ^ and \Delta 1, ` o/ 0 : ? ! ? then

\Delta 1\Delta 2; |\Delta 1|, |\Delta 2|o/0 ` R[[o/]]((\Delta 2,o/0)) : [Ro/ 0]hho/ : ^ii
Another lemma that we need is that the translation of a LH polykinded type is
a LHR polykinded type.

Lemma A.2
If T [[[o/ 0]ho/ : ^i]] = [o/ 0]hho/ : ^ii.

We may now prove the static correctness of phase-splitting.
Theorem A.3 (Static Correctness)
If \Delta ; \Gamma  ` e : oe then \Delta ; |\Delta |, T [[\Gamma ]] ` E[[e]] : T [[oe]]

Type-Safe Run-time Polytypic Programming 29

Type-fi
(\Lambda fi:? ! ?.e)[o/] jE e[o//fi]

Symmetry

e0 jE e
e jE e0

Congruence rules

i jE i x jE x R\Phi  jE R\Phi 
e jE e0
*x:oe.e jE *x:oe.e0

e1 jE e01 e2 jE e02

e1e2 jE e01e02

e jE e0
\Lambda ff:^.e jE \Lambda ff:^.e0

e jE e0
e[o/] jE e0[o/]

e jE e0 `(\Phi ) jE e0\Phi 
typerec[^][o/] e ` jE typerec[^][o/] e0 `0

e jE e0 `(\Phi ) jE e0\Phi 
untyrec[^][o/] e ` jE untyrec[^][o/] e0 `0

Fig. A 1. Type fi-equivalence

A.2 Dynamic correctness
We will prove operational correctness up to the definition in Figure A.2 of equivalence of result terms. The symbol jE relates two LHR terms that differ only by type
fi-expansions. This notion of equivalence does not weaken our dynamic-correctness
result as all equal terms differ only in the type annotations. All equivalent terms
have the same erasure, so we can argue that they model the same computation.

The reason that we can prove operational correctness only up to this notion of
equivalence is because of how substitution interacts with the definition of representation. We would like substitution to commute with representation, but that is not
the case. R

[[o/1[o/2/ff]]](\Delta ,o/) 6= R[[o/1]](\Delta ,o/)[o/2/ff][ bR[[o/2]]/xff]
For example, if o/1 is ff then the left hand side equals R[[o/2]](\Delta ,o/) while the right
hand side equals (xff[o/])[ bR[[o/2]]/xff] = (\Lambda fi:? ! ?.R[[o/2]](\Delta ,fi))[o/ ].

Proposition A.4
By examination of the definition of jE , we assert the following properties of this
relation:

1. jE is an equivalence relation.
2. If e1 jE e2 then e[e1/x] jE e[e2/x].
3. If e1 jE e2 then e1[e/x] jE e2[e/x].
4. If e is not of the form (\Lambda fi:? ! ?.e1)[o/ ] and e jE e0 then e0 7!* e00 where e00

has the same outermost form as e and e00 jE e.

30 S. Weirich
Lemma A.5 (Strengthening)
If ff is not free in o/ , then for any \Delta , c, o/ 0,

R[[o/ ]](\Delta {ff)^},o/0) = R[[o/ ]](\Delta ,o/0)
Proof
Examination of the definition of R[[o/]](\Delta ,o/0).

Lemma A.6 (Substitution of closed constructors)
If \Delta , ff:^2 ` o/1 : ^1 and ; ` o/2 : ^2 then

R[[o/1[o/2/ff]]](\Delta ,o/) jE R[[o/1]](\Delta ,o/)[o/2/ff][ bR[[o/2]]/xff]
Lemma A.7 (Open substitution)
If \Delta , ff:^0 ` o/1 : ^ and \Delta  ` o/2 : ^0 then

R[[o/1[o/2/ff]]](\Delta ,o/) jER

[[o/1]](\Delta {ff)^0},o/)[o/2/ff][ bR[[o/2]]/xff][R[[o/2]](\Delta ,o/)/yff]

Lemma A.8
If \Delta  ` o/1 : ^ and o/1 wh o/2 then for all e1 jE R[[o/1]]((\Delta ,o/0)), e1 7!* e2 and
e2 jE R[[o/2]]((\Delta ,o/0)).

Corollary A.9
If o/ weak head normalizes to p, and e jE R[[o/ ]]((\Delta ,c,\Psi )) then e 7!* p0 jE R[[p]]((\Delta ,o/)).

Lemma A.10 (Path correctness)
If ; `^ typerec[o/ 0]hp : ?i of `, j : oe and typerec[o/ 0]hp : ?i of `, j )k e and `0 jE E[[`]]
and p0 jE R[[p]]((;,o/0,(\Delta ,E[[j]],ae,E[[`]]))) then

typerec[o/ 0] p0 `0 )LHR e2 jE E[[e]].
Lemma A.11 (Typerec Correctness)
If typerec[o/ 0]ho/ : ^i of `, j 7!k e and e1 jE E[[typerec[o/0]ho/ : ^i of `, j]] then e1 7!*LHR
e2 jE E[[e]].

Lemma A.12 (Constructor substitution)
If \Delta , ff:^; \Gamma  ` e : oe and \Delta  ` o/ : ^, then E[[e[o//ff]]] jE E[[e]][o//ff][ bR[[o/ ]]xff].

Lemma A.13 (Term substitution)
If \Delta , ; \Gamma , x : oe0 ` e : oe and \Delta ; \Gamma  ` e0 : oe0, then E[[e[e0/x]]] = E[[e]][E[[e0]]/x].

Lemma A.14 (Dynamic correctness)
If ; ` e1 : oe and e1 7!k e2 then if e01 jE E[[e1]], e01 7!*LHR e02 jE E[[e2]].