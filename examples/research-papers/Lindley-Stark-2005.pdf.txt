

Appears in Proceedings of TLCA 2005, Nara, Japan,

LNCS 3461, pp.262-277. Springer-Verlag, 2005

Reducibility and ??-liftingfor Computation Types

Sam Lindley and Ian Stark?
Laboratory for Foundations of Computer Science
School of Informatics, The University of Edinburgh, Scotland

{Ian.Stark,Sam.Lindley}@ed.ac.uk

Abstract. We propose ??-lifting as a technique for extending operational predicates to Moggi's monadic computation types, independent of the choice of
monad. We demonstrate the method with an application to Girard-Tait reducibility, using this to prove strong normalisation for the computational metalanguage *ml. The particular challenge with reducibility is to apply this semantic
notion at computation types when the exact meaning of "computation" (stateful,
side-effecting, nondeterministic, etc.) is left unspecified. Our solution is to define
reducibility for continuations and use that to support the jump from value types
to computation types. The method appears robust: we apply it to show strong
normalisation for the computational metalanguage extended with sums, and with
exceptions. Based on these results, as well as previous work with local state, we
suggest that this "leap-frog" approach offers a general method for raising concepts defined at value types up to observable properties of computations.

1 Introduction
Moggi's computational metalanguage *ml is a typed calculus for describing program-ming languages with real-world features like exceptions, nondeterminism and sideeffects. It refines the pure simply-typed lambda-calculus by explicitly distinguishingvalues from computations in the type system: for each type

A of values, there is a type
T A of programs that compute a value of type A. The calculus specifies that the typeconstructor

T be a strong monad, which is enough to support a wide range of notionsof computation [5, 21, 22, 33].

In this paper we present ??-lifting: a method for reasoning about properties ofcomputations in

*ml , independent of the underlying monad, by raising up conceptsdefined explicitly on values.

We demonstrate the technique with a type-directed proof of strong normalisationfor
*ml , extending Girard-Tait reducibility to handle computation types. We also applyit to some extensions of

*ml , and observe that ??-lifting gives a smooth treatment ofreducibility for commuting conversions.

Section 2 provides a brief review of the computational metalanguage and relatedsystems. Reduction in

*ml properly extends that in the simply-typed lambda-calculus,with three reductions specific to computations. One of these,

T.assoc, is a commuting

? Supported by an EPSRC Advanced Research Fellowship

http://www.ed.ac.uk/~stark/reducibility.html

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
conversion; another, T.fi, involves substituting one term within another; which maymake a term grow larger, and create subterms not present before. As usual with these
kinds of reduction, the consequence is that straightforward induction over the structureof terms or types is not enough to prove termination of

*ml reduction.
In earlier work, Benton et al. proved strong normalisation for *ml terms bytranslating them into a lambda-calculus with sums, and then invoking Prawitz's result

for that system [4]. Our alternative is to use ??-lifting to give a standalone proof ofstrong normalisation, inductively on the structure of

*ml types.
Section 3 sets out the details. We define an auxiliary notion of reducibility at everytype, that is linked to strong normalisation but amenable to induction over the structure

of types. This is a standard technique from the lambda-calculus: roughly, reducibility isthe logical predicate induced by strong normalisation at ground types. We show that all

reducible terms are strongly normalising, and go on to prove the fundamental theoremof logical relations, that in fact all definable terms are reducible.

The challenge, and the chief technical contribution of this paper, is to find a suitabledefinition for reducibility at computation types. Some such definition is essential, as
the type constructor T is intentionally left unspecified. A first informal attempt mightbe to echo the definition for functions, and look at the immediate application of a
computation:
(Bad 1) Term M of type T A is reducible if for all reducible N of type T B, the termlet

x ( M in N is reducible.

This is not inductive over types, as the definition of reducibility at type T A depends onreducibility at type

T B, which may be more complex. We can try to patch this:

(Bad 2) Term M of type T A is reducible if for all strongly normalising N oftype

T B, the term let x ( M in N is strongly normalising.

However, this turns out to be too weak to prove properties of M in richer contextslike let

y ( (let x ( (-) in N ) in P . Examining the structure of these, we define a
continuation K as a nested sequence of let xi ( (-) in Ni, and use these for ourdefinition of reducibility:

(Good 1) Term M of type T A is reducible if for all reducible continuations K, theapplication

K @ M is strongly normalising.

Here application means pasting term M into the hole (-) within K. Of course, we nowhave to define reducibility for continuations:

(Good 2) Continuation K accepting terms of type T A is reducible if for all re-ducible

V of type A, the application K @ [V ] is strongly normalising.

The term [V ] is the trivial computation returning value V . By moving to the simplervalue type

A we avoid a potential circularity, and so get a notion of reducibility definedby induction on types. What is more, the characterisation by continuations is strong

enough to treat both the commuting conversion T.assoc and substitution in T.fi, andthe strong normalisation proof goes through without undue difficulty.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
Looking beyond reducibility, this jump over continuations offers a quite general methodto raise concepts from value type

A up to computation type T A, whether or not weknow the nature of
T . Suppose that we write K ? M when K applied to M is stronglynormalising, and for any predicate

OE ` A define in turn:

OE? = { K | K ? [V ] for all V 2 OE }
OE?? = { M | K ? M for all K 2 OE? } ` T A .

This is our operation of ??-lifting: to take a predicate OE on value type A and returnanother

OE?? on the computation type T A, by a "leap-frog" over OE? on continuations.One informal view of this is that continuations

K represent possible observations onterms, and
OE?? lifts OE to computations based on their observable behaviour.We believe that the use of ??-lifting in the metalanguage

*ml is original. It wasinspired by similar constructions applied to specific notions of computation; it is

also related to Pitts's ??-closure, and that in turn has analogues in earlier work onreducibility. Section 5.1 discusses this further.

In Sect. 4 we demonstrate ??-lifting for reducibility in some variations of *ml ; treatingsums, exceptions, and Moggi's

*c. For each case we vary our notion of continuation,
but leave the definition of (-)?? unchanged. Notably, this includes the commutingconversions introduced by sums. Section 5 discusses related work, and concludes with

some possible future directions.

2 The Computational Metalanguage
We start with a standard simply-typed lambda-calculus with ground type 0, product
A * B and function space A ! B for all types A and B. The computationalmetalanguage extends this with a type constructor

T and two term constructions:

- For each A there is a type T A, of computations that return an answer in A.
- The lifted term [M ] is the computation which simply returns the answer M .
- The composition term let x ( M in N denotes computing M, binding the answerto

x and then computing N .

Fig. 1 presents typing1 and reduction rules for this language *ml . It corresponds toMoggi's

*MLT [21]. In categorical terms, this is the internal language for a cartesianclosed category with a strong monad

T . More concretely, it is also what lies behind theuse of monads in the Haskell programming language, where

T is any type constructorin the
Monad class and the term formers are return M for lifting and do {x<-M; N}for composition [24].

Often we do not require the full power of *ml , and there are two commonsimplifications: first, that all functions must return computations, thus having type

A !
T B; and second, that this is the only place where T can occur. These constrain the

1 Our presentation of typing follows Girard et al. [14], in that we assume a global assignment

of types to variables. This is in contrast to typing "`a la Curry" and typing "`a la Church" [2],
which use local typing contexts.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
calculus to represent computations and only computations, disallowing pure functionsof type

A ! B as well as metacomputations like those with type T A ! T B and
T (T A).

With both of these restrictions in place we obtain the sub-calculus *ml*. Thiscontains the call-by-value embedding [16] of the simply-typed lambda-calculus into

the computational metalanguage; with the attention on functions of type A ! T Bembodying call-by-value semantics.

It turns out that the terms of *ml* are so constrained that we can dispense withexplicit lifting and computation types, replacing them by a simple syntactic separation
of values V from non-values M. This leaves only the let-construction, and we havea subset

*c* of Moggi's computational lambda-calculus *c [20]. Sabry and Wadlerdiscuss in detail the correspondences between

*ml , *ml*, *c* and *c [28]. Our resultson
*ml apply directly to its restriction *ml*; however, *c has extra reduction rules, andin Sect. 4.3 we give a ??-lifting approach to cover these too.

The reductions for *ml appear in the last part of Fig. 1. These extend thosefor the simply-typed lambda-calculus with three reductions that act only on terms
of computation type: T.fi, T.j and T.assoc. Before looking more closely at thesethree, we review some relevant properties of typed reduction, and the notion of strong
normalisation.
Proposition 1. Reduction in the computational metalanguage preserves types and is
itself preserved under substitution.

(i) If M : A and M ! M0 then M 0 : A.
(ii) If M ! M 0 then M[x := N] ! M 0[x := N ].

Proof. Induction on the derivation of M : A and the structure of M respectively. ut
Definition 2. A term M in some calculus is strongly normalising (it is SN) if there isno infinite reduction sequence

M ! M1 ! * * * . In this case we write max (M ) for thelength of the longest reduction sequence starting from

M . A calculus itself is stronglynormalising if every term in it is strongly normalising.

We use the results of Prop. 1 repeatedly in the proofs for Sect. 3, and also the following:

Corollary 3. If the *ml term M[x := N ] is strongly normalising, then so is M.

Proof. By contradiction, from Prop. 1(ii): suppose M has some infinite reductionsequence

M ! M1 ! * * * ; then so does M [x := N ] ! M1[x := N ] ! * * * . If
M[x := N ] has no such sequence, then neither does M and both are SN. ut

It is standard that under fi-reduction the untyped lambda-calculus is not stronglynormalising. For example, the term

\Omega  = (*x.xx)(*x.xx) fi-reduces to itself, leading tothe infinite reduction sequence
\Omega  !fi \Omega  !fi . . . . On the other hand, the simply-typedlambda-calculus is strongly normalising with respect to

fi-reduction [14]: in particular,
\Omega  has no simple type.

We shall be investigating strong normalisation with the additional terms and reduc-tions of

*ml from Fig. 1. The reductions to watch are T.fi and T.assoc: like !.fi, a

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
Syntax
Types A, B ::= 0 | A ! B | A * B | T A
Terms L, M, N, P ::= xA | *xA.M | MN | hM, Ni | ss1(M) | ss2(M)

| [M] | let xA ( M in N

Typing

xA : A

M : B
*xA.M : A ! B

M : A
[M] : T A

M : A ! B N : A

MN : B

M : T A N : T B
let xA ( M in N : T B

M : A N : Bh

M, Ni : A * B

M : A1 * A2

ssi(M) : Ai i = 1, 2

Reductions
!.fi (*x.M)N -! M[x := N]
!.j *x.Mx -! M if x/2fv(M)

* .fii ssi(hM1, M2i) -! Mi i = 1, 2
* .j hss1(M), ss2(M)i -! M

T.fi let x ( [N] in M -! M[x := N]
T.j let x ( M in [x] -! M
T.assoc let y ( (let x ( L in M) in N -! let x ( L in (let y ( M in N) if x/2fv(N)

Fig. 1. The computational metalanguage *ml .

T.fi step performs substitution, and so may enlarge the term at hand; while T.assoc isa commuting conversion, also termed a permutation or permutative conversion. Commuting conversions are so named for their transforming action, via the Curry-Howardisomorphism, on derivation trees in natural deduction (indeed, the counterpart in logic
of T.assoc is described in [4]). They also arise when the lambda-calculus is extendedwith sums, and are known for the issues they can cause in proofs over reduction systems.
Prawitz originally addressed this in [27]; see [17] for a discussion and further references.As we shall see below, ??-lifting uses structured continuations to perform proof over

commuting conversions.

3 Reducibility
We present ??-lifting with the concrete example of a proof of strong normalisationin

*ml , by extending the type-directed reducibility approach originally due to Tait [29].We follow closely the style of Girard et al. [14, Chap. 6]; although in this short

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
presentation we focus on the proof parts specific to *ml , with full details appearingelsewhere [19]. As explained earlier, the key step is to find an appropriate definition
of reducibility for computation types, which we do by introducing a mechanism formanaging continuations.

3.1 Continuations
Informally, a continuation should capture how the result of a computation might be usedin a larger program. Our formal definition is structured to support inductive proof about

these uses.

- A term abstraction (x)N of type T A ( T B is a computation term N of type T Bwith a distinguished free variable

x of type A.

- A continuation K is a finite list of term abstractions, with length |K|.

K ::= Id | K ffi (x)N |Id | = 0|K ffi (x)N | = |K| + 1
- Continuations have types assigned using the following rules:

Id : T A ( T A (x)N : T A ( T B K : T B ( T CK ffi (x)N : T A ( T C .
- We apply a continuation of type T A ( T B to a computation term M of type T Aby wrapping

M in let-statements that use it:

Id @ M = M
(K ffi (x)N ) @ M = K @ (let x ( M in N )

Notice that when |K| > 1 this is a nested stack of computations, not simplesequencing: i.e.

let x1 ( (let x2 ( (. . . (let xn ( M in Nn)) . . . in N2) in N1
rather than

let x1 ( M1 in let x2 ( M2 in . . . in let xn ( Mn in N .
Although these two are interconvertible by a sequence of T.assoc rewrites, wecannot identify them while we are looking to confirm strong normalisation in the

presence of substituting rewrites like !.fi and T.fi.In fact, it is exactly this nesting structure that we use to tackle

T.assoc in our keyLemma 7; essentially, the stack depth of a continuation tracks the action of the

commuting conversion.
- We define a notion of reduction on continuations:

K ! K0 def() 8M . K @ M ! K0 @ M()

K @ x ! K0 @ x

where the second equivalence follows from Prop. 1(ii). A continuation K isstrongly normalising if all reduction sequences starting from

K are finite; and inthis case we write max (
K) for the length of the longest.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
Lemma 4. If K ! K0, for continuations K and K0, then |K0| <= |K|.
Proof. Suppose K = Id ffi (x1)Nn ffi * * * ffi (xn)Nn. Then its application K @ x =let

x1 ( (. . . (let xn ( x in Nn) . . . ) in N1 and there are only two reductions thatmight change the length of

K.

- T.j where Ni = [xi] for some i. Then K ! K0 where K0 = Id ffi (x1)N1 ffi * * * ffi(

xi-1)Ni-1 ffi (xi+1)Ni+1 ffi * * * ffi (xn)Nn and |K0| = |K| - 1.

- T.assoc may occur at position i for 1 <= i < n to give K0 = (x1)N1 ffi * * * ffi(

xi-1)Ni ffi (xi+1)(let xi ( Ni+1 in Ni) ffi (xi+2)Ni+2 ffi * * * ffi (xn)Nn. Again|
K0| = |K| - 1.

Hence |K0| <= |K| as required. ut

3.2 Reducibility and Neutrality
Figure 2 defines two sets by induction on the structure of types: reducible terms redA oftype

A, and reducible continuations red?A of type T A ( T B for some B. As describedin the introduction, for computations we use

redT A = red??A .We also need to classify some terms as neutral; we do this by decomposing every

reduction into a rewrite context with a hole that must be plugged with a term of aparticular form (see Fig. 2 again). From this we define:

- Term M is active if R[M ] is a redex for at least one of the rewrite contexts.- Term

M is neutral if R[M] is not a redex for any of the rewrite contexts.

The neutral terms are those of the form x, M N , ss1(M) and ss2(M ); i.e. computationtypes add no new neutral terms. The basic properties of reducibility now follow (CR 1)-

(CR 4) of [14].
Theorem 5. For every term M of type A, the following hold.

(i) If M 2 redA, then M is strongly normalising.(ii) If

M 2 redA and M ! M 0, then M 0 2 redA.(iii) If
M is neutral, and whenever M ! M0 then M 0 2 redA, then M 2 redA.(iv) If
M is neutral and normal (has no reductions) then M 2 redA.

Proof. Part (iv) is a trivial consequence of (iii), so we only need to prove (i)-(iii),which we do by induction over types. The proof for ground, function and product types

proceeds as usual [14]. Here we expand the details for computation types:

(i) Say M 2 redT A. By the induction hypothesis (i), for every N 2 redA we have that

N is SN, and so [N ] is too. This is enough to show that Id : T A ( T A is in red?A,and so Id @

M = M is SN as required.

(ii) Suppose M 2 redT A and M ! M 0. For all K 2 red?A, application K @ M is SN,and

K @ M ! K @ M 0; thus K @ M0 is SN and M 0 2 redT A as required.

(iii) Take M : T A neutral with M 0 2 redT A whenever M ! M0. We have to show that

K @ M is SN for each K 2 red?A. First, we have that K @ [x] is SN, as x 2 redA bythe induction hypothesis (iv). Hence

K itself is SN, and we can work by inductionon max (
K).

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
Reducibility for terms and continuations

M 2 red0 if the ground term M is strongly normalising

F 2 redA!B if F M 2 redB for all M 2 redA
P 2 redA*B if ss1(P ) 2 redA and ss2(P ) 2 redB

M 2 redTA if K @ M is strongly normalising for all K 2 red?A

K 2 red?A if K @ [N] is strongly normalising for all terms N 2 redA.

Reduction Rewrite context Active term!

.fi -N *x.M!

.j - *x.Mx

*.fii ssi(-) hM, Ni*

.j - hss1(M), ss2(M)i

T.fi let x ( - in M [N]

T.j let x ( M in - [x]
T.assoc let y ( - in N let x ( L in M

Fig. 2. Reducibility and neutrality for *ml

Application K @ M may reduce as follows:*

K @ M0, where M ! M0, which is SN as K 2 red?A and M 0 2 redT A.*
K0 @M, where K ! K0. For any N 2 redA, K @[N ] is SN as K 2 red?A; and
K @ [N ] ! K0 @ [N ], so K0 @ [N] is also SN. From this we have K0 2 red?Awith max (

K0) < max (K), so by the induction hypothesis K0 @ M is SN.

There are no other possibilities as M is neutral. Hence K @ M is stronglynormalising for every

K 2 red?A, and so M 2 redT A as required. ut

3.3 Reducibility Theorem
We show that all terms are reducible, and hence strongly normalising, by induction ontheir syntactic structure. This requires an appropriate lemma for each term constructor.

Here we set out proofs for the new constructors associated with computation: lifting [-]and let. The other cases follow as usual from the properties of Thm. 5, and are set out

in [19].
Lemma 6. Lifting preserves reducibility: if term P 2 redA then [P ] 2 redT A.
Proof. For any continuation K 2 red?A, the application K @ [P ] is SN, as P 2 redA;and so [

P ] 2 redT A. ut

We next wish to show that formation of let-terms preserves reducibility. That will beLemma 8, but we first need a result on the strong normalisation of let-terms in context.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
This is the key component of our overall proof, and is where our attention to thestack-like structure of continuations pays off: the challenging case is the commuting
conversion T.assoc, which does not change its component terms; but it does alterthe continuation stack length, and this gives enough traction to maintain the induction
proof.
Lemma 7. Let P : A be a term, (x)N : T A ( T B a term abstraction, and
K : T B ( T C a continuation, such that both P and K @ (N [x := P ]) are stronglynormalising. Then

K @ (let x ( [P ] in N ) is strongly normalising.

Proof. We show by induction on |K| + max (K @ N ) + max (P ) that the reducts of
K @ (let x ( [P ] in N ) are all SN. The interesting reductions are as follows:

- T.fi giving K @ (N [x := P ]), which is SN by hypothesis.
- T.j when N = [x], giving K @ [P ]. But K @ [P ] = K @ (N [x := P ]), which isagain SN by hypothesis.

- T.assoc in the case where K = K0 ffi (y)M with x /2 fv (M); giving the reduct

K0 @(let x ( [P ] in (let y ( N in M )). We aim to apply the induction hypothesiswith

K0 and (let y ( N in M ) for K and N , respectively. Now

K0 @ ((let y ( N in M )[x := P ]) = K0 @ (let y ( N [x := P ] in M )

= K @ (N [x := P ])

which is SN by hypothesis. Also
|K0|+max (K0 @(let y ( N in M))+max (P ) < |K|+max (K @N )+max (P )
as |K0| < |K| and (K0 @ (let y ( N in M)) = (K @ N ). This last equal-ity explains our use of max (

K @ N ); it remains fixed under T.assoc, un-like max (
K) and max (N ). Applying the induction hypothesis gives that
K0 @ (let x ( [P ] in (let y ( N in M)) is SN as required.

Other reductions are confined to K, N or M , and can be treated by the inductionhypothesis, decreasing either max (

K @ N) or max (M ). ut

We are now in a position to prove that composing computations in let-terms preservesreducibility.

Lemma 8. If M 2 redT A and (x)N : T A ( T B has N[x := P ] 2 redT B for all
P 2 redA, then (let x ( M in N ) 2 redT B.

Proof. Given a continuation K 2 red?B, we must show that K @ (let x ( M in N ) isSN. Now for any

P 2 redA, application K @ (N [x := P ]) is SN, as K 2 red?B and
N[x := P ] 2 redTB by hypothesis. But P is also SN, by Thm. 5(i), and so Lemma 7shows that

K @ (let x ( [P ] in N ) is SN too. This proves that (K ffi (x)N ) 2 red?A, soapplying it to

M 2 redT A gives that K @ (let x ( M in N ) is SN as required. ut

We finally reach the desired theorem via a stronger result on substitutions into openterms.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
Theorem 9. Let M : B be some term with free variables x1 : A1, . . . , xk : Ak. Thenfor any

N1 2 redA1, . . . , Nk 2 redAk we have M [x1 := N1, . . . , xk := Nk] 2 redB.

Proof. By induction on the structure of the main term. For computation terms we have:

- [P ], where P : A. By the induction hypothesis P [~x := ~N ] 2 redA, and by Lemma 6

we get [P ][~x := ~N ] = [P [~x := ~N ]] 2 redTA as required.
- let x ( L in M, where L : T C and M : T B. The induction hypothesis is that

L[~x := ~N ] 2 redTC, and M[~x := ~N , x := P ] 2 redT A for all P 2 redC. Lemma 8

gives (let x ( L in M)[~x := ~N ] = let x ( L[~x := ~N ] in M [~x := ~N ] 2 redT A. ut

Theorem 10. Each *ml term M : A is in redA, and hence strongly normalising.
Proof. Apply Thm. 9 with Ni = xi, where xi 2 redAi by Thm. 5(iv). This tells us that
M 2 redA, and by Thm. 5(i) also strongly normalising. ut

4 Extensions
In this section we apply ??-lifting to reducibility in some extensions of *ml : withsum types, with exceptions; and in the computational lambda-calculus

*c. Both sumsand exceptions have existing normalisation results in the standard lambda-calculus (for

example, [11] and [18, Thm. 6.1]); we know of no prior proofs for them in *ml . Moreimportant, though, is to see how ??-lifting adapts to these features. The key step is to
extend our formalized continuations with new kinds of observation. Once this is done,we can use these to lift predicates to computation types. The case of reducibility, and
hence a proof of strong normalisation, then goes through as usual. Here we can onlysummarize, and full details appear in [19].

4.1 Reducibility for Sums
Prawitz first showed how to extend reducibility to sums [27]. His method is quiteintricate: for a term

M of sum type to be reducible, not only must the immediatesubterms of
M be reducible, but also a certain class of subterms of M0 must be reduciblewhenever
M reduces to M0. We avoid this complexity by defining reducibility for sumsas we do for computations, by a leap-frog over continuations.

We begin by extending *ml with sum types and a case construct where each branchmust be a computation (we later lift this constraint):

M : A
'1(M ) : A + B

M : B
'2(M ) : A + B

M : A + B N1 : T C N2 : T C
case M of '1(x1A) ) N1 | '2(x2B) ) N2 : T C

To record possible observations of sum terms, we introduce sum continuations:

S ::= K ffi h(x1)N1, (x2)N2i
(K ffi h(x1)N1, (x2)N2i) @ M = K @ (case M of '1(x1) ) N1 | '2(x2) ) N2).

We can now define reducibility for sum continuations, and thence for sums.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types

- Sum continuation S : A + B ( T C is in red?A+B if:*

S @ ('1(M )) is strongly normalising for all M 2 redA and*
S @ ('2(N )) is strongly normalising for all N 2 redB.-

Sum term P : A + B is in redA+B if S @ P is strongly normalising for all
S 2 red?A+B.

This is then sufficient to prove strong normalisation for *ml with sums in the manner ofSect. 3.3.

To apply this to a more general case construction, we can move to frame stacks:nested collections of elimination contexts for any type constructor [26]. Frame stacks
generalise continuations, and we have been able to use them to give a leap-frog definitionof reducibility not just for computations, but also for sums, products and function types.

This in turn gives a proof of strong normalisation for *ml with full sums, as well as thesimply-typed lambda-calculus with sums [19, $3.5].

One special case of this brings us full circle: *ml trivially embeds into the simply-typed lambda-calculus with

unary sums.

[M ] 7-! '(M ) let x ( M in N 7-! case M of '(x) ) N
The two languages are essentially the same, except that *ml has tighter typing rulesand admits fewer reductions. Frame stacks and ??-reducibility then provide strong

normalisation for both calculi.

4.2 Reducibility for Exceptions
Benton and Kennedy propose a novel syntax for incorporating exceptions into *ml ,which they use within the SML.NET compiler [9]. They combine exceptions and let

into the single construction try xA ( M in N unless H. This first evaluates M, thenbinds the result to

x and evaluates N ; unless an exception was raised in M , in which caseit evaluates the
handler H instead. The control flow of try-in-unless strictly extendsthe classic try-catch metaphor: for more on this see [9]; and also the rationale [10] for

a similar recent extension of exception handling in the Erlang programming language.Here we take exceptions

E ranging over some fixed (possibly infinite) set; this isnecessary to ensure termination [18]. A handler

H : T B is then a list of pairs (E, P )of exceptions and computations of type
T B: evaluation picks the first pair that matchesthe exception to be handled; unmatched exceptions are re-raised. Typing rules are:

raise(E ) : T A

M : T A N : T B H : T B
try xA ( M in N unless H : T B .

The original let is now a special case of try, with empty handler: let x ( M in N =try

x(M in N unless {}. Notice that we are not fixing our choice of monad T ; it mustsupport exceptions, but it may incorporate other effects too.

For ??-lifting in this calculus, we generalise continuations to cover the newobservable behaviour of exception raising, by associating a handler to every step of
the continuation.

K ::= Id | K ffi h(x)N , Hi
(K ffi h(x)N , Hi) @ M = K @ (try x ( M in N unless H)

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
We now say that continuation K is in red?A if:

- K @ [N ] is strongly normalising for all N 2 redA; and in addition-

K @ (raise(E )) is strongly normalising for all exceptions E.

Building ??-reducibility on this is enough to give strong normalisation for *ml withexceptions, with a proof in the style of Sect. 3.3.

4.3 Reducibility for the Computational Lambda-Calculus
Strong normalisation for *ml immediately gives strong normalisation for the subcalcu-lus

*ml* described in Sect. 2. However, despite the close correspondence between *ml*and

*c, explored in [28], we do not immediately get strong normalisation for *c. Thisis because of two additional reduction rules in

*c:

let.1 P M -! let x ( P in xM if x /2 fv (M )
let.2 V Q -! let y ( Q in V y if y /2 fv (V )

where P, Q range over non-values, and V ranges over values.We can adapt our proof, again using continuations in a leap-frog definition of
reducibility:
Ground value V 2 red0 if V is strongly normalising
Function value V 2 redA!B if, for all M 2 redA [ red??A , V M 2 red??B
Continuation K 2 red?A if, for all V 2 redA, K @ V is strongly normalising
Non-value P 2 red??A if, for all K 2 red?A, K @ P is strongly normalising

The distinction between values and non-values is crucial. There is no explicit compu-tation type constructor in

*c, but non-values are always computations. Thus redA isreducible values of type
A, and red??A is reducible non-values of type A, playing therole of
redT A. This ??-reducibility leads as before to a proof of strong normalisationfor
*c, accounting for both additional reductions.

5 Conclusion
We have presented the leap-frog method of ??-lifting as a technique for raisingoperational predicates from type

A to type T A, based on the observable behaviourof terms. This is independent of the nature of computations

T , and introduces theopportunity of proof by induction on the structure of continuations.

As a concrete example, we demonstrated ??-lifting in a definition of reducibilityfor
*ml , and thence a type-directed proof of strong normalisation. We have also appliedthis to some extensions of

*ml , addressing in particular the robustness of the method intreating systems with commuting conversions.

In this final section we expand on the relation to other work on this topic, andcomment on some possibilities for future research.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
5.1 Related Work
We believe that our use of ??-lifting for computation types in *ml is new. It is,however, inspired by similar constructions applied to specific notions of computation.

Pitts and Stark [25] apply the method to give a structurally inductive characterisation ofobservational equivalence for a functional language with local state. They then use this
to validate certain proof techniques for reasoning about dynamically-allocated referencecells. Direct validation of these techniques had proved fruitless, because even though

the precise form of computational effects was known -- non-termination, state, anddynamic allocation -- the interaction between them was intractable.

In [26], Pitts employs ??-closure to define an operational form of relational parametricity for a polymorphic PCF. Here the computational effect is nontermination, and (-)??leads to an operational analogue of the semantic concept of "admissible" relations.

Abadi in [1] investigates further the connection between ??-closure and admissibility.The notion of ??-closed is different from our lifting: it expresses a property of
a set of terms at a single type, whereas we lift a predicate OE on terms of type A to
OE?? on terms of a different type T A. However, the concept is clearly related, and theclosure operation makes some appearance in the literature on reducibility, in connection

with saturation and saturated sets of terms. Loosely, saturation is the property onewishes candidates for reducibility to satisfy; and this can sometimes be expressed as
??-closure. Examples include Girard's reducibility candidates for linear logic [13,pp. 72-73] and Parigot's work on

*u and classical natural deduction [23, pp. 1469-1471]. For Girard the relevant continuations are the linear duals

A?, while for Parigotthey are applicative contexts, lists of arguments in normal form N

<!. We conjecture

that in their style our ??-lifting could be presented as an insertion { [V ] | V : redA }followed by saturation (although we then lose the notion of reducible continuations).

Melli`es and Vouillon use biorthogonality in their work on ideal models for types; thisis a closure operation based on an orthogonality relation matching our

K ? M [31, 32].They make a case for the importance of orthogonality, highlighting the connection

to reducibility. They also deconstruct contexts into frame stacks for finer analysis:elsewhere, Vouillon notes the correspondence between different forms of continuation
and possible observations [30].
There are evident echoes of continuation-passing style in the leap-frog character of??-lifting; and its independence from the choice of monad recalls Filinski's result

that composable continuations can simulate all definable monads [12]. The apparentconnection here is appealing, but we have not been able to make any formal link.

Goubault-Larrecq et al. investigate logical relations for computation types, propos-ing a distributivity law that these should satisfy [15]. They give a number of examples
of logical relations lifted to specific monads; and, again, their chosen relation for thecontinuations monad has a similar structure to our ??-lifting.

As mentioned in the introduction, existing proofs of strong normalisation for *mlare based on translations into other calculi that are already known to be strongly
normalising. We have said how Benton et al., working from a logical perspective,used a translation into a lambda-calculus with sums [4]. In a report on monadic type
systems -- a generalisation of pure type systems and the computational metalanguage

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types
-- Barthe et al. [3] prove strong normalisation by translation into a lambda-calculuswith an extra reduction

fi0. Finally, Hatcliff and Danvy [16] state that T -reductions arestrongly normalising, although they do not indicate a specific proof method.

5.2 Further Work
Subsequent to the work described here, we have developed a normalisation by evalu-ation algorithm for

*ml , which we prove correct using the strong normalisation result.Normalisation by evaluation (NBE) then leads to further results on the theory of

*ml :namely, that convertibility of terms is decidable, and reduction is confluent. This is described in detail in the first author's PhD thesis [19], which implements NBE for theversion of

*ml used as an intermediate language in the SML.NET compiler [7, 8], andevaluates its performance compared to conventional rewriting.

There is an extensive and growing body of work on the problem of normalisation formany varieties of typed lambda-calculi, with reducibility as just one approach. Joachimski and Matthes have proposed an alternative induction method, that characterises thestrongly normalisable terms in a calculus [17]. This is proof-theoretically simpler, and it
would be interesting to see how this applies to computation types in *ml . Their methodcovers sum types, commuting conversions and, most interestingly for us,

generalizedapplications of the form
s(t, y.r). These have some resemblance to our decompositionof continuations: here
y.r is a term abstraction, to which will be passed the result ofapplying function
s to argument t.
The broader test for ??-lifting is to investigate its application to other predicatesor relations on

*ml terms. Ultimately we want to make precise, and confirm, the
informal conjecture of Kennedy and Benton that (-)?? captures "observation": if OEis some predicate on values, then

OE?? is a "best observable approximation" to it oncomputations [6].

References

[1] M. Abadi. ??-closed relations and admissibility. Math. Struct. Comp. Sci., 10(3):313-320,

2000.
[2] H. P. Barendregt. Lambda calculi with types. In Handbook of Logic in Computer Science,

vol. II, pp. 118-309. OUP, 1992.
[3] G. Barthe, J. Hatcliff, and P. Thiemann. Monadic type systems: Pure type systems for

impure settings. In Proc. HOOTS II, ENTCS 10. Elsevier, 1997.
[4] P. N. Benton, G. Bierman, and V. de Paiva. Computational types from a logical perspective.

J. Funct. Prog., 8(2):177-193, 1998.
[5] P. N. Benton, J. Hughes, and E. Moggi. Monads and effects. In Applied Semantics;

Advanced Lectures, LNCS 2395, pp. 42-122. Springer-Verlag, 2002.
[6] P. N. Benton and A. Kennedy. Personal communication, December 1998.
[7] P. N. Benton, A. Kennedy, and G. Russell. Compiling Standard ML to Java bytecodes. In

Proc. ICFP '98. ACM Press, 1998.
[8] P. N. Benton, A. Kennedy, C. Russo, and G. Russell. The SML.NET compiler. Available

at http://www.cl.cam.ac.uk/Research/TSG/SMLNET/.
[9] P. N. Benton and A. J. Kennedy. Exceptional syntax. J. Funct. Prog., 11(4):395-410, 2001.

Sam Lindley and Ian Stark Reducibility and ??-lifting for Computation Types

[10] R. Carlsson, B. Gustavsson, and P. Nyblom. Erlang's exception handling revisited. In Proc.

ERLANG '04, pp. 16-26. ACM Press, 2004.
[11] P. de Groote. On the strong normalisation of intuitionistic natural deduction with

permutation-conversions. Inf. & Comp., 178(2):441-464, 2002.
[12] A. Filinski. Representing monads. In Conf. Record POPL '94, pp. 446-457. ACM Press,

1994.
[13] J.-Y. Girard. Linear logic. Theor. Comp. Sci., 50(1):1-102, 1987.
[14] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. CUP, 1989.
[15] J. Goubault-Larrecq, S. Lasota, and D. Nowak. Logical relations for monadic types. In

Proc. CSL '02, pp. 553-568, 2002.
[16] J. Hatcliff and O. Danvy. A generic account of continuation-passing styles. In Conf. Record

POPL '94, pp. 458-471. ACM Press, 1994.
[17] F. Joachimski and R. Matthes. Short proofs of normalization. Arch. Math. Log., 42(1):58-

87, 2003.
[18] M. Lillibridge. Unchecked exceptions can be strictly more powerful than call/cc. HigherOrder & Symb. Comp., 12(1):75-104, 1999.
[19] S. Lindley. Normalisation by Evaluation in the Compilation of Typed Functional Programming Languages. PhD thesis, U. Edinburgh, 2005.
[20] E. Moggi. Computational lambda-calculus and monads. In Proc. LICS '89, pp. 14-23.

IEEE Comp. Soc. Press, 1989.
[21] E. Moggi. Notions of computation and monads. Inf. & Comp., 93(1):55-92, 1991.
[22] J. Newburn. All about monads, v1.1.0. http://www.nomaware.com/monads.
[23] M. Parigot. Proofs of strong normalisation for second order classical natural deduction. J.

Symb. Log., 62(4):1461-1479, 1997.
[24] S. Peyton Jones, ed. Haskell 98 Language and Libraries: The Revised Report. CUP, 2003.
[25] A. Pitts and I. Stark. Operational reasoning for functions with local state. In Higher Order

Operational Techniques in Semantics, pp. 227-273. CUP, 1998.
[26] A. M. Pitts. Parametric polymorphism and operational equivalence. Math. Struct. Comp.

Sci., 10:321-359, 2000.
[27] D. Prawitz. Ideas and results in proof theory. In Proc. 2nd Scand. Log. Symp., Stud. Log.

Found. Math. 63, pp. 235-307. North Holland, 1971.
[28] A. Sabry and P. Wadler. A reflection on call-by-value. ACM Trans. Prog. Lang. Syst.,

19(6):916-941, 1997.
[29] W. W. Tait. Intensional interpretations of functionals of finite type I. J. Symb. Log.,

32(2):198-212, 1967.
[30] J. Vouillon. Subtyping union types. In Proc. CSL '04, LNCS 3210, pp. 415-429. SpringerVerlag, 2004.
[31] J. Vouillon and P.-A. Melli`es. Recursive polymorphic types and parametricity in an

operational framework. Submitted for publication, 2004.
[32] J. Vouillon and P.-A. Melli`es. Semantic types: a fresh look at the ideal model for types. In

Conf. Record POPL '04, pp. 52-63. ACM Press, 2004.
[33] P. Wadler. Monads for functional programming. In Advanced Functional Programming,

LNCS 925, pp. 24-52. Springer-Verlag, 1995.