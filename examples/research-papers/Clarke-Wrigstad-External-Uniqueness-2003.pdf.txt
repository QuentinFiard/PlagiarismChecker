

External Uniqueness is Unique Enough

Dave Clarke1 and Tobias Wrigstad2
1 Institute of Information and Computing Sciences
Utrecht University, Utrecht, The Netherlands. dave@cs.uu.nl

2 Deptartment of Computer and Systems Sciences

Stockholm University/KTH, Stockholm, Sweden. tobias@dsv.su.se

Abstract. External uniqueness is a surprising new way to add unique
references to an OOPL. The idea is that an externally unique reference is
the only reference into an aggregate from outside the aggregate. Internal
references which do not escape the boundary of the aggregate are innocuous and therefore permitted. Based on ownership types, our proposal not
only overcomes an abstraction problem from which existing uniqueness
proposals suffer, it also enables many examples which are inherently not
unique, such as a unique reference to a set of links in a doubly-linked
list, without losing the benefits of uniqueness.

1 Introduction
Two essentially different approaches to managing aliasing in object-oriented pro-gramming exist. On one hand sits unique or alias-free references. These are based
on a very simple idea: any variable or field annotated with the keyword uniquecontains the only reference to the object it holds, otherwise it contains

null [29,35, 11, 13, 9, 1]. Apart from helping reason about programs, unique references

safely enable, for example, idioms essential in concurrent programming such asthe transfer of ownership pattern [32], and help enforce software protocols [19].
In all cases, the same notion of uniqueness applies.Unfortunately, all extant uniqueness proposals suffer from an abstraction
problem which we identify in this paper: as software evolves, programs which useuniqueness are forced to change their interfaces when purely internal implementation changes are made. The interface changes propagate through a program.The second approach to managing aliasing employs alias encapsulation, as
exemplified by ownership types [17]. Simply put, these impose a form of object-level privacy by preventing objects (rather than just fields) from being accessed
outside of their enclosing encapsulation boundaries [17, 36, 15, 9, 7, 16, 1, 5]. Own-ership types have been employed for reasoning about programs [16, 36], for alias
management [17, 37], in program understanding [1], to eliminate data-races [9]and deadlocks [7] from concurrent programs, and to enable safe lazy updates in
object-oriented databases [8].Existing attempts to unify uniqueness and ownership typing [9, 1] unfortunately offer little additional benefit from their combination, while perpetuatingthe abstraction problem.

We believe that the key to the abstraction problem is that most systemscannot distinguish between external references and innocuous, internal references
which do not escape encapsulation boundaries. There are essentially two kinds ofownership types, based on the degree of protection provided. The stronger form,
namely those with deep ownership [17, 16], provide the machinery necessary tomake this distinction. These form the basis for our proposal.

In this paper, we introduce a different kind of uniqueness called externaluniqueness. External uniqueness loosens the conventional uniqueness constraint,
requiring that there be only one reference to an aggregate from outside of theaggregate, without limiting the number of references to the aggregate from its
inside. Interestingly, it turns out that the externally unique reference is the onlyactive reference to an object, so it is effectively unique.

Our proposal not only overcomes the abstraction problem, it also enables anumber of interesting examples which result from the synergy between uniqueness and deep ownership: we enable, for example, the transfer of entire aggregatesbetween objects, or even the combination of the encapsulated representation of
data structures such as doubly-linked lists, even in the presence of aliasing withinsuch aggregates, without leaving any unwanted aliases which would break encapsulation. Above all, we do so for a class-based object-oriented programminglanguage with subtyping.

Outline Our paper is organised as follows. In Section 2 we describe the abstrac-tion problem with uniqueness, and point to a way around it. As ownership types
are the key to a solution, we review them in Section 3. We then describe externaluniqueness in Section 4, before illustrating its power through example in Section 5. Section 6 covers the essence of our formalisation. We discuss our proposalin Section 7 and related work in Section 8, before concluding in Section 9.

2 Challenging Uniqueness
Existing approaches to uniqueness in object-oriented programming are broken.We now outline how the two different approaches both suffer from the same
abstraction problem, before indicating a way out of the mess.

2.1 An Abstraction Problem
To add unique references to an OOPL, one must consider how a class treats itsinstances internally via

this (or self). Approaches in the literature reflect thetreatment of
this in a class' interface in one of two ways:

via class annotation classes are divided into two kinds, those which may as-sign

this internally, and those which do not. Only instances of the lattermay be referenced uniquely [35].

via method annotation methods are annotated to indicate that they mayconsume

this [29, 11]. Calling such a method requires (at least conceptually)that its target be destructively read.

Proposals combining ownership types and uniqueness follow suit: Boyapati andRinard [9] adopt the first approach, whereas Aldrich, Kostadinov and Chambers
[1] adopt the latter. In both cases, a problem surfaces when the implementationof a class changes the way it uses

this. For concreteness, assume that we havethe following class with a single method:

class BlackBox {

void xyzzy() { .. }
}

and a variable (or field):

unique BlackBox bb;

When we change the implementation of the BlackBox class so that the xyzzymethod assigns

this internally, we are forced, under existing proposals, to change
BlackBox's interface.

Using class annotations we would have to modify BlackBox to indicate thatits instances cannot be referred to uniquely:

class neverunique BlackBox. Asa result, variable declarations such as the one above would no longer be valid, and

would have their uniqueness stripped. It may also be the case that all destructivereads of

BlackBox objects throughout the entire program would have to bechanged to ordinary reads, perhaps with destructive read implemented manually.

When using method annotations, we would have to modify the xyzzy methodto indicate that it consumes

this, such as void xyzzy() consumes { .. }. Thecall
bb.xyzzy() may create an internal reference to its target, requiring thatthe target

bb be consumed to preserve uniqueness. The consequence here iseven more drastic, as the semantics of method call changes: calls to this method

suddenly consume their target, whereas in the original program they did not.

In both cases, a purely internal change to the implementation of BlackBoxforces changes to its interface, which propagate through the program -- either

statically or dynamically. Not only does this introduce the opportunity for errors,since the behaviour of a program changes, it means that objects cannot be
treated like black boxes. Thus extant uniqueness proposals break abstraction.

2.2 Distinguishing internal and external references
The abstraction problem occurs, we believe, because the distinction cannot read-ily be made between internal and external references. For example, traditional
object-oriented programming languages cannot distinguish the references be-tween the links of a linked list, which are internal to the data structure, from
references that go into a data structure from outside of it, such as the referencefrom the handle object to the first link.

A purely internal reference to an object which has only one external referencecannot be used by objects other than the holder of the external reference. This
means that no changes to the object can be made via the internal referenceviolating the "uniqueness" of the external reference, since the internal reference
is only accessible once already inside the object. Thus, purely internal referencesare innocuous. Their existence should not affect how an aggregate is viewed
externally; they ought to be preserved to maintain the internal consistency of

an aggregate. Otherwise, knowledge of internal reference behaviour exposes anobject's implementation details and thus violates abstraction, as we have shown.

Fortunately, the desired distinction can be made in a programming languagewith ownership types, as originally proposed by Clarke, Potter and Noble [17].
This form of ownership types provide strong protection against external aliasingof an object's internals, enabling a strong notion of aggregate object. Technically,
each object has an owner through which all external access paths into the objectmust pass, meaning that owners are dominators in the object graph (take a
peek at Figure 1). The resulting anti-aliasing guarantees are compatible withthe containment implicit in object-oriented programming.

Based on the machinery of ownership types, we propose a new take on unique-ness called external uniqueness. External uniqueness restricts the external references to an object to be at most one, while permitting arbitrary internal aliasing.Consequently, external uniqueness refines the object graph property underlying
ownership types from dominating nodes to dominating edges (see again Fig-ure 1). Using external uniqueness, we treat

this non-uniquely and allow it tobe arbitrarily assigned internally. Methods cannot steal

this, and hence neednot be annotated, keeping the syntactic overhead down and avoiding clutter

in interfaces. Furthermore, under very mild conditions, we need not annotateclasses,

1 since instances from every class can be referred to uniquely. Thus external uniqueness can solve the abstraction problem.Since ownership types are crucial to our proposal, we shall now review what

they do and how they do it.

3 How Ownership Types Work
Ownership types package together into a class-based type system a number ofconditions which together act locally to restrict the global structure of object
graphs. The underlying idea is very simple.Objects have owners and can be the owners of other objects. Ownership
forms a tree, where an object is inside the object which owns it. Also, an objectis inside itself. An additional owner called

world forms the root of the tree, henceall objects are inside
world. Finally, there is a condition which governs whetherone object can refer to another (

u"", u""0 are object ids, ) is logical implication):

u"" refers to u""0 ) u"" inside owner(u""0)
This says that object u"" can only access an object u""0 whose owner is outside ofitself, or alternatively, an object cannot be accessed from outside of its owner.
The owner can be seen as the permission required to access an object, andan object's position in the inside relation determines whether the object has
enough permission. A nice little theorem [38, 15] states that if we have all ofthese conditions, then an object's owner will be on all paths from the root of

1 Assigning this to a static variable prohibits unique references to the objects of its

class. This behaviour is rare, so we will not even consider it here.

OwnershipInvalid refUnique refRef and Object
u
f

Root

r
e

f'i
s

Root
e'

r f'
f

u

i

s

Root

Uniqueness Ownership External Uniqueness
Reference kinds: u - (externally) unique. f, f0 - invalid (f breaks uniqueness, f0 breaks deep ownership). s - sibling. e, e0 - external to grey object. i - internal. r - representation.

Fig. 1. Comparing uniqueness, deep ownership and external uniqueness

the graph to that object, which is to say that an object's owner is its dominator.We call this property owners-as-dominators, and type systems which enjoy it
are said to offer deep ownership.Deep ownership is illustrated in the centre picture in Figure 1. If one considers
the objects an object owns to be nested inside it, as depicted by the roundedbox, then deep ownership can be stated as: no reference can pass through an
object's boundary from outside to the inside.The tricky part is realising these ideas in a class-based OOPL. Firstly, owners
become a syntactic category and are indicated in an object's type. Types takethe form

p0 :chpi21..ni, where c is a class name, p0 is the owner of objects of thattype, and each

pi21..n is a binding for the parameters of the class. Constraints onowners are recorded in the type system using both inside (A'*) and its converse

outside (A^*). These constraints are specified in class headers (and elsewhere)and must be satisfied when forming types. In code examples, we write write
inside for A'* and outside for A^*.Outside of a class there is only one owner, the global

world. Within the bodyof a class,
this is used to denote objects owned by the current instance. Theseobjects are directly inside the current instance -- objects inside these objects are

also inside, but inaccessible. A class implicitly takes a parameter for the ownerof its instances, denoted

owner within the class body -- objects with this ownerare called siblings. In addition, the class may have parameters, such as

a and bin the following:

class c<a, b outside a> {

// valid owners: this, owner, world, a, b
// relationship: this inside owner inside a inside b inside world
}

c 2 ClassName, f 2 FieldName, m 2 MethodName, x, y 2 TermVar,

o"" 2 OwnerVar.

P 2 Program ::= classi21..n s e
class 2 Class ::= class cho""i Ri pi21..mi extends c0hp0i021..ni { fdj21..r methk21..s }

where R is either inside or outside (A'* or A^*).
fd 2 Field ::= t f = e;
meth 2 Method ::= ho""i Ri pi21..mi t m(ti xi21..n) { s return e }

lval 2 Lvalue ::= x | e.f

e 2 Expr ::= this | lval | lval-- | new t | null | e.mhpj21..mi(ei21..n)
s 2 Stat ::= skip; | t x = e; | e; | lval = e; | s s | if (e) { s1 } else { s2 }|

(o"") { s } | { s } | borrow lval as ho""i x { s }
p, q 2 Owner ::= this | o"" | world | owner | unique|

uniquep (in elaborated language only)
t 2 Type ::= p:chpi21..ni

Table 1. Syntax of Joline

External objects have owner, world or some parameter as owner. In additionto these owners, additional owner variables may be introduced via owner polymorphic methods, scoped regions, or borrowing. Whether these are internal orotherwise is determined from their relationship (if any) with

this.
That takes care of owners, now for the nesting between them. Firstly, ev-ery owner is inside

world. Within a class body we have this A'* owner, and
owner A'* o"" for each of the class' parameters o"". Since the ordering of ownersis required when forming types, we also can specify the ordering, such as the

constraint b A^* a above, in the class header. (The default constraint is outside
owner.)

The final constraint required is that the owner part of a type be preservedthrough subtyping, as this acts as the permission governing access to the object.

More detailed descriptions of ownership types are available in the literature[15, 16]. From now on, when we refer to ownership types, we assume a deep model
of ownership, and we use "unique" to indicate external uniqueness, adding theappropriate qualifiers either where required or for emphasis.

4 A Tour of External Uniqueness
We now present our proposal for external uniqueness. It is a minor extensionto ownership types with major consequences. For concreteness, we work in the
context of a core programming language called Joline, much of which ought to befamiliar (see Table 1). We first describe external uniqueness, then the operations
required to support it, and address a few technicalities required to maintainsoundness of the system, before diving into examples in the next section.

4.1 External Uniqueness in a Nutshell
A reference to an object is externally unique if it is the only reference from out-side an object to it. Aliasing from inside the object is still permitted, because

such references form a part of the aggregate objects' implementation. Externaluniqueness takes uniqueness, but only applies it externally, using the distinction between the inside and outside of an object offered by ownership types.Figure 1 illustrates the distinction between uniqueness, deep ownership, and external uniqueness. The graph-theoretic property that external uniqueness enjoysis a refinement of the owners-as-dominators property. An externally unique reference corresponds to a dominating edge to its target, which is an edge thatmust occur on all paths from the root of an object graph to the target. This
can be seen in the third picture in Figure 1: the dotted edge u denotes an ex-ternally unique reference. Notice that internal references to the grey object are
still permitted. The dominating edge property implies that if the dominatingedge

u is removed, then all internal objects (within the rounded box) becomeinaccessible from the rest of the system. Contrast this with ownership typing in

the centre picture, where the removal of the grey dominator object would resultin its internal objects becoming inaccessible.

The formal property of external uniqueness is:

u"" refers uniquely to u""0 ^ u""o refers to u""0 ) u""o inside owner(u""0)
This property states that all non-unique references to an object referred to viaa unique reference are from objects internal to the object. Combined with the

fact that there can be only one unique reference and the original owners-as-dominators property, we get that unique references are dominating edges.

Externally unique references are denoted using types such as unique : chpi21..ni.The unique annotation can only appear in the owner position, and thus no

pi21..nmay be "
unique." (For technical reasons, we have types like uniquep : chpi21..ni-- see Section 4.3.) As ownership types maintain the dominators property, to

obtain external uniqueness we need only add machinery to ensure the uniquenessof references of type

unique : chpi21..ni whenever viewed externally.

4.2 Operations on External Uniques
Unique values, fields and variables are affected in two ways: movement andborrowing. Movement is simpler, so we discuss it first.

Movement Movement allows an externally unique reference to be moved fromone field or variable into another, possibly losing its uniqueness along the way.
Movement is the only operation which can be directly performed on a uniquefield or variable. To preserve uniqueness the original value must no longer be
accessible through its source after the movement. Either the source must benullified, the approach we take, or a technique such as alias burying, which
statically ensures that all aliases to an object are dead when a unique variableor field is read [11], must be applied.

r
u

i

s

Root

\Gamma \Delta \Gamma \Delta \Gamma \Gamma \Delta \Gamma \Delta \Gamma 
\Gamma \Delta \Gamma \Delta \Gamma 
\Theta \Delta \Theta \Delta \Theta \Theta \Delta \Theta \Delta \Theta 
\Theta \Delta \Theta \Delta \Theta  r

bStack

f

Root

s
ib'Heap

External Uniqueness Borrowing
Fig. 2. Mediating between external uniqueness and borrowing -- b is the original borrowed reference. b, b0 are only valid during the borrowing. (Stack grows downwards)

Moving is really a compound operation which combines a means for obtaininga unique value with a means for consuming it. A unique value, as opposed to a
unique field or variable, can be obtained through object creation, the destructiveread of a unique field or variable (lval

--), or as the result of a method call. Tosimplify the formal account of the language, destructive reads are made explicit.

Thus a programmer writes x = y-- or return x--, for example, instead of x =
y or return x, respectively. Ultimately, a unique value is consumed by assigningit to a field or variable, or by passing it as an argument to a method.

The presence of internal references causes no problems when moving, becausethe dominating edge property guarantees that these are all (effectively) moved
also. When consuming a unique value, however, we must ensure that deep owner-ship be maintained. The appropriate constraints on movement are incorporated
into the subtype relation.
Borrowing Performing an operation other than the moving of a unique reference,such as accessing a field or calling a method, requires that it first be borrowed.
The borrowing construct creates a non-unique reference, x, to the borrowedentity, lval, for a limited lexical scope,

s:

borrow lval as ho""i x { s }
For example, we could call the add method of the object in variable unique:B
bus as follows: borrow bus as <bo> b { b.add(...); }.

To make this a little more concrete, consider the phases of borrowing de-picted in Figure 2. The left-hand picture indicates the state of play before the

borrowing occurs. Initially, all access paths from the root to the grey object andits inside contain the unique reference

u, which is inactive, and thus the objectsare also inactive. During the borrowing, right-hand picture, the original reference

is placed in variable x which can be treated non-uniquely. The type of x is not

unique, having owner o"", which must always be a "fresh owner", for the durationof the borrowing, and we can access its fields and methods, pass it to methods,
or even store it in subsequent stack frames or on locally created heaps. Since o"" isonly available in the scope of the borrowing, no references with types containing
o"" are active at then end of the borrowing. Only internal aliases remain, and thesituation returns to the original inactive state.

To some degree, borrowing exists primarily to facilitate type checking, byproviding a construct to mediate between uniqueness and non-uniqueness. Ownership typing ensures that no reference escapes from the borrowing construct viasome back door. We must now consider how to maintain external uniqueness,
since one could simply walk in the front door and move the reference containedin lval (indicated as

u in Figure 2). There are essentially three approaches:

do nothing rather than invalidate the original lval, we could simply weakenthe definition of uniqueness, permitting both the reference in the lval and

the borrowed references, and even allowing movement of the lval underfoot.We dismiss this case for now.
destructive we could nullify the lval during borrowing, and then:

- simply restore the original contents of lval when the borrowing ceases;
- restore the final contents of the borrowing variable x at the end of theborrowing. Restoring the initial value is consistent with conventional

uniqueness, whereas enabling a different reference into the same aggre-gate to be reinstated is consistent with external uniqueness; or
- rather than simply nullify lval, we could record the state of its contents.The three possible states are: available, null, and borrowed, indicating

that lval contains something, nothing, or is disabled due to some bor-rowing. In the presence of multiple threads, more states could be added
to indicate whether a different thread is borrowing the reference.
alias burying the last possibility is to employ alias burying, as mentionedabove. This would ensure that when lval is read that all aliases are unusable

[11]. Alias burying eliminates the need for destructive reads, but unfortu-nately comes at cost. As it is based on program analysis, its strength is
sensitive to the underlying analysis. To achieve modular checking, classesmust be further annotated to indicate which unique fields are read [12]. This
may well reintroduce the abstraction problem. Furthermore, we do not knowwhether alias burying works in a multi-threaded setting.

In the last two cases, there is no active reference to the target object extractedfrom lval. Thus, the combination of a borrowing mechanism and ownership types
ensures that an externally unique reference is the only active reference to itstarget. We proceed with the second variation of the destructive approach, preventing a reference such as f in Figure 2. This keeps our formal system simple,while retaining a strong definition of uniqueness.

A drawback of destructive reads is that it precludes simultaneous non-conflict-ing operations on unique references, e.g., allowing read-only methods on unique
references even during a borrowing (not necessarily a good thing).

4.3 Movement bounds
Moving an object to a new location could result in residual aliasing of the in-ternals of its original location, thus violating the invariants of deep ownership
and external uniqueness. To avoid this problem, all occurrences of unique havean associated movement bound and appear in the formal system as

uniquep.The movement bounds bound the outwards movement of unique references --

a unique reference may only be moved to variables inside its movement bound.Choosing

p requires a trade-off: an outer p enables more movement, but limitswhat the object can access (i.e., what ownership parameters can appear in its

type); whereas an inner p would enable less movement, but permits more access.A unique reference with movement bound

world can be moved anywhere inthe system. (See our workshop version of this paper for an example elaboration

function which provides movement bounds automatically [18].)

4.4 Do constructors return externally unique references?
Clearly, the act of creation results in a unique object, so we must consider whatcould go wrong in a method call, which is effectively what a constructor call
is. Here external uniqueness would be violated if the method assigns this to apreexisting external object. This object would have to have

owner as its ownerand be accessible from an object passed to the method. But, if the

owner wasmerely acting as the movement bound, then there would be no problem, because

such an argument to the constructor would be unique and could be consumedby the constructor into the new object. Thus the fix is simple: the parameters
of a constructor cannot have owner in their type, except as a movement bound.This is a minor restriction.

For simplicity, we omit constructors from our language description.

5 External Uniqueness at Work and Play
We now illustrate external uniqueness with a number of examples, highlightingaspects which would be impossible under existing uniqueness proposals.

External uniqueness In Figure 3 a server manages a number of clients. Theclients are part of the representation of whatever object owns the server. Each
client stores a back pointer to its server, e.g., to access other clients via the
clients array or to compare the server's object id with the source of someevent. In ordinary models of uniqueness, this reference would either make it

impossible have a unique reference to the server, or it would consume the serverthe first time it was passed to a client. With external uniqueness, this reference
is permitted -- the internal use of this in the server class does not effect itsinterface or how the server may be used or referenced externally.

class Server {

this:Client<owner>[10] clients; // internal array of clients
void accept(int num) {

clients[num].setServer(this);
}
}
class Client<serverowner outside owner> {

serverowner:Server server; // server is external
void setServer(serverowner:Server server) {

this.server = server;
}
}

Fig. 3. External uniqueness

The initialisation problem ([20]) To keep objects such as the following lexer flex-ible, we must be able to initialise its internal stream with an externally created
object, without leaving any external aliasing to the stream object. Proposedsolutions suffer from the weaknesses of shallow ownership [1, 9] (see Section 8).

class Lexer {

this:InputStream stream; // internal
Lexer(unique:InputStream s) { stream = s--; }
}
void lexerClient() {

unique:InputStream stream = new FileInputStream(file);
unique:Lexer l = new Lexer(stream--);
}

Simulating borrowing Previous approaches to uniqueness use lent parameters toavoid the capture of unique references passed to methods. We can simulate this
using borrowing and a call to an owner polymorphic method. Apart from makingthem applicable to objects with different owners, owner polymorphic methods
cannot capture any argument whose owner is a parameter:

class Printer {

static <o inside world> void print(o:Printable p) { .. }
}
unique:B b; // B implements Printable
borrow b as <a> b' { Printer.print<a>(b'); }

Another benefit of this scheme is that the borrowed object may be stored tem-porarily on the heap during the borrowing. This is discussed shortly.

Transfer of ownership Transfer of ownership is an important design pattern inconcurrent object-oriented programming [32]. In the following token ring, the
token object is passed from one thread to the next by calling the give method.For example, Figure 4 illustrates the move of

Token B from TokenRing element
A to C. This idiom relies on the movement bound of B being the owner of

the surrounding object A, that is D, to ensure that B has no references to theobjects inside

A. That is, the token ring elements must be siblings.

class TokenRing {

owner:TokenRing next; // sibling
unique:Token token;
void give() { next.receive(token--); }
void receive(unique:Token tkn)

{ token = tkn--; }
}

B

D

CA
B

Fig. 4. A Token Ring. Transfer token B from A to its sibling C

External uniqueness allows the token object to be a fully-fledged aggregatewhich may be the resource shared between the elements in the token ring. Of
course, there is no reason why this couldn't be a movement from one machineto another.

Merging representations External uniqueness enables the protected, self-refer-ential internals of two data structures to be merged, without copying, into a
new data structure, which offers the same degree of protection, without anyresidual aliasing from the original data structures. For example, Figure 5 shows
the merging of one doubly-linked list into another. The phases of operationare:

(1) borrow the local interior, head, using temporary owner ho; (2) movethe other interior,

other.head, so that it has owner ho; perform the merge (anappend in this case); and then reinstate with the resulting value of

bh, which mayhave been set in line
(*). Note that other.head is consumed in this operation.David Holmes posed this example as a challenge when he saw the original

ownership types proposal [17]. No existing combination of uniqueness and own-ership types can handle it, but we finally do so in an elegant manner.

Moving parts In the previous example, there is a single unique reference intothe internal links of the doubly-linked list from the

List object. It is simple tomodify this example to account for multiple references into a data structure. For

concreteness, we consider a doubly-linked list with a tail pointer. The key is tointroduce a proxy object to hold both references into the list, and have a unique
reference to this object.

class HeadAndTail<data> { class List<data> {

owner:Link<data> head, tail; unique:HeadAndTail<data> handle;
} }

Local objects and orthogonality Joline also has a construct which enables thecreation of temporary heap objects which may refer to existing objects, including borrowed unique references. The statement (o"") { s } creates a new ownerwhich is implicitly nested inside some existing collection of owners, giving access

class Link<data> {

data:Object data;
owner:Link<data> next, prev;
}
class List<data> {

unique:Link<data> head;
void append(owner:List<data> other) {

borrow head as <ho> bh { (1)

ho:Link<data> ohead = other.head--; (2)
if (bh == null) { bh = ohead; } (*)
else if (ohead != null) {

ho:Link<data> h = bh;
while (h.next != null) { h = h.next; }
h.next = ohead; h.next.prev = h;
}
}
}
}

Fig. 5. Merging two doubly-linked lists. ho is the temporary owner of the list head
while borrowed. head.

to existing objects. Through the invariants of ownership types, the lifetime ofobjects of types containing

o"" is limited to the scope of s. Objects created withinthe block can be used normally, even passed to owner polymorphic methods, but

are discarded at the end of the block.For example, the

print method in an earlier example could have the bodywhich follows. Here the

LayoutManager object, which has owner a, can accessthe external
Printable object, but cannot persist when the scope exits.

static void print<o inside world>(o:Printable p) {

(a) { // temporary owner

a:LayoutManager<o> lm = new a:LayoutManager<o>(p);
lm.addBorder();
lm.print("/dev/printer");
}
}

This feature is impossible without deep ownership, unless one uses an effectssystem. Scoped regions resemble an abstract, statically safe, type-level version
of ScopedMemories from Real-time Java [6], which requires no dynamic checks.

6 A Touch of Formality
In this section, we present the static semantics for Joline, focusing on the mostimportant rules. The remainder are relatively standard and straightforward and
can be found in Appendix A. Type checking is defined for programs which havemovement bounds in place (see further [18]). As a notational shortcut, we present

rules with multiple conclusions, denoting one copy of the rule for each conclusion.The type environment

E records the nesting relation on owner parameters, andthe types of free term variables:

E ::= ; | E, x :: t | E, o"" A'* G{pi21..n} | E, o"" A^* p
(o"" A'* F{pi21..n} means o"" is inside all p 2 {pi21..n}). The test unique(t) is trueif and only if the type

t is unique, that is, that its owner is uniquep. Fc and Mcare maps for each class

c from the field names or method names in that class(or superclass) to their declared types, modulo the substitution of superclass

parameters. The function owners() when applied to an environment gives all theowner parameters defined in that environment, including the global

world, andwhen applied to a type gives all the owner arguments in the type. Substitutions of

owners for owner parameters are denoted ?. The act of substituting is denoted
?(* * *). The notation ?p represents the substitution ? [ {owner 7! p}. A typemay be written either as

p : chpi21..ni or p : ch?i, where ? = {o""i 7! pi21..n} forappropriate
o""i21..n, i.e., the names of the owner parameters declared in the class.

Types

(type)
class cho""i Ri pi21..ni * * * 2 P
? = {owner 7! q, o""i 7! qi21..n} E ` ?(o""i Ri pi)i21..n

E ` q :chqi21..ni
E ` uniqueq :chqi21..ni

A type is well-formed whenever the substituted owner arguments satisfy theordering on parameters prescribed in the class. The type can be either unique
or not. In the case of unique types, the movement bound must satisfy the sameconstraint which it would satisfy as the actual owner.

Subtyping
(sub-lose-unique)

E ` p :ch?i
E ` uniquep :ch?i <= p :ch?i

(sub-class)
E ` p:ch?pi class ch. . .i extends c0hp0i21..ni * * * 2 P

E ` p :ch?i <= p :c0h?p(p0i21..n)i
E ` uniquep :ch?i <= uniquep :c0h?p(p0i21..n)i

(sub-move)
E ` p0 A'* p E ` p:chpi21..ni
E ` uniquep :chpi21..ni <= uniquep0 :chpi21..ni

Subtyping is derived from subclassing, modulo the binding of superclass pa-rameters. As this corresponds to the composition of two order-preserving functions, it is order-preserving, required to preserve deep ownership [15]. In partic-ular, subtyping preserves the owner. Letting the owner vary, as in Cyclone [27],
would be unsound in our system [16]. Finally, subtyping may preserve unique-ness or forget it, in which case the movement bound becomes the regular owner

of the object. The movement bound may also move inwards, to get a strongermovement restriction.

Statements
(stat-update)
E ` lval :: t ref E ` e :: t

E ` lval = e; ; E

(stat-scoped-region)
E, o"" A'* F P ` s ; E0 P t, owners(E)

E ` (o"") { s } ; E

(stat-borrow)
E ` lval :: uniquep :chpi21..ni ref E, o"" A'* p, x :: o"":chpi21..ni ` s ; E0

E ` borrow lval as ho""i x { s } ; E

The rule (stat-update) simply enforces that updates can be performed tol-values only if the types match, modulo subtyping. The rule

(stat-scopedregion) introduces a new owner variable for the duration of the given block.The bounds

P , though unspecified in code, determine which objects may beaccessed by objects created in this scope. From the rule

(stat-borrow) anyuniquely typed l-value may be borrowed. This is achieved by introducing a new

owner variable which is restricted in scope to act as the owner of the temporarynon-unique reference to the borrowed value. To ensure that this reference, or
other references into the borrowed value do not escape this scope, we requirethat this owner is inside the unique type's movement bound. The remainder
of the type must correspond exactly to the type of the l-value, so that it isreinstated with a correctly typed value when the borrowing ends.

l-values

(lval-var)
x :: t 2 E x 6= this

E ` x :: t ref

(lval-field)
E ` e :: p:ch?i Fc(f) = t
this 2 owners(t) ) e t^ this

E ` e.f :: ?p(t) ref

These rules give the types of l-values, which are variables (other than this)and fields. Their type is given exactly as declared, modulo substitution of parameters. l-values may be updated or destructively read. The condition this 2
owners(t) ) e t^ this, which was called the static visibility in the original own-ership types system [17], ensures that types contain

this in them can only beaccessed internally to the object. It amounts to saying that fields (and methods)

which return or require the object in internals are private. This is not essential;we could have used dynamic aliasing [16], but the type system would have been
a little too complex to present our ideas. Subsumption does not apply to l-valuetypes to ensure the validity of reinstatement at the end of borrowing.

Expressions

(expr-lval)
E ` lval :: t ref ~unique(t)

E ` lval :: t

(expr-dread)
E ` lval :: t ref

E ` lval-- :: t

(expr-call)
E ` e :: p:ch?i Mc(m) = 8(o""i Ri pi21..n)tj21..m ! t0
this 2 owners(8(o""i Ri pi21..n)tj21..m ! t0) ) e t^ this
?0 = {o""i 7! qi21..n} E ` ?0(?p(o""i Ri pi21..n)) E ` ej :: ?0(?p(tj)) for all j 2 1..m

E ` e.mhqi21..ni(ej21..m) :: ?0(?p(t0))

Not all l-values can be directly treated as values. The rules (expr-lval)and

(expr-dread) correspond to extracting the value within the l-value. If thetype is non-unique, then the (contents of) l-value can automatically be used as a

value. If the type is unique, then a destructive read must be used to convert itscontents into an expression. Destructive reads can apply to non-unique l-values.

The rule for method call is a behemoth. Firstly, it applies only to non-uniquetypes (as does the rule for field access). The second line is the static visibility
test which restricts expressions containing this in their type (as declared inthe class) to being used only internally, that is, on

this. The owner argumentsof the target type and the owner arguments supplied to the method form two

substitutions to transform the method's argument and return types into typesterms of the owners in scope. The value supplied to each argument of the method
must have the type expected by the method. The method may return a uniquelytyped value.

Note that there are no rules for accessing the fields and methods of uniquereferences. To do so a borrowing must first be issued.
As usual, subsumption does apply to expression typing.

7 Discussion
We believe that our model of uniqueness is more appropriate and more stablethan existing approaches in that it overcomes their limitations.

The abstraction problem Ownership types distinguish internal and external ref-erences. With them, we can permit arbitrary internal aliasing within a uniquely
referenced aggregate, without the loss of effective uniqueness. From a softwareengineering perspective, our proposal is better suited to software evolution than
traditional uniqueness, since it does not require interfaces to change when theinternal implementation does, as illustrated by the Client-Server example in Figure 3. In addition, we need not clutter interfaces with annotations on methodsor constructors indicating calls that destructively consume their targets, as in
other proposals, because methods cannot be called on a unique reference andtheir targets cannot be consumed. The price is the loss of uniqueness on

this,precluding moves initiated within an object. The gains are much greater.

Orthogonality Borrowing was introduced in existing uniqueness proposals sothat unique references can be operated upon without consuming their targets.
Existing uniqueness proposals impose the restriction that a borrowed referencecannot be stored in the field of an object, making borrowed references a kind
of second class citizen. These proposals lack mechanisms in their type systems

to treat borrowed references as usual non-unique references and maintain theinvariant that after the borrowing has ceased, the reference is again unique.

Rather than introducing borrowed references as another kind of reference,our borrowing is a construct which mediates between unique and non-unique
perspectives. Any non-unique reference, including those introduced in a bor-rowing and those internal to an object, can be passed to owner polymorphic
methods, or stored on the heap in objects created within scoped regions. Own-ership types guarantees that any aliases created are temporary or appropriately
contained. The result is a cleaner language which employs orthogonal constructsin a flexible manner.

A unique is a unique is a unique A potential problem when dealing with uniquereferences in the presence of borrowing is that reading a field or variable containing a uniquely typed reference while aliases exist violates the uniquenessexpectation of those accessing the field. As we mentioned in Section 4, there are
a number of ways for dealing with this. Recapping, we could weaken the defi-nition of unique and not nullify a variable when borrowing, or we could nullify
when borrowing thus introducing null pointers and potential race conditions,or we could employ alias burying and accept a sophisticated program analysis
which does not work in a multi-threaded setting. In the last two solutions, ex-ternal uniqueness becomes effectively unique. That is, while not strictly unique,
the dominating edge property means that there is only ever one active referenceto an externally unique object, since internal references only become active during a borrowing when the original reference is unavailable. Thus there is eithera single active unique reference to an object, or many references with limited
scope, but never both.

Reentrancy and internal threads An interesting consequence of our proposalregarding the reentrancy of objects is that, once a reference has been borrowed,
an object can only be reentered from references inside the original object. It isnot possible to call a method from an external object which then results in a
call to the original object. We expect that this localised reentrancy will be handywhen reasoning about objects.

An important conclusion for concurrency is that an object referred to uniquelycan only be entered by one thread. However, if threads are created within an
object while it is being borrowed, then their mere existence threatens the pos-sibility of retaining a strong notion of uniqueness. We feel that this should be
avoided -- a better approach is to pass the unique references between threads.

Uniqueness, non-null and finality The stronger form of uniqueness interactsbadly if we wish to have final fields containing unique values or non-null unique
types [22]. The problems encountered are similar, though independent. Whena final field contains a unique reference, a destructive borrowing violates the
finality of the field and similarly, the non-nullity of a non-null type. We suspectthat alias burying again will come to the rescue in the sequential setting, but

beyond that we cannot yet have non-null or final unique references. Yet anotherapproach is to weaken external uniqueness for final fields.
Uniqueness and shallow ownership Dominating edges are possible only whendominators can be enforced. But this is impossible in systems lacking deep ownership, such as AliasJava [1] and some in the first author's thesis [15], and hencethey cannot support external uniqueness. Adding ordinary uniqueness in such
cases is easy, since the invariants underlying deep ownership need not be consid-ered. (This originally caused us to baulk when contemplating uniqueness.)

Weakness and limitations Apart from the difficulty maintaining the uniquenessinvariant in a sensible and cheap manner, external uniqueness also inherits the
weaknesses of deep ownership. In brief, one must program with the single entrypoint to aggregate objects requirement. Consequently a choice must be made
between the amount encapsulation desired and the flexibility gained. The diffi-culties arise when trying to implement patterns such as iterators or command
objects which require multiple, sometimes temporary, access paths into the in-ternals of an object, or observers which require multiple permanent references
[23]. Shallow ownership overcomes these weaknesses [1], though some attemptshave been made to overcome some them while maintaining deep ownership [16].

8 Related Work
Table 2 presents a comparison between different proposals in the literature withregard to the kinds of uniqueness, alias encapsulation, and borrowing they provide. For reasons of space, we restrict our discussion mainly to object-orientedprogramming languages. For a few pointers into less closely related literature,
see e.g., [11, 13], or for a recent discussion on aliasing in general, see [16].

Uniqueness Encapsulation Borrowing
This paper External Deep Orthogonal
PRFJ [9] a Conventional Deep Parameter
Flexible Alias Protection [37] Free Deep -
Vault [19, 21] b z.Conventional Shallow Orthogonal
AliasJava [1] Conventional Shallow Parameter
Pivot Uniqueness [33] c <Conventional Shallow Parameter
Capabilities for sharing [13] d z.Conventional z.Shallow z.Parameter
Islands [29] e Conventional Full z.Parameter
Balloons [2] Conventional Full Parameter
OOFX/Alias Burying [11, 26] Conventional None Parameter
Eiffel* [35] Conventional None Parameter
Virginity [34] Free None Parameter

Table 2. Comparison. Legend: - not applicable; a-e see text

We consider three kinds of uniqueness:

free values can be unique (e.g., from object construction).
conventional uniqueness fields and variables may contain unique referencesto an object. Such a reference is the only one stored in the heap, and possibly

the stack, modulo any borrowing.
external uniqueness fields and variables may contain externally unique refer-ence into an aggregate. Internal references to unique object are permitted.

Both forms of uniqueness subsume free. Freedom without uniqueness means thatthe freeness is lost as soon as the value is stored in a field or variable. Commonly
used synonyms for uniqueness include linear and unshareable.We consider three kinds of ownership/encapsulation:

shallow direct access to certain objects is limited.
deep the only access (transitively) to the internal state of an object is througha single-entry point. References to external state is possible.

full same as deep ownership, except that no references to objects outside theencapsulating object from within the encapsulating boundary are permitted.

While shallow ownership prevents direct access to the encapsulated objects,proxy objects may be created (internally or externally) which access the encapsulated objects and may escape the encapsulation boundary. Deep ownershipgoes further by lifting the nesting of objects into the type system and ensuring
that no references to deeply nested objects pass through their enclosing bound-ary. This is also called flexible alias encapsulation [37]. Full alias encapsulation
[37] is like deep ownership except that references to external objects are notpermitted from within the encapsulation boundaries. In graph theoretic terms,
deep ownership imposes that owners are dominators which break path connec-tivity when removed, whereas full alias encapsulation imposes that "owners"
are cut points which break graph connectivity when removed. Other forms ofencapsulation, such as the package level restrictions in Confined Types [28], are
too coarse-grained to enable external uniqueness.Kim, Bertino and Garza [30] define semantics for references capable of expressing a shallow form of ownership and traditional uniqueness for compositereferences. This system is however not statically checked nor does it provide deep
ownership or external uniqueness, though the machinery seems to be in place toimplement the latter via dynamic checks. A more detailed comparision with this
and other models from the OODB community would be instructive.We consider two kinds of borrowing of unique references:

borrowed parameters method parameters, this, and/or local variables mayborrow a unique reference. Borrowed references may not be assigned to fields.
orthogonal borrowing references are either unique or non-unique. Scope re-strictions apply to a borrowed unique reference to ensure that the uniqueness

invariant can be regained.
In Eiffel* [35], AliasJava [1], Balloons [2], Pivot Uniqueness [33] and Capabil-ities for sharing [13], borrowing weakens uniqueness since the unique reference is

still visible and usable despite the existence of the temporary borrowed aliases.This is avoided in PRFJ [9], Vault [19] and our proposal by using nullification or
scope restrictions, and in Alias Burying [11] by invalidating all borrowings if aunique field or variable is read while borrowed. Checking the constraints underlying alias burying modularly leads to an interdependence between uniquenessand read effects [12]. Guava [3] also uses lent parameters to avoid capturing of
objects.Some remarks regarding Table 2 follow. (a) PRFJ [9] permits object graphs
which violates deep ownership, but it uses an effects system to prevent accessthrough the offending references. The result is effectively deep ownership. In
addition, to increase flexibility, PRFJ allows unique to be used even as a non-owner parameter. For example, to allow a list class where the data in the links is
unshared, see Figure 5, unique is used in the data owner position. This requiresthat the list class be written with this in mind. Unfortunately, no formalisation
exists, and so we have remained conservative and permit unique to appear onlyas the owner. (b) DeLine and F"ahndrich [21] give a practical linear type system for a non object-oriented, imperative language. Our borrowing resemblestheir adopt operation, where a linear reference temporarily becomes non-linear.
They also have a focus operation which enables non-linear references to linearentities to be treated linearly, avoiding destructive read. The inflexible nature
of classes makes this difficult to achieve in our setting. (c) Pivot uniqueness [33]only enables unique fields to be assigned with newly created objects or null. (d)
Capabilities for sharing [13] offers primitive and dynamic constructs that com-bine to give various kinds uniqueness, read-only references etc., though no one
specific policy is enforced. Furthermore, no static type system exists. Finally, (e)Islands [29] only allows borrowing through read-only references.

Uniqueness and Linearity Girard's linear logic [25] created the opportunity forstronger control of resources in programming languages. However, a number of
researchers have realised that programming with uniqueness or linearity in itsstrictest form is painful [41, 4]. Wadler's

let! construct, quasi-linear types [31],and Vault's adoption and focus [21], for example, introduce means for alleviating

this pain. Our notion of external aliasing and to a lesser extent our borrowingconstruct were designed for a similar goal in an object-oriented setting.

Region-based memory management Our scoped region construct is similar tolexically scoped

letregion construct used in region-based memory management[39, 40]. There are a number of differences. Firstly, our construct is under programmer control, as in Cyclone [27], whereas the regions calculus is the basis fora compiler's intermediate language. Secondly, the principal aim of region-based
memory management differs from ours, which is to limit the aliasing betweenobjects. The final difference is the technical machinery used to achieve safety:
our approach is structural, maintaining a specific nesting relationship betweenobjects to ensure that no references into a deleted region remain (see also [15]),
whereas the regions calculus uses effects to determine that references into adeleted region are never dereferenced. Both Cyclone [27] and Gay and Aiken's
RC [24] manage a nesting relationship which captures when one object outlives

another. While some attempts to explicitly add region-based memory manage-ment to Java exist [42, 14], they require interfaces to be extended with effects
annotations to ensure modular checking, whereas our structural approach usesownership and owner annotations. Recently , however, Boyapati et.al., did add
regions and ownership to Java to address the problems of Real-time Java [10].Although the structural approach lacks the delicacy of the regions calculus, we
believe that it is closer to the spirit of object-oriented programming.

9 Conclusions and Future Work
In this paper we introduced a new take on uniqueness called external uniqueness.This was a natural extension of ownership types; while not free, it is, in a sense,
already paid for once you have ownership types.2 On the surface our proposalseems to violate the very essence of uniqueness, permitting arbitrary internal
references to an object which is referred to by an externally unique pointer, but,as we have demonstrated, the external references is the only active reference to
the object, and is thus effectively unique. Furthermore, our definition solves anabstraction problem from which existing approaches to uniqueness suffer.

This work forms part of a general program to localise references, behaviour,control, etc. to simplify reasoning about programs. We wish to further our work
in this direction. In addition, we are adding external uniqueness to our Joecompiler [16] so that we can then explore more programming patterns and apply
our ideas to concurrency, mobility, memory management and so forth.

References

1. Jonathan Aldrich, Valentin Kostadinov, and Craig Chambers. Alias annotations

for program understanding. In OOPSLA Proceedings, November 2002.
2. Paulo S'ergio Almeida. Balloon Types: Controlling sharing of state in data types.

In ECOOP Proceedings, June 1997.
3. David F. Bacon, Robert E. Strom, and Ashis Tarafdar. Guava: a dialect of Java

without data races. In OOPSLA Proceedings, pages 382-400, 2000.
4. Henry G. Baker. `Use-once' variables and linear objects - storage management,

reflection and multi-threading. ACM SIGPLAN Notices, 30(1), January 1995.
5. Anindya Banerjee and David A. Naumann. Representation independence, confinement, and access control. In Proceedings of the 29th ACM Symposium on Principles
of Programming Languages (POPL'02), Portland, Oregon, January 2002.
6. Greg Bollella, James Gosling, Benjamin Brosgol, Peter Dibble, Steve Furr, and

Mark Turnbull. The Real-Time Specification for Java. Addison-Wesley, 2000.
7. Chandrasekhar Boyapati, Robert Lee, and Martin Rinard. Ownership types for

safe programming: Preventing data races and deadlocks. In OOPSLA Proceedings,
November 2002.
8. Chandrasekhar Boyapati, Barbara Liskov, and Liuba Shrira. Ownership types and

safe lazy upgrades in object-oriented databases. Technical Report MIT-LCS-TR858, Laboratory for Computer Science, MIT, July 2002.

2 Quoting Simon Peyton Jones

9. Chandrasekhar Boyapati and Martin Rinard. A parameterized type system for

race-free Java programs. In OOPSLA Proceedings, 2001.
10. Chandrasekhar Boyapati, Alexandru Salcianu, William Beebee, and Martin Rinard. Ownership types for safe region-based memory management in real-time
java. In ACM SIGPLAN 2003 Conference on Programming Language Design and
Implementation (PLDI), June 2003.
11. John Boyland. Alias burying: Unique variables without destructive reads. Software

-- Practice and Experience, 31(6):533-553, May 2001.
12. John Boyland. The interdependence of effects and uniqueness. In 3rd Workshop

on Formal Techniques for Java Programs, June 2001.
13. John Boyland, James Noble, and William Retert. Capabilities for Sharing: A

Generalization of Uniqueness and Read-Only. In ECOOP Proceedings, June 2001.
14. M. V. Christiansen and P. Velschrow. Region-based memory management in Java.

Master's thesis, Department of Computer Science (DIKU), University of Copenhagen, May 1998.
15. David Clarke. Object Ownership and Containment. PhD thesis, School of Computer Science and Engineering, University of New South Wales, Sydney, Australia,
2001.
16. David Clarke and Sophia Drossopolou. Ownership, encapsulation and the disjointness of type and effect. In OOPSLA Proceedings, November 2002.
17. David Clarke, John Potter, and James Noble. Ownership types for flexible alias

protection. In OOPSLA Proceedings, 1998.
18. David Clarke and Tobias Wrigstad. External uniqueness. In 10th Workshop on

Foundations of Object-Oriented Languages (FOOL), New Orleans, LA, January
2003.
19. Robert DeLine and Manuel F"ahndrich. Enforcing high-level protocols in low-level

software. In Proceedings of the ACM Conference on Programming Language Design
and Implementation, pages 59-69, June 2001.
20. David L. Detlefs, K. Rustan M. Leino, and Greg Nelson. Wrestling with rep

exposure. Technical Report SRC-RR-98-156, Compaq Systems Research Center,
July 1998.
21. Manuel F"ahndrich and Robert DeLine. Adoption and focus: Practical linear types

for imperative programming. In Proceedings of the ACM Conference on Programming Language Design and Implementation, June 2002.
22. Manuel F"ahndrich and K. Rustan M. Leino. Non-null types in an object-oriented

language. In Erik Poll, editor, Formal Techniques for Java-like Programs, M'alaga,
Spain, June 2002. Appears in Technical report NIII-R0204, Computing Science
Department, University of Nijmegen, 2002.
23. Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design Patterns. Addison-Wesley, 1994.
24. David Gay and Alex Aiken. Language support for regions. In ACM SIGPLAN

2001 Conference on Programming Language Design and Implementation (PLDI),
Snowbird, Utah, June 2001.
25. J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1-102, 1987.
26. Aaron Greenhouse and John Boyland. An object-oriented effects system. In

ECOOP'99, 1999.
27. Dan Grossman, Greg Morrisett, Trevor Jim, Michael Hicks, Yanling Wang, and

James Cheney. Region-based memory management in Cyclone. In Proceedings of
the ACM Conference on Programming Language Design and Implementation, June
2002.

28. Christian Grothoff, Jens Palsberg, and Jan Vitek. Encapsulating objects with

confined types. In OOPSLA Proceedings, 2001.
29. John Hogg. Islands: Aliasing protection in object-oriented languages. In OOPSLA

Proceedings, November 1991.
30. Won Kim, Elisa Bertino, and Jorge F Garza. Composite objects revisited. In

Proceedings of the 1989 ACM SIGMOD International Conference on Management
of Data, pages 337-347, Portland, Oregon, 1989.
31. Naoki Kobayashi. Quasi-linear types. In 26th ACM Symposium on Principles of

Programming Languages, January 1999.
32. Doug Lea. Concurrent-Programming in Java: Design Principles and Patterns. Java

Series. Addision-Wesley, 1998.
33. K. Rustan M. Leino, Arnd Poetzsch-Heffter, and Yunhong Zhou. Using data groups

to specify and check side effects. In Proceedings of the ACM Conference on Programming Language Design and Implementation, June 2002.
34. K. Rustan M. Leino and Raymie Stata. Virginity: A contribution to the specification of object-oriented software. Information Processing Letters, 70(2):99-105,
April 1999.
35. Naftaly Minsky. Towards alias-free pointers. In ECOOP Proceedings, July 1996.
36. P. M"uller and A. Poetzsch-Heffter. Universes: A type system for controlling representation exposure. In A. Poetzsch-Heffter and J. Meyer, editors, Programming
Languages and Fundamentals of Programming. Fernuniversit"at Hagen, 1999.
37. James Noble, Jan Vitek, and John Potter. Flexible alias protection. In Eric Jul,

editor, ECOOP'98-- Object-Oriented Programming, volume 1445 of Lecture Notes
In Computer Science, pages 158-185, Berlin, Heidelberg, New York, July 1988.
Springer-Verlag.
38. John Potter, James Noble, and David Clarke. The ins and outs of objects. In

Australian Software Engineering Conference, Adelaide, Australia, November 1998.
IEEE Press.
39. J.-P Talpin and P. Jouvelot. Polymorphic type, region, and effect inference. Journal

of Functional Programming, 2(3):245-271, July 1992.
40. Mads Tofte and Jean-Pierre Talpin. Region-Based Memory Management. Information and Computation, 132(2):109-176, 1997.
41. Phil Wadler. Linear types can change the world! In M. Broy and C. B. Jones,

editors, IFIP TC 2 Working Conference on Programming Concepts and Methods,
pages 561-581, Sea of Gallilee, Israel, April 1990. North-Holland.
42. Bennett Norton Yates. A type-and-effect system for encapsulating memory in

Java. Master's thesis, Department of Computer and Information Science and the
Graduate School of the University of Oregon, August 1999.

A Type Rules
The complete collection of type rules are given here.
E ` 3 Good environment

(env-;)

; ` 3

(env-x)
E ` t x /2 dom(E)

E, x :: t ` 3

(env-o"" A^*)
E ` p o"" /2 dom(E)

E, o"" A^* p ` 3

(env-o"" A'*)
E ` pi21..n o"" /2 dom(E)

E, o"" A'* F{pi21..n} ` 3

E ` p Good owner

(owner-var)

o"" R 2 E

E ` o""

(owner-this)

this :: t 2 E

E ` this

(owner-world)

E ` 3
E ` world

E ` p A'* q Owner p is inside q

(in-env1)
o"" A'* F P 2 E p 2 P

E ` o"" A'* p

(in-env2)
o"" A^* p 2 E

E ` p A'* o""

(in-world)

E ` p
E ` p A'* world

(in-this)
this :: t 2 E
E ` this A'* owner

(in-refl)

E ` p
E ` p A'* p

(in-trans)
E ` p A'* q E ` q A'* q0

E ` p A'* q0`

P , ` class Good Program and Class

(program)`
class for all class 2 P ` s ; E E ` e :: t`

classi21..n s e :: t

(class-object)
` class Object { }
(class)
E0 = owner A'* world, o""i Ri pi21..m E0 ` owner A'* o""i21..m
E0 ` owner:c0h?i owner /2 rng(?) E = E0, this :: owner:cho""i21..mi{

fi21..n} " dom(Fc0) = ; E ` ei :: ti21..r E ` methj21..sM

c(m) t^ ?(Mc0(m)) 8m 2 names(methj21..s) " dom(Mc0)`
class cho""i Ri pi21..mi extends c0h?i {ti fi = ei21..r methj21..s}

E ` meth Good Method

(method)
E00 = E, o""i Ri pi21..n, xj :: tj21..m E00 ` s; E0 E0 ` e :: t0

E ` ho""i Ri pi21..ni t0 m(ti xi21..m){ s return e }

E ` t Good Type

(type)
class cho""i Ri pi21..ni * * * 2 P
? = {owner 7! q, o""i 7! qi21..n} E ` ?(o""i Ri pi)i21..n

E ` q :chqi21..ni
E ` uniqueq :chqi21..ni

E ` t <= t0 t is a subtype of t0

(sub-lose-unique)

E ` p :ch?i
E ` uniquep :ch?i <= p :ch?i

(sub-class)
E ` p:ch?pi class ch. . .i extends c0hp0i21..ni * * * 2 P

E ` p :ch?i <= p :c0h?p(p0i21..n)i
E ` uniquep :ch?i <= uniquep :c0h?p(p0i21..n)i

(sub-refl)

E ` t
E ` t <= t

(sub-trans)
E ` t <= t0 E ` t0 <= t00

E ` t <= t00

(sub-move)
E ` p0 A'* p E ` p:chpi21..ni
E ` uniquep :chpi21..ni <= uniquep0 :chpi21..ni

E ` s ; E0 Good statement. Resulting environment E0
(stat-skip)

E ` 3
E ` skip; ; E

(stat-local)
x /2 dom(E) E ` e :: t

E ` t x = e; ; E, x :: t

(stat-expr)

E ` e :: t
E ` e; ; E

(stat-update)
E ` lval :: t ref E ` e :: t

E ` lval = e; ; E

(stat-sequence)
E ` s1 ; E00 E00 ` s2 ; E0

E ` s1 s2 ; E0

(stat-scoped-region)
E, o"" A'* F P ` s ; E0 P t, owners(E)

E ` (o"") { s } ; E

(stat-block)

E ` s ; E0
E ` {s} ; E

(stat-if-then-else)
E ` e :: bool E ` s1 ; E0 E ` s2 ; E00

E ` if (e) { s1 } else { s2 } ; E

(stat-borrow)
E ` lval :: uniquep :chpi21..ni ref
E, o"" A'* p, x :: o"" :chpi21..ni ` s ; E0
E ` borrow lval as ho""i x { s } ; E

E ` lval :: t ref l-value of type t

(lval-var)
x :: t 2 E x 6= this

E ` x :: t ref

(lval-field)
E ` e :: p:ch?i Fc(f) = t
this 2 owners(t) ) e t^ this

E ` e.f :: ?p(t) ref

E ` e :: t Expression e has type t

(expr-lval)
E ` lval :: t ref ~unique(t)

E ` lval :: t

(expr-dread)
E ` lval :: t ref

E ` lval-- :: t

(expr-this)
this :: t 2 E

E ` this :: t

(expr-new)

E ` t
E ` new t :: t

(expr-null)

E ` t
E ` null :: t

(expr-subsumption)

E ` e :: t E ` t <= t0

E ` e :: t0

(expr-call)
E ` e :: p:ch?i Mc(m) = 8(o""i Ri pi21..n)tj21..m ! t0
this 2 owners(8(o""i Ri pi21..n)tj21..m ! t0) ) e t^ this
?0 = {o""i 7! qi21..n} E ` ?0(?p(o""i Ri pi21..n)) E ` ej :: ?0(?p(tj)) for all j 2 1..m

E ` e.mhqi21..ni(ej21..m) :: ?0(?p(t0))