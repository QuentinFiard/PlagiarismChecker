

Monadic Regions

[Extended Abstract]

Matthew FluetCornell University
Department of Computer Science4133 Upson Hall

Ithaca, NY 14853fluet@cs.cornell.edu

ABSTRACT
Drawing together two lines of research (that done in typesafe region-based memory management and that done in
monadic encapsuation of effects), we give a type-preserving
translation from a variation of the region calculus of Tofte
and Talpin into an extension of System F augmented with
monadic types and operations. Our source language is a
novel region calculus, dubbed the Single Effect Calculus, in
which sets of effects are specified by a single region representing an upper bound on the set. Our target language is FRGN,
which provides an encapsulation operator whose parametric
type ensures that regions (and values allocated therein) are
neither accessible nor visible outside the appropriate scope.

1. INTRODUCTION

Region-based memory management is a particular way to
manage the dynamically (or heap) allocated memory of a
program. It stands in contrast to explicit memory management by the programmer using operations like C's malloc
and free and to fully automatic memory management using
a garbage collector. In a region-based memory management
system, regions are areas of memory holding heap allocated
data. Regions have syntactic lifetimes, following the block
structure of the program. A region is created upon entering
a region delimited block; for the duration of the block, data
can be allocated into the region; upon exiting the block,
the entire region (including all data allocated within it) is
destroyed. Tofte and Talpin's region calculus [24, 25] introduced a type system, based on effects, that ensures the safety
of this allocation and deallocation mechanism. A unique
feature of this scheme is that evaluation can lead to dangling pointers: a pointer to data that has been deallocated.
So long as the program never dereferences such a pointer (a
fact that the type system verifies), the program can be safely
run. This aspect of region-based memory management systems can lead to better memory usage than that achieved

Permission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specificpermission and/or a fee.
SPACE2004 2004 Venice, ItalyCopyright 200X ACM X-XXXXX-XX-X/XX/XX ...$5.00.

by garbage collectors, which do not allow dangling pointers,
on some programs.

While there has been some work aimed at integrating
garbage collection and region-based memory management
[9, 6], it is not possible to manage particular data by one
scheme or the other. Cyclone [12] offers multiple forms of
memory management in the context of a safe dialect of C.
However, it makes use of a sophisticated type-and-effect system to ensure safety. We seek, therefore, a simple account
that supports region-based memory management within a
"traditional" functional programming language that primarily relies upon garbage collection and a simple type system.

A separate line of research has investigated mechanisms by
which imperative (and otherwise "foreign") constructs can
be safely integrated into pure functional languages. Launchbury and Peyton Jones [14, 15] introduced monadic state as
a means by which imperative computations could be embedded in the pure evaluation of a functional program. The encapsulation operator runST has a type that statically guarantees that stateful computations appear as pure functions
to the rest of the program. Inspired by this work, we propose
monadic regions as a mechanism for embedding region-based
memory management within a pure functional language.

The main contributions of this paper are three-fold. First,
we introduce a novel region calculus, dubbed the Single Effect Calculus. The Single Effect Calculus tracks a partial
order on regions; this order can be used allow a single region to bound the effect of a set of regions. Second, we
introduce a novel monadic language, dubbed FRGN, which
is an extension of System F that adds monadic types and
operations for manipulating regions. A key aspect of this
language is that no extension (beyond adding three type
constructors) to the type system of System F is required; in
particular, type equality in FRGN is syntactic and all new
language expressions can be interpreted as constants with
polymorphic types. Encapsulation of region computations
in FRGN is ensured by the type system, using parametricity. Finally, we give a type preserving translation from the
Single Effect Calculus to FRGN, an important first step towards demonstrating the adequacy of FRGN for expressing
region-based memory management.

The remainder of this paper is structured as follows. In
the next two sections, we describe the Single Effect Calculus and FRGN. Section 4 presents a type preserving translation from the Single Effect Calculus to FRGN. In Section 5,
we consider related work. Section 6 concludes and notes

i 2 Z
", % 2 RVarsSEC where H 2 RVarsSEC
f, x 2 VarsSEC

Types

o/ ::= bool | (u, ae)
Boxed types

u ::= int | o/1 ffl-! o/2 | o/1 * o/2 | \Pi % * '.fflo/
Effects

' ::= {ae1, . . . , aen}
Places

ffl, ae ::= %

Programs

p ::= e
Terms

e ::= i at ae | e1 _ e2 at ae | e1 4 e2 |

tt | ff | if eb then et else ef |
x | *x : o/.ffle at ae | e1 e2 |
(e1, e2) at ae | fst e | snd e |
new %.e | *% * '.fflu at ae | e [ae] |
fix f : o/.u
Abstractions

u ::= *x : o/.ffle at ae | *% * '.fflu at ae

Figure 1: Single Effect Calculus: Syntax

some directions for future work. Supplemental figures can
be found in the appendix.

2. THE SINGLE EFFECT CALCULUS

The Single Effect Calculus is a variation of the region calculus of Tofte and Talpin [24, 25], in the spirit of [11], and
taking inspiration from the Capability Calculus [5] and Cyclone [8]. Essentially, the Single Effect Calculus capitalizes
on the fact that a LIFO stack of regions imposes a partial
order on live (allocated) regions. Regions lower on the stack
outlive regions higher on the stack. Hence, the liveness of
a region implies the liveness of all regions below it on the
stack. Thus, it is the case that a single region can serve as
a witness for a set of effects: the region appears as a single
effect in place of the set.

Figure 1 presents the syntax of "initial programs" (that is,
excluding intermediate terms that would appear in an operational semantics) of the Single Effect Calculus. Figures 2
and 3 presents a type system for this external language.
Figure 10 in the Appendix presents a simple large-step operational semantics in terms of a run-time store. In the
following sections, we explain and motivate the main constructs and typing rules of the Single Effect Calculus.

2.1 Types

In Tofte and Talpin's original region calculus, a region
is associated with every type that requires heap allocated
storage. We assume that integers, pairs, and closures require
heap allocated storage, while booleans do not. The type
(u, ae) pairs together a boxed type (a type requiring heap
allocated storage) and a place (a region); we interpret (u, ae)
as the type of objects of boxed type u, allocated in region
ae. For our external language, it suffices to allows places

to range over region variables (RVarsSEC ), which include a
distinguished member H, corresponding to a global region
that remains live throughout the execution of the program.
Various operational semantics extend the syntactic class of
places to include concrete region names [25] and/or a special
constant corresponding to a deallocated region [4].

Of the boxed types, integers and pairs are standard. More
interesting are the two boxed types corresponding to abstractions. Recall that in previous formulations of region
calculi, the types of functions and region abstractions are
given by:

o/1 '-! o/2 and \Pi %.'o/
where ' is an effect, a finite set of places. In the function
and region-abstraction types, the effect ' denotes a latent
effect, the set of regions read from or written to when an
argument is supplied to the function or a region supplied to
the region abstraction.

Our formulation of function and region abstraction types
differ. The type of a function is given by:

o/1 ffl-! o/2
where ffl is a (single) place. Whereas ' denoted the set of regions affected by executing the function, ffl denotes an upper
bound (in the partial order of regions) on the set of regions
affected by executing the function. In the case of the former,
the typing judgement for an application requires showing
that all regions in ' are live. In the case of the latter, the
typing judgement for an application only requires showing
that ffl is live; the liveness of all regions below ffl are implied
by the stack discipline.

The type of a region abstraction is given by:

\Pi % * '.fflo/
where ' and ffl are a finite set of places and a place, respectively. (Note that the region variable % is bound within ffl
and o/, but not '.) The bounded quantification in this type
requires that at the instantiation of % by a region ae, we must
be able to show that ae is outlived by all of the regions in
'. Within the body of the abstraction, we assume that % is
an upper bound on the set of regions '. As with a function
type, ffl denotes an upper bound on the set of regions affected
when the region abstraction is applied to a region.

2.2 Programs and Terms

Programs in the Single Effect Calculus are simply terms.
We distinguish programs as a syntactic class because the
type system presented in the next section has a special
judgement for top-level programs. Essentially, this judgement establishes reasonable "boundary conditions" for a
program's execution, an aspect that is often overlooked in
previous descriptions of region calculi.

Terms in the Single Effect Calculus are similar to those
found in the *-calculus. One major difference is that terms
yielding heap allocated values carry a region annotation
at ae, which indicates the region in which the value is to
be allocated. New regions are introduced (and implicitly
created and destroyed) by the new %.e term. The region
variable % is bound within e, demarcating the scope of the
region. Within e, values may be read from or allocated in
the region %. Executing new %.e allocates a new region of
memory, then executes e, and finally deallocates the region.

The term \Pi % * '.fflu at ae introduces a region abstraction
(allocated in the region ae), where the term u is polymorphic
in the region %.1 Such region polymorphism is particularly
useful in the definition of functions, in which we parameterize over the regions necessary for the evaluation of the
function. As explained in the previous section, region abstractions make use of bounded quantification; the intention
is that % is outlived by all the regions in '. The term e [ae]
eliminates a region abstraction; operationally, it substitutes
the place ae for the region variable % in u and evaluates resulting term.

Finally, we include a fixed-point term, fix f : o/.u. Since
we intend the Single Effect Calculus to obey a call-by-value
evaluation semantics, we limit the body of a fixed-point to
abstractions.As an example, consider the following term to compute a

factorial (in which we elide the type annotation on fact):

fix fact.

(\Pi %i * {}.%i (\Pi %o * {}.%i (\Pi %b * {%i, %o}.%i (*n : (int, %i).%b

if new %.n <= (1 at %)

then 1 at %o
else new %o0.(new %i0 .

(fact [%i0] [%o0] [%i0 ]

(new %.n - (1 at %) at %i0))) * n at %o
) at %i) at %i) at %i) at %f

The function fact is parameterized by three regions: %i is
the region in which the input integer is allocated, %o is the
region in which the output integer is to be allocated, and
%b is a region that bounds the latent effect of the function.
We see that the bounds on %i and %o indicate that they are
not constrained to be outlived by any other regions. On
the other hand, the bound on %b indicates that both %i and
%o must outlive %b. Hence, %b suffices to bound the effects
within the body of the function, in which we expect region
%i to be read from and region %o to be allocated in. Note
that the regions passed to the recursive call to fact satisfy
the bounds, as %i0 clearly outlives itself and %o0 is allocated
before (and deallocated after) %i0.

2.3 Typing Judgements

The typing rules for the Single Effect Calculus appear in
Figures 2 and 3. Region contexts \Delta  are ordered lists of
region variables bounded by effect sets. Value contexts \Gamma 
are ordered lists of variables and types. We summarize the
main typing judgements in the following table:

Judgement Meaning
\Delta  `btype u Boxed type u is well-formed.
\Delta  `type o/ Type o/ is well-formed.
\Delta  `rr ffl * ae If region ffl is live, then region ae is live.

(Alt.: region ae outlives region ffl.)
\Delta  `re ffl * ' If region ffl is live, then all regions in '

are live. (Alt.: all regions in ' outlive
region ffl.)
\Delta ; \Gamma  `exp e : o/, ffl Term e has type o/ and effects

bounded by region ffl.
`prog p ok Program p is well-typed.

Previous formulations of region calculi make use of a
judgement of the form \Gamma  `exp e : o/, ', where ' indicates
the set of regions that may be effected by the evaluation
of e (and the set of bound region variables is left implicit).

1Limiting the body of a region abstraction to abstractions

ensures that an erasure function that removes region annota-tions and produces a *-calculus term is meaning preserving.

The Single Effect Calculus simply replaces ' with a single
region ffl that bounds the effects in '. In practice, and as
suggested by the typing rules, ffl corresponds to the most recently allocated region (also referred to as the top or current
region).

We start by noting that the typing rules for the judgements \Delta  `rr ffl * ae and \Delta  `re ffl * ' simply formalize the
reflexive, transitive closure of the syntactic constraints in
\Delta , each of which asserts a particular "outlived by" relation
between a region variable and an effect set.

The key judgement in region calculi is the typing rule for
new %.e:

% 62 dom(\Delta ) \Delta  `type o/

\Delta , % * {ffl}; \Gamma  `exp e : o/,%

\Delta ; \Gamma  `exp new %.e : o/, ffl

The antecedent \Delta  `type o/ asserts that the new region variable % does not appear in the result type, including any effects occurring in region abstraction types that appear in the
result type. Note further that the antecedent % /2 dom(\Delta )
and the implicit judgement `ctxt \Delta ; \Gamma ; ffl ensure that % does
not appear in the types of the value environment. Together,
these facts guarantee that the region % is not needed before
the evaluation of e, nor is it needed after, corresponding to
the allocation and deallocation of a new region. This new region is clearly related to the current region ffl -- it is outlived
by the "old" current region and becomes the "new" current
region for the evaluation of e. These facts are captured by
the final antecedent \Delta , % * {ffl}; \Gamma  `exp e : o/, %.

It is worth comparing the treatment of latent effects in
the Single Effect Calculus with their treatment in previous
formulations of region calculi. In previous work, the typing
rule for application appears as follows:

\Gamma  `exp e1 : (o/1 '-! o/2, ae), '1 \Gamma  `exp e2 : o/2, '2

\Gamma  `exp e1 e2 : o/2, ' [ '1 [ '2 [ {ae}

In the Single Effect Calculus, the composite effect ' [ '1 [
'2 [ {ae} is witnessed by a single effect ffl that subsumes
the effect of the entire expression. We interpret ffl as an
upper bound on the composite effect; hence, ffl is an upper
bound on each of the effect sets '1 and '2, which explains
why ffl is used in the antecedents that type-check the subexpressions e1 and e2. In order to execute the application,
the operational semantics must read the function out of the
region ae; therefore, we require ae to outlive the current region
ffl by the antecedent \Delta  `rr ffl * ae. Finally, we require the
latent single effect ffl0, which is an upper bound on the set
of regions affected by executing the function, to outlive the
current region, which ensures that ffl is also an upper bound
on the set of regions affected by executing the function.

As alluded to in the previous section, the typing rule for
region application requires that we be able to show that the
formal region parameter ae is outlived by all of the regions
in the region abstraction bound '.

Finally, the rule for top-level programs requires that an
expression evaluate to a boolean value in the context of distinguished region H that remains live throughout the execution of the program. It also serves as the single effect
that bounds the effects of the entire program. Alternative
formulations of these "boundary conditions" exist; we have
adopted these to simplify the translation in Section 4.

Region contexts
\Delta  ::= * | \Delta , % * '

Value contexts
\Gamma  ::= * | \Gamma , x : o/

`rctxt \Delta 

`rctxt *

`rctxt \Delta  % 62 dom(\Delta ) \Delta  `eff '

`rctxt \Delta , % * '

\Delta  `place ae

% 2 dom(\Delta )

\Delta  `place %

\Delta  `eff '

\Delta  `place aei i21...n
\Delta  `eff {ae1, . . . , aen}

\Delta  `btype u

\Delta  `btype int

\Delta  `type o/1 \Delta  `place ffl \Delta  `type o/2

\Delta  `btype o/1 ffl-! o/2

\Delta  `type o/1 \Delta  `type o/2

\Delta  `btype o/1 * o/2

% 62 dom(\Delta ) \Delta  `eff ' \Delta , % * ' `place ffl \Delta , % * ' `type o/

\Delta  `btype \Pi % * '.fflo/

\Delta  `type o/

\Delta  `type bool

\Delta  `btype u \Delta  `place ae

\Delta  `type (u, ae)

\Delta  `rr ffl * ae

\Delta (") = {ae1, . . . , aei, . . . , aen}

\Delta  `rr " * aei

\Delta  `place ffl
\Delta  `rr ffl * ffl

\Delta  `rr ffl * ffl0 \Delta  `rr ffl0 * ae

\Delta  `rr ffl * ae

\Delta  `re ffl * '

\Delta  `rr ffl * aei i21...n
\Delta  `re ffl * {ae1, . . . , aen}

\Delta  `vctxt \Gamma 

\Delta  `vctxt *

\Delta  `vctxt \Gamma  x 62 dom(\Gamma ) \Delta  `type o/

\Delta  `vctxt \Gamma , x : o/

`ctxt \Delta ; \Gamma ; ffl

`rctxt \Delta  \Delta  `vctxt \Gamma  \Delta  `place ffl

`ctxt \Delta ; \Gamma ; ffl

Figure 2: Single Effect Calculus: Static Semantics (I)

\Delta ; \Gamma  `exp e : o/, ffl

\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp i at ae : (int, ae), ffl

\Delta ; \Gamma  `exp e1 : (int, ae1), ffl \Delta  `rr ffl * ae1
\Delta ; \Gamma  `exp e2 : (int, ae2), ffl \Delta  `rr ffl * ae2

\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp e1 _ e2 at ae : (int, ae), ffl

\Delta ; \Gamma  `exp e1 : (int, ae1), ffl \Delta  `rr ffl * ae1
\Delta ; \Gamma  `exp e2 : (int, ae2), ffl \Delta  `rr ffl * ae1

\Delta ; \Gamma  `exp e1 4 e2 : bool, ffl

\Delta ; \Gamma  `exp tt : bool, ffl \Delta ; \Gamma  `exp ff : bool, ffl

\Delta ; \Gamma  `exp eb : bool, ffl
\Delta ; \Gamma  `exp et : o/, ffl \Delta ; \Gamma  `exp ef : o/, ffl

\Delta ; \Gamma  `exp if eb then et else ef : o/, ffl

\Gamma (x) = o/
\Delta ; \Gamma  `exp x : o/, ffl

x 62 dom(\Gamma ) \Delta  `type o/1 \Delta  `place ffl0

\Delta ; \Gamma , x : o/1 `exp e : o/2, ffl0
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp *x : o/1.ffl

0e at ae : (o/

1

ffl0-! o/

2, ae), ffl

\Delta ; \Gamma  `exp e1 : (o/1 ffl

0-! o/

2, ae), ffl \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp e2 : o/1, ffl \Delta  `rr ffl * ffl0

\Delta ; \Gamma  `exp e1 e2 : o/2, ffl

\Delta ; \Gamma  `exp e1 : o/1, ffl
\Delta ; \Gamma  `exp e2 : o/2, ffl
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp (e1, e2) at ae : (o/1 * o/2, ae), ffl

\Delta ; \Gamma  `exp e : (o/1 * o/2, ae), ffl \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp fst e : o/1, ffl

\Delta ; \Gamma  `exp e : (o/1 * o/2, ae), ffl \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp snd e : o/2, ffl

% 62 dom(\Delta ) \Delta  `type o/

\Delta , % * {ffl}; \Gamma  `exp e : o/,%

\Delta ; \Gamma  `exp new %.e : o/, ffl

% 62 dom(\Delta ) \Delta  `eff ' \Delta  `place ffl0

\Delta , % * '; \Gamma  `exp u : o/, ffl0
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp *% * '.ffl

0u at ae : (\Pi % * '.ffl0 o/, ae), ffl

\Delta ; \Gamma  `exp e : (\Pi % * '.ffl

0o/, ae0), ffl \Delta  `

rr ffl * ae0

\Delta  `place ae \Delta  `re ae * '

\Delta  `rr ffl * ffl0[ae/%]

\Delta ; \Gamma  `exp e [ae] : o/[ae/%], ffl

f 62 dom(\Gamma ) \Delta  `type o/

\Delta ; \Gamma , f : o/ `exp u : o/, ffl

\Delta ; \Gamma  `exp fix f : o/.u : o/, ffl

`prog p ok

*, H * {}; * `exp p : bool, H

`prog p ok

Figure 3: Single Effect Calculus: Static Semantics (II)

2.4 Discussion

An important issue to consider is the expressiveness of the
Single Effect Calculus relative to Tofte and Talpin's original
region calculus. Tofte and Talpin's formulation of the region
calculus as the implicit target of an inference system makes
a direct comparison difficult. Fortunately, there has been
sufficient interest in region-based memory management to
warrant direct presentations of the region calculus [10, 3, 4,
11], which are better suited for comparison. Three aspects
of the region calculus are highlighted as essential features:
region polymorphism, region polymorphic recursion, and effect polymorphism.

The Single Effect Calculus clearly supports region polymorphism (albeit, in a slightly different form). Furthermore,
region polymorphic recursion is supported by fixing a region abstraction, as demonstrated in the fact example. One
can give a straightforward translation from a source region
calculus without effect polymorphism into the Single Effect
Calculus. At the type level, this transation expands every
function type into a function and region abstraction type:

T r(o/1 '-! o/2, ae)z = (T Jo/1K ae-! (\Pi " * '."T Jo/2K , ae), ae)
At the term level, source functions become functions and region abstractions and applications become applications and
region applications. A similar approach deals with region
abstractions in the source language. Essentially, this translation works by looking for the places where region sets are
used in the source calculus and simply replacing them by
an abstraction over that set. Clearly, this is not the most
efficient translation. For example, in places where we could
statically identify an upper bound on the region set (e.g.,
a singleton region set), we could elide the abstraction and
simply use the upper bound.

Effect polymorphism can be simulated in the Single Effect Calculus, although at a heavier notational cost. Recall
that effect polymorphism provides a means to abstract over
an entire set of regions. Effect instantiation applies an effect
abstraction to a set of regions. Effect polymorphism is especially useful for typing higher-order functions. For example,
the type of the list map function is polymorphic in the effect
of the functional argument.

Encoding effect polymorphism in the Single Effect Calculus begins by replacing effect abstractions (8".aeo/) by region
abstractions with an empty bound (\Pi " * {}.aeo/ ). Effect
instantiation must be translated to region instantiation; in
particular, the set of regions must be translated to a single
region denoting the upper bound of the set. In the presence of region polymorphism, this can be complicated, because a set of region variables may have no obvious upper
bound. Hence, we must extend the translation to include
upper bounds for each set of region variables that may be
used in an effect instantiation. For example, a source type
like (\Pi %1.'1 (\Pi %2.'2 .(\Pi %3.'3 o/, ae3), ae2), ae3) (where any subset of {%1, %2, %3} may be used in an effect instantiation) is
translated to

(\Pi %1 * {}.ae1 (\Pi "1 * '1."1

(\Pi %2 * {}.ae2 (\Pi "2 * '2."2

(\Pi %12 * {%1, %2}.ae2

(\Pi %3 * {}.ae3 (\Pi "3 * '3."3

(\Pi %13 * {%1, %3}.ae3(\Pi %23 * {%2, %3}.ae3

(\Pi %123 * {%1, %2, %3}.ae3

(T Jo/ K , ae3), ae3), ae3), ae3), ae3), ae3), ae2).ae2), ae2), ae1), ae1)

i 2 Z
ff 2 TVarsFRGN
f, x 2 VarsFRGN

Types

o/ ::= int | bool | o/1 ! o/2 | o/1 * * * * * o/n | ff | 8ff.o/ |

RGN o/r o/a | RGNVar o/r o/a | RGNHandle o/r

Terms

e ::= i | e1 _ e2 | e1 4 e3 |

tt | ff | if eb then et else ef |
x | *x : o/.e | e1 e2 | (e1, . . . , en) | seli e |
\Lambda ff.e | e [o/ ] | let x = e1 in e2 |
runRGN [o/a] v | ^
Commands

^ ::= returnRGN [o/r] [o/a] v |

thenRGN [o/r] [o/a] [o/b] v1 v2 |
allocRGNVar [o/r] [o/a] vr va |
readRGNVar [o/r] [o/a] v |
fixRGNVar [o/r] [o/a] vr vf |
newRGN [o/r] [o/a] v
Values

v ::= i | tt | ff | x | *x : o/.e | \Lambda ff.e | (v1, v2) | ^

Figure 4: FRGN: Syntax

In the term translation, %12, %23, and %123 can be used for region instantiations when the source term performs an effect
instantiation with the corresponding set of region variables.
The burden of instantiating %12, %23, and %123 falls to the
term that instantiates %1, %2, and %3, which will have sufficient information to choose the right upper bounds.

A formal translation could be given, but doing so detracts
from the work at hand.

3. THE FRGN CALCULUS

The language FRGN is an extension of System F [20, 7] (also
referred to as the polymorphic *-calculus), adding monadic
types and operations and taking inspiration from the work
on monadic state [14, 15, 16, 1, 23, 19]. Essentially, FRGN
uses an explicit region monad to enforce the locality of region
allocated values.

Figure 4 presents the syntax of "initial programs" (that
is, excluding intermediate terms that would appear in an
operational semantics) of FRGN. Figure 5 presents a type
system for this external language. Figure 11 in the Appendix
presents a simple large-step operational semantics in terms
of a run-time store. In the following sections, we explain
and motivate the main constructs and typing rules of FRGN.

3.1 Types

Types in FRGN are similar to those found in System F.
We include the primitives types int and bool, function and
product types, and type abstractions. In addition, we have
RGN o/r o/a as the type of monadic region computations,
RGNVar o/r o/a as the type of region allocated values, and
RGNHandle o/r as the type of region handles. Intuitively,
RGN o/r o/a is the type of computations that yield values
of type o/a and that take place in the region indexed by the
type o/r. Likewise, RGNVar o/r o/a is the type of values of type

o/a allocated in the region indexed by the type o/r. Finally,
RGNHandle o/r is the type of handles for the region indexed
by the type o/r. A value of such a type is a region handle - a
run-time value holding the data necessary to allocate values
within a region. Region indices (types) and region handles
(values) are distinguished in order to maintain a phase distinction between compile-time and run-time expressions and
to more accurately reflect implementation of regions. Region indices, like other types, have no run-time significance
and may be erased from compiled code. On the other hand,
region handles are necessary at run-time to allocate values
within a region.

Although the remainder of this paper will never require
a region index to be represented by anything other than
a type variable, we choose to allow an arbitrary type in
the first argument of the RGN monad type. We can thus
interpret RGN as a primitive type constructor, without any
special restrictions that may not be expressible in a practical
programming language. Furthermore, in a semantics not
based on type-erasure, type variables used as region indices
will be instantiated with region types (see Figure 11).

3.2 Terms

As with types, most of the terms in FRGN are similar to
those found in System F. Constants, arithmetic and boolean
operations, function abstraction and application, tuple introduction and elimination, and type abstraction and instantiation are all completely standard.

We let ^ range over the syntactic class of monadic commands. (Equivalently, and as suggested by the explicit type
annotations and the restriction of sub-expressions to values, we can consider the monadic commands as constants
with polymorphic types in a call-by-value interpretation of
FRGN.) Each command corresponds to a particular transformation on a monadic region. The commands returnRGN
and thenRGN are the unit and bind operations of the region
monad respectively.

The command allocRGNVar [o/r] [o/a] vr va allocates the
value va of type o/a in the region indexed by the type o/r.
The additional value vr is the region handle for the region
indexed by o/r, which is necessary to allocate values within
the region.

The command readRGNVar [o/r] [o/a] v reads a value of type
o/a stored at the location v in the region indexed by the type
o/r. The command fixRGNVar [o/r] [o/a] vr vf allocates a value
of type o/a in the region indexed by o/r; the value is produced
by the function vf which is applied to the location where
the allocated value is to be stored. This provides a means
of allocating recursive structures. We discuss this command
in more detail when we examine the typing rules for FRGN.

The command newRGN [o/r] [o/a] v first, creates a new region, executes the region computation described by v in the
new region, and finally deallocates the new region. This entire execution is a computation that yields a value of type
o/a taking place in the region indexed by o/r. We will have
more to say about the computation described by v shortly.

Finally, the expression runRGN [o/a] v eliminates regiontransformer operations. In particular, if v describes a region
computation yielding a value of type o/a, then runRGN [o/a] v
executes that computation in a region, returning the final
value produced by v and destroying the region (and any
values allocated within it). The region (and any new regions
introduced by newRGN) is neither accessible nor visible from

outside the runRGN [o/a] v expression.
3.3 Typing Judgements

The typing rules for FRGN appear in Figure 5. Type contexts \Delta  are ordered lists of type variables and value contexts
\Gamma  are ordered lists of variables and types. We introduce the
(suggestive) abbreviation o/r _ o/s for a function that coerces
any computation taking place in the region indexed by o/r
into a computation taking place in the region indexed by o/s.
We call such functions witnesses and explain their role in
more detail below.

The only typing judgement of interest is \Delta ; \Gamma  `exp e : o/
meaning that term e has type o/. The rules for constants,
arithmetic and boolean operations, function abstraction and
application, tuple introduction and elimination, and type
abstraction and instantiation are all completely standard.
As expected in a monadic language, each command expression is given the monadic type RGN o/r o/a for appropriate region index and return type. The typing rules for returnRGN
and thenRGN correspond to the standard typing rules for
monadic unit and bind operations. The typing rules for
allocRGNVar and readRGNVar are straight-forward.

As in the Single Effect Calculus, the key judgements are
those relating to the creation of new regions. We first examine the typing rule for the runRGN expression:

\Delta ; \Gamma  `exp v : 8ff.RGNHandle ff ! RGN ff o/a

\Delta ; \Gamma  `exp runRGN [o/a] v : o/a

As stated above, the argument to runRGN should describe a
region computation. In fact, we require v to be a polymorphic function that yields a region computation after being
applied to a region handle. Recall that we can consider a
value of type RGN o/r o/a as a region-transformer - that is,
it accepts a region (indexed by the type o/r), performs some
operations (such as allocating into the region), and returns
a value and the modified region. The effect of universally
quantifying the region index in the type of v is to require
v to make no assumptions about the input region (e.g., the
existence of pre-allocated values). Furthermore, all operations that manipulate a region are "infected" with the region
index: when combining operations, the rule for returnRGN
requires the region index type to be the same; locations
allocated and read using allocRGNVar and readRGNVar require the region index of the RGNVar to be the same as the
computation in which the operation occurs. Thus, if a region computation RGN o/r o/a were to return a value that
depended upon the region indexed by o/r, then o/r would appear in the type o/a. Since the type o/a appears outside the
scope of the type variable ff in the typing rule for runRGN,
it follows that ff cannot appear in the type o/a. Therefore, it
must be the case that the value returned by the computation
described by v does not depend upon the region index which
will instantiate ff. Taken together, these facts ensure that
an arbitrary new region can be supplied to the computation
and that the value returned will not leak any means of accessing the region or values allocated within it; hence, the
region can be destroyed at the end of the computation. Finally, because we require region handles for allocating within
regions, we provide the region handle for the newly created
region as the argument to a function that yields the computation we wish to execute.

Type contexts
\Delta  ::= * | \Delta , ff

Value contexts
\Gamma  ::= * | \Gamma , x : o/

o/r _ o/s j 8ff.RGN o/r ff ! RGN o/s ff
`tctxt \Delta 

`tctxt *

`rctxt \Delta  ff 62 dom(\Delta )

`tctxt \Delta , ff

\Delta  `type o/

\Delta  `type int \Delta  `type bool

\Delta  ` o/1 \Delta  ` o/2

\Delta  `type o/1 ! o/2

\Delta  `type o/i i21...n
\Delta  `type o/1 * * * * * o/n

ff 2 dom(\Delta )

\Delta  `type ff

ff 62 dom(\Delta ) \Delta , ff `type o/

\Delta  `type 8ff.o/

\Delta  `type o/r \Delta  `type o/a

\Delta  `type RGN o/r o/a

\Delta  `type o/r \Delta  `type o/a

\Delta  ` RGNVar o/r o/a

\Delta  `vctxt \Gamma 

\Delta  `vctxt *

\Delta  `vctxt \Gamma  x 62 dom(\Gamma ) \Delta  `type o/

\Delta  `vctxt \Gamma , x : o/

`ctxt \Delta ; \Gamma 

`tctxt \Delta  \Delta  `vctxt \Gamma 

`ctxt \Delta ; \Gamma 

\Delta ; \Gamma  `exp e : o/

\Delta ; \Gamma  `exp i : int

\Delta ; \Gamma  `exp e1 : int
\Delta ; \Gamma  `exp e2 : int

\Delta ; \Gamma  `exp e1 _ e2 : int

\Delta ; \Gamma  `exp e1 : int
\Delta ; \Gamma  `exp e2 : int

\Delta ; \Gamma  `exp e1 4 e2 : bool \Delta ; \Gamma  `exp tt : bool \Delta ; \Gamma  `exp ff : bool

\Delta ; \Gamma  `exp eb : bool
\Delta ; \Gamma  `exp et : o/ \Delta ; \Gamma  `exp ef : o/

\Delta ; \Gamma  `exp if eb then et else ef : o/

\Gamma (x) = o/
\Delta ; \Gamma  `exp x : o/

\Delta  `type o/1 x 62 dom(\Gamma )

\Delta ; \Gamma , x : o/1 `exp e : o/2

\Delta ; \Gamma  `exp *x : o/1.e : o/1 ! o/2

\Delta ; \Gamma  `exp e1 : o/1 ! o/2

\Delta ; \Gamma  `exp e2 : o/1

\Delta ; \Gamma  `exp e1 e2 : o/2

\Delta ; \Gamma  `exp e1 : o/i i21...n
\Delta ; \Gamma  `exp (e1, . . . , en) : o/1 * * * * * o/n

1 <= i <= n
\Delta ; \Gamma  `exp e : o/1 * * * * * o/n

\Delta ; \Gamma  `exp seli e : o/i

ff 62 dom(\Delta )
\Delta , ff; \Gamma  `exp e : o/

\Delta ; \Gamma  `exp \Lambda ff.e : 8ff.o/

\Delta  `type o/ 0
\Delta ; \Gamma  `exp e : 8ff.o/

\Delta ; \Gamma  `exp e [o/ 0] : o/ [o/ 0/ff]

\Delta ; \Gamma  `exp e1 : o/1
x 62 dom(\Gamma ) \Delta ; \Gamma , x : o/1 `exp e2 : o/2

\Delta ; \Gamma  `exp let x = e1 in e2 : o/2

\Delta ; \Gamma  `exp v : 8ff.RGNHandle ff ! RGN ff o/a

\Delta ; \Gamma  `exp runRGN [o/a] v : o/a

\Delta  `type o/r \Delta ; \Gamma  `exp v : o/a
\Delta ; \Gamma  `exp returnRGN [o/r] [o/a] v : RGN o/r o/a

\Delta ; \Gamma  `exp v1 : RGN o/r o/a
\Delta ; \Gamma  `exp v2 : o/a ! RGN o/r o/b

\Delta ; \Gamma  `exp thenRGN [o/r] [o/a] [o/b] v1 v2 : RGN o/r o/b

\Delta ; \Gamma  `exp v1 : RGNHandle o/r \Delta ; \Gamma  `exp v2 : o/a
\Delta ; \Gamma  `exp allocRGNVar [o/r] [o/a] v1 v2 : RGN o/r (RGNVar o/r o/a)

\Delta ; \Gamma  `exp v : RGNVar o/r o/a
\Delta ; \Gamma  `exp readRGNVar [o/r] [o/a] v : RGN o/r o/a

\Delta ; \Gamma  `exp v1 : RGNHandle o/r
\Delta ; \Gamma  `exp v2 : RGNVar o/r o/a ! o/a

\Delta ; \Gamma  `exp fixRGNVar [o/r] [o/a] v1 v2 : RGN o/r (RGNVar o/r o/a)

\Delta ; \Gamma  `exp v : 8ff.o/r _ ff ! RGNHandle ff ! RGN ff o/a

\Delta ; \Gamma  `exp newRGN [o/r] [o/a] v : RGN o/r o/a

Figure 5: FRGN: Static Semantics

The typing rule for newRGN is very similar:

\Delta ; \Gamma  `exp v : 8ff.o/r _ ff ! RGNHandle ff ! RGN ff o/a

\Delta ; \Gamma  `exp newRGN [o/r] [o/a] v : RGN o/r o/a

Ignoring for the moment the argument of type o/r _ ff, we see
that exactly the same argument as above applies. In particular, the computation makes no assumptions about the
newly created region, nor can the region be leaked through
the returned value of type o/a. What, then, is the role of
the witness argument? The answer lies in the fact that we
do not really intend the execution to take place in an arbitrary region. Instead, we expect the newly allocated region
to be related to previously allocated regions according to a
stack discipline (just as in region calculi). Hence, the notion
of "execution taking place in a region" is somewhat inaccurate; instead, we have executions taking place in a stack of
regions. The region index in a type RGN o/r o/a indicates a
particular member of the region stack; in practice, it often
coincides with the most recently allocated region. Thus, any
computation taking place in a stack of regions where o/s is
a member (i.e., a RGN o/s o/a term) is also a computation
taking place in a stack of regions where o/r is a member (i.e.,
a RGN o/r o/a term) whenever o/s outlives o/r. A function of
type o/s _ o/r witnesses this coercion. This explains the role
of the witness argument - it is provided to the computation
taking place in the inner region in order to coerce computations (such as allocating a new value in the outer region)
from the outer region to the inner region. Operationally,
such a witness function acts as the identity function.

Finally, we note that the typing rule for fixRGNVar requires that the function vf has the type RGNVar o/r o/a ! o/a.
Note that this is a pure function, not a monadic computation. Hence, it is safe to pass the location where the allocated value is to be stored, because no computation (hence,
no reading of region allocated values) can occur during the
evaluation of the application of vf to a location. On the
other hand, vf can return a computation that reads the
allocated value, since this computation cannot occur until
after the knot has been tied.

4. THE TRANSLATION

In this section we present a type-preserving translation
from the Single Effect Calculus to FRGN. Many of the key
components of the translation should be obvious from the
suggestive naming of the previous sections. We clearly intend new to be translated (in some fashion) to newRGN.
Likewise, we can expect types of the form (u, ae) to be translated to types of the form RGNVar. It further seems likely
that the outlives relation ffl * ae should be related to the witness functions o/r _ o/s. We present the translation in stages,
as there are some subtleties that require explanation.

We start with a few preliminaries. We assume injections
from the sets RVarsSEC and VarsSEC to the sets TVarsFRGN
and VarsFRGN respectively. In the translation, applications
of such injections will be clear from context and we freely use
variables from source objects in target objects. We further
assume two additional injections from the set RVarsSEC to
the set VarsFRGN ; the image of a region variable % under
these injections are written %h and %w respectively.

The translation is a typed call-by-value monad translation, similar to the standard translation given by Sabry and
Wadler [22]. We have not attempted to optimize the translation to avoid the introduction of "administrative" redexes.
We feel that this simplifies the translation, although it is
likely to complicate a proof that the translation preserves
the semantics. We intend to investigate an optimized translation in future work.

Figure 6 shows the translation of types and contexts. As
expected, the type (u, ae) is translated to RGNVar ae Tu JuK,
whereby region allocated values in the source are also region allocated in the target. The translations of primitive
types and product types are trivial. More interesting are
the translations of function types and region abstraction
types. Functions with effects bounded by the region ffl are
translated into pure functions that yield computations taking place in stack of regions with ffl as a member. Region
abstractions are translated into type abstractions. Because
the target calculus requires explicit region handles for allocation, each time a region is in scope in the source calculus,
the region handle must be in scope in the target calculus.
This explains the appearance of the RGNHandle % type in
the translation. Likewise, the target calculus makes witness
functions explicit, whereas in the source calculus such coercions are implied by * related regions. Hence, we interpret
% * {ae1, . . . , aen} as an n-tuple of functions, each witnessing a coercion from region aei to %. This interpretation is
formalized by the T* J*K translations.2

We extend the type translation to contexts in the obvious way. In addition to translating region variables to type
variables and translating the types of variables in value contexts, we have additional translations from region contexts
to value contexts. As explained above, region handles and
witness functions are explicit values in the target calculus.
Hence, our translation maintains the invariant that whenever a region variable % is in scope in the source calculus,
the variables %h and %w are in scope in the target calculus.
The variable %h (of type RGNHandle %) is the handle for the
region % and the variable %w (of type T* J% * 'K) is the tuple
holding the witness functions that coerce to region %.

Figure 7 shows the translation of witness terms. The first
three translations map the reflexive, transitive closure of the
syntactic constraints in a source \Delta  into an appropriate coercion function. The final translation collects a set of coercion
functions into a tuple; such a term is suitable as an argument
to the translation of a region abstraction.

Figure 8 shows the translation of key terms. Figures 12
and 13 in the Appendix show the translation of the other
terms; these additional translations are straight-forward in
light of the translations given in Figure 8. In order to make
the translation easier to read, we introduce the following
notation:

bind f : o/a ( e1; e2 j let k = e1 in

thenRGN [o/r] [o/a] [o/b] k (*f : o/a.e2)

where k fresh

2Note that in the Single Effect Calculus, we only substitutes regions for region variables. This means that the setsof regions that appear in the program never change size (although they may change elements as a result of substitu-tion). The T

* J*K translations require keeping the orderingof regions in a set {ae

1, . . . , aen} constant. It does not re-quire a global ordering on region variables; such an ordering

would not suffice for our purposes, because the ordering ofelements in a set might change after substitution. Instead,
we take {ae1, . . . , aen} as an ordered list, where substitutionpreserves the order.

Lemma 1 (Translation preserves types (types and contexts)).

* If `rctxt \Delta , then `rctxt CT\Delta  J\Delta K.

* If `rctxt \Delta  and \Delta  `btype u, then CT\Delta  J\Delta K `type Tu JuK.

* If `rctxt \Delta  and \Delta  `type o/, then CT\Delta  J\Delta K `type To/ Jo/K.

* If `rctxt \Delta  and \Delta  `vctxt \Gamma , then CE\Delta  J\Delta K `vctxt CE\Delta  J\Delta K , CE\Gamma  J\Gamma K.

Translations yielding types

Types

To/ JboolK = bool
To/ J(u, ae)K = RGNVar ae Tu JuK

Boxed types

Tu JintK = int

Tu ro/1 ffl-! o/2z = To/ Jo/1K ! RGN ffl To/ Jo/1K

Tu Jo/1 * o/2K = To/ Jo/1K * To/ Jo/2K
Tu J\Pi % * '."o/ K = 8%.T* J% * 'K ! RGNHandle % ! RGN ffl To/ Jo/K

Effects

T* Jffl * aeK = ae _ ffl
T* Jffl * {ae1, . . . , aen}K = T* Jffl * ae1K * * * * * T* Jffl * aenK

Translations yielding type contexts

Region contexts

CT\Delta  J*K = *
CT\Delta  J\Delta , % * 'K = CT\Delta  J\Delta K , %

Translations yielding value contexts

Region contexts

CE\Delta  J*K = *
CE\Delta  J\Delta , % * 'K = CE\Delta  J\Delta K , %h : RGNHandle %, %w : T* J% * 'K

Value contexts

CE\Gamma  J*K = *
CE\Gamma  J\Gamma , x : o/ K = CE\Gamma  J\Gamma K , x : To/ Jo/ K

Figure 6: Translation from the Single Effect Calculus to FRGN (Types and Contexts)

Lemma 2 (Translation preserves types (Witnesses)).

* If `rctxt \Delta  and \Delta  `rr ffl * ae, then CT\Delta  J\Delta K ; CE\Delta  J\Delta K `exp E`rr Jffl * aeK : T* Jffl * aeK.

* If `rctxt \Delta  and \Delta  `re ffl * ', then CT\Delta  J\Delta K ; CE\Delta  J\Delta K `exp E`re Jffl * 'K : T* Jffl * 'K.
Translations yielding terms (witnesses)

E`rr s \Delta (") = {ae1, . . . , ae

i, . . . , aen}

\Delta  `rr " * aei - = seli "

w

E`rr s \Delta  `place ffl\Delta  `

rr ffl * ffl - = \Lambda ff.*c : RGN ffl ff.c

E`rr s \Delta  `rr ffl * ffl

0 \Delta  `rr ffl0 * ae

\Delta  `rr ffl * ae - = \Lambda ff.*c : RGN ae ff.E`rr J\Delta  `rr ffl * ffl

0K [ff] (E

`rr J\Delta  `rr ffl

0 * aeK [ff] c)

E`re t \Delta  `rr ffl * aei

i21...n

\Delta  `re ffl * {ae1, . . . , aen} -- = (E`rr J\Delta  `rr ffl * ae1K , . . . , E`rr J\Delta  `rr ffl * ae

nK)

Figure 7: Translation from the Single Effect Calculus to FRGN (witnesses)

Lemma 3 (Translation preserves types (terms)).

* If `ctxt \Delta ; \Gamma ; ffl and \Delta ; \Gamma  `exp e : o/, ffl, then CT\Delta  J\Delta K ; CE\Delta  J\Delta K , CE\Gamma  J\Gamma K `exp E`exp J\Delta ; \Gamma  `exp e : o/, fflK : RGN ffl To/ Jo/ K.

Translations yielding terms (terms)

E`exp s \Delta  `place ae \Delta  `rr ffl * ae\Delta ; \Gamma  `

exp i at ae : (int, ae), ffl - = E`

rr J\Delta  `rr ffl * aeK [To/ J(int, ae)K] (allocRGNVar [ae] [Tu JintK] ae

h i)

E`exp s \Gamma (x) = o/\Delta ; \Gamma  `

exp x : o/, ffl - = returnRGN [ffl] [T

o/ Jo/ K] x

E`exp uwwwv

x 62 dom(\Gamma ) \Delta  `type o/1 \Delta  `place ffl0

\Delta ; \Gamma , x : o/1 `exp e : o/2, ffl0
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp *x : o/1.ffl

0e at ae : (o/

1

ffl0-! o/2, ae), ffl

"""""~

=

E`rr J\Delta  `rr ffl * aeK [To/ s(o/1 ffl

0-! o/

2, ae)-]

(allocRGNVar [ae] [Tu so/1 ffl

0-! o/

2-]

aeh (*x : To/ Jo/1K .E`exp J\Delta ; \Gamma , x : o/1 `exp e : o/2, ffl0K))

E`exp uwv

\Delta ; \Gamma  `exp e1 : (o/1 ffl

0-! o/

2, ae), ffl \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp e2 : o/1, ffl \Delta  `rr ffl * ffl0

\Delta ; \Gamma  `exp e1 e2 : o/2, ffl

"""~

=

bind f : To/ s(o/1 ffl

0-! o/

2, ae)- ( E`exp s\Delta ; \Gamma  `exp e1 : (o/1

ffl0-! o/

2, ae), ffl- ;

bind g : Tu so/1 ffl

0-! o/

2- ( E`rr J\Delta  `rr ffl * aeK [Tu so/1

ffl0-! o/

2-] (readRGNVar [ae] [Tu so/1

ffl0-! o/

2-] f);

bind a : To/ Jo/1K ( E`exp J\Delta ; \Gamma  `exp e2 : o/1, fflK ;
E`rr J\Delta  `rr ffl * ffl0K To/ Jo/2K (g a) where g, a fresh

E`exp uv

% 62 dom(\Delta ) \Delta  `type o/

\Delta , % * {ffl}; \Gamma  `exp e : o/,%

\Delta ; \Gamma  `exp new %.e : o/, ffl ""~

= newRGN [ffl] [To/ Jo/ K] (\Lambda %.*%w : T* J% * {ffl}K .*%h : RGNHandle %.

E`exp J\Delta , % * {ffl}; \Gamma  `exp e : o/, %K)

E`exp uwwv

% 62 dom(\Delta ) \Delta  `eff ' \Delta  `place ffl0

\Delta , % * '; \Gamma  `exp u : o/, ffl0
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp *% * '.ffl

0u at ae : (\Pi % * '.ffl0 o/, ae), ffl

""""~

=

E`rr J\Delta  `rr ffl * aeK [To/ r(\Pi %.ffl

0o/, ae)z]

(allocRGNVar [ae] [Tu r\Pi %.ffl

0o/z]

aeh (\Lambda %.*%w : T* J% * 'K .*%h : RGNHandle %.

E`exp J\Delta , % * '; \Gamma  `exp u : o/, ffl0K))

E`exp uwwv

\Delta ; \Gamma  `exp e : (\Pi % * '.ffl

0o/, ae0), ffl \Delta  `

rr ffl * ae0

\Delta  `place ae \Delta  `re ae * '

\Delta  `rr ffl * ffl0[ae/%]

\Delta ; \Gamma  `exp e [ae] : o/[ae/%], ffl

""""~

=

bind f : To/ r(\Pi %.ffl

0o/, ae0)z ( E

`exp r\Delta ; \Gamma  `exp e : (\Pi %.

ffl0o/, ae0), fflz ;

bind g : Tu r\Pi %.ffl

0o/z ( E

`rr J\Delta  `rr ffl * ae

0K [Tu r\Pi %.ffl0o/ z] (readRGNVar [ae0] [Tu r\Pi %.ffl0o/z] f);

E`rr J\Delta  `rr ffl * ffl0K To/ Jo/ [ae/%]K (g [ae] E`re J\Delta  `re ae * 'K aeh) where g fresh

Figure 8: Translation from the Single Effect Calculus to FRGN (Terms (I))

Lemma 4 (Translation preserves types (programs)).

* If `prog p ok, then *; * `exp E`prog J`prog p okK : bool.

Translations yielding terms (programs)

E`prog s *, H * {}; * `exp p : bool, H`

prog p ok - = runRGN (\Lambda H.*H

h : RGNHandle H.

let Hw = () in
E`exp J*; H * {}; * `exp p : bool, HK)

Figure 9: Translation from the Single Effect Calculus to FRGN (Programs)

where o/r and o/b are inferred from context.

The translation of an integer constant is a canonical example of allocation in the target calculus. The allocation is
accomplished by the allocRGNVar command, applied to the
appropriate region handle and value. However, the resulting command has type RGN ae (RGNVar ae int), whereas the
source typing judgement requires the computation to be expressed relative to the region ffl. We coerce the computation
using a witness function, whose existence is implied by the
judgement \Delta  `rr ffl * ae. Allocation of a function proceeds in
exactly the same manner. Function application, while notationally heavy, is simple. The thenRGN commands sequence
evaluating the function to a location, reading the location,
evaluating the argument, and applying the function to the
argument.

The translation of new %.e is pleasantly direct. As described above, we introduce %, %h, and %w through \Lambda - and
*-abstractions. The region handle and coercion function are
supplied by the newRGN command when the computation
is executed.

The translation of region abstraction is similar to the
translation of functions. Once again, region handles and
witness functions are *-bound in accordance to the invariants described above. During the translation of region applications, the appropriate tuple of witness functions (constructed by E`re J*K) and region handle are supplied as arguments.

Figure 9 shows the translation of programs. An entire region computation is encapsulated and run by the runRGN
expression. We bind Hw to an empty tuple, which corresponds to the absence of any coercion functions to the region
H.

In each figure, we have indicated the particular type
preservation lemma implied by each component of the translation. The proofs are by (mutual) induction on the structure of the typing judgements.

5. RELATED WORK

The work in this paper draws heavily from two lines of
research. The first is the work done in type-safe region-based
memory management, introduced by Tofte and Talpin [24,
25]. Our Single Effect Calculus draws inspiration from the
Capability Calculus [5] and Cyclone [8], where the "outlives"
relationship between regions is recognized as an important
component of type-systems for region calculi.

The work of Banerjee, Heintze and Riecke [2] deserves
special mention. They show how to translate the region
calculus of Tofte and Talpin into an extension of the polymorphic *-calculus called F#. A new type operator # is

used as a mechanism to hide and reveal the structure of
types. Capabilities to allocate and read values from a region are explicitly passed as polymorphic functions of types
8ff.ff ! (ff#ae) and 8ff.(ff#ae) ! ff; however, regions have
no run-time significance in F# and there is no notion of deallocation upon exiting a region. The equality theory of types
in F# is nontrivial, due to the treatment of #; in contrast,
type equality on FRGN types is purely syntactic. Finally, it
is worth noting that there is almost certainly a connection
between the F# lift and seq expressions and the monadic
return and bind operations, although it is not mentioned or
explored in the paper.

The second line of research on which we draw is the work
done in monadic encapsulation of effects [17, 18, 21, 14, 26,
15, 16, 22, 1, 13, 23, 19, 27]. The majority of this work has
focused on effects arising from reading and writing mutable
state. While recent work [26, 19, 27] has considered more
general combinations of effects and monads, no work has
examined the combination of regions and monads.

Launchbury and Peyton Jones [14, 15] introduced a
monadic state transformer type ST s ff for computations
which transform a state indexed by s and delivers a value of
type ff. To run such state transforming computations, they
provide a term runST with the type 8ff.(8s.ST s ff) ! ff.
Our typing rules for runRGN and newRGN, inspired by that
of runST, use the same parametricity to ensure that computations do not leak any (direct or indirect) references to
deallocated regions.

Launchbury and Sabry [16] argue that the principle behind runST can be generalized to provide nested scope. They
introduce two constants

blockST :: (8fi.ST (ff * fi) o/) ! ST ff o/
importVar :: MutVar ff o/ ! MutVar (ff * fi) o/

where blockST encapsulates a new scope and importVar explicitly allows variables from an enclosing scope to be manipulated by the inner scope. Similarly, Peyton Jones3 suggests
introducing the constant

liftST :: ST ff o/ ! ST (ff * fi) o/
in lieu of importVar, with the same intention of importing
computations from an outer scope into the inner scope. At
first glance, this mechanism seems sufficient for supporting
a translation from a region calculus. However, in the presence of region polymorphism, such an approach proves difficult. The problem is that the explicit connection between
the outer and inner scopes in the product type enforces a
total order on regions. This total order is expressed in the

3private communication

types of region allocated values. Hence, one cannot write
a function polymorphic in the regions ae1 and ae2 and apply
it in all three of the following situations: (a) instantiate ae1
and ae2 with the same region, (b) instantiate ae1 with a region that strictly outlives the region that instantiates ae2, (c)
vice versa. To put it another way, the function doesn't know
what the region stack is going to look like when it is called -
it doesn't know where ae1 and ae2 are relative to each other or
to the top of the stack. Hence, we adopt the approach presented in this paper, where we pass evidence showing that
each of the regions is live.

Finally, we note that Wadler and Thiemann [27] advocate

marrying effects and monads by translating a type o/1 oe-! o/2
to the type T Jo/1K ! Toe T Jo/2K, where Toe o/ represents a
computation that yields a value of type o/ and has effects
delimited by (the set) oe. As with the work of Banerjee et.
al. described above, this introduces a nontrivial theory of

equality (and subtyping) on types; the types Toe o/ and Toe

0 o/

are equal so long as oe and oe0 are (encodings of) equivalent
sets. However, few programming languages allow one to
express such nontrivial equalities between types.

6. CONCLUSIONS AND FUTURE WORK

We have given a type preserving translation from the Single Effect Calculus to FRGN. Both the source and the target
calculi use a static type-system to delimit the effects of allocating in and reading from regions. The Single Effect Calculus uses the partial order implied by the "outlives" relation
on regions to use single regions as bounds for sets of effects.
We feel that this is an important insight that leads to a
relatively straight-forward translation into the monadic setting. FRGN draws from the work on monadic encapsulation
of state to give parametric types to runRGN and newRGN
that prevent access of regions beyond their lifetimes. Explicit functions witness the outlives relationship between regions, enabling computations from outer regions to be cast
to computations in inner regions. Witness functions cannot
be forged and are only introduced via newRGN.

There are numerous directions for future work. Finalizing semantics for both the Single Effect Calculus and FRGN,
proving the type safety of each language, and proving that
the translation preserves the semantics of programs are foremost on our list. Exploring an optimized monad translation is likely to be important here. We are also interested
in mechanisms that relax the notational burden of passing
witness functions, such as type-classes. Finally, as is well
known, Tofte and Talpin's original region calculus can lead
to inefficient memory usage in tail-recursive programs. We
would like to explore whether or not techniques developed
to overcome these problems (e.g., storage analysis and late
allocate/early deallocation analysis) can be adapted to the
monadic setting.

Acknowledgements
Greg Morrisett proposed an initial encoding of regions into
a monadic setting based on the ST monad and discussed the
many refinements leading to the present work. The anonymous referees made a number of helpful suggestions.

7. REFERENCES

[1] Z. Ariola and A. Sabry. Correctness of monadic state:

An imperative call-by-need calculus. In Proceedings of

the 25th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL'98),
pages 62-74, San Diego, CA, 1998. ACM Press.
[2] A. Banerjee, N. Heintze, and J. Riecke. Region

analysis and the polymorphic lambda calculus. In
Proceedings of the 14th IEEE Symposium on Logic in
Computer Science (LCS'99), pages 88-97, Trento,
Italy, 1999. IEEE Computer Society Press.
[3] C. Calcagno. Stratified operational semantics for

safety and correctness of the region calculus. In
Proceedings of the 28th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL'01), pages 155-165, London, England, 2001.
ACM Press.

[4] C. Calcagno, S. Helsen, and P. Thiemann. Syntactic

type soundness results for the region calculus.
Information and Computation, 173(2):199-332, Mar.
2002.
[5] K. Crary, D. Walker, and G. Morrisett. Typed

memory management in a calculus of capabilities. In
Proceedings of the 26th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL'99), pages 262-275. ACM Press, 1999.

[6] M. Elsman. Garbage collection safety for region-based

memory management. In Proceedings of the ACM
SIGPLAN Workshop on Types in Language Design
and Implementation (TLDI'03), pages 123-134, New
Orleans, LA, 2003. ACM Press.
[7] J.-Y. Girard, P. Taylor, and Y. Lafont. Proofs and

Types. Cambridge University Press, 1989.
[8] D. Grossman, G. Morrisett, Y. Wang, T. Jim,

M. Hicks, and J. Cheney. Formal type soundness for
Cyclone's region system. Technical Report 2001-1856,
Department of Computer Science, Cornell University,
Nov. 2001.
[9] N. Hallenberg, M. Elsman, and M. Tofte. Combining

region inference and garbage collection. In Proceedings
of the ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI'02),
pages 141-152. ACM Press, 2002. Berlin, Germany.
[10] S. Helsen and P. Thiemann. Syntactic type soundness

for the region calculus. In Proceedings of the 4th
International Workshop on Higher Order Operational
Techniques in Semantics (HOOTS'00), volume 41 of
Electronic Notes in Theoretical Computer Science,
pages 1-19, Montreal, Canada, Sept. 2000. Elsevier
Science Publishers.
[11] F. Henglein, H. Makholm, and H. Niss. Effect types

and region-based memory management. In B. Pierce,
editor, Advanced Topics in Types and Programming
Languages, chapter 5. MIT Press, 2003. In
preparation.

[12] M. Hicks, G. Morrisett, D. Grossman, and T. Jim.

Safe and flexible memory management in Cyclone.
Technical Report CS-TR-4514, University of Maryland
Department of Computer Science, July 2003.

[13] R. Kieburtz. Taming effects with monadic typing. In

Proceedings of the 3rd ACM SIGPLAN International
Conference on Functional Programming (ICFP'98),
pages 51-62, Baltimore, MD, 1998. ACM Press.
[14] J. Launchbury and S. Peyton Jones. State in Haskell.

Lisp and Symbolic Computation, 8(4):293-341, 1995.

[15] J. Launchbury and S. Peyton Jones. Lazy functional

state threads. In Proceedings of the ACM SIGPLAN
Conference on Programming Language Design and
Implementation (PLDI'94), pages 24-35, Orlando, FL,
1997. ACM Press.

[16] J. Launchbury and A. Sabry. Monadic state:

Axiomatization and type safety. In Proceedings of the
2nd ACM SIGPLAN International Conference on
Functional Programming (ICFP'97), pages 227-237,
Amsterdam, The Netherlands, 1997. ACM Press.
[17] E. Moggi. Computational lambda calculus and

monads. In Proceedings of the 4th IEEE Symposium
on Logic in Computer Science (LCS'89), pages 14-23,
Pacific Grove, CA, 1989.

[18] E. Moggi. Notions of computation and monads.

Information and Computation, 93(1):55-92, Jan. 1991.
[19] E. Moggi and A. Sabry. Monadic encapsulation of

effects: a revised approach (extended version). Journal
of Functional Programming, 11(6):591-627, Nov. 2001.
[20] J. Reynolds. Towards a theory of type structure. In

Programming Symposium, volume 19 of Lecture Notes
in Computer Science, pages 408-425, Paris, France,
Apr. 1974. Springer-Verlag.
[21] J. Riecke and R. Viswanathan. Isolating side effects in

sequential languages. In Proceedings of the 22nd ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL'95), pages 1-12, San
Francisco, CA, 1995. ACM Press.
[22] A. Sabry and P. Wadler. A reflection on call-by-value.

ACM Transactions on Programming Languages and
Systems, 19(6):916-941, Nov. 1997.
[23] M. Semmelroth and A. Sabry. Monadic encapsulation

in ml. In Proceedings of the 4th ACM SIGPLAN
International Conference on Functional Programming
(ICFP'99), pages 8-17, Paris, France, 1999. ACM
Press.
[24] M. Tofte and J.-P. Talpin. Implementation of the

typed call-by-value *-calculus using a stack of regions.
In Proceedings of the 21st ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL'94), pages 188-201, Portland, OR, 1994. ACM
Press.

[25] M. Tofte and J.-P. Talpin. Region-based memory

management. Information and Computation,
132(2):109-176, Feb. 1997.
[26] P. Wadler. The marriage of effects and monads. In

Proceedings of the 3rd ACM SIGPLAN International
Conference on Functional Programming (ICFP'98),
pages 63-74, Baltimore, MD, 1995. ACM Press.
[27] P. Wadler and P. Thiemann. The marriage of effects

and monads. Transactions on Computational Logic,
4(1):1-32, 2003.

APPENDIX
Figures 10 and 11 present simple large-step operational semantics for the Single Effect Calculus and FRGN respectively.
Figures 12 and 13 show the translation of terms not covered
in Figure 8.

We use the following notational conventions in Figure 10:

- * denotes a deallocated region.
- hliae denotes a pointer to a storable in region ae.
- Regions and region stacks that differ only in the order

of their fields are considered identical.
- The expression e[e0/x] denotes the capture-avoiding

substitution of e0 for x in e. Similar capture-avoiding
substitutions are defined for e[ae/%] and w[ae/%].

- Updates of finite maps R are denoted by M{l 7! w}

and updates of finite maps S are denoted by S{% 7! R}.
We abbreviate S{% 7! S(%){l 7! w}} by S{(%, l) 7! w}.

- The notation S - % excludes % from the domain of S.
- The notation S[ae/%] denotes

{%0 7! {l0 7! S(%0, l0)[ae/%]}l02dom(S(%0))}%02dom(S).
We use the following notational conventions in Figure 11:
- * denotes a deallocated region.
- hliae denotes a pointer to a storable in region ae.
- Regions and region stacks that differ only in the order

of their fields are considered identical.
- The expression e[e0/x] denotes the capture-avoiding

substitution of e0 for x in e. Similar capture-avoiding
substitutions are defined for e[ae/r], e[o/ 0/ff], w[ae/r],
w[o/ 0/ff], and o/ [o/ 0/ff].
- Updates of finite maps R are denoted by M{l 7! w}

and updates of finite maps S are denoted by S{r 7! R}.
We abbreviate S{r 7! S(r){l 7! w}} by S{(r, l) 7! w}.

- The notation S - r excludes r from the domain of S.
- The notation S[ae/r] denotes

{r0 7! {l0 7! S(r0, l0)[ae/r]}l02dom(S(r0))}r02dom(S).

l 2 LocsSEC
Places
ffl, ae ::= . . . | *

Terms

e ::= . . . | hliae
Values

v ::= hliae
Storables

w ::= i | *x : o/.ffle | (v1, v2) | *% * ' : o/.fflu

Regions

R ::= {l1 7! w1, . . . , ln 7! wn}
Region stacks

S ::= {%1 7! R1, . . . , %m 7! Rm}

S, e ,! S0, v

l 62 dom(S(%))
S, i at % ,! S{(%, l) 7! i}, hli%

S, e1 ,! S1, hl1i%1 S1(%1, l1) = i1
S1, e2 ,! S2, hl2i%2 S2(%2, l2) = i2

l 62 dom(S2(%))

S, e1 _ e2 at % ,! S2{(%, l) 7! i1 _ i2}, hli%

S, e1 ,! S1, hl1i%1 S1(%1, l1) = i1
S1, e2 ,! S2, hl2i%2 S2(%2, l2) = i2

S, e1 4 e2 at % ,! S2, i1 4 i2

S, tt ,! S, tt S, ff ,! S, ff

S, eb ,! S, tt
S0, et ,! S00, v00

S, if eb then et else ef ,! S00, v00

S, eb ,! S, ff
S0, ef ,! S00, v00

S, if eb then et else ef ,! S00, v00

l 62 dom(S(%))
S, *x : o/.ffle at % ,! S{(%, l) 7! *x : o/.ffle}, hli%

S, e1 ,! S1, hl1i%1
S1(%1, l1) = *x : o/.ffle

S1, e2 ,! S2, v2
S2, e[v2/x] ,! S0, v0

S, e1 e2 ,! S0, v0

S, e1 ,! S1, v1 S1, e2 ,! S2, v2

l 62 dom(S2(%))

S, (e1, e2) at % ,! S2{(%, l) 7! (v1, v2)}, hli%

S, e ,! S0, hli%
S0(%, l) = (v1, v2)

S, fst e ,! S0, v1

S, e ,! S0, hli%
S0(%, l) = (v1, v2)

S, snd e ,! S0, v2

% 62 dom(S) S{% 7! ;}, e ,! S0, v

S, new %.e ,! (S0 - %)[*/%], v[*/%]

l 62 dom(S(%))
S, *%0 * '.fflu at % ,! S{(%, l) 7! *%0 * '.fflu}, hli%

S, e ,! S0, hli%
S(%, l) = *%0 * '.fflu
S0, u[ae/%0] ,! S00, v00

S, e [ae] ,! S00, v00

l 62 dom(S(%))
S, fix f : (o/1 ffl-! o/2, %).*x : o/1.ffle at % ,! S{(%, l) 7! *x : o/1.ffle[hli%/f]}, hli%

l 62 dom(S(%))
S, fix f : (\Pi %0 * '.fflo/, %).*%0 * '.fflu at % ,! S{(%, l) 7! *%0 * '.fflu[hli%/f]}, hli%

p ,! v

{H 7! ;}, p ,! S, v

p ,! v

Figure 10: Single Effect Calculus: Operational Semantics

l 2 LocsFRGN
r 2 (Rname, v)

Types

o/ ::= . . . | ae
Places

ae ::= r | *

Terms

e ::= . . . | handle(ae) | hliae
Commands

^ ::= . . . | witnessRGN [o/a] [ae1] [ae2] v
Values

v ::= . . . | handle(ae) | hliae
Storables

w ::= v

Regions
R ::= {ln 7! wn, . . . , ln 7! wn}
Region stacks

S ::= {rm 7! Rm, . . . , rm 7! Rm}

e ,! v

i ,! i

e1 ,! i1 e2 ,! i2

e1 _ e2 ,! i1 _ i2

e1 ,! i1 e2 ,! i2

e1 4 e2 ,! i1 4 i2 tt ,! tt ff ,! ff

eb ,! tt et ,! v
if eb then et else ef ,! v

eb ,! ff ef ,! v
if eb then et else ef ,! v *x : o/.e ,! *x : o/.e

e1 ,! *x : o/.e0 e2 ,! v e0[v/x] ,! v0

e1 e2 ,! v0 \Lambda ff.e ,! \Lambda ff.e

e ,! \Lambda ff.e0 e0[o//ff] ,! v

e [o/] ,! v

e1 ,! v1 e2 ,! v2

(e1, e2) ,! (v1, v2)

e ,! (v1, v2)

fst e ,! v1

e ,! (v1, v2)

snd e ,! v2

v0 [r] handle(r) ,! ^ {r 7! ;}, ^ ,! S, v0

runRGN [o/a] v ,! v0[*/r] ^ ,! ^ ae ,! ae hliae ,! hliae

S, ^ ,! S0, v

S, returnRGN [r] [o/a] v ,! S, v

S, ^ ,! S0, v0 v v0 ,! ^0 S0, ^0 ,! S00, v00

S, thenRGN [r] [o/a] [o/b] ^ v ,! S00, v00

r 2 dom(S) l 62 dom(S(r))
S, allocRGNVar [o/a] [r] handle(r) w ,! S{(r, l) 7! w}, hlir

r 2 dom(S) l 2 dom(S(r))
S, readRGNVar [o/a] [r] hlir ,! S, S(r, l)

r 2 dom(S) l 62 dom(S(r)) v hlir ,! w

S, fixRGNVar [o/a] [r] r v ,! S{(r, l) 7! w}, hlir

r v r0 r0 /2 dom(S)
v (\Lambda ff.*c : RGN r ff.witnessRGN [ff] [r] [r0] c) handle(r0) ,! ^ S{r0 7! ;}, ^ ,! S0[r0 7! R], v0

S, newRGN [r] [o/a] v ,! S0[*/r0], v0[*/r0]

r1 v r2 S, ^ ,! S0, v
S, witnessRGN [o/a] [r1] [r2] ^ ,! S0, v

Figure 11: FRGN: Operational Semantics

Translations yielding terms (terms)

E`exp uwwv

\Delta ; \Gamma  `exp e1 : (int, ae1), ffl \Delta  `rr ffl * ae1
\Delta ; \Gamma  `exp e2 : (int, ae2), ffl \Delta  `rr ffl * ae2

\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp e1 _ e2 at ae : (int, ae), ffl

""""~

=

bind a : To/ J(int, ae1)K ( E`exp J\Delta ; \Gamma  `exp e1 : (int, ae1), fflK ;
bind a0 : Tu JintK ( E`rr J\Delta  `rr ffl * ae1K [Tu JintK] (readRGNVar [ae1] [Tu JintK] a);
bind b : To/ J(int, ae2)K ( E`exp J\Delta ; \Gamma  `exp e2 : (int, ae2), fflK ;
bind b0 : Tu JintK ( E`rr J\Delta  `rr ffl * ae2K [Tu JintK] (readRGNVar [ae2] [Tu JintK] b);
let i = a0 _ b0 in
E`rr J\Delta  `rr ffl * aeK [To/ J(int, ae)K] (allocRGNVar [ae] [Tu JintK] aeh i) where a, a0, b, b0, i fresh

E`exp uv

\Delta ; \Gamma  `exp e1 : (int, ae1), ffl \Delta  `rr ffl * ae1
\Delta ; \Gamma  `exp e2 : (int, ae2), ffl \Delta  `rr ffl * ae1

\Delta ; \Gamma  `exp e1 4 e2 : bool, ffl ""~

=

bind a : To/ J(int, ae1)K ( E`exp J\Delta ; \Gamma  `exp e1 : (int, ae1), fflK ;
bind a0 : Tu JintK ( E`rr J\Delta  `rr ffl * ae1K [Tu JintK] (readRGNVar [ae1] [Tu JintK] a);
bind b : To/ J(int, ae2)K ( E`exp J\Delta ; \Gamma  `exp e2 : (int, ae2), fflK ;
bind b0 : Tu JintK ( E`rr J\Delta  `rr ffl * ae2K [Tu JintK] (readRGNVar [ae2] [Tu JintK] b);
let i = a0 _ b0 in
returnRGN [ffl] [To/ JboolK] z where a, a0, b, b0, i fresh

E`exp r \Delta ; \Gamma  `exp tt : bool, ffl z = returnRGN [ffl] [To/ JboolK] tt

E`exp r \Delta ; \Gamma  `exp ff : bool, ffl z = returnRGN [ffl] [To/ JboolK] ff

E`exp uv

\Delta ; \Gamma  `exp eb : bool, ffl
\Delta ; \Gamma  `exp et : o/, ffl \Delta ; \Gamma  `exp ef : o/, ffl

\Delta ; \Gamma  `exp if eb then et else ef : o/, ffl ""~

=

bind b : To/ JboolK ( E`exp J\Delta ; \Gamma  `exp eb : bool, fflK ;
if b then E`exp J\Delta ; \Gamma  `exp et : o/, fflK else E`exp J\Delta ; \Gamma  `exp ef : o/, fflK where b fresh

Figure 12: Translation from the Single Effect Calculus to FRGN (Terms (II))

Translations yielding terms (terms)

E`exp uwwv

\Delta ; \Gamma  `exp e1 : o/1, ffl
\Delta ; \Gamma  `exp e2 : o/2, ffl
\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma  `exp (e1, e2) at ae : (o/1 * o/2, ae), ffl

""""~

=

bind a : To/ Jo/1K ( E`exp J\Delta ; \Gamma  `exp e1 : o/1, fflK ;
bind b : To/ Jo/2K ( E`exp J\Delta ; \Gamma  `exp e2 : o/2, fflK ;
E`rr J\Delta  `rr ffl * aeK [To/ J(o/1 * o/2, ae)K] (allocRGNVar [ae] [To/ J(o/1 * o/2, ae)K] aeh (a, b)) where a, b fresh

E`exp s \Delta ; \Gamma  `exp e : (o/1 * o/2, ae), ffl \Delta  `rr ffl * ae\Delta ; \Gamma  `

exp fst e : o/1, ffl - =

bind x : To/ J(o/1 * o/2, ae)K ( E`exp J\Delta ; \Gamma  `exp e : (o/1 * o/2, ae), fflK ;

bind y : Tu Jo/1 * o/2K ( E`rr J\Delta  `rr ffl * aeK [Tu Jo/1 * o/2K] (readRGNVar [ae] [Tu Jo/1 * o/2K] a);
let z = sel1 y in
returnRGN [ffl] [To/ Jo/1K] z where x, y, z fresh

E`exp s \Delta ; \Gamma  `exp e : (o/1 * o/2, ae), ffl \Delta  `rr ffl * ae\Delta ; \Gamma  `

exp snd e : o/2, ffl - =

bind x : To/ J(o/1 * o/2, ae)K ( E`exp J\Delta ; \Gamma  `exp e : (o/1 * o/2, ae), fflK ;

bind y : Tu Jo/1 * o/2K ( E`rr J\Delta  `rr ffl * aeK [Tu Jo/1 * o/2K] (readRGNVar [ae] [Tu Jo/1 * o/2K] a);
let z = sel2 y in
returnRGN [ffl] [To/ Jo/2K] z where x, y, z fresh

E`exp

uwwww
wwwv f 62 dom(\Gamma )

\Delta  `type (o/1 ffl

0-! o/

2, ae)

x 62 dom(\Gamma , f : (o/1 ffl

0-! o/

2, ae)) \Delta  `type o/1

\Delta ; \Gamma , f : (o/1 ffl

0-! o/

2, ae), x : o/1 `exp e : o/2, ffl0

\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma , f : (o/1 ffl

0-! o/

2, ae) `exp *x : o/1.ffl

0e at ae : (o/

1

ffl0-! o/2, ae), ffl

\Delta ; \Gamma  `exp fix f : (o/1 ffl

0-! o/

2, ae).*x : o/1.ffl

0e at ae : (o/

1

ffl0-! o/

2, ae), ffl

""""""
"""~ =

E`rr J\Delta  `rr ffl * aeK To/ s(o/1 ffl

0-! o/

2, ae)-

(fixRGNVar [ae] [Tu so/1 ffl

0-! o/

2-]

aeh (*f : To/ s(o/1 ffl

0-! o/

2, ae)- .*x : To/ Jo/1K .

E`exp s\Delta ; \Gamma , f : (o/1 ffl

0-! o/

2, ae), x : o/1 `exp e : o/2, ffl0-))

E`exp

uwwww
wwv f 62 dom(\Gamma )\Delta  `

type (\Pi % * '.ffl

0 o/, ae)

% 62 dom(\Delta ) \Delta  `eff '
\Delta , % * '; \Gamma , f : (\Pi % * '.ffl

0o/, ae) `

exp u : o/, ffl0

\Delta  `place ae \Delta  `rr ffl * ae

\Delta ; \Gamma , f : (\Pi % * '.ffl

0 o/, ae) `

exp *% * '.ffl

0u at ae : (\Pi % * '.ffl0 o/, ae), ffl

\Delta ; \Gamma  `exp fix f : (\Pi % * '.ffl

0o/, ae).*% * '.ffl0u at ae : (\Pi % * '.ffl0o/, ae), ffl

""""""
""~ =
E`rr J\Delta  `rr ffl * aeK To/ r(\Pi %.ffl

0.o/, ae)z

(fixRGNVar [ae] [Tu r\Pi %.ffl

0o/ z]

aeh (*f : To/ r(\Pi %.ffl

0o/, ae)z .*%w : T

* J% * 'K .*%

h : RGNHandle %.

E`exp r\Delta , % * '; \Gamma , f : (\Pi %.ffl

0o/, ae) `

exp u : o/, ffl0z))

Figure 13: Translation from the Single Effect Calculus to FRGN (Terms (III))