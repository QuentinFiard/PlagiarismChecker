

The marriage of effects and monads
PHILIP WADLER
Avaya Labs
and
PETER THIEMANN
Universit"at Freiburg, Germany

Gifford and others proposed an effect typing discipline to delimit the scope of computational
effects within a program, while Moggi and others proposed monads for much the same purpose.
Here we marry effects to monads, uniting two previously separate lines of research. In particular,
we show that the type, region, and effect system of Talpin and Jouvelot carries over directly to
an analogous system for monads, including a type and effect reconstruction algorithm. The same
technique should allow one to transpose any effect system into a corresponding monad system.

Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions and
Theory; F.3.2 [Logics and meanings of programs]: Semantics of Programming Languages--
Operational semantics

General Terms: Languages, Theory
Additional Key Words and Phrases: monad, effect, type, region, type reconstruction

1. INTRODUCTION
Computational effects, such as state or continuations, are powerful medicine. If
taken as directed they may cure a nasty bug, but one must be wary of the side
effects.

For this reason, many researchers in computing seek to exploit the benefits of
computational effects while delimiting their scope. Two such lines of research are
the effect typing discipline, proposed by Gifford and Lucassen [GL86; Luc87], and
pursued by Talpin and Jouvelot [TJ92; TJ94; Tal93] among others, and the use
of monads, proposed by Moggi [Mog89; Mog91], and pursued by Wadler [Wad90;
Wad92; Wad93; Wad95] among others. Effect systems are typically found in strict
languages, such as FX [GJLS87] (a variant of Lisp), while monads are typically
found in lazy languages, such as Haskell [Has98].

Permission to make digital/hard copy of all or part of this material without fee for personal
or classroom use provided that the copies are not made or distributed for profit or commercial
advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and
notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish,
to post on servers, or to redistribute to lists requires prior specific permission and/or a fee.

cfl 20TBD ACM 1529-3785/20TBD/0700-0001 $5.00 TBDTBD
Permission to make digital/hard copy of all or part of this material without fee for personal
or classroom use provided that the copies are not made or distributed for profit or commercial
advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and
notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish,
to post on servers, or to redistribute to lists requires prior specific permission and/or a fee.

cfl 20TBD ACM 1529-3785/20TBD/0700-0001 $5.00

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD, Pages 1-31.

2 \Delta  P. Wadler and P. Thiemann

In his pursuit of monads, Wadler wrote the following:

. . . the use of monads is similar to the use of effect systems . . . . An
intriguing question is whether a similar form of type inference could
apply to a language based on monads. [Wad92]

Half a decade later, we can answer that question in the affirmative. Goodness
knows why it took so long, because the correspondence between effects and monads
turns out to be surprisingly close.

The marriage of effects and monads. Recall that a monad language introduces
a type T o/ to represent a computation that yields a value of type o/ and may have
side effects. If the call-by-value translation of o/ is o/ y, then we have that (o/ ! o/ 0)y,
where ! represents a function that may have side effects, is equal to o/ y ! T o/ 0y,
where ! represents a pure function with no side effects.

Recall also that an effect system labels each function with its possible effects, so
a function type is now written o/ oe! o/ 0, indicating a function that may have effects
delimited by oe.

The innovation of this paper is to marry effects to monads, writing Toe o/ for a
computation that yields a value in o/ and may have effects delimited by oe. Now we
have that (o/ oe! o/ 0)y is o/ y ! Toe o/ 0y.

The monad translation offers insight into the structure of the original effect system. In the original system, variables and lambda abstractions are labelled with
the empty effect, and applications are labeled with the union of three effects (the
effects of evaluating the function, the argument, and the function body). In the
monad system, effects appear in just two places: the `unit' of the monad, which
is labeled with the empty effect, and the `bind' of the monad, which is labeled
with the union of two effects. The translation of variables and lambda abstractions
introduces `unit', hence they are labeled with an empty effect; and the translation
of application introduces two occurrences of `bind', hence it is labeled with a union
of three effects (each [ symbol in oe [ oe0 [ oe00 coming from one `bind').

Transposing effects to monads. Numerous effect systems have been proposed,
carrying more or less type information, and dealing with differing computational
effects such as state, continuations, or communication [GL86; Luc87; JG89; TJ92;
TJ94; Tal93; NNA97]. Tofte and others propose a system for analysing memory
allocation based on effects [TT94; TB98]. Java contains a simple effect system,
without effect variables, where each method is labeled with the exceptions it might
raise [GJS96].

For concreteness, this paper works with a type, region, and effect system based
on proposals by Talpin and Jouvelot [TJ92; Tal93; TJ94], where effects indicate
which regions of store are initialised, read, or written. Talpin and Jouvelot's results
transpose in a straightforward way to a monad formulation. It seems clear that
other effect systems can be transposed to monads in a similar way.

Applications. In Glasgow Haskell, the monad ST is used to represent computational effects on state [PW93; LP94]. All effects on state are lumped into a single
monad. There is no way to distinguish an operation that reads the store from one
that writes the store, or to distinguish operations that write two distinct regions of

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  3
the store (and hence cannot interfere with each other). The type, region, and effect
system of Talpin and Jouvelot addresses precisely this problem, and the monadbased system described here could be applied directly to augment any particular
instance of the ST monad with effects.

In fact, the letregion construct [TT94; TB98] (which was originally named
private [LG88]) corresponds closely to the runST operator in Glasgow Haskell,
where the index type plays the role of a region. For the one-region case, this
connection has been formalized and proved correct for a simple call-by-value language with runST [SS99]. An alternative approach to monadic encapsulation uses
a constant run with an interesting higher-order type [MP99]. In that approach,
the monadic code is abstracted over the monadic operations, which are provided
through the run constant.

Similarly, in Haskell the monad IO is used to represent all computational effects
that perform input/output [PW93; PH97]. Dialects of Haskell extend this to call
procedures written in other languages [PW93; FLMP99], deal with concurrency
[PGF96], or handle exceptions [PRH+99]. Again, all effects are lumped into a
single monad, and again a variant of the system described here could be used to
augment the IO monad with effects.

Monads labeled with effects can also be applied to optimizing strict languages
such as Standard ML. Whereas Haskell requires the user to explicitly introduce
monads, Standard ML can be regarded as implicitly introducing a monad everywhere, via Moggi's translation from call-by-value lambda calculus into a monadic
metalanguage. The implicit monad of Standard ML incorporates all side effects,
including operations on references and input-output, much like a combination of
Haskell's ST and IO monads. As before, labeling the monad with effects can be
used to delimit the scope of effects. In particular, where the monad is labeled with
the empty effect, the corresponding expression is pure and additional optimizations
may be applied. Or when the monad reads but does not write the store, certain
operations may be commuted. This technique has been applied to intermediate languages for Standard ML compilers by Tolmach [Tol98] and by Benton, Kennedy,
and Russel [BKR98]. Our work can be regarded as complementary to theirs: we
provide the theory and they provide the practice.

Summary of results. Talpin and Jouvelot present (i) a type system with effects,
(ii) a semantics, with a proof that types and effects are consistent with the semantics
(iii) a type and effect reconstruction algorithm, with a proof that it is sound and
complete. We review each of these results, following it by the corresponding result
for the monad system. We also recall the call-by-value translation from lambda
calculus into a monad language, and show that this translation preserves (i) types,
(ii) semantics, and (iii) the principal types derived by the reconstruction algorithms.

By and large, we stick to the notation and formulation of Talpin and Jouvelot
[TJ92; Tal93; TJ94]. However, we differ in a few particulars.

Talpin and Jouvelot [TJ92] use a simplified treatment of the polymorphic binding
let x = v in e. While their type inference algorithm makes use of type schemes,
their correctness proof elides them by assuming that let x = v in e is expanded to
e[x := v]. In contrast, here we use standard type schemes throughout.

In subsequent work [TJ94; Tal93], Talpin and Jouvelot also adopt type schemes

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

4 \Delta  P. Wadler and P. Thiemann
throughout. However, they go beyond the present framework in admitting nonvalues to have polymorphic types. To achieve this goal, they refine effects to also
include the type of the effected reference and have the generalization step only
abstract those variables that are neither mentioned in the type environment nor in
the current effect. In addition, their calculus includes implicit effect masking in the
style of letregion.

Also, Talpin and Jouvelot follow the classic work of Tofte [Tof87], using an
evaluation-style operational semantics (`big step'). In contrast, we follow the approach of Wright and Felleisen [WF94] and use an operational semantics based on
reduction (`small step'). As noted by Wright and Felleisen, this leads to a simpler proof: instead of a complex relation between values and types (specified as
a greatest fixpoint), we can use the existing type relation (specified by structural
induction).

The monad translation we use is standard. It was introduced by Moggi [Mog89;
Mog91], and has been further studied by Hatcliff and Danvy [HD94] and Sabry
and Wadler [SW97]. Our reduction semantics for the monad is new. It most
closely resembles the work of Hatcliff and Danvy, but they did not deal with state
and therefore did not have to distinguish between pure reductions and those with
computational effects, as we do here.

This paper is a revised version of [Wad98]. Changes include the use of type
schemes (as in [TJ94; Tal93]); the use of an optimized monad translation (which
greatly simplifies the proof that the translation preserves the semantics); the introduction of evaluation contexts in the operational semantics (which follows more
closely the development of Wright and Felleisen); and the correction of a some
errors in the original (for instance, rule (get0 ) should not have been included in
Monad).

The results are all obtained by straightforward application of well-known techniques. We do give some proofs to illustrate minor unexpected technical subtleties.
However, in general results for effect systems transpose to monads without much
effort.

Value polymorphism. Some care is required when mixing computational effects
with polymorphic types, lest soundness be forfeit. One approach, due to Tofte
[Tof87] and used in the original SML [MTH90], introduces `imperative' type variables in the presence of computational effects. Numerous other approaches have
been suggested, including some based on effects [Wri92; TJ94]. However, by far
the simplest is value polymorphism. This approach was noted by Tofte [Tof87],
promoted by Leroy [Ler93] and Wright [Wri95], and used in the revised SML
[MTHM97]. It restricts polymorphism to values, a subclass of expressions that
can have no computational effects. Talpin and Jouvelot [TJ92] used value polymorphism, and we do so here.

There is a potential problem. Moggi's original monad translation was monomorphic. How should it be extended to polymorphism? Several years ago Eugenio
Moggi, John Hughes, and Philip Wadler held a discussion where they attempted
to add polymorphism to the translation and failed. However, they did not consider
value polymorphism, which was less popular back then.

In this paper, we extend the monad translation to include value polymorphism.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  5
The extension is presented for the monad system with effects, but applies equally
well when effects are absent. In retrospect, the extension seems obvious, since the
monad translation handles values specially. Indeed, similar uses of value polymorphism have been proposed by Harper and Lillibridge [HL93] (for CPS with call/cc)
and by Barthe, Hatcliff, and Thiemann [BHT98] (for a configurable monadic metalanguage in the style of Pure Type Systems).

One might say that value polymorphism fits monads to a `T'.

Outline. The remainder of this paper is organised as follows. Section 2 introduces
the effect type system and the corresponding type system for monads, it introduces
the monad translation and shows that it preserves types. Section 3 presents an
operational semantics for effects and a corresponding semantics for monads, shows
each semantics sound with respect to types, and shows that the monad translation
preserves semantics. Section 4 presents a type, region, and effect reconstruction
algorithm for effects and a corresponding algorithm for monad, shows each algorithm is sound and complete, and shows that the monad translation relates the two
algorithms. Section 5 concludes.

2. TYPES
This section introduces two languages and their type systems, and the translation
between them. The first language, Effect, is a call-by-value lambda calculus with
operations on a store. Its type system includes regions and effects. The second
language, Monad, is based on Moggi's monadic metalanguage extended with the
same store operations, and with a type system augmented by the same regions and
effects. We extend the usual monad translation to include effects, and show that it
preserves typings.

2.1 Types for Effect
The language Effect and its type system is shown in Figure 1. There are three
syntactic classes, values, non-values, and expressions. A value is either an identifier,
a lambda abstraction, or a recursive function binding. A non-value is either an
application, a polymorphic let binding for values, a monomorphic ilet binding
for expressions with imperative effects, or one of three primitive operations on the
store, which allocate a new reference, get the value of a reference, or set a reference
to a new value. An expression is either a value or a non-value.

A region is either a region variable or a region constant. An effect is either an
effect variable, the empty effect, the union of two effects, or one of three effects
corresponding to the three operations on the store, each of which is labelled with
the region of store affected. Equality on effects is modulo the assumption that [ is
associative, commutative, idempotent, and has ; as a unit. We write oe w oe0 when
oe = oe [ oe0.

A type is either a type variable, a function type (labelled with the effect that
occurs when the function is applied), or a reference type (labelled with the region
in which the reference is located). A type scheme ^o/ has the form 8_ff; _fl; _&:o/ where

_ff; _fl; _& are (possibly empty) sequences of type, region, and effect variables.

A type environment E maps identifiers to type schemes. We write Ex for the
environment with x removed from its domain, fx 7! ^o/ g for the environment that

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

6 \Delta  P. Wadler and P. Thiemann

x 2 Id
v 2 Val v ::= x j *x: e j rec x: *x0: e
n 2 NonVal n ::= e e0 j ilet x = e in e0 j let x = v in e j new e j get e j set e e0
e 2 Exp e ::= v j n

r 2 RegConst
fl 2 RegVar
ae 2 Region ae ::= fl j r
& 2 EffVar
oe 2 Effect oe ::= & j ; j oe [ oe0 j init(ae) j read(ae) j write(ae)

ff 2 TyVar
o/ 2 Type o/ ::= ff j o/ oe! o/ 0 j refae o/

^o/ 2 TyScheme ^o/ ::= 8_ff; _fl; _&:o/

E 2 TyEnv = Id ! TyScheme
` 2 Subst = (TyVar ! Type) \Theta  (RegVar ! Region) \Theta  (EffVar ! Effect)

(var) ^o/ * o/E

x [ fx 7! ^o/ g `eff x : o/ ! ; (does)

E `eff e : o/ ! oe oe0 w oe

E `eff e : o/ ! oe0

(abs) Ex [ fx 7! o/ g `eff e : o/

0 ! oe

E `eff *x: e : o/ oe! o/ 0 ! ; (app)

E `eff e : o/ oe

00! o/ 0 ! oe E `

eff e0 : o/ ! oe0
E `eff e e0 : o/ 0 ! oe [ oe0 [ oe00

(let) E `eff v : o/ ! ; Ex [ fx 7! gen(E; o/ )g `eff e : o/

0 ! oe

E `eff let x = v in e : o/ 0 ! oe

(ilet) E `eff e : o/ ! oe Ex [ fx 7! o/ g `eff e

0 : o/ 0 ! oe0

E `eff ilet x = e in e0 : o/ 0 ! oe [ oe0

(rec) Ex;x

0 [ fx 7! o/ oe! o/ 0; x0 7! o/ g `eff e : o/ 0 ! oe

E `eff rec x: *x0: e : o/ oe! o/ 0 ! ;

(new) E `eff e : o/ ! oeE `

eff new e : refae o/ ! oe [ init(ae)

(get) E `eff e : refae o/ ! oeE `

eff get e : o/ ! oe [ read(ae) (set)

E `eff e : refae o/ ! oe E `eff e0 : o/ ! oe0

E `eff set e e0 : o/ ! oe [ oe0 [ write(ae)

Fig. 1. The effect calculus, Effect

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  7
e 2 MonExp e ::= x j *x: e j rec x: e j e e0 j let x = e in e0

j !e? j let x ( e in e0 j new e j get e j set e e0

o/ 2 MonType o/ ::= ff j o/ ! o/ 0 j Toe o/ j refae o/

^o/ 2 MonTyScheme ^o/ ::= 8_ff; _fl; _&:o/

E 2 MonTyEnv = Id ! MonTyScheme
` 2 Subst = (TyVar ! MonType) \Theta  (RegVar ! Region) \Theta  (EffVar ! Effect)

(var) ^o/ * o/E

x [ fx 7! ^o/ g `mon x : o/ (does)

E `mon e : Toe o/ oe0 w oe

E `mon e : Toe

0 o/

(abs) Ex [ fx 7! o/ g `mon e : o/

0

E `mon *x: e : o/ ! o/ 0 (app)

E `mon e : o/ ! o/ 0 E `mon e0 : o/

E `mon e e0 : o/ 0

(let) E `mon e : o/ Ex [ fx 7! gen(E; o/ )g `mon e

0 : o/ 0

E `mon let x = e in e0 : o/ 0

(unit) E `mon e : o/E `

mon !e? : T; o/ (bind)

E `mon e : Toe o/ Ex [ fx 7! o/ g `mon e0 : Toe

0 o/ 0

E `mon let x ( e in e0 : Toe[oe

0 o/ 0

(rec) Ex [ fx 7! o/g `mon e : o/E `

mon rec x: e : o/ (new)

E `mon e : o/
E `mon new e : Tinit(ae) refae o/

(get) E `mon e : refae o/E `

mon get e : Tread(ae) o/ (set)

E `mon e : refae o/ E `mon e0 : o/

E `mon set e e0 : Twrite(ae) o/

Fig. 2. The monad language, Monad

maps identifier x to type scheme ^o/ , E [ E0 for the union of two maps with disjoint
domains, and E ' E0 when the first map contains the second. Similar notation will
be used later for substitutions and stores.

We write free(o/ ), free(^o/ ) and free(E) for the set of free type, region, and effect
variables in a type, type scheme, or type environment. We write e[x := v] for the
capture-avoiding substitution of value v for variable x in expression e, and we write
free(e) for the free identifiers of an expression.

We define generic instances and generalization in the usual way. A substitution
` maps type variables to types, region variables to regions, and effect variables to
effects. We say that type scheme ^o/ 0 is a generic instance of the type scheme ^o/ ,
written ^o/ * ^o/ 0, if ^o/ = 8_ff; _fl; _&:o/ and ^o/ 0 = 8_ff0; _fl0; _&0:o/ 0 and there is a substitution

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

8 \Delta  P. Wadler and P. Thiemann
` such that o/ 0 = `o/ , where the domain of ` is restricted to the free variables of o/
(that is, dom(`) = f_ff; _fl; _&g) and the bound variables of ^o/ 0 are not free in ^o/ (that
is, f_ff0; _fl0; _&0g " free(^o/ ) = ;). We say that type scheme ^o/ is the generalization of
type o/ with respect to environment E, written ^o/ = gen(E; o/ ), if ^o/ = 8_ff; _fl; _&:o/ where
f_ff; _fl; _&g = free(o/ ) n free(E).

A typing E `eff e : o/ ! oe indicates that expression e yields a value of type o/ and
has effect delimited by oe, where the type environment E maps the free identifiers
of e to types.

In the rule for abstraction, (abs), the effect is empty because evaluation immediately returns the function, with no side effects. The effect on the function arrow
is the same as the effect for the function body, because applying the function will
have the same side effects as evaluating the body. In the rule for application, (app),
the effect is the union of the effects for evaluating the function, evaluating the
argument, and applying the function.

Each let binding construct comes with its own typing rule. Rule (let) handles
polymorphic let binding of values, and rule (ilet) handles monomorphic ilet binding of expressions with imperative effects. Rules (let) and (var) use type schemes
in the usual way.

Rule (does) permits a form of subeffecting. Effects indicate an upper bound on the
side effects an expression may have, and so may always be made larger. The rules
for the three primitive operations, (new), (get), and (set), add the corresponding
effect to the effects for their arguments. The region in the effect matches the region
in the reference type.

The following lemmas are standard results for type and effect systems. They
state that syntactic values have no effects and that substitution of values preserves
typing. Their proofs are straightforward.

Lemma 2.1. (Values are pure) If E `eff v : o/ ! oe then E `eff v : o/ ! ;.
Lemma 2.2. (Value substitution) Let E = Ex [ fx 7! o/ g. If E `eff e : o/ 0 ! oe and
E `eff v : o/ ! ; then E `eff e[x := v] : o/ 0 ! oe.

2.2 Types for Monad
Whereas Effect is a call-by-value language, with side effects occuring when any
expression is evaluated, Monad is a call-by-name language, with side effects occuring
only at top-level. All computations with side effects are represented by the new
monad type.

We use call-by-name for monads to stress the relation to Haskell. Like Plotkin's
CPS translation, the image of Moggi's monad translation is indifferent: it delivers
identical results regardless whether the monad language uses call-by-value or callby-name [Plo75; HD94; SW97].

The language Monad and its type system is shown in Figure 2. The distinction
between values and expressions is no longer relevant for polymorphism, since evaluation has no side effects. However, there are monad values which serve as results of
a computation in Monad. Expressions are extended with two new forms for manipulating monads (we describe these shortly). Regions and effects are as before. The

function type o/ oe! o/ 0 of before is here broken into the pure function type o/ ! o/ 0,
and the monad type Toe o/ , representing a computation that yields a value of type o/

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  9
and has effects delimited by oe.

The monad unit !e? denotes the computation that immediately returns the
value of e, with no effects. Hence in (unit) the effect is empty. The monad bind
let x ( e in e0 denotes the computation that first performs computation e, binds
x to the result, and then performs computation e0. Hence in (bind) the effect is the
union of the effects of its two subcomputations. (The forms !e? and let x ( e in e0
are written in Haskell as return e and e ??= *x: e0, respectively.)

Polymorphic binding let x = e in e0 is distinct from monad bind. Since expressions have no side effects, there is no need to restrict polymorphism to values. The
remaining rules are straightforward adjustments of the previous forms. The three
primitive operations, since they involve computational effects, have monad types.

2.3 The translation
Figure 3 shows the translation from Effect to Monad. It is a typed call-by-value
monad translation, similar to the standard translation given by Sabry and Wadler
[SW97]. The translation given here is optimized so as not to introduce certain
`administrative' redexes. Although this makes the translation more complex, it
simplifies the proof (to be given in the next section) that the translation preserves
the semantics.

We write o/ y for the translation of a type, vy for the translation of a value, e\Lambda  for
the translation of an expression, and Ey for the translation of a type environment.

As is well known, the monad translation preserves typing, a property that continues hold for our systems with effects.

Proposition 2.3. (Translation preserves types)
--If E `eff v : o/ ! ; then Ey `mon vy : o/ y.
--If E `eff e : o/ ! oe then Ey `mon e\Lambda  : Toe o/ y.

The proof is by induction on the structure of type derivations.

The translation of let works out neatly thanks to value polymorphism. Whereas
the translation of an expression is in a monad, and so must be bound with the nonpolymorphic monad bind, the translation of a value is not in a monad, and can
safely be bound with the polymorphic let.

The figure also shows the grammar of expressions and types in Monad that are in
the image of the translation from values, expressions (after closure under reduction),
and types in Effect. In the image, application always has some translated value for
function and argument, ordinary let always binds to a translated value, and monad
unit always contains a translated value.

3. SEMANTICS
This section presents operational semantics of the two languages. The reduction
system for Effect is standard, save for instrumentation to trace operations on the
store, which is used to demonstrate consistency between semantics and effects. The
reduction system for Monad appears to be new, even without the instrumentation.
It resembles that of Hatcliff and Danvy [HD94], but differs in distinguishing two
sorts of reductions, those that may have side effects and those that do not. For both
effects and monads, we show that the type and effect system is sound, modifying the

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

10 \Delta  P. Wadler and P. Thiemann

ffy j ff
(o/ oe! o/ 0)y j o/ y ! Toe o/ 0y

(refae o/ )y j refae o/ y
(8_ff; _fl; _&:o/)y j 8_ff; _fl; _&:o/ y

xy j x
(*x: e)y j *x: e\Lambda 
(rec x: *x0: e)y j rec x: *x0: e\Lambda 

v\Lambda  j !vy?
(n e)\Lambda  j let x ( n\Lambda  in (x e)\Lambda 
(v n)\Lambda  j let x ( n\Lambda  in (v x)\Lambda 
(v v0)\Lambda  j vy v0y
(let x = v in e)\Lambda  j let x = vy in e\Lambda 
(ilet x = e in e0)\Lambda  j let x ( e\Lambda  in e0\Lambda 

(new n)\Lambda  j let x ( n\Lambda  in (new x)\Lambda 

(new v)\Lambda  j new vy
(get n)\Lambda  j let x ( n\Lambda  in (get x)\Lambda 

(get v)\Lambda  j get vy
(set n e)\Lambda  j let x ( n\Lambda  in (set x e)\Lambda 
(set v n)\Lambda  j let x ( n\Lambda  in (set v x)\Lambda 
(set v v0)\Lambda  j set vy v0y

(x1 : o/1; : : : ; xn : o/n)y j x1 : o/ y1 ; : : : ; xn : o/ yn

.v 2 TranVal .v ::= x j *x: .e j rec x: *x0: .e
.e 2 TranExp .e ::= .v .v0 j let x = .v in .e j ! .v? j let x ( .e in .e0

j new .v j get .v j set .v .v0

.o/ 2 TranType .o/ ::= ff j .o/ ! Toe .o/ 0 j refae .o/

Fig. 3. Translation from Effect to Monad

results of Wright and Felleisen [WF94] to take effects and monads into account. We
also show that the translation preserves semantics, in that it preserves instrumented
reduction.

3.1 Semantics for Effect
The operational semantics for Effect is shown in Figure 4. Locations l are a designated subset of the variables. By convention, a location is never used as the bound
variable in a lambda or let expression. A store s maps locations to values. A trace
f is the semantic equivalent of an effect, where regions are replaced by locations.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  11
l 2 Location ` Id
s 2 Store = Location ! Value
f 2 Trace f ::= ; j f [ f 0 j init(l) j read(l) j write(l)

EvaluationContext E ::= [ ] j E e j v E j ilet x = E in e

j new E j get E j set E e j set v E

(beta) s; (*x: e)v ;\Gamma !eff s; e[x := v]
(rec) s; (rec x: *x0: e)v ;\Gamma !eff s; (*x0: e[x := rec x: *x0: e])v
(letv) s; let x = v in e ;\Gamma !eff s; e[x := v]
(let) s; ilet x = v in e ;\Gamma !eff s; e[x := v]
(new) s; new v init(l)\Gamma ! eff s [ fl 7! vg; l fresh l 62 dom(s)
(get) sl [ fl 7! vg; get l read(l)\Gamma ! eff sl [ fl 7! vg; v
(set) sl [ fl 7! vg; set l v0 write(l)\Gamma ! eff sl [ fl 7! v0g; v0

(context) s; e

f\Gamma !

eff s0; e0

s; E[e] f\Gamma !eff s0; E[e0] (step)

s; e f\Gamma !eff s0; e0
s; e f\Gamma !\Gamma !eff s0; e0

(refl) s; e ;\Gamma !\Gamma !

eff s; e (tran)

s; e f\Gamma !\Gamma !eff s0; e0 s0; e0 f

0\Gamma !\Gamma !

eff s00; e00

s; e f[f

0\Gamma !\Gamma !

eff s00; e00

Fig. 4. Semantics for Effect

If l 62 dom(s), we write s [ fl 7! vg for the store that maps location l to value v
and otherwise behaves like s. We let sl range over stores that do not bind l, that
is, l 62 dom(sl).

An evaluation state is a pair s; e where all free variables of e are locations in
s (free(e) ` dom(s)) and the same holds for all stored values (8l 2 dom(s),

free(s(l)) ` dom(s)). A single reduction step is written s; e f\Gamma !eff s0; e0, where
s; e is the state before the step, f is a trace of the effect of the step, and s0; e0 is the
state after the step.

Rule (beta) specifies function application; the language Effect is call-by-value as
the argument must be a value for the rule to apply. The rule leaves the store
unchanged and is labeled with an empty effect. Rules (rec) and (let) are similar.
Rules (new), (get), and (set) perform actions on the store and have corresponding
effects. Rule (context) forms the contextual closure of reduction with respect to
evaluation contexts. An evaluation context E is an expression with a hole in place of

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

12 \Delta  P. Wadler and P. Thiemann

l 2 Location ` Id
s 2 Store = Location ! MonExp

Monad context M ::= [ ] j let x ( M in e
Operator context O ::= [ ] j get [ ] j set [ ] e
Pure context P ::= [ ] j P e

(beta) (*x: e0)e \Gamma !mon e0[x := e]
(rec) rec x: e \Gamma !mon e[x := rec x: e]
(let) let x = e in e0 \Gamma !mon e0[x := e]
(bind) s; let x ( !e? in e0 ;\Gamma !mon s; e0[x := e]
(new) s; new e init(l)\Gamma ! mon s [ fl 7! eg; !l? fresh l 62 dom(s)
(get) sl [ fl 7! eg; get l read(l)\Gamma ! mon sl [ fl 7! eg; !e?
(set) sl [ fl 7! eg; set l e0 write(l)\Gamma ! mon sl [ fl 7! e0g; !e0?

(monad) s; e

f\Gamma !

mon s0; e0

s; M [e] f\Gamma !mon s0; M [e0] (operator)

e \Gamma !mon e0
s; O[e] ;\Gamma !mon s; O[e0]

(pure) e \Gamma !mon e

0

P [e] \Gamma !mon P [e0] (step)

s; e f\Gamma !mon s0; e0

s; e f\Gamma !\Gamma !mon s0; e0

(refl) s; e ;\Gamma !\Gamma !

mon s; e (tran)

s; e f\Gamma !\Gamma !mon s0; e0 s0; e0 f

0\Gamma !\Gamma !

mon s00; e00

s; e f[f

0\Gamma !\Gamma !

mon s00; e00

Fig. 5. Semantics for Monad

the next sub-expression to be evaluated. Defining E ::= [ ] j E e j v E j : : : specifies
the order of evaluation, since the function in an application must be reduced to a
value before the argument is elegible for reduction. The handling of the operations

on the store is similar. Finally, rules (step), (refl ), and (tran) specify f\Gamma !\Gamma !eff as the
reflexive and transitive closure of f\Gamma !eff .

There are additional judgements to relate stores to type environments, and traces
to effects. Write E `eff s if dom(s) = dom(E) and, for each l 2 dom(s), if E(l) =
refae o/ then E `eff s(l) : o/ ! ;. Write E j=eff f ! oe if

for each init(l) in f we have E(l) = refae o/ and init(ae) v oe,
ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  13
for each read(l) in f we have E(l) = refae o/ and read(ae) v oe,
for each write(l) in f we have E(l) = refae o/ and write(ae) v oe.

Write E `eff s; e : o/ ! oe if s; e is an evaluation state and E `eff s and E `eff e : o/ ! oe.
Reduction preserves types and is consistent with effects.

Proposition 3.1. (Subject reduction)
If E `eff s; e : o/ ! oe and s; e f\Gamma !eff s0; e0 then there exists some E0 ' E such that
E0 `eff s0; e0 : o/ ! oe and E0 j=eff f ! oe.

The proof is by case analysis on the definition of s; e f\Gamma !eff s0; e0.

The form of a value is determined by its type.

Lemma 3.2. (Canonical forms)
Let s; v be an evaluation state and E `eff s; v : o/ ! ;.

(1 ) If o/ = o/ 0 oe! o/ 00 then v is either *x: e or rec x: *x0: e.
(2 ) If o/ = refae o/ then v is a location l 2 dom(s).

The proof is by case analysis on o/.

A well-typed evaluation state is never stuck.

Proposition 3.3. (Progress)
Suppose E `eff s; e : o/ ! oe. Either e is a value or there exists s0; e0 and f such that

s; e f\Gamma !eff s0; e0.

The proof is by induction on the derivation of E `eff s; e : o/ ! oe. The complete proof
is given in Appendix A.1.

Write s; e *feff if there is an infinite reduction

s; e f

0\Gamma !eff s1; e1 f1\Gamma !eff s2; e2 f2\Gamma !eff \Delta  \Delta  \Delta 

with f = S fi. Then we have the following.

Proposition 3.4. (Type soundness)
If E `eff s; e : o/ ! oe then there exists E0 ' E so that either

--s; e *feff and E0 j=eff f ! oe, or
--s; e f\Gamma !\Gamma !eff s0; v and E0 `eff s0; v : o/ ! ; and E0 j=eff f ! oe.
Type soundness is an immediate corrollary of progress.

It is interesting to consider which expressions would give problems during evaluation. An evaluation state s; e is stuck if e is not a value and there is no f; s0; e0

such that s; e f\Gamma !eff s0; e0. A simple case analysis shows that a state is stuck if and
only if it has one of the following forms:

e = E[v v0], where v is a location,
e = E[get v], where v is not a location or v =2 dom(s), or
e = E[set v v0], where v is not a location or v =2 dom(s).

Stuck expressions are not typable.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

14 \Delta  P. Wadler and P. Thiemann
3.2 Semantics for Monad
Figure 5 shows the operational semantics for Monad. Locations and traces are as
before, but a store now maps locations to expressions. There are two notions of
reduction.

Pure reductions do not access the store and have no effect. They are written
e \Gamma !mon e0. Rule (beta) specifies function application; the language Monad is callby-name as the argument need not be a value for the rule to apply. The rule is
pure and makes no reference to the store. Rules (rec) and (let) are similar.

Monadic reductions perform sequencing and execute the operations on the store.

They may have an effect and are written s; e f\Gamma !mon s; e0. Rule (bind ) simplifies a
monadic bind of a monadic unit; it leaves the store unchanged and is labeled with
an empty effect. (But it is not a pure operation: this prevents reduction of ill-typed
expressions such as (let x ( !(*y: y)? in x)z, where the monadic expression is not
at top-level.) Rules (new), (get), and (set) perform actions on the store and have
corresponding effects.

There are three sorts of contexts, monad contexts M , operator contexts O, and
pure contexts P , and three corresponding context rules. Rule (monad) forms
the contextual closure of monadic reductions over monadic reductions through a
monad context M ; rule (operator ) forms the contextual closure of monadic reductions over pure reductions through an operator context O; and rule (pure)
forms the contextual closure of pure reductions over pure reductions through a
pure context P . (These rules permit reduction of sensible expressions such as
(*y: let x ( !y? in x)z, where an application yields a monadic expression at toplevel.) Since the monad language is call-by-name, pure contexts do not reduce the
argument of a function. Since expressions, not values, are placed in the store, operator contexts neither reduce the argument of new nor the second argument of
set.

As before, rules (step), (refl ), and (tran) specify f\Gamma !\Gamma !mon as the reflexive and

transitive closure of f\Gamma !mon. The relations E `mon s, E `mon s; e : o/ , and E j=mon
f ! oe are defined, mutatis mutandis, as for Effect.

As before, reduction preserves types and is consistent with effects.

Proposition 3.5. (Subject reduction)
--If E `mon e : o/ and e \Gamma !mon e0 then E `mon e0 : tau.
--If E `mon s; e : Toe o/ and s; e f\Gamma !mon s0; e0 then there exists some E0 ' E such that

E0 `mon s0; e0 : Toe o/ and E0 j=mon f ! oe.

The proof is by induction on the definitions of e \Gamma !mon e0 and s; e f\Gamma !mon s0; e0.

We define values for the calculus Monad as follows.

v 2 MonVal v ::= l j *x: e j !e?.
As before, the form of a value is determined by its type.

Lemma 3.6. (Canonical forms) Let s; v be an evaluation state and E `mon s; v :
o/ .

(1 ) If o/ = o/ 0 ! o/ 00 then v = *x: e.
ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  15
(2 ) If o/ = Toe o/ 0 then v = !e?.
(3 ) If o/ = refae o/ then v = l 2 Location and l 2 dom(s).

The proof is by case analysis on o/.

As before, a well-typed evaluation is never stuck.

Proposition 3.7. (Progress) Suppose that E `mon s; e : o/ . Then either e 2
MonVal or there exist f; s0; e0 such that s; e f\Gamma !mon s0; e0.
The proof is by induction on the derivation of E `eff s; e : o/ ! oe.

As before, type soundness is an immediate corrollary of progress.

Proposition 3.8. (Type soundness) If E `mon s; e : o/ then there exists E0 ' E
so that either

--s; e *fmon and E0 j=mon f ! oe, or
--s; e f\Gamma !\Gamma !mon s0; v and E0 `mon s0; v : o/ and E0 j=mon f ! oe.
In both cases, if o/ = Toe

0 o/ 0 then oe = oe0, otherwise oe = ;.

As before, it is interesting to consider which expressions would give problems
during evaluation. Now an evaluation state s; e is stuck if one of the following
conditions holds:

e = M [O[P [v e]]], where v is not a lambda,
e = M [let x ( v in e], where v is not a monad unit,
e = M [get v], where v is not a location or v =2 dom(s),
e = M [set v e], where v is not a location or v =2 dom(s).

Again, stuck expressions are not typable.

3.3 Translation
It is well known that the monad translation preserves semantics, and this property
continues to hold for the instrumented semantics. A key to the correspondence is
that if a term in Effect is translated to Monad then the resulting term has subterms
of the form e0 e or ilet x = e in e0 or !e? only when e is the image of an Effectvalue, that is, only when e has the form .v.

If s is a store in Effect, then we write sy for the corresponding store in Monad,
where sy(l) = (s(l))y for each l 2 dom(s).

Translation commutes with substitution of Effect-values.

Lemma 3.9. For all e 2 Exp and v 2 Val, e\Lambda [x := vy] = (e[x := v])\Lambda .
Formally, preservation of semantics corresponds to a simulation result between
Effect and Monad. The reduction of a term in Effect runs almost in lock-step
with the reduction of its image in Monad. Sometimes an additional administrative
reduction is required. For instance, consider a reduction in Effect,

n v0 f\Gamma !eff v v0
where n\Lambda  f\Gamma !mon vy (disregarding the store component for simplicity). The image
of this reduction in Monad is given by

(n v0)\Lambda  = let x ( n\Lambda  in x v0y f\Gamma !mon let x ( !vy? in x v0y \Gamma !mon vy v0y = (v v0)\Lambda 

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

16 \Delta  P. Wadler and P. Thiemann
which requires one extra administrative reduction. Hence, each reduction in Effect
gives rise to one or two corresponding reductions in Monad.

Another peculiarity arises in the translation of stuck terms. Given a stuck term
in Effect, its image in Monad can sometimes perform one reduction step before it
gets stuck, too. This is a consequence of translating the call-by-value recursion
operator in Effect to a call-by-name recursion operator in Monad. If the original
term is stuck because of some rec x: *x0: e, then the translated term must unwind
the recursion once before it becomes stuck, too.

Proposition 3.10. (Translation preserves semantics)

(1 ) If s; e f\Gamma !eff s0; e0 then either sy; e\Lambda  f\Gamma !mon s0y; e0\Lambda , or sy; e\Lambda  f\Gamma !mon s0y; e0 and

e0 \Gamma !mon e0\Lambda .

(2 ) If s; e f\Gamma !\Gamma !eff s0; e0 then sy; e\Lambda  f\Gamma !\Gamma !mon s0y; e0\Lambda .
(3 ) If s; e *feff then sy; e\Lambda  *fmon.
(4 ) If s; e is stuck then either sy; e\Lambda  is stuck or e\Lambda  \Gamma !mon e0 where sy; e0 is stuck.

The proofs of 1 and 4 are by induction on the definitions of f\Gamma !eff, and the proofs of
2 and 3 are by induction on f\Gamma !\Gamma !eff . The complete proofs are given in Appendix A.2.

As mentioned in the previous section, the proof is considerably simplified by the
use of an optimizing translation. The non-optimized translation introduces many
additional administrative redexes, which obscure the correspondence between the
effect and monad systems.

Another choice which simplifies the proof is the use of two syntactically distinct
forms for let, a polymorphic let binding of values and a monomorphic let binding
of expressions with imperative effects. Without this distinction, it is still possible
to obtain a simulation result, but at the price of a contrived monad translation.

Note that the image of the translation does not include all possible stuck expressions in Monad. In particular, the P context is always trivial because the
monad translation moves computations out of the argument positions. The monad
translation also guarantees that the reduction (bind ) never gets stuck.

4. TYPE RECONSTRUCTION
This section presents type, region, and effect reconstruction algorithms for the two
languages. The reconstruction algorithm for Effect, due to Talpin and Jouvelot,
closely resembles Milner's original type reconstruction algorithm [Mil78]. Effects
are handled by accumulating a set of constraints, similar to the handling of subtypes
in Mitchell's inference algorithm [Mit91]. It is straightforward to transpose the
reconstruction algorithm from Effect to Monad. Both algorithms are sound and
complete, and typings yielded by the two algorithms are related by the translation
between the two languages.

4.1 Unification
A substitution maps type variables to types, region variables to regions, and effect
variables to effects. The substitution id is the identity substitution. Substitutions
and the unification algorithms for Effect are shown in Figure 6, and the modifications for Monad are shown in Figure 7.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  17
` 2 Subst = (TyVar ! Type) \Theta  (RegVar ! Region) \Theta  (EffVar ! Effect)

Ueff (ff; ff0) = fff 7! ff0g

Ueff (ff; o/ ) = if ff 2 free(o/ ) then fail else fff 7! o/ g

Ueff (o/; ff) = Ueff(ff; o/ )
Ueff(o/0 &! o/1; o/ 00 &

0! o/ 0

1) = let ` = f& 7! &0g`0 = U

eff(`o/0; `o/ 00)
`00 = Ueff(`0`o/1; `0`o/ 01)

in `00`0`

Ueff(reffl o/; reffl0 o/ 0) = let ` = ffl 7! fl0g

`0 = Ueff(`o/; `o/ 0)
in `0`

Ueff (\Gamma ; \Gamma ) = fail

Fig. 6. Unification of Effect Types

` 2 Subst = (TyVar ! MonType) \Theta  (RegVar ! Region) \Theta  (EffVar ! Effect)

Umon(o/0 ! o/1; o/ 00 ! o/ 01) = let ` = Umon(o/0; o/ 00)

`0 = Umon(`o/1; `o/ 01)
in `0`

Umon(T& o/; T&

0 o/ 0) = let ` = f& 7! &0g

`0 = Umon(`o/; `o/ 0)
in `0`

Fig. 7. Changes to the unification algorithm for Monad

^ 2 Constraint = ""(EffVar \Theta  Effect)
_ 2 EffModel = EffVar ! Effect

K(;) = id
K(f& w oeg [ ^) = let _ = K(^) in f& 7! & [ _(oe)g ffi _

Fig. 8. Constraints

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

18 \Delta  P. Wadler and P. Thiemann

! 2 V ar = TyVar + RegVar + EffVar

^o/ 2 TyScheme ^o/ ::= 8_!: (o/; ^)
E 2 TyEnv = Id ! TyScheme

Ieff(E; ^; x) = let new _!0

8_!: (o/; ^0) = E(x)
` = f_! 7! _!0g
in hid; `o/; ;; ^ [ `^0i

Ieff(E; ^; *x: e) = let new ff; &

h`; o/; oe; ^0i = Ieff(Ex [ fx 7! ffg; ^; e)
in h`; `ff &! o/; ;; ^0 [ f& w oegi

Ieff(E; ^; rec x: *x0: e) = let new ff; ff0; &

h`; o/; oe; ^0i = Ieff(Ex;x0 [ fx 7! ff &! ff0; x0 7! ffg; ^; e)
`0 = Ueff (`ff0; o/ )
in h`0`; `0`(ff &! ff0); ;; `0(^0 [ f`& w oeg)i

Ieff (E; ^; e e0) = let new ff; &

h`; o/; oe; ^0i = Ieff(E; ^; e)
h`0; o/ 0; oe0; ^00i = Ieff(`E; ^0; e0)
`00 = Ueff(`0o/; o/ 0 &! ff)
in h`00`0`; `00ff; `00(`0oe [ oe0 [ &); `00^00i

Ieff(E; ^; let x = v in e) = let h`; o/; ;; ^0i = Ieff(E; ^; v)

_! = (free(K(^0)o/ )) n free(K(^0)`E)
^00 = f& w oe 2 ^0 j & 2 _!g
^000 = ^0 n ^00
h`0; o/ 0; oe; ^0000i = Ieff (`Ex [ fx 7! 8_!: (o/; ^00)g; ^000; e)
in h`0`; o/ 0; oe; ^0000i

Ieff (E; ^; ilet x = e in e0) = let h`; o/; oe; ^0i = Ieff(E; ^; e)

h`0; o/ 0; oe0; ^00i = Ieff(`Ex [ fx 7! o/ g; ^0; e)
in h`0`; o/ 0; oe [ oe0; ^00i

Initial type environment
E(new) = 8ff; fl; &: (ff &! reffl ff; f& w init(fl)g)
E(get) = 8ff; fl; &: (reffl ff &! ff; f& w read(fl)g)

E(set) = 8ff; fl; &; &0: (reffl ff &! ff &

0! ff; f&0 w

write(fl)g)

Fig. 9. Type reconstruction for Effect

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  19
Imon(E; ^; x) = let new _!0

8_!: (o/; ^0) = E(x)
` = f_! 7! _!0g
in hid; `o/; ^ [ `^0i

Imon(E; ^; *x: e) = let new ff

h`; o/; ^0i = Imon(Ex [ fx 7! ffg; ^; e)
in h`; `ff ! o/; ^0i

Imon(E; ^; rec x: e) = let new ff

h`; o/; ^0i = Imon(Ex [ fx 7! ffg; ^; e)
`0 = Umon(`ff; o/ )
in h`0`; `0o/; `0^0i

Imon(E; ^; e e0) = let new ff

h`; o/; ^0i = Imon(E; ^; e)
h`0; o/ 0; ^00i = Imon(`E; ^0; e0)
`00 = Umon(`0o/; o/ 0 ! ff)
in h`00`0`; `00ff; `00^00i

Imon(E; ^; let x = e in e0) = let h`; o/; ^i = Imon(E; ^; e)

_! = (free(K(^0)o/ )) n free(K(^0)`E)
^00 = f& w oe 2 ^0 j & 2 _!g
^000 = ^0 n ^00
h`0; o/ 0; ^0000i = Imon(`Ex [ fx 7! 8_!: (o/; ^)g; ^000; e0)
in h`0`; o/ 0; ^0000i

Imon(E; ^; !e?) = let new &

h`; o/; ^0i = Imon(E; ^; e)
in h`; T& o/; ^0i

Imon(E; ^; let x ( e in e0) = let new ff; ff0; &; &0; &00

h`; o/; ^0i = Imon(E; ^; e)
`0 = Umon(o/; T& ff)
h`00; o/ 0; ^00i = Imon(E [ fx 7! `0ffg; `0^0; e0)
`000 = Umon(o/ 0; T&

0 ff0)

in h`000`00`0`; T&

00 `000ff0; `000(^00 [ f&00 w `00`0& [ &0g)i

Initial type environment
E(new) = 8ff; fl; &: (ff ! T& reffl ff; f& w init(fl)g)
E(get) = 8ff; fl; &: (reffl ff ! T& ff; f& w read(fl)g)
E(set) = 8ff; fl; &0: (reffl ff ! ff ! T&

0 ff; f&0 w write(fl)g)

Fig. 10. Type reconstruction for Monad

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

20 \Delta  P. Wadler and P. Thiemann

A key trick in the reconstruction algorithm is to ensure that all effects and regions
are represented by variables, to simplify unification. A type, type scheme, type
environment, or substitution is normalised if the only regions and effects it contains
are variables. (This notion is also present in the work of Talpin and Jouvelot, but
only implicitly.)

The unification algorithms Ueff (o/; o/ 0) and Umon(o/; o/ 0) take two normalised types
and return a normalised substitution `.

Proposition 4.1. (Unification) Let U be one of Ueff or Umon.
--(Sound) If ` = U(o/; o/ 0) then `o/ = `o/ 0 (with `; o/; o/ 0 normalised).
--(Complete) If `o/ = `o/ 0 then there exist `0 and `00 such that `0 = U(o/; o/ 0) and

` = `00`0 (with o/; o/ 0; `0 normalised).

The proof is standard, as normalisation eliminates any potentially tricky cases.

4.2 Constraints
Constraints and the constraint solution algorithm are shown in Figure 8. A set of
constraints ^ is a set of inequations of the form & w oe, asserting that & encompasses
at least the effect oe.

A substitution _ is a solution of ^, written _ j= ^, if _& w _oe for each inequation
& w oe in ^. Such a solution always exists.

The constraint solution algorithm K(^) takes a constraint set and returns a substitution _ which solves ^. It assumes that effect variables on the left hand side
of constraints in ^ are distinct, which can be achieved by repeatedly merging two
constraints & w oe and & w oe0 into one constraint & w oe [ oe0.

Proposition 4.2. (Constraint solution)
--(Sound) K(^) j= ^.
--(Complete) If _ j= ^ then _ = _ ffi K(^).

The proof is given in Appendix A.3.
The algorithm is identical to the one in Talpin's thesis [TJ94; Tal93]. It computes
a principal solution of the constraint set ^, independently of the order in which the
constraints are visited. (The algorithm is subtly different to their earlier algorithm
Min [TJ92]. Algorithm Min yields a solution, which is minimal with respect to the
ordering w defined by _ w _0 iff, for all & 2 dom(_0), _(s) w _0(s). Unfortunately,
this ordering is not defined in their paper.)

4.3 Reconstruction for Effect
Type schemes and the reconstruction algorithm for Effect are shown in Figure 9.
A different flavor of type schemes is introduced which fits better with the type
inference. Following [TJ94; Tal93], such a reconstruction scheme has the form
8_!: (o/; ^) where _! is a sequence of type, region, or effect variables; the scheme is
normalised if o/ is normalised. Such a scheme represents all types of the form `o/
where ` j= ^ and the domain of ` is contained in _!. Reconstruction environments
are taken to map identifiers to type schemes; the environment is normalised if all
types in it are normalised. We write f_! 7! _!0g for a substitution, when _! and _!0

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  21
have the same length, and each has type, region, and effect variables in the same
positions as the other.

The reconstruction algorithm Ieff(E; ^; e) takes a normalised reconstruction environment E, an initial constraint set ^, and an expression e, and returns a quadruple
h`; o/; oe; ^0i, with ` and o/ normalised. It fails if some unification within it fails. The
substitution ` is idempotent, and o/ , oe, and ^0 are invariant under `. The algorithm
is essentially drawn from Talpin and Jouvelot's later work [TJ94].

To relate a reconstruction scheme to an equivalent type scheme, we exploit the
algorithm for solving constraints in Figure 8. If ^o/ is a type reconstruction scheme,
we define ^o/ = ^o/ 0 where ^o/ = 8_ff; _fl; _&: (o/; ^) and ^o/ 0 = 8_ff; _fl; _&: K(^)(o/). We define E
by pointwise extension: E(x) = E(x) for each x 2 dom(E).

To state completeness, we use the generic instance relation ^o/ * ^o/ 0 defined in
Section 2. We define E * E0 by pointwise extension: it holds if E(x) * E0(x) for
each x 2 dom(E).

The reconstruction algorithm is sound and complete.

Proposition 4.3. (Type reconstruction)
--(Sound) If Ieff (E; ^; e) = h`; o/; oe; ^0i and _ = K(^0) then _`E `eff e : _o/ ! _oe, with

E, `, and o/ normalised.

--(Complete) Let E be a normalised reconstruction environment, let E0 be a type environment such that E * E0, and let ` j= ^. If `E0 `eff e : o/ ! oe then Ieff (E; ^; e) =
h`0; o/ 0; oe0; ^0i and there exists a substitution `00 such that `00`0E * `E0 and o/ = `00o/ 0
and oe ' `00oe0 and `00 j= ^0, with `0 and o/ 0 normalised.

The proof for the first part is by induction on the structure of expressions, and for
the second by induction on the structure of type derivations. (A similar proof is
given by Talpin and Jouvelot [TJ94]. In their earlier work [TJ92], the proof skips
the case of polymorphic `let' binding, assuming such bindings have been expanded
out.)

Another way to obtain a reconstruction result would be to introduce arrow effects
as proposed by Tofte and others [TT94]. In fact, type schemes with arrow effects
are equivalent to the reconstruction type schemes introduced in the present section:
simply replace each arrow effect &:oe by the effect variable & and add the constraint
& w oe.

4.4 Reconstruction for Monad
The reconstruction algorithm for Monad is shown in Figure 9. The unification
algorithm, type schemes, and type environments are as before, with types for Monad
replacing types for Effect, mutatis mutandis. Constraints carry over without change.

The reconstruction algorithm Imon(E; ^; e) takes a type environment E, an initial
constraint set ^, and an expression e, and returns a triple h`; o/; ^0i, or fails if some
unification within it fails. The reconstruction algorithm is easily transposed to the
new setting. It has much the same structure as before, the largest difference being
that effects are mentioned only in monad types, and effects in types are always
represented by variables, so a few extra constraints are required.

It is also easy to transpose the results regarding the algorithm.

Proposition 4.4. (Type reconstruction)

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

22 \Delta  P. Wadler and P. Thiemann
--(Sound) If Imon(E; ^; e) = h`; o/; ^0i and _ = K(^0) then _`E `mon e : _o/ , with E,

`, and o/ normalised.

--(Complete) Let E be a normalised reconstruction environment, E0 a type environment such that E * E0, and let ` j= ^. If `E0 `mon e : o/ then Imon(E; ^; e) =
h`0; o/ 0; ^0i and there exists a substitution `00 such that `00`0E * `E and o/ = `00o/ 0
and `00 j= ^0, with `0 and o/ 0 normalised.

4.5 Translation
The two reconstruction algorithms yield results that are related by the translation.
Write ^ ' ^0 if for all _ we have _ j= ^ if and only if _ j= ^0. The translation is
extended to apply to reconstruction schemes by taking (8_!: (o/; ^))y = 8_!: (o/ y; ^).

Proposition 4.5. (Translation preserves type reconstruction) If Ieff (E; ^; e) =
h`0; o/ 0; oe0; ^0i and Imon(Ey; ^; e\Lambda ) = h`00; o/ 00; ^00i then there exist & and _ such that
T& o/ y = o/ 0 and `0 = _`00 and oe0 = _& and ^0 ' _^00.

The proof is by induction on the structure of expressions.

5. CONCLUSIONS
We have verified the conjecture, first broached half a decade past, that effect systems
can be adapted to monads. We have demonstrated this for the specific case of the
type, region, and effect system of Talpin and Jouvelot, but it seems clear that any
effect system can be adapted to monads in a similar way.

Here are points for future work.

Denotational semantics. It is straightforward to provide semantics for effects
and monads in a denotational style. In this semantics, the instrumentation can be
factored out as a separate monad transformer. The factoring uses the well known
result that if T X is a monad, then so is TA X = T (X \Theta  A), where A is a monoid.
In this case, A is taken to be the monoid of traces, with identity ; and operator [.

Coherent semantics. An alternative approach to denotational semantics might
be to eliminate the instrumentation, and associate with each effect oe a different
monad T oe. For state, one traditionally defines T X = S ! X \Theta  S where the store
S is a mapping from locations to values. Here one might define T oe o/ = Soe ! X \Theta Soe
where Soe is a store restricted to contain only locations in regions ae such that read(ae)
or init(ae) is in oe, and Soe is a store restricted to contain only locations in regions
ae such that init(ae) or write(ae) is in oe. Corresponding to each effect inclusion
oe ` oe0 there should be a monad morphism T oe ! T oe

0. In order to ensure coherence

in the style of Breazu-Tannen et al. [BCGS91], we should expect transitivity of
inclusions to correspond to composition of the corresponding morphisms.

A general theory of effects and monads. As hypothesised by Moggi and as born
out by practice, most computational effects can be viewed as a monad. Does this
provide the possibility to formulate a general theory of effects and monads, avoiding
the need to create a new effect system for each new effect?

Acknowledgements. Thanks to Mads Tofte, Jon Riecke, Matthias Felleisen, and
J.-P. Talpin for comments on earlier drafts of this paper.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  23
REFERENCES

Gilles Barthe, John Hatcliff, and Peter Thiemann. Monadic type systems: Pure type systems

for impure settings (preliminary report). In Proceedings of HOOTS'97, volume 10 of ENTCS.
Elsevier, 1998.

N. Benton, A. Kennedy, and G. Russell, Compiling Standard ML to Java Bytecodes, ACM 3'rd

International Conference on Functional Programming, Baltimore, September 1998.

V. Breazu-Tannen, T. Coquand, C. A. Gunter, and A. Scedrov, Inheritance as explicit coercion,

Information and Computation, 93(1):172-221, 1991. Reprinted in C. A. Gunter and J. C.
Mitchell, editors, Theoretical aspects of object-oriented programming, MIT Press, 1994.

Sigbjorn Finne, Daan Leijen, Erik Meijer, and Simpon Peyton Jones. Calling Hell from Heaven

and Heaven from Hell. 4'th ACM International Conference on Functional Programming, Paris,
September 1999.

D. K. Gifford and J. M. Lucassen, Integrating functional and imperative programming, ACM

Conference on Lisp and Functional Programming, Cambridge, Massachusetts, August 1986.

D. K. Gifford, P. Jouvelot, J. M. Lucassen, and M. A. Sheldon, FX-87 Reference Manual, Technical

report MIT/LCS/TR-407, MIT Laboratory for Computer Science, September 1987.

James Gosling, Bill Joy, and Guy Steele, The Java Language Specification, Java Series, Sun

Microsystems, 1996.

Haskell98, a non-strict, purely functional language. http://www.haskell.org, December 1998.
J. Hatcliff and O. Danvy, A generic account of continuation-passing styles, ACM Symposium on

Principles of Programming Languages, Portland, Oregon, January 1994.

Robert Harper and Mark Lillibridge. Polymorphic type assignment and cps conversion. LISP

and Symbolic Computation, 6(4):361-380, 1993.
P. Jouvelot and D. K. Gifford, Reasoning about continuations with control effects, Technical

report MIT/LCS/TM-378, MIT Laboratory for Computer Science, January 1989.

M. P. Jones, Functional programming with overloading and higher-order polymorphism, in J.

Jeuring and E. Meijer, editors, Advanced Functional Programming, LNCS 925, Springer Verlag,
1995.

J. Launchbury and S. L. Peyton Jones, Lazy functional state threads, ACM Conference on Programming Language Design and Implementation, Orlando, Florida, 1994.

Xavier Leroy. Polymorphism by name for references and continuations. In Conference Record

of POPL '93: The 20st ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, pages 220-231, Charleston, South Carolina, USA, January 1993. ACM Press.

John M. Lucassen and David K. Gifford. Polymorphic effect systems. In Conference Record

of POPL '88: The 15rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, pages 47-57, San Diego, California, 1988. ACM Press.

J. M. Lucassen, Types and effects, towards the integration of functional and imperative programming, Ph.D. Thesis, Technical report MIT/LCS/TR-408, MIT Laboratory for Computer
Science, August 1987.

R. Milner, A theory for type polymorphism in programming, Journal of Computer and Systems

Science, 17:348-375, 1978.

J. C. Mitchell, Type inference with simple subtypes, Journal of Functional Programming,

1(3):245-286, 1991.

J. C. Mitchell, Foundations for programming languages, MIT Press, 1996.
E. Moggi and F. Palumbo, Monadic Encapsulation of Effects: A Revised Approach, HOOTS '99

Higher Order Operational Techniques in Semantics, Electronic Notes in Theoretical Computer
Science 26, Elsevier Science, 1999.

R. Milner, M. Tofte, and R. Harper, The Definition of Standard ML, MIT Press, 1990.
R. Milner, M. Tofte, R. Harper, and D. MacQueen, The Definition of Standard ML (Revised),

MIT Press, 1997.
E. Moggi, Computational lambda calculus and monads, IEEE Symposium on Logic in Computer

Science, Asilomar, California, June 1989.

E. Moggi, Notions of computation and monads, Information and Computation, 93(1), 1991.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

24 \Delta  P. Wadler and P. Thiemann

Hanne Riis Nielson, Flemming Nielson, and Torben Amtoft. Polymorphic subtyping for effect

analysis: The static semantics. In Mads Dam, editor, Proceedings of the Fifth LOMAPS Workshop, number 1192 in Lecture Notes in Computer Science. Springer-Verlag, 1997.

Simon Peyton Jones, Alastair Reid, Tony Hoare, Simon Marlow, and Fergus Henderson. A semantics for imprecise exceptions. In Proceedings of the 1999 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI), SIGPLAN Notices, Atlanta,
Georgia, USA, May 1999. SIGPLAN Notices 34(5).

J. Peterson and K. Hammond, editors, Haskell 1.4, a non-strict, purely functional language,

Technical report, Yale University, April 1997.

G. Plotkin, Call-by-name, call-by-value, and the *-calculus, Theoretical Computer Science, 1:125-

159, 1975.

Simon Peyton Jones, Andrew Gordon, and Sigbjrn Finne. Concurrent Haskell. In Conference

Record of POPL '96: The 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 295-308, St. Petersburg Beach, Florida, USA, 21-24 January 1996.
ACM Press.

S. L. Peyton Jones and P. Wadler, Imperative functional programming, ACM Symposium on

Principles of Programming Languages, Charleston, South Carolina, January 1993.

Miley Semmelroth and Amr Sabry. Monadic Encapsulation in ML. 4'th ACM International Conference on Functional Programming, pages 8-17, Paris, September 1999.

Amr Sabry and Philip Wadler, A reflection on call-by-value, ACM Transactions on Programming

Languages and Systems, 19(6):916-941, November 1997. (An earlier version appeared in 1'st
ACM International Conference on Functional Programming, Philadelphia, May 1996.)

J.-P. Talpin and P. Jouvelot, Polymorphic type, region, and effect inference, Journal of Functional

Programming, 2(3):245-271, July 1992.

J.-P. Talpin and P. Jouvelot, The type and effect discipline, Information and Computation,

111(2):245-296, 1994.

J.-P. Talpin, Theoretical and Practical Aspects of Type and Effect Inference, PhD Thesis, Ecole

des Mines de Paris and University Paris VI, 1993.

M. Tofte, Operational semantics and polymorphic type inference, PhD Thesis, University of Edinburgh, 1987.

M. Tofte and L. Birkedal, A region inference algorithm, Transactions on Programming Languages

and Systems, November 1998 (to appear).

Mads Tofte and Jean-Pierre Talpin. Implementation of the typed call-by-value *-calculus using a

stack of regions. In Proceedings of the 21th ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages, pages 188-201, January 1994.

A. Tolmach, Optimizing ML using a hierarchy of monadic types. Workshop on Types in Compilation, Kyoto, March 1998.

P. Wadler, Comprehending monads, ACM Conference on Lisp and Functional Programming,

Nice, France, June 1990.

P. Wadler, The essence of functional programming (Invited talk), ACM Symposium on Principles

of Programming Languages, Albuquerque, New Mexico, January 1992.

P. Wadler, Monads for functional programming, in M. Broy, editor, Program Design Calculi,

NATO ASI Series, Springer Verlag, 1993. Also in J. Jeuring and E. Meijer, editors, Advanced
Functional Programming, LNCS 925, Springer Verlag, 1995.

P. Wadler, How to declare an imperative (Invited talk), International Logic Programming Symposium, Portland, Oregon, MIT Press, December 1995.

P. Wadler, The marriage of effects and monads, ACM 3'rd International Conference on Functional

Programming, Baltimore, September 1998.

A. Wright and M. Felleisen, A syntactic approach to type soundness, Information and Computation, 115(1):38-94, November 1994.

A. Wright, Typing references by effect inference, 4th European Symposium on Programming,

Rennes, France, February 1992, Springer-Verlang LNCS 582.

A. Wright, Simple imperative polymorphism, Lisp and Symbolic Computation, 8:343-355, 1995.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  25
A. PROOFS
A.1 Progress
Proposition 3.3 (Progress)
Suppose E `eff s; e : o/ ! oe. Either e is a value or there exists s0; e0 and f such that

s; e f\Gamma !eff s0; e0.

Proof. By induction on the derivation of E `eff s; e : o/ ! oe. In each case, we
have that E `eff s and E `eff e : o/ ! oe.

Case (var) ^o/ * o/E

x [ fx 7! ^o/ g `eff x : o/ ! ; . A value.

Case (does) E `eff e : o/ ! oe oe

0 w oe

E `eff e : o/ ! oe0 . The claim is immediate by the inductive
hypothesis.

Case (abs) Ex [ fx 7! o/g `eff e : o/

0 ! oe

E `eff *x: e : o/ oe! o/ 0 ! ; . A value.

Case (app) E `eff e1 : o/

oe

00! o/ 0 ! oe E `

eff e2 : o/ ! oe0
E `eff e1 e2 : o/ 0 ! oe [ oe0 [ oe00 . By induction, either s; e1

f\Gamma !

eff

s0; e01 or e1 is a value v1.

In the first case, rule (context) yields that s; e1 e2 f\Gamma !eff s0; e01 e2.
If e1 = v1, a value, then, by induction, either s; e2 f\Gamma !eff s0; e02 or e2 is a value.
In the first case, rule (context) yields that s; v1 e2 f\Gamma !eff s0; v1 e02.
If e2 = v2, a value, then the canonical forms lemma 3.2 applied to v1 yields that
v1 is either *x: e or rec x: *x0: e. In both cases, the expression is a redex using
either (beta) or (rec).

Case (let)

E `eff v : o/ ! ;
Ex [ fx 7! gen(E; o/ )g `eff e : o/ 0 ! oe

E `eff let x = v in e : o/ 0 ! oe

. This expression is a redex.

Case (ilet)

E `eff e1 : o/ ! oe
Ex [ fx 7! o/ g `eff e2 : o/ 0 ! oe0
E `eff ilet x = e1 in e2 : o/ 0 ! oe [ oe0

. By induction, either e1 is a

value, in which case the whole expression is a redex, or s; e1 f\Gamma !eff s0; e01. In the
latter case, the whole expression reduces due to (context).

Case (rec) Ex;x

0 [ fx 7! o/ oe! o/ 0; x0 7! o/ g `eff e : o/ 0 ! oe

E `eff rec x: *x0: e : o/ oe! o/ 0 ! ; . A value.

Case (new) E `eff e : o/ ! oeE `

eff new e : refae o/ ! oe [ init(ae) . By induction, either e is a value,

in which case the whole expression is a redex, or s; e f\Gamma !eff s0; e0. In the latter case,
the whole expression reduces, too, by rule (context).

Case (get) E `eff e : refae o/ ! oeE `

eff get e : o/ ! oe [ read(ae) . By induction, either e is a value, in

which case the canonical forms lemma 3.2 shows that e = l 2 Location, l 2 dom(s),

and hence the whole expression is a redex, or s; e f\Gamma !eff s0; e0. In the latter case,
the whole expression reduces by rules (context).

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

26 \Delta  P. Wadler and P. Thiemann

Case (set) E `eff e1 : refae o/ ! oe E `eff e2 : o/ ! oe

0

E `eff set e1 e2 : o/ ! oe [ oe0 [ write(ae) . By induction, either e1 is a
value, in which case the canonical forms lemma 3.2 shows that e1 = l 2 Location

and l 2 dom(s), or s; e1 f\Gamma !eff s0; e01. In the latter case, the whole expression reduces
by rules (context).

If e1 = l then, by induction, either e2 is a value, in which case the whole expression

is a redex, or s; e2 s\Gamma !

0

eff; e02. In the latter case, the whole expression reduces by(context).

A.2 Translation preserves semantics
Proposition 3.10 (Translation preserves semantics)

(1 ) If s; e f\Gamma !eff s0; e0 then either sy; e\Lambda  f\Gamma !mon s0y; e0\Lambda , or sy; e\Lambda  f\Gamma !mon s0y; e0 and

e0 \Gamma !mon e0\Lambda .

(2 ) If s; e f\Gamma !\Gamma !eff s0; e0 then sy; e\Lambda  f\Gamma !\Gamma !mon s0y; e0\Lambda .
(3 ) If s; e *feff then sy; e\Lambda  *fmon.
(4 ) If s; e is stuck then either sy; e\Lambda  is stuck or e\Lambda  \Gamma !mon e0 where sy; e0 is stuck.

Proof. Item 1 by induction on the definition of f\Gamma !eff.
Case (beta): s; (*x: e)v ;\Gamma !eff s; e[x := v].

sy; ((*x: e)v)\Lambda 
= sy; (*x: e)y vy
= sy; (*x: e\Lambda ) vy

;\Gamma !mon sy; e\Lambda [x := vy]

= sy; (e[x := v])\Lambda 

Case (rec): s; (rec x: *x0: e)v ;\Gamma !eff s; (*x0: e[x := rec x: *x0: e])v.

sy; (rec x: *x0: e)y vy
= sy; (rec x: *x0: e\Lambda ) vy

;\Gamma !mon sy; (*x0: e\Lambda [x := rec x: *x0: e\Lambda ]) vy

= sy; (*x0: e\Lambda [x := (rec x: *x0: e)y]) vy
= sy; ((*x0: e[x := rec x: *x0: e])v)\Lambda 

Case (letv): s; let x = v in e ;\Gamma !eff s; e[x := v].

sy; (let x = v in e)\Lambda 
= sy; let x = vy in e\Lambda 

;\Gamma !mon sy; e\Lambda [x := vy]

= sy; (e[x := v])\Lambda 

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  27
Case (let): s; ilet x = v in e ;\Gamma !eff s; e[x := v].

sy; (ilet x = v in e)\Lambda 
= sy; let x ( v\Lambda  in e\Lambda 
= sy; let x ( !vy? in e\Lambda 

;\Gamma !mon sy; e\Lambda [x := vy]

= sy; (e[x := v])\Lambda 

Case (new): s; new v init(

l)\Gamma !

eff s [ fl 7! vg; l where l 62 dom(s).

sy; (new v)\Lambda 
= sy; new vy
init(l)\Gamma !

mon sy [ fl 7! vyg; !l?

= s [ fl 7! vgy; l\Lambda 

Case (get): sl [ fl 7! vg; get l read(l)\Gamma ! eff sl [ fl 7! vg; v.

sl [ fl 7! vgy; (get l)\Lambda 
= syl [ fl 7! vyg; get l
read(l)\Gamma !

mon syl [ fl 7! vyg; !vy?

= sl [ fl 7! vgy; v\Lambda 

Case (set): sl [ fl 7! vg; set l v0 write(

l)\Gamma !

eff sl [ fl 7! v0g; v0.

(sl [ fl 7! vg)y; (set l v0)\Lambda 
= syl [ fl 7! vyg; set l v0y
write(l)\Gamma !

mon syl [ fl 7! v0yg; !v0y?

= (sl [ fl 7! v0g)y; v0\Lambda 

Case (context) s; n

f\Gamma !

eff s0; e0

s; E[n] f\Gamma !eff s0; E[e0] . The expression, n, must be a non-value
because otherwise the reduction would be impossible.

Subcase E = [ ] e.

sy; (n e)\Lambda 
= sy; let x ( n\Lambda  in (x e)\Lambda 

f\Gamma !

mon by induction, and context M

sy; let x ( e0\Lambda  in (x e)\Lambda 

If e0 2 NonVal then

= sy; (e0 e)\Lambda 
If e0 = v0 2 Val then

= sy; let x ( v0\Lambda  in (x e)\Lambda 
= sy; let x ( !v0y? in (x e)\Lambda 

;\Gamma !mon sy; (x e)\Lambda [x := v0y]

= sy; (v0 e)\Lambda 
ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

28 \Delta  P. Wadler and P. Thiemann

Subcase E = v [ ].

sy; (v n)\Lambda 
= sy; let x ( n\Lambda  in (v x)\Lambda 

f\Gamma !

mon by induction, and context M

sy; let x ( e0\Lambda  in (v x)\Lambda 

If e0 2 NonVal then

= sy; (v e0)\Lambda 
If e0 = v0 2 Val then

= sy; let x ( v0\Lambda  in (v x)\Lambda 
= sy; let x ( !v0y? in (v x)\Lambda 

;\Gamma !mon sy; (v x)\Lambda [x := v0y]

= sy; (v v0)\Lambda 

Subcase E = ilet x = [ ] in e.

sy; (ilet x = n in e)\Lambda 
= sy; let x ( n\Lambda  in e\Lambda 

f\Gamma !

mon by induction, and context M

sy; let x ( e0\Lambda  in e\Lambda 

= sy; (ilet x = e0 in e)\Lambda 

Subcase E = new [ ].

sy; (new n)\Lambda 
= sy; let x ( n\Lambda  in (new x)\Lambda 

f\Gamma !

mon by induction, and context M

sy; let x ( e0\Lambda  in (new x)\Lambda 

If e0 2 NonVal then

= sy; (new e0)\Lambda 
If e0 = v0 2 Val then

= sy; let x ( v0\Lambda  in (new x)\Lambda 
= sy; let x ( !v0y? in (new x)\Lambda 

;\Gamma !mon sy; (new x)\Lambda [x := v0y]

= sy; (new v0)\Lambda 

Subcase E = get [ ].

sy; (get n)\Lambda 
= sy; let x ( n\Lambda  in (get x)\Lambda 

f\Gamma !

mon by induction, and context M

sy; let x ( e0\Lambda  in (get x)\Lambda 

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  29
If e0 2 NonVal then

= sy; (get e0)\Lambda 
If e0 = v0 2 Val then

= sy; let x ( v0\Lambda  in (get x)\Lambda 
= sy; let x ( !v0y? in (get x)\Lambda 

;\Gamma !mon sy; (get x)\Lambda [x := v0y]

= sy; (get v0)\Lambda 

Subcase E = set [ ] e. Analogous to E = [ ] e.
Subcase E = set v [ ]. Analogous to E = v [ ].

Item 2 by induction on the definition of f\Gamma !\Gamma !eff .
Item 3 is immediate from item 2.
Item 4 requires an inductive proof, again:
Case l v0, where l 2 Location.
(l v0)\Lambda  = ly v0y = l v0y is stuck because l is not a lambda.
Case get v, where v is not a location or v =2 dom(s).
(get v)\Lambda  = get vy. There are three cases for v.
Subcase v = l 2 Location and l 62 dom(s).
Then get ly = get l is stuck because l =2 dom(sy) = dom(s).
Subcase v = *x: e.
Then get (*x: e)y = get *x: e\Lambda  is stuck because vy is not a location.
Subcase v = rec x: *x0: e.
Then

get (rec x: *x0: e)y
= get (rec x: *x0: e\Lambda )
\Gamma !mon get (*x0: e\Lambda [x := rec x: *x0: e\Lambda ])

which is stuck because *x0: : : : is not a location.

Case set v v0, where v is not a location or v =2 dom(s).
(set v v0)\Lambda  = set vy v0y. Analogous to subcase get v.
Case if s; e is stuck, then s; E[e] is stuck. By definition of stuck, e must be a
non-value.

Subcase E = [ ] e0.
(e e0)\Lambda  = let x ( e\Lambda  in (x e0)\Lambda . By induction, sy; e\Lambda  is stuck so that e\Lambda  has the
form M [e0], where e0 is one of the cases in the definition of stuck. Hence, for some
monad context M 0,

(e e0)\Lambda 
= let x ( M [e0] in (x e0)\Lambda 
= M 0[e0]

This proves the claim.

Subcase E = v [ ].
(v e)\Lambda  = let x ( e\Lambda  in (v x)\Lambda . Stuck by analogous reasoning as in the previous
subcase.

Subcase E = ilet x = [ ] in e0.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

30 \Delta  P. Wadler and P. Thiemann

(ilet x = e in e0)\Lambda  = let x ( e\Lambda  in e0\Lambda . Stuck by analogous reasoning as in the
previous subcase.

Subcase E = new [ ].
(new e)\Lambda  = let x ( e\Lambda  in (new x)\Lambda . Stuck by analogous reasoning as in the previous subcase.

Subcase E = get [ ].
(get e)\Lambda  = let x ( e\Lambda  in (get x)\Lambda . Analogous.
Subcase E = set [ ] e0.
(set e e0)\Lambda  = let x ( e\Lambda  in (set x e0)\Lambda . Analogous to subcase e e0.
Subcase E = set v [ ].
(set v e)\Lambda  = let x ( e\Lambda  in (set v x)\Lambda . Analogous to subcase v e.

A.3 Constraint solution
Proposition 4.2 (Constraint solution)

--(Sound) K(^) j= ^.
--(Complete) If _ j= ^ then _ = _ ffi K(^).

Proof. To show soundness, suppose that the constraint set has the form ^[f& w
oeg. Now,

K(^ [ f& w oeg)(&)
= (f& 7! & [ K(^)(oe)g ffi K(^))(&)
= f& 7! & [ K(^)(oe)g(&)
= & [ K(^)(oe)
w (f& 7! & [ K(^)(oe)g ffi K(^))(oe)
= K(^ [ f& w oeg)(oe)

Completeness is shown by induction on ^.
Case ; is immediate.
Case ^ [ f& w oeg.
Let _0 = _ ffi K(^ [ f& w oeg) = _ ffi f& 7! & [ K(^)(oe)g ffi K(^). Show that, for each
&0, _0(&0) = _(&0).

First, observe that _ ffi f& 7! & [ K(^)(oe)g = _ by considering this substitution on
&.

_(f& 7! & [ K(^)(oe)g(&))
= _(& [ K(^)(oe))
= _(&) [ _(K(^)(oe))

[by the inductive hypothesis]
= _(&) [ _(oe)

[since _ solution]
= _(&)

There are three cases to consider.
Subcase &0 =2 dom(K(^)) and &0 6= &.
_0(&0) = _(f& 7! & [ K(^)(oe)g(K(^)(&0))) = _(&0).

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.

The marriage of effects and monads \Delta  31
Subcase &0 = &.

_0(&)
= _(f& 7! & [ K(^)(oe)g(K(^)(&)))

[since & =2 dom(K(^))]
= _(f& 7! & [ K(^)(oe)g(&))

[by the preceding observation]
= _(&)

Subcase &0 2 dom(K(^)).

_0(&0)
= _(f& 7! & [ K(^)(oe)g(K(^)(&0)))

[by the preceding observation]
= _(K(^)(&0))
= _(&0)

Received November 1999; revised February 2001; accepted March 2001.

ACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.