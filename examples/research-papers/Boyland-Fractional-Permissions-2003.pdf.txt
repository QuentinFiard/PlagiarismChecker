

To appear: Static Analysis Symposium 2003 (revision 1.1)
Checking Interference with Fractional

Permissions?

John Boyland??
University of Wisconsin-Milwaukee, USA

boyland@cs.uwm.edu

Abstract. We describe a type system for checking interference using
the concept of linear capabilities (which we call "permissions"). Our innovations include the concept of "fractional" permissions: reads can be
permitted with fractional permissions whereas writes require complete
permissions. This distinction expresses the fact that reads on the same
state do not conflict with each other. One may give shared read access
at one point while still retaining write permission afterwards. We give an
operational semantics of a simple imperative language with structured
parallelism and prove that the permission system enables parallelism to
proceed with deterministic results.

1 Introduction
In this paper we describe a new way to check effects on mutable state (reads andwrites) in imperative code for the purpose of determining when two segments
of code are non-interfering. This information can be used by a compiler forscheduling purposes, or by a refactoring tool when reordering code. Analysis is
made modular by having an effects specification for each procedure. Thus twotasks must be performed: checking that a procedure meets its effect specification;
and the original task--checking interference for two statements.Previous work suggests two different models:

effect-based In this model, one infers effects for statements. Effects inferencehas been studied extensively for functional languages [1, 2]. For a modular

analysis, inferred effects for a procedure body are then checked against thedeclared effects. Interference is checked by comparing inferred effects. Each
statement is type-checked in context \Gamma  and produces a set of effects '. Forinterference checking, a side condition

'1#'2 is used to check that if thereis a write in one set of effects, the other set includes no reads or writes on

the same state:

\Gamma  ` s1 ! '1 \Gamma  ` s2 ! '2 '1#'2

\Gamma  ` s1 does not interfere with s2
? This material is based upon work supported by the National Science Foundation

under Grant No. 9984681
?? The author wishes to acknowledge support through the High Dependability Computing Program from NASA Ames cooperative agreement NCC-2-1298.

2
See for example Reynolds syntactic control of interference [3], our earlierwork [4] or Clarke and Drossopoulou's JOE [5].
permission-based In this model, one checks a statement to see if it can beexecuted under a given set of permissions. (For example, consider the lock

checking of Flanagan and Abadi [6], or Boyapati et al [7, 8].) A procedureis checked by determining whether the body can be typed using the declared effects (viewed as permissions). To determine if two statements canbe executed in interleaved fashion, we see if the set of permissions can be
partitioned into two sets, one for each statement:

\Pi 1 ` s1 \Pi 2 ` s2
\Pi 1, \Pi 2 ` s1 does not interfere with s2

The permissions are treated as linear keys: they cannot be duplicated, ordiscarded. See for example Walker, Crary and Morrisett's capability language

(CL) [9], Ishtiaq and O'Hearn's use of "bunched implication" (BI) logic [10],or Reynolds' "separation logic" [11, 12].

These two models are almost duals of each other (especially when the typing rulesgiven above are seen simply as relations) but the practical difference between
checking effect conflict '1#'2 and splitting of permissions \Pi 1, \Pi 2 causes thetwo approaches to be incomparable.

1.1 Problems with Effects and Permissions
Our earlier work [4] used an effect-based system: effects inferred for a methodbody were checked against the method's declared effects and two statement

effects were compared to see if they conflict or not. When effects were compared,we needed the answer to an aliasing question to determine if there was overlap
and hence conflict. Consider the following two compound statements:

{ ...; *x = 10; ... } { ...; *y = 42; ... }
In order to determine whether these statements interfere, we need to knowwhether

x could be the same as y. More precisely, we need to know if the set ofcells that

x could point to at the point that the assignment *x = 10 occurs, couldoverlap the set of cells that

y could point to at the second assignment. We callthis kind of question a "MayEqual" question [13]. One simple way to answer the

question conservatively is to use the fact that objects of different type cannot bealiases of each other. This approach is used by Clarke and Drossopoulou where
the addition of ownership parameterization allows for fine type distinctions. Butany less conservative analysis, such as a Steensgaard's "Points-To" analysis [14],
will need to examine the code. In fact, to do a good job at MayEqual, one needsto know about data dependencies, in particular, about effects. Thus we are left
with the unsatisfying result that the inferred effects do not in themselves includeenough information to perform the interference checking; we must combine the
effects analysis with an alias analysis.

3
An alternate technique is to use permissions. Each individual permissionapplies to a single part of the store and thus the mere existence of two separate
(write) permissions ensures that they do not refer to the same area of storage.In order to handle allocation and deallocation which manufacture and consume
permissions respectively, we check statements with an input and output set ofpermissions:

\Pi  ` s ) \Pi 0 means that s can be executed given permissions \Pi after which permissions

\Pi 0 are available.A problem that arises is how to distinguish reads (which do not conflict

with each other) from writes (which conflict with each other and with reads).For example, Reynolds' separation logic [12] (unlike his earlier work [3]) does
not permit one to separate two side-effecting computations that read the samestate. Two different solutions have been used in previous work:

- Permit a linear key (giving write permission) to be coerced into a nonlinearkey, which then permits only reads from this point forward. (This approach

is possible using subtyping in CL.)- Permit a linear key to be treated non-linearly in a bounded context. Wadler's
let! construct [15] permits a linear variable to be used nonlinearly by codethat only needs read access. SCIR [16] permits a linear key to be moved
into a non-linear section while type checking a statement that only needsread permission. CL uses bounded quantification to pass a unique region
to a function that can use any kind of region. (Thus CL supports bothapproaches.)

In the first case, we irrevocably lose the permission to write. In the second case,it is restored after the section needing read-only access is done. This "amplification" is sound as long as the context needing read permissions is not ableto retain this permission for later use. For instance let! forbids the code using
the variable nonlinearly from (among other things) returning a function, since areference could be hidden in the closure. CL does not permit a closure to hold
capabilities at all. Neither does it permit a capability variable to be used wher-ever its bound can be used. Assuming

r+ is a duplicable capability, CL permitsthe contraction rule on the left, but not the right:

r+, r+, \Pi  ` s ) \Pi 0

r+, \Pi  ` s ) \Pi 0 Ok

s^ <= r+ s^, r+, \Pi  ` s ) \Pi 0

s^, \Pi  ` s ) \Pi 0 NotOk

A system that permits a linear capability to be treated non-linearly will needto use some rules that are at the surface-level, unmotivated. The problem is

(speaking roughly) that if a permission is arbitrarily duplicable, then there is noway to determine if one has all the copies.

One is left with the unpalatable choice between conservatively surrenderingwrite permission irrevocably, and conservatively restricting the type system.

1.2 Fractional Permissions
Our solution to this dilemma is to avoid non-linearity: read permissions arenot duplicable. The major innovation of this paper is to show how one can

4
manufacture arbitrarily many read permissions without copying a permission:we split permissions. Each piece has a definite fraction and thus we can determine
if all the pieces have been recovered and reconstruct the whole permission. Thisproperty is enabled by adding a single substructural rule:

ij t^ "ij, (1 - ")ij
where " is some fraction between zero and one (exclusive) and ij is a permission.1

This solution gives a simple explanation of why writes conflict with reads andwrites, but that reads do not conflict with each other: two pieces can co-exist

but one cannot have the whole thing at the same time as another piece of it.

Consider a procedure requiring read permission to a cell and returning thisread permission as well as read permission to some unknown cell. We don't have

a "contraction" rule in this system and thus cannot take a read permission andconvert it into two read permissions that are identical to the first. Instead if one
wants to get two read permissions from one, one needs to split it into smallerpermissions. Thus if the second result returned by the procedure is an alias
of the parameter, it will be unable to return the entire read permission of theparameter; it will have to return a smaller fraction (which will at least appear
as a different fraction than was delivered to the procedure). Even if the callerhad write permission to the parameter before the call, afterwards, it will not be
possible to reassemble an (unsafe) write permission.

On the other hand, if the second returned permission is not an alias of theparameter, it will be possible to return the same read permission that was passed,

and the caller will be able to reassemble a write permission.

1.3 Contributions
The contribution of this work are as follows:

- We provide a way to check read-write effects with permissions--there is noneed for a MayEqual analysis.

- We provide a new substructural rule for permissions-like systems to enablesharing of read-only state without needing to include non-linear permissions.
- We provide a way for a writable key to be temporarily made read-only whilestill being able to track all the copies, thus preventing unsoundness if a read

permission is retained in some way.
- We present the idea in a simple language with aliasing, procedures and paral-lel computations. We give an operational semantics and define a permission

type system (including simple existential return values) and prove soundness.
- We prove that checkable parallel constructs do not interfere: execution leadsto deterministic results.

1 In this paper, we define a fraction to be a real number. The proofs would also all

work with rational fractions, or fractions with powers of two as denominators. Other
non-numeric encodings are possible, with suitable changes to definitions and proofs.

5
Section 2 describes the simple language, gives an operational semantics anda permission type system. Then we prove the main result: that the type system
ensures non-interference. The following section describes a variety of extensionsmade possible using fractional permissions. Section 4 reviews related work.

2 Types and Permissions
This section first describes the operational semantics of a simple language withpointers to cells containing integers. Then it describes the permission type system
that can be used to check non-interference. We prove that this check of non-interference permits the execution of two pieces of code to be interleaved.

2

2.1 Operational Semantics
The language used to demonstrate the permissions system is a simple languagewhere source level global variables may point to allocated cells which hold integers. We have a (finite) set of variables V , an infinite set of (cell) locations3
L and a set of memories (stores) M which map variables to locations and some(finite subset of) locations to integers (

ZZ):

source vars v 2 Vlocations

l 2 Lmemory (
uV , uL) = u 2 M = (V ! L) * (L * ZZ) where Dom uL u"" uV (V )

where * denotes a partial finite function. The side condition ensures that amemory does not have dangling pointers (here

uV (V ) = {uV v | v 2 V }). Wepermit
u to apply directly to variables and locations. Thus if u = (uV , uL) then
u(u v) is short for uL(uV v). The notation u[v 7! l] updates the pointer storedin a variable and

u[l 7! i] updates the integer stored in a cell. We write u1 z. u2to mean that two memories are isomorphic.

4

A program consists of a (finite) set of procedures. Each procedure has astatement for its body, and thus a program is represented by a map from each

procedure to a statement. (For simplicity, there are no local variables.)

procedures p 2 Pprograms

g 2 G = P ! S

One can allocate a cell, copy pointers or update cell contents. We have sequential(

;) and parallel (||) composition, as well as conditionals and procedure calls:

statements S 3 s ::= v:=new | v:=v0 | *v:=e | skip|

s ; s0 | s || s0 | if b then s else s0 | call p
2 This paper has a separate appendix which contains the lemmas and proofs. URL:

http://www.cs.uwm.edu/faculty/boyland/papers/permissions-appendix.ps
3 In this paper, we do not model the possibility of running out of heap storage.

4 The precise definition of isomorphicity is given in the appendix.

6
Integer expressions include literals, additions and dereferencing of variables.Boolean expressions permit pointer comparison or comparison with zero.

integer expressions e ::= n | e+e | *vboolean expressions

b ::= true | false | v==v0 | e!=0

Figure 1 gives a small-step semantics for statements and expressions. A pairh
u, xi where u is a memory and x is a statement, an integer expression or aboolean expression is rewritten as a new pair for one step of evaluation. The

rewriting for statements is subscripted with a program g because statementsmay include procedure calls and a program maps procedure names to bodies.

The evaluation of new statements stores 0 into the cell to prevent a danglingpointer. None of the other rules can introduce dangling pointers either. The
evaluation of parallel compositions is nondeterministic: either branch may beevaluated one step further. The parallel composition can be eliminated once
both branches are done. The lack of dangling pointers means that evaluationcannot get stuck.

Example Two different runs of the same parallel composition may yield dif-ferent results. Consider the example in Fig. 2. If we evaluate it in a memory
where v4 points to the same cell as v1 or v2, nondeterminism could lead todifferent results. For example, consider

u(v1) = u(v4) = l1, u(v2) = u(v3) = l2,
u(l1) = u(l2) = 1. If the left part is fully evaluated before the right, then at theend

*v1 will be 4. If the right part is fully evaluated before the left, the end re-sult of

*v1 will be 1. However, in other memories, nondeterminism in executionleads to the same result. For instance, if all of the variables point to different

cells, then the execution of the two parts can be interleaved arbitrarily withoutaffecting the final result.

If we use an effect system to check interference, it first notices that neitherpart writes a variable the other reads (a simple matter of matching names), and
thus the two parts only interfere if MayEqual(v11, v32) . MayEqual(v11, v22) .MayEqual(

v21, v32) where the subscripts refer to the occurrences of the vari-ables. A precise answer will require an alias analysis smart enough to determine

that v32 = v41 and such. An effect system simply does not provide sufficientinformation on its own to determine interference. Reynolds' original syntactic
control of interference has the same difficulty with this example.On the other hand, BI-logic or separation logic will fail to determine noninterference since both parts need to access the cell pointed to by v2. These logicsdo not distinguish shared reading from shared writing, and thus cannot determine that the sharing in this case is safe. (The sharing of v4 is non-problematicsince only the heap is partitioned.)

O'Hearn et al's SCIR can handle this example by temporarily making v4and

*v2 read-only, but this solution is not sound in the presense of existentialsas seen in the discussion of Fig. 5.

If one were to define noninterference using the Walker et al's capability lan-guage (not its intended purpose), one encounters a problem with

*v2. If the

7
l 62 Dom uLh
u, v:=newi !g hu[v 7! l, l 7! 0], skipi hu, v:=v

0i !g hu[v 7! u v0], skipi

hu, ei ! hu, e0ih
u, *v:=ei !g hu, *v:=e0i hu, *v:=ii !g hu[u v 7! i], skipi

hu, s1i !g hu0, s01ih
u, s1;s2i !g hu0, s01;s2i hu, skip;si !g hu, si h

u, s1i !g hu0, s01ih
u, s1||s2i !g hu0, s01||s2i

hu, s2i !g hu0, s02ih
u, s1||s2i !g hu0, s1||s02i hu, skip||skipi !g hu, skipi

hu, if true then s1 else s2i !g hu, s1i
hu, if false then s1 else s2i !g hu, s2i

hu, bi ! hu, b0ih
u, if b then s1 else s2i !g hu, if b0 then s1 else s2i

hu, call pi !g hu, g pi hu, e1i ! hu, e

01i

hu, e1+e2i ! hu, e01+e2i h

u, e2i ! hu, e02ih
u, n1+e2i ! hu, n1+e02i

hu, n1+n2i ! hu, n1 + n2i hu, *vi ! hu, u(u v)i hu, v==v0i ! hu, u v = u v0i

hu, ei ! hu, e0ih
u, e!=0i ! hu, e0!=0i hu, i!=0i ! hu, i 6= 0i

Fig. 1. Evaluation

(*v1 := *v2; v1 := v4) || (v3 := v4; *v3 := 3+*v2)

Fig. 2. Example program.

8
permission to read this value is represented by a duplicable capability r+, thenthere is no difficulty, but then write permission to

*v2 can never be recovered.On the other hand, if we have write permission in the form of a unique capability

r1, it does not seem to be possible to check noninterference in the example herewithout irreversibly downgrading this permission. One can prove

r1 < {r+, r+}and use this with bounded quantification, but a capability such as

s^ cannot besplit into two pieces, even if we know
s^ < {r+, r+}, without destroying it. Asplit (similar to what occurs in SCIR) would result in unsoundness because the

capability language has existential return types (in the guise of polymorphiccontinuations).

In the following section, we define a permission type system that can handlesuch examples. Well-typed statements always have deterministic results.

2.2 Permission Types
We follow Smith, Walker and Morrisett [17] in using a singleton type ptr(!) totype pointer variables containing the pointer to location

!. (The permission typesystem uses location variables in all places rather than actual locations.)

location var ! 2 R
We have two kinds of base permissions: one to permit reading/writing of a source-level variable

v (and also to give its type) and one to permit reading/writing theinteger in a cell:

base permission r' ::= v : ptr(!) | !
We do not use fraction constants, but make use of fraction variables which rep-resent some fraction between zero and one, exclusive:

fraction var z 2 Z
Base permissions can be "multiplied" by fractions. Syntactically we distinguishbetween fractions that may be complete (

z.) from ones that are strictly betweenzero and one (
").

permission ij ::= z.r'fraction

z. ::= 1 | "partial fraction E 3

" ::= z | 1 - " | ""

A complete fraction permits writing (as well as reading), but a partial fractionpermits only reading.

A statement is permission-checked in an environment E consisting of a set
\Delta  of free location and fraction variables, and a "set" of permissions \Pi :

environment E ::= \Delta ; \Pi context

\Delta  t, R [ Zpermissions
\Pi  ::= * | ij | \Pi , \Pi 

9
We have three simple sub-structural rules on permission "sets":

*, \Pi  t^ \Pi 
\Pi 1, \Pi 2 t^ \Pi 2, \Pi 1
\Pi 1, (\Pi 2, \Pi 3) t^ (\Pi 1, \Pi 2), \Pi 3

We have the permission splitting operation on a complete environment only toensure we don't split a permission using an unbound variable:

\Delta  ` " frac
\Delta ; "ij, (1 - ")ij, \Pi  t^ \Delta ; ij, \Pi 

where we define "(z.r') = ("z.)r' with "1 = ". We also have rules for fractions:

""0 t^ "0"
"("0"00) t^ (""0)"00
(1 - (1 - ")) t^ "

A procedure accepts a "set" of permissions and returns a "set" of permissions.It is polymorphic in a type context (the 8 scopes over the whole type) and returns

existentially bound permissions. The program type maps procedures to types:

procedure type A 3 o"" ::= 8\Delta .\Pi  ! 9\Delta .\Pi program type

! 2 \Omega  = P ! A

When we perform a call, we need to substitute actual partial fractions for fractionvariables and actual location variables for location variables:

substitution ? 2 \Sigma  = (R ! R) * (Z ! E)
As with u, we permit the pair to apply to either kind of variable, and we sayDom (

?R, ?Z ) = Dom ?R [ Dom ?Z. Application is extended to permissions andfractions, and to variables not in the domain:

? ! = ! if ! 62 Dom ?R ? z = z if z 62 Dom ?Z ? 1 = 1

?(1 - ") = 1 - ? " ?(""0) = (? ")(? "0) ? * = *
?(v : ptr(!)) = v : ptr(? !) ? z.r' = (? z.)(? r') ?(\Pi , \Pi 0) = ? \Pi , ? \Pi 0
Fig. 3 gives the rules for well-formedness of the various syntactic entities withrespect to a set of location and fraction variables. Essentially well-formedness

merely checks whether all variables are bound. Well-formedness of a substitutionchecks that the variables in the domain context are mapped to well-formed
entities in the range context. Using this definition we extend substitution tocomplete environments: if `

? : \Delta  ! \Delta 0 then ?(\Delta 00; \Pi 00) = (\Delta 0[(\Delta 00-\Delta ); ? \Pi 00).Figure 4 gives the rules for permission-checking a program. Allocating a cell

(New) requires write permission on the variable and gets write permission on

10
! 2 \Delta 
\Delta  ` ! loc-var

v 2 V \Delta  ` ! loc-var
\Delta  ` v : ptr(!) base-perm

\Delta  ` ! loc-var
\Delta  ` ! base-perm

z 2 \Delta 
\Delta  ` z frac

\Delta  ` 1 frac

\Delta  ` " frac \Delta  ` "0 frac

\Delta  ` ""0 frac

\Delta  ` " frac
\Delta  ` 1 - " frac

\Delta  ` e frac \Delta  ` r' base-perm

\Delta  ` er' perms \Delta  ` * perms

\Delta  ` \Pi 1 perms \Delta  ` \Pi 2 perms

\Delta  ` \Pi 1, \Pi 2 perms

\Delta  ` \Pi  perms \Delta  " \Delta  = ; \Delta , \Delta 0 ` \Pi 0 perms` 8

\Delta .\Pi  ! 9\Delta 0.\Pi 0 proc-type

For all p 2 P, ` ! p proc-type`

! prog-type

Dom ? = \Delta  For all ! 2 \Delta , \Delta 0 ` ?R ! loc-var For all z 2 \Delta , \Delta 0 ` ?Z z frac`

? : \Delta  ! \Delta 0

Fig. 3. Well-formedness rules
the new cell. The singleton types for variables permit the system to keep track ofaliasing in the

Copy rule. The permissions are "threaded" through both partsof a sequential composition but are split into two for a parallel composition and

then recombined.For

if statements, the environment is sent to both branches and the resultingpermissions may be different. Linearity prevents discarding permissions and thus

there must exist two substitutions ?1 and ?2 that can be used to represent eachbranch's result as an instance of the unified result. At a call, we need two substitutions: one to determine what the actual locations and fractions will be andanother to rename the existentially bound resulting variables. Permissions that
are not needed in a procedure around the call are preserved. The correspondingrule

Proc checks that it is possible to witness the existential variables.

Examples The example code previously shown in Fig. 2 can be permission-checked using

\Pi  = 1v1 : ptr(!), zv2 : ptr(!0), 1v3 : ptr(!0), z0v4 : ptr(!00), 1!, 1!0, 1!00
(here the key !0 needs to be divided between the two parallel parts because eachneeds read access) but not using

\Pi 0 = 1v1 : ptr(!), zv2 : ptr(!0), 1v3 : ptr(!00), z0v4 : ptr(!0), 1!, 1!0, 1!00
because the left part needs some fraction of !0 but the right needs the whole key.This shows that the permissions system can check noninterference more precisely

than BI-logic or separation logic, at least for examples such as this.

11
! fresh
\Delta ; 1v : ptr(!0), \Pi  `! v:=new ) {!} [ \Delta ; 1!, 1v : ptr(!), \Pi  New

\Delta ; 1v : ptr(!), z.v0 : ptr(!0), \Pi  `! v:=v0 ) \Delta ; 1v : ptr(!0), z.v0 : ptr(!0), \Pi  Copy

E = (\Delta ; z.v : ptr(!), 1!, \Pi 0) E ` e : Int

E `! *v:=e ) E Update E `! skip ) E Skip

E `! s1 ) E0 E0 `! s2 ) E00

E `! s1; s2 ) E00 Seq

\Delta ; \Pi 1 `! s1 ) \Delta 01; \Pi 01 \Delta ; \Pi 2 `! s2 ) \Delta 02; \Pi 02

\Delta ; \Pi 1, \Pi 2 `! s1||s2 ) \Delta 01 [ \Delta 02; \Pi 01, \Pi 02 Par

\Delta ; \Pi  ` b : Bool \Delta ; \Pi  `! s1 ) \Delta 1; ?1 \Pi 3 \Delta ; \Pi  `! s2 ) \Delta 2; ?2 \Pi 3
\Delta 3 fresh \Delta  [ \Delta 3 ` \Pi 3 perms ` ?1 : \Delta 3 ! \Delta 1 ` ?2 : \Delta 3 ! \Delta 2

\Delta ; \Pi  `! if b then s1 else s2 ) \Delta  [ \Delta 3; \Pi 3 If

! p = 8\Delta 1.\Pi 1 ! 9\Delta 2.?2 \Pi 3 \Delta 3 fresh ` ?1 : \Delta 1 ! \Delta  ` ?2 : \Delta 3 ! \Delta 2

\Delta ; ?1 \Pi 1, \Pi  `! call p ) \Delta  [ \Delta 3; ?1 \Pi 3, \Pi  Call

\Pi  = z.1v1 : ptr(!1), z.2v2 : ptr(!2), \Pi 0

\Delta ; \Pi  ` v1 == v2 : Bool Eq

E ` e : Int
E ` e!=0 : Bool NotEq

b 2 {true, false}

E ` b : Bool Bool

E ` e1 : Int E ` e2 : Int

E ` e1+e2 : Int Plus

\Pi  = z.v : ptr(!), z.0!, \Pi 0

\Delta ; \Pi  ` *v : Int Deref

n 2 ZZ
E ` n : Int Int

\Delta 1; \Pi 1 `! s ) \Delta 01; ? \Pi 2 \Delta 01 " \Delta 2 = ; ` ? : \Delta 2 ! \Delta 01`

! s : 8\Delta 1.\Pi 1 ! 9\Delta 2.\Pi 2 Proc

For all p 2 P, `! g p : ! p`

g : ! Prog

Fig. 4. Permission-Checking a Program

12
g alias = v2 := v1
g noalias = v2 := new

o""1 = 8l^!, !0, z, z0l/.zv1 : ptr(!), 1v2 : ptr(!0), z0!

! 9l^!00, y, y0, y00l/.zv1 : ptr(!), 1v2 : ptr(!00), y!, y0!00, y00!00
o""2 = 8l^!, !0, z, z0l/.zv1 : ptr(!), 1v2 : ptr(!0), z0!

! 9l^!00, y, y0, y00l/.zv1 : ptr(!), 1v2 : ptr(!00), z0!, y0!00, y00!00

Fig. 5. Two simple procedures and their types

The next example, Fig. 5, gives the code for two procedures: one that returns(
v2) an alias of its parameter (v1); and one that returns a new cell. The procedure
alias has the first type o""1, but the second procedure noalias has both types o""1and

o""2. Both procedure types o""1 and o""2 require permission to read v1 and write
v2 and to read the cell that v1 points to. Both procedure types also say thatthe read permission for

v1 and the write permission for v2 are returned to thecaller as is read permission for the cell pointed to by (the presumably changed)

pointer in v2.5 The two procedure types differ only in what fraction is returnedof the read permission for the cell pointed to by

v1. The first procedure type doesnot specify how "much" is returned; the new fraction is bound existentially. The

second procedure type specifies that the same fraction coming in is returned. Ifone has write permission to the cell pointed to by

v1 and calls a procedure withtype
o""2, one can recover write permission after the procedure is complete, butif the callee has type

o""1, one cannot.

In Walker et al's CL, one can formulate corresponding procedure types thateither permit or forbid aliasing in the result region/value. Polymorphic continuations gives roughly the same power as existential return types.

In an effects system, the procedures would not need to have read permissionon the cell pointed to by

v1 because it is not accessed; the types would be muchsimpler, but then this information must be recovered by the alias analysis used

to answer MayEqual questions. A similar situation occurs with separation logicor BI-logic: information about the heap is not needed to type either procedure
but any potential aliasing after the procedure is finished is not described.

Recall that in SCIR, a writeable variable may be given a read-only typetemporarily. This rule is not sound if we add the ability to pack a copy of a

read-only permission in an existential (as in procedure type o""1), and to unpackit later. After the write permission is recovered, the read-only permission could
be mistakenly seen as not interfered with. In our system, in contrast, even read5 The reason why the procedures need to return two permissions to !00 is because

a fraction variable can never refer to 1. If fraction variables could be one, then a
fraction 1 - z could be zero and render the permission type system unsound.

13
only permissions cannot be duplicated; if read-only permission is retained, theprocedure is unable to return as "much" of the permission as it received from
the caller, making it impossible to recover the write permission.
2.3 Consistency
In order to prove correctness of the type system we need to use a typing invariantwith regard to a memory. A memory

u includes the values of pointer variables,but the type system introduces new variables: key variables and fraction variables. Let \Psi  be mappings (partial function) from location and fraction variablesto locations and numbers between zero and 1, respectively:

type variable map A~ 2 \Psi  = (R * L) * (Z * (0, 1))
As with memories, we treat the pair of mappings as a single mapping with bothtypes. We extend a mapping

A~ to run on fraction expressions (A~ z. 2 (0, 1]):

A~ 1 = 1
A~(""0) = (A~ ")(A~ "0)
A~(1 - ") = 1 - A~ "

These rules ensure that A~ works the same on equivalent fractions: z. t^ z.0 )
A~(z.) = A~(z.0). We further extend a mapping to apply to permissions. Now insteadof getting a single value, we get a value for each variable or cell. Thus the result

is a function from variables and locations to real numbers: A~ \Pi  : ((V [ L) ! IR).The function is made total by mapping all other

x 2 V [ L to zero:

A~ . = []
A~(z.v : ptr(!)) = [v 7! A~ z.]

A~(z.!) = [A~ ! 7! A~ z.]
A~(\Pi 1, \Pi 2) = (A~ \Pi 1) + (A~ \Pi 2)

where
(A~ \Pi 1 + A~ \Pi 2) x = (A~ \Pi 1) x + (A~ \Pi 2) x

The range of the result is syntactically only guaranteed to be nonnegative.A memory is not considered consistent with the environment unless the range

includes only numbers between zero and one, inclusive. The A~ is also used tocheck that variables indeed have the location represented in their type, and that
there are no dangling pointers.

Dom A~ = \Delta  Rng (A~ \Pi ) t, [0, 1] A~; u ` \Pi  consistent

\Delta ; \Pi  ` u ok

A~; u ` * consistent A~; u ` \Pi 1 consistent A~; u ` \Pi 2 consistentA~; u ` \Pi 

1, \Pi 2 consistent

A~(!) = u(v)
A~; u ` z.v : ptr(!) consistent

A~ ! 2 Dom u
A~; u ` z.! consistent

14
2.4 Non-interference
Non-interference in the checking of parallel composition permits us to prove astrong result: terminating evaluation always leads to an isomorphic store. In

other words, the nondeterminism cannot affect the final result.
Theorem 1. If we have a well-typed program g ( ` g : !) and a statement s thatpermission-checks in an environment

E ( E `! s ) E0) and a memory u1 thatis consistent with the environment (
E ` u1 ok), and s can be fully evaluated in

this memory in k steps ( hu1, si k!g hu*1, skipi) then for any isomorphic memory
u2 z. u1, any other evaluation sequence hu2, si !g hu02, s0i !g . . . terminates inexactly

k steps and has an isomorphic result u*2 z. u*1.

2.5 Summary
We have taken a simple language with aliasing and explicit parallelism andhave shown that fractional permissions give us a way to ensure determinism

of execution through non-interference. The following section considers how thisbasic system can be lifted to more complex situations.

3 Extensions
This section explores further work made possible with fractional permissions.

Algorithmic Checking The permission checking system described in this pa-per is not algorithmic since the splitting required for a parallel composition is
not deterministic. The solution is to permission-check the first branch with allthe permissions, but keep track of which ones are actually needed. When only a
fraction of a permission is needed, split it before recording the use of the fraction.After checking the first branch, check the second branch using the permissions
that were not needed during the first branch.

Aliasing information The system here does not make use of pointer equalitychecking in

if conditions. Equality is useful in order to connect a variable withan unknown pointer with a permission on an unknown cell. Inequality is useful in asserting uniqueness. To handle both situations, one can add a separatealiasing context that expresses known equalities and inequalities between location variables, and even logical connectives between these facts. For example ifone knows that a variable

z is equal to one of x and y, then if we have writepermission for the cells pointed to by both

x and y, then we also implicitly havepermission for the cell pointed to by
z. In general, one can use any three-valuedlogic [18] to hold this information. This information represents "facts" and not

permissions and thus can be copied to both sides of a parallel composition.

15
Memory Management Adding garbage collection could be accomplished us-ing a formulation similar to that of Morrisett, Felleisen and Harper [19]. Instead
of the isomorphicity constraint, one would ensure that a final integer expressionwould have a value unchanged by garbage collection. We would also need a way
to remove permissions to unreachable cells.

Adding explicit memory management (dispose) can be handled. Deallo-cation removes a key just as allocation introduces it. The usual semantics of

dispose leaves dangling pointers in place, and the proof of determinism failswhen dangling pointers exist: the sequence

v1 := v2; dispose v2; new v2may reallocate the same memory location for
v1 or not, leading to non-isomorphicmemories. There are at least two possible ways around this difficulty: (1) relax

isomorphicity and then prevent dangling pointers from being compared to otherpointers; or (2) change the semantics of dispose to work only in ways that do not
leave dangling pointers. In the first solution, one needs permission to comparepointers, which corresponds to the I access right of BNR capabilities [20].

The permission system described here cannot check recursive procedures thatallocate cells on their recursive path, since each allocation produces a new key
which cannot be forgotten. This brings us to the next extension topic.

Records and recursive data types When we have singleton types for point-ers, then record types and especially recursive data types require the use of
existentials [21]. The existentials include not just bindings, but also permissions.This permits us to represent an unknown unique pointer: the complete permission stored with the pointer. Immutable pointers are represented by storing anexistential fraction of the permission with the pointer.

Since the packed existential includes (linear) witness permissions, a variablewith existential type cannot be read or written (that is, copying or destroying the value) until the existential is unpacked. Therefore a permission systemneeds to distinguish "open variables" (variables with singleton type) from "closed
variables" (variables with existential type). Closed variables can be fractionallyopened in which case only a fraction of the witness permissions are usable.

Adoption and Ownership Adoption involves logically storing a key insideanother one. Adoption cannot be undone. In this way, it is similar to ownership.
In adoption and focus, the adoptee can only be made accessible by temporarilymaking the adopter inaccessible. With fractions, one could access a fraction of
the adoptee (and thus have read-only access) given only a fraction of the adopter.

A shared variable is modeled by adopting its complete permission into aglobally accessible key. "Fractional adoption" permits the modeling of uniquewrite variables, variables that are globally read-only with write access at a singlepoint. For such a variable, a known fraction is adopted by a globally accessible
key and the remainder is kept at the write-access point. The two fractions canbe put together to gain write access.

16
4 Related Work
Reynolds' "syntactic control of interference" [3] checked that call-by-name wouldnot cause "covert interference" where a parameter and a procedure each observe

the same changing state. This work was revisited by O'Hearn and others [16](SCIR). SCIR split the context into two parts: an active part (writable); and
a passive part (read only). The passive part can be duplicated in two branchesof the proof (unlike the active part) enabling the sharing of read-only state. An
interesting rule called "passification" enabled a write of a variable to be ignoredif the result was a passive type. A monadic-like structure ensures that (visible)
state mutations cannot be hidden in a passively-type result.Reynolds and O'Hearn have continued analysis of mutable data structures
using the logic of "bunched implications" [10] and "separation logic" [12]. A spa-tial conjunction operator in the logics allows parts of the heap to be analyzed
separately. Allocation and deallocation add and remove spatial conjuncts. How-ever, the spatial conjunction operator strictly separates heap access: it does not
distinguish reads from writes. It appears that fractions could be applied, so thatone could have

P |= "P * (1 - ")P and get the ability to share read-only heaps.Walker, Crary and Morrisett's static capability system [9] inspired DeLine

and F"ahndrich's alias typing system for Vault [22], from which adoption andfocus [23] grew. The capabilities or guards can be seen as permissions. With the
"focus" operation, one temporarily gives up a guard in order to get unrestrictedaccess to a unique variable. Once uniqueness is re-established the guard can be
returned. This process is handled with a linear implication h -s' g.Effects systems have been used to check non-interference [4, 5] but need to
be augmented with MayEqual information to check for conflict. One simple (butconservative) analysis is to assume any two references with the same type (or
compatible types) may be aliased.In the area of compilers, non-interference is traditionally checked through
using a data-flow graph (or some superset thereof). From early on, the interde-pendence between aliasing and data dependencies has been recognized. Traditionally, the alias information is presented in terms of may-alias (and must-alias)facts, pairs of aliases at program points. MayEqual, on the other hand, compares
pointer expressions at disparate program points [13]. Ross and Sagiv [24] haveshow how data dependencies can be recovered from may-alias information by
instrumenting the program (in a global transformation).Rugina and Rinard give an algorithm for doing flow-sensitive pointer analysis
in programs with structured parallelism [25]. It models interference by assumingthat any mutation performed in one parallel branch may be visible at any time in
other parallel branches. The analysis described here is simpler since interferencebetween parallel branches is forbidden.

5 Conclusions
We define a permission type system which enables us to solve the interdepen-dent problems of uniqueness and effects in a single formalism. We extend earlier

17
work on permissions to distinguish reads from writes using fractional permis-sions, rather than non-linearity. We define a simple language with aliasing and
parallelism and show that well-typed programs have deterministic results.

Acknowledgments I thank Dave Clarke, Manuel F"ahndrich and Bill Retertfor helping me frame this idea and reading innumerable drafts. All remaining
errors are strictly my own.

References

1. Jouvelot, P., Gifford, D.K.: Algebraic reconstruction of types and effects. In: Conference Record of the Eighteenth Annual ACM SIGACT/SIGPLAN Symposium
on Principles of Programming Languages. ACM Press, New York (1991) 303-310
2. Talpin, J.P., Jouvelot, P.: Polymorphic type, region and effect inference. Journal

of Functional Programming 2 (1992) 245-271
3. Reynolds, J.C.: Syntactic control of interference. In: Conference Record of the Fifth

ACM Symposium on Principles of Programming Languages, New York, ACM Press
(1978) 39-46
4. Greenhouse, A., Boyland, J.: An object-oriented effects system. In Guerraoui,

R., ed.: ECOOP'99 -- Object-Oriented Programming, 13th European Conference.
Volume 1628 of Lecture Notes in Computer Science., Berlin, Heidelberg, New York,
Springer (1999) 205-229
5. Clarke, D., Drossopoulou, S.: Ownership, encapsulation and the disjointness of

type and effect. In: OOPSLA'02 Conference Proceedings--Object-Oriented Programming Systems, Languages and Applications. Volume 37., New York, ACM
Press (2002) 292-310
6. Flanagan, C., Abadi, M.: Types for safe locking. In Swierstra, S.D., ed.: ESOP'99

-- Programming Languages and Systems, 8th European Symposium on Programming. Volume 1576 of Lecture Notes in Computer Science., Berlin, Heidelberg,
New York, Springer (1999) 91-108
7. Boyapati, C., Rinard, M.: A parameterized type system for race-free Java programs. In: OOPSLA'01 Conference Proceedings--Object-Oriented Programming
Systems, Languages and Applications. Volume 36., New York, ACM Press (2001)
56-69
8. Boyapati, C., Lee, R., Rinard, M.: Ownership types for safe programming: preventing data races and deadlocks. In: OOPSLA'02 Conference Proceedings--ObjectOriented Programming Systems, Languages and Applications. Volume 37., New
York, ACM Press (2002) 211-230
9. Walker, D., Crary, K., Morrisett, G.: Typed memory management via static capabilities. ACM Transactions on Programming Languages and Systems 22 (2000)
701-771
10. Ishtiaq, S.S., O'Hearn, P.W.: BI as an assertion language for mutable

data structures. In: Conference Record of the Twenty-eighth Annual ACM
SIGACT/SIGPLAN Symposium on Principles of Programming Languages, New
York, ACM Press (2001) 14-26
11. Reynolds, J.C.: Intuitionistic reasoning about shared mutable data structure. In:

Millenial Perspectives in Computer Science, Palgrave (to appear) Draft dated July
28, 2000.

18
12. Reynolds, J.: Separation logic: a logic for shared mutable data structures. In: Logic

in Computer Science, Los Alamitos, California, IEEE Computer Society (2002) 55-
74
13. Boyland, J., Greenhouse, A.: MayEqual: A new alias question. Presented at

IWAOOS '99: Intercontinental Workshop on Aliasing in Object-Oriented Systems.
http://cuiwww.unige.ch/~ecoopws/iwaoos/papers/papers/greenhouse.ps.gz
(1999)
14. Steensgaard, B.: Points-to analysis in almost linear time. In: Conference Record

of the Twenty-third Annual ACM SIGACT/SIGPLAN Symposium on Principles
of Programming Languages, New York, ACM Press (1996) 32-41
15. Wadler, P.: Linear types can change the world! In Broy, M., Jones, C.B., eds.:

Programming Concepts and Methods. Elsevier, North-Holland (1990)
16. O'Hearn, P.W., Takeyama, M., Power, A.J., Tennent, R.D.: Syntactic control of

interference revisited. In: MFPS XI, conference on Mathematical Foundations of
Program Semantics. Volume 1., Elsevier (1995)
17. Smith, F., Walker, D., Morrisett, J.G.: Alias types. In Smolka, G., ed.: ESOP'00

-- Programming Languages and Systems, 9th European Symposium on Programming. Volume 1782 of Lecture Notes in Computer Science., Berlin, Heidelberg,
New York, Springer (2000) 366-381
18. Sagiv, M., Reps, T., Wilhelm, R.: Parametric shape analysis via 3-valued logic. In:

Conference Record of the Twenty-sixth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, New York, ACM Press (1999)
105-118
19. Morrisett, G., Felleisen, M., Harper, R.: Abstract models of memory management.

In: Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture (FPCA'95), New York, ACM Press
(1995) 66-77
20. Boyland, J., Noble, J., Retert, W.: Capabilities for sharing: A generalization of

uniqueness and read-only. In Knudsen, J.L., ed.: ECOOP'01 -- Object-Oriented
Programming, 15th European Conference. Volume 2072 of Lecture Notes in Computer Science., Berlin, Heidelberg, New York, Springer (2001) 2-27
21. Walker, D., Morrisett, G.: Alias types for recursive data structures. In: Types in

Compilation: Third International Workshop, TIC 2000. Volume 2071 of Lecture
Notes in Computer Science., Berlin, Heidelberg, New York, Springer (2001) 177-
206
22. DeLine, R., F"ahndrich, M.: Enforcing high-level protocols in low-level software.

In: Proceedings of the ACM SIGPLAN '01 Conference on Programming Language
Design and Implementation. Volume 36., New York, ACM Press (2001) 59-69
23. F"ahndrich, M., DeLine, R.: Adoption and focus: Practial linear types for imperative programming. In: Proceedings of the ACM SIGPLAN '02 Conference on
Programming Language Design and Implementation. Volume 37., New York, ACM
Press (2002) 13-24
24. Ross, J.L., Sagiv, M.: Building a birdge between pointer aliases and program

dependencies. In Hankin, C., ed.: ESOP'98 -- Programming Languages and Systems, 7th European Symposium on Programming. Volume 1381 of Lecture Notes
in Computer Science., Berlin, Heidelberg, New York, Springer (1998) 221-235
25. Rugina, R., Rinard, M.C.: Pointer analysis for structured parallel programs. ACM

Transactions on Programming Languages and Systems 25 (2003) 70-116

18a
A Technical matter for "Checking Interference with

Fractional Permissions" (SAS 2003)

Definition 1. Two memories u and u0 are isomorphic (written u z. u0) if andonly if a 1-1 and onto function

' exists on the set of locations ( ' l = ' l0 ()
l = l0 ) such that the following conditions hold:

1. For all v 2 V, u0 v = '(u v);2. Dom

u0L = '(Dom uL);3. For all

l 2 Dom uL, u0L(' l) = uL l

These conditions in particular imply that the stores have the same integers forvariables:

u(u v) = u0(u0 v).

Lemma 1. The relation z. is an equivalence relation.

Proof. reflexivity Obvious (' is the identity function).symmetricity Given

u1 z. u2 with 1-1 function ', the relation u2 z. u1 can beproved using
'0 = '-1:1.
u1 v = '-1('(u1 v)) = '-1(u2 v).2. Dom

u1L = '-1(Dom u2L).3. Let
l 2 Dom u2, then by the second condition, l = ' l0 for some l0 2Dom

u1. Thus u1('-1 l) = u1(l0) = u2(' l0) = u2 l.transitivity Given

u1 z. u2 z. u3 with 1-1 functions '12 and '23, u1 z. u3 canbe proven using
' = '12 s' '23, that is, ' l = '23('12 l).1.
u3 v = '23(u2 v) = '23('12(u1 v)) = ' v.2. Dom

u3L = '23(Dom mu2L) = '23('12(Dom u1L)) = '(Dom u1L).3.
u3 l = u2('23 v) = u1('12('23 v)) = u1(' v).

Lemma 2. For any statement or expression x not skip, true, false or aninteger constant, evaluation can proceed one step in any memory

u: hu, xi !gh
u0, x0i.

Proof. We prove by induction on x:
v:=new Progress is immediate since uL is a finite map and L is infinite: x0 =

skip.
v:=v0 Progress to skip is immediate since all memories are complete functionson

V .
*v:=e If e isn't an integer constant, the result follows from the inductive hy-pothesis. Otherwise the result follows since

uV is a complete function.
s1;s2 If s1 = skip, the result follows immediately, otherwise it follows by in-duction.

s1||s2 If both s1 = s2 = skip, progress to skip is immediate. Otherwise theresult follows by induction.
if b then s1 else s2 If b is a boolean constant, progress to s1 or s2 is imme-diate. Otherwise the result follows by induction.
call p Immediate, since evaluation is unconditional.

18b
e1+e2 If both e1 and e2 are integer constants, progress to an integer constant isimmediate. Otherwise it follows by induction.
*e Progress to an integer constant is immediate because memories have no dan-gling pointers:

u(u v) will be defined.

Progress irrespective of typing depends upon the lack of dangling pointers. If anextension wishes to permit dangling pointers, progress will only be possible in

typed (permission-checked) programs.Expression evaluation yields the same result in isomorphic memories:

Lemma 3. Suppose we have two isomorphic memories u1 z. u2, then if hu1, ei !h

u1, e0i then hu2, ei ! hu2, e00i and e0 = e00. Similarly, if hu1, bi ! hu1, b0i, thenh
u2, bi ! hu2, b00i, and b0 = b00.

Proof. We prove by structural induction over the form of the expression. Weprove for the following cases:

v==v0 Here b0 = (u1 v = u1 v0), and thus b00 = (u2 v = u2 v0) = ('(u1 v) =

'(u1 v0)) = (u1 v = u1 v0) = b0.
i!=0 (Trivial since memory is not involved.)
e!=0 (Follows immediately using the inductive hypothesis.)
b (Boolean constants are trivial since the antecedent cannot be met.)
n1+n2 (Trivial since memory is not used.)
e1+e2 (Follows immediately using the inductive hypothesis.)
*v Here e0 = u1(u1 v). Now u2 v = '(u1 v) and even if dangling pointers werepermitted, we would still have

u2 v 2 Dom u2 since u1(u1 v) is defined andthus
u1 v 2 Dom u1 and thus by the second condition for isomorphicityDom
u2 = '(Dom u1) 3 '(u1 v). Thus u2(u2 v) is defined and by the thirdcondition of isomorphicity

u2(u2 v) = u2('(u1 v)) = u1(u1 v) = e0, and soh
u2, ei ! hu2, e0i.
n1 (Trivial since the antecedent cannot be satisfied.)

If we use the same sequence of derivations when evaluating statements, isomor-phicity is preserved:

Lemma 4. Suppose we have two isomorphic memories u1 z. u2 and a statement
s that can be evaluated in the first memory ( hu1, si !g hu01, s0i), then there existsan isomorphic resulting memory (

u02 z. u01) for evaluation in the second memory( h
u2, si !g hu02, s0i).

Proof. We prove the result by structural induction over s. We perform a caseanalysis on the form of

s:

Newv The fact that evaluation can proceed in u2 is immediate since new state-ments evaluate to

skip in one step. let l1 and l2 be the two new locationsadded in the respective evaluations. Then we must prove (

u01 = u1[v 7!
l1, l1 7! 0]) z. (u02 = u2[v 7! l2, l2 7! 0]). If ' is the map that shows u1 z. u2,then if

' l1 = l2, then let '0 = '. Otherwise it must be '-1 l2 62 Dom u1 (bythe second condition of isomorphicity). Then let

'0 = '[l1 7! l2, '-1 l2 7!
' l1. Checking the isomorphicity conditions:

18c
1. u02 v = l2 = '0 l1 = '0(u01 v). If v0 6= v, then u02 v0 = u2 v0 = '(u1 v0) =

'(u01 v0) and since memories are not allowed to have dangling pointers
u01 v0 must be in the domain of u0L and thus cannot be l1 or '-1 l2 andso

'(u01 v0) = '0(u01 v0) satisfying the first isomorphicity condition.
2. Dom u02 = {l2} [ Dom u2 = {' l1} [ '(Dom u1) = '(Dom u01)
3. Let l 2 Dom u01. If l = l1, then u02(' l) = u02 l2 = 0 = u01 l. Otherwise,

l 6= l1, and thus u02(' l) = u2(' l) = u1 l = u01 l.

v:=v0 We need only verify that u01 = u1[v 7! u1 v0] z. u02 = u2[v 7! u2 v0]. If

v = v0, this is trivial. Otherwise, we check the three isomorphicity conditions:

1. For v itself, u02 v = u2 v0 = '(u1 v0) = '(u01 v0). For other v00 6= v,

u02 v00 = u2 v00 = '(u1 v00) = '(u01 v00).
2. The domains are unchanged so this condition is satisfied trivially.
3. The mappings for locations are unchanged by evaluation of v:=v0, andthus this condition is still met.

*v:=e If e is an integer constant i, then s evaluates immediately to skip andwe need only check that

u01 = u1[(u1 v) 7! i] z. u02 = u2[(u2 v) 7! i]

1. The first condition depends only on the memory for variables and thusis unchanged.

2. The second condition depends only on the domains for locations, andthis is unaffected since

u? v is not permitted to be a dangling pointer.
3. Let l = u1 v. Since u1 z. u2, we have u2 v = ' l. Thus u02(' l) = i = u01(l).For other Dom

u01 3 l0 6= l, u02(' l0) = u2(' l) = u1(l) = u01(l).

Otherwise, the result follows using Lemma 3.
skip Trivial since the antecedent cannot be met.
s1;s2 If s1 = skip, then s0 must be s2 and the memory is unchanged and thusthe result is established immediately. Otherwise, we use the inductive hypothesis on s1 to get s01 and u01 z. u02. This gives us hui, s1;s2i !g hu0i, s01;s2iand we are done.
skip||skip In this case hui, si !g hui, skipi and we are done.
s1||s2 Suppose s0 = s01||s2 where hu1, s1i !g hu01, s01i. Then by the inductivehypothesis, we have h

u2, s1i !g hu02, s01i with u01 z. u02. From this followsimmediately h
u2, s1||s2i !g hu02, s01||s2i and we are done. Otherwise if theright part is evaluated first, analogous reasoning applies.

if true then s1 else s2 The result follows immediately since s0 must be s1and

u01 = u1. And similarly for code
if b then s1 else s2 where hu1, bi ! hu1, b0i. The result follows immediatelyusing Lemma 3.

call p The result follows immediately since hui, call pi !g hui, g pi with un-changed memories.

The lack of dangling pointers is crucial to the proof of this lemma: if in the mem-ories some variable

v has a dangling pointer: ui v 62 Dom ui, then the statement
v0:=new for some other variable v0 could perhaps result in v and v0 being aliases,or perhaps not, breaking isomorphicity.

18d
Definition 2. The parallel composition (written ? ] ?0) of two substitutions ondisjoint domains, and the sequential composition (written

? s' ?0) are defined asfollows:

(? ] ?0) x = ! ? x x 2 Dom ??0 x x 2 Dom ?0

(? s' ?0) x = ?0(? x)
Lemma 5. Given \Delta 0 u"" \Delta , then

\Delta  ` ! loc-var ) \Delta 0 ` ! loc-var
\Delta  ` r' base-perm ) \Delta 0 ` r' base-perm

\Delta  ` z. frac ) \Delta 0 ` z. frac
\Delta  ` \Pi  perms ) \Delta 0 ` \Pi  perms

Proof. Straightforward structural induction.

Well-formedness is preserved under application by well-formed substitutions:
Lemma 6. Given ` ? : \Delta  ! \Delta 0 and \Delta  [ \Delta 00 ` \Pi  perms then \Delta  [ \Delta 0 `
? \Pi  perms.

Proof. Straightforward structural induction.
Composition preserves well-formedness under straightforward conditions:
Lemma 7. Let ` ?1 : \Delta 1 ! \Delta 01 and ` ?2 : \Delta 2 ! \Delta 02. Then

- If \Delta 1 " \Delta 2 = ; then ` ?1 ] ?2 : (\Delta 1 [ \Delta 2) ! (\Delta 01 [ \Delta 02)- If

\Delta 01 t, \Delta 2 then ` ?1 s' ?2 : \Delta 1 ! \Delta 02

Proof. Straightforward proof by induction.

We now prove several technical lemmas that apply to proof trees using therules in Figure 4. First one that ensures we have we don't lose bindings and thus

maintain a well-formed environment:
Lemma 8. If we can permission-check s in environment \Delta ; \Pi  yielding a re-sulting environment

\Delta 0; \Pi 0 ( \Delta ; \Pi  `! s ) \Delta 0; \Pi 0), and the first environmentwas well-formed (
\Delta  ` \Pi  perms) then the new bindings \Delta 0 - \Delta  are all fresh,no bindings are lost (

\Delta  t, \Delta 0) and the resulting environment is well-formed(
\Delta 0 ` \Pi 0 perms).

Proof. Straightforward structural induction.

We also have a weakening lemma:
Lemma 9. If we can permission-check s in environment \Delta ; \Pi  yielding a result-ing environment

\Delta 0; \Pi 0 ( \Delta ; \Pi  `! s ) \Delta 0; \Pi 0), then we can permission-check sin an environment with more variables and more permissions (

\Delta  [ \Delta e; \Pi , \Pi e `!
s ) \Delta 0 [ \Delta e; \Pi 0, \Pi e).

18e
Proof. We prove the transformation using induction over the height of the prooftree. We perform a case analysis on the rule at the case of the tree:

New,Copy,Update,Skip,Call The extra variables and permissions pass throughinstances of any of these rules unchanged.
Seq Assume the proof tree has the form:

...

\Delta ; \Pi  `! s1 ) \Delta 0; \Pi 0 ?

1

...

\Delta 0; \Pi 0 `! s2 ) \Delta 00; \Pi 00 ?

2

\Delta ; \Pi  `! s1; s2 ) \Delta 00; \Pi 00 Seq
By induction, we can push extra variables \Delta e and permissions \Pi e into bothbranches, and form the tree:

...
\Delta  [ \Delta e; \Pi , \Pi e `! s1 ) \Delta 0 [ \Delta e; \Pi 0, \Pi e ?

1

...

\Delta 0 [ \Delta e; \Pi 0, \Pi e `! s2 ) \Delta 00 [ \Delta e; \Pi 00, \Pi e ?

2

\Delta  [ \Delta e; \Pi , \Pi e `! s1; s2 ) \Delta 00 [ \Delta e; \Pi 00, \Pi e Seq
Par Assume the proof tree has the form:

...

\Delta ; \Pi 1 `! s1 ) \Delta 01; \Pi 01 ?

1

...

\Delta ; \Pi 2 `! s2 ) \Delta 02; \Pi 02 ?

2

\Delta ; \Pi 1 `! s1||s2 ) \Delta 01 [ \Delta 02; \Pi 01, \Pi 02 Par
We perform a similar transformation but only into the one branch, formingthe tree:

...
\Delta ; \Pi 1 `! s1 ) \Delta 01; \Pi 01 ?

1

...

\Delta  [ \Delta e; \Pi 2, \Pi e `! s2 ) \Delta 02 [ \Delta e; \Pi 02, \Pi e ?

2

\Delta  [ \Delta e; \Pi 1, \Pi 2, \Pi e `! s1||s2 ) \Delta 01 [ \Delta 02 [ \Delta e; \Pi 01, \Pi 02, \Pi e Par
If The condition can be checked with extra variables or permissions, and byinduction, the extra variables and permissions can be passed through each

branch. Finally the substitutions ` ?i : \Delta 3 ! \Delta  can be trivially consideredto be of type

\Delta 3 ! (\Delta  [ \Delta e). Since Delta3 are fresh, we have (?i \Pi 3, \Pi e) =
?i(\Pi 3, \Pi e).

We also have a substitution lemma:
Lemma 10. If we have a well-typed program ` g : ! and a well-typed statement
\Delta ; \Pi  `! s ) \Delta 0; \Pi 0 and a substitution ` ? : \Delta 1 ! \Delta 2, and \Delta 1 t, \Delta , then thestatement can be typed in the substituted environment:

\Delta 2 [ (\Delta  - \Delta 1); ? \Pi  `!
s ) \Delta 2 [ (\Delta 0 - \Delta 1); ? \Pi 0, that is, ?(\Delta ; \Pi ) `! s ) ?(\Delta 0; \Pi 0)

18f
Proof. The type context part of the result is clear because of Lemma 6. We provethe remainder by induction over all kinds of rules in the proof tree (including
those for boolean and integer expressions). We use a case analysis on the ruleapplied at the root:

New

! fresh
\Delta ; 1v : ptr(!0), \Pi 1 `! v:=new ) {!} [ \Delta ; 1!, 1v : ptr(!), \Pi 1 New

Here ? \Pi  = 1v : ptr(? !0), ? \Pi 1. These permissions permit us to use Newto type the statement with output permissions 1

!, 1v : ptr(!), ? \Pi 1 = ? \Pi 0since
! cannot be in the domain of ? since it is fresh.Copy

\Delta ; 1v : ptr(!), z.v0 : ptr(!0), \Pi 1 `! v:=v0 ) \Delta ; 1v : ptr(!0), z.v0 : ptr(!0), \Pi 1 Copy
Here ? \Pi  = 1v : ptr(? !), (? z.)v0 : ptr(? !0), ? \Pi 1 which permits us to apply
Copy to get output permissions 1v : ptr(? !0), (? z.)v0 : ptr(? !0), ? \Pi 1 thatis

? \Pi 0.Update

\Delta ; z.v : ptr(!), 1!, \Pi 1 ` e : Int
\Delta ; z.v : ptr(!), 1!, \Pi 1 `! *v:=e ) \Delta ; z.v : ptr(!), 1!, \Pi 1 Update

Here ? \Pi  = (? frac)v : ptr(? !), 1? rho where permits us to apply Updateto get the same permissions out.
Skip Trivial.
Seq Follows by induction.
Par By induction.If

\Delta ; \Pi  ` b : Bool \Delta ; \Pi  `! s1 ) \Delta 01; ?1 \Pi 3 \Delta ; \Pi  `! s2 ) \Delta 02; ?2 \Pi 3
\Delta 3 fresh \Delta  [ \Delta 3 ` \Pi 3 perms ` ?1 : \Delta 3 ! \Delta 01 ` ?2 : \Delta 3 ! \Delta 02

E `! if b then s1 else s2 ) \Delta  [ \Delta 3; \Pi 3 If

By the definition of substitution \Delta i; ?i \Pi 3 = ?i(\Delta  [ \Delta 3; \Pi 3) = ?i E0. Byinduction, we obtain the following:

? E ` b : Bool
? E `! s1 ) ?(?1 E0)

? E `! s2 ) ?(?2 E0)
Each ?i makes substitutions only for x 2 \Delta 3, and thus we can define
sigma0i x = ?(?i x) and have ?(?i E0) = ?0i(? E0) with a well-types ?i, andthus we can apply

If to achieve the desired result.

18g
Call

! p = 8\Delta 01.\Pi 1 ! 9\Delta 02.?2 \Pi 3
\Delta 3 fresh ` ?1 : \Delta 01 ! \Delta  ` ?2 : \Delta 3 ! \Delta 02

\Delta ; ?1 \Pi 1, \Pi 4 `! call p ) \Delta  [ \Delta 3; ?1 \Pi 3, \Pi 4 Call

Let \Pi 2 = ?2 \Pi 3 be the output permissions for the procedure. Now ? \Pi  =
?(?1 \Pi 1), ? \Pi 4 = (?1s'?) \Pi 1, ? \Pi 4 has the form needed to apply Call gettingoutput permissions (

?1 s' ?) \Pi 3, ? \Pi 4 = ? (?1 P i3), ? \Pi 4 = ?(?1 \Pi 3, \Pi 4) =
? \Pi 0 which was to be proved.Eq

\Delta ; z.1v1 : ptr(!1), z.2v2 : ptr(!2), \Pi 1 ` v1 == v2 : Bool Eq
Here ? \Pi  = (? z.1)v1 : ptr(? !1), (? z.2)v2 : ptr(? !2), ? \Pi 1 permitting us toapply

Eq with the same result.
NotEq Direct from the inductive hypothesis.
Bool Trivial.
Plus Direct from the inductive hypothesis.Deref

\Pi  = z.v : ptr(!), z.0!, \Pi 1

\Delta ; \Pi  ` *v : Int Deref

Here ? \Pi  = (? z.)v : ptr(? !), (? z.0)(? !), ? \Pi 1 permits us to apply Deref toachieve the desired result.
Int Trivial.
Lemma 11. If A~ " is defined, it is in the range (0, 1). If A~ z. is defined, it is inthe range (0

, 1].

Proof. Straightforward proof by induction using mathematical properties.

Environment and permission equivalence have no effect on the definition of
A~ \Pi :

Lemma 12. If we have \Delta ; \Pi  t^ \Delta ; \Pi 0 and Dom A~ = \Delta  then A~ \Pi  = A~ \Pi 0.

Proof. We consider each equivalence rule in turn and sketch why it has no effecton the result:

*, \Pi  t^ \Pi  The constant function [* 7! 0] is the identity for functional addition.
\Pi 1, \Pi 2 t^ \Pi 2, \Pi 1 Functional addition is commutative.
\Pi 1, (\Pi 2, \Pi 3) t^ (\Pi 1, \Pi 2), \Pi 3 Functional addition is associative{

z} [ \Delta ; zij, (1 - z)ij, \Pi  t^ {z} [ \Delta ; ij, \Pi  Since z is in the type context, it willbe in the domain of

A~, and thus we can use the distributive law of realmultiplication over real addition.

""0 t^ "0" Real multiplication is commutative.
"("0"00) t^ (""0)"00 Real multiplication is associative.

18h
Consistency with the concatenation of permissions implies the consistency ofeach part:
Lemma 13. If \Delta ; \Pi 1, \Pi 2 ` u ok then \Delta ; \Pi 1 ` u ok
Proof. Obvious.

The following lemma formalizes the idea that writes cannot occur in parallelwith reads or other writes:

Lemma 14. If we have an environment E = (\Delta ; \Pi 1, \Pi 2) and a consistent mem-ory

E ` u ok with type variable mapping A~, then if (A~ \Pi 1) x = 1 for some vari-able or location

x, then (A~ \Pi 2) x = 0. In other words, it is not possible to rewrite
\Pi 2 to include permission to observe x: \Pi 2 6t^ z.x . . . , \Pi 02.

Proof. Suppose we have such a (A~ \Pi 1) x = 1. Then (A~ \Pi ) x = (A~ \Pi 1) x +(

A~ \Pi 2) x = 1 + (A~ \Pi 2). But the function A~ \Pi 2 returns a non-negative number(as can be seen by its construction), and thus the only way that we could have

Rng A~ \Pi  t, [0, 1] is to have (A~ \Pi 2) x = 0. Furthermore, it could not be possibleto rewrite

\Pi 2 to include a permission z.x . . . because (A~ \Pi 2) x >= A~ z. > 0 wherethe final inequality is from Lemma 11.

We have preservation for expressions as a separate lemma:
Lemma 15. If we have an expression x E ` x : # (where # 2 {Int, Bool}) whichcan be evaluated in some memory

u hu, xi !g hu, x0i, then types will be preserved
E ` x0 : # .

Proof. Obvious case analysis.
Lemma 16. If we have a well-typed program g ( ` g : !) and a statement s thatpermission-checks in an well-formed environment

E = (\Delta ; \Pi ) (\Delta  ` \Pi  permsand
E `! s ) E00) (where E00 = (\Delta 00; \Pi 00)) and a memory u that is consistentwith the environment (

E ` u ok), then for any evaluation (hu, si !g hu0, s0i),the resulting memory
u0 is consistent in an environment E0 ( E0 ` u0 ok) suitablefor permission-checking

s0(E0 `! s0 ) ? E00) for some well-formed substitution`
? : (\Delta 00 - \Delta ) ! \Delta 000 for some \Delta 000. (In other words, some of the newlyintroduced type variables may be substituted, but none of the existing ones.)

Proof. We strengthen the statement to prove by adding three extra results asfollows:
For all g, !, E = (\Delta ; \Pi ), s, E00, u, A~, u0, s0where

1. ` g : !2.

\Delta  ` \Pi  perms3.
E `! s ) E004.
E ` u ok with A~, that is(a)

\Delta  = Dom A~(b) Rng

A~ \Pi  t, [0, 1](c)
A~; u ` \Pi  consistent5. h
u, si !g hu0, s0i

Then 9E0 = (\Delta 0; \Pi 0), A~0, ? where

10. ` ? : (\Delta 00 - \Delta ) ! \Delta 00020.

E0 `! s0 ) ? E0030.
\Delta 0 u"" \Delta 40.
E0 ` u0 ok with A~0, that is(a0)

\Delta 0 = Dom A~0(b0) Rng

A~0 \Pi 0 t, [0, 1](c0)
A~0; u0 ` \Pi 0 consistent50.
A~0 |\Delta = A~60. (

A~0 \Pi 0)Dom u = A~ \Pi 70. (
A~ \Pi ) x < 1 ) u0 x = u x

18i
We prove by structural induction over the permission-check of s. We perform acase analysis on the root of the proof tree:

New s = v:=new

! fresh
\Delta ; 1v : ptr(!0), \Pi 1 `! v:=new ) {!} [ \Delta ; 1!, 1v : ptr(!), \Pi 1 New

Let l be the newly allocated location (l 62 Dom uL). We have then u0 = u[v 7!
l, l 7! 0]. We prove the results with E0 = E00, A~0 = A~[! 7! l], ? = [! 7! !].10. Straightforward with

\Delta 000 = \Delta 00.20. Immediate since
s0 = skip.30. Immediate since
\Delta 0 = \Delta  [ {!}.40. (a0) Dom
A~0 = Dom A~ [ {!} = \Delta  [ {!} = \Delta 0(b0) Now

! is fresh so it cannot appear in \Pi 1 and then A~0 \Pi 1 = A~ \Pi 1,and so we can compute Rng

A~0 \Pi 0 = Rng [l 7! 1] + [v 7! 1] + A~0 \Pi 1 =Rng [
l 7! 1] + A~ \Pi , and thus the range is fine as long as (A~ \Pi ) l = 0.Suppose

A~ \Pi  l > 0, then we must have z.!00 2 \Pi  where A~ !00 = l. Butthen by , we would have

A~ !00 2 Dom u which is a contradiction.(c0) Since
A~ ! = l 2 Dom u0, we have A~0; u0 ` 1! consistent. Also u0 v = land thus

A~0; u0 ` 1v : ptr(!) consistent. Now by 4 and Lemma 14,we get that

\Pi 1 cannot contain any permission z.v : ptr(!00) and thechanges in
u0 have no effect on checking consistency with \Pi 1. Simi-larly
! cannot appear in \Pi 1 because ! is fresh, and thus we achieve
A~0; u0 ` \Pi 1 consistent and so fulfill50. Follows immediately from definition of

A~0 since ! is fresh.60. As shown above
A~0 \Pi  = (A~ \Pi )[l 7! 1] and so we have the result.70. Immediate since

u0 changes only for l (not in the domain of A~ \Pi ) and v(for which we have

A~ v = 1.
Copy s = v:=v0

\Delta ; 1v : ptr(!), z.v0 : ptr(!0), \Pi 1 `! v:=v0 ) \Delta ; 1v : ptr(!0), z.v0 : ptr(!0), \Pi 1 Copy
Let l = u v. We have then u0 = u[v 7! l], E00 = E. We prove the results with
E0 = E00, A~0 = A~, ? = [] (the identity substitution).10. Trivial since

\Delta 00 - \Delta  = ;, ? = [].20. Immediate since

s0 = skip.30. Trivial since
\Delta 0 = \Delta .40. Since the permission fractions are unchanged in

E0, we need only prove
A~; u0 ` \Pi 0 consistent. Here u0 differs from u only for v. Now by Lemma 14
\Pi 1 must not include any permissions involving v, and thus A~; u0 `
\Pi  consistent follows immediately from A~; u ` \Pi  consistent. Similarly,we get

A~; u0 ` z.v0 : ptr(!0) consistent and A~ !0 = u v0 = l from A~; u `
z.v0 : ptr(!0) consistent. The final condition A~; u0 ` 1v : ptr(!0) consistentis satisfied since

A~ !0 = l = u0 v.50. Trivial since
A~0 = A~.60. Immediate since no fractions are changed in

\Pi 0.

18j
70. Immediate since the only change is for v.
Update s = *v:=e

E = (\Delta ; z.v : ptr(!), 1!, \Pi 1) E ` e : Int

E `! *v:=e ) E Update

Here we choose E0 = E, A~0 = A~, ? = []. If e is an addition or dereferenceexpression, then we have preservation immediately by Lemma 15 and the

additional items are trivially satisfied since u0 = u. Otherwise if e is aninteger constant

i u0 = u[l 7! i] where l = u v.10. Trivial

20. Trivial since s0 = skip.30. Trivial.
40. The consistency of u0 depends only on u0V and the domain of u0L, neitherof which are changed in evaluation, preservation also follows easily.
50. Trivial since A~0 = A~.60. Trivial since

\Pi 0 = \Pi 00 = \Pi .70. Straightforward since (

A~ \Pi ) v = 1, and v is the only place where u0 differsfrom
u.
Skip This case follows trivially since it is not satisfiable.
Seq s = s1; s2

E `! s1 ) E001 E001 `! s2 ) E00

E `! s1; s2 ) E00 Seq

If s1 = skip, then hu, si !g hu, s2i and we have E1 = E and thus can choose
E0 = E, A~0 = A~, ? = [] and achieve preservation immediately.Otherwise, by the inductive hypothesis applied to

s1, we have E01, A~01, ?1 thatmeet conditions (10-70) for
s1. We choose the same variables E0 = E01, A~0 =
A~01, ? = ?1 and thus the only remaining result to prove is which followsimmediately from the substitution lemma around the permission-check of

s1, that is, by the substitution lemma, we have ? E001 `! s2 ) ? E00, andthus

E0 `! s01;s2 ) ? E00
which was to be proved.Par

\Delta ; \Pi 1 `! s1 ) \Delta 001 ; \Pi 001 \Delta ; \Pi 2 `! s2 ) \Delta 002 ; \Pi 002

\Delta ; \Pi 1, \Pi 2 `! s1||s2 ) \Delta 001 [ \Delta 002 ; \Pi 001 , \Pi 002 Par

If s1 = s2 = skip, then preservation is immediate with E0 = E = E00, A~0 =
A~, ? = [].Otherwise, suppose we have the evaluation h

u, s1||s2i !g hu0, s01||s2i whereh
u, s1i !g hu0, s01i.By Lemma 2.3, we have

\Delta ; \Pi 1 ` u ok using the same A~ and thus wecan apply for inductive hypothesis for

s1 using E1 = (\Delta ; \Pi 1) to obtain
E01 = (\Delta 01; \Pi 01), A~01, ?1 that satisfy conditions (10-70). Then we choose E0 =(

\Delta 01; \Pi 01, \Pi 2), A~0 = A~01 ? = ?1:

18k
10. Trivial from the inductive result.20. By Lemma 8, the variables in

\Delta 002 - \Delta  are fresh, and thus ? must haveno effect on variables in
\Delta 002 and thus ? \Pi 002 = \Pi 002 . This equality plus theweakening lemma(Lemma 9) enable us to construct the proof:

\Delta 0; \Pi 01 `! s1 ) ?(\Delta 001 ; \Pi 001 ) \Delta 0; \Pi 2 `! s2 ) ?(Delta002 ; \Pi 002 )

\Delta 0; \Pi 01, \Pi 2 `! s1||s2 ) ?(\Delta 001 [ \Delta 002 ; \Pi 001 , \Pi 002 ) Par

30. Trivial since \Delta 0 = \Delta 01 u"" \Delta .40. (a0) Dom

A~0 = Dom A~01 = Delta01(b0) Now
A~0 \Pi 0 = A~0 \Pi 01 + A~0 \Pi 2 = A~0 \Pi 01 + A~ \Pi 2 where the latter equalityis due to condition 50 from the inductive use and the fact that

\Pi 2is well-formed. Now consider (
A~0; \Pi 0) x for some x 2 Dom u. Bycondition 60 on the inductive use, we get (

A~0 \Pi 01) x = (A~ \Pi 1) x andthus by our original condition 44b, the result must be in the range

0 to 1. For some other x 62 Dom u0, we must have (A~ \Pi 2) x = 0 andthus the inductive condition 40b0b0 suffices to show (

A~0; \Pi 0) x 2 [0, 1].(c0) Here we need to check if
\Pi 2 t^ z.v : ptr(!), . . . we have A~0 ! = u0 v.Now by well-formedness and inductive condition 50, we get

A~0 ! =
A~ !. Also (A~ \Pi 2) v = A~ z. > 0 and thus by Lemma 14, (A~ \Pi 1) v <1 and so by inductive condition 70 we have

u0 v = u v, and thusthe consistency condition converts to
A~ ! = u v which follows fromrequirements for preservation.

50. Follows by induction.60. Follows by induction.
70. Follows by induction.The case for

s2 being evaluated is analogous.
If s = if b then s1 else s2

\Delta ; \Pi  ` b : Bool \Delta ; \Pi  `! s1 ) \Delta 1; ?1 \Pi 3 \Delta ; \Pi  `! s2 ) \Delta 2; ?2 \Pi 3
\Delta 3 fresh \Delta  [ \Delta 3 ` \Pi 3 perms ` ?1 : \Delta 3 ! \Delta 1 ` ?2 : \Delta 3 ! \Delta 2

E `! if b then s1 else s2 ) \Delta  [ \Delta 3; \Pi 3 If

If b is not a boolean constant, then we have preservation directly by usingLemma 15. Otherwise since the memory is unchanged, we can use

E0 = Eto keep consistency. If the "true" branch is taken, note that since

?1(\Delta  [
\Delta 3; \Pi 3) = (\Delta 1; ?1\Pi 3), we have preservation immediately with ? = ?1. Ifthe "false" branch is taken, the same reasoning applies.

Call s = call p

! p = 8\Delta 1.\Pi 1 ! 9\Delta 2.?2 \Pi 3
\Delta 3 fresh ` ?1 : \Delta 1 ! \Delta  ` ?2 : \Delta 3 ! \Delta 2

\Delta ; ?1 \Pi 1, \Pi  `! call p ) \Delta  [ \Delta 3; ?1 \Pi 3, \Pi  Call

Here we can choose E0 = E and preserve memory consistency since thememory is unchanged. For preservation of permission-checking, the fact that

procedure p is well-typed yields the following facts:

\Delta 1; \Pi 1 `! g p ) \Delta 01; ? \Pi 2 \Delta 01 " \Delta 2 = ; ` ? : \Delta 2 ! \Delta 01

18l
where \Pi 2 = ?2 \Pi 3. We can use the first fact and the substitution lemma,and the weakening lemma to prove

\Delta ; ?1 \Pi 1, \Pi  `! g p ) \Delta  [ (\Delta 01 - \Delta 1); (?2 s' ? s' ?1)\Pi 3, \Pi 
Now define ?3 with domain \Delta 3 as ?3 x3 = (?2 s'? s'?1)x3. By its construction,it is clear `

?3 : \Delta 3 ! (\Delta [(\Delta 01 -\Delta 1)). Now for x 62 \Delta 3, (?2 s'? s'?1)x = ?1 x.Thus (
?2 s' ? s' ?1)\Pi 3 = (?1 ] ?3)\Pi 3. Moreover since ` ?1 : \Delta 1 ! \Delta  and
\Delta  " \Delta 3 = ; (on account of freshness) we can apply ?1 first and then ?3 and
?3 \Pi  = \Pi  yielding finally:

\Delta ; ?1 \Pi 1, \Pi  `! g p ) ?3(\Delta  [ \Delta 3; ?1 \Pi 3, \Pi )
as required.
Definition 3. We say that two statements s1 and s2 are non-interfering inan environment

E (written E `! s1#s2) if their parallel composition can bepermission-checked in the environment (

E `! s1||s2 ) E0). Non-interferenceis extended to a boolean expression
b using S(b) = if b then skip else skipand to an integer expression
e using S(e) = if e!=0 then skip else skip.For any statement
s, let S(s) = s.

The kernel of the proof of non-interference is that one can re-order adjacentpairs of derivations:

Lemma 17. If in a well-typed program ( ` g : !), we have two non-interferingstatements or expressions

E `! x1#x2 and a consistent memory u ( E ` u ok)and we can evaluate either one step ( h

u, x1i !g hu1, x01i and hu, x2i !g hu2, x02i),then we can reduce each in the other's output memory with the same new form

( hu1, x2i !g hu12, x02i and hu2, x1i !g hu21, x01i) and the resulting memoriesare isomorphic (

u12 z. u21).

Proof. We prove the result inductively over x1 and x2 together. Now if bothevaluations have no effect on memory,

u1 = u2 = u, the result follows immedi-ately. Moreover, if the evaluation of
x1 not only leaves the memory unchanged,but does not even depend on memory, that is

x1 is pure (8u0hu0, x1i !g hu0, x01i),then we have
u1 = u and thus u12 = u2 and u21 = u2, and so the result fol-lows. Similarly if

x2 is pure, we are done. Furthermore if the memory effectsand dependencies of

x1 or x2 are indirect, because of subexpressions or sub-statements, the result follows using the inductive hypothesis. Finally, because

the result is symmetric, we need only consider one direction of reordering. Thuswe only have twelve cases to consider: the three primitive statements that update
memory (allocation, copying and update) against each other and against the twoother primitives that depend on memory (pointer equality and dereference). In
the following case analysis, assume E = (\Delta ; \Pi 1, \Pi 2), \Delta ; \Pi i `! S(xi) ) \Delta 0i; \Pi 0i,and

A~ is the witness to E ` u ok:

v1:=new#v2:=new Let l1 and l2 be the two new locations (possibly the samelocation). Here

u1 = u[v1 7! l1, l1 7! 0], u2 = u[v2 7! l2, l2 7! 0]. Now since

18m
\Pi 1 = 1v1 : ptr(!01), . . ., (A~ \Pi 1) v1 = 1, by Lemma 14 \Pi 2 cannot include anypermissions to modify

v1 and thus v2 6= v1. Now it is trivial to evaluate
x1 = v1:=new in u02 and vice versa to x01 = x02 = skip. We can choosethe locations to allocate: if

l1 = l2, then let l01 = l02 62 {l1 = l2} [ Dom uL,otherwise let
l01 = l1, and l02 = l2. We end up with the following two memories:

u12 = u[v1 7! l1, v2 7! l02, l1 7! 0, l02 7! 0]
u21 = u[v1 7! l01, v2 7! l2, l01 7! 0, l2 7! 0]

If l01 = l1 6= l2 = l02 then the two memories are not just isomorphic, but indeedequal. Otherwise

l01 = l02 6= l1 = l2 and the two memories are isomorphicusing the one-to-one mapping that maps

l1 to l01 and vice versa, but keepsall other locations the same.

v1:=new#v2:=v02 Similar as the previous case, by Lemma 14, we determine v1 6=

v2, v1 6= v02 and thus by a similar argument the statements can be evaluatedin either order.

v1:=new#*v2:=n2 (Similar.)
v1:=new#v2==v02 (Similar.)
v1:=new#*v2 (Similar)
v1:=v01#v2:=v02 Similarly, we find by Lemma 14 that v1 6= v2, v1 6= v02, v01 6= v2(although

v01 = v02 is possible--these variables are only read).
v1:=v01#*v2:=n2 (Similar, as all following cases:)
v1:=v01#v2==v02
v1:=v01#*v2
*v1:=n1#*v2:=n2
*v1:=n1#v2==v02
*v1:=n1#*v2

The reordering lemma allows us to prove a one-step non-determinism lemma:
Lemma 18. Given a well-typed program ( ` g : !) and a permission-checkedstatement

E `! s ) E0 and a consistent memory u ( E ` u ok) and we havetwo different evaluation steps ( h

u, si !g hu0, s0i and hu, si !g hu00, s00i, where
s0 6= s00) then there exists an evaluation step to unify the two different results( h

u0, s0i !g hu12, s*i and hu00, s00i !g hu21, s*i) with isomorphic results ( u12 z.
u21).

Proof. NB: There is no need to prove this lemma for expressions since expressionevaluation is deterministic.

We prove by induction on the structure of s. Now the only constructs thatpermit non-determinism are sequential and parallel composition. In the former
case (s = s1;s2), the nondeterminism must come in the left branch (s0 = s01;s2,
s00 = s001 ;s2), and thus we can apply the inductive hypothesis to achieve a singleresult on the left (h

u0, s01i !g hu12, s*1i and hu00, s001 i !g hu21, s*1i with u12 z. u21.From this we can see

s* = s*1;s2 unifies the two evaluations for s.In the parallel composition case, either the two different evaluations each

operate on the same branch (in which case we can apply the inductive hypothesis

18n
in the same way as we just did for sequential composition) or else (assumingwithout loss of generality that the first evaluation reduces the left branch) we
have the following situation:

hu, s1||s2i !g hu0, s01||s2i hu, s1||s2i !g hu00, s1||s02i
Since E `! s1||s2 ) E0, we have E `! s1#s2 and thus we can apply Lemma 17to get h

u00, s1i !g hu21, s01i and hu0, s2i !g hu12, s02i where u12 z. u21 and thenapply
Par to get

hu0, s01||s2i !g hu12, s01||s02i hu00, s1||s02i !g hu21, s01||s02i
and we have the result with s* = s01||s02.

Finally we have our theorem of deterministic results for permission-checkedprograms:

Theorem 1. If we have a well-typed program g ( ` g : !) and a statement s thatpermission-checks in an environment

E ( E `! s ) E0) and a memory u1 thatis consistent with the environment (
E ` u1 ok), and s can be fully evaluated in

this memory in k steps ( hu1, si k!g hu*1, skipi) then for any isomorphic memory
u2 z. u1, any other evaluation sequence hu2, si !g hu02, s0i !g . . . terminates inexactly

k steps and has an isomorphic result u*2 z. u*1.

Proof. By Lemma 4, we can redo the first statement evaluation with u2 andachieve an isomorphic result

u*12. Thus since isomorphicity is transitive, we canassume a single starting memory

u = u1 = u2 without loss of generality.We prove the result by induction over

k. If k = 0, we must have s = skipand the result follows immediately. Otherwise, if

k = 1, then if the secondsequence starts with the same reduction, it terminates too in one step. If it were

to start with a different reduction (hu, si !g hu02, s0i where s0 6= skip), then byLemma 18, we would be able to form an evaluation h

u*1, skipi !g hu002, s00i whichis impossible. It is similarly impossible for the second sequence to terminate in

one step if the first does not.Otherwise assume

k > 1. The two evaluation sequences are

hu, si !g hu01, s01i !g . . . !g hu*1, skipi
and h

u, si !g hu02, s02i !g . . .

If s01 = s02, we can use the inductive hypothesis on the tail of each evaluation toachieve the result. Otherwise, we can apply Lemma 18 to form the following two

new evaluation sequences that share the same tail:

hu01, s01i%
g &gh
u, si hu00, s00i !g . . .&

g %gh

u02, s02i

18o
Now we apply the inductive hypothesis on the tail of the original evaluationsequence and the upper evaluation sequence shown here to determine that the
upper evaluation sequence must terminate in exactly k steps with an isomorphicresult, and thus the bottom evaluation sequence must also terminate in

k steps.Next Lemmas 18 and 4 ensure the two evaluation sequences in the diagram have

isomorphic results. Finally, we apply the inductive hypothesis again to the tail ofthe bottom evaluation sequence with the tail of the second sequence to achieve
the desired result.