

Subtyping Constrained Types

(Revised Draft)
Valery Trifonov\Lambda y Scott Smith\Lambda 
Department of Computer Science, Johns Hopkins UniversityBaltimore, MD 21218, USA

ftrifonov, scottg@cs.jhu.eduhttp://www.cs.jhu.edu/hog/

May 7, 1996

Abstract
A constrained type is a type that comes with a set of subtyping constraints on variables occurring in the type.Constrained type inference systems are a natural generalization of Hindley/Milner type inference to languages

with subtyping. This paper develops several subtyping relations on polymorphic constrained types of a generalform that allows recursive constraints and multiple bounds on type variables. We establish a full type abstraction
property that equates a novel operational notion of subtyping with a semantic notion based on regular trees. Thedecidability of this notion of subtyping is open; we present a decidable approximation. Subtyping constrained types
has applications to signature matching and to constrained type simplification. The relation will thus be a criticalcomponent of any programming language incorporating a constrained typing system.

1 Introduction
A constrained type is a type that is additionally constrained by a set of subtyping constraints on the free type variables.
An example is t ! intn ft ^ intg, a type of functions where the argument type variable t is constrained to be a subtype
of int. It is possible to perform let-polymorphic type inference for constrained types. Polymorphic type inference in
a setting with constraints produces type schemes of the form 8t1; : : : ; tn: o/ n C, which generalize the type schemes
8t1; : : : ; tn: o/ produced by the Hindley/Milner algorithm. Constrained type inference is strictly more general than
Hindley/Milner type inference. These and other reasons make constrained types worthy of study.

The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell [Mit84,
Mit91]. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous
other researchers have defined restricted forms of constraint inference system, including [MR85, FM88, Kae92,
BM96].

A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by
Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken
& Wimmers [AW93]. These constraint system are less restrictive than the previously cited formulations. For one,
recursive constraints such as t ^ t !intare legal. Additionally, both upper- and lower-bound constraints on variables
are allowed, and multiple bounds may be placed on a single variable (multiple bounds such as ft ^ o/1; t ^ o/2g are

\Lambda Partially supported by NSF grant CCR-9312433

yPartially supported by AFOSR grant F49620-93-1-0169

1

expressed equivalently as t ^ o/1 " o/2, where " is the type intersection operator of [AW93]). This extra flexibility
allowed in the constraint sets produces a more powerful, but computationally more complex, inference algorithm.

Our long-term goal is to apply the techniques of constrained types and constrained type inference to object-oriented
programming languages; previous results include [EST95b, EST95a]. Constrained types are particularly appropriate
for object-oriented programming languages: these types incorporate subtyping which is critical in an object-oriented
setting, and their greater flexibility gives a reasonable solution to the binary methods problem [BCC+96].

The objective of this paper is to address the problem of subtyping between polymorphic constrained type schemes:

8t1; : : : ; tn:o/ n C ^8 8t1; : : : ; tn:o/ 0 n C0
This relation has not received much attention in the literature. We develop several different relations. The "optimal"
form ^8obs may be characterized observationally by analogy with Morris/Plotkin contextual expression equivalence,
replacing expression contexts with proof contexts. We then define a semantic form ^8sem based on a regular tree
interpretation, and prove it is a good model by showing it is exactly ^8obs, a full type abstraction property. The ideal
model [MPS86] may also be used as a basis of a constrained type ordering ^8ideal [AWL94], but it is not fully abstract.
^8sem is a surprisingly complex relation: we leave open the question whether ^8sem = ^8obs is decidable, and develop
a powerful decidable approximation ^8dec.

There are at least two applications of this subtyping relation ^8. The first is separate compilation via modules
and functors, and the subsequent need for signature matching. To a first approximation, in a module system based on
Hindley/Milner style of type inference the program specifies a polymorphic type (signature) S for the parameter of a
functor F to allow uses of the parameter at different types (not possible for parameters of functions); the polymorphic
signature inferred for the actual argument M is then matched against S at the point of application F (M ). A functor
in a constrained type setting takes as argument a module of a polymorphic constrained type; signature matching is
thus the satisfaction of

8t1; : : : ; tn: o/module n Cmodule ^8 8t01; : : : ; t0m: o/functor arg n Cfunctor arg
Another important application of these subtyping relations is the justification of simplification operations on
constrained polymorphic types. In this case a proof is required that the simplified type is equivalent to the original
(i.e. both a subtype and a supertype).

In the process of defining these subtyping relations, other results of independent interest are derived. First, an
entailment relation K ` o/ ^ o/ 0 over simple types o/ is axiomatized. The set C is a system of arbitrary type constraints,
thus generalizing the system of [AC93] which only allows one upper, non-recursive bound of each variable C. We
define two reduced forms of constraint sets, constraint maps (kernel) and canonical maps, which are also of use as
more compact representations of constraint sets in algorithms such as type inference. Next, the subtyping relations
on constrained types are defined, and their relationship is established. Finally, soundness of a system of typing rules
with constrained types is proved by a simple method of reduction to soundness of a system without constrained types.
A principal typing property is established for our type inference algorithm.

In this paper we work over a simple language with only function, top, and bottom types to reduce clutter. However,
previous work [EST95b, EST95a] shows how state, records, variants, classes, and objects all may be incorporated
in a constrained type framework, and we explicitly avoid semantic tools (such as the ideal model of types [MPS86])
which lack a strong potential to generalize to such constructs.

We conclude this introduction with a remark about the duality between constrained type inference, where recursive
constraints and multiple bounds are allowed, and flow analysis algorithms. [PS96] establishes an isomorphism between
a certain kind of flow analysis [PS92] and a monomorphic version of the constrained type system studied in this paper:
the two systems accept precisely the same programs. Polymorphic constrained types are related to the idea of
polymorphic splitting found in the flow analysis of [JW95]. They add a notion of splitting the 0CFA flow analysis
at let-constructs, inspired by Hindley/Milner let-polymorphism1. The main advantage of the typed view is that it

1The flow analysis of [JW95] does not exactly correspond to the polymorphic constrained type inference of this paper for two technical

2

allows analysis of non-closed programs, and integrates the flow analysis with the type system in a direct fashion.
It would be extremely useful to have a partial and composable flow analysis, so the typed view is perhaps worth
studying for this purpose alone. Subtyping constrained types is by this duality a form of matching between partial
flow analyses. Consider in particular the following scenario: module B imports module A, and initially a flow analysis
(i.e. constrained type inference via the duality) has been performed on A and B. The code in A is then modified. If
the modifications to A only introduce more constraints, its inferred type should be a ^8-subtype of the original type,
and the flow analysis on B need not be performed again when the new A is linked. This approach would allow some
inter-module flow information to be kept, allowing inter-module optimizations without a global analysis phase.

2 Simple and Constrained Types
We illustrate our ideas by studying an extension of the call-by-name *-calculus with constants and let-binding.

e ::= x j *x: e j e e0 j X j let X = e in e0
To simplify the presentation we assume that the *-bound and let-bound variables are in different syntactic classes,
that *-bound variables are not re-bound, and that constants are a special case of let-variables, bound in the initial
environment. We write *_: e for *x: e where x is not free in e, and (e; e0) for (*_: e0) e.

The simple types are

Typ 3 o/ ::= t j ? j ? j o/ ! o/ 0 j : : :

where t ranges over the set TyVar of type variables, ? and ? are "minimal" and "maximal" types. In addition to the
function types there may be a set of basic types which we leave unspecified. We call ?, ?, !, etc. type constructors,
and all simple types in Typ \Gamma  TyVar constructed.

Simple types are the building blocks of constrained types, assigned to language terms by the type system (to be
fully presented in Section 5). A constrained type ^ has the official form 8t: A ) o/ n C, where the context A is a finite
map from variables to simple types, written hxi : o/ii, the root type o/ is a simple type, and the constraint set C is a set
of subtyping constraints on simple types, each of the form o/ 0 ^ o/ 00.2 We use this new notion for constrained types in
order to more appropriately present the binding structure of type variables. The context A represents the assumptions
about the types of *-bound variables free in the term, and C is the set of subtyping constraints (a.k.a. coercions )
under which the term is typable; they are both part of the type itself instead of the environment. Thus all constrained
types in a type sequent are closed, so we can compare constrained types with different sets of type variables, and
avoid giving meaning to constrained types with constrained but free type variables. Two forms that are less clear
about bindings are (t ^ t ! t0; x : t) ` x x : t0, which treats the constraints as a part of the environment and not a
feature of the type that can be modified by subsumption; and x : t ` x x : 8t0: t0 n ft ^ t ! t0g, which raises the
question does this sequent indeed hold for arbitrary t as t's unconstrained presence in the assumptions suggests. We
write ; `T x x : 8t; t0: hx : ti ) t0 n ft ^ t ! t0g to answer these objections.

DEFINITION 2.1 A constraint set C is closed when

if fo/ ^ o/ 0; o/ 0 ^ o/ 00g ` C; then o/ ^ o/ 00 2 C; and
if o/1 ! o/ 01 ^ o/2 ! o/ 02 2 C; then fo/2 ^ o/1; o/ 01 ^ o/ 02g ` C

We denote by Cl(C) the least closed superset of C. Thus, for example, if C = ft ! t ^ (? ! t) ! ? ! ?g, then
Cl(C) = C [ f? ! t ^ t; t ^ ? ! ?; ? ! t ^ ? ! ?; ? ^ ?; t ^ ?; ? ! t ^ ?g.

A constraint set is consistent if for each constraint o/ ^ o/ 0 in it at least one of the following is true: o/ = ?, o/ 0 = ?,
both sides have the same outermost type constructor, or one of them is a type variable. In the above example, Cl(C)
is inconsistent, since it contains the inconsistent constraint ? ^ ?.

reasons: (1) the splitting they perform is somewhat less general than let-polymorphism to achieve more efficiency; (2) they perform additional
analysis on if-expressions that has no analogue here.

2We only consider closed constrained types, for which ftg ' FTV(A) [ FTV(o/ ) [ FTV(C), where FTV(o/ ) as usual denotes the set of type

variables free in o/ . Constrained types are considered identical under ff-renaming of bound type variables.

3

3 Primitive Subtyping
In order to define notions of ^8, a theory of primitive subtyping under a set of subtyping constraints, C j= o/ ^ o/ 0,
is developed. Both a semantic theory and a decidable axiomatization are developed. This primitive subtyping theory
may be contrasted with existing theories of similar form. [AC93] is one such theory; in this work the constraint sets
C are restricted to e.g. have no lower bounds and at most one upper bound on each type variable; furthermore none
of the constraints in C [ fo/ ^ o/ 0g can be recursive. Our theory is thus more general and may have other applications
besides our use here to define ^8 relations.

3.1 Regular Tree Semantics of Constraints
Sequents C j= o/ ^ o/ 0 may be defined as valid if they hold for all instantiations of type variables in C, o/ , and
o/ 0. There are many possibilities for the notion of "instance." The simplest is to allow instances to range over the
variable-free types constructed from ?, ?, and !. However, for our purposes this does not give enough points in
the space of instances, e.g. when typing binary methods [BCC+96] we have to work with recursive constraint sets
such as ft ! t ^ t; t ^ t ! ?g, which have no solutions in this space. This is an example where differences arise
when recursive constraint sets are allowed--if recursive constraint sets were not allowed, the simple type basis would
have been appropriate. Another candidate is the ideal model [MPS86] used in [AWL94], it conversely has too many
points. Polymorphic types such as 8t:t ! t may be substituted for type variables, but since our system is shallow these
points are superfluous in our framework. It turns out that the addition of the solutions of recursive type equations
to the ground types gives just enough points to define an appropriate semantics. In the next section a theorem will
be proven which rigorously demonstrates this fact. We use the convenient notion of regular trees [Cou83, AC93] to
model solutions of recursive type equations; another reason we use a regular tree model instead of e.g. ideals is that
we expect it to scale better to more full-featured languages.

We present the semantics of constraint sets in terms of regular trees over a ranked alphabet. Let us review some
definitions and results from [Cou83, AC93]. Given a ranked alphabet L, a tree ' is a partial function from finite
sequences of natural numbers N \Lambda  (paths) to L such that Dom(') is prefix-closed and for each ss 2 N \Lambda  we have
fk j ssk 2 Dom(')g = f0; : : : rankL('(ss)) \Gamma  1g. The subtree at ss 2 Dom(') is the function *ss0:'(ssss0); jssj is the
level of that subtree. A tree is regular if the set of its subtrees is finite.

Define T as the set of regular trees over the ranked alphabet Lo/ of type constructors in our language, the nullary
? and ? and the binary !; we reuse the syntax of types as a notation for trees. A regular system in this context
is a set of equations of the form ti = o/i between type variables ti 2 TyVar and simple types o/i (i.e. finite trees over
Lo/ [ TyVar where the type variables are nullary); a regular system is contractive if it has no subset of the form
fti = ti+1ji2f0; :::n\Gamma 1g; tn = t0g. An assignment ae on V ae TyVar is a total map in V ! T; it is homomorphically
extended on simple types o/ with FTV(o/ ) ` V : ae(?) = ?, ae(?) = ?, and ae(o/ ! o/ 0) = ae(o/ ) ! ae(o/ 0). An assignment
ae on ti is a solution of the regular system ti = o/i if aeti = aeo/i.

PROPOSITION 3.1 Each contractive regular system has a unique solution, and each regular tree is the image of some
variable in a solution of a contractive regular system.

A level-k cut 'jk of ' 2 T for k 2 N is defined as the (finite) tree obtained by replacing all subtrees at level k of
' (if any) by ?.

A partial order over L, in which ? is the minimal element and ? is the maximal, together with variance
specifications for the arguments of non-nullary constructors (in this case, contravariance in the domain and covariance
in the range of !) induce a partial order ^tree over T as follows: ? ^tree ' and ' ^tree ? for each finite tree ', and
'1 ! '01 ^tree '2 ! '02 if '2 ^tree '1 and '01 ^tree '02; finally, ' ^tree '0 if 'jk ^tree '0jk for each k 2 N .

Returning to our type system, within a set of constraints we model simple types by regular trees satisfying these
constraints:

DEFINITION 3.2 (i) An assignment ae k-satisfies a constraint o/ ^ o/ 0, written ae .k o/ ^ o/ 0, if ae(o/ )jk ^tree ae(o/ 0)jk.

4

(ii) ae satisfies o/ ^ o/ 0 (ae . o/ ^ o/ 0, also ae is a solution of o/ ^ o/ 0) if ae .k o/ ^ o/ 0 for each k 2 N .
(iii) The above properties are extended over a set of constraints C if they hold for each constraint in the set.

Regular trees may now be used to define the theory C j= o/ ^ o/ 0.
DEFINITION 3.3 (i) C j= o/ ^ o/ 0 if for every assignment ae on FTV(C [ fo/ ^ o/ 0g), if ae . C, then ae . o/ ^ o/ 0.

(ii) C j=V C0 for V ` FTV(C) " FTV(C0) if for each solution ae of C there is a solution ae0 of C0 which agrees with

ae on V (we drop V if it is FTV(C0)).

(iii) C and C0 are equivalent on V if C j=V C0 and C0 j=V C.

PROPOSITION 3.4 j= is a preorder on constraint sets.
LEMMA 3.5 C and Cl(C) are equivalent.
PROOF: Cl(C) j= C since C ` Cl(C); on the other hand the constraints present in Cl(C) in compliance with
Definition 2.1 are satisfied whenever their parent constraints (in that Definition) are, and therefore C j= Cl(C). 2

COROLLARY 3.6 If C is satisfiable, then Cl(C) is consistent.
PROOF: Every solution of C must satisfy Cl(C); but if the latter is inconsistent, it contains a constraint of one of the
forms ? ^ ?, ? ^ o/ ! o/ 0, or o/ ! o/ 0 ^ ?, which cannot be satisfied by any assignment. 2

3.2 Constraint Map Representation
We now define constraint maps as an equivalent form for representing consistent closed constraint sets. Closed
constraint sets may contain significant redundant information. To a constraint set fo/1 ! o/ 01 ^ o/2 ! o/ 02g the closure
adds fo/2 ^ o/1; o/ 01 ^ o/ 02g, and the original constraint between functions is completely captured by the additions and
can be removed. Constraint maps in fact do not allow constraints between two constructed types, since they can
always be expressed by an equivalent family of constraints, provided the constraint set was consistent to begin with.
We reuse some of the notation previously defined for constraint sets C on constraint maps K.

DEFINITION 3.7 A constraint map is a finite map K 2 TyVar ! (2Typ)2, assigning sets of upper and lower bounds
to each type variable in its domain; we use the more intuitive notation t ^ o/ 2 K and t * o/ 0 2 K for o/ 2 ss1(K(t))
and o/ 0 2 ss2(K(t)), respectively, and (K; t ^ o/ ), (K; t * o/ ) for the maps extending the sets ss1(K(t)), respectively
ss2(K(t)), to contain o/ . We write t * o/ instead of o/ ^ t since K is not required to be antisymmetric, i.e. t0 2 ss1(K(t))
does not imply t 2 ss2(K(t0)); we use t = o/ 2 K for the pair t ^ o/ 2 K, t * o/ 2 K.

DEFINITION 3.8 The kernel Ker(C) of a constraint set C is the constraint map defined by the set of constraints
fo/ ^ o/ 0 2 Cl(C) j fo/; o/ 0g " TyVar 6= ;g; a constraint of the form t ^ t0 sets the appropriate bounds on both variables.

For example, since the closure of the constraint set C = f(? ! t) ! t ^ t ! t ! ?g is Cl(C) = f(? ! t) ! t ^
t ! t ! ?; t ^ ? ! t; t ^ t ! ?g, the kernel of C is Ker(C) = (t ^ ? ! t; t ^ t ! ?).

PROPOSITION 3.9 For consistent constraint set C, Ker(C) and C are equivalent.

The kernel form of a constraint set has significant advantages from an implementation perspective: a type inference
algorithm may maintain constraint sets in their equivalent kernel form, which is considerably more compact than the
closure.

5

(?) K ` ? ^ o/ (?) K ` o/ ^ ?
(=) K ` t ^ t; t 2 Dom(K) (!) K ` o/

01 ^ o/1 K ` o/2 ^ o/ 02

K ` o/1 ! o/2 ^ o/ 01 ! o/ 02

(") (K; t ^ o/; t ^ o/

0) ` o/ ^ o/ 0

(K; t ^ o/ ) ` t ^ o/ 0 (#)

(K; t * o/; t * o/ 0) ` o/ 0 ^ o/

(K; t * o/ ) ` o/ 0 ^ t
if (K; t ^ o/; t ^ o/ 0) is contractive if (K; t * o/; t * o/ 0) is contractive

Figure 1: Rules for primitive subtyping

3.3 Rules for Primitive Subtyping
We now axiomatize the theory C j= o/ ^ o/ 0. We take advantage of the equivalent constraint map representation of C,
and axiomatize a relation K ` o/ ^ o/ 0. The rules appear in Figure 1. An implicit requirement for K ` o/ ^ o/ 0 is
FTV(o/ ) [ FTV(o/ 0) ` Dom(K). As is usually the case in the presence of recursive types, a notion of contractiveness
plays an important role in detecting ill-defined constraint maps.

DEFINITION 3.10 A constraint map K is contractive if the transitive closures of ss1 ffi K and ss2 ffi K as relations on
TyVar have no reflexive components, i.e. if there do not exist circular lists of variables ft1; : : : ; tng ` Dom(K) such
that tn = t1 and ti ^ ti+1 2 K (respectively ti * ti+1 2 K) for each i 2 f1; : : : ; n \Gamma  1g.

For instance, neither (t ^ t) nor (t * t0; t0 * t) is contractive, while (t * t0; t ^ t0) is (recall a constraint
map is not necessarily symmetric on type variables). However note that contractiveness of constraint maps, as
opposed to regular systems, does not entail satisfiability, e.g. (t ^ ?; t * ?) is a contractive map with no solutions.
Contractiveness of constraint maps obtained as kernels of constraint sets is easily achieved by first merging type
variables which form a cycle (e.g. transforming ft ^ t0; t0 ^ t; t ^ t0 ! ?g into ft ^ t; t ^ t ! ?g) and then
removing constraints of the form t ^ t; this results in a map equivalent to the original and obviously contractive.

Rules (?), (?), (!), and (=) for reflexivity of the relation on type variables are standard. The novel rules (")
and (#) provide the only access to constraints in K; in fact, were the constraint map in its premise identical to the one
in its conclusion, rule (") would have been just the standard rule for proving an upper bound on a type variable in a
system of rules with eliminated transitivity. With the extra assumption these are induction rules, similar to the (FIX)
rule of [ESTZ95].

Two rules often present in systems with subtyping [AC93] but omitted here concern the general reflexivity and
transitivity of the relation; and while it is easy to see that reflexivity is a meta-rule (K ` o/ ^ o/ is always provable
for FTV(o/ ) ` Dom(K)), transitivity only holds for consistent constraint maps.

DEFINITION 3.11 A constraint map K is consistent if for each t, o/ , and o/ 0, if t * o/ 2 K and t ^ o/ 0 2 K, then
K ` o/ ^ o/ 0.

The following Lemma shows that a kernel contains all of the information of a consistent set C, and that the
construction of the closure of C can be seen as a process of recovering a constraint map K such that K ` C.

LEMMA 3.12 If Cl(C) is a consistent constraint set, then Ker(C) is a consistent constraint map, and Ker(C) ` Cl(C).
PROOF SKETCH: Observe that by the definition of the closure of C the premises of rule (!) are the "daughter"
constraints of its conclusion, and hence must be present in the set whenever the conclusion is present. Furthermore
if o/ , o/ 0, and o/ 00 are constructed types and fo/ ^ o/ 0; o/ 0 ^ o/ 00g ` C, then o/ ^ o/ 00 is only consistent if and only if
all of them have the same outermost constructor, and in this case all of its daughter constraints will be obtained by
transitivity on the daughter constraints of o/ ^ o/ 0 and o/ 0 ^ o/ 00; hence transitivity via variables suffices, and it also
ensures that Ker(C) is consistent. 2

6

3.4 Soundness and Decidability of Primitive Subtyping
Next we establish soundness of the proof system ` with respect to the relation j=; the main idea is to show that
all assignments which approximate solutions of a constraint map K also approximate solutions of all subtyping
constraints provable from K.

LEMMA 3.13 If K is contractive, K ` o/ ^ o/ 0 has a proof, and the assignment ae k-satisfies K, then

(i) if the proof of K ` o/ ^ o/ 0 has an instance of a rule other than (") or (#) at its root, then ae .k+1 o/ ^ o/ 0;
(ii) if there is an instance of (") or (#) at the root of the proof of K ` o/ ^ o/ 0, then ae .k o/ ^ o/ 0.

PROOF: We proceed by induction on the structure of the proof of K ` o/ ^ o/ 0.

(i) Clearly any assignment on Dom(K) satisfies the constraints in the conclusions of (?), (?), and (=); as for

(!), by inductive hypothesis ae at least k-satisfies the constraints o/ 01 ^ o/1 and o/2 ^ o/ 02 in its premises, hence
ae(o/1 ! o/2)jk+1 = ae(o/1)jk ! ae(o/2)jk ^ ae(o/ 01)jk ! ae(o/ 02)jk = ae(o/ 01 ! o/ 02)jk+1.

(ii) Suppose that K ` o/ ^ o/ 0 has a proof ending with an instance of ("); the case of (#) is similar. Then o/ is some

type variable t1, and the antecedent of the rule is of the form K; t1 ^ o/ 0 ` o/1 ^ o/ 0, where t1 ^ o/1 2 K. If one
or both of o/1 and o/ 0 are variables, the last rule applied in the proof of this sequent may be (") or (#) again, so
the proof of K ` o/ ^ o/ 0 ends in a chain of one or more instances of these two rules. Let ht1; : : : ; tn; o/ni and
ht01; : : : ; t0m; o/ 0mi be respectively the sequences of left and right hand sides of the constraints in the conclusions
of these instances, from the root; here n is equal to the number of instances of (") in this chain, and m--to that
of (#). At the other end of the chain there is a proof of some (K; K0) ` o/n ^ o/ 0m ending in a rule other that
(") or (#). Note that K0 consists exactly of the constraints in the conclusions of rules in this chain (including
the root o/ ^ o/ 0), all of the forms ti ^ t0j, t0j * ti, ti ^ o/ 0m, and t0j * o/n.

By induction on the length of the l.h.s. sequence we obtain ti ^ ti+1 2 K for each i 2 f1; : : : ; n \Gamma  1g, and
tn ^ o/n 2 K, as follows. Suppose that ti ^ ti+1 =2 K; then it is in the constraint map K0 because it appeared
as a conclusion of one of the instances of (") closer to the root, say the jth instance, where j ! i. But this
implies ti = tj, and since by inductive hypothesis f: : : ; tj ^ tj+1; : : : ; ti\Gamma 1 ^ tig ` K, it follows that K is
not contractive, which contradicts the assumptions. Similarly (for i = n) we can show that tn ^ o/n 2 K. The
analogous result holds for the r.h.s. sequence.

We now establish that ae .k K0 (and therefore ae .k o/ ^ o/ 0) by induction on k:

ffl Any assignment 0-satisfies any constraint, hence ae .0 K0.
ffl Suppose ae .l K0, where l ! k. Then ae .l (K; K0), and hence by inductive hypothesis ae .l+1 o/n ^ o/ 0m,

since the proof of (K; K0) ` o/n ^ o/ 0m has a rule other than (") and (#) at its root. Consider for example
the constraints in K0 of the form ti ^ o/ 0m; since fti ^ ti+1; : : : ; tn ^ o/ng ` K, ae k-satisfies, and hence
l+1-satisfies every one of them. Thus by transitivity of the relation ^ on finite trees ae .l+1 ti ^ o/ 0m, and
similarly for each of the rest of the constraints in K0.

2
THEOREM 3.14 (SOUNDNESS) If K is contractive and K ` o/ ^ o/ 0, then K j= o/ ^ o/ 0.
PROOF: Suppose ae . K. For each k 2 N it follows that ae .k K, and thus by Lemma 3.13 at least ae .k o/ ^ o/ 0.
Therefore ae . o/ ^ o/ 0. 2

The system ` is incomplete with respect to the relation j=; indeed it is not even possible to prove that (t ^ t !
?; t ^ ? ! t) ` t ^ ? ! ? since the bound we need is stronger than any one of the two given. However ` is useful
because of the following property.

7

LEMMA 3.15 The relation K ` o/ ^ o/ 0 is decidable.
PROOF: Note that for each rule in the system either the sizes of the constraints in its premises are smaller than
that of its conclusion, or the constraint map has one more element (with the exception (K; t ^ o/ ) ` t ^ o/ , which
immediately reduces to reflexivity), and the bounds added to the constraint map are subterms of the type terms present
in the goal we are trying to prove, and hence form a finite set. 2

3.5 Canonical Constraint Maps
We can obtain a stronger proof system if we place the constraints in an equivalent canonical form that has precomputed least upper and greatest lower bounds. In a canonical constraint map each variable has exactly one
constructed upper and one constructed lower bound. For instance, a canonical equivalent of (t ^ t ! ?; t ^ ? ! t)
is K = (t * ?; t ^ ? ! ?). The upper bounds t ! ? and ? ! t on t have the lub ? ! ? computed for them. For
this set we can indeed prove K ` t ^ ? ! ?. The canonicalization process also has potential as an implementation
technique.

DEFINITION 3.16 A constraint map K is canonical if

ffl K assigns exactly one upper and one lower constructed bound to each type variable in its domain,
ffl if t ^ t0 2 K and t0 ^ t00 2 K, then t ^ t00 2 K, and
ffl for each (t ^ t0; t ^ o/; t0 ^ o/ 0) ` K, where fo/; o/ 0g " TyVar = ;, we have K ` o/ ^ o/ 0, and similarly for the

lower bounds.

Clearly if K and K0 are equivalent on FTV(o/ ) [ FTV(o/ 0) then K j= o/ ^ o/ 0 if and only if K0 j= o/ ^ o/ 0. This
allows us to upgrade our system by converting each map K to an equivalent canonical map Can(K) and then proving
Can(K) ` o/ ^ o/ 0 instead of the original K ` o/ ^ o/ 0.

Here we provide an algorithm for computing an equivalent canonical form Can(K) of a map K.

ALGORITHM 3.17 Can(K) is computed as follows.
Start with K0 = K, and for some t 2 FTV(K0) let V *t be the least set satisfying V *t = ftg [ ft0 j 9t00 2 V *t : t00 ^
t0 2 K0g, i.e. the set of upper bounds on t in the reflexive transitive closure of K0 on TyVar; the case of lower bounds
is similar. Let B*t = fo/ 2 Typ \Gamma  TyVar j 9t0 2 V *t : t0 ^ o/ 2 K0g, the set of constructed upper bounds on t. We
compute the canonical upper bound o/ of t as the greatest lower bound of the elements of B*t , as follows.

If B*t ` f?g, then o/ = ?; if ? 2 B*t , then o/ = ?. Otherwise let fo/i ! o/ 0ig be the set of all function
types in B*t , and let o/ = t^fo/

ig ! t

.

fo/ 0i g, where t

^
fo/ig and t

.

fo/ 0ig are in general auxiliary type variableswe associate with the respective sets of type terms; in the cases when

T is a singleton set ft0g we let

t^T = t.T = t0. Add the bounds (t^fo/

ig * o/j) (and similarly for t

.

fo/ 0i g) to K

0.

Replace the constructed upper bounds of t by (t ^ o/ ); thus the new bounds on t, namely (t ^ o/ ) and (t ^ t0) for
each t0 2 V *t , are in canonical form. Continue until all variables in K0 are processed. (Adding also all bounds of the
form (t^S ^ t^T ) and (t.S * t.T ) if T ae S, when those auxiliary variables appear in the domain of the map, produces
an even stronger, with respect to `, yet equivalent form.) The resulting K0 is the value of Can(K).

The following Lemma proves the correctness of this algorithm.
LEMMA 3.18 For each constraint map K there exists a canonical equivalent Can(K).

8

PROOF SKETCH: Each step of the transformation of K into Can(K) maintains equivalence; the algorithm terminates
because the bounds on the auxiliary variables are subterms of the types in K (hence finitely many), and only two
auxiliary variables--an upper and a lower bound--are associated with each set of subterms. The resulting map
Can(K) is canonical because for each t and t0 such that t ^ t0 2 Can(K) we have by construction B*t ' B*t0 , which
allows proving the ordering on the constructed bounds of t and t0. 2

For example computing the canonical equivalent of K = (t ^ t ! ?; t ^ ? ! t) starts by introducing t1 = t.ft; ?g

and t2 = t^f?; tg, and transforming K into K0 = (t * ?; t ^ t1 ! t2; t1 * ?; t1 ^ ?; t1 * t; t2 * ?; t2 ^ ?; t2 ^
t). This map is already in canonical form, and it is possible to prove K0 ` t ^ ? ! ?. However, even
when ` is used on to canonical equivalents it still does not provide proofs for some valid relations; for instance,
(t * ?; t ^ t ! ?) j= t ^ (? ! ?) ! ?. We leave open the decidability of C j= o/ ^ o/ 0.

In the general case, the algorithm implied by Lemma 3.15 may attempt comparing o/ against each upper bound on
t currently in K in the process of searching for a a proof of K ` t ^ o/ . In this process, it may have to backtrack
if it fails to find a proof using a particular bound. In the case of canonical maps we can do better than that, by the
following Lemma.

LEMMA 3.19 If K is a canonical constraint map and K ` o/ ^ o/ 0, then there exists a proof of this sequent in which
all instances of rules (") and (#) only use canonical bounds in K.

PROOF SKETCH: Given an arbitrary proof derivation D of K ` o/ ^ o/ 0 we construct a proof which only uses
canonical bounds in (") and (#) as follows: let D0 be a minimal depth subderivation of D where a non-canonical
(say, upper) bound o/1 on some variable t is used in an instance of rule (") with a goal K0 ` t ^ o/2 and a premise
(K0; t ^ o/2) ` o/1 ^ o/2. Then the constraint t ^ o/1 must be present in K0, which implies that there is an instance
of (") with a goal K00 ` t ^ o/1, where K00 ae K0, closer to the root of D. But all such instances of (") use the
canonical upper bound o/0 of t; hence we have a proof of (K00; t ^ o/1) ` o/0 ^ o/1. We can splice the proofs of
(K00; t ^ o/1) ` o/0 ^ o/1 and (K0; t ^ o/2) ` o/1 ^ o/2 to obtain a proof of (K00; t ^ o/2) ` o/0 ^ o/2; details of this
procedure and the proof of its termination are omitted for brevity. Recursively applying this operation, we obtain a
derivation of the desired form. 2

Lemma 3.19 suggests the following algorithm for deciding K ` o/ ^ o/ 0 with time complexity of O(n2), where
n is the size of K [ fo/ ^ o/ 0g.

ALGORITHM 3.20 During preprocessing, determine the syntactically distinct type subterms in K [ fo/ ^ o/ 0g (let their
number be n0, n0 ^ O(n)) and assign each an index. Initialize a Boolean matrix M of size n0 \Theta  n0 to the relation
given by the constraints in K. Start with the goal o/ ^ o/ 0, and if the current goal is true in M , succeed; if it's an
inconsistent constraint, fail; otherwise, set the goal's entry in M to true and continue with the corresponding derived
goals, according to the rules in Figure 1, picking always the canonical bound on a variable when applying (") or
(#). Thus, each pair of type subterms in K [ fo/ ^ o/ 0g is only encountered at most once (though we may encounter
syntactically identical pairs more than once).

A parallel can be drawn between our system of subtyping rules and the system `AC of Amadio and Cardelli
[AC93], which is based on a relation of equivalence between recursive types, and on the inductive rule

(_) C; t ^ t

0 `AC o/ ^ o/ 0

C `AC _t: o/ ^ _t0: o/ 0
Since recursive types can be encoded as type variables with identical upper and lower bounds, the corresponding rule
for simple types with constraints is

(_) K; t = o/; t

0 = o/ 0; t ^ t0 ` o/ ^ o/ 0

K; t = o/; t0 = o/ 0 ` t ^ t0

9

which is indeed derivable in ` in a stronger version by successive applications of (") and (#); furthermore, the
steps of the proof of K; t = o/; t0 = o/ 0 ` t ^ t0 follow closely the steps of the algorithm for computing
C `AC _t: o/ ^ _t0: o/ 0 presented in [AC93], which also effectively constructs the type contexts necessary in order
to establish type equivalences. Amadio and Cardelli show that their system is complete with respect to the regular
tree model of recursive types under certain conditions on C, o/ , and o/ 0; in particular the constraints in C may not be
recursive, and no variable may occur in both o/ and o/ 0. An attempt to directly apply the system to prove sequents
violating these conditions shows that it is incomplete in the more general setting considered in this paper, e.g.
t ^ ? ! t 6`AC t ^ _t0: ? ! t0. Our system, while still incomplete with respect to the model we present, is capable
of proving the corresponding forms of all sequents provable in [AC93], in addition allowing multiple recursive upper
and lower bounds on type variables, e.g. t ^ ? ! t; t0 = ? ! t0 ` t ^ t0.

3.6 Satisfiability of Canonical Constraint Maps
A constrained type only has meaning if its constraints describe a non-empty set of instances, and hence the satisfiability
of a constraint map is an important property. In this section we provide a connection between consistency and
satisfiability of canonical constraint maps. This connection also plays a role in establishing the relationship between
various notions of subtyping on constrained types in Section 4.

DEFINITION 3.21 The canonical map K0 is a submap of a canonical map K if K0 ` K. Note that constraints on
variables in Dom(K) \Gamma  Dom(K0) may involve variables in Dom(K0), but FTV(Codom(K0)) ` Dom(K0).

LEMMA 3.22 If K0 is a submap of K, and K is consistent and canonical, then every solution of K0 can be extended
to a solution of K.

PROOF: Given a solution ae0 of K0, by Proposition 3.1 there exists a contractive regular system S0 of equations
for the type variables in Dom(K0) such that ae0 is the unique solution of S0. Define ae as the unique solution of
S = S0 [ ft = o/U j t 2 Dom(K) \Gamma  Dom(K0); o/U 2 Typ \Gamma  TyVar; t ^ o/U 2 Kg, i.e. as the extension of ae0 obtained by
equating each variable not in K0 to its unique constructed upper (for specificity) bound in K. (S is indeed a contractive
regular system since all bounds are constructed.) Since ae0 . K0 we only have to verify that ae satisfies the constraints
on variables in Dom(K) \Gamma  Dom(K0); suppose that ae .k K for some k 2 N . By Definition 3.16 each type variable t in
Dom(K) has exactly one constructed upper bound o/U which ae satisfies (with equality) by construction; furthermore, t
has exactly one constructed lower bound o/L in K, and by Definition 3.11 there is a proof of K ` o/L ^ o/U ; since both
o/L and o/U are constructed, by Lemma 3.13 we have ae .k+1 o/L ^ o/U , and therefore ae .k+1 o/L ^ t (recall aet = aeo/U
by construction). Let us now consider the constraints between variables in K: if t ^ t0 2 K, and o/U and o/ 0U are the
upper bounds in K of t and t0 respectively, then by Definition 3.16 there is a proof of K ` o/U ^ o/ 0U ; this again by
Lemma 3.13 implies ae .k+1 o/U ^ o/ 0U and hence ae .k+1 t ^ t0. So ae .k K implies ae .k+1 K, and the statement of the
Lemma follows from the trivial ae .0 K. 2

COROLLARY 3.23 Every consistent canonical constraint map K is satisfiable.
PROOF: Application of Lemma 3.22 to the case of K0 = ;. 2

Combining these results with canonicalization and soundness of ` with respect to j=, we can reason about canonical
maps instead of their equivalent constraint sets.

DEFINITION 3.24 C ` o/ ^ o/ 0 if Can(Ker(C)) ` o/ ^ o/ 0.

4 Subtyping Constrained Types
In this section we define three concrete ^8 relations of subtyping on constrained types: ^8obs, ^8sem, and ^8dec, as
promised in the introduction.

10

4.1 Operational Subtyping
For an initial definition of ^8 we rely on operational notions as a basis. The basic idea is simple, but we could not find
any precedent for it in the literature. Expressions of constrained type 8t: A ) o/ n C are also of type 8t0: A0 ) o/ 0 n C0
if for any future uses of expressions of the latter type that are consistent, the former type also leads to a consistent use.
Relation ^8obs is defined by this means. The difficult issue is how a "future use" of a type should be defined. Informally,
each use is a typing proof context, in analogy with Morris/Plotkin expression contexts. We give a particular version of
typing proof context which is one of many reasonable and equivalent notions: a "future use" is a set of constraints of
the form that could be added by the inference rules. The constraints added by the inference rules may only introduce
upper bounds on the root types, and therefore only lower bounds on the types in the context. As a consequence
one may obtain a valid typing derivation after replacing a subterm by another term whose constrained type yields a
consistent system when those bounds are added. This leads us to the following observational definition of a subtyping
relation on constrained types. (We let A ^ A0 abbreviate the set of constraints fA(x) ^ A0(x) j x 2 Dom(A0)g,
defined only when Dom(A) ' Dom(A0).3)

DEFINITION 4.1 For closed constrained types, 8t0: A0 ) o/ 0 n C0 ^8obs 8t00: A00 ) o/ 00 n C00 if for each 8t: A ) o/ n C
such that ftg is disjoint from ft0g and ft00g, if Cl(C [C00 [(A ^ A00)[fo/ 00 ^ o/ g) is consistent, then Cl(C [C0 [(A ^
A0) [ fo/ 0 ^ o/ g) is consistent.

4.2 Semantic Subtyping
Next, a semantic notion ^8sem is defined, via the regular tree model: two polymorphic constrained types are ordered
if their sets of regular tree instances are ordered.

The context component A of a constrained type corresponds to a finite map \Phi  from variables to regular trees; the
relation ^tree can be extended on such maps as follows: \Phi  ^tree \Phi 0 if Dom(\Phi ) ' Dom(\Phi 0) and \Phi (x) ^tree \Phi 0(x)
for each x 2 Dom(\Phi 0).

DEFINITION 4.2 An instance of the constrained type ^ = 8t: A ) o/ n C is a pair written \Phi  ) ' where \Phi  = ae ffi A
and ' = aeo/ for some assignment ae on ftg that satisfies C. The set of instances of ^ is Inst(^).

As in the definition of ^8obs, the natural order on instances is \Phi  ) ' ^tree \Phi 0 ) '0 if \Phi 0 ^tree \Phi  and ' ^tree '0.
We can now define a semantical notion of subtyping on constrained types.

DEFINITION 4.3 ^0 ^8sem ^00 if for each instance of ^00 there is a smaller instance of ^0.

We may now prove the equivalence of ^8sem and ^8obs, demonstrating the appropriateness of the regular tree
interpretation.

THEOREM 4.4 (FULL TYPE ABSTRACTION) The relations ^8sem and ^8obs agree.

PROOF: Let ^0 = 8t0: A0 ) o/ 0 n C0 and ^00 = 8t00: A00 ) o/ 00 n C00.

^8sem`^8obs: Suppose that ^0 ^8sem ^00, and 8t: A ) o/ n C is such that ftg"(ft0g[ft00g) = ; and Cl(C[C00[(A ^
A00) [ fo/ 00 ^ o/ g) is consistent. Then by Lemmas 3.12 and 3.18 and Corollary 3.23 there is an assignment ae00 on

ft; t00g which satisfies C [ C00 [ (A ^ A00) [ fo/ 00 ^ o/ g. But ftg is disjoint from ft00g and ft0g, and for each instance
of ^00 there is a smaller instance of ^0, hence there exists a solution ae0 of C0 which agrees with ae00 on ftg (thus ae0 . C),
and ae00 ffi A00 ^tree ae0 ffi A0 and ae0o/ 0 ^tree ae00o/ 00. By transitivity of ^tree it follows that ae0 satisfies (A ^ A0) [ fo/ 0 ^ o/ g,
hence by Corollary 3.6 Cl(C [ C0 [ (A ^ A0) [ fo/ 0 ^ o/ g) is consistent.

3This "subtyping rule" for contexts is similar to standard record subtyping [Car84]; indeed the closure conversion [[x]] = *E: E.x,
[[*x: e]] = *E: *x: [[e]]{ xi = E.xijx

i2FV(e)\Gamma fxg; x = x }, and [[e e

0]] = *E: [[e]] E ([[e0]] E) makes the environment explicit and maps terms of

type 8t: hxi : o/ii ) o/ n C to closed terms of type 8t: hi ) { xi : o/i } ! o/ n C.

11

^8sem'^8obs: Suppose ^0 ^8obs ^00, and let ae00 . C00. By Proposition 3.1 there exist contractive regular systems
whose only solutions are the trees in ae00 ffi A00 and ae00o/ 00; these systems can be represented as constraint sets with
identical upper and lower bounds on type variables. Choosing the type variables ftg in these systems disjoint from

ft0g [ ft00g we obtain a constrained type ^ = 8t: A ) o/ n C of which ae00 ffi A00 ) ae00o/ 00 is the unique instance
under some assignment ae on ftg; furthermore Cl(C [ C00 [ (A ^ A00) [ fo/ 00 ^ o/ g) is satisfied (with equalities on

(A ^ A00)[fo/ 00 ^ o/ g) by ae00 on ft00g extended with ae on ftg. Then by Definition 4.1 Cl(C [C0[(A ^ A0)[fo/ 0 ^ o/ g)
is satisfiable as well; but ae is the only solution of C, so the solution must be an extension of ae with some ae0 on ft0g.
Hence ae0 satisfies C0, and in addition the instance of ^0 corresponding to ae0 is smaller than the instance of ^ (under ae),
which in turn was the arbitrarily selected instance of ^00. 2

To contrast ^8sem with the ideal model ordering ^8ideal, consider the following example, in which we omit contexts
and quantifiers when empty. In the regular tree model the only solution of C = f? ! ? ^ t; t ^ ? ! ?; t ^ ? ! ?g
is ae = [t 7! ? ! ?], which satisfies also t ^ ? ! ?; hence (? ! ?) ! ? ! ? n ; ^8sem 8t: t ! t n C. But this fails
for ^8ideal since in the ideal model e.g. [ t 7! 8t0: t0 ! t0 ] is a solution of C which does not satisfy t ^ ? ! ?. As
a consequence the ideal model ordering does not offer full type abstraction with respect to the operational subtyping
^8obs.

4.3 Decidable Subtyping
The question of decidability of ^8sem is open; we show how it may be approximated by a powerful decidable relation.
The material of the previous section is used to define this decidable relation.

The informal idea leading to the decidable relation is simple: observe that adding constraints to a set may

only shrink the set of its solutions. For constrained types ^0 = 8t0: A0 ) o/ 0 n C0 and ^00 = 8t00: A00 ) o/ 00 n C00,
Definition 4.3 states that ^0 ^8sem ^00 if a certain relation holds for each instance of ^00 (that is, for the unrestricted
set of solutions of C00) and some corresponding instance of ^0 (that is, an element of a possibly restricted subset of

solutions of C0). Thus, assumming that ft0g and ft00g are disjoint, we would have a proof of ^0 ^ ^00 if we could show
that the relations o/ 0 ^ o/ 00 and (A00 ^ A0) hold under C00 and C0 together with some set C of constraints which do not

"constrain further" the type variables t00 (but possibly add constraints on t0).

Applying the machinery developed in Section 3, these ideas are formalized in the following definition of a relation
approximating ^8sem.

DEFINITION 4.5 ^0 ^8dec ^00 if ^0 = 8t0: A0 ) o/ 0 n C0 and ^00 = 8t00: A00 ) o/ 00 n C00 for some ft0g " ft00g = ;, and
there exists a consistent canonical map K such that K ` C0 [ (A00 ^ A0) [ fo/ 0 ^ o/ 00g and Can(Ker(C00)) is a submap
of K.

Here the map K represents the union of C00, C0, and C of our informal discussion: it has Can(Ker(C00)) as a
submap (meaning ft0g are not further constrained), it entails C0, and its constraints on ft0g may be stronger that those
in C0 in order to ensure that the relations between root types and contexts hold. The following theorem shows that
^8dec is indeed an approximation to ^8sem.

THEOREM 4.6 If ^0 ^8dec ^00, then ^0 ^8sem ^00.
PROOF SKETCH: Let K be the map of Definition 4.5. Since Ker(C00) ` Cl(C00) and Can(Ker(C00)) is equivalent to
Ker(C00), each solution ae00 of C00 is a solution of Can(Ker(C00)). Therefore by Lemma 3.22 each solution of C00 can
be extended to a solution ae of K, which then by Theorem 3.14 and Lemma 3.12 satisfies C0 [ (A00 ^ A0) [ fo/ 0 ^ o/ 00g.
Hence the instance ae ffi A0 ) aeo/ 0 of ^0 is smaller than the given instance ae00 ffi A00 ) ae00o/ 00 of ^00. 2

Although the incompleteness of ` with respect to j= implies incompleteness of ^8dec with respect to ^8sem,
the relation ^8dec is still quite powerful: it subsumes the relation of instantiation between type schemes in the
Hindley/Milner system, the subtyping relation between recursive types in the Amadio/Cardelli system, and their

12

union on recursive polymorphic types in shallow (prenex) form. Consider Hindley-Milner subtyping in more detail.
The type scheme 8t00: o/ 00 is an instance of 8t0: o/ 0 if o/ 00 = oe(o/ 0), where oe is a simple type substitution on ft0g = FTV(o/ 0),
and ft00g = FTV(o/ 00); then we have 8t0: hi ) o/ 0 n ; ^8dec 8t00: hi ) o/ 00 n ; by Definition 4.5, as evidenced by the
canonical constraint map K = (t0 ^ oe(t0); t0 * oe(t0)), which entails o/ 0 ^ oe(o/ 0) and is obviously consistent. Closed
recursive types can also be represented as constrained types, with the constraint set effectively encoding a regular
system; when restricted to these types, ^8dec is equivalent to the system of Amadio and Cardelli.

In addition, ^8dec is sufficiently strong to allow proving correctness of many useful simplifications of types inferred
by the system. For example, ^8dec can be used to show the soundness of the constraint set simplification "garbage
collection" of [EST95a], which allows the removal of "unreachable" constraints.

DEFINITION 4.7 Given a constrained type 8t: A ) o/ n K, where K is a canonical constraint map, a type variable t
is positively reachable if t occurs positively in o/ , or negatively in A, or positively in the constructed lower bound in
K of some positively reachable t0, or negatively in the constructed upper bound in K of some negatively reachable
t00. Negative reachability is defined symmetrically. (recall that an occurrence of a variable in a simple type is positive
(resp. negative) if it occurs inside an even (odd) number of type subterms in argument position of !.)

A constraint t * o/ 0 2 K (resp. t ^ o/ 0 2 K) is reachable if t is positively (negatively) reachable; t ^ t0 2 K is
reachable if t is negatively and t0 is positively reachable.

This notion of reachability is motivated by the type rules (Section 5, Figure 2), which only set upper bounds on
types of subterms. Thus for instance a type variable t in the type ^ of a term e can only obtain new upper bounds
(when e appears as a subterm) if t is positively reachable in ^; in this case t's lower bounds may be the source of an
inconsistency (via transitivity). Conversely, however, if t is not reachable positively, its lower bounds are not going to
cause inconsistency in any future use of e--hence they may safely be ignored; for example,

8t: hi ) t n f? ! t ^ t; t ^ t ! ?g ^8dec 8t: hi ) t n f? ! t ^ tg:
PROPOSITION 4.8 If GC(^) is the constrained type obtained by removing the unreachable constraints in ^, then
GC(^) ^8dec ^ and ^ ^8dec GC(^).

PROOF SKETCH: The first part is obvious, since ^ only may have more constraints than GC(^). For the second part,
let ^ = 8t0: A0 ) o/ 0 n K0; then GC(^) = 8t00: oeA0 ) oeo/ 0 n oe(GC(K0)), where oe = [t00=t0] is a renaming of all type
variables t0 to a disjoint set, and GC(K0) is K0 with the constraints unreachable from o/ 0 and A0 removed. Then the
constraint map

K = Can((K0; GC(K0); t0 ^ t00; t0 * t00))

satisfies the requirements of Definition 4.5: it suffices to note that the proof of K ` o/ 0 ^ oeo/ 0 will only use the
lower bounds of variables t00 positively reachable from oeo/ 0, and respectively upper bounds of negatively reachable
variables--just those left in by the garbage collection. 2

Pottier [Pot96] offers an alternative definition of reachability, which ignores the polarity of the occurences of type
variables and instead keeps all constraints on variables which may be reached in any position from the root. Our
experience with applications of constrained type systems to object-oriented languages [EST95b, EST95a] shows that
keeping track of polarity makes a significant difference when simplifying types inferred for new objects (which are
fixed points of classes)--type variables associated with objects have often large upper bounds inherited from the class
definition (before taking the fixed point); they are removed by our garbage collection but not by Pottier's. Furthermore,
removing more constraints often enables other simplifications, e.g. replacing a type variable by its bound.

We present an outline of an algorithm for computing 8t0: A0 ) o/ 0 n C0 ^8dec 8t00: A00 ) o/ 00 n C00. The algorithm
either fails, if the subtyping does not hold, or it produces a set of constraints C which only put bounds on the type

variables in ft0g; the constraint map K required by Definition 4.5 can then be obtained by extending Can(C00) with
Can(Ker(C0 [ C)). The algorithm is very similar to the one for computing closure of a constraint set; in fact it is a
generalization of the latter.

13

(VAR) \Gamma  `T x : 8t: hxi : o/i; x : o/ i ) o/ n C; ftg ' Si FTV(o/i) [ FTV(o/ ) [ FTV(C)

(ABS) \Gamma  `

T e : 8t: hx

i : o/i; x : o/ i ) o/

0 n C

\Gamma  `T *x: e : 8t: hxi : o/ii ) o/ ! o/ 0 n C

(APP) \Gamma  `

T e0 : 8t: A ) o/ 00 ! o/ n C \Gamma  `T e00 : 8t: A ) o/ 00 n C

\Gamma  `T e0 e00 : 8t: A ) o/ n C
(LETVAR) \Gamma  `T X : \Gamma (X); X 2 Dom(\Gamma )

(LET) \Gamma  `

T e : ^ \Gamma ; X : ^ `T e0 : ^0

\Gamma  `T let X = e in e0 : ^0

(SUB) \Gamma  `

T e : ^ ^ ^8 ^0

\Gamma  `T e : ^0

Note: the closures of the constraint sets in all conclusions must be consistent.

Figure 2: Typing rules.

ALGORITHM 4.9 8t0: A0 ) o/ 0 n C0 ^8dec 8t00: A00 ) o/ 00 n C00 is computed as follows.
We start by computing K00 = Can(C00) and with an initially empty set C0 of new constraints on variables in ft00g
which are "pending proof," and proceed as in computing the closure of C0 [ fo/ 0 ^ o/ 00g [ (A00 ^ A0), namely, failing
on inconsistent constraints, and reducing consistent ones between constructed types to constraints on variables, of the

form t ^ o/ (or o/ ^ t). When t 2 ft0g, if the constraint is already in C0 [ C, the search succeeds; otherwise we add
these constraints to C and continue as in the closure computation by searching for a proof of o/L ^ o/ (resp. o/ ^ o/U ),

where o/L and o/U represent the lower and upper bound(s) on t in C0 [ C so far. However, when t 2 ft00g, we instead
attempt to prove that this constraint is implied (by the rules for primitive subtyping) by the constraints on t in K 00.
The proof search goes much as described in Section 3.4: if o/ is already an upper (lower) bound of t in K00 [ C0, it
succeeds, otherwise the new constraint is added to the set C0, and we search for a proof of the constraint o/U ^ o/
(resp. o/ ^ o/L), where o/U and o/L are the canonical upper and lower bounds on t in K00.

Thus, the algorithm treats variables in ft0g and ft00g differently, but symmetrically: it compares new upper bounds
on a t0 with its old lower bounds, but new upper bounds on a t00 with its old (canonical) upper bound. (The reader
may have noticed that converting C0 to a canonical constraint map is not necessary for this algorithm; however it may
improve its performance.)

THEOREM 4.10 The relation ^8dec is decidable.
PROOF SKETCH: The algorithm terminates, since each constraint it analyzes is between simple type subterms from
the two given constrained types, and they are finitely many (an upper bound of O(n3) for the time complexity of the
algorithm is implied by the complexities of closure computation [PO95] and ` (Section 3)). If the algorithm succeeds,

the set C contains the additional constraints on variables in ft0g necessary for proving o/ 0 ^ o/ 00 and (A00 ^ A0); if it
fails, it has shown that an inconsistent constraint is necessary in order to prove the subtyping relation, hence it is false.
(The necessity of all generated constraints is due to Lemma 3.19.) 2

5 Soundness of the Type System and Completeness of Inference
The typing rules shown in Figure 2 infer sequents of the form \Gamma  `T e : ^; the type environment \Gamma  only assigns
constrained types to let-bound variables, while the types of *-bound variables are included in the context component

14

(VARI) \Gamma  `I x : 8ti; t: hxi : ti; x : ti ) t n ;

(ABSI) \Gamma  `

I e : 8ti; t: hxi : ti; x : ti ) o/ n C

\Gamma  `I *x: e : 8ti; t: hxi : tii ) t ! o/ n C ; fxig = FV(*x: e)

(APPI) \Gamma  `

I e0 : 8t0: A ) o/ 0 n C0 \Gamma  `I e00 : 8t00: A ) o/ 00 n C00

\Gamma  `I e0 e00 : 8t0; t00; t: A ) t n C0 [ C00 [ fo/ 0 ^ o/ 00 ! tg
where ft0g \Gamma  FTV(A); ft00g \Gamma  FTV(A); FTV(A); and ftg are all disjoint

Figure 3: Typing rules modified for type inference.

of ^. Each rule has the implicit side condition that the closure of the constraint set in the constrained type in its
conclusion is consistent. Rule (APP) requires the types of the subterms to share the context A, constraint set C, and
set of bound variables ftg. Rule (LET) is sound with respect to the call-by-name semantics;4 constraints on types of
variables free in e need not be reflected in ^0 unless X occurs free in e0. Finally the subsumption rule (SUB) replaces
the constrained type of a term by a supertype; it is thus the only rule that may allow the constraint set in the type of
a term to be taken into account or modified. The rules are parametric in the choice of ^8, for which we considered
a number of different possibilities; the notation `T represents the rules with abstract ^8, and `Tsem for instance
represents `T with ^8 defined as the concrete relation ^8sem.

Rules for type inference are presented5 in Figure 3; there is no rule for subsumption, and the let-related rules are
the same as in `T and hence omitted.

We may now establish soundness of the typing rules of Figure 2. In our previous proofs of soundness of constrained
typing systems [EST95b], a direct subject reduction argument was used. Recent observations concerning the close
relation between constrained type systems and simple type systems [PS96] allow us to establish soundness based on
soundness of a simple type system. We believe this direct approach to type soundness of constrained type systems
should be applicable to other constrained type languages.

Amadio and Cardelli [AC93] present a type system `_ with recursive types (modeled by regular trees) and a
subtyping relation on them equivalent to ^tree. This system can be applied to the let-free fragment of our language
to produce sequents of the form \Phi  `_ e : ', where \Phi  is a finite map from variables to regular trees whose role in our
type system `T is played by a context A.

We now establish that a typing derivation in `Tsem can be viewed as a family of derivations in `_.

DEFINITION 5.1 The let-expansion LE(e) of a term e is defined as the homomorphic extension of LE(let X = e0 in e00) =
(LE(e0); LE(e00)[LE(e0)=X]), where the postfix [=] denotes capture-free substituton.

THEOREM 5.2 If ; `Tsem e : ^, then ; `_ LE(e) : ' for each ' 2 Inst(^). If ; `_ LE(e) : ', then ; `Tsem e : ^
for some ^ such that ' 2 Inst(^).

PROOF SKETCH: By induction on the structure of typing derivations. For the first part note that for rule (SUB)
(using ^8sem as the meaning of ^8) the inductive step is trivial, since each instance of the larger constrained type is a
supertype (w.r.t. ^tree) of an instance of the smaller one; for the other rules, an assignment satisfying the constraint
system in the conclusion also satisfies those in the premises. For the second part, observe that for each \Phi  and ' there
is a constrained type whose (unique) instance is \Phi  ) '. 2

COROLLARY 5.3 The type system `Tsem is sound.

4A version sound with respect to call-by-value can be obtained by defining let

v X = e in e0 as let X = e in (X; e0) for type-checkingpurposes.

5We write the inference rules with a top-down propagation of the contexts; a bottom-up presentation with synthesized context components
is also possible.

15

PROOF: Implied by the soundness of `_ [AC93]: the typability of a term e under `Tsem implies the typability of
LE(e) under `_, which by soundness of `_ implies that the evaluation of LE(e) will not cause a run-time error. Since
the let-expansion of e is observationally equivalent to e, this implies that the evaluation of e is free of run-time errors.
2

COROLLARY 5.4 The type system `Tdec is sound.
THEOREM 5.5 The inference system `I is complete with respect to `Tsem .
PROOF SKETCH: We demonstrate that for each term the type inferred by `I is principal,6 i.e. minimal with respect
to the relation ^8sem among types provable for this term by `Tsem . The proof proceeds by induction on the derivation
structure. 2

6 Related Work
Pottier [Pot96] has independently derived results that are related to some results of this paper. He defines a syntactic
and a semantic notions of entailment on constraint sets, shows they are equivalent, and presents a type system with
subsumption based on this entailment. He also provides an algorithm for an approximation to the entailment relation,
which appears equivalent to K ` o/ ^ o/ 0 for canonical K; finally, the theory is used as a basis for proving the
soundness of a number of constrained type simplifications. However the entailment relations do not take into account
reachability of type variables, which depends on the polarity of their occurrences and hence on the root type; in
particular his syntactic entailment C0 ` C00 requires C00 [ C to be consistent whenever C0 [ C is, for any constraint
set C, including sets that put bounds on unreachable type variables, which is not possible during type inference.
As a consequence both the relation between constrained types, implied by his subsumption rule, and its decidable
approximation are strictly less powerful than ours. The algorithm for verifying entailment uses explicit unions and
intersections in place of the canonicalization of the constraint maps in our rules; this may be a less efficient method if
the relation is to be implemented.

Jim [Jim96a] also defines a notion of ^8 that relates fewer types than ours but is still powerful enough to
prove some principal typing properties for constrained type systems. His ^8 relation is based on a combination of

substitution and primitive subtyping, namely (in terms of this paper) 8t0: A0 ) o/ 0 n C0 ^8 8t00: A00 ) o/ 00 n C00 if
there exists a substitution S on ft0g such that C00 ` SC0 [ (A00 ^ SA0) [ fSo/ 0 ^ o/ 00g. Given this substitution one
can construct the consistent canonical map K = (Can(Ker(C00)); Can(Ker(C0) [ ft0 ^ St0; t0 * St0g)) satisfying
the requirements of Definition 4.5; hence ^0 ^8 ^00 implies ^0 ^8dec ^00. However the converse fails: for instance
8t: hi ) t n f? ! ? ! t ^ tg ^8 8t: hi ) t n f? ! t ^ tg, but not the other way around as allowed by ^8dec.

Bourdoncle and Merz [BM96] have independently addressed the problem of subtyping constrained types in the
context of a system where recursive constraints are not allowed, with applications to typing of object-oriented programs
with multi-methods. The idea of a semantic relation on polymorphic constrained types in the style of ^8sem appears to
have been first advocated by them. Their semantic subtyping relation can be defined over simple ground types that do
not include recursive types since their constraint sets have no cyclic dependences. The rejection of cyclic constraint
structures significantly changes the problem, and a direct comparison of results may be misleading. The presence of
cycles makes our theory more complex (and, possibly even undecidable); without cycles, their theory is decidable.
Their approach has the advantage that it is simpler, but the disadvantage that it is not as complete (and, is not as closely
tied to flow analysis).

6Principal constrained types in our system correspond to principal typings in other type systems [Jim96b], because our constrained types
include the typing context. Our system has no principal typings with respect to the let-environment \Gamma .

16

7 Conclusions
There are still many questions to be dealt with before a full language design based on polymorphic constrained type
inference can be proposed. Verification of type interfaces (signatures) between separately compiled modules and the
functors applied to them is one aspect which requires a powerful and sound subtyping relation between constrained
types. Constrained subtyping is also useful for type simplification: a constrained type may be replaced by a simpler
but equal one.

This paper establishes a foundation for constrained type theory, in particular via a powerful characterization of
subtyping on constrained types. We introduce two natural notions of subtyping, observational ^8obs and semantic ^8sem,
and prove that they are equivalent; we further give a decidable approximation ^8dec to these relations. Both results
represent improvements over recent work on subtyping of constrained types with recursive constraints [EST95a, Pot96,
Jim96a]. We also introduce a novel closed form of constraint types with contexts, which eliminates the problems
associated with free type variables. Finally, we present a type system with principal constrained types, and establish
its soundness via reduction to the system of Amadio and Cardelli.

The most generous relations ^8sem and ^8obs may be undecidable, but we believe that ^8dec is powerful enough to
be useful in practice for signature matching and constraint simplification. Our confidence in the system stems from
the fact that ^8dec subsumes the Amadio/Cardelli subtyping of recursive types, the type scheme instantiation in the
Hindley/Milner system, and the subtyping relation of [Pot96]. Additionally, it turns out that the known simplifications
of constraint sets do not test the limits of the system based on ^8dec; indeed we have shown in this paper that ^8dec can
be used to demonstrate the correctness of simplifications not included in other systems. Similarly, functor signatures
may generally be produced by starting with an inferred constrained type and transforming it in regular ways, thus
avoiding constrained types which ^8dec does not relate to the inferred type. We have yet to find a realistic subtyping
example which is semantically sound but is not derivable using ^8dec, but most convincing would be the performance
of a system that uses it for signature matching and simplifications in practice on real code; we are in the process of
constructing an implementation for this purpose.

References
[AC93] R. Amadio and L. Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages and Systems,15(4):575-631, September 1993. Extended abstract in POPL 1991.

[AW93] A. Aiken and E. L. Wimmers. Type inclusion constraints and type inference. In Proceedings of the InternationalConference on Functional Programming Languages and Computer Architecture, pages 31-41, 1993.
[AWL94] A. Aiken, E. L. Wimmers, and T. K. Lakshman. Soft typing with conditional types. In Conference Record of theTwenty-First Annual ACM Symposium on Principles of Programming Languages, pages 163-173, 1994.
[BCC+96] Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Ben-jamin Pierce. On binary methods.

Theory and Practice of Object Systems, 1996. (to appear; see
ftp://ftp.cs.iastate.edu/pub/techreports/TR95-08/TR.ps.Z).

[BM96] Franc,ois Bourdoncle and Stephan Merz. On the integration offunctional programming, class-based object-oriented programming, and multi-methods. Manuscript. Available at

http://www.ensmp.fr/~bourdonc/mlsub.html, 1996.
[Car84] L. Cardelli. A semantics of multiple inheritance. In Semantics of Data Types, volume 173 of Lecture notes in

Computer Science, pages 51-67. Springer-Verlag, 1984.

[Cou83] B. Courcelle. Fundamental properties of infinite trees. Theoretical Computer Science, 25:95-169, 1983.
[Cur90] Pavel Curtis. Constrained quantification in polymorphic type analysis. Technical Report CSL-90-1, XEROX PaloAlto Research Center,

CSLPubs.parc@xerox.com, 1990.

[EST95a] J. Eifrig, S. Smith, and V. Trifonov. Sound polymorphic type inference for objects. In OOPSLA '95, pages 169-184,1995.

17

[EST95b] J. Eifrig, S. Smith, and V. Trifonov. Type inference for recursively constrained types and itsapplication to OOP. In Proceedings of the 1995 Mathematical Foundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer Science. Elsevier, 1995.
http://www.elsevier.nl/locate/entcs/volume1.html.

[ESTZ95] J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. An interpretation of typed OOP in a language with state. Lisp andSymbolic Computation, 8(4):357-397, 1995.

[FM88] Y.-C. Fuh and P. Mishra. Type inference with subtypes. In European Symposium on Programming, 1988.
[Jim96a] Trevor Jim. Principal typings and type inference. PhD thesis, MIT, 1996. (to appear).
[Jim96b] Trevor Jim. What are principal typings and what are they good for? In Conference Record of the Twenty-ThirdAnnual ACM Symposium on Principles of Programming Languages, 1996.

[JW95] Suresh Jagannathan and Andrew Wright. Effective flow analysis for avoiding run-time checks. In Proceedings of the2nd International Static Analysis Symposium, volume 983 of LNCS, pages 207-224. Springer-Verlag, 1995.
[Kae92] S. Kaes. Type inference in the presence of overloading, subtyping and recursive types. In ACM Conference on Lisp

and Functional Programming, pages 193-204, 1992.

[Mit84] John C. Mitchell. Coercion and type inference (summary). In Conference Record of the Eleventh Annual ACM

Symposium on Principles of Programming Languages, 1984.

[Mit91] John C. Mitchell. Type inference with simple subtypes. Journal of Functional Programming, 1:245-285, 1991.
[MPS86] D. B. MacQueen, G. Plotkin, and R. Sethi. An ideal model for recursive polymorphic types. Information and Control,71:95-130, 1986.

[MR85] P. Mishra and U. Reddy. Declaration-free type checking. In Conference Record of the Twelfth Annual ACM Symposiumon Principles of Programming Languages, pages 7-21, 1985.
[PO95] Jens Palsberg and Patrick O'Keefe. A type system equivalent to flow analysis. In Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, pages 367-378, 1995.
[Pot96] Franc,ois Pottier. Simplifying subtyping constraints. In First International Conference on Functional Programming,1996. (to appear).
[PS92] Jens Palsberg and Michael I. Schwartzbach. Safety analysis versus type inference for partial types. InformationProcessing Letters, pages 175-180, 1992.
[PS96] Jens Palsberg and Scott Smith. Constrained types and their expressiveness. TOPLAS, 1996. (to appear;

ftp://ftp.cs.jhu.edu/pub/scott/cte.ps.Z).

18