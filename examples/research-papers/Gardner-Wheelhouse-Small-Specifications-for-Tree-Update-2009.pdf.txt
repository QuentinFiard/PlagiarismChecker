

Small Specifications for Tree Update

Philippa Gardner and Mark Wheelhouse
Imperial College London, {pg, mjw03}@doc.ic.ac.uk

Abstract. O'Hearn, Reynolds and Yang introduced Separation Logic to
provide modular reasoning about simple, mutable data structures in memory. They were able to construct small specifications of programs, by reasoning about the local parts of memory accessed by programs. Gardner,
Calcagno and Zarfaty generalised this work, introducing Context Logic to
reason about more complex data structures. In particular, they developed a
formal, compositional specification of the Document Object Model, a W3C
XML update library. Whilst keeping to the spirit of local reasoning, they
were not able to retain small specifications. We introduce Segment Logic,
which provides a more fine-grained analysis of the tree structure and
yields small specifications. As well as being aesthetically pleasing, small
specifications are important for reasoning about concurrent tree update.

1 Introduction
Separation Logic [13], introduced by O'Hearn, Reynolds and Yang, provides
modular reasoning about mutable data structures in memory. The idea is to
reason about the small, local parts of memory (the footprint) that are accessed by
a program. The resulting modular reasoning has been used to notable success for
verifying memory safety properties of large C-programs [1], and for reasoning
about concurrent imperative programs [14]. Calcagno, Gardner and Zarfaty
generalised this work to more complex data structures, such as those found on
the Web, by introducing Context Logic for reasoning about arbitrary structured
data update [3]. Their original work applied Context Logic reasoning to a simple
tree update language. With Smith and Zarfaty, Gardner and Wheelhouse have
since applied Context Logic reasoning to the W3C Document Object Model
(DOM) [6], a library for in-place XML update [18].

Our goal is to design and formally specify a concurrent XML update language. Such a language will enable web applications to make the most of the
dynamic nature of XML. For example, with Wikipedia, users currently copy
articles on to their browsers, before updating and returning them to Wikipedia
to be integrated with the main site. They cannot view Wikipedia (or a scientific database or information in the Cloud) as a shared XML memory store
that can be concurrently updated by many clients, because methods for safely
performing such operations are poorly understood. We almost have the technology to develop a safe, formally specified language for concurrent XML update,
drawing on our experience experience with sequential DOM [6] and O'Hearn's
Concurrent Separation Logic [14]. However, we are missing one ingredient.

In our DOM work, we were not able to provide small specifications for all
our DOM programs. In particular, our reasoning for the basic move commands,

2 Philippa Gardner and Mark Wheelhouse

Fig. 1. Splitting up the Working Tree using Multi-holed Contexts.
such as DOM's appendChild, used axioms which required a substantial overapproximation of the footprint. Whilst this over-approximation was acceptable
for reasoning about sequential programs, it is a serious limitation when reasoning about concurrent programs. In this paper, we solve this limitation, by
introducing Segment Logic to provide a more fine-grained analysis of structured
data update in general, and tree update in particular. We provide small axioms
for all the basic commands of a simple tree update language; it is straightforward
to extend our ideas to DOM [6]. Although this paper focuses on a sequential
tree update language, we believe it provides the technology necessary for our
future work on reasoning about concurrent tree update.

To motivate Segment Logic, consider the DOM command appendChild (n; m)
which moves the tree with top node identified by m to be the last child of the
tree identified by n. Fig. 1 indicates how the working tree splits in the two cases
where appendChild(n; m) does not fault: it succeeds when n and m are in different
parts of the tree and when m is under n; it faults when m is above n. The axiom
for appendChild(n; m) using multi-holed Context Logic [2] is 1:

{(C ffiff n[c1]) ffifi m[tree(c2)]}

appendChild (n; m)
{(C ffiff n[c1 \Omega  m[tree(c2)]]) ffifi ?}

The precondition specifies that the working tree can be split into a subtree with
top node m, and a tree context with hole variable fi (y in Fig. 1) satisfying the
separating application formula C ffiff n[c1]. This formula states that the context
can be further split into a subcontext with top node n and an unspecified context
with hole ff (x in Fig. 1) given by context variable C. The postcondition states
that the tree at m is moved to be the last child of n and is replaced by the empty
tree. The surrounding context, denoted by variable C, remains the same.

The problem with this appendChild axiom is that it is not small. The precondition is not the intuitive footprint. The only part of the tree that appendChild(n; m)
requires is the tree at m which is being moved, and the tree or context with top
node n (actually node n is enough) whose children are being extended by m.
However, our precondition does not just use m and n. It also requires the surrounding context denoted by C. It is possible to put additional constraints on C

1 In [6], the axiom for appendChild is given using single-holed Context Logic. The multiholed Context Logic axiom is simpler, but still not suitable for concurrent reasoning.

Small Specifications for Tree Update 3
Fig. 2. Splitting up the Working Tree using Tree Segments.
to insist that the context is minimal. But this is not the point. We need a finer way
of analysing the tree in order to capture the intuitive footprint of the command.

Instead of basing our reasoning on multi-holed tree contexts and application,
we base our reasoning on tree segments. With multi-holed contexts, the working
tree is split into a context and subtrees which have lost the information about
where they originated from; the application function determines which holes
get filled. With segments, the working tree is split into tree segments which
still `know' how to join back together again. As well as unique hole labels,
tree segments have unique hole addresses which determine which holes the
segments fill. For example, consider Fig. 2. In both cases, the working tree is
split into a bunch of tree segments. The hole labels (in the holes) and the hole
addresses (on the arrows) determine how the tree segments join back up to form
the original tree. Notice that hole labels and addresses have brackets around
them, denoting that they are bound. In the syntax, we will use a hiding operator
(x), analogous to the restriction operator of Milner's ss-calculus [12].

Moreover, consider the right-hand equalities of Fig. 2. In both cases, the tree
segment with top node identified by n has been split into just the node n at
the same address and fresh hole label z, plus another tree segment at address
z which contains the children of node n. We shall see that the node n and the
tree with top node m are all that is required to provide the small axiom for
appendChild. Fig. 2 thus indicates how we can uniformly separate the minimal
data required in order to reason about appendChild. It is possible to take this
separation to the extreme, by cutting up the tree structure into a collection of
nodes, with the hole labels and addresses showing how the nodes are joined
together (a spaghetti of wires analogous to a heap representation). However,
this is not how we use the hole information. We only cut up the tree in a minimal
way in order to provide the right segment about which to reason.

We introduce Segment Logic for reasoning about our tree segments. It is like
Context Logic in that it reasons directly about high-level trees. It is like Separation Logic in that it uses a commutative separating conjunction *, rather than
the non-commutative separating application of Context Logic. Using Segment
Logic, the small axiom for appendChild(n; m) is:

{ff\Gamma n[fl] * fi\Gamma m[tree(c)]}

appendChild(n; m)
{ff\Gamma n[fl \Omega  m[tree(c)]] * fi\Gamma ?T}

4 Philippa Gardner and Mark Wheelhouse
The precondition specifies two tree segments: a node n at address variable ff
(x in Fig. 2) and a complete tree whose top node is m at address fi (y in Fig 2).
The postcondition states that the tree at m moves to be the last child of n and is
replaced by the empty tree. The axiom is small, with the precondition capturing
the intuitive footprint of appendChild(n; m). We can extend the axiom to larger
tree segments using the normal separation frame rule, a rule for the hiding
quantification, and the rule for logical consequence. In fact, instead of using the
hiding quantifier as primitive, we use the basic revelation connective (and a
revelation frame rule), the revelation magic wand (the revelation right adjoint),
and the fresh label quantification (and a fresh variable elimination rule), inspired
by the work of Gabbay and Pitts [5], and Cardelli and Gordon [4]. Interestingly,
we shall see that these more primitive constructs are important for describing
the weakest preconditions.

2 Tree Update Language
We study a simple, but expressive, high-level tree update language for manipulating finite, ordered, unranked trees, with unique node identifiers for specifying
the locations of updates as in DOM. Our tree structures are left intentionally
simple. It is straightforward to incorporate (and reason about) additional data
such as text data and attributes (see [6]). To simplify our exposition, we work
with multi-holed tree contexts [2]. Throughout this paper we use countably
infinite and disjoint sets Id = {m; n; :::} for location names and X = {x; y; z; :::} for
hole identifiers.

Definition 1 (Tree Contexts). Multi-holed tree contexts c 2 CId;X are defined by:

tree context c ::= ?C empty tree context

x hole identifier x used as a hole label
n[c] tree context with top node n
c \Omega  c composition of tree contexts

with the restriction that each hole identifier, x 2 X, and location name, n 2 Id, occur
at most once in a tree context c, and subject to an equivalence c1jc2 stating that \Omega  is
associative with identity ?C. The set of hole identifiers that occur in tree context c is
denoted f ree(c). A tree context with no context holes (a complete tree) is denoted t.

Definition 2 (Context Application). Context Application is defined as a set of partial
functions apx : CId;X * CId;X * CId;X indexed by hole labels x:

apx(c1; c2) = ( c1[c2=x] if x 2 f ree(c1) and f ree(c1) " f ree(c2) = {}undefined otherwise
We abbreviate apx(c1; c2) by c1 ffix c2. We often omit the ?C leaves from a tree
context to make it more readable, writing n[m \Omega  p] instead of n[m[?C] \Omega  p[?C]].

Our update language is a high-level, stateful, sequential, imperative language, based on variable assignment and update commands as in DOM. The
program state is made up of two components: the working tree which contains
all of the nodes we will be manipulating with our programs; and a high-level
variable store containing variables for node identifiers.

Small Specifications for Tree Update 5
Definition 3 (Variable Store). The variable store oe 2 \Sigma  is a finite partial function

oe : VarId *fin Id [ {null}
mapping location name variables VarId = {m; n; :::} to location names or null. We write
oe[n 7! n] for the variable store oe overwritten with oe(n) = n.

To specify location name values, our language uses simple expressions. Location
names are specified either with location name variables or the constant null;
we forbid direct reference to constant location names other than null. We also
require simple Boolean expressions for conditional tests in our language.

Definition 4 (Expressions). Location name expressions N 2 ExpId and Boolean expressions B 2 ExpB are defined by:

N ::= n | null n 2 VarId
B ::= N = N | false | B ) B

The valuation of an expression E in a store oe is written ~E"oe and has the obvious
semantics. The classical Boolean connectives true, ~, ^ and . are derivable.

DOM commands tend to update whole trees although, for example, the
DOM commands getNodeName and createNode manipulate single nodes. Since
our reasoning analyses tree segments, we explore a language for manipulating
tree segments with primitive commands that update either a single node n or
the whole subtree beneath some node n; the commands for updating whole
trees are derivable (Example 1).

Definition 5 (Tree Update Language). The commands of the tree update language
consist of the node update commands CnodeUp, the tree update commands CtreeUp and
the standard skip, assignment, local, sequencing, if-then-else and while-do commands:

CnodeUp ::= n0 := getUp(n) get parent of node n and record it in n0

n0 := getLeft(n) get previous sibling of node n
n0 := getRight(n) get next sibling of node n
n0 := getFirst(n) get first child of node n
n0 := getLast(n) get last child of node n
insertNodeAbove(n) insert a new node above node n
deleteNode(n) delete node n
moveNodeAbove(n; m) move node m above node n
moveNodeLeft(n; m) move node m to the left of node n
moveNodeRight(n; m) move node m to the right of node n
prependNode(n; m) prepend node m to children of node n
appendNode(n; m) append node m to children of node n

CtreeUp ::= deleteSubtree(n) delete subtree (subforest) beneath node n

moveSubLeft(n; m) move children of node m to the left of node n
moveSubRight(n; m) move children of node m to the right of node n
prependSub(n; m) prepend children of node m to children of node n
appendSub(n; m) append children of node m to children of node n

The set of free variables of a command C is denoted free(C), and the set of variables
modified by C is denoted mod(C).

6 Philippa Gardner and Mark Wheelhouse

The behavior of these commands should be self-explanatory. The node update commands consist of get commands that return a neighboring node in the
tree, a node insertion command that puts a fresh node into the tree above node
n (the other node insertion commands are derivable), a delete command that
removes a node from the tree, and node move commands that take a node out
of the tree and put it in a new position. These node move commands leave
the children of the moved node m as children of m's old parent. The tree update
commands work on subtrees of an identified node. They consist of a delete command that removes an entire subtree from the tree, and subtree move commands
that take a subtree out of the tree and put it in a new position.

These commands are sufficient to express a wide range of tree manipulation, as illustrated by the examples below. Our command set is not minimal: for
example, we could derive the deleteSubtree command using a combination
of get commands, node deletion and recursion. However, we believe the commands chosen provide a natural and expressive tree update language. We give
the operational semantics in Section 3 using tree segments, rather than trees or
tree contexts, as this simplifies the description of our reasoning in Section 5.

In [8], there are also commands for inserting whole trees. This is achieved by
including tree shapes (trees without identifiers) in the variable store. Here we
avoid such complications by omitting commands for tree insertion and copying.
The reasoning presented here extends simply to these extra commands.

We now give example programs which will be used to illustrate our reasoning in Section 5. In all of these examples, oe(n) = 1 and oe(m) = 2.

Example 1 (Move). DOM has the command appendChild, whereas our language
has appendNode and appendSub. We implement the standard appendChild as:

appendChild(n; m) , local temp := null in {

insertNodeAbove(m) ;
temp := getUp(m) ;
appendNode(n; m) ;
appendSub(m; temp) ;
deleteNode(temp)
}

The diagrams illustrate the intuitive effect of the program on the working tree.
For the program above not to fault, it requires the node n = 1 and the complete
tree at node m = 2 (the left-hand diagram and the intuitive footprint). The
complete tree at m ensures that m is not an ancestor of n. The result of the
program is to move the tree at m = 2 to be under the node n = 1 (the right-hand
diagram). Our reasoning captures the intuition illustrated by these diagrams.

Example 2 (Simple Swap). Our node update commands enable us to define programs that act on arbitrary segments of the tree. For example, consider the
program simple(n) which swaps a node n with its first child:

Small Specifications for Tree Update 7
simple(n) , local temp := null; first := null in {

insertNodeAbove(n) ;
temp := getUp(n) ;
first := getFirst(n) ;
moveNodeAbove(first; n) ;
moveNodeAbove(temp; first) ;
deleteNode(temp)
}

Example 3 (General Swap). The program nodeSwap(n; m) swaps the positions of
arbitrary nodes n and m of a tree leaving their subtrees stationary:

nodeSwap(n; m) , local temp := null in {

insertNodeAbove(n) ;
temp := getUp(n) ;
moveNodeAbove(m; n) ;
moveNodeAbove(temp; m) ;
deleteNode(temp)
}

Example 4 (Node Rotate). The program nodeCycle(n) takes the node n, its first
and last child, and rotates these nodes with n taking the place of first child, first
child taking the place of last child, and last child taking the place of n:

nodeCycle(n) , local first := null; last := null in {

first := getFirst(n) ;
last := getLast(n) ;
nodeSwap(n; last) ;
nodeSwap(n; first)
}

Example 5 (Combining Move and Node Swap). Consider a simple cyclic list of
pictures used, for example, to view properties on an estate agent's web page. It
can be implemented as a tree structure, with the root node of the tree containing
the ID of the picture currently being displayed, the picture itself being stored
beneath the last of its children (under node 3 below), and the other pictures in
the list being stored beneath their ID nodes as the rest of the root node's children.
The program queuePop(n) cycles the pictures so that the current picture moves
to the back of the list and the next picture is displayed. Notice the use of
appendChild which includes the complete tree t in the footprint.

queuePop(n) , local next := null; info := null in {

next := getFirst(n) ;
info := getLast(n) ;
nodeSwap(n; info) ;
nodeSwap(next; info) ;
appendChild(next; info)
}

8 Philippa Gardner and Mark Wheelhouse
3 Tree Segments
We are not able to provide a small specification of the appendChild command
(and the appendSub command) using tree contexts. We are able to provide small
specifications for all our tree update commands using tree segments.

Definition 6 (Tree Segments). Tree segments s 2 SId;X are defined by the grammar:

tree segment s ::= ?S empty tree segment

x\Gamma c tree context c addressed by hole identifier x
s + s disjoint union
(x)(s) hiding, hole identifier x bound in tree segment s

with the restriction that each hole identifier x 2 X occurs free at most once as a hole label
and at most once as a hole address in tree segment s, and each location name, n 2 Id,
occurs at most once in s. The set f ree(s) denotes the set of free hole identifiers in s.

With tree contexts, we have the application (1[x \Omega  3])ffix 2 = 1[2 \Omega  3]. The application ffix binds x, and declares that hole x is filled by the argument 2. With tree
segments, we have the equivalence (x)(z\Gamma 1[x \Omega  3] + x\Gamma 2) j z\Gamma 1[2 \Omega  3]. In this
case, it is the segment x\Gamma 2 with address x that declares that 2 should go into the
hole x, and the hiding operator (x) which binds x in the segment.

Definition 7 (Tree Segment Equivalence). An equivalence relation j over tree
segments is defined by the following axioms and the natural structural rules:

s + ?S j s
(x)(?S) j ?S

s1 + s2 j s2 + s1
s1 + (s2 + s3) j (s1 + s2) + s3

(x)(y)(s) j (y)(x)(s)

(x)(s) j (y)(s[y=x]) if y ! f ree(s)
(x)(y\Gamma c + s) j y\Gamma c + (x)(s) if x , y and x ! f ree(c)
(x)(y\Gamma c1 + x\Gamma c2) j y\Gamma (c1 ffixc2) if x 2 f ree(c1)

Most of the axioms involving hiding follow from analogous axioms for the
restriction operator of the ss-calculus [12]. The last hiding axiom is specific to tree
segments. It enables us to pull apart and compress segments, as illustrated in
Fig. 3. A tree segment is in its compressed form if it cannot be further compressed
using this last axiom. A tree segment is well-formed if and only if its compressed
form is cycle free; that is, the hole labels and hole addresses are disjoint in its
compressed form. We only work with well-formed tree segments in this paper.

Fig. 3 demonstrates a graphical interpretation of segments. The left-hand
side of Fig. 3 will come as no surprise to those familiar with graphical process
models: for example, Milner's work on process graphs [11]. Here, the hole
identifiers describe the edges of the graph (wires). However, this is not the only
use of hole identifiers. Consider the right-hand side of Fig. 3. Here, the hole
identifier y is used to address multiple edges of a graph. More than this, consider
the appendChild command in Example 1. The tree segment z\Gamma 1[x] + y\Gamma 2[t]
updates to z\Gamma 1[x \Omega  2[t]] + y\Gamma ?C: before update the segment y\Gamma 2[t] states that a
tree is at address y; after update y\Gamma ?C states that the empty tree is at address y.

Small Specifications for Tree Update 9
Fig. 3. Equivalent Tree Segments: (x) and (y) denote hidden hole labels and addresses.
This example illustrates that edge arity is not necessarily preserved by update.
Our hole identifiers should therefore not be regarded as describing graph edges.
Instead, they describe tree fragments.

Notice that our language manipulates nodes and complete trees. It does
not refer to hole identifiers in any way. However, the operational semantics is
greatly simplified by using either tree contexts or tree segments. We choose tree
segments, as this leads to a simpler interpretation of Hoare triples in Section 5.

Definition 8 (Operational Semantics). We give the operational semantics for the
basic commands of the tree update language in Fig. 4 using an evaluation relation
 relating configuration triples C; oe; s, terminal states oe; s, and faults, where C is a
command, oe is a variable store and s is a tree segment. The set of variables of a command
C is denoted free(C) and is contained within the domain of oe, denoted dom(oe). We omit
the standard cases for skip, assignment, local, sequencing, if-then-else and while-do.

Our style of local Hoare reasoning about programs requires that the commands of our language be local. A command is local if it satisfies two properties,
initially introduced in [10], known as the safety-monotonicity property and the
frame property. The safety-monotonicity property specifies that, if a command is
safe (does not fault) in a given state, then it is safe in a larger state. The frame
property specifies that, if a command is safe in a given state, then any execution
on a larger state can be tracked to an execution on the smaller state. The commands of our language presented here (and the DOM commands [6]) are local.
For example, consider the behavior of n0 := getRight(n). If the right sibling of n
exists, then its identifier is stored at n'. If n is the last child of some parent node
(meaning n can never obtain a right sibling via segment composition), then n'
stores the value null. However, if the node n is not present in the tree, or n has
no right sibling or parent, then the command must fault in order to be local.

4 Segment Logic
We introduce Segment Logic. First, we present the logical environment which
contains logical variables for tree contexts, tree segments and hole identifiers.
Location name variables have the standard dual role as both program variables and logical variables. They are declared in the variable store, but can be
quantified like logical variables.

Definition 9 (Logical Environment). An environment e 2 E is a set of functions

e : (LVarC ! CId;X) * (LVarS ! SId;X) * (LVarX ! X)
mapping tree context variables LVarC = {c; :::} to tree contexts, tree segment variables
LVarS = {s; :::} to tree segments, and hole identifier variables LVarX = {ff; fi; fl; ffi:::} to
hole identifiers. We write e[lvar 7! val] for e overwritten with e(lvar) = val.

10 Philippa Gardner and Mark Wheelhouse

oe(n) = n s j (w;x;y;z)(s0+ x\Gamma m[y \Omega  n[w] \Omega  z])

n0 := getUp(n); oe; s  oe[n0 7! m]; s

oe(n) = n s j (x;y;z)(s0+ x\Gamma n[y] \Omega  m[z])

n0 := getRight(n); oe; s  oe[n0 7! m]; s

oe(n) = n s j (x;y;z)(s0+ x\Gamma m[z \Omega  n[y]])

n0 := getRight(n); oe; s  oe[n0 7! null]; s

oe(n) = n s j (x;y;z)(s0+ x\Gamma n[y \Omega  m[z]])

n0 := getLast(n); oe; s  oe[n0 7! m]; s

oe(n) = n s j (x)(s0+ x\Gamma n[?C])
n0 := getLast(n); oe; s  oe[n0 7! null]; s

oe(n) = n s j (x;y)(s00+ x\Gamma n[y])
m fresh id s0 j (x;y)(s00+ x\Gamma m[n[y]])

insertNodeAbove(n); oe; s  oe; s0

oe(n) = n s j (x;y)(s00+ x\Gamma n[y])

s0 j (x;y)(s00+ x\Gamma y)

deleteNode(n); oe; s  oe; s0

oe(n) = n s j (x)(s00+ x\Gamma n[t])

s0 j (x)(s00+ x\Gamma n[?C])

deleteSubtree(n); oe; s  oe; s0

oe(n) = n oe(m) = m
s j (w;x;y;z)(s00+ x\Gamma n[z] + y\Gamma m[w])
s0 j (w;x;y;z)(s00+ x\Gamma n[z\Omega m] + y\Gamma w)

appendNode(n; m); oe; s  oe; s0

oe(n) = n oe(m) = m
s j (x;y;z)(s00+ x\Gamma n[z] + y\Gamma m[t])
s0 j (x;y;z)(s00+ x\Gamma n[z\Omega t] + y\Gamma m)

appendSub(n; m); oe; s  oe; s0

oe(n) = n oe(m) = m
s j (w;x;y;z)(s00+ x\Gamma n[z] + y\Gamma m[w])
s0 j (w;x;y;z)(s00+ x\Gamma m[n[z]] + y\Gamma w)

moveNodeAbove(n; m); oe; s  oe; s0

For get and move, only some of the cases are given; the other cases are analogous. Our commands
fault when the program state does not satisfy any of the preconditions for that command.

Fig. 4. Operational Semantics for the Basic Tree Update Commands.

Segment Logic for trees consists of segment formulae and tree formulae. Just
as in Separation Logic and Context Logic, segment formulae consist of classical
formulae, structural formulae and specific formulae for describing the structure
of data (in this case trees). For this paper, we have chosen to use tree formulae
in the style of Ambient Logic [4], although we do not see a reason why PT could
not be first-order logic formulae for describing trees or even XDuce types [9].
Note that adapting this work to other data structures, such as sequences, just
involves changing the tree formulae (or types) to sequence formulae (or types).

Definition 10 (Formulae). The formulae of Segment Logic for trees consist of the
segment formulae PS and tree formulae PT given by:

PS; QS ::= PS ) PS | falseS

| ?S | PS * PS | PS-*PS | ffrPS | ff-rPS
| 9var: PS | 9lvar: PS | Nff: PS
| ff\Gamma PT
| s | B

PT; QT ::= PT ) PT | falseT Classical

Structural
| 9var: PT | 9lvar: PT Quantifiers
| ?T | ff | n[PT] | PT \Omega  PT Specific
| c | B | @Tff Expression
Let f ree(PS) and f ree(PT) denote the appropriate sets of free variables: ff is free in ffrPS
ff-rPS, ff\Gamma PT and @Tff, bound in Nff: PS. var is a location name variable and lvar is
a logical variable. The binding precedence, strongest first, is: \Omega , \Gamma , *, r, -*, -r, ).

The separating connective *, its unit ?S and its right adjoint (the separating
magic wand) -*, are structural formulae which are known from the Separation
Logic literature: formula PS *QS describes a segment that can be separated into a
segment satisfying PS and a disjoint segment satisfying QS; formula ?S describes
the empty segment; and formula PS -* QS describes a segment that, whenever
it is joined to a segment satisfying PS, results in a segment satisfying QS.

Before explaining the other structural formulae, we explain the specific segment formulae: the formula ff\Gamma PT describes a tree segment with hole address
given by the value of variable ff and tree context satisfying tree formula PT.
The tree formulae follow the style of reasoning given by Ambient Logic. For

Small Specifications for Tree Update 11
Fig. 5. Connection and Disconnection of Tree Segments.
the specific tree formulae, we have ?T specifying the empty tree context, ff
specifying a hole label given by the value of variable ff, n[PT] specifying a tree
context with top node denoted by node variable n and subtree satisfying PT,
and the composition formula PT \Omega  QT describing a tree context which can be
split into one context satisfying PT and the other disjoint context satisfying QT.
The tree expression formulae include the formula @Tff which describes a tree
that contains ff free; the analogous formula for tree segments is derivable.

The other structural connectives are the revelation connective, r, and its
right adjoint, the revelation magic wand -r. As far as we are aware, these
connectives have not been used in the local reasoning setting before. Together
with the freshness quantifier Nff, they have been used in the Ambient Logic [4],
following the work of Pitts and Gabbay [5]. The freshness quantifier enables us
to pick a completely new hole identifier. The formula ffrPS describes a segment
with a top-level hiding binder given by the value of ff such that, after the hiding is
removed, the remaining segment satisfies PS. Consider the tree segment z\Gamma 1[2\Omega 
3] j (x)(z\Gamma 1[x \Omega  3] + x\Gamma 2). It satisfies the formula ffr(fi\Gamma 1[ff \Omega  trueT] + ff\Gamma 2),
when ff = x; fi = z. The revelation connective ffr strips off the hiding binder,
disconnecting the tree into the fragments z\Gamma 1[x\Omega 3]+x\Gamma 2 as illustrated in Fig. 5.
By contrast, the formula ff -r PS describes a segment which satisfies PS if it is
extended with a hiding binder over the hole identifier stored in variable ff. For
example, the tree segment z\Gamma 1[x\Omega 3]+x\Gamma 2 satisfies the formula ff-r(fi\Gamma 1[2 \Omega  3])
when ff = x. The revelation magic wand ff -r adds the binder (x) to the segment
to obtain the tree segment (x)(z\Gamma 1[x \Omega  3] + x\Gamma 2) j z\Gamma 1[2 \Omega  3], thus connecting
the fragmented tree into the whole tree as illustrated in Fig. 5. Analogous to
the separating magic wand, we shall see that the revelation magic wand is
important for giving the weakest preconditions of commands.

Definition 11 (Satisfaction Relation). Given a logical environment e and a variable
store oe, the semantics of Segment Logic is given in Fig. 6 by two satisfaction relations
e; oe; s |=S PS and e; oe; c |=T PT defined on tree segments and tree contexts respectively.

Definition 12 (Derived Formulae). The standard classical logic connectives are
derived from false and ) as usual, and the following useful formulae are defined:

tree(PT) , PT ^ ~9ff: @Tff

n , n[?T]
ffi[PT] , 9m: m[PT]

@Sff , Hfi: (trueS * (ff\Gamma fi . fi\Gamma ff))

\Sigma PS , trueS * PSH
ff: PS , Nff: ffrPS
Formula tree(PT) describes a complete tree satisfying PT. Formula n describes a
leaf node identified by n. Formula ffi[PT] allows us to drop the identifier of a node.
Formula @Sff describes a tree segment that contains ff free. Formula \Sigma PS allows
us to express that somewhere in the tree segment there is a segment satisfying PS.
Finally, formula Hff: PS provides the standard hiding quantification [4] allowing
us to quantify over hidden (restricted) labels.

12 Philippa Gardner and Mark Wheelhouse

e; oe; s |=S ?S , s j ?S
e; oe; s |=S PS * QS , 9s1; s2: s j s1 + s2 ^ e; oe; s1 |=S PS ^ e; oe; s2 |=S QS
e; oe; s |=S PS -* QS , 8s0: e; oe; s0 |=S PS ^ (s + s0)\Lambda ) e; oe; s + s0 |=S QS
e; oe; s |=S ffrPS , 9x; s0: e(ff) = x ^ s j (x)(s0) ^ e; oe; s0 |=S PS
e; oe; s |=S ff -r PS , 9x; s0: e(ff) = x ^ s0 j (x)(s) ^ e; oe; s0 |=S PS
e; oe; s |=S Nff: PS , 9x: x#e;s ^ e[ff 7! x]; oe; s |=S PS
e; oe; s |=S ff\Gamma PT , 9c; x: e(ff) = x ^ s j x\Gamma c ^ e; oe; c |=T PT
e; oe; s |=S s , s j e(s)
e; oe; s |=S B , ~B"oe = true

e; oe; c |=T ?T , c j ?C
e; oe; c |=T ff , c j e(ff)
e; oe; c |=T n[PT] , 9c1: c j oe(n)[c1]

^ e; oe; c1 |=T PT
e; oe; c |=T PT \Omega  QT , 9c1; c2: c j c1 \Omega  c2

^ e; oe; c1 |=T PT
^ e; oe; c2 |=T QT
e; oe; c |=T c , c j e(c)
e; oe; c |=T B , ~B"oe = true
e; oe; c |=T @Tff , e(ff) 2 free(c)
(s)\Lambda  denotes that s is well formed. x#s denotes that x is fresh with respect to s:

We omit the standard semantics for P ) Q; false and 9v: P:

Fig. 6. Satisfaction Relations of Segment Logic for Trees.
Example 6 (Segment Logic Examples).

(a) The segment formula ff\Gamma n[fl] * fi\Gamma m[ffi] describes a tree segment consisting of

a node n with address ff and context hole fl, and node m with address fi and
context hole ffi. The variables n and m cannot denote the same node identifier:
similarly, ff, fi cannot denote the same hole identifier; neither can fl, ffi.

(b) The segment formula ff\Gamma n[fl] *fi\Gamma m[tree(c)] describes a tree segment consisting of a single node n at address ff and a complete tree (a tree with no holes)
with top node m at address fi. This formula is the safety precondition for
the small axiom of the appendSub(n; m) command. In particular, the formula
states that m cannot be an ancestor of n, as n is disjoint from the tree c.

(c) The segment formula Hff; fi: (ffi\Gamma r[ff \Omega  fi] * ff\Gamma n[fl] * fi\Gamma m[tree(c)]) describes a

tree segment consisting of a node r at address ffi whose children are given by
the holes ff and fi, and a tree segment satisfying the formula in Example (b).
The labels ff,fi are under the hiding quantification, and hence denote fresh,
unequal, identifiers. This formula is equivalent to ffi\Gamma r[n[fl] \Omega  m[tree(c)]],
which states that there is a node r at address ffi whose children are n and m.
(d) To specify our language, it is enough to work with the hiding quantification.

However, to describe the weakest preconditions, we must use revelation.
For example, the weakest precondition of the deleteSubtree(n) command
is 9c: Nff: ffr( (ff\Gamma n[?T] -* (ff -r PS))*ff\Gamma n[tree(c)] ). This formula describes
a tree segment which can be separated into a complete tree, with top node
n at a fresh address x denoted by ff, and a segment s satisfying (ff\Gamma n[?T]) -*
(ff -r PS). The segment s, when extended to (x)(x\Gamma n[?T] + s), satisfies PS.

5 Local Hoare Reasoning
We use Segment Logic to provide local Hoare reasoning about programs written in the language given in Definition 5. First, we give a fault avoiding, partial correctness interpretation of local Hoare triples following [19]. Informally,
{PS} C {QS} means that, when PS holds for a tree segment s, then command C
does not fault when run on s and the result, if C terminates, satisfies QS.

Definition 13 (Local Hoare Triples). Recall the evaluation relation  relating configuration triples C; oe; s, terminal states oe; s and faults in Fig. 4. The fault-avoiding
partial correctness interpretation of local Hoare Triples is given below:

{PS} C {QS} , 8e; oe; s: f ree(C) ` dom(oe) ^ f ree(PS) [ f ree(QS) ` dom(oe) [ dom(e)

^ e; oe; s |=S PS ) C; oe; s 6 fault ^ 8oe0; s0: C; oe; s  oe0; s0 ) e; oe0; s0 |=S QS

Small Specifications for Tree Update 13
{ff\Gamma m[fi \Omega  n[ffi] \Omega  fl] ^ (n0 = n0)} n0 := getUp(n) {(ff\Gamma m[fi \Omega  n[ffi] \Omega  fl])[n0=n0] ^ (n0 = m)}

{ff\Gamma n[ffi] \Omega  m[fi] ^ (n0 = n0)} n0 := getRight(n) {(ff\Gamma n[ffi] \Omega  m[fi])[n0=n0] ^ (n0 = m)}
{ff\Gamma m[fi \Omega  n[ffi]] ^ (n0 = n0)} n0 := getRight(n) {(ff\Gamma m[fi \Omega  n[ffi]])[n0=n0] ^ (n0 = null)}
{ff\Gamma n[ffi \Omega  m[fi]] ^ (n0 = n0)} n0 := getLast(n) {(ff\Gamma n[ffi \Omega  m[fi]])[n0=n0] ^ (n0 = m)}

{ff\Gamma n[?T] ^ (n0 = n0)} n0 := getLast(n) {(ff\Gamma n[?T])[n0=n0] ^ (n0 = null)}

{ff\Gamma n[fi]} insertNodeAbove(n) {ff\Gamma ffi[n[fi]]}
{ff\Gamma n[fi]} deleteNode(n) {ff\Gamma fi}
{ff\Gamma n[tree(c)]} deleteSubtree(n) {ff\Gamma n[?T]}
{ff\Gamma n[fl] * fi\Gamma m[ffi]} moveNodeAbove(n; m) {ff\Gamma m[n[fl]] * fi\Gamma ffi}
{ff\Gamma n[fl] * fi\Gamma m[ffi]} appendNode(n; m) {ff\Gamma n[fl \Omega  m[?T]] * fi\Gamma ffi}
{ff\Gamma n[fl] * fi\Gamma m[tree(c)]} appendSub(n; m) {ff\Gamma n[fl \Omega  tree(c)] * fi\Gamma m[?T]}

n0 and n0 are distinct. The omitted commands have analogous or standard axioms.

Fig. 7. A Selection of the Small Axioms for the Basic Tree Update Commands.

Definition 14 (Small Axioms). The Small Axioms for the basic tree update commands from Fig. 4 are given in Fig. 7.

With Raza, Gardner has developed the formal definitions of footprints and small
specifications for abstract local functions using Abstract Separation Logic [15].
It would be interesting to extend this abstract theory to the tree segments and
reasoning studied here, and prove that the axioms really are small.

Definition 15 (Inference Rules). The local reasoning inference rules include the
standard Hoare Logic Rules for Sequencing, Consequence, Disjunction, Local Variable, If-Then-Else, While-Do, and the rules for Separation Frame, Revelation Frame,
Auxiliary Variable Elimination and Fresh Label Elimination given by:

Separation Frame:

{PS} C {QS}

{PS * RS} C {QS * RS} mod(C) " free(RS) = {}

Revelation Frame:

{PS} C {QS}

{ffrPS} C {ffrQS}

Auxiliary Variable Elimination:

{PS} C {QS}

{9n: PS} C {9n: QS} n ! free(C)

Fresh Variable Elimination:

{PS} C {QS}

{ Nff: PS} C { Nff: QS}
Recall that the set of variables modified by a command C is denoted mod(C).
The Separation Frame rule is standard from Separation Logic and allows us to
extend the working tree with tree segments that are not used by the command.
The Revelation Frame rule is similar. It allows us to add hiding binders to the
working tree, since hole identifiers are not used by any of our commands. The
Fresh Variable Elimination rule is analogous to the standard Auxiliary Variable
Elimination rule. To see how we use these rules, consider again the small axiom
of appendSub. We can extend this axiom using our inference rules to obtain:

{Hff; fi: (ffl\Gamma r[ff \Omega  fi] * ff\Gamma n[fl] * fi\Gamma m[tree(c)])}

appendSub(n; m)
{Hff; fi: (ffl\Gamma r[ff \Omega  fi] * ff\Gamma n[fl \Omega  tree(c)] * fi\Gamma m[?T])}
This triple can be simplified using the consequence rule following the discussion in Example 6(c). In this example, it is natural to use the derived hiding
quantification. Following the discussion in Example 6(d) we can see that the
primitive revelation connectives are, however, necessary to obtain the weakest
preconditions, a selection of which are shown in Fig. 8.

14 Philippa Gardner and Mark Wheelhouse

{9m; n0: Hff;fi;fl;ffi:\Sigma ff\Gamma m[fi \Omega  n[ffi] \Omega  fl] ^ (n0 = n0) ^ (ff;fi;fl;ffi -r PS[m=n0])} n0 := getUp(n) {PS}(

9m; n0: Hff;fi;ffi: \Sigma ff\Gamma n[ffi] \Omega  m[fi] ^ (n

0 = n0) ^ (ff;fi;ffi -r PS[m=n0])

. \Sigma ff\Gamma m[fi \Omega  n[ffi]] ^ (n0 = n0) ^ (ff;fi;ffi -r PS[null=n0]) ) n

0 := getRight(n) {PS}(

9m; n0: Hff;fi;ffi: \Sigma ff\Gamma n[ffi \Omega  m[fi]] ^ (n

0 = n0) ^ (ff;fi;ffi -r PS[m=n0])

. \Sigma ff\Gamma n[?T] ^ (n0 = n0) ^ (ff -r PS[null=n0]) ) n

0 := getLast(n) {PS}

{Hff;fi: ((ff\Gamma ffi[n[fi]] -* (ff;fi -r PS)) * ff\Gamma n[fi])} insertNodeAbove(n) {PS}

{Hff;fi: ((ff\Gamma fi -* (ff;fi -r PS)) * ff\Gamma n[fi])} deleteNode(n) {PS}
{9c: Hff: ((ff\Gamma n[?T] -* (ff -r PS)) * ff\Gamma n[tree(c)])} deleteSubtree(n) {PS}
{Hff;fi;fl;ffi:(((ff\Gamma m[n[fl]] * fi\Gamma ffi) -* (ff;fi;fl;ffi -r PS)) * (ff\Gamma n[fl] * fi\Gamma m[ffi]))} moveNodeAbove(n; m) {PS}
{Hff;fi;fl;ffi:(((ff\Gamma n[fl \Omega  m[?T]] * fi\Gamma ffi) -* (ff;fi;fl;ffi -r PS)) * (ff\Gamma n[fl] * fi\Gamma m[ffi]))} appendNode(n; m) {PS}
{9c: Hff;fi;fl:(((ff\Gamma n[fl \Omega  tree(c)] * fi\Gamma m[?T]) -* (ff;fi;fl -r PS)) * (ff\Gamma n[fl] * fi\Gamma m[tree(c)]))} appendSub(n; m) {PS}

Fig. 8. A Selection of the Weakest Preconditions for our Basic Tree Update Commands.

Theorem 1 (Soundness and Completeness). The small axioms and inference rules
are sound. For straight line code, they are also complete.

Proof Sketch. Soundness is straightforward to prove. Completeness for straight
line code follows from the derivability of the the weakest preconditions (Fig. 8)
from the small axioms (Fig. 7). See the full paper [7] for further details.

Example 7 (Specifying appendChild). In Example 1 we gave the appendChild program. The command's specification and its derivation are:

{ff\Gamma n[fl] * fi\Gamma m[tree(c)]}

appendChild(n; m)
{ff\Gamma n[fl \Omega  m[tree(c)]] * fi\Gamma ?T}

{ff\Gamma n[fl] * fi\Gamma m[tree(c)]}

local temp := null in {
{ff\Gamma n[fl] * fi\Gamma m[tree(c)] ^ (temp = null)}
{Hffi: ff\Gamma n[fl] * fi\Gamma m[ffi] * ffi\Gamma tree(c) ^ (temp = null)}

insertNodeAbove(m) ;
{Hffi: ff\Gamma n[fl] * fi\Gamma ffi[m[ffi]] * ffi\Gamma tree(c) ^ (temp = null)}

temp := getUp(m) ;
{Hffi: ff\Gamma n[fl] * fi\Gamma temp[m[ffi]] * ffi\Gamma tree(c)}
{Hffl; ffi: ff\Gamma n[fl] * fi\Gamma temp[ffl] * ffl\Gamma m[ffi] * ffi\Gamma tree(c)}

appendNode(n; m) ;
{Hffl; ffi: ff\Gamma n[fl \Omega  m[?T]] * fi\Gamma temp[ffl] * ffl\Gamma ffi * ffi\Gamma tree(c)}
{ff\Gamma n[fl \Omega  m[?T]] * fi\Gamma temp[tree(c)]}
{Hffl; ffi: ff\Gamma n[fl \Omega  ffl] * ffl\Gamma m[ffi] * ffi\Gamma ?T * fi\Gamma temp[tree(c)]}

appendSub(m; temp) ;
{Hffl; ffi: ff\Gamma n[fl \Omega  ffl] * ffl\Gamma m[ffi \Omega  tree(c)] * ffi\Gamma ?T * fi\Gamma temp[?T]}
{ff\Gamma n[fl \Omega  m[tree(c)]] * fi\Gamma temp[?T]}

deleteNode(temp) }
{ff\Gamma n[fl \Omega  m[tree(c)]] * fi\Gamma ?T}

Throughout the proof, we use the rules to separate out the footprint of a command, apply the appropriate small axiom, then use the rules to compress the
result back into the original tree.

Example 8 (Specifying Node Manipulation). In Examples 2, 3 and 4 we gave three
node manipulation programs: simple(n), nodeSwap(n; m) and nodeCycle(n). The
specifications for each of these programs are:

{ff\Gamma n[m[fi] \Omega  fl]}

simple(n)
{ff\Gamma m[n[fi] \Omega  fl]}

{ff\Gamma n[fl] * fi\Gamma m[ffi]}

nodeSwap(n; m)
{ff\Gamma m[fl] * fi\Gamma n[ffi]}

{ff\Gamma n[m[fi] \Omega  fl \Omega  l[ffi]]}

nodeCycle(n)
{ff\Gamma l[n[fi] \Omega  fl \Omega  m[ffi]]}
The derivations of these specifications are shown in Fig. 9.

Example 9 (Specifying queuePop). In a similar way, we can derive the following
specification for the queuePop program from Example 5:

{ff\Gamma n[m[tree(c)] \Omega  fl \Omega  i[fi]]}

queuePop(n)
{ff\Gamma m[fl \Omega  n[fi] \Omega  i[tree(c)]]}

Small Specifications for Tree Update 15
simple derivation:
{ff\Gamma n[m[fi] \Omega  fl]}

local temp; first := null in {(
ff\Gamma n[m[fi] \Omega  fl] ^ (temp = null)

^ (first = null) )
insertNodeAbove(n) ;(
ff\Gamma ffi[n[m[fi] \Omega  fl]] ^ (temp = null)

^ (first = null) )
temp := getUp(n) ;
{ff\Gamma temp[n[m[fi] \Omega  fl]] ^ (first = null)}

first := getFirst(n) ;
{ff\Gamma temp[n[first[fi] \Omega  fl]] ^ (first = m)}

moveNodeAbove(first; n) ;
{ff\Gamma temp[n[first[fi]] \Omega  fl] ^ (first = m)}

moveNodeAbove(temp; first) ;
{ff\Gamma first[temp[n[fi] \Omega  fl]] ^ (first = m)}

deleteNode(temp) }
{ff\Gamma first[n[fi] \Omega  fl] ^ (first = m)}
{ff\Gamma m[n[fi] \Omega  fl]}

nodeSwap derivation:
{ff\Gamma n[fl] * fi\Gamma m[ffi]}

local temp := null in {(
ff\Gamma n[fl] * fi\Gamma m[ffi]

^ (temp = null) )

insertNodeAbove(n) ;(
ff\Gamma ffi[n[fl]] * fi\Gamma m[ffi]

^ (temp = null) )
temp := getUp(n) ;
{ff\Gamma temp[n[fl]] * fi\Gamma m[ffi]}

moveNodeAbove(m; n) ;
{ff\Gamma temp[fl] * fi\Gamma n[m[ffi]]}

moveNodeAbove(temp; m) ;
{ff\Gamma m[temp[fl]] * fi\Gamma n[ffi]}

deleteNode(temp) }
{ff\Gamma m[fl] * fi\Gamma n[ffi]}

nodeCycle derivation:
{ff\Gamma n[m[fi] \Omega  fl \Omega  l[ffi]]}

local first; last := null in {(
ff\Gamma n[m[fi] \Omega  fl \Omega  l[ffi]]

^ (first = null) ^ (last = null) )

first := getFirst(n) ;(
ff\Gamma n[first[fi] \Omega  fl \Omega  l[ffi]]

^ (first = m) ^ (last = null) )

last := getLast(n) ;(
ff\Gamma n[first[fi] \Omega  fl \Omega  last[ffi]]

^ (first = m) ^ (last = l) )

nodeSwap(n; last) ;(
ff\Gamma last[first[fi] \Omega  fl \Omega  n[ffi]]

^ (first = m) ^ (last = l) )

nodeSwap(n; first) }(
ff\Gamma last[n[fi] \Omega  fl \Omega  first[ffi]]

^ (first = m) ^ (last = l) )

{ff\Gamma l[n[fi] \Omega  fl \Omega  m[ffi]]}

Fig. 9. Derivations of the Specifications for simple, nodeSwap and nodeCycle.
6 Conclusion
We have introduced Segment Logic for reasoning about structured data update in general, and tree update in particular. Using Segment Logic, we have
demonstrated that it is possible to give small axioms for tree update commands
such as DOM's appendChild command. In this paper, we have concentrated
on a simple, lightweight tree update language. It is straightforward to transfer
the techniques developed here to Featherweight DOM [6]. We do not envisage
difficulties with extending the approach to the full DOM specification [16].

A typical Segment Logic proof separates the working tree into segments,
identifying the tree segment which corresponds to the footprint of a command.
It applies a small axiom to this segment, and compresses the updated fragment
back into the original tree. This separation and compression is key to our Segment Logic reasoning. It is not unlike the unfolding and folding of abstract
predicates, due to Parkinson and Vafeiadis [17]. The difference is that reasoning
using Separation Logic with abstract predicates is implementation dependent:
the formula slist(l; i) describes a list l implemented as a singly-linked list with
heap address i; the formula dlist(l; i; j) describes a list l implemented as a doublylinked list with heap addresses i and j. By contrast, reasoning using Segment
Logic is implementation independent: the formula ff\Gamma P describes e.g. a list or
tree identified and satisfying formula or data type P at abstract address ff.

Our next step is to design and formally specify a concurrent XML update
language, combining ideas from Featherweight DOM, Concurrent Separation
Logic [14] and Segment Logic. We believe that Segment Logic provides us with
crucial technology for achieving this goal. For example, consider the program

deleteTree(n) || deleteTree(m) , which should succeed if the two trees being
called are disjoint. A Segment Logic specification of this program is:

{ff\Gamma n[tree(c1)] * fi\Gamma m[tree(c2)]}
deleteTree(n) || deleteTree(m)

{ff\Gamma ?T * fi\Gamma ?T}
Segment Logic allows us to establish such natural disjointness properties, since
it combines reasoning directly about the abstract tree structure with using the

16 Philippa Gardner and Mark Wheelhouse
separating conjunction *. Our goal is to extend the update language presented
here with parallel composition and critical regions, and adapt the Concurrent
Separation Logic reasoning to provide a formal, compositional specification of
a concurrent XML update language.

Acknowledgments: We thank Thomas Dinsdale-Young for many interesting
discussions regarding this work and Viktor Vafeiadis for the name Segment
Logic. Gardner acknowledges support of a Microsoft/RAEng Senior Research
Fellowship. Wheelhouse acknowledges support of an EPSRC DTA award.

References

1. J. Berdine, C. Calcagno, and P. W. O'Hearn. Smallfoot: Modular automatic assertion

checking with separation logic. FMCO, LNCS, 4111, 2005.
2. C. Calcagno, T. Dinsdale-Young, and P. Gardner. Adjunct elimination in context logic

for trees. APLAS, LNCS, 4807, 2007.
3. C. Calcagno, P. Gardner, and U. Zarfaty. Context logic and tree update. POPL, ACM,

40, 2005.
4. L. Cardelli and A. D. Gordon. Ambient logic. Mathematical Structures in Computer

Science, in press, 2006.
5. M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable

binding. Formal Aspects of Computing, 13, 2002.
6. P. Gardner, G. Smith, M. Wheelhouse, and U. Zarfaty. Local Hoare reasoning about

DOM. PODS, ACM, 27, 2008.
7. P. Gardner and M. Wheelhouse. Small specifications for tree update, extended version. http://www.doc.ic.ac.uk/,mjw03/PersonalWebpage/pdfs/moveFull.pdf, 2009.
8. P. Gardner and U. Zarfaty. Reasoning about high-level tree update and its low-level

implementation. Technical Report DTR09-9, Imperial College, 2009.
9. H. Hosoya and B. C. Pierce. Xduce: A statically typed XML processing language.

TOIT, ACM, 3, 2003.
10. S. Ishtiaq and P. W. O'Hearn. BI as an assertion language for mutable data structures.

POPL, ACM, 36, 2001.
11. R. Milner. Pi-nets: A graphical form of ss-calculus. ESOP, LNCS, 788, 1994.
12. R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes I & II. Information

and Computation, 100, 1992.
13. P. W. O'Hearn, J. Reynolds, and H. Yang. Local reasoning about programs that alter

data structures. CSL, LNCS, 15, 2001.
14. P. W. OHearn. Resources, concurrency and local reasoning. Theoretical Computer

Science, 375, 2007.
15. M. Raza and P. Gardner. Footprints in local reasoning. FoSSaCS, LNCS, 4962, 2008.
16. G. Smith. Providing a formal specification for DOM core level 1. PhD Thesis, to be

submitted December 2009.
17. V. Vafeiadis. Modular fine-grained concurrency verification. Technical Report

UCAM-CL-TR-726, Cambridge, 2008.
18. W3C. Dom: Document object model. W3C recommendation.

http://www.w3.org/DOM/, 2005.
19. H. Yang and P. W. O'Hearn. A semantic basis for local reasoning. FoSSaCS, LNCS,

2303, 2002.