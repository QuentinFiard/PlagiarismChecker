

Alpha-Structural Recursion and Induction
ANDREW M. PITTS
Cambridge University, Cambridge, UK

Abstract. The nominal approach to abstract syntax deals with the issues of bound names and
\Theta -equivalence by considering constructions and properties that are invariant with respect to per-muting names. The use of permutations gives rise to an attractively simple formalization of common,

but often technically incorrect uses of structural recursion and induction for abstract syntax modulo
\Theta -equivalence. At the heart of this approach is the notion of finitely supported mathematical objects.This article explains the idea in as concrete a way as possible and gives a new derivation within

higher-order classical logic of principles of \Theta -structural recursion and induction for \Theta -equivalenceclasses from the ordinary versions of these principles for abstract syntax trees.

Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions andTheory--Syntax; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages--Algebraic approaches to semantics; operational semantics; denotational semantics; F.4.1[Mathematical Logic and Formal Languages]: Mathematical Logic--Mechanical theorem proving

General Terms: Languages, Theory, Verification
Additional Key Words and Phrases: Abstract syntax, binders, induction, names, recursion

1. Introduction

"They [previous approaches to operational semantics] do not in generalhave any great claim to being syntax-directed in the sense of defining

the semantics of compound phrases in terms of the semantics of theircomponents."

GD Plotkin, A Structural Approach to Operational Semantics, p. 21(Aarhus 1981; reprinted as Plotkin [2004, p. 32]).

The above quotation and the title of the work from which it comes indicate theimportant role played by structural recursion and structural induction in programming language semantics. These are the forms of recursion and induction that fitthe commonly used "algebraic" treatment of syntax. In this approach one specifies
the syntax of a language at the level of abstract syntax trees (ASTs) by giving an

This research supported by UK EPSRC grants GR/R07615/1 and EP/D000459/1.
Author's address: University of Cambridge Computer Laboratory, William Gates Building, 15 JJThomson Avenue, Cambridge CB3 0FD UK.

Permission to make digital or hard copies of part or all of this work for personal or classroom use isgranted without fee provided that copies are not made or distributed for profit or direct commercial
advantage and that copies show this notice on the first page or initial screen of a display along with thefull citation. Copyrights for components of this work owned by others than ACM must be honored.
Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistributeto lists, or to use any component of this work in other works requires prior specific permission and/or
a fee. Permissions may be requested from Publications Dept., ACM, Inc., 1515 Broadway, New York,NY 10036 USA, fax: +1 (212) 869-0481, or permissions@acm.org.

C\Theta  2006 ACM 0004-5411/06/0500-0459 $5.00

Journal of the ACM, Vol. 53, No. 3, May 2006, pp. 459-506.

460 ANDREW M. PITTS
algebraic signature. This consists of a collection of sorts s (one for each syntacticcategory of the language), and a collection of constructors K (also called "operators" or "function symbols"). Each such K comes with an arity consisting of a finitelist (s

1, . . . , sn) of sorts and with a result-sort s. Then, the ASTs over the signaturecan be described by inductively generated terms t : if K has arity (s

1, . . . , sn) andresult sort s, and if t
i is a term of sort si for i = 1..n, then K(t1, . . . tn) is a termof sort s. One gets off the ground in this inductive definition with the n = 0 instance of the rule for forming terms, which covers the case of constants, C (and oneusually writes the term C() just as C). Recursive definitions and inductive proofs
about programs following the structure of their ASTs are both clearer and lessprone to error than ones using nonstructural methods. However, this treatment of
syntax does not take into account the fact that most languages that one deals with inprogramming semantics involve binding constructors. In the presence of binders,
many syntax-manipulating operations only make sense, or at least only have goodproperties, when we operate on syntax at a level of abstraction represented not by
ASTs themselves, but by \Theta -equivalence classes of ASTs.It is true that this level of abstraction, which identifies terms differing only in the
names of bound entities, can be reconciled with an algebraic treatment of syntax byusing indexes, as in de Bruijn [1972]. The well-known disadvantage of this device
is that it necessitates a calculus of operations on de Bruijn indexes that does nothave much to do with our intuitive view of the structure of syntax. As a result there
can be a big "coding gap" between statements of results involving binding syntaxwe would like to make and their de Bruijn versions; and (hence) it is easy to get
things wrong. For this reason, de Bruijn-style representations of syntax may bemore suitable for language implementations than for work on language semantics.

In any case, most of the work on semantics which is produced by humans ratherthan by computers sticks with ordinary ASTs involving explicit bound names and
uses an informal approach to \Theta -equivalence classes.1 This approach is signalledby, a form of words such as "we identify expressions up to

\Theta -equivalence" andmeans that: (a) occurrences of "t " now really mean its
\Theta -equivalence class "[t]\Theta ";and (b) if the representative t for the class [t]

\Theta  is later used in some context wherethe particular bound names of t clash in some way with those in the context, then

t will be changed to an \Theta -variant whose bound names are fresh (i.e., are ones notused in the current context). In other words, it is assumed that the "Barendregt
variable convention" [Barendregt 1984, Appendix C] is maintained dynamically.In the literature, the ability to change bound names "on the fly" is usually justified
by the assertion that final results of constructions involving ASTs are independentof choice of bound names. A fully formal treatment has to prove such independence
results and in this article we examine ways, arising from the results of Gabbay andPitts [2002] and Pitts [2003], to reduce the burden of such proofs.

However, proving that pre-existing functions respect \Theta -equivalence is only partof the story; in most cases a prior (or simultaneous) problem is to prove the existence of the required functions in the first place. To see why, consider the familiarexample of capture-avoiding substitution (x := t )t\Lambda  of a

\Lambda -term t for all free oc-currences of a variable x in a
\Lambda -term t\Lambda . To bring out the issues with binders more

1 This includes the metatheory of "higher-order abstract syntax" [Pfenning and Elliott 1988], where
the questions we are addressing are pushed up one meta-level to a single binding-form, \Lambda -abstraction.

Alpha-Structural Recursion and Induction 461
clearly, let us consider this operation not for the pure \Lambda -calculus, but for an appliedcalculus that also has expressions for local recursive function declarations. Thus,
the terms are either variables (x, f, y, . . . ), applications (t1 t2), function abstractions(

\Lambda x.t), or local recursive function declarations of the form letrec f x = t1 in t2. Theleftmost occurrence of the variable f in letrec f x = t

1 in t2 binds all free occur-rences of f in both t
1 and t2; whereas the leftmost occurrence of the variable x onlybinds free occurrences of x in t

1. A systematic way of specifying such patterns ofbinding and the associated notion of

\Theta -equivalence is given in Section 2.2; for themoment I assume the reader can supply a suitable definition of

\Theta -equivalence for
\Lambda -terms involving such letrec-expressions. How does one define capture-avoidingsubstitution for such terms up to

\Theta -equivalence? In the vernacular of programmingsemantics, one might specify (x := t)(-) by saying it has the following properties,

where fv(t) indicates the finite set of free variables of t .

(x := t)y = \Theta t if y = xy if y \Xi = x (1)
(x := t)(t1 t2) = (x := t )t1 (x := t)t2 (2)

y /\Pi  fv(t) \Sigma  -x"" \Upsilon  (x := t )\Lambda y. t1 = \Lambda y. (x := t)t1 (3)
y /\Pi  fv(t2) \Sigma  - f "" & f, y /\Pi  fv(t) \Sigma  -x"" \Upsilon 

(x := t )letrec f y = t1 in t2 = letrec f y = (x := t )t1 in (x := t)t2. (4)

The condition on Eq. (3) should be familiar enough: there is no need to say whathappens when y occurs free in t or when y = x, since we are working "up to

\Theta -equivalence" and can change
\Lambda y. t1 to an \Theta -variant satisfying these conditions. Thesame goes for the more complicated condition on Eq. (4): Given x and t , we can

change letrec f y = t1 in t2 up to \Theta -equivalence to ensure that f and y are distinctvariables not occurring free in t and not equal to x; less crucially, we can also
assume that y does not occur free in t2, because that term lies outside the bindingscope of y in the term letrec f y = t

1 in t2.To see what this specification of (x := t)(-) really amounts to, let us restore the

usually invisible notation [t]\Theta  for the \Theta -equivalence class of a term t. Writing \Xi for the set of terms and

\Xi /=\Theta  for its quotient by \Theta -equivalence =\Theta , then capture-avoiding substitution of an

\Theta -equivalence class e for a variable x is a function ^sx,e \Pi 
\Xi /=\Theta  \Phi  \Xi /=\Theta . Every such function corresponds to a function sx,e \Pi  \Xi  \Phi  \Xi /=\Theta respecting =

\Theta , that is, satisfying

t1 =\Theta  t2 \Upsilon  sx,e(t1) = sx,e(t2) (5)
(enabling us to define ^sx,e([t]\Theta ) as [sx,e(t)]\Theta ). The requirements (1)-(4) mean thatwe want s

x,e to satisfy:

sx,e(y) = \Theta e if y = x[y]

\Theta  if y \Xi = x (6)

sx,e(t1 t2) = [t\Lambda 1 t\Lambda 2]\Theta  where sx,e(ti ) = [t\Lambda i ]\Theta  for i = 1, 2

(7)

462 ANDREW M. PITTS

y /\Pi  fv(e) \Sigma  -x"" \Upsilon 

sx,e(\Lambda y.t1) = [\Lambda y.t \Lambda 1]\Theta  where sx,e(t1) = [t \Lambda 1]\Theta  (8)

y /\Pi  fv(t2) \Sigma  - f "" & f, y /\Pi  fv(e) \Sigma  -x"" \Upsilon 

sx,e(letrec f y = t1 in t2) = [letrec f y = t\Lambda 1 in t \Lambda 2]\Theta 
where sx,e(ti ) = [t\Lambda i ]\Theta  for i = 1, 2. (9)

The problem is not one of proving that a certain well-defined function sx,e respects
\Theta -equivalence, but rather of proving that a function exists satisfying (5)-(9). Notethat (6)-(9) do not constitute a definition of s

x,e(t) by recursion on the structure of theAST t: even if we patch up the "where" conditions in clauses (7)-(9) by using some

enumeration of ASTs to make the choices t \Lambda i definite functions of sx,e(ti ), the fact stillremains that clauses (8) and (9) and only specify what to do for certain pairs (y

, t1),rather than for all such pairs. Of course it is possible to complicate the specification

by saying what to do for \Lambda - and letrec-terms that do not meet the preconditions in (8)and (9), thereby arriving at a way of constructing s

x,e(t ) for any t (either by givingup structural properties and using a less natural recursion on the height of trees; or

by fixing an enumeration of variables and using structural recursion to define a moregeneral operation of simultaneous substitution [Stoughton 1988]). An alternative
approach, and one that works with the original simple specification, is to constructfunctions by giving rule-based inductive definitions of their graphs, with the rules
encoding the required properties of the function. One then has to prove (using rule-based induction) that the resulting relations are single-valued, total and respect =

\Theta .This is in principle a fully formal and widely applicable approach to constructing

functions like sx,e using tools that in any case are part and parcel of structuraloperational semantics; but one that is extremely tedious to carry out. It would be
highly preferable to establish a recursion principle that goes straight from definitionslike (1)-(4) to the existence of the function (x := t)(-) \Pi 

\Xi /=\Theta  \Phi  \Xi /=\Theta . Weprovide such a principle here for a general class of signatures in which binding

information can be declared. We call it \Theta -structural recursion and it comes with anassociated induction principle,

\Theta -structural induction.These recursion and induction principles for

\Theta -equivalence classes of ASTs aresimplifications and generalizations of the ones introduced by Gabbay and Pitts

[2002] as part of a new mathematical model of fresh names and name binding.That article expresses its results in terms of an axiomatic set theory, based on the
classical Fraenkel-Mostowski permutation model of set theory. In my experience,this formalism impedes the take up within computer science of the new ideas
contained in that article. There is an essentially equivalent, but more concretedescription of the model as standard sets equipped with some simple extra structure.
These so-called nominal sets are introduced by Pitts [2003], and I will use them hereto express

\Theta -structural recursion and induction within "ordinary mathematics", ormore precisely, within Church's higher-order classical logic [Church 1940].

1.1. HOW TO READ THIS ARTICLE. Having read the Introduction this far, impa-tient readers may wish to turn to Theorem 5.4 to see the statement of the

\Theta -structuralrecursion principle for
\Lambda -calculus with letrec-terms and how it is used to define(x := t)(-) \Pi 
\Xi /=\Theta  \Phi  \Xi /=\Theta  satisfying (1)-(4). To understand the statementof this theorem, they must then look up the definitions of "nominal set", "finite

support" and the freshness relation (-) # (-) in Section 3. This recursion principle

Alpha-Structural Recursion and Induction 463
and the corresponding induction principle are generalised to arbitrary signatureswith binding information in Section 5. The particular way of specifying binding
information that we use (via nominal signatures [Urban et al. 2004]) is explainedin Section 2. Section 4 gives a first, simple version of the

\Theta -structural recursionand induction principles that is derived from ordinary structural recursion/induction

for ASTs by, roughly speaking, taking into account an implicit parameterisationby name-permutations. The reduction of the practically more useful principles of
Section 5 to the simpler ones of Section 4 is quite involved and is relegated to theAppendices. Section 6 contains an extended example (on normalization by evaluation for the simply-typed \Lambda -calculus [Berger and Schwichtenberg 1991]) that notonly uses

\Theta -structural recursion and induction, but also shows off some of the powerof nominal sets and the notion of freshness of names that they support. The final

Section 7 assesses this article's "nominal" approach to abstract syntax in the contextof related work, both from a mathematical perspective and from the perspective of
automated theorem proving.

2. Nominal Syntax
The usual principles of structural recursion and induction are parameterised byan algebraic signature that specifies the allowed constructors for forming abstract

syntax trees (ASTs) of each sort. In order to state principles of recursion andinduction for

\Theta -equivalence classes of ASTs, we need to fix a notion of signaturethat also specifies the forms of binding that occur in the ASTs. As explained in the

Introduction, we stick with the usual "nominal" approach in which bound entitiesare explicitly named. Any generalisation of the notion of algebraic signature to
encompass constructors that bind names needs to specify how bound occurrencesof names in an AST are associated with a binding site further up the syntax tree.
There are a number of such mechanisms in the literature of varying degrees ofgenerality [Fiore et al. 1999; Griffin 1988; Honsell et al. 2001; Plotkin 1990; Urban
et al. 2004]. Here we will use the notion of nominal signature [Urban et al. 2004]. Ithas the advantage of dealing with binding and

\Theta -equivalence independently of anyconsiderations to do with variables, substitution and

\Pi -equivalence: bound names ina nominal signature may be of several different sorts and not just variables that can

be substituted for. In common with the other cited approaches, nominal signaturesonly allow for constructors that bind a fixed number of names (and without loss of
much generality, we can take that number to be one). There are certainly forms ofbinding occurring "in the wild" that do not fit comfortably into this framework (for
example, in the full version of F<: with records and pattern-matching used in Part2B of the "POPLmark challenge" [Aydemir et al. 2005]). I believe that the notion
of \Theta -structural recursion given here can be extended to cover more general forms ofstatically scoped binding, such as those used by Pottier [2005] in his C

\Theta ml library;but for simplicity's sake I will stick with constructors binding a fixed number of

names.

2.1. ATOMS. From a logical point of view (as opposed to a pragmatic onethat also encompasses issues of parsing and pretty-printing), the names we use for

making localised bindings in formal languages only need to be atomic, in the sensethat the structure of names (of the same kind) is immaterial compared with the
distinctions between names. Therefore, we will use the term atom for such names.

464 ANDREW M. PITTS
Throughout this article, we fix two sets: the set A of all atoms and the set AS ofall atom-sorts. We also fix a function sort \Pi  A \Phi  AS assigning sorts to atoms and
assume that the sets AS and Aa \Theta  -a \Pi  A -- sort(a) = a"" for each a \Pi  AS, are allcountably infinite.

2.2. NOMINAL SIGNATURES. A nominal signature \Sigma  consists of a subset of theatom-sorts,

\Sigma A \Psi  AS, a set \Sigma D of data-sorts and a set \Sigma C of constructors. Eachconstructor K \Pi 

\Sigma C comes with an arity \Upsilon  and a result sort s \Pi  \Sigma D, and we writeK :
\Upsilon  \Phi  s to indicate this information. The arities \Upsilon  of \Sigma  are given as follows:

Atom-sorts. Every atom-sort a \Pi  \Sigma A is an arity.
Data-sorts. Every data-sort s \Pi  \Sigma D is an arity.
Unit arity. 1 is an arity.
Pair arities. If \Upsilon 1 and \Upsilon 2 are arities, then \Upsilon 1 * \Upsilon 2 is an arity.
Atom-binding arities. If a \Pi  \Sigma A and \Upsilon  is an arity, then ffafi\Upsilon  is an arity.

The terms t over \Sigma  of each arity are defined as follows, where we write t : \Upsilon  toindicate that t has arity

\Upsilon  .2

Atoms. If a \Pi  Aa is an atom of sort a, then a : a.
Constructed terms. If K : \Upsilon  \Phi  s is in \Sigma C and t : \Upsilon  , then K t : s.
Unit. flffi : 1 is the unique term of unit arity.
Pairs. If t1 : \Upsilon 1 and t2 : \Upsilon n, then flt1, t2ffi : \Upsilon 1 * \Upsilon 2.
Atom-binding. If a \Pi  Aa and t : \Upsilon  , then ffafit : ffafi\Upsilon  .

We write Ar(\Sigma ) for the set of all arities over a nominal signature \Sigma , T(\Sigma ) forthe set of all terms over

\Sigma , and ar \Pi  T(\Sigma ) \Phi  Ar(\Sigma ) for the function assigning toeach term t the unique arity

\Upsilon  such that t : \Upsilon  holds. For each \Upsilon  \Pi  Ar(\Sigma ), we writeT(
\Sigma )\Upsilon  for the subset -t \Pi  T(\Sigma ) -- ar(t ) = \Upsilon  "" of terms of arity \Upsilon  .

Example 2.1 (\Lambda -calculus with letrec ). Here is a nominal signature for the un-typed

\Lambda -calculus [Barendregt 1984]. There is a single atom-sort v for variables, anda single data-sort t for

\Lambda -terms.

atom-sorts data-sorts constructorsv t V

: v \Phi  tA : t * t \Phi  t

L : ffvfit \Phi  t
To illustrate the intermixing of the arity-formers for pairing and atom-binding thatis allowed in a nominal signature, consider augmenting

\Lambda -calculus with the localrecursive function declarations, letrec f x = t

1 in t2, that were used in the discussionof capture-avoiding substitution in the Introduction. Recall that free occurrences of

x in t1 are bound in letrec f x = t1 in t2; and free occurrences of f in either of t1 ort

2 are bound in the term. To get the effect of this, we can add to the above nominalsignature a constructor

Letrec : ffvfi((ffvfit) * t) \Phi  t.

2 Compared with Urban et al. [2004, Definition 2.3] we only define ground terms, since we do not
need to consider variables ranging over terms here.

Alpha-Structural Recursion and Induction 465
So, for example, the expression letrec f x = f x in f (\Lambda y.y) corresponds to thenominal term

Letrecff f fiflffxfiAflV f, Vxffi, AflV f, LffyfiVyffiffi
of arity t over this signature (where f, x, y \Pi  Av).

Example 2.2 (\Phi -calculus). Here is a nominal signature for the version of theMilner-Parrow-Walker

\Phi  -calculus given by Sangiorgi and Walker [2001, Defini-tion 1.1.1]. There is an atom-sort chan for channel names and a data-sort proc for

process expressions; but there are also auxiliary data-sorts gsum, for processes thatare guarded sums, and pre, for prefixed processes.

atom-sorts data-sorts constructorschan proc Gsum

: gsum \Phi  procgsum Par : proc * proc \Phi  proc

pre Res : ffchanfiproc \Phi  procRep : proc \Phi  proc

Zero : 1 \Phi  gsumPre : pre \Phi  gsum

Plus : gsum * gsum \Phi  gsumOut : (chan * chan) * proc \Phi  pre

In : chan * ffchanfiproc \Phi  preTau : proc \Phi  pre
Match : (chan * chan) * pre \Phi  pre
For example, the \Phi -calculus process expression \Psi x((xu.0 + yv.0)--x(z).zw .0) cor-responds to the following nominal term of arity proc over this signature (where

x, u, y, v, z, w \Pi  Achan):

ResffxfiParflGsumPlusflPreOutflflx, uffi, GsumZeroflffiffi,PreOutflfly

, vffi, GsumZeroflffiffiffi,GsumPreInflx
, ffzfiGsumPreOutflflz, w ffi, GsumZeroflffiffiffiffi.

2.3. ORDINARY STRUCTURAL RECURSION AND INDUCTION. The terms over anominal signature

\Sigma  are just the abstract syntax trees determined by an ordinarysignature associated with

\Sigma  whose sorts are the arities of \Sigma , whose constructorsare those of
\Sigma , plus constructors for unit, pairs and atom-binding, and with atomsregarded as particular constants. Consequently we can use ordinary structural recursion to define functions on the set T(\Sigma ) of terms over \Sigma ; and we can use ordinarystructural induction to prove properties of those terms. The following two theorems
give versions of these principles that we use later. We regard their proofs as standardand omit them.3

THEOREM 2.3 (STRUCTURAL RECURSION FOR NOMINAL TERMS). Let \Sigma  be anominal signature. Suppose we are given sets S

\Upsilon  , for each \Upsilon  \Pi  Ar(\Sigma ), and

3 Each theorem can be used to prove the other; and either of them can be proved using induction for
the natural numbers once one has fixed upon a particular construction of abstract syntax trees.

466 ANDREW M. PITTS
elements

ga \Pi  Aa \Phi  Sa (a \Pi  \Sigma A)
gK \Pi  S\Upsilon  \Phi  Ss ((K : \Upsilon  \Phi  s) \Pi  \Sigma C)

g1 \Pi  S1
g\Upsilon 1*\Upsilon 2 \Pi  S\Upsilon 1 OE S\Upsilon 2 \Phi  S\Upsilon 1*\Upsilon 2 (\Upsilon 1, \Upsilon 2 \Pi  Ar(\Sigma ))
gffafi\Upsilon  \Pi  Aa OE S\Upsilon  \Phi  Sffafi\Upsilon  (a \Pi  \Sigma A, \Upsilon  \Pi  Ar(\Sigma ))

(We write X OE Y for the Cartesian product of two sets X and Y ; and write X \Phi  Yfor the set of functions from X to Y .) Then there is a unique family of functions
( ^g\Upsilon  \Pi  T(\Sigma )\Upsilon  \Phi  S\Upsilon  -- \Upsilon  \Pi  Ar(\Sigma )) satisfying the following properties

^g a = ga(a) (10)
^g(K t) = gK( ^g t) (11)

^gflffi = g1 (12)
^gflt1, t2ffi = g\Upsilon 1*\Upsilon 2fl ^g t1, ^g t2ffi (13)
^g ffafit = gffafi\Upsilon  (a, ^g t ), (14)

where we have abbreviated ^g\Upsilon  (t) to ^g t (since \Upsilon  = ar(t) is determined by t).

THEOREM 2.4 (STRUCTURAL INDUCTION FOR NOMINAL TERMS). Let \Sigma  be anominal signature and S \Psi  T(

\Sigma ) a set of terms over \Sigma . To prove that S is the wholeof T(
\Sigma ), it suffices to show

(ffla \Pi  \Sigma A, a \Pi  Aa) a \Pi  S (15)
(ffl(K : \Upsilon  \Phi  s) \Pi  \Sigma C, t : \Upsilon  ) t \Pi  S \Upsilon  K t \Pi  S (16)flffi \Pi 

S (17)
(ffl(\Upsilon i \Pi  Ar(\Sigma ), ti : \Upsilon i -- i = 1, 2)) t1 \Pi  S & t2 \Pi  S \Upsilon  flt1, t2ffi \Pi  S (18)
(ffla \Pi  \Sigma A, a \Pi  Aa, \Upsilon  \Pi  Ar(\Sigma ), t : \Upsilon  ) t \Pi  S \Upsilon  ffafit \Pi  S. (19)

2.4. \Theta -EQUIVALENCE AND \Theta -TERMS. So far, we have taken no account of thefact that atom-binding terms ffafit should be identified up to renaming the bound
atom a. Given a nominal signature \Sigma , the relation of \Theta -equivalence, t =\Theta  t\Lambda  : \Upsilon (where

\Upsilon  \Pi  Ar(\Sigma ) and t, t \Lambda  \Pi  T(\Sigma )\Upsilon  ) makes such identifications. It is inductivelydefined by the rules in Figure 1. They generalise to terms over a nominal signature

a version of the definition of \Theta -equivalence of \Lambda -terms [Gunter 1992, p. 36] that isconveniently syntax-directed compared with the classic version [Barendregt 1984,
Definition 2.1.11]. It is easy to see that =\Theta  is reflexive, symmetric and respects thevarious term-forming constructions for nominal syntax. Less straightforward is the
fact that =\Theta  is transitive. This can be proved in a number of ways. My favorite waymakes good use of the techniques we will be using later, based on the action of
atom-permutations on terms; see Pitts [2003, Example 1].

Definition 2.5. For each \Upsilon  \Pi  Ar(\Sigma ), we write T\Theta (\Sigma )\Upsilon  for the quotient of T(\Sigma )\Upsilon by the equivalence relation (-) =

\Theta  (-) : \Upsilon  . Thus, the elements of T\Theta (\Sigma )\Upsilon  are \Theta -equivalence classes of terms of arity

\Upsilon  ; we write [t ]\Theta  for the class of t and refer to[t]

\Theta  as an \Theta -term of arity \Upsilon  over the nominal signature \Sigma .

Alpha-Structural Recursion and Induction 467

FIG. 1. \Theta -Equivalence of nominal terms.
3. Finite Support
The crucial ingredient in the formulation of structural recursion and induction for
\Theta -terms over a nominal signature is the notion of finite4 support. It gives a well-behaved way, phrased in terms of atom-permutations, of expressing the fact that

atoms are fresh for mathematical objects. It turns out to agree with the obvious def-inition when the objects are finite data such as abstract syntax trees, but allows us to
deal with freshness for the not so obvious case of infinite sets and functions. For ex-ample, the identity function on A "mentions" every atom in its graph; nevertheless,
it has empty support and any atom is fresh for it.

3.1. NOMINAL SETS. Let Perm denote the set of all (finite, sort-respecting)atom-permutations; by definition, its elements are bijections

\Phi  : A i A such that-a \Pi  A --
\Phi  (a) \Xi = a"" is finite5 and sort(\Phi  (a)) = sort(a) for all a \Pi  A. The operationof composing bijections gives a binary operation

\Phi , \Phi \Lambda  \Pi  Perm j\Phi  \Phi  ` \Phi  \Lambda  \Pi  Perm

(\Phi  ` \Phi  \Lambda )(a) \Theta  \Phi (\Phi  \Lambda (a)) (a \Pi  A)
that makes Perm into a group; we write \Omega  for the identity atom-permutation and
\Phi  -1 for the inverse of \Phi  . Among the elements of Perm we single out transpositions(a a\Lambda ) given by a pair of atoms of the same sort: (a a\Lambda ) is the atom-permutation

mapping a to a\Lambda , mapping a\Lambda  to a and leaving all other atoms fixed. It is a basicfact of group theory that every

\Phi  \Pi  Perm is equal to a finite composition of suchtranspositions.

4 Both Gabbay [2006] and Cheney [2004] develop more general notions of "small" supports. As
Cheney's work shows, such a generalisation is necessary for some techniques of classical modeltheory to be applied; but finite supports suffice here.

5A very similar theory of nominal sets can be developed without this restriction to finite permutations;
but the restriction does ensure that Perm is itself a nominal set (see Example 3.3)--a fact that weexploit in the proof of the

\Theta -structural recursion theorem.

468 ANDREW M. PITTS

An action of Perm on a set X is a function Perm OE X \Phi  X , whose effect on(
\Phi , x) \Pi  Perm OE X we write as \Phi  u* x (with X understood), and which is requiredto have the properties:

\Omega  u* x = x and \Phi  u* (\Phi \Lambda  u* x) = (\Phi  ` \Phi  \Lambda ) u* x, for all x \Pi  X and
\Phi , \Phi  \Lambda  \Pi  Perm. Given such an action and an element x \Pi  X , we say that a set A \Psi  Aof atoms supports x if (a a\Lambda ) u* x = x holds for all atoms a and a\Lambda  (of the same sort)

that are not in A.

Definition 3.1. A nominal set is by definition a set X equipped with an actionof Perm such that every element x \Pi  X is supported by some finite set of atoms.

If X is a nominal set and A1 and A2 are both finite sets of atoms supportingx \Pi  X , then it is the case that A

1 ' A2 also supports x. To see this, suppose that aand a\Lambda  are atoms of the same sort not in A

1 ' A2; we have to show (a a\Lambda ) u* x = x.This is certainly the case if a = a\Lambda  (because (a a) =

\Omega ); and if a \Xi = a\Lambda , picking anyatom a\Lambda \Lambda  of the same sort as a and a\Lambda  not in the finite set A

1 \Sigma  A2 \Sigma  -a, a\Lambda "", then(a a\Lambda ) = (a a\Lambda \Lambda ) ` (a\Lambda  a\Lambda \Lambda ) ` (a a\Lambda \Lambda ) is a composition of transpositions each of which

fixes x (since for each of the three pairs of atoms, each element of the pair is eithernot in A

1, or not in A2), so itself fixes x, as required. It follows immediately fromthis intersection property of finite supports that in a nominal set X , each element

x \Pi  X possesses a smallest finite support, which we write as suppX (x), or justsupp(x) if X is clear from the context, and call the support of x in X .

Example 3.2
(1) Each set Aa of atoms of a particular sort a is a nominal set once we endow itwith the atom-permutation action given by

\Phi  u* a = \Phi (a); as one might expect,supp(a) = -a"". It is not hard to see that the disjoint union of nominal sets is

again a nominal set. So since the set of all atoms is the disjoint union of Aa asa ranges over atom-sorts, A is a nominal set with atom-permutation action and
support sets as for each individual Aa.
(2) Let \Sigma  be a nominal signature. Using Theorem 2.3, we can define an atom-permutation action on the sets T(

\Sigma )\Upsilon  of terms over \Sigma  of each arity \Upsilon  \Pi  Ar(\Sigma ):

\Phi  u* a \Theta  \Phi  (a)
\Phi  u* K t \Theta  K(\Phi  u* t )

\Phi  u* flffi \Theta  flffi
\Phi  u* flt1, t2ffi \Theta  fl\Phi  u* t1, \Phi  u* t2ffi
\Phi  u* ffafit \Theta  ff\Phi  u* afi(\Phi  u* t).
Using Theorem 2.4, one can prove that this has the properties required ofan atom-permutation action, that a

, a\Lambda  /\Pi  atm(t) \Upsilon  (a a\Lambda ) u* t = t, and thata \Pi  atm(t) & (a a\Lambda ) u* t = t \Upsilon  a = a\Lambda . From these facts, it follows that each

T(\Sigma )\Upsilon  is a nominal set, with supp(t) equal to the finite set atm(t ) of atomsoccurring in t.

(3) Turning next to \Theta -terms over \Sigma  (Section 2.4), first note that the action ofatom-permutations on terms preserves

\Theta -equivalence: this is a consequence ofa general property (Theorem 3.6) of rule-based inductive definitions that we

will establish at the end of Section 3.2. Therefore, we get a well-defined actionon

\Theta -terms by defining: \Phi  u* [t ]\Theta  = [\Phi  u* t ]\Theta . For this action, one finds that T\Theta (\Sigma )\Upsilon 

Alpha-Structural Recursion and Induction 469

is a nominal set with supp([t]\Theta ) equal to the finite set fa(t ) of free atoms of anyrepresentative t of the class [t]

\Theta , defined (using Theorem 2.3) by:

fa(a) \Theta  -a""

fa(K t ) \Theta  fa(t)

fa(flffi) \Theta  ^
fa(flt1, t2ffi) \Theta  fa(t1) \Sigma  fa(tn)
fa(ffafit ) \Theta  fa(t - -a"").
(4) Each set S becomes a nominal set, called the discrete nominal set on S, whenwe endow it with the trivial action of atom-permutations, given by

\Phi  u* s = sfor each
\Phi  \Pi  Perm and s \Pi  S; in this case the support of each element is empty.In particular, we will regard the one-element set 1 = -()"", the set of Booleans

B = -true, false"" and the set of natural numbers N = -0, 1, 2, . . . "" as nominalsets in this way.

3.2. PRODUCTS, FUNCTIONS AND POWERSETS. If X1 and X2 are nominal sets,then we get an action of atom-permutations on their Cartesian product X

1 OE X2by defining
\Phi  u* (x1, x2) to be (\Phi  u* x1, \Phi  u* x2), for each (x1, x2) \Pi  X1 OE X2. If Aisupports x

i \Pi  Xi for i = 1, 2, then it is not hard to see that A1 \Sigma  A2 supports(x
1, x2) \Pi  X1 OE X2. Thus, X1 OE X2 is also a nominal set. Note that

supp((x1, x2)) = supp(x1) \Sigma  supp(x2). (20)
since we have already observed that supp(x1) \Sigma  supp(x2) supports (x1, x2), so thatsupp((x

1, x2)) \Psi  supp(x1) \Sigma  supp(x2); and conversely, if A supports (x1, x2), thenit also supports each x

i , so that supp(xi ) \Psi  supp((x1, x2)).Turning next to functions, if X and Y are nominal sets, then we get an action of

atom-permutations on the set X \Phi  Y of all functions from X to Y by defining \Phi  u* fto be the function mapping each x \Pi  X to

\Phi  u* ( f (\Phi  -1 u* x)) \Pi  Y . If you have notseen this definition before, it may look more complicated than expected; however,

note that it is equivalent to the requirement that function application be respectedby atom-permutations:

\Phi  u* ( f (x)) = (\Phi  u* f )(\Phi  u* x). (21)
More precisely, the definition of the action on functions is forced by the requirementthat X \Phi  Y together with the usual application function be the exponential of

X and Y in the Cartesian closed category whose objects are sets equipped withan atom-permutation action and whose morphisms are functions preserving the
action. Unlike the situation for Cartesian product, not every element f \Pi  X \Phi  Yis necessarily finitely supported with respect to this action (see Example 3.4 below).
However, if f is supported by a finite set of atoms A, then \Phi  u* f is supported by-

\Phi (a) -- a \Pi  A"". (This follows as in the proof of property (25) below.) Therefore,the set

X \Phi fs Y \Theta  - f \Pi  X \Phi  Y -- (* finite A \Psi  A) A supports f ""
of finitely supported functions from X to Y is closed under the atom-permutationaction and is a nominal set.

Given a nominal set X , we can use the usual bijection between subsets of Xand functions in X \Phi  B (where B = -true

, false"") to transfer the action of

470 ANDREW M. PITTS
atom-permutations on X \Phi  B to one on subsets of X . From the definition ofthe action of atom-permutations on functions and using the fact that the action on
B is trivial (see Example 3.2(4)), one can calculate that this action sends \Phi  \Pi  Permand S \Psi  X to the subset

\Phi  u* S \Theta  -\Phi  u* x -- x \Pi  S"".
Note that if S is supported by a set of atoms A with respect to this action, then \Phi  u* Sis supported by -

\Phi  (a) -- a \Pi  A"". So the set

Pfs(X ) \Theta  -S \Psi  X -- (* finite A \Psi  A) A supports S""
of finitely supported subsets of the nominal set X is closed under the atom-permutation action on all subsets of X and hence is a nominal set.

Example 3.3 Recall that the elements of Perm are bijections from A to itselfthat respect sorts and leave fixed all but finitely many atoms. So each

\Phi  \Pi  Perm is inparticular a function A \Phi  A. Regarding A as a nominal set, as in Example 3.2(1),

the action of atom-permutations on \Phi  qua function turns out to be the operation ofconjugation:

\Phi  \Lambda  u* \Phi  = \Phi  \Lambda  ` \Phi  ` (\Phi \Lambda )-1. Hence, the action of atom-permutations onA \Phi  A restricts to an action on Perm. One can prove that the finite set -a \Pi  A --

\Phi  (a) \Xi = a"" supports \Phi  with respect to this action (and is in fact the smallest suchset); so Perm is a nominal set.

Example 3.4 Not every function between nominal sets is finitely supported.For example, since the set A of atoms is countable, there are surjective functions
from N to A; but it is not hard to see that any f \Pi  N \Phi fs A must have a finiteimage (which is in fact the support of f ). A more subtle example of a non-finitelysupported function is any choice function6 for the set A of atoms, that is, any functionchoose \Pi  (A \Phi 

fs B) \Phi  A (where B = -true, false"") satisfying f (a) = true \Upsilon f (choose( f )) = true, for all f \Pi  A \Phi 

fs B and a \Pi  A. To see this, we supposethat choose is supported by some finite set A \Psi  A and derive a contradiction. Let

f \Pi  A \Phi  B be the function mapping a \Pi  A to true if a /\Pi  A and to false ifa \Pi  A. It is not hard to see that A supports f ; in particular, f \Pi  A \Phi 

fs B andwe can apply choose to obtain an atom a
0 \Theta  choose( f ). Let a = sort(a0). SinceA
a is infinite and A \Sigma  -a0"" is finite, there is some atom a1 \Pi  Aa with a1 \Xi = a0and a

1 /\Pi  A. Since a1 /\Pi  A, f (a1) = true by definition of f ; and so, since chooseis a choice function, we also have f (choose( f )) = true. By definition of f and

a0, this means that a0 = choose( f ) /\Pi  A. Since a0, a1 /\Pi  A and A supports bothchoose and f , we have (a

0 a1) u* choose = choose and (a0 a1) u* f = f . Thus by(21), a
1 = (a0 a1) u* a0 = (a0 a1) u* choose( f ) = ((a0 a1) u* choose)((a0 a1) u* f ) =choose( f ) = a

0, contradicting the fact that we picked a1 to be different from a0and completing the proof.

For nominal sets X and Y , the operation of function application

appX,Y ( f, x) \Theta  f x

6 It was the lack of finite support for choice functions that motivated the original construction of the
permutation model of set theory by Fraenkel and Mostowski (see Jech [1977]).

Alpha-Structural Recursion and Induction 471
is an element of (X \Phi fs Y ) OE X \Phi fs Y ; indeed, if follows from (21) that appX,Y issupported by the empty set of atoms. Similarly, it is not hard to see that currying,

curX,Y,Z ( f ) \Theta  \Lambda x \Pi  X.\Lambda y \Pi  Y. f (x, y)
determines an element curX,Y,Z \Pi  ((X OE Y \Phi fs Y ) \Phi fs (X \Phi fs (Y \Phi fs Z ))) withempty support. The constantly true function and the equality function

trueX (x) \Theta  true
eqX (x, x\Lambda ) \Theta  if x = x\Lambda , then true else false
also determine elements trueX \Pi  (X \Phi fs B) and eqX \Pi  (X OE X \Phi fs B) with emptysupport. It is for these reasons that the following general principle holds good.

THEOREM 3.5 (FINITE SUPPORT PRINCIPLE). Any function or relation that isdefined from finitely supported functions and relations using higher-order, classical
logic without choice principles, is itself finitely supported.

Because of this, the collection of finitely supported functions and subsets ofnominal sets forms a very rich collection that is closed under the usual constructions

of informal, classical mathematics.7 If we remain within pure higher-order, classicallogic over ground types for numbers and Booleans, then we only get elements
with empty support. However, if we add a ground type for the set A of atoms,a constant for the function sort \Pi  A \Phi  AS (taking AS to be a copy of N) and
constants for each atom, then the terms and formulas of higher-order logic describefunctions and subsets that may have nonempty, finite support. Such a "higher-order
logic with atoms" has been developed by Gabbay [2002]. In this article, we stickwith ordinary higher-order, classical logic: By considering all functions and subsets
rather than just finitely supported ones, one sometimes gets more information abouta construction. A good example of this is provided by a cornerstone of programming
language semantics, namely rule-based inductive definitions. Given a nominal setX , let R be a finitely supported set of rules for defining a subset of X ; more precisely,
let R be an element of the nominal set Pfs(Pfs(X ) OE X ). As usual, a subset S \Psi  Xis closed under the rules in R if

(ffl(H, c) \Pi  R) H \Psi  S \Upsilon  c \Pi  S
and the smallest such subset, ind(R), is given by the intersection of all such closedsubsets. If we worked systematically in "FM-HOL" [Gabbay 2002], rather than

using arbitrary subsets of X , we would only consider finitely supported subsets thatare closed under the rules, and would replace ind(R) by \Lambda -S \Pi  P

fs(X ) -- (ffl(H, c) \Pi R) H \Psi  S \Upsilon  c \Pi  S"". However, these two subsets coincide, as the following

theorem shows.

THEOREM 3.6 (FINITELY SUPPORTED INDUCTIVE DEFINITIONS). Let X be anominal set. For any set of rules R \Pi  P

fs(Pfs(X ) OE X ), the subset ind(R) \Psi  Xinductively defined by R is a finitely supported subset of X ; indeed, supp(ind(R)) \Psi 

supp(R).

7 The only exception being that the finite support property is not conserved by all uses of choice: see
Example 3.4. The extent to which a useful theory of finite support can be developed in constructiverather than classical mathematics is a very interesting question that is not pursued here.

472 ANDREW M. PITTS

PROOF. Suppose a, a\Lambda  are atoms of the same sort that are not in the support ofR. We have to show that (a a\Lambda ) u* ind(R) = ind(R). It suffices to just show ind(R) \Psi 
(a a\Lambda ) u* ind(R). (For applying (a a\Lambda ) to both sides, then gives the reverse inclusion.)For this, it suffices to show that (a a\Lambda ) u* ind(R) is closed under the rules in R, since
ind(R) is the smallest such subset. But if (H, c) \Pi  R, then ((a a\Lambda ) u* H, (a a\Lambda ) u* c) isalso a rule in R, because (a a\Lambda ) u* (H

, c) \Pi  (a a\Lambda ) u* R = R since a, a\Lambda  /\Pi  supp(R).So if H \Psi  (a a\Lambda ) u* ind(R), then (a a\Lambda ) u* H \Psi  (a a\Lambda ) u* (a a\Lambda ) u* ind(R) = ind(R), so

(a a\Lambda ) u* c \Pi  ind(R) since ind(R) is closed under the rule ((a a\Lambda ) u* H, (a a\Lambda ) u* c); andhence c = (a a\Lambda ) u* (a a\Lambda ) u* c \Pi  (a a\Lambda ) u* ind(R).

In this article we will confine ourselves to finitely supported finitary rules, thatis, those R only containing (hypothesis, conclusion)-pairs (H

, c) for which H isa finite subset of X . Every finite subset of a nominal set is in particular a finitely

supported subset: clearly, -x1, . . . , xn"" is supported by supp(x1) \Sigma  u* u* u* \Sigma  supp(xn).Furthermore, the action of atom-permutations on subsets of X clearly sends finite
subsets to finite subsets. So the finite powerset Pfin(X ) is a nominal set when Xis. For finitary rules, we just have to check that R is a finitely supported subset of
the nominal set Pfin(X ) OE X to conclude from the above theorem that the subsetind(R) it inductively defines is again finitely supported. For example, it is not hard
to see that the rule set given schematically in Figure 1 is a subset of Pfin(T(\Sigma ) OET(

\Sigma )) OE (T(\Sigma ) OE T(\Sigma )) that is supported by the empty set of atoms. Therefore,by the theorem, the relation =

\Theta  of \Theta -equivalence is supported by the empty set.So =
\Theta  is preserved by all atom-transpositions and hence also by any \Phi  \Pi  Perm(since each

\Phi  is a composition of transpositions):

t =\Theta  t\Lambda  : \Upsilon  \Upsilon  \Phi  u* t =\Theta  \Phi  u* t\Lambda  : \Upsilon . (22)
We used this property in Example 3.2(3) when discussing the nominal set structureof T

\Theta (\Sigma ).

3.3. NOMINAL SUBSETS AND QUOTIENTS. If X is a nominal set and S \Pi  Pfs(X )is a finitely supported subset of it, then S is not necessarily itself a nominal set,

because for any x \Pi  S and \Phi  \Pi  Perm we have no guarantee that \Phi  u* x again lies inS. But if supp(S) = ^, then (a a\Lambda ) u* S = S for all atoms a

, a\Lambda  of the same sort; andsince each
\Phi  \Pi  Perm is the composition of transpositions, in this case, it followsthat
\Phi  u* S = S. From this, it is not hard to see that the condition supp(S) = ^ isequivalent to

(ffl\Phi  \Pi  Perm, x \Pi  X ) x \Pi  S \Upsilon  \Phi  u* x \Pi  S. (23)
So when (23) holds, the action of atom-permutations on elements of X restricts toan action on S; and furthermore, the support of each x \Pi  S is the same as its support

as an element of X . Therefore, S is a nominal set. We call such an S a nominalsubset of X . (The term, equivariant subset, is also commonly used for this.)

Another useful way of forming nominal sets is by taking quotients. If _ is anequivalence relation on a nominal set X , then so long as _ is a nominal subset
of X OE X , the usual set X/_ of equivalence classes inherits a well-defined atom-permutation action, given by

\Phi  u* [x] = [\Phi  u* x]. Furthermore, an equivalence classis supported by any set of atoms that supports a representative of the class. So

X/_ is a nominal set. The construction of the nominal set T\Theta (\Sigma )\Upsilon  of \Theta -terms (ofarity

\Upsilon  over a nominal signature \Sigma ) from the nominal set T(\Sigma )\Upsilon  is an example of

Alpha-Structural Recursion and Induction 473
this construction, since we saw in (22) that \Theta -equivalence is a nominal subset ofT(

\Sigma )\Upsilon  OE T(\Sigma )\Upsilon  .

3.4. FRESHNESS. Given an element of a nominal set, most of the time we areinterested not so much in its support as in the (infinite) set of atoms that are not in

its support. More generally, if x \Pi  X and y \Pi  Y are elements of nominal sets, wewrite x # y when supp

X (x) ' suppY (y) = ^ and say that x is fresh for y.
LEMMA 3.7. Let X , Y and Z be nominal sets. For any x \Pi  X , y \Pi  Y , f \Pi Y \Phi 

fs Z , \Phi  \Pi  Perm and atoms a, a\Lambda  \Pi  A of the same sort,

\Phi  u* ((a a\Lambda ) u* x) = (\Phi (a) \Phi (a\Lambda )) u* (\Phi  u* x) (24)

x # y \Upsilon  \Phi  u* x # \Phi  u* y. (25)
x # f & x # y \Upsilon  x # ( f y). (26)

PROOF. Equation (24) follows immediately from the fact that the atom-permutations

\Phi  ` (a a\Lambda ) and (\Phi  (a) \Phi  (a\Lambda )) ` \Phi  are always equal.Given a set of atoms A, recall from the previous section that we write

\Phi  u* Afor the set -
\Phi  (a) -- a \Pi  A"". Note that since each permutation is in particular abijection, it is the case that

\Phi  u* ( A ' A\Lambda ) = \Phi  u* A ' \Phi  u* A\Lambda . Therefore, to prove (25),it suffices to show that
\Phi  u* supp(x) = supp(\Phi  u* x). But if A supports x, then, for anyatoms a
, a\Lambda  /\Pi  \Phi  u* A (of the same sort), we have \Phi  -1(a), \Phi  -1(a\Lambda ) /\Pi  A and hence(
\Phi  -1(a) \Phi -1(a\Lambda )) u* x = x. Applying \Phi  u* (-) to both sides of this equation and using(24), we get (a a\Lambda ) u* (

\Phi  u* x) = \Phi  u* x. Thus, \Phi  u* A supports \Phi  u* x when A supports x.So

(ffl\Phi  \Pi  Perm)(fflx \Pi  X ) supp(\Phi  u* x) \Psi  \Phi  u* supp(x).
Hence, supp(x) = supp(\Phi  -1 u* \Phi  u* x) \Psi  \Phi  -1 u* supp(\Phi  u* x) and thus, we also have
\Phi  u* supp(x) \Psi  supp(\Phi  u* x). So we do indeed have \Phi  u* supp(x) = supp(\Phi  u* x) andhence also (25).

Finally, for property (26), note that for all atoms a, a\Lambda  of the same sort, if a, a\Lambda  /\Pi supp( f ) \Sigma  supp(y) then (a a\Lambda ) u* f = f and (a a\Lambda ) u* y = y; so by (21) (a a\Lambda ) u* f y =
((a a\Lambda ) u* f )((a a\Lambda ) u* y) = f y. Thus, supp( f ) \Sigma  supp(y) supports f y and hencesupp( f y) is contained in this finite set. Therefore, if supp(x) is disjoint from both
supp( f ) and supp(y), then it is also disjoint from supp( f y).

Recall that the set of atoms A is a nominal set as in Example 3.2(1). The follow-ing simple property of finitely supported sets of atoms is extremely useful when

dealing with properties of fresh atoms; it subsumes Gabbay and Pitts [2002, Propo-sition 4.10] and Pitts [2003, Proposition 4].

THEOREM 3.8 (SOME/ANY THEOREM). Let S \Pi  Pfs(A) be a set of atoms sup-ported by some finite set of atoms A. For each atom-sort a \Pi  AS, the following are
equivalent:

(ffla \Pi  Aa) a /\Pi  A \Upsilon  a \Pi  S (27)
(*a \Pi  Aa) a /\Pi  A & a \Pi  S. (28)

PROOF. Since Aa - A is infinite, it is in particular nonempty; thus, (27) implies(28). Conversely, suppose a \Pi  A

a - A satisfies a \Pi  S. Given any other a\Lambda  \Pi  Aa - A,we have to show a\Lambda  \Pi  S; but (a a\Lambda ) u* S = S (since a

, a\Lambda  /\Pi  A * supp(S)) and hencea\Lambda  = (a a\Lambda ) u* a \Pi  (a a\Lambda ) u* S = S.

474 ANDREW M. PITTS

Example 3.9 Recall from Example 3.2(ii) that, in the nominal set T(\Sigma )\Upsilon  ofterms of arity

\Upsilon  over a nominal signature \Sigma , the support of a term t is just thefinite set atm(t) of atoms that occur in t. Furthermore, if a\Lambda 

/\Pi  atm(t), then the termst -a\Lambda 
/a"" (replace a by a\Lambda  throughout t) and (a a\Lambda ) u* t (swap a and a\Lambda  throughout t) arethe same. Therefore, the crucial rule (=

\Theta  -5) in the definition of \Theta -equivalence ofnominal terms can be rewritten as:

a \Pi  \Sigma A a, a\Lambda , a\Lambda \Lambda  \Pi  Aa a\Lambda \Lambda  # (a, t, a\Lambda , t \Lambda ) (a\Lambda \Lambda  a) u* t =\Theta  (a\Lambda \Lambda  a\Lambda ) u* t\Lambda  : \Upsilon ff

afit =\Theta  ffa\Lambda fit\Lambda  : ffafi\Upsilon 

In particular, we have

ffafit =\Theta  ffa\Lambda fit\Lambda  : ffafi\Upsilon  ,

(*a\Lambda \Lambda  \Pi  Aa) a\Lambda \Lambda  # (a, t, a\Lambda , t\Lambda ) & (a a\Lambda \Lambda ) u* t =\Theta  (a\Lambda  a\Lambda \Lambda ) u* t\Lambda  : \Upsilon . (29)

Applying Theorem 3.8 to the set of atoms S = -a\Lambda \Lambda  \Pi  Aa -- (a a\Lambda \Lambda ) u* t =\Theta  (a\Lambda  a\Lambda \Lambda ) u* t\Lambda  :
\Upsilon  "", which (by Lemma 3.7) is supported by A = supp(a, t, a\Lambda , t \Lambda ), we get from (29)a useful property of

\Theta -equivalence of atom-binding terms:

ffafit =\Theta  ffa\Lambda fit\Lambda  : ffafi\Upsilon  ,

(ffla\Lambda \Lambda  \Pi  Aa) a\Lambda \Lambda  # (a, t, a\Lambda , t\Lambda ) \Upsilon  (a a\Lambda \Lambda ) u* t =\Theta  (a\Lambda  a\Lambda \Lambda ) u* t\Lambda  : \Upsilon . (30)

The next result provides a very general criterion for when a construction that"picks a fresh atom" is independent of which fresh atom is chosen.

THEOREM 3.10 (FRESHNESS THEOREM). Given an atom-sort a \Pi  AS and anominal set X , if a finitely supported function h \Pi  A

a \Phi fs X satisfies

(*a \Pi  Aa) a # h & a # h(a), (31)
then there is a unique element fresh(h) \Pi  X satisfying

(ffla \Pi  Aa) a # h \Upsilon  h(a) = fresh(h). (32)
Furthermore, supp(fresh(h)) \Psi  supp(h).

PROOF. Given (31) we have to prove that h is constant on the nonempty setA
a - supp(h). First, note that, by Theorem 3.8 (with S \Theta  -a \Pi  Aa -- a # h(a)"" andA \Theta  supp(h) * supp(S)), if (31) holds, then

(ffla \Pi  Aa) a # h \Upsilon  a # h(a). (33)
Suppose a, a\Lambda  \Pi  Aa - supp(h). To see that h(a) = h(a\Lambda ), without loss of generalitywe may assume a \Xi = a\Lambda . By (26), a # h(a\Lambda ) (since a # h and a # a\Lambda ); and a\Lambda  # h(a\Lambda )

holds by (33). Hence,

h(a\Lambda ) = (a a\Lambda ) u* h(a\Lambda ) since (a, a\Lambda ) # h(a\Lambda )=

((a a\Lambda ) u* h)((a a\Lambda ) u* a\Lambda ) by (21)=

h((a a\Lambda ) u* a\Lambda ) since (a, a\Lambda ) # h=
h(a).

So there is a unique element fresh(h) \Pi  X satisfying (32). To see that it is supportedby supp(h), if a

, a\Lambda  are atoms (of the same sort) satisfying (a, a\Lambda ) # h, choosing any

Alpha-Structural Recursion and Induction 475
a\Lambda \Lambda  in the infinite set Aa - supp(h, a, a\Lambda ), we have (a a\Lambda ) u* fresh(h) = (a a\Lambda ) u* h(a\Lambda \Lambda ) =((a a\Lambda ) u* h)((a a\Lambda ) u* a\Lambda \Lambda ) = h(a\Lambda \Lambda ) = fresh(h). Thus, supp(h) supports fresh(h).

4. Recursion and Induction Principles for \Theta -Terms
Recall from Definition 2.5 that T\Theta (\Sigma )\Upsilon  denotes the set of \Theta -terms of arity \Upsilon  overa nominal signature

\Sigma ; by definition these are \Theta -equivalence classes [t]\Theta  of termst :
\Upsilon  . Elementary properties of the relation =\Theta  of \Theta -equivalence yield the followingstructural properties of

\Theta -terms; at the same time, we introduce some concrete syn-tax for
\Theta -terms mirroring the informal notation for \Theta -equivalence classes mentionedin the Introduction.

Atoms. If a \Pi  \Sigma A and e \Pi  T\Theta (\Sigma )a, then there is a unique a \Pi  Aa such thate = [a]

\Theta . In this case, we write e just as a.Constructed

\Theta -terms. If s \Pi  \Sigma D and e \Pi  T\Theta (\Sigma )s, then there are unique (K : \Upsilon  \Phi s) \Pi 

\Sigma C and e\Lambda  \Pi  T\Theta (\Sigma )\Upsilon  such that there exists t\Lambda  with e\Lambda  = [t \Lambda ]\Theta  and e = [K t\Lambda ]\Theta .In this case, we write e as K e\Lambda .

Unit. T\Theta (\Sigma )1 contains a unique equivalence class, [flffi]\Theta , which we write as ().Pairs. If

\Upsilon 1, \Upsilon 2 \Pi  Ar(\Sigma ) and e \Pi  T\Theta (\Sigma )\Upsilon 1*\Upsilon 2 , then there are unique ei \Pi  T\Theta (\Sigma )\Upsilon ifor i = 1
, 2 such that there exist ti with ei = [ti ]\Theta  (i = 1, 2) and e = [flt1, t2ffi]\Theta . Inthis case, we write e as (e

1, e2).Atom-binding. If a \Pi 
\Sigma A, \Upsilon  \Pi  Ar(\Sigma ) and e \Pi  T\Theta (\Sigma )ffafi\Upsilon  , then for each a \Pi  Aawith a # e (i.e., with a not a free atom of e-cf. Example 3.2(iii)), there is a unique

e\Lambda  \Pi  T\Theta (\Sigma )\Upsilon  such that there exists t\Lambda  with e\Lambda  = [t \Lambda ]\Theta  and e = [ffafit\Lambda ]\Theta . In thiscase, we write e as a

. e\Lambda .

Using this notation, we now give a first version of structural recursion for \Theta -termsover a nominal signature. Compared with Theorem 2.3, the principle uses nominal

sets rather than ordinary sets, and requires a common finite support for the collectionof functions in its hypothesis. Furthermore, the function supplied for each atombinding arity must satisfy a freshness condition for binders (FCB) saying, roughly,that for some sufficiently fresh choice of the atom being bound, the result of the
function can never contain that atom in its support. These conditions ensure thatthere is a unique (finitely supported) arity-indexed family of functions that is well
defined on \Theta -equivalence classes and satisfies the required recursion equations--forall sufficiently fresh bound atoms, in the case of the recursion equation for binders.

THEOREM 4.1 (FIRST \Theta -STRUCTURAL RECURSION THEOREM). Let \Sigma  be anominal signature. Suppose we are given an arity-indexed family of nominal sets
(X\Upsilon  -- \Upsilon  \Pi  Ar(\Sigma )) and elements

fa \Pi  Aa \Phi fs Xa (a \Pi  \Sigma A)
fK \Pi  X\Upsilon  \Phi fs Xs ((K : \Upsilon  \Phi fs s) \Pi  \Sigma C)

f1 \Pi  X1
f\Upsilon 1*\Upsilon 2 \Pi  X\Upsilon 1 OE X\Upsilon 2 \Phi fs X\Upsilon 1*\Upsilon 2 (\Upsilon 1, \Upsilon 2 \Pi  Ar(\Sigma ))
fffafi\Upsilon  \Pi  Aa OE X\Upsilon  \Phi fs Xffafi\Upsilon  (a \Pi  \Sigma A, \Upsilon  \Pi  Ar(\Sigma ))

all of which are supported by a finite set of atoms A and satisfy the freshnesscondition for binders (FCB): for each atom-binding arity ffafi

\Upsilon  \Pi  Ar(\Sigma ), the

476 ANDREW M. PITTS
function fffafi\Upsilon  satisfies

(*a\Lambda  \Pi  Aa) a\Lambda  /\Pi  A & (fflx \Pi  X\Upsilon  ) a\Lambda  # fffafi\Upsilon  (a\Lambda , x). (FCB)

Then there is a unique family of finitely supported functions ( ^f \Upsilon  \Pi  T\Theta (\Sigma )\Upsilon  \Phi fsX

\Upsilon  -- \Upsilon  \Pi  Ar(\Sigma )) with supp( ^f \Upsilon  ) \Psi  A and satisfying the following properties forall a

, e, e1, . . . , en of appropriate arity:

^f a = fa(a) (34)
^f (K e) = fK( ^f e) (35)

^f () = f1 (36)
^f (e1, e2) = f\Upsilon 1*\Upsilon 2( ^f e1, ^f e2) (37)

a /\Pi  A \Upsilon  ^f (a. e) = fffafi\Upsilon  (a, ^f e) (38)

where we have abbreviated ^f \Upsilon  (e) to ^f e and used the notation for \Theta -terms intro-duced above.

PROOF. We can reduce the proof of the theorem to an application of Theo-rem 2.3, taking advantage of the fact that we are working (informally) in higherorder logic.8 From the Ar(\Sigma )-indexed family of nominal sets X\Upsilon  we define another such family: S\Upsilon  \Theta  Perm \Phi fs X\Upsilon  (regarding Perm as a nominal set as inExample 3.3 and using the \Phi 

fs construct from Section 3.2). Now define elementsg
a, gK, g1, g\Upsilon 1*\Upsilon 2 and gffafi\Upsilon  as in the statement of Theorem 2.3, as follows.

ga a \Theta  \Lambda \Phi  \Pi  Perm. fa(\Phi  (a))

gK s \Theta  \Lambda \Phi  \Pi  Perm. fK(s(\Phi ))

g1 \Theta  \Lambda \Phi  \Pi  Perm. f1
g\Upsilon 1*\Upsilon 2(s1, s2) \Theta  \Lambda \Phi  \Pi  Perm. f\Upsilon 1*\Upsilon 2 (s1(\Phi  ), s2(\Phi ))

gffafi\Upsilon  (a, s) \Theta  \Lambda \Phi  \Pi  Perm. fresh(\Lambda a\Lambda  \Pi  Aa. fffafi\Upsilon  (a\Lambda , s(\Phi  ` (a a\Lambda )))).

The crucial clause in this definition is the last one, where we are using the fresh functional from Theorem 3.10 applied to the function h \Theta  \Lambda a\Lambda  \Pi  Aa. fffafi\Upsilon  (a\Lambda , s(\Phi  `(a a\Lambda ))). For this to make sense, it has to be the case that h is finitely supported and satisfies condition (31) of that lemma, let us see why this is so. Sincesupp( f

ffafi\Upsilon  ) \Psi  A by assumption, it follows that h is supported by the finiteset A \Sigma  supp(s

, \Phi , a). To see that (31) holds of h, let a\Lambda  be the atom whoseexistence is asserted by (FCB); thus, a\Lambda 

/\Pi  A and a\Lambda  # fffafi\Upsilon  (a\Lambda , x) for anyx \Pi  X

\Upsilon  . For any other a\Lambda \Lambda  \Pi  Aa - A, we have (a\Lambda  a\Lambda \Lambda ) u* fffafi\Upsilon  = fffafi\Upsilon (since a\Lambda 

, a\Lambda \Lambda  /\Pi  supp( fffafi\Upsilon  )); hence, applying (a\Lambda  a\Lambda \Lambda ) to a\Lambda  # fffafi\Upsilon  (a\Lambda , x), fromLemma 3.7, we get a\Lambda \Lambda  # f

ffafi\Upsilon  (a\Lambda \Lambda , (a\Lambda  a\Lambda \Lambda ) u* x) for any x \Pi  X\Upsilon  . Choosing a\Lambda \Lambda  tobe in the infinite set A
a - ( A \Sigma  supp(s, \Phi , a)) and x = (a\Lambda  a\Lambda \Lambda ) u* s(\Phi  ` (a a\Lambda \Lambda )),we conclude that a\Lambda \Lambda  # h and a\Lambda \Lambda  # fff

afi\Upsilon  (a\Lambda \Lambda , s(\Phi  ` (a a\Lambda \Lambda ))) = h(a\Lambda \Lambda ), as requiredfor (31).

8 In other words, the theorem is reducible to primitive recursion at higher types.

Alpha-Structural Recursion and Induction 477

Applying Theorem 2.3 with this data, we get a family of functions

^g\Upsilon  \Pi  T(\Sigma )\Upsilon  \Phi  (Perm \Phi fs X\Upsilon  )
satisfying the recursion equations (10)-(14) of that theorem. Next one proves thatthese functions respect

\Theta -equivalence:

t1 =\Theta  t2 : \Upsilon  \Upsilon  ^g\Upsilon  t1 = ^g\Upsilon  t2. (39)
This is done by induction over the derivation of t1 =\Theta  t2 : \Upsilon  from the rules inFigure 1; the induction step for rule (=

\Theta  -5) uses the following property of ^g,which follows by induction on the structure of t, that is, using Theorem 2.4:

(ffl\Upsilon  \Pi  Ar(\Sigma ), t : \Upsilon  )(ffl\Phi , \Phi  \Lambda  \Pi  Perm) ^g\Upsilon  t (\Phi  ` \Phi  \Lambda ) = ^g\Upsilon  (\Phi  \Lambda  u* t ) \Phi . (40)
In view of (39), the functions ^g\Upsilon  induce functions ^f \Upsilon  \Pi  T\Theta (\Sigma )\Upsilon  \Phi  X\Upsilon  given by^

f \Upsilon  [t]\Theta  \Theta  ^g\Upsilon  t \Omega  for any t : \Upsilon  (recalling that \Omega  stands for the identity permutation).
One proves that these functions ^f \Upsilon  are all supported by A by first proving thatthe functions ^g

\Upsilon  are so supported; the latter follows from the uniqueness part ofTheorem 2.3: if a

, a\Lambda  are atoms of the same sort not in A, then one can show that(a a\Lambda ) u* ^g

\Upsilon  satisfies the same recursion equations as ^g\Upsilon  and hence is equal to thatfunction. The fact that the ^f

\Upsilon  satisfy the required recursion equations (34)-(38)follows from the recursion equations (10)-(14) satisfied by the ^g

\Upsilon  . That concludesthe existence part of the proof of Theorem 4.1.

For the uniqueness part, suppose functions f \Lambda \Upsilon  \Pi  T\Theta (\Sigma )\Upsilon  \Phi fs X\Upsilon  are all
supported by A and satisfy the recursion equations (34)-(38) for ^f \Upsilon  . Define

g\Lambda \Upsilon  \Pi  T(\Sigma )\Upsilon  \Phi  S\Upsilon  by g\Lambda \Upsilon  t \Phi  \Theta  f \Lambda \Upsilon  [\Phi  u* t]\Theta  (\Upsilon  \Pi  Ar(\Sigma ), t : \Upsilon , \Phi  \Pi  Perm). One canshow that the g\Lambda 

\Upsilon  satisfy the same recursion equations (10)-(14) from Theorem 2.3as the functions ^g

\Upsilon  ; so by the uniqueness part of that theorem, g\Lambda \Upsilon  = ^g\Upsilon  . Therefore,

for all t : \Upsilon  , f \Lambda \Upsilon  [t]\Theta  = f \Lambda \Upsilon  [\Omega  u* t]\Theta  \Theta  g\Lambda \Upsilon  t \Omega  = ^g\Upsilon  t \Omega  \Theta  ^f \Upsilon  [t]\Theta ; hence, f \Lambda \Upsilon  = ^f \Upsilon  .

Example 4.2 (Length of an \Theta -Term ). Gordon and Melham [1996, Section 3.3]give the usual recursion scheme for defining the length of a

\Lambda -term, remark that itis not a direct instance of the scheme developed in that article (their Axiom 4) and

embark on a detour via simultaneous substitutions to define the length function. Thisdifficulty is analyzed by Norrish [2004, Sec. 3] on the way to his improved version
of Gordon and Melham's recursion scheme (discussed further in Example 5.6 andSection 7). Pleasingly, the usual recursive definition of the length of a

\Lambda -term, ormore generally of an
\Theta -term over any nominal signature, is a very simple applicationof the First
\Theta -Structural Recursion Theorem.9 Thus, in Theorem 4.1, we take X\Upsilon 

9 The same goes for Norrish's stripc function, used to illustrate the limitations of Gordon and
Melham's [1996] workaround for the length function [Norrish 2004, p. 247].

478 ANDREW M. PITTS
to be the discrete nominal set N of natural numbers and

fa \Theta  \Lambda a \Pi  Aa. 1
fK \Theta  \Lambda k \Pi  N. k + 1

f1 \Theta  0
f\Upsilon 1*\Upsilon 2 \Theta  \Lambda (k1, k2) \Pi  N OE N. k1 + k2
fffafi\Upsilon  \Theta  \Lambda (a, k) \Pi  Aa OE N. k + 1.

These functions are all supported by A = ^ and (FCB) holds trivially, because
a # k holds for any a \Pi  A and k \Pi  N. So the theorem gives us functions ^f \Upsilon  \Pi 
T\Theta (\Sigma )\Upsilon  \Phi fs N. Writing length e for ^f \Upsilon  e, we have the expected properties of alength function on

\Theta -terms:

length a = 1
length(K e) = length e + 1

length() = 0
length(e1, e2) = length e1 + length e2

length(a. e) = length e + 1.

Note that the last clause holds for all a, because in (38) the condition "a /\Pi  A" isvacuously true (since A = ^).

Remark 4.3 In Theorem 4.1, we gave (FCB) as an existential statement. It isin fact equivalent to the universal statement

(ffla\Lambda  \Pi  Aa) a\Lambda  /\Pi  A \Upsilon  (fflx \Pi  X\Upsilon  ) a\Lambda  # fffafi\Upsilon  (a\Lambda , x).
This follows from the "some/any" Theorem 3.8 by taking S to be -a\Lambda  \Pi  Aa -- (fflx \Pi X

\Upsilon  ) a\Lambda  # fffafi\Upsilon  (a\Lambda , x)"" and checking that A supports S.

Remark 4.4 (Primitive Recursion). Theorem 4.1 gives a simple "iterative"form of structural recursion for

\Theta -terms, rather than a more complicated "prim-itive recursive" form with recursion equations

^f a = fa(a)
^f (K e) = fK(e, ^f e)

^f () = f1
^f (e1, e2) = f\Upsilon 1*\Upsilon 2(e1, e2, ^f e1, ^f e2)

a /\Pi  A \Upsilon  ^f (a. e) = fffafi\Upsilon  (a, e, ^f e).

In fact, this more general form can be deduced from the simple one given in thetheorem by adapting to our nominal setting a similar result for ordinary structural

Alpha-Structural Recursion and Induction 479
recursion: Defining X \Lambda \Upsilon  \Theta  T\Theta (\Sigma )\Upsilon  OE X\Upsilon  and functions

f \Lambda a(a) \Theta  (a, fa(a))
f \Lambda K(e, x) \Theta  (K e, fK(e, x))

f \Lambda 1 \Theta  ((), f1)
f \Lambda \Upsilon 1*\Upsilon 2 ((e1, x1), (e2, x2)) \Theta  ((e1, e2), f\Upsilon 1*\Upsilon 2 (e1, e2, x1, x2))

f \Lambda ffafi\Upsilon  (a, e, x) \Theta  (a. e, fffafi\Upsilon  (a, e, x)),

we first apply Theorem 4.1 to get functions ^f \Lambda \Upsilon  \Pi  T\Theta (\Sigma )\Upsilon  \Phi fs T\Theta (\Sigma )\Upsilon  OE X\Upsilon  . Theuniqueness part of the theorem allows us to deduce that the first components of these
functions are all identity functions; it follows from this that the second component
of ^f \Lambda \Upsilon  is a function ^f \Upsilon  \Pi  T\Theta (\Sigma )\Upsilon  \Phi fs X\Upsilon  satisfying the above scheme of primitiverecursion (and is the unique such).

The next theorem gives a version of structural induction for \Theta -terms. Just asTheorem 4.1 was derived from ordinary structural recursion (Theorem 2.3), we
prove this theorem as a corollary of ordinary structural induction (Theorem 2.4).

THEOREM 4.5 (FIRST \Theta -STRUCTURAL INDUCTION THEOREM). Let \Sigma  be anominal signature. Suppose we are given a finitely supported set S \Pi  P

fs(T\Theta (\Sigma )) of
\Theta -terms over \Sigma . To prove that S is the whole of T\Theta (\Sigma ), it suffices to show

(ffla \Pi  \Sigma A, a \Pi  Aa) a \Pi  S (41)
(ffl(K : \Upsilon  \Phi  s) \Pi  \Sigma C, e \Pi  T\Theta (\Sigma )\Upsilon  ) e \Pi  S \Upsilon  K e \Pi  S (42)
() \Pi  S (43)
(ffl(\Upsilon i \Pi  Ar(\Sigma ), ei \Pi  T\Theta (\Sigma )\Upsilon i -- i = 1, 2)) e1 \Pi  S & e2 \Pi  S \Upsilon  (e1, e2) \Pi  S (44)
(ffla \Pi  \Sigma A, \Upsilon  \Pi  Ar(\Sigma ))(*a \Pi  Aa) a # S & (ffle \Pi  T\Theta (\Sigma )\Upsilon  ) e \Pi  S \Upsilon  a. e \Pi  S.(45)

PROOF. Let S be the set of nominal terms over \Sigma  whose \Theta -equivalence classeslie in S no matter how we permute the atoms occurring in the term:

S \Theta  -t \Pi  T(\Sigma ) -- (ffl\Phi  \Pi  Perm) [\Phi  u* t]\Theta  \Pi  S"".
Clearly, S = T\Theta (\Sigma ) if S = T(\Sigma ); and to prove the latter, it suffices to check
that S satisfies conditions (15)-(19) of Theorem 2.4. The first four of these followimmediately from (41)-(44) respectively. So it just remains to show that (45) implies

that S satisfies condition (19). First note that by Theorem 3.8 applied to the set ofatoms -a \Pi  A

a -- (ffle \Pi  T\Theta (\Sigma )\Upsilon  ) e \Pi  S \Upsilon  a. e \Pi  S"", which is supported bysupp(S), (45) is equivalent to

(ffla \Pi  \Sigma A, \Upsilon  \Pi  Ar(\Sigma ))(ffla \Pi  Aa) a # S \Upsilon 

(ffle \Pi  T\Theta (\Sigma )\Upsilon  ) e \Pi  S \Upsilon  a. e \Pi  S. (46)

Given a \Pi  Aa and t \Pi  S, we have to prove that ffafit \Pi  S, that is, that[

\Phi  u* ffafit]\Theta  \Pi  S for any \Phi  \Pi  Perm. Choosing any atom a\Lambda  in the infinite set

480 ANDREW M. PITTS
Aa - supp(S, \Phi , a, t), we have

\Phi  u* ffafit = ff\Phi  (a)fi(\Phi  u* t)=

\Theta  ffa\Lambda fi((\Phi  u* t )-a\Lambda /\Phi  (a)"") by definition of =\Theta  (Section 2.4)= ff

a\Lambda fi((\Phi (a) a\Lambda ) u* (\Phi  u* t)) since a\Lambda  /\Pi  atm(\Phi  u* t)= ff

a\Lambda fi(\Phi  \Lambda  u* t) where \Phi  \Lambda  \Theta  (\Phi  (a) a\Lambda ) ` \Phi .
So [\Phi  u* ffafit]\Theta  = a\Lambda . [\Phi \Lambda  u* t]\Theta  \Pi  S by (46), since a\Lambda  # S (by choice of a\Lambda ) and
[\Phi  \Lambda  u* t]\Theta  \Pi  S, because t \Pi  S. So it is indeed the case that ffafit \Pi  S when a \Pi  Aaand t \Pi  S.

5. Second \Theta -Structural Recursion & Induction Theorems
Theorem 4.1 is an "arity-directed" recursion principle for \Theta -terms: one has to spec-ify nominal sets X

\Upsilon  for each arity \Upsilon  , and give functions f( ) for atom-sorts, unit, pairand atom-binding arities in addition to ones for constructors. Although this gives

flexibility over how to treat atom, unit, pair and atom-binding \Theta -terms when givingan

\Theta -structurally recursive definition of some functions, this flexibility is often moreof a hindrance than a help. In most cases, one is primarily interested in defining

functions only on \Theta -terms whose arities are data-sorts s \Pi  \Sigma D, with \Theta -terms of otherkinds of arity (atom-sorts, unit, pair and atom-binding arities) playing an auxiliary
role. For example, when \Sigma  is the nominal signature for \Lambda -terms with local recur-sive function declarations (Example 2.1), to define the capture-avoiding substitution
function ^sx,e \Pi  T\Theta (\Sigma )t \Phi fs T\Theta (\Sigma )t discussed in the Introduction, we should onlyhave to specify finitely supported functions corresponding to the right-hand sides
of the defining Eqs. (6)-(9), that is, one function for each of the signature's fourconstructors V, A, L and Letrec. But as it stands, to define ^s

x,e using Theorem 4.1 wehave to work out suitable choices for X
\Upsilon  and for the functions fv, f1, f\Upsilon 1*\Upsilon 2, fffvfi\Upsilon for any
\Upsilon , \Upsilon 1, \Upsilon 2 \Pi  Ar(\Sigma ).So we will develop a second, "sort-directed" version of

\Theta -structural recursion inwhich one only has to give X

\Upsilon  when \Upsilon  = s is a data-sort, and only has to give thefunctions f
( ) for constructors. Here is the statement of the new form of the recursionprinciple; the notations used in it are defined in Figure 2 and discussed below.

THEOREM 5.1 (SECOND \Theta -STRUCTURAL RECURSION THEOREM). Let \Sigma  be anominal signature. Suppose we are given a family of nominal sets X = (X

s -- s \Pi 
\Sigma D) indexed by the data-sorts of \Sigma , a finite set A of atoms, and functions

fK \Pi  X (\Upsilon ) \Phi fs X (s) ((K : \Upsilon  \Phi  s) \Pi  \Sigma C)
all of which are supported by A and satisfy

(* _a \Pi  A\Upsilon  ) _a # A & (ffl _x \Pi  X --\Upsilon --) _a ff\Upsilon  _x \Upsilon  _a # fK( _a, _x)\Upsilon  . (FCBK)

Then there is a unique family of finitely supported functions ( ^f s \Pi  T\Theta (\Sigma )s \Phi fsX

s -- s \Pi  \Sigma D) with supp( ^f s) \Psi  A and satisfying

(ffl _a \Pi  A\Upsilon  ) _a # A \Upsilon  (ffl_e \Pi  T\Theta (\Sigma )--\Upsilon --) _a ff\Upsilon  _e \Upsilon  ^f s(K _a. _e) = fK( _a, ^f --\Upsilon -- _e)\Upsilon (47)

for each (K : \Upsilon  \Phi  s) \Pi  \Sigma C.

Alpha-Structural Recursion and Induction 481

FIG. 2. Definitions used in Theorem 5.1.
In this theorem, we start with a family of nominal sets X = (Xs -- s \Pi  \Sigma D)indexed by the data-sorts of the signature

\Sigma  and with a family of finitely supportedfunctions ( f

K -- K \Pi  \Sigma C) indexed by the constructors of \Sigma . The domain X (\Upsilon ) of fK isobtained from the arity

\Upsilon  of K by interpreting each atom-sort as the correspondingnominal set of atoms (Example 3.2(i)), each data-sort as given by X , the unit arity as

the one-element discrete nominal set (Example 3.2(iv)), pair arities using productsof nominal sets (Section 3.2), and atom-binding arities just using product with
nominal sets of atoms. The aim is to use this data to specify some functions ^f smapping

\Theta -terms e : s to elements ^f s e \Pi  Xs by giving recursion equations as in(47), with one (conditional) equation for each way of forming

\Theta -terms of data-sort,that is, for each constructor K :
\Upsilon  \Phi  s in \Sigma . The conditional equation for K
specifies the effect of ^f s not for arbitrary \Theta -terms constructed with K, but ratherjust for those of the form K _a

. _e where _a # A and _a ff\Upsilon  _e hold. Here _a \Pi  A\Upsilon  isa nested tuple of distinct atoms matching the binding occurrences of atom-sorts

in the arity \Upsilon  ; _e \Pi  T\Theta (\Sigma )--\Upsilon -- is a nested tuple of \Theta -terms matching the nonbindingoccurrences of atom-sorts and the occurrences of data-sorts in

\Upsilon  ; and the operation_a
, _e j\Phi  _a. _e assembles these two nested tuples into an \Theta -term of arity \Upsilon  , to which

482 ANDREW M. PITTS

FIG. 3. Definitions used in Theorem 5.2.
K can be applied to get a constructed \Theta -term K _a. _e : s. The equation in (47) isrestricted by two conditions:

--the first, _a # A, just requires that the atoms in _a do not occur in the commonfinite support of the functions f

K;
--the second, _a ff\Upsilon  _e, ensures that in addition to the atoms in _a being mutually dis-tinct (by virtue of the definition of A

\Upsilon  ), they avoid the support of the constituents

of _e in an appropriate way (the precise definition of "appropriate" being givenin Figure 2).

The theorem guarantees the unique existence of such functions on \Theta -terms providedthe functions f

K satisfy the freshness condition on binders given by (FCBK). Thisasserts the existence of a nested tuple _a of distinct atoms that can appear in binding

positions in elements of X (\Upsilon ) (i.e., _a \Pi  A\Upsilon  ) such that:
--the atoms are distinct from A, that is, _a # A (they are also mutually distinct bydefinition of A

\Upsilon  );

--whenever _x is a nested tuple of atoms and X -elements that can appear in non-binding positions in elements of X (

\Upsilon ) (i.e., _x \Pi  X --\Upsilon --) for which _a is suitably

fresh, that is, satisfying _a ff\Upsilon  _x,10 then assembling _a and _x into an element( _a

, _x)\Upsilon  \Pi  X (\Upsilon ), fK maps this element to one in X (s) = Xs whose support doesnot contain any of the atoms in _a (i.e., _a # f

K( _a, _x)\Upsilon  ).

The easiest way I know of proving Theorem 5.1 is to derive it from the following"sort-directed" version of

\Theta -structural induction, which uses notations that aredefined in Figures 2 and 3, and which are discussed below.

THEOREM 5.2 (SECOND \Theta -STRUCTURAL INDUCTION THEOREM). Let \Sigma  be anominal signature. Suppose we are given a family of finitely supported subsets
(Ss \Pi  Pfs(T\Theta (\Sigma )s) -- s \Pi  \Sigma D) indexed by the data-sorts of \Sigma  and all supported by afinite set of atoms A. Then, to prove that S

s is the whole of T\Theta (\Sigma )s for all s \Pi  \Sigma D,it suffices to show for each constructor (K :

\Upsilon  \Phi  s) \Pi  \Sigma C that

(* _a \Pi  A\Upsilon  ) _a # A & (ffl_e \Pi  T\Theta (\Sigma )--\Upsilon --) _a ff\Upsilon  _e & _e \Pi  S--\Upsilon -- \Upsilon  K _a. _e \Pi  Ss. (IHK)

In this theorem, we start with a family of subsets Ss \Psi  T\Theta (\Sigma )s of \Theta -terms whosearities are data-sorts and that are all supported by some finite set of atoms A. We

wish to prove that every t : s is in Ss (for all s \Pi  \Sigma D). The theorem guarantees thisprovided each constructor (K :

\Upsilon  \Phi  s) \Pi  \Sigma C satisfies the induction hypothesisgiven by (IH

K). This asserts the existence of a nested tuple _a of distinct atoms that

10 This relation ff\Upsilon  , defined in Figure 2, is a subtlety of the freshness condition on binders that is not
apparent in the simpler First \Theta -Structural Recursion Theorem.

Alpha-Structural Recursion and Induction 483
can appear in binding positions in \Theta -terms of arity \Upsilon  (i.e., _a \Pi  A\Upsilon  ) such that:
--the atoms are distinct from A, that is, _a # A (they are also mutually distinct bydefinition of A

\Upsilon  );

--whenever _e is a nested tuple of \Theta -terms that can appear in nonbinding positionsin an

\Theta -term of arity \Upsilon  (i.e., _e \Pi  T\Theta (\Sigma )--\Upsilon --) for which _a is suitably fresh, thatis, satisfying _a

ff\Upsilon  _e, then assembling _a and _e into the \Theta -term _a. _e : \Upsilon  , theconstructed
\Theta -term K _a. _e must lie in the subset Ss.

The proof of Theorem 5.2 is given in Appendix A and the proof of Theorem 5.1in Appendix B. In Sections 5.1 and 5.2, we explore what these principles look like

for particular nominal signatures, using the examples from Section 2.2.

Remark 5.3 (Atom-Abstraction and the Initial Algebra Property ). For eachatom-sort a \Pi  AS and each nominal set X , let [A

a] X denote the set of equivalenceclasses of pairs (a
, x) \Pi  Aa OE X for the equivalence relation (a, x) _ (a\Lambda , x\Lambda ) givenby

(*a\Lambda \Lambda  \Pi  Aa) a\Lambda \Lambda  # (a, x, a\Lambda , x\Lambda ) & (a a\Lambda \Lambda ) u* x = (a\Lambda  a\Lambda \Lambda ) u* x\Lambda . (48)
The relation _ is evidently reflexive and symmetric; to see that it is also transitive,one first applies Theorem 3.8 with S = -a\Lambda \Lambda  \Pi  A

a -- (a a\Lambda \Lambda ) u* x = (a\Lambda  a\Lambda \Lambda ) u* x\Lambda "" andA = supp(a
, x, a\Lambda , x\Lambda ) to show that (a, x) _ (a\Lambda , x\Lambda ) holds if and only if

(ffla\Lambda \Lambda  \Pi  Aa) a\Lambda \Lambda  # (a, x, a, x\Lambda ) \Upsilon  (a a\Lambda \Lambda ) u* x = (a\Lambda  a\Lambda \Lambda ) u* x\Lambda . (49)
We write [a]x for the _-equivalence class of the pair (a, x) and call it an atom-abstraction. It follows from Lemma 3.7 that _ is a nominal subset of A

a OE X . Sothe quotient [A
a] X is a nominal set as in Section 3.3. One can calculate that thesupport of each element [a]x of [A

a] X is supp(x) - -a"".Using these atom-abstraction nominal sets, it is possible to give an initial algebra

characterisation of (T\Theta (\Sigma )s -- s \Pi  \Sigma D) that is equivalent to Theorem 5.1. Considerthe category whose objects are families of nominal sets X = (X

s -- s \Pi  \Sigma D) indexedby the data-sorts of
\Sigma , and whose morphisms f : X \Phi  X \Lambda  are indexed familiesf = ( f

s \Pi  Xs \Phi fs X \Lambda s -- s \Pi  \Sigma D) of functions with empty support (i.e., functionsthat respect the action of all atom-permutations). The constructors of

\Sigma  determinea functor F

\Sigma  from this category to itself, defined in Figure 4. An F\Sigma -algebra issimply an object I equipped with a morphism i : F

\Sigma  I \Phi  I . Such an algebra isinitial if for any other such algebra f : F
\Sigma  X \Phi  X , there is a unique morphism^f : I \Phi  X so that

(50)
commutes, that is, satisfying

(ffls \Pi  \Sigma D)(ffl(K : \Upsilon  \Phi  s) \Pi  \Sigma C)\Xi fflx \Pi  I [\Upsilon ]\Pi  ^f s(is(K, x)) = fs\Xi K, ^f [\Upsilon ] x\Pi .
Standard category-theoretic results give that i is an isomorphism and that the initialalgebra (I

, i ) is unique up to isomorphism. Theorem 5.1 can be used to prove that(T

\Theta (\Sigma )s -- s \Pi  \Sigma D) is the (object part of) an initial F\Sigma -algebra. Conversely, one

484 ANDREW M. PITTS

FIG. 4. Functor F\Sigma  associated with a nominal signature \Sigma .
can give a direct inductive construction of an initial F\Sigma -algebra and use the initialalgebra property (50) to deduce Theorem 5.1: see Gabbay and Pitts [2002, Sect. 6].

5.1. EXAMPLE: \Lambda -CALCULUS (WITH letrec). Let \Sigma  be the nominal signaturefrom Example 2.1. Thus, T(

\Sigma )t is the set \Xi  of abstract syntax trees for \Lambda -calculuswith letrec; and T

\Theta (\Sigma )t is the quotient \Xi /=\Theta  of that set by the usual notion of \Theta -equivalence--in other words T

\Theta (\Sigma )t is what is normally meant by the set of all (openor closed) untyped
\Lambda -terms with local recursive function declarations. Suppose weare given a nominal set X and functions

fV \Pi  Av \Phi fs X (51)
fA \Pi  X OE X \Phi fs X (52)

fL \Pi  Av OE X \Phi fs X (53)
fLetrec \Pi  Av OE ((Av OE X ) OE X ) \Phi fs X (54)

all supported by a finite set of atoms A. Applying the definitions in Figure 2, onefinds that the conditions (FCB

K) for K = V, A are equivalent to true, that (FCBL)is equivalent to

(*a \Pi  Av) a /\Pi  A & (fflx \Pi  X ) a # fL(a, x) (55)
and that (FCBLetrec) is equivalent to

(*a, a\Lambda  \Pi  Av) a \Xi = a\Lambda  & a, a\Lambda  /\Pi  A & (fflx, x\Lambda  \Pi  X ) a\Lambda  # x \Upsilon 

(a, a\Lambda ) # fLetrec(a, ((a\Lambda , x\Lambda ), x)). (56)

So for this nominal signature, Theorem 5.1 gives us the following recursion prin-ciple. We state it using the usual concrete syntax for

\Lambda -calculus and using the fact(noted in Example 3.2(iii)) that the support of a term e \Pi 

\Xi /=\Theta  is its finite set fv(e)of free variable

THEOREM 5.4. Let \Xi /=\Theta  be the nominal set of \Theta -equivalence classes of
\Lambda -terms with local recursive function declarations:

e ::= x -- e e -- \Lambda x.e -- letrec x x = e in e

Alpha-Structural Recursion and Induction 485
where the variables x are drawn from the nominal set Av of atoms of some fixedsort v. Given any nominal set X and functions as in (51)-(54) all supported by
some finite set of atoms A and with fL and fLetrec satisfying (55) and (56), then thereis a unique function ^f \Pi 

(\Xi /=\Theta  \Phi fs X ) supported by A and satisfying

^f (x) = fV(x) (57)
^f (e1 e2) = fA( ^f e1, ^f e2) (58)

x /\Pi  A \Upsilon  ^f (\Lambda x.e) = fL(x, ^f e) (59)
x, y /\Pi  A & x /\Pi  fv(e2) \Sigma  -y"" \Upsilon 

^f (letrec y x = e1 in e2) = fLetrec(y, ((x, ^f e1), ^f e2)). (60)

Turning to the induction principle for this signature, if S \Psi  \Xi /=\Theta  is a set ofterms supported by a finite set of atoms A, then (IH

V), (IHA), (IHL) and (IHLetrec)are equivalent to

(fflx \Pi  Av) x \Pi  S (61)
(ffle1, e2 \Pi  S) e1 e2 \Pi  S (62)
(*x \Pi  Av) x /\Pi  A & (ffle \Pi  S) \Lambda x. e \Pi  S (63)
(*x, y \Pi  Av) x \Xi = y & x, y /\Pi  A &

(ffle1, e2 \Pi  S) x /\Pi  fv(e2) \Upsilon  letrec y x = e1 in e2 \Pi  S (64)

respectively. So for this signature Theorem 5.2 says that S contains all terms if itsatisfies (61)-(64).

Example 5.5 (Capture-Avoiding Substitution ). The example mentioned in theIntroduction of capture-avoiding substitution of

\Lambda -terms, ^sx,e \Pi  \Xi /=\Theta  \Phi  \Xi /=\Theta ,is obtained from the above theorem by taking X to be the nominal set

\Xi /=\Theta . Given

x \Pi  Av and e \Pi  X , then ^sx,e is given by ^f where

fV(y) \Theta  \Theta e if y = xy if y \Xi = x
fA(e1, e2) \Theta  e1 e2

fL(y, e1) \Theta  \Lambda y. e1
fLetrec(z, ((y, e1), e2)) \Theta  letrec z y = e1 in e2

A \Theta  fv(e) \Sigma  -x"".
Condition (55) is satisfied because, as noted in Example 3.2(iii), for each e1 \Pi  X =
\Xi /=\Theta , supp(e1) is the finite set fv(e1) of free variables of e1; in particular, we havey # f

L(y, e1) = \Lambda y. e1 simply because y /\Pi  fv(\Lambda y. e1) = fv(e1) - -y"". Similarly,condition (56) is satisfied because

fv(letrec z y = e1 in e2) = (fv(e1) - -y, z"") \Sigma  (fv(e2) - -z"")
so that (y, z) # fLetrec(z, ((y, e1), e2)) = letrec z y = e1 in e2 provided y /\Pi  fv(e2).Note that f

A, fL and fLetrec are all supported by the empty set of atoms, whereas fVis supported by fv(e) \Sigma  -x""; so this is what we take for the common support A. Thus,

486 ANDREW M. PITTS
the conditions on the recursion equations in (59) and (60) correspond precisely tothe conditions in (8) and (9).

Example 5.6 (Recursion with Varying Parameters). Norrish [2004, p. 245]considers a variant of capture-avoiding substitution whose definition involves recursion with varying parameters; it motivates the parametrized recursion principlethat he presents in that article. The

\Theta -structural recursion principles we have givenhere do not involve extra parameters, let alone varying ones; nevertheless it is possible to derive parameterized versions from them. In the case of ordinary structuralrecursion, one can derive a parameterized version from an unparameterized one
by currying parameters and defining maps into function sets using Theorem 2.3.In the presence of binders, one has to do something slightly more complicated,
involving the Freshness Theorem 3.10, to derive a parameterized (FCB) from theunparameterized version of the condition.

Let us see how this works for Norrish's example, using the nominal signature forthe pure

\Lambda -calculus obtained from Example 2.1 by deleting the Letrec constructor.Fixing on a pair of atoms x

1, x2 \Pi  Av, we seek a function s \Pi  (\Xi /=\Theta ) \Phi fs(
\Xi /=\Theta ) \Phi fs (\Xi /=\Theta ) satisfying for all y, e, e1, e2:

s(y)(e) = \Theta e if y = x1y if y \Xi = x

1 (65)

s(e1 e2)(e) = (s(e1)(e)) (s(e2)(e)) (66)
y /\Pi  fv(e) \Sigma  -x1, x2"" \Upsilon  s(\Lambda y. e1)(e) = \Lambda y. s(e1)(x2 e) (67)

Thus, the same parameter e appears in each clause defining s(e1)(e) by recursion onthe structure of e

1 except for clause (67), where the application term x2 e appearsinstead. Such a function s can be obtained from Theorem 5.4 (restricted to pure

\Lambda -terms) as s = ^f if we take X to be the nominal set (\Xi /=\Theta ) \Phi fs (\Xi /=\Theta ) and usethe functions

fV \Theta  \Lambda y \Pi  Av.\Lambda e \Pi  (\Xi /=\Theta ). if y = x1, then e else y
fA \Theta  \Lambda (fi1, fi2) \Pi  X OE X. \Lambda e \Pi  (\Xi /=\Theta ). (fi1 e) (fi2 e)

fL \Theta  \Lambda (y, fi1) \Pi  Av OE X.\Lambda e \Pi  (\Xi /=\Theta ). fresh(h(y, fi1, e))

where the last clause uses Theorem 3.10 applied to the finitely supported functionh(y

, fi1, e) \Pi  Av \Phi fs (\Xi /=\Theta ) that maps each y\Lambda  \Pi  Av to

h(y, fi1, e)(y\Lambda ) \Theta  \Lambda y\Lambda . ((y y\Lambda ) u* fi1)(x2 e).
This function is easily seen to satisfy the property (31) needed to apply the theorem. All the above functions are supported by A \Theta  -x1, x2"". Properties (57) and
(58) of ^f give (65) and (66) respectively. When y \Xi = x1, x2, property (59) gives
us ^f (\Lambda y. e1) = fL(y, ^f e1) = fresh(h(y, ^f e1, e)). So if y # (x1, x2, e), picking
any y\Lambda  # (x1, x2, e, e1, h), then by Theorem 3.10 we have fresh(h(y, ^f e1, e)) =

h(y, ^f e1, e)(y\Lambda ) \Theta  \Lambda y\Lambda . ((y y\Lambda ) u* ( ^f e1))(x2 e) = \Lambda y\Lambda . (y y\Lambda ) u* ( ^f e1 (x2 e)). Hence by
definition of =\Theta , ^f (\Lambda y. e1) = \Lambda y. ^f e1 (x2 e), as required for (67).

5.2. EXAMPLE: \Phi  -CALCULUS. Let \Sigma  be the nominal signature from Exam-ple 2.2. Suppose we are given nominal sets X

proc, Xgsum, Xpre and functions

Alpha-Structural Recursion and Induction 487

fGsum \Pi  Xgsum \Phi fs Xprocf

Par \Pi  Xproc OE Xproc \Phi fs Xprocf
Res \Pi  Achan OE Xproc \Phi fs Xprocf
Rep \Pi  Xproc \Phi fs Xproc

fZero \Pi  1 \Phi fs Xgsumf

Pre \Pi  Xpre \Phi fs Xgsumf
Plus \Pi  Xgsum OE Xgsum \Phi fs Xgsum

fOut \Pi  (Achan OE Achan) OE Xproc \Phi fs Xpref

In \Pi  Achan OE (Achan OE Xproc) \Phi fs Xpref
Tau \Pi  1 \Phi fs Xpref
Match \Pi  (Achan OE Achan) OE Xpre \Phi fs Xpre

all supported by a finite set of atoms A. The conditions (FCBRes) and (FCBIn) areequivalent to

(*a \Pi  Achan) a /\Pi  A & (fflx \Pi  Xproc) a # fRes(a, x) (68)
(*a \Pi  Achan) a /\Pi  A &

(ffla\Lambda  \Pi  Achan)(fflx \Pi  Xproc) a \Xi = a\Lambda  \Upsilon  a # fIn(a\Lambda , (a, x)) (69)

respectively; and conditions (FCBK) for K \Xi = Res, In are all equivalent to true. Soif f

Res and fIn satisfy (68) and (69), then by Theorem 5.1, there are unique finitelysupported functions ^f

s \Pi  T\Theta (\Sigma )s \Phi fs Xs (for s = proc, gsum, pre) all supportedby A and satisfying for all e

, e1, e2, a1, a2, a, a\Lambda  of suitable arity

^f (K e) = fK( ^f e) (K = Gsum, Rep, Pre) (70)
^f (K(e1, e2)) = fK( ^f e1, ^f e2) (K = Par, Plus) (71)
^f (K()) = fK() (K = Zero, Tau) (72)
^f (K((a1, a2), e)) = fK((a1, a2), ^f e) (K = Out, Match) (73)

a /\Pi  A \Upsilon  ^f (Res a. e) = fRes(a, ^f e) (74)
a /\Pi  A & a \Xi = a\Lambda  \Upsilon  ^f (In(a\Lambda , a. e)) = fIn(a\Lambda , (a, ^f e)) (75)

where we have abbreviated ^f s(e) to ^f e.We leave the reader to work out what induction principle Theorem 5.2 gives for

this signature.

6. Extended Example: Normalization by Evaluation
One of the most important aspects of nominal sets is that they provide, viathe notion of finite support, a notion of freshness of names with respect

to mathematical structures. This notion generalizes the usual "not a free vari-able of" relation from finite syntactical structures to infinite objects (sets, functions, . . . ) where there is no obvious notion of free name. The theory comes intoits own in situations where syntax and semantics have to be considered together
and yet one still needs a workable notion of fresh name. We give an examplein this section by treating normalization by evaluation (NBE) for simply typed
\Lambda -calculus [Berger and Schwichtenberg 1991; Berger et al. 2003]. This produces

488 ANDREW M. PITTS
so-called "\Pi fl-long" normal forms for typed \Lambda -terms by first taking their denota-tional semantics in the standard, extensional functions model of the calculus over
a ground type of syntax trees and then composing with a reification function thatturns elements of the denotational model back into syntax (in normal form). When
reifying an extensional function into a \Lambda -abstraction one wants to choose a freshname v for the

\Lambda -bound variable; but as the survey by Dybjer and Filinski [2002,p. 157] eloquently puts it when discussing an informal version of the reification

function

"The problem is the "v fresh" condition; what exactly does it mean?Unlike such conditions as "x does not occur free in E", it is not even
locally checkable whether a variable is fresh; freshness is a global prop-erty, defined with respect to a term that may not even be fully constructed
yet."

As a result, treatments of NBE in the literature adopt some device for makingthe current finite context of used names explicit and threading it through all the
mathematical definitions involved in the denotational and reification functions usedfor NBE: see Berger et al. [2003, sect. 2.5], Dybjer and Filinski [2002, sect. 3.3] and
Fiore [2002], for example. This tends to obscure the simple, but informal idea behindreification. Dybjer and Filinski [2002] go on to mention after the above quote that
"freshness" can be characterised rigorously in the framework of Gabbay and Pitts[2002]. The details are presented here for the first time, using nominal sets rather
than the FM-set theory of loc. cit. The point is not just that this setting provides arigorous explanation of "freshness" (since the formal approaches mentioned above
also do that), but that it allows us to retain the essential simplicity of an informalaccount such as in Dybjer and Filinski [2002, sect. 3.2].

6.1. TYPED \Lambda -TERMS AND THEIR \Pi fl-LONG NORMAL FORMS. We assume thereader is familiar with simply typed

\Lambda -calculus; if not, see Barendregt [1992] forexample. Rather than give a signature for raw

\Lambda -terms and then cut down to the well-typed ones using typing contexts, we make do with a simpler, but less extensible

treatment using explicitly typed variables.11 Let

Ty \Theta  -ffi ::= \Omega  -- ffi .\Phi  ffi "" (76)
be the set of simple type symbols over a single ground type \Omega . We assume givenan injective function

ffi \Pi  Ty j\Phi  vffi \Pi  AS that codes the simple type symbols asatom-sorts. We use atoms of sort v

ffi to stand for variables of type ffi in the simplytyped
\Lambda -calculus. Note that when ffi and ffi \Lambda  are different simple type symbols, vffi andv

ffi\Lambda  are different atom-sorts; so recalling the assumptions we made in Section 2.1,the sets of atoms A

vffi and Avffi\Lambda  are disjoint.

11 Such an approach is fine for simply typed terms, but becomes unworkable for calculi with type
variables or dependent types.

Alpha-Structural Recursion and Induction 489

Consider the nominal signature \Sigma STL with

atom-sorts data-sorts constructorsv

ffi tffi Vrffi : vffi \Phi  tffiAp

ffi,ffi\Lambda  : tffi

.\Phi ffi\Lambda  * tffi \Phi  tffi\Lambda 

Lmffi,ffi\Lambda  : ffvffi fitffi\Lambda  \Phi  tffi .\Phi ffi\Lambda 

as ffi and ffi \Lambda  range over Ty. Thus the (nominal) set

\Xi (ffi ) \Theta  T\Theta (\Sigma STL)tffi (77)
of \Theta -terms of arity tffi over \Sigma STL is precisely the usual set of \Theta -equivalence classesof abstract syntax trees for

\Lambda -terms of simple type ffi \Pi  Ty, using variables that areexplicitly tagged with types.

Next we give a nominal signature for \Pi fl-long normal forms. In the system weare considering, the general form of a type is

ffi1 .\Phi  (ffi2 .\Phi  u* u* u* (ffik .\Phi  \Omega ) u* u* u* ) forsome k >= 0; using conventional notation for typed

\Lambda -terms, a term of this type isin
\Pi fl-long normal form if it takes the form

\Lambda x1 : ffi1.\Lambda x2 : ffi2 u* u* u* \Lambda xk : ffik. x n1 u* u* u* nk
where x is a variable and n1, . . . , nk are \Pi fl-long normal forms. Accordingly, wecan use the nominal signature

\Sigma LNF with

atom-sorts data-sorts constructorsv

ffi nffi Vffi : vffi \Phi  uffiu

ffi Affi,ffi\Lambda  : uffi .\Phi ffi\Lambda  * nffi \Phi  uffi\Lambda L

ffi,ffi\Lambda  : ffvffi finffi\Lambda  \Phi  nffi .\Phi ffi\Lambda I : u

\Omega  \Phi  n\Omega 

where ffi and ffi \Lambda  range over Ty. The (nominal) set

N (ffi ) \Theta  T\Theta (\Sigma LNF)nffi (78)
corresponds to the set of \Theta -equivalence classes of abstract syntax trees for simply-typed

\Lambda -terms of type ffi in \Pi fl-long normal form, whereas

U (ffi ) \Theta  T\Theta (\Sigma LNF)uffi (79)
corresponds to the set of \Theta -equivalence classes of neutral (or atomic) terms of type
ffi ; see Dybjer and Filinski [2002, p. 155], for example.

Notation 6.1. From now on we will use the following concrete, overloaded, buthopefully more familiar notations for

\Theta -terms over the signatures \Sigma STL and \Sigma LNF.

--Typical elements of Avffi , \Xi (ffi ), N (ffi ) and U (ffi ) will be written x, e, n and urespectively.

--Vrffi x will be written just as x, Apffi,ffi\Lambda (e1, e2) as e1 e2, and Lmffi,ffi\Lambda  x. e as \Lambda x : ffi. e.
--Vffi x will be written just as x, Affi,ffi\Lambda (u, n) as u n, Lffi,ffi\Lambda  x. n as \Lambda x : ffi. n and I u justas u.

Every \Pi fl-long normal form and every neutral term can be regarded as a \Lambda -term ofthe corresponding type; indeed a very simple application of the second

\Theta -structuralrecursion theorem for the nominal signature
\Sigma LNF tells us that there are functions

iffi \Pi  N (ffi ) \Phi fs \Xi (ffi ) jffi \Pi  U (ffi ) \Phi fs \Xi (ffi ) (80)

490 ANDREW M. PITTS
supported by the empty set of atoms and satisfying for all ffi, ffi \Lambda  \Pi  Ty and x, u, n ofsuitable arity

jffi x = x
jffi\Lambda (u n) = ( jffi .\Phi ffi\Lambda  u)(iffi n)
iffi .\Phi ffi\Lambda (\Lambda x : ffi. n) = \Lambda x : ffi. iffi\Lambda  n

i\Omega  u = j\Omega  u.

We aim to use the technique of NBE [Berger and Schwichtenberg 1991] to definethe normalization function

normffi \Pi  \Xi (ffi ) \Phi fs N (ffi ) (81)
with the following properties:

(fflffi \Pi  Ty, e1, e2 \Pi  \Xi (ffi )) e1 =\Pi fl e2 \Upsilon  normffi e1 = normffi e2 (82)
(fflffi \Pi  Ty, n \Pi  N (ffi )) normffi (iffi n) = n (83)
(fflffi \Pi  Ty, e \Pi  \Xi (ffi )) iffi (normffi e) =\Pi fl e. (84)

Here =\Pi fl \Psi  \Xi (ffi ) OE \Xi (ffi ) is the usual relation of \Pi fl-conversion between(

\Theta -equivalence classes of) \Lambda -terms of the same simple type ffi . It is by definition thesmallest congruence relation satisfying

(fflffi, ffi \Lambda  \Pi  Ty, x \Pi  Avffi , e1 \Pi  \Xi (ffi \Lambda ), e2 \Pi  \Xi (ffi )) (\Lambda x : ffi. e1)e2 =\Pi fl e1[x := e2](85)

(fflffi, ffi \Lambda  \Pi  Ty, e \Pi  \Xi (ffi .\Phi  ffi \Lambda ), x \Pi  Avffi ) x # e \Upsilon  e =\Pi fl \Lambda x : ffi. e x. (86)
Here e1[x := e2] indicates the capture-avoiding substitution of e2 for all free occur-rences of x in e

1. It can be defined using the second \Theta -structural recursion theoremfor the nominal signature

\Sigma STL much as in Example 5.5; instead, we will regard it asa special case of the simultaneous substitution functions defined in the next section.

Once (82)-(84) are proved, then it follows that for every e \Pi  \Xi (ffi ) there is a uniquen \Pi  N (

ffi ) with e =\Pi fl iffi n; and, modulo some considerations about computability,deciding

\Pi fl-conversion is reduced to the decidable relation of \Theta -equivalence onT(
\Sigma LNF)nffi by applying the normffi function. We aim to show how to use \Theta -structuralrecursion to define norm

ffi ; and how to prove (82)-(84) using, among other things,
\Theta -structural induction.

6.2. SUBSTITUTION. A (simultaneous) substitution \Upsilon  is a function that mapsatoms in A

vffi to \Theta -terms in \Xi (ffi ) (for any ffi \Pi  Ty) and that has the property that itsdomain

dom(\Upsilon  ) \Theta  \Sigma x \Pi  \Upsilon ffi\Pi Ty Avffi -- \Upsilon  x \Xi = x\Phi 
is a finite set. We let atom-permutations \Phi  \Pi  Perm act on such functions in theusual way (Section 3.2): the substitution

\Phi  u* \Upsilon  maps x \Pi  Avffi to \Phi  u* (ffl(\Phi -1(x)) and(therefore) has domain dom(
\Phi  u* \Upsilon  ) = \Phi  u* dom(\Upsilon  ) = -\Phi  (x) -- x \Pi  dom(\Upsilon  )"". It isnot hard to see that with respect to this action, each substitution

\Upsilon  is supported bythe finite set of atoms dom(
\Upsilon  ) \Sigma  \Upsilon x\Pi dom(\Upsilon ) supp(\Upsilon  x). Therefore, the collection of

substitutions forms a nominal set that we write as Sub.Given

ffi \Pi  Ty, e \Pi  \Xi (ffi ) and \Upsilon  \Pi  Sub, we let [e]\Upsilon  \Pi  \Xi (ffi ) denote the result ofcarrying out on e the simultaneous, capture-avoiding substitution given by

\Upsilon  . This

Alpha-Structural Recursion and Induction 491

FIG. 5. Substitution and denotation.
is specified by the recursion Eq. (87)-(88) in Figure 5. For each \Upsilon  \Pi  Sub, we can usethe second

\Theta -structural recursion theorem for \Sigma STL to define the functions ([-]\Upsilon  \Pi 
\Xi (ffi ) \Phi fs \Xi (ffi ) -- ffi \Pi  Ty) satisfying these equations, much as in Example 5.5, butusing supp(

\Upsilon  ) as the common finite support A. (In particular, in Theorem 5.1 theonly nontrivial freshness condition on binders, (FCB

Lmffi,ffi\Lambda  ), is easily verified.)The identity substitution
\Upsilon 0 \Pi  Sub maps each x \Pi  Avffi to x \Pi  \Xi (ffi ). Thecomposition

\Upsilon 1; \Upsilon 2 of \Upsilon 1, \Upsilon 2 \Pi  Sub is the element of Sub that maps each x \Pi  Avffito [
\Upsilon 1 x]\Upsilon 2. These operations satisfy:

[e]\Upsilon 0 = e (93)
[e](\Upsilon 1; \Upsilon 2) = [[e]\Upsilon 1]\Upsilon 2. (94)

Both properties can be proved easily by applying the second \Theta -structural inductionprinciple (Theorem 5.2) for the nominal signature

\Sigma STL. For example, to prove (94),for each
\Upsilon 1, \Upsilon 2 \Pi  Sub we take Stffi to be -e \Pi  \Xi (ffi ) -- [e](\Upsilon 1; \Upsilon 2) = [[e]\Upsilon 1]\Upsilon 2"", whichis supported by A = supp(

\Upsilon 1, \Upsilon 2); then (IHVrffi ) and (IHApffi,ffi\Lambda  ) are easy to verify,using (87) and (88) respectively; for (IH

Lmffi,ffi\Lambda  ), which is the statement

(*x \Pi  Avffi ) x /\Pi  A & (ffle \Pi  Stffi\Lambda  ) \Lambda x : ffi. e \Pi  Stffi .\Phi ffi\Lambda  ,
we can choose any x in the infinite set Avffi - A (so that x # (\Upsilon 1, \Upsilon 2)): if e \Pi  Stffi\Lambda  ,then

[\Lambda x : ffi. e](\Upsilon 1; \Upsilon 2)=

[[\Lambda x : ffi. e]\Upsilon 1]\Upsilon 2 by definition of \Upsilon 1; \Upsilon 2=
[\Lambda x : ffi. [e]\Upsilon 1]\Upsilon 2 by (89), since x # \Upsilon 1=
\Lambda x : ffi. [[e]\Upsilon 1]\Upsilon 2 by (89), since x # \Upsilon 2=
\Lambda x : ffi. [e](\Upsilon 1; \Upsilon 2) since e \Pi  Stffi\Lambda =
[\Lambda x : ffi. e](\Upsilon 1; \Upsilon 2) by (89), since x # (\Upsilon 1; \Upsilon 2) (because \Upsilon 1; \Upsilon 2 is

supported by supp(\Upsilon 1) \Sigma  supp(\Upsilon 2) \Psi  A)

and hence \Lambda x : ffi. e \Pi  Stffi .\Phi ffi\Lambda  .The single-variable substitution used in the definition of =

\Pi fl in the previoussection can be defined as:

e1[x := e2] \Theta  [e1](\Upsilon 0-x j\Phi  e2""), (95)
where in general the updated substitution \Upsilon  -x j\Phi e"" \Pi  Sub maps x \Pi  Avffi to e \Pi  \Xi (ffi )and otherwise acts like

\Upsilon  \Pi  Sub.

492 ANDREW M. PITTS

6.3. DENOTATION. We interpret each simple type ffi \Pi  Ty as a nominal set D(ffi )as follows:

D(\Omega ) \Theta  N (\Omega ) (96)
D(ffi .\Phi  ffi \Lambda ) \Theta  D(ffi ) \Phi fs D(ffi \Lambda ). (97)

An environment ffl is a function that, for any ffi \Pi  Ty, maps the atoms in Avffi toelements of D(

ffi ). We let atom-permutations \Phi  \Pi  Perm act on such functions in theusual way (Section 3.2): the environment

\Phi  u* ffl maps x \Pi  Avffi to \Phi  u* (ffl(\Phi  -1(x)).Let Env be the nominal set of environments that are finitely supported with respect

to this action.Given

ffi \Pi  Ty, e \Pi  \Xi (ffi ) and ffl \Pi  Env, we wish to define the denotation[[e]]
ffl \Pi  D(ffi ), satisfying Eq. (90)-(92) in Figure 5. It is clear from the form ofthese equations that we should try to define [[e]]

ffl by \Theta -structural recursion for
\Sigma STL for all ffl simultaneously, because of the use of an updated environment in(92):

ffl-x j\Phi  d"" is by definition the function mapping x to d and otherwise act-ing like

ffl (and is finitely supported by supp(ffl) \Sigma  -x"" \Sigma  supp(d)). So in The-orem 5.1 it seems that we should take X

tffi to be Env \Phi fs D(ffi ) and use thefunctions

fVrffi \Theta  \Lambda x \Pi  Avffi .\Lambda ffl \Pi  Env. ffl x (98)
fApffi,ffi\Lambda  \Theta  \Lambda (fi, fi \Lambda ) \Pi  Xtffi .\Phi ffi\Lambda  OE Xtffi .\Lambda ffl \Pi  Env. fi ffl (fi \Lambda ffl) (99)
fLmffi,ffi\Lambda  \Theta  \Lambda (x, fi \Lambda ) \Pi  Avffi OE Xtffi\Lambda  .\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ). fi \Lambda (ffl-x j\Phi  d""). (100)

These functions are all supported by A = ^ and the only nontrivial freshnesscondition on binders is (FCB

Lmffi,ffi\Lambda  ), which in view of Theorem 3.8 (the "some/any"theorem) is the requirement that for all x \Pi  A

vffi and fi \Pi  Env \Phi fs D(ffi \Lambda )

x # \Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ). fi (ffl-x j\Phi  d""). (101)

If we could prove that, then the theorem gives us functions ^f tffi \Pi  \Xi (ffi ) \Phi fs
(Env \Phi fs D(ffi )) satisfying (47)--from which it follows that [[e]]ffl \Theta  ^f tffi e fflsatisfies (90)-(92). The problem is that (101) is not true for all elements

fi ofEnv \Phi 

fs D(ffi \Lambda )! We have to strengthen the "recursion hypothesis" by suitablyrestricting the class of functions

fi that we consider.This is the first time in this article we have encountered a really nontrivial

"freshness condition on binders". Eq. (90)-(92) are typical of many such defi-nitions in denotational semantics; but why is it the case that the right-hand side
of Eq. (92) is independent of the choice of bound variable x on the left-handside? Compared with the similar question for Eq. (89) a few lines above it,
there seems no quick answer to this question. However, the freshness of x for
\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ). [[e]](ffl-x j\Phi  d"") does follow from two expected properties ofdenotations:

(1) The denotation of e with respect to an environment ffl only depends on the valueof

ffl at the free variables of e.

(2) The denotation of a permuted version \Phi  u* e of e with respect to an environment

ffl is the denotation of e with respect to the composition ffl ` \Phi .

Alpha-Structural Recursion and Induction 493
It is possible to take account of these facts in advance when applying Theorem 5.1to construct denotations.12 To do so, we cut down to the following nominal subset
of Env \Phi fs D(ffi ):

Xtffi \Theta  -fi \Pi  Env \Phi fs D(ffi ) -- i1(fi ) & i2(fi )"", (102)
where

i1(fi ) \Theta  (* A \Pi  Pfin(A))(fflffi \Pi  Ty, x \Pi  Avffi , d \Pi  D(ffi ), ffl \Pi  Env)x

/\Pi  A \Upsilon  fi (ffl-x j\Phi  d"") = fi ffl (103)

i2(fi ) \Theta  (ffl\Phi  \Pi  Perm, ffl \Pi  Env) (\Phi  u* fi ) ffl = fi (ffl ` \Phi ). (104)
The slightly elaborate form of i1 compared with property 1 above is needed toshow that the functions defined in (98)-(100) satisfy

i1( fVrffi x)
i1(fi ) & i1(fi \Lambda ) \Upsilon  i1( fApffi,ffi\Lambda  (fi, fi \Lambda ))
i1(fi \Lambda ) \Upsilon  i1( fLmffi,ffi\Lambda  (x, fi \Lambda )).

Similar properties hold for i2. Therefore, fVrffi \Pi  Avffi \Phi fs Xtffi , fApffi,ffi\Lambda  \Pi  Xtffi .\Phi ffi\Lambda  OEX

tffi \Phi fs Xtffi\Lambda  and fLmffi,ffi\Lambda  \Pi  Avffi OE Xtffi\Lambda  \Phi fs Xtffi .\Phi ffi\Lambda  . Furthermore, it is now the casethat if x \Pi  A

vffi and fi \Lambda  \Pi  Xtffi\Lambda  , then (101) holds. To see this, first note that since
i1(fi \Lambda ) holds, there is a finite set of atoms A such that

(fflffi \Pi  Ty, x\Lambda  \Pi  Avffi , d\Lambda  \Pi  D(ffi ), ffl\Lambda  \Pi  Env) x\Lambda  /\Pi  A \Upsilon  fi \Lambda (ffl\Lambda -x\Lambda  j\Phi  d\Lambda "") = fi \Lambda ffl\Lambda .(105)

Choose any x\Lambda  in the infinite set Avffi - supp(x, fi \Lambda , A). Hence, x\Lambda  # \Lambda ffl \Pi  Env.\Lambda d \Pi D(

ffi ). fi \Lambda (ffl-x j\Phi  d""); and so applying the transposition (x x\Lambda ) to this we get

x = (x x\Lambda ) u* x\Lambda 

# (x x\Lambda ) u* \Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ).fi \Lambda (ffl-x j\Phi  d"")=

\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ).((x x\Lambda ) u* fi \Lambda )(ffl-x\Lambda  j\Phi  d"")=
\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ).fi \Lambda (ffl-x\Lambda  j\Phi  d"" ` (x x\Lambda )) because i2(fi \Lambda ) holds=
\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ).fi \Lambda (ffl-x j\Phi  d""-x\Lambda  j\Phi  ffl x"") because x\Lambda  \Xi = x=
\Lambda ffl \Pi  Env.\Lambda d \Pi  D(ffi ).fi \Lambda (ffl-x j\Phi  d"") by (105), since x\Lambda  /\Pi  A.

So (101) does indeed hold. Therefore, we can apply Theorem 5.1 to these nominal
sets and functions to obtain ^f tffi \Pi  Xtffi satisfying (47). Defining [[e]]ffl \Theta  ^f tffi e ffl, weget the required properties (90)-(92).

Denotations respect \Pi fl-conversion:

e1 =\Pi fl e2 \Upsilon  [[e1]] = [[e2]]. (106)
To see this, it suffices to show that [[-]] = [[-]] is a congruence relation equating
\Pi -convertible (85) and fl-convertible (86) terms. Congruence is immediate from

12 We are in effect carrying out a simultaneous inductive-recursive definition: see Dybjer [2000].

494 ANDREW M. PITTS
the defining properties (90)-(92) of [[-]]. To see that [[-]] respects \Pi -conversion,one has to show

[[e\Lambda [x := e]]]ffl = [[e\Lambda ]](ffl-x j\Phi  [[e]]ffl"") (107)
and for fl-conversion one has to show

x /\Pi  fv(e) \Upsilon  [[e]](ffl-x j\Phi  d"") = [[e]]ffl. (108)
These properties can be proved using the second \Theta -structural induction principle(Theorem 5.2) for

\Sigma STL, with the second one used in the proof of the first.13 For(108), one can use the subsets

Stffi \Theta  -e \Pi  \Xi (ffi ) --

(fflx \Pi  Avffi , ffl \Pi  Env, d \Pi  D(ffi )) x # e \Upsilon  [[e]](ffl-x j\Phi  d"") = [[e]]ffl""

which are all supported by the empty set. Properties (90)-(92) of [[-]] allow oneto show that these subsets satisfy the induction hypotheses (IH

Vrffi ), (IHApffi,ffi\Lambda  ) and(IH
Lmffi,ty\Lambda  ); hence, by Theorem 5.2, each Stffi is the whole of \Xi (ffi ) and (108) holds.For (107), for each x \Pi  A

vffi and e \Pi  \Xi (ffi ), we apply Theorem 5.2 to the subsets

S\Lambda tffi \Theta  -e\Lambda  \Pi  \Xi (ffi ) -- (fflffl \Pi  Env) [[e\Lambda [x := e]]]ffl = [[e\Lambda ]](ffl-x j\Phi  [[e]]ffl"")"",

which are all supported by A \Theta  -x"" \Sigma  supp(e). To conclude that S\Lambda tffi = \Xi (ffi ), we
have to prove the these subsets S\Lambda tffi satisfy the induction hypotheses (IHVrffi ), (IHApffi,ffi\Lambda  )and (IH

Lmffi,ty\Lambda  ). The first two follow easily from (90) and (91). For (IHLmffi,ty\Lambda  ), we haveto show (*x\Lambda  \Pi  A

vffi ) x\Lambda  # (x, e) & (ffle\Lambda  \Pi  Stffi ) \Lambda x\Lambda  : ffi. e\Lambda  \Pi  Stffi ; but choosingany x\Lambda  in the infinite set A

vffi - supp(x, e), for each e\Lambda  \Pi  S\Lambda tffi and ffl \Pi  Env wehave:

[[(\Lambda x\Lambda  : ffi. e\Lambda )[x := e]]]ffl=

[[\Lambda x\Lambda  : ffi. (e\Lambda [x := e])]]ffl since x\Lambda  /\Pi  fv(x, e)=
\Lambda d \Pi  D(ffi ). [[e\Lambda [x := e]]](ffl-x\Lambda  j\Phi  d"") by (92)=
\Lambda d \Pi  D(ffi ). [[e\Lambda ]](ffl-x\Lambda  j\Phi  d""-x j\Phi  [[e]](ffl-x\Lambda  j\Phi  d"")"") since e\Lambda  \Pi  Stffi=
\Lambda d \Pi  D(ffi ). [[e\Lambda ]](ffl-x\Lambda  j\Phi  d""-x j\Phi  [[e]]ffl"") by (108), since x\Lambda  /\Pi  fv(e)=
\Lambda d \Pi  D(ffi ). [[e\Lambda ]](ffl-x j\Phi  [[e]]ffl""-x\Lambda  j\Phi  d"" since x\Lambda  \Xi = x=
[[\Lambda x\Lambda  : ffi. e\Lambda ]](ffl-x j\Phi  [[e]]ffl"") by (92)

so that \Lambda x\Lambda  : ffi. e\Lambda  \Pi  Stffi , as required.

6.4. REIFICATION, REFLECTION AND NORMALIZATION. The reification functionae
ffi \Pi  D(ffi ) \Phi fs N (ffi ) turns elements of the denotational model into \Pi fl-longnormal forms, whereas the reflection function oe

ffi \Pi  U (ffi ) \Phi fs D(ffi ) turns neutralterms into denotational elements. Both functions are defined simultaneously by

ordinary structural recursion for simple type symbols ffi \Pi  Ty in Figure 6, where forclarity we have written

\Theta -terms over the signature \Sigma LNF without the conventions

13 It might seem that (108) is a consequence of the property (103) that we built in to the construction
of [[-]]; but unfortunately that property only tells us that [[e]](ffl-x j\Phi  d"") and [[e]]ffl are equal when xavoids some finite set of atoms, rather than the particular finite set supp(e).

Alpha-Structural Recursion and Induction 495

FIG. 6. Reification (aeffi ) and reflection (oeffi ).
introduced by Notation 6.1. The interesting part of the definition in this figure isclause (110), where we make use of the fresh construct from Theorem 3.10. To do
so, we have to check that the conditions of that theorem are satisfied; but in thiscase that is easy: given f \Pi  D(

ffi .\Phi  ffi \Lambda ), choosing any atom x in the infinite setA

vffi - supp(aeffi\Lambda , oeffi , f ),14 then the element

h \Theta  \Lambda x \Pi  Avffi . Lffi,ffi\Lambda  x. aeffi\Lambda ( f (oeffi (Vffi x)))
of Avffi \Phi fs N (ffi \Lambda ) satisfies x # h (by choice of x) and x # h(x) (because x /\Pi fv(L

ffi,ffi\Lambda  x. n) for any n \Pi  N (ffi \Lambda )); so we can form fresh(h) as in the theorem.

Definition 6.2 The initial environment ffl0 maps each x \Pi  Avffi to oeffi (Vffi x) \Pi D(

ffi ), for all ffi \Pi  Ty. This has empty support (because the oeffi functions do) andhence in particular it is an element of the nominal set Env of finitely supported

environments. Using it, we define the normalization function normffi \Pi  \Xi (ffi ) \Phi fsN (

ffi ) by:

normffi (e) \Theta  aeffi ([[e]]ffl0). (113)
Recall that we wish to show that normffi has the properties (82)-(84). Property(82) follows immediately from (106). Property (83) is the first half of the following
result.

LEMMA 6.3. For all ffi \Pi  Ty, n \Pi  N (ffi ) and u \Pi  U (ffi )

aeffi ([[iffi n]]ffl0) = n (114)

[[ jffi u]]ffl0 = oeffi (u). (115)

PROOF. These properties can be proved by using the second \Theta -structural in-duction principle (Theorem 5.2) for

\Sigma LNF to show that the subsets

Snffi \Theta  -n \Pi  N (ffi ) -- aeffi ([[iffi n]]ffl0) = n""
Suffi \Theta  -u \Pi  U (ffi ) -- [[ jffi u]]ffl0 = oeffi (u)""

14In fact, supp(aeffi\Lambda  , oeffi , f ) = supp( f ) because the reification and reflection functions turn out to have
empty support.

496 ANDREW M. PITTS

FIG. 7. Logical relation.
are equal to N (ffi ) and U (ffi ) respectively (for all ffi \Pi  Ty). Since these subsets aresupported by the empty set of atoms one can take A = ^ in the theorem and prove

(fflx \Pi  Avffi ) Vffi x \Pi  Suffi (IHVffi )
(fflu \Pi  Suffi .\Phi ffi\Lambda  , n \Pi  Snffi ) Affi,ffi\Lambda (u, n) \Pi  Suffi\Lambda  (IHAffi,ffi\Lambda  )

(*x \Pi  Avffi )(ffln \Pi  Snffi\Lambda  ) Lffi,ffi\Lambda  x. n \Pi  Snffi .\Phi ffi\Lambda  (IHLffi,ffi\Lambda  )
(fflu \Pi  Su\Omega  ) I u \Pi  Su\Omega . (IHI)

These nearly all follow directly from the definitions of iffi , jffi , aeffi , oeffi , [[-]] and ffl0.The only tricky case is for (IH

Lffi,ffi\Lambda  ), because of the use of fresh in aeffi .\Phi ffi\Lambda . Pickingany atom x in A
vffi , suppose n \Pi  Snffi\Lambda  . We wish to prove that Lffi,ffi\Lambda  x. n \Pi  Snffi .\Phi ffi\Lambda  .Note that x # L
ffi,ffi\Lambda  x. n; so since [[-]], iffi .\Phi ffi\Lambda  and ffl0 have empty support, it is thecase that x # [[i

ffi .\Phi ffi\Lambda (Lffi,ffi\Lambda  x. n)]]ffl0 = [[\Lambda x : ffi. iffi\Lambda  n]]ffl0 = f , where f \Theta  \Lambda d \Pi D(ffi ). [[i
ffi\Lambda  n]](ffl0-x j\Phi  d""). Hence

x # (\Lambda x\Lambda  \Pi  Avffi . Lffi,ffi\Lambda  x\Lambda . aeffi\Lambda ( f (oeffi (Vffi x\Lambda ))))
and therefore by definition of fresh in Theorem 3.10

aeffi .\Phi ffi\Lambda ([[iffi .\Phi ffi\Lambda (Lffi,ffi\Lambda  x. n)]]ffl0)=

fresh(\Lambda x\Lambda  \Pi  Avffi . Lffi,ffi\Lambda  x\Lambda . aeffi\Lambda ( f (oeffi (Vffi x\Lambda ))))=
Lffi,ffi\Lambda  x. aeffi\Lambda ( f (oeffi (Vffi x)))=
Lffi,ffi\Lambda  x. aeffi\Lambda ([[iffi\Lambda  n]](ffl0-x j\Phi  oeffi (Vffi x)""))=
Lffi,ffi\Lambda  x. aeffi\Lambda ([[iffi\Lambda  n]]ffl0) by definition of ffl0=
Lffi,ffi\Lambda  x. n since n \Pi  Snffi\Lambda 

so that Lffi,ffi\Lambda  x. n is indeed an element of Snffi .\Phi ffi\Lambda  .

It just remains to prove that normffi has the property (84). For this we use alogical relation _

ffi \Psi  D(ffi )OE\Xi (ffi ) between elements of the denotational model andterms. It is defined by ordinary structural recursion for simple type symbols

ffi \Pi  Tyin Figure 7, which also extends the relation to one between (finitely supported)

environments and substitutions.

LEMMA 6.4 (FUNDAMENTAL PROPERTY OF _ ). For all ffi \Pi  Ty, e \Pi  \Xi (ffi ), ffl \Pi Env and

\Upsilon  \Pi  Sub

ffl _ \Upsilon  \Upsilon  [[e]]ffl _ffi [e]\Upsilon . (116)

Alpha-Structural Recursion and Induction 497

PROOF. This can be proved by applying the second \Theta -structural induction the-orem for the nominal signature

\Sigma STL to show that the subsets

Sffi \Theta  -e \Pi  \Xi (ffi ) -- (fflffl \Pi  Env, \Upsilon  \Pi  Sub) ffl _ \Upsilon  \Upsilon  [[e]]ffl _ffi [e]\Upsilon  ""
are equal to \Xi (ffi ), for all ffi \Pi  Ty. Proving the induction hypotheses (IHVrffi ) and(IH

Apffi,ffi\Lambda  ) is straightforward; and for (IHLmffi,ffi\Lambda  ), one first proves

d _ffi e & e =\Pi fl e\Lambda  \Upsilon  d _ffi e\Lambda  (117)
([\Lambda x. e]\Upsilon  ) e\Lambda  =\Pi fl [e](\Upsilon  -x j\Phi  e\Lambda "") (118)

where \Upsilon  -x j\Phi  e\Lambda "" indicates an updated substitution mapping x to e\Lambda  and otherwiseacting like

\Upsilon  .

One can prove by ordinary structural induction for types ffi \Pi  Ty that

(fflffi \Pi  Ty, u \Pi  U (ffi )) oeffi (u) _ffi jffi u (119)
(fflffi \Pi  Ty, d \Pi  D(ffi ), e \Pi  \Xi (ffi )) d _ffi e \Upsilon  iffi (aeffi (d)) =\Pi fl e. (120)

(Both properties are proved simultaneously, and one needs to make use of (117).)Because of (119), the identity substitution

\Upsilon 0 \Pi  Sub satisfies ffl0 _ \Upsilon 0 . So byLemma 6.4 and (93) we have [[e]]
ffl0 _ffi [e]\Upsilon 0 = e, for all e \Pi  \Xi (ffi ). Thus, (120)gives i

ffi (aeffi ([[e]]ffl0)) =\Pi fl e, that is, iffi (normffi (e)) =\Pi fl e, as required for (84).

7. Assessment

7.1. MATHEMATICAL PERSPECTIVE. The results of this article are directly in-spired by my joint work with Gabbay on "FM-set" theory [Gabbay and Pitts 2002]

and by his PhD thesis [Gabbay 2000]. In particular, those works contain structuralrecursion and induction principles for an inductively defined FM-set isomorphic
to \Lambda -terms modulo \Theta -equivalence. Here I have taken an approach that is both a bitmore general and more concrete: more general, because the particular signature for
\Lambda -terms has been replaced by an arbitrary nominal signature (a notion which comesfrom joint work with Urban et al. [2004] and is developed further in Cheney's
thesis [Cheney 2004]); and more concrete in two respects. First, the key notion of(finite) support has been developed using nominal sets within the framework of
ordinary higher-order classical logic, rather than being axiomatised within FM-settheory; see Cheney [2004, Chap. 3] for a more leisurely and generalized account
of the theory of nominal sets. Second, the recursion and induction principles de-veloped here refer directly to

\Theta -terms, that is, standard \Theta -equivalence classes ofabstract syntax trees, rather than using an initial algebra that is merely isomorphic

to the set of \Theta -terms; see Remark 5.3. This is also the approach taken by Norrish[2004], building on Gordon and Melham's five axioms for

\Theta -equivalence [Gordonand Melham 1996]; and also by Urban and Tasson [2005]. Norrish's recursion principle [Norrish 2004, Figure 1] has side-conditions requiring that the function beingdefined be well-behaved with respect to variable-permutations and with respect to
generation of fresh variables. In effect, these side-conditions build in just enough ofthe theory of nominal sets to yield a well-defined and total function, while only having to specify how binders with fresh variables are mapped by the function. Alongwith Urban and Tasson [2005], I prefer to develop the theory of nominal sets in its

498 ANDREW M. PITTS
own right and then give a simple-looking15 recursion principle within that theory.One advantage of such an approach is that it makes it easier to identify and use
properties of name freshness, such as Theorem 3.10, independently of the recursionprinciple. We used Theorem 3.10 in the reduction of Theorem 4.1 to Theorem 2.3,
in the reduction of "varying parameters" to "no parameters" (Example 5.6) andin the definition of the reification functions in the extended example in Section 6;
another good example of its use occurs (implicitly) in the denotational semanticsof FreshML's

fresh expression [Shinwell and Pitts 2005, Sect. 3].How easy is it to apply these principles of

\Theta -structural recursion and induction?Just as for the work of Gordon and Melham [1996], Norrish [2004] and Urban and

Tasson [2005], to use them one does not have to change to an unfamiliar logic (weremain in higher-order classical logic), or a new way of representing syntax (we use
the familiar notion of \Theta -equivalence classes of abstract syntax trees). One does haveto get used to thinking in terms of permutations and finite support; and the latter
is undoubtedly a subtle concept at higher types. However, the relativisation fromarbitrary mathematical objects to finitely supported ones called for by this approach
is made easier by the fact (Theorem 3.5) that the finite support property is conservedby all the usual constructs of higher-order logic except for uses of the axiom of
choice. Thus, if some language of interest has been specified as the \Theta -terms for aparticular nominal signature and one wishes to define a function on those

\Theta -termsspecified by an instance of the recursion scheme (47) in Theorem 5.1 (for suitable

functions fK), then there are three tasks involved in applying the theorem to thisdata:

(I) Show that the sets Xs that one is mapping into have the structure of nominalsets.
(II) Show that the functions fK are all supported by a single finite set of atoms A.
(III) Show that each function fK satisfies the "freshness condition on binders"(FCB

K).

Task (I) is usually carried out by showing how the Xs are built up from some stan-dard nominal sets (such as those in Example 3.2) using the constructions described

in Sections 3.2 and 3.3. Task (II) might seem quite difficult, but in fact the FiniteSupport Principle (Theorem 3.5) usually reduces it to seeing how the f

K are con-structed within higher-order logic. So really the main difficulty is task (III). In some

cases, such as the capture-avoiding substitution function in Example 5.5, (FCBK)is very easily checked. In other cases, such as in the definition of the denotation
functions [[-]] in the extended example of Section 6, one has to work hard to verifythe freshness condition on binders.

Applying the \Theta -structural induction principles is somewhat easier. For example,for the second

\Theta -structural induction principle (Theorem 5.2) one still has theanalogues of the easy tasks (I) and (II); and then one just has to verify the induction

hypothesis (IHK) for each constructor K, which is in fact a more restricted propertythan the corresponding induction hypothesis in an ordinary structural induction for
terms rather than \Theta -terms.

15 Once one gets used to the distinctive concepts of nominal sets, I believe that principles such as
Theorems 4.1, 5.1 and 5.4 are quite simple.

Alpha-Structural Recursion and Induction 499

7.2. AUTOMATED THEOREM PROVING PERSPECTIVE. Based on experience withother formalisms, I claim that the use of permutations and finitely supported objects
advocated here is a simple, effective and yet rigorous way of dealing with bindersand

\Theta -equivalence in "article-and-pencil" proofs in programming language seman-tics. But how easy is it to provide computer support for reasoning with

\Theta -structuralrecursion and induction? Of the three types (I-III) of task involved in applying

these principles in any particular case that were mentioned above, task (III) willrequire human-intervention; but in view of Theorem 3.5, there is the possibility
of automating tasks (I) and (II). One way of attempting that is to develop a newhigher-order logic in which types only denote nominal sets and that axiomatises
properties of permutations and finite support; this is the route taken by Gabbay,with his FM-HOL [2002]. The disadvantage of such a "new logic" approach is
that one does not have easy access to the legacy of already-proved results in sys-tems such as HOL4 and Isabelle/HOL. To what extent tasks (I) and (II) can be
automated within these "legacy" mechanised logics remains to be seen. The workof Norrish [2004] provides a starting point within the HOL4 system. For the Isabelle system, Urban and Tasson [2005] developed a theory equivalent to nominalsets within Isabelle/HOL up to and including an induction principle (but not a recursion principle) for the particular nominal signature for \Lambda -terms.16 Building uponthat foundation, Urban and Berghofer are developing a Nominal Datatype Package
for Isabelle/HOL that allows its users to declare nominal signatures and then haveprinciples of

\Theta -structural recursion and induction for those signatures proved andready to be applied: see http://isabelle.in.tum.de/nominal/.

HOL4 and Isabelle/HOL are theorem-proving systems for higher-order classicallogic. Can support for

\Theta -structural recursion and induction be provided in proof-assistants based on constructive metatheory, such as the Coq [pauillac.inria.fr/coq/]

and Twelf [www.cs.cmu.edu/twelf/] systems? Answering this question involvesinvestigating a topic we have not addressed here: the constructive content of the
theory of nominal sets and (hence) the integration of atoms, atom-permutations andfinite support with the metalogical frameworks underlying Coq and Twelf. First
steps towards this have been taken by Sch"opp [2006], Sch"opp and Stark [2004],and by Cheney (personal communication, 2006).

Appendix
A. Proof of Second \Theta -Structural Induction Theorem
Given a nominal signature \Sigma , we prove the second \Theta -structural induction principle(Theorem 5.2) as a corollary of the first one, Theorem 4.5. To do so, we must first

develop some properties of the operation _a \Pi  A\Upsilon  , _e \Pi  T\Theta (\Sigma )--\Upsilon -- j\Phi  _a. _e \Pi  T\Theta (\Sigma )\Upsilon and the relation

ff\Upsilon  \Psi  A\Upsilon  OE T\Theta (\Sigma )--\Upsilon -- defined in Figure 2.

LEMMA A.1. If _a \Pi  A\Upsilon  , _e \Pi  T\Theta (\Sigma )--\Upsilon -- and _a ff\Upsilon  _e, then supp( _a. _e) = supp(_e) -supp( _a).

16Their proof of validity of the induction principle follows a different route from the one used here to
prove the \Theta -structural recursion and induction principles.

500 ANDREW M. PITTS

PROOF. This can be proved by ordinary structural recursion for arities. Theinduction step for pair arities uses the fact (20) that the support of a pair is the union
of the supports of its two components. The induction step for atom-binding aritiesuses the fact, noted in Example 3.2(3), that the support of an

\Theta -term is its finite setof free atoms (so that in particular supp(a
. e) = supp(e) - -a"").

LEMMA A.2. Let (Ss \Pi  Pfs(T\Theta (\Sigma )s) -- s \Pi  \Sigma D) be a family of finitely supportedsubsets of

\Theta -terms indexed by the data-sorts of \Sigma . Extend this to arity-indexedfamilies

(S\Upsilon  \Pi  Pfs(T\Theta (\Sigma )\Upsilon  ) -- \Upsilon  \Pi  Ar(\Sigma ))
(S--\Upsilon -- \Pi  Pfs(T\Theta (\Sigma )--\Upsilon --) -- \Upsilon  \Pi  Ar(\Sigma ))

as in Figure 3. Then for any finite set A of atoms, each element of S\Upsilon  is of the form_a

. _e for some _a \Pi  A\Upsilon  and _e \Pi  S--\Upsilon -- satisfying _a # A and _a ff\Upsilon  _e.

PROOF. This can be proved by ordinary structural induction for arities, for allA simultaneously. The induction steps when

\Upsilon  = a \Pi  \Sigma A, \Upsilon  = s \Pi  \Sigma D and \Upsilon  = 1are trivial.

Case \Upsilon  = \Upsilon 1 *\Upsilon 2. By definition of S\Upsilon  , each e \Pi  S\Upsilon  is of the form e = (e1, e2) withe
i \Pi  S\Upsilon i for i = 1, 2. Given A, by induction hypothesis for \Upsilon 1 applied to the finiteset of atoms A \Sigma  supp(e

2), we can find _a1 \Pi  A\Upsilon 1 and _e1 \Pi  S--\Upsilon 1-- with e1 = _a1. _e1,_a
1 # ( A, e2) and _a1 ff\Upsilon 1 _e1. Then, by induction hypothesis for \Upsilon 2, we can find_a
2 \Pi  A\Upsilon 2 and _e2 \Pi  S--\Upsilon 2-- with e2 = _a2. _e2, _a2 # ( A, _a1, _e1) and _a2 ff\Upsilon 2 _e2. Since_a
1 # _a2, we have ( _a1, _a2) \Pi  A\Upsilon 1 o/ A\Upsilon 2 = A\Upsilon  . So e = (e1, e2) = ( _a1, _a2). (_e1, _e2)with ( _a

1, _a2) # A and (_e1, _e2) \Pi  S--\Upsilon 1-- OE S--\Upsilon 2-- = S--\Upsilon --. So it just remains to show( _a
1, _a2) ff\Upsilon  (_e1, _e2). For this, since _ai ff\Upsilon i _ei (i = 1, 2) and _a2 # _e1 hold byconstruction, we just need to prove that _a

1 # _e2. We chose _a1 to have its supportdisjoint from supp(e
2), which by Lemma A.1 is supp(_e2) - supp( _a2); since supp( _a1)is also disjoint from supp( _a

2), it follows that supp( _a1)'supp(_e2) = ^, that is, _a1 # _e2,as required.

Case \Upsilon  = ffafi\Upsilon 1. By definition of S\Upsilon  , each e \Pi  S\Upsilon  is of the form e = a. e1 witha \Pi  A

a - supp(S\Upsilon 1) and e1 \Pi  S\Upsilon 1. Given A, choosing any atom a\Lambda  in the infinite setA
a - supp( A, a, e1), it follows from the characterization of \Theta -equivalence in (29)that e = a\Lambda 

. e\Lambda 1 where e\Lambda 1 \Theta  (a a\Lambda ) u* e1 \Pi  (a a\Lambda ) u* S\Upsilon 1 = S\Upsilon 1, since a, a\Lambda  # S\Upsilon 1. Then byinduction hypothesis for

\Upsilon 1 applied to the finite set of atoms A \Sigma  -a\Lambda "", we can find_a

1 \Pi  A\Upsilon 1 and _e1 \Pi  S--\Upsilon 1-- with e\Lambda 1 = _a1. _e1, _a1 # ( A, a\Lambda ) and _a1 ff\Upsilon 1 _e1. since a\Lambda  # _a1,we have (a\Lambda 

, _a1) \Pi  Aa o/ A\Upsilon 1 = A\Upsilon  . So e = a\Lambda . e\Lambda 1 = (a\Lambda , _a1). _e1 with (a\Lambda , _a1) # A,

_e1 \Pi  S--\Upsilon 1-- = S--\Upsilon -- and (a\Lambda , _a1) ff\Upsilon  _e1.

To prove Theorem 5.2, we also need to see that its induction hypotheses (IHK) areequivalent to ones that universally rather than existentially quantify over suitably
fresh nested tuples _a of atoms. To do so, we make use of the following generalizationof permutations that transpose a pair of atoms.

Definition A.3 (Vector-Transpositions). Let \Sigma  be a nominal signature and \Upsilon  \Pi Ar(

\Sigma ) an arity over the signature. Let the nominal set A\Upsilon  of nested tuples of distinctatoms be defined as in Figure 2. For each pair of elements _a

, _a\Lambda  \Pi  A\Upsilon  with _a # _a\Lambda , let
ffi_a,_a\Lambda  \Pi  Perm be the atom-permutation that transposes the atoms at corresponding

Alpha-Structural Recursion and Induction 501
positions in the nested tuples _a and _a\Lambda . More formally, ffi_a,_a\Lambda  is defined by ordinarystructural recursion on the arity

\Upsilon  as follows:

\Upsilon  ( _a, _a\Lambda ) \Pi  A\Upsilon  o/ A\Upsilon  j\Phi  ffi_a,_a\Lambda  \Pi  Perma \Pi 

\Sigma A ((), ()) j\Phi  \Omega s \Pi 
\Sigma D ((), ()) j\Phi  \Omega 1 (()

, ()) j\Phi  \Omega 
\Upsilon 1 * \Upsilon 2 (( _a1, _a2), ( _a\Lambda 1, _a\Lambda 2)) j\Phi  ffi_a1,_a\Lambda 1 ` ffi_a2,_a\Lambda 2ffafi

\Upsilon 1 ((a, _a1), (a\Lambda , _a\Lambda 1)) j\Phi  (a a\Lambda ) ` ffi_a1,_a\Lambda 1

Although the clauses defining ffi_a,_a\Lambda  make sense for any pair _a, _a\Lambda , we restrict topairs satisfying _a # _a\Lambda  to ensure that

ffi_a,_a\Lambda  enjoys many properties of single-atomtranspositions, (a a\Lambda ). In particular, one can easily prove by ordinary structural

induction for arities that:

\Phi  ` ffi_a,_a\Lambda  ` \Phi  -1 = ffi(\Phi u*_a),(\Phi u*_a\Lambda ) (any \Phi  \Pi  Perm) (121)

supp(ffi_a,_a\Lambda ) \Psi  supp( _a) \Sigma  supp( _a\Lambda ) (122)

ffi_a,_a\Lambda  = ffi_a\Lambda ,_a (123)
ffi_a,_a\Lambda  ` ffi_a,_a\Lambda  = \Omega  (124)

ffi_a,_a\Lambda  u* _a = _a\Lambda . (125)

Part (2) of the following result generalizes the "some/any" Theorem 3.8 from singleatoms to elements of A

\Upsilon  .

LEMMA A.4.
(1) For all finite sets of atoms A, there is some _a \Pi  A\Upsilon  with _a # A.
(2) For all finitely supported subsets S \Pi  Pfs(A\Upsilon  ), if S is supported by the finite setof atoms A, then the following statements are equivalent.

(ffl _a \Pi  A\Upsilon  ) _a # A \Upsilon  _a \Pi  S (126)
(* _a \Pi  A\Upsilon  ) _a # A & _a \Pi  S. (127)

PROOF. Part (1) follows easily by ordinary structural induction for arities \Upsilon  \Pi Ar(

\Sigma ). For part (2), first note that in view of part (1), one just has to show that(127) implies (126). Suppose _a \Pi  A

\Upsilon  satisfies _a # A & _a \Pi  S. Given any other

_a\Lambda  \Pi  A\Upsilon  with _a\Lambda  # A, we have to show _a\Lambda  \Pi  S. We can use part (1) to find _a\Lambda \Lambda  \Pi  A\Upsilon with _a\Lambda \Lambda  # ( A

, _a, _a\Lambda ) and then use the vector-transpositions of Definition A.3 to

define \Phi  \Theta  ffi_a\Lambda ,_a\Lambda \Lambda  ` ffi_a,_a\Lambda \Lambda  \Pi  Perm.17 By (125), we have \Phi  u* _a = _a\Lambda ; and becauseby (122)

\Phi  is supported by supp( _a, _a\Lambda , _a\Lambda \Lambda ), which is disjoint from A and hencefrom supp(S), we have

\Phi  u* S = S. So applying \Phi  to _a \Pi  S we get _a\Lambda  \Pi  S, asrequired.

The following result generalizes the characterization of \Theta -equivalence mentionedin Example 3.9. Note that in view of the previous lemma, the right-hand side of the
17Since it may not be the case that _a # _a\Lambda , we cannot use ffi_a,_a\Lambda  ; so (unlike in the proof of Theorem 3.8)
we resort to swapping via an intermediate, fresh _a\Lambda \Lambda .

502 ANDREW M. PITTS
bi-implication in (128) could be replaced by (ffl _a\Lambda \Lambda  \Pi  A\Upsilon  ) _a\Lambda \Lambda  # A \Upsilon  ffi_a,_a\Lambda \Lambda  u* _e =
ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda  \Pi  T\Theta (\Sigma )--\Upsilon --.

LEMMA A.5. Suppose _a, _a\Lambda  \Pi  A\Upsilon  and _e, _e\Lambda  \Pi  T\Theta (\Sigma )--\Upsilon -- satisfy _a ff\Upsilon  _e and_a\Lambda 

ff\Upsilon  _e\Lambda . If A is a finite set of atoms supporting ( _a, _a\Lambda , _e, _e\Lambda ), then

_a. _e = _a\Lambda . _e\Lambda  \Pi  T\Theta (\Sigma )\Upsilon  ,

(* _a\Lambda \Lambda  \Pi  A\Upsilon  ) _a\Lambda \Lambda  # A & ffi_a,_a\Lambda \Lambda  u* _e = ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda  \Pi  T\Theta (\Sigma )--\Upsilon --. (128)

PROOF. This can be proved by ordinary structural induction for arities \Upsilon  .The induction step for atom-binding arities uses the corresponding property (29)

of =\Theta .

We can now complete the proof of Theorem 5.2. We are given subsets (Ss \Pi P
fs(T\Theta (\Sigma )s) -- s \Pi  \Sigma D) supported by the finite set of atoms A and satisfying (IHK)for each K \Pi 

\Sigma C. Define (S\Upsilon  \Pi  Pfs(T\Theta (\Sigma )\Upsilon  ) -- \Upsilon  \Pi  Ar(\Sigma )) as in the right-handcolumn in Figure 3. It is not hard to see that all of these subsets are also supported

by A and hence so is their union S \Theta  \Upsilon \Upsilon \Pi Ar(\Sigma ) S\Upsilon  . If S = T\Theta (\Sigma ), then Ss = T\Theta (\Sigma )s
for each s \Pi  \Sigma D; and to prove S = T\Theta (\Sigma ) we just have to prove that this Ssatisfies the conditions (41)-(45) of Theorem 4.5. Conditions (41) and (43)-(45)

are immediate from the definition of (S\Upsilon  -- \Upsilon  \Pi  Ar(\Sigma )) in Figure 3. For condition(42), given (K :

\Upsilon  \Phi  s) \Pi  \Sigma C and e \Pi  S\Upsilon  , we have to show that K e \Pi  Ss. Firstnote that by applying Lemma A.4(2) to the subset - _a \Pi  A

\Upsilon  -- (ffl_e \Pi  T\Theta (\Sigma )--\Upsilon --) _a ff\Upsilon 

_e & _e \Pi  S--\Upsilon -- \Upsilon  K _a. _e \Pi  Ss"", which is supported by A, to see that (IHK) isequivalent to

(ffl _a \Pi  A\Upsilon  ) _a # A \Upsilon  (ffl_e \Pi  T\Theta (\Sigma )--\Upsilon --) _a ff\Upsilon  _e & _e \Pi  S--\Upsilon -- \Upsilon  K _a. _e \Pi  Ss.(129)
By Lemma A.2, e = _a. _e with _a \Pi  A\Upsilon  , _e \Pi  S--\Upsilon --, _a # A and _a ff\Upsilon  _e; so (129)gives K e \Pi  S

s. Thus, we can indeed apply Theorem 4.5 to conclude that S is thewhole of T
\Theta (\Sigma ) and hence in particular that each Ss is equal to the whole of T\Theta (\Sigma )s,completing the proof of Theorem 5.2.

B. Proof of Second \Theta -Structural Recursion Theorem
We will establish the second \Theta -structural recursion principle (Theorem 5.1) viaa common strategy for reducing recursion to induction: we first construct relations (using a rule-based inductive definition) that would be the graphs of
the required functions ^f s were they single-valued and total relations-and thenprove they are so by applying Theorem 5.2. A further application of Theorem 5.2 is needed to show that the functions ^f s are unique with the statedproperties.

So suppose we are given a family of nominal sets X = (Xs -- s \Pi  \Sigma D) indexedby the data-sorts of a nominal signature

\Sigma , and functions ( fK \Pi  X (\Upsilon ) \Phi fs X (s) --(K :
\Upsilon  \Phi  s) \Pi  \Sigma C) all of which are supported by a finite set A of atoms and satisfy(FCB

K).

Alpha-Structural Recursion and Induction 503

B.1. Existence of the Functions ^f s \Pi  T\Theta (\Sigma )s \Phi fs XsConsider the subsets F

s \Psi  T\Theta (\Sigma )s OE Xs (for s \Pi  \Sigma D) that are inductively definedby the following rule

K : \Upsilon  \Phi  s _a \Pi  A\Upsilon  _e \Pi  T\Theta (\Sigma )--\Upsilon --
_a # A _a ff\Upsilon  _e (_e, _x) \Pi  F--\Upsilon -- _a ff\Upsilon  _x

(K _a. _e, fK( _a, _x)\Upsilon  ) \Pi  Fs (130)

where F--\Upsilon -- \Psi  T\Theta (\Sigma )--\Upsilon -- OE X --\Upsilon -- is defined from any family (Fs \Psi  T\Theta (\Sigma )s OE Xs -- s \Pi 
\Sigma D) by ordinary recursion on the structure of arities as follows.

\Upsilon  F--\Upsilon -- \Psi  T\Theta (\Sigma )--\Upsilon -- OE X --\Upsilon --a \Pi 

\Sigma A -(a, a) -- a \Pi  Aa""s \Pi 
\Sigma D Fs1 -(()

, ())""
\Upsilon 1 * \Upsilon 2 -((_e1, _e2), ( _x1, _x2)) -- (_e1, _x1) \Pi  F--\Upsilon 1-- & (_e2, _x2) \Pi  F--\Upsilon 2--""ffafi

\Upsilon 1 F--\Upsilon 1--

It is not hard to see that the set of rules determined by (130) is supported by A.Hence, by Theorem 3.6, so are all the subsets F

s (and the subsets F--\Upsilon -- defined fromthem). For the existence part of Theorem 5.1, it suffices to show that each F

s is thegraph of a function ^f
s from T\Theta (\Sigma )s to Xs. For then:

--each ^f s and the functions ^f --\Upsilon -- defined from them as in Figure 2 are supportedby A, because F

s is;
--the graphs of the functions ^f --\Upsilon -- are the relations F--\Upsilon --, because of the abovedefinition of F--

\Upsilon --;

--if _a # A and _a ff\Upsilon  _e, then _a ff\Upsilon  ^f --\Upsilon -- _e, because of the definition of ^f --\Upsilon --;
--hence ( ^f s -- s \Pi  \Sigma D) satisfies the recursion property (47): for if _a # A and _a ff\Upsilon  _e,

then _x \Theta  ^f --\Upsilon -- _e satisfies (_e, _x) \Pi  F--\Upsilon -- and _a ff\Upsilon  _x; so (K _a. _e, fK( _a, _x)\Upsilon  ) \Pi  Fs by
rule (130) and hence ^f s(K _a. _e) = fK( _a, _x)\Upsilon  = fK( _a, ^f --\Upsilon -- _e)\Upsilon  .

To prove that each Fs is the graph of a function, that is, that

Ss \Theta  -e \Pi  T\Theta (\Sigma )s -- (*! x \Pi  Xs) (e, x) \Pi  Fs""
is the whole of T\Theta (\Sigma )s, we apply Theorem 5.2. Note that from the way it is defined,each S

s is supported by A, because Fs is. So we just have to prove that (Ss -- s \Pi  \Sigma D)satisfies (IH

K) for each (K : \Upsilon  \Phi  s) \Pi  \Sigma C. By Lemma A.4(1), there is some _a \Pi  A\Upsilon with _a # A. We prove (IH

K) for this _a by showing that for each _e \Pi  S--\Upsilon -- with _a ff\Upsilon  _eit is the case that K _a
. _e \Pi  Ss.First, note that by the definitions of S--

\Upsilon -- from (Ss -- s \Pi  \Sigma D) (in Figure 3) and

F--\Upsilon -- from (Fs -- s \Pi  \Sigma D), we have

(ffl_e \Pi  T\Theta (\Sigma )--\Upsilon --) _e \Pi  S--\Upsilon -- \Upsilon  (*! _x \Pi  X --\Upsilon --) (_e, _x) \Pi  F--\Upsilon --. (131)
In particular, it follows that if _e \Pi  S--\Upsilon -- and (_e, _x) \Pi  F--\Upsilon --, then supp( _x) \Psi  A\Sigma supp(_e)(since A supports F--

\Upsilon --); and this in turn implies (by induction on the structure of

504 ANDREW M. PITTS
arities \Upsilon  ) that\Xi 

ffl _a \Pi  A\Upsilon  , _e \Pi  T\Theta (\Sigma )--\Upsilon --, _x \Pi  X --\Upsilon --\Pi  _a ff\Upsilon  _e & _e \Pi  S--\Upsilon -- & (_e, _x) \Pi  F--\Upsilon -- \Upsilon 

_a ff\Upsilon  _x. (132)

So by rule (130), if _e \Pi  S--\Upsilon -- with _a ff\Upsilon  _e, then there is some _x \Pi  X --\Upsilon -- with(K _a

. _e, fK(_e, _x)\Upsilon  ) \Pi  Fs. Thus, to see that K _a. _e \Pi  Ss, it just remains to show thatif (K _a

. _e, x) \Pi  Fs, then x = fK(_e, _x)\Upsilon  . But if (K _a. _e, x) \Pi  Fs holds, it must havebeen deduced by an application of rule (130) to

_a\Lambda  # A & _a\Lambda  ff\Upsilon  _e\Lambda  & (_e\Lambda , _x\Lambda ) \Pi  F--\Upsilon -- & _a\Lambda  ff\Upsilon  _x\Lambda 
with K _a. _e = K _a\Lambda . _e\Lambda  and x = fK( _a\Lambda , _x\Lambda )\Upsilon  . So _a. _e = _a\Lambda . _e\Lambda  and by Lemma A.5,
ffi_a,_a\Lambda \Lambda  u* _e = ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda , for some _a\Lambda \Lambda  # ( A, _a, _e, _a\Lambda , _e\Lambda ). By (122), the atom-permutations
ffi_a,_a\Lambda \Lambda  and ffi_a\Lambda ,_a\Lambda \Lambda  have their support disjoint from A and hence from the support ofF--

\Upsilon -- and S--\Upsilon --. Therefore

(ffi_a,_a\Lambda \Lambda  u* _e, ffi_a,_a\Lambda \Lambda  u* _x) = ffi_a,_a\Lambda \Lambda  u* (_e, _x) \Pi  ffi_a,_a\Lambda \Lambda  u* F--\Upsilon -- = F--\Upsilon -- ,
(ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda , ffi_a\Lambda ,_a\Lambda \Lambda  u* _x\Lambda ) = ffi_a\Lambda ,_a\Lambda \Lambda  u* (_e\Lambda , _x\Lambda ) \Pi  ffi_a\Lambda ,_a\Lambda \Lambda  u* F--\Upsilon -- = F--\Upsilon -- ,

ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda  = ffi_a,_a\Lambda \Lambda  u* _e \Pi  ffi_a,_a\Lambda \Lambda  u* S--\Upsilon -- = S--\Upsilon --
and hence by (131), ffi_a,_a\Lambda \Lambda  u* _x = ffi_a\Lambda ,_a\Lambda \Lambda  u* _x\Lambda . Note that from (FCBK), by Lemma A.4(2)we have

(ffl _a \Pi  A\Upsilon  ) _a # A \Upsilon  (ffl _x \Pi  X --\Upsilon --) _a ff\Upsilon  _x \Upsilon  _a # fK( _a, _x)\Upsilon  . (133)
So we have _a # fK( _a, _x)\Upsilon  and _a\Lambda  # fK( _a\Lambda , _x\Lambda )\Upsilon  ; and by choice of _a\Lambda \Lambda  we also have_a\Lambda \Lambda  # ( f

K( _a, _x)\Upsilon  , fK( _a\Lambda , _x\Lambda )\Upsilon  ). Since the atom-permutations ffi_a,_a\Lambda \Lambda  and ffi_a\Lambda ,_a\Lambda \Lambda  have theirsupports in A and hence disjoint from f

K, fK( _a, _x)\Upsilon  and fK( _a\Lambda , _x\Lambda )\Upsilon  , we have

fK( _a, _x)\Upsilon  = ffi_a,_a\Lambda \Lambda  u* fK( _a, _x)\Upsilon  = fK(ffi_a,_a\Lambda \Lambda  u* _a, ffi_a,_a\Lambda \Lambda  u* _x)\Upsilon 
fK( _a\Lambda , _x\Lambda )\Upsilon  = ffi_a\Lambda ,_a\Lambda \Lambda  u* fK( _a\Lambda , _x\Lambda )\Upsilon  = fK(ffi_a\Lambda ,_a\Lambda \Lambda  u* _a\Lambda , ffi_a\Lambda ,_a\Lambda \Lambda  u* _x\Lambda )\Upsilon  .

From above ffi_a,_a\Lambda \Lambda  u* _e = ffi_a\Lambda ,_a\Lambda \Lambda  u* _e\Lambda ; and by (125), ffi_a,_a\Lambda \Lambda  u* _a = _a\Lambda \Lambda  = ffi_a\Lambda ,_a\Lambda \Lambda  u* _a\Lambda . Sof

K( _a, _x)\Upsilon  = fK( _a\Lambda , _x\Lambda )\Upsilon  = x, as required.

B .2. Uniqueness of the Functions ^f s \Pi  T\Theta (\Sigma )s \Phi fs Xs
Suppose ( ^f \Lambda s \Pi  T\Theta (\Sigma )s \Phi fs Xs -- s \Pi  \Sigma D) is also supported by A and satisfies
property (47). To see that ^f \Lambda s = ^f s, if suffices to show that Ss \Theta  -e \Pi  T\Theta (\Sigma )s --^

f s e = ^f \Lambda s e"" is the whole of T\Theta (\Sigma ) for each s \Pi  \Sigma D. This follows almost immediately by Theorem 5.2; one just has to check that the subsets S--\Upsilon -- defined from this
(Ss -- s \Pi  \Sigma D) satisfy S--\Upsilon -- \Psi  -_e \Pi  T\Theta (\Sigma )--\Upsilon -- -- ^f --\Upsilon -- _e = ^f \Lambda --\Upsilon -- _e"".

ACKNOWLEDGMENT. I am grateful to James Cheney, Murdoch Gabbay, MichaelNorrish, Mark Shinwell and Christian Urban for their many contributions to the
subject of this article which is a revised and much extended version of Pitts [2005].

REFERENCES
AYDEMIR, B. E., BOHANNON, A., FAIRBAIRN, M., FOSTER, J. N., PIERCE, B. C., SEWELL, P., VYTINIOTIS,

D., WASHBURN, G., WEIRICH, S., AND ZDANCEWIC, S. 2005. Mechanised metatheory for the masses:
The POPLmark challenge. In Proceedings of the 18th International Conference on Theorem Proving in

Alpha-Structural Recursion and Induction 505

Higher Order Logics (TPHOLs 2005), J. Hurd and T. Melham, Eds. Lecture Notes in Computer Science,
vol. 3603. Springer-Verlag, New York, 50-65. www.cis.upenn.edu/group/proj/plclub/mmm/.
BARENDREGT, H. P. 1984. The Lambda Calculus: Its Syntax and Semantics, revised ed. North-Holland.
BARENDREGT, H. P. 1992. Lambda calculi with types. In Handbook of Logic in Computer Science,

S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, Eds. Vol. 2. Oxford University Press, 117-309.
BERGER, U., EBERL, M., AND SCHWICHTENBERG, H. 2003. Term rewriting for normalization by evaluation. Inf. Comput. 183, 19-42.
BERGER, U., AND SCHWICHTENBERG, H. 1991. An inverse of the evaluation functional for typed \Lambda -

calculus. In Proceedings of the 6th Annual Symposium on Logic in Computer Science. IEEE Computer
Society Press, Los Alamitos, CA, 203-211.
CHENEY, J. 2004. Nominal logic programming. Ph.D. dissertation, Cornell University.
CHURCH, A. 1940. A formulation of the simple theory of types. J. Symb. Logic 5, 56-68.
DE BRUIJN, N. G. 1972. Lambda calculus notation with nameless dummies, a tool for automatic formula

manipulation, with application to the Church-Rosser theorem. Indag. Math. 34, 381-392.
DYBJER, P. 2000. A general formulation of simultaneous inductive-recursive definitions in type theory.J. Symb. Logic 65

, 2.
DYBJER, P., AND FILINSKI, A. 2002. Normalization and partial evaluation. In Applied Semantics, Ad-vanced Lectures

, G. Barthe, P. Dybjer, and J. Saraiva, Eds. Lecture Notes in Computer Science, Tutorial,
vol. 2395. Springer-Verlag, New York, 137-192. (International Summer School, APPSEM 2000, Caminha, Portugal, September 9-15, 2000).
FIORE, M. P. 2002. Semantic analysis of normalisation by evaluation for typed lambda calculus. In Pro-ceedings of the 4th International ACM SIGPLAN Conference on Principles and Practice of Declarative

Programming (PPDP 2002), (Pittsburgh, PA), ACM, New York, 26-37.
FIORE, M. P., PLOTKIN, G. D., AND TURI, D. 1999. Abstract syntax and variable binding. In Proceedings ofthe 14th Annual Symposium on Logic in Computer Science

. IEEE Computer Society Press, Los Alamitos,
CA, 193-202.
GABBAY, M. J. 2000. A theory of inductive definitions with \Theta -equivalence: Semantics, implementation,

programming language. Ph.D. dissertation, University of Cambridge.
GABBAY, M. J. 2002. FM-HOL, a higher-order theory of names. In Workshop on Thirty Five years ofAutomath, Informal Proceedings

, F. Kamareddine, ed. Heriot-Watt University, Edinburgh, Scotland.
GABBAY, M. J. 2006. A general mathematics of names in syntax. Math. Struct. Comput. Sci. to appear.
GABBAY, M. J., AND PITTS, A. M. 2002. A new approach to abstract syntax with variable binding. Form.Asp. Comput. 13

, 341-363.
GORDON, A. D., AND MELHAM, T. 1996. Five axioms of alpha-conversion. In Theorem Proving in HigherOrder Logics, 9th International Conference

. Lecture Notes in Computer Science, vol. 1125. SpringerVerlag, New York, 173-191.
GRIFFIN, T. G. 1988. Notational definition--A formal account. In Proceedings of the 3rd Annual Sym-posium on Logic in Computer Science

. IEEE Computer Society Press, 372-383.
GUNTER, C. A. 1992. Semantics of programming languages: Structures and techniques, Los Alamitos,

CA. Foundations of Computing. MIT Press, Cambridge, MA.
HONSELL, F., MICULAN, M., AND SCAGNETTO, I. 2001. An axiomatic approach to metareasoning on

nominal algebras in HOAS. In Proceedings of the 28th International Colloquium on Automata, Languagesand Programming (ICALP 2001)

, Crete, Greece, July. F. Orejas, P. G. Spirakis, and J. Leeuwen, Eds.
Lecture Notes in Computer Science, vol. 2076. Springer-Verlag, New York, 963-978.
JECH, T. J. 1977. About the axiom of choice. In Hand book of Mathematical Logic. J. Barwise, ed.

North-Holland, Amsterdam, The Netherlands, 345-370
NORRISH, M. 2004. Recursive function definition for types with binders. In Theorem Proving in HigherOrder Logics, 17th International Conference

. Lecture Notes in Computer Science, vol. 3223. SpringerVerlag, New York, 241-256.
PFENNING, F., AND ELLIOTT, C. 1988. Higher-order abstract syntax. In Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation

. ACM, New York, 199-
208.
PITTS, A. M. 2003. Nominal logic, a first order theory of names and binding. Inf. Comput. 186, 165-193.
PITTS, A. M. 2005. Alpha-structural recursion and induction (extended abstract). In Theorem Provingin Higher Order Logics, 18th International Conference (TPHOLs 2005)

, Oxford UK, Aug. J. Hurd and
T. Melham, Eds. Lecture Notes in Computer Science, vol. 3603. Springer-Verlag, New York, 17-34.
PLOTKIN, G. D. 1990. An illative theory of relations. In Situation Theory and its Applications, Volume1

, R. Cooper, Mukai, and J. Perry, Eds. CSLI Lecture Notes, vol. 22. Stanford Univ., Stanford, CA,
133-146.

506 ANDREW M. PITTS
PLOTKIN, G. D. 2004. A structural approach to operational semantics. J. Logic Algeb. Prog. 60-61,

17-139.
POTTIER, F. 2005. An overview of C\Theta ml. In Proceedings of the ACM SIGPLAN Workshop on ML (Tallinn,

Estonia). ACM, New York.
SANGIORGI, D., AND WALKER, D. 2001. The \Phi -calculus: A Theory of Mobile Processes. Cambridge

University Press, Cambridge, UK.
SCH"OPP, U. 2006. Names and binding in type theory. Ph.D. dissertation, University of Edinburgh.
SCH"OPP, U., AND STARK, I. D. B. 2004. A dependent type theory with names and binding. In Proceedingsof the Symposium on Computer Science Logic (CSL04)

, (Karpacz, Poland). Lecture Notes in Computer
Science, vol. 3210. Springer-Verlag, New York, 235-249.
SHINWELL, M. R., AND PITTS, A. M. 2005. On a monadic semantics for freshness. Theoret. Comput.Sci. 342

, 28-55.
STOUGHTON, A. 1988. Substitution revisited. Theoret. Comput. Sci. 59, 317-325.
URBAN, C., PITTS, A. M., AND GABBAY, M. J. 2004. Nominal unification. Theoret. Comput. Sci. 323,

473-497.
URBAN, C., AND TASSON, C. 2005. Nominal techniques in Isabelle/HOL. In Proceedings of the 20thInternational Conference on Automated Deduction (CADE-20)

, (Tallinn, Estonia, July). Lecture Notes
in Computer Science, vol. 3632. Springer-Verlag, New York, 38-53.

RECEIVED SEPTEMBER 2005; REVISED MARCH 2006; ACCEPTED APRIL 2006

Journal of the ACM, Vol. 53, No. 3, May 2006.