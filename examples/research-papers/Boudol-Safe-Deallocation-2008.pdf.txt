

Typing Safe Deallocation

G'erard Boudol
INRIA, 06902 Sophia Antipolis, France

Abstract. In this work we address the problem of proving, by static
analysis means, that allocating and deallocating regions in the store provides a safe way to achieve memory management. That is, the goal is to
provably ensure that a program does not use pointers into a deallocated
region. A well-known approach to this problem is the one of Tofte and
Talpin. Our first contribution is to provide a simple proof, by means of a
subject reduction property, of type safety for their region calculus. Our
second, main contribution is that we actually do this for an extension
of Tofte-Talpin's calculus, featuring a primitive construct for deallocating regions, similar to C's free, that allows one to circumvent the strict
stack-of-regions discipline enforced in Tofte-Talpin's calculus. Our static
analysis consists in a novel type and effect system, extending the one of
Tofte and Talpin, where we record deallocation effects.

1 Introduction
Some years ago, Tofte and Talpin [15, 16] proposed a new memory model forhigher-order, typed languages, as an alternative to explicit allocation/deallocation
of memory (e.g. malloc/free in C) and garbage collection. The main idea is tointroduce, in an intermediate language for the compilation process, a blockstructured (letregion ae in e) construct, allocating a new region in the memory forthe evaluation of

e, and deallocating it upon termination. 1 Experience has shownthat, as reported in [17], introducing region management in this way allows the

compiler to produce code for ML programs that executes quite efficiently, evenwithout the support of a garbage collector. Moreover, memory management with
regions is provably safe, and this is one of the most remarkable achievements ofTofte and Talpin's approach.

The safety proof is not so easy, however. The original proof in [16] useda quite elaborate coinductive technique. A number of research works have been
done since then on this topic [2, 4-6, 8, 11, 18], in order to better understand whythe apparently simple typing of the

letregion construct is actually safe, and toget a simpler proof. Indeed, this construct allows for reusing a dead region, even

though there are still pointers in that region in the code, thus creating dangling

1 This idea was previously mentioned in [14]: "Since the locations belonging to a

private region cannot be accessed after the expression returns, they can be safely
deallocated when the expression returns." However, the semantics given in this paper
did not involve deallocation, and this statement was not proved.

pointers. Moreover, the same pointers can also be subsequently reused, holdingvalues of a different type. The difficulty is then to prove that the pointers in the
code that actually refer to defunct regions are guaranteed by typing to never beused. The syntactic proof of [5], following the standard steps of a type safety
proof (see [20]), seems to be adopted as the classical one by now (see [13]). Itformalizes deallocation as the substitution of a dead region * for the deallocated
region everywhere in the current configuration, including in the values stored inthe memory. In [5] it is shown that this semantics is bisimilar to the original one
of [16]. However, using an explicit notion (*) of a deallocated region modifies (andoverloads) the semantics of the

letregion construct, with a rewriting phase thatis not present in the original formulation, and therefore a truly direct, syntactic

proof of type safety for Tofte-Talpin's region calculus is yet to be done. Our firstcontribution is to give a fresh look at this problem.

To prove that region deallocation is safe, we have to ensure that when a regionis deallocated, it should not be used by the rest of the computation (i.e. the
evaluation context). This is done in [16] by means of a sophisticated consistencypredicate, supporting a coinductive proof technique. We shall do this here by
means of a type and effect system. The idea is very simple. First, we decomposethe (

letregion ae in e) construct of Tofte and Talpin as follows:

(letregion ae in e) = (new ae in (free after ae e))
where (new ae in e0) allocates a new region, with scope e0, and (free after ae e)deallocates the region

ae when the computation of e is terminated. Such a de-composition was introduced in [1].

2 Then we introduce a new kind of effects,

which we call negative effects, or deallocation effects, associated with the latterconstruct in the type system, and we check that there is no conflict with the

ordinary, "positive," or usage effects, in order to ensure that regions requiredin future computations are not deleted in the current computation. Typically,
assuming a left-to-right evaluation order, as in [16], the negative effect of e0 in(

e0e1) should not intersect the positive effect of e1, in order for the applicationto be typable. With this refined (flow-sensitive) effect system, which directly

extends the one of [16], we are able to show the safety of region deallocation, bymeans of a Subject Reduction argument, as explained below (Section 4).

The idea of using explicit deallocation effects suggests that we could furtherdecompose the (

letregion ae in e) construct of Tofte and Talpin, introducing anexplicit, atomic instruction for region deallocation. We write this as (

dispose ae),and we define

(free after ae e) = (let x = e in (dispose ae) ; x)
(see [19] for a similar decomposition). Quite obviously, the deallocation effectsare introduced by the

dispose instruction, and our proof of type safety actuallydeals with the refined region calculus, where the

letregion construct is replacedby
new and dispose. The latter, which could also be defined in terms of free after

2 In [1], the allocation operation is also separated from the creation of a new name.

We shall comment on this below. The free after construct is denoted (region ae in e)
in [5]. An analogous expression (*private* ae e) was used in [14], though with different
semantics.

and termination (), was considered, in various concrete syntactic forms, in anumber of papers: it is denoted

freerg in [8, 18], deleteregion in [9, 10] and releasein [12] (with different semantics), and

free in [19]. One reason for using such anexplicit region deallocation construct is that, as noted very early in [1, 3], the

strict stack discipline enforced in Tofte and Talpin's calculus is too constrainingto cope with situations where it would be much more efficient to reclaim a region
without waiting for the end of its lexical scope. It is then natural to use suchan explicit deallocation construct, for optimization purposes, but the problem
of ensuring that this operation is safe comes out again, and it is a difficult one.A specific difficulty, noted in [1], is that "for correctness it is important that
a region be allocated only once and deallocated only once during its lifetime."The "allocated-only-once" is a built-in feature of the (

new ae in e) construct, butregarding deallocation, it seems appropriate to use ideas from linear logic, and

this is indeed what is done in a number of works, see for instance [7, 8, 18, 19].However, as we show below, resorting to linear logic techniques is not a necessity. Indeed, introducing deallocation effects makes it very easy to control the"deallocated-only-once" feature in our flow-sensitive effect system: it is enough
to ensure that a region occurring in the deallocation effect of a subexpression isnot in the (negative) effect of the rest of the computation. Our static analysis for
provably ensuring the safety of explicit region deallocation is then much simplerthan previously given ones.

The paper is organized as follows: in a first section, we introduce our extendedregion calculus, and describe its operational semantics. In a next section, we
introduce our type and effect system, featuring the notion of a deallocationeffect. We then establish a Subject Reduction property up to region renaming,
and derive from it our Type Safety result. A brief conclusion is given. For lackof space, most of the proofs are omitted.

2 The extended region calculus
In this section we introduce our region calculus, extending the one of Tofteand Talpin with an explicit primitive construct for deallocating regions, and we
describe its operational semantics. We assume given two disjoint denumerablesets RegVar and RegCst of region variables and region constants, respectively
ranged over by ae and r. The set Reg = RegVar [ RegCst of region names,is ranged over by

%. We also assume given a denumerable set Loc of memorylocations, or pointers, range over by

p, q . . ., and a denumerable set Var ofvariables, ranged over by
x, y, . . . f, g . . .. The syntax is as follows:

a := (r, p) addresses

v ::= () | a values
w ::= *xe storable values

e ::= x | v | (w @ %) | (e0e1) | (let x = e0 in e1) expressions|

(new ae in e) | (dispose %)

The expression (w @ %), pronounced "w at %" in [16], is meant to create a newpointer in region

% with contents w. As usual, the variable x is bound in *xe,

and ae is bound in (new ae in e), whereas it is free in (w @ ae) and (dispose ae).We denote by

reg(e) the set of region constants and region variables that occur(free) in
e, and by ref(e) the set of addresses occurring in e. The expression e issaid to be closed if no variable or region variable occurs free in it. We denote by

{x 7!v}e and {ae 7!%}e the capture-avoiding substitutions of values and regionnames in

e. We shall consider expressions up to ff-conversion, that is up to therenaming of bound variables and regions. We use the notation (

*xe1e0), that is(
we0) where w = *xe1, as a synonym of (let x = e0 in e1), and we also write thisas

e0 ; e1 whenever x is not free in e1.In a more realistic language, there would be more (storable) values, like

booleans, integers, pairs, and so on, with appropriate constructs to use thesevalues, like conditional branching, etc. We regard the region calculus of Tofte
and Talpin [16] as a sub-language, where (new ae in e) and (dispose %) are replacedby (

letregion ae in e), with

(letregion ae in e) =def (new ae in (free after ae e)) where

(free after % e) =def (let x = e in (dispose %) ; x)

as explained in the Introduction.In order to show our safety result, we use a small-step semantics for the

language. The evaluation of an expression consists, as usual, in reducing a redexinside an evaluation context, in the context of a store. The redexes and evaluation
contexts are as follows:

u ::= (w @ r) | (av) | (*xev) redexes|

(new ae in e) | (dispose r)
E ::= [] | E[F] evaluation contexts

F := ([] e) | (a []) | (*xe []) frames

Definition (Stuck Expressions) 2.1. An expression e is stuck if and only
if e = E[e0] where e0 is either a variable, or (w @ ae), or (()e0), or (dispose ae).

Notice that a closed stuck expression has the form E[(()e)]. The following is astandard fact:

Lemma 2.2. For any expression e, either
(i) e is a value, or
(ii) e is a stuck expression, or
(iii) there exist an evaluation context E and a redex u such that e = E[u].
As in [16], a store s is a mapping from a finite set dom(s) of region constantsto regions, where a region is a mapping from a finite set of locations to storable

values. We denote by Dom(s) the set { (r, p) | r 2 dom(s) & p 2 dom(s(r)) }, andwe write

s(r, p) for s(r)(p) where (r, p) 2 Dom(s). We define, for R ` Reg and
r 2 RegCst:

dom(s _ R) = R " dom(s)

r 2 dom(s _ R) ) (s _ R)(r) = s(r)

s\r = s _ (dom(s) - {r})

We shall in fact use the notations f _ X and f \x for any partial function f :
A * B, with x 2 A and X ` A.

(s, E[(w @ r)]) ! (s + {(r, p) 7!w}, E[(r, p)]) r 2 dom(s),

p 62 dom(s(r))

(s, E[((r, p)v)]) ! (s, E[(wv)]) r 2 dom(s),

p 2 dom(s(r)),
s(r, p) = w

(s, E[(*xev)]) ! (s, E[{x 7!v}e])
(s, E[(new ae in e)]) ! (s + {r 7!;}, E[{ae 7!r}e]) r 62 dom(s)

(s, E[(dispose r)]) ! (s\r, E[()])

Figure 1: Reduction

In the operational semantics, we use the notations of [16] for extending orupdating the store with new regions, namely

s + {r 7!;} and s + {(r, p) 7!w}.The reduction relation consists in a transition relation between configurations,

that are pairs (s, e) of a store and an expression to evaluate. This is defined inFigure 1. The evaluation of an application (

e0e1) is standard. We neverthelessexamine the various steps in details, since our typing will rely on these: first, one

computes the function e0 until an address a is obtained, possibly by reducingan expression (

w @ r). Next, the argument e1 is computed, producing a value
v. Then, to evaluate the resulting expression (av), a read operation occurs, re-turning the value contained in the store at address

a. This value should be afunction
*xe, and we now have to evaluate (let x = v in e), as usual, that is: thevalue
v is bound to x, and finally one proceeds evaluating {x 7!v}e. Regardingthe construct (

new ae in e), evaluating it consists in allocating a new region con-stant
r in the store, which is bound to ae in e for the rest of the computation, 3while evaluating (

dispose r) deallocates the region named r from the store andterminates. Then one can check that the (

letregion ae in e) construct has thesame semantics as in [16]. Notice in particular that in allocating a new region,

reducing (new ae in e), we do not require that the new name does not occur in
e, nor in the evaluation context E, nor in some value currently recorded in thestore. Then one can reuse a region name that still occurs in the configuration,

with the only proviso that the name is not in the domain of the current store.

3 The type and effect system
3.1 Effects, types, judgements and rules
Our main technical novelty in this work consists, as explained in the Introduc-tion, in refining the notion of an effect, introducing negative, deallocation effects

that are distinct from the usual "positive" effects of creating, reading or updatinga region. In this work, it will be unnecessary to distinguish various kinds of positive effects. Then an effect here is a pair ' = ('+, '-) of a positive effect '+ anda negative effect

'-, which both are finite sets of region names. The standardset-theoretic notions, like inclusion, union, etc. are extended componentwise to

3 For simplicity, we use region substitution {ae 7!r}e instead of a region environment.

\Sigma ; \Gamma , x : o/ ` x : ;, o/ \Sigma ; \Gamma  ` () : ;, 1l \Sigma , (r, p) : i; \Gamma  ` (r, p) : ;, ir

\Sigma ; \Gamma , x : o/ ` e : ', oe

\Sigma ; \Gamma  ` *xe : (o/ '-! oe)

\Sigma ; \Gamma  ` w : i
\Sigma ; \Gamma  ` (w @ %) : ({%}, ;), i%
\Sigma ; \Gamma  ` e0 : '0, (o/ '2--! oe)% \Sigma ; \Gamma  ` e1 : '1, o/

\Sigma ; \Gamma  ` (e0e1) : ('0 + %) [ '1 [ '2, oe (

'-0 " ({%} [ '+-1 [ '+-2 ) = ;
'-1 " ({%} [ '+-2 ) = ;

\Sigma ; \Gamma  ` e0 : '0, o/ \Sigma ; \Gamma , x : o/ ` e1 : '1, oe

\Sigma ; \Gamma  ` (let x = e0 in e1) : '0 [ '1, oe

'-0 " '+-1 = ;

\Sigma ; \Gamma  ` e : ', o/
\Sigma ; \Gamma  ` (new ae in e) : '\ae, o/

ae 62 \Sigma , \Gamma , o/

\Sigma ; \Gamma  ` (dispose %) : (;, {%}), 1l

Figure 2: The type and effect system: expressions

effects. In the following we write '+- for '+ [ '-, ' + % for ' [ ({%}, ;), and '\%for

' - ({%}, {%}). The types are standard:

o/, oe . . . ::= t | 1l | i% types

i ::= (o/ '-! oe) storable value types

The type 1l is also often denoted unit. As in [16], (o/ '-! oe)% is the type of addresses
in region % of the store where one finds a functional value of type (o/ '-! oe). Asusual, a functional type records the latent effect

' a function of this type mayhave when applied to an argument.

There are two kinds of judgments in our type and effect system. A judgment
\Sigma ; \Gamma  ` e : ', o/ means that under the assumptions \Sigma  and \Gamma  , the expression e isanticipated to have an effect

', and has type o/ . Similarly, a judgment \Sigma ; \Gamma  ` w :
i means that, under the assumptions \Sigma  and \Gamma  , the storable value w has type
i (and no effect, since this is a value). The component \Sigma  in these judgments isthe region typing context, which maps a finite set

dom(\Sigma ) of region constants toregion typings, where a region typing is a map from a finite set of locations to

types of storable values. The set { (r, p) | r2dom(\Sigma ) & p2dom(\Sigma (r)) } is denoted
Dom(\Sigma ), and a region typing context is written (r1, p1) : i1, . . . , (rm, pm) : im.The

\Gamma  component is, as usual, a typing context, mapping a finite set of variablesto types. In the typing rule for (

new ae in e), we write ae 62 \Sigma , \Gamma , o/ to mean thatthe variable
ae does not occur in \Sigma , \Gamma  (that is, in the types assigned by thesetyping contexts) and

o/.The rules of the type and effect system are given in Figure 2, which we now

comment. First we point out that the negative effects are, as expected, intro-duced when typing an expression (

dispose %), while a positive effect results froma storing operation (
w @ %) and reading a (functional) value from the store, in anapplication. Our effect system then checks that a subexpression does not deallocate a region in which some future effect is anticipated. In our core language,where we adopt a left-to-right evaluation order, the only subexpressions that

have a "future" are e0 in (e0e1) and (let x = e0 in e1), and e1 in (e0e1), wherein the latter case, the effects that may arise after evaluating

e1 are the effect ofreading the function from the store (at address
e0), and the latent effect of thatfunction. Then in typing the application (
e0e1), we have the constraint that theregion in which the value resulting from evaluating

e0 is stored should not bedisposed of before the actual reading operation occurs, that is

% 62 ('-0 [ '-1 ).Similarly,
e0 should not have the effect of removing regions that may be usedin the rest of the computation, that is

'-0 " '+-1 = ; = '-0 " '+-2 , and finally,
e1 should not delete regions occurring in the latent effect of the function, thatis

'-1 " '+-2 = ;. The constraint in typing a (let x = e0 in e1) is similar. Theseconstraints mean in particular that one cannot deallocate twice the same region.

Indeed, in our calculus where allocating (via new) and deallocating (via dispose)a region are not restricted to follow the strict block-structured discipline of [16],
it would be generally unsafe (and not very useful) to deallocate several timesthe same region. For instance, evaluating an expression of the form

(new ae0 * * * dispose ae0 * * * (new ae1 * * * dispose ae0 * * * (w @ ae1) * * * ))
could result in assigning to ae1 the same region r that has been assigned to ae0,since

r has been disposed of, but then the second instruction (dispose ae0) has theeffect of deleting the region associated with

ae1, and the evaluation of (w @ ae1)then fails in this case. In the rule for (
new ae in e), we could require ae 2 '-,in order to ensure that the region assigned to

ae has been disposed of when theevaluation exits its scope, but this would be just an indication, because the effects

anticipated by typing are not guaranteed to occur (though it is guaranteed thatno other effect can possibly occur).

Regarding the derived constructs that are involved in the Tofte and Talpin'ssub-calculus, one can see that a derived typing rule is

\Sigma ; \Gamma  ` e : ', o/
\Sigma ; \Gamma  ` (free after % e) : ' [ (;, {%}), o/

% 62 '-

and consequently

\Sigma ; \Gamma  ` e : ', o/

\Sigma ; \Gamma  ` (letregion ae in e) : '\ae, o/

ae 62 \Sigma , \Gamma , o/, '-

One may then observe that in typing expressions of the derived sub-calculus thenegative effect is always empty, and conclude that, up to the identification of
('+, ;) with the single effect '+, what we get is exactly the usual typing forTofte and Talpin's region calculus, without any constraint on the effect.

Now let us see an example of a typable expression, inspired from examples in[1, 18]. Let

w be a typable storable value, e a typable expression using (via thevariable
x) this value from region ae (and possibly having other positive effectsin this region), and let

e0 be a typable expression that has no effect in region ae.Then the following is typable:

new ae in let x = (w @ ae) in
new ae0 in let f = (*x(let y = (free after ae e) in e0) @ ae0) in
(free after ae0 (fx))

This example shows, first, that regions may have arbitrarily overlapping extent[1]: here the evaluation will execute the sequence

new ae * * * new ae0 * * * dispose ae * * * dispose ae0
Second, in the code for the function f, the region constant assigned to ae canbe disposed of without waiting for the call (

f x) to end, since this region is onlyused in a first part of the computation of (
f x). As another example, one can seethat with a conditional branching construct, typed as follows:

\Sigma ; \Gamma  ` e : ', bool \Sigma ; \Gamma  ` ei : 'i, o/
\Sigma ; \Gamma  ` (if e then e0 else e1) : ' [ '0 [ '1, o/

'- " ('+-0 [ '+-1 ) = ;

then if a branch does not use region %, one can immediately dispose of it, whilein the other branch this action is deferred after the use of values in that region.
(As above with the new construct, we could additionally require '-0 = '-1 inthis rule.)

To show the type safety result, we have to extend the typing to configura-tions. In order to type the store, one should have enough assumptions in the
region typing context: any address in the store should be the subject of a typingassumption. Moreover, the value stored at some address should have type as prescribed by the region typing context. Finally, for a configuration to be typable,we shall require a "well-formedness" property, asserting that any region in which
the computation may have an effect should be allocated in the store. Indeed, itis essential for safety to preserve the property that accesses to the memory never
fail. Our definition is therefore as follows:
Definition (Typing Configurations) 3.1.

(i) \Sigma ; \Gamma  ` s ,def ( Dom(s) ` Dom(\Sigma )(r, p) 2 Dom(s) ) \Sigma ; \Gamma  ` s(r, p) : \Sigma (r, p)

(ii) \Sigma ; \Gamma  ` (s, e) : ', o/ ,def 8?!?:

\Sigma ; \Gamma  ` s & \Sigma ; \Gamma  ` e : ', o/

8r. r 2 '+- ) ae r 2 dom(s) &dom(\Sigma (r)) ` dom(s(r))

3.2 Some properties
We notice a few facts that will be used in our proof of type safety. First, thetype and effect system reflects the fact that a value has no effect:

Remark 3.2. \Sigma ; \Gamma  ` v : ', o/ ) ' = ;
Second, some errors are, as usual, statically precluded by typing:
Remark 3.3. A closed stuck expression is not typable.
Finally, one can show some standard properties relating typing and substitution:

Lemma (Substitution) 3.4.
(i) \Sigma ; \Gamma  ` v : , o/ & \Sigma ; \Gamma , x : o/ ` e : ', oe ) \Sigma ; \Gamma  ` {x 7!v}e : ', oe

\Sigma ; \Gamma  ` [] : (o/ ;-! o/)

\Sigma ; \Gamma  ` E : (` '1--! oe) \Sigma ; \Gamma  ` F : (o/ '0--! `)

\Sigma ; \Gamma  ` E[F] : (o/ '0['1----! oe)

'-0 " '+-1 = ;

\Sigma ; \Gamma  ` e : '0, o/
\Sigma ; \Gamma  ` ([]e) : ((o/ '1--! oe)% ('0+%)['1-------! oe)

'-0 " ({%} [ '+-1 ) = ;

\Sigma , (r, p) : (o/ '-! oe); \Gamma  ` ((r, p) []) : (o/ '+r---! oe)

\Sigma ; \Gamma , x : o/ ` e : ', oe
\Sigma ; \Gamma  ` (*xe []) : (o/ '-! oe)
Figure 3: The type and effect system: evaluation contexts

(ii) If \Sigma ; \Gamma  ` e : ', o/ and r does not occur in \Sigma ; \Gamma  ` e : ', o/ then {ae 7!r}(\Sigma ; \Gamma  `
e : ', o/).

For the proof of our main result, it will be convenient to decompose the typingof an expression of the form E[

e] into a typing of e and a typing of the evaluationcontext. (An alternative is to use a "Replacement Lemma", see [20] for instance.)

The type system for evaluation contexts allows one to infer judgments of the form
\Sigma ; \Gamma  ` E : (o/ '-! oe), meaning that if the context is filled with an expression oftype

o/ , then it will return a result of type oe, while producing effects as indicatedby
'. There are constraints regarding the effects similar to the ones that hold forexpressions. The rules are given in Figure 3. Then we introduce an alternative

way to type expressions, by means of judgments of the form \Sigma ; \Gamma  fl e : ', o/ ,established as follows:

\Sigma ; \Gamma  ` e : '0, o/ \Sigma ; \Gamma  ` E : (o/ '1--! oe)

\Sigma ; \Gamma  fl E[e] : '0 [ '1, oe

'-0 " '+-1 = ;

We can prove that this provides us with just an equivalent way of typing:
Lemma 3.5.
(i) \Sigma ; \Gamma  fl e : ', o/ ) \Sigma ; \Gamma  ` e : ', o/
(ii) If \Sigma ; \Gamma  ` E[e] : ', o/ then there exist '0, '1 and oe such that \Sigma ; \Gamma  ` e : '0, oe
and \Sigma ; \Gamma  ` E : (oe '1-! o/ ) with ' = '0 [ '1 and '-0 " '+-1 = ;.

4 Type safety
A technical difficulty in showing the soundness of typing deallocation is thatthere is a discrepancy between the operational semantics and typing as regards
the generation of new regions. More specifically, to establish Subject Reductionwould require that the fresh name generated when reducing (

new ae in e) be asfresh as possible, and in particular, that it does not occur in the expression

e,in order for the substitution of the new name to yield a valid typing judgment.

On the opposite side, from the operational point of view, it could be beneficial,and therefore allowed (as it is), to reuse a name that has been disposed of, even

though it could still occur in the expression e, in a dead pointer to a deallo-cated region for instance. Our way to reconcile the typing with the operational
semantics is to establish a Subject Reduction property up to simulation (wherea "simulation" is half a bisimulation - but we do not need any coinductive machinery). The idea is actually very simple: it is to show that, to preserve thetyping along a given computation, one may have to, not exactly follow, but simulate the actual computation by just making "better" (from the typing point ofview) choices of new region names and pointers, while still maintaining a tight
correspondence with the given computation, by means of a region and pointerrenaming. Safety will then result from the fact that the use of dangling pointers
is precluded by typing, cf. Definition 3.1(ii).

4.1 The simulation relation
We introduce a relation over configurations (s, e), that will be proved to bea simulation. More precisely our simulation relates (

s, e) to (s0, e0) by meansof a translation t, in such a way that, if (
s, e) is typable and (s0, e0) performsa transition, then one can choose regions and pointers so that (

s, e) performs asimilar transition, resulting in similar configurations, while preserving typability.

The translation, relating region constants to regions constants, and pointersto pointers, may evolve along the transitions, either because a new pointer is
created, or because a region constant is created, or reused.
Definition (Translations) 4.1. A translation t is a pair (r, p) where
(i) r is a mapping from a finite subset dom(r) of RegCst to RegCst,
(ii) p is a function with the same domain as r, such that, for any r 2 dom(r),

p(r) is an injective mapping from a finite subset dom(p(r)) of Loc to Loc.

We denote by T the set of translations. We also write p(r) as pr. We extend theinclusion relation to translations, as follows:

(r, p) ` (r0, p0) ,def ( r ` r

0 &

r 2 dom(r) ) pr ` p0r
For each translation t = (r, p), we define the partial mapping hti on expressionsand storable values, by induction on the structure, as follows - omitting the
cases where the translation just goes through the structure of the expression:

hti(r, p) = (r(r), pr(p)) if r 2 dom(r) & p 2 dom(pr)h
ti(w @ r) = (htiw @ r(r)) if r 2 dom(r)h
ti(dispose r) = (dispose r(r)) if r 2 dom(r)

We write:

e Bt e0 ,def e 2 dom(hti) & e0 = hti(e)

The syntactic structure of e0 is identical to the one of e whenever e Bt e0: theexpression

e0 is obtained from e by renaming region constants and pointers. Thefollowing should be obvious:

Remarks 4.2.
(i) For any expression e, if we let te = (r, p) where r = { (r, r) | r 2 reg(e) } andp

r = { (p, p) | (r, p) 2 ref(e) } for r 2 reg(e), then te 2 T and e Bte e.
(ii) If e 2 dom(hti) then htie is a value (resp. a redex, resp. a stuck expression)
if and only if e is a value (resp. a redex, resp. a stuck expression).

(iii) If e Bt e0 and t ` t0 then e Bt0 e0.
The relation Bt is compatible with substitution:
Lemma 4.3.
(i) v Bt v0 & e Bt e0 ) {x 7!v}e Bt {x 7!v0}e0
(ii) r 2 dom(r) & e Br,p e0 ) {ae 7!r}e Br,p {ae 7!r(r)}e0.
We define what it means for a translation t to comply with an effect, whichintuitively means that the translation does not confuse the region constants

involved in the effect:
Definition 4.4. A translation t = (r, p) complies with the effect ', in notation
t / ' if and only if '+- " RegCst ` dom(r) and r _ '+- is injective.

Clearly

t / ' &  ` ' ) t /  (1)

Our simulation on configurations is indexed by a translation t and an effect '.We first define the relation B

'
t on stores, as follows:

Definition 4.5. Let t = (r, p) be a translation and ' an effect such that t / '.
Then s B't s0, read "s simulates s0 up to ' modulo t," if and only if

(i) r('+-) ` dom(s0)

(ii) r 2 '+ & (r, p) Bt (r0, p0) ) ( (r, p) 2 Dom(s) , (r

0, p0) 2 Dom(s0)

(r, p) 2 Dom(s) ) s(r, p) Bt s0(r0, p0)
It should be obvious that

s B't s0 &  ` ' ) s Bt s0 (2)
Then we define

(s, e) B't (s0, e0) ,def s B't s0 & e Bt e0

4.2 Main result
Now we show the Subject Reduction property suggested above: if (s0, e0) is ty-pable, and simulates (

s1, e1), and if the latter performs a transition to (s01, e01)then there is a choice of regions and a typable configuration (

s00, e00) which sim-ulates (modulo the updated region translation) (
s01, e01), and is the result of thecorresponding transition from (
s0, e0). This property can be drawn:

(s1, e1) -!-!-! (s01, e01)a a

\Sigma ; \Gamma  ` (s0, e0) : ', o/ 99K \Sigma 0; \Gamma  ` (s00, e00) : , o/

Lemma (Subject Reduction up to Simulation) 4.6.
If \Sigma ; \Gamma  ` (s0, e0) : ', o/ and (s1, e1) ! (s01, e01) with (s0, e0) B't (s1, e1) then there
exist s00, e00, \Sigma 0 and  such that (s0, e0) ! (s00, e00) and \Sigma 0; \Gamma  ` (s00, e00) : , o/

with (s00, e00) Bt0 (s01, e01) for some t0 2 T .

Proof: by case on the transition (s1, e1) ! (s01, e01).*

(s1, E1[(w0 @ r0)]) ! (s1 + {(r0, p0) 7!w0}, E1[(r0, p0)]) with r0 2 dom(s1) and
p0 62 dom(s1(r0)). We have e0 = E0[(w @ r)] with r2dom(r), r0 = r(r) and wBtw0.By Lemma 3.5(ii), there exist

'0, '1 and oe such that \Sigma ; \Gamma  ` (w @ r) : '0, oe and

\Sigma ; \Gamma  ` E0 : (oe '1-! o/ ) with ' = '0 [ '1 and '-0 " '+-1 = ;. Then oe = ir with
\Sigma ; \Gamma  ` w : i, and '0 = ({r}, ;). We have r 2 '+, and therefore r 2 dom(s0) byDefinition 3.1(ii). We distinguish two cases.

(a) If there exists p such that pr(p) = p0, that is (r, p) Bt (r0, p0) then p 62
dom(s0(r)) by Definition 4.5(ii), and therefore

(s0, e0) ! (s00, e00) where ( s

00 = s0 + {(r, p) 7!*xe}

e00 = E0[(r, p)]

Since r 2 '+ and (r, p) 62 Dom(s0) we have, by Definition 3.1(ii), (r, p) 62
Dom(\Sigma ), and \Sigma , (r, p) : i; \Gamma  ` (r, p) : ;, ir. Then \Sigma , (r, p) : i; \Gamma  ` (s00, e00) : '1, o/by Lemma 3.5(i) and

'1 ` '. Then obviously t / '1 (see (1) above), and

r('+-1 ) ` r('+-) ` dom(s1) = dom(s01)
by Definition 4.5(i). If r00 2 '+1 and (r00, p00) Bt (r0, p0) then r00 = r since r _ '+- isinjective, and

p00 = p since pr is injective, hence (r00, p00) 2 Dom(s00). From thiswe easily conclude (

s00, e00) B'1t (s01, e01).

(b) Otherwise, that is if there is no p 2 dom(pr) such that pr(p) = p0, let pbe such that (

r, p) 62 Dom(\Sigma ). Then (r, p) 62 Dom(s0) by Definition 3.1(i), andtherefore

(s0, e0) ! (s00, e00) where ( s

00 = s0 + {(r, p) 7!*xe}

e00 = E0[(r, p)]
Since \Sigma , (r, p) : i; \Gamma  ` (r, p) : ;, ir we have \Sigma , (r, p) : i; \Gamma  ` (s00, e00) : '1, o/by Lemma 3.5(i). Let t0 = (r

, p0) where p0 = p + {(r, p) 7!(r0, p0)}. Then p0r isinjective, and since
'1 ` ' we have t0 / '1 (see (1) above) and r('+-1 ) ` r('+-) `
dom(s1) = dom(s01). There is no (r00, p00) such that r00 2'+1 and (r00, p00)Bt (r0, p0),since otherwise we would have

r00 = r, for r _ '+- is injective, by Definition 4.4,and this would contradict our assumption (b). From this it is easy to conclude

(s00, e00) B'1t0 (s01, e01), using Remark 4.2(iii).*

(s1, E1[((r0, p0)v0)]) ! (s1, E1[(w0v0)]) with r0 2 dom(s1), p0 2 dom(s1(r0)) and
s1(r0, p0) = w0. We have e0 = E0[((r, p)e2)] with (r, p) Bt (r0, p0) and e2 Bt v0,hence

e2 is a value v, by Remark 4.2(ii), and therefore ((r, p)e2) is a redex. ByLemma 3.5(ii) there exist

'0, '1 and oe such that \Sigma ; \Gamma  ` ((r, p)v) : '0, oe and

\Sigma ; \Gamma  ` E0 : (oe '1-! o/ ) with '-0 " '+-1 = ; and ' = '0 [ '1. Then (r, p) 2 Dom(\Sigma )

with \Sigma (r, p) = (` 0--! oe)r and \Sigma ; \Gamma  ` v : 1, ` with '0 = (0 + r) [ 1. Since
r 2 '+, we have r 2 dom(s0) by Definition 3.1(ii), hence p 2 dom(s0(r)) and

s0(r, p) Bt s1(r0, p0) by Definition 4.5(ii), that is s0(r, p) = w with w Bt w0. Then
\Sigma ; \Gamma  ` w : (` 0--! oe) by Definition 3.1(i), and we have

(s0, e0) ! (s0, e00) where e00 = E0[(wv)]
By Lemma 3.5(i) we have \Sigma ; \Gamma  ` (s0, e0o) : , o/ where  = 0 [ 1 [ '1 ` ',
and it is obvious that t /  and (s0, e00) Bt (s1, e01) (see the remarks (1) and (2)above).

* (s1, E1[(*xe02v0)]) ! (s1, E1[{x 7!v0}e02]). In this case we use the SubstitutionLemma 3.4(i). The details are left to the reader.

* (s1, E1[(new ae in e02)]) ! (s1 + {r0 7!;}, E1[{ae 7!r0}e02]) with r0 62 dom(s1).We have

e0 = E0[(new ae in e2)] with e2 Bt e02, and there exist '0, '1 and oe such

that \Sigma ; \Gamma  ` (new ae in e2) : '0, oe and \Sigma ; \Gamma  ` E0 : (oe '1-! o/ ) with '-0 " '+-1 = ;and

' = '0 [ '1 by Lemma 3.5(ii). Let r be a fresh region constant, that doesnot occur in the statement

\Sigma ; \Gamma  ` (s0, e0) : ', o/ , nor in dom(r). In particular,
r 62 dom(s0), and therefore

(s0, e0) ! (s00, e00) where (

s00 = s0 + {r 7!;}

e00 = E0[{ae 7!r}e2]

We have \Sigma ; \Gamma  ` e2 : '00, oe with ae 62 \Sigma , \Gamma , o/ and '0 = '00\ae. Then by Lemma3.4(ii) we have

\Sigma ; \Gamma  ` {ae 7!r}e2 : {ae 7!r}'00, oe, hence \Sigma ; \Gamma  ` (s00, e00) : , o/by Lemma 3.5(i), where

'+- ` +- ` '+- [ {r}. Let t0 = (r0, p0) where r0 =r + {
r 7!r0} and p0 = p + {r 7!;}. If r00 2 dom(r) is such that r(r00) = r0 then
r00 62 +- by Definition 4.5(i) since r0 62 dom(s1), and therefore r0 _+- is injective,hence t0 /

. Clearly r0(+-) ` dom(s01), since r('+-) ` dom(s1) by Definition

4.5(i). It is then easy to conclude (s00, e00) Bt0 (s01, e01), using Lemma 4.3(ii).*

(s1, E1[(dispose r0)]) ! (s1\r0, E1[()]). We have e0 = E0[(dispose r)] with
r 2 dom(r) and r(r) = r0. Then

(s0, e0) ! (s00, e00) where ( s

00 = s0\r

e00 = E0[()]

and by Lemma 3.5(ii) there exist  and oe such that \Sigma ; \Gamma  ` E0 : (1l -! o/ ) with
r 62 +- and ' =  [ (;, {r}). Then we have \Sigma ; \Gamma  ` (s00, e00) : , o/ , thanks toLemma 3.5(i). We obviously have

t /  (see the remark (1) above). Assumethat
r00 2 +- is such that r(r00) = r0. Since r _ '+- is injective, we should thenhave

r00 = r, but this is impossible since r 62 +-. This shows r(+-) ` dom(s01).Now assume that

r00 2 + is such that (r00, p00) Bt (r0, p0). Then we should have
r00 = r since r _ '+- is injective, but this is impossible since r 62 +-. From thiswe easily conclude that

s00 Bt s01, and therefore (s00, e00) Bt (s01, e01).

We can now use this lemma to show that a typable closed expression does notrun into an error. We first define the erroneous configurations.

Definition (Faulty Configuration) 4.7. A configuration (s, e) is faulty if
either

(i) e is a stuck expression, that is E[e0] where e0 is either a variable, or (*xe0 @ ae),
or (()e0), or (dispose ae), or

(ii) e writes in a deallocated region, that is e = E[(w @ r)] with r 62 dom(s), or
(iii) e uses a dangling pointer, that is e = E[((r, p)v)] with (r, p) 62 Dom(s).
Then our main result is as follows:
Theorem (Type Safety) 4.8. If (s, e) is a closed, typable configuration, and
(s, e) *! (s0, e0), then the configuration (s0, e0) is not faulty.
Proof: first we notice that closedness is preserved by reduction. We have \Sigma ; \Gamma  `(

s, e) : ', o/ . Let R be a finite subset of RegCst which contains all the regionconstants involved in the judgment

\Sigma ; \Gamma  ` (s, e) : ', o/ (including the nameoccurring in values stored in
s, etc.). Let us define t = (r, p) as follows: r ={ (
r, r) | r 2 R } and, for r 2 R, pr maps any address (r, p) occurring in thejudgment

\Sigma ; \Gamma  ` (s, e) : ', o/ onto itself. Clearly t2T , eBt e (see Remarks 4.2(i)-(iii)), t /

' and s B't s since '+- ` dom(s) by Definition 3.1(ii), and therefore(
s, e) B't (s, e). Then by Lemma 4.6 there exist (s00, e00), \Sigma 0,  and t0 = (r0, p0)

such that (s, e) *! (s00, e00) with \Sigma 0; \Gamma  ` (s00, e00) : , o/ and (s00, e00)Bt0 (s0, e0), andin particular

eBt0 e0. Then by Remarks 3.3 and 4.2(ii), e0 is not a stuck expression.If
e0 = E0[(w0 @ r0)] then e00 = E[(w @ r)] with r0(r) = r0 and r 2 + by Lemma3.5(ii), and therefore

r 2 dom(s00) by Definition 3.1(ii), hence r0 2 dom(s0) byDefinition 4.5. If
e0 = E0[((r0, p0)e1)] then e00 = E[((r, p)e0)] with (r, p)Bt0 (r0, p0),and
r 2 + by Lemma 3.5(ii). We conclude as in the previous case.

Given a closed, typable expression e with effect ', which does not contain anymemory address, this result applies in particular to an initial configuration (

s, e)where
s = { r 7!; | r 2 reg(e) [ '+- }. (We conjecture that for such an expression,there exists a typing such that

'+- ` reg(e).)

5 Conclusion
In this work we have presented a new static analysis for a language with explicitmanipulations of memory regions. Our type and effect system is a direct generalization of the one of Tofte and Talpin. We also have introduced a new method forproving type safety in such a language, establishing a "subject reduction up-tosimulation" property that makes apparent the fact that, if we choose "properly"the names created along the computation, then the typing is preserved. We believe that our idea of introducing explicit deallocation effects, which are in somesense dual to the capabilities of [18], and to the set of "currently allocated regions" of [4], can be adapted to richer settings. In particular, in an extendedversion of this work, we shall show how to deal with region polymorphism and
aliasing. We also think our technique could be extended to deal with explicitallocation, as proposed in [1] for instance, by introducing anticipated and actual
allocation effects. We preferred not to consider such an extended language here,mainly for the purpose of keeping the exposition simple.

It would be interesting to see whether our static analysis could justify thesafety of some of the optimizations, as decribed in [1] for instance, to Tofte and
Talpin's compilation from the call-by-value *-calculus into the region calculus.More generally, it would be interesting to see whether one can take some advantage in using the typed language we have presented as an intermediate languagein the compilation process of functional languages.

References

1. A. Aiken, M. F"ahndrich, R. Levien, Better static memory management: improving region-based analysis of higher-order languages, PLDI'95 (1995) 174-185.
2. A. Banerjee, N. Heintze, J. Riecke, Region analysis and the polymorphic

lambda-calculus, LICS'99 (1999) 88-97.
3. L. Birkedal, M. Tofte, M. Vejlstrup, From region inference to von Neumann

machines via region representation inference, POPL'96 (1996) 171-183.
4. C. Calcagno, Stratified operational semantics for safety and correctness of the

region calculus, POPL'01 (2001) 155-165.
5. C. Calcagno, S. Helsen, P. Thiemann, Syntactic type soundness results for the

region calculus, Information and Computation Vol. 173 No. 2 (2002) 199-221.
6. S. Dal Zilio, A. Gordon, Region analysis and a ss-calculus with groups, J. of

Functional Programming Vol. 12 No. 3 (2002) 229-292.
7. M. F"ahndrich, R. DeLine, Adoption and focus: practical linear types for imperative programming, PLDI'02 (2002) 13-24.
8. M. Fluet, G. Morrisett, A. Ahmed, Linear regions are all you need, ESOP'06,

Lecture Notes in Comput. Sci. 3924 (2006) 7-21.
9. D. Gay, A. Aiken, Memory management with explicit regions, PLDI'98 (1998)

313-323.
10. D. Gay, A. Aiken, Language support for regions, PLDI'01 (2001) 70-80.
11. S. Helsen, P. Thiemann, Syntactic type soundness for the region calculus,

HOOTS'00, ENTCS Vol. 41 No. 3 (2001) 1-19.
12. F. Henglein, H. Makholm, F. Niss, A direct approach to control-flow sensitive

region-based memory management, PPDP'01 (2001) 175-186.
13. F. Henglein, H. Makholm, F. Niss, Effect Types and Region-Based Memory

Management, Chap. 3 of Advanced Topics in Types and Programming Languages
(B.C. Pierce, Ed.), MIT Press (2005) 87-135.
14. J.M. Lucassen, D.K. Gifford, Polymorphic effect systems, POPL'88 (1988) 47-

57.
15. M. Tofte, J.-P. Talpin, Implementation of the typed call-by-value *-calculus

using a stack of regions, POPL'94 (1994) 188-201.
16. M. Tofte, J.-P. Talpin, Region-based memory management, Information and

Computation Vol. 132, No. 2 (1997) 109-176.
17. M. Tofte, L. Birkedal, M. Elsman, N. Hallenberg, A retrospective on

region-based memory management, HOSC Vol. 17 No. 2 (2004) 245-265.
18. D. Walker, K. Crary, G. Morrisett, Typed memory management via static

capabilities, TOPLAS Vol. 22 No. 4 (2000) 701-771.
19. D. Walker, K. Watkins, On regions and linear types, ICFP'01 (2001) 181-192.
20. A. Wright, M. Felleisen, A syntactic approach to type soundness, Information

and Computation Vol. 115 No. 1 (1994) 38-94.