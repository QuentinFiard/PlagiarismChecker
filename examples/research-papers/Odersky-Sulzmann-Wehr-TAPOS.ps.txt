

Type Inference with Constrained Types
Martin Odersky

University of South Australia, School of Computer and Information Science, The Levels, South Australia 5095

Martin Sulzmann*

Yale University, Department of Computer Science, New Haven, CT 06520-8285

Martin Wehr
University of Edinburgh, Laboratory for Foundations of Computer Science (LFCS), EH7 3JZ Edinburgh

Keywords: constrained types, subtypes, record types, constraint systems, constraint solving, type inference, principal types,
ideal semantics

We present a general framework HM(X) for type systems
with constraints. The framework stays in the tradition of
the Hindley/Milner type system. Its type system instances
are sound under a standard untyped compositional semantics. We can give a generic type inference algorithm for
HM(X) so that, under sufficient conditions on X, type inference will always compute the principal type of a term.
We discuss instances of the framework that deal with polymorphic records, equational theories and subtypes.

1. Introduction

Many type systems extend the Hindley/Milner[Mil78]
system with constraints. Examples are found in record
systems [Oho95, R'em89, Wan89], overloading [Jon92,
Kae92, VHJW96, NP93, CHO92, OWW95, BM97], and
subtyping [CCH+89, BSvG95, AW93, EST95b, Smi91].
Extensions of Hindley/Milner with constraints are also
increasingly popular in program analysis [DHM95,
TJ92].

Even though these type systems use different constraint domains, they are largely alike in their typetheoretic aspects. In this paper we present a general
framework HM(X) for Hindley/Milner style type systems with constraints, analogous to the CLP(X) framework in constraint logic programming [JM94]. Particular type systems can be obtained by instantiating the
parameter X to a specific constraint system. The Hindley/Milner system itself is obtained by instantiating X
to the standard Herbrand constraint system.

*Supported by DARPA Grant F30602-96-2-0232.
cfl (Year) John Wiley & Sons, Inc.

By and large, the treatment of constraints in type
systems has been syntactic: constraints were regarded
as sets of formulas, often of a specific form. On the
other hand, constraint programming now generally uses
a semantic definition of constraint systems, taking a
constraint system as a cylindric algebra with some additional properties [HMT71, Sar93]. Cylindric algebras
define a projection operator 9_ff that binds some subset of variables _ff in the constraint. In the usual case
where constraints are boolean algebras, projection corresponds to existential quantification.

Following the lead of constraint programming, we
treat a constraint system as a cylindric algebra with
a projection operator. Projection is very useful for our
purposes for two reasons: First, projection allows us to
formulate a logically pleasing and pragmatically useful
rule (8 Intro) for quantifier introduction:

(8 Intro) C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )C ^ 9_ff:D; \Gamma  ` e : 8_ff:D ) o/
Here, C and D are constraints over the type variables
in the type context \Gamma  and the type scheme o/ . We
discuss some other proposals for quantifier introduction
and show how our approach improves already existing
ones.

Second, projection is an important source of opportunities for simplifying constraints [Jon95, Pot96,
EST95a]. In our framework, simplifying means changing the syntactic representation of a constraint without
changing its denotation. For example, the subtyping
constraint

9fi:(ff !: fi) ^ (fi !: fl)

THEORY AND PRACTICE OF OBJECT SYSTEMS, Vol. (Volume Number)((Optional Issue Number)), 1 22 (Year) CCC(cccline information)

can safely be simplified to

(ff !: fl)
since the denotation is the same for both constraints.
Without the projection operator, the two constraints
would be different, since one restricts the variable fi
while the other does not.

Two of the main strengths of the Hindley/Milner system are a type soundness result and the existence of a
type inference algorithm that computes principal types.
HM(X) stays in the tradition of the Hindley/Milner
type system. Type systems in HM(X) are sound under a
standard untyped compositional semantics provided the
underlying constraint system X is sound. This result
can be summarized in the slogan "well-typed programs
can not go wrong". One of the key ideas of our paper is to present sufficient conditions on the constraint
domain X so that the principal types property carries
over to HM(X). The conditions are fairly simple and
natural. For those constraint systems meeting the conditions, we present a generic type inference algorithm
that will always yield the principal type of a term.

The type inference algorithm is explained by treating the typing problem itself as a constraint. Generally, the constraint system X needs to be rich enough
to express all constraint problems that can be generated by type derivations. On the other hand, we admit
the possibility that constraints on the left hand side of
the turnstile and in type schemes come from a more
restricted set which we call solved forms. The task of
type inference is then to split a typing problem into a
substitution and a residual constraint in solved form.
This we call constraint normalization. We require that
normalization always yields a "best" solution, if there
is a solution at all. This ensures that the type inference
algorithm computes principal types.

Our work generalizes Milner's results to systems with
non-standard constraints and thus makes it possible to
experiment with new constraint domains without having to invent yet another type inference algorithm and
without having to repeat the often tedious proofs of
soundness and completeness of type inference.

Object-oriented languages. Object oriented languages are often based on record calculi and
type systems supporting a notion of subtyping.
Cardelli/Wegner [CW85] gave an early survey about
general research directions. Reynolds [Rey85] and
Mitchell [Mit84] are foundational papers that develop
basic concepts of constraints and subtyping. Palsberg [Pal95] gave an efficient inference algorithm for
a calculus of objects.

Subtyping is orthogonal to the notion of parametric polymorphism supported by the Hindley/Milner system. A natural approach for a type system that supports both notions is to add subtype constraints to

types [AW93, EST95a]. Such systems can be expressed
as instances of the HM(X) system (or, if they are based
on recursive records, in an extension of it). Other encodings of object-oriented languages forgo subtyping,
and are instead based on calculi for extensible records
or overloading [R'em89, Wan89, OWW95, BM97]. Such
systems can also be regarded as instances of our framework. We demonstrate this using Ohori's system
[Oho95] as an example.

Outline. The rest of this paper is structured as follows:
The next section discusses previous approaches to type
systems with constraints. Section 3 gives a characterization of constraint systems. Section 4 presents our
framework HM(X) for Hindley/Milner style type systems with constraints. Section 5 presents an ideal semantics for type systems in the framework from which
a type soundness theorem is derived. Section 6 establishes conditions on the constraint system so that type
inference is feasible and a principal types theorem holds.
Section 7 describes as an instance of our framework a
type system for polymorphic records. Section 8 concludes.

2. Related work

Hindley/Milner style type systems with constrained
types have been used in a number of instances. All such
type systems extend the type judgments \Gamma  ` e : oe of
the original Hindley/Milner system with a constraint
hypothesis on the left side of the turnstile, written
C; \Gamma  ` e : oe. Furthermore, they extend the type
schemes 8_ff:o/ of the Hindley/Milner system with a constraint component; we write

8_ff:C ) o/
to express that the constraint C restricts the types that
can legally be substituted for the bound variables _ff.

All type systems have essentially the same rule for
eliminating quantifiers, which we write as follows:

(8 Elim) C; \Gamma  ` e : 8_ff:D ) o/

0 C `e [_o/ =_ff]D

C; \Gamma  ` [_o/ =_ff]o/ 0
The rule is a refinement of the corresponding rule in
the Hindley/Milner system. It says that, when instantiating a type scheme 8_ff:D ) o/ 0, the only valid instances
are those instances [_o/ =_ff]o/ 0 which satisfy the constraint
part D of the type scheme.

While there is agreement about the proper technique
for eliminating quantifiers in type schemes, there is remarkable disagreement about the proper way to introduce them. Figure 1 shows four different rules that
have all been proposed in the literature. We have edited
these rules somewhat to present them in a uniform style,
and have attempted to compensate for the considerable variations in detail between published type sys2 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

No satisfiability check[Jon92]: C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )C; \Gamma  ` e : 8_ff:D ) o/ (8 Intro-1)
Weak satisfiability check[AW93]: C ^ D; \Gamma  ` e : o/ 9D _ff 62 fv(C) [ fv(\Gamma )C; \Gamma  ` e : 8_ff:D ) o/ (8 Intro-2)
Strong satisfiability check[Smi91]: C ^ D; \Gamma  ` e : o/ C ` [_o/ =_ff]D _ff 62 fv(C) [ fv(\Gamma )C; \Gamma  ` e : 8_ff:D ) o/ (8 Intro-3)
Duplication[EST95b]: C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )C ^ D; \Gamma  ` e : 8_ff:D ) o/ (8 Intro-4)

FIG. 1. Versions of the quantifier introduction rule
tems. Even though these details matter for each particular type system, we have to abstract from them here
in order to concentrate on general principles. We now
discuss each of the four schemes in turn.

In his work in qualified types [Jon92], Jones uses
a general framework for type qualification with a rule
equivalent to rule (8 Intro-1). Any constraint can be
shifted from the assumption on the left to the type
scheme on the right of the turnstile; it is not checked
whether the traded constraint is satisfiable. This might
lead to programs that are well-typed as a whole, even
though some parts have unsatisfiable constraints.

To give an example, assume that our constraints
are subtyping constraints (^) in a type system with
classes and a subtyping relation determined by programmer declarations. Let us assume that there is a
parametrized class List ff which is a subtype of type
Comparable (List ff), where Comparable is declared as
follows:

type Comparable ff = fless : ff ! Boolg
Let us further assume that there is a value Nil of type
8ff:true ) List ff that represents the empty list. Consider the following (nonsensical) program.

Example 1.

let

f: 8ff:(List ff ^ Comparable ff) ) List ff ! List ff
f x = if x.less(true) then x else Nil
in 1

We use a Haskell-style notation, adding type annotations for illustration purposes. Using rule (8 Intro1), the program in Figure 1 is well-typed, even though
we would not expect the constraint in function f's type
scheme to have a solution, since the function type List ff
would not be a subtype of Comparable Bool.

In the ideal semantics of types [MPS86], which represents universal quantification by intersection, f 's type
would be an empty intersection, which is equal to the

whole type universe including the error element wrong.
However, the whole program in Figure 1 is still sound
because every application of f must provide a valid instantiation of the constraint. Since the constraint is unsatisfiable, no application is possible. In essence, Jones
treats constraints as proof obligations that have to be
fulfilled by presenting "evidence" at the instantiation
site. This scheme is clearly inspired by Haskell's implementation of overloading by dictionary passing. It runs
into problems if one ever wants to compute a value of a
constrained type without any instantiation sites, as in
the following slight variation of Example 1.

Example 2.

let

y: 8ff:(List ff ^ Comparable ff) ) Bool
y = Nil.less(true)
in 1

Jones excludes this code on the grounds that y's type
is ambiguous, but it is unclear how to generalize this
restriction to arbitrary constraint systems.

Nevertheless, it is possible to integrate Jones' approach into our HM(X) framework, thus giving it a semantic basis independent of dictionary passing. The
essential idea is that we have to restrict ourselves to
constraint systems in which projections of solved constraints are trivial, i.e `e 9ff:C, for all constraints C
that can appear on the left hand side of the turnstile,
and for all type variables ff 2 fv(C). In this case, our
rule (8 Intro) simplifies to (8 Intro-1).

Note that trivial projections correspond well to
Haskell's "open world" assumption, which says that the
range of possible instance types for an overloaded operation is not fixed in advance. Therefore, we can never
rule out that a given constraint which still has free variables might have a solution. A formalization of this
principle using a "bottom type" [OWW95] makes it possible to define a compositional semantics for Haskell-
style overloading.

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 3

In the type system of Aiken/Wimmers [AW93], moving a constraint from the left hand side of the turnstile
to the right-hand side is allowed only if the constraint is
satisfiable (i.e. has a solution). Hence, none of the previous examples would be typable with rule (8 Intro-2),
which they use. However, this example is typable.

Example 3.

let

f: 8fi:fi ! Int
f x =

let y: 8ff:(List ff ^ Comparable fi) ) Bool

y = Nil.less(x)
in 1
in f true

The constraint List ff ^ Comparable fi has a solution,
namely fi = List ff. Therefore, using rule (8 Intro-2) we
can generalize y's type to

8ff:(List ff ^ Comparable fi):Bool:
On the other hand, if we substitute the actual parameter true in f's definition, we get again Example 1 which
is not typable under the system with (8 Intro-2). Hence,
the system with (8 Intro-2) does not enjoy the property
of subject reduction, which says that if a term is typable then its reduction instances are typable as well.
In a later version, they use rule (8 Intro-4) instead.

Where Aiken and Wimmers require only a weak form
of satisfiability for traded constraints, G. Smith requires
a strong one [Smi91]. In rule (8 Intro-3), the traded constraint D must be solvable by instantiation of only the
quantified variables _ff. Hence, all three previous examples would be untypable under his system. However, (8
Intro-3) rule seems overly restrictive, depending on the
constraint system used. For instance, let's assume that
Comparable has precisely two instances:

Int ^ Comparable Int
Char ^ Comparable Char

Now consider the following program:
Example 4.

let

f: 8fi:fi ! Int
f x =

let g y = y.less(x)
in 1
in 1

When typing the definition of g, Smith's system requires
a solution of the constraint o/ ^ Comparable o/ , where o/
is y's type. Two solutions exist: o/ = Int or o/ = Char,
and there is no best type for y that improves on both
solutions.

The system of the Hopkins Objects Group [EST95b]
differs from the previous three systems in that in rule
(8 Intro-4) the constraint D is copied instead of moved;
there are no restrictions on when the copying can take

place. Under this scheme, the first three examples
would be rejected and the fourth one would be accepted,
which corresponds fairly well to our intuition. At the
same time, rule (8 Intro-4) seems strange in that its conclusion contains two copies of the constraint D, one in
which the type variables ff are bound and one in which
they are free. Actually, the Hopkins Objects Group
uses a slightly different system in which generalization
is coupled with the let rule and one of the two constraints undergoes a variable renaming. HM(X) can
be seen as the proper logical formulation of their more
algorithmically-formulated type system. Furthermore,
instead of dealing exclusively with subtype constraints,
we admit arbitrary constraint systems.

3. Constraint systems

We present a characterization of constraint systems along the lines of Henkin [HMT71] and
Saraswat [Sar93]. Building on the standard notions of
simple and cylindric constraint systems we introduce
term constraint systems as constraint systems which
have a well-behaved notion of substitution. These constraint systems will be the parameter which allows our
framework to be customized to different application domains.

We start with the definition of a simple constraint
system.

Definition. A simple constraint system is a structure
(\Omega ; `e ) where \Omega  is a non-empty set of tokens or (primitive) constraints. We also refer to such constraints as
predicates. The relation `e ` p\Omega  \Theta  \Omega  is an entailment
relation where p\Omega  is the set of finite subsets of \Omega . We
call C 2 p\Omega  a constraint set or simply a constraint.

A constraint system (\Omega ; `e ) must satisfy for all constraints C; D 2 p\Omega :

C1 C `e P whenever P 2 C and
C2 C `e Q whenever

C `e P for all P 2 D and D `e Q

We extend `e to be a relation on p\Omega  \Theta  p\Omega  by: C `e D
iff C `e P for every P 2 D. Furthermore, we define
C =e D iff C `e D and D `e C. The term `e C is
an abbreviation for ; `e C and true = f P j ; `e P g
represents the true element.

We give an example how to generate a simple constraint system based on a first-order language L.

Example 5. For any first-order language L, and
countably infinite set of variables Var, take \Omega  to be an
arbitrary subset of open (L, Var)-formulas, and `e to
be the entailment relation with respect to some class \Delta 
of L-structures. That is, fP1; : : : ; Png `e Q iff for every structure M 2 \Delta , an M -valuation realizes Q whenever it realizes each of P1; : : : ; Pn. Such a (\Omega ; `e ) is a

4 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

simple constraint system.

We now extend a simple constraint system with a
projection operator 9_ff. This leads to a cylindric constraint system.

Definition. A cylindric constraint system is a structure CS = (\Omega ; `e ;Var; f9ff j ff 2 Varg) such that:

ffl (\Omega ; `e ) is a simple constraint system,
ffl Var is an infinite set of variables,
ffl For each variable ff 2 Var, 9ff : p\Omega  ! p\Omega 

is an operation satisfying:

E1 C `e 9ff:C
E2 C `e D implies 9ff:C `e 9ff:D
E3 9ff:(C ^ 9ff:D) =e (9ff:C) ^ (9ff:D)
E4 9ff:9fi:C =e 9fi:9ff:C

Remark. For simplicity, we omit set notation for
constraints, and connect constraints by ^ instead of the
union operator [. Also, we generally do not enclose
simple constraints P in opening and closing braces. For
instance, P ^ Q is an abbreviation for fP g [ fQg. We
assume that ^ binds tighter than 9_ff. For instance,
9_ff:C ^ D stands for 9_ff:(C ^ D). We write C =e D iff
C `e D and D `e C.

Example 6. Let the token set \Omega  consist of some subclass of (L,Var) formulas closed under existential quantification of finite conjunctions. Each operator 9_ff is
then interpreted by the function which maps each finite set fP1; : : : ; Png of tokens to the set of tokens
f9_ff:P1 ^ : : : ^ Png. It is easy to see that the four conditions above are satisfied.

The projection operator 9_ff allows us to bind variables _ff in a constraint. That means we can project away
information. If the constraint system models a boolean
algebra, projection corresponds to existential quantification. Based on the projection operator we define the
free variables fv(C) and satisfiability of a constraint C.

Definition. Let C be a constraint. Then fv(C) =
fff j 9ff:C 6 =e Cg.

Definition. Let C be a constraint. Then C is satisfiable iff `e 9fv(C):C.

The next lemma states an important property about
the projection operator. Projection of a constraint does
not influence the satisfiability of the constraint.

Lemma 1. Let C be a constraint. Then C is satisfiable
iff 9ff:C is satisfiable.

The final step in our modeling of constraint systems
is the extension from cylindric constraint systems to
term constraint systems. We assume a term algebra
T with signature \Sigma  = (Var, Cons) as given. Var is a
set of variables and Cons is a set of type constructors

containing at least the function constructor ! of arity 2.
In examples below we will sometimes use a multi-sorted
algebra, in which terms and constructors are partitioned
into sorts. Always present will be the sort of types which
is ranged over by o/ .

Definition. A substitution OE is an idempotent mapping from the set of variables Var to the term algebra
Term(\Sigma ) which is the identity everywhere except on a
finite set of variables.

Definition. A term constraint system T CST =
(\Omega ; `e ; Var; f9ff j ff 2 Varg) over a term algebra T is a
cylindric constraint system with predicates of the form

p(o/1; : : : ; o/n) (o/i 2 T )
such that the following holds:

ffl For each pair of types o/; o/ 0 there is an equality

predicate (o/ = o/ 0) in T CST , which satisfies:

D1 `e (ff = ff)
D2 (ff = fi) `e (fi = ff)
D3 (ff = fi) ^ (fi = fl) `e (ff = fl)
D4 (ff = fi) ^ 9ff:(C ^ (ff = fi)) `e C
D5 (o/ = o/ 0) `e (T [o/ ] = T [o/ 0])

where T [] is an arbitrary term context
ffl For each predicate P ,

D6 [o/ =ff]P =e 9ff:(P ^ (ff = o/ ))

where ff 62 fv(o/ )

Remark. Conditions D1 - D4 are the conditions
imposed on a cylindric constraint system with diagonal elements, which is usually taken as the foundation
of constraint programming languages. D4 says that
equals can be substituted for equals; it is in effect the
Leibniz principle. D5 states that (=) is a congruence.
D6 connects the syntactic operation of a substitution
over predicates with the semantic concepts of projection and equality. Substitution is extended to arbitrary
constraints in the canonical way:

[o/ =ff](P1 ^ : : : ^ Pn) = [o/ =ff]P1 ^ : : : ^ [o/ =ff]Pn:
Here are some basic lemmas which hold in term constraint systems.

Lemma 2 Renaming. Let C be a constraint and fi
a new type variable. Then 9ff:C =e 9fi:[fi=ff]C.

Lemma 3 Normal Form. Let C be a constraint and
OE = [_o/ =_ff] be a substitution. Then OEC =e 9_ff:C ^ (ff1 =
o/1) ^ : : : ^ (ffn = o/n).

In the above lemma it is essential that substitutions
are idempotent mappings. In the case of substitution OE
this ensures that none of the type variables _ff appears
in the types _o/ .

Lemma 4 Substitution. Let C; D be constraints
such that C `e D and OE be a substitution. Then
OEC `e OED.

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 5

We now discuss several instances of term constraint
systems. Section 7 will present a more elaborate example of a term constraint system that deals with records.

Example 7. For any term algebra T let HERBRAND =
(\Omega ; `e ; Var; f9ff j ff 2 Varg) be the minimal term constraint system where \Omega  contains only primitive constraints of the form (o/ = o/ 0) where o/ and o/ 0 are types
from T . Equality in HERBRAND is syntactic, i.e. T
is a free algebra. Entailment between two constraints C
and D can be checked by the matching algorithm. For
example, (f (x; y) = f (a; g(b; c))) must entail (x = a)
and (y = g(b; c)). Satisfiability can be checked by (first-
order) unification.

A more refined example of a term constraint system deals with physical dimension types in the style of
Kennedy [Ken96]:

Example 8. Let T be the two-sorted term algebra consisting of dimensions and types.

Dimensions d ::' ff j i(d) j prod(d; d) j 1 j m j s
Types o/ ::= ff j dim(d) j o/ ! o/

The dimension constructor i(\Delta ) corresponds to the inverse of a dimension and prod(\Delta ; \Delta ) to the product of
two dimensions. Dimension constants are 1 for the
unit measure, m for meters and s for seconds. There
might be other dimension constructors besides the mentioned ones. A type is either a type variable, or a dimension, or a function type. DIM is then the term
constraint system which obeys the following additional
conditions, which specify that dimension types form an
abelian group.

DIM1 `e (prod(ff; fi) = prod(fi; ff))
DIM2 `e (prod(ff; prod(fi; fl)) = prod(prod(ff; fi); fl))
DIM3 `e (prod(ff; 1) = ff)
DIM4 `e (prod(ff; i(ff)) = 1)

As our final example, we consider an extension of a
term constraint system with subtyping.

Example 9. A subtype constraint system over a term
algebra T is a term constraint system with a subtype
predicate (o/ !: o/ 0) for each pair of types o/ and o/ 0 which
satisfies the following conditions.

SUB1 (ff = ff0) =e (ff !: ff0) ^ (ff0 !: ff)

SUB2 D `

e (ff01 !: ff1) D `e (ff2 !: ff02)

D `e (ff1 ! ff2 !: ff01 ! ff02)

SUB3 D `

e (ff1 !: ff2) D `e (ff2 !: ff3)

D `e (ff1 !: ff3)

Let SC be a subtype constraint system with primitive
types Int and Float and record types of the form fl1 :
o/1; : : : ; ln : o/ng. Records are modeled by admitting constructors of the form

l1 : : : ln : o/1 ! : : : ! o/n ! fl1 : o/1; : : : ; ln : o/ng
in the term algebra. We assume that record fields are
ordered with respect to a given ordering relation on field
labels. The additional types obey the following rules.

SUB4 `e (Int !: Float)

SUB5 `e (fl1 : o/1; : : : ; ln : o/n; : : :g !: fl1 : o/1; : : : ; ln : o/ng)

SUB6 D `

e (o/1 !: o/ 01) : : : D `e (o/n !: o/ 0n)

D `e (fl1 : o/1; : : : ; ln : o/ng !: fl1 : o/ 01; : : : ; ln : o/ 0ng)

4. The HM(X) framework

This section describes a general extension HM(X) of
the Hindley/Milner type system with a term constraint
system X over a term algebra T .

Our development is similar to the original presentation [DM82]. We work with the following syntactic
domains.

Values v ::= x j *x:e
Expressions e ::= v j e e j let x = e in e
Types o/ ::= ff j o/ ! o/ j T _o/
Type schemes oe ::= o/ j 8ff:C ) oe

We consider only one-sorted algebras here, but it
is straightforward to extend the treatment to multi-
sorted algebras. This formulation generalizes the one
in [DM82] in two respects. First, types are now members of an arbitrary term algebra, hence there might be
other constructors besides !. In the above definition T
stands for additional type constructors which vary depending on a specific HM(X) instance. We have already
seen examples where T has been instantiated to dimension and record types. Second, type schemes 8ff:C ) oe
now include a constraint component C, which restricts
the types that can be substituted for the type variable
ff. We require that the constraint C has to be satisfiable. On the other hand, the language of terms is
exactly as in [DM82]. That is, we assume that any language constructs that make use of type constraints are
expressible as predefined values, whose names and types
are recorded in the initial type environment.

The typing rules of our system can be found in Figure 2. Typing judgments are of the form C; \Gamma  ` e : oe
where C is a satisfiable constraint in X, \Gamma  a type environment and oe a type scheme. A typing judgment is
valid if it can be derived by application of the typing
rules and its constraint component is satisfiable.

Quite often we restrict the set of constraints C that
can appear in type schemes and on the left hand side
of the turnstile to so called solved forms. The set of

6 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

(Var) C; \Gamma  ` x : oe (x : oe 2 \Gamma )
(Sub) C; \Gamma  ` e : o/ C `

e (o/ _ o/ 0)

C; \Gamma  ` e : o/ 0

(Abs) C; \Gamma x:x : o/ ` e : o/

0

C; \Gamma x ` *x:e : o/ ! o/ 0

(App) C; \Gamma  ` e1 : o/1 ! o/2 C; \Gamma  ` e2 : o/1C; \Gamma  ` e

1e2 : o/2

(Let) C; \Gamma x ` e : oe C; \Gamma x:x : oe ` e

0 : o/ 0

C; \Gamma x ` let x = e in e0 : o/ 0

(8 Intro) C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )C ^ 9_ff:D; \Gamma  ` e : 8_ff:D ) o/

(8 Elim) C; \Gamma  ` e : 8_ff:D ) o/

0 C `e [_o/ =_ff]D

C; \Gamma  ` e : [_o/ =_ff]o/ 0

FIG. 2. Logical type system
solved forms, denoted by S, is always a subset of the
satisfiable constraints in X.

The most interesting rules in Figure 2 are the
(8 Intro) rule and the (8 Elim) rule. By rule (8 Intro)
we quantify some type variables. We often use vector notation for type variables in type schemes. The
term 8_ff:D ) o/ is an abbreviation for 8ff1:true )
: : : 8ffn:D ) o/ and 9_ff:D is an abbreviation for
9ff1: : : : 9ffn:D.

Unlike in standard treatments of Hindley/Milner
style systems we also have a subsumption rule (Sub),
which allows us to derive term e with type o/ 0 if we can
derive term e with type o/ and type o/ subsumes type o/ 0.
The subsumption relation _ is determined by the constraint system X, and is assumed to satisfy the standard
axioms for a partial ordering plus the contra-variance
rule:

REFL (ff = ff0) `e (ff _ ff0) ^ (ff0 _ ff)
ASYM (ff _ ff0) ^ (ff0 _ ff) `e (ff = ff0)

TRANS D `

e (ff1 _ ff2) D `e (ff2 _ ff3)

D `e (ff1 _ ff3)

CONTRA D `

e (ff01 _ ff1) D `e (ff2 _ ff02)

D `e (ff1 ! ff2 _ ff01 ! ff02)

Except for these conditions, the choice of _ is arbitrary.

Example 10. The Hindley/Milner system is an instance of our type system framework. Take X to be the
Herbrand constraint system over the algebra of types o/ .
Take the set of solved forms to be the set consisting
only of true, which is represented by the empty token
set. Take _ to be syntactic type equality. Then the
only type schemes arising in proof trees of valid typing
judgments are of the form 8ff:fg ) oe, which we equate
with Hindley/Milner type schemes 8ff:oe. The subsumption rule becomes the trivial tautology which states that
a judgment can be derived if it can be derived. It is easy
to convince oneself that a judgment \Gamma  ` e : oe is derivable in Hindley/Milner if and only if fg; \Gamma  ` e : oe is
derivable in HM(HERBRAND).

Example 11. Let X be the constraint system DIM, let
the set of solved forms be the set consisting only of true,
and let subsumption _ be the equality relation = in
DIM. Then Kennedy's system can be recovered simply by adding primitives to the initial type environment
\Gamma 0 that deal with dimensions. E.g. we assume that

div : 8d1; d2: dim(d1) ! dim(d2) ! dim(prod(d1; i(d2)))
is contained in \Gamma 0. Other basic connectives are treated
analogously.

Example 12. Let X be the subtype constraint system
SC and let the subsumption relation _ be equal to the
subtyping relation !:. Let the set of solved forms S
be all satisfiable constraints in SC. For every record
fl1 : o/1; : : : ; ln : o/ng in a program we add a datatype

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 7

constructor

l1 : : : ln : o/1 ! : : : ! o/n ! fl1 : o/1; : : : ; ln : o/ng
and for every field label l we add a function

.l : fl : o/ g ! o/
to the initial type environment \Gamma 0. The first corresponds
to record creation, the second to record selection. Other
basic primitive functions are defined analogously.

The resulting system is related to the subtyping approach of the Hopkins Object Group [EST95b]. The
main difference is that we use logical rules for quantifier
introduction and elimination where they use a syntactic
approach where quantifier introduction is coupled with
let and quantifier elimination is coupled with variable
use. Another important difference is that their system
also includes recursive types. Recursive types are beyond the scope of this paper, so we cannot deal with their
system in its full generality. We can however deal with
either a variant of their system without recursive types,
or with a system of recursive records that are given as
instances of explicitly declared classes, similar to the
datatype constructions in functional languages or the
class and interface system of Java [GLS96].

Further applications with non-trivial constraint systems include overloading [Jon92, Kae92, VHJW96,
NP93, CHO92, OWW95, BM97], record calculi [R'em89,
Wan89], and static program analysis techniques such as
binding time analysis [DHM95]. As an extended example we will present in Section 7 a record calculus similar
to Ohori's [Oho95].

5. Semantics

We give a type soundness theorem based on an ideal
semantics [MPS86] for HM(X) type systems. We show
that our type system is sound, provided the underlying
constraint system is sound and the subsumption predicate (_) satisfies a coherence property. We say a constraint system is sound if every satisfiable constraint has
a monotype solution. Coherence of a constraint system
means that if a type o/ subsumes a type o/ 0, then the
denotation of o/ in the ideal model is a subset of the
denotation of o/ 0.

Definition. A monotype is a type o/ with fv(o/ ) = ;.

We let _ range over monotypes.
Definition. A constraint system X is sound if for all
type variables ff and constraints C 2 S, if `e 9ff:C then
there is a monotype _ such that `e 9ff:(ff = _) ^ C.

The soundness proof is based on an ideal semantics
of types which is a direct extension of the semantics in
[Mil78].

The meaning of a term is a value in the CPO V,
where V contains all continuous functions from V to V
and an error element W, usually pronounced "wrong".
Depending on the concrete type system used, V might
contain other elements as well. We require that the
values of additional type constructors are representable
in the CPO V. Then V is the least solution of the
equation

V = W? + V ! V + Pk2K (k V1 : : : Varity(k))?
where K is the set of values of an additional type constructor T .

The meaning function on terms is the same as in the
original semantics of Hindley/Milner terms. That is,
we assume that any language constructs that make use
of type constraints are expressible as predefined values,
whose names and types are recorded in the initial type
environment.

[[x]]j = j(x)

[[*u:e]]j = *v:[[e]]j[u := v]
[[e e0]]j = if [[e]]j 2 V ! V ^ [[e0]]j 6= W

then ([[e]]j) ([[e0]]j)
else W

[[let x = e in e0]]j = if [[e]]j 6= W

then [[e0]]j[x := [[e]]j]
else W

We will show in the following that the meaning of a
well-typed program is always different from "wrong".

As a first step, we give a meaning to types. Following [Mil78], we let types denote ideals, i.e. non-
empty, downward-closed and limit-closed subsets of V.
The meaning function [[\Delta ]] maps closed types and type
schemes to ideals. On function types and type schemes
it is defined as follows:

[[_1 ! _2]] =

ff 2 V ! V j v 2 [[_1]] ) f v 2 [[_2]]g
[[T _1 : : : _m]] =

f?g [S

fk [[_01]] : : : [[_0n]] j

true; \Gamma 0 ` k : _01 ! : : : ! _0n ! T _1 : : : _mg
[[8_ff:C ) o/ ]] =T

f[[[__=_ff]o/ ]] j `e [__=_ff]Cg

We are now in the position to define coherence of the
subsumption predicate (_).

Definition. The constraint system X is coherent if
for all monotypes _ and _0, if `e (_ _ _0) then [[_]] `
[[_0]].

Lemma 5. Let oe be a closed type scheme. Then [[oe]]
is an ideal.

Proof. A straightforward induction on the structure of oe.

8 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

Furthermore, we conclude that in a sound constraint
system the error element is not contained in a closed
type scheme.

Lemma 6. Given a sound constraint system X and a
closed type scheme oe. Then W 62 [[oe]].

Proof. This is true for all monotypes _. Consider
now a type scheme oe = (8_ff:C ) o/ ). Because oe is
closed we get `e 9_ff:C (remember that all constraints
that appear in the typing judgments of a derivation need
to be least satisfiable). Also, C is sound, thus there is
a monotype vector __ such that `e [__=_ff]C. Hence, the
denotation of [[oe]] is not an empty intersection. W is not
contained in the denotation of any monotype [__=_ff]_o/ .
Thus W is not contained in [[oe]].

Definition. A variable environment j models a
closed typing environment \Gamma , written j j= \Gamma , if for all
x : oe 2 \Gamma , j(x) 2 [[oe]].

Theorem 7 Type Soundness. Let C; \Gamma  ` e : oe be
a valid typing judgment in HM(X), where X is a sound
and coherent constraint system. Let OE be a substitution
such that OE\Gamma  and OEoe are closed and such that `e OEC.
Let j be a variable environment such that j j= OE\Gamma . Then

(1) W 62 [[OEoe]]
(2) [[e]]j 2 [[OEoe]]

Proof. (1) follows immediately from Lemma 6.
We prove now (2) by a structural induction on typing
derivations. There are three interesting cases.

Case (Var) The last step of the derivation is:

C; \Gamma  ` x : oe (x : oe 2 \Gamma )
Therefore x : OEoe 2 OE\Gamma . Since j j= OE\Gamma , [[x]]j = j(x) 2
[[OEoe]].

Case (8 Intro) The last step of the derivation is:

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9_ff:D; \Gamma  ` e : 8_ff:D ) o/

Let OE be such that OE\Gamma  and OE(8_ff:D ) o/ ) are closed and
such that `e OE(C ^ 9_ff:D). Furthermore, we assume
there are no name clashes between OE and _ff. Let __ be
an arbitrary vector of monotypes such that

`e 9_ff:((_ff = __) ^ OED)
Since C is sound there is at least one such vector __. Let
OE0 = [__=_ff] ffi OE. Then since _ff 62 fv(C), OE0(C ^ D) =
OEC ^ OE0D, which expands to OEC ^ 9_ff:((__ = _ff) ^ OED).
By our assumption this constraint is valid. Furthermore, OE0\Gamma  and OE0o/ are both closed. By the induction
hypothesis, [[e]]j 2 [[OE0o/ ]]. Since __ was arbitrary such
that `e [__=_ff](OED),

[[e]]j 2 Tf[[[__=_ff](OEo/ )]] j `e [__=_ff](OED)g

= [[OE(8_ff:D ) o/ )]]:

Case (Sub) The last step of the derivation is:

C; \Gamma  ` e : o/ C `e (o/ _ o/ 0)

C; \Gamma  ` e : o/ 0

We know that there is a substitution OE such that OE\Gamma  and
OEo/ 0 are closed and such that `e OEC. It follows that `e
(OEo/ _ OEo/ 0). It might be the case that OEo/ still contains
some free variables. We can extend OE to a substitution
OE0 such that OE0o/ is closed. Because OE0 is an extension of
OE we get that OE0\Gamma  is closed and `e OE0C. Applying the
induction hypothesis, we get that [[e]]j 2 [[OE0o/ ]]. Because
X is coherent we know that [[OE0o/ ]] ` [[OE0o/ 0]]. Because OEo/ 0
is a closed type and OE0 extends OE we get that [[OE0o/ 0]] =
[[OEo/ 0]] and this yields [[e]]j 2 [[OEo/ 0]].

The type soundness theorem can be simplified to
top-level programs. As a corollary, we find Milner's
slogan "well types programs do not go wrong" carries
over to sound constraint extensions.

Corollary. Let X be a sound and coherent constraint
system. Let true; \Gamma  ` e : oe be a valid closed typing
judgment in HM(X). If j j= \Gamma  then [[e]]j 6= W.

Proof. Immediate from (1) and (2) of Theorem 7.

We find that HM(HERBRAND), HM(DIM) and
HM(SC) satisfy the requirements. Hence, these applications are sound with respect to the provided semantics.

6. Type inference

We now turn to the problem of type inference in
HM(X) type systems. We follow the standard approach
of translating a typing problem into a constraint problem. Then a typing problem is solvable if the constraint
problem is solvable. The solution of a constraint problem is a constraint in solved form in S. If no solution
exists then the typing problem is not solvable. For instance, consider a function application e1e2 where e1
has inferred type o/1 and e2 has inferred type o/2. To
solve the typing problem e1e2 we need to solve the constraint (o/1 _ o/2 ! ff) with the fresh type variable ff
corresponding to the yet unspecified result type of the
application e1e2.

For the moment, we take a closer look at two specific
typing situations. In HM(SC) the subsumption predicate _ corresponds to the subtype predicate !:. The
set S is defined as the set of all satisfiable constraints
in SC. Then solving a constraint problem means simply checking whether the constraint is satisfiable or not.
In another example we considered the Hindley/Milner
system as an instance HM(HERBRAND) of the HM(X)

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 9

framework. Here, the subsumption predicate _ corresponds to the type equality predicate = and S is the
set consisting of just true. In this case solving a constraint problem requires more than just a satisfiability
test. We additionally have to discard all equality problems, which can be achieved by Herbrand unification.

We can observe that type inference consists of two
phases: constraint generation and constraint solving.
Constraint generation is always the same for all HM(X)
type systems. We simply generate constraints of the
form (o/ _ o/ 0). But the kind of constraint solving might
differ in different typing situations. Depending on the
structure of the set S of solved forms we have to apply different methods to obtain a constraint in solved
form. The least requirement which we put on S is that
the constraints in S are satisfiable. Hence, solving of
a constraint problem requires at least a satisfiability
test. But our constraint systems and the structure of
the set S can be arbitrary complex. Therefore, solving
of constraint problems might involve more sophisticated
methods than e.g. a satisfiability test or Herbrand unification. In the latter, we refer to solving of constraint
problems as constraint normalization or normalization
for short. In the next section we give a formal treatment of normalization in a constraint system X. Then,
we give a generic type inference algorithm for HM(X)
type systems and state our main results, namely that
type inference is sound, and under sufficient conditions
on X also complete.

6.1 Normalization

In this section we study normalization of constraints.
Before giving an axiomatic description of normalization,
we first introduce some preliminary definitions.

Preliminaries: Let OEjU be the restriction of the
substitution OE to the domain U . That is, OEjU (x) = OE(x)
if x 2 U and OEjU (x) = x otherwise. For substitutions
OE and  we write  =U OE iff `e ((x) = OE(x)) for all
x 2 U . We write  ^OE

0

U OE iff OE0 ffi  =U OE. We write ^
U OE if 9OE0 :  ^OE

0 OE. Sometimes, we omit the set

U .

Note that this makes the "more general" substitution
the smaller element in the pre-order ^U . This choice,
which reverses the usual convention in treatments of
unification (e.g. [LMM87]), was made to stay in line
with the semantic notion of type instances.

We make ^U a partial order by identifying substitutions that are equal up to variable renaming, or equivalently, by defining  =U OE iff  ^U OE and OE ^U .
It follows from [LMM87] that ^U is a complete lower
semi-lattice where least upper bounds, if they exist,
correspond to unifications and greatest lower bounds
correspond to anti-unifications.

We consider now the task of normalization. Generally, a typing problem is translated into a constraint C
in the term constraint system C and a substitution .
We will refer to the pair (C; ) as a constraint problem. Normalization means then computation of a normal form of a constraint problem (C; ).

Definition. Let X be a term constraint system over
a term algebra T and S be the set of solved constraints
in X. Let C 2 S and D 2 X be constraints and let OE,
be substitutions. Then (C; ) is a normal form of (D; OE)
iff OE ^ , C `e D and C = C.

(C; ) is principal if for all normal forms (C0; 0) of
(D; OE) we have that  ^ 0 and C0 `e 0C.

The principal normal form represents the best solution of a constraint problem. As an example consider
the constraint system HERBRAND. There, a principal
normal form corresponds to a most general unifier and
a normal form corresponds to a unifier of a constraint
problem.

The next lemma states that all principal normal
forms are unique up to variable renaming.

Lemma 8 Uniqueness. Let (C; ) and (C0; 0) be
principal normal forms of (D; OE). Then there is a variable renaming OE0 such that C0 =e OE0C and 0 = OE0 ffi .

We identify two normal forms that are equivalent up
to variable renaming. We can thus define a well-defined
function normalize from constraint problems (D; OE) to
normal forms as follows:

normalize(D; OE)
= (C; ) if (C; ) principal normal form of (D; OE)
= fail otherwise

We now extend the property of having a principal normal form to constraint systems.

Definition. Given a constraint system X over a term
algebra T and a set of solved constraints S in X. The
constraint system X has the principal constraint property if for every constraint D 2 X and substitution OE,
either (D; OE) does not have a normal form or (D; OE) has
a principal normal form.

We also say that the HM(X) type system has the
principal constraint property if X has the principal constraint property.

In Section 7 we discuss in detail a type system
for Ohori-style records that satisfies the principal constraint property. This example belongs to a class of constraint systems where constraint solving involves some
form of unification. Further examples of constraint systems of this kind are HERBRAND and DIM. We can
apply similar techniques as those introduced in Section 7 to show that HERBRAND and DIM satisfy the
principal constraint property.

The situation is different for the constraint system SC. There, the set S of solved forms consists of

10 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

(Var)

x : (8_ff:D ) o/ ) 2 \Gamma  _fi new

(C; ) = normalize(D; [ _fi=_ff])

jfv(\Gamma ); C; \Gamma  `W x : o/

(Abs) ; C; \Gamma x:x : ff `

W e : o/ ff new

nfffg; C; \Gamma x `W *x:e : (ff) ! o/

(App)

1; C1; \Gamma  `W e1 : o/1 2; C2; \Gamma  `W e2 : o/2

0 = 1 t 2
D = C1 ^ C2 ^ (o/1 _ o/2 ! ff) ff new

(C; ) = normalize(D; 0)
jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)

(Let)

1; C1; \Gamma x `W e : o/ (C2; oe) = gen(C1; 1\Gamma ; o/ )

2; C3; \Gamma x:x : oe `W e0 : o/ 0
0 = 1 t 2 D = C2 ^ C3

(C; ) = normalize(D; 0)
jfv(\Gamma 

x); C; \Gamma x `W let x = e in e0 : o/ 0

FIG. 3. Type inference
all satisfiable constraints. Given a constraint problem
(D; OE) we distinguish between two cases. If OED is unsatisfiable then (D; OE) does not have a normal form. Assume OED is satisfiable then (OED; id) is the principal normal form of (D; OE). Given another normal form (D0; OE0)
of (D; OE). Then it holds that OE ^ OE0 and D0 `e OE0D.
But then it follows immediately that (OED; id) is principal. We conclude that the constraint system SC satisfies
the principal constraint property, and that a normalize
function can be defined as follows:

normalize(C; OE)
= (OEC; id) if OEC is satisfiable
= fail otherwise

The normalization function is computable since satisfiability in SC is decidable. This follows easily by adapting techniques developed in [TS96].

6.2 Type inference algorithm

We now connect the principal constraint property of
a constraint system with the principal types property
of a type system. Figure 3 gives a generic type inference algorithm that computes principal types if the
constraint system satisfies the principal constraint property. The algorithm is formulated as a deduction system
over clauses of the form ; C; \Gamma  `W e : o/ with type environment \Gamma , expression e as input values and substitution , constraint C, type o/ as output values. For each
syntactic construct of expressions e we have one clause.

The deduction rules can be interpreted operationally, as
a logic program that constructs a bottom-up derivation
of `W clauses.

In the (Var) rule, we assume that an unqualified type
o/ can be represented as 8;:true ) o/ . This avoids a separate case of this rule for unqualified types. Note that
(Var) makes use of the function normalize, specified in
the last subsection. Our deduction rules yield an algorithm only if normalize is computable. In the following,
we assume that we are dealing only with computable
normalization functions.

The type inference algorithm `W is a straightforward extension of algorithm W, see [DM82]. The algorithm `W consists of the following three basic components: constraint generation, constraint normalization
and generalization of unbound type variables. All three
components can already be found in the original algorithm W but are now extended to deal with constraints.
We already discussed constraint generation and normalization. The generalization procedure for our algorithm
is left underspecified; we only require that it satisfies:

gen(C; \Gamma ; oe) = (D ^ 9_ff:C0; 8_ff:C0 ) oe)
where C is a constraint such that C =e C0 ^ D,
\Gamma  is a type environment, oe is a type scheme, _ff =
(fv(oe) [ fv(C))nfv(\Gamma ) and fv(D) " _ff = ;. That is, generalization splits a constraint into two parts. Generalized
variables can be free only in one of the two parts, C0,
but not the other, D. Only the C0 part ends up as a
constraint in the generalized type scheme. Note that
the above requirement can always be fulfilled by takTHEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 11

ing D to be true. However, depending on the actual
constraint system used there might exist better strategies, which keep the constraint in the generalized type
scheme smaller.

Our type inference algorithm interleaves constraint
generation and normalization. Each inference rule combines the constraint problems of the premises and performs then a normalization step. That means we perform strict normalization during type inference. In
essence, we only need to perform normalization right
before a (Let) rule (because the constraint in a type
scheme needs to be in normal form) or at the end. This
corresponds to lazy normalization. An example of a lazy
formulation of type inference for the Hindley/Milner
type system can already be found in [Wan87]. The following lemma states that both views are equivalent. We
can perform normalization in any order and always obtain the same result.

Lemma 9. Given constraints D; D0 and substitutions
OE; OE0. Then

normalize((D; OE) t (D0; OE0))

=
normalize(normalize(D; OE) t normalize(D0; OE0))

where the term (D; OE) t (D0; OE0) stands for (D ^ D0; OE t
OE0).

6.3 Main results

To state our main results concisely, we extend the
subsumption predicate _ to type schemes. Subsumption on type schemes is defined by a deduction system
with clauses of the form C `i oe _ oe0, which state that
the type scheme oe is more general than the type scheme
oe0 under the constraint C. The deduction system is defined as follows.

(Sub) C `

e (o/ _ o/ 0)

C `i o/ _ o/ 0

(_ 8) C ^ D `

i oe _ oe0 ff 62 tv(oe) [ tv(C)

C ^ 9ff:D `i oe _ (8ff:D ) oe0)

(8 _) C `

i [o/ =ff]oe _ oe0 C `e [o/ =ff]D

C `i (8ff:D ) oe) _ oe0
The result triple of the type inference algorithm `W
forms a typing configuration (C; oe; ), which consists of
a constraint C 2 S, a type scheme oe and a substitution
 such that C = C, oe = oe and  is consistent with
respect to \Gamma . A substitution OE is consistent with respect
to a type scheme oe = 8_ff:D ) o/ if D 2 S where we
assume there are no name clashes between _ff and .
This extends naturally to type environments. Given
two typing configurations (C; oe; ), (C0; oe0; 0) we say

(C; oe; ) is more general than (C0; oe0; 0) iff  ^OE

0

fv(\Gamma ) ,C0 `e OE0C and C0 `i OE0oe _ oe0. In such a situation we

write (C; oe; ) _ (C0; oe0; ).

Lemma 10. Given a type environment \Gamma  and a term e.
If ; C; \Gamma  `W e : o/ then (C; o/; ) is a typing configuration.

Furthermore, this typing configuration always represents a valid typing of the given term under the given
type environment.

Theorem 11 (Soundness of Inference). Given a
term e and a type environment \Gamma . If ; C; \Gamma  `W e : o/
then C; \Gamma  ` e : o/ , C = C and o/ = o/ .

A sketch of the proofs of soundness and completeness
of type inference can be found in the appendix. For a
more detailed discussion we refer to [Sul97].

We now discuss completeness of type inference for
HM(X) type systems. In general, we always require
that an HM(X) type system has to fulfill the principal
constraint property to achieve complete type inference.
But as it turns out this is not sufficient. There are examples of non-regular equational theories where unification is unitary (that means we have most general unifiers) but algorithm `W does not infer principal types.
An equational theory is regular if `e (o/ = o/ 0) implies
fv(o/ ) = fv(o/ 0). We say a constraint system X is regular
if the underlying equational theory is regular. An example of a non-regular theory is the dimension constraint
system DIM. We find that `e (prod(i(d); d) = 1) but
fv(prod(i(d); d)) = fdg 6= ; = fv(1). In Section 6.1
we observed that DIM satisfies the principal constraint
property. But algoritm `W fails to infer principal types
for the dimension type system HM(DIM). This observation is due to A.J. Kennedy. At the end of this section
we give a concrete example where we can see why algorithm `W fails.

Nevertheless, we can state a completeness theorem
for two large classes of HM(X) type systems. First, we
consider the class of constraint systems X where the
set S of solved forms in X contains all satisfiable constraints in X. We denote by X a the set of all those constraint systems that additionally satisfy the principal
constraint property. In the second class we put further
restrictions on the set S of solved forms. We assume
that all constraints in S are in simplified form, which
means that all non-trivial equality problems have been
resolved. A constraint C 2 S is in simplified form if
C `e (o/ = o/ 0) implies `e (o/ = o/ 0). We denote by X r
the set of all regular constraint systems X which satisfy
the principal constraint property and for which every
solved form is also a simplified form.

An example for a member of X a is the constraint
system SC. The constraint systems HERBRAND and
the record constraint system introduced in Section 7

12 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

are examples for members of X r. But DIM is not in X r
because DIM is non-regular.

To obtain a completeness result for type inference,
we assume that we have an HM(X) type system where
X belongs to X a or X r. Furthermore, we consider only
those typing judgments C; \Gamma  ` e : oe where the type
environment and the constraint on the left hand side of
the turnstile are realizable, i.e. have a type instance. A
type environment \Gamma  is realizable in a constraint C if for
every x : oe 2 \Gamma  there is a o/ such that C `i oe _ o/ .

Now, we present our completeness result. Informally
speaking, we want to have the following. Given a derivation C0; OE\Gamma  ` e : oe0, our type inference algorithm
should report a constraint that is at least as small as
C0 and a type that is at least as general as oe0.

Theorem 12 (Completeness of Inference). Let
C0; OE\Gamma  ` e : oe0 be a typing judgment such that OE\Gamma  is
realizable in C0. Then

; C; \Gamma  `W e : o/
for some substitution , constraint C, type o/ , such that

gen(C; \Gamma ; o/ ) = (Co; oeo)

(Co; oeo; ) _ (C0; oe0; OE)

The completeness theorem can be simplified for top-
level programs to the following corollary, which states
that our type inference algorithm computes principal
types.

Corollary. Let true; \Gamma  ` e : oe be a closed typing judgment such that \Gamma  is realizable in true. Then
OE; C; \Gamma  `W e : o/ for some substitution OE, constraint C,
such that

gen(C; OE\Gamma ; o/ ) = (true; oeo)

`i oeo _ oe

In the case of HM(X) type systems where X in X a we
have formulated the completeness result in more general terms than actually necessary. In Section 6.1 we
observed that normalization in SC corresponds to a satisfiability test. This observation can be generalized to
all constraint systems in the class X a. But then we can
conclude that type inference always returns the identity
substitution. Type inference only consists in accumulating constraints and checking whether the constraints
are satisfiable or not. This holds for the (Var) case.
We rename the bound type variables in the constraint
and check satisfiability of the renamed constraint. If
this constraint is satisfiable we return the renamed constraint. The renaming substitution is equivalent to the
identity substitution on the free type variables of the
given type environment. We find that no substitutions
are introduced in the base case nor through the normalization procedure. Then type inference in X a always returns the identity substitution. Hence, substitution 

is always the identity substitution in the completeness
theorem for the class X a.

In case of HM(X) type systems where X in X r we
have put stronger conditions on the set S of solved constraints. The set S must now be in simplified form.
Therefore, normalization also involves computation of
a residual substitution. The restriction to regular theories in case of the class X r is important to establish
complete type inference as we will see in the following
example, due to A.J. Kennedy [Ken96].

In the dimension type system HM(DIM), define an
initial type environment as follows:

\Gamma  = fkg : dim M

s : dim T
div : 8d1; d2: dim prod(d1; d2) !

dim d1 ! dim d2
pair : 8t1; t2:t1 ! t2 ! t1 \Theta  t2g

Here, kg and s are some basic dimensions, pair is the
pairing operator and div is a primitive operation on dimensions. Now consider the following expression:

e = *x:let y = div x in pair(y kg)(y s)
We want to type e under the type environment \Gamma . The
subexpression div x has the following type under type
environment \Gamma :x : dim prod(d1; d2) :

\Gamma :x : dim prod(d1; d2) ` div x : dim d1 ! dim d2
Here, it is not possible to quantify over the type variables d1 and d2. But we can derive another type for
div x under the same type environment:

\Gamma :x : dim prod(d1; d2)

`
div x : dim prod(d1; d3) ! dim prod(i(d3); d2)

We have simply instantiated d1 with prod(d1; d3) and
d2 with prod(i(d3); d2). Kennedy calls this the problem
of unrevealed polymorphism. Neither of the two types
for div x is more general than the other, and there is
no third type that generalizes both. Hence, algorithm
`W fails to infer a principal type for expression e under
type environment \Gamma .

It is interesting to point out that `W computes principal types for dimension types if S contains all satisfiable constraints in DIM. Then DIM belongs to X a and
for that class we have a completeness result. The reason is that now all unification problems are explicit. No
unification is involved during type inference. Type inference performs only a satisfiability test. The problem
of unrevealed polymorphism comes into play if normalization involves unification in a non-regular theory.

7. Polymorphic records

Following ideas of Ohori [Oho95] we give an instance
of our HM(X) system which deals with polymorphic

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 13

records. Ohori's system, abbreviated O in the following, has besides type variables and function types also
record types denoted by fl1 : o/1; : : : ; ln : o/ng, where li
is an element of an enumerable set of record labels. We
assume that there is an ordering relation between all
field labels. All record fields are ordered with respect
to this ordering relation. Because we have a fixed ordering of record fields we can apply Herbrand unification
for solving equality constraints between records.

Type quantification in O is kinded; in the type
scheme 8ff:ff :: ^ ) oe the type variable ff ranges only
over kind ^. A kind is of the form hl1 : o/1; : : : ; ln : o/ni;
it comprises all records that contain at least fields
l1; : : : ; ln with types o/1; : : : ; o/n.

Instead of a constraint on the left hand side of a
typing judgment, Ohori uses a kind assignment K which
can be considered as a function which assigns each type
variable ff its kind k. He writes K ^ (ff :: k) for the
disjoint extension of K with a new type variable ff with
kind k.

Here's an example of a program typed in O.

Example 13.

f: 8ff; fi:(ff :: hl : fii) ) ff ! Int
f x =

let g: fi ! Bool

g = * y. eq y (x.l)
in 1

We use a Haskell-style notation, with type scheme annotations added for illustration purposes. The program
assumes that there is a function

eq : 8ff:ff ! ff ! Bool
in the initial type environment.

7.1 Type system

We now translate O into the HM(X) framework. We
add to the initial type environment \Gamma 0 primitive constructs that deal with record formation, selection and
update. For every ordered sequence of record labels
l1; : : : ; ln we postulate an n-ary parameterized data
type Rl1 ::: l

n. The record type fl1 : o/1; : : : ; ln : o/ng isthen represented as R

l1 ::: lno/1 : : : o/n. For simplicity we
will keep using the record type notation as a synonym

for the datatype notation. For every record datatype
Rl1 ::: l

n we have in the initial environment a datatypeconstructor

l1 : : : ln : o/1 ! : : : ! Rl1 ::: l

no/1 : : : o/n

Then, l1 : : : ln e1 : : : en represents record formation
fl1 = e1; : : : ; ln = eng. For each field label l we add
to the initial type environment \Gamma 0 the two functions

.l : 8ff; fi:(ff :: hl : fii) ) ff ! fi
modifyl : 8ff; fi:(ff :: hl : fii) ) ff ! fi ! ff

The first function corresponds to record selection, the
second to record update.

Kinded quantification in O is modeled by primitive
constraints of the form (o/ :: k) where o/ is a type and k
is a kind. Technically, this means we add (o/ :: k) to the
set \Omega  of primitive constraints where (::) is a primitive
predicate of arity 2. We define REC as the smallest term
constraint system that satisfies the following additional
rules:

REC1 `e (fl1 : o/1; : : : ln : o/ng :: hli : o/ii)

where l1; : : : ; ln are distinct
REC2 (o/ :: hl : o/1i) ^ (o/ :: hl : o/2i) `e (o/1 = o/2)
REC3 (f: : : ; l : o/1; : : :g :: hl : o/2i) `e (o/1 = o/2)
REC4 9ff:(ff :: k) =e true

where ff 62 fv(k)

Note that these conditions rule out recursive records,
since our type algebra does not have recursive types.
On the other hand, we do allow recursive constraints
between type variables in REC. For instance, the constraint (ff :: hl : ff ! ffi) is well-formed. But that constraint is not satisfiable and therefore cannot appear as
a solved form. Also ruled out (by conditions REC2
and REC3) is overloading of field labels.

The set S of solved forms in HM(REC) consists of
all satisfiable constraints of the form

C ::= fg j (ff :: hl : o/ i) j C ^ C j 9_ff:C
where we take the empty token set as a representation
of true. Furthermore, we require that the constraints in
S are in simplified form, i.e. C `e (o/ = o/ 0) must imply
`e (o/ = o/ 0). For instance,

(ff :: hl : fii) ^ (ff :: hl : fl ! fli)
is not in simplified form and is therefore excluded.

The type system HM(REC) is as given in Figure 2,
with subsumption (_) being modeled by (=). As an
example, here the annotated program from Example 7
re-formulated in HM(REC):

Example 14.

f: 8ff:(9fi:(ff :: hl : fii)) ) ff ! Int
f x =

let g : 8fi:(ff :: hl : fii) )

fi ! Bool
g = * y. eq y (x.l)
in 1

In HM(REC) we quantify in the innermost let over
type variable fi, leaving just ff to be quantified in the
toplevel function f. This is not possible in O, since
ff's kind depends on fi. The question arises whether
this makes HM(REC) a more permissive type system
than O. Specifically, are there examples where we
can use function g polymorphically? The answer is
no. Every instance of g has to satisfy the constraint

14 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

9fi:(ff :: hl1 : fii). But ff can only have one field entry
with label l1. Therefore, we can use g in the let-body
only monomorphically. In general, we can observe that
O and HM(REC) type exactly the same programs, but
the types are more precise in HM(REC).

Theorem 13 Full and Faithful. Every program typable in O is typable in HM(REC) and vice versa.

7.2 Type inference

We now consider type inference for HM(REC). Since
REC is a regular constraint system, we can obtain type
inference with principal types, provided it fulfills the
principal constraint property. To show the principal
constraint property for REC, we proceed in three steps.
First, we show that it is always possible to formulate
a constraint as a projection over a projection-free subpart. A constraint D is projection-free if D (considered
as a set) contains only tokens of the form (ff :: k) and
(o/ = o/ 0). Then we give a procedure which computes the
principal normal form of projection-free constraints, or
fails if no normal form exists. Finally, we show that
it is sufficient to compute principal normal forms of
projection-free constraints. This is achieved by a lifting
method. Given an arbitrary constraint C we compute
the principal normal form of the projection-free part.
Then we lift this result to the projected part. We show
that this lifting method is sound and complete.

In a first step we transform a constraint into a projection over a projection-free subpart. The idea is that
we can always rename type variables which are bound
by the projection operator. It holds that

9ff:C =e 9fi:[fi=ff]C
where fi is a new type variable. That means, w.l.o.g.
there are no name clashes between two projected constraints (9ff:C)^(9fi:D). Then we can lift all projection
operators to the outermost level using condition E3 of
a cylindric constraint system:

(9ff:C) ^ (9fi:D) =e 9ff:(9fi:(C ^ D))
We can summarize these observations in the following
lemma.

Lemma 14. Let C 2 REC. Then there exists a
projection-free constraint D such that C =e 9_ff:D .

In the next step we show how to compute principal normal forms for projection-free constraints. We
assume that we have a projection-free constraint D
which contains only primitive predicates of the form
(=) and (::). W.l.o.g., we can assume that all predicates (::) are of the form (ff :: k). This can be achieved
because we know that

(o/ :: k) =e 9ff:((ff = o/ ) ^ (ff :: k))

where ff is a new type variable. The closure Cl(D) of
D is the smallest constraint which fulfills the following
conditions:

1. D ` Cl(D)
2. If (ff = fl1 : o/1; : : : ; ln : o/ng) 2 Cl(D)

then (ff :: hl1 : o/1i); : : : ; (ff :: hln : o/ni) 2 Cl(D)
3. If (ff :: hl : o/1i); (ff :: hl : o/2i) 2 Cl(D)

then (o/1 = o/2) 2 Cl(D)

From a semantic view point we have not done anything because Cl(D) =e D. We only have changed
the syntactic representation of D. The intention of
building the closure of D is to generate all predicates
(o/ :: hl : o/ 0i) which might cause any inconsistencies.
Given all such predicates we can generate all unification problems (o/ = o/ 0) which have to be resolved. The
following lemma states that we really have generated all
such predicates.

Lemma 15. Given a field label l and types o/; o/ 0. If
6 `e (o/ :: hl : o/ 0i) then (o/ :: hl : o/ 0i) 2 Cl(D) iff D `e
(o/ :: hl : o/ 0i). Furthermore, if 6 `e (o/ = o/ 0) then (o/ =
o/ 0) 2 Cl(D) iff D `e (o/ = o/ 0).

We can apply unification over Herbrand terms [Rob65]
to resolve all equality predicates (=) in Cl(D). We obtain a most general unifier OE of the equality predicates
(=) in Cl(D). It remains to check whether this most
general unifier OE is consistent with Cl(D). This can be
done by checking whether there are any inconsistencies
in OECl(D). If not, (OECl(D); OE) represents the principal
normal form of (D; id). We can summarize this observation in the following lemma.

Lemma 16. Given a projection-free constraint D 2
REC and a substitution OE. Then (D; OE) has a principal
normal form, which can be computed by the procedure
described above, or else no normal form exists.

It remains to lift this procedure to arbitrary constraints. First, we state some essential lemmas that are
necessary to establish this lifting method. Then we apply this lifting method to state that REC satisfies the
principal constraint property.

The next lemma gives us a procedure to lift principal
normal forms of constraints to arbitrary constraints. It
states that whenever we can compute the principal normal form of a constraint D then we get the principal
normal form of the constraint 9ff:D for free.

Lemma 17. Let D 2 REC and OE be a substitution where ff 62 codom(OE) [ dom(OE). If
(C; ) = normalize(D; OE) then (9ff:C; nfffg) =
normalize(9ff:D; OE).

The next lemma states that a normal form of a constraint exists iff a normal form of the projected constraint exists.

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 15

Lemma 18. Given a substitution OE where ff 62
codom(OE) [ dom(OE) and a constraint D 2 REC. Then
(D; OE) has a normal form iff (9ff:D; OE) has a normal
form.

We have now everything at hand to prove that REC
satisfies the principal constraint property. The proof of
the theorem consists in describing a method how to lift
computation of principal normal forms for projection-
free constraints to arbitrary constraints.

Theorem 19. The constraint system REC satisfies the
principal constraint property.

Proof. Given an arbitrary constraint problem
(D; OE) where D =e 9_ff:D0 such that D0 is projection-
free. We consider two cases.

First, assume (D; OE) has no normal form. Because of
Lemma 18 we know that this holds iff (D0; OE) does not
have a normal form either. The latter can be checked
by the normalization procedure for projection-free constraints.

Now, assume (D; OE) does have a normal form. We
apply Lemma 18 and find that the normal form of
(D0; OE) exists. By assumption we know how to normalize (D0; OE). That means (D0; OE) does have a principal
normal form and we can compute its principal normal
form. With Lemma 17 we can lift the principal normal form of the projection-free constraint problem and
obtain the principal normal form of (D; OE).

We can conclude that REC satisfies the principal
constraint property.

8. Conclusion

We have presented a general framework for Hindley/Milner style type systems with constraints. An innovative aspect of the framework is its new formulation of the quantifier introduction rule, which avoids
problems in previous work. The formulation requires
the presence of a projection operator 9 on constraints.
This requirement was the main motivation to progress
from a syntactic notion of constraints as sets of formulas to a semantic notion of constraints as cylindric
algebras. Cylindric algebras always have a projection
operator even though the operator need not be present
in syntactic form. Projection is also readily available for
the syntactic constraint systems that have been used in
type system literature. A simple way to introduce it is
by marking some variables as projected. In fact such
a marking can usually be reconstructed from a type
judgment: simply mark all variables that appear free in
neither the final type schemes or the final type environment as projected.

Projection provides an important opportunity for
constraint simplification: It is legal to eliminate variables from constraints as long as these variables are

projected since such an elimination does not change the
constraint's denotation. Simplification in the context
of subtypes has already been studied by Pottier [Pot96]
and the Hopkins Object Group [TS96]. We plan to
investigate in the future how their simplification techniques fit into the HM(X) framework.

Since our framework also includes a subsumption
rule based on a given subsumption relation in the constraint system, it can be adapted to a wide variety of
type system instances. For instance, the classical Hindley/Milner system falls out by taking subsumption to be
syntactic equality in a free algebra, Wand/R'emy style
records [R'em89, Wan89] or dimension types [Ken96] fall
out by taking some richer notion of equality as subsumption, and standard object calculi [EST95a] fall out
by identifying the subtyping and the subsumption relations.

We could give a type soundness result for sound and
coherent HM(X) type systems based on a standard untyped denotational semantics. Furthermore, we formulated a generic type inference algorithm for HM(X) type
systems. For a large class of constraint systems we could
state sufficient conditions under which type inference
computes principal types. To design a full language or
static analysis based on our approach, one must simply check that the conditions on the constraint system
are met. If this is the case, one gets a type inference
algorithm and the principal type property for free.

We hope that our results will open the door to a new
class of program analyses for program checking which
can be tailored to specific application domains. For
instance, it should be possible to add a dimension analysis to an existing programming language after the fact
and in a modular way, without changing the semantics
of the base language or its compiler. Our type system framework would then be the basis of a language
tool framework which can be tailored to specific analysis needs. The construction and investigation of such a
tool framework remains a topic for future research.

ACKNOWLEDGEMENTS
We thank Alex Aiken, Kim Marriott, Harald Sondergaard, Phil Wadler and the referees for their valuable
comments.

References
AW93. Alexander Aiken and Edward L. Wimmers. Type inclusion

constraints and type inference. In FPCA '93: Conference on
Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, pages 31-41, New York, June
1993. ACM Press.

BM97. Fran,cois Bourdoncle and Stephan Metz. Type Checking Higher-Order Polymorphic Multi-Methods. In Confer16 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

ence Record of the Twentyfourth Annual ACM Symposium on
Principles of Programming Languages, Paris, France. ACM
Press, January 1997.

BSvG95. Kim B. Bruce, Angela Schuet, and Robert van Gent.

Polytoil: A type-safe polymorphic object-oriented language
(extended abstract). In Procceding of ECOOP, pages 27-51.
Springer Verlag, 1995. LNCS 952.

CCH+89. Peter Canning, William Cook, Walter Hill, Walter

Olthoff, and John C. Mitchell. F-bounded polymorphism
for object-oriented programming. In Functional Programming Languages and Computer Architecture, pages 273-280,
September 1989.

CHO92. Kung Chen, Paul Hudak, and Martin Odersky. Parametric type classes. In Proc. of Lisp and F.P., pages 170-191.
ACM Press, June 1992.

CW85. Luca Cardelli and Peter Wegner. On understanding types,

data abstraction, and polymorphism. Computing Surveys,
17(4):471-522, December 1985.

DHM95. Dirk Dussart, Fritz Henglein, and Christian Mossin.

Polymorphic binding-time analysis in polynomial time. In
Proceedings of SAS, pages 118-135. Springer Verlag, September 1995.

DM82. L. Damas and R. Milner. Principal type-schemes for functional programs. In Conference Record of the Ninth Annual
ACM Symposium on Principles of Programming Languages,
pages 207-212. ACM, ACM, January 1982.

EST95a. J. Eifrig, S. Smith, and V. Trifonov. Sound polymorphic

type inference for objects. In OOPSLA '95 Conference Proceedings, volume 30(10) of ACM SIGPLAN Notices, pages
169-184, 1995.

EST95b. Jonathan Eifrig, Scott Smith, and Valery Trifonov. Type

inference for recursivly constrained types and its application
to object oriented programming. In Electronic Notes in Theoretical Computer Science, volume 1, 1995.

HMT71. L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebra.

North-Holland Publishing Company, 1971.

JM94. Joxan Jaffar and Michael Maher. Constraint logic programming: A survey. Journal of Logic Programming,
19(20):503-581, 1994.

Jon92. Mark P. Jones. Qualified Types: Theory and Practice.

D.phil. thesis, Oxford University, September 1992.

Jon95. Mark P. Jones. Simplifying and improving qualified types.

In FPCA '95: Conference on Functional Programming Languages and Computer Architecture. ACM Press, 1995.

GLS96. James Gosling, Bill Joy, and Guy Steele. The Java language specification. Java Series, Sun Microsystems, ISBN
0-201-63451-1, 1996.

Kae92. Stefan Kaes. Type inference in the presence of overloading, subtyping and recursive types. volume 5, pages 193-204,
1992. Proceedings of the 1992 ACM Conference on LISP and
Functional Programming.

Ken96. Andrew J. Kennedy. Type inference and equational theories. Technical Report LIX/RR/96/09, LIX, Ecole Polytechnique, 91128 Palaiseau Cedex, France, September 1996.

LMM87. J. Lassez, M. Maher, and K. Marriott. Unification

revisited. In J. Minker, editor, Foundations of Deductive
Databases and Logic Programming. Morgan Kauffman, 1987.

Mil78. Robin Milner. A theory of type polymorphism in programming. Journal of Computer and System Sciences, 17:348-
375, Dec 1978.

Mit84. John C. Mitchell. Coercion and type inference. In Proceedings of the 11th ACM Symposium on Principles of Programming Languages, pages 175-185, 1984.

MPS86. D. MacQueen, G. Plotkin, and R. Sethi. An ideal model

for recursive polymorphic types. Information and Control,
71:95-130, 1986.

NP93. Tobias Nipkow and Christian Prehofer. Type checking type

classes. In Conference Record of the Twentieth Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina, January 10-
13, 1993, pages 409-418. ACM Press, January 1993.

Oho95. Atsushi Ohori. A polymorphic record calculus and its

compilation. ACM TOPLAS, 6(6):805-843, November 1995.

OWW95. Martin Odersky, Philip Wadler, and Martin Wehr. A

second look at overloading. In Proceedings of the Seventh
International Conference on Functional Programming Languages and Computer Architecture (FPCA'95), pages 135-
146, La Jolla, California, June 25-28, 1995. ACM SIGPLAN/SIGARCH and IFIP WG2.8, ACM Press.

Pal95. Jens Palsberg. Efficient inference of object types. Information and Computation, 123(2):198-209, 1995.

Pot96. Francois Pottier. Simplifying subtyping constraints. In

International Conference on Functional Programming, pages
122-133, May 1996.

R'em89. D. R'emy. Typechecking records and variants in a natural

extension of ML. pages 77-88. ACM, January 1989.

R'em92a. Didier R'emy. Extending ML type system with a sorted

equational theory. Research Report 1766, Institute National
de Recherche en Informatique et en Automatique, 1992.

R'em92b. Didier R'emy. Typing record concatenation for free. In

ACM, editor, Conference record of the Nineteenth Annual
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages: papers presented at the symposium,
Albuquerque, New Mexico, January 19-22, 1992, pages 166-
176, New York, NY, USA, 1992. ACM Press.

Rey85. John C. Reynolds. Three approaches to type structure. In Proceedings TAPSOFT/CAAP 1985, pages 97-138.
Springer-Verlag, 1985. Lecture Notes in Computer Science
185.

Rob65. J. A. Robinson. A machine-oriented logic based on the

resolution principle. Journal of the Association for Computing Machinery, 12:23-41, 1965.

Sar93. Vijay A. Saraswat. Concurrent Constraint Programming. Logic Programming Series, ACM Doctoral Dissertation
Award Series. MIT Press, Cambridge, Massachusetts, 1993.

Smi91. Geoffrey S. Smith. Polymorphic type inference for languages with overloading and subtyping. PhD thesis, Cornell
University, Ithaca, NY, August 1991.

Sul97. Martin Sulzmann. Proofs of Soundness and Completeness of Type Inference for HM(X). Research Report
YALEU/DCS/RR-1102, Yale University, Department of
Computer Science, February 1997.

TJ92. Jean-Pierre Talpin and Pierre Jouvelot. The type and effect

discipline. In Seventh Annual IEEE Symposium on Logic in
Computer Science, Santa Cruz, California, pages 162-173,
Los Alamitos, California, June 1992. IEEE Computer Society
Press.

TS96. Valery Trifonov and Scott Smith. Subtyping Constrained

Types. In Proceedings of the Third Internationl Static Analysis Symposium, volume 1145 of LNCS, pages 349-365, 1996.

VHJW96. Cordelia V.Hall, Kevin Hammond, Simon L. Peyton

Jones, and Philip L. Wadler. Type classes in Haskell. ACM
TOPLAS, 18(2):109-138, March 1996.

Wan87. Mitchell Wand. A simple algorithm and proof for type

inference. In Fundamenta Informaticae X, pages 115-122.
North-Holland, 1987.

Wan89. Mitchell Wand. Type inference for record concatenation

and multiple inheritance. In Proceedings of the IEEE Symposium on Logic in Computer Science, pages 92-97, June 1989.

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 17

Appendix: Proof of Theorem 11 (Soundness)

The following two lemmas can both be proven by
a straightforward induction on the derivation ` . We
say a substitution OE is consistent with respect to a type
scheme oe = 8_ff:D ) o/ if D 2 S where we assume
there are no name clashes between _ff and . This extends naturally to type environments. Furthermore, a
substitution OE is consistent with respect to a constraint
C if OEC 2 S.

Lemma 1. Given C; \Gamma  ` e : oe and a substitution OE
such that OE is consistent with respect to C and \Gamma . Then
OEC; OE\Gamma  ` e : OEoe.

Lemma 2. Given C; \Gamma  ` e : oe and a constraint D 2 S
such that D `e C. Then D; \Gamma  ` e : oe.

We restate Theorem 11 in the following lemma.
Lemma 3 Soundness of `W . Given a type environment \Gamma  and a term e. If ; C; \Gamma  `W e : o/ then
C; \Gamma  ` e : o/ , C = C and o/ = o/ .

Proof. We apply induction on the derivation `W .
We only consider one case. The other cases can be
proven in a similar style.

Case (App) We have the following situation:

1; C1; \Gamma  `W e1 : o/1 2; C2; \Gamma  `W e2 : o/2

0 = 1 t 2
D = C1 ^ C2 ^ (o/1 _ o/2 ! ff) ff new

(C; ) = normalize(D; 0)
jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)

We apply the induction hypothesis to the left and right
premise and obtain

C1; 1\Gamma  ` e1 : o/1 1C1 = C1 1o/1 = o/1
and

C2; 2\Gamma  ` e2 : o/2 2C2 = C2 2o/2 = o/2
With Lemma 2 we can conclude that

C; 1\Gamma  ` e1 : o/1 C; 2\Gamma  ` e2 : o/2
W.l.o.g. we can assume that all identifier in \Gamma  are contained in e1 and e2 and not more. This fact and normalization ensures that  is consistent in C and \Gamma . Then
we can apply Lemma 1 and obtain

C; \Gamma  ` e1 : o/1 C; \Gamma  ` e2 : o/2
We know that C `e (o/1 _ o/2 ! (ff)) and apply the
(Sub) rule to get C; \Gamma  ` e : o/2 ! (ff). It remains
to apply the (App) rule and we find

C; \Gamma  ` e1e2 : (ff)

Appendix: Proof of Theorem 12 (Completeness)

We give now a proof sketch for completeness for
HM(X) type systems where X 2 X r satisfies the principal constraint property. Some technical lemmas (which
we will point out) rely on the fact that X is regular. The
proof for X ais similar, but there we only need weaker
versions of these technical lemmas which do not rely
on the regularity of the constraint system. In order to
prove completeness we have to do a little more work.
The idea is to introduce two intermediate derivations,
and to show that all derivations have the same expressive power.

First, we introduce some conventions. The generalization procedure gen takes a constraint C, a type environment \Gamma  and a type o/ and returns the generalized constraint and type, written gen(C; \Gamma ; o/ ) = (C0; oe). We use
two specialized generalization versions: gen1(C; \Gamma ; o/ ) returns only the constraint part and gen2(C; \Gamma ; o/) returns
only the type scheme part.

We introduce some basic lemmas. Most of them
are stated without proof. A detailed discussion can be
found in [Sul97]. The following two lemmas rely on the
fact that we only consider regular theories. We give the
proof for one lemma where one can see that X needs to
be a regular theory. The first lemma states that we can
lift entailment between two constraints to the generalized constraints.

Lemma 1. Given a type context \Gamma , constraints C; ~C,
types o/; o/ 0 and substitutions OE; OE0;  such that C `e OE0 ~C
and  ^OE

0

fv(\Gamma ) OE. Then Co `

e OE0 ~Co where Co =

gen2(C; OE\Gamma ; o/ 0) and ~Co = gen2( ~C; \Gamma ; o/ ).

Proof. W.l.o.g. we assume Co = 9_ff:C and~
Co = 9 _fi: ~C. We show that _ff 62 fv(OE0 ~Co). Assume the
contrary. W.l.o.g.

_ff 62 fv(\Gamma ) [ fv( ~Co) [ codom(OE) (A1)
because we can always rename bound variables and during type inference always new type variables have been
introduced. That means there is a fl 2 fv( ~Co) such that

_ff 2 fv(OE0(fl)). Further it holds that fl 62 fv(\Gamma ). Assume fl 2 fv(\Gamma ) then there is a ffi 2 fv(\Gamma ) such that
ffi 2 fv((fl)). We know that OE(ffi) = OE0 ffi (ffi) (here
we need the fact that X is regular, both sides of the
equation contain the same set of free variables) and
then we find _ff 2 codom(OE) which is a contradiction
to A1. We get fl 62 fv(\Gamma ) and fl 2 fv( ~Co). But this is
again a contradiction because ~Co is a generalized constraint. Our starting assumption was false and we find
that _ff 62 fv(OE0 ~Co).

18 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

Now, we can conclude that ~C `e ~Co. Then it follows
that OE0 ~C `e OE0 ~Co. This yields C `e OE0 ~Co. Finally, we
obtain Co `e 9_ff:OE0 ~Co and because _ff 62 fv(OE0 ~Co) that
we means we get Co `e OE0 ~Co as desired.

Remark. The proof of the previous lemma relies on
the fact that X is regular. For X in X a we only need a
restricted version of this lemma. Therefore, we still can
achieve complete type inference for X in X a.

The next lemma is similar to the previous one, except
that it compares types instead of constraints.

Lemma 2. Given a type context \Gamma , constraints C; ~C,
types o/; o/ 0 and substitutions OE; OE0;  such that C `e
OE0 ~C, C `i OE0o/ _ o/ 0 and  ^OE

0

fv(\Gamma ) OE. Then `

i OE0~oeo _

oeo where oeo = gen1(C; OE\Gamma ; o/ 0) and ~oeo = gen1( ~C; \Gamma ; o/ ).

The next lemma states that we can lift some properties about a constraint and a substitution to the same
constraint but extended substitution.

Lemma 3. Given a set U of variables, constraints
C1; C0 and substitutions ; 1; 2; OE; OE1 such that
1C1 = C1, C0 `e OE01C1,  = 1 t2,  ^OE

0

U OE, 1 ^

OE

0

1U

OE, codom(2)"fv(C1) ` U and codom(1)"fv(C2) ` U .
Then C0 `e (OE0 ffi )C1.

The next Lemma is similar to the previous one but
it is stated for the `i relation.

Lemma 4. Given a set U of variables, a constraint
C0, type schemes ~oe; oe00 and substitutions ; 1; 2; OE; OE1
such that 1~oe = ~oe, C0 `i OE01~oe _ oe00,  = 1 t 2,

 ^OE

0

U OE, 1 ^

OE

0

1U OE, codom(2) " fv(C1) ` U and

codom(1) " fv(C2) ` U . Then C0 `i (OE0 ffi )~oe _ oe00.

Now, we introduce the intermediate derivations. We
introduce a derivation `2 which is based on derivation
` in figure 2. Instead of rule (8 Elim) we have the
following new rule:

(Inst) C; \Gamma  `2 x : o/ (x : oe 2 \Gamma  C `i oe _ o/ )
All other rules stay unchanged. Note, also the (Var)
rule is still present in derivation `2 . The idea of derivation `2 is simply to enforce (8 Elim) steps as early as
possible.

Next, we consider a syntax directed derivation `d .
We also want to get rid of the (8 Intro) rule. This rule is
combined with the (Let) rule. Furthermore, the (Var)

and (Inst) rules are combined in the (Var-Inst) rule.
The rules are as follows:

(Var-Inst) C; \Gamma  `d x : o/ (x : oe 2 \Gamma  C `i oe _ o/ )

(Abs) C; \Gamma x:x : o/ `

d e : o/ 0

C; \Gamma x `d *x:e : o/ ! o/ 0

(App) C; \Gamma  `

d e1 : o/1 ! o/2 C; \Gamma  `d e2 : o/1

C; \Gamma  `d e1e2 : o/2

(Sub) C; \Gamma  `

d e : o/ C `e (o/ _ o/ 0)

C; \Gamma  `d e : o/ 0

(Let)

C; \Gamma x `d e : o/ (C0; oe) = gen(C; \Gamma x; o/ )

C00; \Gamma x:x : oe `d e0 : o/ 0
C0 ^ C00; \Gamma x `d let x = e in e0 : o/ 0

In the (Let) rule we implicitely require that the constraint C0^C00 is in solved form. Remember that the set
of constraints of solved forms is not necessarily closed
under ^. That means, when we apply the (Let) rule we
always have to ensure that C0 ^ C00 is in solved form.

The next lemmas state how these derivations are connected. The first two of these lemmas can both be
proven by a straightforward induction on the derivation
relation.

Lemma 5 Equivalence of ` and `2 . Given a type
environment \Gamma , a constraint C, a term e and a type
scheme oe. Then C; \Gamma  ` e : oe iff C; \Gamma  `2 e : oe.

Lemma 6 Soundness of `d . Given C; \Gamma  `d e : o/ .
Then C; \Gamma  ` e : o/ .

We now show that `d is complete with respect to `2
and `W is complete with respect to `2 . In order to
prove it we have to strengthen the assumption about the
given type environment. This is due to the (Let) rule
where the two premises use different type environments.
Therefore, we introduce the following definition.

Definition. Let C be a constraint and \Gamma  and \Gamma 0 be
type environments such that \Gamma  = fx1 : oe1; : : : ; xn : oeng
and \Gamma 0 = fx1 : oe01; : : : ; xn : oe0ng. Then C `i \Gamma 0 _ \Gamma  iff
C `i oe0i _ oei 8i : i 2 f1; : : : ; ng.

In the following theorem it is essential that the type
environment \Gamma 0 is realizable. Remember, a type environment \Gamma 0 is realizable in a constraint C if for every
x : oe 2 \Gamma 0 there is a o/ such that C `i oe _ o/ .

Lemma 7 Completeness of `d . Given C0; \Gamma 0 `2
e : oe0, C0 `i \Gamma  _ \Gamma 0 and \Gamma 0 is realizable in C0. Then

(a) oe0 = o/ : C; \Gamma  `d e : o/ C0 `e C
(b) otherwise : C; \Gamma  `d e : o/ (oeo; Co) = gen(C; \Gamma ; o/ )

C0 `e Co C0 `i oeo _ oe

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 19

Proof. We use induction on the derivation `d .
Due to space limitation we only show two cases.

Case (Var) We know that C0; \Gamma 0 `2 x : oe0 where x :
oe0 2 \Gamma 0. By assumption we know there is a x : oe in
\Gamma  such that C0 `i oe _ oe0. If oe0 = o/ then we can
immediately apply the (Var-Inst) rule and we are done.
Otherwise, w.l.o.g. we can assume that oe = 8_ff:D ) o/ 0.
We set C = [ _fi=_ff]D and o/ = [ _fi=_ff]o/ 0 where _fi are fresh
type variables. We apply again the (Var-Inst) rule and
find C; \Gamma  `d x : o/ . We set (oeo; Co) = gen(C; \Gamma ; o/ ) where
oeo is essentially a renamed version of oe. We find that
C0 `i oeo _ oe0. By assumption \Gamma 0 is realizable in C0,
hence there is a o/ such that C0 `e [_o/ =_ff]D. This leads
us to the conclusion that C0 `e Co and we are done.

Case (Let) We have the following situation:

C0; \Gamma 0x `2 e : oe C0; \Gamma 0x:x : oe `2 e0 : o/ 0

C0; \Gamma 0x `2 let x = e in e0 : o/ 0

First, we consider the case if oe is a type o/ . We apply the induction hypothesis to left premise and obtain C1; \Gamma x `d e : o/ and C0 `e C1. We set
(oeo; Co) = gen(C1; \Gamma x; o/ ). It is an easy observation
that C0 `i oeo _ o/ holds. Now, we apply the induction hypothesis to the right premise. This yields
C2; \Gamma x:x : oeo `d e0 : o/ 0 and C0 `e C2. We know
that C0 `e Co ^ C2 which ensures that Co ^ C2 is in
solved form. We can apply the (Let) rule and obtain
Co ^ C2; \Gamma x `d let x = e in e0 : o/ 0.

Now, let us consider the case if oe is a type scheme.
Application of the induction hypothesis to the left
premise yields:

C1; \Gamma x `d e : o/ (oeo; Co) = gen(C1; \Gamma x; o/ )

C0 `i oeo _ oe C0 `e Co:

To apply the induction hypothesis to the right premise
we have to show that \Gamma 0x:x : oe is realizable in C0. We
know that C0; \Gamma 0x:x : oe `2 e : o/ 0 holds. If x does not
appear in the free variables of e it is sufficient to consider only \Gamma 0x which is by assumption realizable. Otherwise we know that that the type of x must have been
instantiated to a monomorphic type which shows that
\Gamma 0x:x : oe is realizable in C0. Then we can apply the
induction hypothesis to the right and find

C2; \Gamma x:x : oeo `d e : o/ 0 C0 `e C2:
We can conclude that C0 `e Co ^C2 which ensures that
Co ^ C2 is in solved form. We can apply the (Let) rule
and find

Co ^ C2; \Gamma x `d let x = e in e0 : o/ 0

Lemma 8. (Completeness of `W ) Given C0; OE\Gamma  `d
e : o/ 0. Then

; C; \Gamma  `W e : o/

for some substitutions , OE0, constraint C and type o/
such that,

 ^OE

0

fv(\Gamma ) OE C0 `

e OE0C C0 `i OE0o/ _ o/ 0

Proof. We use induction on the derivation `d .
Due to space limitation we only show the two interesting
cases.

Case (App) We have the following situation:

C0; OE\Gamma  `d e1 : o/ 01 ! o/ 02 C0; OE\Gamma  `d e2 : o/ 01

C0; OE\Gamma  `d e1e2 : o/ 02

Application of the induction hypothesis yields

1; C1; \Gamma  `W e1 : o/1 1 ^OE

0
1

fv(\Gamma ) OEC0 `e OE0

1C1 C0 `i OE01o/1 _ o/ 01 ! o/ 02

(A2)

and

2; C2; \Gamma  `W e2 : o/2 2 ^OE

0
2

fv(\Gamma ) OE

C0 `e OE02C2 C0 `i OE02o/2 _ o/ 01

We set 0 = 1 t 2. Then we find that 0 ^OE

0

fv(\Gamma ) OE.We want to apply Lemmas 3, 4. We identify the set

U in these lemmas with fv(\Gamma ). We assume that type
variables introduced in one part of the inference tree do
not appear in the other part. Formally, this means that

codom(2) " fv(C1) ` fv(\Gamma )
and

codom(1) " fv(C2) ` fv(\Gamma )

All preconditions of Lemmas 3, 4 are fulfilled. We can
conclude that

C0 `e (OE0 ffi 0)C1 C0 `i (OE0 ffi 0)o/1 _ o/ 01 ! o/ 02

C0 `e (OE0 ffi 0)C2 C0 `i (OE0 ffi 0)o/2 _ o/ 01

We set D = C1 ^ C2 ^ (o/1 _ o/2 ! ff) where ff is a fresh
type variable. Then we obtain that C0 `e (OE0 ffi 0 ffi
[o/ 02=ff])D. We find that (C0; OE0 ffi 0 ffi [o/ 02=ff]) is a normal
form of (D; 0). By assumption HM(X) satisfies the
principal constraint property. We obtain that (C; )
is the principal normal form of (D; 0) where  ^OE

00

OE0 ffi 0 ffi [o/ 02=ff]. Because (C; ) is principal we find that
C0 `e OE00C. W.l.o.g. (OE0 ffi 0)o/ 02 = o/ 02. Then, we can
conclude that (OE0 ffi 0 ffi [o/ 02=ff])jfv(\Gamma ) = OE. This leads

to  ^OE

00

fv(\Gamma ) OE. Furthermore, it holds that OE00(ff) = o/ 02because

o/ 02 = OE0 ffi 0 ffi [o/ 02=ff](ff) = OE00 ffi (ff) = OE00(ff)
The last reasoning steps holds because ff is a new type
variable therefore ff 62 dom(). Finally, we apply the
(App) rule and find

jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)

20 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)

which establishes the induction step.
Case (Let) We have the following situation:

C1; OE\Gamma x `d e : o/ (oe; C2) = gen(C1; OE\Gamma x; o/ )

C3; OE\Gamma x:x : oe `d e0 : o/ 0
C2 ^ C3; OE\Gamma x `d let x = e in e0 : o/ 0

Induction hypothesis applied to the left part yields

1; ~C1; \Gamma x `W e : o/1 1 ^OE

0
1

fv(\Gamma x) OE

C1 `e OE01 ~C1 C1 `i OE01o/1 _ o/ (A3)

From Lemma 2 and Lemma 1 and A3 we obtain that

C2 `e OE01 ~C2 `i OE01oe1 _ oe (A4)
where (oe1; ~C2) = gen( ~C1; \Gamma x; o/1). We set ~OE = OE01 ffi OE.
Then it holds that

`i ~OE(\Gamma x:x : oe1) _ OE\Gamma x:x : oe (A5)
because

~OEoe1 = (OE01 ffi OE)oe1 = (OE01 ffi (OE01 ffi 1)jfv(\Gamma ))oe1 = OE01oe1

An easy observation yields

~OEjfv(\Gamma 

x) = OE (A6)

We rewrite the right premise with the stronger type
environment in A5 (this fact is stated without proof
but can be found in detail in [Sul97]) and find

C3; ~OE(\Gamma x:x : oe1) `d e0 : o/ 0
Now, we are able to apply the induction hypothesis to
the right part and find

2; ~C3; \Gamma x:x : oe1 `W e0 : o/ 01

2 ^OE

0
2

fv(\Gamma x)[fv(oe1) ~OE

C3 `e OE02 ~C3 C3 `i OE02o/ 01 _ o/ 0

(A7)

From A3 we can deduce that

1 ^OE

0
1

fv(\Gamma x)[fv(oe1) ~OE (A8)

because of A3 and A6 it holds that

(OE01 ffi 1)jfv(\Gamma 

x) = OE = ~OEjfv(\Gamma x)

and if ff 2 fv(oe1) we can assume that ff 62 fv(\Gamma x) then
we know that

OE(ff) = ff 1(ff) = ff
We can deduce that

OE01 ffi 1(ff) = OE01(ff) = ~OE(ff)

Then from A7 and A8 we find that the least upper
bound of 1 and 2 exists. It holds that

0 ^OE

0

fv(\Gamma x)[fv(oe) OE (A9)

where 0 = 1 t 2. With A6 and from A9 we find that

0 ^OE

0

fv(\Gamma x) OE

From A4 and A3 we know that

C2 `e OE01 ~C2 C3 `e OE02 ~C3 C3 `i OE02o/ 01 _ o/ 0
As in the (App) case we can conclude from Lemmas 3, 4
that

C2 `e (OE0 ffi 0) ~C2 C3 `e (OE0 ffi 0) ~C3
and

C3 `i (OE0 ffi 0)o/ 01 _ o/ 0

We set D = ~C2 ^ ~C3. Then we obtain that (C2 ^
C3; OE0 ffi 0) is a normal form of (D; 0). By assumption HM(X) satisfies the principal constraint property.
Assume (C; ) is the principal normal form of (D; 0)
where  ^OE

00 OE0 ffi 0. Now, we can apply the (Let) rule

and find

jfv(\Gamma ); C; \Gamma x `W let x = e in e0 : o/ 01
Furthermore, we obtain that

C2 ^ C3 `e OE00C C2 ^ C3 `i (OE00 ffi )o/ 01 _ o/ 0

where  ^OE

00

fv(\Gamma x) OE.

Now we have everything at hand to prove completeness of type inference.

Theorem 9. Given C0; OE\Gamma  ` e : oe0 and OE\Gamma  is realizable in C0. Then

; C; \Gamma  `W e : o/
for some substitutions OE0, , constraint C and type o/
such that,

 ^OE

0

fv(\Gamma ) OE C0 `

e OE0Co C0 `i OE0oeo _ oe0

where (oeo; Co) = gen(C; \Gamma ; o/ ).

Proof. First, we apply Lemma 5 in order to get a
derivation in `2 . Then, we can apply Lemma 7 (completeness of `d ). This yields

(a) oe0 = o/ : C; OE\Gamma  `d e : o/ C0 `e C
(b) otherwise : C; OE\Gamma  `d e : o/ (oeo; Co) = gen(C; OE\Gamma ; o/ )

C0 `e Co C0 `i oeo _ oe0

(A10)

After that we apply Lemma 8 (completeness of `W )
and find

; ~C; \Gamma  `W e : ~o/  ^OE

0

fv(\Gamma ) OE
C `e OE0 ~C C `i OE0 ~o/ _ o/

We set (oeo; Co) = gen(C; \Gamma ; o/ ). It remains to show

THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year) 21

1. C

0 `i OE0~oe

o _ oe

0

2. C

0 `e OE0 ~C

o.

This fact follows by application of the Lifting Lemmas 3, 4.

22 THEORY AND PRACTICE OF OBJECT SYSTEMS--(Year)