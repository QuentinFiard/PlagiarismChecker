

R'esolution de Contraintes dans des Alg`ebres de Termes

Rapport d'Habilitation

Hubert Comon\Lambda 

Ce document est une introduction aux travaux pr'esent'es le 3 Avril 1992 devant le jury compos'e de Ph. Jorrand (pr'esident), B. Courcelle, J.-Y. Girard, G. Huet, J.-P. Jouannaud, J.-L.
Lassez, M. Nivat, pour obtenir le dipl^ome d'habilitation `a diriger des recherches en Sciences de
l'Universit'e de Paris-Sud.

Ces quelques pages constituent une introduction `a une s'erie d'articles que le lecteur est invit'e
`a consulter pour plus de d'etails. Le paragraphe 1 est une br`eve description du contexte dans
lequel se situent les travaux d'ecrits ensuite.

Table des mati`eres
1 Le cadre de travail 3

1.1 Qu'est ce qu'une contrainte? : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3
1.2 Pourquoi les contraintes? : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 4
1.3 Les contraintes symboliques. L'exemple des contraintes d''egalit'e : : : : : : : : : 4
1.4 Exemples d'utilisation de l'expressivit'e des contraintes symboliques : : : : : : : : 6
1.5 Expression du contr^ole `a l'aide de contraintes symboliques : : : : : : : : : : : : : 6
1.6 Les contraintes symboliques 'etudi'ees ici : : : : : : : : : : : : : : : : : : : : : : : 7
1.7 Formes r'esolues : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 8
1.8 Logique 'equationnelle contrainte : : : : : : : : : : : : : : : : : : : : : : : : : : : 8
1.9 Langages de Formes Normales : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 9

2 Formules 'Equationnelles 11

2.1 Probl`emes de compl'ement : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 11
2.2 R'esolution des formules 'equationnelles dans T (F ) : : : : : : : : : : : : : : : : : : 12

3 Formules 'Equationnelles dans des Alg`ebres Quotient 15
4 'Elimination de la n'egation 18

4.1 R'esultat de non-'equivalence avec des probl`emes d'unification : : : : : : : : : : : 18
4.2 Transformation des formules : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 19
4.3 'Elimination de la n'egation dans un quotient : : : : : : : : : : : : : : : : : : : : : 19

\Lambda CNRS and LRI, Bat. 490, Universit'e de Paris Sud, 91405 ORSAY cedex, France. E-mail comon@lri.lri.fr

1

5 Contraintes d'appartenance 20

5.1 Syntaxe des formules : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 21
5.2 Interpr'etation des formules : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 21
5.3 Formes r'esolues : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 22
5.4 Simplification des formules : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 22
5.5 Application `a la compl'etude suffisante : : : : : : : : : : : : : : : : : : : : : : : : 23

6 Contraintes d'Ordre 25

6.1 Les formules consid'er'ees et leur interpr'etation : : : : : : : : : : : : : : : : : : : : 25
6.2 Formes r'esolues : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 26
6.3 Cl^oture des formules : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 26
6.4 Propri'et'es de la fonction successeur et r`egles de transformation les refl'etant : : : 26
6.5 Extensions : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 27

7 Compl'etion de syst`emes de r'e'ecriture avec contraintes 29

7.1 Le syst`eme de contraintes : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 29
7.2 D'eductions sur les 'equations contraintes : : : : : : : : : : : : : : : : : : : : : : : 30
7.3 R'esolution des contraintes : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 30

8 Langages de Formes Normales 33
9 Recherches Futures 35

2

1 Le cadre de travail
Depuis longtemps, l'unification, qui consiste `a r'esoudre une 'equation dans l'alg`ebre (libre) des
termes est une op'eration fondamentale dans plusieurs domaines et en particulier en programmation logique. De m^eme, la disunification qui consiste `a r'esoudre des formules plus complexes
(et comportant en particulier des n'egations) s'est av'er'ee une op'eration tout aussi fondamentale
(voir l'article de synth`ese [19]). Mais ce n'est que plus r'ecemment que ces op'erations sont vraiment consid'er'ees comme des r'esolution de contraintes. Et ce point de vue s'est en fait av'er'e
tr`es fructueux. Mais qu'est-ce au juste que la r'esolution de contraintes? Le mot "contrainte"
est en effet dangereusement surcharg'e et nous avons besoin d'^etre pr'ecis.

1.1 Qu'est ce qu'une contrainte?
Un syst`eme de contraintes est d'efini d'une part par un langage logique C (en g'en'eral, un fragment
d'une logique du premier ordre), en deuxi`eme lieu par un mod`ele M et enfin par un algorithme
de d'ecision, pour toute formule OE 2 C, de la satisfaisabilit'e de OE dans M .

Les exemples sont nombreux: C peut ^etre un langage du premier ordre, la troisi`eme condition
imposant alors que la th'eorie du premier ordre de M soit d'ecidable. Par exemple, le syst`eme de
contraintes peut ^etre l'arithm'etique de Presburger, ou la th'eorie des nombres r'eels. (Consulter
l'article de synth`ese de M. Rabin [74] pour plus de d'etails sur les th'eories d'ecidables.) M peut
aussi ^etre l'alg`ebre des arbres finis dont la th'eorie du premier ordre a 'et'e prouv'ee d'ecidable par
Mal'cev [67], exemple qui nous int'eresse tout particuli`erement et sur lequel je reviendrai.

Les contraintes permettent, comme leur nom l'indique, de contraindre les formules d'une
autre logique. Plus formellement, une logique contrainte est d'efinie par

ffl une logique, i.e. un ensemble de formules L, une classe de structures M et une relation

de satisfaction j=,

ffl un syst`eme de contraintes (C; M; \Phi )
ffl pour toute structure S de M, une application HS du domaine D de M dans le domaine

DS de la structure S.

Les formules de la logique contrainte sont alors les expressions OE k C o`u OE 2 L et C 2 C. Un
mod`ele de la formule contrainte OE k C est un triplet oe; `; S o`u S 2 M, oe est une assignation des
variables libres de C dans D et ` est une assignation des autres variables libres de OE dans DS,
tels que (

M j= Coe
HS(oe) ffi `; S j= OE

o`u HS(oe) est l'assignation qui `a toute variable x du domaine de oe associe HS(xoe). Lorsque le
domaine D est un ensemble de termes, l'application HS sera toujours choisie co"incidant avec
l'interpr'etation des termes dans DS, ce qui simplifie les choses: une formule contrainte n'est plus
alors que la repr'esentation d'un ensemble de formules.

Cette d'efinition qui fait appel aux mod`eles n'est pas enti`erement satisfaisante, mais il n'existe
aucune d'efinition pr'ecise dans la litt'erature. D'autre part, il n'existe pas de m'ecanisme uniforme
qui permette de donner les r`egles de d'eduction dans une logique contrainte `a partir des r`egles
de d'eduction de la logique et des r`egles de r'esolution de contraintes. Nous allons d'ailleurs
amplement illustrer ce probl`eme de combinaison dans les paragraphes qui suivent.

Il ne faut pas confondre les contraintes avec ce qu'on appelle souvent les conditions (par
exemple en r'e'ecriture conditionnelle). En effet, les contraintes sont interpr'et'ees dans un mod`ele

3

fixe alors que l'interpr'etation des conditions d'epend des formules auxquelles elles s'appliquent.
Donnons un exemple typique : (

f (x) = a k a = b

a = b k a = a

Si les contraintes sont interpr'et'ees dans l'alg`ebre libre des termes, la premi`ere contrainte n'est
jamais satisfaite et la premi`ere formule contrainte d'enote un ensemble vide de formules. La
deuxi`eme contrainte est quant `a elle toujours satisfaite. Les deux formules ci-dessus sont donc
alors 'equivalentes `a la seule formule (non contrainte) a = b.

Si par contre nous nous pla,cons dans une logique conditionnelle, k peut-^etre remplac'e par
l'implication , les signes d''egalit'e situ'es de part et d'autre de la fl`eche 'etant interpr'et'es de la
m^eme mani`ere. Dans ce cas, f (x) = a est une cons'equence logique des deux formules puisque
la condition a = b est valide. En fait, les deux formules conditionnelles sont 'equivalentes `a
l'ensemble de deux formules fa = b; f (x) = ag.

1.2 Pourquoi les contraintes?
Les int'er^ets des syst`emes de contraintes sont multiples. Le premier int'er^et vient de la combinaison de deux langages: il est bien connu que certains probl`emes s'expriment plus facilement
dans un langage que dans un autre et qu'il n'y a pas de langage "id'eal" dans lequel tous les
probl`emes s'expriment simplement. Un syst`eme de contraintes peut donc offrir des notations
ad'equates `a l'expression d'un probl`eme. Par exemple, l'introduction d''egalit'es et d'in'egalit'es
sur les entiers dans un langage de programmation logique permet d'exprimer facilement des
probl`emes d'agencement et de planification (voir par exemple [32]).

Deuxi`emement, pour r'esoudre des contraintes, on peut tirer parti de la connaissance du
domaine particulier dans lequel elles sont interpr'et'ees et donc obtenir des techniques sp'ecialis'ees
plus efficaces. L'usage des contraintes permet donc d'am'eliorer l'efficacit'e de la r'esolution de
probl`emes sp'ecifiques.

Un troisi`eme int'er^et est de sch'ematiser des ensembles de formules: gr^ace aux contraintes il
n'est pas n'ecessaire de calculer explicitement certains ensembles grands (ou m^eme infinis) de
formules qui interviennent dans l'ex'ecution d'un programme. Certains ensembles de formules
peuvent en effet ^etre repr'esent'es par une seule formule contrainte. De la m^eme fa,con, l'utilisation
(et l'application explicite) de substitutions devient inutile, ce qui 'evite la croissance d'emesur'ee
des formules en cas d'occurrences multiples d'une m^eme variable.

Enfin, un autre avantage que nous d'ecrirons de mani`ere d'etaill'ee plus loin est la possibilit'e
de d'ecrire des strat'egies de preuve `a l'aide de contraintes. M^eme si ces strat'egies peuvent
s'exprimer sans l'aide des contraintes, celles-ci permettent une pr'esentation souvent plus simple
et plus 'el'egante, comme nous allons en donner un exemple dans le paragraphe qui suit.

En r'esum'e, les contraintes permettent d'am'eliorer `a la fois l'efficacit'e et l'expressivit'e d'un
langage (de programmation) logique. C'est en particulier pour ces raisons que les syst`emes
de contraintes connaissent un succ`es grandissant, tant en milieu universitaire qu'industriel. Les
syst`emes d''equations et d'in'equations ont d'abord 'et'e introduits par A. Colmerauer en PROLOG
II [9], puis l'exemple a rapidement 'et'e suivi et g'en'eralis'e `a d'autres syst`emes de contraintes.

1.3 Les contraintes symboliques. L'exemple des contraintes d''egalit'e
Un syst`eme de contraintes est qualifi'e de symbolique lorsque le domaine du mod`ele M est
une alg`ebre de termes. L'exemple le plus connu de r'esolution de contraintes symboliques est
l'unification qui consiste `a r'esoudre des 'equations entre termes. Cette r'esolution d''equations

4

peut avoir lieu dans l'univers de Herbrand (ou alg`ebre des termes); c'est le cas 'etudi'e par Herbrand en 1930 [40] dans ses travaux sur la th'eorie de la d'emonstration puis repris par Robinson
en 1965 [75] et par bien d'autres ensuite. Depuis 1965 les applications de l'unification sont
aussi nombreuses qu'importantes. Tout d'abord dans les ann'ees 70 sont n'es les langages de
programmation logique, fond'es sur la r`egle de r'esolution dont l'application d'epend du calcul
de l'unificateur principal de deux formules atomiques. Depuis, l'unification est utilis'ee dans
des domaines aussi vari'es que le tra^itement des langues naturelles, l'inf'erence de types dans les
langages fonctionnels ou encore la v'erification de circuits.

Le simple fait de consid'erer l'unification comme de la r'esolution de contraintes 'equationnelles
dans des alg`ebes de termes a permis d'effectuer de nombreux progr`es (se reporter `a l'article de
synth`ese de J.-P. Jouannaud et C. Kirchner [46]). La notion d'unificateur et l'utilisation de
substitutions est en effet en g'en'eral inutile et parfois m^eme nuisible. Je ne veux mentionner
ici que deux r'esultats remarquables dont l'un est tr`es r'ecent. Tous deux ont trait `a la logique
'equationnelle.

Le premier est d^u `a Hullot [45] mais a 'et'e raffin'e et 'el'egament pr'esent'e par Nutt, R'ety et
Smolka [72]: il s'agit de la compl'etude de la strat'egie basique de surr'eduction. La surr'eduction est
une proc'edure de r'esolution d''equations dans une th'eorie 'equationnelle. Une telle proc'edure joue,
par exemple, un r^ole fondamental dans les probl`emes d'int'egration de d'efinitions fonctionnelles
(par 'equations) dans un langage de programmation logique bas'e sur la r'esolution.

Soit R est un syst`eme de r'e'ecriture convergent (c'est `a dire qui est confluent et qui termine,
voir l'article de synth`ese de N. Dershowitz et J.-P. Jouannaud [30] pour les d'efinitions manquantes en r'e'ecriture). L''egalit'e modulo la congruence engendr'ee par R est alors d'ecidable:

s

\Lambda \Gamma \Gamma !

R t si et seulement si s

\Lambda \Gamma !
R

\Lambda \Gamma 
R t. Le probl`eme pos'e est la r'esolution d''equations dansla th'eorie d'efinie par R. En d'autres termes, 'etant donn'es s et t, on cherche les substitutions

oe telles que soe

\Lambda \Gamma \Gamma !

R toe. La proc'edure de surr'eduction consiste `a remplacer le probl`eme s = tpar les probl`emes s[r]

p` = t` o`u l ! r 2 R, p est une position non variable de s et ` est un
plus g'en'eral unificateur de l et sjp. La strat'egie basique consiste `a ne pas faire de superposition

dans des positions introduites par les substitutions, ou, plus pr'ecis'ement, `a ne pas appliquer les
substitutions, en gardant les probl`emes d'unifiabilit'e comme des contraintes d''egalit'e. La r`egle
de surr'eduction devient alors: s = t k C

s[r]p = t k C ^ sjp = l
la partie situ'ee `a doite du signe k d'esignant la contrainte et la partie situ'ee `a gauche de ce signe
le probl`eme `a r'esoudre. On notera qu'il n'y a plus d'application de substitution dans cette r`egle.
Cette id'ee est d'ailleurs d'ej`a ancienne pour ce qui concerne la programmation logique: la plupart
des interpr`etes de PROLOG n'effectuent pas les substitutions, mais au contraire gardent une
contrainte d''egalit'e avec les litt'eraux `a r'esoudre.

Une deuxi`eme application beaucoup plus r'ecente des contraintes 'equationnelles est la compl'etude de la superposition basique pour les syst`emes de r'e'ecriture, r'esultat d^u (entre autres) `a
Nieuwenhuis et Rubio [71]. L'id'ee est la m^eme que pour la surr'eduction: il n'est pas n'ecessaire
de calculer les paires critiques `a des positions introduites par des substitutions, ce qui, `a nouveau,
s'exprime simplement et 'el'egamment `a l'aide de contraintes; la r`egle de d'eduction habituelle se
trouvant remplac'ee par:

g = d k OE l = r k 

g[r]p = d k OE ^  ^ gjp = l
Ces deux exemples montrent bien l'importance de l'utilisation des contraintes pour la pr'esentation des probl`emes. Cependant, les contraintes ne sont pas indispensables, une fois comprise la
strat'egie. En effet, on peut toujours r'esoudre la partie contrainte, obtenant ainsi une substitution

5

oe, puis appliquer oe `a la formule. En d'autres mots: les formules contraintes ci-dessus peuvent
toujours ^etre transform'ees en des formules non contraintes 'equivalentes, ce qui n'est pas toujours
le cas pour d'autres syst`emes de contraintes symboliques.

1.4 Exemples d'utilisation de l'expressivit'e des contraintes symboliques
Les contraintes symboliques, outre la clart'e de pr'esentation de certaines strat'egies 'evoqu'ee plus
haut, permettent d'exprimer de fa,con concise des ensembles tr`es grands (ou m^eme infinis) de
substitutions. C'est le cas en programmation logique, comme l'a remarqu'e K. Kunen [61], mais
je voudrais 'evoquer ici d'autres exemples, reli'es `a la logique 'equationnelle.

Les dis'equations sont utilis'ees par H.-J. B"urckert dans les probl`emes d'unification modulo
l'associativit'e - commutativit'e [5]. L'id'ee est la suivante: l'unification modulo associativit'ecommutativit'e (AC) peut conduire `a un ensemble exponentiel d'unificateurs principaux alors
que l'unification modulo associativit'e + commutativit'e + 'el'ement neutre (AC1) conduit `a 1
ou 0 unificateur principal en l'absence de symbole libre. Donc, au lieu d'effectuer l'unification
AC, on effectue l'unification modulo AC1, en contraignant toutes les variables `a ^etre distinctes
de l''el'ement neutre. Cela permet d'obtenir une seule solution (contrainte) au lieu d'un grand
nombre de solutions qui partagent uen structure commune. Ce genre d'id'ee est aussi exploit'e par
E. Domenjoud qui utilise des contraintes d'appartenance au lieu de dis'equations [33]. Toujours
dans le m^eme esprit, J.-P. Jouananud et C. March'e utilisent des dis'equations pour contraindre
les r`egles de r'e'ecriture dans la compl'etion modulo AC1 afin de r'esoudre le probl`eme de l'absence
d'ordre de r'eduction qui soit compatible avec AC1 [49].

Dans un autre registre, R. Caferra et N. Zabel utilisent les formules 'equationnelles pour
construire des mod`eles en cas de non-r'efutation d'un ensemble de clauses; le syst`eme de d'eduction
qu'ils utilisent permet de rechercher `a la fois une r'efutation et de calculer un mod`ele [6]. Le
pouvoir d'expression des formules 'equationnelles permet en outre de d'ecrire des mod`eles infinis.
Des id'ees semblables sont utilis'ees pour la n'egation constructive en programmation logique (voir,
par exemple, [80]).

D'autres exemples d'utilisations de contraintes symboliques dans divers domaines sont propos'es dans l'article joint en annexe [19].

1.5 Expression du contr^ole `a l'aide de contraintes symboliques
Un autre int'er^et des contraintes symboliques est la possibilit'e qu'elles offrent d'exprimer du
contr^ole dans les formules elles-m^emes, au lieu de l'exprimer dans les r`egles d'inf'erence. C''etait
sans doute d'ej`a l'esprit de l'introduction des dis'equations en PROLOG II. Un autre exemple
r'ecent montre l'importance de ce point de vue: l'expression de strat'egies ordonn'ees comme
contraintes d'ordre.

J. Hsiang et M. Rusinowitch donnaient en 1987 le premier ensemble de r`egles de compl'etion
qui soit r'efutationnellement complet [41]. La r`egle qu'ils utilisent se pr'esente ainsi: soit * un
ordre de r'eduction total sur les termes sans variables, la r`egle de d'eduction s''ecrit alors:

l = r g = d

l[d]poe = roe Si goe j ljpoe et roe 6* loe ^ doe 6* goe

Cette r`egle d'inf'erence `a l'immense avantage par rapport `a ses pr'ed'ecesseurs de ne pas supposer
l ? r et g ? d, la strat'egie ordonn'ee interdisant simplement de remplacer un terme par un terme
plus grand dans la d'eduction.

6

Un premier raffinement de cette r`egle consiste `a n'effectuer la d'eduction que s'il existe une
instance de l = r et g = d qui oriente ces 'equations de gauche `a droite:1

l = r g = d

l[d]poe = roe Si goe j ljpoe et 9`; roe` ! loe` ^ doe` ! goe`

Enfin, un nouveau raffinement, qui permet `a nouveau de calculer strictement moins d''equations
et qui reste n'eanmoins complet consiste `a garder dans la contrainte loe ? roe (que l'on a simplifi'ee)
les instances pour lesquelles la d'eduction est licite:

l = r k OE g = d k 
l[d]p = r k OE ^  ^ ljp = g ^ l ? r ^ g ? d

Si la contrainte OE ^  ^ ljp = g ^ l ? r ^ g ? d est satisfaisable.

L'expression de la strat'egie dans les contraintes, c'est-`a-dire dans les formules elles-m^emes
permet de garder une "histoire" des d'eductions ant'erieures, ou, plus exactement, des hypoth`eses
effectu'ees dans les d'eductions ant'erieures.

1.6 Les contraintes symboliques 'etudi'ees ici
Bien s^ur, pour tous les syst`emes de contraintes mentionn'es, il nous faut montrer qu'ils satisfont
les propri'et'es requises 'enonc'ees tout au d'ebut de ce paragraphe. En particulier, il faut donner
des algorithmes de d'ecision de la satisfaisabilite dans les mod`eles consid'er'es.

Une grande partie des travaux pr'esent'es ici consiste pr'ecis'ement `a donner des familles
d'algorithmes de r'esolution de contraintes symboliques. Tout d'abord, je parlerai des formules
'equationnelles dans le paragraphe 2. Ce sont des formules du premier ordre arbitraires construites sur un alphabet de symboles de fonction arbitraire et le seul symbole de pr'edicat =. Ces
formules sont interpr'et'ees dans l'alg`ebre des termes ou dans certains de ses quotients. L''etude
de telles formules n'est pas seulement motiv'e par leur utilisation comme syst`eme de contraintes.
Je donnerai quelques autres exemples d'utilisation.

Ensuite, je montrerai dans le paragraphe 5 comment r'esoudre des formules 'equationnelles
comportant en outre des pr'edicats unaires (contraintes de sortes) interpr'et'es comme des langages
d'arbres r'eguliers (on peut aussi consid'erer une classe de langages d'arbres un peu plus 'etendue).
Ceci peut ^etre vu comme la r'esolution de formules dans une alg`ebre avec sortes ordonn'ees puisque
les signatures avec sortes ordonn'ees ne sont rien d'autre que des automates d'arbre ascendants
d''etats finis.

Enfin, le troisi`eme syst`eme de contraintes que je consid'ererai est le cas de contraintes d'ordre
(celles qu'il faut r'esoudre pour utiliser la strat'egie ordonn'ee du paragraphe pr'ec'edent). La
r'esolution de syst`emes d'in'equations sur les arbres sera donc consid'er'ee dans le paragraphe 6.

Dans tous les cas, j'utilise une technique particuli`ere pour la r'esolution des contraintes: la
r'e'ecriture de formules. Je donne donc des r`egles (ou, plus exactement des sch'emas de r`egles)
de r'e'ecriture dont je prouve la terminaison et tels que toute forme irr'eductible d'une formule
sans variable libre est ? (formule valide) ou ? (formule insatisfaisable). Les r`egles de r'e'ecriture
sont donn'ees avec le maximum de libert'e possible dans leur application de fa,con `a ce que la
preuve de terminaison soit la plus g'en'erale possible. Ceci permet de prouver d'un coup la
terminaison de tous les algorithmes de r'esolution de contraintes qui sont obtenus en utilisant
(de fa,con d'eterministe) le m^eme ensemble de r`egles d'inf'erence. Or il n'est pas inutile de disposer

1En fait, cette r`egle est bien celle que voulaient exprimer J. Hsiang et M. Rusinowitch. S'ils ont choisi la
premi`ere forme de la r`egle, c'est uniquement pour ^etre certains de la d'ecidabilit'e de la condition qui n''etait pas
'evidente pour la r`egle sous sa deuxi`eme forme.

7

de plusieurs algorithmes pour le m^eme probl`eme, comme l'a montr'e l'exemple de l'unification.
En fait, l'un ou l'autre des algorithmes sera plus int'eressant selon le type exact de probl`eme `a
r'esoudre et les moyens dont on dispose.

Lorsque les formules `a r'esoudre comportent des variables libres, la r'esolution de celles-ci doit
conduire `a une description des solutions qui soit "plus simple" que la formule elle-m^eme. Cette
notion de simplicit'e est pr'ecis'ee par les formes r'esolues.

1.7 Formes r'esolues
En fait, l'unification consiste `a trouver des formes simplifi'ees (et que l'on sait solubles, d'o`u l'appellation de formes r'esolues) `a des 'equations s = t entre termes s; t. Un exemple typique de forme
r'esolue est une conjonction x1 = t1 ^ : : : ^ xn = tn dans laquelle x1; : : : ; xn est un sous-ensemble
des variables du probl`eme de d'epart. Si x1; : : : ; xn n'ont qu'une occurrence dans la conjonction,
la forme r'esolue repr'esente un plus g'en'eral unificateur (sa taille peut ^etre exponentielle par
rapport `a la taille du probl`eme initial). Mais on peut demander simplement que, pour tout i, xi
n'ait pas d'occurrence dans tj, j * i; on obtient les formes s'equentiellement r'esolues [46] dont
la taille est cette fois polyn^omiale par rapport `a la taille du probl`eme de d'epart.

Le choix des formes r'esolues n'a pas qu'un impact sur la complexit'e des r'esultats et des
algorithmes, mais aussi sur leur incr'ementalit'e c'est-`a-dire sur la capacit'e `a r'eutiliser les r'esultats
des calculs ant'erieurs pour des r'esolution de contraintes ult'erieures. En effet, les formes r'esolues
repr'esentent de fa,con simplifi'ee les formules et peuvent donc ^etre utilis'ees `a la place de celles-ci
chaque fois que leur calcul a 'et'e effectu'e. Cette propri'et'e est fondamentale en programmation
logique: on n'a pas besoin en g'en'eral d'une repr'esentation explicite des solutions, mais seulement
d'une repr'esentation utilisable dans des calculs ult'erieurs. L'utilisation de formes r'esolue 'evite
de refaire un travail d'ej`a effectu'e.

Pour chaque probl`eme de r'esolution de contraintes symboliques, je vais d'efinir une notion
de forme r'esolue. Chaque fois que c'est possible (et ce sera toujours le cas, sauf pour les contraintes d'ordre du paragraphe 6) les formes r'esolues distinctes de ? devront ^etre satisfaisables.
Autrement dit, le test de satisfaisabilit'e doit ^etre plus simple, sinon trivial, que sur les formules
du langage de containtes. Les formes r'esolues que nous d'efinirons ne donneront en g'en'eral pas
explicitement de substitutions engendrant l'ensemble des solutions, ce qui est en g'en'eral `a la
fois inutile et impossible comme nous le verrons dans le paragraphe 4.

1.8 Logique 'equationnelle contrainte
Les syst`emes de contraintes (symboliques ou non) ont largement 'et'e mis en oeuvre dans les langages de programmation logique bas'es sur les clauses de Horn. Mais ce n'est que tr`es r'ecemment
(sous l'impulsion, entre autres de Claude Kirchner, H'el`ene Kirchner et Michael Rusinowitch [57])
que les contraintes (symboliques, cette fois) sont utilis'ees en logique 'equationnelle. J'ai d'ailleurs
d'ej`a montr'e dans les paragraphes 1.4 et 1.5 quelles pouvaient ^etre les utilisations potentielles
des contraintes en logique 'equationnelle.

La r'e'ecriture est une strat'egie ordonn'ee de remplacement d''egaux par 'egaux qui est compl`ete
lorsque le syst`eme de r'e'ecriture est convergent. Obtenir des syst`emes de r'e'ecriture convergents
`a partir d''equations est l'un des objectifs fondamentaux des techniques de compl'etion d'ej`a
utilis'ees depuis longtemps pour les calculs de bases d'id'eaux dans les anneaux de polyn^omes. La
compl'etion des syst`emes de r'e'ecriture de termes est maintenant un domaine de recherche `a part
enti`ere depuis l'article fondateur de D. Knuth et P. Bendix [59]. Cette technique de compl'etion
se fonde sur un lemme de paires critiques dont l'id'ee est d^ue `a Knuth et Bendix et dont l''enonc'e
et la preuve g'en'eraux sont d^us `a G. Huet [43]. Ce lemme s''enonce ainsi: la relation de r'eduction

8

!R d'efinie par l'ensemble R de r`egles de r'e'ecriture est localement confluente si et seulement si
les paires critiques de R sont confluentes.

Malheureusement le lemme de Huet est en d'efaut dans le cas de la logique 'equationnelle
contrainte (quel que soit le syst`eme non trivial de contraintes). Par exemple,(

x = a : f (x) ! b

a ! b

est un syst`eme de r'e'ecriture contraint (la premi`ere r`egle f (x) ! b est contrainte par x = a). Il
n'y a pas de paire critique au sens usuel, pourtant le syst`eme de r'e'ecriture ainsi d'efini n'est pas
localement confluent puisque

b

x=a:f(x)!b\Gamma \Gamma \Gamma \Gamma \Gamma \Gamma \Gamma  f (a) a!b\Gamma \Gamma ! f (b)

et b comme f (b) est irr'eductible. Ce ph'enom`ene n'a rien de surprenant: si l'on remplace x par
a dans la premi`ere r`egle, une paire critique est mise en 'evidence. Ce probl`eme s'apparente aux
probl`emes rencontr'es avec la r'e'ecriture conditionnelle, mais il ne faut pas confondre r'e'ecriture
contrainte et r'e'ecriture conditionnelle (nous avons d'ej`a insist'e sur ce point dans le paragraphe
1.1. (Pour certaines d'efinitions de la r'e'eriture conditionnelle le syst`eme de r'e'ecriture ci-dessus
serait d'ailleurs confluent).

Il y a deux solutions envisageables pour r'esoudre le probl`eme pos'e par la mise en d'efaut du
lemme des paires critiques:

1. restreindre les contraintes autoris'ees de fa,con `a ce que le lemme reste correct
2. 'etendre la notion de paire critique de fa,con `a prendre en compte les probl`emes li'es `a

l'utilisation des contraintes.

Ces deux directions de recherche sont actuellement en cours d'exploration dans plusieurs 'equipes.
(Mais aucun article n'a 'et'e publi'e pour l'instant, de toutes les fa,cons les r'esultats risquent de
d'ependre du syst`eme de contraintes consid'er'e.)

Ce ph'enom`ene ('echec du lemme des paires critiques) appara^it aussi dans la compl'etion de
syst`emes de r'e'ecriture avec sortes ordonn'ees qui est 'etudi'ee dans de nombreux articles (voir
par exemple l'article de G. Smolka, W. Nutt, J. Goguen et J. Meseguer [79] ou celui de C.
Kirchner, H. Kirchner et J. Meseguer [56]). Mais le fait n'a plus rien de myst'erieux si l'on voit
la logique 'equationnelle avec sortes ordonn'ees comme une logique 'equationnelle avec contraintes
de sorte. Pour ces raisons, je me suis int'eress'e `a la compl'etion de syst`emes de r'e'ecriture avec
contraintes de sortes, en tentant (au contraire des approches pr'ecit'ees) de r'etablir le lemme des
paires critiques par extension de la notion de paire critique. Ceci m'a conduit `a introduire des
variables de second ordre dans les termes (et dans les contraintes). Le paragraphe 7 et l'article
[21] sont consacr'es `a ce sujet.

Le domaine de la r'e'ecriture contrainte est un domaine neuf et il reste beaucoup `a faire. J'y
reviendrai dans la paragraphe 9.

1.9 Langages de Formes Normales
Je ne peux pas clore ce paragraphe introductif sans parler des langages de formes normales.
Bien qu'il ne s'agisse pas directement de r'esolution de contraintes, le calcul de grammaires et
les propri'et'es de ces langages utilisent de fa,con cruciale la r'esolution de formules 'equationnelles.

Un langage de formes normales est l'ensemble des termes clos (i.e. sans variable) qui sont
irr'eductibles pour un syst`eme de r'e'ecriture R. Un probl`eme g'en'eral, appel'e r'eductibilit'e inductive par J.-P. Jouannaud et E. Kounalis [48] est de savoir si toutes les instances closes d'un

9

terme sont r'eductibles par R. Ce probl`eme est fortement li'e `a l'automatisation des preuves par
induction dans les th'eories 'equationnelles comme l'on montr'e de nombreux auteurs (voir par
exemple [73, 52, 48, 1].) On l'exprime aussi simplement avec le vocabulaire des langages: il
s'agit de d'ecider du vide de l'intersection d'un langage de formes normales avec l'ensemble des
instances closes d'un terme t.

Ces langages d'arbre sont en fait des langages reconnaissables lorsque les membres gauches de
r`egles sont lin'eaires. Les techniques d'automates s'appliquent donc en ce cas. Mais le cas g'en'eral
est plus complexe. En fait, j'ai montr'e dans ma th`ese d'universit'e qu'il est possible, `a l'aide de
la r'esolution de formules 'equationnelles, de calculer des grammaires conditionnelles engendrant
ces langages d'arbres puis de donner un algorithme de nettoyage pour ces grammaires. C'est ce
que je vais d'evelopper dans le paragraphe 8.

10

2 Formules 'Equationnelles
Je d'ecris dans ce paragraphe le contenu d'un article 'elabor'e en collaboration avec P. Lescanne
[26] concernant la r'esolution de formules 'equationnelles dans l'alg`ebre libre dans le cas d'un
alphabet fini. Le r'esultat de d'ecidabilit'e qui en d'ecoule donne une autre preuve d'un r'esultat
de Mal'cev [67] qui a d'ailleurs 'et'e red'ecouvert ind'ependamment (et en utilisant une troisi`eme
technique) par M. Maher [66]. Ces r'esultats seront g'en'eralis'es `a certaines alg`ebres quotient dans
le paragraphe suivant.

Dans tous les cas, la r'esolution de formules 'equationnelles arbitraires dans une alg`ebre A
fournit une axiomatisation compl`ete de A: les r`egles de r'e'ecriture de formules ne constituent
qu'une strat'egie ordonn'ee d'utilisation de certaines 'equivalences qui axiomatisent le mod`ele.
C''etait d'ailleurs la motivation de Mal'cev: trouver toutes les classes d'alg`ebres localement
libres qui soient compl`etement axiomatisables.

D'autres r'esultats sur la r'esolution de formules 'equationnelles sont d'ecrits dans [19]. Il s'agit
par exemple de la r'esolution de formules 'equationnelles dans l'alg`ebre libre lorsque l'alphabet est
infini. Ce probl`eme a 'et'e r'esolu simplement par K. Kunen [62] qui l'utilise pour les probl`emes de
s'emantique de la n'egation par 'echec en programmation logique. Une autre preuve a 'et'e donn'ee
par M. Maher [66] qui montre aussi comment r'esoudre les formules 'equationnelles dans l'alg`ebre
des arbres rationnels. Ce que j'ai aussi montr'e dans ma th`ese d'universit'e [12] par d'autres
m'ethodes. Enfin, ma th`ese d'universit'e contient aussi d'autres r'esultats concernant les formes
r'esolues et le contr^ole apport'e aux r`egles de transformation, r'esultats qui ne sont pas repris dans
les articles que j'ai publi'es ult'erieurement.

Avant de d'ecrire le contenu de l'article, je souhaite revenir bri`evement sur les motivations
premi`eres de l''etude de ces formules, motivations qui sont finalement assez 'eloign'ees de la programmation logique contrainte.

2.1 Probl`emes de compl'ement
Fondamentalement, la r'esolution de l''equation s = t permet d'obtenir une repr'esentation manipulable de l'intersection de l'ensemble de toutes les instances de s (not'e [[s]]) et de l'ensemble
de toutes les instances de t. Par exemple, si l'alphabet consid'er'e ne comprend qu'une constante
0 et un symbole s `a un seul argument,

[[s(x)]] = fs(0); s2(0); : : : ; sn(0); : : :g:
Et, si l'on ajoute un symbole + `a deux arguments, [[x + (x + 0)]] " [[(y + s(y)) + z)]] s'obtient en
r'esolvant x + (x + 0) = (y + s(y)) + z). L'intersection est ici l'ensemble infini [[(y + s(y)) + ((y +
s(y)) + 0)]].

Mais il n'y a pas que l'intersection qui pr'esente un int'er^et: dans beaucoup de situations,
d'autres op'erations sur de tels ensembles infinis de termes sont n'ecessaires. Une op'eration typique est le compl'ementaire: le probl`eme est alors de trouver toutes les instances d'un terme qui
ne sont pas instances d'un autre terme. Ce probl`eme s'exprime bien, non pas `a l'aide d''equations
seulement, mais en utilisant aussi quantificateurs et n'egation. De fa,con plus g'en'erale, de tels
probl`emes de compl'ement sont des cas particuliers de r'esolution de formules 'equationnelles. En
effet, [[t]] \Gamma  [[u]] (par exemple) est repr'esent'e par la formule

9Var(t); 8Var(u) : x = t ^ x 6= u
Ces probl`emes de compl'ement sont 'etudi'es en d'etail dans les articles [23] et et [20]. Parmi
les applications, citons la compilation du filtrage, le traitement de la n'egation en programmation

11

Reflexivit'e 8x; x = x
Symmetrie 8x; y; x = y () y = x
Transitivit'e 8x; y; z x = y ^ y = z =) x = z
Compatibilit'e 8~x; ~y; ~x = ~y =) f (~x) = f (~y) Pour tout f 2 F

Figure 1: L'ensemble EQ des axiomes de l''egalit'e

Decompose 8~x; ~y; f (~x) = f (~y) () ~x = ~y
Clash 8~x; ~y; f (~x) 6= f (~y) si f 6= g
Occur-Check 8x t[x]p 6= x pour tout terme t et toute position p 6= \Lambda 

Figure 2: L'ensemble d'axiomes F T des arbres finis
logique (soit par calcul statique de la "contrepartie n'egative" d'un pr'edicat [2], soit par l'ajout
de r`egles d'inf'erence [65]) ou le calcul de langages de formes normales d'ecrit dans le paragraphe
8 et qui a constitu'e la motivation premi`ere de mon int'er^et pour le sujet.

2.2 R'esolution des formules 'equationnelles dans T (F )
Les formules 'equationnelles sont donc des formules du premier ordre arbitraires dont les atomes
sont des 'equations s = t entre termes de T (F; X) ou des dis'equations s 6= t. L''egalit'e est
interpr'et'ee par l''egalit'e syntaxique j des termes. De plus, une assignation oe des variables libres
d'une formule 'equationnelle OE `a des termes de T (F ) est une solution de OE si OEoe est valide dans
T (F ). Enfin, je supposerai toujours que T (F ) est infini (le cas o`u T (F ) est fini est trivial).

On peut supposer que les formules 'equationnelles sont en forme pr'enexe et m^eme qu'elles
sont en forme normale conjonctive. De plus, pour r'esoudre de telles formules il suffit de montrer
comment 'eliminer un quantificateur. Plus pr'ecis'ement, j'appelerai probl`eme 'equationnel toute
formule de la forme .

i2I

9~x; 8~y : P

o`u P est une formule sans quantificateur en forme normale conjonctive. Si l'on montre (et ce
sera le cas) comment transformer un probl`eme 'equationnel en un probl`eme 'equivalent, mais
sans variable quantifi'ee universellement, alors on saura comment r'eduire n'importe quelle formule 'equationnelle en une formule purement existentielle en 'eliminant le quantificateur le plus
imbriqu'e de OE ou de :OE.

C'est pourquoi la fa,con la plus simple de proc'eder est de commencer par r'eduire les probl`emes
'equationnels en formules purement existentielles.

Notons tout d'abord que, outre les propri'et'es de l''egalit'e, l'interpr'etation des formules dans
T (F ) (arbres finis) nous assure la validit'e des formules de la figure 2.

Ces axiomes (appelons les F T pour Finite Trees) permettent de d'ecomposer les formules
atomiques de sorte qu'elles soient toutes de la forme x = t ou bien x 6= t o`u x est une variable
qui n'appara^it pas dans t. Maintenant, si x est quantifi'ee universellement et n'appara^it pas dans
t, on peut 'eliminer x gr^ace `a la r`egle

(Q1) 8x : x 6= t . d ! dfx 7! tg

12

qui est une cons'equence des axiomes de l''egalit'e qui sont rappel'es dans la figure 1. L''elimination
des occurrences de variables quantifi'ees universellement et qui sont membres d''equations demande un peu plus d'attention: il faut utiliser un lemme d'ind'ependance des dis'equations d'ej`a
'etabli par A. Colmerauer [9] et 'etudi'e par J.-L. Lassez, M. Maher et K. Marriott [63].

Lemme 1 Si s1 6= t1; : : : ; sn 6= tn sont n dis'equations qui ont chacune au moins une solution
dans T (F ), alors la conjonction s1 6= t1 ^ : : : ^ sn 6= tn a au moins une solution dans T (F ).

Ce lemme permet de d'eduire la r`egle de transformation de formules suivante:

(Q2) 8~y : z1 = t1 . : : : . zn = tn . d ! d
si, pour tout i, zi est une variable distincte de ti, s'il existe une variable y 2 ~y " Var(z1; t1) "
: : : " Var(zn; tn) telle que y 62 Var(d).

Supposant d'esormais que F est fini, il nous faut utiliser quelque part l'axiome de cl^oture du
domaine:

(DCA) 8x; .

f2F

9 ~xf ; x = f ( ~xf )

formule qui ne peut ^etre d'eduite de EQ [ F T .

Cet axiome sera utilis'e pour "faire remonter" les variables quantifi'ees universellement de
fa,con `a ce que celles-ci puissent ^etre 'elimin'ees en utilisant l'une des deux r`egles que j'ai mentionn'ees plus haut. Donnons un exemple:

Exemple 1 Soit F = f0; sg, et OE la formule 8y; x 6= s(y) . x0 6= s(y). Utilisant l'axiome de
cl^oture du domaine, cette formule se r'e'ecrit en:

8y; x = 0 ^ (x 6= s(y) . x0 6= s(y))
. 9z; 8y; x = s(z) ^ (x 6= s(y) . x0 6= s(y))

Il est maintenant possible de simplifier la premi`ere partie en x = 0 et la deuxi`eme partie en
utilisant la r`egle Q1; la formule devient:

x = 0 . (9z; x = s(z) ^ x0 6= s(z))
qui est purement existentielle.

De fa,con g'en'erale, si l'on diff`ere autant que possible l'utilisation de l'axiome de cl^oture du
domaine, on obtient un syst`eme de transformations qui termine (voir [26] pour plus de d'etail):

Th'eor`eme 1 ([26]) Il existe un syst`eme de r`egles de transformation qui termine et qui transforme tout probl`eme 'equationnel en une formule purement existentielle qui a m^eme ensemble de
solutions.

La r'esolution de formules 'equationnelles se ram`ene donc maintenant `a la r'esolution de formules purement existentielles ce qui est plus facile. D'efinissons tout d'abord les formes r'esolues:

D'efinition 1 Une forme r'esolue sera ici ?, ? ou bien une formule

9~z : x1 = t1 ^ : : : ^ xn = tn ^ x01 6= t01 ^ : : : ^ x0m = t0m
o`u les variables x1; : : : ; xn n'ont qu'une occurrence dans la formule et x01; : : : x0m sont des variables, distinctes de t01; : : : ; t0m respectivement.

13

Comme cons'equence du lemme 1, nous obtenons les bonnes propri'et'es des formes r'esolues:
Lemme 2 Les formes r'esolues distinctes de ? ont au moins une solution.

Proposition 1 ([26]) Il existe un syst`eme de r`egles de transformations de formules qui termine
et qui r'eduit toute formule purement existentielle en une disjonction (finie) de formes r'esolues
qui a m^eme ensemble de solutions.

Enfin, en mettant bout `a bout les r'esultats, nous obtenons:
Th'eor`eme 2 ([26]) Il existe un syst`eme de r`egles qui termine et qui transforme toute formule
'equationnelle OE en une disjonction (finie) de formes r'esolues, 'equivalente `a OE dans T (F ).

En particulier, si OE est une formule ferm'ee, elle est valide dans T (F ) si et seulement si l'une
de ses formes r'esolues est distincte de ?:

Corollaire 1 Dans le cas o`u F est fini, EQ [ F T [ (DCA) engendre une th'eorie compl`ete dont
un mod`ele est T (F ).

14

3 Formules 'Equationnelles dans des Alg`ebres Quotient
Je d'ecris ici des extensions des r'esultats du paragraphe pr'e'edent `a la r'esolution de formules
'equationnelles dans certains quotients de l'alg`ebre des termes. Ces r'esultats sont d'ecrits dans

deux articles [17, 25], le second 'etant le fruit d'une collaboration avec M. Haberstrau et J.-P.
Jouannaud.

Mal'cev dans [68] n''etudie pas seulement les classes d'alg`ebres localement libres qui sont
compl`etement axiomatisables, il consid`ere aussi des classes d'alg`ebres permutativement localement libres. En bref, ces alg`ebres, au lieu de satisfaire l'axiome de d'ecomposition de la figure 2,
satisfont un axiome de la forme:

8~x; ~y; f (x1; : : : ; xn) = f (y1; : : : ; yn) () .

ss2\Pi f

x1 = yss(1) ^ : : : ^ xn = yss(n)

o`u \Pi f est un sous-groupe du groupe sym'etrique Sn.

En effet, le remplacement de la r`egle issue de l'axiome de d'ecomposition:

f (s1; : : : ; sn) = f (t1; : : : ; tn) ! s1 = t1 ^ : : : ^ sn = tn
par la r`egle de mutation

f (s1; : : : ; sn) = f (t1; : : : ; tn) ! .

ss2\Pi f

(s1 = tss(1) ^ : : : ^ sn = tss(n))

ne complique pas beaucoup les preuves du paragraphe pr'ec'edent.

En fait l'id'ee de remplacer la d'ecomposition (et le Clash) par des r`egles de mutation est `a
la base des techniques propos'ees par C. Kirchner dans sa th`ese sur la conception syst'ematique
d'algorithme d'unification dans les th'eories 'equationnelles [53]. C. Kirchner introduit en effet la
notion de pr'esentation syntaxique qui permet de d'eriver imm'ediatement des r`egles de mutation
qui remplacent la d'ecomposition (qui est incompl`ete dans les th'eories 'equationnelles). Un ensemble d''equations E est dit syntaxique lorsque toute preuve d''egalit'e peut s'effectuer avec au
plus une 'etape `a la racine. Ce que l'on note:

s

\Lambda \Gamma !

E t ssi s

(6=\Lambda )\Lambda \Gamma \Gamma \Gamma \Gamma !

E

(\Lambda )=\Gamma \Gamma \Gamma !

E

(6=\Lambda )\Lambda \Gamma \Gamma \Gamma \Gamma !

E t

o`u \Lambda  est la position de la racine. La r`egle de mutation associ'ee `a un ensemble fini E d''equations
syntaxique peut s''ecrire quant `a elle:

f (s1; : : : ; sn) = g(t1; : : : ; tm) !.

f(v1;:::;vn)=g(w1;:::;wm)2E

9Var(v1; : : : ; vn; w1; : : : ; wm) : (s1 = v1 ^ : : : ^ sn = vn ^ t1 = w1 ^ : : : ^ tm = wm)

Les th'eories syntaxiques (c'est-`a-dire des th'eries engendr'ees par un ensemble fini d''equations
syntaxique) constituent donc un bon candidat pour g'en'eraliser les th'eories permutatives. Malheureusement, il y a des limites th'eoriques: R. Treinen a montr'e que la th'eorie de T (F )==E est
ind'ecidable lorsque E est constitu'e des axiomes d'associativit'e et de commutativit'e d'un symbole
de fonction, ou m^eme de l'associativit'e seule [81], alors que ces deux th'eories sont syntaxiques
(ce n'est pas trivial pour les axiomes AC; voir par exemple l'article de C. Kirchner et F. Klay
[58]). La r`egle de mutation seule pose elle-m^eme des probl`emes de terminaison.

Plusieurs autres probl`emes se posent lorsqu'on cherche `a g'en'eraliser les r'esultats de Mal'cev
`a des th'eories syntaxiques non n'ecessairement permutatives. En voici quelques-uns:

15

ffl La r'esolution d''equations (unification) peut n'ecessiter l'introduction de variables auxilliaires (quantifi'ees existentiellement). C'est par exemple le cas pour l'unification AC: l'une
des formes r'esolues de x1 +x2 = x3 +x4 est 9z1; z2; z3; z4 : x1 = z1 +z2 ^x2 = z3 +z4 ^x3 =
z1 + z3 ^ x4 = z2 + z4, si l'on suppose que + est AC. Il n'y a aucun moyen ici d''eliminer
ces variables quantifi'ees existentiellement. Par voie de cons'equence, la r'esolution d'une
dis'equation va introduire des quantificateurs universels. La simplification des 'equations
et dis'equations, qui est indispensable `a l''elimination des quantificateurs, va donc en sens
contraire de ce qu'on souhaite, puisqu'elle introduit, au lieu d''eliminer, les quantifications.

ffl le deuxi`eme probl`eme est la r'esolution d''equations cycliques. En effet, la r`egle de test

d'occurrence n'est pas, en g'en'erale, correcte dans les quotients de T (F ); on peut fort bien

avoir une identit'e u

\Lambda \Gamma \Gamma !

E t[u]p avec p 6= \Lambda . Une solution serait bien s^ur de supposer quele test d'occurrence reste correct dans la th'eorie 'equationnelle consid'er'ee. C'est le cas par

exemple des th'eories permutatives. C'est aussi l'hypoth`ese effectu'ee par C. Kirchner dans
sa th`ese [53]. Mais, comme nous allons le voir, il est possible de r'esoudre autrement ce
probl`eme, en utilisant des r`egles analogues aux r`egles de mutation, mais pour la r'esolution
des 'equations cycliques.

ffl Le troisi`eme probl`eme est que le lemme d'ind'ependence des dis'equations (lemme 1) n'est

pas correct dans tous les quotients de T (F ).

Une solution du premier probl`eme consiste `a se restreindre aux th'eories 'equationnelles
minces, c'est-`a-dire engendr'ees par un ensemble fini d''equations s = t telles que les variables de
s et t apparaissent `a la profondeur au plus 1. Des exemples de telles th'eories sont les th'eories
permutatives de Mal'cev ou les th'eories engendr'ees par un ensemble fini d''equations closes. Tout
d'abord

Lemme 3 ([25]) Les th'eories minces sont syntaxiques.

En fait, il existe m^eme un ensemble fini, mince et syntaxique d''equations engendrant la
th'eorie. Il est alors possible d''eliminer imm'ediatement les variables introduites par mutation
car celles-ci se trouvent toujours ^etre membre d'une 'equation (ou d'une dis'equation si elles sont
quantifi'ees universellement). Le premier probl`eme 'evoqu'e ci-dessus est donc r'esolu dans les
th'eories minces.

Pour r'esoudre les cycles, on peut employer un proc'ed'e analogue:

D'efinition 2 ([25]) Une r`egle de r'e'ecriture l ! r est effondrante si, pour toute substitution oe,
jloej ? jroej.

Un ensemble d''equations E est syntaxique pour les cycles si, pour toute identit'e t[u]p

\Lambda \Gamma \Gamma !

E utelle que p 6= \Lambda , il y a un pr'efixe strict q de p et une preuve de la forme

t[u]p

(?q)\Lambda \Gamma \Gamma !

E

q\Gamma \Gamma !
l!r

\Lambda \Gamma \Gamma !
E u

o`u l ! r est une r`egle effondrante de E.

Dans les th'eories syntaxiques pour les cycles, le deuxi`eme probl`eme 'evoqu'e plus haut se
r'esoud ais'ement. Or,

Lemme 4 ([25]) Les th'eories minces sont syntaxiques pour les cycles.

16

Il faut noter que les deux lemmes ci-dessus s'obtiennent par des techniques de compl'etion
ordonn'ee de syst`emes de r'e'ecriture.

Le troisi`eme probl`eme se r'esoud aussi dans les th'eories minces, car ces th'eories satisfont un
crit`ere de validit'e du lemme d'ind'ependence des dis'equations (voir [17]).

Il reste bien s^ur `a prouver la terminaison de l'ensemble des r`egles de transformation de
formules. C'est le r'esultat principal de [17].

Th'eor`eme 3 ([17, 25]) Soit E un ensemble d''equations engendrant une th'eorie mince. Il
existe un syst`eme de r`egles qui termine et qui transforme toute formule 'equationnelle OE en une
disjonction finie de formes r'esolues 'equivalente `a OE dans T (F )==E .

Ce qui permet en outre de g'en'eraliser le r'esultat de Mal'cev: si E est un ensemble d''equations
minces, alors T (F )==E admet une axiomatisation r'ecursive compl`ete (que nous ne donnons pas
ici, mais le lecteur peut se reporter aux articles pr'ecit'es.

17

4 'Elimination de la n'egation
Revenant aux formules 'equationnelles du paragraphe 2, j'ai omis de discuter du choix des formes
r'esolues. En fait, on aimerait obtenir, si c'est possible, une formule 'equationnelle sans n'egation
qui a m^eme ensemble de solutions que la formule de d'epart. Ce probl`eme a 'et'e abord'e par J.-L.
Lassez et K. Marriott [64] dans le cas de probl`emes de compl'ement. C'est h'elas toujours un
probl`eme ouvert dans le cas g'en'eral de formules 'equationnelles. Pour notre part, nous avons
pu obtenir un syst`eme de r`egles de transformation qui 'elimine la n'egation chaque fois que c'est
possible, pour le sous-ensemble SED des probl`emes 'equationnels d'efini comme suit. OE est SED
si l'une de ses formes normales conjonctives s''ecrit

9 ~w; 8~y : d1 ^ : : : ^ dn
o`u chaque di est une 'equation ou une disjonction de dis'equations. En d'autres termes OE ne doit
pas contenir de sous-formule de la forme s 6= t . u = v.

Les r'esultats que nous avons obtenus se fondent d'une part sur une s'erie de lemmes 'etablissant
des classes de formules qui ne sont pas 'equivalentes `a des formules sans n'egation, d'autre part sur
un syst`eme de r`egles de transformation dont les formes r'esolues sont ou bien des formules sans
n'egation, ou bien des formules dont on a prouv'e qu'elles ne peuvent ^etre 'ecrites sans n'egation.

4.1 R'esultat de non-'equivalence avec des probl`emes d'unification
Appelons probl`eme d'unification toute formule 'equationnelle ne contenant pas de dis'equations
(et pas de n'egation). On suppose aussi (et cela, jusqu'`a la fin du paragraphe) que T (F ) est infini
et F est fini. L''equivalence de deux formules est d'efinie par: OE ,  si et seulement si OE et  ont
m^eme solutions. Une formule OE est alors EU si elle est 'equivalente `a un probl`eme d'unification.

Nous avons d'abord prouv'e les lemmes suivants (qui sont analogues `a ceux de J.-L. Lassez
et K. Marriott [64]):

Lemme 5 Soit oe est une substitution idempotente distincte telle que oe(X) ne contient aucun
terme clos. Alors s 6= soe n'est pas EU d`es que soe 6j s.

Ce r'esultat est ensuite progressivement g'en'eralis'e:
Lemme 6 Soit P j u1 6= t1 ^ : : : ^ un 6= tn tel que, pour tout i, ui; ti sont des termes non clos,
sans variables communes et tels que ui j tioei o`u oei(X) " T (F ) = ;, alors P n'a pas la propri'et'e
EU .

D'efinition 3 Un probl`eme simple est ou bien ? ou ? ou bien une formule de la forme

9 \Gamma !w : x1 = t1 ^ : : : ^ xn = tn ^ d1 ^ : : : ^ dn
o`u

1. x1; : : : ; xn sont les variables libres de la formule. Elles apparaissent une fois seulement

dans celle-ci.

2. Var(d1; : : : ; dm) ` Var(t1; : : : ; tn) ` \Gamma !w
3. Chaque di est une disjonction de dis'equations de la forme z1 6= u1 .: : : .zk 6= uk o`u chaque

zj est une variable qui appara^it une seule fois dans chaque di et aucun des termes ui n'est
clos.

18

Lemme 7 Tout probl`eme simple qui n'est pas un probl`eme d'unification, n'a pas la propri'et'e
EU .

Il reste maintenant `a montrer comment se ramener syst'ematiquement `a des probl`emes simples.

4.2 Transformation des formules
Il est exclu de pr'esenter ici l'ensemble des r`egles de transformation. Donnons seulement quelques
exemples illustrant les difficult'es qui s'ajoutent aux probl`emes 'evoqu'es dans le paragraphe 2.

Exemple 2 Supposons, dans cet exemple et dans les suivants, que F = f+; s; 0g. La formule

x 6= 0
bien qu''etant en forme r'esolue, au sens du paragraphe 2, poss'ede la propri'et'e EU ; elle est
'equivalente `a

(9z : x = s(z)) . (9z1; z2 : x = z1 + z2)

Cet exemple montre qu'il faut utiliser l'axiome de cl^oture du domaine dans d'autres circonstances que celles qui ont 'et'e 'evoqu'ees dans le paragraphe 2, ce qui va compliquer la preuve de
terminaison.

Exemple 3 Consid'erons cette fois la formule

9z; x : y = z + x ^ (x 6= s(z) . z 6= s(x)):
Si l'on utilise les transformations du paragraphe 2, on obtiendra deux formes r'esolues, n'ayant
pas la propri'et'e EU d'apr`es le lemme 7. Or ce probl`eme a la propri'et'e EU : il suffit de remarquer
que la disjonction est toujours vraie.

Ces cas seront r'esolus en effectuant le remplacement x 6= t . d ! x 6= t . dfx 7! tg m^eme
dans des situations o`u x n'est pas quantifi'ee existentiellement.

Le dernier exemple que je donne ci-dessous est un exemple de formules qui n'est pas SED
et pour lequel mon syst`eme de transformations 'echoue.

Exemple 4

9z1; z2 : x = s(z1) . x = z1 + z2 . y 6= s(x)
est 'equivalente `a

9z1; z2 : x = s(z1) . x = z1 + z2 . y = 0 . y = z1 + z2 . y = s(s(z1)) . y = s(z1 + z2)
Th'eor`eme 4 Il existe un syst`eme de r`egles qui termine et tel que la forme irr'eductible d'un
probl`eme SED est une formule simple 'equivalente.

Bien s^ur, avec le lemme 7, on en d'eduit une technique de d'ecision de la propri'et'e EU pour
les probl`emes SED.

4.3 'Elimination de la n'egation dans un quotient
L'extension des r'esultats pr'ec'edents lorsque l'interpr'etation est un quotient T (F )==E a 'et'e
'etudi'ee par M. Fernandez. Les r'esultats des paragraphes pr'ec'edents s''etendent sans peine au

cas d'un quotient par une congruence =E engendr'ee par des 'equations permutatives (au sens de
Mal'cev). D'autres extensions sont `a l''etude, mais aucun r'esultat n'a 'et'e obtenu jusqu'`a pr'esent.
Le cas associatif-commutatif serait particuli`erement int'eressant. Le seul r'esultat remarquable
dans le cas AC est la d'ecidabilit'e de l'existence d'une solution `a un probl`eme de compl'ement
(au moins dans le cas lin'eaire) [60].

19

5 Contraintes d'appartenance
Je d'ecris dans ce paragraphe le contenu de l'article [22] qui est le fruit d'une collaboration avec
C. Delor.

Jusqu'`a pr'esent je n'ai consid'er'e que des alg`ebres non-typ'ees. Une question naturelle (qui
se pose en particulier dans les applications) est d''etendre les r'esultats pr'ec'edents `a certaines
alg`ebres de termes avec sortes ordonn'ees. Ces alg`ebres ont 'et'e d'abord introduites par J.
Goguen et J. M'eseguer [37] pour pouvoir sp'ecifier des fonctions qui ne pouvaient l'^etre en
logique 'equationnelle. D'un point de vue syntaxique, une signature est donn'ee par

ffl un ensemble fini de symboles de sortes S
ffl un ensemble fini de symboles de fonction F
ffl un ensemble fini de d'eclarations de la forme s ^ s0 o`u s; s0 2 S, ce qui doit d'efinir une

relation d'ordre sur S

ffl une application a de F dans les entiers naturels appel'ee arit'e
ffl pour chaque f 2 F un ensemble (fini) de profils qui sont des paires compos'ees d'un

'el'ement de Sa(f) et d'un 'el'ement de S. Si ((s1; : : : ; sn); s) est dans le profil de f , on note

g'en'eralement f : s1 \Theta  : : : \Theta  sn ! s.

En fait, une signature n'est rien d'autre qu'un automate d'arbres d''etats finis (plus pr'ecis'ement
un automate ascendant). Je me r'ef`ererai d'ailleurs au livre de G`ecseg et Steinby [36] pour tout
ce qui concerne les langages d'arbres reconnaissables. Mais on peut aussi se reporter au cours
de Ma^itrise de M. Dauchet [28].

L'unification dans les alg`ebres `a sortes ordonn'ees a fait couler beaucoup d'encre (cf. par
exemple [85, 76, 77, 54, 69, 78]). Diverses hypoth`eses sont prises par les auteurs (la r'egularit'e
par exemple) qui n'ont en fait de sens o`u m^eme d'int'er^et que si l'on cherche un ensemble complet
d'unificateurs. Or c'est rarement utile. Comme nous l'avons d'ej`a 'etabli en introduction, il nous
suffit d'obtenir des formes r'esolues. Ceci est possible, si l'on consid`ere explicitement les sortes
des variables comme des contraintes de type.

J''etudie donc ici des formules du premier ordre dont les atomes sont des 'equations, des
dis'equations ou des contraintes de type de la forme t 2 i o`u i est une expression de sorte. Les
pr'edicats 2 i sont intepr'et'es comme des langages d'arbres reconnaissables, ou, plus g'en'eralement,
comme des langages reconnus par des automates avec tests d''egalit'e entre fr`eres [4], ce qui correspond d'ailleurs `a certaines signatures avec d'eclarations de termes [77].

La r'esolution de ces formules donne bien s^ur comme cas tr`es particulier l'unification dans
l'alg`ebre libre avec sortes ordonn'ees (sans hypoth`eses sur la signature). J'en profite aussi pour
affaiblir le contr^ole utilis'e pour la r'esolution des formules 'equationnelles. Il s'est av'er'e en effet
que la mise en forme normale conjonctive, `a chaque 'etape, des formules 'equationnelles, pouvait
^etre une op'eration extr`emement co^uteuse, `a cause de la distributivit'e de . par rapport `a ^.

Nous 'evitons donc ici autant que possible d'imposer une mise en forme normale. De m^eme, nous
"lib'eralisons" le contr^ole impos'e `a l'utilisation de l'axiome de cl^oture du domaine de fa,con `a pouvoir 'eliminer n'importe quel quantificateur en cas d'imbrications multiples. Cette lib'eralisation
est la principale difficult'e r'esolue dans [22]: la terminaison du syst`eme de r`egles est beaucoup
plus difficile.

Enfin, la r'esolution de ces formules avec contraintes d'appartenance permet de r'esoudre le
probl`eme de la compl'etude suffisante dans des cas particuliers, par simple r'eduction de formule.

20

5.1 Syntaxe des formules
S est un ensemble fix'e (fini) de symboles de sorte. Alors, l'ensemble ES des expressions de sorte
est le plus petit ensemble qui contient S ainsi que les deux formules triviales ? et ? et qui
v'erifie:

ffl Si i; i0 2 ES, alors i ^ i0, i . i0, :i 2 ES
ffl Si i1; : : : ; in 2 ES et f 2 F a pour arit'e n, alors f (i1; : : : ; in) 2 ES.

J'appelle maintenant formule 'equationnelle les formules du premier ordre dont les atomes
sont de la forme s = t, s 6= t ou s 2 i o`u i 2 ES.

On suppose que les formules ne comportent pas de n'egation explicite (:(s 2 i) est transform'e
en s 2 (:i)). Par contre, les formules ne sont pas n'ecessairement en forme pr'enexe.

5.2 Interpr'etation des formules
Pour chaque s 2 S, [[s]] est un sous-ensemble reconnaissable de T (F ). Cette interpr'etation
s''etend de fa,con 'evidente:

ffl [[?]] = T (F ) et [[?]] = ;
ffl [[i ^ i0]] = [[i]] " [[i0]], [[i . i0]] = [[i]] [ [[i0]], [[:i]] = T (F ) n [[i]]
ffl [[f (i1; : : : ; in)]] = ff (s1; : : : ; sn) j 8i; si 2 [[ii]]g.

Les langages reconnaissables poss`edent la propri'et'e int'eressante suivante:
Lemme 8 Pour chaque symbole de fonction n-aire f (n * 1), il existe une application (calculable) not'ee f \Gamma 1 qui associe `a chaque expression de sorte un ensemble fini de n-uples d'expressions
de sortes telles que:

f (s1; : : : ; sn) 2 [[i]] () 9(i1; : : : ; in) 2 f \Gamma 1(i); 8i; si 2 [[ii]]
pour tous termes s1; : : : ; sn et toute expression de sorte i.

L'interpr'etation des formules atomiques (et par suite des formules du premier ordre) s'obtient
`a l'aide de [[\Delta ]]:

ffl oe est solution de t 2 i si toe est 'el'ement de [[i]].
ffl oe est solution de s = t (resp. de s 6= t) si soe j toe (resp. soe 6j toe).2

Nous pouvons aussi interpr'eter les sortes dans la classe des langages reconnaissables par des
automates avec tests d''egalit'e entre fr`eres (cf. [4]). Cette classe (appel'ee REC=) est en effet
close par toutes les op'erations bool'eennes et poss`ede les propri'et'es de d'ecision n'ecessaires aux
r'esultats qui vont suivre. Il y a aussi pour ces langages une propri'et'e analogue au lemme 8 (voir
[22]). Mais, pour fixer les id'ees, je garde jusqu'`a la fin de ce paragraphe une interpr'etation dans
les langages reconnaissables.

2Ici, comme dans le paragraphe pr'ec'edent, j d'esigne l'identit'e des arbres.

21

(Q5) 8y : d . y 6= t ! dfy 7! tg
Si y 62 Var(t).

(Q7) 8~y : z1 = u1 . : : : . zn = un . y1 2 i1 . : : : . ym 2 im . d ! d
Si

ffl z1; : : : ; zn sont des variables
ffl pour tout i, Var(zi; ui) " ~y 6= ;
ffl ~y " Var(d) = ;
ffl y1; : : : ; ym 2 ~y sont distinctes
ffl [[i1]]; : : : [[im]] ne sont ni finis ni co-finis

Figure 3: R`egles d''elimination des quantificateurs universels
5.3 Formes r'esolues
Les formes r'esolues ne contiennent pas seulement des 'equations et des dis'equations, mais aussi
des contraintes d'appartenance:

D'efinition 4 Une formule est en forme r'esolue si c'est ?, ? ou bien si elle est de la forme:

9~z : x1 = t1 ^ : : : ^ xn = tn ^ x01 = t01 ^ : : : ^ x0m = t0m ^ x001 2 i1 ^ : : : ^ x00k 2 ik
o`u

ffl x1; : : : ; xn; x01; : : : ; x0m; x001; : : : ; x00k sont des variables
ffl x1; : : : ; xn n'ont qu'une occurrence dans la formule
ffl chacune des variables apparaissant dans x01; t01; : : : x0m; t0m a au moins une ocurrence dans

l'un des termes t1; : : : ; tn

ffl x001; : : : ; x00k sont distinctes deux `a deux et ont chacune au moins une occurrence dans l'un

des termes t1; : : : ; tn

ffl Pour tout i, [[ii]] est infini

Il est possible d'obtenir une forme l'eg`erement 'etendue du lemme 1 qui permet de prouver
que toute forme r'esolue distincte de ? admet au moins une solution.

5.4 Simplification des formules
Les r`egles de transformation sont essentiellement les m^emes que pour les formules 'equationnelles
du paragraphe 2. Je donne dans la figure 3 les deux r`egles fondamentales permettant l''elimination
d'un quantificateur universel (par n'egation on a aussi les r`egles permettant l''elimination des
quantificateurs existentiels).

22

Outre ces r`egles d''elimination de quantificateurs, le syst`eme de transformations contient des
r`egles structurelles comme la distributivit'e (de ^ par rapport `a . comme de . par rapport `a ^,
mais dans des conditions qui 'evitent de boucler), ou comme la r`egle

8~y : P ^ Q ! (8~y : P ) ^ (8~y : Q)
Enfin, le syst`eme de r`egles contient des r`egles permettant de tra^iter les pr'edicats d'appartenance, comme la r`egle de d'ecomposition issue du lemme 8.

Le syst`eme obtenu a bien les propri'et'es voulues:

Th'eor`eme 5 ([22]) Il existe un syst`eme de r`egles qui termine et qui transforme toute formule
'equationnelle (avec contraintes d'appartenance) en une disjonction finie de formes r'esolues qui

lui est 'equivalente.

Comme dans le paragraphe 2, on d'eduit de ce r'esultat une axiomatisation compl`ete de la
structure.

5.5 Application `a la compl'etude suffisante
La compl'etude suffisante est une propri'et'e introduite par J. Guttag et J. Horning [39] et qui
exprime le fait que la sp'ecification d'une "nouvelle" fonction f n'introduit pas de nouvelle valeur
dans les domaines pr'ec'edemment d'efinis. Autrement dit, c'est une propri'et'e d'incr'ementatlit'e
des sp'ecifications. Plus formellement, soit \Sigma 1 = (S1; F1; E1) une sp'ecification, c'est-`a-dire -un
ensemble fini de symboles de sorte -un ensemble fini de symboles de fonction avec leurs profils -un
ensemble finis d''equations sur T (F1; X). Soit \Sigma 2 = (S1 [ S2; F1 [ F2; E1 [ E2). La sp'ecification
\Sigma 2 est suffisamment compl`ete par rapport `a \Sigma 1 si tout terme t contenant un symbole de F2 et
de sorte s 2 S1 peut ^etre prouv'e 'egal (modulo E1 [ E2) `a un terme de T (F1).

Cette propri'et'e est ind'ecidable en g'en'eral, comme l'ont montr'e J. Guttag et J. Horning [39].
Mais, si l'on suppose que E1 [ E2 peut ^etre orient'ee en un syst`eme de r'e'ecriture convergent R,
et sous d'autres hypoth`eses que je ne rappelle pas ici, la compl'etude suffisante de \Sigma 2 par rapport
`a \Sigma 1 est 'equivalente `a la r'eductibilit'e inductive, pour tous les symboles f 2 F2, de f (x1; : : : ; xn)
par rapport `a R.

D'efinition 5 ([47]) Un terme t est inductivement r'eductible par rapport au syst`eme de r'e'ecriture
R si toutes les instances closes de t sont r'eductibles par R.

Exemple 5
On suppose qu'il n'y a qu'une sorte. F1 = f0; sg, F2 = f+g et

E2 = R = f0 + x ! x; s(x) + y ! s(x + y)g:
Alors, x + y est inductivement r'eductible par rapport `a R (mais pas r'eductible). En fait, la
sp'ecification de + est suffisamment compl`ete par rapport `a F1 et `a E1 = ;.

La r'eductibilt'e inductive a quant `a elle 'et'e prouv'ee d'ecidable par D. Plaisted [73]. Mais
l'algorithme de Plaisted, comme les algorithmes qui ont suivi (y compris celui qui est d'ecrit dans
le paragraphe 8) sont tr`es complexes. Il se trouve que la r'eduction de formules 'equationnelles
avec contraintes d'appartenance nous permet de d'ecider simplement par r'eduction de formules
de la r'eductibilit'e inductive, non pas dans le cas g'en'eral, mais dans un ensemble de situations
int'eressant. En fait, si l'on suppose que l'ensemble des termes de T (F1) qui sont irr'eductibles
est reconnaissable par un automate d''etats finis (ce r'esultat s''etend en fait, comme la r'esolution
des formules 'equationnelles, au cas o`u T (F1) est reconnu par un automate avec tests d''egalit'e

23

entre fr`eres), alors la r'eductibilit'e inductive de f (x1; : : : ; xn) (pour f 2 F2) est d'ecidable par
simplification de la formule suivante:

8x1; : : : ; xn; 9Var(l1; : : : ; lk) :

x1 2 :N F . : : : . xn 2 :N F . f (x1; : : : ; xn) = l1 . : : : . f (x1; : : : ; xn) = lk

si l1; : : : ; lk sont les membres gauches des r`egles de R dont le symbole de t^ete est f et N F est le
langage des termes de T (F1) qui sont irr'eductibles. La formule se r'eduit `a ? pour tout f 2 F2
si et seulement si la sp'ecification est suffisamment compl`ete.

24

6 Contraintes d'Ordre
Je pr'esente dans ce paragraphe le contenu de l'article [16].

J'ai d'ej`a montr'e dans le paragraphe 1.5 que les contraintes de la forme s ? t permettent
d'exprimer dans les formules elles-m^emes (au lieu des r`egles d'inf'erence) une strat'egie ordonn'ee.
Il est plus avantageux d'exprimer le contr^ole au sein les formules lorsque celui-ci consiste en une
condition d'existence dont la preuve est constructive: la contrainte permet de garder trace, non
seulement du fait que la condition d'application de la r`egle a p^u ^etre satisfaite, mais aussi des
valeurs des variables quantifi'ees existentiellement qui ont permis de la satisfaire. Ce qui autorise
des raffinements dans des 'etapes ult'erieures de d'eduction. Donnons-en un exemple:

Exemple 6 Soit F = ff; g; 0g et * l'ordre lexicographique sur les chemins (voir par exemple
l'article de synth`ese de N. Dershowitz [29] pour une d'efinition compl`ete) 'etendant la pr'es'eance:
0 ? f ? g. (Cet exemple n'a pas de signification int'eressante, il est juste construit pour illustrer
les diff'erentes strat'egies). Soit enfin E = ff (x) = a; f (f (x)) = g(x)g. Par superposition (en
utilsant la version contrainte de la r`egle de d'eduction), on obtient:

f (x) = a f (f (x)) = g(x)
f (f (x)) ? a ^ f (f (x)) ? g(x) : g(x) = a

La contrainte se simplifiant en x * a.
Maintenant, l'inf'erence

a = f (x) x * a : a = g(x)
x * a ^ a ? f (x) ^ a ? g(x) : f (x) = g(x)

est bloqu'ee par l'insatisfaisabilit'e de la contrainte, alors qu'elle aurait 'et'e possible si nous n'avions
pas gard'e la condition x * a dans le r'esultat de la premi`ere d'eduction.

De toutes les fa,cons, qu'on garde ou non la contrainte dans la formule, il faut d'ecider de la
satisfaisabilit'e des contraintes pour savoir si une r`egle est applicable. (Mais dans le cas o`u les
contraintes sont conserv'ees dans les formules il est aussi important d'obtenir une forme simplifi'ee
des contraintes). Dans le cas de la compl'etion avec contraintes d'ordre, l'ordre sur les termes
doit ^etre un ordre de r'eduction (i.e. monotone et bien fond'e) et doit ^etre total sur les termes clos.
L'exemple le plus simple d'un ordre ayant ces propri'et'es est le lexicographic path ordering (not'e
*lpo dans la suite) d'efini par N. Dershowitz (voir [29] par exemple). C'est donc la r'esolution de
contraintes d'ordre dans lesquelles * est interpr'et'e par *lpo qui m'int'eresse en premier. C'est
le sujet de l'article [16]: le fragment existentiel de la th'eorie d'un ordre lexicographique sur les
chemins est d'ecidable.

Donnons maintenant un aper,cu de la technique de d'ecision.

6.1 Les formules consid'er'ees et leur interpr'etation
Les formules que nous consid'erons sont des formules du premier ordre sans quantificateur dont
les atomes sont des 'equations s = t ou bien des in'equations s ? t o`u s et t sont des termes
form'es sur un alphabet fini quelconque (mais fixe) F qui contient au moins une constante et un
symbole non constant. F est suppos'e ^etre muni d'un ordre total *F appel'e pr'es'eance.

L''egalit'e est interpr'et'ee comme l'identit'e des termes et le symbole ? est interpr'et'e comme
?lpo dont je rappelle la d'efinition:

s j f (s1; : : : ; sn) ?lpo g(t1; : : : ; tm) j t ssi

25

ffl Ou bien 91 ^ i ^ n; si *lpo t
ffl Ou bien f ?F g et 81 ^ i ^ m, s ?lpo ti
ffl Ou bien f = g et

- 81 ^ i ^ n, s ?lpo ti
- et 91 ^ j ^ n, 81 ^ k ! j; sk j tk et sk ?lpo tk

Le probl`eme se ram`ene tout d'abord de fa,con 'evidente `a tester la satisafaisabilit'e d'une
formule

s1 = t1 ^ : : : ^ sn = tn ^ u1 ? v1 ^ : : : ^ um ? vm

La technique employ'ee peut alors se d'ecomposer en 3 'etapes, chacune faisant l'objet d'un
paragraphe ci-dessous.

6.2 Formes r'esolues
La d'efinition de l'ordre lexicographique sur les chemins et les r`egles d'unification permettent de
transformer n'importe quelle formule in'equationnelle en une disjonction finie de formes r'esolues
qui sont soit ? ou ? soit de la forme

x1 = t1 ^ : : : ^ xn = tn ^ y1 ? u1 ^ : : : ^ ym ? um ^ z1 ! v1 ^ : : : ^ zk ! vk
o`u x1; : : : ; xn sont des variables qui n'ont qu'une occurrence dans la formule, y1; : : : ; ym; z1; : : : ; zk
sont des variables.

Malheureusement, des exemples tr`es simples montrent qu'il existe des formes r'esolues qui
n'ont pas de solution:

Exemple 7 Soit F = f0; sg avec s ? 0. Alors s(x) ? y ^ y ? x n'a aucune solution car, pour
tout terme x, s(x) est son successeur (au sens des ordinaux).

6.3 Cl^oture des formules
Les 'equations sont tout d'abord 'elimin'ees des formes r'esolues en identifiant de fa,con non
d'eterministe les termes apparaissant dans la formule et en effectuant les remplacements correspondant. (Apr`es cette 'etape, les termes non identidi'es sont suppos'es distincts). La formule
est ensuite lin'earis'ee de fa,con non d'eterministe. Autrement dit: on choisit de fa,con arbitraire un
ordre total sur tous les termes (ou sous-termes) apparaissant dans la formule, qui soit compatible
avec les in'egalit'es d'ej`a pr'esentes et avec la d'efinition de *lpo.

Le r'esultat de cette "cl^oture" d'une forme r'esolue est un ensemble fini de formules de la
forme

OE j t1 ? : : : ? tn

et qui sont "closes pas d'eduction". En effet, la normalisation, par le syst`eme de r`egles du
paragraphe pr'ec'edent, de n'importe quelle partie de OE doit conduire `a une disjonction de formes
r'esolues dont une au moins est une sous-formule de OE. Cette propri'et'e de "cl^oture par d'eduction"
sera extr`emement utile dans le paragraphe suivant.

6.4 Propri'et'es de la fonction successeur et r`egles de transformation les refl'etant
L'ensemble de tous les termes avec variables peut se d'ecomposer en trois ensembles:

ffl l'ensemble Succ des termes dont toutes les instances sont des ordinaux successeurs

26

ffl l'ensemble Lim des termes dont toutes les instances sont des ordinaux limites.
ffl l'ensemble Ver des termes "versatiles" dont les instances ont tant^ot successeurs, tant^ot

limites.

Exemple 8 Soit F = f+; 1; 0g avec + ? 1 ? 0. Alors 0 + (1 + x) 2 Succ car ce terme est
toujours le successeur de 1 + x, quel que soit le terme x.

1 + x 2 Lim et x + 0 2 Ver car, si x = 0 c'est un ordinal successeur et, si x 6= 0, c'est un
ordinal limite.

Pour *lpo, deux autres ensembles de termes jouent un r^ole particulier: l'ensemble N des
termes strictement inf'erieurs `a ! et l'ensemble N (X) des termes dont une instance est dans
N . En effet, si t 2 Succ et t 62 N (X), alors, non seulement toutes les instances de t sont des
ordinaux successeurs, mais on peut trouver un terme u tel que, pour tout oe, toe est le successeur
de uoe.

Exemple 9 0 + (1 + x) 2 Succ \Gamma  N (X); c'est le successeur de 1 + x ind'ependemment de x. Par
contre 0 + x 2 Succ mais 0 + 0 est le successeur de 1 alors que 0 + (1 + x) est le successeur de
1 + x: l'expression du terme dont c'est le successeur d'epend de la position de x par rapport `a !.

Consid'erons maintenant un probl`eme t1 ? : : : ? tn. Soit x la plus grande variable dans
cet ordre lin'eaire. Soit tk le terme juste `a gauche de x. Tout d'abord, gr^ace aux propri'et'es
de cl^oture, on peut 'eliminer tous les termes ti, i ^ k qui contiennent x (voir [16] pour plus de
d'etail). Ensuite, si tk 2 Lim, alors on peut 'eliminer x de la s'equence (il y aura "toujours la
place" pour x). Si tk 2 Succ \Gamma  N (X), alors tk peut s''ecrire comme le successeur de uk et le
probl`eme a une solution si et seulement si il a une solution pour x = uk. En rempla,cant x par uk
on est ramen'e `a un probl`eme comportant une variable de moins. Si maintenant tk est versatile
et si tk 62 jcalN (X), on remplace tk par des instances qui permettent de choisir entre Succ et
Lim.

Il ne reste plus maintenant que le cas o`u tk 2 N (X). Dans ce cas, on peut d'abord 'eliminer
de la s'equence tous les termes qui ne sont pas dans N (X). Ensuite, je montre qu'un probl`eme
dont tous les termes sont dans N (X) a une solution si et seulement si il a une solution associant
`a toutes les variables un terme de N . La r'esolution du syst`eme d'in'equations se ram`ene alors `a
la r'esolution d'un syst`eme d''equations lin'eaires diophantiennes.

On en d'eduit:

Th'eor`eme 6 ([16]) Le fragment existentiel de la th'eorie d'un ordre lexicographique sur les
chemins est d'ecidable.

La technique propos'ee ici est en fait doublement exponentielle, `a cause de la deuxi`eme 'etape
qui comporte deux choix non-d'eterministes correspondant `a un passage aux parties de l'ensemble
des termes. Mais, s'il est facile de montrer que le probl`eme est NP-difficile, la complexit'e
intrins`eque du probl`eme reste `a trouver.

6.5 Extensions
Ce r'esultat a 'et'e 'etendu `a d'autres notations ordinales par J.-P. Jouannaud et M. Okada [50].
Si la pr'es'eance n'est pas totale, le probl`eme reste ouvert de savoir si le fragment existentiel de
la th'eorie de *lpo est d'ecidable. N'eanmoins, dans ce cas de pr'es'eance partielle, R. Treinen a
montr'e que le fragment \Sigma 4 la th'eorie de *lpo est ind'ecidable [82]. (La d'ecidabilit'e de la th'eorie
du premier ordre de *lpo en cas de pr'es'eance totale est 'egalement un probl`eme ouvert).

27

Les contraintes d'ordre dans lesquelles * est interpr'et'e par la relation de sous-terme ont aussi
'et'e 'etudi'ees (mais je n'en vois pas d'application 'evidente). Venkataraman a en effet montr'e que

le fragment existentiel de la th'eorie de l'ordre sous-arbre sur les arbres finis est d'ecidable, alors
que le fragment \Sigma 3 est ind'ecidable [84]. S. Tulipani a obtenu des r'esultats analogues dans le cas
des arbres infinis [83].

28
7 Compl'etion de syst`emes de r'e'ecriture avec contraintes

d'appartenance

Je d'ecris ici le contenu de l'article [21]. Ce travail se situe dans le courant r'ecent d''etude de la
r'e'ecriture contrainte dont j'ai trac'e les grandes lignes dans le paragraphe 1.8. En ce qui concerne
les contraintes d'appartenance (qui permettent, comme nous l'avons vu, d'exprimer les sortes
ordonn'ees), mes travaux s'apparentent `a ceux de H. Chen, J. Hsiang et H.-C. Kong [8, 7] et `a
ceux de C. Kirchner et H. Kirchner [55]. Mais le syst`eme de contraintes que j'ai choisi, comme
les r`egles de d'eduction, sont tr`es diff'erents de ceux qui sont choisis dans ces deux approches.
H. Chen, J. Hsiang et H.-C. Kong n'adoptent pas vraiment le point de vue de la r'e'ecriture
contrainte. De plus, leur langage, quoique plus expressif par certains aspects, ne permet pas
de contraindre une variable `a appartenir `a un langage r'egulier arbitraire. C. Kirchner et H.
Kirchner ont quant `a eux adopt'e un point de vue encore plus diff'erent puisque la notion de
r'eduction elle-m^eme est modifi'ee. Par contre, l'expressivit'e semble3 comparable `a la n^otre.

7.1 Le syst`eme de contraintes
Les contraintes que je consid`ere sont des formules exprimant l'appartenance `a un langage reconnaissable. En fait, les r`egles de compl'etion m'ont oblig'e `a 'etendre ce langage par l'introduction
de variables de second ordre, contraintes elles aussi `a appartenir `a des langages reconnaissables.
Plus pr'ecis'ement, S sera un ensemble fini de symboles de sorte, F un alphabet fini de symboles
de fonction avec leur arit'e, X un ensemble infini de symboles de variables (du premier ordre),
CX un ensemble infini de symboles de variables (monadiques de second ordre). T est l'ensemble
des termes de premier ordre construits sur cet alphabet, les symboles de CX `etant suppos'es
unaires. C est l'ensemble des termes de la forme t[X]p o`u X 2 CX et t 2 T .

Les expressions de sorte sont form'ees comme dans le paragraphe 5, avec la possibilit'e
suppl'ementaire d'appliquer une expression de contexte `a une expression de sorte. Les expressions
de contextes sont

ffl ou bien ?, ?, ffl (intepr'et'e par l'ensemble r'eduit `a l'application identit'e)
ffl ou bien une expression de sorte dans laquelle une sous-expression a 'et'e remplac'ee par une

expression de contexte.

ffl ou bien l'application d'une expression de contexte `a une expression de contexte
ffl ou bien C\Lambda  o`u C est une expression de contexte
ffl ou bien enfin n'importe quelle combinaison bool'eenne d'expressions de contexte.
Les contraintes sont alors des conjonctions de formules atomiques d'une des formes

ffl s = t o`u s; t 2 T
ffl s 2 i o`u s 2 T et i une expression de sorte
ffl t[X]p 2 C o`u t[X]p 2 C et C est une expression de contexte
ffl X = t[Y ]p o`u X 2 CX et t[Y ]p 2 C
3Je ne peux avoir de certitude tant que la version 'etendue de leur article n'est pas termin'ee.

29

Etant donn'e un automate d''etats finis A, les expressions de sortes sont interpr'et'ees, comme
dans le paragraphe 5 comme des sous-ensembles reconnaissables de T (l'interpr'etation de l'expression
de sorte i est not'ee [[i]]A). De m^eme, les expressions de contexte sont interpr'et'ees comme des
sous-ensembles reconnaisables de l'ensemble des applications de T dans T . L'interpr'etation
choisie est 'evidente, par exemple,

[[f (q1; : : : ; qn)[C]i]]A = f*x:f (t1; : : : ; tn)[u[x]p]i 2 Cj *x:u[x]p 2 [[C]]A; 8i; ti 2 [[qi]]Ag
Les contraintes sont interpr'et'ees en cons'equence: les symboles de pr'edicat 2i sont interpr'et'es
par [[i]]A et l''egalit'e est l'identit'e entre arbres.

7.2 D'eductions sur les 'equations contraintes
Les 'equations (et r`egles) contraintes consid'er'ees sont des 'equations et r`egles entre termes du premier ordre. En fait, on peut consid'erer que l''equation contrainte s = t k OE n'est que l'expression
de l'ensemble (infini) d''equations closes fsoe = toe j oe j= OEg.

L'orientation des 'equations contraintes ne pose pas de probl`eme (mais on pourrait raffiner
les techniques usuelles): s = t k OE s'oriente en s ! t k OE si s ? t pour un ordre de r'eduction
fix'e `a l'avance. Le calcul des paires critiques est par contre beaucoup plus int'eressant, puisque,
comme je l'ai expliqu'e le calcul habituel est incomplet. Il faut en fait rajouter une premi`ere
r`egle qui correspond aux cas o`u, en r'e'ecrivant sous une position variable, la contraintes initialement satisfaite, ne l'est plus, emp^echant ainsi d'obtenir la confluence du diagramme comme on
l'obtiendrait dans le cas non contraint.

l ! r k x 2 q ^ OE g ! d k 
rfx 7! X1(d)g = lfx 7! X1(d)g k OE0

Si OE0 est une forme r'esolue de X1(g) 2 q ^  ^ OE ^ X1(d) 62 q

Dans cette r`egle, X1 repr'esente le "saut" (inconnu) entre la position variable x et la position
`a laquelle est appliqu'ee la r`egle de r'e'ecriture g ! d. La condition X(d) 62 q exprime le fait
que la contrainte n'est plus satisfaite lorsque g ! d est appliqu'ee: la r`egle de d'eduction ajoute
exactement les paires de termes pour lesquels le lemme des paires critiques habituel 'echoue. Cet
ensemble, a priori infini, est "sh'ematis'e" avec l'aide de la variable X1.

Il faut ajouter `a cette r`egle et `a la r`egle de d'eduction classique une troisi`eme r`egle de
d'eduction correspondant aux superpositions "`a cheval" sur les variables de second ordre (voir
[21]). On obtient alors l'analogue du lemme de paires critiques:

Lemme 9 ([21]) Si s; t; u sont trois termes clos tels que s \Gamma 

R t \Gamma !R u, alors, ou bien s

\Lambda \Gamma !
R

\Lambda \Gamma 
R u,
ou bien il existe une r`egle de d'eduction D telle que R `D OE : l = r et s

\Lambda \Gamma !

R \Gamma \Gamma !OE: l=r

\Lambda \Gamma 
R u.

Il faut enfin pr'eciser la notion de simplification de termes avec variables (ce qui n'est pas
imm'ediat; en fait, plusieurs d'efinitions sont possibles). On obtient alors un ensemble de r`egles de
compl'etion pour lesquelles des r'esultats analogues aux r'esultats classiques peuvent ^etre 'etablis.

Il reste cependant `a s'assurer que le syst`eme de contraintes utilis'e ici poss`ede les propri'et'es
requises des syst`emes de contraintes qui ont 'et'e 'enonc'ees en introduction.

7.3 R'esolution des contraintes
Le probl`eme de la r'esolution des contraintes est, a priori, ardu puisque l'unification de second
ordre est ind'ecidable comme l'a montr'e W. Goldfarb [38]. Cependant, les contraintes dont la

30

compl'etion rend n'ecessaire la r'esolution constituent un fragment de la logique 'equationnelle
de second ordre. En effet, tous les termes intervenant dans les contraintes introduites par la
proc'edure de compl'etion v'erifient la propri'et'e suivante: si X 2 CX a deux occurrences p et
q dans le terme t, alors tjp j tjq. En d'autres termes, si l'on consid`ere les termes comme des
graphes acycliques, on peut supposer qu'ils sont lin'eaires. (i.e. que les variables apparaissent au
plus une fois).

Cette propri'et'e permet de ne consid'erer que les contraintes de la forme

s1 = t1 ^ : : : ^ sn = tn ^ X1 = U1 ^ : : : ^ Xm = Um ^ M
o`u

ffl M est une conjonction de contraintes d'appartenance
ffl s1; : : : ; sn 2 T
ffl Tous les termes ti -ou bien appartiennent `a T -ou bien sont de la forme Yi(t0i) o`u t0i 2 T
ffl chaque variable de CX appara^it au plus une fois dans s1; : : : ; sn; t1; : : : ; tn
ffl X1; : : : ; Xn 2 CX , U1; : : : ; Um 2 C et chaque variable de CX appara^it au plus une fois dans

chque Ui

ffl X1; : : : ; Xn n'apparaissent pas dans s1; : : : ; sn; t1; : : : ; tn,
ffl X1 = U1 ^ : : : ^ Xm = Um est en forme s'equentiellement r'esolue (comme d'efini par J.-P.

Jouannaud et C. Kirchner [46]).

Pour r'esoudre ces contraintes, j'ai besoin de r`egles de d'ecomposition des contraintes d'appartenance, qui, bien que longues et techniques `a expliquer, ne pr'esentent pas de difficult'e conceptuelle. Les d'ecompositions dans les cas rigide/rigide et flexible/rigide (suivant la terminologie
de G. Huet [42]) ne posent pas de probl`eme majeur. Le cas flexible/flexible, qui correspond en
fait (`a cause de la forme des probl`emes consid'er'es) `a une fusion d''equations x = X(s) ^ x = Y (t)
est plus difficile. En effet, d'une part il n'est pas possible d'utiliser des r`egles d''elimination de
variables sans perdre les propri'et'es des formules consid'er'ees, d'autre part il n'est pas possible
de contraindre les fusions par des conditions de taille comme on le fait habituellement (cf. [46]).
En effet, les arguments de tailles sont inadapt'es au cas de termes contenant des variables de
second ordre.

Exemple 10 Soit le probl`eme x = X(x) ^ x = Y (f (z)). La d'ecomposition de X(x) = Y (f (z))
doit donner, entre autres, les deux probl`emes 9Z:X = Y \Delta  Z ^ Z(x) = f (z) et 9Z:Y = X \Delta  Z ^ x =
Z(f (z)). Que l'on garde x = X(x) ou que l'on garde x = Y (f (z)) du probl`eme original, on
obtient apr`es 2 'etapes de transformations une sous-formule qui est un renommage du probl`eme
de d'epart.

Mais, dans l'exemple ci-dessus, on remarquera qu'il y a une 'equation cyclique x = X(x) qui
n'a de solution que si X ext l'identit'e4. En fait, c'est toujours le cas pour les probl`emes de nonterminaison: s'il n'y a pas terminaison c'est qu'il est possible de d'eduire une 'equation cyclique.
L'id'ee est alors de contraindre l'application d'une r`egle de fusion+ d'ecomposition (dans le cas
flexible/flexible) par l'absence de cycle d'eductible. La notion de d'eduction faisant ici appel `a
une extension de la cl^oture de congruence ('etudi'ee, entre autres, par G. Nelson & D. Oppen

4Notre langage ne permet pas les projections, ce qui constitue une (autre) diff'erence notoire avec l'unification
de second ordre.

31

[70]). Ceci permet de d'efinir un ordre d'occurrence g'en'eralis'e (voir [21]) qui, en contraignant les
r`egles de fusion, 'evite la non-terminaison.

Nous ne d'efinissons pas ici la notion de forme r'esolue. Elle s'inspire des d'efinitions donn'ees
dans les paragraphes pr'ec'edents et, de toutes fa,cons, v'erifie la propri'et'e fondamentale de
poss'eder au moins une solution.

Th'eor`eme 7 ([21]) Il existe un syst`eme de r`egles qui est correct et qui termine lorsqu'il est
appliqu'e `a une contrainte. De plus, les formules irr'eductibles pour ce syst`eme sont des formes
r'esolues.

32

8 Langages de Formes Normales
J'ai 'evoqu'e dans le paragraphe 5.5 les probl`emes de compl'etude suffisante et de r'eductibilit'e
inductive. Cette derni`ere s'est r'ev'el'ee ^etre une propri'et'e cl'e pour plusieurs applications dont
l'automatisation des preuves par induction, comme l'ont montr'e J.-P. Jouannaud et E. Kounalis
[48]. Bien que montr'ee d'ecidable dans le cas g'en'eral par D. Plaisted d`es 1985 [73], la r'eductibilit'e
inductive a fait l'objet de nombreux travaux ult'erieurs. En particulier, j'ai essay'e de mieux comprendre ce probl`eme, de trouver de nouveaux algorithmes de d'ecision, si possible plus efficaces.
Ce travail est l'objet de la partie principale de ma th`ese d'universit'e [12] et j'essaye maintenant
de reprendre ces r'esultats en les 'etendant et en les am'eliorant (en particulier du point de vue
de la complexit'e). J'ai ainsi commenc'e la r'edaction d'une s'erie de trois articles dont seulement
le premier est termin'e [20].

Le point de d'epart de mes travaux a consist'e `a essayer d'exprimer les probl`emes de r'eductibilit'e inductive dans un formalisme de th'eorie des langages. En effet, la r'eductibilit'e
inductive de t, c'est l'inclusion du langage [[t]] de toutes les instances closes de t dans le langage
L de tous les termes clos dont un sous-terme est une instance d'un membre gauche de r`egle de
r'e'ecriture. Cette simple constatation permet de tra^iter de fa,con standard le cas o`u t comme
les membres gauches de r`egles sont des termes lin'eaires, puisqu'alors (comme J. Gallier et R.
Book l'avaient d'ej`a remarqu'e [35]) les langages correspondants sont des langages reconnaissables
d'arbres. Malheureusement, le cas g'en'eral est plus complexe. Si les membres gauches de r`egles ne
sont pas lin'eaires, le langage des termes clos r'eductible est un langage d'arbres non alg'ebrique en
g'en'eral. En fait, il est engendr'e par une grammaire d'arbres alg'ebrique utilisant une strat'egie IO
(les d'efinitions de strat'egies de d'erivation dans les grammaires alg'ebriques d'arbres sont donn'ees
par J. Engelfriet et E. Schmidt [34]).

En fait, le probl`eme de r'eductibilit'e inductive s'exprime plus commod'ement comme un
probl`eme de d'ecision du vide: [[t]] " N F est il vide? si N F est l'ensemble des termes clos
irr'eductibles. J'appelle langage de formes normales un tel ensemble de termes clos. Bien que je
ne l'aie pas prouv'e, le langage de formes normales [[t]] " N F semble ne pas ^etre alg'ebrique (OI),
la g'en'eration par une grammaire IO est quant `a elle un probl`eme ouvert. Mais, dans tous les
cas, il n'y a pas d'algorithme connu de d'ecision du vide.

Ma contribution a consist'e `a donner une technique (utilisant la r'esolution de probl`emes
de compl'ements) qui permet de calculer des grammaires conditionnelles engendrant le langage
N F " [[t]]. Ces grammaires doivent ^etre rapproch'ees des automates avec tests d''egalit'es et de
dis'egalit'es entre fr`eres de B. Bogaert et S. Tison [3, 4]. Mais ces derniers ne sont pas assez
g'en'eraux pour toujours reconna^itre N F . En fait la classe REC= de langages reconnus par
ces automates poss`ede des propri'et'es de stabilit'e tr`es fortes que n'ont pas n'ecessairement les
langages de formes normales.

La deuxi`eme partie de ma contribution consiste `a montrer qu'il est possible de d'ecider si une
grammaire conditionnelle engendr'ee par l'algorithme pr'ec'edent engendre ou non un langage vide.
Sur ce point, et bien que la d'ecidabilit'e soit acquise, mon algorithme n'est toujours pas satisfaisant car sa complexit'e (une tour d'exponentielles) doit pouvoir ^etre r'eduite consid'erablement.
En fait, rien ne prouve qu'il est impossible d'obtenir un algorithme de d'ecision polyn^omial car,
si la r'eductibilit'e inductive elle-m^eme est un probl`eme exponentiel (voir par exemple l`article de
D. Kapur, P. Narendran, D. Rosenkrantz et H. Zhang [51]), la partie complexe peut tr`es bien se
trouver dans le calcul de la grammaire elle-m^eme. Un tel r'esultat (que je conjecture vrai) serait
int'eressant car il prouverait qu'on peut "factoriser" les calculs complexes dans un calcul effectu'e
une fois pour toutes (celui de la grammaire de N F ), l'algorithme de d'ecision pour chaque terme
t de la r'eductibilit'e inductive de t 'etant quant `a lui polyn^omial.

La troisi`eme partie de ma contribution consiste `a transformer les sp'ecifications. L'id'ee

33

est la m^eme que ci-dessus: factoriser les parties complexes. On peut calculer, `a partir d'une
sp'ecification (avec sortes-ordonn'ees) une sp'ecification 'equivalente (en un sens pr'ecis'e dans [13])
pour laquelle il n'y a que des symboles constructeurs ou des symboles d'efinis, comme dans le
cas consid'er'e par G. Huet et J.-M. Hullot [44]. Cette transformation n'est possible que si la
sp'ecification d'origine est pr'esent'ee par un syst`eme de r'e'ecriture convergent et que le langage
des termes clos irr'eductibles est reconnaissable. Mais, dans le cas o`u elle est possible, elle
permet d'obtenir des sp'ecifications bien plus simples pour lesquelles, entre autres, les tests de
r'eductibilit'e inductive sont triviaux.

Il reste n'eanmoins plusieurs points obscurs. D'une part, comme je l'ai dit, mon algorithme de
d'ecision (en fait, c'est un algorithme de nettoyage de la grammaire) n'est pas encore satisfaisant.
D'autre part, on ne sait pas si la reconnaissabilit'e de N F est d'ecidable: c'est l'un des probl`emes
ouverts 'enonc'es dans les actes de RTA 91 [31]. Or la reconnaissabilit'e de N F est, par exemple,
utilis'ee dans la transformation de sp'ecifications pr'esent'ee ci-dessus. Enfin, l''etude syst'ematique
des langages de formes normales du point de vue de la th'eorie des langages reste `a faire: quelles
sont les propri'et'es de stabilit'e? de d'ecision? Comment se compare pr'ecis'ement cette classe de
langages avec les classes connues ? etc ... Ces recherches ont pour l'instant 'et'e repouss'ees car
elles se situent un peu en dehors de la direction principale de mes recherches: les contraintes
dans les alg`ebres d'arbres. C'est pourquoi je n'en parle pas dans le paragraphe suivant, mais ces
sujets font toujours partie de mes pr'eoccupations.

34

9 Recherches Futures
Mon projet (ou plut^ot notre projet) au sein de l''equipe DEMONS est de d'evelopper tant du point
de vue th'eorique que du point de vue logiciel, des algorithmes de r'esolution de contraintes symboliques. D'autre part, nous nous int'eressons `a la d'emonstration avec des formules contraintes,
particuli`erement en logique 'equationnelle. Ces axes de recherche sont en effet relativement nouveaux et sont prometteurs car les probl`emes de contraintes et de preuves dans des logiques
contraintes sont li'ees `a la conception de langages de programmation logique contrainte. Plus
pr'ecis'ement, les travaux en cours ont pour objet

ffl la r'esolution de contraintes d'ordre (dans le cas d'un ordre r'ecursif sur les chemins 'etendant

une pr'es'eance partielle, par exemple)

ffl l''elimination de la n'egation des formules 'equationnelles
ffl la compl'etion avec des contraintes (autres que les contraintes d'appartenance)
ffl la r'ealisation (dont M. Haberstrau est le principal artisan) de l'environnement ECOLOG,

pour la conception de langages de programmation logique contrainte (dont une description
est donn'ee dans [24]).

Ces projets de recherche s'int`egrent aussi de fa,con naturelle dans le groupe de travail (ESPRIT III, BRA) Construction of Computational Logics auquel nous participons.

35

Remerciements
La liste des personnes `a remercier est trop longue pour ^etre donn'ee de fa,con exhaustive. Ceci
est donc un remerciement collectif `a tous ceux qui m'ont aid'e (et qui sauront se reconna^itre).

Cependant, je dois distinguer deux personnes qui ont jou'e et jouent encore un r^ole d'eterminant
dans la conduite de mes travaux. Il s'agit d'une part de Jean-Pierre Jouannaud dont le soutien,
les encouragements et surtout les discussions et conseils techniques et scientifiques constituent
la pierre d'angle de mes travaux de recherche. D'autre part, il s'agit de mon 'epouse Nathalie
dont la foi ind'efectible constitue un soutien moral souvent utile sinon indispensable.

36

Bibliographie

[1] L. Bachmair. Proof by consistency in equational theories. In Proc. 3rd IEEE Symp. Logic

in Computer Science, Edinburgh, July 1988.

[2] R. Barbuti, P. Mancarella, D. Pedreshi, and F. Turini. A transformation approach to

negation in logic programming. J. Logic Programming, 8:201-228, 1990.

[3] B. Bogaert and S. Tison. Automata with equality tests. Technical Report IT 207, Laboratoire d'Informatique Fondamentale de Lille, USTL, Lille, France, Feb. 1991.

[4] B. Bogaert and S. Tison. Equality and disequality constraints on brother terms in tree

automata. In A. Finkel, editor, Proc. 9th Symp. on Theoretical Aspects of Computer Science,
Paris, 1992. Springer-Verlag.

[5] H. J. B"urckert. Solving disequations in equational theories. In Proc. 9th Conf. on Automated

Deduction, Argonne, LNCS 310. Springer-Verlag, May 1988.

[6] R. Caferra and N. Zabel. A method for simultaneous search for refutations and models

using equational problems. To appear in Journal of Symbolic Computation, 1990.

[7] H. Chen and J. Hsiang. Logic programming with recurrence domains. In Proc. ICALP 91,

LNCS, Madrid, 1991.

[8] H. Chen, J. Hsiang, and H.-C. Kong. On finite representations of infinite sequences of

terms. In S. Kaplan and M. Okada, editors, Proc. CTRS 90, Montreal, 1990.

[9] A. Colmerauer. Prolog II. Manuel de r'ef'erence et mod`ele th'eorique. Research report, GIA

Luminy, Marseille, Mar. 1982.

[10] H. Comon. Sufficient completeness, term rewriting systems and anti-unification. In Proc.

8th Conf. on Automated Deduction, Oxford, LNCS 230, pages 128-140. Springer-Verlag,
July 1986.

[11] H. Comon. An effective method for handling initial algebras. In Proc. 1st Workshop on

Algebraic and Logic Programming, Gaussig, LNCS 343. Springer-Verlag, Nov. 1988.

[12] H. Comon. Unification et disunification: Th'eorie et applications. Th`ese de Doctorat,

Institut National Polytechnique de Grenoble, France, 1988.

[13] H. Comon. Inductive proofs by specifications transformation. In Proc. 3rd Rewriting Techniques and Applications 89, Chapel Hill, LNCS 355, pages 76-91. Springer-Verlag, Apr.
1989.

[14] H. Comon. Equational formulas in order-sorted algebras. In Proc. ICALP, Warwick. Springer-Verlag, July 1990.

[15] H. Comon. Solving inequations in term algebras. In Proc. 5th IEEE Symposium on Logic

in Computer Science, Philadelphia, June 1990.

[16] H. Comon. Solving symbolic ordering constraints. International Journal on Foundations

of Computer Science, 1(4), 1990.

[17] H. Comon. Complete axiomatizations of some quotient term algebras. In Proc. ICALP,

Madrid, LNCS 510, July 1991.

37

[18] H. Comon. Complete axiomatizations of some quotient term algebras. Research Report

650, LRI and CNRS, Univ. Paris-Sud, 1991. To appear in TCS.

[19] H. Comon. Disunification: a survey. In J.-L. Lassez and G. Plotkin, editors, Computational

Logic: Essays in Honor of Alan Robinson. MIT Press, 1991.

[20] H. Comon. Ground normal forms and inductive proofs. part I: complement problems.

Submitted to Journal of Symbolic Computation, 1991.

[21] H. Comon. Completion of rewrite systems with membership constraints. In W. Kuich,

editor, Proc. ICALP 92, Vienna, 1992. Springer-Verlag. An extended version is available
as LRI Research Report number 699, Sept. 1991.

[22] H. Comon and C. Delor. Equational formulas with membership constraints. Technical

report, Laboratoire de Recherche en informatique, Mar. 1991. To appear in Information
and Computation.

[23] H. Comon and M. Fernandez. Negation elimination in equational formulae. Research Report

716, Laboratoire de Recherche en Informatique, Univ. Paris-Sud, France, Dec. 1991.

[24] H. Comon, M. Haberstrau, and J.-P. Jouannaud. Ecolog : un environnement pour la

programmation en logique contrainte. draft, 1990.

[25] H. Comon, M. Haberstrau, and J.-P. Jouannaud. Decidable properties of shallow equational

theories. In Proc. 7th IEEE Symp. on Logic in Computer Science, Santa Cruz, 1992. Also
Research Report, Dec. 1991, Laboratoire de Recherche en Informatique, Orsay, France.

[26] H. Comon and P. Lescanne. Equational problems and disunification. J. Symbolic Computation, 7:371-425, 1989.

[27] H. Comon, D. Lugiez, and P. Schnoebelen. A rewrite-based type discipline for a subset of

computer algebra. J. Symbolic Computation, 11, 1991.

[28] M. Dauchet. Cours d'informatique th'eorique. Universit'e de Lille, 1984.
[29] N. Dershowitz. Termination of rewriting. J. Symbolic Computation, 3(1):69-115, Feb. 1987.
[30] N. Dershowitz and J.-P. Jouannaud. Rewrite systems. In J. van Leeuwen, editor, Handbook

of Theoretical Computer Science, volume B, pages 243-309. North-Holland, 1990.

[31] N. Dershowitz, J.-P. Jouannaud, and J. W. Klop. Open problems in rewriting. In Proceedings of the Fourth International Conference on Rewriting Techniques and Applications,
Como, Italy, April 1991. To appear in Lecture Notes in Computer Science, Springer, Berlin.

[32] M. Dincbas, P. V. Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. The

constraint logic programming language CHIP. In Proc. Int. Conf. on Fifth Generation
Computer Systems FGCS-88, pages 693-702, 1988.

[33] E. Domenjoud. AC unification through order-sorted AC1 unification. In Proc. 4th Rewriting

Techniques and Applications 91, Como, LNCS 488, 1991.

[34] J. Engelfriet and E. Schmidt. IO and OI. J. Comput. Syst. Sci., 15, 1977.
[35] J. H. Gallier and R. V. Book. Reductions in tree replacement systems. Theoretical Comput.

Sci., 37:123-150, 1985.

38

[36] M. G'ecseg and M. Steinby. Tree Automata. Akademia Kiad'o, Budapest, 1984.
[37] J. Goguen and J. Meseguer. Order-sorted algebra I: Partial and overloaded operators, errors

and inheritance. Draft, Computer Science Lab., SRI International, 1987.

[38] W. D. Goldfarb. Note on the undecidability of the second-order unification problem. In

Theoretical Computer Science, pages 225-230, 1981.

[39] J. V. Guttag and J. J. Horning. The algebraic specification of abstract data types. Acta

Inf., 10:27-52, 1978.

[40] J. Herbrand. Recherches sur la th'eorie de la d'emonstration. Th`ese d'Etat, Univ. Paris,

1930. Also in: Ecrits logiques de Jacques Herbrand, PUF, Paris, 1968.

[41] J. Hsiang and M. Rusinowitch. On word problems in equational theories. In Proc. 14th

ICALP, Karlsruhe, LNCS 267. Springer-Verlag, July 1987. Available as INRIA Research
Report 678.

[42] G. Huet. R'esolution d''equations dans les langages d'ordre 1; 2; : : : !. Th`ese d'Etat, Univ.

Paris 7, 1976.

[43] G. Huet. Confluent reductions: abstract properties and applications to term rewriting

systems. J. ACM, 27(4):797-821, Oct. 1980.

[44] G. Huet and J.-M. Hullot. Proofs by induction in equational theories with constructors.

J. Comput. Syst. Sci., 25(2), 1982.

[45] J.-M. Hullot. Canonical forms and unification. In Proc. 5th Conf. on Automated Deduction,

Les Arcs, LNCS 87. Springer-Verlag, July 1980.

[46] J.-P. Jouannaud and C. Kirchner. Solving equations in abstract algebras: A rule-based

survey of unification. In J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays
in Honor of Alan Robinson. MIT-Press, 1991.

[47] J.-P. Jouannaud and E. Kounalis. Automatic proofs by induction in equational theories

without constructors. In Proc. 1st IEEE Symp. Logic in Computer Science, Cambridge,
Mass., June 1986.

[48] J.-P. Jouannaud and E. Kounalis. Automatic proofs by induction in theories without

constructors. Information and Computation, 82(1), July 1989.

[49] J.-P. Jouannaud and C. March'e. Completion modulo associativity, commutativity and

identity. In A. Miola, editor, Proc. DISCO'90. LNCS 429, pages 111-120, Capri, Italy,
Apr. 1990. Springer-Verlag. To appear in TCS.

[50] J.-P. Jouannaud and M. Okada. Satisfiability of systems of ordinal notations with the

subterm property is decidable. In Proc. ICALP 91, LNCS, Madrid, 1991.

[51] D. Kapur, P. Narendran, D. Rosenkrantz, and H. Zhang. Sufficient completeness, ground

reducibility and their complexity. Acta Inf., 28:311-350, 1991.

[52] D. Kapur, P. Narendran, and H. Zhang. On sufficient completeness and related properties

of term rewriting systems. Acta Inf., 24(4):395-415, 1987.

[53] C. Kirchner. M'ethodes et Outils de Conception Syst'ematique d'Algorithmes d'Unification

dans les Th'eories equationnelles. Th`ese d'Etat, Univ. Nancy, France, 1985.

39

[54] C. Kirchner. Order-sorted equational unification. In Proc. 5th Int. Conference on Logic

Programming, Seattle, Aug. 1988.

[55] C. Kirchner and H. Kirchner. Computations in G-algebras. 5th Int. Workshop on Unification, July 1991.

[56] C. Kirchner, H. Kirchner, and J. Meseguer. Operational semantics of OBJ-3. In Proc. 15th

ICALP, Tampere, LNCS 317. Springer-Verlag, July 1988.

[57] C. Kirchner, H. Kirchner, and M. Rusinowitch. Deduction with symbolic constraints. Revue

Fran,caise d'Intelligence Artificielle, 4(3):9-52, 1990. Special issue on automatic deduction.

[58] C. Kirchner and F. Klay. Syntactic theories and unification. In Proc. 5th IEEE Symp. Logic

in Computer Science, Philadelphia, June 1990.

[59] D. E. Knuth and P. B. Bendix. Simple word problems in universal algebras. In J. Leech,

editor, Computational Problems in Abstract Algebra, pages 263-297. Pergamon Press, 1970.

[60] E. Kounalis, D. Lugiez, and L. Pottier. Complement problems modulo associativity and

commutativity. In Proc. 16th Mathematical Foundations of Computer Science 91, Warsaw.
Springer-Verlag, 1991.

[61] K. Kunen. Answer sets and negation as failure. In Proc. 4th. Int. Conf. on Logic Programming, Melbourne, pages 219-228, 1987.

[62] K. Kunen. Negation in logic programming. J. Logic Programming, 4:289-308, 1987.
[63] J.-L. Lassez, M. J. Maher, and K. G. Marriot. Unification revisited. In Proc. Workshop

on Found. of Logic and Functional Programming, Trento, LNCS 306. Springer-Verlag, Dec.
1986.

[64] J.-L. Lassez and K. G. Marriott. Explicit representation of terms defined by counter examples. J. Automated Reasoning, 3(3):1-17, Sept. 1987.

[65] D. Lugiez. A deduction procedure for first order programs. In G. Levi and M. Martelli,

editors, Proc. Int. Conf. on Logic Programming, Lisbon, 1989. MIT Press.

[66] M. J. Maher. Complete axiomatizations of the algebras of finite, rational and infinite trees.

In Proc. 3rd IEEE Symp. Logic in Computer Science, Edinburgh, pages 348-357, July 1988.

[67] A. Mal'cev. On the elementary theories of locally free algebras. Soviet Math. Doklady, 1961.
[68] A. I. Mal'cev. Axiomatizable classes of locally free algebras of various types. In The

Metamathematics of Algebraic Systems. Collected Papers. 1936-1967, pages 262-289. NorthHolland, 1971.

[69] J. Meseguer, J. Goguen, and G. Smolka. Order-sorted unification. J. Symbolic Computation,

8(4):333-414, 1989.

[70] G. Nelson and D. C. Oppen. Fast decision procedures based on congruence closure. J. ACM,

27:356-364, 1980.

[71] R. Nieuwenhuis and A. Rubio. Basic superposition is complete. In Proc. ESOP 92, 1992.
[72] W. Nutt, P. R'ety, and G. Smolka. Basic narrowing revisited. J. Symbolic Computation,

7(3/4):295-318, 1989.

40

[73] D. Plaisted. Semantic confluence tests and completion methods. Information and Control,

65:182-215, 1985.

[74] M. Rabin. Decidable theories. In J. Barwise, editor, Handbook of Mathematical Logic, pages

595-629. North-Holland, 1977.

[75] J. A. Robinson. A machine-oriented logic based on the resolution principle. J. ACM,

12(1):23-41, 1965.

[76] M. Schmidt-Schauss. Unification in many-sorted equational theory. In Proc. 8th Conf. on

Automated Deduction, Oxford, LNCS 230, pages 538-552. Springer-Verlag, July 1986.

[77] M. Schmidt-Schauss. Computational Aspects of an Order-Sorted Logic with Term Declarations. PhD thesis, Univ. Kaiserslautern, Apr. 1988.

[78] G. Smolka. Logic programming over polymorphically order-sorted types. PhD thesis, Univ.

Kaiserslautern, May 1989.

[79] G. Smolka, W. Nutt, J. A. Goguen, and J. Meseguer. Order-Sorted Equational Computation. In H. A"it-Kaci and M. Nivat, editors, Resolution of Equations in Algebraic Structures,
Volume 2, Rewriting Techniques, chapter 10, pages 297-367. Academic Press, New York,
N.Y., 1989.

[80] P. Stuckey. Constructive negation for constraint logic programming. In Proc. 6th IEEE

Symp. Logic in Computer Science, Amsterdam, 1991.

[81] R. Treinen. A new method for undecidability proofs of first order theories. Tech. Report

A-09/90, Universit"at des Saarladandes, Saarbr"ucken, May 1990.

[82] R. Treinen. A new method for undecidability proofs of first order theories. In K. V.

Nori and C. E. V. Madhavan, editors, Proceedings of the Tenth Conference on Foundations
of Software Technology and Theoretical Computer Science, pages 48-62. Springer Lecture
Notes in Computer Science, vol. 472, 1990.

[83] S. Tulipani. Decidability of the existential theory of infinite terms with subterm relation.

To appear in Information and Computation, 1991.

[84] K. N. Venkataraman. Decidability of the purely existential fragment of the theory of term

algebras. J. ACM, 34(2):492-510, 1987.

[85] C. Walther. A mecanical solution of Schubert's streamroller by many-sorted resolution.

Artificial Intelligence, 26(2):217-224, 1985.

41