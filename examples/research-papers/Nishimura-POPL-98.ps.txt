

Static Typing for Dynamic Messages

Susumu Nishimura
RIMS, Kyoto University
Sakyo-ku, Kyoto 606-01, JAPAN
nisimura@kurims.kyoto-u.ac.jp

Abstract
Dynamic messages are first-class messages dynamically bound toprogram variables. By dynamic messages, the methods to be
invoked can be varied dynamically at run-time, which providesa powerful abstraction mechanism for object-oriented languages.
Dynamic messages are critically needed for some programs, but itseems that there has been no proposal of static type systems for
dynamic messages. This paper presents a static typing disciplinefor dynamic messages and formalizes it into a second order polymorphic type system. The type system satisfies the type soundnessproperty and has a principal type inference algorithm. The type
system therefore provides a foundation for a statically typed object-oriented language enriched with polymorphic dynamic messages.

1 Introduction
In object-oriented languages, method is invoked by passing a mes-sage to an object. If messages are treated as first-class values
and they are bound to program variables, the method invoked bythe messages can be varied dynamically. In this paper, we call
first-class messages as dynamic messages to emphasize their dy-namic nature. Most of object-oriented languages do not allow dynamic messages, but only a few languages support them. Smalltalk[GR89] and Objective-C [PW91], for example, provide a special
method `perform:' for the purpose of passing dynamic mes-sages to objects. Though dynamic messages are not so frequently
used even in these languages, there are some significant programswhose use of dynamic messages is critical and cannot be easily replaced by statically specified messages.One example of the critical use of dynamic messages is
delegate objects. We can simply define a delegate object as anobject that redirects all the passed messages to another object by
using dynamic messages as follows

f redirect(m) = om g
where f redirect(m) = ... g defines a delegate object consisting ofa single method named redirect. The redirect method receives

a dynamic message bound to the argument variable m and passesthe message to an object o (the message passing is expressed
by om), where o refers to the object to which messages are
To appear in the 25th Annual ACM SIGPLAN-SIGACT Sym-posium on Principles of Programming Languages, January

1998, San Diego, California.
Copyright cfl1998 by the Association for Computing Machin-ery.

redirected. The delegation cannot be easily expressed withoutthe dynamic message bound to m representing any message to be
transmitted to the object o.Dynamic messages also bring a powerful abstraction mechanism into object-oriented languages: a dynamic message bound toa program variable abstracts the method actually invoked by the
message passed to an object, which is analogous to the abstractionmechanism of higher-order functions in functional languages. By
means of this abstraction mechanism, we can describe a variety ofmethods that implement useful features similar to those provided
by higher-order functions, in the framework of an object-orientedlanguage. For example, a method map for passing a list of
messages to an object, which is an object-oriented analogue of thehigher-order map function, would be implemented as follows

method map(msglst) =case msglst of

[] ) []
j head::tail ) (selfhead)::(selfmap(tail))end

where [] stands for an empty list, head::tail is a list constructorwhich adds a new element head to the head of a list tail, and the
identifier self refers to the object itself executing the method. Thismap method would be useful for programming some applications.
In graphical application programs, for example, we can invokea sequence of methods for window manipulation and picture
drawing by a single message passing as follows

wmap([raise(), clear(), box(0,0,10,10), line(0,30,20,5)])
where w refers to a window object and the four methods raise,clear, box, and line are invoked one after another.

In addition to the ability of defining a variety of flexible meth-ods, the abstraction mechanism provided by dynamic messages
can contribute to the efficiency of distributed object-oriented com-puting, where objects are modeled as network objects [BNOW93]
accepting network-transparent method invocations. In distributedcomputation, network latency is a major bottleneck and it is crucial
for efficient computation to reduce network load by exploiting lo-cality. We observe that dynamic messages can exploit locality by
abstracting remote computation.To see how locality is exploited by dynamic messages, we consider the execution of a Unix standard command find in a net-worked environment, where a file system is maintained by a network file server and the find command is executed on a remoteclient. The execution of a

find command on a remote clientwould consist of recursive traversal of the directory tree, conditional checking for each file, and an operation on the searched files,

1

each of which requires a communication between the server andthe client. The execution therefore produces a heavy network load
between the server and the remote client, which causes poor perfor-mance consequently. The network load can be reduced, however, if
the locality of the file system is exploited, i.e., if the server executesthe

find command in behalf of the remote client.This locality exploitation can be naturally expressed by means

of dynamic messages. We can implement the network file serveras a network object that provides network-transparent file access
services including the service for executing the find commandin behalf of remote clients. Remote clients are allowed to utilize
the service by sending a find message of the following form to theserver object

find(dir, cond, fop)
where dir is a directory object which is the top node of a directoryhierarchy to be searched, and cond and fop are messages abstracting the method for conditional checking on the files and themethod for file operation on the searched files, respectively. For
example, to list all the names of such files that contain the string"ACM", we send the following message to the server object

find(dir,grep(``ACM''),fname())
where dir is the top directory to be searched, grep and fname arebuilt-in methods for file object to check if the specified string is

contained and to return the file name string, respectively.The find method can be defined with dynamic messages in
a simple way. First, the find method for the file server object isdefined as

method FileServer.find(dir,cond,fop) =dir

 find(cond,fop)

where the find message is simply redirected to the directory objectdir. The redirected find message is recursively passed to all

descendant objects (files and directories) in the directory hierarchy.If a directory object receives a find, the received find message is
redirected to all immediate descendant files and directories. Weassume that every directory object has a method named mapdir
that passes a given message to all immediate descendant objects:if a message mapdir(msg) is passed to a directory object, then
the directory object redirects the message msg to all objects (filesand directories) registered in the directory record. The mapdir
can be defined similarly to the map method defined above. Thefind method for a directory object is defined by using the mapdir
method as follows.

method Dir.find(cond,fop) =self

 mapdir(find(cond,fop))

If the find message reaches a file object, the search condition isfirst checked, and then the method for file operation is invoked if

the condition is satisfied. The conditional checking and the methodinvocation for file operation is done by passing the messages
contained in the find message to the file object itself, as show inthe following program

method File.find(cond,fop) =if (self

cond) then [selffop] else []

where [e] stands for a singleton list whose only element is e. Themethod returns either a singleton list or an empty list depending on

the result of conditional checking. The lists of results are collectedand concatenated into a single list by the mapdir method.

In spite of their advantages, dynamic messages are not frequently used in object-oriented programming. It seems that onemajor reason for this infrequent use of dynamic messages is that
there is no static typing discipline for dynamic messages. Thereare a few typed object-oriented languages supporting dynamic messages, but the type safety is not guaranteed by their type sys-tems. Objective-C [PW91], for example, is a strongly typed objectoriented language that allows dynamically bound method invoca-tions in a way similar to those of Smalltalk. In Objective-C, however, every dynamic message is given a single type called selectortype, and therefore the object receiving a dynamic message may
not implement the corresponding method, in which case a run-timeerror is signaled.

The aim of this paper is to develop a static typing disciplinefor dynamic messages to incorporate them into the framework of a
typed object-oriented language. A static type system for dynamicmessages would bring the fruitful benefit of statically typed languages into an object-oriented language enriched with the powerfuldynamic method invocation mechanism. Static typing is an effective method to develop programs in a semantically verified way,where type inconsistency can be detected earlier by static type inference in advance of execution. Static typing for dynamic mes-sages therefore would be useful for finding a message that attempts
to invoke a method not implemented in an object, for detecting typemismatch of the arguments and the result of message passing, etc.
To the author's knowledge, there seems to be no static type sys-tem that combines an objected-oriented language with the dynamic
method invocation mechanism in a type safe manner. Several re-searchers have been elaborating foundational models for statically
typed object-oriented languages [Car88, CCH+89, OB89, Mit90,R'em94, PT94, HP95, AC96, BSvG95, BPF97], but the dynamic
method invocation mechanism is not incorporated into the pro-posed models.

In an object-oriented language embedded in *-calculus, a dy-namic message can be encoded by enclosing it in a function closure: a dynamic message msg(a) is encodable as a function f =
*x:x  msg(a) and passing the dynamic message to an object ocan be encoded as a function application

fo. However, this encod-ing depends on the general abstraction mechanism of higher-order

functions. It seems that the encoding adds an irrelevant indirectionthat every message is wrapped in a function closure. The concern
of this paper is not in such a variant of *-calculus enriched withobject-oriented features, but in a language comprising of purely
object-oriented components: objects, messages, and message pass-ing. Such a pure object-oriented language can be a new calculus
having enough power to encode some useful features: variants arejust messages, pairs and records are encoded as objects, conditional
expressions are special form of object definition, and *-abstraction
*x:M is encoded by an object farg(x) = Mg and application ofthe function to an argument

N by farg(x) = Mg  arg(N). Fur-thermore, the pure object-oriented calculus suggests a calculus of

objects and messages which interact with each other as the duals ofone another, which seems to exhibit an elegance of object-oriented
programming paradigm. A similar duality is formally presented inBarbanera and Berardi's symmetric lambda calculus [BB96] as the
duality of pairs and sums. This duality is also generally known asthat of records and labeled variants. For example, a labeled variant
of type h`1(o/1); : : : ; `n(o/n)i is encoded by records as a functionof type

8t:fj`1 : o/1 ! t; : : : ; `n : o/n ! tgj ! t, following the typenotation in Ohori's polymorphic record calculus [Oho95]. However, the type of the encoded variant indicates that application ofthe variant to a record forces the resulting types to be the same
type t. This typing restriction is critical for object-oriented pro-gramming languages, since an object generally consists of methods yielding differently typed results. A type system for an object-oriented language should allow the same message to be used to in2

voke identically named methods yielding results of different types,but it seems that there is no such type system for object-oriented
languages. In Aiken, Wimmers, and Lakshman's soft typing sys-tem [AWL94], conditional types allow a single case expression to
yield differently typed results. However, their type system cannotbe static, since their type system depends on the dynamic nature of
programs, i.e., the control-flow.In the rest of the section, we will show the difficulties in typing
dynamic messages by some examples, and explain a general ideato overcome the difficulties. Consider the following simple but
illustrative example.

method foo(o,m) = om
The method foo is such a method that receives an object o anda message m as arguments and sends the message to the object.

There is no static information about the name of the methodinvoked by the message passing: o can be any object, m can be
any message, and therefore the method name to be invoked iscompletely unknown. Nevertheless, to preserve the type safety, the
type system must guarantee that the object has the correspondingmethod that will be invoked by the message. Furthermore, the
method foo cannot be typed in the usual way, since the resulttype of the method cannot be determined uniquely. Consider the
following two expressions

ofoo(fa(x)=x+1,b(x)=(x=0)g, a(3))
ofoo(fa(x)=x+1,b(x)=(x=0)g, b(1))
where we assume that o is some object that accepts the foo method.The first expression and the second expression should be typed as

int and bool, respectively. This indicates that the results of invo-cations of an identical method foo can have completely different
types depending on the types of the object and the message givenas arguments. The type system for dynamic messages therefore
must solve two problems: static typing without sufficient staticmethod name information and method typing dependent on the
argument types.We solve these problems based on the following observation:
Each dynamic message can be viewed as an abstraction of a setof method names that the dynamic message can invoke, and therefore each dynamic message should be statically typed by a set ofmethod names that may be invoked by the message. For example, if a dynamic message has no static information about methodnames invoked by the message, the dynamic message is typed by
an empty set of method names. If some static information abouta method name is supplied later, the newly supplied method name
can be included in the set of method names in a way that type con-sistency is preserved. Based on this observation, we develop our
type system as a second order polymorphic type system, where thetype information is expressed by kinding as is done in Ohori's type
system for record calculus [Oho95]. Our type system, however,gives a solution for the two problems in typing dynamic messages:
Every dynamic message can be typed by a set of method names,where only one method out of the set is invoked by the dynamic
message, and the method typing depending on the argument typesis achieved as a process of resolving type inconsistency. In the following sections of the paper, we will describe in detail how the typesystem solves the two problems and then give a formal definition
of the type system.The rest of the paper is organized as follows. Section 2 informally shows our typing strategy for dynamic messages. Section 3presents a formal definition of an object-oriented language enriched
with dynamic messages and gives its operational semantics andtyping rules. In the section, we also show the type soundness and

give a principal type inference algorithm. In Section 4, we givesome examples of typing derivations and show how classes can be
defined by means of recursive object definition. Finally, Section 5concludes the paper and discusses future work.

We only sketched the proof of the type soundness theorem inAppendix. The proof of the other theorems is omitted from the
present paper due to the page limitation. The author intends topublish the proof of those theorems elsewhere in a more detailed
form.

2 Typing Dynamic Messages
We formalize the general idea proposed in the previous section as asecond-order polymorphic type system. In the following, we conventionally write t :: k to express a type variable t kinded by a kind
k. Note that our type system has no type directly representing thetype structure of objects and messages. Instead, the type information is expressed through kindings of the form t :: k, where t is atype variable indexing the type information of an object or a message and k is a kind representing the type information. The typeinformation of objects and messages cannot be expressed by ordinary types, since the exact type structure of objects and messagescannot be known statically in the presence of dynamic messages.
Even statically specified objects and messages cannot determinetheir exact type structure, since another dynamic message may add
new type information. Furthermore, the type information must beshared among the types to preserve type consistency. This requires
the types of objects and messages to be indexed by distinguishedtype variables.

Based on the above observation, we represent each dynamicmessage by a kind enumerating method names that may be invoked
by the message with their corresponding arguments. A dynamicmessage is typed by a type variable kinded by a message kind,
s :: hh`1(o/1); : : : ; `n(o/n)ii, where `1; : : : ; `n are method namesand each

o/i is the argument type of the corresponding method.Each object is then represented by a kind enumerating dynamic

messages acceptable to the object with their corresponding resulttypes. An object is expressed by a type variable kinded by an object kind, t :: fjt1 ! o/1; : : : ; tn ! o/ngj, where t1; : : : ; tn are typesof dynamic messages accepted by the object and each

o/i is the re-sult type of the method invocation by the corresponding dynamic

message. The type variables t1; : : : ; tn therefore must be kindedby some message kinds. The object kind furthermore must respect a particular type consistency condition: identically namedmethods of an object must be invoked with the same argument
type and the same return type. This condition is rephrased as fol-lows: if

ti :: hh`(o/ ); : : :ii and tj :: hh`(o/ 0); : : :ii, then o/ = o/0 and
o/i = o/j. We call this condition the well-formedness condition forobject kinds.

To see how types can be inferred by the above typing strategy,we first consider the typing for the foo method given in the
previous section.

method foo(o,m) = om
We type this method in the following way. Let s be the type for thedynamic message m. Since no information about method names is

given for the dynamic message, s is kinded by a null message kind,i.e.,

s :: hhii. Then o is typed as an object that accepts the dynamicmessage m, i.e., the type of o is given as

t :: fjs :: hhii ! ugj wherethe type variable
u represents some result type not yet determined.The dynamic message kinded by a null message kind may seem

useless since the kinding indicates that the message cannot invokeany method. However, the kinding makes sense when some static
information about a method name is supplied later. Actually, the

3

type variable s plays a role similar to that of the raw variables inWand's type system [Wan87].

To see how we can consistently infer the result type of the foomethod which depends on the type of the argument, we revisit the
following example given in the previous section.

ofoo(fa(x)=x+1,b(x)=(x=0)g, a(3))
In this message passing, the argument variable m is bound tothe message a(3), whose method name is statically specified.

We therefore augment the null message kind with the new staticinformation, i.e.,

s :: hha(int)ii. Furthermore, since the programvariable o is also bound to an object

fa(x)=x+1,b(x)=(x=0)g, theobject kind should be augmented to express that the methods a

and b are implemented in the object. The object kind is thereforeexpanded to accept two more dynamic messages as follows

t :: fj s :: hha(int)ii ! u;

s1 :: hha(int)ii ! int; s2 :: hhb(int)ii ! boolgj;

where the new type variables s1 and s2 are types of dynamic mes-sages to invoke the methods a and b, respectively. However, this

object typing contains an apparent type inconsistency. The well-formedness condition is broken for the object kind: the kindings
s :: hha(int)ii and s1 :: hha(int)ii indicate that two differentlytyped dynamic messages can invoke an identical method a but the
results have different types (u and int). We resolve this type incon-sistency by unifying the two types

u and int. The unification yields
int as the expected result type of the above message passing. Thetyping procedure described above resolves the type dependency by

a simple unification process respecting the well-formedness con-dition. If b(1) is given instead as the second argument of the
foo method in the above example, then a similar inference processyields the expected type bool by unifying

u into bool.The typing strategy presented so far enables us to type dynamic

messages by augmenting type information with the static methodname information supplied during the type inference procedure.
However, the unlimited augmentation of type information breaksthe soundness of the type system. To see this, consider the
following example.

method bar(m) = fsucc(x)=x+1, pos(x)=(x?0)gm
The method bar receives a dynamic message through the argumentm and passes it to the object consisting of two methods succ and

pos. Following the above typing strategy, we initially type thedynamic message m by

s :: hhii and the object fsucc(x)=(x+1),pos(x)=(x
?0)g by

t :: fj s :: hhii ! u;

s1 :: hhsucc(int)ii ! int; s2 :: hhpos(int)ii ! boolgj:

This typing is valid as long as the method invoked by the dynamicmessage m is either succ or pos. However, if the method bar is

used with a statically named message different from both succ andpos, we obtain an improper typing. Suppose a message pred(7) is
given as the argument of the method bar. Then the message kindfor the dynamic message m is augmented to include the method
pred, i.e., s :: hhpred(int)ii. This typing should be illegal, sincethe object implements only the two methods succ and pos but the
kinding indicates that the object must have the method pred.We observe that such an improper typing is caused by the typing strategy that ignores the static information about method namesin objects. To keep trace those static information, we attach a set of
method names to every kind as a constraint. The constrained mes-sage kind and object kind are expressed as

hh`1(o/1); : : : ; `n(o/n)iiL

and fjs1 ! o/1; : : : ; sn ! o/ngjL, respectively, where L is some sub-set of method names. The set attached to a message kind indicates
the maximal set of method names that can be enumerated in themessage kind, i.e., any message kind

hh`1(o/1); : : : ; `n(o/n)iiL mustsatisfy
f`1; : : : ; `ng ` L; The set attached to an object kind indi-cates the maximal set of method names the corresponding object

can accept, i.e., for any object kind fjs1 ! o/1; : : : ; sn ! o/ngjL,each

si must be kinded by a message kind hh\Delta  \Delta  \Delta iiLi such that
Li ` L. According to this kinding strategy, we type the methodbar with the constrained kinds as follows: The method receives a

dynamic message of type s :: hhiifsucc;posg and passes it to theobject of type

t :: fj s :: hhiifsucc;posg ! u;

s1 :: hhsucc(int)iifsucc;posg ! int;
s2 :: hhpos(int)iifsucc;posg ! boolgjfsucc;posg:

Due to the attached constraint, we can obtain a sound type systemby rejecting any augmentation of type information that does not
obey the constraint attached to kinds. For example, the messagepred(7) cannot be used as a well-typed argument of the method
bar any more, since the inclusion of the method pred into the typeof the argument yields a type

s :: hhpred(int)iifsucc;posg, whichviolates the constraint.

We formalize the idea presented above into a second order poly-morphic type system in the following section. The resulting type
system supports an ML-style let polymorphism and recursive ob-jects, where the recursiveness of types is expressed by mutual reference between types and kinds. Though we have put the type consis-tency condition that disables the invocations of an identical method
with different types, the let polymorphism allows identical methodsto be used with different types. In this paper, we do not consider
subtyping which is often regarded as a formal model for classeswith inheritance. We will mention about the subtyping issue briefly
in Section 5.The general idea of our type system is based on Ohori's type
system for polymorphic record calculus [Oho95], where each ob-ject is kinded by a record kind associating distinct labels to corresponding types. However, our type system is far more powerfulthan Ohori's in the sense that it achieves polymorphic typing for dynamic messages, whose counterpart in the record calculus is first-class labels that are not considered in Ohori's type system. In addition to this, as mentioned in Section 1, our object-oriented languagecan be viewed as a calculus of the duals, i.e., objects and messages,
which is reflected in the type system as interaction between objectkinds and message kinds. In Ohori's type system, variant kinds are
considered, but they have no interaction with record kinds.The typing mechanism of our type system is also similar to
that of R'emy's type system for records and variants [R'em89]. Histype system allows type inclusion for record and variant fields by
attaching an attribute to each labeled field to tell if the field valuemust, may, or must not exist for the field. The kind restriction in
our type system tells essentially the same constraint expressed bythe attributes in R'emy's type system. However, first-class labels are
not considered in the R'emy's work either.

3 An Object-Oriented Language with Dynamic Messages
In this section, we use the following mathematical notations. Wedenote set difference by

A n B = fx j x 2 A and x 62 Bg.For every finite map
f and g, domain(f) denotes the domainof
f, f ffi g denotes functional composition, and f + g de-fines a finite map by overriding the definition of

f by g, i.e.,
domain(f + g) = domain(f) [ domain(g), (f + g)(x) = g(x)for every

x 2 domain(g), and (f + g)(x) = f(x) for every

4

M ::= c (constant)

j x (identifier)
j f`1(x1) = M1; : : : ; `n(xn) = Mng (object)
j `(M) (message)
j M  M (message passing)
j let x = M in M (let binding)
j letobj x = f`1(x1) = M1; : : : ; `n(xn) = Mng in M (recursive object)

Figure 1: Syntax of the Language

ae ` c + c CONST

x 2 domain(ae)

ae ` x + ae(x) VAR

ae ` M + v
ae ` `(M) + `(v) MESSAGE

ae ` f`1(x1) = M1; : : : ; `n(xn) = Mng + f`1( ; x1; M1; ae); : : : ; `n( ; xn; Mn; ae)g OBJECT

ae ` M + f`(x; y; M0; ae0); : : :g ae ` N + `(v0)
ae0 + fx 7! f`(x; y; M0; ae0); : : :g; y 7! v0g ` M0 + v

ae ` M  N + v MSGPASS

ae ` M + v0 ae + fx 7! v0g ` N + v

ae ` let x = M in N + v LET

ae + fx 7! f`1(x; x1; M1; ae); : : : ; `n(x; xn; Mn; ae)gg ` N + v

ae ` letobj x = f`1(x1) = M1; : : : ; `n(xn) = Mng in N + v LETOBJ

Figure 2: Operational Semantics
x 2 domain(f) n domain(g). We conventionally write a fi-nite map as a finite sequence, e.g.

fx1 : q1; : : : ; xn : qng. Fi-nally, we assume that
L denotes a denumerably infinite set of la-bels
f`; `0; \Delta  \Delta  \Delta g, and we use meta variables L; L0; : : : to range over
L and finite subsets of L.

3.1 The Language Syntax
The language presented here is a minimal object-oriented languagethat provides only essential features for discussing dynamic messages. The language is a common core of languages that havebeen investigated in the series of studies of object-oriented programming [GM94], providing the following features: object cre-ation, messages, method invocation, and polymorphic let binding. We give the language syntax in Figure 1. An object
f`1(x1) = M1; : : : ; `n(xn) = Mng is comprised of n(n * 0)methods uniquely distinguished by labels

`1; : : : ; `n, and eachmethod
`i receives an argument through xi and executes the body
Mi. A message is expressed as `(M), a value tagged by a label `.The expression for method invocation

M  N passes the message
N to the object M and executes the corresponding method of theobject.

N can be any expression, thus it can be a dynamic message.In addition to these, for the sake of recursive object definition, we

included a special construct letobj. The letobj construct binds anobject to an identifier and the identifier can be referred to the object itself in the object being defined; The identifier corresponds tothe self variable which is used in some object-oriented languages
to refer to the object being executed.Although the language is small, it has enough power to encode
some useful features: variants, pairs, records, conditional expres-sions, and

*-abstractions, as mentioned in Section 1. We can evenencode class definitions by means of recursive object definitions,

which will be discussed in Section 4.
3.2 Operational Semantics
We give an operational semantics of our language in the style ofnatural semantics [Gun92]. We first define semantic values, which

are ranged over by meta-variable v, by the following grammar.

v ::= c (constant)

j `(v) (message)
j f`1(x1; y1; M1; ae1); : : : ; `n(xn; yn; Mn; aen)g (object)

The meta-variable c ranges over the set of constant values such asintegers. A message is a value tagged with a label, where the tag

is the method name and the value is the argument. An object is asequence of method closures of the form

`i(xi; yi; Mi; aei), where
`i is the method name, xi is an identifier referring to the recorditself (like a self variable),

yi the argument of the method, Mi themethod body, and
aei the run-time environment when the methodwas created. A run-time environment

ae is a finite map that assignsidentifiers to values, written as
fx1 7! v1; : : : ; xn 7! vng.The operational semantics is given in Figure 2 by a set of rules

that derive a formula of the form ae ` M + r, which indicates thatthe expression

M evaluates to the result r under the run-time envi-ronment
ae, where r is a value or a special symbol error standing fora run-time error. Note that the complementary rules that yields error are omitted from the figure, whereas they are given as implicitrules: if either one of the subderivations yields error or none of the
rules given in the figure cannot be applied to derive a formula, thenthe evaluation derivation yields error. Furthermore, if a method
closure has the form `( ; y; M; ae), stands for a special anonymousidentifier which is never bound in a run-time environment. That is,

5

writing ae + f 7! vg is equivalent to writing ae. The closure ofmethod defined in a non-recursive object has the anonymous identifier as its first component, since any non-recursive object does nothave the reference to the object itself.

3.3 Type System
We present a polymorphic type system for our language. We firstdefine types and kinds of our type system.

3.3.1 Types and Kinds
Types, ranged over by o/; o/ 0; : : :, are defined by the following gram-mar

o/ ::= b j t
where b stands for basic types, and t for type variables. As dis-cussed in Section 2, we have no type directly representing objects

and messages. The type of an object or a message is expressed by atype variable indexing a kind representing the corresponding type
information, and the type information is shared through the typevariables. For example, an object and dynamic messages accepted
by the object share the type information so that the types of the dy-namic messages respect the type consistency constraint induced by
the well-formedness condition, which will be formally defined inthe following.

Kinds, ranged over by k; k0; : : :, have distinguished threeforms, as defined in the following grammar.

k ::= U (universal kind)

j hh`1(o/1); : : : ; `n(o/n)iiL (message kind)
j fjt1 ! o/1; : : : ; tn ! o/ngjL (object kind)

U is universal kind, the kind for any type. A message kind
hh`1(o/1); : : : ; `n(o/n)iiL is a possibly empty sequence of typestagged with labels, subscripted by a set of labels

L. The order ofthe sequence is insignificant. The message kind represents such a

dynamic message that may invoke some method named `i with anargument of type

o/i. The subscripted L designates the upper boundof the set of labels enumerated in the sequence. An object kind

fjt1 ! o/1; : : : ; tn ! o/ngjL is a possibly empty sequence of pairs ofa type variable and a type of the form

t ! o/ , where t is the typeof a dynamic message, thus
t must be kinded by a message kind.The order of the sequence is insignificant. The object kind represents such an object that accepts n dynamic messages, whose typesare given by

t1; : : : ; tn, returning the results of types o/1; : : : ; o/n,respectively. The subscripted set of labels

L designates the upperbound of the set of method names that can be accepted by the object. To give consistent typing for objects, we impose a particularcondition on object kinds: identically named methods of an object
must be invoked with the same argument type and the same returntype. This type consistency for object kind is formally described in
the following part of this section as the well-formedness condition.In the rest of the paper, for every message kind

k =
hh`1(o/1); : : : ; `n(o/n)iiL, we denote the set of labels f`1; : : : ; `ngby

Labels(k), and L by Labub(k). The set of free type variablesoccurring in a type

o/ is denoted by FTV (o/), and the set of freetype variables in a kind

k by KFTV (k).

3.3.2 Kinding Rules and Kinded Substitution
Kinds are given to types relative to a kind assignment. A kind as-signment

K is a finite map from type variables to kinds, written as
ft1 :: k1; : : : ; tn :: kng. We extend the definition of KFTV tokind assignments by

KFTV (K) = St2domain(K) KFTV (K(t)).

In our type system, kinds are given only for well-formed typesunder a well-formed kind assignment. We say a type

o/ is well-formed under a kind assignment
K if FTV (o/) ` domain(K).A kind assignment
K is well-formed if K(t) is a well-formed kindfor every
t 2 domain(K), where the well-formedness of a kind kunder a kind assignment

K is defined by the following conditions.

ffl KFTV (k) ` domain(K).
ffl If k = hh`1(o/1); : : : ; `n(o/n)iiL then

- `1; `2; : : : ; `n are distinct labels,
- o/1; : : : ; o/n are well-formed under K, and
- f`1; `2; \Delta  \Delta  \Delta  ; `ng ` L.

ffl If k = fjt1 ! o/1; : : : ; tm ! o/mgjL then

- t1; : : : ; tn are distinct type variables,
- o/1; : : : ; o/n are well-formed under K,
- every K(ti) is a message kind such that

Labub(K(ti)) ` L, and

- K(ti) = hh`(o/); \Delta  \Delta  \Delta iiLi and K(tj) = hh`(o/0); \Delta  \Delta  \Delta iiLj

implies o/ = o/ 0 and o/ 0i = o/0j.

In the rest of the paper, we assume that every kind assignment iswell-formed.

We say a type o/ has a kind k under K, if K ` o/ :: k is derivedby applying one of the following rules.

ffl K ` o/ :: U for every well-formed type o/.
ffl K ` t :: hh`1(o/1); : : : ; `n(o/n)iiL if K(t) is a well-formedmessage kind

hh`1(o/1); : : : ; `n(o/n); \Delta  \Delta  \Delta iiL0 such that L0 ` L.

ffl K ` t :: fjt1 ! o/1; : : : ; tn ! o/ngjL if K(t) is a well-formedobject kind

fjt1 ! o/1; : : : ; tn ! o/n; \Delta  \Delta  \Delta gjL0 such that L0 ` L.

A type substitution, or simply substitution, is a finite map fromtype variables to types, written as

[t1no/1; : : : ; tnno/n]. An emptysubstitution is in particular written as

[ ]. Substitution for a type
o/ by a type substitution `, written `(o/ ), is obtained by simulta-neously replacing every type variable

t in o/ by `(t). Substitutionfor a kind
k is similarly defined except for the case k is an objectkind. If
k is an object kind, a simultaneous replacement may yieldan object kind

fjt1 ! o/1; : : : ; tn ! o/ngjL which contains repeatedoccurrences of identical type descriptions

t ! o/. If there are suchrepeated occurrences, they are suppressed to a single occurrence.

In our type system, only substitutions that conform to a kindassignment are allowed. A kinded substitution is a pair

(K; `) of akind assignment
K and a substitution `. We say a kinded substitu-tion
(K; `) respects a kind assignment K0, if K ` `(t) :: `(K0(t))for every

t 2 domain(K0).Kinded substitution preserves the kinding relation.

Proposition 3.1 Let K be a kind assignment, and (K0; `) be akinded substitution that respects

K. Then, for any o/ and any kind
k such that K ` o/ :: k, we have K0 ` `(o/ ) :: `(k).

3.3.3 Polytypes
Polymorphism is expressed in our type system by polytypes. Apolytype

oe has the form 8t1 :: k1; \Delta  \Delta  \Delta  ; tn :: kn:o/ , where n * 0 andthe order of quantification is insignificant. Note that not only the

type variables t1; : : : ; tn in o/ but also those in k1; : : : ; kn are quan-tified. The set of free type variables in a polytype is therefore defined by FTV (8t1 :: k1; \Delta  \Delta  \Delta  ; tn :: kn:o/ ) = (Sni=1 KFTV (kn) [

6

K; \Gamma  ` c : b CONST

x 2 domain(\Gamma  ) o/ _K \Gamma  (x)

K; \Gamma  ` x : o/ VAR

K; \Gamma  ` M : o/ K ` t :: hh`(o/ )iiL

K; \Gamma  ` `(M) : t MESSAGE

K; \Gamma  + fxi : o/ig ` Mi : o/ 0i (for each i = 1; \Delta  \Delta  \Delta  ; n)
K ` t :: fjt1 ! o/01; : : : ; tn ! o/0ngjf`

1;:::;`ngK ` t

i :: hh`i(o/i)iif`1;:::;`ng (for each i = 1; \Delta  \Delta  \Delta  ; n)

K; \Gamma  ` f`1(x1) = M1; : : : ; `n(xn) = Mng : t OBJECT

K; \Gamma  ` M : t K ` t :: fjs ! o/gjL K; \Gamma  ` N : s

K; \Gamma  ` M  N : o/ MSGPASS

K0; \Gamma  ` M : o/ 0 (K; oe) = Clos(K0; \Gamma  ; o/ 0) K; \Gamma  + fx : oeg ` N : o/

K; \Gamma  ` let x = M in N : o/ LET

K0; \Gamma  + fx : tg ` f`1(x1) = M1; : : : ; `n(xn) = Mng : t

(K; oe) = Clos(K0; \Gamma  ; t) K; \Gamma  + fx : oeg ` N : o/

K; \Gamma  ` letobj x = f`1(x1) = M1; : : : ; `n(xn) = Mng in N : o/ LETOBJ

Figure 3: Typing Rules
FTV (o/)) n ft1; : : : ; tng. We say a polytype oe is well-formed un-der

K, if FTV (oe) ` domain(K). Furthermore, we assume thebound variable convention on the quantified type variables by

ff-conversion. Under the bound variable convention, we define substitution for polytypes by `(8t1 :: k1; \Delta  \Delta  \Delta  ; tn :: kn:o/) = 8t1 ::
`(k1); \Delta  \Delta  \Delta  ; tn :: `(kn):`(o/ ).We define the notion of generic instance of polytypes. Let

oe =
8t1 :: k1; : : : ; tn :: kn:o/ and oe0 = 8s1 :: k01; : : : ; sm :: k0m:o/ 0,be two polytypes, where we assume that

t1; : : : ; tn; s1; : : : ; sm arefresh type variables by the bound variable convention. We say a

polytype oe is a generic instance of oe0 with respect to a kind as-signment

K, written oe _K oe0, if there exists a substitution ` suchthat
domain(`) = fs1; : : : ; smg, kinded substitution (K + ft1 ::
k1; : : : ; tn :: kng; `) respects K + fs1 :: k01; : : : ; sm :: k0mg, and
`(o/ 0) = o/.

3.3.4 Typing Rules
Types are given for expressions relative to a type assignment, whichis a finite map from identifiers to polytypes, written as

fx1 :
oe1; : : : ; xn : oeng. We extend the notion of free type variablesto type assignments by

FTV (\Gamma  ) = Sx2domain(\Gamma ) FTV (\Gamma  (x)).

The notion of type substitution is also extended to type as-signments, i.e., we write

`(\Gamma  ) for a type assignment such that
domain(`(\Gamma  )) = domain(\Gamma  ) and `(\Gamma  )(x) = `(\Gamma  (x)) for ev-ery

x 2 domain(\Gamma  ).To type let and letobj expressions, we need to take closure of a

type with respect to a type assignment. However, we must be care-ful taking type closure, since the type structure in our type system
is expressed by the kinds attached to the type variables by means ofthe kind assignment. Furthermore, we need to take it into account
that the types contained in an object kind may have dependencyon one another due to the well-formedness condition. To take a
proper set of free type variables, we introduce the notion of essen-tially free type variables that respects the type structure expressed
by the kind assignment and the type dependency induced by the

well-formedness condition, whose definition is similar to that ofOhori's type system [Oho95]. Given a kind assignment

K and apolytype
oe well-formed under K, the set of essentially free typevariables denoted by

EFTV (K; oe), is defined as the smallest setof type variables satisfying the following conditions.

ffl FTV (oe) ` EFTV (K; oe).
ffl If t 2 EFTV (K; oe), then KFTV (K(t)) ` EFTV (K; oe).
ffl If K(t) = fjs ! o/ 0; : : :gjL and s 2 EFTV (K; oe), then t 2

EFTV (K; oe).

The first two conditions say that the set of effectively free type vari-ables contains all the type variables that can be reached by traversing the type structure expressed by kinds. The last condition tellsthat a type variable kinded by an object kind must be contained in
the set of essentially free type variables to preserve the type de-pendency, if a type of a dynamic message accepted by the object
belongs to the set of essentially free type variables. The definitionof essentially free type variables is extended to type assignments
by EFTV (K; \Gamma  ) = St2domain(\Gamma ) EFTV (K; \Gamma  (t)).

A type closure of o/ under a kind assignment K and a typeassignment

\Gamma  , denoted by Clos(K; \Gamma  ; o/), is a pair (K0; oe) of akind assignment

K0 and a polytype oe = 8t1 :: K(t1); \Delta  \Delta  \Delta  ; tn ::
K(tn):o/ such that ft1; : : : ; tng = EFTV (K; o/ ) n EFTV (K; \Gamma  ),
domain(K) n ft1; : : : ; tng = domain(K0), and K0(t) = K(t) forall

t 2 domain(K0).Figure 3 shows the set of rules to derive a typing judgment

of the form K; \Gamma  ` M : o/, which asserts that an expression Mhas a type

o/ under a kind assignment K and a type assignment \Gamma  .The rule C

ONST gives a proper basic type for each constant. Therule V
AR gives an instance of the polytype assigned to the iden-tifier. The rule M

ESSAGE gives a type kinded by a message kind
hh`(o/)iiL for a message, where ` is the method name to be invokedand

o/ is the argument type. The subscripted set of labels L indicatesthat the typing rule does not care about the constraint on the upper

7

(i) (E [ f(o/; o/)g; K; `) =) (E; K; `)
(ii) (E [ f(t; o/)g; K [ f(t; U)g; `) =) ([tno/ ](E); [tno/ ](K); [tno/ ] ffi `)if

t 62 FTV (o/ ).

(iii) (E [ f(t; s)g; K [ f(t; hhF iiL); (s; hhF 0iiL0 )g; `)

=) ( [tns](E [ f(F (`); F 0(`)) j ` 2 Dom(F ) " Dom(F 0)g);

[tns](K [ f(s; hhF + F 0iiL"L0)g);
[tns] ffi `)
if Dom(F ) [ Dom(F 0) ` L " L0.

(iv) (E; K [ f(t; fjs ! o/; s ! o/ 0; : : :gjL)g; `) =) (E [ f(o/; o/ 0)g; K [ f(t; fjs ! o/; : : :gjL)g; `)

(v) (E [ f(t; s)g; K [ f(t; fjRgjL); (s; fjR0gjL0)g [ f(u; hhFuiiLu ) j u 2 Dom(R + R0)g; `)

=) ( [tns](E [ f(R(u); R0(u)) j u 2 Dom(R) " Dom(R0)g);

[tns](K [ f(s; fjR + R0gjL"L0)g [ f(u; hhFuiiL"L0"Lu) j u 2 Dom(R + R0)g);
[tns] ffi `)
if Dom(Fu) ` L " L0 for any u 2 Dom(R + R0).

(vi) (E; K [ f(t; fjRgjL); (s1; hhF1iiL1); (s2; hhF2iiL2)g; `)

=) ( E [ f(R(s1); R(s2))g [ f(F1(`); F2(`)) j ` 2 Dom(F1) " Dom(F2)g;

K [ f(t; fjRgjL); (s1; hhF1iiL1); (s2; hhF2iiL2 )g;
`)if
s1; s2 2 Dom(R), Dom(F1) " Dom(F2) 6= ;, and either R(s1) 6= R(s2) or F1(`) 6= F2(`)for some

` 2 Dom(F1) " Dom(F2).

Rule (i)-(iv) are prior to (v); Rule (i)-(v) are prior to (vi).

Figure 4: Rewriting Rules for Kinded Unification

bound of the set of method names. The rule OBJECT gives a typekinded by an object kind

fjt1 ! o/01; : : : ; tn ! o/ 0ngjf`

1;:::;`ng. Thiskinding describes the object as an object accepting n dynamic messages whose types are given as t1 :: hh`1(o/1)iif`1;:::;`ng; : : : ; tn ::
hh`n(o/n)iif`1;:::;`ng, respectively. For each method `i, the argument type o/i and the result type o/ 0 is derived by a typing derivationsimilar to that for functions in functional languages. The rule M

SG-P
ASS first derives the type of the object and the type of the messagepassed to the object. If the message has a type

s and the object hassuch a type
t :: fjs ! o/ gjL that accepts the dynamic message andreturns the result of type

o/ , then the derivation yields o/ as the typeof the message passing. The rule L

ET introduces an ML-style letpolymorphism by taking a type closure. The rule L

ETOBJ is a vari-ant of the L
ET rule, which combines the recursive object typingwith the polymorphic typing.

3.4 Type Soundness
We show that the type system is sound with respect to the op-erational semantics by following Leroy's method for proving the

soundness in the presence of recursion [Ler92]. We first definetypes of values relative to a kind assignment. Value typing is given
as the following three relations.

K j= v : o/ A value v has a type o/ relative to K.
K j= v : oe A value v has a polytype oe relative to K.
K j= ae : \Gamma  A run-time environment ae has a type assignment

\Gamma  relative to K.
These relations are defined on the structure of v and ae as follows.

ffl K j= c : b if c is a constant of base type b.
ffl K j= `(v) : t if K(t) = hh`(o/); : : :iiL and K j= v : o/ .

ffl K j= f`1(x1; y1; M1; ae1); : : : ; `n(xn; yn; Mn; aen)g : t

- if K(t) = fjt1 ! o/1; : : : ; tn ! o/ngjL such thatS

i Labels(K(ti)) = L = f`1; : : : ; `ng and-
for every i and j such that K(tj) = hh`i(o/ ); : : :iiL0 ,there exists a type assignment

\Gamma  such that K j= aei : \Gamma and
K; \Gamma  + fxi : t; yi : o/ g ` Mi : o/i.

ffl K j= v : oe if for any kinded substitution (K0; `) that respects

K and any type o/ such that o/ _K0 `(oe), K0 j= v : o/ .

ffl K j= ae : \Gamma  if domain(ae) = domain(\Gamma  ) and K j= ae(x) :

\Gamma  (x) for all x 2 domain(\Gamma  ).

We can show that both typing derivation and value typing arepreserved by any kinded substitution respecting the kind assignment.
Proposition 3.2 Let K be a kind assignment, \Gamma  be a type assign-ment

M be an expression, and o/ be a type. If K; \Gamma  ` M : o/, then
K0; `(\Gamma  ) j= M : `(o/ ) holds for every kinded substitution (K0; `)that respects

K.

Proposition 3.3 Let K be a kind assignment, v be a value, and o/be a type. If

K j= v : o/, then K0 j= v : `(o/ ) holds for every kindedsubstitution
(K0; `) that respects K.

Then we can show the desired property.
Theorem 3.4 (Type soundness) Let K be a kind assignment, \Gamma be a type assignment, and

ae be a run-time environment satisfying
K j= ae : \Gamma  . If an expression M has a typing derivation K; \Gamma  `
M : o/ and there is an evaluation derivation ae ` M + r, then wehave

K j= r : o/.

8

I(K; \Gamma ; c) = (K; [ ]; b)where

b is the base type of constant c.

I(K; \Gamma ; x) =if

x 62 domain(\Gamma  ) then failureelse let

8t1 :: k1; \Delta  \Delta  \Delta  ; tn :: kn:o/ = \Gamma  (x)where

t1; : : : ; tn are renamed to fresh type variables.in
(K + ft1 :: k1; \Delta  \Delta  \Delta  ; tn :: kng; [ ]; o/ )

I(K; \Gamma ; `(M)) =let

(K0; `; o/) = I(K; \Gamma ; M)let
t be a fresh type variablein
(K0 + ft : hh`(o/)iiLg; `; t)

I(K; \Gamma ; f`1(x1) = M1; : : : ; `n(xn) = Mng) =let

t; t1; : : : ; tn; s1; : : : ; sn; u1; : : : ; un be fresh type variableslet
L = f`1; : : : ; `nglet
K0 = K + f t :: fjt1 ! u1; : : : ; tn ! ungjL;

t1 :: hh`1(s1)iiL; : : : ; tn :: hh`n(sn)iiL;
s1 :: U; : : : ; sn :: U; u1 :: U; : : : ; un :: Uglet
(K00; `00; o/1) = I(K0; \Gamma  + fx1 : s1g; M1)let
(K1; `1) = U(K00; f(o/1; `00(u1))g).

..
let (K0n\Gamma 1; `0n\Gamma 1; o/n) = I(Kn\Gamma 1; `n\Gamma 1 ffi \Delta  \Delta  \Delta  ffi `1 ffi `00(\Gamma  + fxn : sng); Mn)let

(Kn; `n) = U(K0n\Gamma 1; f(o/n; `0n\Gamma 1 ffi `n\Gamma 1 ffi \Delta  \Delta  \Delta  ffi `1 ffi `00(un))g)in
(Kn; `n ffi `0n\Gamma 1 ffi \Delta  \Delta  \Delta  ffi `1 ffi `00; `n ffi `0n\Gamma 1 ffi \Delta  \Delta  \Delta  ffi `1 ffi `00(t))

I(K; \Gamma ; M  N) =let

(K0; `0; o/0) = I(K; \Gamma ; M)let
(K1; `1; o/1) = I(K; `0(\Gamma  ); N )let
t; s; u be fresh type variableslet
(K2; `2) = U(K1 + ft :: fjs ! ugjL; s :: hhiiL; u :: Ug; f(t; `1(o/0)); (s; o/1)g)in
(K2; `2 ffi `1 ffi `0; `2(u))

I(K; \Gamma ; let x = M in N ) =let

(K0; `0; o/0) = I(K; \Gamma ; M)let
ft1; : : : ; tng = EFTV (K0; o/0) n EFTV (K0; `0(\Gamma  ))let
(K1; `1; o/1) = I(K0; `0(\Gamma  ) + fx : 8t1 :: K0(t1); \Delta  \Delta  \Delta  ; tn :: K0(tn):o/0g; N)in
(K1; `1 ffi `0; o/1)

I(K; \Gamma ; letobj x = f`1(x1) = M1; : : : ; `n(xn) = Mng in N) =let t be a fresh type variable.

let (K0; `0; s) = I(K + ft :: fjgjLg; \Gamma  + fx : tg; f`1(x1) = M1; : : : ; `n(xn) = Mng)let

(K1; `1) = U(K0; f(`0(t); s)g)let
ft1; : : : ; tng = EFTV (K1; `1(s)) n EFTV (K1; `1 ffi `0(\Gamma  ))let
(K2; `2; o/ ) = I(K0; `1 ffi `0(\Gamma  ) + fx : 8t1 :: K1(t1); \Delta  \Delta  \Delta  ; tn :: K1(tn):`1(s)g; N)in
(K2; `2 ffi `1 ffi `0; o/)

Figure 5: Type Inference Algorithm
3.5 Type Inference
We present a type inference algorithm for our language. The typeinference algorithm needs an auxiliary procedure, kinded unification, that unifies types under a kinding restriction.Let

E be a set of tuples of types, where each tuple representsa type equation to be solved. A kinded set of type equations is a

pair (K; E) of a kind assignment K and a set E of type equations,where each equation is an unordered pair of types and every type

o/contained in
E is well-formed under K. A unifier for a kinded set

of type equations (K; E) is a kinded substitution (K0; `) respecting
K such that domain(K0) " domain(`) = ; and `(o/) = `(o/ 0) forevery

(o/; o/ 0) 2 E. We say a unifier (K0; `) is a most general unifierfor a kinded type equation

(K; E), if for any unifier (K00; `0), thereexists a substitution
`00 such that (K00; `00) respects K0 and `0 =
`00 ffi `.We define our kinded unification algorithm as a rewriting procedure that unifies a kinded set of type equations, in the spirit ofthe transformational method for E-unification by Gallier and Sny9

\Pi 0 =

...
K0; fm : s; x : intg ` x+1 : int

...
K0; fm : s; x : intg ` x?0 : bool
K0 ` s1 :: hhsucc(int)iifsucc;posg K0 ` s2 :: hhpos(int)iifsucc;posg K0 ` t1 :: fjs1 ! int; s2 ! boolgjfsucc;posg

K0; fm : sg ` fsucc(x)=x+1, pos(x)=(x?0)g : t1

K0 ` s0 :: hhbar(s)iifbarg

K0 ` t0 :: fjs0 ! ugjfbarg

\Pi 0..

..
K0; fm : sg ` fsucc(x)=x+1, pos(x)=(x?0)g : t1 K0 ` t1 :: fjs ! ugjfsucc;posg K0; fm : sg ` m : s

K0; fm : sg ` fsucc(x)=x+1, pos(x)=(x?0)gm : u

K0; fg ` fbar(m) = fsucc(x)=x+1, pos(x)=(x?0)gmg : t0
where K0 = f t0 :: fjs0 ! ugjfbarg; t1 :: fjs ! u; s1 ! int; s2 ! boolgjfsucc;posg; u :: U;

s :: hhiifsucc;posg; s0 :: hhbar(s)iifbarg; s1 :: hhsucc(int)iifsucc;posg; s2 :: hhpos(int)iifsucc;posgg:

(a) Object definition
...

K1; fg ` fbar(m) = ...g : t0 K1 ` t0 :: fjs0 ! intgjfbarg

K1; fg ` 3 : int K1 ` s :: hhsucc(int)iiL

K1; fg ` succ(3) : s K1 ` s0 :: hhbar(s)iiL

K1; fg ` bar(succ(3)) : s0

K1; fg ` fbar(m) = fsucc(x)=x+1, pos(x)=(x?0)gmg bar(succ(3)) : int

where K1 = f t0 :: fjs0 ! intgjfbarg; t1 :: fjs ! int; s1 ! int; s2 ! boolgjfsucc;posg;

s :: hhsucc(int)iifsucc;posg; s0 :: hhbar(s)iifbarg; s1 :: hhsucc(int)iifsucc;posg; s2 :: hhpos(int)iifsucc;posgg:

(b) Message passing

Figure 6: Examples of Typing Derivation
der [GS89]. The rewriting procedure is given in Figure 4 by a set ofrules for rewriting triple

(E; K; `), where (K; E) is a kinded set oftype equations to be solved and

` is a type substitution for unifyingthe type equations that have been solved so far. We impose some

priority between the rewriting rules; we say a rewriting rule A isprior to

B, if the rewriting rule B can be applied only when therule
A cannot. In each rewriting rule, a kind assignment K is ex-pressed by a set of ordered pairs of type variable and its kind, i.e.,

f(t; K(t)) j t 2 domain(K)g. We define substitution to a set Eof type equations by

`(E) = f(`(o/1); `(o/2)) j (o/1; o/2) 2 Eg.Furthermore, we use the following notations. We write a message kind as hhF iiL, where F is a finite map from a set of labels
`1; : : : ; `n to the corresponding argument types representing a se-quence

`1(F (`1)); : : : ; `n(F (`n)). Similarly, we write an objectkind as
fjRgjL, where R is a finite map from type variables to typesrepresenting a sequence

t1 ! R(o/1); : : : ; tn ! R(o/n) such that
t1; : : : ; tn are distinct.Given a kinded set of type equations

(K; E), suppose thattriple
(E; K; [ ]) is rewritten to a triple (;; K0; `) by the rewrit-ing rules and that no rewriting rule cannot be applied any more.

Then, we define the result of kinded unification algorithm U by
U(K; E) = (K0; `); If there is no such rewriting, we define instead
U(K; E) = fail. The following property holds for the kinded unification algorithm U.
Theorem 3.5 Let (K; E) be a kinded set of type equations. If
(K; E) has a unifier, the unification algorithm U computes a mostgeneral unifier

(K0; `); otherwise the algorithm reports fail.

We give a type inference algorithm I, a variant of Damas-Milner's ML type inference algorithm

W [DM82], in Figure 5. Thealgorithm fails if and only if either the algorithm returns failure or

the subsidiary kinded unification algorithm U fails in unification;Otherwise,

I(K; \Gamma ; M) returns a triple (K0; `; o/ ). We say a triple
(K0; `; o/) is a typing of an expression M under a kind assignment
K and a type assignment \Gamma  , if there is a typing derivation to yield
K0; `(\Gamma  ) ` M : o/ and (K0; `) respects K. We say (K0; `; o/) is amost principal typing, if for any typing

(K00; `0; o/ 0) of M under Kand
\Gamma  there exists a substitution  such that (K00; ) respects K0,
(o/) = o/ 0, and  ffi ` = `0. The following theorem shows that thetype inference algorithm

I infers a most principal typing.

Theorem 3.6 (Principality of type inference algorithm) Let Kbe a kind assignment,

\Gamma  be a type assignment, and M be an ex-pression.
I(K; \Gamma ; M) successfully returns a most principal typingif and only if

M has a typing under K and \Gamma  .

10

4 Typing Examples and Class Definition
We show some examples of typing derivations. We first considerthe following expression defining an object

fbar(m) = fsucc(x)=x+1, pos(x)=(x?0)gmg
whose only method is the bar method defined in Section 2. Thederivation tree is given in Figure 6 (a), where

\Pi 0 is a sub-derivation tree for the inner object definition,

fsucc(x)=...,pos(x)=...
g. The bar method is typed as a method which receivesa message, whose type is

s :: hhiifsucc;posg, and returns theresult of passing the message to the inner object. The type of

the result of the message passing is expressed by u :: U, whoseproper type is determined when a message is given as the argument of the bar method, as shown in the following expression.

fbar(m) =

fsucc(x)=x+1, pos(x)=(x?0)gmgbar(succ(3))

The typing derivation for this expression is given in Figure 6 (b).To type this expression, we need to alter the kinding for

the dynamic message m to include the method succ, i.e.,
s :: hhsucc(int)iifsucc;posg. Furthermore, we need to fix thekinding for the inner object so that it conforms the well-formedness

condition by unifying u and int. Due to this unification, we havethe expected result type

int, for the above message passing.Our language can define recursive objects by using letobj, and

the type of recursive objects is expressed in our type system asrecursively kinded types, where the recursiveness is expressed by
mutual reference between types and kinds. As an example of suchrecursive typing, we consider a class definition, which is encoded
as an object with a parameterized method for creating instances asdescribed in [CHC90]. The following example defines a simple
point class.

letobj point =

fnew(x) = fget()=x, move(y)=pointnew(x+y)gg

where the method new returns an instance of the point class. Theinstance consists of two methods, get for returning the initial

location given as the parameter when the instance is created,and move for creating a new instance whose location is moved
according to the given argument. By a typing derivation similarto the above example, the point class is typed as an object whose
only method new receives an integer parameter and returns aninstance of the following type

t :: fjs1 :: hhget(unit)iiL ! int; s2 :: hhmove(int)iiL ! tgjL,
where L = fget; moveg. The type of the instance represents arecursive object, where the result type of the method move refers
to the type of the object itself.

5 Conclusion and Future Work
We have presented a second order polymorphic type system for anobject-oriented language with dynamic messages. The type system offers a powerful static typing discipline that allows typing dy-namic messages with insufficient static information about method
names. The type system takes an approach to determine types lazilywhen sufficient static information is supplied, which allows the result type of the method to vary depending on the argument type.The language can encode classes by recursive objects, where the
types of recursive objects are expressed as recursively kinded typesin the type system. The type system is sound with respect to the

operational semantics of the language, and the types of programscan be reconstructed by a type inference algorithm.

The language presented in the paper is a small language thatprovides no class inheritance mechanism. To support inheritance
based on the class encoding described in Section 4, we need to ex-tend the language with an object concatenation operator. However,
it seems difficult to type the object concatenation operator in theframework of the presented type system, since the object concatenation requires negative information to tell that some methods mustnot be contained in an object. To avoid the complexity of treating
negative information, we would have to put some syntactic restric-tion on class definitions so that the set of method names can be
determined statically.Subtyping is another possible way to support class inheritance.
A possible strategy to support subtyping in our type system wouldbe to define a subkinding relation

v under a kind assignment K asfollows.

ffl hh`1(o/1); : : : ; `n(o/n); : : :iiL v hh`1(o/ 01); : : : ; `n(o/0n)iiL0if

L ` L0 and o/i v o/0i for every i = 1; : : : ; n.

ffl fjt1 ! o/1; : : : ; tn ! o/n; : : :gjL v fjt01 ! o/01; : : : ; t0n ! o/ 0ngjL0if

L ` L0 and also K(t0i) v K(ti) and o/i v o/ 0i for every
i = 1; : : : ; n.

However, it seems difficult to incorporate this subkinding relationinto a sound type system. We need further careful investigation on

this topic.As mentioned in Section 1, the object-oriented language enriched with dynamic messages suggests a calculus of objects andmessages, which are interacting with each other as the duals of one
another, and therefore our type system provides a foundation fora typed calculus of the duals. The calculus has an interesting typing property that identically named methods invoked by the samemessage can yield differently typed results. We might be able to
apply this property to other type systems. Besides, in a distributedenvironment, the calculus utilizes the distributed resources in a different way from that of *-calculus. The example of the networkfile server given in Section 1 indicates a difference between the abstraction mechanisms of higher-order functions and dynamic mes-sages. Suppose that dynamic messages are encoded by functions.
In the case, function closures packaging the local computational re-sources, namely the run-time environment and the program code,
are passed over the network, and the function closures are executedon the server machine. This corresponds to the conventional migration mechanism in distributed computing. In contrast to the migra-tion based approach, dynamic messages passed to a remote server
transfer only a small amount of local resources, namely arguments,to the remote server and mainly utilize remote resources. Dynamic
messages seem to have the advantage over function closures of pro-ducing a smaller amount of network traffic than function closures.
Further investigation on this topic would shed some light on theutilization of distributed resources in distributed computing.

Acknowledgment
I would like to thank anonymous referees whose comments are veryvaluable for improving the paper. I am also grateful to Atsushi
Ohori for his advice and encouragement.

References
[AC96] M. Abadi and L. Cardelli. A Theory of Objects.Springer, 1996.

11

[AWL94] A. Aiken, E. L. Wimmers, and T. K. Lakshman. Softtyping with conditional types. In Proceedings of

ACM Symposium on Principles of Programming Lan-guages, pages 163-173, 1994.

[BB96] F. Barbanera and S. Berardi. A symmetric lambdacalculus for classical program extraction. Information

and Computation, 125:103-117, 1996.
[BNOW93] A. Birrell, G. Nelson, S. Owicki, and E. Wobber. Net-work objects. In Proceedings of the Fourteenth ACM

Symposium on Operating Systems Principles, pages217-230, 1993.

[BPF97] K. B. Bruce, L. Petersen, and A. Fiech. Subtypingis not a good "match" for object-oriented languages.

In ECOOP '97 Proceedings, volume 1242 of LNCS,pages 104-127, 1997.

[BSvG95] K. B. Bruce, A. Schuett, and R. van Gent. Poly-TOIL: A type-safe polymorphic object-oriented language. In ECOOP '95 Proceedings, volume 952 ofLNCS, pages 27-51, 1995.

[Car88] L. Cardelli. A semantics of multiple inheritance. In-formation and Computation, 76(2-3):138-164, 1988.
[CCH+89] P. Canning, W. Cook, W. Hill, W. Olthoff, andJ. C. Mitchell. F-bounded polymorphism for objectoriented programming. In Proceedings of ACM Con-ference on Functional Programming and Computer
Architecture, pages 273-280, 1989.
[CHC90] W. R. Cook, W. L. Hill, and P. S. Canning. Inheritanceis not subtyping. In Proceedings of ACM Symposium on Principles of Programming Languages, pages125-135, 1990.

[DM82] L. Damas and R. Milner. Principal type schemes forfunctional programs. In Proceedings of ACM Symposium on Principles of Programming Languages, pages207-212, 1982.

[GM94] C. A. Gunter and J. C. Mitchell, editors. TheoreticalAspects of Object-Oriented Programming Types, Semantics, and Language Design. The MIT Press, 1994.
[GR89] A. Goldberg and D. Robson. Smalltalk-80 The Lan-guage. Addison-Wesley, 1989.

[GS89] J. Gallier and W. Snyder. Complete sets of transforma-tions for general E-unification. Theoretical Computer

Science, 67(2):203-260, 1989.
[Gun92] C. A. Gunter. Semantics of Programming Languages.The MIT Press, 1992.

[HP95] M. Hofmann and B. C. Pierce. A unifying type-theoretic framework for objects. Journal of Functional Programming, 5(4):593-635, 1995.
[Ler92] Xavier Leroy. Polymorphic typing of an algorithmiclanguage. Ph.D. thesis RR-1778, INRIA, 1992.

[Mit90] J. C. Mitchell. Toward a typed foundation for methodspecialization and inheritance. In Proceedings of

ACM Symposium on Principles of Programming Lan-guages, pages 109-124, 1990.

[OB89] A. Ohori and P. Buneman. Static type inference forparametric classes. In Proceedings of ACM OOPSLA

conference, pages 121-148, 1989.
[Oho95] A. Ohori. A polymorphic record calculus and its com-pilation. ACM Transactions on Programming Languages and Systems, 17(6):844-895, 1995.
[PT94] B. C. Pierce and D. N. Turner. Simple type theoreticfoundations for object-oriented programming. Journal of Functional Programming, 4(2):207-247, 1994.
[PW91] L. J. Pinson and R. S. Wiener. Objective-C: object-oriented programming techniques. Addison-Wesley,

1991.
[R'em89] Didier R'emy. Typechecking records and variants in anatural extension of ML. In Proceedings of ACM Symposium on Principles of Programming Languages,pages 77-87, 1989.

[R'em94] Didier R'emy. Programming objects with ML-ART,an extension to ML with abstract and record types.

In Theoretical Aspects of Computer Software, pages321-346, 1994.

[Wan87] M. Wand. Complete type inference for simple ob-jects. In Proceedings of Second Symposium on Logic

in Computer Science, pages 37-44, 1987.

Appendix: Summary of Type Soundness Proof
Let \Phi K be a function defined as follows
\Phi K(S) = S

[ [

t2S

KFTV (K(t))

[ ft 2 domain(K) j K(t) = fjs ! o/; : : :gjL and s 2 Sg;
where S ` domain(K). The set of essentially free type variablescan be defined by means of iteration of this function, i.e.,

EFTV (K; oe) = \Phi 1K (FTV (oe)) = S1n=0 \Phi nK(FTV (oe))
EFTV (K; \Gamma  ) = \Phi 1K (FTV (\Gamma  )) = S1n=0 \Phi nK(FTV (\Gamma  )):

The following lemma holds.
Lemma A.1 Let K; K0 be kind assignments, ` be a type substitu-tion such that

(K0; `) respects K.

(1) For any t 2 domain(K) and any kind k such that K ` t :: k,we have

KFTV (K(t)) ' KFTV (k).

(2) For any t 2 domain(K),

KFTV (`(K(t))) ` [

s2FTV(`(t))

KFTV (K0(s)):

(3) [

t2\Phi nK(S)

FTV (`(t)) ` \Phi nK0([

t2S

FTV (`(t)))

As a corollary,[

t2EFTV(K;oe)

FTV (`(t)) ` EFTV (K0; `(oe))

[

t2EFTV(K;\Gamma )

FTV (`(t)) ` EFTV (K0; `(\Gamma  )):

12

Proof. Property 1 is immediately from the definition of the kindingrelation. Property 2 is proved by case analysis on

K(t). Property 3is proved by induction on
n, using the property 2.

The proof of Proposition 3.2 is given below.
Proof. Proof is by induction on the height of typing derivation. Weprove the induction step by case analysis on the last rule used to

derive the typing derivation.We only consider the most involving case that the last rule is

LET. The typing derivation is as follows.

K0; \Gamma  ` M : o/ 0 (K; oe) = Clos(K0; \Gamma  ; o/0)

K; \Gamma  + fx : oeg ` N : o/

K; \Gamma  ` let x = M in N : o/

By the definition of type closure, oe = 8t1 :: K0(t1); \Delta  \Delta  \Delta  ; tm ::
K0(tm):o/0 such that ft1; : : : ; tmg = EFTV (K0; o/0) n
EFTV (K0; \Gamma  ), domain(K0) = ft1; : : : ; tmg [ domain(K),and

K0(t) = K(t) for all t 2 domain(K). We can assume,by the bound variable convention,

t1; : : : ; tm are fresh variablesthat appear neither in
K nor in K0. Let K1 = K0 + ft1 ::
`(K0(t1)); : : : ; tm :: `(K0(tm))g. It is easy to show that (K1; `)respects

K0.By applying the induction hypothesis to the two premises,

we have typing derivations K1; `(\Gamma  ) ` M : `(o/ 0) and
K0; `(\Gamma  ) + fx : `(oe)g ` N : `(o/). We will show
Clos(K1; `(\Gamma  ); `(o/0)) = (K0; `(Clos(K; \Gamma  ; o/ 0))). First, weshow

EFTV (K1; `(o/0)) n EFTV (K1; `(\Gamma  )) = ft1; : : : ; tmg.We have

ft1; : : : ; tmg ` EFTV (K1; `(o/ 0)), by lemma A.1 (3).Then we prove

ft1; : : : ; tmg " EFTV (K1; `(\Gamma  )) = ;, i.e.
ft1; : : : ; tmg " \Phi nK1(FTV (`(\Gamma  ))) = ;. Proof is by in-duction on

n. If n = 0, ti 62 \Phi nK1(FTV (`(\Gamma  ))) =

FTV (`(\Gamma  )) ` domain(K0) for every i. Suppose that the equation holds for n and that ti 2 \Phi n+1K

1 (FTV (`(\Gamma  ))) for somei. By the definition of \Phi 

K1 and the induction hypothesis, ei-ther

ti 2 St2\Phi n

K1(FTV(`(\Gamma ))) KFTV (K1(t)) or there exists s 2

\Phi nK1(FTV (`(\Gamma  ))) such that K1(ti) = fjs ! o/; : : :gjL. However,since

ti is assumed to be a fresh type variable, either of theseconditions cannot be satisfied due to the definition of

EFTV .Therefore, the inclusion
ft1; : : : ; tmg ` EFTV (K1; `(o/0)) n
EFTV (K1; `(\Gamma  )) holds. To show the converse inclusion, weprove the following property: for any

t 2 \Phi nK1(FTV (`(o/ 0))) n
EFTV (K1; `(\Gamma  )), t = ti for some i for some n. Proof isby induction on

n by refutation. If n = 0 and there exists
t 2 FTV (`(o/ 0)) n EFTV (K1; `(\Gamma  )) such that t is not any of
t1; : : : ; tm, then there exists s 2 FTV (o/0) such that s is not anyof

t1; : : : ; tm (hence, s 2 EFTV (K0; \Gamma  )) and t 2 FTV (`(s)).Therefore, by lemma A.1 (3), we have

t 2 FTV (`(s)) `
EFTV (K1; `(\Gamma  )). This contradicts to t 62 EFTV (K1; `(\Gamma  )).Suppose the property holds for

n and there exists t such that
t 2 \Phi n+1K

1 (FTV (`(o/

0))) n EFTV (K1; `(\Gamma  )) and t is not any of

t1; : : : ; tm. By the definition of \Phi K1 , we need to check three cases.(a) If

t 2 \Phi nK1 (FTV (`(t))), the proof has finished by the induction hypothesis. (b) Suppose there exists t0 2 \Phi nK1 (FTV (`(o/ 0)))
such that t 2 KFTV (K1(t0)). By the induction hypothesis, ei-ther

t0 = ti for some i or t0 2 EFTV (K1; `(\Gamma  )). If t0 2
EFTV (K1; `(\Gamma  )), then t 2 EFTV (K1; `(\Gamma  )) by the definitionof

EFTV , which contradicts to t 62 EFTV (K1; `(\Gamma  )). Sup-pose

t0 = ti for some i. Then, we have t 2 KFTV (K1(t0)) =
KFTV (`(K0(ti))), and therefore there exits s 2 KFTV (K0(ti))such that

t 2 FTV (`(s)). Notice that KFTV (K0(ti)) `
ft1; : : : ; tmg [ EFTV (K0; \Gamma  ). If s = tj for some j, then
t = tj, contradicting to the assumption. If s 2 EFTV (K0; \Gamma  )otherwise, by lemma A.1 (3), we have

t 2 FTV (`(s)) `

EFTV (K1; `(\Gamma  )), which contradicts to t 2 EFTV (K1; `(\Gamma  )).(c) Suppose there exists

s 2 \Phi nK1(FTV (`(o/ 0))) such that K1(t) =

fjs ! o/; : : :gjL. Since domain(K1) = ft1; : : : ; tng[domain(K0)and

t is not any of t1; : : : ; tn, t 2 domain(K0). Therefore sis not any of

t1; : : : ; tn, and by the induction hypothesis, s 2
EFTV (K1; `(\Gamma  )). By the definition of EFTV , this implies t 2
EFTV (K1; `(\Gamma  )), which contradicts to t 62 EFTV (K1; `(\Gamma  )).By the discussion above, we can conclude

EFTV (K1; `(o/0)) n EFTV (K1; `(\Gamma  )) = ft1; : : : ; tmg and wehave

Clos(K0; `(\Gamma  ); `(o/ 0)) = (K1; 8t1 :: `(K(t1)); \Delta  \Delta  \Delta  ; tm ::
`(K(tm)):`(o/0)) = (K1; `(oe)). Therefore, we can get the typingderivation

K0; `(\Gamma  ) ` let x = M in N : `(o/) by applying theL
ET rule.

Proposition 3.3 is proved by routine induction on the structureof value

v, by using proposition 3.2. The proposition leads thefollowing corollary.

Corollary A.2 If K + ft1 :: k1; : : : ; tn :: kng j= v : o/ and
domain(K) " ft1; : : : ; tng = ;, then K j= v : 8t1 :: k1; \Delta  \Delta  \Delta  ; tn ::
kn:o/.

Proof. By the bound variable convention and the definition ofgeneric instance.

The type soundness theorem (theorem 3.4) is proved as follows.
Proof. Proof is by induction on the height of evaluation derivation.We argue each induction step by case analysis on the last rule used

to derive the derivation. Only a few critical cases are examined inthe following.
Case VAR rule. M = x and the only possible typing is

x 2 domain(\Gamma  ) o/ _K \Gamma  (x)

K; \Gamma  ` x : o/

Since x 2 domain(\Gamma  ), x 2 domain(ae) and r = ae(x). Wehave

K j= ae(x) : \Gamma  (x) by the hypothesis K j= ae : \Gamma  . Since
o/ _K \Gamma  (x), by the definition of relation j=, we conclude
K j= ae(x) : o/ .

Case MSGPASS rule. The only possible typing is

K; \Gamma  ` M : t K ` t :: fjs ! o/ gjL K; \Gamma  ` N : s

K; \Gamma  ` M  N : o/
By the induction hypothesis, we have the following four relations.

ae ` M + f`1(x1; y1; M1; ae1); : : :g, ae ` M + `(v0),
K j= f`1(x1; y1; M1; ae1); : : :g : t, and K j= `(v0) : s.

Since K ` t :: fjs : o/gjL, there exists i such that `i = ` and
K(s) = hh`i(o/ 0); : : :iiL0. Hence, there exists a type assignment
\Gamma  such that K ` aei : \Gamma  and K; \Gamma  + fxi : t; yi : o/ 0g ` Mi : o/ .Since

K j= aei + fxi 7! f`(xi; yi; Mi; aei); : : :g; yi 7! v0g :
\Gamma  + fxi : t; yi : o/0g, by applying the induction hypothesis, wehave

aei + fxi 7! f`i(xi; yi; Mi; aei); : : :g; yi 7! v0g ` Mi + vand
K j= v : o/ .

Case LET rule. The only possible typing is

K0; \Gamma  ` M : o/0 (K; oe) = Clos(K0; \Gamma  ; o/ 0)

K; \Gamma  + fx : oeg ` N : o/

K; \Gamma  ` let x = M in N : o/

By the induction hypothesis, we have ae ` M + v0 and K j=
v0 : o/0. By corollary A.2, K j= v0 : oe and K j= ae + fx : v0g :
\Gamma  + fx : oeg. By the induction hypothesis, we have ae + fx : v0g `
N + v and K j= v : o/.

13