

Recursive polymorphic types and parametricityin an operational framework

Paul-Andr'e Melli`es * J'er^ome Vouillon *
Abstract
We construct a realizability model of recursive polymorphic types, starting from an untyped language of terms andcontexts. An orthogonality relation

e ? ss indicates when
a term e and a context ss may be safely combined in the
language. Types are interpreted as sets of terms closedby biorthogonality. Our main result states that recursive

types are approximated by converging sequences of intervaltypes. Our proof is based on a "type-directed" approximation technique, which departs from the "language-directed"approximation technique developed by MacQueen, Plotkin
and Sethi in the ideal model. We thus keep the language el-ementary (a call-by-name

*-calculus) and unstratified (no
typecase, no reduction labels). We also include a short account of parametricity, based on an orthogonality relationbetween quadruples of terms and contexts.

1 Introduction

In this article, we describe how a large variety of typ-ing constructions: recursive types, polymorphism, subtyping, product types, intersection types, union types, as wellas parametricity, may be interpreted and studied in a somewhat na"ive and operational framework. We choose to setour scene slowly, starting from a brief account of recursive
types in categories of domains, then shifting gradually tothe operational model we have in mind.

Recursive types. Solving recursive equations betweentypes is generally done in categories. Take for instance the
equation

X = 1 + X (1)

in the category Set of sets and functions, where 1 + X de-notes the disjoint union of

X and of the singleton 1 = {*}.This equation has two canonical solutions, namely the set N

of natural numbers, and the set N+{1} of natural numberscompleted by infinity. By "solution", one means a set

Xequipped with an isomorphism
X - 1 + X, alternativelyseen as its inverse map
X -! 1 + X. Accordingly, eachof the solution sets N and N + {1} comes equipped with a

*Postal address: Equipe PPS, CNRS and Universit'e Paris VII, 2 place
Jussieu, Case 7014, 75251 Paris Cedex 05, FRANCE. Email address: mel-lies@pps.jussieu.fr and vouillon@pps.jussieu.fr

function s and p, called "successor" and "predecessor":

N s- 1 + N N + {1} p-! 1 + N + {1} (2)
and defined respectively as s(*) = 0 and s(n) = n + 1, andas

p(0) = *, p(n + 1) = n and p(1) = 1, for all n 2 N.

The two solutions (2) are canonical in the followingsense. Call prefixpoint

f and postfixpoint g of equation (1)any function:

X f- 1 + X and Y g-! 1 + Y.
Canonicity says that, for any such f (resp. g), there exists aunique function

h (resp. k) making the diagram commute:

X 1 + X

foo

N

h
OO

1 + Nsoo

1+h
OO N + {1}

p // 1 + N + {1}

Y

g //

k

OO

1 + Y

1+k
OO (3)

In other words, s is the "initial" prefixpoint (called inductivesolution), and

p is the "terminal" postfixpoint (called coin-ductive solution) of equation (1). What we find here is nothing but the "categorification" of Knaster-Tarski's theory offixpoints for a monotone function in a complete lattice. A
categorical terminology is generally adopted: the "prefix-points" and "postfixpoints" are called

T -algebras and T -coalgebras for the functor
T : Set -! Set defined as
T (X) = 1 + X. And the diagrams of equation (3) expressthat the

T -algebra s is the "initial" T -algebra, and that the
T -coalgebra p is the "terminal" T -coalgebra.

Mixed variance. Equation (1) is particularly simple be-cause the variable

X occurs only in a covariant (= positive)position. More complicated recursive equations may be also

considered, like

X = X ) X (4)

where the variable X appears in a covariant as well as acontravariant (= negative) position. This kind of equation

may be formulated in any cartesian closed category, where
X ) Y denotes the usual arrow construct.

These equations of mixed variance have (in general) nosolution in the category Set. Typically, equation (4) has

only the trivial solution X = 1, while equation

X = 1 + (X ) X) (5)

has no solution at all, for obvious cardinality reasons.Scott invented Domain Theory when he realized that
equations of mixed variance like (4) and (5) could be solvedby shifting from the category Set to the category CPO
of domains (= partial orders with a least element ? andall directed limits) and continuous (= monotone and limitpreserving) functions between them. We refer the readerto [4] for a modern exposition of Domain Theory.

We only mention here that Freyd [15] derives this exis-tence of solutions in

CPO from a striking property of itssubcategory CPO

? of strict (= ?-preserving) functions,called "algebraic compactness". The property states that

the initial T -algebra and the terminal T -coalgebra coincidefor every (well-behaved) covariant endofunctor

T : CPO? -! CPO?.
Freyd shows that the category CPOop? * CPO? is alsoalgebraically compact, and reformulates in this way any

mixed variance functor on CPO? as a covariant endofunc-tor

T on this category. The unique canonical fixpoint of Tis shown to be of the form (

D, D0) where D and D0 are iso-morphic in CPO

?. This provides the solution D ,= D0 tothe original mixed-variance equation over CPO.

We step back to equation (1) for illustration, slightly gen-eralized in the category

CPO as equation:

X = 1? + (A * X) (6)
where A denotes a fixed domain. That is, the domain Xis required to be isomorphic to the coalesced sum of the

lifted domain 1? = {?, *} with the cartesian product ofthe domains

A and X. Just as in Set, equation (6) has aninductive solution (= the domain of lists over

A) and a coin-ductive solution (= the domain of streams over

A) in thecategory
CPO. But in contrast to Set, algebraic compact-ness implies that the two solutions coincide in CPO.

The ideal model. We found instructive to recall brieflythe categorical approach to recursive types, because it is
elegant and mainstream. We shift now to a different ap-proach to recursive types, initiated by MacQueen, Plotkin,
and Sethi in the ideal model for types [19]. The ideal modelis still domain-theoretic, but not categorical any more. This
brings us one step closer to the operational framework de-veloped in this article.

The ideal model is built in two stages. First stage: a do-main V of "semantic expressions" is fixed, defined in [19]
as the canonical solution in CPO of the equation:

V = T+N+(V ! V)+(V*V)+(V+V)+{0}? (7)
This may be read as follows: V is (isomorphic to) the coa-lesced sum of the boolean constants

T, the integers N, thecontinuous functions from
V to V, the product of V with it-self, the sum of V with itself, and a "type-error" constant

0.

Or alternatively: a "semantic expression" f 2 V is eithera boolean constant, an integer, a function between expressions, a pair of expressions, a left (resp. right) injection ofan expression, the error constant

0, or the least element ?.Second stage: every type is interpreted as an

ideal ofthe domain
V, that is, as a non-empty set I ` V whichis (1) downward closed, and (2) closed under directed limits. Notice that ideals are domains themselves. So, typesare interpreted as domains, just as in mainstream Domain
Theory. There is a major difference, though: these domainsare not only domains, they are also "subdomains" of the domain V. So, subtyping may be interpreted as set-theoreticinclusion. But this has another key consequence. Defined
as the canonical solution of equation (7), the domain V isapproximated by a sequence (

Vn)n2N of domains:

V0 ` V1 ` * * * ` Vn-1 ` Vn ` Vn+1 ` * * * ` V
each of them image of a projection map ssn : V -! Vn.Besides, every element

x 2 V is the least upper bound ofthe directed set {
ssn(x) | n 2 N} of its approximations.This "stratification" of the domain V enables to define a

distance d(I, J) between two ideals I and J as d(I, J) = 0when

I = J, and as d(I, J) = 2-n when I 6= J, for n theleast number such that

ssn(I) 6= ssn(J). MacQueen, Plotkinand Sethi prove that the resulting metric space on ideals is

Cauchy-complete; and deduce that every recursive equation

X = T (X, X)
has a unique solution, as long as the functor T of mixedvariance is contractive with respect to the metric space on
ideals. Remarkably, contractibility holds for a large class offunctors

T , including all our illustrating equations (4), (5)and (6).

Towards operational semantics. The ideal model suffersfrom a serious defect noted in [3] and related to the domaintheoretic definition of V: There exist "semantic expres-sions"

f 2 V which are not defined in the calculus, andmay distort the expected properties of types. This is illustrated by the term:

por - explode = *f. if f(true, \Omega )

and f(\Omega , true)
and not f(false, false)
then 0
else true.

where \Omega  denotes the diverging term \Omega  = (*y.y y) (*y.y y)and

0 denotes the "type-error" constant \Omega .What should be the type of

por - explode? The firstbranch of the
if - then - else is selected only when theinput
f represents the "parallel-or" function (noted por )which returns

true when one of its arguments is true,and
false when its two arguments are false. Now, the

2

function por 2 V is a "semantic expression" which can-not be represented syntactically in the

*-calculus, or in anysequential language. So, the term
por - explode returns
true for every term f of type (T * T) ! T in any suchlanguage; and consequently should be typed ((

T * T) !T) ! T there. Unfortunately, this type is not validated

by the ideal model, because the term por - explode inter-preted in

V returns "error" for the "semantic expression"por of type (T * T) ! T.

This example suggests to reject the mediation of DomainTheory, and to recast the ideal model directly inside operational semantics. The project is fascinating conceptually,but difficult to realize technically. As we mentioned earlier, the existence of recursive types in the ideal model isdeduced from the "stratification" of the domain

V, and theexistence of the projection maps
ssn : V ! Vn. Obviously,shifting to operational semantics requires to find an operational counterpart to the "stratification" of the domain V.How and what? This question has attracted considerable
interest in the last decade, leading to a series of major ad-vances in the field [3, 5, 8, 10, 11, 12, 20, 23]. Four solutions
emerged from the period, which we recall briefly now.1. Abadi, Pierce and Plotkin [3] do not alter the domaintheoretic definition of V (and thus keep its "stratification")but restrict the interpretation of types to ideals "generated" (in the order-theoretic sense) by definable elements.Strikingly, the resulting ideal model validates that the term
por - explode has type ((T*T) ! T) ! T. Other syn-tactic variants of the ideal model are considered, obtained
in each case by restricting the interpretation to particularclasses of ideals, e.g. the so-called "abstract" and "coarse"
ideals, see [3] for details. In any of these variants, it is tech-nically crucial that the projection maps

ssn : V ! Vn aredefinable. This requires to enrich the language (an untyped

*-calculus) with a "typecase" operator which tests whethera term

e is a boolean, a natural, a pair, a sum, or a function,and then returns a different result

ei in each case:

cases e bool : e1

nat : e2
pair : e3
sum : e4
fun : e5
end

This idea has been influential and reappears in many laterattacks to connect operational and denotational semantics,

most notably by Smith, Mason, and Talcott [20, 23] andBirkedal and Harper [8]. We should add that the article [3]
is also influential for its last section, where the three authorsdeliver in a visionary style the principle of an ideal model
living inside operational semantics.2. Dami [11, 12] takes up the last idea of [3] and recasts
the ideal model inside operational semantics. Several vari-ants of the

*-calculus are considered, all of them enrichedwith reduction labels inspired from L'evy [18]. These labels provide the "stratification" of the language necessaryto solve recursive equations between types.

3. Chroboczek [10] recasts the ideal model in game se-mantics, by solving an equation similar to (7) in a category of games. The resulting game G is "stratified", andrecursive equations are thus solved inside G by the same
Cauchy-completeness argument as in [19]. Chroboczek ob-serves a mismatch between his original operational semantics (a call-by-name *-calculus), and the interpretation ofthis calculus in the model. He thus designs an adequate language by enriching the original language with a "located"(and in fact "stratified") notion of convergence test.

4. Appel and McAllester [5] develop a radically differentapproach to the problem, in which (in contrast to

1, 2 and3) they do not need to enrich the original language in order

to stratify it. Their language is defined using a small-stepsemantics. This enables them to define intensional types, in
which an information on the number of steps to compute avalue is provided. Remarkably, this extra information is sufficient to approximate the behavior of a term, and to solverecursive equations between types.

Realizability and orthogonality. These operational ap-proaches to recursive types have in common to alter something of the original syntax of the calculus, or to alter some-thing of the original definition of types. Here, we want to
interpret recursive polymorphic types in operational seman-tics, but without "stratifying" the language or the convergence test (as in 1,2,3), and without "intensionalizing" thetyping (as in

4).
This is a difficult task, which requires to design anew stratification principle in order to replace the usual

"language-directed" stratification. A clarifying step is takenin a companion paper [25] where we reformulate the ideal
model in a more conceptual and operational way, inspiredfrom Krivine's

realizability [17, 13].
In a realizability model (`a la Krivine), one starts from anuntyped calculus of terms and contexts, and constitutes a

typed language on top of it. The cornerstone of the theoryis a notion of orthogonality

e ? ss which indicates when aterm
e and a context ss may be safely combined (no error atruntime). Orthogonality induces a closure operator which

associates to every set U of terms the set U ?? of termswhich cannot be separated from

U by a context. This set
U?? is called the biorthogonal of U. Types are interpretedas sets

U = U ?? closed by biorthogonality, also called
truth values. The formal definition appears in Section 3.

Connecting "types" and "orthogonality" is one of thenicest discoveries of "French" proof-theory. The idea

emerged after intense reflection on the reducibility candidates method to prove strong normalization for System F .Girard reformulates these candidates as biorthogonal sets of

terms, in his proof of cut elimination for linear logic [16].

3

The idea reappears in Parigot's proof of Strong Normaliza-tion for second order

*u-calculus [21]. Meanwhile, Krivineformulates a comprehensive framework based on orthogonality, in order to analyze types as specifications of terms.Krivine demonstrates that realizability generalizes Cohen's
forcing and induces models of classical Zermelo-Fraenkelset theory [13, 17].

Parametricity. It should be said that the idea of orthog-onality is not only "French": Andy Pitts discovered it independently in his remarkable work on operational equiva-lence [22] -- see also [1]. We indicate in Section 9 (alas too
briefly for lack of space) how Pitts' operational approach toparametricity may be reflected in a realizability framework.

Type-directed stratification. What about recursivetypes? We are looking for an operational counterpart to
"algebraic compactness" in Domain Theory. This shouldensure (for instance) that the type of lists of booleans and
the type of streams of booleans coincide in the model. Takethe set

U of boolean lists (e1, ..., en) in which each term eiis either

true or false. Any such list is easily encoded ina
*-calculus with pairs. Now, take the term:

e1 = Y (*x.(true, x))
in which Y = *f.(*x.f xx)(*x.f xx) is the Kleene fix-point. The term

e1 implements the infinite stream of true,thus is element of the truth value

V of boolean streams. But
e1 is not an element of U . It is not difficult to see how-ever that

e1 is an element of U ??. Indeed, every context sswhich combines safely with all the boolean lists, combines

safely with all the boolean streams, including e1. We con-clude from this and

U ` V that V = U ??.The equality
U ?? = V captures the essence of coinci-dence, and we shall prove it for every recursive type (Theorem 5). Note that the equality generally fails when orthog-onality amounts to

termination (e ? ss iff e combined to
ss converges) instead of safety. Indeed, there may exist acontext

ss (think of a length function) which terminates onevery list and loops on every stream.

The framework described in [25] is technically enlight-ening, but still based on a "language-directed" stratification technique, which we reject here. We develop insteada "type-directed" stratification technique, in which every
(possibly infinite) type o/ is approximated by finite treescalled

interval types. Each interval type K is interpretedin the model as a triple (

U, V, OEK) where U ` V are truthvalues, and
OEK is a conversion term sending every term
e 2 V to a term OEK e 2 U . These "type-directed" OEKreplace the "language-directed" projections

ssn of the idealmodel. The resulting "type-directed" picture is closer to

Domain Theory, in which the solution of a recursive equa-tion

X = T (X, X) is computed as limit of a categoricaldiagram defined by the type

T .

Related works. As noted earlier, the literature on types ishuge, even if one restricts one's attention to recursive types,
subtyping, or polymorphism. We did our best to give a com-prehensive panorama of the field in the introduction, but it
is obviously too brief, and far from exhaustive, for lack ofspace. The interested reader will find complementary information in the companion paper [25].

Outline. In the remainder of the paper, we introduce acall-by-name calculus (Section 2) for which we formulate
an orthogonality relation between terms and stacks, in thestyle of Krivine (Section 3). This defines a truth value as a
set of terms orthogonal to a set of stacks. Then, we intro-duce our syntax of types and of interval types (Section 4).
We interpret types as truth values in two stages: first, weinterpret

inductively every interval type as a pair of truthvalues, with a conversion term between them (Section 5);

then, we interpret types by approximating them with inter-val types (Section 6). We sketch how to treat intersection
and union types by moving to a nondeterministic language(Section 7). We prove soundness of our interpretation for
a typing system with universal and existential types, andsubtyping (Section 8). Finally, we give a brief account of
parametricity (Section 9) and conclude (Section 10).

2 A simple call-by-name calculus
2.1 The terms

We start from an untyped *-calculus with pairs and con-ditional branch, defined by the syntax below:

e ::= x variable|

*x.e abstraction|
e e application| (

e, e) pair|
fst(e) first projection|
snd(e) second projection|
if e then e else e conditional branch|
true constant true|
false constant false

2.2 The operational semantics

We choose to apply a call-by-name evaluation strategybetween terms, which we describe using a small-step semantics. This is only a matter of choice: all the construc-tions in this paper work also if one starts from a call-byvalue *-calculus. The definition goes in two steps. First, weintroduce a class of evaluation contexts, indicating where a
symbolic transformation may be applied in a term. Then,we specify five rewriting rules, formulated as an interaction
between a term and its evaluation context.

4

Evaluation contexts are finite lists defined by the grammar:

E ::= nil head context|

e * E application|
fst * E first projection|
snd * E second projection| (

if e, e) * E conditional branch

Every term e and evaluation context E may be combined togenerate a term denoted h

e | Ei and defined as follows:

he | nili = eh

e | e0 * Ei = he e0 | Eih
e | fst * Ei = hfst(e) | Eih
e | snd * Ei = hsnd(e) | Eih
e | (if e1, e2) * Ei = hif e then e1 else e2 | Ei

The reduction relation ! is defined as the smallest rela-tion between terms containing any instance of five rewriting

rules: the usual fi-rule:

h*x.e | e0 * Ei ! he[x := e0] | Ei
two rules for the products:h

(e1, e2) | fst * Ei ! he1 | Eih(

e1, e2) | snd * Ei ! he2 | Ei

and two rules for the conditional:h

true | (if e1, e2) * Ei ! he1 | Eih
false | (if e1, e2) * Ei ! he2 | Ei

where e, e0, e1, e2 denote terms and E denotes an evaluationcontext. Observe that the resulting reduction ! is

deter-ministic in the sense that:

8e, e1, e2, e ! e1 and e ! e2 ) e1 = e2.
3 Realizability
3.1 The safe terms

We write !* for the reflexive and transitive closure ofthe relation !, and say that:

* a term e reduces to a term e0 when e !* e0,

* a term e loops when there exists an infinite sequenceof reductions:

e ! e1 ! e2 ! * * *

* a term is safe when it loops, or when it reduces to oneof the two boolean constants

true or false,

* a term is unsafe when it is not safe.
An example of safe term is \Omega , defined as:

\Omega  = (*x.x x) (*x.x x).
An example of unsafe term is 0, defined as:

0 = (true) (true).

3.2 The stacks

The terms of the language will be tested by evaluationcontexts E, as well as by two "constant" contexts \Omega  and

0which we add here for convenience. We call these testing

contexts stacks, and note them ss as in [17, 13].

ss ::= E evaluation context| \Omega  safe

| 0 unsafe
A stack ss is called strict when it is an evaluation context,
safe when ss = \Omega  and unsafe when ss = 0.We extend the definition of h- | Ei to stacks in the expected way. Thus for every term e:

he | \Omega i def= \Omega , he | 0i def= 0.
Similarly, we extend to stacks the constructors defined forevaluation contexts in Section 2.2. This is simply done by
applying the convention below, for any terms e, e1, e2:

e * \Omega  = fst * \Omega  = snd * \Omega  = (if e1, e2) * \Omega  def= \Omega ,
e * 0 = fst * 0 = snd * 0 = (if e1, e2) * 0 def= 0.

3.3 Orthogonality

The orthogonality relation ? between terms and stacksis defined as follows:

e ? ss () the term he | ssi is safe.
Thus, a term e and a stack ss are orthogonal when combiningthem induces a term h

e | ssi which loops, or reduces to oneof the boolean constants

true or false.Some readers will find it unexpected to see terms like

*x.e counted among our unsafe terms. This seems to con-tradict the accepted notion of value in functional programming. Well, not really. The idea is that a term like *x.e isunsafe until it receives an argument

e0 and induces a safeterm (
*x.e) e0. We write this *x.e ? e0 * nil, and note thatobserving boolean constants (and only them) is enough to

characterize types semantically.Note finally that the stack \Omega  is orthogonal to every term,
and that the stack 0 is orthogonal to no term.
3.4 Truth values

A term e is orthogonal to a set of stacks \Pi  when:

8ss 2 \Pi , e ? ss.
In that way, every set of stacks \Pi  defines a set of terms \Pi ?,called the

orthogonal of \Pi :

\Pi ? = {e | 8ss 2 \Pi  : e ? ss}.

5

Conversely, every set of terms \Lambda  defines a set of stacks \Lambda ?,consisting of all the stacks orthogonal to \Lambda :

\Lambda ? = {ss | 8e 2 \Lambda  : e ? ss}.
Taking twice the orthogonal of a set of terms \Lambda  induces a setof terms \Lambda ?? called the

biorthogonal of \Lambda . This operation(\Lambda  7! \Lambda ??) defines a closure operator in the lattice of sets

of terms, ordered by inclusion. In particular, \Lambda  ` \Lambda ??.A truth value

U is a set of terms closed by biorthogonal-ity, that is, satisfying

U = U ??. Note that the orthogonal\Pi ? to a given set of stacks \Pi  is always a truth value, and

that truth values are closed under (arbitrary) intersection.
3.5 Two constructions on truth values

Suppose that U and V are two truth values. We definethe truth values

U ) V and U * V as follows.

The arrow construction. The truth value U ) V is de-fined as the set of terms orthogonal to the stacks

e * ss where
e 2 U and ss is a stack orthogonal to V .

Lemma 1 For every truth values U, V and term e, the following facts are equivalent :

1. e 2 U ) V ;2. 8

e0 2 U, e e0 2 V .

The product construction. The truth value U * V is de-fined as the set of terms orthogonal to the stacks

fst * sswhere
ss is a stack orthogonal to U , and snd * ss where ss isa stack orthogonal to

V .

Lemma 2 A term is element of U * V iff the term loops, orreduces to a pair (

e, e0) where e 2 U and e0 2 V .

4 Types
4.1 Syntax of types

Types are defined in two steps. First, finite patterns(called

type patterns) are defined inductively. Then, thesepatterns are assembled coinductively into possibly infinite

trees (called types). This two-step construction rules out ill-defined types, such as

o/ = 8ff.o/ , in that case because 8ff.o/is not a pattern. Indeed, any occurrence of a type in a pattern

is below a constructor ! or *.We assume given a set of type variables

ff and a singletype constant Bool . Given a set of types
o/ , we define typepatterns
t inductively by the grammar below.

t ::= Bool boolean type|

o/ * o/ pair type|
o/ ! o/ function type|
ff type variable| ? top type

| 8ff.t universal quantification| ? bottom type
| 9ff.t existential quantification

The different type constructions are standard. See Sec-tions 5 and 6 for a precise description of their meaning.

We write t(o/1, . . . , o/k) when the pattern t has leaves o/1,. . . ,

o/k, where each o/i occurs linearly in t. The finite pat-terns

t are assembled coinductively as follows:

o/ ::= t(o/1, . . . , o/k) coinductively.
By coinduction, every type o/ is of the form t(o/1, . . . , o/k).So, we can reason inductively on the structure of type patterns, then coinductively on the structure of types. Thisturns out to be very convenient. Besides, all the constructions !, *, . . . , on type patterns define constructions ontypes in the obvious way. This enables to write types like
o/1 ! o/2, o/1 * o/2 or 8ff.o/ .Types are considered modulo renaming of their bound
variables. This does not contradict the coinductive defini-tion of types on the alphabet of patterns since, in fact,

ff-conversion is only a handy presentation of de Bruijn indices.

Note also that we don't assume types to be regular: typesmay have an infinite number of distinct subtrees.

Remark: the sum types are not treated for lack of space only.They are very easily integrated in the framework by extending the language of terms with three operators inl(e),
inr(e), caseof(e, e1, e2), and the language of evaluationcontexts with one operator (

case e1, e2) * E, with the fol-lowing equation:

he | (case e1, e2) * Ei = hcaseof(e, e1, e2) | Ei
and the two additional rewriting rules:

hinl(e) | (case e1, e2) * Ei ! he1 e | Eih

inr(e) | (case e1, e2) * Ei ! he2 e | Ei

4.2 Syntax of interval types

In contrast to types, which may be infinite, interval typesare finite trees, defined inductively by the grammar below.

K ::= Bool boolean type|

K * K pair type|
K ! K function type|
ff type variable| ? top type

| 8ff.K universal quantification| ? bottom type
| 9ff.K existential quantification| [?

, ?] interval

In Section 6, we will use these interval types to "approx-imate" types, in order to interpret them. Accordingly, the

type constructions are the same as for types. The only nov-elty is the interval type [?

, ?], which will be interpreted inthe next section (Section 5) as the largest possible "interval", bounded by the smallest and largest nonempty truthvalues.

6

4.3 Types approximated by interval types

We say that an interval type K approximates a type o/ ,which we write as

K v o/ , when the type o/ may be obtainedsyntactically by replacing every leaf labelled [?

, ?] in K bya type. For instance:

8ff.8fi.[?, ?] ) [?, ?] v 8ff.8fi.ff ) (ff ) fi).
5 Interpretation of interval types
5.1 Adjunction

Let OE be a term and  be a function on stacks. One saysthat

 is the adjoint of OE when, for every term e and stack ss:

OE e ? ss () e ?  ss.
Note that the adjoint  is characterized by OE modulo ob-servational equivalence, in the sense that if

0 is anotheradjoint of
OE, then, for every stack ss:

{ ss}? = {0 ss}?.
This enables to use the notation OE* for the adjoint .
5.2 Semantic intervals

A semantic interval is a triple (U, V, OE) consisting of twononempty truth values

U and V satisfying U ` V , and aterm
OE 2 V ) U having an adjoint OE*. We generally notesemantic intervals as follows:

U OE- V.
The term OE is called the conversion of the semantic interval.Recall from Section 3 that

OE 2 V ) U means that:

8e 2 V, OE e 2 U.
Lemma 3 The function OE* sends every stack ss 2 U ? to a
stack OE*ss 2 V ?.

Remark: The adjoint OE? is here to take full advantage ofthe duality between terms and stacks, saying that every existential type on terms is at the same time a universal typeon

stacks. Or similarly, that every union type on terms (seeSection 7) is at the same time an intersection type on stacks.

This dual perspective is crucial, we believe, to interpret ex-istential and union types in the presence of recursive types
(without any recourse to a "language-based" stratification).
5.3 Interpretation of interval types

We call semantic environment ae any function from typevariables to truth values. To any such environment

ae and in-terval type
K we define a semantic interval [[K]]ae by struc-tural induction on

K. So, all along the section, we supposegiven two interval types

K and K0 interpreted as:

[[K]]ae = U OE- V, [[K0]]ae = U 0 - V 0.

One needs to prove for each construction that the interpre-tation defines a semantic interval -- which is not really difficult.
Arrow type: [[K ! K0]]ae = V ) U 0 OE)- U ) V 0where

OE )  = *x.( ffi x ffi OE) = *x.*y. (x (OE y)).

Product type: [[K * K0]]ae = U * U 0 OE*- V * V 0where

OE *  = *x.(OE fst(x),  snd(x)).

Boolean type: [[Bool ]]ae = W *x.x- Wwhere

W is the biorthogonal of the set {true, false}.

Bottom: [[?]]ae = W *x.x- Wwhere

W is the smallest nonempty truth value, alternativelythe set of looping terms, or the biorthogonal of the singleton

{\Omega }.
Top: [[?]]ae = W *x.x- Wwhere

W is the largest truth value, that is, the set of allterms, or alternatively, the set of all terms orthogonal to the

stack \Omega .
Type variable: [[ff]]ae = W *x.x- Wwhere

W is the truth value associated to the type variable ffby the environment

ae.

Universal type: [[8ff.K]]ae = U OE- Vwhere

U (resp. V ) is the intersection of all truth values UT

(resp. VT ) such that [[K]]ae,(ff7!T ) = UT OE

T- VT for T

ranging over truth values. As usual, [[K]]ae,(ff7!T ) denotesthe interpretation of

K in the environment ae in which thetype variable
ff is assigned to T . The term OE is defined byshowing that
OET = OET 0 for any truth values T and T 0, andthen taking
OE = OET for any truth value T .

Existential type: [[9ff.K]]ae = U OE- Vwhere

U (resp. V ) is the biorthogonal of the union ofall truth values

UT (resp. VT ) such that [[K]]ae,(ff7!T ) =

UT OE

T- VT for T ranging over truth values. The term OE

is defined by showing that OET = OET 0 for any truth values Tand

T 0, and then taking OE = OET for any truth value T .

Interval type: [[[?, ?]]]ae = U \Omega - Vwhere

U (resp. V ) is the smallest (resp. largest) nonemptytruth value. Note that the term \Omega  transports every term

e 2
V to the looping term \Omega  e 2 U .

6 Interpretation of types

Here comes the crux of the paper: we show that every(possibly infinite) type

o/ generates a converging sequence

7

of interval types, the limit of which defines the interpreta-tion of

o/ in the model. The proof is based on a simula-tion lemma (lemma 4) showing that, under some appropriate conditions, the conversion terms OEK associated to oursemantic intervals behave like

j-conversions or reductionlabels in the
*-calculus [18].

6.1 Term expansion

A term e0 obtained from a term e by inserting conversionterms

OEK is called an expansion of e. We write this e ; e0.This may be formalized by structural induction on the term:

e ; e e ; e

0

e ; OEK e0

e ; e0
*x.e ; *x.e0

e1 ; e01 e2 ; e02

e1 e2 ; e01 e02

e1 ; e01 e2 ; e02

(e1, e2) ; (e01, e02)

e ; e0
fst(e) ; fst(e0)

e ; e0
snd(e) ; snd(e0)

e1 ; e01 e2 ; e02 e3 ; e03
if e1 then e2 else e3 ; if e01 then e02 else e03

where OEK indexed by the interval type K denotes the con-version of any semantic interval [[

K]]ae, for ae an arbitrarysemantic environment.

The depth of an interval type K is defined by structuralinduction:

kK * K0k = kK ! K0k = 1 + min(kKk, kK0k)k

ffk = kBoolk = +1k?k

= k?k = +1k8
ff.Kk = k9ff.Kk = kKkk
[?, ?]k = 0

We speak of an expansion of depth k when all the OEK in-troduced by expansion are indexed by interval types

K ofdepth greater or equal to
k. In that case, we write e ;k e0.

6.2 The simulation lemma
Lemma 4 (simulation) For every pair of terms (e, e0) suchthat

e !* e0, there exists an integer p such that whenever
e ;p+k f for a safe term f and integer k, there exists aterm

f0 satisfying f !* f 0 and e0 ;k f 0.

6.3 Interpretation of types

Let ae denote a semantic environment. Every type o/ de-fines a set of approximating interval types

K v o/ , each ofthem interpreted as a semantic interval

[[K]]ae = UK OE

K- VK.

We define U1 def= SKvo/ UK and V1 def= TKvo/ VK. Ob-viously,

U1 ` V1 because UK ` VK for every K v o/ .

We deduce that V1 coincides with the biorthogonal of U1(theorem 5) from the property:

8e 2 V1, 8ss 2 U ?1, e ? ss.
Theorem 5 (coincidence) V1 = U ??1 .
We therefore interpret the type o/ in the environment ae as[[

o/ ]]ae = V1 = U ??1 . Note that the definition ensures sub-stitution properties like [[

o/ ]]ae+(ff7![[o/0]]ae) = [[o/ [ff := o/ 0]]]ae forevery types
o/ and o/0, and type variable ff.

7 Intersection and Union

We indicate briefly how we interpret union and intersec-tion types in the presence of recursive types, see also [24].

The first step is to define two constructs ^ (intersection) and. (union) on truth values

U, V , just in the expected way:

U ^ V = U " V, U . V = (U [ V )??.
Our proof technique in Sections 5 and 6 requires to definethe conversions

OE ^  and OE .  associated to the constructs^ and . on interval types. We believe that this not possible in the operational model based on the call-by-name
*-calculus defined in Section 2. But this may be achievedby enriching the language with an "error-avoiding" nondeterministic choice operator k, with the additional rules:

he1ke2 | Ei ! he1 | Ei he1ke2 | Ei ! he2 | Ei
with E an evaluation context in the sense of Section 2.2.The conversions

OE ^  and OE .  may then be defined asthe term
OEk. The existence of an adjoint for the term OEkrequires to extend our class of stacks with an operator k,

building stacks ss1kss2 with the obvious action on terms:

he | ss1kss2i = he | ss1i k he | ss2i
We clarify now the orthogonality relation ? associated tothis non-deterministic calculus. A term is called safe when

it may loop, or may reduce to true or false. A term e isorthogonal to a stack

ss when he | ssi is safe. For instance,the term
e = true k *x.x is orthogonal to the stack ss =
0 k (true * nil) because the term he | ssi reduces to theconstant

true. It is not difficult to see then that the adjointof
OEk is the function which associates to every stack ss thestack

OE*ssk*ss, where OE* (resp. *) denotes the adjoint ofthe term

OE (resp. ).

8 Typing judgement

In order to demonstrate the power of our semantic anal-ysis, we deliver a series of typing rules (figure 1) for the

untyped calculus of Section 2, and prove that these rules aresound. We take the usual notions of typing environment \Gamma 

8

VAR-ACCESS

\Gamma (x) = o/

\Gamma  ` x : o/

APP

\Gamma  ` e1 : o/2 ! o/1

\Gamma  ` e2 : o/2

\Gamma  ` e1 e2 : o/1

ABS

\Gamma , x : o/2 ` e : o/1

\Gamma  ` *x.e : o/2 ! o/1

PAIR

\Gamma  ` e1 : o/1 \Gamma  ` e2 : o/2

\Gamma  ` (e1, e2) : o/1 * o/2

FST

\Gamma  ` e : o/1 * o/2

\Gamma  ` fst(e) : o/1

SND

\Gamma  ` e : o/1 * o/2

\Gamma  ` snd(e) : o/2

CONSTANT TRUE
\Gamma  ` true : Bool C

ONSTANT FALSE
\Gamma  ` false : Bool

CONDITIONAL

\Gamma  ` e1 : Bool

\Gamma  ` e2 : o/ \Gamma  ` e3 : o/

\Gamma  ` if e1 then e2 else e3 : o/

FIXPOINT

\Gamma  ` e : o/ ! o/

\Gamma  ` Y e : o/

ALL-INTRO

\Gamma , ff ` e : o/

\Gamma  ` e : 8ff.o/

ALL-ELIM

\Gamma  ` e : 8ff.o/

\Gamma  ` e : o/[o/0/ff]

EXISTS-INTRO

\Gamma  ` e : o/[o/0/ff]

\Gamma  ` e : 9ff.o/

EXISTS-ELIM

\Gamma  ` e : 9ff.o/0

\Gamma , ff, x : o/0 ` hx | Ei : o/
ff 62 FV(o/) x 62 FV(E)

\Gamma  ` he | Ei : o/

SUB

\Gamma  ` e : o/0 o/0 <: o/

\Gamma  ` e : o/

Figure 1. Typing rules

and of typing judgement \Gamma  ` e : o/ , and refer to [25] for for-mal definitions. Our typing rules are also canonical, except
for the elimination rule of the existential, which is inspiredfrom [14]. We write \Gamma (

x) for the type of the variable x inthe environment \Gamma , and FV for the set of free variables of a

type or an evaluation context.The typing system depends on a subtyping relation

<:between types, which appears in the Sub rule. The only

hypothesis that we make on the relation <: is that for everytwo types

o/, o/ 0 such that o/ <: o/0, and for every semanticenvironment

ae, we have the inclusion [[o/ ]]ae ` [[o/ 0]]ae. This issufficient to establish that the typing system is sound:

Theorem 6 (Soundness) ` e : o/ implies e 2 [[o/ ]].
This establishes that every closed term of type Bool is safe.

9 Parametricity and typed realizability

We explain briefly how realizability may be adapted toaccount for logical relations and parametricity. Following [2, 6, 9, 7, 22] among a few others, we would like tointerpret types as saturated relations. A saturated relation
(,1, r, ,2) over the set of terms \Lambda  consists of a binary rela-tion

r ` \Lambda 2 and two partial equivalence relations (pers) ,1and ,

2 over \Lambda , such that:8

(a, b, c, d) 2 \Lambda 4, a ,1 b and b r c and c ,2 d ) a r d.
We find useful to express every saturated relation(,

1, r, ,2) as the following set of quadruples:

R = {(a, b, c, d) 2 \Lambda 4, a ,1 b, b r c and c ,2 d}.

We define an orthogonality relation ?sat between quadru-ples of terms and stacks of our deterministic language of

Section 2, by writing (e1, e2, e3, e4) ?sat (ss1, ss2, ss3, ss4)precisely when

he1 | ss1i =safe he1 | ss2i =safe he2 | ss1i =safe he2 | ss2ih

e3 | ss3i =safe he3 | ss4i =safe he4 | ss3i =safe he4 | ss4ih

e2 | ss2i =safe he3 | ss3i

where e =safe e0 means that (1) the terms e and e0 are safeand (2a) either

e and e0 reduce to the same boolean constant,or (2b) both
e and e0 loop. A key observation follows:

Lemma 7 (Saturation) Every biorthogonal set of quadruples of terms is a saturated relation R.

It is then easy to construct a realizability model of recursivetypes based on

biorthogonal relations instead of truth val-ues. The operators ) and * are adapted to biorthogonal

relations. That is, R ) S denotes the set of quadruples or-thogonal to every quadruple (

e1 * ss1, e2 * ss2, e3 * ss3, e4 * ss4)where (
e1, e2, e3, e4) 2 R and (ss1, ss2, ss3, ss4) 2 S?. Sim-ilarly for the product

R * S of two biorthogonal relations.Then, one interprets recursive types by approximating

them by interval types, in the lines of Sections 5 and 6. Thisdefines a biorthogonal relation [[[

o/ ]]]ae for every type o/ andsemantic environment
ae from type variables to biorthogo-nal relations. Now, suppose that the subtyping relation

<:verifies that for every two types
o/ <: o/ 0, and for every se-mantic environment
ae, we have the inclusion [[[o/ ]]]ae ` [[[o/0]]]ae.We prove that:

Theorem 8 (Soundness) ` e : o/ implies (e, e, e, e) 2 [[[o/ ]]].
Consider two closed terms e1 and e2 typed as ` e1 : o/and `

e2 : o/ in our typing system. We say that the terms
e1, e2 are parametrically equivalent (noted e1\Delta o/ e2) when(

e1, e1, e2, e2) 2 [[[o/ ]]]. And that they are contextually equiv-alent (noted

e1 ,o/ctx e2) when e e1 =safe e e2 for everyclosed term
e typed as ` e : o/ ! Bool in our typing sys-tem. We prove that for every type

o/ :

Lemma 9 (in untyped realizability) \Delta o/ ` ,o/ctx.
This indicates that there are more parametricity tests in theuntyped realizability universe, than in the typed syntax. To

obtain equality of \Delta o/ and ,o/ctx, we thus need to shift to atyped setting, in which only typed terms and stacks (`a la

9

Church) are considered. The orthogonality relation e ? ssholds when the term h

e | ssi is well-typed and safe. The def-inition of \Delta 
o/ is immediately adapted to this typed setting.

We establish in this way the key property stated by Pitts forhis PolyPCF (theorem 4.15 [22]), reformulated in our polymorphic typing system with subtyping and recursive types.
Theorem 10 (in typed realizability) \Delta o/ = ,o/ctx .

10 Conclusion and future works

We have shown how recursive polymorphic types, aswell as subtyping, may be interpreted operationally without

altering the original syntax of the *-calculus. We have alsoindicated how parametricity may be integrated smoothly in
the framework. It will be interesting to see in future workhow the methodology scales up to languages with effects,
and to process calculi.
References

[1] M. Abadi. top-top-closed relations and admissibility. Mathematical Structures in Computer Science, 10(3):313-320,
2000.[2] M. Abadi, P.-L. Curien, and G. Plotkin. Formal parametric polymorphism. Theoretic Computer Science, 121(1 and
2):9-58, 1993.[3] M. Abadi, B. Pierce, and G. Plotkin. Faithful ideal models for recursive polymorphic types. International Journal
of Foundations of Computer Science, 2(1):1-21, Mar. 1991.
Summary in Fourth Annual Symposium on Logic in Computer Science, June, 1989.[4] S. Abramsky and A. Jung. Domain theory. In S. Abramsky,

D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of
Logic in Computer Science, volume 3, pages 1-168. Clarendon Press, 1994.[5] A. W. Appel and D. McAllester. An indexed model

of recursive types for foundational proof-carrying code.
ACM Transactions on Programming Languages and Systems (TOPLAS), 23(5):657-683, 2001.[6] E. S. Bainbridge, P. J. Freyd, A. Scedrov, and P. J. Scott.

Functorial polymorphism. In G. Huet, editor, Logical
Foundations of Functional Programming, pages 315-330.
Addison-Wesley, Reading, MA, 1990.[7] R. Bellucci, M. Abadi, and P.-L. Curien. A model for formal parametric polymorphism: A per interpretation for system r. In M. Dezani-Ciancaglini and G. Plotkin, editors,
Typed Lambda Calculi and Applications: Proc. of the 2nd
International Conference on Typed Lambda Calculi and Applications, pages 32-46. Springer, Berlin, Heidelberg, 1995.[8] L. Birkedal and R. Harper. Constructing interpretations of

recursives types in an operational setting. Information and
Computation, 155:3-63, 1999.[9] K. Bruce and J. C. Mitchell. Per models of subtyping, recursive types and higher-order polymorphism. In POPL '92:
Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 316-
327, New York, NY, USA, 1992. ACM Press.

[10] J. Chroboczek. Games semantics and subtyping. PhD thesis and LFCS report ECS-LFCS-03-432, University of Edinburgh, Great Britain, 2003.[11] L. Dami. Labelled reductions, runtime errors and operational subsumption. In P. Degano, R. Gorrieri, and
A. Marchetti-Spaccamela, editors, ICALP, volume 1256
of Lecture Notes in Computer Science, pages 782-793.
Springer, 1997.[12] L. Dami. Operational subsumption, an ideal model of subtyping. In A. D. Gordon, A. M. Pitts, and C. Talcott, editors,
Second Workshop on Higher-Order Operational Techniques
in Semantics, volume 10 of Electronic Notes in Theoretical
Computer Science. Elsevier Science Publishers, 2000.[13] V. Danos and J.-L. Krivine. Disjunctive tautologies and synchronisation schemes. In Computer Science Logic'00, volume 1862 of Lecture Notes in Computer Science, pages 292-
301. Springer, 2000.[14] J. Dunfield and F. Pfenning. Type assignment for intersections and unions in call-by-value languages. In Proc. 6th International Conference on Foundations of Software Science
and Computation Structures (FOSSACS'03), Lecture Notes
in Computer Science. Springer-Verlag, 2003.[15] P. J. Freyd. Algebraically complete categories. In A. Carboni, M. C. Pedicchio, and G. Rosolini, editors, Proceedings of the 1990 Como Category Theory Conference, volume 1488 of Lecture Notes in Mathematics, pages 131-156.
Springer-Verlag, 1991.[16] J.-Y. Girard. Linear logic. Theoretical Computer Science,

50:1-102, 1987.[17] J.-L. Krivine. Typed lambda-calculus in classical zermelofraenkel set theory. Archive of Mathematical Logic,
40(3):189-205, 2001.[18] J.-J. L'evy. An algebraic interpretation of the lambda beta Kcalculus; and an application of a labelled lambda-calculus.
Theoretical Computer Science, 2(1):97-114, June 1976.[19] D. MacQueen, G. Plotkin, and R. Sethi. An ideal model

for recursive polymorphic types. Information and Control,
71(1-2):95-130, 1986.[20] I. A. Mason, S. F. Smith, and C. L. Talcott. From operational

semantics to domain theory. Information and Computation,
128(1):26-47, 1996.[21] M. Parigot. Strong normalization for second order classical

natural deduction. In 8th Annual IEEE Symposium on Logic
in Computer Science, pages 39-46, Montreal, Canada, June
1993. IEEE Computer Society Press.[22] A. M. Pitts. Parametric polymorphism and operational

equivalence. Mathematical Structures in computer Science,
10:321-359, 2000.[23] S. F. Smith. The coverage of operational semantics. In A. D.

Gordon and A. M. Pitts, editors, Higher Order Operational
Techniques in Semantics, Publications of the Newton Institute, pages 307-346. Cambridge University Press, 1998.[24] J. Vouillon. Subtyping union types. In J. Marcinkowski and

A. Tarlecki, editors, 18th International Workshop CSL 2004,
volume 3210 of Lecture Notes in Computer Science, pages
415-429. Springer-Verlag, September 2004.[25] J. Vouillon and P.-A. Melli`es. Semantic types: A fresh look

at the ideal model for types. In Proceedings of the 31th
ACM Conference on Principles of Programming Languages,
pages 52-63, Venezia, Italia, Jan. 2004. ACM Press.

10

Appendix
Proofs of section 5
Arrow type. We prove that

V ) U0 OE)- U ) V 0
defines a semantic interval.Conversion : We prove first that

(OE ) ) 2 (U ) V 0) ) (V ) U 0). (8)
Suppose that e 2 U ) V 0. We want to prove that (OE )
) e 2 V ) U 0. It is enough to prove that (OE ) ) e isorthogonal to every stack

ss0 = e0 * ss where e0 2 V and ss isorthogonal to
U 0. By hypothesis, U 0 is nonempty; thus, ss isnot the unsafe stack

0. On the other hand, the case when ssis the safe stack \Omega  is immediate. There remains to treat the

case when ss is an evaluation context E. In that case,

h(OE ) ) e | ss0i = h*x.*y. (x (OE y)) | e * e0 * Ei! h

*y. (e (OE y)) | e0 * Ei! h
 (e (OE e0)) | Ei

There remains to show that the term  (e (OE e0)) is elementof

U 0. But this is a consequence of lemma 1, and the jointfacts that

OE 2 V ) U , that e 2 U ) V 0 and that  2
V 0 ) U 0. We conclude that (OE ) ) e ? ss0, and thusproperty (8).

Adjoint : We define (OE ) )* and prove that this is indeedthe adjoint of (

OE ) ).

* (OE ) )*ss = ss when ss is the safe stack \Omega . Indeed,in that case, both (

OE ) ) e ? ss and e ? ss, for everyterm
e.

* (OE ) )*ss = OE e * *E when ss = e * E for some term

e and evaluation context E. Indeed, (OE ) ) e0 ? e*Eiff

 (e0 (OE e)) ? E iff e0 (OE e) ? *E iff e0 ? OE e *
*E, for e0 an arbitrary term.

* (OE ) )*ss = 0 otherwise. Indeed, in that case, theterm h(

OE ) ) e | ssi is easily shown to be unsafe.

Product type. We prove that

[[K * K0]] = U * U0 OE*- V * V 0
defines a semantic interval.Conversion : We prove first that

(OE * ) 2 (V * V 0) ) (U * U 0). (9)
Suppose that e 2 V *V 0. We want to prove that (OE*) e 2
U *U 0. This means proving that (OE *) e is (1) orthogonalto every stack

fst * ss where ss is orthogonal to V , and also

(2) orthogonal to every stack snd*ss0 where ss0 is orthogonalto

V 0. We only show point (1), since point (2) is proved ina similar fashion. By hypothesis,

V is is nonempty; thus, ssis the unsafe stack
0. On the other hand, the case when ssis the safe stack \Omega  is immediate. There remains to treat the

case when ss is an evaluation context E. In that case,

h(OE * ) e | fst * Ei =h

*x.(OE fst(x),  snd(x)) | e * fst * Ei !h(

OE fst(e),  snd(e)) | fst * Ei !h
OE fst(e) | Ei

Now, hOE fst(e) | Ei is safe iff OE fst(e) ? E iff fst(e) ?
OE*E iff e ? fst * OE*E. Now, the stack OE*E is orthogonalto

U , and e is element of V * V 0. From this and definitionof

V * V 0 follows that e is orthogonal to fst * OE*E. Weconclude that h

OE fst(e) | Ei is safe, and thus that (OE *
) e ? fst*E. As we said, point (2) is established similarly.We conclude that (

OE * ) e 2 U * U 0.Adjoint :
We define (OE * )* and prove that this is indeedthe adjoint of (

OE * ).

* (OE * )*ss = ss when ss is the safe stack \Omega . Indeed,in that case, both (

OE * ) e ? ss and e ? ss, for everyterm
e.

* (OE * )*ss = fst * OE*E when ss = fst * E for someevaluation context E. Indeed, (

OE * ) e0 ? fst * E iff
OE fst(e) ? E iff e ? fst * OE*E, for every term e.

* similarly, (OE * )*ss = snd * OE*E when ss = snd * Efor some evaluation context E.

* (OE * )*ss = 0 otherwise. Indeed, in that case, theterm h(

OE * ) e | ssi is easily shown to be unsafe.

Boolean type, bottom, top, type variable. In each case,the term

*x.x is element of W ) W and has the identityfunction on stacks as adjoint (

*x.x)*.

Universal type. We prove that

[[8ff.K]]ae = U OE- V
defines a semantic interval. By definition, the term OE isequal to the term

OET for any truth value T . Consequently,the term
OE has an adjoint OE* = OET .Conversion : There remains to prove that

OE 2 V ) U.
Suppose that e is a term in V , and that ss is a stack orthogo-nal to

U . Suppose that T is a truth value. Then, the term eis element of

VT . Thus, the term OE e is element of UT . Thisis true for every truth value

T . Thus, the term OE e is elementof
V , for every term e 2 V . We conclude that OE 2 V ) U .

11

Existential type. We prove that

[[8ff.K]]ae = U OE- V
defines a semantic interval. By definition, the term OE isequal to the term

OET for any truth value T . Consequently,the term
OE has an adjoint OE* = OET .
Conversion: There remains to prove that

OE 2 V ) U.
Suppose that e is a term in V , and that ss is a stack orthog-onal to

U . Suppose that T is a truth value. Then, the stack
ss is orthogonal to UT . Thus, the stack OE*ss is orthogonalto

VT . This is true for every truth value T . Thus, the stack
OE* ss is orthogonal to V . In particular, e ? OE* ss. It fol-lows immediately that

OE e ? ss. This is true for every term
e element of V and for every stack ss orthogonal to U. Weconclude that

OE 2 V ) U .

Interval type. The definition works because the term \Omega  eis element of

U for every term e element of V (that is: forevery term). Besides, the term \Omega  has an adjoint \Omega *, which

transports every stack ss to the safe stack \Omega .
Proofs of Section 6.2 and Section 6.3 (sketched)
Lemma 4 (simulation) For every pair of terms (e, e0) such
that e !* e0, there exists an integer p such that whenever
e ;p+k f for a safe term f and integer k, there exists aterm

f0 satisfying:

f !* f 0 and e0 ;k f 0.

Proof: (sketch) The general idea is that expanding a term
e to a term f with a conversion OEK either induces an errorin

f, or behaves just like an j-expansion. Typically,

hOEK2)K1 (e) | e0 * Ei !* hOEK1 (e (OEK2 e0)) | Ei.
One important point is that no conversion \Omega  associated tothe interval type [?

, ?] applies inside the reduction f !*
f 0. This would break the simulation. For that reason, werequire an expansion depth

e ;p+k f larger than the prod-uct
p of the length of the shortest reduction e !* e0, andof the maximum length of an evaluation context involved

in the reduction. The length of an evaluation context is thenumber of application nodes

e * E in its definition. \Xi 

Theorem 5 (coincidence) V1 = U ??1 .

Proof: (sketch) We deduce that U1 ` V1, from the factthat

UK ` VK for every interval type K v o/ . The truthvalue

V1 which contains U1 contains also its biorthogo-nal
U ??1 . This establishes that U ??1 ` V1. We prove theconverse inclusion

V1 ` U ??1 , which may be reformulatedas the statement below:

8e 2 V1, 8ss 2 U ?1, e ? ss.
The orthogonal of U1 is given by an intersection:

U ?1 = "

Kvo/

U ?K

So, every stack ss 2 U ?1 is orthogonal to UK, and everyelement

e 2 V1 is transported to a term OEK e 2 UK, for
K v o/ . We conclude that

8K v o/, OEK e ? ss. (10)
We claim that this implies that e ? ss. This is immediatewhen

ss is one of the stacks \Omega  or 0. We proceed by con-tradiction when the stack

ss = E is strict (= an evaluationcontext). Suppose that the term h

e | Ei is unsafe. Thismeans that h
e | Ei ! e0 to a term e0 which cannot be fur-ther reduced by !, but which is neither the constant

truenor the constant
false. By lemma 4, we may choose aninteger
p such that, for every K of depth p + k, the term
f = hOEK e | Ei reduces to a term f 0 such that e0 ;k f0.It is not difficult to see that, if

k is chosen larger than thelength of any evaluation context in

e0, then the term f0 isjust as unsafe as
e0. We conclude that hOEK e | Ei is unsafe,or equivalently that

OEK e is not orthogonal to E, and thusreach a contradiction with (10). We conclude that

e ? ss. \Xi 

12