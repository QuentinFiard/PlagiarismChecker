

Refinement Types for Secure Implementations
Jesper Bengtson

Uppsala University Karthikeyan BhargavanMicrosoft Research C'edric FournetMicrosoft Research Andrew D. GordonMicrosoft Research

Sergio Maffeis
Imperial College London and University of California at Santa Cruz

Abstract
We present the design and implementation of a typechecker for
verifying security properties of the source code of cryptographic
protocols and access control mechanisms. The underlying type
theory is a l -calculus equipped with refinement types for expressing pre- and post-conditions within first-order logic. We derive
formal cryptographic primitives and represent active adversaries
within the type theory. Well-typed programs enjoy assertion-based
security properties, with respect to a realistic threat model including key compromise. The implementation amounts to an enhanced
typechecker for the general purpose functional language F#; typechecking generates verification conditions that are passed to an
SMT solver. We describe a series of checked examples. This is
the first tool to verify authentication properties of cryptographic
protocols by typechecking their source code.

1 Introduction

The goal of this work is to verify the security of imple-mentation code by typing. Here we are concerned particularly with authentication and authorization properties.We develop an extended typechecker for code written
in F# (a variant of ML) [Syme et al., 2007] and annotatedwith refinement types that embed logical formulas. We use
these dependent types to specify access-control and crypto-graphic properties, as well as desired security goals. Typechecking then ensures that the code is secure.We evaluate our approach on code implementing authorization decisions and on reference implementations of se-curity protocols. Our typechecker verifies security properties for a realistic threat model that includes a symbolic at-tacker, in the style of Dolev and Yao [1983], who is able
to create arbitrarily many principals, create arbitrarily manyinstances of each protocol roles, send and receive network
traffic, and compromise arbitrarily many principals.
Verifying Cryptographic Implementations In earlierwork, Bhargavan et al. [2007] advocate the cryptographic

verification of reference implementations of protocols,rather than their handwritten models, in order to minimize the gap between executable and verified code. They

automatically extract models from F# code and, afterapplying various program transformations, pass them to
ProVerif, a cryptographic analyzer [Blanchet, 2001, Abadiand Blanchet, 2005]. Their approach yields verified security for very detailed models, but also demands considerablecare in programming, in order to control the complexity of
global cryptographic analysis for giant protocols. Even ifProVerif scales up remarkably well in practice, beyond a
few message exchanges, or a few hundred lines of F#, veri-fication becomes long (up to a few days) and unpredictable
(with trivial code changes leading to divergence).
Cryptographic Verification meets Program VerificationIn parallel with specialist tools for cryptography, verification tools in general are also making rapid progress, andcan deal with much larger programs [see for example Flanagan et al., 2002, Filli^atre, 2003, Barnett et al., 2005, Pot-tier and R'egis-Gianas, 2007]. To verify the security of
programs with some cryptography, we would like to com-bine both kinds of tools. However, this integration is delicate: the underlying assumptions of cryptographic mod-els to account for active adversaries typically differ from
those made for general-purpose program verification. Onthe other hand, modern applications involve a large amount
of (non-cryptographic) code and extensive libraries, some-times already verified; we'd rather benefit from this effort.

Authorization by Typing Logic is now a well establishedtool for expressing and reasoning about authorization policies. Although many systems rely on dynamic authorizationengines that evaluate logical queries against local stores of
facts and rules, it is sometimes possible to enforce policiesstatically. Thus, Fournet et al. [2007a,b] treat policy enforcement as a type discipline; they develop their approachfor typed pi calculi, supplemented with cryptographic primitives. Relying on a "says" modality in the logic, they alsoaccount for partial trust (in logic specification) in the face of
partial compromise (in their implementations). The presentwork is an attempt to develop, apply, and evaluate this approach for a general-purpose programming language.

Outline of the Implementation Our prototype tool takesas input module interfaces (similar to F# module interfaces
but with extended types) and module implementations (inplain F#). It typechecks implementations against interfaces,
and also generates plain F# interfaces by erasure. Using theF# compiler, generated interfaces and verified implementations can then be compiled as usual.

Our tool performs typechecking and partial type infer-ence, relying on an external theorem prover for discharging

the logical conditions generated by typing. We currently useplain first-order logic (rather than an authorization-specific
logic) and delegate its proofs to Z3 [de Moura and Bjo/rner,2008], a solver for Satisfiability Modulo Theories (SMT).
Thus, in comparison with previous work, we still rely on anexternal prover, but this prover is being developed for general program verification, not for cryptography; also, we usethis prover locally, to discharge proof obligations at various
program locations, rather than rely on a global translationto a cryptographic model.

Reflecting our assumptions on cryptography and othersystem libraries, some modules have two implementations:
a symbolic implementation used for extended typing andsymbolic execution, and a concrete implementation used
for plain typing and distributed execution. We have ac-cess to a collection of F# test programs already analyzed using dual implementations of cryptography [Bhargavan et al.,2007], so we can compare our new approach to prior work
on model extraction to ProVerif. Unlike ProVerif, type-checking requires annotations that include pre- and postconditions. On the other hand, these annotations can ex-press general authorization policies, and their use makes
typechecking more compositional and predictable than theglobal analysis performed by ProVerif. Moreover, typechecking succeeds even on code involving recursion andcomplex data structures.

Outline of the Theory We justify our extended type-checker by developing a formal type theory for a core of F#:
a concurrent call-by-value l -calculus.

To represent pre- and post-conditions, our calculus hasstandard dependent types and pairs, and a form of refinement types [Freeman and Pfenning, 1991, Xi and Pfenning,1999]. A

refinement type takes the form {x : T | C}; avalue
M of this type is a value of type T such that the for-mula C{M

/x} holds. (Another name for the construction is
predicate subtyping [Rushby et al., 1998]; {x : T | C} is thesubtype of T characterized by the predicate C.)

To represent security properties, expressions may as-sume and assert formulas in first-order logic. An expression
is safe when no assertion can ever fail at run time. By anno-tating programs with suitable formulas, we formalize security properties, such as authentication and authorization, asexpression safety.

Our F# code is written in a functional style, so pre- andpost-conditions concern data values and events represented
by logical formulas; our type system does not (and need notfor our purposes) directly support reasoning about mutable
state, such as heap-allocated structures.
Contributions First, we formalize our approach withina typed concurrent l -calculus. We develop a type system

with refinement types that carry logical formulas, buildingon standard techniques for dependent types, and establish
its soundness.

Second, we adapt our type system to account for active(untyped) adversaries, by extending subtyping so that all

values manipulated by the adversary can be given a spe-cial universal type (

Un). Our calculus has no built-in cryp-tographic primitives. Instead, we show how a wide range

of cryptographic primitives can be coded (and typed) inthe calculus, using a seal abstraction, in a generalization of
the symbolic Dolev-Yao model. The corresponding robustsafety properties then follow as a corollary of type safety.

Third, experimentally, we implement our approach as anextension of F#, and develop a new typechecker (with partial type inference) based on Z3 (a fast, incomplete, first-order logic prover).

Fourth, we evaluate our approach on a series of program-ming examples, involving authentication and authorization
properties of protocols and applications; this indicates thatour use of refinement types is an interesting alternative to
global verification tools for cryptography, especially for theverification of executable reference implementations.

An online technical report provides details, proofs, andexamples omitted from this version of the paper.

2 A Language with Refinement Types

Our calculus is an assembly of standard parts: call-by-value dependent functions, dependent pairs, sums, isorecursive types, message-passing concurrency, refinementtypes, subtyping, and a universal type

Un to model at-tacker knowledge. This is essentially the Fixpoint Calculus

(FPC) [Gunter, 1992], augmented with concurrency and re-finement types. Hence, we adopt the name Refined Concurrent FPC, or RCF for short. This section introduces its syn-tax, semantics, and type system (apart from

Un), togetherwith an example application. Section 3 introduces

Un andapplications to cryptographic protocols. (Any ambiguities

in the informal presentation should be clarified by the se-mantics in Appendix B and the type system in Section 4.)

Expressions, Evaluation, and Safety An expression rep-resents a concurrent, message-passing computation, which
may return a value. A state of the computation consists of(1) a multiset of expressions being evaluated in parallel;

(2) a multiset of messages sent on channels but not yet re-ceived; and (3) the log, a multiset of assumed formulas.
The multisets of evaluating expressions and unread mes-sages model a configuration of a concurrent or distributed
system; the log is a notional central store of logical formu-las, used only for specifying correctness properties.

We write S |= C to mean that a formula C logically fol-lows from a set S of formulas. In our implementation, C
is some formula in (untyped) first-order logic with equali-ties

M = N interpreted as syntactic identity between values.(Appendix A lists the (standard) syntax.)

We assume collections of names, variables, and typevariables. A name is an identifier, generated at run time,
for a channel, while a variable is a placeholder for a value.If f is a phrase of syntax, we write f {M

/x} for the out-come of substituting a value
M for each free occurrence ofthe variable x in f . We identify syntax up to the captureavoiding renaming of bound names and variables. We write
fnfv(f ) for the set of names and variables occurring free ina phrase of syntax f .

Syntax of Values and Expressions:
v ::= a | x name or variable
h ::= inl | inr | fold constructorM

, N ::= value

v name or variable() unit

fun x ! A function (scope of x is A)(M

,N) pair
h M construction
A, B ::= expressionM value

M N applicationM = N syntactic equality
let x = A in B let (scope of x is B)let (x

, y) = M in A pair split (scope of x, y is A)match

M with constructor matchh x ! A else B (scope of x is A)

(na)A restriction (scope of a is A)A O/ B fork
M!N transmission of N on channel M
M? receive message off channelassume C assumption of formula C

assert C assertion of formula C
To evaluate M, return M at once. To evaluate M N, ifM = fun x ! A, evaluate A{N

/x}. To evaluate M = N,if the two values
M and N are the same, return true 4=
inr (); otherwise, return false 4= inl (). To evaluate let x =
A in B, first evaluate A; if evaluation returns a value M,evaluate B{M

/x}. To evaluate let (x1, x2) = M in A, if
M = (N1, N2), evaluate A{N1/x1}{N2/x2}. To evaluatematch M with h x ! A else B, if M = h N for some N,

evaluate A{N/x}; otherwise, evaluate B.

To evaluate (na)A, generate a globally fresh channelname c, and evaluate A{c

/a}. To evaluate A O/ B, start aparallel thread to evaluate
A (whose return value will be dis-carded), and evaluate B. To evaluate M!N, if M = c for some

name c, emit message N on channel c, and return () at once.To evaluate M?, if M = c for some name c, block until some
message N is on channel c, remove N from the channel, andreturn N.

To evaluate assume C, add C to the log, and return (). Toevaluate assert

C, return (). If S |= C, where S is the set oflogged formulas, we say the assertion succeeds; otherwise,

we say the assertion fails. Either way, it always returns ().
Expression Safety:
An expression A is safe if and only if, in all evaluations of A,all assertions succeed. (see Appendix B for formal details.)

Types and Subtyping We assume a collection of type
variables, for forming recursive types.

Syntax of Types:
H,T,U ::= typea type variable

unit unit type\Pi x : T

. U dependent function type (scope of x is U)\Sigma 
x : T. U dependent pair type (scope of x is U)T +U disjoint sum type

ua.T iso-recursive type (scope of a is T )(

T )chan channel type{x : T | C} refinement type (scope of x is C)

{C} 4= { : unit | C} ok-type
(The notation denotes an anonymous variable that by con-vention occurs nowhere else.)

A value of type unit is the unit value (). A value of type\Pi 
x : T. U is a function M such that if N has type T , then M Nhas type U{N

/x}. A value of type \Sigma x : T. U is a pair (M, N)such that
M has type T and N has type U{M/x}. A valueof type T + U is either

inl M where M has type T , or inr Nwhere
N has type U. A value of type ua.T is a construction
fold M, where M has the (unfolded) type T {ua.T /a}. Avalue of type (

T )chan is a name c such that for any trans-mission
c!M on c, message M has type T . A value of type{x : T | C} is a value M of type T such that the formula

C{M/x} follows from the log.As usual, we can define syntax-directed typing rules for

checking that the value of an expression is of type T , writtenE ` A : T , where E is a typing environment. The environment tracks the types of variables and names in scope. Wewrite ? for the empty environment.

The core principle of our system is safety by typing:
Theorem 1 (Safety by Typing) If ? ` A : T then A is safe.

Section 4 has all the typing rules. The majority are stan-dard. Here, we explain the intuitions for the rules concerning refinement types, assumptions, and assertions.The judgment E |= C means C is deducible from the formulas mentioned in refinement types in E. For example:

* If E includes y : {x : T | C} then E |= C{y/x}.

Consider the refinement types T1 = {x1 : T | P(x1)} and
T2 = {x2 : unit | 8z.P(z) ) Q(z)}. If E = (y1 : T1, y2 : T2)then

E |= Q(y1) (via the rule above plus first-order logic).The introduction rule for refinement types is as follows.

* If E ` M : T and E |= C{M/x} then E ` M : {x : T | C}.

A special case of refinement is an ok-type, written {C},and short for { :

unit | C}: a type of tokens that a for-mula holds. For example, up to variable renaming,

T2 ={8z
.P(z) ) Q(z)}. The specialized rules for ok-types are:

* If E includes x : {C} then E |= C.

* A value of type {C} is (), a token that C holds.

The type system includes a subtype relation E ` T <: T 0,and the usual subsumption rule:

* If E ` A : T and E ` T <: T 0 then E ` A : T 0.

Refinement relates to subtyping as follows. (To avoidconfusion, note that

True is a logical formula, which alwaysholds, while true is a Boolean value, defined as

inr ()).

* If T <: T 0 and C |= C0 then {x : T | C} <: {x : T 0 | C0}.

* {x : T | True} <:> T .
For example, {x : T | C} <: {x : T | True} <: T .We typecheck assume and assert as follows.

* E ` assume C : {C}.

* If E |= C then E ` assert C : unit.
By typing the result of assume as {C}, we track that C cansubsequently be assumed to hold. Conversely, for a welltyped assert to be guaranteed to succeed, we must checkthat

C holds in E. This is sound because when typecheck-ing any A in E, the formulas deducible from E are a lower

bound on the formulas in the log whenever A is evaluated.
Formal Interpretation of our Typechecker We interpreta large class of F# expressions and modules within our calculus. To enable a compact presentation of the semantics ofRCF, there are two significant differences between expressions in these languages. First, the formal syntax of RCF isin an intermediate, reduced form (reminiscent of A-normal
form [Sabry and Felleisen, 1993]) where let x = A in B is theonly construct to allow sequential evaluation of expressions.

As usual, A; B is short for let = A in B. More notably, ifA and B are proper expressions rather than being values, the
application A B is short for let f = A in (let x = B in f x).In general, the use in F# of arbitrary expressions in place of
values can be interpreted by inserting suitable lets.The second main difference is that the RCF syntax for
communication and concurrency ((na)A and A O/ B and M?and M!N) is in the style of a process calculus. In F# we
express communication and concurrency via a small libraryof functions, which is interpreted within RCF as follows.

Functions for Communication and Concurrency:
chan 4= fun x ! (na)a create new channel
send 4= fun c ! fun x ! (c!x O/ ()) send x on c
recv 4= fun c ! let x = c? in x block for x on c
fork 4= fun f ! ( f () O/ ()) run f in parallel

We also assume standard encodings of strings, numerictypes, Booleans, tuples, records, algebraic types (including
lists) and pattern-matching, and recursive functions. RCFlacks polymorphism, but by duplicating definitions at multiple monomorphic types we can recover the effect of havingpolymorphic definitions.

We use the following notations for functions with pre-conditions, and non-empty tuples (instead of directly using
the core syntax for dependent function and pair types). Weusually omit conditions of the form {

True} in examples.

Derived Notation for Functions and Tuples:
[x1 : T1]{C1} ! U 4= \Pi x1 : {x1 : T1 | C1}. U(

x1 : T1 * ** * * xn : Tn){C} 4=ae \Sigma x

1 : T1. . .. \Sigma xn-1 : Tn-1. {xn : Tn | C} if n > 0{C} otherwise

To treat assume and assert as F# library functions, wefollow the convention that constructor applications are interpreted as formulas (as well as values). If h is an algebraictype constructor of arity

n, we treat h as a predicate symbolof arity n, so that h(M

1, . .. , Mn) is a formula.All of our example code is extracted from two kinds of

source files: either extended typed interfaces (.fs7) that de-clare types, values, and policies; or the corresponding F#
implementation modules (.fs) that define them.We sketch how to interpret interfaces and modules as
tuple types and expressions. In essence, an interface is asequence val

x1 : T1 .. . val xn : Tn of value declarations,which we interpret by the tuple type (

x1 : T1 * * * * * xn : Tn).A module is a sequence let x

1 = A1 . .. let xn = An of valuedefinitions, which we interpret by the expression let x

1 =A
1 in .. . let xn = An in (x1, .. . ,xn). If A and T are the in-terpretations of a module and an interface, our tool checks

whether A : T . Any type declarations are simply inter-preted as abbreviations for types, while a policy statement
assume C is treated as a declaration val x : {C} plus a defi-nition let

x = assume C for some fresh x.

Example: Access Control in Partially-Trusted CodeThis example illustrates static enforcement of file access
control policies in code that is typechecked but not nec-essarily trusted, such as applets or plug-ins [Pottier et al.,
2001, Abadi and Fournet, 2003, Abadi, 2006].We first declare a type for the logical facts in our policy.
We interpret each of its constructors as a predicate symbol:here, we have two basic access rights, for reading and writing a given file, and a property stating that a file is public.
type facts =CanRead of string

// read access| CanWrite of string

// write access| PublicFile of string

// some file attribute

We use these facts to give restrictive types to sensitiveprimitives. For instance, the declarations

val read: file:string{CanRead(file)} !stringval delete

: file:string{CanWrite(file)} !unit

demand that the function read be called only in contextsthat have previously established the fact

CanRead A for itsstring argument
A (and similarly for write). These demandsare enforced at compile time, so in F# the function

read justhas type
string ! string and its implementation may be leftunchanged.

Library writers are trusted to include suitable assumestatements. They may declare policies, in the form of logical deduction rules, declaring for instance that every filethat is writable is also readable:

assume 8x. CanWrite(x) )CanRead(x)
and they may program helper functions that establish newfacts. For instance, they may declare

val publicfile: file : string !unit{ PublicFile(file) }assume 8x

. PublicFile(x) )CanRead(x)

and implement publicfile as a partial function that dynami-cally checks its filename argument.

let publicfile f =if f

= "C:/public/README" then assume (PublicFile(f))else failwith

"not a public file"

where let f x = A is short for let f = fun x ! A.The F# library function

failwith throws an exception, soit never returns and can safely be given the polymorphic

type string ! a , where a can be instantiated to any RCFtype. (We also coded more realistic dynamic checks, based
on dynamic lookups in mutable, refinement-typed, access-control lists. We omit their code for brevity.)

To illustrate our code, consider a few sample files, oneof them writable:

let pwd = "C:/etc/password"let readme

= "C:/public/README"let tmp
= "C:/temp/tempfile"let
= assume (CanWrite(tmp))

Typechecking the test code below reports two type errors:
let test =delete tmp

; // okdelete pwd

; // type errorlet v1
= read tmp in // ok, using 1st logical rulelet v2
= read readme in // type errorpublicfile readme

; let v3 = read readme in () // ok

For instance, the second delete yields the error "Cannot es-tablish formula

CanWrite(pwd) at acls.fs(39,9)-(39,12)."
In the last line, the call to publicfile dynamically tests itsargument, ensuring

PublicFile(readme) whenever the finalexpression
read readme is evaluated. This fact is recordedin the environment for typing the final expression.

From the viewpoint of fully-trusted code, our inter-face can be seen as a self-inflicted discipline--indeed, one
may simply assume 8x.CanRead(x). In contrast, partially-trusted code (such as mobile code) would not contain any
assume. By typing this code against our library interface,possibly with a policy adapted to the origin of the code, the
host is guaranteed that this code cannot call read or writewithout first obtaining the appropriate right.

Although access control for files mostly relies on dy-namic checks (ACLs, permissions, and so forth), a static
typing discipline has advantages for programming partially-trusted code: as long as the program typechecks, one can
safely re-arrange code to more efficiently perform costly dy-namic checks. For example, one may hoist a check outside
a loop, or move it to the point a function is created, ratherthan called, or move it to a point where it is convenient to
handle dynamic security exceptions.

In the code below, for instance, the function reader canbe called to access the content of file

readme in any contextwith no further run time check.

let test higher order =let reader

= (publicfile readme; (fun () !read readme)) inlet v4
= read readme in // type errorlet v5
= reader () in () // ok

Similarly, we programmed (and typed) a function thatmerges the content of all files included in a list, under the

assumption that all these files are readable, declared as
val merge: (file:string{ CanRead(file) }) list !string
where list is a type constructor for lists, with a standard im-plementation typed in RCF.

3 Modelling Cryptographic Protocols

Following Bhargavan et al. [2007], we start with plain F#functions that create instances of each role of the protocol
(such as client or server). The protocols make use of vari-ous libraries (including cryptographic functions, explained

below) to communicate messages on channels that repre-sent the public network. We model the whole protocol as an
F# module, interpreted as before as an expression that ex-ports the functions representing the protocol roles, as well
as the network channel [Sumii and Pierce, 2007]. We ex-press authentication properties (correspondences [Woo and
Lam, 1993]) by embedding suitable assume and assert ex-pressions within the code of the protocol roles.

The goal is to verify that these properties hold in spiteof an active opponent able to send, receive, and apply cryptography to messages on network channels [Needham andSchroeder, 1978]. We model the opponent as some arbitrary (untyped) expression O which is given access to theprotocol and knows the network channels [Abadi and Gordon, 1999]. The idea is that O may use the communicationand concurrency features of RCF to create arbitrary parallel
instances of the protocol roles, and to send and receive mes-sages on the network channels, in an attempt to force failure
of an assert in protocol code. Hence, our formal goal is ro-bust safety, that no assert fails, despite the best efforts of an
arbitrary opponent.
Formal Threat Model: Opponents and Robust Safety
An expression O is an opponent iff O contains no occur-rence of assert and each type annotation within

O is Un.An expression A is robustly safe iff the application O A is

safe for all opponents O.
(An opponent must contain no assert, or less it could vacu-ously falsify safety. The constraint on type annotations is a

technical convenience; it does not affect the expressivenessof opponents.)

Typing the Opponent To allow type-based reasoningabout the opponent, we introduce a

universal type Un ofdata known to the opponent, much as in earlier work [Abadi,

1999, Gordon and Jeffrey, 2003a]. By definition, Un istype equivalent to (both a subtype and a supertype of) all
of the following types: unit, (\Pi x : Un. Un), (\Sigma x : Un. Un),(

Un + Un), (ua.Un), and (Un)chan. Hence, we obtain op-ponent typability, that O :

Un for all opponents O.It is useful to characterize two

kinds of type: public types(of data that may flow to the opponent) and tainted types (of

data that may flow from the opponent).
Public and Tainted Types:
Let a type T be public if and only if T <: Un.Let a type

T be tainted if and only if Un <: T .

We can show that refinement types satisfy the followingkinding rules. (Section 4 has kinding rules for the other
types, following prior work [Gordon and Jeffrey, 2003b].)

* E ` {x : T | C} <: Un iff E ` T <: Un

* E ` Un <: {x : T | C} iff E ` Un <: T and E, x : T |= C

Consider the type {x : string | CanRead(x)}. Accordingto the rules above, this type is public, because

string is pub-lic, but it is only tainted if
CanRead(x) holds for all x. If wehave a value M of this type we can conclude

CanRead(M).The type cannot be tainted, for if it were, we could conclude

CanRead(M) for any M chosen by the opponent. It is thepresence of such non-trivial refinement types that prevents
all types from being equivalent to Un.

Verification of protocols versus an arbitrary opponent isbased on a principle of robust safety by typing.

Theorem 2 (Robust Safety by Typing) If ? ` A : Un thenA is robustly safe.

To apply the principle, if expression A and type T arethe RCF interpretations of a protocol module and a protocol
interface, it suffices by subsumption to check that A : T and
T is public. The latter amounts to checking that Ti is publicfor each declaration val x

i : Ti in the protocol interface.

A Cryptographic Library We provide various librariesto support distributed programming. They include polymorphic functions for producing and parsing network represen-tations of values, declared as

val pickle: x:a !(p:a pickled)val unpickle

: p:a pickled !(x:a )

and for messaging: addr is the type of TCP duplex connec-tions, established by calling

connect and listen, and used bycalling
send and recv. All these functions are public.
The cryptographic library provides a typed interface toa range of primitives, including hash functions, symmetric

encryption, asymmetric encryption, and digital signatures.We detail the interface for HMACSHA1, a keyed hash function, used in our examples to build messages authenticationcodes (MACs). This interface declares

type a hkey = HK of a pickled Sealtype hmac

= HMAC of Unval mkHKey

: unit !a hkeyval hmacsha1

: a hkey !a pickled !hmacval hmacsha1Verify

: a hkey !Un !hmac !a pickled

where hmac is the type of hashes and a hkey is the type ofkeys used to compute hashes for values of type

a .
The function mkHKey generate a fresh key (informallyfresh random bytes). The function

hmacsha1 computes thejoint hash of a key and a value with matching types a. The

function hmacsha1Verify verifies whether the joint hash ofa key and a value (a priori the pickled representation of any
type b ) match some given hash. If verification succeeds,this value is returned, now with the type

a indicated in thekey. Otherwise, an exception is raised.

Although keyed-hash verification is concretely imple-mented by recomputing the hash and comparing it to the
given hash, this would not meet its typed interface: assume

a is the refinement type hx:stringi {CanRead(x)}. In orderto hash a string x, one needs to prove

CanRead(x) as a pre-condition for calling
hmacsha1. Conversely, when receiv-ing a keyed hash of x, one would like to obtain

CanRead(x)as a postcondition of the verification--indeed, the result

type of hmacsha1Verify guarantees it. At the end of thissection, we describe a well-typed symbolic implementation
of this interface.
Example: A Protocol based on MACs Our first crypto-graphic example implements a basic one-message protocol

with a message authentication code (MAC) computed as ashared-keyed hash; it is a variant of a protocol described
and verified in earlier work [Bhargavan et al., 2007].We present snippets of the protocol code to illustrate our
typechecking method; Appendix C lists the full source codefor a similar, but more general protocol. We begin with a
typed interface, declaring three types: event for specifyingour authentication property;

content for authentic payloads;and
message for messages exchanged on a public network.

type event = Send of string // a type of logical predicatetype content

= x:string{Send(x)} // a string refinementtype message

= (string * hmac) pickled // a wire format

The interface also declares functions, client and server, forinvoking the two roles of the protocol.

val addr : (string * hmac, unit) addr // a public server addressprivate val hk

: content hkey // a shared secret

private val make: content hkey !content !messageval client

: string !unit // start a client

private val check: content hkey !message !contentval server

: unit !unit // start a server

The client and server functions share two values: a pub-lic network address

addr where the server listens, and ashared secret key
hk. Given a string argument s, client callsthe
make function to build a protocol message by calling
hmacsha1 hk (pickled s). Conversely, on receiving a mes-sage at

addr, server calls the check function to check themessage by calling

hmacsha1Verify.In the interface, values marked as priv may occur only in

typechecked implementations. Conversely, the other values(

addr, client, server) are available to the opponent, as wellas

Un-typed values declared in libraries.Authentication is expressed using a single event

Send(s)recording that the string
s has genuinely been sent by theclient--formally, that
client(s) has been called. This event isembedded in a refinement type,

content, the type of strings ssuch that
Send(s). Thus, following the type declarations for
make and check, this event is a pre-condition for buildingthe message, and a post-condition after successfully checking the message.Consider the following code for

client and server:

let client text =assume

(Send(text)); // privileged, carefully reviewlet c
= connect addr insend c

(make hk text)let server

() =let c
= listen addr inlet text

= check hk (recv c) inassert
(Send text) // guaranteed by typing

The calls to assume before building the message and toassert after checking the message have no effect at run time

(the implementations of these functions simply return ())but they are used to specify our security policy. In the terminology of cryptographic protocols, assume marks a "begin"event, while assert marks an "end" event.

Here, the server code expects that the call to check onlyreturns

text values previously passed as arguments to client.This guarantee follows from typing, by relying on the types

of the shared key and cryptographic functions. On the otherhand, this guarantee does not presume any particular cryptographic implementation--indeed, simple variants of ourprotocol may achieve the same authentication guarantee, for
example, by authenticated encryption or digital signature.

Conversely, some implementation mistakes would resultin a compile-time type error indicating a possible attack.

For instance, removing priv from the declaration of the au-thentication key

hk, or attempting to leak hk within clientwould not be type-correct; indeed, this would introduce an

attack on our desired authentication property.
Example: Principals and Compromise We now extendour example with multiple principals, with a shared key between each pair of principals. Hence, the keyed hash au-thenticates not only the message content, but also the sender
and the intended receiver. The full implementation is in Ap-pendix C; here we give only the types.

We represent principal names as strings; Send events arenow parameterized by the sending and receiving principals.

type prin = stringtype event

= Send of (prin * prin * string) | Leak of printype
(;a:prin,b:prin) content = x:string{ Send(a,b,x) }

The second event Leak is used in our handling of princi-pal compromise, as described below. The type definition

of content has two value parameters, a and b; they bindexpression variables in the type being defined, much like
type parameters bind type variables. (Value parameters ap-pear after type parameters, separated by a semicolon; here,
content has no type parameters before the semicolon.)

We store the keys in a (typed, list-based) private databasecontaining entries of the form (

a,b,k) where k is a symmetrickey of type (;
a,b)content shared between a and b.

val genKey: prin !prin !unitprivate val getKey

: a:string !b
:string !((;a,b) content) hkey

Trusted code can call getKey a b to retrieve a key sharedbetween

a and b. Both trusted and opponent code can alsocall
genKey a b to trigger the insertion of a fresh key intothe database.

To model the possibility of key leakage, we allow oppo-nent code to obtain a key by calling the function

leak:

assume 8a,b,x. ( Leak(a) ) )Send(a,b,x)val leak

:a
:prin !b:prin !(unit{ Leak(a) }) * ((;a,b) content) hkey

This function first assumes Leak(a), as recorded in its resulttype, then calls

getKey a b and returns the key. Since theopponent gets a key shared between

a and b, it can generateseemingly authentic messages on
a's behalf; accordingly,we declare the policy that
Send(a,b,x) holds for any x af-ter the compromise of
a, so that leak can be given a publictype--without this policy, a subtyping check fails during

typing.
Implementing Formal Cryptography Morris [1973] de-scribes

sealing, a programming language mechanism toprovide "authentication and limited access." Sumii and

Pierce [2007] provide a primitive semantics for sealingwithin a l -calculus, and observe the close correspondence
between sealing and various formal characterizations ofsymmetric-key cryptography.

In our notation, a seal k for a type T is a pair of func-tions: the seal function for k, of type T !

Un, and the unseal function for k, of type Un ! T . The seal function, whenapplied to M, wraps up its argument as a sealed value, informally written {M}k in this discussion. This is the only wayto construct {

M}k. The unseal function, when applied to{M}

k, unwraps its argument and returns M. This is the onlyway to retrieve M from {M}

k. Sealed values are opaque; inparticular, the seal k cannot be retrieved from {M}

k.We declare a type of seals, and a function mkSeal to create a fresh seal, as follows.
type a Seal = (a !Un) * (Un !a )val mkSeal

: unit !a Seal

To implement a seal k, we maintain a list of pairs[(
M1,a1);. . .; (Mn, an)]. The list records all the values Mithat have so far been sealed with k. Each a

i is a fresh namerepresenting the sealed value {M
i}k. The list grows as morevalues are sealed; we associate a channel s with the seal k,

and store the current list as the one and only message on s.We maintain the invariant that both the

Mi and the ai arepairwise distinct: the list is a one-to-one correspondence.

The function mkSeal below creates a fresh seal, by gen-erating a fresh channel

s; the seal itself is the pair of func-tions (
seal s,unseal s). The code uses the channel-basedabbreviations

chan, send, and recv displayed in Section 2.The code also relies on library functions for list lookups:

the function first, of type (a ! b option)! a list !b option,

takes as parameters a function and a list; it applies the func-tion to the elements of the list, and returns its first nonNoneresult, if any; otherwise it returns
None. This function isapplied to a pair-filtering function
left, defined as let left z (
x,y)= if z = x then Some y else None, to retrieve the first aiassociated with the value being sealed, if any, and is used

symmetrically with a function right to retrieve the first Miassociated with the value being unsealed, if any.

type a SealChan = ((a * Un) list) Pi.chanlet seal

: a SealChan !a !Un = fun s M !let state

= recv s in match first (left M) state with| Some
(a) !send s state; a| None !

let a: Un = Pi.name "a" insend s

((M,a)::state); alet unseal
: a SealChan !Un !a = fun s a !let state

= recv s in match first (right a) state with| Some
(M) !send s state; M| None !failwith

"not a sealed value"let mkSeal
() : a Seal =let s
:a SealChan = chan "seal" insend s

[]; (seal s, unseal s)

Within RCF, we derive formal versions of cryptographicoperations, in the spirit of Dolev and Yao [1983], but based

on sealing rather than algebra. Our technique dependson being within a calculus with functional values. Thus,
in contrast with previous work in cryptographic pi calculi[Gordon and Jeffrey, 2003b, Fournet et al., 2007b] where
all cryptographic functions were defined and typed as prim-itives, we can now implement these functions and retrieve
their typing rules by typechecking their implementations.As an example, we derive a formal model of the functions we use for HMACSHA1 in terms of seals as follows.
let mkHKey ():a hkey = HK (mkSeal ())let hmacsha1

(HK key) text = HMAC (fst key text)let hmacsha1Verify

(HK key) text (HMAC h) =let x
:a pickled = snd key h inif x

= text then x else failwith "hmac verify failed"

Similarly, we derive functions for symmetric encryption(AES), asymmetric encryption (RSA), and digital signatures (RSASHA1).

4 A Type System for Robust Safety

We describe the full type system.
Judgments, and Syntax of Environments:

E ` \Pi  E is syntactically well-formedE ` T in E, type T is syntactically well-formed

E |= C formula C is derivable from EE ` T :: n in E, type T has kind n 2 {pub

,tnt}
E ` T <: U in E, type T is a subtype of type UE ` A : T in E, expression A has type T

Syntax of Typing Environments:

u ::= environment entrya type variable

a :: {pub,tnt} kinding
a : (T )chan name (of channel type)x : T variable (of any type)

E ::= u1, .. . , un environment

A name can only have a channel type. If E = u1,. . ., unwe write u 2

E to mean that u = ui for some i 2 1..n. Wewrite
T <:> T 0 for T <: T 0 and T 0 <: T . Let dom(E) be theset of type variables, names, and variables defined in E. Let

fnfv(E) = S{fnfv(T ) | (u : T ) 2 E}.
Rules of Well-Formedness and Deduction:

? ` \Pi 

E ` \Pi fnfv(u) ` dom(E)
dom(u) " dom(E) = ?

E, u ` \Pi 

E ` \Pi 
fnfv(T ) ` dom(E)

E ` T
E ` \Pi  fnfv(C) ` dom(E) forms(E) |= C

E |= C
forms(E) 4=8!: {

C{y/x}} [ forms(y : T ) if E = (y : {x : T | C})
forms(E1) [ forms(E2) if E = (E1, E2)? otherwise

The next set of rules axiomatizes the sets of public andtainted types, of data that can flow to or from the opponent.
Kinding Rules: E ` T :: n for n 2 {pub,tnt}
E ` \Pi  (a :: {pub, tnt}) 2 E

E ` a :: n

E ` \Pi 
E ` unit :: n
E ` T :: tntE

, x : T ` U :: pub

E ` (\Pi x : T. U) :: pub

E ` T :: pubE

,x : T ` U :: tnt

E ` (\Pi x : T. U) :: tnt
E ` T :: n E, x : T ` U :: n

E ` (\Sigma x : T. U) :: n

E ` T :: n E ` U :: n

E ` (T +U) :: n
E, a :: {pub,tnt} ` T :: pubE

, a :: {pub,tnt} ` T :: tnt

E ` (ua.T ) :: n

E ` T :: pubE ` T :: tnt
E ` (T )chan :: n
E ` {x : T | C} E ` T :: pub

E ` {x : T | C} :: pub

E ` T :: tnt E, x : T |= C

E ` {x : T | C} :: tnt

The following rules of subtyping are standard [Cardelli,1986, Pierce and Sangiorgi, 1996, Aspinall and Compagnoni, 2001]. The two rules for subtyping refinementtypes are the same as in Sage [Gronski et al., 2006].

Subtype: E ` T <: U
E ` T :: pub E ` U :: tnt

E ` T <: U

E ` \Pi  a 2 dom(E)

E ` a <: a
E ` \Pi 
E ` unit <: unit

E ` T 0 <: T E,x : T 0 ` U <: U0

E ` (\Pi x : T. U) <: (\Pi x : T 0. U0)
E ` T <: T 0 E, x : T ` U <: U0

E ` (\Sigma x : T. U) <: (\Sigma x : T 0. U0)
E ` T <: T 0 E ` U <: U0

E ` (T + T 0) <: (U +U0)

E, a ` T <:> T 0
E ` (ua.T ) <: (ua.T 0)
E ` T <: T 0 E ` T 0 <: T

E ` (T )chan <: (T 0)chan
E ` {x : T | C} E ` T <: T 0

E ` {x : T | C} <: T 0

E ` T <: T 0 E, x : T |= C

E ` T <: {x : T 0 | C}

The universal type Un is to be type equivalent to all typesthat are both public and tainted; we (arbitrarily) define

Un 4=(
unit)chan. We can show that this definition satisfies theintended meaning: E ` T :: pub iff E ` T

<: Un, and E `
T :: tnt iff E ` Un <: T .The following congruence rule for refinement types is

derivable from the two primitive rules for refinement types.We also list the special case for ok-types.

E ` T <: T 0 E, x : {x : T | C} |= C0

E ` {x : T | C} <: {x : T 0 | C0}

E, : {C} |= C0
E ` {C} <: {C0}

Next, we present the rules for typing values. The rule forconstructions h M depends on an auxiliary relation h : (T

,U)that delimits the possible argument
T and result U of eachconstructor h.

Rules for Values: E ` A : T
E ` \Pi  (v : T ) 2 E

E ` v : T

E ` \Pi 
E ` () : unit
E, x : T ` A : U
E ` fun x ! A : (\Pi x : T. U)

E ` M : T E ` N : U{M/x}

E ` (M, N) : (\Sigma x : T. U)
h : (T,U) E ` M : T E ` U

E ` h M : U

E ` M : T E |= C{M/x}

E ` M : {x : T | C}
inl:(T, T +U) inr:(U, T +U) fold:(T {ua.T /a}, ua.T )

Our final set of rules is for typing arbitrary expressions.In the rules for pattern-matching pairs and constructions, we
use equations within refinement types to track informationabout the matched variables.

Rules for Expressions: E ` A : T
E ` A : T E ` T <: T 0

E ` A : T 0

E ` M : (\Pi x : T. U) E ` N : T

E ` M N : U{N/x}

E ` M : (\Sigma x : T. U)E

, x : T, y : U, : {(x, y) = M} ` A : V{
x, y} " fv(V ) = ?

E ` let (x, y) = M in A : V
E ` M : T h : (H, T )
E, x : H, : {h x = M} ` A : U x /2 fv(U)E

, : {8x.h x 6= M} ` B : U

E ` match M with h x ! A else B : U

E ` M : T E ` N : U
E ` M = N : {b : bool | b = true , M = N}
E ` \Pi  fnfv(C) ` dom(E)

E ` assume C : {C}

E |= C
E ` assert C : unit
E ` A : T E, x : T ` B : U x /2 fv(U)

E ` let x = A in B : U
E, a : (T )chan ` A : U a /2 fn(U)

E ` (na)A : U
E ` M : (T )chan E ` N : T

E ` M!N : unit

E ` M : (T )chan

E ` M? : T
E, : {A2} ` A1 : T1 E, : {A1} ` A2 : T2

E ` (A1 O/ A2) : T2

The final rule, for A1 O/ A2, relies on an auxiliary functionto extract the top-level formulas from

A2 for use while type-checking A

1, and to extract the top-level formulas from A1for use while typechecking A

2. The function A returns aformula representing the conjunction of each C occurring

in a top-level assume C in an expression A, with restrictednames existentially quantified.

Formula Extraction: A
(na)A = (9a.A) A1 O/ A2 = (A1 ^ A2)let

x = A1 in A2 = A1 assume C = C

A = True if A matches no other rule

5 Implementing Refinement Types for F#

We implement a typechecker that takes as input a seriesof extended RCF interface files and F# implementation files
and, for every implementation file, perform the followingtasks: (1) typecheck the implementation against its RCF interface, and any other RCF interfaces it may use; (2) kind-check its RCF interface, ensuring that every public value
declaration has a public type; and then (3) generate a plainF# interface by erasure from its RCF interface. The programming of these tasks almost directly follows from ourtype theory. In the rest of this section, we only highlight
some design choices and implementation decisions.

Handling F# Language Features Our typechecker pro-cesses F# programs with many more features than the calculus of Section 2. Thus, type definitions also featuremutual recursion, algebraic datatypes, type abbreviations,
and record types; value definitions also feature mutual re-cursion, polymorphism, nested patterns in let- and matchexpression, records, exceptions, and mutable references. Asdescribed in Section 2, these constructs can be expanded out
to simpler types and expressions within RCF.
Annotating Standard Libraries Any F# program mayuse the set of

pervasive types and functions in the standardlibrary; this library includes operations on built-in types

such as strings, Booleans, lists, options, and references, andalso provides system functions such as reading and writing
files and pretty-printing. Hence, to check a program, wemust provide the typechecker with declarations for all the
standard library functions and types it uses. When the typesfor these functions are F# types, we can simply use the F#
interfaces provided with the library and trust their imple-mentation. However, if the program relies on extended RCF
types for some library functions, we must provide our ownRCF interface. For example, the following code declare two
functions on lists:
assume

(8x, u. Mem(x,x::u)) ^
(8x, y, u. Mem(x,u) )Mem(x,y::u)) ^
(8x, u. Mem(x,u) )(9y, v. u = y::v ^(x = y .Mem(x,v))))val mem

: x:a !u:a list !r:bool{r=true )Mem(x,u)}val find
: (a !bool) !(u:a list !r:a { Mem(r,u) })

We declare an inductive predicate Mem for list member-ship and use it to annotate the two library functions for list

membership (mem) and list lookup (find). Having definedthese extended RCF types, we have a choice: we may either
trust that the library implementation satisfies these types,or reimplement these functions and typecheck them. For
lists, we reimplement (and re-typecheck) these functions;for other library modules such as

String and Printf, we trustthe F# implementation.

Implementing Trusted Libraries In addition to the stan-dard library, our F# programs rely on libraries for cryptography and networking. We write their concrete implemen-tations on top of .NET Framework classes. For instance, we
define keyed hash functions as:
open System.Security.Cryptographytype a hkey

= bytestype hmac
= byteslet mkHKey

() = mkNonce()let hmacsha1

(k:a hkey) (x:bytes) =
(new HMACSHA1 (k)).ComputeHash xlet hmacsha1Verify

(k:a hkey) (x:bytes) (h:bytes) =let hh
= (new HMACSHA1 (k)).ComputeHash x inif h
= hh then x else failwith "hmac verify failed"

F# Definitions F# Declarations RCF Declarations Analysis Time Z3 Obligations
Typed Libraries 440 lines 125 lines 146 lines 12.1s 12
Access Control (Section 2) 104 lines 16 lines 34 lines 8.3s 16
MAC Protocol (Section 3) 40 lines 9 lines 12 lines 2.5s 3
Logs and Queries 37 lines 10 lines 16 lines 2.8s 6
Principals & Compromise (Section 3) 48 lines 13 lines 26 lines 3.1s 12
Flexible Signatures (Section 6) 167 lines 25 lines 52 lines 14.6s 28

Table 1. Typechecking Example Programs
Similarly, the network send and recv are implemented usingTCP sockets (and not typechecked in RCF).

We also write symbolic implementations for cryptogra-phy and networking, coded using seals and channels, and
typechecked against their RCF interfaces. These implemen-tations can also be used to compile and execute programs
symbolically, sending messages on local channels (insteadof TCP sockets) and computing sealed values (instead of
bytes); this is convenient for testing and debugging, as onecan inspect the symbolic structure of all messages.

Type Annotations and Partial Type Inference Type in-ference for dependently-typed calculi, such as RCF, is undecidable in general. For top-level value definitions, we re-quire that all types be explicitly declared. For subexpressions, our typechecker performs type inference using stan-dard unification-based techniques for plain F# types (polymorphic functions, algebraic datatypes) but it may requireannotations for types carrying formulas.

Generating Proof Obligations for Z3 Following ourtyping rules, our typechecker must often establish that
a condition follows from the current typing environment(such as when typing function applications and kinding
value declarations). If the formula trivially holds, the type-checker discharges it; for more involved first-order-logic
formulas, it generates a proof obligation in the Simplify for-mat [Detlefs et al., 2005] and invokes the Z3 prover. Since
Z3 is incomplete, it sometimes fails to prove a valid for-mula.

The translation from RCF typing environments to Sim-plify involves logical re-codings. Thus, constructors are
coded as injective, uninterpreted, disjoint functions. Hence,for instance, a type definition for lists

type (a ) list = Cons of a * a list | Nil
generates logical declarations for a constant Nil and a binaryfunction

Cons, and the two assumptions

assume 8x,y. Cons(x,y) 6= Nil.assume 8

x,y,x',y'.(
x = x' ^ y = y') $ Cons(x,y) = Cons(x',y').

Each constructor also defines a predicate symbol thatmay be used in formulas. Not all formulas can be translated to first-order-logic; for example, equalities betweenfunctional values cannot be translated and are rejected.

Evaluation We have typechecked all the examples of thispaper and a few large programs. Table 1 summarizes our results; for each example, it gives the number of lines of typedF# code, of generated F# interfaces, and of declarations in
RCF interfaces, plus typechecking time, and the number ofproof obligations passed to Z3. Since F# programmers are
expected to write interfaces anyway, the line difference be-tween RCF and F# declarations roughly indicates the additional annotation burden of our approach.The first row is for typechecking our symbolic implementations of lists, cryptography, and networking libraries.The second row is an extension of the access control example of Section 2; the next three rows are variants of theMAC protocol of Section 3. The final row implements the
protocol described next in Section 6.The examples in this paper are small programs designed
to exercise the features of our type system; our results in-dicate that typechecking is fast and that annotations are not
too demanding. In comparison with an earlier tool FS2PVthat compiles F# code to ProVerif [Bhargavan et al., 2007],
our typechecker succeeds on examples with recursive func-tions, such as the last row in Table 1, where ProVerif fails
to terminate. We expect our method to scale better to largerexamples, since we can typecheck one module at a time,
rather than construct a large ProVerif model. On the otherhand, F

S2PV requires no type annotations, and ProVerif canalso prove injective correspondences and equivalence-based

properties [Blanchet et al., 2008].
6 Application: Flexible Signatures

We illustrate the controlled usage of cryptographic sig-natures with the same key for different intents, or different

protocols. Such reuse is commonplace in practice (at leastfor long-term keys) but it is also a common source of errors (see Abadi and Needham [1996]), and it complicatesprotocol verification.

The main risk is to issue ambiguous signatures. As an in-formal design principle, one should ensure that, whenever
a signature is issued, (1) its content follows from the cur-rent protocol step; and (2) its content cannot be interpreted
otherwise, by any other protocol that may rely on the samekey. To this end, one may for instance sign nonces, identities, session identifiers, and tags as well as the messagepayloads to make the signature more specific.

Our example is adapted from protocol code for XMLdigital signatures, as prescribed in web services security
standards [Eastlake et al., 2002, Nadalin et al., 2004].These signatures consist of an XML "signature information", which represents a list of (hashed) elements coveredby the signature, together with a binary "signature value",
a signed cryptographic hash of the signature information.Web services normally treat received signed-information
lists as sets, and only check that these sets cover selected el-ements of the message--possibly fewer than those signed,
to enable partial erasure as part of intermediate messageprocessing. This flexibility induces protocol weaknesses in
some configurations of services. For instance, by providingcarefully-crafted inputs, an adversary may cause a naive service to sign more than intended, and then use this signature(in another XML context) to gain access to another service.

For simplicity, we only consider a single key and two in-terpretations of messages. We first declare types for these
interpretations (either requests or responses) and their net-work representation (a list of elements plus their joint signature).
type id = int // representing message GUIDstype events

=Request of id * string

// id and payload| Response of id * id * string

// id, request id, and payloadtype element
=IdHdr of id

// Unique message identifier| InReplyTo of id

// Identifier for some related messsage| RequestBody of string

// Payload for a request message| ResponseBody of string

// Payload for a response message| Whatever of string
// Any other elementstype siginfo
= element listtype msg
= siginfo * dsig

Depending on their constructor, signed elements canbe interpreted for requests (

RequestBody), responses,(
InReplyTo, ResponseBody), both (IdHdr), or none(
Whatever). We formally capture this intent in the type dec-laration of the information that is signed:

type verified = x:siginfo{

(8id, b.(Mem(IdHdr(id),x) ^Mem(RequestBody(b),x)))Request

(id,b) )^
(8id, req, b.(Mem(IdHdr(id),x) ^Mem(ResponseBody(b),x)^Mem

(InReplyTo(req),x)) )Response(id,req,b) ) }

Thus, the logical meaning of a signature is a conjunction ofmessage interpretations, each guarded by a series of conditions on the elements included in the signature information.We only present code for requests. We use the following
declarations for the key pair and for message processing.
private val sk: verified privkeyval vk

: verified pubkeyprivate val mkMessage

: verified !msgprivate val isMessage
: msg !verified

type request = (id:id * b:string){ Request(id,b) }val isRequest

: msg !requestprivate val mkPlainRequest

: request !msgprivate val mkRequest
: request !siginfo !msg

To accept messages as a genuine requests, we just verifyits signature and find two relevant elements in the list:

let isMessage (msg,dsig) =unpickle

(rsasha1Verify vk (pickle msg) dsig)let isRequest msg

=let si
= isMessage msg in (find id si, find request si)

For producing messages, we may define (and type):
let mkMessage siginfo = (siginfo, rsasha1 sk (pickle siginfo))let mkPlainRequest

(id,payload) =mkMessage
(IdHdr(id)::RequestBody(payload)::[])let mkRequest

(id,payload) extra : msg =check harmless extra

;mkMessage
(IdHdr(id)::RequestBody(payload)::extra)

While mkPlainRequest uses a fixed list of signed elements,
mkRequest takes further elements to sign as an extra pa-rameter. In both cases, typing the list with the refinement

type verified ensures (1) Request(id,b), from its input refine-ment type; and (2) that the list does not otherwise match the
two clauses within verified. For mkRequest, this requiressome dynamic input validation

check harmless extra where
check harmless is declared as

val check harmless: x: siginfo !r: unit {

( 8s. not(Mem(IdHdr(s),x)))^
( 8s. not(Mem(InReplyTo(s),x)))^
( 8s. not(Mem(RequestBody(s),x)))^
( 8s. not(Mem(ResponseBody(s),x))) }

and recursively defined as
let rec check harmless m = match m with| IdHdr

( ):: !failwith "bad"| InReplyTo

( ):: !failwith "bad"| RequestBody

( ):: !failwith "bad"| ResponseBody

( ):: !failwith "bad"|
::xs !check harmless xs|
[] !()

On the other hand, the omission of this check, or an error inits implementation, would be caught as a type error.

7 Related Work

Type systems for information flow have been developedfor code written in many languages, including Java [Myers, 1999] and ML [Pottier and Simonet, 2003]. Furtherworks extend them with support for cryptographic mechanisms [for example, Askarov et al., 2006, Vaughan andZdancewic, 2007, Fournet and Rezk, 2008]. These systems seek to guarantee non-interference properties for pro-grams annotated with confidentiality and integrity levels. In

contrast, our system seeks to guarantee assertion-based se-curity properties, commonly used in authorization policies
and cryptographic protocol specifications, and disregardsimplicit flows of information.

Type systems with logical effects, such as ours, have alsobeen used to reason about the security of models of distributed systems. For instance, type systems for variants ofthe p-calculus [Fournet et al., 2007b, Cirillo et al., 2007]
and the l -calculus [Cirillo et al., 2007] can guarantee thatexpressions follow their access control policies. Type systems for variants of the p-calculus, such as Cryptyc [Gor-don and Jeffrey, 2002], have been used to verify secrecy, authentication, and authorization properties of protocol mod-els. Unlike our tool, none of these typecheckers operates on
source code.

The tool CSur has been used to check cryptographicproperties of C code using an external first-order-logic

theorem-prover [Goubault-Larrecq and Parrennes, 2005]; itdoes not rely on typing.

Our approach of annotating programs with pre- and post-conditions has similarities with extended static checkers
used for program verification, such as ESC/Java [Flana-gan et al., 2002], Spec# [Barnett et al., 2005], and ESC/Haskell [Xu, 2006]. Such checkers cannot verify securityproperties of cryptographic code, but they can find many
other kinds of errors. For instance, Poll and Schubert [2007]use ESC/Java2 [Cok and Kiniry, 2004] to verify that an SSH
implementation in Java conforms to a state machine specifi-cation. Combining approaches can be even more effective,
for instance, Hubbers et al. [2003] generate implementationcode from a verified protocol model and check conformance
using an extended static checker.

In comparison with these approaches, we propose sub-typing rules that capture notions of public and tainted

data, and we provide functional encodings of cryptography.Hence, we achieve typability for opponents representing active attackers. Also, we use only stable formulas: in anygiven run, a formula that holds at some point also holds
for the rest of the run; this enables a simple treatment ofprograms with concurrency and side-effects. (This would
not be the case, say, with predicates on the current state ofshared mutable memory.)

One direction for further research is to avoid the needfor refinement type annotations, by inference. A potential
starting point is a recent paper [Rondon et al., 2008], whichpresents a polymorphic system of refinement types for ML,
quite related to RCF, together with a type inference algo-rithm based on predicate abstraction.

Acknowledgments Discussions with Bob Harper andDan Licata were useful. Aleks Nanevski commented on
a draft of this paper. Kenneth Knowles suggested a proof

technique. Nikolaj Bjo/rner and Leonardo de Moura pro-vided help with Z3. Sergio Maffeis was supported by EPSRC grant EP/E044956/1.

A Logic

Formally, our typed calculus is parameterized by thechoice of an authorization logic, in the sense that it relies
only on a series of abstract properties of the logic, ratherthan on a particular syntax or semantics for logic formulas.

Experimentally, our prototype implementation uses ordi-nary first order logic with equality, with terms that include
all the values M, N of Section 2 (including functional val-ues). During typechecking, this logic is partially mapped
to the SIMPLIFY input of Z3, with the implementation re-striction that no term should include any functional value.
(This restriction prevents discrepancies on term equalitiesbetween the calculus and the logic.)

We use the following abstract syntax.
First-Order Logic with Equality:

p predicate symbolC ::= formula

C ^C0 conjunctionC .C0 disjunction

~C negation8x

.C universal quantification9
x.C existential quantification
p(M1,. . ., Mn) atomic predicateM = M0 equation

True 4= 8x.x = x
False 4= ~True
M 6= M0 4= ~(M = M0)(C ) C0) 4= (~C .C0)

(C , C0) 4= (C ) C0) ^ (C0 ) C)
As usual with first order logic, the logical terms may includeboth variables and function symbols (coded as datatype constructors). In addition, they may include function abstrac-tions fun

x ! A, considered up to consistent renaming ofbound variables. (These functions are inert in the logic; they

can be compared but not applied.)

Other interesting logics for our verification purposes in-clude logics with "says" modalities [Abadi et al., 1993],

which may be used to give a logical account of principalsand partial trust by typing [Fournet et al., 2007b].

B Semantics and Safety of Expressions

This appendix formally defines the operational seman-tics of expressions, and the notion of expression safety, as
introduced in Section 2.

An expression can be thought of as denoting a structure,given as follows. We define the meaning of assume C and
assert C in terms of a structure being statically safe.Let an

elementary expression, e, be any expression apartfrom a let, restriction, fork, message send, or an assumption.

Structures and Static Safety:
O~i21..n Ai 4= () O/ A1 O/ .. . O/ An
L ::= {} | (let x = L in B)

S ::= (na1) . .. (na`)

(( O~

i21..m assume Ci) O/ ( O~j21..nMj!Nj) O/ ( O~k21..o Lk{ek}))

Let structure S be statically safe if and only if, for all p 21

..o and C, if ep = assert C then {C1,. . .,Cm} ` C.

Heating: A V A0
Axioms A j A0 are read as both A V A0 and A0 V A.
A V AA V A00 if A V A0 and A0 V A00

A V A0 ) let x = A in B V let x = A0 in BA V A0 ) (na)A V (na)A0
A V A0 ) (A O/ B) V (A0 O/ B)A V A0 ) (B O/ A) V (B O/ A0)

() O/ A j AM!N V M!N O/ ()
assume C V assume C O/ ()
a /2 fn(A0) ) A0 O/ ((na)A) V (na)(A0 O/ A)
a /2 fn(A0) ) ((na)A) O/ A0 V (na)(A O/ A0)a

/2 fn(B) ) let x = (na)A in B V (na)let x = A in B

(A O/ A0) O/ A00 j A O/ (A0 O/ A00)(A O/ A0) O/ A00 V (A0 O/ A) O/ A00

let x = (A O/ A0) in B j A O/ (let x = A0 in B)

Reduction: A ! A0
(fun x ! A) N ! A{N/x}(let (

x1,x2) = (N1, N2) in A) ! A{N1/x1}{N2/x2}(match M with h x ! A else B) !ae

A{N/x} if M = h N for some NB otherwise

M = N ! ae true if M = Nfalse otherwise
c!M O/ c? ! Massert C ! ()
let x = M in A ! A{M/x}
A ! A0 ) let x = A in B ! let x = A0 in B
A ! A0 ) (na)A ! (na)A0A ! A0 ) (A O/ B) ! (A0 O/ B)

A ! A0 ) (B O/ A) ! (B O/ A0)

A ! A0 if A V B, B ! B0, B0 V A0
Expression Safety:
An expression A is safe if and only if, for all A0 and S, ifA !* A0 and A0 V S, then S is statically safe.

C Example Code

We provide the complete interface and implementationcode for the final MAC-based authentication protocol of
Section 3.
Refinement-Typed Interface
module Mopen Pi

open Cryptoopen Net

type prin = stringtype event

= Send of (prin * prin * string) | Leak of printype
(;a:prin,b:prin) content = x:string{ Send(a,b,x) }type message

= (prin * prin * string * hmac) pickled

private val mkContentKey:a

:prin !b:prin !((;a,b)content) hkeyprivate val hkDb

:
(prin*prin, a:prin * b:prin * k:(;a,b) content hkey) Db.tval genKey

: prin !prin !unitprivate val getKey

: a:string !b
:string !((;a,b) content) hkey

assume 8a,b,x. ( Leak(a) ) )Send(a,b,x)val leak

:a
:prin !b:prin !(unit{ Leak(a) }) * ((;a,b) content) hkey

val addr : (prin * prin * string * hmac, unit) addrprivate val check

:b
:prin !message !(a:prin * (;a,b) content)val server

: string !unit

private val make:a

:prin !b:prin !(;a,b) content !messageval client

: prin !prin !string !unit

F# Implementation Code
module Mopen Pi

open Crypto // Crypto Libraryopen Net

// Networking Library

// Simple F# types for principals, events, payloads, and messages:type prin

= stringtype event

= Send of (prin * prin * string) | Leak of prin

type content = stringtype message

= (prin * prin * string * hmac) pickled

// Key database:let hkDb

: ((prin*prin),(prin*prin*(content hkey))) Db.t =Db
.create ()let mkContentKey

(a:prin) (b:prin) : content hkey =mkHKey
()let genKey a b

=let k
= mkContentKey a b inDb
.insert hkDb (a,b) (a,b,k)let getKey a b

=let a
',b',sk = Db.select hkDb (a,b) inif
(a',b') = (a,b) then sk else failwith "select failed"

// Key compromise:let leak a b

=assume
(Leak(a)); ((),getKey a b)
// removed: assume (Leak(b));

// Server code:let addr

: (prin * prin * string * hmac, unit) addr =http
"http://localhost:7000/pwdmac"let check b m

=let a
,b',text,h = unpickle m inif b

= b' thenlet k

= getKey a b in
(a,unpickle

(hmacsha1Verify k (pickle (text:string)) h))else failwith

"Not the intended recipient"let server b
=let c
= listen addr inlet
(a,text) = check b (recv c) inassert

(Send(a,b,text))

// Client code:let make a b s

=pickle
(a,b,s,hmacsha1 (getKey a b) (pickle s))let client a b text

=assume
(Send(a,b,text));let c
= connect addr insend c

(make a b text)

// Execute one instance of the protocol:let

= genKey "A" "B"let
= fork (fun (u:unit) !client "A" "B" "Hello")let
= server "B"

References
M. Abadi. Access control in a core calculus of dependency. In International Conference on Functional Programming (ICFP'06), 2006.

M. Abadi. Secrecy by typing in security protocols. JACM, 46(5):

749-786, Sept. 1999.

M. Abadi and B. Blanchet. Analyzing security protocols with secrecy types and logic programs. JACM, 52(1):102-146, 2005.

M. Abadi and C. Fournet. Access control based on execution history. In 10th Annual Network and Distributed System Symposium (NDSS'03). Internet Society, February 2003.

M. Abadi and A. D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and Computation, 148:
1-70, 1999.

M. Abadi and R. Needham. Prudent engineering practice for cryptographic protocols. IEEE Transactions on Software Engineering, 22(1):6-15, 1996.

M. Abadi, M. Burrows, B. Lampson, and G. Plotkin. A calculus

for access control in distributed systems. ACM TOPLAS, 15(4):
706-734, 1993.

A. Askarov, D. Hedin, and A. Sabelfeld. Cryptographicallymasked flows. In Static Analysis Symposium, volume 4134 of
LNCS, pages 353-369. Springer, 2006.

D. Aspinall and A. Compagnoni. Subtyping dependent types.

TCS, 266(1-2):273-309, 2001.

M. Barnett, M. Leino, and W. Schulte. The Spec# programming

system: An overview. In CASSIS'05, volume 3362 of LNCS,
pages 49-69. Springer, January 2005.

K. Bhargavan, C. Fournet, A. D. Gordon, and S. Tse. Verified

interoperable implementations of security protocols. Technical
Report MSR-TR-2006-46, Microsoft Research, 2007. See also
CSFW'06 and WS-FM'06.

B. Blanchet. An efficient cryptographic protocol verifier based on

Prolog rules. In IEEE Computer Security Foundations Workshop (CSFW'01), pages 82-96, 2001.

B. Blanchet, M. Abadi, and C. Fournet. Automated verification of

selected equivalences for security protocols. Journal of Logic
and Algebraic Programming, 75(1):3-51, 2008.

L. Cardelli. Typechecking dependent types and subtypes. In Foundations of Logic and Functional Programming, volume 306 of
LNCS, pages 45-57. Springer, 1986.

A. Cirillo, R. Jagadeesan, C. Pitcher, and J. Riely. Do As I SaY!

Programmatic access control with explicit identities. In IEEE
Computer Security Foundations Symposium (CSF'07), pages
16-30, 2007.

D. R. Cok and J. Kiniry. ESC/Java2: Uniting ESC/Java and JML.

In CASSIS'05, volume 3362 of LNCS, pages 108-128. Springer,
2004.

L. de Moura and N. Bjo/rner. Z3: An efficient SMT solver. In Tools

and Algorithms for the Construction and Analysis of Systems
(TACAC'08), volume 4963 of LNCS, pages 337-340. Springer,
2008.

D. Detlefs, G. Nelson, and J. Saxe. Simplify: A theorem prover

for program checking. JACM, 52(3):365-473, 2005.

D. Dolev and A. Yao. On the security of public key protocols.

IEEE Transactions on Information Theory, IT-29(2):198-208,
1983.

D. Eastlake, J. Reagle, D. Solo, M. Bartel, J. Boyer, B. Fox,

B. LaMacchia, and E. Simon. XML-Signature Syntax and Processing, 2002. W3C Recommendation, at http://www.w3.
org/TR/2002/REC-xmldsig-core-20020212/.

J.-C. Filli^atre. Why: a multi-language multi-prover verification

condition generator. http://why.lri.fr/, 2003.

C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe,

and R. Stata. Extended static checking for Java. SIGPLAN Not.,
37(5):234-245, 2002.

C. Fournet and T. Rezk. Cryptographically sound implementations for typed information-flow security. In 35th Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (POPL'08), pages 323-335, Jan. 2008.

C. Fournet, A. D. Gordon, and S. Maffeis. A type discipline for

authorization policies. ACM TOPLAS, 29(5), 2007a. In press.

C. Fournet, A. D. Gordon, and S. Maffeis. A type discipline for authorization policies in distributed systems. In 20th IEEE Computer Security Foundations Symposium (CSF'07), pages 31-45,
2007b.

T. Freeman and F. Pfenning. Refinement types for ML. In Programming Language Design and Implementation (PLDI'91),
pages 268-277. ACM, 1991.

A. D. Gordon and A. S. A. Jeffrey. Cryptyc: Cryptographic protocol type checker. At http://cryptyc.cs.depaul.
edu/, 2002.

A. D. Gordon and A. S. A. Jeffrey. Authenticity by typing for

security protocols. Journal of Computer Security, 11(4):451-
521, 2003a.

A. D. Gordon and A. S. A. Jeffrey. Types and effects for asymmetric cryptographic protocols. Journal of Computer Security,
12(3/4):435-484, 2003b.

J. Goubault-Larrecq and F. Parrennes. Cryptographic protocol

analysis on real C code. In VMCAI'05, pages 363-379, 2005.

J. Gronski, K. Knowles, A. Tomb, S. N. Freund, and C. Flanagan.

Sage: Hybrid checking for flexible specifications. In R. Findler,
editor, Scheme and Functional Programming Workshop, pages
93-104, 2006.

C. Gunter. Semantics of programming language. MIT Press, 1992.
E. Hubbers, M. Oostdijk, and E. Poll. Implementing a formally

verifiable security protocol in Java Card. In Security in Pervasive Computing, pages 213-226, 2003.

J. H. Morris, Jr. Protection in programming languages. Commun.

ACM, 16(1):15-21, 1973.

A. C. Myers. JFlow: Practical mostly-static information flow control. In ACM Symposium on Principles of Programming Languages (POPL'99), pages 228-241, 1999.

A. Nadalin, C. Kaler, P. Hallam-Baker, and R. Monzillo. OASIS

Web Services Security: SOAP Message Security 1.0 (WSSecurity 2004), Mar. 2004. At http://www.oasis-open.
org/committees/download.php/5941/
oasis-200401-wss-soap-message-security-1.
0.pdf.

R. Needham and M. Schroeder. Using encryption for authentication in large networks of computers. Commun. ACM, 21(12):
993-999, 1978.

B. Pierce and D. Sangiorgi. Typing and subtyping for mobile processes. Mathematical Structures in Computer Science, 6(5):
409-454, 1996.

E. Poll and A. Schubert. Verifying an implementation of SSH. In

WITS'07, pages 164-177, 2007.

F. Pottier and Y. R'egis-Gianas. Extended static checking of call-by-value functional programs. Draft, July
2007. URL http://cristal.inria.fr/~fpottier/
publis/pottier-regis-gianas-escfp.ps.gz.

F. Pottier and V. Simonet. Information flow inference for ML.

ACM TOPLAS, 25(1):117-158, 2003.

F. Pottier, C. Skalka, and S. Smith. A systematic approach to access control. In Programming Languages and Systems (ESOP
2001), volume 2028 of LNCS, pages 30-45. Springer, 2001.

P. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. In Programming Language Design and Implementation (PLDI'08).
ACM, 2008. To appear.

J. Rushby, S. Owre, and N. Shankar. Subtypes for specifications:

Predicate subtyping in PVS. IEEE Transactions on Software
Engineering, 24(9):709-720, 1998.

A. Sabry and M. Felleisen. Reasoning about programs in

continuation-passing style. LISP and Symbolic Computation,
6(3-4):289-360, 1993.

E. Sumii and B. Pierce. A bisimulation for dynamic sealing. TCS,

375(1-3):169-192, 2007. Extended abstract at POPL'04.

D. Syme, A. Granicz, and A. Cisternino. Expert F#. Apress, 2007.
J. A. Vaughan and S. Zdancewic. A cryptographic decentralized

label model. In IEEE Symposium on Security and Privacy,
pages 192-206, Washington, DC, USA, 2007.

T. Woo and S. Lam. A semantic model for authentication protocols. In IEEE Symposium on Security and Privacy, pages
178-194, 1993.

H. Xi and F. Pfenning. Dependent types in practical programming.

In ACM Symposium on Principles of Programming Languages
(POPL'99), pages 214-227. ACM, 1999.

D. N. Xu. Extended static checking for Haskell. In ACM SIGPLAN

workshop on Haskell (Haskell'06), pages 48-59. ACM, 2006.