

SIAM J. COMPUT.

Vol. 6, No. 2, June 1977

FAST PATTERN MATCHING IN STRINGS*

DONALD E. KNUTHf, JAMES H. MORRIS, JR.:l: AND VAUGHAN R. PRATT

Abstract. An algorithm is presented which finds all occurrences of one. given string within
another, in running time proportional to the sum of the lengths of the strings. The constant of
proportionality is low enough to make this algorithm of practical use, and the procedure can also beextended

to deal with some more general pattern-matching problems. A theoretical application of the

algorithm shows that the set of concatenations of even palindromes, i.e., the language {can}*, can berecognized

in linear time. Other algorithms which run even faster on the average are also considered.

Key words, pattern, string, text-editing, pattern-matching, trie memory, searching, period of a
string, palindrome, optimum algorithm, Fibonacci string, regular expression

Text-editing programs are often required to search through a string ofcharacters looking for instances of

a given "pattern" string; we wish to find all
positions, or perhaps only the leftmost position, in which the pattern occurs as acontiguous substring of the text. For example,

c a e n a r y contains the pattern
e n, but we do not regard c a n a r y as a substring.The

obvious way to search for a matching pattern is to try searching at every
starting position of the text, abandoning the search as soon as an incorrectcharacter is found. But this approach can be very inefficient, for example when we

are looking for an occurrence of aaaaaaab in aaaaaaaaaaaaaab.When the

pattern is a"b and the text is a2"b, we will find ourselves making (n + 1)comparisons of characters. Furthermore, the traditional approach involves

"backing up" the input text as we go through it, and this can add annoyingcomplications when

we consider the buffering operations that are frequently
involved.In

this paper we describe a pattern-matching algorithm which finds all
occurrences of a pattern of length rn within a text of length n in O(rn + n) units oftime,

without "backing up" the input text. The algorithm needs only O(m)
locations of internal memory if the text is read from an external file, and onlyO(log m)

units of time elapse between consecutive single-character inputs. All ofthe
constants of proportionality implied by these "O" formulas are independentof
the alphabet size.

* Received by the editors August 29, 1974, and in revised form April 7, 1976.t Computer

Science Department, Stanford University, Stanford, California 94305. The work of
this author was supported in part by the National Science Foundation under Grant GJ 36473X and by

the Office of Naval Research under Contract NR 044-402.Xerox

Palo Alto Research Center, Palo Alto, California 94304. The work of this author was
supported in part by the National Science Foundation under Grant GP 7635 at the University of

California, Berkeley.

Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts 02139. The work of this author was supported in part by the National Science Foundation

under Grant GP-6945 at University of California, Berkeley, and under Grant GJ-992 at Stanford

University.

323

324 DONALD E. KNUTH, J/t.IVIES H. MORRIS, JR. AND VAUGHAN R. PRATI'

We shall first consider the algorithm in a conceptually simple but somewhat
inefficient form. Sections 3 and 4 of this paper discuss some ways to improve the

efficiency and to adapt the algorithm to other problems. Section 5 develops theunderlying theory, and 6

uses the algorithm to disprove the conjecture that a
certain context-free language cannot be recognized in linear time. Section 7
discusses the origin of the algorithm and its relation to other recent work. Finally,8 discusses

still more recent work on pattern matching.

1. Informal development. The idea behind this approach to pattern match-ing
is perhaps easiest to grasp if we imagine placing the pattern over the text andsliding

it to the right in a certain way. Consider for example a search for the patternabcabcacab

in the textbabcbabcabcaabcabcabcacabc; initially
we place the pattern at the extreme left and prepare to scan the leftmost characterof

the input text:

abc abc ac abbabc babc abcaabcabcabcacabc

The arrow here indicates the current text character; since it points to b, whichdoesn't match that

a, we shift the pattern one space right and move to the nextinput character:

abc abc ac ab
babc babc abcaabcabcabcacabc

Now we have a match, so the pattern stays put while the next several characters

are scanned. Soon we come to another mismatch"

abc abc ac ab
babc babc abcaabcabcabcacabc

At this point we have matched the first three pattern characters but not the fourth,
so we know that the last four characters of the input have been a b c x where x # a;
we don't have to remember the previously scanned characters, since ourposition inthe

pattern yields enough information to recreate them. In this case, no matter what xis (as long

as it's not a), we deduce that the pattern can immediately be shifted four
more places to the right; one, two, or three shifts couldn't possibly lead to a match.Soon

we get to another partial match, this time with a failure on the eighthpattern character:

abcabcacab
babc babc abc aabcabcabcaca bc

FAST PATTERN MATCHING IN STRINGS 325
Now we know that the last eight characters were a b c a b c a x, where x # c. Thepattern should therefore be

shifted three places to the right"

abc abc ac abbabcbabcabc aabc abcabcacabc

We try to match the new pattern character, but this fails too, so we shift the patternfour (not three

or five) more places. That produces a match, and we continue
scanning until reaching another mismatch on the eighth pattern character"

abc abc ac abba bcbabcabcaabc abc abc acabc

Again we shift the pattern three places to the right; this time a match is produced,and

we eventually discover the full pattern:

abc abc ac ab
ba bcbabcabcaa bc abc abc ac abc

The play-by-play description for this example indicates that the patternmatching process will run efficiently if we have an auxiliary table that tells usexactly how far to slide the pattern, when we detect a mismatch at its/'th character

pattern[if. Let next[f] be the character position in the pattern which should be

checked next after such a mismatch, so that we are sliding the pattern ] next[] ]places

relative to the text. The following table lists the appropriate values:

/'=1 2 3 4 5 6 7 8 9 10
pattern[f]=a b c a b c a c a b

next[f] O 1 1 0 1 1 0 5 0 1
(Note that next[j] 0 means that we are to slide the pattern all the way past thecurrent text character.) We shall discuss how to precompute this table later;
fortunately, the calculations are quite simple, and we will see that they requireonly O(m) steps.

At each step of the scanning process, we move either the text pointer or the
pattern, and each of these can move at most n times; so at most 2n steps need to beperformed, after the

next table has been set up. Of course the pattern itself doesn'treally
move; we can do the necessary operations simply by maintaining the pointer
variable ].

326 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

2. Programming the algorithm. The pattern-match process has the generalform

place pattern at left;while pattern

not fully matched
and text not exhausted do
beginwhile pattern character

differs from
current text characterdo shift

pattern appropriately;advance to next character of text;

end;
For convenience, let us assume that the input text is present in an array text[ 1" n ],

and that the pattern appears in pattern[1 :inf. We shall also assume that rn > 0,
i.e., that the pattern is nonempty. Let k and f be integer variables such that text[k]denotes the

current text character and pattern[f] denotes the correspondingpattern character; thus, the pattern

is essentially aligned with positions p + 1through
p + rn of the text, where k =p +f. Then the above program takes thefollowing simple form"

1:= k := 1;while/" _-< rn and k _-< n do

begin

while j > 0 and text[k] pattern[f]

do j := next[j];
k:=k+l;j:=j+l;end;

If/" > rn at the conclusion of the program, the leftmost match has been found inpositions k rn through k 1; but if/" <- m, the text has been exhausted. (The and
operation here is the "conditional and" which does not evaluate the relationtext[k] pattern[f] unless/" > 0.) The program has

a curious feature, namely that
the inner loop operation "j := next[f]" is performed no more often than the outerloop

operation "k := k + 1"; in fact, the inner loop is usually performed somewhatless often,

since the pattern generally moves right less frequently than the text
pointer does.To prove rigorously that the above program

is correct, we may use thefollowing
invariant relation" "Let p k-/" (i.e., the position in the text just
preceding the first character of the pattern, in our assumed alignment). Then wehave text[p+i]=pattern[i] for l=<i </" (i.e.,

we have matched the first f-1characters of the
pattern, if j >0); but for 0_-< <p we have text[t + if pattern[iffor
some i, where 1 -< -< rn (i.e., there is no possible match of the entire pattern tothe left of p)."

The program will of course be correct only if we can compute the next table sothat the above

relation remains invariant when we perform the operation
j := next[j]. Let us look at that computation now. When the program sets

FAST PATTERN MATCHING IN STRINGS 327
/" := next[f], we know that f > 0, and that the last/" characters of the input up to andincluding text[k] were

pattern[l].., pattern[j- 1] x
where x pattern If]. What we want is to find the least amount of shift for whichthese characters

can possibly match the shifted pattern; in other words, we wantnext[f]
to be the largest less than/" such that the last characters of the input were

pattern 1 ]... pattern 1] x
and pattern[i]pattern[f]. (If no such exists, we let next[i]=O.) With this
definition of next[f] it is easy to verify that text[t+l]...text[k]pattern[l] pattern[k 1] for k f <= < k next[f];

hence the stated relation isindeed invariant, and
our program is correct.Now
we must face up to the problem we have been postponing, the task ofcalculating next[f]

in the first place. This problem would be easier if we didn'trequire pattern[i] pattern[f]

in the definition of next[j], so we shall consider theeasier problem first. Let f[f] be the largest less than/"

such that pattern[l]...pattern[i- 1] pattern[f-i + 1] pattern[j- 1]; since this

condition holds vac-uously for 1,
we always have f[/'] >= 1 when/" > 1. By convention we let f[ 1] 0.The pattern used

in the example of 1 has the following f table:

/'=1 2 3 4 5 6 7 8 9 10
pattern[f]=a b c a b c a c a b

f[/']=0 1 1 1 2 3 4 5 1 2.

If pattern[j]=pattern[f[j]] then f[f+ 1]=f[j]+ 1; but if not, we can useessentially

the same pattern-matching algorithm as above to compute f[j + 1],
with text pattern! (Note the similarity of the f[j] problem to the invariant
condition of the matching algorithm. Our program calculates the largest j lessthan

or equal to k such that pattern[I].., pattern[j- 1] text[k-j+ 1]...text[k- 1],

so we can transfer the previous technology to the present problem.)The following program

will compute f[/" + 1], assuming that f[j] and next[l],next[j- 1] have already been calculated"

:=
while > 0 and pattern[j] pattern[t]do

t := next[t];f[/'+ 1] :=

t+ 1;

The correctness of this program is demonstrated as before; we can imagine two

copies of the pattern, one sliding to the right with respect to the other. Forexample, suppose

we have established that f[8]= 5 in the above case; let usconsider the
computation of ]'[9]. The appropriate picture is

abcabc acababc abcac ab

328 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

Since pattern[8] b, we shift the upper copy right, knowing that the most recentlyscanned characters of the lower copy

were a b c a x for x b. The next table tells
us to shift right four places, obtaining

abcabcacababcabcacab

and again there is no match. The next shift makes 0, so ]'[9] 1.Once we understand how to compute f, it is only a short step to the
computation of next[f]. A comparison of the definitions shows that, for/" > 1,

ff[j], if pattern[j] pattern[fir]f;next[f] next[f[j]],

if pattern [/'] pattern If[if].

Therefore we can compute the next table as follows, without ever storing thevalues of f[j]

in memory.

j := 1; := 0; next[l] := 0;while j < m do

begin comment t= f[/'];

while > 0 and pattern[j] pattern[t]

do t := next[t];:= t+l;/" :=/'+1;

if pattern [/'] pattern It]

then next[f] := next[t]
else next[j] := t;

end.

This program takes O(m) units of time, for the same reason as the matchingprogram takes O(n): the

operation := next[t] in the innermost loop always shiftsthe upper copy of the pattern

to the riglt, so it is performed a total of m times at
most. (A slightly different way to prove that the running time is bounded by a
constant times m is to observe that the variable starts at 0 and it is increased,

m- 1 times, by 1; furthermore its value remains nonnegative. Therefore theoperation := next[t],

which always decreases t, can be performed at most m- 1times.)

To summarize what we have said so far: Strings of text can be scanned
efficiently by making use of two ideas. We can precompute "shifts", specifyinghow

to move the given pattern when a mismatch occurs at its/'th character; and
this precomputation of "shifts" can be performed efficiently by using the sameprinciple, shifting the pattern against

itself.

3. Gaining efficiency. We have presented the pattern-matching algorithm in
a form that is rather easily proved correct; but as so often happens, this form is notvery

efficient. In fact, the algorithm as presented above would probably not becompetitive

with the naive algorithm on realistic data, even though the naive
algorithm has a worst-case time of order m times n instead of m plus n, because

FAST PATTERN MATCHING IN STRINGS 329
the chance of this worst case is rather slim. On the other hand, a well-implemented

form of the new algorithm should go noticeably faster because there is no backingup after

a partial match.It
is not difficult to see the source of inefficiency in the new algorithm aspresented above: When the alphabet of characters

is large, we will rarely have a
partial match, and the program will waste a lot of time discovering ratherawkwardly that text[k] pattern[l] for k 1, 2, 3, When/" 1 and text[k]

pattern[l], the algorithm sets/" := next[If=O, then discovers that/" =0, then

increases k by 1, then sets ] to 1 again, then tests whether or not 1 is <=m, and later

it tests whether or not 1 is greater than 0. Clearly we would be much better off

making/" 1 into a special case.The algorithm also spends unnecessary

time testing whether/" > m or k > n.A fully-matched
pattern can be accounted for by setting pattern[m + 1]= "@"for some impossible character @ that will never be matched, and by letting

next[m+l]=-l; then a test for/'<0 can be inserted into a less-frequentlyexecuted part of the code. Similarly we can for example

set text[n + 1] "_1_"(another impossible character) and text[n +2]=pattern[if,

so that the test fork >
n needn't be made very often. (See [17] for a discussion of such more or lessmechanical transformations on programs.)

The following form of the algorithm incorporates these refinements.

a := pattern 1];pattern[m + 1] := '@' next[m + 1] := -1;

text[n + 1] := '_t_' text[n + 2] := a;f:=k:= 1;
get started: comment/" 1;while text[k]

a do k := k + 1;
if k > n then go to input exhausted;char matched'/" := f + 1; k := k + 1;

loop: comment/" > 0;if text[k] pattern[f] then go to char matched;

] := next[f];i/" 1 then go to get started;

if f 0 then

begin] := 1; k := k+l;

go to get started;end;
if / 0 then go to loop;comment text[k- m] through text[k- 1] matched;

This program will usually run faster than the naive algorithm; the worst case
occurs when trying to find the pattern a b in a long string of a's. Similar ideas canbe used

to speed up the program which prepares the next table.In
a text-editor the patterns are usually short, so that it is most efficient totranslate

the pattern directly into machine-language code which implicitly contains the next table (cf. [3, Hack 179] and [24]). For example, the pattern in 1

330 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT
could be compiled into the machine-language equivalent of

L0: k:=k+l;LI:

if text[k] a then go to L0;.k := k+l;

if k > n then go to input exhausted;
L2: if text[k b then go to L1;k:=k+l;

L 3: if text[k] c then go to L1;k := k+l;

L4: if text[k] a then go to L0;k:=k+l;

L5: if text[k] b then go to L1;k:= k+l;

L6: if text[k] c then go to L1;k := k+l;

L7: if text[k] a then go to L0;k := k+l;

L8: if text[k] c then go to L5;k := k+l;

L9: if text[k] a then go to L0;k := k+l;

L10: if text[k] b then go to L1;k := k+l;

This will be slightly faster, since it essentially makes a special case for a//valuesof/.

It is a curious fact that people often think the new algorithm will be slower
than the naive one, even though it does less work. Since the new algorithm isconceptually hard

to understand at first, by comparison with other algorithms ofthe
same length, we feel somehow that a computer will have conceptual difficulties
toomwe expect the machine to run more slowly when it gets to such subtle
instructions!

4. Extensions. So far our programs have only been concerned with findingthe leftmost

match. However, it is easy to see how to modify the routine so that allmatches
are found in turn: We can calculate the next table for the extended
pattern of length m+l using pattern[re+if="@", and then we set

resume := next[m + 1] before setting next[m + 1] to -1. After finding a match anddoing whatever

action is desired to process that match, the sequence

/" := resume; go to loop;
will restart things properly. (We assume that text has not changed in the meantime. Note that resume cannot be zero.)Another approach would be

to leave next[m + 1] untouched, never changing
it to -1, and to define integer arrays head[1 :m ] and link[1 :n ] initially zero, and

to insert the code

link[k] := head[f]; head[j] := k;

FAST PATTERN MATCHING IN STRINGS 331
at label "char matched". The test "if/>0 then" is also removed from theprogram.

This forms linked lists for 1-</=<m of all places where the first /characters of the pattern (but

no more than/) are matched in the input.
Still another straightforward modification will find the longest initial match ofthe
pattern, i.e., the maximum/" such that pattern[l].., pattern[f] occurs in text.In practice, the text characters are often packed into words, with say b

characters per word, and the machine architecture often makes it inconvenient
to access individual characters. When efficiency for large n is important on such

machines, one alternative is to carry out b independent searches, one for eachpossible alignment of the pattern's first character in the word. These searches can

treat entire words as "supercharacters", with appropriate masking, instead ofworking

with individual characters and unpacking them. Since the algorithm Wehave
described does not depend on the size of the alphabet, it is well suited to thisand
similar alternatives.

Sometimes we want to match two or more patterns in sequence, finding anoccurrence of the

first followed by the second, etc.; this is easily handled by
consecutive searches, and the total running time will be of order n plus the sum ofthe individual pattern lengths.

We might also want to match two or more patterns in parallel, stopping assoon

as any one of them is fully matched. A search of this kind could be done with
multiple next and pattern tables, with one/" pointer for each; but this would makethe running

time kn plus the sum of the pattern lengths, when there are k patterns.Hopcroft and Karp have observed (unpublished) that

our pattern-matchingalgorithm
can be extended so that the running time for simultaneous searches is
proportional simply to n, plus the alphabet size times the sum of the patternlengths. The patterns are combined into a "trie" whose nodes represent all of the

initial substrings of one or more patterns, and whose branches specify the

appropriate successor node as a function of the next character in the input text.For example, if there are four patterns {a b

c a b, a b a b c, b c a c, b b c }, the trie isshown
in Fig. 1.

node

0

2

3
4

5
6
7

8
9
10

substring
a

abc
abca

aba

abab
b
bc

bca
bb

if if

7

2
10

7
abcab

6
10
10

7

2
10

if

0

0

3
0
bcac

0
ababc

8
0
bcac

bbc

FIG.
Such a trie can be constructed efficiently by generalizing the idea we used tocalculate next[f];

details and further refinements have been discussed by Aho and
Corasick [2], who discovered the algorithm independently. (Note that this

332 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

algorithm depends on the alphabet size; such dependence is inherent, if we wish tokeep the coefficient of

n independent of k, since for example the k patterns mighteach consist of
a single unique character.) It is interesting to compare thisapproach
to what happens when the LR(0) parsing algorithm is applied to theregular grammar Sa$lbSlcSlabcablababclbcaclbbc.

5. Theoretical considerations. If the input file is being read in "real time",
we might object to long delays between consecutive inputs. In this section we shallprove that the number of times/" := next[f]

is performed, before k is advanced, isbounded by a function of the approximate form log6

m, where 4 (1 +/)/21.618 is the golden ratio, and that this bound is best possible. We shall use

lower case Latin letters to represent characters, and lower case Greek lettersa,/3,..,

to represent strings, with e the empty string and [al the length of a. Thuslal- 1 for all characters

a; I t l- I1 +ltl; and [el =0. We also write a[k] for thekth character of
a, when 1-< k-< I 1,As a warmup for our theoretical discussion, let

us consider the Fibonacci
strings [14, exercise 1.2.8-36], which turn out to be especially pathologicalpatterns for the above algorithm. The

definition of Fibonacci strings is

(1) b=b, b=a; )n-")n_l)n_2 forn_->3.
For example, b3 a b, 4 a b a, 4 a b a a b. It follows that the length [b, is
the nth Fibonacci number Fn, and that 4n consists of the first F, characters of an
infinite string boo when n ->_ 2.

Consider the pattern 48, which has the functions f[/'] and next[f] shown inTable 1.

TABLE
/'=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21pattern[i]=a b

a a b a b a a b a a b a b a a b a b afl/']=0
1 2 2 3 4 3 4 5 6 7 5 6 7 8 9 10 11 12 8next[f]=O
1 0 2 1 0 4 0 2 0 7 1 0 4 0 2 1 0 12 0

If we extend this pattern to boo, we obtain infinite sequences f[j] and next[f]having the

same general character. It is possible to prove by induction that

(2) [[f]=f-G,- forFg <=f <Fk+l,

because of the following remarkable near-commutative property of Fibonaccistrings:

(3) l)n_2n_ C()n_l)n_2) for n ->- 3,
where c(a) denotes changing the two rightmost characters of a. For example,I6

a b a a b a b a and c(b6) a b a a b a a b. Equation (3) is obvious whenn=3; and for n>3

we have c(b_2b,_0=b,_eC(bn_l)=b,_.b_3b_:b,-lbn-: by induction;
hence c(b_:b,_l) c(c(qb-149,-:)) 9-19,-:.Equation (3)
implies that

(4) next[F 1] Fk-1 1 for k _-> 3.

FAST PATTERN MATCHING IN STRINGS 333
Therefore if we have a mismatch when/" Fs-1 20, our algorithm might set/" := next[f] for the

successive values 20, 12, 7, 4, 2, 1, 0 of/'. Since Fk is (b k/ff-)
rounded to the nearest integer, it is possible to have up to log m consecutive
iterations of the/" := next[f] loop.We shall

now show that Fibonacci strings actually are the worst case, i.e., thatlog,
m is also an upper bound. First let us consider the concept of periodicity instrings. We say that p

is a period of ce if

(5) a[i] ce[i +p] for 1 =<i =< I l-p,
It is easy to see that p is a period of ce if and only if

(6) a (ce lce2)kce
for some k =>0, where [alce2[ =p and ce2 E. Equivalently, p is a period of ce if andonly

if

(7) ce02 02ce
for some 02 and 02 with }021 1021 =p. Condition (6) implies (7) with 02 ce2cel and02

ce2ce2. Condition (7) implies (6), for we define k [Ic{/p] and observe that ifk >0, then ce 02/3 implies /302 02/3 and [IBI/P] k- 1; hence, reasoning

inductively, ce Ozce for some ce with Ice 21 < P, and ce 02 02ce i. Writing 02 ce lce2yields. (6).

The relevance of periodicity to our algorithm is clear once we consider what it
means to shift a pattern. If pattern[If.., pattern[f-1]=ce ends withpattern[if pattern[i-1]=/3,

we have

(8) ce fl01 02fl
where [02[ 102[ / i, so the amount of shift j is a period of ce.The

construction of next[j] in our algorithm implies further thatpattern[if,

which is the first character of 01, is unequal to pattern[j]. Let us assumethat/3
itself is subsequently shifted leaving a residue % so that

(9) /3 3'02 2'
where the first character of 02 differs frrn that of 02. We shall now prove that

(10)
if 1 1+1 1 1 1, there is an overlap of d=lfll+l l-I l characters between the
occurrences of fl and y in f102 =ce 0.0zy; hence the first character of 02 isy[d + 1]. Similarly there

is an overlap of d characters between the occurrences of/3 and 3/in 02/3
ce y0202; hence the first character of 02 is/3[d + 1]. Since thesecharacters
are distinct, we obtain y[d+ 1]fl[d+l], contradicting (9). This
establishes (10), and leads directly to the announced result:THzoz. The number of

consecutive times that ] := next[f] is performed,while
one text character is being scanned, is at most 1 + log6 m.Pro@ Let Lr be the length of the shortest

string ce as in the above discussionsuch that a sequence of
r consecutive shifts is possible. Then L 0, L2 1, and wehave 1[3l>=Lr_l, lyl>-L_2

in (10); hence La>-Fr+I 1 by induction on r. Now if rshifts occur
we have m -->E+l->b r-. [-1

334 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

The algorithm of 2 would run correctly in linear time even if f[/'] were used
instead of next[f], but the analogue of the above theorem would then be false. Forexample,

the pattern a leads to f [j] j 1 for 1 =< j =< m. Therefore if we matched
a to the text a"-lbce, using f[/'] instead of next[j], the mismatch text[m]pattern[m] would be followed by

m occurrences of j := f[/'] and m 1 redundantcomparisons of text[m] with pattern[j], before k is advanced to m + 1.

The subject of periods in strings has several interesting algebraic properties,but
a reader who is not mathematically inclined may skip to 6 since the following
material is primarily an elaboration of some additional structure related to theabove theorem.

LEMMA 1. If p and q are periods of ce, and p + q <-_ Ice[ + gcd(p, q), thengod(p, q)

is a period of a.Proof. Let d=gcd(p,q), and assume without loss of generality that

d <p < q p + r. We have a[i] a[i +p] for 1 _<- _<-Ice]-p and a[i] ce[i + q] for

l_<-i--< I[-q; hence c[i +r] [i +q] ce[i] for 1 +r<-i +r<=lcel-p, i.e.,

a[i]=a[i+r] for 1-<ill-q.
Furthermore a 01 02 where [01[ p, and it follows that p and r are periodsof/3, where p +

r -< 1/31+ d I/3[+ god(p, r). By induction, d is a period of/3. SinceI[ [al-p >=q -d >=q-r =p [0a], the strings 0a and Oz (which have the respective forms 21 and 12 by (6) and (7)) are substrings of/3; so they also have d as

a period. The string a (/3a/32)+/31 must now have d as a period, since anycharacters d positions apart are contained within 1/2 or/11. [[]

The result of Lemma 1 but with the stronger hypothesis p + q _-< Ice] wasproved by Lyndon and

Schiitzenberger in connection with a problem about freegroups [19, Lem. 4]. The weaker hypothesis in Lemma 1

turns out to give the bestpossible bound: If gcd(p,q)<p<q
we can find a string of lengthp +
q -god(p, q)- 1 for which god(p, q) is not a period. In order to see why this isso, consider first the example in Fig. 2 showing the

most general strings of lengths15 through 25 having both 11 and 15
as periods. (The strings are "most general"in the
sense that any two character positions that can be different are different.)

abc def ghi j ka bc d
abc daf ghi j ka bc. daabc dab

ghi ka bc dab
abc dabc hi j ka bc dabc
abc dabc di ka bc dabc d

abc dabc daj ka bc dabc da
abc dabc dab ka bc dabc dab

ab c dab c dab c a b c dab c dab c

ab c aab c aabc a bc aab c aab c a
aac aaac aaac a ac aaac aaac aa

aaaaaaaaaaaa aaaaaaaaaaaaa

FIG. 2
Note that the number of degrees of freedom, i.e., the number of distinct symbols,decreases by 1

at each step. It is not difficult to prove that the number cannotdecrease by
more than 1 as we go from lal n- 1 to I 1- n, since the only new

FAST PATTERN MATCHING IN STRINGS 335
relations are a[n]=a[n-q]=a[n-p]; we decrease the number of distinctsymbols by

one if and only if positions n -q and n -p contain distinct symbols inthe
most general string of length n 1. The lemma tells us that we are left with at
most god(p, q) symbols when the length reaches p + q-god(p, q); on the otherhand

we always have exactly p symbols when the length is q. Therefore each of thep-god(p, q)

steps must decrease the number of symbols by 1, and the mostgeneral string of length p +q- gcd(p, q)-1

must have exactly god(p, q)+ 1 dis-tinct symbols. In other words, the lemma
gives the best possible bound.When p and q are relatively prime, the strings of length p + q- 2

on twosymbols, having both p and
q as periods, satisfy a number of remarkableproperties, generalizing what we have observed

earlier about Fibonacci strings.Since the properties of these pathological patterns may prove useful

in otherinvestigations,
we shall summarize them in the following lemma.LEMMA 2. Let the

strings r(m, n) of length n be definedfor all relatively primepairs of integers n >= m >= 0 as follows:

r(0, 1) a, o,(1, 1) b, r(1, 2) ab;
r(m, m + n) r(n mod m, m)r(m, n) )(11)

cr(n,m+n)=cr(m,n)r(n modm, m) ifO<m<n.
These strings satisfy the ]ollowing properties:(i) r(m,

qm + r)r(m r, m) r(r, m)r(m, qm + r), for m > 2;(ii) r(m, n) has period m, for

m > 1;(iii) c(r(m, n))=r(n -m, n), for

n > 2.(The function c(a) was defined
in connection with (3) above.)Proof. We have, for 0 <
m < n and q => 2,

r(m + n, q(m + n)+ m) r(m, m + n) r(m + n, (q- 1)(m + n)+ m),

r(m +n, q(m +n)+n)=r(nm +n) r(m +n, (q-1)(m +n)+n),

r(m + n, 2m + n)= r(m, m + n) o,(n mod m, m),
cr(m + n, m + 2n) o'(n, m + n) o-(m, n);
hence, if 01 o-(n mod m, m) and 02 o-(m, n) and q _-> 1,

(12) o-(m+n,q(m+n)+m)=(OxOz)q01, r(m+n,q(m+n)+n)=(OzO1)qOz.
It follows that

o-(m +n, q(m +n)+m)o-(n, m + n)= o-(m, m +n) o'(m +n, q(m +n)+m),
o'(m + n, q(m + n)+ n)o'(m, m + n)= o(n, m + n)o'(m + n, q(m + n)+ n),

which combine to prove (i). Property (ii) also follows immediately from (12),

except for the case m 2, n 2q + 1, or(2, 2q + 1) (ab)'a, which may be verifieddirectly. Finally, it suffices to verify property (iii) for 0 < m < 1/2n, since c(c(a)) a;

we must show that

c(tr(m,m+n))=tr(m,n)o'(n modm, m) forO<m<n.

336 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

When m <= 2 this property is easily checked, and when rn > 2 it is equivalent by

induction to

r(m,m+n)=r(m,n)cr(m-(nmodm),m) for0<m<n, m>2.
Set n mod rn r, [n/m q, and apply property (i).By

properties (ii) and (iii) of this lemma, r(p, p +q) minus its last twocharacters is the string of length p + q-2 having periods

p and q. Note thatFibonacci strings are just a very special case, since b,, =cr(F,_a, F,). Another

property of the o- strings appears in 15]. A completely different proof of Lemma 1and its optimality, and a completely different definition of r(m, n),

were given byFine and Will in 1965 [7]. These strings have a long history going back

at least tothe
astronomer Johann Bernoulli in 1772; see [25, 2.13] and [21].If

c is any string, let P(c) be its shortest period. Lemma 1 implies that allperiods

q which are not multiples of P(a) must be greater than lal-P(a)+gcd(q, P(a)). This is

a rather strong condition in terms of the pattern matchingalgorithm, because of the following result.

LEMMA 3. Let a pattern [ 1]... pattern [f 1] and let a pattern [/']. In the
pattern matching algorithm, f[/']=/'-P(a), and next[f]=f-q, where q is thesmallestperiod of

a which is not a period o[aa. (Ifno such period exists, next[f] 0.)If P(a) divides P(ca) and P(aa) < f, then P(a)= P(aa). If P(a) does

not divideP(aa)
or if P(aa)=L then q =P(a).Proof. The

characterizations of f[/'] and next[f] follow immediately from the
definitions. Since every period of aa is a period of a, the only nonobvious

statement is that P(a)= P(aa) whenever P(a) divides P(aa) and P(cea) f. LetP(a)

=p and P(aa)= rap; then the (mp)th character from the right of c is a, as isthe (m- 1)pth, as is the pth; hence p is a period of

aa.Lemma 3 shows that the/" := next[j] loop
will almost always terminatequickly. If P(a) P(aa), then q
must not be a multiple of P(a); hence by Lemma1, P(a)+q
>=j + 1. On the other hand q >P(a); hence q >1/2j and next[j]<1/2/. Inthe other case q P(a),

we had better not have q too small, since q will be a periodin the residual pattern after

shifting, and next[next[ill will be <q. To keep theloop running it is necessary for

new small periods to keep popping up, relativelyprime
to the previous periods.

6. Palindromes. One of the most outstanding unsolved questions in thetheory of

computational complexity is the problem of how long it takes todetermine whether or

not a given string of length n belongs to a given context-freelanguage. For many
years the best upper bound for this problem was O(n 3) in ageneral context-free language as

n c; L. G. Valiant has recently lowered this toO(n og7). On the other hand, the problem

isn't known to require more than order
n units of time for any particular language. This big gap between O(n) andO(n 2.8a) deserves

to be closed, and hardly anyone believes that the final answerwill be O (n).

Let be a finite alphabet, let Z* denote the strings over , and let

P {aa R ]a e E*}.
Here cr denotes the reversal of a, i.e., (a,a2 a,) a, azal. Each string

7r in P is a palindrome of even length, and conversely every even palindrome over

FAST PATTERN MATCHING IN STRINGS 337
is in P. At one time it was popularly believed that the language P* of "evenpalindromes starred", namely the

set of palstars 7rl rn where each 7ri is in P,would
be impossible to recognize in O(n) steps on a random-access computer.It

isn't especially easy to spot members of this language. For example,
a a b b a b b a is a palstar, but its decomposition into even palindromes might notbe immediately apparent; and the reader might need several minutes to decide

whether or not

baabbabbaababbaabbabbabaa

bbabbabbabbaabababbabbaab
is in P*. We shall prove, however, that palstars can be recognized in O(n) units of

time, by using their algebraic properties.Let us say that a nonempty palstar is prime if it cannot be written as the

product of two nonempty palstars. A prime palstar must be an even palindromeR

act but the converse does not hold. By repeated decomposition, it is easy to seethat every palstar/ is expressible as a product fll fit of prime palstars, for

some >= 0; what is less obvious is that such a decomposition into prime factors isunique. This "fundamental theorem of palstars" is an immediate consequence of
the following basic property.LEMMA 1. A

prime palstar cannot begin with another prime palstar.Proof. Let
ta R be a prime palstar such that aO R Ry for some nonempty
even palindrome flflR and some y # e; furthermore, let R have minimumlength among all such counterexamples. If then

aa R= flflR3,=a6y

for some 6 e; hence a R 6% and flflR (flflR)R (a6)n 8RaR 6R6% con-tradicting the minimality of [flflR I. Therefore IflflR[<--__[al; hence

a =flflg6 for

some 8, and flflg,y OgoR__ RRR. But this implies that y is the palstarRR, contradicting the primality of

COROLLARY (Left cancellation property.) If aft and or'are palstars, so is ft.Proof. Let

a a a and a[3 fla fl be prime factorizations of a andaft. If

al a fll fl, then fl fl+l.., fl is a palstar. Otherwise let jbe minimal with a. fli; then

ai begins with fli or vice versa, contradictingLemma 1.

LEMMA 2. Ifo is a string of length n, we can determine the length ofthe longest
even palindrome fl P such that a fl'y, in O(n steps.Proof. Apply the pattern-matching algorithm with pattern

a and text ct R.

When k-n+1 the algorithm will stop with j maximal such thatpattern[i] pattern [j- 1] text[n + 2-j] text[n]. Now perform the following iteration:

while j ->_ 3 and/" even do j := f(j).

By the theory developed in 3, this iteration terminates with/" -> 3 if and on(y
if t begins with a nonempty even palindrome, and/"- 1 will be the length of thelargest such palindrome. (Note that ]'[] must be used here instead of next[]]; e.g.

consider the case a a b a a b. But the pattern matching process takes O(n)

time even when [[f] is used.)THEOREM. Let L be any language such that L* has the left cancellation

property and such that, given any string ct of length n, we can find a nonempty L

338 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT
such that a begins with or we can prove that no such exists, in O(n steps. Then

we can determine in O(n time whether or not a given string is in L*.Proofi Let

a be any string, and suppose that the time required to test or
nonempty prefixes in L is <-Kn for all large n. We begin by testing a's initialsubsequences of lengths 1, 2, 4, ..., 2, ..., and finally

a itself, until finding a
prefix in L or until establishing that a has no such prefix. In the latter case, a is notin L*, and we have consumed at most (K + Ka) + (2K + Ka) + (4K + Ka) +" +

(]a [K + Ka) < 2Kn + Ka log n units of time for some constant Ka. But if we find anonempty prefix/3 L where

a fly, we have used at most 41 [K + K(log2 [/3 [)
units of time so far. By the left cancellation property, a L* if and only if y L*,and

since [71 n -I/31 we can prove by induction that at most (4K + Ka)n units of
time are needed to decide membership in L*, when n > 0. UCOROLLARY. P* can be recognized in O(n) time.

Note that the related language

P* (Tr Y-,* 17r 7r and e 2}*
cannot be handled by the above techniques, since it contains both a a a b b b and

a a a b b b b a; the fundamental theorem of palstars fails with a vengeance. It is
an open problem whether or not PI* can be recognized in O(n) time, although we

suspect that it can be done. Once the reader has disposed of this problem, he orshe is urged

to tackle another language which has recently been introduced by S.A.
Greibach [ 11], since the latter language is known to be as hard as possible; nocontext-free language

can be harder to recognize except by a constant factor.

7. Historical remarks. The pattern-matching algorithm of this paper was
discovered in a rather interesting way. One of the authors (J. H. Morris) wasimplementing

a text-editor for the CDC 6400 computer during the summer of1969,
and since the necessary buffering was rather complicated he sought amethod that would

avoid backing up the text file. Using concepts of finite
automata theory as a model, he devised an algorithm equivalent to the methodpresented above, although

his original form of presentation made it unclear thatthe
running time was O(m + n). Indeed, it turned out that Morris's routine was toocomplicated for other implementors of the system

to understand, and he dis-covered several months later that
gratuitous "fixes" had turned his routine into ashambles.

In a totally independent development, another author (D. E. Knuth) learnedearly in 1970 of S. A. Cook's surprising theorem about two-way deterministic
pushdown automata [5]. According to Cook's theorem, any language recognizable by a two-way deterministic pushdown automaton, in any amount of time,

can be recognized on a random access machine in O(n) units of time. Since D.Chester had recently shown that the

set of strings beginning with an evenpalindrome could be recognized by such an

automaton, and since Knuth couldn'timagine how to recognize such a language in less than about

n 2 steps on aconventional computer, Knuth laboriously went through all the steps of Cook's

construction as applied to Chester's automaton. His plan was to "distill off" what

(Note added April, 1976.) Zvi Galil and Joel Seiferas have recently resolved this conjecture
affirmatively.

FAST PATTERN MATCHING IN STRINGS 339
was happening, in order to discover why the algorithm worked so efficiently. Afterpondering the

mass of details for several hours, he finally succeeded in abstractingthe mechanism

which seemed to be underlying the construction, in the special caseof palindromes, and he generalized

it slightly to a program capable of finding thelongest
prefix of one given string that occurs in another.This was the

first time in Knuth's experience that automata theory had taughthim how
to solve a real programming problem better than he could solve it before.He showed

his results to the third author (V. R. Pratt), and Pratt modified Knuth'sdata
structure so that the running-time was independent of the alphabet size.When Pratt

described the resulting algorithm to Morris, the latter recognized it ashis own, and

was pleasantly surprised to learn of the O(m + n) time bound, whichhe and Pratt
described in a memorandum [22]. Knuth was chagrined to learn thatMorris had already

discovered the algorithm, without knowing Cook's theorem;but the theory of
finite-state machines had been of use to Morris too, in his initialconceptualization of the algorithm,

so it was still legitimate to conclude that
automata theory had actually been helpful in this practical problem.The

idea of scanning a string without backing up while looking for a pattern,
in the case of a two-letter alphabet, is implicit in the early work of Gilbert [10]dealing with comma-free codes. It also

is essentially a special case of Knuth'sLR(0) parsing algorithm [16] when applied

to the grammar

for each a in the alphabet,

where a is the pattern. Diethelm and Roizen [6] independently discovered the

idea in 1971. Gilbert and Knuth did not discuss the preprocessing to build the nexttable,

since they were mainly concerned with other problems, and the pre-processing algorithm given by Diethelm and

Roizen was of order rn 2. In the caseof
a binary (two-letter) alphabet, Diethelm and Roizen observed that the
algorithm of 3 can be improved further" we can go immediately to "charmatched" after/" := next[j] in this case

if next[j] > O.A conjecture by R. L.
Rivest led Pratt to discover the log6 rn upper bound onpattern
movements between successive input characters, and Knuth showed thatthis was best possible by

observing that Fibonacci strings have the curiousproperties proved in 5. Zvi Galil has observed that a real-time algorithm can be

obtained by letting the text pointer move ahead in an appropriate manner whilethe f pointer

is moving down [9].In
his lectures at Berkeley, S. A. Cook had proved that P* was recognizablein O(n log n) steps

on a random-access machine, and Pratt improved this to O(n)using a preliminary form of the ideas

in 6. The slightly more refined theory in thepresent
version of 6 is joint work of Knuth and Pratt. Manacher [20] foundanother way

to recognize palindromes in linear time, and Galil [9] showed how to
improve this to real time. See also Slisenko [23].It seemed

at first that there might be a way to find the longest commonsubstring of
two given strings, in time O(m + n); but the algorithm of this paperdoes
not readily support any such extension, and Knuth conjectured in 1970 thatsuch
efficiency would be impossible to achieve. An algorithm due to Karp, Miller,and Rosenberg [13] solved the problem in O((m + n) log (m + n)) steps, and this

340 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT
tended to support the conjecture (at least in the mind of its originator). However,Peter

Weiner has recently developed a technique for solving the longest commonsubstring problem

in O(m + n) units of time with a fixed alphabet, using tree
structures in a remarkable new way [26]. Furthermore, Weiner's algorithm hasthe following interesting consequence,

pointed out by E. McCreight" a text file canbe processed (in linear time) so that it is possible

to determine exactly how much of
a pattern is necessary to identify a position in the text uniquely; as the pattern isbeing typed

in, the system can be interrupt as soon as it "knows" what the rest ofthe pattern must be! Unfortunately the time and space requirements for Weiner's

algorithm grow with increasing alphabet size.If

we consider the problem of scanning finite-state languages in general, it is
known [1 9.2] that the language defined by any regular expression of length

m is recognizable in O(mn) units of time. When the regular expression has theform

the algorithm we have discussed shows that only O(m + n) units of time areneeded (considering *

as a character of length 1 in the expression). Recent workby M. J.
Fischer and M. S. Paterson [8] shows that regular expressions of the form

i.e., patterns with "don't care" symbols, can be identified inO(n log rn log log rn log q) units of time, where q is the alphabet size and rn

[cela2 cer[+ r. The constant of proportionality in their algorithm is extremelylarge, but the existence of their construction indicates that efficient new
algorithms for general pattern matching problems probably remain to be dis-covered.

A completely different approach to pattern matching, based on hashing, hasbeen proposed by Malcolm C.

Harrison [12]. In certain applications, especially
with very large text files and short patterns, Harrison's method may be significantly faster than the character-comparing method of the present paper, on theaverage, although the redundancy of English makes the performance of his

method unclear.

8. Postscript: Faster pattern matching in strings.2 In the spring of 1974,Robert S. Boyer and J.

Strother Moore and (independently) R. W. Gosper noticedthat there
is an even faster way to match pattern strings, by skipping more rapidly
over portions of the text that cannot possibly lead to a match. Their idea was tolook

first at text[m], instead of text[l]. If we find that the character text[m] does
not appear in the pattern at all, we can immediately shift the pattern right rnplaces. Thus, when the alphabet

size q is large, we need to inspect only about n/rn
characters of the text, on the average! Furthermore if text[m] does occur in thepattern,

we can shift the pattern by the minimum amount consistent with a match.

This postscript was added by D. E. Knuth in March, 1976, because of developments which
occurred after preprints of this paper were distributed.

FAST PATTERN MATCHING IN STRINGS 341
Several interesting variations on this strategy are possible. For example, iftext[m] does

occur in the pattern, we might continue the search by looking attext[m 1], text[m 2], etc.; in

a random file we will usually find a small value of r
such that the substring text[m- r] text[m] does not appear in the pattern, so
we can shift the pattern m-r places. If r- [2 logq m J, there are more than m 2possible values of text[m r]... text[m ], but only m

r substrings of length r + 1
in the pattern, hence the probability is O(1/m) that text[m r] text[m] occurs

in the pattern; If it doesn't, we can shift the pattern right m r places; but if it does,
we can determine all matches in positions <m-r in O(m) steps, shifting thepattern

m-r places by the method of this paper. Hence the expected number ofcharacters examined among the first m [2 logq m is O(1ogq m); this proves the

existence of a linear worst-case algorithm which inspects O(n (1Ogq m)/m) characters in a random text. This upper bound on the average running time applies to allpatterns, and there are

some patterns (e.g., a or (a b)'/2) for which the expectednumber of characters
examined by the algorithm is O(n/m).Boyer and Moore have

refined the skipping-by-m idea in another way. Theiroriginal algorithm may be expressed

as follows using our conventions:

while k _-< n dobegin

]:=m;while j > 0 and text[k] =pattern[j] do

beginf:=f-1;k:=k-1;

end;if ] 0 then
beginmatch foundat (k);

k:=k+m+l
end elsek := k +

max (d[text[k]], dd[j]);

end;

This program calls match found at (k) for all O<=k<-n-m such thatpattern[l].., pattern[m] text[k + 1] text[k + m]. There are two precomputed tables, namely

d[a] min {sis m or (0 _-< s < m and pattern[m s] a)}
for each of the q possible characters a, and

dd[j] min {s + m -j s >-- 1 and((s_-> 1 or pattern[i-s]=pattern[i]) for j <i =<m)},

for 1 _<-/" _-<m.

342 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

The d table can clearly be set up in O(q + rn) steps, and the dd table can beprecomputed

in O(m) steps using a technique analogous to the method in 2above, as
we shall see. The Boyer-Moore paper [4] contains further exposition of
the algorithm, including suggestions for highly efficient implementation, and givesboth theoretical and

empirical analyses. In the remainder of this section we shallshow how the above methods can be used to resolve some of the problems left

open in [4].First let

us improve the original Boyer-Moore algorithm slightly by replacingdd[f] by

dd'[f] min {s + rn -j s => 1 and (s >=j or pattern[f-s] # pattern[f])and ((s

=>i or pattern[i-s] pattern[i]) for j <i =< m)}.

(This is analogous to using next[j] instead of f[j]; Boyer and Moore [4] credit theimprovement in this case to Ben Kuipers, but they do

not discuss how todetermine dd' efficiently.) The following program shows how the dd' table can be

precomputed in O(m) steps; for purposes of comparison, the program also showshow to compute dd, which actually

turns out to require slightly more operationsthan dd'

for k := 1 step 1 until rn do dd[k] := dd'[k] := 2 x rn- k;
j:=m;t:=m+l;while/" > 0 do

beginfEi] :=

t;while =<

rn and pattern[j] pattern[t] dobegin

dd'[t] := min (dd'[t], rn-/');:=/It];
end;t:=t-1;f:=f-1;
dd[t] := min (dd[t], rn-/');end;
for k := 1 step 1 until t do

begindd[k] :=

min (dd[k], m + t- k);dd'[k ] :=

min dd'[k ], rn + t- k);end;

In practice one would, of course, compute only dd', suppressing all references todd. The example

in Table 2 illustrates most of the subtleties of this algorithm.

TABLE 2
j=l 2 3 4 5 6pattern[j]

b a d b a cf[j]=10

11 6 7 8 9dd[j]=19
18 17 16 15 8dd'[/']=19

18 17 16 15 8

7 8 9 10 11

b a c b a

10 11 11 11 12
7 6 5 4

13 12 8 12

FAST PATTERN MATCHING IN STRINGS 343
To prove correctness, one may show first that f[]] is analogous to the f[]] in 2,but

with right and left of the pattern reversed; namely f[m m + 1, and for ] < m
we have

]'[]3 min {i IJ < -<_ m andpattern[i + 1] pattern[m] =pattern[] + 1]... pattern[m +]-i]}.

Furthermore the final value of corresponds to f[0] in this definition; m is the
maximum overlap of the pattern on itself. The correctness of dd[j] and dd'[j] forall

j now follows without much difficulty, by showing that the minimum value of sin the definition of dd[]o]

or dd'[jo] is discovered by the algorithm when(t,j)=(jo, jo-s).

The Boyer-Moore algorithm and its variants can have curiously anomalous
behavior in unusual circumstances. For example, the method discovers morequickly that the pattern

a a a a a a a c b does not appear in the text (a b)" if itsuppresses the d
heuristic entirely, i.e., if d[t] is set to -oo for all t. Likewise, ddactually
turns out to be better than dd' when matching a 15 b c b a b a b in(b
a a b a b)", for large n.Boyer and Moore showed that

their algorithm has quadratic behavior in the
worst case; the running time can be essentially proportional to pattern length

times text length, for example when the pattern c a (b a)" occurs together with the

text (x TM a a(b a)")". They observed that this particular example was handled in

linear time when Kuiper's improvement (dd' for dd) was made; but they left openthe

question of the true worst case behavior of the improved algorithm.There are trivial cases in which the Boyer-Moore algorithm has qladratic

behavior, when matching all occurrences of the pattern, for example whenmatching the pattern a" in the text a". But we are probably willing to accept such

behavior when there are so many matches; the crucial issue is how long the

algorithm takes in the worst case to scan over a text that does not contain thepattern at all. By extending the techniques of 5, it is possible to show that the

modified Boyer-Moore algorithm is linear in such a situation:THEOREM. ff the above algorithm

is used with dd' replacing dd, and if the textdoes
not contain any occurrences of the pattern, the total number o]: charactersmatched

is at most 6n.Proof. An

execution of the algorithm consists of a series of stages, in which mkcharacters
are matched and then the pattern is shifted Sk places, for k 1, 2,We
want to show that Y mk <= 6n; the proof is based on breaking this cost intothree parts,

two of which are trivially O(n) and the third of which is less obviously
SO. Let

m , mk 2Sk if mk > 2Sk otherwise let m , 0. When m , > 0, we will saythat the leftmost m,

text characters matched during the kth stage have been"tapped". It
suffices to prove that the algorithm taps characters at most 4n times,
since Y. mk <= mk + 2 Y. Sk and Y'. Sk <--_n. Unfortunately it is possible for somecharacters of the

text to be tapped roughly log m times, so we need to arguecarefully that
m ,_-< 4n.Suppose the

rightmost m' of the m , text characters tapped during the kthstage
are matched again during some later stage, but the leftmost m ,-m/,' are

344 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

being matched for the last time. Clearly (kn ,- m') =< n, so it remains to show thatm[,'<-_3n.

Let Pk be the amount by which the pattern would shift after the kth stage if thed[a]

heuristic were not present (d[a ] -c); then p -< s, and p is a period of the
string matched at stage k.Consider a value of k such that m/,' > 0, and suppose that the text characters

matched during the kth stage form the string ce =alaZ where lal=m and[cezl m;,' + 2s; hence

the text characters in a are matched for the last time. Sincethe pattern does
not occur in the text, it must end with xa and the text scanned sofar
must end with za, where x z. At this point the algorithm will shift the patternright

sk positions and will enter stage k + 1. We distinguish two cases: (i) Thepattern length rn exceeds m +pg. Then the pattern can be written O3a, where

It l pg; the last character of/3 is x and the last character of 0 is y x, by definitionof dd'. Otherwise (ii) rn =< m +pk; the pattern then has the form/3a, where

[/31 <--p <_-s. By definition of m;,' and the assumption that the pattern does notoccur in the text, we have It'll /1 21, i.e., It l In both cases (i) and
(ii), p is a period ofNow consider the

first subsequent stage k' during which the leftmost of thetext characters tapped during stage k

is matched again; we shall write k k' whenthe stages
are in this relation. Suppose the mismatch occurs this time when textcharacter z'

fails to m.atch pattern character x'. If z' occurs in the text within tel,regarding
ce as fixed in its stage k position, then x' cannot be within/ce where
now occurs in the stage k' position of the pattern, since Pk is a period of/a and thecharacter

Pk positions to the right of x' is a z' (it matches a z' in the text). Thus x'now appears within 0. On the other hand, if z' occurs to the left of a, we must have

]cel 0, since the characters of ce are never matched again. In either event, case(ii) above proves to be impossible. Hence case (i) always occurs when m' > 0, and
x' always appears within 0.To complete the argument,

we shall show that -,k-.k' m[; for all fixed k', is at
most 3Sk,. Let p' =Pk' and let a' denote the pattern matched at stage k'. Letk <...<k be the values of k such that k-k'. If Io'l+p'<-_m, let/'a' be the

rightmost p' +la'l characters of the pattern. Otherwise let a" be the leftmostla'l +p'-m characters of a'; and let/3'a' be a" followed by the pattern. Note that

in both cases a' is an initial substring of J'a' and I/'] P'. In both cases, the actionsof the algorithm during stages k + 1 through k'

are completely known if we are
given the pattern and/', and if we know z' and the place within/3' where stagek + 1

starts matching. This follows from the fact that fl' by itself determines
the text, so that if we match the pattern against the string z'fl'fl'fl'... (starting atthe specified place for

stage k + 1) until the algorithm first tries to match z' we willknow the length of a'. (If Ic'l < p' then/3' begins with a' and this statement holds

trivially; otherwise, a' begins with fl' and has period p'; hence fl'fl'fl'.., beginswith a'.) Note that the algorithm cannot begin two different stages at exactly the

same position within/3', for then it would loop indefinitely, contradicting the factthat

it does terminate. This property will be out key tool for proving the desiredresult.

Let the text strings matched during stages kl, kr be 01, Or, and let
their periods determined as in case (i) be p p respectively; we have pi <

FAST PATTERN MATCHING IN STRINGS 345
for 1 _-</" =< r. Suppose that during stage kj the mismatch of xj # zi implies that the
pattern ends with yi/3icei, where [fljl Pi. We shall prove that [a 1[ +" + leer[-< 3p'.
First let us prove that I ;I <p' for all j: We have observed that x' always occurs
within 0; hence y/3a occurs as a rightmost substring of x'a'. If I ,1 >--p' thenp +p'--< [flal; hence the character p positions

to the right of yi in x'a' is xi, as isthe character p + p'
positions to the right of yi. But the character p' positions to theright of y in x'ce' is a

yj, since p' is a period of x'ce'; hence the character p' +pipositions to the right of y is also y, contradicting x #

yj.Since Iceil < P', each string

cei for j >- 2 appears somewhere within fl', when fl'is regarded as a cyclic string, joined end-for-end. (It follows from the definition of

k k' that zce is a substring of ce' for/" => 2.) We shall prove that the rightmosthalves of these strings, namely the rightmost [1/21ceil] characters as they appear in

fl', are disjoint. This implies that 1/21cel+... +1/21cerl <--P', and the proof will becomplete (since Ice 11----- P').

Suppose therefore that the right half of the appearance of cei overlaps the
right half of the appearance of cei within/3', for some /" >= 2, where the rightmostcharacter of

cei is within cei. This means that the algorithm at stage kg begins tomatch characters starting within

cei at least pi characters to the right of zj where
zicei appears in fl', when the text ce' is treated modulo p'. (Recall that pi <The pattern ends with

xicej, and pj is a period of xlai. The algorithm must workcorrectly when the text equals the pattern, so there must come a stage, before

shifting the pattern to the right of the appearance of cej, where the algorithm scansleft until hitting

zi. At this point, call it stage k", there must be a mismatch ofz. x., since
Pi or more characters have been matched. (The character pi positionsto the right of z. is x., by periodicity.) Hence k" < k'; and it follows that k" kg. (If

k"> k we have zcei entirely contained within ce", but then k k' implies thatk"= k'.) Now k"= k implies that

zi z and xi x. We shall obtain a contradic-tion by showing that the algorithm "synchronizes" its stage k + 1 behavior with its

stage k. + 1 behavior, modulo p', causing an infinite loop as remarked above. Themain point is that the dd' table will specify shifting the pattern

pi steps, so that yi isbrought into the position corresponding to
zj, in stage k as well as in stage ki. (Anylesser shift brings an x. into position
pi spaces to the right of zi; hence it puts y xiinto the position corresponding to

zi, by periodicity, contradicting xi y.) Theamount of shift depends on the maximum of the d and dd' entries, and the d entry

will be chosen (in either k or ki) if and only if zi is not a character of fli; but in thiscase, the d entry

will also specify the same shift both for stage ki and stage k..The
constant 6 in the above theorem is probably much too large, and theabove proof

seems to be much too long; the reader is invited to improve the
theorem in either or both respects. An interesting example of the rather complexbehavior possible

with this algorithm occurs when the pattern is bO and the text isOa4r for large
r, where

COROLLARY. The worst case running time ofthe Boyer-Moore algorithm withdd' replacing dd

is O(n + rm character comparisons, if the pattern occurs r times inthe
text.Proof. Let T(n, r) be the worst case running time as a function of

n and r,

346 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT
when m is fixed. The theorem implies that T(n, 0) -< 7n, counting the mismatchedcharacters

as well as the matched ones. Furthermore, if r >0 and if the firstappearance of the pattern ends

at position no we have T(n, r)_-<7(no 1)+m+ T(n no +
m 1, r- 1). It follows that T(n, r) <- 7n + 8rm 14r. [-]When the Boyer-Moore algorithm implicitly shifts the pattern to the right, it

forgets all it "knows" about characters already matched; this is why the linearitytheorem is not trivial. A more complex algorithm can be envisaged, with a finite

number of states corresponding to which text characters are known to match thepattern

in its current position; when in state q we fetch the character x := text[kt[q]], then we set k := k + s[q, x] and go to state q'[q, x]. For example, consider

the pattern a b a c b a b a, and the specification of t, s, and q' in Table 3; exactly 41distinguishable

states can arise. An asterisk (*) in that table shows where thepattern has been fully matehed.

The number of states in this generalization of the Boyer-Moore algorithmcan be rather large,

as the example shows, but the patterns which occur most often
in practice probably do not imply many states. The number of states is always lessthan 2", and perhaps

a much smaller upper bound is possible; it is unclear which
patterns of a given length lead to the most states, and it does not seem obvious thatthis maximum number of states is exponential in rn.

If the characters of the pattern are distinct, say a laz a,, this generalization of the Boyer-Moore algorithm leads to exactly 1/2(m 2+ m) states. (Namely,all states of the form o...

ak ... ai+1 a,, for 0-<_k <]-<_m, with aksuppressed if k 0.) By merging several of these states we obtain the following

simple algorithm, which uses a table c[x] where

The algorithm works only when all pattern characters are distinct, but it improvesslightly

on the Boyer-Moore technique in this important special case.f:=k:=m;

while k _-< n do

begin := c[text[k]];if < 0 then ] :=

melse if 0 then

begin for := 1 step 1 until m- 1 doif text[k i] pattern[m i] then go to nomatch;

match found at (k m);nomatch:/" :=

rn;end else if
+j _> m then ] := else j := m;k := k +];

end;Let
us close this section by making a preliminary investigation into the
question of "fastest" pattern matching in strings, i.e., optimum algorithms. Whatalgorithm minimizes the number of

text characters examined, over all conceivablealgorithms for the problem
we have been considering? In order to make thisquestion nontrivial,
we shall ask for the minimum average number of characters

FAST PATTERN MATCHING IN STRINGS 347
examined when finding a// occurrences of the pattern in the text, where theaverage

is taken uniformly with respect to strings of length n over a givenalphabet. (The

minimum worst case number of characters examined is of no
interest, since it is between n m and n for all patterns3; therefore we ask for theminimum average number. It might be argued that the minimum average number,

taken over random strings, is of little interest, since people rarely search inrandom

strings; they usually search for patterns that actually appear. However,the random-string model is

a reasonable approximation when we consider thosestretches of
text that do not contain the pattern, and the. algorithm obviously must
examine every character in those places where the pattern does occur.)The

case of patterns of length 2 can be solved exactly; it is somewhatsurprising

to find that the analysis is not completely trivial even in this case.
Consider first the pattern a b where a b. Let q be the alphabet size, q _-> 2. Letf(n) denote the

minimum average nurnber of characters examined by analgorithm
which finds all occurrences of the pattern in a random text of length n;and let g(n) denote the

minimum average number of characters examined in arandom
text of length n + 1 which is known to begin with a, not counting the
examination of the known first character. These functions can be computed by thefollowing recurrence

relations:

f(O) =/(1) g(O) O, g(1) 1.

f(n) 1 + min (l(f(k- 1) +g(n -k))+l(g(k 1)+f(n-k))<=k <-_,,\q q+(1--)(f(k-l)+f(n-k))),

n-->2.
The recurrence for f follows by considering which character is examined first; the

recurrence for g follows from the fact that the second character must be examined
in any case, so it can be examined first without loss of efficiency. It can be shownthat the minimum

is always assumed for k 2; hence we obtain the closed form

n(q2+q-1) (q-1)(q2+2q-1) (1- q)"f(n)

q(2q- 1) q(2q- 1) + q"-3(q- 1)(2q- 1)2,

n(q2+q-1) (q-1)(q2-3q+l) (1 q)"g(n) +

q(2q- 1) q(2q- 1)2 qn-2(2q- 1)2,

solution

n=>l.
(To prove that these functions satisfy the stated recurrences reduces to showingthat the minimum of

q q
for 1 -< k _-< n occurs for k 2, whenever n -> 2 and q -> 2.)

This is clear when we must find all occurrences of the pattern; R. L. Rivest has recently proved it
also for algorithms which stop after finding one occurrence. (Information ProcessingLetters, to appear.)

348 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

TABLE 3

s[q,x],q'[q,x]
state q known characters t[q] other

0 ooooooo, 0 0,1 1,8 4,9 8,0

a 1 7,10 0,2 7,10 7,102
ooooooba 2 0,3 7,10 2,11 7,103

o,o a b a 3 5,12 0,4 5,12 5,12

4 b a b a 4 5,12 5,12 0,5 5,12

5 c baba 5 0,6 5,12 5,12 5,12

6 ac baba 6 5,12 0,7 5,12 5,12
7 b a c b a b a 7 *5, 12 5, 12 5, 12 5, 12
8 b 0 0,2 8,0 8,0 8,0

9 c 0 0,13 6,14 4,9 8,0
10 a 0 0,15 1,8 4,9 8,0
11 c b a 0 0,1 6,14 8,0 8,0

12 ab a 0 0,17 3,18 4,9 8,0
13 c a 7,10 0,19 7,10 7,10

14 b 0 0,20 3,18 4,9 8,0
15 a a 7,10 0,21 7,10 7,10
16 c b a a 1 7,10 0,5 7, 10 7,10

17 a b a a 7,10 0,22 7,10 7,10

18 b 0 0,23 3,24 8,0 8,0
19 c b a 2 0,25 7,10 7,10 7,10
20 b a 7,10 0,26 7,10 7,1021

a b a 2 0,27 7,10 2, 11 7,1022

a b a b a 2 0,28 7,10 2, 29 7,1023

b a 7,10 0,30 7,10 7,1024
b b 0 0,31 3,24 8,0 8,025

c a b a 3 5, 12 0,5 5, 12 5, 1226
boooba 2 0,32 7,10 2,11 7,1027
a a b a 3 5, 12 0,33 5, 12 5, 1228

a b a a b a 3 5, 12 0,34 5, 12 5, 1229

a c b a 0 0,35 6,14 8,0 8,030 boba 2 0,4 7,10 7,10 7,10

31 b b a 7,10 0,36 7,10 7,10
32 b a b a 3 5, 12 0,37 5, 12 5, 12
33 a b a b a 4 5, 12 5, 12 0,38 5, 12

34 a b a b a b a 4 5, 12 5, 12 *5, 12 5, 12
35 a c b a a 7,10 0,38 7,10 7,10
36 b b b a 2 0,37 7,10 7,10 7,10

37 b b a b a 4 5, 12 5, 12 0,39 5, 12
38 a c b a b a 5 0,40 5, 12 5, 12 5, 12
39 b c b a b a 5 0,7 5, 12 5, 12 5, 12
40 a a c b a b a 6 5, 12 *5, 12 5, 12 5, 12

If the pattern is a a, the recurrence for f changes to
f(n)=l+ min ( () )l<=k<=n (g(k 1) + g(n k)) + 1 (f(k 1) +f(n k)) n >-_ 2;

but this is actually no change!Hence the following

is an optimum algorithm for all patterns of length 2, in

FAST PATTERN MATCHING IN STRINGS 349
the sense of minimum average text characters inspected to find all matches in arandom

string:

k:=2;
while k -< n dobegin

c := text[k];
if c pattern[2] and text[k 1] pattern[l]then match found

at (k- 2);
while c pattern [1] dobegin k := k + 1;

c := text[k];if
c =pattern[2] then match found at (k 2);end;

k :=k+2;end;

For patterns of length 3 the recurrence relations become more complex; theydepend

on more than simply the length of the strings and knowledge aboutcharacters

at the boundaries. The determination of an optimum strategy in this
case remains an open problem. The algorithm sketched at the beginning of thissection shows that an average of O(n(log m)/m)

bit inspections suffices over abinary alphabet. Clearly [n/m
is a lower bound, since the algorithm must inspect
at least one bit in any block of n consecutive bits. The pattern a can be handled
with O(n/rn) bit inspections on the average; but it seems reasonable to conjecturethat patterns of length

rn exist for arbitrarily large m, such that an average of atleast
cn (log rn)/m bits must be inspected for all large n. Here c denotes a positiveconstant, independent of

rn and n.

Acknowledgment. Robert S. Boyer and J. Strother Moore suggested manyimportant improvements to early drafts of this postscript, especially in connection
with errors in the author's first attempts at proving the linearity theorem.

REFERENCES
[1] ALFRED V. AHO, JOHN E. HOPCROFT AND JEFFREY D. ULLMAN, The Design and Analysisof Computer Algorithms, Addison-Wesley, Reading, Mass., 1974.

[2] ALFRED V. AHO AND MARGARET J. CORASICK, Efficient string matching: An aid tobibliographic search, Comm. ACM, 18 (1975), pp. 333-340.

[3] M. BEELER, R. W. GOSPER AND R. SCHROEPPEL, HAKMEM, Memo No. 239, M.I.T.

Artificial Intelligence Laboratory, Cambridge, Mass., 1972.[4] ROBERT S. BOYER

AND J. STROTHER MOORE, a fast string searching algorithm, manuscript

dated December 29, 1975; Stanford Research Institute, Menlo Park, Calif., and Xerox Palo

Alto Research Center, Palo Alto, Calif.[5] S. A. COOK,

Linear time simulation of deterministic two-way pushdown automata, Information
Processing 71, North-Holland, Amsterdam, 1972, pp. 75-80.[6] PASCAL DIETHELM

AND PETER ROIZEN, An efficient linear search for a pattern in a string,

unpublished manuscript dated April, 1972; World Health Organization, Geneva, Switzerland.[7] N. J. FINE

AND H. S. WlLF, Uniqueness theorems for periodic functions, Proc. Amer. Math. Soc.,
16 (1965), pp. 109-114.['8] MICHAEL J. FISCHER

AND MICHAEL S. PATERSON, String matching and other products,

SIAM-AMS Proc., vol. 7, American Mathematical Society, Providence, R.I., 1974,
I19. 113-125.

350 DONALD E. KNUTH, JAMES H. MORRIS, JR. AND VAUGHAN R. PRATT

[9] ZvI GALIL, On converting on-line algorithms into real-time and on real-time algorithms forstring-matching and palindrome

recognition, SIGACT News, 7 (1975), No. 4, pp. 26-30.[10] E. N. GILBERT,
Synchronization of binary messages, IRE Trans. Information Theory, IT-6(1960),
pp. 470-477.[11] SHEILA A. GREmACH,

The hardestcontext-free language, this Journal, 2 (1973), pp. 304-310.[12] MALCOLM C. HARRISON,

Implementation of the substring test by hashing, Comm. ACM, 14(1971),
pp. 777-779.[13] RICHARD M. KARr', RAYMOND E. MILLER

AND ARNOLD L. ROSENBERG, Rapid identification of repeated patterns in strings, trees, and arrays, ACM Symposium on Theory of
Computing, vol. 4, Association for Computing Machinery, New York, 1972, pp. 125-136.[14] DONALD E. KNUTH, Fundamental

Algorithms, The Art of Computer Programming, Vol. 1,
Addison-Wesley, Reading, Mass., 1968; 2nd edition 1973.[15] ., Sequences

with precisely k + k-blocks, Solution to problem E2307, Amer. Math.
Monthly, 79 (1972), pp. 773-774.[16] , On

the translation of languages from left to right, Information and Control, 8 (1965), pp.
607-639.[17] , Structured programming with go to

statements, Computing Surveys, 6 (1974),

pp. 261-301.[18] DONALD E. KNUTH, JAMES H. MORRIS, JR.

AND VAUGHAN R. PRATT, Fast pattern
matching in strings, Tech. Rep. CS440, Computer Science Department, Stanford Univ.,
Stanford, Calif., 1974.[19] R. C. LYNDON

AND M. P. SCHOTZEN3ZrtGEg, The equation alVt=blce in a free group,
Michigan Math. J., 9 (1962), pp. 289-298.[20] GLENN MANACHER, A

new linear-time on-line algorithm for finding the smallest initial
palindrome of a string, J. Assoc. Comput. Mach., 22 (1975), pp. 346-351.[21] A. MARKOFF, Sur

une question de Jean Bernoulli, Math. Ann., 19 (1882), pp. 27-36.[22] J. H. MORRIS, JR.
AND VAUGHAN R. PRATT, A linearpattern-matching algorithm, Tech. Rep.
40, Univ. of California, Berkeley, 1970.[23] A. O. SLISENKO,

Recognition of palindromes by multihead Turing machines, Dokl. SteklovMath. Inst., Akad. Nauk SSSR, 129 (1973), pp. 30-202. (In Russian.)

24 KEN THOMPSON, Regularexpression search algorithm, Comm. ACM, 11 (1968), pp. 419-422.[25] B. A. VNKOV, Elementary

Number Theory, Wolters-Noordhoff, Groningen, the Netherlands,
1970.[26] PETER WEINER,

Linear pattern matching algorithms, IEEE Symposium on Switching andAutomata
Theory, vol. 14, IEEE, New York, 1973, pp. 1-11.