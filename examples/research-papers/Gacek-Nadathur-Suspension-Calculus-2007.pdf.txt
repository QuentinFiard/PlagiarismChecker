

A Simplified Suspension Calculus and its
Relationship to Other Explicit Substitution Calculi

Andrew Gacek and Gopalan Nadathur
Digital Technology Center and Department of Computer Science and Engineering
University of Minnesota

This paper concerns the explicit treatment of substitutions in the lambda calculus. One of its
contributions is the simplification and rationalization of the suspension calculus that embodies
such a treatment. The earlier version of this calculus provides a cumbersome encoding of substitution composition, an operation that is important to the efficient realization of reduction. This
encoding is simplified here, resulting in a treatment that is easy to use directly in applications.
The rationalization consists of the elimination of a practically inconsequential flexibility in the
unravelling of substitutions that has the inadvertent side effect of losing contextual information
in terms; the modified calculus now has a structure that naturally supports logical analyses, such
as ones related to the assignment of types, over lambda terms. The overall calculus is shown to
have pleasing theoretical properties such as a strongly terminating sub-calculus for substitution
and confluence even in the presence of term meta variables that are accorded a grafting interpretation. Another contribution of the paper is the identification of a broad set of properties that are
desirable for explicit substitution calculi to support and a classification of a variety of proposed
systems based on these. The suspension calculus is used as a tool in this study. In particular,
mappings are described between it and the other calculi towards understanding the characteristics
of the latter.

Categories and Subject Descriptors: F.4.3 [Mathematical Logic and Formal Languages]:
Mathematical Logic--Lambda calculus and related systems

General Terms: Languages, Theory
Additional Key Words and Phrases: Lambda calculus, explicit substitutions, term rewriting,
higher-order abstract syntax, metalanguages

1. INTRODUCTION
This paper concerns the explicit treatment of substitution in the lambda calculus.It has a twofold purpose within this context. First, it simplifies and rationalizes a

particular calculus known as the suspension calculus that provides such a treatment[Nadathur and Wilson 1998]. Second, using the resulting system as a basis, it
attempts to explicate the nuances of and differences between an array of explicitsubstitution calculi that have been proposed in recent years.

The desire to treat substitution directly in the syntax and rewrite rules of thelambda calculus has had a variety of motivations. The suspension calculus was
developed originally with the intention of supporting a higher-order view of syntax,now commonly referred to as higher-order abstract syntax [Pfenning and Elliott

Authors' addresses:
A. Gacek, University of Minnesota, 4-192 EE/CS Building, 200 Union Street SE, Minneapolis,
MN 55455, USA, Email: andrew.gacek@gmail.com
G. Nadathur, University of Minnesota, 4-192 EE/CS Building, 200 Union Street SE, Minneapolis,
MN 55455, USA, Email: gopalan@cs.umn.edu

2 * A. Gacek and G. Nadathur
1988] or lambda tree syntax [Miller 2000]. Success has been encountered in thisendeavour: amongst other applications, the notation has been employed in the
reasoning system called Bedwyr [Baelde et al. 2007], in the abstract machine for
*Prolog [Nadathur and Mitchell 1999] and in the implementation of the FLINTtyped intermediate language [Shao et al. 1998]. Despite its use in practical systems, the original suspension calculus manifests some deficiencies. One problemis the building in of excessive flexibility in the unravelling of substitutions that
leads inadvertently to the loss of certain kinds of context information. This addedflexibility does not really enhance the efficiency of reduction and has unpleasant
side effects such as the loss of the ability to associate a typing calculus with lambdaterms. Another problem relates to the encoding of the composition of substitutions.
Although the notation includes such a capability, its treatment is complicated andhas led to the description of a derived calculus [Nadathur 1999] that is the one
usually employed in applications. A drawback with this derived calculus is that itdoes not possess the property of confluence when meta variables are added to the
syntax under the so-called grafting interpretation1. At a practical level, this has theimpact that new approaches to higher-order unification based on using graftable
meta variables [Dowek et al. 2000] cannot be exploited relative to it.One contribution of this paper is the redressing of this situation. In particular, it
describes a modified treatment of substitution composition that is simultaneouslynatural, easy to use directly in implementations and consistent with contextual
properties.The last fifteen years has seen the description of a large number of explicit substitution calculi, often without a clear enunciation of the goals underlying their design.A consequence of this phenomenon is that it has been difficult to evaluate the different calculi or even to understand the distinctive characteristics of each. This papercontributes in a second way by bringing greater clarity to these matters. Specifically, it identifies three properties that appear important for explicit treatmentsof substitution to support. It then surveys some of the prominent calculi in this
realm through this prism. The suspension calculus that is developed in the earliersections serves as a tool in understanding the various other systems. Through this
process, a better grasp is also obtained of the capabilities of this specific notation.The rest of the paper is structured as follows. In the next section we describe
the new version of the suspension calculus. Section 3 then elucidates its proper-ties: we show here the strong normalizability and confluence of the sub-calculus for
treating substitutions and the confluence of the overall calculus even in the pres-ence of graftable meta variables. Section 4 discusses other treatments of explicit
substitutions and contrasts these with the one developed here. Section 5 concludesthe paper.

2. THE SUSPENSION CALCULUS
The modified version of the suspension calculus of Nadathur and Wilson [1998] thatwe present in this section does not sacrifice any of the computational properties of

the original calculus that are essential to its use in implementations. Rather, it em1Although this has not been made explicit previously, the original suspension calculus is confluent
even in the presence of graftable meta variables.

The Suspension Calculus and Other Explicit Substitution Calculi * 3
bodies a view of it that is easier to reason about and to relate to other approaches toexplicit substitutions. In the first two subsections below, we outline the intuitions
underlying the suspension calculus and then substantiate this discussion througha precise description of its syntax and reduction rules. We then discuss the relationship of the version of the calculus we present here with the original version andalso describe variants of it arising from the introduction of meta variables under
two different interpretations.
2.1 Motivating the Encoding of Substitutions
We are interested in enhancing the syntax of the lambda calculus with a newcategory of expressions that is capable of encoding terms together with substitutions

that have yet to be carried out on them. The kinds of substitutions that we wishto treat are those that arise from beta contraction steps being applied to lambda
terms. Towards understanding what needs to be encoded in this context, we mayconsider a term with the following structure:

(. . . ((* . . . (* . . . ((* . . . t . . .) s1) . . .) . . .) s2) . . .)
We assume here a de Bruijn representation for lambda terms, i.e., names are notused with abstractions and bound variable occurrences are replaced by indices that

count abstractions back up to the one binding them [Bruijn 1972]. We have elidedmuch of the detail in the term shown and have, in fact, focussed only on the
following aspects: there is a beta redex in it (whose "argument" part is s2) thatis embedded possibly under abstractions and that itself contains at least another
embedded beta redex. Contracting the two beta redexes shown should produce aterm of the form

(. . . (. . . (* . . . (. . . t0 . . .) . . .) . . .) . . .)
where t0 is obtained from t by substituting s2 and (a modified form of) s1 forappropriate variables and adjusting the indices for other bound variables to account

for the disappearance of two enclosing abstractions. Our goal is to represent t0 as
t coupled with the substitutions that are to be performed on it.Towards developing a suitable encoding, it is useful to factor the variable references within t into two groups: those that are bound by abstractions inside the firstbeta redex that is contracted and those that are bound by abstractions enclosing
this redex. Let us refer to the number of abstractions enclosing a term in a par-ticular context as its embedding level relative to that context. For example, if we
assume that every abstraction within the outer beta redex in the term consideredabove has been explicitly shown, then the embedding level of

t in this context is 3.Rewriting a beta redex eliminates abstractions and therefore changes embedding

levels. Thus, if the two beta redexes of interest are both contracted, the embeddinglevel of

t becomes 1. We shall call the embedding levels at a term before and afterbeta contractions the old and new embedding levels respectively. Simply recording

these with a term is enough for encoding the change that needs to be made to theindices for variables bound by the "outer" group of abstractions; in particular, these
indices must be decreased by the difference between the old and the new embeddinglevels.

4 * A. Gacek and G. Nadathur

Substitutions for the other group of variable references, i.e., those bound byabstractions within the first beta redex contracted, can be recorded explicitly in an
environment. To suggest a concrete syntax, the term t0 in the example consideredmay be represented by the expression [[

t, ol, nl, e]] where ol and nl are the old andnew embedding levels, respectively, and
e is the environment. Note that the numberof entries in the environment must coincide with the old embedding level. It is

convenient also to maintain the environment as a list or sequence of elements whoseorder is reverse that of the embedding level of the abstraction they correspond to;
amongst other things, this allowed for an easy augmentation of the environment in atop-down traversal of the term. Now, one component of the entry for an abstraction
that is contracted should obviously be the argument part of the relevant beta redex.For an abstraction not eliminated by a contraction, there is no new term to be
substituted, but we can still correctly record the index corresponding to the firstfree variable as a pseudo substitution for it. In both these cases, we have also to
pay attention to the following fact: the term in the environment may be substitutedinto a new context that has a larger number of enclosing abstractions and hence
de Bruijn indices for free variables within it may have to be modified. To encodethis renumbering, it suffices to record the (new) embedding level at the relevant
abstraction with the environment entry. The difference between this and the (new)embedding level at the point of substitution determines the amount by which the
free variable indices inside the term being substituted have to be changed. Thus,each environment entry has the form (

t, l) where t is a term and l is a positivenumber. We refer to the second component of each such entry as its index and

we observe that the indices for successive environment entries must form a non-increasing sequence at least for the simple form of environments we are presently
considering.Once we have permitted terms encoding substitutions into our syntax, it is possible for such terms to appear one inside another. A particular instance of thisphenomenon is when they appear in juxtaposition as in the term

[[[[t, ol1, nl1, e1]], ol2, nl2, e2]].
This term corresponds to separately performing two sets of substitutions into t. Itis useful to have a means for combining these into one set of substitutions, i.e., for

rewriting the indicated term into one of the form [[t, ol0, nl0, e0]]. In determining theshape of the new term, it is useful to note that

e1 and e2 represent substitutions foroverlapping sequences of abstractions within which

t is embedded. The generationof the original term can, in fact, be visualized as follows: First, a walk is made over

ol1 abstractions immediately enclosing t, possibly eliminating some of them via betacontractions, recording substitutions for all of them in

e1 and eventually leavingbehind
nl1 enclosing abstractions. Then a similar walk is made over ol2 abstractionsimmediately enclosing the term [[

t1, ol1, nl1, e1]], recording substitutions for each ofthem in
e2 and leaving behind nl2 abstractions. Notice that the ol2 abstractionsscanned in the second walk are coextensive with some final segment of the

nl1abstractions left behind after the first walk and includes additional abstractions if

ol2 > nl1.Based on the image just evoked, it is not difficult to see what

ol0 in the termrepresenting the combined form for the substitutions should be: this form represents

The Suspension Calculus and Other Explicit Substitution Calculi * 5
a walk over ol1 enclosing abstractions in the case that ol2 <= nl1 and ol1 + (ol2 -
nl1) abstractions otherwise and ol0 should be the appropriate one of these values.Similarly, the number of abstractions eventually left behind is

nl2 or nl2 +(nl1 -ol2)depending on whether or not
nl1 <= ol2, and this determines the value of nl0. Withregard to the environment
e0, this should be composed of the elements of e1 modifiedby the substitutions encoded in

e2 followed by a final segment of e2 in the case that
ol2 > nl1. The modification to be effected on the elements of e1 may be understoodas follows. Suppose

e1 has as an element the pair (s, l). Then s is affected by onlythat part of
e2 that comes after the first nl1 - l entries in it. Further, the index ofthe corresponding entry in the composite environment would have to be increased

from l by an amount equal to ol2 - nl1 in the case that ol2 > nl1. From theseobservations, it is clear that the merged environment can be generated completely
from the components e1, nl1, ol2 and e2. We correspondingly choose to encode thisenvironment by the expression {{

e1, nl1, ol2, e2}}.Our focus here has been on motivating the new syntactic forms in the suspension

calculus. However, implicit in this discussion has been a "meaning" for these newexpressions in the sense of a translation into an underlying de Bruijn term. This
informal semantics will be made precise in the next section through a collection ofrewrite rules that can be used to incrementally "calculate" the intended encodings.

2.2 The Syntax of Terms and the Rewriting System
We now describe precisely the collections of expressions that constitute terms andenvironments in the suspension calculus. We assume that the lambda terms to

be treated contain constant symbols drawn from a predetermined set. Letting crepresent such constants, the

t and e expressions given by the following rules definea "pre-syntax" for our terms and environments:

t ::= c | #i | (t t) | (* t) | [[t, n, n, e]]
e ::= nil | ((t, n) :: e) | {{e, n, n, e}}

In these rules, n corresponds to the category of natural numbers and i representspositive integers. Terms of the form (

t1 t2) and (* t) are, as usual, referred toas applications and abstractions. A term of the form #

i, known as a de Bruijnindex, represents a variable bound by the
ith abstraction looking outward from thepoint of its occurrence. Expressions of the form [[

t, ol, nl, e]] are called suspensions;these constitute a genuine extension to the syntax of lambda terms. The operator

:: provides the means for forming lists in environments. We use the conventionsthat application is left associative, that :: is right associative and that application
binds more tightly than abstraction to often omit parentheses in the expressionswe write. We shall sometimes need to suppress the distinction between terms and
environments and at these times we shall refer to them collectively as suspensionexpressions or, more simply, as expressions.

The reason we think of the rules above as defining only the pre-syntax is that weexpect suspension expressions to also satisfy certain well-formedness constraints.
In order to enunciate these constraints precisely, we need to associate the notionsof length and level with environments. We do this through the following definitions. The symbol . used in these definitions denotes the subtraction operationon natural numbers.

6 * A. Gacek and G. Nadathur

Definition 2.1. The length of an environment e is denoted by len(e) and is de-fined by recursion on its structure as follows:

(1) len(nil) = 0
(2) len((t, l) :: e) = 1 + len(e)
(3) len({{e1, nl1, ol2, e2}}) = len(e1) + (len(e2) . nl1)

Definition 2.2. The level of an environment e, denoted by lev(e), is also givenby recursion as follows:

(1) lev(nil) = 0
(2) lev((t, l) :: e) = l
(3) lev({{e1, nl1, ol2, e2}}) = lev(e2) + (nl1 . ol2)

The legitimacy requirements that complement the syntax rules is now explicatedas follows:

Definition 2.3. A suspension expression is considered well-formed just in casethe following conditions hold of all its subexpressions:
(1) If it is of the form [[t, ol, nl, e]] then len(e) = ol and lev(e) <= nl.
(2) If it is of the form (t, l) :: e then l >= lev(e).
(3) If it is of the form {{e1, nl1, ol2, e2}} then lev(e1) <= nl1 and len(e2) = ol2.

We henceforth consider only well-formed suspension expressions. We shall alsosometimes restrict our attention to environments which have the structure of a list

of bindings. We identify this class of environments below.

Definition 2.4. A simple environment is one of the form

(t0, l0) :: (t1, l1) :: . . . :: (tn-1, ln-1) :: nil
where by an abuse of notation, we allow n to be 0, in which case the environmentin question is

nil. For 0 <= i < n, we write e[i] to denote the environment element(
ti, li) and e{i} to denote (ti, li) :: . . . :: (tn-1, ln-1) :: nil, i.e., the environmentobtained from

e by removing its first i elements. We extend the last notation byletting
e{i} denote nil in the case that i >= len(e) for any simple environment e.

The rewrite system associated with suspension expressions comprises three kindsof rules: the beta contraction rule that generates substitutions, the reading rules

that distribute them over term structure and the merging rules that allow for thecombination of substitutions generated by different beta contractions into a composite one. These three categories correspond to the rules in Figure 1 labelled (fis),(r1)-(r6) and (m1)-(m6), respectively. The application of several of these rules depends on arithmetic calculations on embedding levels and indices. We have beencareful in the formal presentation to identify such calculations through side conditions on the rules. However, in the sequel, we will often assimilate such arithmeticoperations into the rewrite rule itself with the understanding that they are to be
"interpreted." Using this approach, rule (r6) may have been written instead as

[[(* t), ol, nl, e]] ! (* [[t, ol + 1, nl + 1, (#1, nl + 1) :: e]]).

The Suspension Calculus and Other Explicit Substitution Calculi * 7
(fis) ((* t1) t2) ! [[t1, 1, 0, (t2, 0) :: nil]].
(r1) [[c, ol, nl, e]] ! c, provided c is a constant.
(r2) [[#i, 0, nl, nil]] ! #j, where j = i + nl.
(r3) [[#1, ol, nl, (t, l) :: e]] ! [[t, 0, nl0, nil]], where nl0 = nl - l.
(r4) [[#i, ol, nl, (t, l) :: e]] ! [[#i0, ol0, nl, e]],

where i0 = i - 1 and ol0 = ol - 1, provided i > 1.

(r5) [[(t1 t2), ol, nl, e]] ! ([[t1, ol, nl, e]] [[t2, ol, nl, e]]).
(r6) [[(* t), ol, nl, e]] ! (* [[t, ol0, nl0, (#1, nl0) :: e]]),

where ol0 = ol + 1 and nl0 = nl + 1.

(m1) [[[[t, ol1, nl1, e1]], ol2, nl2, e2]] ! [[t, ol0, nl0, {{e1, nl1, ol2, e2}}]],

where ol0 = ol1 + (ol2 . nl1) and nl0 = nl2 + (nl1 . ol2).

(m2) {{e1, nl1, 0, nil}} ! e1.
(m3) {{nil, 0, ol2, e2}} ! e2.
(m4) {{nil, nl1, ol2, (t, l) :: e2}} ! {{nil, nl01, ol02, e2}},

where nl01 = nl1 - 1 and ol02 = ol2 - 1, provided nl1 >= 1.

(m5) {{(t, n) :: e1, nl1, ol2, (s, l) :: e2}} ! {{(t, n) :: e1, nl01, ol02, e2}},

where nl01 = nl1 - 1 and ol02 = ol2 - 1, provided nl1 > n.

(m6) {{(t, n) :: e1, n, ol2, (s, l) :: e2}} ! ([[t, ol2, l, (s, l) :: e2]], m) :: {{e1, n, ol2, (s, l) :: e2}},

where m = l + (n . ol2).

Fig. 1. Rewrite Rules for the Suspension Calculus
Definition 2.5. We say that a suspension expression r is related to s by a fis-contraction step, a reading step or a merging step if it is the result of applying the
(fis) rule, one of the rules (r1)-(r6) or one of the rules (m1)-(m6), respectively, atany relevant subexpression of

s. We denote these relations by writing s\Lambda fisr, s\Lambda rrand
s\Lambda mr, respectively. The union of the relations \Lambda r and \Lambda m will be denoted by
\Lambda rm, that of \Lambda r and \Lambda fis by \Lambda rfis and, finally, that of all three relations by \Lambda rmfis.If

R corresponds to any of these relations, we shall write R* to denote its reflexiveand transitive closure.

The following theorem shows that these various relations are well-defined.
Theorem 2.6. The relations \Lambda fis, \Lambda r and \Lambda m, and, hence, any combination ofthem, preserve well-formedness of suspension expressions.

Proof. A somewhat stronger property can be proved for the rewriting relationsof interest: (i) they leave the length of an environment unchanged, (ii) they never
increase the level of an environment, and (iii) they preserve well-formedness. Thesefacts are established simultaneously by induction on the structure of suspension
expressions. The base case is verified by considering in turn each rewrite rule inFigure 1. The argument is then completed by considering each possibility for the
structure of an expression and using the induction hypothesis. The details areentirely straightforward and hence omitted.

We illustrate the rewrite rules by considering their use on the term

8 * A. Gacek and G. Nadathur

((* (* * #1 #2 #3) t2) t3),
where t2 and t3 are arbitrary terms. We trace a \Lambda rmfis-rewrite sequence for thisterm below:

((* (* * #1 #2 #3) t2) t3)

\Lambda *fis[[[[* #1 #2 #3, 1, 0, (t2, 0) :: nil]], 1, 0, (t3, 0) :: nil]]
\Lambda m[[* #1 #2 #3, 2, 0, {{(t2, 0) :: nil, 0, 1, (t3, 0) :: nil}}]]
\Lambda m[[* #1 #2 #3, 2, 0, ([[t2, 1, 0, (t3, 0) :: nil]], 0) :: {{nil, 0, 1, (t3, 0) :: nil}}]]
\Lambda m[[* #1 #2 #3, 2, 0, ([[t2, 1, 0, (t3, 0) :: nil]], 0) :: (t3, 0) :: nil]].

The last expression in this sequence is a term that represents, roughly, the "sus-pended" simultaneous substitution of

t2, modified by the substitution of t3 for itsfirst free variable, and of
t3 for the first two free variables in (* #1 #2 #3). Thissuspension has been produced by contracting the two beta redexes in the original

term and then using the merging rules to combine the two separate substitutionsthat are so generated. The combined environment can now be moved inside the
abstraction, distributed over the applications and partially "evaluated" using thereading rules to yield

(* #1 [[[[t2, 1, 0, (t3, 0) :: nil]], 0, 1, nil]]) [[t3, 0, 1, nil]])).
This term manifests a structure that may be thought of as a generalization ofhead-normal forms to suspension terms. By applying reading and merging rules

in accordance with the structure of t2 and t3, we may further transform it into ahead-normal form in the conventional sense.

The terms in the de Bruijn style presentation of the lambda calculus are a subsetof the terms in the suspension calculus. In particular, they are exactly the terms in
the present notation that do not contain any suspensions. Given a rewrite relation
R, we shall say, as usual, that an expression is in R-normal form if it cannot befurther transformed by the rules defining

R. It is easily seen then that a suspensionterm is in de Bruijn form just in case it is in

\Lambda rm-normal form. We would, of course,be interested in knowing if any given suspension expression can be transformed into

a normal form of this kind. We answer this question in the affirmative in the nextsection and subsequently relate the rewrite relations defined here with the usual
notion of beta reduction over de Bruijn terms.
2.3 Relationship to the Original Suspension Calculus
The suspension calculus as we have described it here deviates from the original pre-sentation in [Nadathur and Wilson 1998] in a few different ways. One distinction

arises from the use in the earlier version of the calculus of a special form for theenvironment item that results from percolating a substitution under an abstraction. These items are written as @n where n is a natural number. The rule (r6)correspondingly has the form

[[(* t), ol, nl, e]] ! (* [[t, ol + 1, nl + 1, @nl :: e]])
in that setting. This form was introduced into the syntax and treated in specialways by the rewrite rules in anticipation of an implementation optimization. It is,

however, inessential at a theoretical level. In particular, the behaviour of a dummy

The Suspension Calculus and Other Explicit Substitution Calculi * 9
environment element of the form @n can be completely circumscribed by replacingit with (#1

, n + 1)2. We assume the impact of this observation below.Suspension expressions in the present setting constitute a subset of the expressions in the original calculus at a pre-syntax level. However, the well-formednesscondition when restricted to these expressions is different in the two contexts. The
earlier condition has a form that is identical to the one in Definition 2.3 except thatthe requirement on the levels of environments is replaced by one on their indices,
a notion that is defined below.

Definition 2.7. Given a natural number i, the i-th index of an environment e isdenoted by

indi(e) and is defined as follows:

(1) If e is nil then indi(e) = 0.
(2) If e is (t, k) :: e0 then indi(e) is k if i = 0 and indi-1(e0) otherwise.
(3) If e is {{e1, nl, ol, e2}}, let m = (nl . indi(e1))3 and l = len(e1). Then

indi(e) = 8!:

indm(e2) + (nl . ol) if i < l and len(e2) > m
indi(e1) if i < l and len(e2) <= m
ind(i-l+nl)(e2) if i >= l.

The index of an environment, denoted by ind(e), is ind0(e).
Any given environment expression e is expected to be reducible to a simple one ofthe form (

t0, l0) :: . . . :: (tn-1, ln-1) :: nil. The i-th index of e is then precisely liif
i < n and 0 otherwise. The level of e, in contrast, only estimates the 0-th indexwhen

e is reduced to this simple form while retaining information that is neededfor interpreting intermediate expressions in the rewriting process. Nevertheless, we

can observe the following:

Lemma 2.8. The well-formed expressions of the suspension calculus as describedin this paper are a subset of the well-formed ones of the original presentation.

Proof. We prove the following by induction on the structure of a suspensionexpression that is well-formed under the criterion in this paper: (a) the expression
is also well-formed under the earlier criterion and (b) if the expression is an environ-ment

e, then lev(e) >= ind(e) and if i > j then indi(e) >= indj(e). These propertiesmust be shown simultaneously: the induction hypothesis pertaining to (b) is needed

for establishing (a) and we need to know that the expression is well-formed in theearlier sense in order to establish (b). The details are straightforward once these
observations are made and hence we omit them here. The lemma is an immediateconsequence of property (a).

The final difference between the two versions of the suspension calculus is in thetreatment of the composition of two environments. In the earlier presentation, the
outer environment is distributed eagerly over the elements of the inner one. Thisis done by a rule of the form

2It should be noted, though, that the parsimony of the latter form is complemented by the
introduction of more (perhaps unnecessary) possibilities for rewriting that considerably complicate
the proof of termination for the reading and merging rules.
3The . here can be replaced by - for well-formed expressions.

10 * A. Gacek and G. Nadathur

{{et :: e1, nl, ol, e2}} ! hhet, nl, ol, e2ii :: {{e1, nl, ol, e2}},
where hhet, nl, ol, e2ii represents an augmentation to the syntax of environmentitems for encoding the effect of transforming

et by the relevant substitutions in
e2. The older version of the calculus has rules relating to expressions of the formhh

et, nl, ol, e2ii that facilitate the pruning of e2 down to a part that really affects etand the subsequent generation of a suspension that captures its influence on the

term component. By contrast, the present rendition of the calculus calculates theeffect of

e2 on et :: e1 by first pruning e2 down to a relevant part based on et andonly later distributing the refined environment to

e1.It follows naturally from the observations made above that the rules (m2), (m5)

and (m6) do not appear in the original rendition of the suspension calculus. How-ever, based on the discussions already in [Nadathur and Wilson 1998], it can be
seen that each of these rules is admissible to the earlier version in the sense thattheir left and right hand sides can be rewritten to a common form in that setting.
We can, in fact, make the following observation, a detailed proof of which appearsin [Gacek 2006b]:

Lemma 2.9. Let x1 and x2 be suspension expressions such that x1\Lambda *rmx2. As-sume further that

x2 is in \Lambda rm-normal form. Then x1 also rewrites to x2 by virtueof the reading and merging rules in [Nadathur and Wilson 1998].

Our focus up to this point has been on arguing that the suspension calculus asdescribed here is a subsystem of sorts of the original presentation. It is important,
of course, to also address the issue of why such a "subsystem" is of interest. Thereare several reasons for this, all arising out of the modified treatment of substitution
composition. First, this treatment is a considerably simplified one and can, asa consequence, be used directly in practical applications. Second, it rectifies a
problem with the original calculus that prevented certain interesting logical analysesover terms from being formulated: it is, for instance possible to describe a type
assignment system now for terms [Gacek 2006b], something that was difficult to dowith the original suspension calculus. Finally, this change is crucial to our ability
to describe formal correspondences of the suspension calculus with other explicitsubstitution calculi later in this paper.

While there may be justifications for the modified suspension calculus, there isalso a question about its adequacy. It is evident that this version can still treat
substitutions explicitly and that it possesses the important capability of composingsuch substitutions. In the next section we see also that properties such as confluence
and the ability to simulate the usual notion of beta reduction over lambda termsare preserved, thus settling any concern over adequacy.

2.4 Permitting Meta Variables In Suspension Terms
The syntax of suspension expressions does not presently allow for instantiatablevariables. Such variables, also referred to as meta variables, are often used within

lambda terms in situations such as those of higher-order theorem proving andsymbolic manipulation of higher-order objects. In the former context, these variables arise naturally in attempts to prove existential statements: such proofs in-volve choosing instantiations for existential quantifiers and meta variables provide

The Suspension Calculus and Other Explicit Substitution Calculi * 11
a means for delaying actual choices till there is enough information for determiningwhat they should be. In the latter context, instantiatable variables are instrumental in realizing structure recognition capabilities relative to the use of higher-orderabstract syntax based representations of constructs whose structures involve binding notions. For example, consider the first-order formula 8x((p x) . (q x)). Usingan abstraction to capture the binding content of the quantifier, this formula can
be rendered into the lambda term (all * (or (p #1) (q #1))), where all and or areconstants chosen to encode universal quantification and disjunction in formulas.
Given such representations, the lambda term (all * (or (P #1) (Q #1))) in which
P and Q are meta variables serves as a pattern for recognizing formulas that at thetop-level have the structure of a disjunction embedded within a universal quantifier.

An important question concerning meta variables is that of how substitutionsfor them are to be treated. The logically correct interpretation of these variables
requires that such substitutions respect the notion of scope. Thus, if X is aninstantiatable variable that has an occurrence within an abstraction context, the
term that is substituted for it cannot contain a bound variable that is captured bythe enclosing abstraction. This view is one that also supports rather useful pattern
matching capabilities. To understand this, we might reconsider the "template"we have described above for first-order formulas. Suppose that we want to refine
this so that the formulas recognized by it are such that the right subpart of thedisjunction does not depend on the top-level quantifier. If a treatment of meta
variables in accordance with logical principles is used, then the following modifiedtemplate achieves this purpose: (

all * (or (P #1) Q))). The critical facet thatensures this behaviour is that no structure that is substituted for

Q can have avariable occurrence in it that is captured by the abstraction corresponding to the

quantifier.

An alternative possibility to the logical view of instantiatable variables is to treatthem as placeholders against which any well-formed term can be grafted. This

kind of "grafting" interpretation has been found useful in conjunction with explicitsubstitution notations in, for instance, realizing a new approach to unification in
the context of lambda terms [Dowek et al. 2000]. The well-known procedure dueto Huet [1975] calculates unifiers incrementally and requires the construction of
a complicated term, the contraction of beta redexes and the calculation of theirsubstitution effects all for the sole purpose of percolating dependency information
to places where they can be used in later computation steps. By allowing metavariables to be substituted for by terms with variable occurrences that can be
captured by enclosing abstractions, the dependencies can be transmitted by a muchsimpler process. Of course, treating instantiatable variables in this "graftable" way
seems contradictory to their logical interpretation and also appears to fly in the faceof pattern matching applications. However, a reconciliation is possible: variables
can be interpreted initially in a logical way but then surrounded in an explicitsubstitution context so that a subsequent grafting treatment does not violate the
required logical constraints. Thus, consider again the term (all * (or (P #1) Q)).This term may be transformed into (

all * (or ([[P 0, 0, 1, nil]] #1) [[Q0, 0, 1, nil]])). Byidentifying
P and Q with the terms [[P 0, 0, 1, nil]] and [[Q0, 0, 1, nil]], we insulatesubstitutions for them from a dependence on the external abstraction even under

12 * A. Gacek and G. Nadathur
a grafting interpretation of P 0 and Q0.Either of the discussed views of meta variables can be built into the suspension
notation. Towards this end, we first modify the syntax for terms to the following:

t ::= v | c | #i | (t t) | (* t) | [[t, n, n, e]],
where v represents the category of instantiatable variables. If we interpret thesevariables in the logical way, then they cannot be affected by substitutions generated

by fi-contractions. To support this view, therefore, we add the following to ourreading rules:

(r7) [[v, ol, nl, e]] ! v, if v is a meta variable.
If, on the other hand, the grafting interpretation is chosen, then this rule is notacceptable and the original rewriting system, in fact, remains unchanged.

The choice of interpretation impact on the properties of the calculus in differentways. Under the logical view, meta variables behave like constants in that they may
be replaced only by closed terms; this fact is explicitly manifest in the similarityof rule (r7) to (r1). Thus, all the properties of the calculus that includes them are
already manifest in the subsystem described in Section 2.2. The situation is moreintricate under the grafting view. For example, consider the term ((

* ((* X) t1)) t2)in which
X is an instantiatable variable and t1 and t2 are terms in \Lambda rm-normal form.This term can be rewritten to

[[[[X, 1, 0, (t1, 0) :: nil]], 1, 0, (t2, 0) :: nil]]
and also to

[[[[X, 2, 1, (#1, 1) :: (t2, 0) :: nil]], 1, 0, ([[t1, 1, 0, (t2, 0) :: nil]], 0) :: nil]],
amongst other terms. It is easy to see that these terms cannot now be rewrittento a common form using only the reading and (

fis) rules. The merging rules areessential to this ability. As we see in Section 3, these also suffice for this purpose.

We assume henceforth that the suspension calculus includes meta variables andthat these are implicitly accorded the grafting interpretation. For reasons already
mentioned, it is easy to see that the properties we establish for the resulting calculuswill hold also under the logical interpretation.

3. PROPERTIES OF THE SUSPENSION CALCULUS
We now consider the coherence of the suspension calculus. Suspensions and theassociated reading and merging rules are intended mainly to provide control and

variability over substitution relative to the lambda calculus. In keeping with thefinite nature of the substitution process, we would expect the reduction relations
defined by these rules to be always terminating. We show this to be the case in thefirst subsection. There are evidently choices to be made in the application of the
reading and merging rules. Regardless of how these choices are made, it is importantthat we produce the same normal form. We show that this confluence property holds
in the second subsection below. We then digress briefly to establish an interestingstructural property of the suspension calculus which relates two different methods
for encoding the renumbering of bound variables; this property is used in the nextsection in relating the suspension calculus to the

*oe-calculus. Finally, we prove

The Suspension Calculus and Other Explicit Substitution Calculi * 13
that confluence continues to hold when the (fis) rule is added to the collection andthat this full system is also capable of simulating beta reduction over de Bruijn
terms.
3.1 Strong Normalizability for Substitution Reductions
There are two steps to our argument that any sequence of rewritings based onthe reading and merging rules must terminate. First we identify a collection of

first-order terms over which we define a well-founded ordering using a variant ofrecursive path orderings [Dershowitz 1982; Ferreira and Zantema 1995]. We then
describe a translation from suspension expressions to this collection of terms thatis such that each of the relevant rewrite rules produces a smaller term relative to
the defined order. The desired conclusion follows from these facts.The terms that are intended to capture the essence of suspension expressions
vis-a-vis termination are constructed using the following (infinite) vocabulary: the0-ary function symbol *, the unary function symbol lam, and the binary function
symbols app, cons and, for each positive number i, si. We denote this collection ofterms by T . We assume the following partial ordering A on the signature underlying
T : si A sj if i > j and, for every i, si A app, si A lam, si A cons and si A *. Thisordering is now extended to the collection of terms.

Definition 3.1. The relation O/ on T is inductively defined by the following prop-erty: Let

s = f (s1, . . . , sm) and t = g(t1, . . . , tn); both s and t may be *, i.e., thenumber of arguments for either term may be 0. Then

s O/ t if

(1) f = g (in which case n = m), (s1, . . . , sn) O/lex (t1, . . . , tn), and, s O/ ti for all isuch that 1 <=

i <= n, or

(2) f A g and s O/ ti for all i such that 1 <= i <= n, or
(3) si = t or si O/ t for some i such that 1 <= i <= m.

Here O/lex denotes the lexicographic ordering induced by O/.

In the terminology of [Ferreira and Zantema 1995], O/ is an instance of a recursivepath ordering based on A. It is easily seen that A is a well-founded ordering on

the signature underlying T . The results in [Ferreira and Zantema 1995] then implythe following:

Lemma 3.2. O/ is a well-founded partial order on T .
We now consider the translation from suspension expressions to T . The criticalpart of this mapping is the treatment of expressions of the form [[

t, ol, nl, e]] and{{
e1, nl, ol, e2}}. Our translation ignores the embedding level components of theseexpressions and transforms them into terms whose top-level function symbol is

siwhere
i is a coarse measure of the remaining substitution work. In estimating thiseffort in a sufficiently fine-grained way relative to an abstraction, it is necessary to

take cognizance of the following fact: rule (r6) creates a "dummy" substitution forthe bound variable that is then adjusted by generating a "renumbering" suspension
using rule (r3). To account for this additional work, we define a family of measuresthat relativizes the complexity of an expression to the number of enclosing suspensions. In calculating this quantity it is important to observe that the substitution

14 * A. Gacek and G. Nadathur
via rule (r3) of a term in an environment results in it being embedded in an ad-ditional suspension. We quantify the maximum such "internal embedding" below
and then use this in estimating the substitution effort. In these definitions, max isthe function that picks the larger of its two integer arguments.

Definition 3.3. The measure u that estimates the internal embedding potentialof a suspension expression is defined as follows:
(1) For a term t, u(t) is 0 if t is a constant, a meta variable or a de Bruijn index,

u(s) if t is (* s), max (u(s1), u(s2)) if t is (s1 s2), and u(s) + u(e) + 1 if t is[[

s, ol, nl, e]].

(2) For an environment e, u(e) is 0 if e is nil, max (u(s), u(e1)) if e is (s, l) :: e1 and

u(e1) + u(e2) + 1 if e is {{e1, nl, ol, e2}}.

Definition 3.4. The measures ji on terms and environments for each naturalnumber

i are defined simultaneously by recursion as follows:

(1) For a term t, ji(t) is 1 if t is a constant, a meta variable or a de Bruijnindex,

ji(s) + 1 if t is (* s), max (ji(s1), ji(s2)) + 1 if t is (s1 s2),and ji+1(s) +
ji+1+u(s)(e) + 1 if t is [[s, ol, nl, e]].

(2) For an environment e, ji(e) is 0 if e is nil, max (ji(s), ji(e1)) if e is (s, l) :: e1and

ji+1(e1) + ji+1+u(e1)(e2) + 1 if e is {{e1, nl, ol, e2}}.

The measure j0 is meaningfully used only relative to suspensions. In this context,it estimates, in a sense, the maximum effort along any one path in the substitution

process rather than the cumulative effort.

Definition 3.5. The translation E of suspension expressions to T is defined asfollows:

(1) For a term t, E(t) is * if t is a constant a meta variable or a de Bruijn index,app(E(

t1), E(t2)) if t is (t1 t2), lam(E(t0)) if t is (* t0) and si(E(t0), E(e0)) where
i = j0(t) if t is [[t0, ol, nl, e0]].

(2) For an environment e, E(e) is * if e is nil, cons(E(t0), E(e0)) if e is (t0, l) :: e0and

si(E(e1), E(e2)) where i = j0(e) if e is {{e1, nl, ol, e2}}.

We are now in a position to prove the strong normalizability of the substitutionreduction relations.

Theorem 3.6. Every rewriting sequence based on the reading and merging rulesterminates.
Proof. A tedious but straightforward inspection of each of the reading andmerging rules verifies the following: If

l ! r is an instance of these rules, then E(l) O/E(
r), u(l) >= u(r), and, for every natural number i, ji(l) >= ji(r). Definition 3.1ensures that O/ is monotonic, i.e., if

v results from u by the replacement of a subpart
x by y such that x O/ y, then u O/ v. Further, it is easily seen that if x and yare both either terms or environments such that

u(x) >= u(y) and ji(x) >= ji(y)for each natural number
i and if v is obtained from u by substituting y for x,then
ji(u) >= ji(v) for each natural number i. From these observations it followseasily that if

t1\Lambda rmt2 then E(t1) O/ E(t2). The theorem is now a consequence ofLemma 3.2.

The Suspension Calculus and Other Explicit Substitution Calculi * 15
As an interesting side note, we observe that the termination proof presented herehas been formally verified using the Coq proof assistant [Gacek 2006a].

3.2 Confluence for the Substitution Calculus
Theorem 3.6 assures us that every suspension expression has a \Lambda rm-normal form.From observations in Section 2 it follows therefore that every suspension term can

be reduced to a de Bruijn term and every environment can be rewritten to one ina simple form using the reading and merging rules. We now desire to show that
these normal forms are unique for any given expression. This would immediatelybe the case if we have the property of confluence, i.e., if for any

s, u and v suchthat
s\Lambda *rmu and s\Lambda *rmv we know that there must be a t such that u\Lambda *rmt and v\Lambda *rmt.A well-known result, proved, for instance, in [Huet 1980], is that confluence follows

from a weaker property known as local confluence for a reduction relation that isterminating. In our context this translates to it being sufficient to show for any
suspension expression s that if s\Lambda rmu and s\Lambda rmv then there must be an expression
t such that u\Lambda *rmt and v\Lambda *rmt. The usual method for proving local confluence fora rewrite system is to consider the different interfering ways in which pair of rules

can be applied to a given term and to show that a common term can be producedin each of these cases. We use this approach in proving local confluence for the
reading and merging rules here. The most involved part of the argument concernsthe interference of rule (m1) with itself. We discuss this situation first and then
use our analysis in proving the main result.

3.2.1 An associativity property for environment composition. The expression[[[[[[

t, ol1, nl1, e1]], ol2, nl2, e2]], ol3, nl3, e3]] can be transformed into a form correspond-ing to the term

t under a substitution represented by a single environment in twodifferent ways by using rule (m1). The composite environments in the two cases

are given by the expressions

{{{{e1, nl1, ol2, e2}}, nl2 + (nl1 . ol2), ol3, e3}}
and

{{e1, nl1, ol2 + (ol3 . nl2), {{e2, nl2, ol3, e3}}}}.
Conceptually, these environments correspond to first composing e1 and e2 and thencomposing the result with

e3 or, alternatively, to composing e1 with the result ofcomposing
e2 with e3. An important requirement for local confluence is that thesetwo environments can be made to converge to a common form, i.e., environment

composition must, in a sense, be associative. We show this to be the case here.The argument we provide is inductive on the structures of the three environments
and has the following broad outline: Based on the specific context, we considerthe simplification of one of the two environments by relevant reading and merging
rules. We then show that the other expression can also be rewritten, possibly byusing the same rules, either to the same expression as the first or to an expression
that is amenable to the use of the induction hypothesis.We begin by noting some properties of the reading and merging rules that are
useful in filling out the details of the proof. The first of these relates to the secondenvironment displayed above and has the following content: At some point in the

16 * A. Gacek and G. Nadathur
reduction of this expression, it becomes possible to apply the rules relevant toevaluating the composition of

e2 and e3. Applying these rules immediately doesnot limit the normal forms that can be produced. This observation is contained in

the next two lemmas.

Lemma 3.7. Let A be the environment {{e1, nl1, ol1, {{e2, nl2, ol3, e3}}}} where e3is a simple environment and

e2 is of the form (t2, n2) :: e02. Further, for any positivenumber
i such that i <= nl2 - n2 and i <= ol3, let B be the environment

{{e1, nl1, ol1, {{e2, nl2 - i, ol3 - i, e3{i}}}}}.
If A\Lambda *rmC for any simple environment C then also B\Lambda *rmC.

Proof. It suffices to verify the claim when i = 1; an easy induction on i thenextends the result to the cases where

i > 1. For the case of i = 1, the argument isby induction on the length of the reduction sequence from

A to C with the essentialpart being a consideration of the first rule used. The details are straightforward

and hence omitted.

Lemma 3.8. Let A be the environment {{e1, nl1, ol1, {{e2, nl2, ol3, e3}}}} where e2and

e3 are environments of the form (t2, nl2) :: e02 and (t3, n3) :: e03, respectively.Further, let

B be the environment

{{e1, nl1, ol1, ([[t2, ol3, n3, e3]], n3 + (nl2 . ol3)) :: {{e02, nl2, ol3, e3}}}}.
If A\Lambda *rmC for any simple environment C then also B\Lambda *rmC.

Proof. The proof is again by induction on the length of the reduction sequencefrom

A to C. The first rule in this sequence either produces B, in which casethe lemma follows immediately, or it can be used on

B (perhaps at more thanone place) to produce a form that is amenable to the application of the induction

hypothesis.

In evaluating the composition of e2 and e3, it may be the case that some partof

e3 is inconsequential. The last observation that we need is that this part can be"pruned" immediately in calculating the composition of the combination of

e1 and
e2 with e3. The following lemma is consequential in establishing this fact.

Lemma 3.9. Let A be the environment {{e1, nl1, ol2, e2}} where e2 is a simpleenvironment.

(1 ) If ol2 <= nl1 - lev (e1) then A reduces to any simple environment that e1 reducesto.
(2 ) For any positive number i such that i <= nl1 - lev(e1) and i <= ol2, A reduces toany simple environment that {{

e1, nl1 - i, ol2 - i, e2{i}}} reduces to.

Proof. Let e1 be reducible to the simple environment e01. Then we may trans-form

A to the form {{e01, nl1, ol2, e2}}. Recalling that the level of an environment isnever increased by rewriting, we have that lev (

e01) <= lev (e1). From this it followsthat
A can be rewritten to e01 using rules (m5) and (m2) if ol2 <= nl1 - lev (e1). Thisestablishes the first part of the lemma.

The second part is nontrivial only if nl1 - lev (e1) and ol2 are both nonzero.Suppose this to be the case and let

B be {{e1, nl1 - 1, ol2 - 1, e2{1}}}. The desired

The Suspension Calculus and Other Explicit Substitution Calculi * 17
result follows by an induction on i if we can show that A can be rewritten to anysimple environment that

B reduces to. We do this by an induction on the lengthof the reduction sequence from

B to the simple environment. This sequence mustevidently be of length at least one. If a proper subpart of

B is rewritten by thefirst rule in this sequence, then the same rule can be applied to

A as well and theinduction hypothesis easily yields the desired conclusion. If
B is rewritten by oneof the rules (m3)-(m6), then it must be the case that
A\Lambda rmB via either rule (m4) or(m5) from which the claim follows immediately. Finally, if

B is rewritten using rule(m2), then
ol2 <= nl1 - lev (e1). The second part of the lemma is now a consequenceof the first part.

We now prove the associativity property for environment composition:
Lemma 3.10. Let A and B be environments of the form

{{{{e1, nl1, ol2, e2}}, nl2 + (nl1 . ol2), ol3, e3}}
and

{{e1, nl1, ol2 + (ol3 . nl2), {{e2, nl2, ol3, e3}}}},
respectively. Then there is a simple environment C such that A\Lambda *rmC and B\Lambda *rmC.

Proof. We assume that e1, e2 and e3 are simple environments; if this is not thecase at the outset, then we may rewrite them to such a form in both

A and B beforecommencing the proof we provide. Our argument is now based on an induction on

the structure of e3 with possibly further inductions on the structures of e2 and e1.
Base case for first induction. When e3 is nil, the lemma is seen to be true byobserving that both

A and B rewrite to {{e1, nl1, ol2, e2}} by virtue of rule (m2).

Inductive step for first induction. Let e3 = (t3, n3) :: e03. We now proceed by aninduction on the structure of

e2.

Base case for second induction. When e2 is nil, it can be seen that, by virtue of rules(m2), (m3) and either (m4) or (m5),

A and B reduce to {{e1, nl1, ol3 - nl2, e3{nl2}}}when
ol3 > nl2 and to e1 otherwise. The truth of the lemma follows immediatelyfrom this.

Inductive step for second induction. Let e2 = (t2, n2) :: e02. We consider first thesituation where

nl1 > lev(e1). Suppose further that ol3 <= (nl2 - n2). Using rules(m5) and (m2), we see then that

B\Lambda *rm{{e1, nl1, ol2, e2}}.
We also note that ol3 <= (nl2 + (nl1 . ol2)) - lev({{e1, nl1, ol2, e2}}) in this case.Lemma 3.9 assures us now that

A can be rewritten to any simple environment that{{
e1, nl1, ol2, e2}} reduces to and thereby verifies the lemma in this case.It is possible, of course, that

ol3 > (nl2 - n2). Here we see that

B\Lambda *rm{{e1, nl1 - 1, ol2 + (ol3 . nl2) - 1,{{

e02, n2, ol3 - (nl2 - n2), e3{nl2 - n2}}}}}.

using rules (m5) and (m6). Using rule (m5), we also have that

A\Lambda *rm{{{{e1, nl1 - 1, ol2 - 1, e02}}, nl2 + (nl1 . ol2), ol3, e3}}.

18 * A. Gacek and G. Nadathur
Invoking the induction hypothesis, it follows that A and

{{e1, nl1 - 1, ol2 + (ol3 . nl2) - 1, {{e02, nl2, ol3, e3}}}}
reduce to a common simple environment. By Lemma 3.7 it follows that B mustalso reduce to this environment.

The only remaining situation to consider, then, is that when nl1 = lev(e1). Forthis case we need the last induction, that on the structure of

e1.

Base case for final induction. If e1 is nil, then nl1 must be 0. It follows easily thatboth

A and B reduce to {{e2, nl2, ol3, e3}} and that the lemma must therefore betrue.

Inductive step for final induction. Here e1 must be of the form (t1, nl1) :: e01. Wedispense first with the situation where

n2 < nl2. In this case, by rule (m5)

B\Lambda *rm{{e1, nl1, ol2 + (ol3 . nl2), {{e2, nl2 - 1, ol3 - 1, e03}}}}.
By the induction hypothesis used relative to e03, B and the expression

{{{{e1, nl1, ol2, e2}}, nl2 + (nl1 . ol2) - 1, ol3 - 1, e03}}
must reduce to a common simple environment. By Lemma 3.9, A must also reduceto this environment.

Thus, it only remains for us to consider the situation in which n2 = nl2. In thiscase by using rule (m1) twice we may transform

A to the expression Ah :: At where

Ah = ([[[[t1, ol2, n2, e2]], ol3, n3, e3]], n3 + ((nl2 + (nl1 . ol2)) . ol3))
and

At = {{{{e01, nl1, ol2, e2}}, nl2 + (nl1 . ol2), ol3, e3}}.
Similarly, B may be rewritten to the expression Bh :: Bt where

Bh = ([[t1, ol2 + (ol3 . nl2), n3 + (nl2 . ol3),([[

t2, ol3, n3, e3]], n3 + (nl2 . ol3)) :: {{e02, nl2, ol3, e3}}]],
n3 + (nl2 . ol3) + (nl1 . (ol2 + (ol3 . nl2))))

and

Bt = {{e01, nl1, ol2 + (ol3 . nl2),([[

t2, ol3, n3, e3]], n3 + (nl2 . ol3)) :: {{e02, nl2, ol3, e3}}}}.

Now, using straightforward arithmetic identities, it can be seen that the "index"components of

Ah and Bh are equal. Further, the term component of Ah can berewritten to a form identical to the term component of

Bh by using the rules (m1)and (m6). Finally, by virtue of the induction hypothesis, it follows that

At and theexpression

{{e01, nl1, ol2 + (ol3 . nl2), {{e2, nl2, ol3, e3}}}}
reduce to a common simple environment. Lemma 3.8 allows us to conclude that Btcan also be rewritten to this expression. Putting all these observations together it

is seen that A and B can be reduced to a common simple environment in this caseas well.

The Suspension Calculus and Other Explicit Substitution Calculi * 19
3.2.2 Uniqueness of Substitution Normal Forms. We can now show that \Lambda rm isa locally confluent reduction relation.

Lemma 3.11. For any expressions s, u and v such that s\Lambda rmu and s\Lambda rmv theremust be an expression

t such that u\Lambda *rmt and v\Lambda *rmt.

Proof. We recall the method of proof from [Huet 1980]. An expression t con-stitutes a nontrivial overlap of the rules

R1 and R2 at a subexpression s if (a) t isan instance of the lefthand side of
R1, (b) s is an instance of the lefthand side of
R2 and also does not occur within the instantiation of a variable on the lefthandside of

R1 when this is matched with t and (c) either s is distinct from t or R1 isdistinct from

R2. Let r1 be the expression that results from rewriting t using R1and let
r2 result from t by rewriting s using R2. Then the pair hr1, r2i is called theconflict pair corresponding to the overlap in question. Relative to these notions,

the lemma can be proved by establishing the following simpler property: for everyconflict pair corresponding to the reading and merging rules, it is the case that the
two terms can be rewritten to a common form using these rules.In completing this line of argument, the nontrivial overlaps that we have to
consider are those between (m1) and each of the rules (r1)-(r6), between (m1)and itself and between (m2) and (m3). The last of these cases is easily dealt
with: the two expressions constituting the conflict pair are identical, both be-ing nil. The overlap between (m1) and itself occurs over a term of the form
[[[[[[t, ol1, nl1, e1]], ol2, nl2, e2]], ol3, nl3, e3]]. By using rule (m1) once more on eachof the terms in the conflict pair, these can be rewritten to expressions of the form
[[t, ol0, nl0, e0]] and [[t, ol00, nl00, e00]], respectively, whence we can see that ol0 = ol00 and
nl0 = nl00 by simple arithmetic reasoning and that e0 and e00 reduce to a commonform using Lemma 3.10. The overlaps between (m1) and the reading rules are also

easily dealt with. For instance consider the case of (m1) and (r1). Using rule (r1),the two terms in the conflict pair can be rewritten to the same constant. The other
cases are similar even if a bit more tedious.

As observed already, the main result of this subsection follows directly fromLemma 3.11 and Theorem 3.6.

Theorem 3.12. The relation \Lambda rm is confluent.
The uniqueness of \Lambda rm-normal forms is an immediate consequence of Theo-rem 3.12. In the sequel, a notation for referring to such forms will be useful.

Definition 3.13. The notation |t| denotes the \Lambda *rm-normal form of a suspensionexpression

t.

It is easily seen that the \Lambda rm-normal form for a term that does not contain metavariables is a term that is devoid of suspensions, i.e., a de Bruijn term. A further

observation is that if the all the environments appearing in the original term aresimple, then just the reading rules suffice in reducing it to the de Bruijn term that
is its unique \Lambda rm-normal form.
3.3 An Equivalence Property Relating to Renumbering Substitutions
An important role for the subcalculus for substitutions is that of realizing therenumbering of de Bruijn indices necessitated by beta contractions. One mechanism

20 * A. Gacek and G. Nadathur

t , t e , e
t1 , t01 t2 , t02

t1 t2 , t01 t02

t , t0 e , e0
(t, n) :: e , (t0, n) :: e0

t , t0
* t , * t0

e1 , e01 e2 , e02{{
e1, nl1, ol2, e2}} , {{e01, nl1, ol2, e02}}

t , t0 e , e0
[[t, ol, nl, e]] , [[t0, ol, nl, e0]]

t , t0
(t, n) , (t0, n)

t , t0 r , r0 e , e0
([[t, ol, nl, r]], nl + k) :: e , ([[t0, ol, nl0, r0]], nl0 + k) :: e0

Fig. 2. The similarity relation, ,
for controlling such renumbering is the new embedding level in a suspension, i.e.,the value chosen for

nl in an expression of the form [[t, ol, nl, e]]. Looking at thereading rule (r3), we see that another component that determines renumbering is

the index of an environment term, i.e., the value chosen for n in an item of the form(

t, n) in an environment. Now, these different mechanisms appear in juxtapositionin an environment item of the form ([[

t, ol, nl, e]], n). We observe here that \Lambda rm-normal forms are invariant under a coordinated readjustment of the renumbering

burden between the two devices in such an expression.The permitted reapportionment is expressed formally through the notion of similarity defined below.

Definition 3.14. The similarity relation between (well-formed) terms and envi-ronments, respectively, is denoted by , and is given by the rules in Figure 2.

The property of interest is then the following:
Theorem 3.15. If t and t0 are terms such that t , t0, then |t| = |t0|. If e and e0are environments such that

e , e0, then they rewrite by reading and merging rulesto similar simple environments.

Proof. Only a sketch is provided here; a detailed proof may be found in [Gacek2006b]. Using the translation function from Definition 3.5, we define the relation
AE on suspension expressions as follows: u AE v just in case E(u) O/ E(v). ObviouslyAE is a well-founded partial order. It is also easily seen that

u AE v if either v is asub-expression of
u or u\Lambda rmv.The argument is now an inductive one based on the ordering induced by AE on

pairs of expressions. In filling out the details, when considering two expressions uand

v such that u , v, the additional properties of AE and the induction hypothesisallow us to assume that any similar subparts of

u and v that are terms are identicaland that are environments are simple. We then consider the different cases for the

structures of u and v and the rewriting rules that are applicable to them. The onlynontrivial case when

u and v are terms arises when these are suspensions to which

The Suspension Calculus and Other Explicit Substitution Calculi * 21
rule (r3) is applicable and the environment parts of these terms are similar but notidentical. In this case we have

u = [[#1, ol, nl, ([[tr, olr, nlr, r]], nlr + k) :: e]]

\Lambda (r3) [[[[tr, olr, nlr, r]], 0, nl - (nlr + k), nil]]
\Lambda (m1) [[tr, olr, nl - (nlr + k) + nlr, {{r, nlr, 0, nil}}]]
\Lambda (m2) [[tr, olr, nl - k, r]]

v = [[#1, ol, nl, ([[tr, olr, nl0r, r0]], nl0r + k) :: e0]]

\Lambda (r3) [[[[tr, olr, nl0r, r0]], 0, nl - (nl0r + k), nil]]
\Lambda (m1) [[tr, olr, nl - (nl0r + k) + nl0r, {{r0, nl0r, 0, nil}}]]
\Lambda (m2) [[tr, olr, nl - k, r0]]

By assumption, r , r0. Since u AE [[tr, olr, nl - k, r]] and v AE [[tr, olr, nl - k, r0]], theinduction hypothesis yields the desired conclusion. For environments, the nontrivial

cases arise when u and v are of a form to which the rules (m5) or (m6) apply. Theargument here is similar albeit more tedious.

Theorem 3.15 casts an interesting light on rule (m6) of the suspension calculus.This rule has the form

{{(t, n) :: e1, n, ol2, (s, l) :: e2}} !([[

t, ol2, l, (s, l) :: e2]], m) :: {{e1, n, ol2, (s, l) :: e2}}

where m = l + (n . ol2). The righthand side of the rule has an environment itemin which both an index and a new embedding level is chosen. Observe that a value

larger than l could also be used for the new embedding level so long as the index iscorrespondingly modified and it remains consistent with the context in which the
replacement is performed. Intuitively, this would correspond to eagerly relativizing[[

t, ol2, l, (s, l) :: e2]] to a context with a larger number of enclosing abstractions andtaking cognizance of this in its subsequent substitution.

3.4 Confluence for the Full Calculus
Now we turn to the confluence of the system given by the rules in Figure 1 thatincludes the (

fis) rule in addition to the ones for interpreting substitutions. Inestablishing this property, we adopt the method used in [Curien et al. 1996] to

demonstrate that the *oe-calculus is confluent. The following lemma, proved in[Curien et al. 1996], is a critical part of the argument.

Lemma 3.16. Let R and S be two reduction relations defined on a set X withR being confluent and strongly normalizing and S satisfying the property that for
every t, u and v such that t S u and t S v there is an s such that u S s and v S s.Further suppose that for every

t, u and v such that t S u and t R v there is an ssuch that
u R* s and v (R* [ S [ R*) s. Then the relation R* [ S [ R* is confluent.

In applying this lemma, we shall utilize the parallelization of \Lambda fis that is definedbelow.

Definition 3.17. The relation \Lambda fisk on suspension expressions is defined by therules in Figure 3.

22 * A. Gacek and G. Nadathur

t ! t e ! e
t1 ! t01 t2 ! t02

t1 t2 ! t01 t02

t ! t0 e ! e0
(t, l) :: e ! (t0, l) :: e0

t ! t0
* t ! * t0

e1 ! e01 e2 ! e02{{
e1, nl1, ol2, e2}} ! {{e01, nl1, ol2, e02}}

t ! t0 e ! e0
[[t, ol, nl, e]] ! [[t0, ol, nl, e0]]

t1 ! t01 t2 ! t02
(* t1) t2 ! [[t01, 1, 0, (t02, 0) :: nil]]

Fig. 3. Rules defining \Lambda fisk
Theorem 3.18. The relation \Lambda rmfis is confluent.
Proof. Let R be \Lambda rm and let S be \Lambda fisk. We observe then that

\Lambda rmfis ` (R* [ S [ R*) ` \Lambda *rmfis .
Thus (R* [ S [ R*)* = \Lambda *rmfis and hence \Lambda rmfis would be confluent if (R* [ S [ R*)is.

To establish the latter we use Lemma 3.16, interpreting R and S as per thenomenclature of the lemma. We have already seen that

\Lambda rm is both confluentand strongly normalizing. To show that if
t\Lambda fisku and t\Lambda fiskv then there is an ssuch that
u\Lambda fisks and v\Lambda fisks, we argue by induction on the structure of t and byconsidering the rules by which

u and v are obtained. The only non-trivial case isthat when
t is the term (* t1) t2, one of u and v is [[t01, 1, 0, (t02, 0) :: nil]] and theother is (
* t001 ) t002 where t1\Lambda fiskt01, t1\Lambda fiskt001 , t2\Lambda fiskt02 and t2\Lambda fiskt002. By the inductionhypothesis, there exists an

s1 such that t01\Lambda fisks1 and t001 \Lambda fisks1 and an s2 such that
t02\Lambda fisks2 and t002 \Lambda fisks2. We then pick s as [[s1, 1, 0, (s2, 0) :: nil]]; obviously u\Lambda fisksand

v\Lambda fisks.It only remains for us to show that for any

t, u and v such that t\Lambda fisku and
t\Lambda rmv there is an s such that u\Lambda *rms and v (\Lambda *rm [ \Lambda fisk [ \Lambda *rm) s. We do this againby induction on the structure of

t. The argument is straightforward in all casesexcept perhaps when
t is [[(* t1) t2, ol, nl, e]], v is [[* t1, ol, nl, e]] [[t2, ol, nl, e]] and uis [[[[
t01, 1, 0, (t02, 0) :: nil]], ol, nl, e0]] where t1\Lambda fiskt01, t2\Lambda fiskt02 and e\Lambda fiske0. However,if we pick

s to be

[[t01, ol + 1, nl, ([[t02, ol, nl, e0]], nl) :: e0]]
we can easily show that it satisfies the requirements, thus completing the argumenteven in this case.

Theorem 3.18 strengthens the confluence result established for the original sus-pension calculus in [Nadathur and Wilson 1998] in that it shows that this property

The Suspension Calculus and Other Explicit Substitution Calculi * 23
holds even when meta variables are permitted in terms. Although we have onlyshown this property to hold for the refinement of the suspension calculus presented
here, our argument can be easily adapted to the original version.
3.5 Simulation of Beta Reduction
A fundamental requirement of any explicit substitution calculus is that it shouldallow for the simulation of beta reduction in the usual

*-calculus. In framing thisrequirement properly for the suspension calculus, it is necessary, first of all, to restrict attention to the situation where meta variables do not appear in terms. Inthis setting, as observed already, the lambda calculus terms under the de Bruijn notation are exactly those suspension terms that are devoid of suspensions. Moreover,beta contraction, denoted by

\Lambda fi, is defined as follows:

Definition 3.19. Let t be a de Bruijn term and let s1, s2, s3, . . . represent aninfinite sequence of de Bruijn terms. Then the result of simultaneously substituting

si for the i-th free variable in t for i >= 1 is denoted by S(t; s1, s2, s3, . . .) and isdefined recursively as follows:

(1) S(c; s1, s2, s3, . . .) = c, for any constant c,
(2) S(#i; s1, s2, s3, . . .) = si for any variable reference #i,
(3) S((t1 t2); s1, s2, s3, . . .) = (S(t1; s1, s2, s3, . . .) S(t2; s1, s2, s3, . . .)), and
(4) S((* t); s1, s2, s3, . . .) = (* S(t; #1, s01, s02, s03, . . .)) where, for i >= 1,

s0i = S(si; #2, #3, #4, . . .).

Using this substitution operation, the fi-contraction rule is given by the following

((* t1) t2) ! S(t1; t2, #1, #2, . . .).
A de Bruijn term t is related via fi-contraction to s if s results from t by theapplication of this rule at an appropriate subterm. We denote this relationship by

\Lambda fi. Beta reduction is the reflexive and transitive closure of \Lambda fi.

One part of the relationship between the suspension and lambda calculi that mayalso be viewed as the soundness of the (

fis) rule is the following:

Theorem 3.20. Let t and s be suspension terms such that t\Lambda fiss. Then |t|\Lambda *fi|s|.
Proof. This theorem is proved for the original suspension calculus in [Nadathurand Wilson 1998]. The result carries over to the version of the calculus presented

here by virtue of Lemma 2.9.

The ability of the suspension calculus to simulate beta reduction is a suitablystated converse to the above theorem.

Theorem 3.21. Let t and s be de Bruijn terms such that t\Lambda *fis. Then t \Lambda *rmfiss.
Proof. It has been shown in [Nadathur and Wilson 1998] for the original for-mulation of the suspension calculus that if

t\Lambda *fis then t\Lambda *rfiss. This observationcarries over to the present version since the rules defining

\Lambda rfis have essentiallybeen preserved. The theorem obviously follows from this.

24 * A. Gacek and G. Nadathur
4. COMPARISON WITH OTHER EXPLICIT SUBSTITUTION CALCULI
We now survey some of the other explicit treatments of substitutions that have beenproposed and contrast them with the suspension calculus. We restrict our attention in this study to calculi that utilize the de Bruijn scheme for representing boundvariables. A good approach to understanding such calculi is to characterize them
based on properties that are desired of them over and above their ability to encodesubstitutions. These are three such properties in our understanding: the ability
to compose reduction substitutions, confluence in a situation where graftable metavariables are included and the preservation of strong normalizability for terms in
the underlying lambda calculus. The first of these properties is central to combiningsubstitution walks in normalization. Without it, for instance, the reduction of the
term (* * t1) t2 t3 would require two separate traversals to be made over t1 for thepurpose of substituting

t2 and t3 for the relevant bound variables in it. The sec-ond property is important in developing algorithms that exploit the grafting view

of meta variables. For example, confluence in the presence of such variables is acentral requirement in realizing a new approach to higher-order unification [Dowek
et al. 2000]. The final property has both a theoretical and a practical significance.At a theoretical level, it measures the coherence of the calculus. Explicit treatments
of substitution are obtained usually by adding a terminating set of rules for car-rying out the substitutions generated by beta contractions. The non-preservation
of strong normalizability should, in this setting, be read as an undesirable interfer-ence between different parts of the overall rewrite system. At a practical level, this
signifies that caution must be exercised in designing normalization procedures.

Of these various properties, the one that appears to be most important in prac-tice is the ability to combine reduction substitutions: studies show that it is central
to the efficient implementation of reduction [Liang et al. 2004], and, as indicated inSection 2, it also appears to be a natural way to realize confluence in the presence
of graftable meta variables. Unfortunately, the majority of the explicit substitutioncalculi seem not to include this facility. Particular calculi sacrifice other properties
as well. The *AE-calculus [Benaissa et al. 1996] preserves strong normalizability butdoes not permit graftable meta variables. The

*se-calculus permits such variablesand is confluent even with this addition [Kamareddine and R'ios 1997] but does not

preserve strong normalizability [Guillaume 2000]. The *i-calculus [Mu~noz 1996]possesses both properties but obtains confluence by effectively requiring beta redexes to be contracted in an innermost fashion. Amongst the systems that do notpermit the combination of substitutions, the

*wso-calculus alone preserves strongnormalizability and realizes confluence in the presence of graftable meta variables

without artificially limiting reduction strategies [David and Guillaume 2001].

The only systems that permit the combination of reduction substitutions are,to our knowledge, the

*oe-calculus [Abadi et al. 1991], the closely related \Lambda CCLcalculus [Field 1990] and the suspension calculus. The first two calculi are practically identical and, for this reason, we restrict our discussion of them to onlythe

*oe-calculus. The suspension and the *oe-calculus both admit graftable metavariables without losing confluence and they are similar in many other respects as

The Suspension Calculus and Other Explicit Substitution Calculi * 25
well4. However, they have two important differences. One of these relates to themanner in which they represent substitutions. The

*oe-calculus encodes these asindependent entities that can be separated from the term that they act on. This is

a pleasant property at a formal level but it also leads to inefficiencies in the treat-ment of the renumbering of bound variables that is necessary when a substitution
is moved under an abstraction. The second difference concerns the treatment ofbound variables. In the

*oe-calculus, these are encoded as environment transform-ing operators in contrast to their representation directly as de Bruijn indices in

the suspension calculus. The former representation is parsimonious in that rulesthat serve to compose substitutions can also be used to interpret bound variables.
However, there are also disadvantages to such parsimony. It appears more difficult,for example, to separate out rules based on purpose and, hence, to identify simpler,
yet complete, subsystems as has been done for the suspension calculus [Nadathur1999]. The ambiguity in function also appears to play a role in the non-preservation
of strong normalizability in the *oe-calculus [Mellies 1995]: although the status ofthis property for the suspension calculus is as yet undetermined, a more focussed
treatment of substitution composition disallows the known counterexample for the
*oe-calculus to be reproduced within it.In the rest of this section we use the suspension calculus as a means for understanding the different treatments of explicit substitutions in more detail. We alsoattempt to substantiate the qualitative comparisons that we have provided above.
Our approach to doing this is to describe translations between the suspension calcu-lus and the other calculi that illuminate their differing characteristics. None of the
calculi that we consider treat constants in terms and, for the sake of consistency,we assume these are missing also in suspension terms. We also do not include meta
variables initially since these are not present in all calculi, but we bring them intoconsideration later as relevant. We divide our discussion of the other calculi into
two subsections depending on whether or not they possess an ability to combinesubstitutions. As we shall see below, the calculi that do not have a combining
capability correspond substantially to the suspension calculus without the mergingrules.

4.1 Calculi Without Substitution Composition
We discuss three calculi under this rubric: the *AE-calculus [Benaissa et al. 1996],the

*s-calculus [Kamareddine and Rios 1995], and the *se-calculus [Kamareddineand R'ios 1997]. Qualitatively, these calculi provide an increasing sequence of capabilities. When the de Bruijn representation is used for lambda terms, the indices ofexternally bound variables in a term have to be incremented when it is substituted
under an abstraction. The *AE-calculus requires such renumbering to be carriedout in separate walks for each abstraction that the term is substituted under. The
*s-calculus improves on this situation by permitting all the renumbering walks tobe combined into one although such a walk is still kept distinct from walks that
realize substitutions arising out of beta contractions. The *se-calculus extends the
4To be accurate in spirit as well as in detail this statement needs a qualification: as we discuss
later in the section, the original rewrite system of the *oe-calculus needs to be extended slightly
to obtain confluence in the presence of graftable meta variables.

26 * A. Gacek and G. Nadathur

(B) (* a) b ! a[b/] (VarShift) n["] ! n + 1
(App) (a b)[s] ! a[s] b[s] (FVarLift) 1[*(s)] ! 1
(Lambda) (* a)[s] ! * a[*(s)] (RVarLift) n + 1[*(s)] ! n[s]["]

(FVar) 1[a/] ! a
(RVar) n + 1[a/] ! n

Fig. 4. Rewrite rules for the *AE-calculus
*s-calculus by permitting graftable meta variables.

4.1.1 The *AE-calculus. The syntax of this calculus comprises two categories:terms, corresponding to lambda terms possibly encoding explicit substitutions, and

substitutions.

Definition 4.1. The terms, denoted by a and b and the substitutions, denotedby

s, of the *AE-calculus are given by the following syntax rules:

a ::= n | a b | * a | a[s]
s ::= a/ | *(s) | "

The collection of expressions described may be understood intuitively as follows.The expression

n represents the nth de Bruijn index, analogously to #n in thesuspension calculus. The binary operator [ ], referred to as a closure, introduces

explicit substitutions into terms. The expression a/, created using the operator
/ called slash, represents the substitution of a for the first de Bruijn index and ashifting down of all other de Bruijn indices. The substitution *(

s), which uses theoperator * called lift, provides a device for pushing substitutions underneath abstractions. Finally, the expression ", called shift, represents the effect of increasingthe de Bruijn indices corresponding to externally bound variables by one.

The interpretations of the various syntactic devices are made explicit by the rulesin Figure 4 that define the

*AE-calculus. The rule labelled (B) in this collectionemulates beta contraction by generating an explicit substitution. The rest of the

rules, that constitute the sub-calculus AE, serve to propagate such substitutions overthe structure of a lambda term and to eventually evaluate them at the bound
variable occurrences.In relating the suspension and the

*AE-calculus it is natural to identify the syn-tactic categories of terms in the two settings and to think of environments in the

former framework as corresponding to substitutions in the latter. There is, how-ever, an important difference in the view of the latter two entities. Substitutions in
the *AE-calculus are self-contained objects that carry all the information needed forunderstanding them in context. In contrast, the interpretation of an environment
requires also an associated old and new embedding level in the suspension calculus.This intuition underlies the following translation of

*AE to suspension expressions.

Definition 4.2. The mappings T from terms in the *AE-calculus to terms in thesuspension calculus and

E from substitutions in the *AE-calculus to triples consistingof two natural numbers and a suspension environment are defined by recursion as

follows:

The Suspension Calculus and Other Explicit Substitution Calculi * 27
(1) For a term t, T (t) is #n if t is n, (T (a) T (b)) if t is (a b), * T (a) if t is * a, and[[

T (a), ol, nl, e]] if t is a[s] and E(s) = (ol, nl, e).

(2) For a substitution s, E(s) is (1, 0, (T (a), 0) :: nil) if s is a/, (0, 1, nil) if s is ",and (

ol + 1, nl + 1, (#1, nl + 1) :: e) if s is *(s0) and E(s0) = (ol, nl, e).

It is easy to see that T (a) must be a well-formed suspension term for every term
a in the *AE-calculus. The difference in representation of bound variables in thetwo calculi is clearly only a cosmetic one and we shall ignore it in the discussion

that follows. It is obvious then that T is a translation that preserves de Bruijnterms. It can also be easily verified is that

T and E are one-to-one mappings.There are, however, many suspension terms that are not the images under

T of anyterm in the
*AE-calculus: the set of substitutions that can be encoded in the lattercalculus is quite limited. There are, in fact, only two forms that substitutions can

take: *(. . . *(a/) . . .), corresponding to preserving the first few de Bruijn indices,substituting

a (with appropriate renumbering) for the next one and decreasing theremaining indices by one, and *(

. . . *(") . . .), corresponding to preserving the firstfew de Bruijn indices and then incrementing the remaining ones by one. Thus, the

*AE-calculus cannot encode an expression such as [[t, 0, 2, nil]], where t is a de Bruijnterm, directly. This expression can be represented indirectly by

t["]["] that hasthe suspension term [[[[
t, 0, 1, nil]], 0, 1, nil]] as its image. This encoding highlights aproblem with the manner in which the

*AE-calculus treats renumbering of de Bruijnindices: incrementing by
n has to be realized through n separate walks that eachincrement by 1. A more drastic example of the limitations of the

*AE-calculus is thatit possesses no simple way to encode the suspension term [[
t, 1, 2, (s, 2) :: nil]] thatcorresponds to substituting
s for the first de Bruijn index in t and incrementingall the remaining indices by two. Finally, we note that only simple environments

appear in terms that are in the image of T . This is, of course, to be expected sincethe the

*AE-calculus does not support the ability to compose substitutions.At the level of rewriting, we would expect the

*AE-calculus to translate into thesubcalculus of the suspension calculus that excludes the merging rules. This is true

for the most part: it is easily seen that if l ! r is an instance of any rule in Figure 4other than (FVar) and (RVarLift), then

T (l) ! T (r) is an instance of either the(
fis) rule or one of the reading rules in Figure 1. For the (FVar) rule, we observefirst that the [[

t, 0, 0, nil]] ! t is an admissible rule in the suspension calculus in theabsence of graftable meta variables. Now, this fact can be used to build a special

case of (r3) into the rewrite system:

(r3') [[#1, ol, 0, (t, 0) :: e]] ! t
The (FVar) rule corresponds directly to (r3') under the translation we have de-scribed.

The situation for the (RVarLift) rule is more involved. Any term that matchesits lefthand side translates into a suspension term of the form

[[#(n + 1), ol + 1, nl + 1, (#1, nl + 1) :: e]]
where either e is nil, in which case ol is 0 and nl is 1, or e has a first element of theform (

t, nl). In the suspension calculus, rule (r4) allows this term to be rewrittento the form

28 * A. Gacek and G. Nadathur

[[#n, ol, nl + 1, e]].
In the case that e is nil, this suspension corresponds to incrementing the indices forexternally bound variables in a de Bruijn term, constituted here by #

n, by 2. If e isof the form (
t, nl) :: e0 on the other hand, then the suspension represents a situationin which one or more terms are to be substituted into a context that includes more

enclosing abstractions than were present in the context of their origin. The *AE-calculus is capable of representing neither situation directly but can encode both
indirectly via a term that translates to

[[[[#n, ol, nl, e]], 0, 1, nil]].
This is, in fact, the translation of the righthand side of the (RVarLift) rule. Thisterm can be reduced to [[#

n, ol, nl + 1, e]] by using the merging rules but representsthe introduction of an extra renumbering walk in the absence of these rules.

The above discussion casts light on the efficiency with which beta reduction canbe realized using the two calculi considered here. Normal forms for suspension
expressions involving only simple environments are identical whether or not themerging rules are utilized. From this it follows easily that the normal forms produced by the two systems must be identical.

4.1.2 The *s-calculus. The *s-calculus also distinguishes between beta contrac-tion and renumbering substitutions. However, it differs from the

*AE-calculus in thatit possesses a more general mechanism for renumbering de Bruijn indices and also

has a more concise way of recording which de Bruijn indices are actually affectedby beta contraction and renumbering substitutions. These devices are manifest in
the syntax of terms.

Definition 4.3. The terms of the *s-calculus, denoted by a and b, are given bythe rules

a ::= n | a b | * a | a oei b | 'ik a
where n and i range over positive integers and k ranges over non-negative integers.
Towards understanding this syntax, we observe first that de Bruijn terms are rep-resented in the

*s-calculus exactly as they are in the suspension calculus with thecosmetic difference that the

nth de Bruijn index is denoted directly by n ratherthan #
n. Beyond this, there are two additional kinds of expressions that serve tomake substitutions explicit. A term of the form

a oei b, called a closure and intendedto capture a beta contraction substitution, represents the substitution of a suitably

renumbered version of b for the ith de Bruijn index in a and a shifting down by oneof all de Bruijn indices greater than

i in a. A term of the form 'ik a, called an updateand included to treat renumbering, represents an increase by

i - 1 of all de Bruijnindices greater than
k. The purpose of these new kinds of expressions becomes clearfrom the rewriting rules for the

*s-calculus that are presented in Figure 5. The
oe-generation rule is the counterpart of beta contraction in this collection. The re-maining rules, referred to collectively as the

s rules, serve to calculate substitutionsintroduced into terms by applications of the

oe-generation rule.Closures and updates can be understood as special forms of suspensions. This

relationship is made precise by the following definition.

The Suspension Calculus and Other Explicit Substitution Calculi * 29
oe-generation (* a) b ! a oe1 b
oe-*-transition (* a) oei b ! * (a oei+1 b)
oe-app-transition (a1 a2) oei b ! (a1 oei b) (a2 oei b)

oe-destruction n oei b ! 8><>:

n - 1 if n > i
'i0 b if n = i
n if n < i

'-*-transition 'ik(* a) ! * ('ik+1 a)
'-app-transition 'ik(a1 a2) ! ('ik a1) ('ik a2)

'-destruction 'ik n ! (n + i - 1 if n > kn if n <= k

Fig. 5. Rewrite rules for the *s-calculus
Definition 4.4. The translation T of terms in the *s-calculus to suspension termsis defined by recursion as follows:

T (t) =

8??????????
!???????
???:

#n if t is n
T (a) T (b) if t = (a b)
* T (a) if t = * a
[[T (a), i, i - 1, (#1, i - 1) ::

(#1, i - 2) :: . . . :: (#1, 1) :: (T (b), 0) :: nil]] if t = a oei b and
[[T (a), k, k + i - 1, (#1, k + i - 1) ::

(#1, k + i - 2) :: . . . :: (#1, i) :: nil]] if t = 'ik a.

The image of the translation function T is, once again, evidently a subset of thewell-formed suspension terms. At a rewriting level, the

*s-calculus is, in a sense,contained within that fragment of the suspension calculus that excludes the merging

rules. Towards making this comment precise, we observe first that the followingis a derived rule of this fragment of the suspension calculus, assuming that

e is asimple environment:

[[#n, ol, nl, e]] = 8?!?:

#(n - ol + nl) if n > ol,
#(nl - l + 1) if n <= ol and e[n] = (#1, l), and
[[t, 0, nl - l, nil]] otherwise, assuming e[n] = (t, l).

In particular, this rule embodies a sequence of applications of the rules (r2)-(r4)from Figure 1. Now, if we augment the reading rules to also include this rule, then

the following theorem is easily proved:

Theorem 4.5. If a and b are terms of the *s-calculus such that a rewrites to bin one step using the rules in Figure 5, then then

T (a)\Lambda rfisT (b).

Noting that de Bruijn terms are preserved under the translation, we see then thatany normalization sequence in the

*s-calculus can be mimicked in a one-to-onefashion within this fragment of the suspension calculus.

The comments above indicate a correspondence at a theoretical level but theygloss over issues relevant to the practical implementation of reduction. First, as

30 * A. Gacek and G. Nadathur

oe-oe-transition (a oei b) oej c ! (a oej+1 c) oei(b oej-i+1 c) if i <= j
oe-'-transition 1 ('ik a) oej b ! 'i-1k a if k < j < k + i
oe-'-transition 2 ('ik a) oej b ! 'ik(a oej-i+1 b) if k + i <= j
'-oe-transition 'ik(a oej b) ! ('ik+1 a) oej('ik+1-j b) if j <= k + 1

'-'-transition 1 'ik('jl a) ! 'jl ('ik+1-j a) if l + j <= k
'-'-transition 2 'ik('jl a) ! 'j+i-1l a if l <= k < l + j

Fig. 6. Additional rewrite rules for the *se-calculus
the translation function indicates, the *s-calculus provides a rather succinct en-coding for the substitutions that arise when only the reading and the

fis rules areused. Second, the
s rules utilize this representation to realize substitution ratherefficiently in this context; observe, in this regard, that the derived reading rule actually embodies a possibly costly "look-up" operation that is necessary relative to themore elaborate encoding of substitutions used in the suspension calculus. However,
this efficiency has an associated cost: closures in the *s-calculus represent exactlyone beta contraction substitution and, consequently, multiple such substitutions
must be effected in separate walks. By contrast, even simple environments in thesuspension calculus have the flexibility for encoding multiple beta contraction and
arbitrary renumbering substitutions. Moreover, the merging rules are not neededin their full generality to exploit this capability: simple to implement derived rules
can be described for this purpose [Nadathur 1999]. It has been observed that theability to combine substitutions that is supported by the more general encoding for
them leads to significantly greater efficiency in realizing reduction in practice thandoes the concise encoding facilitated by treating restricted forms of substitutions
[Liang et al. 2004].

4.1.3 The *se-calculus and permutations of substitutions. The *s-calculus andthe

*AE-calculus lack confluence in the presence of graftable meta variables. Inthe absence of substitution composition, the only way to regain confluence is to

permit permutations of substitutions5. In the context of the *s-calculus, suchpermutability should apply to both the closure and the update forms of explicit
substitutions. The *se-calculus adds the rules in Figure 6 to those already presentin the

*s-calculus in support of such permutability. There must, of course, besome kind of directionality to the permitted substitution reorderings to ensure

termination and the side conditions on the new rules are intended to realize this.To understand the use of these rules and also the restrictions on permutations, we
may consider the term ((* ((* X) t1)) t2). Mimicking in the *se-calculus the tworeduction paths seen for this term in Section 2.4, we get the terms (

X oe1 t1) oe1 t2and (
X oe2 t2) oe1(t1 oe1 t2). Notice now that the oe-oe-transition rule is applicableonly to the first of these terms. Thus, intuitively, this rule permits the permutation

only of substitutions arising from the contraction of outer beta redexes over thosearising from contracting inner ones. The effect of carrying out this rearrangement

5We note here that permutation and composition of substitutions are distinct notions although
they seem sometimes to have been confused in the literature, e.g., see [Cosmo et al. 2003].

The Suspension Calculus and Other Explicit Substitution Calculi * 31
is to make the substitutions have the same form in both terms, as is desired.The

*se-calculus has been shown to have an adequate mix of permutation rules toensure confluence in the presence of meta variables [Kamareddine and R'ios 1997].

From the discussion of the oe-oe-transition rule it might appear that it also restrictsthese rules sufficiently to preserve strong normalizability. Unfortunately, this is not
the case: it has been shown that interactions between closures and updatings cangive rise to nontermination even when the starting point is a lambda term that
can be simply typed [Guillaume 2000]. The *ws-calculus [David and Guillaume2001] provides a remedy to this situation by extending the syntax of de Bruijn
terms (and hence the normal forms produced by reduction) to include terms withnumeric labels that represent yet-to-be-computed renumbering substitutions.

4.2 Calculi with Substitution Composition
As we have noted, the main exemplars of this variety of treatment of explicit sub-stitutions are the

*oe- and the suspension calculi. We discuss their relationshipbelow. In contrast to the earlier situations, it is now relevant to consider mappings

between these calculi in both directions.

4.2.1 The *oe-calculus. The *oe-calculus, like the *AE-calculus that is derivedfrom it, treats substitutions as independent entities that can be meaningfully separated from the terms they act upon. Thus, its syntax is determined by terms andsubstitutions.

Definition 4.6. The following syntax rules in which a and b denote terms and sand

t denote substitutions define the syntax of the *oe-calculus:

a ::= 1 | a b | * a | a[s]
s ::= id | a * s | s ffi t | "

A term of the form a[s] is called a closure and represents the term a with thesubstitution

s to be applied to it. The substitution id is the identity substitution.The substitution

a * s is called cons and represents a term a to be substituted forthe first de Bruijn index along with a substitution

s for the remaining indices.The substitution
s ffi t represents the composition of the substitution s with thesubstitution
t. Finally, the substitution " is called shift and is intended to capturethe increasing by 1 of all the de Bruijn indices corresponding to the externally

bound variables in the term it is applied to. A form of substitution that hasspecial significance is " ffi (" ffi * * * (" ffi ") * * * ). Assuming

n occurrences of " inthe expression, such a substitution represents an
n-fold increment to the de Bruijnindices of the externally bound variables in the term it operates on. The shorthand

"n is used for such an expression and the notation is further extended by allowing"

0 to denote id.

The reference to de Bruijn indices in the previous paragraph is accurate in spiritbut not in detail. The

*oe-calculus represents abstracted variables as environmenttransforming operators rather than as indices. Specifically, only the first abstracted

variable is represented directly by the index 1: for n > 1, the n-th such variable isrepresented by 1["

n-1]. When such a term is subjected to a substitution, the shift

operators will play a role in determining the appropriate term to replace it with, asthe rules of the calculus will elucidate. It will become clear then that composition

32 * A. Gacek and G. Nadathur

(Beta) (*a) b ! a[b * id]

(App) (a b)[s] ! a[s] b[s] (Map) (a * s) ffi t ! a[t] * (s ffi t)
(Abs) (*a)[s] ! *a[1 * (s ffi ")] (Ass) (s ffi t) ffi u ! s ffi (t ffi u)
(VarId) 1[id] ! 1 (IdL) id ffi s ! s
(VarCons) 1[a * s] ! a (ShiftId) " ffi id ! "
(Clos) a[s][t] ! a[s ffi t] (ShiftCons) " ffi (a * s) ! s

Fig. 7. Rewrite rules for the *oe-calculus
of substitutions is essential in this calculus even to the proper interpretation ofvariables bound by abstractions.

The rules that define the *oe-calculus are presented in Figure 7. In this collection,the (Beta) rule serves to simulate beta contraction. The remaining rules, that define
the subsystem oe, are meant to propagate substitutions generated by the (Beta)rule. The

oe rules in the left column compute the effect of substitutions on terms.The (Clos) rule may generate a composition of substitutions in this process that

the rules in the right column are useful in unravelling. Given two terms or twosubstitutions

u and v , we write u \Lambda *oe v or u \Lambda oe v to denote the fact that v resultsby replacing an appropriate subpart of

u using any of these rules or only one of the
oe rules, respectively. The reflexive and transitive closure of these relations is, asusual, denoted by

\Lambda **oe and \Lambda *oe .It is useful to understand the manner in which the rules of the

*oe-calculusfunction in the task of normalizing terms as a prelude to contrasting it with

the suspension calculus. Towards this end, consider the lambda term given by(

* * ((* * * #3) #2)) in the suspension calculus. This term is encoded by

(* * ((* * * 1["2]) 1["]))
in the *oe-calculus. Applying the (Beta) rule to the only redex in this term we get

(* * ((* * 1["2])[1["] * id])).
The substitution generated by beta contraction can now be moved inside the twoabstractions using the (Abs) rule to get the term

(* * * * (1["2][1 * (1 * ((1["] * id) ffi ") ffi ")]).
The substitution (1 * ((1["] * id) ffi ") ffi ") that appears in this expression depictsthe iterated adjustment of substitutions as they are pushed under abstractions in

*oe-calculus; by contrast, the suspension calculus captures the needed renumberingsimply by a global adjustment to the new embedding level. The next conceptual
step in the reduction is that of "looking up" the binding for the variable representedby 1["

2] in the substitution. This step requires the possible use of (ShiftCons) to

prune off an initial portion of the substitution and an eventual use of (VarId) toselect the desired term. However, the encoding of abstracted variables necessitates

the use of the rules (Clos), (Ass) and (Map) to prepare the situation for applyingthese rules. The term that results at the end of this process is (

* * * * 1[(" ffi ") ffi "]).The (Ass) rule can now be used to transform the term under all the abstractions

into the form 1[" ffi (" ffi ")] that is recognizable as the encoding of a de Bruijn index.

The Suspension Calculus and Other Explicit Substitution Calculi * 33
4.2.2 Translating suspension expressions into *oe-expressions. The non-trivialpart of this mapping concerns the treatment of environments in the suspension
calculus. Intuitively, these must correspond to substitutions in the *oe-calculus.However, environments obtain a meaning only relative to the new embedding level of
the suspension terms they appear in. Moreover, to be well-formed, this embeddinglevel must be at least as large as the level of the environment itself. Once this
constraint is satisfied, the example just considered suggests the right translation toa "standalone" substitution.

Definition 4.7. The mappings S from suspension terms to *oe-terms and R frompairs constituted by a suspension environment

e and a natural number i such that
lev(e) <= i to *oe-substitutions are defined simultaneously by recursion as follows:

(1) S(#1) = 1, S(#(n+1)) = 1["n] if n > 0, S(a b) = (S(a) S(b)), S(* a) = * S(a)and

S([[t, ol, nl, e]]) = S(t)[R(e, nl)].

(2) R(e, i) = 8?????!?????:

(. . . ((id

i occurrences of "z ""-- -ffi "

) ffi ") * * * ) ffi " if e = nil

(. . . (((S(t) * R(e0, n))

i-n occurrences of "z ""-- -ffi "

) ffi ") * * * ) ffi " if e = (t, n) :: e0 and
R(e1, nl1) ffi R(e2, i - (nl1 . ol2)) if e = {{e1, nl1, ol2, e2}}.

The constraint on the pairs that R applies to raises a question concerning the well-definedness of

R, and hence also of S. However, the well-formedness requirementon suspension expressions in Definition 2.3 ensures that these must be well-defined.

Another fact that is easy to verify is that these mappings are both one-to-one; thecritical observation in this regard is that Definition 4.7 is constructed so that

R(e, i)is not equal to "
j for any e, i and j. Finally, we observe a correspondence also at

the level of the rewriting:

Theorem 4.8. Let u and v be suspension expressions such that u\Lambda rmv (u \Lambda 
rmfisv). If u and v are terms, then there exists a *oe-term w such that S(u)\Lambda *oe w and
S(v) \Lambda *oe w (respectively, S(u) \Lambda **oe w and S(v) \Lambda **oe w). If u and v are environments,then for any

i such that lev(u) <= i, there is a *oe-substitution w such that R(u, i)\Lambda *oe
w and R(v, i) \Lambda *oe w (respectively R(u, i) \Lambda **oe w and R(v, i) \Lambda **oe w).

Proof. Applications of the rules (fis), (r5), (r6), (m1) and (m3) on suspensionexpressions map directly onto applications of (Beta), (App), (Abs), (Clos) and

(IdL), respectively, on their translations. Rule (r2) that corresponds to renumberinga de Bruijn index translates into a sequence of uses of the (Map) and (Ass) rules
in accordance with the representation of abstracted variables in the *oe-calculus.Rule (r3) is similar to the rule (VarCons). However, the translation of the lefthand
side must be "prepared" for the use of (VarCons) by a sequence of applications of(Map) and a peculiarity of the translation of the righthand side may require (IdL)
to be used on it to produce a common form. In a similar sense, the rules (r4), (m4)and (m5) correspond to a "compiled form" of (ShiftCons) and (m6) corresponds
to a compiled form of (Map). Finally, rule (m2) is similar to the use of (Ass) inproducing a normal form.

34 * A. Gacek and G. Nadathur

4.2.3 Translating *oe-expressions into suspension expressions. Going in the re-verse direction needs a decision on the range of the mapping for

*oe-substitutions.Considering a term of the form
a[s] indicates what this might be. Such a termshould translate into a suspension of the form [[

t, ol, nl, e]] where the triple (ol, nl, e)is obtained by "interpreting"
s. In the case when every composition in s has a shiftas its right operand, this triple can be arrived at in a natural way:

e should reflectthe substitution terms in
s, ol should be the number of such terms and nl, whichcounts the number of enclosing abstractions, should correspond to the length of

the longest sequence of compositions with shifts at the top level in s. The intu-ition underlying the encoding of general substitution composition in the suspension
calculus now allows this translation to be extended to arbitrary *oe-substitutions.

Definition 4.9. The mapping T from *oe-terms to suspension terms and the map-ping

E from *oe-substitutions to triples of an old embedding level, a new embeddinglevel, and a suspension environment are defined simultaneously by recursion as follows:
(1) T (1) = #1, T (a b) = (T (a) T (b)), T (* a) = * T (a) and T (a[s]) is #(n + 1)if

a is 1 and s is "n for n >= 0 and is [[T (a), ol, nl, e]] where E(s) = (ol, nl, e)otherwise.

(2) E(id) = (0, 0, nil), E(") = (0, 1, nil), E(a * s) = (ol + 1, nl, (T (a), nl) :: e)where

E(s) = (ol, nl, e), and E(s1 ffi s2) is (ol1, nl1 + 1, e1) if s2 is " and is(
ol1 + (ol2 . nl1), nl2 + (nl1 . ol2), {{e1, nl1, ol2, e2}}) otherwise, assuming that
E(s1) = (ol1, nl1, e1) and E(s2) = (ol2, nl2, e2).

It is easily seen that, for any term a of the *oe-calculus, T (a) is a well-formedsuspension term. The translation treats a term of the form 1["

n] as a special

case, reflecting its interpretation as the encoding of an abstracted variable. If thiscase were not singled out, the translation would produce the term [[#1

, 0, nl, nil]]instead. This term can be rewritten to #(
n + 1) by the rule (r2). A similarobservation applies to the translation of
s ffi ". This case is treated as a special oneto account for the manner in which a substitution is moved under an abstraction in

the *oe-calculus. If this issue were to be ignored, this substitution would translate to(

ol, nl + 1, {{e, nl, 0, nil}}) instead of (ol, nl + 1, e), assuming that E(s) = (ol, nl, e).The environment component of the former triple rewrites to that of the latter by

the rule (m2).The following theorem, whose proof is trivial, is evidence of the naturalness of
our translations:

Theorem 4.10. For every suspension term t, T (S(t)) = t.
In order to state a correspondence between the rewrite systems, we need to extendthe reduction relations on suspension expressions to triples of the form (

ol, nl, e)that are the targets of the mapping
E. We do this in the obvious way: a triple(
ol, nl, e) is related to (ol, nl, e0) by a rewriting relation just in case e is related to
e0 by that relation.

Theorem 4.11. If a and b are *oe-terms such that a\Lambda oe b (a\Lambda *oe b), then there is asuspension-term

u such that T (a)\Lambda *rmu (T (a)\Lambda *rmfisu) and T (b)\Lambda *rmu (T (b)\Lambda *rmfisu).If
s and t are *oe-substitutions such that s\Lambda oe t (s\Lambda *oe t) then there exist environments

The Suspension Calculus and Other Explicit Substitution Calculi * 35
e1 and e2 such that E(s)\Lambda *rm(ol, nl, e1) (E(s) \Lambda *rmfis(ol, nl, e1)), E(t)\Lambda *rm(ol, nl, e2)(

E(t)\Lambda *rm(ol, nl, e2)) and e1 , e2.

Proof. The argument is by induction on the structure of *oe-expressions. The-orem 3.15 permits us to focus on the situation where rewriting takes place at the

root of the expression. Also, the observations about the "redundancy" of the specialcases in the definitions of

T and E allow us to ignore them in the proof.Now, we can observe a relationship between several of the rules in the

*oe-calculusand rules in the suspension calculus: (Beta) corresponds to (
fis), (App) to (r5),(Abs) to (r6), (VarId) to (a special case of) (r2), (VarCons) to (r3), (Clos) to

(m1), (IdL) to (m3), (ShiftId) to (m2) and (ShiftCons) to (m4). In some casesthe correspondence is precise in that the translation of the lefthand side rewrites
exactly to the translation of the righthand side by the indicated rule. However, inmost cases, some "adjustments" using other reading and merging rules are needed
before or after the specific rule application to account for the peculiarities of thedifferent calculi.

The two rules that remain are (Map) and (Ass). The former corresponds to (m6)but the correspondence is not quite the same as with the other rules. Suppose
(a * s1) ffi s2 rewrites to a[s2] * (s1 ffi s2) by this rule. Let T (a) = t, E(s1) =(

ol1, nl1, e1), and E(s2) = (ol2, nl2, e2). The index components of E((a*s1)ffis2) and
E(a[s2]*(s1 ffis2)) are quickly seen to be identical. The environment components are{{(

t, nl1) :: e1, nl1, ol2, e2}} and ([[t, ol2, nl2, e2]], nl2 + (nl1 . ol2)) :: {{e1, nl1, ol2, e2}},respectively. These are like the left and right sides of rule (m6) with two differences.

First, e2 might not have the form (s, l) :: e02 that is needed by rule (m6). This canbe "fixed" by rewriting

e2 at the outset to such a form6. The second differenceis that the index of the first environment term on the right side uses

nl2 whererule (m6) uses
l. However, this is not a problem because the two environments areclaimed only to be similar, not identical.

Finally, turning to (Ass), we see that there is no rule in the suspension calculusthat "simulates" it. Rather, this rule corresponds to a meta property of the calculus
that was proved in Lemma 3.10.

4.2.4 Meta Variables and Preservation of Strong Normalizability. Our presen-tation of the

*oe-calculus is true to its original description in [Abadi et al. 1991].This rewrite system is not confluent when the syntax of terms is extended to include graftable meta variables. However, straightforward additions to the rule setsuffice to regain this property [Curien et al. 1996]; see also [Dowek et al. 2000] for
a system closer in form to the one discussed in this paper.The

*oe-calculus does not preserve strong normalizability as we have alreadynoted, although the substitution subsystem

oe is strongly normalizing. The cruxof the problem is that the (Beta) rule and the substitution rules can interact with

each other to get a substitution to scope over its own subcomponents. To see howthis might happen, consider the following reduction sequence adapted from [Mellies
1995]:

((* a0) b0)[((* a) b) * id]

6For completeness, the case where e2 reduces to nil must also be discussed. (Map) in this case is
related to (r2) and the argument is easier.

36 * A. Gacek and G. Nadathur

\Lambda *oe (* (a0[1 * ((((* a) b) * id) ffi ")])) b0[((* a) b) * id]
\Lambda Beta a0[1 * ((((* a) b) * id) ffi ")][b0[((* a) b) * id] * id]
\Lambda *oe a0[b0[((* a) b) * id] * ((((* a) b) * id) ffi (" ffi (b0[((* a) b) * id] * id)))]

The substitution (" ffi (b0[((* a) b) * id] * id)) that appears as a subexpression of thelast term in this sequence would be rewritten to

id in a sensible progression to anormal form. However, it can also perversely be distributed over the preceding

substitution using (Map) to produce the substitution subexpression

((* a) b)[" ffi (b0[((* a) b) * id] * id)] * (id ffi (" ffi (b0[((* a) b) * id] * id))).
Observe here that [((* a) b) * id] has become a subpart of a substitution that standsover the term ((

* a) b) that originates from itself.The preservation of strong normalizability is still an unsettled question with regard to the suspension calculus. However, Mellies' counterexample does not applyto this calculus because the kind of problem situation depicted above cannot be
created within it. In particular, rule (m6) that corresponds to (Map) in the sus-pension calculus ensures that only relevant portions of an external environment are
distributed over substitution terms.
5. CONCLUSION
This paper has presented a simplified and rationalized version of the suspensioncalculus. The new notation has several pleasing theoretical and practical properties

some of which have been manifest here. This version also differs from the originalpresentation in that it preserves contextual information. This characteristic has
been central to our ability to describe translations to the *oe-calculus and has alsobeen exploited elsewhere in defining a system for type assignment [Gacek 2006b].
This paper has also surveyed the world of explicit substitution calculi. It hasattempted to do this in a top-down fashion, first elucidating properties that are
important for such calculi to possess and then using these to categorize and toexplain the motivations for the different proposed systems. In the process we have
also distilled a better understanding of the capabilities of the suspension calculus.This work can be extended in several ways. We mention two that we think are
especially important. First, like the *oe-calculus, the notation we have describedhere provides the basis for incorporating new treatments of higher-order unification
that exploit graftable meta variables into practical systems. It is of interest toactually explicate such a treatment and to evaluate its benefits empirically. Second,
the question of preservation of strong normalizability is still an open one for thiscalculus. This issue appears to be a non-trivial one to settle and an answer to it is
likely to provide significant insights into the structure of the suspension calculus.
ACKNOWLEDGMENTS
This work began while the second author was on a sabbatical visit to the Protheogroup at LORIA and INRIA, Nancy and the Comete and Parsifal groups at 'Ecole

Polytechnique and INRIA, Saclay. Support for this work has been provided by theNSF through the grant numbered CCR-0429572; however, any opinions, findings,
and conclusions or recommendations expressed in this paper are those of the authorsand do not necessarily reflect the views of the National Science Foundation. Gacek

The Suspension Calculus and Other Explicit Substitution Calculi * 37
has also been supported by a grant from Boston Scientific during the concludingstages of this research.

REFERENCES

Abadi, M., Cardelli, L., Curien, P.-L., and L'evy, J.-J. 1991. Explicit substitutions. Journal

of Functional Programming 1, 4, 375-416.

Baelde, D., Gacek, A., Miller, D., Nadathur, G., and Tiu, A. 2007. The Bedwyr system for

model checking over syntactic expressions. Available from the Computing Research Repository
at http://arxiv.org/abs/cs.LO/0702116.

Benaissa, Z., Briaud, D., Lescanne, P., and Rouyer-Degli, J. 1996. *AE, a calculus of explicit

substitutions which preserves strong normalization. Journal of Functional Programming 6, 5,
699-722.

Bruijn, N. 1972. Lambda calculus notation with nameless dummies, a tool for automatic formula

manipulation, with application to the Church-Rosser Theorem. Indag. Math. 34, 5, 381-392.

Cosmo, R. D., Kesner, D., and Polonovski, E. 2003. Proof nets and explicit substitutions.

Mathematical Structures in Computer Science 13, 3, 409-450.

Curien, P.-L., Hardin, T., and L'evy, J.-J. 1996. Confluence properties of weak and strong

calculi of explicit substitutions. Journal of the ACM 43, 2, 362-397.

David, R. and Guillaume, B. 2001. A *-calculus with explicit weakening and explicit substitution. Mathematical Structures for Computer Science 11, 1, 169-206.

Dershowitz, N. 1982. Orderings for term-rewriting systems. Theoretical Computer Science 17, 3,

279-301.

Dowek, G., Hardin, T., and Kirchner, C. 2000. Higher-order unification via explicit substitutions. Information and Computation 157, 183-235.

Ferreira, M. and Zantema, H. 1995. Well-foundedness of term orderings. In Fourth International Workshop on Conditional Term Rewriting Systems, N. Dershowitz, Ed. Lecture Notes
in Computer Science, vol. 968. Springer, 106-123.

Field, J. 1990. On laziness and optimality in lambda interpreters: Tools for specification and

analysis. In Seventeenth Annual ACM Symposium on Principles of Programming Languages.
ACM Press, 1-15.

Gacek, A. 2006a. A Coq proof of the termination of the reading and merging rules in the suspension calculus. http://www-users.cs.umn.edu/~agacek/pubs/gacek-masters/Termination/.

Gacek, A. 2006b. The suspension calculus and its relationship to other explicit treatments of

subsubstitution in lambda calculi. M.S. thesis, University of Minnesota.

Guillaume, B. 2000. The *se-calculus does not preserve strong normalisation. Journal of Functional Programming 10, 4, 321-325.

Huet, G. 1975. A unification algorithm for typed *-calculus. Theoretical Computer Science 1,

27-57.

Huet, G. 1980. Confluent reductions: Abstract properties and applications to term rewriting

systems. Journal of the ACM 27, 4, 797-821.

Kamareddine, F. and Rios, A. 1995. A lambda-calculus `a la de bruijn with explicit substitutions. In Seventh International Conference on Programming Languages: Implementations,
Logics and Programs (PLILP). Lecture Notes in Computer Science, vol. 982. Springer, 45-62.

Kamareddine, F. and R'ios, A. 1997. Extending the *-calculus with explicit substitution which

preserves strong normalization into a confluent calculus on open terms. Journal of Functional
Programming 7, 4, 395-420.

Liang, C., Nadathur, G., and Qi, X. 2004. Choices in representation and reduction strategies

for lambda terms in intensional contexts. J. Autom. Reasoning 33, 2, 89-132.

Mellies, P.-A. 1995. Typed *-calculi with explicit substitutions may not terminate. In Second

International Conference on Typed Lambda Calculi and Applications, M. Dezani-Ciancaglini
and G. Plotkin, Eds. Lecture Notes in Computer Science, vol. 902. Springer, 328-334.

38 * A. Gacek and G. Nadathur

Miller, D. 2000. Abstract syntax for variable binders: An overview. In Proceedings of the First

International Conference on Computational Logic, J. Lloyd, Ed. Lecture Notes in Artificial
Intelligence, vol. 1861. Springer, 239-253.
Mu~noz, C. 1996. Confluence and preservation of strong normalization in an explicit substitution

calculus. In Eleventh Annual IEEE Symposium on Logic in Computer Science. IEEE Computer
Society Press, 440-447.
Nadathur, G. 1999. A fine-grained notation for lambda terms and its use in intensional operations. Journal of Functional and Logic Programming 1999, 2 (March).
Nadathur, G. and Mitchell, D. J. 1999. System description: Teyjus--a compiler and abstract

machine based implementation of *Prolog. In Automated Deduction-CADE-16, H. Ganzinger,
Ed. Lecture Notes in Artificial Intelligence, vol. 1632. Springer, 287-291.
Nadathur, G. and Wilson, D. 1998. A notation for lambda terms: A generalization of environments. Theoretical Computer Science 198, 1-2, 49-98.
Pfenning, F. and Elliott, C. 1988. Higher-order abstract syntax. In Proceedings of the ACMSIGPLAN Conference on Programming Language Design and Implementation. ACM Press,
199-208.
Shao, Z., League, C., and Monnier, S. 1998. Implementing typed intermediate languages. In

Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98).
ACM Press, 313-323.