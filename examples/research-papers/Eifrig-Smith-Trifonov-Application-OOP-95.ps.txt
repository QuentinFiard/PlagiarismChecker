

Electronic Notes in Theoretical Computer Science 1 (1995)
URL: http://www.elsevier.nl/locate/entcs/volume1.html 22 pages

Type Inference for Recursively Constrained

Types and its Application to OOP

Jonathan Eifrig 1

;2 Scott Smith 1 Valery Trifonov 1;2

Department of Computer Science

The Johns Hopkins University

Baltimore, Maryland 21218
feifrig, scott, trifonovg@cs.jhu.edu

Abstract
We define a powerful type inference mechanism with application to object-oriented
programming. The types inferred are recursively constrained types, types that come
with a system of constraints. These types may be viewed as generalizations of recursive types and F-bounded polymorphic types, the forms of type that are necessary
to properly encode object typings. The base language we study, I-Soop, incorporates state and records, the two features critical to encode objects in a non-objectoriented language. Soundness and completeness of the type inference algorithm are
established by operational means. Our method for establishing these properties is
somewhat novel. We illustrate how the algorithm may be fruitfully applied to infer
types of object-oriented programs.

1 Introduction
This paper addresses the problem of designing an object-oriented programming language with an effective type inference mechanism. Recently developed programming languages including Standard ML and Haskell incorporate
type inference as a core component of the language. However, type inference has yet to achieve practical application to object-oriented programming
languages.

We strongly feel the core type features necessary to model object-oriented
programming with type inference include a notion of subtyping [8], and a notion of "recursively constrained polymorphism," a generalization of F-bounded
polymorphism [9,6].

Recursively constrained types ^ are types of the form o/ n C, with " n "
reading "where." C is a set of type constraints of the form o/1 ^ o/2, possibly
containing free type variables. These constraints may be recursive in that a

1 Partially supported by NSF grants CCR-9109070 and CCR-9301340
2 Partially supported by AFOSR grant F49620-93-1-0169

cfl1995 Elsevier Science B. V.

Eifrig, Smith and Trifonov
variable t could occur free in both o/1 and o/2. The recursive constraint set
ft ! Nat ^ t, t ^ t ! Natg expresses t = t ! Nat, so recursively constrained
types subsume recursive types. We will use rc type to abbreviate recursively
constrained type.

Polymorphic rc types are types 8t1; : : : ; tn: o/ n C where constraints o/1 ^ o/2
in C may contain type variables t1; : : : tn free. Polymorphic rc types generalize
the more well-known bounded types [8] 8t ^ o/: o/ 0 in several ways. First,
they are recursive, so t could occur free in o/ ; this is not allowed in bounded
types. Types with t occurring free in o/ are the so-called F-bounded types
[6]. Polymorphic rc types generalize F-bounded types by allowing more than
one upper bound on a type variable, as well as allowing multiple lower-bound
constraints o/ ^ t. This generalized form of polymorphic type is very useful
in typing object-oriented programs that are otherwise untypable, irrespective
of the question of type inference. An example of such a program is given in
Section 5 below.

It is not difficult to see how rc polymorphism is useful in typing classes
and objects, for it is at least as useful as F-bounded polymorphism. Classes
may have so-called binary methods that refer to the type of objects of their
own class; for instance an object with an equal method takes as parameter
another object of its own type. Thus, a self-type is needed. And, this selftype needs to be open-ended since a class may be extended; we wish the type
of self to be "an object with all the methods currently defined, and possibly
additional ones". Polymorphic rc types capture this notion by constraining
the polymorphic "self-type" t to include the current methods, for instance

8t: o/ n ft ^ : : : equal : t ! Bool; : : :g
Binary methods have proven very difficult to type in a general way; it has
even been suggested that they be disallowed.

One way to understand the usefulness of lower bounds o/ ^ t in rc types
are as generalizations of recursive types. It is possible to write an rc type
^ = t n fo/1 ^ t ^ o/2g where lower bound o/1 differs from upper bound o/2
(it is a recursive type if o/1 = o/2). These generalized forms are useful as
intermediate results produced during the type inference process as "partial"
forms of recursive types. During the type inference process, constraints are
accumulated on types in a "bottom-up" fashion, and so types at the leaves
of typing proofs have small constraint sets, and have fat constraint sets at
the root. The lower bound o/1 constrains the "output" of the type ^ (what
properties objects of type ^ must have); if an object of type ^ is used (i.e.,
passed to a function of type o/ 0 ! : : :), an additional upper-bound constraint
t ^ o/ 0 will be placed on the type by the type inference mechanism, and
this could only be contradictory if o/1 ^ o/

0, which follows by transitivity, was

contradictory. The upper bound is the dual of this, constraining the "input"
of the type (what functions of type t ! : : : must do).

The presence of multiple upper-bound constraints or multiple lower-bound
constraints can be understood as a restricted form of union and intersection
type: fo/ ^ t, o/

0 ^ tg would be equivalent to fo/ . o/ 0 ^ tg if there were union

2

Eifrig, Smith and Trifonov
types o/ . o/

0 in the language; a dual relationship exists between intersections

and upper bounds. We believe general union and intersection types cause too
many problems to be worthwhile, but this implicit restricted form is quite
natural.

In this paper we develop a type inference algorithm for the I-Soop language (Inference Semantics of OOP). I-Soop is not an object-oriented language; however, it has an expressive enough type system so that typed OOP
may be effectively encoded within I-Soop. We take a translational approach
because we find the factoring to help clarify ambiguities; however, there is also
merit in studying languages where objects themselves are primitive [1], and
the concepts herein should eventually be recast as primitive object typings.
I-Soop's type system contains both subtyping and polymorphic rc types. We
infer shallow polymorphic rc types at let-expressions as in the Hindley/Milner
algorithm [17]. In addition the underlying language includes records and a
notion of state, for with these features it is possible to obtain an effective
encoding of object-oriented programming. Records are needed so record subtyping can be used to model object subtyping [8]. Without state, the critical
state-holding property of objects is lost [11].

Our approach to establishing the soundness of constrained type inference
differs from other work in the literature. In other approaches (e.g. [3,13],
[25,20]), a method is given that either produces a satisfying assignment to the
constraints and thus establishes their consistency, or establishes that no such
solution exists and the constraints are thus inconsistent. In our approach, an
rc type's constraint system is considered "consistent" if it does not contain
any "obvious" contradictions such as Nat ^ Bool. We show this view is sound,
without ever showing the "consistent" constraint systems have solutions. Instead we directly establish a subject-reduction property over a proof of typing
with "consistent" rc types at each node [26,27]. We believe the standard
method of finding solutions to the constraint sets can be overly restrictive,
for it forces one to have a rich enough type language or type model that can
express the solutions as types or sets. In our language, for instance, we expect
general union and intersection types would be required to express the solution
of constraints as types, but we do not wish to pay the penalty of having these
types in our language.

We also take a more primitive approach to establishing the completeness of
type inference, i.e. that all typable programs will successfully have some type
inferred by the type inference algorithm. We first define a restricted set of
typing rules, the inference rules, for which typing derivations are deterministic.
Then these rules are shown equivalent in strength to the general form of rules,
without recourse to a "principal types" property.

1.1 Related Work
A number of type inference systems have been developed that bear on the type
inference problem for OOP. Papers of Reynolds [24], Cardelli [7], and Mitchell
[18] are foundational papers in the field that develop the basic concepts of

3

Eifrig, Smith and Trifonov
constraints and subtyping. Many papers have been written since; we focus on
the more recent work the most relevant to ours.

Kaes [13] develops a type inference algorithm for a language containing
polymorphic and recursive types and type constraints. This work incorporates
subtyping constraints, recursive types, and polymorphism. Kaes writes socalled constrained types o/ jC in close analogy to our rc types o/ n C. This
approach cannot solve general recursive constraints: t ^ o/ generates a nonterminating unification problem in his system if t occurs free in o/ , while our
approach can handle such constraints without difficulty. He does allow a
"fixing" of such a constraint by replacing it with a recursive type _t:o/ , but at
the cost of an important loss of generality. Kaes takes the standard approach
to constraint consistency, by producing a solution to the constraints. He also
intends ^ to model overloading, not record subtyping (his system has no record
types). Sekiguchi and Yonezawa [25] take an approach similar to Kaes but
interpret ^ as subtyping on record types, making it more directly applicable
to object-oriented programming.

Palsberg, Schwartzbach, et. al. have written a number of papers concerning
type inference for objects [20,19,21,15]. The main feature of their work is they
do not take the Hindley/Milner approach to type inference. Instead, their
inference algorithm uses flow analysis to generate a set of constraints about a
program, and then applies another algorithm to come up with a solution to
these constraints if it exists. Their work represents the current state-of-the-art
in having a practical type inference algorithm for object-oriented programming
languages. Other advantages of their approach include asymptotically efficient
inference algorithms, and named class types. Their system however has no
polymorphism, and they take a code-expansion view of inheritance, requiring
re-type-checking with each class extension. This lack of polymorphism has
been partially addressed by Plevyak and Chien [22].

Our work is closest to that of Aiken and Wimmers [3]. They develop a type
system with subtyping, union and intersection types, and a form of polymorphic type similar to polymorphic rc types. They prove soundness using the
ideal model [16]. As with the previously mentioned researchers, they have an
algorithm that produces a satisfying assignment to the top-level constraints to
establish consistency of a constraint set. The satisfying assignment they produce is an ideal in the ideal model. We have no union, intersection, or negation
types. These types prove problematic in their system, and they are in fact
unnecessary for type inference -- if they are not used in the types of atomic
constructs, they are not generated by the inference algorithm (provided multiple upper and lower bounds to the same variable are allowed, as we do). Aiken
and Wimmers have not addressed the problem of using their system for typing
object-oriented programs; their language lacks important features necessary
for the encoding of objects. In particular their language is a functional language without records. The ideal model cannot model languages with state,
so their approach would not extend to a language with state. Aiken has implemented the type inference algorithm [2], and this implemented system has an
optimized inference algorithm and an implementation of extensible records.

4

Eifrig, Smith and Trifonov
Var 3 x
Num 3 n ::= 0 j 1 j 2 j : : :
Val 3 v ::= x j n j *x. e j - l = v "" j [ l)v ] j l # v
Exp 3 e ::= v j e e j let x = e in e j - l = e "" j e.l j [ l)e ] j l # e

Fig. 1. Syntax of the I-Soop language.
Encoding object-oriented features within a more basic language is one possible approach to how object-oriented programming should be done [23]. We
could take a similar approach by programming in an object-oriented style via
the encoding of objects in I-Soop that we give in Section 5. R'emy gives a
collection of extensions to ML that allow OOP to be encoded. R'emy is the
only author amongst of those previously discussed who has a proof of soundness of his system in the presence of reference cells. His encoding is missing a
notion of subtyping and thus lacks the core feature of object lifting: allowing
subclass objects to be implicitly coerced to be superclass objects. Instead, coercion functions must be explicitly supplied. R'emy's encoding is more efficient
than the encoding we use; each object creation in our encoding entails forming
closures for each method of the object. If our language were to be used as
a primitive OOP language, some more efficient object representations would
need to be developed. R'emy's system also has a notion of extensible record,
which we expect will be useful for encoding delegation-style object-oriented
programming.

1.2 Outline
In Section 2 we present I-Soop and its operational semantics. Section 3
presents the I-Soop type system; sketches of the proofs of subject reduction
and type inference appear in Section 4. Then, to show how OOP can be faithfully encoded, an extended example is worked in Section 5. This example also
serves to illustrate the power of the type inference system. We draw some
final conclusions in Section 6.

2 The I-Soop Language
We begin by defining the I-Soop language, which is roughly call-by-value PCF
with records, variants, reference cells, and let-expressions (see Figure 1).

The "vector notation" l = v is shorthand for l1 = v1; : : : ; lk = vk for some
k; li = vi is shorthand for the same and indicates that i will range over the
elements of the vector. The set B = fsucc; pred; is zero; ref; !; setg ae Var
contains the names of built-in primitive functions on numbers and reference
cells. Variants are dual to records: the injection l # e tags the value of e with
label l, and the match [ l)e ] (similar to the Standard ML fn construct) can
be applied to a tagged value to extract it. The booleans and conditional are

5

Eifrig, Smith and Trifonov
derived from variants: true and false are defined as true # - "" and false # - "",
respectively, and if e then e1 else e2 stands for [ true)*.. e1, false)*.. e2 ] e;
we use *.. e to denote *x. e for some x not free in e.

A store (ranged over by s) is a finite mapping from variables to values.
A configuration hs; ei is a pair of a store and an expression. Computation
is defined via a single-step relation 7!1 between configurations. A reduction
context R is an expression with a "hole" ffi in it, into which one may put a
subexpression via R[e]. Reduction contexts serve to isolate the next step of
computation to be performed--it is always in the hole.

Definition 2.1 A reduction context is defined inductively in Figure 2.

R ::= ffi j R e j v R j let x = R in e

j - l1 = v1, : : : , li\Gamma 1 = vi\Gamma 1, li = R, li+1 = ei+1, : : : , lk = ek "" j R.l
j [ l1)v1, : : : , li\Gamma 1)vi\Gamma 1, li)R, li+1)ei+1, : : : , lk)ek ] j l # R

Fig. 2. I-Soop reduction contexts.

Definition 2.2 7!1 is the least relation on configurations satisfying the conditions shown in Figure 3, where

e[e

0=x] is the capture-free substitution of e0 for x in e,

[ x 7! v ] is the map defined only on x with result v,
f jjg is the functional extension of f by g.

hs; R[(*x. e) v]i 7!1 hs; R[e[v=x]]i
hs; R[let x = v in e]i 7!1 hs; R[e[v=x]]i

hs; R[succ n]i 7!1 hs; R[n0]i (if n0 = n + 1)
hs; R[pred n]i 7!1 hs; R[n0]i (if n0 = n : 1)
hs; R[is zero 0]i 7!1 hs; R[true]i
hs; R[is zero n]i 7!1 hs; R[false]i (if n 6= 0)
hs; R[- : : : , l = v, : : : "".l]i 7!1 hs; R[v]i
hs; R[[ : : : , l)v, : : : ] (l # v0)]i 7!1 hs; R[v v0]i

hs; R[ref v]i 7!1 hsjj[ x 7! v ]; R[a]i (x =2 Dom(s) [ B)

hs; R[!x]i 7!1 hs; R[s(x)]i (x 2 Dom(s))
hs; R[set - cell = x, val = v ""]i 7!1 hsjj[ x 7! v ]; R[v]i (x 2 Dom(s))

Fig. 3. The single-step computation relation.

6

Eifrig, Smith and Trifonov
Here is a sample execution.

h;; (*x. succ (!(x.field))) - field = ref 5 ""i

7!1 h[ y 7! 5 ]; (*x. succ (!(x.field))) - field = y ""i
7!1 h[ y 7! 5 ]; succ (!(- field = y "".field))i
7!1 h[ y 7! 5 ]; succ (!y)i
7!1 h[ y 7! 5 ]; succ 5i
7!1 h[ y 7! 5 ]; 6i
Lemma 2.3

(i) 7!1 is deterministic: if hs; ei 7!1 hs0; e0i and hs; ei 7!1 hs00; e00i, then there

is a uniform renaming of variables in s0 and e0 to those in s00 and e00
respectively.

(ii) 7!1 is compositional: if hs; ei 7!1 hs0; e0i, then hs; R[e]i 7!1 hs0; R[e0]i for

every reduction context R. 2

3 I-Soop Types
The monomorphic types of the language are

TyVar 3 ff ::= t j u
Typ 3 o/ ::= ff j Nat j o/ !o/

0 j - l : o/ "" j [ l : o/ ] j o/ ref

where t ranges over the applicative type variables AppTyVar

def= ft

1; t2; : : : g,

and u ranges over the imperative ones: ImpTyVar

def= fu

1; u2; : : : g. This

division of variables into two classes is similar to that of Standard ML. The

set of free type variables in a type o/ is FTV (o/ ); o/ is imperative if FTV (o/ ) `
ImpTyVar.

A type constraint is a subtyping assertion between two (monomorphic)
types, written o/1 ^ o/2. We will require all sets of constraints used in types
and rules to be implicitly closed under obvious laws.

Definition 3.1 (Constraint System) A set of type constraints C is closed
iff

(i) If o/1 ^ o/2 2 C and o/2 ^ o/3 2 C, then o/1 ^ o/3 2 C.
(ii) If o/1!o/ 01 ^ o/2!o/ 02 2 C, then fo/2 ^ o/1; o/ 01 ^ o/ 02g ` C.
(iii) If - li : o/i "" ^ - lj : o/ 0j "" 2 C and flig ' fljg, then fo/j ^ o/ 0j g ` C.

(iv) If [ li : o/i ] ^ [ lj : o/ 0j ] 2 C and flig ` fljg, then fo/i ^ o/ 0i g ` C.

(v) If o/1 ref ^ o/2 ref 2 C, then fo/1 ^ o/2; o/2 ^ o/1g ` C.
A closed set of constraints is a constraint system.

We let C range over (implicitly closed) constraint systems, and thus will
be careful to make sure any new set of constraints we form is closed. The

7

Eifrig, Smith and Trifonov
closed union of sets of constraints is denoted by C1]C2, an operation that by
inspection can be seen to be associative.

Definition 3.2 (Constraint Consistency) A constraint o/1 ^ o/2 is consistent if

(i) o/1 2 TyVar or o/2 2 TyVar;
(ii) o/1 = o/2 = Nat, or o/1 = o/ 01 ref and o/2 = o/ 02 ref, or o/1 = o/ 01!o/ 001 and

o/2 = o/ 02!o/ 002 (for some o/ 01; o/ 02; o/ 001 ; o/ 002 );

(iii) o/1 = - l : o/ "", o/2 = - l

0 : o/ 0 "", and flg ' fl0g; or

(iv) o/1 = [ l : o/ ], o/2 = [ l0 : o/ 0 ], and flg ` fl0g.
Otherwise a constraint is inconsistent.

For example, Nat ^ t!Nat and t ref ^ - m : Nat "" are inconsistent constraints, while t ^ t!Nat, t ^ u, and u ^ Nat are each consistent. A constraint system is consistent if all the constraints in the system are consistent.
The rules will require all constraint systems to implicitly be consistent.

The type system assigns I-Soop expressions rc types of the form

^ ::= o/ n C
to indicate an expression of type o/ which is constrained by the constraints in
C. Since the rules implicitly require C to be consistent, it makes sense to view
^ as a type and to write C on the right side of the turnstile as part of the
type.

We define the following notion of subtyping on rc types.

Definition 3.3 (Subtyping rc Types) o/ n C ^ o/ 0 n C0 provided that C0 is
consistent and C ]fo/ ^ o/ 0g ` C0.

Stronger notions of subtyping could be defined, but for our purposes this
definition suffices. The type schemes oe are as follows.

oe ::= o/ j 8ff: ^
Note that since ^ = o/ n C can contain an arbitrary collection of constraints C,
shallow F-bounded polymorphic types are a special case of these polymorphic
rc types.

3.1 I-Soop Typing Rules
Before giving the rules we describe notation used in the rules. Notation used in
sequent judgements includes the following. A type environment A is a mapping
from variables to type schemes; we use the more intuitive notation [ x : oe ] instead of [ x 7! oe ]. Given a type environment A, the proof system assigns to an
expression e a rc type o/ n C, written as the type judgement A ` e : o/ n C, under the condition that C is consistent (as mentioned previously, all constraint
sets C appearing in the rules implicitly must be consistent); we occasionally

8

Eifrig, Smith and Trifonov
(Sub) A ` e : ^; ^ ^ ^

0

A ` e : ^0

(Num)

A ` n : Nat n ;

(Abs)Ajj[ x : o/ ] ` e : o/

0 n C

A ` *x. e : o/ !o/ 0 n C

(App) A ` e

1 : o/ !o/

0 n C1; e2 : o/ n C2

A ` e1 e2 : o/ 0 n C1]C2

(Var) A(x) = o/

A ` x : o/ n ;

(PVar) A(x) = 8ff: ^; \Psi  is a substitution on fffg

A ` x : \Psi ^

(Sel) A ` e : - l : o/ "" n C

A ` e.l : o/ n C

(Record) A ` e

i : o/i n Ci

A ` - li = ei "" : - li : o/i "" n Ui Ci

(Inj) A ` e : o/ n C

A ` l # e : [ l : o/ ] n C

(Match) A ` e

i : o/i!o/ n Ci

A ` [ li)ei ] : [ li : o/i ]!o/ n Ui Ci

(Let) A ` e : o/ n C; Ajj[ x : 8ff: o/ n C ] ` e

0 : o/ 0 n C0

A ` let x = e in e0 : o/ 0 n C ]C0

where fffg `

8?!

?:

if e is expansive then AppClos(o/ n C; A)

else Clos(o/ n C; A)

Fig. 4. Typing rules of I-Soop.
may write A ` e1 : o/1 n C1; e2 : o/2 n C2; : : : to indicate several type judgements provable in the same environment. Programs are type-checked in the
initial environment A0 assigning the following type schemes to the built-ins:

A0 = [ succ : Nat!Nat; pred : Nat!Nat; is zero : Nat!Bool;

ref : 8u: u!u ref; ! : 8t: t ref!t; set : 8t: - cell : t ref, val : t ""!t ]

where Bool stands for the type [ true :- "", false :- "" ]. A substitution on fffg is
a map \Psi  2 TyVar ! Typ which is the identity on TyVar n fffg and maps
ImpTyVar to imperative types; a renaming \Phi  of fffg is a substitution on fffg
with codom(\Phi ) ` TyVar. An expression is expansive if and only if it is not a
value; following Tofte [26] we form type schemes by making the sets of type
variables we generalize over dependent on the expansiveness of the expression.
The definitions of these sets are

Clos(o/ n C; A) = (FTV (o/ ) [ FTV (C)) n FTV (A)
AppClos(o/ n C; A) = Clos(o/ n C; A) " AppTyVar

where the functionality of FTV is extended as usual to constraint systems, rc
types, type schemes, and type environments.

The typing rules for I-Soop are given in Figure 4. Most of the rules have
obvious relation to those of standard systems with subtyping and records; as

9

Eifrig, Smith and Trifonov
in Tofte's system [26], the typing of ref introduces imperative types. The main
difference is the addition of constraints as part of types, the associated subsumption rule on these types, and the way consistent constraints accumulate
from the leaves to the root of a typing proof. It is important to observe that
consistency of constraints is implicitly enforced by each rule. Other presentations of constrained type systems [18,3,13] do not require local consistency, so
the constraints in the rules have both a hypothetical and assertional component. They are hypothetical in that they may be inconsistent, and they are
assertional in that they assert properties of the type if they are consistent.
For this reason they write C on the left of the turnstile, and perform some
top-level consistency check before a proved typing is "true." Since constraints
are never inconsistent in our rules we have no hypothetical component and
constraints are thus written on the right-hand side of the turnstile.

Some justification is required for the (Let) rule, in which the constraint
system of the let expression contains not only the constraints in C 0, necessary
for typing its body, but also those in C, accumulated for the type of the
bound variable. Leaving the latter constraints out (as [3] do, but corrected
in [2]) results in a system unsound with respect to the standard call-by-value
semantics of the let expression; C may contain constraints on type variables
free in the environment, and their omission may lead to accepting programs
which get stuck while evaluating the expression assigned to the bound variable.
As an example, consider the expression

(*x. let y = !x in succ x) 5
By rules (PVar), (Var), (Sub), and (App) the constraint system C of the rc type
of !x contains o/ ^ o/ 0 ref for some type o/ 0, where o/ is the type associated with
x by the rule (Abs). This constraint will lead to inconsistency when combined
with the constraint Nat ^ o/ at the outermost rule of the typing proof, (App).
If it were omitted from the constraint system of the let, the other constraint
on o/ , namely o/ ^ Nat from the body succ x, would not cause an inconsistency,
and the program would type-check; however its execution obviously leads to
the stuck state h;; let y = !5 in succ 5i.

While the type language does not have recursive types, *x. x x can be given
the rc type t1!t2 n ft1 ^ t1!t2g. We do not have a "bottom" type, but its
positive occurrences may be simulated by an unconstrained type variable, e.g.
(*x. x x) *x. x x has the rc type

t2 n ft1!t2 ^ t1; t1 ^ t1!t2g
An unconstrained variable can also be used instead of a "top" type in negative
positions. Positive occurrences of "top" may be simulated by overconstraining
from below:

A0 ` if true then 5 else - "" : t n fNat ^ t; - "" ^ tg
This constraint system is consistent. Note that not all typable programs are
of this particular "top" type, but they are provably of type t n fNat ^ t; - "" ^

10

Eifrig, Smith and Trifonov
tg]C for some C and fresh t by a single use of (Sub). Similarly overconstraining
from above achieves the effect of "bottom" in negative positions.

4 Subject Reduction, Soundness, and Type Inference
We prove soundness of the type system by demonstrating a subject reduction
property. First we strengthen the (Let) rule of the system to:

(Let) A ` e : o/ n C; Ajj[ x : 8ff: o/ n C ] ` e

0 : o/ 0 n C0; \Phi  is a renaming of fffg

A ` let x = e in e0 : o/ 0 n \Phi C ]C0

where fffg `

8?!

?:

if e is expansive then AppClos(o/ n C; A)

else Clos(o/ n C; A)

Obviously, any use of the original (Let) rule can be trivially transformed
into a use of the stronger rule, by choosing \Phi  to be the identity renaming.
This renaming does not add any power to the typing system; any program
that is typable with the stronger (Let) rule is also typable with the original; it
is introduced only to avoid certain technical complications which arise during
reductions within a let expression.

Next, we extend the notion of typing to configurations:

Definition 4.1 A ` hs; ei : o/ n C if and only if

1. A ` e : o/ n C;
2. Dom(A) = Dom(A0) [ Dom(s), Dom(A0) " Dom(s) = ;, and A agrees

with A0 on Dom(A0);

3. for each x 2 Dom(s) we have A(x) = o/x ref and A ` s(x) : o/x n Cx for

some o/x and Cx ` C.

Theorem 4.2 (Subject Reduction) If A ` hs; ei : ^, then either e 2 Val
or else hs; ei 7!1 hs

0; e0i and there exists an environment A0 such that A0 `

hs0; e0i : ^. 2

We present only a sketch of the proof in this abbreviated version. The
proof proceeds in the standard fashion: given a configuration and a proof of
its typability, perform one step of computation and transform the original
typing proof into a proof for the new configuration. The interaction between
let-polymorphism and reference cells is known to cause significant difficulty
[26]; our approach to this problem derives from [27], avoiding Tofte's complex
greatest fixed-point construction.

The differences between our proof and that of [27] result from the constraint systems of rc types and polymorphic rc types. Each step of computation is accompanied by a proof transformation that pushes constraints present
near the top of the proof tree towards the leaves. The complications of the
proof arise when these constraints are pushed through uses of the (Let) rule;

11

Eifrig, Smith and Trifonov
demonstrating that the type generalizations performed in the initial application of the rule remain valid is non-trivial.

This pushing of constraints from the root of the typing proof towards the
leaves during reduction can be considered a lazy approach to proof canonicalization. An alternative approach would be to regularize the initial typing
proof of a program to canonical form by pushing all of the constraints present
at the root to the leaves before performing any computation. This would result in a more straightforward subject reduction proof, at the expense of a
more complicated proof canonicalization lemma.

The soundness of the type system is a corollary of the Subject Reduction
theorem:

Theorem 4.3 (Soundness) If A0 ` e : ^, then either e diverges, or e computes to a value.

Proof. By induction on the length of computation, using Theorem 4.2. 2

Note we have thus proved soundness of the constrained type system without ever having shown the systems of constraints have a solution.

4.1 Type Inference
We now define the type inference algorithm and prove it is complete, i.e. if a
program has a type derivation the inference algorithm will infer a type for it.
The strategy we take to reach this desired outcome is the following.

1. Define a new set of rules (the inference rules) for which typing derivations

are deterministic.

2. Prove the inference rules are equivalent in strength to the general rules

we had been using previously.

The inference rules appear in Figure 5.

Theorem 4.4 For all terms e and environments A, it is decidable whether
there exists a ^ such that A `inf e : ^.

Proof (Sketch) By inspection of the rules, there is only one rule for typing
each expression construct. By further inspection, the only nondeterminism
that may be introduced in rule application is the choice of type variables used
in rules (Abs) and (PVar). We thus choose ff-normal proofs that use fresh
variables in every place possible. If a proof exists, there clearly must then
be a corresponding ff-normal proof. For expression e the ff-normal proof is
unique modulo ff-conversion. Thus a decision procedure may be defined for
constructing such a canonical proof. The algorithm fails when an inconsistent
constraint system is obtained when combining the constraint systems inferred
for subterms, and detection of such inconsistencies is trivially decidable. 2

We now relate the inference rules to the general rules.

12

Eifrig, Smith and Trifonov
(Abs) Ajj[ x : t ] `

inf e : o/ n C

A `inf *x. e : t!o/ n C

(Var) A(x) = o/

A `inf x : o/ n ;

(Sel) A `

inf e : o/ n C

A `inf e.l : t n C ]fo/ ^ - l : t ""g

(Inj) A `

inf e : o/ n C

A `inf l # e : [ l : o/ ] n C

(Record) A `

inf ei : o/i n Ci

A `inf - li = ei "" : - li : o/i "" n Ui Ci

(Num)

A `inf n : Nat n ;

(Match) A `

inf ei : o/i n Ci

A `inf [ li)ei ] : [ li : ti ]!t n Ui(Ci]fo/i ^ ti!tg)

(App) A `

inf e1 : o/1 n C1; e2 : o/2 n C2

A `inf e1 e2 : t n C1]C2]fo/1 ^ o/2!tg

(PVar) A(x) = 8ff: ^; \Phi  is a renaming of fffg

A `inf x : \Phi ^

(Let) A `

inf e : o/ n C; Ajj[ x : 8ff: o/ n C ] `inf e

0 : o/ 0 n C0

A `inf let x = e in e0 : o/ 0 n C ]C0

where fffg =

8?!

?:

if e is expansive then AppClos(o/ n C; A)

else Clos(o/ n C; A)

Fig. 5. Type inference rules of I-Soop.
Theorem 4.5 (Completeness of Type Inference) Given an environment
A and an expression e, the typing judgement A ` e : ^ is provable for some
^ if and only if A `inf e : ^0 is provable for some ^0.

Proof: (Sketch) If A `inf e : ^

0 is provable, A ` e : ^ is obviously provable

as well; each inference rule is a special case of a combination of (Sub) and a
general rule.

Conversely, typing proofs in the general set of rules may be transformed
into ones using only the inference ones in a two-step process. First, the proof is
transformed into pre-inference form, in which each rule used one of the inference rules, or possibly (Sub). In the process, certain types o/ used in the proof
(such as in the conclusion of rules (Var), (Sel), (App), and the like) are replaced
by fresh type variables t; the corresponding type constraints fo/ ^ t; t ^ o/ g
are added to the constraint system and bubbled to the top. Similarly, each
assumption x : o/ is replaced with an assumption of the form x : t, together with
the constraints fo/ ^ t; t ^ o/ g, for some fresh t. The result is a larger set of
constraints mentioning these new type variables. Demonstrating the consistency of these richer constraint systems as these new constraints propagate to
the root of the proof is non-trivial.

Second, the proof is reworked again, eliminating uses of rule (Sub) induc13

Eifrig, Smith and Trifonov
tively. This transformation takes a pre-inference proof of A ` e : o/ n C and
produces an inference proof of A ` e : o/ 0 n C0, where C0 ` C and either o/ = o/ 0
or fo/ 0 ^ o/ g ` C. This is possible because the antecedents of each inference
rule are simply of the form A ` e : o/ n C; the type o/ need not be in any special
form for the rule to be applicable. Essentially, this means that a use of (Sub)
followed by another rule can be exchanged, thus moving the subsumptions to
the root of the proof where they can be eliminated. 2

Thus from Theorems 4.5 and 4.4 we may conclude that every program
typable under the general rules has a type inferred by the type inference algorithm. Note we establish no principal typing property. The typing produced
by the inference algorithm is indeed "minimal" in an intuitive sense, but it is
not formally minimal since our definition of ^ ^ ^0 is weak: t!Nat n ft ^ Natg
is not a subtype of Nat!Nat n ;, even though any term that can be given the
former type can also be given the latter. We leave the question of principal
typings for future study, since completeness is ultimately all the programmer
desires.

5 Applications to OOP
We now illustrate how this type inference algorithm is useful for typing objectoriented programs, the main motivation for our work. We show its utility in
class-based OOP; we expect it also applies to delegation-style OOP but that
topic is beyond the scope of this paper. The basic OOP concepts we wish
to incorporate include standard notions of object, method, instance variable,
class, inheritance, method/instance hiding, and object lifting 3 . The more
advanced notions we wish to account for include polymorphism, multiple inheritance and binary methods. Without binary methods (in general, methods
that take objects as parameters or return objects as values), the object typing problem is not overly difficult: objects may be interpreted as records of
functions (methods) and cells (instance variables), inheritance is subtyping,
and object lifting is accomplished by a subsumption rule. As we show, typing
becomes considerably more difficult in the presence of binary methods [9].

The ideal way to show applicability to OOP would be to define a complete
OOP language, types, and inference algorithm; this is beyond the scope of
this paper, however. Instead, we will show how a collection of simple macros
allow OOP to be embedded into I-Soop.

The basic idea of the representation is to interpret classes as functions on
records *s:- : : : "" where s is the "self"; new then takes the fixed point of a class
to produce an object, in the form of a record (see [14]). We cannot quite use
this encoding. First, it is difficult to create fixed points which are records in a
call-by-value language. Second, when taking a fixed point via a Y -combinator,
the semantics entails re-evaluating the record with each recursive access, and
thus erroneously re-initialize any instance variables. In previous work [12] we
avoided these problems by using a memory-based fixed point. Unfortunately

3 Also called implicit object coercion or object subsumption.

14

Eifrig, Smith and Trifonov
this encoding will not work here as the use of reference cells to form the fixed
point will infer imperative polymorphic types for objects. We thus opt for
an encoding using a Y -combinator with an initial instance variable allocation
phase. In a more complete treatment of this topic a limited form of memorybased fixed point such as the single-assignment reference (SAR) of [10] could
be used. We ignore the issue of information hiding in this presentation, though
it is not difficult to incorporate.

Definition 5.1 The object syntax is defined by the macros given in Figure 6,
where Y

def= *y. (*x. x x) *x. *z. y (x x) z is a call-by-value Y -combinator, and

\Omega 

def= Y (*x. x).

Note that the class macro binds occurrences of s free in the e00k, and those
of ui free in e0j and e00k.

(class) class s super ui of ei inst xj = e0j meth mk = e00k

=
*.. let u0i = ei - "" in let ui = u0i (*x. \Omega ) in

let y = - xj = ref e0j "" in *s. let ui = u0i (s) in
*.. - inst = y, meth = - mk = e00k ""
(new) new = *x. Y(x - "")
(message send) e !- m = (e - "").meth.m
(instance read) e\Delta x = !((e - "").inst.x)
(instance write) e1\Delta x := e2 = set - cell = (e1 - "").inst.x, val = e2 ""

Fig. 6. Macros for object syntax.
We illustrate the typing problems involved with binary methods through
an example of a GcdNum class that has a binary method gcd that takes another
GcdNum and recursively computes the GCD of itself and the other GcdNum.
In order to keep the example very simple we assume the instance variable
containing the actual number, val, is publicly accessible, and that GcdNum
defines no other methods. ZGcdNum is a subclass of GcdNum with an additional unimportant method zero. Here mod is taken to be a function that
computes the modulus of two numbers.

let GcdNum = class s super

inst

val = 0
meth

gcd = *num. if is zero (s\Delta val) then s

else if is zero (mod (num\Delta val) (s\Delta val)) then s
else s\Delta val := mod (s\Delta val) (num\Delta val); num !- gcd s

15

Eifrig, Smith and Trifonov
The gcd method takes another GcdNum object, num, as argument. Because
num is of the same type as the type of objects of the class we are currently defining, expressing the type of the gcd method will require some selfreferentiality.

We first consider appropriate types for the inheritance-is-subtyping paradigm.
This is known to have serious limitations [9], but is nonetheless frequently
found in commercial OOP languages. In this paradigm we give GcdNum the
type

GcdNum : GcdType!GcdType; where
GcdType = _t: (- ""!- val : Nat ref, gcd : t!t "")
Note that _ is the usual recursive type constructor. We use it instead of the
I-Soop encoding of recursive types using recursive constraints. new GcdNum
then returns an object of type GcdType. Without inheritance this type is
perfectly adequate. We now look at the adequacy of this type with inheritance.
We extend our example by defining ZGcdNum, a subclass of GcdNum that also
includes a method that tests for zero.

let ZGcdNum = class s

super

u of GcdNum
inst

val = u\Delta val
meth

gcd = u !- gcd,
zero = *.. is zero (s\Delta val)

In this case we did not override the gcd method; instead, we inherited it from
GcdNum, denoted here by the superclass variable u (in this encoding we explicitly state the superclass of each inherited method). Using the inheritance-issubtyping paradigm, the inherited instance variables and methods must have
the same types as in the superclass since these types are fixed. Thus, the type
of ZGcdNum must be

ZGcdNum : ZGcdType!ZGcdType; where
ZGcdType =
_t: (- ""!- val : Nat ref, gcd : GcdType!GcdType, zero : - ""!Bool "")
Note the gcd method still operates on GcdType, not ZGcdType. Thus if gcd
were overridden in ZGcdNum with a function that used num's zero method,
this typing would fail, an undesirable fact. Another problem with this typing
is illustrated in the following additional code.

let zgnum = new ZGcdNum in (zgnum !- gcd zgnum) !- zero - ""
The gcd method type is not parametric in the type of the object given to it.
Thus it will accept an object of ZGcdType as an argument since by subtyping
ZGcdType ^ GcdType, but the result returned is only of GcdType, and thus is
not known to have a zero method. The above code will thus not type-check,

16

Eifrig, Smith and Trifonov
even though it executes without error.

An alternative typing is needed. Since we inherit from GcdNum, the ZGcdNum objects that eventually are created will have more methods than just gcd.
To capture this, we must take a parametric or open-ended view of the self-type
in GcdNum's type. The parametricity we desire in GcdNum is that t should
be any subclass with at least gcd and val, and furthermore that gcd parametrically maps t to t. To express the open-ended view as a type, F-bounded
quantification is used as follows.

GcdNum : 8t ^ GcdTypeF(t): t!GcdTypeF(t); where
GcdTypeF(t) = - ""!- val : Nat ref, gcd : t!t ""
ZGcdNum may then be typed as

ZGcdNum : 8t ^ ZGcdTypeF(t): t!ZGcdTypeF(t); where
ZGcdTypeF(t) = - ""!- val : Nat ref, gcd : t!t, zero : - ""!Bool "";
giving zgnum the type _t: ZGcdTypeF(t). Thus the above code type-checks. In
addition, it would have been possible to override gcd in ZGcdNum, impossible
in the simple recursive-types view.

The F-bounded typing has a drawback, however. ZGcdNum objects can
no longer be lifted to be GcdNum objects (since their types are recursive types
with t occurring negatively), and thus the following code will not type-check.

let gnum = new GcdNum in

let zgnum = new ZGcdNum in

gnum !- gcd zgnum

Note that the recursive typing would allow this code to type-check.

So, both the F-bounded interpretation of inheritance and the recursive
types interpretation fail to typecheck certain typable programs. Our type
inference algorithm, however, infers types that will allow both of the above
varieties of message send to be typed in a single program.

5.1 Types inferred in I-Soop
To simplify the presentation, we will ignore the instance variable val in the
example. We will also simplify the translation scheme to reflect this, by eliminating the first line from the macro expansion of class and replacing u0i by e,
and defining new as Y.

First consider the types inferred for the classes GcdNum and ZGcdNum.
The simplified translations are

let GcdNum =

*s. *.. - gcd = *num. if -- then s

else if -- then s
else (num - "").gcd s ""
in let ZGcdNum =

*s. let u = GcdNum (s) in

17

Eifrig, Smith and Trifonov
*.. - gcd = (u - "").gcd,

zero = *.. is zero -- ""

We first sketch how the inference system of rules, `inf, infers GcdNum's
type. These rules are deterministic modulo ff-variants so proof construction
is mechanical. Starting from the leaves and using rules (Record), (App), and
(Sel) in turn we obtain

A0jj[ s : t1; . : ta; num : tb ] `inf (num - "").gcd : td n C1;

where C1 = ftb ^ - ""!tc; tc ^ - gcd : td ""g
Next, using (App),

A0jj[ s : t1; . : ta; num : tb ] `inf (num - "").gcd s : te n C2;
where C2 = ftb ^ - ""!tc; tc ^ - gcd : td ""; td ^ t1!teg
Next, expanding the conditional and using (Abs) and (Match) twice,

A0jj[ s : t1; . : ta ] `inf *num. : : : : tb!t2 n C2]fte ^ t2; t1 ^ t2g
Finally, by (Record) and (Abs) twice,

A0 `inf GcdNum : t1!ta!- gcd : tb!t2 "" n C2]fte ^ t2; t1 ^ t2g
This is the type inferred by the inference rule system. An actual implemented type inference algorithm would automatically perform a number
of simplifications on this type that do not change the meaning. Here we
present these simplifications informally by giving typings deduced in the general rules that are simplified forms of the inferred types. For GcdNum, ta is
unconstrained so it may be replaced by - "" by subsumption. tb has only one
positive occurrence in the type, so it may be replaced with its upper bound.
tc; td and te may also each be replaced. The following type may then be
deduced for GcdNum in the general rules:

8t1; t2: t1!- ""!- gcd : (- ""!- gcd : t1!t2 "")!t2 "" "" n ft1 ^ t2g
Hereafter we present the simplified forms of types only. An actual implemented type inference algorithm would automatically perform these simplifications. For ZGcdNum, the (simplified) inferred type is

8t1; t2: t1!- ""!- gcd : (- ""!- gcd : t1!t2 "")!t2, zero : - ""!Bool "" n ft1 ^ t2g

Contrast these types with the F-bounded type given GcdNum in the "openself" encoding above. Observe that the parameter num is an object with
a gcd method. Since that is the only method of num that is used, no more
fields are required in the inferred type. Contrast that with the F-bounded
case where num has all methods of GcdNum: the open-endedness here is more
precise, each method that is passed the "self" requires that self to only have
the methods actually used. Note also that this is not even an F-bounded
type, the constraint t1 ^ t2 is not recursive. Recursive constraints may not
arise in classes, since the knot has not been tied yet.

18

Eifrig, Smith and Trifonov
Consider now the object types. gnum and zgnum have the following (simplified) types inferred:

gnum : 8t1; t2: t1 n f- ""!- gcd : (- ""!- gcd : t1!t2 "")!t2 "" ^ t1 ^ t2g;

zgnum : 8t1; t2: t1 n f- ""!- gcd : (- ""!- gcd : t1!t2 "")!t2,

zero : - ""!Bool "" ^ t1 ^ t2g

It is difficult to explain precisely what these types denote, except to say
they are definitely not the recursive types used in both encodings for objects
above.

The message sends from the example have the following constrained types.

zgnum !- gcd gnum : t2 n f

- ""!- gcd : (- ""!- gcd : t1a!t2 "")!t2, zero : - ""!Bool "" ^ t1a,
t1a ^ - ""!- gcd : t1b!t2 "", t1b ^ - ""!- gcd : t1a!t2 ""
- ""!- gcd : (- ""!- gcd : t1b!t2 "")!t2 "" ^ t1b, t1a ^ t2; t1b ^ t2g;
zgnum !- gcd zgnum : t02 n f

- ""!- gcd : (- ""!- gcd : t01a!t02 "")!t02, zero : - ""!Bool "" ^ t01a,
t01a ^ - ""!- gcd : t01b!t02 "", t01b ^ - ""!- gcd : t01a!t02 "";
- ""!- gcd : (- ""!- gcd : t01b!t02 "")!t02, zero : - ""!Bool "" ^ t01b,
t01a ^ t02; t01b ^ t02g

Note the function upper bounds of t1a, t1b, t01a and t01b can be proved to never
be used; a more complete set of simplification transformations would justify
their removal. Each use of gnum and zgnum gives rise to fresh variables by the
(PVar) rule; if these objects were not let-polymorphic, the two message sends
above would share type variables and generality would be lost. Observe there
are no contradictions in the constraint systems of either of these message sends.
Also note the result type t2 is in effect the union of t1a and t1b since it is an
upper bound of these two types. This corresponds to the fact that the result of
gcd could be either a gnum or a zgnum. Consider sending a zero message to the
result of the second message send, (zgnum !- gcd zgnum) !- zero - "". The rules
force t02 ^ - ""!- zero : - ""!Bool "" to be added to the constraints, but this is
still consistent. On the other hand, consider (zgnum !- gcd gnum) !- zero - "".
This may give a run-time error, so should not type-check. Indeed, t2 ^
- ""!- zero : - ""!Bool "" by transitive closure also requires a record without zero to be a subtype of a record with zero, but this is by definition an
inconsistent constraint.

Compared to other work on rigorously sound class-based object languages,
neither Bruce's TOOPLE or TOIL languages [4,5], nor our Loop language [12]
allows the above program to type-check; in fact we know of no static type19

Eifrig, Smith and Trifonov
system for object-oriented programming that successfully type-checks this example. So, not only do we obtain object type inference, we have a richer type
language where it is not required to choose between "inheritance is subtyping"
and the open-ended view of self.

6 Discussion
We have given a new, powerful method for type inference for object-oriented
languages that is in many ways more powerful than previously existing methods. We have hopes that the core we present here will lead to development of a
full-scale object-oriented programming language incorporating type inference.
What we present here only shows this method is feasible, however. Further
study is necessary to see if it can be implemented efficiently in practice. There
also is the question of how well other language features will combine with this
inference method. Modules in particular will be a challenge. There also should
be separate syntax and types added for OOP features such as class definition
and message send. This will provide a uniform notion of what OOP is to all
programmers, and limit incompatibility of code. Lastly, even though this system is significantly stronger than the existing Hindley/Milner-style inference
algorithms, the types it produces are larger and less easily readable by programmers. Thus it is important to address both the problem of simplification
of these types, and the problem of how a better descriptions of what led to a
type error can be given to programmers.

Acknowledgements
We would like to acknowledge Jens Palsberg for helpful discussions on related
work, and Amy Zwarico for contributions in the early phases of this project.

References

[1] M. Abadi and L. Cardelli. A semantics of object types. In Proceedings of the

Ninth Annual IEEE Symposium on Logic in Computer Science, pages 332-341,
1994.

[2] A. Aiken. Illyria system. Available by anonymous ftp from ftp://

s2k-ftp.cs.berkeley.edu/pub/personal/aiken/, 1994.

[3] A. Aiken and E. L. Wimmers. Type inclusion constraints and type inference.

In Proceedings of the International Conference on Functional Programming
Languages and Computer Architecture, pages 31-41, 1993.

[4] K. Bruce. Safe type checking in a statically-typed object-oriented programming

language. In Conference Record of the Twentieth Annual ACM Symposium on
Principles of Programming Languages, pages 285-298, 1993.

[5] Kim B. Bruce and Robert van Gent. TOIL: A new type-safe object-oriented

imperative language. Technical report, Williams College, 1993.

20

Eifrig, Smith and Trifonov
[6] P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. F-bounded

polymorphism for object-oriented programming. In Proceedings of the
Conference on Functional Programming Languages and Computer Architecture,
pages 273-280, 1989.

[7] L. Cardelli. A semantics of multiple inheritance. In Semantics of Data Types,

volume 173 of Lecture notes in Computer Science, pages 51-67. Springer-Verlag,
1984.

[8] L. Cardelli and P. Wegner. On understanding types, data abstraction and

polymorphism. Computing Surveys, 17(4):471-522, December 1985.

[9] William R. Cook, Walter L. Hill, and Peter S. Canning. Inheritance is not

subtyping. In Conference Record of the Seventeenth Annual ACM Symposium
on Principles of Programming Languages. ACM Press, 1990.

[10] J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. A simple interpretation of

OOP in a language with state. Technical Report YALEU/DCS/RR-968, Yale
University, 1993.

[11] J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. Application of OOP type

theory: State, decidability, integration. In OOPSLA '94, pages 16-30, 1994.

[12] J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. An interpretation of typed

OOP in a language with state. Lisp and Symbolic Computation, 1995. To
appear.

[13] S. Kaes. Type inference in the presence of overloading, subtyping and recursive

types. In ACM Conference on Lisp and Functional Programming, pages 193-
204, 1992.

[14] Samuel N. Kamin and Uday S. Reddy. Two semantic models of object-oriented

languages. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects
of Object-Oriented Programming, chapter 13, pages 464-495. MIT Press, 1994.

[15] D. Kozen, J. Palsberg, and M. I. Schwartzbach. Efficient inference of partial

types. In Foundations of Computer Science, 1992.

[16] D. B. MacQueen, G. Plotkin, and R. Sethi. An ideal model for recursive

polymorphic types. Information and Control, 71:95-130, 1986.

[17] R. Milner. A theory of type polymorphism in programming. Journal of

Computer and System Sciences, 17:348-375, 1978.

[18] J. Mitchell. Coercion and type inference (summary). In Conference Record

of the Eleventh Annual ACM Symposium on Principles of Programming
Languages, 1984.

[19] N. Oxho/j, J. Palsberg, and M. I. Schwartzbach. Type inference with subtypes.

In ECOOP'92 European Conference on Object-Oriented Programming, volume
615 of Lecture notes in Computer Science, pages 329-349. Springer-Verlag, 1992.

[20] J. Palsberg and M. Schwartzbach. Object-Oriented Type Systems. Wiley, 1994.
[21] Jens Palsberg and Michael I. Schwartzbach. Safety analysis versus type

inference for partial types. Information Processing Letters, pages 175-180, 1992.

21

Eifrig, Smith and Trifonov
[22] J. Plevyak and A. Chien. Precise concrete type inference for object-oriented

languages. In Proceedings of the Ninth Annual ACM Conference on ObjectOriented Programming Systems, Languages, and Applications, pages 324-340,
1994.

[23] Didier R'emy. Programming objects with ML-ART: An extension to ML with

abstract and record types. In Masami Hagiya and John C. Mitchell, editors,
International Symposium on Theoretical Aspects of Computer Software, pages
321-346, Sendai, Japan, April 1994. Springer-Verlag.

[24] J. C. Reynolds. Three approaches to type structure. In TAPSOFT proceedings,

volume 185 of Lecture notes in Computer Science, pages 97-138, 1985.

[25] T. Sekiguchi and A. Yonezawa. A complete type inference system for subtyped

recursive types. In Proc. Theoretical Aspects of Computer Software, volume 789
of Lecture Notes in Computer Science, pages 667-686. Springer-Verlag, 1994.

[26] M. Tofte. Type inference for polymorphic references. Information and

Computation, 89:1-34, 1990.

[27] A. Wright and M. Felleisen. A syntactic approach to type soundness. Technical

Report TR91-160, Rice University Department of Computer Science, 1991. To
appear in Information and Computation.

22