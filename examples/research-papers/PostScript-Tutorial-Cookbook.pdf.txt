

   

L A N G U A G E
TUTORIAL
and
COOKBOOK

ADOBE SYSTEMS
I N C O R P O R A T E D

Addison-Wesley Publishing Company, Inc.
Reading, Massachusetts  *  Menlo Park, California
Don Mills, Ontario  *  Wokingham, England  *  Amsterdam
Sydney  *  Singapore  *  Tokyo  *  Madrid
Bogota'  *  Santiago  *  San Juan

    

Library of Congress Cataloging in Publication Data
Main entry under title:
Postscript language tutorial and cookbook.

Includes index.1. PostScript (Computer program language)
I. Adobe Systems.QA76.73.P67P68  1985  005.13c'3  85-15694
ISBN 0-201-10179-3

Copyright (C) 1985 by Adobe Systems Incorporated.
All rights reserved.  No part of this publication may bereproduced, stored in a retrieval system, or transmitted, in any

form or by any means, electronic, mechanical, photocopying,recording, or otherwise, without the prior written permission
of the publisher.Printed in the United States of America.
Published simultaneously in Canada.
POSTSCRIPT is a trademark of Adobe Systems Incorporated.

Times is a trademark and Helvetica is a registered trademark ofAllied Corporation.
Linotron 101 is a registered trademark of Allied Corporation.Scribe and U

NILOGIC are registered trademarks of UNILOGIC, Ltd.Apple, AppleTalk, and MacTerminal are trademarks of

Apple Computer, Inc.Macintosh is a trademark licensed to Apple Computer, Inc.

The information in this book is furnished for informational use only, issubject to change without notice, and should not be construed as a

commitment by Adobe Systems Incorporated.  Adobe SystemsIncorporated assumes no responsibility or liability for any errors or
inaccuracies that may appear in this book.  The software described inthis book is furnished under license and may only be used or copied in
accordance with the terms of such license.

ABCDEFGHIJ-HA-898765Second printing: December 1985

iv

 

Contents
PREFACE ix
POSTSCRIPT LANGUAGE
TUTORIAL

CHAPTER 1 INTRODUCTION

1.1 POSTSCRIPT as a Page Description Language 1
1.2 POSTSCRIPT as a Programming Language 4

CHAPTER 2 STACK AND ARITHMETIC

2.1 The POSTSCRIPT Stack 7
2.2 Arithmetic 8
2.3 Interactive Stack Operators 12
2.4 New Operator Summaries 14
2.5 Operator Summary 15

CHAPTER 3 BEGINNING GRAPHICS

3.1 Drawing Lines 18
3.2 Filled Shapes 22
3.3 Operator Summary 25

CHAPTER 4 PROCEDURES AND VARIABLES

4.1 POSTSCRIPT Dictionaries 27
4.2 Defining Variables and Procedures 28
4.3 Using Procedures and Variables 30
4.4 Operator Summary 33

CHAPTER 5 PRINTING TEXT

5.1 POSTSCRIPT Fonts 35
5.2 Printing Variety 38
5.3 Operator Summary 46

v

  

CHAPTER 6 MORE GRAPHICS

6.1 Coordinate Systems 47
6.2 Graphics State 50
6.3 Curves 53
6.4 Operator Summary 60

CHAPTER 7 LOOPS AND CONDITIONALS

7.1 Conditional Execution 62
7.2 Loops 67
7.3 Operator Summary 76

CHAPTER 8 ARRAYS

8.1 POSTSCRIPT Arrays 77
8.2 Array Operators 78
8.3 Operator Summary 86

CHAPTER 9 MORE FONTS

9.1 Different Shows 87
9.2 Character Encoding 91
9.3 Font Transformations 94
9.4 Character Outlines 97
9.5 Operator Summary 100

CHAPTER 10 CLIPPING AND LINE DETAILS

10.1 Clipping Path 101
10.2 Line-Drawing Details 104
10.3 Operator Summary 110

CHAPTER 11 IMAGES

11.1 The image Operator 111
11.2 Operator Summary 117

CHAPTER 12 POSTSCRIPT PRINTERS

12.1 Apple LaserWriter 119

vi

 

POSTSCRIPT LANGUAGE
COOKBOOK

INTRODUCTION

FORMAT OF THE EXAMPLES 125
HOW TO USE THE COOKBOOK 126

BASIC GRAPHICS

ABOUT THE PROGRAMS 129
DICTIONARIES AND LOCAL VARIABLES 130
Program 1 / Repeated Shapes 135
Program 2 / Expanded and Constant Width Lines 137
Program 3 / Elliptical Arcs 139
Program 4 / Drawing Arrows 143
Program 5 / Centered Dash Patterns 147
Program 6 / Printing Images 151

PRINTING TEXT

ABOUT THE PROGRAMS 155
Program 7 / Printing with Small Caps 159
Program 8 / Setting Fractions 163
Program 9 / Vertical Text 167
Program 10 / Circular Text 169
Program 11 / Placing Text Along an Arbitrary Path 173

APPLICATIONS

ABOUT THE PROGRAMS 177
Program 12 / A Simple Line Breaking Algorithm 181
Program 13 / Making a Poster 185
Program 14 / Drawing a Pie Chart 189
Program 15 / Filling an Area with a Pattern 193

MODIFYING AND CREATING FONTS

MODIFYING EXISTING FONTS 199
CREATING NEW FONTS 200
ABOUT THE PROGRAMS 201
Program 16 / Making an Outline Font 205
Program 17 / Re-encoding an Entire Font 209
Program 18 / Making Small Changes to Encoding Vectors 213
Program 19 / Changing the Character Widths of a Font 217
Program 20 / Creating an Analytic Font 221
Program 21 / Creating a Bitmap Font 225

vii

 

FOR FURTHER REFERENCE 229
QUOTATIONS 231

APPENDIX OPERATOR SUMMARY

INDEX 241

viii

   

Preface
The POSTSCRIPT page description language provides a device in-dependent standard for representing the printed page. This book

is  designed  to  be  a  companion  piece  to  the POSTSCRIPT Lan-guage  Reference  Manual.  It  presents  illustrative  material  to  aid
in  understanding  the  POSTSCRIPT language.  The  tutorial  infor-mation  presented  here  has  been  deliberately  separated  from  the
reference  manual  to  help  ensure  that  the  defining  document  of-fers a precise, unambiguous definition of the language and associated  graphics  imaging  model.  In  all  cases,  when  questions  ofdefinition  or  precise  specification  are  raised,  the P

OSTSCRIPTLanguage Reference Manual is the final word.

This  book  actually  contains  two  documents:  the POSTSCRIPTLanguage Tutorial and the P

OSTSCRIPT Language Cookbook.

The  tutorial  provides  an  easy,  informal  introduction  to  theP

OSTSCRIPT language and its graphics primitives. The tutorial'sstyle  and  level  of  presentation  is  aimed  at  programmers  who

wish  to  design  and  implement  applications,  such  as  wordprocessing packages, graphics illustrators, and CAD/CAM drawing systems. It is interactively oriented, and written with the as-sumption  that  you,  the  reader,  already  know  how  to  program.
You  are encouraged to try  variations  of the examples  presentedin  the  tutorial  on  a  P

OSTSCRIPT printer  as  you  work  your  waythrough the book.

The cookbook is, as its name suggests, a collection of programsthat  are  offered  as  examples  of  P

OSTSCRIPT usage.  Thesesamples have been chosen both as illustrations of the functional

range  of  POSTSCRIPT and  as  useful  ingredients  for  inclusion  inapplication  packages  that  you  design.  The  cookbook  samples
demonstrate techniques for rendering quality graphics, achievingeffective  typography  with  digital  fonts,  and  maintaining  true
device  independence.  Again,  you  are  encouraged  to  experimentwith variations of these samples on a P

OSTSCRIPT printer as youdevelop your own applications.

ix

   

The  principal  authors  of  this  material  are  Linda  Gass  and  JohnDeubert. The final organization and the majority of the material

for  the POSTSCRIPT Language  Tutorial is  due  to  John  Deubert.Ed  Taft  reviewed  and  proofread  the  material  during  the  later
stages of its production. Linda Gass designed and developed theP

OSTSCRIPT Language Cookbook and she is the principal authorof both the examples and the explanatory text. The seminal idea

of the cookbook is due to Doug Brotz and several of the illustra-tions  in  the  cookbook  are  due  to  John  Warnock.  Andy  Shore
proofread the text and POSTSCRIPT sample programs. The bookdesign was specified by Bob Ishi and was implemented by Andy
Shore  and  Brian  Reid.  The  index  was  compiled  by  StevenSorensen.

The  art  of  printing  is  rich  in  tradition,  and  the  technology  forproducing  the  printed  page  has  evolved  over  centuries.  We  at

Adobe  Systems  are  pleased  to  offer  POSTSCRIPT as  a  tool  forprinting in the electronic age. I believe that this tutorial material
will  significantly  enhance  your  ability  to  explore  this  excitingtechnology  and  help  you  enjoy  the  process  of  discovering  the
world of electronic printing.

Charles GeschkeAugust 1985

x

    

CHAPTER 1
INTRODUCTION

A

BAC
BAC
A BDC
EA BDC
EFA BD

The POSTSCRIPT language is a programming language designedto convey a description of virtually any desired page to a printer.

It possesses a wide range of graphic operators that may be com-bined  in  any  manner.  It  contains  variables  and  allows  the  combining of operators into more complex procedures and functions.
POSTSCRIPT page descriptions are programs to be run by an in-terpreter.  P

OSTSCRIPT programs  are  usually generated by  appli-cation  programs  running  on  other  computers.  However,  many

POSTSCRIPT printers,  including  the  Apple  LaserWriter,  have  aninteractive  state  in  which  the  user  may  program  directly  in
POSTSCRIPT (see section 12.1).

1.1  POSTSCRIPT AS A PAGE DESCRIPTION LANGUAGE

POSTSCRIPT has  a  large  selection  of  graphics  operators  that  al-low it to precisely describe a desired page. These operators control the placement of three types of graphics objects:

* Text in a wide variety of typefaces can be placed on a pagein any position, orientation, and scale.

* Geometric  figures can  be  constructed  using  POSTSCRIPTgraphics operators.  These describe the locations of straight

1

      

lines and curves of any size, orientation, and width, as wellas filled spaces of any size, shape, and color.

* Sampled  Images of  digitized  photographs,  free-handsketches,  or  any  other  image  may  be  placed  on  a  page  in

any scale or orientation.
All graphic objects may be easily rotated, scaled, and clipped toa specified portion of the output page.

POSTSCRIPT Imaging Model
An imaging  model is  the  set  of  rules  that  are  incorporated  intothe design of a graphics system. The P

OSTSCRIPT imaging modelis very similar to the model we instinctively adopt when we draw

by hand.
The  POSTSCRIPT model  considers  an  image  to  be  built  up  byplacing ink on a page in selected areas. The ink may form letters,

lines,  filled  shapes,  or  halftone  representations  of  photographs.The ink itself may be black, white, colored, or any shade of gray.
These  elements  may  be  cropped  to  a  boundary  of  any  shape  asthey are placed on the page. Once the page has been built up to
the desired form, it may be printed on an output device.
Three  concepts  are  central  to  the  implementation  of  theP

OSTSCRIPT imaging model:

Current Page: The current page is the "ideal page" on whichP

OSTSCRIPT draws.  It  is  independent  of  the  capabilities  of  theprinter being used.

When  a  program  begins,  the  current  page  is  completely  empty.P

OSTSCRIPT painting operators place marks on the current page,each of which completely obscures marks that they may overlay.

Once  the  current  page  is  completely  described,  it  is  sent  to  theprinter, which reproduces the page as well as it can.

It  is  important  to  remember  that  no  matter  what  color  a  markhas -- white,  gray,  black,  or  color -- it  is  put  onto  the  current

page as if it were applied with opaque paint.
Current Path: The current path is a set of connected and dis2 Chapter 1:  INTRODUCTION

    

connected points, lines, and curves that together describe shapesand their positions. There is no restriction to the shapes that may
be defined by the current path; they may be convex or concave,even  self-intersecting.  The  elements  of  the  current  path  are
specified  in  terms  of  their  positions  on  the  current  page.  Theresolution  of  the  printer  in  use  in  no  way  constrains  the  definition of the path.
The  current  path  is  not  itself  a  mark  on  the  current  page.P

OSTSCRIPT path  operators define  the  current  path,  but  do  notmark the page. Once a path has been defined,  it can be stroked

onto the current page (resulting in a line drawn along the path),filled (yielding solid regions of ink), or used as a clipping boundary.
Clipping  Path: The current  clipping  path is  the  boundary  ofthe  area  that  may  be  drawn  upon.  Initially,  the  clipping  path
matches  the  printer's  default  paper  size.  The  clipping  path  maybe changed to any size and shape desired. If an imaging operator
tries  to  mark  the  current  page  outside  of  the  current  clippingpath,  only  those  parts  of  the  mark  that  fall  within  the  clipping
path will actually be drawn onto the current page.

Coordinate Systems
Positions on a page are described as x and y pairs in a coordinatesystem imposed on the page.

Every output device has a built-in coordinate system by which itaddresses points on a page. We call this built-in coordinate system,  idiosyncratic  to  each  device, device  space.  Device  spacevaries widely from printer to printer; there is no uniformity in the
placement  of  coordinate  origins  or  in  horizontal  and  verticalscaling.

Positions on the POSTSCRIPT current page are described in termsof  a user coordinate system or user space. This  coordinate system is independent of the printer's device space. Coordinates in aP

OSTSCRIPT program  are  automatically  transformed  from  userspace  into  the printer's  device  space  before  printing  the  current

page. User space thus provides a coordinate system within whicha  page  may  be  described  without  regard  for  the  particular
machine on which the page is to be printed.

1.1  POSTSCRIPT AS A PAGE DESCRIPTION LANGUAGE 3

    

The  POSTSCRIPT user  space  can  be  altered  in  three  ways.  Thecoordinate  system's  origin  may  be translated,  moved  to  any

point in user space. The axes may be rotated to any orientation.The axes may be scaled to any degree desired; the scaling may
be  different  in  the x and y directions.  A  sophisticated  user  mayspecify  any  linear  transformation  from  user  space  to  device
space.  Thus,  coordinates  in  a  POSTSCRIPT program  are  change-able  with  respect  to  the  current  page,  since  they  are  described
from  within  a  coordinate  system  that  may  slide  around,  turn,shrink, or expand.

1.2  POSTSCRIPT AS A PROGRAMMING LANGUAGE

About  one-third  of  the  POSTSCRIPT language  is  devoted  tographics. The remainder makes up an entirely general computer

programming language. The POSTSCRIPT language contains ele-ments  of  many  other  programming  languages,  but  most  closely
resembles the FORTH language.

POSTSCRIPT Stack
POSTSCRIPT reserves  a  piece  of  memory  called  a stack for  thedata with which it is working. The stack behaves like a stack of

books.  The  last  book  placed  on  the  stack  is  the  first  book  thatwill  later  be  removed.  Similarly,  numbers,  strings,  and  other
pieces  of  data  placed  on  the  stack  will  be  removed  in  reverseorder, the last item added to the stack being the first retrieved.

Postfix Notation
POSTSCRIPT operators  that  require  numbers  or  other  data,  suchas add and sub,  retrieve  that  data  from  the  stack.  To  use  an

operator,  one  must  first  place  the  data  it  requires,  its operands,on the stack, and then call the operator. The operator will place
its own results on the stack. This style of programming, in whichthe  operands  are  specified  before  the  operator,  is  referred  to  as
postfix notation.

4 Chapter 1:  INTRODUCTION

   

POSTSCRIPT Data Types
POSTSCRIPT supports  many  data  types  common  to  other  lan-guages,  including  reals,  booleans,  arrays,  and  strings.  The

POSTSCRIPT language  also  defines  object  types  such  asdictionary and mark. For descriptions of all the P

OSTSCRIPT dataand  object  types,  refer  to  the P
OSTSCRIPT Language  ReferenceManual.

POSTSCRIPT Flexibility
POSTSCRIPT is an extremely flexible language. Functions that donot  exist,  but  which  would  be  useful  for  an  application,  can  be

defined  and  then  used  like  other  POSTSCRIPT operators.  Thus,P

OSTSCRIPT is  not  a  fixed  tool  within  whose  limits  an  appli-cation  must  be  written,  but  is  an  environment  that  can  be

changed  to  match  the  task  at  hand.  Pieces  of  one  page  descrip-tion  can  be  used  to  compose  other,  more  complicated  pages.
Such  pieces  can  be  used  in  their  original  form  or  translated,rotated, and scaled to form a myriad of new composite pages.

Printable Programs
POSTSCRIPT programs  are  written  entirely  in  printable ASCIIcharacters. This allows them to be handled as ordinary text files

by  the  vast  majority  of  communication  and  computer  filesystems. In addition, it ensures that a P

OSTSCRIPT program willbe  as  easy  for  a  person  to  read  as  the  structure  of  the  program

allows.

1.2  POSTSCRIPT AS A PROGRAMMING LANGUAGE 5

   

CHAPTER 2

The  POSTSCRIPT programming  language,  like  all  programminglanguages,  works  with  various  types  of  data,  such  as  numbers,

arrays, strings, and characters. The pieces of data manipulated byP

OSTSCRIPT are referred to as POSTSCRIPT objects.

There  are  many  ways  a  language  can  manipulate  data;  for  ex-ample,  many  languages  require  that  data  be  placed  in  variables

and be addressed by a variable name. The POSTSCRIPT languagehas  variables,  but  it  also  manipulates  data  directly  by  using  a
special entity called a stack.

2.1  THE POSTSCRIPT STACK

A  stack  is  a  piece  of  memory  set  aside  for  data  which  is  to  beimmediately  used  by  P

OSTSCRIPT.  This  memory  area  is  or-ganized  in  such  a  way  that  the  last  item  put  in  is  the  first  item

available to be removed. This type of data structure is referred toas a last in, first out or

LIFO stack.

A LIFO stack  behaves  like  a  stack  of  books.  As  the  books  arestacked  up -- Twain,  then  Dickens,  then  Hemingway,  and  so

on -- only the book on the top, the last one added, is really acces-sible.

7

     

Putting Numbers on the Stack
Any  number  appearing  in  a  POSTSCRIPT source  file  (that  is,  atext  file  that  contains  a  P

OSTSCRIPT program)  is  placed  on  thestack. For example, if a source file contains the following line:

12  6.3 -99
the interpreter will take the following actions as it reads the line12
12

6.3

12

6.3

-99

6.3

12

-99

POSTSCRIPT Stack

from left to right (see illustration at left):

1. Push the number 12 onto the stack
2. Place 6.3 on  the  stack,  pushing 12 to  the  next  positiondown.

3. Put -99 onto the stack, pushing the first two numbers downone place.
The  number -99 is  now  at  the  top  of  the  stack,  waiting  to  beused.  The  other  numbers  are  on  the  stack  also,  but  can  only  bemark
/Font

[1 2]

(PS)

Anything can be placedon the stack

taken  off in the proper  order.  It should be  borne  in  mind as weuse the stack that any kind of P

OSTSCRIPT object can be placedon  the  stack.  This  includes  arrays,  strings,  and  the  more  exotic

POSTSCRIPT objects,  like  dictionaries.  For  the  first  chapter  ortwo  of  this  tutorial,  we  shall  concentrate  primarily  on  numbers,
to simplify our discussion.
Note that spaces, tabs, and newline characters act as delimiters ofP

OSTSCRIPT objects.  Other  characters,  such  as  parentheses  andbrackets,  can  be  delimiters  under  some  circumstances;  we  shall

discuss these as we progress through the tutorial.

2.2  ARITHMETIC

A  POSTSCRIPT operator is  a  word  that  causes  the  POSTSCRIPTinterpreter  to  carry  out  some  action.  It  is  the  equivalent  of  the

commands  and  procedures  of  other  languages.  When  the  inter-preter comes across a word in a source file, it searches its internal  dictionaries  to  see  if  that  word  is  an  operator  name.  If  thename  is  listed  in  the  dictionary,  the  interpreter  carries  out
whatever  instructions  are  associated  with  that  name  and  thencontinues on to the next word in the source file. For more detail
on POSTSCRIPT dictionaries, refer to chapter four.

8 Chapter 2:  STACK AND ARITHMETIC

      

add and sub
POSTSCRIPT operators  look  to  the  stack  for  the  numbers  theyneed, that is, for their operands. The operator generally removes

its  operands  from  the  stack  and  replaces  them  with  whateverresults that operator produces.

For example, the add operator causes POSTSCRIPT to remove the
5

5

27

5

27

32
add

add

top two numbers from the stack, add them, and leave the sum onthe stack. Thus, the program line below would affect the stack as
illustrated at left.

5  27  add
The 5 and the 27 are pushed onto the stack and the add operatorthen replaces them with their sum.

8.3

8.3

6.6
8.3

6.6

1.7

sub

sub

The  POSTSCRIPT sub operator  works  in  a  similar  manner,  withthe program line

8.3  6.6  sub
having the results diagrammed at left. The numbers 8.3 and 6.6are pushed on the stack; the sub operator subtracts the top number on the stack from the number below it.

Stack Notation
The  contents  of  the  POSTSCRIPT stack  is  typically  depicted  inprint as a line of numbers (or other data) with the top of the stack

at  right.  Thus,  a  stack  with 6 on  top, 143.9 below  it,  and -800below that is printed:

-800  143.9  6
Notice that this displays the numbers in the order in which theywere originally placed on the stack.

Similarly,  the  effects  of  an  operator  on  the  stack  may  be  in-dicated  by  showing  the  stack's  initial  condition  (before  the

operator is executed), the operator's name, and then the contentsof the stack after the operator was executed. Using this method, a
demonstration of the effects of add could be expressed:

2.2  ARITHMETIC 9

      

5  27 add Th 32
.

Other Arithmetic Operators
Besides add and sub,  POSTSCRIPT possesses  a  full  range  ofarithmetic operators, including:

div Divide  the  second  number  on  the  stack  by  thetop number on the stack. For example,

13  8 div Th 1.625
idiv Divide  the  second  number  on  the  stack  by  thetop number on the stack; only the integral part of

the quotient is retained.

25  3 idiv Th 8
mod Divide  the  second  number  by  the  top.  In  thiscase, only the remainder of the division is kept.

12  10 mod Th 2
The  operands  passed  to  the mod and idivoperators must be integers.

mul Multiply  the  top  two  numbers  on  the  stack,pushing the product onto the stack.

6  8 mul Th 48
neg Reverse  the  sign  of  the  number  on  top  of  thestack.

-27 neg Th 27
These are the arithmetic operators we shall be using the most inthis  tutorial.  For  detailed  descriptions  of  the  full  range  of

POSTSCRIPT arithmetic  operators,  including sqrt, exp, ceiling,and sin, see the P

OSTSCRIPT Language Reference Manual.

10 Chapter 2:  STACK AND ARITHMETIC

      

More-Complex Arithmetic
The  use  of  a  stack  in  POSTSCRIPT allows  some  freedom  in  ex-actly how an  arithmetic  process  is  carried  out.  For example,  let

us say that we wanted to calculate

6 + (3 / 8)
in POSTSCRIPT. Either of the following two program lines wouldleave the appropriate number on the stack.

* 3  8  div  6  add

* 6  3  8  div  add
8
3

3  8

.375

div

6
.375

6

6.375

add

6+3/8, Example 1

In the first case  (see illustration), we put 3 and 8 on the stack,divide the former by the latter, put 6 on the stack, and add it to
the quotient below it.
In the second case, the same operations are performed, but nowwe  start  out  by  putting  all  three  of  the  numbers  on  the  stack.

8
3
6

6  3  8

.375

6

div

6.375

add

6+3/8, Example 2

Then we call the div operator, which divides the second number(3) by the top (8) and add the top two numbers (6 and .375).
Similarly, the equation

8 - (7 * 3)
can be expressed in at least two ways:

* 8  7  3  mul  sub

* 7  3  mul  8  exch  sub
The  second  method  introduces  a  new  operator: exch.  Thisoperator exchanges the top two items on the stack. Note that in

21
7 3 mul

8
21

8

21

8

exch

-13

sub

8-7*3

this example, the phrase 7 3 mul places the two numbers on thestack and multiplies them, leaving the product, 21, on the top of
the  stack.  The  number 8 is  then  pushed  onto  the  stack,  but  thisleaves the stack contents in the wrong order for our subtraction.
The sub operator  subtracts  the  top  number  from  the  second,which in this case would be 21 minus 8, the opposite of what we

2.2  ARITHMETIC 11

      

want. The exch operator invoked at this point reverses the orderof the top two numbers of the stack, putting them in the correct
order for our subtraction.

Stack Operators
The exch operator  is  our  first  example  of  a stack  operator,  anoperator whose function is to add, remove, or rearrange items on

the POSTSCRIPT stack. There are several such operators, includ-ing:

clear Removes all items from the stack.

6  8  12 clear Th --
dup Duplicates the top item on the stack.

6 dup Th 6  6
pop Remove the the top element from the stack.

17  8 pop Th 17
roll Roll stack contents. Take two numbers from thestack.  The  top  number  tells  P

OSTSCRIPT howmany times and in which direction to rotate the

stack; the second number is how many items areto be rotated.

7  8  9  3  1 roll Th 9  7  8
7  8  9  3 -1 roll Th 8  9  7
We  will  be  using  these  and  other  stack  manipulation  operatorsthroughout  this  manual.  For  a  complete  description  of  all  these

operators,  see  the  appropriate  chapter  in  the POSTSCRIPT Lan-guage Reference Manual.

2.3  INTERACTIVE STACK OPERATORS

Most  POSTSCRIPT programs  are  generated  by  applicationprograms such as word processors. However, many P

OSTSCRIPTprinters  have  an  interactive  mode  that  allows  a  user  to  speak

12 Chapter 2:  STACK AND ARITHMETIC

      

directly to the POSTSCRIPT interpreter. For those who do have aninteractive  environment,  P

OSTSCRIPT has  operators  that  allowyou to directly examine the stack.

==
15.3

-17

98

(a)

-17

98

(b)

The == operator removes the top item from the stack and echosit over a communications channel (which is often connected to a
terminal). Thus, if the stack looked like figure a, at left, the ==operator,  typed  on  the  keyboard,  would  print 15.3 on  the  terminal and leave the stack holding the contents indicated in b.
The == operator prints the top item as well as it can. Many ob-jects,  such  as  numbers,  strings,  and  arrays,  are  simply  printed.

Items that cannot be printed, like dictionaries and files, are iden-tified by their object types. Thus, if the top item on the stack was
a  dictionary  (we  shall  be  talking  about  this  at  greater  lengthlater), the == operator would print

--dictionary--
on the terminal.

pstack
Another useful interactive stack operator is pstack. This operatorprints  the  contents  of  the  entire  stack.  Unlike  the == operator,

pstack does not remove any of the stack's contents.
Thus, if the stack looked like this:

6  12 -97.2  100
The pstack operator  would  display  the  following,  leaving  thestack unchanged.

100-97.2
126

pstack and == are examples of polymorphic operators, so calledbecause  they  can  take  many  different  kinds  of  objects  as

operands.

2.3  INTERACTIVE STACK OPERATORS 13

     

2.4  NEW OPERATOR SUMMARIES

This chapter,  and those that  follow,  end with a  summary  of  theP

OSTSCRIPT operators  introduced  in  the  chapter.  These  sum-maries group the new operators by function type and list the following information for each:

* Operator name

* Stack contents before operation

* Stack contents after operation

* Description of operation

The two lists of stack contents are separated by a double arrow(Th).  The  symbols  used  in  the  stack  descriptions  represent  the

following types of objects:
n i j x y Numbers
ary Array
bool Boolean
dict Dictionary
fdict Font dictionary
nam Name
ob Any POSTSCRIPT object
proc Procedure
str String
Other  symbols,  when  used,  are  self-explanatory.  When  morethan one type of object may be expected on the stack, the alternative  types  will  be  separated  by  a  slash  (/).  Thus, ary/str in-dicates that the object may be either an array or a string.

14 Chapter 2:  STACK AND ARITHMETIC

     

2.5  OPERATOR SUMMARY

Stack Operators
clear ob ...ob Th --1 i

Remove all stack contents

dup ob Th ob ob

Duplicate top of stack

exch ob ob Th ob ob1 2 2 1

Reverse order of top two objects on stack

pop ob ob Th ob1 2 1

Remove top of stack

roll ob ...ob n j Th ob ...ob ob ...obn-1 0 (j-1) mod n 0 n-1 j mod n

Rotate n elements j times

Math Operators
add n n Th n +n1 2 1 2

Add two numbers

div n n Th n /n1 2 1 2

Divide two numbers

idiv n n Th int(n /n )1 2 1 2

Integer divide

mod n n Th (n MOD n )1 2 1 2

Modulus

mul n n Th n *n1 2 1 2

Multiply two numbers

sub n n Th n -n1 2 1 2

Subtract two numbers

Interactive Operators
== ob Th --

Destructively display top of stack

pstack ob ...ob Th ob ...ob1 i 1 i

Display stack contents

2.5  OPERATOR SUMMARY 15

   

CHAPTER 3
BEGINNING GRAPHICS

The  POSTSCRIPT language  is  designed  to  produce  graphicimages. This being the case, the language comes with a wealth of

graphics operators, which we shall be exploring in this tutorial.
Drawing with POSTSCRIPT starts with constructing a path on anideal drawing surface called the current page. A path is a set of

straight  lines  and  curves  that  define  a  region  to  be  filled  orrepresent  a  trajectory  that  is  to  be  drawn  on  the  current  page.
(For  a  more  complete  discussion  of  paths  and  the  current  page,refer to the P

OSTSCRIPT Language Reference Manual.)

Having constructed a path, we need to decide what to do with it.We can paint a line of some thickness along the current path or

we can fill the path in to create a solid shape.
We will alternate these two steps -- creating a path and filling orstroking  it -- until  everything we want has been drawn onto  the

current page. Once the current page is complete, we can print iton a physical piece of paper.

17

    

3.1  DRAWING LINES

Let  us  begin  with  a  simple  task:  drawing  a  single  5-inch-longvertical line. The following program accomplishes this.

newpath144 72 moveto

144 432 linetostroke
showpage
Let us examine this program line by line.
We  start  out  by  calling  the newpath operator.  This  operatorempties the current path and declares we are starting a new path.

Now  we  shall  construct  a  straight  path  that  corresponds  to  theline we  wish  to draw. Paths  are constructed by  moving a phantom "pen" around the current page. This pen leaves an unmarkedtrace  on  the  current  page  that  represents  the  current  path.  The
position  on  the  current  page  to  which  this  pen  points  at  a  par-ticular time is the current point on the current path.

We start building a path with a moveto.

144 72 moveto
The moveto operator takes two numbers off the stack and treatsthem as x and y coordinates to which to move. The coordinates

specified become the current point.
In the POSTSCRIPT default coordinate system, the origin is in thelower left hand corner of the current page. As usual, x increases

to  the right and y increases upward.  The units employed in thissystem are 1/72 inch long. Thus, our second program line places
two numbers (144 and 72) on the stack and then moves the cur-rent point to a location 2 inches (144/72) to the right and 1 inch
(72/72) up from the lower-left corner of the page.
The lineto operator on the third line,

144 432 lineto
adds a segment to the current path that connects the current point

18 Chapter 3:  BEGINNING GRAPHICS

     

to the position specified by the numbers on the stack, in this case144 and 432. The point specified as the argument to this operator
becomes the new current point.
Note that the lineto operator does not actually draw on the cur-rent page. It simply adds a line segment to the current path. You

may later draw in this line, but it does not happen automatically.
The stroke operator  on  line  four  causes  the  path  we  have  con-structed to be painted onto the current page. Our path becomes a

visible line.
Finally, showpage prints the current page, with the line we drewon it.

The three steps we took in drawing our line were:

1. Construct a POSTSCRIPT path, using newpath, moveto, andlineto.

2. stroke that path onto the current page.
3. Print the current page with showpage.

Two Lines
The following program, whose output is at left, draws two lines.

newpath72 360 moveto

144 72 rlineto144 432 moveto
0 -216 rlinetostroke
showpage
This program is similar to our first. The first two lines clear thecurrent  path  and  move  the  current  point  to  a  position  1  inch  to

the right and 5 inches up from the page's lower-left corner.

newpath72 360 moveto

The next line contains a new operator, rlineto.

3.1  DRAWING LINES 19

     

144 72 rlineto
This  is  similar  to  the lineto operator  we  used  in  the  firstprogram. Here, however, the numbers on the stack represent an x

and y displacement relative to the current point. POSTSCRIPT alsohas an rmoveto operator that is similar to moveto, but measures
positions relative to the current point.
Thus, the program line above adds a line segment to the currentpath.  This  segment  extends  two  inches  to  the  right  of,  and  one

inch above, the current point.
The next two lines of the program,

144 432 moveto0 -216 rlineto

move the current point up above the first line segment and thenadd a line segment to our path extending down (note the negative
y argument) 216 units from that point.
At  this  stage  we  have  a  path  consisting  of  two  intersecting  linesegments. These lines would be invisible if we were to print the

current  page  right  now,  since  we  have  not  yet  used  the strokeoperator.  Note  that  the  current  path  is  not  continuous.  A
POSTSCRIPT path does not need to be a single connected piece; itcan consist of any collection of line segments and curves on the
current page.
Finally, our program strokes the path and prints the current page.

A Box

A Box

Here's a simple one-inch-square box, centered on the page:

newpath270 360 moveto

0 72 rlineto72 0 rlineto
0 -72 rlineto-72 0 rlineto
4 setlinewidthstroke showpage

20 Chapter 3:  BEGINNING GRAPHICS

     

This program moves to a position near the center of the page andthen constructs a box-shaped path by moving one inch up, right,

down, and left. The path is then stroked and the page printed.
The seventh line presents something new:

4 setlinewidth
The setlinewidth operator allows you to specify the width of theline  that  is  stroked  onto  your  path.  In  this  case,  a  line  width  of

4/72  inch  is  specified;  this  will  remain  the  width  of  all  linesstroked onto the page until a new setlinewidth is invoked.

Our box, you may notice, contains a flaw: the lower-left cornerhas a notch in it. This results from our lines' having significant

width.4units
(a)

(b)

A four-unit-wide line segment extends two units to either side ofthe  current  path  (illustration a,  at  left).  Where  the  first  and  last

line segments of our box intersect, there is a two-unit-square areathat  is  not  a  part  of  either  stroked  path  and  remained  white
(illustration b).

A Better Box

To avoid this problem, we must use a new operator: closepath.

newpath270 360 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
4 setlinewidthstroke showpage

This  program  is  identical  to  the  previous  one,  save  that  theprogram line closing the box has been changed to closepath. The

closepath operator adds a line segment to the current path con-necting the current point to the last point addressed by a moveto
operator.  It  closes  the  path  with  a  mitered  join,  eliminating  thenotch  we  noticed  in  our  first  box.  It  is  possible  to  change  the
method  by  which  POSTSCRIPT joins  line  segments;  to  see  howthis is done, refer to chapter 9 of this tutorial.

3.1  DRAWING LINES 21

    

3.2  FILLED SHAPES

Our  programs  so  far  have  constructed  paths  and  then  strokedthem  onto  the  page.  However,  a  P

OSTSCRIPT path  can  also  befilled in. The following program is identical to the last except for

A Filled Box

one line.

newpath270 360 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
fillshowpage

This  time,  instead  of  stroking  this  path,  we  invoked  the filloperator. This operator fills the current path with ink, producing
a solid black square.

A Gray Box
Our  block  does  not  have  to  be  black.  The  program  belowproduces a gray box.

newpath270 360 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
.5 setgrayfillA Gray Box

showpage
The setgray operator  specifies  the  shade  of  gray  in  which  allpainting  is  to  be  done.  The  argument  on  the  stack  (0.5,  in  this

case)  specifies  the  shade,  with  zero  being  black  and  one  beingwhite.  The  gray  shade  specified  will  remain  in  effect  until
another setgray changes it. If a program does not specify a grayvalue, P

OSTSCRIPT assumes everything is to be painted in black.

22 Chapter 3:  BEGINNING GRAPHICS

    

Your  printer  may  produce  halftones  that  look  different  fromthose printed in this tutorial. Each printer has its own method of

generating these.

Overlapping Shapes
POSTSCRIPT images are opaque. Any ink painted on the currentpage  will  obscure  anything  previously  painted  there.  Consider

this program, for example, which paints three overlapping solidsquares.

newpath %Begin black box252 324 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
fill
newpath %Begin gray box270 360 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
.4 setgrayfill

newpath %Begin lighter box288 396 moveto

0 72 rlineto72 0 rlineto
0 -72 rlinetoclosepath
.8 setgray

Overlapping Boxes

fillshowpage %Send to printer
This  example  paints  a  black  box,  an  overlapping  gray  box,  andan  overlapping  light  gray  box.  Each  box  covers  up  part  of  the
box below it. If we had painted a white box, that would also havecovered up whatever it overlapped.

Note  that  each  box  had  to  start  with  a moveto.  This  is  because

3.2  FILLED SHAPES 23

    

the fill operator  clears  the  current  path;  after  a fill,  there  is  nocurrent  point  and  a lineto or rlineto would  have  no  starting
point. The stroke operator also clears the current path.
The  three-box  program  also  contains  comments.  Comments  inP

OSTSCRIPT programs start with a percent symbol and continueto the end of the line. Anything following a % on a P

OSTSCRIPTprogram line is ignored by the interpreter.

This  last  program  was  quite  repetitious;  we  performed  a  set  ofoperations -- drawing a filled box -- three times. We shall see in

the  next  chapter  that  the  POSTSCRIPT language  allows  you  todefine a group of operations as a named procedure. This procedure  can  then  be  used  exactly  as  though  it  were  a  POSTSCRIPTpredefined operator.

24 Chapter 3:  BEGINNING GRAPHICS

     

3.3  OPERATOR SUMMARY

Path Construction Operators
closepath -- Th --

Closes the current path with a straight line to the last moveto point

lineto x y Th --

Continue the path with line to (x,y)

moveto x y Th --

Set the current point to (x,y)

newpath -- Th --

Clear the current path

rlineto x y Th --

Relative lineto (currentpoint + (x,y))

rmoveto x y Th --

Relative moveto

Painting Operators
fill -- Th --

Fill current path with the current color

setgray n Th --

Set the current color

setlinewidth n Th --

Set the current line width

stroke -- Th --

Paint the current path with the current color and line width

Output Operators
showpage -- Th --

Transfer the current page to the output device

3.3  OPERATOR SUMMARY 25

   

CHAPTER 4

4.1  POSTSCRIPT DICTIONARIES

A  dictionary  is  a  table  that  associates  pairs  of  objects.  AnEnglish  dictionary  associates  words  with  their  definitions.  A

POSTSCRIPT dictionary  associates  an  object  called  a key withanother object, the key's value. The P

OSTSCRIPT interpreter canlook up a key in a dictionary and obtain the associated value (or

discover that the key is not present).
Two  POSTSCRIPT dictionaries  are  always  present,  the systemdictionary and  the user  dictionary.  The  system  dictionary  pairs

each  predefined  POSTSCRIPT operator  name  with  a  particularbuilt-in  action.  The  P

OSTSCRIPT user  dictionary associatesnames with the procedures and variables defined by a program.

When the interpreter encounters a name, it searches first the userdictionary  and  then  the  system  dictionary.  If  it  finds  the  name

among  the  dictionaries'  keys,  the  interpreter  takes  the  ap-propriate action, usually either putting an object on the stack or
carrying out a set of instructions. If the name is not found in thedictionaries, the interpreter raises an error.

POSTSCRIPT dictionaries  are  kept  on  a dictionary  stack,  whichstarts out with the system dictionary on the bottom and the user

dictionary  on  top.  When  the  interpreter  encounters  a  name,  it

27

     

searches the dictionaries downward from the top of this stack. Aprogram  may  create  new  dictionaries,  which  can  be  placed  on
top of the dictionary stack. The dictionary on top of the diction-ary stack, and thus the first to be searched, is called the current
dictionary. For details on  creating new  dictionaries, refer to theP

OSTSCRIPT Language  Reference  Manual and  the POSTSCRIPTLanguage Cookbook.

4.2  DEFINING VARIABLES AND PROCEDURES

POSTSCRIPT Variables
A  variable  is  defined  by  placing  the  variable's  name  and  valueinto the current dictionary. This is done with the def operator, as

in the following program line:

/ppi  72  def
This  line  first  places  the  name ppi onto  the  stack.  The  slashpreceding  these  characters  indicates  that  the  P

OSTSCRIPT inter-preter should put this name on the stack as a literal and not immediately try to find it in a dictionary.
Next, the number 72 is pushed onto the stack.
Finally, def takes these two objects off the stack and enters theminto  the  current  dictionary.  The  second  item  on  the  stack  (ppi)

becomes the key that is associated with the first item (72). Thatis, ppi is  now  a  P

OSTSCRIPT variable  with a  value  of 72.  If  theline

10  ppi  mul
were to appear later in our program, the POSTSCRIPT interpreter
10

10

72
10

ppi

720

mul

Using a Variable

would do the following:

1. Push 10 on the stack,
2. Search the dictionary stack for the key ppi and put its value,72, on the stack,

3. Multiply  the  top  two  stack  items  together,  leaving  theirproduct on the stack.

28 Chapter 4:  PROCEDURES AND VARIABLES

     

To  change  the  value  of  a  variable,  you  redefine  it  with  a  newvalue. The following lines would both change the value of ppi.
ppi

/ppi

100

ppi

ppi

1
100

ppi

1

101

ppi

add

Incrementing a Variable

/ppi  100  def
/ppi  ppi 1 add  def
The  first  line  would  redefine ppi to  a  value  of 100;  the  secondwould increment the value of ppi by one (see illustration at left).

POSTSCRIPT Procedures
A POSTSCRIPT procedure is a set of operations grouped togetherwith  a  common  name.  This  set  of  operations  is  stored  with  its

key in a dictionary. When the key appears in a program, the as-sociated set of operations is carried out.

POSTSCRIPT procedures are defined  in  exactly the  same way  asvariables. The program must place the procedure name (preceded

by  a  slash)  on  the  stack,  followed  by  the  set  of  operations  thatmake up the procedure. Then the def operator is used to store the
operations and name in the current dictionary. The set of opera-tions making up the procedure must be enclosed in braces.

For example, the following line defines a procedure named inch.

/inch  {72 mul}  def
Any appearances of the word inch following this line will causethe interpreter to carry out the operations inside the braces. That

is, the interpreter will put 72 on the stack and then multiply thetop  two  numbers,  the 72 and  whatever  was  on  the  stack  when
inch was called. Thus, the program lines

5  inch5  72  mul

have identical results; both leave 360, the product of 5 and 72, onthe stack.
The inch procedure  is  a  useful  tool  in  many  programs,  since  ittranslates inches into the 1/72-inch units of the P

OSTSCRIPT co-ordinate system.

4.2  DEFINING VARIABLES AND PROCEDURES 29

    

4.3  USING PROCEDURES AND VARIABLES

The use of procedures and variables can make an enormous dif-ference  in  the  readability  of  a  program,  the  ease  with  which  it

can be modified, and its length.

Three Boxes Again
As an example, let us take the last program from chapter two, thethree  overlapping  boxes,  and  rewrite  it.  Looking  over  the

program, we see that the set of instructions that construct a one-inch-square path is repeated three times. Let us define these instructions to be a procedure named box and then incorporate thisprocedure into the program.

% ----- Define box procedure ---/box

{ 72 0 rlineto0 72 rlineto

-72 0 rlineto

Overlapping Boxes

closepath } def% --------- Begin Program -----------
newpath % First box252 324 moveto box

0 setgray fillnewpath % Second box
270 360 moveto box.4 setgray fill
newpath % Third box288 396 moveto box

.8 setgray fillshowpage

Here we start by defining our new procedure, box, to be the setof operators that create a square path. We then use that procedure
three times to make three filled boxes. First we move to a start-ing  point  on  the  current  page.  Then  we  call  the box procedure,
which contructs a path starting at that point. Finally, we set thegray  value  and  fill  the  path  we  contructed.  These  steps  are
repeated two more times, once for each box in our image.

30 Chapter 4:  PROCEDURES AND VARIABLES

    

Advantages
Changing our program has affected it in three important ways:

1. The program is more compact.
2. The program is more readable.  Procedure names can (andshould)  be  chosen  to  reflect  what  they  do.    In  reading  the

program later, you can more easily see what the program isdoing  at  any  given  point,  since  the  procedure  titles  themselves tell you.
3. The  program  is  more  easily  changed.    If,  for  example,  wewanted it to create two-inch boxes, we would only need to

change  the  definition  of  the box procedure.  In  the  earlierversion  of  this  program,  we  would  have  had  to  separately
change each of the three boxes.

Another Box Program
The way in which one designs a program will vary according towhat  decisions  have  been  made  in  defining  procedures.  Let  us

look at one more way of producing our overlapping boxes.

% ------- Define procedures----/inch  {72 mul} def

/box % stack: x y => ---{ newpath moveto

1 inch 0 rlineto0 1 inch rlineto
-1 inch 0 rlinetoclosepath } def
/fillbox % stack: grayvalue => ---{ setgray fill } def
% ----------- Main Program -----------3.5 inch 4.5 inch box
0 fillbox3.75 inch 5 inch box
.4 fillbox4 inch 5.5 inch box
.8 fillboxshowpage

We have made three changes here. First of all, we have includedour inch procedure, which converts the number on the stack from
inches into POSTSCRIPT units.

4.3  USING PROCEDURES AND VARIABLES 31

    

Second,  we  changed box so  that  it  clears  the  current  path(newpath) and then moves to the location specified on the stack

before tracing out its path. Note that the comment to the right ofthe  procedure  name  indentifies  what  the  procedure  expects  to
find on the stack.
Finally, we defined fillbox, which sets the current gray value tothe number on the stack, and then fills the current path.

This new version of our program divides into two sections. Wefirst defined a set of procedures and then used these procedures

in the main part of our program, the section that actually carriesout our assigned task. This main program section is much more
readable  than  our  original  three-box  program.  Units  are  ex-pressed  in  inches  and  major  activities  are  carried  out  by
procedures whose names indicate their functions.

Considerations in Defining Procedures
There  are  no  solid  rules  that  dictate  when  a  set  of  operationsshould be defined as a procedure. In general, the three qualities

you are trying to maximize are: readability, so that other people(or yourself at a later date) can pick up the program and see what
it  does; compactness,  so  that  your  program  does  not  take  upmore  space  than  is  necessary; flexibility,  so  that  when  changes
become necessary, they can be made with a minimum of pain.
To maximize these qualities, you should consider defining a setof  operations  to  be  a  procedure  if  it  occurs  frequently  in  the

program, particularly if it is likely to need revising, or if its pur-pose  is  obscure  to  the  casual  reader  and  would  benefit  from  a
descriptive name.

32 Chapter 4:  PROCEDURES AND VARIABLES

     

4.4  OPERATOR SUMMARY

Dictionary Operators
def key value Th --

Associate key with value in the current dictionary

4.4  OPERATOR SUMMARY 33

   

CHAPTER 5
PRINTING TEXT

A  great  deal  of  what  we  put  on  paper  is  text  in  various  forms.The  P

OSTSCRIPT language  has  all  the  tools  necessary  to  handletext  operations,  from  simple  word  placement  to  complex

typographic composition.
Text  data  is  represented  by  POSTSCRIPT string objects.  AP

OSTSCRIPT string  consists  of  any  sequence  of  charactersenclosed  in  parentheses.  A  string  can  be  placed  on  the  stack,

assigned to a variable, or printed on paper.
POSTSCRIPT allows  considerable  freedom  in  how  a  string  isprinted.  Before  a  string  can  be  sent  to  the  current  page,

POSTSCRIPT must  be  told  what  typeface  and  size  to  use  in  theprinting. That is, you must specify the font.

5.1  POSTSCRIPT FONTS

A font is  a  collection  of  characters  with  a  unified  design.  Thedesign  itself  is  referred  to  as  a typeface.  A  set  of  typefaces

designed to work together in a pleasing way is called a typefacefamily.

There are hundreds of typeface families, including such familiarones as Times and Helvetica.

35

    

The  typefaces  within  each  family  represent  variations  on  thetheme set by the family's design. Thus, within the Times family,Roman
ItalicBold
ExtendedCondensed
Obliqued

we have Times Roman, Times Italic, Times Bold, and so on. Thevariety of possible faces within a family is endless and includes
typefaces that are extended, condensed, extra-bold, and obliqued.
A font is a particular implementation of a typeface. The standardP

OSTSCRIPT fonts are geometrical descriptions of the outlines ofa  typeface's  characters.  These  descriptions  allow  the  font  to  be

printed on paper at any scale with minimum distortion from thescaling process.

Using POSTSCRIPT Fonts
Before  you  can  print  text,  you  must  specify  the  desired  font.There are three steps to this process:

1. Find the information describing the font.  This informationis kept in a font dictionary, which contains the information

necessary to produce a particular font, including the outlinedescription  of  each  character.  For  more  information  on
font  dictionaries,  refer  to  chapter  eight  of  this  tutorial  andto the P

OSTSCRIPT Language Reference Manual.

2. Scale the font to the size needed.  The size is specified bythe minimum vertical separation necessary between lines of

text.  Thus,  a  twelve-point  font  needs  twelve  points  be-tween  successive  lines  of  text  to  ensure  the  lines  do  not
interfere  with  each  other.   (Remember  that  a  point  is 1/72inch.)

3. Establish  the  scaled  font  as  the current  font,  in  which  alltext is to be printed.

To see how this is done, let us examine the following program,which prints the word typography in 15-point Times Roman.

/Times-Roman findfont15 scalefonttypography
setfont72 200 moveto
(typography) showshowpage

There are several new operators here.

36 Chapter 5:  PRINTING TEXT

    

In the first line we put the literal name Times-Roman on the stackand then call the findfont operator.

/Times-Roman findfont
findfont looks up the name in a dictionary called FontDirectoryand places the appropriate font dictionary on the stack.

The  font  dictionary  returned  by  the findfont operator  containscharacter shape descriptions for one-point characters. These must

be changed to the  desired  font size  with the scalefont operator.This  operator  takes  a  font  dictionary  and  a  number  from  the
stack,  and  returns  the  font  dictionary  scaled  by  the  specifiedamount.

Thus, our program's second line

15 scalefont
will leave on the stack a dictionary for a 15-point Times Romanfont.

Finally,  the setfont operator  takes  the  font  dictionary  off  thestack and establishes it as the current font, to be used for printing

text.
Now we are ready to print something.
We  use  the moveto operator  to  set  the  current  point.  Then  weplace the string typography on the stack (enclosed in parentheses

to denote it as a string), and call the show operator.

72 200 moveto(typography) show

show prints the string that is on the stack onto the current pagestarting at the current point. The current point is left at the end of
the text.

5.1  POSTSCRIPT FONTS 37

   

5.2  PRINTING VARIETY

Point Sizes
The fact that POSTSCRIPT internally describes its fonts as shapedescriptions  allows  the  fonts  to  be  scaled  while  retaining  their

fidelity  at  large  sizes.  For  example,  consider  the  followingprogram:

/showGorilla % stack: x y ---Gorilla
Gorilla
Gorilla
Gorilla

{ moveto (Gorilla) show }def/Times-Roman findfont  6 scalefont  setfont
72 300 showGorilla/Times-Roman findfont  10 scalefont  setfont
72 275  showGorilla/Times-Roman findfont  15 scalefont  setfont
72 250  showGorilla/Times-Roman findfont  20 scalefont  setfont
72 225 showGorilla
showpage
This  program  prints  the  word Gorilla in  four  different  sizes  ofTimes  Roman.  We  first  define  a  procedure  called showGorilla,

which moves to a position specified on the stack and then printsthe string.

/showGorilla % stack: x y ---{ moveto (Gorilla) show }def
The procedure is followed by a set of lines that repeatedly finds,scales, and sets a Times Roman font and then calls showGorilla.

/Times-Roman findfont  6 scalefont  setfont72 300 showGorilla
Note  that  this  program  could  also  be  written  with  a  proceduredefined to handle the font changes:

38 Chapter 5:  PRINTING TEXT

    

/showGorilla % stack: x y{ moveto (Gorilla) show }def
/scaleTimes % stack: scale{ /Times-Roman findfont

exch scalefont %scale, using # on stksetfont } def

6 scaleTimes72 300 showGorilla
10 scaleTimes72 275  showGorilla
15 scaleTimes72 250  showGorilla
25 scaleTimes72 225 showGorilla

showpage
The scaleTimes procedure defined above sets the current font toTimes  Roman  at  a  point  size  obtained  from  the  stack.  The  first

line of the scaleTimes definition retrieves the font dictionary forTimes Roman.

/Times-Roman findfont
The stack now has this dictionary on top and the scale we wantbelow  it.  (We  placed  the  font  dictionary  on  the  stack  when  we

called  the  procedure.)  We  exchange  these  two  objects  and  callthe scalefont and setfont operators.

exch scalefontsetfont
The current font becomes Times Roman at the desired point size.
Typefaces
The  following  program  demonstrates  the  POSTSCRIPT standardtypefaces.

5.2  PRINTING VARIETY 39

             

%-------- Define Procedures ------------/vpos  720 def % vertical position variable
/word  (Typefaces) def % string variable
/choosefont % Stack: typeface-name{ findfont 15 scalefont setfont} def

/newline{/vpos vpos 15 sub def %decrease vpos

72 vpos moveto } def %go to that line
/printword %stk: typeface-name{ choosefont %set font

word show %show "typefaces"newline } def %go to next line
%------------ Begin Program -----------------TypefacesTypefaces

TypefacesTypefaces

TypefacesTypefaces
TypefacesTypefaces

TypefacesTypefaces
TypefacesTypefaces

Typefaces

72 vpos moveto %vpos starts as 720/Times-Roman  printword
/Times-Bold  printword/Times-Italic  printword
/Times-BoldItalic  printwordnewline
/Helvetica  printword/Helvetica-Bold  printword
/Helvetica-Oblique  printword/Helvetica-BoldOblique  printword
newline/Courier  printword
/Courier-Bold  printword/Courier-Oblique  printword
/Courier-BoldOblique  printwordnewline
/Symbol  printwordshowpage

This program is more elaborate than our earlier ones. We start bydefining two variables and three procedures.
The  variable vpos is  used  to  keep  track  of  the  current  point'svertical  position.  The  program  uses  this  variable  as  the y argument of a moveto.
Word holds the string that we want our program to print. It willbe used by a show operator.

40 Chapter 5:  PRINTING TEXT

    

The choosefont procedure

/choosefont % Stack: typeface-name{ findfont 15 scalefont setfont} def

sets the current font to that named on the stack. Newline movesthe  current  point  down  fifteen  points  by  decreasing vpos and
using it with a moveto.

/newline{/vpos vpos 15 sub def

72 vpos moveto } def
The printword procedure sets the current font, using choosefont,prints the value of the variable word, and then moves the current

point to the beginning of the next line, using newline.

/printword %stk: typeface-name{ choosefont

word shownewline } def

After  defining  its  variables  and  procedures,  the  program  movesthe  current  point  to  a  starting  position  on  the  current  page  and

then uses printword with nine different typefaces.

/Times-Roman  printword/Times-Bold  printword
/Times-Italic  printword/Times-BoldItalic  printword
newline
Note  that  the  typeface  families  are  separated  by  calls  to  thenewline procedure.

Graphics and Text
POSTSCRIPT makes no  distinction  between  text and  graphics. Atext  character  is  simply  another  graphic  object  to  be  placed  on

the current page. Thus, no special steps need to be taken to com-bine text and graphics on an output page.

Let us end this chapter with an example that illustrates this point.We shall design and print a business card for the world-famous

Diamond Cafe.

5.2  PRINTING VARIETY 41

    

This will be a standard-size business card (two inches by three-and-a-half)  and  will  have  a  printed  border  1/8  inch  in  from  the

card's edges. We shall print the name of the cafe in bold type atthe  top  left  of  the  card  with  the  cafe's  slogan  ("The  Club  of
Lonely Hearts") in italics below it. In the lower-right corner willbe the name of the cafe's owner. Behind the text, we shall print a

Diamond Cafe

"The Club of Lonely Hearts"

Sam Spade
Owner

light gray diamond.

%---------------- Variables ------------------/MainFont

/Helvetica-Bold findfont 15 scalefont def/SloganFont
/Helvetica-Oblique findfont 7 scalefont def/OwnerFont
/Helvetica findfont 10 scalefont def%---------------- Procedures -------------------
/rightshow % stk: string{ dup stringwidth pop %get length of string

120 exch sub %calc. white space0 rmoveto %Move over that much
show } def %show string

42 Chapter 5:  PRINTING TEXT

  

/CardOutline %Print card's outline{ newpath

90 90 moveto0 144 rlineto
252 0 rlineto0 -144 rlineto
closepath.5 setlinewidth
stroke } def/doBorder %Print card's border
{ 99 99 moveto0 126 rlineto %Border: 126 pts high

234 0 rlineto %  & 234 points wide0 -126 rlineto
closepath2 setlinewidth %2-point-wide line
stroke } def/Diamond
{ newpath %define & fill207 216  moveto % a diamond-shaped

36 -54  rlineto % path-36 -54  rlineto
-36  54  rlinetoclosepath

.8 setgray  fill } def/doText %Print card's text
{ 0 setgray  90 180 movetoMainFont setfont

(Diamond Cafe) rightshow90 168 moveto
SloganFont setfont("The Club of Lonely Hearts") rightshow
216 126 movetoOwnerFont setfont
(Sam Spade) show216 111 moveto
(Owner) show } def%---------- Main Program ------------
CardOutlinedoBorder
DiamonddoText

showpage

5.2  PRINTING VARIETY 43

    

This program defines several variables and procedures and thenuses them to make the card. The steps taken in printing the card
are  suggested  by  the  procedure  calls  at the  end  of  the  program.The  card's  outline  is  drawn,  followed  by  the  border,  the  gray
diamond, and the text.
Any  POSTSCRIPT object  can  be  assigned  to  a  variable.  Thisprogram uses three variables whose values are font dictionaries.

Each  of  these  variables  holds  the  information  needed  toreproduce characters in a particular font. All the program needs
to do to change fonts is place the value of the desired variable onthe stack and call the setfont operator.

Let's examine the definition of the MainFont. We first place thename of the variable on the stack as a literal, preceded by a slash:

/MainFont
We then put the font dictionary for the Helvetica Bold typefaceon the stack

/Helvetica-Bold findfont
and scale it to a point size of fifteen.

15 scalefont
The scalefont operator  leaves  the  newly-scaled  font  dictionaryon top of the stack with our variable name still residing beneath

it.  The def operator  places  these  two  objects  into  the  user  dic-tionary, with MainFont as the key and the font dictionary as that
key's value.

/MainFont/Helvetica-Bold findfont 15 scalefont def

The  other  two  variables, SloganFont and OwnerFont aresimilarly defined.
Assigning scaled font dictionaries to variables is a good practicein programs that frequently change fonts. Finding and scaling a

font dictionary is a relatively time-consuming task. If a programdoes this once for each font and saves the result as a variable, it
will  run  much  more  quickly  than  if  it  calls  the findfont andscalefont operators for each font change.

44 Chapter 5:  PRINTING TEXT

    

Five procedures are defined in this program.
Rightshow prints a right-justified string (taken from the stack) ina 120-point-wide space. The first line of this procedure's definition

dup stringwidth pop
introduces a new operator: stringwidth.
stringwidth takes a string from the top of the stack and replacesit  with  the  horizontal  and  vertical  distances  the  current  point

would be moved if the string were shown in the current font. They offset is left on top of the stack, with x below it. Thus, the line
above duplicates the string on the stack, replaces the top copy ofthe  string  with  the x and y offsets,  and  then  drops  the y offset
from the stack. The stack is left with the string's width on top ofthe stack and the string itself below.

The procedures CardOutline, doBorder, and Diamond all defineclosed paths. CardOutline and doBorder stroke their paths onto

the current page, while Diamond fills its path with gray.
Finally, doText prints  the  card's  lettering  in  a  succession  ofmovetos, setfonts, and rightshows. Note that the different fonts

are  set  by  calling  one  of  the  font-dictionary  variables  and  thensetfont.

5.2  PRINTING VARIETY 45

     

5.3  OPERATOR SUMMARY

Character and Font Operators
findfont key Th fdict

Return dictionary for named font

scalefont fdict n Th fdict

Return new scaled font dictionary

setfont fdict Th --

Set current font

show str Th --

Print str on the current page

stringwidth str Th x y

Return width of str

46 Chapter 5:  PRINTING TEXT

    

CHAPTER 6
MORE GRAPHICS

6.1  COORDINATE SYSTEMS

POSTSCRIPT graphics  operators  do  their  work  within  a  coordi-nate  system  refered  to  as  the user  coordinate  system or user

space.  This  system  is  independent  of  any  physical  device;P

OSTSCRIPT operators  draw  in  user  space  and  the  result  isautomatically  transferred  to  the device  coordinate  system of  a

particular printer, that is, to device space.
In  our  programs  so  far,  we  have  been  using  the  POSTSCRIPTdefault coordinate system. In this default user space, the origin is

in the lower-left-hand corner of the current page and the unit ofmeasure is the P

OSTSCRIPT unit of 1/72 inch.

User space is malleable, however. Its coordinate system may bechanged in position, orientation, and size.

Translating User Space

Translation

Translation is movement from one place to another.  In the caseof a coordinate system, it refers to movement of the origin. The

POSTSCRIPT translate operator moves the origin of user space tothe  position  specified  on  the  stack.  For  example,  the  program
line

47

    

100 200 translate
would move the origin of the POSTSCRIPT coordinate system tothe  point (100,200). All  future  positions  will  be  measured  from

this point on the current page.
The following program illustrates the effects of translate.

/Times-Roman findfont 30 scalefont setfont

A Box

A Box

A Box

Translated Squares

/square %procedure to draw a{ newpath %  filled square

0 0 moveto90 0 lineto %define a square path
90 90 lineto0 90 lineto
closepath  fill %fill it6 92 moveto % & label it
(A Box) show  } def
square %do a square200 250 translate %move coord. sys.
square %do another square200 250 translate %and move again
square %do a third square
showpage
The  procedure  defined  in  this  program  draws  a  block  whoselower left corner is at the origin of the current coordinate system.

We  obtained  three  different  blocks  in  this  program,  not  bychanging  the  position  of  each  box,  but  by  translating  the  origin
of  the  coordinate  system  on  the  current  page.  Note  that  thesecond  translation  was  relative  to  the  already-once-translated
origin, not the default origin.
Thus, there are two ways of drawing an object in several places.You can change the position of the object each time, substituting

new coordinates where necessary, or you can construct the objectat the same coordinates and move the coordinate system.

48 Chapter 6:  MORE GRAPHICS

     

Rotation
The  POSTSCRIPT user  coordinate  system  may  also  be  rotated.

Rotation

The rotate operator  takes  a  number  from  the  stack  and  rotatesthe coordinate axes that many degrees counterclockwise.

Let us again write a program that draws a box three times, transA Box

A Box

A Box

Rotated Squares

lated as before, but this time also rotated.

/Times-Roman findfont 30 scalefont setfont
/square %procedure from{ newpath % previous program

0 0 moveto90 0 lineto
90 90 lineto0 90 lineto
closepath  fill6 92 moveto %Label the box
(A Box) show  } def
square %do a square300 150 translate %move coord. sys.
60 rotate %and rotate itsquare %do it again...
300 150 translate60 rotate
square %do a third square
showpage
Again, we changed the position and orientation of the square bychanging  the  coordinate  system  within  which  that  square  is

defined. The actual definition of the square is unchanged.

Scaling

PS
1  1  scale

PS
1.25  1.25  scale

PS

2  .5  scale

The scale operator  allows  you  to  change  the  size  of  the  unitsused  by  P

OSTSCRIPT.  This  operator  takes  two  arguments  fromthe stack, an x and y scaling factor, and changes the size of the

coordinate system's units by those factors. For example,

6.1  COORDINATE SYSTEMS 49

   

3  3  scale
will triple the size of the coordinate system's units; objects willbe  drawn  three  times  as  large  as  they  would  have  been  before

this command was executed.
Again, our box program:

/Times-Roman findfont 30 scalefont setfont

A Box

A Box

A Box

Scaled Squares

/square %procedure to draw a{ newpath % filled square

0 0 moveto90 0 lineto
90 90 lineto0 90 lineto
closepath  fill6 92 moveto %Label the box
(A Box) show  } def
square %do a square100 100 translate
1.5 1.5 scalesquare
100 100 translate.75 1.25 scale %non-uniform scaling
square
showpage
Notice that the second scaling was non-uniform; we scaled the xand y dimensions by different factors, making our square (and its

label) appear narrow and tall.

6.2  GRAPHICS STATE

In our programs so far, we have been implicitly working within agraphics  state,  the  set  of  data  that  describes  how  P

OSTSCRIPToperators  will  affect  the  current  page.  Among  the  information

that  makes  up  the  current  graphics  state  are  the  current path,point, gray value, font, line width, and user coordinate system.

For  a  complete  description  of  the  graphics  state,  refer  to  theP

OSTSCRIPT Language Reference Manual.

50 Chapter 6:  MORE GRAPHICS

     

Saving the Graphics State
There are times when we would like to save the current graphicsstate so that we can return to it at a later time.

For example, if we want to print a filled and outlined shape, such

as the one at left, we would have to construct a suitable path andthen fill it. Unfortunately, the fill operator clears the current path,

leaving us with no path to stroke. It would be useful to save thecurrent graphics state immediately before performing the fill and
then  restore  the  graphics  state  afterwards,  recovering  the  pathwhich could then be stroked.

The operators that save and retrieve the current graphics state aregsave and grestore. The gsave operator saves a copy of the current graphics state on a graphics state stack. This stack can holdup  to  thirty-two  graphics  states,  including  the  current  graphics
state.
The grestore operator restores the most recently gsaved graphicsstate.  All  of  the  characteristics  of  the  current  graphics  state,  including the current path, gray value, line width, and user coordi-nate  system,  are  returned  to  what  they  were  when  the gsave
operator was called.
Let us demonstrate the use of these operators with a program thatdraws a five-pointed star, filled and outlined.

/starside{ 72 0 lineto %add line to path

currentpoint translate %move origin-144 rotate } def %rotate coord. sys.
/star %stack: x y

Star

{ movetocurrentpoint translate

4 {starside} repeatclosepath
gsave.5 setgray fill
grestorestroke } def

6.2  GRAPHICS STATE 51

     

200 200 star
showpage
We have defined two procedures in this program. Starside drawsone  of  the  lines  that  make  up  the  star; star draws  a  filled,  outlined  star  whose  upper  left  point  has  the x and y coordinatesspecified on the stack.

72  0  lineto

currentpoint  translate

The starside procedure  starts  out  by  adding  a  horizontal  line  tothe current path:

72  0  lineto
It  then  introduces  a  new  operator, currentpoint,  which  pushesthe x and y coordinates  of  the  current  point  on  the  stack.  The

program line

currentpoint  translate
thus  puts  the  coordinates  of  the  current  point  on  the  stack  andthen moves the origin of user space to that position. The origin is

moved to the end of the line segment we just added to our path.
The starside procedure then rotates the current coordinate system144 degrees clockwise.

-144 rotate

-144  rotate (Note  the  negative  argument;  positive  angles  are  measuredcounterclockwise.) This rotation reorients the x-axis in the direction of the next side of the star.

The star procedure also introduces a new operator, repeat.

4 {starside} repeat
This operator requires two arguments: a number (4, in this case)and a set of operations enclosed in curly braces (here consisting

of  the  procedure starside).  The  operations  are  carried  out  thenumber  of  times  specified  by  the  first  operand.  The  line  above
will thus perform the starside procedure four times.
This line is followed by  a closepath,  which  completes the star-shaped path.

52 Chapter 6:  MORE GRAPHICS

    

We then fill in the star:
4  {starside}  repeatclosepath

fill
grestore

stroke

gsave.5 setgray fill
grestore
Before  we  fill  the  star,  we  use  the gsave operator  to  copy  thecurrent  state  on  the  graphics  state  stack.  This  is  necessary  because we want to use the current path twice: once to fill and onceto stroke. Having saved the graphics state, we set the gray level
to .5 and fill the path. fill clears the current path. When we callgrestore,  the  graphics  state  we  duplicated  earlier  is  restored  as
our  current  graphics  state,  returning  the  star-shaped  path  and  agray value of 0.

The star procedure then strokes the resurrected current path.
The main part of our program is only two lines long:

200 200 star
showpage
This pushes 200 on the stack twice (as x and y coordinates) andcalls  the star procedure,  constructing  a  star  beginning  at  that

point. The showpage operator then commits the contents of thecurrent page to paper.

6.3  CURVES

Generally,  graphic  images  are  not  composed  exclusively  ofstraight  line  segments.  To  accomodate  this,  there  are

POSTSCRIPT operators to construct any desired curve. In this sec-tion, we shall discuss curves that are circular arcs. More complex
curves may be defined using such operators as curveto (see theP

OSTSCRIPT Language Reference Manual).

The arc operator  adds  a  circular  arc  to  the  current  path.  It  re-quires five arguments on the stack: the x and y coordinates of the

arc's  center  of  curvature,  the radius of  curvature,  and  the  arc'sbeginning  and  ending angles measured  counterclockwise  from
the positive x axis. Thus, the program line

6.3  CURVES 53

    

100  150  36  45  90  arc
would  produce  an  arc-shaped  path  on  the  current  page  with  acenter  100  units  to  the  right  and  150  units  above  the  origin,  a

radius  of  36  units,  extending  counterclockwise  from  45  to  90100  150  36  45  90  arc
degrees (see illustration at left).
The arcn operator is similar to arc, differing only in that it con-structs an arc in a clockwise direction. The line

100  150  36  45  90  arcn
produces a path shaped like that at left.
The arc and arcn operators alter their behaviors slightly if a cur-100 150  36  45  90  arcn

rent point already exists when the operator is called. In this case,the operator will draw not only the specified arc, but also a line

segment  connecting  the  current  point  and  the  beginning  of  thearc.

The following program illustrates this change by drawing similararcs, first without and then with a current point.

Two arcs

newpath300  400  54  40  140  arc  stroke
newpath300 365 moveto
340  345  54  40  140  arc  stroke
showpage
In the first case, no current point exists; the arc is simply drawnonto the current page as specifed. Before drawing the second arc,

however,  we  moved  the  current  point  to  the  position 340,365;this  time,  the arc operator  drew  a  line  connecting  our  current
point to the beginning of the arc.

54 Chapter 6:  MORE GRAPHICS

    

Circles and Ellipses
A  circle  is  an  arc  extending  from  0  to  360  degrees.  An  ellipsecan  be  constructed  by  nonuniformly  scaling  the  coordinate  system and then drawing a circle.
The program below draws a series of ellipses.

Ellipses

/doACircle{ 0 0 54 0 360 arc stroke } def
/doAnEllipse{ 1 .75 scale

doACirclestroke } def

300 500 translate  doACircle
4 {0 -72 translatedoAnEllipse} repeat

showpage
We begin by defining two procedures, doACircle, which draws acircle  54  units  in  radius  with  its  center  at  the  origin,  and

doAnEllipse, which draws an ellipse by scaling the y-dimensionto three-quarters the x and then drawing a circle.

6.3  CURVES 55

    

The program translates the origin to a position above the middleof  the  page  and  draws  a  circle.  Then  the  program  does  the  following operations four times, using a repeat operator:

1. Move the coordinate origin down one inch (72 units).
2. Draw an ellipse onto the current page.

Note  that  although  our  loop  specifies  a  one-inch  distance  be-tween  the  ellipses'  centers,  the  ellipses  are  not  drawn  one  inch

apart.  This  is  because  they  are  offset  72  points  as  measured  inthe current coordinate system, whose y-direction is scaled down
by each ellipse.
Note  also that  although we only specify  a  scaling factor of .75,the y axis  becomes  scaled  much  more  than  this  during  the

program.  Each  ellipse  scales  the current coordinate  system,which  may  already  be  scaled.  Each  ellipse  reduces  the  vertical
direction to three-quarters of what it was before.

Rounding Corners
Intersecting lines are frequently connected by round corners. TheP

OSTSCRIPT arcto operator offers a convenient way to do this.

The  operator  requires  two  points  and  a  radius  on  the  stack.  Itdraws a line segment from the current point toward the first point

listed  on  the  stack.  This  segment  terminates  in  an  arc  with  thespecified  radius  whose  end  is  tangent  to  the  line  segment  connecting the two  points  specified on  the  stack  (see  illustration  atleft).  The  operator  returns  with  the  stack  holding  the x and y
coordinates of the beginning and end of the arc.
This  becomes  much  clearer  with  an  example.  The  followingprogram  draws  a  small x at  each  of  three  points,  moves  to  the

first of these, and then uses the other two points as arguments to

r
currentpoint

x1,y1

x2,y2

x1  y1  x2  y2  r  arcto

arcto.

56 Chapter 6:  MORE GRAPHICS

     

/DrawAnX{ 3  3  rmoveto -6 -6  rlineto

0  6  rmoveto  6 -6  rlinetostroke } def

arcto

50 50 moveto DrawAnX50 150 moveto DrawAnX
150 150 moveto  DrawAnX
50 50 moveto50 150  150 150  36 arcto
4 {pop} repeatstroke

showpage
The results of this program are shown at left. After drawing thethree X's,  the  program  moves  the  current  point  to 50,50,  the

lower  left  point.  The arcto operator  then  starts  drawing  a  linesegment  toward 50,150 (in  the upper left). Instead  of  extending
up  to  the  point,  the  line  segment  ends  with  an  arc  of  radius 36that terminates tangent to the line connecting the top two points
in the diagram. The current point is left at the end of the arc.
Note  that  the arcto operator  leaves  the  stack  holding  the  num-bers 50,  114,  86, and 150,  which  represent  the  beginning  and

endpoint of the arc. Since we do not need these values, we dropthem from the stack with a repeated pop operator.

4 {pop} repeat
Printing a Logo
Let  us  use  our  curve-generating  operators  to  print  a  logo  for  amovie named Omaha. This movie dwells on the loneliness of the

Plains during the early nineteenth century and so its logo will berather  stark,  consisting  of  a  black  background  with  the  word
"Omaha"  rising  from  below  and  a  gray  circle,  representing  thefull moon, behind.

6.3  CURVES 57

      

% ------------ Define Procedures -------------
OMAHA

/Helvetica-Bold findfont  27 scalefont setfont
/fourpops{ 4 {pop} repeat } def

/background %Black background{ 0 18 moveto % with rounded corners

0 72  108 72  18 arcto fourpops108 72  108 0  18 arcto fourpops
108 0  0 0  18 arcto fourpops0 0  0 72  18  arcto fourpops
fill } def/moon
{ .6 setgray % set gray level81 45 18 0 360 arc fill % draw a circle

} def % end of definition
/omaha{ 1 setgray

0 -1 moveto1 2 scale % double y-scale
(OMAHA) stringwidth pop % width of word108 exch sub 2 div % calc. indentation
0 rmoveto % indent(OMAHA) show } def % & print
% ------------ Begin Program -----------------255 465 translate

backgroundmoon
omaha
showpage
This  program  follows  the  usual  pattern  of  defining  a  series  ofprocedures and then later calling them in sequence at the end of

the source code.
The  first  three  procedures  are  reasonably  straightforward.Fourpops drops four objects from the stack; this is used after the

arcto operator  to  remove  the  coordinates  left  on  the  stack.  Thebackground procedure  uses  four arcto's  to  construct  a  rectan58 Chapter 6:  MORE GRAPHICS

   

gular  path  with  rounded  corners  and  then  fills  the  path. Moonconstructs a circular path and fills it with gray.
The omaha procedure  prints  that  name  in  white  capital  lettersagainst the black background. Note that the line

1  2  scale
doubles  the  vertical  scale  of  the  coordinate  system  in  use.  Thismakes our letters taller than they would be otherwise. The lines

(OMAHA) stringwidth pop108 exch sub 2 div
0 rmoveto
calculate the indentation needed to center the string OMAHA onthe  background.  The  first  of  these  lines  determines  the  printed

width of the string; the second and third lines subtract this widthfrom the total width of the background (108 units) and move half
that amount to the right.

6.3  CURVES 59

     

6.4  OPERATOR SUMMARY

Control Operators
repeat n proc Th --

Execute proc n times

Coordinate Systems Operators
rotate angle Th --

Rotate user space angle degrees counterclockwise about origin

scale x y Th --

Scale user space by x horizontally and y vertically

translate x y Th --

Move origin of user space to (x,y)

Graphics State Operators
grestore -- Th --

Restore graphics state from matching gsave

gsave -- Th --

Save current graphics state

Path Construction Operators
arc x y r ang ang Th --1 2

Add counterclockwise arc to current path

arcn x y r ang ang Th --1 2

Add clockwise arc to current path

arcto x y x y r Th xt yt xt yt1 1 2 2 1 1 2 2

Build tangent arc

currentpoint -- Th x y

return coordinates of current point

60 Chapter 6:  MORE GRAPHICS

    

CHAPTER 7

The POSTSCRIPT language has many operators for specifying theflow  of  control  within  a  program.  We  used  one  of  these,  the

repeat operator, in the previous chapter. All POSTSCRIPT controloperators make use of an object type which we briefly mentioned
before, the executable array, a more formal name for the objectwe have been calling a procedure.

Executable Arrays
An executable array, that is, a POSTSCRIPT procedure, is an arraywhose  contents  are  to  be  executed  by  the  P

OSTSCRIPT inter-preter.

When  the  interpreter  encounters  a  series  of  objects  (values  andnames)  in  a  program,  it  carries  out  the  actions  appropriate  to

those  instructions,  placing  objects  on  the  stack  and  looking  upand executing operators and procedures.

However,  if  a  series  of  objects  is  enclosed  in  braces,  it  is  notimmediately executed, but is stored in an array and placed on the

stack. Thus, the line

86 23 add
causes  the  interpreter  to  add  the  numbers 86 and 23 together,while the line

61

      

{86 23 add}
places  the  numbers  and  the  operator add in  an  array,  which  isthen  placed  on  the  stack.  An  executable  array  will  often  be

preceded by a literal name and followed by a def operator, whichassociates it with the name in the current dictionary. (This is how
named procedures are defined.)
An executable array may also be used as an argument for a con-trol  operator,  such  as repeat.  In  this  case,  the  executable  array

holds the operations that are to take place when the conditions ofthe control operator are met.

7.1  CONDITIONAL EXECUTION

Comparisons
The POSTSCRIPT language has a full set of comparison operators.These compare the top two items on the stack, which can be of

any matching type, and return an object of type boolean, a trueor false,  on  the  stack.  The  P

OSTSCRIPT comparison  operators,and their equivalent mathematical symbols, are:

* eq = * ne z'

* gt > * lt <

* ge >= * le <=
The boolean results of the above operators can be used with theP

OSTSCRIPT logical operators not, and, or, and xor.

The if Operator
The if operator  takes  a  boolean  object  and  an  executable  arrayfrom  the  stack  and  carries  out  the  operations  in  the  array  if  the

boolean  value  is true.  Thus,  we  could  define  a  procedure  for  atext  formatter  that  would  check  to  see  if  the  end  of  the  current
line had been reached:

62 Chapter 7:  LOOPS AND CONDITIONALS

    

/chkforendofline{ currentpoint pop %get x-position

612 gt %greater than 612?{0 -12 translate  0 0 moveto} if
} def
This  procedure  obtains  the  position  of  the  current  point  andthrows away the y coordinate. It then compares the remaining x

coordinate  to  see  if  it  is  beyond  the  right  edge  of  the  currentpage. If so, it carries out a set of operations that moves the coordinate origin and current point to the beginning of the next line.
Let us write a program that will do very simple formatted print-ing of a series of strings. This program contains a procedure that

takes a string off the stack, checks to see if that string will fit onthe  current  line,  moves  to  a  new  line,  if  necessary,  and  then
prints the string.

% -------------- Variables ---------------/LM 72 def %left margin
/RM 216 def %right margin/ypos 720 def %current y-position
/lineheight 14 def %distance between lines%  of text
% ------------- Procedures ---------------/newline %move to next line

{ ypos lineheight sub %decrease ypos/ypos exch def %...& save new value

LM ypos moveto } def %move to next line
/prtstr %stack: str{ dup stringwidth pop %calc. length of string

currentpoint pop %get horiz. positionadd  RM  gt %sum > right margin?
{newline} if %if so, next lineshow } def %print string

7.1  CONDITIONAL EXECUTION 63

    

%------------- Main Program --------------/Times-Italic findfont  13 scalefont setfont
If you tell the truth, you don't have to remember 
anything.  - Mark Twain  LM ypos moveto(If ) prtstr  (you ) prtstr (tell ) prtstr

(the ) prtstr  (truth, ) prtstr (you ) prtstr(don't ) prtstr  (have ) prtstr  (to ) prtstr

(remember ) prtstr  (anything.  ) prtstr(- Mark ) prtstr  (Twain ) prtstr

showpage
Three  variables  are  defined  here. LM and RM are  the  left  andright margins, repectively, within which the text is to be printed.

Ypos is the vertical position of the current line on which text isbeing  printed. Lineheight is  the  vertical  distance  that  will
separate lines of text.
The procedure newline moves the current point to the beginningof  the  next  line.  It  decreases ypos by lineheight,  defining  the

result to be the new value of ypos:

ypos lineheight sub/ypos exch def

It then moves the current point to the left margin at the verticalposition determined by ypos.

LM  ypos  moveto
The second procedure defined in this program, prtstr, checks tosee if the string on the stack will fit on the current line, moves to

the next line, if appropriate, and prints the string.
The  procedure  first duplicates  the  string  to  be printed,  and  thencalculates  its  length  by  using stringwidth and  dropping  the y

value.

dup stringwidth pop
The  procedure  then  determines  the x position  of  the  currentpoint.

currentpoint pop

64 Chapter 7:  LOOPS AND CONDITIONALS

     

These two values are added and the sum is compared to the rightmargin to see if the word would run beyond the margin.

add  RM  gt
If  so,  the newline procedure  is  called.  In  either  case,  the  string,still on the stack, is printed.

{newline} ifshow
In the main part of the program, the current point is moved to itsbeginning  position  and  then  the  text  is  printed,  one  word  at  a
time.
This  is  a  very  primitive  text  formatter,  unable  to  parse  lines  oftext  into  words.  A  more  sophisticated  formatter  is  presented  in

the POSTSCRIPT Language Cookbook.

The ifelse Operator
The  second  POSTSCRIPT conditional  operator  requires  three  ob-jects  on  the  stack:  a  boolean  value  and  two  executable  arrays.

The first array placed on the stack will be executed if the booleanvalue  is  true;  the  second  array  will  be  executed  if  the  boolean
object is false. That is, the program line

bool  {op1} {op2}  ifelse
will execute op1 if bool is true and op2 otherwise.
The program below uses the ifelse operator to produce a stack ofoverlapping trapezoids of alternating gray shade and decreasing

height.  The  height  is  varied  by  changing  the  vertical  scale  foreach  trapezoid  as  determined  by  the  variable scalefactor.  The
gray  shade  is  alternated  by  counting  the  trapezoids  as  they  areconstructed and filling even trapezoids with gray and odds with
black.  The  variable counter holds  the  number  of  the  currenttrapezoid.

7.1  CONDITIONAL EXECUTION 65

    

% ------- Variables & Procedures ---------/scalefactor 1 def
/counter 0 def/DecreaseScale

{ scalefactor .2 sub/scalefactor exch def } def

/IncreaseCounter{ /counter counter 1 add def } def
/trappath %construct a trapezoid{ 0 0 moveto  90 0 rlineto

-20 45 rlineto -50 0 rlinetoclosepath } def

/doATrap{ gsave

1 scalefactor scale %scale vert. axistrappath %construct path
counter 2 mod %is counter even?0 eq {.5} {0} ifelse %choose grey or black
setgray  fillgrestore } def %restore scale, etc.
% ------------ Begin Program ----------250 350 translate

5{IncreaseCounter

doATrapDecreaseScale
0 20 translate } repeat
showpage
The  procedures DecreaseScale and IncreaseCounter do  whattheir  names  imply,  the  former  decreasing scale by  .2,  the  latter

increasing counter by 1.
The trappath procedure  constructs  a  trapezoidal  path  with  itslower  left  corner  at  the  origin.  Successive  trapezoids  are  offset

by translating the coordinate system.

66 Chapter 7:  LOOPS AND CONDITIONALS

    

Finally, the doATrap procedure scales the current coordinate sys-tem, constructs a trapezoidal path (using trappath), and then calculates counter modulo 2.

1 scalefactor scaletrappath
counter 2 mod
The modulo operation will yield a 0 if counter is even and a 1 ifcounter is odd.

We then use the ifelse operator.

0 eq {.5} {0} ifelsesetgray  fill

We  test  the  results  of  the mod operation,  place  two  executablearrays (holding alternative values for setgray) on the stack, and
call  the ifelse operator.  The ifelse operator  executes  one  of  theexecutable arrays, causing either a .5 or a 0 to be placed on the
stack,  depending  on  whether  the  result  of  the eq operator  wastrue or false. DoATrap then  calls  the setgray operator  and  fills
the current path.
After  defining  the  necessary  procedures,  the  program  translatesto a point below the center of the current page and implements a

repeat loop  that  repeatedly  increases counter and  prints  atrapezoid, and then prepares for the next trapezoid by decreasing
scale and translating the origin.

5{IncreaseCounter

doATrapDecreaseScale
0 20 translate } repeat

7.2  LOOPS

There are three POSTSCRIPT operators for establishing and con-trolling  program  loops.  We  have  already  used  the repeat

operator. The for operator controls an indexed loop similar to theFor...To...Next structures  in  other  languages;  the loop and exit
operators implement an indeterminate loop that continues until aspecified condition is met.

7.2  LOOPS 67

      

The for Operator
The POSTSCRIPT for operator implements a counting loop. Thisoperator  takes  four  operands:  the  loop  counter's  starting  value,

increment  amount,  and  final  value,  and  the  procedure  to  berepeated. The for operator places the current value of the counter
on the stack immediately before each execution of the procedure.
For  example,  the  following  program  line,  embedded  in  theproper  program,  would  cause  the  letter  "k"  to  be  printed  every

twelve units across the page:

0 12 600 {0 moveto (k) show } for
Each multiple of twelve from zero to 600 will be pushed onto thestack and the set of operations run.

The numeric operands of for need not be integers. Consider thefollowing program:

/Times-Italic findfont  30 scalefont setfont
/printZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZipZip

{ 0 0 moveto  (Zip) show} def320  400  translate

.95 -.05  0 % start  incr.  end{setgray  printZip -1 .5 translate } for
1 setgray printZip
showpage
This program starts by establishing a 30-point Times Italic as thecurrent  font.  The  procedure printZip is  then  defined  and  the

origin of the current coordinate system is moved to the middle ofthe current page.

We  then  begin  a for loop.  The  numbers .95, -.05,  and 0 areplaced on the stack, followed by the executable array

{setgray  printZip -1 .5 translate}
The for operator  repeats  these  operations  for  each  value  of  theloop counter from .95 down to 0.

68 Chapter 7:  LOOPS AND CONDITIONALS

     

After the loop terminates, the gray value is set to white and theword Zip is printed one last time.

1 setgray printZip
loop and exit
Many  procedures  need  to  be  repeated  an  indefinite  number  oftimes,  either  forever  or  until  some  condition  is  met.  Other  languages  meet  this  need  with  such  constructs  as  Pascal'srepeat...until. P

OSTSCRIPT provides a pair of operators: loop andexit.

The loop operator takes a procedure as its operand and executesit repeatedly until it encounters an exit command within the procedure. exit causes  a  program  to  leave  the  innermost  loop  con-taining that operator. The exit operator will also terminate loops
started by the for, repeat, and forall operators. (See section 8.2for a discussion of the forall operator.)

Thus, the program line

{(Howdy ) show} loop
would cause the string Howdy to be repeatedly printed across thepage and beyond. Since there is no exit in the repeated instructions, this line represents an infinite loop.
To  see  how  the loop-exit pair  work  together,  let's  examine  thefollowing program, which draws several strings of circles across

the width of the current page.

/pagewidth 8.5 72 mul def
/doCircle{ xpos ypos radius 0 360 arc stroke} def
/increase-x{ xpos radius add

/xpos exch def } def

7.2  LOOPS 69

   

/lineofcircles %stack: radius y{ /ypos exch def %define ypos

/radius exch def % ...& radius/xpos 0 def % ...& xpos
{xpos  pagewidth le %begin loop{doCircle increase-x}

{exit} ifelse}loop %end loop
} def %end definition% --------------- Begin Program -----------
10 400 lineofcircles30 400 lineofcircles
90 400 lineofcircles
showpage
The  variable pagewidth holds  the  width  of  a  standard  8.5-inchpage  in  P

OSTSCRIPT units.  The  procedure doCircle draws  acircle on the current page; the circle's center is at xpos,ypos and

its radius is radius. These variables are given values later in theprogram.

The increase-x procedure  increases  the  value  of xpos by  theradius, in effect moving the center of the next circle over by that

amount.
The  last  procedure  defined, lineofcircles,  requires  two  numberson the stack: the circles' radius and the vertical position of their

centers.  These  arguments  are  assigned  to  appropriate  variables(radius and ypos) and xpos is defined as 0.

/ypos exch def/radius exch def
/xpos 0 def
Next, a loop repeatedly draws circles.

{xpos  pagewidth le{doCircle increase-x}{exit} ifelse
}loop
These lines check to see if the current horizontal position is lessthan or equal to the width of the paper. If so, then the procedure

draws  a  circle  onto  the  current  page  and  increases xpos.  If  the

70 Chapter 7:  LOOPS AND CONDITIONALS

     

horizontal position is off the right side of the page, that is, if theresult of the le procedure is false, the exit procedure causes the
interpreter to leave the loop.
Finally,  the  program  does  three  lines  of  circles,  all  at  the  same

vertical position.

10 400 lineofcircles30 400 lineofcircles
90 400 lineofcircles

Recursion
A  loop  can  be  set  up  in  a  program  by  having  a  procedure  callitself, a process called recursion. The recursive calling of a procedure  can  be  a  powerful -- and  somewhat  tricky -- tool.  Theprogram must define some conditions under which the procedure
does not call itself.
Let  us  demonstrate  recursion  in  a  POSTSCRIPT program  thatprints a table of factorials for the numbers from one to ten. The

factorial of a number is the product of all the integers from oneto  that  number.  The  recursive  procedure  here  will  be factorial,
which  will  define n-factorial  to  be 1 if n is  one  andn*(n-1 factorial) otherwise.

% ---------- Variables & Procedures -----------1! = 1
2! = 23! = 6
4! = 245! = 120
6! = 7207! = 5040
8! = 403209! = 362880
10! = 3628800

/LM 72 def/Times-Roman findfont 15 scalefont setfont
/nstr 7 string def
/newline{ currentpoint 16 sub %decrement y-position

exch pop %drop old x...LM exch %  replace it with LM...
moveto} def %  & go there/factorial %stack: n --- n! (after)
{ dup  1  gt{dup 1 sub factorial mul} if
} def/prt-n % stack: n
{ nstr cvs show } def

7.2  LOOPS 71

    

/prtFactorial %stack: n{ dup prt-n %print n

(! = ) showfactorial prt-n %print n!
newline} def% ----------- Program ---------------
LM 600 moveto1 1 10 {prtFactorial} for
showpage
The third line in this program,

/nstr 7 string def
defines a string variable using the string operator. This operatortakes an integer from the stack and creates a new string with the

specified length. The string's contents are null characters.
The newline procedure, as in our formatting program, moves thecurrent point to the beginning of the next line of text. Note that

this  version  of  the  procedure  takes  a  somewhat  different  ap-proach than the last, getting the current vertical position from the
currentpoint operator,  rather  than  keeping  this  value  in  a  vari-able.

Factorial is the recursive procedure in this program.

/factorial{ dup  1  gt

{dup 1 sub factorial mul} if} def

The procedure duplicates the number on the stack and checks tosee if it is greater than 1. If so, the number is multiplied by the
result  of  calling factorial with  its  numeric  predecessor.  If  thenumber is not greater than one, then no action is taken, and the
function returns with that number (i.e., 1) on the stack. The resultis that factorial returns with the stack holding the factorial of the
specified number.
The third procedure, prt-n, prints the number on top of the stack.It introduces a new operator, cvs.

72 Chapter 7:  LOOPS AND CONDITIONALS

    

/prt-n % stack: n{ nstr cvs show } def
The POSTSCRIPT show operator can only take a string as its ar-gument. Anything that is to be printed must first be converted to
a string. This is the function of the cvs operator. This operator'sarguments  consist  of  an  object  and  a  string.  The  object  is  converted into a string representation which is stored in the specifiedstring and left on the stack. For boolean objects, cvs will return
the  strings true or false;  names,  operators,  and  numbers  willreturn their text representations.

The string argument given to cvs must have enough characters tohold the string representation generated. Prt-n converts the number  on  the  stack  to  a  string  whose  maximum  length  is  seven,determined by the seven-character string it puts on the stack before calling cvs.
PrtFactorial prints the number on the stack and its factorial, thenmoves to the next line.

/prtFactorial{ dup prt-n

(! = ) showfactorial prt-n
newline} def
The program then moves to the top of the current page and ex-ecutes  the prtFactorial procedure  for  each  integer  from  one  to

ten.

LM 600 moveto1 1 10 {prtFactorial} for

Recursive Graphics
Recursion applied to graphics can yield quite impressive and in-tricate  results.  We  shall  end  this  chapter  with  an  example  of

recursive graphics. Our program will produce a fractal, a figurewhose  structure  at  any  scale  mirrors  the  figure's  overall  structure.
In this case, we shall produce a fractal arrow.

7.2  LOOPS 73

    

% ------------ Variables & Procedures -------------/depth 0 def
Fractal Arrow

/maxdepth 10 def/down {/depth depth 1 add def} def
/up {/depth depth 1 sub def } def
/DoLine % print a vert. line{ 0 144 rlineto  currentpoint

stroke translate 0 0 moveto} def/FractArrow
{ gsave  .7  .7  scale %reduce scale10 setlinewidth %set line width

down  DoLine %print linedepth  maxdepth le %depth<max. depth?

{ 135 rotate FractArrow-270 rotate FractArrow} if
up grestore } def
% ------------ Begin Program ----------------300 400 moveto
FractArrowstroke
showpagedepth = 1

depth = 2
depth = 3

The two variables  defined  in  this  program  control the recursionof the procedure FractArrow. The variable depth holds a number
that represents the current "depth" of recursion. This variable isincremented  at  the  beginning  of  every FractArrow call  and
decremented at the end.
The maxdepth variable  holds  the  maximum  value  allowed  fordepth. FractArrow will stop calling itself when depth is equal to

maxdepth.
The  recursive  procedure FractArrow starts  by  saving  thegraphics state and then scaling down the coordinate system.

gsave.7  .7  scale
The  line  width  is  set  to  ten, depth is  increased,  and  a  line  seg-ment is drawn onto the page.

74 Chapter 7:  LOOPS AND CONDITIONALS

     

10 setlinewidthdown  DoLine
Note that each successive recursion will yield shorter and thinnerline segments, since the scale is being decreased with each recursion.
Depth and maxdepth are  compared,  and  if  the  former  is  not

Fractal Arrow with the reductionfactor changed from .7 to .6

Fractal Arrow with constantline width and reduction = 0.5

greater  than  the  latter,  the  recursive  part  of  the  procedure  iscarried out.

depth  maxdepth le{ 135 rotate FractArrow

-270 rotate FractArrow} if
The if operator's argument calls FractArrow twice, once after acounterclockwise  rotation  and  again  after  a  clockwise  rotation.

These  calls  to FractArrow,  in  turn,  repeat  the  process.  Eachdraws  a  vertical  line -- rotated  to  some  other  direction  on  the
current page -- and then, if depth is still small enough, executesFractArrow twice again. Each call to FractArrow generates two
more such calls until depth finally reaches maxdepth.
The FractArrow procedure ends by decreasing depth and restor-ing the graphics state to what it had been at the beginning of the

procedure.
The  image  this  program  produces  changes  considerably  withchanges in the maximum depth, the factor by which user's space

is  scaled,  the  length  of  the  line  segment  drawn  by FractArrow,and the angles through which user's space is rotated.

7.2  LOOPS 75

      

7.3  OPERATOR SUMMARY

Control Operators
exit -- Th --

Exit innermost for, loop, or repeat

for j k l proc Th --

For i = j to l step k do proc

if bool proc Th --

If bool is true, then do proc

ifelse bool proc proc Th --t f

If bool is true then do proc , else do proct f

loop proc Th --

Repeat proc forever

String and Conversion Operators
string n Th str

Create string of length n

cvs ob str Th str

Convert to string

Relational Operators
eq ob ob Th bool1 2

Test for equality

ne ob ob Th bool1 2

Test for inequality

gt n/str n/str Th bool1 2

Test for greater than

ge n/str n/str Th bool1 2

Test for greater than or equal to

lt n/str n/str Th bool1 2

Test for less than

le n/str n/str Th bool1 2

Test for less than or equal to

76 Chapter 7:  LOOPS AND CONDITIONALS

    

CHAPTER 8
ARRAYS

8.1  POSTSCRIPT ARRAYS

POSTSCRIPT arrays  are  one-dimensional  collections  of  objects.These objects are numbered from zero, so that a ten-item array is

numbered  from  zero  to  nine.  POSTSCRIPT arrays  are  differentfrom those in other languages in that their elements need not all
be  of  the  same  type.  That  is,  a  single  array  may  contain,  forexample, strings, integers, dictionaries, and other arrays.

An  array  in  a  program  is  denoted  by  any  collection  ofP

OSTSCRIPT objects  surrounded  by  square  brackets.  Thus,  thelines

[16  (twelve)  8][(sum)  6  14  add]
both set up arrays. The first has three members: two numbers anda string. The second array has two items in it: the string sum and
the  number 20.  (Note  that  operators  within  an  array  definitionare carried out as the array is being defined.)

Arrays may also be defined by the array operator. This operatortakes  a  number  from  the  stack  and  constructs  an  array  of  that

length. The line

10 array

77

     

would leave a ten-place array on the stack. The elements of thisarray are initially all P

OSTSCRIPT null objects.

Marks
When an array is created with a line such as

[1  2  3  (O'Leary)]
the square brackets play a more active role than is immediatelyevident. The left bracket is a P

OSTSCRIPT operator that leaves anobject called a mark on the stack.

As  the  interpreter  continues  through  the  program  line,  it  putsmore  objects  on  the  stack  until  it  encounters  a  right  bracket,

which  is  an  operator  that  creates  an  array  containing  the  stackcontents  back  to  the  topmost  mark.  The  mark  is  dropped  from
the stack and the array remains.

Composite Objects
POSTSCRIPT arrays,  strings,  and  dictionaries  are  examples  ofcomposite  objects.  These  objects  have  values  that  are  separate

from  the  object  itself.  That  is,  the  character  codes  making  up  astring are stored in a different location in a P

OSTSCRIPT machinethan the string object that P
OSTSCRIPT directly manipulates.

Note  that  composite  objects  can  share  values.  A dup operationon a string duplicates the object, but not its value. The duplicate

object looks  to  the  same place  in  the  machine's memory for  itsvalue.

8.2  ARRAY OPERATORS

Storing & Fetching Array Members: put and get
The put and get operators store and fetch array information. puttakes three arguments from the stack: an array, an index, and an

object.  It  puts  the  object  into  the  array  at  the  position  specifiedby the index. That is,

78 Chapter 8:  ARRAYS

    

/AnArray 10 array defAnArray  8  (language) put]
would put the string language into the ninth position in AnArray.(Remember  that  the  positions  within  an  array  are  counted  from
zero.)
get takes  an  array  and  an  index  from  the  stack  and  returns  theobject occupying the specified position within the array. The line

[2  5  9]  1 get
would return with the number 5 on the stack.
The following program defines a procedure that uses get to printthe  contents  of  an  array.  It  also  introduces  a  new  operator,

length, which returns the number of objects in an array.

% ------------ Variables & Procedures ----------/LM 72 def %Left margin
/Tempstr 30 string def
/Helvetica findfont 12 scalefont setfont
/crlf %next line{ currentpoint 13 sub

exch pop LM exch moveto } def/aryshow % stack: array
{ /ary exch def %put array in var.0  1  ary length 1 sub %loop parameters

{ ary exch get %get array memberTempstr cvs %convert to string

show  crlf } for %print & next line} def

8.2  ARRAY OPERATORS 79

    

% ------------ Begin Program --------------
mouse27
aName--nostringval--
--nostringval--0
--nostringval--

LM 600 moveto
%begin array:[(mouse) %string

27 %number/aName %literal
[6  12] %array{crlf} %executable
LM %variable/Helvetica findfont %font dictionary
]aryshow

showpage
This  program  defines  a  variable, LM,  sets  the  current  font  totwelve-point  Helvetica,  and  defines  the crlf procedure  that  we

have  seen  before.  It  then  defines  a  procedure  that  prints  anarray's contents.

/aryshow % array => ---{ /ary exch def

0  1  ary length 1 sub{ ary exch get

Tempstr cvsshow  crlf } for
} def
This procedure takes an array from the stack and places it into avariable, ary. It then starts a for loop that will count from zero to

one less than the number of items in ary. (Again, an array with nitems will number those items from 0 to n-1.)

The for procedure  uses  the  counter,  automatically  pushed  ontothe stack, as an index to fetch an item from ary.

ary  exch  get
The object obtained is converted to a string representation of upto  thirty  characters  (determined  by  the  initial  definition  of

Tempstr) and printed on the current page.

80 Chapter 8:  ARRAYS

     

Tempstr cvsshow  crlf
After  defining aryshow,  the  program  moves  to  the  top  of  thepage and places a seven item array on the stack.

mouse27
aName--nostringval--
--nostringval--0
--nostringval--

LM 600 moveto
%Begin array:[(mouse)

27/aName
[6  12]{crlf}
LM/Helvetica findfont]

This array becomes the argument for the aryshow procedure.
Note the manner in which the different objects are printed. Thestring,  name,  number,  and  variable  have  their  values  printed  as

you would expect. The array, procedure, and font dictionary arerepresented by the string --nostringval--, because cvs is unable to
produce a string representation for these objects.

"Automatic" Loops: forall
Programs  often  need  to  perform  a  set  of  operations  on  eachmember  of  an  array.  To  simplify  this  procedure,  P

OSTSCRIPTdefines  a forall operator  that  takes  an  array  and  a  procedure  as

operands.  The  procedure  is  performed  on  each  member  of  thearray. Thus,

AnArray  {30 string cvs show}  forall
would print each member of AnArray on the current page.
We can use the forall operator to simplify the text formatter wewrote in the previous chapter.

8.2  ARRAY OPERATORS 81

   

% -------------- Variables ---------------/LM 72 def %right margin
/RM 216 def %left margin/ypos 720 def %current y-position
/lineheight 11 def  %distance between lines%  of text
% ------------- Procedures ---------------/crlf %move to next line
Concience is the inner voice that warns us somebody may be looking 

 - Mencken  { ypos lineheight sub %decrease ypos/ypos exch def % ...& save new value

LM ypos moveto } def %move to next line/prtstr %stack: str
{ dup stringwidth pop %calc. length of stringcurrentpoint pop %get hor. position

add  RM  gt % sum > right margin?{crlf} if %if so, carriage return
show } def %print string/format %stack: [string array]
{  {prtstr  ( ) show}  forall} def
%------------- Main Program --------------/Times-Italic findfont  10 scalefont setfont

LM ypos moveto
%Text array:[(Concience)(is)(the)(inner)(voice)

(that)(warns)(us)(somebody)(may)(be)(looking)( - Mencken) ]
format
showpage
Most of this program is identical to the formatter in the previouschapter.  The  difference  is  in  the  inclusion  of  the format procedure,  which  takes  an  array  of  strings  from  the  stack  and  useseach member as an argument for prtstr.

/format{  {prtstr  ( ) show}  forall

} def
Notice that format prints a space after each string.

82 Chapter 8:  ARRAYS

     

Our text can now be placed in an array of one-word strings andprinted  with  the format procedure,  which  is  exactly  what  the

program does.

Polymorphic Operators
The length, put, get,  and forall operators  are  actuallypolymorphic operators.  These  can  operate  on  arrays,  strings,  or

dictionaries. length will  return  the  number  of  characters  in  astring,  elements  in  an  array,  or  key-value  pairs  in  a  dictionary.
The  other  three  operators  give  you  access  to  individual  charac-ters, array elements, or key-value pairs. For more information on
the  use  of  these  operators,  refer  to  the  next  chapter  of  thisTutorial,  the P

OSTSCRIPT Language  Reference  Manual,  and  theP
OSTSCRIPT Language Cookbook.

All At Once: aload and astore
Two POSTSCRIPT operators allow you to store or load the entirecontents of an array at once. The aload operator takes an array as

its argument and places the individual elements of that array, andthen the array itself, on the stack. Thus, the line

[1 2 3]  aload
would result in the following stack contents:

1  2  3  [1 2 3]
astore works in the opposite direction, taking several objects andan  array  off  the  stack,  and  placing  all  of  the  objects  into  the

array, which is left on the stack. There must be at least as manyobjects  on  the  stack  as  there  are  places  within  the  array  or  an
error will result. The line

(a)  (b)  (c)  (d)  4 array astore
would leave the array

[(a) (b) (c) (d)]
on the stack.
The following program uses aload to print a sample of some ofthe standard P

OSTSCRIPT typefaces.

8.2  ARRAY OPERATORS 83

     

% --------- Variables & procedures -------/LM 72 def
/newline{ currentpoint 10 sub

exch pop LM exchmoveto } def

The five boxing wizards jump quickly.
The five boxing wizards jump quickly.The five boxing wizards juup quickly.

/PrintSample % [string  fontname]{ aload pop %unload array

findfont 8 scalefont setfont %set fontshow  newline } def %print string
/FontList [ %begin array:[(The five boxing wizards jump quickly.)

/Helvetica][(The five boxing wizards jump quickly.)
/Times-Roman][(The five boxing wizards jump quickly.)
/Symbol]] def %end array
% ------------ Begin Program ----------LM 600 moveto

FontList  {PrintSample} forall
showpage
LM and newline are familiar to us from past programs.
The PrintSample procedure  takes  an  array  as  its  argument;  thisarray should hold a string and the literal name of a font.

/PrintSample% [string  fontname]{ aload pop

findfont 8 scalefont setfontshow  newline } def

The procedure uses an aload to unload the contents of the arrayonto  the stack  and  a pop to remove  the  copy  of  the  array  itself
left  on  the  stack  by aload. PrintSample sets  the  current  font  tothe font named in the array and then prints the string on the current page.
FontList is  an  array  made  up  of  two-item  arrays  of  the  formneeded by PrintSample. Each of these smaller arrays is made up

of a string and the name of a font, for example

84 Chapter 8:  ARRAYS

   

[(The five boxing wizards jump quickly.)/Helvetica]
Finally,  the  program  moves  the  current  point  to  the  top  of  thepage,  puts  the FontList array  onto  the  stack  and  calls
PrintSample for each item within the array.

FontList  {PrintSample} forall
Note  that  the Symbol font  prints  Greek  symbols  in  the  place  ofEnglish letters.

8.2  ARRAY OPERATORS 85

      

8.3  OPERATOR SUMMARY

Array Operators
[ -- Th mark

Start array construction

] mark ob ...ob Th array0 i

End array construction

aload ary Th ob ...ob ary0 n-1

Get all elements of an array

array n Th ary

Create array of size n

astore ob ...ob ary Th ary0 n-1

Put elements from stack into array

Polymorphic Operators
forall ary/dict/str proc Th --

For each element do proc

get ary/dict/str index/key Th value

Get value of index/key in object

length dict/str/ary Th n

Length of object

put ary/dict/str index/key value Th --

Put value into object at index/key

Stack Operators
mark -- Th mark

Push mark onto stack (same as [)

86 Chapter 8:  ARRAYS

    

CHAPTER 9
MORE FONTS

9.1  DIFFERENT SHOWS

Printing  a  document  usually  requires  more  than  printing  thewords  that  make  up  the  text.  The  text  often  must  be  justified

between  page  margins  and  the  spacing  between  individualcharacters may need to be adjusted. To help with these tasks, the
POSTSCRIPT language  has  four  variations  of  the show operatorthat allow text to be adjusted for esthetic appeal. These operators
are:

* ashowPrint a string, adding a specified amount of space after each

character.

* widthshowPrint  a  string,  adding  space  after  each  occurrence  of  a

specified character (e.g., after each space).

* awidthshowCombine the above, adding space after each character and

adding a separately specified offset after each occurrence ofa particular character.

* kshowExecute a specified procedure between each pair of characters  in  the  string.    The  current  character  and  the  characterfollowing are passed as arguments to the procedures.

87

    

For details on these operators, refer to the POSTSCRIPT LanguageReference Manual.
We  shall  look  more  closely  at  the  fourth  operator, kshow.  Thisoperator takes a procedure and a string off the stack. After each

character in the string is printed, that character and the one thatfollows it are placed on the stack, and the procedure is executed.
This happens for each character within the string except the last.The final character is simply printed. Thus, the line

{pop pop (-) show}  (hyphens)  kshow
would drop two items from the stack and print a hyphen betweeneach pair of letters in the word hyphens.

h-y-p-h-e-n-s
Note  that  in  this  case  we  popped  the  pair  of  characters  left  bykshow off the stack, since our procedure does not use them.

kshow was  specifically  designed  to  allow  easy kerning,  adjust-ing  inter-letter  spacing  to  achieve  a  more  pleasing  appearance.

However, this operator may be used for other purposes, since theprocedure handed to it as an operand may perform any operation.

For  example,  the  program  below  repeatedly  prints  the  wordsBinky  Inc. until  the  entire  current  page  is  filled.  The  procedure

passed  to kshow calls the newline procedure  whenever the cur-rent  point  moves  past  the  right  margin.  Once  the  page  is  filled,
Binky  Inc. is  printed  again  in  the  center  of  the  page  in  thirty-point type.

88 Chapter 9:  MORE FONTS

    

Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky
 Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  B
inky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky I
nc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  B
inky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky Inc.  Binky I
nc Binky Inc.

% ------- Variables and Procedures --------/TM 780 def %Top Margin
/BM -12 def %Bottom/LM 0 def %Left
/RM 612 def %Right/newline

{ currentpoint 13 subexch pop LM

exch moveto } def/nlIfNec
{ currentpoint pop RM gt %beyond RM?{newline} if } def %yes: next line

/done? %stack: --- bool.{ currentpoint exch pop %Below BM?

BM lt } def/fillpage % stack: str
{ /strg exch def{  {pop pop nlIfNec} strg kshow

done? {exit} if} loop
} def

9.1  DIFFERENT SHOWS 89

    

% ------------ Begin Program -----------/Times-Bold findfont 10 scalefont setfont
LM TM moveto.5 setgray
(Binky Inc.  ) fillpage
/Times-Roman findfont 30 scalefont setfont
RM LM sub %center the words(Binky Inc.) stringwidth pop sub
2 div400 moveto

0 setgray(Binky Inc.) show
showpage
The program begins, as usual, by defining several variables andprocedures.  The  variables  define  the  positions  of  the  margins

within  which  the  text  is  to  be  printed,  in  this  case  the  edges  ofthe current page.

The procedure nlIfnec calls newline if the current point is beyondthe right margin. Done? returns a boolean true or false, depending  on  whether  the  current  point  is  below  or  above  the  bottommargin.

The fillpage procedure

/fillpage{ /strg exch def

{  {pop pop nlIfNec} strg kshowdone? {exit} if
} loop} def

takes a string off the stack and places it in a variable strg. It thenstarts a loop which places a procedure and strg on the stack and
executes  the kshow operator.  The  procedure  executed  betweencharacters  pops  the  two  character  codes  left  by kshow off  the
stack (since we do not use them here) and then calls the nlIfNecprocedure. Once the string has been printed, the done? procedure
determines  whether  the  current  point  is  off  the  bottom  of  the

90 Chapter 9:  MORE FONTS

   

page.  If  so, fillpage quits;  otherwise,  it  repeats,  printing strgagain.
The main part of the program sets the current font to a ten-pointTimes  Bold,  moves  to  the  top  left  of  the  current  page,  sets  the

gray value to .5, and fills the page with the words Binky Inc.

/Times-Bold findfont 10 scalefont setfont
LM TM moveto.5 setgray
(Binky Inc.  ) fillpage
It then prints the thirty-point Binky Inc.

RM LM sub %center the words(Binky Inc.) stringwidth pop sub
2 div 0400 moveto

0 setgray(Binky Inc.) show

9.2  CHARACTER ENCODING

Computer  systems  handle  text  by  assigning  a  numeric  code  toeach  character  recognized  by  the  system.  This  set  of  codes  is

referred to as an encoding of  the  character  set. One widespreadencoding is the familiar

ASCII character code.

Each  POSTSCRIPT font  dictionary  contains  the  encoding  for  itscharacters.  Each  character  in  the  font  is  associated  with  an  integer from 0 to 255. The standard encoding for the alphanumericfonts, such as Times and Helvetica, is similar to the

ASCII stan-dard.  It  is  important  to  note  that  a  font's  encoding  is  not  fixed

and  may  be  changed  to  anything  convenient  for  an  applicationprogram.  For  details  on  how  to  change  the  encoding  of  a  font,
see the POSTSCRIPT Language Cookbook.
Many  of  the  characters  within  a  POSTSCRIPT font  have  no  cor-responding key on a computer keyboard and can only be referred

to by their codes. Many fonts also have characters which do nothave codes in the standard encoding and must be assigned a code

9.2  CHARACTER ENCODING 91

     

before they can be used (see POSTSCRIPT Language Cookbook).For  a  complete  list  of  the  characters  and  corresponding  codes
available  in  the  standard  POSTSCRIPT fonts,  refer  to  theP

OSTSCRIPT Language Reference Manual.

Character codes may be directly used in two ways: they may beinserted  into  a  string  with  a put operation  or  used  directly  in  a

string as an octal (base eight) number.

Putting Codes Into Strings
The  following  program  uses put to  generate  a  table  of  thecharacters whose standard codes are greater than 160. Note that

some  of  the  codes  listed  have  no  characters  associated  withthem.

% -------- Variables & Procedures ---------/Times-Roman findfont 10 scalefont setfont

161   !162   c
163   #164   /
165   Y166   f
167   $168   #
169   '170   "
171   <<172   <
173   >174   fi
175   fl176   
177   -178   #
179   ##180   *
181   182   ||
183   *184   ,
185   "186   "
187   >>188   ...
189   o/oo190   
191   ?192   
193   `194   '
195   ^196   ~
197   _198   *
199   .200   "
201   202   *
203   ,204   
205   ""206   ,
207   ^208   --

225   AE226   
227   -a228   
229   230   
231   232   L/
233   O/234   OE
235   -o236   
237   238   
239   240   
241   ae242   
243   244   
245   i246   
247   248   l/
249   o/250   oe
251   ss

/char 1 string def/nstr 3 string def
/newline{ currentpoint 11 sub

exch pop LMexch moveto } def
(/prt-n %stack: code{nstr cvs show} def

/prtchar %stack: code{ char  0

3 -1 roll putchar  show } def

/PrintCodeandChar %stack: code{ dup prt-n

(  ) showprtchar newline } def
% ---------- Begin Program ----------/LM 72 def
LM 600 moveto161 1 208 {PrintCodeandChar} for

92 Chapter 9:  MORE FONTS

     

/LM 144 defLM 600 moveto
225 1 251 {PrintCodeandChar} for
showpage
The prt-n procedure  defined  above  takes  a  number  from  thestack and prints it on the current page.

Prtchar takes a numeric code from the stack and prints the cor-respoding character. The procedure does this by putting the number  into  a  one-character  string  and  then  printing  the  string.  Thefirst line

char  0
places  the  string  and  the  index  for  the put on  the  stack.  (Notethat the only position in a one-character string is zero.) The next

line

3 -1 roll put
brings  the  numeric  code  to  the  top  of  the  stack  and  puts  it  intochar. Finally, the procedure prints char, which now contains our

character code.
The  procedure PrintCodeandChar calls prt-n,  prints  threespaces,  and  then  calls prtchar,  thereby  printing  one  line  of  our

table.

/PrintCodeandChar %stack: code{ dup prt-n

(  ) showprtchar newline } def

The program itself sets LM, our left margin, to 72, moves to thetop of the page, and then calls PrintCodeandChar for each number  between 161 and 208.  It  then  resets  the  left  margin  to 144and  prints  table  entries  for  the  numbers  from 225 to 251.  The
codes  from 209 through 224 are  skipped  because  they  have  nocharacters assigned to them in the standard encoding.

9.2  CHARACTER ENCODING 93

   

Octal Character Codes
The  characters  printed  by  the  preceding  program  are  not  acces-sible from the keyboard. They can be printed by inserting them

into  strings,  as  we  did  above,  or  by  using  their  octal  valuesdirectly  in  a  string.  A  three-digit  number  following  a  backslash
in a POSTSCRIPT string is interpreted as the octal code of a char-acter to be placed in the string. That is, the string

(785\275)
has  as  its  fourth  element  the  character  whose  character  code  is275  octal.  It  would  be  printed  as  "785o/oo".  A  list  of  the  octal

encoding of all POSTSCRIPT standard fonts is in the POSTSCRIPTLanguage Reference Manual.

To  demonstrate this  method of  using  octal codes,  the  followingprogram prints a line of Spanish text.
   !Hola, Isabel!

/Times-Roman findfont 12 scalefont setfont300 400 moveto

(\241Hola, Isabel!) showshowpage
The code 241 in the string (\241Hola, Isabel!) represents an in-verted exclamation point.
It  should  again  be  emphasized  that  the  encoding  used  here  ismerely the standard encoding for P

OSTSCRIPT text fonts and is inno way fixed. If a different set of codes is appropriate to an application,  or  if  a  program  needs  to  use  some  of  a  font's  un-assigned  characters  (which  include  a  host  of  accented
characters), the encoding is easily changed. Again, to see how todo this, refer to the P

OSTSCRIPT Language Cookbook.

9.3  FONT TRANSFORMATIONS

A  POSTSCRIPT transformation  matrix is  a  six-element  array  ofnumbers  that  defines  how  coordinates  in  user  space  are  to  be

transformed into positions on the current page. The elements ofthe  array  determine  the  scale,  orientation,  and  position  of  the x
and y axes.

94 Chapter 9:  MORE FONTS

    

The  graphics  state  maintains  a Current  Transformation  Matrix,which defines how all images are positioned on the current page.

The translate, rotate,  and scale operators  change  elements  inthis matrix in order to modify the user coordinate system.

A  separate  transformation  matrix  is  associated  with  each  font,defining how the characters in the font are to be printed onto the

current  page.  This font  matrix can  be  altered  directly  with  themakefont operator,  which  takes  a  font  dictionary  and  a  sixelement  array  from  the  stack,  transforms  the  dictionary's  fontmatrix by the array, and then pushes the new font dictionary onto
the stack.
In the discussion that follows, we shall only be examining trans-formation  matrices  that  result  in  straightforward  scaling  of  the

font. Such matrices have the form

[m  0  0  n  0  0]
where m and n are the desired scales in x and y, respectively.
Thus, the lines

/Helvetica-Bold findfont  6 scalefont/Helvetica-Bold findfont [6 0 0 6 0 0] makefont

do exactly the same thing: create a six-point Helvetica Bold fontdictionary.
The makefont operator  allows  you  to  create  condensed  or  ex-panded  fonts  by  suitably  changing  the  contents  of  the  font

matrix. The following program demonstrates this technique.

% ---- Variables & Procedures ----/basefont  /Times-Roman findfont def
/LM 72 def
/newline{ currentpoint 13 sub

exch pop LMexch moveto } def

9.3  FONT TRANSFORMATIONS 95

   

% ----- Begin Program ------LM 600 moveto
%normal print:basefont  [12 0 0 12 0 0] makefont setfont"Talking of axes,"
said the Duchess,"Off with her head!"
   - Lewis Carroll

("Talking of axes,") show newline%expanded:

basefont  [17 0 0 12 0 0] makefont setfont(said the Duchess,) show newline
%condensed:basefont  [7 0 0 12 0 0] makefont setfont
("Off with her head!") show newlinebasefont [12 0 6.93 12 0 0] makefont setfont
(  - Lewis Carroll) show
showpage
Two  variables  are  used  here:  our  usual LM and  a  variablebasefont, whose value is the Times Roman font dictionary.

The program moves to the top of the page and prints four lines,each  time  transforming  the  current  font  with  a  different  font

matrix. The first of these,

[12 0 0 12 0 0]
creates a normal twelve-point Times Roman font. The second,

[17 0 0 12 0 0]
scales the horizontal direction more than the vertical; the heightof each character is that of a twelve-point font, while the width is

appropriate  to  a  seventeen-point  font.  The  characters  are  wider,the font is expanded.

The third matrix used,

[7 0 0 12 0 0]
results in a condensed font.
The last matrix in our example,

[12  0  6.93  12  0  0]

96 Chapter 9:  MORE FONTS

     

has a non-zero value as its third element. The third element in atransformation  matrix  affects  the  angle  by  which  the  font  is
obliqued.  To oblique a font by q degrees, set the third element inthe transformation matrix to y*tanq, where y is the point size of
the font.
The 6.93 in our last matrix above is the product 12*tan30, so ourcharacters are obliqued thirty degrees.

All  of  these  effects  could  have  been  obtained  by  transforminguser space with scale or setmatrix. However, these operators affect the appearance of everything printed on the current page. Ifonly the text should be expanded, compressed, or obliqued, then
makefont is the most appropriate operator.

9.4  CHARACTER OUTLINES

Each  font  dictionary  contains  descriptions  of  the  shapes  of  itscharacters.  Most  fonts  describe  their  characters  as  outlines  that

Most font characters aredescribed as outlines to be filled. are  filled  when  the  character  is  printed.  Other  fonts  describecharacters as lines to be stroked or as bit maps.

Outlined and stroked character descriptions may be directly usedwith  the charpath operator.  This  operator  takes  a  string  and  a

boolean  value  from  the  stack  and  adds  to  the  current  path  thecharacter  outlines  that  describe  the  string.  The  boolean  value
determines  what  type  of  outline  to  leave.  If  false,  the  path  ex-actly mirrors the character descriptions in the font dictionary; if
true,  the  path  differs  from  the  character  description  in  that  anyparts of the character that are normally stroked are outlined. If a
font's characters are all filled, rather than stroked, then there willbe no difference in the paths returned with true and false. (This
is true of Times, Helvetica, and Symbol characters.)
For example, the program lines below would result in the pathsillustrated at left, if they were embedded in the proper program.

(The font used here is Courier, whose characters are stroked.)

(A)  false  charpath

(A)  true  charpath

(A) false charpath(A) true charpath

The path constructed by charpath can be stroked or filled.

9.4  CHARACTER OUTLINES 97

    

Let us end chapter eight with a program that generates an imagesimilar to that reduced at left. We shall print the word Adobe in

outlined  characters  at  several  rotations  around  the  origin,  andthen print an outlined, white-filled Adobe Systems.

% -------- Procedures --------/Helvetica-Bold findfont

30 scalefont setfont
/oshow %stack: (string)

{ true charpath stroke } def/circleofAdobe

{ 15 15 345{ gsave

rotate  0 0 moveto(Adobe) oshow
grestore} for
} def% --- Begin Program ---
250 400 translate
.5 setlinewidthcircleofAdobe
0 0 moveto(Adobe Systems) true charpath
gsave  1 setgray fill  grestorestroke

showpage
This  program's oshow procedure  prints  the  outline  of  a  string'scharacters.

/oshow %stack: (string){ true charpath stroke } def
It pushes the boolean true over the string on the stack, calls thecharpath operator,  and  then  strokes  the  resulting  path  onto  the
current page.
CircleofAdobe sets up a for loop that rotates the coordinate sys-tem  to  every  multiple  of  fifteen  degrees  and  prints  the  outlined

word Adobe at every rotation.

98 Chapter 9:  MORE FONTS

    

/circleofAdobe{ 15 15 345

{ gsaverotate  0 0 moveto

(Adobe) oshowgrestore
} for} def

Finally,  the  program  translates  the  origin  to  the  middle  of  thepage,  calls circleofAdobe,  and  then  outlines  and  fills  the  words
Adobe Systems.

0 0 moveto(Adobe Systems) true charpath
gsave  1 setgray fill  grestorestroke

Note  that  we  put  the fill operation  inside  a gsave-grestore pairso that we could both fill and stroke the character path. Our font
in  this  program  has  filled  characters,  so  the  choice  of true orfalse for this program's charpath operators did not matter.

9.4  CHARACTER OUTLINES 99

     

9.5  OPERATOR SUMMARY

Character and Font Operators
kshow proc str Th --

Execute proc between showing characters in str

makefont fdict matrix Th fdict

Return new font dictionary with transformed font matrix

Path Construction Operators
charpath str bool Th --

Add character outlines to current path

100 Chapter 9:  MORE FONTS

    

CHAPTER 10

10.1  CLIPPING PATH

The POSTSCRIPT graphics state maintains a clipping path, whichrepresents the boundaries of the region on the current page into

which  images  can  be painted.  Initially,  this  path  corresponds  tothe edges of the paper used by the printer. The current clipping
path  can  be  changed  with  the clip operator.  The clip operatormakes  the  current  path  the  clipping  path;  all  future  painting
operations will be clipped so that only those parts that lie withinthis path are actually transferred to the current page.

For example, the following program constructs a triangular pathand makes it the clipping path. It then draws a grid of horizontal

and vertical lines,  only  parts  of  which actually  are painted ontothe current page.

% ---- Procedures ----/trianglepath

{ newpath0 0 moveto

144 0 lineto72 200 lineto

closepath } def

101

    

/verticals{ newpath

0 9 144{ 0 moveto

0 216 rlineto } forstroke } def
/horizontals{ newpath

0  10  200{ 0 exch moveto

144 0 rlineto } forstroke } def
% ---- Begin Program ---230 300 translate
trianglepath  clip %set clipping pathverticals %Do grid
horizontals
showpage
The  procedure trianglepath constructs  a  triangular  path  with  abase  144  units  long  and  a  height  of  200. Verticals and

horizontals draw a series of vertical and horizontal lines, respec-tively.

The  program  calls trianglepath and  then  the clip operator.  Thegrid  is  then  drawn  with verticals and horizontals;  since  the  imageable  portion  of  the  current  page  has  been  clipped,  only  thatpart of the grid that falls within the triangle ends up on the page

Only the part of the grid that falls within the triangular clipping path 
reaches the current page. 

(see illustration at left).

Any path can be used as a clipping boundary, including the char-acter path left by a charpath operator. For example, the following  program  prints  a  series  of  line  segments  radiating  from  theorigin clipped to the character path of the name StarLines.

102 Chapter 10:  CLIPPING AND LINE DETAILS

     

% -------- Procedures ---------------/Times-BoldItalic findfont

27 scalefont setfont
/rays{ 0 1.5 179

{  gsaverotate

0 0 moveto  108 0 linetostroke
grestore} for
} def% -------- Begin Program ---------
300 400 translate
.25 setlinewidth

newpath0 0 moveto
(StarLines) truecharpath clip
newpath54 -15 translate
rays
showpage
The rays procedure draws our radiating lines by repeatedly rotat-ing the coordinate system and drawing a line along the x axis.

rotate0 0 moveto  108 0 lineto
stroke
The  angle  of  rotation  is  determined  by  a for loop  that  stepsthrough the angles from 0 to 179 in 1.5-degree intervals.

The  program,  having  defined rays,  moves  to  the  center  of  thepage, sets the line width to a quarter of a unit, and then sets up

the character outline of the string StarLines as a clipping path.

10.1  CLIPPING PATH 103

       

newpath0 0 moveto
(StarLines) truecharpath clip

The origin is translated to below the center of the string-shapedclipping path and the rays procedure called.

newpath54 -15 translate
rays
A clipping path does not restrict where an object may be drawn,only  what  parts  of  that  object  will  affect  the  current  page.  An

object drawn outside of the current clipping path will not cause

EFGHIJKLMNOPQRSTUVWXYZabcdefgEFGHIJKLMNOPQRSTUVWXYZabcdefg

FGHIJKLMNOPQRSTUVWXYZabcdefgE\Phi \Gamma HIJK\Lambda MNO\Pi \Theta R\Sigma T\Upsilon V\Omega \Xi \Psi Zabcdefg
EFGHIJKLMNOPQRSTUVWXYZabcdefgEFGHIJKLMNOPQRSTUVWXYZabcdefg

FGHIJKLMNOPQRSTUVWXYZabcdefgE\Phi \Gamma HIJK\Lambda MNO\Pi \Theta R\Sigma T\Upsilon V\Omega \Xi \Psi Zabcdefg

Any image, graphics, or text canbe printed within a clipping path.

an error, it will just not appear on the current page.

10.2  LINE-DRAWING DETAILS

The POSTSCRIPT language gives complete control over how thestroke operator converts a path into a painted line or curve. The

setlinewidth operator  determines  the  width  of  the  stroked  line.There are several operators that allow us to precisely determine
other characteristics of a stroked path. Among these are:
setlinecap Determines the appearance of line segment ends.
setlinejoin Determines  the  method  by  which  different  linesegments are joined.

setdash Determines the pattern for dashed lines.
We shall examine each of these operators in turn.

setlinecap
The setlinecap operator takes a number from the stack and usesit as a code determining how  P

OSTSCRIPT will end stroked  linesegments. For example, the program line

1 setlinecap
would  cause  POSTSCRIPT to  paint  all  line  segments  with  roundends.

104 Chapter 10:  CLIPPING AND LINE DETAILS

     

There are three values for the line cap code:

0 Butt  caps.  The  line  segment  has  square  ends  perpen-Linecap = 0; Butt caps

Linecap = 1; Round caps
Linecap = 2; Projecting caps

dicular  to  the  path.  This  is  the  POSTSCRIPT default  linecap.
1 Round  caps.  The  line  segment  ends  with  semicircularcaps with diameters equal to the width of the line.
2 Projecting  square  caps.  These  are  similar  to  butt  caps,but  extend  one-half  of  a  line  width  beyond  the  line

segment's endpoint.

setlinejoin
When  two  connected  line  segments  are  stroked,  POSTSCRIPTneeds to make a decision about what type of joint to use between

them.  The setlinejoin operator  tells  POSTSCRIPT how  to  joinconnecting line segments. This operator is similar to setlinecap,
in  that  it  takes  a  code  from  the  top  of  the  stack.  This  code  canhave  values  from  zero  to  two,  corresponding  to  the  following
types of line joins:

Linejoin = 0; Miter joins

Linejoin = 1; Round joins

Linejoin = 2; Bevel joins

0 Mitered join. The edges of the stroke are extended untilthey  meet.  This is the default join.  This  join  is  affected

by the current miter limit (see below).
1 Rounded join. The segments are connected by a circularjoin with a diameter equal to the line width.

2 Bevel join. The segments are finished with butt end capsand the notch at the larger angle between the segments is

filled with a triangle.

Miter Limit
Mitered joins can present a problem. If two line segments meetat an extremely small angle, the mitered join can produce a spike

that  extends  a  considerable  distance  beyond  the  intersection  ofthe  path  segments.  To  prevent  this,  the  join  switches  from
mitered  to  beveled  when  the  angle  between  line  segments  be-comes too acute.

10.2  LINE-DRAWING DETAILS 105

      

a
b

That is, if the current line join is 0, line segments will normallybe connected with a mitered joint (see a, at left). However, if the

angle  between  the  two  segments  is  too  small,  the  connection  isbeveled (as in b).

The angle at which this changeover is made is determined by the
lw

The miter limit is the maximum ratio of l/w.

current miter limit. The miter limit is the maximum ratio of thediagonal line  through a  join to the width of the lines producing
the  join  (see  at  left).  This  ratio  can  be  set  by  the setmiterlimitoperator, which takes a number from the stack and makes it the
new  miter  limit.  The  smaller  this  number  is,  the  less  tolerantP

OSTSCRIPT becomes  of  small  mitered  angles  and  the  sooner  itwill switch to beveled joins. The default P

OSTSCRIPT miter limitis ten, specifying a miter limit angle of about eleven degrees.

10 setmiterlimit

3 setmiterlimit

The illustration at left shows two line segments intersecting at anangle of thirty degrees. In the upper figure, the miter limit is the

default 10;  in  the  lower,  the  limit  has  been  changed  to 3.  Theangle  is  the  same,  but  the  lower  miter  limit  causes  the  second
pair to be beveled, rather than mitered.

setdash
The  current  path  is  normally  stroked  with  a  solid  line.  Othermethods  of  stroking  a  path  are  possible,  however.  The

POSTSCRIPT graphics  state  includes  a dash  array and  a dashoffset that together describe what pattern of alternating black and
white dashes should be used to stroke paths.
This pattern is set by the setdash operator, which takes an arrayand  a  number  from  the  stack  and  makes  them  the  current  dash

array and offset. The array contains a set of numbers, such as

[3 5 1 5]
which  represent  the  lengths  of  alternating  black  and  white  seg-ments  should  make  up  a  stroked  line.  The  array  above  would

cause all paths to be stroked with a repeating sequence consistingof three units of black, five units of no ink, one unit black, five

[3  5  1  5]  0  setdash units no ink. This pattern will repeat along the entire stroked path

(see illustration at left).

106 Chapter 10:  CLIPPING AND LINE DETAILS

    

The  second  argument passed to setdash is  the  offset within  thedash pattern where the stroke operator is to start when it prints a

line. That is, if we were to set the dash pattern with the line

[6 3]  3  setdash
stroked lines would begin three units into the pattern, or halfwaythrough the first long dash.

The following program illustrates the effects of the setdash argu-ments on the appearance of stroked lines. It draws two thick vertical  lines  and  then  draws  a  series  of  horizontal  lines  betweenthem, each with a different dash pattern or offset. The horizontal
lines are numbered with their vertical positions above the origin.

% ------- Variables & Procedures --------130
115

100
85
70
55
40
25
10

/ypos 130 def/Times-Roman findfont 6 scalefont setfont
/prt-n{ (  ) cvs show } def
/borders{ -2.5 0 moveto  0 135 rlineto

102.5 0 moveto  0 135 rlinetostroke } def
/newline{ /ypos ypos 15 sub def } def
/doLine{ 0 ypos moveto  100 0 rlineto stroke

5 ypos 2 add moveto ypos prt-nnewline } def
% -------- Begin Program --------250 350 translate

5 setlinewidthborders

10.2  LINE-DRAWING DETAILS 107

   

.5 setlinewidth[ ] 0 setdash doLine %empty array for solid line
[4 2] 0 setdash doLine[2 4] 0 setdash doLine
[6 4 2 4] 0 setdash doLine[4 4] 0 setdash doLine
[4 4] 1 setdash doLine[4 4] 2 setdash doLine
[4 4] 3 setdash doLine[4 4] 4 setdash doLine

showpage
Much of this program is familiar to us already. The newline pro-cedure  decrements  the  variable ypos,  which  holds  the  current

vertical position. Prt-n converts a number to a string and prints iton  the  current  page. Borders draws  two  vertical  lines  one
hundred units apart.
The doLine procedure  draws  a  line,  prints  the  value  of yposabove the line, and then decrements ypos.

/doLine{ 0 ypos moveto  100 0 rlineto stroke

5 ypos 2 add moveto ypos prt-nnewline } def

The  program  moves  the  origin  to  the  middle  of  the  page  andprints the vertical borders in 5-unit-wide lines.

5 setlinewidthborders
The line width is reset to .5 and nine horizontal lines are drawn,each with a different dash pattern or offset.
The first dash pattern,

[ ] 0 setdash doLine
has  an  empty  dash  array,  signifying  a  solid  line.  The  offset  isunimportant in this case. The next three lines,

108 Chapter 10:  CLIPPING AND LINE DETAILS

    

[4 2] 0 setdash doLine[2 4] 0 setdash doLine
[6 4 2 4] 0 setdash doLine
draw lines of various dash patterns. The last five lines have thesame pattern, but different offsets.

[4 4] 0 setdash doLine[4 4] 1 setdash doLine
[4 4] 2 setdash doLine[4 4] 3 setdash doLine
[4 4] 4 setdash doLine
For  more  information  on  the setdash operator,  refer  to  theP

OSTSCRIPT Language  Reference  Manual and  the POSTSCRIPTLanguage Cookbook.

10.2  LINE-DRAWING DETAILS 109

    

10.3  OPERATOR SUMMARY

Graphics State Operators
clip -- Th --

Set clipping boundary to current path

setdash ary n Th --

Set dash array

setlinecap 0/1/2 Th --

Set shape of stroked line ends

setlinejoin 0/1/2 Th --

Set shape of stroked line joins

setmiterlimit num Th --

Set maximum miter ratio

110 Chapter 10:  CLIPPING AND LINE DETAILS

     

CHAPTER 11
IMAGES

11.1  THE IMAGE OPERATOR

Digital electronics typically handles photographic information bydividing  the  picture  up  into  small  sections  and  recording  the

brightness and grey value or color of each section. A televisionimage is such a sampled image, as are the graphics produced by
most  computer  systems.  Each  sample  of  the  original  image  isreproduced onto a section of the final printed image. This small
piece of black, white, gray, or color is called a picture element,or pixel.

The POSTSCRIPT language prints sampled images with the imageoperator.  This  operator  interprets  the  character  codes  of  the

characters  of  a  string  as  a  series  of  bits  that  describe  an  image,beginning at the image's lower left corner.

For example, the string "AB" consists of two characters, whosedefault  encodings  are  decimal  65  and  66.  The  image  operator

would interpret this string as the series of bits that are the binaryrepresentation of these numbers. That is, the binary sequence

01000001 01000010
The image operator interprets the bits passed to it as a descrip-tion of the gray values of a stream of pixels of from one to eight

bits each.

111

      

The image operator prints its results in a one-unit square whoselower left corner is at the origin. Thus, the image rendered by the

image operator in the default user coordinate system will be 1/72inch  on  a  side.  Before  using image,  one  needs  to  translate  the
origin to the desired location of the image and scale to the imagesize required.

Using image
The image operator takes five arguments:

* Scan lengthNumber of samples per scan line.

* Scan linesNumber of scan lines in the image.

* Bits per sampleThe  number  of  bits  making  up  each  sample.    Permissible

values are 1, 2, 4, and 8.  An image with one bit per samplewill  print  only  black  and  white.    An  eight  bit-per-sample
image  can  specify  values  ranging  from  0  (black)  to  255(white).

* Transform matrixA  six-element  array  that  determines  the  mapping  of

samples  into  the  one-unit-square  imaging  region.    (For  amore  detailed  description  of  P

OSTSCRIPT transformmatrices, refer to section 4.6 of the P

OSTSCRIPT LanguageReference Manual.)  For an image n samples wide made up

of m lines, the matrix

[ n  0  0  m  0  0 ]
will cause the image to exactly fill the unit square.  Manygraphics  programs  generate  images  whose  data  begins  at
the  upper  left  corner  of  the  image,  rather  than  the  lowerleft.  In these cases, the matrix

[ n  0  0 -m  0  m ]
will allow proper rendering of the image.

* ProcedureThis is the procedure that produces the data strings needed

by image.  This  can  be  any  POSTSCRIPT procedure  that

112 Chapter 11:  IMAGES

     

leaves a string on the stack.  The image operator will takethis string and interpret its characters as sample data.  If the
string  does  not  describe  the  complete  image,  the imageoperator  will  call  this  procedure  again,  repeating  until  the
number  of  samples  implied  by  the  first  three  argumentshave  been  processed.    The image operator  ignores  any
unused data left in the string at the end of the image; it alsoignores  any  bits  left  in  its  current  character  of  data  at  the
end of a scan line.

A Binary Image
The  program  below  prints  an  eight  by  eight  binary  image  one

inch on a side.

300 400 translate %Move image to middle of page72 72 scale %Make image one inch on a side

8  8  1  [8 0 0 8 0 0]  {<c936>}  image
showpage
The  first  two  lines  of  this  program  scale  the  unit  square  to  thedesired  position  and  size.  This  will  determine  the  location  and

size of the printed image.
The third line,

8  8  1  [8 0 0 8 0 0]  {<c936>}  image
prints  an  eight  pixel  by  eight  line  image,  each  pixel  being  onebit; the transform matrix will fill the unit square (scaled to a one

inch square) with the image.
The procedure argument in the line above introduces a new typeof string. Angle brackets enclose a hexadecimal string. Each pair

of characters in this string is interpreted as a hexadecimal num-ber  making  up  one  character  of  the  string.  Thus,  the  string
<c936> has  two  characters  whose  character  codes  arehexadecimal C9 and 36. The image operator will take any kind
of string, but hex strings are useful in specifying bitmaps.
The  procedure  specified  for  the image operator  in  our  example

11.1  THE IMAGE OPERATOR 113

      

will place this two-character  string on the stack every time it iscalled.  This  string  will  be  interpreted  as  a  sequence  of  sixteen
bits:

1 1 0 0 1 0 0 1 0 0 1 1 0 1 1 0

1 1 0 0 1 0 0 10 0 1 1 0 1 1 0
1 1 0 0 1 0 0 10 0 1 1 0 1 1 0
1 1 0 0 1 0 0 10 0 1 1 0 1 1 0
1 1 0 0 1 0 0 10 0 1 1 0 1 1 0

8 8 1 [8 0 0 8 0 0] {<c936>} image

Since each line of our image is eight one-bit samples wide, eachcall of  the  procedure  will  supply  data  for  two  lines.  The image
operator calls the procedure four times in making the image. Theillustration at left indicates the correspondence between the data
and the resulting image.

Bits per Sample
The  following  program  takes  the  image  from  the  previous  ex-ample and prints it four times with different numbers of bits per

sample.

72 500 translate
72 72 scale8 8 1 [8 0 0 8 0 0] {<c936>} image

0 -1.25 translate8 8 2 [8 0 0 8 0 0] {<c936>} image
0 -1.25 translate8 8 4 [8 0 0 8 0 0] {<c936>} image
0 -1.25 translate8 8 8 [8 0 0 8 0 0] {<c936>} image
showpage
The images at left, from top to bottom, represent the hex string<c936> interpreted as one, two, four, and eight bits per sample.

The first square is identical to our previous example. The secondsees the string as an eight-sample sequence:

11  00  10  01  00  11  01  10
This  sequence  makes  up  one  line  of  samples  which  is  repeated

114 Chapter 11:  IMAGES

     

for each line in the image. The last two squares interpret the dataas four- and two-sample sequences, respectively:

1100  1001  0011  0110
11001001  00110110

Aspect Ratio
The program below prints the bitmapped image of a helicopter ina one inch square.

/Helicopter<dd ff 00 ff 54 1f 80 03 fb f9 00 1e> def
300 400 translate72 72 scale
16 6 1 [16 0 0 6 0 0] {Helicopter} image
showpage
The program is very similar to our first example, with only twodifferences:

1. The procedure argument for the image operator returns thecomplete bitmap and is only called once.
2. The  bitmap  is  not  square.  It  contains  six  lines  of  sixteensamples each.
The second difference leads to a problem with our program. Weare mapping a sixteen by six bitmap into a 72 by 72 square. The
result is that our pixels are tall and skinny and our image is dis-torted.  For  our  image  to  be  properly  proportioned,  the  sides  of
the  square  into  which  the  image  is  mapped  (as  set  by  the scaleoperator) should have a ratio equal to those of the bitmap being
printed.
Thus, if the line that contains the scale operator in the programabove is changed to

72 27 scale

11.1  THE IMAGE OPERATOR 115

  

(a  ratio  of  16  to  6),  the  bitmap  proportions  and  the  unit  squareproportions  will  match,  and  the  helicopter  will  come  out  as  at
left.

116 Chapter 11:  IMAGES

     

11.2  OPERATOR SUMMARY

Graphics Output Operators
image scanlen #lines b/p [transform] {proc} Th --

Render image onto current page

Polymorphic Operators
putinterval obj i obj Th --1 2

Copy obj into obj starting at i2 1

11.2  OPERATOR SUMMARY 117

   

CHAPTER 12

12.1  APPLE LASERWRITER

The Apple LaserWriter is the most widely available POSTSCRIPTprinter. Among its features is an interactive mode that allows the

user  to  communicate  directly  with  the  POSTSCRIPT interpreter.This  allows  the  printer  to  be  programmed  directly  in
POSTSCRIPT.
The  LaserWriter  contains  a  complete  implementation  ofP

OSTSCRIPT.  All  of  the  sample  programs  presented  in  thismanual may be sent to the LaserWriter.

Preparing the LaserWriter
The LaserWriter can be used with any computer or terminal thatcan  communicate  through  an  RS-232  port.  The  host  computer

will  need  a  telecommunication  program  (such  as  MacTerminalon  a  Macintosh)  for  interactive  communication  with  a
LaserWriter.
To prepare the LaserWriter for interactive use:

* Connect  the  RS-232  port  of  the  LaserWriter  to  that  of  thehost computer.  Depending on the host computer, this will

require  a cable  with either two  25-pin connectors or  a 25-

119

     

pin  and  a  9-pin  connector  (such  as  a  Macintosh  modemcable).

* Set  the  LaserWriter's  select  switch  to  either  1200  baud  or9600 baud, as desired.

* Turn on the LaserWriter and start the computer's telecom-munication program.  The program should use the following:

* Baud rate of 1200 or 9600, depending on the printer's

switch setting.

* XON/XOFF protocol.

* Seven bit data.

* No Parity.

At this point your keyboard input will be sent through the seriallink  to  the  LaserWriter.  To  start  the  LaserWriter's  interactive

mode,  type  the  command executive followed  by  a  return  (thiswill not be echoed). You will receive an opening message from
the interpreter and then a command prompt:

PS>

Using Interactive Mode
You  will  now  be  typing  directly  to  the  POSTSCRIPT interpreter.All input will be interpreted as P

OSTSCRIPT code. You can sendprograms to the interpreter in two ways:

* You  can  type  the  program  directly  into  the  interpreter.Each  line  of  P

OSTSCRIPT code  will  be  carried  out  as  it  isreceived by the printer.

* You can use the telecommunications program to downloada previously-prepared text file that contains  a P

OSTSCRIPTprogram.  If  you  are  using  MacTerminal,  you  should  use

the following file transfer settings:

* Transfer Method: Text.

* Remote System: Other.

* Retain Line Breaks: Yes.

* Word Wrap Outgoing Text: No.

120 Chapter 12:  POSTSCRIPT PRINTERS

    

Leaving Interactive mode
To  leave  interactive  mode,  type  in  the  POSTSCRIPT commandquit. Do not forget to return the LaserWriter's switch to the setting appropriate to its use as a printer.
For a complete discussion of the LaserWriter's interactive mode,please  refer  to  the  section  on  the  Apple  LaserWriter  in  the

POSTSCRIPT Language Reference Manual.

12.1  APPLE LASERWRITER 121

   

INTRODUCTION
The POSTSCRIPT Language Cookbook is a collection of completeprogramming  examples  intended  to  teach  you  how  to  write

programs  in  the  POSTSCRIPT language.  It  is  assumed  that  youhave covered the material in the P

OSTSCRIPT Language Tutorial(the first half of this book), have access to the P

OSTSCRIPT Lan-guage  Reference  Manual and  have  some  programming  background. It is  possible, though, for someone with very little pro-gramming experience to use the ``Cookbook'' effectively.

The ``recipes'' (programming examples) presented in the Cook-book fall into two basic categories: programs that are ``ready to

use'' and programs that are intended as ``inspiration.'' Many ofthe programs contain commonly used procedure definitions that
may  be  inserted  into  larger  programs  without  modification.  Forexample,  an  application  that  prints  geometric  objects  would  include  the  procedure  to  draw  an  ellipse  as  presented  in  theprogram  ``Elliptical  Arcs.''  Other  programs  are  most  useful  for
the techniques presented; they demonstrate specific applicationsto serve as a model for other applications or to serve as a starting
point for further development.

FORMAT OF THE EXAMPLES

Each programming example begins with a reduced version of theoutput page produced by the program. The 8-1/2 inch by 11 inch

page has been reduced to be 70% of its original size. Small tick-marks  near  the  top  edge  and  the  left  edge  of  the  page  indicate

125

   

scaled  inches  for  easier  reference.  There  is  also  a  scale  at  thebottom  of  the  page  that  shows  the  measurement  of  an  inch  for
this reduced page size.
The  pages  that  present  the  actual  programs  have  been  dividedinto  two  columns.  The  left  column  is  the  program  itself.  The

right column is a commentary on the program.
In the case of programs that are two pages long, the output pageis intentionally repeated.

HOW TO USE THE COOKBOOK

The POSTSCRIPT Language  Cookbook is  divided  into  four  sec-tions:  Basic Graphics, Printing Text, Applications, and Modifying and Creating Fonts. Each section begins with a brief discus-sion of the important points presented and is followed by a collection  of  program  examples.  The  programs  in  the  Cookbookcover a range of difficulty. The easier programs tend to be near
the beginning and the more complex programs towards the end,although there is no clearly defined progression of difficulty.

Each  program  is  independent  of  the  others  but  occasionally  thecommentary  for  a  program  may  rely  on  commentary  from  an

earlier program. In such cases a reference is made to the earlierprogram.

The best way to use the Cookbook is to try running the programson a P

OSTSCRIPT interpreter (usually resident in a printer). Thentry modifying the program by changing arguments to procedures,

for example, or by using different fonts. You can also try com-bining  procedure  definitions  from  various  programs  to  create
more sophisticated programs.
The  Cookbook  attempts  to  present  a  reasonable  programmingstyle and you may find that you develop your own P

OSTSCRIPTprogramming  style.  P
OSTSCRIPT is  a  very  rich  language  (thereare  approximately  250  operators  in  the  standard  language!)  and

there  are  often  many  different  ways  of  expressing  the  sameoperation.  For  example,  the  following  two  program  fragments
achieve  the  same  result:  they  copy  the  top  two  elements  of  theoperand stack.

126 INTRODUCTION

  

2 copy
1 index 1 index
Many of the programs contain commonly used POSTSCRIPT pro-gramming  idioms.  One  such  idiom  is  the  program  fragment  to

push the coordinates of the bounding box of a character onto theoperand stack:

newpath0 0 moveto
(A) true charpath flattenpath pathbbox
This series of operators is used every time the bounding box of acharacter  needs  to  be  determined.  (This  idiom  is  explained  in

detail  in  the  ``Setting  Fractions''  and  ``Printing  with  SmallCaps'' program examples.)

Occasionally  you  will  find  that  efficiency  was  sacrificed  forclarity  in  some  of  the  examples  (clarity  was  more  important  in

this  tutorial  presentation).  More  efficient  implementations  areleft as exercises to the reader.

HOW TO USE THE COOKBOOK 127

 

Repeated Shapes  Expanded and Constant Width Lines  Elliptical Arcs 

Drawing Arrows  Centered Dash Patterns  Printing Images 

   

PROGRAMS 1- 6

BASIC GRAPHICS

The  programs  presented  in  this  section  are  generally  simpler  innature  than  programs  presented  in  later  sections.  They  concentrate on the basic techniques for defining shapes, performingcoordinate system transformations and printing images.

ABOUT THE PROGRAMS

The first program, ``Repeated Shapes,'' demonstrates a synthesisof  many  of  the  basic  P

OSTSCRIPT graphic  constructs:  definingpaths, using the scale and rotate transformations, and using the

graphic  output  operators fill and stroke.  It  exemplifies  how  ashort  and  simple  P

OSTSCRIPT program  can  generate  interestinggraphic images.

The  next  program,  ``Expanded  and  Constant  Width  Lines,''shows  how  to  control  the  scaling  transformation  to  get  differently  scaled  lines.  The  techniques  presented  in  this  programare  not  only  restricted  to  lines  but  may  be  applied  to  any  other
graphic object including fonts.
``Elliptical Arcs'' introduces an important technique: using dic-tionaries to define local variables (see description below). In addition, it demonstrates how to build a procedure, ``ellipse,'' fromthe standard P

OSTSCRIPT operators. The behavior and argumentlist  of  the  ``ellipse''  procedure  are  modeled  after  the arc

operator.  Users  are  free  to  define  new  procedures  inP

OSTSCRIPT:  this  is  what  makes  the  language  so  powerful  andflexible.

129

    

``Drawing Arrows'' defines a general procedure that can be usedto draw any kind of straight arrow. This is a useful primitive in

the larger context of making illustrations.
``Centered  Dash  Patterns''  focuses  on  a  detail  of  the setdashoperator: the offset argument. By carefully calculating the value

of the offset, it's possible to center any dash pattern on any path.Included  in  this  program  is  a  useful  general  procedure,
``pathlength,'' that computes the length of any arbitrary path inthe current user space.

``Printing Images'' demonstrates how to use the image operator,how to modify the transfer function, and how to read the data for

the  image  from  the  current  file.  This  technique  of  reading  datafrom the current file can be applied to many other situations such
as text processing.

DICTIONARIES AND LOCAL VARIABLES

The  POSTSCRIPT language  is  not  as  highly  structured  as  otherprogramming languages such as Pascal or Algol. There is no explicit  method  for  specifying  the  scope  of  variables.  Instead  onehas  to  ``simulate''  the  scoping  mechanism  through  the  careful
use  of  dictionaries,  the  dictionary  stack,  and  the  dictionaryoperators.

First let's review some of the basic concepts underlying the dic-tionary  mechanism.  The def operator  associates  a  key  with  a

value and that key-value pair is stored in the current dictionary.The  current  dictionary  is  always  the  topmost  dictionary  on  the
dictionary stack. A new dictionary can be created (using the dictoperator)  and  it  can  be  pushed  onto  the  dictionary  stack  (using
the begin operator), thereby making it the current dictionary.
When the POSTSCRIPT interpreter encounters a name, it searchesfor  a  definition  of  that  name  in  the  dictionary  stack  beginning

with the topmost (current) dictionary and working its way downthe dictionary stack until it finds the first instance of that name.
Due  to  the  nature  of  this  name  search  process,  dictionaries  be-come the context for the scope of names.

Local  variables  are  simulated  by  creating  a  new  dictionary,

130 BASIC GRAPHICS

   

pushing  it  onto  the  dictionary  stack,  performing def operations,and  then  popping  that  new  dictionary.  As  long  as  the  new  dictionary remains on the dictionary stack, we will find the ``local''value for the variable when a name search is done. Once the new
dictionary  is  popped  from  the  dictionary  stack,  the  values  fornames  defined  within  the  context  of  this  dictionary  will  no
longer be found (although if a variable by that same name weredefined  in  another  dictionary  still  on  the  dictionary  stack,  that
value would be returned in the name search). Methodically push-ing and popping dictionaries is what gives variables their scope.
The following example illustrates this mechanism:
Example:

/thestring (global) def % 1thestring = % 2
/exampledict 1 dict def % 3exampledict begin % 4

thestring = % 5/thestring (local) def % 6
thestring = % 7end % 8
thestring = % 9
The output produced by this program looks like:

globalglobal
localglobal

Description of the program: The first line defines the variable``thestring' to have the value ``(global).'' Line 2 prints the value

of ``thestring'' on the standard output. Line 3 creates a diction-ary  called  ``exampledict''  to  be  used  for  local  storage  of  variables.  Line  4  pushes  ``exampledict''  onto  the  dictionary  stack,making  it  the  current  dictionary.  Line  5  prints  the  value  of
``thestring'' again. Since ``thestring'' has not yet been defined inthe  current  dictionary,  the  value  in  the  next-to-topmost  dictionary  is  printed.  Line  6  defines  ``thestring''  to  have  the  value``(local)'' within the context of ``exampledict'' and this value is
the one found when ``thestring'' is printed in line 7. Line 8 pops``exampledict''  from  the  dictionary  stack.  Line  9  prints  the

DICTIONARIES AND LOCAL VARIABLES 131

  

original  value  of  ``thestring''  since  the  value  defined  in``exampledict'' is no longer found.
The  dictionary  mechanism  can  be  used  with  POSTSCRIPTprocedures  to  simulate  local  variables  in  the  following  manner:

create a new dictionary that is large enough to hold all the defini-tions made within the procedure. The first operation in the procedure should push this dictionary onto the dictionary stack and thelast operation in the procedure should pop it from the dictionary
stack.  The  following  is  a  small  example  that  can  be  used  as  atemplate:

/localdict 1 dict def/sampleproc

{ localdict begin/localvariable 6 def

end} def

In general it is not a good idea to create the dictionary within theprocedure because each procedure call allocates new memory for

the  dictionary.  This  can  use  up  a  lot  of  virtual  memory  if  theprocedure is called repeatedly. The following example illustrates
a  procedure  that  creates  a  new  dictionary  each  time  the  proce-dure is executed:

/sampleproc{ 1 dict begin  % this allocates new VM each time

/localvariable 6 defend
} def
Although it uses more memory, the above method does have theadvantage that each time the procedure is called, an entirely new

context  is  created,  whereas  with  the  previous  method,  the  oldcontext is invoked each time the procedure is called.

There  is  another  method  for  pushing  a  dictionary  onto  the  dic-tionary stack as the first operation in a procedure without having

to give the dictionary a name. This technique is advantageous fortwo  reasons.  The  first  reason  is  that  it  serves  as  a  form  of
``information hiding'' since the dictionary cannot be accessed byname; it can only be accessed within the procedure that contains

132 BASIC GRAPHICS

  

it.  The  second  reason  is  that  it  saves  key  (name)  space  in  theenclosing  dictionary  where  the  procedure  definition  is  made
since  the  dictionary  itself  has  no  name;  the  savings  on  namespace become significant when many procedures requiring local
variables are defined in a program.

/sampleproc % 1{ 0 begin % 2

/localvariable 6 def % 3end % 4
} def % 5/sampleproc load 0 1 dict put % 6

Recall  that  procedures  are  actually  executable  arrays.  The  ``0''in  line  2  of  the  program  merely  serves  as  a  placeholder  for  the

reference  to  the  local  dictionary.  Line  6  creates  the  dictionaryand inserts it into the placeholder position. First the procedure is
pushed onto the operand stack as an array object. Then the dic-tionary is created and inserted as the zeroth element of the procedure array. From now on a reference to the dictionary will existin  the  zeroeth  position  of  the  procedure array.  When the  procedure  is called,  the  first operation  pushes  the dictionary  onto  thedictionary  stack.  This  technique  is  used  in  the  programs
``Creating an Analytic Font'' and ``Creating a Bitmap Font.''

DICTIONARIES AND LOCAL VARIABLES 133

 

1 inch
72 points

   

135
Program 1 / Repeated Shapes
This program prints a rosette design by defining asection of that design and then printing that section
repeatedly. This program illustrates the for and arcoperators, and it shows how coordinate transformations
can be nested to use the most convenient coordinatesystem for each part of a design.

/inch {72 mul} def
/wedge  { newpath
      0 0 moveto      1 0 translate
      15 rotate      0 15 sin translate
      0 0 15 sin -90 90 arc    closepath
  } def

Define an ``ice cream cone'' shape with the arcoperator. This shape will have a 30 degree angle topped
off with a semicircle. Set the path's first point at thecurrent origin. Next, move the origin to the center of the
semicircle by translating to the right 1 unit, rotatingcounter-clockwise by 15 degrees, and translating ``up''
in the rotated system by the radius of the semicircle. Thearc operator includes a straight line to the initial point
of the arc and a curved section to the end of the arc.Note that the semicircle goes from -90 degrees to 90
degrees in the rotated coordinate system. 
gsave Remember the default coordinate system.  3.75 inch 7.25 inch translate Move into position for a sample of the wedge.
  1 inch 1 inch scale Make the edge of the wedge 1 inch long.  wedge 0.02 setlinewidth stroke Draw the wedge with a 1/50 inch thick line.
grestore Get back to default coordinates.
gsave  4.25 inch 4.25 inch translate Move into position for the rosette.
  1.75 inch 1.75 inch scale Make the edges of the rosette 1 3/4 inches long.  0.02 setlinewidth Use a 7/200 inch thick line.
  1 1 12 Set up the for operator to iterate 12 times.   { 12 div setgray Divide the loop index by 12 to set a gray value.
     gsave       wedge Enclose the ``wedge'' operation in a gsave - grestorepair, as it will transform the coordinate system. 
       gsave  fill  grestore Save the wedge path for use after the fill.       0 setgray stroke Draw a black border around the wedge.
     grestore Get out of the coordinate system left by wedge.     30 rotate Set up for the next section.
   } for Close the procedure body and execute the for operator.grestore

showpage

 

1 inch
72 points

   

137
Program 2 / Expanded and Constant Width Lines

This example demonstrates different effects achievedunder the scaling transformation. Normally the line
width used with the stroke operator is scaled accordingto the current user coordinate system. This is
demonstrated in the set of squares drawn on the left sideof the page. It is possible to maintain a constant line
width although the user coordinate system is beingscaled arbitrarily. This is shown in the set of squares
drawn on the right side of the page./inch {72 mul} def
/centersquare  { newpath
      .5 .5 moveto    -.5 .5 lineto      -.5 -.5 lineto   .5 -.5 lineto
    closepath  } def

``centersquare'' will draw a unit square centered on thecurrent coordinate system origin. A square described in
terms of its center, rather than in terms of one of itscorners, is more convenient for this example since we
will be drawing concentric squares. 

gsave Remember the original coordinate system.  2.5 inch 6 inch translate Place the origin for the expanding line width squares.
  1 16 div setlinewidth  1 1 5 Set up a ``for'' loop to execute five times.
    { gsave Remember the current coordinate system.        .5 mul inch dup scale Scale the current units by 1/2 inch times the loop index.
        centersquare        stroke The stroked square has a line width proportional to thecurrent scale. 
      grestore Return to the translated, unscaled coordinate system.    } for
grestore Return to the original untranslated coordinate system.
gsave  6 inch 6 inch translate Place the origin for the constant line width squares.
  1 setlinewidth Set the line width to be 1 point.  /cmtx matrix currentmatrix def
  1 1 5 Store the current transformation matrix, i.e., the currentcoordinate system, in the variable ``cmtx''.     { gsave Remember the translated coordinate system.
        .5 mul inch dup scale Scale the squares as before.        centersquare Create the square path, but don't stroke it yet.
        cmtx setmatrix        stroke Change the coordinate space back to the unscaled one,where the line width is truly 1/72nd of an inch thick. We

explicitly reset only the coordinate space rather than usea grestore, since grestore resets the current path as
well as the current coordinate system.       grestore
    } for After stroking the path, return to the translated, unscaledcoordinate system. grestore Return to the original untranslated coordinate system.
showpage

 

1 inch
72 points

   

139
Program 3 / Elliptical Arcs
This program demonstrates how to build a procedure fordrawing elliptical arcs from the basic P

OSTSCRIPTgraphic primitives. It also demonstrates the use of

dictionaries to implement local variables.
/ellipsedict 8 dict def Local storage for the procedure ``ellipse.''ellipsedict /mtrx matrix put Allocate a matrix for the save matrix operation below;

make it local to the procedure ``ellipse.''
/ellipse  { ellipsedict begin
      /endangle exch def      /startangle exch def
      /yrad exch def      /xrad exch def
      /y exch def      /x exch def

``ellipse'' adds a counter-clockwise segment of anelliptical arc to the current path. It takes six operands:
the x and y coordinates of the center of the ellipse (thecenter is defined as the point of intersection of the major
and minor axes), the ``radius'' of the ellipse in the xdirection, the ``radius'' of the ellipse in the y direction,
the starting angle of the elliptical arc and the endingangle of the elliptical arc. Since the first operation in
this procedure pushes ``ellipsedict'' onto the dictionarystack and the last pops that dictionary from the
dictionary stack, all def operations are local in scope. 
The basic strategy for defining the ellipse is to translateto the center of the ellipse, scale the user coordinate
system by the x and y radius values, and then add acircular arc, centered at the origin with a 1 unit radius to
the current path. We will be transforming the usercoordinate system with the translate and rotate
operators to add the elliptical arc segment but we don'twant these transformations to affect other parts of the
program. In other words, we would like to isolate theeffect of the transformations. Usually the gsave and
grestore operators would be ideal candidates for thistask. Unfortunately gsave and grestore are
inappropriate for this situation because they do not savethe arc segment that has been added to the path. Instead
we will isolate the effect of the transformations bysaving the current transformation matrix and restoring it
explicitly after adding the elliptical arc to the path.
      /savematrix mtrx currentmatrix def Save the current transformation.      x y translate Translate to the center of the ellipse.
      xrad yrad scale Scale by the x and y radius values.      0 0 1 startangle endangle arc Add the arc segment to the path.
      savematrix setmatrix Restore the transformation.    end
  } def

 

1 inch
72 points

    

141
Program 3 / Elliptical Arcs

(continued)

newpath  144 400 72 144 0 360 ellipse
stroke

Draw a full ellipse and outline it with a stroke. Notethat the y-axis is longer than the x-axis. 

newpath  400 400 144 36 0 360 ellipse
fill

Draw a full ellipse and fill it with black. Note that they-axis is shorter than the x-axis. 

newpath  300 180 144 72 30 150 ellipse
stroke

Draw a portion of an elliptical arc and outline it with astroke. 

newpath  480 150 30 50 270 90 ellipse
fill

Draw a portion of an elliptical arc and fill it with black.Note that although the path is not explicitly closed by
the ``ellipse'' procedure, the fill operation implicitlycloses the path for us. 
showpage

 

1 inch
72 points

  

143
Program 4 / Drawing Arrows
This program demonstrates how to define a generalprocedure for drawing various kinds of straight arrows.
/arrowdict 14 dict def Local storage for the procedure ``arrow.''arrowdict begin
  /mtrx matrix defend Allocate a matrix for storing the current matrix below.Make it local to the procedure ``arrow.'' 

/arrow  { arrowdict begin
      /headlength exch def      /halfheadthickness exch 2 div def
      /halfthickness exch 2 div def      /tipy exch def /tipx exch def
      /taily exch def /tailx exch def

``arrow'' adds an arrow shape to the current path. Ittakes seven arguments: the x and y coordinates of the
tail (imagine that a line has been drawn down the centerof the arrow from the tip to the tail, then x and y lie on
this line), the x and y coordinates of the tip of the arrow,the thickness of the arrow in the tail portion, the
thickness of the arrow at the widest part of thearrowhead and the length of the arrowhead. 

      /dx tipx tailx sub def      /dy tipy taily sub def
      /arrowlength dx dx mul dy dy mul add        sqrt def
      /angle dy dx atan def

Compute the differences in x and y for the tip and tail.These will be used to compute the length of the arrow
and to compute the angle of direction that the arrow isfacing with respect to the current user coordinate system
origin.       /base arrowlength headlength sub def Compute where the arrowhead joins the tail.

      /savematrix mtrx currentmatrix def Save the current user coordinate system. We are usingthe same technique to isolate the effect of

transformations as was used in the program to drawelliptical arcs.
      tailx taily translate Translate to the starting point of the tail.      angle rotate Rotate the x-axis to align with the center line of the

arrow.      0 halfthickness neg moveto Add the arrow shape to the current path.
      base halfthickness neg lineto      base halfheadthickness neg lineto
      arrowlength 0 lineto      base halfheadthickness lineto
      base halfthickness lineto      0 halfthickness lineto
      closepath
      savematrix setmatrix Restore the current user coordinate system.    end
  } def

 

1 inch
72 points

   

145
Program 4 / Drawing Arrows

(continued)

newpath  318 340 72 340 10 30 72 arrow
fill

Draw a filled arrow with a thin tail and a longarrowhead. 

newpath  382 400 542 560 72 232 116 arrow
3 setlinewidth stroke

Draw an outlined arrow with a 90 degree angle at thetip. To get a 90 degree angle, the ``headthickness''
should be twice the ``headlength.'' 
newpath  400 300 400 90 90 200 200 3 sqrt mul 2 div
    arrow .65 setgray fillshowpage

Draw a gray-filled arrow that has an equilateral triangleas its arrowhead. To get an equilateral triangle, the
``headlength'' should be the square root of 3 divided by2 times the ``headthickness.'' 

 

1 inch
72 points

   

147
Program 5 / Centered Dash Patterns

This program demonstrates the use of the offsetargument to the setdash operator to center any dash
pattern on a continuous path. The algorithm presentedwill not give the expected results if the path is
discontinuous or closed. Included in this example is avery useful procedure, ``pathlength,'' that computes the
length of an arbitrary path.
/centerdash  { /pattern exch def The procedure ``centerdash'' will center a dash patternon a path such that the dashes at the end points are

identical. It takes an array describing the dash pattern asits argument. 
    /pathlen pathlength def In order to center the dash pattern on the path we needto determine the length of the path. (See the definition

of ``pathlength'' below.)    /patternlength 0 def
    pattern      { patternlength add /patternlength exch def
      } forall

First determine the total length of the repeating patternby summing the elements of the dash array. 

    pattern length 2 mod 0 ne      { /patternlength patternlength 2 mul def } if If the pattern array is an odd number of elements,double the pattern length so that we can get identical

end points. 
    /first pattern 0 get def Get the length of the first element in the pattern arrayfor use later.
    /last patternlength first sub def Calculate the length of the remaining part of the pattern.
    /n pathlen last sub patternlength idiv def    /endpart pathlen patternlength n mul sub
       last sub 2 div def

Now calculate the offset provided to the setdashoperator so that the dashes at the end points are
identical. Think of the path as being composed of 4distinct parts: 2 identical end parts, 1 part which is
composed of ``n'' repeating pattern pieces and 1 partwhich is the remaining piece of the pattern. We can
compute the lengths of the remaining piece and the partcomposed of ``n'' repeating pattern pieces and from
these determine the length of the end part.     /offset first endpart sub def The amount of offset is then given by the difference in
length of the first part and the end part.    pattern offset setdash
  } def Set up the dashing parameters using the offset computedabove. 

 

1 inch
72 points

    

149
Program 5 / Centered Dash Patterns

(continued)

/pathlength  { flattenpath
    /dist 0 def

The procedure ``pathlength'' computes the length of anygiven path. It does so by first ``flattening'' the path with
the flattenpath operator. flattenpath converts anycurveto and arc segments in a path to a series of
lineto segments. Then the pathforall operator is usedto access each segment in the path, find its length and
add the length to a total.     { /yfirst exch def /xfirst exch def
      /ymoveto yfirst def /xmoveto xfirst def } Remember the coordinates of the most recent movetoso that the length of the closepath can be computed.     { /ynext exch def /xnext exch def
      /dist dist ynext yfirst sub dup mul          xnext xfirst sub dup mul add sqrt add def 
      /yfirst ynext def /xfirst xnext def}

For each lineto segment, compute the distance betweenthe current point and the previous point. 

    {} The curveto procedure does nothing since thereshouldn't be any curveto segments in the path after a

flattenpath.    { /ynext ymoveto def /xnext xmoveto def
      /dist dist ynext yfirst sub dup mul          xnext xfirst sub dup mul add sqrt add def 
      /yfirst ynext def /xfirst xnext def}

The coordinates for a closepath segment are thecoordinates of the most recent moveto. 

    pathforall    dist Leave the length of the path on the operand stack.
  } def
5 setlinewidth Set up the line width.
newpath  72 500 moveto 378 500 lineto
[30] centerdash  stroke

Center a very simple dash pattern in which the unfilleddashes have the same length as the filled ones. 

newpath  72 400 moveto 378 400 lineto
[30 50] centerdash  stroke

Center a pattern which is similar to the above exampleexcept that the unfilled dashes are longer than the filled
ones. 
newpath  72 300 moveto 378 300 lineto
[30 10 5 10] centerdash  stroke

Center a dot-dash pattern. 

newpath  72 200 moveto 378 200 lineto
[30 15 10] centerdash  stroke

Center an asymmetric pattern. 

newpath  225 390 300 240 300 arc
[40 10] centerdash  stroke

Center a dash pattern on an arbitrary continuous path, inthis case an arc. 

showpage

 

1 inch
72 points

   

151
Program 6 / Printing Images
This program demonstrates the use of the imageoperator. It also shows a useful technique for reading the
data for the image from the current file. An importantgeneral procedure, ``concatprocs,'' is defined and used
in redefining the transfer function.
/concatprocs  { /proc2 exch cvlit def
    /proc1 exch cvlit def

``concatprocs'' takes two procedure bodies asarguments and concatenates them into one procedure
body. The resulting procedure body is left on theoperand stack. ``concatprocs'' will be used in
constructing a new transfer function below.     /newproc proc1 length proc2 length add
      array def Create a new array large enough to accommodate bothprocedures.     newproc 0 proc1 putinterval Place the 1st procedure at the beginning of the new one.
    newproc proc1 length proc2 putinterval Place the second procedure at the end of the new one.    newproc cvx Now make this array into an executable object.
  } def
/inch { 72 mul } def/picstr 3 string def String used in reading hexadecimal strings below (each

row is 3 bytes long).
/imageturkey  { 24 23 1 [24 0 0 -23 0 23]
      { currentfile picstr readhexstring pop }      image
  } def

The procedure ``imageturkey'' reads the image (ashexadecimal strings) from this file and prints it on the
page. The image of the turkey is represented as one bitper sample. It is 24 samples wide by 23 samples high
and its first sample is in the upper left corner of thesource image. 

The image we generate is mapped to the unit square inuser space. This unit square has its lower left corner at
the origin and extends 1 unit in the positive x and ydirections. Translate the user space origin to center the
image on the page. Then scale the coordinate system toget a larger unit square.

gsave Isolate the effects of the settransfer.  3 inch 4 inch translate Position the unit square on the page.
  2 inch dup scale Scale it to be 2 inches square.

 

1 inch
72 points

    

153
Program 6 / Printing Images

(continued)

  {1 exch sub} currenttransfer concatprocs    settransfer Since the source samples for our image specify a reverseimage (that is, the samples that correspond to ``black''

are specified as 1's rather than 0's) we specify a transferfunction to reverse this effect. Since some output
devices have complex transfer functions we don'tsimply want to set the transfer function. Instead we want
to concatenate our new transfer function with theexisting one to achieve our results. 

  imageturkey  003B00 002700 002480 0E4940
  114920 14B220 3CB650 75FE88  17FF8C 175F14 1C07E2 3803C4
  703182 F8EDFC B2BBC2 BB6F84  31BFC2 18EA3C 0E3E00 07FC00
  03F800 1E1800 1FF800

As soon as ``imageturkey'' is executed, the currentfile... readhexstring sequence will begin reading bytes
from this file. The safest way to synchronize readingfrom the program file with the P

OSTSCRIPT interpreter'sown reading of this file is to embed the reading

commands in a procedure, then place that procedurename followed by a ``carriage return'' followed by the
bytes to be read in the file. In the hexadecimal stringspecified here, each series of 6 hexadecimal numbers
represents a row of bits in the turkey bitmap. Eachhexadecimal character represents a pattern of four 0's or
1's where 0's are black and 1's are white. Notice thatthis image is specified as a ``reverse'' image since the
turkey is white and the background is black. grestore
showpage The image command reads exactly the number of byteswe supplied, and the interpreter picks up its readinghere. 

    

PROGRAMS 7-11
PRINTING TEXT

The  programs  in  this  section  contain  procedures  that  are  veryuseful  in  typesetting.  They  also  provide  guidelines  for

sophisticated  typography.  The  fonts  available  through  theP

OSTSCRIPT language  give  us  a  great  deal  of  flexibility  sincethey  can  be  arbitrarily  scaled  and  rotated.  Without  this

flexibility, most of these programs could not be written. Most ofthe programs in this section are fairly short and simple since the
POSTSCRIPT language  has  an  extensive  set  of  operators  formanipulating fonts and printing text.

ABOUT THE PROGRAMS

The program ``Printing with Small Caps'' defines a general pro-cedure called ``scshow'' for printing a string of capital letters as

small  caps in  the  current  font.  In  traditional  typography,  smallcaps  are  capital  letters  that  have  been  designed  to  match  the  xheight  of  a  particular  typeface;  they  are  smaller  in  height  thanregular capital letters. The ``scshow'' procedure generates small
caps  of  the  proper  proportions  to  coordinate  with  the  currentfont.  In  order  to  get  the  proper  proportions,  the  font  must  be
scaled anamorphically; this is accomplished using the makefontoperator.

``Printing  with  Small  Caps''  also  illustrates  an  important  tech-nique for computing the bounding box of a character. Since the

proportions used for the size of the small caps are derived from aratio of the cap height to the x-height of the font, these two quan155

   

tities  must  be  determined.  By  finding  the  bounding  box  of  thecapital X and the lowercase x, we can determine the cap height
and x-height respectively.
``Setting  Fractions''  defines  a  general  procedure  called``fractionshow''  that  prints  a  fraction  in  the  current  font  given

the  numerator  and  denominator  of  the  fraction.  The  numeralsused to print the numerator and denominator are smaller in size
than  the  standard  numerals  in  a  font.  Once  again  the makefontoperator  is  used  to  scale  the  current  font  anamorphically  to  get
the proper proportions.
``Vertical  Text''  defines  a  general  procedure,  ``vshow,''  forprinting a string vertically on the page. Such a procedure is useful  in  labeling  graphs  and  illustrations.  The  output  of  theprogram  demonstrates  that  text  printed  vertically  tends  to  look
better when the text consists of capital letters only.
``Circular Text'' defines two procedures for printing text along acircular arc. The flexibility of  the P

OSTSCRIPT fonts makes  thisexample possible since characters can be printed at any arbitrary

angle of rotation.
``Placing Text Along an Arbitrary Path'' carries the circular textidea one step further and defines a procedure to print text along a

path of arbitrary shape.

156 PRINTING TEXT

 

157
  

1 inch
72 points

To read means to obtain meaning from words, andlegibility is 

THAT QUALITY WHICH enables wordsto be read easily, quickly, and accurately.

JOHN C. TARR

   

159
Program 7 / Printing with Small Caps

This program defines a general procedure for printingwith small caps.
/scdict 3 dict def Local storage for the procedure ``scshow.''/scshow
  { scdict begin ``scshow'' takes one argument, a string, and shows it assmall caps for the current font. It makes the assumptionthat the characters in the string are upper case letters

(i.e., it does not convert characters from lower case toupper case). 
    gsave Save the current graphics state so that changes made tothe current font are localized to this procedure.
      currentfont [.9 0 0 findscscale 0 0] makefont        setfont Scale the current font by 90 percent in the x-directionand to the proper size in the y-direction (see the

``findscale'' procedure below).       show Show the string.
      currentpoint    grestore
    moveto    end
  } def

Upon exiting this procedure, we would like the currentpoint to be just after the last small cap character shown
so that ``scshow'' behaves like the show operator.Unfortunately performing the grestore will return us to
our position on the page before the small cap string wasshown. To avoid this side-effect, push the current point
onto the operand stack before performing the grestoreoperation and then move to that point before exiting the
procedure. scdict begin
  /findscscale    { gsave
        newpath          0 0 moveto
          (X) true charpath        flattenpath
        pathbbox /capheight exch def pop pop pop        newpath
          0 0 moveto          (x) true charpath
        flattenpath        pathbbox /xheight exch def pop pop pop
      grestore

``findscscale'' determines the correct scale factor forderiving small caps to coordinate with the current font.
The height of the small caps should be the x-height (i.e.,the height of a lower case x) plus one third of the
difference between the x-height and the cap height. Thecap height and x-height are found using the following
method: Create a new path and set the current point tobe the origin. Then execute the charpath operator to
add a description of the character to the current path.The flattenpath operator replaces any curveto
segments in the path with sequences of straight lines sothat the pathbbox operator will return a bounding box
that fits the path as closely as possible (otherwise thecontrol points for the curves are included in the
bounding box computation and these almost always lieoff of the path outline). 
      xheight capheight xheight sub 3 div add        capheight div Leave the scale factor on the operand stack. 
    } defend

  

1 inch
72 points

To read means to obtain meaning from words, andlegibility is 

THAT QUALITY WHICH enables wordsto be read easily, quickly, and accurately.

JOHN C. TARR

   

161
Program 7 / Printing with Small Caps

(continued)

/Times-Roman findfont 18 scalefont setfont
72 500 moveto(To read means to obtain meaning from) show
( words, and) show
72 500 20 sub moveto(legibility is ) show
(THAT QUALITY WHICH) scshow( enables words) show

72 500 20 2 mul sub moveto(to be read easily, quickly, and accurately.) show
72 500 70 sub moveto(JOHN C. TARR) scshow

The following is an example of using small caps in aparagraph of text. When setting words in capital letters,
the results are most aesthetically pleasing when smallcaps are used. 

showpage

  

1 inch
72 points7/8

Slowly stir in 51/2 lbs. of chocolate and then blend on high.

13/22

3/4

   

163
Program 8 / Setting Fractions
This program defines a general procedure for printingfractional quantities.
/fractiondict 5 dict def Local storage for the procedure ``fractionshow.''/fractionshow
  { fractiondict begin      /denominator exch def
      /numerator exch def

``fractionshow'' takes two arguments: a string for thenumerator and a string for the denominator. 

      /regularfont currentfont def Remember the current, unchanged font.      /fractionfont currentfont [.65 0 0 .6 0 0]
        makefont def Create a new font for printing the numerator anddenominator. Scaling the original font by 65 percent inthe x direction and 60 percent in the y direction yields

the best results. 
      gsave        newpath
          0 0 moveto          (1) true charpath
        flattenpath pathbbox        /height exch def pop pop pop
      grestore

The numerator should be top-aligned with the numeralheight (usually the height of the numeral one). In order
to position the numerator, the height of the numeral onein the current font must be computed. The method used
is to create a new path and set the current point to be theorigin. Then execute the charpath operator to add a
description of the character to the current path. Theflattenpath operator replaces any curveto segments in
the path with sequences of straight lines so that thepathbbox operator will return a bounding box that fits
the path as closely as possible (otherwise the controlpoints for the curves are included in the bounding box
computation and these almost always lie off of the pathoutline). 

      0 .4 height mul rmoveto The numerator is positioned at 40 percent of the heightof the numeral one so that it aligns with the numeral

height (since it has been scaled by 60 percent).      fractionfont setfont numerator show Print the numerator string.
      0 .4 height mul neg rmoveto Move back down to the baseline.      regularfont setfont (\244) show Print the fraction bar (octal code 244) in the full-size

font. The fraction bar character has been designed withnegative sidebearings such that it naturally gets
positioned properly with respect to the scaled downnumbers.
      fractionfont setfont denominator show Print the denominator string.      regularfont setfont Return to the original font.
    end  } def

  

1 inch
72 points7/8

Slowly stir in 51/2 lbs. of chocolate and then blend on high.

13/22

3/4

   

165
Program 8 / Setting Fractions

(continued)

/Times-Roman findfont 300 scalefont setfont100 72 moveto
(7) (8) fractionshow

Print a large fraction near the bottom of the page. 

/Times-Roman findfont 18 scalefont setfont72 550 moveto
(Slowly stir in 5) show(1) (2) fractionshow
( lbs. of chocolate and then blend on high.) show

Demonstrate a fraction intermingled with text. 

/Times-Roman findfont 40 scalefont setfont420 650 moveto
(13) (22) fractionshow100 450 moveto
(3) (4) fractionshow

Show a smaller fraction composed of two digit numbers.

showpage

 

1 inch
72 points

TE
XT

 P
OS

IT
IO
NE
D 

VE
RT

IC
AL

LY

SH
OU

LD

 B
E 
CE
NT

ER
ED

 O
N

A 
CO
MM

ON

 C
EN

TE
R 

LI
NE

.

VE
RT

IC
AL

 T
EX

T 

IN
 C
AP

IT
AL

LE
TT
ER
S 
HA

S 
MO

RE

 E
VE
N

sp
ac

in
g 

th
an

 l
ow
er

 c
as
e 

le
tt
er

s.

   

167
Program 9 / Vertical Text
This program defines a general procedure for printingtext vertically (with respect to the user coordinate
system).
/vshowdict 4 dict def Local storage for the procedure ``vshow.''
/vshow  { vshowdict begin
    /thestring exch def    /lineskip exch def

``vshow'' will display text vertically, centering it on acommon center line. ``vshow'' takes two arguments, the
lineskip between letters and the string to be shown. 
    thestring      { The forall operator allows us to repeat the sameprocedure for each character in the string. 
        /charcode exch def forall pushes the character code onto the operand stack.        /thechar ( ) dup 0 charcode put def Convert the character code to a one-character string.

        0 lineskip neg rmoveto Move down by the lineskip amount.        gsave
          thechar stringwidth pop 2 div neg 0 rmoveto Move left by half of the character width.          thechar show Display the character.
        grestore      } forall
    end  } def

/Helvetica findfont 16 scalefont setfont Set up the font we wish to use.
72 576 moveto16 (TEXT POSITIONED VERTICALLY) vshow
122 576 moveto

The first vertical line of text will be centered around theline x = 72 and will begin just below the line y = 576. 

16 (SHOULD BE CENTERED ON) vshow172 576 moveto
16 (A COMMON CENTER LINE.) vshow222 576 moveto
16 (VERTICAL TEXT IN CAPITAL) vshow272 576 moveto
16 (LETTERS HAS MORE EVEN) vshow322 576 moveto
16 (spacing than lower case letters.) vshow
showpage

   

1 inch
72 points

Sym

phon

y No. 9

 (The Choral Sy

mph

ony

)

Ludwig v

on Beethoven

The

 New

 York Philharmonic Orche

stra

   

169
Program 10 / Circular Text
This program defines two different procedures forprinting text around a circular arc. ``outsidecircletext''
prints the text in a clockwise fashion with its baselinealong the circumference, on the outside of the circle.
``insidecircletext'' prints the text in a counter-clockwisefashion with its baseline along the circumference, on the
inside of the circle.
/outsidecircletext  { circtextdict begin
      /radius exch def      /centerangle exch def
      /ptsize exch def      /str exch def

 ``outsidecircletext'' takes four arguments: the string toshow, the point size of the font to use, the angle around
which the text should be centered, and the radius of thecircular arc. It assumes that the center of the circle is at
(0,0). 
      /xradius radius ptsize 4 div add def A radius slightly larger than the one specified is used forcomputations but not for placement of characters. This

has the effect of placing the characters closer together,otherwise the interletter spacing would be too loose. 
      gsave Save the current graphics state.        centerangle str findhalfangle add rotate Find out how much angle the text subtends and then

rotate to the appropriate starting position for showingthe string. (The positive x-axis now intersects the circle
where the text should start.)         str
          { /charcode exch def            ( ) dup 0 charcode put outsideplacechar
          } forall

For each character in the string, determine its positionon the circular arc and show it. 

      grestore Return to the former graphics state.    end
  } def
/insidecircletext  { circtextdict begin
      /radius exch def    /centerangle exch def      /ptsize exch def    /str exch def

 ``insidecircletext'' takes the same four arguments as``outsidecircletext.'' 

      /xradius radius ptsize 3 div sub def      gsave
        centerangle str findhalfangle sub rotate        str
          { /charcode exch def            ( ) dup 0 charcode put insideplacechar
          } forall      grestore
    end

Here we use a radius which is slightly smaller than thedesired radius for computations. This forces the
characters to be placed farther apart to avoidoverlapping. 

  } def

   

170

Program 10 / Circular Text

(continued)

/circtextdict 16 dict defcirctextdict begin
  /findhalfangle    { stringwidth pop 2 div
        2 xradius mul pi mul div 360 mul    } def

``findhalfangle'' takes one argument, a string, and findsthe angle subtended by that string. It leaves the value of
half of that angle on the stack. The angle is found bycomputing the ratio of the width of the string to the
circumference of the circle and then converting thatvalue to degrees. 

  /outsideplacechar    { /char exch def
      /halfangle char findhalfangle def      gsave

``outsideplacechar'' shows a character upright on theoutside of the circumference and then rotates clockwise
by the amount of angle subtended by the width of thecharacter. 
        halfangle neg rotate        radius 0 translate Rotate clockwise by half the angle taken up by the widthof the character and translate out to the circumference. 
        -90 rotate Position character upright on outside of circumference.        char stringwidth pop 2 div neg 0 moveto Center the character around the origin.
        char show      grestore
      halfangle 2 mul neg rotate    } def Rotate clockwise by the amount of angle subtended bythe width of the character. 

  /insideplacechar    { /char exch def
      /halfangle char findhalfangle def      gsave
        halfangle rotate        radius 0 translate
        90 rotate

``insideplacechar'' operates in a similar manner to``outsideplacechar'' except that the direction of rotation
is counter-clockwise and the characters are placedupright on the inside of the circle. 

        char stringwidth pop 2 div neg 0 moveto        char show
      grestore      halfangle 2 mul rotate
    } def
  /pi 3.1415923 defend

    

171
Program 10 / Circular Text

(continued)

/Times-Bold findfont 22 scalefont setfont The remainder of this program demonstrates how to usethe circular text procedures to draw a record label.

306 448 translate translate the origin to the center of the page.
(Symphony No. 9 (The Choral Symphony))  22 90 140 outsidecircletext Put the title of the record along the ``outside'' of thecircle.

/Times-Roman findfont 15 scalefont setfont
(Ludwig von Beethoven)  15 90 118 outsidecircletext Put the composer's name along the ``outside'' of aslightly smaller circle.

(The New York Philharmonic Orchestra)  15 270 118 insidecircletext Put the name of the orchestra along the ``inside'' of thecircle so that it reads right-side-up. 
showpage

 

1 inch
72 points

If my film makes on
e mo

re p

erson

 feel miserable I'll feel I've don

e m

y job

. -- 
WOO
DY ALLEN

   

173
Program 11 / Placing Text Along an Arbitrary Path

This program defines a general procedure called``pathtext'' for placing text along a path of arbitrary
shape.
/pathtextdict 26 dict def Local storage for the procedure ``pathtext.''
/pathtext  { pathtextdict begin
    /offset exch def    /str exch def

``pathtext'' will place a string of text along any path. Ittakes a string and starting offset distance from the
beginning of the path as its arguments. Note that``pathtext'' assumes that a path has already been defined
and after it places the text along the path, it clears thecurrent path in the same manner as the stroke and fill
operators; it also assumes that a font has been set.``pathtext'' begins placing the characters along the
current path, starting at the offset distance andcontinuing until either the path length is exhausted or
the entire string has been printed, whichever occurs first.The results will be more effective when a small point
size font is used along a path with sharp curves. 
    /pathdist 0 def Initialize the distance traveled along the path.    /setdist offset def Initialize the distance covered by setting characters.
    /charcount 0 def Initialize the character count.    gsave
      flattenpath Reduce the path to a series of straight line segments.The characters will be placed along the line segments in

the procedure ``linetoproc.''      {movetoproc} {linetoproc}
        {curvetoproc} {closepathproc}        pathforall The basic strategy is to process the segments of the path,keeping a running total of the distance traveled so far(pathdist). We also keep track of the distance taken up

by the characters that have been set so far (setdist).When the distance traveled along the path is greater than
the distance taken up by the set characters, we are readyto set the next character (if there are any left to be set).
This process continues until we have exhausted the fulllength of the path. 
    grestore    newpath Clear the current path.
    end  } def

    

174

Program 11 / Placing Text Along an Arbitrary Path

(continued)

pathtextdict begin/movetoproc
  { /newy exch def /newx exch def

``movetoproc'' is executed when a moveto componenthas been encountered in the pathforall operation. 

    /firstx newx def /firsty newy def    /ovr 0 def
    newx newy transform

Remember the ``first point'' in the path so that when weget a closepath component we can properly handle the
text.     /cpy exch def /cpx exch def
  } def Explicitly keep track of the current position in devicespace. 
/linetoproc ``linetoproc'' is executed when a lineto component hasbeen encountered in the pathforall operation.
  { /oldx newx def /oldy newy def Update the old point.    /newy exch def /newx exch def Get the new point.
    /dx newx oldx sub def    /dy newy oldy sub def
    /dist dx dup mul dy dup mul add sqrt def Compute the distance between the old and new point.    dist 0 ne Don't do anything if the line segment has zero length.
      { /dsx dx dist div ovr mul def        /dsy dy dist div ovr mul def ``dsx'' and ``dsy'' are used to update the currentposition to be just beyond the width of the previous

character.         oldx dsx add oldy dsy add transform
        /cpy exch def /cpx exch def Update the current position.        /pathdist pathdist dist add def Increment the distance we have traveled along the path.
        { setdist pathdist le Keep setting characters along this path segment until wehave exhausted its length. 
            { charcount str length lt                {setchar} {exit} ifelse } As long as there are still characters left in the string, setthem. 
            { /ovr setdist pathdist sub def              exit }
            ifelse        } loop

Keep track of how much we have overshot the pathsegment by setting the previous character. This enables
us to position the origin of the following charactersproperly on the path. 
    } if  } def

/curvetoproc  { (ERROR: No curveto's after flattenpath!) print
  } def

``curvetoproc'' is executed when a curveto componenthas been encountered in the pathforall operation. It
prints an error message since there shouldn't be anycurveto's in a path after the flattenpath operator has
been executed. 
/closepathproc  { firstx firsty linetoproc
    firstx firsty movetoproc  } def

``closepathproc'' is executed when a closepathcomponent has been encountered in the pathforall
operation. It simulates the action of the operatorclosepath by executing ``linetoproc'' with the
coordinates of the most recent moveto and thenexecuting ``movetoproc'' to the same point. 

   

175
Program 11 / Placing Text Along an Arbitrary Path

(continued)

/setchar  { /char str charcount 1 getinterval def ``setchar'' sets the next character in the string along thepath and then updates the amount of path we have

exhausted.     /charcount charcount 1 add def Increment the character count.
    /charwidth char stringwidth pop def Find the width of the character.    gsave
      cpx cpy itransform translate Translate to the current position in user space.      dy dx atan rotate Rotate the x-axis to coincide with the current segment.
      0 0 moveto char show      currentpoint transform
      /cpy exch def /cpx exch def    grestore Update the current position before restoring to theuntransformed state. 
    /setdist setdist charwidth add def  } def Increment the distance we have covered by settingcharacters. 
end The completes the definitions required by ``pathtext.''

Below is an example of using ``pathtext.''/Helvetica findfont 16 scalefont setfont Set up the font we wish to use.

newpath  200 500 70 0 270 arc
  200 110 add 500 70 270 180 arc

Define the path that ``pathtext'' will use. 

(If my film makes one more person feel\ miserable I'll feel I've done my job.\
 -- WOODY ALLEN) 55 pathtext Print the string along the path at an offset of 55 points.
newpath Draw an outline shape suggestive of a movie camera.  150 310 moveto 360 310 lineto Draw the box part.
  360 400 lineto 150 400 lineto  closepath
  360 347 moveto 410 330 lineto Draw the lens part.  410 380 lineto 360 363 lineto
2 setlinewidth stroke

EXERCISE FOR THE READER: This algorithm placescharacters along the path according to the origin of each
character. Rewrite the algorithm so that the charactersare placed according to the center of their width. This
will yield better results around sharp curves and whenlarger point sizes are used.
showpage

   

A Simple Line Breaking Algorithm 

In every period there have been better or worse types employed in better or worse 
ways. The better types employed in better ways have been used by the educated printer 
acquainted with standards and history, directed by taste and a sense of the fitness of 
things, and facing the industrial conditions and the needs of his time. Such men have made of 
printing an art. The poorer types and methods have been employed by printers ignorant of 
standards and caring alone for commercial success. To these, printing has been simply a 
trade. The typography of a nation has been good or bad as one or other of these classes 
had the supremacy. And to-day any intelligent printer can educate his taste, so to choose 
types for his work and so to use them, that he will help printing to be an art rather than a 
trade.  -Daniel Berkeley Updike.

Drawing a Pie Chart 

January Pie Sales

Blueberry
Cherry

Apple

Boston Cream

Other

Vanilla Cream

Filling an Area with a Pattern 
Basket weave, no rotation in user space Fish scale, 90 degree rotation in user space

Making a Poster 
50%

SA

% OF

AL

OFF
LE

NOTE:  This is not the actual output page produced by the following POSTSCRIPT program. Therectangles are scaled down versions of the 8 1/2" by 11" pages generated by the program.

   

PROGRAMS 12 -15
APPLICATIONS

This section is a collection of miscellaneous programs that serveas  examples  of  some  mini-applications  written  entirely  in  the

POSTSCRIPT language.

ABOUT THE PROGRAMS

The  program  ``A  Simple  Line  Breaking  Algorithm''  is  exactlywhat its title might suggest: a simple algorithm for breaking text

across several lines. The program takes a string and prints it in aspecified  column  on  the  page  making  line  breaks  when  necessary.  The  program  makes  use  of  the stringwidth operator  todetermine  how  long  a word  will be  when printed in the current
font,  and  it  makes  use  of  the search operator  to  find  the  wordbreaks in the string. The line breaking algorithm could be part of
a larger program for document formatting.
``Making a Poster'' is useful for printing a picture that is largerthan  the  usual  8-1/2"  by  11"  page  size.  The  program  defines  a

procedure ``printposter'' that will take the large picture and printit on several pieces of 8-1/2" by 11" paper.

The program ``Drawing a Pie Chart'' defines a set of proceduresthat can be used to draw any  pie chart. It  is a  good example of

integrating  text  and  graphics  under  different  graphical  transfor-mations.

``Filling an Area with a Pattern'' demonstrates one technique fordoing pattern-fill by changing the halftone screen and then using

177

   

the fill operator.  This  is  a  rather  advanced  example  and  it  re-quires an understanding of the specifics of the underlying printing device, such as its resolution and orientation with respect tothe  user  coordinate  system.  The  program  contains  an  important
procedure, ``setuserscreen,'' that is used for setting up a halftonescreen  in  a  device  independent  manner.  The  P

OSTSCRIPThalftone screen machinery is very device dependent and the procedure ``setuserscreen'' serves as a device independent interfaceto it.

178 APPLICATIONS

 

179
  

1 inch
72 points

In every period there have been better or worse types employed in better or worse 
ways. The better types employed in better ways have been used by the educated printer 
acquainted with standards and history, directed by taste and a sense of the fitness of 
things, and facing the industrial conditions and the needs of his time. Such men have made of 
printing an art. The poorer types and methods have been employed by printers ignorant of 
standards and caring alone for commercial success. To these, printing has been simply a 
trade. The typography of a nation has been good or bad as one or other of these classes 
had the supremacy. And to-day any intelligent printer can educate his taste, so to choose 
types for his work and so to use them, that he will help printing to be an art rather than a 
trade.  -Daniel Berkeley Updike.

   

181
Program 12 / A Simple Line Breaking Algorithm

This program demonstrates a simple line breakingalgorithm.
/wordbreak ( ) def Constant used for word breaks (ASCII space)./BreakIntoLines
  { /proc exch def    /linewidth exch def
    /textstring exch def

``BreakIntoLines'' takes a string of text and breaks it upinto a series of lines, each no longer than the maximum
line width. The algorithm breaks lines at word breaks(spaces) only. ``BreakIntoLines'' takes three arguments:
the string of text, the maximum line width and aprocedure to be executed each time the end of a line has
been found. The procedure is expected to take oneargument: a string containing the current line. 
    /breakwidth wordbreak stringwidth pop def Get the width of a word break in the current font.    /curwidth 0 def ``curwidth'' is the typeset width of the current line.
    /lastwordbreak 0 def ``lastwordbreak'' is the index of the most recent wordbreak encountered in the string of text.
    /startchar 0 def ``startchar'' is the index of the first character on thecurrent line.
    /restoftext textstring def ``restoftext'' is a temporary variable that holds theremaining results of the search operator (see the loop

below).
    { restoftext wordbreak search        {/nextword exch def pop
         /restoftext exch def         /wordwidth nextword stringwidth pop def

The basic strategy for breaking lines is to search thestring of text (contained in ``restoftext'') for the next
word break. The pre-string returned by the searchoperator is the word preceding the word break. The
post-string returned gets assigned to ``restoftext.''          curwidth wordwidth add linewidth gt
           { textstring startchar                lastwordbreak startchar sub
                getinterval proc             /startchar lastwordbreak def
             /curwidth wordwidth breakwidth add def }           { /curwidth curwidth wordwidth add
                breakwidth add def           } ifelse

If the width of the word returned by the searchoperator would force the current line to exceed the
maximum line width then the substring spanning thecurrent line (from the first character on the line to the
most recent word break) is passed as an argument to theuser's procedure. Otherwise the width of the current line
is incremented by the width of the word. 

         /lastwordbreak lastwordbreak           nextword length add 1 add def
        }

The ``lastwordbreak'' variable is updated to index intothe text string at the position of the most recent word
break.         { pop exit }
        ifelse    } loop The last word in the text has been found when thesearch operator fails to match the word break pattern;this terminates the loop. 
    /lastchar textstring length def    textstring startchar lastchar startchar sub Don't forget to process the last line.
      getinterval proc  } def

  

1 inch
72 points

In every period there have been better or worse types employed in better or worse 
ways. The better types employed in better ways have been used by the educated printer 
acquainted with standards and history, directed by taste and a sense of the fitness of 
things, and facing the industrial conditions and the needs of his time. Such men have made of 
printing an art. The poorer types and methods have been employed by printers ignorant of 
standards and caring alone for commercial success. To these, printing has been simply a 
trade. The typography of a nation has been good or bad as one or other of these classes 
had the supremacy. And to-day any intelligent printer can educate his taste, so to choose 
types for his work and so to use them, that he will help printing to be an art rather than a 
trade.  -Daniel Berkeley Updike.

   

183
Program 12 / A Simple Line Breaking Algorithm

(continued)

/Times-Roman findfont 16 scalefont setfont Below is an example of the how the ``BreakIntoLines''procedure might be used.
/yline 650 def ``yline'' is a variable used in the procedure provided to``BreakIntoLines'' below.

(In every period there have been better or worse\ types employed in better or worse ways. The\
 better types employed in better ways have been\ used by the educated printer acquainted with\
 standards and history, directed by taste and\ a sense of the fitness of things, and facing the\
 industrial conditions and the needs of his time.\ Such men have made of printing an art. The\
 poorer types and methods have been employed\ by printers ignorant of standards and caring\
 alone for commercial success. To these, printing\ has been simply a trade. The typography of a\
 nation has been good or bad as one or other of\ these classes had the supremacy. And to-day\
 any intelligent printer can educate his taste, so\ to choose types for his work and so to use them,\
 that he will help printing to be an art rather\ than a trade.  \261Daniel Berkeley Updike.)
   300 Use a line width of 300 points.   { 72 yline moveto show
     /yline yline 18 sub def} The procedure provided to ``BreakIntoLines'' takes astring as its argument. It uses a global variable ``yline''to keep track of vertical positioning on the page. It

moves to a specified position on the page, shows thestring in the current font and then updates the vertical
position.    BreakIntoLines EXERCISE FOR THE READER: If the user specifies a
short enough line width, it is possible for the typesetwidth of a single word to exceed the maximum line
width. Modify this algorithm to handle this eventgracefully.
showpage

  

50%

SA

% O

AL

FF
LE

NOTE:  This is not the actual output page produced by the following POSTSCRIPT program. Therectangles are scaled down versions of the 8 1/2" by 11" pages generated by the program.

   

185
Program 13 / Making a Poster
This program demonstrates how to print a picture largerthan a sheet of paper (8.5" by 11") on several sheets of
paper that can be pasted together later.
/printposter  { /rows exch def
    /columns exch def    /bigpictureproc exch def

``printposter'' takes a large picture (larger than 8.5" by11") and prints it on several pages according to the
number of rows and columns specified. Imaginesuperimposing a grid composed of the specified number
of rows and columns on the large image. Then eachrectangle in the grid represents an 8.5" by 11" page to be
printed. ``printposter'' takes three arguments: aprocedure representing the large picture, the number of
columns and the number of rows. 
    newpath      leftmargin botmargin moveto
      0 pageheight rlineto      pagewidth 0 rlineto
      0 pageheight neg rlineto    closepath clip

Set up a clipping region for the page we will print on.Since most printers cannot print to the very edge of the
paper, we will explicitly set up the clipping boundary sothat it lies within the printing boundaries of the printer
and we will compensate for this when we print the largeimage so that all parts of the image are actually printed. 

    leftmargin botmargin translate Readjust the origin on the page so that it coincides withthe origin of the clipping boundary.
    0 1 rows 1 sub For each row of pages...      { /rowcount exch def
        0 1 columns 1 sub For each page within that row...          { /colcount exch def
            gsave              pagewidth colcount mul neg
                pageheight rowcount mul neg                translate Translate the large picture so that the desired sectionwill be imaged on the printed page. We must translatethe large picture in the negative direction so that the

lower left corner of the section to be printed alwayscoincides with the origin. 
              bigpictureproc Execute the large picture, clipping to this page.              gsave showpage grestore Since the showpage operator has the side effect of

executing the initgraphics operator (which would resetthe clipping region), we bracket it by the gsave and
grestore operators.            grestore
          } for      } for
  } def

  

50%

SA

% O

AL

FF
LE

NOTE:  This is not the actual output page produced by the following POSTSCRIPT program. Therectangles are scaled down versions of the 8 1/2" by 11" pages generated by the program.

   

187
Program 13 / Making a Poster

(continued)

/inch {72 mul} def
/leftmargin .5 inch def/botmargin .25 inch def
/pagewidth 7.5 inch def/pageheight 10 inch def

These are the dimensions of the clipping boundary. 

/salesign  { gsave This procedure draws a large sign with a border. Thesign is 22.5 inches wide and 19.5 inches high which fits

comfortably on 6 8.5 inch by 11 inch pages (the finalresult will be 2 rows of pages high and 3 columns of
pages wide).      /Times-Roman findfont 500 scalefont setfont
      2.5 inch 11 inch moveto      (SALE) show
      /Times-Roman findfont 350 scalefont setfont      1.45 inch 4 inch moveto
      .5 setgray (50%) show      0 setgray ( OFF) show
      newpath Specify the path for the border.        .5 inch 18 inch moveto
        22 inch 18 inch lineto        22 inch 2 inch lineto
        .5 inch 2 inch lineto      closepath
      gsave        .75 inch setlinewidth stroke First paint the border with a thick black stroke.
      grestore      10 setlinewidth 1 setgray stroke Then paint a thin white stroke down the center of the

border.    grestore
  } def
{salesign} 3 2 printposter Print the large picture on a total of 6 pages. The image isthree columns of pages wide and 2 rows of pages high. 

 

1 inch
72 points

January Pie Sales

Blueberry
Cherry

Apple

Boston Cream

Other

Vanilla Cream

   

189
Program 14 / Drawing a Pie Chart

This program demonstrates a small application: drawinga pie chart.
/PieDict 24 dict defPieDict begin Local storage for ``DrawPieChart'' and its relatedprocedures. 
  /DrawSlice    { /grayshade exch def
      /endangle exch def      /startangle exch def
      /thelabel exch def

``DrawSlice'' draws an outlined and filled-in pie slice.It takes four operands: the label for this particular pie
slice, the starting angle for the slice, the ending angle forthe slice and the shade of gray the slice should be. 

      newpath  0 0 moveto Create a path in the shape of a pie slice.         0 0 radius startangle endangle arc
      closepath      1.415 setmiterlimit This prevents a spike from occurring on the interior

angles when we outline the pie slices. The value 1.415cuts off miters at angles below 90 degrees.
      gsave        grayshade setgray
        fill      grestore
      stroke

Fill the pie slice path with the appropriate gray color. Byusing gsave and grestore we don't lose the current
path. Since color is painted onto the page, we fill the pieslice first and then outline it with a stroke. 

      gsave The following draws the tick-mark and places the label:        startangle endangle add 2 div rotate Find the center of the pie slice and rotate so that the

x-axis coincides with this center.        radius 0 translate Translate the origin out to the circumference.
        newpath          0 0 moveto labelps .8 mul 0 lineto stroke Draw the tick-mark; make it 80 percent of the labelpoint size in length. 
        labelps 0 translate Move the origin out a little beyond the circumference.        0 0 transform
      grestore      itransform
      /y exch def /x exch def      x y moveto

      x 0 lt        { thelabel stringwidth pop neg 0 rmoveto }
        if

Place the label at the current origin. If we simply drawthe text on the page now, it would come out rotated.
Since this is not desired, we avoid it by returning to theprevious unrotated coordinate system. Before returning,
we remember the position of the current origin on theprinted page. We accomplish this by using the
transform and itransform operators. First perform atransform on the origin to push the coordinates of the
origin in device space onto the operand stack. Thenperform a grestore to return to the previous unrotated
coordinate system. Then perform an itransform on thetwo device coordinates left on the stack to determine
where they are in the current coordinate system. 
      y 0 lt { 0 labelps neg rmoveto } if      thelabel show
    } def

Make some adjustments so that the label text won'tcollide with the pie slice. 

    

190

Program 14 / Drawing a Pie Chart

(continued)

  /findgray    { /i exch def /n exch def
      i 2 mod 0 eq        { i 2 div n 2 div round add n div }
        { i 1 add 2 div n div }        ifelse
    } defend

``findgray'' calculates the gray value for a slice. It takestwo arguments: the total number of slices and the
current slice number (Given that there are n pie slices,the slices are ``numbered'' from 1 to n). The gray values
for the pie slices range evenly from white to black (i.e.,the values provided to setgray range from (n/n, n-1/n,
..., 1/n)). Since we don't want similar values of graynext to each other, findgray ``shuffles'' the possible
combinations of gray like a deck of cards. 
/DrawPieChart  { PieDict begin
      /radius exch def      /ycenter exch def /xcenter exch def
      /PieArray exch def      /labelps exch def /titleps exch def
      /title exch def

``DrawPieChart'' takes seven arguments: the title of thepie chart, the point size for the title, the point size for the
labels for each slice, a special array (described belowwhere ``DrawPieChart'' is called), the (x,y) center of
the pie chart, and the radius of the pie chart. 

      gsave        xcenter ycenter translate Translate the coordinate system origin to the center of

the pie chart.        /Helvetica findfont titleps scalefont setfont Print the title of the pie chart in Helvetica.
        title stringwidth pop 2 div neg radius neg          titleps 3 mul sub moveto
        title show

Center the title below the pie chart. Position it below thebottom of the pie chart by 3 times the title point size. 

        /Helvetica findfont labelps scalefont setfont Print the individual pie slice labels in Helvetica.        /numslices PieArray length def
        /slicecnt 0 def        /curangle 0 def A ``loop'' variable that keeps track of the angle of arc to

begin each pie slice at.        PieArray Repeat the following for each element in the
``PieArray.''          { /slicearray exch def
            slicearray aload pop Push the label and percentage onto the stack.            /percent exch def
            /label exch def            /perangle percent 360 mul def Convert the percentage into degrees of angle.
            /slicecnt slicecnt 1 add def            label curangle curangle perangle add
              numslices slicecnt findgray DrawSlice            /curangle curangle perangle add def Update the current starting angle.
          } forall      grestore
    end  } def

   

191
Program 14 / Drawing a Pie Chart

(continued)

(January Pie Sales) 24 12  [ [(Blueberry) .12 ]
    [(Cherry) .30 ]    [(Apple) .26 ]
    [(Boston Cream) .16 ]    [(Other) .04 ]
    [(Vanilla Cream) .12 ]  ] 306 396 140 DrawPieChart

The pie array is an array of arrays. Each array in the piearray contains the label for a pie slice followed by a real
number indicating the percentage of the total pierepresented by this particular slice. 

showpage

 

1 inch
72 points

Basket weave, no rotation in user space Fish scale, 90 degree rotation in user space

   

193
Program 15 / Filling an Area with a Pattern

This program demonstrates how to fill an area with abitmap pattern using the P

OSTSCRIPT halftone screenmachinery. The setscreen operator is intended for

halftones and a reasonable default screen is provided byeach P

OSTSCRIPT implementation. It can also be used forrepeating patterns but the device dependent nature of the

setscreen operator can produce different results ondifferent printers. As a solution to this problem the
procedure, ``setuserscreen,'' is defined to provide adevice independent interface to the device dependent
setscreen operator.IMPLEMENTATION NOTE: Creating low frequency
screens (below 60 lines per inch in device space) mayrequire a great deal of memory. On printing devices
with limited memory, a limitcheck error occurs whenstorage is exceeded. To avoid this error, it is best to
minimize memory use by specifying a repeating patternthat is a multiple of 16 bits wide (in the device
x-direction) and a screen angle of zero./setuserscreendict 22 dict def
setuserscreendict begin Local storage for the procedure ``setuserscreen.''  /tempctm matrix def
  /temprot matrix def  /tempscale matrix def Temporary matrices used in computations in``setuserscreen.'' 

  /concatprocs    { /proc2 exch cvlit def
      /proc1 exch cvlit def      /newproc proc1 length proc2 length add
        array def      newproc 0 proc1 putinterval
      newproc proc1 length proc2 putinterval      newproc cvx
    } def

``concatprocs'' takes two procedure bodies asarguments and concatenates them into one procedure
body. The resulting procedure body is left on theoperand stack. ``concatprocs'' will be used in
constructing a new spot function below. This procedureis identical to the one defined in the program ``Printing
Images.'' 

  /resmatrix matrix def  /findresolution
    { 72 0 resmatrix defaultmatrix dtransform      /yres exch def /xres exch def
      xres dup mul yres dup mul add sqrt    } def
end

Temporary matrix used in ``findresolution'' below.``findresolution'' returns the resolution (in pixels per
inch) of the device being printed on. Since there are 72units per inch in the default user space, find out how
many pixels those 72 units require in device space bytransforming a 72 unit long vector into device space and
then taking the length of the result. Leave this length onthe operand stack. 

    

194

Program 15 / Filling an Area with a Pattern

(continued)

/setuserscreen  { setuserscreendict begin
      /spotfunction exch def      /screenangle exch def
      /cellsize exch def

``setuserscreen'' takes 3 arguments: the cell size of thehalftone screen in the current user space units, the angle
of the screen relative to the current user space and aprocedure describing the spot function. ``setuserscreen''
converts the cell size and the screen angle from userspace into device space values for the built-in operator
setscreen.       /m tempctm currentmatrix def Get the current transformation matrix.
      /rm screenangle temprot rotate def Create a rotation matrix using the screen angle.      /sm cellsize dup tempscale scale def Create a scale matrix using the cell size.

      sm rm m m concatmatrix m concatmatrix pop Create a new transformation matrix by concatenatingsm*rm*m and store it in ``m.''
      1 0 m dtransform /y1 exch def /x1 exch def Transform a 1 unit vector in the x-direction through thenew transformation matrix to get the corresponding

vector in device space.      /veclength x1 dup mul y1 dup mul add sqrt def Find the length of this device space vector.
      /frequency findresolution veclength div def The frequency is the resolution of the device divided bythe length of the vector.
      /newscreenangle y1 x1 atan def Determine the new screen angle based on the angle ofthe transformed unit vector in device space.
      m 2 get m 1 get mul m 0 get m 3 get mul sub        0 gt Merely determining the screen angle is not enough insome cases since the user coordinate system might be a

reflected image of the device coordinate system. We cancheck for reflected images by testing the transformation
matrix. Given a matrix [a b c d tx ty], if (c*b - a*d) > 0then it's a reflected transformation. 
        { { neg } /spotfunction load concatprocs             /spotfunction exch def
        } if

Compensate for the reflection by flipping the ycoordinate that is passed to the spot function procedure.
We accomplish this by concatenating a procedure to flipthe y coordinate with the original spot function
procedure to create a new spot function procedure. It isvery important that the flip procedure precedes the spot
function procedure.       frequency newscreenangle /spotfunction load
        setscreen Now set up the halftone screen using the setscreenoperator.     end
  } def
/setpatterndict 18 dict defsetpatterndict begin Local storage for the procedure ``setpattern.'' The``bitison'' procedure is used by ``setpattern.'' 
  /bitison    { /ybit exch def /xbit exch def ``bitison'' returns true if the bit at position (xbit, ybit)in ``bstring'' is ``on'' (i.e., it has the value 1), it returns

false otherwise. ``bitison'' takes 2 arguments: the xand y position of the bit in a 2 dimensional coordinate
system. It relies on the two global variables ``bstring''

    

195
Program 15 / Filling an Area with a Pattern

(continued)

and ``bwidth'' (documented in ``setpattern'' below).       /bytevalue bstring ybit bwidth mul xbit 8 idiv
         add get def Get the integer representation of the hexadecimalcharacter pair containing the bit to be tested in thestring. 
      /mask 1 7 xbit 8 mod sub bitshift def Create a mask to address the correct bit.      bytevalue mask and 0 ne
    } def Leave the boolean result on the operand stack. end

/bitpatternspotfunction  { setpatterndict begin
      /y exch def /x exch def

``bitpatternspotfunction'' is the procedure provided tothe ``setuserscreen'' procedure as the spot function.
Like all setscreen spot functions, it takes twoarguments: the x and y coordinates of a pixel in a
halftone screen cell. (See the section on HalftoneScreens in the ``P

OSTSCRIPT Language ReferenceManual.'') Note that the global variables ``onbits'' and

``offbits'' must be set to 0 before this spot function isused with the setscreen operator (see ``setpattern''
below).       /xindex x 1 add 2 div bpside mul cvi def
      /yindex y 1 add 2 div bpside mul cvi def First, transform the (x, y) position into a position toaddress into the bit pattern. Since the x and y valuesprovided to the spot function are between -1 and 1,

transform them into integers between 0 and (bpside-1).       xindex yindex bitison
        { /onbits onbits 1 add def 1 }        { /offbits offbits 1 add def 0 }
        ifelse

If the bit is on, increment the ``onbits'' count and returna high value, otherwise increment the ``offbits'' count
and return a low value.     end
  } def
/setpattern  { setpatterndict begin
      /cellsz exch def      /angle exch def
      /bwidth exch def      /bpside exch def
      /bstring exch def

``setpattern'' sets up the halftone screen machinery sothat a repeating bitmap pattern will be used for
subsequent graphics output operations. It takes 5arguments: ``bstring'' is the bit pattern represented as a
string, ``bpside'' is the number of bits per side (thepattern must be square), ``bwidth'' is an integer
specifying the width of the pattern in bytes (each row ofthe pattern is expressed in an integral number of bytes,
which may contain extra zeroes if ``bpside'' is not amultiple of 8), ``angle'' is the screen angle and ``cellsz''
is the halftone screen cell size. The first 3 argumentslater serve as global variables to ``bitison.'' 
      /onbits 0 def /offbits 0 def Initialize ``onbits'' and ``offbits.''      cellsz angle /bitpatternspotfunction load Set up the halftone screen.
        setuserscreen      {} settransfer Don't allow correction of gray values, because we want

    

196

Program 15 / Filling an Area with a Pattern

(continued)

to set the gray exactly according to the off-bit/total-bitsratio.
      offbits offbits onbits add div setgray    end
  } def

By setting the gray this way, the exact number of ``on''bits will turn on in the screen. The values of ``offbits''
and ``onbits'' are calculated when the setscreenoperator is executed (see ``bitpatternspotfunction''
above). 
/enlargebits  { /bwidth exch def
    /bpside exch def    /bstring exch def

``enlargebits'' is used to print an enlarged bit pattern toillustrate the bit patterns used in ``setpattern'' below. It
takes 3 arguments: ``bstring,'' ``bpside,'' and ``bwidth''(See description of ``setpattern'' above). A black square
is printed for each ``on'' bit. The squares are one unit insize so the coordinate system should be scaled
appropriately before ``enlargebits'' is called. Note thatthe earlier bits in the pattern are printed in the lower
positions of the grid. The high order bit of the first byteof the pattern is the lower left bit, and the low order bit
of the last byte in the pattern is the upper right bit.     0.08 setlinewidth Specify a small line width since this will be scaled.
    0 1 bpside 1 sub For each bit in the y direction ...      { /y exch def
        0 1 bpside 1 sub For each bit in the x direction ...          { /x exch def
            x y setpatterndict /bitison get cvx exec              { gsave
                  x y translate

If the bit is ``on'' print a black square at the appropriateplace on the page. 

                  newpath Define a 1 unit square path.                    0 0 moveto 0 1 lineto
                    1 1 lineto 1 0 lineto                  closepath
                  gsave 0 setgray fill grestore Fill it in with black.                  1 setgray stroke Put a white outline around it.
                grestore              } if
          } for      } for
    newpath      0 0 moveto  0 bpside lineto
      bpside dup lineto  bpside 0 lineto    closepath 0 setgray stroke

Put a black outline around the entire bit pattern. 

  } def

   

197
Program 15 / Filling an Area with a Pattern

(continued)

/inch {72 mul} def
/showpattern  { /ang exch def
    /pat exch def    gsave

``showpattern'' demonstrates the use of the abovefunctions. First display a pattern as enlarged bits, and
then use it to fill an area below the enlarged bits on thepage. 
      0 3.5 inch translate      3 8 div inch dup scale
      pat 8 1 enlargebits Show the enlarged version of the pattern.    grestore
    pat 8 1 ang 72 300 32 div div setpattern First set up the pattern with the halftone screenmachinery. The patterns we are using are 8 bits wide

(i.e., 1 byte wide) and we want a target frequency that isa multiple of 16 bits (see implementation note above).
    newpath Define an area to be filled.      0 0 moveto 3 inch 0 lineto
      3 inch dup lineto 0 3 inch lineto    closepath fill
  } def
/pat1 <d1e3c5885c3e1d88> def/pat2 <3e418080e3140808> def Use hexadecimal string notation to set the bit patterns.Each pair of hexadecimal characters represents a ``row''

in the bit pattern. 
/Helvetica findfont 12 scalefont setfont Font used for printing captions.
gsave  1 inch 1.25 inch translate
  pat1 0 showpattern Show a basket weave pattern on the left.grestore
1 inch 1 inch moveto(Basket weave, no rotation in user space) show

gsave  4.5 inch 1.25 inch translate
  pat2 90 showpatterngrestore
4.5 inch 1 inch moveto(Fish scale, 90 degree rotation) show
( in user space) show

Show a fish scale pattern on the right, but rotate it by 90degrees. The enlarged bitmap pattern is not rotated but
the filled area is. 

showpage

       

Making an Outline Font  Re-encoding an Entire Font 

  Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char

01
23
45
67
1011
1213
1415
1617
2021
2223
2425
2627
3031
3233
3435
3637
40  41 !
42 "43 #
44 $45 %
46 &47 '
50 (51 )
52 *53 +
54 ,55 -
56 .57 /
60 061 1
62 263 3
64 465 5
66 667 7
70 871 9
72 :73 ;
74 <75 =
76 >77 ?

100 @  101 A
102 B103 C
104 D105 E
106 F107 G
110 H111 I
112 J c113 K .
114 L <115 M (
116 N +117 O |
120 P &121 Q
122 R123 S
124 T125 U
126 V127 W
130 X131 Y
132 Z !133 [ $
134 \ *135 ] )
136 ^ ;137 _ ~
140 ` -141 a /
142 b143 c
144 d145 e
146 f147 g
150 h151 i
152 j153 k ,
154 l %155 m _
156 n >157 o ?
160 p161 q
162 r163 s
164 t165 u
166 v167 w
170 x171 y
172 z :173 { #
174 | @175 } '
176 ~ =177 "

200201 a
202 b203 c
204 d205 e
206 f207 g
210 h211 i
212213
214215
216217
220221 j
222 k223 l
224 m225 n
226 o227 p
230 q231 r
232233
234235
236237
240241 !
242 c s243 # t
244 / u245 Y v
246 f w247 $ x
250 # y251 ' z
252 "253 <<
254 <255 >
256 fi257 fl
260261 -
262 #263 ##
264 *265
266 ||267 *
270 ,271 "
272 "273 >>
274 ...275 o/oo
276277 ?

300301 ` A
302 ' B303 ^ C
304 ~ D305 _ E
306 * F307 . G
310 " H311 I
312 *313 ,
314315 ""
316 ,317 ^
320 --321 J
322 K323 L
324 M325 N
326 O327 P
330 Q331 R
332333
334335
336337
340341 AE
342 S343 -a T
344 U345 V
346 W347 X
350 L/ Y351 O/ Z
352 OE353 -o
354355
356357
360 0361 ae 1
362 2363 3
364 4365 i 5
366 6367 7
370 l/ 8371 o/ 9
372 oe373 ss
374375
376377

Making Small Changesto Encoding Vectors

Boktryckarkonsten a"r ka"llan till praktiskt taget all ma"nsklig odling.
Den fo"rutan hade de oerho"rda framstegen inom vetenskap
och teknik inte varit mo"jliga.
-VALTER FALK

Printing is the source of practically all human evolution.
Without it the tremendous progress in the fields of science and
technology would not have been possible.

Changing the Character Widthsof a Font

HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz
HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz
HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz

Creating an Analytic Font 

aEvery bullet has its billet. -William III
aThe bullet that will kill me is not yet cast. -Napoleon I
aThe ballot is stronger than the bullet. -Abraham Lincoln

bEvery bullet has its billet. -William III
bThe bullet that will kill me is not yet cast. -Napoleon I
bThe ballot is stronger than the bullet. -Abraham Lincoln

cEvery bullet has its billet. -William III
cThe bullet that will kill me is not yet cast. -Napoleon I
cThe ballot is stronger than the bullet. -Abraham Lincoln

Hieroglyphics are the root of letters. Allcharacters were originally signs and all
signs were once images. Human society,the world, man in his entirety is in the
alphabet.d

Creating a Bitmap Font 

the tendency of the best
typography has been and
still should be in the path of
simplicity, legibility, and
orderly arrangement.

theodore low de vinne

    

PROGRAMS 16-21
Although  a  large  variety  of  fonts  are  available  with  theP

OSTSCRIPT language, there are situations when users may wishto  modify  the  existing  fonts  or  create  new  fonts.  This  section

presents several examples of modifying existing fonts to changetheir  rendering  style  (from  filled  to  outlined),  the  character
widths or the encoding of characters. There are also 2 examplesof  creating  entirely  new  fonts:  one  using  bitmap  character
descriptions and the other using analytic character descriptions.
The  basic  underlying  structure  of  a  font  is  the font  dictionary.When  fonts  are  modified,  the  entries  in  the  font  dictionary  are

changed.  When  new  fonts  are  created,  certain  crucial  entries  inthe  font  dictionary  must  be  present.  Some  of  the  details  on  the
entries  in  a  font  dictionary  and  how  to  modify  them  are  ex-plained  below;  for  a  full  explanation  refer  to  the P

OSTSCRIPTLanguage Reference Manual.

MODIFYING EXISTING FONTS

The basic strategy for modifying an existing font is to create anentirely  new  font  dictionary  and  to  copy  all  the  references  to

entries  in  the  original  font  dictionary,  except  for  the  FID  entry,into  the  new  dictionary.  The  next  step  is  to  modify  the  appropriate  fields.  The  last  step  is  to  perform  a definefont opera-tion  on  the  modified  font  dictionary  to  make  it  into  a
POSTSCRIPT font.
There are  two important steps to remember when modifying  an

199

    

existing  font.  The  first  is not to  copy  the  FID  field  from  theoriginal font dictionary to the new dictionary. The FID field will
automatically  get  created  when  the definefont operator  is  ex-ecuted.  Attempting  to  perform  a definefont operation  on  a  dictionary  that  already  contains  an  FID  field  results  in  aninvalidfont error.  The  second  step  is  to  change  the  FontName
field in the new dictionary. The same name which appears in theFontName  field  should  be  provided  as  an  argument  to  the
definefont operator. The  FontName  should  always  be  a  uniquename.

In addition, for fonts that have a UniqueID field, it is importantto  change  the  UniqueID  field  when  the  font  is  modified.  The

only  case  when  the  UniqueID  field  should not be  changed  iswhen the Encoding field of a font dictionary has been changed.
Changing  the  UniqueID  should  be  done  with  care.  See  theprograms ``Making an Outline Font'' and ``Changing the Character Widths of a Font'' for examples of this.

CREATING NEW FONTS

When creating new fonts, certain font dictionary entries must bepresent.  They  are  FontMatrix,  FontType,  FontBBox,  Encoding

and BuildChar. For a user defined font, the FontType should al-ways  have  the  value  3.  In  addition,  it  is  useful,  although  not
necessary,  to  have  a  UniqueID  entry.  The  UniqueID  entryfacilitates better caching of characters on disk-based implementations  of  the  POSTSCRIPT interpreter.  (Be  forewarned  that  theUniqueID  must  truly  be  a  unique  24  bit  number  and  that  the
creator of the font is responsible for ensuring this.)
The  BuildChar  procedure  is  responsible  for  specifying  how  acharacter in the new font is rendered. It should always call either

the setcachedevice or setcharwidth operator.  The  BuildCharprocedure  can  use  almost  all  of  the  P

OSTSCRIPT operators  torender  a  character.  However,  there  are  some  restrictions  when

the  character  is  to  be  cached  (i.e.,  when  the setcachedeviceoperator has been used). In this case, any of the operators related
to  gray-level  and  color  are  invalid  (e.g., setgray, setrgbcolor,image, etc).

200 MODIFYING AND CREATING FONTS

  

In the character descriptions for a new font, it is a good idea tocreate  a  character  description  that  will  be  printed  for

``undefined''  characters.  This  character  is  called  ``.notdef''  inthe built-in fonts, and it is defined to print nothing. When users
try to print characters that have not been defined in the font, the``.notdef''  character  is  printed;  the  ``.notdef''  character  is  a
graceful way of avoiding unexpected errors. As well as creatinga  character  description  for  the  undefined  character,  it  is  important  that  the  encoding  vector  have  the  name  of  this  undefinedcharacter in each location that does not have a character defined.
The  simplest  way  to  do  this is to  initialize  all  the  entries  in  theencoding  vector  to  contain  the  ``.notdef''  character  and  then
enter the character names in the desired positions.

ABOUT THE PROGRAMS

The  program  ``Making  an  Outline  Font''  is  an  example  ofmodifying  an  existing  font  to  change  its  rendering  style.  The

program  defines  a  general  procedure  ``MakeOutlineFont''  thattakes  one  of  the  standard  built-in  fonts  and  converts  it  to  an
outline  font.  (The  term  ``built-in  fonts''  refers  to  the  collectionof fonts available with a P

OSTSCRIPT implementation.) This pro-cedure will only yield the correct results for fonts that have their

characters described as outlines.
``Re-encoding  an  Entire  Font''  presents  a  general  procedure``ReEncode''  for  changing  the  encoding  vector  of  a  font.  The

encoding vector is a mapping of character codes (in the range of0  to  255)  to  character  names.  Most  of  the  built-in  fonts  are  encoded  according  to  a  standard  encoding,  but  there  are  caseswhere other encodings may be required such as printing text that
has  been  represented  according  to  the EBCDIC encoding.  Thespecific example demonstrated in the program ``Re-encoding an
Entire  Font''  re-encodes  a  built-in  font  to  have  the EBCDIC en-coding  by  replacing  the  encoding  vector  in  the  font  dictionary
with an entirely new encoding vector.
``Making  Small  Changes  to  Encoding  Vectors''  presents  an  al-ternative  to  replacing  the  entire  encoding  vector  for  situations

when  the  encoding  vector  only  needs  to  be  changed  slightly.Most  of  the  built-in  fonts  contain  characters  that  have  not  been

ABOUT THE PROGRAMS 201

    

encoded,  such  as  accented  characters.  To  print  such  characters,the name of the character must be inserted into the encoding vector. However, we do not want to specify the entire encoding vec-tor  to  insert  a  few  new  characters  so  the  procedure
``ReEncodeSmall'' has been defined to handle this insertion.
When encoding accented characters it is important to understandthat  accented  characters  (also  known  as composite  characters)

are actually a composite of the letter and the accent. In order toprint accented characters properly, both the letter and the accent
of the composite character must be encoded in the encoding vec-tor, as well as the composite character itself. For example, if you
wish  to  encode  the  composite  character  ``Aacute,''  both  the``A'' and the ``acute'' must be encoded.

``Changing  the  Character  Widths  of  a  Font''  defines  a  generalprocedure,  ``ModifyWidths,''  for  changing  some  or  all  of  the

character widths in a given font. It changes the necessary entriesin the font dictionary. In this example the character widths of a
font  are  rounded  such  that  when  the  characters  are  printed  at  acertain point size, the widths will be an integral number of pixels
in  device  space.  This  is  useful  for  avoiding  round-off  error  inpositioning characters with the show operator.

The program ``Creating an Analytic Font'' demonstrates how tocreate a new font whose character descriptions are geometric in

nature.  The  program  defines  all  the  necessary  font  dictionaryentries as well as some new entries of its own. The font created
has  4  characters:  bullets  of  three  sizes  and  an  open  box  shape.Each  character  is  described  using  the  P

OSTSCRIPT graphicoperators.  After  the  font  has  been  defined  it  is  used  in  an  example  that  prints  the  various  characters  intermixed  with  one  ofthe built-in fonts.

The final program, ``Creating a Bitmap Font,'' demonstrates anefficient  way  to  create  a  new  font  whose  character  descriptions

are bitmaps.

202 MODIFYING AND CREATING FONTS

 

203
  

1 inch
72 points

   

205
Program 16 / Making an Outline Font

This program defines a general procedure to take one ofthe built-in filled fonts and convert it into an outline
font. (This program will also work for downloadablefonts available from Adobe Systems, Inc.).

/makeoutlinedict 7 dict def Local storage for the procedure ``MakeOutlineFont.''/MakeOutlineFont
  { makeoutlinedict begin    /uniqueid exch def
    /strokewidth exch def    /newfontname exch def
    /basefontname exch def

``MakeOutlineFont'' takes one of the built-in filledfonts and makes an outlined font out of it. It takes four
arguments: the name of the font on which to base theoutline version, the new name for the outline font, a
stroke width to use on the outline and a unique ID. 

    /basefontdict basefontname findfont def Get the dictionary of the font on which the outlineversion will be based.
    /numentries basefontdict maxlength 1 add def Determine how large the new font dictionary for theoutline font should be. Make it one entry larger to

accommodate an entry for the stroke width used on theoutline.
    basefontdict /UniqueID known not      { /numentries numentries 1 add def } if Make sure there is room for the unique ID field. (Not allfonts have UniqueID fields initially. In particular, the

built-in fonts in POSTSCRIPT version 23.0 do not.)     /outfontdict numentries dict def Create a dictionary to hold the description for the
outline font.    basefontdict
      { exch dup /FID ne          { exch outfontdict 3 1 roll put } Copy all the entries in the base font dictionary to theoutline dictionary, except for the FID. 
          { pop pop } Ignore the FID pair.          ifelse
      } forall
    outfontdict /FontName newfontname put Insert the new name into the dictionary.    outfontdict /PaintType 2 put Change the paint type to outline.
    outfontdict /StrokeWidth strokewidth put Insert the stroke width into the dictionary.    outfontdict /UniqueID uniqueid put Insert the new unique ID.

    newfontname outfontdict definefont pop    end
  } def

Now make the outline dictionary into a POSTSCRIPT font.We will ignore the modified dictionary returned on the
stack by the definefont operator. 

  

1 inch
72 points

   

207
Program 16 / Making an Outline Font

(continued)

The following demonstrates how to use the``MakeOutlineFont'' procedure and how to determine
new unique ID's.
/Helvetica-Bold /Helvetica-Outline1 1000 54 div The stroke width is always specified in the charactercoordinate system (1000 units) The value specified here,

1000/54 will yield a one point wide outline when thefont is scaled to 54 points in size. Note that this outline
width changes with different point sizes.  /Helvetica-Bold findfont dup /UniqueID known
    { /UniqueID get 1 add }    { pop 1 }
    ifelse

Determine the unique ID. If the ``base'' font alreadycontains a unique ID, add a unique constant to it,
otherwise pick a unique integer and leave that value onthe operand stack. 
  MakeOutlineFont
/Helvetica-Outline1 findfont 36 scalefont setfont  72 504 moveto (outline) show

/Helvetica-Outline1 findfont 54 scalefont setfont  (outline) show
/Helvetica-Bold /Helvetica-Outline2 1000 36 div A stroke width value of 1000/36 yields a one point wideoutline when the font is scaled to 36 points in size. It

yields a 1.5 point outline when the font is scaled to 54points in size (54/36 = 1.5).
  /Helvetica-Bold findfont dup /UniqueID known    { /UniqueID get 2 add }
    { pop 2 }    ifelse
  MakeOutlineFont
/Helvetica-Outline2 findfont 36 scalefont setfont  72 444 moveto (outline) show

/Helvetica-Outline2 findfont 54 scalefont setfont  (outline) show
showpage NOTE: If the font is scaled anamorphically, the outlinestroke on the characters will be scaled anamorphicallyas well, leading to potentially undesirable results. 

   

1 inch
72 points

  Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char   Octal     Standard    EBCDICNumber      Char          Char

01
23
45
67
1011
1213
1415
1617
2021
2223
2425
2627
3031
3233
3435
3637
40  41 !
42 "43 #
44 $45 %
46 &47 '
50 (51 )
52 *53 +
54 ,55 -
56 .57 /
60 061 1
62 263 3
64 465 5
66 667 7
70 871 9
72 :73 ;
74 <75 =
76 >77 ?

100 @  101 A
102 B103 C
104 D105 E
106 F107 G
110 H111 I
112 J c113 K .
114 L <115 M (
116 N +117 O |
120 P &121 Q
122 R123 S
124 T125 U
126 V127 W
130 X131 Y
132 Z !133 [ $
134 \ *135 ] )
136 ^ ;137 _ ~
140 ` -141 a /
142 b143 c
144 d145 e
146 f147 g
150 h151 i
152 j153 k ,
154 l %155 m _
156 n >157 o ?
160 p161 q
162 r163 s
164 t165 u
166 v167 w
170 x171 y
172 z :173 { #
174 | @175 } '
176 ~ =177 "

200201 a
202 b203 c
204 d205 e
206 f207 g
210 h211 i
212213
214215
216217
220221 j
222 k223 l
224 m225 n
226 o227 p
230 q231 r
232233
234235
236237
240241 !
242 c s243 # t
244 / u245 Y v
246 f w247 $ x
250 # y251 ' z
252 "253 <<
254 <255 >
256 fi257 fl
260261 -
262 #263 ##
264 *265
266 ||267 *
270 ,271 "
272 "273 >>
274 ...275 o/oo
276277 ?

300301 ` A
302 ' B303 ^ C
304 ~ D305 _ E
306 * F307 . G
310 " H311 I
312 *313 ,
314315 ""
316 ,317 ^
320 --321 J
322 K323 L
324 M325 N
326 O327 P
330 Q331 R
332333
334335
336337
340341 AE
342 S343 -a T
344 U345 V
346 W347 X
350 L/ Y351 O/ Z
352 OE353 -o
354355
356357
360 0361 ae 1
362 2363 3
364 4365 i 5
366 6367 7
370 l/ 8371 o/ 9
372 oe373 ss
374375
376377

   

209
Program 17 / Re-encoding an Entire Font

This program defines a general procedure forre-encoding the entire encoding vector for a font. The
specific example demonstrated shows how to re-encodeone of the built-in fonts according to the EBCDIC
character set encoding.
/reencodedict 5 dict def Local storage for the procedure ``ReEncode.''/ReEncode
  { reencodedict begin      /newencoding exch def
      /newfontname exch def      /basefontname exch def

``ReEncode'' generates a new re-encoded font. It takes3 arguments: the name of the font to be re-encoded, a
new name, and a new encoding vector. ReEncode copiesthe existing font dictionary, replacing the FontName and
Encoding fields, then generates a new FID and entersthe new name in FontDirectory with the definefont
operator. The new name provided can later be used in afindfont operation. 
      /basefontdict basefontname findfont def Get the dictionary of the font on which the re-encodedversion will be based.
      /newfont basefontdict maxlength dict def Create a dictionary to hold the description for there-encoded font.
      basefontdict       { exch dup dup /FID ne exch /Encoding ne and
          { exch newfont 3 1 roll put }

Copy all the entries in the base font dictionary to thenew dictionary except for the FID and Encoding fields. 

          { pop pop } Ignore the FID and Encoding pairs.          ifelse
       } forall      newfont /FontName newfontname put
      newfont /Encoding newencoding put Install the new name and the new encoding vector in thefont.      newfontname newfont definefont pop
    end   } def Now make the re-encoded font dictionary into aPOSTSCRIPT font. Ignore the modified dictionary on theoperand stack returned by the definefont operator. 

/EBCDIC 256 array def0 1 255 { EBCDIC exch /.notdef put } for
EBCDIC  dup 8#100 /space put
  dup 8#112 /cent put    dup 8#116 /plus put  dup 8#113 /period put dup 8#117 /bar put
  dup 8#114 /less put    dup 8#120 /ampersand put  dup 8#115 /parenleft put

  dup 8#132 /exclam put   dup 8#140 /hyphen put  dup 8#133 /dollar put     dup 8#141 /slash put
  dup 8#134 /asterisk put  dup 8#135 /parenright put
  dup 8#136 /semicolon put  dup 8#137 /asciitilde put

To illustrate how the ReEncode procedure is used, wewill re-encode one of the built-in fonts to support the
EBCDIC encoding. (The EBCDIC encoding used isreferenced in ``IBM System/360: Principles of
Operation,'' Appendix F.) The first step in doing this isto define an array containing that encoding. This array is
referred to as an ``encoding vector.'' The encodingvector should be 256 entries long. Since the encoding
vector is rather sparse, all the entries are initialized to``.notdef.'' Those entries which correspond to characters
in the EBCDIC encoding are filled in with the propercharacter name. The octal character code for the
character is used to access the encoding vector. 

   

210

Program 17 / Re-encoding an Entire Font

(continued)

  dup 8#153 /comma put  dup 8#154 /percent put
  dup 8#155 /underscore put  dup 8#156 /greater put
  dup 8#157 /question put

Continuation of the EBCDIC encoding vectordefinition. 

  dup 8#172 /colon put  dup 8#173 /numbersign put
  dup 8#174 /at put  dup 8#175 /quoteright put
  dup 8#176 /equal put  dup 8#177 /quotedbl put

  dup 8#201 /a put    dup 8#206 /f put  dup 8#202 /b put    dup 8#207 /g put
  dup 8#203 /c put    dup 8#210 /h put  dup 8#204 /d put    dup 8#211 /i put
  dup 8#205 /e put
  dup 8#221 /j put     dup 8#226 /o put  dup 8#222 /k put    dup 8#227 /p put
  dup 8#223 /l put     dup 8#230 /q put  dup 8#224 /m put    dup 8#231 /r put
  dup 8#225 /n put
  dup 8#242 /s put    dup 8#246 /w put  dup 8#243 /t put    dup 8#247 /x put
  dup 8#244 /u put    dup 8#250 /y put  dup 8#245 /v put    dup 8#251 /z put

  dup 8#301 /A put    dup 8#306 /F put  dup 8#302 /B put    dup 8#307 /G put
  dup 8#303 /C put    dup 8#310 /H put  dup 8#304 /D put    dup 8#311 /I put
  dup 8#305 /E put
  dup 8#321 /J put    dup 8#326 /O put  dup 8#322 /K put    dup 8#327 /P put
  dup 8#323 /L put    dup 8#330 /Q put  dup 8#324 /M put    dup 8#331 /R put
  dup 8#325 /N put
  dup 8#342 /S put    dup 8#346 /W put  dup 8#343 /T put    dup 8#347 /X put
  dup 8#344 /U put    dup 8#350 /Y put  dup 8#345 /V put    dup 8#351 /Z put

    

211
Program 17 / Re-encoding an Entire Font

(continued)

  dup 8#360 /zero put   dup 8#365 /five put  dup 8#361 /one put    dup 8#366 /six put
  dup 8#362 /two put    dup 8#367 /seven put  dup 8#363 /three put  dup 8#370 /eight put
  dup 8#364 /four put   dup 8#371 /nine putpop Remove the array from the operand stack.

/TR /Times-Roman findfont 10 scalefont def/Times-Roman /Times-Roman-EBCDIC EBCDIC
  ReEncode/TRE /Times-Roman-EBCDIC findfont 10 scalefont
  def

Print a table comparing the standard POSTSCRIPTcharacter set encoding with the EBCDIC encoding. Set
up the fonts to be used: Times Roman with the standardencoding and Times Roman with the EBCDIC
encoding. 
TR setfont0 1 3
  { /counter exch def    40 counter 133 mul add 720 moveto
    (  Octal     Standard    EBCDIC) show    40 counter 133 mul add 720 10 sub moveto
    (Number      Char          Char) show  } for

Print each column heading in the standard TimesRoman. 

/showstring 1 string def/counterstring 3 string def String definitions used to show characters and numbersbelow. 
/yline 690 def/xstart 52 def Print the table of character codes and correspondingcharacters.
0 1 255  { /counter exch def
    /charstring showstring dup 0 counter put def

For each character code from 0 to 255, print thecorresponding standard and EBCDIC characters. 

    TR setfont  xstart yline moveto    counter 8 counterstring cvrs show Print the character code in octal using cvrs.
    xstart 42 add yline moveto    charstring show Print the corresponding standard character.
    TRE setfont  xstart 86 add yline moveto    charstring show Print the corresponding EBCDIC character.
    /yline yline 10 sub def Move down one line.    counter 1 add 64 mod 0 eq
      { /xstart xstart 133 add def        /yline 690 def
      } if

If we have reached the 64th line, move over by acolumn and start at the top again. 

  } for
showpage

   

1 inch
72 points

Boktryckarkonsten a"r ka"llan till praktiskt taget all ma"nsklig odling.
Den fo"rutan hade de oerho"rda framstegen inom vetenskap
och teknik inte varit mo"jliga.
-VALTER FALK

Printing is the source of practically all human evolution.
Without it the tremendous progress in the fields of science and
technology would not have been possible.

   

213
Program 18 / Making Small Changes to Encoding Vectors

This program is slightly different from the previousprogram in that it keeps the original encoding vector of
the font but it overwrites portions of it with the newencodings specified. This method is useful when
re-encoding a font to contain accented (composite)characters.

/reencsmalldict 12 dict def Local storage for the procedure ``ReEncodeSmall.''/ReEncodeSmall
  { reencsmalldict begin    /newcodesandnames exch def
    /newfontname exch def    /basefontname exch def

``ReEncodeSmall'' generates a new re-encoded font. Ittakes 3 arguments: the name of the font to be
re-encoded, a new name, and an array of new characterencoding and character name pairs (see the definition of
the ``scandvec'' array below for the format of thisarray). This method has the advantage that it allows the
user to make changes to an existing encoding vectorwithout having to specify an entire new encoding
vector. It also saves space when the character encodingand name pairs array is smaller than an entire encoding
vector.     /basefontdict basefontname findfont def Get the font dictionary on which to base the re-encoded
version.    /newfont basefontdict maxlength dict def Create a dictionary to hold the description for the
re-encoded font.    basefontdict
      { exch dup /FID ne Copy all the entries in the base font dictionary to thenew dictionary except for the FID field.           { dup /Encoding eq
            { exch dup length array copy Make a copy of the Encoding field.                newfont 3 1 roll put }
            { exch newfont 3 1 roll put }            ifelse
          }          { pop pop } Ignore the FID pair.
          ifelse       } forall

    newfont /FontName newfontname put Install the new name.    newcodesandnames aload pop Modify the encoding vector. First load the new

encoding and name pairs onto the operand stack.    newcodesandnames length 2 idiv
      { newfont /Encoding get 3 1 roll put}      repeat For each pair on the stack, put the new name into thedesignated position in the encoding vector. 

    newfontname newfont definefont pop    end
   } def

Now make the re-encoded font description into aP

OSTSCRIPT font. Ignore the modified dictionaryreturned on the operand stack by the definefont

operator. 

   

1 inch
72 points

Boktryckarkonsten a"r ka"llan till praktiskt taget all ma"nsklig odling.
Den fo"rutan hade de oerho"rda framstegen inom vetenskap
och teknik inte varit mo"jliga.
-VALTER FALK

Printing is the source of practically all human evolution.
Without it the tremendous progress in the fields of science and
technology would not have been possible.

   

215
Program 18 / Making Small Changes to Encoding Vectors

(continued)

/scandvec [  8#300 /Oacute
  8#311 /Adieresis  8#321 /oacute
  8#322 /Ograve  8#323 /Scaron
  8#324 /ograve  8#325 /scaron
  8#330 /Edieresis  8#331 /adieresis
  8#332 /edieresis  8#333 /Odieresis
  8#334 /odieresis  8#340 /Aacute
  8#342 /Aring  8#344 /Zcaron
  8#347 /Eacute  8#360 /aacute
  8#362 /aring  8#364 /zcaron
  8#367 /eacute  ] def

Define an array of new character encoding and namepairs that will enable us to print the accented characters
in the Scandinavian languages. The array is a series ofencoding number and name pairs. The encoding number
always precedes the character name. Since it containspairs, there must be an even number of elements in this
array. The encoding vector positions for these newcharacters have been chosen so that they do not actually
replace any of the characters in the standard encoding. 

/ss { 72 yline moveto show        /yline yline 36 sub def } def This procedure shows a string and then skips a line. 
/Times-Roman /Times-Roman-Scand scandvec  ReEncodeSmall Re-encode the standard Times Roman to include theaccented characters for the Scandinavian Languages. 
/Times-Roman-Scand findfont 16 scalefont  setfont
/yline 500 def(Boktryckarkonsten \331r k\331llan till praktiskt\
 taget all m\331nsklig odling.) ss

Print some text with accented characters. Since theaccented characters are in the upper half of the encoding
vector we must refer to them by their octal codes. 

(Den f\334rutan hade de oerh\334rda framstegen\ inom vetenskap) ss
(och teknik inte varit m\334jliga.) ss(\261VALTER FALK) ss

/Times-Italic findfont 14 scalefont setfont/yline 500 18 sub def
(Printing is the source of practically all human\ evolution.) ss
(Without it the tremendous progress in the\ fields of science and) ss
(technology would not have been possible.) ssshowpage

  

HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz
HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz
HOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyozHOHOHOHO oaobocodoeofogohoiojokolomonopoqorosotouovowoxoyoz

Although the program to the right is device independent, this page was printedon a 300 dot per inch printer to emphasize the effect of rounding character widths.

6 point
7 point
8 point

   

217
Program 19 / Changing the Character Widths of a Font

This program demonstrates how to change the characterwidths of a font. The specific example used shows how
to round the character widths such that when the font isprinted at a certain point size, the widths are an integral
number of pixels in device space.
/modwidthsdict 8 dict def Local storage for the procedure ``ModifyWidths.''/ModifyWidths
  { modwidthsdict begin      /uniqueid exch def
      /newwidths exch def      /newfontname exch def
      /basefontname exch def

``ModifyWidths'' generates a new font. It takes 4arguments: the name of the font whose widths are to be
changed, a new name, a dictionary containing the newwidths and a unique ID. ModifyWidths copies the
existing font dictionary, replacing the FontName field,adds a Metrics entry and then defines a new font. 
      /basefontdict basefontname findfont def Get the dictionary of the font on which the new versionwill be based.
      /numentries basefontdict maxlength 1 add def Determine how large the new font dictionary should be.Make sure it is one entry larger than the previous one so

that it has room for the Metrics entry.      basefontdict /UniqueID known not
        { /numentries numentries 1 add def } if Make sure there is room for the UniqueID field.       /newfont numentries dict def Create the new dictionary
      basefontdict       { exch dup dup /FID ne exch
           /FontBBox ne and          { exch newfont 3 1 roll put }

Copy all the entries in the base font dictionary to thenew dictionary except for the FID and FontBBox (see
explanation below) fields. 
          { pop pop } Ignore the FID and FontBBox pairs.          ifelse
       } forall      /newFontBBox basefontdict /FontBBox get
        aload length array astore def Due to a problem in P

OSTSCRIPT version 23.0 it isnecessary to create an entirely new FontBBox entry

rather than simply make a copy. A new array is createdthat contains the same values for the font bounding box
as the base font has.       newfont /FontBBox newFontBBox put Install the new font bounding box.
      newfont /FontName newfontname put      newfont /Metrics newwidths put Install the new name and widths in the font.
      newfont /UniqueID uniqueid put Install the new unique ID.      newfontname newfont definefont pop
    end   } def Now make the font dictionary with the new metrics intoa POSTSCRIPT font. Ignore the dictionary returned on theoperand stack by the definefont operator. 

    

218

Program 19 / Changing the Character Widths of a Font

(continued)

/roundwidthsdict 13 dict def Local storage for the procedure ``roundwidths.''
roundwidthsdict /showstring 1 string put String used for stringwidth operations.
/roundwidths  { roundwidthsdict begin
    /ptsize exch def    /resolution exch def
    /fontname exch def

``roundwidths'' takes three arguments: a POSTSCRIPTfont name, a point size, and the resolution of the output
device (in the x direction). The resolution is specified inpixels per inch. ``roundwidths'' returns a dictionary of
rounded widths on the operand stack. The widths arerounded so that when they are scaled to the specified
point size, they will be an integral number of pixels indevice space. 

    /thefont fontname findfont def Get the font dictionary associated with the font name.    /newwidths thefont /CharStrings get length
      dict def Allocate a new dictionary for widths. Make it as large asnecessary (there will never be more widths than thereare CharStrings entries). 

    /pixelsperem ptsize 72 div resolution mul def Determine how many pixels are required for the givenpoint size.
    /unitsperpixel 1000 pixelsperem div def Determine how many units (in the 1000 unit font space)map to one pixel.
    gsave      nulldevice Perform the width calculations under the null device so

that we will get the actual widths without roundingeffects from the output device.
      thefont 1 scalefont setfont Use a 1 unit high font; it speeds up the time required fordetermining the width of characters.
      /charcount 0 def      thefont /Encoding get
        { /charname exch def Compute the current width for each character in theencoding vector.           charname /.notdef ne
            { /charwidth showstring dup 0 charcount                put stringwidth pop 1000 mul def Get the current character width by performing astringwidth operation and convert it to 1000ths. 
              /multiples charwidth unitsperpixel div                round cvi def
              /newcharwidth unitsperpixel multiples                mul def
              newwidths charname newcharwidth put            } if Store the newly computed width in the new dictionaryof widths. 
          /charcount charcount 1 add def        } forall
    grestore    newwidths
    end Leave the new dictionary of widths on the operandstack.   } def

    

219
Program 19 / Changing the Character Widths of a Font

(continued)

/findresdict 4 dict deffindresdict begin Local storage for the procedure ``findresolution.'' 
  /tempmatrix matrix def Matrix used in computations.  /epsilon 0.001 def
end Error tolerance (see the ``findresolution'' procedurebelow). 
/findresolution  { findresdict begin ``findresolution'' returns the resolution (in pixels perinch) in the x-direction of the device being printed on. 
      72 0 tempmatrix defaultmatrix dtransform      /y exch def /x exch def Since there are 72 units per inch in the default userspace, find out how many pixels those 72 units require

in device space.       x abs epsilon gt y abs epsilon gt and
        { stop } If both the x and y components of the vector returned bythe dtransform are larger than the error tolerance,refuse to continue because we are in some non-90

degree rotated device space that wouldn't make anysense in our computations. 
        { x dup mul y dup mul add sqrt } Leave the x-resolution on the operand stack.        ifelse
    end  } def The following prints a comparison of rounded vs.

non-rounded widths./showstring
  { (HOHOHOHO oaobocodoeofogohoiojoko) show    (lomonopoqorosotouovowoxoyoz) show } def This procedure simply shows a string of text. 
/res findresolution def Get the resolution of the printing device./uid /Times-Roman findfont dup /UniqueID known
   {/UniqueID get}{pop 0} ifelse def Find the original unique ID for the font we are using. Ifit doesn't have a unique ID, use zero. /rwid /Times-Roman res 6 roundwidths def Compute the rounded widths for 6 pt. Times Roman.
/Times-Roman /TR6 rwid uid 1 add ModifyWidths Create a new font with the 6 pt. rounded widths./Times-Roman findfont 6 scalefont setfont Print the normal 6 pt. Times Roman.
130 560 moveto showstring/TR6 findfont 6 scalefont setfont Print the 6 pt. Times Roman with rounded widths.
130 560 6 sub moveto showstring/rwid /Times-Roman res 7 roundwidths def
/Times-Roman /TR7 rwid uid 2 add ModifyWidths/Times-Roman findfont 7 scalefont setfont
130 500 moveto showstring

Repeat the same procedure for 7 point Times Roman. 

/TR7 findfont 7 scalefont setfont130 500 7 sub moveto showstring
/rwid /Times-Roman res 8 roundwidths def/Times-Roman /TR8 rwid uid 3 add ModifyWidths
/Times-Roman findfont 8 scalefont setfont130 440 moveto showstring
/TR8 findfont 8 scalefont setfont130 440 8 sub moveto showstring

Repeat the same procedure for 8 point Times Roman. 

showpage

  

1 inch
72 points

aEvery bullet has its billet. -William III
aThe bullet that will kill me is not yet cast. -Napoleon I
aThe ballot is stronger than the bullet. -Abraham Lincoln

bEvery bullet has its billet. -William III
bThe bullet that will kill me is not yet cast. -Napoleon I
bThe ballot is stronger than the bullet. -Abraham Lincoln

cEvery bullet has its billet. -William III
cThe bullet that will kill me is not yet cast. -Napoleon I
cThe ballot is stronger than the bullet. -Abraham Lincoln

Hieroglyphics are the root of letters. Allcharacters were originally signs and all
signs were once images. Human society,the world, man in his entirety is in the
alphabet.d

  

221
Program 20 / Creating an Analytic Font

This program demonstrates how to define an entirelynew font with analytic (geometric) character
descriptions.
10 dict dup begin Create a dictionary for the font. Leave room for the FID(fontID) entry.
  /FontType 3 def FontType 3 indicates that this is a user defined font.  /FontMatrix [.001 0 0 .001 0 0] def Since the font coordinate system used for this font is

based on units of 1000 (as are the built-in fonts), specifya FontMatrix that transforms the 1000 unit system to a 1
unit system.  /FontBBox [50 0 760 700] def This is the bounding box that would result if all the
characters in the font were overlapped.  /Encoding 256 array def Allocate storage for the encoding vector.
  0 1 255 {Encoding exch /.notdef put} for  Encoding Initialize all the entries in the encoding vector with``.notdef''. 
    dup (a) 0 get /smallbullet put    dup (b) 0 get /mediumbullet put
    dup (c) 0 get /largebullet put    (d) 0 get /openbox put

Associate the small bullet character with the charactercode for a lowercase a, associate the medium bullet
character with the character code for a lowercase b, andso on. 

  /Metrics 5 dict def Allocate storage for the character widths.  Metrics begin
    /.notdef 0 def    /smallbullet 400 def
    /mediumbullet 520 def    /largebullet 640 def
    /openbox 820 def  end

Make sure there is a width for the ``.notdef'' characteras well as for all the other characters in the font. 

  /BBox 5 dict def  BBox begin Create a dictionary for storing information about thebounding boxes of the character descriptions. 
    /.notdef [0 0 0 0] def Make sure there is a bounding box for ``.notdef''.    /smallbullet [50 200 350 500] def
    /mediumbullet [50 150 450 550] def    /largebullet [50 100 550 600] def
    /openbox [60 0 760 700] def  end The bounding box for the open box is slightly largerthan the path definition because it is stroked. Half of the

strokewidth (60/2 =30) is added to bounding box of theoutline. 

  /CharacterDefs 5 dict def  CharacterDefs begin The ``CharacterDefs'' dictionary will hold thedescriptions for rendering the characters. 
    /.notdef { } def There should always be a description for the undefinedcharacter ``.notdef'' which does nothing.

    

222

Program 20 / Creating an Analytic Font

(continued)

    /smallbullet      { newpath
          200 350 150 0 360 arc        closepath
        fill } def

``smallbullet'' defines a path for drawing a small bulletcentered in the capheight of a font (in this case
capheight=700 units). It also fills the path. 

    /mediumbullet      { newpath
          250 350 200 0 360 arc        closepath
        fill } def

``mediumbullet'' is defined similarly to ``smallbullet.'' 

    /largebullet      { newpath
          300 350 250 0 360 arc        closepath
        fill } def

``largebullet'' is defined similarly to ``smallbullet.'' 

    /openbox      { newpath
          90 30 moveto    90 670 lineto          730 670 lineto  730 30 lineto
        closepath        60 setlinewidth
        stroke } def

``openbox'' defines a path for drawing an outlined boxthat rests on the baseline and is as tall as the capheight
(700 units). It strokes the path with a line whosethickness is 60 units out of 1000. 

  end Finished defining the characters.
  /BuildChar    { 0 begin The procedure ``BuildChar'' is called every time acharacter from this font must be constructed. 
        /char exch def        /fontdict exch def The character code and font dictionary are provided asarguments. 
        /charname fontdict /Encoding get char get def        fontdict begin Convert the character code to the corresponding nameby looking it up in the encoding vector. 
          Metrics charname get 0 Find the width of the character.          BBox charname get aload pop Find the bounding box of the character and push it onto

the stack.              setcachedevice Using the setcachedevice operator enables the
characters from this font to be cached.          CharacterDefs charname get exec
        end      end Find the procedure for rendering the character andexecute it. 
    } def  /BuildChar load 0 3 dict put Local storage for the procedure ``BuildChar.''
  /UniqueID 1 def Create a unique identifier for the font.end Done defining the font dictionary.

/BoxesAndBullets exch definefont pop Register the font; name it ``BoxesAndBullets.''

   

223
Program 20 / Creating an Analytic Font

(continued)

/bbfont /BoxesAndBullets findfont 16 scalefont def/textfont /Times-Roman findfont 16 scalefont def The remainder of this program illustrates the use of theanalytic font intermixed with one of the standard text

fonts. 
/ss { 72 yline moveto show      /yline yline 16 sub def } def This procedure shows a string and then gets ready tomove down the page by one line. 

/showbullettext  { /bulletchar exch def ``showbullettext'' enables us to conveniently show thesame series of text but with different bullets each time.

A string containing the bullet character is passed as anargument. 
    bbfont setfont bulletchar ss Show the bullet character in the BoxesAndBullets font.    textfont setfont Switch to the standard text font.
    (Every bullet has its billet. \261William III) show    bbfont setfont bulletchar ss Show the text immediately following the bullet. (Octalcharacter 261 is an endash.) 
    textfont setfont    (The bullet that will kill me is not yet cast.) show
    ( \261Napoleon I) show    bbfont setfont bulletchar ss
    textfont setfont    (The ballot is stronger than the bullet.) show
    ( \261Abraham Lincoln) show  } def

/yline 650 def (a) showbullettext/yline 550 def (b) showbullettext
/yline 450 def (c) showbullettext

Now show three series of statements, each series with adifferent sized bullet. 

/yline 300 deftextfont setfont
(Hieroglyphics are the root of letters. All) ss(characters were originally signs and all) ss
(signs were once images. Human society,) ss(the world, man in his entirety is in the) ss
(alphabet.) ss

This example shows a common use of the ``openbox''character: as the marker at the end of a paragraph. 

bbfont setfont(d) show Place the ``openbox'' character at the end of the last

line.showpage

 

1 inch
72 points

the tendency of the best
typography has been and
still should be in the path of
simplicity, legibility, and
orderly arrangement.

theodore low de vinne

   

225
Program 21 / Creating a Bitmap Font

This program demonstrates how to efficiently define anentirely new font with bitmap character descriptions.
9 dict dup begin Allocate a dictionary for the font. Leave room for theFID (fontID).
  /FontType 3 def FontType 3 indicates that this is a user defined font tothe P

OSTSCRIPT font machinery.  /FontMatrix [1 0 0 1 0 0] def Use the identity matrix for the font coordinate system.

  /FontBBox [1.28 1.2 -0.16 -0.24] def If all the characters in the font were overlapped, thiswould be the bounding box in the 1 unit character space.
  /Encoding 256 array def Allocate space for the encoding vector.  0 1 255 {Encoding exch /.notdef put} for
  Encoding Initialize all entries in the encoding vector with``.notdef''.   dup 97 /a put    dup 105 /i put    dup 116 /t put
  dup 98 /b put    dup 108 /l put    dup 117 /u put  dup 99 /c put    dup 109 /m put  dup 118 /v put
  dup 100 /d put  dup 110 /n put  dup 119 /w put  dup 101 /e put  dup 111 /o put  dup 121 /y put
  dup 102 /f put   dup 112 /p put  dup 32 /space put  dup 103 /g put  dup 114 /r put   dup 46 /period put
  dup 104 /h put  dup 115 /s put   44 /comma put

Encode the lowercase letters and a few of thepunctuation characters according to their ASCII
encodings (decimal rather than octal codes have beenused). Note that the lowercase letters j, k, q, x, and z are
not encoded since we do not define characterdescriptions for them below (see ``CharData''
dictionary). 

  /BuildChar    { 0 begin The procedure ``BuildChar'' is called every time acharacter from this font must be constructed. 
        /char exch def        /fontdict exch def The character code and the font dictionary are providedas arguments to this procedure each time it's called. 
        /charname fontdict /Encoding get char get def Convert the character code to the corresponding nameby looking it up in the encoding vector.
        /charinfo fontdict /CharData get charname          get def Now retrieve the data for printing that character in the``CharData'' dictionary. 
        /wx charinfo 0 get def Find the width of that character.        /charbbox charinfo 1 4 getinterval def Get the bounding box of the character.
        wx 0 charbbox aload pop setcachedevice Using the setcachedevice operator enables thecharacters from this font to be cached.
        charinfo 5 get charinfo 6 get true Get the width and height of the bitmap; set the invertboolean to true since the bitmaps specify the reverse

image.        fontdict /imagemaskmatrix get
           dup 4 charinfo 7 get put           dup 5 charinfo 8 get put Insert the x and y translation components into thegeneral imagemask matrix. 
        charinfo 9 1 getinterval cvx        imagemask
      end    } def

Get the hexadecimal string for printing the character inthe form of an array, convert it into an executable object
(procedure) and then print the bitmap image. 

  /BuildChar load 0 6 dict put Create local storage for the procedure ``BuildChar.''

    

226

Program 21 / Creating a Bitmap Font

(continued)

  /imagemaskmatrix [25 0 0 -25 0 0] def This is a template imagemask transformation matrixfor this font. Since the bitmaps were designed to be 25

pixels from baseline to baseline and they are the sameresolution in the x and y directions, both the x and y
scale factors are 25. The y scale factor is negativebecause the bitmap images are specified beginning with
the upper left corner rather than the lower left corner.(See description of the imagemask operator in the
POSTSCRIPT Language Reference Manual.)  /CharData 25 dict def
  CharData begin    /a [ .64 .04 0 .56 .56 13 14 -1.5 13.5
       <0F983FD870786038C018C018C018C01       8C018C018603870783FD80F98> ] def
    /b [ .64 .04 0 .56 .76 13 19 -1.5 18.5       <C000C000C000C000C000CF80DFE0F
       070E030C018C018C018C018C018C018       E030F070DFE0CF80> ] def
    /c [ .6 .04 0 .52 .56 12 14 -1.5 13.5

The first number in the character description is thewidth of the character in the 1 unit font space. The next
four numbers are the bounding box for the character inthe 1 unit font space. The next two numbers are the
width and height of the bitmap in pixels. The next twonumbers are the x and y translation values for the
transformation matrix provided to the imagemaskoperator. The last entry in the description is the
hexadecimal string for printing the bitmap. (See below.)        <0F803FE070706030C000C000C000C00
       0C000C000603070703FE00F80> ] def    /d [.64 .04 0 .56 .76 13 19 -1.5 18.5<001800180
      018001800180F983FD870786038C018C018      C018C018C018C018603870783FD80F98>]def
    /e [ .64 .04 0 .56 .56 13 14 -1.5 13.5       <0F803FE070706030C018C018FFF8FFF
       8C000C000603070703FE00F80> ] def    /f [ .32 0 0 .28 .76 7 19 -0.5 18.5 <0E1E3830
       30FEFE303030303030303030303030> ] def    /g [.64 .04 -0.16 .56 .56 13 18 -1.5 13.5<0F983F
       D870786038C018C018C018C018C018C018       603870783FD80F98601870303FF00FC0>]def
    /h [ .6 .04 0 .52 .76 12 19 -1.5 18.5       <C000C000C000C000C000CF80DFE0F070
       E030C030C030C030C030C030C030C030C       030C030C030> ] def
    /i [ .2 .04 0 .12 .76 2 19 -1.5 18.5 <C0C0C00000       C0C0C0C0C0C0C0C0C0C0C0C0C0C0> ] def
    /l [.2 .04 0 .12 .76 2 19 -1.5 18.5<C0C0C0C0C0       C0C0C0C0C0C0C0C0C0C0C0C0C0C0> ] def
    /m [ .92 .04 0 .84 .56 20 14 -1.5 13.5       <CF0780DFCFE0F0F870E07030C06030
       C06030C06030C06030C06030C06030       C06030C06030C06030C06030> ] def
    /n [ .6 .04 0 .52 .56 12 14 -1.5 13.5

Description of Data: Since the lowercase ``i'' is arelatively simple bitmap, it is used in this explanation.
The bitmap for the ``i'' is 2 pixels (samples) wide and19 pixels high. In order to print the bitmap, a
hexadecimal string describing the pixel-image isprovided as the contents of the procedure argument to
the imagemask operator. Each pair of characters in thehexadecimal string description of the ``i'' represents a
row of pixels; each row of the bitmap image should bepadded out to the next byte boundary to ensure proper
results. The matrix provided to the imagemaskoperator describes how to map the unit square in user
space to the bitmap image space. The x and y translationcomponents vary from character to character and
indicate how many pixels to shift by so that the bitmapis positioned properly within user space. The y
translation component will always be the height of thebitmap minus any displacement factor (such as for
characters with descenders). The x component is usuallythe equivalent of the left sidebearing of the character in
pixels. Note that both the x and y translationcomponents have half a pixel (.5) subtracted from their
original values. This is done to avoid round-off errorsinduced by trying to position the bitmap image right on
a device pixel boundary.        <CF80DFE0F070E030C030C030C030C0

   

227
Program 21 / Creating a Bitmap Font

(continued)

       30C030C030C030C030C030C030> ] def    /o [ .64 .04 0 .56 .56 13 14 -1.5 13.5
       <0F803FE070706030C018C018C018C0       18C018C018603070703FE00F80> ] def
    /p [.64 .04 -.16 .56 .56 13 18 -1.5 13.5<CF80DF      E0F070E030C018C018C018C018C018C018E
      030F070DFE0CF80C000C000C000C000>]def    /r [ .32 .04 0 .28 .56 6 14 -1.5 13.5 <DCFCE0
       C0C0C0C0C0C0C0C0C0C0C0> ] def    /s [ .36 0 0 .32 .56 8 14 -0.5 13.5
       <3C7EC3C3C0E0781E0703C3C37E3C> ] def    /t [ .36 0 0 .32 .76 8 19 -0.5 18.5 <1818181818
       FFFF181818181818181818181818> ] def    /u [ .6 .04 0 .52 .56 12 14 -1.5 13.5
       <C030C030C030C030C030C030C030C0       30C030C030C070E0F07FB01F30> ] def
    /v [ .48 0 0 .44 .56 11 14 -0.5 13.5       <C060C060C06060C060C060C0318031
       8031801B001B001B000E000E00> ] def    /w [ .88 0 0 .84 .56 21 14 -0.5 13.5
       <C07018C07018C0701860D83060D830       60D830318C60318C60318C601B06C0
       1B06C01B06C00E03800E0380> ] def    /y [.48 0 -.16 .44 .56 11 18 -.5 13.5<C060C060
       C06060C060C060C03180318031801B001B       001F000600060006000C000C000C00>]def
    /period [.28 .08 0 .16 .12 2 3 -2.5 2.5       <C0C0C0> ] def
    /comma [.32 0 -0.08 .2 .08 5 4 -0.5 1.5       <183060C0> ] def
    /space [.24 0 0 0 0 1 1 0 0 <> ] def    /.notdef [.24 0 0 0 0 1 0 0 <> ] def
  end Pop the ``CharData'' dictionary.  /UniqueID 2 def Create a unique identifier for the font.
end Done specifying the information required for the font./Bitfont exch definefont pop Register the font and name it ``Bitfont.''

/Bitfont findfont 12 scalefont setfont72 500 moveto (the tendency of the best) show
72 488 moveto (typography has been and) show72 476 moveto (still should be in the path of) show
72 464 moveto (simplicity, legibility, and) show72 452 moveto (orderly arrangement.) show

The following lines illustrate the bitmap font in use. 

/Bitfont findfont 8 scalefont setfont72 436 moveto (theodore low de vinne) show Just like any other POSTSCRIPT font, the bitmap font canbe scaled to any size. 
showpage

   

FOR FURTHER REFERENCE
Adobe  Systems,  Inc. POSTSCRIPT Language  Reference  Manual.Addison-Wesley, Reading, Massachusetts, 1985.
Foley, James D. and Van Dam, Andries. Fundamentals of Inter-active  Computer  Graphics.  Addison-Wesley,  Reading,  Massachusetts, 1982.
IBM System/360: Priciples of Operation, Ninth Edition, Novem-ber 1970.

Newman, William M. and Sproull, Robert F. Principles of Inter-active Computer Graphics. McGraw-Hill, New York, 1979.
Pratt,  Terrence  W. Programming  Languages:  Design  andImplementation.  Prentice-Hall,  Inc.,  Englewood  Cliffs,  N.J.,

1975.
Warnock,  John  and  Wyatt,  Douglas.  ``A  Device  IndependentGraphics  Imaging  Model  for  Use  with  Raster  Devices,''

Computer  Graphics Volume  16,  Number  3,  July  1982,  pp.313-320.

229

   

QUOTATIONS
page 180: Daniel Berkeley Updike Printing Types: Their History, Forms,& Use Cambridge (Mass.) 1951, Vol. II, pp. 274-275.
page 158: John C. Tarr Design in Typography London, 1951, p.21.
page 172: Woody Allen Interview by Time Magazine April 30, 1979
page 212: Valter Falk, Stockholm. Manuale Typographicum Frankfurt amMain 1954, p.34.

page 220: William III from John Wesley, Journal June 6, 1765
page 220: Napoleon I at Montereau February 17, 1814
page 220: Abraham Lincoln Speech at Bloomington, Illinois May 19, 1856
page 220: Victor Hugo in France et Belgique - Alpes et Pyrenees - Voyageset Excursions Paris 1910, pp. 215-216.

page 224: Theodore Low De Vinne A Treatise of Title Pages New York1902, p.439.

231

    

APPENDIX
OPERATOR SUMMARY

Operand stack manipulation operators

any pop - discard top element
any any exch any any exchange top two elements1 2 2 1

any dup any any duplicate top element
any ..any n copy any ..any any ..any duplicate top n elements1 n 1 n 1 n
any ..any n index any ..any any duplicate arbitrary elementn 0 n 0 n

a ..a n j roll a ..a a ..a roll n elements up j timesn-1 0 (j-1) mod n 0 n-1 j mod n^

any ..any clear ^ discard all elements1 n^
any ..any count ^ any ..any n count elements on stack1 n 1 n

- mark mark push mark on stack
mark obj ..obj cleartomark - discard elements down through mark1 n
mark obj ..obj counttomark mark obj ..obj n count elements down to mark1 n 1 n

Arithmetic and math operators

num num add sum num plus num1 2 1 2
num num div quotient num divided by num1 2 1 2

int int idiv quotient integer divide1 2
int int mod remainder int mod int1 2 1 2
num num mul product num times num1 2 1 2
num num sub difference num minus num1 2 1 2

num abs num absolute value of num1 2 1
num neg num negative of num1 2 1
num ceiling num ceiling of num1 2 1
num floor num floor of num1 2 1
num round num round num to nearest integer1 2 1
num truncate num remove fractional part of num1 2 1

num sqrt real square root of num
num den atan angle arctangent of num/den in degrees

233

    

angle cos real cosine of angle (degrees)
angle sin real sine of angle (degrees)
base exponent exp real raise base to exponent power

num ln real natural logarithm (base e)
num log real logarithm (base 10)

- rand int generate pseudo-random integer
int srand - set random number seed

- rrand int return random number seed

Array operators

int array array create array of length int

- [ mark start array construction
mark obj ..obj ] array end array construction0 n-1

array length int number of elements in array
array index get any get array element indexed by index
array index any put - put any into array at index
array index count getinterval subarray subarray of array starting at index for count

elements
array index array putinterval - replace subarray of array starting at index1 2 1

by array2
array aload a ..a array push all elements of array on stack0 n-1
any ..any array astore array pop elements from stack into array0 n-1

array array copy subarray copy elements of array to initial subarray of1 2 2 1

array2
array proc forall - execute proc for each element of array

Dictionary operators

int dict dict create dictionary with capacity for int elements
dict length int number of key-value pairs in dict
dict maxlength int capacity of dict
dict begin - push dict on dict stack

- end - pop dict stack
key value def - associate key and value in current dict

key load value search dict stack for key and return associated value
key value store - replace topmost definition of key

dict key get any get value associated with key in dict
dict key value put - associate key with value in dict

dict key known bool test whether key is in dict

key where dict true

or false find dict in which key is defined
dict dict copy dict copy contents of dict to dict1 2 2 1 2

dict proc forall - execute proc for each element of dict

- errordict dict push errordict on operand stack
- systemdict dict push systemdict on operand stack
- userdict dict push userdict on operand stack

234 Appendix:  OPERATOR SUMMARY

   

- currentdict dict push current dict on operand stack
- countdictstack int count elements on dict stack
array dictstack subarray copy dict stack into array

String operators

int string string create string of length int
string length int number of elements in string
string index get int get string element indexed by index
string index int put - put int into string at index
string index count getinterval substring substring of string starting at index for count

elements
string index string putinterval - replace substring of string starting at index1 2 1

by string2
string string copy substring copy elements of string to initial substring1 2 2 1

of string2
string proc forall - execute proc for each element of string
string seek anchorsearch post match true

or string false determine if seek is initial substring of string
string seek search post match pre true

or string false search for seek in string
string token post token true

or false read token from start of string

Relational, boolean, and bitwise operators

any any eq bool test equal1 2
any any ne bool test not equal1 2
num |str num |str ge bool test greater or equal1 1 2 2
num |str num |str gt bool test greater than1 1 2 2
num |str num |str le bool test less or equal1 1 2 2
num |str num |str lt bool test less than1 1 2 2

bool |int bool |int and bool |int logical | bitwise and1 1 2 2 3 3

bool |int not bool |int logical | bitwise not1 1 2 2
bool |int bool |int or bool |int logical | bitwise inclusive or1 1 2 2 3 3
bool |int bool |int xor bool |int logical | bitwise exclusive or1 1 2 2 3 3

- true true push boolean value true
- false false push boolean value false
int shift bitshift int bitwise shift of int (positive is left)1 2 1

Control operators

any exec - execute arbitrary object
bool proc if - execute proc if bool is true
bool proc proc ifelse - execute proc if bool is true, proc if bool is1 2 1 2

false
init incr limit proc for - execute proc with values from init by steps

of incr to limit
int proc repeat - execute proc int times

proc loop - execute proc an indefinite number of times

235

   

- exit - exit innermost active loop
- stop - terminate stopped context
any stopped bool establish context for catching stop

- countexecstack int count elements on exec stack
array execstack subarray copy exec stack into array

- quit - terminate interpreter
- start - executed at interpreter startup

Type, attribute, and conversion operators

any type name return name identifying any's type
any cvlit any make object be literal
any cvx any make object be executable
any xcheck bool test executable attribute
array|file|string executeonly array|file|string reduce access to execute-only
array|dict|file|string noaccess array|dict|file|string disallow any access
array|dict|file|string readonly array|dict|file|string reduce access to read-only
array|dict|file|string rcheck bool test read access
array|dict|file|string wcheck bool test write access

num|string cvi int convert to integer

string cvn name convert to name
num|string cvr real convert to real
num radix string cvrs substring convert to string with radix

any string cvs substring convert to string

File operators
string string file file open file identified by string with access1 2 1

string2
file closefile - close file
file read int true

or false read one character from file
file int write - write one character to file
file string readhexstring substring bool read hex from file into string
file string writehexstring - write string to file as hex
file string readstring substring bool read string from file
file string writestring - write characters of string to file
file string readline substring bool read line from file into string

file token token true

or false read token from file
file bytesavailable int number of bytes available to read

- flush - send buffered data to standard output file
file flushfile - send buffered data or read to EOF
file resetfile - discard buffered characters
file status bool return status of file
string run - execute contents of named file

- currentfile file return file currently being executed
string print - write characters of string to standard output

file

236 Appendix:  OPERATOR SUMMARY

    

any = - write text representation of any to standard

output file^
any .. any stack ^ any .. any print stack nondestructively using =1 n 1 n

any == - write syntactic representation of any to

standard output file^
any .. any pstack ^ any .. any print stack nondestructively using ==1 n 1 n

- prompt - executed when ready for interactive input
bool echo - turn on/off echoing

Virtual memory operators

- save save create VM snapshot
save restore - restore VM snapshot

- vmstatus level used maximum report VM status

Miscellaneous operators

proc bind proc replace operator names in proc by

operators
- null null push null on operand stack
- usertime int return time in milliseconds
- version string interpreter version

Graphics state operators

- gsave - save graphics state
- grestore - restore graphics state
- grestoreall - restore to bottommost graphics state
- initgraphics - reset graphics state parameters
num setlinewidth - set line width

- currentlinewidth num return current line width
int setlinecap - set shape of line ends for stroke (0=butt,

1=round, 2=square)
- currentlinecap int return current line cap
int setlinejoin - set shape of corners for stroke (0=miter,

1=round, 2=bevel)
- currentlinejoin int return current line join
num setmiterlimit - set miter length limit

- currentmiterlimit num return current miter limit
array offset setdash - set dash pattern for stroking

- currentdash array offset return current dash pattern
num setflat - set flatness tolerance

- currentflat num return current flatness
num setgray - set color to gray value from 0 (black) to 1

(white)
- currentgray num return current gray
hue sat brt sethsbcolor - set color given hue, saturation, brightness

- currenthsbcolor hue sat brt return current color hue, saturation, brightness
red green blue setrgbcolor - set color given red, green, blue

237

    

- currentrgbcolor red green blue return current color red, green, blue
freq angle proc setscreen - set halftone screen

- currentscreen freq angle proc return current halftone screen
proc settransfer - set gray transfer function

- currenttransfer proc return current transfer function

Coordinate system and matrix operators

- matrix matrix create identity matrix
- initmatrix - set CTM to device default
matrix identmatrix matrix fill matrix with identity transform
matrix defaultmatrix matrix fill matrix with device default matrix
matrix currentmatrix matrix fill matrix with CTM
matrix setmatrix - replace CTM by matrix

t t translate - translate user space by (t ,  t )x y x y
t t matrix translate matrix define translation by (t , t )x y x y

s s scale - scale user space by s and sx y x y
s s matrix scale matrix define scaling by s and sx y x y

angle rotate - rotate user space by angle degrees
angle matrix rotate matrix define rotation by angle degrees

matrix concat - replace CTM by matrix * CTM
matrix matrix matrix concatmatrix matrix fill matrix with matrix * matrix1 2 3 3 3 1 2

x y transform xc' yc' transform (x, y) by CTM
x y matrix transform xc' yc' transform (x, y) by matrix

dx dy dtransform dxc' dyc' transform distance (dx, dy) by CTM
dx dy matrix dtransform dxc' dyc' transform distance (dx, dy) by matrix

xc' yc' itransform x y inverse transform (xc', yc') by CTM
xc' yc' matrix itransform x y inverse transform (xc', yc') by matrix

dxc' dyc' idtransform dx dy inverse transform distance (dxc', dyc') by

CTM
dxc' dyc' matrix idtransform dx dy inverse transform distance (dxc', dyc') by

matrix
matrix matrix invertmatrix matrix fill matrix with inverse of matrix1 2 2 2 1

Path construction operators

- newpath - initialize current path to be empty
- currentpoint x y return current point coordinate
x y moveto - set current point to (x, y)
dx dy rmoveto - relative moveto

x y lineto - append straight line to (x, y)
dx dy rlineto - relative lineto
x y r ang ang arc - append counterclockwise arc1 2
x y r ang ang arcn - append clockwise arc1 2

x y x y r arcto xt yt xt yt append tangent arc1 1 2 2 1 1 2 2
x y x y x y curveto - append Bezier cubic section1 1 2 2 3 3
dx dy dx dy dx dy rcurveto - relative curveto1 1 2 2 3 3

- closepath - connect subpath back to its starting point

238 Appendix:  OPERATOR SUMMARY

    

- flattenpath - convert curves to sequences of straight

lines
- reversepath - reverse direction of current path
- strokepath - compute outline of stroked path
string bool charpath - append character outline to current path

- clippath - set current path to clipping path
- pathbbox ll ll ur ur return bounding box of current pathx y x y
move line curve close pathforall - enumerate current path

- initclip - set clip path to device default
- clip - establish new clipping path
- eoclip - clip using even-odd inside rule

Painting operators

- erasepage - paint current page white
- fill - fill current path with current color
- eofill - fill using even-odd rule
- stroke - draw line along current path
width height bits/sample matrix proc image - render sampled image onto current page

width height invert matrix proc imagemask - render mask onto current page

Device setup and output operators

- showpage - output and reset current page
- copypage - output current page
matrix width height proc banddevice - install band buffer device
matrix width height proc framedevice - install frame buffer device

- nulldevice - install no-output device
proc renderbands - enumerate bands for output to device

Character and font operators

key font definefont font register font as a font dictionary

key findfont font return font dict identified by key
font scale scalefont fontc' scale font by scale to produce new fontc'
font matrix makefont fontc' transform font by matrix to produce new

fontc'
font setfont - set font dictionary

- currentfont font return current font dictionary
string show - print characters of string on page
a a string ashow - add (a , a ) to width of each char whilex y x y

showing string
c c char string widthshow - add (c , c ) to width of char while showingx y x y

string
c c char a a string awidthshow - combined effects of ashow and widthshowx y x y

proc string kshow - execute proc between characters shown

from string
string stringwidth w w width of string in current fontx y

- FontDirectory dict dictionary of font dictionaries
- StandardEncoding array standard font encoding vector

239

  

Font cache operators

- cachestatus bsize bmax msize mmax csize cmax blimit

return cache status and parameters
w w ll ll ur ur setcachedevice - declare cached character metricsx y x y x y

w w setcharwidth - declare uncached character metricsx y

num setcachelimit - set max bytes in cached character

Errors

dictfull no more room in dictionary
dictstackoverflow too many begins
dictstackunderflow too many ends
execstackoverflow exec nesting too deep
handleerror called to report error information
interrupt external interrupt request (e.g., control-C)
invalidaccess attempt to violate access attribute
invalidexit exit not in loop
invalidfileaccess unacceptable access string
invalidfont invalid font name or dict
invalidrestore improper restore
ioerror input/output error occurred
limitcheck implementation limit exceeded
nocurrentpoint current point is undefined
rangecheck operand out of bounds
stackoverflow operand stack overflow
stackunderflow operand stack underflow
syntaxerror syntax error in POSTSCRIPT program text
timeout time limit exceeded
typecheck operand of wrong type
undefined name not known
undefinedfilename file not found
undefinedresult over/underflow or meaningless result
unmatchedmark expected mark not on stack
unregistered internal error
VMerror VM exhausted

240 Appendix:  OPERATOR SUMMARY

   

Index
% comment character  24 Built-in fonts  201

Bullet character  221
.notdef  201, 209, 218, 221, 225

Cap height  156, 159, 222==
13, 15 ceiling 10

Character  155[
86 bounding box  155

composite  202, 213]
86 encoding  202

Character code  94, 167, 209, 222
Accented characters  202, 213 convert  167add

4, 9, 10, 15, 62 octal  94, 209
Algol  130 Character encoding  91aload

83, 84, 86 Character operators  46, 100and
62 Character widths
Apple LaserWriter  119, 193, 217 changing  217setscreen

limitations  193 rounded  202
font metrics problem  217 charpath 97, 98, 99, 100, 102, 159, 163
interactive use  119 Circles  55
preparing  119 Circular arcs  53arc

53, 54, 60, 129, 135, 149 printing text around  169arcn

54, 60 clear 12, 15
Arcs clip 101, 102, 110, 185

elliptical  139 Clipping boundary  185arcto

56, 57, 58, 60 Clipping path  3, 101
Arithmetic  8, 10 closepath 21, 25, 52, 149, 174array

77, 86 Closepath
Array index  78 implicit  141
Array operators  78, 86 Comments  24
Arrays  61, 77 Comparison operators  62

executable  61, 65, 67, 133 Composite characters  202, 213
Arrows Composite objects  78

drawing  143 concatmatrix 194
ASCII  5, 91, 181, 225 Conditional operators  65ashow

87 Control operators  60, 76astore
83, 86 Conversion operators  76awidthshow

87 Coordinate system  3, 47, 98, 207

current  56, 68begin
130 default  135
Binary image  113 device  47
Bitmap font  225 font  225
Bitmap pattern  193 mirror image  194
Bitmaps  113 stroke width  207bitshift

196 user  3, 47, 95, 137, 139, 143
Boolean object  65 Coordinate systems operators  60
Bounding box  155, 159, 163, 221 Coordinate transformationsBuildChar

200, 222, 225 nested  135

241

   

copypage 185 exch 11, 12, 15
Current coordinate system  56, 68 Executable arrays  65, 67, 133
Current dictionary  28, 29, 130 executive 120
Current font  36, 37, 41, 68, 84, 91, 155, 156, 39 exit 67, 69, 71, 76, 181
Current page  2, 17, 68, 91, 93, 95, 97 exp 10
Current path  2, 18, 19, 20, 23, 51, 159, 163, 173, 189
Current point  18, 19, 20, 24 FID 199, 205, 209, 213, 217, 221, 225
Current transformation matrix  95, 137 fill 22, 23, 25, 32, 51, 53, 99, 129, 135, 141, 177currentfile

151, 153 findfont 37, 44, 46, 209, 217currentmatrix

137, 139, 143, 194 flattenpath 149, 159, 163, 173, 174currentpoint
52, 60, 72, 159, 175 Font  35, 36, 199currenttransfer

153 anamorphic scale  155, 156
Curves  53 bitmap  225curveto

53, 149, 159, 163, 174 character widths  217cvrs
211 condensed  96cvs
72, 73, 76 coordinate system  225cvx

225 creating a new  200

creating an analytic  221
Dash array  106 current  36, 37, 41, 68, 84, 91, 155, 156, 39
Dash offset  106 expanded  96
Dash patterns modifying existing  199

centered  147 obliqued  97
Data types  5 outline  205def

28, 29, 33, 44, 62, 130, 139 re-encoding  209
Default user space  47, 193 transformation matrix  95defaultmatrix

193 user defined  200, 225definefont
199, 200, 205, 209, 213, 217 Font dictionary  36, 37, 44, 91, 95, 96, 97, 199, 200, 201, 202, 222
Device coordinate system  47 Font operators  46, 100
Device independence  193 Font transformations  94
Device space  3, 47, 202, 217, 218 FontBBox 200, 217dict

130 FontDirectory 37, 217
Dictionary  5, 130 FontMatrix 200, 221

create a new  132 FontName 200, 217
current  28, 29, 130 FontType 200
font  36, 37, 44, 91, 95, 96, 97, 200, 201, 202, 222 for 67, 68, 69, 76, 80, 98, 103, 135
system  27 forall 69, 81, 83, 86, 167, 190
user  27 FORTH 4
Dictionary operators  33 Fractions  156, 163
Dictionary stack  27, 130, 131, 139 setting  163div

10, 11, 15dtransform

193, 219 ge 62, 76dup
12, 15, 78 Geometric figures  1get

78, 79, 83, 86
EBCDIC  201, 209, 210, 211 getinterval 181, 225
Ellipses  55, 139 Graphics  41
Elliptical arcs  139 Graphics objects  1
Encoding  200 types  1

character  202 Graphics operators  1, 47
vector  201 Graphics output operators  117
Encoding accented characters  202 Graphics state  50, 51
Encoding vector  201, 221, 225 saving  51

making small changes  213 Graphics state operators  60, 110
re-encoding  209 Graphics state stack  51eq

62, 67, 76 grestore 51, 53, 60, 99, 135, 137, 139, 159, 189erasepage

185 gsave 51, 53, 60, 74, 99, 135, 137, 139, 159, 189
Error tolerance  219 gt 62, 76

242 INDEX

   

Halftone  177 Mitered joins  105
Halftone screen  177, 193, 195 mod 10, 15, 67

angle  193 moveto 18, 19, 20, 21, 23, 25, 37, 40, 41, 45, 149, 174
cell  195 mul 10, 15
frequency  193
spot function  193 ne 62, 76
Hexadecimal characters  197 neg 10
Hexadecimal string  113, 151, 225 newpath 18, 19, 25, 32
Hexadecimal string notation  197 not 62

notdef  201, 209, 218, 221, 225idiv
10, 15 null 78if
62, 75, 76 Null objects  78ifelse

65, 67, 76image

111, 112, 113, 114, 115, 117, 130, 151, 153, 200 Objectsimagemask

225, 226 composite  78
Images Octal codes  92, 94, 215

printing  151 Operand stack  159, 194, 217, 218
Imaging model  2 Operands  4, 9
Inch  29, 31 Operators  8, 9, 10, 12initgraphics

185 arithmetic  10
Interactive mode array  78, 86

leaving  121 character  46, 100
using  120 comparison  62
Interactive operators  15 conditional  65invalidfont

200 control  60, 76itransform
189 conversion  76

coordinate systems  60
Kerning  88 dictionary  33
Key  29, 44, 130, 133 font  46, 100kshow

87, 88, 90, 100 graphics output  117

graphics state  60, 110
Labeling graphs and illustrations  156 interactive  12, 15
LaserWriter math  15

See  Apple LaserWriter output  25le
62, 71, 76 painting  25length

79, 83, 86 path construction  25, 60, 100limitcheck

193 polymorphic  13, 83, 86, 117
Line breaking algorithm  181 relational  76
Line drawing  104 stack  12, 15, 86
Lines string  76

expanded and constant width  137 or 62lineto

18, 19, 20, 24, 25, 149, 174 Output device
Literal  28 coordinate system  3loop

67, 69, 76, 181 Output operators  25
Loops  67, 81lt

62, 76 Page description  1

Painting operators  2, 25
Macintosh  119 PaintType 205
MacTerminal  119, 120 Pascal  130makefont

95, 97, 100, 155, 156, 159, 163 Path  17mark
86 computing the length of  149
Mark  5, 78 placing text along an arbitrary  173
Math operators  15 Path construction operators  25, 60, 100Metrics

217 Path operators  3
Mirror image  194 pathbbox 159, 163
Miter limit  105, 106, 189 pathforall 149, 173, 174

243

   

Pattern-fill  177 roll 12, 15
Patterns rotate 49, 60, 95, 129, 139, 170

filling an area with  193
Picture element  111 Sampled images  2
Pie chart scale 49, 60, 95, 97, 115, 129, 137

drawing  189 Scale factor  159
Pixel  111, 113, 115, 195, 202, 217, 218, 226 scalefont 37, 39, 44, 46
Point sizes  38 Screen
Polymorphic operators  83, 86, 117 halftone  177pop

12, 15, 57, 84 search 177, 181
Poster  185 setcachedevice 200, 222, 225
Postfix notation  4 setcharwidth 200
POSTSCRIPT 1 setdash 106, 107, 109, 110, 130, 147

as a programming language  4 setfont 37, 39, 44, 45, 46
data types  5 setgray 22, 25, 67, 190, 196, 200
Imaging model  2 setlinecap 104, 105, 110
operators  8, 9 setlinejoin 105, 110
page description  1 setlinewidth 21, 25, 104
painting operators  2 setmatrix 97, 137, 139, 143
path operators  3 setmiterlimit 106, 110, 189
stack  4, 7 setrgbcolor 200
POSTSCRIPT arrays  77 setscreen 193, 194
POSTSCRIPT fonts  35, 36 settransfer 151, 153, 196
POSTSCRIPT images Shapes

overlapping  23 repeated  135
POSTSCRIPT interpreter  8, 27, 61, 120, 126, 130, 153, 200 show 37, 40, 46, 73, 87, 169, 202
POSTSCRIPT language  125 showpage 19, 25, 53, 185

programming example  125 sin 10
POSTSCRIPT object  44 Small caps  155, 159
POSTSCRIPT objects  7 printing  159

delimiters of  8 Spot function  193
Printing sqrt 10

fractions  163 Stack  4, 7, 12, 130
graphics  41 dictionary  27, 130, 131, 139
small caps  159 graphics state  51
text  35, 41 operand  159, 167, 194, 217, 218
typefaces  39 Stack notation  9
Procedure  61 Stack operators  15, 86
Procedures  29, 30, 32 Standard encoding  91, 201

concatenating  151 string 72, 76
defining  32 Stringpstack

13, 15 character code  167put
78, 83, 86, 92, 93 hexadecimal  151, 225putinterval

117 String index  93

String objects  35quit
121 String operators  76stringwidth

45, 46, 64, 170, 175, 177, 181, 218
Re-encoding a font  209 stroke 19, 20, 24, 25, 53, 99, 104, 129, 137, 141readhexstring

151, 153 Stroke width  207
Recursion  71 StrokeWidth 205
Recursive graphics  73 sub 4, 9, 10, 11, 15
Relational operators  76 System dictionary  27repeat

52, 56, 60, 61, 62, 67, 69
Resolution  193, 219 Text  1, 41rlineto

19, 24, 25 along an arbitrary path  173rmoveto

20, 25 circular  169

244 INDEX

   

vertical  167
Transfer function  151, 153transform

174, 175, 189
Transformation matrix  94, 95, 226imagemask

226
current  95, 137
font  95translate

47, 48, 60, 95, 139, 171, 185
Translation  47
Typeface  35, 39, 83, 155

x-height  155
Typeface family  35
Typesetting  155
Typography  155

UniqueID 200, 205, 217
Unit square  151
User coordinate system  47, 95, 137, 139, 143
User dictionary  27
User space  3, 4, 47, 151, 167

default  47, 193, 219
translating  47

Variables  28, 30, 44, 130

local  130, 139

Widths

changing  217widthshow

87
Word break  181

x-height  155, 156, 159xor

62

245

  

Colophon
Camera-ready  copy  for  this  book  was  created  entirely  withP

OSTSCRIPT and  printed  on  a  Linotron  101  at  Adobe  SystemsIncorporated.  The  book  was  created  with  the  aid  of  the  Scribe

Document Production System (a product of UNILOGIC, Ltd.) as aScribe  document  definition.  The  illustrations  were  P

OSTSCRIPTprogram  segments  which  Scribe  integrated  and  placed  on  the

pages along with the formatted text portions.
Successive drafts  of  the  book  were  processed  with Scribe,  eachtime  generating  a  single  P

OSTSCRIPT print  file.  The  book  wasproofed  when  needed  by  printing  the  file  on  an  Apple

LaserWriter  POSTSCRIPT printer.  The  final  version  was  printedwithout modification on a Linotype Linotron 101 typesetter and
delivered  to  Addison-Wesley.  No  manual  paste-up  of  any  kindwas required.

The  typefaces  used  in  this  book  were  digitized  by  AdobeSystems  Incorporated.  The  body  type  is  Times  Roman  with

Italic,  Bold,  and  Bold  Italic.  The  titles  and  examples  are  inHelvetica  with  Bold,  Oblique,  and  Bold  Oblique.  The  fixed
width  font  used  in  some  example  output  is  Courier.  Adobe'sSymbol font is also featured.

247