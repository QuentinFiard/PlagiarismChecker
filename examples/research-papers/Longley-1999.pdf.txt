

When  is  a  functional  program  not  a  functional  program? 

John  Longley 

Abstract 
In  an  impure  functional  language,  there  are  programs  whose behaviour  is  completely  functional  (in  that  they  behave  ex- 
tensionally  on  inputs),  but  the  functions  they  compute  can- not  be  written  in  the  purely  functional  fragment  of  the 
language.  That  is,  the  class  of  programs  with  functional behaviour  is  more  expressive  than  the  usual  class  of  pure 
functional  programs.  In  this  paper  we  introduce  this  exten- ded  class  of  `Lfunctional"  programs  by  means  of  examples  in 

Standard  ML,  and  explore  what  they  might  have  to  offer  to programmers  and  language  implementors. 

After  reviewing  some  theoretical  background,  we  present some  examples  of  functions  of  the  above  kind,  and  discuss 
how  they  may  be  implemented.  We  then  consider  two  pos- sible  programming  applications  for  these  functions:  the  im- 
plementation  of  a  search  algorithm,  and  an  algorithm  for exact  real-number  integration.  We  discuss  the  advantages 

and  limitations  of  this  style  of  programming  relative  to  other approaches.  We  also  consider  the  increased  scope  for  com- 
piler  optimieations  that  these  functions  would  offer. 

0  Introduction 
This  paper  is  concerned  with  a  rather  surprising  fact.  In  an impure  functional  language  such  as  Standard  ML  [6],  there 
exist  programs  whose  behaviour  is  completely  functional- in  the  sense  that  they  can  be  modelled  simply  by  a  math- 
ematical  function  from  input-values  to  output-values-but the  functions  they  compute  cannot  be  written  in  the  purely 
functional  fragment  of  the  language. Let  us  explain  more  carefully  what  we  mean  by  "pro- 

grams  whose  behaviour  is  functional".  For  simplicity  we will  consider  only  simply  typed  ML  terms  over  the  basic 

types  unit,  boo1  and  int.  We  will  model  these  basic  types semantically  by  the  evident  sets  of  values  (writing  *  for  the 
value  0): 

[unit]  =  {*} [boo11  =  {true,false) 

tint]  ={...-2,-1,0,1,2  ,...  ] 
Given  I[o]  and  I[r],  we  will  model  the  function  type  u->T by  a  certain  set  [a->~]  of  partial  functions  from  [a]  to  [r] 

(see  below).  We  define  inductively  what  it  means  for  an  ML term  M  : u  to  denote  an  element  of  [o].  For  basic  types  y, 
we  say  that  M  denotes  v  E  (I y  ]  if  M  evaluates  to  u,  say  in the  initial  dynamic  environment.  For  function  types  u->r 

we  say  that  A4  denotes  a  partial  function  f  :  [c]  2  [r]  if whenever  N  : Q denotes  I  E  [[ o J, 

l  if  f(z)  =  y  then  MN  denotes  y,  and 

l  if  f(z)  is  undefined  then  MN  diverges. 
In  fact,  we  define  the  denotation  relations  and  the  sets  UC] by  simultaneous  recursion  on  types,  taking  [u->r]  to  be 

the  set  of  all  partial  functions  [u1]  2  [r]  that  are  denoted by  some  term  M. 

We  will  now  say  a  term  M  :  u  is  functional  (in  beha- viour)  if  it  denotes  some  element  f  E  [a].  Intuitively,  such 
a  term  behaves  extensionally  on  its  inputs-provided,  of course,  that  these  inputs  are  themselves  functional  in  the 
same  sense-so  its  behaviour  on  such  inputs  is  captured completely  by  the  mathematical  function  f.  We  will  reserve 
the  term  pure  for  terms  written  in  the  usual  pure  functional fragment  of  ML. 

We  now  give  a  simple  example  to  show  that  the  class  of functional  programs  defined  above  is  more  expressive  than 
the  class  of  pure  functional  programs.  First  note  that  the set  [unit->unit  Jj has  just  two  elements  T,  I: 

T(*)  =  * I(  *)  is  undefined 
Next,  the  set  [E( unit-hit)->unit  ]  contains  just  three  ele- ments  top,  mid,  hot;'  they  may  be  defined  in  ML  respectively 
by 

fun  top  x  =  0 fun  mid  x  =  x  0 

fun  bot  x  =  bot  x 
Notice  that  bot  5  mid  5  top  with  respect  to  the  pointwise ordering. 

Now  let  F  :  [(unit->nnit)->nnit)]  A  [Ebool]  be  the partial  function  specified  by 

F(  top)  =  false F(mid)  =  true 
F(  bot)  is  undefined. 
Intuitively,  given  g  E  [(unit-)unit)-tiit],  the  result of  Fg  (if  defined)  tells  us  whether  g needs  to  "look  at"  its  ar- 

gument  in  order  to  return  a  result.  Clearly  F is  a  mathemat- ically  well-defined  partial  function,  but  it  cannot  be  written 

`There  is  also  a  fourth  partial  function  h  : [unit->unit  ]I d  nunit  ]I such  that  h(T)  is  undefined  but  h(l)  =  +;  however,  it  follows  from 
the  undecidability  of  the  halting  problem  that  this  function  is  not denotable  even  in  full  ML. 

in  the  pure  functional  fragment  of  ML,  since  it  is  not  mono- tonic  with  respect  to  the  pointwise  ordering.  However,  F can 
be  implemented  in  impure  ML,  for  example  using  references: 

funFg= let  val  r  =  ref  false  in 

(g  (fn  ()=>(r:=true;()))  ;  !r) end 

Other  implementations  of  F  using  exceptions  or  continu- ations  are  also  possible-see  Section  1.3  below. 

The  idea  is  that  programmers  could  make  use  of  func- tions  such  as  F  and  still  believe  they  were  doing  functional 
programming.  The  semantics  of  local  references  in  ML  en- sures  that  even  nested  calls  to  F  behave  in  the  functionally 
correct  way. Here  is  an  example  to  show  how,  in  principle,  a  func- 
tion  like  F might  be  used  to  advantage.  Suppose  we  want  a program  which  takes  a  function  g  from  integers  to  integers 
and  computes  the  sum  ~~~~`ooo  g(i).  Suppose  moreover that,  for  some  reason,  the  arguments  of  g  are  to  be  given 

lazily-that  is,  g  is  to  be  represented  by  an  ML  function g:  (unit->int)->int.  Let 

Sumi  :  ( (unit->int)  ->int)  ->  int 
be  a  pure  ML  function  that  computes  the  sum  in  the  obvious way.  Now  observe  that  if  g  happens  never  to  evaluate  its 

argument,  it  must  be  a  constant  function.  So  by  using  F to detect  whether  this  is  the  case,  we  get  a  spectacular  gain  in 
efficiency  when  g  is  constant: 

fun  test  a  =  fn  O=>(aO;O) funSuIn:!g= 

if  F  (fn  a=>(g(test  a)  ; 0))  then  Sum1  g else  g(fn  ()=>l)  *  1000000 

This  example  is  only  half-serious,  but  it  suggests  that  it  is worth  exploring  what  can  be  done  using  "functional"  pro- 
grams  in  this  extended  sense. There  is  a  natural  mathematical  dass  of  computable 
functions-the  sequentially  realizable  (SIP,) functions-which intuitively  contains  the  above  function  F and  "all  things  like 
it".  This  class  of  functions  was  studied  extensively  from  a theoretical  point  of  view  in  [4].  The  purpose  of  the  present 
paper  is  to  consider  these  functions  fro:m  a  more  practical standpoint,  and  to  explore  what  they  might  have  to  offer  to 

programmers  and  language  implementors. The  paper  is  structured  as follows.  In  Section  1 we  briefly 

mention  some  of  the  relevant  theoretical  background,  intro- duce  some  important  examples  of  SR  functions,  and  consider 
how  they  can  be  implemented.  In  Section  2  we  ask  what  in- teresting  kinds  of  program  can  be  written  in  this  extended 
functional  style.  Here  we  discuss  two  possible  application areas:  the  implementation  of  generic  search  algorithms,  and 

an  algorithm  for  exact  real-number  integration.  In  Section  3 we  ask  what  we  might  stand  to  gain  from  knowing  that  these 
programs  are  "functional"-in  particular,  the  scope  for  com- piler  optimization  of  such  programs.  Finally,  in  section  4 we 

draw  some  tentative  conclusions,  and  mention  some  ques- tions  for  further  consideration. 

Although  in  this  paper  we  have  used  Standard  ML  for our  examples,  we  believe  that  the  main  ideas  would  apply 
equally  well  to  lazy  functional  languages  such  as  Haskell  [3] (at  least  if  one  allows  non-standard  extensions;  see  e.g.  [S]). 

An  ML  source  file  containing  the  exam:ples  in  this  paper  is available  electronically  via  the  author's  home  page  [5]. 

Acknowledgements.  I  am  grateful  to  Simon  Peyton Jones  for  providing  me  with  the  impetus  to  write  this  paper. 
I  have  benefited  from  discussions  with  David  .Aspinall,  Mike Fourman,  Andrew  Kennedy  and  Eike  Ritter.  The  comments 
from  the  anonymous  referees  were  also  very  helpful.  This  re- search  was  funded  by  EPSRC  Research  Grant  GR/L89532: 

"Notions  of  computability  for  general  datatypes". 

1  The  sequentially  realizable  fuxlct  ionals 
1.1  Concept  ual  background 
We  begin  with  a  brief  sketch  of  the  theoretical  picture  that forms  the  background  to  the  present  paper. 

Our  work  on  the  SR  functions  forms  part  of  a  general programme  of  research  addressing  the  question  "What  are 
the  natural  and  interesting  notions  of  computable  function  at higher  types. 7"  For  first-order  types  such  as  int->int,  we  all 
know  what  we  mean  by  the  "computable"  functions:  they are  just  the  Turing-computable  or  partial  recursive  func- 

tions.  At  higher  types,  however,  it  is  less  immediately  clear what  "computable"  should  mean. 

In  fact,  it  now  appears  that  there  are  at  least  three  can- didates  for  a  reasonable  notion  of  higher-type  computab- 
ility,  each  with  good  mathematical  credentials,  and  each yielding  a  different  class  of  "computable  functions".  Firstly, 
there  are  the  sequentially  computable  functions  embodied by  the  prototypical  functional  language  PCF-this  corres- 
ponds  essentially  to  the  pure  functional  (and  simply-typed) fragment  of  ML  or  Haskell.  Secondly,  there  are  the  parallel- 

computable  functions,  embodied  by  an  extension  of  PCF  in- corporating  parallel-or  and  exists  functions.  These  parallel 
operations  are  in  some  sense  computable,  but  they  are  not implementable  even  in  full  ML.  Both  of  the  above  notions 
have  been  widely  known  since  the  early  work  of  Scott  [lo] and  Plotkin  [9].  The  third  class  of  computable  functions- 

the  SR  functions'-has  emerged  more  recently  from  work of  Bucciarelli  and  Ehrhard  11,  21,  van  Oosten  [fl  and  the 
present  author  [4].  The  SR  functions  form  a  larger  class than  the  PCF-computable  functions,  but  they  are  nonethe- 
less  all  expressible  in  an  impure  sequential  language  such  as ML.  They  admit  a  wide  variety  of  mathematical  character- 
izations,  and  have  many  pleasing  theoretical  properties  (see [4]).  Since  the  PCF-computable  functions  are  (in  a  suitable 

sense)  contained  in  each  of  the  other  two  classes,  we  have the  following  picture: 

parallel  sequentially computable  realizable -\  /' 

PCF-sequential 
The  class  of  SR  functions  is  in  some  sense  the  maximal class  of  higher-type  functions  expressible  in  a. sequential  pro- 
gramming  language:  indeed,  the  class  of ML  denotable  func- tions  defined  as  in  the  Introduction  turns  out  to  coincide 

`Since  in  this  paper  we  are  only  interested  in  computable  func- tions,  we  will  use  the  term  "SR  functions"  for  what  are  called  the 
eflective  SR  function&  in  [4]. 

2 

exactly  with  the  SR  functionals.  Thus,  the  SR  function- als  represent  the  limit  of  how  far  one  can  travel  with  the 

power  of  exceptions  or  references  but  without  sacrificing  the extensionality  (i.e.  functional  behaviour)  of  programs. 

One  aspect  of  the  SR  functions  which  may  seem  puzzling is  that  they  are  not  all  monotonic  in  the  usual  sense.  A 
partial  explanation  for  this  is  that  although  not  all  the  SR functions  are  monotonic  with  respect  to  the  usual  pointwise 

order  on  functions,  they  are  monotonic  with  respect  to  the stable  order  (see  e.g.  [l]),  which  turns  out  to  be  the  relevant 
ordering  to  consider  in  connection  with  the  SR  functionals. 

1.2  Examples  of  SR  functionals 
The  function  F given  earlier  is  one  example  of  an  SR  function that  is  not  PCF-computable.  We  now  mention  a  few  further 

examples,  in  order  to  illustrate  the  kind  of  power  that  the SR  functions  provide.  (Implementations  of  our  functions 
will  be  discussed  in  the  next  subsection.) The  main  example  we  wish  to  introduce  is  the  modu- 
lrrs  function  Mod.  Although  relatively  simple,  this  seems  to be  sufficiently  powerful  for  most  of  the  plausible  program- 
ming  applications  of  SR  functions.  First,  suppose  we  are given  an  ML  function  G:  tint->int)  ->int  and  a  function 
h:  int->int,  and  let  us  assume  that  the  application  G  h  ter- minates.  Informally,  in  the  course  of  the  computing  G  h, 

G can  learn  information  about  h  by  calling  it  with  various arguments.  For  example,  G might  ask  "what  is  h  5?",  and  h 
might  reply  "3"  ;  then  G could  ask  for  h  I,  and  h  could  reply with  2;  then  G might  decide  it  knows  enough  about  h,  and 
return  the  final  result.  By  the  time  the  computation  finishes, what  G has  learnt  about  h  can  be  represented  by  a  finite  set 

of  ordered  pairs-in  this  case,  the  set  ((I,  2),  (5,3)).  This set  is  called  the  modulus  of  G at  h;  it  is  the  graph  of  the 
unique  smallest  subfunction  h '  of  h  such  that  G  h'  termin- ates. 

The  function  Mod takes  as arguments  any  functions  G and h  as  above,  and-if  G  h  terminates-returns  the  modulus  of 
G at  h,  e.g.  as  a  list  of  pairs.  The  type  of  Mod in  ML  might therefore  be 

((int->int)->int)  ->  (int->int)  -> (int*int)list 
It  is  crucial  here  that  Mod must  return  only  the  set  of  ordered pairs,  and  must  not  give  away  any  information  about  the 

order  in  which  the  calls  to  h  were  made.  Otherwise,  the behaviour  of  Mod  would  not  be  functional,  since  it  would 
allow  us  to  distinguish  between  different  implementations  of the  same  function  G, such  as 

funGlh=h5+hl fun  G2  h  =hl+h5 
To  prevent  this,  we  can  sanitize  the  result  of  Mod by  sorting the  list  of  pairs  and  removing  duplicates,  or  else  by  using  an 

abstract  type  of  sets  in  place  of  lists. The  point  of  Mod  is  that  it  provides  information  about 
how  much  of  h  is  actually  looked  at  by  G. In  this  respect  it has  a  similar  feel  to  F,  and  indeed  it  is  easy  to  see how  F can 
be  defined  from  Mod  in  pure  functional  ML.  What  is  more surprising  is  that  Mod  is  definable  from  F,3  although  this  is 
not  the  most  efficient  way  to  implement  Mod. 

3This  result  is  due  to  Alex  Simpson;  see  [4,  Proposition  9.131  for the  construction. 

Many  minor  variations  on  Mod are  possible.  For  example, the  types  used  in  the  above  example  are  clearly  not  the  most 
general  possible.  Also,  in  practice  one  is  likely  to  want  a function  Mod'  which,  given  G and  h,  returns  both  the  result  of 
G  h  and  the  modulus  of  G at  h.  Alternatively,  one  might  not require  the  whole  modulus,  but  only  wish  to  know,  say,  the 

largest  argument  (if  any)  with  which  h  was  called;  this  could be  computed  by  a  simpler  function  ModMax.  Finally,  one 
could  consider  analogues  of  the  modulus  function  at  higher types  (computing,  for  example,  the  modulus  of  a  third-order 
function  at  a  second-order  one). Although  Hod  is  powerful  enough  for  many  purposes, 

there  are  many  SR  functions  that  are  not  definable  from Mod  in  pure  functional  ML.  The  bizarre  kinds  of  finite  SR 
function  discussed  in  [4,  Section  9.41 provide  one  class  of  ex- amples,  but  it  would  be  surprising  if  one  could  find  a  prac- 

tical  use  for  these.  A  more  promising  example  is  a  function E of  type 

(int  stream->int)  ->  tint->int)  ->  int 
(where  `a  stream  is  the  familiar  recursive  type  for  streams). Here  we  give  just  an  informal  description  of  E;  for  further 

details  see  [5]. Intuitively,  any  sequential  algorithm  for  a  function  of 
type  int  stream->int  can  be  represented  in  an  obvious  way by  a  (possibly  infinite)  d e&ion  tree;  and  the  type  int->int 
can  be  used  to  encode  a  strategy  for  exploring  such  a  de- cision  tree  and  returning  information  about  some  finite  part 
of  it.  The  crucial  observation  which  makes  E  functional  is that  for  any  function  of  type  int  stream->int  there  is  a 

canonical  (smallest)  decision  tree  that  computes  it,  so  in- formation  about  this  tree  is  really  information  about  the 
function  itself. Finally,  we  mention  a  function  even  more  powerful  than 

E:  the  universal  SR  function  I-I defined  in  [4,  Section  7].  One of  the  main  results  of  [4]  is  that  every  SR  function  is  defin- 

able  from  H in  pure  PCF.  This  means  that  if  one  were  to extend  the  pure  functional  fragment  of  ML  by  adding  H (im- 
plemented  using  non-functional  features),  one  would  have  a language  in  which  one  could  express  all  the  SR  functions 
and  only  them.  Informally,  the  idea  behind  H is  somewhat similar  to  E,  but  in  place  of  int  stream->int  we  have  the 

more  complex  type  (int->int)  ->int.  The  difficulty  is  that for  functions  of  this  type,  there  is  no  longer  a  canonical  de- 
cision  tree-this  means  that  once  H  has  obtained  a  result from  one  decision  tree,  in  order  to  remain  functional  it  has 

to  check  that  all  other  decision  trees  for  the  same  function would  have  given  the  same  result.  This  entails  a  factorial- 
size  search,  which  makes  H less  than  appealing  from  a  prac- tical  point  of  view! 

1.3  Implementations  of  SR  functions 
All  of  the  functions  we  have  mentioned  can  be  implemented in  Standard  ML,  in  several  different  ways.  We  have  already 

seen  how  to  implement  F using  references,  but  it  can  also  be written  using  exceptions: 

funFg= let  exception  e  in 

(g  (fn  -=>raise  e)  ;  false) handle  e  =>  (g  (fn  (f=>O)  ;  true) 
end 
Alternatively,  in  ML  of  New  Jersey,  F  can  be  implemented using  callcc: 

3 

funFg= callcc  (fn  con  => 

(g  (fn  O=> throw  con  (g  (fn  O=>O)  ;  true)  11 ; 
false)  > 
However,  both  these  implementations  suffer  from  an  ineffi- ciency  which  makes  the  reference  implementation  preferable 

in  practice.  In  both  of  the  above,  once  we  have  discovered that  g  evaluates  its  argument,  we  still  need  to  check  that 
g(fn  ()=>  0  )  terminates,  so  the  first  part  of  the  compu- tation  performed  by  g  is  done  twice.  This  illustrates  what 
seems  to  be  a  common  phenomenon  for  SR  functions:  one sometimes  has  to  do  stupid  extra  work  .in  order  to  behave 
functionally. The  exceptions  implementation  of  F also  suffers  from  an- 
other  drawback:4  it  does  not  behave  functionally  on  argu- ments  involving  wildcard  exception  handlers,  for  example: 

fun  id'  x  =  x(>  handle  _  =>  (> 
Thus,  this  implementation  is  functional  only  with  respect  to the  fragment  of  ML  without  wildcard  handlers. 

The  function  Mod is  also  most  easily  implemented  using references.  To  compute  Mod  G  h,  we  maintain  a  log  of  all 
calls  made  to  h,  and  apply  G to  a  version  of  h  that  updates the  log  whenever  it  is  called. 

fun  Mod  G  h  = let  val  log  =  ref  Cl 

funh'x= let  val  y  =  h  x  in 

(log  :=  insert(x,y)(!log)  ;  y) end 
in  (G  h'  ;  !log) end 

Here  insert  is  a  suitable  function  for  inserting  a  pair into  a  sorted  list.  One  could  of  course  achieve  much  greater 
efficiency  by  using,  say,  balanced  trees  to  maintain  sorted lists,  and  this  might  be  acceptable  for  many  purposes,  but 
even  so,  one  might  resent  having  to  do  the  sorting  just  for  the sake  of  being  a  functional  program.  However,  it  is  plausible 
that  for  many  applications  we  would  like  the  result  to  be sorted  anyway.  Note  also  that  to  implement  the  simpler 
function  ModMax  no  sorting  is  required. The  function  E requires  a  little  more  effort  to  implement 

(here  it  seems  best  to  use  a  combination  of  references  and exceptions),  but  it  is  reasonably  efficient  and  there  is  not 
too  much  of  an  overhead  arising  from  the  need  to  be  func- tional.  By  contrast,  the  function  H is  an  extreme  example 
of  a  function  for  which  extra  work  is  required  in  order  to stay  functional.  (We  do  not  know  whether  this  inefficiency 
would  necessarily  be  fatal  in  practical  applications,  however, because  we  do  not  have  any  practical  applications  for  H.) 

2  Some  programming  applications 
2.1  Search  algorithms 
We  now  suggest  some  programming  applications  for  SR  fimc- tions.  Our  first  application  is  the  implementation  of  a  "gen- 

eric"  search  algorithm.  Suppose  (for  example)  that  we  wish to  search  all  permutations  of  the  integers  0,.  . . , n  -  1  for 

`This  was  pointed  out  to  me  by  Nick  Benton  and  Andrew  Kennedy. 

those  satisfying  a  property  P,  where  P  is  to  be  supplied  as a  parameter.  In  principle  this  is  a  search  of  size  n!,  but 
we  can  often  cut  clown  the  search  as  follows.  Suppose  we test  a  permutation  u  =  (60,  . . . , ~~-1).  If  we  can  already 
see  that  P(o)  does  not  hold  just  by  looking  a.t  ~0,.  . . , rr--1 for  some  r  <  n,  we  can  save  ourselves  a  subsearch  of  size 

(n-r)!.  If  permutations  are  represented  by  functions  of  type int->int,  and  P  by  a  function  of  type  (int->int)->bool, 
we  can  use  a  function  like  ModMax  to  discover  the  value  of r  here.  When  cycling  through  all  the  permutations  in  some 
order,  this  number  can  be  used  to  tell  us  the  next  permuta- tion  that  we  need  to  consider.  In  this  way  we  can  construct 
a  function 

search  :  int  ->  ((int->int)->bool)  -> (int->int)list 

such  that  search  n  P  returns  a  list  of  the  permutations  of 0 , . . . ,n-1  satisfying  P.  (See  [5]  for  the  easy  implementation 
details.) By  supplying  different  functions  P  to  search,  we  can 

(for  example)  construct  magic  squares  or  solve  the  n  queens problem  with  reasonable  efficiency.  Of  course,  our  solution 
is  no  more  efficient  than  the  usual  solutions  to  either  of these  problems,  but  there  is  a  gain  in  modularity:  we  have 

separated  out  some  general-purpose  machinery  for  search- ing  through  permutations  from  the  problem-specific  details 
of  the  property  we  are  interested  in.  Obviously  this  could  be achieved  with  ordinary  pure  functional  programming  if  we 
required  P  to  return  explicit  modulus  inform.ation  together with  the  boolean  result,  but  by  not  requiring  this  we  have 
relieved  the  implementors  of  functions  P of  this  (small)  bur- den.  Our  solution  therefore  seems  appealing  if  we  wish  to 

do  many  different  searches  on  the  same  search  space. There  is  an  important  point  here  that  we  would  like  to 
emphasize.  In  general,  programmers  try  to  keep  the  inter- faces  between  program  modules  as  simple  as  possible,  in  or- 
der  to  keep  the  overall  complexity  of  a system  within  the  lim- its  of  understanding.  Very  often  there  is  a  trade-off  between 
simplicity  of  interfaces  and  efficiency,  since  a  simple  inter- face  may  prevent  different  modules  from  exchanging  useful 
information.  As  the  above  example  shows,  SR  functions  can sometimes  be  used  to  pass  intensional  information  across 

module  boundaries-to  make  black  boxes  less  opaque-but without  complicating  the  interfaces. 

We  should  mention  a  limitation  of  the  above  approach. Our  search  algorithm  will  work  most  efficiently  on  argu- 
ments  P which,  when  given  a  permutation  sigma,  call  sigma with  smaller  arguments  first,  and  then  call  sigma  with  lar- 
ger  arguments  only  if  this  is  still  necessary.  However,  there may  be  properties  P for  which  some  other  evaluation  order  is 

more  convenient,  and  so  we  would  prefer  an  i.mplementation of  search  in  which  the  order  in  which  we  cycled  through 
the  permutations  was  not  fixed  in  advance,  but  was  driven dynamically  by  the  evaluation  behaviour  of  P.  Such  an  im- 
plementation  is  indeed  possible  if  we  make  use  of  the  list  of all  the  arguments  with  which  P calls  sigma,  rather  than  just 

the  maximum.  Unfortunately,  though,  the  modulus  func- tion  does  not  suffice,  because  here  we  need  to  know  the 

order  in  which  these  calls  are  made.  Thus,  this  enhanced search  algorithm,  although  an  attractive  exarmple  of  general 
higher-order  programming,  goes  beyond  wheat  can  be  done with  SR  functionals.' 

`An  intermediate  algorithm  making  use  of  the  unordered  set  of arguments  called  might  also  be  possible,  but  it  seems  that  the  control 

This  illustrates  an  interesting  general  point  about  the SR  functionals:  in  order  to  be  functional,  one  sometimes 
deliberately  throws  away  information  that  might  actually be  of  interest  to  the  programmer. 

2.2  Exact  integration 
Our  second  application  is  in  the  area  of  exact  real  number computation,  and  concerns  an  algorithm  for  integrating  a 

given  real  function  to  any  desired  precision.  Let  us  repres- ent  real  numbers  in  the  interval  I  =  [-I,  I]  (non-uniquely) 
by  streams  of  extended  binary  digits,  and  real  functions  by functions  on  such  streams: 

datatype  Digit  =  One  1  Zero  1  MinusOne datatype  Real  =  Real  of  Digit  *  (unit  ->  Real) 

type  RealFun  =  Real  ->  Real 
We  wish  to  write  a  program  which,  when  given  an  integer Ic  and  a  total  function  f  :  1  *  Z  represented  by  a  value 

F:  RealFun,  computes  Ji,  f  to  within  2-k.  (Once  we  have 
done  this,  we  could  in  principle  compute  the  integral  as  a value  of  type  Real.)  To  do  this,  it  is  enough  to  know  the 

value  of  f(z)  to  within  e =  2-(k+1)  for  every  E  E  I. Our  algorithm  proceeds  as  follows.  First  we  compute 
f(--1)  to  within  c,  by  applying  F  to  the  stream  MinusOne- (using  an  obvious  notation);  suppose  the  result  is  the  dy- 
adic  rational  ~0.  Using  a  variant  of  the  ModMax  function, we  can  detect  how  many  digits  of  the  input  stream  were 
used  by  F  to  obtain  Y/O.  Suppose  j  input  digits  were  re- 

quired,  and  let  60  =  2-(-1-`);  then  we  know  that  for  any x  E  [-1,  -1  +  &]  we  have  If(z)  -  ye]  5  e.  We  therefore 

have  that  s_;`tsO  f  is  60 yo  to  within  2--(j+k),  Next  we  com- 

pute  f(-l+  do),  where  the  argument  is  now  represented by  the  stream  MinusOn&-'  ; One; MinusOne~.  As  before  we 

obtain  some  yl  and  61  such  that  If(z)  -  yl]  <  t  for  all x  E  [-1  +  60, -1  +  60 +  611. We  continue  creeping  along  the 
x-axis  in  this  way  until  we  reach  1  (see  below).  When  we finish,  we  will  have  approximated  f  everywhere  to  within  e 
by  pieces  of  constant  functions.  By  adding  up  the  areas  of the  corresponding  rectangles  as  we  go,  we  obtain  an  approx- 
imation  to  the  desired  integral.  Since  the  bi  add  up  to  2, the  total  error  in  this  approximation  is  at  most  2~ =  2-k. 

It  remains  to  show  that  the  algorithm  terminates,  i.e., that  we  do  eventually  reach  E  =  1.  Suppose  for  contradic- 
tion  that  the  sequence  ~1,  x2,.  . .  of  x-values  generated  by the  algorithm  converges  to  some  xc0  <  1.  Then  clearly  the 
streams  Sr , S2,  , , .  representing  these  z-values  themselves converge  (in  an  obvious  sense)  to  some  stream  S,  represent- 
ing  zoo.  But  since  f  is  assumed  to  be  a  total  function,  the application  F(S,)  must  yield  some  real  number  f(xoo).  In 
particular,  the  computation  of  f(xoo)  to  within  E must  use some  finite  number  j  of  digits  of  S,.  Now  for  some  suffi- 
ciently  large  n,  the  stream  S,,  will  agree  with  S,  on  the  first j  digits;  and  in  this  case,  upon  reaching  S,  our  algorithm 

would  detect  the  modulus  j,  and  so  at  the  next  iteration would  generate  a  stream  S,+i  2  S,.  Thus  S,+z  >  S,,  a 
contradiction.6 

structure  would  become  much  more  complicated,  unless  we  are  willing to  accept  the  risk  of  testing  some  permutations  more  than  once. 

sInterestingly,  the  stream  S,  need  not  be  computable,  since  we may  not  have  any  way  of  approximating  z,,,  from  above.  Thus,  we 
need  to  assume  that  F in  some  sense  represents  a  total  function  on  the classical  reals  and  not  just  on  the  computable  ones,  and  we  ought  to 

It  is  worth  comparing  our  approach  with  previous  ap- proaches  to  exact  integration.  In  [ll],  Simpson  gives  a  lazy 
functional  algorithm  for  integration  using  Berger's  u&form modulus  functional.  Simpson's  algorithm  is  particularly  re- 

markable  in  that,  unlike  ours,  it  can  be  coded  in  just  PCF (c&as  pure  functional  ML  or  Haskell).  However,  our  al- 
gorithm  has  a  number  of  advantages.  Firstly,  it  is  more efficient  in  practice,  since  in  Simpson's  algorithm  the  mod- 
ulus  information  is  obtained  in  a  rather  inefficient  way.  (In principle,  though,  the  two  algorithms  differ  in  runtime  only 
by  a  constant  factor.)  Secondly,  our  algorithm  seems  easier to  understand,  since  it  does  not  rely  on  any  clever  use  of 
higher-type  recursion  and  the  evaluation  behaviour  is  easy to  visualize.  Thirdly,  our  approach  using  SR  functions  can 
be  extended  to  compute  integrals  for  certain  classes  of  dis- continuous  functions,  which  cannot  be  integrated  at  all  in 
pure  PCF.  For  example,  if  f  : (I  -  (1))  +  1 has  no  continu- ous  extension  to  the  whole  of  I,  we  can  still  compute  the 
integral  to  within  2--(k-1)  using  the  above  method:  once  we reach  x  =  1 -  c  we  can  stop,  since  the  unexplored  part  of 

f  from  1 -  c  to  1  will  contribute  at  most  e  to  the  integ- ral.  One  can  also  define,  for  example,  an  SR  function  that 
integrates  any  function  f  :  1  +  I  that  is  undefined  on  at most  two  points  (though  here  the  modulus  function  does  not 

suffice-we  need  the  function  E). Other  approaches  are  possible  if  we  allow  ourselves  to  use 
a  different  type  to  represent  real  functions.  For  example,  as with  the  search  algorithm  above,  we  could  insist  that  our 
implementations  of  real  functions  return  explicit  modulus information,  but  this  would  seem  to  complicate  the  coding  of 
functions  significantly.  More  interestingly,  one  can  represent real  functions  using  the  following  datatype  of  "processes" 
operating  on  streams: 

datatype  RealFun'  = question  of  Digit  ->  RealFun' 

1  Answer  of  Digit  *  (unit  ->  RealFun') 
We  should  admit  that,  using  this  representation,  one  can give  a  purely  functional  implementation  of  (essentially)  the 

above  algorithm  that  is  considerably  more  efficient  than the  one  using  SR  functions.  The  price  to  pay  is  that  we 
are  forced  to  program  our  functions  in  a  rather  low-level style,  making  the  supply  and  demand  of  digits  very  explicit. 
Meanwhile,  our  SR  implementation  is  the  best  available  if we  wish  to  integrate  functions  of  ML  type  Real->Real. 

3  Advantages  over  impure  functional  pro- 

gramming 

So  far  we  have  explored  the  possible  benefits  of  program- ming  with  SR  functionals  as  opposed  to  conventional  pure 
functional  programming.  Given  that  SR  functionals  can  be implemented  in  an  impure  language  anyway,  we  should  also 
ask  the  dual  question:  what  are  the  advantages  of  SR-based programming  over  unrestricted  impure  functional  program- 

ming?  In  other  words,  what  can  we  gain  from  knowing  that programs  such  as  Mod behave  functionally?  One  possible  an- 
swer  is  that  functional  programs  are  often  easier  to  reason about  (both  formally  and  informally)  than  non-functional 
ones,  and  so the  SR  functions  seem  attractive  from  the  point 
clarify  what  we  mean  by  F(Sm)  in  this  case.  However,  we  will  gloss over  these  points  here,  since  they  make  a  difference  only  for  highly 

pathological  functions. 

5 

of  view  of  program  verification.  This  possibility  was  briefly considered  in  [4,  Section  12.41,  where  it  was  argued  that  the 
class  of  SR  functions  was  easier  to  reason  about  even  than the  cIass  of  PCF-computable  functions.  (This  is  because 
the  SR  functions  enjoy  better  decidability  properties  than the  PCF  ones.)  Here,  however,  we  concentrate  on  another 
possible  answer:  they  offer  increased  scope  for  conzpeler  op- ti&zatP'on. 

It  is  well  known,  and  commonly  exploited  by  compiler writers,  that  more  optimizing  transformations  are  legitim- 
ate  for  functional  code  than  for  code  that  may  have  side- effects.  Since  SR  functions  are  functional  in  terms  of  their 
behaviour,  one  would  expect  that,  in  principle,  a  compiler should  be  able  to  take  advantage  of  this  fact. 

For  example,  consider  the  ML  function 

funGf  = if  f  0  =  0  then  f  1  else  f  1  +  f  1 

As  part  of  the  optimization  phase,  a  compiler  might  consider eliminating  the  common  subexpression  f  I,  and  replacing 
the  body  of  the  above  declaration  by 

let  val  x  =  f  1  in if  f  0  =  0  then  x  else  x  +  x 

end 
This  avoids  duplicating  the  evaluation  of  f  1  in  the  case that  f  0 is  not  0.  However,  this  transformation  changes  the 

evaluation  order:  f  1  is  now  evaluated  before  f  0.  This optimization  is  therefore  valid  provided  that  the  argument 
f  is  functional.  Whether  this  is  so  will  depend,  of  course, on  the  context  in  which  G is  used;  indeed,  a  compiler  might 
generate  two  different  versions  of  the  object  code  for  G, one for  use  in  functional  contexts  and  one  for  other  contexts. 

Now  suppose  G is  used  in  some  context  Mod  G  f,  where f  is  known  to  be  functional.  The  functional  character  of 
Mod  means  that  it  is  in  principle  quite  legitimate  to  use  the optimized  version  of  G here.  This  contrasts  with  what  would 
happen  for  the  non-functional  version  of  Mod  which  retains the  order  of  the  calls  to  f:  the  two  versions  of  G would  yield 

different  results. In  many  modern  compilers,  the  code  optimizations  are 
regulated  by  means  of  a  type  system  carrying  information about  which  pieces  of  code  are  functional  (in  various  re- 

spects).  It  seems  that  optimizations  of  r,he above  kind  could be  supported  by  such  a  compiler  fairly  easily,  by  implement- 
ing  a  standard  library  of  SR  functions  and  ascribing  types to  them  that  reflected  their  functional  status  (these  would 

typically  be  better  than  the  types  that  the  compiler  could infer  for  itself  from  the  source  code).  This  would  give  us 
a  syntactically  identifiable  class  of  SR  programs.  (We  can- not  expect  a  compiler  to  recognize  all  SR  programs  as  such, 
since  it  is  undecidgble  in  general  whei;her  a  program  is  in the  SR  fragment.) 

It  appears  that  one  could  achieve  a  similar  effect  in  a lazy  language  such  as  Haskell  (in  which  code  transforma- 
tions  are  often  crucial  for  efficiency).  Functions  like  Mod could  be  implemented  using  a  suitable  side-effect  monad; 
and  some  implementations  of  Haskell  Iprovide  an  operation unsaf  ePerf  ormI0  for  transforming  this  into  a  value  that  the 
compiler  will  treat  as if  purely  functional  (see  [8]).  Thus,  the compiler  disclaims  all  responsibility  for  differences  in  pro- 
gram  behaviour  resulting  from  changes  in  evaluation  order; but  with  Mod,  this  will  never  be  a  problem. 

4  Conclusion 

In  this  paper  we  have  tried  to  give  a  practically  oriented introduction  to  the  SR  functions  by  means  of  examples,  and 
to  convey  an  impression  of  what  can  be  done  with  t;hem. In  summary,  SR  functions  can  be  used  to  obtain  intensional 
information  about  a function,  such  as how  much  use  it  makes of  this  argument,  but  they  make  this  information  available 
in  a  completely  extensional  way. We  have  illustrated  some  of  the  potential  advantages  of 
programming  with  SR  functions,  both  in  relation  to  pure functional  programming  in  the  usual  sense,  and  in  relation 

to  unrestricted  impure  functional  programming.  On  the  one hand,  we  gain  some  interesting  extra  programming  power 
over  ordinary  functional  programs,  but  on  the  other  hand, we  retain  the  advantages  of  ease  of  reasoning  and  scope  for 
compiler  optimization. We  have  also  pointed  out  some  of  the  limitations  of  SR 
programming:  sometimes  implementations  of  SR  functions need  to  perform  extra  work  in  order  to  ensure  that  they  be- 

have  functionally,  and  sometimes  this  extra.  work  even  de- prives  the  programmer  of  information  he  might  be  interested 
in.  On  occasions,  these  disadvantages  will  clearly  outweigh any  benefit  that  might  be  gained  from  being  "functional". 

The  purpose  of  this  paper  has  been  to  <advertise  an  el- egant  theoretical  idea  which  might  have  useful  applications 
in  functional  programming,  both  to  programming  and  to language  implementation.  The  particular  examples  we  have 
discussed  are  rather  tentative,  and  are  given  mainly  for  the purpose  of  illustration.  One  possible  application  area  we 
have  not  investigated  so  far  is  the  compile-time  analysis  of programs:  here  one  is  often  interested  in  knowing  which 
pieces  of  code  are  and  are  not  "looked  at"  under  various conditions,  and  it  seems  plausible  that  SR  functions  might 

be  of  some  use  here.  In  any  case,  we  hope  that  other  workers in  functional  programming,  whose  primary  interests  and  ex- 
perience  are  more  practical  than  those  of  the  present  author, may  be  able  to  fmd  other  good  uses  for  SR  functions. 

References 

[II 

PI 
PI 

[51 
161 

A.  Bucciarelli  and  T.  Ehrhard.  Sequenti.ality  and  strong stability.  In  Proc.  6th  Annual  Symposium  on  Logic  kn 

Computer  Science,  pages  138-145.  IEE;E,  1991. 
T.  Ehrhard.  Projecting  sequential  algorithms  on strongly  stable  functions.  Annuls  of  Pure  and  Applied 

Logic,  77:201-244,  1996. 
S.  Peyton  Jones  and  J.  Hughes  (eds.).  Report  on  the programming  language  Haskell  98.  Available  electron- 

ically  from  www , haskell.  org,  February  1999. 

J.R.  Longley.  The  sequentially  realizable  functionals. Technical  Report  ECS-LFCS-98-402,  Department  of 

Computer  Science,  University  of  Edinburgh,  1998.  Sub- mitted  to  Annals  of  Pure  and  Applied  Logic. 

J.R.  Longley.  When  is  a  functional  program  not  a  func- tional  program?:  a  walktbrough  introd.uction  to  the  se- 
quentially  realizable  functionals.  ML  source  file,  avail- able  from  http://uuw.dcs.ed.ac.uk/`hom/jrl/,  1998. 

R.  Milner,  M.  Tofte,  R.  Harper,  and  D.  MacQueen.  The Definition  of  Standard  ML:  revised  1997.  MIT  Press, 

1997. 

[7]  J.  van  Oosten.  A  combinatory  algebra  for  sequential functionals  of  finite  type.  Technical  Report  996,  Uni- 

versity  of  Utrecht,  1997.  To  appear  in  Proc.  Logic  Col- loquium  ,  Leeds. 

[8]  S.  Peyton  Jones  and  S.  Marlow.  Stretching  the  storage manager:  weak  pointers  and  stable  names  in  Haskell. 

Draft  paper,  1999. 
[9]  G.D.  Plotkin.  LCF  considered  as  a  programming  lan- guage.  Theoretical  Computer  Science,  5:223-255,  1977. 

[lo]  D.S.  Scott.  A  type-theoretical  alternative  to  ISWIM, CUCH,  OWHY.  Theoretical  Camp.  Sci.  ,  121:411-440, 

1993.  First  written  in  1969  and  widely  circulated  in unpublished  form  since  then. 

[ll]  A.K.  Simpson.  Lazy  functional  algorithms  for  exact  real functionals.  In  Mathematical  Foundations 

of  Computer Science,  pages  456-464.  Springer  LNCS  1450,  1998. 

Permission  to  make  digital  or  hard  copies  of  all  or  part  of  this  work  for 
personal  or  classroom  use  is  granted  without  fee  provided  that 
copies  are  not  made  or  distributed  for  profit  or  commercial  advan- 
tage  and  that  copies  bear  this  notice  and  the  full  citation  on  the  first  page. 

To  copy  otherwise,  to  republish,  to  post  on  Servers  or  to 

redistribute  to  lists,  requires  prior  specific  permission  and/or  a  fee. 
tCFP  `99  9/99  Paris,  France 
0  ,999  ACM  l-581  13-1  1 l-9/99/0009...55.00 

7 