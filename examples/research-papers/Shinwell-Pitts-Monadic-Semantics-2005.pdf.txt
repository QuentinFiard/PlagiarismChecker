

Theoretical Computer Science 342 (2005) 28-55

www.elsevier.com/locate/tcs

On a monadic semantics for freshness

Mark R. Shinwell*, Andrew M. Pitts
University of Cambridge Computer Laboratory, Cambridge, CB3 0FD, UK

Abstract

A standard monad of continuations, when constructed with domains in the world of FM-sets [M.J.
Gabbay, A.M. Pitts, A new approach to abstract syntax with variable binding, Formal Aspects Com-
put. 13 (2002) 341-363], is shown to provide a model of dynamic allocation of fresh names that is
both simple and useful. In particular, it is used to prove that the powerful facilities for manipulating
fresh names and binding operations provided by the "Fresh" series of metalanguages [M.R. Shinwell,
Swapping the atom: Programming with binders in Fresh O'Caml, Proc. MER\Delta IN, 2003; M.R.
Shinwell, A.M. Pitts, Fresh O'Caml User Manual, Cambridge University Computer Laboratory,
September 2003, available at \Theta http://www.freshml.org/foc/\Lambda ; M.R. Shinwell, A.M. Pitts, M.J. Gabbay,
FreshML: Programming with binders made simple, in: Proc. ICFP '03,ACM Press, 2003, pp. 263-274]
respect \Theta -equivalence of object-level languages up to meta-level contextual equivalence.
(C) 2005 Elsevier B.V. All rights reserved.

1. Introduction

Moggi's use of category-theoretic monads to structure various notions of computationaleffect [7] is by now a standard technique in denotational semantics; and thanks to the work
of Wadler [21] and others, monads are the accepted way of "tackling the awkward squad"[8] of side-effects within pure functional programming. Of Moggi's examples of monads,
we are here concerned with those for modelling dynamic allocation of fresh resources. 1

* Corresponding author.

E-mail address: mrs30@cam.ac.uk (M.R. Shinwell).
1 In this paper the only type of resource we consider is freshly generated names.

0304-3975/$ - see front matter (C) 2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2005.06.003

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 29
Since these are not so well-known, 2 let us recall a simple example of such a monad, T.It is defined on the category of Set-valued functors from the category

I of finite cardinals(i.e. the finite sets
n = {0, . . . , n \Sigma  1} for n = 0, 1, 2, . . .) and injective functions betweenthem. Thus an object A of this functor category gives us a family of sets

A(n) of "A-valuesin world
n", where n is the number of names created dynamically so far; and each injectionof n into a larger "world"

n\Phi  gives rise to a coercion from A(n) to A(n\Phi ). Then the monad
T builds from A an object T A of "computations of A-values" whose value at each n is the

dependent sum T A(n) def= \Delta m\Psi I A(n + m) = {(m, x) | m \Psi  I fi x \Psi  A(n + m)}; such"computations" simply create some number m of fresh names and then return an A-value

in the appropriate world, n + m. The action of T on a natural transformation \Theta  : A \Sigma ffi A\Phi produces the natural transformation

T \Theta  : T A \Sigma ffi T A\Phi  whose component at n \Psi  I isthe function
(T \Theta )n : T A(n) \Sigma ffi T A\Phi (n) mapping (m, x) to (m, \Theta n+m(x)). When A isthe object of names itself, given -y

A(n) = n = {0, . . . , n \Sigma  1}, there is a distinguishedglobal element new : 1 =
I(0, \Sigma ) \Sigma ffi T A corresponding under the Yoneda Lemma tothe element
(1, 0) \Psi  \Delta m\Psi I m = T A(0); this represents the computation whose evaluationcreates a name that is fresh with respect to the current world.

Although this is an attractive notion that has had nice applications (see [19], for example),such dynamic allocation monads on functor categories have proved at best difficult and at
worst impossible to combine with some other important denotational techniques--those formodelling recursively defined higher-order functions and algebraic identities. The difficulty
with higher-order functions is that while domains in functor categories do have exponentials,they are quite complicated things to work with in practice because of the indexing over
"possible worlds". The difficulty with algebraic identities, such as

(let x ffl new in e) = e if x not free in e, (1)
(let x ffl new; x\Phi  ffl new in e) = (let x\Phi  ffl new; x ffl new in e) (2)

is that quotienting dynamic allocation monads in order to force such identities interactsbadly with the order-theoretic completeness properties used to model recursive definitions.

In this paper we get past these problems with recursively defined higher-order functionsand algebraic identities in two steps, both of which turn out to greatly simplify matters.

First, we replace use of functor categories with the category of FM-sets [4]. 3 Althoughthis is equivalent to a category of functors, 4 working with it is almost entirely like working
in the familiar category of sets: in particular exponentials are straightforward, as is the basictheory of domains in FM-sets [18,16]. FM-sets are certain sets equipped with an action of
the group of permutations of a fixed, countably infinite set A of atoms; the key propertyof FM-sets is that their elements have finite support, a notion which provides a syntax-free
notion of "set of free names". The existence of finite supports enables the dependence ofsemantic objects upon parameterising names to be left implicit--a convenient simplification
compared with the explicit passing of parameterising name sets inherent in the "possibleworlds"/functor category approach.

2 Dynamic allocation monads are not mentioned in [7], but do appear in [6, Section 4.1.4].
3 Also known as nominal sets in [11].
4 The ones from I to Set that preserve pullbacks.

30 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55

Secondly, we feed back into denotational semantics the operational insight of [13] thatin the presence of fixpoint recursion, it is easier to validate contextual equivalences like
(1) (and many other more subtle ones that do not concern us here) by forgetting aboutevaluation's properties of intermediate name-creation in favour of its simple termination
properties. This leads to use of a Felleisen-style operational semantics [22], except that weformulate Felleisen's "evaluation contexts" as frame-stacks: see [10] for a recent survey. If
D is the domain of denotations of values of some type, then frame-stacks can be modelledsimply by elements of the strict continuous function space

D\Delta 1j where 1j = {j, `} (oneelement for non-termination, the other for termination); and since expressions are identified

if they have the same termination behaviour with respect to all frame-stacks, we can take
(D\Delta 1j)\Delta 1j as the domain for interpreting expressions. Thus we are led to the use ofthe following

continuation monad 5

(\Sigma )jj def= (\Sigma \Delta 1j)\Delta 1j. (3)
The notion of "finite support" now enters the picture: within the world of FM-sets, thedomain of names is simply a flat domain

Aj on the FM-set A of atoms. We get an elementnew \Psi 
(Aj\Delta 1j)\Delta 1j that models dynamic allocation by defining new to send any
\Theta  \Psi  Aj\Delta 1j to \Theta (a) \Psi  1j, where a \Psi  A is some atom not in the support of the function
\Lambda . Not only do standard properties of support make this recipe well defined (the value of
\Theta (a) is independent of which a we use), but new turns out to have good properties, suchas (1) (see Remark 4.5). 6 We review those parts of "FM-domain theory" that we need in

Section 3.It might seem that the continuation monad

(\Sigma \Delta 1j)\Delta 1j on FM-domains is too simpleto be useful. We show this is not so by using it to prove some extensionality properties

of contextual equivalence for the "Fresh" series of metalanguages [15,17,18]. In partic-ular we give the first correct proof of the main technical result of [18], 7 which shows
that FreshML's powerful facilities for manipulating fresh names and binding operations doindeed respect

\Theta -equivalence of object-level languages up to meta-level contextual equiva-lence. Section 2 introduces a small version of FreshML, called Mini-FreshML, and states

the properties of contextual equivalence we wish to prove. Section 3 gives a monadicdenotational semantics for Mini-FreshML using the monad (3) on the category of FM-
cppos. We prove the adequacy of this denotational semantics for Mini-FreshML's opera-tional semantics by extending some standard methods based on logical relations for relat-
ing semantics to syntax [9]. Section 4 uses the logical relation from the previous sectionto prove the desired extensionality and correctness properties for Mini-FreshML's rep-
resentation of object-level syntax involving binders. Finally in Section 5 we draw someconclusions.

5 It is possible to use other continuation monads, by replacing one or other uses of \Delta  in (3) by other kinds of
function space, but this simple version is enough for our purposes here.

6 new is closely related to the "freshness quantifier" Nintroduced in [4].

7 In [18] the authors attempted to use a direct- rather than continuation-based monadic semantics that turns out
to have problematic order-theoretic completeness properties.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 31
2. Mini-FreshML

We present a small, monomorphic language Mini-FreshML that encapsulates the corefreshness features of FreshML [18] and Fresh O'Caml [15]; the reader is referred to those
papers for motivation of the novel language features for manipulating bindable names(expressions of type

name) and name-abstractions (expressions of type <<name>>\Xi ). Mini-FreshML types
\Xi  are given -y the following grammar:

\Xi  ::= unit | name | \Pi  | \Xi  * \Xi  | <<name>>\Xi  | \Xi  ffi \Xi .
Here \Pi  ranges over a finite set of datatype names and we assume each \Pi  comes with atop-level, ML-style type declaration of the form

\Pi  = C1 of \Lambda 1| * * * |Cn of \Lambda n, (4)
where the Ck are constructors and the corresponding constructor types \Lambda k are generatedfrom the same grammar as types

\Xi  and in particular may involve (simultaneous) recursiveoccurrences of the datatype names

\Pi . Mini-FreshML expressions e are given -y the followinggrammar, where
x ranges over a denumerable set VId of value identifiers and a ranges overanother denumerable set

A, disjoint from VId, whose elements we call atoms (these are theclosed values of type
name):

e ::= x | () | a | Ck(e) | (e, e) | fresh | <<e>>e | swap e, e in e|

if e = e then e else e | fun x(x) = e | e e | let x = e in e|
let (x, x) = e in e | let <<x>>x = e in e|
match e with ( * * * |Ck(x) -> e| * * * ).

Note that local declarations of the form let x = e in e\Phi  are included more for conve-nience than necessity; since we have excluded ML-style polymorphism from Mini-FreshML
(in order to keep things simple), this expression has the same typing and evaluation behaviouras the function application

(fun f (x) = e\Phi )e (where f is a value identifier that does notoccur in
e\Phi ).The
values (i.e. expressions in canonical form) of Mini-FreshML, v, form the subset ofexpressions generated by

v ::= x | () | a | Ck(v) | (v, v) | <<a>>v | fun x(x) = e.
We identify expressions up to \Theta -conversion of bound value identifiers; the binding formsare as follows (with binding positions underlined):

fun x(x\Phi ) = [\Sigma ], let x = e in [\Sigma ], let (x, x\Phi ) = e in [\Sigma ],
let <<x>>x\Phi  = e in [\Sigma ], match e with ( * * * |Ck(x) -> [\Sigma ] | * * * ).

We write e[v/x] for the capture-avoiding substitution of a value v for all free occurrencesof the value identifier x in the expression e. We say that e is closed if it has no free value

identifiers. Even if e is closed, it may well have occurrences of atoms a in it; we write supp(e)

32 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
for the finite set of atoms occurring in e. 8 Note that there are no expression constructions thatbind atoms; in particular, although abstraction expressions

<<e>>e\Phi  are used to representbinders in object-level syntax, they are not binding forms in Mini-FreshML itself. 9 In

what follows we make heavy use of the operation on expressions of swapping atoms:
(a a\Phi ) * e indicates the result of interchanging all occurrences of the atoms a and a\Phi  in theexpression e.

We only consider expressions that are well-typed, given a typing context \Sigma  consistingof a finite map from value identifiers to types. We write

\Sigma  \Delta  e : \Xi  to indicate that e isassigned type
\Xi  in such a typing context \Sigma  (and omit mention of \Sigma  when it is empty). Thisrelation is inductively generated by rules that are mostly standard and which are given in

Appendix A. Let us just mention here that atoms a are assigned type name; and that if e isan expression of type

name and e\Phi  one of type \Xi , then the abstraction expression <<e>>e\Phi has type
<<name>>\Xi .Evaluation of Mini-FreshML expressions can be formalised operationally using a "big-

step" relation * on 4-tuples (a, e, v, a\Phi ), written a, e * v, a\Phi . Here e is a closed expression,
v is a closed value, and a , a\Phi  are finite sets of atoms with the atoms of e contained in
a. The intended meaning of this relation is that in the world with "allocated" atoms a, theexpression

e evaluates to v and allocates the fresh atoms a\Phi  \Sigma  a (evaluation of fresh and
let <<x>>x\Phi  = e in e\Phi  causes dynamic allocation of fresh atoms--see below). Furtherdetails of the relation are given elsewhere [18]. Instead, in this paper we use an equivalent

operational semantics based on the notion of frame stacks, or "evaluation contexts" [22];see [10] for a recent survey of this technique. This abstracts away from the details of which
particular atoms and values have been allocated and instead concentrates on the single notionof termination. In this formulation, as evaluation proceeds a stack of evaluation frames is
-uilt up. Each of these frames is a basic evaluation context: inside is a hole [\Sigma ] for whichmay be substituted another frame (as when composing frames to form a frame stack) or an
expression, which may or may not be in canonical form. Formally then, a frame stack Sconsists of a (possibly empty) list of evaluation frames, thus

S ::= [] | S ss F,
where F ranges over frames as follows:

F ::= Ck([\Sigma ]) | ([\Sigma ], e) | (v, [\Sigma ]) | <<[\Sigma ]>>e | <<v>>[\Sigma ]|

swap [\Sigma ], e in e | swap v, [\Sigma ] in e | swap v, v in [\Sigma ]|
if [\Sigma ] = e then e else e | if v = [\Sigma ] then e else e| [\Sigma ]

e | v [\Sigma ] | let x = [\Sigma ] in e|
let (x, x\Phi ) = [\Sigma ] in e | let <<x>>x\Phi  = [\Sigma ] in e|
match [\Sigma ] with ( * * * |Ck(x) -> e| * * * ).

8 The reason for this notation is the fact that this set of atoms is the support of e in the technical sense introduced
in Section 3.

9 It is one of the main results of this paper (Theorem 2.3) that the properties of Mini-FreshML contextual

equivalence are such that atoms in e occurring in e\Phi  behave up to contextual equivalence as though they are bound
in <<e>>e\Phi ; for example for atoms a, b then <<a>>a turns out to be contextually equivalent to <<b>>b.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 33
Then the termination relation \Theta S, e\Lambda ae (read "e terminates when evaluated with stack S")can be inductively defined by rules that follow the structure of e and then the structure of

S. For example:* \Theta 

S, fresh\Lambda ae holds if \Theta S, a\Lambda ae does for some (or indeed as it turns out, for every) a \Psi 
A \Sigma  supp(S), i.e. for some atom a not occurring in the frame stack S.* \Theta 

S ss let <<x>>x\Phi  = [\Sigma ] in e, <<a>>v\Lambda ae holds if \Theta S, e[a\Phi /x, ((a a\Phi ) * v)/x\Phi ]\Lambda ae doesfor some (or indeed every)

a\Phi  \Psi  A \Sigma  supp(S, v, e).The complete definition of the termination relation is given in Appendix B. Since we have

not defined the "big-step" relation * here, we state the following relationship between itand the termination relation without proof; the details can be found in [16].

Fact 2.1. For any closed Mini-FreshML expression e, \Theta [], e\Lambda ae holds iff for any finite set
a , A containing the atoms of e, the relation a, e * v, a\Phi  holds for some value v and set
of atoms a\Phi  o/ a.

Just as we only use well-typed expressions, we only consider well-typed frame stacks:we write

\Sigma  \Delta  S : \Xi \Delta __ to mean that in typing context \Sigma , the frame stack S takes expressions
e of type \Xi  (in context \Sigma ) and produces a well-typed result (of some type that we do notneed to name, since we only care about the termination of

e when evaluated with stack S).This judgement is defined by induction on the length of the stack S by

\Sigma  \Delta  [] : \Xi \Delta __

\Sigma , [\Sigma ] : \Xi  \Delta  F : \Xi \Phi  \Sigma  \Delta  S : \Xi \Phi \Delta __

\Sigma  \Delta  S ss F : \Xi \Delta __ ,

where in the hypothesis \Sigma , [\Sigma ] : \Xi  \Delta  F : \Xi \Phi  of the secondrule, we regard [\Sigma ] as a specialvalue identifier and type F using the typing rules for expressions given in Appendix A.

In [18], it is claimed that the features of Mini-FreshML that are novel compared withML can be used to represent and to manipulate the terms of languages involving binding
operators in ways that are guaranteed to respect \Theta -equivalence between those terms. Thatpaper shows that a wide range of syntax-manipulating functions can be very conveniently
expressed using the new features. Here we wish to give a formal proof of the fact that \Theta -equivalence between the terms of an "object language" is respected by Mini-FreshML when
we represent those terms as expressions of a suitable Mini-FreshML datatype. For simplicitywe use the untyped

\Delta -calculus as a running example of an object language involving bindingoperators. 10 Write

\Upsilon  for the set of \Delta -terms t, by which we mean abstract syntax trees (notidentified up to
\Theta -equivalence) given -y

t ::= x | \Delta x.t | t t,
where for variables x we are using elements of the set VId of Mini-FreshML value identifiers.To represent such terms in Mini-FreshML we use a top-level type declaration containing:

\Pi  = Var of name|Lam of <<name>>\Pi |App of \Pi  * \Pi . (5)
10 However, our results easily extend to any language with binders specified by a nominal signature
[20, Definition 2.1].

34 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
For each \Delta -term t, define a Mini-FreshML expression [t]e by induction on the structure oft as follows:

[x]e def= Var(x)[
\Delta x.t]e def= let x = fresh in Lam(<<x>>[t]e)[

t t\Phi ]e def= App([t]e, [t\Phi ]e).

\Theta \Lambda \Xi 
\Lambda \Pi  . (6)
Note that under this translation, free variables in \Delta -terms are represented by free valueidentifiers in Mini-FreshML: the set of free variables of

t is the same as the set of free valueidentifiers of [
t]e. Note also that in a typing context \Sigma  that assigns type name to each of thosefree variables, we have

\Sigma  \Delta  [t]e : \Pi . We want to relate \Theta -equivalence of \Delta -terms, t AE\Theta  t\Phi ,to the operational behaviour of the Mini-FreshML expressions [

t]e and [t\Phi ]e of type \Pi . Todo so, we shall use the traditional notion of
contextual equivalence given -y the followingdefinition. 11

Definition 2.2 (Contextual equivalence). The type-respecting relation of contextual pre-order, written

\Sigma  \Delta  e \Theta ctxe\Phi  : \Xi , is defined to hold if \Sigma  \Delta  e : \Xi , \Sigma  \Delta  e\Phi  : \Xi , and for all closed,well-typed expressions

C[e] containing occurrences of e, if \Theta [], C[e]\Lambda ae holds, then so does\Theta []
, C[e\Phi ]\Lambda ae (where C[e\Phi ] is the expression obtained from C[e] by replacing the occurrencesof

e with e\Phi ). The relation of contextual equivalence, OEctx is the symmetrisation of \Theta ctx.For closed typeable expressions e and

e\Phi  we just write e OEctx e\Phi  when O/ \Delta  e OEctx e\Phi  : \Xi  holdsfor some type
\Xi  (and similarly for \Theta ctx).

In the next section we show how to formulate a denotational semantics for Mini-FreshMLwhich we use in Section 4 to prove the following theorem (and other properties of Mini-

FreshML contextual equivalence).
Theorem 2.3 (Correctness for expressions). For any \Delta -terms t and t\Phi , with free variables

contained in the set {x0, . . . , xn} say,

t AE\Theta  t\Phi {x0 : name, . . . , xn : name} \Delta  [t]e OEctx [t\Phi ]e : \Pi .
If t and t\Phi  are \Theta -equivalent, then their translations into Mini-FreshML only differ upto renaming bound value identifiers; so since we identify Mini-FreshML expressions up

to \Theta -equivalence, in this case [t]e and [t\Phi ]e are equal Mini-FreshML expressions and inparticular are contextually equivalent. Thus the left-to-right direction of the above theorem
is straightforward and the force of the theorem lies in the right-to-left direction: if thetermination behaviour of [

t]e and [t\Phi ]e in any context is the same, then t and t\Phi  must be
\Theta -equivalent.

Remark 2.4 (Representing AE\Theta ). Since \Theta -equivalence is a decidable relation between
\Delta -terms, it makes sense to ask whether, given a type declaration for booleans

bool = True of unit|False of unit
11 We have formulated the definition using the termination relation ae; but note that in view of Fact 2.1, we could
have used the big-step evaluation relation *.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 35
we can strengthen the above theorem and represent AE\Theta  by a function expression aeq :
(\Pi  * \Pi ) ffi bool in Mini-FreshML. Such an expression aeq does indeed exist in Mini-FreshML. Rather than give it explicitly, it is clearer to give the Fresh O'Caml version of it,

since Fresh O'Caml's richer syntax (in particular it's richer language of patterns and -uilt-inboolean operations) enables one to express

aeq more clearly: 12

let rec aeq(t,t') = match t,t' with

Var x, Var x' -> if x=x' then true else false
| Lam(<<x>>y),Lam(<<x'>>y') -> aeq(y, swap x and x' in y')

| App(x,y), App(x',y') -> aeq(x,x') && aeq(y,y').

The Mini-FreshML version of aeq has to use nested match-expressions and simple pat-terns to express the above more complicated patterns and also to express the boolean con-

junction &&. The precise sense in which aeq represents AE\Theta  is described in Section 4(see Remark 4.11).

3. Denotational semantics with FM-cppos

The FreshML language design was driven -y the ability of the Fraenkel-Mostowskipermutation model of set theory with atoms to model binding,

\Theta -equivalence and freshnessof names [4]. So to give a denotational semantics to Mini-FreshML we could develop the

usual notion of pointed, chain-complete poset in the axiomatic FM-set theory of [4]. ThisFM-set theory is just classical ZF set theory with urelements and an axiom asserting a "finite
support property" (that is incompatible with the axiom of choice, it should be noted). So thefundamental constructions of domain theory, such as limit-colimit solutions of recursive
domain equations, can be carried out in that axiomatic theory. Such a change of mathematicalfoundations demands a certain meta-logical sophistication from the reader which can render
the results somewhat inaccessible. So instead here we take a less sophisticated, but equivalentapproach and work with domains in FM-set theory as ordinary (partially ordered) sets
with extra structure giving the effect on their elements of permuting atoms. 13 Whicheverapproach one takes, the main point is that domains in this new setting admit some relatively
simple, but novel constructions for names and name-binding with which we can give ameaning to the novel features of Mini-FreshML. We concentrate on describing those new
constructs; a fuller development of FM-cppos is given in [16].Recall from [11,18] that an FM-set is a set X equipped with an action

perm(A) * X \Sigma ffi X, written as (\Phi , x) !ffi \Phi  * x,
of the group perm(A) of permutations of the set A of atoms (thus \Psi  * x = x, where \Psi  is theidentity permutation; and

(\Phi ss\Phi \Phi ) * x = \Phi  * (\Phi \Phi  * x), where ss is composition of permutations).

12 Indeed, the user has no need to make this declaration of aeq in Fresh O'Caml, because the language has a
-uilt-in structural equality function =, which at the type \Pi  declared in (5) already implements aeq; so one can just
use t = t' instead of aeq(t, t').

13 Strictly speaking, what we call an FM-cppo below corresponds to an object in the universe of FM-sets which

has empty support and is a cppo in the axiomatic FM-set theory.

36 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
Furthermore, it is required that every x \Psi  X is finitely supported--meaning that there existsa finite subset

a , A (called a finite support for x) such that (a a\Phi ) * x = x holds forall
a, a\Phi  \Psi  A \Sigma  a. (Here (a a\Phi ) \Psi  perm(A) is the permutation just interchanging a and
a\Phi .) Each x \Psi  X in fact possesses a least finite support which we write as supp(x); thus if
a, a\Phi  \Psi  A \Sigma  supp(x), then (a a\Phi ) * x = x. A function f between FM-sets X and Y is calledequivariant if

\Phi  * (f (x)) = f (\Phi  * x) holds for all \Phi  \Psi  perm(A) and x \Psi  X. The category ofFM-sets and equivariant functions is rich in properties, being in fact equivalent to a well-

known Grothendieck topos (of continuous G-sets, when G is the topological group givenby

perm(A) endowed with the finite information topology). Here we will just describefinite products, power-objects and exponentials in this topos, since the associated notions

of finitely supported subset and function will be important in what follows.
Definition 3.1 (Finite products). The product of X and Y in the category of FM-sets and
equivariant functions is given -y the usual cartesian product of sets X * Y def= {(x, y) |
x \Psi  X fi y \Psi  Y } with permutation action given -y \Phi  * (x, y) def= (\Phi  * x, \Phi  * y). It is nothard to see that with this action

(x, y) is finitely supported because x and y are, and thatsupp
(x, y) = supp(x) " supp(y). The projection functions X #\Sigma  X * Y \Sigma ffi Y areequivariant and make

X * Y into the categorical product of X and Y. The terminal object inthis category is just a one-element set 1 = {0} endowed with the unique permutation action

\Phi  * 0 def= 0.
Definition 3.2 (Finitely supported subsets and functions). A subset S , X of an FM-set
X is defined to be finitely supported if there is a finite set of atoms a , A such that forall

a, a\Phi  \Psi  A \Sigma  a and all x \Psi  S, (a a\Phi ) * x \Psi  S. The set of all finitely supported subsetsof
X becomes an FM-set, denoted PX, once we endow it with the permutation actiongiven -y

\Phi  * S = {\Phi  * x | x \Psi  S}. The equivariant subsets S , X are by definition thosefinitely supported subsets for which we can take

a to be empty (so that x \Psi  S implies
(a a\Phi ) * x \Psi  S for all a, a\Phi  \Psi  A). (It is not hard to see that the subobjects of X in the toposof FM-sets and equivariant functions are naturally in bijection with the equivariant subsets

of X, with inclusion of subobjects corresponding to inclusion of subsets; and PX is indeedthe powerobject of

X in this topos.) A function f between two FM-sets X and Y is definedto be finitely supported if its graph is a finitely supported subset of

X * Y ; it is not hardto see that this is equivalent to requiring that there be a finite subset

a , A such that forall
a, a\Phi  \Psi  A \Sigma  a and all x \Psi  X, (a a\Phi ) * (f (x)) = f ((a a\Phi ) * x) (i.e. f is "equivariantaway from

a"). The set of all such functions becomes an FM-set, denoted Y X, once we

endow it with the permutation action given -y \Phi  * f def= \Delta x \Psi  X. \Phi  * (f (\Phi \Sigma 1 * x)), where
\Phi \Sigma 1 is the inverse of the permutation \Phi . (This is indeed the exponential of X and Y in thetopos of FM-sets.) Note that the morphisms from X to Y in the category of FM-sets, i.e. the

equivariant functions from X to Y, are precisely the elements of Y X that have empty support.
Remark 3.3. The finitely supported subsets of an FM-set are closed under the usualboolean operations. In particular, if a finite set of atoms

a , A witnesses that S , Xis finitely supported, then it also witnesses that the complement

(X \Sigma  S) , X is finitelysupported.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 37
We will make use of a version of Tarski's fixed point theorem in the category ofFM-sets:

Lemma 3.4. An FM-complete lattice is an FM-set L equipped with an equivariant partial
order relation $ such that every finitely supported subset has a greatest lower bound. Givensuch an L, every element

f \Psi  LL which is monotone possesses a least (pre-)fixed point.

Proof. The subset {x \Psi  L | f (x) $ x} is supported by the same finite set of atoms thatsupports

f and therefore has a greatest lower bound. As usual, this is the least (pre-)fixedpoint of
f. \Lambda 

Definition 3.5 (FM-cpos and FM-cppos). An FM-cpo is an FM-set D equipped with anequivariant partial order $ that possesses least upper bounds (lubs) for all

\Omega -chains d0 $
d1 $ d2 $ * * * that are finitely supported, in the sense that there is a finite subset a , Asuch that %

a, a\Phi  \Psi  A \Sigma  a. %n. (a a\Phi ) * dn = dn. (This is equivalent to requiring that thesubset {
dn | n\Xi 0} , D be finitely supported in the sense of Definition 3.2.) An FM-cppois an FM-cpo with a least element j; note that since j $

(a a\Phi ) * j (since j is least) andhence
(a a\Phi ) * j $ (a a\Phi ) * (a a\Phi ) * j = j, we have supp(j) = O/. A morphism f of FM-cpos is an equivariant function which is monotone and preserves lubs of finitely supported

\Omega -chains. A morphism of FM-cppos, written f : D ss\Sigma ffi E, has the same properties -utis also strict (

f (j) = j). FM-cpos (respectively FM-cppos) and their morphisms form acategory FM-Cpo (respectively FM-Cpo

j).

Lemma 3.6 (Least fixed points). Given an FM-cppo D, every function f from D to D that
is finitely supported (Definition 3.2), monotone and preserves lubs of finitely-supported
\Omega -chains possesses a least (pre-)fixed point fix(f ) \Psi  D.

Proof. Just note that the classical construction of fix(f ) as the lu- of the chain j $ f (j) $
f 2(j) $ * * * can be used here, because this chain is finitely supported (by any a that finitelysupports

f, since as we noted above, j always has empty support). \Lambda 

To each Mini-FreshML type \Xi  we assign an FM-cppo \Delta \Xi \Theta . To do so we make use of thefollowing constructions on FM-cppos: smash product (\Sigma  & \Sigma ), coalesced sum (\Sigma  ' \Sigma ),
lifting (\Sigma j), function space (\Sigma ffi\Sigma ), strict function space (\Sigma \Delta \Sigma ), and atom-abstraction([

A]\Sigma ). All -ut the last three are just as for classical domain theory [2]. The FM-cppo
DffiD\Phi  is given -y the FM-set of finitely supported functions f from D to D\Phi  (Definition3.2) that preserve the partial order and lubs of finitely supported

\Omega -chains; as usual, thepartial order on
DffiD\Phi  is inherited from D\Phi  argument-wise. The FM-cppo D\Delta D\Phi  is thesub-FM-cppo of

DffiD\Phi  consisting of those functions that also preserve j. The FM-cppo[
A]D generalises to domain theory the atom-abstraction construct of [4, Section 5] and isdefined as follows.

Definition 3.7 (Atom-abstraction). Given an FM-cpo D, the FM-cpo [A]D consists ofequivalence classes [

a]d of pairs (a, d) \Psi  A * D for the equivalence relation inducedby the pre-order:
(a, d) $ (a\Phi , d\Phi ) iff (a a\Phi \Phi ) * d = (a\Phi  a\Phi \Phi ) * d\Phi  for some atom a\Phi \Phi  not

38 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
in {a} " supp(d) " {a\Phi } " supp(d\Phi ); the permutation action is \Phi  * [a]d def= [\Phi (a)](\Phi  * d)and the partial order is induced by the above pre-order. The elements of [

A]D are indeedfinitely supported: one can calculate that supp
([a]d) = supp(d) \Sigma  {a}. Finitely supported
\Omega -chains in [A]D possess lubs, which can be calculated as follows: given a chain [a0]d0 $[

a1]d1 $ * * * supported by a finite set of atoms a, picking any a \Psi  A \Sigma  a one can show that
(ao a) * d0 $ (a1 a) * d1 $ * * * is an \Omega -chain in D supported by a " {a}; taking its lub, dsay, then [

a]d is a lu- for the original chain [a0]d0 $ [a1]d1 $ * * *. If D has a least elementj, then so does [

A]D, namely [a]j (for any a \Psi  A).

As may be expected, all these constructions are functorial. Lifting and atom-abstractiondetermine functors FM-Cpo

j\Sigma ffi FM-Cpoj; the smash product and sum determine func-tors FM-Cpoj * FM-Cpoj\Sigma ffi FM-Cpoj and the function and strict function spaces

determine functors FM-Cpoopj * FM-Cpoj\Sigma ffi FM-Cpoj. In fact the action of these con-structs on morphisms enriches to locally continuous functors in the following sense. We

say that a functor F : FM-Cpoj\Sigma ffi FM-Cpoj is locally FM-continuous if its action onmorphisms is induced by equivariant functions

FD,E : (D\Delta E)ffi(F D\Delta F E) that aremonotonic and preserve least upper bounds of finitely-supported chains. For example when

F = [A](\Sigma ), FD,E sends f \Psi  (D\Delta E) to the element [A]f \Psi  ([A]D\Delta [A]E) that maps[

a]d to [a\Phi ]f ((a a\Phi ) * d) where a\Phi  is any atom not in supp(f ) " {a} " supp(d) (the result isindependent of which such

a\Phi  we choose).For simplicity, we assume there is a single declaration (4) of a datatype

\Pi  (and later takethe declaration to be (5)). 14 Following [9,2], the denotation of
\Pi  is the minimally invariantFM-cppo associated with a locally FM-continuous functor
F : FM-Cpoopj * FM-Cpoj\Sigma ffi FM-Cpo

j:

F (\Sigma , +) def= F\Lambda 1(\Sigma , +) ' * * * ' F\Lambda n(\Sigma , +), (7)
where for each type \Xi  the functor F\Xi  is defined by induction on the structure of \Xi  as follows:

Funit(D\Sigma , D+) def= 1j,
Fname(D\Sigma , D+) def= Aj,

F\Pi (D\Sigma , D+) def= D+,
F<<name>>\Xi (D\Sigma , D+) def= [A]F\Xi (D\Sigma , D+),

F\Xi *\Xi \Phi (D\Sigma , D+) def= F\Xi (D\Sigma , D+) & F\Xi \Phi (D\Sigma , D+),
F\Xi ffi\Xi \Phi (D\Sigma , D+) def= F\Xi (D+, D\Sigma )\Delta (F\Xi \Phi (D\Sigma , D+))jj.

Here (\Sigma )jj is the continuation monad (3) defined in the Introduction; 1j and Aj are flat
FM-cppos on the FM-sets 1 def= {`} (trivial action: \Phi  * ` def= `) and A (canonical action:
\Phi  * a def= \Phi (a)). Just as Lemma 3.6 shows that least fixed points can be constructed in theusual way, so can minimally invariant solutions to such domain equations be constructed in

14 For finitely many datatypes one just has to solve a finite set of simultaneous domain equations rather than a
single one.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 39
this setting using the normal technique of embedding-projection pairs [9,2] adapted to FM-cppos, using finitely supported

\Omega -chains where classically one uses arbitrary \Omega -chains. 15So let
D be an FM-cppo which is a minimal invariant solution to the recursive domainequation

D = F (D, D). Thus D comes equipped with an isomorphism

i : F (D, D)\Delta D (8)
and (D, i) is uniquely determined by the fact that the identity on D is fix(ff), where ff :
(D\Delta D)ffi(D\Delta D) is given -y ff(f ) = i ss F (f, f ) ss i\Sigma 1.

We may now define the denotation \Delta \Xi \Theta  of a type \Xi  as \Delta \Xi \Theta  def= F\Xi (D, D). Denotations of
typing contexts are given using a finite smash product: \Delta \Sigma \Theta  def= \Sigma x\Psi dom(\Sigma ) \Delta \Sigma (x)\Theta . Thedenotations of values

v (of type \Xi  in context \Sigma ), of frame stacks S (of argument type \Xi in context
\Sigma ) and expressions e (of type \Xi  in context \Sigma ) are given -y finitely supportedfunctions 16 of the following kinds:

V\Delta \Sigma  \Delta  v : \Xi \Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta ,S
\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta j,E

\Delta \Sigma  \Delta  e : \Xi \Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta jj,

where for each FM-cppo D we define Dj def= D\Delta 1j. Intuitively, an element of \Delta \Xi \Theta jmodels a frame stack accepting a value of type

\Xi  and returning ` for termination, or jfor divergence. Just as the behaviour of expressions is determined by any enclosing frame

stack, the denotation of some expression in context is then a function in \Delta \Xi \Theta jj that acceptsthe denotation of a frame stack in context and returns either j or `. Thus, the denotations
of expressions in context make use of the continuation monad (\Sigma )jj based on an FM-cppoof "answers" given -y 1j. We have the usual two monad operations for

(\Sigma )jj, namely theunit return \Psi 
D\Delta Djj given -y

return(d) def= \Delta \Pi  \Psi  Dj. \Pi (d) \Psi  Djj (9)
and the Kleisli lifting operation lift \Psi  (D\Delta Ejj)\Delta (Djj\Delta Ejj) that sends
f \Psi  (D\Delta Ejj) and e \Psi  Djj to

lift(f )(e) def= \Delta fi \Psi  Ej. e(\Delta d \Psi  D. f (d)(fi)) \Psi  Ejj. (10)
We use the informal notation let d ffl e in e\Phi [d] for lift(f )(e) when f is given -y someexpression

e\Phi [d] (involving d strict continuously).The denotation of recursive function values makes use of the least fixed point operation

fix \Psi  (DffiD)\Delta D from Lemma 3.6. The denotation of the fresh expression makes useof the element new \Psi 

(Aj)jj mentioned in the Introduction:

E\Delta \Sigma  \Delta  fresh : name\Theta  def= \Delta fl \Psi  \Delta \Sigma \Theta . new.
15 A logically more sophisticated viewpoint is that we are carrying out the usual construction, but in the axiomatic
FM-set theory [4] rather than in usual axiomatic ZFC set theory.

16 Note that these functions do not necessarily have empty support (consider V\Delta O/ \Delta  a : name\Theta  for example, where

a \Psi  A) and are thus not necessarily morphisms in the category FM-Cpoj.

40 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
Here new is the element of (Aj)jj that sends each \Theta  \Psi  (Aj)j to \Theta (a) \Psi  1j where a is anyelement of

A \Sigma  supp(\Theta ) (for each \Theta , there are infinitely many such a because A is infiniteand supp
(\Theta ) is finite); this gives a well-defined (strict, continuous) function because for anyother
a\Phi  \Psi  A \Sigma  supp(\Theta ) we have (a a\Phi ) * \Theta  = \Theta  (since neither a nor a\Phi  are in the supportof
\Theta ) and hence \Theta (a) = ((a a\Phi ) * \Theta )(a) = (a a\Phi ) * (\Theta ((a\Phi  a) * a)) = (a a\Phi ) * (\Theta (a\Phi )) = \Theta (a\Phi )(where in the last step we use the fact that any

x \Psi  1j satisfies (a a\Phi ) * x = x). Thedenotation of
let <<x>>x = e in e\Phi  expressions involves a similar use of choosingsome fresh
a \Psi  A (mirroring the dynamic allocation involved in the evaluation of suchexpressions), noting that the result is independent of which fresh

a is chosen. 17 The fulldefinition of E\Delta  \Sigma  \Theta  by induction on the structure of expressions is given in Appendix C;

the definition of V\Delta  \Sigma  \Theta  by induction on the structure of values and making use of E\Delta  \Sigma  \Theta  isgiven in Appendix D; the definition of S\Delta  \Sigma  \Theta  by induction on the length of frame stacks and
making us of both E\Delta  \Sigma  \Theta  and V\Delta  \Sigma  \Theta  is given in Appendix E. The "continuation-passingstyle" of these definitions is self-evident. Note that since a value is in particular an expres-
sion, it has a denotation qua value, V\Delta \Sigma  \Delta  v : \Xi \Theta , and qua expression, E\Delta \Sigma  \Delta  v : \Xi \Theta . The twodenotations are related via the unit (9) of the continuation monad:

Lemma 3.8. If v is a value satisfying \Sigma  \Delta  v : \Xi , then E\Delta \Sigma  \Delta  v : \Xi \Theta  = returnss V\Delta \Sigma  \Delta  v : \Xi \Theta  \Psi 
\Delta \Sigma \Theta \Delta \Delta \Xi \Theta jj.

For closed values v of type \Xi , we write V\Delta v\Theta  for the element V\Delta  \Delta  v : \Xi \Theta (O/) of the FM-cppo \Delta 

\Xi \Theta  and use a similar convention for closed frame stacks and expressions.

Remark 3.9 (FM-sets of syntax). Note that the expressions of Mini-FreshML form an FM-set. The action of a permutation of atoms on an expression e is given -y applying the
permutation to the atoms occurring in any syntax tree representing e (recall that we identifyexpressions up to

\Theta -conversion of bound value identifiers); and then the support of anexpression is in fact the finite set of atoms occurring in the expression. Furthermore, it is

easy to prove that the denotational semantics gives equivariant functions on syntax, so that,for example

(a a\Phi ) * E\Delta \Sigma  \Delta  e : \Xi \Theta (fl) = E\Delta \Sigma  \Delta  (a a\Phi ) * e : \Xi \Theta ((a a\Phi ) * fl). In particular it is thecase that supp

(E\Delta \Sigma  \Delta  e : \Xi \Theta (fl)) , supp(e) " supp(fl).

We wish to use our denotational semantics to prove operational properties of Mini-FreshML expressions. An important stepping-stone in this process is the construction of
certain type-indexed logical relations which relate domain elements to values, frame stacksand expressions respectively:

\Pi val\Xi  , \Delta \Xi \Theta  * Val\Xi , \Pi stk\Xi  , \Delta \Xi \Theta j * Stack\Xi , \Pi exp\Xi  , \Delta \Xi \Theta jj * Exp\Xi ,
where Val\Xi  is the set of closed Mini-FreshML values of type \Xi , Stack\Xi  is the set of well-typed frame stacks expecting an argument of type

\Xi  and Exp\Xi  is the set of closed expres-sions of type
\Xi . These relations are all required to be equivariant subsets in the sense ofDefinition 3.2. We also require them to be suitably admissible; for example, for each

17 This is just a manifestation of the "some/any" property of fresh names [4, Proposition 4.10].

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 41
v \Psi  Val\Xi , we require that {d | d\Pi val\Xi  v} to contain j and be closed under lubs of finitelysupported

\Omega -chains in \Delta \Xi \Theta  (and similarly for \Pi stk\Xi  and \Pi exp\Xi  ). Finally, the relations shouldsatisfy the following properties that follow the structure of types:

d\Pi valunit() (11)
d\Pi valnamea  d (= j ) d = a, (12)
d\Pi val\Pi  Ck(v)  * dk \Psi  \Delta \Lambda k\Theta .d = (iss ink)(dk) fi dk\Pi val\Lambda k v, (13)

[a] d\Pi val<<name>>\Xi <<a\Phi >>v  (a a\Phi \Phi ) * d\Pi val\Xi  (a\Phi  a\Phi \Phi ) * v

for some a \Psi  A \Sigma  supp(a, d, a\Phi , v), (14)
(d1, d2)\Pi val\Xi *\Xi \Phi (v1, v2)  d1\Pi val\Xi  v1 fi d2\Pi val\Xi \Phi  v2, (15)

d\Pi val\Xi ffi\Xi \Phi v  % d\Phi \Pi val\Xi  v\Phi .d(d\Phi )\Pi exp\Xi \Phi  v v\Phi , (16)

\Lambda \Pi stk\Xi  S  % d\Pi val\Xi  v.\Lambda (d) = ` ) \Theta S, v\Lambda ae, (17)

fi\Pi exp\Xi  e  % \Lambda \Pi stk\Xi  S.fi(\Lambda ) = ` ) \Theta S, e\Lambda ae. (18)

In clause (13), i is the isomorphism from (8) and ink \Psi  Dk\Delta D1 ' * * * ' Dn is the kthinjection into a coalesced sum. Clause (14) makes use of the support of a tuple; as in

Definition 3.1, supp(a, d, a\Phi , v) = {a} " supp(d) " {a\Phi } " supp(v) (and supp(v) is just thefinite set of atoms occurring in the value

v--see Remark 3.9). In clauses (16) and (17),the notation %
d\Pi val\Xi  v.(\Sigma ) stands for %d \Psi  \Delta \Xi \Theta , v \Psi  Val\Xi .d\Pi val\Xi  v ) (\Sigma ) (and similarly for\Pi stk

\Xi  in (18)). Clauses (17) and (18) define the logical relations for frame stacks and forexpressions in terms of that for values. Clauses (11)-(16) serve to define \Pi val

\Xi  at compoundtypes \Xi  in terms of \Pi val

\Pi  ; and \Pi val\Pi  = F (\Pi val\Pi  , \Pi val\Pi  ) is a fixed point of a certain operatoracting on relations (whose definition we give in detail below). Unfortunately, due to the

negative occurrence of \Pi val\Xi  on the right-hand side of the clause (16) for function types,this operator is non-monotonic; so it is non-trivial to deduce the existence of a suitable

relation \Pi val\Pi  . We do so -y adapting the techniques of [9] to the world of FM-sets, asfollows.

For each type \Xi , let R\Xi  be the set of finitely supported subsets R , \Delta \Xi \Theta  * Val\Xi  withthe desired admissibility property, namely that for each

v \Psi  Val\Xi , the subset {d | (d, v) \Psi 
R} contains j and is closed under lubs of finitely supported \Omega -chains in \Delta \Xi \Theta . This be-comes an FM-set if we define the permutation action of

\Phi  \Psi  perm(A) on R \Psi  R\Xi  to

be \Phi  * R def= {(\Phi  * d, \Phi  * v) | (d, v) \Psi  R}. Partially ordering its elements by inclusion, itis not hard to see that R

\Xi  is in fact an FM-complete lattice (cf. Lemma 3.4), the greatestlower bound of a finitely supported subset of R

\Xi  just being given -y intersection. Given
R\Sigma , R+ \Psi  R\Pi , define F\Xi (R\Sigma , R+) \Psi  R\Xi  by induction on the structure of the type \Xi ,as follows:

Funit(R\Sigma , R+) def= { (d, ()) | d \Psi  1j} ,
Fname(R\Sigma , R+) def= { (j, a) | a \Psi  A} " { (a, a) | a \Psi  A} ,

F\Pi (R\Sigma , R+) def= R+,
F<<name>>\Xi (R\Sigma , R+) def= {([a] d, <<a\Phi >>v) | *a\Phi \Phi \Psi A\Sigma supp(R\Sigma , R+, a, d, a\Phi , v).

((a a\Phi \Phi ) * d, (a\Phi  a\Phi \Phi ) * v)\Psi F\Xi (R\Sigma , R+)},

42 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55

F\Xi *\Xi \Phi (R\Sigma , R+) def= {(\Theta d, d\Phi \Lambda , (v, v\Phi )) | (d, v) \Psi  F\Xi (R\Sigma , R+) fi

(d\Phi , v\Phi ) \Psi  F\Xi \Phi (R\Sigma , R+)},

F\Xi ffi\Xi \Phi (R\Sigma , R+) def= {(d, fun f (x) = e) |

%(d\Phi , v\Phi ) \Psi  F\Xi (R+, R\Sigma ), \Lambda  \Psi  \Delta \Xi \Phi \Theta j, S \Psi  Stack\Xi \Phi .
(%(d\Phi \Phi , v\Phi \Phi ) \Psi  F\Xi \Phi (R\Sigma , R+).\Lambda (d\Phi \Phi ) = ` ) \Theta S, v\Phi \Phi \Lambda ae)
) d(d\Phi )(\Lambda ) = ` ) \Theta S, (fun f (x) = e) v\Phi \Lambda ae }.
(The notation "\Theta d, d\Phi \Lambda " in the clause for product types indicates the smash pair such that\Theta 

d1, d2\Lambda  def= j\Delta \Xi 1\Theta &\Delta \Xi 2\Theta  when either of d1 \Psi  \Delta \Xi 1\Theta  and d2 \Psi  \Delta \Xi 2\Theta  are bottom). Assuming the
single datatype \Pi  has a top-level declaration as in (4), we define F (R\Sigma , R+) \Psi  R\Pi  by

F (R\Sigma , R+) def= {(ink(d), Ck(v)) | 1\Theta k \Theta n fi (d, v) \Psi  F\Lambda k (R\Sigma , R+)}.
Then the relation we seek is a fixed point \Pi val\Pi  = F (\Pi val\Pi  , \Pi val\Pi  ), with the value logical

relation at other types given -y \Pi val\Xi  def= F\Xi (\Pi val\Pi  , \Pi val\Pi  ).

The definition of R\Sigma , R+ !ffi F (R\Sigma , R+) implies that it is an equivariant functionthat is order-reversing in its first argument and order-preserving in its second. Therefore

F $(R\Sigma , R+) def= (F (R+, R\Sigma ), F (R\Sigma , R+)) determines a monotone equivariant functionfrom the FM-complete lattice Rop

\Pi  * R\Pi  to itself. Therefore we can apply Lemma 3.4 todeduce that it has a least fixed point,

(ffi\Sigma , ffi+) say. Thus ffi\Sigma , ffi+ \Psi  R\Pi  satisfy*

ffi\Sigma  = F (ffi+, ffi\Sigma ) and F (ffi\Sigma , ffi+) = ffi+.* For any

R\Sigma , R+ \Psi  R\Pi , if R\Sigma  , F (R+, R\Sigma ) and F (R\Sigma , R+) , R+, then R\Sigma  , ffi\Sigma and
ffi+ , R+.* supp

(ffi\Sigma ) = O/ = supp(ffi+).From this it follows that

ffi+ , ffi\Sigma . So to construct \Pi val\Pi  , it suffices to see that ffi\Sigma  , ffi+, so

that we can take \Pi val\Pi  = ffi\Sigma  = ffi+. To prove that inclusion holds, we appeal to the minimal
invariance property of the FM-cppo \Delta \Pi \Theta  = D and the isomorphism i in (8). First, one canprove from the definition of

F that the subset {f \Psi  (D\Delta D) | %(d, v) \Psi  ffi\Sigma .(f (d), v) \Psi 
ffi+} is mapped to itself by the function ff = i ss F (f, f ) ss i\Sigma 1 : (D\Delta D)ffi(D\Delta D) whoseleast fixed point is the identity on

D. Since that subset contains j and is closed under lubsof finitely supported
\Omega -chains, it follows from the construction of fix(ff) in Lemma 3.6 thatthe subset contains the identity on

D--which means that ffi\Sigma  , ffi+, as required.We next give the "fundamental property" of the logical relations we have just constructed.

To state the property we need to introduce some terminology for value-substitutions, ffl,which are finite partial functions from value identifiers to values. Given such a

ffl, we write
e[ffl] for the result of the capture-avoiding simultaneous substitution of ffl(x) for x in e as
x ranges over dom(ffl); similarly for value-substitutions into values v[ffl], and into framestacks

S[ffl]. Given a typing context \Sigma , let Subst\Sigma  be the set of all value-substitutions ffl withdomain dom

(\Sigma ) and such that for each x \Psi  dom(ffl), ffl(x) is closed. Given ffl \Psi  Subst\Sigma  and
fl \Psi  \Delta \Sigma \Theta , write fl\Pi \Sigma ffl to mean that for each x \Psi  dom(fl), fl(x)\Pi val\Sigma (x)ffl(x).

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 43
Lemma 3.10 (Fundamental property of the logical relations). For all typing contexts \Sigma ,values

v, frame stacks S and expressions e, we have that

\Sigma  \Delta  v : \Xi  ) % fl\Pi \Sigma ffl.V\Delta \Sigma  \Delta  v : \Xi \Theta fl\Pi val\Xi  v[ffl],
\Sigma  \Delta  S : \Xi \Delta __ ) % fl\Pi \Sigma ffl.S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl\Pi stk\Xi  S[ffl],
\Sigma  \Delta  e : \Xi  ) % fl\Pi \Sigma ffl.E\Delta \Sigma  \Delta  e : \Xi \Theta fl\Pi exp\Xi  e[ffl].

Proof. These properties follow -y induction on the derivation of the typing judgements,using the definitions of V\Delta  \Sigma  \Theta , S\Delta  \Sigma  \Theta , E\Delta  \Sigma  \Theta  and the properties (11)-(18) of the logical
relations. \Lambda 
Theorem 3.11 (Computational adequacy). Given \Sigma  \Delta  e : \Xi , ffl \Psi  Subst\Sigma  and S \Psi  Stack\Xi ,

then

\Theta S, e[ffl]\Lambda ae  E\Delta \Sigma  \Delta  e : \Xi \Theta (V\Delta ffl\Theta )(S\Delta S\Theta ) = `,
where V\Delta ffl\Theta  \Psi  \Delta \Sigma \Theta  maps each x \Psi  dom(ffl) to V\Delta ffl(x)\Theta . In particular for all closedtypeable expressions

e \Psi  Exp\Xi , values v \Psi  Val\Xi  and frame stacks S \Psi  Stack\Xi , we have:\Theta 
S, e\Lambda aeE\Delta e\Theta (S\Delta S\Theta ) = ` and \Theta S, v\Lambda aeS\Delta S\Theta (V\Delta v\Theta ) = `.

Proof. The first sentence follows from the second one using a substitutivity property of thedenotational semantics

E\Delta \Sigma  \Delta  e : \Xi \Theta (V\Delta ffl\Theta ) = E\Delta e[ffl]\Theta  (19)
that is proved by induction on the structure of e (and similarly for values and frame stacks).The computational adequacy property for closed expressions is established by first proving

a soundness property

\Theta S, e\Lambda ae ) E\Delta e\Theta (S\Delta S\Theta ) = ` (20)
by induction on the derivation of \Theta S, e\Lambda ae. The reverse implication is a corollary of Lemma3.10: by the fundamental property of the logical relation we have E\Delta 

e\Theta \Pi exp\Xi  e and S\Delta S\Theta \Pi stk\Xi  S;then properties (17) and (18) give the required implication. \Lambda 

4. Extensionalit- and correctness results

We now examine how our denotational semantics of Mini-FreshML can be used to provethe correctness result stated at the end of Section 2 (Theorem 2.3), which we recall centres
around the notion of contextual equivalence. The quantification over all contexts that is partof the definition of contextual equivalence makes it hard to work with directly. Instead we
make use of an alternative characterisation in terms of Mason and Talcott's notion of CIU-equivalence [5]. 18 We prove that this coincides with Mini-FreshML contextual equivalence
using the logical relation from the previous section.

18 CIU = "Closed Instances of all Uses".

44 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
Definition 4.1 (CIU-equivalence). We write \Sigma  \Delta  e OEciu e\Phi  : \Xi  to indicate that the typeableexpressions e and

e\Phi  of type \Xi  (in context \Sigma ) are CIU-equivalent. This equivalence relationis the symmetrisation of the

CIU-pre-order relation, written \Sigma  \Delta  e \Theta ciue\Phi  : \Xi , which bydefinition holds if
\Sigma  \Delta  e : \Xi , \Sigma  \Delta  e\Phi  : \Xi , and for all closing substitutions ffl \Psi  Subst\Sigma  and allclosed frame stacks

S, \Theta S, e[ffl]\Lambda ae implies \Theta S, e\Phi [ffl]\Lambda ae. We write e \Theta ciue\Phi  (respectively OEciu)when e and
e\Phi  are closed expressions and O/ \Delta  e \Theta ciue\Phi  : \Xi  holds for some \Xi .

To show that CIU-equivalence coincides with contextual equivalence we need to turnframe stacks into (evaluation) contexts, as follows. The lemma is proved by a routine
induction on the structure of frame stacks, S.
Lemma 4.2. Define an operation mapping frame stacks S to contexts T (S) by induction
on the structure of S:

T ([]) def= [\Sigma ] T (S ss F) def= (T (S))[F].
Then for all stacks S and expressions e, \Theta [], T (S)[e]\Lambda ae\Theta S, e\Lambda ae.

Theorem 4.3 (Coincidence of OEctx with OEciu). For any typing context \Sigma  and expressions

e, e\Phi  it is the case that \Sigma  \Delta  e \Theta ctxe\Phi  : \Xi  iff \Sigma  \Delta  e \Theta ciue\Phi  : \Xi . Thus the relations OEctx and OEciu
coincide.

Proof. We prove that \Theta ctx and \Theta ciu both coincide with the relation \Theta e defined from thedenotational semantics and the logical relation as follows:

\Sigma  \Delta  e \Theta ee\Phi  : \Xi  def \Sigma  \Delta  e, e\Phi  : \Xi  fi %fl\Pi \Sigma ffl.E\Delta \Sigma  \Delta  e : \Xi \Theta (fl)\Pi exp\Xi  e\Phi [ffl],
where \Sigma  \Delta  e, e\Phi  : \Xi  is the o-vious conjunction of typing judgements. From the fundamentalproperty (Lemma 3.10) we have

\Sigma  \Delta  e : \Xi  implies \Sigma  \Delta  e \Theta ee : \Xi ; and from property (18) ofthe logical relation for expressions and the definition of \Theta 

ciu we have that \Theta e is closedunder composition with \Theta 
ciu on the right. Therefore

\Sigma  \Delta  e \Theta ciue\Phi  : \Xi  ) \Sigma  \Delta  e \Theta ee\Phi  : \Xi . (21)

The compositional nature of the denotational semantics and the fundamental property of thelogical relation ensure that if

\Sigma  \Delta  e \Theta ee\Phi  : \Xi  holds, then so does C[e]\Theta eC[e\Phi ], for any context
C[\Sigma ] for which C[e] and C[e\Phi ] are closed well-typed expressions. Then by computationaladequacy (Theorem 3.11) and property (18) of the logical relation we have that \Theta []

, C[e]\Lambda aeimplies \Theta []
, C[e\Phi ]\Lambda ae. Therefore

\Sigma  \Delta  e \Theta ee\Phi  : \Xi  ) \Sigma  \Delta  e \Theta ctxe\Phi  : \Xi . (22)
To complete a circle of implications we just have to prove that the contextual pre-order iscontained within the CIU-pre-order. To do so, we first have to show that the "instantiation"

part of CIU, i.e. applying a value-substitution to an expression, is contextual. But we nowknow from (21) and (22) that every CIU-equivalence is also a contextual equivalence. In
particular we have i-value conversion

\Sigma  \Delta  (fun f (x) = e)(v) OEctx e[v/x] (23)

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 45
since the corresponding CIU-equivalence is immediate from the definitions of OEciu andthe termination relation \Theta \Sigma 

, \Sigma \Lambda ae. Because of the way they are defined, \Theta ctx and OEctx arecompatible with the various expression-forming constructs of Mini-FreshML, i.e. when-

ever e \Theta ctxe\Phi , then C[e]\Theta ctxC[e\Phi ] for any context C (and similarly for OEctx). Thus if
\Sigma , x : \Xi  \Delta  e \Theta ctxe\Phi  : \Xi \Phi  and \Sigma  \Delta  v : \Xi , then \Sigma  \Delta  (fun f (x) = e)v \Theta ctx(fun f (x) = e\Phi )v : \Xi \Phi ;and so by (23),

\Sigma  \Delta  e[v/x]\Theta ctxe\Phi [v/x] : \Xi \Phi . From this it follows that we have

\Sigma  \Delta  e \Theta ctxe\Phi  : \Xi  ) %ffl \Psi  Subst\Sigma .e[ffl] \Theta ctxe\Phi [ffl]. (24)
So if \Sigma  \Delta  e \Theta ctxe\Phi  : \Xi , then for all closing value-substitutions ffl \Psi  Subst\Sigma  and frame stacks
S \Psi  Stack\Xi , using the congruence property of \Theta ctx and (24) we have T (S)[e[ffl]] \Theta ctxT (S)[

e\Phi [ffl]]; hence \Theta [], T (S)[e[ffl]]\Lambda ae implies that \Theta [], T (S)[e\Phi [ffl]]\Lambda ae and so by Lemma 4.2,\Theta 

S, e[ffl]\Lambda ae implies \Theta S, e\Phi [ffl]\Lambda ae. Therefore

\Sigma  \Delta  e \Theta ctxe\Phi  : \Xi  ) \Sigma  \Delta  e \Theta ciue\Phi  : \Xi  (25)
and the circle of implications is complete. \Lambda 

Combining Theorems 3.11 and 4.3, we have:
Corollar- 4.4 (Equality of denotation). If E\Delta \Sigma  \Delta  e : \Xi \Theta  = E\Delta \Sigma  \Delta  e\Phi  : \Xi \Theta , then \Sigma  \Delta  e OEctx
e\Phi  : \Xi . In particular, if e and e\Phi  are closed expressions of the same type, then E\Delta e\Theta  = E\Delta e\Phi \Theta 
implies e OEctx e\Phi .

Remark 4.5. This result can be used to verify some algebraic identities such as (1) and (2).For example, if

\Sigma  \Delta  e : \Xi  and x is an identifier not occurring free in e, then it is straightforwardto prove (by induction on the structure of e) that

E\Delta \Sigma  \Delta  e : \Xi \Theta (fl) = E\Delta \Sigma , x !ffi \Xi \Phi  \Delta  e : \Xi \Theta (fl[x !ffi d])
for any fl \Psi  \Delta \Sigma \Theta , type \Xi \Phi  and d \Psi  \Delta \Xi \Phi \Theta . Hence for any fl \Psi  \Delta \Sigma \Theta  and \Lambda  \Psi  \Delta \Xi \Theta j

E\Delta \Sigma  \Delta  let x = fresh in e : \Xi \Theta fl\Lambda = E\Delta 

\Sigma  \Delta  fresh : name\Theta fl(\Delta a \Psi  \Delta name\Theta .E\Delta 

\Sigma , x : name \Delta  e : \Xi \Theta (fl[x !ffi a])\Lambda ) by definition of E\Delta  \Sigma  \Theta = E\Delta 
\Sigma , x : name \Delta  e : \Xi \Theta (fl[x !ffi a])\Lambda  for some a \Psi  A \Sigma  supp(e, fl, \Lambda )= E\Delta 
\Sigma  \Delta  e : \Xi \Theta fl \Lambda  from above.

Thus by Corollary 4.4, e OEctx let x = fresh in e holds when x is an identifier notoccurring free in

e. The identity (2) is similarly straightforward to verify.

Although equality of denotation implies contextual equivalence, we do not believe thatthe converse is always true. In other words the denotational semantics is not "fully ab-
stract", not only for the usual reasons concerning sequentiality [14], but also because ofthe subtle examples of contextual equivalence that hold when dynamically allocated names
are combined with higher order functions: see [12,13]. We do not settle this question here,because to do so would require the development of more subtle techniques for calculating
with our continuation-based denotational semantics. Instead we concentrate on using the

46 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
denotational semantics as a tool for establishing extensionality and correctness propertiesof Mini-FreshML contextual equivalence. We now have all the tools needed to prove these
properties.
Corollar- 4.6 (Extensionality).(i) For unit values:

\Delta  v OEctx v\Phi  : unit iff v = v\Phi  = ().(ii)
For name values: \Delta  a OEctx a\Phi  : name iff a = a\Phi  \Psi  A.(iii) For data values:

\Delta  Ck(v) OEctx Ck(v\Phi ) : \Pi  iff \Delta  v OEctx v\Phi  : \Lambda k.(iv)
For pair values: \Delta  (v1, v2) OEctx (v\Phi 1, v\Phi 2) : \Xi 1 * \Xi 2 iff \Delta  v1 OEctx v\Phi 1 : \Xi 1 and \Delta  v2 OEctx
v\Phi 2 : \Xi 2.(v)
For name-abstraction values: \Delta  <<a>>v OEctx <<a\Phi >>v\Phi  : <<name>>\Xi  iff \Delta  (a a\Phi \Phi ) *
v OEctx (a\Phi  a\Phi \Phi ) * v\Phi  : \Xi  for some (or indeed, for every) a\Phi \Phi  \Psi  A \Sigma  supp(a, v, a\Phi , v\Phi ).(vi)
For function values: \Delta  f OEctx f \Phi  : \Xi  ffi \Xi \Phi  iff for all closed v of type \Xi , \Delta  f v OEctx
f \Phi  v : \Xi \Phi .

Proof. First note that by Theorem 4.3, it suffices to prove these extensionality propertieshold with respect to OE

ciu. In each case, the left-to-right implications can be proved directlyfrom the definition of CIU-equivalence. Using this fact, together with properties (11)-(16)

of the logical relation for values, one can show -y induction on the structure of values thatthe relation

\Sigma  \Delta  v \Theta vv\Phi  : \Xi  def \Sigma  \Delta  v, v\Phi  : \Xi  fi %fl\Pi \Sigma ffl.V\Delta \Sigma  \Delta  v : \Xi \Theta (fl)\Pi val\Xi  v\Phi [ffl]
is closed under composition with \Theta ciu on the right. It follows from this and the reflexivityof \Theta 

v (Lemma 3.10) that

\Sigma  \Delta  v \Theta ciuv\Phi  : \Xi  ) \Sigma  \Delta  v \Theta vv\Phi  : \Xi .

Properties (17) and (18) together with Lemma 3.8 ensure that \Theta v is contained in \Theta e; andwe know from the proof of Theorem 4.3 that \Theta 

e coincides with \Theta ciu. Therefore all inall, we have \Sigma 
\Delta  v \Theta vv\Phi  : \Xi  holds iff \Sigma  \Delta  v \Theta ciuv\Phi  : \Xi . Using this, each of the right-to-leftimplications in the extensionality properties then follows from those required of the logical

relation in (11)-(16). \Lambda 

We now turn to the issue of relating object language and metalanguage behaviours asdiscussed at the end of Section 2, using the example of

\Delta -terms for the object language andthe Mini-FreshML datatype
\Pi  declared in (5).

Lemma 4.7. For each \Delta -term t, define a Mini-FreshML value [t]v by induction on the
structure of t as follows:[

x]v def= Var(x),[
\Delta x.t]v def= Lam(<<x>>[t]v),[

t t\Phi ]v def= App([t]v, [t\Phi ]v).
Then for any \Delta -terms t, t\Phi  and any value-substitution ffl that maps the free variables of tand

t\Phi  to atoms t injectively (i.e. ffl(x) = ffl(x\Phi ) ) x = x\Phi ), we have [t]v[ffl] OEctx [t\Phi ]v[ffl]
t AE\Theta  t\Phi .

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 47
Proof. We make use of the fact [4, Proposition 2.2] that \Theta -equivalence for \Delta -terms t \Psi  \Upsilon can be inductively defined by the following rules:

x \Psi  VId

x AE\Theta  x

(x x\Phi \Phi ) * t AE\Theta  (x\Phi  x\Phi \Phi ) * t\Phi 
x\Phi \Phi  \Psi  VId \Sigma  supp(x, t, x\Phi , t\Phi )

\Delta x.t AE\Theta  \Delta x\Phi .t\Phi 

t1 AE\Theta  t\Phi 1 t2 AE\Theta  t\Phi 2

t1 t2 AE\Theta  t\Phi 1 t\Phi 2 .

Then the lemma is proved by induction on the size of t, making use of the extensionalityproperties of Corollary 4.6. \Lambda 

Now consider translating a \Delta -term t into an expression [t]e as in (6), then applying aninjective value-substitution of atoms for free identifiers to get a closed expression [

t]e[ffl]and finally evaluating it. Bound variables in
t get translated into identifiers bound to fresh,which give rise to fresh atoms in the result of evaluating [

t]e[ffl]. So we can expect thatresult to be contextually equivalent to the value [
t]v[ffl] provided the bound variables of
t are distinct from each other and from the free variables--in other words, provided the"Barendregt variable convention" [3, Section 2.1.13] holds for t. It is convenient to formalise

that convention via a structurally inductive definition. For disjoint finite subsets x, x\Phi  of VIdwe define a subset

\Upsilon (x; x\Phi ) , \Upsilon  inductively by the following rules.

x \Psi  x
x \Psi  \Upsilon (x, O/)

t \Psi  \Upsilon ({x} " x, x\Phi ) x /\Psi  x

\Delta x.t \Psi  \Upsilon (x, {x} " x\Phi )
t \Psi  \Upsilon (x, x\Phi 1) t\Phi  \Psi  \Upsilon (x, x\Phi 2) x\Phi 1 + x\Phi 2 = O/

t t\Phi  \Psi  \Upsilon (x, x\Phi 1 " x\Phi 2) .

If t \Psi  \Upsilon (x, x\Phi ) then: the free variables of t are contained within x; the occurrences of boundvariables of t are mutually distinct and are contained within

x\Phi ; the sets of free and boundvariables of
t are disjoint; and the support of--i.e. the set of all variables within--the termt is contained within

x " x\Phi . Note that each term t \Psi  \Upsilon  is \Theta -equivalent to a term in \Upsilon (x, x\Phi )for some
x, x\Phi . One can show -y induction on the derivation from the above rules that if
t \Psi  \Upsilon (x, x\Phi ), then for any injective substitution ffl : VIdffiA with dom(ffl) = x " x\Phi  it isthe case that E\Delta [

t]e[ffl]\Theta  = E\Delta [t]v[ffl]\Theta . Hence by Corollary 4.4 we have

Lemma 4.8. For t \Psi  \Upsilon (x, x\Phi ) and any injective substitution ffl : VIdffiA with dom(ffl) =
x " x\Phi , it is the case that \Delta  [t]e[ffl] OEctx [t]v[ffl] : \Pi .

We are now in a position to prove the correctness theorem.
Proof of Theorem 2.3. As we observed earlier, one can show -y induction over the rulesdefining

\Theta -equivalence of \Delta -terms (given in the proof of Lemma 4.7) that if t AE\Theta  t\Phi  then[
t]e and [t\Phi ]e are the same Mini-FreshML expression (since we identify Mini-FreshMLexpressions up to

\Theta -equivalence of bound value identifiers). So we just have to show that{
x0 : name, . . . , xn : name} \Delta  [t]e OEctx [t\Phi ]e : \Pi  implies t AE\Theta  t\Phi . By suitably renamingbound variables we can find a finite set

x\Phi  and terms t1, t\Phi 1 \Psi  \Upsilon (x, x\Phi ) such that t1 AE\Theta  t and
t\Phi 1 AE\Theta  t\Phi ; and hence [t1]e = [t]e and [t\Phi 1]e = [t\Phi ]e. So if {x0 : name, . . . , xn : name} \Delta  [t]e OEctx[

t\Phi ]e : \Pi , then {x0 : name, . . . , xn : name} \Delta  [t1]e OEctx [t\Phi 1]e : \Pi . Then choosing some injective

48 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55
substitution ffl : VIdffiA with domain x " x\Phi , we can apply Lemma 4.8 to conclude that
\Delta  [t1]v[ffl] OEctx [t\Phi 1]v[ffl] : \Pi . Finally, we apply Lemma 4.7 to obtain t AE\Theta  t1 AE\Theta  t\Phi 1 AE\Theta  t\Phi .\Lambda 

Fix a bijection ffl : VId\Delta A between the countably infinite sets of value identifiers andof atoms. Lemma 4.7 tells us that the mapping

t !ffi [t]v[ffl] induces an injective functionfrom
\Theta -equivalence classes of \Delta -terms to contextual equivalence classes of closed valuesof type

\Pi . In fact this function is a bijection: from the typing rules of Mini-FreshML (seeAppendix A) it is not hard to see that every closed value of type

\Pi  must be of the form[
t]v[ffl] for some \Delta -term t. The contextual equivalence classes of non-value expressions oftype

\Pi  are more complicated; but as the final theorem shows, a closed expression of type \Pi is either divergent or contextually equivalent to the "restriction" of some value. To prove it

we need the following property of divergent terms, which is a corollary of Theorems 3.11and 4.3.

Lemma 4.9 (Divergent terms). For a closed expression e of type \Pi  and the divergent term
j def= (fun f (x) = f (x))(),

e OEctx j ffl) %S.E\Delta e\Theta (S\Delta S\Theta ) = j  %S.\Theta S, e\Lambda (ae .
Theorem 4.10 (Form of expressions). For a closed Mini-FreshML expression e of the type

\Pi  declared in (5), either e OEctx j or

e OEctx let x1 = fresh in * * * let xn = fresh in v
for some value v of type \Pi .
Proof. Using Lemma 4.9 we see that if \Delta  e OEctx j does not hold, then \Theta [], e\Lambda ae. We can nowapply the forwards direction of Fact 2.1 to deduce that there exists some closed value

v\Phi  oftype
\Pi  and some finite set of atoms a such that O/, e * a, v\Phi  with supp(v\Phi ) , a. Pick a bijection
ffl : x\Delta a, where x = {x1, . . . , xn} is a set of value identifiers, and replace each occurrence
of an atom a \Psi  a in v\Phi  with ffl\Sigma 1(a) to obtain a (possibly open) value v. Thus v\Phi  = v[ffl]and it is not hard to see that

e OEciu let x1 = fresh in * * * let xn = fresh in v.Now apply Theorem 4.3. \Lambda 

Remark 4.11 (Representing AE\Theta ). In Remark 2.4 we mentioned that AE\Theta  can be representedin Mini-FreshML, in a certain sense, by the function expression

aeq : (\Pi  * \Pi ) ffi booldescribed there. We can now make the nature of the representation precise. One can prove

by induction on the structure of \Delta -terms t and t\Phi  for any injective substitution ffl : VIdffiAwhose domain contains the free variables of

t, t\Phi  and whose image is the finite set of atoms
a say, that

t AE\Theta  t\Phi  ) * a\Phi  o/ a.(a, aeq([t]v[ffl], [t\Phi ]v[ffl]) * True(), a\Phi ),
t (AE\Theta  t\Phi  ) * a\Phi  o/ a.(a, aeq([t]v[ffl], [t\Phi ]v[ffl]) * False(), a\Phi ).

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 49
It follows from Theorem 4.3 and Lemma 4.8 that

t AE\Theta  t\Phi  ) aeq([t]e[ffl], [t\Phi ]e[ffl]) OEctx True() : bool
t (AE\Theta  t\Phi  ) aeq([t]e[ffl], [t\Phi ]e[ffl]) OEctx False() : bool.

5. Conclusion

In this paper we have begun to develop domain theory in the world of FM-sets. Rather thanchange foundation and work in FM-set theory, we took a concrete approach and developed
FM-cppos as ordinary sets equipped with extra structure. Really the only change fromclassical domain theory is that one must restrict to "finitely supported" functions and subsets.
What one gains is new constructs for fresh names andname-binding that can -e com-inedwith familiar domain-theoretic constructs for modelling recursion both at the level of terms

and of types, to give the kind of refined semantics of fresh names and binders previouslyassociated with more complicated (we would claim) functor category techniques. We applied
the new approach, using a continuation monad with a very simple domain of "results"(1j) to prove properties of FreshML. Variations on this theme seem very promising; for
example, replacing 1j by S\Delta 1j for a suitable (recursively defined) FM-cppo of "states"should give a useful denotational semantics of ML-style references with no restriction on
the type of value stored--we plan to explore this elsewhere. Finally we should mention thatgame semantics can also make gooduse of FM-sets to achieve new full a-straction results:
see [1].

Appendix A. Typing relation

The Mini-FreshML typing relation for expressions, \Sigma  \Delta  e : \Xi , is inductively defined bythe following axioms and rules.

\Sigma  \Delta  x : \Xi  (x \Psi  dom(\Sigma ) and \Sigma (x) = \Xi ) \Sigma  \Delta  () : unit
\Sigma  \Delta  a : name (a \Psi  A)

\Sigma  \Delta  e : \Lambda k
\Sigma  \Delta  Ck(e) : \Pi  (\Pi  = C1 of \Lambda 1| * * * |Cn of \Lambda n)

\Sigma  \Delta  e : \Xi  \Sigma  \Delta  e\Phi  : \Xi \Phi 

\Sigma  \Delta  (e, e\Phi ) : \Xi  * \Xi \Phi  \Sigma  \Delta  fresh : name

\Sigma  \Delta  e : name \Sigma  \Delta  e\Phi  : \Xi 
\Sigma  \Delta  <<e>>e\Phi  : <<name>>\Xi 

\Sigma  \Delta  e : name \Sigma  \Delta  e\Phi  : name \Sigma  \Delta  e\Phi \Phi  : \Xi 

\Sigma  \Delta  swap e, e\Phi  in e\Phi \Phi  : \Xi 

\Sigma , f : \Xi  ffi \Xi \Phi , x : \Xi  \Delta  e : \Xi \Phi 
\Sigma  \Delta  fun f (x) = e : \Xi  ffi \Xi \Phi 

\Sigma  \Delta  e : \Xi \Phi  ffi \Xi  \Sigma  \Delta  e\Phi  : \Xi \Phi 

\Sigma  \Delta  e e\Phi  : \Xi 

\Sigma  \Delta  e : \Xi \Phi  \Sigma , x : \Xi \Phi  \Delta  e\Phi  : \Xi 

\Sigma  \Delta  let x = e in e\Phi  : \Xi 

50 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55

\Sigma  \Delta  e : \Xi \Phi  * \Xi \Phi \Phi  \Sigma , x : \Xi \Phi , x\Phi  : \Xi \Phi \Phi  \Delta  e\Phi  : \Xi 

\Sigma  \Delta  let (x, x\Phi ) = e in e\Phi  : \Xi 

\Sigma  \Delta  e : <<name>>\Xi \Phi  \Sigma , x : name, x\Phi  : \Xi \Phi  \Delta  e\Phi  : \Xi 

\Sigma  \Delta  let <<x>>x\Phi  = e in e\Phi  : \Xi 

\Sigma  \Delta  e : name \Sigma  \Delta  e\Phi  : name \Sigma  \Delta  e1 : \Xi  \Sigma  \Delta  e2 : \Xi 

\Sigma  \Delta  if e = e\Phi  then e1 else e2 : \Xi 

\Sigma  \Delta  e : \Pi %
k \Psi  {1, . . . , n}. \Sigma , x : \Lambda k \Delta  ek : \Xi 

\Sigma  \Delta  match e with (C1(x1) -> e1| * * *

| Cn(xn) -> en) : \Xi 

(\Pi  = C1 of \Lambda 1| * * * |Cn of \Lambda n)

Appendix B. Termination relation

\Theta S, e\Lambda ae is inductively defined by the following axiom and rules, where S ranges overframe stacks,

e, e\Phi , . . . over expressions, v, v\Phi , . . . over values, and a, a\Phi , . . . over atoms.The definition is split into two parts for clarity.

Part 1: \Theta S, v\Lambda ae where v is a value.

\Theta [], v\Lambda ae \Theta 

S, Ck(v)\Lambda ae\Theta 
S ss Ck([\Sigma ]), v\Lambda ae \Theta 

S ss (v, [\Sigma ]), e\Lambda ae\Theta 
S ss ([\Sigma ], e), v\Lambda ae\Theta 

S, (v\Phi , v)\Lambda ae\Theta 
S ss (v\Phi , [\Sigma ]), v\Lambda ae \Theta 

S ss <<v>>[\Sigma ], e\Lambda ae\Theta 
S ss <<[\Sigma ]>>e, v\Lambda ae \Theta 

S, <<v>>v\Phi \Lambda ae\Theta 
S ss <<v>>[\Sigma ], v\Phi \Lambda ae\Theta 
S ss swap a, [\Sigma ] in e\Phi \Phi , e\Phi \Lambda ae\Theta 
S ss swap [\Sigma ], e\Phi  in e\Phi \Phi , a\Lambda ae \Theta 

S ss swap a, a\Phi  in [\Sigma ], e\Phi \Phi \Lambda ae\Theta 
S ss swap a, [\Sigma ] in e\Phi \Phi , a\Phi \Lambda ae\Theta 
S, (a a\Phi ) * v\Lambda ae\Theta 
S ss swap a, a\Phi  in [\Sigma ], v\Lambda ae \Theta 

S ss v [\Sigma ], e\Lambda ae\Theta 
S ss [\Sigma ] e, v\Lambda ae

v = (fun f (x) = e) \Theta S, e[v/f, v\Phi /x]\Lambda ae\Theta 

S ss v [\Sigma ], v\Phi \Lambda ae\Theta 

S, e[v/x]\Lambda ae\Theta 
S ss let x = [\Sigma ] in e, v\Lambda ae\Theta 

S, e[v/x, v\Phi /x\Phi ]\Lambda ae\Theta 
S ss let (x, x\Phi ) = [\Sigma ] in e, (v, v\Phi )\Lambda ae
a\Phi  \Psi  A \Sigma  supp(S, v, e) \Theta S, e[a\Phi /x, ((a a\Phi ) * v)/x\Phi ]\Lambda ae\Theta 

S ss let <<x>>x\Phi  = [\Sigma ] in e, <<a>>v\Lambda ae\Theta 

S ss if a = [\Sigma ] then e1 else e2, e\Phi \Lambda ae\Theta 
S ss if [\Sigma ] = e\Phi  then e1 else e2, a\Lambda ae\Theta 

S, e1\Lambda ae\Theta 

S ss if a = [\Sigma ] then e1 else e2, a\Phi \Lambda ae if a = a\Phi 

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 51

\Theta S, e2\Lambda ae\Theta 
S ss if a = [\Sigma ] then e1 else e2, a\Phi \Lambda ae if a (= a\Phi 

v = Ck(vk), for some 1\Theta k \Theta n \Theta S, ek[vk/xk]\Lambda ae\Theta 
S ss match [\Sigma ] with C1(x1) -> e1| * * * |Cn(xn) -> en, v\Lambda ae

Part 2: \Theta S, e\Lambda ae where e is non-value expression.\Theta 

S ss Ck([\Sigma ]), e\Lambda ae\Theta 

S, Ck(e)\Lambda ae

a \Psi  A \Sigma  supp(S) \Theta S, a\Lambda ae\Theta 

S, fresh\Lambda ae\Theta 

Sss ([\Sigma ], e\Phi ), e\Lambda ae\Theta 

S, (e, e\Phi )\Lambda ae \Theta 

S ss <<[\Sigma ]>>e\Phi , e\Lambda ae\Theta 

S, <<e>>e\Phi \Lambda ae\Theta 
S ss swap [\Sigma ], e\Phi  in e\Phi \Phi , e\Lambda ae\Theta 

S, swap e, e\Phi  in e\Phi \Phi \Lambda ae \Theta 

S ss [\Sigma ] e\Phi , e\Lambda ae\Theta 

S, e e\Phi \Lambda ae\Theta 
S ss let x = [\Sigma ] in e\Phi , e\Lambda ae\Theta 

S, let x = e in e\Phi \Lambda ae \Theta 

S ss let (x, x\Phi ) = [\Sigma ] in e\Phi , e\Lambda ae\Theta 

S, let (x, x\Phi ) = e in e\Phi \Lambda ae\Theta 
S ss let <<x>>x\Phi  = [\Sigma ] in e\Phi , e\Lambda ae\Theta 

S, let <<x>>x\Phi  = e in e\Phi \Lambda ae

\Theta S ss if [\Sigma ] = e\Phi  then e1 else e2, e\Lambda ae\Theta 

S, if e = e\Phi  then e1 else e2\Lambda ae

\Theta S ss match [\Sigma ] with C1(x1) -> e1| * * * |Cn(xn) -> en, e\Lambda ae\Theta 

S, match e with C1(x1) -> e1| * * * |Cn(xn) -> en \Lambda ae .

Appendix C. Denotation of expressions

Notation: In this and the following appendices, write \Delta x.t for the strict function that mapsnon-bottom elements

x to t. Extend this notation in the o-vious way to write \Delta \Theta d1, d2\Lambda .t forstrict functions
D1 & D2\Delta D and \Delta  [a] d.t for strict functions [A]D\Delta D\Phi . (Note that thisnotation imposes no conditions as to which particular representative in [

A]D is chosen: thesemantics below makes this explicit.) We also write \Theta 
d1, d2\Lambda  to indicate a smash pair (such

that \Theta d1, d2\Lambda  def= jD1&D2 when either of d1 \Psi  D1 and d2 \Psi  D2 are bottom). The notation
if a = a\Phi  then d else d\Phi  means d if a and a\Phi  are equal and d\Phi  otherwise.

The function E\Delta \Sigma  \Delta  e : \Xi \Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta jj maps j to itself and for non-bottom arguments
fl is defined by induction on the structure of e as follows:* E

\Delta \Sigma  \Delta  x : \Xi \Theta fl def= \Delta \Lambda  \Psi  \Delta \Sigma (x)\Theta j.\Lambda (fl(x))* E
\Delta \Sigma  \Delta  () : unit\Theta fl def= \Delta \Lambda  \Psi  \Delta unit\Theta j.\Lambda (`)* E
\Delta \Sigma  \Delta  a : name\Theta fl def= \Delta \Lambda  \Psi  \Delta name\Theta j.\Lambda (a)* E
\Delta \Sigma  \Delta  Ck(e) : \Pi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Pi \Theta j.E\Delta \Sigma  \Delta  e : \Lambda k\Theta fl(\Delta d \Psi  \Delta \Lambda k\Theta .\Lambda ((iss ink)d))

52 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55

* E\Delta \Sigma  \Delta  (e, e\Phi ) : \Xi  * \Xi \Phi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi  * \Xi \Phi \Theta j.E\Delta \Sigma  \Delta  e : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .E\Delta 

\Sigma  \Delta  e\Phi  : \Xi \Phi \Theta fl(\Delta d\Phi  \Psi  \Delta \Xi \Phi \Theta .\Lambda \Theta d, d\Phi \Lambda ))* E

\Delta \Sigma  \Delta  fresh : name\Theta fl def= new def=

\Delta \Lambda  \Psi  \Delta name\Theta j.\Lambda (a) (any a \Psi  A \Sigma  supp(\Lambda ))* E
\Delta \Sigma  \Delta  <<e>>e\Phi  : <<name>>\Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta <<name>>\Xi \Theta j.E\Delta \Sigma  \Delta  e : name\Theta fl(\Delta a \Psi  \Delta name\Theta .E\Delta 

\Sigma  \Delta  e\Phi  : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .\Lambda ([a] d)))* E

\Delta \Sigma  \Delta  swap e, e\Phi  in e\Phi \Phi  : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : name\Theta fl(\Delta a \Psi  \Delta name\Theta .E\Delta 

\Sigma  \Delta  e\Phi  : name\Theta fl(\Delta a\Phi  \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e\Phi \Phi  : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .
\Lambda ((a a\Phi ) * d))))* E

\Delta \Sigma  \Delta  fun f (x) = e : \Xi  ffi \Xi \Phi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi  ffi \Xi \Phi \Theta j.\Lambda (fix(\Delta d \Psi  \Delta \Xi  ffi \Xi \Phi \Theta .\Delta d\Phi  \Psi  \Delta \Xi \Theta .E\Delta 

\Sigma , f : \Xi  ffi \Xi \Phi , x : \Xi  \Delta  e : \Xi \Phi \Theta (fl[f !ffi d, x !ffi d\Phi ])))* E

\Delta \Sigma  \Delta  e e\Phi  : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : \Xi  ffi \Xi \Phi \Theta fl(\Delta d \Psi  \Delta \Xi  ffi \Xi \Phi \Theta .E\Delta 

\Sigma  \Delta  e\Phi  : \Xi \Theta fl(\Delta d\Phi  \Psi  \Delta \Xi \Theta .d d\Phi  \Lambda ))* E

\Delta \Sigma  \Delta  let x = e in e\Phi  : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : \Xi \Phi \Theta fl(\Delta d\Phi  \Psi  \Delta \Xi \Phi \Theta .E\Delta 

\Sigma , x : \Xi \Phi  \Delta  e\Phi  : \Xi \Theta (fl[x !ffi d\Phi ])\Lambda ).* E

\Delta \Sigma  \Delta  let (x, x\Phi ) = e in e\Phi  : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : \Xi 1 * \Xi 2\Theta fl(\Delta \Theta d1, d2\Lambda  \Psi  \Delta \Xi 1 * \Xi 2\Theta .E\Delta 

\Sigma , x : \Xi 1, x\Phi  : \Xi 2 \Delta  e\Phi  : \Xi \Theta (fl[x !ffi d1, x\Phi  !ffi d2])\Lambda )* E

\Delta \Sigma  \Delta  let <<x>>x\Phi  = e in e\Phi  : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : <<name>>\Xi \Phi \Theta fl(\Delta  [a] d\Phi  \Psi  \Delta <<name>>\Xi \Phi \Theta .E\Delta 

\Sigma , x : name, x\Phi  : \Xi \Phi  \Delta  e\Phi  : \Xi \Theta (fl[x !ffi a\Phi , x\Phi  !ffi (a a\Phi ) * d\Phi ])\Lambda )(any

a\Phi  \Psi  A \Sigma  supp(e, e\Phi , fl, \Lambda , a, d\Phi ))* E

\Delta \Sigma  \Delta  if e = e\Phi  then e1 else e2 : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.\Delta \Sigma  \Delta  e : name\Theta fl(\Delta a \Psi  \Delta name\Theta .\Delta \Sigma  \Delta  e\Phi  : name\Theta fl(\Delta a\Phi  \Psi  \Delta name\Theta .

if a = a\Phi  then E\Delta \Sigma  \Delta  e1 : \Xi \Theta fl \Lambda  else E\Delta \Sigma  \Delta  e2 : \Xi \Theta fl \Lambda ))* E

\Delta \Sigma  \Delta  match e with * * * |Ck(xk) -> ek| * * * : \Xi \Theta fl def=

\Delta \Lambda  \Psi  \Delta \Xi \Theta j.E\Delta \Sigma  \Delta  e : \Pi \Theta fl(\Delta d\Phi  \Psi  \Delta \Pi \Theta .E\Delta \Sigma , xk : \Lambda k \Delta  ek : \Xi \Theta (fl[xk !ffi dk])\Lambda )(for the unique

k and dk such that d\Phi  = (iss ink)dk).

Appendix D. Denotation of values (expressions in canonical form)

The function V\Delta \Sigma  \Delta  v : \Xi \Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta  maps j to itself and for non-bottom arguments
fl is defined by induction on the structure of the canonical form v as given below.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 53

* V\Delta \Sigma  \Delta  x : \Xi \Theta fl def= fl(x)* V

\Delta \Sigma  \Delta  () : unit\Theta fl def= `* V
\Delta \Sigma  \Delta  a : name\Theta fl def= a* V
\Delta \Sigma  \Delta  Ck(v) : \Pi \Theta fl def= (iss ink)(V\Delta \Sigma  \Delta  v : \Lambda k\Theta fl)* V
\Delta \Sigma  \Delta  (v, v\Phi ) : \Xi  * \Xi \Phi \Theta fl def= \Theta V\Delta \Sigma  \Delta  v : \Xi \Theta fl, V\Delta \Sigma  \Delta  v\Phi  : \Xi \Phi \Theta fl\Lambda * V
\Delta \Sigma  \Delta  <<a>>v : <<name>>\Xi \Theta fl def= [a] (V\Delta \Sigma  \Delta  v : \Xi \Theta fl)* V
\Delta \Sigma  \Delta  fun f (x) = e : \Xi  ffi \Xi \Phi \Theta fl def=fix

(\Delta d \Psi  \Delta \Xi  ffi \Xi \Phi \Theta .\Delta d\Phi  \Psi  \Delta \Xi \Theta .E\Delta 

\Sigma , f : \Xi  ffi \Xi \Phi , x : \Xi  \Delta  e : \Xi \Phi \Theta (fl[f !ffi d, x !ffi d\Phi ])).

Appendix E. Denotation of frame stacks

The function S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta  \Psi  \Delta \Sigma \Theta \Delta \Delta \Xi \Theta j maps j to itself and for non-bottom ar-guments

fl is defined by induction on the structure of S as follows. (The notation let a =
d in d\Phi [a] means d\Phi [a] if d \Psi  Aj is the non-bottom element given -y a \Psi  A and jotherwise.)

* S\Delta \Sigma  \Delta  [] : \Xi \Delta __\Theta fl def= \Delta x \Psi  \Delta \Xi \Theta .`* S

\Delta \Sigma  \Delta  S ss Ck([\Sigma ]) : \Lambda k\Delta __\Theta fl def= \Delta v \Psi  \Delta \Lambda k\Theta .S\Delta \Sigma  \Delta  S : \Pi \Delta __\Theta fl((iss ink)v)* S
\Delta \Sigma  \Delta  S ss ([\Sigma ], e) : \Xi \Delta __\Theta fl def=

\Delta d \Psi  \Delta \Xi \Theta .E\Delta \Sigma  \Delta  e : \Xi \Phi \Theta fl(\Delta d\Phi  \Psi  \Delta \Xi \Phi \Theta .S\Delta \Sigma  \Delta  S : \Xi  * \Xi \Phi \Theta fl\Theta d, d\Phi \Lambda )* S

\Delta \Sigma  \Delta  S ss (v, [\Sigma ]) : \Xi \Phi \Delta __\Theta fl def=

\Delta d \Psi  \Delta \Xi \Phi \Theta .S\Delta \Sigma  \Delta  S : \Xi  * \Xi \Phi \Theta fl\Theta V\Delta \Sigma  \Delta  v : \Xi \Theta fl, d\Lambda * S

\Delta \Sigma  \Delta  S ss <<[\Sigma ]>>e : name\Delta __\Theta fl def=

\Delta a \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .S\Delta \Sigma  \Delta  S : <<name>>\Xi \Theta fl([a] d))* S

\Delta \Sigma  \Delta  S ss <<v>>[\Sigma ] : \Xi \Delta __\Theta (fl) def=

\Delta d \Psi  \Delta \Xi \Theta .S\Delta \Sigma  \Delta  S : <<name>>\Xi \Theta fl(\Upsilon V\Delta \Sigma  \Delta  v : name\Theta fl\Phi  d)* S

\Delta \Sigma  \Delta  S ss swap [\Sigma ], e\Phi  in e\Phi \Phi  : name\Delta __\Theta fl def=

\Delta a \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e\Phi  : name\Theta fl(\Delta a\Phi  \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e\Phi \Phi  : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .S\Delta 

\Sigma  \Delta  S : \Xi \Delta __\Theta fl((a a\Phi ) * d)))* S

\Delta \Sigma  \Delta  S ss swap v, [\Sigma ] in e\Phi \Phi  : name\Delta __\Theta fl def=

let a = V\Delta \Sigma  \Delta  v : name\Theta fl in \Delta a\Phi  \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e\Phi \Phi  : \Xi \Theta fl(\Delta d \Psi  \Delta \Xi \Theta .S\Delta 

\Sigma  \Delta  S : \Xi \Delta __\Theta fl((a a\Phi ) * d))* S

\Delta \Sigma  \Delta  S ss swap v, v\Phi  in [\Sigma ] : \Xi \Delta __\Theta fl def=

let a = V\Delta \Sigma  \Delta  v : name\Theta fl in let a\Phi  = V\Delta \Sigma  \Delta  v\Phi  : name\Theta fl in

\Delta d \Psi  \Delta \Xi \Theta .S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl((a a\Phi ) * d)* S

\Delta \Sigma  \Delta  S ss [\Sigma ] e : (\Xi  ffi \Xi \Phi )\Delta __\Theta fl def=

\Delta d \Psi  \Delta \Xi  ffi \Xi \Phi \Theta .E\Delta \Sigma  \Delta  e : \Xi \Theta fl(\Delta d\Phi  \Psi  \Delta \Xi \Theta .d d\Phi (S\Delta \Sigma  \Delta  S : \Xi \Phi \Delta __\Theta fl))* S

\Delta \Sigma  \Delta  S ss v [\Sigma ] : \Xi \Delta __\Theta fl def=

\Delta d \Psi  \Delta \Xi \Theta .(V\Delta \Sigma  \Delta  v : \Xi  ffi \Xi \Phi \Theta fl d)(S\Delta \Sigma  \Delta  S : \Xi \Phi \Delta __\Theta fl)

54 M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55

* S\Delta \Sigma  \Delta  S ss let x = [\Sigma ] in e : \Xi \Delta __\Theta fl def=

\Delta d \Psi  \Delta \Xi \Theta .E\Delta \Sigma , x : \Xi  \Delta  e : \Xi \Phi \Theta (fl[x !ffi d])(S\Delta \Sigma  \Delta  S : \Xi \Phi \Delta __\Theta fl)* S

\Delta \Sigma  \Delta  S ss let (x, x\Phi ) = [\Sigma ] in e : \Xi  * \Xi \Phi \Delta __\Theta fl def=

\Delta \Theta d1, d2\Lambda  \Psi  \Delta \Xi  * \Xi \Phi \Theta .E\Delta 

\Sigma , x : \Xi , x\Phi  : \Xi \Phi  \Delta  e : \Xi \Phi \Phi \Theta (fl[x !ffi d1, x\Phi  !ffi d2])(S\Delta \Sigma  \Delta  S : \Xi \Phi \Phi \Delta __\Theta fl)* S

\Delta \Sigma  \Delta  S ss let <<x>>x\Phi  = [\Sigma ] in e : <<name>>\Xi \Delta __\Theta fl def=

\Delta  [a] d \Psi  \Delta <<name>>\Xi \Theta .E\Delta \Sigma , x : name, x\Phi  : \Xi  \Delta  e : \Xi \Phi \Theta 

(fl[x !ffi a\Phi , x\Phi  !ffi (a a\Phi ) * d])(S\Delta \Sigma  \Delta  S : \Xi \Phi \Delta __\Theta fl)(any

a\Phi  \Psi  A \Sigma  supp(S, e, fl, a, d))* S

\Delta \Sigma  \Delta  S ss if [\Sigma ] = e\Phi  then e1 else e2 : \Xi \Delta __\Theta fl def=

\Delta a \Psi  \Delta name\Theta .E\Delta \Sigma  \Delta  e\Phi  : name\Theta fl(\Delta a\Phi  \Psi  \Delta name\Theta .

if a = a\Phi  then E\Delta \Sigma  \Delta  e1 : \Xi \Theta fl(S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl)else E\Delta 

\Sigma  \Delta  e2 : \Xi \Theta fl(S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl))* S

\Delta \Sigma  \Delta  S ss if v = [\Sigma ] then e1 else e2 : \Xi \Delta __\Theta fl def=

\Delta a\Phi  \Psi  \Delta name\Theta .if V\Delta \Sigma  \Delta  v : name\Theta (fl) = a\Phi 

then E\Delta \Sigma  \Delta  e1 : \Xi \Theta fl(S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl)else E\Delta 

\Sigma  \Delta  e2 : \Xi \Theta fl(S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl)* S

\Delta \Sigma  \Delta  S ss match [\Sigma ] with * * * |Ck(xk) -> ek| * * * : \Pi \Delta __\Theta fl def=

\Delta d \Psi  \Delta \Pi \Theta .E\Delta \Sigma , xk : \Lambda k \Delta  ek : \Xi \Theta (fl[xk !ffi dk])(S\Delta \Sigma  \Delta  S : \Xi \Delta __\Theta fl)(for the unique k and

dk such that d = (iss ink)dk).

References

[1] S. A-ramsky, D.R. Ghica, A.S. Murowski, C.-H.L. Ong, I.D.B. Stark, Nominal games andfull a-straction for

the nu-calculus, in: 19thAnnu. Symp. Logic in Computer Science, IEEE Computer Society Press,Washington,
2004.
[2] S. Abramsky, A. Jung, Domain theory, in: Handbook of Logic in Computer Science, vol. 3, Clarendon Press,

1994, pp. 1-168.
[3] H.P. Barendregt, The Lambda Calculus: Its Syntax and Semantics, revised ed., North-Holland, Amsterdam,

1984.
[4] M.J. Gabbay,A.M. Pitts,A new approach to abstract syntax with variable binding, FormalAspects of Comput.

13 (2002) 341-363.
[5] I.A. Mason, C.L. Talcott, Equivalence in functional languages with effects, J. Function. Program. 1 (3) (1991)

287-327.
[6] E. Moggi,An abstract view ofprogramming languages,Technical Report ECS-LFCS-90-113, Dept. Computer

Science, Univ. Edin-urgh, 1989.
[7] E. Moggi, Notions of computation and monads, Inform. Comput. 93 (1) (1991) 55-92.
[8] S.L. Peyton Jones, Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-

language calls in Haskell, in: C.A.R. Hoare, M. Broy, R. Steinbruggen (Eds.), Engineering Theories of
Software Construction, IOS Press, 2001, pp. 47-96.
[9] A.M. Pitts, Relational properties of domains, Inform. Comput. 127 (1996) 66-90.
[10] A.M. Pitts, Operational semantics and program equivalence, in: Applied Semantics, Advanced Lectures,

Lecture Notes in Computer Science Tutorial, vol. 2395, Springer, Berlin, 2002, pp. 378-412.
[11] A.M. Pitts, Nominal logic a first order theory of names and binding, Inform. Comput. 186 (2003) 165-193.
[12] A.M. Pitts, I.D.B. Stark, Observable properties of higher order functions that dynamically create local names,

or: What's new? in: Mathematical Foundations of Computer Science, Proc. 18th Internat. Symp., Gda'nsk,
1993, Lecture Notes in Computer Science, vol. 711, Springer, Berlin, 1993, pp. 122-141.

M.R. Shinwell, A.M. Pitts / Theoretical Computer Science 342 (2005) 28-55 55
[13] A.M. Pitts, I.D.B. Stark, Operational reasoning for functions with local state, in: A.D. Gordon, A.M. Pitts

(Eds.), Higher Order Operational Techniques in Semantics, Cambridge University Press, Cambridge, 1998,
pp. 227-273.
[14] G.D. Plotkin, LCF considered as a programming language, Theor. Comput. Sci. 5 (1977) 223-255.
[15] M.R. Shinwell, Swapping the atom: programming with binders in Fresh O'Caml, Proc. MER\Delta IN, 2003.
[16] M.R. Shinwell, The Fresh Approach: Functional Programming with Names and Binders, Ph.D. Thesis,

University of Cambridge Computer Laboratory, 2005, in preparation.
[17] M.R. Shinwell, A.M. Pitts, Fresh O'Caml User Manual, Cambridge University Computer Laboratory,

September. Available at \Theta http://www.freshml.org/foc/\Lambda .
[18] M.R. Shinwell, A.M. Pitts, M.J. Gabbay, FreshML: programming with binders made simple, in: Proc. ICFP

'03, ACM Press, 2003, pp. 263-274.
[19] I.D.B. Stark, Categorical models for local names, Lisp Symbol. Comput. 9 (1) (1996) 77-107.
[20] C. Urban,A.M. Pitts, M.J. Gabbay, Nominal unification, in: Proc. CSL'03 & KGC, Lecture Notes in Computer

Science, vol. 2803, Springer, Berlin, 2003, pp. 513-527.
[21] P. Wadler, Comprehending monads, Math. Struct. Computer Sci. 2 (1992) 461-493.
[22] A.K. Wright, M. Felleisen, A syntactic approach to type soundness, Inform. Comput. 115 (1994) 38-94.