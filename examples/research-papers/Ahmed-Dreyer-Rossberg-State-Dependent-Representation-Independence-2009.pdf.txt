

State-Dependent Representation Independence
Amal AhmedTTI-C

amal@tti-c.org

Derek DreyerMPI-SWS
dreyer@mpi-sws.mpg.de

Andreas RossbergMPI-SWS
rossberg@mpi-sws.mpg.de

AbstractMitchell's notion of representation independence is a particularly
useful application of Reynolds' relational parametricity -- two dif-ferent implementations of an abstract data type can be shown contextually equivalent so long as there exists a relation between theirtype representations that is preserved by their operations. There
have been a number of methods proposed for proving represen-tation independence in various pure extensions of System F (where
data abstraction is achieved through existential typing), as well asin Algol- or Java-like languages (where data abstraction is achieved
through the use of local mutable state). However, none of these ap-proaches addresses the interaction of existential type abstraction
and local state. In particular, none allows one to prove representa-tion independence results for generative ADTs -- i.e., ADTs that
both maintain some local state and define abstract types whose in-ternal representations are dependent on that local state.

In this paper, we present a syntactic, logical-relations-basedmethod for proving representation independence of generative
ADTs in a language supporting polymorphic types, existentialtypes, general recursive types, and unrestricted ML-style mutable references. We demonstrate the effectiveness of our method byusing it to prove several interesting contextual equivalences that involve a close interaction between existential typing and local state,as well as some well-known equivalences from the literature (such
as Pitts and Stark's "awkward" example) that have caused troublefor previous logical-relations-based methods.

The success of our method relies on two key technical inno-vations. First, in order to handle generative ADTs, we develop a
possible-worlds model in which relational interpretations of typesare allowed to grow over time in a manner that is tightly coupled
with changes to some local state. Second, we employ a step-indexedstratification of possible worlds, which facilitates a simplified account of mutable references of higher type.Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal Definitions and Theory; D.3.3 [ProgrammingLanguages]: Language Constructs and Features--Abstract data
types; F.3.1 [Logics and Meanings of Programs]: Specifying andVerifying and Reasoning about Programs

General Terms Languages, Theory, VerificationKeywords Abstract data types, representation independence, existential types, local state, step-indexed logical relations
Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.POPL'09, January 18-24, 2009, Savannah, Georgia, USA.

Copyright c! 2009 ACM 978-1-60558-379-2/09/01. . . $5.00Reprinted from POPL'09,, [Unknown Proceedings], January 18-24, 2009, Savannah,
Georgia, USA., pp. 1-??.

1. IntroductionReynolds' notion of relational parametricity [23] is the essence of
type abstraction -- clients of an abstract type behave uniformlyacross all relational interpretations of that type and thus cannot depend in any way on how the type is represented. Mitchell's notionof representation independence [17] is a particularly useful application of relational parametricity -- two different implementationsof an abstract data type can be shown contextually equivalent so
long as there exists a relation between their type representationsthat is preserved by their operations. This is useful even when the
type representations of the two ADTs are the same, because thechoice of an arbitrary relational interpretation for the abstract type
allows one to establish the existence of local invariants.Originally these ideas were developed in the context of (variants of) System F, but over the past two decades there has been agreat deal of work on extending them to the setting of more realistic languages, such as those with recursive functions [20], generalrecursive types [16, 1, 11], selective strictness [29], etc. In these
functional languages, data abstraction is achieved through the useof existential types. Others have considered representation independence in the setting of imperative languages, such as Algol andJava, where data abstraction is achieved instead through the use of
local mutable state (e.g., local variables or private fields) [21, 5, 14].Of course, most modern languages (such as ML) are neither purely functional nor imperative, but rather freely mix theparadigms. However, none of the existing work on representation
independence has considered a language supporting both the func-tional and the imperative approaches to data abstraction, i.e., both
existential types and local state. This is unfortunate, since both ab-straction mechanisms play important, interdependent roles in the
definition of generative abstract data types.

1.1 Reasoning About Generative Abstract Data TypesExistential type abstraction provides type generativity -- every
unpacking of an existential package generates a fresh abstract typethat is distinct from any other. This is similar to the behavior of
Standard ML's generative functors, which generate fresh abstracttypes at each application, and indeed the semantics of SML-style
functors may be understood as a stylized use of existential typeabstraction [25]. The clearest motivation for type generativity is
in the definition of ADTs that encapsulate some local state. Insuch instances, generativity is sometimes necessary to achieve the
proper degree of data abstraction.As a simple motivating example, consider the SML module code in Figure 1, which is adapted from an example ofDreyer et al. [12]. (Later in the paper, we will develop a similar example using existential types.) Here, the signature SYMBOLdescribes a module implementing a mutable symbol table, which
maps "symbols" to strings. The module provides an abstract type
t describing the symbols currently in its table; a function eq forcomparing symbols for equality; a function

insert, which adds a

1

signature SYMBOL = sig

type t
val eq : t * t -> bool
val insert : string -> t
val lookup : t -> string
end
functor Symbol () :> SYMBOL = struct

type t = int
val size = ref 0
val table = ref nil
fun eq (x,y) = x = y
fun insert str = (

size := !size + 1;
table := str :: !table;
!size
)
fun lookup n =

List.nth (!table, !size - n)
end Figure 1. Generativity Example

given string to the table and returns a fresh symbol mapped to it;and a function

lookup, which looks up a given symbol in the tableand returns the corresponding string.

The functor Symbol implements the symbol type t as an integerindex into a (mutable) list of strings. When applied,

Symbol createsa fresh
table (represented as a pointer to an empty list) and amutable counter

size (representing the size of the table). Theimplementations of the various functions are straightforward, and

the body of the functor is sealed with the signature SYMBOL, thushiding access to the local state (

table and size).The call to
List.nth in the lookup function might in generalraise a
Subscript exception if the input n were an arbitrary inte-ger. However, we "know" that this cannot happen because

lookupis exported with argument type
t, and the only values of type t thata client could possibly have gotten hold of are the values returned

by insert, i.e., integers that are between 1 and the current size of
table. Therefore, the implementation of the lookup function neednot bother handling the

Subscript exception.This kind of reasoning is commonplace in modules that encapsulate local state. But what justifies it? Intuitively, the answer istype generativity. Each instantiation of the

Symbol functor createsa fresh symbol type
t, which represents the type of symbols that arevalid in its own
table (but not any other). Were Symbol not gen-erative, each application of the

Symbol functor would produce amodule with distinct local state but the same symbol type. It would

then be easy to induce a Subscript error by accidentally passinga value of one table's symbol type to another's

lookup function.1While this intuition about the importance of generativity is very

appealing, it is also completely informal. The goal of this paper isto develop a formal framework for reasoning about the interaction
of generative type abstraction and mutable state.In the case of an example like the

Symbol functor, we willbe able to show that the implementation of

Symbol shown inFigure 1 is contextually equivalent to one whose

lookup functionis replaced by:

fun lookup n =

if n > 0 andalso n <= !size

andalso !size = length(!table)
then List.nth (!table, !size - n)
else "Hell freezes over"

1 This is the case, for example, in OCaml, which only supports applicative(i.e., non-generative) functors [15].

In other words, there is no observable difference between the orig-inal

Symbol functor and one that dynamically checks the variousinvariants we claim to "know." Hence, the checks are unnecessary.

This kind of result can be understood as an instance of represen-tation independence, albeit a somewhat degenerate one in that the
ADTs in question share the same type representation. As with mostsuch results, the proof hinges on the construction of an appropriate
relational interpretation of the abstract type t, which serves to im-pose an invariant on the possible values of type

t. In this case, wewish to assert that for a particular structure
S defined by Symbol(),the only values of type
S.t are integers between 1 and the currentsize of
S's table. This will allow us to prove that any range checkon the argument to

S's lookup function is superfluous.The problem is that the relational interpretation we wish to

assign to S.t depends on the current values stored in S's localstate. In effect, as

S's insert function is called repeatedly overtime, its
table grows larger, and the relational interpretation of
S.t must grow accordingly to include more and more integers.Thus, what we need is an account of state-dependent representation

independence, in which the relational interpretations of abstracttypes are permitted to grow over time, in a manner that is tightly
coupled with changes to some local state.
1.2 OverviewIn this paper, we present a novel method for proving state-dependent

representation independence results. Our method extends previ-ous work by Ahmed on syntactic step-indexed logical relations
for recursive and quantified types [1]. We extend her techniquewith support for reasoning about local state, and demonstrate its
effectiveness on a variety of small but representative examples.Although our primary focus is on proving representation independence for ADTs that exhibit an interaction of existentials and state,our method also handles several well-known simply-typed examples from the literature on local state (such as Pitts and Stark's"awkward" example [21]) that have proven difficult for previous
logical-relations-based methods to handle.In order to reason about local state, we build into our logical
relation a notion of possible worlds. While several aspects of ourpossible worlds are derived from and inspired by prior work, other
aspects are quite novel:1. We enrich our possible worlds with populations and laws,

which allow us to evolve the relational interpretation of anabstract type over time in a controlled, state-dependent fashion.
For instance, we can use a population to grow a set of val-ues (e.g., the integers between 1 and some

n), together with alaw that explains what the current population implies about the

current machine state (e.g., that the symbol table has size n).2. Second, our method provides the ability to reason locally about

references to higher-order values. While ours is not the firstmethod to handle higher-order state, our approach is novel and
arguably simpler than previous accounts. It depends criticallyon step-indexing in order to avoid a circularity in the construction of possible worlds.The remainder of the paper is structured as follows. In Section 2, we present Fu!, our language under consideration, whichis essentially System F extended with general recursive types and
general ML-style references. In Section 3, we explain at a high levelhow our method works and what is novel about it. In Section 4, we
present the details of our logical relation and prove it sound (but notcomplete) with respect to contextual equivalence of

Fu! programs.In Section 5, we show how to use our method to prove a number of interesting contextual equivalences. Finally, in Section 6, weconclude with a thorough comparison to related work, as well as
directions for future work.

2

Types ! ::= " | unit | int | bool | !1 ! !2 | !1 " !2 |

#". ! | $". ! | u". ! | ref !Prim Ops

o ::= + | % | = | < | & | . . .Terms

e ::= x | () | l | +-n | o(e1, . . . , en) | true | false |

if e then e1 else e2 | 'e1, e2( | fst e | snd e |
#x : !. e | e1 e2 | !". e | e [!] |
pack !, e as $". !! | unpack e1 as ", x in e2 |
fold e | unfold e | ref e | !e | e1 := e2 | e1 == e2Values

v ::= () | l | +-n | true | false | 'v1, v2( |

#x : !. e | !". e | pack !1, v as $". ! | fold v

s, (#x : !. e) v )%" s, [v/x]e

s, (!". e) [!] )%" s, [!/"]e
s, unpack (pack !, v as $". !!) as ", x in e

)%" s, [!/"][v/x]e
s, unfold (fold v) )%" s, v

s, ref v )%" s[l )" v], l where l /* dom(s)

s, !l )%" s, v where s(l) = v
s, l:= v )%" s[l )" v], () where l * dom(s)

s, l == l )%" s, true
s, l == l! )%" s, false where l += l!

s, e )%" s!, e!
s, E[e] )%" s!, E[e!]Type Contexts

" ::= * | ", "Value Contexts

# ::= * | #, x : !Store Typing
$ ::= * | $, l : ! where FTV (!) = ,

#(x) = !
"; #; $ - x : ! . . .

$(l) = !
"; #; $ - l : ref !

"; #; $ - e : !
"; #; $ - ref e : ref !

"; #; $ - e : ref !

"; #; $ - !e : !

"; #; $ - e1 : ref ! "; #; $ - e2 : !

"; #; $ - e1 := e2 : unit

"; #; $ - e1 : ref ! "; #; $ - e2 : ref !

"; #; $ - e1 == e2 : boolWell-typed Store:

#l * dom($). *; *; $ - s(l) : $(l)

- s : $

Figure 2. Fu! Syntax + Dynamic and Static Semantics (excerpts)

2. The Language Fu!We consider

Fu!, a call-by-value !-calculus with impredicativepolymorphism, iso-recursive types, and general ML-style references. The syntax of Fu! is shown in Figure 2, together with ex-cerpts of the static and dynamic semantics. We assume an infinite
set of locations Loc ranged over by l. Our term language includesequality on references (

e1 == e2), but is otherwise standard.We define a small-step operational semantics for

Fu! as a rela-tion between configurations
(s, e), where s is a global store map-ping locations
l to values v. We use evaluation contexts E to lift theprimitive reductions to a standard left-to-right call-by-value semantics for the language. We elide the syntax of evaluation contexts asit is completely standard, and we show only some of the reduction
rules in Figure 2.

Fu! typing judgments have the form !; "; # ! e : " where thecontexts

!, ", and # are defined as in Figure 2. The type context !is used to track the set of type variables in scope; the value context

" is used to track the term variables in scope (along with their types
" , which must be well formed in context !, written ! ! "); andthe store typing

# tracks the types of the contents of locations inthe store. Note that

# maps locations to closed types. We write
FTV (" ) to denote the set of type variables that appear free in

type ". The typing rules are entirely standard, so we show onlya few rules in Figure 2. We refer the reader to the online technical
appendix [3] for full details of Fu!.
2.1 Contextual EquivalenceA context

C is an expression with a single hole [*] in it. Typingjudgments for contexts have the form

! C : (!; "; # ! ") "
(!!; "!; #! ! "!), where (!; "; # ! ") indicates the type of thehole. Essentially, this judgment says that if

e is an expression suchthat
!; "; # ! e : ", then !!; "!; #! ! C[e] : "!. The typing rulefor a hole

[*] is as follows:

! # !! " # "! # # #!

! [*] : (!; "; # ! " ) " (!!; "!; #! ! " )The other rules are straightforward (see our online appendix [3]).

We define contextual approximation (!; "; # ! e1 $ctx e2 : " )to mean that, for any well-typed program context

C with a hole ofthe type of
e1 and e2, the termination of C[e1] implies the termina-tion of
C[e2]. Contextual equivalence (!; "; # ! e1 %ctx e2 : " )is then defined as approximation in both directions.

Definition 2.1 (Contextual Approximation & Equivalence)Let

!; "; # ! e1 : " and !; "; # ! e2 : " .
"; #; $ - e1 .ctx e2 : ! def=

#C, $!, !!, s. - C : ("; #; $ - !) / (*; *; $! - !!) 0 - s : $! 0

s, C[e1] 1 =/ s, C[e2] 1

"; #; $ - e1 2ctx e2 : ! def=

"; #; $ - e1 .ctx e2 : ! 0 "; #; $ - e2 .ctx e1 : !

3. The Main IdeasIn this section we give an informal overview of the main novel ideas

in our method, and how it compares to some previous approaches.
3.1 Logical RelationsBroadly characterized, our approach is a logical relations method.

We define a relation V !" " #, which relates pairs of values at type ",where the free type variables of

" are given relational interpreta-tions in
#. The relation is "logical" in the sense that its definitionfollows the structure of

" , modeling each type constructor as a log-ical connective. For example, arrow types correspond to implication, so functions are defined to be related at an arrow type iff re-latedness of their arguments implies relatedness of their results. We
will show that this logical relation is sound with respect to contex-tual equivalence for

Fu!. This is useful because, for many examples,it is much easier to show two programs are in the logical relation

than to show they are contextually equivalent directly.Logical relations methods are among the oldest techniques for
proving representation independence results. We will assume thereader is generally familiar with the flavor of these techniques, and
instead focus on what is distinctive and original about ours.
3.2 Local Reasoning via Possible Worlds and IslandsAs explained in Section 1, our core contribution is the idea of

state-dependent relational interpretations of abstract types. That is,whether two values are related by some abstract type's relational interpretation may depend on the current state of the heap. But whendefining such a relational interpretation, how can we characterize
the "current state of the heap?"As a starting point, we review the general approach taken by
a number of prior works on reasoning about local state [21, 22,7, 10]. This approach, which utilizes a possible worlds model, has
influenced us greatly, and constitutes the foundation of our method.However, the form it has taken in prior work is insufficient for our
purposes, and it is instructive to see why.

3

The general approach of these prior works is to index the logicalrelation not only by a type

" but by a world W . Instead of charac-terizing the current state of the heap,

W characterizes the propertieswe expect the heap to have. In other words, it is a relation on machine stores, and we restrict attention to pairs of stores that satisfyit. If two values

v1 and v2 are in the logical relation at type " andworld
W , then it means they are related when considered under anytwo stores

s1 and s2, respectively, that satisfy W .Worlds in turn are constructed as a separating conjunction of

smaller worlds &w1, . . . , wn', sometimes called islands, whereeach island is a relation that "concerns" a disjoint piece of the
store. Intuitively, this means that each island distinguishes betweenpairs of stores only on the basis of a particular set of memory locations, and the set of locations that one island cares about is disjointfrom the set that any other one cares about.

Exactly how the separation criterion on islands is formalized isimmaterial; the important point is that it enables local reasoning.
Suppose we want to prove that one expression is related to anotherin world

W . Each may allocate some fresh piece of the store,and before showing that the resulting values of the expressions

are related, we are permitted to extend W with a new island wdescribing how these fresh pieces of the store relate to each other.
World extension is sound here precisely because the new island is(due to freshness of allocation) separate from the others. So long as
the expressions in question do not make the locations in their localstores publicly accessible, no other part of the program is capable
of mutating the store in such a manner as to violate w.To make things concrete and to observe the limitations of possible worlds (at least as we have described them), let us consider themotivating example from Section 1. To prove that the two implementations of the Symbol functor are contextually equivalent, wewill show that their bodies are logically related in an arbitrary initial world W0. Both functors allocate local state in the same way,namely by allocating one pointer for

table and one for size, sowe will want to extend
W0 with an island wsym describing the localinvariants on
table and size. How should we define wsym?One useful invariant that

wsym can enforce is that, for bothimplementations of
Symbol, the integer pointed to by size is equalto the length of the list pointed to by

table. By incorporating thisproperty into
wsym, we will be guaranteed that, in any future world(i.e., any extension of

W0 ( wsym) in which the lookup functionis called, the dynamic check

!size = length(!table) in thesecond implementation of
Symbol will always evaluate to true.We can also use
wsym to enforce that !size is the same in thestores of both programs, and similarly for

!table. Unfortunately,while this is a necessary condition, it is not sufficient to prove that

the range check on the argument of lookup in the second Symbolimplementation always evaluates to

true. For that, we need a wayof correlating the value of
!size and the possible values of type t,but the islands we have developed thus far do not provide one.

3.3 Populating the Islands and Enforcing the LawsThe problem with islands is that they are static entities with no
potential for development. To address this limitation, we enrich is-lands with populations. A population is a set of values that "inhabit" an island and affect the definition of the store relation forthat island. An island's population may grow over time (i.e., as we
move to future worlds), and its store relation may change accord-ingly. In order to control population growth, we equip every island
with an immutable law governing the connection between its pop-ulation and its store relation. We denote populations by

V , storerelations by
$, and laws by L.Consider the

Symbol example. Let us define Vn = {1, . . . , n},and let
$n be the store relation containing pairs of stores that obeythe properties concerning

table and size described in Section 3.2

and that, in addition, both map the location size to n. The idea isthat

Vn describes the set of values of type t, given that the currentstores satisfy

$n. Thus, when we extend the initial world W0 withan island
wsym governing Symbol's local state, we will choose that
wsym to comprise population V0, store relation $0, and a law Ldefined as

{($n, Vn) | n ) 0}. Here, V0 and $0 characterize theinitial world, in which there are no values of type

t and the sizeof the table is 0. The law
L describes what future populations andstore relations on this island may look like. In particular,

L enforcesthat future populations may contain 1 to
n (for any n), but only inconjunction with stores that map
size to n. (Of course, the initialpopulation and store relation must also obey the law, which they

do.) An island's law is established when the island is first added tothe world and may not be amended in future worlds.

Having extended the world W0 with this new island wsym, weare now able to define a relational interpretation for the type

t,namely: values
v1 and v2 are related at type t in world W if
v1 = v2 = m, where m belongs to the population of wsym in W .In proving equivalence of the two versions of the

lookup function,we can assume that we start with stores
s1 and s2 that are relatedby some world
W , where W is a future world of W0 ( wsym,and that the arguments to

lookup are related at type t in W .Consequently, given the law that we established for

wsym togetherwith the interpretation of
t, we know that the arguments to lookupmust both equal some
m, that the current population of wsym mustbe some
Vn, where 1 * m * n, and that the current store relationmust be
$n. Since s1 and s2 satisfy W , they must satisfy $n, whichmeans they map

size to n ) m. Hence, the dynamic range checkin the second version of

Symbol must evaluate to true.For the above relational interpretation of

t to make sense, weclearly need to be able to refer to a particular island in a world (e.g.,

wsym) by some unique identifier that works in all future worlds. Weachieve this by insisting that a world be an ordered list of islands,
and that new islands only be added to the end of the list. This allowsus to access islands by their position in the list, which stays the
same in future worlds.In addition, an important property of the logical relation, which
relational interpretations of abstract types must thus obey as well, isclosure under world extension, i.e., that if two values are related in
world W , then they are related in any future world of W . To ensureclosure under world extension for relations that depend on their
constituents' inhabitation of a particular island (such as the relationused above to interpret

t), we require that island populations canonly grow larger in future worlds, not smaller.

For expository purposes, we have motivated our populationtechnique with an example that is deliberately simple, in the sense
that the relational interpretation of t is completely dependent onthe current local state. That is, if we know that the current value of
!size is n, then we know without a doubt that the relational inter-pretation of

t in the current world must be {(1, 1), . . . , (n, n)}. InSection 5, we will see more complex examples in which the relational interpretation of t may depend not only on the current state,but also on the history of the program execution up to that point.
Our population techniques scales very nicely to handle such ex-amples because it allows us to control the evolution of an abstract
type's relational interpretation over time.
3.4 Mutable References to Higher-Order ValuesMost prior possible-worlds logical-relation approaches to reasoning about local state impose serious restrictions on what can bestored in memory. Pitts and Stark [21], for example, only allow
references to integers. Reddy and Yang [22] and Benton and Lep-erchey [7] additionally allow references to data, which include integers and pointers but not functions. In the present work, however,we would like to avoid any restrictions on the store.

4

To see what (we think) is tricky about handling references tohigher-order values, suppose we have two programs that both maintain some local state, and we are trying to prove these programsequivalent. Say the invariant on this local state, which we will enforce using an island w, is very simple: the value that the first pro-gram stores in location

l1 is logically related to the value that thesecond program stores in

l2. If these values were just integers, wecould write the law for
w (as we did in the Symbol example) sothat in any future world,

w's store relation $ must demand that twostores
s1 and s2 are related only if s1(l1) = s2(l2). This worksbecause at type

int, the logical relation coincides with equality.If the locations have some higher type

", however, the definitionof
w's store relation $ will need to relate s1(l1) and s2(l2) usingthe logical relation at type

", not mere syntactic equality. But theproblem is: logical relations are indexed by worlds. In order for

$to say that
s1(l1) and s2(l2) are related at type ", it needs to specifythe world
W in which their relation is being considered.Bohr and Birkedal [10] address this issue by imposing a rigid

structure on their store relations. Specifically, instead of having asingle store relation per island, they employ a local parameter,
which is roughly a set of pairs of the form (P, LL), where P isa store relation and

LL is a finite set of pairs of locations (togetherwith a closed type). The way to interpret this local parameter is that

the current stores must satisfy one of the P 's, and all the pairs oflocations in the corresponding

LL must be related by the logicalrelation in the current world. In the case of our example with

l1and
l2, they would define a local parameter {(P, LL)}, where Pis the universal store relation and

LL = {(l1, l2, " )}. Bohr andBirkedal's approach effectively uses the

LL's to abstract awayexplicit references to the world-indexed logical relation within the

store relation. This avoids the need to refer to a specific worldinside a store relation, but it only works for store relations that are
expressible in the highly stylized form of these local parameters.Instead, our approach is to parameterize store relations over the
world in which they will be considered. Then, in defining what itmeans for two stores

s1 and s2 to satisfy some world W , we requirethat for every
$ in W , (s1, s2) + $[W ], i.e., s1 and s2 obey $when it is instantiated to the current world

W . The astute readerwill have noticed, however, that this parameterization introduces a

circularity: worlds are defined to be collections of store relations,which are now parameterized by worlds. To break this circularity,
we employ step-indexed logical relations.

3.5 Step-Indexed Logical Relations and Possible WorldsAppel and McAllester [4] introduced the step-indexed model as
a way to express semantic type soundness proofs for languageswith general recursive and polymorphic types. Although its original motivation was tied to foundational proof-carrying code, thetechnique has proven useful in a variety of applications. In particular, Ahmed [1] has used a binary version of Appel and McAllester'smodel for relational reasoning about System F extended with general recursive types, and it is her work that we build on.The basic idea is closely related to classic constructions from
domain theory. We define the logical relation V !"" # as the limit ofan infinite chain of approximation relations

Vn!" " #, where n ) 0.Informally, values
v1 and v2 are related by the n-th approximationrelation only if they are indistinguishable in any context for

n stepsof computation. (They might be distinguishable after
n steps, butwe don't care because the "clock" has run out.) Thus, values are related in the limit only if they are indistinguishable in any context forany finite number of steps, i.e., if they are really indistinguishable.

The step-indexed stratification makes it possible to define thesemantics of recursive types quite easily. Two values

fold v1 and
fold v2 are defined to be related by Vn!u%. "" # iff v1 and v2 arerelated by

Vk![u%. " /%]" " # for all k < n. Even though the unfolded type is larger (usually a deal breaker for logical relations,which are typically defined by induction on types), the step index gets smaller, so the definition of the logical relation is well-founded. Moreover, it makes sense for the step index to get smaller,
since it takes a step of computation to extract vi from fold vi.Just as we use steps to stratify logical relations, we can also
use them to stratify our quasi-circular possible worlds. We definean "

n-level world" inductively to be one whose constituent storerelations (the

$'s) are parameterized by (n,1)-level worlds. Theintuition behind this stratification of worlds is actually very simple:

an n-level world describes properties of the current stores that mayaffect the relatedness of pairs of values for

n steps of computation.Since it takes one step of computation just to inspect the stores (via

a pointer dereference), the relatedness of pairs of values for n stepscan only possibly depend on the relatedness of the current stores
for n,1 steps. Thus, it is fine for an n-level world to be definedas a collection of (

n,1)-level store relations, i.e., $'s that onlyguarantee relatedness of memory contents for

n,1 steps. And these(
n,1)-level $'s, in turn, need only be parameterized by (n,1)-level worlds.

4. Step-Indexed Logical Relations for Fu!In this section, we present the details of our logical relation for

Fu!and prove it sound with respect to contextual equivalence.

The basic idea is to give a relational interpretation V !" " ofa (closed) type

" as a set of tuples of the form (k, W, v1, v2),where
k is a natural number (called the step index), W is a world(as motivated in Section 3), and

v1 and v2 are values. Informally,
(k, W, v1, v2) + V !" " says that in any computation running for nomore than

k steps, v1 approximates v2 at the type " in world W .An important point is that to determine if

v1 approximates v2 for ksteps (at type
"), it suffices for the world W to be a k-level world.That is, the store relations

$ in W need only guarantee relatednessof memory contents for
k ,1 steps, as discussed in Section 3.5. Wemake the notion of a "
k-level world" precise in Section 4.1.

Preliminaries In the rest of the paper, the metavariables i, j, k,
m, and n all range over natural numbers. We use the metavariable &to denote sets of tuples of the form

(k, W, e1, e2) where k is a stepindex,
W is a world, and e1 and e2 are closed terms (i.e., terms thatmay contain locations, but no free type or term variables). Given a

set & of this form, we write &val to denote the subset of & such that
e1 and e2 are values.As mentioned in Section 3.3, a world

W is an ordered list(written
&w1, . . . , wn') of islands. An island w is a pair of somecurrent knowledge

' and a law L. The knowledge ' for each islandrepresents the current "state" of the island. It comprises four parts: a

store relation $, which is a set of tuples of the form (k, W, s1, s2),where

k is a step index, W is a world, and s1, and s2 are stores;a population

V , which is a set of closed values; and two storetypings
#1 and #2. The domains of #1 and #2 give us the setsof locations that the island "cares about" (a notion we mentioned

in Section 3.2). Meanwhile, a law L is a set of pairs (k, '). If
(k, ') + L, it means that, at "time" k (representing the number ofsteps left on the clock), the knowledge

' represents an acceptablestate for the island to be in. Below we summarize our notation for

ease of reference.

Type Interpretation $ ::= {(k, W, e1, e2), . . . }Store Relation

% ::= {(k, W, s1, s2), . . . }Population
V ::= {v1, . . . }Knowledge

& ::= (%, V, $1, $2)Law
L ::= {(k, &), . . .}Island
w ::= (&, L)World
W ::= 'w1, . . . , wn(

5

CandAtomk def= {(j, W, e1, e2) | j < k 0 W * CandWorldj}

CandTypek def= P(CandAtomvalk )
CandStoreAtomk def= {(j, W, s1, s2) | j < k 0 W * CandWorldj}

CandStoreRelk def= P(CandStoreAtomk)
CandKnowledgek def= CandStoreRelk ! Population

! StoreTy ! StoreTy

CandLawAtomk def= {(j, &) | j & k 0 & * CandKnowledgej}

CandLawk def= P(CandLawAtomk)
CandIsland k def= CandKnowledgek ! CandLawk
CandWorldk def= {W * (CandIslandk)n | n 3 0}

CandAtom! def= Sk"0 CandAtomk

CandType! def= P(CandAtomval! ) 4 Sk"0 CandTypek

5$6k def= {(j, W, e1, e2) | j < k 0 (j, W, e1, e2) * $}
5%6k def= {(j, W, s1, s2) | j < k 0 (j, W, s1, s2) * %}

5&6k def= (5%6k, V, $1, $2) where & = (%, V, $1, $2)
5L6k def= {(j, &) | j & k 0 (j, &) * L}
5w6k def= (5&6k, 5L6k) where w = (&, L)
5W 6k def= '5w16k, . . . , 5wn6k( where W = 'w1, . . . , wn(

(%!, V !, $!1, $!2) 7 (%, V, $1, $2) def= V ! 4 V 0 $!1 4 $1 0 $!2 4 $2

(&!, L!) 7 (&, L) def= &! 7 & 0 L! = L
'w!1, . . . , w!n+m( 7 'w1, . . . , wn( def= m 3 0 0 #i * {1, . . . , n}. w!i 7 wi

(j, W !) 7 (k, W ) def= j & k 0 W ! 7 5W 6j 0 W ! * W orldj 0 W * W orldk
(j, W !) ! (k, W ) def= j < k 0 (j, W !) 7 (k, W )

Atom[!1, !2]k def= {(j, W, e1, e2) * CandAtomk | W * Worldj 0 $1(W ) - e1 : !1 0 $2(W ) - e2 : !2}

Type[!1, !2]k def= {$ * P(Atom[!1, !2]valk ) | #(j, W, v1, v2) * $. #(j!, W !) 7 (j, W ). (j!, W !, v1, v2) * $}

StoreAtomk def= {(j, W, s1, s2) * CandStoreAtomk | W * Worldj}

StoreRelk def= {% * P(StoreAtomk) | #(j, W, s1, s2) * %. #(i, W !) 7 (j, W ). (i, W !, s1, s2) * %}
Knowledgek def= {(%, V, $1, $2) * CandKnowledgek | % * StoreRelk 0

#s1, s2, s!1, s!2.

( #l * dom($1). s1(l) = s!1(l) 0 #l * dom($2). s2(l) = s!2(l) ) =/
#j, W. (j, W, s1, s2) * % 8/ (j, W, s!1, s!2) * %}

LawAtomk def= {(j, &) * CandLawAtomk | & * Knowledgej}

Lawk def= {L * P(LawAtomk) | #(j, &) * L. #i < j. (i, 5&6i) * L}
Islandk def= {(&, L) * Knowledgek ! Lawk | (k, &) * L}
Worldk def= {W * (Islandk)n | n 3 0 0

#a, b * {1, . . . , n}. a += b =/

dom(W [a].$1) # dom(W [b].$1) 0 dom(W [a].$2) # dom(W [b].$2)}

Atom[!1, !2] def= Sk"0 Atom[!1, !2]k

Type[!1, !2] def= {$ * CandType! | #k 3 0. 5$6k * Type[!1, !2]k} 4 Sk"0 Type[!1, !2]k

Figure 3. Auxiliary Definitions: Candidate Sets, k-Approximation, World Extension, and Well-Formedness Conditions

If W = &w1, . . . , wn' and 1 * j * n, we write W [j] as shorthandfor

wj. If w = ('i, Li) where 'i = ($i, Vi, #i1, #i2), we use thefollowing shorthand to extract various elements out of the island

w:

w.& 9 &i
w.L 9 Li
w.% 9 %i

w.V 9 Vi
w.$1 9 $i1
w.$2 9 $i2

If W is a world with n islands, we also use the following shorthand:

$1(W ) def= S1#j#n W [j].$1
$2(W ) def= S1#j#n W [j].$2

We write Val for the set of all values, Store for the set of all stores(finite maps from locations to values), and

StoreTy for the set ofstore typings (finite maps from locations to closed types). We write

Population for the set of all subsets of Val. Finally, we write
S1 # S2 to denote that the sets S1 and S2 are disjoint.

4.1 Well-Founded, Well-Formed Worlds and RelationsNotice that we cannot na"ively construct a set-theoretic model based
on the above intentions since the worlds we wish to construct are(effectively) lists of store relations and store relations are themselves parameterized by worlds (as discussed in Section 3.4). If weignore islands, laws, populations, and store typings for the moment,
and simply model worlds as lists of store relations, we are led to thefollowing specification which captures the essence of the problem:

StoreRel = P(N ! World ! Store ! Store)
World = StoreRelnA simple diagonalization argument shows that the set

StoreRelhas an inconsistent cardinality (i.e., it is an ill-founded recursive

definition).We eliminate the inconsistency by stratifying our definition via
the step index. To do so, we first construct candidate sets, whichare well-founded sets of our intended form. We then construct
proper notions of worlds, islands, laws, store relations, and so

6

on, by filtering the candidate sets through some additional well-formedness constraints.

Figure 3 (top left) defines our candidate sets by induction on k.First, note that elements of

CandAtomk and CandStoreAtomkare tuples with step index
j strictly less than k. Hence, our can-didate sets are well-defined at all steps. Next, note that elements

of CandLawAtomk are tuples with step index j * k. Informally,this is because a

k-level law should be able to govern the currentknowledge (i.e., the knowledge at the present time when we have

ksteps left to execute), not just the knowledge in the future when we

have strictly fewer steps left.While our candidate sets establish the existence of sets of our
intended form, our worlds and type relations will need to be well-behaved in other ways. There are key constraints associated with
atoms, types, store relations, knowledge, laws, islands, and worldsthat will be enforced in our final definitions. To specify these
constraints we need some additional functions and predicates.For any set

& and any set $, we define the k-approximation ofthe set (written

-&.k and -$.k, respectively) as the subset of itselements whose indices are strictly less than

k (see Figure 3, topright). Meanwhile, for any set
L, we define the k-approximationof the set (written
-L.k) as the subset of its elements whose in-dices are less than or equal to

k. We extend these k-approximationnotions to knowledge
', islands w, and worlds W (written -'.k,
-w.k, and -W .k, respectively) by applying k-approximation totheir constituent parts. Note that each of the

k-approximation func-tions yields elements of
CandX k where X denotes the appropriatesemantic object.

Next, we define the notion of world extension (see Figure 3,middle). We write

(j, W !) / (k, W ) (where / is pronounced"extends") if
W is a world that is good for k steps (i.e., W +
Worldk, see below), W ! is a good world for j * k steps (W ! +
Worldj), and W ! extends -W .j (written W ! / -W .j). Recallfrom Section 3.3 that future worlds accessible from

W may havenew islands added to the end of the list. Furthermore, for each

island w + -W .j, the island w! in the same position in W ! mustextend

w. Here we require that w!.L = w.L since an island's lawcannot be amended in future worlds (see Section 3.3). We also

require that w!.' / w.', which says that the island's populationmay grow (

w!.V 0 w.V ), as may the sets of locations that theisland cares about (

w!.#1 0 w.#1 and w!.#2 0 w.#2). Though itmay seem from the definition of knowledge extension in Figure 3

that we do not impose any constraints on w!.$, this is not the case.As explained in Section 3.3, an island's law should govern what the
island's future store relations, populations, and locations of concernmay look like. The requirement

W ! + Worldj (which we discussbelow) ensures that the future knowledge

w!.' obeys the law w!.L.Figure 3 (bottom) defines our various semantic objects, again by

induction on k. These definitions serve to filter their correspondingcandidate sets. We proceed now to discuss each of these filtering
constraints.Following Pitts [20], our model is built from syntactically welltyped terms. Thus, we define Atom["1, "2]k as the set of tuples
(j, W, e1, e2) where #1(W ) ! e1 : "1 and #2(W ) ! e2 : "2, and
j < k. (Recall that #i(W ) denotes the "global" store typing--i.e.,the union of the

#i components of all the islands in W .) We alsorequire the world

W to be a member of Worldj.We define
Type["1, "2]k as those sets & # Atom["1, "2]valkthat are closed under world extension. Informally, if

v1 and v2 arerelated for
k steps in world W , then v1 and v2 should also be relatedfor
j steps in any future world W ! such that (j, W !) is accessiblefrom (i.e., extends)

(k, W ). We define StoreRel k as the set of all
$ # StoreAtomk # CandStoreAtomk that are closed underworld extension. This property is critical in ensuring that we can

extend a world with new islands without fear of breaking the storeproperties from the old islands.

Knowledgek is the set of all tuples of the form ($, V, #1, #2) +
CandKnowledgek such that $ + StoreRel k. As mentionedabove, the domains of

#1 and #2 contain the locations that anisland cares about. What this means is that when determining

whether two stores s1 and s2 belong to the store relation $, wecannot depend upon the contents of any location in store

s1 thatis not in
dom(#1) or on the contents of any location in s2 that isnot in
dom(#2). Thus, #1 and #2 essentially serve as accessibilitymaps [7]. While Benton and Leperchey's accessibility maps are

functions from stores to subsets of Loc, our accessibility maps areessentially sets of locations that are allowed to grow over time.

We define Lawk as the set of laws L such that for all (j, ') + Lwe have that

' + Knowledgej. Furthermore, we require that thesets
L be closed under decreasing step index--that is, if someknowledge

' obeys law L for j steps, then it must be the case that atany future time, when we have

i < j steps left, the i-approximationof knowledge
' still obeys the law L.
Islandk is the set of all pairs (', L) + (Knowledgek 1 Lawk)such that the knowledge

' obeys the law L at the current timedenoted by step index
k -- i.e., (k, ') + L.Finally, we define
Worldk as the set of all W + (Islandk)n.We also require that the sets of locations that each island

W [a]cares about are disjoint from the sets of locations that any other

island W [b] cares about, thus ensuring separation of islands.
4.2 Relational Interpretations of TypesFigure 4 (top) gives the definition of our logical relations for

Fu!.The relations
Vn!"" # are defined by induction on n and nestedinduction on the type

". We use the metavariable # to denotetype substitutions. A type substitution

# is a finite map from typevariables
% to triples (&, "1, "2) where "1 and "2 are closed types,and
& is a relational interpretation in Type["1, "2]. If #(%) =
(&, "1, "2), then #1(%) denotes "1 and #2(%) denotes "2.Note that, by the definition of

Vn!" " #, if (k, W, v1, v2) +
Vn!" " #, then k < n, W + Worldk, and #1(W ) ! v1 : #1(" )and

#2(W ) ! v2 : #2("). Most of the relations Vn!" " # arestraightforward. For instance, the logical relation at type

int saysthat two integers are logically related for any number of steps

kand in any world
W as long as they are equal. The relations for theother base types
unit and bool are similar. The logical relation attype
" 1 " ! says that two pairs of values are related for k steps inworld

W if their first and second components are related (each for
k steps in world W ) at types " and "! respectively.Since functions are suspended computations, their relatedness

is defined based on the relatedness of computations (character-ized by the relation

En!"" #, discussed below). Two functions
!x : #1(" ). e1 and !x : #2(" ). e2 are related for k steps in world
W at the type " 2 " ! if, in any future world W ! where there are
j < k steps left to execute and we have arguments v1 and v2 thatare related at the argument type

", the computations [v1/x]e1 and
[v2/x]e2 are also related for j steps in world W ! at the result type
" ! (i.e., they are in the relation En!" !" #). Intuitively, j < k sufficessince beta-reduction consumes a step. Parameterizing over an arbitrary future world W ! is necessary here in order to ensure closureof the logical relation under world extension.

Before we can specify when two computations are related, wehave to describe what it means for two stores to be related. We
write s1, s2 :k W , denoting that the stores s1 and s2 are relatedfor

k steps at the world W (see Figure 4, top), if the stores arewell-typed with respect to the store typings

#1(W ) and #2(W ),respectively, and if the stores are considered acceptable by--i.e.,

they are in the store relations of--all the islands in W at all futuretimes when

j < k.

7

s1, s2 :k W def= - s1 : $1(W ) 0 - s2 : $2(W ) 0

#w * W. #j < k. (j, 5W 6j, s1, s2) * w.%

Vn!!" ' = Vn!!" ' : Atom['1(!), '2(!)]valn
Vn!"" ' = $ where '(") = ($, !1, !2)
Vn!unit" ' = {(k, W, (), ())}

Vn!int" ' = {(k, W, v, v) | v * Z}
Vn!bool" ' = {(k, W, v, v) | v = true ; v = false}
Vn!! ! !!" ' = {(k, W, 'v1, v!1(, 'v2, v!2() |

(k, W, v1, v2) * Vn!!" ' 0
(k, W, v!1, v!2) * Vn!!!" '}

Vn!! " !!" ' = {(k, W, #x : '1(!). e1, #x : '2(!). e2) |

#(j, W !) ! (k, W ). #v1, v2.

(j, W !, v1, v2) * Vn!!" ' =/
(j, W !, [v1/x]e1, [v2/x]e2) * En!!!" '}

Vn!#". !" ' = {(k, W, !". e1, !". e2) |

#(j, W !) ! (k, W ). #!1, !2, $ * Type[!1, !2].

(j, W !, [!1/"]e1,

[!2/"]e2) * En!!" '[" )" ($, !1, !2)]}

Vn!$". !" ' = {(k, W, pack !1, v1 as $". '1(!),

pack !2, v2 as $". '2(!)) |
$$ * Type[!1, !2].

(k, W, v1, v2) * Vn!!" '[" )" ($, !1, !2)]}

Vn!u". !" ' = {(k, W, fold v1, fold v2) | k < n 0

#j < k. (j, 5W 6j, v1, v2) * Vk![u". !/"]!" '}

Vn!ref !" ' = {(k, W, l1, l2) | k < n 0 wref(k, ', !, l1, l2) * W }
wref(k, ', !, l1, l2) = (&, L)where

& = (%, {}, {l1 : '1(!)}, {l2 : '2(!)})
% = {(j, W !, s1, s2) | (j, W !, s1(l1), s2(l2)) * Vk!!" '}
L = {(j, 5&6j) | j & k}

En!!" ' = {(k, W, e1, e2) * Atom['1(!), '2(!)]n |

#j < k. #s1, s2, s!1, v1.

s1, e1 )%"j s!1, v1 0 s1, s2 :k W =/
$s!2, v2, W !. (k % j, W !) 7 (k, W ) 0

s2, e2 )%"$ s!2, v2 0 s!1, s!2 :k%j W ! 0
(k % j, W !, v1, v2) * Vn!!" '}

V !!" ' = Sn"0 Vn!!" ' E !!" ' = Sn"0 En!!" '

D !*" = {,}
D !", "" = {'[" )" ($, !1, !2)] | ' * D !"" 0 $ * Type[!1, !2]}

G !*" ' = {(k, W, ,) | W * Worldk}
G !#, x : !" ' = {(k, W, ([x )" (v1, v2)]) |

(k, W, () * G !#" ' 0 (k, W, v1, v2) * V !!" '}

S !$" = {(k, W ) | #(l : !) * $. (k, W, l, l) * V !ref !" ,}

"; #; $ - e1 .log e2 : ! def= "; #; $ - e1 : ! 0 "; #; $ - e2 : ! 0

#k 3 0. #', (, W. ' * D !"" 0 (k, W, () * G !#" ' 0

(k, W ) * S !$" =/
(k, W, '1((1(e1)), '2((2(e2))) * E !!" '

"; #; $ - e1 2log e2 : ! def= "; #; $ - e1 .log e2 : ! 0

"; #; $ - e2 .log e1 : !

Figure 4. Step-Indexed Logical Relations for Fu!

The relation En!" " # specifies when two computations are logi-cally related. Two closed, well-typed terms

e1 and e2 are related for
k steps at the type " in world W if, given two initial stores s1 and s2that are related for

k steps at world W , if s1, e1 evaluates to s!1, v1in
j < k steps then the following conditions hold. First, s2, e2 mustevaluate to some

s!2, v2 in any number of steps. (For details on whythe number of steps

e2 takes is irrelevant, see Ahmed [1].) Second,there must exist a world

W ! + Worldk%j that extends the world
W . Third, the final stores s!1 and s!2 must be related for the remain-ing

k , j steps at world W !. Fourth, the values v1 and v2 must berelated for

k , j steps in the world W ! at the type ". Notice theasymmetric nature of the relation on computations: if

s1, e1 termi-nates, then
s2, e2 must also terminate. Hence, our relations Vn!"" #model logical approximation rather than logical equivalence.

The cases of the logical relation for 3%." and 4%." are essen-tially standard. The former involves parameterizing over an arbitrary relational interpretation & of %, and the latter involves choos-ing an arbitrary relational interpretation

& of %. The way the worldsare manipulated follows in the style of the other rules. The logical

relation for u%." is very similar to previous step-indexed accountsof recursive types, as described in Section 3.5. (Note that, although
the type gets larger on the r.h.s. of the definition, the step index getssmaller, so the definition is well-founded.)

Any two locations related at a type ref " are publicly accessiblereferences. For reasoning about such visible locations, existing logical relations methods usually employ some mechanism that is dis-tinct from the machinery used to reason about local or hidden state.
Since there always exists a bijection between the visible locationsof the two computations, the mechanism usually involves having a
special portion of the world that tracks the bijection between visi-ble locations as well as the type

" of their contents. Unlike previousmethods, our worlds have no specialized machinery for reasoning

about visible locations. Our technique for modeling (publicly ac-cessible) references is simply a mode of use of our mechanism for
reasoning about local state.Intuitively, two locations

l1 and l2 should be related at the type
ref " in world W for k steps if, given any two stores s1 and s2 thatare related for

k steps at world W , the contents of these locations,i.e.,
s1(l1) and s2(l2), are related for k , 1 steps at the type ".To enforce this requirement, we simply install a special island

wrefthat only cares about the one location
l1 in s1 and the one location
l2 in s2. Furthermore, wref has an empty population and a law thatsays the population should remain empty in future worlds. Finally,

the island's fixed store relation $ relates all stores s1 and s2 whosecontents at locations

l1 and l2, respectively, are related at type "for
j < k steps. Here j < k suffices since pointer dereferencingconsumes a step (see Section 3.5).

The definitions of logical approximation and equivalence foropen terms are given at the bottom of Figure 4. These definitions
rely on the relational semantics ascribed to the contexts !, ", #,which we discuss next.

We say a type substitution # belongs to the relational interpreta-tion of

! if dom(#) = !, and whenever #(%) = (&, "1, "2), & isa well-formed relational interpretation (i.e.,

& + Type["1, "2]).We let the metavariable
( range of relational value substitutions.These are finite maps from term variables

x to pairs of values
(v1, v2). If ((x) = (v1, v2), then (1(x) denotes v1 and (2(x)denotes

v2. We say ( belongs to the relational interpretation of
" for k steps at world W (written (k, W, () + G !"" #, where
FTV (") # dom(#)), if dom(() = dom("), and the values
(1(x) and (2(x) are related for k steps in world W at type "(x).We say a world

W satisfies a store typing # for k steps(written
(k, W ) + S !#") if W contains an island of the form
wref(k, 5, ", l, l) for each (l : ") + #--i.e., if l is related to itselffor

k steps in world W at type ref ".

8

We write !; "; # ! e1 $log e2 : " (pronounced "e1 logicallyapproximates

e2") to mean that for all k, given a type substitu-tion
# + D !!" and a relational value substitution ( such that
(k, W, () + G !"" #, where the world W satisfies # for k steps,the closed terms

#1((1(e1)) and #2((2(e2)) are related for k stepsin world
W at the type " . Finally, we say e1 and e2 are logicallyequivalent, written

!; "; # ! e1 %log e2 : " , if they logically ap-proximate each other.

4.3 Fundamental Property & Soundness of Logical RelationHere we state some of the main properties of our logical relation
and sketch interesting aspects of the proofs. Further details of themeta-theory are given in the online technical appendix [3].
Lemma 4.1 (Closure Under World Extension)Let

! ! " and # + D !!". If (k, W, v1, v2) + Vn!" " # and
(j, W !) / (k, W ), then (j, W !, v1, v2) + Vn!" " #.Proof: By induction on

n and nested induction on ! ! " . !An important property of logical approximation is that it is a

precongruence, i.e., it is compatible with all the constructs of thelanguage (see e.g., Pitts [20]). We state these compatibility lemmas,
and give detailed proofs of the ones involving references, in theonline technical appendix [3]. The most involved cases are those for
allocation (ref) and assignment, which we discuss below. Proofsof compatibility lemmas that do not involve references essentially
follow the proofs given in Ahmed [1]--although we must now dealwith additional hypotheses and goals involving stores and worlds,
this does not complicate the proofs in any fundamental way.The compatibility property for

ref says that if !; "; # !
e1 $log e2 : " then !; "; # ! ref e1 $log ref e2 : ref ". In theproof, we find ourselves at a point where we have stores

s1, s2 :k Wand we allocate locations
l1 /+ dom(s1) and l2 /+ dom(s2) tohold the values
v1 and v2 respectively (where we know that
(k, W, v1, v2) + V !" " #). To proceed, we define a new world
W ! + Worldk%1, which is just -W .k%1 extended with a newisland

wref(k , 1, #, ", l1, l2). In addition to showing that W ! is avalid world, which is straightforward, we must also show that (1)

(k , 1, W !) / (k, W ) and (2) s1[l1 62 v1], s2[l2 62 v2] :k%1 W !.For (1) we need to show that

l1 and l2 are distinct from locationsthat any island
w + W "cares about"--that is, l1 /+ dom(#1(W ))and
l2 /+ dom(#2(W )), which follows easily since l1 and l2 arefresh for

s1 and s2. For (2) we must show that for all w! + W !,and
j < k , 1, (j, -W !.j, s1[l1 62 v1], s2[l2 62 v2]) + w!.$. If
w! is the new island wref(k , 1, #, ", l1, l2), then the desired resultfollows from the knowledge that

v1 and v2 are logically related. If
w! is any other island, it must be the (k,1)-th approximation ofsome island

w + W . In this case, the desired result follows fromclosure of
w.$ under world extension, together with the fact that siand
si[li 62 vi] are identical when restricted to the domain w.#i.The proof of the compatibility lemma for assignment is quite

similar to that for ref, except that we do not add a new is-land to

W since we know that W already contains an island
wref(k, #, ", l1, l2) where l1 and l2 are the locations being updated.Theorem 4.2 (Fundamental Property)

If !; "; # ! e : " then !; "; # ! e $log e : " .Proof: By induction on the derivation of

!; "; # ! e : " . Eachcase follows from the corresponding compatibility lemma.

!Soundness To show that the logical relation is sound with respect

to contextual approximation, we need an additional property wecall store parametricity. This property says that if

! s : # and W +
Worldk is a world comprising one wref island for each location in
#--i.e., if # = {l1 : "1, . . . , ln : "n} and W = &w1, . . . , wn',where each

wi = wref(k, 5, "i, li, li))--then s, s :k W .

Notice that, to prove store parametricity, we need to show thatfor each

(li : "i) + #, the value stored at location li in store s isrelated to itself at the type

"i (i.e., (k, W, s(li), s(li)) + V !"i" 5).Unfortunately, the latter does not follow from the Fundamental

Property, which only allows us to conclude from *; *; # ! s(li) : "ithat

(k, W, s(li), s(li)) + E !"i" 5.What we need is the notion of logical value approximation,

!; "; # ! v1 $logval v2 : " , which we define exactly as !; "; # !
v1 $log v2 : " except that the E !" " # at the end of that definitionis replaced with

V !" " #. Now we can prove that any well-typedvalue is related to itself in the appropriate value relation

V !" " #,not just in the computation relation
E !"" # as established by theFundamental Property. Specifically, we show that

!; "; # ! v : "implies
!; "; # ! v $logval v : " . (The proof is by induction on
!; "; # ! v : " and for each case the proof is similar to that ofthe corresponding compatibility lemma.) With this lemma in hand,

store parametricity follows easily.Theorem 4.3 (Soundness w.r.t. Contextual Approximation)

If !; "; # ! e1 $log e2 : " then !; "; # ! e1 $ctx e2 : ".Proof: Suppose

! C : (!; "; # ! " ) " (*; *; #! ! " !), ! s : #!,and
s, C[e1] 6,2k s1, v1. We must show that s, C[e2] 7.If

# = {l1 : "1, . . . , ln : "n}, let W = &w1, . . . , wn', whereeach
wi = wref(k + 1, 5, "i, li, li). By the compatibility lemmas,we can show

*; *; #! ! C[e1] $log C[e2] : " !. Hence, noting that
(k+1, W ) + S !#!", we have (k+1, W, C[e1], C[e2]) + E !"!" 5.Since

s, s :k+1 W (by store parametricity) and s, C[e1] 6,2k
s1, v1 (from the premise), it follows that s, C[e2] 7. !

5. ExamplesIn this section we present a number of examples demonstrating
applications of our method. Our examples do not make use ofrecursive types (or even recursion), but Ahmed's prior work, which
we build on, gives several examples that do [1]. We will walkthrough the proof for the first example in detail. For the remaining
ones, we only sketch the central ideas, mainly by giving suitableisland definitions and type interpretations. Full proofs for these
examples and others appear in the online technical appendix [3].
5.1 Name GeneratorOur first example is perhaps the simplest possible state-dependent

ADT, a generator for fresh names. Nevertheless, it captures theessence of the

Symbol example from the introduction:

e = let x = ref 0 in

pack int, &!z : unit. (++x), !z : int. (z * !x)' as )where

) = 4%. (unit 2 %) 1 (% 2 bool) and (++x) abbreviatesthe expression

(x := !x+1; !x), and let is encoded in the standardway (using function application). The package defines an abstract

type % of names and provides two operations: the first one returnsa fresh name on each invocation, and the second one checks that
any value of type % it is given is a "valid" name, i.e., one that waspreviously generated by the first operation.

Names are represented as integers, and the local counter xstores the highest value that has been used so far. The intended
invariant of this implementation is that no value of type % ever hasa representation that is greater than the current content of

x. Underthis invariant, we should be able to prove that the second operation,

which dynamically checks this property, always returns true.To prove this, we show that

e is equivalent to a second expres-sion
e!, identical to e, except that the dynamic check (z * !x) iseliminated and replaced by

true. We only show the one direction,
! e $log e! : ). The other direction is proven analogously.

9

Because the terms are closed, this only requires showing that
(k0, W0, e, e!) + E !)" 5 for all k0 ) 0 and worlds W0. Assumestores

s0, s!0 :k0 W0 and the existence of a reduction sequence
s0, e 6,2k1 s1, v1 with k1 < k0. According to the definition of
E !)" 5, we need to come up with a reduction s!0, e! 6,2$ s!1, v!1and a world

W1 such that (k0 , k1, W1) / (k0, W0) and:

s1, s!1 :k0%k1 W1 8 (k0 , k1, W1, v1, v!1) + V !)" 5By inspecting the definition of reduction, we see that

s1 = s0[l 62 0], v1 = pack int, &!z.(++l), !z.(z * !l)' as )for some

l /+ dom(s0). In the same manner, s!0, e! obviously canchoose some

l! /+ dom(s!0) and reduce to:

s!1 = s!0[l! 62 0], v!1 = pack int, &!z.(++l!), !z.true' as )We now need to define a suitable island that enables us to show

that v1 and v!1 are related. We know W0 has the form &w1, . . . , wp'for some

p. Let W1 be -W0.k0%k1, extended with a new island,
wp+1, defined as follows:

wp+1 = ('0k0%k1, Lk0%k1)

'nk = ($nk , Vn, {l : int}, {l! : int})
$nk = {(j, W, s, s!) + StoreAtomk | s(l) = s!(l!) = n}

Vn = {i | 1 * i * n}
Lk = {(j, 'nj ) + LawAtomk | n + N}The population

Vn consists of all integers that are "valid" names inthe current world, i.e., not greater than the current value of

x. Wehave to show
(k0 , k1, W1) / (k0, W0) and s1, s!1 :k0%k1 W1.Both are straightforward.

By definition of V !4%."", we need to continue by giving arelation

&" + Type[int, int], such that:

(k0 , k1, W1, &!z.(++l), !z.(z * !l)', &!z.(++l!), !z.true')

+ V !(unit 2 %) 1 (% 2 bool)" #with

# = [% 62 (&", int, int)]. We choose the following one:

&" = {(j, W, i, i) + Atom[int, int] | i + W [p + 1].V }This interpretation of

% depends on the (valid) assumption thatit will only be considered at

W 's that are future worlds of W1(in particular, it assumes that the (

p+1)-th island in W , written
W [p + 1], is a future version of the wp+1 we defined above). Wecould build this assumption explicitly into the definition of

&", butas we will see it is simply not necessary to do so. By virtue of this

assumption, a value i is only a valid inhabitant of type % in worldswhose (

p+1)-th island population contains i, that is, where !l ) i.Note that the relation is closed under world extension because

Vmay only grow over time, as explained in Section 3.3.

By definition of V !" 1 " !", it remains to be shown that:1.

(k0 , k1, W1, !z.(++l), !z.(++l!)) + V !unit 2 %" #2.
(k0 , k1, W1, !z.(z * !l), !z.true) + V !% 2 bool" #For each of these, we assume we begin in some strictly future world

W2 in which (k2, W2) " (k0 , k1, W1) and s2, s!2 :k2 W2.First consider (1). We are given

s2, (++l) 6,2k3 s3, v3 forsome
k3 < k2, and it remains to show that s!2, (++l!) 6,2$ s!3, v!3,such that

s3, s!3 and v3, v!3 are related in some future world W3 suchthat
(k2 , k3, W3) / (k2, W2).From

(k2, W2) / (k0 , k1, W1) we know that W2[p + 1].L =
-W1[p + 1].L.k2 = Lk2. From that (k2, W2[p + 1].') + Lk2follows, and hence there exists

n such that W2[p+1].' = 'nk2. Thatis,
W2[p+1].$ = $nk2 and W2[p+1].V = Vn. From s2, s!2 :k2 W2and

k3 < k2 we can conclude (k3, -W2.k3, s2, s!2) + $nk2 andthus

s2(l) = s!2(l!) = n. Consequently, v3 = v!3 = n + 1,
s3 = s2[l 62 n + 1], and s!3 = s!2[l! 62 n + 1].

Now we choose W3 to be -W2.k2%k3 with its (p + 1)-th islandupdated to

('n+1k

2%k3 , Lk2%k3 ). Again, we have to check the relevantproperties, (k

2 , k3, W3) / (k2, W2) and s3, s!3 :k2%k3 W3,which are straightforward. Last, we have to show that the results

v3, v!3 are related in V !%" # under this world, i.e., (k2,k3, W3, n+
1, n + 1) + &". Since n + 1 + Vn+1 = W3[p + 1].V , this isimmediate from the definition of

&".Now consider (2). The proof is similar to that for part (1), but

simpler. We are given that (k2, W2, v2, v!2) + V !%" # = &", and
s2, (v2 * !l) 6,2k3 s3, v3 for some k3 < k2. The main thing toshow is that

v3 = true (we can pick the end world W3 to just be
-W2.k2%k3). As in part (1), we can reason that W2[p + 1].' = 'nk2for some

n, and therefore that s2(l) = n and, by definition of &",also that
v2 * n. Hence, v2 * s2(l), and the desired result followseasily.

5.2 Using ref As a Name GeneratorAn alternative way to implement a name generator is to represent
names by locations and rely on generativity of the ref operator.
e = pack ref unit, &!z : unit. (ref ()),

!p : (ref unit1ref unit). (fst p == snd p)' as )where

) = 4%. (unit 2 %) 1 (% 1 % 2 bool). Here, the secondfunction implements a proper equality operator on names. We want

to prove this implementation contextually equivalent to one usingintegers, as in the previous example:

e! = let x = ref 0 in

pack int, &!z : unit. (++x),

!p : (int 1 int). (fst p = snd p)' as )Here are a suitable island definition and type interpretation for

%:

wp+1 = ('&'k

0 , Lk0)'&l

1,...,ln'
k = ($

n
k , V&l1,...,ln', {li : unit | 1 * i * n}, {l! : int})$n

k = {(j, W, s, s!) + StoreAtomk | s!(l!) = n}V
&l1,...,ln' = {&li, i' | 1 * i * n}

Lk = {(j, '&l1,...,l

n'

j ) + LawAtomk | n + N}&

" = {(j, W, l, i) + Atom[ref unit, int] |&l, i' + W [p + 1].V }

Here, and in the examples that follow, k0 represents the currentstep level, and

p the number of islands in the current world W0, atthe point in the proof where we extend

W0 with the island wp+1governing the example's local state. In this example, we assume

that all labels in a list &l1, . . . , ln' are pairwise disjoint, and l! isa distinguished label, namely the one that has been allocated for

x(as in the previous example).

In the definitions above, the population not only records thevalid names for

e! (as in Section 5.1), but also relates them to thelocations allocated by

e. The latter are not guessable ahead of time,due to nondeterminism of memory allocation, but the law

Lk isflexible enough to permit any partial bijection between
{1, . . . , n}and
Loc to evolve over time. We (ab)use term-level pairs &l, i' toencode this partial bijection in

V . This is sufficient to deduce i = jiff
li = lj when proving equivalence of the equality operators.

5.3 Twin AbstractionAnother interesting variation on the generator theme involves the

definition of two abstract types (we write pack "1, "2, e as 4%, *."to abbreviate two nested existentials in the obvious way):

e = let x = ref 0 in

pack int, int, &!z : unit. (++x),

!z : unit. (++x),
!p : (int 1 int). (fst p = snd p)' as )

10

where ) = 4%, *. (unit 2 %) 1 (unit 2 *) 1 (% 1 * 2 bool).Here we use a single counter to generate names of two types,
% and *, and a comparison operator that takes as input namesof different type. Because both types share the same counter, it
appears impossible for a name to belong to both types (either it wasgenerated as a name of type

% or of type * but not of both). Theexample is interesting, however, in that we have no way of knowing

the interpretations of % and * ahead of time, since calls to the namegeneration functions can happen in arbitrary combinations. We can
verify our intuition by proving that e is equivalent to an e! wherethe comparison operator is replaced by

!p : (int 1 int). false.The following
w and & definitions enable such a proof:

wp+1 = ('0,(k

0 , Lk0)'n,S

k = ($

n
k , Vn,S, {l : int}, {l! : int})$n

k = {(j, W, s, s!) + StoreAtomk | s(l) = s!(l!) = n}V
n,S = {&1, i' | i + S} 9 {&2, i' | i + {1, . . . , n} \ S}

Lk = {(j, 'n,Sj ) + LawAtomk | n + N 8 S # {1, . . . , n}}
&" = {(j, W, i, i) + Atom[int, int] | &1, i' + W [p + 1].V }

&# = {(j, W, i, i) + Atom[int, int] | &2, i' + W [p + 1].V }The population here is partitioned into the valid names for

% andthe valid names for
*, basically recording the history of calls to thetwo generator functions. To encode such a disjoint union in

V , eachvalue is wrapped in a pair with the first component marking the type

it belongs to (1 for %, 2 for *). When proving equivalence of the twocomparison operators, the definitions of

&", &# and W [p + 1].Vdirectly imply that the arguments must be from disjoint sets.

5.4 Cell ClassThe next example is a more richly-typed variation of the higherorder cell object example of Koutavas and Wand [13]:

e = $%. pack ref %, &!x : %. ref x,

!r : ref %. !r,
!&r, x' : ref % 1 %. (r := x)' as )where

) = 4*. (% 2 *) 1 (* 2 %) 1 (* 1 % 2 unit). Weuse pattern matching notation here merely for clarity and brevity

(imagine replacing occurrences of r and x in the third function with
fst and snd projections, respectively, of the argument).This example generalizes Koutavas and Wand's original version

in two ways. First, we parameterize over the cell content type %,which can of course be instantiated with an arbitrary higher type,
thus exercising our ability to handle higher-order stored values.Second, instead of just implementing a single object, our example
actually models a class, where * represents the abstract class type,and the first function acts as a constructor for creating new cell objects. (A subsequent paper by Koutavas and Wand also considers aclass-based version of their original example [14], but it is modeled
with a Java-like nominal type system, not with existential types.)Similar to [13], we want to prove this canonical cell implementation equivalent to one using two alternating slots:
e! = $%. pack (ref int 1 (ref % 1 ref %)),

&!x : %. &ref 1, &ref x, ref x'',

!&r0, &r1, r2'' : (ref int 1 (ref % 1 ref %)).

if !r0 = 1 then !r1 else !r2,
!&&r0, &r1, r2'', x' : (ref int 1 (ref % 1 ref %)) 1 %.

if !r0 = 1 then (r0 := 2; r2 := x)

else (r0 := 1; r1 := x)' as )When

e or e! is instantiated with a type argument, neither oneimmediately allocates any new state. Correspondingly, no island is

introduced at that point in the proof. Rather, a new island is addedto the world at each call to the classes' constructor functions, for it
is at that point when fresh state is allocated in both programs.

So, assuming we have been given a relational interpretation
&" + Type["", " !"] for the type parameter %, consider the proofthat the constructor functions are logically related. When the constructors are called, we allocate fresh state: l in the first program,and

&l!0, &l!1, l!2'' in the second program. For convenience, we willpackage these together notationally as

ls = &l, &l!0, &l!1, l!2'''. Wenow extend the current world
W with wp+1, defined as follows:

wp+1 = ('lsk0, Llsk0)

'lsk = ($lsk , {ls}, {l : ""}, {l!0 : int, l!1 : "!", l!2 : "!"})
$lsk = {(j, W, s, s!) + StoreAtomk |

4i + {1, 2}. s!(l!0) = i 8 (j, W, s(l), s!(l!i)) + &"}
Llsk = {(j, 'lsj ) | j * k}The store relation

$lsk ensures that the contents of l are related (by
&") to the contents of the proper slot l!1 or l!2, depending on thecurrent flag value stored in

l!0. Note how the definition of $lsk reliescrucially on the presence of the world parameter

W . Without it,we would not know in which world to compare
s(l) and s!(l!i).Note also that in this example
wp+1 does not evolve (i.e., its storerelation remains the same in all future worlds).

Finally, when proving equivalence of the existential packages,we represent the cell class type

* with &# defined as follows:

&# = {(j, W, l, &l!0, &l!1, l!2'') | W + Worldj 8

4w + W. w = ('lsj , Llsj ), where ls = &l, &l!0, &l!1, l!2'''}Note that

&# includes ls's owned by any island of the right form.This might add some "junk" to the relation (e.g., objects that were

created by some other class's constructor function), but any suchjunk is harmless since it adheres to the same invariants that the
objects created by e and e! do.
5.5 Irreversible State ChangesA well-known example that has caused trouble for previous logical

relations methods is Pitts and Stark's "awkward" example [21].Although this example does not involve existentials, it has proven
difficult to handle because it involves an irreversible state change:

e = let x = ref 0 in !f : (unit 2 unit). (x := 1; f(); !x)
e! = !f : (unit 2 unit). (f(); 1)The idea here is that

e and e! are equivalent because, as soon asthey are applied, the contents of

x are set to 1, after which point !xwill always return 1. In other words, the first application of

e marksan irreversible state change from
x 62 0 to x 62 1.Intuitively, irreversible state changes are hard to handle if the

knowledge about a piece of local state is fixed once and for all atthe point it is allocated. Using traditional possible-worlds models,
the most precise invariant one can enforce about the contents of
x is that they are either 0 or 1. With such a weak invariant, it isimpossible to know when returning from

f() whether !x is still 1.Using populations, however, we can prove the equivalence of

eand
e! quite easily. A suitable island definition is:

wp+1 = ('(k0, Lk0)

'Vk = ($Vk , V, {lx : int}, {})
$Vk = {(j, W, s, s!) + StoreAtomk | s(lx) = |V |}

Lk = {(j, 'Vj ) | j * k 8 |V | * 1}The intuition here is that we use

V to encode a flag telling uswhether
x has already been set to 1. Initially, !x is 0, signifiedby
V = 5. When x is set to 1, we add some arbitrary value to V ,making it a singleton set of size 1. Because

V is only allowed togrow, we know that
x can never be changed back to 0. In addition,since the law
Lk requires |V | * 1, x must remain at 1 permanently.

11

5.6 Callback with LockThe proofs for the examples presented so far do not use step indices
in an interesting way. The last of our examples, which is inspiredby the reentrant callback example of Banerjee and Naumann [6],
demonstrates an unexpected case where the steps come in handy.Relying as it does on subtle stepwise reasoning, our proof for this
example is rather involved (some might say ugly), but like a dogwalking on its hind legs, one is surprised to find it done at all.

Consider the following object encoding of higher-order type
" = ((unit 2 unit) 2 unit) 1 (unit 2 int):

e = C[f (); x := !x + 1]where

C = let x = ref 0 in &!f : unit 2 unit. [*], !z : unit. !x'It implements a counter object with two methods: an increment
function, and a get function requesting the current counter value.An interesting feature of this object is that its increment method
takes a callback argument, which is invoked before the counter isincremented.

Now, consider the following alternative implementation for thisobject, in which

x is dereferenced before the callback:

e! = C[let n = !x in f (); x := n + 1]One might na"ively assume that the two versions are equivalent,

because x is not publicly accessible. But f might perform arbitraryoperations, including recursively calling the increment function! In
this case, x may be modified between read and write access in e!.Such reentrance can be prevented by adding a lock:

C = let b = ref true in

let x = ref 0 in
&!f : unit 2 unit.

(if !b then (b := false; [*]; b := true) else ())
!z : unit. !x'Note that it is still possible for

f to invoke the get function, whichjust reads the current
x.With
C reimplemented using a lock, e and e! are now contextu-ally equivalent. But how do we go about actually proving this? To

show the two increment functions equivalent, we need to establishthat

f cannot modify x. But how can we set up an island that en-sures that? After all, the island's law must certainly allow updates

to x in general. How can we formulate a law that allows the storeto change, but still can temporarily prohibit it?

Steps to the rescue! When proving that the two increment func-tions are related, we assume that one terminates with

j steps. As-suming
b is set to true (i.e., assuming that x is "unlocked"), wecan partition the reduction sequence for its execution into 3 phases

of length j1 +j2 +j3 = j, where j2 spans the steps spent in the callto

f. These j2 steps are the time window in which x is not allowedto change. So the idea is to define a law that allows setting up time

windows of this kind, during which !x must remain constant.The following island definition does the trick:

wp+1 = ('{&k0,k0,0'}k

0 , Lk0 )

'Vk = ($min(V )k , V, {lb : bool, lx : int}, {l!b : bool, l!x : int})

$&k1,k2,n'k = {(j, W, s, s!) + StoreAtomk |

(j * k1 8 s(lb) = s!(l!b) 8 s(lx) = s!(l!x)) 8
(j ) k2 " (s(lb) = false 8 s(lx) = n))}

Lk = {(j, 'Vj ) + LawAtomk |

V = {&k1, k!1, n1', . . . , &km, k!m, nm'} 8
k1 ) k!1 > k2 ) * * * ) k!m%1 > km ) k!m}Each window is represented by a triple

&k1, k2, n' in V (assumingthe obvious encoding of triples using pairs), with

k1 and k2 giving

its first (upper) and last (lower) step, and n being the value to which
x is fixed during the window. The side condition in Lk ensures thatwindows do not overlap. Consequently, there is always a unique

lowest (newest) window min(V ) = &k1, k2, n', i.e., the one withthe least first projection (the

k1). The store relation $ ensures that,if the step level
j has not yet passed the lower bound k2 of thenewest window (i.e., if

j ) k2), then !x must equal the n fromthat window, and the lock must be held. The definition of

$ alsoprohibits windows from starting in the future by requiring
j * k1.To prove equivalence of the increment functions, starting at step

k with s0(lx) = s!0(l!x) = n and s0(lb) = s!0(l!b) = true (theinteresting case), we proceed in

j1 steps to set b to false, andthen add a new lowest window
&k , j1, k , j1 , j2 , 1, n' to thepopulation of the
(p+1)-th island. Next, we know f() returns afterexactly
j2 steps in some future world W , and the stores s1 and s!1that it returns must be related by

W at step m = k , j1 , j2, whichmeans that
(m , 1, -W .m%1, s1, s!1) + W [p + 1].$. Since thestep level
m , 1 is still in the range of the window we installed,we know that

f() could not have added an even lower window tothe population of the

(p+1)-th island (as the law disallows addingwindows that start in the future). Thus, we know that

W [p+1].$ =

$&m+j2,m%1,n'm , and consequently s1(lx) = s!1(l!x) = n and
s1(lb) = s!1(l!b) = false. That is, thanks to our use of the lock,the call to

f() could not have affected our local state.

5.7 Well-Bracketed State ChangesTo conclude, we give two examples that our method appears unable

to handle. The first one, suggested to us by Jacob Thamsborg, is avariant of Pitts and Stark's "awkward" example (Section 5.5):

e = let x = ref 0 in

!f : (unit 2 unit). (x := 0; f(); x := 1; f(); !x)
e! = !f : (unit 2 unit). (f(); f(); 1)Here, unlike in the "awkward" example, the state of

x changesback and forth between 0 and 1. The reason we believe

e and e!to be equivalent (we do not have a proof!) is that the state changes

occur in a "well-bracketed" fashion -- i.e., every change to 0 isguaranteed to be followed later on in the computation by a change
to 1. This implies (informally) that invoking the callback function
f will either leave the state of x unchanged or will return controlwith

x set to 1. However, it is not clear to us how to formallyestablish this. The trick of representing irreversible state changes

via population growth is inapplicable since the state changes arenot irreversible, and the time windows idea from Section 5.6 is
inapplicable as well since the example does not make use of locks.
5.8 Deferred DivergenceHere is another example we cannot handle, due to Hongseok Yang:2

e1 = !f : (unit 2 unit) 2 unit. f (!z : unit. diverge)
e2 = !f : (unit 2 unit) 2 unit.

let x = ref 0 in let y = ref 0 in
f (!z : unit. if !x = 0 then y := 1 else diverge);
if !y = 0 then x := 1 else divergeHere,

f may either call its argument directly, in which case thecomputation clearly diverges (in

e2 this happens eventually because
y is set to 1), or it may store its argument in some ref cell. Inthe latter case, any subsequent call to the stored argument by the

program context will also cause divergence (in the case of e2,because

x will be 1 at that point). Only if neither f nor the contextever tries to call

f's argument may the computation terminate.

2 A similar example is discussed in Benton and Leperchey [7], at the endof their section 5. However, the two terms in their example are not actually

equivalent in our language, because we have higher-order store.

12

For us to prove e1 and e2 equivalent, we would need some wayof relating the two arguments to

f. Initially, however, when thearguments are invoked, one terminates and the other does not, so

it is not obvious how to relate them. In fact, they are only relatedunder the knowledge of what

e1 and e2 will do after the call to f.This suggests to us that one way to handle such an example might

be to define a relation on terms coupled with their continuations.

6. Related and Future WorkThere is a vast body of work on methods for reasoning about local
state and abstract data types. In the interest of space, we only cite arepresentative fraction of the most closely related recent work.

Logical Relations Our work continues (and, to an extent, synthe-sizes) two lines of recent work: one on using logical relations to
reason about type abstraction in more realistic languages, the otheron using logical relations to reason about local state.

Concerning the former, Pitts [20] provides an excellent overview,although it is now slightly outdated -- in the last few years, several
different logical relations approaches have been proposed for han-dling general recursive (as well as polymorphic) types [16, 1, 11],
which Pitts considers an open problem. Much of the work on thistopic is concerned with logical relations that are both sound and
complete with respect to contextual equivalence. Completeness isuseful for establishing various extensionality properties at different
types, e.g., that two values of type 3%." are contextually equiva-lent iff their instantiations at any particular type

" ! are equivalent.In general, however, just because a method is complete with respect to contextual equivalence does not mean that it is effectivein proving all contextual equivalences. In fact, Pitts gives a representation independence example for which existing techniques are"effectively" incomplete.3

For a logical relation to be complete it must typically be whatPitts terms "equivalence-respecting." There are different ways
to achieve this condition, such as ::-closure [20], biorthogo-nality [16], or working with contextual equivalence classes of
terms [11]. Pitts' ::-closure neatly combines the equivalence-respecting property together with admissibility (or continuity, necessary for handling recursive functions) into one package.We build on the work of Ahmed [1] on step-indexed logical
relations for recursive and quantified types. One advantage of thestep-indexed approach is that admissibility comes "for free," in the
sense that it is built directly into the model. By only ever reasoningabout finite approximations of the logical relation (

Vn!"" #), weavoid the need to ever prove admissibility. (In other words, an

inadmissible relation is indistinguishable from an admissible oneif one only ever examines its step-indexed approximations.) Of
course, the price one pays for this is that one is forced to usestepwise reasoning everywhere, so admissibility is not really "free"
after all. To ameliorate this burden, we are currently investigatingtechniques for proving logical approximation in our model without
having to do explicit stepwise reasoning. As we saw in Section 5.6,though, sometimes the presence of the step indices can be helpful.

Like Ahmed's previous work, our logical relation is sound, butnot complete, with respect to contextual equivalence. (Hers is complete except for the case of existential types.4) While our methodcannot in its current form prove extensionality properties of con3 Pitts' example is actually provable quite easily by a transitive combinationof logical relations proofs (

www.mpi-sws.org/~dreyer/pitts.txt).Dreyer has suggested a harder example, mentioned on page 25 of Sumii

and Pierce [28], for which there is not even any known "brute-force" proof.4 The published conference version of her paper claims full completeness,

but the proof contains a technical flaw uncovered by the second author. Theextended version of her paper corrects the error [1].

textual equivalence, it is still useful for proving representation in-dependence results, which is our primary focus. Recent work by
Ahmed and Blume [2] involves a variant of [1] that is completewith respect to contextual equivalence, where completeness is obtained by essentially Church-encoding the logical interpretation ofexistentials (this is roughly similar to what

::-closure does, too).We are currently attempting to develop a complete version of our

method, using a similar approach to Ahmed and Blume.Concerning the second line of work -- logical relations for
reasoning about local state -- most of the recent previous work weknow of employs possible-worlds models of the sort we discussed
in Section 3.2, so we refer the reader to that earlier section for athorough comparison [21, 22, 7, 10]. However, there are two recent
pieces of work that are worth discussing in further detail.Perhaps the closest related work to ours is Nina Bohr's PhD
thesis [9], which extends her work with Lars Birkedal [10] in twodirections. First, she gives a denotational possible-worlds model
for a language with general recursive types, polymorphism, andhigher-order references, with the restriction that references must
have closed type. This restriction seems to imply that her methodis inapplicable to the cell class example in Section 5.4 because it
involves references of type ref %. Second, she proposes a morerefined (and complex) notion of possible world in which an island's
store relation has the ability to change over time. This is similar incertain ways to our population technique, except that her islands
do not contain anything resembling a population. Her approach isdesigned to handle examples involving irreversible state changes,
like Pitts and Stark's "awkward" example (Section 5.5), but notgenerative ADTs (Sections 5.1-5.3). Bohr's possible worlds also
include the ability to impose invariants on the continuations ofrelated terms, so we believe her technique can handle at least one, if
not both, of the examples in Section 5.7 and 5.8, which we cannot.In a paper conceived concurrently with ours, Birkedal, Sto/vring,
and Thamsborg [8] present a relationally parametric denotationalmodel of a language with general recursive types, polymorphism,
and references of arbitrary type. Their model improves on Bohr'sin the flexibility of its references, but it offers only a weak notion of
possible worlds, with which one can only do very simple reasoningabout local state. Their model cannot handle any of our examples.

Bisimulations For reasoning about contextual equivalences (in-volving either type abstraction or local state), one of the most successful alternatives to logical relations is the coinductive techniqueof bisimulations. Pierce and Sangiorgi [19] define a bisimulation
for reasoning about polymorphic +-calculus, and they demonstrateits effectiveness on an example that is similar to our symbol table
example. Due to the low-level, imperative nature of the +-calculus,it is difficult to give a precise comparison between their technique
and ours, but the basic idea of their technique (described below)has been quite influential on subsequent work.

Sumii and Pierce define bisimulations for an untyped lan-guage with a dynamic sealing operator [27], as well as an extension of System F with general recursive types [28]. Koutavasand Wand [13] adapt the Sumii-Pierce technique to handle an
untyped higher-order language with general references; in theprocess, they improve on Sumii-Pierce's treatment of contextual
equivalences involving higher-order functions. Interestingly, theKoutavas-Wand technique involves the use of inductive stepwise
reasoning when showing that two functions are in the bisimulation.Subsequently, Sangiorgi, Kobayashi, and Sumii [26] propose environmental bisimulations, which generalize Sumii and Pierce's pre-vious work to an untyped framework subsuming that of KoutavasWand's, but in a way that does not appear to require any stepwisereasoning. While all of these bisimulation approaches are sound
and complete with respect to contextual equivalence, none handlesa language with both existential type abstraction and mutable state.

13

There are many similarities between bisimulations and logicalrelations, although a precise comparison of the techniques remains
elusive (and an extremely interesting direction for future work).With bisimulations, one defines the relational interpretations of abstract types, or the invariants about local state, up front, as part of arelation also containing the terms one wishes to prove contextually
equivalent, and then one proceeds to show that the relation one hasdefined is in fact a bisimulation. With logical relations, the proof
proceeds backward in a structured way from the goal of showingtwo terms logically equivalent, and the invariants about type representations or local state are chosen in mid-proof. It is arguablyeasier to sketch a bisimulation proof (by just stating the bisimulation), whereas the islands and & definitions in our proof sketchesmust be stated in medias res. On the other hand, our islands and

&'sare more minimal than bisimulations, which must often explicitly

include a number of redundant intermediate proof steps.The Sumii-Pierce-Koutavas-Wand-Sangiorgi-Kobayashi-Sumii
approach is roughly to define bisimulations as sets of relations,with each relation tied to a particular environment, e.g., a type
interpretation, a pair of stores, etc. Various "up-to" techniques areused to make bisimulations as small as possible. This approach
seems conceptually similar to possible-worlds semantics, but theexact relationship is unclear, and we plan to explore the connection
further in future work.
Separation Logic To reason about imperative programs in a lo-calized manner, O'Hearn, Reynolds et al. introduced separation
logic [24] as an extension to Hoare logic. Separation logic hasbeen enormously influential in the last few years, but it has not to
our knowledge been used to reason about higher-order typed func-tional languages with type abstraction and higher-order store. Notably, however, the desire to scale separation logic to reason abouta functional programming language has led to Hoare Type Theory
(HTT) [18]. HTT is a dependently typed system where computa-tions are assigned a monadic type in the style of a Hoare triple. Under this approach, programs generally have to pass around explicitproof objects to establish properties. Currently, HTT only handles
strong update (where a location's type can vary over time), not ML-style references with weak update (and thus stronger invariants).

Relational Reasoning About Classes There is a large body ofwork on reasoning techniques for object-oriented languages. For
example, Banerjee and Naumann [5] present a denotational methodfor proving representation independence for a Java-like language.
Koutavas and Wand [14] have adapted their bisimulation approachto a subset of Java. The languages considered in these works do not
provide generativity and first-class existential types, but rather tieencapsulation to static class definitions. On the other hand, subsequent work by Banerjee and Naumann [6] addresses the issue ofownership transfer, which we do not. We believe that the generativity of existential quantification and the separation enforced bypossible-island semantics are closely related to various notions of
ownership and ownership types, but we leave the investigation ofthis correspondence to future work.

References[1] Amal Ahmed. Step-indexed syntactic logical relations for recursive

and quantified types. In ESOP, 2006. Extended/corrected version ofthis paper available as Harvard University TR-01-06.
[2] Amal Ahmed and Matthias Blume. Typed closure conversionpreserves observational equivalence. In ICFP, 2008.
[3] Amal Ahmed, Derek Dreyer, and Andreas Rossberg. State-dependentrepresentation independence (Technical appendix), 2008. Available

at: http://ttic.uchicago.edu/~amal/papers/sdri/.

[4] Andrew W. Appel and David McAllester. An indexed model ofrecursive types for foundational proof-carrying code. Transactions

on Programming Languages and Systems, 23(5):657-683, 2001.[5] Anindya Banerjee and David A. Naumann. Ownership confinement

ensures representation independence in object-oriented programs.Journal of the ACM, 52(6):894-960, 2005.
[6] Anindya Banerjee and David A. Naumann. State based ownership,reentrance, and encapsulation. In ECOOP, 2005.
[7] Nick Benton and Benjamin Leperchey. Relational reasoning in anominal semantics for storage. In TLCA, 2005.
[8] Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg. Relationalparametricity for references and recursive types, July 2008. Draft,

submitted for publication.[9] Nina Bohr. Advances in Reasoning Principles for Contextual

Equivalence and Termination. PhD thesis, IT University ofCopenhagen, 2007.
[10] Nina Bohr and Lars Birkedal. Relational reasoning for recursive typesand references. In APLAS, 2006.
[11] Karl Crary and Robert Harper. Syntactic logical relations forpolymorphic and recursive types. In Computation, Meaning and

Logic: Articles dedicated to Gordon Plotkin. 2007.[12] Derek Dreyer, Karl Crary, and Robert Harper. A type system for

higher-order modules. In POPL, 2003.[13] Vasileios Koutavas and Mitchell Wand. Small bisimulations for
reasoning about higher-order imperative programs. In POPL, 2006.[14] Vasileios Koutavas and Mitchell Wand. Reasoning about class
behavior. In FOOL/WOOD, 2007.[15] Xavier Leroy. Applicative functors and fully transparent higher-order
modules. In POPL, 1995.[16] Paul-Andr'e Melli`es and J'er^ome Vouillon. Recursive polymorphic
types and parametricity in an operational framework. In LICS, 2005.[17] John C. Mitchell. Representation independence and data abstraction.
In POPL, 1986.[18] Aleksandar Nanevski, Greg Morrisett, and Lars Birkedal. Hoare
type theory, polymorphism and separation. Journal of FunctionalProgramming, 18(5&6):865-911, September 2008.
[19] Benjamin C. Pierce and Davide Sangiorgi. Behavioral equivalencein the polymorphic pi-calculus. Journal of the ACM, 47(3):531-586,

2000.[20] Andrew Pitts. Typed operational reasoning. In B. C. Pierce, editor,

Advanced Topics in Types and Programming Languages, pages 245-289. The MIT Press, 2005.
[21] Andrew Pitts and Ian Stark. Operational reasoning for functions withlocal state. In HOOTS, 1998.
[22] Uday Reddy and Hongseok Yang. Correctness of data representationsinvolving heap data structures. In ESOP, 2003.
[23] John C. Reynolds. Types, abstraction and parametric polymorphism.In Information Processing, 1983.
[24] John C. Reynolds. Separation logic: A logic for shared mutable datastructures. In LICS, 2002.
[25] Claudio V. Russo. Non-dependent types for Standard ML modules.In PPDP, 1999.
[26] Davide Sangiorgi, Naoki Kobayashi, and Eijiro Sumii. Environmentalbisimulations for higher-order languages. In LICS, 2007.
[27] Eijiro Sumii and Benjamin Pierce. A bisimulation for dynamicsealing. Theoretical Computer Science, 375(1-3):161-192, 2007.
[28] Eijiro Sumii and Benjamin Pierce. A bisimulation for type abstractionand recursion. Journal of the ACM, 54(5):1-43, 2007.
[29] Janis Voigtl"ander and Patricia Johann. Selective strictness andparametricity in structural operational semantics, inequationally.

Theoretical Computer Science, 388(1-3):290-318, 2007.

14