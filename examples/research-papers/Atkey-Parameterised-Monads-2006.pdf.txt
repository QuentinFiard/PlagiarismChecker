

Parameterised Notions of Computation

Robert Atkey1Laboratory for Foundations of Computer Science, School of Informatics, University of Edinburgh
Mayfield Road, Edinburgh EH9 3JZ, UKbob.atkey@ed.ac.uk

Abstract
Moggi's Computational Monads and Power et al's equivalent notion of Freyd categoryhave captured a large range of computational effects present in programming

languages such as exceptions, side-effects, input/output and continuations. Wepresent generalisations of both constructs, which we call parameterised monads
and parameterised Freyd categories, that also capture computational effects withparameters. Examples of such are composable continuations, side-effects where the
type of the state varies and input/output where the range of inputs and outputs varies.By also considering monoidal parameterisation, we extend the range of effects to
cover separated side-effects and multiple independent streams of I/O. We also presenttwo typed

*-calculi that soundly and completely model our categorical definitions --with and without monoidal parameterisation -- and act as prototypical languages with

parameterised effects.
Keywords: Freyd Categories, Computational Monads, Computational Effects

1. INTRODUCTION
Moggi's framework of Computational Monads [9, 8], and Power et al's equivalent notionof Freyd Categories [12, 13, 5], have been successfully used to capture a wide range
of computational effects used in programming language designs, such as non-termination,exceptions, continuations, side-effects and input/output. In this paper, we generalise both notions
to parameterised monads and parameterised Freyd categories. The parameterisation will takethe form of a parameterising category that will annotate computations with information on their
start and end states.
Our main motivating example is that of side-effects. The standard side-effects monad selects anobject

S of the base category to represent the type of the computer's store and sets the functorpart of the monad to be

T A = (S * A)S. Computations go from old stores to new stores andvalues. This monad successfully models global side-effects.

The problem with this solution is that it uses a single object to represent the store at all pointsduring the program. Thus, there is a single "type" that covers all the possible stores that a program
can generate. For the purposes of modelling features such as strong update [10], where the typeof storage cells may change over time, or type systems inspired by Hoare Logic such as Alias
Types [15], this is inadequate. Such type systems type the current store explicitly and restrict therange of possible operations according to the current type. We will present two type systems with
explicitly typed stores below in Sections 3 and 5. An example judgement has the form:

\Gamma ; z : S1 ` c : A; S2
The context \Gamma  and type A are the traditional value context and result type respectively. The context
z : S1 and type S2 use the types S1 and S2 to type the initial and final states required and producedby the computation

c.

We propose to model this by considering an additional parameterising category S to interpret thetypes

S1 and S2. The arrows of S are intended to be used to represent effect-free manipulations ofstore descriptions, analogous to implications between assertions in Hoare Logic. We extend the

1Work funded by the ReQueST grant (EP/C537068) from the Engineering and Physical Sciences Research Council.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 1

Parameterised Notions of Computation
definition of monad to be composed of functors T : Sop * S * C ! C, with additional conditions onthe unit and multiplication that we set out in Section 2.1. In the case of state we assume a functorb

* : S ! C and set T (S1, S2, A) = (cS2 * A)cS1.
This situation suffices for modelling explicitly typed global state. Below, we present two otherexamples, typed input/output, where the range of inputs and outputs depends on the current type
of the state, and Danvy and Filinski's composable continuations [2].
In many cases, however, the assumption of globalness is too strong. We can regard the storeof a computer as being built from multiple independent regions, right down to the individually
addressable storage cells. Similarly, the computer may have multiple I/O devices attached and beable to send output and receive input from them independently.

In order to model this situation, we assume that the parameterising category S is symmetricmonoidal. That is, there is a bifunctor \Omega  : S * S ! S that we can use to build composite
state descriptions from smaller ones. Hence, if the state types [Int] and [Bool] representstores containing an integer and a boolean respectively, the composite state type

[Int] \Omega  [Bool]represents a store containing both an integer and a boolean, in separate memory cells.

The problem now is how to sequence two programs operating on separate parts of the heap. Ifwe have arrows

c1 : A ! T (S1, S2, B) and c2 : B ! T (S01, S02, C) representing computations, howdo we get a single arrow

A ! T (S1 \Omega  S01, S2 \Omega  S02, C)? The solution we present here is to requirenatural transformations (- \Omega 

S)# : T (S1, S2, A) ! T (S1 \Omega  S, S2 \Omega  S, A), and symmetrically, to liftcomputations up to larger state contexts. This lifting is similar to the service provided by monad

strength for lifting to larger value contexts, as seen by the definition of double parameterisedFreyd categories in Section 4, where the two types of computation in context are represented by
two premonoidal structures.
In Section 2, we present our definitions of parameterised monad and parameterised Freydcategory, prove them equivalent and give our main examples: typed side-effects, typed
input/output and composable continuations. We follow this in Section 3 with a typed *-calculus,the Typed Command Calculus, which is sound and complete for our categorical constructions. In
Section 4, we extend our categorical definitions to allow symmetric monoidal parameterisation,extending the range of examples to allow separated side-effects and multiple streams of
input/output. We extend the Typed Command Calculus to this situation in Section 5. Finally, inSections 6 and 7, we describe related work and present some concluding remarks and future
work.
2. SIMPLE PARAMETERISATION
Simple parameterisation allows us to model situations where the current state is global; e.g. astore that cannot be subdivided, or a single I/O port, or a single continuation context. We first
give the definition for parameterised strong monads, and then some examples demonstrating theuse of the parameterisation. We then define parameterised Freyd categories and show that the
two are equivalent. In the next section we will describe a typed *-calculus is sound and completefor parameterised Freyd categories (and parameterised strong monads). All of our definitions are
over a base category C, which we assume to have finite products, and a parameterising categoryS. We refer to these as the value and state categories respectively.

2.1. Parameterised Strong Monads
Recall that a monad consists of a functor T : C ! C and two natural transformations, the unit
jA : A ! T A and the multiplication uA : T (T A) ! T A. For modelling effects, arrows A ! T Bare regarded as computations that take a value of type

A, do some computation and produce avalue of type
B. The unit is used to represent the identity computation and the multiplication isused to interpret the sequencing of computations; i.e. a computation that produces a computation

that produces a value is sequenced to give a computation that produces a value.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 2

Parameterised Notions of Computation
As described in the introduction, for parameterised monads we extend the functor part to be afunctor

T : Sop * S * C ! C. On objects, the first and second arguments represent the assertionsabout the pre-state and post-state respectively. On arrows, they represent the strengthening

of pre-conditions and the weakening of post-conditions, hence the contravariance in the firstargument and covariance in the second.

We extend the unit of the monad to be a family of arrows jS,A : A ! T (S, S, A), used forrepresenting the identity computation at any state. This family of arrows is required to be natural
in A, as for non-parameterised monads. It is also required to be dinatural ([7] $IX.4) in S, sothe equation

jS1,A; T (S1, f, A) = jS2,A; T (f, S2, A) must hold for any f : S1 ! S2. The intuitivereading of dinaturality in this case is that strengthening of the precondition and weakening of the

post-condition are equivalent for the identity computation.
Multiplication of parameterised monads consists of a family of arrows uS1,S2,S3,A :
T (S1, S2, T (S2, S3, A)) ! T (S1, S3, A). Only pairs of computations where the former's post-condition matches the latter's pre-condition may be sequenced. Multiplication is required to be

natural in S1, S3 and A and dinatural in S2. Dinaturality in this case amounts to the followingdiagram commuting for all

f : S2 ! S02:

T (S1, S02, T (S02, S3, A))

T (S1, S2, T (S02, S3, A)) T (S1, S3, A)

T (S1, S2, T (S2, S3, A))

**VVVVVVV
VVVVV u44hhhhhhhhhhhhT (S1,f,T (S02,S3,A))

**VVVVVVVV
VVVV
T (S1,S2,T (f,S3,A))

44hhhhhhh
hhhhh u

This states that if we have two commands with a mismatch in the intermediate state, then it doesnot matter if we weaken the former's post-condition, or the latter's pre-condition in order to make
them match.
Definition 1 An S-parameterised monad (T, j, u) on C consists of a functor T : Sop * S * C ! C;a transformation

jS,A : A ! T (S, S, A), natural in A and dinatural in S; and a transformation
uS1,S2,S3,A : T (S1, S2, T (S2, S3, A)) ! T (S1, S3, A), natural in S1, S3 and A and dinatural in S2.These must obey the monad laws:

j; u = T (S1, S2, j); u = id and T (S1, S2, u); u = u; u.

An alternative partial definition is given by observing that a non-parameterised monad isequivalent to a one object CC-enriched category. A multiple object CC enriched category is
equivalent to part of our definition2, where the objects are the objects of the parameterisingcategory S. Therefore, if we restrict S to be the one object, one arrow category then our definition
is equivalent to the standard definition of a non-parameterised monad.
Crucial to Moggi's use of monads to model effectful computation is the notion of strength. Astrength for a monad is a natural transformation

o/A,B : A * T B ! T (A * B), obeying someaxioms. Strength is used to interpret computations in context: given a computation represented

as an arrow c : A ! T A0 and a context B, we can lift c up to the larger context by composition
with the strength: B * A B*c-! B * T A0 o/-! T (B * A0). The idea of computation in context formsthe main focus of the definition of premonoidal structure, which is a major part of the definition of

Freyd category (see below). We also extend the computation in context idea in Section 4 belowto cover computation in state context.

The definition of strength generalises easily to parameterised monads:
Definition 2 A strength for a parameterised monad (T, j, u) is a natural transformation
o/A,S1,S2,B : A * T (S1, S2, B) ! T (S1, S2, A \Omega  B) that obeys the obvious adaptations of the axiomsfor non-parameterised strength.

2This observation is due to Chung-chieh Shan: http://haskell.org/pipermail/haskell-cafe/2004-July/006448.html

Workshop on Mathematically Structured Functional Programming, MSFP 2006 3

Parameterised Notions of Computation
2.2. Examples
We now give some examples of parameterised monads modelling computational effects thatrequire the additional parameterising category S. In addition to these examples, note that any
strong monad gives a strong parameterised monad with any parameterising category.
2.2.1. Typed State
As stated in the introduction, we can use parameterised monads to model typed global state.Select a collection of storable objects of C, called C

0. Set the category S to have objects [A] foreach object
A of C0, plus an additional object \Sigma . The only non-identity arrows are clear A : [A] ! \Sigma for each

A 2 C0. Hence \Sigma  is the terminal object of S.

The functor b* : S ! C maps each [A] to A and \Sigma  to the terminal object. Hence the objects [A]are used to represent storage cells containing values of type

A and \Sigma  represents a memory cellcontaining a value of indeterminate type.

The monad is defined as T (S1, S2, A) = (cS2 * A)cS1. The definitions of the unit, multiplication andstrength are almost identical to those for the standard side-effects monad. There are two basic
operations for this monad, read and store, which we define as follows:

read : T ([A], [A], A) store : A ! T (\Sigma , [A], 1)read =

*s.(s, s) store = a 7! *s.(a, ?)

2.2.2. Typed I/O
For simplicity, we restrict to C = Set, the category of sets and functions, and S being a smalldiscrete category. Assume a collection of input sets {

I(S)}S2S and a collection of output sets{
O(S1, S2)}S1,S22S. The objects of S represent the states that an I/O device may be in; the sets
I(S) represent the possible inputs in a state; and O(S1, S2) represent the possible outputs in agiven state, and the states they cause the device to go into. On objects, the monad functor is built

inductively from the following rules:

a 2 A
e(a) 2 T (S, S, A)

f 2 I (S1) ) T (S1, S2, A)

i(f) 2 T (S1, S2, A)

m 2 O(S1, S2) c 2 T (S2, S3, A)

o(m, c) 2 T (S1, S3, A)

Computations are therefore trees of output transitions and branching input transitions, terminatedby result values. The monad unit just maps

a to e(a) and multiplication concatenates trees.

The monad has two primitive operations that perform input and output:

input : T (S, S, I(S)) output : O(S1, S2) ! T (S1, S2, 1)input =

i(*x.e(x)) output = *m.o(m, e(*))

2.2.3. Composable Continuations
Parameterised monads provide a way to interpret Danvy and Filinski's composable continuations[2]. Composable continuations provide access to evaluation contexts smaller than the whole
program, delimited at runtime by the reset operator. The current context is made available to theprogram by the shift operator. In contrast, the call with current continuation operator only allows
the entire program to be treated as the current context. The following is inspired by Wadler'sattempt to express composable continuations in terms of monads [18].

We require C to be cartesian closed, and set S to be |C|, the discrete category with the sameobjects as C. Define

T (R1, R2, A) = (A ! R2) ! R1, where ! is the functor part of the cartesianclosed structure. Unit, multiplication and strength are defined as for the standard continuations

monad [9].

Workshop on Mathematically Structured Functional Programming, MSFP 2006 4

Parameterised Notions of Computation
In terms of the type system given by Danvy and Filinski in [2], a judgement ae, ff ` E : o/, fi isinterpreted as an arrow J

aeK ! T (JfiK, JffK, Jo/ K). The reset operator is interpreted as an arrow in C,using the internal language of C:

reset : T (B, A, A) ! T (C, C, B)
reset = c 7! *k.k(c(*x.x))

Thus reset calls c with the empty context, represented by the identity function, and feeds the outputto the current continuation. The shift operator is defined as:

shift : ((A ! T (C, C, B)) ! T (E, D, D)) ! T (E, B, A)
shift = f 7! *k.(e(*v.*k0.k0(kv)))(*x.x)

See below and [2] and [18] for examples of the use of shift and reset. This example needs muchmore work to establish the precise categorical properties of shift and reset, and to potentially

axiomatise it without reference to an underlying continuation passing interpretation, following thelead set by Thielecke [17].

2.3. Parameterised Freyd Categories
Freyd categories are comprised of identity on objects functors J : C ! K, where K haspremonoidal structure and

J strictly preserves it by seeing the finite product structure of C aspremonoidal structure. Premonoidal structure consists of a pair of functors

A ! - : K ! Kand - =
A : K ! K that agree on objects: A ! B = A = B = A \Omega  B, and associativity, leftand right unit and symmetry natural transformations as for symmetric monoidal structure. The

components of these natural transformations must be central: an arrow f of K is central if, for allarrows

g, A ! f; g = B0 = g = B; A0 ! f . Arrows of K are used to represent computations, with theidentity arrow representing the identity computation, and composition representing the sequencing

of computations. The premonoidal structure is used to represent computation in context.
Our definition of parameterised Freyd category builds the required structure in a single step, unlikethe two steps of premonoidal structure on the codomain category, and then a strict premonoidal
functor as for Freyd categories. We do it is this way for two reasons. Firstly, we want the objectsof the codomain category to be comprised to pairs of objects of the value and state categories
but with the premonoidal structure only referring to the value category, so we start by requiringan identity on objects functor

J : C * S ! K. The premonoidal structure is then built on top ofthis, building in the requirement of strict preservation of premonoidal structure. Secondly, there

is no obvious definition of centrality for arrows in a parameterised Freyd category, due to thecomposition ordering imposed by the objects of the state category. Therefore we just state that
the symmetric monoidal structure natural transformations of C via J are the ones we need, ratherthan requiring them on K and saying that

J should preserve them.

Definition 3 A parameterised Freyd category consists of three categories C, S and K, where Chas finite products, and three functors

J : C * S ! K, !C : C * K ! K and =C : K * C ! K, suchthat:

1. J is identity on objects;2. The monoidal structure of C is respected:

A !C J(B, X) = J(A, X) =C B = J(A * B, X) and
f !C J(g, s) = J(f, s) =C g = J(f * g, s);3. For each

S 2 ObS, the transformations J(ffABC, S), J(*A, S), J(aeA, S) and J(oeA,B, S) mustbe natural in all combinations of \Omega 

, !C and =C that make up their domain and codomain.

This definition can be split into two parts: the functor J : C*S ! K, which identifies how pure valuecomputations and state manipulations are incorporated into commands; and the premonoidal
structure with respect to C, given by the functors !C and =C. Closure for parameterised Freydcategories is similar to that for Freyd categories. It will be used to interpret function types.

Definition 4 A parameterised Freyd category J : C * S ! K is closed if, for all A 2 ObC and
S 2 ObS, the functor J(-*A, S) : C ! K has a specified right adjoint, written (A, S) ! - : K ! C.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 5

Parameterised Notions of Computation
We now show the relationship between parameterised Freyd categories and strong parameterisedmonads. To do this we shall go through parameterised adjunctions. The definition of
parameterised adjunction is as follows:
Definition 5 An S-parameterised adjunction from C to D is a 4-tuple hF, G, j, ffli : C ! D where
F and G are functors:

F : S * C ! D G : Sop * D ! C
and j and ffl are the unit and counit, natural in A and dinatural in S:

jS,A : A ! G(S, F (S, A)) fflS,A : F (S, G(S, A)) ! A

By Theorem $IV.7.3 in [7], if we have a functor F : S * C ! D such that for every object S, F (S, -)has a right adjoint

GS : D ! C, then there is a unique way to make G into a bifunctor Sop * D ! Csuch that it is a parameterised adjunction in the sense of this definition. Using this result, we

can turn the closed structure of a closed parameterised Freyd category into an S-parameterisedadjunction between C and K with the functors

J(-, S) and (1, S) ! -.

Now, parameterised monads are to parameterised adjunctions as monads are to adjunctions,as the following lemma partially demonstrates. It also possible to define a suitable notion of
Eilenberg-Moore category of algebras for a parameterised monad, and this and the Kleislicategory used in this lemma are the final and initial objects in the category of adjunctions defining
and parameterised monad, as for monads. See the appendix of [1] for more details.
Lemma 1 S-parameterised adjunctions hF, G, j, ffli : C ! D give S-parameterised monads on C,defined as:

T (S1, S2, A) = G(S1, F (S2, A)) jTS,A = jS,A uTS1,S2,S3,A = G(S1, fflS2,F (S3,A))
Conversely, given an S-parameterised monad on C, define a category CT with objects pairs ofC and S objects and C

T ((A1, S1), (A2, S2)) = C(A1, T (S1, S2, A2)). The functors F = S, A 7!(
A, S); s, f 7! j; T (S1, s, f) : S * C ! CT and G = S1, (A, S2) 7! T (S1, S2, A); s, c 7! T (s, S2, c); u :S * C

T ! C form a parameterised adjoint pair.

Proof Almost identical to the proof of the definition of a monad from an adjunction [7]. Theadditional (di)naturality conditions are easy to check. The second part is just the parameterised
generalisation of the construction of the Kleisli category. \Lambda 
Thus, every closed Freyd category gives a parameterised monad, and we can generate a categoryK and an identity on objects functor

J : C * S ! K via the parameterised version of the Kleisliconstruction. We extend Power and Robinson's Theorem 4.2 of [12], which links the premonoidal

structure of Freyd categories with monad strength, to the parameterised case:
Lemma 2 Given an strength for a parameterised monad (T, j, u), there is premonoidal structureon C

T with respect to C, and vice versa. These operations are inverse.

Proof Given a strength o/ , define f !C c = f \Omega  c; o/A,S1,S2,B, =C is similar. Given premonoidalstructure !

C, define o/A,S1,S2,B = idA !C idT (S1,S2,B) as an arrow of C, where idT (S1,S2,B) is seenas an arrow

T (S1, S2, B) ! B in CT . The axioms in each case are easily checked. That theseoperations are inverse is seen by writing out the two definitions and calculating, keeping careful

track of the different compositions in C and CT . \Lambda 
Lemma 3 If a strong parameterised monad has Kleisli exponentials, i.e. there is a functor(

B, S1) ! - : CT ! C for all objects B, S1, and a natural isomorphism CT ((A * B, S1), (C, S2)) ,=C(

A, (B, S1) ! (C, S2)), then the induced parameterised Freyd category is closed. Conversely,every closed parameterised Freyd category gives a strong monad with Kleisli exponentials. These

operations are inverse.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 6

Parameterised Notions of Computation
Proof The closure functors are identical in both cases. \Lambda 
These lemmas combine to give:
Theorem 1 Strong parameterised monads with Kleisli exponentials and closed parameterisedFreyd categories are equivalent.

3. TYPED COMMAND CALCULUS
In this section we define a typed *-calculus, the Typed Command Calculus, which is sound andcomplete for parameterised Freyd categories. The design of the calculus is based on the fine-grain
call-by-value calculus for Freyd categories given by Levy, Power and Thielecke [5].
3.1. Typing Rules
Levy et al's fine-grain call-by-value calculus has two typing judgements \Gamma  `v V : A and\Gamma  `

p M : A. The first is used to type values, i.e. computations with no effect, and is interpreted in C.

The second judgement is used to type producers, i.e. computations with effects, and is interpretedin K. The two main constructs of the calculus are typed as follows:

\Gamma  `v V : A
\Gamma  `p produce V : A

\Gamma  `p M : A \Gamma , x : A `p N : B

\Gamma  `p M to x.N : B

The construct produce V incorporates values into producers and is interpreted using the functor
J of a Freyd category. The construct M to x.N denotes the execution of the effectful computation
M in the context \Gamma , feeding its result to N which is then executed. This is interpreted using thepremonoidal structure of the Freyd category and composition.

The Typed Command Calculus also has a typing judgement for each category present in thedefinition of parameterised Freyd category. For the three categories, there are three judgements:

\Gamma  `v e : A \Delta  `s s : S \Gamma ; \Delta  `c c : A; S
The first is used to type values, and is interpreted in the value category C. Value terms arecomprised of variables, units, pairs, projections, primitive functions and function abstractions

(but not applications). The second is used to type state manipulations, and is interpreted in thestate category S. State manipulation terms consist of variables and primitive functions. The third
judgement form is used to type computations, and is interpreted in the category K. Computationterms are comprised of pure value and state terms, sequencing, primitive computations and
function application. Contexts for computation judgements are a pair of a value context and astate context, and result types are a pair of a value typed and a state type. The typing rules for
these judgements are given in Figure 1.
Let TV and TS be sets of primitive value types and primitive state types. The state types are exactlythe set of primitive state types and are ranged over by

S, S1, S2, .... Value types are generated bythe following grammar:

A ::= X 2 TV | 1 | A1 * A2 | (A1; S1) ! (A2; S2)
The unit and product types are standard. The value function type (A1; S1) ! (A2; S2), where S1and

S2 are state types, will be interpreted using the closure.

Assume a pair of countably infinite sets of value variables x, x1, x2, ... and state variables
z, z1, z2, .... Value contexts \Gamma  are defined as a list of variable/type pairs where no variable mayappear more than once. State contexts \Delta  are single variable/type pairs of the form

z : S.

The state calculus is a monadic calculus, in the sense that it only has single-argument functions.The rule

S-VAR types variables and S-PRIM types primitive function application. We assume a set\Phi 

S of primitive state manipulations of the form m : S1 -! S2.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 7

Parameterised Notions of Computation
State Calculus:

z : S `s z : S (S-VAR)

\Delta  `s s : S1 (m : S1 -! S2) 2 \Phi S

\Delta  `s ms : S2 (S-PRIM)

Value Calculus:

x : A 2 \Gamma 
\Gamma  `v x : A (V-VAR)

\Gamma  `v e : A1 (f : A1 -! A2) 2 \Phi V

\Gamma  `v fe : A2 (V-PRIM) \Gamma  `v ?1 : 1 (V-1I)

\Gamma  `v e1 : A1 \Gamma  `v e2 : A2

\Gamma  `v (e1, e2) : A1 * A2 (V-*I)

\Gamma  `v e : A1 * A2

\Gamma  `v ssie : Ai (V-*E-i)

\Gamma , x : A1; z : S1 `c c : A2; S2
\Gamma  `v *!(xA1; zS1).c : (A1; S1) ! (A2; S2) (V-!I)

Command Calculus:

\Gamma  `v e : A \Delta  `s s : S

\Gamma ; \Delta  `c (e; s) : A; S (C-V-S)

\Gamma ; \Delta  `c c : A1; S1 (p : (A1; S1) -! (A2; S2)) 2 \Phi C

\Gamma ; \Delta  `c pc : A2; S2 (C-PRIM)

\Gamma ; \Delta  `c c1 : A1; S1 \Gamma , x : A1; z : S1 `c c2 : A2; S2

\Gamma ; \Delta  `c let (x; z) ( c1 in c2 : A2; S2 (C-LET)

\Gamma  `v e : (A1; S1) ! (A2; S2) \Gamma ; \Delta  `c c : A1; S1

\Gamma ; \Delta  `c e@!c : A2; S2 (C-!E)

FIGURE 1: Typing rules for the Typed Command Calculus
The value and command calculi are mutually defined via the rules for function abstractionand application. The value calculus includes the standard rules for product introduction and
elimination. We also assume a set \Phi V of primitive value functions of the form f : A1 -! A2.The rule

V-!I introduces functions. Since a function represents a suspended computation, theyare treated as pure values and so this rule takes a judgement in the command calculus and

produces one in the value calculus. The rule C-!E eliminates such functions, producing aneffectful computation in the command calculus. Functions are to be interpreted using the closed
structure of a closed parameterised Freyd category.
The rule C-V-S incorporates the terms of the value and state calculi into the command calculus.This rule will be interpreted by the action of the functor

J. The C-PRIM rule types primitivecommands taken from a set \Phi 

C of primitive commands of the form p : (A; S1) -! (B; S2). Therule C-L
ET sequences two computations similar to the M to x.N construct of the fine-grain call-by-value calculus.

3.2. Example
We present a short example of composable continuations expressed in our calculus, adaptedfrom Wadler's paper [18]. In this case the set of primitive state types is equal to the set of all value
types. The operators reset and shift can be represented as new constructs in the calculus likeso3:

\Gamma ; z : A `c c : B; B
\Gamma ; z : C `c reset c : A; C

\Gamma , f : (T, D) ! (A, D); z : B `c c : O; O

\Gamma ; z : B `c shift f.c : T ; A

An example term is (assuming primitive value functions for numerals and addition):

let (x; z) ( reset(let (

y; z) ( shift f.(let (a; z) ( f@!(100; z) in let (b; z) ( f @!(1000; z) in (a + b; z))in (
y + 10; z))in (1 +
x; z)

3It is also possible to represent these as primitive commands operating on values of function type, but this method gives
a clearer presentation of the example.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 8

Parameterised Notions of Computation
Value calculus:

ssi(e1, e2) = ei

e = (ss1e, ss2e)
e = ?
f = (*!(xA1, zS1).f@!(x; z))

Command calculus rules:

e1 = e2 s1 = s2

(e1; s1) = (e2; s2)

let (x; z) ( (e; s) in c = c[e/x, s/z]
let (x; z) ( c in (x; z) = c

(*!(x, z).c)@!a = let (x; z) ( a in c
C[let (x; z) ( c1 in c2] = let (x; z) ( c1 in C[c2]

C[-] ::= - | p C[-] | let (x; z) ( C[-] in c | e@!C[-]

FIGURE 2: Equational Rules for the Typed Command Calculus

Given the interpretation of composable continuations above, this term evaluates to 1121. Thecontext let (

y0; z) ( - in (y0+10; z) is invoked twice by the application of the delimited continuationexposed by the shift operator. Note that, since the composable continuations example uses a

discrete category as the parameterising category, the terms of the state calculus are extremelyuninteresting and the variable

z representing the continuation context type information is justrobotically passed throughout the program. For this application it would make sense to suppress

the state calculus, but for more complex examples, such as separated state, it is essential.
3.3. Equational Theory
Equations are generated by three sets of typed axioms of the form \Gamma  `v e1 ax= e2 : A,\Delta  `

s s1 ax= s2 : S and \Gamma ; \Delta  `c c1 ax= c2 : A; S where both sides of each axiom are typable

with the given context and type, and the rules in Figure 2, plus reflexivity, transitivity, symmetryand congruence. The state calculus has no additional rules.

The value calculus has the standard fij rules for product and unit types, plus an j expansion rulefor functions. The command calculus incorporates value and state equations via the (*; *) term
construct. It also has fij rules for sequencing, a fi rule for functions and a collection of commutingconversions for the sequencing construct.

The rules generate three equational judgements of the form \Gamma  `v e1 = e2 : A, \Delta  `s s1 = s2 : Sand \Gamma ; \Delta  `

c c1 = c2 : A; S. Note that the equations only apply when both sides are well-typed

with the same context and result type. By proving the appropriate substitution rules admissible[1], it is easy to see that all the rules apart from the commuting conversions generate well-typed

equations. The commuting conversions can be seen to generate well-typed equations by inductionon the structure of the contexts

C[-].

3.4. Soundness and Completeness
The interpretation of the Typed Command Calculus in a parameterised Freyd category has alreadybeen alluded to, but we spell it out in a bit more detail here. Assume a closed parameterised Freyd
category J : C * S ! K, with maps specifying the interpretation of primitive value and state typesas C and S objects respectively, and the interpretation of primitive value, state manipulation and
command operations as arrows in C, S and K respectively.
The state calculus is interpreted in S, using the identity for the S-VAR rule and the interpretationof primitive functions, plus composition, for the interpretation of

S-PRIM. The rules V-VAR, V-PRIM,
V-1I, V-*I and V-*E-i are given the standard interpretation in a category with finite products.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 9

Parameterised Notions of Computation
The function abstraction rule is interpreted using the isomorphism of homsets derived from theadjunction forming the closure: \Lambda  : K((\Gamma  *

A, S1), (B, S2)) ! C(\Gamma , (A, S1) ! (B, S2)).

The C-V-S rule is interpreted using the functor J in the evident way, and C-PRIM is interpreted justusing composition. For sequencing,

C-LET is interpreted using the premonoidal structure of theparameterised Freyd category. Assuming the first premise is interpreted by an arrow

c1 and thesecond by an arrow
c2, the conclusion is interpreted by J(hid , id i, id ); \Gamma  ! c1; c2. Thus, the contextis duplicated using the finite product structure of C, the computation

c1 is executed in context \Gamma and the result and the remaining copy of \Gamma  are fed into
c2. The conditions on the state types in therule ensure that the composition is valid. The
C-!E rule is interpreted by using the counit of theadjunction forming the closed structure: ev : ((
A, S1) ! (B, S2) * A, S1) ! (B, S2).

Theorem 2 (Soundness and Completeness) The Typed Command Calculus is sound andcomplete for closed parameterised Freyd categories.

Proof Soundness is by induction on the derivations of equational judgements. Completeness isproven by the construction of a closed parameterised Freyd category from the three calculi and
the construction of a model within it. See [1] for the more general case of the monoidal TypedCommand Calculus (Section 5 below). \Lambda 

4. MONOIDAL PARAMETERISATION
As we stated in the introduction, the simple parameterisation case is only suitable for modellingsituations where the state is global, but in the case of side-effects and typed I/O, we can regard
the state as being composed of multiple independent parts. We use symmetric monoidal structureon the state category to represent the composition of state types from smaller state types. The
main problem now is to represent the lifting of computations up to larger state contexts in orderto compose them. We present two solutions to this problem, one for parameterised monads and
one for parameterised Freyd categories, and prove that they are equivalent. For this section, weassume that the parameterising category S is symmetric monoidal.

4.1. Parameterised Monads with Monoidal Lifting
As mentioned in the introduction, we require two families of arrows (- \Omega  S)# and (S \Omega  -)# to liftcomputations up to larger state contexts. If the object

T (S1, S2, A) is interpreted as commands thatgo from state
S1 to state S2 and returns a value of type A, then the effect of the monoidal lifting isto lift such commands to larger state contexts: e.g. applying (- \Omega 

S)# gives T (S1 \Omega  S, S2 \Omega  S, A). Inthis respect, the monoidal lifting performs the same service as the strength in lifting computations

to larger contexts.
Before we can define the structure we require, we need a way of describing actions onparameterised monads that agree on objects with functors on the parameterising category.

Definition 6 Given an S-parameterised monad (T, j, u), and a functor F : S ! S, a lifting of F
to T is a natural transformation F #S1,S2,A : T (S1, S2, A) ! T (F S1, F S2, A) that commutes with theunit and multiplication of the monad:

F #; T (F S1, F S2, F #); u = u; F # j; F # = jF
A natural transformation i : F ) G in S is natural for liftings F # and G# if the equation
F #; T (F S1, i, A) = G#; T (i, GS2, A) holds.

Extending the alternative definition of a parameterised monad as a CC-enriched category notedabove, the definition of a lifting of a functor is the same as a CC-functor on this category.

Using the given definition, we can state the structure we require on parameterised monads tointerpret computation in state context.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 10

Parameterised Notions of Computation
Definition 7 An S-parameterised monad (T, j, u) has monoidal lifting if, for every S 2 ObS,there are liftings for the functors - \Omega 

S and S \Omega  -, written (- \Omega  S)# and (S \Omega  -)#, such thatall the symmetric monoidal structure transformations are natural for them and so are the natural

transformations given by - \Omega  s and s \Omega  - for every arrow s.
4.2. Examples
Two of the examples given above extend to the monoidal case.

4.2.1. Typed Side-effects
For the state category, we take the free symmetric monoidal category on the category S definedfor the typed side-effects example above, which we label S0. We extend the functor b* to be S0 ! C

by mapping objects S1 \Omega  S2 to cS1 * cS2, hence b* becomes a strict symmetric monoidal functor.Monoidal lifting is defined as: (

S \Omega  -)# = c 7! *(s, s1).let (s2, a) = c(s1) in ((s, s2), a) and similarfor (- \Omega 
S)#.

4.2.2. Typed I/O
Again, we restrict to C = Set, the category of sets and functions. Choose a small discretecategory S

o to represent the states of individual I/O devices and assume a collection of input sets{
I(S)}S2S0 and a collection of output sets {O(S1, S2)}S1,S22S0. Set the parameterising categoryS to be the free symmetric monoidal category over S

0. That is, objects of S are words of objectsof S
0 formed by unit, singleton and concatenation and arrows are permutations. This category isstrict with respect to associativity and units. We use the notation

S(S1) to represent a word (objectof S) with a distinguished location in it holding an S

0 object S1.

The object part of the functor of the monad is built using the following inductive definition:

a 2 A
e(a) 2 T (S, S, A)

f 2 I(S1) ) T (S(S1), S2, A)

i(f ) 2 T (S(S1), S2, A)

m 2 O(S1, S2) c 2 T (S(S2), S, A)

o(m, c) 2 T (S(S1), S, A)

c 2 T (S1, S2, A) oe a permutation on S1

s(oe, c) 2 T (oeS1, S2, A)

This construction is subject to the following equations:

s(oe, i(f )) = i(*x.s(oe, f x)) s(oe, o(m, c)) = o(m, s(oe, c)) s(oe1, s(oe2, c)) = s(oe1; oe2, c)
By these equations, it is easy to see that every member of T (S1, S2, A) is equal to s(oe, c) forsome

c not containing a sub-term of the form s(oe0, c0). Therefore, computations are trees of outputtransitions-in-context and branching input transitions-in-context, with values at the leaves. The

action of the functor on permutations is given by either applying a permutation to the root of thetree, or to all leaves. Monad unit and multiplication are defined as above. Monoidal lifting is defined
by appending additional context to the left or right of each node of the tree.
4.3. Double Parameterised Freyd Categories
A double parameterised Freyd category is just a parameterised Freyd category with premonoidalstructure with respect to both of the domain categories. This grants us the capability of lifting a
computation to a larger state context as well as a larger value context.
Definition 8 A double parameterised Freyd category consists of three categories C, S and K,where C and S are symmetric monoidal, and five functors:

J : C * S ! K, !C : C * K ! K,=

C : K * C ! K, !S : S * K ! K and =S : K * S ! K, such that J is identity-on-objects and(
J, !C, =C) and (J, !S, =S) obey the obvious adaptations of the conditions of Definition 3.

This definition is somewhat more symmetric than that for parameterised monads. This is to beexpected, given that the focus of the definition of (parameterised) Freyd category is directly upon

Workshop on Mathematically Structured Functional Programming, MSFP 2006 11

Parameterised Notions of Computation
State Calculus: rules S-VAR and S-PRIM as for the Typed Command Calculus:

\Delta 1 `s s1 : S1 \Delta 2 `s s2 : S2

\Delta 1 on \Delta 2 `s (s1, s2) : S1 \Omega  S2 (S-\Omega I)

\Delta 1 `s s1 : S1 \Omega  S2 \Delta 2, z1 : S1, z2 : S2 `s s2 : S3

\Delta 1 on \Delta 2 `s let (z1, z2) = s1 in s2 : S3 (S-\Omega E)

I `s ?I : I (S-II)

\Delta 1 `s s1 : I \Delta 2 `s s2 : S
\Delta 1 on \Delta 2 `s let ?I = s1 in s2 : S (S-IE)

Value Calculus: as for Typed Command Calculus.
Command Calculus: rules C-V-S, C-PRIM, C-!E as for the Typed Command Calculus.

\Gamma ; \Delta 1 `c c1 : A1; S1 \Gamma , x : A1; \Delta 2, z : S1 `c c2 : A2; S2

\Gamma ; \Delta 1 ./ \Delta 2 `c let (x; z) ( c1 in c2 : A2; S2 (C-LET)

\Gamma ; \Delta 1 `c c1 : A1; S1 \Omega  S2 \Gamma , x : A1; \Delta 2, z1 : S1, z2 : S2 `c c2 : A2; S3

\Gamma ; \Delta 1 ./ \Delta 2 `c let (x; z1, z2) ( c1 in c2 : A2; S3 (C-LET-\Omega )

\Gamma ; \Delta 1 `c c1 : A1; I \Gamma , x : A1; \Delta 2 `c c2 : A2; S3

\Gamma ; \Delta 1 ./ \Delta 2 `c let (x; ?I) ( c1 in c2 : A2; S3 (C-LET-I)

FIGURE 3: Typing rules for the Monoidal Typed Command Calculus
computation in context, so it easier to extend the definition to multiple premonoidal structures, andso multiple kinds of computation in context.

Theorem 3 For an S-parameterised monad (T, j, u), given a monoidal lifting we can get apremonoidal structure with respect to S on C

T and vice versa. These operations are inverse.

Proof Given a monoidal lifting (S \Omega  -)#, define s !S c as c; (S1 \Omega  -)#; T (S1 \Omega  S01, s \Omega  S02, B); thesymmetric case is similar. Given premonoidal structure !

S, define (S \Omega  -)# = S !S idT (S1,S2,B),the symmetric case is again similar. These obey the required axioms by routine checking. In

particular, the two sets of naturality constraints are in one-to-one correspondence. That they aremutually inverse definitions can be seen by writing out the definitions and calculating, keeping in
mind the differences in composition in C and CT . \Lambda 
5. MONOIDAL TYPED COMMAND CALCULUS
We now extend the calculus of Section 3 so that it is sound and complete for closed doubleparameterised Freyd categories. We call the extended calculus the Monoidal Typed Command
Calculus. The changes to the typing rules are shown in Figure 3. The terms, types and rules forthe value calculus are unchanged, except by the larger range of state type constructors:

S ::= X 2 TS | I | S1 \Omega  S2
State contexts are now lists of state manipulation variables and state type pairs, ranged over by\Delta  and with the condition that no variable appear more than once. We define the joining relation

- ./ - = - on triples of contexts by the following clauses:

I ./ I = I (\Delta 1, x : A) ./ \Delta 2 = (\Delta 1 ./ \Delta 2), x : A \Delta 1 ./ (\Delta 2, x : A) = (\Delta 1 ./ \Delta 2), x : A
Given contexts \Delta 1, \Delta 2, we write \Delta 1 ./ \Delta 2 to stand for any context \Delta 3 such that \Delta 1 ./ \Delta 2 = \Delta 3.
The state calculus has additional rules for introducing and eliminating pair and unit types, followingthe standard term constructs for substructural calculi. The command calculus retains the rules

C-V-S, C-PRIM and C-!E.
There are now three sequencing constructs in the command calculus, typed by the rules C-LET,

C-LET-\Omega  and C-LET-I. All the rules type the execution of a command c1, lifted up to the context of(\Gamma ; \Delta 

2), followed by the execution of a second command c2. The rule C-LET differs in this calculus

Workshop on Mathematically Structured Functional Programming, MSFP 2006 12

Parameterised Notions of Computation
from the one in the Typed Command Calculus by allowing computation in a state context, as wellas in a value context.

The three sequencing rules differ in the de-structuring of the state output of the first term. The

C-LET rule does no de-structuring and passes the state output of c1 directly into c2. Rule C-LET-\Omega takes a state pair from

c1 and splits it into two separate variables in c2's context. Rule C-LET-Itakes a unit state and discards it. To see why these constructs are needed, consider the following

example. Assume we have a primitive command p : (1, I) ! (1, S \Omega S). We can use this commandin a sequencing construct:

let (x; z) ( p(*1, *I) in . . .
However, without C-LET-\Omega  there would be no way to decompose the variable z bound in the bodyof this expression in a way that would allow us to use the components in two different commands.

Assuming two commands c1 and c2 with free variables z1 and z2 respectively, the use of C-LET-\Omega allows us to use the output of

p in both:

let (x; z1, z2) ( p(*1; *I ) in let (x; z01) ( c1 in let (x; z02) ( c2 in . . .
The C-LET-I rule fulfils a similar role in eliminating variables of type I.

5.1. Example
The operations read and store and the state manipulation function clear from the typed side-effectsexample above can be typed in the calculus as primitive operations like so:

read : (1, [A]) ! (A, [A]) store : (A, \Sigma ) ! (1, [A]) clear : [A] ! \Sigma 
Using these, we can write the following function which takes three storage cells, two containingintegers and the third of indeterminate type and adds the contents of the first two, placing the
result in the third and forgetting the types of the contents of the first two cells.

*(x; z).let (?; i, o) ( (?; z) in let (?; i1, i2) ( (?; i) inlet (

a; i1) = read (?; i1) in let (b; i2) = read (?; i2) inlet (
?; o) = store (a + b; o) in (?; ((clear i1, clear i2), o)): (1
, ([Int] \Omega  [Int]) \Omega  \Sigma ) ! (1; (\Sigma  \Omega  \Sigma ) \Omega  [Int])

5.2. Equational Theory and Soundness and Completeness
The equational rules for the Monoidal Typed Command Calculus are presented in Figure 4,supplemented by axioms, reflexivity, symmetry, transitivity and congruence as usual. The rules
for the value calculus are unchanged. The state calculus now has additional fij rules for bothof the type constructors. We use Ghani's generalised

j rule [3], which eliminates the need forcommuting conversions.

The command calculus retains the inclusion of value and state equalities, the fij rules for theunary sequencing construct and the

fi rule for functions from before. There are also fij rules for thepair and unit sequencing constructs. There are also two

fi rules for the pair and unit sequencingconstructs that cross the divide between eliminations of product and unit types performed in

the command calculus and those performed in the state calculus. This is required to establishcompleteness. Finally, there are three sets of commuting conversion rules.

As before the equational rules generate three equational judgements of the form \Gamma  `v e1 = e2 : A,\Delta  `

s s1 = s2 : S and \Gamma ; \Delta  `c c1 = c2 : A; S. By extending the interpretation sketched above,

the equational theory so generated is sound and complete for closed double parameterised Freydcategories. See [1] for the proof.

Theorem 4 The Monoidal Typed Command Calculus is sound and complete for closed doubleparameterised Freyd categories.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 13

Parameterised Notions of Computation
State Calculus:

let (z1, z2) = (s1, s2) in s3 = s2[s1/z1, s2/z2]
let (z1, z2) = s1 in s2[z1 \Omega  z2/z] = s2[s1/z]

let ?I = ?I in s2 = s2
let ?I = s1 in s2[?I/z] = s2[s1/z]

Value Calculus: as for the Typed Command Calculus.
Command Calculus:

e1 = e2 s1 = s2

(e1; s1) = (e2; s2)

let (x; z) ( (e; s) in c = c[e/x, s/z]
let (x; z) ( c in (x; z) = c
let (x; z1, z2) ( (e; (s1, s2)) in c = c[e/x, s1/z1, s2/z2]
let (x; z1, z2) ( c in (x; (z1, z2)) = c

let (x; ?I) ( (e; ?I) in c = c[e/x]
let (x; ?I) ( c in (x; ?I) = c

(*!(x, z).c)@!a = let (x; z) ( a in c
let (x; z1, z2) ( (e1; s1) in (e2; s2) = (e2[e1/x]; let (z1, z2) ( s1 in s2)

let (x; ?I) ( (e1; s1) in (e2; s2) = (e2[e1/x]; let ?I = s1 in s2)

C[let (x; z) ( c1 in c2] = let (x; z) ( c1 in C[c2]
C[let (x; z1, z2) ( c1 in c2] = let (x; z1, z2) ( c1 in C[c2]

C[let (x; ?I) ( c1 in c2] = let (x; ?I) ( c1 in C[c2]

C[-] = - | p C[-] | let (x; z) ( C[-] in c | let (x; z1, z2) ( C[-] in c | let (x; ?I) ( C[-] in c | e@!C[-]

FIGURE 4: Equational Rules for the Monoidal Typed Command Calculus

6. RELATED WORK
Computational monads [8, 9] have been extremely successful in providing a framework formodelling a large range of computational phenomena, such as dynamic name generation [16].
They have also be used to do effectful programming in pure functional languages [4]. Power andRobinson introduced Freyd Categories [12] as an alternative presentation of strong monads.

Effect Systems [6] augment traditional type systems with information about the side-effectscaused by a program's execution. Wadler [19] has presented a connection between effect systems
and monads indexed by effect types. The difference between the indexed monads presented byWadler and our parameterised monads is that the indexed monads are indexed by one variable
representing the effects encapsulated by that monad, whereas our parameterisation representsthe start and finish states of the effectful computation.

7. CONCLUSIONS
We have presented generalisations of Moggi's computational monads and Power et al's Freydcategories to cover parameterised effects, our main examples being typed side-effects and typed
I/O. By also considering monoidal parameterisation, our definitions also cover separated side-effects and multiple streams of I/O. We have also presented two typed

*-calculi which are soundand complete for the simple parameterisation and monoidal parameterisation cases.

For future work, we intend to consider the effect of indexed types so that the objects of theparameterising category can be refined with "names" of the regions of memory being referred
to. This should enhance the categorical structures to be able to interpret type systems such asthe Linear Language with Locations [10] and Alias Types [15]. The connection with Hoare logic

Workshop on Mathematically Structured Functional Programming, MSFP 2006 14

Parameterised Notions of Computation
needs to be further investigated, and there is an obvious analogy between the computation instate context we have considered here and the frame rule of Separation Logic [14].

Finally, Plotkin and Power's approach of deriving computational monads from algebras ofoperations and equations [11] should be adaptable to parameterised monads. We have already
done a small amount of work in this direction by deriving the global typed state monad above froma plausible algebra of lookup and update operations (see the appendix of [1]).

REFERENCES

[1] R. Atkey. Substructural Simple Type Theories for Separation and In-place Update. PhDthesis, University of Edinburgh, 2006.
[2] O. Danvy and A. Filinski. A functional abstraction of typed contexts. Techn. Report 89/12,Dept. of Comput. Sci., University of Copenhagen, 1989.
[3] N. Ghani. Adjoint Rewriting. PhD thesis, University of Edinburgh, 1995.[4] S. L. Peyton Jones and P. Wadler. Imperative functional programming. In Conf. Record of

20th Ann. SIGPLAN-SIGACT Symp. on Principles of Programming Langugages, POPL '93(Charleston, SC, Jan. 1993), pp. 71-84. ACM Press, 1993.
[5] P. B. Levy, J. Power, and H. Thielecke. Modelling environments in call-by-value programminglanguages. Inform. and Comput., 185(2), pp. 182-210, 2003.
[6] J. M. Lucassen and D. K. Gifford. Polymorphic effect systems. In Conf. Record of 15thAnn. ACM Symp. on Principles of Programming Languages, POPL '98 (San Diego, CA, Jan.

1988), pp. 47-57. ACM Press, 1988.[7] S. Mac Lane. Categories for the Working Mathematician, 2nd ed., Vol. 5 of Graduate Texts
in Mathematics. Springer-Verlag, 1998.[8] E. Moggi. Computational lambda-calculus and monads. In Proc. of 4th Ann. IEEE Symp.
on Logic in Computer Science, LICS '89 (Pacific Grove, CA, June 1989), pp. 14-23. IEEEComput. Soc. Press, 1989.
[9] E. Moggi. Notions of computation and monads. Inform. and Comput., 93(1), 55-92, 1991.[10] G. Morrisett, A. Ahmed, and M. Fluet. L

3: A linear language with locations. In P. Urzyczyn,

ed., Proc. of 7th Int. Conf. on Typed Lambda Calculi and Applications, TLCA 2005 (Nara,Apr. 2005), vol. 3461 of Lect. Notes in Comput. Sci., pp. 293-307. Springer-Verlag, 2005.

[11] G. Plotkin and J. Power. Notions of computation determine monads. In M. Nielsenand U. Engberg, eds., Proc. of 5th Int. Conf. on Foundations of Software Science and

Computation Structures, FOSSACS 2002 (Grenoble, April 2002), vol. 2303 of Lect. Notesin Comput. Sci., pp. 342-356. Springer-Verlag, 2002.
[12] J. Power and E. Robinson. Premonoidal categories and notions of computation. Math.Struct. in Comput. Sci., 7(5), 453-468, 1997.
[13] J. Power and H. Thielecke. Closed Freyd- and ^-categories. In J. Wiedermann, P. vamEmde Boas, and M. Nilesen, eds., Proc. of 26th Int. Coll. on Automata, Languages and

Programming, ICALP '99 (Prague, July 1999), vol. 1644 of Lect. Notes in Comput. Sci.,pp. 625-634. Springer-Verlag, 1999.
[14] J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In Proc. of17th Ann. IEEE Symp. on Logic in Computer Science, LICS 2002 (Copenhagen, July 2002),

pp. 55-74. IEEE Comput. Soc. Press, 2002.[15] F. Smith, D. Walker, and G. Morrisett. Alias types. In G. Smolka, ed., Proc. of 9th Europ.
Symp. on Programming, ESOP 2000 (Berlin, March/Apr. 2000), vol. 1782 of Lect. Notes inComput. Sci., pp. 366-381. Springer-Verlag, 2000.
[16] I. Stark. Names and Higher-Order Functions. PhD thesis, University of Cambridge, 1994.[17] H. Thielecke. Categorical Structure of Continuation Passing Style. PhD thesis, University of

Edinburgh, 1997.[18] P. Wadler. Monads and composable continuations. Lisp and Symb. Comput., 7(1), 39-56,
1994.[19] P. Wadler. The marriage of effects and monads. In Proc. of 3rd ACM SIGPLAN Int. Conf.
on Functional Programming, ICFP '98 (Baltimore, MD, Sept. 1998), pp. 63-74. ACM Press,1998. Also in ACM SIGPLAN Notices, 34(1), 63-74, 1999.

Workshop on Mathematically Structured Functional Programming, MSFP 2006 15