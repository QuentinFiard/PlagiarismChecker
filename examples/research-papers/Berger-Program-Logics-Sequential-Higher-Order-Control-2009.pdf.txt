

Program Logics for Sequential Higher-Order Control

Martin Berger
Department of Informatics, University of Sussex

Abstract. We introduce a Hoare logic for call-by-value higher-order functional languages with control operators such as callcc. The key idea is to build the assertion
language and proof rules around an explicit logical representation of jumps and their dual
'places-to-jump-to'. This enables the assertion language to capture precisely the intensional and extensional effects of jumping by internalising rely/guarantee reasoning, leading to simple proof rules for higher-order functions with callcc. We show that the logic
can reason easily about non-trivial uses of callcc. The logic matches exactly with the
operational semantics of the target language (observational completeness), is relatively
complete in Cook's sense and allows efficient generation of characteristic formulae.

1 Introduction
Non-trivial control manipulation is an important part of advanced programming and showsup in many variants such as jumps, exceptions and continuations. Research on axiomatic accounts of control manipulation starts with [10], where a simple, imperative first-order low-level language with

goto is investigated. Recently, this research tradition was revived by asequence of works on similar languages [2-4, 7, 24, 29, 32, 34]. None of those investigates the

interplay between advanced control constructs and higher-order features. The present paperfills this gap and proposes a logic for ML-like call-by-value functional languages with advanced control operators (callcc, throw). The key difficulty in axiomatising higher-ordercontrol constructs for functional languages (henceforth "higher-order control") is that program
logics are traditionally based on the idea of abstracting behaviour in terms of input/outputrelations. This is a powerful abstraction for simple languages but does not cater well for jumping, a rather more intensional form of behaviour. Consider the well-known program argfc def=
callcc lk.(throw k lx.(throw k ly.x)) [12]. This function normalises to a l-abstraction, but,as [28] investigates, distinguishes programs by application that are indistinguishable in the absence of continuations: (lx.(x 1); (x 2)) argfc = 1 and (lx.ly.(x 1); (y 2)) argfc argfc =2 with M; N being the sequential composition of M and N, binding more tightly than labstraction. The reason is that continuations carry information about contexts that may bereturned (jumped) to later. Thus, values in languages with higher-order control are no longer
simple entities, precluding logics based on input/output relations. Two ways of dealing withthe intensional nature of control manipulation suggest themselves:

- Using continuation-passing style (CPS) transforms [33] to translate away control manipu-lating operators and then reason about transformed programs in logics like [16] for functional languages.- Using a direct syntactic representation of intensional features.

We choose the second option for pragmatic reasons: It is difficult to reconstruct a program'sspecification from the specification of its CPS transform. This is because CPS transforms increase the size of programs, even where higher-order control is not used. This increases reason-ing complexity considerably. In contrast, in our approach programs or program parts that do

not feature higher-order control can be reasoned about in simpler logics for conventional func-tional languages. The more heavyweight logical apparatus for higher-order control is required
only where control is manipulated explicitly, leading to more concise proofs and specifications.
Key Elements of the Present Approach. This work makes three key proposals for a logicaltreatment of higher-order control.

- Names as an explicit representation of places to jump to, or being jumped to.- Jumps xh ~eiA as an explicit logical operator which says that a program jumps to x carrying a

vector ~e of values, and after jumping, A holds. Jumps are complementary to the evaluationformulae

xh ~eiA, studied in [5, 16, 18, 36], which means a jump to x carrying values ~e leadsto a program state where A holds.

- Rely/guarantee formulae {A}B and tensor A ffi B. {A}B says that if the environment is asspecified by

A, then the program together with the environment will act as constrainedby B. Likewise, A ffi B says a program has a part that is as described by A, and a part that

is as given by B. Rely/guarantee formulae generalise implication, and tensor generaliseconjunction because in e.g. A ^ (B oe C) a free variable must have the same type in A
as in B and C. With rely/guarantee formulae, we weaken this requirement: e.g. in xh2ui ^{xhvwiwhv+1i}uh3i the variable x is used to output in the left conjunct and for input in the
right conjunct, with the input occurring in the rely part of the rely/guarantee formula. Theleft conjunct says that the program jumps to x carrying 2 and u (an intensional specification
at x). The right conjunct says that if the environment offers a function to be invoked at xthat computes the successor of its first argument and returns the result at the second, then
the jump to u carrying 3 will happen, a more extensional specification in that the programtogether with the assumed environment behaves as a function. Similarly,

xh3i ffi xh3iA usesx with different polarities, specifying a program that contains a jump to x carrying 3 to a

target for this jump.
Informal Explanation. Operationally, a program, for example the constant 5, can be seen as avalue-passing jump carrying 5 to some distinguished name, called

default port, left implicit inthe language, but made explicit in implementations, usually as a return address on the stack. It

can be left implicit in the absence of higher-order control because there are no alternatives forreturning: every function, if it returns at all, does so at the default port. Higher-order control
breaks this simplicity: for example throw k 5 will jump to k and not to the default port. Ourlogic deals with multiple return points by

naming the default port in judgements, giving rise tothe following shape of judgements (for total and partial correctness):

M :u A
It asserts that the program M satisfies the formula A, assuming that M's default port is namedu (we do not need preconditions because they can be simulated using rely/guarantee formulae,

see below). Using explicit jumps we can specify:

5 :u uh5i throw k 5 :u kh5i.
The left-hand side says that the program 5 terminates and jumps to the default port u carrying5 as a value. The assertion on the right expresses that

throw k 5 also terminates with a jumpcarrying 5, but now the jump is to
k, which is not the default port.Evaluation formulae are used to specify the behaviour of functions. When a function like

lx.x + 1 is invoked, the result is returned at the default port of the invocation. As functions can

be invoked more than once and in different contexts (in the present context, invoking a functionf is the same as jumping to f , and we use both phrases interchangeably), different default ports
are needed for different invocations. In implementations, a dynamically determined place onthe stack is used for this purpose. In addition, when a l-abstraction like l

x.x + 1 is evaluated,the l-abstraction itself, i.e. lx
.x + 1, is returned at its default port. To express such behaviourwe use the following specification (writing

u(a)A for 9a.uhaiA, and a(xm)A for 8xm.ahxmiA).

lx.x + 1 :u u(a)a(xm)mhx + 1i
This judgement states that the abstraction returns a name a at the default port. This name canbe jumped

to (i.e. invoked) with two arguments, a number x and a name m, the default port forinvocations of a. If invoked, the successor of x will be returned at m.

The role of rely/guarantee formulae is to generalise and internalise preconditions. Considerthe application g 3. If jumps to g with two arguments, a number x and a return port u, yield a
jump uhx + xi then the evaluation of g 3 with default port u should induce a jump uh6i. In aprogram logic with preconditions, we would expect to be able to derive {

g(xm)mhx + xi} g 3 :u{uh6i}. With rely/guarantee formulae we can express this by defining

{A} M :m {B} def= M :m {A}B.
The advantage of internalising preconditions with rely/guarantee formulae are threefold. (1)Key structural relationships between jumps and evaluation formulae are easily expressible as

axioms like: xh ~ei oe {xh ~eiA}A. It states that e.g. a jump gh3ui makes A true whenever theenvironment guarantees that jumps

to g with arguments 3 and u will validate A. (2) We gainmore flexibility in localising and manipulating assumptions, leading to more succinct and compositional reasoning. To see why, consider a complicated formula C[xh2i] containing a jump
to x. Using the axiom just given, and setting A def= xh2iuh3i, we know that xh2i oe {A}uh3i,hence

C[xh2i] implies C[{A}uh3i]. Such reasoning is cumbersome if all assumptions have tobe concentrated in the precondition. Moreover, local hypotheses can be collected, i.e. we can

usually infer from C[{A}uh3i] to {A}C[uh3i], hence conventional reasoning based on rigid pre-/postconditions remains valid unmodified without additional cost (all relevant rules and axioms
are derivable). The added fluidity in manipulating assumptions is vital for reasoning about in-volved forms of mutually recursive jumping. (3) Finally, the most important virtue of internalising preconditions is sheer expressive power. With rely/guarantee formulae, it easy to use
different assumptions in a single formula: consider A def= g(xm)mhx + xi and B def= g(xm)mhx * xi.We can now specify g 3 :

u ({A}uh6i) ^ {B}uh9i. This expressiveness enables convenient rea-soning about complicated behavioural properties of programs that would be difficult to carry

out otherwise.
Contributions. The present work provides the first general assertion method with composi-tional proof rules for higher-order functions with functional control (

callcc and similar op-erators) and recursion under the full type hierarchy. The work identifies as key ingredients in

this approach: (1) An explicit representation of jumps in formulae, which can specify inten-sional aspects of control operators in a uniform manner. (2) Rely/guarantee formulae and an
associated tensor to facilitate local specification of extensional as well as intensional aspectsof higher-order control, and to enable complicated forms of reasoning not otherwise possible.
(3) Proof rules and axioms that capture the semantics of PCF+precisely, as demonstrated bystrong completeness results. Missing proofs can be found in the full version of this paper.

2 PCF With Jumps
Now we define our programming language. We extend PCF with callcc and throw, and callthe resulting language

PCF+. Arguments are evaluated using call-by-value (CBV). Later webriefly consider u
PCF, a variant of CBV PCF with different control operators. The relationshipbetween both is explained in [21].

Types, terms and values are given by the grammar below.Sums, products and recursive types for

PCF+ are straightforward and are discussed in the fullversion of this paper.

a ::= N || B || Unit || a ! b || (a)? V ::= x || c || lxa.M || rec f a.lxb.M
M ::= V || MN || op( ~M) || if M then N else N0 || callcc || throw

Here (a)? corresponds to (a cont) in SML and is the type of continuations with final answertype a,

c ranges over constants like 0, 1, 2, ..., op over functions like addition. We write e.g. ab3for the vector ha

,b, 3i, ~M for the vector hM0,..., Mn-1i, etc; x, f , ... range over variables. Namesare variables that can be used for jumping. The notions of

free variables fv(M) and boundvariables
bv(M) of M are defined as usual. Typing judgements \Gamma  ` M : a are standard, with \Gamma being a finite, partial map from variables to the types a.

From now on we assume all occurringprograms to be well-typed. The semantics of
PCF+ is straightforward, cf. [28].

3 The Logic
This section defines the syntax and semantics of the logic. Since variables in programs aretyped, and the logic speaks about such variables, our logic is typed, too. Types are those of

PCF+, with two generalisations. (1) We add a type ( ~a)! which is the type being-jumped-to with
arguments typed by the vector ~a. (2) We no longer need function spaces, because e.g. a def=
N ! B can now be decomposed into affi def= (N(B)?)!. Type affi holds of names that can bejumped to with two arguments, first a number and then another name, which might be used for

subsequent jumps carrying a boolean. This is the behaviour of functions N ! B under call-by-value evaluation. If we denote by a the result of changing all occurring ? in a into ! and vice
versa, and if we denote by affi the result of translating PCF+ types as just described, then:

(a ! b)ffi = (affi(bffi)?)!.
Our types are given by the grammar:

a ::= N || B || Unit || (a)? || (ab)? || (a)! || (ab)!
Types play essentially the same role in our logic as they do in programming languages, namelyto prevent terms that do not make sense, like x = 5 +

t or xh3i ffi xhiA. Since our use of types isstraightforward, the reader can mostly ignore types in the remainder of the text, as long as he

or she bears in mind that all occurring formulae and judgements must be well-typed. (Furtherinformation about this typing system is given in [15].)

Expressions, Formulae, Assertions. Expressions are standard (e ::= x || c || op( ~e)) and for-mulae for our logic are generated by the following grammar.

A ::= e = e0 || A ^ B || ~A || 8xa.A || xh ~eiA || xh ~eiA || {A}B || A ffi B

Variables, constants and functions are those of $2. Standard logical operators such as T im-plication and existential quantification are defined as usual. We often omit type annotations.
Logical operators have the usual rules of precedence, e.g. 8x.A^B should be read as 8x.(A^B),
A ffi B ^C as (A ffi B) ^C, and {A}B ^C is short for ({A}B) ^C. We write fv(A) for A's free vari-ables, and A-x indicates that x

/2 fv(A). Names are also variables. Typing environments, \Gamma , \Delta , ...are defined as finite maps from names to types. Typing judgements for expressions \Delta  `

e : a andformulae \Delta  ` A are defined as usual, e.g. x must be of type N in x + 3 = 2. The new operators

are typed as follows.

- \Gamma  ` xh ~eiA if \Gamma  ` x : ( ~a)?, \Gamma  ` ei : bi, bi 2 {ai, ai} and \Gamma  ` A.- \Gamma  `

xh ~eiA if \Gamma  ` x : ( ~a)!, \Gamma  ` ei : bi, bi 2 {ai, ai} and \Gamma  ` A.- For rely/guarantee formulae \Gamma  ` {A}B we say x is compensated in A if the type of x in A is

dual to that in \Gamma . For example xh2yi oe {xh2yiyh3i}B is typable under \Delta  def= x : (N(B)!)?, y :(B)?.

We write e.g. xhy*iA to stand for any xhyziA such that z is fresh and does not occur in A, andlikewise for evaluation formulae. We write

xh ~e(y)iA for 9y.xh ~eyiA, assuming y not to occur in~e. Judgements, also called assertions, are of the form M :

m A. Judgements must be well-typed,i.e. M and A must be well-typed and the variables common to A and M must be given consistent

types, e.g. g 3 :u {gh4uiT}2 = 3 is well-typed, but g 3 :u {ghziT}2 = 3 is not.
Examples of Assertions. We continue with simple examples of assertions.

- Let A def= g(xk)(even(x) oe k(a)even(a)). This first example specifies a place g to jump to.If a jump to g happens carrying an even number x as first argument and k, the default port,

then that invocation at g will return at its default port, carrying another even number. Adoes not specifying anything if x is odd.

- Next consider the following formulae. A def= x(kr)(kh7i . rh8i) and B def= {A}u(m)(m =7 .

m = 8) A specifies a place x to jump to with two arguments, k and r (the default port),both of which are used for jumping: either jumping to k carrying 7, or jumping to the

default port carrying 8. B specifies a jump to u carrying 7 or 8, provided the environmentprovides a place to jump to at x, as just described by A.

- Now consider the formula A def= x(ab)ahbbi. It says that if we jump to x carrying twoarguments,

a and b, both being used for jumping, then the invocation at x replies with ajump to a, carrying b twice. Figure 2 shows that u(x)A specifies the behaviour of

callcc,assuming
u as default port.

- Finally, consider the following formula. A def= n(b)b(xy)n(c)c(zr)rhxi. The formula A spec-ifies a jump to

n, carrying a function b that can be jumped to with two arguments, x and y.Of those,
y is subsequently ignored. If b is invoked, it jumps to n again, carrying anotherfunction c, which also takes two arguments, z and r. Of these z is also ignored, but r is

jumped to immediately, carrying x. It can be shown that A specifies argfc.
Models and the Satisfaction Relation. This section sketches key facts about the semantics ofour logic and states soundness and completeness results. We use a typed p-calculus to construct
our semantics. This choice simplifies models and reasoning about models for the followingreasons.

- Models and the satisfaction relation need to be built only once and then cater for manydifferent languages with functional control like

PCF and uPCF. Thus soundness of ax-ioms needs to be proven only once. Proving soundness and completeness is also simpler

with p-calculus based models because powerful reasoning tools are available, e.g. labelledtransitions, that languages with higher-order sequential control currently lack.
- Using processes, the semantics is simple, intuitive and understandable, as well as capturingbehaviour of higher-order control precisely. The typed processes that interpret

PCF+ oru
PCF-programs are up to bisimilarity exactly the morphisms (strategies) in the controlcategories that give fully abstract models to

PCF+ or uPCF[13, 21]. Hence the presentchoice of model gives a direct link with game-based analysis of control.

Processes. The grammar below defines processes with expressions e as above, cf. [17] fordetails.

P ::= 0 || xh ~ei || !x( ~v).P || (nx)P || P|Q || if e then P else Q
We can use this calculus to give fully abstract encodings of PCF+ and uPCF [17, 21]. Transla-tion is straightforward and we show some key cases.

[[lx.M]]u def= u(a)!a(xm).[[M]]m [[throw]]u def= u(a)!a(xm)m(b)!b(y*)xhyi

[[MN]]u def= (nm)([[M]]m|!m(a).(nn)([[N]]n|!n(b).ahbui)) [[callcc]]u def= u(a)!a(xm).xhmmi

This translation generalises a well-known CPS transform [33]. All cases of the translation aresyntactically essentially identical with the corresponding logical rules. This simplifies soundness and completeness proofs and was a vital rule-discovery heuristic.
The Model and Satisfaction Relations. Models of type \Gamma  are of the form (P, x) where P is aprocess and x maps values names and variables to their denotation. We write |=

M :m A if forall appropriately typed-models (P
,x) with m fresh in x we have

([[M]]mx|P,x) |= A
This satisfaction relation works for total and partial correctness, since termination can be statedexplicitly through jumps in total correctness judgements. On formulae, the satisfaction relation

is standard except in the following four cases, simplified to streamline the presentation (here,
= is the contextual congruence on typed processes).

- (P, x) |= xhyi if P ,= Q|ahbi, x(x) = a, x(y) = b.- (P

, x) |= xhyiA if P ,= Q|!a(v).R with x(x) = a and (P|ahx(y)i, x) |= A.- (P
, x) |= {A}B if for all Q of appropriate type (Q, x) |= A implies (P|Q, x) |= B.- (P
, x) |= A ffi B if we can find Q, R such that P ,= Q|R, (Q, x) |= A and (R, x) |= B.

The construction shows that rely/guarantee formulae correspond to (hypothetical) parallelcomposition [20].

4 Axioms and Rules
This section introduces all rules and some key axioms of the logic. We start with the latter andconcentrate on axioms for jumps, tensor and rely/guarantee formulae. Some axioms correspond

closely to similar axioms for implication and conjunction. All axioms and rules are included
in the logic exactly when they are typable.

Axioms for Dynamics. We start with the two axioms that embody the computational dynamicsof jumping. The first expresses the tight relationship between jumping and being-jumped-to
(evaluation formulae):

uh ~eiA ffi uh ~eiB oe A ffi B (CUT)
[CUT] says that if a system is ready to make a jump to u, say it satisfies uh ~eiA, and if the systemalso contains the target for jumps to

u, i.e. it satisfies uh ~eiB, then that jump will happen, and
A ffi B will also be true of the system.The next axiom says that a jump xh ~eiA which guarantees A implies the weaker statement

that if the environment can be jumped to at x with arguments ~e, then B holds, provided theenvironment can rely on A in its environment.

xh ~eiA oe {xh ~ei{A}B}B (XCHANGE)
Further Axioms for Tensor and Rely/Guarantee Formulae. Now we present some axiomsfor the tensor that show its close relationship with conjunction. In parallel, we also exhibit
axioms for rely/guarantee formulae that relate them with implication. As before, we assumethat both sides of an entailment or equivalence are typed under the same typing environment.
This assumption is vital for soundness, as we illustrate below.

A ffi B j A ^ B A ffi B oe A A oe {B}A
A ffi (B ffiC) j (A ffi B) ffi A (8x.A) ffi B-x j 8x.(A ffi B) {A}{B}C j {A ffi B}C

A ffi B j B ffi A {A}B j A oe B B ffi {B}A oe A

Our explanation of these axioms starts on the left. The first axiom says that if A ^ B are typablethen tensor is just conjunction. This does not imply that xh3i ffi xh3iA is equivalent to xh3i ^

xh3iA, since xh3i ^ xh3iA is not typable. However (x = 3 ffi y = 1) j (x = 3 ^ y = 1) is valid.The next two axioms below state associativity and commutativity of tensor. The top axiom in
the middle shows that tensor is not like parallel composition, because the tensor can "forget"their component formulae. The axiom below shows that tensor associates as expected with
quantification. The bottom axiom in the middle shows that rely/guarantee formulae reduce toimplication if all free variables have the same type in

A as in B, i.e. ({xh ~eia}xhei) j ((xh ~eia) oexhei) is not a valid instance of the axiom, but ({xh ~eia}xh ~eib) j ((xh ~eia) oe xh ~eib) is. The top

right axiom shows that it is possible to weaken with a rely formula. The middle axiom onthe right shows how to merge two assumptions in rely/guarantee formulae. The bottom right
axiom can be seen as a typed form of Modus Ponens, and we call it [MP]. The expected formsof weakening also hold, i.e. if

A oe A0 then A ffi B implies A0 ffi B, {A0}B implies {A}B and {B}Aimplies {B}A0.

Further Axioms for Jumps and Evaluation Formulae. Before moving on to rules, we presentsome axioms for jumps and evaluation formulae.

xh ~ei(A ^ yh ~giB) j yh ~gi(B ^ xh ~eiA) xh ~eiT j TA ffi (xh ~eiB) j xh ~ei(A ffi B) xh ~ei ^ yh ~gi oe (x = y ^ ~e = ~g)
The top left axiom states that free variables like x and y that can be jumped to, are 'alwaysthere', i.e. they cannot come into existence only after some function has been invoked. The top
right axiom says that places to jump to cannot 'refuse' arguments: in other words, the statement

xheiT carries no information. This axiom is called [NOINFO]. The bottom left axiom says thatif a program contains a part that jumps at x then the program as a whole can also jump at x,
provided that the program does not contain a component that offers an input at x (not offeringan input at x is implicit in typability of the axiom). Finally, the last axiom expresses that our
language is sequential: at most one jump can happen at any time.

M :m Alx
.M :u u(a)a(xm)A A

BS lx.M :u u(a)Arec g.lx.M :u u(a)9g.(fwga ffi A) REC -c :u uhci CONST

M :m A N :n BMN :
u 9m.(A ffi m(a)9n.(B ffi n(b)ahbui))

APP -callcc :u u(a)a(xm)xhmmi CCC -x :u uhxi VAR

-
throw :u u(a)a(xm)m(b)b(y*)xhyi T

HROW M :m A N :u BM + N :u 9m.(A ffi m(a)9n.(B ffi n(b)uha + bi)) ADD

M :m A N :u B N0 :u C
if M then N else N0 :u 9m.(A ffi m(a)((a = t oe B) ^ (a = f oe C))) I

F M :u A A oe BM :u B CONS

Fig. 1. Total Correctness rules for PCF+. The forwarder is given by fwxy def= x( ~v)yh ~vi.

Rules for PCF+. The total correctness rules for PCF+ are given in Figure 1. Rules are subjectto straightforward well-formedness conditions. From now on we assume all rules to be welltyped. We explain the rules in some detail. As [VAR, CONST, ABS] have already been sketchedin the introduction, we start with the rule for application. The purpose of [A

PP], the rule forfunction application, is to ensure the coordination of functions and their invocations by jumps.

One issue is the generation and management of default ports: the present approach requiresthat a (terminating) function application

may return its result at the application's default port,assuming the evaluations of the function itself, and that of the argument return their respective

results at (distinct) default ports themselves. [APP] achieves this by explicitly representing thesequence of jumps that are integral parts of evaluating a function application. First the jump
to the default port of the function is received by an evaluation formula at m. It receives anargument

a. Then the evaluation of the argument is triggered, and its result, should it return atthe fresh default port n, is received by a second evaluation formula at n. Finally, should both,

the function and its argument return at their respective default ports, a jump to a carrying b andthe application's default port u is executed. By typing we know that the jump to a must find an
evaluation formula expecting two arguments.Why do we have to represent the internals of application evaluation in the logic explicitly,
rather then have them implicit as in the simpler logics for PCF [16]? After all, even in PCF,these jumps take place, albeit behind the scenes. The answer is that because of continuations,
functions can return more than once, i.e. can jump to their default port more than once. Thefunction

argfc from the introduction is an example of such behaviour. The axiomatisation of
PCF in [16] hides default ports, because programs cannot return anywhere but at default ports.It might not be possible to give a logical account of returning to a port more than once without

explicit representation of default ports.Representing jumps and default ports in a single formula, as we do in [A

PP], has ramifica-tions for typing: when names (like m
, n above) are used in a formula for both, jumping, and forbeing-jumped-to we need to mediate, in a controlled way, the rigidity of typing, that enforces

all names to be used under the same typing. Our rules use tensor for this purpose. All rules

can be stated without tensors using just rely/guarantee formulae, but, it seems, not without amaking the inference system more complicated.

Using [APP], setting A def= 9m.((m(a)a(xu)uhx + 1i) ffi m(a)9n.(nh7i ffi n(b)ahbui)) and as-suming that l

x.x + 1 :m m(a)a(xr)rhx + 1i, we infer:

1 lx.x + 1 :m m(a)a(xr)rhx + 1i
2 7 :n nh7i CONST
3 (lx.x + 1)7 :u A APP, 1, 2
The expected judgement (lx.x + 1)7 :u uh8i, is by [CONS] and the following implication :

A oe 9a.((a(xu)uhx + 1i) ffi 9n.(nh7i ffi n(b)ahbui)) oe 9a.((a(xu)uhx + 1i) ffi 9n.ah7ui)oe 9

a.((a(xu)uhx + 1i) ffi ah7ui) oe uh8i

This implication follows from [CUT] and simple logical manipulations.As second example we consider the application g x, with an assumption on the behaviour

of g. The intent is to illuminate the use of rely/guarantee formulae and the [XCHANGE] axiom.
Let A def= even(x) ^ g(xk)(even(x) oe k(a)even(a)). We want to show that

{A} gx :u {u(a)even(a)}, (1)
recalling that {B} M :m {C} is short for M :m {A}B. First we reason as follows.

1 g :m mhgi VAR
2 x :n nhxi VAR
3 gx :u 9m.(mh f i ffi m(a)9n.(nhxi ffi n(b)ahbui)) APP, 1, 2
4 {A} gx :u {u(a)even(a)}. CONS, 3

The interesting step is the last, where we reason as follows.

9m.(mhgi ffi m(a)9n.(nhxi ffi n(b)ahbui)) oe 9m.(mhgi ffi m(a)9n.(ahxui)) oe9m

.(mhgi ffi m(a)ahxui) oe 9m.ghxui oe ghxui

The first and third inferences use [CUT], the two others remove unused quantifiers. Theorem 1shows that

ghxui is an optimal specification for our program in the sense that anything that canbe said at all about the program gx with anchor u can be derived from ghxui. We continue by

deriving (1), using B def= even(x) oe u(a)even(a).

ghxui oe {ghxui(even(x) ^ B)}(even(x) ^ B) oe {g(xu)(even(x) ^ B)}(even(x) ^ B)oe {

A}u(a)even(a)

The first implication is by [XCHANGE], the others are straightforward strengthening of theprecondition, and simple first-order logic manipulations. Now (1) follows by the consequence

rule.The derivation above has a clear 2-phase structure: first a general assertion about the behaviour of the application is derived without assumptions on free variables. Then such as-sumptions are added using [

XCHANGE] and the consequence rule. It is noteworthy that thefirst phase is mechanical by induction on the syntax of the program, while the second phase

takes place without reference to the program. It is possible to use a more traditional style ofreasoning, where applications of languages rules and [C

ONS] are mixed, but this tends to makeinferences longer.

Like the rule for application, [REC] is an adaption of the corresponding rule in [16], butforwarding all jumps to the recursion variable g directly to the recursive function at a. This
forwarding corresponds to "copy-cat strategies" in game-semantics [1, 19], here realising thefeedback loop of jumps to f into a that enables recursion by using tensor. [R

EC] implies amore convenient rule, given as follows.

lx.M :m m(a)8 j fi i.{A[g/a][ j/i]}A

rec g.lx.M :m m(a)8i.A

REC'

As first example of using [REC] we consider a simple function w def= rec g.lx.gx that divergesupon invocation. Since our rules and axioms are for total correctness, we should not be able
to specify anything about w, except that it terminates and returns at its default port when eval-uated as an abstraction, i.e. we show: w :

u u(a)a(xu)T. Mechanically we infer the followingjudgement

w :u u(a)9g.(fwga ffi a(xk)ghxki)
We use axiomatic reasoning to obtain w :u u(a)a(xu)T by [CONS].

u(a)9g.(fwga ffi a(xk)ghxki) oe u(a)9g.(fwga ffi a(xk){ghxkiT}T) oe
u(a)9g.(fwga ffi {ghxkiT}a(xk)T) oe u(a)9g.(fwga ffi {fwga}a(xk)T) oe
u(a)9g.a(xk)T oe u(a)a(xk)T

The first line uses [XCHANGE], the next pushes the assumption of the rely/guarantee formulato the left of the evaluation formula. Then we simply replace that assumption by

fwga. We cando this, because that strengthens the assumption, i.e. weakens the rely/guarantee formula. Then

we apply [MP]. The last line removes the superfluous quantifier. We note that there is a simplerderivation of the same fact, relying on the implications:

u(a)9g.(fwga ffi a(xk)ghxki) oe u(a)T oe u(a)a(xk)T.
The first of those is just weakening of the tensor, while the second is an instance of [NOINFO].[C

CC] says that callcc is a constant, always terminating, and returning at the default port,carrying a function, denoted a, as value. This function takes two arguments, x, the name of

another function, and m, the default port for the invocation of a. By typing we know that mmust be a function invoked with an argument of continuation type (a)?. Whenever

a is invoked,it jumps to x, carrying its default port m as first and second argument. In other words, if the

invocation at x terminates at its default port, it does so at a's default port. Moreover, x can alsojump to m explicitly. Note that m is duplicated [C

CC], i.e. used non-linearly. This non-linearityis the reason for the expressive power of functional control.

We consider another example of reasoning about callcc: M def= callcc lk.7. Mechani-cally, we derive

M :u 9m.(m(a)a(xr)xhrri ffi m(a)9n.(n(b)b(ks)sh7i ffi n(b)ahbui))-- -z ""

A

Then we use axiomatic reasoning to reach the expected judgement M :u uh7i.

A oe 9a.(a(xr)xhrri ffi 9b.(b(ks)sh7i ffi ahbui)) oe 9ab.(a(xr)xhrri ffi ahbui ffi b(ks)sh7i)oe 9

ab.(bhuui ffi b(ks)sh7i) oe 9ab.uh7i oe uh7i

[THROW] says that throw is a function returning at its default port a function a which takes xas its first argument (by typing a continuation (a)?), and returns at its default port

m a secondfunction b, which in turn takes two argument, the first of which is y (of type a). The second

argument, the default port of y is ignored, since x will be jumped carrying y as argument.We continue with reasoning about simple programs with

throw. We show that:

throw k 3 :u kh3i w(throw k 3) :u kh3i.
We begin with the assertion on the left. The assertion for this program will be quite sizablebecause [A

PP] must be applied twice. The following abbreviation is useful to shorten specifi-cations arising from [A

PP].

A |mnu B def= 9m.(A ffi m(a)9n.(B ffi n(b)ahbui)).
Here we assume that u, n do not occur in M and u, m are not in N. We let |mnu bind lesstightly than all the other operators of the logic. This abbreviation is interesting because of the

following derived rule, which is immediate from the rules.

m(a)a(bu)A |mnu n(b)B oe 9ab.(A ^ B). (2)
From [THROW], k :b bhki and 3 :n nh3i we get:

throw k 3 :u (g(a)a(xm)m(b)b(y*)xhyi) |gbm bhki |mnu nh3i
which simplifies to throw k 3 :u kh3i by applying (2) twice. Now we deal with w(throw k 3).
As before: w(throw k 3) :u A with A def= m(a)a(bu)T |mnu kh3i, but we cannot apply (2) since
throw k 3 does not return at the default port. Instead we reason from the axioms.

9n.(kh3i ffi n(b)ahbui) oe 9n.kh3i(T ffi n(b)ahbui) oe kh3i9n.(T ffi n(b)ahbui) oe kh3i
Here the first line is an application of [CUT], the second switches quantification with a jump,and the third line is by [N

OINFO], in addition to straightforward logical manipulations. Thuswe can use [C
UT] once more and infer:

m(a)a(bu)T |mnu kh3i oe 9m.((m(a).a(bu)T) ffi m(a)kh3i) oe 9mb.((a(bu)T) ffi kh3i)oe

kh3i9mb.((a(bu)T) ffi T) oe kh3i

[IF] simply adds a recipient for the default port at M, the condition of the conditional, wherea boolean b is received. Depending on b, the specification of one of the branches is enabled.

[ADD] is similar to [APP] and the [CONS], the rule of consequence, is standard in programlogics.

A Comment on the Shape of Rules. Program logics are usually presented "bottom-up", mean-ing that postconditions in the conclusion of rules are just a meta-variable standing for arbitrary
(well-typed) formulae. This facilitates reasoning starting from a desired postcondition of the

program under specification, and then trying to find an appropriate premise. We have chosenthe "top-down" presentation because it gives simpler and more intuitive rules, and shortens inferences substantially. A "bottom-up"presentation of proof rules is possible, and may be usefulin some cases. The status of the "bottom-up" rules (e.g. completeness) is yet to be established.

Completeness. A goal of axiomatic semantics is to be in harmony with the corresponding op-erational semantics. That means that two programs should be contextually indistinguishable if
and only if they satisfy the same formulae. This property is called observational completeness.We establish observational completeness as a consequence of descriptive completeness.

Definition 1. By v we mean the standard typed contextual precongurence for PCF+, i.e. M v
N if for C[M] + implies C[N] + for all closing contexts C[*], where + means termination.

Theorem 1. (Descriptive Completeness for Total Correctness) Our logic is descriptively com-plete

: for all closed M, N (typable under the same typing), A and m, we have: ` M :m A impliesthat (1) |= M :

m A and (2) whenever |= N :m A then M v N.

The proof of this theorem, and the derivation of observational completeness (as well as relativecompleteness in the sense of Cook) from descriptive completeness follows [14].

The lu-Calculus. From the rules and axioms for PCF+, it is easy to derive a logic for uPCF,an extension of the lu-calculus, a Curry-Howard correspondence for classical logic, with a
recursion operator. The logic enjoys similar completeness properties.

M :m A N :u BM + N :
u 9mn.(A ^ B ^ u = a + b)

SADD M :m Alx.M :u uhxim A SABS M :m Alx.M :u uhxmiA SABS'

lx.M :u A
rec g.lx.M :u 9g.(fwga ffi A) SR

EC M :m A N :n BMN :u 9mn.((A ^ B) ffi mhnui) SAPP M :m mhniu A N :n BMN :u 9mn.(A ^ B) SAPP'

-
callcc :u u(xm)xhmmi SC

CC -throw :u uhxim m(y*)xhyi STHROW -x :u u = x SVAR

-c :u u = c SCONST M :m A N :u B N0 :u C

if M then N else N0 :u 9m.(A ffi (m = t oe B) ^ (a = f oe C)) SI

F

M :u A A oe BM :

u B SC

ONS M :n 9 ~a.(mheiu A ffi mheniB)M :u 9 ~a.(A ffi B) SCUT

Fig. 2. Some derived rules that are useful for reasoning about PCF+ programs that return at their default
port.

5 Simplifying Reasoning
PCF-terms are a subset of PCF+-terms. Reasoning about PCF-terms using the logic for PCF+is moderately more laborious than using a logic tailor-made for

PCF like [16]. This is becauseintermediary jumps in function application are represented explicitly in the former, but not the

latter. Reasoning in $4 about simple programs like (lx.x + 1)7 and throw k 3 suggest thatintermediate jumps can be eliminated mechanically in applications where a function and its
argument return at the default port. We formalise this intuition and obtain simplified derivablelogical rules and axioms, that can be used to reason about a large class of programs, including

PCF+ programs that do use functional control. We start by defining two syntactic shorthandsthat apply only to judgements and evaluation formulae that return at their default ports (u
fresh in both):

M :m A def= M :u u(m)A xh ~eim A def= 8u.xh ~euiu(m)A
We write x( ~y)m A for 8 ~y.xh ~yim A. Using this syntax, lx.x + 1 has the following specification,as we shall show below. l

x.x + 1 :u uhxim m = x + 1. In order to derive specifications like thismore efficiently than by expansion of abbreviations, we introduce derivable rules and axioms

that work directly with this new syntax. Figure 2 lists some rules. Axioms can be simplified inthe same way.

Termination at default ports is not the only place where higher-level rules are useful. Exam-ples in $4 indicate that reasoning about non-default jumps also often follows more high-level
patterns. To support this intuition, we add more shorthands.

M % A def= M :u A ^ mh*i ^ m 6= u a * e % {A} def= aheui(A ^ mh*i ^ m 6= u)
In both u must be fresh. Rules using these additional rules can be found in Figure 3.
Theorem 2. All rules in Figures 2 and 3, and all associated axioms are derivable.
We continue with some further examples of using the derived rules and axioms. We start byderiving 3 +

throw k 7 :u kh3i once more.

1 k :n nhki VAR
2 7 :h h = 7 SVAR
3 throw k 7%khyi JTHROW"
4 3 :m m = 3 SCONST
5 3 + throw k 7%khyi JADD'

Now we consider an example that show that the simplified rules are also useful when reason-ing about programs with free variables. Consider

callcc x :m {A}(m = 7 . m = 8) (3)
where A def= x(kr)(kh7i . rh8i). Mechanically, using the simplified rules, we infer

1 callcc :a a(bc)bhcci SVAR
2 x :b b = x SCCC
3 callcc x :u 9ab.(a(bc)bhcci ^ b = x) ffi ahbui SAPP, 1, 2
4 callcc x :u xhuui CONS, 3
5 callcc x :m {A}(m = 7 . m = 8) CONS, 4

Line 4 is by a straightforward application of [CUT] and some straightforward logical manip-ulations. To get Line 5, we reason as follows.

xhuui oe {xhuui(uh7i . uh8i)}(uh7i . uh8i) oe {A}(uh7i . uh8i) oe u(m){A}(mh7i . mh8i)

The first of these implications uses [XCHANGE], while the second strengthens the preconditionof the rely/guarantee formula.

Example (3) shows how easily we can reason about programs that have free variables whichare assumed to act like throwing a continuation. Just as easily one can assume that a variable

acts like callcc and prove x lk.throw k 7 :m {A}m = 7, where A def= x(ab)ahbbi.

M %Alx
.M :u u * x % {A} JA

BS M :m A N %BM + N %B JADD' M %AM + N %A JADD M :m A N %BMN %B JAPP'

M %A
if M then N else N0 %A JA

DD M %Acallcc M %A JCCC M %AMN %A JAPP M %Athrow M N %A JTHROW

M :m A N %B
throw M N %B JTHROW' M :m mhki N :n Athrow M N %k(n)A JTHROW"

Fig. 3. Some derived rules, helpful for reasoning about PCF+ programs that jump.

Relating the Logics for PCF and PCF+. The derivable rules and axioms just discussed posethe question of the systematic relationship between the present logic and that for

PCF [14, 16].We give an answer by providing a simple translation of formulae and judgements from the

logic for PCF to that for PCF+, and then showing that the inclusion on programs preservesderivability. The idea behind the translation is straightforward: just add fresh default ports.

We continue with a summary of the logic for PCF in [14, 16]. Types and formulae are givenby the following grammar, with expressions being unchanged.

a ::= N || B || Unit || a ! b A ::= e = e0 || A ^ B || ~A || 8xa.A || xheiy A
Judgements are of the form {A} M :m {B}. Next is the translation of PCF-formulae into PCF+-formulae.

pe = e0q def= e = e0 pA ^ Bq def= pAq ^ pBq p~Aq def= ~pAq
p8xa.Aq def= 8xaffi.pAq pxheiy Aq def= 8u.xheuiu(y)pAq u fresh

Please note that the translation changes a to affi in the translation of quantifiers (affi was defined
in $3). Judgements are translated as follows: p{A} M :m {B}q def= M :u u(m){pAq}pBq (ufresh). This translation has the following properties.

Theorem 3. 1. The translation of judgements, when applied to rules, takes PCF-rules to

derivable rules for PCF+.
2. ` {A} M :m {B} implies ` p{A} M :m {B}q, where derivability on the left is in the logicfor

PCF, on the right it's for PCF+.

6 Conclusion
We have investigated program logics for a large class of stateless sequential control constructs.One construct not considered here are exceptions. Exceptions are a constrained form of jumping that is used to escape a context without the possibility of returning, a feature very usefulfor error handling. Exceptions are not included in the present logic because they are caught

dynamically, which does not sit comfortably with our typing system. We believe that a simpleextension of the logic presented here can easily account for exceptions. A second omission is
that many programming languages with interesting control constructs also feature state. Webelieve that adding state to

PCF+or uPCF can be done easily with the help of content quantifi-cation [16].

Related Work. The present work builds upon a large body of preceding work on the semanticsof control, including, but not limited to [11, 17, 21, 22, 25-28]. As mentioned, the investigation
of logics for control manipulation was started by Clint and Hoare [10]. It has been revived by[2-4, 7, 24, 29, 32, 34] (the long version of the present paper will feature a more comprehensive
discussion). None of these approaches investigates logics for fully-fledged higher-order controlconstructs like

callcc.The present work adds a new member to a family of logics for ML-like languages [5, 16,

18, 36], and integrates in a strong sense: e.g. all rules and axioms from [16] are, adapting thesyntax, also valid for

PCF+and uPCF. We believe that all common CPS-transforms between
PCF, PCF+ and uPCF are logically fully abstract in the sense of [23]. This coherence betweenprogramming languages, their operational and axiomatic semantics, and compilations between

each other paves the way for a comprehensive proof-compilation infrastructure for ML-likelanguages.

Rely/guarantee based reasoning was introduced in [20]. Internalising rely/guarantee rea-soning into the program logic itself by way of rely/guarantee formulae was first proposed in
[30, 31] and has been used in Ambient Logics [9] and in expressive typing systems [8]. Theuse of tensor is also found in [30, 31], and has been advocated by Winskel [35]. In all cases the
context is concurrency, not sequential control.A preliminary version of the present work was finished in 2007, and its key ideas, in particular rely/guarantee formulae and the tensor have since lead to a Hennessy-Milner logic fortyped p-calculus [6]. Neither proof-rules nor axioms for higher-order control are investigated
in [6]. Clarifying the relationship between the present logic and that of [6] is an interestingresearch question.

References

1. S. Abramsky, R. Jagadeesan, and P. Malacaria. Full abstraction for PCF. Inf. & Comp., 163:409-470,

2000.
2. D. Aspinall, L. Beringer, M. Hofmann, H.-W. Loidl, and A. Momigliano. A program logic for

resource verification. In Proc. Theorem Proving in Higher-Order Logics (TPHOL), 2004.
3. F. Bannwart and P. M"uller. A program logic for bytecode. ENTCS, 141(1):255-273, 2005.
4. N. Benton. A Typed, Compositional Logic for a Stack-Based Abstract Machine. In Proc. APLAS,

2005.
5. M. Berger, K. Honda, and N. Yoshida. A logical analysis of aliasing for higher-order imperative

functions. In Proc. ICFP, pages 280-293, 2005. Full version to appear in JFP.
6. M. Berger, K. Honda, and N. Yoshida. Completeness and logical full abstraction in modal logics for

typed mobile processes. In Proc. ICALP, 2008.
7. L. Beringer and M. Hofmann. A bytecode logic for JML and types. In Proc. APLAS, pages 389-405,

2006.
8. L. Caires. Spatial-behavioral types, distributed services, and resources. In Proc. TGC, pages 98-115,

2006.
9. L. Cardelli and A. D. Gordon. Anytime, Anywhere. Modal Logics for Mobile Ambients. In

Proc. POPL, pages 365-377, 2000.

10. M. Clint and C. A. R. Hoare. Program Proving: Jumps and Functions. Acta Informatica, 1:214-224,

1972.
11. B. F. Duba, R. Harper, and D. MacQueen. Typing First-Class Continuations in ML. In Proc. POPL,

pages 163-173, 1991.
12. R. Harper and M. Lillibridge. Operational Interpretations of an Extension of Fw with Control Operators. Journal of Functional Programming, 6(3):393-417, 1996.
13. K. Honda. Processes and games. ENTCS, 71, 2002.
14. K. Honda, M. Berger, and N. Yoshida. Descriptive and Relative Completeness of Logics for HigherOrder Functions. In Proc. ICALP, pages 360-371, 2006.
15. K. Honda and N. Yoshida. A uniform type structure for secure information flow. In POPL'02, pages

81-92. ACM Press, 2002. Full version to appear in ACM TOPLAS.
16. K. Honda and N. Yoshida. A compositional logic for polymorphic higher-order functions. In

Proc. PPDP'04, pages 191-202. ACM Press, 2004.
17. K. Honda, N. Yoshida, and M. Berger. Control in the p-calculus. In Proc. CW'04. ACM Press, 2004.
18. K. Honda, N. Yoshida, and M. Berger. An observationally complete program logic for imperative

higher-order functions. In LICS'05, pages 270-279, 2005.
19. J. M. E. Hyland and C. H. L. Ong. On full abstraction for PCF. Inf. & Comp., 163:285-408, 2000.
20. C. B. Jones. Specification and Design of (Parallel) Programs. In IFIP Congress, pages 321-332,

1983.
21. J. Laird. A Semantic Analysis of Control. PhD thesis, Univ. of Edinburgh, 1998.
22. J. Longley. When is a functional program not a functional program? SIGPLAN Not., 34(9):1-7,

1999.
23. J. Longley and G. Plotkin. Logical Full Abstraction and PCF. In Tbilisi Symposium on Logic,

Language and Information, CSLI, 1998.
24. Z. Ni and Z. Shao. Certified Assembly Programming with Embedded Code Pointers. In Proc. POPL,

2006.
25. C.-H. L. Ong and C. A. Stewart. A Curry-Howard foundation for functional computation with

control. In Proc. POPL, pages 215-227, 1997.
26. M. Parigot. lu-Calculus: An Algorithmic Interpretation of Classical Natural Deduction. In

Proc. LPAR, pages 190-201, 1992.
27. G. Plotkin. Call-By-Name, Call-By-Value, and the l-Calculus. TCS, 1(2):125-159, 1975.
28. J. G. Riecke and H. Thielecke. Typed exceptions and continuations cannot macro-express each other.

In Proc. ICALP, volume 1644 of LNCS, pages 635-644, 1999.
29. A. Saabas and T. Uustalu. A Compositional Natural Semantics and Hoare Logic for Low-Level

Languages. In Proc Workshop Structural Operational Semantics (SOS), 2006.
30. C. Stirling. A complete compositional proof system for a subset of CCS. In Proc. ICALP, pages

475-486, 1985.
31. C. Stirling. Modal logics for communicating systems. TCS, 49:311-347, 1987.
32. G. Tan and A. W. Appel. A Compositional Logic for Control Flow. In Proc. Int. Conf. Verification,

Model Checking and Abstract Interpretation (VMCAI), 2006.
33. H. Thielecke. Continuations, functions and jumps. Bulletin of EATCS, Logic Column, 8, 1999.
34. H. Thielecke. Frame rules from answer types for code pointers. In Proc. POPL, pages 309-319,

2006.
35. G. Winskel. A complete proof system for SCCS with modal assertions. In Proc. FSTTCS, volume

206 of LNCS, pages 392-410, 1985.
36. N. Yoshida, K. Honda, and M. Berger. Logical reasoning for higher-order functions with local state.

In Proc. Fossacs, LNCS, pages 361-377, 2007.