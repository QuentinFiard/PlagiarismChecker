

Trust in the Pi-Calculus
Mark Hepburn
mark h@postoffice.utas.edu.au

David Wright
David.Wright@utas.edu.au
School of Computing, University of TasmaniaGPO Box 252-100

Hobart, TasmaniaAustralia, 7001
phone: +61 3 6226 2922fax: +61 3 6226 1824

ABSTRACT
We introduce a new system of trust analysis for concurrent
and distributed systems using the ss-calculus[13, 14, 15] as
a modelling tool. A Type system using boolean annotations
guarantees that no run-time errors due to untrusted data
being used in a trusted context are possible. We improve
on other similar systems[18] by introducing a safe environment in which trust-coercion can be performed based on the
results of run-time checks. An algorithm for deducing the
most general types for the type system is presented.

Keywords
ss-calculus, trust analysis, runtime coercion, type annotations

1. INTRODUCTION

Distributed computing is looming as one of the most important and influential computing paradigms of the near future. Among the benefits it offers are cheaper supercomputers through clustering (e.g. [1]) off-the-shelf personal computers, and perhaps more interestingly the ability to harness
the spare CPU cycles and memory of other machines on the
local intranet or even on the global internet itself (for example, [2, 3, 4]).

With this increase in the use of the internet, particularly
the use of the internet for sharing computational resources,
comes a corresponding increase in the number of threats to
security using the very same pathways into your machine
that your collaborators use to pursue more noble goals. To
counteract these threats, there is a growing discipline of security analyses focusing on mobile agents and network oriented computation (e.g. [5, 23, 21, 26, 16, 11, 19]). Many
of these[23, 8, 19] utilise a concept of flow analysis; the idea
of somehow tracking the flow of data (or other properties

or combination thereof) through a program in order to ascertain if any security violations are possible. Most such
analyses are concerned with the possibility of security levels
being compromised; for example data "leaking" from a high
security level to a lower level.

We take another approach; we concern ourselves in this
work with the possibility of your data being compromised by
intruders rather than our data being viewed by those same
intruders. Note that in some networks data integrity simply
cannot be guaranteed; for instance a government keen to
censor publicly available information may monitor its country's internet gateways, a malicious system administrator
might alter peoples' sensitive data, or even a noisy channel
could possibly render the integrity of information received
along it suspect at best.

In Trust in the lambda-calculus[18], O/rbaek and Palsberg
introduced a system of Trust Analysis involving type annotations and coercion operators that was able to demonstrate
compile-time safety with respect to trust. Any possibility of
data marked as untrusted being used in a computation that
relied on data being trusted for its result would result in a
type checking error. We feel this is very important work;
however we have some reservations about the methodology
through which the results are achieved. The cornerstones
of their system are type annotations (tr, trusted; and dis,
distrusted) and three additional operators to the language:
trust, distrust, and check. The first two are explicit coercion
operators; "trust x" means x is now trusted, no matter what
its previous annotation, and similarly "distrust x" has the
opposite effect. The third, check, is a safety operator: "check
x" only type checks if x is trusted, and fails otherwise. The
intention is the programmer places instances of "check" at
judicious points in his program, then relevant data which is
untrusted is coerced to trusted only after careful checking
(of whatever nature) reveals that it can in fact be trusted.
An advantage of this work is that it is completely decidable
at compile time; if an annotated program successfully type
checks then the bare program (with no trusts, distrusts, or
checks) is also safe with respect to trust.

O/rbaek and Palsberg offer the following example of their
system in action:

fun getRequest client =

let (req, signature) = readFromNetwork(client) in

if verifySignature(signature) then

handleEvent(trust req)

else

handleWrongSignature(req, signature)

where the handler code resembles:
fun handleEvent req =

let trustedReq = check req
in ...

It is our belief however that this approach places too much
responsibility on the programmer to correctly apply the appropriate casts and checks. Consider what happens if the
"verifySignature" branches get mixed up; ie:

...
if verifySignature(signature) then

handleWrongSignature(req, signature)
else

handleEvent(trust req)

In this case the request has been established to be untrustworthy, however due to the explicit trust cast the program
will still type-check and possibly use that untrusted data in
a trusted context.

In our work presented here, we seek to follow a similar
approach, with the following improvements:

ffl extend the approach into a distributed model (O/rbaek

and Palsberg presented systems of a functional[18] and
imperative[17] nature);

ffl provide a safe system of coercion by removing the onus

of correct use of coercion operators from the programmer.

1.1 Motivation

Consider the simple case of a process wishing to send a
message to a second process. Assume that the two processes
are separated to some degree so that they must use an external communication medium, such as a network connection.
Now suppose that that channel of communication has possibly been compromised, and an attacker may be altering
all or some data passing through it. Further assume that
our processes are called P and Q, that the channel they
share for communication is called x, and that P wishes to
transmit a message y which Q will bind to a variable z. In
the ss-calculus (see section 2, and also [13]) this scenario,
represented pictorially in figure 1, is described by

x:[y]Pjx:(*z)Q
It is most likely that Q will not wish to trust the data
(y) received along x without first performing some sort of
integrity check, as it may well have been compromised in
transit. In this case the danger is immediately apparent;
however it is not difficult to imagine much more complicated
examples in which the flow of data is a lot harder to follow
without some kind of formal analysis. Our type system and
syntactic additions to the ss-calculus address this issue.

1.2 Layout

The remainder of this paper is presented as follows: in
section 2 we briefly outline the ss-calculus, the network calculus we will be using as our model. A typing system is also
covered. In section 3 we present our system: first a set of
boolean annotations (based on those presented in [24, 25])
to the base type system is described, which can be used to

demonstrate type safety with the additional property of no
instances of untrusted data being used in a trusted context
being possible. Following this our safe model of coercion
is introduced; a simple extension to the syntax of the sscalculus that removes the responsibility of placing checks in
appropriate places from the programmer. The safety of the
new system is demonstrated in section 4 as subject reduction
is shown to hold. In section 5 an algorithm for determining
the most general type for a program in our system is presented. The soundness and completeness of this algorithm
is proven in section 6. Finally, in section 7 we conclude.

2. THE PI-CALCULUS
2.1 Syntax

The fundamental tenet of the ss-Calculus is communication between processes, which makes it an ideal basis for
our study. The main building blocks are channels, and all
processes are constructed from channels. Channels carry
data between processes, and in its purest form all data is
also comprised of channels. There are two main forms of
processes; those that can receive data and that can transmit data. As an example of a transmitting process, x:[y]P
transmits, to a process capable of receiving along channel
x, the data y then continues as P . The reciprocal case of
a process receiving data is represented as x:(*z)Q; the process receives a message from channel x and binds it to the
variable z then continues as Q (with every instance of z being replaced with x). Note that a channel being used in an
output context is presented with a vertical bar over it.

In this paper we consider a commonly used version of the
ss-Calculus as described in [13], with polyadic channels. We
let P; Q; R range over processes, M; N range over normal
processes (all processes can be expressed in this form ([13])),
F represent abstractions and C concretions, A range over
agents, x; y; z range over names and finally ! represent either
x or x as appropriate for some name x. The complete syntax
is shown in definition 1:

Definition 1.

N ::= !:A j 0 j M + N

P ::= N j PjQ j !P j (*x)P

F ::= P j (*x)F j (*x)F
C ::= P j [x]C j (*x)C
A ::= FjC

An abstraction F is a process prepared to receive a name
along an unspecified channel, and bind it to the variable abstracted (represented by *x where x is the bound variable)
on F . A concretion is the equivalent output case; a process
prepared to output a name along an unspecified channel. An
agent is either an abstraction or a concretion. Restriction
((*x)A), which creates a unique name x in P is also a binding operator. In the ss-calculus we consider, both input and
output are blocking operations. The restriction operator
(*x)P creates a unique name x in P , while the replication
operator !P can be defined inductively as !P = P j!P .

The existence of binding operators enables us to (inductively) define the concept of free and bound names or variables (defn 2):

Figure 1: Basic Scenario
Definition 2.

F V (x:A) = F V (x:A) = fxg [ F V (A)

F V ([x]C) = fxg [ F V (C)
F V ((*x)F) = F V ((*x)F) = F V (F) \Gamma  fxg

2.1.1 Reduction

There is only one reduction axiom in the basic ss-Calculus;
a communication step:

(: : : + x:[~y]P)j(: : : + x:(*~z)Q) \Gamma ! PjQfy=zg

(comm:)

In the communication reduction shown above, process P
sends a name y along channel x, then continues as P . Process Q receives the name y along x and binds it to the
name z, then continues as Q. There are also three inference rules, summarised briefly as: reduction can occur in
parallel (Par.); reduction can occur under a restriction (but
not under abstraction or input/output) (Res.), and structural congruence is preserved under reduction (Struct.):

P \Gamma ! P

0

Q \Gamma ! Q

0

PjQ \Gamma ! P0jQ0

(P ar:)

P \Gamma ! P

0

(*x)P \Gamma ! (*x)P0

(Res:)

Q j P P \Gamma ! P

0

P

0

j Q

0

Q \Gamma ! Q0

(Struct:)

2.2 Typing

The base typing system we use is also that of [13]. The
usual goal of type systems is to prevent certain run-time errors from occurring; since the ss-calculus is concerned with
communication a likely cause of run-time errors is a process
receiving a tuple of data from a channel that is of a different
size to that which it is expecting. To this end our typing
discipline will require each channel to be used in only a certain way; both in the lengths of data tuples it carries, and
by extension since all data is itself comprised of channels the
types of channels it can carry.

We begin by associating all names with a sort. Since all
names are channels, then to each sort we associate a list of
sorts that channels of that sort communicate: the object of
that sort, denoted ob(ffi) for sort ffi.

Definition 3. Judgements

\Gamma ; ob ` P : ^
states that process P is well formed and has type ^, under
the assumption sets \Gamma  and ob (where \Gamma  is a mapping of

names to sorts, and ob is a mapping of sorts to objects of
those sorts).

See definition 7 for a complete type syntax (with annotations; introduced in section 3.3); the reader is referred to
[13] for a more detailed description of the base type system
itself.

3. A SAFE SYSTEM OF COERCION
3.1 A safe coercion operator

We now start to consider the desirable properties of our
system of coercion. We would like the programmer to be
able to consider, and within a restricted environment to
be able to use coercion, but as have stated previously we
would like to do away with the need for explicit, programmer driven casts. As an alternative we envisage a system
in which coercion is based not on programmer judgements
(and hence potentially errors) but on run-time verification.
We deliberately leave the method of verification unstated
in keeping with the broad abstract framework provided by
the ss-calculus, however some examples could include signature verification, or in fact any form of security analysis/verification described by others (eg [16]) that would provide the necessary assurance. In this way we see our method
as being an overall analysis framework that can utilise and
encompass the work of others; we do not see security as being
provided by any one method ([6]), but rather a constantly
shifting approach.

Our addition to the existing ss-calculus syntax (defn. 1)
will coerce (to either trusted or untrusted) its argument
based on the results of runtime certification (using an unspecified method). We would further like to alter the execution path of the program based on the certification results;
to this end we provide two additional arguments (both sscalculus processes) to our operator: one to be executed if
the data can be correctly verified, and the other if it cannot.

Our new operator then looks like this:

certify x (*z)P (*z)Q
where x is the data to be certified (note that in our current,
first order system we do not allow processes themselves to
be verified; this will be rectified in later work dealing with
a higher-order system), P is the process to be executed if
x can be guaranteed trusted, and Q to be executed in the
event that x is untrusted. It will be seen later (Figure 3)
that z is the variable x is bound to in the reduction.

We deal with typing and reduction details later; for the
moment our complete syntax becomes (defn 4):

Definition 4.

N ::= !:A j 0 j M + N j certify x (*z)P (*z)Q

P ::= N j PjQ j !P j (*x)P

F ::= P j (*x)F j (*x)F
C ::= P j [x]C j (*x)C
A ::= FjC

3.2 Example

As an example of our system in use, we present a contrast
with the approach put forward in [18]. Consider again the
example described in the introduction; in our system, the
same scenario would be written as:

*x:certify x (*z.handleEvent) (*z.handleWrongSignature)
(Note that in this example, the abstraction on x is taken to
represent the readFromNetwork function, and the
verifySignature functionality is incorporated in the certify
operator). It can be observed that in our system the coercion
is now implicit, and further it will be shown that the danger
of the execution paths being placed in the wrong order is
detected by the type system.

3.3 An Annotated Type System

To the existing type system, we add a system of boolean
annotations, based on [25]. We consider two concrete values,
T denoting a trusted channel sort (corresponding to truth
in a boolean algebra) and U, denoting an untrusted channel
sort (likewise corresponding to falsehood). In summary the
following relations are admitted (defn 5):

Definition 5.

T \Delta  b = b U \Delta  b = U
T + b = T U + b = b

^T = U ^U = T

It should be noted that although in the interests of completeness we permit the operations of + and negation, they are
not used in the system we present here. Preliminary work
is underway however on an extended system for a higher
order ss-calculus which requires all the operations presented
above.

Now we present the complete type syntax. We first define
the symbols used in our type system:

Definition 6. For all elements of our type system we have
three sets of symbols we use to range over those elements:
concrete elements, variables, and ambiguous elements (table 1).

Concrete Variable Either
Annotations T; U i; j; k b,c,d

Sorts S ff ffi
Object Sorts r ae ^

Table 1: Notation

Our complete type syntax then becomes:

Definition 7.

b ::= TjUjijb1 \Delta  b2jb1 + b2j^b
ffi ::= Sjff

^ ::= ()j

i

ffi

b

n

ffi

b

o\Lambda j

jae

\Gamma  ::=

n

x : ffi

b

o

ob ::=

n

ffi

b

7! ^

o

We also introduce here a few miscellaneous definitions used
in the type rules:

Definition 8. Write (\Gamma ; ob) [ fx : ffi

b

7! ^g to mean

\Gamma  [ fx : ffi

b

g; ob [ fffi

b

7! ^g

Similarly, write (\Gamma ; ob)x [ fx : ffi

b

7! ^g as shorthand for

\Gamma x [ fx : ffi

b

g; ob [ fffi

b

7! ^g

Definition 9. Define the '

^

' operation on object sorts as

(S)

^

(S1 : : : S2) = (SS1 : : : S2)

We consider in this system two possible causes of untrustworthiness: one is data which for some reason or another is known to be untrusted, and the other is data that
cannot be trusted because it has passed through an untrustworthy channel. These assumptions, in particular the
latter, imply a relation between sorts and their objects:
given a sort ffi

b1

that we plan to receive data along then

we would desire that for all ffi

b2

k in ob(ffi

b1

), b2 ^ b1 where ^

is the least reflexive, transitive relation inductively defined
by the following (definition 10):

Definition 10.

U ^ i ^ T
Rather than have a separate set of constraints generated,
we choose to express this relationship between sorts and
their objects slightly differently in our type rules by integrating them into the types themselves. The same effect
can be achieved by requiring that for any ffi

b

then for all

ffi

c

k in ob(ffi

b

) that c = b \Delta  c

0

for some c

0

. Before introducing

the complete type rules, first define multiplication as the
operation inductively defined (definition 11) as

Definition 11.

b \Delta  () = ()

b \Delta  ae = ae

b \Delta 

\Gamma 

(ffi

c

)

^

^

\Delta 

=

i

ffi

bc

j^

(b \Delta  ^)

We can now introduce the type rules: (see Figure 2)
Of these rules, three in particular are worth attention: (inp.)
and (out.), and (cert.). The (inp.) rule requires that the
types of the name(s) received along the channel x first of all
form the same type as the object of the type of the channel
x (which is required by the base type system), but also that
that object sort ^

0

is equal to b \Delta  ^ for some ^, thus enforcing

the view that all data received along an untrusted channel
is untrusted (by the definition of multiplication, defn. 11).

By contrast, we would expect that trusted data can by
sent along an untrusted channel, but that it would be untrusted at the receiving end. To this end our (out.) rule is

\Gamma ; ob ` 0 : ()

(zero)

\Gamma x [ fx : ffibg; ob ` x : ffib

(var:)

\Gamma x [ fx : ffi

b

g; ob ` A:^

\Gamma ; ob ` (*x) A:^

(res:)

\Gamma ; ob ` P:()
\Gamma ; ob ` !P:()

(repl:)

\Gamma ; ob ` M:() \Gamma ; ob ` N:()

\Gamma ; ob ` M + N:()

(sum:)

\Gamma ; ob ` P:() \Gamma ; ob ` Q:()

\Gamma ; ob ` PjQ:()

(comp:)

\Gamma x [ fx : ffi

b

g; ob ` F:^

\Gamma ; ob ` (*x) F: (ffib)

^

^

(abs:)

\Gamma x [ fx : ffi

b

g; ob ` C:^

\Gamma x [ fx : ffibg; ob ` [x] C: (ffib)

^

^

(conc:)

(\Gamma ; ob)x [ fx : ffi

b

7! b \Delta  ^g ` F:b \Delta  ^

(\Gamma ; ob)x [ fx : ffib 7! b \Delta  ^g ` x:F:()

(inp:)

(\Gamma ; ob)x [ fx : ffi

b

7! ^g ` C:^

(\Gamma ; ob)x [ fx : ffib 7! b \Delta  ^g ` x:C:()

(out:)

\Gamma ; ob ` x : ffi

b

\Gamma ; ob ` (*z)P : (ffi

T

)

\Gamma ; ob ` (*z)Q : (ffi

U

)

x =2 F V (P; Q)
\Gamma ; ob ` certify x (*z)P (*z)Q : ()

(cert:)

Figure 2: Type Rules

slightly different: the base requirement that the sorts carried
by x match those to be transmitted by C is still met, but
now in the antecedent we are unconcerned about the annotation on the channel, thus a variable may be trusted in C
and still be exported along an untrusted channel. The consequent of the rule matches that of the (inp) case; all sorts
must be multiplied by the annotation of the channel. This
allows trusted data to be sent along an untrusted channel
and be considered untrusted by the receiving process.

The (cert.) rule forms the cornerstone of our system; it
provides a safe environment in which coercion can be performed, removing the responsibility from the programmer.
The first argument to certify is the name to be certified; the
second argument is a process P upon which a single name
has been abstracted. This name must have the same base
type as the name being certified (x), and be trusted. Similarly, the third argument also has a single name abstracted
upon it with the same base type as x, and is untrusted.
As we shall see when we examine the reduction rules for
certify, in the event that x is certified (usually at runtime)
as trusted then the type of x (ffi

b

) is coerced to trusted and

every instance of z in P replaced with x. Conversely, if x
cannot be certified then it is coerced to untrusted and every
instance of z in Q replaced by x. Since the abstracted name
z is trusted and untrusted in P and Q respectively, this
ensures the safety of the system by subject reduction (see
Section 4). Note that although subject reduction is present
in [18] it is modulo the explicit trust casts: any program
can be made "correct" by inserting enough casts. Finally,
we also require that x not be in the set of free names of P
or Q: this makes the system more elegant than if x were
allowed free in P or Q as it removes the need to introduce
explicit trust casting into the language.

3.4 Reduction Rules

Definition 12. Write \Gamma ; ob `certify x : ffi

T

if x is certified

as trusted; similarly if x is certified as untrusted.

The reduction rules remain the same as for the basic sscalculus, with the addition of extra rules to cater for certify;
see Figure 3. These rules guarantee that if x is trusted then
it will only be used within a trusted context by substituting
it for a trusted name in P ; conversely if it is untrusted then it
will only be used within an untrusted context by substituting
it for an untrusted name in Q. Note that all coercion is
global in effect.

4. SAFETY OF THE SYSTEM

Now that we have a type system and syntax established,
we can begin formulating a proof of subject reduction, which
as we shall see is by necessity slightly different from the
normal subject reduction statement.

First, some preliminary definitions (defn. 13):

Definition 13. Substitutions

ffl A substitution is a pair

(ST : T ype ! T ype; RB : boolexp ! boolexp).

ffl Usually written just as S; sometimes write R to denote

(Id; RB ).

ffl Write Id for (Id; Id).

ffl Write S1; S2 for S2 ffi S1
ffl Application: if S = (ST; RB ) then

- S(S

i

) = ST; RB (S

i

)

- S((S

i

)

^

r) = (S(S

i

))

^

S(r)

- S(fS

i

7! rg [ ob) = fS(S

i

) 7! S(r)g [ S(ob)

ffl For S = (ST; RB ), write

S[ff

i

:= S

j

] for (ST[ff

i

:= S

j

]; RB ) and S[i := j] for

(ST; RB [i := j]). Similarly, write S;R for (ST; RB ; R).

4.1 Substitution Lemma

First we must establish that the substitution lemma holds:

Lemma 4.1. Substitution Lemma: Let , be either ffi or ^,
then:

\Gamma x [

\Phi 

x : ffi

b

\Psi 

; ob ` A :, \Gamma ; ob ` y : ffi

b

\Gamma ; ob ` A fy=xg :,

Proof:
By induction on the structure of A and the type of x & y.

4.2 Subject Reduction

Having established that substitution is sound, we can now
consider the case of subject reduction. The fact that we
must also consider run-time coercion complicates matters
however: the basic subject reduction property states that
the type of a given expression remains immutable as the
expression is reduced. This is obviously not the case in the
presence of run-time coercion; if the reduction involves any
coercion then the type and its enclosing environment may
be altered. Given this, we must find some way of including
this in the statement without relaxing the subject reduction
property itself.

To this end we present a boolean substitution inductively
defined by the reduction path: (Figure 4)

Now we can formulate our new subject reduction statement; similar to the classical case, but the environment after the reduction step must have the substitution defined by
the reduction and the relation given in figure 4 applied to
it.

Theorem 4.1. Subject Reduction:

\Gamma ; ob ` P : () P ! P

0

P ! P

0

fl

\Gamma ;ob

certify R

R(\Gamma ); R(ob) ` P0 : ()

Proof:
By induction on the structure of the derivation of P ! P

0

,

and by cases on the structure of P. In the interests of space,
we present only two illustrative cases:

ffl Suppose the last rule used in the derivation of P!P

0

was

Q ! Q

0

R ! R

0

P = QjR ! Q0jR0 = P0
By the statement \Gamma ; ob ` QjR : (), so from the (comp.)
type rule we must have \Gamma ; ob ` Q : () and
\Gamma ; ob ` R : (). By the induction hypothesis, we have
R1(\Gamma ); R1(ob) ` Q

0

: () and R2(\Gamma ); R2(ob) ` R

0

: () so

R(\Gamma ); R(ob) ` Q

0

jR

0

: () as required, where R = R1; R2

by the definition of fl

\Gamma ;ob

certify.

\Gamma ; ob `certify x : ffi

T

certify x (*z)P (*z)Q ! Pfx=zg

\Gamma ; ob `certify x : ffi

U

certify x (*z)P (*z)Q ! Qfx=zg

Figure 3: certify Reduction Rules

P ! P fl

\Gamma ;ob

certify Id

(reflex)

x:[~y]C

x:[~y]
\Gamma \Gamma \Gamma ! C fl

\Gamma ;ob

certify Id

(out:)

x:(*~y)F

x:(*~z)
\Gamma \Gamma \Gamma \Gamma ! F fl

\Gamma ;ob

certify Id

(inp:)

M ! M

0

fl

\Gamma ;ob

certify R

M + N ! M0 fl

\Gamma ;ob

certify R

(sum:)

P ! P

0

fl

\Gamma ;ob

certify R1 Q ! Q

0

fl

\Gamma ;ob

certify R2

PjQ ! P0jQ0 fl

\Gamma ;ob

certify R1; R1

(comp:)

P ! P

0

fl

\Gamma ;ob

certify R1 P

0

! P

00

fl

\Gamma ;ob

certify R2

P ! P00 fl

\Gamma ;ob

certify R1; R2

(trans:)

\Gamma ; ob ` x : ffi

i

\Gamma ; ob `certify x : ffi

T

certify x P Q ! P \Delta  x fl

\Gamma ;ob

certify Id[i := T]

(certify \Gamma  T)

\Gamma ; ob ` x : ffi

i

\Gamma ; ob `certify x : ffi

U

certify x P Q ! Q \Delta  x fl

\Gamma ;ob

certify Id[i := U]

(certify \Gamma  U)

Figure 4: Reduction Substitution Relation

ffl Suppose the last rule used in the derivation of P!P

0

was

\Gamma ; ob `certify x : ffi

T

P = certify x (*z)R (*z)Q ! Rfx=zg = P0

From the statement, \Gamma ; ob ` certify x (*z)R (*z)Q:(),
where \Gamma ; ob ` (*z)R : (ffi

T

), \Gamma ; ob ` (*z)Q : (ffi

U

), and

\Gamma ; ob ` x : ffi

b

by the (cert.) type rule. Given

\Gamma ; ob `certify x : ffi

T

, then

(certify x (*z)R (*z)Q) ! Rfx=zg by the semantics
of certify, and by subject reduction

\Gamma ; ob ` (*z)R : (ffi

T

) \Gamma ; ob `certify x : ffi

T

R(\Gamma ); R(ob) ` Rfx=zg : ()

where the original annotation b on x has been coerced
to T by certify; so R = Id[b := T] and P ! P

0

fl

\Gamma ;ob

certify

R as required.

5. IMPLEMENTATION

In figure 5 we present an algorithm for determining the
most general type of a given expression. Most of the algorithm is recursive and fairly trivial, with the base case of the
rule for a name which searches in its existing environment
for an entry for that name; if it finds one it returns the type
entry, otherwise it creates a new type variable and returns
that, updating the entry in the environments.

Those that deserve closer inspection include the input and
output cases which must use M (definition 17) to perform
the multiplication required by the type rules, and the rule
for certify which ensures that the certify variable (x) does
not appear free in either continuation (see section 3.3). The
input rule ensures the object of the sort of x is multiplied
by the annotation on the sort before deducing a type for F ;
in case the object of x is a variable (in which case multiplication has no effect; defn 17) it again multiplies the object
after it has been unified with the type of F . The output
rule performs the multiplication after unification, as is consistent with the type rules. Note that the rule for certify uses
unification to ensure the abstracted variable in the continuations are trusted and untrusted respectively, as required
by the type rules.

5.1 Auxiliary Algorithms

The following macro (definition 14) is used for conciseness
in the algorithm:

Definition 14.

SORT (\Gamma ; x) , fx : \Gamma (x)g
Unification algorithms for both single sorts and lists of sorts
(object sorts) are also required by the algorithm, and these
are presented here. Note that the algorithms for unifying
types are mutually recursive; Uss (which unifies single pairs
of sorts) attempts to equate the two sorts, then calls Ussl
to unify their object sorts. Ussl simply walks down the two
lists, calling Uss to unify matching pairs of sorts. A third algorithm, M , is used to perform the multiplication. BUNIFY
is the boolean unification algorithm returning a substitution
which is the most general unifier of its two arguments ([12]).

Definition 15.
Uss

i

ob; ff

b

; S

c

j

= let S = Id[ff

b

:= S

c

]; BUNIFY (b; c) in

S;Ussl

i

S(ob); S(ob(ff

b

)); S(ob(S

c

))

j

Uss

i

ob; S

c

; ff

b

j

= Uss

i

ob; ff

b

; S

c

j

Uss

i

ob; S

b

1; S

c
2

j

= if S1 6= S2 then ?

else if S

b

1 =ss S

c
2 then

Id

else let R = BUNIFY (b; c) in

R; Ussl

i

R(ob); R(ob(S

b

1)); R(ob(S

c
2))

j

Uss

i

ob; ff

b

1; ff

c
2

j

= if ff

b

1 =ss ff

c
2 then

Id
else let S = Id[ff

b

1 := ff

c
2]; BUNIFY (b; c)

in

S;Ussl

i

S(ob); S(ob(ff

b

1)); S(ob(ff

c
2))

j

Definition 16.

Ussl (ob; ae; t) = if ae 2 t ^ ae 6= t then ?

else Id[ae := t]
Ussl (ob; t; ae) = Ussl (ob; ae; t)

Ussl

i

ob; (S

i

1)

^

r; (S

c

2)

^

t

j

= let S = Uss

i

ob; S

b

1; S

c
2

j

in

S;Ussl (S(ob); S(r);S(t))
Ussl (ob; ae1; ae2) = Id[ae1 := ae2]

Ussl (ob; (); ()) = Id

Ussl

i

ob; (S

b

1)

^

r; ()

j

= Ussl

i

ob; (); (S

b

1)

^

r

j

= ?

Definition 17.
M

\Gamma 

b; (S

c

)

^

r

\Delta 

= let S = M (b; S

c

) in S;M (S(b);S(r))

M (b; S

c

) = BUNIFY (c; b \Delta  d) d new

M

i

b; S

T

j

= BUNIFY (b; T)

M

i

b; S

U

j

= Id

M (b; fi) = Id

6. SOUNDNESS AND COMPLETENESS OFTHE ALGORITHMS

In this section we prove that the type inference algorithm
presented in section 5 is sound and complete. In order to
preserve space (and the reader's attention!) we restrict the
proofs - all by induction - to a few suitable cases.

6.1 Soundness of Typess

Theorem 6.1. If h\Gamma ; ob; ^i = Typess (\Gamma 

0

; ob

0

; P) is defined then \Gamma ; ob ` P : ^.

Proof:
By induction on the structure of P. For example:

Typess (\Gamma ; ob; 0) = h\Gamma ; ob; ()i
Typess (\Gamma ; ob; x) = If x 2 dom (\Gamma )

then h\Gamma ; ob; \Gamma (x)i

else

D

\Gamma  [ fx : ff

i

g; ob [ fff

i

7! fig; ff

i

E

Typess (\Gamma ; ob; !P) = Typess (\Gamma ; ob; P)
Typess (\Gamma ; ob; (*x)A) = let h\Gamma 1; ob1; ^i = Typess (\Gamma x; ob; A) in

h(\Gamma 1)x [ SORT (\Gamma ; x) ; ob1; ^i
Typess (\Gamma ; ob; PjQ) = Let h\Gamma 1; ob1; ()i = Typess (\Gamma ; ob; P) in

let h\Gamma 2; ob2; ()i = Typess (\Gamma 1; ob1; Q) in

h\Gamma 2; ob2; ()i
Typess (\Gamma ; ob; M + N) = Let h\Gamma 1; ob1; ()i = Typess (\Gamma ; ob; M) in

let h\Gamma 2; ob2; ()i = Typess (\Gamma 1; ob1; N) in

h\Gamma 2; ob2; ()i

Typess (\Gamma ; ob; (*x)F) = let

D

\Gamma 1; ob1; ffi

b

E

= Typess (\Gamma x; ob; x) in

let h\Gamma 2; ob2; ^i = Typess (\Gamma 1; ob1; F) in

D

(\Gamma 2)x [ SORT (\Gamma ; x) ; ob2;

i

ffi

b

j^

^

E

Typess (\Gamma ; ob; [x]C) = let

D

\Gamma 1; ob1; ffi

b

E

= Typess (\Gamma ; ob; x) in

let h\Gamma 2; ob2; ^i = Typess (\Gamma 1; ob1; C) in

D

\Gamma 2; ob2;

i

ffi

b

j^

^

E

Typess (\Gamma ; ob; x:F) = let

D

\Gamma 1; ob1; ffi

b

E

= Typess (\Gamma ; ob; x) in

let S1 = M

i

b; ob(ffi

b

)

j

in

let h\Gamma 2; ob2; ^i = Typess (S1(\Gamma 1); S1(ob1); F) in

let S2 = S1; Ussl

i

ob2; ^; ob2(ffi

b

)

j

in

let S3 = S2; M (S2(b); S2(^)) in

hS3(\Gamma 2); S3(ob2); ()i

Typess (\Gamma ; ob; x:C) = let

D

\Gamma 1; ob1; ffi

b

E

= Typess (\Gamma ; ob; x) in

let h\Gamma 2; ob2; ^i = Typess (\Gamma 1; ob1; C) in

let S1 = Ussl

i

ob2; ^; ob(ffi

b

)

j

in

let S2 = S1; M (S1(b); S1(^)) in

hS2(\Gamma 2); S2(ob2); ()i

Typess (\Gamma ; ob; certify x (*z)P (*z)Q) = let

D

\Gamma 1; ob1; ffi

b

1

E

= Typess (\Gamma ; ob; x) in

let h\Gamma 2; ob2; (ffi

c

2)i = Typess ((\Gamma x)1; ob1; (*z)P) in

if x 2 dom(\Gamma 2) then ? else

let

D

\Gamma 3; ob3; (ffi

d

3 )

E

= Typess (\Gamma 2; ob2; (*z)Q) in

if x 2 dom(\Gamma 3) then ? else
let S1 = Uss

i

ob3; ffi

T

1 ; ffi

c
2

j

in

let S2 = S1; Uss

i

S1(ob3); S1(ffi

U

1 ); S1(ffi

d
3)

j

in

hS2(\Gamma 3 [ SORT (\Gamma 1; x)); S2(ob3); ()i

Figure 5: Sort Inference Algorithm

ffl Pj x:F: By the induction hypothesis

\Omega 

\Gamma 1; ob1; ffi

b

ff

=

Typess (\Gamma 

0

; ob

0

; x), so \Gamma 1; ob1 ` x : ffi

b

. From the statement, S1 = M

\Gamma 

b; ob1(ffi

b

)

\Delta 

must be defined and hence

by the soundness of M ,
8ffi

c

k 2 ob1(ffi

b

):9d:S1(ffi

c

k) = S1(b \Delta  ffi

d
k); i.e.

S1(ob1(ffi

b

)) = b\Delta ^

0

for some ^

0

. Again by the induction

hypothesis, h\Gamma 2; ob2; ^i = Typess (S1(\Gamma 1); S1(ob1); F),
and therefore ) \Gamma 2; ob2 ` F : ^ By the soundness of
Ussl, S2 = S1; Ussl

\Gamma 

ob2; ^; ob2(ffi

b

)

\Delta 

is sound and hence

S2(\Gamma 2; ob2) ` x:F; () as required, where
hS2(\Gamma 2); S2(ob2); ()i = Typess (\Gamma 

0

; ob

0

; x:F)

ffl Pjcertify x (*z)P

0

(*z)Q: By the induction hypothesis, given

\Omega 

\Gamma 1; ob1; ffi

b

1

ff

= Typess (\Gamma ; ob; x) then \Gamma 1; ob1 `

x : ffi

b

1. Similarly

h\Gamma 2; ob2; (ffi

c

2)i = Typess ((\Gamma 1)x; ob1; (*z)Q)

) \Gamma 2; ob2 ` (*z)Q : (ffi

c

2)

and
\Omega 

\Gamma 3; ob3; (ffi

d

3 )

ff

= Typess ((\Gamma 2; ob2; (*z)R)

) \Gamma 3; ob3 ` (*z)R : (ffi

d

3)

Note that if x 2 fn(Q; R) then Typess fails; however

according to the statement it is defined hence both
these steps are.
Now by the soundness of Uss we have S1(ffi1T) = S1(ffi

c

2)

and S2(ffi

U

1 ) = S2(ffi

d
3 ) where S1 = Uss (Id; ffi1T; ffi

c
2) and

S2 = Uss

\Gamma 

S1; ffi

U

1 ; ffi

d
3

\Delta 

Then by lemma Sub1 S2(\Gamma 3; ob3) ` (*z)Q : (ffi

T

) where

S2(ffi

c

2) = S2(ffi

T
1 ) = ffi

T

Similarly S2(\Gamma 3; ob3) ` (*z)R : (ffi

U

) Then by the (cert.)

type rule
S2(\Gamma 3 [ SORT (\Gamma ; x) ; ob3) ` certify x (*z)Q (*z)R : ()
as required.

6.2 Completeness of Typess

Theorem 6.2. If for some \Gamma 

0

; ob

0

, ^

0

there is a valid deduction \Gamma 

0

; ob

0

` P : ^

0

for P, then Typess (;; ;; P) is defined,

and if h\Gamma ; ob; ^i = Typess (;; ;; P) then
h\Gamma ; ob; ^i ^ h\Gamma 

0

; ob

0

; ^

0

i.

Proof:
By induction on the structure of P. For example:

ffl Pj (*x)F: The deduction

\Gamma 

0

; ob

0

` (*x)F : (ffi

0b

0

)

^

^

0

must end in a use of the

(abs.) rule with antecedent \Gamma 

0

[ fx : ffi

0b

0

g; ob

0

` F :

^

0

Given

\Omega 

\Gamma 1 [ fx : ffi

b

g; ob1; ffi

b

ff

= Typess (;; ;; x) we

have

\Omega 

\Gamma 1 [ fx : ffi

b

g; ob1; ffi

b

ff

^

D

\Gamma 

0

[ fx : ffi

0b

0

g; ob

0

; ffi

0b

0E

Then by the induction hypothesis

\Omega 

\Gamma  [ fx : ffi

b

g; ob; ^

ff

=

Typess

\Gamma 

\Gamma 1 [ fx : ffi

b

g; ob1; F

\Delta 

is defined, and
\Omega 

\Gamma  [ fx : ffi

b

g; ob; ^

ff

^

D

\Gamma 

0

[ fx : ffi

0b

0

g; ob

0

; ^

0

E

Then

by the type rules, Typess (;; ;; (*x)F) is defined and
\Omega 

\Gamma ; ob; (ffi

b

)

^

^

ff

^

D

\Gamma 

0

; ob

0

; (ffi

0b

0

)

^

^

0

E

ffl Pj certify x (*z)Q (*z)R: The deduction

\Gamma 

0

; ob

0

` certify x (*z)Q (*z)R must end in a use of

the (cert.) rule, with antecedents \Gamma 

0

; ob

0

` x : ffi

0b

0

,

\Gamma 

0

; ob

0

` (*z)Q : (ffi

0T

), and \Gamma 

0

; ob

0

` (*z)R : (ffi

0U

)

Given

\Omega 

\Gamma 1; ob1; ffi

b

ff

= Typess (;; ;; x), then

\Omega 

\Gamma 1; ob1; ffi

b

ff

^

D

\Gamma 

0

; ob

0

; ffi

0b

0 E

By the induction hypothesis, the following are defined:
h\Gamma 2; ob2; (ffi

c

2)i = Typess ((\Gamma 1)x; ob1; (*z)Q) and\Omega 

\Gamma 3; ob3; (ffi

d

3 )

ff

= Typess (\Gamma 2; ob2; (*z)R). Note that if

x 2 fn(Q; R) then Typess fails; however according to
the statement a valid deduction exists so this is not
the case. Then by completeness and soundness of Uss,
the following statements hold: S1 = Uss

\Gamma 

Id; ffi

T

; ffi

c

2

\Delta 

)

S1(ffi

T

) =ss S1(ffi

c

2) and S2 = Uss

\Gamma 

S1; ffi

U

; ffi

d

3

\Delta 

) S2(ffi

U

) =ss

S1(ffi

d

3 ). Hence

hS2(\Gamma 3 [ SORT (\Gamma 1; x) ; ob3); ()i ^ h\Gamma 

0

; ob

0

; ()i as required.

The proofs of soundness and completeness of Typess depend on the corresponding proofs of the auxiliary algorithms,
primarily the unification algorithms used. These results are
stated here, but again to preserve space the proofs themselves are not presented, as they are fairly standard.

6.3 Soundness and Completeness of Unifica-tion

Theorem 6.3. If S = Uss

\Gamma 

ob; S

i

1; S

j

2

\Delta 

is defined, then

S(S

i

1) = S(S

j

2).Proof:

By induction on S

i

1, S

j

2 and the definition of Uss.

One must be careful proving completeness of Uss; because
the sorts in ob in effect form a graph, we must consider not
only the sorts being unified but the entire network. To this
end, we introduce the following definition (figure 6):

Theorem 6.4. If S(S

i

1) = S(S

j

2) and

consistent

\Gamma 

;; ob; ob(S

i

1); ob(S

j

2)

\Delta 

then Uss

\Gamma 

ob; S

i

1; S

j

2

\Delta 

is defined.

Proof:
By induction on S

i

1, S

j

2 and the definition of Uss.

Theorem 6.5. If S = Ussl (ob; b; ^1) ^2 is defined, then
S(^1) = S(^2).

Proof:
By cases on ^1 and ^2, and by induction on the definition
of Ussl.

Theorem 6.6. If S(r) = S(t) and consistent (;; ob; r; t) is
true, then Ussl (ob; b; r) t is defined.

Proof:
By induction on r, and t, and on the definition of Ussl.

Theorem 6.7. ffl If S = M (b; ffi

c

) is defined then

9d:S(ffi

c

) = S(b \Delta  ffi

d

)

ffl If S = M (b; ^) is defined then

8ffi

c

2 ^:9d:S(ffi

c

) = S(b \Delta  ffi

d

)

Proof:
By induction on the structure of ffi

c

or ^ as appropriate.

Theorem 6.8. ffl If 9b; c; S:S(ffi

c

) = S(b \Delta  ffi

d

) then

M (b; ffi

c

) is defined.

ffl If 9b; c; S:S(ffi

c

) = S(b \Delta  ffi

d

) then M (b; ^) is defined

8ffi

c

2 ^.

consistent

i

\Sigma ; ob; ffi

b

1; ffi

c
2

j

= if fffi

b

1; ffi

c
2g 2 \Sigma  then true else

`

isVar(ffi

b

1) . isVar(ffi

c
2) .

i

isCon(ffi

b

1) ^ isCon(ffi

c
2) ^ (ffi

b
1 =ss ffi

c
2)

j '

^isDefined(BUNIFY (b; c))
^consistent

i

\Sigma  [ ffffi

b

1; ffi

c
2gg; ob; ob(ffi

b
1); ob(ffi

c
2)

j

!

consistent

i

\Sigma ; ob; ffi

b

1; ffi

b
1

j

= true

consistent (\Sigma ; ob; fi; ^) = consistent (\Sigma ; ob; ^; fi) = true
consistent

i

\Sigma ; ob; (ffi

b

1)

^

^1; (ffi

c

2)

^

^2

j

= consistent

i

\Sigma ; ob; ffi

b

1; ffi

c
2

j

^

consistent (\Sigma ; ob; ^1; ^2)
consistent (\Sigma ; ob; (); ()) = true

consistent

i

\Sigma ; ob; (ffi

b

1)

^

^; ()

j

= consistent

i

\Sigma ; ob; (); (ffi

b

1)

^

^

j

= false

Figure 6: Consistency Definition
Proof:
By induction on ffi

c

or ^ as appropriate.

6.4 Termination of Unification Algorithms

Given that the type unification algorithms are mutually
recursive, it is desirable to prove that they will eventually
terminate. A proof of this exists; however due to space
reasons we have ommited it. As a summary, it works by
proving that each recursive call operates on a smaller ob
than its parent, and thus must eventually terminate.

7. CONCLUSIONS

We have presented a system of trust analysis for networks
using the ss-calculus. Boolean expressions as annotations to
the base type system are used for this purpose. A safe environment for performing coercion of trustedness information
based on the results of runtime verification was introduced.
An algorithm for determining the most general type of an
expression in our system was also presented.

7.1 Related Work

The work presented here bares many similarities to the
discipline of flow analysis; for example that presented in [7,
23, 9]. Such work usually deals with a concept of security
levels; typically the idea that data should not be able to flow
(eg by assignment) from a high security level to a low one.
More generally, this is extended to use multi-point lattices
which may include notions of trust. We believe that our
approach differs from this area in several key points: our
system naturally handles non-determinism, whereas traditional methods have difficulty in this regard ([23]); our system requires no extra run-time type tag information; and
we provide a safe and natural method for performing runtime coercion of these trust levels. We also believe our approach can be extended to higher order systems fairly simply, and importantly without much more complexity being
introduced into the analysis; current work appears to verify
this.

Sewell and Vitek[21] present a system in which "off the
shelf" software can run in a constrained environment provided by software wrappers. Their analysis uses the box-ss
calculus, and they investigate the flow of information across
the boundaries of these wrappers. No avenue for allocating
trustedness is provided however.

Igarishi and Kobayashi[10] study linear type systems for
the ss-calculus, using a similar system of type annotations
(derived indepedently of [25, 24]).

7.2 Future Directions

Future work primarily involves study of a higher-order
ss-calculus (and corresponding type system). It has been
demonstrated[20] that in the regular ss-calculus system higherorder terms can be encoded as first-order with no loss of
expressiveness. We do not believe this to be the case for
our system (whether this view proves correct remains to be
seen!); we view a higher-order calculus as encoding mobile
code and thus potentially a situation involving not just untrusted data but also arbitrary code executing on your system. One consequence of a higher-order system is it seems
unreasonable to trust data coming from an untrusted process, even along a trusted channel. This implies that processes themselves must be annotated as well; for example

\Gamma ; ob ` P : ()

b

\Gamma ; ob ` Q : ()

c

\Gamma ; ob ` PjQ : ()b\Delta c

and perhaps more interestingly,

\Gamma ; ob ` x : ffi

b

\Gamma ; ob ` (*z)P : (ffi

T

)

c

\Gamma ; ob ` (*z)Q : (ffi

U

)

c

x =2 F V (P; Q)
\Gamma ; ob ` certify x P Q : ()

b\Delta c+^b\Delta d

Note that this last example provides a primitive kind of dependent type; if x can be trusted then the statement reduces
as P and the expression b\Delta c+^b\Delta d reduces to c; the annotation
on P above the line. Similarly if x proves to untrusted.

The authors also intend to investigate a type system (as
opposed to the current system of sorts) as is currently in
vogue; with this sort of arrangement instead of a mapping
between sorts and their objects, all information about what
is carried by the channels is contained in the types. (Note
that to get the same power as sorts it is then necessary
to admit recursive types). While this scheme does appear
to lose name-equivalence among types, it is hoped that the
corresponding inference algorithms can be simplified (both
in time and readability); in [22] a type inference algorithm
that is linear on the size of the input process is presented
(for an un-annotated type system).

8. ACKNOWLEDGEMENTS

Hepburn was supported by a University of Tasmania Postgraduate Research Scholarship. The authors are grateful to
the anonymous referees for their insightful and helpful comments.

9. REFERENCES

[1] http://www.beowulf.org/.

[2] http://www.seti.org/.
[3] http://www.distributed.net/.
[4] http://www.popularpower.com/.
[5] Abadi. Secrecy by typing in security protocols. In

TACS: 3rd International Conference on Theoretical
Aspects of Computer Software, 1997.

[6] D. E. Denning. The limits of formal security models.

National Computer Systems Security Award
Acceptance Speech.

[7] D. E. Denning. A lattice model of information flow.

Communications of the ACM, 19(5):236-243, May
1976.
[8] M. Hennessy and J. Riely. Information flow vs.

resource access in the asynchronous pi-calculus. In
27th International Colloquium on Automata,
Languages and Programming (ICALP '2000), Lecture
Notes in Computer Science. Springer-Verlag, Berlin
Germany, July 2000. A longer version appeared as
Computer Science Technical Report 2000:03, School of
Cognitive and Computing Sciences, University of
Sussex.
[9] K. Honda, V. Vasconcelos, and N. Yoshida. Secure

information flow as typed process behaviour. In
G. Smolka, editor, Programming Languages and
Systems: Proceedings of the 9th European Symposium
on Programming (ESOP 2000), Held as Part of the
Joint European Conferences on Theory and Practice
of Software (ETAPS 2000), (Berlin, Germany,
March/April 2000), volume 1782 of lncs, pages
180-199. sv, 2000.

[10] A. Igarashi and N. Kobayashi. Type reconstruction for

linear pi-calculus with I/O subtyping. Journal of
Information and Computation, 161(1):1-44, 2000. An
extended abstract appeared in the Proceedings of SAS
'97, LNCS 1302.

[11] F. Levi and C. Bodei. Security analysis for mobile

ambients.
[12] U. Martin and T. Nipkow. Boolean unification -- the

story so far. In C. Kirchner, editor, Unification, pages
437-456. Academic Press, 1990.
[13] R. Milner. The polyadic ss-calculus: A tutorial. In

F. L. Hamer, W. Brauer, and H. Schwichtenberg,
editors, Logic and Algebra of Specification.
Springer-Verlag, 1993.
[14] R. Milner, J. Parrow, and D. Walker. A calculus of

mobile processes, I. Information and Computation,
100(1):1-40, Sept. 1992.
[15] R. Milner, J. Parrow, and D. Walker. A calculus of

mobile processes, II. Information and Computation,
100(1):41-77, Sept. 1992.
[16] G. C. Necula and P. Lee. Safe, untrusted agents using

proof-carrying code. In G. Vigna, editor, Mobile
Agents and Security, volume 1419 of Lecture Notes in
Computer Science. Springer-Verlag, 1998.

[17] P. O/rbaek. Can you Trust your Data? In M. I. S.

P. D. Mosses and M. Nielsen, editors, Proceedings of
the TAPSOFT/FASE'95 Conference, volume 915 of
LNCS of Springer Lecture Notes in Computer Science,
pages 575-590, Aarhus, Denmark, may 1995.
Springer-Verlag.

[18] J. Palsberg and P. O/rbaek. Trust in the *-calculus. In

A. Mycroft, editor, SAS'95: Static Analysis, volume
983 of Lecture Notes in Computer Science, pages
314-330. Springer-Verlag, 1995.
[19] A. Sabelfeld and D. Sands. A per model of secure

information flow in sequential programs. Lecture Notes
in Computer Science, 1576:40-58, 1999.
[20] D. Sangiorgi. From pi-calculus to higher-order

pi-calculus--and back. In TAPSOFT. Springer Verlag,
LNCS 668, 1993.
[21] P. Sewell and J. Vitek. Secure composition of

untrusted code: Wrappers and causality types.
Technical Report 478, Computer Laboratory,
University of Cambridge, 1999.

[22] V. T. Vasconcelos and K. Honda. Principal typing

schemes in a polyadic pi-calculus. Lecture Notes in
Computer Science, 715:524-??, 1993.
[23] D. Volpano, G. Smith, and C. Irvine. A sound type

system for secure flow analysis. Journal of Computer
Security, 4(3):167-187, Dec. 1996.
[24] D. A. Wright. Reduction Types and Intensionality in

the Lambda-Calculus. PhD thesis, University of
Tasmania, 1992.
[25] D. A. Wright. Linear, strictness and usage logics. In

M. E. Houle and P. Eades, editors, Proceedings of
Conference on Computing: The Australian Theory
Symposium, pages 73-80, Townsville, Jan. 29-30 1996.
Australian Computer Science Communications.
[26] R. Yahalom, B. Klein, and T. Beth. Trust-based

navigation in distributed systems, 1994.