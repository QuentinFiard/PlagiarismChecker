

The Complexity of Subtype Entailment for Simple Types

Fritz Henglein and Jakob RehofDIKU, Department of Computer Science

University of CopenhagenUniversitetsparken 1, DK-2100 Copenhagen O/, Denmark
fhenglein, rehof g@diku.dk

Abstract
A subtyping o/ ^ o/ 0 is entailed by a set of subtyping
constraints C, written C j= o/ ^ o/ 0, if every valuation(mapping of type variables to ground types) that satisfies

C
also satisfies o/ ^ o/ 0.

We study the complexity of subtype entailment for simple
types over lattices of base types. We show that:

ffl deciding C j= o/ ^ o/ 0 is coNP-complete.
ffl deciding C j= ff ^ fi for consistent, atomic C and ff; fi

atomic can be done in linear time.

The structural lower (coNP-hardness) and upper (membership in coNP) bounds as well as the optimal algorithmfor atomic entailment are new. The coNP-hardness result

indicates that entailment is strictly harder than satisfiability,
which is known to be in PTIME for lattices of base types.The proof of coNP-completeness gives an improved algorithm for deciding entailment and puts a precise complexitytheoretic marker on the intuitive "exponential explosion" inthe algorithm.

Central to our results is a novel characterization of
C j= ff ^ fi for atomic, consistent C. This is the basis
for correctness of the linear-time algorithm as well as a
complete axiomatization of C j= ff ^ fi for atomic C byextending the usual proof rules for subtype inference. It also

incorporates the fundamental insight for understanding thestructural complexity bounds in the general case.

1. Introduction
1.1. Subtype entailment: Relevance and relatedwork

Subtyping is a fundamental concept in the theory of typedprogramming languages. Its basic principles are typically

studied in extensions of the simply typed lambda calculus.Following this line of research, the present paper studies
a problem in the standard system of structural subtypingdefined by Mitchell [15, 16] and subsequently studied extensively by many others (see references below.)

In structural subtyping a poset P of base types is lifted toan order (subtype) relation on structured types. This is done

via a subtype logic `P which defines derivable judgementsof the form

C `P o/ ^ o/ 0, where C is a finite set of subtypeconstraints between type expressions and

o/; o/ 0 are possiblystructured types. The simply typed lambda calculus is then

extended with a rule of subsumption, which allows any termhaving type

o/ under the subtype assumptions C to have anysupertype
o/ 0 of o/ , i.e., any type o/ 0 such that C `P o/ ^ o/ 0.The presence of subtype assumptions

C in typings of lambdaterms is necessitated by the desire to have

principal typings,see [9, 16].

However, in contrast to, e.g., the simply typed lambdacalculus and ML, subtyping systems typically suffer from
the problem that the size of principal typings may get in-tractably large for natural programs of even moderate size,
which makes typing information difficult to read and mayseriously slow down type inference in polymorphic frameworks. The problem is now widely recognized and hasgenerated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms(see, e.g., [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7].) Recently,
a number of researchers have independently suggested thatthe problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of
entailment (j=) rather than syntactic proof relations such as
`P . Such works include [18, 24, 7, 1, 8]. The rationale isthat a more powerful subsumption rule allows more typings

to be considered equivalent in the system, and hence moresuccinct representations of principal typings can be found.
Simplification algorithms exploiting this idea typically haveto decide a predicate of the form

C j=P ff ^ fi in orderto verify that a simplification step is sound. However, even

though several such algorithms have been suggested (see references above), no study has so far addressed the problemof the inherent computational complexity of subtype entailment (see, however, work on set-constraint entailment,such as [8, 4].) Indeed no nontrivial complexity results --
neither lower bounds nor interesting upper bounds -- havebeen given for subtype entailment. The present paper aims
at filling this gap for simple types over lattices.Whereas the complexity of subtype entailment is largely
unstudied, the complexity of subtype satisfiability is ratherwell-understood by now (see [22, 23, 2, 3]). In particular,
Tiuryn [22] has shown that the satisfiability problem forsimple types1 is PSPACE-hard in general but in PTIME if

Pis a lattice (see also [2, 3, 19] for various generalizations.)

Since the entailment predicate C j=P o/ ^ o/ 0 (does everyvaluation satisfying

C also satisfy o/ ^ o/ 0?) is at least ashard to decide as satisfiability in any non-trivial poset2, the

problem is certainly PSPACE-hard in general, and a naivealgorithm will give only a NEXPTIME upper bound.3 For
two reasons, however, it is of particular interest to know thecomplexity of entailment over

lattices of base types. Firstly,it is not clear that the problem is harder or just as easy

as satisfiability; in particular, it is a prima facie possibilitythat it might be in PTIME. 4 Secondly, virtually all recent
proposals for model-theoretic subtyping systems use latticesas models. Thus the lower bounds for subtype satisfiability
are inapplicable. Hence, we restrict ourselves in this paperto consideration of predicates of the form

C j=L ff ^ fiwhere
L is a lattice.In addition to the references given above, related work

on entailment problems in various set constraint theoriesshould be mentioned; recent papers include [8, 4].

1.2. Main results

The main results of this paper are as follows:
1. We prove a characterization theorem for entailmentwith atomic types (type variables and type constants)

over lattices, leading to a complete axiomatization ofatomic entailment and a linear time algorithm for deciding C j=L ff ^ fi where C is consistent.
1The satisfiability problem is: given a constraint set C of inequalities
between simple types, determine whether there exists a valuation assigningground types to variables in

C which makes all inequalities in C true in theground ordering?

2I.e. if the poset P is not the singleton set, then there are two distinct
elements b and b0 in P such that b 6^P b0 and the problem C j=P b ^ b0 isthen equivalent to the nonsatisfiability, the complement of the satisfiability

problem, for C.3The problem

C j=P ff ^ fi can be reduced to a problem with onlyatomic subtype assumptions (i.e., with no constructed types) modulo an

exponential expansion of the size of C.4

Note that whereas logical systems with negation sign typically haveentailment problems of equal complexity to that of the unsatisfiability

problem (by standard reduction of the former to the latter via negation),the situation is different in the rather weak logics of subtyping under study
here.

2. We prove that the general entailment problem for struc-tural subtyping for simple types is coNP-complete over

any non-trivial lattice. The result shows in whichprecise sense the intuitive "exponential" explosion incurred by a naive reduction of the general case to theatomic case is inherent. The resulting coNP-algorithm
exploits the characterization given for atomic entail-ment. It contains ideas that could be useful for engineering algorithms to decide entailment. The coNP-hardness result indicates that entailment is harder than
satisfiability for subtype inequalities.
3. The entailment problem is coNP-complete in a systemwith only a single binary

covariant type constructor. Itis also coNP-complete for simple types with additional

type constructors, including the contravariant functiontype constructor. This shows that the presence or absence of contravariance has no impact on the complex-ity of the problem.

The paper is structured as follows. In Section 2 wereview basic results on subtyping. These are primarily used
to establish the central characterization of entailment foratomic types (Theorem 3.2); this is done in Section 3. In
Section 4 we generalize the characterization to entailmentfor simple types. This is used in our proof that entailment
is in coNP in Section 4.1 and in the coNP-hardness proof ofentailment in Section 4.2.

2. Preliminaries

Fix a lattice (L; ^L) of base types. We assume a denu-merable set

V of type variables. The set of type expressionsover
L, denoted by TL(V), is ranged over by o/ , defined by

o/ ::= A j o/ \Lambda  o/ 0 j o/ ! o/ 0
A ::= ff j b

where ff ranges over V and b ranges over the constants in L.Constants from

L and variables are referred to collectivelyas atoms and are ranged over by

A. If o/ 2 TL(V) and novariable occurs in
o/ , then o/ is called a ground type. The setof ground types over

L is denoted TL. A constraint set Cis a finite set of formal inequalities of the form

o/ ^ o/ 0 with
o/; o/ 0 2 TL(V). C is called atomic if all inequalities in Chave the form

A ^ A0. We let Var(C) and Cnst(C) denote,respectively, the set of type variables appearing in

C and theset of constants appearing in
C.The subtype logic
`L is used in the definition of entail-ment below, and it is given in Figure 1. The subtype logic

defines provable judgements of the form C `L o/ ^ o/ 0,meaning that the inequality

o/ ^ o/ 0 is a provable conse-quence of the subtype assumptions in constraint set

C.The following definition explains the main concepts we

shall be interested in.

[const] C `L b ^ b0 ; provided b ^L b0
[ref] C `L o/ ^ o/
[hyp] C [ fo/ ^ o/ 0g `L o/ ^ o/ 0
[trans] C `L o/ ^ o/ 0 C `L o/ 0 ^ o/ 00

C `L o/ ^ o/ 00

[prod] C `L o/1 ^ o/ 01 C `L o/2 ^ o/ 02

C `L o/1 \Lambda  o/2 ^ o/ 01 \Lambda  o/ 02

[arrow] C `L o/ 01 ^ o/1 C `L o/2 ^ o/ 02

C `L o/1 ! o/2 ^ o/ 01 ! o/ 02

Figure 1. Subtype logic
DEFINITION 2.1 (Valuation, satisfaction, entailment) A sub-stitution

S is a function mapping type variables in V to typesin
TL(V), and it is lifted homomorphically to types in thestandard way, and it is extended to constraint sets by setting

S(C) = fS(o/ ) ^ S(o/ 0) j o/ ^ o/ 0 2 Cg.A ground substitution

ae : V ! TL is called a valuation.We say that a valuation

ae satisfies an inequality o/ ^ o/ 0,written
ae j=L o/ ^ o/ 0, if and only if ; `L ae(o/ ) ^ ae(o/ 0). If
C is a finite set of inequalities, then we say that ae satisfies
C, written ae j=L C, if and only if ae j=L o/ ^ o/ 0 for all
o/ ^ o/ 0 2 C. We say that C entails o/ ^ o/ 0, written
C j=L o/ ^ o/ 0, if and only if we have

8ae : V ! TL: ae j=L C ) ae j=L o/ ^ o/ 0

2
DEFINITION 2.2 (Closure, consistency) We say that a con-straint set

C is closed if

ffl o/1 ^ o/ 0 2 C and o/ 0 ^ o/2 2 C imply o/1 ^ o/2 2 C
ffl o/1 \Lambda  o/2 ^ o/ 01 \Lambda  o/ 02 2 C implies o/i ^ o/ 0i 2 C and
ffl o/1 ! o/2 ^ o/ 01 ! o/ 02 2 C implies o/ 01 ^ o/1; o/2 ^ o/ 02 2

C.

The closure of C, denoted cl(C), is the least closed setcontaining

C.We say that a set of inequalities is

consistent, if and onlyif we have
b ^L b0 whenever b ^ b0 2 cl(C). 2

Note that, in case C is atomic, we have C consistent if andonly if

8b; b0 2 L: C `L b ^ b0 ) b ^L b0
In the remainder of this section we give some basic lem-mas many of which are standard.

LEMMA 2.3 (Substitution Lemma)

1. If C `L o/ ^ o/ 0, then S(C) `L S(o/ ) ^ S(o/ 0).
2. If C j=L o/ ^ o/ 0, then S(C) j=L S(o/ ) ^ S(o/ 0)

PROOF As for 1, see [16]. As for 2, assume C j=L o/ ^ o/ 0and suppose that

ae j=L S(C), i.e., ae ffi S j=L C, hence (byassumption)
ae ffi S j=L o/ ^ o/ 0, i.e., ae j=L S(o/ ) ^ S(o/ 0). 2

DEFINITION 2.4 (Matching types, matching substitution,structural set) Two types are matching if they have the same
shape; in more detail, o/ and o/ 0 match if they are both atoms(possibly distinct) or else

o/ = o/1 \Lambda  o/2, o/ 0 = o/ 01 \Lambda  o/ 02 (or
o/ = o/1 ! o/2, o/ 0 = o/ 01 ! o/ 02) with o/1 matching o/ 01 and o/2matching

o/ 02.A set
C of inequalities is matching if it holds for all
o/ ^ o/ 0 2 C that o/ matches o/ 0.A

matching substitution for C is a substitution S suchthat
S(C) is matching.If there exists a matching substitution for

C, then wesay that
C is structural; in that case there is a most generalmatching substitution for

C (see [16] for details), denoted
MC, with the property that, whenever R is a matching sub-stitution for

C, then there exists a substitution V such that
R = V ffi MC; here the equality is restricted to hold onvariables that occur in

C. 2

LEMMA 2.5 (Match Lemma)

1. If C is atomic, and C `L o/ ^ o/ 0, then o/ and o/ 0 match.
2. Assume that C is structural. Then C j=L o/ ^ o/ 0 if and

only if MC(C) j=L MC(o/ ) ^ MC(o/ 0).

PROOF As for 1, see [16]. As for 2, the implication ())follows from the Substitution Lemma. To see the implication ((), assume MC(C) j=L MC(o/ ) ^ MC(o/ 0) andsuppose that

ae j=L C. Then it follows from the MatchLemma that
ae(C) is matching, so there exists a substitution
V such that ae = V ffi MC, and so we have by ae j=L Cthat

V j=L MC(C), and hence (by the assumption) we have
V j=L MC(o/ ) ^ MC(o/ 0), i.e., V ffi M j=L o/ ^ o/ 0, i.e.,
ae j=L o/ ^ o/ 0. 2

If C is satisfiable, then C must be structural, since if some
ae satisfies C, then ; `L ae(C) and hence, by the first part ofthe Match Lemma,

ae(C) must be matching.

LEMMA 2.6 (Decomposition Lemma)

1. If C is atomic, then C `L o/1 \Lambda  o/2 ^ o/ 01 \Lambda  o/ 02 if and onlyif

C `L fo/1 ^ o/ 01; o/2 ^ o/ 02g, and C `L o/1 ! o/2 ^
o/ 01 ! o/ 02 if and only if C `L fo/ 01 ^ o/1; o/2 ^ o/ 02g

2. C j=L o/1 \Lambda  o/2 ^ o/ 01 \Lambda  o/ 02 if and only if C j=L fo/1 ^

o/ 01; o/2 ^ o/ 02g, and C j=L o/1 ! o/2 ^ o/ 01 ! o/ 02 if andonly if

C j=L fo/ 01 ^ o/1; o/2 ^ o/ 02g

PROOF As for the first part, see [16]. As for the secondpart, the implications from right to left are obvious. As
for the other implications, if C j=L o/1 \Lambda  o/2 ^ o/ 01 \Lambda  o/ 02,and

ae j=L C, then ; `L ae(o/1) \Lambda  ae(o/2) ^ ae(o/ 01) \Lambda  ae(o/ 02),and hence (since

; is atomic) the first part of the lemmashows that
; `L fae(o/1) ^ ae(o/ 01); ae(o/2) ^ ae(o/ 02)g, i.e.,
ae j=L fo/1 ^ o/ 01; o/2 ^ o/ 02g. The second claim follows by thesame reasoning.

2

Notice that the decomposition property does not hold for `Lwith non-atomic constraint sets.

For atomic constraint set C over L, define the sets

"C(ff) = fb 2 L " Cnst(C) j C `L ff ^ bg
#C(ff) = fb 2 L " Cnst(C) j C `L b ^ ffg

Let the operations . and ^ denote the least upper bound andthe greatest lower bound in

L.

LEMMA 2.7 (Satisfiability)

1. Let C be atomic. If C is structural and consistent, then

(a) The valuation ae^ = fff 7! V "C (ff)gff2Var(C)

is a solution to C

(b) The valuation ae. = fff 7! W #C (ff)gff2Var(C)is a solution to

C

2. A general constraint set is satisfiable if and only if it is

structural and consistent.

PROOF See [14, 22] for the first part; the second part isproven in [22].

2

3. Atomic entailment

In this section, we consider the predicate C j=L ff ^ fiwith

C atomic, i.e., every inequality in C has the form
A ^ A0. We aim at a complete axiomatization of entailmentwith atomic constraint sets. Note that, in case

C is structural,the entailment problem
C j=L o/ ^ o/ 0 can be reduced, inlinear time, to the problem

C0 j=L ff ^ fi, where ff and fi arefresh variables and with
C0 the atomic decomposition (byLemma 2.6) of the result of applying a matching substitution

to the set C [ fff = o/; fi = o/ 0g. 5 For the purposes of thefollowing development it is therefore sufficient to consider
just entailments of the form C j=L ff ^ fi.

5Here o/1 = o/2 is a shorthand for the two inequalities o/1 ^ o/2 and
o/2 ^ o/2

We begin with a technical lemma. Given atomic con-straint set

C, we can regard C [ L as a digraph: there is anedge from

A to A0 for every inequality A ^ A0 in C, and Ldefines a digraph by stipulating that there is an edge from

bto
b0 whenever b ^L b0.

LEMMA 3.1 Assume C atomic, let b 2 L, and let ff and fibe two distinct variables. Assume that

(i) b 62#C(fi) and
(ii) C 6`L ff ^ fi
Then #C(fi) =#C[b=ff](fi)

PROOF (Sketch) By Lemma 2.3 we have (since ff 6= fi) that
C `L b0 ^ fi implies C[b=ff] `L b0 ^ fi, for any b0 2 L,which shows that

#C(fi) `#C[b=ff](fi).To prove the inclusion

#C[b=ff](fi) `#C(fi), we use that,whenever
b0 2#C[b=ff] (fi), there must exist a path Pb0 in
C[b=ff] [ L (regarded as a digraph) witnessing this fact.The inclusion then follows from the property

(\Lambda ) For any b0 2 L and any path Pb0 in C[b=ff] [ L wit-nessing

b0 2#C[b=ff] (fi) there is a path P 0 in C [ Lwitnessing

b0 2#C(fi).

The property (\Lambda ) is proven by induction on the length ofa path

Pb0 in C[b=ff] [ L of shortest length witnessing
b0 2#C[b=ff](fi). The induction proof involves a case anal-ysis over the form of the path

Pb0 which is tedious but notdifficult, and we leave out further details.

2

We can now prove the main result of this section:

THEOREM 3.2 Let C be atomic, structural and consistent,
ff and fi distinct variables in C. Then C j=L ff ^ fi if andonly if one of the following conditions holds:

(i) C `L ff ^ fi, or
(ii) V "C(ff) ^L W #C(fi)

PROOF ()). Assume C j=L ff ^ fi and C 6`L ff ^ fi Wemust then show

^ "

C(ff) ^L . #C(fi) (1)

We proceed by contradiction, assuming^

"C(ff) 6^L . #C(fi) (2)
Since C j=L ff ^ fi, we have by substitutivity of j=L(Lemma 2.3) and

ff 6= fi that

C[^ "C(ff)=ff] j=L ^ "C(ff) ^ fi (3)

Let Cy = C[V "C (ff)=ff]. By the Satisifiability Lemma(Lemma 2.7) we know, since

C is consistent, that the map

fff 7! ^ "C(ff)g
can be extended to a satisfying valuation for C. It followsthat

Cy is consistent. Then, by the Satisfiability Lemmaagain, we get that the valuation

ffl 7! . #Cy(fl)gfl2Var(Cy)
satisfies Cy. By (3) we then have^

"C(ff) ^L . #Cy(fi) (4)
If C j=L V "C (ff) ^ fi, then the Satisfiability Lemmaentails V

"C (ff) ^L W #C (fi) via the satisfying map
ffl 7! W #C (fl)gfl2Var(C), contradicting (2). We must

therefore conclude that C 6`L V "C (ff) ^ fi. Hence,V

"C (ff) 62#C (fi). This together with the assumption
C 6`L ff ^ fi allows us to apply Lemma 3.1, which showsthat

#C(fi) =#Cy(fi), and so by (4) we have^

"C(ff) ^L . #C(fi) (5)
But (5) contradicts (2), thereby proving (1) and hence theimplication

()).
((). If (i) is the case, the result follows immediately,and if

(ii) is the case, the result follows because we evidentlyhave

C j=L ff ^ ^ "C(ff) and C j=L . #C(fi) ^ fi

2
Theorem 3.2 shows that we get a sound and completeaxiomatization of the relation

j=L on atomic constraint setsby adding the following rules to

`L:

C `L A ^ b1 C `L A ^ b2

C `L A ^ b1 ^L b2

C `L b1 ^ A C `L b2 ^ A

C `L b1 .L b2 ^ A

C `L b1 ^ b2 b1 6^L b2

C `L o/ ^ o/ 0
The theorem also shows that the predicate C j=L ff ^ fi,where

C is atomic, can be decided very efficiently:

COROLLARY 3.3 Assuming .L; ^L and ^L are constanttime operations, given consistent constraint set C of size n
(number of symbols in C) it can be decided in linear timewhether

C j=L ff ^ fi.

PROOF Note that C, viewed as a directed graph, has O(n)vertices and

O(n) edges. Criterion (i) can be decided intime
O(n) by computing the set of of nodes reachable from
ff in C. As for criterion (ii), both V "C(ff) and W #C(fi)can be computed in time

O(n), again by computing the setof nodes reachable from
ff in C and by computing the set ofnodes reachable from
fi along the reverse edges in C. 2

4. Entailment with simple types

We have seen in the previous section that entailment hascomplexity of the same order as the provability relation

`Lwhen restricted to
atomic constraint sets. It turns out, how-ever, that this situation changes when constructed types are

allowed in constraint sets. Here, the provability relationis still decidable in PTIME (we can reduce the problem to
closure of a constraint graph, involving essentially transitiveclosure), whereas we show below that the entailment problem becomes coNP-complete in the presence of compoundtypes.

As in [13, 17, 18] we consider a type o/ as a functionfrom strings (called

addresses) in ff; s; d; rg\Lambda  (\Lambda  denotesthe empty string) to labels in

L = V [ L [ f!; \Lambda g. Here
f; s; d; r denote, respectively, first component and secondcomponent of a pair and domain and range of a function

type. For instance, b[p] (resp. ff[p]) is defined and equalto

b (resp. ff) if and only if p = \Lambda , o/ [f p] is defined if andonly if

o/ = o/1 \Lambda  o/2 and o/1[p] is defined; the value of o/ [f p] isthen the variable, constant or type constructor which can be

reached by traversing o/1 along the path described recursivelyby

p, and we identify o/ with the partial function *p:o/[p] withdomain dom

(o/ ). The parity of an address p, denoted ssp, is
0 if the number of d's in p is even and 1 otherwise.

4.1. Upper bounds

The problem of deciding C j=L ff ^ fi with a generalconstraint set

C is reducible to the atomic case in a straightforward way: expand

C by a most general matching substi-tution (if
C is not structural, the entailment holds trivially),and decompose the resulting set, using Lemma 2.6, into a

set of atomic constraints. This process may result in anexponential expansion of the set.

In this section, we show that general entailment can bereduced to the atomic case without expanding the entire
constraint set, since we can show that we need in fact onlyexpand the variables

ff and fi. The reduction is accom-plished by considering

p-entailment (precisely defined be-low), which captures entailment relations that must hold

between corresponding leaf variables, at address p, in theexpansions of

ff and fi.By exploiting characterizations of

p-entailment we thenproceed to show that the entailment problem is in coNP.

We first observe that the entailment relation j=L restrictedto atomic constraint sets is completely determined by

atomicvaluations, i.e., valuations mapping variables to constants in

L (rather than trees in TL). When C is an atomic constraintset we can define atomic entailment (written

C j=atL o/ ^ o/ 0)by requiring only that any
atomic valuation, which satisfiesall inequalities in
C, also satisfies o/ ^ o/ 0.

LEMMA 4.1 If C is atomic, then C j=L ff ^ fi if and only if
C j=atL ff ^ fi.

PROOF To see the implication ()), if C j=L ff ^ fi and
ae j=atL C, then ae j=L C, hence ae j=L ff ^ fi, hence (since aemaps every variable to an atom)

ae j=atL ff ^ fi.To see the implication
((), let ae be a valuation in TLand define the valuation
aeb in L to be the modification of aesuch that
aeb(ff) = ae(ff) if ae(ff) is an atom and aeb(ff) = botherwise. One can show by simple case analysis that, if

ae j=L C with C atomic, then aeb j=atL C for any fixed con-stant

b 2 L. Now suppose that C j=atL ff ^ fi with C atomic,but
C 6j=L ff ^ fi; then we can derive a contradiction in allcases using the observation above. For instance, if

ae j=L Cbut
ae(ff) 6^L ae(fi) because ae(ff) is not an atom and ae(fi) isan atom

b, then we choose a constant b0 such that b0 6^L b;we have

aeb

0 j=at

L C, hence aeb

0 (ff) = b0 ^

L aeb

0(fi) = b,

which is a contradiction. The remaining possibilities for
ae(ff) 6^L ae(fi) are handled similarly and are left to thereader.

2

A maximal address in a type o/ is an address p 2 dom(o/ )such that

o/ [p] is a leaf (i.e., p is not proper prefix of anyaddress in dom

(o/ )). We say that p is a maximal address for
ff in C if p is a maximal adress in MC(ff) (note that, byLemma 2.5, any such address is in the domain of

ae(ff) forany valuation
ae satisfying C.)

DEFINITION 4.2 (p-entailment) If p is a maximal address for
ff and fi in C, then we say that C p-entails ff ^ fi, written
C j=pL ff ^ fi, if and only if ae(ff)[p] ^ssp ae(fi)[p] for everyvaluation

ae satisfying ae j=L C and ae(ff)[p]; ae(fi)[p] 2 L.Here
^0 is ^L and ^1 its reverse. 2

LEMMA 4.3 C j=L ff ^ fi if and only if C j=pL ff ^ fi for
every maximal address p for ff and fi in C.

PROOF By the Match Lemma, we have C j=L ff ^ fi if andonly if

MC(C) j=L MC(ff) ^ MC(fi); by the Decomposi-tion Lemma, this is equivalent to

C0 j=L C00 where C0 and
C00 are the atomic decompositions of, respectively, MC(C)and

MC(ff) ^ MC(fi). By Lemma 4.1 it then follows thatwe have

C j=L ff ^ fi if and only if ae j=L ff ^ fi for everyvaluation

ae mapping every variable fl to a type matching
MC(fl) and with ae j=L C. It follows that the predicate
C j=L ff ^ fi is completely determined by valuations aesuch that

ae(ff)[p] and ae(fi)[p] are atoms for every maximaladdress
p for ff and fi in C. From this the lemma followseasily.

2

If a variable Sff does not get expanded by MC (i.e., \Lambda  ismaximal address for

ff in C), then we say that ff is atomic
in C. Let Ca denote the set of atomic inequalities in cl(C).

LEMMA 4.4 Suppose that ff and fi are atomic in C, and Cis structural and consistent. Then

C j=L ff ^ fi if and only
if Ca j=atL ff ^ fi.

PROOF For the implication from right to left, we note that,by Lemma 4.1 it is sufficient to prove that

Ca j=L ff ^
fi implies C j=L ff ^ fi, which clearly holds. For theimplication from left to right, let

bC = fo/ ^ o/ 0 2 cl(C) j o/ or o/ 0 is atomicg
By the decomposition property for j=L (Lemma 2.6), C is
equivalent to bC, and so it is sufficient to prove the implicationb

C j=L ff ^ fi ) C0 j=L ff ^ fi (6)
where C0 = ( bC)a. To prove this implication, assume

C0 6j=L ff ^ fi (7)
Then, by Theorem 3.2 (which applies since C0 is an atomicconstraint set), we have

^ "

C0 (ff) 6^L . #C0 (fi) (8)

Let

ae = fff 7! ^ "C0 (ff); fi 7! . #C0 (fi)g

We will show that

ae(C0) is consistent (9)
To prove (9) we proceed as follows. We have C0 6`L ff ^ fiby

(7), and moreover V "C0 (ff) 62#C0 (fi) (since other-wise we must have

C0 j=atL V "C0 (ff) ^ fi leading toa contradiction with

(8) via the satisfying valuation ae. ofLemma 2.7), and hence we have by Lemma 3.1

. #

C0 (fi) = . #Cy

0 (fi) (10)

with Cy0 = C0[V "C0 (ff)=ff]. It then follows fromLemma 2.7 that

ae can be extended to a satisfying valua-tion for
C0, and hence ae(C0) is consistent.
The final step is to show that

ae( bC) is consistent (11)
This can be proven from (9) by an argument similar to theone employed by Tiuryn in [22] to prove that any consistent
constraint set (over a lattice of base types) is satisfiable.Since the main ideas can be found in [22] we leave out
details here, but we note that the main point in the argument(in our case) is to prove that, since

C is consistent and ff and
fi are atomic in C, we have b ^ b0 2 cl(ae( bC)) if and onlyif

b ^ b0 2 cl(ae(C0)); the argument proceeds by inductionin the length of a shortest chain of inequalities witnessing

b ^ b0 2 cl(ae( bC)) and exploits the closure properties of bC.By

(11) and the equivalence of consistency and satis-fiability shown in [22],

ae can be extended to a satisfying

valuation ^ae for bC; by (8) we have ^ae(ff) 6^L ^ae(fi) which
shows bC 6j=L ff ^ fi, thereby proving (6). 2

For any address p, we define special type expressionscalled

p-templates; the idea of a p-template is that it is amost general type having

p in its domain. For instance, with
p = f sf , the type (ff1 \Lambda  (ff2 \Lambda  ff3)) \Lambda  ff4 is a p-template, andwith

p = f f f , the type ((ff1 \Lambda  ff2) \Lambda  ff3) \Lambda  ff4 is a p-template.More precisely, the sets

\Theta p of p-templates are minimal setsof types satisfying

ffl No variable occurs twice in any type in \Theta p for all p
ffl \Theta \Lambda  is, in each context of discussion, an infinite set offresh variables

ffl \Theta fp = f`p \Lambda  ffs j `p 2 \Theta pg
ffl \Theta sp = ffff \Lambda  `p j `p 2 \Theta pg
ffl \Theta dp = f`p ! ffr j `p 2 \Theta pg
ffl \Theta rp = fffd ! `p j `p 2 \Theta pg
LEMMA 4.5 Let ff ^0 fi be the inequality ff ^ fi and let
ff ^1 fi be the inequality fi ^ ff. Let C be a structuralconstraint set, and suppose that

(i) p is a maximal address for ff and fi in C
(ii) `ffp and `fip are two distinct p-templates which have novariables in common with each other and no variables

in common with C
(iii) ffp = `ffp [p] and fip = `fip [p]

(iv) Cp = C [ fff = `ffp ; fi = `fip g

Then C j=pL ff ^ fi if and only if (Cp)a j=atL ffp ^ssp fip.
PROOF We first show that we have

C j=pL ff ^ fi iff Cp j=L ffp ^ssp fip (12)
To see the implication from left to right in (12), we notethat by Lemma 4.3 we have

Cp j=L ffp ^ssp fip if and

only if Cp j=p

0

L ffp ^ssp fip for every maximal address p

0

for ffp and fip in Cp. But, since p is maximal for ff and fiin

C, it is easy to see that \Lambda  is the only maximal addressfor

ffp and fip in Cp, and hence it is sufficient to show that
C j=pL ff ^ fi implies Cp j=\Lambda L ffp ^ssp fip. This implicationis straight-forward and details are left for the reader. To see

the implication from right to left, suppose that ae j=L C with
ae(ff); ae(fi) 2 L; then it is easy to see that ae can be extendedto a valuation

ae0 satisfying Cp and with ae0(ffp) = ae(ff)[p]and
ae0(fip) = ae(fi)[p]. Then ae0(ffp) ^ssp ae0(fip) followsfrom the assumption of the right hand side of

(12), and thisproves the implication.

Since p is a maximal address for ff and fi in C, we clearlyhave

ffp and fip atomic in Cp, and therefore Lemma 4.4shows that we have

Cp j=L ffp ^ssp fip iff (Cp)a j=atL ffp ^ssp fip: (13)
Composing (12) and (13) proves the lemma. 2

As is well known ([16], [22]), testing whether a constraintset

C is structural is reducible to the problem of unifyingthe set (regarding inequalities in

C as equalities under uni-fication.) It follows that we can test in time

O(n) whether
C is structural, where n is the number of symbols in C.Moreover, in case

C is structural, we have MC(ff) match-ing
EC(ff), where EC is the most general unifier for C, forany

ff 2 Var(C) (see, e.g., [16, 22]); it follows that, for anyvariable

ff in Var(C), any maximal address p for ff in Csatisfies that

jpj is O(n), where jpj is the number of symbolsin
p.We can now show:

THEOREM 4.6 Let p be a maximal address for ff and fi in
C. Then the predicate C j=pL ff ^ fi is decidable in time
O(n3) where n is the number of symbols in C.

PROOF Recall from [22] that consistency of C is equivalentto satisfiability of

C, given that C is structural. To decide
C j=pL ff ^ fi, we first decide in linear time whether Cis structural. Moreover, we can decide consistency of

Cin time
O(n3) by computing cl(C), which can be done bydynamic transitive closure of a graph representation of

C.We can therefore assume from now on that
C is structural,consistent and hence satisfiable (otherwise the entailment

trivially holds.)Now fix

p to be the given maximal address for ff and fiin
C. By Lemma 4.5, it is sufficient to decide the predicate

(Cp)a j=atL ffp ^ssp fip (14)
with (Cp)a and ffp; fip defined as in Lemma 4.5. Computing
(Cp)a can be done by computing cl(Cp) which in turn canbe done in time

O(n3), since jpj is O(n) and hence the sizeof each of
`ffp and of `fip is O(n). Once we have computed
(Cp)a, we know by Corollary 3.3 that the entailment (14)can be decided in time linear in the size of

(Cp)a, which is
O(n3). 2

In turn, Theorem 4.6 leads to

THEOREM 4.7 The predicate C j=L ff ^ fi is in coNP.
PROOF It is sufficient to show that the predicate C 6j=L
ff ^ fi is in NP. By Lemma 4.3 this non-entailment holdsif and only if we can find a maximal address

p for ff and fiin
C such that C 6j=pL ff ^ fi. The NP-algorithm for decid-ing non-entailment therefore starts by non-deterministically

guessing a maximal address for ff and fi in C, which willserve as a succinct witness for the non-entailment.

Since the length of any maximal address for ff and fi in
C is linearly bounded by the size of C, guessing p can bedone non-deterministically in polynomial time. Checking

that p is indeed maximal for ff and fi in C is reducible toa deterministic linear time unification problem. Checking
that p is a witness for the non-entailment comes down tochecking

C 6j=pL ff ^ fi, which can be done deterministicallyin polynomial time, by Theorem 4.6.

2

A few remarks on Theorem 4.6 and Theorem 4.7 are inplace. Theorem 4.6 is used to prove Theorem 4.7, but the

former theorem has independent interest (which is why it isnot just a lemma.) The theorem says, when composed with
Lemma 4.3, that if we want to decide whether C j=L ff ^ fi,then we can do so by considering entailments at all the maximal addresses for ff and fi only, and each such entailmentcan be decided in cubic time. Now, there may be exponentially many addresses to consider in the worst case, but theinteresting fact stated in the theorem is that we need

onlyconsider addresses for
ff and fi. This is in sharp contrast toa naive approach where the entire constraint set is expanded

under matching and decomposed to atomic constraints. Incontrast, the theorem shows the possibility of deciding entailment with only a "demand-driven" form of expansion,since we only need to consider addresses in the expansion
of those variables which we are actually interested in. This,in turn, could be useful to engineer,

e.g., simplification ofconstraint sets without expanding the entire set.

In case L is finite, we have a shorter proof of Theorem 4.7(without relying on Theorem 4.6); in this case we could
guess a path p and then test, for each pair (b; b0) 2 L2 suchthat

b 6^L b0, whether or not the set C [ fff = o/b; fi = o/b0gis consistent, where

o/b is `ffp with b substituted for `ffp [p],
and o/b0 is `fip with b0 substituted for `fip [p]. This is just animplementation of the fact that we can express negation of a

constraint by explicit enumeration of all facts contradictingit, when the universe of facts is finite.

4.2. coNP-hardness

In this section we prove that deciding the predicate C j=L
ff ^ fi is coNP-hard; this holds for any non-trivial lattice
L, and in the presence of just a co-variant type constructor.This strongly suggests that there is no way we can bypass the

exponential expansion incurred by matching a structural set,in the worst case, in that we must guess maximal addresses
to decide non-entailment.A basic idea in the proof presented below is that, by
exploiting the characterizations of entailment developed inSection 3 Section 4.1, we can use maximal addresses to
encode truth valuations.

THEOREM 4.8 For any non-trivial lattice L, the predicate
C j=L ff ^ fi is hard for coNP under log-space reductions inthe presence of a single binary, co-variant type constructor.

PROOF In the following construction, we assume only thetype constructor

\Lambda . Moreover, since L is assumed to be anon-trivial lattice, we can assume that there are two elements

?; ? 2 L such that ? ^L ?.Fix two distinct variables

ff and fi. Let NENT be theproblem:

ffl Given C, decide whether C 6j=L ff ^ fi
We reduce SAT (propositional satisfiability, [10]) to NENT.This shows that NENT is NP-hard, which in turn shows that

the problem of deciding C j=L ff ^ fi is coNP-hard.The basic idea is that an address

p defines a truth assign-ment of an instance of SAT. Given

n variables x1; : : : ; xncontaining all the propositional variables occurring in an instance of SAT, we say that an address p = l1 : : : ln 2 ff; sgnof length

n defines a truth assignment Tp as follows:
Tp(xi) = true if li = f and Tp(xi) = false if li = s(note that

f means true and not false in this encoding.)Henceforth we shall think of addresses both as such and as

the truth assignments they induce in this fashion.Let us assume now that we are given an instance

I ofSAT, a set of clauses
fC1; : : : ; Cmg over x1; : : : ; xn. Eachclause is a finite disjunction of

atoms A. An atom is apropositional variable or its negation. Each clause defines a

set of truth valuations which falsify the clause; we call thisset the

exclusion set of the clause. Then, a truth valuation
T 2 ff; sgn satisfies I, if and only if T is not in the exclusionset of any clause in

I.Given
I we construct an instance C(I) of NENT (thatis, a constraint set) with the following intuition. For every

clause Ci = A1 . : : : . Ak in I we build a set of constraintsthat excludes exactly every address that (when read as a truth
assignment) falsifies the clause. By excluding we mean thatevery such address

p satisfies

C(I) j=pL ff ^ fi
so that, by Lemma 4.3, p is not a witness that the NENT-problem has a positive answer. This is done by making sure

that p becomes a maximal address for ff and fi in C(I) suchthat

C(I)p contains the inequalities ffp ^ ? and ? ^ fip;here

C(I)p and ffp; fip are as in Lemma 4.5. Furthermore,our construction is such that

ffp ^ fip is not deducible from
C(I) By our characterizations of entailment, this means thatexistence or nonexistence in

C(I) of an address p such that
ffp ^ ? and ? ^ fip determines whether C(I) 6j=L ff ^ fior

C(I) j=L ff ^ fi.Let us now describe in detail the construction of the set

C(I). The set of addresses that falsify clause Ci can bedescribed by a unique

address pattern Pi 2 ff; s; #gn.

An address pattern defines the set of addresses that ariseby replacing

# arbitrarily by either f or s. For example,
s##f s### is the address pattern that falsifies clause x1 .
:x4 . x5 for n = 8.Given an address pattern

P we define C(P; fl) as follows:

C(F P 0; fl) = fffi \Lambda  ffi0 ^ flg [ C(P 0; ffi) (ffi; ffi0 new)

C(SP 0; fl) = fffi \Lambda  ffi0 ^ flg [ C(P 0; ffi0) (ffi; ffi0 new)
C(#P 0; fl) = fffi \Lambda  ffi ^ flg [ C(P 0; ffi) (ffi new)

C(\Lambda ; fl) = f? ^ flg

Similarly, we define C\Gamma (P; fl): This is done by reversingthe inequalities in the first three clauses for

C above andreplacing the last clause by
C\Gamma (\Lambda ; fl) = ffl ^ ?g.Let
Pi be the address pattern that falsifies clause Ci.The constraints generated for

Ci are C(Pi; fi) [ C\Gamma (Pi; ff).The constraints
C(I) generated for I is the union of theconstraints generated for the individual clauses in

I.Now, to see that
C(I) is a reduction of SAT to NENT wehave to check:

I is satisfiable if and only if C(I) 6j=L ff ^ fi (15)
However, by Lemma 4.3 together with Lemma 4.5, we have
(15) equivalent to

p satisfies I if and only if CIp 6j=atL ffp ^ fip (16)
for every truth valuation p on the n variables of I; in (16),
CIp is the atomic set (C(I)p)a, defined as in Lemma 4.5,and

ffp; fip likewise.Inspection the construction of

C(I) shows that there areno chains of inequalities from any variable in any of the constraints in C\Gamma (Pi; ff) to any variable in any of the constraintsin

C(Pj; fi), for all i; j. Hence,

CIp 6`L ffp ^ fip (17)
To prove (16), assume first that p satisfies I. Since p sat-isfies

I, there can be no pattern Pi defining the exclusion setof
Ci such that p matches Pi. It then follows by constructionof

C(I) that

"CIp (ffp) = ; =#CIp (fi)

and hence^

"CIp (ffp) = ? 6^L ? = . #CIp (fip) (18)

which proves CIp 6j=atL ffp ^ fip by Theorem 3.2 togetherwith

(17).Finally, consider the implication from right to left in

(16).If
CIp 6j=atL ffp ^ fip, then we must have^

"CIp (ffp) 6^L . #CIp (fip) (19)

by Theorem 3.2 and (17). Let Pi be any pattern whichdefines an exclusion set for a clause in

I. If p matches Pi,then, by construction of
C(I), we see that ffp ^ ? 2 CIp

and ? ^ fip 2 CIp , contradicting (19). Hence, p cannot bein the exclusion set of any clause in

I, and hence p satisfies
I. 2

By Theorem 4.8 and Theorem 4.7 we have
COROLLARY 4.9 The entailment problem for simple types
over any non-trivial lattice is coNP-complete under log-space reductions; the problem remains coNP-complete in

the presence of a single co-variant type constructor.

References

[1] A. Aiken, E. Wimmers, and J. Palsberg. Optimal representations of polymorphic types with subtyping. Technical Report
UCB/CSD-96-909, University of California, Berkeley, July
1996.[2] M. Benke. Efficient type reconstruction in the presence of

inheritance. In Mathematical Foundations of Computer Science (MFCS), pages 272-280. Springer Verlag, LNCS 711,
1993.[3] M. Benke. Some complexity bounds for subtype inequalities.

Technical Report TR 95-20 (220), Warsaw University, Institute of Informatics, Warsaw University, Poland, December
1995.[4] W. Charatonik and A. Podelski. The independence property

of a class of set constraints. In Conference on Principles and
Practice of Constraint Programming, pages 76-90. SpringerVerlag, 1996. Lecture Notes in Computer Science, Vol. 1118.[5] P. Curtis. Constrained quantification in polymorphic type

analysis. Technical Report CSL-90-1, Xerox Parc, February
1990.[6] J. Eifrig, S. Smith, and V. Trifonov. Sound polymorphic type

inference for objects. In Proceedings OOPSLA '95, 1995.[7] M. Fahndrich and A. Aiken. Making set-constraint program
analyses scale. In Workshop on Set Constraints, Cambridge
MA, 1996.[8] C. Flanagan and M. Felleisen. Moduar and polymorphic

set-based analsysis: Theory and practice. Technical Report
Rice COMP TR96-266, Rice University, November 1996.[9] Y. Fuh and P. Mishra. Polymorphic subtype inference: Closing the theory-practice gap. In Proc. Int'l J't Conf. on Theory and Practice of Software Development, pages 167-183,
Barcelona, Spain, March 1989. Springer-Verlag.[10] M. Garey and D. Johnson. Computers and Intractability - A

Guide to the Theory of NP-Completeness. Freeman, 1979.[11] M. Hoang and J. Mitchell. Lower bounds on type inference
with subtypes. In Proc. 22nd Annual ACM Symposium on
Principles of Programming Languages (POPL), pages 176-
185. ACM Press, 1995.[12] S. Kaes. Type inference in the presence of overloading, subtyping and recursive types. In Proc. ACM Conf. on LISP
and Functional Programming (LFP), San Francisco, California, pages 193-204. ACM Press, June 1992. also in LISP
Pointers, Vol. V, Number 1, January-March 1992.

[13] D. Kozen, J. Palsberg, and M. Schwartzbach. Efficient recursive subtyping. In Proc. 20th Annual ACM SIGPLANSIGACT Symp. on Principles of Programming Languages,
pages 419-428. ACM, ACM Press, January 1993.[14] P. Lincoln and J. Mitchell. Algorithmic aspects of type inference with subtypes. In Proc. 19th Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programmin Languages (POPL), Albuquerque, New Mexico, pages 293-304.
ACM Press, January 1992.[15] J. Mitchell. Coercion and type inference (summary). In Proc.

11th ACM Symp. on Principles of Programming Languages
(POPL), pages 175-185, 1984.[16] J. Mitchell. Type inference with simple subtypes. Journal of

Functional Programming, 1(3):245-285, July 1991.[17] J. Palsberg and P. O'Keefe. A type system equivalent to flow
analysis. ACM Transactions on Programming Languages
and Systems, 17(4):576-599, July 1995.[18] F. Pottier. Simplifying subtyping constraints. In Proceedings

ICFP '96, International Conference on Functional Programming, pages 122-133. ACM Press, May 1996.[19] V. Pratt and J. Tiuryn. Satisfiability of inequalities in a poset.

Studia Logica (to appear).[20] J. Rehof. Minimal typings in atomic subtyping. To appear
in proceedings POPL '97, 24th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, Paris,
France, January 1997.[21] G. S. Smith. Principal type schemes for functional programs

with overloading and subtyping. Science of Computer Programming, 23:197-226, 1994.[22] J. Tiuryn. Subtype inequalities. In Proc. 7th Annual IEEE

Symp. on Logic in Computer Science (LICS), Santa Cruz,
California, pages 308-315. IEEE Computer Society Press,
June 1992.[23] J. Tiuryn and M. Wand. Type reconstruction with recursive

types and atomic subtyping. In M.-C. Gaudel and J.-P. Jouannaud, editors, Proc. Theory and Practice of Software Development (TAPSOFT), Orsay, France, volume 668 of Lecture
Notes in Computer Science, pages 686-701. Springer-Verlag,
April 1993.[24] V. Trifonov and S. Smith. Subtyping constrained types. In

Proceedings SAS '96, Static Analysis Symposium, Aachen,
Germany, pages 349-365. Springer, 1996. Lecture Notes in
Computer Science, vol.1145.