

Divergence of F<= type checking

Giorgio Ghelli1

Abstract
System F <= is an extension of second-order  typed lambda calculus, where a
subtype hierarchy among types is  defined, and bounded second-order lambda
abstraction is allowed. This language is a basis for much of the current research
on integration of typed functional languages with subtypes and inheritance. An
algorithm to perform type checking for F <= expressions has been known since the
language Fun was defined. The algorithm has been proved complete, by the
author and P.-L.  Curien, which means that it is a semi-decision procedure for
the type-checking problem. In this paper we show that this algorithm is not a
decision procedure, by exhibiting a term which makes it diverge. This result was
the basis of Pierce's proof of undecidability of typing for F<=. We study the
behavior of the algorithm to show that our diverging judgement is in some sense
contained in any judgement which makes the algorithm diverge . On the basis  of
this result, and of other results in the paper, we claim that the  chances that the
algorithm will loop while type-checking a "real program" are negligible. Hence,
the undecidability of F <= type-checking should not  be considered as a reason to
prevent the adoption of F <= as a basis for defining programming  languages of
practical interest. Finally, we show the undecidability of an important subsystem
of F<=.

1 Introduction
The language  `Fun' was introduced in [Cardelli Wegner 85] to formalize the
relationships between subtyping, polymorphism,  inheritance and modules in a strongly
typed language.  Fun in its entirety is very rich, but a subsystem of it, called F<=, has
been recognized as a minimal kernel which collects the main technical substance of the
recursion-free part of the language.  Technically, system  F <= is an extension of the
second-order l-calculus defined by Girard and Reynolds, [Girard 72] [Reynolds 74], with
subtypes, bounded second-order abstraction, and a maximum type  Top which allows
unbounded quantification.  F<= was formalized in [Curien Ghelli 92], by modifying the
system defined in  [Bruce Longo 90]. Extensions of Fun and F<= are the basis of most
current research on the  integration of the capabilities of object-oriented languages and
functional languages in a strongly typed context (see, e.g., [Canning Hill Olthoff 88]
1Dipartimento di Informatica, Universita` di Pisa, Corso Italia 40, I-56125, Pisa, Italy, ghelli@di.unipi.it.
This work was carried out with the partial support of E.C., Esprit Basic Research Action 6309 FIDE2, ofthe Italian National Research Council, "Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo" grant

No. 92.01561.PF69, and of the Ministero dell'Universita` e della Ricerca Scientifica e Tecnologica.

1

[Cook 89] [Canning et al 89] [Mitchell  90] [Danforth Tomlinson 88] [Cardelli Martini
Mitchell Scedrov 91][Ghelli 91] [Bruce 91] [Cardelli Mitchell 91] [Mitchell et al 91]
[Bruce 92] [Hofmann Pierce 94]  [Bruce 93] [Ghelli 93a] [Gunter Mitchell 93] [Pierce
Turner 93]). 

An algorithm to assign a type to every well-typed  Fun term and to check whether a type
is a subtype of another was already known when the language was presented, and can be
attributed to Luca Cardelli. In [Curien Ghelli 92] this typing algorithm was formalized for
F<= and proved correct and complete. In the same paper the algorithm is shown to be the
"natural" one with respect  to a notion of "normal form" of type-checking proofs.
Correctness and completeness mean that the algorithm successfully terminates on all and
only the typable terms, but do not imply that it terminates on non-typable terms. The
termination of subtype  checking would immediately imply the termination of type
checking, but it was not even known whether subtype checking terminates or not.

In this paper we show that there are terms which make that algorithm diverge,
contradicting the faulted termination proof given in [Ghelli 90]. Then we study the
features which characterize those judgements which make the algorithm diverge (the
"diverging judgements").

The basic aim of this study was to settle a basis on which to determine whether the
F<= typing problem is decidable. We were successful in this, since our result was actually
the basis of Benjamin Pierce's proof  of undecidability of  F<= [Pierce 93]. Even though
this part of the problem has been closed, our analysis of  the algorithm behavior is still
useful to understand what makes the problem difficult. This kind of information may be
used to design  decidable variants of the language; such variants have been recently
proposed, for example, in [Katiyar Sankar 92] and [Castagna Pierce 94].

Another reason to study diverging judgements is to understand whether  they may
appear in "real programs". Here we claim that diverging judgements are artificial ones,
which do not arise "naturally" in  real programming, and we substantiate this claim by
defining a set of features which must be shared  by all diverging judgements. The
awkwardness of these constraints supports our belief that the undecidability of F<= is not
a problem of practical concern, hence that F<= can be safely used as a basis for designing
programming languages. 

Finally, diverging judgements are related to the addition of recursive types to F<=. In
[Ghelli 93a] we showed that, surprisingly enough, type-level recursion is not conservative
over F<= subtyping. This means that there are some  F<= unprovable subtyping judgements
which become provable (by transitivity) when recursive types (regular infinite trees) are
added to F<=. One of these judgements is in fact the diverging judgement introduced here.
In [Ghelli 93a] we also show that the set of non-recursive judgements which become
provable by adding recursive types is (properly) included in the set of diverging
judgements. This result shows that, even though diverging judgements are defined here in
terms of the behavior of a specific algorithm, they have a wider role in F<=, which should
be better understood.

In this paper, we also show the undecidability of an important variant of F<=, system
Fbq. Other variants are discussed in [Ghelli 93b].

This paper is structured as follows. Section 2 introduces the language and the algorithm.
In Section 3 we show a judgement which makes the standard type checking algorithm for

2

F<= diverge. Section 4 studies the features of any diverging judgment, showing the
minimality of the one  presented in Section 2. Finally in Section 5 we prove that type
checking the subsystem Fbq of F<= is as hard as typechecking the whole F<=.

2 The language and the algorithm
2.1 The language
The language  F<= was defined in [Curien Ghelli 92], as a more essential version of
Cardelli and Wegner's Fun language. The syntax of F<= is defined as follows:

Types T ::= t  |  Top  |  T#T  |  O't<=T. T Terms

a ::= x  |  top  |  lx:T. a  |  a(a)  |  Lt<=T. a  |  a{T}Environments G

::= ()  |  G, t<=T  |  G, x:TJudgements
  J  ::= G z^ a : T  |  G z^ T <= T  L

t<=T.a is the  second-order abstraction of the expression a with respect to the type
variable  t; the bound  <=T means that  only subtypes of T  are accepted as parameters.
a{T} is the corresponding application of a function to a type.

The type Top is a supertype of all types, useful for codifying an unbounded secondorder lambda abstraction as Lt<=Top.a; top is a "canonical" term of type Top.O'

t<=T1.T2 is the type of a function  Lt<=T1.a, with T 2, the type of a, generally
depending on t.

A judgement Gz^a:T  means that  a has type  T with respect to the environment  G,
which collects information  about the free variables of a and T ; Gz^T<=U  means that  T
is a subtype of U , i.e. that an expression of type  T can be used in any context where an
expression of type U can be used, again with respect to G.

The constants O' , l , L  bind their variable in their second argument, as usual;
similarly a definition  t<=A in the environment  binds t in the following part of the
judgement; the  scope of a variable is the part of the judgement where that variable is
bound. In a quantified type  O't<=A.B and in an environment ... t<=A... we say that  A  is a
bound (i.e. an upper limit) for t, and that t is bounded by A.

Throughout the paper we always distinguish between "a variable" and "an occurrence
of a variable". The use of these terms is best explained by an example: in the judgement

t<=Top z^ O'u<=t. t#u  <=  Top
there are two  variables ( t  and u ), two  occurrences of the  variable t and one
occurrence of the variable  u; these three occurrences are underlined (a more formal
definition of occurrence is in Section 4). Two variables are different  when there is onea

-variant of the judgement where they have different names (a-equivalence is defined as
usual). For example, in the following judgement we have  three different variables with
the same name t, and we have two bound occurrences of each variable:

t<=Top z^ t # (O't<=Top. t#t) <= t # (O't<=Top. t#t)
A judgement is well formed if all variable occurrences are bound and all  different
variables have different names; hence the above judgement is not well formed2.
2 Names of variables may be seen, as usual, as a readable denotation of their DeBruijn indexes [DeBruijn
72]; however, in this context, carefully managing names of variables helps to avoid some pitfalls.

3

The typing rules of the language are grouped together in Appendix A for reference. These
rules are implicative formulae which may be read as Horn clauses, which define a typechecking algorithm in a Prolog style, by specifying how to reduce the type-checking  or
subtype-checking problem in the consequence to the type-checking or subtype-checking
problems in the premises. But two of these rules,  (Subsump) and (Trans), would make
any Prolog interpreter diverge, since they reduce a problem to the same problem
(Subsump), or to a pair of more general problems  (Trans). In proof-theoretic terms they
both resemble a "cut  rule". In [Curien Ghelli 92] any provable subtyping or typing
judgement was proved to admit a single "normal form" cut-free proof, and an alternative
set of rules was defined which produces  all and only the "normal form" proofs of  F<=.
The operational interpretation of these "algorithmic rules" (reported in Appendix B)
defines a pair of deterministic algorithms:

* a type checking (or  type assignment ) algorithm  Gz^a:A, which computes A fromG 

and a;

* a subtype checking algorithm  G z^ A<=B, which, given  G , A  and B , either is

successful or fails.

Both algorithms work as follows: the input problem is compared with the conclusion of
all the rules, the only matching rule is used to reduce the problem to the subproblems in
the premises of the rule, and finally these subproblems are solved in the specified order,
by recursively applying the same algorithm (see also Section 2.2). The algorithm
terminates with success when all the subproblems match the terminal rules AlgId<=,
AlgTop<=, AlgVar and AlgTop; it terminates with failure when no rule  matches a
subproblem (e.g.  Gz^Top<=t), or when an output  type does not match the expected
shape3. Note that this algorithm is deterministic (without backtracking), since for each
judgement there is at most one applicable rule. This determinism was achieved by
reducing the scope of transitivity, which can only be applied to type variables
(AlgTrans), and the scope of subsumption, which can only be used within function
application (AlgApp, AlgApp2).

The correctness and completeness of the above  algorithm are proved in [Curien Ghelli
92]. Correctness means that if the algorithm answers  `A' to a  question ` Gz^a:?' thenGz^

a:A is provable in the system; this can be proved easily, since  the algorithm merely
applies rules which are derivable within the system.

Completeness means that if Gz^a:A is provable in the system, the  algorithm applied
to the input  G,a terminates, with a correct answer (actually it returns the minimum
correct type). But note that in [Curien Ghelli 92] the fact that the algorithm terminates, on
typable terms, is not proved by studying its computational behavior, but only indirectly,
as a consequence of the fact that any provable judgement has a finite "canonical" proof,
and that each step of the algorithm builds a piece of this finite proof.

Correctness and completeness of the type checking algorithm do  not imply that the
problem is  decidable, since the algorithm may still diverge on non-typable terms.
Decidability of type checking would follow immediately from decidability of subtype
checking, since a rule for  Gz^a:? only invokes the same algorithm applied to strict
3More precisely, when in rules (AlgApp)  and (AlgApp2), the minimum non variable supertype  G*(T)
of the type T of the applied term f does not match A#B or O't<=A.B, respectively (see Appendix B).

4

subterms of a and the subtype checking algorithm. For this reason, in the rest  of the
paper we will only study the subtype checking algorithm, which is the hard kernel of type
checking.

2.2 The subtype checking algorithm
In this section we formally describe the subtype-checking algorithm, with the  help of a
term rewriting relation " i^i"i"A*", which reduces a judgement to its  antecedents in the
applicable subtyping rule.

From now on we study a simplified type system without the # type constructor, since it
does not add any complexity to the subtype relation: in fact,  G z^  A# B' <= A' # B is
provable if and only if G z^  O'x<=A.B' <= O' x'<=A'.B is provable, where x  and x ' are
fresh type variables.

In our study of the algorithm we want to be able to follow the evolution of a variable
through different "i^i"i"A*" rewriting steps. To this aim, when two different variables are
unified by the backward application of the (O'<=) rule:

(O'<=) G z^ A<=A' G, t'<=A z^ B[t'/t] <= B'

--------------------------G z^ O't<=A'.B <= O't'<=A.B'

instead of applying the substitution  B[t'/t], we will record the unification of t and t'  in
the environment and leave B and B' as they are, by writing G, (t=t')<=A' z^ B' <= B.

For a similar reason, we duplicate the <=  relation into two relations,  Gz^A<=B andGz^

B>=A, such that  Gz^A<=B ## Gz^B>=A. This allows the ( O'<=) rule  to be rewritten as
follows (recall that "i^i"i"A*" denotes the backward application of a rule):

(O'<=)       G z^ O't<=A.B' <= O't'<=A'.B     i^i"i"A*     {   G z^ A >= A',   G, (t=t')<=A' z^ B' <= B     }
In this way, the residuals  A and B'  of the left hand side of the  comparison  O't<=A.B' are
still on the left hand side, and similarly for the right hand side. This notation is exploited,
in particular in Section  4.5, to study the "i^i"i"A* "  reduction invariant properties of each
side of the comparison. Hereafter we will usually only give definitions and examples in
terms of the Gz^A<=B case; the other case is always defined symmetrically.

To summarise, the syntax of the types and judgements managed by the algorithm is:

Types A ::= Top  |  t  |  O't<=A.AEnvironments G

::= ()  |  G, (t=t)<=AJudgements
J ::= G z^ A <= A  |  G z^ A >= A  |  true  |  false

In well-formed judgements all variables are bound, and different variables have different
names.

The reduction relation " i^i"i"A*" is defined by the  following term rewriting rules, plus the
symmetric rules obtained by exchanging  A<=B with B>=A ( Gz^t~u, read " G  unifies  t
and u", means that either t is u, or   (u =t )<= A  is in G , or   (t=u)<=A is in G ; " ~" is
only defined on variables):

5

(lhs-top) G z^ A' <= Top i^i"i"A* true
(lhs-varId)Gz^t~u " G z^ u <= t i^i"i"A* true

(lhs-exp) G-oC~u, Cz'Top " G z^ u <= C i^i"i"A* G z^ FreshNames(G(u)) <= C
(lhs-O'dom) G z^ O't<=A.B' <= O't'<=A'.B i^i"i"A* G z^ A >= A'

(lhs-O'cod) G z^ O't<=A.B' <= O't'<=A'.B i^i"i"A* G, (t=t')<=A' z^ B' <= B

(lhs-false) when nothing else applies:  G z^ A <= B i^i"i"A* false
The above rules will be called "left hand side rules"; the "right hand side rules" are
obtained by inverting the comparisons, like in the  (rhs-exp) rule below (hereafter, we
will omit the lhs-/rhs- prefix when it is not needed):

 (rhs-exp)G-oC~u, Cz'Top " G z^ C >= u i^i"i"A* G z^ C >= FreshNames(G(u))
In the  (exp) rule,  G(u) is the bound of  u defined in G; FreshNames (G(u)) renames
all the variables  defined inside  G (u)  with unused variable names, to preserve the
invariant that different variables in a judgement have different names4. We will write
(exp)(A) to denote an  (exp) step which expands  the variable to  A  (i.e ., A  is
FreshNames(G(u)). After the execution of a  (O'cod) step, the definitions O' t and O' t'
of the variables  t and t' disappear from the  comparison and appear, as (t=t')<=A' , in the
environment. For this reason, we will often say that a  (O'cod) step "moves the
definitions of t and t' into the environment".

The only two normal form terms of the above system are true and false . Each
judgement which differs from  true and false  can be reduced by exactly one rule, with
the only exception of judgements of the form  G z^  O't<=A.B' <=  O't'<=A'.B, reduced by the
two  O' rules. ( O'dom) is the only rule which inverts the direction  of the comparison.
When there exists one infinite reduction chain which starts from a judgement J, we  say
that J is a diverging judgement.

The subtype-checking algorithm works by maintaining a "to-do list" of subtyping
judgements to be proved, which initially only contains the input judgement. At each step,
one of the to-do judgements is substituted with its immediate antecedent(s), by applying
the "i^i"i"A*" rewrite rules. A judgement which reduces to  true is simply removed from the
list. If a judgement in the to-do list reduces to  false, the algorithm stops and reports a
failure, meaning that the original judgement was not provable. The algorithm stops with
success when the list is emptied.

This algorithm explores the set of all the " i^i"i"A*" chains which start from a judgement
J; it stops either  when it meets one chain which terminates with false , or when all
chains are built, and all of them terminate with true. If both infinite chains and chains
ending with  false start from a judgement  J, then the algorithm may either diverge  or
stop, depending on how it manages its to-do list. However, we will exhibit a judgement J
which is diverging but does not rewrite to false ; when applied to such a judgement, the
algorithm necessarily diverges. For this reason, in the rest of the paper we will ignore the
problem of the choice of the judgement to be rewritten at each step5, but we will focus
4In our examples we  use Greek letters for variables defined inside a bound in the environment to
emphasize the fact that these names must be changed any time the bound is copied into the comparison:

..., u <= O'x<=t.x z^ u <= A   i^i"i"A*(exp)   ..., u <= O'x<=t.x z^ O'v<=t.v <= A

6

on the exploration of a single rewriting chain, and on the existence of infinite rewriting
chains.

Notation: Hereafter we will use these abbreviations:O'

t.A abbreviates O't<=Top.A
-A abbreviates O't<=A.Top where t is a fresh variable

These abbreviated terms can be reduced by the following derived rules:

(O'dom') G z^ -A <= -A' i^i"i"A* G z^ A >= A'(O'cod') G z^ O't.B' <= O't'<=A'.B i^i"i"A* G, (t=t')<=A' z^ B' <= B

2.3 Executing judgement rewriting
The judgement rewriting process can be seen as an interleaving of scanning and
substitution steps performed on the compared types. This point of view will be useful, in
particular, in Sections 3 and 4.4.

We can represent each compared type by a tree plus a pointer which specifies which
subtree is being considered (see Figure 1). Then, a  (O') step moves the pointer down the
two trees, while an  (exp) step substitutes  a leaf which is a variable with a copy of its
bound, renamed by FreshNames. For example, the following reduction sequence:z^

 O't<=(

O'O'O'O'

O' z<=A.z) .C >= O't'<=(
O'O'O'O'

O'z'<=A'.B').C' i^i"i"A*(O'dom)z^
 O'z<=A.z <= O'z'<=A'.B' i^i"i"A*(O'cod)
z=z'<=A' z^ z <= B' i^i"i"A*(exp)
z=z'<=A' z^ FreshNames(A') <= B'

can be visualized as in Figure 1 (the dashed pointer points to the smaller side).

O'domO'z C C'O't O't'O'z'
A' B'A z O'

z C C'O't O't'O'z'

A' B'A z

O'z C C'O't O't'O'z'

A' B'A O'

z C C'O't O't'O'z'

A' B'A A'

O'cod
exp(FN(A'))
z
Figure 1.  Subtype checking means scanning+substituting.

5The simplest, and most efficient,  approach is to explore the rewriting chains in a depth-first way,
holding the to-do list in the stack. By exploring the different chains in a breadth first way, i.e. by cyclingbetween all judgements in the to-do list, divergence would be avoided on judgements which both diverge

and rewrite to false. However, breadth-first exploration would not be worthwhile in practice, in view of theclaim that divergent judgements do not arise in real programs.

7

3 A diverging judgement
Since Fun was defined, the algorithm in Section 2.1 was considered to be the natural one
to type-check it. It was believed to be a decision procedure, and some researchers tried to
prove this fact.  The problem was apparently settled by the author, who produced a
"proof" of termination of the algorithm. This "proof" was published in [Ghelli 90] and
checked by a few people, until Pierre-Louis Curien and, independently, John Reynolds,
discovered a subtle bug in it. The attempts to remove that bug  finally produced a
surprising result: the algorithm is not a  decision procedure, and a diverging judgement
can be written.

A minimal diverging judgement is:

v0<=(O'x.-O'y<=x.-x)   z^ v0 <= O'u1<=v0.-v0
This judgement produces no chain ending with  false and produces only one infinite
rewriting chain. The first few judgements in this chain are listed below:

B=O'x.-O'y<=x.-x
1) v0<=B z^ v0 <= O'u1<=v0.-v0 (lhs-exp)
2) v0<=B z^ O'v1.-O'u2<=v1.-v1 <= O'u1<=v0.-v0 (lhs-O'cod')
3) v0<=B, u1=v1<=v0    z^ -O'u2<=v1.-v1 <= -v0 (lhs-O'dom')
4) v0<=B, u1=v1<=v0 z^ O'u2<=v1.-v1 >= v0 (rhs-exp)

5) v0<=B, u1=v1<=v0    z^ O'u2<=v1.-v1 >= O'v2.-O'u3<=v2.-v2 (rhs-O'cod')
6) v0<=B, u1=v1<=v0, u2=v2<=v1 z^ -v1 >= -O'u3<=v2.-v2 (rhs-O'dom')
7) v0<=B, u1=v1<=v0, u2=v2<=v1 z^ v1 <= O'u3<=v2.-v2 (lhs-exp)
8) v0<=B, u1=v1<=v0, u2=v2<=v1 z^ v0 <= O'u3<=v2.-v2 (lhs-exp)

We will now try to describe informally what happens; all the ideas sketched here will be
formalized in Section 4.

We say that a variable  t refers to  u if either  u appears free in the bound of t, or if
t refers to some  v which in turn refers to  u; e.g., in  O' v<=u.O't<=v.t, t refers to both  v
and u (this is made formal in Section 4.5). The typing rules enforce that no variable can
refer to itself; this implies, apparently, that  once a variable has been expanded in both
sides of the comparison, it cannot appear in the comparison anymore. This was the main
assumption supporting the idea that the algorithm should always terminate.

However, expanded variables can be reintroduced into a comparison, due to the
(O'cod) rule which changes  the bound of the variable on the smaller side. Consider
Figure 2, where the first three steps of the infinite chain are depicted; in the four
comparisons, the variable occurrences which refer to v0 are underlined; the environment
is depicted on top of the compared types.

8

O'cod'
O'dom'
 expv0 v
0 O'

u1

- O'u

2

v1 v

1

-
-
v0 O'

v1

O'u2
v1 v

1

-
-

O'v1

v0 O'

u1

-v
0

v0 O'

u1

-v
0 O'u2

v1 v

1

-
-

O'v1

v0 O'

u1

-
v0

v0 <= "x. -"y<=x. - x

(u1= v1) <= v0

v0 <= "x. -"y<=x. - x

(u1= v1) <= v0

v0 <= "x. -"y<=x. - x v0 <= "x. -"y<=x. - x

Figure 2.  The first three steps of the infinite rewriting chain.
In the first step v0 is substituted by a bound which does not refer to  v0. However, when
the  (O'cod') step unifies  u1 with v1, the bound of  v1 becomes v0, hence the left hand
side now contains two references to  v0. The next ( O'dom') step inverts the roles of the
two sides and recreates, essentially, the initial situation, with  v0 referred by both sides.
Note the different roles of the two v0's in  O'u1<=v0.-v0: the first one is moved in the
environment and is needed to make v1 a reference to v0; the second one is the one which
will be expanded. Exactly the same roles will be played by the two occurrences of v1 inO'

v1.-O'u2<=v1.-v1. This is the basis for an infinite series of expansions of the same
variable.

Although this minimal diverging judgement exhibits a kind of cyclicity which seems
easy to detect, the reader can verify that this pattern could be enriched in increasingly
complex ways. Actually, Pierce's  undecidability result implies that there is no general
way to detect whether the algorithm enters an infinite loop [Pierce 93].

The rest of this paper analyses the behavior of the  subtype checking algorithm. This
analysis defines a set of constraints on the shape of diverging  judgements, which show
that all of these judgements must share a rather complex structure, and that the diverging
judgement above exhibits, in some sense, the typical behavior of any diverging
judgement. This "uniqueness" of the diverging  judgement means that any attempt at
designing a decidable variant of F<= can be focussed on avoiding this kind of divergence.

4 The behavior of the subtype checking algorithm
4.1  Overview
In this section we study the properties of diverging judgements, to show that they all
share the basic features of our minimal case, as will be elaborated. In fact, these studies
were first performed without knowing whether a diverging judgement existed or not, and
their final result was the design of the judgement presented in the previous section.

9

We first show (Section 4.2) that in a rewriting chain nothing new is ever created:
every type occurring in any judgement in the chain is equal, up to variable renaming, to
some type occurring in the first judgement of the chain. We then associate a polarity with
every occurrence of a type in a judgement, and  show that reduction preserves polarity.
These facts imply that every infinite rewriting chain eventually compares infinitely many
times the same pairs of types  (up to variable renaming). Hence, the complexity of the
problem essentially comes from the possibility of an unlimited growth of the
environment.

In Section 4.3 we prove that, in any diverging judgement, a variable exists which is
expanded infinitely many times. This is a key result, and is the basis of most of the other
results of Section 4. It is proved by first showing that: (a) in an infinite rewriting  chain
infinitely many new variables are created; (b) that new variables  are always created by
expanding variables with a strictly bigger bound.

In Section 4.4 we define a reduction invariant, called the inversion depth, defined as
the maximum nesting  level of bounds inside bounds. We show that a judgement may
diverge only if this nesting level is at least three. This is  the first result supporting our
claim that "only weird judgements diverge".

In Section 4.5 we go back  to the result that in a diverging judgement there is one
variable which is expanded infinitely many times, and  describe the conditions which
make this possible. To this aim, we first formalize the notion of reachability informally
introduced in Section 3. Then we show that, when a variable is expanded on one side, it is
not reachable from that side in the resulting judgement, but it may become reachable
again by obtaining a reference to that variable from the other side. To this aim, the
(O'cod) rule must be used in a very specific way, which is described in this section. This
way of using the (O'cod) rule is the second piece of evidence that we give for the "onlyweird-judgements-diverge" claim.

Finally Section 4.6 shows that the shape of our minimal judgement  is typical for
diverging judgements. More precisely, we show that every occurrence in the bound of our
diverging judgement derives from the need to regain a reference to an expanded variable.
This implies that any diverging judgement must always contain, buried under other
details, the same pieces as our minimal one, all of them playing the same roles.

4.2  Basic properties and definitions
In this section we show that in a rewriting chain essentially the same pairs of types are
always compared.

We first collect some definitions (occurrence, closed form of a judgement, occurrence
with respect to a judgement, polarity) which will be used in the next subsections.

Definition 4.1 (occurrence): An  occurrence m is a string of 0's and 1's, used to refer to

a subterm  A/m of a type  A as follows ( e is the empty sequence; "." denotes
concatenation):

A/e = A
(O't<=A.B)/(0.m) = A/m
(O't<=A.B)/(1.m) = B/m

Intuitively, m specifies a path to be followed to extract A/ m from A: a 0  directs into

10

the bound and a 1 directs into the codomain; the subterm is found when the path ends.

The  valid occurrences of a type T  are all those occurrences m such that  T/m is
defined. A[B/m] denotes the result of substituting the subterm at the occurrence m
of A with B ; A [ B / t ]  (variable substitution) means substituting B  at all the
occurrences of t. In both cases, we will explicitly handle variable renaming.

Definition 4.2 (closed form of a judgement): For any judgement J

t'1=t1<=A1,...,t'n=tn<=An z^ T <= U
the judgementz^

 O't'1...O't'n.T[t'i/ti] <= O't1<=A1.....O'tn<=An.U[ti/t'i]
is called the closed form of J.

The compared types O' t'1...O't'n.T[t'i/ti] and  O't1<=A1.....O'tn<=An.U[ti/t'i] will be
denoted respectively by O'G-.T and O'G.U (where G is t'1=t1<=A1,...,t'n=tn<=An). 

Fact 4.3: The closed form of a judgement  J is equivalent to J, from the point of view of

provability and of  divergence, since it r educes to  J in n ( O'cod') steps, where n is
the length of the environment.

The next definition extends the notion of occurrence from a type to a whole judgement,
by defining the occurrence of a type in a judgement J as its occurrence on one side of the
comparison of the closed form of J.

Definition 4.4 (occurrence w.r.t. a judgement ): Given a judgement  G  z^  T <= U  or  G z^

U >= T  (where G = (t' 1=t1)<=A1,...,(t'n=tn)<=An) and any occurrence of a subterm in
A1,...,An,U, its occurrence w.r.t. the judgement  is its occurrence in O' G.U, while
for any occurrence of a subterm in T  its occurrence w.r.t. the judgement  is its
occurrence in O' G-.T; in the first case we say that it occurs on the larger side of the
judgement, in the second case  that it occurs on the smaller side. The v a l i d
occurrences of a judgement are those occurrences m such that some subterm  occurs
in m w.r.t. the judgement.

Definition 4.5 (polarity ): The polarity of an occurrence of a type in a judgement is

inductively defined as follows; in the judgements:

(t'1=t1)<=A1,...,(t'n=tn)<=An z^ T <= U         (t'1=t1)<=A1,...,(t'n=tn)<=An z^ U >= T

the occurrences of  A 1... An  and T  are  negative, and the occurrence of  U is
positive. If the occurrence of a type  O't<=A.B has a given polarity (positive or
negative), the occurrence of  B has the same polarity, while the occurrence  of  A has
the opposite polarity.

We can now prove the first two propositions. Proposition 4.6 says that types  are not
created during a reduction  chain, but they are just "moved around". Proposition 4.7
specifies that, when they are moved around, their polarity is preserved.

Proposition 4.6: All the new bounds inserted into the environment and all the types which

are compared in a reduction chain starting from (t' 1=t1)<=A1,...,(t'n=tn)<=An z^  T <= U

11

are similar to subterms of  A1,..., An, T, U, where T  similar to U  means that  T and
U only differ in the names of their free and bound variables6.

Proof: The first property is preserved by each rule: the  (O') rules substitute the compared

types with two subterms and, in the ( O'cod) case, add a subterm of one of the
compared types to the environment; the (exp)  rule copies into the comparison a type
which is a-equal, hence similar, to a bound in the environment.  The thesis follows,
since being similar to a subterm is a transitive relation.    M

Proposition 4.7: For each reduction sequence {Ji }iI"I (where I  may be  {0..n} or  w),

each type in each Ji is similar to one type appearing in J0 with the same polarity.

Proof: This can be checked rule by rule. For example, the  (O'dom) rule  applied to a

comparison  O't<=A.B' <=  O't'<=A'.B copies the bound A ' , which is negative sinceO'

t'<=A'.B is positive, in the environment, and all the bounds in the environment are
negative by definition. The expansion rule substitutes a negative variable with a
bound from the environment, negative by definition.    M

Lemma 4.8: For each reduction sequence {Ji }iI"I (where I  may be  {0..n} or  w), such

that both a  (lhs-exp) and a  (rhs-exp) steps appear in the initial subsequence
{Ji}iI"{0..m}, all the new bounds inserted into the environment at any step, and all the
types which are compared in a judgement  Jl with l>=m, are  similar to subterms of a
negative bound which appears in J0 (i.e., this bound may either be an  Ai or a bound
which is a negative subterm of an Ai, of T or of U).

Proof: Any negative bound which is put in the environment by a  (O'cod) step is similar

to a negative bound in J0 by Proposition 4.7. The rest of the proposition follows from
the fact that after a  (lhs-exp)(A) step, and before the next  (lhs-exp) step, the left
hand side of the comparison is a subterm of  A, and A is similar to a bound in the
environment (likewise for the right hand side).    M

These propositions show that detecting rewriting divergence is only difficult because of
the unlimited growth of the environment, since the comparison always regards the same
(modulo similarity) pairs of types.

4.3  Variable creation in diverging judgements
The diverging sequence that  we have presented always goes back to expand the same
variable  v0, even though infinitely many different variables (ui  and v i  for  iI"w) are
created. In this section we prove that this is a feature of every diverging judgement.

Before proving this result, we have  to relate variables appearing in different
judgements in a precise way. 

Definition 4.9 (variable identification ): If Ji^i"i"A* J', and one variable in  J has the same

name as one variable in J' , we consider them as  being the same variable. If one
variable  t is in J '  but not  in J , we say that  t has been  created by the rewriting
step.

New variables can be created  by (exp)(T) steps only, and they are all and only the
variables defined inside the bound  T. For example, the step below creates  x on the left
6Formally: T similar_to U   ##   t1,...tn,u1,...un  exist such that  O't1...tn.T =a O'u1...un.U.

12

hand side:

(t=t')<=O'x.Top  z^ t   <=   A. i^i"i"A*(exp)(O'x.Top)
(t=t')<=O'x.Top  z^  O'x.Top  <=   A

Let us now examine the evolution of the bound of a variable along a reduction chain.
Definition 4.10: A variable  t is properly defined  w.r.t. a judgement  J if the bound of  t

is in a negative occurrence of  J; otherwise t is improperly defined . The bound of a
properly defined variable is its proper bound.

Remark 4.11: One variable t, along a reduction chain, evolves as follows:

* It is created inside the comparison with a given  creation bound; it maintains that

bound, with its polarity, up to the step where its definition  (O't) occupies
occurrence e on one side of the comparison.

* If the next ( O') step is ( O'dom), the variable simply disappears from the

judgement. If the next  (O') step is ( O'cod), the variable is unified with one
variable t' from the other side,  its definition is moved from  the comparison into
the environment, and:

i) If  t was improperly  defined, i.e. if  t was defined at occurrence  e on the

smaller side of the comparison, then, after the  (O'cod) step, t changes its
bound, acquiring the negative bound of t', and becomes properly defined. 

ii) If  t was already properly defined, i.e. if  t was defined at occurrence  e on

the larger side of the comparison, then t changes neither its bound nor the
polarity of its bound.

In both cases, in the next steps t, which is now defined in the environment,  will
remain properly defined, and its bound will no longer change.

Hence, in a fixed rewriting chain, every variable has exactly one creation bound and
at most one proper bound, which may either be its creation bound or may be acquired
after being unified to a properly defined variable.

By the previous remark, the following notion of  creation bound-depth  and proper
bound-depth is well defined, and every variable in a given chain has exactly one creation
bound-depth and has either one proper bound-depth or no proper bound-depth at all.

Definition 4.12: The depth  of a type  is the length of its longest valid occurrence. In a

rewriting chain of judgements, the creation bound-depth of a variable is the depth of
its  creation bound, while the proper bound-depth is the depth of its proper bound.

Proposition 4.13: In an infinite reduction there are an infinite number of (lhs-exp)  steps,

an infinite number of  (rhs-exp) steps, an infinite  number of  (lhs-O') steps (where a
(O') step is either a  (O'cod) or a ( O'dom)) and an infinite number of  (rhs-O') steps.
In an infinite reduction, infinitely many different variables are created on both sides.

Proof: There can be no  infinite sequence of consecutive ( O') steps since each of them

strictly decreases the dimension of  the types compared. A sequence of consecutive
(exp) steps always has the form:  Gz^t1<=A i^i"i"A* ...  i^i"i"A* G z^ tn<=A  i^i"i"A* Gz^B<=A with
tn<=B', t n-1<=tn,..., t1<=t 2 contained in the environment; when  the environment has
length n, at most  n consecutive  (exp) steps are possible. Hence any infinite chain  is

13

formed by an infinite interleaving of finite groups of (O') and (exp) steps.

Both an infinite number  of  (lhs-exp) and of (rhs-exp)  steps must be performed
in any infinite chain, since any ( O') step strictly reduces the size of both compared
types. An infinite number of ( O') steps  are performed on each side, since any
sequence of  (lhs-exp) steps is terminated by a  (lhs-O') step, and similarly on the
right hand side.

In any infinite reduction chain, the last expansion of any sequence of expansion
steps like the one exemplified above always copies  a bound B with shape  O't<=T.U,
since the next step is a  (O') step. Hence, an infinite number of variables  are created
on both sides of the comparison.    M

Lemma 4.14: A variable with creation bound-depth n is created by expanding a variable

whose proper bound-depth is at least n+1.

Proof: A variable t with a bound  B is created  by expanding a variable  u whose proper

bound A contains a subterm similar to  O't<=B; hence, if the depth of  B is n, then the
depth of A is at least n+1.    M

Lemma 4.15: In any infinite reduction, if  k variables have a creation bound satisfying a

property Q, then at most 2k variables have a proper bound satisfying Q.

Proof: Intuitively, any creation bound may become the proper bound  of at most two

variables. More formally, let: 

Cre = {t | A is the creation bound of t and Q(A)}
Pro = {t | A is the proper bound of t and Q(A)}
C&P = {t | tI"Cre and the creation bound of t is proper}
UniC&P = {t | t is unified by a (O'cod) step to one variable u in C&P}

By Remark 4.11, a variable  t is in Pro  iff either it has been created with a proper
bound satisfying  Q ( tI"C&P) or it has been unified with a variable in such a
situation (tI"UniC&P). Moreover, every variable in  C&P is unified to at most one
variable in  UniC&P, hence  #UniC&P <= #C&P  (where #S is the cardinality of  a set
S). To sum up:

#Pro  =  #C&P + #UniC&P  <=  #C&P + #C&P  <=  #Cre + #Cre  =  2k.

Proposition 4.16: In any infinite reduction there is one variable which is expanded an

infinite number of times.

Proof: By Proposition 4.13, in an infinite reduction sequence, an infinite number of

different variables are created. Let  n be the maximum  i such that an infinite number
of different variables  of creation bound-depth i are created. n exists, since by
Proposition 4.13 an infinite number of variables are actually created, and by
Proposition 4.6 there is an upper limit to the bound-depths of all these variables. By
the definition of n, there is only a finite number  k of different variables with
creation bound-depth greater  than n. By Lemma 4.15, at most 2 k variables may
have a proper bound-depth greater than n. Since an infinite number of variables with
creation bound-depth n are created, then, by Lemma 4.14, the 2k (or less) variables
with proper bound-depth greater than n are (collectively) expanded an infinite

14

number of times to create these infinitely many variables, which means that at  least
one of the 2k variables is expanded an infinite number of times.    M

Proposition 4.16 states that there is one variable which is expanded an infinite number of
times, and Proposition 4.13 states that an infinite number of variables are created, but up
to this point there is no reason to believe that this infinite number of different variables
are used (i.e. appear in their scope), that their definition is moved into the environment by
the  (O'cod) rule, and that they are expanded, as happens in our diverging judgement. In
Section 4.5 we will show that this is always the case.

4.4  The inversion depth of a diverging judgement
We have seen that, in every diverging judgement, there is one variable which reappears
(an infinite number of times) on one side of the comparison after it has been expanded on
that side. In this and in the next subsection we study how a variable may reappear. In this
section we show that a minimum "inversion depth" is needed for its bound; in the next
section we focus on a specific way of using the (O'cod) rule.

Definition 4.17 (inversion depth, odd/even occurrences): The  inversion depth  of an

occurrence n is the number of 0's in it; an occurrence is odd/even if its inversion
depth is odd/even. The inversion depth of a type is the maximum inversion depth of
all of its valid occurrences 7. The  inversion depth of a judgement  Gz^A<=B is the
maximum inversion depth of all the valid occurrences  of the judgement (Definition
4.4), i.e. the maximum between the inversion depths of O'G-.A and O'G.B.

Inversion refers to the fact that if we follow the path encoded by an occurrence  n along
a type, each 0 in n  corresponds to a polarity inversion.  The inversion depth of a
judgement is a measure of its complexity, and it never increases during reduction.

Proposition 4.18: Rewriting does not increase the inversion depth of a judgement.
Proof: Suppose that  n is the inversion depth of the judgement. The maximum  inversion

depth of a bound in the environment is then, at most, n-1 , hence an (exp)  step puts
into the comparison a type whose depth is at most  n-1. A  ( O'cod) rule applied to a
comparison of depth  n puts in the environment  a bound of maximum depth n-1 ,
which cannot make the inversion depth of the judgement bigger than  n. Finally
(O'dom) just decreases the inversion depth of the types compared.    M

The following lemma shows that a bound with inversion depth 2 is needed to change the
direction of the comparison twice.

Lemma 4.19: If a sequence of rewriting steps contains (lhs-exp)(A) , (rhs-exp)(B), and

(lhs-exp)(C) (in this order,  but possibly separated by other steps), and if  (lhsexp)(A) is the last (lhs-exp)  step before  (rhs-exp)(B), then the inversion depth of  A
is at least 2.

Proof: Let the path between two (exp)  steps be the occurrence representing the

movements made by the pointer along the compared types (Section 2.3); formally, let
it be the sequence which contains one 0 (resp. one  1) for each ( O'dom) (resp.
7This notion is similar to the rank of functional types.

15

(O'cod)) step performed after the first expansion and before the second one. Observe
that:

a) The path between a right hand side  (exp) and a left hand side  (exp), or vice

versa, is always odd (i.e. it contains an odd number of 0's).

b) If (lhs-exp)(T') is the first left expansion which  follows  (lhs-exp)(T), if m is the

path between  (lhs-exp)(T) and (lhs-exp)(T'), then  T/m is the variable substituted
by T', hence m is a valid occurrence of T.

Let (lhs-exp)(C') be the first left expansion which follows  (rhs-exp)(B). By (a), the
path  m between (lhs-exp)(A) and (lhs-exp)(C') has an inversion depth of at least 2,
since it is the concatenation of the two odd paths from  (lhs-exp)(A) to (rhs-exp)(B)
and from (rhs-exp)(B) to (lhs-exp)(C'); by (b) m is a valid occurrence of  A; hence
the inversion depth of A is at least 2.    M

Propositions 4.13, 4.18 and Lemma 4.19 together force a lower bound on  the inversion
depth of a diverging judgement.

Proposition 4.20: The inversion depth of a diverging judgement is at least 3.
Proof: By Proposition 4.13, any infinite chain starting from the diverging judgement

contains three expansion steps  satisfying the conditions of Lemma 4.19. When the
first step is executed, the type A of Lemma 4.19 is a renamed copy of a bound in the
environment; since the inversion depth of this bound is at least 2, the inversion depth
of the whole judgement is at least 3. By Proposition 4.18 (depth never increases), the
inversion depth of the original judgement is also at least 3.    M

Proposition 4.20 gives an elementary characterization  of a subset of the subtyping
judgements which is decidable and expressive: types with an inversion depth strictly
greater than two are, in practical use, rare8.

The reader can check that the inversion  depth of our diverging judgement is three;
hence our judgement is minimal with respect to that parameter.

4.5  Regaining references to expanded variables
The key feature of diverging judgements is the existence of a variable which, after being
expanded, appears back on the same side to be expanded once again, actually infinitely
many times again (Proposition 4.16). We show  here that this would not be possible
without the unification performed by the  (O'cod) rule, and that  this unification must be
exploited in quite a special way to reach this effect.

To this aim, we first define when a variable  is reachable from another one, from a
specific side of the comparison, or from the whole comparison. We show that this
definition captures the idea of reachability, i.e. that only if a variable is reachable from
the comparison, may it  be expanded in some future step. Then we show that, when a
variable z is expanded on one side of the comparison, then no references to that variable
remain on that side, which implies that a reference to z  must be reobtained in order to
expand  z once again . We finally show how  (O'cod) must be  exploited to regain that
8Types with a high inversion depth arise when F<=  is used to encode, for example, products or existential
types (see [Cardelli Longo 92] [Ghelli 90] [Cardelli Martini Mitchell Scedrov 91]). However, if productsand existentials are regarded as primitive type constructors, they do not add anything to the whole inversion

depth of a judgement.

16

reference. This result is used  to show, in the next section, the minimality of our
judgement.

We first define the reachability relation. 
Definition 4.21 (negative free): A variable  t is negative free in an occurrence of a type

T w.r.t.  J, if a negative (w.r.t. J) free  occurrence of  t is inside the occurrence of
type T.9  

When the occurrence of  T  is understood, we just say that  t is negative free i n T . For
example, we say that, in  t<=Top  z^  Top #t <= t#Top, t is negative free in both  Top#t
and t#Top.

Definition 4.22 (reachability): With respect to a fixed judgement J, the variable u is

immediately reachable  from a properly defined  t, written  t R J u, iff u is negative
free in the  proper  bound of  t. The strict reachability relation  RJ+ is the transitive
closure of immediate reachability  R ; t R J * u means  t=u or t R J+  u. If  t RJ* u w e
say that t is a reference to u.

We are only interested in negative variables and in proper bounds, since only negative
variables can be expanded, and can only be substituted by proper bounds.

We now extend the notion of reachability to the comparison of a judgement. If  G is
(t'1=t1)<=A1...(t'n=tn)<=An, let  def(G ) be the set of the variables defined in  G , i.e. the
set {t' 1,t1,...,t'n,tn}. For  JE^=E^GE^z^E^T1E^<=E^T2 and XE^I^E^def(G), ReachVarsX(J,Ti) contains
those variables in X which are reachable from side  Ti of the comparison, i.e. from some
negative free variable of  Ti, and ReachVarsX(J) contains those variables in  X which are
reachable from either T1 or T2.

Definition 4.23: Let J = G z^ T1 <= T2:

ReachVarsX(J,T1) =def {tI"X | O^n even, u free in T1, T1/n=u  s.t.  u RJ* t}
ReachVarsX(J,T2) =def {tI"X | O^n odd, u free in T2, T2/n=u  s.t.  u RJ* t}
ReachVarsX(J) =def ReachVarsX(J,T1) E^ ReachVarsX(J,T21) 

The name reachability given to the above relation is justified by the fact that no variable
which is unreachable from J may be expanded in some judgement deriving from J.

Theorem 4.24: Consider a judgement Gz^T<=U and a reduction chain  {Ji}iI"I starting from

it. The sequence ReachVarsdef(G)({Ji})iI"I is non-increasing.

Proof: Consider a (O'cod) step:

Ji=G,G' z^ O't<=A.B' <= O't'<=A'.B    i^i"i"A*    Ji+1=G,G', t=t'<=A' z^ B' <= B
We show that  uI"ReachVarsdef(G)(Ji+1) implies that uI"ReachVars def(G)(Ji). By
definition, there exists  w  negative free in  B' or in B  such that  w RJi +1* u. The
following cases arise:

a) w=t' (or  t) and w=u: this is impossible: u is different from  t (and uz't') since

uI"def(G) but t'(t)I`def(G).

9Formally, an occurrence  n is inside an occurrence m  when  n^m.m'. "Inside" refers  to the fact that the
path m.m' leads inside the type which is reached by the path m.

17

b) w=t' (or  t) and w RJi +1+ u: since  w=t' RJi+1+ u then there  exists t" free at an

even occurrence in  A' such that  t" R* u . Since  A' is a subterm of  O't'<=A'.B, and
A' is negative in Ji, uI"ReachVarsdef(G)(Ji); the same holds if w=t.

c) wz't',t and w RJi +1* u: since  wz't  and wz't', if w is negative free in either  B ' or

B then  w is negative free in  O't<=A.B' or in O' t'<=A'.B, i.e. it is negative free on
one side of the comparison of the judgement Ji, hence uI"ReachVarsdef(G)(Ji).

A similar but simpler proof can be performed for the (O'dom) case.
Consider now an expansion step:

(t'1=t1)<=A1...(t'n=tn)<=An z^ ti <= B i^i"i"A* G z^ FreshNames(Ai)<= B
The negative free variables of FreshNames (Ai) are the negative free variables of  A i,
which were already reachable through ti, while B is not affected by the step.    M

Corollary 4.25: If  tI`ReachVars{t}(J), then there exists no  J' deriving from J such that

an expansion step expanding t can be applied to J'.

Proof: An  expansion step expanding  t can be applied to  J'  only if one side of the

comparison of  J' consists  of a negative free  t; in this case  tI"ReachVars{t}(J'),
hence, if J rewrites to J', tI"ReachVars{t}(J).

The next fact to prove is that, when a variable  t is expanded, in the resulting judgement
no reference to  t remains on that side of the judgement, i.e. that the strict reachability
relation is acyclic. We will actually prove a stronger property, upward well-foundedness
of the reachability relation.

Lemma 4.26: The  RJ+ strict reachability  relation on variables is upward well-founded,

i.e. there is no infinite chain {ti }iI"w such that, for any iI"w , ti RJ+ ti+1. In particular,
for no t we may have t RJ+ t.

Proof:  If  t R J+  u then  t is defined in the scope of u, and this is  an acyclic relation.

Formally, if the definition  at occurrence p t (w.r.t.  J) of one variable  t is in the
scope of another variable  u defined at  occurrence p u, then  pt=pu.1.m for somem

. Hence, if  |p| is the length of an occurrence, then |p u|<|pt|. t R J u implies that
u is free in the bound of  t, hence that the definition of t is in the scope of  u, hence
that |p u|<|pt|. Since < is downward well-founded on integers, then RJ + is upward
well-founded on variables.    M

Corollary 4.27: In any infinite reduction chain  {Ji = G i  z^  Ai _ i Bi }iI"w (where _ i is

either <=E^or >=) a variable  t and an infinite set  II^w exist such that, for one side of
the comparison (say the left hand side), for all  i's in I , tI` ReachVars{t}(Ji,Ai) and
tI"ReachVars{t}(Ji+1,Ai+1).

Proof: By Proposition 4.16, in  an infinite reduction chain one variable exists, say t,

which is expanded infinitely many times, hence it is expanded infinitely many times
at least on one side of the comparison, say the left hand side. Let L ={l | J l reduces to
Jl+1 by expanding  t on the left  hand side} ; both  l and {l+1| l I"L} are infinite, and,
for all l's in L:

* tI"ReachVars{t}(Jl,Al), since, for lI"L, Al=t. 

18

* tI`ReachVars{t}(Jl+1,Al+1): for lI"L, Al+1 is a renamed version of the bound of t;

hence, Al+1 RJl+1* t would imply t RJl+1+ t, which is forbidden by Lemma 4.26.

For any pair of consecutive integers  l and l '  in L , tI` ReachVars{t}(Jl+1,Al+1) and
tI"ReachVars{t}(Jl',Al'); hence, for any  l, a kl  exists, with  l+1 <= kl  < l' , such that
tI`ReachVars{t}(Jkl,Akl) and t I"ReachVars{t}(Jkl+1,Akl+1). The set formed by all these
kl's is an infinite set which satisfies the theorem hypothesis.    M

We have formalized the intuition that in a diverging judgement there is a variable whose
reference is lost and then regained, infinitely many times, by one side of the comparison.
We can finally study the "fine structure" needed to regain that lost reference.

Proposition 4.28: If  Ji^i"i"A*J' and uI"ReachVars X(J',A')-ReachVarsX(J,A), where A  and

A' are the left hand sides of the comparisons of J and J', then:

a) J = G z^ O't<=T.U' <= O't'<=T'.U   (for some t,t',T,U)

J'  = G, t=t'<=T' z^ U' <= U
and J is transformed in J' by a (lhs-O'cod) step.

b) t is negative free in  U' and u is reachable in J from a free negative variable of

T'.

Proof: Consider a (O'cod) step:

J=G z^ O't<=T.U' <= O't'<=T'.U i^i"i"A*     J'=G, t=t'<=T' z^ U' <= U
Suppose that  uI"ReachVarsX(J',U')-ReachVarsX(J,O't<=T.U'). By definition, there
exists w negative free in U' such that w RJ'* u. The following cases arise:

a) wz't and w RJ' * u: this is impossible: since  wz't, if w  is negative free in  U'

then w is negative free in O't<=T.U', and then uI"ReachVarsX(J,O't<=T.U').

b) w=t and w=u: this is impossible, since uI"def(G) but tI`def(G).
c) w=t and w RJ' + u: this means that t(= w) is negative free in  U', and there is a

free negative variable z in T' (the bound of t in J') such that z RJ'* u, q.e.d..

We omit the simple proof of the  fact that the set  ReachVarsX(J,A), where A is the
left hand side of the comparison, cannot grow  in the  (O'dom), (exp) and (rhs-O'

cod) cases.    M

The proposition above states that the only way of gaining a reference to one variable  u
on one side of the comparison is to unify a variable (say  t) improperly (negatively)
defined on that side to a variable, properly defined on the other side,  t', whose bound T'
refers to  u. Furthermore, the variable t must appear in an even occurrence of its scope
U'. We can now complete Proposition 4.13.

Proposition 4.29: In any infinite reduction an infinite number of different variables must

be created, appear in their scope, have their definition moved into the environment by
a (O'cod) step, and be expanded.

Proof: With respect to a fixed rewriting chain  C={Ji}iI"w , we say that  t is usefullyreachable from u (w.r.t. to a judgement Ji ) iff u RJi * t  and, furthermore,  u  is
expanded in some step of  C. Reasoning as in Corollary 4.27, we prove that there
exist one variable  t and an infinite set  I such that  t is not usefully-reachable from

19

one side, say the left hand side, of any judgement in {Ji }iI"I but is usefully-reachable
from the  left hand side of the judgements in  {Ji+1}iI"I. Since useful reachability
implies reachability, by Proposition 4.28, for any  iI"I, there exists one different
variable  ti which appears in its scope  U'i and whose definition is moved into the
environment in the rewriting  step transforming Ji  in Ji + 1 . ti  is also expanded in
some step, by definition of useful reachability.    M

To summarize, we have shown that every diverging chain uses infinitely many different
variables to be able to expand one single variable infinitely many times (Propositions
4.16 and 4.29); Proposition 4.28 specifies the fine structure needed to exploit a new
variable to prepare a new expansion of an already expanded variable.

4.6  The minimality of our diverging judgement
We can finally show the minimality of our judgement. More precisely, we show that, for
any diverging judgement  J, each occurrence of a type operator ( O', t or "-")  in the
bound B=O' x.-O'y<=x.-x of the minimal diverging judgement corresponds to an
occurrence of the same type operator in a bound of  J, both occurrences playing the same
role w.r.t. divergence.

Theorem 4.30: Any diverging judgement contains two bounds with  the following

structure:

(1) A' =   E1[O't.E2[t]]
(2) B' =   O[O't'<=E3[t"].U]

Where the  Ei[] are even contexts, i.e. types with a hole  at an even occurrence, and
O[] is an odd context.

Proof: Consider a diverging chain  {Ji=Giz^Ai<=Bi}iI"w  starting from J. By Corollary

4.27, a variable  u and an infinite set  II^w exist such that, for one side of the
comparison (say the left hand side), O' i I" I  uI`ReachVars{t}(Ji,Ai) and
uI"ReachVars{t}(Ji+1,Ai+1). Let us choose a jI"I  such that both a  (rhs-exp) and a
(lhs-exp) come  before the step  Jji^i"i"A*Jj+1 ( this is always possible by Proposition
4.13). In this way, by Lemma 4.8, we are sure that  Aj and B j  are similar to two
subterms of two negative bounds  A' and B' appearing in  J. By Proposition 4.28, Aj
and Bj are two types O't<=T.U' and O't'<=T'.U such that:

(1) O't<=T.U' occurs negatively in  Jj. Hence, it is similar  to a subterm which occurs

in an even occurrence of the bound  A'. Moreover, t appears negatively in  U',
hence A' can be written as E1[O't.E2[t]], where the Ei[] are even contexts.

(2) O't'<=T'.U occurs positively in  Jj. Hence, it is similar to a subterm which occurs

in an odd occurrence of the  bound B' . Moreover, some variable t" appears free
at a  negative occurrence of T', hence  B' can be written as  O[O't'<=E3[t"].U],
where O[] is an odd context and E3[] is an even context.    M

We can now show that, for any diverging judgement J, each occurrence of a  type
operator in the bound  B=O'x.-O'y<=x.-x corresponds to an occurrence of the  same
operator in some bound  of  J (where "-" may be substituted by any operator which
inverts polarity). Here "corresponds" means that the two operators play the same role in

20

the (O'cod) step which is applied infinitely many times, according to Proposition 4.28, in
order to have the variable t of Corollary 4.27 reappear infinitely many times in the set of
variables which are reachable from one side of the comparison.

Consider the graphical representation of B in Figure 3.

11.0
1.0.11.0.1.01.0.0O'yx x
-

O'x e

Figure 3.  The subterms occurring in the bound B.
The quantifier O' x occurring at  e is used to introduce an improperly defined variable
and the occurrence of the variable  x at 1.0.1.0 is the one which  will be expanded later
on; hence they correspond to the O' t and t which must occur in even contexts in the
bound A' according to Theorem 4.30. In the same way, occurrences 1.0 (O' y) and 1.0.0
(x) correspond to the O' t' and t" required by condition (2) of Theorem 4.30. The "-"
appearing at occurrence 1 constitutes the odd context  O[] required by condition (2) and,
finally, the "-" at occurrence 1.0.1 completes the even context surrounding the variablex

 at 1.0.1.0 as required by condition (1). Hence, any diverging judgement J contains
the whole structure of the bound  B, possibly split in two bounds . One may now also
show, by Proposition 4.28, that not only is bound B minimal, but also the right hand side
of the comparison in the judgement v<=B z^ v <= O'u<=v.v is the minimal one needed to start
a diverging chain.

5 Divergence and undecidability of Fbq
The type Top  was initially defined in Fun to deal with both bounded and unbounded
quantification with a single  O' construct, by representing an unbounded quantificationO'

t.T as  O't<=Top.T. Alternatively, following [Bruce Longo 90],  we may define two
different O'  quantifiers, bounded and  unbounded, thus avoiding the type  Top. The
resulting type system has been called F b q  by Luca Cardelli (F + Bounded
Quantification), and has three different  (O') subtyping rules, one to compare two
bounded quantifications, one to compare two unbounded quantifications, and one to
perform the mixed comparison (unbounded <= bounded). The rules are just three different
instances of the  F<= rules; for example, the mixed comparison  rule is as follows (the
algorithmic subtyping rules of Fbq are in Appendix C):

(u-bO'<=) G, t'<=A z^ B'[t'/t] <= B

-----------------G z^ O't.B' <= O't'<=A.B

Fbq can be seen as a sublanguage of  F<=, since the unbounded quantification of Fbq
can be read as  Top-bounded quantification in F<=; F<= is conservative over  Fbq, in the
sense that any provable F<= judgement which can be written inside  Fbq can also be
proved inside Fbq [Ghelli 90]. The standard type-checking algorithm for  Fbq can easily
be defined by dropping the Top rules from our reduction system, by introducing into the
environment syntax the  t=t' type statement to substitute t=t'<=Top , and by adding  two

21

reduction rules for the unbounded-unbounded and unbounded-bounded comparisons:

(Fbq-u<=b) G z^ O't.B' <= O't'<=A'.B i^i"i"A* G, t=t'<=A'  z^ B' <= B
(Fbq-u<=u) G z^ O't.B' <= O't'.B i^i"i"A* G, t=t' type  z^ B' <= B

It is then easy to see that the diverging judgement in Section 3 also  diverges in this
reduction system.

We can generalize this fact by proving that type checking  Fbq is as difficult as type
checking F<=; more precisely, each problem may be transformed into the other one in
linear time.  In one direction, since  F<= is a consistent extension of  Fbq, then any  F<=
type checker can be used to type check any Fbq judgement. We now illustrate the other
transformation, which reduces the subtype checking problem of  F<= to subtype checking
for Fbq.

To this aim we define a deep-double-negation  mapping  C,_E' which transforms  F<=
judgements into  Fbq judgements and preserves provability. We first define negation of
T, written  -T, as  O't<=T.t; note that this is different from the previous definitionO'

t<=T.Top.

Definition 5.1: The mapping - (surface negation10) of  F<= and Fbq types on, respectively, F<= and Fbq types is defined as:

Az'Top  " -A  = O't<=A.t

-Top = O't.t

where t is a fresh variable. 

The mapping  C,_E' (deep double negation ) of  F<= types and judgements on  Fbq types
and judgements negates each occurrence in the judgement twice, the only exception being
bounds. 

Definition 5.2: The mapping A"_A* ( internal double negation ) from F<= minus {Top} on

Fbq is defined as:A"

tA*: A"tA*  = tA"O'A*

: A,Bz'Top: A"O't<=A.BA*  = O't<=A"AA*.--A"BA*

Az'Top: A"O't<=A.TopA*  = O't<=A"AA*.--Top
Bz'Top:  A"O't<=Top.BA*  = O't.--A"BA*

  A"O't<=Top.TopA* = O't.--Top

The mapping C,_E' from F<= to Fbq is defined as:

Az'Top: C,AE'   =  --A"AA* C,

TopE'  =  --Top

These mappings are extended to judgements in the natural way:

* A"GA*: t=t'<=Top becomes t=t' type, while t=t'<=A (Az'Top) becomes t=t'<=A"AA*

* C,Gz^A<=BE' = A"GA* z^ C,AE' <= C,BE' (note that G is internally double negated)

* A"Gz^A<=BA* = A"GA* z^ A"AA* <= A"BA* (well defined only if Az'Top and Bz'Top)

We want to prove that any  F<= subtyping judgement  J is provable if and only if C,JE' is
provable in Fbq. We first need some lemmas.
10No (conscious) logical intuition is hidden behind the name negation.

22

Lemma 5.3: G z^ -A <= -B reduces to G z^ A >= B and to true.
Lemma 5.4: If  Az'B and A and B are  different from Top , then  G z^ C,A E' <=  C,BE' reduces

to G z^ A"AA* <= A"BA* and to true.

Lemma 5.5: G z^ C,AE' <= C,TopE' is provable.
Proof: If Az'Top, G z^ C,AE' <= C,TopE' is equal toG z^

 ---A"AA* <= --Top
which reduces as follows (we ignore some trivial successful branches):G z^

 ---A"AA* <= --Top i^i"i"A*G z^
 --A"AA* >= -Top =G z^
 O'u<=A"AA*.u >= O'u'.u' i^i"i"A*G
, u=u'<=A"AA* z^ u >= u' i^i"i"A*
true.    M

Lemma 5.6: G z^ C,TopE' <= C,AE' is not provable if Az'Top.
Proof: If Az'Top, then G z^ C,TopE' <= C,AE' is equal toG z^

 --Top <= --A"AA*
which reduces as follows (we ignore some trivial successful branches):G z^

 -Top >= -A"AA* =G z^
 O'u'.u' >= O'u<=A"AA*.u i^i"i"A*
false.    M

Theorem 5.7: For any judgement J, J is provable in F<= if and only if C,JE' is provable in

Fbq.

Proof: We prove that  z^<= J (i.e.  J is provable in F<=) if and only if z^bq  C,JE' (i.e.  C,JE' is

provable in Fbq), together with the same property for the mapping A"JA*. We  prove
that  z^<= JE^"E^E^z^bq  C,JE'  by induction on the length of the longest reduction chain
starting from J (this maximum exists since  z^ <=  J), and prove  z^ <=  JE^*E^E^z^bq  C,JE' by
induction on the length of the longest reduction chain starting from C,JE'. We work by
case analysis on the shape of the types compared in  J; we only report the interesting
cases t<=A and O' t<=A.B' <= O' t<=A'.B. For each of these cases we simply show that  J
reduces to a set of non trivially provable judgements  J1,...,Jn iff C,JE' reduces to a set
of non trivially provable judgements J' 1,...,J'n   such that  J'i is either A"Ji A* , or  C,JiE'.
Then z^<= J ## z^<= J1,...,Jn ##by induction z^bq J'1,...,J'n ## z^bq C,JE'.

We present the reduction chains  for some interesting cases with no further
comment.

J = G, t=t'<=A, G' z^ t<=C  with  -oC~t, Cz'Top, Az'Top.

J  =   G, t=t'<=A, G' z^ t<=C i^i"i"A*(exp)    G z^ A<=CC,

JE'  = A"GA*, t=t'<=A"AA*, A"G'A*  z^  --t  <=    --A"CA* i^i"i"A**(O'dom')A"GA*

, t=t'<=A"AA*, A"G'A*  z^  t  <=    A"CA* i^i"i"A*(exp)A"GA*
, t=t'<=A"AA*, A"G'A*  z^  A"AA* <=    A"CA*

23

J = G, t=t'<=A, G'  z^  t<=C   with  -o C ~ t, Cz'Top, A=Top: in this case we have to

prove that neither J nor C,JE' are provable (proof omitted).

J = G z^ O't<=A.B' <= O't'<=A'.B  with Az'Top and A'z'Top

J  =  G z^ O't<=A.B' <= O't'<=A'.B i^i"i"A*

(O'dom) G z^ A >= A'      and  (O'cod) G, t=t'<=A' z^ B'<=BC,

JE'  = A"GA*  z^  C,O't<=A.B' E' <=  C,O't'<=A'.BE' =A"GA*  z^

  --O't<=A"AA*.C,B'E' <=  --O't'<=A"A'A*.C,BE' i^i"i"A**(O'dom')A"GA*  z^
  O't<=A"AA*.C,B'E' <=  O't'<=A"A'A*.C,BE' i^i"i"A*
(O'dom)  A"GA* z^ A"AA* >= A"A'A* and  (O'dom)  A"GA*, t=t'<=A"A'A* z^ C,B'E' <= C,BE'

J = G  z^  O't<=Top.B' <= O't'<=A'.B  with A'z'Top

J  =  G z^ O't<=Top.B' <= O't'<=A'.B i^i"i"A*(O' cod)G

, t=t'<=A' z^ B'<=BC,

JE'  =  A"GA*  z^  C,O't<= Top.B' E' <=  C,O't'<=A'.BE' =A"GA*  z^

  --O't.C,B'E' <=  --O't'<=A"A'A*.C,BE' i^i"i"A** (O'dom')A"GA*  z^
  O't.C,B'E' <=  O't'<=A"A'A*.C,BE' i^i"i"A*(O'cod')A"GA*
, t=t'<=A"A'A* z^ C,B'E' <= C,BE'.    M

Theorem 5.7 completes the proof that subtype checking of F<= can be reduced to subtype
checking of F bq and vice-versa. A proof of this fact based on a more complex
translation, also translating  F<= terms to  Fbq terms, was previously suggested by Luca
Cardelli (personal communication). Note that  F<= and Fbq subtype checking are also
equivalent from the point of view of complexity, since the mapping C,JE' can be executed
in linear time and increases the size of J only by a constant factor. 

It may be interesting to know that, in [Katiyar Sankar 92],  Fbq was proved  to
become decidable as soon as the mixed bound comparison (Fbq-u<=b) is forbidden.

6 Conclusions
We have shown that the standard type-checking algorithm of system  F <=  is only a
semidecision procedure, by presenting a subtype judgement which makes it diverge. The
divergence result was very surprising for the author, who shared the common belief that
the standard algorithm was a decision procedure. Whilst the paper was being written, the
author communicated this judgement to Benjamin Pierce, who used it to encode tworegister Turing machines as  F<= subtyping judgements, proving that the problem is
undecidable, in sharp contrast with the common belief that type-checking F<= is "easy"
[Pierce 93].

We have given a set of results about the nature of judgements which make the algorithm
diverge. These results can be used to prove decidability or undecidability for variations of
F<=, to design decidable versions of the system, and to characterize interesting decidable
subsystems of  F<=. These results have been used to support the claim that undecidability
of F<= may not be a problem of practical concern,  since divergence of type checking is
limited to judgements with a very peculiar and unnatural structure [Curien Ghelli 93,

24

Ghelli Pierce 92]. Similarly, they have been used to  support the claim that the nonconservativity of recursive types w.r.t. F<= subtyping is not a practical problem, since this
non-conservativity is limited to diverging judgements [Ghelli 93a].

Acknowledgments
I gratefully thank Luca Cardelli for many insights into the problem of decidability of type
checking for the language F<=. The work on type-checking algorithms for the Galileo and
Fibonacci object-oriented database programming languages, in the project led at Pisa
University by Antonio Albano, provided the motivations for this study. Special thanks to
Pierre-Louis Curien who provided a great deal of help and suggestions during many
phases of this work, and to the anonymous referee who provided many useful and
constructive comments.

References
[Bruce 91] K. B. Bruce, "The equivalence of two semantic definitions for inheritance inobject-oriented languages", in Mathematical Foundations of Programming Semantics ,

Pittsburgh, PA, 1991.
[Bruce 92] K. B. Bruce, " A paradigmatic object-oriented language: Design, statictyping and semantics", Technical Report CS-92-01, Williams College, 1992.

[Bruce 93] K. B. Bruce, "Safe type checking in a statically typed object-orientedprogramming language", in POPL '93, 1993.
[Bruce Longo 90] K. B. Bruce and G. Longo, "A Modest Model of Records, Inheritanceand Bounded Quantification", Information & Computation, 87(1/2), 196-240, 1990.
[Canning et al  89] P. Canning, W. Cook, W. Hill, J.C. Mitchell, and W. Olthoff, "F-bounded quantification for object-oriented programming", in  Functional Programming
and Computer Architecture, 273-280, 1989.
[Canning Hill Olthoff 88] P. Canning, W. Hill, and W. Olthoff, "A kernel language  forobject oriented programming", Technical Report STL-88-21, HP Labs, 1988.

[Cardelli Longo 92] L. Cardelli and G. Longo, "A semantic basis for Quest", Journal ofFunctional Programming, 1 (4), 417-458, 1992.
[Cardelli Martini Mitchell Scedrov 91] L. Cardelli,  S. Martini, J.C. Mitchell, and A.Scedrov, "An extension of system F with subtyping", Intl. Conference on Theoretical
Aspects of Computer Software , Sendai, Japan, LNCS  526, 1991. To appear inInformation & Computation.

[Cardelli Mitchell 91] L.  Cardelli and J.C. Mitchell, "Operations on Records",Mathematical Structures in Computer Science, 1 (1), 3-48, 1991.
[Cardelli Wegner 85] L. Cardelli and P.  Wegner, "On understanding types, dataabstraction and polymorphism", ACM Computing Surveys, 17 (4), 1985.
[Castagna Pierce 94] G. Castagna and B.  Pierce, "D ecidable Bounded Quantification" ,in POPL '94, 1994.
[Cook 89] W. Cook, " A Denotational Semantics of Inheritance ", PhD Thesis,  BrownUniversity, 1989.
[Curien Ghelli 92] P.-L. Curien and G. Ghelli, "Coherence of Subsumption in F <=,Minimum Typing and Type Checking",  Mathematical Structures in Computer Science,
2(1), 1992.

25

[Curien Ghelli 93] P.-L. Curien and G. Ghelli, "Confluence and decidability of  bhtop<=reduction in F

<=", Information & Computation, to appear.
[Danforth Tomlinson 88] S. Danforth and C. Tomlinson, "Type Theories and Object-Oriented Programming", ACM Computing Surveys, 20 (1), 29-72, 1988.

[DeBruijn 72] N.G. De Bruijn, "Lambda Calculus Notation Without Nameless Dummies,a Tool for Automatic Formula Manipulation", Indag. Math., 34, 381-392, 1972.
[Ghelli 90] G. Ghelli, " Proof Theoretic Studies  about a Minimal Type SystemIntegrating Inclusion  and Parametric Polymorphism", PhD Thesis, TD-6/90,
Dipartimento di Informatica dell'Universita` di Pisa, Italy, 1990.
[Ghelli 91] G. Ghelli, "Modelling features of object-oriented languages in  second orderfunctional languages with subtypes", in  Foundations of  Object-Oriented Languages,

J.W. de Bakker, W.P. de Roever, G.Rozenberg (Eds.), LNCS 489, 311-340, 1991.
[Ghelli 93a] G. Ghelli, "Recursive types are not conservative over F <=", Intl. Conf. onTyped Lambda Calculus and Applications (TLCA), Utrecht, The Netherlands, 1993.

[Ghelli 93b] G. Ghelli, " Divergence of F <= type checking ", Technical Report 5/93,University of Pisa, Dipartimento di Informatica, March 1993.
[Ghelli Pierce 92] G. Ghelli and B. Pierce, "Bounded Existentials and Minimal Typing ",manuscript, June 1992, available from the authors.
[Girard 72] J.Y. Girard, "Interpre'tation fonctionnelle et e'limination des coupures dansl'arithme'tique d'ordre supe'rieur", The`se de Doctorat d'Etat, Paris, 1972.
[Gunter Mitchell 93] C. Gunter and  J.C. Mitchell, "Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language  Design ", The MIT Press,
1993, to appear.
[Hofmann Pierce 94] M. Hofmann and B. Pierce, " A unifying type-theoretic frameworkfor objects", in Symposium on Theoretical Aspects of Computer Science, 1994.

[Katiyar Sankar 92] D. Katiyar and S. Sankar, "Completely Bounded Quantification isDecidable", in ACM SIGPLAN Workshop on ML and its Applications, June, 1992.
[Mitchell 90] J.C. Mitchell, "Towards a typed foundation for method specialization andinheritance", in POPL '90, 1990.
[Mitchell et al 91] J.C. Mitchell, S. Meldal, and N. Madhav, "An extension of standardML modules with subtyping and inheritance", in  POPL '91, 1991.
[Pierce 93] B. Pierce, "Bounded Quantification  is Undecidable",  Information &Computation, to appear. Also in [Gunter Mitchell 93].
[Pierce Turner 93] B. Pierce and D.N. Turner, "Object-Oriented Programming WithoutRecursive Types", in POPL '93, 1993.
[Reynolds 74] J.C. Reynolds, "Towards a theory of type structure", in  Paris Colloquiumin Programming, LNCS 19, 408-425, 1974.

26

Appendix A: The System F<=.
Syntax: A ::= t  |  Top  |  A#A  |  O't<=A. A 

a  ::= x  |  top  |  lx:A. a |  a(a)  |  Lt<=A. a  |  a{A}

Environments (sequences whose individual components have the form x:A or t<=A):
(U`env) () env
(<=env) G  env   G z^ A  type tI`G11 (: env) G  env    G z^ A  type   xI`G

----------------------- -----------------------G,  t<=A     env G, x:A     env

  

Types:
(VarForm) G, t<=A, G'   env       (TopForm) G  env  

----------------- ------------G, t<=A, G' z^ t    type G z^ Top   type

(#Form) G z^ A  type G z^ B  type        (O'Form) G, t<=A z^ B  type     tI`G

---------------------- ---------------------G z^ A#B    type G z^ O't<=A. B    type

Subtypes:
(Var<=) G, t<=A, G'  env   (Top<=) G z^ A type   

-------------- ----------G, t<=A, G' z^ t<=A G z^ A<=Top

(#<=) G z^ A<=A' G z^ B<=B'          (O'<=) G z^ A<=A' G, t'<=A z^ B[t'/t]<=B'  tI`G

----------------- -----------------------------G z^ A'#B <= A#B' G z^ O't<=A'.B <= O't'<=A.B'

(Id<=) G z^ t type         (Trans<=) G z^ A<=B G z^ B<=C

--------- -----------------G z^ t<=t G z^ A<=C

Expressions:
(Var) G, x:A, G'  env (Top) G  env

------------- -----------G, x:A, G' z^ x: A G z^ top: Top    

(# Intro) G, x:A z^ b: B xI`G (# Elim) G z^ f: A#B   G z^ a: A

------------------- ---------------------G z^ lx:A.b: A#B G z^ f(a): B

(O' Intro) G, t<=A z^ b[t/t']: B tI`G (O' Elim) G z^ f: O't <= A. B G z^ A' <= A

---------------------- -------------------------G z^ Lt'<=A.b: O't<=A.B G z^ f{A'}: B[tY"A']

(Subsump) G z^ a: A  G z^ A <= B

----------------------G z^ a: B

11 tI`G means that t is not bounded by any element t<=A of G; similarly for xI`G.

27

Appendix B: The algorithmic rules and the rewriting rules
Environments as functions from variables to typesG

(t) (the bound of t in G): (G, t<=A, G')(t) =def AG
*(T) (the minimum non variable supertype of T in G):

i` T if T is not a type variableG*(T)=
def i'i^ G*(U) if T=t and  G(t)=U

Expressions:
(AlgVar) G, x:A, G'  env (AlgTop) G  env

-------------- -----------G, x:A, G' z^ x: A G z^ top: Top    

(AlgAbs) G, x: A z^ b: B    xI`G (AlgAbs2) G, t <= A z^ b: B     tI`G

------------------- ------------------G z^ lx:A.b: A#B G z^ Lt<=A.b: O't<=A.B

(AlgApp) G z^ f: T  G*(T) = A#B G z^ a: A' G z^ A'<=A

-------------------------------------------G z^ f(a): B

(AlgApp2) G z^ f: T  G*(T) = O't<=A.B G z^ A' <= A

--------------------------------------G z^ f{A'}: B[tY"A']

Subtypes:
(AlgId<=) G z^ t  type   (AlgTop<=) Az'Top G z^ A type 

--------- ----------------------G z^ t<=t G z^ A<=Top

(AlgTrans<=) Az't, Az'Top G z^ G(t)<=A    

----------------------G z^ t<=A

(Alg#<=) G z^ A'<=A G z^ B'<=B          (AlgO'<=) G z^ A'<=A G, t'<=A' z^ B'[t'/t]<=B    tI`G

------------------ ------------------------------G z^ A#B' <= A'#B G z^ O't<=A.B' <= O't'<=A'.B

Rewriting rules for the <= case (for the >= case, exchange <= with >= and vice versa):

(top) G z^ A'<=Top i^i"i"A* true(varId) Gz^t~u " G z^ u <= t i^i"i"A* true

(exp) G-oC~u, Cz'Top " G z^ u <= C i^i"i"A* G z^ FreshNames(G(u)) <= C(O'dom) G z^ O't<=A.B' <= O't'<=A'.B i^i"i"A* G z^ A >= A'
(O'cod) G z^ O't<=A.B' <= O't'<=A'.B i^i"i"A* G, (t=t')<=A' z^ B' <= B(false) nothing else applies  " G z^ A <= B i^i"i"A* false

The ~ relation is the minimal relation such that:   G,(t=u)<=A,G' z^ t~u,u~t,t~t,u~u.
Appendix C: Algorithmic subtype rules for Fbq
(Id<=), (Trans<=), (#<=) plus:
(b-bO'<=) G z^ A'<=A G, t'<=A' z^ B'[t'/t]<=B   tI`G (u-uO'<=) G, t' type z^ B'[t'/t]<=B   tI`G

------------------------------- -----------------------G z^ O't<=A.B' <= O't'<=A'.B G z^ O't.B' <= O't'.B

(u-bO'<=) G, t'<=A z^ B'[t'/t] <= B     tI`G

-----------------------G z^ O't.B' <= O't'<=A.B

Rewriting rules: as above, minus (top), plus:

(Fbq-u<=b) G z^ O't.B' <= O't'<=A'.B i^i"i"A* G, t=t'<=A'  z^ B' <= B
(Fbq-u<=u) G z^ O't.B' <= O't'.B i^i"i"A* G, t=t' type  z^ B' <= B

28