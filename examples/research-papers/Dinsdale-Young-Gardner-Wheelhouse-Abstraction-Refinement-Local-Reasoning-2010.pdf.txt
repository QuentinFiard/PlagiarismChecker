

Abstraction and Refinement for Local Reasoning

Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

Imperial College London{
td202, pg, mjw03}@ic.ac.uk

Abstract. Local reasoning has become a well-established technique in
program verification, which has been shown to be useful at many different
levels of abstraction. In separation logic, we use a low-level abstraction
that is close to how the machine sees the program state. In context
logic, we work with high-level abstractions that are close to how the
clients of modules see the program state. We apply program refinement to
local reasoning, demonstrating that high-level local reasoning is sound for
module implementations. We consider two approaches: one that preserves
the high-level locality at the low level; and one that breaks the high-level
`fiction' of locality.

1 Introduction
Traditional Hoare logic is an important tool for proving the correctness of pro-grams. However, with heap programs, it is not possible to use this reasoning in
a modular way. This is because it is necessary to account for the possibility ofmultiple references to the same data. For example, a proof that a program reverses a list cannot be used to establish that a second, disjoint list is unchanged;disjointness conditions must be explicitly added at every step in the proof.

Building on Hoare logic, O'Hearn, Reynolds and Yang addressed this problemby introducing separation logic [12] for reasoning locally about heap programs.
The fundamental principle of local reasoning is that, if we know how a local com-putation behaves on some state, then we can infer the behaviour when the state
is extended: it simply leaves the additional state unchanged. Separation logicachieves local reasoning by treating state as resource. A program is specified in
terms of its footprint - the resource necessary for it to operate - and a frame ruleis used to infer that any additional resource is indeed unchanged. For example,
given a proof that a program reverses a list, the frame rule can directly establishthat the program leaves a second, disjoint list alone. Consequently, separation
logic enables modular reasoning about heap programs.

Abstraction and refinement are also essential for modular reasoning. Abstrac-tion takes a concrete program and produces an abstract specification; refinement

takes an abstract specification and produces a correct implementation. Both ap-proaches result in a program that correctly implements an abstract specification.
Such a result essential for modularity because it means that a program can bereplaced by any other program that meets the same specification. Abstraction

2 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

H
L

H + HH + LT
Fig. 1. Module Translations

and refinement are well-established techniques in program verification, but haveso far not been fully understood in the context of local reasoning.

Parkinson and Bierman have used abstract predicates to provide abstractionfor separation logic [13]. An abstract predicate is, to the client, an opaque object
that encapsulates the unknown representation of an abstract datatype. Theyinherit some of the benefits of locality from separation logic: an operation on one
abstract predicate leaves others alone. However, the client cannot take advantageof local behaviour that is provided by the abstraction itself.

Consider a set module. The operation of removing, say, the value 3 from theset is local at the abstract level; it is independent of whether any other value is
in the set. Yet, consider an implementation of the set as a sorted, singly-linkedlist in the heap, starting from address

h. The operation of removing 3 from theset must traverse the list from
h. The footprint therefore comprises the entirelist segment from
h up to the node with value 3. With abstract predicates, theabstract footprint corresponds to the concrete footprint and hence, in this case,

includes all the elements of the set less than or equal to 3. Consequently, abstractpredicates cannot be used to present a local abstract specification for removing 3.

Calcagno, Gardner and Zarfaty introduced context logic [2], a generalisationof separation logic, to provide such abstract local reasoning about structured
data. Context logic has been used to reason about programs that manipulatee.g. sequences, multisets and trees [3]. In particular, it has been successfully applied to reason about the W3C DOM tree update library [8]. Thus far, contextlogic reasoning has always been justified with respect to an operational semantics
defined at the same level of abstraction as the reasoning. In this paper, we com-bine abstract local reasoning about structured data with data refinement [10, 5]
in order to refine such abstract local specifications into correct implementations.Mijajlovi'c, Torp-Smith and O'Hearn previously combined data refinement
with local operational reasoning [11] to demonstrate that module implementa-tions are equivalent for well-behaved clients, specifically dealing with aliasing
issues in the refinement setting. By contrast, we relate axiomatic abstract localreasoning about a module with axiomatic reasoning about its implementations.

The motivating example of this paper is the stepwise refinement of a treemodule T. The refinement is illustrated in Fig. 1. We show how the tree module
T may be correctly implemented using the familiar separation-logic heap moduleH and an abstract list module L. We then show how this list module L can be
correctly implemented in terms of the heap module H. Our approach is modular,so this refinement can be extended with a second instance of the heap module H
(illustrated with a dotted arrow). Finally, we show that the double-heap moduleH + H can be trivially implemented by the heap module H, completing the
refinement from the tree module T to the heap module H. As a contrast, we also

Abstraction and Refinement for Local Reasoning 3
briefly consider a direct refinement of the tree module T using the heap moduleH, although the details of this example are given in the full paper [7].

Our development provides two general techniques for verifying module imple-mentations with respect to their local specifications, using locality-preserving and
locality-breaking translations. Locality-preserving translations, broadly speaking,relate locality at the abstract level with locality of the implementation. However,
implementations typically operate on a larger state than the abstract footprint,for instance, by performing pointer surgery on the surrounding state. We introduce the notion of crust to capture this additional state. This crust intrudes onthe context, and so breaks the disjointness that exists at the abstract level. We
therefore relate abstract locality with implementation-level locality through afiction of disjointness.

With locality-breaking translations, locality at the abstract level does notcorrespond to locality of the implementation. Even in this case, we can think
about a locality-preserving translation using possibly the whole data structure asthe crust. Instead, we prove soundness by establishing that the specifications of
the module commands are preserved under translation in any abstract context,showing the soundness of the abstract frame rule. We thus establish a fiction of
locality at the abstract level.The full proofs of our results may be found in the full version of this paper [7].

2 Preliminaries
We begin by introducing two key concepts: the definition of a context algebra tomodel program state, and an axiomatic semantics, based on context algebras,
to describe the behaviour of an imperative programming language.

2.1 State Models
We work with multiple data structures at multiple levels of abstraction. Tohandle these structures in a uniform way, we model our program states using

context algebras. Context algebras are a generalisation of separation algebras [4]to more complex data structures. Whereas separation algebras are based on
a commutative combination of resource, context algebras are based on non-commutative resource, which is necessary to handle structured data. We will see
that many interesting state models fit the pattern of a context algebra.
Definition 1 (Context Algebra). A context algebra A = (C, D, *, ffi, I, 0)comprises:

- a non-empty set of state contexts, C;- a non-empty set of abstract states, D;
- a partially-defined associative context composition function, * : C * C * C;- a partially-defined context application function, ffi : C * D

* D,with
c1 ffi (c2 ffi d) = (c1 * c2) ffi d (undefined terms are considered equal);- a distinguished set of identity contexts, I ` C; and

4 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

- a distinguished set of empty states, 0 ` D;
having the following properties: for all c 2 C, d 2 D, and i0 2 I

- i ffi d is defined for some i 2 I, and whenever i0 ffi d is defined, i0 ffi d = d;- the relation {(

c, d) | 9o 2 0. c ffi o = d} is a total surjective function;-
i * c is defined for some i 2 I, and whenever i0 * c is defined, i0 * c = c;-
c * i is defined for some i 2 I, and whenever c * i0 is defined, c * i0 = c.

Example 1. The following are examples of context algebras:
(a) Heaps h 2 H are defined as:

h ::= emp | n 7! v | h * h
where n 2 N+ ranges over unique heap addresses, v 2 Val ranges overvalues, and * is associative and commutative with identity emp. (Heaps are

thus finite partial functions from addresses to values.) Heaps form the heapcontext algebra, H = (

H, H, *, *, {emp}, {emp}). All separation algebras [4]can be viewed as context algebras in this way.

(b) Variable stores oe 2 \Sigma  are defined as:

oe ::= emp | x *+ v | oe * oe
where x 2 Var ranges over unique program variables, v 2 Val ranges over val-ues, and * is associative and commutative with identity emp. Variable stores

form the variable store context algebra, V = (\Sigma , \Sigma , *, *, {emp}, {emp}).(c) Trees

t 2 T and tree contexts c 2 C are defined as:

t ::= ? | n[t] | t ffl t
c ::= - | n[c] | t ffl c | c ffl t

where n 2 N+ ranges over unique node identifiers, and ffl is associative withidentity ?. Context composition and application are standard (substituting

a tree or context in the hole), and obviously non-commutative. Trees andtree contexts form the tree context algebra, T = (

C, T, *, ffi, {-}, {?}).(d) Given context algebras, A

1 and A2, their product A1 * A2 (defined as onewould expect) is also a context algebra. For example, H * V and T * V

combine, respectively, heaps and trees with variable stores.

2.2 Predicates
Predicates are either sets of abstract states (denoted p, q) or sets of state contexts(denoted

f, g). We do not fix a particular assertion language, although we douse standard logical notation for conjunction, disjunction, negation and quantification. We lift operations on states and contexts to predicates: for instance,
x 7! v denotes the predicate {x 7! v}; 9v. x 7! v denotes {x 7! v | v 2 Val};
p * q denotes {d1 * d2 | d1 2 p ^ d2 2 q}; the separating application f ffi p denotes{

c ffi d | c 2 f ^ d 2 p}; and so on. We also use Q* to denote iterated *. We useset-theoretic notation for predicate membership (2) and containment (`).

Abstraction and Refinement for Local Reasoning 5
2.3 Language Syntax
Our programming language has a simple imperative core with standard con-structs for variables, conditionals, iteration, and procedures. We tailor this language to different domains (heaps, trees, etc.) by choosing an appropriate set ofbasic commands for each domain.

Definition 2 (Programming Language). Given a set of basic commands \Phi ,ranged over by

', the language L\Phi  is defined by the following grammar:

C ::=skip | ' | x := E | C; C | if B then C else C | while B do C |

procs -!r 1 := f1(-!x 1){C}, * * * , -!r k := fk(-!x k){C} in C |

call -!r := f(-!E ) | local x in C

where x , r , . . . 2 Var range over program variables, E , E 1, . . . 2 ExpVal range
over value expressions, -!x , -!E , . . . represent vectors of program variables or ex-pressions,

B 2 ExpBool ranges over boolean expressions, and f, f1, . . . 2 PNamerange over procedure names.

2.4 Axiomatic Semantics
We give the semantics of the language L\Phi  as a program logic based on localHoare reasoning. We model the state with the context algebra, A * V, which

combines two context algebras: the context algebra, A, manipulated only bythe commands of

\Phi ; and the variable store context algebra, V, used to interpretprogram variables. By treating variables as resource [1], we are able to avoid sideconditions in our proof rules. A set of axioms Ax ` P(DA * \Sigma )* \Phi  * P(DA * \Sigma )provides the semantics for the commands of

\Phi , where DA is the set of abstractstates from A and
\Sigma  is the set of variable stores from V.The judgments of our proof system have the form

\Gamma  ` {p} C {q}, where
p, q 2 P(DA * \Sigma ) are predicates, C 2 L\Phi  is a program and \Gamma  is a procedurespecification environment. A procedure specification environment associates procedure names with pairs of pre- and postconditions (parameterised by the ar-guments and return values of the procedure respectively). The interpretation of
judgments is that, in the presence of procedures satisfying \Gamma  , when executedfrom a state satisfying

p, the program C will either diverge or terminate in astate satisfying
q.The proof rules of the program logic are given in Fig. 2. The semantics of

value expressions JE Koe is the value of E in variable store oe. The variable storepredicate

ae denotes an arbitrary variable store that evaluates all of the programvariables that are read but not written in each command under consideration.

We write vars(ae) and vars(E ) to denote the variables in ae and E respectively.The

Axiom rule allows us to use the given specifications of our basic com-mands and the

Frame rule is the natural generalisation of the frame rule forseparation algebras to context algebras. The rules

Assgn, Local, PDef and
PCall are standard, adapted to our treatment of variables as resource. The

6 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

(p, ', q) 2 Ax
\Gamma  ` {p} ' {q} Axiom

\Gamma  ` {p} C {q}
\Gamma  ` {f ffi p} C {f ffi q} Frame

vars(ae) = vars(E ) - {x }
\Gamma  ` {0A * (x *+ v * ae)} x := E *0A * (x *+ JE K(x *+v*ae) * ae)_ Assgn

\Gamma  ` {(IA * x *+ -) ffi p} C {(IA * x *+ -) ffi q} (IA * x *+ -) ffi p 6= ;

\Gamma  ` {p} local x in C {q} Local

8(fi :P ! Q) 2 \Gamma . \Gamma  0, \Gamma  ` {9-!

v . P (-!v ) * (-!x i *+ -!v * -!r i *+ -)}C

i{9-!
w . Q(-!w ) * (-!x i *+ - * -!r i *+ -!w )}8
(f : P ! Q) 2 \Gamma . 9i. f = fi \Gamma  0, \Gamma  ` {p} C {q}

\Gamma  0 ` {p} procs -!r 1 := f1(-!x 1){C1}, . . . , -!r k := fk(-!x k){Ck} in C {q} PDef

vars(ae) = vars(E ) - {-!r }

\Gamma , (f : P ! Q) ` n

P (J-!E K(-!r *+-!v *ae)) * (-!r *+ -!v * ae)o

call -!r := f(-!E ){9-!
w . Q(-!w ) * (-!r *+ -!w * ae)}

PCall

Fig. 2. Selected local Hoare logic rules for L\Phi .
Assgn rule not only requires the resource x *+ v, but also the resource ae contain-ing the other variables used in

E . For the Local rule, recall that the predicate
p specifies a set of pairs consisting of resource from DA and variable resource.The predicate (

IA * x *+ -) ffi p therefore extends the variable component withvariable
x of indeterminate initial value. If a local variable block is used to re-declare a variable that is already in scope, the

Frame rule must be used add thevariable's outer scope after the
Local rule is applied. For the PDef and PCallrules, the procedure
f has parametrised predicates P = *-!x .p and Q = *-!r .qas its pre- and postcondition, with

P (-!v ) = p[-!v /-!x ] and Q(-!w ) = q[-!w /-!r ];the parameters carry the call and return values of the procedure. We omit the

Cons, Disj, Skip, Seq, If and While rules, which are standard. For all of ourexamples, the conjunction rule is admissible; in general, this is not the case.

3 Abstract Modules
The language given in $2 and its semantics are parameterised by a contextalgebra, a set of commands and a set of axioms. These parameters constitute an
abstract description of a module. We shall use this notion of an abstract moduleto show how to correctly implement one module in terms of another.

Definition 3 (Abstract Module). An abstract module A = (AA, \Phi A, AxA)consists of a context algebra A

A with abstract state set DA, a set of commands
\Phi A and a set of axioms AxA ` P(DA * \Sigma ) * \Phi A * P(DA * \Sigma ).

Abstraction and Refinement for Local Reasoning 7
Notation. We write LA for the language L\Phi A. We write `A for the proof judgmentdetermined by the abstract module. When A can be inferred from context, we
may simply write ` instead of `A.

3.1 Heap Module
The first and most familiar abstract module we consider is the abstract heapmodule, H = (H

, \Phi H, AxH), which extends the core language with standardheap-update commands. The context algebra H was defined in Example 1. We

give the heap update commands in Definition 4, and the axioms for describingthe behaviour of these commands in Definition 5.

Definition 4 (Heap Update Commands). The set of heap update commands
\Phi H comprises: allocation, n := alloc(E ); disposal, dispose(E , E 0); mutation,[

E ] := E 0; and lookup n := [E ].

Definition 5 (Heap Axioms). The set of heap axioms AxH comprises:ae

emp * n *+ v * ae^ J

E Kae*n *+v >= 1 oe n := alloc(E ) 8!:

9x. x 7! - * ...*

x + JE Kae*n *+v 7! -*

n *+ x * ae 9=;ae J
E Kae 7! - * ...* J

E Kae + JE 0Kae 7! - * ae oe dispose(E , E 0) {emp * ae}{J

E Kae 7! - * ae} [E ] := E 0 {JE Kae 7! JE 0Kae * ae}{J
E Kae*n *+v 7! x * n *+ v * ae} n := [E ] {JE Kae*n *+v 7! x * n *+ x * ae}

3.2 Tree Module
Another familiar abstract module that we consider is the abstract tree module,T = (T

, \Phi T, AxT), which extends the core language with tree update commandsacting on a single tree, similar to a document in DOM. The tree context algebra

T was defined in Example 1. We give the tree update commands in Definition 6and their corresponding axioms in Definition 7.

Definition 6 (Tree Update Commands). The set of tree update commands
\Phi T comprises: relative traversal, getUp, getLeft, getRight, getFirst, getLast;node creation,

newNodeAfter; and subtree deletion deleteTree.

Definition 7 (Tree Axioms). The set of tree update axioms AxT includes:ae J

E Kae*n *+n[t] ffl m[t0]*

n *+ n * ae oe n := getRight(E ) ae J

E Kae*n *+n[t] ffl m[t0]*

n *+ m * ae oeae

m[t0ffl JE Kae*n *+n[t]]*

n *+ n * ae oe n := getRight(E ) ae

m[t0ffl JE Kae*n *+n[t]]*

n *+ null * ae oeae J

E Kae*n *+n[t0ffl m[t]]*

n *+ n * ae oe n := getLast(E ) ae J

E Kae*n *+n[t0 ffl m[t]]*

n *+ m * ae oeae J

E Kae*n *+n[?]*

n *+ n * ae oe n := getLast(E ) ae J

E Kae*n *+n[?]*

n *+ null * ae oe

8 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

{JE Kae[t] * ae} newNodeAfter(E ) {9m. JE Kae[t] ffl m[?] * ae}{J

E Kae[t] * ae} deleteTree(E ) {? * ae}
The omitted axioms are analogous to those given above.

3.3 List Module
We will study an implementation of the tree module using lists of unique ad-dresses. We therefore define an abstract module for manipulating lists whose

elements are unique, L = (L, \Phi L, AxL). The list context algebra L is given inDefinition 10. The list update commands are given in Definition 11 and their
corresponding axioms are given in Definition 12.Superficially, our abstract list stores resemble heaps, in the sense that we have
multiple lists each with a unique address. We write (i Z)v1+v2+v3)*(j Z) w1+v1)to denote a list store consisting of two separate lists

v1 + v2 + v3 and w1 + v1,at different addresses
i and j. However, unlike heaps, our list store contexts alsoallow us to consider separation within lists. For example, the same list store can

be written as (i Z) v1 + - + v3) ffi (i Z)v2 * j Z) w1 + v1), describing a list context
v1 + - + v3 at address i applied to the list store i Z) v2 * j Z) w1 + v1: theapplication puts list

v2 at i into the context hole.Furthermore, we make a distinction between lists

j Z) w1 + v1 which can beextended by list contexts, and completed lists
j Z) [w1 + v1] which cannot beextended. The reason to work with completed lists is that sometimes we need

to know which elements are the first or last elements in a list. For example, thecommand

getHead will return the first element of a list, so this element must befully determined and not subject to change if a frame is applied. Completed lists

may be separated into contexts and sublists, for example j Z) [w1 + -] ffi j Z) v1 isdefined, but may not be extended, for example

j Z) w1 +-ffij Z) [v1] is undefined.

Definition 8 (List Stores and Contexts). Lists l 2 L, list contexts lc 2 Lc,list stores

ls 2 Ls, and list store contexts lsc 2 Lsc are defined by:

l ::= " | v | l + l ls ::= emp | i Z) l | i Z)[l] | ls * ls
lc ::= - | lc + l | l + lc lsc ::= ls | i Z) lc | i Z) [lc] | lsc * lsc

where v 2 Val ranges over values, which are taken to occur uniquely in each listor list context,

i 2 Laddr ranges over list addresses, which are taken to occuruniquely in each list store or list store context, + is taken to be associative with

identity ", and * is taken to be associative and commutative with identity emp.

Our context application ffi actually subsumes our separating operator *, inthat as well as extending existing lists, we can also add new lists to the store,

for example (j Z)w1 + v1) ffi (i Z) v1 + v2 + v3) = (j Z) w1 + v1) * (i Z) v1 + v2 + v3).
Definition 9 (Application and Composition). The application of list storecontexts to list stores ffi :

Lsc * Ls * Ls is defined inductively by:

emp ffi ls = ls
(lsc * i Z) l) ffi ls = (lsc ffi ls) * i Z) l
(lsc * i Z) [l]) ffi ls = (lsc ffi ls) * i Z) [l]

Abstraction and Refinement for Local Reasoning 9
(lsc * i Z) lc) ffi (ls * i Z) l) = (lsc ffi ls) * i Z) lc[l/-]
(lsc * i Z) [lc]) ffi (ls * i Z) l) = (lsc ffi ls) * i Z) [lc[l/-]]

where lc[l/-] denotes the standard replacement of the hole in lc by l. The resultof the application is undefined when either the right-hand side is badly formed

or no case applies. The composition * : Lsc * Lsc * Lsc is defined similarly.
Definition 10 (List-Store Context Algebra). The list-store context alge-bra, L = (

Lsc, Ls, *, ffi, {emp}, {emp}) is given by the above definitions.

Definition 11 (List Update Commands). The set of list commands \Phi L com-prises: lookup,

getHead, getTail, getNext, getPrev; stack-style access, pop,
push; value removal and insertion, remove, insert; and construction and de-struction,

newList, deleteList.

Definition 12 (List Axioms). The set of list axioms AxL includes the follow-ing axioms: (the omitted axioms are analogous)ae J

E Kae*v *+v Z)[ v0 + l ]*

v *+ v * ae oe v := E.getHead() ae J

E Kae*v *+v Z) [ v0 + l ]*

v *+ v0 * ae oeae J

E Kae*v *+v Z)[ " ]*

v *+ v * ae oe v := E.getHead() ae J

E Kae*v *+v Z) [ " ]*

v *+ null * ae oeae J

E Kae*v *+v Z)JE 0Kae*v *+v + u*

v *+ v * ae oe v := E.getNext(E 0) ae J

E Kae*v *+v Z)JE 0Kae*v *+v + u*

v *+ u * ae oeae J

E Kae*v *+v Z)[ l+JE 0Kae*v *+v ]*

v *+ v * ae oe v := E.getNext(E 0) ae J

E Kae*v *+v Z)[ l+JE 0Kae*v *+v ]*

v *+ null * ae oe{J

E Kae Z) [ l ] * ae ^ (JE 0Kae 62 l)} E.push(E 0) {JE Kae Z)[ JE 0Kae + l ] * ae}{J

E Kae Z)JE 0Kae * ae} E.remove(E 0) {JE Kae Z)" * ae}ae J
E Kae Z) [ l+JE 0Kae +l0 ] * ae^ (J

E 00Kae 62 l + JE 0Kae + l0) oe E.insert(E 0, E 00) ae J

E Kae Z) [ l + JE 0Kae+J

E 00Kae + l0 ] * ae oe{; *

i *+ i} i := newList() {9j. j Z)[ " ] * i *+ j}{J
E Kae Z) [ l ] * ae} E.deleteList() {; * ae}

3.4 Combining Abstract Modules
We provide a natural way of combining abstract modules that enables programsto be written that intermix commands from different modules. For example, we

will use the heap and list module combination H + L in $5.1 as the basis forimplementing T. The combination comprises both commands for manipulating
lists and commands for manipulating heaps, defined so that they do not interferewith each other.

Definition 13 (Abstract Module Combination). Given abstract modulesA

1 = (AA1, \Phi A1, AxA1) and A2 = (AA2, \Phi A2, AxA2), their combination A1+A2 =(A

A1 * AA2, \Phi A1 \Phi  \Phi A2, AxA1 + AxA2) is defined by:

10 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

- AA1 * AA2 is the product of context algebras;-

\Phi A1 \Phi  \Phi A2 = (\Phi A1 * {1}) [ (\Phi A2 * {2}) is the disjoint union of commandsets;

- AxA1 +AxA2 is the lifting of the axiom sets AxA1 and AxA2 using the emptystates from

AxA2 and AxA1: formally, AxA1 + AxA2 ={(
ss1p, (', 1), ss1q) | (p, ', q) 2 AxA1} [ {(ss2p, (', 2), ss2q) | (p, ', q) 2 AxA1},where

ss1p = {(d,o,oe) | (d,oe) 2 p, o 2 02}, ss2p = {(o,d,oe) | (d,oe) 2 p, o 2 01}.

When the command sets \Phi A1 and \Phi A2 are disjoint, we may drop the tagswhen referring to the commands in the combined abstract module. When we do

use the tags, we indicate them with an appropriately placed subscript.

4 Module Translations
We define what it means to correctly implement one module in terms of another,using translations which are reminiscent of downward simulations in [9].

Definition 14 (Sound Module Translation). A module translation A ! Bfrom abstract module A to abstract module B consists of

- a state translation function J-K : DA ! P(DB), and- a substitutive implementation function J-K : L

A ! LB obtained by substi-tuting each basic command of
\Phi A with a call to a procedure written in LB.

A module translation is sound if, for all p, q 2 P(DA * \Sigma ) and C 2 LA,

`A {p} C {q} =) `B {JpK} JCK {JqK} .
where the predicate translation J-K : P(DA * \Sigma ) ! P(DB * \Sigma ) is the naturallifting of the state translation given by J

pK = W(d,oe)2pJdK * oe.

We will see that sometimes the module structure is preserved by the transla-tions and sometimes it is not; also, sometimes the proof structure is preserved,

sometimes not. Notice that, since we are only considering partial correctness, itis always acceptable for the implementation to diverge. In order to make termination guarantees, we could work with total correctness; our decision not to isfor simplicity and based on prevailing trends in separation logic and context logic
literature [12, 4, 2]. It is possible for our predicate translation to lose information.For instance, if all predicates were unsatisfiable under translation, it would be
possible to implement every abstract command with skip; such an implementa-tion is useless. It may be desirable to consider some injectivity condition which
distinguishes states and predicates of interest. Our results do not rely on this.

Modularity. A translation A1 ! A2 can be naturally lifted to a translationA

1+B ! A2+B, for any module B. We would hope that the resulting translationswould be sound, but it is not clear that this holds for all sound translations

A1 ! A2. When it is does hold, we say that the translation A1 ! A2 is modular.The techniques we consider in this paper provide modular translations, because
they inductively transform proofs from module A1 to proofs in module A2.

Abstraction and Refinement for Local Reasoning 11
(a) (b) (c)

Fig. 3. An abstract tree from T (a), and its representations in H (b) and H * Ls (c).
5 Locality-preserving Translations
Sometimes there is a close correspondence between locality in an abstract mod-ule and locality in its implementation. We introduce locality-preserving module
translations, and provide a general result that such translations are sound. Re-call Fig. 1 of the introduction. We show that module translations T ! H + L
and H + H ! H are locality preserving.

Consider Fig. 3 which depicts a simple tree (a), and representations of it inthe heap module H (b), and in the combined heap and list module H + L (c).

In (b), a node is represented by a memory block of four fields, recording theaddresses of the left sibling, parent, right sibling and first child. In (c), a node
is represented by a list of the child nodes (shown as boxes) and a block of twofields, recording the address of the parent and the child list. Just as the tree in
(a) can be decomposed into a context and a disjoint subtree (as shown by thedashed lined), its representations can also be decomposed: the representations
preserve context application. However, we must account for the pointers in therepresentations which cross the boundary between context and subtree. This
means that the representation of a tree must be parameterised by an interfaceto the surrounding context. Similarly, contexts are parameterised by interfaces
both to the inner subtree and outer context. We split the interface I into twocomponents: the reference the surrounding context makes in to the subtree (the
in part), and the reference the subtree makes out to the surrounding context(the out part).

Consider deleting the subtree indicated by the dashed lines in the figure.In the abstract tree, this deletion only operates on the subtree: the axiom for
deletion has just the subtree as its precondition. In the implementations however,the deletion also operates on the representation of some of the surrounding
context: in (b), this is the parent node and right sibling; in (c), the parentnode and child list. We therefore introduce the idea of a crust predicate, e

FI ,

that comprises the minimal additional state required by an implementation. Thecrust is parameterised by interface

I and an additional crust parameter F thatfully determine it. In the figure, the crusts for the subtree in (b) and (c) are

shown shaded. (In the list-based representation, all the sibling nodes form partof the crust because they are required for node insertion.)

12 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

We define locality-preserving translations which incorporate three key prop-erties: application preservation, crust inclusion, and axiom correctness. Application preservation, we have seen, requires that the low-level representations ofabstract states can be decomposed in the same manner as the abstract states
themselves. Crust inclusion requires that an abstract state's crust is subsumedby any context that is applied (together with the context's own crust). This
allows us to frame on arbitrary contexts despite the crust already being present- we simply remove the state's crust from the context before applying it. (Since
the crust represents an effective overlap between what represents a state andwhat represents its context, the abstract view that the two are disjoint is really
a fiction of disjointness.) Finally, axiom correctness requires that the implemen-tations of the basic commands meet the specifications given by the abstract
module's axioms.
Definition 15 (Locality-Preserving Translation). For interface set I =I

in * Iout and crust parameter set F, a locality-preserving translation A ! Bcomprises:

- representation functions hh-ii- : DA * I ! P(DB) and hh-ii-- : CA * I * I !P(C

B);- a crust predicate e

FI , parameterised by I 2 I and F 2 F; and

- a substitutive implementation function J-K : LA ! LB,

for which the following properties hold:

1. application preservation: for all f 2 P(CA), p 2 P(DA) and I 2 I,

hhf ffiA piiI = 9I0. hhf iiII0 ffiB hhpiiI0;
2. crust inclusion: for all -!out0, -!out 2 Iout, F 2 F, c 2 CA, there exist f 2P

(CB), F 0 2 F such that, for all -!in 2 Iin,i

9-!in0. eF-!in0,-!out0 * hhcii-!in0,-!out0-!in,-!out j = f * eF0-!in,-!out; and
3. axiom correctness: for all (p, ', q) 2 AxA, -!out 2 Iout and F 2 F,

`B n(|p|)-!out,F o J'K n(|q|)-!out,F o ,

where (|p|)-!out,F = W(d,oe)2p(9-!in. eF-!in,-!out ffi hhdii-!in,-!out) * oe.
Notice that this locality-preserving translation is a module translation, with the
state translation function J-K : DA ! P(DB) defined by JdK = 9-!in. eF-!in,-!out ffi

hhdii-!in,-!out, for some choice of -!out 2 Iout and F 2 F.

Theorem 1. A locality-preserving translation A ! B is a sound translation.

Abstraction and Refinement for Local Reasoning 13
This theorem is proved by inductively transforming a high-level proof in A tothe corresponding proof in B, preserving the structure. Application preservation
and crust inclusion allow us to transform a high-level frame into a low-level frame,and axiom correctness allows us to soundly replace the high-level commands
with their implementations. The remaining proof rules transform naturally. Ifwe chose to include the conjunction rule in our proof system, then we would need
to additionally verify that our representation functions preserve conjunction and
also that the crust predicate 9-!in. eF-!in,-!out is precise.

5.1 Module Translation: T ! H + L
We study a list-based implementation of the tree module which uses a combina-tion of the heap and list modules given in $3. We shall see that this implementation provides a locality-preserving translation of our abstract tree module. Todefine a locality-preserving translation we need to give a representation function,
a crust predicate and a substitutive implementation function for the translation.The representation functions for trees and tree contexts are given below. As
we have seen, each node of the tree is represented by a list of addresses of thenode's children and a memory block of two fields that record the addresses of
the parent node and child list. The in part of the interface, l 2 (N+)*, is a list ofthe addresses of the top-level nodes of the subtree. The out part of the interface,
u 2 N+, is the address of the subtree's parent node. We use the notation x 7! y,zto mean

x 7! y * x + 1 7! z and also write E 1 .= E 2 to mean emp ^ (E 1 = E 2).We also abuse notation slightly, freely combining heaps and list stores with *.

hh?ii",u ::= emphh
n[t]iin,u ::= 9i, l. n 7! u,i * i Z)[ l ] * hhtiil,nhh
t1 ffl t2iil,u ::= 9l1, l2. (l .= l1 + l2) * hht1iil1,u * hht2iil2,u

hh-iil,ul0,u0 ::= (l .= l0) * (u .= u0)
hhn[c]iin,uI0 ::= 9i, l. n 7! u,i * i Z)[ l ] * hhciil,nI0hh

t ffl ciil,uI0 ::= 9l1, l2. (l .= l1 + l2) * hhtiil1,u * hhciil2,uI0hh
c ffl tiil,uI0 ::= 9l1, l2. (l .= l1 + l2) * hhciil1,uI0 * hhtiil2,u

The crust, eFI , parameterised by interface I = l, u and free logical variables
F = (l1, l2, u0), is defined as follows:

el1,l2,u0l,u ::= 9i. u 7! u0,i * i Z) [ l1 + l + l2 ] * 

*Y

n2l1+l2

n 7! u!

This crust predicate captures the shaded part of the tree shown in Fig. 3(c) whichincludes the parent node

u of the subtree and the list of u's children, includingthe top level nodes
l of the subtree. These are needed by the implementationsof commands that lookup siblings or parents, or delete a subtree. The crust also

14 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

n .parent , n
n .children , n + 1
n := newNode() , n := alloc(2)
disposeNode(n ) , dispose(n , 2)

proc n 0 := getLast(n ){

local x in

x := [n .children] ;
n 0 := x .getTail()}

proc n 0 := getRight(n ){

local x , y in

x := [n .parent] ;
y := [x .children] ;
n 0 := y .getNext(n )}

proc deleteTree(n ){

local x , y , z in

x := [n .parent] ;
y := [x .children] ;
y .remove(n ) ;
y := [n .children] ;
z := y .getHead() ;
while z 6= null do

call deleteTree(z ) ;
z := y .getHead()
disposeList(y ) ;
disposeNode(n )}

Fig. 4. Selected procedures for the list-based implementation

includes the other sibling nodes as these are needed by the implementation ofthe node insertion command.

A selection of the procedures that constitute the substitutive implementationfunction is given in Fig. 4.

Theorem 2. The representation function, crust predicate and substitutive im-plementation given above constitute a locality-preserving translation.

5.2 Module Translation: H + H ! H
Another example of a locality-preserving translation is given by implementing apair of heap modules H + H in a single heap H, by simply treating the two heaps

as disjoint portions of the same heap.The representation function is the same both for states and for contexts:
hh(h1, h2)ii = {h1} * {h2}. The interface set is trivial (just a single-element set).The crust parameter set is also trivial, and the crust predicate is simply emp. The
substitutive implementation JCK is defined to be the detagging of C: that is, heapcommands from both abstract modules are substituted with the corresponding
command from the single abstract module. For example:J

n := alloc1(E )K = n := alloc(E ) = Jn := alloc2(E )K
Theorem 3. The representation function, crust predicate and substitutive im-plementation given above constitute a locality-preserving translation.

(Note, the representation function in this case does not preserve conjunction.)
6 Locality-breaking Translations
There is not always a close correspondence between locality in an abstract mod-ule and locality in its implementation. For example, consider an implementation
of our list module that represents each list as a singly-linked list in the heap.In the abstract module, the footprint of removing a specific element from a list

Abstraction and Refinement for Local Reasoning 15
is just the element of the list. In the implementation however, the list is tra-versed from its head to reach the element, which is then deleted by modifying
the pointer of its predecessor. The footprint is therefore the list fragment fromthe head of the list to the element, significantly more than the single list node
holding the value to be removed. While we could treat this additional footprintas crust, in this case it seems appropriate to abandon the preservation of locality
and instead give a locality-breaking translation that provides a fiction of locality.Consider a translation from abstract module A to B. With the exception of
the frame rule and axioms, the proof rules for A can be mapped to the corre-sponding proof rules of B: that is, from the translated premises we can directly
deduce the translated conclusion. To deal with the frame rule, we remove it fromproofs in A by `pushing' applications of the frame rule to the leaves of the proof
tree. In this way, we can transform any local proof to a non-local proof.
Lemma 1 (Frame-free Derivations). Let A be an abstract module. If thereis a derivation of `

A {p} C {q} then there is also a derivation that only usesthe frame rule in the following ways:

\Gamma  ` {p} C {q} (#)
\Gamma  ` {f ffi p} C {f ffi q}

...
\Gamma  ` {p} C {q}
\Gamma  ` {(IA * oe) ffi p} C {(IA * oe) ffi q}

where (#) is either Axiom, Skip or Assgn.

By transforming a high-level proof of `A {p} C {q} in this way, we canestablish `

B {JpK} JCK {JqK} provided that we can prove that the implementa-tion of each command of

\Phi A satisfies the translation of each of its axioms underevery frame. (We can reduce considerations to singleton frames by considering

any given frame as a disjunction of singletons and applying the Disj rule.)
Definition 16 (Locality-breaking Translation). A locality-breaking trans-lation A ! B is a module translation such that, for all

c 2 CA and (p, ', q) 2
AxA, the judgment `B {J{c} ffi pK} J'K {J{c} ffi qK} holds.

Theorem 4. A locality-breaking translation is a sound translation.

If we include the conjunction rule, then we must verify that every singletoncontext predicate is precise (i.e. the context algebra must be left-cancellative).

Note that, whilst there is less to prove when working with locality-breakingtranslations than with locality-preserving translations, the actual proofs may
be more difficult as we have to show that the axioms are preserved in everycontext. Our examples show that the two approaches are suited to different
circumstances.

6.1 Module Translation: L ! H
We provide a locality-breaking translation L ! H, which implements abstractlists with singly-linked lists in the heap.

16 Thomas Dinsdale-Young, Philippa Gardner, and Mark Wheelhouse

x .value , x

x .next , x + 1
x := newNode() , x := alloc(2)
disposeNode(x ) , dispose(x , 2)

proc i.remove(v ){

local u , x , y , z in

x := [i ] ;
u := [x .value] ;
y := [x .next] ;
if u = v

then

[i ] := y ;
disposeNode(x )
else

u := [y .value] ;
while u 6= v do

x := y ;
y := [x .next] ;
u := [y .value]
z := [y .next] ;
[x .next] := z ;
disposeNode(y )}

proc v := i.getNext(v 0){

local x in

x := [i ] ;
v := [x .value] ;
while v 6= v 0 do

x := [x .next] ;
v := [x .value]
x := [x .next] ;
if x = null then v := x

else v := [x .value]}

Fig. 5. Selected procedures for the linked-list implementation
The state translation from list stores to heaps is defined inductively by:J

;K ::= emp Ji Z) l * lsK ::= FalseJ
i Z)[ l ] * lsK ::= 9x. i 7! x * hhlii(x,null ) * JlsK

where hh"ii(x,y) ::= (x .= y) hhvii(x,y) ::= x 7! v,y

hhl + l0ii(x,y) ::= 9z. hhlii(x,z) * hhl0ii(z,y)
Note that not all list stores are realised by heaps: only ones in which every list iscomplete. The intuition behind this is that partial lists are purely abstract notions that provide a useful means to our ultimate end, namely reasoning aboutcomplete lists. The abstract module itself does not provide operations for creating or destroying partial lists, and so we would not expect to give specificationsfor complete programs that concern partial lists. A selection of the procedures
that constitute the substitutive implementation function is given in Fig. 5.
Theorem 5. The state translation and substitutive implementation given aboveconstitute a locality-breaking translation.

7 Conclusions
We have shown how to refine module specifications given by abstract local rea-soning into correct implementations. We have identified two general approaches
for proving correctness: locality-preserving and locality-breaking translations.Locality-preserving translations relate the abstract locality of a module with the
low-level locality of its implementation. This is subtle since disjoint structuresat the high-level are not quite disjoint at the low-level, because of the additional crust that is required to handle the pointer surgery. Locality-preservingtranslations thus establish a fiction of disjointness. Meanwhile, locality-breaking
translations establish a fiction of locality, by justifying abstract locality eventhough this locality is not matched by the implementation.

This paper has focused on refinement for abstract local reasoning in thesequential setting. With Dodds, Parkinson and Vafeiadis, Dinsdale-Young and

Abstraction and Refinement for Local Reasoning 17
Gardner have introduced concurrent abstract predicates [6] as a technique forverifying correct implementations of concurrent modules. They achieve local
reasoning and disjoint concurrency at the abstract level, by abstracting from alow-level resource model with fine-grained permissions. Our next challenge is to
extend our refinement techniques to the setting of disjoint concurrency.
Acknowledgments: Gardner acknowledges support of a Microsoft/RAEngSenior Research Fellowship. Dinsdale-Young and Wheelhouse acknowledge support of EPSRC DTA awards. We thank Mohammad Raza and Uri Zarfaty fordetailed discussions of this work. In particular, some of the technical details
in our locality-preserving translations come from an unpublished technical re-port Reasoning about High-level Tree Update and its Low-level Implementation
written by Gardner and Zarfaty in 2008.

References

1. R. Bornat, C. Calcagno, and H. Yang. Variables as resource in separation logic.

In Proceedings of MFPS XXI, volume 155 of ENTCS, pages 247-276, Amsterdam,
The Netherlands, 2006. Elsevier.
2. C. Calcagno, P. Gardner, and U. Zarfaty. Context logic and tree update. In POPL

'05, volume 40 of SIGPLAN Not., pages 271-282, New York, NY, USA, 2005.
ACM.
3. C. Calcagno, P. Gardner, and U. Zarfaty. Local reasoning about data update.

Electron. Notes Theor. Comput. Sci., 172:133-175, 2007.
4. C. Calcagno, P. W. O'Hearn, and H. Yang. Local action and abstract separation

logic. In LICS '07, pages 366-378, Washington, DC, USA, 2007. IEEE Computer
Society.
5. W. DeRoever and K. Engelhardt. Data Refinement: Model-Oriented Proof Methods

and Their Comparison. Cambridge University Press, Cambridge, UK, 1999.
6. T. Dinsdale-Young, M. Dodds, P. Gardner, M. Parkinson, and V. Vafeiadis. Concurrent abstract predicates. In ECOOP '10, LNCS, Berlin/Heidelberg, Germany,
2010. Springer.
7. T. Dinsdale-Young, P. Gardner, and M. Wheelhouse. Abstract local reasoning.

Technical report, Imperial College London, London, UK, 2010. http://www.doc.
ic.ac.uk/~td202/papers/alrfull.pdf.
8. P. A. Gardner, G. D. Smith, M. J. Wheelhouse, and U. D. Zarfaty. Local Hoare

reasoning about DOM. In PODS '08, pages 261-270, New York, NY, USA, 2008.
ACM.
9. J. He, C. A. R. Hoare, and J. W. Sanders. Data refinement refined. In ESOP '86,

volume 213 of LNCS, pages 187-196, Berlin/Heidelberg, Germany, 1986. Springer.
10. C. A. R. Hoare. Proof of correctness of data representations. Acta Inf., 1(4):271-

281, 1972.
11. I. Mijajlovi'c, N. Torp-Smith, and P. W. O'Hearn. Refinement and separation contexts. In FSTTCS '04, pages 421-433, Berlin/Heidelberg, Germany, 2004. Springer.
12. P. W. O'Hearn, J. Reynolds, and H. Yang. Local reasoning about programs

that alter data structures. In CSL '01, volume 2142 of LNCS, pages 1-19,
Berlin/Heidelberg, Germany, 2001. Springer.
13. M. Parkinson and G. Bierman. Separation logic and abstraction. In POPL '05,

volume 40 of SIGPLAN Not., pages 247-258, New York, NY, USA, 2005. ACM.