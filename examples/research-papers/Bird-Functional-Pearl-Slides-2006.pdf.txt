

01

Back

Home>Recent Press>Pearl Walking Map>Special Events Venues
First Thursday>PDBA Members>Contact Us>Site Map

02

Virtual Tour History
Magazine Recent Press
Pearl Walking Map Portland Streetcar
Neighborhood Association
Business Association

The name of Portland's best known art district, The Pearl, suggests urban legend.
Perhaps an oyster canning factory once sat amidst the aging warehouses, or Chinese
seafarers hid pearls beneath cobble stoned Twelfth Street. Whatever the origin, there's
the suggestion of both beauty and ugliness in the name--an elegant gem nestled in a
drab, rough shell.

The story goes like this: Thomas Augustine, a local gallery owner, coined the phrase
more than 10 years ago to suggest that the buildings in the warehouse district were like crusty oysters, and that the galleries and artists' lofts within were like pearls. "There

were very few visible changes in the area," says Al Solhiem, a developer who has been
involved in many projects in the district. "People would drive by and not have a clue as
to what was inside." As local business people were looking to label the growing
area--the "warehouse district" or the "brewery district" were two suggestions--an
Alaska Airlines writer borrowed Augustine's phrase, according to Solheim. The name stuck.

"Everyone hated it," says Pulliam Deffenbaugh Gallery owner Rod Pulliam, who opened
his gallery 10 years ago. Few other galleries, such as Quartersaw and Blackfish, have
histories that go back that far. But many artists lived or worked in the area in loft buildings such as the Maddox on Hoyt Street. Back then, says Pulliam, light industry,

vacant buildings, and blue collar cafes outnumbered the galleries and lofts.
Despite initial cynicism about the name, few deny that it's catchy. The Portland Institute
for Contemporary Art (PICA)'s inventive announcement for its 1998 annual Dada Ball
included a tuna can with a fake pearl inside.

Home>Recent Press>Pearl Walking Map>Special Events Venues First Thursday>PDBA Members>Contact Us>Site Map

03

HowtoWritea

FunctionalPearl

ICFP,Portland,Oregon,2006
RichardBird

04

MybrieffromtheProgramChair

"WelldoneFunctionalPearlsareoftenthehighlightofan
ICFPconference,butmanyofthesubmittedones
somehowmissthemark,bybeingtootrivial,too
complicated,orsomehownotquitetheelegantsolution
onehopesfor.Soitwouldbeinterestingtohearabout
yourexperiencesastowhatmakesagoodoneandhow
togoaboutcreatingit."

05

Whatisafunctionalpearl?
RecentICFPcallsforpapershavesaid:
"Functionalpearls:Elegant,instructiveexamplesof
functionalprogramming.
...Pearlsneednotreportoriginalresearchresults;they
mayinsteadpresentre-usableprogrammingidiomsor
elegantnewwaysofapproachingaproblem."

Somepreviouscallsaddedanoff-puttingsentence:
"Itisnotenoughsimplytodescribeaprogram!"

So,pearlsare
polishedelegantinstructiveentertaining

06

Origins
In1990,whenJFPwasbeingplanned,Iwasaskedbythethen
editors,SimonPeytonJonesandPhilipWadler,tocontributea
regularcolumntobecalledFunctionalPearls.

Theideatheyhadinmindwastoemulatetheverysuccessful
seriesofessaysthatJonBentleyhadwritteninthe1980sunder
thetitleProgrammingPearlsintheC.ACM.

Bentleywroteabouthispearls:
"Justasnaturalpearlsgrowfromgrainsofsandthat
haveirritatedoysters,theseprogrammingpearlshave
grownfromrealproblemsthathaveirritated
programmers.Theprogramsarefun,andtheyteach
importantprogrammingtechniquesandfundamental
designprinciples."

07

Whyme?
BecauseIwasaGOFERman.
Onemajorreasonthatfunctionalprogrammingstimulatedthe
interestofmanyatthattimewasthatitwas

GOodForEquationalReasoning.

Perhaps,theeditorsnodoubtthought,Icouldgiveexamplesof
GOFER-ingaclearbutinefficientfunctionalspecificationintoa
lessobviousbutmoreefficientprogram?

Mypersonalresearchagenda:tostudytheextenttowhichthe
wholearsenalofefficientalgorithmdesigntechniquescanbe
expressed,organised,taughtandcommunicatedthroughthelaws
offunctionalprogramming.

08

Thestateofplay

*Some64pearlswillhaveappearedinJFPbytheendof2006;

*AlsoasprinklingofpearlsatICFPandMPC;

*SpecialissueinJFP,2004devotedtopearls;

*AlsoacollectioninTheFunofProgramming,editedbyJ.
GibbonsandO.deMoor,Palgrave,2003.

Pearlscontain:

*Instructiveexamplesofprogramcalculationorproof;

*Niftypresentationsofoldornewdatastructures;

*Interestingapplicationsandprogrammingtechniques.

09

ReviewingforJFP
Isendouteachpearlforreview,includingmyown.Reviewersare
instructedtostopreadingwhen

*Theygetbored;

*Thematerialgetstoocomplicated;

*Toomuchspecialistknowledgeisneeded;

*Thewritingisbad.

Somepearlsarebetterservicedasstandardresearchpapers.
Mostneedmoretimeintheoyster.

10

Advice

*Throwawaytherulebookforwritingresearchpapers;

*Getinquick,getoutquick;

*Beself-contained,nolonglistsofreferencesandrelatedwork;

*Beengaging;

*Remember,writingandreadingarejointventures;

*Youaretellingastory,sosomeelementofsurpriseis
welcome;

*Findanauthorwhosestyleyouadmireandcopyit(my
personalfavouritesareMartinGardnerandDonKnuth).

11

Moreadvice

*Giveatalkonthepearltonon-specialists,yourstudents,
yourdepartment.

*Ifyouchangedtheorderofpresentationforthetalk,
considerusingtheneworderinthenextdraft;

*Putthepearlawayforacoupleofmonthsatleast;

*Takeitoutandpolishitagain.

12

Adviceonadvice
"Whateveradviceyougive,beshort."Horace

"Theonlythingtodowithgoodadviceistopassiton.It
isneverofanyusetooneself."OscarWilde

"Iowemysuccesstohavinglistenedrespectfullytothe
verybestadvice,andthengoingawayanddoingthe
exactopposite."G.K.Chesterton

13

ASimpleSudoku
Solver

ICFP,Portland,Oregon,2006
RichardBird

14

AquotefromTheIndependentNewspaper

HowtoplayFillinthegridsothateveryrow,every
columnandevery3*3boxcontainsthedigits1-9.
There'snomathsinvolved.Yousolvethepuzzlewith
reasoningandlogic.

15

Ouraim
Ouraimistodefineafunction
solve::Grid->[Grid]

forfillinginagridcorrectlyinallpossibleways.
Webeginwithaspecification,thenuseequationalreasoningto
calculateamoreefficientversion.

No`maths',nomonads:justwholesome,pure-andlazy
functionalprogramming.

16

Basicdatatypes
>typeMatrixa=[Rowa]
>typeRowa=[a]

>typeGrid=MatrixDigit
>typeDigit=Char

>digits::[Digit]
>digits=['1'..'9']

>blank::Digit->Bool
>blank=(=='0')

Wesupposethatthegivengridcontainsonlydigitsandblanks.

17

Specification
Hereisthespecification:
>solve1::Grid->[Grid]
>solve1=filtervalid.expand.choices

Inwords:firstinstallallpossiblechoicesfortheblankentries,
thencomputeallgridsthatarisefrommakingeverypossible
choice,thenreturnonlythevalidgrids.

Thetypes:
choices::Grid->MatrixChoices
expand::MatrixChoices->[Grid]
valid::Grid->Bool

18

Installingchoices
ThesimplestchoiceofChoicesis
>typeChoices=[Digit]
Thenwehave
>choices::Grid->MatrixChoices
>choices=map(mapchoice)
>wherechoiced|blankd=digits
>|otherwise=[d]

19

Expansion
Expansionisjustmatrixcartesianproduct:
>expand::MatrixChoices->[Grid]
>expand=cp.mapcp

Thecartesianproductofalistoflistsisgivenby:
>cp::[[a]]->[[a]]
>cp=foldrop[[]]
>opxsyss=[x:ys|x<-xs,ys<-yss]

20

Validgrids
Avalidgridisoneinwhichnorow,columnorboxcontains
duplicates.

>valid::Grid->Bool
>validg=allnodups(rowsg)&&
>allnodups(colsg)&&
>allnodups(boxsg)

Weomitthedefinitionofnodups.
Thatleavesthedefinitionofrows,cols,andboxs.

21

Rows,columnsandboxs
>rows,cols,boxs::Matrixa->[Rowa]
>rows=id
>cols=foldr(zipWith(:))(repeat[])
Boxsisjustalittlemoreinteresting:
>boxs=mapunsplit.unsplit.mapcols.
>split.mapsplit

>unsplit=concat
>split[]=[]
>split(x:y:z:xs)=[x,y,z]:splitxs

22

Wholemealprogramming
Insteadofthinkingaboutcoordinatesystems,anddoing
arithmeticonsubscriptstoextractinformationaboutrows,
columnsandboxes,wehavegonefordefinitionsofthese
functionsthattreatthematrixasacompleteentityinitself.

GeraintJoneshasaptlycalledthisstyle
WholemealProgramming

Wholemealprogrammingisgoodforyou:ithelpstopreventa
diseasecalledindexitis,andencourageslawfulprogram
construction.

23

Laws
Forexample,herearethreelawsthatarevalidonN2*N2
matrices:

rows.rows=id
cols.cols=id
boxs.boxs=id

Herearethreemore,validonN2*N2matricesofchoices:
maprows.expand=expand.rows
mapcols.expand=expand.cols
mapboxs.expand=expand.boxs

Wewillmakeuseoftheselawsinashortwhile.

24

Threemorelaws
Thefollowinglawsconcernfilter:
Iff.f=id,then
filter(p.f)=mapf.filterp.mapf
Secondly,
filter(allp).cp=cp.map(filterp)
Thirdly,
filterp.concat=concat.map(filterp)
Wewillalsomakeuseoftheselawsinduecourse.

25

Pruningamatrixofchoices
Thoughexecutableintheory,thespecificationishopelessin
practice.

Tomakeamoreefficientsolver,agoodideaistoremoveany
choicesfromacellcthatalreadyoccurassingleentriesinthe
row,columnandboxcontainingc.

Wethereforeseekafunction
prune::MatrixChoices->MatrixChoices

sothat
filtervalid.expand

=filtervalid.expand.prune

Howwouldyoudefineprune?

26

Pruningarow
>pruneRow::RowChoices->RowChoices
>pruneRowrow=map(removeones)row
>whereones=[d|[d]<-row]

>removexs[d]=[d]
>removexsds=ds\\xs

ThefunctionpruneRowsatisfies
filternodups.cp

=filternodups.cp.pruneRow

27

Calculation
Remember,wewant
filtervalid.expand

=filtervalid.expand.prune

Wehave
filtervalid.expand

=filter(allnodups.boxs).
filter(allnodups.cols).
filter(allnodups.rows).expand

Wesendeachofthesefiltersonebyoneintobattlewithexpand.

28

GOFERit!
Letf2{rows,cols,boxs}andabbreviatenodupstop:
filter(allp.f).expand

={sincef.f=id}
mapf.filter(allp).mapf.expand

={sincemapf.expand=expand.f}
mapf.filter(allp).expand.f

={definitionofexpand}
mapf.filter(allp).cp.mapcp.f

={lawoffilterandcp}
mapf.cp.map(filterp.cp).f
{propertyofpruneRow}

=mapf.cp.map(filterp.cp.pruneRow).f

29

Goingbackwards!
mapf.cp.map(filterp.cp.pruneRow).f

={lawoffilterandcp}
mapf.filter(allp).cp.mapcp.mappruneRow.f

={definitionofexpand}
mapf.filter(allp).expand.mappruneRow.f

={sincef.f=id}
filter(allp.f).mapf.expand.mappruneRow.f

={sincemapf.expand=expand.f}
filter(allp.f).expand.f.mappruneRow.f

={introducingpruneByf=f.mappruneRow.f}
filter(allp.f).expand.pruneByf

Hence
filter(allp.f).expand

=filter(allp.f).expand.pruneByf

30

Theresult
Afteratadmoreequationalreasoning,weobtain
>prune::MatrixChoices->MatrixChoices
>prune=
>pruneByboxs.pruneBycols.pruneByrows
>wherepruneByf=f.mappruneRow.f

Nowwehaveasecondversionoftheprogram:
>solve2::Grid->[Grid]
>solve2=filtervalid.expand.prune.choices

Infact,wecanhaveasmanyprunesaswelike.

31

Single-cellexpansion
ThesimplestSudokuproblemsaresolvedbyrepeatedlypruning
thematrixofchoicesuntilonlysingletonchoicesareleft.

Formoredeviouspuzzleswecancombinepruningwithanother
simpleidea:single-cellexpansion.

Supposewedefineafunction
expand1::MatrixChoices->[MatrixChoices]

thatexpandsthechoicesforonecellonly.Thisfunctionisto
satisfythepropertythat,uptopermutationoftheanswer,

expand=concat.mapexpand.expand1

32

Parsimoniousexpansion
Agoodchoiceofcellonwhichtoperformexpansionisonewitha
smallestnumberofchoices,notequalto1ofcourse:

>expand1::MatrixChoices->[MatrixChoices]
>expand1cm=
>[rows1++[row1++[c]:row2]++rows2|c<-cs]
>where
>(rows1,row:rows2)=break(anysmallest)cm
>(row1,cs:row2)=breaksmallestrow
>smallestcs=lengthcs==n
>n=minimum(lengthscm)

>lengths=filter(/=1).maplength.concat

33

Propertiesofparsimoniousexpansion

*expand1cm=[]ifcmcontainsanullchoice;

*expand1cm=undefinedifcmcontainsonlysinglechoices.

Hence
expand=concat.mapexpand.expand1

onlyholdswhenappliedtomatriceswithatleastonenon-single
choice,possiblyanullchoice.

Sayamatrixiscompleteifallchoicesaresingletons,andblocked
ifthesingletonchoicescontainaduplicate.

Incompletebutblockedmatricescanneverleadtovalidgrids.A
completeandnon-blockedmatrixofchoicescorrespondstoa
uniquevalidgrid.

34

Blockedandcompletematrices
>complete::MatrixChoices->Bool
>complete=all(allsingle)

>single[_]=True
>single_=False

>blocked::MatrixChoices->Bool
>blockedcm=anyhasdups(rowscm)||
>anyhasdups(colscm)||
>anyhasdups(boxscm)

>hasdupsrow=dups[d|[d]<-row]

35

Morecalculation
Assumingamatrixisnon-blockedandincomplete,wehave
filtervalid.expand

=filtervalid.concat.mapexpand.expand1
=concat.map(filtervalid.expand).
expand1

=concat.map(filtervalid.expand.prune).
expand1

Writing
search=filtervalid.expand.prune

wethereforehave,onincompleteandnon-blockedmatrices,
search=concat.mapsearch.expand1.prune

36

Areasonablesudokusolver
>solve::Grid->[Grid]
>solve=search.choices

>search::MatrixChoices->[Grid]
>searchcm
>|blockedpm=[]
>|completepm=[map(maphead)pm]
>|otherwise=concat$mapsearch$expand1pm
>wherepm=prunecm

37

Tests
ItestedthesolveronSimonPeytonJones'36puzzlesrecordedat
http://haskell.org/haskellwiki/Sudoku
Itsolvedthemin8.8seconds(ona1GHzpentium3PC).
Ialsotestedthemon6minimalpuzzles(eachwith17non-blank
entries)chosenrandomlyfromthe32000givenatthesite.

Itsolvedthemin111.4seconds.

38

Conclusions
ThereareaboutadozenHaskellSudokusolversat
http://haskell.org/haskellwiki/Sudoku
Allofthese,includingaverynicesolverbyLennartAugustsson,
deploycoordinatecalculations.Manyusearraysandmostuse
monads.IknowofsolversthatreducetheproblemtoBoolean
satisfiability,constraintsatisfaction,modelchecking,andsoon.

MineisabouttwiceasslowasLennart'sonthenefariouspuzzle,
butaboutthirtytimesfasterthanYitzGale'ssolveroneasy
puzzles.

Iwouldarguethatmineiscertainlyoneofthesimplestand
shortest.Atleastitwasderived,inpart,byequationalreasoning.