

Noname manuscript No.
(will be inserted by the editor)

Call-By-Push-Value: Decomposing Call-By-Value And
Call-By-Name

Paul Blain Levy

Received: date / Accepted: date
Abstract We present the call-by-push-value (CBPV) calculus, which decomposes the
typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain
primitives. On the operational side, we give big-step semantics and a stack machine
for CBPV, which leads to a straightforward push/pop reading of CBPV programs. On
the denotational side, we model CBPV using cpos and, more generally, using algebras
for a strong monad. For storage, we present an O'Hearn-style "behaviour semantics"
that does not use a monad.

We present the translations from CBN and CBV to CBPV. All these translations straightforwardly preserve denotational semantics. We also study their operational properties: simulation and full abstraction.

We give an equational theory for CBPV, and show it equivalent to a categorical
semantics using monads and algebras. We use this theory to formally compare CBPV
to Filinski's variant of the monadic metalanguage, as well as to Marz's language SFPL,
both of which have essentially the same type structure as CBPV. We also discuss less
formally the differences between the CBPV and monadic frameworks.

Keywords call-by-push-value * computational effect * monad * lambda-calculus *
call-by-value * call-by-name

1 Introduction
1.1 Aims of Paper
Let us consider typed call-by-value (CBV) and typed call-by-name (CBN), and observe
convergence at ground type only. (This restriction does not matter in CBV, but in CBN,
it makes the j-law for functions into an observational equivalence.) Suppose we seek
to combine these into a single "subsuming" language such that

- the subsuming language, like CBV and CBN, is equipped with operational semantics, cpo semantics, monad semantics, storage semantics in the manner of (O'H93)
and continuation semantics in the manner of (SR98)

University of Birmingham
E-mail: pbl@cs.bham.ac.uk

2

- these semantics are at least as simple as the corresponding semantics for CBV and

CBN
- the translations preserve all these semantics.

We could add "etc." to the list of semantics, but for the sake of precision we will stop
there.

The reason this is a desirable objective is that it is plausible that the situation found
for all the semantics listed will also be true for all other CBV and CBN semantics we
might wish to study. (This cannot be made into a precise statement, because of the
simplicity requirement.) If so, then a researcher studying a new kind of semantics need
only develop it for the subsuming language, because the CBV and CBN semantics can
be derived from the subsuming semantics.

In this paper, we introduce a calculus, call-by-push-value (CBPV), which is a solution to this problem. It was obtained by analyzing the above semantics to find comon
underlying primitives. But this paper does not follow that route; instead, the only
knowledge presupposed is big-step and cpo semantics for CBV and CBN, and global
store and monad semantics for CBV.

1.2 Related Work
CBPV is closely related to Filinski's Effect-PCF (Fil96), a form of the monadic metalanguage (Mog91). However it differs from Effect-PCF in 2 respects.

1. CBPV's computation types denote algebras, not merely carriers of algebras. As we

explain in Sect. 2.1, this is essential in order to treat CBN compositionally.
2. CBPV retains the distinction between a computation and its thunk, familiar to

CBV programmers but erased in monadic metalanguages. Sect. 2.2 explains this
point in the more familiar CBV setting, before we come to CBPV.

Besides Effect-PCF, and somewhat similar pointed/unpointed calculi such as (How96),
there has been much work bringing CBV and CBN into a common framework. However,
it is usually with regard to a narrower range of semantics than we are considering.

- Translations into intuitionistic linear logic (BW96) preserve cpo semantics, but not

the others.
- Translations into SFPL (Mar00) preserve cpo semantics and operational semantics,

but not the others.
- Translations into continuation languages (Plo75), or their polarized counterpart

LLP (Lau99), preserve continuation semantics, including unbracketed game semantics (Lai98), and (certain) operational semantics, but not the others. Likewise the
related work of (Sel01).

We therefore emphasize what, by contrast, is extraordinary about CBPV: the translations into it preserve such a wide range of semantics. Indeed there are many more,
including game semantics, possible world semantics, non-monad models of nondeterminism, etc., that we do not treat in this paper, and the reader is referred to (Lev04)
for more information.

3
1.3 Structure of Paper
Before looking at CBPV, we develop some themes in monad semantics of CBN (Sect. 2.1)
and CBV (Sect. 2.2). We then introduce CBPV, with its monad/algebra semantics, and
big-step semantics. We also present a stack machine, which explains why functions are
computations in CBPV: they pop their argument from the stack.

A novel part of the paper is Sect. 6.2, which presents a behaviour semantics for
storage--actually the simpler CBPV version of the CBN semantics in (O'H93). Because
it is not a monad semantics, this model illustrates the difference between CBPV and
the monadic framework. Furthermore, we see that its soundness is trivial, by contrast
with that of the monad/algebra model1.

We then give the translations from CBV and CBN into CBPV, and prove preservation of denotational semantics. This is a trivial result, but it is the most important
one, in the light of our original problem. We also show preservation of operational
semantics--not exactly, but up to some minor "administrative reductions". And we
state (without proof) full abstraction theorems for these translations.

Next, we move to the more technical part of the paper: relating CBPV to the wellestablished monadic framework. To do this, we need an equational theory for CBPV,
and we also need to add certain complex values to the syntax, though they can always
be eliminated from a computation. We give a monad/algebra categorical semantics and
prove that every CBPV model is equivalent to a monad model (even though it may be
unnatural to present it in this way). This enables us, finally, to prove the soundness of
the algebra model for storage, deducing it from that of the behaviour semantics.

Finally, having dealt with complex values and the equational theory, it is straightforward to relate CBPV to Filinski's Effect-PCF and Marz's SFPL (except for recursive
types, which we do not treat in this paper).

1.4 Note
Since the original presentation in (Lev99), some changes have been made to the CBPV
syntax (including recursion).

produce V  return V
h: : : ; i:Mi; : : :i2Ii  *{i:Mi}i2I

let x be V: M  let V be x: M

(^i; V )  h^i; V i
(V; V 0)  hV; V 0i

ux: M  rec x: M

2 Monads
2.1 Algebra Semantics For Call-By-Name
There are two theories for typed CBN:

1 In fact the latter can be deduced from the former, as explained at the end of Sect. 9.

4

- the "lazy" theory (HD97; Ong88), where convergence is observed at every type
- the "PCF-style" theory (Plo77), where convergence is observed at ground type

only.

The terms *xA:divergeB and divergeA!B are observationally equivalent in the PCFstyle theory, but not in the lazy theory. (The lazy theory has also been studied in the
untyped setting (Abr90; HD97; Ong88; Plo75).)

Moggi's seminal paper (Mog91) provided translations from CBV and lazy CBN
into his "monadic metalanguage", and hence semantics for CBV and CBN in any
bicartesian closed category C equipped with a strong monad T . The translation from
lazy CBN is shown in (Hat94) to be the composite

lazy CBN // CBV // monadic metalanguage
Here the first factor is the thunking transform of (HD97).

A semantics of PCF-style CBN in (C; T ) is given in (BHM00; Fil96). In it, we have

[[bool]] = T (1 + 1)
[[A ! B]] = [[A]] ! [[B]]

[[A + B]] = T ([[A]] + [[B]])

and a term A0; : : : ; An-1 ` M : B denotes a function from [[A0]] * * * * * [[An-1]] to [[B]].

This semantics--which, for reasons explained below, we call carrier semantics--is
not compositional. For example, the interpretation of if must be given by induction
over types: it is trivial at ground type or sum type, and at function type it is given by

if M then N else N0 = *x: (if M then (Nx) else (N0x)) (1)
in the sense that the denotation of the LHS is defined to be that of the RHS. Furthermore, in order to prove the computational adequacy of such a semantics, one first has
to prove2 that (1) is an observational equivalence.

The solution to this non-compositionality problem is that, in monad semantics, a
CBN type should denote not an object of C, but rather a T -algebra. We recall that this

is defined to be a pair (X; `), where X 2 ob C and T X ` // X is a morphism such
that

X

jX //

id !!BB

BB

BB
BB T X

`
fflffl

T 2X
uXoo

T `
fflffl
X T X`oo

(2)

commutes. We call X the carrier and ` the structure of the algebra. Here are some
examples:

- An algebra for the lifting monad on Cpo has a pointed cpo or cppo (cpo with a

least element), as a carrier, and each pointed cpo has a unique structure map. Thus
this monad is unusual in that an algebra is determined by its carrier.
- An algebra for the printing monad A* * - on Set can be described as an A-set, a

set X together with a binary operation * from A * X to X. This corresponds to a
monoid action, written **, of A* on X.

2 An alternative method is given in Remark 1 below.

5
Given a strong monad T on cartesian C, we can build T -algebras for it in the following
ways.

- The free T -algebra on a C-object A has carrier T A and structure map uA.
- For a family of T -algebras {(Xi; `i)}i2I , suppose the object family {Xi}i2I has

a product, with vertex V and projection V ss

i // X

i for each i 2 I. Then the

product algebra Qi2I (Xi; `i) has carrier V and structure the unique T V

OE // V

such that

T V
OE

fflffl

T ssi // T X

i

`i
fflffl
V ssi // Xi

commutes for each i 2 I.

- For a C-object A and T -algebra (X; `), suppose there is an exponential from A to

X, with vertex V and evaluation A * V

ev // X . Then the exponential algebra

A ! (X; `) has carrier V and structure the unique T V

OE // V such that

A * T V
A*OE

fflffl

tA;V // T (A * V ) T ev // T X

`
fflfflA * V

ev // X

commutes.

Suppose we write F T A for the free T -algebra on A, and UT B for the carrier of a T algebra B. Then (assuming C to be bicartesian closed) the algebra semantics of CBN
types is given by

[[bool]] = F T (1 + 1)
[[A ! B]] = UT [[A]] ! [[B]]

[[A + B]] = F T (UT [[A]] + UT [[B]])

and a term A0; : : : ; An-1 ` M : B denotes a function from UT [[A0]] * * * * * UT [[An-1]]
to UT [[B]].

Clearly,

- every type's carrier denotation is the carrier of its algebra denotation (hence the

name "carrier semantics")
- the two sides of (1) have the same denotation in algebra semantics (but not by

definition, unlike in carrier semantics)
- hence each term has the same denotation in algebra and carrier semantics.

But in algebra semantics, the interpretation of conditionals is compositional.
Remark 1 The computational adequacy of carrier semantics can be deduced from that
of algebra semantics, since the denotations of terms are the same.

6

Similarly, consider a CBN language containing a print c instruction (for c 2 A)
that can be prefixed to a term of any type. The language is modelled using the printing
monad A* * - on Set. In carrier semantics, print would be interpreted by induction
on types. But in algebra semantics, a CBN type denotes an A-set (X; *), and we define

[[print c: M]]ae = c * [[M]]ae
The following is sufficient to ensure that all exponentials and finite products of
algebras exist, so that algebra semantics can be constructed.

Definition 1 An algebra-building structure consists of a strong monad (T; j; u; t) on
a distributive category C, with an exponential from every C-object to every carrier of
a T -algebra.

2.2 Call-By-Value and Thunks
We recapitulate and critique the analysis of CBV semantics that leads to the monadic
metalanguage.

Consider a CBV language with booleans and multi-ary functions, together with
some computational effects--let us say global store, and write S for the set of stores.
The types of this language are

A ::= bool | (A0; : : : ; An-1) ! A
The 0-ary function type ( ) ! A is well known to CBV programmers, being a type of
thunks that can be forced whenever convenient. Following (HD97; Mog89), we might
call this type T A, and write thunk M and force N for *( ):M and N( ) respectively.

Before monads became popular, the denotational semantics of this language would
have been formulated as follows. First we interpret each type by a set:

[[bool]] = 1 + 1
[[(A0; : : : ; An-1) ! B]] = (S * [[A0]] * * * * * [[An-1]]) ! (S * [[B]])

Then we interpret each term \Gamma  ` M : B by a function S * [[\Gamma ]] [[

M]] // S * [[B]] . Next,

we interpret each value \Gamma  ` V : B by a function [[\Gamma ]] [[

V ]]val // [[B]] such that [[V ]](s; ae) =

(s; [[V ]]valae) for each s 2 S and ae 2 [[\Gamma ]].

We proceed to prove 2 substitution lemmas, for substitution of values into terms
and into values. Finally, we prove soundness and adequacy, which completes the story.

The line of thought that leads from this account to the monadic metalanguage
proceeds in three steps.

The first step is as follows. Since a value has 2 denotations--as a term, and as a
value--it makes sense to introduce an explicit judgement \Gamma  `v V : A for values, and to
make explicit the coercion of values into effectful terms. Doing this gives something like
the fine-grain CBV language3 shown in Fig. 1. This greatly simplifies the semantics of
CBV constructs, e.g. application.

3 The language MIL-lite in (BK99), which distinguishes between different effects, is somewhat similar. However, fine-grain CBV differs from the original CBV language only in its
judgements and terms; the types are unchanged.

7
Types

The same as the original CBV language

Judgements

\Gamma  `v V : A \Gamma  ` M : A

Terms

\Gamma ; x : A; \Gamma 0 `v x : A

\Gamma  `v V : A \Gamma ; x : A ` M : B

\Gamma  ` let V be x: M : B
\Gamma  `v V : A
\Gamma  ` return V : A

\Gamma  ` M : A \Gamma ; x : A ` N : B

\Gamma  ` M to x: N : B
\Gamma ; x : A ` M : B
\Gamma  `v *x:M : A ! B

\Gamma  `v V : A ! B \Gamma  `v W : A

\Gamma  ` V W : B
The rules for multi-ary functions are similar.

\Gamma  `v true : bool

\Gamma  `v V : bool \Gamma  ` M : B \Gamma  ` M0 : B

\Gamma  ` if V then M else M0 : B

Fig. 1 Syntax of Fine-Grain CBV, for boolean and multi-ary function types

The second step, a rather minor one, is to allow values to be formed using let and
if, by adding the typing rules

\Gamma  `v V : A \Gamma ; x : A `v W : B

\Gamma  `v let V be x: W : B

\Gamma  `v V : bool \Gamma  `v W : B \Gamma  `v W 0 : B

\Gamma  `v if V then W else W 0 : B
These so-called complex values greatly complicate the operational semantics, because
they need to be evaluated. However, they are very natural from a denotational and
categorical viewpoint. We discuss complex values in detail in Sect. 8.2 (not in the CBV
setting, but everything we say applies equally to CBV).

The third step is to observe that

[[( ) ! B]] = S ! (S * [[B]]) (3)
[[*( ):M]]valae = *s:([[M]](s; ae)) (4)

[[V ( )]](s; ae) = ([[V ]]valae)s (5)

So terms \Gamma  ` M : B correspond to values \Gamma  `v V : () ! B, via these thunking and
forcing operations. Therefore--it is argued--the ` judgement is redundant, and we
might as well abolish it, leaving only values. That gives the monadic metalanguage.

But this third step is problematic. Firstly, because it erases the conceptually significant difference between a CBV term and its thunk. Secondly, because this difference,
though invisible in monad semantics, is apparent in many others. These other semantics, although they can be squashed into the monadic straitjacket, become less simple
and less intuitive as a consequence.

The most glaring example is the possible world semantics of (Lev02), where the
semantic equations for the monadic metalanguage are much more complicated than
for fine-grain CBV, because they must repeatedly force and thunk. Other examples
are continuation and game models; these describe the interaction or jumping between

8
different parts of a program, and forcing corresponds to a jump. It is not possible to
treat these examples in this paper, but a full treatment can be found in (Lev04).

For these reasons, we will maintain the distinction between a term (computation)
and its thunk.

3 CBPV Syntax and Monad/Algebra Semantics
CBPV has two disjoint classes of terms: values and computations. Below, we shall
see this difference in operational terms: a value is, whereas a computation does. As
explained in Sect. 2.2, we take care to distinguish a computation M from its thunk, the
latter being a value that can be forced at any time.

CBPV likewise has two disjoint classes of type: a value has a value type, while a
computation has a computation type. The types are given by

value types A ::= UB | Pi2I Ai | 1 | A * A
computation types B ::= F A | Qi2I Bi | A ! B

where I is any finite4 set. The elements of I are called tags, and we write them starting
with #, to avoid confusion with identifiers. For example,P

{#jan:A; #feb:B; #mar:C}
is a value type if A; B; C are value types.

The type 1 is entirely analogous to *, so we generally omit typing rules, etc., for
it.

It is obvious how to interpret these types in an algebra-building structure: a value
type denotes an object of C whereas a computation type denotes a T -algebra. Thus
F A denotes the free T -algebra on [[A]], whilst UB denotes the carrier of [[B]]. The type
A ! B denotes the exponential algebra from [[A]] to [[B]].

In particular, using the lifting monad on Cpo, we interpret a value type by a cpo
and a computation type by a cppo. Here F A denotes the lift of [[A]], whilst UB has the
same denotation as B, so U is invisible. (A unary construct c is said to be invisible in
a given denotational semantics when [[c(Q)]] = [[Q]].)

As in CBV, an identifier in CBPV can be bound only to a value, so it must have
value type. We accordingly define a context \Gamma  to be a sequence

x0 : A0; : : : ; xn-1 : An-1
of distinct identifiers with associated value types. We often omit the identifiers and
write just A0; : : : ; An-1. In an algebra building structure this denotes the C-object
[[\Gamma ]] = [[A0]] * * * * * [[An-1]].

We write \Gamma  `v V : A to mean that V is a value of type A, and we write \Gamma  `c M : B
to mean that M is a computation of type B. The terms of CBPV are given in Fig. 2.
We explain some of the less familiar constructs. The keyword pm stands for "patternmatch". We write ` for application in reverse order; the advantage of this is explained

4 For certain purposes, including game semantics, B"ohm trees and possible worlds, it is
convenient to consider infinitary forms of CBPV, CBV and CBN. In the infinitary setting, I
can be any countable set (but only finite products of value types are allowed). In this paper,
we treat only finitary languages, but use the indexed notation with a view to this infinitary
extension.

9
in Sect. 5.2. Because we think of Qi2I as the type of functions taking each i 2 I to
a computation of type Bi, we have made its syntax similar to that of !. We use the
keyword to corresponding to the Haskell idiom >>= *. Thus M to x: N (unlike in
Haskell, N can have any computation type) is the sequenced computation that first
executes M, and when this produces a value x proceeds to execute N. We reserve let
for plain binding.

We writeA + B for P{#

l:A; #r:B}

0 for P{}
A \Pi  B for Q{#l:A; #r:B}
1\Pi  for Q{}

\Gamma ; x : A; \Gamma 0 `v x : A

\Gamma  `v V : A \Gamma ; x : A `c M : B

\Gamma  `c let V be x: M : B

\Gamma  `v V : A
\Gamma  `c return V : F A

\Gamma  `c M : F A \Gamma ; x : A `c N : B

\Gamma  `c M to x: N : B

\Gamma  `c M : B
\Gamma  `v thunk M : UB

\Gamma  `v V : UB
\Gamma  `c force V : B

\Gamma  `v V : A^i ^i 2 I
\Gamma  `v h^i; V i : Pi2IAi

\Gamma  `v V : Pi2IAi \Gamma ; x : Ai `c Mi : B (8i 2 I)

\Gamma  `c pm V as {hi; xi:Mi}i2I : B

\Gamma  `v V : A \Gamma  `v V 0 : A0

\Gamma  `v hV; V 0i : A * A0

\Gamma  `v V : A * A0 \Gamma ; x : A; y : A0 `c M : B

\Gamma  `c pm V as hx; yi:M : B

\Gamma  `c Mi : Bi (8i 2 I)
\Gamma  `c *{i:Mi}i2I : Qi2IBi

\Gamma  `c M : Qi2IBi ^i 2 I

\Gamma  `c ^i`M : B^i

\Gamma ; x : A `c M : B
\Gamma  `c *x:M : A ! B

\Gamma  `v V : A \Gamma  `c M : A ! B

\Gamma  `c V `M : B

Fig. 2 Terms of CBPV

In an algebra-building structure (C; T ), a value \Gamma  `v V : A denotes a C-morphism
from [[\Gamma ]] to [[A]], whilst a computation \Gamma  `c M : B denotes a C-morphism from [[\Gamma ]] to
the carrier of [[B]]. In particular:

- if \Gamma  `v V : A, then return V denotes the composite

[[\Gamma ]] [[

V ]] // [[A]] j[[A]] // T [[A]]

- If \Gamma  `c M : F A and \Gamma ; x : A `c N : B and B denotes the algebra (Y; OE) then

M to x: N denotes the composite

[[\Gamma ]] (

id;[[M]]) // [[\Gamma ]] * T [[A]] t[[\Gamma ]];[[A]] // T ([[\Gamma ]] * [[A]]) T [[N]] // T Y OE // Y

10

- thunk and force are invisible.
In Sect. 6.2, we shall see a model where thunk and force are visible.

Divergence
\Gamma  `c diverge : B

\Gamma ; x : UB `c M : B

\Gamma  `c rec x: M : B

Printing elements of a countable set A

\Gamma  `c M : B c 2 A
\Gamma  `c print c: M : B

Storing elements of a finite set S in a cell
(We could allow denumerable S, making the syntax infinitary.)

\Gamma  `c M : B s 2 S
\Gamma  `c cell := s: M : B

\Gamma  `c Ms : B (8s 2 S)
\Gamma  `c read-cell-as {s:Ms}s2S : B

Fig. 3 Adding divergence, printing, storage

In Fig. 3 we show how to add constructs for divergence/recursion, printing elements
of a set, and storing elements of a set in a global cell. Although there are many other
effects we can treat, this limited range suffices to illustrate our main points about
CBPV.

It is convenient to treat commands for printing etc. as prefixes, rather than as
primitive terms.

The denotational semantics of divergence in the cppo model is

[[diverge]]ae = ?
with rec x: M interpreted as a least prefixpoint. The denotational semantics of printing
in the A-set model is

[[print c: M]]ae = c * [[M]]ae
We discuss denotational semantics of storage in Sect. 6.1.

4 Big-Step Semantics
We begin the big-step semantics by defining a special class of closed computations
where evaluation stops, which we call terminal computations. (We cannot, of course,
call them "values".) They are given by

T ::= return V | *{i:Mi}i2I | *x:M
The big-step semantics are expressed using the judgement M + T , where M is a closed
computation and T a terminal computation of the same type. The rules are presented
in Figs. 4-5.

11
Each big-step rule has the form

M0 + T0 * * * Mr-1 + Tr-1

M + T (6)
for some r ? 0. Here they are:

M[V=x] + T
let V be x: M + T

return V + return V

M + return V N[V=x] + T

M to x: N + T

M + T
force thunk M + T

M^i[V=x] + T
pm h^i; V i as {hi; xi:Mi}i2I + T

M[V=x; V 0=y] + T
pm hV; V 0i as hx; yi:M + T

*{i:Mi}i2I + *{i:Mi}i2I

M + *{i:Ni}i2I N^i + T

^i`M + T

*x:M + *x:M

M + *x:N N[V=x] + T

V `M + T

Fig. 4 Big-step semantics for CBPV

Proposition 1 (termination and determinism)
no effects For each M there is a unique T such that M + T .
divergence For each M there exists at most one T such that M + T .
printing For each M there is a unique m; T such that M + m; T .
storage For each s; M there is a unique s0; T such that s; M + s0; T .

The proof is standard, and in the Appendix.
Definition 2 For any computation `c M : Pi2I 1 (such a computation is said to be
ground), its operation [M] is

no effects an element of I. If M + return hi; hii then [M] = i
divergence an element of I?. If M + return hi; hii then [M] = up i, and if M diverges

then [M] = ?
printing an element of A* * I. If M + m; return hi; hii then [M] = (m; i)
storage an element of S ! (S * I): for each s 2 S, if s; M + s0; return hi; hii then

[M]s = (s0; i).

In each case, we define observational equivalence ' to be the largest congruence on
terms such that if M ' M0 then [M] = [M0]. More explicitly, for two computations

12

Divergence We add the rules

diverge + T
diverge + T

M[thunk rec x: M=x] + T

rec x: M + T

and we say that M diverges when there does not exist T such that M + T . (This
exploits determinism, of course.)
Printing The big-step judgement takes the form M + m; T where m 2 A*. We
accordingly replace each rule (6) by

M0 + m0; T0 * * * Mr-1 + mr-1; Tr-1

M + m0 + m1 + * * * + mr-1; T

where + means concatenation of strings, and we add the rule

M + m; T
print c: M + [c] + m; T

Storage The big-step judgement takes the form s; M + s0; T where s; s0 2 S. We
accordingly replace each big-step rule of the form (6) by

s0; M0 + s1; T0 * * * sr-1; Mr-1 + sr; Tr-1

s0; M + sr; T
and we add the rules

s0; M + s00; T
s; cell := s0: M + s00; T

s0; Ms0 + s00; T
s0; read-cell-as {s:Ms}s2S + s00; T

Fig. 5 Big-step semantics for divergence, printing and storage

\Gamma  `c M; M0 : B, we say M ' M0 when [C[M]] = [C[M0]] for any ground-computation
context C with hole \Gamma  `c [*] : B.

In the case of divergence, we define observational inequality . to be the largest
precongruence on terms such that if M . M0 then [M] 6 [M0]. More explicitly, for
two computations \Gamma  `c M; M0 : B, we say M . M0 when [C[M]] 6 [C[M0]] for any
ground-computation context C with hole \Gamma  `c [*] : B.

In Sect. 3 we have given denotational semantics for divergence (using cpos/cppos)
and for printing (using A-sets), and we have to prove them sound and adequate.

Proposition 2 (soundness/adequacy) Let M be a closed computation. We write ffl
for the empty environment.

divergence If M + T then [[M]]ffl = [[T ]]ffl. If M diverges then [[M]]ffl = ?.
printing If M + m; T then [[M]]ffl = m ** [[T ]]ffl.

The proof is standard, and in the Appendix.

Corollary 1 Both for divergence and for printing, we have [[N]]ffl = [N] for every
ground computation N. Hence for any terms M; M0 (not necessarily closed), if [[M]] =
[[M0]] then M ' M0, by compositionality of [[-]]. In the case of divergence, [[M]] 6 [[M0]]
implies M . M0.

13
Initial Configuration
M nil

Transitions
let V be x: M K 
M[V=x] K

M to x: N K 
M to x: N :: K

return V to x: N :: K 
N[V=x] K

force thunk M K 
M K

pm h^i; V i as {hi; xi:Mi}i2I K 
M^i[V=x] K

pm hV; V 0i as hx; yi:M K 
M[V=x; V 0=y] K

^i`M K 

M ^i :: K

*{i:Mi}i2I ^i :: K 
M^i K

V `M K 
M V :: K

*x:M V :: K 
M[V=x] K

Terminal Configurations
return V nil
*{i:Mi}i2I nil
*x:M nil

Fig. 6 CK-machine for CBPV

5 CK-Machine
5.1 Introducing the CK-Machine
The CK-machine is a form of operational semantics that is more explicit than big-step
semantics and has certain advantages over it; for example, it allows the easy formulation of control effects. It can be given for CBV, CBN and CBPV. It was introduced
by (FF86) in a CBV setting, and there are many similar formulations (Kri85; PS98;
SR98).

At any point in time, the machine has configuration M; K when M is the computation we are evaluating and K is a stack. Here is a "raw" (i.e. type free) grammar of
stacks:

K ::= nil | to x: N :: K | V :: K | ^i :: K

14
For a typed grammar, see (Lev05).

To understand the CK-machine, just think about how we might implement the
big-step rules using a stack. Suppose for example that we are evaluating M to x: N.
The big-step semantics tells us that we must first evaluate M. So we put the rest of
the term to x: N onto the stack, because at present we do not need it. Later, having
evaluated M to return V , we can remove to x: N from the stack and proceed to
evaluate N[V=x], as the big-step semantics suggests.

As another example, suppose we are evaluating V `M. The big-step semantics tells
us that we must first evaluate M. So we put the argument V onto the stack, because
at present we do not need it. Later, having evaluated M to *x:N, we can remove this
argument from the stack and proceed to evaluate N[V=x], as the big-step semantics
suggests.

The machine is shown in Fig. 6. To evaluate a closed computation M, we start
with the configuration M; nil and follow the transitions until we reach a configuration
T; nil for a terminal computation T .

The CK-machine agrees with the big-step semantics in the following sense:

Proposition 3 For any closed computation M, we have M + T iff M; nil * T; nil.
This is proved in (Lev04) by standard techniques. For each of our effects, it is straightforward to adapt the CK-machine and obtain a variant of Prop. 3.

5.2 Pushing and Popping
The strangest feature of CBPV, for people familiar with CBV, is the fact that *x:M is
a computation. But the CK-machine gives a simple explanation of this feature. Looking
at Fig. 6, it is apparent that V ` can be read as an instruction "push V ", whilst *x can
be read as an instruction "pop x". This is why we prefer an operand-first notation for
application.

A fortunate consequence of the push/pop interpretation is that it makes CBPV
programs easy to read. Here is an example program using printing. The program involves some complex values such as arithmetic and string expressions, which are easy
to understand although they are not officially included within the CK-machine.

print "hello0".
let 3 be x.
let thunk (

print "hello1".
*z:
print "we just popped "z.
return x + z
) be y.
print "hello2".
( print "hello3".

7`
print "we just pushed 7".
force y
) to w.
print "w is bound to "w.
return w + 5

15
It is easy to see that the program outputs as follows
hello0
hello2
hello3
we just pushed 7
hello1
we just popped 7
w is bound to 10

and finally returns the value 15.

From this viewpoint, we can give the following operational summary of CBPV
types.

- A value of type UB is a thunk of a computation of type B.
- A value of type Pi2IAi is a pair hi; V i, where i 2 I and V is a value of type Ai.
- A value of type A * A0 is a pair hV; V 0i, where V is a value of type A and V 0 is a

value of type A0.
- A value of type 1 is the 0-tuple h i.

- A computation of type F A returns a value of type A.
- A computation of type Qi2I Bi pops a tag i 2 I, and then behaves as a computation

of type Bi.
- A computation of type A ! B pops a value of type A and then behaves as a

computation of type B.

Notice how this description follows the principle "a value is, a computation does".

6 Denotational Semantics for Storage
6.1 Monad/Algebra Semantics
So far we have seen denotational semantics for divergence and printing, and proved
them sound and adequate, but what about storage? One seemingly reasonable way of
building such a semantics is to use the S ! (S * -) monad on Set in the manner of
Sect. 3, so that a computation type denotes an algebra for this monad. But we still have
the task of proving some kind of soundness theorem, at the very least the following.

Proposition 4 If M is a closed computation of type F A, and s; M + s0; return V ,
then ([[M]]ffl)s = (s0; [[V ]]ffl).

This is not straightforward to prove. One method is to introduce another denotational
model, prove the latter sound, and then prove the agreement of the two models (we
describe this agreement at the end of Sect. 9). We now turn to this other denotational
model, called behaviour semantics, and introduced for CBN in (O'H93). Not only is it
easier to prove sound, but it is arguably more intuitive than the algebra semantics.

6.2 Behaviour Semantics
For values, behaviour semantics is no different from monad semantics:

16

- a value type A (and similarly a context \Gamma ) denotes a set
- the connectives P and * denote sum and product of sets
- a value \Gamma  `v V : A denotes a function from [[\Gamma ]] to [[A]].

But a computation type B denotes not an algebra but a set. Intuitively, this is the set
of behaviours of a computation of type B. So a computation \Gamma  `c M : B denotes a
function from S * [[\Gamma ]] to [[B]], because, in a given store s 2 S and environment ae 2 [[\Gamma ]],
it behaves in a certain way. The semantics of types is as follows:

- The behaviour of a computation of type F A is to terminate in a state s 2 S

returning a value V of type A. So F A denotes S * [[A]].
- The behaviour of a computation of type A ! B is to pop a value of type A, and,

depending on the value popped, to behave as a computation of type B. So A ! B
denotes [[A]] ! [[B]].
- The behaviour of a computation of type Qi2I Bi is to pop i 2 I, and, depending

on the i popped, to behave as a computation of type Bi. So Qi2I Bi denotesQ

i2I [[Bi]].- A value of type UB can be forced in any store s 2 S, and depending on this store,

will behave as a computation of type B. So UB denotes S ! [[B]].
The semantic equations for terms are straightforward and we omit them. In behaviour
semantics, it is straightforward to formulate a soundness theorem for computations of
all types:

Proposition 5 If s; M + s0; T then [[M]](s; ffl) = [[T ]](s0; ffl).
and this is proved by induction on +.
Corollary 2 [[N]](s; ffl) = [N]s for every ground computation N and s 2 S. Hence, for
any terms M; M0, if [[M]] = [[M0]] then M ' M0.

7 Call-By-Value and Call-By-Name Fragments of CBPV
7.1 Introduction
In this section, we shall display CBV and CBN as fragments of CBPV. The types of
CBV are value types and the types of CBN are computation types. Whereas the CBV
boolean and sum types are the same as CBPV, the CBV function type decomposes as

A !CBV B = U(A ! F B) (7)
Operationally, this says that a CBV function is a thunk of a computation that pops
an argument and returns an answer. The CBN function type decomposes as

A !CBN B = UA ! B
Operationally, this says that an argument to a CBN function is a thunk. The CBN
boolean and sum types decompose as

boolCBN = F (1 + 1)
A +CBN A0 = F (UA + UA0)

17
It is crucial to see that all these decompositions preserve denotational semantics, both
for cpos/cppos and, more generally, in the monad/algebra setting. We state this properly in Sect. 7.4.

The types we treat for CBV and CBN are

A ::= bool | A ! A | A + A (8)
deferring the treatment of other connectives to Sect. 7.5. For the connectives in (8), the
term syntax and the big-step semantics (+CBN and +CBV) are standard e.g. (Win93).
For recursion, there are several possible formulations, one of which is shown in Fig. 7.
Observational equivalence ('CBN and 'CBV) and inequality (.CBN and .CBV) are
defined as in Def. 2, defining ground terms to be closed terms of type bool.

CBN

\Gamma ; x : A ` M : A
\Gamma  ` rec x: M : A

M[rec x: M=x] +CBN T

rec x: M +CBN T
CBV

\Gamma ; x : A; f : A ! B ` M : B

\Gamma  ` rec f *x:M : A ! B rec f *x:M +CBV rec f *x:M

M +CBV rec f *x:P N +CBV V P [rec f *x:P=f; V=x] +CBV W

MN +CBV W

Fig. 7 Syntax and big-step semantics of recursion in CBN and CBV

7.2 CBN to CBPV
Each CBN term A0; : : : ; An-1 ` M : B is translated into a CBPV computation
UAn0; : : : ; UAnn-1 `c Mn : Bn. The translation is shown in Fig. 8, and it clearly
preserves denotational semantics in the cppo setting, and, more generally, in the
monad/algebra setting. However, it does not precisely preserve substitution or bigstep semantics; as an example, consider the CBN term let true be x: *y:x.

To achieve preservation of substitution, and preservation and reflection of big-step
semantics (we require reflection so that our account extends to a nondeterministic
setting), we work with a relation 7!n from CBN terms to CBPV computations. This
is defined inductively; there is one rule for each line of Fig. 8 e.g.

x 7!n force x

N 7!n N0 M 7!n M0
MN 7!n (thunk N0)`M0
together with an additional rule

M 7!n M0
M 7!n force thunk M0
Now substitution is preserved.

18

C Cn (a computation type)
bool F (1 + 1)
A + B F (UAn + UBn)
A ! B (UAn) ! Bn

A0; : : : ; An-1 ` M : C UAn0; : : : ; UAnn-1 `c Mn : Cn

x force x
let M be x: N let thunk Mn be x: Nn

true return h#l; h ii
false return h#r; h ii
if M then N else N0 Mn to z: pm z as {h#l; ui:Nn; h#r; ui:N0n}

inl M return h#l; thunk Mni
inr M return h#r; thunk Mni
pm M as {inl x:N; inr x:N0} Mn to z: pm z as {h#l; xi:Nn; h#r; xi:N0n}

*x:M *x:Mn

MN (thunk Nn)`Mn
rec x: M rec x: Mn
print c: M print c: Mn

Fig. 8 Translating CBN to CBPV

Proposition 6 If M 7!n M0 and N 7!n N0 then M[N=x] 7!n M0[thunk N0=x]
Proposition 7 The relation from CBN to CBPV terms is a bisimulation:

1. If M +CBN T and M 7!n M0, then there exists T 0 such that T 7!n T 0 and M0 + T 0.
2. If M 7!n M0 and M0 + T 0, then there exists T such that T 7!n T 0 and M +CBN T .

Hence the translation reflects observational inequality: if Mn . Nn then M .CBN N.

Proof For (1), induct, primarily on M +CBN T and secondarily on M 7!n M0. For (2),
induct on M0 + T 0.

7.3 From CBV to CBPV
The translation from CBV to CBPV proceeds in two stages: first from CBV to finegrain CBV (which we saw in Sect. 2.2), which leaves the types unchanged, and then
from fine-grain CBV into CBPV, which decomposes the function type. But, in this
paper, we just present the composite translation, and it appears in Fig. 9.

As with the translation from CBN, it does not preserve substitution or big-step
semantics. To see this, consider the term let inl true be x: *y:x.

So, again, we give a relation 7!v from CBV terms to CBPV computations, and
another relation 7!val from CBV values to CBPV values. We can present Fig. 9 by
rules such as these:

M 7!v M0 N 7!v N0
let x be M: N 7!v M0 to x: N0

M 7!v M0
*x:M 7!val thunk *x:M0
To these rules we add the following

M 7!v return V to x: return inl x

M 7!v return inl V

M 7!v return V to x: return inr x

M 7!v return inr V
We have thus defined non-functional relations 7!v and 7!val, and we will show that
they commute with substitution and preserve and reflect operational semantics.

19
C Cv (a value type)
bool 1 + 1
A + B Av + Bv
A ! B U(Av ! F Bv)

A0; : : : ; An-1 ` M : C Av0; : : : ; Avn-1 `c Mv : F Cv

x return x
let M be x: N Mv to x: Nv

true return h#l; h ii
false return h#r; h ii
if M then N else N0 Mv to z: pm z as {h#l; ui:Nv; h#r; ui:N0v}

inl M Mv to z: return h#l; zi
inr M Mv to z: return h#r; zi
pm M as {inl x:N; inr x:N0} Mv to z: pm z as {h#l; xi:Nv; h#r; xi:N0v}

*x:M return thunk *x:Mv

MN Mv to f: Nv to x: x`(force f)
print c: M print c: Mv
rec f *x:M return thunk rec f: *x:Mv

A0; : : : ; An-1 ` V : C Av0; : : : ; Avn-1 `v V val : Cv

x x
true h#l; h ii
false h#r; h ii
inl V h#l; V vali
inr V h#r; V vali

*x:M thunk *x:Mv
rec f *x:M thunk rec f: *x:Mv

Fig. 9 Translation of CBV types, terms and values

Proposition 8 The relations satisfy the following basic properties.

1. If V 7!val V 0 then V 7!v return V 0.
2. If M 7!v M0 and V 7!val V 0 then M[V=x] 7!v M0[V 0=x].
3. If W 7!val W 0 and V 7!val V 0 then W [V=x] 7!val W 0[V 0=x].

The relation from CBV to CBPV terms is a bisimulation, in the following sense.
Proposition 9 Suppose M 7!v M0.

1. If M +CBV V , then there exists V 0 such that M0 + return V 0 and V 7!val V 0.
2. If M0 + return V 0 there exists V such that M +CBV V and V 7!val V 0.

Hence the translation reflects observational inequality: if Mv . Nv then M .CBV N.

To prove this, we introduce the following.
Definition 3 We define two classes of safe terms.

1. In CBV, the following terms are safe:

S ::= x | let S be x: S | inl S | inr S

| true | false | if S then S else S
| pm S as {inl x:S; inr x:S} | *x:M

2. In CBPV the following terms (all computations of F type) are safe:

S ::= return V | let V be x: S | S to x: S

| pm V as {hi; xi:Si}i2I | pm V as hx; yi:S

20
Lemma 1 Suppose x0 : A0; : : : ; xn-1 : An-1 ` M : B and M 7!v M0. Then

1. M is safe iff M0 is safe.
2. Suppose that M is safe and that U0 7!val U00; : : : ; Un-1 7!val U0n-1.

- If M[---!Ui=xi] +CBV V , then, for some V 0, we have M0[---!U0i=xi] + return V 0 and

V 7!val V 0.
- If M0[---!U0i=xi] + return V 0, then, for some V , we have M[---!Ui=xi] +CBV V and

V 7!val V 0.

We prove Lemma 1 by induction on M 7!v M0.

Because of Lemma 1, we have the case M0 = return V 0 of Prop. 9. Using this
fact, we prove Prop. 9(1) by induction on M +CBV V , and (2) by induction on M0 +
return V 0.

7.4 Preservation of Denotational Semantics
As we stated in the Introduction, the most important results about CBPV are the
most trivial ones:

Proposition 10 The translations we have seen, from CBN and from CBV to CBPV
preserve cpo semantics, and more generally monad/algebra semantics, up to isomorphism. In other words, the semantics of CBN and CBV obtained from the monad/algebra
semantics of CBPV are the monad/algebra semantics described in Sect. 2.

In particular, the monad semantics5 of U(A ! F B) is an exponential from [[A]] to
T [[B]].

Proposition 11 The CBV storage semantics obtained from the storage semantics of
CBPV is the traditional one, up to isomorphism, while the CBN storage semantics
obtained from the storage semantics of CBPV is that of (O'H93).

In particular, we have

[[A !CBV B]] = S ! ([[A]] ! (S * [[B]]))
[[A !CBN B]] = (S ! [[A]]) ! [[B]]

7.5 Full Abstraction
A frequently asked question is whether the translations from CBV and CBN to CBPV
are fully abstract. This is not one but many questions: its meaning depends not only
on the set of effects available, but also on the set of connectives provided in the source
language. As illustration of this latter point, recall that the CBN language we have
considered so far contains binary sum, but not ternary sum, which is not isomorphic
to (A + B) + C in CBN. Yet a CBN ternary sum can be represented in CBPV. So the
question of whether the translation to CBPV is fully abstract incorporates the question
of whether adding ternary sum to CBN is fully abstract; and this is non-trivial.

To avoid this problem, we want to suppose the CBV/CBN source languages to
provide a "complete" range of connectives. It is argued in (Lev06) that the canonical

5 This in fact is true for any semantics of CBPV--this follows from Prop. 17 below.

21
way of doing this is to provide two general connectives: P (a kind of sum of products),
and Q (a kind of products of multi-ary function types).

An example of P is the following. If A, B, C are types, then P {#l:A; B; #r:C}
is the type of

- tuples h#l; M; M0i, where M has type A and M0 has type B, and
- tuples h#r; Mi, where M has type C.

This type has two introduction rules

\Gamma  ` M : A \Gamma  ` M0 : B
\Gamma  ` h#l; M; M0i : P {#l:A; B; #r:C}

\Gamma  ` M : C
\Gamma  ` h#r; Mi : P {#l:A; B; #r:C}

and one elimination rule that pattern-matches a tuple

\Gamma  ` M : P {#l:A; B; #r:C} \Gamma ; x : A; y : B ` N : D \Gamma ; x : C ` N0 : D

\Gamma  ` pm M as {h#l; x; yi: N; h#r; xi: N0} : D

An example of Q is the following. If A,B,C,D,E are types, then Q {#l:A; B `
C; #r:D ` E} is the type of functions that

- map arguments (#l; M; M0), where M has type A and M0 has type B, to something

of type C, and
- map arguments (#r; M), where M has type D, to something of type E.

This type has one introduction rule, a *-abstraction that must provide two bodies:

\Gamma ; x : A; y : B ` M : C \Gamma ; x : D ` M0 : E
\Gamma  ` *{(#l; x; y):M; (#r; x):M0} : Q {#l:A; B ` C; #r:D ` E}

and two elimination rules for application:

\Gamma  ` M : Q {#l:A; B ` C; #r:D ` E} \Gamma  ` N : A \Gamma  ` N0 : B

\Gamma  ` M(#l; N; N0) : C

\Gamma  ` M : Q {#l:A; B ` C; #r:D ` E} \Gamma  ` N : D

\Gamma  ` M(#r; N) : E

It is straightforward to give CBV and CBN operational semantics for all these terms.
For recursion, we follow Fig. 7; in the case of CBV, we allow recursive *-abstractions
of type Q {#l:A; B ` C; #r:D ` E}.

In the absence of effects, P and Q could be seen as mere syntactic sugar, built
up from the connectives 0; +; 1; *; !. But it is argued in (Lev06) that this viewpoint
falls down in the effectful setting, because many isomorphisms cease to hold.

It is easy to see how to generalize these two prototypical examples to arbitrary
tuple types and arbitrary function types; the details are given in (Lev06), and the
resulting form of *-calculus is called jumbo *-calculus. We accordingly assume the
CBV and CBN source languages to be jumbo *-calculus extended with effects. All the
connectives we have seen so far, viz. bool; +; !, as well as the n-ary function types
mentioned in Sect. 2.2, are instances of these connectives.

The translation of our two example connectives into CBPV is shown in Fig. 10.
We translate the general connectives into CBPV in the same way we translated the
two examples, and adapt the proofs of Prop. 7-11 accordingly.

22

CBN

C Cn (a computation type)P
{#l:A; B; #r:C} F P{#l:(UAn * UBn); #r:UCn}Q
{#l:A; B ` C; #r:D ` E} Q{#l:(UAn ! UBn ! Cn); #r:(UDn ! En)}

A0; : : : ; An-1 ` M : C UAn0; : : : ; UAnn-1 `c Mn : Cn

h#l; M; M0i return h#l; hthunk Mn; thunk M0nii

h#r; Mi return h#r; thunk Mni
pm M as {h#l; x; yi: N; h#r; xi: N0} Mn to z: pm z as {h#l; wi:(pm w as hx; yi:Nn); h#r; xi:N0n}

*{(#l; x; y):M; (#r; x):M0} *{#l:*x:*y:Mn; #r:*x:M0n}

M(#l; N; N0) thunk N0n`thunk Nn`#l`Mn

M(#r; N) thunk Nn`#r`Mn

CBV

C Cv (a value type)P
{#l:A; B; #r:C} P{#l:(Av * Bv); #r:Cv}Q
{#l:A; B ` C; #r:D ` E} UQ{#l:(Av ! Bv ! F Cv); #r:(Dv ! F Ev)}

A0; : : : ; An-1 ` M : C Av0; : : : ; Avn-1 `c Mv : F Cv

h#l; M; M0i Mv to x: M0v to y: return h#l; hx; yii

h#r; Mi Mv to x: return h#r; xi
pm M as {h#l; x; yi: N; h#r; xi: N0} Mv to z: pm z as {h#l; wi:(pm w as hx; yi:Nv); h#r; xi:N0v}

*{(#l; x; y):M; (#r; x):M0} return thunk *{#l:*x:*y:Mv; #r:*x:M0v}

M(#l; N; N0) Mv to f: Nv to x: N0v to y: y`x`#l`force f

M(#r; N) Mv to f: Nv to x: x`#r`force f
rec f *{(#l; x; y):M; (#r; x):M0} return thunk rec f: *{#l:*x:*y:Mv; #r:*x:M0v}

A0; : : : ; An-1 ` V : C (value) Av0; : : : ; Avn-1 `v V val : Cv

h#l; V; V 0i h#l; hV val; V 0valii

h#r; V i h#r; V vali
*{(#l; x; y):M; (#r; x):M0} thunk *{#l:*x:*y:Mv; #r:*x:M0v}
rec f *{(#l; x; y):M; (#r; x):M0} thunk rec f *{#l:*x:*y:Mv; #r:*x:M0v}

Fig. 10 Translating example connectives from CBN and CBV into CBPV

Proposition 12 (junk-freeness and full abstraction)

1. The translation from CBN jumbo *-calculus with any of our effects (divergence,

printing or storage) to CBPV with the same effects is
junk-free i.e. for each computation UAn0; : : : ; UAnn-1 ` M : Bn in the target

language, there is a term A0; : : : ; An-1 ` N : B in the source language such
that Nn = M is provable in the CBPV theory
fully abstract i.e. M .CBN N iff Mn . Nn.
2. The translation from CBV jumbo *-calculus with any of our effects (divergence,

printing or storage) to CBPV with the same effects is
junk-free i.e. for each computation Av0; : : : ; Avn-1 ` M : F Bv in the target language, there is a term A0; : : : ; An-1 ` N : B in the source language such that
Nv = M is provable in the CBPV theory
fully abstract i.e. M .CBV N iff Mv . Nv.

We omit the proof of junk-freeness, which uses a reverse translation from CBPV to
CBN and from CBPV to CBV, and is given in detail in (Lev04). Full abstraction
follows from junk-freeness in the standard manner (Plo77).

23
The question remains whether these results hold for smaller source languages. In
some cases, affirmative results can be obtained by showing that the smaller source
languages provide enough connectives to define the general connectives of jumbo *-
calculus. In other cases--such as the one mentioned above, where the source language
is CBN without ternary sum--the answer is unknown. But it seems likely affirmative answers for various effects can be obtained from junk-freeness results for suitable
denotational semantics, such as game semantics.

7.6 Untyped Languages
The simulation results Prop. 6-9 do not make any use of types, and could be transferred
to an untyped setting. However, this appears to be of little interest. After all, an
essential part of the motivation we presented for CBPV was the idea of observing
convergence at ground type only, and this makes no sense in an untyped language.
Instead, the traditional observation in untyped CBN *-calculus, if one wishes the j-
law to be valid, is reduction to head normal form (Bar80). That is unsuited to typed
languages, e.g. it would distinguish the CBN terms *x:x and *x:diverge of type 1 ! 1,
even though they have the same denotation.

8 Complex Values and the CBPV Equational Theory
8.1 The CBPV Equational Theory
In this section, we give the CBPV equational theory, which will allow us to prove
correspondence with the categorical semantics, and to relate CBPV to Filinski's EffectPCF (Fil96).

The CBPV equational theory is the minimal congruence containing the laws in
Fig. 11 (with R ranging over computations). The laws given for print and diverge
are of course effect-specific, but there are similar laws for other effects.

The push/pop reading of CBPV sheds light on may of these laws. For example,
the fi-law for functions says: "if we push V , then pop x, then do M, that is the same
as doing M with x bound to V ". Similarly the j-law for functions says: "if we pop x,
then push x, then do M which ignores x, that is the same as doing M".

Proposition 13 (soundness of equational theory) The equations in Fig. 11 are
validated by our denotational models for divergence, printing and storage, and hence
are observational equivalences in the presence of any one of these effects.

8.2 Complex Values
The CBPV typing rules presented in Fig. 2 allow computations to be formed by patternmatching, but not values. As stated for fine-grain CBV in Sect. 2.2, this keeps the
operational semantics simple. On the other hand, certain desirable values and equations
between values are missing. For example, we can see that

1. there is no value x : 0 * 0 `v V : 0

24

We omit the assumptions necessary to make each equation well-typed. Given a
term \Gamma  ` R : B we write xR for the weakened term in the context \Gamma ; x : A where
A is some suitable type. This implies that x is not in \Gamma , because the identifiers
in a context must be distinct. We thereby obviate the need for the traditional
x 62 FV(R) conditions.

fi-laws
let V be x: R = R[V=x]
(return V ) to x: M = M[V=x]

force thunk M = M
pm h^i; V i as {hi; xi:Ri}i2I = R^i[V=x]

pm hV; V 0i as hx; yi:R = R[V=x; V 0=y]

^i`*{i:Mi}i2I = M^i

V `*x:M = M[V=x]

j-laws
M = M to x: return x

V = thunk force V
R[V=z] = pm V as hi; xi:{ xR[hi; xi=z]}i2I
R[V=z] = pm V as hx; yi: xyR[hx; yi=z]

M = *{i:i`M}i2I
M = *x:(x` xM)

sequencing laws
(P to x: M) to y: N = P to x: (M to y: xN)

P to x: *{i:Mi}i2I = *{i:(P to x: Mi)}i2I

P to x: *y:M = *y:( yP to x: M)

print laws
(print c: M) to x: N = print c: (M to x: N)

print c: *{i:Mi}i2I = *{i:print c: M}i2I

print c: *x:M = *x:print c: M

diverge laws
diverge to x: N = diverge

diverge = *{i:diverge}i2I
diverge = *x:diverge

Fig. 11 CBPV equations

2. the equation x : 0 `v true = false : 1 + 1 (where true and false abbreviate

h#l; hii and h#r; hii respectively) cannot be proved using the laws of Fig. 11.

In the remainder of the paper, we wish to prove the correspondence of CBPV with a
categorical semantics and with Effect-PCF, and, for these purposes, we have to rectify
these problems. To do so, we add complex values, whose syntax is displayed in Fig. 12.
The equational theory on CBPV with complex values is the least congruence containing
the laws of Fig. 11, with R ranging over all terms (values and computations).

More generally, we define a theory on CBPV with complex values to be a substitutive congruence containing these laws. (The least congruence is automatically substitutive.) In the sequel, o/ ranges over theories with complex values, and oe over theories
without complex values. In the latter case, we write oe+CV for the least extension of oe
to a theory with complex values. We also write `c+CV and `v+CV to indicate the syntax
and least theory of CBPV with complex values, and `c-CV and `v-CV to indicate the
syntax and least theory of CBPV without complex values.

25
\Gamma  `v V : A \Gamma ; x : A `v W : B

\Gamma  `v let V be x: W : B
\Gamma  `v V : Pi2IAi \Gamma ; x : Ai `v Wi : B (8i 2 I)

\Gamma  `v pm V as {hi; xi:Wi}i2I : B

\Gamma  `v V : A * A0 \Gamma ; x : A; y : A0 `v W : B

\Gamma  `v pm V as hx; yi:W : B

Fig. 12 Complex values

Complex values can be regarded as a minor addition to the language, in the sense
that they have no impact on computations:

Proposition 14 (complex values do not affect computations)

1. (definability) For any computation \Gamma  `c+CV M : B, there is a computation \Gamma  `c-CV

N : B such that \Gamma  `c+CV M = N : B.
2. (conservativity) Let oe be an equational theory on CBPV without complex values

(i.e. a congruence containing all the laws of Fig. 11). Let \Gamma  `c-CV N; N0 : B be
computations. Then N = N0 is in oe+CV iff N = N0 in oe.

Examples (1)-(2) show that these results do not hold for values.

Proof Following (F"uh99), we define a thunkable from \Gamma  to B to be a computation
\Gamma  `c-CV M : F B such that

\Gamma  `c-CV return thunk M = M to x: return thunk return x : F UF B (9)
Condition (9) is equivalent to the following: for any context \Gamma  `c-CV C[*] : B that does
not bind any identifiers, we have

\Gamma  `c-CV C[M] = M to x: C[return x] : B (10)
The equivalence follows from the fact that

\Gamma  `c-CV C[M] = (return thunk M) to y: C[force y] : B
It is easy to show that every safe computation, in the sense of Def. 3, is thunkable.

In Fig. 13, we define compositionally

- for each computation \Gamma  `c+CV M : B, a computation \Gamma  `c-CV ~M : B such that

\Gamma  `c+CV ~M = M : B is provable.
- for each value \Gamma  `v+CV V : B in CBPV, a safe (and hence thunkable) computation

\Gamma  `c-CV ~V : F B such that \Gamma  `c+CV ~V = return V : F B is provable.

This proves definability. For conservativity, we first show that if \Gamma  `v+CV W : A then

\Gamma  `c-CV a'\Gamma M[W=x] = ~W to x: ~M : B

\Gamma  `c-CV a'\Gamma V [W=x] = ~W to x: ~V : F B
by mutual induction on \Gamma ; x : A `c+CV M : B and \Gamma ; x : A `v+CV V : B. We deduce, by
induction, that

26

\Gamma  `c+CV M : B \Gamma  `c-CV ~M : B
let V be x: M ~V to z: let z be x: ~M
return V ~V to z: return z
M to x: N ~M to x: ~N
pm V as {hi; xi:Mi}i2I ~V to z: pm z as {hi; xi: ~Mi}i2I
pm V as hx; yi:M ~V to z: pm z as hx; yi: ~M
*{i:Mi}i2I *{i: ~Mi}i2I
^i`M ^i` ~M

*x:M *x: ~M
V `M ~V to z: z` ~M

\Gamma  `v+CV V : B \Gamma  `c-CV ~V : F B
x return x
h^i; V i ~V to z: return h^i; zi
hV; V 0i ~V to z: ~V 0 to z0: return hz; z0i
thunk M return thunk ~M
let V be x: W ~V to z: let z be x: ~W
pm V as {hi; xi:Wi}i2I ~V to z: pm z as {hi; xi: ~Wi}i2I
pm V as hx; yi:W ~V to z: pm z as hx; yi: ~W

Fig. 13 Definitions used in the proof of Prop. 14

- if \Gamma  `c+CV M = M0 : B then \Gamma  `c-CV ~M = ~M0 : B
- if \Gamma  `v+CV V = V 0 : B then \Gamma  `c-CV ~V = ~V 0 : F B

We also show that

- if \Gamma  `c-CV N : B then \Gamma  `c-CV ~N = N : B is provable
- if \Gamma  `v-CV W : B then \Gamma  `c-CV ~W = return W : F A is provable.

Given oe, we prove

- if M = M0 in oe+CV then ~M = ~M0 in oe
- if V = V 0 in oe+CV then ~V = ~V 0 in oe

by induction, and the result follows.

Prop. 14(1) enables us to "evaluate" a computation with complex values, by first
removing the complex values and then evaluating. But it should be noted that the algorithm for removal of complex values that we gave in the proof involves some arbitrary
choices, and is certainly not canonical. This is essentially the problem with complex
values, from the operational perspective: they detract from the rigid sequential nature
of the language, because they can be evaluated at any time.

Although Prop. 14 does not apply to values, we have some limited results as follows.

Proposition 15 Let \Gamma  be a context that is tuple-free, i.e. no identifier in it has P; 1; *
type. For any value \Gamma  `v+CV V : B, there exists \Gamma  `v-CV W : B such that \Gamma  `v+CV V =
W : B is provable.

Proof Fix \Gamma . Given a value \Gamma ; \Delta  `v+CV V : B, and, for each identifier (yi : B) 2 \Delta , a
value \Gamma  `v-CV Wi : B, we define, in Fig. 14, a "pseudo-substitution" \Gamma  `v-CV 'V (--!W=y) : B
such that \Gamma  `v-CV 'V (--!W=y) = V [--!W=y] : B is provable. (The penultimate clause exploits
the fact that any value \Gamma  `v-CV V : Pi2IAi must be of the form h^i; W i, rather than an

27
identifier, because \Gamma  is tuple-free. Similarly for the last clause.) Finally, given \Gamma  `v+CV
V : B, we define W to be 'V applied to the empty pseudo-substitution.

\Gamma ; \Delta  `v+CV V : B \Gamma  `v-CV 'V (--!W=y) : B
x declared in \Gamma  x
yi declared in \Delta  Wi

h^i; V i h^i; 'V (--!W=y)i
hV; V 0i h 'V (--!W=y); 'V 0(--!W=y)i

thunk M a'\Gamma M[--!W=y]
let V be x: V 0 where 'V (--!W=y) = W 'V 0(--!W=y; W=x)
pm V as {hi; xi:Vi}i2I where 'V (--!W=y) = h^i; W i 'V^i(--!W=y; W=x)
pm V as hx; x0i:V 0 where 'V (--!W=y) = hW; W 0i 'V 0(--!W=y; W=x; W 0=x0)

Fig. 14 Definitions used in the proof of Prop. 15

Definition 4 A theory oe (with or without complex values) is inconsistent when `c
return true = return false : F (1 + 1) in oe, or, equivalently, when \Gamma  `c M = N : B
is in oe for all \Gamma  `c M; N : B. (Thus values are not necessarily equated.) Otherwise it
is consistent.

Proposition 16 Closed values within a consistent theory have the following properties.

1. Let oe be a consistent theory without complex values. For closed values `c-CV W; W 0 :

B, if return W = return W 0 is in oe, then W = W 0 is in oe.
2. Let oe be a consistent theory without complex values. For closed values `v-CV W; W 0 :

B, if W = W 0 is in oe+CV, then it is in oe.
3. Let o/ be a consistent theory with complex values. For closed values `c+CV V; V 0 : B,

if return V = return V 0 is in o/, then V = V 0 is in o/.

Proof We prove these in the stated order.

1. This is by induction on W . If W has type UB, it follows from

W = thunk (return W to x: force x)
If W is h^i; V i and W 0 is h^i0; V 0i then, firstly we apply the context

[*] to z: pm z as ss h^i; xi: return truehi; xi: return false (i 6= ^i) l/
to return W = return W 0, which if ^i 6= ^i0 gives return true = return false in
oe. Since oe is consistent, we have ^i = ^i0. Then we apply the context

[*] to z: pm z as ss h^i; xi: return xhi; xi: return v (i 6= ^i) l/
to return W = return W 0, giving return V = return V 0 in oe, so V = V 0 is in oe
by the inductive hypothesis. Hence W = W 0 is in oe. The case where W is hV; V 0i
is similar.

28

2. We have return W = return W 0 in oe+CV, and hence also, by Prop. 14(2), in oe.

By Prop. 16(1), we deduce that W = W 0 is in oe.
3. Using Prop. 15, we obtain `v-CV W; W 0 : B such that `v+CV V = W : B and

`v+CV V 0 = W 0 : B are provable. Then return W = return W 0 is in o/. Since the
restriction of o/ to complex-value-free terms is consistent, Prop. 16(1) tells us that
W = W 0 is in o/, and so V = V 0 is in o/.

9 Every Model Is Equivalent to an Algebra Model
In Sect. 3, we saw how to model CBPV in an algebra-building structure, where all
exponentials to carriers are required to exist. But this requirement is too strong. If there
is a family of algebras containing all free algebras and closed under exponentiation and
finite product, then it suffices to require exponentials to carriers of algebras in this
family. We make this precise as follows.

Definition 5 A CBPV algebra-family consists of a distributive category C equipped
with a strong monad T and a (not necessarily small) family of T -algebras {KY }Y 2J--
we write KY = (UY ; fiY )--together with

free algebras for each X 2 ob C, an index F X 2 I mapped by K to the free algebra

on X
exponential algebras for each X 2 ob C and index Y 2 J, an exponential E from

X to UY in C, and an index X ! Y 2 J mapped by K to the exponential algebra
from X to KY constructed using E
product algebras for each finite family {Y i}i2I of indices, a product P for {UY i}i2I

in C, and an index Qi2IY i 2 J mapped by K to the product algebra of {KY i}i2I
constructed using P .

Clearly this gives us a model of CBPV, where a computation type denotes an index
in I, and a computation \Gamma  `c M : B denotes a C-morphism from [[\Gamma ]] to U[[B]]. Again,
thunk and force are invisible in all such models.

Remark 2 It is possible to define a "weak" notion of CBPV algebra-family where all
the algebra equations in Def. 5 are replaced by algebra isomorphisms (no coherence
conditions required). But it can be shown that every such weak model is equivalent to
a model in the sense of Def. 5.

We now show that every model of CBPV is an algebra-family. More precisely, we
construct a category of CBPV models and a category of CBPV algebra-families and
prove them equivalent. Strictly speaking, these should be 2-categories, but to skirt
2-categorical issues, we fix the object structure6.

Definition 6 (object structures)

1. A CBPV object structure o/ is a (not necessarily small) algebra for the 2-sorted

signature defining CBPV types. Thus it consists of 2 sets valtypes o/ of val-objects
and comptypes o/ of comp-objects, equipped with a binary operation * on valtypes o/,
and with similar operations for all the other CBPV connectives.

6 The price we pay for this is that the method is not at all robust. We leave to future
work the development of a robust 2-categorical treatment, where structure is preserved only
up to isomorphism. But this is a general concern in the categorical semantics of simply typed
languages, not specific to CBPV.

29
2. We write RestrAlgo/ for the category of CBPV algebra-families with object structure o/, where morphisms are identity on both val-objects and comp-objects, and
preserve all structure on the nose.

Defining the category of CBPV models, purely from the equational theory, is more
difficult. The following is a method formulated independently in (Jef99; Lev96), which
is applicable to many simply typed calculi.

Definition 7 Let o/ be a CBPV object structure.

1. A o/-sequent Q is either

A0; : : : ; An-1 `v B or A0; : : : ; An-1 `c B
where A0; : : : ; An-1 and B are value objects in o/ and B is a computation object
in o/.
2. A o/-signature s is a function from o/-sequents to sets.
3. We write Sigo/ for the category of o/-signatures, where a morphism from s to s0

provides a function from s(Q) to s0(Q) for each o/-sequent Q.

It is clear that, to model CBPV, one must first give a CBPV object structure o/ and then
a o/-multigraph s. This much allows us to interpret types and judgements, although it
still remains to describe the semantics of term constructors.

Definition 8 Let o/ be a CBPV object structure. We define a monad T on Sigo/ as
follows. Let s be a o/-signature. We inductively define another o/-signature called the
terms built from the signature s, using the rules of Fig. 2 and Fig. 12 together with the
rules \Gamma  `v V

0 : A0 * * * \Gamma  `

v Vr

-1 : Ar-1

\Gamma  `v f(V0; : : : ; Vr-1) : B f 2 s (A0; : : : ; A

r-1 `

v B)

\Gamma  `v V0 : A0 * * * \Gamma  `v Vr-1 : Ar-1

\Gamma  `c f(V0; : : : ; Vr-1) : B f 2 s (A0; : : : ; A

r-1 `

c B)

We define T s to be this signature (mapping each sequent to the terms inhabiting
it) quotiented by the congruence generated by the equations of Fig. 11. The unit js
takes each operation f 2 s (A0; : : : ; Ar-1 `v B) to f(x0; : : : ; xr-1), and similarly for
values. The multiplication us is defined by induction over terms in T 2s. In particular,
it maps M(V0; : : : ; Vn-1), where M is a term in T s and hence an operation in T 2s, to

M[-------!(us)Vj=xj], and it preserves all other term constructors.

Definition 9 A direct model of CBPV consists of a CBPV object structure o/ together
with an algebra (s; `) for the monad T on Sigo/ . If o/ is a CBPV object structure, we
write Directo/ for the category of T -algebras and algebra homomorphisms.

We can now state our main theorem.
Proposition 17 Let o/ be a CBPV object structure. Then the categories Directo/ and
RestrAlgo/ are equivalent.

We omit the detailed proof of this, but give an overview. Mapping RestrAlgo/ to
Directo/ essentially says that a CBPV algebra family gives a model of CBPV, validating
all the laws. In the other direction, if we have a model of CBPV, then the semantics

30
of values is a model of the simply typed *-calculus with * and P types, hence a
distributive category C. We obtain a monad by setting T to be UF , and the unit of
the monad jA is given by

x : A `v thunk return x : UF A
For each comp-object B, the algebra KB is defined to have carrier UB and structure
fiB, defined by the term

x : UF UB `v thunk (force x to y: force y) : UB
and this determines the multiplication: uA = fiF A.

As an instance of this construction, the behaviour semantics of storage (Sect. 6.2)
is equivalent to a CBPV algebra family, which is a sub-model of the algebra semantics
in Sect. 6.1. This fact enables us to deduce Prop. 4 from Prop. 5.

10 Comparison with Filinski's Monadic Metalanguage and Marz's SFPL
Having treated complex values in some detail, we are in a position to look closely at
the relationship between

- CBPV
- Effect-PCF, a version of the monadic metalanguage appearing in (Fil96)
- SFPL (Mar00), a variant of the earlier language SFL (Mar98).

We treat Effect-PCF in detail, because the relationship between CBPV and monads
is a central theme of this paper; but we treat SFPL in outline only. We omit recursive
types, as these are beyond the scope of this paper. The non-recursive types and the
judgements of the two languages are given7 in Fig. 15. The syntax of Effect-PCF is
given in Fig. 16. We have modified syntax slightly to agree with CBPV, in particular
using M to x: N for sequencing in Effect-PCF.

It is quite easy to see that if we take the types of CBPV and erase U, so that
computation types are a subset of value types, we obtain the types of Effect-PCF. On
the other hand, if we erase F , so that value types are a subset of computation types, we
obtain the types of SFPL. This erasure can be explained by the denotational semantics
each author was considering:

- Filinski was considering carrier semantics where a computation type B denotes a

carrier of an algebra, rather than the whole algebra, and therefore U is invisible.
- Marz was considering lifted cpo semantics where a value type A denotes a pointed

cpo, the lift of what A denotes in our cpo semantics. Thus a computation A0; : : : ; An-1 `c
M : B denotes a strict function from [[A0]] \Omega  * * * \Omega  [[An-1]] to [[B]]. This semantics
uses smash product and coalesced sum of cppos, and strict function spaces. Most
importantly, F is invisible.

The translation - from CBPV value (resp. computation) types to Effect-PCF value
(resp. computation) types are defined by induction:

UB = B

F A = T A
7 Caution: (Mar00) uses the phrase "computational types" for what we have called the
"value types" of SFPL.

31
Effect-PCF

value types A ::= B | Pi2IAi | 1 | A * A
computation types B ::= T A | Qi2IBi | A ! B

judgement A0; : : : ; An-1 ` B
SFPL

value types A ::= B? | Li2IAi | 1\Omega  | A \Omega  A
computation types B ::= A | Qi2IBi | A -ffi B

judgement A0; : : : ; An-1 ` B

Fig. 15 Types and judgements of Effect-PCF and SFPL

Primitives

\Gamma ; x : A; \Gamma 0 ` x : A

\Gamma  ` M : A \Gamma ; x : A ` N : B

\Gamma  ` let M be x: N : B
\Gamma  ` M : A
\Gamma  ` return M : T A

\Gamma  ` M : T A \Gamma ; x : A ` N : T B

\Gamma  ` M to x: N : T B
\Gamma  ` M : A^i
\Gamma  ` h^i; Mi : Pi2IAi

\Gamma  ` M : Pi2IAi \Gamma ; x : Ai ` Ni : B (8i 2 I)

\Gamma  ` pm M as {hi; xi:Ni}i2I : B

\Gamma  ` M : A \Gamma  ` M0 : A0

\Gamma  ` hM; M0i : A * A0

\Gamma  ` M : A * A0 \Gamma ; x : A; y : A0 ` N : B

\Gamma  ` pm M as hx; yi:N : B

\Gamma  ` Mi : Bi (8i 2 I)
\Gamma  ` *{i:Mi}i2I : Qi2IBi

\Gamma  ` N : Qi2IBi

\Gamma  ` ^i`N : B^i

\Gamma ; x : A ` M : B
\Gamma  ` *x:M : A ! B

\Gamma  ` M : A \Gamma  ` N : A ! B

\Gamma  ` M`N : B

Derived \Gamma  ` M : T A \Gamma ; x : A ` N : B

\Gamma  ` M to x:B N : B
This is defined by induction on B.

M to x:TA N = M to x: N
M to x:Qi2IBi N = *{i:(M to x:Bi (i`N))}i2I

M to x:A!B N = *y:(M to x:B (y`N))

Fig. 16 Terms of Effect-PCF (slightly modified)

32
and all the other clauses are trivial. The translations e- from Effect-PCF value types to
CBPV value types, and b- from Effect-PCF computation types to CBPV computation
types are defined by mutual induction:

eB = U bBO'
T A = F eA

and all the other clauses are trivial. It is obvious that - on value types is inverse to e-,
and - on computation types is inverse to b-. In the same way, we can define a bijection
between CBPV value (resp. computation) types and SFPL value (resp. computation)
types.

A0; : : : ; An-1 ` M : B fA0; : : : ; fiAn-1 `v+CV U"M : eB

x x
let M be x: N let U"M be x: eN

h^i; Mi h^i; U"Mi
pm M as {hi; xi:Ni}i2I pm U"M as {hi; xi: U"Ni}i2I

hM; M0i h U"M; fM0i
pm M as hx; yi: N pm U"M as hx; yi: eN

return M thunk return U"M
M to x: N thunk ((force U"M) to x: force eN)

*x:M thunk *x: force U"M

N`M thunk ( eN`force U"M)
*{i:Mi}i2I thunk *{i: force fMi}i2I

^i`M thunk (^i`force U"M)

Fig. 17 Translation from Effect-PCF terms to CBPV values

Proceeding to terms, the sole judgement of Effect-PCF corresponds to `v in CBPV.
Hence we translate every Effect-PCF term into a CBPV value, as shown in Fig. 17.
This translation preserves provable equality. Moreover, the equationa*\Gamma 

M to x:B N = thunk ((force U"M) to x: force U"N)
is provable in the equational theory with complex values; this is shown by induction
on the type B of N.

In the opposite direction, we define a translation - taking

- a value A0; : : : ; An-1 `v V : B in CBPV with complex values to a term A0; : : : ; An-1 `

V : B in Effect-PCF
- a computation A0; : : : ; An-1 `c M : B in CBPV with complex values to a term

A0; : : : ; An-1 ` M : B in Effect-PCF

by induction:

thunk M = M

force V = V
M to x: N = M to x:B N where B is the type of N

33
and all the other clauses are trivial. This preserves provable equality, because the
analogues of all the CBPV laws are provable in Effect-PCF (using induction over types
for the sequencing laws).

Finally we prove

- for any Effect-PCF term \Gamma  ` M : B, the equation \Gamma  ` U"M = M : B is provable
- for any CBPV value \Gamma  `v+CV V : A, the equation \Gamma  `v+CV eV = V : B is provable

- for any CBPV computation \Gamma  `c+CV M : B, the equation \Gamma  `c+CV force U"M = M : B

is provable.

by induction on the terms. Hence the translations reflect provable equality.

As for SFPL, its sole judgement corresponds to `c in CBPV. The relationship
between CBPV and SFPL terms is somewhat similar to the above, although not as
tight. We omit details.

11 Conclusions
We summarize the advances represented by call-by-push-value.

Firstly, the explicit writing of U allows us to give a compositional account of CBN,
because a computation type denotes an algebra.

Secondly, CBPV makes explicit the thunking isomorphism, which is invisible from
the monadic viewpoint, but apparent in the behaviour semantics of Sect. 6.2.

Thirdly, we see a simple decomposition of CBN and CBV models for the first time.
In particular, O'Hearn's behaviour semantics of CBN (O'H93), where A !CBN B
denotes (S ! [[A]]) ! [[B]] previously appeared strange, but now can be understood
using the decomposition of A !CBN B into UA ! B and the behaviour semantics
of CBN. A similar example is the continuation semantics of (SR98), although we have
not treated it in this paper.

Fourthly, we have a straightforward operational semantics for CBPV (unlike EffectPCF, but like MIL-lite), and the translations from CBN and CBV into it are fully
abstract. Admittedly, the operational semantics is defined only for complex-value-free
terms, but we proved that every computation is equal (in the theory) to one of this
form.

Fifthly, we have a machine reading of CBPV (the CK-machine) that makes it clear
why a function type should be regarded as a computation type, a classification that
was present in Effect-PCF but not understood in a computational way.

As stated in Sect. 1.1, this paper is an introduction to CBPV, not an exhaustive
study. In particular, the relationship between CBPV and adjunctions (Lev03; Lev05)
is not investigated in this paper. However, in the particular models we have studied, it
is quite apparent that U and F represent an adjunction.

- The monad/algebra semantics uses an Eilenberg-Moore adjunction between C and

CT (algebras and algebra homomorphisms).
- The behaviour semantics uses the adjunction between Set and Set with left adjoint

S * - and right adjoint S ! -.

We leave to future work the development of this theory--much more can be found
in (Lev04). Furthermore, it remains to compare this work to the line of research
in (Lau99; Sel01); this is closely related to continuation semantics, which we have
not included in this paper.

34
Acknowledgements
I am grateful to Peter O'Hearn, the reviewers and numerous other people for discussion
on this material.

References

Abr90. S. Abramsky. The lazy *-calculus. In Research topics in Functional Programming,

pages 65-117. Addison Wesley, 1990.
Bar80. H. Barendregt. The Lambda-Calculus: Its Syntax and Semantics. North-Holland,

Amsterdam, 1980.
BHM00. Nick Benton, John Hughes, and Eugenio Moggi. Monads and effects. In Gilles Barthe,

Peter Dybjer, Luis Pinto, and Jo~ao Saraiva, editors, Advanced Lectures From International Summer School on Applied Semantics (APPSEM), Caminha, Portugal,
volume 2395 of Lecture Notes in Computer Science, pages 42-122, 2000.
BK99. Nick Benton and Andrew Kennedy. Monads, effects and transformations. In Andrew

Gordon and Andrew Pitts, editors, Proceedings, Higher-Order Operational Techniques in Semantics (HOOTS '99), volume 26 of ENTCS, pages 3-20, Paris, France,
1999.
BW96. N. Benton and P. Wadler. Linear logic, monads and the lambda calculus. In Proceedings, 11th Annual IEEE Symposium on Logic in Computer Science, pages 420-431,
New Brunswick, New Jersey, 1996. IEEE Computer Society Press.
FF86. M. Felleisen and D. Friedman. Control operators, the SECD-machine, and the *-

calculus. In M. Wirsing, editor, Formal Description of Programming Concepts III,
pages 193-217. North-Holland, 1986.
Fil96. A. Filinski. Controlling Effects. PhD thesis, School of Computer Science, Carnegie

Mellon University, Pittsburgh, Pennsylvania, 1996.
F"uh99. Carsten F"uhrmann. Direct models for the computational *-calculus. In S. Brookes,

A. Jung, M. Mislove, and A. Scedrov, editors, Proceedings of the 15th Conference in
Mathematical Foundations of Programming Semantics, New Orleans, volume 20 of
ENTCS, pages 147-172, 1999.
Hat94. John Hatcliff. The Structure of Continuation-Passing Styles. PhD thesis, Kansas

State University, June 1994.
HD97. J. Hatcliff and O. Danvy. Thunks and the *-calculus. Journal of Functional Programming, 7(3):303-319, May 1997.
How96. Brian Howard. Inductive, coinductive, and pointed types. In Proceedings of the

ACM SIGPLAN International Conference on Functional Programming (ICFP '96),
volume 31(6) of ACM SIGPLAN Notices, pages 102-109. ACM, June 1996.
Jef99. A. Jeffrey. A fully abstract semantics for a higher-order functional language with nondeterministic computation. Theoretical Computer Science, 228(1-2):105-150, 1999.
Kri85. J.-L. Krivine. Un interpr'eteur de *-calcul. Unpublished, 1985.

Lai98. J. Laird. A Semantic Analysis of Control. PhD thesis, University of Edinburgh,

1998.
Lau99. Olivier Laurent. Polarized proof-nets: proof-nets for LC (extended abstract). In

Jean-Yves Girard, editor, Typed Lambda Calculi and Applications '99, L'Aquila,
Italy, volume 1581 of Lecture Notes in Computer Science, pages 213-227. Springer,
April 1999.
Lev96. P. B. Levy. *-calculus and cartesian closed categories. Essay for Part III of the

Mathematical Tripos, Cambridge University, 1996.
Lev99. P. B. Levy. Call-by-push-value: a subsuming paradigm (extended abstract). In J.-Y

Girard, editor, Proceedings, Typed Lambda-Calculi and Applications, L'Aquila, Italy,
volume 1581 of LNCS, pages 228-242. Springer, 1999.
Lev02. P. B. Levy. Possible world semantics for general storage in call-by-value. In J. Bradfield, editor, Proceedings, 16th Annual Conference of the European Assocation for
Computer Science Logic (CSL), volume 2471 of LNCS, pages 232-246. Springer,
2002.
Lev03. P. B. Levy. Adjunction models for call-by-push-value with stacks. In R. Blute and

P. Selinger, editors, Proceedings, 9th Conference on Category Theory and Computer

35
Science, Ottawa, 2002, volume 69 of Electronic Notes in Theoretical Computer Science, 2003.
Lev04. P. B. Levy. Call-By-Push-Value. A Functional/Imperative Synthesis. Semantic

Structures in Computation. Springer, 2004.
Lev05. P. B. Levy. Adjunction models for call-by-push-value with stacks. Theory and Applications of Categories, 14:75-110, 2005.
Lev06. P. B. Levy. Jumbo *-calculus. In Proceedings, 33rd International Colloquium on

Automata, Languages and Programming, volume 4052 of LNCS, pages 444-455.
Springer, 2006.
Mar98. Michael Marz. A fully abstract model for sequential computation. Technical Report

CSR-98-6, University of Birmingham, School of Computer Science, September 1998.
Mar00. M. Marz. A Fully Abstract Model for Sequential Computation. PhD thesis, Technische Universit"at Darmstadt, 2000. published by Logos-Verlag, Berlin.
Mog89. E. Moggi. Computational lambda-calculus and monads. In Proceedings, 4th Annual

Symposium on Logic in Computer Science, Pacific Grove, California, pages 14-23.
IEEE, 1989.
Mog91. E. Moggi. Notions of computation and monads. Information and Computation,

93:55-92, 1991.
O'H93. P. W. O'Hearn. Opaque types in algol-like languages. Manuscript, 1993.
Ong88. C. H. L. Ong. The Lazy Lambda Calculus: An Investigation into the Foundations of

Functional Programming. PhD thesis, Imperial College of Science and Technology,
1988.
Plo75. G. D. Plotkin. Call-by-name, call-by-value and the *-calculus. Theoretical Computer

Science, 1(1):125-159, 1975.
Plo77. G. D. Plotkin. LCF considered as a programming language. Theoretical Computer

Science, 5:223-255, 1977.
PS98. A. M. Pitts and I. D. B. Stark. Operational reasoning for functions with local state.

In A. D. Gordon and A. M. Pitts, editors, Higher Order Operational Techniques in
Semantics, Publications of the Newton Institute, pages 227-273. Cambridge University Press, 1998.
Sel01. P. Selinger. Control categories and duality: On the categorical semantics of the

*u-calculus. Mathematical Structures in Computer Science, 11(2):207-260, 2001.
SR98. Th. Streicher and B. Reus. Classical logic, continuation semantics and abstract

machines. Journal of Functional Programming, 8(6):543-572, 1998.
Tai67. W. W. Tait. Intensional interpretation of functionals of finite type I. Journal of

Symbolic Logic, 32(2):198-212, June 1967.
Win93. G. Winskel. Formal Semantics of Programming Languages. MIT Press, 1993.

Appendix
We give here the proof of termination (for CBPV without recursion) and that computations denoting ? diverge (for CBPV with recursion). Both of these are adaptations
of standard arguments based on the method of (Tai67).

Here is the proof of Prop. 1.

Proof Determinism is trivial in every case. For termination, we use a Tait-style proof.
Here it is for storage; the other proofs are similar. We define

- for each value type A, a set redA of closed values of type A
- for each computation type B, a set redB of pairs s; M where s 2 S and M is a

closed computation of type B

36
The definition of these subsets proceeds by induction over types:

thunk M 2 redUB iff s; M 2 redB for all s 2 S
h^i; V i 2 redPi

2IAi iff V 2 redA^ihV; V 0i 2

redA*A0 iff V 2 redA and V 0 2 redA0

s; M 2 redFA iff s; M + s0; return V where V 2 redA
s; M 2 redQi

2IBi iff s; M + s

0; *{i:Mi}i2I where i 2 I implies s0; Mi 2 redB

i

s; M 2 redA!B iff s; M + s0; *x:N where V 2 redA implies s0; M[V=x] 2 redB

We note that s; M 2 redB iff s; M + s0; T for some s0; T 2 redB.

Finally we show that for any computation A0; : : : ; An-1 `c M : B, if s 2 S and

Wi 2 redAi for i = 0; : : : ; n - 1 then s; M[----!Wi=xi] 2 redB; and similarly for any value
A0; : : : ; An-1 `v V : A. This is shown by mutual induction on M and V , and gives the
required result.

Here is the proof of Prop. 2.

Proof These are all proved by induction on +, except the clause about divergence which
requires a Tait-style proof. We define

- for each value type A, a relation 6A between [[A]] and closed values of type A such

that, for each V , the set {a | a 6A V } is admissible and down-closed
- for each computation type B a relation 6B between [[B]] and closed computations

of type B, such that, for each M, the set {a | a 6B M} is admissible, down-closed
and ?-containing.

(Our proof does not make use of the down-closure property.) The definition of these
relations proceeds by induction over types:

a 6UB thunk M iff a 6B M
a 6Pi

2I Ai h^i; V i iff a = h^i; bi for some b 6A^i Va 6

A*A0 hV; V

0i iff a = hb; b0i for some b 6A V and b0 6A

0 V 0

b 6F A M iff b = ? or

b = up a and M + return V and a 6A V
f 6Qi

2I Bi M iff f = ? orM + *{i:N

i}i2I; and i 2 I implies f^i 6Bi Ni
f 6A!B M iff f = ? or

M + *x:N; and a 6A V implies fa 6B N[V=x]

We note that b 6B M iff either b = ? or M + T for some terminal T such that b 6B T .

Finally, we show that for any computation A0; : : : ; An-1 `c M : B, if ai 6Ai

Wi for i = 0; : : : ; n - 1 then [[M]]-----!xi 7! ai 6B M[----!Wi=xi]; and similarly for any value
A0; : : : ; An-1 `v V : A. This is shown by mutual induction on M and V , and gives the
required result.