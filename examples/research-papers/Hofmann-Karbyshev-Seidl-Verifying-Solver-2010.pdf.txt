

Verifying a Local Generic Solver in Coq

Martin Hofmann1, Aleksandr Karbyshev2, and Helmut Seidl2

1 Institut fl'ur Informatik, Universitl'at Ml'unchen

hofmann@ifi.lmu.de
2 Fakultl'at fl'ur Informatik, Technische Universitl'at Ml'unchen

{aleksandr.karbyshev,seidl}@in.tum.de

Abstract. Fixpoint engines are the core components of program analysis tools and compilers. If these tools are to be trusted, special attention should be paid also to the correctness of such solvers. In this
paper we consider the local generic S,xpoint solver RLD which can be
applied to constraint systems x \Theta  fx, x \Lambda  V , over some lattice D where
the right-hand sides fx are given as arbitrary functions implemented in
some speciS,cation language. The veriS,cation of this algorithm is challenging, because it uses higher-order functions and relies on side effects
to track variable dependences as they are encountered dynamically during S,xpoint iterations. Here, we present a correctness proof of this algorithm which has been formalized by means of the interactive proof
assistant Coq.

1 Introduction
A generic solver computes a solution of a constraint system x \Theta  fx, x \Lambda  V , oversome lattice D, where the right-hand side

fx of each variable x is given as afunction of type (
V \Xi  D) \Xi  D implemented in some programming language.A local generic solver, when started with a set

X \Pi  V of interesting variables,tries to determine the values for the
X of a solution of the constraint system bytouching as few variables as possible.

Local generic solvers are a convenient tool for the implementation of efficientframeworks for program analyses. They have S,rst been proposed for the analysis of logic programs [3, 5, 6, 7] and model-checking [10], but recently have alsoattracted attention in interprocedural analyzers of imperative programs [1, 14].
One particularly simple instance RLD of a local generic solver has been includedinto the textbook on Program Analysis and Optimization [15], although without
any proof of correctness of the algorithm.Efficient solvers for constraint systems exploit that often right-hand side functions query the current variable assignment only for few variables. A genericsolver, however, must consider right-hand sides as black boxes which cannot be
preprocessed for variable dependences before-hand. Therefore, efficient genericsolvers rely on self-observation to detect and record variable dependences on-theT^y during evaluation of right-hand sides. The local generic solver TD by vanHentenryck [3] as well as the solver

RLD add a recursive descent into solving

R. Cousot and M. Martel (Eds.): SAS 2010, LNCS 6337, pp. 340-355, 2010.

c\Theta  Springer-Verlag Berlin Heidelberg 2010

Verifying a Local Generic Solver in Coq 341
variables before reporting their values. Both self-observation through side-effectsand the recursive evaluation make these solvers intricate in their operational behavior and therefore their design and implementation are error-prone.In fact, during experimentation with tiny variations of the solver RLD we
found that many seemingly correct algorithms and implementations are bogus.In view of the application of such solvers in tools for deriving correctness properties, possibly of safety critical systems, it seems mandatory to us to have fullconS,dence into the applied software.

The S,rst issue in proving any generic solver correct is which kind of functionssafely may be applied as right-hand sides of constraints. In the companion paper [8] we therefore have presented a semantical property of purity. The notion ofpurity is general enough to allow any function expressed in a pure functional language without recursion, but also allows certain forms of (well-behaved) statefulcomputation. Purity of a function

f allows f to be represented as a strategy tree.This means that the evaluation of
f on a variable assignment \Theta  can be consideredas a sequence of variable look-ups followed by local computations and ending in

an answer value.It is w.r.t. this representation that we prove the local generic solver RLD
correct. Related formal correctness proofs have been provided for variants ofKildallR^s algorithm for dataT^ow analysis [13, 11, 2, 4] This S,xpoint algorithm is
neither generic nor local. It also exploits variable dependences which, however,are explicitly given through the control-T^ow graph.

All theorems and proofs are formalized by means of the interactive theoremprover

Coq [12].

2 The Local Generic Solver RLD
One basic idea of the algorithm RLD is that, as soon as the value of variabley is requested during reevaluation of the right-hand side

fx, the algorithm doesnot naively return the current value for
y. Instead, it S,rst tries to get a betterapproximation of it, thus reducing the overall number of iterations and computations performed. This idea is similar to that of the algorithm TD.Both algorithms also record the variable dependencies (

x, y) (w.r.t. the cur-rent variable assignment) as they are encountered during evaluation of the righthand side fx as a side-effect. The main difference between the two algorithmslies in how they behave when a variable

x changes its value. While the algorithmTD recursively destabilizes all variables which also indirectly depend on x, the

algorithm RLD only destabilizes the variables which immediately (locally) areinT^uenced by

x, and triggers the reevaluation of these variables at once.The algorithm RLD maintains the following data structures.

1. Finite map \Theta , storing current values of variables. We track only S,nite numberof observed variables, since the overall size of set

V can be tremendouslylarge. We deS,ne the auxiliary function

342 M. Hofmann, A. Karbyshev, and H. Seidl

\Theta \Lambda  x = \Theta \Theta  x if x \Lambda  dom(\Theta ),\Sigma  otherwise
that returns a current value of \Theta  x if it is deS,ned; otherwise, it returns \Sigma .2. Finite set stable \Pi 

V . Intuitively, if variable x is marked as stable then either
x is already solved, i.e., a computation for x has completed and \Theta  gives asolution for x and all those variables x transitively depends on, or x is called

and it is in the call stack of solve function and its value is being processed.3. Finite map inT^, where dependencies between variables are stored. More exactly, inT^ x returns an overapproximation of a set of variables y, for whichevaluation of

fy on the current \Theta \Lambda  depends on x. Again, we track only S,nitenumber of observed variables and deS,ne the auxiliary function

inT^[ ] x = \Theta inT^ x if x \Lambda  dom(inT^),[ ] otherwise.
The structures have initial values: \Theta  = \Upsilon , stable = \Upsilon , inT^ = \Upsilon .The algorithm

RLD proceeds as follows (see Fig. 1). The function solve allis called for a list

X of interesting variables from the initial state (with \Theta  = \Upsilon ,stable = \Upsilon , inT^ = \Upsilon ). The function

solve all calls recursively solve x for every
x \Lambda  X.The function

solve when called for some variable x S,rst checks whether xis already in the set stable. If so, the function returns; otherwise, the algorithm

marks x as being stable and tries to satisfy a constraint \Theta  x \Theta  fx \Theta . For that,it reevaluates a value of the right-hand side

fx, and calculates the least upperbound new of the result together with the old value of

\Theta  x. If the value of new isstrictly larger than the old value, the function
solve updates the value of \Theta  forx. Since the value of
\Theta  x has changed, all constraints of variables y dependenton
x may not be satisS,ed anymore. Hence the function solve destabilizes allthe variables from work = inT^

[ ] x, i.e., subtracts work from the set stable. Thenvalue inT^ x is reset to empty and solve all work is recursively called.

We mention, that the right-hand side fx is not evaluated directly on the func-tion

\Theta , but by using an auxiliary stateful function \Lambda y.eval(x,y), allowing S,rstlyto get better values for variables the variable

x depends on. Once eval(x,y) iscalled, it S,rst calls
solve y and then adds x to inT^ y. The latter reT^ects the factthat the value of x possibly depends on the value of y. Only after recording the

variable dependence (x, y), the current value of y is returned.Our goal is to prove that the algorithm

RLD is a local generic solver for any(possibly inS,nite) constraint system S = (

V, f ) where right-hand sides fx arepure.

3 Systems of Constraints
Instead of reasoning about an algorithm which modiS,es a global state by side-effecting functions as in Fig. 1, we prefer to reason about the denotational semantics of such an algorithm, i.e., about the corresponding purely functionalprogram where the global state is explicitly threaded through the program.

Verifying a Local Generic Solver in Coq 343
function eval(x : V , y : V ) =

solve(y);

infl y \Xi  infl y \Pi  -x"";
\Theta \Theta  y

function eval rhs(x : V ) =

fx(\Lambda y.eval(x, y))

function extract work(x : V ) =

let work = infl[ ] x in

stable \Xi  stable \ work; infl x \Xi  [ ];
work
function solve(x : V ) =

if x \Lambda  stable then ()
else

stable \Xi  stable \Pi  -x"";
let cur = eval rhs(x) in
let new = \Theta \Theta  x \Sigma  cur in
if new \Upsilon  \Theta \Theta  x then ()
else\Theta  x \Xi  new;

let work = extract work(x) in
solve all(work )
end

end

function solve all(work : 2V ) =

foreach x \Lambda  work do solve(x)

begin

\Theta  = \Phi ; stable = \Phi ; infl = \Phi ;
solve all(X );
(\Theta \Theta , stable)
end

Fig. 1. The recursive solver tracking local dependencies (RLD)

Assume D = (D, \Phi , \Psi ) is a lattice consisting of the carrier D equipped withthe partial ordering \Psi  and the least upper bound operation \Phi . A pair (

V, f ) isa constraint system, where
V is a set of variables and f is a functional of type

f : V \Xi  (V \Xi  MD) \Xi  MD,
that for every x \Lambda  V returns a corresponding right-hand side fx : (V \Xi  MD) \Xi M

D. Here, the monad constructor M when applied to a set D, returns a com-putation resulting in a value from

D. In our application, we assume MD to be astate transformer monad deS,ned by

S \Xi  (D * S) for some set S of states where
f is assumed to be polymorphic in S.This means that right-hand sides may have side effects onto the global state

and that they can be applied to variable assignments whose evaluation them-selves may have side effects. What we assume, however, is that the side effects

344 M. Hofmann, A. Karbyshev, and H. Seidl
of the evaluation of a call fx \Theta  only are attributed to side-effects incurred by theevaluation of the function

\Theta . This property is not captured by polymorphism ina state alone [8]. It is guaranteed, however, by the notion of purity introduced

in [8]. If the function fx is pure in the sense of [8], then fx is representable bymeans of a strategy tree. This means that the evaluation of

fx on a variableassignment consists of a sequence of variable look-ups followed by some local

computation leading to further look-ups and so on until eventually a result isproduced.

3.1 Strategy Trees
Definition 1. For a given set of values D and a set of variables V we deS,nethe set T (

V, D) of strategy trees inductively by:

- if a \Lambda  D then Answ(a) \Lambda  T (V, D);
- if x \Lambda  V and c : D \Xi  T (V, D) is a total function then Quest(x, c) \Lambda  T (V, D).

Let \Xi  be a mapping from V \Xi  MD. By means of the monad operations return :
D \Xi  MD and bind : MD \Xi  (D \Xi  MD) \Xi  MD we deS,ne the function\Theta 

u*\Lambda  : T (V, D) \Xi  (V \Xi  MD) \Xi  MD
recursively by: \Theta 

Answ(a)\Lambda  \Xi  = return a ,\Theta 
Quest(x, c)\Lambda  \Xi  = bind (\Xi  x) (fun a \Xi  \Theta c a\Lambda  \Xi ) .

Recall that for state transformer monads, the monad operations return : D \Xi M

D and bind : MD \Xi  (D \Xi  MD) \Xi  MD are deS,ned by:

return a = fun s \Xi  (a, s) ,
bind m f = fun s \Xi  let (a, s1) = m s in f a s1 .

Therefore, the function \Theta u*\Lambda  is given by:\Theta 

Answ(a)\Lambda  \Xi  = fun s \Xi  (a, s) ,\Theta 
Quest(x, c)\Lambda  \Xi  = fun s \Xi  let (a, s1) = \Xi  x s in \Theta c a\Lambda  \Xi  s1 .

The evaluation of a strategy tree thus formalizes the stateful evaluation of thepure function represented by this tree.

Moreover, if \Xi  does not depend on the state and has no effect on the state,i.e., is of the form

\Xi  = return \Omega  \Theta  = fun x \Xi  return (\Theta  x)
for some function \Theta  : V \Xi  D, then for all states s and trees r \Lambda  T (V, D)\Theta 

r\Lambda  \Xi  s = (a, s)

Verifying a Local Generic Solver in Coq 345
holds, for some a \Lambda  D. Therefore, we deS,ne the function\Theta 

u*\Lambda * : T (V, D) \Xi  (V \Xi  D) \Xi  D
by: \Theta 

r\Lambda * \Theta  = fst(\Theta r\Lambda  (return \Omega  \Theta ) ()) .

In our application, the solver not only evaluates pure functions, i.e., strategytrees, but also records the variables accessed during this evaluation. In order

to reason about the sequence of accessed variables together with their values,we instrument the evaluation of strategy trees by additionally taking a list of
already visited variables together with their values and returning updated listfor the rest computations. For the state transformer monad this instrumented
evaluation is deS,ned by:\Theta 

Answ(a)\Lambda \Pi  \Xi  l = return (a, l) ,\Theta 
Quest(x, c)\Lambda \Pi  \Xi  l = bind (\Xi  x) (fun a \Xi  \Theta c a\Lambda \Pi  \Xi  (l @ [(x, a)])) ,

or, again instantiated for state transformer monads,\Theta 

Answ(a)\Lambda \Pi  \Xi  l = fun s \Xi  ((a, l), s) ,\Theta 
Quest(x, c)\Lambda \Pi  \Xi  l = fun s \Xi  let (a, s1) = \Xi  x s in \Theta c a\Lambda \Pi  \Xi  (l @ [(x, a)]) s1 ,

where l : (V * D) list.Then for every strategy tree

r, mapping \Xi  : V \Xi  MD and list l1 : (V *D) list\Theta 

r\Lambda  \Xi  s = (a, s\Pi ) iff \Theta r\Lambda \Pi  \Xi  l1 s = ((a, l2), s\Pi ) ,
for some a \Lambda  D and l2 : (V * D) list. Moreover, if \Xi  = return \Omega  \Theta  for some
\Theta  : V \Xi  D, then for all states s\Theta 

r\Lambda \Pi  \Xi  [ ] s = ((a, l), s)
holds, for some a \Lambda  D and l : (V * D) list.Now assume that we are given a mapping

t : V \Xi  T (V, D). Relative to thismapping and an assignment
\Theta  : V \Xi  D we deS,ne

trace\Theta  r = l , where \Theta r\Lambda \Pi  (return \Omega  \Theta ) [ ] () = (( , l), ), r \Lambda  T (V, D) ,
dept,\Theta  x = -y -- (y, ) \Lambda  trace\Theta (t x)"" .

Moreover, we deS,ne dept,\Theta (X) = \Lambda x\Sigma X dept,\Theta  x. Intuitively, the function dept,\Theta applied to a variable

x and a variable assignment \Theta  returns a set of variables thatx directly depends on relative to

\Theta , i.e., a set of those variables which values arerequired to evaluate the strategy tree for the right-hand side of

x. The relation

Dept,\Theta  = -(x, y) -- y \Lambda  dept,\Theta  x""
is also called a dependence graph for the variable assignment \Theta . Let Dep+t,\Theta  be
a transitive closure of the relation Dept,\Theta  and Dep*t,\Theta  = Dep+t,\Theta  ff -(x, x) -- x \Lambda 
V "" be a reT^exive and transitive closure of Dept,\Theta  and denote dep*t,\Theta  x = -y --
Dep*t,\Theta (x, y)"" and dep*t,\Theta (X) = \Lambda x\Sigma X dep*t,\Theta  x.

346 M. Hofmann, A. Karbyshev, and H. Seidl
3.2 Solutions
Definition 2. Let S = (V, f ) be a constraint system over the lattice D and X \Pi 
V . We say that a variable assignment \Theta  : V \Xi  D is a solution of the constraintsystem S, if for every

x \Lambda  V , \Theta  x \Theta  d whenever (d, ()) = fx(return \Omega  \Theta ) () holds.For the latter statement, we also write

\Theta  x \Theta  fx \Theta .

Definition 3. A partial function

A : (V \Xi  T (V, D)) * 2V \Xi  (V \Xi  D) * 2V
is (the denotational semantics of) a local solver if it takes as input a pair (t, X)of a strategy function

t and a set X \Pi  V of interesting variables and, whenever itterminates, returns a pair (

\Theta , X\Pi ) consisting of a variable assignment \Theta  : V \Xi  Dtogether with a set
X\Pi  \Pi  V such that the following holds:

1. X \Pi  X\Pi  and dep*t,\Theta (X\Pi ) \Pi  X\Pi ;2.

\Theta  x \Theta  \Theta t x\Lambda * \Theta  holds for every x \Lambda  X\Pi .

In particular, this means that \Theta  restricted to X\Pi  is a solution of the constraintsystem (

X\Pi , f --X\Theta ).

4 Functional Implementation with Explicit State Passing
In the functional implementation of algorithm RLD, the global state is madeexplicit, and passed into function calls by means of a separate parameter. Accordingly, the modiS,ed state together with the computed value (if there is any)are jointly returned. The type of a state is

type state = 2V * (V \Pi  D) * (V \Pi  V list) .
The three components correspond to the set stable, the S,nite (partial) map \Theta ,and the S,nite (partial) map inT^, respectively.

To facilitate the handling of the state we introduce the following auxiliaryfunctions:

- The function get : state \Xi  V \Xi  D implements the function \Theta \Lambda ;- The function

set : V \Xi  D \Xi  state \Xi  state when applied to x updates thecurrent value of

\Theta  x;- The function
get stable : state \Xi  2V extracts the set stable from thecurrent state;

- The function is stable : V \Xi  state \Xi  bool checks whether a given variable

x is in the set stable;- The function

add stable : V \Xi  state \Xi  state adds a given variable to theset stable;

- The function rem stable : V \Xi  state \Xi  state removes a given variable fromthe set stable;
- The function get infl : V \Xi  state \Xi  V list implements the function inT^[ ];

Verifying a Local Generic Solver in Coq 347
let rec eval x y = fun s \Psi 

let s = solve y s in

let s = add infl y x in
(get y s, s)

and eval rhs x = fun s \Psi \Theta 

t x\Lambda  (eval x) s

and solve x = fun s \Psi 

if is stable x s then s

else

let s = add stable x s in

let (new val, s) = eval rhs x s in
let cur val = get s x in
let new val = cur val \Sigma  new val in
if new val \Upsilon  cur val then s
else

let s = set x new val s in

let (work, s) = extract work x s in
solve all work s

and solve all work = fun s \Psi 

match work with--

[ ] \Psi  s--

x :: xs \Psi  solve all xs (solve x s) in

let s init = (\Phi , \Phi , \Phi ) in
let s = solve all X s init in
(get s, get stable s)

Fig. 2. Functional implementation of RLD

- The function add infl : V \Xi  V \Xi  state \Xi  state applied to variables x andy adds the pair (y

, x) to inT^;
- The function rem infl : V \Xi  state \Xi  state applied to the variable x setsthe list inT^

[ ] x in the current state to [ ].

The auxiliary function extract work : V \Xi  state \Xi  (V list * state) applied to avariable

x determines the list w of variables immediately inT^uenced by x, resetsinT^ x to [ ], and subtracts

w from the set stable as follows:

let extract work x = fun s \Xi 

let w = get infl x s in
let s = rem infl x s inlet

s = fold left (fun s y \Xi  rem stable y s) s w in(
w, s)

Using the auxiliary functions \Theta u*\Lambda  for strategy trees, the mutually recursive func-tions

eval, eval rhs, solve and solve all of the algorithm are then given inFig. 2.

348 M. Hofmann, A. Karbyshev, and H. Seidl

Given a list of interesting variables X \Pi  V the algorithm calls the function
solve all from the initial state s init = (\Upsilon , \Upsilon , \Upsilon ).From now on,

RLD refers to this functional implementation. We prove:

Theorem 4. The algorithm RLD is a local generic solver.

5 Proof of Theorem 4
The proof consists of four main steps:

1. We instrument the functional program, introducing auxiliary data struc-tures D^ ghost variables.

2. We implement the instrumented program in Coq.
3. We provide invariants for the instrumented program.
4. We prove these invariants jointly by induction on number of recursive calls.

5.1 Instrumentation
In order to express the invariants necessary to prove the correctness of the al-gorithm, we introduce additional components into the state which do not affect

the operational behavior of the algorithm but record auxiliary information. Theauxiliary data structures appear in the program as ghost variables, i.e., variables
which are not allowed to appear in case distinctions and may not be writteninto ordinary structures. Thus, they do not inT^uence the NGcontrol T^owO"" of the
program. We distinguish:

- the set called of variables which are currently processed;
- the set queued of variables which have been destabilized, i.e., removed fromthe set stable by the algorithm and not yet been reevaluated.

Accordingly, the type state in the instrumented program is given by:

type state = 2V * 2V * (V \Pi  D) * (V \Pi  V list) * 2V .
The S,ve components correspond to the sets stable and called, the S,nite (partial)map

\Theta , the S,nite (partial) map inT^, and the set queued, respectively.Also, we require the following auxiliary functions:

- The function add called : V \Xi  state \Xi  state adds a given variable to theset called;
- The function rem called : V \Xi  state \Xi  state removes a given variable fromthe set called;
- The function add queued : V \Xi  state \Xi  state adds a given variable to theset queued;
- The function rem queued : V \Xi  state \Xi  state removes a given variable fromthe set queued.

Verifying a Local Generic Solver in Coq 349
(*...*)
and eval rhs x = fun s \Psi \Theta 

t x\Lambda \Lambda  (eval x) [ ] s

and solve x = fun s \Psi 

if is stable x s then s

else

let s = rem queued x s in

let s = add stable x s in
let s = add called x s in
let ((new val, ), s) = eval rhs x s in
let s = rem called x s in
let cur val = get s x in
let new val = cur val \Sigma  new val in
if new val \Upsilon  cur val then s
else

let s = set x new val s in

let (work, s) = extract work x s in
solve all work s

Fig. 3. Instrumented implementation of the functions eval rhs and solve

In the instrumented implementation, we also replace the evaluation \Theta u*\Lambda  for strat-egy trees with \Theta u*\Lambda \Pi  which additionally returns the list of accessed variables together with their respective values. Also, the function extract work for a given
x additionally removes the list w of variables inT^uenced by x from the set calledand adds it to the set queued of the current state.

The instrumented functions eval rhs and solve are given in Fig. 3. Thefunctions

eval and solve all remain unchanged.It is intuitively clear that the instrumentation does not alter the relevant

behavior of the algorithm and that therefore the subsequent veriS,cation of theinstrumented version also establishes the correctness of the original one. We now
sketch two ways for making this rigorous; neither of them is part of the formalveriS,cation, though, which operates entirely on the instrumented version. For
the rest of this section let us used primed notation, e.g. state\Pi , solve\Pi  etc. forthe instrumented versions, leaving the unprimed ones for the original version.

We can deS,ne a simulation relation fi \Pi  state * state\Pi  as the graph of theprojection from

state\Pi  to state. We deS,ne a lifted relation M(fi) \Pi  MX * M\Pi Xfor any
X by

f M(fi) f \Pi  fl ffis, s\Pi , s1, s\Pi 1, x, x\Pi . f (s) = (x, s1) ffl f \Pi (s\Pi ) = (x\Pi , s\Pi 1) ffl

s fi s\Pi  =i s1 fi s\Pi 1 ffl x = x\Pi  .

Two functions f : X \Xi  MY and f \Pi  : X \Xi  M\Pi Y are related if f (x) M(fi) f \Pi (x)holds for all

x \Lambda  X. It is then a straightforward consequence from the deS,nitionsthat each component of the algorithm is related to its primed (instrumented)

version and thus that they yield equal results when started in related states andafter discarding the instrumentation.

350 M. Hofmann, A. Karbyshev, and H. Seidl

Alternatively, we can modify the veriS,cation of the instrumented version toyield a direct veriS,cation of the original version by existentially quantifying the
instrumentation components in all invariants. When showing that such existen-tially quantiS,ed invariants are indeed preserved, one opens the existentials in
the assumption yielding a S,xed but arbitrary instrumentation of the startingstate; one then updates this instrumentation using the above updating functions
rem queued, add stable etc. and uses the resulting instrumentation as existen-tial witness for the conclusion. The remaining proof obligation then follows step
by step the veriS,cation of the instrumented version. See [9] for a formal accountof this proof-transforming procedure in the context of Hoare logic.

5.2 Implementation in Coq
Coq accepts the deS,nition of a recursive function only if it is provably termi-nating. Since the algorithm

RLD is generic, we neither make any assumptionsconcerning the lattice D (e.g., w.r.t. S,niteness of ascending chains), nor assume

S,niteness of the set of variables V . Accordingly, termination of the algorithmcannot be guaranteed. Therefore, our formalization of the algorithm in

Coqrelies on the representation of partial functions through their function graphs.

The mutual recursive deS,nition of these relations exactly mimics the functionalimplementation of the algorithm.

We deS,ne the following relations (see appendix):
- for every x, y \Lambda  V , s, s\Pi  : state, d \Lambda  D, EvalRel(x, y, s, s\Pi , d) holds iff the call

eval x y s terminates and returns the value (d, s\Pi );- for every x \Lambda 

V , t \Lambda  T (D, T ), s, s\Pi  : state, d \Lambda  D, l, l\Pi  : (V * D) list,
Wrap Eval x(x, t, s, s\Pi , d, l, l\Pi ) holds iff the call \Theta t\Lambda \Pi  (eval x) l s terminatesand returns the value ((

d, l\Pi ), s\Pi );- for every x \Lambda 
V , s, s\Pi  : state, d \Lambda  D, l\Pi  : (V * D) list, Eval rhs(x, s, s\Pi , d, l\Pi )holds iff the call

eval rhs x s terminates and returns the value ((d, l\Pi ), s\Pi );- for every x \Lambda 
V , s, s\Pi  : state, Solve(x, s, s\Pi ) holds iff the call solve x sterminates and returns the value

s\Pi ;- for every work \Pi 
V , s, s\Pi  : state, SolveAll(work, s, s\Pi ) holds iff the call
solve all work s terminates and returns the value s\Pi .

The deS,ned predicates relate states before the call and after termination of thecorresponding functions. Therefore, they can be used to reason about properties

of the algorithm, even if its termination is not guaranteed.

5.3 Invariants
Given a variable assignment \Theta  we inductively deS,ne relation valid \Pi  (V *D) list*(

V \Xi  D) as follows:

- valid([ ], \Theta );- for any x \Lambda 

V , d \Lambda  D and l : (V * D) list, if valid(l, \Theta ) and d = \Theta  x then
valid((x, d)::l, \Theta );

Verifying a Local Generic Solver in Coq 351
and relation legal \Pi  (V * D) list * T (V, D) inductively by:

- legal([ ], r) for any r \Lambda  T (V, D);- for any x \Lambda 

V , d \Lambda  D, l : (V * D) list and c : D \Xi  T (V, D), if legal(l, c(d))then
legal((x, d)::l, Quest(x, c)).

Intuitively, valid(l, \Theta ) holds iff the path l agrees with the variable assignment \Theta ,and

legal(l, r) means that one can walk along the path l in the tree r, for every(
x, d) from l using a value d as an argument of a corresponding continuationfunction. For example, one can show by induction that

trace\Theta  r is valid for \Theta  andis legal in
r, i.e., valid(trace\Theta  r, \Theta ) and legal(trace\Theta  r, r) hold for any r \Lambda  T (V, D)and given variable assignment

\Theta .Given a strategy tree
r and a path l legal in r we can deS,ne a function
subtree(l, r) recursively as follows:

- if l = [ ] then subtree(l, r) = r;- if

l = (x, d)::vs and r = Quest(x, c) then subtree(l, r) = subtree(vs, c(d)).

We have that subtree(trace\Theta  r, r) = Answ(a) holds for every tree r \Lambda  T (V, D) andvariable assignment

\Theta .We prove by induction on length of a path the following lemma.

Lemma 5. For any given r \Lambda  T (V, D), a path l : (V * D) list and a variableassignment

\Theta  : V \Xi  D, the following is equivalent:

- l = trace\Theta  r;-

valid(l, \Theta ), legal(l, r), subtree(l, r) = Answ(a), for some a \Lambda  D, hold. j\Phi 

From now on, for simplicity, we denote get infl as inT^[ ] and get as \Theta \Lambda . Statess and s\Pi  denote a state before a call of some function and a state after the call

terminates, respectively. Structures stable, called, queued and inT^ are componentsof the state

s, primed structures are components of the state s\Pi . Let t : V \Xi T (
V, D) be a given strategy function. We denote a tree t x by tx. We say thatvariable

x is solved in the state s if x \Lambda  stable \ called. We treat lists as sets inthe formulae below.

We deS,ne:

I0(s) fl called \Pi  stable ffl queued ` stable = \Upsilon  ,I
1(s, s\Pi ) fl stable\Pi  ' stable ffl called\Pi  \Pi  called ffl queued\Pi  \Pi  queued .

We call a state s (a transition from s to s\Pi ) consistent if I0(s) (respectively,I

1(s, s\Pi )) holds. The formula

I\Theta (s, s\Pi ) fl ffiz \Lambda  V. \Theta \Lambda  s\Pi  z \Theta  \Theta \Lambda  s z
expresses that the variable assignment in the state s\Pi  returns larger values thanthat in the state

s. The formula

I\Theta ,infl(s, s\Pi ) fl ffiz \Lambda  V. (\Theta \Lambda  s\Pi  z \Psi  \Theta \Lambda  s z =i inT^[ ] z s \Pi  inT^[ ] z s\Pi ) ffl

(\Theta \Lambda  s\Pi  z ^\Psi  \Theta \Lambda  s z =i inT^[ ] z s \Pi  stable\Pi  \ called\Pi )

352 M. Hofmann, A. Karbyshev, and H. Seidl
relates structures \Theta  and inT^. It expresses for every variable z the following. Ifthe value of

z did not increase, then inT^\Pi  contains more dependencies; otherwise,all the variables inT^uenced by

z in s are solved in s\Pi . The formula

Idep(x, s) fl ffiz \Lambda  dept,(\Theta \Lambda  s) x. z \Lambda  stable ff queued ffl x \Lambda  inT^[ ] z s .
expresses that for every variable z inT^uencing x, this dependency is stored inthe state

s. The formula

Icorr(s) fl ffix \Lambda  stable \ called. \Theta \Lambda  s x \Theta  \Theta tx\Lambda *(\Theta \Lambda  s) ffl Idep(x, s)
deS,nes the correctness of the state s. This means that for every variable x whichis solved in s, the constraint

\Theta  x \Theta  fx \Theta  is satisS,ed for x and dependencies of
x are treated correctly. The most difficult part of the proof was to determineinvariants for the main functions of the algorithm which are sufficiently strong

to prove its correctness. The most complicated invariant refers to the function\Theta u*\Lambda \Pi (

eval x). The formula

I\Theta u*\Lambda \Theta (eval x)(x, r, s, s\Pi , d, vlist, vlist\Pi ) fl

x \Lambda  stable ffl I0(s) ffl Icorr(s) ffl (ffi(y, v) \Lambda  vlist. y \Lambda  stable) =iI

0(s\Pi ) ffl I1(s, s\Pi ) ffl vlist \Pi  vlist\Pi  ffl (ffi(y, v) \Lambda  vlist\Pi . y \Lambda  stable) fflI
\Theta (s, s\Pi ) ffl I\Theta ,infl(s, s\Pi ) ffl Icorr(s\Pi ) ffl\Xi 
x \Lambda  called ffl (ffi(y, v) \Lambda  vlist. x \Lambda  inT^[ ] y s) ffl

valid(vlist, \Theta \Lambda  s) ffl legal(vlist, tx) ffl subtree(vlist, tx) = r =i\Pi 

x \Lambda  called\Pi  =i

valid(vlist\Pi , \Theta \Lambda  s\Pi ) ffl legal(vlist\Pi , tx) ffl subtree(vlist\Pi , tx) = Answ(d) ffl
(ffi(y, v) \Lambda  vlist\Pi . x \Lambda  inT^[ ] y s\Pi ) ffl Idep(x, s\Pi )\Sigma  ffl\Pi 
x /\Lambda  called\Pi  =i x \Lambda  stable\Pi  \ called\Pi \Sigma \Upsilon 

relates the arguments vlist and s with the result value ((d, vlist\Pi ), s\Pi ) of the callwhenever it terminates. It proceeds recursively on the tree

r, taking as a param-eter a list vlist of already visited variables together with their new values. The

function \Theta u*\Lambda \Pi  (eval x) is called for a stable variable x and applied to a partialpath vlist of stable variables and an initial consistent correct state s. As a result
it returns a value d and a longer path vlist\Pi , which extends vlist, of stable visitedvariables, together with a consistent correct state

s\Pi . The formula states thatvalues
\Theta  x of all variables x grew, and inT^ changes according to changes in \Theta . Itdistinguishes the case where

x \Lambda  called. Then if vlist is a valid and legal path in
tx leading to the subtree r and if x \Lambda  called\Pi  then the result path vlist\Pi  is againvalid and legal in

tx and leads to an answer d and all the dependencies of x arerecorded. Note that by lemma 5 this implies that vlist\Pi  is a trace in

tx by \Theta \Pi . Ifx \Lambda  called and x
/\Lambda  called\Pi  then it was reevaluated and solved during a recursivecall for some variable

y of r. It does not matter which value d is returned inthis case since
x is solved in s\Pi  and the corresponding constraint is satisS,ed and

Verifying a Local Generic Solver in Coq 353
will be preserved after the sequent update of \Theta  x. In the case x /\Lambda  called we candeduce that

x is solved in s\Pi  using I1(s, s\Pi ). The formula

Ieval rhs(x, s, s\Pi , d, l\Pi ) fl

x \Lambda  called ffl I0(s) ffl Icorr(s) =iI

0(s\Pi ) ffl I1(s, s\Pi ) ffl I\Theta (s, s\Pi ) ffl I\Theta ,infl(s, s\Pi ) ffl Icorr(s\Pi ) ffl\Xi 
x \Lambda  called\Pi  =i d = \Theta tx\Lambda *(\Theta \Lambda  s\Pi ) ffl l\Pi  = trace\Theta  tx ffl

(ffi(y, v) \Lambda  vlist\Pi . x \Lambda  inT^[ ] y s\Pi ) ffl Idep(x, s\Pi )\Upsilon 

relates the arguments x and s of the call of eval rhs x s with the result states\Pi  whenever it terminates. If the input state s is consistent and correct then so

is the state s\Pi . In the case when x stays called we have that d is a value of theright-hand side of

x on \Theta \Pi  and l\Pi  is a trace in tx by \Theta \Pi . In the case x /\Lambda  called\Pi the variable x is processed during some intermediate recursive call and is solved

in s\Pi . The formula

Isolve(x, s, s\Pi ) flI

0(s) ffl Icorr(s) =iI
0(s\Pi ) ffl I1(s, s\Pi ) ffl I\Theta (s, s\Pi ) ffl I\Theta ,infl(s, s\Pi ) ffl Icorr(s\Pi ) ffl\Xi 
x \Lambda  stable =i s = s\Pi \Upsilon  ffl\Xi 

x /\Lambda  stable =i stable\Pi  ' stable ff -x"" ffl queued\Pi  \Pi  queued \ -x""\Upsilon 

relates arguments x and s with the result state s\Pi  of the call of solve x swhenever it terminates. If the state

s is consistent and correct then so is s\Pi . Inthe case
x \Lambda  stable the state does not change. If x /\Lambda  stable then eventually x issolved in s\Pi  and is removed from the set queued. The formula

Isolve all(w, s, s\Pi ) flI

0(s) ffl Icorr(s) =iI
0(s\Pi ) ffl I1(s, s\Pi ) ffl I\Theta (s, s\Pi ) ffl I\Theta ,infl(s, s\Pi ) ffl Icorr(s\Pi ) ffl
(w ff stable \ called \Pi  stable\Pi  \ called\Pi ) ffl (queued\Pi  \Pi  queued \ w)

relates the arguments w and s with the result state s\Pi  of the call solve all w swhenever it terminates. It states that all the variables solved in

s together withthe variables from
w are solved in s\Pi  and none of the variables from w is inqueued\Pi . We note that although

w = inT^ x (for a corresponding x) may containinvalid dependencies, i.e., variables not dependent on

x on the current \Theta , Icorr(s\Pi )states that inT^ x is appropriately recomputed.

By induction on number of unfoldings of deS,nitions we prove in Coq thatthe formulae I

eval, I\Theta u*\Lambda \Theta (eval x), Ieval rhs, Isolve and Isolve all are invariants ofcorresponding functions in the following sense.

Theorem 6. For all states s, s\Pi  : state the following is true:

- for every x, y \Lambda  V , d \Lambda  D, EvalRel(x, y, s, s\Pi , d) implies Ieval(x, y, s, s\Pi , d);- for every x \Lambda 

V , r \Lambda  T (D, T ), d \Lambda  D, l, l\Pi  : (V * D) list,
Wrap Eval x(x, r, s, s\Pi , d, l, l\Pi ) implies I\Theta u*\Lambda \Theta (eval x)(x, r, s, s\Pi , d, l, l\Pi );

354 M. Hofmann, A. Karbyshev, and H. Seidl

- for every x \Lambda  V , d \Lambda  D, l\Pi  : (V * D) list, Eval rhs(x, s, s\Pi , d, l\Pi ) impliesI

eval rhs(x, s, s\Pi , d, l\Pi );- for every x \Lambda 

V , Solve(x, s, s\Pi ) implies Isolve(x, s, s\Pi );- for every

w \Lambda  V list, SolveAll(w, s, s\Pi ) implies Isolve all(w, s, s\Pi ). j\Phi 

5.4 Putting Things Together
Having veriS,ed the invariants, we now prove that theorem 4 holds, i.e., that RLDis a local solver. Let s init be an initial state with stable = called = queued =

\Theta  = inT^ = \Upsilon . Assume that RLD applied to (t, X) terminates and let s\Pi  be thestate returned by the call

solve all X s init. According to the deS,nition 3, wehave to show that:

1. X \Pi  stable\Pi  and dep*t,(\Theta \Lambda  s\Theta )(stable\Pi ) \Pi  stable\Pi ;
2. \Theta \Lambda  s\Pi  x \Theta  \Theta tx\Lambda *(\Theta \Lambda  s\Pi ) holds for every x \Lambda  stable\Pi .

By theorem 6, implication Isolve all(X, s init, s\Pi ) holds; and its premise is true,inasmuch as both I

0(s init) and Icorr(s init) hold. Therefore, we have I1(s init,s\Pi ), and hence called\Pi  = queued\Pi  = \Upsilon . From (

X ff stable \ called \Pi  stable\Pi  \called\Pi ) we conclude, that

X \Pi  stable\Pi . From Icorr(s\Pi ) it follows, that ffix \Lambda stable\Pi 
. \Theta \Lambda  s\Pi  x \Theta  \Theta tx\Lambda *(\Theta \Lambda  s\Pi ) and dept,(\Theta \Lambda  s\Theta )(stable\Pi ) \Pi  stable\Pi  hold. Hence we

have dep*t,(\Theta \Lambda  s\Theta )(stable\Pi ) \Pi  stable\Pi  and the statement of theorem 4 follows. j\Phi 

6 Conclusion
We have presented the outline of a proof that the algorithm RLD is a localgeneric solver. By that, we enabled the inclusion of this algorithm into the trusted
code base of a veriS,ed program analyzer. Since the solver can be applied to con-straint systems where right hand sides of variables are arbitrary pure functions,
this enables the design and implementation of T^exible and general veriS,ed ana-lyzer frameworks.

The extended version of this paper will provide further veriS,ed properties ofthe algorithm

RLD, such as sufficient conditions for its termination as well assufficient conditions for returning fragments not of any but of the least solution

of the given constraint system. In practical applications such as the analyzer
Goblint it is often convenient to allow more than one constraint for a variable.Therefore, it would be also interesting to provide formalized correctness proofs

also for corresponding extension of RLD.
References

1. Backes, M., Laud, P.: Computationally sound secrecy proofs by mechanized T^ow

analysis. In: ACM Conference on Computer and Communications Security, pp.
370E^379 (2006)
2. Cachera, D., Jensen, T.P., Pichardie, D., Rusu, V.: Extracting a data T^ow analyser

in constructive logic. In: Schmidt, D. (ed.) ESOP 2004. LNCS, vol. 2986, pp. 385E^
400. Springer, Heidelberg (2004)

Verifying a Local Generic Solver in Coq 355
3. Le Charlier, B., Van Hentenryck, P.: A universal top-down S,xpoint algorithm.

Technical Report CS-92-25, Brown University, Providence, RI 02912 (1992)
4. Coupet-Grimal, S., Delobel, W.: A uniform and certiS,ed approach for two static

analyses. In: Filli^atre, J.-C., Paulin-Mohring, C., Werner, B. (eds.) TYPES 2004.
LNCS, vol. 3839, pp. 115E^137. Springer, Heidelberg (2006)
5. Fecht, C.: Gena - a tool for generating prolog analyzers from speciS,cations. In:

Mycroft, A. (ed.) SAS 1995. LNCS, vol. 983, pp. 418E^419. Springer, Heidelberg
(1995)
6. Fecht, C., Seidl, H.: Propagating differences: An efficient new S,xpoint algorithm for

distributive constraint systems. In: Hankin, C. (ed.) ESOP 1998. LNCS, vol. 1381,
pp. 90E^104. Springer, Heidelberg (1998)
7. Fecht, C., Seidl, H.: A faster solver for general systems of equations. Sci. Comput.

Program. 35(2), 137E^161 (1999)
8. Hofmann, M., Karbyshev, A., Seidl, H.: What is a pure functional? In: Abramsky, S., Gavoille, C., Kirchner, C., der Heide, F.M.a., Spirakis, P.G. (eds.)
ICALP 2010. LNCS, vol. 6199, pp. 199E^210. Springer, Heidelberg (2010),
http://dx.doi.org/10.1007/978-3-642-14162-1_17
9. Hofmann, M., Pavlova, M.: Elimination of ghost variables in program logics. In:

Barthe, G., Fournet, C. (eds.) TGC 2007 and FODO 2008. LNCS, vol. 4912, pp.
1E^20. Springer, Heidelberg (2008)
10. Jorgensen, N.: Finding S,xpoints in S,nite function spaces using neededness analysis

and chaotic iteration. In: LeCharlier, B. (ed.) SAS 1994. LNCS, vol. 864, pp. 329E^
345. Springer, Heidelberg (1994)
11. Klein, G., Nipkow, T.: VeriS,ed bytecode veriS,ers. Theor. Comput. Sci. 3(298),

583E^626 (2003)
12. The Coq development team. The Coq proof assistant reference manual. TypiCal

Project (formerly LogiCal), Version 8.2-bugS,x (2009)
13. Nipkow, T.: VeriS,ed bytecode veriS,ers. In: Honsell, F., Miculan, M. (eds.) FOSSACS 2001. LNCS, vol. 2030, pp. 347E^363. Springer, Heidelberg (2001)
14. Seidl, H., Vojdani, V.: Region analysis for race detection. In: Palsberg, J., Su, Z.

(eds.) SAS 2009. LNCS, vol. 5673, pp. 171E^187. Springer, Heidelberg (2009)
15. Seidl, H., Wilhelm, R., Hack, S.: l'Ubersetzerbau: Analyse und Transformation.

Springer, Heidelberg (2010)