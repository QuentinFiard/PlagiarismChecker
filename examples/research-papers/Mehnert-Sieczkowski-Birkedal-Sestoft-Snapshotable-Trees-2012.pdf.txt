

Formalized Verification of Snapshotable Trees:

Separation and Sharing

Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft

IT University of Copenhagen{
hame, fisi, birkedal, sestoft}@itu.dk

Abstract. We use separation logic to specify and verify a Java program
that implements snapshotable search trees, fully formalizing the specification and verification in the Coq proof assistant. We achieve local and
modular reasoning about a tree and its snapshots and their iterators, although the implementation involves shared mutable heap data structures
with no separation or ownership relation between the various data.
The paper also introduces a series of four increasingly sophisticated implementations and verifies the first one. The others are included as future
work and as a set of challenge problems for full functional specification
and verification, whether by separation logic or by other formalisms.

1 Introduction
This paper presents a family of realistic but compact challenge case studies formodular software verification, and shows how separation logic can address one
challenge from that family using an approach similar to ramified frames [10]. Thespecification and verification are fully formalized in Coq, and we believe this is
the first mechanical formalization of this approach to modular reasoning aboutimplementations that use shared heap data with no separation or ownership
between the various data.The family of case studies consists of a single interface specification for snapshotable trees, and four different implementations. A snapshotable tree is anordered binary tree that represents a set of items and supports taking readonly
snapshots of the set, in constant time, at the expense of slightly slower subsequentupdates to the tree. A snapshotable tree also supports iteration (enumeration)
over its items as do, e.g., the Java collection classes. The four implementationsof the snapshotable tree interface all involve shared heap data as well as increasingly subtle uses of destructive heap update.

For practical purposes it is important that the same interface specificationcan support verification of multiple implementations with varying degrees of internal sharing and destructive update. Moreover, the specification must accom-modate any number of data structure (tree) instances, each having any number
of iterators and snapshots, each of which in turn can have any number of itera-tors. Most importantly, we show how we can have local reasoning (a frame rule)
even though the tree and its snapshots share mutable heap data.

2 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft

We welcome other solutions to the specification and verification of this casestudy; indeed Leino has already made one (unpublished) using Dafny [11].
The Java source code of the case studies of all four implementations and theCoq source is available at

http://www.itu.dk/people/hame/snapshots.tar.gz.Section 2 presents the interface of the case study data structure, shows an

example use, and outlines four implementations. Section 3 gives a formal spec-ification of the interface using separation logic and verifies the example code.
Sections 4 and 5 verify the first implementation.

2 Case Study: Snapshotable Trees
The case study is a simplified version of snapshotable treesets from the C5 collec-tion library [8]. Section 2.1 presents the common interface, Section 2.2 presents

client code for a simple application, and Section 2.3 gives an overview of fourpossible implementations of increasing sophistication.

2.1 Interface: Operations on Snapshotable Trees
Conceptually, a snapshot of a treeset is a readonly copy of the treeset. Subsequentupdates to the tree do not affect any of its snapshots, so one can update the

tree while iterating over a snapshot. Taking a snapshot must be a constant timeoperation, but subsequent updates to the tree may be slower after a snapshot has
been taken. Implementations (Section 2.3) typically achieve this by making thetree and its snapshots share parts of their representation, gradually unsharing
it as the tree gets updated, in a manner somewhat analogous to copy-on-writememory management schemes in operating systems.

All tree and snapshot implementations implement the same ITree interface:
public interface ITree extends Iterable<Integer> {

public boolean contains(int x);
public boolean add(int x);
public ITree snapshot();
public Iterator<Integer> iterator();
}

These operations have the following effect:

- tree.contains(x) returns true if the item is in the tree, otherwise false.-

tree.add(x) adds the item to the tree and returns true if the item was notalready in the tree; otherwise does nothing and returns false.

- tree.snapshot() returns a readonly snapshot of the given tree. Updates tothe given tree will not affect the snapshot. A snapshot cannot be made from

a snapshot.-
tree.iterator() returns an iterator (also called enumerator, or stream) ofthe tree's items. Any number of iterators on a tree or snapshot may exist

at the same time. Modifying a tree will invalidate all iterators on that tree(but not on its snapshots), so that the next operation on such an iterator
will throw ConcurrentModificationException.

Formalized Verification of Snapshotable Trees: Separation and Sharing 3
We include the somewhat complicated iterator() operation because it makesthe distinction between a tree and its snapshots completely clear: While it is
illegal to modify a tree while iterating over it, it is perfectly legal to modifythe tree while iterating over one of its snapshots. Also, this poses an additional
verification challenge when considering implementations with rebalancing (casesA2B1 and A2B2 in Section 2.3) because

tree.add(item) may rebalance thetree in the middle of an iteration over a snapshot of the tree, and that should

be legal and not affect the iteration.Note that for simplicity, items are here taken to be integers; using techniques
from [20] it is straightforward to extend our formal specification and verificationto handle a generic version of snapshotable trees.

2.2 Example Client Code
To show what can be done with snapshots and iterators (and not without),consider this piece of client code. It creates a treeset

t, adds three items to it,creates a snapshot
s of the tree, and then iterates over the snapshot's three itemswhile adding new items (6 and 9) to the tree:

ITree t = new Tree();
t.add(2); t.add(1); t.add(3);
ITree s = t.snapshot();
Iterator<Integer> it = s.iterator();
boolean lc = it.hasNext();
while (lc) {

int x = it.next();
t.add(x * 3);
lc = it.hasNext();
}

2.3 Implementations of Snapshotable Trees
One may consider four implementations of treesets, spanned by two orthogonalimplementation features. First, the tree may be left unbalanced (A1) or it may be

actively rebalanced (A2) to keep depth O(log n). Second, snapshots may be keptpersistent, that is, unaffected by tree updates, either by path copy persistence
(B1) or by node copy persistence (B2):

Without rebalancing With rebalancing
Path copy persistence A1B1 A2B1Node copy persistence A1B2 A2B2

The implementation closest to that of the C5 library [8, section 13.10] is A2B2,which is still somewhat simplified: only integer items, no comparer argument, no
update events, and so on. In this paper we formalize and verify only implemen-tation A1B1; the verification of the more sophisticated implementations A1B2,
A2B1 and A2B2 will be addressed in future work.

4 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft

Nevertheless, for completeness and in the hope that others may considerthis verification challenge, we briefly discuss all four implementations and the
expected verification challenges here.With path copy persistence (cases AxB1), adding an item to a tree will duplicate the path from the root to the added node, if this is necessary to avoidmodifying any snapshot of the tree. Thus an update will create

O(d) new nodeson average where
d is the depth of the tree.With node copy persistence (cases AxB2), each tree node has a spare child

reference. The first update to a node uses this spare reference, does not copy thenode and does not update its parent; the node remains shared between the tree
and its snapshots. Only the second update to a node copies it and updates itsparent. Thus an update does not replicate the entire path to the tree root; the
number of new nodes per update is amortized O(1). See Driscoll [6] or [8].To implement ordered trees without rebalancing (cases A1By), we use a Node
class containing an item (here an integer) and left and right children; null isused to indicate the absence of a child. A tree or snapshot contains a stamp
(indicating the "time" of the most recent update) and a reference to the rootNode object;

null if the tree is empty.To implement rebalancing of trees (cases A2By), we use left-leaning red-black

trees (LLRB) which encode 2-3 trees [1, 19], instead of general red-black trees [7]as in the C5 library. This reduces the number of rebalancing cases.

To implement iterators on a tree or snapshot we use a class TreeIterator thatholds a reference to the underlying tree, a stamp (the creation "time" of the
iterator) and a stack of nodes. The stamp is used to detect subsequent updatesto the underlying tree, which will invalidate the iterator. Since snapshots cannot
be updated, their iterators are never invalidated. The iterator's stack holds itscurrent state: for each node in the stack, the node's own item and all items in
the right subtree have yet to be output by the iterator.
Case A1B1 = no rebalancing, path copy persistence In this implementation thereis shared data between a tree and its snapshots, but the shared data is not being
mutated because the entire path from the root to an added node gets replicated.Hence no node reachable from the root of a snapshot, or from nodes in its
iterators' stacks, can be affected by an update to the live tree; therefore nooperation on a snapshot can be affected by operations on the live tree. Although
this case is therefore the simplest case, it already contains many challenges infinding a suitable specification for trees, snapshots and iterators, and in proving
the stack-based iterator implementation correct.
Case A2B1 = rebalancing, path copy persistence In this case there is potentialmutation of shared data, because the rebalancing rotations seem to be able to
affect nodes just off the fresh unshared path from a newly added node to the root.This could adversely affect an iterator of a snapshot because a reference from
the iterator's node stack might have its right child updated (by a rotation), thuswrongly outputting the items of its right subtree twice or not at all. However,
this does not happen because the receiver of a rotation (to be moved down) is

Formalized Verification of Snapshotable Trees: Separation and Sharing 5
always a fresh node (we're in case B1 = path copy persistence) and moreover weconsider only

add operations (not remove), so the child being rotated (moved up)is also a fresh node and thus not on the stack of any iterator - the rebalancing

was caused by this child being "too deep" in the tree. Hence if we were to support
remove as well, we must consider whether the implementation of rotations mustbe refined.

Case A1B2 = no rebalancing, node copy persistence In this case, there is muta-tion of shared data not observable for the client. For example, a left-child update
to a tree Node that is also part of a snapshot will move the snapshot's left-childvalue to Node's extra reference field, and destructively update the left child as
required for the live tree. There should be no observable change to the snapshot,despite the change to the data representing it. The basic reason for correctness
is that any snapshot traversing an updated node will use the extra reference andhence not see the update; this is true for nodes reachable from the root of a
snapshot as well as for nodes reachable from the stack of an iterator. When weneed to update a node whose extra reference is already in use, we leave the old
node alone and create a fresh copy of the node for use in the live tree; again,existing snapshots and their iterators do not see the update.

Case A2B2 = rebalancing, node copy persistence In this case there is mutationof shared data (due both to moving child fields to the extra reference in nodes,
and due to rotations), not observable for the client. Since the updates caused byrotations are handled exactly like other updates, the correctness of rebalancing
with respect to iterators seems to be more straightforward than in case A2B1.

3 Abstract Specification and Client Code Verification
We use higher-order separation logic [18, 3] to specify and verify the snapshotabletree data structure. We build on top of an intuitionistic formalization of higherorder separation logic in Coq [2], developed as part of our research project.To allow implementations to share data between a tree, its snapshots, and
iterators and still make it possible for clients to reason locally (to focus only ona single tree / snapshot / iterator), we will use an idea from [10] (see also the
verification of Union-Find in [9]). The idea is to introduce an abstract predicate,here named

H, global to each tree data structure consisting of a single tree,multiple snapshots and multiple iterators. This abstract predicate

H is param-eterized by a finite set of disjoint abstract structures. We have three kinds of

abstract structures: either a Tree, a Snap, or an Iter. The use of H enables aclient of our specification to consider each abstract structure to be separate or
disjoint from the rest of the abstract structures and thus the client can reasonmodularly about client code using only those abstract structures she needs; the
rest can be framed out. Since the abstract predicate H is existentially quantified,the client has no knowledge of how an implementation defines

H (see [3, 16] formore on abstract predicates in higher-order separation logic). The implementor

6 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft
of the tree data structure has a global view on the tree with its snapshots anditerators, and is able to define which parts of the abstract structures are shared
in the concrete heap. In Section 4 we define H for the A1B1 case (Section 2.3).The Tree abstract structure consists of a handle (reference) to the tree and
a model, which is an ordered finite set, containing the elements of the tree. TheSnap structure is similar to Tree. The Iter structure consists of a handle to
the iterator and a model, which is a list containing the remaining elements foriteration. Because

H is tree-global, exactly one Tree structure must be present("the tree"), while the number of Snap and Iter structures is not constrained.

The remainder of this section contains the abstract specification of the ITreeinterface and the Iterator interface. In Section 3.3 we verify the client code
presented in Section 2.2.In a method's postcondition, variable

ret is the return value.

3.1 Specification of the ITree Interface
We now present the formal abstract specification of the ITree interface informallydescribed in Section 2.1. The specification is parametrized over a class

C andthe above-mentioned predicate
H, and each method specification is universallyquantified over a finite set of integers

o/ and a finite set of abstract structures OE.
interface ITree {{

H({T ree(this, o/)} ] OE)} contains(x) {ret = x 2 o/ ^ H({T ree(this, o/)} ] OE)}{
H({Snap(this, o/)} ] OE)} contains(x) {ret = x 2 o/ ^ H({Snap(this, o/)} ] OE)}{
H({T ree(this, o/)} ] OE)} add(x) {ret = x 62 o/ ^ H({T ree(this, {x} [ o/)} ] OE)}{
H({T ree(this, o/)} ] OE)} snapshot() {H({Snap(ret, o/)} ] {T ree(this, o/)} ] OE)}{
H({Snap(this, o/)} ] OE)} iterator() {H({Iter(ret, [o/])} ] {Snap(this, o/)} ] OE) ^

ret <: Iterator}
(a) H({T ree(t, o/})} ] OE) ` t : C
(b) H({Snap(s, o/)} ] OE) ` s : C
(c) o/ = o/0 ^ H({T ree(t, o/)} ] OE) ` H({T ree(t, o/0)} ] OE)
(d) H({Snap(s, o/)} ] OE) ` H(OE)
(e) H({Iter(it, ff)} ] OE) ` H(OE)}

These specifications can be read as follows:

- contains requires either a Snap or Tree structure (written as separate spec-ifications) for the

this handle and some set o/ . The structure is unmodifiedin the postcondition, and the return value is true if the item

x is in the set
o/ , otherwise false.-
add requires a Tree structure for the this handle and some set o/ . Thepostcondition states that the given item

x is added to the set o/ . The returnvalue indicates whether the tree was modified, which is the case if the item

was not already in the set o/ .
- snapshot requires a Tree structure for the this handle (the interface inSection 2.1 does not support snapshots of snapshots) and some set

o/. Thepostcondition constructs a Snap structure for the returned handle
ret andthe same set
o/ as the tree.

Formalized Verification of Snapshotable Trees: Separation and Sharing 7
- iterator requires a Snap structure for the this handle and some set o/ . Thepostcondition constructs an Iter structure with the return handle and the

set o/ converted to an ordered list, written [o/ ]. The returned handle fulfillsthe Iterator specification (written

<:), given in the next subsection.

The five axioms state that (a) the static type of the tree is the given class C;(b) the static type of a snapshot is

C; (c) the model o/ of the tree can be replacedby an equal model
o/ 0; and we can forget about snapshots (d) and iterators (e).In contrast to the description in Section 2.1 we do not consider iterators over

the tree. An iterator over the tree becomes invalid when the tree is modified, wecan express this using the ramification operator [10].

The abstract separation can be observed, e.g., in the specification of add:it only modifies the model of the Tree structure and does not affect the rest of
the abstract structures (OE is preserved in the postcondition). Hence the clientcan reason about calls to

add locally, independently of how many snapshots anditerators there are.

In our Coq formalization we do not have any syntax for interfaces at thespecification logic level [2], but represent interfaces using Coq-level definitions.
Appendix A contains the formal representation of the above interface ITree.

3.2 Iterator Specification
Our iterator specification is also parametrized over a class IC and a predicate
H, and each method specification is universally quantified over a list of integers
ff and a finite set of abstract structures OE.
interface Iterator<Integer> {{

H({Iter(this, ff)} ] OE)} hasNext() {ret = (|ff| 6= 0) ^ H({Iter(this, ff)} ] OE) }{
H({Iter(this, x :: ff)} ] OE)} next() {ret = x ^ H({Iter(this, ff)} ] OE)}}

The specification of the Iterator interface requires an Iter structure with the
this handle and some list ff. The return value of the method hasNext captureswhether the list

ff is non-empty. The Iter structure in the postcondition is notmodified. The method

next requires an Iter structure with a non-empty list(
x :: ff). The list head is returned and the model of the Iter structure is updatedto the remainder of the list.

3.3 Client Code Verification
To verify the client code from Section 2.2 we assume given a class C such thatITree

C H holds for some H and then verify the client code under the precon-dition {

H({T ree(t, {})})}.Figure 1 gives a step-by-step proof of the client code from Section 2.2, with

client code lines to the left and their postconditions to the right.After inserting some items (line 1) to the tree, the model contains these items,
{1, 2, 3}. In line 2, a snapshot s of the tree t is created. The invariant H nowconsists of the Tree structure and a Snap structure containing the same elements.

8 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft*

H({T ree(t, {})})_
1: t.add(2); t.add(1);

t.add(3); *

H({T ree(t, {1, 2, 3})})_

2: ITree s = t.snapshot(); *H({T ree(t, {1, 2, 3})} ] {Snap(s, {1, 2, 3})})_
3: Iterator<Integer> it =

s.iterator(); *

H({T ree(t, {1, 2, 3})} ] {Snap(s, {1, 2, 3})} ]{
Iter(it, [1, 2, 3])})_

4: boolean lc =

it.hasNext(); *

lc = true ^ H({T ree(t, {1, 2, 3})} ]{
Snap(s, {1, 2, 3})} ] {Iter(it, [1, 2, 3])})_

5: while (lc) { invariant: 9ff, fi.ff@fi = [1, 2, 3] ^ lc = (|fi| 6=

0) ^ H({T ree(t, {1, 2, 3} [ {3z|z 2 ff}))} ]{

Snap(s, {1, 2, 3})} ] {Iter(it, fi)})

6: int x = it.next(); *fi = x :: fi0 ^ H({T ree(t, {1, 2, 3} [ {3z|z 2 ff})} ]{

Snap(s, {1, 2, 3})} ] {Iter(it, fi0)})_

7: t.add(x * 3); *H({T ree(t, {1, 2, 3} [ {3z|z 2 ff} [ {3x})} ]{

Snap(s, {1, 2, 3})} ] {Iter(it, fi0)})_

8: lc = it.hasNext(); *lc = (|fi0| 6= 0) ^ H({T ree(t, {1, 2, 3} [ {3z|z 2 ff} [{

3x})} ] {Snap(s, {1, 2, 3})} ] {Iter(it, fi0)})_

9: } *H({T ree(t, {1, 2, 3, 6, 9})} ] {Snap(s, {1, 2, 3})})_

Fig. 1. Client code verification

For the client the abstract structures are disjoint, but in an implementation, theywill be realized using sharing. Indeed, for the A1B1 implementation, the concrete
heap will be as shown in Figure 2, where all the nodes are shared between thetree and the snapshot.

In line 3 an iterator it over the snapshot s is created. To apply the call rule ofthe

iterator method, only the Snap structure is taken into account, the rest (theTree structure) is framed out inside of

H (via appropriate instantiation of OE in the
iterator specification). The result is that an Iter structure is constructed, whosemodel contains the same values as the model of the snapshot, but converted to an

ordered list. We introduce the loop variable lc in line 4, and again use abstractframing to call

hasNext.
Lines 5-9 contain a while loop with loop condition lc. The loop invariantsplits the iteration list [1

, 2, 3] into the list ff containing the elements alreadyiterated over and the list

fi containing the remainder. The loop variable lc isfalse iff
fi is the empty list. The invariant H contains the Tree structure whosemodel is the initial set {1, 2, 3} joined with the set of the elements of

ff, eachmultiplied by 3.
H also contains the Iter and the Snap structures.
We omit detailed explanation of the remaining lines of verification.
Note that in the final postcondition, the client sees two disjoint structures(axiom (e) is used to forget the empty iterator), but in the A1B1 implementation,

the concrete heap will involve sharing, as shown in Figure 3. Only the left subtreeis shared by the tree and the snapshot; the root and right subtree were unshared
by the first call to add in the loop.

Formalized Verification of Snapshotable Trees: Separation and Sharing 9

2
1 3

t.root s.root

Fig. 2. Heap after snapshot construction

2
1 3

6

9

2

3

t.root s.root

Fig. 3. Live heap after loop
In summary, we have shown the following theorem, which says that givenany classes

C and IC satisfying the ITree and Iterator interface specifications,the client code satisfies its specification. The postcondition says that snapshot

scontains items 1, 2 and 3, and tree
t contains also items 6 and 9.

Theorem 1. 8H.8C, IC.IT ree C H ^ Iterator IC H` {

H({T ree(t, {})})} client code {H({T ree(t, {1, 2, 3, 6, 9})}]{Snap(s, {1, 2, 3}))}

4 Implementation A1B1
In this section we show partial correctness verification of the A1B1 implemen-tation, that it satisfies the abstract specification from the previous section. This
involves defining a concrete H and showing that the methods satisfy the requiredspecifications for this concrete

H. The development has been formally verifiedin Coq (as has the client program verification above).

The Coq formalization uses a shallow embedding of higher-order separationlogic in Coq, developed for verification of OO programs using interfaces. See [2].
Invariant H is radically different depending on whether snapshots of the treeare present or not. The reason is that method

add mutates the existing tree ifthere are no snapshots present, see Section 5 for details. Here we focus on the

case where snapshots are present.The A1B1Tree class stores its data in three fields: the

root node, a booleanfield
isSnapshot, indication whether it is a snapshot, and a field hasSnapshot,indicating whether it has snapshots. The stamp field mentioned in Section 2.3

is only required for iterators over the tree and so not further discussed here.The Node class is a nested class of the A1B1Tree with three fields,

itemcontaining its value, and a handle to the right (
rght) and left (left) subtree.In the following we use standard separation logic connectives, in particular

the separating conjunction * and the points to predicate 7!.We now define our concrete

H and also the realization of the abstract struc-tures. We first explain the realization of Tree and Snap; the Iter structure is

described in Section 4.1. Recall that OE ranges over finite sets of abstract struc-tures (Tree, Snap, Iter), with exactly one Tree structure, and recall that

H, givena
OE, returns a separation logic predicate. The definition of H is:

10 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft

H(OE) , 9oe.(wf(oe) ^ heap(oe)) * oe ffl OE
Here oe is a finite map of type ptr ! ptr * Z * ptr, with ptr being the typeof Java pointers (handles), corresponding to the Node class. The map

oe mustbe well-formed, which simply means that all pointers in the codomain of

oe areeither
null or in the domain of oe. When oe is extended (only in addRecursive),the pointer of the domain is always fresh, so there cannot be cycles in

oe.
The heap function maps oe to a separation logic predicate, which describesthe realization of

oe as a linked structure in the concrete heap.

heap(oe) , 8*p 2 dom(oe).9pl, v, pr. oe[p] = (pl, v, pr)^

p.left 7! pl * p.item 7! v * p.rght 7! pr

The iterating separating conjunction (8*) is used here to ensure that all nodesin

oe are disjoint in the heap.

Finally, we present the definition of oe ffl OE (we defer the definition of oe ffl{
Iter( , )} to the following subsection):

oe ffl OE ]  , oe ffl OE * oe ffl 
oe ffl {T ree(ptr, o/ )} , 9p.Node(oe, p, o/) ^ ptr.root 7! p*

ptr.isSnapshot 7! false * ptr.hasSnapshot 7! true
oe ffl {Snap(ptr, o/ )} , 9p.Node(oe, p, o/) ^ ptr.root 7! p*

ptr.isSnapshot 7! true * ptr.hasSnapshot 7! false

The spatial structure of all the Nodes is covered by heap(oe) so oe ffl OE justneeds to describe the additional heap taken up by Tree, Snap, and Iter structures.
The pure Node(oe, p, o/) predicate, defined by induction on o/ below, is usedto express that

o/ is the finite set of items reachable from p in oe.

N ode(oe, p, o/ ) , \Gamma p = null ^ o/ = {}\Delta .\Gamma 

p 2 dom(oe) ^ 9pl, v, pr. oe[p] = (pl, v, pr) ^9

o/l, o/r.o/ = o/l [ {v} [ o/r ^(8

x 2 o/l.x < v) ^ (8x 2 o/r.x > v) ^
N ode(oe, pl, o/l) ^ N ode(oe, pr, o/r)\Delta 

4.1 Iterator
The TreeIterator class implements the Iterator interface. It contains a singlefield,

context, which is a stack of Node objects.
The constructor of the TreeIterator pushes all nodes on the leftmost pathof the tree onto the stack. The method

next pops the top node from the stackand returns the value held in that node. Before returning, it pushes the leftmost

path of the node's right subtree (if any) onto the stack. The method hasNextreturns true if and only if the stack is empty.

The verification of the iterator depends on the following specification of a
stack class, where the notation bf lifts the function f such that it operates onexpressions rather than values (a detailed explanation of this lifting is in [2]).

Formalized Verification of Snapshotable Trees: Separation and Sharing 11
Stack spec , 8T : Type.9

SR : classname ! (val ! T ! HeapAsn) ! val ! T * ! HeapAsn.
(8C : classname. 8P : val ! T ! HeapAsn.

Stack::new() 7! {?} {r. cSR C P r nil}^
(8ff : T *. Stack::empty(this) 7!

{ cSR C P this ff} {r. cSR C P this ff ^ r = (ff = nil)})^
(8ff : T *. 8t : T . Stack::push(this, x) 7!

{ cSR C P this ff * bP x t ^ x : C} { cSR C P this (t :: ff)})^
(8ff : T *. 8t : T . Stack::pop(this, x) 7!

{ cSR C P this (t :: ff)} { cSR C P this ff})^
(8ff : T *. 8t : T . Stack::peek(this, x) 7!

{ cSR C P this (t :: ff)} {r. bP r t*

(8u : T . bP r u -* cSR C P this (u :: ff))}))^
(8C : classname. 8P, P 0 : val ! T ! HeapAsn.

(8v : val. 8t : T . (P v t ` P 0 v t)) =)8

v : val. 8ff : T *. (SR C P v ff ` SR C P 0 v ff))

This specification is kept in the style of [17], although we use a different logic.For the purpose of specifying the iterators over snapshotable trees, we instantiate the type T with Z*; the model of a node on the stack is a list of integers.Intuitively, this list corresponds to the node value and the element list of its right
subtree. The iterator is modelled as a list that is equal to the concatenation ofthe elements of the stack. We also require that the topmost element of the stack
is nonempty (if present). This intuition is formalized in the interpretation of theIter structure, where

SR is a representation predicate of a stack:

oe ffl {Iter(p, ff)} , 9st. p.context 7! st * 9fi.stack inv (fi, ff)^

SR Node (N S oe) st fi.

To make this definition complete, we provide the definitions of stack inv ,which connects the representation of the stack with the representation of the

iterator, and the definition of the N S predicate.

stack inv(xss, ys) , ys = concat(xss) ^ j ? iff xss = nilxs 6= nil iff xss = xs :: xss0

NS oe node ff , Node(oe, node, o/) ^ ff = [{x 2 o/|x >= node.item}]
These definitions, along with an assumption that SR is the representation predi-cate of Stack (i.e., fulfills all the method specifications and axioms of Stack spec)

suffice to show the correctness of Iter-dependent methods. The axiom present inStack spec is needed to preserve iterators if some new memory is added to

oe: itallows us to replace (
N S oe) with (N S oe0) as a representation predicate of stackobjects under certain side conditions.

12 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft
5 On the Verification of Implemented Code
We now give an intuitive description of how the A1B1 implementation was ver-ified, given the concrete

H defined above. We verified the complete implemen-tation in Coq but only discuss the

add method here. We used Kopitiam [13] totransform the Java code into SimpleJava, the fragment represented in Coq.

Method add allocates a RefBool cell containing boolean field value, thencalls method

addRecursive to insert the item into the binary tree, respectingthe ordering. Method

addRecursive, shown below, must handle several cases:

- if there are no snapshots present, then*

if the item x is already in the tree, then the heap is not modified.*
if the item x is not in the tree, then a new node is allocated and destruc-tively inserted into the tree.

- if there are snapshots present, then*

if the item x is already in the tree, then the heap is not modified.*
if the item x is not in the tree, then a new node is allocated and everynode on the path from the root to the added node is replicated, so that

the snapshots are unimpaired.
The implementation of addRecursive walks down the tree until a node withthe same value, or a leaf, is reached. It uses the call stack to remember the path
in the tree. If a node was added, either the entire path from the root to theadded node is duplicated (if snapshots are present) or the handles to the left or
right subtree are updated (happens destructively exactly once, the parent of theadded node updates its left or right handle, previously pointing to

null):
Node addRecursive (Node node, int item, RefBool updated) {

Node res = node;
if (node == null) {

updated.value = true;
res = new Node(item);
} else {

if (item < node.item) {

Node newLeft = addRecursive(node.left, item, updated);
if (updated.value && this.hasSnapshot)

res = new Node(node.rght, node.item, newLeft);
else

node.left = newLeft;
} else if (node.item < item) {

Node newRght = addRecursive(node.rght, item, updated);
if (updated.value && this.hasSnapshot)

res = new Node(newRght, node.item, node.left);
else

node.rght = newRght;
} //else item == node.item so no update
}
return res;
}

Formalized Verification of Snapshotable Trees: Separation and Sharing 13
We now show the pre- and postcondition of addRecursive for the two caseswhere snapshots are present.

{updated.value 7! false * this.hasSnapshot 7! true*

heap(oe) * wf(oe) ^ Node(oe, node, o/) ^ item 2 o/}

addRecursive(node, item, updated){
updated.value 7! false * this.hasSnapshot 7! true*

heap(oe) * ret = node}

The postcondition in the case that the item is added to the tree extends themap

oe to oe0, for which the heap layout and the well-formedness condition musthold. The Node predicate uses

oe0 and the finite set is extended with item:{
updated.value 7! false * this.hasSnapshot 7! true*

heap(oe) * wf(oe) ^ Node(oe, node, o/) ^ item 62 o/}

addRecursive(node, item, updated){
updated.value 7! true * this.hasSnapshot 7! true*9
oe0.oe ` oe0 ^ heap(oe0) * wf(oe0) ^ Node(oe0, ret, {item} [ o/)}

The call to addRecursive inside of add is verified for each specification of
addRecursive independently.To summarize Sections 4 and 5, we state the following theorem, which says

that given a stack fulfilling the stack specification, the TreeIterator class meetsthe Iterator specification and the A1B1 implementation meets the ITree specification, and the constructor for the A1B1Tree establishes the H predicate.
Theorem 2. 9H.Stack spec ` Iterator T reeIterator H ^ IT ree A1B1 H ^{?}

A1B1T ree() {H({T ree(ret, {})})}

Thus we can safely link the independently verified client code with the A1B1implementation!

6 Related Work
Malecha and Morrisett [12] have presented a formalization of a Ynot implemen-tation of B-trees with an iterator method. In their case, the iterator and the
tree also share data in the concrete heap. However, they can only reason about"single-threaded" uses of trees and iterators: their specification of the iterator
method transforms the abstract tree predicate into an abstract iterator predi-cate, which prohibits calling tree methods until the client turns the iterator back
into a tree. In our setup, we have one tree, but allow for multiple snapshots anditerators, and the tree can be updated after an iterator has been created, as
shown in our client code example. Malecha and Morrisett use fractional permis-sions to allow for the sharing parts of the heap between a tree and an iterator,
whereas we use the H predicate to account for the sharing. We remark thatMalecha and Morrisett are working in an axiomatic extension of Coq, whereas
our proofs are done in a shallowly embedded program logic, since our programsare written in an existing real programming language (Java).

Dinsdale-Young et al. [5] present another approach for reasoning about shareddata structures, which gives the client a fiction of disjointness. Roughly speaking,
they define a new abstract program logic for each module (they can be combined)

14 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft
for abstract client reasoning. Their approach allows to give a client specificationsimilar to ours, but without using the

H and with the abstract structures (Tree/ Snap / Iter) being predicates in the (abstract) program logic. This has the

advantage that one can use ordinary framing for local reasoning.Dinsdale-Young et al. [4] have also presented another approach for reasoning
about sharing. Sharing can happen in certain regions, and the module imple-mentor has to define a protocol which describes how data in the shared region
can evolve. Again, what corresponds to our abstract structures can now be seenas separation logic predicates and thus, again, one can use ordinary framing for
local reasoning.

For both approaches [5] and [4] the module implementor has more proof obli-gations than in our approach: In [5] he has to show that the abstract operations

satisfy a number of side conditions related to how the abstract structures are re-alized in the concrete heap. In [4] he has to show related properties; here phrased
in terms of certain stability conditions.

Compared to the work of Dinsdale-Young et al., our approach has the ad-vantage that it is arguably simpler in that we do not need to introduce new

separation (or context) algebras for the modules. That is why we could buildour formalization on an implementation of standard separation logic in Coq.

7 Conclusion and Future Work
We have presented snapshotable trees as a challenge for formalized reasoningabout mutable data structures that use sharing extensively, and given an abstract
specification of the ITree interface. Moreover, we have presented a formalizationof the A1B1 implementation of snapshotable treees.

The overall size of the formalization effort is roughly 5000 lines of Coq codeand it takes 2 hours to qed the proofs. This is quite big compared to other
formalization efforts of imperative programs in Coq, such as Hoare Type Theory/ Ynot [14, 15]. The main reason is that we are working in a shallowly embedded
program logic for a Java-like language, whereas Hoare Type Theory / Ynot is anaxiomatic extension of Coq. Thus our formalization includes both the operational
semantics of the Java subset and the soundness theorems for the program logic;also, Java program variables cannot simply be represented by Coq variables.

We also plan to verify the even subtler implementations A1B2, A2B1 andA2B2, which are expected to provide further insight into the challenges of dealing with shared mutable data and unobservable state changes. Through thosemore complex applications of separation logic we hope to learn more about desirable tool support, including how to automate the "obvious" reasoning thatcurrently requires much thought and excessive amounts of proof code. Although
we have not formally verified these implementations yet, we are fairly certainthey would match the interface specification presented in Section 3. In all four
implementations the tree is conceptually separate from its snapshots, which isthe property required by the interface, and the invariant

H allows us to describethe heap layout very precisely, using techniques shown in Section 4.

Formalized Verification of Snapshotable Trees: Separation and Sharing 15
Finally, we would like to explore how to combine the advantages of our ap-proach and those of Dinsdale-Young's approach discussed above.

References

1. A. Andersson. Balanced search trees made simple. In F. Dehne et al., editors,

Algorithms and Data Structures. LNCS 709, pages 60-71. Springer-Verlag, 1993.
2. J. Bengtson, J. B. Jensen, F. Sieczkowski, and L. Birkedal. Verifying objectoriented programs with higher-order separation logic in Coq. In ITP 2011, 2011.
3. B. Biering, L. Birkedal, and N. Torp-Smith. BI-hyperdoctrines, higher-order separation logic, and abstraction. ACM Trans. Program. Lang. Syst., 29(5), 2007.
4. T. Dinsdale-Young, M. Dodds, P. Gardner, M. Parkinson, and V. Vafeiadis. Concurrent abstract predicates. In T. DHondt, editor, ECOOP 2010, volume 6183 of
LNCS, pages 504-528. Springer Berlin / Heidelberg, 2010.
5. T. Dinsdale-Young, P. Gardner, and M. Wheelhouse. Abstraction and refinement

for local reasoning. In VSTTE, pages 199-215, Berlin, Heidelberg, 2010. Springer.
6. J. Driscoll, N. Sarnak, D. Sleator, and R. Tarjan. Making data structures persistent.

Journal of Computer and Systems Sciences, 38(1):86-124, 1989.
7. L. Guibas and R. Sedgewick. A dichromatic framework for balanced trees. In 19th

FCS, Ann Arbor, Michigan, pages 8-21, 1978.
8. N. Kokholm and P. Sestoft. The C5 Generic Collection Library for C# and CLI.

Technical Report ITU-TR-2006-76, IT University of Copenhagen, January 2006.
9. N. Krishnaswami. Verifying Higher-Order Imperative Programs with Higher-Order

Separation Logic. PhD thesis, Carnegie Mellon University, 2011. Forthcoming.
10. N. R. Krishnaswami, L. Birkedal, and J. Aldrich. Verifying event-driven programs

using ramified frame properties. In TLDI, pages 63-76. ACM, 2010.
11. K. R. M. Leino. Dafny: An automatic program verifier for functional correctness. In E. M. Clarke and A. Voronkov, editors, Logic for Programming, Artificial
Intelligence, and Reasoning. LNCS 6355, pages 348-370, 2010.
12. G. Malecha and G. Morrisett. Mechanized verification with sharing. In 7th International Colloquium on Theoretical Aspects of Computing, Sept. 2010.
13. H. Mehnert. Kopitiam: Modular incremental interactive full functional static verification of java code. In M. Bobaru, K. Havelund, G. Holzmann, and R. Joshi,
editors, NASA Formal Methods, volume 6617, pages 518-524. Springer, 2011.
14. A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. Ynot: dependent types for imperative programs. In J. Hook and P. Thiemann, editors, Proc.
of 13th ACM ICFP 2008, pages 229-240. ACM, 2008.
15. A. Nanevski, V. Vafeiadis, and J. Berdine. Structuring the verification of heapmanipulating programs. In Proceedings of POPL, 2010.
16. M. J. Parkinson and G. M. Bierman. Separation logic and abstraction. In Proceedings of POPL, pages 247-258, 2005.
17. R. Petersen, L. Birkedal, A. Nanevski, and G. Morrisett. A realizability model for

impredicative hoare type theory. In S. Drossopoulou, editor, ESOP 2008, volume
4960 of Lecture Notes in Computer Science, pages 337-352. Springer, 2008.
18. J. C. Reynolds. Separation logic: A logic for shared mutable data structures. IEEE

Proc. of 17th Symp. on Logic in CS, Nov 2002.
19. R. Sedgewick. Left-leaning red-black trees. At

http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf.
20. K. Svendsen, L. Birkedal, and M. Parkinson. Verifying generics and delegates. In

ECOOP'10, pages 175-199. Springer-Verlag, 2010.

16 Hannes Mehnert, Filip Sieczkowski, Lars Birkedal, and Peter Sestoft
A Appendix
We define here the ITree and the Iterator interface specification as Coq defini-tions. We use the name SPred for the finite set of abstract structures containing
exactly one Tree structure and any number of Snap and Iter structures.A detailed explanation of the notation can be found in [2].

ITree , *C : classname. *H : Pfin(SPred) ! HeapAsn.

(8o/ : Pfin(Z). 8OE : Pfin(SPred). C::contains(this, x) 7!

{ bH({ dTree(this, o/ )} ] OE)} {r. bH({ dTree(this, o/)} ] OE) ^ r = (x 2 o/ )})^
(8o/ : Pfin(Z). 8OE : Pfin(SPred). C::contains(this, x) 7!

{ bH({[Snap(this, o/ )} ] OE)} {r. bH({[Snap(this, o/ )} ] OE) ^ r = (x 2 o/)})^
(8o/ : Pfin(Z). 8OE : Pfin(SPred). C::add(this, x) 7!

{ bH({ dTree(this, o/ )} ] OE)} {r. bH({ dTree(this, {x} [ o/ )} ] OE) ^ r = (x 62 o/ )})^
(8o/ : Pfin(Z). 8OE : Pfin(SPred). C::snapshot(this) 7!

{ bH({ dTree(this, o/ )} ] OE)} {r. bH({ dTree(this, o/), [Snap(r, o/ )} ] OE)})^
(8o/ : Pfin(Z). 8OE : Pfin(SPred). C::iterator(this) 7!

{ bH({[Snap(this, o/ )} ] OE)} {r. 9IC : classname. Iterator IC H ^ r : IC^b

H({[Snap(this, o/ ), cIter(r, [o/])} ] OE)})^
(8v : val. 8o/ : Pfin(Z). 8OE : Pfin(SPred ).

(H({T ree(v, o/ )} ] OE) =) v : C) ^ (H({Snap(v, o/)} ] OE) =) v : C))^
(8v : val. 8o/ : Pfin(Z). 8OE : Pfin(SPred ).

(H({Snap(v, o/ )} ] OE) ` H(OE)))^
(8v : val. 8ff : Z*. 8OE : Pfin(SPred).

(H({Iter(v, ff)} ] OE) ` H(OE)))^
(8v : val. 8o/, o/ 0 : Pfin(Z). 8OE : Pfin(SPred).

o/ = o/ 0 =) (H({T ree(v, o/)} ] OE) ` H({T ree(v, o/ 0)} ] OE)))

Iterator , *C : classname. *H : Pfin(SPred) ! HeapAsn.

(8ff : Z*. 8OE : Pfin(SPred). C::hasNext(this) 7!

{ bH({ cIter(this, ff)} ] OE)} {r. bH({ cIter(this, ff)} ] OE) ^ r = (ff 6= nil)})^
(8x : Z. 8ff : Z*. 8OE : Pfin(SPred). C::next(this) 7!

{ bH({ cIter(this, x::ff)} ] OE)} {r. bH({ cIter(this, ff)} ] OE) ^ r = x})