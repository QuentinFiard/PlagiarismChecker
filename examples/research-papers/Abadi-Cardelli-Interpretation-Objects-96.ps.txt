

An Interpretation of Objects and Object Types

Mart'in Abadi\Lambda 
Digital Systems Research Center

ma@pa.dec.com

Luca Cardelli\Lambda 
Digital Systems Research Center

luca@pa.dec.com

Ramesh Viswanathany
Isaac Newton Institute for Mathematical Sciences

R.Viswanathan@newton.cam.ac.uk

Abstract
We present an interpretation of typed object-oriented concepts in terms of well-understood, purely procedural concepts. More precisely, we give a compositional subtypepreserving translation of a basic object calculus supporting
method invocation, functional method update, and subtyping, into the polymorphic *-calculus with recursive types
and subtyping. The translation techniques apply also to an
imperative version of the object calculus which includes inplace method update and object cloning. Finally, the translation easily extends to "Self types" and other interesting
object-oriented constructs.

1 Introduction
Object-oriented programming languages have introduced numerous ideas, structures, and techniques. Although these
contributions are not always conceptually clear (or even
sound), they are often original and useful. One of the most
basic contributions is the notion of self; the operations associated with an object (its methods) can refer to the object as
self, and invoke other operations by indirecting through self,
with dynamic dispatch. A related contribution is the notion
of subsumption: an object can be replaced (subsumed by)
any object that supports the same or more operations; in
typed languages, subsumption is systematized in rules for
subclassing and subtyping.

Object-oriented programming is not limited to objectoriented languages. One can emulate objects in some procedural languages, such as Scheme and C. So it is possible that,
despite its originality, object-oriented programming can be
reduced to procedural programming. Such a reduction is
not straightforward. Interesting difficulties arise at the level
of types: the most natural definition of objects as records of
functions (the self-application semantics [Kam88]) does not
validate the expected subtypings, so subsumption is blocked.

\Lambda Address: Digital Systems Research Center, 130 Lytton Avenue,
Palo Alto, California 94301, U.S.A.

ySupported by NSF Grant CCR-9303099 and a Rosenbaum Fellowship. Address: Isaac Newton Institute for Mathematical Sciences,
20 Clarkson Road, Cambridge, CB3 0EH, U.K.

To appear in the Proceedings of the 23rd Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, January 1996, St. Petersburg
Beach, Florida.

In this paper we develop an interpretation of objectoriented programming in terms of procedural programming
(specifically, in terms of a fairly standard *-calculus with
subtyping). We show a translation of objects into records of
functions, and a translation of object types into types built
up from record types, existential types, and recursive types.
These ingredients should not be surprising, but their combination is new. The translation is faithful in that it respects
operational semantics, typing rules, and subtyping rules; it
yields a syntactic proof of soundness for those rules.

In order to make this interpretation both manageable
and precise, we develop it in the context of object calculi
[AC94b]. Object calculi are formalisms analogous to *-
calculi, based on objects rather than on functions. Their
only primitives are objects, method invocation, method update, and (for imperative calculi) cloning. Method update
is the most unusual of these, but forms of method update do
appear in several languages [Lie81, And92, Tai92, MGV92,
MMPN93, ALBC+93, App93, Car95]. The primitives are
quite expressive: they allow representations of both classbased and object-based notions, for example classes, subclasses, protection, prototyping, and mode switching. When
typed, object calculi include a subtyping relation and a subsumption rule.

We believe that our interpretation of objects is compelling for several reasons.

ffl First, it makes precise the vague intuition that objects

have something to do with abstract data types and recursive types. That intuition has been important in
previous works that studied *-calculi with subtyping
and used them to emulate objects to various extents
(see the next section). The target calculus of our translation is the result of those previous works.

ffl The translation is sufficiently complicated to confirm

that objects provide a useful abstraction independent
of procedural concepts. On the other hand, it is simple
enough to serve as an explanation of objects in terms
of well-understood constructs.

ffl Finally, the translation is not limited to one particular

object calculus. With some modifications, it applies
both to functional and imperative execution models;
and it can be adapted to account for "Self types" and
"structural rules" [AC95b], which are operationally
sound but unsound in common denotational models.

In the next section we review some of the background,
describing related works, and give an informal overview of

our interpretation. Section 3 defines a first version of the
translation precisely; Section 4 gives an imperative translation; Section 5 deals with additional type constructs.

2 Informal Review and Overview
We first review a basic untyped object calculus [AC94b]
since we use its notation in what follows. In this calculus, an object [l1 = &(x1)b1; : : : ; ln = &(xn)bn] is a collection of methods &(x1)b1; : : : ; &(xn)bn with respective names
l1; : : : ; ln; the method bodies are b1; : : : ; bn, and the variables x1; : : : ; xn denote self. The order of the methods does
not matter. The only operations on objects are method
invocation and method update. If o is the object [l1 =
&(x1)b1; : : : ; ln = &(xn)bn], then the invocation of its method
li, written o:li, consists in replacing o for xi in bi; the method
update o:li ( &(x)b yields an object like o but where we
have li = &(x)b. For now, we take the update construct to
be functional, that is, to create a new object. Fields (instance variables) are easily expressible as methods that do
not use their self parameters.

This untyped calculus is the basis for a first-order calculus with subtyping, called Ob1!:. In Ob1!:, an object type
[l1 : B1; : : : ; ln : Bn] is the type of objects which have methods l1; : : : ; ln that, when invoked, result in values of types
B1; : : : ; Bn respectively.

A characteristic of object-oriented languages is that an
object with more methods can be used wherever an object
with fewer methods is expected. In Ob1!:, this is supported
through a subtyping relation !:. An object type with more
methods is a subtype of an object type with fewer methods
provided that the common methods have exactly the same
result types; for example, [l1 : B1; l2 : B2]!:[l1; B1] for any
types B1 and B2.

The self-application semantics [Kam88] provides a satisfactory explanation of untyped objects as records of functions. Let us write fl1 = a1; : : : ; ln = ang for the record with
fields l1; : : : ; ln with a1; : : : ; an as values; a \Delta  l for extracting
the field l of record a; and a\Delta l := b for updating the field l of
record a to be b. In the self-application semantics, a method
is a function of its self parameter; an object is a record of
such functions; method invocation is field selection plus selfapplication; method update is record update:

[l1 = &(xi)bi i21:::n] 4= fli = *(xi)bi i21:::ng

o:lj 4= o \Delta  lj(o)
o:lj ( &(y)b 4= o \Delta  lj := *(y)b

This interpretation respects the operational behavior of both
method invocation and method update.

Unfortunately, the self-application semantics does not
extend to typed systems such as Ob1!:. In particular, it
does not validate the essential subtypings between object
types. Following the self-application semantics, one would
naturally interpret the object type A j [li : Bi i21:::n] as a
recursive record type, the solution to the type equation:

A = fli : A!Bi i21:::ng
where fli : Ci i21:::ng denotes the evident record type. Because of the contravariant occurrences of the object type
A, we do not obtain subtypings valid in Ob1!: such as
[l1 : B1; l2 : B2]!:[l1 : B1].

In part because of this difficulty, there have been several
other interpretations of objects. Most of them were defined
as ways of emulating objects in procedural settings, rather
than as precise translations, so it is somewhat hard to give
a full account of their scope. In short, many of them contributed interesting and useful techniques but they all suffer from limitations. The recursive-record semantics [Car88]
validates the expected subtypings, but it does not model
method update (or even field update); the generator semantics [Coo89] deals with update, at the cost of separating
objects from object generators. The existential interpretation of [PT94, HP95] also validates the expected subtypings, and models class-based constructs where methods and
fields are rigidly separated and it is only the fields that
can be updated; unfortunately, the translation of objects
is type-directed, and rather elaborate. An imperative interpretation [ESTZ95] can solve the problems of the selfapplication semantics with judicious side-effects; its main
limitation is that it does not model the cloning construct
of object-based imperative languages. Finally, some interpretations give up on subtyping altogether, and reduce it to
coercion functions [AC94a, R'em94]; the coercion functions
are cumbersome, destroy the flavor of the original programs,
and preclude an explanation of object subtyping in terms of
more primitive subtyping relations.

At this point, a possible conclusion is that it is easy to
understand the computational behavior of objects, but that
their desired typing and subtyping properties make them
fundamentally different from records and functions. It was
this view that originally led to the formulation of object calculi. Our interpretation of objects, which we discuss next,
sheds some new light on this matter. It does provide a
rather complete account of objects in terms of records and
functions. It applies both to class-based and object-based
constructs, places no restrictions on method update, and validates the expected subtypings. On the other hand, because
it is not straightforward, it does not remove the usefulness
of object calculi as a setting for studying object-oriented
concepts.

In this paper we develop translations of several object
calculi into *-calculi. The translations are faithful in that
they respect the operational semantics, typing rules, and
subtyping rules of the object calculi. The first translation
maps Ob1!: into F!:_, the polymorphic *-calculus with
subtyping and recursive types; we preview this translation
next, explaining informally how it treats types.

Consider a type A j [l1 : B1; : : : ; ln : Bn]. Because of
subsumption, an object o containing additional methods besides l1; : : : ; ln can be an element of A. If we think of the
"true type" of o as the type listing all its methods, then
the type A only partially reveals the true type of o; what is
publicly visible are only the methods l1; : : : ; ln. We therefore take the translation A\Lambda  of an object type A to be a type
abstraction with representation type the true type of the object. Using the notation 9(X!:C)B for a type abstraction
with an interface B and an unknown representation type X
that is a subtype of C, we define A\Lambda  as a recursive type,
with the following equation:

A\Lambda  = 9(X!:A\Lambda )flseli : (X!B\Lambda i ) i21:::n;

lupdi : (X!B\Lambda i )!X i21:::n;
self : Xg (1)

The subtyping assumption X!:A\Lambda  for the representation
type expresses that the true type is known to be a subtype

2

Table 1: Operational Semantics of Ob1!: and F!:_
Ob1!:

If a j [li = &(xi : A)bifxig i21:::n]; j 2 1 : : : n
(Eval Select) a:lj ; bjfag
(Eval Update) a:lj ( &(x : A0)b ; [lj = &(x : A)b; li = &(xi : A)bi i2f1:::ng\Gamma fjg]

F!:_

(Eval Beta) (*(x : A)bfxg)(a) ; bfag
(Eval Beta2) (*(X!:A)bfXg)(A0) ; bfA0g
(Eval Record Select) fli = bi i21:::ng \Delta  lj ; bj for j 2 1 : : : n
(Eval Unfold) unfold(fold(A; a)) ; a
(Eval Unpack) open c as X!:A; x : BfXg in dfX; xg : D ; dfC; bfCgg

where c j pack X!:A0 = C with bfXg : B0fXg

of the object type. The field lseli is the method li treated as a
function of self. The field lupdi provides the ability to update
method li--given a new method that is a function of self, it
returns a new object. The field self is the object itself with
all its methods (including the private ones); through self ,
the methods l1; : : : ; ln can access methods not listed in the
interface.

Each of the ingredients in this translation is necessary.
In particular, the use of existential types in addition to recursive types is essential for getting the desired subtypings.
Similarly, it is essential to model method update via a field
lupdi : if method update were modeled by an update of the
field lseli then this would leave the field self unaffected, so
the operational semantics would be distorted.

In the next section we detail this translation of Ob1!:.
In Section 4, we consider an imperative version of the translation, which deals correctly with cloning but is in some
ways simpler than the functional one thanks to side-effects.
In Section 5, we show that the translation of Ob1!: can be
extended to account for richer object-type constructs with
Self types and variance annotations.

3 Interpretation of an Object Calculus with

Functional Update

In this section, we describe the translation of the object calculus Ob1!: into the functional calculus F!:_. In Sections
3.1 and 3.2, we briefly describe the calculi Ob1!: and F!:_,
and in Section 3.3, we detail the translation of Ob1!: into
F!:_. The precise typing rules for the two calculi are given
in Appendices A and B.

3.1 An Object Calculus: Ob1!:
The types of Ob1!: are generated by the grammar:

A; B ::= Top j [li : Bi i21:::n]
where n * 0. The type Top is the supertype of all types
and [li : Bi i21:::n] is the type of objects with methods li
returning results of type Bi. The terms of the calculus are
similar to those of the untyped calculus described in Section
2 except that &-bound variables have type annotations:

a; b ::= x j [li = &(xi : A)bi i21:::n] j a:l j a:l ( &(x : A)b

A subset of the terms generated by this grammar are identified as well-typed terms by a set of typing rules described
in Appendix A. The rules are used to derive judgements of
the form E ` J , where J is an assertion and E is an environment describing assumptions about the free variables
in J . The assertion \Pi  means that E is a well-formed environment, A means that A is a well-formed type, A!:B
means that A is a subtype of B, and a : A means that a
is a well-formed term of type A. An important rule, (Sub
Object), states that A is a subtype of A0 if A has all the
method names given in A0 and moreover the result types of
these methods are exactly the same in A and A0 (so object
types are invariant in their component types).

The operational semantics is defined via a reduction system; it is free of side-effects. The primitive redexes given in
Table 1 correspond to method invocation and method update; we write bfxg to distinguish a variable x that may occur free in b, and bfag for the result of replacing x with a in b
once x is clear from context. The one-step reduction relation
\Gamma !o is the congruence closure of ; (i.e., we can reduce any
subterm that is a redex); the many-step reduction relation
\Gamma !!o is the reflexive, transitive closure of \Gamma !o. We define
results to be terms of the form [li = &(xi : A)bi i21:::n]; we
say that a closed term a converges, and write a +o, if there
exists a result v such that a\Gamma !!ov.

3.2 A Functional Calculus: F!:_
The system F!:_ is the standard extension of System F with
recursive types and subtyping. While records and existentially quantified types are encodable in terms of the other
constructs of F!:_, we present them as primitive for simplicity. System F!:_ is defined in detail in Appendix B; in
this section, we describe informally some of its constructs.

Records are collections of fields with associated values;
the only operation on records is field extraction (written
r \Delta  l). The basic types are function types and record types.

A record type fli : Bi i21:::ng lists the field names and the
types of the values associated with them. Record types are
covariant in their component types. We use the recursive
type _(X)BfXg to denote a solution to the type equation
X = BfXg where X could occur free in B. The isomorphism between _(X)BfXg and its unfolding Bf_(X)BfXgg
is given by the constructs fold and unfold: if a is of type
_(X)BfXg then unfold(a) is of the unfolded type, and if b

3

is of the unfolded type then fold(_(X)BfXg; a) is of type
_(X)BfXg.

The existentially quantified type 9(X!:A)BfXg is the
type of a term a (roughly) if there exists a type C that is
a subtype of A for which a is a term of type BfCg. More
formally, given a term a of type BfCg, the term pack X !:
A = C with a : BfXg has type 9(X!:A)BfXg. What
we achieve by packing a in a term of type 9(X!:A)BfXg
is the hiding of information about the type C at which
a realizes 9(X!:A)BfXg. (Recall that data abstractions
have existential types [MP88].) Given a term c of type
9(X!:A)BfXg, we can access its "inside" by writing the
term open c as X!:A; y : BfXg in d : D, where X stands
for the representation type and y for the "inside". We can
use X and y in d but the typing rules ensure that d cannot assume any information about X other than that it is
a subtype of A, and the type D specified for d must not
depend on the representation type X, i.e., X cannot occur
free in D.

Table 1 specifies reduction for F!:_. The one-step reduction relation \Gamma !f is the congruence closure of ;, and \Gamma !!f
is the reflexive, transitive closure of \Gamma !f . As for Ob1!:, we
distinguish certain terms as results; the set of results, defined in Appendix B, includes *-abstractions and records.
We say that a closed term a converges, and write a +f , if
there exists a result v such that a\Gamma !!f v.

Using recursive types, we can easily define a (call-byname) fixed point operator. It is also routine to define
letrec; we write letrec f(x1 : A1) \Delta  \Delta  \Delta  (xn : An) : B =
b in c to denote a recursive definition of a function f of
type A1! \Delta  \Delta  \Delta  !An!B, used in the term c.

3.3 Translation
We are now ready to describe the translation of Ob1!: into
F!:_. The translation is in two parts. The first part is a
translation of types which maps every type A of Ob1!: to a
type A\Lambda  of F!:_ and is defined by induction on the structure
of types in Ob1!:.

Top\Lambda  = Top
[li : Bi i21:::n]\Lambda  = _(Y )9(X!:Y )

flseli : (X!B\Lambda i ) i21:::n;

lupdi : (X!B\Lambda i )!X i21:::n;
self : Xg

The interpretation of object types given here is the same
as that of Section 2, but here we use a _ rather than an
equation (Equation (1)) for defining the existential type recursively. Note that in the translation of the object type
A j [li : Bi i21:::n], the field lseli makes the type A\Lambda  covariant

in B\Lambda i and the field lupdi makes it contravariant in B\Lambda i . Our
interpretation thus explains the invariance of object types
in their component types as arising from a covariance due
to invocation and a contravariance due to update.

The key consequence of our translation of object types
is that it gives the expected subtypings. More formally,
we use the translation of types to define a mapping E\Lambda  for
environments, and establish Theorem 3.1 which states that
well-formed types of Ob1!: get mapped to well-formed types
of F!:_ and that the subtyping judgements of Ob1!: are
preserved by the translation.

OE\Lambda  = OE
(E; x : A)\Lambda  = E\Lambda ; x : A\Lambda 

Theorem 3.1

1. If E ` \Pi  is derivable in Ob1!:, then E\Lambda  ` \Pi  is derivable

in F!:_.

2. If E ` A is derivable in Ob1!:, then E\Lambda  ` A\Lambda  is derivable in F!:_.

3. If E ` A!:B is derivable in Ob1!:, then E\Lambda  ` A\Lambda !:B\Lambda 

is derivable in F!:_.

The second part of the translation is for terms. To
make the main ideas in the translation of terms transparent, we first informally explain the results of the translation
as untyped *-terms, omitting the type annotations associated with using recursive and existential types; we make the
details precise later. Informally, every term a of Ob1!: is
mapped to its meaning, hhaii, which is a *-term. Apart from
the typing restrictions imposed by the recursive and existential types, the translation of an object type is a record type

with two fields lseli and lupdi for each method li and a field
self . The field lseli is the method li treated as a function of
self, and the field lupdi returns a new object when applied
to a new method treated as a function of self. With this
understanding, the translations of method invocation and
update are straightforward.

hha:ljii = hhaii \Delta  lselj (hhaii \Delta  self )
hha:lj ( &(x)bii = hhaii \Delta  lupdj (*(x)hhbii)

The most delicate part of the translation of terms is that
for objects. This may be expected since we did not do anything computationally interesting so far--we just delegated

responsibility to the fields lseli and lupdi provided by the interface of objects. To understand the translation of objects,
it is instructive to consider first an incorrect attempt, which
will also explain the presence of the field lupdi . Suppose we
chose not to have the field lupdi in the record interface for
objects and instead modeled method update by an update
of the field lseli , i.e., for an object o j [li = &(xi)bi i21:::n],
we would have that

hho:lj ( &(x)bii = hhoii \Delta  lselj := *(x)hhbii (wrong)
Invoking a method lj of o would still be interpreted as extracting the lselj field and applying it to the field self . Since
the object o is a record with field lseli equal to the method bi
treated as a function of its self parameter, and since method
invocation is modeled by application to the field self , the
field self then has to be the object itself. We arrive at the
following recursive definition for hhoii:

hhoii = flseli = *(xi)hhbiii i21:::n; self = hhoiig (wrong)
The problem with this (functional) interpretation of objects
is that when a method gets updated the object changes but
since we only update the field lj of the record, this change
is not reflected in the field self and consequently we lose the
dynamic binding of self. Thus, if some other method uses
lj in its body, then its invocation modeled by application

4

Table 2: Translation of Ob1!: into F!:_
hhxiiE = x
hh[li = &(xi : A)bi i21:::n]iiE = letrec create (f1 : A\Lambda !B\Lambda 1 ) : : : (fn : A\Lambda !B\Lambda n) : A\Lambda  =

fold (A\Lambda ;

pack X!:A\Lambda  = A\Lambda 
with flseli = fi i21:::n;

lupdi = *(g : A\Lambda !B\Lambda i )

create (f1) : : : (fi\Gamma 1) (g) (fi+1) : : : (fn) i21:::n;
self = create (f1) : : : (fn)g : CAfXg)
in create (*(x1 : A\Lambda )hhb1iiE;x1:A) : : : (*(xn : A\Lambda )hhbniiE;xn:A)
where A j [li : Bi i21:::n]

hha:liiE = open unfold(hhaiiE) as X!:Ll;B; x : flsel : (X!B\Lambda ); self : Xg

in (x \Delta  lsel)(x \Delta  self ) : B\Lambda 
where B = hE; ail

hha:l ( &(x : A)biiE = open unfold(hhaiiE) as X!:A\Lambda ; y : CAfXg

in (y \Delta  lupd)(*(x : X)hhbiiE;x:A) : A\Lambda 

to the field self would not see the result of the update. So,
an important idea in the context of our translation is that
method update is not modeled as record update. The second
idea to glean from this flawed attempt is that defining the
object itself recursively would not reflect the computational
behavior of objects accurately. Intuitively, update has no
chance of working once the recursion freezes self to be the
state of the object at the time of creation, i.e., if recursion
is used too soon. (Those familiar with the recursive-record
interpretation [Car88] may note that the source of its problems in modeling method update can also be traced to the
early use of recursion.)

The solution is to define not the object itself recursively,
but the dependence of the object on its methods recursively.
That is, we define a function create that when applied to
n methods, returns an object with those n methods and it
is the definition of create that is recursive. An object can
then be defined by the application of create to its methods,
as follows:

For o j [li = &(xi)bi i21:::n];
hhoii = letrec create (f1) \Delta  \Delta  \Delta  (fn) =

flseli = fi i21:::n;

lupdi = *(g) create (f1) \Delta  \Delta  \Delta  (fi\Gamma 1)

(g) (fi+1) \Delta  \Delta  \Delta  (fn) i21:::n;
self = create (f1) \Delta  \Delta  \Delta  (fn)g
in create (*(x1)hhb1ii) : : : (*(xn)hhbnii)

We now define the translation of terms with typing annotations, more precisely. We use the following notation.

Notation:

1. For any object type A j [li : Bi i21:::n], we define the

F!:_ type CAfXg with free variable X:

CAfXg 4= flseli : (X!B\Lambda i ) i21:::n;

lupdi : (X!B\Lambda i )!X i21:::n;
self : Xg

2. For any method name l and Ob1!: type B, we define

the F!:_ type Ll;B by:

Ll;B 4= _(Y )9(X!:Y )flsel : (X!B\Lambda ); self : Xg
3. Suppose, for any term a and environment E, that E `

a : [: : : ; l : B; : : :] is provable in Ob1!:. Then by the
minimum-types property of Ob1!: [AC94b] and by the
invariance of object types, we have that if E ` a :
[: : : ; l : B0; : : :] then B j B0. So we let hE; ail be the
unique type B such that E ` a : [: : : ; l : B; : : :] is
provable if it exists, and be undefined otherwise.

For any term a in Ob1!: and environment E, Table 2
defines a term hhaiiE of F!:_. The translation proceeds by
induction on the structure of a. In particular, the translation
of a judgement E ` a : A does not depend on its derivation
in Ob1!:, and consequently, we can avoid coherence issues in
our proofs. The inclusion of the environment E in defining
the meaning of a term arises for purely technical reasons. It
is to give the necessary type annotations in the translation
of method invocation. If we had omitted type annotations
from the target calculus or put more type information in
the syntax of the term for method invocation, we could have
defined the meaning of the term without any dependence on
the environment.

Some remarks regarding the translation of terms are in
order. The translation of method invocation explains the
presence of the field self in the translation of object types:
using x instead of x \Delta  self would not lead to a typable result. In the translation of method update, the use of *(x :
X)hhbiiE;x:A is motivated by the reduction rule (Eval Update) which asserts:

([li = &(xi : A)bi 1:::n+m]:lj ( &(x : A0)b) ;

[lj = &(x : A)b; : : : ]

with A instead of A0 in the type annotation of x in the
updated object. The use of *(x : A\Lambda )hhbiiE;x:A instead of
*(x : X)hhbiiE;x:A would be acceptable from the point of
view of typing but would not fit with the rule (Eval Update).

5

The following theorem states that our translation preserves typing judgements and the computational behavior
of terms.

Theorem 3.2

1. If E ` a : A is derivable in Ob1!: then E\Lambda  ` hhaiiE :

A\Lambda  is derivable in F!:_.

2. If E ` a : A is derivable in Ob1!: and a\Gamma !!ob then

hhaiiE\Gamma !!f hhbiiE.

The translation can serve as a basis for validating reasoning principles for objects from reasoning principles for
functions. In particular, we can prove that two objects are
equivalent by showing that their translations are equivalent.
We have been able to check a few non-trivial object equivalences in this manner. This proof method is not complete,
because the translation is not fully abstract; however, it is
sound, because the translation is computationally adequate,
as we show next.

Let a and b be two closed Ob1!: terms of type A. We
say that a and b are operationally equivalent at type A, and
write a jo b : A, if we have that C[a] +o if and only if
C[b] +o for any context C[\Delta ] which is well-typed assuming
the hole [\Delta ] is of type A. We define the relation of operational equivalence similarly for F!:_, and write a jf b : A.
The first part of the following theorem states that the translation is computationally adequate; the second part, which
is a corollary of the first, states that if two Ob1!: terms
have operationally equivalent translations then they are operationally equivalent.

Theorem 3.3 Assume that ; ` a : A and ; ` b : A are derivable in Ob1!:. Then:

1. a +o if and only if hhaii; +f .
2. If hhaii; jf hhbii; : A\Lambda  then a jo b : A.

In summary, there are three key ideas in the translation.
The first is that interpreting an object type as a recursive
type abstraction gives the desired subtypings. The second
is to model method invocation not as application to the
object itself, but rather to a field self which holds the current
value of the object. And finally, by splitting each method
into a field for invocation and a field for update and by
using recursion in a function that creates objects, we obtain
dynamic binding.

4 Interpretation of an Imperative Object

Calculus

In this section, we show how the ideas embodied in the translation described in Section 3 are also useful to the interpretation of imperative object-oriented constructs. Our formal
setting is the imperative object calculus of [AC95a].

4.1 An Imperative Object Calculus
The terms of the untyped imperative object calculus are
generated by the grammar:

a; b ::= x j [li = &(xi)bi i21:::n] j a:l j a:l ( &(x)b

j clone(a) j let x = a in b

As the previous calculus, this imperative calculus has terms
corresponding to objects, method invocation, and method
update. However, the operational semantics is imperative
in that method names denote locations where the closures
of the corresponding methods are stored and method update
is done in place. Thus, method update has a side-effect of
changing the object rather than returning a new object. In
addition, we have two new primitives: (1) clone(a) returns
a shallow copy of the object a, i.e., an object with the same
method suite as a stored in fresh memory locations; (2) the
let construct evaluates a term, binds it to a variable, and
then evaluates a second term with that variable in scope.
Sequential evaluation (;) and eagerly evaluated fields can be
defined from let. The type system is given in Appendix C;
it is an extension of that of Ob1!:.

4.2 Translation
We translate the imperative object calculus into an imperative version of F!:_, which here we describe informally. The
syntax of this imperative version extends that of F!:_ with
field update for records (written a\Delta l := b) and with an uninitialized value of each type (written nil(B)). Because of the
presence of field update, record types must be invariant in
their components. The operational semantics of the imperative version is significantly different from that of F!:_ in two
respects: (1) The field names in records now denote memory
locations and field update is done in place. It is therefore
more accurate to think of a record as a collection of memory locations rather than as a collection of values. (2) In the
presence of side-effects, one needs to fix an evaluation order;
we assume call-by-value evaluation for the target calculus.
Then let x = a in b can be defined as (*(x)b)(a), and a; b
can be defined as (*(z)b)(a) for some z not free in b.

The main departure from the translation described in
Section 3.3 is that, in the imperative setting, we do not split
a method into two distinct fields corresponding to method
invocation and method update. Recall that the essential reason for the split in the functional case was that the field self
would not detect the change to a method if method update
was modeled by record update of the field corresponding to
the method. However, in the presence of imperative features
in the target calculus, we can use the field self to store a
pointer to the record itself (that is the meaning of the object), thus ensuring that any changes to the other fields of
the record are reflected in self .

The translation of types uses the ideas described in Section 2. In addition, we include a cloning function in the
public interface of an object. For types we therefore have:

Top\Lambda  = Top
[li : Bi i21:::n]\Lambda  = _(Y )9(X!:Y )

fli : (X!B\Lambda i ) i21:::n;

clone : fg!X;
self : Xg

The distinction between the fields self and clone is that the
former contains a pointer to the record itself while the latter
returns a shallow copy of the record (under a dummy abstraction). We need to distinguish the two since, in method
invocation, one must apply the method to the object rather
than to a shallow copy of the object. As before, the use of
a recursive type abstraction yields the desired subtypings.

6

Table 3: Translation of the Imperative Object Calculus (Sketch)

hhxii = x
hh[li = &(xi)bi i21:::n]ii = letrec create (f1) : : : (fn) =

let z = fli = fi i21:::n; clone = nil; self = nilg
in z \Delta  clone := *(x)create (z \Delta  l1) \Delta  \Delta  \Delta  (z \Delta  ln);

z \Delta  self := z;
z \Delta  self
in create (*(x1)hhb1ii : : : (*(xn)hhbnii)

hha:ljii = let x = hhaii in (x \Delta  lj)(x \Delta  self )
hha:l ( &(x)bii = let y = hhaii in y \Delta  lj := *(x)hhbii

hhclone(a)ii = (hhaii \Delta  clone)(fg)
hhlet x = a in bii = let x = hhaii in hhbii

We give the precise definition of the translation of terms
below. For now, we refer to Table 3 which states the translation omitting type annotations in terms. In the translation
of an object, we declare a skeletal record structure z where
the fields clone and self are uninitialized, and then update
these fields so that they can point circularly to the record
structure. Note that we retained the idea of defining a create
function recursively rather than the object itself recursively.
This is necessary for cloning to return the correct copy of
the object after updates; if we had defined the object recursively, then clone would have been frozen to return a shallow
copy of the state of the object at the time of its creation.
(Cf. the semantics of [ESTZ95], which does not accommodate cloning.) In our translation, the field clone is defined
to be an abstraction so that the application of create terminates under call-by-value evaluation. Method invocation is
interpreted in the same way as in the functional case while
method update is interpreted as record update. Cloning is
interpreted as an application of the field clone to a dummy
argument (the empty record).

The precise definition of the translation of terms, in Table 4, relies on the following notation:

Notation:

1. For A j [li : Bi i21:::n], we define:

CimpA fXg 4= fli : (X!B\Lambda i ) i21;:::;n;

clone : fg!X;
self : Xg

2. For any method name l and type B, we let:

Limpl;B 4= _(Y )9(X!:Y )fl : (X!B\Lambda ); self : Xg
3. The type MinTyhE; ai is the minimum type of a in

environment E, i.e., the type A such that E ` a : A0
is provable if and only if E ` A!:A0; it is undefined if
a is not typable in E. The type hE; ail is as in Section
3.3.

We can prove a soundness theorem for this translation.
We omit it from this paper since its statement requires
lengthy definitions detailing and relating the operational semantics of the imperative calculi.

5 Extensions to Richer Object Types
In this section, we consider richer typing disciplines for objects: variance annotations, Self types, and structural rules
(all described in [AC95b]); we show how our translation extends to account for them. In Section 5.1, we begin by giving
an overview of these typing disciplines and an informal description of our interpretation for them. In Section 5.2, we
describe an enriched object calculus more precisely. Finally,
in Section 5.3, we give a translation of this object calculus.

5.1 Preview
Variance Annotations
Variance annotations are an extension to object types; they
are symbols (+, \Gamma , 0) attached to method names in object
types. The annotation l+ indicates that method l is only
invocable, l\Gamma  indicates it is only updatable, and l0 indicates
that it is both. These annotations allow finer protection on
the access of methods, and give desirable subtyping properties. Object types are covariant in the types of their +
components, contravariant in the types of their \Gamma  components, and invariant in the types of their 0 components.

Variance annotations naturally fit in the framework of
our interpretation. Namely, we can translate object types
to the same recursive type abstractions with both record
components lsel, lupd for a method l0; only the lsel component for l+; and only the lupd component for l\Gamma .

Self Types
The Self-type construct yields flexible typing for objects
with methods that return objects of the type of self. Extending the notation for object types, we write

Obj (X)[li : BifXg i21:::n]
where Obj binds a type variable X that can occur covariantly in the result types Bi; intuitively the variable X stands
for the type of self, called the Self type. A longer object type
is still a subtype of a shorter one:

Obj (X)[li : Bi i21:::n+m]!:Obj (X)[li : Bi i21:::n]
Recall that in the translation of simple object types given
by Equation 1 we viewed the representation type as the "true

7

Table 4: Translation of the Imperative Object Calculus
hhxiiE = x
hh[li = &(xi : A)bi i21:::n]iiE = letrec create (f1 : A\Lambda !B\Lambda 1) : : : (fn : A\Lambda !B\Lambda n) : A\Lambda  =

let z : CimpA fA\Lambda g = fli = fi i21:::n; clone = nil(fg!A\Lambda ); self = nil(A\Lambda )g
in z \Delta  clone := *(x : fg) create (z \Delta  l1) \Delta  \Delta  \Delta  (z \Delta  ln);

z \Delta  self := fold(A\Lambda ; pack X!: A\Lambda  = A\Lambda  with z : CimpA fXg);
z \Delta  self
in create (*(x1 : A\Lambda )hhb1iiE;x1:A) : : : (*(xn : A\Lambda )hhbniiE;xn:A)
where A j [li : Bi i21:::n]

hha:liiE = open unfold(hhaiiE) as X!:Limpl;B ; x : fl : (X!B\Lambda ); self : Xg

in (x \Delta  l) (x \Delta  self ) : B\Lambda 
where B = hE; ail

hha:l ( &(x : A)biiE = open unfold(hhaiiE) as X!:A\Lambda ; y : CimpA fXg

in fold(A\Lambda ;

pack X0!: A\Lambda  = X
with y \Delta  lj := *(x : X)hhbiiE;x:A : CimpA fX0g) : A\Lambda 

hhclone(a)iiE = open unfold(hhaiiE) as X!:A\Lambda ; x : CimpA fXg

in (x \Delta  clone)(fg)
where A = MinTyhE; ai

hhlet x : A = a in biiE = let x : A\Lambda  = hhaiiE in hhbiiE;x:A

type" of an object. We take this "true type" to be the Self
type; therefore, for A j Obj (X)[li : BifXg i21:::n], we let:

A\Lambda  = 9(X!:A\Lambda )flseli : X!B\Lambda i fXg i21:::n;

lupdi : (X!B\Lambda i fXg)!X i21:::n;
self : Xg

With this straightforward extension, our interpretation accounts for Self types.

Structural Rules
While the subtyping rules for object types assert that a
longer object type is a subtype of a shorter object type,
structural rules arise as consequence of the stronger "structural assumption" that the only subtypes of an object type
are longer object types. An example of such a structural
rule, using the simple object types of Ob1!:, is the following modification of the rule (Val Update) of Table 8:

(Struct Val Update)
For A j [li : Bi i21:::n]

E ` C!:A E ` a : C E; x : C ` b : Bj

E ` a:lj ( &(x : C)b : C

In our interpretation, structural assumptions on object
types are reflected as structural assumptions on recursive
types. Specifically, structural rules for object types are validated if we strengthen the target calculus with a structural
rule for recursive types:

(Struct Val Unfold)

E ` C!:_(X)BfXg E ` a : C

E ` unfold(a) : BfCg

The rule (Struct Val Unfold) can be seen as a consequence
of assuming that any subtype of a recursive type arises

through the reflexivity rule ((Sub Refl) of Table 7) or the
subtyping rule for recursive types ((Sub Rec) of Table 9).
For example, suppose that E ` C!:_(X)BfXg because
of (Sub Rec). Then C is of the form _(X)B0fXg and if
E ` a : C then E ` unfold(a) : B0fCg. Further, we have
that E; Y !: T op; X!:Y ` B0fXg!:BfY g. In particular,
since E ` C!:C, using C for both X and Y we get that
E ` B0fCg!:BfCg and using subsumption we get the consequent of the rule (Struct Val Unfold).

We can see informally how the rule (Struct Val Update)
is validated thanks to (Struct Val Unfold). Assume that
E ` C\Lambda !:A\Lambda  and E ` hhaii : C\Lambda . Using the definition of A\Lambda 
as a recursive type and applying (Struct Val Unfold), we can
conclude that:

E ` unfold(hhaii) : 9(X!:C\Lambda )f: : : ; lupdj : (\Delta  \Delta  \Delta )!X; : : :g

The result of an update is of type C\Lambda , since lupdj returns a
result of type X and X!:C\Lambda . In contrast, with the weaker,
non-structural rule (Val Unfold) of F!:_ (Table 9), we can
conclude only that E ` unfold(hhaii) : 9(X!:A\Lambda )f: : :g and
the result of the update has to be given the weaker type A\Lambda .

5.2 An Enriched Object Calculus
The calculus Obstr!: is an extension of Ob1!: with variance
annotations, Self types, and structural rules. Like the semantics of Ob1!:, the semantics of Obstr!: is free of sideeffects.

The types of Obstr!: are generated by the grammar:

A; B ::= X j Top j Obj (X)[li*i : BifXg i21:::n]
where *i 2 f+; \Gamma ; 0g. As described in Section 5.1, Obj binds
the Self type, and the variance annotation *i specifies the
operations permissible on method li.

8

Table 5: Operational Semantics of Obstr!:
If a j obj (X = A)[li = &(xi : X)bifX; xig i21:::n]; j 2 1 : : : n
(Eval Select) a:lj ; bjfA; ag
(Eval Update) a:lj ( (Y !:A0; y : Y )&(x : Y )bfY; yg ; obj (X = A)[lj = &(x : X)bfX; ag;

li = &(xi : X)bi i2f1:::ng\Gamma fjg]

Because of Self types, the term syntax of Obstr!: is slightly
different from that of Ob1!::

a; b ::= x j obj (X = A)[li = &(xi : X)bi i21:::n]

j a:l j a:l ( (Y !:A; y : Y )&(x : Y )b

An object has the form obj(X = A)[li = &(xi : X)bi i21:::n]
with X standing for the Self type. Method update is written
a:l ( (Y !:A; y : Y )&(x : Y )b where A is a known type for a,
Y denotes the Self type of a, y is bound to the object being
updated (a), and x is the usual self parameter in method b.
The parameter y is useful because it is given type Y while
a has the weaker type A.

The typing rules for Obstr!: are structural. They appear
in Appendix D.

The operational semantics is defined via a reduction system whose redexes are given in Table 5. In the rule for
method update, note that the object a gets substituted for
the parameter y. Apart from this, the only difference from
the corresponding rules of Ob1!: is the type propagation--
the actual type of self gets substituted for the formal type
parameter X standing for the Self type. We denote the
many-step reduction relation for Obstr!: by \Gamma !!os.

5.3 Translation
We translate Obstr!: into an extension Fstr!:_ of F!:_; this
extension has the same operational semantics as F!:_ but
includes a structural rule, namely the rule (Struct Val Unfold) of Section 5.1.

The translation of types combines the ideas for variance
annotations and for Self types described in Section 5.1:

X\Lambda  = X
Top\Lambda  = Top
Obj (X)[li*i : BifXg i21:::n]\Lambda 

= _(Y )9(X!:Y )f(li*i : BifXg)y i21:::n;

self : Xg
for Y not free in the Bi's

where the fields (li*i : BifXg)y are defined by case analysis
on the variance annotation *i as follows:

(l+i : BifXg)y = lseli : X!B\Lambda i fXg
(l\Gamma i : BifXg)y = lupdi : (X!B\Lambda i fXg)!X

(l0i : BifXg)y = (l+i : BifXg)y; (l\Gamma i : BifXg)y

We define the translation of environments as in Section
3.3, with the additional clause (E; X!:A)\Lambda  = E\Lambda ; X!:A\Lambda .

The following theorem states that well-formed environments are mapped to well-formed environments, that wellformed types are mapped to well-formed types, and that the
translation preserves subtyping judgements.

Theorem 5.1

1. If E ` \Pi  is derivable in Obstr!: , then E\Lambda  ` \Pi  is derivable

in F!:_, and a fortiori in Fstr!:_.

2. If E ` A is derivable in Obstr!: , then E\Lambda  ` A\Lambda  is derivable in F!:_, and a fortiori in Fstr!:_.

3. If E ` A!:B is derivable in Obstr!: , then E\Lambda  ` A\Lambda !:B\Lambda 

is derivable in F!:_, and a fortiori in Fstr!:_.

We give the translation of terms in Table 6, using the
following notation:

Notation:

1. For A j Obj (X)[li*i : BifXg], we define:

CstrA fXg 4= f(li*i : BifXg)y i21:::n;

self : Xg

2. For a type A, environment E, and method name l,

we define the Obstr!: type hA; Eil as follows. If A j
Obj (X)[: : : ; l* : BfXg; : : :], then hA; Eil is BfXg. If
A j X (a type variable) and E j E0; X!:A0; E00,
then hA; Eil is hA0; E0il. In all other cases (e.g., for
A j Top), hA; Eil is undefined.

3. As in Section 4.2, the type MinTyhE; ai is the minimum type of a in environment E. (We can prove that
such a minimum type exists in Obstr!: .)

If we omit type annotations then the translation of terms
is basically the same as that described for Ob1!:. The main
novelty of the translation is that it shows that we can attach
suitable type annotations to the untyped terms described in
Section 3.3 so that well-typed terms of Obstr!: get mapped
to well-typed terms of Fstr!:_. The following theorem states
that the translation preserves typing judgements and computational behavior.

Theorem 5.2

1. If E ` a : A is derivable in Obstr!: then E\Lambda  ` hhaiiE : A\Lambda 

is derivable in Fstr!:_.

2. If E ` a : A is derivable in Obstr!: and a\Gamma !!osb then

hhaiiE\Gamma !!f hhbiiE.

9

Table 6: Translation of Obstr!: into Fstr!:_
hhxiiE = x
hhobj(X = A)[li = &(xi : X)bifXg i21:::n]iiE

= letrec create (f1 : A\Lambda !B\Lambda 1 fA\Lambda g) : : : (fn : A\Lambda !B\Lambda nfA\Lambda g) : A\Lambda  =

fold (A\Lambda ;

pack X!:A\Lambda  = A\Lambda 
with flseli = fi i21:::n;

lupdi = *(g : A\Lambda !B\Lambda i fA\Lambda g)

create (f1) : : : (fi\Gamma 1) (g) (fi+1) : : : (fn) i21:::n;
self = create (f1) : : : (fn)g : CstrA fXg)
in create (*(x1 : A\Lambda )hhb1fAgiiE;x1:A) : : : (*(xn : A\Lambda )hhbnfAgiiE;xn:A)

where A j Obj (X)[li*i : BifXg i21:::n]

hha:liiE = open unfold(hhaiiE) as X!:A\Lambda ; x : flsel : (X!B\Lambda fXg); self : Xg

in (x \Delta  lsel)(x \Delta  self ) : B\Lambda fA\Lambda g
where A = MinTyhE; ai; BfXg = hA; Eil

hha:l ( (Y !:A; y : Y )&(x : Y )biiE = open unfold(hhaiiE) as X!:A\Lambda ; z : flupd : (X!B\Lambda fXg)!X; self : Xg

in (z \Delta  lupd)((*(Y !:A\Lambda )*(y : Y )*(x : Y )hhbiiE;Y !:A;y:Y;x:Y ) X (z \Delta  self )) : A\Lambda 
where B = hA; Eil

6 Conclusions
We have presented a new interpretation of objects and object types that preserves subtyping and behavior; its basic
idea works for both functional and imperative semantics.
Our interpretation is more general than previous solutions
in that it handles object-based constructs such as cloning
and method update, as well as the common class-based constructs. Moreover, it is simpler than other proposals in the
sense of being syntax-directed. It is the first interpretation
of this kind.

Our interpretation offers insights into the nature of objects. It describes, in principle, a type-safe way of coding
objects in procedural languages. However, as is the case
even with more limited interpretations, it cannot be used in
actual programming practice because of its pragmatic complexity. This fact confirms the commonly held belief that
object-oriented languages differ significantly from procedural languages in practical expressive power.

References
[AC94a] M. Abadi and Luca Cardelli. A semantics of object

types. In Proceedings of the Ninth Annual Symposium on Logic in Computer Science, pages 332-341,
July 1994.

[AC94b] M. Abadi and Luca Cardelli. A theory of primitive

objects: Untyped and first-order systems. In Theoretical Aspects of Computer Software, pages 296-
320. Springer-Verlag, April 1994.

[AC95a] M. Abadi and L. Cardelli. An imperative object calculus: Basic typing and soundness. In SIPL '95 --
Proceedings of the Second ACM SIGPLAN Workshop on State in Programming Languages. Technical Report UIUCDCS-R-95-1900, Department of
Computer Science, University of Illinois at UrbanaChampaign, January 1995.

[AC95b] Martin Abadi and Luca Cardelli. An imperative object calculus. In P.D. Mosses, M. Nielsen, and M.I.

Schwartzbach, editors, TAPSOFT'95: Theory and
Practice of Software Development, pages 471-485.
Springer-Verlag LNCS 915, May 1995.

[ALBC+93] O. Agesen, C. Chambers L. Bak, B.W. Chang,

U. Holzle, J. Maloney, R.B. Smith, D. Ungar, and
M. Wolczko. The Self 3.0 programmer's reference
manual. Sun Microsystems, 1993.

[And92] B. Andersen. Ellie: a general, fine-grained, firstclass, object-based language. Journal of Object Oriented Programming, 5(2):35-42, 1992.

[App93] Apple Computer, Inc. Apple, The NewtonScript

Programming Language, 1993.

[Car88] L. Cardelli. A semantics of multiple inheritance. Information and Computation, 76:138-164, 1988. Special issue devoted to Symp. on Semantics of Data
Types, Sophia-Antipolis (France), 1984.

[Car95] L. Cardelli. A language with distributed scope.

In Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, 1995.

[Coo89] W.R. Cook. A Denotational Semantics of Inheritance. PhD thesis, Brown University, 1989.

[ESTZ95] J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico.

An interpretation of typed OOP in a language with
state. Lisp and Symbolic Computation, 1995. To
appear.

[HP95] Martin Hofmann and Benjamin Pierce. A unifying type-theoretic framework for objects. Journal of
Functional Programming, 1995. To appear. Previous
version appeared in the Symposium on Theoretical
Aspects of Computer Science, 1994 (pages 251-262).

[Kam88] S. Kamin. Inheritance in Smalltalk-80: a denotational definition. In ACM Symp. Principles of Programming Languages, pages 80-87, 1988.

[Lie81] H. Lieberman. A preview of Act1. Technical Report

AI Memo No 625, MIT, 1981.

[MGV92] B.A. Myers, D.A. Giuse, and B. Vander Zanden.

Declarative programming in a prototype-instance

10

system: object-oriented programming without writing methods. In Proc. OOPSLA '92, pages 184-200,
1992.

[MMPN93] O.L. Madsen, B. Moller-Pedersen, and K. Nygaard.

Object-oriented programming in the Beta programming language. Addison-Wesley, 1993.

[MP88] J.C. Mitchell and G.D. Plotkin. Abstract types have

existential types. ACM Trans. on Programming
Languages and Systems, 10(3):470-502, 1988. Preliminary version appeared in Proc. 12th ACM Symp.
on Principles of Programming Languages, 1985.

[PT94] Benjamin C. Pierce and David N. Turner. Simple

type-theoretic foundations for object-oriented programming. Journal of Functional Programming,
4(2):207-248, 1994.

[R'em94] D. R'emy. Programming Objects with ML-ART, an

extension to ML with Abstract and Record types. In
Theoretical Aspects of Computer Software. SpringerVerlag, April 1994.

[Tai92] A. Taivalsaari. Kevo, a prototype-based objectoriented language based on concatenation and module operations. Technical Report LACIR 92-02, University of Victoria, 1992.

Appendix
In this appendix we summarize several calculi, giving both
grammars and rules. We often use assertions of the form
E ` Ji 8i 2 1 : : : n to indicate n hypotheses; by convention,
this means E ` \Pi  when n = 0.

A The Ob1!: Calculus
The calculus Ob1!: consists of the rules given in Tables 7
and 8. It has the following syntax:

Environments E ::= ; j E; x : A
Types A; B ::= Top j [li : Bi i21:::n]
Variables x; y

Terms a; b ::= x j [li = &(xi : A)bi i21:::n]

j a:l j a:l ( &(x : A)b
Results v ::= [li = &(xi : A)bi i21:::n]

B The F!:_ Calculus
The calculus F!:_ consists of the rules given in Tables 7 and
9. It has the following syntax:

Environments E ::= ; j E; x : A j E; X!:A
Type Variables X; Y
Types A; B; C ::= X j Top j A!B

j fli : Bi i21:::ng j _(X)A
j 8(X!:A)B j 9(X!:A)B
Variables x; y
Terms a; b; c; d ::= x j *(x : A)b j a(b)

j fli = bi i21:::ng j a \Delta  l
j fold(A; b) j unfold(a)
j *(X!:A)b j b(A)
j pack X!:A = C with b : BfXg
j open c as X!:A; x : B in d : D
Results v ::= *(x : A)b j fli = bi i21:::ng

j fold(A; v) j *(X!:A)b
j pack X!:A = C with b : BfXg

Other definitions of the set of results could be adopted.

The one given here is convenient for our adequacy theorem;
it is however not particularly compelling. Fortunately our
techniques are not too sensitive to changes in the definition
of the set of results.

C The Imperative Variant of Ob1!:
The typed imperative object calculus contains all the rules
of Ob1!: (described in Appendix A) and contains the typing rules given in Table 10 for its additional terms. As
for Ob1!:, we can prove a minimum-types property for the
typed imperative calculus. (This is a convenient departure
from the original calculus of [AC95a]: the terms described
here contain more type information.) The syntax is:

Environments E ::= ; j E; x : A
Types A; B ::= Top j [li : Bi i21:::n]
Variables x; y
Terms a; b ::= x j [li = &(xi : A)bi i21:::n]

j a:l j a:l ( &(x : A)b
j clone(a)
j let x : A = a in b

D The Obstr!: Calculus
The calculus Obstr!: consists of the rules given in Table 7, the
rules (Env X), (Type X), (Sub X) given in Table 9, and the
rules of Table 11. It has the following syntax:

Environments E ::= ; j E; x : A j E; X!:A
Type Variables X; Y
Types A; B ::= X j Top

j Obj (X)[li*i : Bi i21:::n]
with *i 2 f+; \Gamma ; 0g
Variables x; y
Terms a; b ::= x

j obj(X =A)[li =&(xi :X)bi i21:::n]
j a:l
j a:l ( (Y !:A; y : Y )&(x : Y )b

11

Table 7: Common Typing Rules
Environments
(Env ;) ; ` \Pi  (Env x) E ` AE; x : A ` \Pi  ; x 62 dom(E)

Subtyping

(Sub Refl) E ` AE ` A!:A (Sub Trans) E ` A!:B E ` B!:CE ` A!:C

(Val Subsmp) E ` a : A E ` A!:BE ` a : B

Top
(Type Top) E ` \Pi E ` Top (Sub Top) E ` AE ` A!:Top

Variable Typing
(Val x) E

0; x : A; E00 ` \Pi 

E0; x : A; E00 ` x : A

Table 8: Additional Typing Rules for Ob1!:
Object Types and Subtyping
(Type Object) E ` Bi 8i 2 1 : : : nE ` [l

i : Bi i21:::n] (Sub Object)

E ` Bi 8i 2 1 : : : n + m
E ` [li : Bi i21:::n+m]!:[li : Bi i21:::n]

Term Typings

(Val Object) E; xi : A ` bi : Bi 8i 2 1 : : : nE ` [l

i = &(xi : A)bi i21:::n] : A ; A j [li : Bi

i21:::n]

(Val Select) E ` a : [li : Bi

i21:::n]

E ` a:lj : Bj ; j 2 1 : : : n

(Val Update) E ` a : A E; x : A ` b : BjE ` a:l

j ( &(x : A)b : A ; A j [li : Bi

i21:::n]; j 2 1 : : : n

12

Table 9: Additional Typing Rules for F!:_
Environments
(Env X) E ` AE; X!:A ` \Pi  ; X 62 dom(E)

Types

(Type X) E

0; X!:A; E00 ` \Pi 

E0; X!:A; E00 ` X (Type !)

E ` A E ` B

E ` A!B

(Type Record) E ` Bi 8i 2 1 : : : nE ` fl

i : Bi i21:::ng (Type Rec)

E; X!:Top ` A

E ` _(X)A

(Type All) E; X!:A ` BE ` 8(X!:A)B (Type Exists) E; X!:A ` BE ` 9(X!:A)B

Subtyping

(Sub X) E

0; X!:A; E00 ` \Pi 

E0; X!:A; E00 ` X!:A (Sub !)

E ` A0!:A E ` B!:B0

E ` A!B!:A0!B0

(Sub Record) E ` Bi!:B

0i; 8i 2 1 : : : n E ` Bi; 8i 2 n + 1 : : : n + m

E ` fli : Bi i21:::n+mg!:fli : B0i i21:::ng

(Sub Rec) E ` _(X)A E ` _(Y )B E; Y !:Top; X!:Y ` A!:BE ` _(X)A!:_(Y )B

(Sub All) E ` A

0!:A E; X!:A0 ` B!:B0

E ` 8(X!:A)B!:8(X!:A0)B0 (Sub Exists)

E ` A!:A0 E; X!:A ` B!:B0

E ` 9(X!:A)B!:9(X!:A0)B0

Term Typings

(Val Fun) E; x : A ` b : BE ` *(x : A)b : A!B (Val Appl) E ` b : A!B E ` a : AE ` b(a) : B

(Val Record) E ` bi : Bi 8i 2 1 : : : nE ` fl

i = bi i21:::ng : fli : Bi i21:::ng

(Val Record Select) E ` a : fli : Bi

i21:::ng

E ` a \Delta  lj : Bj ; j 2 1 : : : n

(Val Fold) E ` b : BfAgE ` fold(A; b) : A ; A j _(X)BfXg

(Val Unfold) E ` b : AE ` unfold(b) : BfAg ; A j _(X)BfXg

(Val Fun2) E; X!:A ` b : BE ` *(X!:A)b : 8(X!:A)B (Val Appl2) E ` b : 8(X!:A)B E ` A

0!:A

E ` b(A0) : BfA0g

(Val Pack) E ` C!:A E ` bfCg : BfCgE ` pack X!:A = C with bfXg : BfXg : 9(X!:A)BfXg

(Val Open) E ` c : 9(X!:A)B E ` D E; X!:A; x : B ` d : DE ` (open c as X!:A; x : B in d : D) : D

Table 10: Additional Typing Rules for the Imperative Calculus

(Val Clone) E ` a : [li : Bi

i21:::n]

E ` clone(a) : [li : Bi i21:::n]

(Val Let) E ` a : A E; x : A ` b : BE ` let x : A = a in b : B

13

Table 11: Additional Typing Rules for Obstr!:
Variance Subtypings
(Sub Covariant) E ` B!:B

0 * 2 f0; +g

E ` *B!:+B0 (Sub Contravariant)

E ` B0!:B * 2 f0; \Gamma g

E ` *B!:\Gamma B0

(Sub Invariant) E ` BE ` 0B!:0B

Object Types and Subtyping
(Type Object) E; X!:Top ` BifXg 8i 2 1 : : : nE ` Obj (X)[l

i*i : Bi i21:::n] ; *i 2 f

+; \Gamma ; 0g; Bi covariant in X

(Sub Object) For A j Obj (X)[li*i : BifXg i21:::n+m]; A0 j Obj (X)[li*0i : B0ifXg i21:::n]

E; Y !:A ` *iBifY g!:*0iB0ifY g 8i 2 1 : : : n

E ` A!:A0

Term Typings

(Val Object) E; xi : A ` bifAg : BifAg 8i 2 1 : : : nE ` obj (X = A)[l

i = &(xi : X)bifXg i21:::n] : A ; A j Obj (X)[li*i : BifXg

i21:::n]

(Struct Val Select) For A0 j Obj (X)[li*i : BifXg i21:::n]; *j 2 f+; 0g; j 2 1 : : : n

E ` a : A E ` A!:A0

E ` a:lj : BjfAg

(Struct Val Update) For A0 j Obj (X)[li*i : BifXg i21:::n]; *j 2 f\Gamma ; 0g; j 2 1 : : : n

E ` a : A E ` A!:A0 E; Y !:A; y : Y; x : Y ` b : BjfY g

E ` a:lj ( (Y !:A; y : Y )&(x : Y )b : A

14