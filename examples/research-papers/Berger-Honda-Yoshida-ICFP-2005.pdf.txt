

A Logical Analysis of Aliasing in ImperativeHigher-Order Functions
Martin Berger Kohei Honda

Queen Mary, University of London

Nobuko Yoshida
Imperial College London

Abstract
We present a compositional program logic for call-by-value imper-ative higher-order functions with general forms of aliasing, which

can arise from the use of reference names as function parameters,return values, content of references and parts of data structures.
The program logic extends our earlier logic for alias-free impera-tive higher-order functions with new modal operators which serve
as building blocks for clean structural reasoning about programsand data structures in the presence of aliasing. This has been an
open issue since the pioneering work by Cartwright-Oppen andMorris twenty-five years ago. We illustrate usage of the logic for
description and reasoning through concrete examples including ahigher-order polymorphic Quicksort. The logical status of the new
operators is clarified by translating them into (in)equalities of refer-ence names. The logic is observationally complete in the sense that
two programs are observationally indistinguishable iff they satisfythe same set of assertions.

Categories and Subject Descriptors F.3.1 [Specifying and Veri-fying and Reasoning about Programs]: Assertions, logics of programs, specification techniquesGeneral Terms

Languages, Reliability, Security, Theory, Verifi-cation

Keywords Hoare-Logics, Modalities, Aliasing, Pointers, Typing,Functional Programming, p-Calculus

1. Introduction
In high-level programming languages names can be used to indicateeither stateless entities like procedures, or stateful constructs such

as imperative variables. Aliasing, where distinct names refer to thesame entity, has no observable effects for the former, but strongly
affects the latter. This is because if state changes, that changeshould affect all names referring to that entity. Consider

P def= x := 1; y :=!z; !y := 2,
where, following ML notation, !x stands for the content of animperative variable or reference x. If z stores a reference name x

initially, then the content of x after P runs is 2; if z stores somethingelse, the final content of x is 1. But if it is unclear what z stores,
we cannot know if !y is aliased to x or not, which makes reasoning

Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.
ICFP'05 September 26-28, 2005, Tallinn, Estonia.Copyright cfl 2005 ACM 1-59593-064-7/05/0009. . . $5.00.

difficult. Or consider a program

Q def= ly.(x := 1; y := 2).
If Q is invoked with an argument x, the content of x ends up as2, otherwise it stays 1. In these examples, what have been syntactically distinct reference names in the program text may be coa-lesced during execution, making it difficult to judge which name
refers to which store from the program text alone. The situationgets further complicated with higher-order functions because programs with side effects can be passed to procedures and stored inreferences. For example let:

R def= l(f xy). ( let z =!x in !x := 1; !y := 2; f (x,y); z := 3 )
where a = Ref (Ref (Nat)). R receives a function f and two ref-erences x and y. Its behaviour is different depending on what it

receives as f (for simplicity let's assume x and y store distinct ref-erences). If we pass a function lxy

.() as f , then, after execution,!x stores 3 and !y stores 2. But if the standard swapping function

swap def= lab.let c =!b in (b :=!a;a := c) is passed, the contentof x and y is swapped and !x now stores 2 while !y stores 3. Such
interplay between higher-order procedures and aliasing is commonin many non-trivial programs in ML, C and more recent typed and
untyped low-level languages [1, 17, 38].Hoare logic [20], developed on the basis of Floyd's assertion
method [14], has been studied extensively as a verification methodfor first-order imperative programs with diverse applications. However Hoare's original proof system is sound only when aliasing isabsent [4, 11]: while various extensions have been studied, a general solution which extends the original method to treat aliasing,retaining its semantic basis [15, 21] and tractability, has not been
known, not to speak of its combination with arbitrary imperativehigher-order functions (our earlier work [24] extends Hoare logic
with a treatment for a general class of higher-order imperative func-tions including stored procedures, but does not treat aliasing).

Resuming studies by Cartwright-Oppen and Morris from 25years ago [9, 10, 33], the present paper introduces a simple and
tractable compositional program logic for general aliasing and im-perative higher-order functions. A central observation in [9, 10, 33]
is that (in)equations over names, simple as they may seem, are ex-pressive enough to describe general aliasing in first-order procedural languages, provided we distinguish between reference names(which we write x) and the corresponding content (which we write
!x) in assertions. In particular, their work has shown that alias ro-bust substitution, written C{|e

/!x|} in our notation, defined by:

M |=C{|e/!x|} iff M [x 7![[e]]M] |= C (1)
(i.e. an update of a store at a memory cell referred to by x withvalue e), can be translated into (in)equations of names through

inductive decomposition of C, albeit at the expense of an increase

280

in formula size. This gives us the following semantic version ofHoare's assignment axiom:

{C{|e/!x|}}x := e{C} (2)
where the pre-condition in fact stands for the translated form men-tioned above. The rule subsumes the original axiom but is now

alias-robust. As clear evidence of descriptive power of this ap-proach, Cartwright and Oppen showed that the use of (2) leads
to a sound and (relatively) complete logic for a programming lan-guage with first-order procedures and full aliasing [9, 10]: Morris showed many non-trivial reasoning examples for data structureswith destructive update, including the reasoning for Schorr-Waite
algorithm [33].The works by Cartwright-Oppen and Morris, remarkable as they
are, still beg the question how to reason about programs with alias-ing in a tractable way. The first issue is calculation of validity in
assertions involving semantic substitutions. This is hardly practi-cal because inductive decomposition of {|e

/!x|} into (in)equationshas been the only syntactic tool available. As demonstrated through

many examples by Morris [33] and, more recently, Bornat [7], thisdecomposition should be distributed to every part of a given formula even if that part is irrelevant to the state change under consid-eration, making reasoning extremely cumbersome. As one typical
example, if we use the decomposition method for calculating thelogical equivalence

C{|c/!x|}{|e/!x|} j C{|c/!x|}
for general C, with c being a constant, we need either meta-logicalreasoning, induction on C, or an appeal to semantic means. Because such logical calculation is a key part of program proving(cf. [20]), practical usability of this approach becomes unclear. The
second problem is the lack of structured reasoning principles forderiving precise description of extensional program behaviour with
aliasing. This makes reasoning hard, because properties of com-plex programs often depend crucially on how sub-programs interact through shared, possibly aliased references. Finally, the logicsin [9, 10, 33] and their successors do not offer a general treatment
of higher-order procedures as well as mutable data structures whichmay store such procedures.

We address these technical issues by augmenting the logic forimperative higher-order functions introduced in [24] with a pair of
mutually dual logical primitives called content quantifiers. They of-fer an effective middle layer with clear logical status for reasoning
about aliasing. The existential part of the primitives, written h!xiC,is defined by the following equivalence:

M |= h!xiC defj 9V.(M [x 7!V ] |= C) (3)
The defining clause says: "for some possible content of a referencenamed x, M satisfies C" (which may not be about the current state,

but about a possible state, hence the notation). Syntactically h!xiCdoes not bind free occurrences of x in C. Its universal counterpart
is written [!x]C, with the obvious semantics.We mention a couple of notable aspects of these operators.
First, introduction of these operators gives us a tractable methodfor logically calculating assertions with semantic update, solving a
central issue posed by Cartwright-Oppen and Morris 25 years ago.We start from the following syntactic representation of semantic
update using the well-known decomposition:

C{|e/!x|} j 9m.(h!xi(C ^!x=m) ^ m=e). (4)
From (3) and (4), the logical equivalence (1) is immediate, recov-ering (2) as a syntactic axiom. Not only does C{|e

/!x|} now haveconcrete syntactic shape without needs of global distribution of update operations, but also these operators offer a rich set of logicallaws coming from standard quantifiers and modal operators, enabling efficient and tractable calculation of validity while subsum-ing Cartwright-Oppen/Morris's methods. Intuitively this is because
logical calculation can now focus on those parts which do get af-fected by state change: just like lazy evaluation, we do not have
to calculate those parts which are not immediately needed. In latersections we shall demonstrate this point through examples.

Closely related with its use in logical calculation is a powerfuldescriptive/reasoning framework enabled by content quantification,
in conjunction with standard logical primitives. By allowing hypo-thetical statements about the content of references separate from
reference names themselves (which is the central logical feature ofthese operators), complex aliasing situations are given clean, succinct description, combined with effective compositional reason-ing principles. This is particularly visible when we describe and
reason about disjointness and sharing of mutable data structures(in this sense it expands the central merits of "separating connectives" [34, 37], as we shall discuss in later sections). The primi-tives work seamlessly with the logical machinery for capturing pure
and imperative higher-order behaviour studied in [22, 23, 24], en-abling precise description and efficient reasoning for a large class of
higher-order behaviour and data structures. The descriptive powerof the logic is formally clarified in Section 4 by showing the assertion language is observationally complete in the sense that twoprograms are contextually indistinguishable exactly when they satisfy the same set of assertions.Third, and somewhat paradoxically, these merits of content
quantification come without any additional expressive power: anyformula which contains content quantification can be translated,
up to logical equivalence, into one without. While establishing thisresult, we shall also show that content quantification and semantic
update are mutually definable. Thus name (in)equations, contentquantification and semantic update are all equivalent in sheer expressive power: the laws of content quantification are reducible tothe standard axioms for the predicate calculus with equality, which
in turn are equivalent to semantic update through its axioms fordecomposition. This does not however diminish the significance
of content quantification: without identifying it as a proper logi-cal primitive with associated axioms, it is hard to consider its use
in reasoning, both in logical calculation and in its applications tostructured reasoning for programs and data structures in the presence of general aliasing. To our knowledge [2, $10], neither thecalculation method nor the reasoning principle proposed in the
present paper is discussed in the foregoing work.In the remainder, Section 2 introduces the programming/assertion languages. Section 3 presents axioms and proof rules. Section4 records key technical results on the logic. Section 5 illustrates
the use of the logic through concrete reasoning examples includinga higher-order, polymorphic Quicksort. Section 6 discusses related
work (including earlier logics for sublanguages of Algol and morerecent ones such as Separation Logic) and concludes with further
issues. A full version [2] contains detailed proofs, further examplesand an extensive historical survey.

2. Assertions and their Semantics
2.1 Programming Language.
As a target programming language, we use call-by-value PCF withunit, sums and products, augmented with imperative constructs

[35]. Let x,y,... range over an infinite set of names. Then types,values and programs are given by the following grammar.

a ::= Unit | Bool | Nat | a)b | a * b | a + b | Ref (a)
V ::= c | x | lxa.M | u f a)b.lya.M | hV,W i | ini(V )

M ::= V | MN | M := N | !M | op( ~M) | pi(M) | hM,Ni | ini(M)|

if M then M1 else M2 | case M of {ini(xaii ).Mi}i2{1,2}

281

We use standard boolean/arithmetic constants and operations, resp.ranged over by

c and op. Types can carry reference types: henceprocedures, references and data structures may pass/return/store

reference names, leading to general forms of aliasing as discussedin the Introduction. We freely use obvious shorthands like M;N and
let x = M in N.A basis \Gamma ;\Delta  is a pair of finite maps one from names to nonreference types (\Gamma ,..., called environment basis) and the other fromnames to reference types (\Delta 

,..., called reference basis). \Theta ,\Theta 0,...combine two kinds of bases. The typing rules are standard and

omitted [35]. We write \Gamma ;\Delta  ` M : a when M has type a under \Gamma ;\Delta .A program is semi-closed if its environment basis is empty,
written \Delta  ` M : a. A store (s,...) is a finite map from referencenames to semi-closed values, to which the typing extends in the
obvious way. Using configurations of the form (M, s) with semi-closed M and store s typable under a common basis, the call-byvalue, one step reduction, written (M,s) -! (M0,s0), is definedin the standard way [18, 35]. We write

(M,s) + if 9V,s0. (M,s) -!* (V,s0) 6-! .
Henceforth we only consider well-typed programs and configura-tions.

2.2 Models.
We introduce a class of models which concisely represent compu-tational situations of interest. We follow our previous work [24]

except for the additional use of distinctions to describe aliasing, aninnovation coming from the p-calculus [32]. Our models are immediately faithful to the observable behaviour of programs, whichis important for our logic's observational completeness, established
later.A distinction over \Delta  (D

,...) is a type-respecting equivalencerelation over
dom(\Delta ). The equivalence classes of a distinction arecalled its identicals (i

,j,...). The point of using distinctions is tohave a modular way of specifying in the model which references

are aliased (those in the same identical) and which are not. Let\Delta  ` M : a and let D be a distinction over \Delta . Regarding identicals of
D as names, we can substitute a D-identical i for each name x 2 i inM, which we write MD. Intuitively, MD is a program whose names
are coalesced following D. MD is typed by \Delta D, which is defined
similarly. For example, given M def= if x = y then 0 else 1, if Donly equates x and y then we have

MD def= if i = i then 0 else 1 (assuming i def= {x,y}),
Note MD reduces as (MD,s) -! (0,s) which is quite differentfrom M itself, showing that distinctions affect observable behaviour

of programs.A typed context C[ * ]

\Gamma ;\Delta ;a is a context with a hole typed with aunder \Gamma ;\Delta . A typed context is semi-closing if it does not l-abstract

any reference name in the hole and the resulting program is semi-closed. \Delta  is complete if, whenever

Ref (a) occurs in a type in \Delta 'srange, there is a name of that type in \Delta . Let \Delta  be complete and D

be a distinction over \Delta  and assume \Gamma ;\Delta  ` M1,2 : a. Then we write

\Gamma ;\Delta  ` M1 ,=D M2 : a iff ((C[M1D],s) + iff (C[M2D],s) +)
for all semi-closing C[ * ]\Gamma ;\Delta ;a and well-typed stores s. The stan-dard contextual congruence [35], which we denote by ,=, coincides

with the closure of ,=D under arbitrary distinctions.An abstract value of type (D;\Delta ;a) is a ,=

D-congruence classof semi-closed values which are typed as a under \Delta . We let v,

w,... range over abstract values. In short, abstract values are semi-closed values taken modulo the typed congruence relative to a given
distinction. Since reference names are values, identicals are alsoabstract values (of appropriate types). We write [V ]D;\Delta ;a for an

abstract value whose representative is V , and [[a]]\Delta D for the set ofall abstract values of type (D;\Delta ;a). We can now define a model.
Definition 1 A model of type \Gamma ;\Delta , written M \Gamma ;\Delta , is a triple(D

,x,s) where

* D is a distinction on \Delta ;*

x, called environment, is a finite map from dom(\Gamma ,\Delta ) to ab-stract values which is type-respecting in the sense that each x 2

dom(\Gamma ,\Delta ) is mapped to an abstract value of type D;\Delta ;\Gamma (x);* s

, called (abstract) store, is a finite map from the identicalsof D to abstract values which is type-respecting in the sense

that each i 2 D is mapped to an abstract value of type D;\Delta ;aassuming (\Delta D)(i) =

Ref (a).

2.3 Syntax of Assertions.
The logical language is standard first-order logic with equality [31,$ 2.8], extended with assertions for evaluation with side effects

[24] and quantifications over store content. Let ? 2 {^,.,oe} andQ 2 {8

,9}. We highlight changes from [24].

e ::= xa | () | n | b | op( ~e) | he,e0i | pi(e) | inja+bi (e) | !e
C ::= e = e0 | ~C | C ?C0 | Q x.C | {C} e * e0 = x {C0}|

[!e]C | h!eiC
The first set of expressions (ranged over by e,e0,...) are terms whilethe second set are formulae (ranged over by A

,B,C,C0 ...). Theconstants include unit, numerals and booleans, while

op( ~e) rangesover first-order operations, both coming from the underlying programming language. We also have pairing, projection and injection,again corresponding to those in the target programming language.
The final term !e dereferences e. Unlike in [24], quantification canabstract variables of all types including references. We also use
truth T (definable as 1 = 1) and falsity F (which is ~T). Finally,x 6= y stands for ~(x = y).

The formula {C} e * e0 = x {C0} is called evaluation formula[24], where the name x binds its free occurrences in C0. Intuitively,
{C} e*e0 = x {C0} asserts on the evaluation of an application withpre/post conditions, and can be read:

an invocation of e with an argument e0 under hypotheticalinitial state C (pre-condition) terminates with a final state
and a resulting value, the latter named x, both described byC0 (post-condition).

The pre/post conditions are about hypothetical state since we oftenneed to describe imperative behaviour independent from a current
state. For example,

!x = 1 ^ 8i.8 j.{!x = i} f * j = z {z =!x = i + j}
asserts that (1) the current content of x is 1; and (2) if, hypothet-ically, the content of x is i and f is invoked with j, then the return value and the resulting content of x are both i + j. Note thate*e0 = x in {C} e*e0 = x {C0} is asymmetric and * is not commutative. 1 Content quantifications h!ei and [!e] are illustrated throughexamples later.

fv(C) denotes the set of free variables in C. C-~x in-dicates
fv(C) " { ~x} = /0. Binding in formulae is induced only bystandard quantifiers, 8, 9, and by evaluation formulae. In particular, fv(h!eiC) = fv([!e]C) = fv(e) [ fv(C). Formulae are taken upto a-convertibility (some care is needed to avoid name capture, as
illustrated in [2, $5.2], though all concrete examples in this papercan be read without this concern).

Starting from variables, each term can be typed inductively.Using typed terms is not strictly necessary but contributes to clarity

1 In [24], we wrote {C} e * e0 & x {C0} instead of {C} e * e0 = x {C0}.

282

and understandability. We write \Theta  ` e : a when e has type a under\Theta . We also write \Theta  ` C when terms in C are well-typed under
\Theta . Henceforth we only treat well-typed terms and formulae. Typeannotations for variables are often omitted in examples.

Logical substitution plays an important role in the present logic.We define, with m fresh:

C{|e2/!e1|} def= 9m.(h!e1i(C ^ !e1 = m) ^ m = e2).
Intuitively C{|e2/!e1|} describes the situation where a model satis-fying C is updated at a memory cell referred to by e

1 (of a referencetype) with a value e
2 (of its content type), with e1,2 interpreted inthe current model. Through the help of axioms discussed later, logical substitution interacts with content quantification just as syntac-tic substitution does with conventional quantification. For example,
[!x]C oe C{|e/!x|} for any x, e and C, which corresponds to the fa-miliar 8x

.C oe C[e/x]. C{|e/!x|} oe h!xiC also holds, correspondingto the standard entailment C[e

/x] oe 9x.C.

Convention Logical connectives are used with standard prece-dence/association, with content quantification given the same

precedence as standard quantification (i.e. they associate strongerthan binary connectives). For example, ~A ^ B oe 8x

.C . h!eiD oe Eis a shorthand for ((~A) ^ B) oe (((8x
.C) . (h!eiD)) oe E).C

1 j C2 stands for (C1 oe C2) ^ (C2 oe C1). Similarly,* {

C}e * e0{C0} stands for {C}e * e0 = x{x = () ^ C0} with x 62fv(C0); and

* {C}e * e0 = e00{C0} for {C}e * e0 = x{x = e00 ^ C0} with x 62

fv(C0) [ fv(e00) and e00 not a variable.

Formulae are often called assertions.
2.4 Semantics of Assertions.
The interpretation of terms, written [[e]]M , is straightforward andomitted. The defining clauses for the satisfaction relation is standard [31] (e1 = e2 is interpreted by the identity; connectives are in-terpreted classically [23, 22, 24]), except: M |= {C}e * e0 = x{C0}
is given following [24] (to wit: "if the given environment and anyhypothetical state together satisfy C, then the application of [[e]]

Mto [[e0]]
M converges to a value (named x) and a state which togethersatisfy C"); whereas standard and content quantifications are interpreted as:*

M |= 8xa.C if M 0 |= C for each M 0 such that M <=x:a M 0.*
M |= 9xa.C if M 0 |= C for some model M 0 such that M <=x:aM 0.

* M |= [!eRef(a)].C if [[e]]M = [[x]]M and for each V 2 [[a]]\Delta D we

have M [x 7! V ] |= C.

* M |= h!eRef(a)i.C if [[e]]M = [[x]]M and some V 2 [[a]]\Delta M exists

with M [x 7! V ] |= C.

Above M <=x:a M 0 means that M 0 is exactly like M , except thatthe former has an additional entry for x (in detail: one new entry

for x is added to the environment; if x has a reference type, it mayeither be adjoined to an existing identical or form a new identical
for which a new entry is added to the store). M [x 7! V ], with x areference name in M , is exactly like M except that it stores [V ] at
the identical containing x.
2.5 Examples of Assertions
We illustrate usage of our assertion language through simple exam-ples. Throughout we assume x

,y,z are typed as Ref (Nat), while i, jare typed as
Nat, unless otherwise stated.

1. (dereference) The assertion x = 2 with x typed as Nat, says thata (functional) variable has the value 2. The assertion !x = 2 says

the content of a reference named x is 2. Finally the assertion!!x = 2 with x typed as

Ref (Ref (Nat)), says that the contentof a reference which is itself the content of a reference, the last

one named x, is 2.
2. (content quantification, 1) A simple formula using existentialcontent quantification is h!xi!x = 3. It is equivalent to

T becauseall it says is that x can possibly store 3, which is surely true

regardless of its current value (just as 9i.i = 3 is always true).Dually [!x]!x = 3 is equivalent to

F since it claims that x stores3 whatever value x may store, which is impossible regardless

of the current content of x (just as 8i.i = 3 is a contradictorystatement).

3. (content quantification, 2) Consider h!xi!y = 3. Since if x andy are equal the content of both references are hidden, and

because !y = 3 is equivalent to (x = y^!x = 3).(x 6= y^!y = 3),the assertion h!xi!y = 3 is equivalent to x = y . (x 6= y^!y =
3) hence to x 6= y oe!y = 3. Next consider [!x]!y = 3. It sayswhatever natural number a reference named x may store, the
number stored in y is 3. For this to hold, it is sufficient andnecessary that x and y name distinct memory cells and that the
content of y is 3. Thus the assertion is logically equivalent tox 6= y ^ !y = 3. In general, the assertion h!eiC claims C holds
for the content of a reference qualified in C if that reference isdistinct from e; whereas [!e]C claims C holds and any reference
whose content is discussed in C is distinct from e.
4. (swap, 1) Recall swap def= l(x,y).let z =!x in (x :=!y;y := z)from the Introduction. The behaviour of this program, named u,

can be described by the following assertion.

8xyi j.{!x = i^!y = j}u * (x,y){!x = j^!y = i} (5)
Above and henceforth we use an evaluation formula with mul-tiple arguments for readability.

5. (swap, 2) swap above in fact works for a pair of references ofan arbitrary type, and is indeed typable as such in polymorphic

programming languages like ML and Haskell. Following [23],we can capture its polymorphic behaviour by adding 8X

.C (anddually 9X
.C) to the assertion language, with the grammar oftypes extended with type variables (X

, Y,...) and quantifiers(8X
.a and 9X.a). With this extension, we can refine (5).

8X.8xRef(X).8yRef(X).8iX.8 jX.{!x = i^!y = j}u * (x

,y){!x = j^!y = i} (6)

The assertion should be readable naturally. Types in assertionsare interpreted syntactically, incorporating a map from type

variables to closed types to the environment part of models [23].
6. (swap 3) The assertions (5) and (6) may not fully capture thebehaviour of

swap in that they do not say swap only modifiesthe content of references it receives as arguments (which can be

crucial if we are to use swap as part of a larger program). Tocapture this property, we may assert, refining (5):

8Y.8zRef(Y).8hY.8xyi j. (z6=xy oe{!x=i ^ !y= j ^ !z=h} u * (x

,y) {!x= j ^ !y=i ^ !z=h}) (7)

Above "z 6= xy" stands for "z 6= x^z 6= y", similarly henceforth.z

, j are polymorphically typed since we wish to say any refer-ence of any type except xy are left unmodified. The assertion

(7) now captures the whole observable behaviour of (monomor-phic)

swap in the sense that any program satisfying the asser-tion is observationally congruent to

swap under arbitrary dis-tinctions. Since (7) is slightly verbose, we may wish to use a

shorthand, writing:

8xyi j. {!x = i^!y = j}u * (x,y){!x = j^!y = i} @ xy (8)

283

which formally stands for (7) (note the translation is mechani-cal). The general form of this construction is:

{C}e * e0 = x{C0} @ {e0,e1,...,en-1} (9)
where {e0,e1,...,en-1} (usually written as a sequence, as in(8)) is a finite set of terms of reference types, called write set,

in which dereferences should not occur as subterms. The short-handed form (9) is called located assertion and used extensively
from now on.
7. (double) Let double? def= l(x,y).(x :=!x+!x; y :=!y+!y). Obvi-ously

double? will double the content of each of its two argu-ment only if x and y are distinct. We give a located assertion for

double?, named u.8

xyih.{
!x = i^ !y = j ^ x 6= y} u * (x,y) {!x = 2 * i^ !y = 2 * j} @ xy.(10)

This specification doesn't talk about the case x = y. A full
specification of double? is given as, with A def= !x = i^ !y = j:8

xyi j.{
A}u*(x,y){(x = y^!x = 4i) . (x 6= y^!x = 2i^!y = 2 j)}@xy(11)

Specification (11) suggests how we may refine this program sothat it becomes robust w.r.t aliasing. Let:

double! def= l(x,y).if x = y then x :=!x+!x

else x :=!x+!x; y :=!y+!y.

The program now meets the "expected" specification obtainedby deleting "x 6= y" from the precondition of (10). The relationship between semantics of a program and its specification isclarified by observational completeness discussed in Section 4.

3. Proof Rules and Axioms
3.1 Judgement and its Validity.
A judgement consists of a program and a pair of formulae followingHoare [20], augmented with a fresh name called anchor [23, 22,

24], written {C} M\Gamma ;\Delta ;a :u {C0}. This sequent is used for bothvalidity and provability. If we wish to be specific, we prefix it with
either ` (for provability) or |= (for validity). In {C} M\Gamma ;\Delta ;a :u {C0}:

* u is the anchor of the judgement, which should not be in

dom(\Gamma ,\Delta ) [ fv(C); and*

C is the pre-condition and C0 is the post-condition.

An anchor is used to name the value resulting from M, and spec-ifies its behaviour. As in Hoare logic, the distinction between primary and auxiliary names plays an important role in our logic. In{C} M\Gamma ;\Delta ;a :

u {C0}, the primary names are dom(\Gamma ,\Delta )[ {u}, whilethe auxiliary names are those free names in C and C0 which are not

primary. Henceforth we assume judgements are always well-typed,in the sense that, in {C} M\Gamma ;\Delta ;a :

u {C0},

\Gamma ,\Delta ,\Theta  ` C and \Gamma ,u : a,\Delta ,\Theta  ` C0 such that dom(\Theta ) "(

dom(\Gamma ,\Delta ) [ {u}) = /0.

As a convenient notation, when a = Unit, we write {C}M\Gamma ;\Delta ;a{C0}for {

C}M\Gamma ;\Delta ;a :u {C0} with u 62 fv(C0), recovering a Hoare triple[20]. Validity of judgement is given by the following clause.

Definition 2 (validity of judgement) We say {C} M\Gamma ;\Delta  :m {C0} is
valid, written |= {C} M\Gamma ;\Delta  :m {C0}, if, whenever (D, x, s)\Gamma 0;\Delta 0 |= C,we have (Mx

,s) + (v,s0) such that (D,x*m : v,s0) |= C0, for each\Gamma 0 and \Delta 0 which respectively extend (i.e. are supersets of) \Gamma  and \Delta .

[Var] -{C[x/u]} x :u {C} [Const] -{C[c/u]} c :u {C}
[In1] {C} M :v {C0[in1(v)/u]}{C} in1(M) :u {C0} [Proj1] {C} M :m {C0[p1(m)/u]}{C} p1(M) :u {C0}

[Case] {C~x} M :m {C-~x0 } {C0[ini(xi)/m]} Mi :u {C0 -~x}{

C} case M of {ini(xi).Mi}i2{1,2} :u {C0}

[Add] {C}M1 :m1 {C0} {C0}M2 :m2 {C0[m1 + m2/u]}{C}M1 + M2 :u {C0}

[Abs] {C ^ Ax} M :m {C0}{

A} lx.M :u {{C}u * x = m{C0}}

[App] {C} M :m {C0} {C0} N :n { C1 ^ {C1} m * n = u {C0}}{C} MN :u {C0}

[If ] {C} M :b {C0} {C0[t/b]} M1 :u {C0} {C0[f/b]} M2 :u {C0}{C} if M then M1 else M2 :u {C0}

[Pair] {C} M1 :m1 {C0} {C0} M2 :m2 {C0[hm1,m2i/u]}{C} hM1,M2i :u {C0}

[Deref ] {C} M :m {C0[!m/u]}{C} !M :u {C0}
[Assign] {C} M :m {C0} {C0} N :n {C0{|n/!m|}}{C} M := N {C0}

[Rec] {Axi ^ 8 j fi i.B( j)[x/u]} ly.M :u {B(i)-x}{

A} ux.ly.M :u {8i.B(i)}

Figure 1. Main proof rules. The difference from the rules in [24]is highlighted.

Thus a valid judgement demands termination. By using arbitrarymodels under arbitrary extensions of bases, the validity is robust
with respect to arbitrary aliasing and weakening. Total correctnesswas chosen to facilitate comparison with [24]. It is straightforward
to obtain partial correctness: only the recursion rule changes.
3.2 Main Proof Rules.
Figure 1 presents the main compositional proof rules. There is onerule for each language construct following its typing. In addition,

there are structural rules which simply manipulate formulae. Someof the main structure rules are listed in Figure 2. For each rule we
stipulate:

* Free i, j,... range over auxiliary names. Further no primary

names in the premise(s) occur as auxiliary names in the con-clusion (this may be considered as a variant of the bound name

convention).*
A,A0,B,B0,... range over stateless formulae, i.e. those formulaewhich do not contain active dereferences (a dereference !e is

active if it does not occur in pre/post conditions of evaluationformulae nor under the scope of content quantification of !e: for
example, !x is active in !x = 2 but neither in h!xi(C^!x = 2) norin {!x = 0}u * (){!x = 1} ).

Despite the added complexity of models due to aliasing, the onlyessential textual change in the proof rules from the logic for aliasfree imperative higher-order functions in [24], is the replacementof syntactic with logical substitution in [Assign] (highlighted),
demonstrating clean, rigorous stratification of logics. Below wediscuss two rules for imperative constructs, using simple inferences
for illustration.

284

[Consequence] C oe C0 {C0} M :u {C00} C00 oe C0{C} M :u {C0}
[Promote] {A} V :u {B}{A ^C} V :u {B ^C} [^-oe] {C ^ A}V :u {C0}{C}V :u {A oe C0}
[oe-^] {C}M :u {A oe C0}{C ^ A}M :u {C0} [.-Pre] {C1}M :u {C} {C2}M :u {C}{C1 .C2}M :u {C}
[^-Post] {C}M :u {C1} {C}M :u {C2}{C}M :u {C1 ^C2} [Aux8] {Ci} M :u {C0}{

C} M :u {8i.C0}

[Aux9] {C} M :u {C0 -

i}{9

i.C} M :u {C0} [Invariance] {C} M

\Gamma ;\Delta ;a :m {C0}{
C ^ A} M :m {C0 ^ A}

Figure 2. Structural rules.

[Deref] infers the property of !M for an arbitrary program M ofa reference type, saying:

If we wish to have C0 as a result of dereference !M named ustarting from the initial state C, we should assume the same
thing about M (to be evaluated into a reference) named x,substituting !x for u in C.

A simple example of using [Deref] follows.{

T} x :z {z = x} (Var, Conseq){
T} lx.x :m {8x.{T}m * x = z{z = x}} (Abs, Aux8){8

x.{T}m * x = z{z = x}} y :n {n = y ^ {T}m * n = z{z = y}}{
T} (lx.x)y :z {!z =!y} (App, Conseq){
T} !((lx.x)y) :u {u =!y} (Deref)
In the second line we use a structural rule [Aux8]. The third andfourth lines use standard equality laws (e.g. z=y oe!z=!y).

The rule [Assign] treats assignment of an arbitrary expression(of type a) to an arbitrary expression (of type

Ref (a)), both possi-bly inducing side effects. It reads:

If the result after executing M := N should satisfy C0 startingfrom C, then, starting from the same state C, M named m
should terminate to reach some C0, and, in turn, N namedn evaluates from C

0 to reach C0, with its occurrences of nsubstituted for !m.

Note the rule assumes the left-right evaluation order (the rule whichassumes the right-left evaluation order, or no order at all, can be
easily formulated). The next example starts from Line 4 in theprevious inference.

1. {T} (lx.x)y :m {m = y} above
2. {m = y ^ 1 = 1} 1 :n {m = y ^ n = 1} (Const)
3. (m = y ^ n = 1) oe (!y = 1){|n/!m|} (?)
4. {m = y ^ 1 = 1} 1 :n {(!y = 1){|n/!m|}} (2, 3, Conseq)
5. {T} (lx.x)y := 1{!y = 1} (1, 4, Assign)
Line 3, which involves semantic update, is derived later. The casewith side effects can be reasoned similarly.

[Assign] treats the most general form of assignment. From thisrule, we can derive specialised assignment rules which offer more
efficient reasoning. For example, if both sides of the assignmentare simultaneously both logical terms and programs, we have the
following simplified rule.

[AssignS] {C{|e2/!e1|}} e1 := e2 {C}

[Abs] {C ^ Ax} M :m {C0}@ ~e{

A} lx.M :u {{C}u * x= m{C0}@ ~e}@ /0

[App] {C}M :m {C0}@ ~e {C0}N :n {C1 ^ {C1}m * n = u{C0}@ ~e2}@ ~e1{C} MN :u {C0}@ ~e~e1 ~e2

[Deref ] {C} M :m {C0[!m/u]}@ ~e{C} !M :u {C0}@ ~e
[Assign] {C} M :m {C0}@ ~e1 {C0} N :n {C0{|n/!m|}}@ ~e2 C0 oe m = e0{C} M := N {C0}@ ~e1 ~e2e0

[Invariance] {C} M :u {C0}@ ~e C0 !~e-free{C ^ C0} M :u {C0 ^C0}@ ~e [Weak] {C} M :m {C0}@ ~e{C} M :m {C0}@ ~e ~e0

[SeqI] {C1} M {C01}@ ~e1 {C2} N {C02}@ ~e2{C1 ^ [! ~e1]C2} M;N {h! ~e2iC01 ^ C02}@ ~e1 ~e2
[Thinning] {C^!e0 = i} M :m {C0^!e0 = i}@ ~ee0 i fresh{C} M :m {C0}@ ~e
Figure 3. Derived proof rules for located assertions (other rulesdirectly follow Fig.1 and 2).

The rule is directly derivable from [Assign] and {C[e/u]}e :u {C}(which is also derivable).
3.3 Structured Reasoning for Programs with Aliasing.
One of the central problems in large-scale software developmentis to prevent inadvertent interference between programs through

shared variables, especially in the presence of aliasing. The locatedassertions in $2.5 address this concern by delineating part of the
store a program may affect. Below we extend this idea to judge-ments.

{C}M :u {C0}@ ~e defj {C ^ y 6= ~e^!y = i}M :u {C0 ^ y 6= ~e^!y = i}
where y and i are fresh and distinct (to be precise, y and i arerespectively typed as

Ref (X) and X for a fresh X) and ~e is a writeset as for located assertions, cf. $2.5 (6). For example {!x = i} x :=

!x+1 {!x = i+1}@x says the command increments the content ofx and does nothing else.

Valid located judgements are derivable by the proof rules fornon-located judgements by translating located judgements to nonlocated ones. A more efficient method is to use compositional proofrules which are derivable in the original system but which are
tailored for located judgements, the main ones of which are listedin Figure 3. The initial four rules should be naturally read (note
[Assign] demands the assigned reference to be among a write effect,while [Deref] does not have such a condition). In [Invariance], we
say C is !e-free when [!e]C j C. Since !e-freedom of C is (up to j)equivalent to C having the shape [!e]C0 or h!eiC0 for some C0, the
rule is in fact equipotent to each one of the following rules:

[InvUniv] {C} M :u {C0}@ ~e{C ^ [! ~e]C0} M :u {C0 ^ [! ~e]C0}@ ~e

[InvExist] {C} M :u {C0}@ ~e{C ^ h! ~eiC0} M :u {C0 ^ h! ~eiC0}@ ~e
[Invariance] and its variants improve the standard invariance rulesin Hoare logics in that they need no extra-logical side condition
(which says "M does not modify variables in C0"). The next rule[SeqI] ("I" for independent) is directly derivable from [InvUniv],
[InvExist] and the standard sequencing rule. The rule looks lop-sided, but its meaning is operationally transparent:

285

Assume (1) {C1}M1{C01}@ ~e1 and (2) {C2}M2{C02}@ ~e2.Suppose C

1 and C2 initially hold, the latter regardless of thecontent of ~e

1. Let first M1 run: then by (1), C01 holds. SinceM
1 only modifies ~e1, C2 still holds, so that if M2 runs next,we reach C0

2 by (2). This next run only modifies ~e2, hence ifC0
1 does not talk about ~e2, then it should continue to hold inthe final state.

The rule directly infers a judgement for a sequenced pair of pro-grams from independent judgements for the component programs.
Here we show a very simple usage of this rule.

1 {T} x := 2 {!x = 2}@x (AssignS)
2 {T} y :=!z {!y =!z}@y (AssignS)
3 {T} x := 2;y :=!z {h!yi!x = 2 ^ !y =!z}@xy (SeqI)

Note h!yi!x = 2 is equivalent to x 6= y oe!x = 2. We used thefollowing located version of (AssignS):

[AssignS] {C{|e2/!e1|}} e1 := e2 {C}@ ~e (C oe e1 2 ~e)
Finally, [Weakening] is easily understood, while [Thinning] recov-ers extensionality (for example the judgement {

T} x :=!x {T}@/0becomes derivable).

3.4 Laws of Content Quantification
Content quantification is introduced because aliasing cuts off theunique bond between a reference name and its content. Hence

(hypothetical) properties of content need to be described indepen-dently from names. For verification, content quantification offers
tractable reasoning on aliased references through succinct logicallaws. These laws are deduced starting from axioms and applying inference rules in the standard way [31]. The axiom system includesthe standard axioms and rules of first-order logic with equality [31,

$2.8], formal number theory, as well as axioms for evaluation for-mulae, data types and content quantification. Here we focus on content quantification (other proper axioms follow our previous work[24], as detailed in [2, $6.3/6.4]).

Axioms for [!x] and h!xi may be given following either thoseof standard quantifiers [31, $2.3] or those of modal operators [6].
Here we take the former approach, which is more concise. Firstwe regard h!xiC as standing for ~[!x](~C). Then there are three
axioms.

(CA1) [!x](C-!x1 oe C2) oe (C1 oe [!x]C2)(CA2) [!x]C oe C

(CA3) [!x](!x = m oe C) j h!xi(C^!x = m)
In (CA1), C-!x indicates C is syntactically !x-free. We generate theset of syntactically !x-free formulae, S-!x by: (1) [!x]C 2 S-!x; and

(2) C ^ Vi ei 6= x 2 S-!x where {ei} exhaust all active dereferences(cf.$3.2) in C; (3) the result of applying any logical connective
(including negation) or standard/content quantifier except 8x,9xto formulae in S -!x is again in S -!x.

(CA1) corresponds to familiar8x
.(C1 oeC2) oe (C1 oe 8x.C2) with x 62 fv(C1). (CA2) is a degenerateform of 8x

.C oe C[e/x]. (CA3) says two ways to represent logicalsubstitutions coincide, which is important to recover all properties

of semantic update as studied in [7, 9, 10, 33], as discussed in thenext section. Finally, to the rules of inference, we add the following
analogue of standard generalisation.

(CGen) C ) [!x]C
In a deduction with non-trivial assumptions, we demand assump-tions to be syntactically !x-free if the deduction uses (CGen) for !x.

By the standard argument, we obtain the deduction theorem [31,$2.4].

Let us list some of the useful laws (focussing on existentials forour later convenience), all deducible from the axiom system.

(L1) C oe h!xiC(L2) h!xih!xiC oe h!xiC
(L3) h!xi!x = e(L4) 9m

.h!xiC j h!xi9m.C (m 6= x)(L5) h!xi(C

1 .C2) j h!xiC1 . h!xiC2(L6) [!x]C
1 ^ h!xiC2 oe h!xi(C1 ^C2)(L7) h!xi(C

1 ^C2) j C1 ^ h!xiC2 (C1 !x-free)(L8) if C j C-!x

0 then C is x-free.
All are analogues of the well-known laws for existential quan-tifiers and the "May" modality. (L7) implies (C

1 ^ C2){|e/!x|} jC
1 ^ (C2{|e/!x|}) when C1 is !x-free, suggesting the use of contentquantification for realising the following locality principle which

has been missing so far (a similar point is observed by Bornat [7],after his extensive exploration of logical calculations involving semantic update using Morris's method):

"If part of a formula does not concern the content of x, thenan update (substitution) at x by some value should not affect

that part."
As a simple application of these laws, we derive C{|c/!x|}{|e/!x|} j
C{|c/!x|} mentioned in the Introduction. Let C0 def= C{|c/!x|} and mbe fresh. Writing (fol) indicates the use of first-order logic with

equality [31, $2.8].9

m.(h!xi(C0^!x = m) ^ m = e)j 9

m.(C0 ^ h!xi(!x = m) ^ m = e) (L8, L7)j C0 ^ 9m

.h!xi(!x = m ^ m = e) (fol, L8)j C0 ^ h!xi9m

.(!x = m ^ m = e) (L4)j C0 ^ h!xi!x = e (fol)

j C0 (L3, fol)
Note the inference never touches C0 (as it should not). As anotherexample, we infer (

?), Line 3, from the inference in Page 9.

(m=y ^ n=1) j [!m](m=y ^ n=1) (L8)j [!m](m=y ^ n=1) ^ h!mi!m=n (L3)

oe h!mi(m=y ^ n=1^!m=n) (L6)oe (!y = 1){|n

/!m|}. (fol)

As noted in the Introduction, the proposed framework effectivelysubsumes the known calculation methods based on semantic update, which are often useful. Below we list simple ones (all areeasily justifiable by the laws given above). Some others are also
discussed in the next section. Below, in (S1-a) (resp. (S1-b)), weassume e

1 (resp. e) and e0 do not contain dereferences.

(S0) C{|e0/!e|} j C, assuming C is !e-free.
(S1-a) (e0 =!e1){|e00/!e2|} j ((e1 = e2 ^ e0 = e00) . (e1 6= e2 ^ e0 =!e

2)) or, as its special instance:
(S1-b) (e0 =!e){|e00/!e|} j e0 = e00.

4. Technical Results
This section records key theoretical properties of the logic, startingwith soundness.

Theorem 1 (soundness for the proof rules) If ` {C} M :u {C0} thenwe have |= {C} M :

u {C0}.

PROOF: We show [Deref ,Assign]. Write (Mx,s) +m (x*m : v,s0)for (Mx

,s) + (v,s0). For [Deref ]:

(x, s) |= C ) (Mx, s) +m (x*m:i, s0) |= C0[!m/u]) ((!M)x

, s) +u (x*u:s0(i), s0) |= C0

286

For [Assign] we reason, with x0 = x * m:i:

(x, s) |= C ) (Mx, s) +m (x*m:i, s0) |= C0) (Nx

0, s0) +n (x0*n:w, s0) |= C0{|n/!m|}) ((M := N)x, s) +

u (x0*u:(), s0[i 7! w]) |= C0

The last line is by the logical equivalence between M |=C0{|n/!m|}and M [ [[m]]

M 7! [[n]]M ] |= C0, which is immediate. See [24, $5.5]and [2, $8.1] for other cases. ut

Proposition 1 (soundness of the axioms) (1) (CA1-3) in $ 3.4 arevalid. (2) (CGen) is sound in the sense that if C is valid then so is
[!x]C.

For the proofs, see [2, $8.1]. Since proof rules in Figure 3 arederivable by those in Figures 1 and 2 (as well as Kleymann's
strengthened consequence rule for (Thinning) [27]), we also know:

Corollary 1 If ` {C} M :u {C0} @ ~e by the rules in Figure 3, then|= {C} M :

u {C0} @ ~e.

4.1 Elimination of Content Quantification.
We show any formula containing content quantification can betransformed into a formula without them, up to logical equivalence.

This is closely related with the decomposition result in [10]. Inthe course of the proof, we also establish mutual representability
between content quantification and Cartwright-Oppen/Morris's se-mantic update.

Proposition 2 1. We have [!e]C j 8m.C{|m/!e|} with m be fresh.Dually, h!eiC j 9m

.C{|m/!e|}.
2. (following [10]) Let ? 2 {^,.,oe}, Q 2 {8,9} and z 62 {x,y}.

(C1 ?C2){|y/!x|} j C1{|y/!x|} ?C2{|y/!x|}(~C){|y

/!x|} j ~(C{|y/!x|})(Q z
.C){|y/!x|} j Q z.(C{|y/!x|})
C-!x{|y/!x|} j C-!x{C}e * e0 = x{C0}{|y

/!x|} j 9uv.({C}u * v = w{C0}^ (u = e ^ v = e0){|y

/!x|})

3. If C has no content quantification we can rewrite C up to j as9~r ~c

.( (^ici =!ri) ^C0), where ~r ~c are fresh and C0 has no activedereference.

PROOF: Mechanical using the axioms, see [2, $5.4]. ut
Proposition 2 (1, 2), which depend on (CA3) in $3.4, establish adirect connection between content quantification and semantic update, allowing us to restore the latter's reasoning methods from [10,9, 33]. Now transform (!u = z){|m

/!x|} into: h!xi(!u = z^!x = m)(with m fresh) which is equivalent to (x = u^m = z).(x 6= u^!u =

z). Write [[(!u = z){|m/!x|}]] for the formula on the right. UsingProposition 2,

h!xiC j 9m.(9~r ~c.((^i[[(!ri = ci){|m/!x|}]]) ^C0))
with C0 without content quantification and m etc. fresh. Performingthis transformation repeatedly, we obtain:

Theorem 2 (elimination) For each C, there exists C0 s.t. C j C0and no content quantification occurs in C0.

4.2 Observational Completeness
A central property of our logic is its precise correspondence withthe observational congruence, in the sense that two programs are

contextually equivalent iff they satisfy the same set of assertions.This offers foundations of modular software engineering, where replacement of one module with another with the same specificationdoes not violate the observable behaviour of the whole software, up
to the latter's global specification.For the proof we extend the method we used in [24], which we
now outline. We first define a subset of programs which representa limited class of behaviours, called finite canonical forms (FCFs,
ranged over by F,F0,...), whose construction comes from gamesemantics [3]. Now let us say (C

,C0) is a characteristic assertionpair (or a CAP) of F at u when F is the least behaviour w.r.t. v

s.t. |= {C}M :u {C0}, where v is the preorder counterpart of ,=.We then derive CAPs for FCFs by introducing tailored proof rules
which refine those in [24] with located judgements (cf. Figure 3).For writing down CAPs and constructing proof rules, we need a
small extension of terms in our assertion language which stands forvectors of variable. Once we know there are CAPs for all FCFs, we
can translate discernibility of finite contexts, hence FCFs, into thelatter's CAPs, hence we know any discerning finite contexts can be
represented by logical assertions, concluding the proof. Following[24] we work with total correctness assertions (TCAs) which represent properties closed upwards w.r.t. v, which is enough (see [2,$8.3] for details). Writing `

char {C} F :u {C0} when {C} F :u {C0}is provable with the derived rules, we obtain:

Proposition 3 If `char {C} F :u {C0}, then (C,C0) is a CAP of F atu.
Such (C,C0) gives the most general formula for total correctness inthe sense of [4], so that we observe:

Corollary 2 (relative completeness for FCFs) If |= {C}F :u {C0}such that (C

,C0) are TCAs, then ` {C}F :u {C0}.

We conjecture that Corollary 2 extends to general programs bya similar argument. Now write \Gamma ;\Delta  ` M

1 ,=L M2 : a whenever:|= {C}M\Gamma ;\Delta ;a

1 :u {C0} iff |= {C}M\Gamma ;\Delta ;a2 :u {C0}. We conclude:

Theorem 3 (observational completeness) \Gamma ;\Delta  ` M1 ,= M2 : a iff\Gamma ;\Delta  ` M

1 ,=L M2 : a.

PROOF: "Only if" is direct from the definitions. For "if" supposeM

1 ,=L M2 but M1 6,= M2. By abstraction, we assume M1,2 are semi-closed. By construction there is semi-closed FCF F and ~F0 such that

(FM1, ~r 7! ~F0) + and (FM2, ~r 7! ~F0) *. By Proposition 3, there areassertions which characterise

F and ~F0. Let such formula for F
at f be written [[F]]( f ). With A def= [[F]]( f ) ^ (^i[[F0i ]](!ri)) we nowreason:

(FM1, ~r 7! ~F0) + ) f :[F]*m:[M1] |= {^i[[F0i ]](!ri)} f * m = z {T}) |

= {T} M1 :m {8 f .{A} f * m = z {T}}

But 6|= {T} M2 :m {8 f .{A} f * m = z{T}}, that is M1 6,=L M2. ut

5. Reasoning Examples
This section illustrates the use of our logic for verifying correctnessof programs, starting from simple examples and finishing with

highlights from the derivation for a higher-order generic Quicksort[26], extracted from the full derivation in [2, $9]. Along the way we
also show how easily our logic can accommodate generalisationsin type structures. Throughout we use the rules for the located
assertions from Figure 3.

287

5.1 Double and Swap
Double We begin with reasoning about double? from $ 2.5 (6),which exhibits different behaviour under different distinctions. We

derive the specification (10). The key point is a use of [SeqI] inFigure 3 for a short inference, focussing on the extensional property

of each part, setting A defj x6=y ^ !x=i ^ !y= j.

{!x=i} x :=!x+!x {!x=2i}@x{

!y= j} y := !y+!y {!y=2 j}@y{
!x=i ^ [!x]!y= j} x := !x+!x ; y := !y+!y {h!yi!x=2i ^ !y=2 j}@xy{
A} x := !x+!x ; y := !y+!y {x6=y oe (!x=2i^ !y=2 j)}@xy{
A} x := !x+!x ; y := !y+!y {!x=2i^ !y=2 j}@xy{
T}double? :u { 8x,y. {A}u * (x,y){!x=2i^!x=2 j}@xy }@/0

where the first two lines are instantly derivable by (S1-b) in $3.4and (AssignS), the third uses (SeqI), the next (Consequence), then

(oe-^) and the last (Abs, Aux8).

Swap: Located Reasoning The swap procedure is a classicalexample for reasoning about aliased programs [10, 9, 12]. We can
either use [SeqI] as done for double? above, or use the traditionaldecomposition method via our result in $4.1. Next we verify that
swap satisfies (8), $ 2.5. We start with extensional reasoning for
the two assignments and combine them using [SeqI]. Let A def= x =y oe i = j.

{!y = j} x :=!y {!x = j}@x (AssignS){

z = i} y := z {!y = i}@y (AssignS){
!y = j ^ [!x]z = i} x :=!y ; y := z {h!yi!x = j ^ !y = i}@xy (SeqI){

!x = i^!y = j ^ z = i}x :=!y ; y := z

{(x 6= y oe!x = j) ^ !y = i}@xy (Conseq){

A^!x = i^!y = j ^ z = i}x :=!y ; y := z

{A ^ (x 6= y oe!x = j) ^ !y = i}@xy (Invariance){

!x = i^!y = j ^ z = i} x :=!y ; y := z {x = j ^ y = i}@xy (Conseq){

!x = i^!y = j} !x :z {!x = i^!y = j ^ z = i}@ /0 (Deref){

!x = i^!y = j}

let z =!x in (x :=!y ; y := z){!x = j^!y = i}@xy (Let)

{T} swap :u {Swapu}@ /0 (Abs)
In the fifth line, A is stateless. In the sixth line, we used !x = i^!y =j entails A. The rest is immediate. We can further universally

abstract the program, using [TAbst] (which appears at the end of$5.3).

Swap: Reasoning by Traditional Method For comparison, wenow show reasoning based on the traditional method.

{(!x = j^!y = i){|z/!y|}{|!y/!x|}}x :=!y
{(!x = j^!y = i){|z/!y|}}@x (AssignS){

(!x = j^!y = i){|z/!y|}} y := z {!x = j^!y = i}@y (AssignS){

(!x = j^!y = i){|z/!y|}{|!y/!x|}}x :=!y ; y := z

{!x = j^!y = i}@xy (Seq)
(!x = i^!y = j ^ z = i) oe (!x = j^!y = i){|z/!y|}{|!y/!x|} (? ? ?){

!x = i^!y = j ^ z = i} x :=!y ; y := z {!x = j^!y = i}@xy (Conseq){
!x = i^!y = j} !x :z {!x = i^!y = j ^ z = i}@ /0 (Deref){

!x = i^!y = j}

let z =!x in (x :=!y ; y := z){!x = j^!y = i}@xy (Let)

{T} swap :u {Swapu} (Abs)

In the sixth line we used the following derived rule, using the
encoding let x = M in N def= (lx.N)M.

[Let] {C} M :x {C0}@ ~e {C0} N :u {C0}@ ~e0{C} let x = M in N :

u {C0}@ ~e ~e0

Except for the fourth line, all inferences are direct from the proofrules. Below we derive (? ? ?), starting from the consequence and

reaching the antecedent.

(!x = j^!y = i){|z/!y|}{|!y/!x|}j (!x = j){|z

/!y|}{|!y/!x|} ^ (!y = i){|z/!y|}{|!y/!x|} (Pro.2 (2))j ((x = y oe z = j) ^ (x 6= y oe!x = j)){|!y

/!x|} ^(z = i){|!y
/!x|} (S1)j (x = y oe z = j){|!y

/!x|} ^(x 6= y oe!x = j){|!y

/!x|} ^ (z = i){|!y/!x|} (Pro.2 (2))j (x = y oe z = j) ^ (x 6= y oe (!x = j{|!y

/!x|})) ^ z = i (L7)j (x = y oe z = j) ^ (x 6= y oe!y = j) ^ z = i (S1)

ae !x = i ^ !y = j ^ z = i (fol)
While the traditional reasoning gives a shorter compositional rea-soning, it involves non-trivial inferences at the assertion level. This

is because the traditional method (or the separation-based methoda la Burstall) cannot exploit semantic independence between two
assignments, which [SeqI] can capture.
5.2 Circular References
Next we consider x :=!!x, an example of a circular data structure.Typing this program requires recursive types, which we outline

first. Taking the equi-isomorphic approach [35] where recursivelydefined types are equated iff their representation as regular trees are
isomorphic, the grammar of types is extended as follows, for boththe programming language and for the assertion language.

a ::= ... | X | uX.a
The typing rules do not change except for taking types up to treeisomorphism. Accordingly no change is needed in the axioms and

proof rules. We wish to prove the following judgement.{

!x = y^!y = x} x :=!!x {!x = x}@x
For the proof we start by converting the pre-condition into a formthat is usable by [AssignS].

(!x = y ^ !y = x) oe!!x = x j (!x = x)[!!x/!x] j (!x = x){|!!x/!x|} (??)
Given (??), the inference is immediate:

1. {(!x = x){|!!x/!x|}} x :=!!x {!x = x} (AssignS)
2. {!x = y^ !y = x} x :=!!x {!x = x} (1, (??), Conseq)
Similarly we can easily derive{

!y = x} x := (1,inr(!y)) {!x = (1,inr(x))} @ x
where x is typed with uX.Ref ((Nat * (Unit + X))), the type of amutable list of natural numbers (one may also use the null pointer

as a terminator of a list). The assertion !x = (1,inr(x)) says x storesa pair of 1 and the right injection of a reference to itself, precisely
capturing graphical structure of the datum. We can also assert andreason about stored procedures including programs with Landin's
recursion (e.g. x := lz.if z = 0 then 1 else z * (!x)(z - 1), afterwhose run (!x)n computes n's factorial), see [24] for details.

5.3 A Polymorphic, Higher-Order Procedure: Quicksort
Hoare's Quicksort is an efficient algorithm for sorting arrays usingrecursion. Apart from recursive calls to itself, Quicksort calls Partition, a procedure which permutes elements of an array so that theyare divided into two contiguous parts, the left containing elements
less than a "pivot value" pv and the right those greater than pv.The pivot value pv is one of the array elements which may ideally
be their mean value. In the following we specify and derive a fullspecification of one instance of the algorithm, directly taken from

288

its well-known C version [26, $5.1.1]. First we present the code,assuming a generic swapping procedure from $2.5 (4-6). We use
indentation for scoping.

quicksort def=uq

. l(a,c,l,r).

if l < r then

let p0 = par(a,c,l,r) inq(a

,c,l, p0 - 1);q(a
,c, p0 + 1,r)

par def=l(a

,c,l,r)

let pv =!a[r] inp := l;i := l;

while !i < r

if c(!a[!i], pv) then

swap(a[!p],a[!i]);p :=!p + 1 ;

i :=!i + 1;
swap(a[r],a[!p]);!p

In these programs we omit type annotations for variables, the mainones of which (for both programs) are:

a : X[ ], c : (X * X))Bool, l,r : Nat
X[ ] is the type of a generic array, see below. Quicksort itself hasthe function type from the product of these types to

Unit. Partitionis the same except that it return type is
Nat.This program exhibits several features which are interesting

from the viewpoint of capturing and verifying behavioural prop-erties using the present logic.

* Its correctness crucially relies on the extensional behaviour of

each part: when recursively calling itself twice in the last twolines of the Quicksort code, it is essential that each call modifies

only the local subarray it is working with, without any overlap.We shall show how this aspect is transparently reflected in the
structures of assertions and reasoning, realising what O'Hearnand Reynolds called "local reasoning" [34, 37] through the
use of logical primitives of general nature rather than thoseintroduced for that specific purpose.

* The program makes essential use of a higher-order procedure,

receiving as its argument a comparison procedure which is usedfor permuting elements.

* The program is fully polymorphic, in the sense that it can sort

an array of any type (as far as a proper comparison procedure isprovided).

In the following we shall discuss how these aspects can be treatedin the present logic. Even including a recent formal verification
of Quicksort in Coq [13], we believe a rigorous verification ofQuicksort's extensional behaviour with higher-order procedures
and polymorphism is given here for the first time.
Preparation: Arrays We first introduce arrays, both for pro-grams and assertions. The presentation may offer basic ideas on

how a new data type can be systematically incorporated in the pre-sented logic. We add:

(types) a ::= ... | a[ ]
(programs) M ::= ... | M[N]
(Terms) e ::= ... | e[e0] | size(e)

[Array] \Gamma  ` M : a[ ] \Gamma  ` N : Nat\Gamma  ` M[N] : Ref (a)

An array consists of a sequence of references: selecting an entrywill return the corresponding reference which can then be dereferenced (we can equally treat less analytical presentation). In modelsan array is regarded as a finite partial injection from

Nat to refer-ences.

Any data type is equipped with axioms characterising its be-haviour. The main ones for arrays are: Each array of size n is made
up of n distinct references:8

i, j. ( 0 <= i, j fi size(x) ^ i 6= j oe x[i] 6= x[ j] )
Two arrays are equal iff their size and component references coin-cide.

(size(x) = size(y) ^ 8i. ( 0 <= i < size(x) - 1 oe x[i] = y[i] )) oe x = y

Two distinct arrays never overlap (not applicable in some lan-guages).
x 6= y oe 8i, j. ( 0 <= i < size(x) - 1 ^ 0 <= j < size(y) - 1 oe x[i] 6= y[ j] )
We also need proof rules for arrays, one introduction rule for arrayidentifiers and one elimination rule for indexing. Since the former
is common to all variables, we only add the latter.

[Array]

{C}M :m{C0}@ ~e{

C0}N :n{C0[m[n]/u]}@ ~e0 C0[m[n]/u] oe 0<=n<size(m){

C} M[N] :u {C0} @ ~e ~e0

The rightmost premise prevents out-of-bound errors (treatment oferrors is further discussed in [2]).

Specification We now present a full specification of Quicksort(For simplicity,

par and swap are assumed inlined: treating themas external procedures is straightforward).

{T} qsort :u {8X.Qsortu}@/0. (12)
where we set, omitting types, Qsortu is the predicate

8abclr. 0@{

Equal(ablr)^Order(c)}u * (a

,c,l,r){
Perm(ablr)^Sorted(aclr)}@a[l...r]ip 1A (13)

Here a[l...r]ip is short for a[l],...,a[r],i, p. The variable b is auxil-iary and is of the same array type as a, denoting the initial copy of

a, so that we can specify the change of a in the post-condition isonly in the ordering of its elements. Each predicate used in (13)
has the following meaning. For the precondition:

* Equal(ablr) says: distinct arrays a and b coincide in their

content in the range from l to r (with l and r being in the arraybound). In addition, it also stipulates freshness and distinctness

of variables p and i.*
Order(c) says: c calculates a total order without side effects.Formally, it is the conjunction of:

1. 8xy.(c * (x,y) = T . c * (x,y) = F). In this assertion"c*(x

,y)=e" stands for "{T}c*(x,y) = z{z = e}@/0" ("thecomparison terminates and has no side effects");

2. 8xy.(x 6= y oe (c*(x,y) = T.c*(y,x) = T)) ("two distinctelements are always ordered"); and
3. (c*(x,y) = T^c*(y,z) = T) oe c*(x,z) = T ("the orderingis transitive").
The use of this predicate instead of (say) a boolean conditionembodies the higher-order nature of Quicksort.
For the post-condition:

* Perm(ablr) says: entries of a and b in the range from l to r

are permutations of each other in content. It also stipulates thesame distinctness condition as

Equal(ablr).*

Sorted(alrc) says: the content of a in the range from l to rare sorted w.r.t. the total order implemented by c. Formally:

Sorted(aclr) defj 8i, j.(l <= i < j <= r oe c * (!a[i],!a[ j]) = T).
So Qsortu in (13) as a whole says:

Initially we assume two distinct arrays, a and b, of the samecontent from l to r (

Equal(ablr)), together with a procedurewhich realises a total order (

Order(c)). After the programruns, one array remains unchanged (because the assertion

says it touches only a), and this changed array is such that itis the permutation of the original one (

Perm(ablr)) and thatit is well-sorted w.r.t. c (
Sorted(aclr)).

289

Located assertions play a fundamental role in this specification: forexample, it is crucial to be able to assert c has no unwanted side
effects. In the rest of this section, we present highlights from a fullderivation of the judgement (12) recorded in [2, $9].

Reasoning (1): Sorting Disjoint Subarrays First we focus onthe last two lines of

quicksort which sort subarrays by recur-sive calls. The reasoning demonstrate how the use of our refined

invariance rule offers quick inference by combining two local, ex-tensional specifications. Concretely our aim is to establish:

{C1} q(a,c,l, p0 - 1) ; q(a,c, p0 + 1,r) {C01}@a[l...r]ip (14)
where

C1 defj ` Perm(ablr) ^ Parted(aclrp0) ^ Order(c) ^8 j <k.QsortBounded(q j) ^ r - l <=k '

C01 def= Perm(ablr) ^ Sorted(aclr).
Two newly introduced predicates are illustrated below.

QsortBounded(q j) with j of Nat type is used as an inductivehypothesis for recursion. It is the same as Qsort

q, given in (13),Page 10, except that it only works for a range no more than j

and that it replaces "Equal(ablr)" in the precondition of (13) with"

Perm(ablr)", which is necessary for the induction to go through.
Parted(aclrk) says the subarray of a from l to r is partitioned atan intermediate index k w.r.t. the order defined by c. Formally it is

given as:

l <=k<=r ^ 8 j.(l <= j <=k oe c * (!a[ j],!a[k])=T)

^ 8 j.(k <= j <=r oe c * (!a[k],!a[ j])=T)
A key feature of these two recursive calls is that neither modi-fies/depends on subarrays written by the other. As mentioned already, this feature allows us to localise reasoning: the specifica-tion and deduction of each part has only to mention local information it is concerned with. Joining the resulting two specifications isthen transparent through the invariance rule and basic laws of content quantification. Let ~e2 def= a[l..p0 - 1]pi and ~e3 def= a[p0 + 1..r]pi(which are the parts touched by the first/second calls, respectively).
We now derive:

R.1. {C2} q(l,p0 - 1) {C02} @ ~e2

R.2. {C3} q(p0 + 1,r) {C03} @ ~e3
R.3. {C2 ^ [! ~e2]C3} q(l,p0 - 1) ; q(p0 + 1,r) {h! ~e3iC02 ^ C03}@ ~e2 ~e3
R.4. C1 oe 9b0.(([! ~e3]C2 ^ C2 ^ [!~e2 ~e3](C02 ^ h! ~e2iC03 oe C01)))
R.5. {C1} q(l,p0 - 1) ; q(p0 + 1,r) {C01}@~e2 ~e3 (Conseq-Aux)
Line (R.3) uses (R.1-2, SeqI), the first two (AppS). The derivationuses the following abbreviations.

C2 def= Equal(ab0l(p0 - 1)) ^ Order(c) ^ 8 j <k.QsortBounded(q j)^

p0 - 1 - l <k

C02 def= Perm(ab0l(p0 - 1)) ^ Sorted(acl(p0 - 1))
C3 def= Equal(ab0(p0+1)r) ^ Order(c) ^ 8 j <k.QsortBounded(q j) ^

r-(p0+1)<k

C03 def= Perm(ab0(p0 + 1)r) ^ Sorted(ac(p0 + 1)r)

Note each of C2/C02 and C3/C03 mentions only the local subarrayeach call works with. The auxiliary variable b0 serves as a fresh

copy of a immediately before these calls (we cannot use b since,e.g.

Perm(abl(p0 - 1)) does not hold). (R.1-3) are asserted andreasoned using b0, which (R.4) mediates into the judgement on b,

so that (R.5) only mentions b. The inference uses the followingderived rules (the first one is due to Kleymann).

[Conseq-Aux] {C0} M :u {C00}@ ~e C oe 9 ~j.(C0[ ~j/~i] ^ [!~e](C00[ ~j/~i] oe C0)){C} M :u {C0}@ ~e

[AppS] C oe {C}e * (e1..en)=u{C0}@ ~e{C} e(e1...en) :u {C0}@ ~e

Using these rules and [SeqI], (R.1/2/3/5) are immediate. The re-maining step is the derivation of (R.4), the condition for [Conseq-Aux].
For this, the first step is to see:

(Dist ^ !a[p0] =!b0[p0] ^ Perm(bb0lr) ^ Parted(bclrp0))oe ((C0

2 ^ C03) oe C01) (15)

is valid, which is elementary (Dist says a and b0 are distinct and donot overlap with p and i). Then by (CGen) (cf. $3.4) we can universally content quantify ! ~e2 ~e3 over (15). By Dist, the antecedent of(15) is ! ~e

2 ~e3-robust, hence we can apply (CA1) (cf. $3.4) to reach(R.4).

Reasoning (2): Using Comparison Next we focus on the useof a comparison procedure in the while loop in Partition, which is
originally passed to Partition as an argument. We start with the loopinvariant.

Invar defj 0@ C

prepart ^ l <=!p,!i <= r ^ Leq(acl(!p - 1)pv)^

Geq(ac(!p0)(!i - 1)pv) ^ (!p <!i oe c * (!a[!p], pv) = T) 1A
Leq(aclrv) (resp. Geq(aclrv)) says the entries from l to r in a aresmaller (resp. bigger) than v. When inside the loop, the values of

p and i differ from the invariant slightly, so that we also make use
of: Cinloop defj Invar^!i < r ^ r-!i = j. The following assertionsspecify two cases of the conditional branch.

Cthen defj Cinloop ^c*(!a[!i], pv) = T C~then defj Cinloop ^c*(!a[!i], pv) = F.

We now present the derivation for the if sentence of the loop,where the comparison procedure received as an an argument is

used at the conditional branch. Below we assume the conditionalbody ("

ifbody") has been verified already and let j to be a freshlychosen variable of Nat-type.

(Invar ^ r-!i > 0) oe 0@{

Invar ^ r-!i>0}c * (!a[!i]

, pv) = z{c * (!a[!i]
, pv) = z ^ Invar ^ r-!i>0}@/0 1A{

Invar ^ r-!i > 0}c(!a[!i]

, pv) :z{c * (!a[!i]
, pv) = z ^ Invar ^ r-!i > 0}@/0 (AppSimple){

Cthen} ifbody {Invar{|!i + 1/!i|}^ r-!i <= j)}@a[l...r - 1]ip (omitted)

C~then oe (Invar{|!i + 1/!i|} ^ r-!i <= j){

Cinloop}

if c(!a[!i], pv) then ifbody{
Invar{|!i + 1/!i|} ^ r-!i <= j)}@a[l...r - 1]pi (IfThen)

Thus reasoning about a conditional branch which involves a callto a received procedure is no more difficult than treating first-order

expressions. Above we used the following simplification of [If ].

[IfThen] {C} M :m {C0}@ ~e {C0[T/m]} N {C0}@ ~e0 C0[F/m] oe C0{C} if M then N {C0}@ ~e ~e0
The rest of the verification for Partition is mechanical, so that wereach the following natural judgement:

{Perm(ablr) ^ Order(c)}

par(a,c,l,r) :p0{
Parted(aclrp0) ^ Perm(ablr) ^ Order(c)}@a[l..r]pi

.

Reasoning (3): Polymorphism We are now ready to derive thewhole specification of Quicksort (12). As noted, the algorithm is
generic in the type of data being sorted, so we conclude with deriv-ing its polymorphic specification. We need one additional rule for
type abstraction (for further details of treatment of polymorphism,see [23]). We also list the rule for "let" which is easily derivable
from [Abs] and [App] through the standard encoding. Below, ftv(\Theta )

290

indicates the type variables in \Theta , similarly for ftv(C).

[TAbs] {C} V \Gamma 

;\Delta ;a :m {C0} X 62 ftv(\Gamma ,\Delta ) [ ftv(C){

C} V \Gamma ,\Delta ;8X.a :u {8X.C0}

[Let] {C} M :x {C0}@ ~e {C0} N :u {C0}@ ~e0{C} let x = M in N :u {C0}@ ~e ~e0
We now present the derivation. For brevity we use the following abbreviations: C? def= Perm(ablr)^Sorted(aclr), B0 def= Perm(ablr)^
Order(c) ^ 8 j < k.QsortBounded(q j) ^ r - l <= k, and B def=B0 ^ l

< r. We also write qsort0 for qsort in Page 9 withoutthe first line (i.e. without u

/l-abstractions), M for q(a,c,l, p0 -1) ;
q(a,c, p0 + 1,r) and N for q(l, p0 - 1) ; q(p0 + 1,r).{

B} par(a,c,l,r) :p0 {Parted(aclrp0) ^ B}@a[l..r]pi (Invariance){
Parted(aclrp0) ^ B} M {C?}@a[l...r]ip (R.5){
B} let p0 = par(a,l,r,c) in N {C?}@a[l...r]ip (Let){
B0} qsort0 {C?}@a[l...r]ip (IfThen){8

j < k.QsortBounded(q j)}l(a

,c,l,r).qsort0 :m{
QsortBounded(mk)}@/0 (Abs){

T} qsort :u {Qsortu}@/0 (Rec, Consequence){

T} qsort :u {8X.Qsortu}@/0 (TAbs)
This concludes the derivation of a full specification for polymor-phic Quicksort.

6. Conclusion
This paper introduced a program logic for imperative higher-orderfunctions with general forms of aliasing, presented its basic theory, and explored its use for specification and verification throughsimple but non-trivial examples. Distinguishing features of the
proposed program logic include a general treatment of impera-tive higher-order functions and aliasing; its precise correspondence
with observational semantics [15, 19]; provision of structured as-sertion and reasoning methods for higher-order behaviour with
shared data in the presence of aliasing; and clean extensibility todata structures. We expect that compositional program logics which
can fully capture behaviours of higher-order programs will haveapplications not only in specification and verification of individual
programs but also in combination with other engineering activitiesfor safety guarantee of programs.

The logic is built on our earlier work [24], where we introduceda logic for imperative higher-order functions without aliasing. In
[24], a reference type in both the programming and assertion lan-guages, is never carried in another type, which leads to the lack of
aliasing: operationally, a procedure never receives or returns (anda reference never stores) references, while logically, equating two
distinct reference names is contradictory. In the present work wehave taken off this restriction. This leads to substantially richer and
more complex program behaviour, which is met by a minimal butpowerful enrichment in the logic, both in semantics (through introduction of distinctions) and in syntax (by content quantification).The added machinery allows us to reason about a general form of
assignment, M := N, to treat a large class of mutable data struc-tures, and to reason about many programs of practical significance
such as Quicksort, all of which have not been possible in the logicin [24]. In the following we conclude the paper with discussions on
remaining topics and related work.
Local References.
Apart from aliasing and higher-order behaviours, one of the fo-cal points in reasoning about (imperative) higher-order functions

is new name generation or local references, as studied by Pitts and

Stark [36]. Its clean logical treatment is possible through a rigorousstratification on top of the present logic. At the level of programming language, the grammar is extended by new x := M in N withx 62 fv(M). For its logical treatment, there are two layers. In one,
local references are never allowed to go out of the original scope(hence they are freshly created and used at each run of a program or
a procedure body, to be thrown away after termination or return). Inthis case, we do not have to change the assertion language but have
only to add what corresponds to the standard proof rule for locallydeclared variables. Below we present a simpler case when name
comparison is not allowed in the target programming language.

{C-x}N :n {C0} {([!x]C0)[!x/n]}M\Gamma ;\Delta *x:Ref(a);b :m {C0-x}{

C} new x := N in M\Gamma ;\Delta ;b :u {C0} (16)

which says that, when inferring for M, we can safely assume thatthe newly generated x is distinct from existing reference names, and

that the description of the resulting state and value, C0, should notmention this new reference (for further illustration, see [2, $10]).
It is notable that this rule and its refinement for the restricted formof local references allow us to treat the standard parameter passing
mechanism in procedural languages such as C and Java through thefollowing simple translation: a procedure definition "

f(x,y) {...}"is transformed into

l(x0,y0).new x := x0 in new y := y0 in ....
Since x and y are freshly generated, they are never aliased with eachother nor with existing reference names. This aspect is logically

captured by (16). Thus the (lack of) aliasing in stack variablescan be analysed as a special case of aliasing in general references,
allowing uniform understanding.In the fully general form of local references, a newly generated reference can be exported to the outside of its original scope(reminiscent of scope extrusion in the p-calculus [32]) and can live
longer than the generating procedure. A procedure can now havelocal state, possibly changing behaviour each time it runs, reflecting not only a given argument and global state but also its localstate, the latter invisible to the environment. This leads to greater
complexity in behaviour, demanding a further enrichment in logics.Among others we need to treat a newly generated reference which
is exported to the outside, which means, in the context of (16), thatC0 should now be able to talk about the freshly generated reference.
How this can be done with a clean and minimal extension to thepresent logic will be discussed in a forthcoming exposition.

Related Work.
A detailed historical survey of the program logics and reasoningmethods which treat aliasing, is given in [2, $10], where the main

efforts in this genre in the last three decades are discussed. Belowwe focus on some of the directly related Hoare-like program logics
which treat aliasing. Janssen and van Emde Boas [25] first intro-duce distinctions between reference names and their content in the
assertion method. The assignment rule based on semantic substitu-tion is discussed by Cartwright and Oppen [10], Morris [33] and
Trakhtenbrot, Halpern and Meyer [39]. The work by Cartwrightand Oppen [10] presented a (relative) completeness result for a language with aliasing and procedures. Morris [33] gives extensivereasoning examples. Bornat [7] further explored Morris's reasoning method. Trakhtenbrot et al. [39] also presents an invariance rulereminiscent of ours, as well as using the dereference notation in the
assertion language for the first time. As arrays and other mutabledata structures introduce aliasing between elements, studies of their
proof rules such as [16, 29, 4] contain logical analyses of aliasing(which goes back to [30]). More recently Kulczycki et al. [12] study

291

possible ways to reason about aliasing induced by call-by-referenceprocedure calls.

A different approach to the logical treatment of aliasing, basedon Burstall's early work, is Separation Logic by Reynolds, O'Hearn
and others [37, 34]. They introduce a novel conjunction * that alsostipulates disjointness of memory regions. Separation Logic uses
the semantics and rules of Hoare logic for alias-free stack-allocatedvariables while introducing alias-sensitive rules for variables on
heaps. We discuss their work in some detail since it exhibits aninteresting contrast with our approach, both philosophically and
technically. Their logic starts from a resource-aware assignmentrule [37]: {e 7! -} [e] := e0 {e 7! e0} where e and e0 do not
include dereference of heap variables and "x 7! -" stands for9i

.(x 7! i)". The rule demands that a memory cell is available ataddress e, demonstrating the resource-oriented nature of the logic

(motivated from reasoning for low-level code such as assemblers).Consequently, {

T} [e] := [e] {T} is unsound in their logic. Thiscommand corresponds to x :=!x in our notation. {

T} x :=!x {T} istrivially sound in original Hoare logic [20] and ours.

On the basis of these resource-oriented proof rules, [37, 34]propose a variant of the invariance rule.

{C} P {C0} fv(C0) " modify(P) = /0{

C *C0} P {C0 *C0} (17)

The second premise is the standard side condition (modify(P) isthe set of all stack-allocated variables which P may write to). Apart

from this side condition, soundness of this rule hinges on the re-source-oriented assignment/dereference rules described above, by
which all the variables (addresses) in the heap which P may writeto are explicitly mentioned in C. Like the standard invariance rule,
this rule is intended to serve as an aid for modular verification ofprogram correctness.

Separation Logic's ability to reason about aliased referencescrucially depends on its resource-oriented nature, the separating
conjunction * and a special predicate 7! to represent content ofmemory cells. In contrast, the present work aims at a precise logical articulation of observational meaning of programs in the tra-ditions of both Hennessy-Milner logic and Hoare logic, as exemplified by Theorem 3. Another difference is that our logic aims tomake the best of the standard logical apparatus of first-order logic
with equality to represent general aliasing situations. These differ-ences come to life for example in the [Invariance] rule of $3, which
plays a role similar to (17). Our rule relies on purely compositionalreasoning about observable behaviour, which, as examples in the
previous section may suggest, contributes to tractability in reason-ing. Concrete examples will serve to elucidate the difference. The
following shows a possible inference for x := 2; y :=!z through adirect application of (17, Assign, Inv, Seq, Consequence).

{x 7! -} x := 2 {x 7! 2}{

y 7! - ^ z 7! i} y :=!z {y 7! i ^ z 7! i}{

x 7! - * (y 7! - ^ z 7! -)}x := 2;y :=!z

{x 7! 2 * 9i.(y 7! i ^ z 7! i)}
For the same program, a direct application of our invariance rulegives:

1 {T} x := 2 {!x = 2}@x (Assign)
2 {T} y :=!z {!y =!z}@y (Assign)
3 {T} x := 2;y :=!z {h!yi!x = 2 ^ !y =!z}@xy (SeqI)
Reflecting observational nature, the pre-condition simply staysempty. Note also that h!yi!x = 2 ^ !y =!z is equivalent to (x 6= y oe

!x = 2) ^ !y =!z, which is more general than x 7! 2 * 9i.(y 7! i ^

z 7! i). Intuitively this is because the content quantification (hereh!yi) offers a more refined form of protection from sharing/aliasing.

These examples suggest a gain in generality in using the pro-posed logical framework for representation of sharing and disjointness of data structures. While C1 *C2 is practically embeddable as[! ~e

2]C1 ^ [! ~e1]C2 where ~ei exhausts active dereferences of Ci, theexamples suggest the use of write sets in located judgements/assertions offers a more precise description and smooth reasoning. Onits observational basis, the present logic may incorporate resourcesensitive aspects through separate predicates (for example a pred-icate

allocated(e) may say e of a reference type is allocated). Be-cause of differences in orientation, we also expect a fruitful interplay between ideas from Separation Logic and those from the pro-posed logic and its ramifications. As one such instance, our long
version [2, $10] reports a generalisation of a refined version of (17)studied by O'Hearn, Yang and Reynolds [34].

We also note elimination procedures similar to our Theorem 2are studied by Lozes [28] and Calcagno et al. [8].

Acknowledgements We thank the anonymous referees fortheir useful comments. This work was partially supported by
EPSRC grants GR/R03075/01, GR/T04236/01, GR/S55538/01,GR/T04724/01 and GR/T03208/01.

References

[1] C- home page. http://www.cminusminus.org.
[2] A full version of the present paper. Available for download atwww.dcs.qmul.ac.uk/~kohei/logics.

[3] Samson Abramsky, Kohei Honda, and Guy McCusker. A fully abstractgame semantics for general references. In LICS'98, pages 334-344,

1998.
[4] K R. Apt. Ten Years of Hoare Logic: a survey. TOPLAS, 3:431-483,1981.

[5] Friedrich L. Bauer, Edsger W. Dijkstra, and Tony Hoare, editors.Theoretical Foundations of Programming Methodology, Lecture Notes

of an International Summer School. Reidel, 1982.
[6] Patrick Blackburn, Maarten de Rijke, and Yde Venema. Modal Logic.Cambridge University Press, 2001.

[7] Richard Bornat. Proving pointer programs in hoare logic. In Conf. onMathematics of Program Construction, LNCS. Springer-Verlag, 2000.
[8] Cristiano Calcagno, Philippa Gardner, and Matthew Hague. Fromseparation logic to first-order logic. In Proc. FoSSaCs'05, LNCS.

Springer-Verlag.
[9] Robert Cartwright and Derek C. Oppen. Unrestricted procedure callsin Hoare's logic. In POPL, pages 131-140, 1978.

[10] Robert Cartwright and Derek C. Oppen. The logic of aliasing. ActaInf., 15:365-384, 1981.
[11] Patrick Cousot. Methods and logics for proving programs. InHandbook of Theoretical Computer Science, volume B, pages 843-

993. Elsevier, 1999.
[12] G. W. Kulczycki et al. Reasoning about procedure calls with repeatedarguments and the reference-value distinction. Technical Report TR

]02-13a, Dept. of Comp. Sci., Iowa State Univ., December 2003.
[13] Jean-Christophe Filli^atre and Nicolas Magaud. Certification of sortingalgorithms in the system Coq. In Theorem Proving in Higher Order

Logics: Emerging Trends, 1999.
[14] Robert W. Floyd. Assigning meaning to programs. In Symp. inApplied Mathematics, volume 19, 1967.

[15] Irene Greif and Albert R. Meyer. Specifying the Semantics of whilePrograms: A Tutorial and Critique of a Paper by Hoare and Lauer.

ACM Trans. Program. Lang. Syst., 3(4), 1981.
[16] David Gries and Gary Levin. Assignment and procedure call proofrules. ACM Trans. Program. Lang. Syst., 2(4):564-579, 1980.

292

[17] Dan Grossman, Greg Morrisett, Trevor Jim, Michael Hicks, YanlingWang, and James Cheney. Region-based memory management in

cyclone. In PLDI'02. ACM, 2002.
[18] Carl A. Gunter. Semantics of Programming Languages. MIT Press,1995.

[19] Matthew Hennessy and Robin Milner. Algebraic Laws for Non-Determinism and Concurrency. JACM, 32(1), 1985.
[20] Tony Hoare. An axiomatic basis of computer programming. CACM,12, 1969.
[21] Tony Hoare and He Jifeng. Unifying Theories of Programming.Prentice-Hall International, 1998.
[22] Kohei Honda. From process logic to program logic. In ICFP'04,pages 163-174. ACM Press, 2004.
[23] Kohei Honda and Nobuko Yoshida. A compositional logic forpolymorphic higher-order functions. In PPDP'04, pages 191-202.

ACM Press, 2004.
[24] Kohei Honda, Nobuko Yoshida, and Martin Berger. An observation-ally complete program logic for imperative higher-order functions. In

Proc. LICS'05, pages 270-279. IEEE, 2005.
[25] T. M. V. Janssen and Peter van Emde Boas. On the proper treatmentof referencing, dereferencing and assignment. In Proc. ICALP, pages

282-300, 1977.
[26] Brian W. Kernighan and Dennis M. Ritchie. The C ProgrammingLanguage, Second Edition. Prentice-Hall, Englewood Cliffs, New

Jersey, 1988.
[27] Thomas Kleymann. Hoare logic and auxiliary variables. Technicalreport, University of Edinburgh, LFCS ECS-LFCS-98-399, October

1998.
[28] Etienne Lozes. Elimination of spatial connectives in static spatiallogics. TCS, to appear.

[29] David C. Luckham and Norihisa Suzuki. Verification of array, record,and pointer operations in pascal. ACM Trans. Program. Lang. Syst.,

1(2):226-244, 1979.
[30] John L. McCarthy. Towards a mathematical science of computation.In IFIP Congress, pages 21-28, 1962.

[31] Elliot Mendelson. Introduction to Mathematical Logic. WadsworthInc., 1987.
[32] Robin Milner, Joachim Parrow, and David Walker. A calculus ofmobile processes, parts I and II. Info. & Comp., 100(1):1-77, 1992.
[33] Joseph M. Morris. A general axiom of assignment/ assignment andlinked data structures/ a proof of the Schorr-Wait algorithm. In [5],

pages 25-52. Reidel, 1982.
[34] Peter O'Hearn, Hongseok Yang, and John C. Reynolds. Separationand information hiding. In POPL'04, 2004.

[35] Benjamin C. Pierce. Types and Programming Languages. MIT Press,2002.
[36] Andrew Pitts and Ian Stark. Operational reasoning for functions withlocal state. In HOOTS'98, CUP, pages 227-273, 1998.
[37] John C. Reynolds. Separation logic: a logic for shared mutable datastructures. In LICS'02, 2002.
[38] Zhong Shao. An overview of the FLINT/ML compiler. In 1997 ACMSIGPLAN Workshop on Types in Compilation (TIC'97), Amsterdam,

The Netherlands, June 1997.
[39] Boris Trakhtenbrot, Joseph Halpern, and Albert Meyer. FromDenotational to Operational and Axiomatic Semantics for ALGOLlike languages: an overview. In Logic of Programs, volume 164 ofLNCS, pages 474-500, 1984.

293