

A Stratified Semantics of General ReferencesEmbeddable in Higher-Order Logic*

(EXTENDED ABSTRACT)
Amal J. Ahmed# Andrew W. Appel## Roberto Virga$

Princeton University{
amal,appel,rvirga}@cs.princeton.edu

Abstract
We demonstrate a semantic model of general references-- that is, mutable memory cells that may contain values
of any (statically-checked) closed type, including other references. Our model is in terms of execution sequences ona von Neumann machine; thus, it can be used in a ProofCarrying Code system where the skeptical consumer checks
even the proofs of the typing rules. The model allows us toprove a frame-axiom introduction rule that allows locality

of specification and reasoning, even in the event of updatesto aliased locations. Our proof is machine-checked in the
Twelf metalogic.

1 Introduction

Proof-carrying code is a framework for proving thesafety of machine-language programs with a machinecheckable proof. In conventional PCC systems [19, 18],proofs are written in a logic with a built-in understanding of
a particular type system; that is, each inference rule of thetype system is an axiom of the logic. In foundational PCC,
introduced by Appel and Felty [4], the only axiom besidesthe axioms of higher-order logic and arithmetic is the definition of the state-transition relation of the target architec-ture. The semantics of everything else (safety, types, etc.)
must be modeled in terms of possible state transitions. Forvery simple type systems, with immutable references, no
data structure creation, and no recursive types, such modelsare easy to construct. Appel and Felty [4] have shown how
to extend this to allocation of immutable values, covariant

*To appear in LICS 2002#

Supported in part by DARPA Grant F30602-99-1-0519 and by NSFGrant 9972930.

##Supported in part by DARPA Grant F30602-99-1-0519.$

Supported by DARPA Grant F30602-99-1-0519.

recursive types, function pointers, and quantified types. Ap-pel and McAllester [5] further extend this to contravariant
recursive types. Our new result is an extension of all the pre-vious type systems to mutable references, where reference
cells can contain values of any type, including functions andother references.

Almost [12] all practical programming languages usemutable references; object-oriented languages (such as
Java) and functional languages (such as ML) permit ref-erences to contain values of arbitrary (statically-checked)
type. Therefore, general references are essential in ourplans to build PCC systems for practical languages. Our
model can handle the full language of ML or Java refer-ences, including cyclic data structures, covariant and contravariant recursive data types, and gives a detailed seman-tics for the initialization, allocation and update of data structures in memory. The foundational PCC consumer need notknow, or trust, the typing rules in advance. This means that
we must provide a machine-checkable proof of these rules;for this we use a semantic model.

The denotational semantics of general references haveposed a challenge to semanticists for years [8]. Recently,
however, some solutions have emerged [1, 15]. An impor-tant aspect of our model, which is a mix of denotational and
operational semantics, is that it is immediately useful as aformalism for proving properties of machine-language programs. The formalism allows locality of specification andreasoning, even in the event of memory updates, and even
in the presence of aliasing.In a typical syntactic theory of references we have judgments of the form \Psi , \Gamma  ` x : o/ (where \Psi  is a mapping fromlocations to types). In the Appel-Felty semantics, a type is
a predicate on a set of allocated locations a, a memory m,and a root-pointer

x, where a is simply a set of addresses.It seems natural to generalize

a to serve the role of \Psi , thusextending Appel-Felty to model general references. Unfortunately, this leads to a circularity. The main contribution ofthis paper is to eliminate this circularity. Our approach consists of a stratification of the type universe, together with aninteresting use of G"odel numbering as a way to encode the
resulting hierarchy of types in higher-order logic. Also, oursemantics is based on a possible-worlds model which seems
crucial in modeling the intensionality inherent in ML-stylereferences.

2 Foundational proofs of safety

We begin by summarizing the foundational PCC ap-proach to proving the safety of machine-language programs.
Specifying safety. The first step is to build a model of avon Neumann machine, such as the Sparc or the Pentium,

and a safety policy. In this model, a machine state comprisesa register bank and a memory, each of which is a function
from integers (addresses) to integers (contents).The execution of an instruction is modeled as a single
step of the machine. First, we define each instruction i as apredicate on four arguments (

r, m, r0, m0) such that, given amachine at state (
r, m), after execution of instruction i themachine will be at state (

r0, m0), provided that the executiondoes not violate the safety policy. For example, if the safety

policy requires that "only writable addresses may be up-dated," (where the predicate

writable is suitably specifiedas part of the safety policy), we can define the instruction

m[rj + c]  ri as:

store(i, j, c) =

*r, m,r0, m0. writable(r(j) + c) ^ m0(r(j) + c) = r(i)^ (8

x 6= (r(j) + c). m0(x) = m(x)) ^ r0 = r

Next, we specify the step relation (r, m) 7! (r0, m0) whichformally describes a single instruction execution. It requires

the existence of an instruction i and a register bank r00 suchthat the integer at location

r(PC) (PC is the program counter)in memory
m decodes to instruction i, updating the registerbank
r with an incremented program counter produces r00,and finally instruction

i safely maps (r00, m) to (r0, m0):

(r, m) 7! (r0, m0) =9

r00, i. decode(m(r(PC)), i)^

r00 = r [PC := r(PC) + 1] ^ i(r00, m, r0, m0)

where f [d := x] = *i. if i = d then x else f (i). 1We model a state in which the real machine would have

a next step that violates the safety policy, as a state withno successor in the step relation. Then, proving that a state
is safe (written safe(r, m)) amounts to showing that thereis no path from (

r, m) to a state with no successor. Toprove a program safe it suffices to show that a state (

r, m)where the program is loaded in memory
m and the programcounter
r(PC) points to the first instruction of the program,is a safe state. We say that a state (

r, m) is safe to executefor
k steps, written safen(k, r, m), if it cannot get stuck

1For details on how to specify instruction encoding and semantics for
real machine architectures, see Michael and Appel [16].

within k instructions. Then, we show safe(r, m) by prov-ing 8

k. safen(k, r, m) by induction on k, the number offuture execution steps.

Proving programs safe. A program is a sequence of ma-chine instructions at a specific place in memory. At each
point in the program there is a precondition, or invariant,such that if the registers and memory satisfy the precondition it is safe to execute the program. The global invariant \Gamma maps each location in the program to its local invariant. 2 In
foundational PCC (and also in Necula [19]) preconditionsare expressed using types, e.g.,

r(1) : o/1 ^ m(102) : o/5.A judgment
x : o/ in foundational PCC is interpreted as
x :k,m o/, which may be read as "x has type o/ with re-spect to memory

m to approximation k" or "the assumptionthat
x has type o/ cannot be proved wrong within k stepsof execution". Program invariants, then, are parametrized

by k, r, and m. Appel and McAllester [5] give a formalinterpretation of the judgment \Gamma  ` {

P }C{Q}, (where Cis an instruction and
P and Q are the pre- and postcondi-tion, respectively), as a statement about safe future execution of a program with respect to an induction hypothesis \Gamma in a foundational PCC system. Under this interpretation, to
show \Gamma  ` {P }C{Q} it is sufficient to prove two lemmas:progress and approximate preservation. Progress says that
when the program counter points to address l, if C is a validinstruction at address

l and the invariant at address l holds,then we can safely execute

C:

Lemma 1 (Progress)

decode(m(l), [[C]]) \Gamma (l) = P \Gamma (l + 1) = Q

r(PC) = l P (k, r, m) k >= 19

r0, m0. (r, m) 7! (r0, m0)

Approximate preservation 3 says that if the invariant ataddress

l holds, then executing the instruction at l leads to astate (
r0, m0) such that the invariant \Gamma (r0(PC)) is satisfied instate (
r0, m0) with approximation k - 1 (since one executionstep was consumed by the execution of

C):

Lemma 2 (Approximate Preservation)

decode(m(l), [[C]]) \Gamma (l) = P \Gamma (l + 1) = Q
r(PC) = l P (k, r, m) k >= 1 (r, m) 7! (r0, m0)

\Gamma (r0(PC))(k - 1, r0, m0)

3 Semantic models of types

To motivate our upcoming model, we present threeHoare triples that read from, initialize, and update memory, respectively, and show type-inference rules required toprove that each triple holds. In a foundational system these

2In practice, it would suffice for \Gamma  to map only the entry points of basic
blocks to the appropriate invariants.3

We use "approximate" to indicate that unlike regular proofs of preser-vation, here the induction is on the number of future execution steps

k.

2

inference rules cannot be added to the logic as axioms; wediscuss the semantic models of types from which they can
be derived as lemmas.
3.1 An indexed model
Example 1 (Traversal of heap-allocated data)Consider the following Hoare triple involving an instruction

that reads a value from a data structure in memory. Theprecondition says that this data structure must be a reference
cell containing a value of type o/, while the postconditionrequires that the value in the destination register has type

o/.

{*k, r, m. r(2) :k,m ref o/ }
r3  m(r2){

*k, r, m. r(3) :k,m o/}

Let us prove that the above triple holds with respect to theglobal invariant \Gamma . To simplify the exposition, we will concentrate on proving approximate preservation -- in our au-tomated proofs, of course, we also prove progress. The step
relation increments the program counter and the above in-struction is not a control-flow instruction, so

r0(PC) = l + 1is easily proved. Since we know from the semantics of the

load instruction that m0 = m, to prove r3 :k-1,m0 o/, we canuse an inference rule similar to the Ref Elimination rule below. This rule says that if x is a pointer to a value of type
o/ in memory m with index k, then the contents of memory
m at address x are of type o/ with index k - 1 (since oneexecution step is consumed in dereferencing the pointer).

Ref Elimination x :

k,m ref o/

m(x) :k-1,m o/

But where does this inference rule come from? A type-specialized PCC system (such as Necula's [19]) would include a similar rule as an axiom. In foundational PCC, how-ever, we build a semantic model of types that allows us to
prove this type inference rule as a lemma. A value is a pair(

m, x) of a memory m and an integer x (usually an ad-dress that can be thought of as the root-pointer to a data

structure in memory). The domain of types has elementsthat are sequences of

k-approximations to the value (m, x),where (
k, m, x) is in a type o/ iff (m, x) is "good enough"for
k steps of execution [5]. Then, a program that executes
j instructions where j <= k also believes that x has type
o/; that is, x :k,m o/ ) 8j <= k. x :j,m o/ . Types can thenbe defined as predicates on (

k, m, x) so that the judgment
x :k,m o/ is just syntactic sugar for o/(k, m, x). We can de-fine integer and reference types as follows:

int(k, m, x) = true
(ref o/ )(k, m, x) = readable(x) ^ 8j <k. o/ (j, m, m(x))

From the definition of ref above, we can immediately provethe Ref Elimination rule as a lemma.

By defining a variety of types in this way (Appel andFelty [4] provide an extensive catalog), and using them as

r1
r5

(a) Unaliased

r1
r5

(b) Aliased
Figure 1. Pointer Aliasing

building blocks to describe more complicated datatypes, wecan reason about the safety of programs that traverse nontrivial data structures -- just as long as these data structuresare

statically allocated.

3.2 A dynamic allocation model
Example 2 (Dynamic heap allocation)Programs written in a call-by-value pure functional language allocate new data structures on the heap but neverupdate old values. Appel and Felty [4] describe a semantic
model that allows us to reason about the safety of such pro-grams. Consider the following Hoare triple for an instruction that creates a new reference cell in memory by writingto a new,

writable memory location, pointed to by register
r5. The situation is depicted in figure 1(a) where all "new"or unallocated memory cells appear shaded.

{*k, r, m. r(1) :k,m o/1 ^ r(4) :k,m o/2}
m(r5)  r4{

*k, r, m. r(1) :k,m o/1 ^ m(r(5)) :k,m o/2}

Given r1 :k,m o/1 and the fact that the store instruction altersmemory (i.e.,

m0 6= m), how can we prove r1 :k,m0 o/1?First, we distinguish between allocated and unallocated locations by maintaining a set a of allocated addresses. Weexpect that the program's memory allocator module keeps
track of which memory addresses it has allocated usingsome data structure in registers and memory. Thus, from
time to time, the set a is computable by some function
a = alloc(r, m). At other times, (for example, part waythrough an allocation), it may be that

a 6= alloc(r, m).As a result,
a is existentially quantified when it appears inprogram invariants.

We say that a state is a pair (a, m) of an allocset a and amemory

m. A value is now a tuple (k, a, m, x) of an index
k, a state and a root-pointer and types are, as before, pred-icates on values. Only

readable and writable locationsare added to the allocset. This is accomplished by giving

the program's allocator module an initial pool that is a sub-set of (

readable " writable). The types int and ref aredefined as,

int(k, a, m, x) = true(

ref o/)(k, a, m, x) = x 2 a ^ 8j < k. o/ (j, a, m, m(x))

3

Next, we specify that only unallocated locations can bemodified, i.e., from a state (

a, m) we can get to a state(
a, m0) if and only if 8x. x 2 a ) m(x) = m0(x). In thismodel, a store instruction never affects existing data structures; hence, we can prove that existing type judgments arepreserved across memory updates. This model allows us
to prove the following Initialization Invariance rule as alemma. The rule says that when we update an unallocated
location, type judgments made with respect to the old mem-ory continue to be valid with respect to the new memory:

Initialization Invariance

x :k,a,m o/ y /2 a m0 = m [y := z]

x :k-1,a,m0 o/

If we rewrite the invariants of our Hoare triple so that typejudgments have the form

x :k,a,m o/, using the Initializa-tion Invariance rule we can prove the following statement:

{*k, r, m. 9a. r(1) :a,m o/1 ^ r(5) /2 a ^ r(4) :a,m o/2}
m(r5)  r4{

*k, r, m. 9a. r(1) :k,a,m o/1 ^ m(r(5)) :k,a,m o/2}

3.3 The need for a new model
Example 3 (Mutable data structures)The model described by Appel and Felty [4] cannot be used

to reason about the safety of programs written in an imper-ative language. That model prohibits updates to allocated
memory locations -- the store instruction in the followingHoare triple performs such an update:

{*k, r, m. 9a. r(1) :k,a,m o/1^

r(5) :k,a,m ref o/2 ^ r(4) :k,a,m o/2}
m(r5)  r4{

*k, r, m. 9a. r(1) :k,a,m o/1 ^ r(5) :k,a,m ref o/2}

Consider the scenario illustrated by figure 1(b) -- the storeinstruction updates the location that

r5 points to (therebymodifying the data structure that
r1 points to), so that wecannot know if
r1 has type o/1 with respect to the modifiedmemory
m0. We do not want to rule out situations suchas this one where an aliased location is being updated. The

Update Invariance rule allows us to handle updates even inthe presence of aliasing. This rule says that when we update
an allocated location, type judgments made with respect tothe old memory continue to be valid with respect to the new
memory. This suggests that writing to an allocated locationshould be permitted only if the update is type-preserving.

Update Invariance

x :k,a,m o/ y :k,a,m ref o/ 0 z :k,a,m o/ 0 m0 = m [y := z]

x :k-1,a,m0 o/

Allowing updates of aliased locations while guaranteeingconsistency is not an easy task -- i.e., proving the Update

Invariance rule is nontrivial. For foundational PCC, we

must devise a new semantic model of types that allows usto prove the Update Invariance rule as a lemma. Such a
model and a proof of an Update Invariance lemma are themain contributions of this paper.

An update to an allocated location must be type-preserving -- this means that only values of a certain type
may be written at that location. Hence, we require a modelthat, for each allocated location, keeps track of this type. In
the next section we describe why tracking permissible heapupdates is tricky.

4 Modeling permissible heap updates

In the semantics of immutable fields described in sec-tion 3.2 a type is a predicate on an index

k (an integer), amemory
m (a function from integers to integers), a set aof allocated addresses (a predicate on integers), and a rootpointer x (an integer). In our object logic, we write the typesof these logical objects as,

memory = num ! num
allocset = num ! otype = num * allocset * memory * num !

o

where o is the type of propositions (true or false).

4.1 Putting types in the allocset

To allow for the update of existing values we might thinkof enhancing the allocset

a to become a finite map fromlocations to types: for each allocated address

x, we keeptrack of the type
o/ of updates allowed at x. As before, atype is a predicate on four arguments (

k, a, m, x):

allocset = num fin! type
type = num * allocset * memory * num ! o

But there is a problem with this specification: notice thatthe metalogical type of type is recursive, and, furthermore,

that it has an inconsistent cardinality: the set of types mustbe bigger than itself.

4.2 A hierarchy of types

To better understand the problem, let us take a closerlook at our desired definition of ref. We say

x :k,a,m ref o/if location
x is allocated, if the allocset a says that the per-missible update type for location

x is o/, and if the value inmemory at location
x is of type o/ with index j for j < k: 4

(ref o/ )(k, a, m, x) = (x, o/) 2 a ^ 8j < k. o/(j, a, m, m(x))
Notice that o/ is a "smaller" type than ref o/ and that to deter-mine the members of ref

o/ we, in fact, only consider thoselocations in the allocset whose permissible update types are

4Recall that we would like the allocset to be a finite map from locations
to types. Since a finite map can be modeled as a relation, we write (x, o/) 2
a rather than a(x) = o/.

4

"smaller" than ref o/. This suggests a well-foundedness or-dering: types in our model should be stratified so that a type
at level i relies not on the entire allocset, but only on thatsubset of the allocset that maps locations to types at level

j,for
j < i. This leads us to the following type hierarchy:

type0 = unit
allocseti = num fin! typeitype

i+1 = num * allocseti * memory * num ! o

By stratifying mutable references we have eliminated thecircularity. Unfortunately, the above type hierarchy does

not fit into higher-order logic. We would like to have a sin-gle type of type in our object logic, not an infinite number
of them.
4.3 A hierarchy of Godel numberings of types

To achieve a single type of type, we present a solu-tion that replaces the (semantic) type (type

i ) in the alloc-set with its syntax. This syntax is simply a free algebra

of type expression terms. To manipulate syntactic types inhigher-order logic, we encode them as G"odel numbers (we
use this term in a general sense, to mean simply "uniqueidentifiers"). We use a stratified G"odel numbering relation
rep(i, n, o/) where the G"odel number n represents the type
o/ at level i. Note that instead of encoding syntactic types us-ing integers, we opted to use G"odel numbers that are finite

trees of integers. The types of the relevant logical objectsand of the G"odel numbering relation

rep are as follows:

gnum = tree(num)
allocset = num fin! gnumpretype = num * allocset * memory * num !

o
rep : num * gnum * pretype ! otype = num ! pretype

A type is now a predicate on (i, k, a, m, x) where i is theindex of the type in the type hierarchy; this corresponds informally to a logical object of type typei as in section 4.2.A predicate on (

k, a, m, x) is now called a pretype. (Hence-forth, we will use

oe to range over pretypes and o/ to rangeover types.)

Before we describe our pretypes and their encoding, weneed some notation for representing trees of integers. A tree
constructor treei(c0, t1, . . . , ti) returns a tree with integer
c0 at the root and i subtrees t1, . . . , ti, for example:

\Delta 

tree0(1)

\Delta 
\Theta 
tree1(4, tree0(1))

\Delta 
n1 n2
tree2(3, n1, n2)

Pretypes. We now define the pretypes int, [ , and ref,(for a type constructor tycon, tycon denotes the corresponding pretype constructor), and describe how a rep relationmay be defined for these pretypes. Note that since the

definition of ref depends on rep (which has not been de-fined yet),

ref should take rep(i) (for some i >= 0) asan argument. We use

ae to denote the corresponding for-mal parameter, where the type of

ae is as follows: ae :gnum * pretype !
o. (All subsequent uses of the vari-able
ae will be of this logical type -- i.e. ae is always used todenote

rep(i) for some i >= 0.)

int(k, a, m, x) = true(

oe1 [ oe2)(k, a, m, x) = oe1(k, a, m, x) . oe2(k, a, m, x)
(ref(ae, oe))(k, a, m, x) = 9n. (x, n) 2 a ^ ae(n, oe)^ 8

j < k. oe(j, a, m, m(x))

Defining rep. We can define, as a formula in higher-orderlogic, a

rep predicate that has the following properties:1. It relates the pretype int to the tree

tree0(1):

rep(0, tree0(1), int) \Delta 
2. It relates oe1 [ oe2 to the tree below as follows:

rep(i, n1, oe1) rep(i, n2, oe2)
rep(i, tree2(2, n1, n2), oe1 [ oe2)

\Delta 

n1 n2
3. It relates the pretype ref(ae, oe) to a tree where one childis a tree with the single root node

i. Since ae encap-sulates
i, the level of oe in the type hierarchy, i mustbe part of the G"odel number for

ref(ae, oe) (note that
ref(ae, oe) is at level i + 1 in this hierarchy):

rep(i, n, oe)
rep(i + 1, tree2(3, tree0(i), n), ref(ae, oe))

\Delta 

ni
4. rep(i) ae rep(i + 1):

rep(i, n, oe)
rep(i + 1, n, oe)

We show the inductive definition in the technical report [3].Figure 2 illustrates the first few levels of the hierarchy for

the pretype constructors int, [ , and ref. Level 0 consists ofthe G"odel numberings of int, int [ int, (int [ int) [ int, and
so on. Let oe0 denote a pretype that has a G"odel number atlevel 0. Level 1 consists of G"odel numberings of pretypes
oe0, of pretypes ref(rep(0), oe0), and of all pretypes in theclosure (with respect to [ ) of the level 1 pretypes.

Figure 2 also describes the structure of the rep relation:Here,

base is a subset of rep(0) and specifies the G"odelnumbers of all primitive types;

closure(ae) specifies all thetypes constructible by unioning together types numbered in

ae; step(rep(i)) defines a subset of rep(i+1); the closureof the latter, then, gives us

rep(i + 1).

Types. Having defined rep, we can now define the typesthat correspond to the pretypes defined above:

int(i) = int(

o/1 [ o/2)(i) = o/1(i) [ o/2(i)
(ref o/)(i) = ref(rep(i - 1), o/(i - 1))

5

int
int \Delta  int \Delta \Theta  int

base

closure
ref (int \Delta \Theta  int \Delta \Theta  int)

ref(int)

step
ref(int \Delta \Theta  int) \Delta  ref (int) closure

int \Delta \Theta  int

ref (int \Delta \Theta  int)

int \Delta  ref (int)

step

ref (ref(int))

ref (int \Delta  ref (int))

ref (ref (int \Delta \Theta  int))

Figure 2. Hierarchy of Godel numberings
By creating a hierarchy of G"odel numbers, we have, in ef-fect, created a hierarchy of types: to determine the elements
of a type at level i + 1 we need to know the elements of alltypes at levels 0 through

i -- for this we use rep(i). Bystratifying types we have eliminated the circularity.

5 Possible worlds

The semantics we are presenting is a possible-worlds se-mantics. Possible-worlds models (or Kripke models 5 ) are
specified by defining (see Huth and Ryan [13]):*

A set W , whose elements are called worlds. In ourmodel, a world corresponds to a state so we have,

W = allocset * memory.*
A relation R ` W * W called the accessibility rela-tion. In our model, this corresponds to the extend-state

relation on states (a, m) and (a0, m0) which describeshow we can get from a well-formed (or

valid) state(
a, m) to a valid state (a0, m0). Section 5.1 specifieswhen a state is considered valid and section 5.2 specifies the extend-state relation.* A labeling function

L : W ! P(Atoms) that, givena world
w, yields the set of atomic propositions thathold in that world. The atomic propositions

p that weare interested in are of the form: "location
l may holda value of pretype
oe" where l is an allocated location.Therefore, in our model,

L(a, m) = {(l, oe) | (l, n) 2 a ^ 9i. rep(i, n, oe)}*
The properties that the accessibility relation R shouldsatisfy -- these depend on what set of formulas involving p (where p is an atomic proposition) should bevalid in the desired model. Without going into further
detail, our model requires that the extend-state relationbe reflexive and transitive (lemma 6).

5Kripke [29] introduced the notion of possible worlds when he developed the model theory for modal propositional logic based on this concept.

5.1 Valid states

The judgment x :k,a,m oe says that x has pretype oe forup to

k execution steps with respect to the state (a, m). Im-plicit in this assertion is the assumption that state (

a, m) iswell-formed or valid such that types are guaranteed to be

preserved for k steps. A state (a, m) is valid with index
k if it satisfies three conditions. First, the allocset a mustbe a partial function, that is, each location in the allocset

should be mapped to only one G"odel number (informally,to only one type). Second,

a should only map locationsto legitimate G"odel numbers (informally, valid types). The

predicate godel specifies legitimate G"odel numbers:

godelae(n) = 9ae0, oe. ae ae ae0 ^ ae0(n, oe)
The subscript ae indicates that godel takes rep(i) as anargument. (Note that we could have instead defined

godelae(n) as 9oe.ae(n, oe). We explain why the present for-mulation is useful when we discuss the definition of the type
codeptr in section 7.) Third, the type of an allocated cell'scontents (with respect to

k, a, and m) must match its per-missible update type in
a; that is, if a maps a location l topretype
oe then m(l) :k,a,m oe should hold.) We say that xmatches a G"odel number

n with respect to a state (a, m)and index
k if,

matchae(k, n, a, m, x) =8

ae0, oe. ae ae ae0 ) ae0(n, oe) ) oe(k, a, m, x)

Definition 3 (Valid State)
validstateae(k, a, m) =8

x, n, n0. (x, n) 2 a ^ (x, n0) 2 a ) n =tree n0^ 8

x, n. (x, n) 2 a ) godelae(n)^ 8
x, n. (x, n) 2 a ) matchae(k, n, a, m, m(x))

The following property follows from the definition of
validstate. Informally, the type of the value in an al-located cell matches the type that the allocset says it should

have for up to k execution steps:
Lemma 4 (Heap Well-Typed)

(x, n) 2 a validstateae(k, a, m)9

ae0, oe. ae ae ae0 ^ ae0(n, oe) ^ m(x) :k,a,m oe

5.2 Valid state extension

To formally describe the memory and allocset extensionspermissible in our model we specify the extend-state relation (a, m) vae,k (a0, m0) which says that state (a0, m0) is avalid extension of state (

a, m) with index k -- or, alterna-tively, that (
a, m) approximates (a0, m0) for up to k execu-tion steps. State extensions must satisfy three constraints.

First, memory cannot be deallocated, so if x 2 dom(a),then we require that

x 2 dom(a0). (The reason for this re-striction is that the extend-state relation must be transitive.)

Second, the permissible update type of an allocated locationcannot be altered across state extensions, so if (

x, n) 2 a

6

then (x, n) 2 a0. Third, the model requires that all mem-ory updates be type-preserving -- to enforce this we simply
require that state (a0, m0) be a valid state (which sufficesbecause the last two conditions ensure that all allocated locations are "preserved" under state extension).
Definition 5 (Extend State)
Valid state extension (vae,k) is specified as,

(a, m) vae,k (a0, m0) =8

x, n. (x, n) 2 a ) (x, n) 2 a0^

validstateae(k, a, m) ^ validstateae(k, a0, m0)

Lemma 6 (vae,k Reflexive and Transitive)
The extend-state relation (vae,k) is reflexive and transitive.

Consider a state (a, m) where all unallocated memorylocations contain

junk; that is, there are no "initialized butnot yet allocated" locations. When we extend the state,

(a, m) vae,k (a0, m0), as a result of the Heap Well-Typedproperty of a valid state, we are forced to initialize a new
memory location (with a value of the appropriate type) be-fore we add it to the allocset:

Lemma 7 (Initialization Before Allocation)
(a, m) vae,k (a0, m0) , (a, m) vae,k (a, m0) vae,k (a0, m0)

6 What is a type?

A type is a predicate on (i, k, a, m, x). We now describethe four properties a type must have in order to be considered a "good" or valid type.
Extensible. In section 3.3 we presented the Update In-variance rule which says that type judgments are preserved
across memory extension. How can we use the stratifiedmodel of mutable references to prove this rule as a lemma?
We start by stating update invariance as a property of a type-predicate, which says that a type (at level

i) is closed undervalid extension of the memory (i.e., state extension at level

i - 1):

update-inv(o/) =8

i, k, x, a, m, m0. (a, m) vrep(i-1),k (a, m0))

x :i,k,a,m o/ ) x :i,k,a,m0 o/

Notice that since (a, m) vae,k (a, m0) allows updatesof both allocated and unallocated locations,

update-invincorporates the notion of Initialization Invariance described in section 3.2.We model the allocation of new memory by extending
the allocset. To reason about programs that dynamically al-locate memory, we need a rule that says that type judgments
are preserved under extension of the allocset. We call thisthe Allocation Invariance rule. In lieu of the rule we specify the allocation invariance property of a type-predicate:

alloc-inv(o/) =8

i, k, x, m, a, a0. (a, m) vrep(i-1),k (a0, m))

x :i,k,a,m o/ ) x :i,k,a0,m o/

We say that a predicate o/ on (i, k, a, m, x) is extensibleif it has both the

update-inv and alloc-inv propertieswhich leads to the following definition:

extensible(o/ ) =8

i, k, x, a, m, a0, m0. (a, m) vrep(i-1),k (a0, m0))

o/ (i, k, a, m, x) ) o/(i, k, a0, m0, x)

If extensible(o/) holds for each type o/ in our system, thenwe can easily prove the Update, Allocation and Initialization Invariance rules as lemmas.
Index closed. A property of types that we have alreadymentioned is that if

x has type o/ for k future execution steps,then it must be the case that

x has type o/ for j < k steps:

kclosed(o/ ) =8

i, k, j, a, m. 0<= j <k ) o/(i, k, a, m, x) ) o/ (i, j, a, m, x)

Upward closed. Informally, a type at level i has more "in-formation" than a type at level

j, for j < i -- i.e., theformer has access to more levels of

rep and consequently,can determine the pretypes of more locations in the allocset. Therefore, if we have sufficient information at level i toconclude that

x has type o/, then at level i + 1 we still havesufficient information to conclude that

x has type o/:

iclosed(o/ ) =8

i, j, k, a, m. 0<= i< j ) o/ (i, k, a, m, x) ) o/ (j, k, a, m, x)

Representable. To construct a value of type o/, we wouldfirst write the value into an unallocated memory location
l, and then extend the allocset with the pair (l, n) where
n represents the pretype o/(i) at some level i in the G"odelnumbering hierarchy. Clearly this last step requires the existence of such an i and n; i.e., there must be some i >= 0such that the pretype

o/(i) is representable:

repable(o/, i) = 9n. rep(i, n, o/ (i))

Valid types. We say that a predicate o/ on (i, k, a, m, x) isa

type if it is extensible, index closed, upward closed andrepresentable:

Definition 8 (Type)
type(o/ ) = extensible(o/ ) ^ kclosed(o/) ^ iclosed(o/)^ 9

i. repable(o/, i)

7 Modeling a nontrivial type system

In this section we present a model of general references.More precisely, our model permits references to values of
any type defined using the primitive types and type contruc-tors shown in figure 4; figure 3 gives the pretype definitions
that the figure 4 definitions rely on. We will first specifya G"odel numbering relation for the pretypes in our system,
then explain some of the more involved type definitions, andfinally present the relevant theorems. The accompanying

7

For k >= 0 :

?(k, a, m, x) = true?

(k, a, m, x) = false
int(k, a, m, x) = true
(const(n))(k, a, m, x) = x = n
(offset(n, oe))(k, a, m, x) = oe(k, a, m, x + n)(

oe1 [ oe2)(k, a, m, x) = oe1(k, a, m, x).

oe2(k, a, m, x)(
oe1 " oe2)(k, a, m, x) = oe1(k, a, m, x)^

oe2(k, a, m, x)
(rec F )(k, a, m, x) = F k+1?(k, a, m, x)
(box(ae, oe))(k, a, m, x) = 9n. (x, n) 2 a^

ae(n, K const(m(x)))^ 8

j < k. oe(j, a, m, m(x))
(ref(ae, oe))(k, a, m, x) = 9n. (x, n) 2 a^

ae(n, K oen) ^ oen = oe^ 8

j < k. oe(j, a, m, m(x))
(codeptr(ae, oe))(k, a, m, x) = 8r0, a0, m0, j. j < k^

r0(PC) = x^ (

a, m) vae,j (a0, m0)^
oe(j, a0, m0, r0(1)))
safen(j, r0, m0)

Figure 3. Pretype definitions

technical report [3] contains a more detailed exposition ofour model (including existential and universal types which
we have not described here due to lack of space), as well asproofs of the theorems in this paper.

7.1 Godel numbers of pretype functions

Our model requires that we specify the G"odel number ofeach of the pretypes in figure 3. But to specify the G"odel
number of rec(F ) (where F is a function from pretypes topretypes), we have to first specify the G"odel numbers of
pretype functions F . Rather than extend the rep relation sothat it specifies the G"odel numbers of pretype functions as
well as of pretypes, we observe that if we represent everypretype as a pretype function that simply ignores its argument, then we would only require G"odel numbers of pre-type functions. We use K

oe to denote a pretype functionthat ignores its argument and returns the pretype

oe (i.e.,K =
*y. *x. y).We define

rep(i, n, F ), the G"odel numbering relationfor pretype functions, in the same way as we defined

rep(i, n, oe) in section 4.3. We present some of the rulescharacterizing the relation in figure 5. Note that

base nowconsists of the G"odel numbers of K
oe for primitive pre-types
oe, as well as, the G"odel number of the identity pre-type function

*oe. oe. For closure, if the pretype func-tions
F and the pretype oe are representable at level i, then
F (oe) should also be representable at level i. (This con-dition is specified by the

clos apply rule in figure 5.) In

For i >= 0 :?

(i) = ??
(i) = ?
int(i) = int(

const(n))(i) = const(n)
(offset(n, o/ ))(i) = offset(n, o/(i))(

o/1 [ o/2)(i) = o/1(i) [ o/2(i)(
o/1 " o/2)(i) = o/1(i) " o/2(i)
(rec F )(i) = rec(F (i))

For i > 0 :

(box o/)(i) = box(rep(i - 1), o/ (i - 1))
(ref o/)(i) = ref(rep(i - 1), o/ (i - 1))
(codeptr o/ )(i) = codeptr(rep(i - 1), o/ (i - 1))

where, F (i) : pretype ! pretype = *o/. (F (*i0.o/ ))(i)

Figure 4. Type definitions

addition, the pretype constructors offset, [ , " , and recare used to compute the

closure of each ae where ae ae
rep(i). Given some ae = rep(i), the pretypes box, ref,and

codeptr, (each of which is parametrized by ae) are usedto compute

step(ae). For example, if F is representableat level
i, then the pretype functions *oe. ref(rep(i), F (oe))and K
rec(*oe. ref(rep(i), F (oe))) are representable at level
i + 1. We modify the definitions of godel, match, and
repable as follows:

godelae(n) = 9ae0, oe. ae ae ae0 ^ ae0(n, K oe)
matchae(k, n, a, m, x) = 8ae0, oe. ae ae ae0 ) ae0(n, K oe))

oe(k, a, m, x)
repable(F, i) = 9n. rep(i, n, F (i))

7.2 Types
Recursive types (rec). We have incorporated Appel andMcAllester's [5] indexed model of types where the indices
k allow the construction of a well-founded recursion, evenwhen modeling contravariant recursive types. All definitions and proofs regarding recursive types are explained intheir paper. In proving that a type

rec(F ) is a valid type(theorem 11), we require that
F be wellfounded (see [5]).

Immutable references (box). The type box of immutablereferences is defined in figures 3 and 4. Any value may be

stored in an immutable location, as long as it is numericallyequal to the value that is already there.

First-order continuations (codeptr). A value of type
codeptr(o/) is a first-order continuation, that is, a machine-code address to which control may be passed, provided that

its precondition (that register r1 contain a value of type o/)is satisfied. Consider the judgment

x :i,k,a,m codeptr(o/).

8

rep(0, tree0(1), K ?)

base ? rep(0, tree

1(4, tree0(c)), K const(c))

base const rep(0, tree

0(7), *o/. o/) base id

rep(i, n1, F ) rep(i, n2, K o/)
rep(i, tree2(11, n1, n2), K (F (o/))) clos apply

rep(i, n, F )
rep(i, tree2(12, tree0(c), n), *o/. offset(c, F (o/)))

clos offset

rep(i, n1, F1) rep(i, n2, F2)
rep(i, tree2(13, n1, n2), *o/. F1(o/) [ F2(o/)) clos [

wellfounded(F ) rep(i, n, F )

rep(i, tree1(15, n), K rec(F )) clos rec

rep(i, n, F )
rep(i + 1, n, F ) step include

rep(i, n, F )
rep(i + 1, tree2(22, tree0(i), n), *o/. ref(rep(i), F (o/)))

step ref

Figure 5. Some clauses in the Godel numbering relation for pretype functions
This says that if we jump to address x in some future ma-chine state (

r0, m0) (i.e., if r0(PC) = x), then (r0, m0) is asafe state for

j < k steps if the following three conditionshold. First, the argument (i.e., the value stored in register

r1) must be of the right type; that is, r0(1) :i-1,j,a0,m0 o/(see

codeptr in figure 3). A crucial observation aboutcodeptr(

ae, oe) is that if ae = rep(i0), then oe is a pretypeat level
i0.
Second, state (a0, m0) must be a valid extension of state(
a, m) -- i.e., (a, m) vae,j (a0, m0). Note that in extend-ing (

a, m) to (a0, m0) we may have created new cells withtypes that are higher in the G"odel numbering hierarchy.

In that event we need a higher level rep relation, say ae0such that

ae ae ae0, to ensure that state (a0, m0) is valid.But recall the definition of

validstate, or more specif-ically, the definitions of
godel and match in section 5.1.The predicates
godel and match are defined in such away that we have

validstateae(j, a0, m0) if and only if
validstateae0 (j, a0, m0) for ae ae ae0 (see lemma 10).

Third, the program p that is in memory in state (a, m)must still be in memory in state (

a0, m0). To enforce thiscondition, we make all allocset locations that contain program instructions "immutable"; that is, the allocset mapsthese locations to G"odel numbers of box types. Since the
program is preserved under state extension, our requirementis simply (

a, m) vae,j (a0, m0).

7.3 Validity of types
Lemma 9 (rep Upward Closed)
rep(i, n, F ) ) rep(i + 1, n, F )

Lemma 10 (State Valid Modulo Rep Level)If

rep(i) is a sub-relation of rep(i0) then:
validstaterep(i)(k, a, m) , validstaterep(i0)(k, a, m)

The above lemma is key to the consistency of our model. Itfollows from lemma 9 and our carefully crafted definitions

of godel and match, and allows us to prove a series oflemmas critical to the proof of the following theorem [3].
Theorem 11 (Type)a-d.

type(o/), where o/ ::= ?|?|int|const(n)

e. type(o/) ) type(offset(i, o/)).

f. type(o/1) ^ type(o/2) ) type(o/1 [ o/2).
g. type(o/1) ^ type(o/2) ) type(o/1 " o/2).
h. wellfounded(F ) ) type(rec(F )).

i. type(o/) ) type(box o/).
j. type(o/) ) type(ref o/).
k. type(o/) ) type(codeptr o/).

We can construct a variety of types using the types shownin figure 4 (and 9, 8 types [3]) as building blocks (see Appel and Felty [4]). Any such type (except arbitrarily nestedrecursive and quantified types -- see section 9) can easily
be shown to be a type.
7.4 Invariance lemmas

Lemma 12 (Initialization Invariance)

x :i,k,a,m o/ y /2 a m0 = m [y := z] type(o/ )

x :i,k-1,a,m0 o/

Lemma 13 (Allocation Invariance)

x :i,k,a,m o/ a0 = a [ {(y, n)}(

y /2 a . (y, n) 2 a) type(o/ )

x :i,k,a0,m o/

Lemma 14 (Update Invariance)

x :i,k,a,m o/ y :i,k,a,m ref o/ 0 z :i,k,a,m o/0

m0 = m [y := z] type(o/ )

x :i,k-1,a,m0 o/

We can show that the premises of the above lemmas satisfythe extend-state (v) relation. The conclusions then follow

trivially from type(o/).

9

7.5 Introduction & elimination rules

We prove introduction and elimination lemmas for eachtype in figure 4 [3]. We only show the lemmas for

ref here.

Lemma 15 (Ref-I)x /2 a m(x) :

i,k,a,m o/ repable(o/, i) type(o/ )9

a0. (a, m) vrep(i),k (a0, m) ^ x :i+1,k+1,a0,m ref o/

Lemma 16 (Ref-E) x :

i+1,k+1,a,m ref o/

m(x) :i,k,a,m o/

8 Two examples

Using our model of general references we can provelemma 2 for the following program fragments. The proofs
are given in the technical report [3].

r5
r6

Alloca\Sigma ed
\Psi \Omega ee
fffiff

fffifl
fffiffi

fffiffl
fffii

(a) Before example 1

\Delta 00
\Delta 0\Delta 

r1

\Delta  \Delta 00

\Delta 0\Delta 

r1

Before \Sigma f\Upsilon er
(b) Before and after example 2
Figure 6. Scenarios for examples

Example 1 (Initialize, allocate, update)Consider figure 6(a) as the starting point of the following
program fragment at address l in memory, which constructsa reference cell of type

o/2 (i.e., initializes a location, thenadds it to the allocset) and then updates it. Note that

o/2 maybe any type definable in our system. For this example, assume that register r6 is a special register that always pointsto the next address to be allocated; then, to add a location
to the allocated set, we must simply increment this register.For brevity, we have omitted "

*k, r, m." from the followinginvariants.

{9a, i. r(1) :i,k,a,m o/1 ^ r(4) :i,k,a,m o/2^

r(5) /2 dom(a) ^ r(5) = r(6)}
m(r5)  r4{9

a, i. r(1) :i,k,a,m o/1 ^ r(4) :i,k,a,m o/2 ^ m(r(5)) :i,k,a,m o/2}
r6  r6 + 1{9

a, i. r(1) :i,k,a,m o/1 ^ r(4) :i,k,a,m o/2 ^ r(5) :i,k,a,m ref o/2}
m(r5)  r4{9

a, i. r(1) :i,k,a,m o/1 ^ r(5) :i,k,a,m ref o/2}

Example 2 (Cycles in memory)Our model can handle cycles in the memory graph. Figure 6(b) depicts the situation before and after executing thestore instruction in the following Hoare triple, where

F de-notes
*o/. ref int [ ref o/ :{9

a, i. r(1) :i,k,a,m ref int ^ 100 :i,k,a,m rec(F )}
m(r1)  r1{9

a, i. 100 :i,k,a,m rec(F )}

9 Typed machine language

A limitation of the semantics we described in section 7is that it does not allow us to represent arbitrarily nested
recursive and quantified types such as the following:

rec(*ff. ref(rec(*fi. (ref fi) [ ff)))
Typed Machine Language, described by Swadi and Appel,[31] accommodates arbitrarily nested recursive and quantified types using DeBruijn indices. Our new semantics iscompatible with this approach.

10 Machine-checked proof

All of our proofs are machine-checked, and furthermore,these proofs have an actual use: they form part of the proof
of safety of a machine-language program in a PCC sys-tem. The logic that we use is Church's higher-order logic
with a few axioms of arithmetic; we represent our logic,and check proofs, in the LF metalogic [10] implemented in
the Twelf logical framework [25]. Our proof "implemen-tation" consists of about 16,500 lines of Twelf code, using the encoding of higher-order logic described by Appeland Felty [4]. The implementation of the Appel-McAllester
model (without mutable references) consisted of 8,200 linesof proof, while that of the Appel-Felty model (with neither
contravariant recursive types nor mutable references) con-sisted of 5,400 lines.

11 Conclusions & related work
Denotational vs. structured operational semantics. Inour model we prove all type inference rules as derived lemmas. The reader may have wondered if our denotationalsemantics approach or an operational (purely syntactic) approach is the right one to take. We should observe thatour model is a mix of denotional and operational semantics. Our validstate predicate behaves like the inductionhypothesis of a syntactic progress-and-preservation proof,
though in the indexed model the induction is over the num-ber of steps that can be executed in the future rather than the
past. We have used the semantic approach to build a syn-tactic type system for Sparc instructions with 1032 clauses
(including both operator definitions and typing rules). Thesyntactic proof of the soundness of this type system would
require the analysis of close to a thousand cases for eachproperty proved by induction. A person doing the syntactic proof of this theorem would, no doubt, tire of thelarge number of cases and soon settle on an "uber-property
to use as the induction hypothesis, just as we have done us-ing

validstate. There really is a continuum between thepurely syntactic and purely semantic approaches -- types

in the Appel-Felty [4] model were sets of terms, in Appel-McAllester [5] they were domains of terms, and in this

10

model we have domains of terms with embedded syntax.We believe that in practice our approach has turned out to
be more modular than a purely syntactic approach.
Compositionality and syntax-in-the-semantics. Wehave presented a model of general references based on

possible-worlds semantics. This model is not composi-tional in the conventional sense. To see why, consider the
fact that a value x is of type ref o/ if and only if it has type
o/ in the extensional sense (which, in our model, means byinspection of the registers and memory) and also has type

o/ in the intensional sense. The intension indicates that xwill continue to be of type

o/ indefinitely. References inML and Java have an intensional component: when a ref

cell is allocated it is tagged with the type that it must havefor its lifetime. We suspect that only purely extensional
concepts can have a (strictly) compositional semantics.Kripkean possible worlds have proven extremely valuable
in modeling intension. So let us consider the nature ofpossible worlds. Peregrin's [24] analysis concludes that "a
possible world in the intuitive sense can be explicated asa maximal consistent class of statements". This implies
that to give the semantics of possible worlds we requiretechniques like coinduction [23, 17, 6] or non-well-founded
sets [2], each of which is in some sense syntax-dependent.In light of that, and Peregrin's conclusion that "possible worlds are language dependent", our embedding ofsyntactic types (that express intension) in the semantics
seems unavoidable. But the latter should not be interpretedas: "the use of G"odel numbers in the semantics seems
unavoidable" -- we use G"odel numbers to encode ourstratified semantics in higher-order logic, but even without
that, the stratified semantics itself contains syntactic types(in the allocset

i).

Game semantics. Hintikka [11] advocated the use ofgame-theoretical semantics to model possible worlds.

Game semantics is especially useful in removing fromconsideration all

impossible possible worlds. Abramsky,Honda and McCusker[1] describe a game semantics of general references that they show to be fully abstract. In thismodel, reference types are modeled by their behavior, or
more specifically as a product of a "read method" and a"write method" in the style of Reynolds [27]. This representation is quite different from that in location-based modelssuch as ours. It would be interesting to see if such a model
could be incorporated into a foundational PCC system.
Levy's possible-worlds model. Recently, Levy [15] de-scribed a possible-worlds model for general references.

There are interesting correspondences between his modeland ours. His

world-store (w, s), where w is a world and s isa
w-store, (i.e., each location in s is well-typed with respectto

w) corresponds to a valid state (a, m) in our model. Hisaccessibility relation between worlds resembles ours. His

model has the property: "if w <= w0 then every wo/ -valueis a

w0o/ -value" (where wo/ -value denotes a value of type o/in world

w); this corresponds to extensible in our model.The definition (denotation to be more precise) of the type

ref o/ in his model is: [[ref o/]]w = $wo/ (where $wo/ denotes"the set of cells of type

o/ in w"). Notice that [[ref o/]] is de-fined in terms of the syntax

o/ rather than the semantics [[o/]]; that is, this semantics is not compositional either. Levy is

faced with the same kind of circularity that we described insection 4. He solves it by observing that recursive equations
on domains have solutions. We solve it by showing that ourhierarchy of types has a limit.

Locality of reasoning. We have shown how our seman-tic model provides us with rules (lemmas) that allow us to
prove properties of programs with mutable references -- aslong as these properties are expressed as types. There has
been a great deal of work on program-proving for pointers;here, we discuss only the formalism described by Ishtiaq
and O'Hearn [14] (which is closely related to the work ofBurstall and Reynolds [7, 28]). When proving properties
of programs that mutate the heap, a great deal of effort isspent reasoning about what does not change. Ishtiaq and
O'Hearn use the BI logic [20] which provides a spatial formof conjunction * such that the statement

P * Q is true justwhen the current heap can be split into two components,

one of which makes P true and the other of which makes Qtrue. This operator allows them to introduce frame axioms
(which describe invariants of the heap) using the rule,{

P }C{Q}{
P * R}C{Q * R} ModifiesOnly(C) " free(R) = ;

where ModifiesOnly(C) is the set of (free) variables thatare updated by the command

C. This resembles the follow-ing rule in our system, though in our model,

R is restrictedto type judgments such as
r(1) :a,m o/1 ^ 100 :a,m o/2(where 100 may be a memory location). Also, in our model,

ModifiesOnly(C) is the set of registers that are updated bythe command

C and free(R) is the set of registers aboutwhich
R contains assertions:{

P }C{Q}{
P ^ R}C{Q ^ R} ModifiesOnly(C) " free(R) = ;
The use of ^ instead of * has important consequences. Con-sider the situation in figure 1(b). Now suppose we have the

following C, P , Q, and R:

P = 9a. r(5) :k,a,m ref o/2 ^ r(4) :k,a,m o/2
C = m(r5)  r4
Q = 9a. r(5) :k,a,m ref o/2
R = 9a. r(1) :k,a,m o/1

If {P }C{Q} holds, then using our frame-axiom introduc-tion rule, we can conclude {

P ^ R}C{Q ^ R} holds. Wecannot conclude {
P *R}C{Q*R} using their frame-axiomintroduction rule because in this situation (figure 1(b)) the

heap cannot be split into two parts, such that one part satis-fies

r(5) :a,m ref o/ and the other part r(1) :a,m o/1. Theirframe axiom introduction rule is useful when aliasing is not

11

expected to occur because their predicates R are strongerthan just typing judgments.
Other related work. The use of a store typing mappinglocations to types is not new. Tofte [32] uses this approach
in his type soundness proof for polymorphic references.Tofte, however, makes use of coinduction to handle cycles
in the memory graph. Harper [9] has shown how a progress-and-preservation proof can be arranged so that there is no
need for coinduction. Our model, meanwhile, can handlecycles in memory by virtue of the index

k. For a referenceto a memory cycle to be well-typed, we only need to know

that it is well-typed to approximation k. With each mem-ory dereference the

k decreases. Hence, there is no need forcoinduction.

A common feature of models of mutable state is that theyspecify

how the state is allowed to vary over time. Mod-els for
Idealized Algol developed by Reynolds and Oles[27, 21, 22] make use of functor categories indexed by possible worlds or store shapes to specify how the size of thestore, as well as its contents, may change at any point in the
program. We note, however, that these models do not han-dle general references. Stark [30] (building on work done
with Pitts on possible world models of the nu-calculus [26])describes a denotational semantics for

Reduced ML that in-cludes integer references.

12 Future work

All practical languages provide some means for manag-ing memory, but the model that we have described does not
allow memory to be reclaimed. Building a possible-worldsmodel that permits deallocation is challenging in the context of ML-style references where the type of a memorycell is fixed upon allocation; (technically, the difficulty lies
in defining an extend-state relation that permits deallocationand is transitive). We are attempting to extend our possibleworlds model to allow region-based memory management.

Appel and McAllester's indexed model [5] has both asimple, nonextensional version and an extensional version

using PERs. It is not trivial to make an extensional seman-tics for general references because the equivalence of two
values depends on the set of their free locations. We intendto investigate this.

Acknowledgements. We would like to thank Peter O'Hearn
for noting that our model is a possible-worlds model and for pointing out Paul Levy's related work, and the anonymous referees for
various helpful comments and suggestions.

References

[1] S. Abramsky, K. Honda, and G. McCusker. A fully abstract

game semantics for general references. In Proceedings Thirteenth Annual IEEE Symposium on Logic in Computer Science, pages 334-344, Los Alamitos, California, 1998. IEEE
Computer Society Press.[2] P. Aczel. Non-Well-Founded Sets. Center for the Study of

Language and Information, Stanford University, 1988.[3] A. J. Ahmed, A. W. Appel, and R. Virga. A stratified semantics of general references embeddable in higher-order
logic. Technical Report TR-650-02, Princeton University,
May 2002.[4] A. W. Appel and A. P. Felty. A semantic model of types and

machine instructions for proof-carrying code. In POPL '00:
The 27th ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages, pages 243-253. ACM Press,
Jan. 2000.[5] A. W. Appel and D. McAllester. An indexed model of recursive types for foundational proof-carrying code. Technical
Report TR-629-00, Princeton University, Oct. 2000.[6] J. Barwise and L. Moss. Vicious Circles: On the Mathematics of Non-wellfounded Phenomena. Cambridge University
Press, 1996.[7] R. M. Burstall. Some techniques for proving correctness

of programs which alter data structures. In B. Meltzer and
D. Michie, editors, Machine Intelligence 7, pages 23-50.
Edinburgh University Press, Edinburgh, Scotland, 1972.[8] M. P. Fiore, A. Jung, E. Moggi, P. O'Hearn, J. Riecke,

G. Rosolini, and I. Stark. Domains and denotational semantics: History, accomplishments and open problems. Technical Report CSR-96-2, School of Computer Science, The
University of Birmingham, 1996. 30pp., available from
http://www.cs.bham.ac.uk/.[9] R. Harper. A note on: "A simplified account of polymorphic references" [Inform. Process. Lett. 51 (1994), no. 4,
201-206; MR 95f:68142]. Information Processing Letters,
57(1):15-16, 1996.[10] R. Harper, F. Honsell, and G. Plotkin. A framework for

defining logics. Journal of the ACM, 40(1):143-184, Jan.
1993.[11] K. J. Hintikka. Impossible possible worlds vindicated. Journal of Philosophical Logic, 4:475-484, 1975.[12] P. Hudak, S. Peyton Jones, and P. Wadler. Report on the programming language Haskell, a non-strict, purely functional
language, version 1.2. SIGPLAN Notices, 27(5), May 1992.[13] M. R. A. Huth and M. D. Ryan. Logic in Computer Science: Modelling and reasoning about systems. Cambridge
University Press, Cambridge, England, 2000.[14] S. Ishtiaq and P. W. O'Hearn. BI as an assertion language

for mutable data structures. In Conference Record of POPL
2001: The 28th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, pages 14-26, New
York, 2001. ACM.[15] P. B. Levy. Call-by-Push-Value. Ph. D. dissertation, Queen

Mary, University of London, London, UK, March 2001.[16] N. G. Michael and A. W. Appel. Machine instruction syntax
and semantics in higher-order logic. In 17th International
Conference on Automated Deduction, June 2000.[17] R. Milner and M. Tofte. Co-induction in relational semantics. Theoretical Computer Science, 87(1):209-220, 1991.[18] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to typed assembly language. ACM Trans. on Programming Languages and Systems, 21(3):527-568, May 1999.

12

[19] G. Necula. Proof-carrying code. In 24th ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, pages 106-119, New York, Jan. 1997. ACM Press.[20] P. W. O'Hearn and D. J. Pym. The logic of bunched implications. Bulletin of Symbolic Logic, 5(2):215-244, June
1999.[21] F. J. Oles. A Category-Theoretic Approach to the Semantics

of Programming Languages. Ph. D. dissertation, Syracuse
University, Syracuse, New York, August 1982.[22] F. J. Oles. Functor categories and store shapes. In P. W.

O'Hearn and R. D. Tennent, editors, ALGOL-like Languages, Volume 2, pages 3-12. Birkh"auser, Boston, Massachusetts, 1997.[23] D. Park. Fixpoint induction and proofs of program properties. In B. Meltzer and D. Michie, editors, Machine Intelligence, volume 5, pages 59-78, Edinburgh, 1969. Edinburgh
University Press.[24] J. Peregrin. Possible worlds: A critical analysis. The Prague

Bulletin of Mathematical Linguistics, 59-60:9-21, 1993.[25] F. Pfenning and C. Sch"urmann. System description: Twelf
-- a meta-logical framework for deductive systems. In
The 16th International Conference on Automated Deduction. Springer-Verlag, July 1999.[26] A. M. Pitts and I. D. B. Stark. Observable properties of higher order functions that dynamically create local names, or: What's new? In A. M. Borzyszkowski
and S. Sokol/owski, editors, Mathematical Foundations of
Computer Science 1993, volume 711 of Lecture Notes in
Computer Science, pages 122-141, Berlin, 1993. SpringerVerlag.[27] J. C. Reynolds. The essence of Algol. In J. W. de Bakker

and J. C. van Vliet, editors, Algorithmic Languages, pages
345-372, Amsterdam, 1981. North-Holland.[28] J. C. Reynolds. Intuitionistic reasoning about shared mutable data structure. In J. Davies, B. Roscoe, and J. Woodcock,
editors, Millennial Perspectives in Computer Science, pages
303-321, Houndsmill, Hampshire, 2000. Palgrave.[29] S.A. Kripke. Semantical considerations on modal logic. In

Proceedings of a Colloquium: Modal and Many Valued Logics, volume 16, pages 83-94, 1963.[30] I. D. B. Stark. Names and Higher-Order Functions. Ph. D.

dissertation, University of Cambridge, Cambridge, England,
December 1994.[31] K. N. Swadi and A. W. Appel. Foundational semantics for

tal syntactic rules via typed machine language. Submitted
for publication, 2002.[32] M. Tofte. Type inference for polymorphic references. Information and Computation, 89:1-34, November 1990.

13