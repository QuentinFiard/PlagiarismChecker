

Mixin Modules
Dominic Duggan* Constantinos Sourelis

Mixin modules are proposed as a new construct for module languages, allowing recursive definitions to span module boundaries.
Mixin modules are proposed specifically for the Standard ML language. Several applications are described, including the resolution
of cycles in module import dependency graphs, as well as functionality related to Haskell type classes and CLOS generic functions,
though without any complications to the core language semantics.
Mixin modules require no changes to the core ML type system, and

only a very minor change to its run-time semantics. A type system
and reduction semantics are provided, and the former is verified to
be sound relative to the latter.

1 Introduction
The Standard ML module language has gained some interest because of its state-of-the-art module language. The module language
provides a clean separation between modules and interfaces, allowing a module to export several interfaces. A particular strength of
the language is its treatment of prrrameterized modules (functors).
Standard ML provides an innovative mechanism for combining

abstraction and sharing: sharing constraints in a fonctor building
block can be used to place some graph structure on the import hierarchy over which it abstracts. The original Standard ML module

system provided weak support for separate compilation. Mo&dalike manifest type definitions in opaque interfaces have been proposed as an alternative module design, facilitating both separate

compilation [18] and first-class modules [13, 26].

An aspect of the Standard ML module system which remains
problematic is its interaction with recursive constructs which cross
module boundaries. The problem is that such constructs are not allowed; the module dependency graph is required to be acyclic. This
IS an instance of a problem shared by all other module systems.
The essence of the problem is that recursion cannot cross module
boundaries. As a resul~ for example, mutually recursive datatypes
in ML must be defined in the same module. This results in a somewhat monolithic module structure, in which one module collects
the datatype definitions, while client modules implement the functionality required for these datatypes. This monolithic structure is

at odds with data abstraction, which would entail encapsulating the
types, and the operations on those types, behind opaque interfaces.

Various languages take different approaches to reconciling the
need to allow recursion to cross module boundaries. Haskell and
Modula-3 allow cycles in the module import dependency graph.

Although some such approach might be investigated for the Standard ML module system, this is not a general solution to what we

"Address: Department of Computer Science, University of Waterloo, Waterloo,
Ontario, Canada N2L 3G1. dduggaa@uwat erlo o. ca

Permission to make digitaihrd mpy of part or all of thii vmrk for personalor classroom use is ranted without fee provided that copies are not made

ior distributed for pro t or eommereiai advantage, the copyright notice, thetitle of the publication and its date appear, and notkx is given ttrat
copying is by permission of ACM, Inc. To mpy otherwise, b republish, topoet on servers, or to redstribub to lists, requires prior apeoitio permission
and/or a fee.

ICFP '96 5/96 PA, USAO 1996 ACM 0-69791 -771 -!XWOO05...$505O

would like achieve in breaking up recursive constructs across modules. For example the Haskell language also has type classes [3 1].
In the semantics provided in [10], type classes allow recursive definitions to cross module boundaries by breaking up recursive functions into implementations of an overloaded operator. The type

system allows these implementations to be type-checked independently and then implicitly combined at points where an overloaded

operation is used in an application.

In this paper we present an extension to Standard ML modules which supports modular building blocks where recursive definitions cross module boundaries, but which is a conservative extension of the existing module system. This approach alIows SML
modules to be "decomposed" into smaller parts, called mixin modules. Mixins allow recursive definitions to be broken up into modular fragments: both recursive function and recursive type definitions may be broken up and spread across modules. A combining operation allows these fragments to be combined, and a closure operation allows an ordinary Standard ML module to be produced from the composition of several mixins. At the core language
level, we allow empty dat at ype definitions. These are primarily
for mixins which rely on other mixins to provide the definitions of

such datatypes (Sect. 2.2). We introduce an inner pseudo-variable,
which allows access to further extensions of a recursive function

within a mixin module body.

We provide severaJ examples of the usefulness of our approach. Beyond resolving circular dependencies in import graphs,

we demonstrate how our approach provides similar functionality to

Haskell type classes [14] and CLOS generic functions [17]. This
is done without extending the core ML type system or operational

semantics. The former fact means tha~ with our approach, the core
language programmer sees a familiar and widely-accepted type

system. The latter fact means that our approach allows a straightforward efficient run-time implementation.

Section 2 provides several examples to motivate mixin modules
Section 3 presents the formal type system for mixin modules; this
type system is an extension of recent reformulations which have
been proposed for SML modules [13, 18, 19]. Section 4 presents an
operational semantics for mixin modules, in the form of a reduction

system which maps mixin modules to ordinary SML modules. A
semantic soundness result verifies that the semantics does not "fail"
due to type errors during reduction. Section 5 considers related and
future work, and provides our conclusions.

2 Examples of Mixin Modules
The addition of mixin modules to the ML module system requires

the introduction of a new kind of module construc~ in addition to
structures and functors:

structure l'f = mixin (defml ) body (de@2) ini.t (dejm~) end
The body of the mixin, (de@s2), is required to be a collection of
datatype and recursive fimction definitions. These definitions may
use type and value definitions from (defisl ), which we refer to as
the prelude of the mixin. The definitions in (dej%sl ) and (defns2)

are both visible in (dejks3 ), which we refer to as the initialization

262

structure Num =
Rixin body

datatype terra = CONST of int
datatype value = NUM of int

type env = string -+ value
fun eval (CONST i) . = NUM i

I evalt39 (e:env) = imnertme
md (* Num *)

structure Func =
nixin

fun bind(x,v,e) = fny +

if x=y then v else e y
~ody

datatype term= VAR of string I

ABS of string * term I APP of term * tern
datatype value =+ CLOS of term * env
withtype env = string + value

fun eval (VAR x) (env:env) = env x

I eval (f as ABS .) e = CLOS (f, e)
I eval (APP (rator,rand)) e =

let val CLOS (ABS(x,b),e') = eval rator e

in eval b (bind (x,eval rend e,e'))
end
I eval tm e = innertm e
md (* Func *)

Figure 1: Simple Interpreter Mixins
secdonofthemixin. (defisl) and (de@s3) contain type, function

and module definitions, and have the usual ML semantics. The
interesting part of themixin isthemixin body, (defns2). Thedefinitions in this partare assumed to berecorsive. More importantly,

these definitions are assumed to be open to further extension, by
combining the mixinwithother mixins.When twomixinsare combined, recursive definitions with the same names in the mixin bodies are merged. Corresponding to mixin modules we have mixin
signatures:

signature S = mixsig (dec.kl) body (deckz) init (decZs3) end
Correspondingto the composition roles for mixin modules, our
module calculus also hasacomposition ndeformixin signatures.
Our module calculus also has an equalily theory for signatures

which allows the composition of mixin signatures to be transformed into amixin signature of the aforesaid form. The closure

of a mixin module produces a module with an ordinary SML signature. Like structures, mixins may occur inside functor bodies

and may be argumentsto fonctors, so thereis no problem with
tbeir interaction with the SML module system. An extension we
do not consider is mtiinfinctors, mixins which may be combined

and closed into afunctor. We leave this for futore work. We now
provide several examples to demonstrate the use of mixins.

2.1 Simple interpreter Mixins

Figure 1 provides a simple example of the use of mixins, for providmgamodular implementation ofan interpreter. Theexampleis

asimple version ofthatused by Steele to motivate pseudo-monads
[29]. Theexample provides two building blocks, one fornumbers
and the other for functions. Both building blocks provide cases
forthedefmition of theterm andvalue datatypes. The calculus

Figure 2: Binding of inner, and of recursive references to eval,

in definition of eval in Num and Func

of mixin modules includes an operator for combining mixins, @
In the composition Num @ Func, the two definitions for the term

datatype are combined into a single datatype definition. Similarly

the two definitions for eval are combined. The pseudo-variable

inner, available within a function in the body of a mixin module,
provides programmer control over how this combination is performed. In the result of composing the definitions of eval, the
resulting single eval function first checks for the CONST constrictor (using the Num implementation) and then delegates to the Func
implementation to check for the other constructors. Because of

inner, composition @ is not commutative.

The Func mixin demonstrates the important points of the example. Both the term datatype and the eval function contain
recursive references. However these recursive references are not

necessarily to the current definitions of these datatypes. The final fixed point of these recursive definitions may include definitions provided by other mixins, and the recursive references within

the Func mixii refer to these final fixed points. The definition of

inner, on the other hand, is not a recursive reference to the definition of eval, but anon-recursive reference to further extensions of

eval contributed by other mixins composed to the right of Func.

Figore 2 illustrates this graphically. An initial call to the eval
function exported by the composition of these mixins begins by executing the code defined in the Num mixin. Invocations of inner

transfer control to the code defined in the Font mixin. At any point
recursive references to eval transfer control back to the code defined in Nun

2.2 Cyclic Import Dependencies
The Standard ML module system prohibits cycles in the module
import dependency graph. Figore 3 provides a practical example
of the difficulties this causes, from the Standard ML of New Jersey

compiler [1]. This example shows some of the import hierarchy for
the modules comprising the front end of the compiler, modified by
the addition of a type explanation facility to the type-checker [9].
The type explainer stores explanations in extra information fields
in type variables. As a result the Types module is now (through

TypeExplain) a client of Absyn, which introduces a cycle in the
import hierarchy. Our implementation of type explanation avoided

this cycle by using unsafe type casting! The only alternative was
to merge the Types, Variable and Absyn modules into a single "mega-module~' since the types and abstract syntax datatypes

are mutually recursive (with type explanation). Even so, this "disguised" import cycle shows up in other parts of the hierarchy. For
example, TypesUt il exports operations for creating new type variables; these variables are initialized with null explanations, so the

263

PrintUt il Types
TYP!U~/~;~\,I

%

~:Modules

I /'Absyn ,'

// I

/1
/'.

tSoduleUtil

`pB\/7PPAbs yn

BV.Type Explain

IUnify
>1TypeCheck

Figure 3: Jmport Hierarchy of SML/NJ
operations for creating these null explanations must be placed in.

TypesUt il rather than TypeExplain, where they really belong
(where the type explanation data structures are declared).

One might be tempted to believe that these problems can be
solved using functors, which have received a great deal of attention
in the design and implementation of SML modules. For example,
we might try to make Types into a functor, parametrized over

the type explanations which are recorded with type variables. This
functor is then instantiated at the point where Abs ynis defined. LJnfortunately this approach only serves to illustrate further problems

with SML modules:

functor Types'F (T: TYPE-EXPLAIN) : TYPES = . . .
functor TypeExplainF (A: ABSYN) : TYPE-EXPLAIN = . . .

functor AbsynF (T: TYPES) : A13SYN = . . .
structure Absyn = AbsynF (Types)

and TypeExplain = TypeExplainF (Absyn)

and Types = TypesF (TypeExplain)

Functoriziig the code only delays the problems described earlier
until the point at which the functors need to be instantiated. Again

we face the problem that the abstract syntax and type datatypes
are mutually recursive, so their definitions cannot span different
modules.

The obvious solution to these problems is to allow recursive
structures and functors. Modula-3 [24] is an example of a language
which allows cycles in module dependency graphs. This has significant implications for the semantics of modules. Type definitions in
modules may be mutually recursive, so type-checking must check
for equality of rational trees. Allowing rationrd trees, as in Modula3, would involve adding circular unification to the type inference

algorithm. Although this can be done, experience suggests that
some type errors are no longer detected statically in the resulting
type system; furthermore the inferred types can be somewhat complicated [27]. The semantics of module initialization in Modula-3

are that within a strongly connected component in the import dependency graph, the order of initialization is left undefined. This

is clearly unacceptable in ML-like languages, where variables are
immutable and bound to clearly defined initial values. In fact current implementations of Standard ML modules explicitly rely on

the absence of circularities in the initialization of modules [2].

Essentially the semantics of module composition in Standard
ML (and ahnost all other module languages) is based on functor application. This is so even if functors are not explicitly involved; in

the SML/lYJ implementation of linking [2], an ordinary ML structure is implemented as a function which is applied to a vector of
imports at link-time, and produces a vector of exports. Mixin modules introduce anew form of module composition, based on "merging" the fixed points of recursive definitions. Within the body of

the mixin, all value definitions are required to be k-abstractions;
since evshsation is delayed, order-of-initialization ambiguities are
avoided. Outside of the body of the mixin, the semantics of value
definitions are the same as that for Standard ML. As noted, mixin
composition is non-commutative because of the use of inner. The
initirdixation order for definitions outside of the mixin bodies in a
mixin composition is to initidze the "child" (rightmost) definitions

first for reasons made clear in Sect. 4.

The solution to the original problem is then to declare Absyn,
TypeExplain and Types as mixins. This allows for example the
type explainer to be reused with different abstract syntaxes and type

systems, by combining it with different Absyn and Types mixins.
The types module specifies a datatype for object language types,

and some useful functions over that representation which are required by clients. The module makes use of the undetermined type
explanation datatype by giving a null definition for this datatype,

depending on a type explanation mixin to complete its definition.
This requires a mild extension of core ML, allowing empty datatype

definitions. A particular implementation of a compiler frontend
with type explanation is then constructed by combining these mixins and "closing up" the result (using the mixin operations provided
in Sect. 3}

structure Types = mixin body datatype explain;

datatype, ty = . . . end
structure TypeExplain = . . .
structure Absyn = . . .

structure Front = C1OS (Types@ TypeExplain@ Absyn)

Consider if the frontend requires an operation for copying abstract
syntax trees. Within the Types mixin, we define a function copyTy
which recurses over a t y data structure. At some point this function
needs to copy explanations. To do this, c opyTy makes a recursive
call to c opyExplai~ where the latter is defined by:

fun copyExplain (exp: explain) : explain = inner (exp)
The Types mixin then relies on the type explanation mixin to complete the definition of copyExplain (and the latter will in turn call

cop yAbs yn, the implementation of c opyAbs yn in Abs yn will in
turn call copyTy).

2.3 Parametric Overloading and Generic

Functions

The next example compares mixin modules with parametric overloading [16], as exemplified by Haskell type classes [14], and with
CLOS generic functions [17]. Although parametric overloading is
well-understood for single-parameter overloading, the implementation of type classes remains problematic, necessitating as they do
call-site closure construction at the uses of overloaded functions.
TWe classes remain the main performance bottleneck in Haskell

264

structure Linear =
mixin body

datatype car = VECTOR of car list I

MATRIX of car list list
fun (VECTOR VS) * (VECTOR VS') = . . .

I (MATRIXms) * (vEcTORVS) = . . .

I v * (WCTOliVS) =

VECTOR (map (fn v' ~ v * v') VS)
I V*V' =inner(v,v')
end (* Linear *)

structure Number =
mixin body

datatype car = REAL of real I INT of int
fm (8JMLx) * (INTY) = . . .
end (* Number *)

Figure4:Numencal AlgebraMixins
comuilers. Furthermore tvoe-checkitu zforsom eextensionsofua-. . .
rameter overloading remains unclear. `Figure 4 demonstrates a ~se

of mixin modules for an application of "multi-parameter" parametric overloading. The Linear mixin implements linear algebra operations for vectors and matrices, while the Number mixin irrtplements operators for integers and rerds. In the definition of multiplication in Linear, there is a case for vector-vector and matrixvector multiplication, with the third clause handling scalar-vector

multiplication (where scalars are meant to be provided by another
mixin). Duggan and Ophel [11] demonstrate that in any type
system for multi-parameter parametric overloading which is rich
enough to support the example k Fig. 4, type-checking is undecidable.

Mixin modules avoid these decidability and performance problems. Type-checking at the core language level is exaetiy the same

as in Standard ML. Furthermore our module calculus avoids all of
the implementation problems associated with type classes. The definitions of a mixin module cannot be used until the module is closed
up to an ordinary ML module. M the point where this is done, the

datatype and function definitions in the mixin body are closed to
any further extensions, and code generation and optimization may
proceed without needing to accommodate future extensions to the

definitions. As a result mixin modules introduce no complications

for runtime efficiency.

Mixin modules can also model other extensions of parametric overloading. For example, a facility analogous to type constructor classes [15] can be modelled using mixins with collection
datatypes:

structure List = mixin body

datatype a carr = LIST of cZ list
fun nap f (LIST XS) = . . .

I map f xs = inner f xs
end (* List *)

structure Tree = mixin body

datatype a carr = LEAF I

NODE of a * a carr * u. carr
fun map f LEAF = LEAF

I map f (NODE(x,tl,t2))

NODE(f x,map f tl, map
I map f xs = inner f xs
end (* Tree *)

.
f t2)

Mixin modules and Haskell type classes each have their relative advantages. There is an essential difference between the two:
the latter assumes homogeneous collection data structures (for example, all elements of a vector are integers, or all are matrices,
etc). The approach of mixirt modules allows each element of a
vector to be in the union of the types which make up the carrier

type, so the approach of mixins allows heterogeneous collections.
Run-time dispatching is then based on the tags associated with the

data constructors. The approach of mixin modules appears preferable for e.g. graphical user interface applications. For example, we
can structure an extensible window library as a collection of mixin
modules, with an extensible window type; the basic window library
may be extended by adding mixin modules defining new window
types. The advantage of the mixin modules approach maybe seen
by considering e.g., window hierarchies, which can be represented

as a list of subwindows associated with each window. A function
which operates over the window hierarchy dispatches based on the

data constructor tag associated with each window in a list of subwindows. In this way mixin modules maybe seen as in some sense

analogous to CLOS generic functions [17]; what is lacking from
mixirt modules is any notion of subtyping or subclassing, although
subclassing is available with an extension of mixin modules which
we consider in Sect. 5.

The approach of type classes cannot handle this example of an
extensible window system, because it requires that collection types

be homogeneous: the immediate subwindows of a given window
would all have to be of the same window type, which is clearly
useless. On the other hand the approach of type classes is preferable for applications involving homogeneous collection datatypes
(e.g. vectors and matrices), since for example in mapping an overloaded operation over a vector, dispatching is done once for the
entire vector, rather than repeatedly for each element of the vector.

3 Typing Mixin Modules
In this section we provide the static semantics for mixin modules.
Section 3.1 summarizes the syntax of an ML-like minilanguage,
while Sect. 3.2 provides the type rules for mixins. The dynamic
semantics are provided in the next section.

3.1 Syntax
Figure 5 contains the grammar of the calculus used in the presentation of mixin semantics and typing. Namess, t, x denote module,
type, and value components of modules respectively, while identifiers s~, tt, tt bind to modules, types and values. Identifiers ii
consist of an external name i and an internal name i. Following
the approaches of Leroy [18] and Harper and Lillibndge [13], only
the internal name of a bound identifier admits a-conversion; this
pertnits module access by external name and composition of corresponding fields in mixin bodies. This renaming is implicit in the

modules calculus (similarly to other calculi such as the l-calculus),
but is necessary for some of the preconditions of the type rules
which require internal names to be distinct in the concatenation of
environments and signatures.

The two main classes of expression are modules Mt and expressions E. A structure is a collection of definitions M, and a functor
is a mapping fkom modules to modules. In addition we now have
m~@s as a new module construc~ denoted by Ml <(M)M2. This
is abstract syntax for mixin module expressions of the form mixin
h41 body M init &fz end used in the previous section. Ml and
M2 denote the prelude and initialization parts, respectively, of the

mixin. G(M) denotes the body, in which all (type and value) definitions are mutually recursive. Module types are defined by the\St

265

M, ::=

St ::=

s ..--..--

P . ._. .--

J'& ::=

E . ._. .--

R . ._. .--

P . ._. .--

struct M end I functor(structure s,:S~)kf~ I (JV&:S~)
P I P@) I ~<(~b)M t ~~ ~~t t clos(~~)sig S end I funsig (structures, :S1)S1 I S $(S) S

typett I t=~ I tis$ I valx,:z

I structure s,:S, I SJ' I e
Slslp.s

1 I x I P.X I P.c(E) I El E2 I Ayfi

[ letDinE I caseEofRI' l'...' l'R"
P+E
x I p.c(q

Figure 5: Syntax
dOm(r) ~ {xlvalx:z~r}u

{tltypetcr}u
{s I structures: S, ~ r}
dom($) s {C 11$=1$1 . .. UC(~) ..@n}n}

cOxts(r) E U{dOm($) I (t is $) c r}

cons(s) S U{dom(@) I (t iS @) C S}
cons(kf) q U{dom($) ] (t iS $) GM}

{

IM(BV(L% )) n IB(BV(SZ)) = {)
`* `s2 5 `1's2 K cOns(Sl) n cOns(S~) ={}

{

dOrn(rl ) n dom(r2) = {}
`1 +`2 s `1 u`2 i cOns(rl ) n cOns(l_'2) = {}

EEU(r,t) ~ (type t) e r and (t is 0'), (t = T) @r

Em(N) ~ {x I y, EN}

IB(ff) E {y I y, C~}

BV(& type tt) = (BV(S) - {t~}t,) U {tt}
BV(& vai A: `c) z (BV(S) - {~}ti) U {XX}

BV($ tis I+) s BV(S)
BV($ t = Z) E BV(S)
BV($ structure s,: S') s (BV(S) - {sj}.,) U {s,}

BV(~, type tt) E ...(sirnfiar)

Figure 6: Definitions

ration of a new type name (type tt)from its definition as a type

abbreviation (t = r) or a datatype (t is $), as explained in the next
subsection.

Our calculus contains severrd simplifications for the sake of exposition. Functor applications are only allowed to have the form
p (pf) where p and p' are paths; this enables us to give a reduction semantics which preserves type identity, a crucial issue in the

design of a module type system with generativity. This sitrtplification is inessential, and we may assume a source-level translation which converts from a more liberal syntax to this one [18].
We only allow simple paths S.SI . . .Sn; in particular we do not have

fonctor applications in paths, as suggested by Leroy [19] for typing higher-order functors. We do this to simplify the presentation,

since higher-order functors do not materially affect the semantics
of mixin modules. We make the simplifying assumption that functors are tist-order, as in Standard ML, although this is not strictly
enforced in the type rules. This assumption is only necessary to

simplify reasoning about type soundness in the next section, due
to the fact that we work with a reduction semantics rather than the
usual denotational semantics. The core language types are simple
type names, projections of type components of structures, and arrow types. This type system can be extended very straightforwardly

to more sophisticated core language types (polymorphic types, parametrized types, constrained types, etc) without contributing anything to the exposition. Finally we assume that each functor takes

a single module as its argumenq this simplifies the type rule for
functor application.

The body of a mixin may only contain type and value definitions. We make this restriction because of our decision that it

should always be possible to transform a combination of mixins
into an ordinary ML module. For simplicity we only allow datatype
definitions, although type abbreviations can also be added (with

some restriction on recursive references having to go "through" a
datatype). Mb gives the syntax of mixin body definitions. AU value
definitions, and all type definitions, are assumed to be mutually recursive. As with function definitions, value definitions are required
to be k-abstractions. This prevents circuhirities in initialization.

Figure 6 provides several metafunctions which are used in the
type rules in the next subsection. dorn(r) denotes the internal
names in the domain of r. dom(+) denotes the constructors in

a datatype definition. cons extends thk to environments, signatures and modules. BV(S) denotes the set of (internal name, external
name) pairs exported by the sequence of declarations S, this operation excludes names which are "shadowed" by declarations to
the right in S (i.e., a variable xx is excluded if there is another declaration with external name x to the right of it in S). BV(M) is

defined similarly for sequences of definitions. IN(N) returns the
internal names in a set of names, while EN(N) returns the external

names. NEW(r, t ) is a predicate which checks that there is a declaration for the name t,but that there is no type or datatype assertion for
t. S1 @S2 denotes the concatenation of the declarations of S1 and
S2; the side-condition on this operation ensures that internal names

in the declarations are renamed apart beforehand, and that the declarations have no data constructors in common. Similarly rl + r2
denotes the concatenation of two type contexts, with the proviso

that they have no internal names in ~~mmon in their domai&,

syntax class, and consist of signatures for structures, fonctor signatures for functors, and a new form of module type for mixins,
S1~(S)S2. Definitions M in a module consist of structure definitions, type definitions and value definitions. Value definitions are

separated into a separate syntax class since they may also appear
in a let-expression. Value definitions include a special fun form
for defining mutually recursive functions; each body Et is assumed

to be a k-abstraction. In type definitions, we separate the decla3.2 IWlixinTyping Rules
We base the module type system on the systems of manifest types
proposed independently by Leroy [18] and by Harper and Lillibndge [13] (see also [26]). We base our formulation on the approach
of manifest types because of its relative simplicity in modeling generativity.

266

In the approach of manifest types, a definition in a structure
type t = `c gives rise to the manifest type type t = 7 in the signature of the structure. A subtyping relation on type declarations

includes the rule (type t = @ <: (type t).Extended to signatures,
this rule allows type information to be "forgotten" in signatures,

so that manifest types may be made opaque. "Generativity" is obtained by requiring that every top-level module be given a unique
"stamp" (or, be bound to a unique "internal name"), and making

generative types opaque and with their identity determined by their
path beginning at a top-level structure.

We modify this approach in the following ways. We break a
type declaration into two parts, the binding assertion type tand the
defining assertions t= T and tisQ. Each bound type name has
no more than one defining assertion. In the aforesaid approaches

to module typing, only the fist form of defining assertion (for
type abbreviations) is allowed. We introduce the second form of
defining assertion for generative datatypes. With this approach,
datatypes with identical forms but different "stamps" are distinguished; datatypes occupy a middle ground between manifest and
opaque types. The final modification is to type strengthening [18]:

given a structure with path p and signature St, type strengthening
St/p allows the replacement of an opaque type type ttinStwith

the manifest type type tt = pt. Type strengthening in our module

system is given by:

(sig S end)/p
(funsig (S)S,)/p

(sq(s)s)/p
(structures, : S, ; S)/p

(type tt; S)/p

(t='q s)/p
(t is @;s)/p
(valxx : q S)/p

sig S/p end
funsig (S)St

Sqs)s
structures~ : (St/p.s) ; S/p
type tt;t= p.c S/p
Sfp
S/p

valxx : q S/p

Type strengthening allows a datatype to be shared between modules:

structure S1 =

struct datatype f oo = bar; val x = bar end
structure S2 =

S1 : sig type foo = S1. foo; val x: foo end
if true then S1 bar else S2 .x (* type checks *)

Figore 7 provides the type rules for the modules language.
The rules for typing declarations of modules (R-MOD,R-MOD-MR),

structures (R-MOD-SS) and functors (R-MOD-FS), as well as the
rule for fonctor application (R-MOD-PA) are as usual and selfexplanatory. The rule for projecting a modules from within a structure (R-MOD-SP) performs a substitution to construct the signature
ofs. All occurrences of an internal name bound before the declaration ofs in the signature of the enclosing structure are prefixed

by the path to this structure and replaced with the corresponding
external name. This prefixing is also done for data constructors

defined before the declaration ofs. This prefixing step is necessary to properly remove the dependency ofs on its local context
since (as mentioned) internal names admit ~-conversion whereas
external names are fixed. Finaliy Rule R-MOD-TS gives the type
strengthening rule for the calculus, Rule R-MOD-MAT gives the
type rule for explicit signature matching, while Rule R-MOD-SUB

gives the type subsumption rule. We omit type rules for checking
the well-formedness of signatures (r 1-St modtype) and for sub-gptig (r 1- St <: S:

and r E S <: S'), since these are essentially

standard [13, 18, 19].

r~kf,:st r+{structures: S,}l-M:S
r 1- (structures, = M, ; M): (structure S$: .$; S)

(R-MOD)

structures: St e r

rks:sf (R-MOD-MR)

r t- p: (sig S'; structure s,: S, ; S" end) s ~ EM(BV(S"))

e = {p.u/n I n. C BV(S')} U {p.C/c I CG cons(s')}

r F P.S: 0(s,)

(R-MOD-SP)

rt-p:s
rkp:slp (R-hiOD-Ts)

r~kf:s
r i- struct M end : sig S end (R-MOD-SS)

r+{shud~s:s,}kkfl :s/ r 1-S1modtype
r 1-functor(structure s,: S~)M, : funsig(structure s,: S,)Sj

(R-MOD-Fs)

r t- p: funsig(strueture s,: S~)S1 r~p':s;

r F P(P'): {p'/s}st (R-MoD-PA)

rkkf, :s,
rt-pf,:sf):s, (R-MOD-MAT)

rkkft:s, r 1-$ modtype r F S/ <: S/

rhkff:s; (R-h40D-suB)

rkkfp:sp r+vk~b:sb--. ----
r+ SPh%kkfbOk r+ Sp+Sb EMi:Si

r ~ kfp<(kfb)~i : SP$(sb)si (R-MOD-MIX)

r k Ml:s: qs;)s! r E kfz: sjqs;)sf
S;am;=sp r+~ks~18s$=sb S;gjs; =s,

r b kfI @&fz: Sp<(.$b)si

(R-h40D-c0h4P)

r b kff : Sp $(s'b)Si
r ~ CIOS(&ff): Sp @sb @si (R-MOD-CL)

Figure 7: Modules Language Typing Rules
Rule R-MOD-MIX in Figure 7 determines the signature of an
atomic mixin module

rt-MP:SP r+~lkM~:s~
17+?$+~lt-Mb Ok r+~+Tt-Mi :Sir 1-kfpc(kf~)kfj: sp

$(sb)si

(R-MOD-MIX)

This rule tirst constructs the signature Sp of tie prelude section
MP. The operation ~ returns the set of all decl~ations in SP after

removing external names from identifiers. These declarations are

added to the context to perform a "tirst pass" over the body of the
mixin in order to construct a signature sb for the body. The second paSS over the body adds ~ and T to the context. The latter
is needed because declarations within the body are mutually recursive. The second pass can therefore verify the correctness of
types ascribed to mutually recursive functions. The final step is
the derivation of a signature for the initialization section after the

context has been extended with the declarations of the prelude and
body sections. Type inference for the functions in the mixin body is

267

exactly the same as type inference for mutually recursive functions
in Hindley-Milner type inference. Some explicit type information
is necessary if polymorphic recursion is desired.

The fist and second passes over the mixin body are performed
using the rules shown in Figure 8. Rule R-MFP-T checks a binding assertion for a datatype, ensuring that the external name introduced for the type does not occur elsewhere in the mixin module
body. This requirement is appropriate since declarations within the
body section are mutually recursive and, moreover, constructs with
the same external name are extended during composition. Rule RMFP-I handles the defining assertion of a datatype, checking that a
binding assertion has already been encountered and that no other
defining assertions exist for the datatype. The rule also ensures
that data constructors are all new and distinct (checked as a sidecondition of the + operation). Rule R-MFP-V checks a value declaration, requiring that the value be a A-abstraction as explained in

section 3.1.

The remaining rules of Figure 8 perform the second pass over
the body section. Rule R-MSP-V can verify the type of a function

since the bindings for the identifiers of any recursive references
made by the function exist in the context. Before checking the
function, the rule also adds an appropriate binding for the pseudovariable inner which, as demonstrated in Section 2, acts as a placeholder of extensions supplied by other mixins.

Rule R-MOD-COMP in Figure 7 gives the rule for typing the
composition of two mixins Ml @Mz:

r+ fvfl: s;qs~p~ r I-M: s;qsgp~
s;@s; =sp r+q~s;w~=sb S~@jS~=Si

r ~kfl @M'2 : ~p $(~b)~i

(R-MOD-COMP)
The signatures for the relude and initialization sections are com-`?1
posed as S; @S~ and Si @Si respectively, with `~' defined in Figure 6. This operation is essentially sequential composition.

Figure g contains the rules used by Rule R-MOD-COMPto compose the signatures of the bodies of the mixins being composed.

The composition of two signatures S1 and S2 is denoted by S1 @S2.
The rules in Figure 9 allow the composition of two signatures
S1 @S2 to be rewritten to a normal signature. At the heart of these
rules is the R-CB -I rule which joins together the constructors from

the definition of a datatype in two different mixin bodies. The first
premise in this rule ensures that there is no overlap in the constmctors defined for that datatype in the two different mixins. The addition of the combined datatype assertion to the contexg r+ {t is Q},
checks that there is no overlap between the constructors being defined and the constructors already defined in the context r (recall
that r has already combined the constructor definitions to the left
of these datatype definitions in the mixin prelude and body).

The R-CB-TI, R-cB-11 and R-CB-VI rules in Figure 9 allow a
type constructor or program variable which is defined in one mixin
but not the other, to be added to the signature of the mixin resulting
from their composition. We refer to these rules as the inflation
rules. They essentially allow us to inflate the interface of a mixin

with declarations that are missing from its body, in order to allow us
to compose that mixin with other mixins that provide the missing
declarations.

In the composition Ml @&fz of two mixins Ml andM2, we refer
to Ml and M2 as the parent and child modules, respectively. In
the sequential composition of the prelude and initialization parts of

the mixins, the parent mixin's declarations follow the child mixin's
declarations. Consider for example:

structure ml = mixin

type t = int

body val x = fn u: int +- w+l

init val y = x
end
structure mz = mixin

type t = bool
body val x = fn w:int * 3

init val x = true
end

Composing-ml @mz and closing results in a structure:

Struct

type t` = bool; type t = int
val x = fn u:int * w~i
val x> = true; val y = x
end

with signature

sig type t = int

val x: int + int
val y: int + int
end

Note that some renaming of the child mixin's shadowed fields is required. This approach is taken to make the overriding of definitions
in the prelude and initialization part consistent with composition of

bodies: since the parent does not use the inner pseudo-variable in
the definition of x, the definition of x in the child is "discarded." So
in some sense the parentis "in control" and determines what parts

of the child mixin are visible in the final structure.

Rule R-MOD-CL determines the signature of an ML structure
resulting from closure of a mixin module. The signature is the

concatenation `o', as defined in Figure 6, of the signatures for the
three sections of the mixin module.

t @lw(Bv(S)) r+ {typez} IFM: S

r 1+(type q; M): (type rt; S)

mw(t,r) r'+{tis$}l~kf:s

rlt-(tisqy M):(tis~S)

f zrm(w(s)) r+{valf:~} It-1. f:s

r l!- (vdff =.?7; M): (valjf: T S)

rlFMok
r N- (type t~; M) ok

rlFMok
rlF(tis&M)ok

(R-MFP-T)

(R-MFP-1)
(R-MFP-V)

(R-MSP-T)

(R-MsP-1)
(f:q cr r+{inner:~}lFE:'c rlFMok

rk (valff =~, M) ok

(R-MsP-v)

Figure 8: Atomic Mixin Typing Rules (See Rule R-MOD-MIX in
Figure 7)

The SML module system includes a subtyping relation based on
interface containment. As mentioned, approaches based on manifest types augment this with the ability to "forget" manifest types.
For mixins the subtype relation must be made invariant in the toplevel definitions in all parts of the mixin:

BV(Sj) = BV($) BV(S: ) = BV(S~)

(R-kiIx-s)

268

~+{typet}ESl@S2=S
r F (type tt; SI ) @(type tt; S2) = (type tt; S)

t f EU(BV(S4) r+{typet]FS1g3S2=S

r 1- (type h; S1) 8 S2 = (type h; S)

(R-cB-T)
(R-CB-TI)
dom(h ) n dom(h) = {} r+{tisO1u Q2}FS18S2=S

r~ (tis$l; Sl)c3(tis Q2;S2)=(tis$lu$2; S)

(R-cB-1)

IJEH(t,r) r+{tis Q}t-s1c9s2=S

rt-(tis@ Sl)c3S2=(tis$; S) (R-cB-@

r+{vaif:z] t- S1c3S2=S
rl-(val ~f:TS1) 8(val~f :zS2)=(val.tf:% S)

(R-cB-v)

f $?En(Bv(s2)) 17+{val~:z} FS1c3S2=S

rF(val~r:l S1)t3S2=(valfi:TS) (R-cB-vl)

r+{typet}kkf:s
r F (type t,;M):(type tt; S) (R-c-T)

IIEW(t, r) r+{tis$}EM:S

r~(tiS~; M):(tiS~; s) (R-C-I)

MEW(t,r) r+{t=7}FM:s

i-t(t=llw):(t=ws) (R-C-E)

rt-~:z 17+{vaIx:7}FM:S
r~ (valfi=E, M) :(val~:7; S) (R-C-V)

r'={valfl :q,..., valfn:%}
r+ PFEl:zi, i=l...rs r+r't-kf:s (R-c-R)

rE(fu~;=~ll[...llj;=~n:M)

: (val~~ :zI; . . .. valf; : G; S)

Figure 10: Core Language TWing Rules
Figure 9: Mixin Composition Typing Rules (See Rule R-MOD- some form of tvme uolvmomhism must be added tO the core lanThis restriction is necessary because of the composition rule for
mixins: If interface containment is allowed on the definitions in

a mixin, then the meaning of the composition of the following is

ambiguous:

structure nq = roixin val x = true end

structure roz = snixin val x = 3 end
structure sn3 = nixin val x = 4 end

structure s = clOS (ml @ mz B m3)

For example, without the restriction on sub@ing, the type ofs. x
could be int or bo o1; if its type were int, its value could be 3 or

4. For example, we could use subtyping as follows:

w : mixsig val x: bool end <: mixsig end
to "forget" the value of ml so that in the final composition the type

of x would be int instead of bo 01 (using inflation in mixin composition). The restriction in rule R-MIX-S dissrtllows this since the

two signatures do not share the same collection of identifiers.

Figure 10 provides typing rules for the core language. We omit
rules for expressions L?. These are standard and their inclusion

would be straightforward. Mixin modules are intended as an extension to the module system of ML, which leaves the type system

and semantics of the core language unmodified.

The key property that is required for type-checking is the existence of principal types for modules.

Definition 3.1 Given a context r.
An expression E has a principal type ~ if r E E : T and for any

otherd such tha~ r 1-E: z', we haver 1-z <: ?.

A module Mt has a principal signature St ifr ~ A4t: St, andfor any

other S; such that r E A4t: S{, we have r E St <:$.

Lemma 3.1 Assume all well-typed expressions have princ+al

types. Then all well-formed modules have principal signatures.

The statement of principality deliberately abstracts from the details

of core language types. For the simple core language used here,

guage to admitp'rin~iphty, `with the subtype relation <: extended
to an instance relation over polymorphic types. Various other enrichments of the subtype relation with core language subtyping are

possible [25, 12].

4 Semantics of Mixin Modules

In this section, we provide the operational semantics for our
mmilanguage in terms of a rewrite rule system. The rules for normalizing mixin expressions are given in Fig. 11. Rule COMP normalizes a composition of two mixins. This forms the sequential
composition of the respective preludes and initialization parts, and

the parallel composition of the mixirs bodies. This latter composition is defined by the COMP-T, COMP-I and COMP-V rules. If a
field is present in one mixin body and missing in the other, then a
"default" definition is inserted during composition (either an empty

datatype definition or a function definition fn x ~ irmer x).
We refer to this as the infZation rule for mixin composition; we

omit the obvious rules which perform this inflation.

Rule CLOS closes up a mixin module to an ordinary structure.
The value definitions in the body of the mixin are composed into

a collection of mutually recursively defined functions. The CLOS
rule must also "close up" occurrences of inner in these value definitions. We use the special constant 1- to closeup these definitions;
evaluation fails at run-time if J- is ever evaluated. This is analogous
to the situation in ML where pattern-matching may fail because the

clauses in a function definition do not cover all possible cases.

The reduction semantics is based on the definition of evaluation
contexts given in Fig. 13, with the rules:

MEt [~ + ME, [M']
J4Et [Mt] + MEt [M;]

ME[.E] + ME[E']
ME[~ + ME[M']

if M--+M'

f Mf+. M/
if E+E'

if M+M'

and so on for evaluation contexts for expressions (omitted). These
rules prevent evaluation within a functor body or a mixin, and ensure that evsduation of a structure body proceeds from left to right.
The rules for ordinary expressions are essentially similar and familiar [32], and are omitted. The reduction semantics also needs to accommodatestructure projection and functor application. Rules PROJ269

(J'fjww ) @(J'$o@'f?)+ (J@'f;wf: CM'@(J@:) (COMP)

(type tt;kfj) IXI(type tt;kf~) + type rt;kfj wkf~ (COMP-T)

(COMP-1)

(COMP-V)
Mb=(type fitis~valfi~ =El; . ..val&~= E.)
M = (type fi ~is ~ fun& = {k.l/inner}E1 1[ . . . [1fit = {h.l/inner}En) (CLOS)

CIOS(MP CJlfb) Mi ) + struct Alp ;M,lfi end

EE[L] + -L

(kx.El) E2 + {E2/x}E1

(BOT)
(BETA)
let&in E+E (LET-1 )
let valxx = El; Din E2 + {E1/x}(let D in .52) (LET-2)

let D'; D" in E + let 9(D") in (3(E) (LET-3)

{

D' = funJ~=Ell[ ...ll~f=E~where

f) D {(h?.letlY hEi)/flli=l,...,n}

(case p.c(~) of . . . `~' p.c(xJ+E '1' . ..)+ {~/~}E (CASE-1)

(wseE of . . . `1'x+.E' '1' . ..)+ {E/x}E' (cAsE-2)
kfv; structure s,= MVt;ME[S.p] ---+ MV; structure s,= MVt;ME[MVr (p, E)] (PROJ-V)
W; structure s,= MVt;ME[,s.p' (p)] ---+ W; structures, = MV,;ME[(MVt (P', s)) (p)] (pRoJ-F)

Figure 11: Computation Rules
v and PROJ-F denote the operations of projecting a value and a is allowed since no type identities are lost by this projection. The
functor, respectively, out of the global context of bound structures. third case corresponds to a vrdue being projected out of a structure,
Note that a structure is never copied by projection, because of the while the fourth and fifth cases correspond to a functor and a mixin
fact that type generativity is basedon the syntactic identity of paths. being projected, respectively. Finally the last case corresponds to a
These rules use the operation of applying a module to a path, de- functor application being ~-reduced.

fined in Fig. 12. The formulation of subject reduction is complicated by abstracModule application Mt (p,p'), where &ft is applied top, is written using an accumulating parameter p' which records the path so
far followed from the top-level environment to reach the module
&ft. The first case in the definition in Fig. 12 corresponds tu projecting a module out of a structure; however this projection is only

defined if the operation terminates in one of the following cases.
As a module is projected out of a slructure, the definitions it imports from the bindings to the left of it in the structure rue prefixed

by the path to the structure from the top-level environment. This is
completely analogous to the R-MOD-SP rule in Figure 7.

The second case in the definition in Figure 12 corresponds to
the case where a path is being projected out of a structure. This

tion in the type system. Co-nside~

structure s : sig type t val x:t end =

struct datatype t=foo val x=foo end

With this declaration, s. x has type s. t. s. x reduces to the constructor s. f 00, but the datatype declaring s. f OOis hidden behind
the opaque type s. t. We refer to s. f oo as a hidden value, sinceit

cannot be given a type outside of the body of s. Nevertheless,
in reasoning about subject reduction for this example, we need to
expose the type information in the definition oft.

To reason about subject reduction, we use a reformulation of the
type system presented in the previous section, with the following

270

(structM1 ;structures, = MV, ;M2 end)(s.p',p) =

where

and

P (P'lP") =
(structM1;valxx = W ;kf2 end)(x,p) =

where

and

(functor (structure s,: S,)Mt)(s,p) =

(MpS(Mb)Mi )(S,P) =
(functor (strnctures, : St)A4,)(p) =

e(Mvt)(p',p.s)
8 = {p.n/nl n. c BV(kfl)}U{p.c/c I c e cons(Ml)}
s @EN(BV(~2))

P.P'

9(EV)
8 = {p.n/rz [ nn c BV(kfl)} U {p.c/c I c c cons(M1)}
x @EN(BV(M2))

functor (structures, : St)kft

J'& <(ll'f~)kft

{P/s}~t
Figure 12: Applying Modules to Paths

[1

[1

I struct ME end
ME,8J4( I W, @M.Ef I

\ MV; val~ =EEkl
MV; structures, = MEt ;M

CIOS(ME1)

functor(SOM, I M $,(~b) M I struct MV end

Figure 13: Evaluation Context
changes:

1. We remove the construct for allowing explicit type declarations for modules, (Mr : St ), and we omit the corresponding

signature matching rule Rule R-MOD-MAT in Figure 7.

2. We fold the type subsumption rule, Rule R-MOD-SUB, into

the rule for functor application. Rule R-MOD-PA in Figure 7.
With the omission of explicit signature matching, this is the

only place where subsumption is required (even with the addition of mixin modules).

To simplify the exposition of type soundness, we make the simplifying assumption that functors are fist-order, as in Standard ML.
It is then trivial to define a syntactic transformation which removes

explicit signature matching from programs. This transformation is

defined as the homomorphic extension of the following:

[(M, : St)] = [M,]
Let ~ EM M: S denote the derivability of type judgments in this
restricted (or minima~ type system. Then we have

Lemma 4.1 l~r E M: S then r RM [~ : S' for some S' such thatr+sf~:s.

Theorem 1 (Subject Reduction) Given r and M not containing
signature matching. Given r l-~ M: S and M + M'. Then r FM
Ml: S for some S' such that r 1-S' <: S.

Fig. 13 also defines value expressions. Afaulty term is an expression containing an irreducible subexpression which is not a value.

Lemma 4.2 Given r and M not containing signature matching.

Given T' FM M: S, then M contains no faulty terms.

Finally soundness follows from the fact that any reduction sequence
in the original type system can be simulated by a corresponding
reduction sequence in the minimal type system:

Theorem 2 (Soundness) Given r and M not containing signature
matching. If r E M : S then evaluation of M does not go wrong,

i.e.,there does not exist a reduction sequence

M+... +Mi +...
of reductions starting from M such that some Mi contains a faulty

term.

271

5 Related Work and Conclusions
Mixin modules are clearly influenced by work in implementation inheritance, and in particular mixin-based inheritance, in the
object-oriented languages community. As already discussed, mixin
modules bear some relationship to CLOS generic functions, but
with data constmctor tags replacing the type tags that are used for
dispatching in CLOS. The irmer construct bears some relationship
to call -next -methodic CLOS, which allows a method in a class
to invoke the instance of that method in the next class in the inheritance chain. Mixin modules are also related to BETA patterns [21],
and indeed our inner construct is deliberately named to suggest
the analogy with the BETA construct. Like BETA, implementation inheritance with mixin modules is based on incremental extensions only, and does not allow the overriding of existing definitions (Smalkalk-style method overrides). Bracha and Cook [3] propose "mixin classes" as a construct for object-oriented languages.
Bracha and Lindstrom [4] extend the work of Bracha and Cook by
proposing "modules" (object generators) as a more general notion

than classes, from which classes and mixins maybe derived using
their suite of inheritance operations. Mitchell, Meldal and Madhav

[22] consider the addition of object-oriented constructs to the ML
module language. Their approach amounts to adding F-bounded
quantification and implementation inheritance [7, 23] to the ML
module language, and implementing objects as modules rather than
as closures. AH of this work is based on providing some notion of
implementation inheritance for object-oriented languages.

We are the first to suggest a form of implementation inheritance
for a functional language, based on adding inheritance mechanisms
to the module system. Burstall [5] proposed a functional language
NPL (a predecessor h HOPE [6]) with extensible datatypes and

function definitions, in which constructors could be incrementally
added to the definition of a datatype, and clauses could be incrementally added to the definitions of functions that operated on that
datatype. However unlike our approach he did not base his extensions on the module system, and his approach to providing extensions is less general. Beyond the fact that our approach solves some
open problems with the SML module system, our commitment to
providing inheritance in the module system has important benefits

for the implementation of mixins. One of the reasons for the increasing acceptance of functional languages has been the very efficient implementation of pattern-matching [30]. This efficiency in
turn relies on the fact that all of the constructors for a datatype are
known when compiling the clauses of a function definition. This is

manifested in the SML/NJ compiler, for example, where the implementation of pattern-matching in exception handlers is somewhat
less efficient than that for the ordinary case constmct. By postponing optimization and code generation for mixin modules until they
are closed up to ordinary ML structures, we may similarly benefit from efficient compilation while providing extensible datatypes.
We are currently investigating the design of a suitable intermediate

form into which to compile mixin modules, in order to support this
implementation strategy.

The other implementation issue with mixin modules is the inferring of properties of extensible datatypes defined in mixins.
Given a datatype definition in one mixm, how are we to infer
whether it admits equality, since another mixin may declare a constructor for that datatype with a functional domain? Similar issues
arise with other datatype attributes, for example, variance properties of datatypes if we introduce subtyping [8]. One possible approach here is to require that these attributes be declared by the
programmer. Analogous issues arise with datatype properties that

are only used internally in the compiler, in the representation analysis of datatypes. It appears plausible that work on cross-module

optimization may be applicable in this situation.

In a large sense we have only told half of the story of mixin
modules. We have only reported on vertical extensions, adding
cases to the definitions of datatypes and functions. However there
is also a notion of horizontal extensions for mixin modules, which

also allows the domain of a data constructor to be extended during mixin composition [28]. This provides us with the form of

subclassing provided in CLOS that is missing from this account.
Using this mechanism, for example, we can define modular interpreter building blocks in the style of Liang et al [20]. Furthermore

mixin modules can be extended to provide a class construct for ML
extended with objects [8]. In contrast to simply adding classes to
ML, this approach provides implementation inheritance for all of
ML, not just some object-oriented fragment of it. We intend to
report on this in a subsequentpaper.

Acknowledgements: Thanks to Bob Harper and David MacQueen
for stimulating discussions.

References

[1]

[2]
[3]
[4]
[5]
[6]

Andrew Appel and David MacQueen. Standard ML of New
Jersey. In Proceedings of the Symposium on Programming
Language Iinplementation and Logic Programming, volume

528 of Lecture Notes in Computer Science, pages 1-13.

Springer-Verlag, 1991.

Andrew Appel and David MacQueen. Separate compilation
for Standard ML. In Proceedings of ACM SIGPLAN Conference on ProgrammingLanguageD esign and Implementation,
pages 13-23. ACM Press, June 1994. SIGPLAN Notices VOL

ume 30, number 6.

Gilad Bracha and William Cook. Mixin-based inheritance.
In Proceedings of ACM Symposium on Object-Oriented Programming: Systems, Languages and Applications, pages

303-311. ACM Press, October 1990. SIGPLANNotices, volume 25, number 10.

Gilad Bracha and Gary Lindstrom. Modularity meets inheritance. In International Conference on Computer Languages,
pages 282-290. IEEE, 1992.

R. M. Burstall. Design considerations for a functional programming language. In Infotech State of the Art Conference,
Copenhagen, Denmark, 1977. Infotech.

Rod M. Burstall, David B. MacQueen, and Donald T. Sannella. HOPE: An experimental applicative language. In CorsferenceRecord of the 1980LISP Conference, pages 136-143,

1980.

[7] William Cook, Walter Hill, and Peter Canning. Inheritance is

not subtyping. In Proceedings of ACM Symposium on Principles of Programming Languages, pages 125-135, 1990.

[8] Dominic Duggan. Polymorphic methods with self types for

ML-like languages. Technical Report CS-95-03, University

of Waterloo, Department of Computer Science, 1995.

[9]

[10]

Dominic Duggan and Frederick Bent. Explaining type inference. Technicrd Report CS-94-14, University of Waterloo,
Waterloo, Ontario, Canada, 1994. To appear in Science of

Computer Programing.

Dominic Duggan and John Ophel. Kinded parametric overloading. Technical Report CS-94-35, University of Waterloo,
Department of Computer Science, September 1994.

272

[11] Dominic Duggan and John Ophel. On type-checking multiparameter type classes. To be submitted, 1995.

[12] Jonathan Eifrig, Scott Smith, and V. Trifonov. Sound polymorphic type inference for objects. In Proceedings of ACM
svm~osium on Obiect-OrientedProQraminQ: Svstems. Lan[13]

[14]

[15]

[16]
[17]
[18]

[19]
[20]

[21]
[22]

[23]

[24]

g~a~es and Appli~ations. ACM Pre&, Octob& 1~95. `
Robert Harper and Mark Lillibridge. A type-theoretic approach to higher-order modules with sharing. In Proceedings of ACM Symposium on Principles of Programming Languages, pages 123-137, Portland, Oregon, January 1994.
ACM Press.

Patd Hudak, Simon Peyton-Jones, Philip Wadler, Brian
Boutel, Jon Fairbairn, Joseph Fasel, Maria M. Guzman,

Kevin Hammond, John Hughes, Thomas Johnsson, Richard
Kieburtz, Rishiyur Nikhil, Will Par@in, and John Peterson.
Report on the programming language Haskell, a non-strict
purely functional language, Version 1.2. ACM SIGPLANIVotices, 27(5), 1992.

Mark Jones. A system of constructor classes: Overloading

and implicit higher-order polymorphism. In Proceedings of
ACM Symposium on Functional Programming and Computer
Architecture, pages 1-10. Springer-Verlag, 1993. Lecture
Notes in Computer Science 594.

Stefan Kaes. Parametric overloading in polymorphic programming languages. In European Symposium on Programming, pages 13 1-144. Springer-Verlag, 1988. Lecture Notes
in Computer Science 300.

S. C. Keene. Object Oriented Programming in CommonLisp:
A Programming Guide in CLOS. Addison-Wesley, 1989.

Xavier Leroy. Manifest types, modules, and separate compilation. In Proceedings of ACM Symposium on Principles of
Programing Languages, pages 109-122, Portland, Oregon,
January 1994. acmp.

Xavier Leroy. Applicative functors and fully transparent
higher-order modules. In Proceedings of ACM Symposium on
Principles of Programing Languages, pages 154-163, San
Francisco, California, January 1995. ACM Press.

Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and modular interpreters. In Proceedings of ACM
Symposium on Principles of Programming Languages, pages
333-343, San Francisco, January 1995. ACM Press.

Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen
Nygaard. Object-Oriented Programing in the BEZA Programing Language. ACM Press, 1993.

John Mitchell, Sigurd Meldal, and Neel Madhav. An extension of Standard ML with subtyping and inheritance. In Proceedings of ACM Symposium on Principles of Programming
Languages, pages 270-278. ACM Press, January 1991.

John C. Mitchell. Toward a typed foundation for method specialization and inheritance. In Proceedings of ACM Symposium on Principles of Programing Languages, pages 109-

124, 1990.

Greg Nelson. Systems Programing in Modula-3. PrenticeHall Series in Innovative Technology. Prentice-Hall, 1991.

[25]
[26]
[27]

[28]
[29]

[30]

[31]

[32]

Martin Odersky and Konstantin Laufer. Putting type annotations to work. In Proceedings of ACM Symposium on Principles of Programing Languages, pages 54-67, St. Petersburg

Beach, Florida, January 1996. ACM Press.

John Ophel. A polymorphic language with first-class

modules. Australian Computer Science Communications,

17(1):422-430, February 1995.

Didier R6my. Programming objects with ML-ART: An extension to ml with abstract and record types. In Masami Hagiya

and John C. Mitchell, editors, International Symposium on
Theoretical Aspects of Computer Software, pages 321-346,
Sendai, Japan, April 1994. Springer-Verlag.

Constrmtinos Sourelis. Mixin modules. Master's thesis, University of Waterloo, 1995.

Guy Steele. Building interpreters by composing monads. In
Proceedings of ACM Symposium on Principles of Programming Languages, pages 472-492. ACM Press, 1994.

Philip Wadler. Efficient compilation of pattern-matching.
pages 78-103. Prentice-Hall, 1987. Chapter contributed to

The Implementation of Functional Programming Languages,

Simon Peyton-Jones.

Philip Wadler and Stephen Blott. How to make ad-hoc polymorphism less ad-hoc. In Proceedings of ACM Symposium on
Principles of Programming Languages, pages 60-76. ACM

Press, 1989.

Andrew Wright and Matthias Felleisen. A syntactic approach

to type soundness. Technical Report TR91-160, Rice University, April 1991

273