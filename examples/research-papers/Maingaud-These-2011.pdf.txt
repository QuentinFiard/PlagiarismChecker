

Universite' Paris Diderot - Paris 7

E'cole doctoraleSciences Mathe'matiques de Paris Centre

THE`SE
pour l'obtention du diplo^me de
DOCTEUR DE L'UNIVERSITE' PARIS DIDEROT

Spe'cialite' Informatique

CERTIFICATION
DE PROGRAMMES IMPE'RATIFS

EN LOGIQUE DYNAMIQUE
LE CAS DU LAMBDA-CALCUL AVEC RE'FE'RENCES

Pre'sente'e et soutenue publiquement par

Se'verine Maingaud
le 13 De'cembre 2011, devant le jury compose' de

Pre'sident du jury : Thomas Ehrhard
Directeur de the`se : Alexandre MiquelCodirecteur : Vincent Balat

Rapporteurs : Daniel LeivantClaude Marche'
Examinateurs : Wolfgang AhrendtFranc,ois Pottier

2

Table des matie`res
1 Introduction 91.1 Preuve de programmes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

1.1.1 Me'thodes de ve'rification de fiabilite' logicielle . . . . . . . . . . . . . . 91.1.2 Formalisation mathe'matique . . . . . . . . . . . . . . . . . . . . . . . 10

Logique de Hoare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10Logique de se'paration . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Logique dynamique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121.1.3 Outils de ve'rification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.2 He'ritage et contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14Aspects syntaxiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

Aspects se'mantiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.3 Pre'sentation du document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2 Introduction a` la logique modale propositionnelle 172.1 Introduction a` la logique modale propositionnelle . . . . . . . . . . . . . . . . 17

2.1.1 Syntaxe de LMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182.1.2 Se'mantique de Kripke . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

Structures relationnelles, cadres et mode`les . . . . . . . . . . . . . . . 19Ve'rite' des formules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.1.3 Expressivite' et caracte'risation . . . . . . . . . . . . . . . . . . . . . . . 25Traduction de LMP en logique classique . . . . . . . . . . . . . . . . . 25

Caracte'risation et satisfaisabilite' . . . . . . . . . . . . . . . . . . . . . 26Caracte'risation et validite' . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.1.4 Logiques modales normales et comple'tude . . . . . . . . . . . . . . . . 27Le syste`me K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

Correction et comple'tude de K . . . . . . . . . . . . . . . . . . . . . . 28Extensions de K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Variantes et re`gles de'rive'es . . . . . . . . . . . . . . . . . . . . . . . . 292.2 Introduction a` la logique dynamique propositionnelle . . . . . . . . . . . . . . 31
2.2.1 Syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312.2.2 Se'mantique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

Cadres re'guliers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

4 Table des matie`res

Exe'cution symbolique . . . . . . . . . . . . . . . . . . . . . . . . . . . 332.2.3 LDP : une extension de la Logique de Hoare . . . . . . . . . . . . . . . 34
Logique de Hoare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34Plus faible pre'condition . . . . . . . . . . . . . . . . . . . . . . . . . . 34

3 L'objet d'e'tude : MLimp 373.1 Le langage ML

imp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373.1.1 La grammaire de ML

imp . . . . . . . . . . . . . . . . . . . . . . . . . . 38Les programmes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

Les valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403.1.2 Les stores bien forme's . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
Bonne formation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413.2 Se'mantique ope'rationnelle de ML

imp . . . . . . . . . . . . . . . . . . . . . . . 413.2.1 E'valuation a` <<petits pas>> . . . . . . . . . . . . . . . . . . . . . . . . . 41

Les contextes d'e'valuation . . . . . . . . . . . . . . . . . . . . . . . . . 41E'valuation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
3.2.2 Proprie'te's de l'e'valuation . . . . . . . . . . . . . . . . . . . . . . . . . 43
4 Syntaxe et logique de MLDL 454.1 Syntaxe formelle de MLDL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

4.1.1 Expressions symboliques . . . . . . . . . . . . . . . . . . . . . . . . . . 46Les constantes et fonctions primitives . . . . . . . . . . . . . . . . . . 46

Les programmes symboliques . . . . . . . . . . . . . . . . . . . . . . . 46Les valeurs symboliques . . . . . . . . . . . . . . . . . . . . . . . . . . 48
E'valuation symbolique sur les programmes . . . . . . . . . . . . . . . 484.1.2 Les updates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
Syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52Updates et acce`s me'moire . . . . . . . . . . . . . . . . . . . . . . . . . 52
E'valuation symbolique des updates . . . . . . . . . . . . . . . . . . . . 534.1.3 Le langage de spe'cification . . . . . . . . . . . . . . . . . . . . . . . . 53
Variables libres et substitution . . . . . . . . . . . . . . . . . . . . . . 544.1.4 L'e'valuation symbolique sur les formules . . . . . . . . . . . . . . . . . 57
De'composition des boi^tes . . . . . . . . . . . . . . . . . . . . . . . . . 57Propagation des updates . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Propagation du *-lieur . . . . . . . . . . . . . . . . . . . . . . . . . . . 59Boi^te et quantifications du premier et du second ordre. . . . . . . . . . 62
Raisonnement par cas . . . . . . . . . . . . . . . . . . . . . . . . . . . 62Passage aux contextes . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.1.5 Le syste`me de'ductif . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63Fragment classique du second ordre . . . . . . . . . . . . . . . . . . . 64

E'galite' et Remplacement . . . . . . . . . . . . . . . . . . . . . . . . . 66E'valuation symbolique dans les preuves . . . . . . . . . . . . . . . . . 66
Re`gles modales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66Prouvabilite' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.2 Extensions du syste`me et re`gles de'rive'es . . . . . . . . . . . . . . . . . . . . . 674.2.1 Re`gles de de'duction de'rive'es . . . . . . . . . . . . . . . . . . . . . . . 67

Logique classique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67Remplacement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

Table des matie`res 5
Ne'cessitation existentielle . . . . . . . . . . . . . . . . . . . . . . . . . 68Boi^te ge'ne'rique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.2.2 Macros et extension du noyau . . . . . . . . . . . . . . . . . . . . . . . 72Macros d'e'valuation symbolique . . . . . . . . . . . . . . . . . . . . . 72

Extension du noyau avec des e'quivalences de'rivables . . . . . . . . . . 73Macros de'die'es au diamant . . . . . . . . . . . . . . . . . . . . . . . . 75
4.3 Exemples de preuves et modules de'die's . . . . . . . . . . . . . . . . . . . . . 764.3.1 Partage de me'moire . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

4.3.2 E'tat me'moire hypothe'tique . . . . . . . . . . . . . . . . . . . . . . . . 784.3.3 Modules de'die's . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

Arithme'tique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78Donne'es pures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.3.4 Limite du syste`me : de'clarations locales . . . . . . . . . . . . . . . . . 824.3.5 Boi^te ge'ne'rique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

5 Outils se'mantiques 895.1 Pre'sentation des dcpo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

5.1.1 La cate'gorie des dcpo . . . . . . . . . . . . . . . . . . . . . . . . . . . 905.1.2 Produit de deux dcpo . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

Continuite' par composantes . . . . . . . . . . . . . . . . . . . . . . . . 92Produit ge'ne'ralise' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
5.1.3 Somme directe de deux dcpo . . . . . . . . . . . . . . . . . . . . . . . 92Somme ge'ne'ralise'e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
5.1.4 Exponentielle de deux dcpo . . . . . . . . . . . . . . . . . . . . . . . . 935.1.5 La cate'gorie des cpo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

Lifting d'un dcpo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94Cpo plat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
5.1.6 La cate'gorie des injections-projections . . . . . . . . . . . . . . . . . . 95De'termination des composantes de

f : A n~ B . . . . . . . . . . . . . . 95Anatomie d'un couple injection-projection . . . . . . . . . . . . . . . . 96

La cate'gorie CPOip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 975.2 Re'solution d'e'quations dans CPOip . . . . . . . . . . . . . . . . . . . . . . . . 98
5.2.1 Colimite d'un !-diagramme dans CPOip . . . . . . . . . . . . . . . . . 985.2.2 Image de la colimite par un endofoncteur de CPOip . . . . . . . . . . . 103
5.2.3 Re'solution de l'e'quation A ^ OEpAq . . . . . . . . . . . . . . . . . . . . 1055.3 Actions de groupe sur les dcpo . . . . . . . . . . . . . . . . . . . . . . . . . . 105
5.3.1 Actions de groupe - de'finitions . . . . . . . . . . . . . . . . . . . . . . 1065.3.2 La cate'gorie

G-dCPO . . . . . . . . . . . . . . . . . . . . . . . . . . . 106Ope'rations sur les

G-dcpo . . . . . . . . . . . . . . . . . . . . . . . . . 1075.3.3 La cate'gorie
G-CPOip . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

6 Se'mantique de'notationnelle de MLimp 1116.1 Construction du mode`le de ML

imp dans les dcpo . . . . . . . . . . . . . . . . . 1116.1.1 Mode'lisation des programmes, des valeurs et des stores . . . . . . . . 111

Mode'lisation des valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . 111Mode'lisation des fonctions . . . . . . . . . . . . . . . . . . . . . . . . . 112
Mode'lisation des stores . . . . . . . . . . . . . . . . . . . . . . . . . . 112Syste`me d'e'quations et me'thode de re'solution . . . . . . . . . . . . . . 112

6 Table des matie`res

6.1.2 Le foncteur T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113Le type de donne'es alge'brique T

X . . . . . . . . . . . . . . . . . . . . 113Fonctorialite' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

Le foncteur T dans dCPO . . . . . . . . . . . . . . . . . . . . . . . . . 113Point fixe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
Exemple : le test d'e'galite' dans TX . . . . . . . . . . . . . . . . . . . 1166.1.3 Le foncteur S . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
Le foncteur S dans Set . . . . . . . . . . . . . . . . . . . . . . . . . . . 117Le foncteur S dans dCPO . . . . . . . . . . . . . . . . . . . . . . . . . 117
6.1.4 Le foncteur R dans dCPO . . . . . . . . . . . . . . . . . . . . . . . . . 1196.1.5 Le foncteur

 dans CPOip . . . . . . . . . . . . . . . . . . . . . . . . . 1206.1.6 Re'solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

6.2 Le mode`le de MLimp dans G-dCPO et dans G-CPOip . . . . . . . . . . . . . . 1236.2.1 Le groupe des permutations a` support fini . . . . . . . . . . . . . . . . 123

Permutations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1236.2.2 Action des permutations d'adresses sur le mode`le de ML

imp . . . . . . 125Fonctorialite' de T, S et R dans
G-dCPO . . . . . . . . . . . . . . . . . 125Fonctorialite' de

 dans G-CPOip . . . . . . . . . . . . . . . . . . . . . 126Point-fixe de
 dans G-dCPO . . . . . . . . . . . . . . . . . . . . . . . 128Actions de
G sur les valeurs et les stores . . . . . . . . . . . . . . . . . 1286.3 Interpre'tation de'notationnelle de ML

imp . . . . . . . . . . . . . . . . . . . . . 1296.3.1 La fonction d'interpre'tation . . . . . . . . . . . . . . . . . . . . . . . . 129

Les valuations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129Interpre'tation des programmes de ML

imp . . . . . . . . . . . . . . . . . 129Interpre'tation des programmes symboliques . . . . . . . . . . . . . . . 135

Interpre'tation des stores syntaxiques . . . . . . . . . . . . . . . . . . . 1386.3.2 Exemples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
Quelques programmes de MLimp . . . . . . . . . . . . . . . . . . . . . . 138Non surjectivite' de l'interpre'tation . . . . . . . . . . . . . . . . . . . . 139
6.3.3 Proprie'te's de correction . . . . . . . . . . . . . . . . . . . . . . . . . . 140Correction de la se'mantique ope'rationnelle de ML

imp . . . . . . . . . . 140Correction de l'e'valuation symbolique . . . . . . . . . . . . . . . . . . 142

6.4 Relation de domination et invariants lie's a` la me'moire . . . . . . . . . . . . . 1446.4.1 Motivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

6.4.2 Passage de X a` X . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145De'finition de la relation de domination sur T

X . . . . . . . . . . . . . 145De'finition des e'le'ments de S
X bien forme's . . . . . . . . . . . . . . . . 145De'finition des e'le'ments de R

X bien forme's . . . . . . . . . . . . . . . 146De'finition de la relation de domination sur

X . . . . . . . . . . . . . 1466.4.3 Passage a` la colimite . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

6.4.4 Correction de la fonction d'interpre'tation . . . . . . . . . . . . . . . . 148
7 Se'mantique de Kripke de MLDL 1537.1 Construction du mode`le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

7.1.1 Vue d'ensemble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153Mode`le de Kripke . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

Un mode`le dans Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1547.1.2 Structure du mode`le . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154

Table des matie`res 7
Les mondes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154Individus du premier ordre : valeurs bien forme'es . . . . . . . . . . . . 155
Certificats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155Individus du second ordre : les pre'dicats . . . . . . . . . . . . . . . . . 155
Les valuations logiques . . . . . . . . . . . . . . . . . . . . . . . . . . . 1567.2 Interpre'tation et correction de MLDL . . . . . . . . . . . . . . . . . . . . . . . 157
7.2.1 Interpre'tation des updates . . . . . . . . . . . . . . . . . . . . . . . . . 157Interpre'tation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

Correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1577.2.2 Interpre'tation des formules . . . . . . . . . . . . . . . . . . . . . . . . 159
Satisfaisabilite' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159Substitutivite' du premier ordre et

G-invariance . . . . . . . . . . . . . 160De'notation d'un pre'dicat syntaxique et substitution du second ordre . 162

7.2.3 Correction et cohe'rence de MLDL . . . . . . . . . . . . . . . . . . . . . 163
8 Conclusion et perspectives 1698.1 Bilan et contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169

Aspects syntaxiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169Aspects se'mantiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
8.2 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170Liens avec la logique de se'paration . . . . . . . . . . . . . . . . . . . . 170

Comple'tude de la se'mantique ope'rationnelle de MLimp . . . . . . . . . 171Visibilite' des adresses me'moire . . . . . . . . . . . . . . . . . . . . . . 171
Typage certifie' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173Re'sume' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182

8 Table des matie`res

1
Introduction

L

'importance cruciale de la fiabilite' logicielle n'est plus a` de'montrer. Il suffit de citer desaccidents informatiques graves tels que l'explosion du vol 501 de la fuse'e Ariane 5,

ou encore le dysfonctionnement du Therac-25 1 [LT93]. A` l'heure ou` de plus en plusde besoins essentiels de notre vie (sante', transports, e'nergie, communications, expression
citoyenne 2, etc) de'pendent de composants logiciels dont la complexite' ne cesse de s'accroi^tre,il est impe'ratif de de'velopper des outils de contro^le efficaces afin d'empe^cher (au moins de
re'duire au maximum) ce genre d'accidents informatiques. C'est un des buts de la disciplineinformatique : le de'veloppement de logiciels fiables et d'outils de ve'rification dont le ro^le est
de garantir que les programmes respectent bien leur spe'cification, c'est-a`-dire font bien ceque l'on attend d'eux.

1:1 Preuve de programmes

1:1:1 Me'thodes de ve'rification de fiabilite' logicielle

Il existe diffe'rentes me'thodes pour garantir qu'un logiciel est fiable. Ces me'thodes peuvente^tre classe'es de la manie`re suivante (Figure 1.1) :

Tout d'abord, on distingue les me'thodes dynamiques (ou` les ve'rifications sont faites aucours de l'exe'cution du programme) des me'thodes statiques (ou` la preuve de fiabilite' re'sulte
d'une analyse du code source).Parmi les me'thodes statiques, on distingue encore deux approches. Dans l'approche a
posteriori, on part d'un programme de'ja` e'crit. On peut raisonner ensuite a` l'aide d'automatesfinis sur les diffe'rents e'tats possibles de l'exe'cution (model checking), ou bien en approximant
la se'mantique du programme par des exe'cutions partielles (interpre'tation abstraite), ou bienencore en traduisant le programme vers un syste`me formel de'die' a` la preuve.

1. Le Therac-25 est une machine de radiothe'rapie de'veloppe'e par EACL (Canada) et CGR MeV (France).Suite a` un dysfonctionnement informatique, plusieurs patients ont rec,u des doses massives de radiation, au
moins cinq de'ce'de`rent des suites de l'irradiation.2. Depuis quelques anne'es de'ja`, certaines communes ont remplace' les urnes transparentes par des boi^tes
noires : les machines a` voter.

10 Chapitre 1 - Introduction

v'erification

dynamique simulationtests

statique

a posteriori

model checking
interp. abstraite

traduction

par construction raffinement

certification

Figure 1.1 - Me'thodes de ve'rification de fiabilite'

Une autre approche consiste a` garantir la fiabilite' du programme par construction. Lafiabilite' est garantie par les proprie'te's du langage dans lequel le programme a e'te' e'crit ou
prouve' dans un syste`me formel ou` l'on raisonne sur la structure du programme. Dans cetteapproche de fiabilite' par construction on peut encore distinguer deux me'thodes. Soit on part
de la formalisation d'une spe'cification donne'e pour en extraire un programme (raffinement -extraction), soit on part d'un programme et d'une spe'cification pour prouver leur ade'quation
(certification de programme). Nous nous inte'resserons essentiellement a` la certification deprogramme.

1:1:2 Formalisation mathe'matique

Quelle que soit l'approche adopte'e, les me'thodes de fiabilite' reposent sur une formalisationdes programmes et des spe'cifications dans un langage mathe'matique plus ou moins riche qui

de'pend en partie du paradigme de programmation conside're' (fonctionnel - impe'ratif - objet).Historiquement, le premier formalisme entie`rement centre' autour de la notion de fonction
est le lambda-calcul, invente' par A. Church [Chu41, Bar98]. Le lambda-calcul a inspire' ensuitetoute une famille de langages de programmation, les langages fonctionnels, qui comprend
notamment Lisp (1958), ML (1973), Haskell (1987), etc. Dans ces langages, les programmessont vus commes des fonctions mathe'matiques. Leur se'mantique est donc particulie`rement
bien comprise. La the'orie des types, qui est elle-me^me une famille de langages fonctionels, estun cadre naturellement adapte' pour raisonner sur les programmes fonctionnels purs. C'est
pourquoi les prouveurs de the'ore`mes base's sur la the'orie des types sont des outils tre`s utilesa` la preuve de programmes fonctionnels.

La programmation impe'rative est une me'thode proce'durale (dans l'esprit des machinesde Turing [Tur38, Tur50]) qui met l'accent sur les modifications des donne'es en me'moire. Le
comportement d'un programme de'pend donc fortement de l'e'tat de la me'moire dans lequelil est exe'cute'. C'est la raison pour laquelle les langages impe'ratifs n'ont pas en ge'ne'ral de se'mantique aussi claire que les langages fonctionnels. Raisonner sur des programmes impe'ratifsest donc moins aise' que raisonner sur des programmes fonctionnels purs. Pourtant la plupart
des logiciels critiques sont e'crits dans des (fragments certes restreints de) langages impe'ratifs.

Logique de Hoare Historiquement, la logique de Hoare est la premie`re me'thode formelleintroduite pour traiter les programmes impe'ratifs (1967-1969) et encore aujourd'hui la plupart

des me'thodes de preuve de programmes impe'ratifs en sont des extensions. Les premie`res ide'esde la logique de Hoare ont e'te' jete'es par C. A. R. Hoare dans An axiomatic basis for computer
programming [Hoa69] et par R. W. Floyd dans Assigning meanings to programs [Flo67]. Il

1.1. Preuve de programmes 11
s'agit d'une logique axiomatique de'die'e a` la spe'cification et la certification de programmesimpe'ratifs, ou` chaque programme est vu comme une fonction de transition entre les e'tats
me'moire de la machine. La spe'cification d'un programme ss est une description des modifi-cations de la me'moire ope're'es par l'exe'cution de

ss. La correction faible (sous condition determinaison) de
ss vis-a`-vis de cette spe'cification est exprime'e a` l'aide de triplets de la forme

tAu ss tBu
ou` la pre'condition A et la postcondition B sont des formules logiques explicitant le contenude la me'moire : si la pre'condition

A est vraie et si le programme ss termine, alors, apre`s touteexe'cution de
ss, la postcondition B est vraie. La validite' de ces triplets est e'tablie gra^ce a` desre`gles qui permettent a` la fois de raisonner au niveau logique sur les conditions

A et B et deraisonner au niveau du programme en l'exe'cutant symboliquement. Par exemple la re`gle de

l'affectation :

tAre-xsu x :i e tAu assign
signifie que la validite' de Are-xs (formule obtenue en substituant l'expression e a` la variable
x dans la condition A) est e'quivalente a` la validite' de A apre`s l'affectation. Il est importantde noter qu'il y a une bijection entre les variables et les cellules me'moires. Cela signifie que

la logique de Hoare ne permet pas de traiter le partage de me'moire.En 1975, E. W. Dijkstra introduit la notion de transformateur de pre'dicats, [Dij75] . Les
transformateurs de pre'dicats de'signent un ensemble d'algorithmes permettant de calculerautomatiquement des pre' ou post-conditions particulie`res. C'est pourquoi de nombreux assistants a` la preuve de programmes se sont appuye's sur cette notion de transformateurs etnotamment sur l'algorithme de recherche de la plus faible pre'condition d'un programme et
d'une postcondition donne's. Nous donnons un bref aperc,u de la logique de Hoare et de lanotion de plus faible pre'condition a` la Section 2.2.3 (on trouvera une pre'sentation comple`te
de la logique de Hoare dans [Cou] de P. Cousot).
Logique de se'paration La logique de se'paration a e'te' introduite au de'but des anne'es2000 par Reynolds et O'Hearn [Rey02]. Il s'agit d'une extension de la logique de Hoare ou`

l'annotation des programmes manipulant des pointeurs est facilite'e par l'ajout d'une conjonc-tion de se'paration, note'e

AbB, garantissant que les conditions A et B portent respectivementsur des parties disjointes de l'e'tat me'moire. Cette nouvelle construction permet de raisonner

efficacement sur des structures de donne'es mutables et partage'es (telles que les listes chai^ne'espar exemple). En logique de se'paration, les triplets n'ont pas tout a` fait le me^me sens que dans
la logique de Hoare puisque un programme donne' ne peut acce'der qu'aux variables de'clare'esdans sa pre'condition : dans le triplet

tAu ss tBu, toutes les variables manipule'es par ss (note'esmod
pssq) doivent figurer dans A. Dans ce cadre, il est possible d'exprimer la proprie'te' demonotonie suivante : une formule vraie pour une portion donne'e de l'e'tat me'moire reste vraie

pour toute extension de cet e'tat obtenue par allocation de nouvelles adresses. Cette proprie'te'est exprime'e par la re`gle frame :

tAu ss tBu
tA b Cu ss tB b Cu modpssq X FVpCq i ?

qui est centrale dans la logique de se'paration. Il est important de noter que cette conditionde monotonie impose de ne conside'rer que des programmes qui ne libe`rent pas d'adresse

12 Chapitre 1 - Introduction

me'moire 3. C'est un aspect que nous retrouverons e'galement dans notre travail (Section 6.4).
Logique dynamique La logique dynamique a e'te' de'veloppe'e par Vaughan Pratt [Pra76].Il s'agit d'une logique modale qui ge'ne'ralise la logique de Hoare. Le point essentiel est que

la syntaxe des programmes est inte'gre'e au niveau des formules logiques gra^ce aux modalite's,notamment la boi^te modale

rsss B qui exprime la correction faible du programme ss vis-a`-visde la postcondition
B. Il est important de noter qu'ici B peut contenir d'autres boi^tes. Ceciautorise les imbrications multiples et offre une grande souplesse dans l'expression des spe'cifications. La logique dynamique est donc tre`s expressive. Par exemple le triplet de Hoare
tAu ss tBu se traduit en logique dynamique par la formule A N~ rsss B, en revanche la formule
prss1s Aq N~ rss2s pB N~ rss3s Cq n'est repre'sentable par aucun triplet de Hoare. Les preuves enlogique dynamique se font en de'composant les programmes et en conservant les e'tats me'moire

interme'diaires. Lorsque cette de'composition suit la strate'gie d'exe'cution des programmes, onparle alors d'exe'cution symbolique (ou d'e'valuation symbolique). Une pre'sentation plus de'taille'e de la logique dynamique est donne'e dans le Chapitre 2.

1:1:3 Outils de ve'rification

Il existe de tre`s nombreux outils de preuve de programmes (dont nous ne ferons pas uneliste exhaustive) qui se distinguent les uns des autres par plusieurs aspects :

i. l'approche de fiabilite' (par construction, a posteriori, raffinement, certification, etc)
ii. le mode de preuve (automatique - semi-automatique - interactif) ;
iii. le paradigme de programmation (impe'ratif - fonctionnel) ;

iv. le syste`me formel sous-jacent.

Automatique Semi-automatique Interactif
Impe'ratif typage ML WHY - Boogie Ynot - CFMLModel Checking B KIV - KeY

Fonctionnel typage ML WHO Coq - PVS - AgdaPangolin Isabelle - HOL - PAF
Les prouveurs La plupart des prouveurs sont base's sur des syste`mes de types tre`s richesqui permettent d'exprimer des fonctions (donc aussi des programmes fonctionnels purs) et
des spe'cifications.On trouve par exemple les prouveurs base's sur la logique d'ordre supe'rieur et ses variantes.
PVS [ORS92] est base' sur une logique d'ordre supe'rieur munie d'une notion de sous-typage(dans l'esprit du sche'ma de compre'hension de la the'orie des ensembles). Dans la me^me famille,
on trouve aussi le prouveur interactif HOL/Isabelle qui permet de de'finir la logique d'ordresupe'rieur (HOL) et la the'orie des ensembles (ZFC) [Pau89, P

\Gamma 94]. Le syste`me pre'sente' dans

cette the`se a plus particulie`rement e'te' inspire' par le syste`me PAF [Bar03b], un prouveur

3. Il existe en fait une version de la logique de se'paration (introduite par Ishtiaq et O'Hearn) ou` la conditionde monotonie n'est pas impose'e. On pourra alors conside'rer la libe'ration d'adresses me'moire.

1.1. Preuve de programmes 13
de'die' au fragment fonctionnel de ML, fonde' sur une logique multi-sorte'e du second ordrea` la AF2. Le principal ingre'dient est un pre'dicat de typage fort, qui exprime la correction
forte (terminaison) du programme vis-a`-vis de son type. 4 Tous ces prouveurs sont base's surune notion de preuve externe au syste`me de types. C'est un aspect que partage e'galement le
syste`me que nous pre'senterons au Chapitre 4.D'autres sortes de prouveurs sont conc,us sur la possibilite' d'inte'grer le syste`me de preuves
au syste`me de types, suivant le principe de la correspondance de Curry-Howard. C'est le casdu projet Automath (dirige' par De Bruijn), qui est le premier exemple de syste`me base'
sur Curry-Howard. La the'orie des types de Martin-Lo"f [ML84] est une extension du formal-isme de Automath et constitue aujourd'hui le noyau de la plupart des syste`mes base's sur
Curry-Howard. Le prouveur Coq est une imple'mentation du calcul des constructions induc-tives [CH88] (extension du syste`me F et de la the'orie de Martin-Lo"f). Il exploite pleinement
la correspondance de Curry-Howard et permet aussi bien la certification que l'extraction deprogrammes.

WHY La plateforme WHY [Fil03] est un outil de certification semi-automatique quitraite les programmes impe'ratifs du premier ordre qui ne font pas de partage de me'moire
-- deux variables distinctes de'notent toujours deux cellules me'moire distinctes. La me'thodeconsiste a` ge'ne'rer des obligations de preuves (essentiellement par recherche de la plus faible
condition) a` partir d'un programme donne' e'crit dans le langage WHY. Les obligations depreuves peuvent ensuite e^tre ve'rifie'es avec diffe'rents outils (solver SMT, prouveur).

A` cette approche fiabilite' par construction, s'ajoute le de'veloppement de modules de'die's a`la gestion a posteriori de langages de programmation standard (Jessie pour Java, Caduceus,
Frama-C pour C). Le ro^le du module consiste essentiellement a` traduire le programme versWHY. Le point important est que le partage de me'moire effectif dans le programme de de'part
apparai^t dans le programme WHY d'arrive'e sous une forme inoffensive -- les pointeurs sonttraduits par des cle's dans une me'moire fonctionnelle stocke'e dans une seule variable globale.
Les variables de WHY quant a` elles respectent la condition de non partage et de'notenttoujours des cellules me'moire distinctes. Nous retrouverons des invariants similaires dans le
syste`me de preuve que nous pre'senterons au Chapitre 4 (Section 4.1.1).

Me'thode B La me'thode B est une me'thode de raffinement conc,ue par J-R. Abrial [AA96]a` partir de la logique de Hoare [Hoa69] et des travaux de E. W. Dijkstra [Dij75]. Elle est fonde'e
sur les concepts mathe'matiques de la the'orie des ensembles. L'ide'e ge'ne'rale consiste a` partird'une spe'cification dans le langage B (la machine abstraite), pour ensuite en extraire un
programme en appliquant des e'tapes de raffinement successives. Chaque e'tape de raffinementproduit une nouvelle machine qui correspond a` des choix d'imple'mentation. Par exemple,
tel objet (l'ensemble des places d'un train) sera repre'sente' par telle structure de donne'es(un tableau de boole'ens). Ainsi, chaque e'tape introduit plus de de'terminisme et de contenu
algorithmique, jusqu'a` obtenir un programme annote' par quelques invariants logiques. Lesobligations de preuves correspondent a` la cohe'rence de la machine abstraite et a` la correction
de chaque e'tape de raffinement -- typiquement ve'rifier que la structure de donne'es choisiepour repre'senter un objet respecte bien les conditions requises ou que l'imple'mentation d'une
ope'ration abstraite pre'serve bien les invariants voulus. Ce proce'de' garantit in fine que leprogramme ainsi ge'ne're' est bien correct vis-a`-vis de sa spe'cification.

4. Une partie de ma the`se a e'te' consacre'e a` e'tablir la cohe'rence de PAF. Ces re'sultats ne sont pas pre'sente'sdans ce document, ils sont expose's dans [Mai09].

14 Chapitre 1 - Introduction

Le point important ici est que les programmes sont mode'lise's par des substitutions. L'ac-tion des programmes sur la me'moire est simule'e par l'action des substitutions sur les pre'dicats
(qui de'crivent l'e'tat de la me'moire), dans l'esprit de la re`gle d'affectation (assign). Cetteide'e se retrouve dans les updates du projet KeY (voir ci-dessous) et dans le syste`me que nous
allons pre'senter.

Le projet KeY et les updates Le projet KeY est un outil interactif de'die' aux langagesde programmation oriente's objets. Il est base' sur une extension de la logique dynamique ou`
les mises-a`-jour de la me'moire sont simule'es gra^ce a` un me'canisme d'updates, a` la manie`re dessubstitutions ge'ne'ralise'es de la me'thode B. Un update

u est une combinaison (compositionse'quentielle et paralle`le) d'expressions atomiques de la forme valeur-gauche :

i valeur qui ontla me^me se'mantique que l'affectation. Ainsi dans la formule
tx :i vuA, la sous-formule A este'value'e dans un e'tat ou`
x vaut v.La the'orie comple`te du calcul des updates de KeY est pre'sente'e dans [Ru"m06]. Le point

important est que ce calcul de'pend fortement de la distinction entre expressions rigides, quine de'pendent pas de la me'moire et de'notent toujours la me^me valeur, et expressions non
rigides dont la valeur de'pend de l'e'tat de la me'moire (les valeurs-gauches sont clairement desexpressions non rigides). Cette distinction est explicite dans le langage que nous conside'rerons.
C'est pourquoi la grammaire des updates que nous utiliserons (Section 4.1.2) est plus simpleque celle de [Ru"m06].

Autres outils Pangolin [RGP08] est un langage de programmation fonctionnel qui utiliseune logique de Hoare pour permettre d'e'crire des assertions logiques dans les programmes
(les fonctions de premie`re classe sont traduites logiquement par des couples de pre'dicats).Ces assertions seront ensuite prouve'es statiquement. En ajoutant une notion d'effets polymorphiques a` cette logique, il est possible d'e'tendre la logique de WHY aux programmesd'ordre supe'rieur en suivant le principe de Pangolin. C'est le principe de WHO [KF09].

Ynot est un outil interactif base' sur le formalisme HTT. Le but est d'ajouter des traitsimpe'ratifs a` l'outil Coq vu comme langage de programmation. Ceci est re'alise' gra^ce a` une
formalisation de la logique de se'paration dans Coq avec une monade.CFML [Cha10a, Cha10b] est un outil de'die' a` la certification de programmes Caml en
Coq, base' sur la notion de formules caracte'ristiques. Une formule caracte'ristique d'un pro-gramme est une description fonctionnelle du comportement de ce programme. Ces formules
sont ge'ne're'es automatiquement a` partir des programmes avant d'e^tre prouve'es dans Coq.

1:2 He'ritage et contributions

Dans cette the`se, nous pre'sentons un syste`me formel de certification, MLDL, de'die' a` un
*-calcul non type' contenant des re'fe'rences d'ordre supe'rieur et dont l'e'valuation se fait enappel par valeur. Ce langage de programmation peut donc e^tre vu comme un fragment non

type' et avec re'fe'rences de ML, raison pour laquelle nous l'appelons MLimp. La me'thode adopte'edans MLDL consiste a` prouver l'ade'quation entre un programme et sa spe'cification, les deux
objets e'tant de'ja` donne's -- contrairement au raffinement (Me'thode B) ou a` l'extraction (enCoq). MLDL comporte un langage de spe'cification et un syste`me de preuve permettant de
raisonner directement sur les programmes sans traduction pre'alable.

1.2. He'ritage et contributions 15
La the`se comporte deux volets : un volet syntaxique consacre' a` la pre'sentation de MLDL,et un volet se'mantique consacre' a` la construction d'un mode`le de MLDL afin de prouver la
cohe'rence du formalisme.
Aspects syntaxiques MLDL est construit sur une logique dynamique du second ordredont les individus de base sont les valeurs de ML

imp, et dont le syste`me de'ductif combine dese'tapes de de'duction purement logiques et des e'tapes d'e'valuation symbolique. Les principes

fondamentaux de MLDL sont inspire's a` la fois de l'assistant a` la preuve PAF et du projet KeY.

He'ritage de PAF Comme PAF, MLDL est de'die' a` un langage de programmation de lafamille ML. De plus, la logique de MLDL est une logique du second ordre, ce qui permet
notamment de de'finir des pre'dicats caracte'risant les donne'es dans l'esprit de AF2. Pour finir,MLDL n'est pas conc,u autour de la correspondance de Curry-Howard (programmes et preuves
vivent dans des mondes se'pare's). Raisonner sur les programmes se fait (entre autres) gra^ce a`l'e'valuation symbolique.

He'ritage de KeY Comme KeY, MLDL est base' sur une extension de la logique dynamiqueou` l'e'valuation symbolique est imple'mente'e par une congruence. Par ailleurs, la distinction
entre objets rigides et non-rigides qui est faite dans KeY se trouve e'galement dans MLDLa` travers les notions de programmes et valeurs symboliques. De plus, la logique de MLDL
reprend le me'canisme des updates de'fini dans KeY. Comme nous le verrons (Section 4.1.2),les updates peuvent e^tre sensiblement simplifie's dans MLDL gra^ce aux proprie'te's du langage
de programmation MLimp (en particulier la distinction explicite entre une adresse et soncontenu).

Aspects se'mantiques Le volet se'mantique de la the`se est consacre' a` la constructiond'un mode`le de MLDL ainsi qu'aux preuves de corrections associe'es. Le but initial e'tait de construire ce mode`le dans le cadre ge'ne'ral de la se'mantique de Kripke pour la logique dynamique,ou` les relations d'accessibilite' sont habituellement indexe'es par la syntaxe des programmes.
Cependant, nous verrons que l'e'valuation symbolique effectue un certain nombre d'identifi-cations entre programmes qui ne sont pas faites par la se'mantique ope'rationnelle de ML

imp.C'est pourquoi le mode`le de MLDL est construit a` partir d'un mode`le de'notationnel de ML

impou` deux programmes congruents (au sens de l'e'valuation symbolique) appartiennent a` une

me^me classe d'e'quivalence. Le mode`le du langage de programmation est construit avec destechniques standard de re'solution d'e'quations dans la cate'gorie des dcpo et la cate'gorie des
cpo avec injections-projections.Il est naturel d'attendre que la se'mantique des programmes soit inde'pendante de l'imple'mentation du gestionnaire de me'moire et notamment de l'ordre d'allocation. Pourtant, cetteproprie'te' est particulie`rement de'licate a` e'tablir. C'est ce qui motive l'introduction des actions
de groupes sur les dcpo (Section 6.2) ainsi que l'introduction de la de'finition de dominationpar un ensemble d'adresses (Section 6.4).

Contributions

Logique dynamique et second ordre Bien que la logique dynamique du second ordre neconstitue pas une nouveaute' en soi, le syste`me MLDL est a` notre connaissance le premier

formalisme de preuve de programme combinant la logique dynamique avec le secondordre qui lui ajoute un grand pouvoir d'expression.

16 Chapitre 1 - Introduction

Design de la boi^te La boi^te standard de la logique dynamique a du^ e^tre adapte'e a` MLimpou` tout programme est une expression. On verra que la boi^te modale de MLDL contient

un lieur dont le ro^le est de re'cupe'rer la valeur calcule'e par le programme.
Gestion des adresses La gestion des adresses me'moire (allocation, partage, etc) dans MLDLest re'alise'e en introduisant un jeu de noms d'adresses et le lieur associe', le

*-lieur, dont lero^le essentiel est de garantir et propager les conditions de frai^cheur des noms d'adresses.

Action de groupes sur les dcpo et relation de domination Co^te' se'mantique, nous de'velop-pons une the'orie des actions de groupe sur les dcpo, que l'on appliquera au groupe des

permutations d'adresses a` support fini, ainsi qu'une notion de domination des pro-grammes et des stores par un ensemble d'adresses. Ces nouveaux outils vont nous permettre de traiter les questions de bonne formation et d'invariance lie'es a` la manipulationdes adresses me'moire.

Se'mantique de'notationnelle et se'mantique de Kripke L'association de la se'mantiquede'notationnelle (pour le langage de programmation) a` la se'mantique de Kripke (pour

le syste`me formel) permet d'inte'grer les identifications faites par l'e'valuation symbol-ique aux relations d'accessibilite' du mode`le (de'sormais indexe'es par la de'notation des
programmes).

1:3 Pre'sentation du document

Le Chapitre 2 est une introduction a` la logique modale et a` la logique dynamique. Ilpre'sente les principaux outils syntaxiques (les modalite's) qui seront utilise's dans MLDL, ainsi
que les ide'es principales de la se'mantique de Kripke habituellement associe'e aux logiquesmodales. Le langage de programmation ML

imp ainsi que sa se'mantique ope'rationnelle sontpre'sente's dans le Chapitre 3. Au Chapitre 4, nous pre'sentons la syntaxe formelle de MLDL

et donnons quelques exemples de spe'cification. Les chapitres suivants sont tous de'die's auxaspects se'mantiques. Dans le Chapitre 5, nous exposons les outils se'mantiques qui nous serviront a` construire le mode`le de MLimp et celui de MLDL. Il s'agit de notions et de re'sultatsstandard de la the'orie des domaines (essentiellement la cate'gorie des dcpo et la cate'gorie des
injections-projections) auxquels on a ajoute' la the'orie des actions de groupe sur les dcpo. LeChapitre 6 est consacre' a` la construction du mode`le de ML

imp ainsi qu'aux re'sultats de cor-rection de la se'mantique ope'rationnelle et de l'e'valuation symbolique vis-a`-vis de ce mode`le.

Le mode`le de MLDL est pre'sente' au Chapitre 7. Il s'agit d'un mode`le de Kripke qui nouspermettra d'e'tablir le re'sultat essentiel de la the`se : la cohe'rence de MLDL.

2
Introduction a` laLogique Modale Propositionnelle

L

'objet de cette the`se est de de'finir et d'e'tudier un syste`me formel, MLDL, de'die' a` la cer-tification d'un langage de programmation impe'ratif non type' contenant des re'fe'rences

d'ordre supe'rieur (MLimp). Ce syste`me utilise la logique dynamique qui est une exten-sion de la logique modale permettant de raisonner sur le comportement des programmes en
inte'grant leur syntaxe aux modalite's. Dans ce chapitre, on se propose donc d'introduire lesoutils purement logiques ne'cessaires a` la compre'hension de MLDL. La pre'sentation expose'e ici
est largement inspire'e de l'ouvrage de P. Blackburn, M. de Rijke et Y. Venema [BdRdV01],Modal Logic et de l'ouvrage de B. F. Chellas [Che80], Modal Logic, an introduction. On commencera (Section 2.1) par pre'senter la logique modale dans un cadre ge'ne'ral, avant de sefocaliser sur la logique dynamique (Section 2.2).

2:1 Introduction a` la logique modale propositionnelle

La logique modale est une logique qui contient des constructions particulie`res permettantde raffiner les assertions en leur attribuant un mode. Dans un langage naturel, ces modalite's
correspondent aux adverbes. Ainsi, la proposition <<J'ai fini de re'diger ma the`se>> peut e^trede'cline'e selon diffe'rents modes, par exemple (ale'thique, doxastique, e'piste'mique) :

Il est certain que j'ai fini de re'diger ma the`seIl se peut que j'aie fini de re'diger ma the`se
Alexandre ne croit pas que j'aie fini de re'diger ma the`seDieu sait que j'ai fini de re'diger ma the`se

Le premier fondateur de la logique modale est Aristote qui traite des notions de ne'cessite'et de possibilite' (entre autres) dans le De interpretatione et dans les Premiers Analytiques.
Depuis, elle est e'tudie'e aussi bien par les philosophes que par les logiciens. Apre`s avoir e'te'un objet d'e'tude privile'gie' des philosophes (et me^me des the'ologiens) me'die'vaux, la logique
modale a connu un regain d'inte're^t au cours du XXe sie`cle, [Pan92, Eng]. En 1918, C. I. Lewischerche a` formaliser les notions de conse'quence et d'implication stricte (implication dont la

18 Chapitre 2 - Introduction a` la logique modale propositionnelle

conclusion de'pend effectivement de la pre'misse), [Lew60]. Ces conside'rations ont mene' a` l'ap-parition de la logique modale contemporaine, caracte'rise'e par le traitement syntaxique qu'elle
fait des modalite's. Celles-ci deviennent des ope'rateurs formels, des constructions syntaxiquesqu'il est possible d'ite'rer et d'imbriquer a` volonte'. Cette formalisation mathe'matique a ouvert
la voie au de'veloppement de toutes sortes de logiques modales qui sont utilise'es dans des do-maines aussi varie's que la linguistique, les syste`mes de pre'vision des mouvements financiers,
ou encore l'informatique. En informatique, la logique modale a essentiellement e'te' utilise'edans le cadre de l'intelligence artificielle ; dans le cadre de la se'mantique des langages de
programmation, en particulier pour les questions de gestion des ressources (espace me'moireet temps d'exe'cution) -- y compris en logique line'aire dans son traitement des modalite's
-- ; mais aussi dans le cadre de la certification de programme. C'est bien entendu ce dernieraspect qui nous inte'resse ici.

2:1:1 Syntaxe de LMP

On pre'sente la grammaire d'un langage modal propositionnel basique construit sur ladisjonction, la ne'gation et une unique modalite' unaire : la boi^te modale. La de'finition ge'ne'rale

pre'voit qu'un langage puisse contenir plusieurs modalite's d'arite' e'ventuellement diffe'rentes.Nous nous restreignons ici au cas ou` le langage ne contient qu'une seule modalite' unaire.
Formellement, on suppose donne' un ensemble de'nombrable \Phi  de variables propositionnellesnote'es

OE, OE1, OEi, , etc. L'ensemble des propositions bien forme'es de LMP est de'fini par la BNFsuivante :

A ::i OE -- K -- A -- A . A -- lA
A` partir de ce noyau, on peut de'finir de manie`re standard la constante vraie (top), laconjonction, l'implication et le diamant qui est la modalite' duale de la boi^te :

J j  K
A ^ B j pA . Bq
A N~ B j A . B
A O/ B j pA N~ Bq ^ pB N~ Aq\Sigma 

A j  l A

Les diffe'rentes logiques modales se distinguent par la signification qui est attribue'e a` lamodalite'. Par exemple, en logique modale ale'thique la boi^te indique le mode de la ne'cessite',
tandis que son dual, le diamant, indique le mode de la possibilite'. Les deux constructions selisent donc :

lA il est ne'cessaire que A\Sigma 

A il est possible que A

En logique de'ontique, les modalite's de'crivent les droits et devoirs. Ainsi les deux modalite'sse lisent :

lA il est obligatoire que A\Sigma 

A il est permis que A

En logique temporelle, la boi^te marque la permanence tandis que le diamant marque laponctualite' :

lA il est toujours vrai que A\Sigma 

A un jour, il est vrai que A

2.1. Introduction a` la logique modale propositionnelle 19
Dans d'autres logiques, les modalite's font intervenir un e'le'ment exte'rieur et permettentainsi d'affiner les propositions. C'est le cas dans les logiques e'piste'miques (logique de la
connaissance) et doxastiques (logique de la croyance), ou` la boi^te est indexe'e par le sujet(souvent appele' agent) du savoir ou de la croyance : la formule

la A est alors lue <<a sait queA>> ou <<a croit que A>>. C'est e'galement le cas en logique dynamique ou` la boi^te est indexe'e

par un programme. Les deux modalite's duales sont ici interpre'te'es par :

rps A apre`s toute exe'cution du programme p, A est vraie
xpy A apre`s l'une au moins des exe'cutions possibles de p, A est vraie

Ces deux formules permettent d'exprimer respectivement la correction faible (rps A) et lacorrection forte (

xpy A, spe'cification plus terminaison) du programme qui indexe la modalite'.Nous reviendrons plus en de'tail sur le cas de la logique dynamique dans la section suivante.

2:1:2 Se'mantique de Kripke

La se'mantique de Kripke, ou se'mantique des mondes possibles, a e'te' introduite par lelogicien Saul Aaron Kripke dans son article de 1959 A Completeness Theorem in Modal

Logic [Kri59] et celui de 1963 Semantical considerations on Modal Logic [Kri63]. Cette se'-mantique est traditionnellement utilise'e pour interpre'ter la logique modale. Cette section
pre'sente les principales caracte'ristiques de la se'mantique de Kripke : la structure ge'ne'rale desmode`les ainsi que les diffe'rentes notions de ve'rite', de conse'quence logique et de caracte'risation.

Structures relationnelles, cadres et mode`les Les mode`les de LMP sont construitssur des structures appele'es cadres, qui ne sont rien d'autre que des structures relationnelles

ou` le ro^le de chaque relation est d'interpre'ter les modalite's du langage. Bien que le langagepre'sente' plus haut ne contienne qu'une seule modalite', la De'finition 2.1.1 est donne'e dans un
cadre plus ge'ne'ral ou` plusieurs relations sont autorise'es.
De'finition 2.1.1 (Structures relationnelles).Une structure relationnelle est un

n \Gamma  1-uplet F i xW, R1, : : : , Rny, n a, 0, ou` W est unensemble non vide appele' l'univers de

F, et ou` tous les autres composants sont des relationssur cet univers (pour tout
i compris entre 1 et n, Ri D^ W \Theta  W ). Les e'le'ments de l'universsont souvent appele's points, noeuds, mondes, instants ou e'tats (dans le Chapitre 7, ils seront

nomme's stores).
Exemple 2.1Les ensembles des entiers naturels, relatifs, des nombres rationnels et re'els, chacun munis
de la relation d'ordre large d^, sont autant d'exemples de structures relationnelles.Les syste`mes de transitions de la forme

xW, tRa -- a P Auy ou` A est un ensemble non vided'e'tiquettes
a et pour tout a P A, Ra une relation sur W , sont e'galement des exemples derelations structurelles. Ces structures sont particulie`rement ade'quates pour mode'liser les e'tats

d'exe'cution d'une machine : les e'le'ments de W repre'sentant les diffe'rents e'tats de la me'moireet chaque relation

Ra repre'sentant la transition entre deux e'tats, effectue'e par l'exe'cution duprogramme
a.

20 Chapitre 2 - Introduction a` la logique modale propositionnelle

De'finition 2.1.2 (Cadre).Un cadre pour LMP est une structure relationnelle

F i xW, Ry ne contenant qu'une seulerelation binaire
R sur l'univers W . La relation R est appele'e la relation d'accessibilite' ducadre.

Remarque 2.1.1. Dans le cas des logiques modales indexe'es par un ensemble exte'rieur, un cadrecontient une famille de relations d'accessibilite' e'tiquete'es par les e'le'ments de cet ensemble.
Par exemple, un cadre de logique e'piste'mique sera de la forme xW, tRauaPAgy ou` Ag est unensemble d'agents, tandis que dans un cadre de logique dynamique les relations sont e'tiquete'es
par un ensemble de programmes.
De'finition 2.1.3 (Mode`le).Un mode`le pour LMP est un couple

M i xF, V y ou` F est un cadre pour LMP et V estune valuation qui assigne un ensemble de points de l'univers aux variables propositionnelles

(V pOEq D^ W ).

Intuitivement, V pOEq est l'ensemble des points de l'univers ou` la proposition atomique OE estvraie. E'tant donne' un cadre, une valuation peut e^tre vue comme une manie`re de <<placer>> les
variables propositionnelles en des points de l'univers. Un me^me cadre admet donc plusieursmode`les (une infinite' si l'ensemble \Phi  est infini) qui sont autant de manie`res possibles de placer
les variables propositionnelles.

Notations On notera respectivement WF et RF, l'univers et la relation d'accessibilite'sous-jacents au cadre

F. De me^me, on notera respectivement WM, RM et VM, l'univers, larelation d'accessibilite' et la valuation sous-jacents au mode`le

M.

Ve'rite' des formules Nous allons maintenant de'finir diffe'rentes notions de ve'rite' pourles formules du langage : la satisfaisabilite', la ve'rite' globale (ou universelle) et la validite'. Les

deux premie`res notions se de'finissent au niveau des mode`les, tandis que la notion de validite'se de'finit au niveau des cadres. Intuitivement, les formules valides sont vraies dans tous
les mode`les d'un cadre, tandis que les formules satisfaisables (respectivement, globalementvraies) sont vraies en un point (respectivement, en tout point) d'un mode`le. Les formules
valides permettent donc de caracte'riser la relation d'accessibilite' en de'crivant formellementle cadre. Les formules satisfaisables quant a` elles donnent des informations contingentes a`
propos d'un mode`le donne'.
De'finition 2.1.4 (Satisfaisabilite').Soit

M i xW, R, V y. La notion de satisfaisabilite' d'une formule, note'e M, w --u` A et lue <<Aest satisfaite dans

M au point w P W >>, est de'finie par induction sur A par :

M, w --u` OE ssi w P V pOEq
M, w --u`K ssi 0 i 1
M, w --u` A ssi M, w * A
M, w --u` A . B ssi M, w --u` A ou M, w --u` B
M, w --u` lA ssi pour tout w1 P W, si Rpw, w1q, alors M, w1 --u` A

2.1. Introduction a` la logique modale propositionnelle 21
Ces de'finitions se ge'ne'ralisent imme'diatement aux autres connecteurs a` l'aide des lois deDe Morgan :

M, w --u` J ssi 0 , 1
M, w --u` A ^ B ssi M, w --u` A et M, w --u` B
M, w --u` A N~ B ssi si M, w --u` A, alors M, w --u` B
M, w --u` A O/ B ssi M, w --u` A N~ B et M, w --u` B N~ A
M, w --u` \Sigma A ssi il existe w1 P W tel que Rpw, w1q et M, w1 --u` A

Une formule A est satisfaisable dans M, s'il existe un point w P WM tel que A estsatisfaite dans

M au point w (Dw P WM: M, w --u` A). Elle est globalement vraie dans M si elleest satisfaite en tout point de l'univers de

M (@w P WM: M, w --u` A). Elle est satisfaisable(respectivement, globalement vraie), s'il existe un mode`le

M dans lequel elle est satisfaisable(respectivement, globalement vraie).

Exemple 2.2Conside'rons les mode`les suivants :

M1 flw0::

^^
flw1OE

flw2

TT
ee

M2 flw0OE88

__
flw1

flw2OE

UU
ff

1. La formule OE N~ lOE est globalement vraie dans le mode`le M1 ou` VM1pOEq i tw1u. Parcontre, dans

M2 ou` V pOEq i tw0, w2u, elle n'est que satisfaisable :-
M2, w1 --u` OE N~ lOE et M2, w0 --u` OE N~ lOE ;-
M2, w2 --u` OE, Rpw2, w1q et M2, w1 * OE implique M2, w2 * OE N~ lOE (la formule n'estdonc pas globalement vraie dans

M2).

2. La formule OE N~ \Sigma OE n'est pas globalement vraie dans M1, mais l'est dans M2. En effet,on a :

- M1, w1 --u` OE mais M1, w1 * \Sigma OE car w1 n'est l'origine d'aucune fle`che.-

M2, w1 --u` OE N~ \Sigma OE car M2, w1 * OE.-
M2, w0 --u` OE N~ \Sigma OE car M2, w0 --u` OE et w0Rw0.-
M2, w2 --u` OE N~ \Sigma OE car M2, w2 --u` OE, w2Rw0 et M2, w0 --u` OE.

3. Les mode`les

M3 flw0OE

flw1OE

flw2

UU
ff

M4 flw0
flw1OE

flw2

UU
ff

montrent que la distributivite' de la boi^te sur la disjonction est satisfaisable mais n'estpas globalement vraie. En effet, la formule

lpOE . q N~ lOE . l est satisfaisable dans

22 Chapitre 2 - Introduction a` la logique modale propositionnelle

M3 (et me^me globalement vraie dans M3). Elle n'est cependant pas satisfaite au point
w2 de M4 : M4, w2 --u` lOE . , mais M4, w2 * lOE et M4, w2 * l.

4. La formule l K est satisfaisable dans les mode`les M3 et M4 (par les points w0 et w1).En re`gle ge'ne'rale, cette formule est satisfaite en tout point de'connecte' -- ou du moins

ne permettant d'atteindre aucun autre point (origine d'aucune fle`che).
La notion de satisfaisabilite' est locale au sens ou` elle est de'finie au niveau des mode`les etde'pend donc d'une valuation donne'e. Deux mode`les distincts peuvent e^tre construits sur un
me^me cadre et ne pas satisfaire les me^mes formules. Dans les exemples ci-dessus (Exemple 2.2),les mode`les

M1 et M2 ont un cadre commun, de me^me que les mode`les M3 et M4. Ils ne sedistinguent que par les valuations. Cette notion de valuation peut e^tre e'tendue aux formules

en ge'ne'ral par :

VMpAq i tw P W -- M, w --u` Au

On constate que A est satisfaisable dans M si VM , ? et qu'elle est globalement vraie dans
M si VM i W . La notion de valuation pour les formules peut aussi e^tre obtenue induc-tivement. Les connecteurs logiques correspondent aux ope'rations ensemblistes habituelles (le

comple'ment, l'union et l'intersection) :

V pKq i ?
V pJq i W
V pAq i ApV pAqq
V pA . Bq i V pAq Y V pBq
V pA ^ Bq i V pAq X V pBq
V pA N~ Bq i ApV pAqq Y V pBq

Les modalite's logiques correspondent a` des ope'rations plus complexes faisant intervenirla relation d'accessibilite'. Intuitivement, pour ve'rifier la satisfaisabilite' des formules

lA ou\Sigma 
A, il faut parcourir l'univers a` la recherche d'e'tats dans lesquels la formule A est satisfaite.Cette recherche n'est pas exhaustive mais guide'e par la relation d'accessibilite' : seuls les

e'tats accessibles a` partir de l'e'tat courant sont parcourus. Dans le cas de la boi^te, chacun deces e'tats doit satisfaire la formule. Dans le cas du diamant, l'un au moins doit la satisfaire.
On peut donc voir l'ope'ration ensembliste correspondante comme une recherche, a` partir del'ensemble

V pAq, des points origines qui atteignent un point dans V pAq :

V plAq i tw P W -- @w1 P W, Rpw, w1q n~ w1 P V pAqu
V p\Sigma Aq i tw P W -- Dw1 P W, Rpw, w1q et w1 P V pAqu

Lorsque la relation d'accessibilite' R est fonctionnelle et totale, les deux modalite's coi"nci-dent et

V plAq i \Sigma A peut e^tre de'fini comme l'image inverse de R :

V plAq i V p\Sigma Aq i R\Delta 1pV pAqq

De'finition 2.1.5 (Validite').Une formule

A est valide dans un cadre F a` un point w (notation : F, w --u` A), si pour toutevaluation
V , xF, V y, w --u` A. La formule A est valide dans le cadre F (notation : F --u` A), sipour tout point

w de l'univers, F, w --u` A. Elle est valide si elle est valide dans tout cadre.

Exemple 2.3

2.1. Introduction a` la logique modale propositionnelle 23
1. La formule lpA N~ Bq N~ plA N~ lBq est valide. Soit F, w --u` lpA N~ Bq et F, w --u` lA.Soit

w1 tel que Rpw, w1q. Alors, F, w1 --u` A N~ B et F, w1 --u` A. Donc, F, w1 --u` B et onpeut conclure

F, w --u` lB.

2. De me^me, la formule \Sigma pA . Bq N~ p\Sigma A . \Sigma Bq est valide dans tout cadre : soit w tel que

w --u` \Sigma pA . Bq. Il existe donc au moins un point accessible a` partir de w satisfaisant laformule

A . B. Soit w1 ce point. On a Rpw, w1q et w1 --u` A . B. Supposons, sans pertede ge'ne'ralite',

w1 --u` A. Par conse'quent, w --u` \Sigma A.

3. Dans le cadre F1

F1 flw0

''
flw1

77

flw3
ou` RF1 est fonctionnelle, la boi^te modale est distributive sur la disjonction. La formule
lpA . Bq N~ plA . lBq est donc valide dans F1. Autrement dit, quelque soit la valua-tion

V , on a xF1, V y --u` lpA . Bq N~ plA . lBq. Plus ge'ne'ralement, cette formule estvalide dans tout cadre dont la relation d'accessibilite' est fonctionnelle (Proposition 2.2).

4. Dans le cadre F2

F2 flw0

''
flw1

77

flw3:: flw2

TT

ou` RF2 est fonctionnelle et totale, la formule lOE O/ \Sigma OE est globalement vraie. Plusge'ne'ralement, dans tout cadre dont la relation d'accessibilite' est fonctionnelle et totale,
la boi^te et le diamant coi"ncident.
5. Le cadre F2 valide e'galement la formule lOE O/ lOE qui exprime la neutralite' de laboi^te vis-a`-vis de la ne'gation. Plus ge'ne'ralement, dans les structures fonctionnelles et

totales, la boi^te et le diamant sont des modalite's e'quivalentes et auto-duales :

w --u` lA ssi w "--u` lAssi

Rpwq "--u` Assi
Rpwq --u` Assi

w --u` lA

6. La formule l K est trivialement valide dans tout cadre F tel que RF i ?.
7. La formule \Sigma J n'est pas valide dans le cadre F i xt0, 1, 2u, a* y

fl0 // fl1 // fl2
puisque le point 2 n'a pas de successeur. En revanche, elle est valide dans tout cadre dontla relation d'accessibilite' admet une branche infinie ou un cycle. Elle est par exemple

valide dans tout cadre isomorphe a` xN, a*y, ou si la relation d'accessibilite' est un ordrelarge :

24 Chapitre 2 - Introduction a` la logique modale propositionnelle

fl0 //jj fl1 //jj fl2jj
fl0 // fl1 // fl2 // fl3 // : : :
Contrairement a` la satisfaisabilite', la validite' ne de'pend pas d'une valuation donne'e, maisest lie'e uniquement au cadre conside're'. Pour distinguer sche'matiquement et graphiquement
ces deux notions, on peut dire que la validite' des formules de'pend du positionnement desfle`ches, alors que la satisfaisabilite' de'pend en plus de la position des variables propositionnelles. La validite' des formules permet donc de caracte'riser diffe'rentes classes de cadres (parexemple ceux dont la relation d'accessibilite' est fonctionnelle ou admet une branche infinie).

De'finition 2.1.6 (Conse'quence se'mantique).Soit \Gamma 

Y tAu un ensemble de formules modales.- La formule

A est une conse'quence se'mantique locale de \Gamma  (notation : \Gamma  --u` A) si etseulement si pour tout mode`le

M et tout point w P WM de l'univers, M, w --u` \Gamma implique
M, w --u` A.- La formule

A est une conse'quence se'mantique globale de \Gamma  (notation : \Gamma  --u`g A) lorsque,si \Gamma  est un ensemble de formules valides, alors

A est une formule valide : si pour tout Fet tout
w P WF on a F, w --u` \Gamma , alors pour tout F et tout w P WF, on a F, w --u` A. A estune conse'quence se'mantique globale de \Gamma  vis-a`-vis de

F lorsque, si \Gamma  est un ensemblede formules globalement vraies dans tout mode`le de
F, alors A est globalement vraiedans tout mode`le de
F.

Il est clair que la notion de validite' est plus forte que celle de ve'rite' globale, elle-me^meplus forte que la notion de satisfaisabilite'. En revanche, le rapport s'inverse en ce qui concerne la conse'quence se'mantique : la notion de conse'quence locale est plus forte que celle deconse'quence globale. C'est l'objet de la proposition suivante.

Proposition 2.1 (Conse'quence locale versus conse'quence globale).Soit \Gamma 

Y tAu un ensemble de formules. \Gamma  --u` A implique \Gamma  --u`g A.

De'monstration :On suppose que (*) : \Gamma 

--u` A, et que (**) : toutes les formules de \Gamma  sont valides. Soit Met
w P WM. De (**), on a que M, w --u` \Gamma  et de (*) on conclut que M, w --u` A : la formule Aest bien globalement vraie dans tout mode`le. Elle est donc valide. oe

Remarque 2.1.2. La re'ciproque de la proposition pre'ce'dente est fausse. Par exemple, on a
OE --u`g lOE (puisque OE est valide, elle est satisfaite par les points accessibles du point courant,quel que soit ce point ;

lOE est donc aussi valide) et pourtant OE * lOE (un contre-exemple estdonne' dans l'Exemple 2.2.1).

Intuition La conse'quence globale correspond a` la pre'servation de la validite' et de lave'rite' globale. En revanche, la conse'quence locale ne correspond pas simplement a` la pre'servation de la satisfaisabilite'. Elle est plus forte car elle exige une condition supple'mentairesur les points de l'univers : les formules doivent e^tre satisfaites par les me^mes points. Par
exemple, A n'est pas une conse'quence locale de \Sigma A (\Sigma A * A : A peut e^tre satisfaite en un

2.1. Introduction a` la logique modale propositionnelle 25
point accessible par le point courant sans que celui-ci la satisfasse pour autant), pourtant lasatisfaisabilite' de \Sigma 

A entrai^ne bien celle de A.

2:1:3 Expressivite' et caracte'risation

Nous nous inte'ressons ici a` l'expressivite' de LMP en la comparant a` la logique classiqueet en examinant le type de proprie'te's se'mantiques qu'elle permet de caracte'riser.

De'finition 2.1.7 (Caracte'risation).Soient

M une classe de mode`les et F une classe de cadres, \Gamma  Y tAu un ensemble de formules :-
A caracte'rise (ou de'finit) M , si pour tout mode`le M, M P M si et seulement si M --u` A.De me^me, \Gamma  caracte'rise

M lorsque pour tout mode`le M, M P M ssi M --u` \Gamma .

- A caracte'rise (ou de'finit) F , si pour tout cadre F, F P F si et seulement si F --u` A. Deme^me, \Gamma  caracte'rise

F , si pour tout cadre F, F P F ssi F --u` A.

Proposition 2.2 (Distributivite' de la boi^te sur la disjonction).La formule

lpA.Bq N~ plA.lBq caracte'rise la classe des cadres ou` la relation d'accessibilite'est fonctionnelle.

De'monstration :Soit

FFonc la classe des cadres dont la relation d'accessibilite' est fonctionnelle et soit F uncadre.

1. Supposons que RF ne soit pas fonctionnelle (F R FFonc), c'est-a`-dire qu'il existe w, w1 et

w2 P WF tels que pw, w1q P RF, pw, w2q P RF et w1 , w2. Soit V une valuation telle que
V pAq i tw1u et V pBq i tw2u. On a alors xF, V y --u` lpA . Bq et xF, V y * lA . lB.Par conse'quent,

F * lpA . Bq N~ lA . lB.

2. Soit F P FFonc et soit w P WF. Supposons que (*) : F, w * lpA . Bq. Si F, w * lA, onpeut conclure. Sinon, c'est qu'il existe un point accessible a` partir de

w ou` la formule
A n'est pas satisfaite. Puisque F P FFonc, ce point est unique, notons-le Rpwq. On adonc (**) :

F, Rpwq * A. Par (*), on a F, Rpwq --u` A . B. De (**), on de'duit donc que
F, Rpwq --u` B. Puisque Rpwq est l'unique point accessible a` partir de w, on a F, w --u` lBet finalement

F, w --u` lA . lB. oe

Traduction de LMP en logique classique On donne une traduction de LMP enlogique classique du premier ordre. Pour chaque variable propositionnelle

OE appartenant a` \Phi ,on suppose donne' un pre'dicat
POEpxq ou` la variable x repre'sente le point courant de l'univers,ainsi qu'une relation binaire
R\Pi  pour repre'senter la modalite' universelle. Le langage cible dela traduction, note' L

\Phi , est de'fini par :

A ::i K -- POEpxq -- R\Pi px, yq -- A -- A . A -- Dx: A
La traduction d'une formule A de LMP, note'e LAMx, est de'finie inductivement sur A par :L

OEMx i POEpxqL
KMx i KL
AMx i LAMxL
A . BMx i LAMx . LBMxL

lAMx i @y: pxR\Pi y N~ LAMyq py fraisq

26 Chapitre 2 - Introduction a` la logique modale propositionnelle

Notons que cette traduction n'est rien d'autre qu'une reformulation de l'interpre'tationse'mantique des formules de LMP ou` la modalite' est repre'sente'e par une relation binaire et
une quantification borne'e. Un mode`le du premier ordre est une structure qui fournit uneinterpre'tation aux pre'dicats et aux relations du langage, ce qui correspond pre'cise'ment aux
valuations et a` la relation d'accessibilite' du mode`le modal : l'interpre'tation de POE est donne'epar

V pOEq, et l'interpre'tation de la relation binaire R\Pi  est donne'e par la relation d'accessibilite'.Tout mode`le de LMP peut donc e^tre vu comme un mode`le du premier ordre. La proposition

suivante (dont une preuve est donne'e dans [BdRdV01]) est donc naturelle. Elle montre l'e'quiv-alence se'mantique, en terme de satisfaction et de ve'rite' globale, entre une formule de LMP et
sa traduction. On note M --u` LAMxrws pour signifier que la formule LAMx est satisfaite dans lemode`le

M par l'assignation qui associe w a` la variable x.

Proposition 2.3 (E'quivalence au niveau des mode`les).Soit

A une formule de LMP.

1. (Satisfaction). Pour tous M et w P WM : M, w --u` A ssi M --u` LAMxrws.
2. (Ve'rite' globale). Pour tout M : M --u` A ssi M --u` @xLAMx.

Caracte'risation et satisfaisabilite' La proposition pre'ce'dente ne signifie pas pourautant que toute formule de L

\Phi  est la traduction d'une formule de LMP. Par exemple, laformule

@y z: ppR\Pi px, yq ^ R\Pi px, zq ^ y , zq N~ Dw:pR\Pi py, wq ^ R\Pi pz, wqqq
exprimant la confluence locale de R\Pi  au point x ne correspond a` aucune formule de LMP.Il en est de me^me pour la re'flexivite' locale a` un point de l'univers : on peut montrer, par

des techniques de bi-simulation (voir [BdRdV01]), qu'aucune formule modale de LMP n'este'quivalente a` la formule

R\Pi px, xq de L\Phi . Intuitivement, cela refle`te l'impossibilite' d'exprimeren LMP le fait qu'un point pre'cis de l'univers est en relation avec lui-me^me. Plus ge'ne'ralement,

LMP ne permet pas d'exprimer de proprie'te's locales des points de l'univers. Du point de vuede la satisfaisabilite', la logique du premier ordre a une expressivite' plus fine au sens ou` elle
permet de manipuler explicitement les e'tats de l'univers.
Caracte'risation et validite' Inversement, au regard de la validite' (proprie'te's relativesaux cadres), LMP est un langage plus expressif que L

\Phi , puisqu'il permet de caracte'riser desclasses de structures qui ne sont pas de'finissables au premier ordre. Par exemple, les structures

dont la relation d'accessibilite' est transitive et bien fonde'e sont caracte'rise'es par la formulemodale de Lo"b, note'e

pLq, ce'le`bre en logique de la prouvabilite' : lplOE N~ OEq N~ lOE (pourune de'monstration et une discussion de la question de la de'finissabilite' de ces structures,

voir [BdRdV01]). En revanche, un raisonnement par compacite', applique' a` l'ensemble deformules ci-dessous (ou`

Bpnq de'signe la formule Dx1 : : : xn: pRpx1, x2q ^ \Xi  \Xi  \Xi  ^ Rpxn\Delta 1, xnqq et
A la formule suppose'e donner la caracte'risation) :

\Gamma  i tAu Y t@xyz: pRpx, yq ^ Rpy, zq N~ Rpx, zqqu Y tBpnq -- n P Nu
permet de montrer que ces structures ne sont pas de'finissables au premier ordre. Pour de'finirces structures, il faut passer au second ordre. Cela n'est pas surprenant puisque la validite'
modale (De'finitions 2.1.4 et 2.1.7) se de'finit par une quantification sur les valuations et doncsur les sous-ensembles de l'univers (

VFpOEq D^ WF). Le second ordre permet de manipuler ex-plicitement ces valuations -- de la me^me manie`re que le premier ordre permet de manipuler

2.1. Introduction a` la logique modale propositionnelle 27
explicitement les points de l'univers --, il permet donc de quantifier sur les mode`les et d'ex-primer la validite' des formules. Par conse'quent, il est possible d'e'noncer l'e'quivalence entre
une formule de LMP et sa traduction au second ordre en terme de validite'. Formellement,cette traduction est construite a` partir de la traduction au premier ordre :L

AM2x i @POE1, : : : , POEn: LAMx
ou` OE1, : : : , OEn sont les variables propositionnelles apparaissant dans A. De`s lors, on a la propo-sition suivante (dont une preuve est donne'e dans [BdRdV01]) qui e'tablit l'e'quivalence au
niveau des cadres entre une formule de LMP et sa traduction au second ordre.
Proposition 2.4 (E'quivalence au niveau des cadres).Soit

A une formule de LMP. Pour tout cadre F et tout point w de l'univers de F :

F, w --u` A ssi F --u` LAM2xrws

F --u` A ssi F --u` @x: LAM2x

2:1:4 Logiques modales normales et comple'tude

Le concept de logique modale normale fait re'fe'rence a` diffe'rents syste`mes syntaxiquesqui ont en commun un petit nombre de re`gles et un axiome. Il s'agit d'un regroupement
de logiques modales bien connues et bien e'tudie'es qui, toutes, sont construites sur la based'un noyau commun : le syste`me K. A` ce noyau peuvent s'ajouter diffe'rents axiomes (euxme^mes bien connus). L'inte're^t de ces syste`mes est que chaque extension ainsi obtenue permetde caracte'riser une classe de cadres. La pre'sentation du syste`me K et de certaines de ses
extensions est faite dans un formalisme a` la Hilbert.

Le syste`me K Le noyau, commun a` toutes les logiques normales, est appele' syste`me K.Il est compose' des re`gles de preuves ci-dessous ainsi que de toutes les instances de tautologies

propositionnelles et de tous les axiomes qui sont des instances du sche'ma d'axiome :

pKq lpOE N~ q N~ plOE N~ lq
Re`gles de preuve :

1. (Substitution). E'tant donne'e une preuve de A et une formule B quelconque, on peutconstruire une preuve de

rB-OEsA (formule obtenue en substituant uniforme'ment chaqueoccurrence de la variable propositionnelle

OE dans A par B).

2. (Modus ponens). E'tant donne'es une preuve de A et une preuve de A N~ B, on peutconstruire une preuve de

B.

3. (Ne'cessitation). E'tant donne'e une preuve de A, on peut construire une preuve de lA.

De'finition 2.1.8 (K-Preuve).Une K-preuve de

A est une suite de formules A1, : : : , An telle que An i A et pour tout i P
t1, : : : , nu, Ai est soit un axiome, soit obtenue a` partir d'un sous ensemble de tA1, : : : , Ai\Delta 1upar l'une des re`gles de preuves. S'il existe une K-preuve de A, on notera

$K A.

28 Chapitre 2 - Introduction a` la logique modale propositionnelle

Correction et comple'tude de K Il est aise' de ve'rifier que les deux premie`res re`glespre'servent la validite'. Le modus ponens pre'serve me^me la satisfaisabilite'. En revanche, la re`gle

de substitution ne pre'serve ni la ve'rite' globale ni la satisfaisabilite'. La re`gle de ne'cessitationpermet de placer une boi^te modale devant toute formule prouvable. Clairement, cette re`gle
pre'serve la validite' ainsi que la ve'rite' globale : A --u`g lA. En effet, si la formule A est satisfaiteen tout point de l'univers quelle que soit la valuation du mode`le (

V pAq i W pour toute V ),de me^me, en tout point, la formule
lA sera satisfaite quelle que soit V (V plAq i W pourtoute
V ). En revanche, la ne'cessitation ne correspond pas a` une conse'quence locale : A * lA(Remarque 2.1.2) ; elle ne pre'serve pas la satisfaisabilite'.

On a vu (Exemple 2.3.1) que l'axiome K est valide, i.e. --u` lpOE N~ q N~ plOE N~ lq. Parla Proposition 2.1, on a donc aussi :

lpA N~ Bq --u`g lA N~ lB.La ne'cessitation et l'axiome
K vont de pair et fonctionnent de manie`re duale pour ma-nipuler les boi^tes : l'axiome permet d'enlever les boi^tes ; la ne'cessitation permet de les placer

devant les formules.La correction forte et la comple'tude du syste`me K sont des conse'quences de la validite'
de l'axiome K et des re`gles de preuves. C'est l'objet de la proposition suivante dont unede'monstration est donne'e dans [BdRdV01] :

Proposition 2.5 (Correction forte et comple'tude de K).pour tout

F, F --u` A si et seulement si $K A.

Extensions de K Les extensions du syste`me K les plus connues sont construites a` l'aidedes axiomes (et proprie'te's associe'es) suivants :

pT q lOE N~ OE re'flexivite'
p4q lOE N~ llOE transitivite'
pBq OE N~ l\Sigma OE syme'trie
pDq lOE N~ \Sigma OE totalite'
pCDq \Sigma OE N~ lOE fonctionnalite'
pLq lplOE N~ OEq N~ lOE transitivite' + bonne fondation

Chacun de ces axiomes est valide dans une certaine classe de cadres et par suite corre-spond a` une conse'quence locale qui caracte'rise la relation d'accessibilite'. Le tableau ci-dessous

pre'sente les extensions du syste`me K les plus e'tudie'es en mentionnant les re'sultats de com-ple'tude associe's. Chaque syste`me est correct et complet vis-a`-vis de la classe des cadres

Fou` :

T i K \Gamma  pT q RF est re'flexiveK4

i K \Gamma  p4q RF est transitiveB
i K \Gamma  pBq RF est syme'triqueS4
i K \Gamma  pT q \Gamma  p4q RF est re'flexive et transitiveS5
i K \Gamma  pT q \Gamma  p4q \Gamma  pBq RF est une relation d'e'quivalenceKCD
i K \Gamma  pCDq RF est fonctionnelleKD
i K \Gamma  pDq RF n'est pas borne'e a` droiteKL
i K \Gamma  pLq F est un arbre fini transitif

A` chaque type de logique modale (ale'thique, de'ontique, etc) correspond une extension dusyste`me K. Par exemple, la logique e'piste'mique est de'finie syntaxiquement par les formules

prouvables dans le syste`me S4. Dans ce cadre, les axiomes K, T et 4 correspondent auxpostulats suivants :

2.1. Introduction a` la logique modale propositionnelle 29
pKq si un agent sait que A implique B et qu'il sait A, alors il sait B
pT q si un agent sait que A, alors A est vraie
p4q si un agent sait que A, alors il sait qu'il sait que A

Autrement dit, (K) les agents sont doue's d'une capacite' de de'duction infinie (ils saventtout ce qui peut e^tre de'duit) ; (

T ) ils raisonnent correctement ; (4) ils sont conscients de leursavoir.

Un autre exemple est celui de la logique de'ontique standard, essentiellement base'e surle postulat suivant : ce qui est obligatoire est tole're'. La logique de'ontique est donc syntaxiquement donne'e par les formules prouvables dans le syste`me KD. Se'mantiquement, ellecorrespond aux cadres ou` la relation est se'rielle.

Remarque 2.1.3. L'axiome D (totalite') et l'axiome CD (e'quivalent a` la distributivite' de laboi^te sur la disjonction) caracte'risent les relations fonctionnelles et totales (Exemple 2.3.3 et
2.3.4). Ils joueront un ro^le primordial dans MLDL, notamment dans l'optimisation des re`glesmodales (voir ci-dessous).

Variantes et re`gles de'rive'es Le syste`me K et ses extensions peuvent e^tre pre'sente'esdans d'autres formalismes, par exemple en de'duction naturelle ou en calcul des se'quents, qui

est mieux adapte' a` la recherche de preuve et l'automatisation. Historiquement, ce passage a`des formalismes ge'ome'triques plus modernes a permis l'e'tude du comportement calculatoire
des preuves en logique classique et intuitionniste, notamment a` travers l'introduction de lalogique line'aire et des re'seaux de preuves (J-Y. Girard, [GTL89]). Ci-dessous, nous pre'sentons
rapidement le syste`me K en de'duction naturelle et en calcul des se'quents, en insistant sur lesre`gles de'rive'es qu'il est commode d'introduire.

De'finition 2.1.9 (Correction des re`gles et des se'quents).
Soient F un cadre, S i pA1, : : : , An $ B1, : : : , Bkq, S1 et S2 des se'quents et S1S2 une re`gle.

- S est valide dans F (F --u` S) lorsque pour tout point w P WF, F, w --u` A1 ^ \Xi  \Xi  \Xi  ^ Animplique

F, w --u` B1 . \Xi  \Xi  \Xi  . Bk.

- la re`gle S1S2 est correcte vis-a`-vis de F lorsque la validite' du se'quent S1 dans F entrai^ne

celle de S2 : F --u` S1 implique F --u` S2.

Formalise' en de'duction naturelle, le syste`me K (axiome K et ne'cessitation) est donne'par :

\Gamma  $ A N~ B \Gamma  $ A

\Gamma  $ B e N~

\Gamma , A $ B
\Gamma  $ A N~ B i N~

$ lpA N~ Bq N~ plA N~ lBq pKq

$ A
$ lA ncs0

Il est a` noter que, contrairement aux autres re`gles, la re`gle de ne'cessitation exige que lecontexte soit vide. Ceci se justifie par le fait que la ne'cessitation ne correspond pas a` une
conse'quence locale (Remarque 2.1.2 : OE * lOE). Un contre-exemple est donne' par \Gamma  i tAu,

30 Chapitre 2 - Introduction a` la logique modale propositionnelle

(A $ A et A & lA). Pour pouvoir se placer dans n'importe quel contexte, il faudrait quece contexte soit lui aussi soumis a` la ne'cessitation :

A1, : : : , An $ A
lA1, : : : , lAn $ lA ncs1

La re`gle de ne'cessitation ncs1, qui est une ge'ne'ralisation de la re`gle ncs0, est non seule-ment valide, mais elle est me^me de'rivable dans le syste`me K. Il suffit en effet de distribuer la

boi^te gra^ce a` l'axiome K autant de fois que ne'cessaire. Cette version renforce'e de la ne'cessi-tation peut encore e^tre ge'ne'ralise'e si l'on passe au calcul des se'quents, ou` le contexte droit
peut contenir plusieurs formules :

A1, : : : , An $ B, C1, : : : , Ck
lA1, : : : , lAn $ lB, \Sigma C1, : : : , \Sigma Ck ncs2

La` encore, la re`gle ncs2 est de'rivable dans K. La de'rivation consiste a` passer toutesles formules

Ci a` gauche (g), appliquer ncs1 et tout repasser a` droite (d). Les syste`mes
pKq \Gamma  ncs1 et pKq \Gamma  ncs2 sont donc e'quivalents. Notons par ailleurs que la re`gle ncs2 faitintervenir la modalite' existentielle. La question se pose de savoir s'il est possible de remplacer

ces occurrences du diamant par des boi^tes. En ge'ne'ral, la re'ponse est non, pour la simpleraison que la boi^te n'est pas distributive sur la disjonction (Exemple 2.2.3). En revanche, si
l'on se place dans des structures fonctionnelles (caracte'rise'es par le syste`me KCD), alors ladistributivite' de la boi^te sur la disjonction est valide. Par conse'quent, la re`gle :

k a, 0 A1, : : : , An $ B1, : : : , BklA1, : : : , lA

n $ lB1, : : : , lBk ncs3

est valide. Autrement dit, les syste`mes K \Gamma  CD\Gamma ncs2 et K\Gamma ncs3 sont e'quivalents. Remar-quons que la condition de bord permet d'e'viter les cas d'erreur lie's au fait que la relation

de'note'e par la boi^te n'est pas ne'cessairement totale. L'exemple 2.2.4 montre que sans cela,l'infe'rence ne serait pas correcte. Elle permettrait par exemple de de'river :

K $
l K $

dont la conclusion est clairement fausse lorsqu'aucun e'tat n'est accessible a` partir de l'e'tatcourant. Bien entendu, lorsque la relation sous-jacente est fonctionnelle et totale, il est alors

possible de supprimer la condition de bord :

A1, : : : , An $ B1, : : : , Bk
lA1, : : : , lAn $ lB1, : : : , lBk ncs4

La re`gle ncs4 est de'rivable dans le syste`me K \Gamma CD \Gamma D. En fait, les syste`mes K \Gamma CD \Gamma Det
K\Gamma ncs4 sont e'quivalents.De'monstration :

Il suffit d'une part de remarquer que la re`gle ncs4 est correcte dans tout cadre fonctionnelet total. En effet, soit

F un cadre tel que RF est fonctionnelle et totale et w P WF. Notons
RFpwq l'unique point atteint par w.

F, w --u` lA1 ^ \Xi  \Xi  \Xi  ^ lAn ssi F, RFpwq --u` A1 ^ \Xi  \Xi  \Xi  ^ An

n~ F, RFpwq --u` Bi p1d^id^kqssi

F, w --u` lBi p1d^id^kq pHIqssi
F, w --u` lB1 . \Xi  \Xi  \Xi  . lBk

2.2. Introduction a` la logique dynamique propositionnelle 31
Inversement, la re`gle ncs4 permet de de'river les trois axiomes, en utilisant par ailleursles re`gles standard en calcul des se'quents (rappel \Sigma 

A j lA) :

axA $ A
gA, A $ ncs4

lA, lA $ d

lA $ \Sigma A N~ d

$ lA N~ \Sigma A

axA $ A

d$ A, A ncs4

$ lA, lA g\Sigma 
A $ lA N~ d

$ \Sigma A N~ lA

axA $ A axB $ B

N~ gA N~ B, A $ B ncs4

lpA N~ Bq, lA $ lB N~ d

lpA N~ Bq $ lA N~ lB N~ d

$ lpA N~ Bq N~ plA N~ lBq oe

2:2 Introduction a` la logique dynamique propositionnelle

Historiquement, la logique dynamique a e'te' de'veloppe'e par Vaughan Pratt (entre 1974 et1976 [Pra76]) comme une se'mantique de la logique de Hoare, avant de constituer un syste`me
de logique modale a` proprement parler. Elle peut e^tre vue comme une ge'ne'ralisation de lalogique de Hoare, qui unifie les aspects calculatoires et les aspects logiques des preuves en
injectant les programmes et l'exe'cution au niveau des formules. Ce rapprochement est renforce'par le paralle`le qui peut e^tre fait avec la se'mantique des langages de programmation impe'ratifs
de'finie en 1975 par E. W. Dijkstra a` travers la notion de transformateur de pre'dicats, [Dij75],et notamment le transformateur le plus connu : la plus petite pre'condition. Ce paralle`le est
esquisse' a` la fin de cette section.La caracte'ristique principale de LDP est de contenir une modalite' spe'cifique pour chaque
programme, inte'grant ainsi de manie`re explicite la structure et la syntaxe des programmes auniveau des formules logiques. Chacune de ces modalite's exprime la correction du programme
par lequel elle est indexe'e. La correction faible d'un programme ss vis-a`-vis d'une spe'cification
A -- apre`s toute exe'cution de ss (potentiellement aucune si ss ne termine pas), A est vraie-- est exprime'e par la formule

rsss A. La correction forte de ss vis-a`-vis de A -- il existe uneexe'cution de
ss (ss termine) apre`s laquelle A est vraie -- est exprime'e par la formule xssy A.Initialement, le langage de programmation pour lequel LDP a e'te' de'fini e'tait non de'terministe et contenait un petit nombre de constructions. Par la suite, des syste`mes de ve'rificationde programmes tels que KIV [BRS

\Gamma 00] ou KeY [BHS06], ont permis de developper la logique

dynamique et de l'adapter a` des langages de programmation plus e'volue's comme Java. Nousdonnons ici une pre'sentation de LDP dans sa version initiale.

2:2:1 Syntaxe

Pour de'finir le langage de programmation \Pi , on suppose fixe' un ensemble d'instructionsde base, note'es

ff, fi, etc, a` partir desquelles les programmes plus complexes sont construits.Formellement, la grammaire de \Pi  est de'finie par :

ss ::i ff -- ss Y ss -- ss ; ss -- ss\Sigma 

32 Chapitre 2 - Introduction a` la logique modale propositionnelle

Intuitivement, les programmes de ce langage peuvent e^tre vus comme des ge'ne'rateurs(non de'terministes) de mots sur un alphabet donne' : l'introduction

ff ge'ne`re la lettre a ; laconstruction
ss1 Y ss2 (le choix) ge'ne`re indiffe'remment l'un ou l'autre des deux mots engendre'spar ses branches

ss1 et ss2 ; le mot engendre' par le programme ss1 ; ss2 (la se'quence) est compose'du mot engendre' par

ss1 suivi du mot engendre' par ss2 ; le programme ss\Sigma  (l'ite'ration, note'eavec la fermeture de Kleene) ge'ne`re une se'quence finie de taille arbitraire du mot engendre' par

ss. Le langage \Pi  permet donc de ge'ne'rer toutes les expressions re'gulie`res (au sens habituel).Formellement, l'exe'cution d'un programme

ss de \Pi , note'e N~, est de'finie inductivement sur lastruture de
ss. On note pss le mot engendre' par le programme ss :

ff N~ pff
ss1 Y ss2 N~ xss1 ou xss2

ss1; ss2 N~ xss1xss2

ss\Sigma  N~ psspss \Xi  \Xi  \Xi  psslooomooon

n,nPN

Historiquement, la logique dynamique a e'te' e'labore'e pour un langage de programmationplus riche contenant entre autres les intersections et les tests. Toutefois, le fragment pre'sente'

ci-dessus aussi appele' logique dynamique propositionnelle re'gulie`re -- et qui correspond auxprogrammes re'guliers de l'alge`bre de Kleene -- suffit a` pre'senter les ide'es essentielles de la
logique dynamique qui seront exploite'es dans MLDL. La grammaire de LDP est une variantede celle de la logique modale propositionnelle ou` figure une modalite' universelle pour chaque
programme ss P \Pi . Formellement, la grammaire de LDP, construite a` partir d'un ensemblede'nombrable \Phi  de variables propositionnelles (note'es

OE, OE1, etc), est de'finie par :

A ::i OE -- K -- A -- A . A -- rsss A
L'ensemble des modalite's est clos vis-a`-vis du choix, de la se'quence et de l'ite'ration. Ainsi,pour chaque instruction de base

a, ras est une modalite'. De me^me, rss1 Y ss2s, rss1 ; ss2s et rss\Sigma ssont des modalite's de`s lors que
rsss, rss1s et rss2s sont des modalite's.

2:2:2 Se'mantique

Cadres re'guliers La plupart des syste`mes de transition e'tiquete's ne sont pas inte'ressantsdu point de vue de LDP car ils ne capturent pas la notion d'exe'cution associe'e au langage

de programmation sous-jacent. Les cadres pertinents sont ceux ou` les relations d'accessibilite'correspondent a` l'exe'cution des programmes, autrement dit ou` la se'mantique de la modalite'
rsss est donne'e par l'exe'cution de ss. Si tel est le cas, alors les proprie'te's du langage deprogrammation peuvent e^tre exprime'es et e'tudie'es dans la logique. Par exemple, les proprie'te's
de fonctionnalite' et de se'rialite' des relations d'accessibilite', exprime'es par les axiomes Cet

CD, correspondent au de'terminisme et a` la terminaison de l'exe'cution. La transitivite'correspond au fait que l'exe'cution ne modifie pas la me'moire. L'e'tat courant restant inchange',

les formules satisfaites sont les me^mes. Du point du vue de la certification de programmes,il est impe'ratif de conside'rer une logique dont la se'mantique refle`te la strate'gie d'exe'cution.
Les cadres dont l'e'tude est pertinente pour le langage \Pi  qui nous inte'resse ici, sont appele'scadres re'guliers.

De'finition 2.2.1 (Cadre re'gulier).Un cadre re'gulier pour LDP est un cadre

F tel que les relations d'accessibilite' sont ge'ne're'es

2.2. Introduction a` la logique dynamique propositionnelle 33
inductivement a` partir de relations de base Ra associe'es aux instructions atomiques et aumoyen des clauses suivantes :

Rss1Yss2 i Rss1 Y Rss2

Rss1 ;ss2 i Rss1 \Pi  Rss2

Rss\Sigma  i pRssq\Sigma 

Autrement dit, dans un cadre re'gulier, le choix correspond a` l'union ensembliste ; lase'quence, a` la composition et l'ite'ration a` la clo^ture re'flexive et transitive. Pour finir, un
mode`le re'gulier est un mode`le M i xF, V y ou` F est un cadre re'gulier.

Exe'cution symbolique Les proprie'te's d'e'valuation des constructions Y, ; et \Sigma  de \Pi  --par de'finition, valides dans tout cadre re'gulier -- peuvent e^tre de'crites dans LDP. La description des e'tapes d'exe'cution au niveau logique correspond a` ce qu'on appelle l'exe'cutionsymbolique. Cette exe'cution symbolique est de'finie dans LDP par le biais d'axiomes qui caracte'risent chacune des constructions du langage de programmation. L'exe'cution symboliquedes programmes de \Pi  est donne'e par les axiomes :

rss1 Y ss2s OE O/ rss1s OE ^ rss2s OE pA1q

rss1 ; ss2s OE O/ rss1s rss2s OE pA2q

xss\Sigma y OE O/ OE . xssy xss\Sigma y OE pA3q

rss\Sigma s OE O/ OE ^ rss\Sigma s pOE N~ rsss OEq pA4q

Une proprie'te' essentielle, attendue d'une logique dynamique, est que l'exe'cution symbol-ique coi"ncide pre'cise'ment avec l'exe'cution concre`te des programmes (au sens ou` les axiomes
caracte'risent l'exe'cution, De'finition 2.1.7), ce qui est le cas de LDP et de \Pi . C'est l'objet dela proposition suivante :

Proposition 2.6.Les axiomes

A1, A2, A3 et A4 caracte'risent les cadres re'guliers.

Remarque 2.2.1.La caracte'risation des cadres re'guliers par les axiomes

A1 \Delta  A4 ne signifie pas qu'un syste`mede'ductif e'tendant le syste`me K avec ces axiomes serait fortement complet car une telle logique

n'est pas compacte. Il suffit pour cela de conside'rer l'ensemble

\Gamma  i txss\Sigma y OE, xssy OE, xssy xssy OE, xssy xssy xssy OE, : : :u
et d'observer que tout sous-ensemble fini est satisfaisable tandis que \Gamma  lui-me^me ne l'est pas.Un re'sultat de comple'tude faible (

--u` A n~ $LDP A) est montre' dans [BdRdV01].

Pour finir, remarquons simplement que toutes les proprie'te's de'finissables dans LDP nesont pas de'finissables en logique classique du premier ordre (et re'ciproquement). C'est le
cas des cadres re'guliers a` cause de la fermeture de Kleene -- pour les caracte'riser, il fautpasser au second ordre. En revanche, le fragment de LDP sans fermeture de Kleene peut e^tre
traduit au premier ordre en de'finissant pour chaque modalite' rsss , la relation Rss associe'e(voir [BdRdV01] pour plus de de'tails sur ces traductions).

34 Chapitre 2 - Introduction a` la logique modale propositionnelle

2:2:3 LDP : une extension de la Logique de Hoare

Pour finir, nous de'crivons brie`vement le lien entre la logique dynamique et la logique deHoare. Nous exposons ci-dessous le paralle`le qui peut e^tre fait entre les notions de plus faible

pre'condition et d'exe'cution symbolique.
Logique de Hoare Les premie`res ide'es de la me'thode formelle que constitue la logiquede Hoare sont de'finies a` la fois par C. A. R. Hoare dans An axiomatic basis for computer

programming [Hoa69] et par R. W. Floyd dans Assigning meanings to programs [Flo67].Nous donnons ici quelques unes des ide'es essentielles de cette logique qui permettront de la
comparer a` la logique dynamique -- une pre'sentation comple`te de la logique de Hoare figuredans Methods and Logics for Proving Programs de P. Cousot [Cou].

Il s'agit d'une logique axiomatique de'die'e a` la spe'cification et la certification de pro-grammes impe'ratifs. Dans ce cadre, chaque programme est vu comme une fonction de transition entre les e'tats me'moire de la machine. La spe'cification d'un programme ss consiste alorsen la description des modifications de la me'moire ope're'es par l'exe'cution de

ss, a` l'aide detriplets de la forme

tAu ss tBu
ou` A et B, appele'es respectivement la pre'condition et la postcondition de ss, sont des formuleslogiques explicitant le contenu de la me'moire. En particulier,

A et B ne contiennent pasd'instruction. Le triplet ainsi forme' exprime la correction faible de

ss : si la pre'condition Aest vraie et si le programme
ss termine, alors, apre`s toute exe'cution de ss, la postcondition
B est vraie. La validite' de ces triplets est e'tablie gra^ce a` deux types de re`gles, calculatoireset logiques. Les re`gles calculatoires sont guide'es par la syntaxe des programmes et miment

son exe'cution. Par exemple, pour les constructions du choix (Y), de la se'quence (;) et del'ite'ration finie (

\Sigma ) pre'sente'es ci-dessus, les re`gles de Hoare sont donne'es par :

tAu ss tBu tAu ss1 tBu

tAu ss Y ss1 tBu

tAu ss tBu tBu ss1 tCu

tAu ss ; ss1 tCu

A N~ B tAu ss tBu B N~ A

tAu ss\Sigma  tBu

La re`gle de conse'quence quant a` elle, porte exclusivement sur les conditions et permetd'inte'grer le raisonnement logique aux de'rivations. Les implications logiques ainsi ge'ne're'es

sont prouve'es a` l'aide du dispositif mathe'matique standard. E'tapes calculatoires et e'tapeslogiques sont bien distinctes et traite'es se'pare'ment.

A1 N~ A tAu ss tBu B N~ B1

tA1u ss tB1u

Plus faible pre'condition La plus faible pre'condition d'un programme est un trans-formateur de pre'dicats, c'est-a`-dire une fonction sur les conditions (pre'dicats portant sur la

me'moire). La plus faible pre'condition de ss associe une pre'condition a` chaque postcondition :
De'finition 2.2.2 (Plus petite pre'condition).E'tant donne' un programme

ss et une postcondition B, la plus faible pre'condition de ss et B

2.2. Introduction a` la logique dynamique propositionnelle 35
est une formule A telle que le triplet tAu ss tBu est de'rivable et tel que pour toute formule
A1, si tA1u ss tBu est de'rivable, alors A1 implique A.

La plus faible pre'condition d'un programme ss et d'une postcondition B correspond donca` la condition la moins restrictive, mais suffisante, pour qu'apre`s l'exe'cution de

ss, B soitve'rifie'e. Cette notion (et plus ge'ne'ralement la notion de transformateur de pre'dicats) est cruciale du point de vue de la recherche de preuve. En effet, certaines re`gles calculatoires commeici celle de la se'quence -- et bien d'autres dans le cas de langages plus e'volue's incluant par
exemple des boucles (while, until, etc) -- font apparai^tre une condition qui ne figure pas dansle triplet prouve'. De`s lors, rechercher une preuve se re'sout bien souvent a` rechercher cette
condition et la plus petite pre'condition constitue un candidat ide'al. Dans Guarded commands,nondeterminacy and formal derivation of programs, [Dij75], Dijkstra de'finit sa se'mantique des
transformateurs de pre'dicats et donne les algorithmes de recherche correspondants. L'algo-rithme de recherche de la plus faible pre'condition est guide' par la syntaxe des programmes.
Dans le me^me esprit, le transformateur, note' wppss, Bq, associe' aux constructions Y, ; et \Sigma ,peut e^tre de'fini par :

wppss1 Y ss2, Bq i wppss1, Bq ^ wppss2, Bqwp

pss1 ; ss2, Bq i wppss1, wppss2, Bqqwp

pss\Sigma , Bq i wppss, Bq,avec l'obligation de preuves :

B O/ wppss, Bq

Pour les cas du choix et de la se'quence, une simple observation permet de remarquerque les clauses correspondent exactement a` l'exe'cution symbolique de'finie par les axiomes

A1, A2 de LDP. Dans le cas de l'ite'ration, il faut voir que la validite' de la formule rss\Sigma s Best e'quivalente a` celle de la formule

rsss B et de l'obligation de preuve : si rss\Sigma s B est valide,alors a` la fois
B et rss\Sigma s pB N~ rsss Bq sont valides (par axiome A4), donc les obligations depreuve
prsss Bq N~ B et B N~ rsss B sont valides, et pour finir on peut conclure que rsss B estvalide. Re'ciproquement, supposons que

rsss B ainsi que l'obligation B O/ rsss B soient valides.Alors, par ne'cessitation la formule
rss\Sigma s pB N~ rsss Bq est valide. Par ailleurs, puisque rsss B et
rsss B N~ B sont valides, on peut de'duire que B est e'galement valide. L'axiome A4 autorise a`conclure que la formule

rss\Sigma s B est valide.Finalement, la logique dynamique fait le lien entre la logique de Hoare et la notion de

plus faible pre'condition d'un co^te' et la logique modale et la notion d'exe'cution symbolique del'autre. Mais du point de vue de l'expressivite', la logique dynamique s'ave`re plus puissante car
elle me'lange arbitrairement expressions purement logiques et instructions : une formule telleque

rss1s pA N~ rss2s Bq n'est pas repre'sentable par un triplet de Hoare. Cet atout se manifesteclairement avec la notion d'exe'cution symbolique qui peut e^tre de'finie explicitement dans

LDP tandis qu'elle ne peut e^tre de'finie que de manie`re externe en logique de Hoare, commec'est le cas avec la plus faible pre'condition de Dijkstra.

36 Chapitre 2 - Introduction a` la logique modale propositionnelle

3
L'objet d'e'tude : MLimp

D

ans ce chapitre, nous pre'sentons le langage de programmation qui sera e'tudie' dansles chapitres suivants. ML

imp est un lambda-calcul non type' avec re'fe'rences d'ordresupe'rieur et avec une e'valuation en appel par valeur.

Le typage n'intervient en aucune fac,on dans le noyau du syte`me que nous pre'sentonsdans ce chapitre. L'objectif initial e'tait de traiter le langage de programmation avec son
syste`me de typage. Toutefois, le langage non type' soule`ve a` lui seul un ensemble de difficulte'sscientifiques suffisamment grand pour justifier une e'tude inde'pendante du typage. L'avantage
de conside'rer un langage non type' est qu'il est possible de conside'rer des programmes refuse'spar le typage statique mais dont le comportement calculatoire est correct. Un autre avantage
est que le mode`le de MLimp (Chapitre 6) est inde'pendant du typage et pourra e^tre re'utilise'pour n'importe quel syste`me de type. Mais ceci a un cou^t : l'ajout de re`gles d'e'valuation
correspondant aux erreurs de typage et qui sont en re'alite' une forme de typage dynamique.Nous introduisons d'abord la grammaire de ML

imp (Section 3.1) avant de pre'senter sase'mantique ope'rationnelle (Section 3.2).

3:1 Le langage MLimp

MLimp est un langage fonctionnel qui contient les constructions suffisantes pour manipulerles entiers, les paires, les fonctions et les re'fe'rences d'ordre supe'rieur. Autrement dit, les
fonctions et les adresses me'moire sont des valeurs qui, a` ce titre, peuvent e^tre aussi bienpasse'es en argument d'application que stocke'es dans la me'moire. De plus, le langage prend
en charge l'allocation de nouvelles adresses.Parmi les caracte'ristiques des langages de programmation a` la ML, deux sont a` souligner
car elles permettront, au chapitre suivant, de simplifier les me'canismes propres a` la logiquemodale et habituellement utilise's pour la certification de'die'e a` des langages de programmation
impe'ratifs tels que Java :

1. l'absence de distinction instructions / expressions : tout programme (s'il termine) a unevaleur de retour.

2. l'absence de valeurs-gauches : la distinction entre une re'fe'rence et son contenu est

38 Chapitre 3 - L'objet d'e'tude : MLimp

explicite. Ainsi, alors qu'en Java on e'crit

x i x \Gamma  1
ou` x est une variable entie`re, la syntaxe ML, qui interdit la modification des variableset impose que

x soit une re'fe'rence vers un entier, donne

x :i !x \Gamma  1
ou` !x est la primitive d'acce`s au contenu de x et :i la primitive d'affectation.

3:1:1 La grammaire de MLimp

Les constantes de base L'ensemble D des e'le'ments de base est compose' de deux en-sembles de constantes suppose's disjoints :

- les constantes entie`res, note'es n, n1, n1, etc. De manie`re a` e'viter les proble`mes lie's a`l'imple'mentation des entiers en machine (tels que le de'passement d'entiers par exemple),

on suppose qu'on a a` notre disposition Z, l'ensemble des entiers relatifs.- L : un ensemble de'nombrable des adresses me'moire concre`tes note'es

`, `1, `1, : : : , etc.Ces deux ensembles constituent les donne'es e'le'mentaires de notre langage de programmation

symbolique. Les constantes boole'ennes << true >> et << false >> sont repre'sente'es respectivementpar les constantes entie`res 1 et 0. Dans les conditionnelles, on conside'rera plus ge'ne'ralement
que la constante << true >> est repre'sente'e par n'importe quelle valeur entie`re diffe'rente de 0.La constante 0 repre'sente e'galement la valeur << void >> de ML.

Les fonctions primitives On suppose e'galement donne' un ensemble fini de symbolesde fonction, note's f

, f1, f1, etc, qui repre'sentent les ope'rations e'le'mentaires sur les entiers (il n'ya pas d'arithme'tique sur les adresses) : dans cet ensemble se trouvent au moins les ope'rations

arithme'tiques usuelles (\Gamma , \Delta , \Theta , -, etc). Chaque symbole de fonction f est donne' avec unearite'

k e^ 1 ainsi qu'une fonction totale ~f : Zk N~ Z qui de'finit l'ope'ration correspondante.

Les programmes Formellement, la grammaire des programmes, note's p, p1, p1, etc, estconstruite inductivement a` partir d'un ensemble de'nombrable X de variables d'expressions

note'es x, y, : : : , etc :

p ::i n -- ` -- fpp1, : : : , pnq

-- x -- *x: p -- p1 p2
-- pp1, p2q -- fstppq -- sndppq
-- p i p1 -- if p then p1 else p2
-- ref p -- p :i p1 -- !p

A` partir de ce noyau, il est possible de de'finir plusieurs autres constructions. Dans la suite,nous utiliserons la notation let

x i p in p1 de de'finition locale comme du sucre syntaxiquepour le programme
p*x: p1q p. Dans le cas ou` la variable x n'apparai^t pas libre dans leprogramme
p1, on utilisera la notation se'quentielle p ; p1. Par ailleurs, le programme effectuantla re'cursion, note' fix, est donne' par le combinateur de point fixe (en appel par valeur) de

Turing : (*y: *f: f pyyf q) *y: *f: f pyyf q.Les notions d'occurrences de variable libres et lie'es sont de'finies de manie`re habituelle.
L'ensemble des variables libres d'un programme p est note' FVppq. L'ope'ration de substitution

3.1. Le langage MLimp 39
implicite (sans capture de variables) est de'finie de la me^me manie`re que dans le *-calcul. Onnote

rp

1-

xsp le re'sultat de cette ope'ration.

Remarque 3.1.1. En pre'sence d'effets de bord, la substitution implicite d'un programme n'estpas se'mantiquement correcte. En effet, les deux programmes

rp

1-

xsp let x i p1 in p

n'ont pas en ge'ne'ral la me^me se'mantique ope'rationnelle. Par exemple, le programme r!r-ysp*x: yqqui de'signe la fonction

*x: !r, n'a pas le me^me comportement ope'rationnel que le programmelet
y i !r in *x: y. Dans le deuxie`me cas, le contenu de la re'fe'rence r est lu une seule foisdans l'e'tat courant, tandis que dans le premier cas il est lu a` chaque appel de la fonction

dans des e'tats diffe'rents de la me'moire. Pour cette raison, l'usage de la substitution implicitesera fortement restreint non seulement dans le langage de programmation mais aussi dans la
logique que nous de'finirons dans le chapitre suivant.
Remarque 3.1.2. Les constructions syntaxiques

fpp1, : : : , pnq fstppq sndppq ref p !p p :i p1
sont donne'es dans une forme totalement applique'e. En particulier, les symboles de fonctionsprimitives f ne peuvent apparai^tre que dans la construction f

pp1, : : : , pnq ou` l'application esttotale et porte sur le n-uplet complet des arguments. Cette forme d'application ne peut donc

pas e^tre confondue avec celle du langage qui peut e^tre partielle. Toutefois, a` partir de cesconstructions il est possible d'extraire les fonctions suivantes :

f1 j *x1 \Xi  \Xi  \Xi  xn: fpx1, : : : , xnqfst

1 j *x: fstpxq

snd1 j *x: sndpxqref

1 j *x: ref x

deref j *x: !xaffec

j *xy: x :i y

qui peuvent e^tre utilise'es avec l'application (curryfie'e) du langage et ont le me^me comporte-ment que les fonctions primitives. Il n'est pas judicieux de prendre f

, fst, snd, ref, ! et :i commeprimitives. En effet, ceci briserait l'invariant sur la forme des valeurs fonctionnelles, a` savoir

que toute valeur fonctionnelle est de la forme *x: p. Cet invariant facilite significativementl'e'tude des proprie'te's des valeurs fonctionnelles concre`tes.

E'tant donne' un programme p, l'ensemble des adresses qui apparaissent syntaxiquementdans

p, note' locppq est de'fini inductivement sur la structure de p par :

locpnq i ?loc

p`q i t`uloc
pfpp1, : : : , pnqq i T^1d^id^n locppiq

locpxq i ?loc
p*x: pq i locppqloc

pp p1q i locppq Y locpp1q

40 Chapitre 3 - L'objet d'e'tude : MLimp

locppp, p1qq i locppq Y locpp1qloc

pfstppqq i locppqloc
psndppqq i locppq

locpp i p1q i locppq Y locpp1qloc
pif p then p1 else p2q i locppq Y locpp1q Y locpp2q

locpref pq i locppqloc

pp :i p1q i locppq Y locpp1qloc

p!pq i locppq

Dans la suite, on notera locpp1, : : : , pnq pour de'signer l'ensemble des adresses qui appa-raissent dans l'un au moins des

pi.

Les valeurs Parmi les programmes, on distingue le sous-ensemble V des valeurs qui sontdes objets clos et totalement e'value's. Notons en particulier que les fonctions et les adresses

me'moires sont des valeurs de MLimp. Formellement, la syntaxe des valeurs est donne'e par lagrammaire suivante :

v ::i n -- ` -- pv1, v2q -- *x: p pF V ppq D^ txuq
Remarque 3.1.3. Toutes les valeurs fonctionnelles du langage sont de la forme *x: p ou` x estl'unique variable libre du programme

p.

3:1:2 Les stores bien forme's

On suppose donne'e une e'nume'ration " : N N~ L de l'ensemble des adresses me'moire. Lese'tats me'moires sont repre'sente's par des fonctions partielles, note's

s, s1, s1, : : : , et appele'esstores, qui associent des valeurs aux adresses me'moire et dont le domaine est un segment

initial de " :

s : L Y'N~ Vdom

psq i "pt0, : : : , 7dompsq \Delta  1uq

ou` 7 indique le cardinal d'un ensemble. Par ailleurs, l'ensemble des adresses qui apparaissentdans un store est note' loc

psq et de'fini par :

locpsq i d^

`Ps

t` -- locpsp`qqu

De'finition 3.1.1 (Mises-a`-jour).Soit

ps : L N~ Vq P S, n i 7L et ` P L Y t"nu, v une valeur. Alors, ps 4 ` DH vq est le storede'fini par :

domps 4 ` DH vq i dompsq Y t`u

ps 4 ` DH vqp`1q i #v si `

1 i `

sp`q sinon

Remarque 3.1.4. Dans le cas ou` ` R dompsq Y t"nu, la fonction ps 4 ` DH vq ne correspondpas a` un store car son domaine n'est pas un segment initial de

". Pour cette raison, nousne conside'rerons jamais ces objets. C'est pourquoi, e'tant donne' un store

ps 4 ` DH vq, soit
` P dompsq, soit ` i "n (pour n i 7dompsq).

3.2. Se'mantique ope'rationnelle de MLimp 41
Bonne formation Conside'rons le store : s i ` DH *x: !`1. La fonction stocke'e a` l'adresse

` fait clairement un acce`s a` une adresse non alloue'e dans s, a` savoir `1. Le store s fait donclui aussi re'fe'rence a` cette adresse non alloue'e. Pour interdire ce genre de configuration et

garantir qu'aucun acce`s me'moire n'est fait en dehors des zones alloue'es, on de'finit la notionde bonne formation des programmes et des stores.

De'finition 3.1.2 (Programme bien forme' dans un store).Soit

p un programme et s un store. Le programme p est bien forme' dans s lorsque toutes lesadresses qui apparaissent dans

p sont alloue'es dans s :

locppq D^ dompsq
L'ensemble des valeurs bien forme'es dans le store s est note' Vs.
De'finition 3.1.3 (Store bien forme').Un store

s est un store bien forme' si et seulement si sp`q P Vs pour toute adresse ` dans ledomaine de

s. L'ensemble des stores bien forme's est note' S.

3:2 Se'mantique ope'rationnelle de MLimp

La se'mantique ope'rationnelle de ML-imp est donne'e par une strate'gie a` <<petits pas>>en appel par valeur dont l'ordre (gauche a` droite) est de'termine' au moyen de la notion de
contexte d'e'valuation.

3:2:1 E'valuation a` <<petits pas>>

Les contextes d'e'valuation Les contextes d'e'valuation fixent l'ordre dans lequel lesprogrammes sont e'value's : de gauche a` droite pour les arguments des primitives et des fonctions, ainsi que pour les constructions binaires du langage. Formellement, la syntaxe descontextes d'e'valuation, note's C, est de'finie par la grammaire suivante :

C ::i pq -- fpv1, : : : , vn, C, p1, : : : , pmq

-- C p -- v C
-- C i p -- v i C -- if C then p1 else p2
-- pC, pq -- pv, Cq -- fstpCq -- sndpCq
-- ref C -- !C -- C :i p -- v :i C

Par la suite, nous e'crirons Cppq pour de'signer le programme obtenu en substituant leprogramme

p a` l'unique occurrence de pq dans C. Les contextes d'e'valuation sont des objet clos,par conse'quent si le programme

p est clos, alors Cppq est un programme clos. Ils de'finissentune strate'gie d'e'valuation en appel par valeur et de gauche a` droite.

E'valuation L'e'valuation est une relation binaire de'finie sur les e'tats d'e'valuation quisont des couples note's

p ffi s ou` p est un programme clos et s un store. On de'finit une e'tape

42 Chapitre 3 - L'objet d'e'tude : MLimp

d'e'valuation sur les e'tats d'e'valuation, note'e p ffi s a, p1 ffi s1, par les axiomes pre'sente'sci-dessous ainsi que par la re`gle de passage au contexte d'e'valuation :

p ffi s a, p1 ffi s1
Cppq ffi s a, Cpp1q ffi s1

Les primitives repre'sentant les ope'rations arithme'tiques usuelles sur les entiers s'e'valuenta` l'aide des fonctions mathe'matiques correspondantes qui sont toutes des fonctions totales :

f pn1, : : : , nkq ffi s a, ~f pn1, : : : , nkq ffi s
L'application d'une fonction et les projections s'e'valuent de manie`re standard. Pour lesconditionnelles, tout entier excepte' ze'ro est conside're' comme un repre'sentant du boole'en
true :

p*x: pq v ffi s a, rv-xsp ffi s
fstpv1, v2q ffi s a, v1 ffi s
sndpv1, v2q ffi s a, v2 ffi s

if n then p1 else p2 ffi s a, p1 ffi s psi n , 0q

if 0 then p1 else p2 ffi s a, p2 ffi s

Le test d'e'galite' est toujours bien de'fini (contrairement aux tests d'e'galite' de langagestels que Caml par exemple). Intuitivement, le test d'e'galite' est de'fini positivement sur les
couples de donne'es pures, c'est-a`-dire deux entiers, deux adresses ou deux paires de donne'espures. Tous les autres cas sont des cas d'erreurs et seront donne's plus bas. Formellement, le
test d'e'galite' est de'fini a` l'aide du symbole de Kronecker.

n i m ffi s a, ffin,m ffi s

ff i fi ffi s a, ffiff,fi ffi s
pv1, v2q i pv11, v12q ffi s a, pv1 i v11q \Theta  pv2 i v12q ffi s

Toutes les constructions d'acce`s a` la me'moire s'e'valuent e'galement de manie`re standard :

ref v ffi s a, "n ffi ps 4 "n DH vq pou` n i 7dompsqq
` :i v ffi s a, 0 ffi s 4 ` DH v psi ` P dompsqq

!` ffi s a, sp`q ffi s psi ` P dompsqq

Un des crite`res essentiels pour e'tablir la correction du syste`me MLDL re'side dans la con-cordance entre les valeurs closes et les formes normales (programmes totalement e'value's) de
MLimp. C'est pourquoi l'e'valuation doit contro^ler les acce`s me'moire (pas d'acce`s en zone nonalloue'e), mais aussi, pour certaines constructions, tester dynamiquement le bon typage des
appels (bien entendu, dans un cadre bien type', de telles re`gles ne seraient jamais exe'cute'es).Il est donc ne'cessaire de comple'ter la liste des re`gles d'e'valuation avec les axiomes suivants :

3.2. Se'mantique ope'rationnelle de MLimp 43
v1 v2 ffi s a, 0 ffi s psi v1 n'est pas une abstractionq
f pv1, : : : , vkq ffi s a, 0 ffi s psi vi R Z pour un i P r1::ksq
if v then p1 else p2 ffi s a, 0 ffi s psi v R Zq

fstpvq ffi s a, 0 ffi s psi v n'est pas une paireq
sndpvq ffi s a, 0 ffi s psi v n'est pas une paireq

v :i v1 ffi s a, 0 ffi s psi v R dompsqq

!v ffi s a, 0 ffi s psi v R dompsqq

n i ` ffi s a, 0 ffi s
` i n ffi s a, 0 ffi s
n i pv1, v2q ffi s a, 0 ffi s
pv1, v2q i n ffi s a, 0 ffi s

` i pv1, v2q ffi s a, 0 ffi s
pv1, v2q i ` ffi s a, 0 ffi s

*x: p i v ffi s a, 0 ffi s
v i *x: p ffi s a, 0 ffi s
*x: p i v ffi s a, 0 ffi s
v i *x: p ffi s a, 0 ffi s

NotationsOn note

a,\Sigma  la clo^ture re'flexive et transitive de la relation a,.On note
p ffi s c^ pour signifier qu'aucune e'tape de re'duction ne peut e^tre applique'e a` l'e'tat
p ffi s c'est-a`-dire que pour tout e'tat p1 ffi s1, p ffi s c^ p1 ffi s1.

3:2:2 Proprie'te's de l'e'valuation

Les propositions suivantes e'tablissent un certain nombre de proprie'te's de l'e'valuation desprogrammes, entre autres que l'e'valuation est de'terministe, que les valeurs sont les formes

normales de l'e'valuation, mais aussi que l'e'valuation pre'serve la bonne formation des pro-grammes et des stores.

Proposition 3.1 (De'terminisme de l'e'valuation).Soient

p ffi s, p1 ffi s1 et p2 ffi s2 des e'tats d'e'valuation bien forme's.

1. Si p ffi s a, p1 ffi s1 et p ffi s a, p2 ffi s2, alors p1 ffi s1 i p2 ffi s2.
2. L'e'valuation des programmes est confluente : pour tous stores s1, s2 et toutes valeurs

v1 P Vs1 et v2 P Vs2. Si p ffi s a,\Sigma  v1 ffi s1 et p ffi s a,\Sigma  v2 ffi s2, alors v1 ffi s1 i v2 ffi s2.

De'monstration :

1. L'ordre d'e'valuation est totalement fixe'. Par conse'quent, a` chaque e'tape une seulere'duction est possible.

2. Corollaire de (1) en raisonnant par re'currence sur le nombre d'e'tapes d'e'valuation.

44 Chapitre 3 - L'objet d'e'tude : MLimp

oe
Proposition 3.2 (Valeurs et formes normales).Soient

v une valeur, p un programme et s un store. Alors,

1. v est une forme normale : v ffi s c^.
2. si p est une forme normale (p ffi s c^), alors p est une valeur.

De'monstration :

1. Une simple observation de la syntaxe des valeurs permet de voir qu'aucune e'tape dere'duction n'est applicable.

2. Soit pffis un e'tat d'e'valuation tel que p n'est pas une valeur. On montre par induction sur

p qu'une e'tape de re'duction peut e^tre applique'e. Le programme p a l'une des formes :f

pp1, : : : , pnq p1 i p2 p1 p2 pp1, p2q fstpp1q sndpp1qif

p1 then p1 else p2 ref p1 p1 :i p2 ou !p1.

p i fpp1, : : : , pnq : si tous les pi sont des valeurs vi, alors on a p ffi s a,\Sigma  ~fpv1, : : : , vnq ffi sdans le cas ou` tous les

pi s'e'valuent sur des entiers, et pffis a,\Sigma  0ffis dans le cas contraire.Sinon, il existe
j, 1 d^ j d^ n, tel que pj n'est pas une valeur et pi est une valeur pourtout
i a* j. Par hypothe`se d'induction, il existe un e'tat d'e'valuation p1j ffi s1 tel que
pj ffi s a, p1j ffi s1. Finalement, on a fpp1, : : : , pj, : : : , pnq ffi s a, fpp1, : : : , p1j, : : : , pnq ffi s1.Tous les autres cas se montrent de manie`re similaire.

oe
De'finition 3.2.1 (E'tats d'e'valuation bien forme's).Un e'tat d'e'valuation

p ffi s est bien forme' lorsque s est un store bien forme' et que p est unprogramme bien forme' dans

s.

Proposition 3.3 (Pre'servation de la bonne formation).Soit

p ffi s un e'tat bien forme'. Si p ffi s a, p1 ffi s1, alors p1 ffi s1 est aussi un e'tat bien forme'.

De'monstration :Les seules e'tapes de re'duction qui modifient le store sont :

ref v ffi s a, "n ffi ps 4 "n DH vq et ` :i v ffi s a, 0 ffi ps 4 ` DH vq
ou` n i 7dompsq et ` P dompsq. Dans le second cas, le domaine de s n'a pas e'te' modifie' et labonne formation est pre'serve'e puisque par hypothe`se loc

pvq D^ dompsq. Dans le premier cas,alloc
psq est bien alloue'e dans le store d'arrive'e et locpvq D^ dompsq. Par ailleurs, on a clairementdom
psq Y t"nu i "pt0, : : : , nuq Dans le cas du passage au contexte, la bonne formation de s1est suppose'e par hypothe`se d'induction. Dans tous les autres cas, on a loc

pp1q i locppq et
s i s1. oe

Corollaire 3.3.1.Soit

pffis un e'tat d'e'valuation bien forme'. Si pffis a,\Sigma  p1 ffis1, alors p1 ffis1 est un e'tat d'e'valuationbien forme'.

4
Syntaxe et logique de MLDL

C

e chapitre est consacre' a` la pre'sentation du syste`me logique MLDL, le langage de spe'-cification et de preuve pour les programmes e'crits dans le langage ML

imp pre'sente' auChapitre 3. MLDL est base' sur une extension au second ordre de la logique dynamique,

dont les individus de base sont les valeurs du langage MLimp.

L'e'valuation symbolique La principale caracte'ristique du syste`me de preuve de MLDLre'side dans la distinction ope're'e entre les re`gles de de'duction proprement dites (pre'sente'es
ici en calcul des se'quents) et les re`gles d'e'valuation symbolique, que l'on peut voir comme desaxiomes transforme's en re`gles de re'e'criture. Formellement, la relation d'e'valuation symbolique
se pre'sente sous la forme d'une congruence de'finie sur les programmes et sur les formules ou`chaque re`gle de la forme

p * p1 exprime que les programmes p et p1 sont e'quivalents danstous les contextes logiques, tandis que chaque re`gle de la forme

A * A1 exprime que lesformules
A et A1 sont e'quivalentes dans tous les contextes (y compris sous les modalite's) 1.Dans MLDL, l'e'valuation symbolique sert principalement a` incorporer dans la logique les

re`gles d'e'valuation du langage MLimp. Nous verrons ainsi que toutes les e'tapes fonctionnellesde l'e'valuation (et notamment la

fi-re'duction) peuvent e^tre traite'es directement au niveau desprogrammes (e'valuation symbolique sur les programmes), tandis que les e'tapes impe'ratives

doivent e^tre traite'es au niveau des formules (e'valuation symbolique sur les formules) a` traversun calcul de modalite's sur lequel nous reviendrons plus en de'tail dans ce chapitre.

Il est bien connu que l'e'valuation symbolique (tout comme le test de conversion en the'oriedes types ou en de'duction modulo) est une aide pre'cieuse dans le cadre de la preuve sur
machine. Pour cette raison, il nous arrivera a` plusieurs reprises d'incorporer directement dansla relation d'e'valuation symbolique des e'quivalences qui sont par ailleurs prouvables dans le
formalisme (comme par exemple A j A), ceci afin de faciliter le travail de preuve. (Nousen verrons plusieurs exemples a` la Section 4.2.2.)

1. Cette distinction entre de'duction et e'valuation symbolique est he'rite'e du projet KeY [BHS06], maisrapproche e'galement notre travail de de la the'orie des types [ML84] et de la de'duction modulo [DHK03], avec
cette diffe'rence que la richesse de la logique dynamique utilise'e ici permet d'aborder les traits impe'ratifs de laprogrammation.

46 Chapitre 4 - Syntaxe et logique de MLDL

Les modalite's de MLDL Comme dans tout autre syste`me base' sur la logique dynamique,la me'moire est traite'e de manie`re implicite a` l'aide d'un certain nombre de modalite's. Le
syste`me MLDL inclut trois modalite's diffe'rentes :- les boi^tes (indexe'es par les programmes), qui sont directement he'rite'es de la logique

dynamique, mais aussi :- les updates, qui permettent d'exprimer des mises a` jour locales de la me'moire (et que
l'on peut voir comme des formes particulie`res de boi^tes), et- le

*-lieur, qui permet d'exprimer dans la logique l'allocation d'une adresse frai^che.Les modalite's seront pre'sente'es avec la grammaire des formules a` la Section 4.1.3).

Plan du chapitre La syntaxe et le syste`me de preuves de MLDL sont introduits dans lapremie`re section. Dans la deuxie`me section, on pre'sente un certain nombre de re`gles de'rivables
qui permettent entre autres d'e'tendre l'e'valuation symbolique. Pour finir, quelques preuvesde spe'cification sont pre'sente'es dans la dernie`re section. On y pre'sentera e'galement des extensions possibles du syste`me avec des modules de'die's a` l'arithme'tique et aux donne'es pures.

4:1 Syntaxe formelle de MLDL

Cette section de'finit les diffe'rentes cate'gories syntaxiques de MLDL (re'capitule'es dans laFigure 4.1). On pre'sente e'galement l'e'valuation symbolique sur les programmes et sur les
formules ainsi que le syste`me de'ductif.

4:1:1 Expressions symboliques

Les constantes et fonctions primitives On retrouve les entiers (note's n, n1, etc),ainsi que les fonctions primitives de ML

imp (note'es f, f1, etc). Les adresses me'moire de MLimpsont en revanche repre'sente'es par des adresses symboliques (ou noms d'adresses), note'es

ff, fi,etc. (Comme pour l'ensemble des variables, on suppose que l'ensemble des noms d'adresses,

note' A, est de'nombrable.) Intuitivement, les noms d'adresses de'finissent un second jeu devariables auxquelles sont attache's les trois invariants se'mantiques suivants :

1. une adresse symbolique de'note toujours une adresse me'moire concre`te et rien d'autre.
2. l'adresse de'note'e par une adresse symbolique est toujours alloue'e dans l'e'tat courantde la me'moire : un nom abstrait d'adresse ne de'notera jamais une adresse qui n'est pas

alloue'e.
3. deux adresses symboliques distinctes de'notent deux adresses me'moire distinctes.

Les programmes symboliques Le langage de programmation symbolique reprend lame^me grammaire que ML

imp a` la diffe'rence pre`s qu'ici les adresses concre`tes sont remplace'espar des adresses symboliques. Formellement, la cate'gorie syntaxique des programmes symboliques, note's p, p1, p1, etc, est de'finie par :

p ::i n -- ff -- fpp, : : : , pq

-- x -- *x: p -- p p
-- pp, pq -- fstppq -- sndppq
-- p i p -- if p then p else p
-- ref p -- p :i p -- !p

4.1. Syntaxe formelle de MLDL 47
Syntaxe des programmes symboliques

p ::i n -- ff -- fpp, : : : , pq

-- x -- *x: p -- p p
-- pp, pq -- fstppq -- sndppq
-- p i p -- if p then p else p
-- ref p -- p :i p -- !p

Syntaxe des valeurs symboliques
v ::i n -- ff -- fpv, : : : , vq

-- pv, vq -- fstpvq -- sndpvq
-- v i v -- if v then v else v
-- x -- *x: p

Syntaxe des updates
u ::i ? -- u ; v :i v1

Syntaxe des contextes d'e'valuation symbolique
Ces ::i pq -- fpv1, : : : , vn, Ces, p1, : : : , pmq

-- Ces p -- v Ces
-- pCes, pq -- pv, Cesq -- fstpCesq -- sndpCesq

-- Ces i p -- v i Ces -- if Ces then p1 else p2
-- ref Ces -- !Ces -- Ces :i p -- v :i Ces

Syntaxe des formules
A ::i Xpv1, : : : , vkq -- Ipvq

-- A -- A ^ A
-- @x: A -- @Xk: A
-- tuuA -- *ff: A -- rp as xs A

Figure 4.1 - Cate'gories syntaxique de MLDL

48 Chapitre 4 - Syntaxe et logique de MLDL

Les notions de variables libres et lie'es sont de'finies de la me^me manie`re que pour les pro-grammes concrets et FV

ppq de'signe l'ensemble des variables ayant des occurrences libres de
p. Par ailleurs, on note FNppq l'ensemble des adresses symboliques qui apparaissent dans p.L'ope'ration de substitution implicite

rp

1-

xsp est de'finie e'galement sur les programmes sym-boliques.

Les valeurs symboliques Les valeurs symboliques constituent un sous-ensemble desprogrammes symboliques ou` les constructions autorise'es sont restreintes : ni application, ni

acce`s me'moire (pas me^me en lecture seule). En revanche, les valeurs symboliques peuventcontenir toutes les autres constructions (variables libres, conditionnelles, projections, etc). Il
ne s'agit donc pas de valeurs au sens habituel. Leur avantage est d'offrir a` l'utilisateur uncertain degre' de liberte' qui lui permettra de choisir la strate'gie d'e'valuation la plus commode
pour faire une preuve. Par exemple, le programme :

p*x: pq pif 0 then 0 else 1q
pourra indiffe'remment 2 e^tre re'duit sur l'un des deux programmes :

rif 0 then 0 else 1-xsp p*x: pq 0
Dans certains cas, il peut aussi e^tre commode de poursuivre un calcul bien qu'une de sesbranches soit momentane'ment bloque'e : la re`gle symbolique de

fi-re'duction (ci-dessous, Fig-ure 4.2) autorise de re'duire le programme
p*x: pq pif y then 0 else 1q en rif y then 0 else 1-xsp.Cette souplesse dans les choix de strate'gie se justifie se'mantiquement parce que les restrictions

sur la grammaire des valeurs symboliques garantissent que :

1. l'e'valuation d'une valeur symbolique ne modifie pas la me'moire ;
2. l'e'valuation d'une valeur symbolique termine toujours ;
3. en supposant donne'e une assignation des variables et des adresses, chaque valeur sym-bolique de'note sans ambigui"te' une unique valeur concre`te quel que soit l'e'tat courant

de la me'moire (voir Proposition 6.26).
4. par conse'quent, la substitution d'une valeur symbolique est une ope'ration se'mantique-ment valide : les programmes

rv-xsp et let x i v in p calculent la me^me valeur.

Formellement, les valeurs symboliques, note'es v, v1, v1, : : : , etc, forment une sous-classe dela cate'gorie des programmes symboliques qui est de'finie par la grammaire suivante :

v ::i n -- ff -- fpv, : : : , vq

-- pv, vq -- fstpvq -- sndpvq
-- v i v -- if v then v else v
-- x -- *x: p

E'valuation symbolique sur les programmes Formellement, l'e'valuation symbol-ique est re'alise'e par une congruence de'finie a` la fois sur les programmes symboliques (pour

les e'tapes fonctionnelles) et sur les formules (pour les e'tapes impe'ratives). Nous de'finissons

2. On pourrait en fait de'montrer que le syste`me de re'e'criture, obtenu en orientant les re`gles de gauche a`droite, est confluent mais cela n'est pas utile pour la correction et la cohe'rence de MLDL.

4.1. Syntaxe formelle de MLDL 49
ci-dessous l'e'valuation symbolique sur les programmes symboliques, note'e p * p1 et de'finiepar les re`gles et axiomes suivants (re'capitule'es dans la Figure 4.2, p. 50) :

Re'flexivite' - Syme'trie - Transitivite' :

x * x n * n ff * ff

p * p1
p1 * p

p * p1 p1 * p2

p * p2

Calcul : f

pn1, : : : , nkq * ~fpn1, : : : , nkq

p*x: pq v * rv-xsp p\Sigma q
fstppv1, v2qq * v1snd

ppv1, v2qq * v2

if n then p else p1 * p pn , 0qif 0 then

p else p1 * p1

(*) : on suppose que les variables libres de v ne sont pas lie'es dans p.

Test d'e'galite' :

pn i mq * ffin,m pff i fiq * ffiff,fi p*x: p i *y: p1q * 0

pv1, v2q i pv11, v12q * pv1 i v11q \Theta  pv2 i v12q
L'e'galite' des valeurs symboliques est de'finie sur les donne'es pures ainsi que sur les valeursfonctionnelles pour lesquelles le test est toujours ne'gatif -- ci-dessus,

ffi de'signe le symbolede Kronecker. Le test d'e'galite' n'est donc pas re'flexif : en ge'ne'ral, v

i v est faux (n'estpas congruent a` 1). Ceci interdit toute e'quivalence logique entre le test d'e'galite' et l'e'galite'

de Leibniz de'finissable dans la logique (voir Section 4.1.5). Les autres re`gles de'finissant lacongruence sont les re`gles de passage au contexte (a` tous les contextes) :

pi * p1i
fpp1, : : : , pi, : : : , pkq * fpp1, : : : , p1i, : : : , pkq

p1 * p11
pp1, p2q * pp11, p2q

p2 * p12
pp1, p2q * pp1, p12q

p * p1
fstppq * fstpp1q

p * p1
sndppq * sndpp1q

p1 * p11
pp1 i p2q * pp11 i p2q

p2 * p12
pp1 i p2q * pp1 i p12q

p * p1
pif p then p1 else p2q * pif p1 then p1 else p2q

p1 * p11
pif p then p1 else p2q * pif p then p11 else p2q

p2 * p12
pif p then p1 else p2q * pif p then p1 else p12q

p * p1
*x: p * *x: p1

p1 * p11
pp1 p2q * pp11 p2q

p2 * p12
pp1 p2q * pp1 p12q

50 Chapitre 4 - Syntaxe et logique de MLDL

Re'flexivite' - Syme'trie - Transitivite' :
x * x n * n ff * ff

p * p1
p1 * p

p * p1 p1 * p2

p * p2

Calcul :
fpn1, : : : , nkq * ~fpn1, : : : , nkq

p*x: pq v * rv-xsp
fstppv1, v2qq * v1snd

ppv1, v2qq * v2

if n then p else p1 * p pn , 0qif 0 then

p else p1 * p1

pn i mq * ffin,m

pff i fiq * ffiff,fi
pv1, v2q i pv11, v12q * pv1 i v11q \Theta  pv2 i v12q

p*x: p i *y: p1q * 0

Figure 4.2 - E'valuation symbolique sur les programmes - (1/2)

4.1. Syntaxe formelle de MLDL 51
Passage a` tous les contextes :

pi * p1i
fpp1, : : : , pi, : : : , pkq * fpp1, : : : , p1i, : : : , pkq

p1 * p11
pp1, p2q * pp11, p2q

p2 * p12
pp1, p2q * pp1, p12q

p * p1
fstppq * fstpp1q

p * p1
sndppq * sndpp1q

p1 * p11
pp1 i p2q * pp11 i p2q

p2 * p12
pp1 i p2q * pp1 i p12q

p * p1
pif p then p1 else p2q * pif p1 then p1 else p2q

p1 * p11
pif p then p1 else p2q * pif p then p11 else p2q

p2 * p12
pif p then p1 else p2q * pif p then p1 else p12q

p * p1
*x: p * *x: p1

p1 * p11
pp1 p2q * pp11 p2q

p2 * p12
pp1 p2q * pp1 p12q

p1 * p11
pp1 :i p2q * pp11 :i p2q

p2 * p12
pp1 :i p2q * pp1 :i p12q

p * p1
pref pq * pref p1q

p * p1
!p * !p1

Figure 4.2 - E'valuation symbolique sur les programmes - (2/2)

52 Chapitre 4 - Syntaxe et logique de MLDL

p * p1
pref pq * pref p1q

p1 * p11
pp1 :i p2q * pp11 :i p2q

p2 * p12
pp1 :i p2q * pp1 :i p12q

p * p1
!p * !p1

4:1:2 Les updates

Les updates sont des mises-a`-jour locales de la me'moire. Ces patches peuvent s'appliquera` certains programmes symboliques ainsi qu'aux formules. Gra^ce a` la distinction explicite

qui est faite dans MLimp entre une re'fe'rence et son contenu (absence de valeurs-gauches),la notion d'updates de'veloppe'e dans KeY, [BHS06, Ru"m06], peut ici e^tre significativement
simplifie'e : les updates ne manipulent que des objets non mutables : les valeurs symboliques.
Syntaxe Formellement, un update, note' u, u1, u1, : : : , etc, est une liste finie de paires devaleurs symboliques de la forme v :

i v1 que nous appellerons mises-a`-jour atomiques :

u ::i ? -- u ; v :i v1
L'ensemble des adresses symboliques qui apparaissent dans un update, note' FNpuq, etl'ensemble de ses variables libres, note' FV

puq, sont de'finis composante par composante. Lasubstitution implicite de valeurs symboliques est e'galement de'finie sur les updates composante

par composante, ainsi :

FNpu; v1 :i v2q i FNpuq Y FNpv1q Y FNpv2q

FVpu; v1 :i v2q i FVpuq Y FVpv1q Y FVpv2q
rv-xspu ; v1 :i v2q i prv-xsuq ; prv-xsv1 :i rv-xsv2q

Updates et acce`s me'moire Applique' a` un programme, un update simule localementla mise a` jour. Formellement, l'application d'un update

u a` un programme symbolique de laforme !v est une ope'ration implicite (imple'mente'e par une re'e'criture) note'e

tuu!v et de'finiepar :

t?u!v j !v
tu ; v1 :i v2u!v j if v i v1 then v2 else tuu!v

Remarque 4.1.1. Les updates s'appliquent exclusivement aux programmes de la forme !v ou`v est une valeur symbolique. L'application

tuu!p n'est pas de'finie.

Remarque 4.1.2. Le re'sultat de cette ope'ration est un programme symbolique qui pourra parla suite e^tre simplifie', au moyen de la congruence

*, en une valeur symbolique.

Lorsque dans un update chaque valeur symbolique apparai^t au plus une fois comme entre'e(modulo e'valuation symbolique des valeurs), l'ordre des mises-a`-jour atomiques de cet update
n'a pas d'importance et peut e^tre modifie'. En revanche, il se peut qu'il y ait plusieurs entre'espour une me^me valeur symbolique, comme c'est le cas dans les deux exemples suivants :

u j pff :i 0 ; ff :i 1q u1 j ppif 0 then ff else fiq :i 5 ; pif 1 then fi else ffq :i 8q

Dans ces cas, l'ordre dans lequel apparaissent les mises-a`-jour atomiques est pris encompte. Par de'finition, les appels re'cursifs de l'application d'un update a` un programme

4.1. Syntaxe formelle de MLDL 53
symbolique s'arre^tent a` la premie`re correspondance en partant de la droite. Par conse'quent,toutes les mises-a`-jour atomiques de la me^me valeur se trouvant plus a` gauche dans la liste
sont ignore'es :

tu1u!fi j tpif 0 then ff else fiq :i 5 ; pif 1 then fi else ffq :i 8u!fi

* tfi :i 5 ; fi :i 8u!fi
j 8

E'valuation symbolique des updates La congruence s'e'tend naturellement a` la no-tion d'updates ou` elle est de'finie par les re`gles de simplification et de passage au contexte

suivantes :

pu ; ff :i v1 ; fi :i v2q * pu ; fi :i v2 ; ff :i v1q
pu ; ff :i v1 ; ff :i v2q * pu ; ff :i v2q

v1 * v11
pu ; v1 :i v2q * pu ; v11 :i v2q

v2 * v12
pu ; v1 :i v2q * pu ; v1 :i v12q

u * u1
u ; v1 :i v2 * u1 ; v1 :i v2

4:1:3 Le langage de spe'cification

Les formules, note'es A, B, C, : : : , etc, sont construites a` partir d'un ensemble de'nombrableR de variables du second ordre, note'es

X, Y, : : : , etc, qui repre'sentent les relations k-aires.Nous supposons que chaque variable du second ordre est donne'e avec une arite' que l'on

indique par un exposant au moment ou` la variable est introduite (quantification). La cate'goriesyntaxique des formules est de'finie par la grammaire suivante :

A ::i Xpv1, : : : , vkq -- Ipvq

-- A -- A ^ A
-- @x: A -- @Xk: A
-- tuuA -- *ff: A -- rp as xs A

Soulignons la pre'sence du pre'dicat constant I qui transforme n'importe quelle valeursymbolique v en une formule

Ipvq exprimant que v est une valeur diffe'rente de 0. Ainsi quedes trois modalite's : la boi^te modale, les updates et le

*-lieur.

rp as xs A : Il s'agit de la boi^te de la logique dynamique a` laquelle a e'te' ajoute' un lieur(_ as _) dont le ro^le est de re'cupe'rer la valeur calcule'e par le programme. Cette formule

se lit donc : << si p s'e'value vers une valeur x, alors A (qui peut faire re'fe'rence a` la valeurcalcule'e par

p a` travers la variable x) est vraie dans l'e'tat me'moire engendre' par lesmodifications de

p sur l'e'tat courant >>. Lorsque A ne de'pend pas de x, nous e'crironssimplement
rps A. Notons que contrairement aux valeurs symboliques, les programmessymboliques ne peuvent apparai^tre qu'a` l'inte'rieur des boi^tes. L'e'valuation symbolique

des boi^tes est de'finie a` la Section 4.1.4 (De'composition des boi^tes).

54 Chapitre 4 - Syntaxe et logique de MLDL

*ff: A : Il s'agit d'un lieur re'serve' aux noms d'adresses. Cela permet de ge'rer l'allocationde nouvelles adresses mais aussi le partage de me'moire, gra^ce au me'canisme standard

de propagation des conditions de frai^cheur des noms a` travers la formule. La formule
*ff:A se lit : << A est vraie apre`s allocation d'une nouvelle adresse me'moire nomme'e ff >>.Les re`gles relatives au

*-lieur sont pre'sente'es Section 4.1.4 (Propagation du *-lieur).

tuuA : Ici, les updates peuvent e^tre vus comme des formes particulie`re de boi^tes : boi^tesne contenant qu'une seule affectation dont les deux membres sont des valeurs symboliques et telles qu'aucune variable n'est lie'e par le _ as _. La formule tuuA se lit donc :<<

A est vraie apre`s application du patch u a` l'e'tat courant >>. Techniquement, celas'effectue en appliquant

u a` A, ope'ration explicite qui est de'finie par l'e'valuation sym-bolique sur les formules (Section 4.1.4, Propagation des updates). Intuitivement,

A estmise a` jour en remplac,ant les lectures d'adresses par leur contenu dans
u. Par exemple,
tff :i vur!ff as xs A est e'quivalent a` rv as xs A.

Les autres connecteurs habituels de la logique classique et modale ainsi que les quantifi-cateurs et les e'le'ments neutres se de'finissent aise'ment et de manie`re standard a` partir de ce

noyau :

A . B j pA ^ Bq
A N~ B j A . Bq
A O/ B j pA N~ Bq ^ pB N~ Aq
Dx: A j @x:  A
DXk: A j @Xk:  A
K j @X0: X
J j  K
xp as xy A j rp as xs A

Remarque 4.1.3. Le langage permet d'exprimer l'e'galite' de deux valeurs symboliques de troismanie`res diffe'rentes :

Ipv i v1q @X1: pXpvq N~ Xpv1qq rv i v1 as bs Ipbq
Nous verrons par la suite (Section 4.1.5) que ces trois expressions ne sont, en ge'ne'ral, pase'quivalentes.

Variables libres et substitution L'ensemble des occurrences libres de variables dupremier et du second ordre d'une formule

A est note' FVpAq. Celui des occurrences libres desnoms d'adresses est note' FN
pAq. La grammaire des formules comprenant des constructionsinhabituelles, nous explicitons formellement la de'finition de ces deux ensembles :

De'finition 4.1.1 (Ensemble des variables et noms d'adresses libres d'une formule).Soient

A, B des formules, v, v1 : : : , vn des valeurs symboliques, x et X des variables respective-ment du premier et second ordre,

ff une adresse symbolique, u un update et p un programmesymbolique.

1. L'ensemble des variables libres d'une formule est de'fini inductivement sur la structurede cette formule par :

4.1. Syntaxe formelle de MLDL 55
FVpXpv1, : : : , vnqq i d^

1d^id^nFV

pviq Y tXu

FVpIpvqq i FVpvq
FVpAq i FVpAq
FVpA ^ Bq i FVpAq Y FVpBq
FVp@x: Aq i FVpAq \Delta  txu
FVp@Xn: Aq i FVpAq \Delta  tXu
FVp*ff: Aq i FVpAq
FVptuuAq i FVpuq Y FVpAq
FVprp as xs Aq i FVppq Y pFVpAq \Delta  txuq

La notion d'ensemble de variables libres est naturellement e'tendue aux ensembles finisde formules. Soit \Gamma  un ensemble fini de formules. La notation FV

p\Gamma q de'signe l'ensembledes variables qui apparaissent libres dans l'une au moins des formules de \Gamma  :

FVp\Gamma q i d^

AP\Gamma  FV

pAq

2. L'ensemble des noms d'adresse libres d'une formule est de'fini inductivement par :

FNpXpv1, : : : , vnqq i d^

1d^id^n FN

pviq

FNpIpvqq i FNpvq
FNpAq i FNpAq
FNpA ^ Bq i FNpAq Y FNpBq
FNp@x: Aq i FNpAq
FNp@Xn: Aq i FNpAq
FNp*ff: Aq i FNpAq \Delta  tffu
FNptuuAq i FNpuq Y FNpAq
FNprp as xs Aq i FNppq Y FNpAq

De me^me, la notion d'ensemble de noms libres est trivialement e'tendue aux ensemblesfinis de formules : FN

p\Gamma q est l'ensemble des noms qui apparaissent libres dans l'une aumoins des formules de \Gamma  :

FNp\Gamma q i d^

AP\Gamma  FN

pAq

La notion standard de substitution du 1er ordre est e'tendue aux constructions de notre lan-gage. Or, nous avons vu (Remarque 3.1.1) qu'en ge'ne'ral la substitution d'un programme symbolique n'est pas une ope'ration se'mantiquement correcte (r!r-ys*x: y ss plet y i !r in *x: yq).Pour cette raison, la substitution implicite du premier ordre est restreinte aux valeurs symboliques. Elle est note'e rv-xsA.

56 Chapitre 4 - Syntaxe et logique de MLDL

De'finition 4.1.2 (Substitution de valeurs symboliques dans une formule).Soient

A, B des formules, v, v1, v1 : : : , vn des valeurs symboliques, x, y et X des variables re-spectivement du premier et second ordre,

ff une adresse symbolique, u un update et p unprogramme symbolique. On suppose que les variables et noms d'adresse libres de v n'apparaissent pas lie's dans la formule a` laquelle on applique la substitution, ce qui est toujourspossible modulo alpha-conversion :

rv-xsXpv1, : : : , vnq i Xprv-xsv1, : : : , rv-xsvnq
rv-xsIpv1q i Iprv-xsv1q
rv-xspAq i prv-xsAq
rv-xspA ^ Bq i rv-xsA ^ rv-xsB

rv-xsp@y: Aq i #@y: A si x i y@y: rv-

xsA sinon (y R FVpvq)

rv-xsp@Xn: Aq i @Xn: rv-xsA
rv-xsp*ff: Aq i *ff: rv-xsA
rv-xsptuuAq i trv-xsuu rv-xsA

rv-xsprp as ys Aq i #r

rv-xsp as ys A si x i y

rrv-xsp as ys rv-xsA sinon

On note rv1-x1, : : : , vn-xnsA la substitution paralle`le des variables x1, : : : , xn par les valeurssymboliques v

1, : : : , vn dans la formule A.

La formule rB-Xpx1,:::,xnqsA de'note l'ope'ration de substitution implicite du second ordrede'finie sur le mode`le de la de'finition donne'e dans [Kri93].

De'finition 4.1.3 (Substitution du second ordre).Soient

A et B deux formules, x1, : : : , xn des variables et X une variable de relation n-airetelles que (

ffi) les variables x1, : : : , xn et les variables libres de B n'ont pas d'occurrence lie'edans
A (ceci est toujours possible modulo alpha-conversion). La formule rB-Xpx1,:::,xnqsA estde'finie inductivement sur la structure de

A par :

rB-Xpx1,:::,xnqsY pv1, : : : , vnq i #rv

1-x1, : : : , vn-xnsB si X i Y

Y pv1, : : : , vnq sinon
rB-Xpx1,:::,xnqsIpvq i Ipvq
rB-Xpx1,:::,xnqspAq i prB-Xpx1,:::,xnqsAq
rB-Xpx1,:::,xnqspA1 ^ A2q i rB-Xpx1,:::,xnqsA1 ^ rB-Xpx1,:::,xnqsA2
rB-Xpx1,:::,xnqsp@x: Aq i @x: rB-Xpx1,:::,xnqsA

rB-Xpx1,:::,xnqsp@Y n: Aq i #@Y

n: A si X i Y

@Y n: rB-Xpx1,:::,xnqsA sinon (ffi)
rB-Xpx1,:::,xnqsp*ff: Aq i *ff: rB-Xpx1,:::,xnqsA
rB-Xpx1,:::,xnqsptuuAq i tuu rB-Xpx1,:::,xnqsA
rB-Xpx1,:::,xnqsprp as xs Aq i rp as xs rB-Xpx1,:::,xnqsA

4.1. Syntaxe formelle de MLDL 57
4:1:4 L'e'valuation symbolique sur les formules

La congruence de'finie a` la Section 4.1.1 est e'tendue au niveau des formules a` l'aide desre`gles donne'es dans la Figure 4.3 (p. 60) et dont la fonction est de refle'ter au niveau logique
toutes les e'tapes impe'ratives de calcul (les e'tapes de calcul purement fonctionnelles e'tantde'ja` prises en charge par la congruence sur les programmes). Il est commode de de'composer
cet ensemble de re`gles en plusieurs groupes, respectivement de'die's a` la de'composition desboi^tes, la propagation des updates, la propagation du

*-lieur, la prise en charge des e'tapesfonctionnelles et un groupe de'die' au pre'dicat d'injection des valeurs symboliques dans les

formules :

Ip0q * K pinjKq
Ipnq * J n,0 pinjJq
Ipvq ^ Ipv1q * Ipv \Theta  v1q pinj^q

Tous les autres groupes concernent les e'tapes impe'ratives de l'e'valuation symbolique.L'ide'e ge'ne'rale de cette simulation est de de'composer les boi^tes, en tenant compte des misesa`-jour de la me'moire (apparition des updates) et des allocations (apparition du *-lieur),jusqu'a` ce qu'il soit possible de les effacer. Ces mises-a`-jour et allocations ainsi ge'ne're'es
seront ensuite propage'es dans la formule et simuleront localement les modifications de l'e'tatme'moire.

De'composition des boi^tes La de'composition des boi^tes est guide'e par l'ordre d'e'-valuation de ML

imp, mais gra^ce aux valeurs symboliques, il est possible (dans une certainemesure) de laisser a` l'utilisateur le choix de la strate'gie d'e'valuation. Le degre' de liberte' est

impose' par les contextes d'e'valuation symbolique. Formellement, les contextes d'e'valuationsymbolique, note's C

es, C1es, . . . , sont de'finis par :

Ces ::i pq -- Ces p -- v Ces -- fpv1, : : : , vn, Ces, p1, : : : , pmq

-- pCes, pq -- pv, Cesq -- fstpCesq -- sndpCesq
-- Ces i p -- v i Ces -- if Ces then p1 else p2
-- ref Ces -- !Ces -- Ces :i p -- v :i Ces

Les contextes d'e'valuation symbolique se distinguent des contextes d'e'valuation sur deuxpoints :

1. les contextes d'e'valuation symbolique ne sont pas ne'cessairement des objets clos. Ainsi,C

esppq peut contenir les variables libres alors me^me que p est un programme clos.

2. contrairement aux contextes d'e'valuation, les contextes d'e'valuation symbolique nede'finissent pas une strate'gie a` proprement parler car l'ordre qu'ils de'crivent est guide'

par les valeurs symboliques et n'est donc pas de'terministe. Par exemple, le programmesymbolique

pp*x: ffq 0q :i pif y then 0 else 1q
peut e^tre de'compose' en Cespp*x: ffq 0q avec Ces j pq :i pif y then 0 else 1qou en C

1espif y then 0 else 1q avec C1es j p*x: ffq 0 :i pq.

58 Chapitre 4 - Syntaxe et logique de MLDL

Formellement, la de'composition des boi^tes est de'finie par les re`gles de congruence suiv-antes :

rCesppq as xs A * rp as ys rCespyq as xs A yRFVpA,Ces,xq psplitq

rref v as xs A * *ff:tff :i vurff-xsA ffRFNpA,vq pallocq
rv1 :i v2 as xs A * tv1 :i v2ur0-xsA paffecq

rv as xs A * rv-xsA pdelq

La premie`re re`gle permet de de'composer une boi^te en suivant l'ordre d'e'valuation symbol-ique du programme qu'elle contient. La valeur calcule'e par le sous-programme est repre'sente'e

dans la suite du calcul par la variable y qui est lie'e par la nouvelle boi^te. Bien entendu, dansle cas ou` le programme boucle, la re`gle split pourra e^tre applique'e a` l'infini. Toutes les autres
re`gles de'crivent les cas ou` il est possible de supprimer une boi^te selon la forme du programmequ'elle contient. Une boi^te contenant une cre'ation de re'fe'rence (a` noter : l'argument de ref est
ne'cessairement une valeur symbolique) peut e^tre supprime'e en indiquant d'une part qu'uneallocation me'moire doit e^tre faite (a` l'aide du

*-lieur) et d'autre part la valeur a` stocker danscette nouvelle adresse (en ajoutant l'update ade'quat). Si la boi^te contient une affectation

dont les membres gauche et droit sont des valeurs symboliques, alors elle peut e^tre remplace'epar l'update correspondant (l'entier 0 jouant le ro^le de la valeur void, valeur de retour des
affectations). Finalement, lorsque la boi^te contient une valeur symbolique, elle peut tout sim-plement e^tre efface'e, il suffit de substituer cette valeur symbolique a` la variable lie'e par la
boi^te.Les re`gles split et alloc ne tiennent pas compte de la localite' des variables et effectuent
une ouverture de porte'e. Par exemple, les occurrences libres de x dans A ne sont pas, dans laformule de gauche, dans la porte'e du lambda, tandis qu'elles sont, dans la formule de droite,
dans la porte'e du as de la premie`re boi^te :

rp*x: p2q p1s A * rp1 as xs rp2s A
De me^me, dans la re`gle alloc, la variable x et le nom d'adresse ff n'ont pas la me^me porte'e.Ceci justifie les conditions de bord des re`gles. L'impact sur la visibilite' des adresses me'moires

est important puisque les adresses locales sont alors traite'es comme si elles e'taient de'clare'esglobalement. Ainsi, les deux formules suivantes sont congruentes :

rlet r i pref 0q in *_: pr :i !r \Gamma  1 ; !rq as ccs A * rref 0 as rs r*_: pr :i !r \Gamma  1 ; !rq as ccs A
Remarque 4.1.4. Le paralle`le entre l'e'valuation symbolique en logique dynamique et le calculde la plus petite pre'-condition en logique de Hoare (Section 2.2.3), peut e^tre poursuivi dans le
cas des langages a` la ML. Pour esquisser ce paralle`le, on se base sur la de'finition de la plus faiblepre'-condition donne'e par J-C Fillia^tre dans [Fil99] et rappele'e ci-dessous. On observe que les
clauses de'finissant la plus faible pre'condition correspondent aux re`gles de de'composition desboi^tes, a` ceci pre`s que dans [Fil99] les adresses et leur contenu sont identifie's.

De'finition de Fillia^tre

wppcqp*r: Qq i Qrr DH cswp

pxqp*r: Qq i Qrr DH xswp
p!xqp*r: Qq i Qrr DH xswp
pe1; e2qp*r: Qq i wppe1qp*_: wppe2qp*x: Qqqwp
px :i e1qp*r: Qq i wppe1qp*x: Qrr DH voidsqwp
pref e1qp*r: Qq i wppe1qp*r: Qq

4.1. Syntaxe formelle de MLDL 59
Les trois premiers cas correspondent a` notre re`gle del (ou` !x est identifie' a` x). Le qua-trie`me cas correspond exactement a` la re`gle split. Les deux dernie`res correspondent a` une
combinaison de la re`gle split avec respectivement la re`gle affec et la re`gle alloc, en tenanttoujours compte de l'identification entre adresse et contenu.

Propagation des updates Les updates sont propage's vers l'inte'rieur de la formule etdisparaissent au moment ou` ils sont applique's aux programmes symboliques qui apparaissent

dans les boi^tes (ne'cessairement de la forme !v) et aux valeurs symboliques (arguments despre'dicats). Toutefois, cette propagation est bloque'e par la pre'sence des boi^tes modales. Dans
le cas ge'ne'ral, un update ne peut pas passer a` droite d'une boi^te car cela corromprait lase'quence des mises-a`-jour de l'e'tat me'moire, comme dans l'exemple suivant : la formule

tff :i 0urp*y: ff :i yq 42s r!ff as xs Ipx i 42q
est valide, tandis que la formule

rp*y: ff :i yq 42s tff :i 0ur!ff as xs Ipx i 42q
ou` l'update tff :i 0u a e'te' passe' a` droite de la premie`re boi^te, ne l'est pas. Un update est enattente devant une boi^te jusqu'a` ce que celle-ci soit suffisamment de'compose'e et contienne un

programme de la forme !v. Dans ce cas pre'cis (re`gle read), l'update traverse la boi^te : il passea` droite de la boi^te mais au passage il est applique' au programme afin de lire le contenu de
la me'moire (a` l'aide de l'ope'ration tuu!v de'finie Section 4.1.2). Formellement, la propagationdes updates est de'finie par les re`gles (upd) suivantes :

tuuIpvq * Ipvq
tuu@x:A * @x:tuuA xRFVpuq
tuu@X:A * @X:tuuA

tuu*ff:A * *ff:tuuA ffRFNpuq
tuutu1uA * tu ; u1uA
tuur!v as xs A * rtuu!v as xs tuuA xRFVpuq preadq

Propagation du *-lieur Excepte'e la premie`re, les re`gles de propagation du *-lieur sontessentiellement des re`gles de commutation entre

*-lieurs, avec la quantification du secondordre et avec la boi^te. Les commutations entre
*-lieurs et avec la boi^te correspondent au faitque l'ordre dans lequel les adresses sont alloue'es n'a pas d'importance. La premier re`gle refle`te

le fait que les valeurs symboliques ne de'pendent pas de l'e'tat de la me'moire. Formellement,la propagation du

*-lieur est de'finie par les re`gles (*rule) suivantes :

Ipvq * *ff: Ipvq ffRFNppq
*ff:*fi:A * *fi:*ff:A
rp as xs *ff:A * *ff:rp as xs A ffRFNppq

Le *-lieur ne commute pas avec la quantification universelle du premier ordre dont ledomaine est de'fini a` partir de l'ensemble des adresses qui sont alloue'es dans l'e'tat courant

(Chapitre 7). Ainsi les deux formules

@x: *ff: rff :i 0 ; !x as ys Ipy , 0q *ff: @x: rff :i 0 ; !x as ys Ipy , 0q

60 Chapitre 4 - Syntaxe et logique de MLDL

Pre'dicat d'injection
Ip0q * K pinjKq
Ipnq * J n,0 pinjJq
Ipvq ^ Ipv1q * Ipv \Theta  v1q pinj^q

De'composition des boi^tes
rCesppq as xs A * rp as ys rCespyq as xs A yRFVpA,Ces,xq psplitq

rref v as xs A * *ff:tff :i vurff-xsA ffRFNpA,vq pallocq
rv1 :i v2 as xs A * tv1 :i v2ur0-xsA paffecq

rv as xs A * rv-xsA pdelq

Propagation des updates
tuuIpvq * Ipvq pupdq
tuu@x:A * @x:tuuA xRFVpuq
tuu@X:A * @X:tuuA

tuu*ff:A * *ff:tuuA ffRFNpuq
tuutu1uA * tu ; u1uA
tuur!v as xs A * rtuu!v as xs tuuA xRFVpuq preadq

Propagation du *-lieur
Ipvq * *ff: Ipvq ffRFNpvq p*ruleq
*ff:*fi:A * *fi:*ff:A
rp as xs *ff:A * *ff:rp as xs A ffRFNppq

Boi^te et quantification du 1er ordre
@h: rh 0 as xs A * @h: rh 0s @x: A h,fRFVpAq pisolq

Raisonnement par caspcasesq
rif v then p1 else p2 as xs A * pIpvq N~ rp1 as xs Aq ^ pIpvq N~ rp2 as xs Aq

Figure 4.3 - E'valuation symbolique sur les formules - (1/2)

4.1. Syntaxe formelle de MLDL 61
Passage aux contextes dela congruence sur les programmes dans les formules
vi * v1i
Xpv1, : : : , vi, : : : , vnq * Xpv1, : : : , v1i, : : : , vnq

v * v1
Ipvq * Ipv1q

p * p1
rp as xs A * rp1 as xs A

u * u1
tuuA * tu1uA

Ne'gation pre`gles primitives de'rivablesq

A * A pinvolq
*ff: A * *ff: A pneutrq

tuuA * tuuA pneutrq

Propagation des modalite's pre`gles primitives de'rivablesq

*ff: A ^ *ff: B * *ff: pA ^ Bq

tuupA ^ Bq * tuuA ^ tuuB
rp as xs pA ^ Bq * rp as xs A ^ rp as xs B

xp as xy pA ^ Bq * xp as xy A ^ xp as xy B

*ff: A N~ *ff: B * *ff: pA N~ Bq

tuupA N~ Bq * tuuA N~ tuuB
rp as xs pA N~ Bq * rp as xs A N~ rp as xs B

xp as xy pA N~ Bq * xp as xy A N~ xp as xy B

*ff: A . *ff: B * *ff: pA . Bq

tuupA . Bq * tuuA . tuuB
rp as xs pA . Bq * rp as xs A . rp as xs B

xp as xy pA . Bq * xp as xy A . xp as xy B

Boi^te ge'ne'rique pre`gles primitives de'rivablesq

l A * l l A ptransq
l pA ^ Bq * l A ^ l B pdistrq

Passage a` tous les contextes de la congruence sur les formules
A * A1
A * A1

A1 * A11
A1 ^ A2 * A11 ^ A2

A2 * A12
A1 ^ A2 * A1 ^ A12

A * A1
@x: A * @x: A1

A * A1
@X: A * @X: A1

A * A1
*ff: A * *ff: A1

A * A1
tuuA * tuuA1

A * A1
rp as xs A * rp as xs A1

Figure 4.3 - E'valuation symbolique sur les formules - (2/2)

62 Chapitre 4 - Syntaxe et logique de MLDL

ne sont pas e'quivalentes. Tandis que la premie`re est valide de`s lors qu'aucune adresse de l'e'tatcourant ne contient 0, la seconde est clairement fausse : la variable

x peut e^tre instancie'e parl'adresse
ff qui, elle, contient 0. En ge'ne'ral, nous avons donc :

@x: *ff: A ss *ff: @x: A
Ce proble`me survient e'galement pour la quantification universelle du second ordre @X: A,ou` la variable

X peut repre'senter n'importe quelle proprie'te' faisant re'fe'rence a` une adressealloue'e jusqu'ici. Comme pre'ce'demment, on aura donc en ge'ne'ral :

@X: *ff: A ss *ff: @X: A
Pour les me^mes raisons, une occurrence de *-lieur en te^te d'une formule ne peut pas e^tresupprime'e, et cela me^me si le nom d'adresse lie' par le

* n'apparai^t pas dans le reste de laformule. Il n'y a donc pas e'quivalence entre les formules

*ff: A et A, que ff apparaisse ou nonlibre dans
A.

Boi^te et quantifications du premier et du second ordre. Toujours pour lame^me raison (domaine non constant), la quantification du premier ordre ne commute pas, en

ge'ne'ral, avec une boi^te. Un contre-exemple est donne' par les formules

@xrref 1s r!x as ys Ipy i 0q rref 1s @xr!x as ys Ipy i 0q
qui ne sont clairement pas e'quivalentes. La premie`re est valide de`s lors que toutes les adressesalloue'es sont initialise'es a` 0. La seconde est clairement fausse, puisque la variable

x peut e^treinstancie'e par l'adresse qui vient d'e^tre alloue'e et initialise'e a` 1. Comme pre'ce'demment, le

me^me proble`me se pose avec la quantification universelle du second ordre.Toutefois, il est possible, sous certaines conditions, de faire interagir la boi^te et la quantification du premier ordre. C'est l'objet de la re`gle d'isolation ou` le lieur de la boi^te est expanse'par une quantification universelle :

@h: rh 0 as xs A * @h: rh 0s @x: A h,fRFVpAq pisolq
Intuitivement, cette re`gle peut e^tre comprise de la manie`re suivante : si une proprie'te'est vraie de la valeur calcule'e par n'importe quel programme, alors elle est vraie de toute

valeur apre`s e'valuation de n'importe quel programme. Autrement dit, e'valuer n'importe quelprogramme et re'cupe'rer la valeur calcule'e e'quivaut a` e'valuer n'importe quel programme, jeter
la valeur calcule'e et quantifier universellement dans le nouvel e'tat me'moire : quelle que soitla valeur conside're'e, on peut construire un programme qui la calcule (Lemme 7.7).

Raisonnement par cas La pre'sence de variables libres dans les programmes (non lie'espar une abstraction) peut bloquer l'e'valuation et le cas e'che'ant bloquer les tentatives de

preuves. C'est le cas dans l'exemple ci-dessus ou dans la formule :

ry 5 as xs Ipx i 120q
Toutefois, pour les conditionnelles bien forme'es -- ou` le programme test est une valeur sym-bolique et de'note bien un entier --, le proble`me peut e^tre contourne' en raisonnant par cas et

en prouvant se'pare'ment la spe'cification pour le programme de chacune des deux branches.Par exemple la proprie'te'

rpif py i 3q then y \Sigma  2 else 6q as xs Ipx i 6q

4.1. Syntaxe formelle de MLDL 63
peut e^tre prouve'e en montrant que la valeur retourne'e dans les deux cas (y i 3 et y , 3) estbien e'gale a` 6. C'est pre'cise'ment ce qu'exprime la re`gle de congruence suivante :

rif v then p1 else p2 as xs A * pIpvq N~ rp1 as xs Aq ^ pIpvq N~ rp2 as xs Aq pcasesq
Remarque 4.1.5. On pourrait penser que les re`gles d'e'valuation symbolique permettent defaire disparai^tre entie`rement les boi^tes et les updates dans les formules. Or ce n'est pas le cas.
Il existe des cas ou` l'e'valuation symbolique est bloque'e sur une formule contenant encore desboi^tes, comme c'est le cas pour la formule

@y: r!y as xs J
qui est valide (et me^me de'rivable) : aucune re`gle de congruence (lue comme une re'e'criture,oriente'e de gauche a` droite) ne peut lui e^tre applique'e, et pourtant elle contient encore une

boi^te. En ge'ne'ral, e'tant donne'es deux formules A et A1 telles que A1 est obtenue a` partir de Aen appliquant les re`gles de congruence (lues de gauche a` droite) autant de fois que possible,
A1 n'est pas une formule classique du second ordre (i.e. sans modalite').
Passage aux contextes La congruence des expressions symboliques (e'tapes fonction-nelles) et des updates est injecte'e au niveau des formules au moyen des re`gles de clo^ture

contextuelles suivantes :

vi * v1i
Xpv1, : : : , vi, : : : , vnq * Xpv1, : : : , v1i, : : : , vnq

v * v1
Ipvq * Ipv1q

p * p1
rp as xs A * rp1 as xs A

u * u1
tuuA * tu1uA

A * A1
A * A1

A * A1
A ^ B * A1 ^ B

B * B1
A ^ B * A ^ B1

A * A1
@x: A * @x: A1

A * A1
@X: A * @X: A1

A * A1
tuuA * tuuA1

A * A1
*ff: A * *ff: A1

A * A1
rp as xs A * rp as xs A1

4:1:5 Le syste`me de'ductif

Le langage de spe'cification est e'quipe' d'un syste`me de'ductif que l'on pre'sente ici dans leformalisme du calcul des se'quents a` la Gentzen. Ce syste`me (re'capitule' dans la Figure 4.4,

p. 65) inclut les re`gles standard de la logique classique du second ordre ainsi que des re`glesspe'cifiques a` notre langage pour l'e'valuation symbolique et les modalite's, re`gles largement
inspire'es de la logique modale dynamique.Le choix du formalisme (calcul des se'quents) se justifie par ses bonnes proprie'te's du point
de vue de la recherche de preuves, notamment la proprie'te' de la sous-formule (fragment dupremier ordre sans la congruence). Nous avons opte' pour une version du calcul avec se'quents
multi-conclusions car cela permet, dans notre cas pre'cis, de restreindre le noyau du syste`me a`un (relativement) petit nombre de re`gles, en particulier en ce qui concerne les re`gles modales
(Section 4.1.5).

64 Chapitre 4 - Syntaxe et logique de MLDL

E'tant donne' deux multi-ensembles finis de formules \Gamma  et \Delta , le se'quent \Gamma  $ \Delta  exprimeque la conjonction des formules de \Gamma  entrai^ne la disjonction des formules de \Delta , autrement dit
l'une au moins des formules de \Delta  peut e^tre prouve'e a` partir des formules de \Gamma .
Notation E'tant donne' un multi-ensemble fini \Gamma  de formules du langage, on notera :-

\Gamma  : l'ensemble des formules A telles que A P \Gamma  ;-
^\Gamma  (resp. .\Gamma ) : la conjonction des formules de \Gamma  (la disjonction des formules de \Gamma ).-
*ff: \Gamma  : l'ensemble des formules *ff: A telles que A P \Gamma  ;-
tuu\Gamma  : l'ensemble des formules tuuA telles que A P \Gamma  ;-
rp as xs \Gamma  : l'ensemble des formules rp as xs A telles que A P \Gamma .

Fragment classique du second ordre On retrouve les re`gles habituelles de la logiquedu second ordre dans leur version multiplicative, comprenant :

- le groupe identite' avec l'axiome et la coupure :

A $ A ax

\Gamma  $ A, \Delta  \Gamma 1, A $ \Delta 1

\Gamma , \Gamma 1 $ \Delta , \Delta 1 cut

- ainsi que les re`gles et axiomes pour les e'le'ments neutres :

\Gamma  $ \Delta 
\Gamma , J $ \Delta  top-g $ J top-d K $ bottom-g

\Gamma  $ \Delta 
\Gamma  $ K, \Delta  bottom-d

- le groupe structurel avec une re`gle gauche et une re`gle droite pour l'affaiblissement etla contraction :

\Gamma , A, A $ \Delta 

\Gamma , A $ \Delta  ctr-g

\Gamma  $ A, A, \Delta 

\Gamma  $ A, \Delta  ctr-d

\Gamma  $ \Delta 
\Gamma , A $ \Delta  wk-g

\Gamma  $ \Delta 
\Gamma  $ A, \Delta  wk-d

- le groupe logique avec une re`gle gauche et une re`gle droite pour les connecteurs :

\Gamma  $ A, \Delta 
\Gamma , A $ \Delta  g

\Gamma , A $ \Delta 
\Gamma  $ A, \Delta  d

\Gamma , A, B $ \Delta 
\Gamma , A ^ B $ \Delta  ^g

\Gamma  $ A, \Delta  \Gamma 1 $ B, \Delta 1

\Gamma , \Gamma 1 $ A ^ B, \Delta , \Delta 1 ^d

- ainsi qu'une re`gle gauche et une re`gle droite pour les quantificateurs du premier etsecond ordre :

\Gamma , rv-xsA $ \Delta 

\Gamma , @x: A $ \Delta  @

1g xRFVp\Gamma ;\Delta q \Gamma  $ A, \Delta \Gamma 

$ @x: A, \Delta  @

1d

\Gamma , rB-Xpx1,:::,xnqsA $ \Delta 

\Gamma , @Xn: A $ \Delta  @

2g XRFVp\Gamma ;\Delta q \Gamma  $ A, \Delta \Gamma 

$ @Xn: A, \Delta  @

2d

4.1. Syntaxe formelle de MLDL 65
Groupe identite'

A $ A ax

\Gamma  $ A, \Delta  \Gamma 1, A $ \Delta 1

\Gamma , \Gamma 1 $ \Delta , \Delta 1 cut

\Gamma  $ \Delta 
\Gamma , J $ \Delta  top-g $ J top-d K $ bottom-g

\Gamma  $ \Delta 
\Gamma  $ K, \Delta  bottom-d

$ Ipv i v1q N~ @X: pXpvq N~ Xpv1qq ident

Groupe structurel
\Gamma , A, A $ \Delta 

\Gamma , A $ \Delta  ctr-g

\Gamma  $ A, A, \Delta 

\Gamma  $ A, \Delta  ctr-d

\Gamma  $ \Delta 
\Gamma , A $ \Delta  wk-g

\Gamma  $ \Delta 
\Gamma  $ A, \Delta  wk-d

Groupe logique
\Gamma  $ A, \Delta 
\Gamma , A $ \Delta  g

\Gamma , A $ \Delta 
\Gamma  $ A, \Delta  d

\Gamma , A, B $ \Delta 
\Gamma , A ^ B $ \Delta  ^g

\Gamma  $ A, \Delta  \Gamma 1 $ B, \Delta 1

\Gamma , \Gamma 1 $ A ^ B, \Delta , \Delta 1 ^d

\Gamma , rv-xsA $ \Delta 

\Gamma , @x: A $ \Delta  @

1g xRFVp\Gamma ;\Delta q \Gamma  $ A, \Delta \Gamma 

$ @x: A, \Delta  @

1d

\Gamma , rB-Xpx1,:::,xnqsA $ \Delta 

\Gamma , @Xn: A $ \Delta  @

2g XRFVp\Gamma ;\Delta q \Gamma  $ A, \Delta \Gamma 

$ @Xn: A, \Delta  @

2d

Groupe modal
\Gamma  $ \Delta 
*ff: \Gamma  $ *ff: \Delta  *ncs

\Gamma  $ \Delta 
tuu\Gamma  $ tuu\Delta  upd-ncs

\Delta ,? \Gamma  $ \Delta rp as xs \Gamma  $ rp as xs \Delta  box-ncs

E'valuation symbolique
A * A

1 \Gamma , A

1 $ \Delta 

\Gamma , A $ \Delta  *g

A * A

1 \Gamma  $ A

1, \Delta 

\Gamma  $ A, \Delta  *d

Figure 4.4 - Syste`me de'ductif

66 Chapitre 4 - Syntaxe et logique de MLDL

E'galite' et Remplacement La grammaire de MLDL offre deux syntaxes pour exprimerl'e'galite' de deux objets :

Ipv i v1q et @X: pXpvq N~ Xpv1qq (ce qu'on notera v iLbz v1). Cesdeux e'galite's ne sont pas e'quivalentes. En effet, l'e'galite' de Leibniz identifie plus d'objets.

En particulier, elle est capable d'identifier des valeurs fonctionnelles. On voit aise'ment quela formule

Ip*x: p i *x: pq n'est pas valide (car p*x: p i *x: pq * 0), tandis que laformule
*x: p iLbz *x: p l'est. Par conse'quent, la validite' de la formule v iLbz v1 n'entrai^nepas celle de

Ipv i v1q. En revanche, toutes les valeurs identifie'es par le test d'e'galite' seront(se'mantiquement) identifie'es par l'e'galite' de Leibniz. C'est la raison pour laquelle le syste`me

contient un axiome explicitant cette implication :

$ Ipv i v1q N~ @X: pXpvq N~ Xpv1qq ident
E'valuation symbolique dans les preuves Par ailleurs, le syste`me comprend desre`gles spe'cifiques qui permettent d'inte'grer la congruence des formules au niveau des preuves.

Intuitivement, les deux re`gles suivantes expriment le fait que deux formules congruentes (cal-culatoirement e'quivalentes) sont logiquement e'quivalentes :

A * A

1 \Gamma , A

1 $ \Delta 

\Gamma , A $ \Delta  rw-g

A * A

1 \Gamma  $ A

1, \Delta 

\Gamma  $ A, \Delta  rw-d

Remarque 4.1.6. En raison de la pre'sence de ces re`gles, faisant appel a` l'e'valuation symbol-ique des programmes (e'ventuellement divergents), la ve'rification de preuve dans MLDL n'est
pas de'cidable. En pratique, il sera possible de forcer la de'cidabilite' de ces re`gles en les re-streignant arbitrairement, par exemple en limitant le nombre de pas d'e'valuation autorise's.
On ne conside'rera pas ces restrictions davantage lie'es au design de l'imple'mentation.

Re`gles modales Le groupe des re`gles modales est inspire' des re`gles standard de lalogique modale pre'sente'es au Chapitre 2. Gra^ce au formalisme choisi (calcul des se'quents)

et au caracte`re fonctionnel des trois modalite's (du^ en partie au de'terminisme de MLimp), cegroupe ne contient que trois re`gles :

\Gamma  $ \Delta 
*ff: \Gamma  $ *ff: \Delta  *ncs

\Gamma  $ \Delta 
tuu\Gamma  $ tuu\Delta  upd-ncs \Delta 

,? \Gamma  $ \Delta rp as xs \Gamma  $ rp as xs \Delta  box-ncs

Les trois modalite's de'notent au plus un e'tat me'moire, ce qui explique qu'on autoriseplusieurs formules dans le contexte droit. Le

*-lieur et l'update en de'notent exactement un,ce qui est la raison pour laquelle le contexte droit peut e'ventuellement e^tre vide. En revanche,

dans le cas ou` le programme qu'elle contient ne termine pas, la boi^te ne de'note aucun e'tatme'moire. C'est pour tenir compte de cette non terminaison e'ventuelle que la condition de bord
est ne'cessaire. Il n'est donc pas toujours ne'cessaire d'e'valuer symboliquement le programme
p pour prouver une formule de la forme rp as xs A. C'est bien le sens de la correction partielled'un programme.

Prouvabilite' Un se'quent est de'rivable dans MLDL s'il existe une de'rivation de ce se'quentdans le syste`me compose' des re`gles de la Figure 4.4. Une formule

A est prouvable si le se'quent
$ A est de'rivable.

4.2. Extensions du syste`me et re`gles de'rive'es 67
4:2 Extensions du syste`me et re`gles de'rive'es

Le noyau logique de MLDL pre'sente' a` la section pre'ce'dente est relativement restreint. Ilest donc naturel d'ajouter suffisamment de re`gles pour simplifier les preuves et les rendre le
plus intuitives possibles. Par ailleurs, l'e'valuation symbolique est la partie du raisonnementla plus automatisable. C'est pourquoi nous voulons lui inte'grer le maximum d'e'quivalences
logiques, y compris des e'quivalences de'rivables.Dans cette section, nous pre'sentons un ensemble de re`gles de'ductives qui sont de'rivables
dans MLDL (Section 4.2.1). Nous montrerons aussi un certain nombre d'e'quivalences logiques,et pour chacune d'entre elles, nous inte'grerons une nouvelle re`gle de congruence primitive a`
l'e'valuation symbolique (Section 4.2.2). L'ensemble des macro-re`gles et des re`gles de'rive'es estre'capitule' dans les Figures 4.5 et 4.6, pp. 71-72. Les re`gles primitives figurent avec les autres
re`gles de l'e'valuation symbolique (Figure 4.3, p. 60).

4:2:1 Re`gles de de'duction de'rive'es

Logique classique Les re`gles logiques du fragment classique du second ordre (disjonc-tion, implication et quantifications) sont de'rivables dans MLDL. On trouvera dans [Lau08] les

de'rivations des re`gles :

\Gamma , A $ \Delta  \Gamma 1, B $ \Delta 1

\Gamma , \Gamma 1, A . B $ \Delta , \Delta 1 .-g

\Gamma  $ A, B, \Delta 
\Gamma  $ A . B, \Delta  .-d

\Gamma  $ A, \Delta  \Gamma 1, B $ \Delta 1

\Gamma , \Gamma 1, A N~ B $ \Delta , \Delta 1 N~-g

\Gamma , A $ B, \Delta 
\Gamma  $ A N~ B, \Delta  N~-d

\Gamma , A $ B, \Delta  \Gamma 1, B $ A, \Delta 1

\Gamma , \Gamma 1 $ A O/ B, \Delta , \Delta 1 O/ d

xRFVp\Gamma ;\Delta q \Gamma , A $ \Delta \Gamma , Dx: A $ \Delta  D1-g \Gamma  $ r

v-xsA, \Delta 

\Gamma  $ Dx: A, \Delta  D

1-d

XRFVp\Gamma ;\Delta q \Gamma , A $ \Delta \Gamma , DX: A $ \Delta  D2-g \Gamma  $ r

B-XsA, \Delta 

\Gamma  $ DX: A, \Delta  D

2-d

Remplacement L'e'quivalence calculatoire de deux valeurs symboliques (de'finie par letest d'e'galite') se traduit par une e'quivalence logique, laquelle justifie le remplacement mutuel

de ces valeurs symboliques partout dans les formules. C'est pre'cise'ment ce qui est exprime'par les deux re`gles replG et replD :

\Gamma  $ rv-xsA, \Delta  \Gamma 1 $ Ipv i v1q, \Delta 1

\Gamma , \Gamma 1 $ rv

1-

xsA, \Delta , \Delta 1 replD

\Gamma , rv-xsA $ \Delta  \Gamma 1 $ Ipv i v1q, \Delta 1

\Gamma , \Gamma 1, rv

1-

xsA $ \Delta , \Delta 1 replG

68 Chapitre 4 - Syntaxe et logique de MLDL

Lemme 4.1.Les re`gles replG et replD sont de'rivables dans MLDL.

De'monstration :Il s'agit de montrer que ces re`gles sont de'rivables dans le syste`me de re`gles de la Figure 4.3
(p. 60). Nous donnons ci-dessous une de'rivation de la re`gle replD (le cas de replG estsimilaire) :

Ipv i v1q $ @X: pXv N~ Xv1qident

\Gamma 1 $ Ipv i v1q, \Delta 1

...
...
...
...

\Gamma  $ rv

1-

xsA, \Delta  axrv

1-

xsA $ rv

1-

xsA N~ g

\Gamma , rv-xsA N~ rv

1-

xsA $ rv

1-

xsA, \Delta  @2g

\Gamma , @X: pXv N~ Xv1q $ rv

1-

xsA, \Delta  cut

\Gamma , Ipv i v1q $ rv

1-

xsA, \Delta  cut

\Gamma , \Gamma 1 $ rv

1-

xsA, \Delta , \Delta 1 oe

Ne'cessitation existentielle La re`gle duale de la re`gle ncs-box est donne'e par :

\Gamma ,? \Gamma  $ \Delta xp as xy \Gamma  $ xp as xy \Delta  ncs-diam
Bien entendu, la condition de bord requiert que le contexte gauche (et non pas le contextedroit) ne soit pas vide. S'il l'est, alors la preuve devra obligatoirement passer par l'e'valuation
symbolique du programme. Cela correspond bien a` la notion de correction forte exprime'e parle diamant.

Lemme 4.2.La re`gle ncs-diam est de'rivable dans MLDL.
De'monstration :On note avec une double barre l'application re'pe're'e d'une me^me re`gle.

\Gamma  $ \Delta  d
$ \Delta , \Gamma  g
\Delta  $ \Gamma \Gamma ,? ncs-box
rp as xs \Delta  $ rp as xs \Gamma  d

$ rp as xs \Gamma , rp as xs \Delta  g
rp as xs \Gamma  $ rp as xs \Delta  j

xp as xy \Gamma  $ xp as xy \Delta  oe

4.2. Extensions du syste`me et re`gles de'rive'es 69
Boi^te ge'ne'rique Intuitivement, il est clair que lorsque la variable h n'est pas libre dans

A, la formule @h: rh 0s A exprime que << A est vraie apre`s l'exe'cution de n'importe quel pro-gramme >> -- plus pre'cise'ment : n'importe quel programme ne faisant re'fe'rence qu'aux adresses

alloue'es dans l'e'tat courant. De'sormais, on note l A la formule @h: rh 0s A et on appelle boi^tege'ne'rique la modalite'

l ainsi de'finie.

l A j @h: rh 0s A hRFVpAq
Cette modalite' de'note n'importe quel e'tat de la me'moire et peut donc e^tre vue commeune quantification universelle sur les stores (ce a` quoi elle correspond effectivement dans la
se'mantique). Nous pouvons de`s lors exprimer de manie`re e'le'gante des proprie'te's d'invariancevis-a`-vis de l'e'tat me'moire telles que :

@r: l r!r as xs rr :i !r \Gamma  1; !r as ys Ipy i x \Gamma  1q
Proposition 4.1.Les formules suivantes sont de'rivables dans MLDL.

l A N~ A (re'flexivite')
l A N~ rps A (instanciation)
l A N~ l l A (transitivite')

De'monstration :Re'flexivite' et Instanciation :

axA $ A
delr0s A $ A

*drp*x: xq 0s A $ A
@1g@h: rh 0s A $ A

N~ d$ p@h: rh 0s Aq N~ A

$ ax
rps A $ rps A *d

rp*_: pq 0s A $ rps A

@1g@h: rh 0s A $ rps A

N~ d$ p@h: rh 0s Aq N~ rps A

Transitivite' : on insiste seulement sur le fait que la preuve repose sur la re`gle d'isolation :
@h: rh 0 as xs A * @h: rh 0s @x: A (si h, f R FVpAq).

axrlet f2 i ph1 0q in h2 0s A $ rlet f2 i ph1 0q in h2 0s A
*drp*x: let f2 i ph1 0q in h2 0q 0s A $ rlet f2 i ph1 0q in h2 0s A

@1g@h: rh 0s A $ rlet f2 i ph1 0q in h2 0s A
let@h: rh 0s A $ rh1 0 as f2s rh2 0s A
isol@h: rh 0s A $ rh1 0s @h2: rh2 0s A

@1d@h: rh 0s A $ @h1: rh1 0s @h2: rh2 0s A

N~ d$ p@h: rh 0s Aq N~ @h1: rh1 0s @h2: rh2 0s A

oe

70 Chapitre 4 - Syntaxe et logique de MLDL

Corollaire 4.1.1.La formule

A O/ l l A ainsi que les re`gles de de'duction suivantes sont de'rivables dans MLDL.

\Gamma , A $ \Delta 
\Gamma , l A $ \Delta  refl-g

\Gamma  $ l A, \Delta 

\Gamma  $ A, \Delta  refl-d

\Gamma , rps A $ \Delta 

\Gamma , l A $ \Delta  inst-g

\Gamma  $ l A, \Delta 
\Gamma  $ rps A, \Delta  inst-d

La boi^te ge'ne'rique de'note n'importe quel e'tat me'moire accessible par l'e'tat courant,c'est-a`-dire que la relation d'accessibilite' associe'e n'est pas fonctionnelle. Elle n'est donc pas
distributive sur la disjonction. Par conse'quent, la re`gle de ne'cessitation ge'ne'rique est soumisea` la condition que le contexte droit soit restreint a` une formule exactement :

\Gamma  $ A
l \Gamma  $ l A

\Pi ncs

Proposition 4.2.La re`gle de ne'cessitation ge'ne'rique (

\Pi ncs) est de'rivable dans MLDL.

De'monstration :Soulignons simplement que la condition de bord correspond syntaxiquement a` la restriction sur les variables libres de la re`gle @1d (sinon, chaque instance de @1d introduirait unevariable frai^che : les boi^tes seraient donc impossibles a` e'liminer par ne'cessitation). On pose
\Gamma  i tA1, : : : , Anu :

A1, : : : , An $ A ncs-box
rh 0s A1, : : : , rh 0s An $ rh 0s A

@1grh 0s A1, : : : , @h: rh 0s A
n $ rh 0s A @1g

@h: rh 0s A1, : : : , @h: rh 0s An $ rh 0s Ah R FVpl \Gamma q

@1d@h: rh 0s A1, : : : , @h: rh 0s A
n $ @h: rh 0s A oe

Corollaire 4.2.1.Les formules

l pA ^ Bq O/ l A ^ l B et l pA N~ Bq N~ pl A N~ l Bq
ainsi que les re`gles de de'duction :

\Gamma , l A N~ l B $ \Delta 

\Gamma , l pA N~ Bq $ \Delta  distrG

\Gamma  $ l pA N~ Bq, \Delta 
\Gamma  $ l A N~ l B, \Delta  distrD

sont de'rivables dans MLDL.

4.2. Extensions du syste`me et re`gles de'rive'es 71
Logique classique
\Gamma , A $ \Delta  \Gamma 1, B $ \Delta 1

\Gamma , \Gamma 1, A . B $ \Delta , \Delta 1 .-g

\Gamma  $ A, B, \Delta 
\Gamma  $ A . B, \Delta  .-d

\Gamma  $ A, \Delta  \Gamma 1, B $ \Delta 1

\Gamma , \Gamma 1, A N~ B $ \Delta , \Delta 1 N~-g

\Gamma , A $ B, \Delta 
\Gamma  $ A N~ B, \Delta  N~-d

\Gamma , A $ B, \Delta  \Gamma 1, B $ A, \Delta 1

\Gamma , \Gamma 1 $ A O/ B, \Delta , \Delta 1 O/ d

xRFVp\Gamma ;\Delta q \Gamma , A $ \Delta \Gamma , Dx: A $ \Delta  D1-g \Gamma  $ r

v-xsA, \Delta 

\Gamma  $ Dx: A, \Delta  D

1-d

XRFVp\Gamma ;\Delta q \Gamma , A $ \Delta \Gamma , DX: A $ \Delta  D2-g \Gamma  $ r

B-X sA, \Delta 

\Gamma  $ DX: A, \Delta  D

2-d

Remplacement
\Gamma  $ rv-xsA, \Delta  \Gamma 1 $ Ipv i v1q, \Delta 1

\Gamma , \Gamma 1 $ rv

1-

xsA, \Delta , \Delta 1 replD

\Gamma , rv-xsA $ \Delta  \Gamma 1 $ Ipv i v1q, \Delta 1

\Gamma , \Gamma 1, rv

1-

xsA $ \Delta , \Delta 1 replG

Induction sur les entiers
$ Ap0q Natpnq, Apnq $ Apn \Gamma  1q

$ @n : Nat: Apnq ind

Ne'cessitation pour le diamant
\Gamma ,? \Gamma  $ \Delta xp as xy \Gamma  $ xp as xy \Delta  ncs-diam

Boi^te ge'ne'rique
\Gamma , A $ \Delta 
\Gamma , l A $ \Delta  refl-g

\Gamma  $ l A, \Delta 

\Gamma  $ A, \Delta  refl-d

\Gamma , rps A $ \Delta 

\Gamma , l A $ \Delta  inst-g

\Gamma  $ l A, \Delta 
\Gamma  $ rps A, \Delta  inst-d

\Gamma , l A N~ l B $ \Delta 

\Gamma , l pA N~ Bq $ \Delta  distrG

\Gamma  $ A
l \Gamma  $ l A

\Pi ncs \Gamma  $ l pA N~ Bq, \Delta \Gamma  $ l A N~ l B, \Delta  distrD

Figure 4.5 - Re`gles de'ductives de'rive'es

72 Chapitre 4 - Syntaxe et logique de MLDL

rlet y i p in p1 as xs A * rp as ys rp1 as xs A yRFVpA,xq pletq

rp ; p1 as xs A * rps rp1 as xs A pseqq

rCespref vq as xs A * *ff:tff :i vurCespffq as xs A ffRFNpA,vq pallocq
rCespv1 :i v2q as xs A * tv1 :i v2urCesp0q as xs A paffecq

tuurCesp!vq as xs A * tuurCesptuu!vq as xs A xRFVpuq preadq

xlet y i p in p1 as xy A * xp as yy xp1 as xy A yRFVpA,xq pletq

xp ; p1 as xy A * xpy xp1 as xy A pseqq

xCesppq as xy A * xp as yy xCespyq as xy A yRFVpA,Ces,xq psplitq

xref v as xy A * *ff:tff :i vurff-xsA ffRFNpA,vq pallocq
xv1 :i v2 as xy A * tv1 :i v2ur0-xsA paffecq

xv as xy A * rv-xsA pdelq
tuux!v as xy A * xtuu!v as xy tuuA xRFVpuq preadq

xif v then p1 else p2 as xy A * pIpvq N~ xp1 as xy Aq ^ pIpvq N~ xp2 as xy Aq pcasesq

xCespref vq as xy A * *ff:tff :i vuxCespffq as xy A ffRFNpA,vq pallocq
xCespv1 :i v2q as xy A * tv1 :i v2uxCesp0q as xy A paffecq

tuuxCesp!vq as xy A * tuuxCesptuu!vq as xy A xRFVpuq preadq

Figure 4.6 - Re`gles de congruence de'rive'es sur les formules
4:2:2 Macros et extension du noyau

Macros d'e'valuation symbolique Dans l'esprit d'automatisation et de simplificationdu syste`me, il est commode de de'finir les macros suivantes :

let-in rlet y i p in p1 as xs A * rp as ys rp1 as xs A y R FVpA, xq
se'quence rp ; p1 as xs A * rps rp1 as xs A

dont les de'rivations sont donne'es par :

rlet y i p in p1 as xs A j rp*y: p1q p as xs A

* rp as ys rp*y: p1q y as xs A yRFVpA,*y: p1,xq
* rp as ys rp1 as xs A yRFVpA,xq

rp ; p1 as xs A j rlet _ i p in p1 as xs A

* rp as _s rp1 as xs A

De me^me, les cre'ations de re'fe'rences, mises-a`-jour et lectures de la me'moire peuvent e^tretraite'es directement a` l'aide des re`gles de'rive'es ci-dessous qui combinent les re`gles alloc,

4.2. Extensions du syste`me et re`gles de'rive'es 73
affec et del avec la re`gle split :

Cre'ation :

rCespref vq as xs A * rref v as ys rCespyq as xs A

* *ff:tff :i vurCespffq as xs A

Mises-a`-jour :

rCespv1 :i v2q as xs A * rv1 :i v2 as ys rCespyq as xs A

* tv1 :i v2urCesp0q as xs A

Lecture :

tuurCesp!vq as xs A * tuur!v as ys rCespyq as xs A

* rtuu!v as ys tuurCespyq as xs A
* rtu ; uu!v as ys tuurCespyq as xs A
* rtuutuu!v as ys tuurCespyq as xs A
* tuurtuu!v as ys rCespyq as xs A
* tuurCesptuu!vq as xs A

Extension du noyau avec des e'quivalences de'rivables On introduit une se'rie dere`gles de congruence primitives qui se distinguent parce qu'elles correspondent a` des e'quivalences de'rivables dans le syste`me de'ductif de MLDL. Leur validite' est donc garantie sans pourautant qu'on ait a` la de'montrer se'mantiquement. (Techniquement, cela permet de re'duire la
liste, de'ja` longue, de cas de la preuve de la correction de la congruence, Proposition 7.7)
Proposition 4.3 (Ne'gation).Les formules suivantes sont de'rivables dans MLDL.

A O/ A pinvolq
*ff: A O/ *ff: A pneutrq

tuuA O/ tuuA _

De'monstration :La de'rivation de la premie`re formule est triviale (

d suivie de d). La justification se'-mantique des deux formules suivantes est que les updates et le

*lieur de'notent des fonctionstotales. Syntaxiquement, les de'rivations reposent sur les re`gles de ne'cessitation :

axA $ A

gA, A $

*-ncs*ff: A, *ff: A $

d*ff: A $ *ff: A

axA $ A

g$ A, A

*-ncs$ *ff: A, *ff: A

g*ff: A $ *ff: A

axA $ A

gA, A $ ncs-upd

tuuA, tuuA $ d
tuuA $ tuuA

axA $ A

g$ A, A ncs-upd

$ tuuA, tuuA g
tuuA $ tuuA oe

74 Chapitre 4 - Syntaxe et logique de MLDL

Proposition 4.4 (Propagation des modalite's).Les formules de distributivite' suivantes sont de'rivables dans MLDL :

*ff: A ^ *ff: B O/ *ff: pA ^ Bq

tuupA ^ Bq O/ tuuA ^ tuuB
rp as xs pA ^ Bq O/ rp as xs A ^ rp as xs B

xp as xy pA ^ Bq O/ xp as xy A ^ xp as xy B

*ff: A N~ *ff: B O/ *ff: pA N~ Bq

tuupA N~ Bq O/ tuuA N~ tuuB
rp as xs pA N~ Bq O/ rp as xs A N~ rp as xs B

xp as xy pA N~ Bq O/ xp as xy A N~ xp as xy B

*ff: A . *ff: B O/ *ff: pA . Bq

tuupA . Bq O/ tuuA . tuuB
rp as xs pA . Bq O/ rp as xs A . rp as xs B

xp as xy pA . Bq O/ xp as xy A . xp as xy B

De'monstration :Nous ne donnons que quelques de'rivations, toutes les autres e'tant similaires :

tuupA N~ Bq $ tuuA N~ tuuB :

axA $ A, B

gA, A $ B

N~ dA $ A N~ B

d$ A, A N~ B

inv$ A, A N~ B ncs-upd

$ tuuA, tuupA N~ Bq

axB, A $ B

N~ dB $ A N~ B ncs-upd

tuuB $ tuupA N~ Bq N~ g
tuuA N~ tuuB $ tuupA N~ Bq

*ff: pA ^ Bq $ *ff: A ^ *ff: B :

axA $ A wk-g
A, B $ A ^g
A ^ B $ A *-ncs
*ff: pA ^ Bq $ *ff: A

axB $ B wk-g
A, B $ B ^g
A ^ B $ B *-ncs
*ff: pA ^ Bq $ *ff: B ^d

*ff: pA ^ Bq, *ff: pA ^ Bq $ *ff: A ^ *ff: B ctr-g

*ff: pA ^ Bq $ *ff: A ^ *ff: B

rp as xs pA . Bq $ rp as xs A . rp as xs B :

axA $ A axB $ B

.gA . B $ A, B ncs-box

rp as xs pA . Bq $ rp as xs A, rp as xs B .d
rp as xs pA . Bq $ rp as xs A . rp as xs B

4.2. Extensions du syste`me et re`gles de'rive'es 75

oe
Par ailleurs nous avons montre' pre'ce'demment (Corollaires 4.2.1 et 4.1.1) que les formulesde la distributivite' sur la conjonction et la duplication de la boi^te ge'ne'rique :

l A O/ l l A ptransq
l pA ^ Bq O/ l A ^ l B pdistrq

e'taient de'rivables dans MLDL. Par conse'quent, on peut les inte'grer a` l'e'valuation symboliquede MLDL en tant que re`gles de congruence primitives, de me^me que toutes les autres e'quivalences qu'on a montre'es e^tre de'rivables. Toutes les re`gles suivantes sont des primitives del'e'valuation symbolique de MLDL :

Ne'gation
A * A pinvolq
*ff: A * *ff: A pneutrq

tuuA * tuuA

Propagation des modalite's
*ff: A ^ *ff: B * *ff: pA ^ Bq pdistrq

tuupA ^ Bq * tuuA ^ tuuB
rp as xs pA ^ Bq * rp as xs A ^ rp as xs B

xp as xy pA ^ Bq * xp as xy A ^ xp as xy B

*ff: A N~ *ff: B * *ff: pA N~ Bq

tuupA N~ Bq * tuuA N~ tuuB
rp as xs pA N~ Bq * rp as xs A N~ rp as xs B

xp as xy pA N~ Bq * xp as xy A N~ xp as xy B

*ff: A . *ff: B * *ff: pA . Bq

tuupA . Bq * tuuA . tuuB
rp as xs pA . Bq * rp as xs A . rp as xs B

xp as xy pA . Bq * xp as xy A . xp as xy B

Boi^te ge'ne'rique
l A * l l A ptransq
l pA ^ Bq * l A ^ l B pdistrq

Macros de'die'es au diamant Naturellement, un programme s'e'value symboliquementde la me^me manie`re qu'il soit a` l'inte'rieur d'une boi^te ou d'un diamant. Par conse'quent,

toutes les re`gles de congruence de'die'es a` la boi^te peuvent e^tre de'cline'es dans leur version

76 Chapitre 4 - Syntaxe et logique de MLDL

existentielle, y compris le raisonnement par cas et les macros pre'sente'es ci-dessus. Les re`gles :

xCesppq as xy A * xp as yy xCespyq as xy A yRFVpA,Ces,xq psplitq

xref v as xy A * *ff:tff :i vurff-xsA ffRFNpA,vq pallocq
xv1 :i v2 as xy A * tv1 :i v2ur0-xsA paffecq

xv as xy A * rv-xsA pdelq
tuux!v as xy A * xtuu!v as xy tuuA xRFVpuq preadq

xif v then p1 else p2 as xy A * pIpvq N~ xp1 as xy Aq ^ pIpvq N~ xp2 as xy Aq pcasesq

xCespref vq as xy A * *ff:tff :i vuxCespffq as xy A ffRFNpA,vq
xCespv1 :i v2q as xy A * tv1 :i v2uxCesp0q as xy A

tuuxCesp!vq as xy A * tuuxCesptuu!vq as xy A xRFVpuq

sont des macros de MLDL. Nous donnons quelques unes des simulations, les autres e'tant sim-ilaires. Remarquons simplement qu'elles utilisent les primitives que nous venons d'introduire
au paragraphe pre'ce'dent :

xCesppq as xy A j rCesppq as xs A

* rp as ys rCespyq as xs A yRFVpA,Ces,xq
* rp as ys rCespyq as xs A
j xp as yy xCespyq as xy A

xref v as xy A j rref v as xs A

* *ff: tff :i vurff-xsA
* *ff: tff :i vurff-xsA
j *ff: tff :i vurff-xsA
* *ff: tff :i vurff-xsA

4:3 Exemples de preuves et modules de'die's

Les exemples qui suivent illustrent la manie`re de traiter le partage de me'moire (Sec-tion 4.3.1), la modularite' (Sections 4.3.4 et 4.3.5), l'induction sur les donne'es, la boi^te
ge'ne'rique. On de'finira aussi des modules de'die's au raisonnement arithme'tique et aux donne'espures (Section 4.3.3). Nous verrons aussi un exemple de proprie'te' que MLDL ne permet pas de
prouver et qui est lie' a` la localite' des de'clarations (Section 4.3.4). Le dernier exemple illustrecependant le pouvoir d'expression de la boi^te ge'ne'rique, qui permet de ne pas faire de'pendre
les spe'cifications de l'e'tat courant de la me'moire (Section 4.3.5).

4:3:1 Partage de me'moire

Les exemples qui suivent illustrent la manie`re dont le partage de me'moire est ge're' dansMLDL gra^ce aux adresses abstraites. Le premier est l'exemple standard qui consiste a` modifier

le contenu d'une adresse via un de ses pointeurs et de ve'rifier le re'sultat via un autre de sespointeurs :

4.3. Exemples de preuves et modules de'die's 77
spe'cification : @m, n: rp as zs Ipz i nq ou` p j plet x i pref mq in plet y i x in y :i n ; !xqq

ax$ J

*d$ Ip1q

*d$ Ipn i nq

*d (del)$ rn as zs Ipz i nq

*d (read +upd)$ tff :i nur!ff as zs Ipz i nq
*d (affec)$ rff :i n ; !ff as zs Ipz i nq

*d$ rlet x i ff in let y i x in y :i n ; !x as zs Ipz i nq
ncs-upd$ tff :i murlet x i ff in let y i x in y :i n ; !x as zs Ipz i nq
*-ncs$ *ff: tff :i murlet x i ff in let y i x in y :i n ; !x as zs Ipz i nq

*d (alloc)$ rlet x i pref mq in let y i x in y :i n ; !x as zs Ipz i nq
@1d$ @m, n: rlet x i pref mq in let y i x in y :i n ; !x as zs Ipz i nq

Le second exemple est emprunte' a` l'article [YHB07] de Yoshida, Honda et Berger danslequel la fonction Inc, qui incre'mente le contenu d'une adresse locale, est appele'e deux fois
via des pointeurs diffe'rents.
spe'cification : @n: rIncSharedn as ys Ipy i 2n \Gamma  3q ou`

Incn j let x i pref nq in *_: x :i !x \Gamma  1 ; !xIncShared

n j pa :i Incnq ; pb :i !aq ; pz1 :i p!aq0q ; pz2 :i p!bq0q ; p!z1 \Gamma  z2q

ax$ J

*d (*)$ rIncShared
n as ys Ipy i n \Gamma  3q @1d

$ @n: rIncSharedn as ys Ipy i n \Gamma  3q

rIncSharedn as ys Ipy i n \Gamma  3q p\Sigma q

* ra :i Incns rb :i !as rz1 :i p!aq0s rz2 :i p!bq0s r!z1\Gamma !z2 as ys Ipy i 2n \Gamma  3q
* *ff: tff :i nura :i *_: pff :i !ff \Gamma  1 ; !ffqs rb :i !as : : :
* *ff: tff :i n ; a :i *_: pff :i !ff \Gamma  1 ; !ffqurb :i !as : : :
* *ff: tff :i n ; a :i *_: pff :i !ff \Gamma  1 ; !ffqurb :i *_: pff :i !ff \Gamma  1 ; !ffqs : : :
* *ff: tff :i n ; a :i *_: p: : :q ; b :i *_: p: : :qurz1 :i p!aq0s : : :
* *ff: tff :i n ; b :i *_: p: : :qurz1 :i p*_: p: : :qq0s : : :
* *ff: tff :i n ; b :i *_: p: : :qurz1 :i pff :i !ff \Gamma  1 ; !ffqs : : :
* *ff: tff :i n ; b :i *_: p: : :qurz1 :i pff :i n \Gamma  1 ; !ffqs : : :
* *ff: tff :i n \Gamma  1 ; b :i *_: p: : :qurz1 :i !ffs : : :
* *ff: tff :i n \Gamma  1 ; b :i *_: p: : :qurz1 :i n \Gamma  1s : : :
* *ff: tff :i n \Gamma  1 ; b :i *_: p: : :q ; z1 :i n \Gamma  1urz2 :i p!bq0s : : :
* *ff: tff :i n \Gamma  1 ; z1 :i n \Gamma  1urz2 :i pff :i !ff \Gamma  1 ; !ffqs : : :
* *ff: tff :i n \Gamma  1 ; z1 :i n \Gamma  1urz2 :i pff :i n \Gamma  2 ; !ffqs : : :
* *ff: tff :i n \Gamma  2 ; z1 :i n \Gamma  1urz2 :i !ffs : : :
* *ff: tz1 :i n \Gamma  1 ; z2 :i n \Gamma  2ur!z1\Gamma !z2 as ys Ipy i 2n \Gamma  3q
* *ff: rn \Gamma  1 \Gamma  n \Gamma  2 as ys Ipy i 2n \Gamma  3q
* *ff: Ipp2n \Gamma  3q i p2n \Gamma  3qq
* J

78 Chapitre 4 - Syntaxe et logique de MLDL

4:3:2 E'tat me'moire hypothe'tique

Le syste`me permet de raisonner sur des programmes avec effets de bord sans pour autantavoir a` modifier re'ellement l'e'tat courant. Les preuves peuvent e^tre plus longues qu'en raisonnant directement, mais cela peut se re've'ler avantageux si l'on veut conserver l'e'tat courantde la me'moire. Cette technique de preuve sur le mode conditionnel repose entie`rement sur la
re`gle de ne'cessitation. Nous l'illustrons avec l'exemple trivial de la correction de l'affectation.

spe'cification : @x, n: pr!x as ys Ipy i nq N~ rx :i !x \Gamma  1 ; !x as zs Ipz i n \Gamma  1qq

ax$ J
wk-gIpy i nq $ J

*dIpy i nq $ Ipn \Gamma  1 i n \Gamma  1q
replIpy i nq $ Ipy \Gamma  1 i n \Gamma  1q

*dIpy i nq $ tx :i y \Gamma  1ur!x as zs Ipz i n \Gamma  1q
*dIpy i nq $ rx :i y \Gamma  1 ; !x as zs Ipz i n \Gamma  1q

ncs-boxr!x as ys Ipy i nq $ r!x as ys rx :i y \Gamma  1 ; !x as zs Ipz i n \Gamma  1q
splitr!x as ys Ipy i nq $ rx :i !x \Gamma  1 ; !x as zs Ipz i n \Gamma  1q

N~ d$ r!x as ys Ipy i nq N~ rx :i !x \Gamma  1 ; !x as zs Ipz i n \Gamma  1q

@1d$ @x, n: pr!x as ys Ipy i nq N~ rx :i !x \Gamma  1 ; !x as zs Ipz i n \Gamma  1qq

4:3:3 Modules de'die's

La question de de'finir un syste`me de type dans MLDL soule`ve, nous l'avons dit, un grandnombre de difficulte's non re'solues pour le moment. Ne'anmoins, il est possible de de'finir des
pre'dicats correspondant intuitivement a` certains types de donne'es et de les utiliser ponctuelle-ment dans les preuves. C'est ce que nous faisons ci-dessous en pre'sentant brie`vement deux
exemples d'extensions du syste`me qui permettent de raisonner sur les entiers naturels et surles donne'es pures.

Arithme'tique Il est possible de de'finir dans MLDL un pre'dicat de'finissant les entiersnaturels. Nous raisonnerons donc sur les entiers naturels a` l'aide du pre'dicat Nat de'fini de

manie`re standard (voir [Kri93]) par :

Natpxq j @X: ppXp0q ^ @y: pXpyq N~ Xpy \Gamma  1qqq N~ Xpxqq
Nous utiliserons e'galement la quantification borne'e @x : Nat: Apxq (notation alle'ge'e de laformule

@x: pNatpxq N~ Apxqq) ainsi que la re`gle d'induction associe'e :

$ Ap0q Natpnq, Apnq $ Apn \Gamma  1q

$ @n : Nat: Apnq ind

Proposition 4.5.La re`gle ind est de'rivable dans MLDL.

4.3. Exemples de preuves et modules de'die's 79
De'monstration :On montre dans un premier temps que le successeur d'un entier naturel est e'galement
un entier naturel : Natpnq $ Natpn \Gamma  1q. On note ANatpxq la formule Natpxq ^ Apxq.

axXpnq $ Xpnq axXpn \Gamma  1q $ Xpn \Gamma  1q

N~ gXpnq, Xpnq N~ Xpn \Gamma  1q $ Xpn \Gamma  1q
@1gXpnq, @y: pXpyq N~ Xpy \Gamma  1qq $ Xpn \Gamma  1q

axXp0q ^ @y: pXpyq N~ Xpy \Gamma  1qq $ Xp0q ^ @y: pXpyq N~ Xpy \Gamma  1qq

...
...
...

N~ gpXp0q ^ @y: pXpyq N~ Xpy\Gamma 1qqq N~ Xpnq, Xp0q, @y: pXpyq N~ Xpy \Gamma 1qq $ Xpn \Gamma  1q
@2gNatpnq, Xp0q, @y: pXpyq N~ Xpy \Gamma 1qq $ Xpn\Gamma 1q

N~@Natpnq $ Natpn\Gamma 1q

$ Natp0q ^ Ap0q

Natpnq, Apnq $ Apn \Gamma  1q Natpnq $ Natpn \Gamma  1q ^d

gANatpnq $ ANatpn \Gamma  1q

N~ d$ ANatpnq N~ ANatpn \Gamma  1q

@1d$ @y: pANatpnq N~ ANatpn \Gamma  1q
^d$ ANatp0q ^ @y: pANatpnq N~ ANatpn \Gamma  1qq

...

...
...

axApnq $ Apnq
wk-g,^gANatpnq $ Apnq

N~ gpANatp0q ^ @y: pANatpnq N~ ANatpn \Gamma  1qqq N~ ANatpnq $ Apnq
@2gNatpnq $ Apnq

N~ d$ Natpnq N~ Apnq

@1d$ @n : Nat: Apnq

oeLe pre'dicat Nat et la re`gle d'induction associe'e sont donc tous deux de'finissables dans
MLDL. En revanche, il est ne'cessaire (pour faire des preuves un tant soit peu inte'ressantes)d'ajouter quelques uns des axiomes de Peano :

(AP3) @x : Nat: px \Gamma  1 , 0q
(AP4) @x, y : Nat: ppx \Gamma  1 i y \Gamma  1q N~ px i yqq

Les deux premiers axiomes de Peano sont de'rivables au second ordre, tandis que le cinquie`mecorrespond pre'cise'ment au pre'dicat Nat. Il sera e'galement ne'cessaire de se donner quelques

axiomes relatifs aux fonctions arithme'tiques de'note'es par les primitives de MLimp :

1. @x, y, z: pIpx i yq N~ Ipx \Gamma  z i y \Gamma  zqq (Fonctionnalite' +)
2. @x, y, z: pIpx i yq N~ Ipx \Delta  z i y \Delta  zqq (Fonctionnalite' -)
3. @x, y, z: pIpx i yq N~ Ipx \Theta  z i y \Theta  zqq (Fonctionnalite' \Theta )
4. @x, y, z: pIpx \Gamma  z i y \Gamma  zq N~ Ipx i yqq (Injectivite' +)

80 Chapitre 4 - Syntaxe et logique de MLDL

5. @x, y, z: pIpx \Delta  z i y \Delta  zq N~ Ipx i yqq (Injectivite' -)Dans les preuves qui figurent dans les dernie`res sections de ce chapitre, on travaillera
toujours dans ce module de'die' a` l'arithme'tique. (Ce module est re'capitule' dans la Figure 4.7,p. 80)

Pre'dicat (de'finissable dans MLDL)

Natpxq j @X: ppXp0q ^ @y: pXpyq N~ Xpy \Gamma  1qqq N~ Xpxqq
Re`gle d'induction sur les entiers (de'rivable dans MLDL)

$ Ap0q Natpnq, Apnq $ Apn \Gamma  1q

$ @n : Nat: Apnq ind

Axiomes

1. @x : Nat: px \Gamma  1 , 0q (AP3)
2. @x, y : Nat: ppx \Gamma  1 i y \Gamma  1q N~ px i yqq (AP4)
3. @x, y, z: pIpx i yq N~ Ipx \Gamma  z i y \Gamma  zqq (Fonctionnalite' +)
4. @x, y, z: pIpx i yq N~ Ipx \Delta  z i y \Delta  zqq (Fonctionnalite' -)
5. @x, y, z: pIpx i yq N~ Ipx \Theta  z i y \Theta  zqq (Fonctionnalite' \Theta )
6. @x, y, z: pIpx \Gamma  z i y \Gamma  zq N~ Ipx i yqq (Injectivite' +)
7. @x, y, z: pIpx \Delta  z i y \Delta  zq N~ Ipx i yqq (Injectivite' -)

Figure 4.7 - Module de'die' a` l'arithme'tique

Donne'es pures Pour de'finir les donne'es pures, on se donne un pre'dicat Locp:q carac-te'risant les adresses me'moire, ainsi que l'ensemble LOC des axiomes de'finissant l'extension

du pre'dicat et la re'flexivite' du test d'e'galite' sur les adresses.LOC :

$ Locpffq $ Locpnq $ Locppv, v1qq $ Locp*x: pq

$ @x: pLocpxq N~ Ipx i xqq
On peut alors de'finir le pre'dicat unaire Datap:q repre'sentant les donne'es pures ainsi quela re`gle d'induction associe'e -- on s'autorisera abusivement a` l'utiliser sur plusieurs termes,

par exemple Datapx, yq :

Datapxq j @X: \Gamma  p X0

^ @y, z: pXy ^ Xz N~ Xpy \Gamma  1q ^ Xpy \Delta  1q ^ Xppy, zqqq
^ @y: pLocpyq N~ Xyq q
N~ Xx\Phi 

$ Ap0qData
py, zq, Apyq, Apzq $ Apy \Gamma  1q ^ Apy \Delta  1q ^ Appy, zqq Datapyq, Locpyq $ Apyq

$ @x : Data: Apxq ind

4.3. Exemples de preuves et modules de'die's 81
Pre'dicats

Locp:q donne'Data

pxq j @X: \Gamma  p X0

^ @y, z: pXy ^ Xz N~ Xpy \Gamma  1q ^ Xpy \Delta  1q ^ Xppy, zqqq
^ @y: pLocpyq N~ Xyq q
N~ Xx\Phi 

Axiomes

1. $ Locpffq
2. $ Locpnq
3. $ Locppv, v1qq
4. $ Locp*x: pq
5. $ @x: pLocpxq N~ Ipx i xqq

Re`gle d'induction sur les donne'es pures (de'rivable dans MLDL \Gamma  LOC)

$ Ap0q Datapy, zq, Apyq, Apzq $ Apy \Gamma  1q ^ Apy \Delta  1q ^ Appy, zqqData

pyq, Locpyq $ Apyq

$ @x : Data: Apxq ind

Figure 4.8 - Module de'die' aux donne'es pures

Proposition 4.6 (Induction sur les donne'es pures).La re`gle d'induction sur les donne'es pures est de'rivable dans MLDL

\Gamma  LOC.

De'monstration :La preuve est semblable a` celle de la re`gle d'induction sur les entiers. oe

On a vu que le test d'e'galite' et l'e'galite' de Leibniz ne sont pas e'quivalents. Ils le sonttoutefois sur les donne'es pures. C'est l'objet de la proposition suivante :
Proposition 4.7 (E'galite' et remplacement sur les donne'es pures).Les deux se'quents suivants sont de'rivables dans MLDL

\Gamma  LOC :

$ @x : Data: Ipx i xq $ @x, y : Data: p@X: pXx N~ Xyq N~ Ipx i yqq
De'monstration :On montre le premier se'quent gra^ce a` la re`gle d'induction sur les donne'es pures. La
pre'misse Datapyq, Locpyq $ Ipy i yq est une conse'quence directe des axiomes de LOC. Lepas inductif se montre a` l'aide de la re`gle

^d et des trois se'quents :- Data
py, zq, Ipy i yq, Ipz i zq $ Ipy \Gamma  1 i y \Gamma  1q- Data
py, zq, Ipy i yq, Ipz i zq $ Ipy \Delta  1 i y \Delta  1q- Data
py, zq, Ipy i yq, Ipz i zq $ Ippy, zq i py, zqqLes deux premiers sont des instances des axiomes de fonctionnalite' de l'addition et de la

soustraction. On donne ci-dessous une de'rivation du troisie`me se'quent :

82 Chapitre 4 - Syntaxe et logique de MLDL

axIpy i yq $ Ipy i yq axIpz i zq $ Ipz i zq

^dIpy i yq, Ipz i zq $ Ipy i yq ^ Ipz i zq
wk-dDatapy, zq, Ipy i yq, Ipz i zq $ Ipy i yq ^ Ipz i zq

inj^Datapy, zq, Ipy i yq, Ipz i zq $ Ippy i yq \Theta  pz i zqq
*Datapy, zq, Ipy i yq, Ipz i zq $ Ippy, zq i py, zqq

La re'flexivite' du test d'e'galite' sur les donne'es pures peut e^tre utilise'e pour donner unede'rivation du se'quent exprimant l'e'quivalence entre les deux e'galite's sur les donne'es pures :

Datapx, yq $ Ipx i xq axIpx i yq $ Ipx i yq N~ gData

px, yq, Ipx i xq N~ Ipx i yq $ Ipx i yq

@2gDatapx, yq, x i
Lz y $ Ipx i yq N~ dData

px, yq $ px iLz y N~ Ipx i yqq N~ d

$ Datapx, yq N~ px iLz y N~ Ipx i yqq

@1d$ @x, y : Data: px i
Lz y N~ Ipx i yqq oe

4:3:4 Limite du syste`me : de'clarations locales

L'exemple suivant est e'galement tire' de [YHB07]. La proce'dure MemFact retourne lafactorielle d'un entier passe' en argument, en optimisant les calculs : le stockage du re'sultat

dans une adresse de'clare'e localement (me'moi"sation) permet de ne pas effectuer le me^mecalcul deux fois de suite. La preuve suivante consiste a` montrer, par induction, que pour tout
entier naturel passe' en argument, le programme MemFact calcule bien le me^me re'sultat quela fonction factorielle :

Fact j fix p*F, n: if n i 0 then 1 else n \Theta  pF pn \Delta  1qqqMemFact

j let pa, bq i pref 0, ref 1q in

*x: if x i!a then !b else pa :i x ; b :i pFact xq ; !bq

spe'cification de Fact : les deux premie`res formules (ci-dessous) correspondent auxe'tapes re'cursives de l'e'valuation symbolique de la fonction Fact. La dernie`re e'tablit que le
calcul effectue' par Fact est insensible aux modifications de la me'moire.

@X: prFact 0 as xs X O/ Xq p1q
@X: @n : Nat: prFact pn \Gamma  1q as xs X O/ rFact n as ms rpn\Gamma 1q\Theta m as xs Xq p2q
@n : Nat: @X, x, y: prFact n as ms tx :i yuX O/ tx :i yurFact n as ms Xq p3q

(1) : ax

X $ X *g (del)
r1s X $ X *g

rFact 0s X $ X

axX $ X

*d (del)X $ r1s X

*dX $ rFact 0s X
O/ d$ rFact 0s X O/ X
@2d$ @X: prFact 0s X O/ Xq

4.3. Exemples de preuves et modules de'die's 83
(2) : on raisonne par cas (cases) en utilisant l'axiome : @n : Nat: n \Gamma  1 , 0 d'ou` l'onde'rive

S,0 : Natpnq $ Ipn \Gamma  1q , 0. Par la suite, on cessera d'expliciter le pre'dicatd'injection et on notera simplement

n \Gamma  1 , 0 ou n \Gamma  1 i 0. La de'rivation est de'coupe'een trois morceaux : un premier morceau correspond a` la de'rivation du se'quent

S1 :Nat
pnq, rFact pn \Gamma  1q as xs X $ rpFact nq \Theta  n as xs X ; le deuxie`me, au se'quent S2 :
n \Gamma  1 , 0, rpFact nq \Theta  n as xs X $ rFact pn \Gamma  1q as xs X ; le dernier correspond a` laspe'cification (2). Par ailleurs, on pose

m i n \Gamma  1.

S,0 axrpFact nq \Theta  m as xs X $ rpFact nq \Theta  m as xs X N~ gNat
pnq, pm , 0q N~ rpFact nq \Theta  m as xs X $ rpFact nq \Theta  m as xs X cases,wkNat
pnq, rif pm i 0q then 1 else pFact nq \Theta  m as xs X $ rpFact nq \Theta  m as xs X *g

S1 : Natpnq, rFact m as xs X $ rpFact nq \Theta  m as xs X

S,0,wkNatpnq $ m , 0, X
gNatpnq, m i 0 $ X

N~ dNatpnq $ pm i 0q N~ X.

..
...

...

axrpFact nq \Theta  m as xs X $ rpFact nq \Theta  m as xs X

N~ d,wkrpFact nq \Theta  m as xs X $ m , 0 N~ rpFact nq \Theta  m as xs X

cases,^dNatpnq, rpFact nq \Theta  m as xs X $ rif m i 0 then 1 else pFact nq \Theta  m as xs X
*dS2 : Natpnq, rpFact nq \Theta  m as xs X $ rFact m as xs X

S1 S2 O/ dNat
pnq $ rFact m as xs X O/ rpFact nq \Theta  m as xs X N~ d

$ Natpnq N~ prFact m as xs X O/ rpFact nq \Theta  m as xs Xq

@1d$ @n : Nat: prFact m as xs X O/ rpFact nq \Theta  m as xs Xq

@2d$ @X: @n : Nat: prFact m as xs X O/ rpFact nq \Theta  m as xs Xq

*d$ @X: @n : Nat: prFact m as xs X O/ rFact n as ms rm \Theta  n as xs Xq

(3) : on raisonne par induction sur l'entier naturel n. La de'rivation est de'coupe'e autour dela re`gle d'induction. Puisque

tx :i yuX * X, la formule a` prouver est donc congruentea`
@n : Nat: @X: prFact n as ms X O/ tx :i yurFact n as ms Xq et l'hypothe`se d'inductionest donne'e par

Hpnq : Natpnq ^ @X: prFact n as ms X O/ tx :i yurFact n as ms Xq.La variable de relation

X peut alors e^tre instancie'e par la formule Xm\Theta pn\Gamma 1q : rm \Theta 
pn \Gamma 1q as zs X, pour obtenir l'hypothe`se Hm\Theta pn\Gamma 1q : rFact n as ms Xm\Theta pn\Gamma 1q O/ tx :i
yurFact n as ms Xm\Theta pn\Gamma 1q.

Remarque 4.3.1. La formule rFact n as ms X O/ tx :i yurFact n as ms X est e'quivalentemodulo

ff-renommage a` la formule rFact n as zs X O/ tx :i yurFact n as zs X ou` lere'sultat renvoye' n'est plus nomme'

m mais z.

84 Chapitre 4 - Syntaxe et logique de MLDL

axX $ X

N~ d$ X N~ X

@2d$ @X: pX N~ Xq

*d$ @X: pX N~ tx :i yuXq

(1)$ Hp0q : @X: prFact 0s X N~ tx :i yurFact 0s Xq

axH
m\Theta pn\Gamma 1q $ rFact n as ms Xm\Theta pn\Gamma 1q O/ tx :i yurFact n as ms Xm\Theta pn\Gamma 1q @2g

Hpnq $ rFact n as ms Xm\Theta pn\Gamma 1q O/ tx :i yurFact n as ms Xm\Theta pn\Gamma 1q (2)

Hpnq $ rFact pn\Gamma 1q as zs X O/ tx :i yurFact pn\Gamma 1q as zs X

@2dHpnq $ Hpn\Gamma 1q : @X: prFact pn\Gamma 1q as zs X O/ tx :i yurFact pn\Gamma 1q as zs Xq

$ Hp0q Hpnq $ Hpn\Gamma 1q ind
$ @n : Nat: @X: prFact n as ms X O/ tx :i yurFact n as ms Xq *d
$ @n : Nat: @X: prFact n as ms tx :i yuX O/ tx :i yurFact n as ms Xq

spe'cification de MemFact : la spe'cification de MemFact e'tablit que pour tout entiernaturel passe' en argument, elle calcule le me^me re'sultat que la fonction Fact :

@n : Nat: rpMemFact nq i pFact nq as bs Ipbq
Encore une fois, la preuve se fait par induction sur les entiers naturels et la de'rivation estpre'sente'e en deux parties : le cas de base, le pas inductif. On notera les fonctions MemFact
et Fact respectivement M et F. Dans un premier temps, on effectue l'e'valuation symboliquede MemFact

pn \Gamma  1q avec l'hypothe`se que p\Sigma q : pn \Gamma  1q , 0.

pflq : rMpn \Gamma  1q i Fpn \Gamma  1q as bs Ipbq

* *ff, fi: tff :i 0 ; fi :i 1urCifpn\Gamma 1 i 0q i Fpn\Gamma 1q as bs Ipbq pallocq
* *ff, fi: tff :i 0 ; fi :i 1urCpff :i n\Gamma 1q i Fpn\Gamma 1q as bs Ipbq pcases \Sigma q
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urCpfi :i Fpn\Gamma 1qq i Fpn\Gamma 1q as bs Ipbq paffecq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs rCpfi :i xq i Fpn\Gamma 1q as bs Ipbq psplitq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs tfi :i xur!fi i Fpn\Gamma 1q as bs Ipbq paffecq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs tfi :i xurx i Fpn\Gamma 1q as bs Ipbq preadq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs tfi :i xurFpn\Gamma 1q as ys rx i y as bs Ipbq psplitq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs rFpn\Gamma 1q as ys tfi :i xurx i y as bs Ipbq p3q
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q as xs rFpn\Gamma 1q as ys rx i y as bs Ipbq preadq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1urFpn\Gamma 1q i Fpn\Gamma 1q as bs Ipbq psplitq
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1ur1 as bs Ipbq p*q
* *ff, fi: tff :i n\Gamma 1 ; fi :i 1uIp1q pdelq
* *ff, fi: Ip1q pupdq
* Ip1q p*ruleq

4.3. Exemples de preuves et modules de'die's 85
ax$ J

*d$ Ip1q

*d (del)$ r1 as bs Ipbq

*d$ r1 i 1 as bs Ipbq

ncs-upd$ tff :i 0 ; fi :i 1ur1 i 1 as bs Ipbq

*d (read)$ tff :i 0 ; fi :i 1ur!fi i 1 as bs Ipbq

*-ncs$ *ff, fi: tff :i 0 ; fi :i 1ur!fi i 1 as bs Ipbq
*d (alloc)$ rpM 0q i pF 0q as bs Ipbq.

..
...

...
...

Natpnq $ pn\Gamma 1q , 0

ax$ Ip0q
wk-gpn\Gamma 1q , 0 $ Ip1q

(fl)pn\Gamma 1q , 0 $ rMpn\Gamma 1q i Fpn\Gamma 1q as bs Ipbq
cutNatpnq $ rMpn\Gamma 1q i Fpn\Gamma 1q as bs Ipbq
wk-gNatpnq, rpM nq i pF nq as bs Ipbq $ rMpn\Gamma 1q i Fpn\Gamma 1q as bs Ipbq
ind$ @n : Nat: rpM nq i pF nq as bs Ipbq

Limite du syste`me La limite consiste a` traiter les variables a et b comme si elles e'taientde'clare'es globalement. Dans la spe'cification qui vient d'e^tre prouve'e, la fonction MemFact est
de'clare'e (ses re'fe'rences locales sont cre'e'es et initialise'es) juste avant d'e^tre applique'e. Parconse'quent, le contenu des re'fe'rences est toujours le me^me au moment de l'appel. Cette
spe'cification ne dit rien du cas ou` un autre programme est exe'cute' entre la de'claration etl'appel a` MemFact. Le fait que MemFact calcule la factorielle d'un entier, et ce, quel que soit
les programmes qui ont e'te' exe'cute's depuis sa de'claration, est exprime' par la proprie'te'

rMemFact as Ms rFact as Fs l @n : Nat: rpM nq i pF nq as bs Ipbq
qui n'est pas vraie dans MLDL car les autres programmes peuvent potentiellement modifier lesre'fe'rences locales de MemFact. En effet, en instanciant la boi^te ge'ne'rique par le programme
(ff :i 0 ; fi :i 7) ou` ff et fi ont e'te' cre'e'es par MemFact, on obtient une formule clairementfausse :

*ff, fi: tff :i 0 ; fi :i 7u@n : Nat: rpM nq i pF nq as bs Ipbq
puisque dans ce cas pM 0q * 7, tandis que pF 0q * 1. Ceci est du^ au fait que dans MLDL, lesde'clarations locales sont traite'es comme des de'clarations globales et que toutes les adresses

alloue'es sont visibles et modifiables.

Modularite' Cet exemple illustre le fait que MLDL permet de moduler les preuves. Ici,la spe'cification de MemFact et celle de Fact sont dissocie'es. La spe'cification de Fact peut
e^tre utilise'e dans un autre contexte de preuve. Cette modularite' apparai^t e'galement dansl'exemple de la section suivante.

4:3:5 Boi^te ge'ne'rique

Nous commenc,ons par les de'rivations des deux formules donne'es en exemples a` la Sec-tion 4.2.1. Les proprie'te's spe'cifiques de la boi^te ge'ne'rique n'interviennent pas explicitement

86 Chapitre 4 - Syntaxe et logique de MLDL

dans ces de'rivations. Seule la ne'cessitation est invoque'e :

A : @r, n: l tr :i nurr :i !r \Gamma  1 ; !r as xs Ipx i n \Gamma  1q

B : @r: l r!r as xs rr :i !r \Gamma  1; !r as ys Ipy i x \Gamma  1q

A :

ax$ J

*d$ Ipn \Gamma  1 i n \Gamma  1q

del$ rn \Gamma  1 as xs Ipx i n \Gamma  1q

ncs-upd$ tr :i n \Gamma  1urn \Gamma  1 as xs Ipx i n \Gamma  1q
read$ tr :i n \Gamma  1ur!r as xs Ipx i n \Gamma  1q

affec$ tr :i nurr :i n \Gamma  1 ; !r as xs Ipx i n \Gamma  1q

read$ tr :i nurr :i !r \Gamma  1 ; !r as xs Ipx i n \Gamma  1q

\Pi ncs$ l tr :i nurr :i !r \Gamma  1 ; !r as xs Ipx i n \Gamma  1q

@1d$ @r, n: l tr :i nurr :i !r \Gamma  1 ; !r as xs Ipx i n \Gamma  1q

B :

ax$ J

*d$ Ip1q

del$ r1 as bs Ipbq

*d$ r!r \Gamma  1 i!r \Gamma  1 as bs Ipbq

split$ r!r as xs r!r \Gamma  1 i x \Gamma  1 as bs Ipbq

split$ r!r as xs r!r as zs rz \Gamma  1 i x \Gamma  1 as bs Ipbq
del$ r!r as xs r!r as zs Ipz \Gamma  1 i x \Gamma  1q

upd$ r!r as xs r!r as zs tr :i z \Gamma  1uIpz \Gamma  1 i x \Gamma  1q

del$ r!r as xs r!r as zs tr :i z \Gamma  1urz \Gamma  1 as ys Ipy i x \Gamma  1q
read$ r!r as xs r!r as zs tr :i z \Gamma  1ur!r as ys Ipy i x \Gamma  1q
affec$ r!r as xs r!r as zs rr :i z \Gamma  1 ; !r as ys Ipy i x \Gamma  1q
split (z frais)$ r!r as xs rr :i !r \Gamma  1 ; !r as ys Ipy i x \Gamma  1q
\Pi ncs$ l r!r as xs rr :i !r \Gamma  1 ; !r as ys Ipy i x \Gamma  1q

@1d$ @r: l r!r as xs rr :i !r \Gamma  1 ; !r as ys Ipy i x \Gamma  1q

Le dernier exemple illustre mieux l'usage qui peut e^tre fait de la boi^te ge'ne'rique car ilexploite pleinement ses proprie'te's, notamment l'instanciation et la duplication. Ici, la pre'sence
de la boi^te ge'ne'rique est rendue ne'cessaire car elle permet de renforcer la spe'cification prouve'e,qui reste ainsi vraie apre`s l'exe'cution de n'importe quel programme. L'hypothe`se d'induction
pourra ainsi e^tre applique'e dans diffe'rents contextes calculatoires. L'exemple est construitavec deux fonctions : iter est une fonction sans effet de bord qui prend en argument un entier
n, une fonction f et un argument a, et exe'cute n fois le programme (f a) ; incr est une simplefonction d'incre'mentation de la re'fe'rence passe'e en argument.

iter j fix p*F:f:a:n: if n i 0 then 0 else pf a ; F f a nqqincr

j *x: px :i !x \Gamma  1; !xq

4.3. Exemples de preuves et modules de'die's 87
Spe'cification de iter : Dans un premier temps, on spe'cifie la fonction iter en utilisantprincipalement la congruence du syste`me. Soit

X une variable de relation et f, a des variablesd'individus. Alors :

riter incr f a 0s X * r0s X * X
riter incr f a pn \Gamma  1qs X * rf a ; iter incr f a ns X

* rf as riter incr f a ns X

Par conse'quent, on peut donner des de'rivations des spe'cifications suivantes (les deuxpreuves sont identiques) :

@X: @f, a: riter f a 0s X O/ X p1q
@X: @f, a, n: riter f a pn \Gamma  1qs X O/ rf as riter f a ns X p2q

$ X O/ X *d
$ riter f a 0s X O/ X @2d,@1d

$ @X: @f, a: priter f a 0s X O/ Xq

Utilisation de la spe'cification de iter : La spe'cification de iter peut e^tre utilise'epour montrer qu'apre`s l'exe'cution de n'importe quel programme, l'ite'ration de la fonction
d'incre'mentation sur une re'fe'rence quelconque a bien pour effet d'augmenter d'autant lecontenu de cette re'fe'rence. On donne ci-dessous une preuve inductive de la formule

P ci-dessous, ou` l'e'criture !
r i v est une notation raccourcie pour la formule r!r as xs x i v.

P : @n : Nat, r, k: l p!r i k N~ riter incr r ns !r i k \Gamma  nq
Cas de base

ax!r i k $ !r i k

*d +(1)!r i k $ riter incr r 0s !r i k

N~ d$ !r i k N~ riter incr r 0s !r i k

ncs$ l p!r i k N~ riter incr r 0s !r i kq

@1d$ @r, k: l p!r i k N~ riter incr r 0s !r i kq

Cas inductif Pour plus de lisibilite' et de concision, l'e'valuation symbolique des fonctions esteffectue'e se'pare'ment, et la formule

riter incr r xs !r i k \Gamma  x est note'e Apxq. La premie`redes deux preuves sert a` e'tablir que (3) :

rincr rs Apnq * Apn \Gamma  1q, tandis que la secondepermet de montrer que (4) :
princr rs !r i k \Gamma  1q * pr!r as xs px \Gamma  1 i k \Gamma  1qq :

p3q : rincr rs Apnq j rincr rs riter incr r ns !r i k \Gamma  n

* riter incr r pn \Gamma  1qs !r i k \Gamma  pn \Gamma  1q p2q
j Apn \Gamma  1q

p4q : rincr rs !r i k \Gamma  1 * rr :i !r \Gamma  1s r!r as ys y i k \Gamma  1

* r!r as xs rr :i x \Gamma  1s r!r as ys y i k \Gamma  1 psplitq
* r!r as xs tr :i x \Gamma  1ur!r as ys y i k \Gamma  1 paffecq
* r!r as xs rtr :i x \Gamma  1u!r as ys y i k \Gamma  1 pupdq
* r!r as xs rx \Gamma  1 as ys y i k \Gamma  1 preadq
* r!r as xs px \Gamma  1 i k \Gamma  1q pdelq

88 Chapitre 4 - Syntaxe et logique de MLDL

La de'rivation du cas inductif repose sur l'usage et les bonnes proprie'te's de la boi^tege'ne'rique. Techniquement, sa duplication permet d'en conserver une copie pour une
ne'cessitation ulte'rieure, et son instanciation, par la fonction incr, permet de se placerdans le contexte calculatoire ade'quat. Moralement, la boi^te ge'ne'rique permet d'utiliser
l'hypothe`se d'induction quel que soit l'e'tat de la me'moire.

ax$ J

*d, wk-gx i k $ k \Gamma  1 i k \Gamma  1

replx i k $ x \Gamma  1 i k \Gamma  1

ncs-box!r i k $ r!r as xs px \Gamma  1 i k \Gamma  1q

*d,(4)!r i k $ rincr rs !r i k \Gamma  1 Apn \Gamma  1q $ Apn \Gamma  1q

rincr rs !r i k \Gamma  1 N~ Apn \Gamma  1q, !r i k $ Apn \Gamma  1q N~ d

rincr rs !r i k \Gamma  1 N~ Apn \Gamma  1q $ !r i k N~ Apn \Gamma  1q *g,(3)
rincr rs !r i k \Gamma  1 N~ rincr rs Apnq $ !r i k N~ Apn \Gamma  1q *g

rincr rs p!r i k \Gamma  1 N~ Apnqq $ !r i k N~ Apn \Gamma  1q inst

l p!r i k \Gamma  1 N~ Apnqq $ !r i k N~ Apn \Gamma  1q ncs-box
l l p!r i k \Gamma  1 N~ Apnqq $ l p!r i k N~ Apn \Gamma  1qq dupl

l p!r i k \Gamma  1 N~ Apnqq $ l p!r i k N~ Apn \Gamma  1qq

@1g@r, k: l p!r i k N~ Apnqq $ l p!r i k N~ Apn \Gamma  1qq

@1d@r, k: l p!r i k N~ Apnqq $ @r, k: l p!r i k N~ Apn \Gamma  1qq

5
Outils se'mantiques

D

ans ce chapitre, nous mettons en place le cadre the'orique dans lequel s'inscrit la con-struction du mode`le de ML

imp que nous effectuerons au Chapitre 6, et nous pre'sentonsles outils se'mantiques ne'cessaires a` cette construction.

Du mode`le syntaxique au mode`le de'notationnel Dans la mesure ou` les objets ma-nipule's par MLDL sont des objets purement syntaxiques (des programmes et des valeurs), il
est naturel dans un premier temps de chercher a` justifier les proprie'te's logiques du formalisme(notamment la proprie'te' de cohe'rence) en construisant un mode`le syntaxique, c'est-a`-dire ici
un mode`le de Kripke dont les mondes sont les stores bien forme's et dans lequel les programmessymboliques sont interpre'te's par des programmes clos tandis que les valeurs symboliques sont
interpre'te'es par des valeurs closes.Une telle construction soule`ve cependant une difficulte' majeure, qui est lie'e au fait que
dans la logique me^me de MLDL, les programmes -- mais aussi les valeurs -- sont identifie's a`travers la relation d'e'valuation symbolique. Afin de refle'ter cette identification, le mode`le doit
donc interpre'ter les valeurs symboliques non pas par des valeurs closes, mais par des classesd'e'quivalence de valeurs closes modulo une certaine relation d'e'quivalence. Cette relation
d'e'quivalence dans le mode`le doit e^tre suffisamment large pour contenir la relation d'e'valu-ation symbolique 1, mais elle doit rester suffisamment fine pour ne pas identifier les valeurs
entie`res 0 et 1. Dans un langage purement fonctionnel, cette difficulte' se re'sout habituellementen invoquant la proprie'te' de Church-Rosser, qui permet de de'montrer que la congruence engendre'e par les re`gles de calcul n'identifie pas des formes normales distinctes -- et notammentles valeurs 0 et 1. Malheureusement, le langage e'tudie' ici n'est pas un langage fonctionnel, mais
un langage impe'ratif avec des re'fe'rences d'ordre supe'rieur, et il semble difficile de re'utiliserles techniques habituelles de preuve de confluence dans notre cadre. 2

1. Par exemple, si p et p1 sont deux programmes e'quivalents a` travers la relation d'e'valuation symbolique,le mode`le se devra d'identifier les deux valeurs

*x: p et *x: p1.2. Nous avons essaye' sans succe`s d'adapter la technique de Tait et Martin-Lo"f a` notre cadre en de'finissant

une relation de re'duction paralle`le sur les e'tats -- c'est-a`-dire sur les couples forme's d'un programme etd'un store -- qui contienne a` la fois la

fi-re'duction et les ope'rations d'affectation, de de're'fe'rencement et decre'ation d'une nouvelle re'fe'rence. Il est cependant possible d'adapter la me'thode de Tait et Martin-Lo"f aux

seuls programmes, et de montrer ainsi que la relation d'e'valuation symbolique sur les valeurs et les programmes(lorsqu'on oriente les re`gles de gauche a` droite) est confluente. Cependant, la porte'e d'un tel re'sultat reste
limite'e dans la mesure ou` elle ne concerne que les e'tapes de calcul purement fonctionnelles dans le langage.

90 Chapitre 5 - Outils se'mantiques

Pour cette raison, nous n'allons pas pre'senter un mode`le syntaxique du formalisme, maisun mode`le construit a` l'aide des outils de la se'mantique de'notationnelle, qui, ainsi que nous
le verrons, proce'deront gratuitement a` toutes les identifications de'sire'es.

La se'mantique de'notationnelle Introduite a` la fin des anne'es 1960 par Scott et Stra-chey [SS71], la se'mantique de'notationnelle se propose d'interpre'ter chaque objet d'un langage
de programmation par un e'le'ment d'un ensemble ordonne' pA, d^q ou` l'ordre x d^ y exprime quela de'notation

y contient au moins autant d'information que la de'notation x. En se'mantiquede'notationnelle, la de'notation d'un objet ne repre'sente donc pas vraiment l'objet lui-me^me,

mais pluto^t le contenu informatif observable a` partir du comportement calculatoire de cetobjet. Dans ce cadre, les fonctions calculables sont repre'sente'es par des fonctions continues
(voir De'f. 5.1.2).Le principal inte're^t de cette approche re'side dans le fait que la de'notation d'un programme fait totalement abstraction du code du programme pour ne conserver que ses pro-prie'te's purement extensionnelles (c'est-a`-dire les proprie'te's << observables >> en fonction des
diffe'rents contextes d'exe'cution). Ainsi, deux programmes ayant le me^me comportement cal-culatoire -- et en particulier deux programmes congruents a` travers la relation d'e'valuation
symbolique -- seront purement et simplement identifie's a` travers leur de'notation.

Plan du chapitre Dans la Section 5.1 nous pre'sentons les notions de dcpo, de cpo,de fonction continue, d'injection-projection, etc. ainsi que les structures cate'goriques sousjacentes. Dans la Section 5.2, on expose la technique habituelle [Plo, AL91, AC98] pourre'soudre des e'quations de domaines (notamment dans la cate'gorie des injections-projections).

Finalement, nous pre'sentons a` la Section 5.3 la principale contribution de ce chapitre, a`savoir la the'orie des actions de groupe sur les dcpo, qui nous permettra dans les chapitres 6
et 7 de contro^ler les invariants lie's a` l'allocation des adresses.

5:1 Pre'sentation des dcpo

Afin d'alle'ger l'expose', on se place ici dans une version simplifie'e de la the'orie des domainesou` la notion de limite ne porte que sur des suites croissantes indice'es par

! et non sur desensembles dirige's. Formellement, nous ne travaillerons donc qu'avec des
!-dcpo, des !-cpoet des fonctions
!-continues, tout en continuant a` utiliser (abusivement) la terminologie dedcpo, de cpo et de fonction continue. La pre'sentation qui est faite ici (du moins jusqu'a` la

section 5.1.5) est largement inspire'e de [Win93].

5:1:1 La cate'gorie des dcpo

De'finition 5.1.1 (Dcpo).On dit qu'un ensemble partiellement ordonne'

A i pA, d^Aq est un dcpo si toute suite croissanted'e'le'ments de
A admet une borne supe'rieure.

En particulier, on dit qu'un dcpo A i pA, d^Aq est discret si l'ordre d^A est l'e'galite', c'est-a`-dire si

x d^A y si et seulement si x i y pour tous x, y P A. Tout ensemble X peut donc e^trevu comme un dcpo discret, quitte a` le munir de la relation d'e'galite'.

5.1. Pre'sentation des dcpo 91
De'finition 5.1.2 (Fonctions monotones et continues).Soient

A et B deux dcpo. On dit qu'une fonction f : A N~ B est :

monotone si pour tous x, y P A, x d^A y implique f pxq d^B f pyq
continue si f est monotone et si pour toute suite croissante pxiqiP! d'e'le'ments de A, ona

f pl/

iP!

xq i l/

iP!

f pxq.

Remarque 5.1.1. Intuitivement, la condition de monotonie exprime que le re'sultat d'une fonc-tion calculable est d'autant plus de'fini que son entre'e est de'finie. Quant a` la condition de
continuite', elle exprime mathe'matiquement l'ide'e intuitive selon laquelle pour produire uneinformation finie en sortie, une fonction calculable n'a besoin d'utiliser qu'une quantite' finie
d'information sur son entre'e. Dans tout ce qui suit, on ne conside'rera donc que des fonctionscontinues. D'un point de vue mathe'matique, cette restriction a e'galement un autre inte're^t,
qui est de rendre possible l'existence de solutions non triviales a` des e'quations de domainestelles que

A ^ pA N~ Aq (ou` A N~ A de'signe l'espace des fonctions continues de A dans A).Sans cette restriction, il est en effet facile de de'montrer que l'e'quation pre'ce'dente n'a pas

d'autre solution que la solution triviale (i.e. a` un seul point).

On appelle cate'gorie des dcpo, et on note dCPO, la cate'gorie dont les objets sont les dcpoet dont les fle`ches sont les fonctions continues.
Comme toute application f : A N~ B allant d'un dcpo discret A vers un dcpo B (eta fortiori vers un dcpo discret

B) est continue, la cate'gorie des ensembles Set se plongepleinement et fide`lement dans la cate'gorie dCPO par le foncteur qui a` tout ensemble

X associele dcpo discret
pX, iq et a` toute application f : X N~ Y associe cette me^me application, vuecomme fonction continue de

pX, iq vers pY, iq. (Intuitivement, ce plongement permet de voirles dcpo comme une extension de la notion d'ensemble.)

5:1:2 Produit de deux dcpo

Soient A et B deux dcpo. On munit le produit carte'sien A \Theta  B de l'ordre produit de'finipar :

px, yq d^A\Theta B px1, y1q ssi x d^A x1 ^ y d^B y1 px, x1 P A, y, y1 P Bq
et on conside`re les deux projections ss1 : A \Theta  B N~ A et ss2 : A \Theta  B N~ B de'finies par :

ss1px, yq i x et ss2px, yq i y ppx, yq P A \Theta  Bq
On ve'rifie aise'ment que :-

A \Theta  B est un dcpo ;- les deux projections

ss1 et ss2 sont continues ;- le dcpo
A \Theta  B est un produit cate'gorique, en ce sens que pour tout dcpo X et pourtoutes fonctions continues

f : X N~ A et g : X N~ B, il existe une unique fonctioncontinue
xf ; gy : X N~ A \Theta  B telle que ss1 \Pi  xf ; gy i f et ss2 \Pi  xf ; gy i g :

X
f

wwnnnnnn

nnnnnn

nnn

D! xf;gyfflffl g

''PPPPP
PPPPPP
PPPP

A A \Theta  Bss1oo ss2 // B

92 Chapitre 5 - Outils se'mantiques

De plus, la fonction xf ; gy : X N~ A \Theta  B est de'finie par xf ; gypxq i pf pxq, gpxqq pourtout

x P X.

Continuite' par composantes Soient A, B et C trois dcpo. On dit qu'une fonction

f : A \Theta  B N~ C est continue par composantes si

1. pour tout x P A, la fonction f px, :q : B N~ C est continue ; et
2. pour tout y P A, la fonction f p:, yq : A N~ C est continue.

Proposition 5.1.Une fonction

f : A \Theta  B N~ C est continue (au sens de la structure de dcpo sur A \Theta  B) si etseulement si
f est continue par composantes.

Ce re'sultat de'coule du lemme suivant :
Lemme 5.1.Soient

A un dcpo, et pxi,jqpi,jqP!2 une famille d'e'le'ments de A indice'e par !2 telle que i d^ i1et
j d^ j1 impliquent xi,j d^ xi1,j1 pour tous i, i1, j, j1 P !. Alors, l'ensemble txi,j -- pi, jq P !2uadmet une borne supe'rieure dans

A, qui est donne'e par :l/

pi,jqP!2

pxi,jq i l/

iP! l/jP!

xi,j i l/

jP! l/iP!

xi,j i l/

iP!

xi,i

Produit ge'ne'ralise' Plus ge'ne'ralement, si pAiqiPI est une famille de dcpo indice'e par unensemble

I quelconque, le produit s'iPI Ai i tpxiqiPI -- @i P I xi P Aiu muni de l'ordre produitde'fini par :

pxiqiPI d^ pyiqiPI ssi @i P I xi d^ yi
est un dcpo, et pour tout i P I, la projection ssi de'finie par :

ssi : z'

jPI

Aj N~ Ai

pxjqjPI ThN~ xi
est continue. La` encore, on ve'rifie aise'ment que le dcpo produit s'iPI Ai est un produit ge'ne'ral-ise' au sens de la the'orie des cate'gories. (On notera cependant que le re'sultat de continuite' par

composantes de'montre' a` la Proposition 5.1 ne s'e'tend pas au produit ge'ne'ralise', sauf dansle cas ou` l'ensemble

I est fini). En particulier, le dcpo 1 i tflu est un objet terminal de lacate'gorie dCPO, qui est donc une cate'gorie carte'sienne.

5:1:3 Somme directe de deux dcpo

Soient A et B deux dcpo. On munit la somme directe A \Gamma  B i pt1u \Theta  Aq Y pt2u \Theta  Bq del'ordre de'fini par :

pi, xq d^A\Gamma B pj, yq ssi pi i 1 ^ j i 1 ^ x d^A yq . pi i 2 ^ j i 2 ^ x d^B yq
et on conside`re les deux injections '1 : A N~ A \Gamma  B et '2 : B N~ A \Gamma  B de'finies par :

'1pxq i p1, xq et '2pyq i p2, yq px P A, y P Bq
On ve'rifie aise'ment que :

5.1. Pre'sentation des dcpo 93
- A \Gamma  B est un dcpo ;- les deux injections

'1 : A N~ A \Gamma  B et '2 : B N~ A \Gamma  B sont continues ;- le dcpo
A \Gamma  B est un coproduit cate'gorique, en ce sens que pour tout dcpo X et pourtoutes fonctions continues

f : A N~ X et g : B N~ X, il existe une unique fonctioncontinue
rf ; gs : A \Gamma  B N~ X telle que rf ; gs \Pi  '1 i f et rf ; gs \Pi  '2 i g :

X

A

f 77nnnnnnnnnn
nnnnn

'1 // A \Gamma  B

D! rf;gs

OO

B'2oo
ggg
PPPPPP

PPPPPP

PPP

De plus, la fonction rf ; gs : A\Gamma B N~ X est de'finie par rf ; gsp1, xq i f pxq et rf ; gsp2, yq i
gpyqq pour tout x P A et y P B.

Somme ge'ne'ralise'e Plus ge'ne'ralement, si pAiqiPI est une famille de dcpo indice'e parun ensemble

I quelconque, la somme r^iPI Ai i tpi, xq -- i P I ^ x P Aiu munie de l'ordre de'finipar :

pi, xq d^ pj, yq ssi i i j ^ x d^Ai y
est un dcpo, et pour tout i P I l'injection 'i de'finie par :

'i : Ai N~ y"

jPI

Aj

x ThN~ pi, xq
est continue. La` encore, on ve'rifie aise'ment que le dcpo est un coproduit ge'ne'ralise' au sensde la the'orie des cate'gories. En particulier, le dcpo vide est un objet initial de la cate'gorie
dCPO, qui est donc une cate'gorie bi-carte'sienne.

5:1:4 Exponentielle de deux dcpo

E'tant donne's deux dcpo A et B, on note A N~ B l'ensemble des fonctions continues de Adans

B muni de l'ordre << par points >>, c'est-a`-dire de l'ordre de'fini par :

f d^AN~B g ssi @x P A f pxq d^B gpxq
On ve'rifie aise'ment que :- l'ensemble ordonne'

A N~ B est un dcpo dans lequel la borne supe'rieure d'une suitecroissante de fonctions continues

pfiqiP! est une fonction continue, qui est donne'e par :

pl/

iP!

fiqpxq i l/

iP!

pfipxqq px P Aq

- l'application apply : pA N~ Bq \Theta  A N~ B de'finie par applypf, xq i f pxq est continue.- le dcpo

A N~ B muni de la fonction continue apply : pA N~ Bq \Theta  A N~ B est uneexponentielle au sens de la the'orie des cate'gories, dans la mesure ou` pour tout dcpo

Xet pour toute fonction continue
f : X \Theta  A N~ B, il existe une unique fonction continue\Lambda 
pf q : X N~ pA N~ Bq telle que apply \Pi  p\Lambda pf q \Theta  idAq i f :

94 Chapitre 5 - Outils se'mantiques

X \Theta  A \Lambda 

pfq\Theta idA //

f **VVVVVVVVVVVVVV
VVVVVVVV
VV pA N~ Bq \Theta  A

apply
fflfflB

Par conse'quent, la cate'gorie dCPO est une cate'gorie bi-carte'sienne ferme'e.

5:1:5 La cate'gorie des cpo

De'finition 5.1.3 (Cpo).On appelle cpo tout dcpo

A ayant un plus petit e'le'ment, traditionnellement note' KA.

On appelle cate'gorie des cpo, et on note CPO, la cate'gorie dont les objets sont les cpo etdont les fle`ches sont les fonctions continues (au sens des dcpo). Par de'finition, CPO est une
sous-cate'gorie pleine de la cate'gorie dCPO, la ple'nitude de'coulant du fait que les cpo et lesdcpo partagent la me^me notion de fonction continue.

Remarque 5.1.2. On notera que :- l'exponentielle

A N~ B de deux cpo A et B, est un cpo dont le plus petit e'le'ment estla fonction constante

x P A ThN~KB. De me^me, le produit A \Theta  B est un cpo, dont le pluspetit e'le'ment est le couple

pKA, KBq. Plus ge'ne'ralement, le produit carte'sien s'iPI Aid'une famille de cpo
pAiqiPI est un cpo, dont le plus petit e'le'ment est la famille pKAiqiPI .De plus, le cpo 1
i tflu est un objet terminal dans la cate'gorie CPO. Ainsi, la cate'gorieCPO est une sous-cate'gorie carte'sienne ferme'e de la cate'gorie dCPO.

- le dcpo A \Gamma  B n'est jamais un cpo (car il n'admet pas de plus petit e'le'ment), me^medans le cas ou`

A et B sont des cpo. Cette remarque se ge'ne'ralise a` toute somme r^iPI Aidans le cas ou`

I n'est pas un singleton. La cate'gorie CPO n'a donc pas d'objet initial,ni de coproduit.

- l'exponentielle A N~ B de deux dcpo A et B a un plus petit e'le'ment de`s lors que Badmet un plus petit e'le'ment. Dans ce cas, le plus petit e'le'ment de

A N~ B est la fonctionconstante
x P A ThN~KB. On peut donc tout a` fait construire un cpo de la forme A N~ Ba` partir d'un dcpo

A sans plus petit e'le'ment, seule l'existence du plus petit e'le'mentde
B e'tant requise.

Lifting d'un dcpo E'tant donne' un dcpo A, on note AK l'ensemble AK i tp0, 0qu Y

pt1u \Theta  Aq muni de l'ordre de'fini par :

pi, xq d^ pj, yq ssi i i 0 . pi i 1 ^ j i 1 ^ x d^A yq
pour tous pi, xq, pj, yq P AK. Intuitivement, l'ensemble ordonne' AK est obtenu en ajoutant a`une copie de

A un e'le'ment supple'mentaire Ki p0, 0q qui est, d'apre`s la de'finition de l'ordre,plus petit que tous les e'le'ments de

A.On conside`re l'injection canonique

t:u de A dans AK de'finie par :

t:u : A N~ AK

x ThN~ txu i p1, xq

La` encore, on ve'rifie aise'ment que :

5.1. Pre'sentation des dcpo 95
- l'ensemble ordonne' AK est un cpo de plus petit e'le'ment Ki p0, 0q, et ce, inde'pen-damment du fait que le dcpo

A ait ou non un plus petit e'le'ment. On notera que laconstruction
AK a encore un sens lorsque A est un cpo. Dans ce cas, le plus petit e'le'-ment de
A perd son statut de plus petit e'le'ment dans le cpo AK a` travers l'injectioncanonique de A dans

AK : tKAu ,KAK.- l'injection canonique
t:u : A N~ AK est une fonction continue.- pour tout
x, y P A, txu a*AK tyu ssi x a*A y et txu i tyu ssi x i y.- soient
A un dcpo et B un cpo. Toute fonction continue f : A N~ B peut e^tre transforme'een une fonction contiue

fK : AK N~ B en posant fKpxq i txu pour tout x P A et
fKpKAKq iKB.Plus ge'ne'ralement, la cate'gorie dCPO se plonge de manie`re fide`le et non pleine dans la

cate'gorie CPO a` l'aide du foncteur lift : dCPO N~ CPO de'fini par :

liftpAq i AKlift

pf q i t:u \Pi  fK : AK N~ BK

Cpo plat On appelle cpo plat tout cpo A dont tous les e'le'ments distincts de KA sontincomparables entre eux. A` isomorphisme pre`s, tout cpo plat

A est de la forme A ^ XK, ou`
X est un dcpo discret :

fl fl fl : : : : : :

K
OOOOO

OOOOO

OOOO

????

???

5:1:6 La cate'gorie des injections-projections

Soient A et B deux cpo.

De'finition 5.1.4 (Couple injection-projection).On appelle un couple injection-projection de

A dans B tout couple f i pf \Gamma , f \Delta q constitue' dedeux fonctions continues
f \Gamma  : A N~ B et f \Delta  : B N~ A telles que :

f \Delta  \Pi  f \Gamma  i idA et f \Gamma  \Pi  f \Delta  d^ idB
L'assertion <<f est un couple injection-projection de A dans B>> est note'e f : A n~ B.

Si f : A n~ B est un couple injection-projection, l'e'galite' f \Delta  \Pi  f \Gamma  i idA implique quela fonction

f \Gamma  est injective tandis que la fonction f \Delta  est surjective. (On qualifie alors lasurjection
f \Delta  de <<projection>>.)Les axiomes

f \Delta  \Pi  f \Gamma  i idA et f \Gamma  \Pi  f \Delta  d^ idB impliquent que les deux fonctions continues
f \Gamma  et f \Delta  sont strictes, en ce sens que :

f \Gamma pKAq iKB et f \Delta pKBq iKA
De'termination des composantes de f : A n~ B Pour tout couple f : A n~ B :

96 Chapitre 5 - Outils se'mantiques

L'injection f \Gamma  est de'termine'e par la projection f \Delta .En effet, l'image par

f \Gamma  d'un e'le'ment x P A est le plus petit e'le'ment de l'ensemble desante'ce'dents de
x par f \Delta  dans B :

f \Gamma pxq i minty P B -- f \Delta pyq i xu
La projection f \Delta  est de'termine'e par l'injection f \Gamma .En effet, l'image par

f \Delta  d'un e'le'ment y P B est le plus grand e'le'ment de l'ensemble des<<pre'-ante'ce'dents>> de

y par f \Gamma  dans A, c'est-a`-dire l'ensemble des e'le'ments x P A telsque
f \Gamma pxq d^ y :

f \Delta pyq i maxtx P A -- f \Gamma pxq d^ yu

Par conse'quent, pour tous f, g : A n~ B, on a :

f i g ssi f \Gamma  i g\Gamma  . f \Delta  i g\Delta 

Anatomie d'un couple injection-projection Intuitivement, tout couple injection-projection

f : A n~ B permet de voir les e'le'ments de A comme des approximations dese'le'ments de

B. L'injection f \Gamma  : A N~ B permet d'identifier chaque e'le'ment x P A avec sonimage
f \Gamma pxq P B, tandis que la projection f \Delta  : B N~ A permet d'associer a` chaque e'le'ment
y P B une <<approximation>> f \Delta pyq P A.Il est possible de formaliser pre'cise'ment cette intuition en remarquant que l'injection

f \Gamma constitue un plongement du cpo
A dans le cpo B, en ce sens que :

1. f \Gamma pKAq iKB ;
2. pour tous x, x1 P A : x d^A x1 ssi f \Gamma pxq d^B f \Gamma px1q 3.

Ce plongement permet ainsi d'identifier le cpo A avec son image B1 i f \Gamma pAq dans le cpo
B par l'injection f \Gamma  : A N~ B. Par ailleurs, le sous-ensemble B1 D^ B -- qui est isomorphe a`
A en tant qu'ensemble ordonne' -- constitue un sous-cpo de B car :

1. KBi f \Gamma pKAq P B1 ;
2. B1 est <<clos par borne supe'rieure>>, en ce sens que la borne supe'rieure (dans B) de toutesuite croissante d'e'le'ments de

B1 appartient a` B1 e'galement.

Conside'rons a` pre'sent la fonction f \Pi  i f \Gamma  \Pi f \Delta  : B N~ B, qui correspond intuitivement a` laprojection

f \Delta  : B N~ A ramene'e dans B (et me^me dans B1) a` l'aide de l'injection f \Gamma  : A N~ B.Pour tout
y P B on a :

1. f \Pi pyq P B1 et f \Pi pyq d^ y (<<f \Pi pyq est une approximation de y dans B1>>)
2. f \Pi pyq i y ssi y P B1 (<<les e'le'ments de B1 sont les points fixes de f \Pi >>)

Autrement dit, la fonction f \Pi  : B N~ B permet d'approcher tout e'le'ment y P B par une'le'ment

f \Pi pyq P B1 tel que f \Pi pyq d^ y, ce qui indique une perte potentielle d'information lorsdu passage au sous-cpo

B1. Plus pre'cise'ment :- Dans le cas ou`
y P B1, on a f \Pi pyq i y (<<aucune perte d'information>>)- En revanche lorsque

y R B1, on a f \Pi pyq a* y (<<perte stricte d'information>>)Il est important de noter que pour tout couple injection-projection

f : A n~ B, la foncion
f \Pi  : B N~ B de'finie par f \Pi  i f \Gamma  \Pi  f \Delta  est idempotente, puisque :

f \Pi  \Pi  f \Pi  i f \Gamma  \Pi  f \Delta  \Pi  f \Gamma  \Pi  f \Delta  i f \Gamma  \Pi  idA \Pi  f \Delta  i f \Gamma  \Pi  f \Delta  i f \Pi 
3. L'implication directe est imme'diate par monotonie, et la re'ciproque de'coule du fait que f\Delta  \Pi  f\Gamma  i idA

5.1. Pre'sentation des dcpo 97
Les fonctions continues idempotentes f \Pi  : B N~ B telles que f \Pi  d^ idB caracte'risent enre'alite' les couples injection-projection a` isomorphisme pre`s, ce dont on peut se convaincre de
la manie`re suivante :Soient

B un cpo quelconque et f \Pi  : B N~ B une fonction continue telle f \Pi  d^ idB (sous-identite') et

f \Pi  \Pi  f \Pi  i f \Pi  (idempotence). On conside`re alors le sous-ensemble A D^ B de'finicomme l'ensemble des points fixes de

f \Pi , c'est-a`-dire :

A i tx P B -- f \Pi pxq i xu
On notera que, puisque la fonction continue f \Pi  : B N~ B est idempotente, on a e'galement
A i f \Pi pBq (i.e. A est l'image de B par f \Pi ). On ve'rifie alors que le sous-ensemble A D^ B ainside'fini est un sous-cpo du cpo

B, puisque :

1. f \Pi pKBq d^KB, donc f \Pi pKBq iKB P A ;
2. Si pxiqiP! est une suite croissante d'e'le'ments de A, alors :

f \Pi pl/

iP!

xiq i l/

iP!

f \Pi pxiq i l/

iP!

xi pcar f \Pi pxiq i xi P Aq

ce qui entrai^ne que pZ^iP! xiq P A.Puisque le sous-ensemble

A D^ B a lui-me^me une structure de cpo (en conside'rant l'ordreinduit par
B), on peut construire deux applications f \Gamma  : A N~ B et f \Delta  : B N~ A en posant
f \Gamma pxq i x pour tout x P A (inclusion de A dans B) et f \Delta pyq i f \Pi pyq pour tout y P B(restriction de

B a` son image f \Pi pBq i A). On ve'rifie alors sans difficulte' que ces deuxfonctions sont continues et que

f \Delta  \Pi  f \Gamma  i idA et f \Gamma  \Pi  f \Delta  d^ idB,
ce qui entrai^ne que f i pf \Gamma , f \Delta q est bien un couple injection-projection de A dans B.

La cate'gorie CPOip Dans ce qui suit, on de'signe par CPOip la cate'gorie dont les objetssont les cpo et dont les fle`ches sont les couples injection-projection

f : A n~ B. Dans cettecate'gorie :

- la fle`che identite' idipA : A n~ A est donne'e par idipA i pidA, idAq ;- e'tant donne'es deux fle`ches

f : A N~ B et g : B N~ C dans la cate'gorie CPOip, lacompose'e
g \Pi  f : A N~ C est de'finie par g \Pi  f i pg\Gamma  \Pi  f \Gamma , f \Delta  \Pi  g\Delta q.Il est important de remarquer que la notion d'isomorphisme dans CPOip coi"ncide avec la

notion d'isomorphisme dans CPO dans le sens suivant :
Lemme 5.2 (Isomorphisme dans CPO et dans CPOip).Pour tous cpo

A et B :

1. Si A et B sont isomorphes dans CPO a` travers une fle`che inversible h : A N~ B, alorsle couple

f ph, h\Delta 1q : A n~ B est un isomorphisme dans CPOip, dont l'inverse est donne'par
f \Delta 1 i ph\Delta 1, hq.

2. Si A et B sont isomorphes dans CPOip a` travers une fle`che inversible f : A n~ B,alors cette fle`che a pour inverse

f \Delta 1 i pf \Delta , f \Gamma q dans CPOip, et les fonctions continues
f \Gamma  : A N~ B et f \Delta  : B N~ A constituent des isomorphismes re'ciproques l'un de l'autredans CPO, en ce sens que

pf \Gamma q\Delta 1 i f \Delta  et pf \Delta q\Delta 1 i f \Gamma .

Par ailleurs, on peut noter que :

98 Chapitre 5 - Outils se'mantiques

- La cate'gorie CPOip admet un objet initial, a` savoir le cpo 1 i tflu. En effet, pour toutcpo

A, il existe une unique fle`che f : 1 n~ A , laquelle est donne'e par f \Gamma pflq iKA et
f \Delta pxq i fl pour tout x P A.- Pour tous cpo

A et B, le cpo A \Theta  B muni des deux fle`ches fl1 : A n~ A \Theta  B et
fl2 : B n~ A \Theta  B de'finies par :

fl\Gamma 1 pxq i px, KBq fl\Delta 1 px, yq i x

fl\Gamma 2 pyq i pKA, yq fl\Delta 2 px, yq i y

constitue un coproduit (et non un produit !) dans la cate'gorie CPOip.- En revanche, la cate'gorie CPOip n'a pas d'objet terminal, et deux objets quelconques
n'ont en ge'ne'ral pas de produit (au sens cate'gorique).Plus ge'ne'ralement, on peut de'montrer que la cate'gorie CPOip a toutes ses colimites, en
ce sens que tous les diagrammes de la cate'gorie CPOip admettent une colimite dans CPOip.(L'objet initial 1 et le coproduit

A \Theta  B correspondant respectivement aux colimites du di-agramme vide et du diagramme a` deux points

tA; Bu.) Dans ce qui suit, on s'inte'resserauniquement aux colimites des
!-chai^nes dans CPOip.

5:2 Re'solution d'e'quations dans CPOip

Dans cette section, on se propose de montrer comment re'soudre dans CPOip une e'quationde la forme

A ^ OEpAq, ou` OE est un endofoncteur de CPOip. Historiquement, cette techniquede re'solution a e'te' introduite par Scott pour re'soudre l'e'quation

A ^ pA N~ Aq dont lessolutions non triviales constituent autant de mode`les du
*-calcul pur. Au chapitre suivant,nous re'soudrons une e'quation similaire (mais sensiblement plus complexe en raison de la

pre'sence des stores) pour construire un mode`le du langage de programmation MLimp.

5:2:1 Colimite d'un !-diagramme dans CPOip

On conside`re un !-diagramme dans CPOip, c'est-a`-dire un couple

A i ppAiqiP!, pfi : Ai n~ Ai\Gamma 1qiP!q
forme' d'une suite de cpo pAiqiP! et d'une suite de fle`ches pfi : Ai n~ Ai\Gamma 1qiP! :

A i A0 f0 +3 A1 f1 +3 A2 f2 +3 A3 +3 : : :
Dans ce qui suit, il est commode de conside'rer la famille de fonctions continues pfi,jqpi,jqP!2de'finie pour tout

pi, jq P !2 par :

fi,j i $'&'%

f \Gamma j\Delta 1 \Pi  \Xi  \Xi  \Xi  \Pi  f \Gamma i si i a* j
idAi si i i j
f \Delta j \Pi  \Xi  \Xi  \Xi  \Pi  f \Delta i \Delta  1 si i a, j

On notera que :- pour tout

i P ! : fi,i i idAi, fi,i\Gamma 1 i f \Gamma i , et fi\Delta 1,i i f \Delta i ;

5.2. Re'solution d'e'quations dans CPOip 99
- pour i d^ j : pfi,j, fj,iq : Ai n~ Aj est le couple injection-projection donne' par pfi,j, fj,iq i

fj\Delta 1 \Pi  \Xi  \Xi  \Xi  \Pi  fi.

De'finition 5.2.1 (Coco^nes et colimites).

1. On appelle coco^ne sur A, tout couple pC, fl\Sigma q forme' d'un cpo C et d'une suite de fle`ches

fl\Sigma  i pfli : Ai n~ CqiP! telle que fli i fli\Gamma 1 \Pi  fi pour tout i P !, c'est-a`-dire que lediagramme suivant commute :

C
: : :

19
+3 Ai

fli

:B~~
~~~~

~

~~~~
~~~

fi +3 Ai\Gamma 1

fli\Gamma 1

]e DDD

DDDD

D

DDDD

DDDD

+3 : : :

fn

2. E'tant donne's deux coco^nes pC, \Gamma \Sigma q et pD, ffi\Sigma q sur le diagramme A, on dit qu'une fle`che

u : C n~ D est un morphisme de coco^nes si ffii i u \Pi  fli pour tout i P !, ce que l'on note
u : pC, \Gamma \Sigma q n~A pD, ffi\Sigma q :

C

u +3 D

: : :

4!
+3

/7
Ai
fli

KS

fi +3
ffii

3;oooo
oooooo

oooo

oooooo
oooooo
oo A

i\Gamma 1

fli\Gamma 1
ck OOOO

OOOOO

OOO

OOOOO

OOOOO

OO ffii\Gamma 1

KS

+3 : : :

go ck

Les coco^nes sur A forment une cate'gorie.
3. Enfin, on dit qu'un coco^ne pA8, ff\Sigma q est une colimite de A, si ce coco^ne est un objetinitial dans la cate'gorie des coco^nes sur

A, c'est-a`-dire si pour tout coco^ne pC, fl\Sigma q, ilexiste un unique morphisme de coco^nes
u : pA8, ff\Sigma q n~A pC, fl\Sigma q :

C

A8
D! u

KS

Ai

fli

!D\Delta \Delta 
\Delta \Delta \Delta \Delta 

\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 

\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta  ffi

4!pppp
ppppp
ppp

ppppp
ppppp
pp

fi +3 Ai\Gamma 1

ffi\Gamma 1
ck OOOO

OOOOO

OOO

OOOOO

OOOOO

OO

fli\Gamma 1
[c???

????

????

????

???

????

????

????

????

??

La proprie'te' de commutation entre les fle`ches du diagramme et celle du coco^ne se ge'ne'raliseaise'ment. Ainsi, on a :
Lemme 5.3.Soit

pC, fl\Sigma q un coco^ne du diagramme A, alors pour tout i, j P !, fi,j i fl\Delta j \Pi  fl\Gamma i .

C

i
: : : +3 Ai f

i +3

fli

4!pppp
ppppp
pppp

ppppp
ppppp
ppp : : :

fj\Delta 1 +3 Aj +3

fljbj NNNNNNNNN

NNNN

NNNNN

NNNNN

NNN

: : :

100 Chapitre 5 - Outils se'mantiques

De'monstration :Le re'sultat est trivial lorsque

i i j.Si
i a* j, alors fl\Delta j \Pi  fl\Gamma i i fl\Delta j \Pi  fl\Gamma i\Gamma 1 \Pi  f \Gamma i i fl\Delta j \Pi  fl\Gamma j \Pi  f \Gamma j\Delta 1 \Pi  \Xi  \Xi  \Xi  \Pi  f \Gamma i i idAj \Pi  fi,j i fi,jSi

i a, j, alors fl\Delta j \Pi  fl\Gamma i i f \Delta j \Pi  fl\Delta j\Gamma 1 \Pi  fl\Gamma i i f \Delta j \Pi  \Xi  \Xi  \Xi  \Pi  f \Delta i\Gamma 1 \Pi  fl\Delta i \Pi  fl\Gamma i i fi,j \Pi  idAi i fi,joe

Nous allons maintenant montrer que le diagramme A admet une colimite. Pour cela, onconside`re l'ensemble

A8 de'fini par

A8 i tu P z'

iP!

Ai -- @i P !: ui i f \Delta i pui\Gamma 1qu

et muni de l'ordre induit par l'ordre produit sur s'iP! Ai. On ve'rifie aise'ment que :
Proposition 5.2.
A8 est un cpo.

De'monstration :Soit

pujqjP! une suite croissante d'e'le'ments de A8. Il s'agit de montrer que sa bornesupe'rieure _

u i Z^jP! uj dans le cpo produit s'iP! Ai -- laquelle est de'finie <<par points>> :
p_uqi i Z^jP!ppujqiq pour tout i P ! -- appartient encore a` A8, ce qui revient a` ve'rifier pourtout

i P ! que :

p_uqi i l/

jP!

ppujqiq i l/

jP!

f \Delta i ppujqi\Gamma 1q i f \Delta i pl/

jP!

ppujqi\Gamma 1qq i f \Delta i pp_uqi\Gamma 1q

ce qui de'coule de la continuite' de f \Delta i . Le dcpo A8 a par ailleurs pour plus petit e'le'ment lasuite

pKAiqiP!, puisque KAi i f \Delta i pKAi\Gamma 1q pour tout i P !. oePour tous

i P !, x P A, et u P A8, on pose :

ff\Gamma i pxq i pfi,jpxqqjP! et ff\Delta i puq i ui
On ve'rifie alors que :
Proposition 5.3.Pour tout

i P !, ffi i pff\Gamma i , ff\Delta i q : Ai n~ Ai\Gamma 1 est un couple injection-projection, et ffi i ffi\Gamma 1 \Pi fi(dans CPOip).

De'monstration :(De'finition de

ff\Gamma i : Ai N~ Ai\Gamma 1) La fonction ff\Gamma i de'finie pour tout x P Ai par ff\Gamma i pxq i
pfi,jpxqqjP! est a priori a` valeurs dans le produit s'jP! Aj. (Il s'agit manifestement d'unefonction continue, car elle est solution du proble`me universel de'finissant le produit.) Pour

montrer que ff\Gamma i est a` valeurs dans A8, il suffit de ve'rifier que pour tout j P !, on a :

pff\Gamma i pxqqj i fi,jpxq i f \Delta j pfi,j\Gamma 1pxqq i f \Delta j ppff\Gamma i pxqqj\Gamma 1q
ce qui est imme'diat d'apre`s la de'finition des fonctions fi,j.(De'finition de

ff\Delta i : A8 N~ Ai) Par construction, la fonction ff\Delta i i pu ThN~ uiq est larestriction de la projection

ssi : s'jP! Aj N~ Ai a` A8, et est donc continue.

5.2. Re'solution d'e'quations dans CPOip 101
(De'finition de ffi i pff\Gamma i , ff\Delta i q) Pour tout x P Ai, on a ff\Delta i pff\Gamma i pxqq i fi,ipxq i x, d'ou`
ff\Delta i \Pi  ff\Gamma i i idAi. De me^me, pour tout u P A8 et pour tout j P ! on a :

rff\Gamma i pff\Delta i puqqsj i fi,jpuiq i #fi,jpfj,ipujqq d^ uj si i d^ j pcar ui i fi,jpujqqu

j si i e^ j pcar uj i fi,jpuiqq

soit ff\Gamma i pff\Delta i puqq d^ u, d'ou` ff\Gamma i \Pi  ff\Delta i d^ idA8.(E'galite'

ffi i ffi\Gamma 1 \Pi  fi) Pour tout x P Ai, on a :

ff\Gamma i pxq i pfi,jpxqqjP! i pfi\Gamma 1,jpf \Gamma i pxqqqjP! i ff\Gamma i\Gamma 1pf \Gamma i pxqq
d'ou` ff\Gamma i i ff\Gamma i\Gamma 1 \Pi  f \Gamma i . De me^me pour tout u P A8, on a :

ff\Delta i puq i ui i f \Delta i pui\Gamma 1q i f \Delta i pff\Delta i\Gamma 1puqq
d'ou` ff\Delta i i f \Delta i \Pi  ff\Delta i\Gamma 1, et finalement ffi i ffi\Gamma 1 \Pi  fi. oeD'un point de vue cate'gorique, nous venons de montrer que le couple

pA8, ff\Sigma q -- enposant
ff\Sigma  i pffi : Ai n~ A8qiP! -- est un coco^ne sur A :

A8

: : :

08
+3 Ai

ffi

9A----
--------

--

--------
------

fi +3 Ai\Gamma 1

ffi\Gamma 1

^f EEE

EEEE

E

EEEE

EEEE

+3 : : :

fn

Il nous reste a` pre'sent a` montrer que :
Proposition 5.4.Le coco^ne

pA8, ff\Sigma q est une colimite de A, en ce sens que pour tout coco^ne pC, fl\Sigma q, il existeun unique morphisme de coco^nes

u : pA8, ff\Sigma q n~A pC, fl\Sigma q :

C

A8
D! u

KS

Ai

fli

!D\Delta \Delta 
\Delta \Delta \Delta \Delta 

\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 

\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta \Delta \Delta 
\Delta \Delta  ffi

4!pppp
ppppp
ppp

ppppp
ppppp
pp

fi +3 Ai\Gamma 1

ffi\Gamma 1
ck OOOO

OOOOO

OOO

OOOOO

OOOOO

OO

fli\Gamma 1
[c???

????

????

????

???

????

????

????

????

??

De plus, le morphisme de coco^nes u : pA8, ff\Sigma q n~A pC, fl\Sigma q est de'fini par

u\Gamma puq i pl/

iP!

pfl\Gamma i puiqqq et u\Delta pcq i pfl\Delta i pcqqiP!

pour tous u P A8 et c P C.
De'monstration :(De'finition de

u\Gamma ) Soit u\Gamma  : A8 N~ C l'application de'finie par u\Gamma puq i Z^iP! fl\Gamma i puiq.Pour montrer que cette application est bien de'finie, il suffit de montrer que la suite

pfl\Gamma i puiqqiP!

102 Chapitre 5 - Outils se'mantiques

est croissante dans C. Soit i P !. Comme fli i fli\Gamma 1 \Pi  fi -- car pC, fl\Sigma q est un coco^ne sur A --,on a

fl\Gamma i i fl\Gamma i\Gamma 1 \Pi  f \Gamma i , soit

fl\Gamma i puiq i fl\Gamma i\Gamma 1 \Pi  f \Gamma i puiq i fl\Gamma i\Gamma 1 \Pi  f \Gamma i \Pi  f \Delta i pui\Gamma 1q d^ fl\Gamma i\Gamma 1pui\Gamma 1q :
Par ailleurs, on ve'rifie aise'ment que u\Gamma  est monotone et continue.

(De'finition de u\Delta ) Soit u\Delta  : C N~ A8 l'application de'finie par u\Delta pcq i pfl\Delta i pcqqiP!. Pourmontrer que

u\Delta  est bien a` valeurs dans A8, il suffit de ve'rifier que fl\Delta i pcq i f \Delta i pfl\Delta i\Gamma 1pcqq pourtout
i P !, ce qui de'coule imme'diatement du fait que fl\Delta i i f \Delta i \Pi  fl\Delta i\Gamma 1, puisque fli i fli\Gamma 1 \Pi  fi.La` encore, on ve'rifie aise'ment que

u\Delta  est monotone et continue.

(De'finition de u : A8 n~ C) Ve'rifions que u\Delta  \Pi  u\Gamma  i idA8 et u\Gamma  \Pi  u\Delta  d^ idC . Pour tout
u P A! et pour tout j P !, on a

u\Delta pfl\Gamma puqqj i fl\Delta j pl/

iP!

fl\Gamma i puiqq

i l/

iP!

fl\Delta j pfl\Gamma i puiqq

i l/

ie^j

fl\Delta j pfl\Gamma i puiqq

i l/

ie^j

fi,jpuiq

i l/

ie^j

uj i uj

ppar le Lemme 5.3q
pcar fi,jpuiq i uj si j d^ iq

soit encore u\Delta pfl\Gamma puqq i pujqjP! i u. Pour tout c P C, on a par ailleurs

u\Gamma pu\Delta pcqq i l/

iP!

fl\Gamma i pfl\Delta i pcqq d^ c pcar fl\Gamma i \Pi  fl\Delta i d^ idC q

soit encore u\Gamma  \Pi  u\Delta  i uipfl\Gamma i \Pi  fl\Delta i qiP! d^ idC .

(Morphisme de coco^nes) Il s'agit de montrer que fli i u \Pi  ffi pour tout i P !. Pour tous
i P ! et x P Ai, on a

pu \Pi  ffiq\Gamma pxq i u\Gamma pff\Gamma i pxqq i u\Gamma ppfi,jpxqqjP!q

i l/

jP!

fl\Gamma j pfi,jpxqq

i l/

je^i

fl\Gamma j pfi,jpxqq

i l/

je^i

fl\Gamma i pxq i fl\Gamma i pxq pcar fl\Gamma j \Pi  fi,j i fl\Gamma i si i d^ jq

d'ou` pu \Pi  ffiq\Gamma  i fl\Gamma i . De me^me, pour tous i P ! et c P C, on a

pu \Pi  ffiq\Delta pcq i ff\Delta i pu\Delta pcqq i ff\Delta i ppfl\Delta j pcqqjP!q i fl\Delta i pcq ,
soit pu \Pi  ffiq\Delta  i fl\Delta i . D'ou` fli i u \Pi  ffi. Nous avons ainsi montre' l'existence du morphisme decoco^nes

u : pA8, ff\Sigma q n~ pC, fl\Sigma q ;

5.2. Re'solution d'e'quations dans CPOip 103
(Unicite') Supposons que u1 : A8 n~ C soit une injection-projection telle que fli i u1 \Pi  ffipour tout

i P !. On commence par remarquer que pour tout u P A8, on a

u i l/

iP!

pfi,jpuiqqjP! ,

d'ou`

u1\Gamma puq i l/

iP!

u1\Gamma ppfi,jpuiqqjP!q

i l/

iP!

u1\Gamma pff\Gamma i puiqq

i l/

iP!

fl\Gamma i puiq

i u\Gamma puq

pde'f. de ff\Gamma i q
pcar fl\Gamma i i u1\Gamma  \Pi  ff\Gamma i q

pde'f. de u\Gamma q
et par conse'quent u1\Gamma  i u\Gamma . De plus, pour tout c P C on a

u1\Delta pcq i pff\Delta i pu1\Delta pcqqqiP!

i pfl\Delta i pcqqiP!
i u\Delta pcq

pcar fl\Delta i i ff\Delta i \Pi  u1\Delta q

pde'f. de u\Delta q

d'ou` u1\Delta  i u\Delta  et finalement u1 i u. oe

5:2:2 Image de la colimite par un endofoncteur de CPOip

En reprenant les notations de la Section 5.2.1, on conside`re a` pre'sent un endofoncteur OEdans CPOip, c'est-a`-dire une correspondance qui :

- a` tout cpo X associe un cpo OEX ; et- a` toute fle`che

f : X n~ Y (ou` X et Y sont des cpo quelconques) associe une fle`che
OEf i pOE\Gamma f, OE\Delta f q : OEX n~ OEY .A` travers le foncteur

OE, le diagramme A a pour image le !-diagramme

B i OEA i B0 g0 +3 B1 g1 +3 B2 g2 +3 B3 +3 \Xi  \Xi  \Xi 
de'fini par Bi i OEAi et gi i OEfi pour tout i P !.Soit

pB8, fi\Sigma q la colimite du diagramme B de'finie par :

B8 i tu P s'iP! Bi -- @i P !: ui i f \Delta i pui\Gamma 1qu

fi\Sigma  i pfi\Gamma i , fi\Delta i qiP! avec

fi\Gamma i pxq i pfi,jpxqqjP! et fi\Delta i puq i ui
Remarquons qu'il s'agit exactement de la me^me construction que pre'ce'demment pour
pA8, ff\Sigma q, qui est la colimite du diagramme A.En plongeant le cpo

B8 (i.e. la << colimite des images >>) dans le cpo OEA8 (i.e. l'<< imagede la colimite >>), on remarque que ce dernier cpo peut e^tre muni d'une structure de coco^ne

pOEA8, OEff\Sigma q sur B. En effet, OE e'tant un foncteur, pour tout i P !, le couple pOE\Gamma ffi, OE\Delta ffiq i

104 Chapitre 5 - Outils se'mantiques

OEffi : OEAi n~ OEA8 est une injection-projection de OEAi dans OEA8 qui commute avec lesfle`ches du diagramme :

OEffi i OEpffi\Gamma 1 \Pi  fiq i OEffi\Gamma 1 \Pi  OEfi i OEffi\Gamma 1 \Pi  gi
Par conse'quent, d'apre`s la Proposition 5.4 :

Corollaire 5.4.1 (B8 n~ A8).Il existe un unique morphisme de coco^nes

u : pB8, fi\Sigma q n~B pOEA8, OEff\Sigma q, lequel est donne',pour tous
v P B8 et c P OEA8, par :

u\Gamma pvq i sup

iP! OE

\Gamma ffipviq et u\Delta pcq i \Gamma OE\Delta ffipcq\Phi 

iP!

En ge'ne'ral, le couple injection-projection u : B8 n~B OEA8 n'est pas un isomorphisme.Mais puisque

u\Gamma  \Pi  u\Delta  i sup

iP! pOE

\Gamma ffi \Pi  OE\Delta ffiq pd^ idOEA

8q p\Sigma q

(voir la preuve de la Proposition 5.4), on de'duit du Lemme 5.2 que :

Proposition 5.5 (Condition pour l'isomorphisme).Le morphisme de coco^nes

u : B8 n~B OEA8 est un isomorphisme si et seulement si :

sup

iP! pOE

\Gamma ffi \Pi  OE\Delta ffiq i idOEA

8

De'monstration :De (*), on a que la condition e'quivaut a` l'e'galite'

u\Gamma  \Pi  u\Delta  i idOEA8, ce qui permet deconclure a` l'aide du Lemme 5.2, car
pu, u\Delta 1q, ou` u\Delta 1 i pu\Delta , u\Gamma q, constitue un couple defonctions continues inversibles avec
u \Pi  u\Delta 1 i idOEA8 et u\Delta 1 \Pi  u i idB8. oeCette condition, ne'cessaire pour obtenir la proprie'te' de commutation entre le foncteur

OEet la colimite -- un isomorphisme entre la colimite de l'image par
OE de A (B8) et l'imagepar
OE de la colimite de A (OEA8) --, sugge`re naturellement la de'finition et la caracte'risationsuivantes :

De'finition 5.2.2 (Foncteur !-cocontinu).On dit qu'un foncteur

OE : CPOip n~ CPOip est !-cocontinu s'il pre'serve la colimite de tout !-diagramme, c'est-a`-dire si pour tout

!-diagramme A i ppAiqiP!, pfiqiP!q, l'unique morphismede coco^nes (sur
OEA)

u : colim i P !OEAi n~A OEA OE\Delta colim i P !Ai\Psi 
est un isomorphisme.

La Proposition 5.5 nous donne alors la caracte'risation suivante :
Proposition 5.6 (Caracte'risation des foncteurs !-cocontinus).Pour qu'un foncteur

OE : CPOip n~ CPOip soit !-cocontinu, il faut et il suffit que pour tout
!-diagramme A i ppAiqiP!, pfiqiP!q de colimite pA8, ff\Sigma q on ait :

sup

iP! pOE

\Gamma ffi \Pi  OE\Delta ffiq i idOEA

8 :

5.3. Actions de groupe sur les dcpo 105
5:2:3 Re'solution de l'e'quation A ^ OEpAq

Gra^ce aux constructions qui pre'ce`dent, il est maintenant possible de de'montrer que :

Proposition 5.7 (Plus petit point fixe d'un endofoncteur !-cocontinu).Tout endofoncteur

OE : CPOip n~ CPOip qui est !-cocontinu admet un plus petit point fixe,c'est-a`-dire un cpo
A8 tel que

(1) OEA8 ^ A8
(2) Pour tout cpo C tel que OEC ^ C, il existe h : A8 n~ C.

De'monstration :(Existence d'un point fixe) On conside`re le

!-diagramme
A i ppAiqiPP!, pfi : Ai n~ Ai\Gamma 1qiP!q de'fini par

A0 i 1 Ai\Gamma 1 i OEAi

f0 i pKKOEpA0q, Kflq fi\Gamma 1 i OEfi

(ou` f0 : 1 n~ OE1 est l'unique couple injection-projection de 1 dans OE1) ainsi que le !-diagramme image

B i ppBiqiPP!, pgi : Bi n~ Bi\Gamma 1qiP!q, qui est de'fini par

Bi i OEAi i Ai\Gamma 1 et gi i OEfi i fi\Gamma 1 pi P !q
Soient pA8, ff\Sigma q et pB8, fi\Sigma q les colimites respectives des !-diagrammes A et B. Puisqueque le foncteur

OE est !-cocontinu, alors (De'finition. 5.2.2), l'unique morphisme de coco^nes
u0 : pB8, fi\Sigma q n~B pOEA8, OEff\Sigma q de'finit un isomorphisme entre les cpo B8 et OEA8. Il reste alorsa` de'montrer que les cpo

A8 et B8 sont isomorphes, ce qui de'coule imme'diatement du faitque les diagrammes
A et B sont eux-me^me isomorphes : par construction on a Bi i Ai\Gamma 1 et
gi i fi\Gamma 1 pour tout i P !. (L'isomorphisme u1 i pu\Gamma 1 , u\Delta 1 q : A8 n~ B8 est en effet donne' par
u\Gamma 1 puq i pui\Gamma 1qiP! et u\Delta 1 pvq i pvi\Delta 1qiP!\Sigma  Yt0 ThN~ flu pour tous u P A8 et v P B8.) La compose'e
u i u0 \Pi  u1 : A8 n~ OEA8 des deux isomorphismes u1 : A8 n~ B8 et u0 : B8 n~B OEA8 nousdonne alors l'isomorphisme recherche'.

(Minimalite') Notons u : A8 n~ OEA8 l'isomorphisme de A8 dans OEA8, et conside'ronsun cpo

C muni d'un isomorphisme u1 : C n~ OEC. On conside`re alors la suite de couplesinjection-projection

pfli : Ai n~ Cq de'finie par :

fl0 i pKKC , Kflq : 1 n~ C et fli\Gamma 1 i pu1\Delta 1 \Pi  OEfliq : Ai\Gamma 1 n~ C pi P !q
On ve'rifie par une re'currence imme'diate que-

fl0 i fl1 \Pi  f0 (par unicite' de fl0 : 1 n~ C)- si

fli i fli\Gamma 1 \Pi  fi, alors

fli\Gamma 1 i u1\Delta 1 \Pi  OEfli i u1\Delta 1 \Pi  OEpfli\Gamma 1 \Pi  fiq i pu1\Delta 1 \Pi  OEfli\Gamma 1q \Pi  OEfi i fli\Gamma 2 \Pi  fi\Gamma 1
d'ou` il ressort que pC, fl\Sigma q (en notant fl\Sigma  i pfliqiP!) est un coco^ne sur le diagramme A. D'ou`l'existence d'une injection-projection de la colimite

A8 dans C. oe

5:3 Actions de groupe sur les dcpo

Nous concluons cette introduction a` la se'mantique de'notationnelle en pre'sentant la the'oriedes actions de groupe sur les dcpo, qui constitue notre principale contribution dans ce chapitre.

106 Chapitre 5 - Outils se'mantiques

Nous travaillons ici dans le cadre le plus ge'ne'ral, en supposant donne' un groupe G fixe', dontla loi de composition est note'e multiplicativement, et dont l'unite' est note'e 1.

Dans les chapitres 6 et 7, nous verrons comment utiliser la notion d'action de groupe surles dcpos dans le cas particulier ou`

G est un sous-groupe du groupe des permutations desadresses afin de contro^ler les me'canismes de renommage des adresses dans le mode`le.

5:3:1 Actions de groupe - de'finitions

On appelle une action de G sur un ensemble A toute application de ff : G \Theta  A dans Aassociant a` tout couple

poe, xq P G\Theta A un e'le'ment note' oex, et satisfaisant les axiomes suivants :

(1) 1x i x (x P A)
(2) oepoe1xq i poeoe1qx (oe, oe1 P G, x P A)

De manie`re e'quivalente, une action de G sur A est la donne'e d'un morphisme de groupes
h : G N~ AutpAq, ou` AutpAq de'signe l'ensemble des automorphismes de A.Il de'coule imme'diatement de ces axiomes que pour tout e'le'ment du groupe

oe P G, lafonction
px ThN~ oexq : A N~ A est un automorphisme de A -- c'est-a`-dire une fonction continueinversible -- dont l'inverse est la fonction

px ThN~ oe\Delta 1xq. En particulier, la fonction x ThN~ 1x estla fonction identite'. De plus, on ve'rifie aise'ment que si l'action

ff : G \Theta  A N~ A est continue,alors la fonction
px ThN~ oexq : A N~ A est un automorphisme continu de A.

De'finition 5.3.1 (Orbite, stabilisateur et points fixes).Soit

ff une action de G sur l'ensemble A et a un e'le'ment de A. L'orbite de a, note' Orba, estl'ensemble des images de

a par G. Un stabilisateur de a est l'ensemble des e'le'ments de Gdont l'action sur
a est l'identite'. L'ensemble des points fixes d'un e'le'ment oe de G est donne'par l'ensemble des e'le'ments de

A invariants sous l'action de oe :

Orba i toea P A -- oe P Gu Staba i toe P G -- oea i au Fixoe i ta P A -- oea i au

5:3:2 La cate'gorie G-dCPO

De'finition 5.3.2 (G-dcpo).Un dcpo

A muni d'une action ff de G sur A telle que pour tout oe P G, la fonction x ThN~
ffpoe, xq : A N~ A est continue, est appele' un G-dcpo et note' pA, ffq.

Clairement, dans le cas ou` A a un plus petit e'le'ment K (i.e. A est un cpo), on ve'rifieimme'diatement que

oeK i K pour tout oe P G. De me^me si A a un plus grand e'le'ment J,on a
oeJ i J pour tout oe P G -- c'est une conse'quence imme'diate de la monotonie desautomorphismes

x ThN~ oex. Plus ge'ne'ralement, toute action de G sur A envoie les e'le'mentsminimaux (resp. les e'le'ments maximaux) de

A sur les e'le'ments minimaux (resp. les e'le'mentsmaximaux) de
A.

De'finition 5.3.3 (Fonction G-invariante).On appelle fonction

G-invariante toute fonction continue f : pA, ffq N~ pB, fiq, ou` pA, ffq et
pB, fiq sont des G-dcpo, telle que pour tout poe, aq P G \Theta  A, f pffpoe, aqq i fipoe, f paqq. Lorsqu'iln'y aura pas d'ambigui"te', on notera simplement

f \Pi  oe i oe \Pi  f .

5.3. Actions de groupe sur les dcpo 107
On appelle cate'gorie des G-dcpo et on note G-dCPO, la cate'gorie dont les objets sont les
G-dcpo et les fle`ches sont les fonctions G-invariantes.

Ope'rations sur les G-dcpo Les ope'rations sur les dcpo de'finies a` la Section 5.1.1sont e'tendues aux

G-dcpo. Il s'agit essentiellement pour chaque ope'ration, de de'finir l'actionapproprie'e et de ve'rifier que les fonctions standard sur ces ope'rations sont bien

G-invariantes.Soient
I un ensemble de'nombrable (e'ventuellement fini), pAi, ffiqiPI une famille de G-dcpo,
pA, ffq et pB, fiq deux G-dcpo :

Produit L'action act\Theta  associe'e au dcpo produit s'iPI Ai est de'finie par :

G \Theta  z'

iPI

Ai Y'N~ z'

iPI

Ai

poe, paiqiPI q ThN~ pffipoe, aiqqiPI

Somme directe L'action act\Gamma  associe'e a` la somme directe de la famille pAiqiPI est donne'epar :

G \Theta  y"

iPI

Ai Y'N~ y"

iPI

Ai

poe, 'ipaqq ThN~ 'ipffipoe, aqq

Lifting L'action actt:u associe'e au lifting du dcpo A est donne'e par :

G \Theta  AK Y'N~ AK

poe, tauq ThN~ tffpoe, aqu

Espace des fonctions continues Bien que la notion naturelle de morphisme dansla cate'gorie des

G-dcpos soit la notion de fonction continue G-invariante, il est ne'anmoinspossible de munir l'espace

A N~ B de toutes les fonctions continues d'un G-dcpo pA, ffq dansun autre
G-dcpo pB, fiq d'une action actN~ de'finie par conjugaison de la manie`re suivante :

G \Theta  pA N~ Bq Y'N~ A N~ B

poe, f q ThN~ oef : a P A ThN~ fipoe, f pffpoe\Delta 1, aqqqi.e.

oef i oe \Pi  f \Pi  oe\Delta 1

Remarque 5.3.1. Clairement, l'action actN~ commute avec l'application, en ce sens que oepf xq i
poef qpoexq. On voit donc que les fonctions G-invariantes sont exactement les fonctions tellesque

oef i f . En effet, si oef i f , alors oepf paqq i oepf poe\Delta 1poeaqqq i poef qpoeaq i f poeaq. Etinversement, si

f est G-invariante, alors oef i oe \Pi  f \Pi  oe\Delta 1 i oeoe\Delta 1 \Pi  f i 1f i f . Autrementdit, Stab

f i G.

De plus, on ve'rifie aise'ment que :- pour tout

x P A \Theta  B (resp. x P A \Gamma  B, x P AK, x P A N~ B), 1x i x et oe1poexq i poe1oeqx ;- pour tout

i P I, les fonctions ssi, 'i, et t:u sont G-invariantes ;- les actions act

\Theta , act\Gamma , actt:u et actN~ sont continues (act\Theta  par continuite' des ssi ; act\Gamma par continuite' des

'i, actt:u par continuite' de t:u et actN~ par continuite' de f ) ;- par conse'quent,

A \Theta  B, A \Gamma  B, AK et A N~ B sont des G-dcpo ;- la fonction K

fl est G-invariante et le cpo 1 i tflu est un G-dcpo ;

108 Chapitre 5 - Outils se'mantiques

- la fonction vide est G-invariante et le dcpo vide est un G-dcpo.D'un point de vue cate'gorique, nous venons de montrer que :

Proposition 5.8.
G-dCPO est une cate'gorie bi-carte'sienne.

Remarque 5.3.2. La cate'gorie G-dCPO est me^me une cate'gorie bi-carte'sienne ferme'e dontl'exponentielle est le dcpo

A N~G B des fonctions continues G-invariantes muni de l'actionde groupe triviale (i.e. act

N~Gpoe, f q i f ). Cependant, nous aurons besoin au chapitre suivantde toutes les fonctions continues pour interpre'ter les programmes de ML

imp, et pas seulementdes fonctions
G-invariantes, d'ou` la ne'cessite' de conside'rer l'espace de toutes les fonctionscontinues muni de son action (qui ne constitue pas une exponentielle dans

G-dCPO).

E'tant donne'es les fonctions f : B N~ B1, g : B N~ B2, f 1 : B1 N~ B et g1 : B2 N~ B, onpeut noter par ailleurs que les fonctions :

ssi : s'iPI Ai N~ Ai
xf ; gy : B N~ B1 \Theta  B2

'i : Ai N~ r^iPI Ai
rf 1; g1s : B1 \Gamma  B2 N~ B

sont toutes G-invariantes. De plus :

Proposition 5.9.Soient

pA, ffq, pB, fiq deux G-dcpo, et pgi : A N~ BqiP! une !-chai^ne de fonctions G-invariantes.Alors la borne supe'rieure Z^

iP! gi est G-invariante.

De'monstration :Soit

a P A.

oeppZ^iP! giqpaqq i oe Z^iP!pgipaqq

i Z^iP! oegipaq pfi continueq
i Z^iP! gipoeaq pgi G-invarianteq
i pZ^iP! giqpoeaq oe

5:3:3 La cate'gorie G-CPOip

Soit A et B deux cpo.

De'finition 5.3.4 (Couple injection-projection G-invariant).Soit

f : A n~ B un couple injection-projection de A dans B. Le couple f i pf \Gamma , f \Delta q est
G-invariant si f \Gamma  : A N~ B et f \Delta  : B N~ A sont des fonctions G-invariantes.

On ve'rifie aise'ment que la composition g\Pi f i pg\Gamma \Pi f \Gamma , f \Delta \Pi g\Delta q de deux couples injections-projections

G-invariants f : A n~ B et g : B n~ C, est un couple G-invariant. Par conse'quent,

5.3. Actions de groupe sur les dcpo 109
la structure dont les objets sont les G-cpo et les fle`ches sont les injections-projections G-invariantes, constitue une cate'gorie que l'on note

G-CPOip.Il est important de remarquer que la notion d'isomorphisme dans

G-CPOip coi"ncide avecle notion d'isomorphisme dans
G-CPO au sens suivant :

Lemme 5.4 (Isomorphisme dans G-CPO et G-CPOip).Pour tous

G-cpo A et B (G-dcpo avec plus petit e'le'ment) :

1. Si A et B sont isomorphes dans G-CPO a` travers une fle`che inversible h : A N~ B,alors le couple

f ph, h\Delta 1q : A n~ B est un isomorphisme dans G-CPOip, dont l'inverseest donne' par
f \Delta 1 i ph\Delta 1, hq.

2. Si A et B sont isomorphes dans G-CPOip a` travers une fle`che inversible et G-invariante

f : A n~ B, alors cette fle`che a pour inverse f \Delta 1 i pf \Delta , f \Gamma q dans G-CPOip, et lesfonctions

G-invariantes f \Gamma  : A N~ B et f \Delta  : B N~ A constituent des isomorphismesre'ciproques dans

G-CPO, en ce sens que pf \Gamma q\Delta 1 i f \Delta  et pf \Delta q\Delta 1 i f \Gamma .

E'tant donne's des cpo A et B, on ve'rifie aise'ment que :-

G-CPOip n'admet pas d'objet terminal.- l'unique fle`che 1

n~ A est bien G-invariante ;- les deux fle`ches
fl1 : A n~ A \Theta  B et fl2 : B n~ A \Theta  B associe'e au coproduit A \Theta  B etde'finies a` la page 97 sont bien

G-invariantes.

Proposition 5.10 (Action sur les colimites).Soit

A i pAi, fi : Ai n~ Ai\Gamma 1q un !-diagramme dans G-CPOip. Alors, pA8, pffiqiP!q, colimitede
A dans CPOip, est un coco^ne de A dans G-CPOip. De plus, l'action de G sur A8 est donne'par

oeu i poeuiqiP!.

De'monstration :Il s'agit essentiellement de montrer que

A8 peut e^tre muni d'une action et que les couples
ffi : Ai n~ Ai\Gamma 1 sont G-invariants -- on a de'ja` montre' que A8 est un cpo et que le diagrammecommute (Propositions 5.2 et 5.3). Le premier point est imme'diat. On remarque en effet que

par G-invariance de la composition et des projections, on a :

oepff\Gamma i pxqq i oeppfi,jpxqqjP!q i poepfi,jpxqqqjP! i pfi,jpoexqqjP! i ff\Gamma i poexq
et

oepff\Delta i puqq i oepssipuqq i ssipoeuq i ff\Delta i poeuq

On rappelle maintenant que A8 i tu P s'iP! Ai -- @i P !: ui i f \Delta i pui\Gamma 1qu. Soit u i puiqiP!un e'le'ment de

A8. Clairement, oeu i poeuiqiP! P s'iP! Ai. De plus, pour tout i P !, on abien :

poeuqi i oeui i oepf \Delta i pui\Gamma 1qq i f \Delta i poeui\Gamma 1q i f \Delta i ppoeuqi\Gamma 1q
Par conse'quent, la fonction continue act8 : G \Theta  A8 Y'N~ A8, de'finie par oeu i poeuiqiP!,constitue bien une action de

G sur A8 qui est donc un G-cpo. oe

110 Chapitre 5 - Outils se'mantiques

6
Se'mantique de'notationnelle de MLimp

D

ans ce chapitre, nous pre'sentons la se'mantique de'notationnelle de MLimp. Nous com-mencerons par construire un mode`le dans la cate'gorie dCPO (Section 6.1) que nous

enrichirons ensuite avec une action du groupe des permutations d'adresses a` supportfini (Section 6.2). Nous de'finirons ensuite la fonction d'interpre'tation des programmes, des
valeurs et des stores dans ce mode`le (Section 6.3) et nous e'tablirons les proprie'te's de cor-rection de la fonction d'interpre'tation vis-a`-vis de la se'mantique ope'rationnelle (de'finie a` la
Section 3.2) et de l'e'valuation symbolique (de'finie a` la Section 4.1.1). Enfin, nous introduirons(Section 6.4) la notion de relation de domination (entre une de'notation et un ensemble fini
d'adresses), qui sera notre principal outil pour traiter la question des invariants lie's a` lame'moire dans le chapitre suivant.

6:1 Construction du mode`le de MLimp dans les dcpo

Le mode`le de MLimp est construit a` l'aide des outils se'mantiques pre'sente's au chapitrepre'ce'dent. Il s'agit de re'soudre dans dCPO et CPOip un syste`me d'e'quations qui permette de
mode'liser les objets de MLimp.

6:1:1 Mode'lisation des programmes, des valeurs et des stores

Mode'lisation des valeurs Par de'finition, les valeurs de MLimp sont soit des entiers,soit des adresses, soit des couples, soit des fonctions. Cela fournit la premie`re e'quation :

V i Z \Gamma  L \Gamma  pV \Theta  V q \Gamma  F
ou` Z et L de'signent respectivement les dcpos discrets des entiers et des adresses, et ou` leparame`tre

F de'signe le dcpo repre'sentant les fonctions (nous verrons en fait qu'il s'agit d'uncpo). Notons qu'un dcpo

V qui est solution de cette e'quation ne peut pas avoir de plus petite'le'ment, ce qui correspond au fait que ML

imp ne contient pas de valeur inde'finie.

112 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Mode'lisation des fonctions Une fonction de MLimp se mode'lise naturellement par une'le'ment du cpo :

F i pV \Theta  Sq N~ pV \Theta  SqK
ou` S de'signe le dcpo des stores. On notera que ce dcpo est en re'alite' un cpo, puisque le dcpode retour

pV \Theta  SqK a un plus petit e'le'ment, qui permet de mode'liser la non terminaison del'application d'une fonction.

Mode'lisation des stores Par de'finition, un store syntaxique est une fonction dont ledomaine est un segment initial de

", l'allocateur me'moire syntaxique. Une solution naturelleserait d'en faire autant avec les stores se'mantiques. Cependant, nous verrons a` la Section 6.4

que le traitement des invariants lie's a` la me'moire impose de stocker la politique d'allocationdans chaque store se'mantique. (La raison technique e'tant que les permuations d'adresses
doivent non seulement agir sur les adresses de'ja` alloue'es, mais e'galement sur les adressesfutures, et donc sur la politique d'allocation.)

Formellement, un store est repre'sente' dans le mode`le par un triplet s i pL, e, 'q, ou` :-

L est un ensemble fini d'adresses, repre'sentant le domaine du store s ;-
e est une e'nume'ration de Lc i LzL, qui repre'sente la politique d'allocation des adressesnon encore utilise'es dans

s ;-
' est une fonction (finie) de L dans V .Ainsi, l'espace des stores est de'fini par la somme directe

S i y"

LPPfinpLq Enum

pLcq \Theta  V L

ou` les ensembles PfinpLq et EnumpLcq sont tous deux munis de leur structure de dcpo discret,tandis que

V L est muni de sa structure de dcpo produit. (Nous verrons plus loin que ces choixde structures sont essentiels pour garantir la continuite' des me'canismes d'allocation.)

Syste`me d'e'quations et me'thode de re'solution Au final, nous obtenons un sys-te`me de trois e'quations a` trois inconnues

V , S et F (les deux premie`res de'signant des dcpo,et la dernie`re un cpo) :

V ^ Z \Gamma  L \Gamma  pV \Theta  V q \Gamma  F (6.1)
p\Sigma \Sigma q S ^ y"

LPPfinpLq Enum

pLcq \Theta  V L (6.2)

F ^ pV \Theta  Sq N~ pV \Theta  SqK (6.3)
Il est important de remarquer que dans le syste`me d'e'quations ci-dessus, les inconnues
V , S et F n'ont que des occurrences positives, sauf dans le membre droit de l'e'quationde'finissant le cpo

F . C'est la raison pour laquelle nous centrerons la re'solution du syste`mesur l'inconnue
F . Ainsi, nous de'finirons successivement deux foncteurs T et S permettantd'exprimer respectivement les dcpos

V et S a` partir du cpo F . Ceci nous permettra decaracte'riser le cpo
F comme solution de l'e'quation F i F , ou`  est l'endofoncteur dansCPOip de'fini par :
X i rpTX \Theta  SXq N~ pTX \Theta  SXqKs.

6.1. Construction du mode`le de MLimp dans les dcpo 113
6:1:2 Le foncteur T

Le type de donne'es alge'brique TX Avant tout, remarquons que les valeurs deML

imp sont des arbres binaires dont les feuilles sont de trois types diffe'rents : entier, adresseou fonction. Ici, le type des fonctions est abstrait et passe' en parame`tre. Nous de'finissons

donc, pour tout ensemble X quelconque, le type alge'brique TX des arbres binaires dont lesfeuilles sont e'tiquete'es par les e'le'ments de

Z \Gamma  L \Gamma  X.Formellement, e'tant donne' un ensemble

X, les e'le'ments de TX, note's t, t1, t2, etc, sontde'finis par la grammaire suivante :

t ::i intpnq -- addrp`q -- pairpt1, t2q -- basepxq
ou` n P Z, ` P L et x P X.

Fonctorialite' Soient X et Y des ensembles. A` toute application f : X N~ Y , on associeune application T

f : TX N~ TY de'finie par induction sur t P TX par :

Tf pintpnqq i intpnqT

f paddrp`qq i addrp`qT
f ppairpt1, t2qq i pairpTf pt1q, Tf pt2qqT

f pbasepxqq i basepf pxqq

Proposition 6.1 (Fonctorialite' de T dans Set).La double correspondance qui a` tout ensemble

X associe l'ensemble TX et a` toute application
f P Y X associe l'application Tf P TY TX est un foncteur dans la cate'gorie Set.

Le foncteur T dans dCPO Dans le cas ou` X est muni d'une relation d'ordre pd^X q, onmunit l'ensemble T

X d'une relation d'ordre note'e pd^TX q et de'finie par induction a` l'aide desre`gles :

intpnq d^TX intpnq

nPZ addrp`q d^T

X addrp`q

`PL

t1 d^TX u1 t2 d^TX u2
pairpt1, t2q d^TX pairpu1, u2q

x d^X y
basepxq d^TX basepyq

On ve'rifie aise'ment que la relation pd^TX q ainsi de'finie sur l'ensemble TX est une relationd'ordre, pour laquelle les e'le'ments de la forme int

pnq, addrp`q, pairpt1, t2q et basepxq sont deuxa` deux incomparables. De plus, deux e'le'ments comparables de T

X ont la me^me structured'arbre, les me^me feuilles dans
Z ou dans L, et ne diffe`rent que sur les feuilles dans X.

Remarque 6.1.1. Si donc ptiqiP! est une !-chai^ne d'e'le'ments de TX, une induction imme'diatemontre que tous les e'le'ments de la chai^ne sont du me^me type, autrement dit que :

- soit il existe un entier n P Z tel que pour tout i P !, ti i intpnq ;- soit il existe une adresse

` P L telle que pour tout i P !, ti i addrp`q ;- soit pour tout
i P !, il existe un (unique) couple pui, viq P TX2 tel que ti i pairpui, viq.De plus, les deux suites

puiqiP! et pviqiP! sont e'galement croissantes dans TX ;- soit pour tout
i P !, il existe un (unique) xi P X tel que ti i basepxiq. De plus, la suite
pxiqiP! est croissante dans X.

114 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Proposition 6.2.Pour tout dcpo

X, TX est un dcpo sans plus petit e'le'ment.

De'monstration :

Soit ptiqiP! une suite croissante d'e'le'ments de TX. On de'montre par induction sur t0 quecette suite admet une borne supe'rieure.

- t0 i intpnq (avec n P Z). Dans ce cas, on a ti i intpnq pour tout i P !. La suite ptiqiP!est donc constante et a pour borne supe'rieure int

pnq.-
t0 i addrp`q (avec ` P L). Me^me raisonnement que pre'ce'demment.-
t0 i pairpu0, v0q (avec u0, v0 P TX). De la Remarque 6.1.1 suit qu'il existe un (unique)couple

pui, viq P TX2 tel que ti i pairpui, viq et que les deux suites puiqiP! et pviqiP! sontcroissantes. D'apre`s l'hypothe`se d'induction, ces deux suites ont des bornes supe'rieures,

note'es respectivement _u et _v. Il est alors imme'diat que la suite ptiqiP! i ppairpui, viqqiP!a pair

p_u, _vq pour borne supe'rieure.-
t0 i basepx0q (avec x0 P X). De me^me, pour tout i P !, il existe un (unique) e'le'ment
xi P X tel que ti i basepxiq et que la suite pxiqiP! est croissante dans X. Comme X estun dcpo, la suite

pxiqiP! a une borne supe'rieure _x (dans X). Il est alors imme'diat quela suite
ptiqiP! i pbasepxiqqiP! a pour borne supe'rieure basep_xq (dans TX).

Enfin, il est clair que TX n'a pas de plus petit e'le'ment, puisque les arbres intp0q et intp1qn'ont pas de minorant commun. oe

Lemme 6.1 (Continuite' des constructeurs).Pour tout dcpo

X, les quatre fonctions

intp:q : Z N~ TX pairp:, :q : TX2 N~ TXaddr

p:q : L N~ TX basep:q : X N~ TX

sont continues.
De'monstration :

C'est imme'diat pour les constructeurs intp:q et addrp:q, puisque leur argument est a` valeursdans un dcpo discret. La continuite' des deux autres constructeurs repose sur des manipulations e'le'mentaires sur les bornes supe'rieures. oe

Proposition 6.3.Si

X et Y sont des cpo, et si f : X N~ Y est une fonction continue, alors Tf : TX N~ TY este'galement une fonction continue.

De'monstration :

Soit ptiqiP! une suite croissante d'e'le'ments de TX. Il s'agit de de'montrer que Tf pZ^iP! tiq iZ^
iP! Tf ptiq. On raisonne par induction sur t0.-

t0 i intpnq (avec n P Z). Dans ce cas, on a ti i intpnq pour tout i P !, d'ou`T

f pZ^iP! tiq i Tf pintpnqq i intpnq i Z^iP! intpnq i Z^iP! Tf ptiq.-
t0 i addrp`q (avec ` P L). Me^me raisonnement que pre'ce'demment.

6.1. Construction du mode`le de MLimp dans les dcpo 115
- t0 i pairpu0, v0q (avec u0, v0 P TX). La Remarque 6.1.1 entrai^ne que :

Tf pZ^iP! tiq i Tf pZ^iP! pairpui, viqq

i Tf ppairpZ^iP! ui, Z^iP! viqq
i pairpTf pZ^iP! uiq, Tf pZ^iP! viqq
i pairpZ^iP! Tf puiq, Z^iP! Tf pviqq
i Z^iP! pairpTf puiq, Tf pviqq
i Z^iP! Tf ppairpui, viqq
i Z^iP! Tf ptiq

pLemme 6.1q

pDe'f. de Tq
pHyp. Ind.q
pLemme 6.1q

pDe'f. de Tq

- t0 i basepx0q (avec x0 P X). De me^me, on a alors :

Tf pZ^iP! tiq i Tf pZ^iP! basepxiqq

i Tf pbasepZ^iP! xiqq
i basepf pZ^iP! xiqq
i basepZ^iP! f pxiqq
i Z^iP! basepf pxiqq
i Z^iP! Tf pbasepxiqq
i Z^iP! Tf ptiq

pLemme 6.1q

pDe'f. de Tq
pContinuite' de f q

pLemme 6.1q

pDe'f. de Tq

oeD'apre`s les Propositions 6.1, 6.2 et 6.3 on a imme'diatement :
Proposition 6.4 (Fonctorialite' de T dans dCPO).La double correspondance, qui a` tout dcpo

X associe le dcpo TX et a` toute fonction continue
f : X N~ Y associe la fonction continue Tf : TX N~ TY , est un foncteur dans dCPO.

Proposition 6.5 (Continuite' du foncteur T).-- Le foncteur T : dCPO

N~ dCPO est continu, en ce sens que pour tous dcpo X et Y ,l'application

T : pX N~ Y q N~ pTX N~ TY q

f ThN~ Tf

est continue de pX N~ Y q dans pTX N~ TY q.

De'monstration :Il s'agit de montrer que T pre'serve la borne supe'rieure de toute

!-chai^ne de fonctionscontinues. Soit
pfiqiPI une suite croissante d'e'le'ments de pX N~ Y q. Il faut de'montrer queT
pZ^iP! fiq i Z^iP! Tfi, ce qui revient a` de'montrer que

Tpl/

iP!

fiqptq i l/

iP! T

fiptq

pour tout t P TX. On raisonne par induction sur t P TX.-

t i intpnq (avec n P Z). Dans ce cas, on a

TpZ^iP! fiqptq i TpZ^iP! fiqpintpnqq

i intpnq i Z^iP! intpnq
i Z^iP! Tfipintpnqq
i Z^iP! Tfiptq

pDe'f. de Tq
pDe'f. de Tq

116 Chapitre 6 - Se'mantique de'notationnelle de MLimp

- t i addrppq`q (avec ` P L). Me^me raisonnement que pre'ce'demment.-

t i pairpu, vq (avec u, v P TX). Dans ce cas, on a

TpZ^iP! fiqptq i TpZ^iP! fiqppairpu, vqq

i pairpTpZ^iP! fiqpuq, TpZ^iP! fiqpvqq
i pairpZ^iP! Tfipuq, Z^iP! Tfipvqq
i Z^iP! pairpTfipuq, Tfipvqq
i Z^iP! Tfippairpu, vqq
i Z^iP! Tfiptq

pDe'f. de Tq
pHyp. Ind.q
pLemme 6.1q

pDe'f. de Tq

- t i basepxq (avec x P X). Dans ce cas, on a

TpZ^iP! fiqptq i TpZ^iP! fiqpbasepxqq

i baseppZ^iP! fiqpxqq
i basepZ^iP! fipxqq
i Z^iP! basepfipxqq
i Z^iP! Tfipbasepxqq
i Z^iP! Tfiptq

pDe'f. de Tq
psup. de fonctionsq

pLemme 6.1q

pDe'f. de Tq

oe
Point fixe Finalement, on montre que TX, le dcpo des valeurs construites sur la basede

X, est un point fixe de la fonction Y ThN~ Z \Gamma  L \Gamma  pY \Theta  Y q \Gamma  X. On a donc bien :

Lemme 6.2 (Point fixe).Pour tout dcpo

X, on a TX ^ Z \Gamma  L \Gamma  pTX \Theta  TXq \Gamma  X.

Exemple : le test d'e'galite' dans TX A` tout dcpo X, on associe une fonction de testd'e'galite' sur les valeurs de T

X, EquX : TX \Theta  TX N~ t0, 1u de'finie par :

EquX pintpnq, intpn1qq i ffin,n1Equ

X paddrp`q, addrp`1qq i ffi`,`1Equ
X ppairpt1, t2q, pairpt11, t12qq i EquX pt1, t11q \Theta  EquX pt2, t12qEqu

X pbasepxq, basepx1qq i 0

pn, n1 P Zq

p`, `1 P Lq
pt1, t2, t11, t12 P TXq

px, x1 P Xq

(ou` ffii,j de'signe le symbole de Kronecker), et par EquX pt1, t2q i 0 de`s que les deux arbres t1 PT

X et t2 P TX sont construits a` l'aide de deux constructeurs distincts. Par une inductionimme'diate sur la structure des arbres dans T

X, on ve'rifie que :

Proposition 6.6 (Continuite' de EquX : TX2 N~ t0, 1u).Pour tout dcpo

X, la fonction EquX : TX2 N~ t0, 1u est continue (ou` t0, 1u est muni de sastructure de dcpo discret).

Par la suite, on notera Equ la fonction EquF ou` F est la solution de l'e'quation 6.3.

6.1. Construction du mode`le de MLimp dans les dcpo 117
6:1:3 Le foncteur S

Le foncteur S dans Set On conside`re la correspondance qui a` tout ensemble X, associel'ensemble S

X de'fini par :

SX i r^LPPfinpLq EnumpLcq \Theta  pTXqL

i tpL, e, 'q -- L P PfinpLq ^ e P EnumpLcq ^ ' P pTXqLu
ou` Lc i LzL de'signe le comple'mentaire de L dans L. On remarque que L e'tant un dcpodiscret, toute fonction

' de L, ensemble fini d'adresses, dans TX, est continue. Par ailleurs,on associe a` toute application

f P Y X , ou` X et Y sont des ensembles quelconques, uneapplication S
f P SY SX de'finie, pour tout pL, e, 'q P SX, par :

Sf pL, e, 'q i pL, e, Tf \Pi  'q

Notations
(E'nume'rations) E'tant donne'e une e'nume'ration e P EnumpLq, on note popnpeq l'e'nume'ra-tion obtenue a` partir de

e en de'pilant n adresses, pour tout i P N par ppopnpeqqi i ei\Gamma n.

(Stores) E'tant donne' un store s i pL, e, 'q, on note :- dom

psq i L ;- free
psq i e ;-
sp`q i 'p`q pour tout ` P L i dompsq.

Proposition 6.7 (Fonctorialite' de S dans Set).La double correspondance qui a` tout ensemble

X associe l'ensemble SX et a` toute application
f P Y X associe l'application Sf P SY SX est un foncteur dans Set.

De'monstration :Il s'agit essentiellement de ve'rifier que

1. SidX i idSX
2. Spg \Pi  f q i Sg \Pi  Sf
pour tous X, Y , Z, f P Y X et g P ZY . La preuve repose essentiellement sur la fonctorialite'de T et l'associativite' de la composition. oe

Le foncteur S dans dCPO Dans le cas ou` X est un dcpo, on munit l'ensemble SX desa structure de dcpo induite par la somme directe ge'ne'ralise'e (Section 5.1.3) en posant

pL, e, 'q d^SX pL1, e1, '1q j L i L1 ^ e i e1 ^ @` P L 'p`q d^TX '1p`q
pour tous pL, e, 'q, pL, e1, '1q P SX. Insistons sur le fait que dans le dcpo SX :- Deux e'le'ments issus de deux composantes Enum

pLcq \Theta  TXL et EnumpL1cq \Theta  TXL

1 sont

incomparables entre eux de`s lors que L , L1 -- dans une somme directe ge'ne'ralise'e,l'ensemble des indices est traite' de manie`re discre`te.

- Pour chaque ensemble fini d'adresses L P PfinpLq, TXL de'signe le produit fini s'`PL TX,ou, ce qui revient au me^me, l'ensemble des fonctions continues

' : L N~ TX en munissantl'ensemble fini
L de sa structure de dcpo discret.

118 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Proposition 6.8.Si

X et Y sont des cpo, et si f : X N~ Y est une fonction continue, alors Sf : SX N~ SY este'galement une fonction continue.

De'monstration :Soit

psiqiP! une suite croissante d'e'le'ments de SX, et posons pL, e, '0q i s0. On de'montrepar une re'currence imme'diate que pour tout

i P !, il existe une (unique) application 'i P TXLtelle que
si i pL, e, 'iq, et on ve'rifie que la suite p'iqiP! est croissante dans TXL. On a alors

Sf pZ^iP! siq i Sf pL, e, Z^iP! 'iq

i pL, e, Tf \Pi  pZ^iP! 'iqq
i pL, e, Z^iP!pTf \Pi  'iqq
i Z^iP!pL, e, Tf \Pi  'iq
i Z^iP! Sf psiq

pProp. 6.5q

oePar conse'quent :
Proposition 6.9 (Fonctorialite' de S dans dCPO).La double correspondance qui a` tout dcpo

X associe le dcpo SX et a` toute fonction continue
f : X N~ Y associe la fonction continue Sf : SX N~ SY est un foncteur dans dCPO.

Proposition 6.10 (Continuite' du foncteur S).Le foncteur S : dCPO

N~ dCPO est continu, en ce sens que pour tous dcpo X et Y , l'application

S : pX N~ Y q N~ pSX N~ SY q

f ThN~ Sf

est continue de pX N~ Y q dans pSX N~ SY q.

De'monstration :Soit

pfiqiP! P pX N~ Y q! une suite croissante. Pour tout pL, e, 'q P SX on a :

SpZ^iP! fiqpL, e, 'q i pL, e, TpZ^iP! fiq \Pi  'q

i pL, e, pZ^iP! Tfiq \Pi  'q
i pL, e, Z^iP!pTfi \Pi  'qq
i Z^iP!pL, e, Tfi \Pi  'q
i Z^iP! SfipL, e, 'q

pContinuite' de Tq

pContinuite' de \Pi q

soit S Z^iP! fi i Z^iP! Sfi. oe
Ante'riorite' E'tant donne's deux stores s i pL, e, 'q et s1 i pL1, e1, '1q, on dit que s estante'rieur a`

s1, ce que l'on note s I^ s1, s'il existe un entier n P ! tel que :-
L1 i L Y te0, : : : , en\Delta 1u ;-
e1 i popnpeq.(L'entier

n en question est force'ment unique.) On notera que la relation d'ante'riorite' s I^ s1ne tient pas compte des valeurs stocke'es dans

s et dans s1.La relation d'ante'riorite' est clairement un pre'ordre pour lequel deux stores

s et s1 sonte'quivalents (i.e.
s I^ s1 et s1 I^ s) si et seulement si freepsq i freeps1q (ce qui entrai^ne e'galementque dom
psq i domps1q).

6.1. Construction du mode`le de MLimp dans les dcpo 119
Extension d'un store E'tant donne' un store s P SX, on note extpsq le store obtenu a`partir de

s en allouant la prochaine adresse libre et en y stockant la valeur 0. Formellement,le store ext

psq est de'fini par :- dom
pextpsqq i dompsq Y tfreepsq0u- free
pextpsqq i pop1pfreepsqq ;- ext
psqp`q i sp`q pour tout ` P dompsq ;- ext
psqpfreepsq0q i intp0q.On notera que par construction, on a

s I^ extpsq.

Mise-a`-jour d'une adresse alloue'e Soient s i pL, e, 'q, ` P L et v une valeur. Onnotera

s\Gamma t` ThN~ vu le store pL, e, '\Gamma t` ThN~ vuq ou` ' \Gamma  t` ThN~ vu est la fonction continue de'finiepar :

' \Gamma  t` ThN~ vu : L Y'N~ TX

`1 ThN~ #v si `

1 i `

'p`1q sinon

Lemme 6.3.Soient

L P PfinpLq, ` P L et ', '1 P TXL. Si ' d^ '1 et v d^ v1, alors '\Gamma t` ThN~ vu d^ '1\Gamma t` ThN~ v1u.De me^me, si

s et s1 sont deux e'le'ments de S tels que s d^ s1, alors s \Gamma  t` ThN~ vu d^ s1 \Gamma  t` ThN~ v1u.

6:1:4 Le foncteur R dans dCPO

Il est commode d'introduire un foncteur auxiliaire R : dCPO N~ dCPO, de'fini comme leproduit des foncteurs T et S. Formellement :

- A` tout dcpo X, on associe le dcpo RX de'fini par :

RX i TX \Theta  SX
- E'tant donne's deux dcpo X et Y , on associe a` toute fonction continue f : X N~ Y , unefonction continue R

f : RX N~ RY , de'finie par :

Rf pt, sq i pTf ptq, Sf psqq ppt, sq P RXq
Il est alors imme'diat d'apre`s les Propositions 6.4, 6.5, 6.9 et 6.10 que :

Proposition 6.11 (Fonctorialite' de R dans dCPO).La double correspondance qui a` tout dcpo

X associe le dcpo RX et a` toute fonction continue
f : X N~ Y associe la fonction continue Rf : RX N~ RY , est un foncteur continu dans dCPO.

Notations On e'tend les notations dompsq, freepsq et sp`q aux e'tats r i pt, sq P RX enposant :

- domprq i dompsq ;- free

prq i freepsq ;-
rp`q i sp`q pour tout ` P domprq.

Ante'riorite' Comme pour les stores, on munit les e'tats d'une relation d'ante'riorite' r I^ r1de'finie pour tous

pt, sq, pt1, s1q P SX par :

pt, sq I^ pt1, s1q j s I^ s1 :

120 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Extension d'un e'tat De me^me, on de'finit l'extension extprq d'un e'tat r i pt, sq P RXen posant :

extppt, sqq i pt, extpsqq :
Cette notation est e'tendue au G-dcpo pRXqK en posant

extpKq i Kext
ptpt, squq i textppt, sqqu i tpt, extpsqqu

6:1:5 Le foncteur  dans CPOip

A tout cpo X on associe le cpo X de'fini par :

X i RX N~ RXK
L'inte're^t de la correspondance X ThN~ X re'side dans le fait que :

Proposition 6.12 (Re'solution du syste`me d'e'quations).Si

F est un cpo tel que F ' F , alors en posant V i TF et S i SF on a les isomorphismes(au sens des dcpo) :

V i TF ' Z \Gamma  L \Gamma  V \Theta  V \Gamma  F

S i SF i r^LPPfinpLq EnumpLcq \Theta  VL
F ' pV \Theta  Sq N~ pV \Theta  SqK

Fonctorialite' dans CPOip Soient X et Y des cpo. A` toute fle`che f : X N~ Y on associeune fle`che

f : X N~ Y de'finie de la manie`re suivante.
fl De'finition de \Gamma f : X N~ YPour tous

, P X et u P RY on pose

\Gamma f p,qpuq i #K si ,pRf

\Delta puqq i K

tRf \Gamma pu1qu si ,pRf \Delta puqq i tu1u

fl De'finition de \Delta f : Y N~ XPour tous

, P Y et u P RX on pose

\Delta f p,qpuq i #K si ,pRf

\Gamma puqq i K

tRf \Delta pu1qu si ,pRf \Gamma puqq i tu1u

Proposition 6.13.Pour toute injection-projection

f : X N~ Y , le couple f i ppf q\Gamma , pf q\Delta q est une injection-projection de
X dans Y . De plus, la fonction compose'e \Gamma f \Pi  \Delta f : Y N~ Y estcaracte'rise'e pour tous

, P Y et r P RY par :\Gamma 

\Gamma f \Pi  \Delta f \Phi p,qprq i #K si ,\Gamma Rf

\Pi prq\Phi  i K

tRf \Pi pr1qu si ,\Gamma Rf \Pi prq\Phi  i tr1u

en notant f \Pi  i f \Gamma  \Pi  f \Delta  P pY N~ Y q.

6.1. Construction du mode`le de MLimp dans les dcpo 121
De'monstration :(Calcul de

\Delta f \Pi  \Gamma f ) Soient , P X et r P RX.On distingue les deux cas suivants :

- ,prq i K. Dans ce cas, on a ,pRf \Delta pRf \Gamma prqqq i ,prq i K, soit

\Gamma f p,qpRf \Gamma prqq i K pcar ,pRf \Delta pRf \Gamma prqqq i Kq
d'ou`

\Delta f p\Gamma f p,qqprq i K pcar \Gamma f p,qpRf \Gamma prqq i Kq

et finalement \Delta f p\Gamma f p,qqprq i K i ,prq.-
,prq i tr1u. Dans ce cas, on a ,pRf \Delta pRf \Gamma prqqq i ,prq i tr1u, soit

\Gamma f p,qpRf \Gamma prqq i tRf \Gamma pr1qu pcar ,pRf \Delta pRf \Gamma prqqq i tr1uq
d'ou`

\Delta f p\Gamma f p,qqprq i tRf \Delta pRf \Gamma pr1qqu pcar \Gamma f p,qpRf \Gamma prqq i tRf \Gamma pr1quq
et finalement \Delta f p\Gamma f p,qqprq i tRf \Delta pRf \Gamma pr1qqu i tr1u i ,prq.Nous avons ainsi de'montre' que

\Delta f p\Gamma f p,qqprq i ,prq pour tout r P RX, d'ou` l'on tire
\Delta f p\Gamma f p,qq i ,, et finalement \Delta f \Pi  \Gamma f i idX .(Calcul de

\Gamma f \Pi  \Delta f ) Soient , P Y et r P RY .On distingue les deux cas suivants :

- ,pRf \Pi prqq i K. Dans ce cas, on a ,pRf \Gamma pRf \Delta prqqq i K, soit

\Delta f p,qpRf \Delta prqq i K pcar ,pRf \Gamma pRf \Delta prqqq i Kq
d'ou`

\Gamma f p\Delta f p,qqprq i K pcar \Delta f p,qpRf \Delta prqq i Kq

et finalement \Gamma f p\Delta f p,qqprq i K d^ ,prq.-
,pRf \Pi prqq i tr1u. Dans ce cas, on a ,pRf \Delta pRf \Gamma prqqq i tr1u, soit

\Delta f p,qpRf \Delta prqq i tRf \Delta pr1qu pcar ,pRf \Gamma pRf \Delta prqqq i tr1uq
d'ou`

\Gamma f p\Delta f p,qqprq i tRf \Gamma pRf \Delta pr1qqu pcar \Delta f p,qpRf \Delta prqq i tRf \Delta pr1quq
et finalement \Gamma f p\Delta f p,qqprq i tRf \Pi pr1qu d^ tRidY pr1qu i tr1u i ,prq.Nous avons ainsi de'montre' que

\Gamma f p\Delta f p,qqprq d^ ,prq pour tout r P RX, d'ou` l'on tire
\Gamma f p\Delta f p,qq d^ ,, et finalement \Gamma f \Pi  \Delta f d^ idX . (La formule permettant de calculer
p\Gamma f \Pi  \Delta f qp,qprq est imme'diate d'apre`s ce qui pre'ce`de.) oe

Proposition 6.14 (!-Cocontinuite' de ).Le foncteur

 : CPOip N~ CPOip est un foncteur !-cocontinu.

De'monstration :Soit

A i ppAiqiP!, pfi : Ai n~ Ai\Gamma 1qiP!q un !-diagramme dans CPOip, dont la colimite estnote'e
pA8, ff\Sigma q. Il s'agit d'apre`s la Proposition 5.6 de de'montrer quel/

iP!

p\Gamma ffi \Pi  \Delta ffiq i idA8 ,

122 Chapitre 6 - Se'mantique de'notationnelle de MLimp

soit encore que pour tous , P A8 et r P RA8 :l/

iP!

p\Gamma ffip\Delta ffip,qqqprq i ,prq

Par la Proposition 6.13, on a que la fonction compose'e \Gamma ffi \Pi  \Delta ffi : A8 N~ A8 estcaracte'rise'e pour tous

, P A8 et r P RA8 par :\Gamma 

\Gamma ffi \Pi  \Delta ffi\Phi p,qprq i #K si ,\Gamma Rff

\Pi i prq\Phi  i K

tRff\Pi i pr1qu si ,\Gamma Rff\Pi i prq\Phi  i tr1u

E'tant donne's , P A8 et r P RA8 fixe's, on distingue donc les deux cas suivants :- Soit

,pRff\Pi i prqq i K pour tout i P !. Dans ce cas, on a p\Gamma ffip\Delta ffip,qqqprq i K pourtout

i P !, soit l/

iP!

p\Gamma ffip\Delta ffip,qqqprq i K

Mais comme par ailleurs Z^iP! ff\Pi i i idA8, il de'coule de la continuite' du foncteur R etde la fonction

, P A8 que

,prq i l/

iP!

,pRff\Pi i prqq i K ,

d'ou` l'e'galite' recherche'e.- Soit il existe

i0 P ! tel que ,pRff\Pi i0prqq , K. Dans ce cas, on a ,pRff\Pi i prqq , K pourtout
i e^ i0, par monotonie. On pose alors ,pRff\Pi i prqq i tr1iu pour tout i e^ i0. Parconstruction, la suite

pr1iqie^i0 est croissante. On a alors :Z^

ie^i0p\Gamma ffip\Delta ffip,qqqprq i Z^ie^i0tRff\Pi i pr1iqu

i tRpZ^ie^i0 ffiqpZ^ie^i0 r1iqu

i tZ^ie^i0 r1iu i Z^ie^i0tr1iu
i Z^ie^i0 ,pRff\Pi i prqq i ,pZ^ie^i0 Rff\Pi i prqq i ,prq

d'ou` l'e'galite' recherche'e. oe

6:1:6 Re'solution

Nous avons vu a` la Proposition 6.12 que la re'solution du syste`me (**) se rame`ne a` lare'solution de l'e'quation

X i X, laquelle de'coule de la proposition suivante :

Proposition 6.15 (Point fixe du foncteur ).L'e'quation

X i pXq a une plus petite solution dans CPOip, qui est la colimite de l'!-diagramme

A i ppAiqiP!, pfi : Ai n~ Ai\Gamma 1qiP!q de'fini par :

A0 i 1 Ai\Gamma 1 i Ai

f0 i pKKpA0q, Kflq fi\Gamma 1 i fi

De'monstration :Corollaire des Propositions 5.7 et 6.14. oe

6.2. Le mode`le de MLimp dans G-dCPO et dans G-CPOip 123
6:2 Le mode`le de MLimp dans G-dCPO et dans G-CPOip

Dans cette section, nous reprenons la construction du mode`le de MLimp, en la conside'rantdans les cate'gories

G-dCPO et G-CPOip ou` G de'signe le groupe des permutations d'adressesa` support fini. Pour cela, nous commencons par pre'senter le groupe des permutations a`

support fini. Il suffira ensuite de de'corer chacunes des correspondances T, S, R et  avecl'action approprie'e et de ve'rifier qu'il s'agit bien de foncteurs dans

G-dCPO (pour T, S et R)et dans
G-CPOip (pour ).

6:2:1 Le groupe des permutations a` support fini

Permutations On appelle une permutation d'adresses (ou plus simplement une permu-tation) toute bijection de L dans L. L'ensemble des permutations d'adresses est note'

SpLq.

Support d'une permutation Pour toute permutation oe P SpLq, on appelle le supportde

oe et on note supppoeq l'ensemble de'fini par :

supppoeq i t` P L : oep`q , `u:
On remarque que :- supp

pidLq i ? ;- supp
poe\Delta 1q i supppoeq ;- supp
poe1 \Pi  oeq D^ supppoeq Y supppoe1q.

Permutations a` support fini D'apre`s ce qui pre'ce`de, il est clair que l'ensemble

G i toe P SpLq : supppoeq finiu
des permutations a` support fini constitue un sous-groupe du groupe SpLq des permutationsd'adresses. Dans ce qui suit, on ne conside'rera que des permutations a` support fini, et les

seules actions conside're'es seront de'finies sur le groupe G.
Cycles E'tant donne'es n adresses deux a` deux distinctes `1, : : : , `n (avec n e^ 1), on note
p`1 \Xi  \Xi  \Xi  `nq la permutation de'finie par :

p`1 \Xi  \Xi  \Xi  `nqp`iq i `i\Gamma 1
p`1 \Xi  \Xi  \Xi  `nqp`nq i `1

p`1 \Xi  \Xi  \Xi  `nqp`q i `

p1 d^ i a* nq
p` R t`1, : : : , `nuq
Par construction, on a suppp`1 \Xi  \Xi  \Xi  `nq i t`1, : : : , `nu, et p`1 \Xi  \Xi  \Xi  `nq\Delta 1 i p`n \Xi  \Xi  \Xi  `1q.Dans ce qui suit, on appelle un cycle d'ordre

n toute permutation de la forme p`1 \Xi  \Xi  \Xi  `nq,ou` les adresses
`1, : : : , `n sont deux a` deux distinctes. Dans le cas particulier ou` n i 2, onparle de transposition. (On notera e'galement que tous les cycles d'ordre 1 sont e'gaux a` la

permutation identite' : p`q i idL.)
Proposition 6.16 (De'composition des cycles).Pour tout cycle

p`1 \Xi  \Xi  \Xi  `nq et pour tout entier p P r1::ns :

p`1 \Xi  \Xi  \Xi  `nq i p`1 \Xi  \Xi  \Xi  `pq \Pi  p`p \Xi  \Xi  \Xi  `nq :

124 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Permutation fixe sur L Soit L un ensemble fini d'adresses. On dit qu'une permutation
oe P G est fixe sur L lorsque oep`q i ` pour tout ` P L (i.e. oe--L i idL). L'ensemble despermutations fixes sur

L, qui constitue un sous-groupe de G, est note' FixpLq :

FixpLq i toe P G : @` P L oepxq i xu :

Ensemble clos par l'action de groupe Soit X un G-dcpo quelconque. On dit qu'unsous-ensemble

E D^ X est clos par l'action de groupe (sur X) si pour tous x P E et oe P G ona
oex P E (en abre'ge' : G \Xi  E i E).

Les rotations d'adresses. . .
. . . sur les stores se'mantiques Soient deux stores s i pL, e, OEq et s1 i pL1, e1, OE1q telsque

s I^ s1, et soit n P ! l'unique entier tel qu'on ait L1 i L Y te0, : : : , en\Delta 1u et e1 i popnpeq.On note rot

ps, s1q le cycle d'ordre n \Gamma  1 de'fini par :

rotps, s1q i pe0 \Xi  \Xi  \Xi  enq :
Intuitivement la rotation d'adresses rotps, s1q de'cale d'un cran toutes les adresses e0, : : : , en\Delta 1alloue'es au cours du passage de

s a` s1, tandis qu'elle envoie l'adresse suivante en (pas encorealloue'e dans
s1) sur e0.Une conse'quence imme'diate de la Proposition 6.16 est la suivante :

Proposition 6.17.Pour tous

s, s1, s2 P SX tels que s I^ s1 et s1 I^ s2 on a

rotps, s2q i rotps, s1q \Pi  rotps1, s2q :

. . . sur les e'tats se'mantiques On e'tend la notation rotps, s1q a` tous les couples d'e'-tats

r i pt, sq et r1 i pt1, s1q tels que r I^ r1 (c'est-a`-dire tels que s I^ s1) en posantrot
pr, r1q i rotps, s1q. La` encore :

Proposition 6.18.Pour tous

r, r1, r2 P RX tels que r I^ r1 et r1 I^ r2 on a

rotpr, r2q i rotpr, r1q \Pi  rotpr1, r2q :

Sous-ensemble ferme' On rappelle que dans un dcpo X, un sous-ensemble F D^ X estferme' si :

(1) F est clos infe'rieurement :

@x, y P X px d^ y ^ y P F n~ x P F q :
(2) Toute chai^ne pxiqiP! d'e'le'ments de F a sa borne supe'rieure dans F e'galement :

@pxiqiP! P Chain(F) psup

iP! xiq P F

6.2. Le mode`le de MLimp dans G-dCPO et dans G-CPOip 125
6:2:2 Action des permutations d'adresses sur le mode`le de MLimp

Avant tout, on rappelle que les foncteurs T, S, R et  sont de'finis par :

TX i Z \Gamma  L \Gamma  pTX \Theta  TXq \Gamma  X

SX i r^LPPfinpLq EnumpLcq \Theta  pTXqL

RX i TX \Theta  SX
X i RX N~ RXK

Fonctorialite' de T, S et R dans G-dCPO Dans un premier temps, on conside'reradonc les dcpo discrets X , A,

Z et L pour montrer qu'ils peuvent e^tre muni d'une structurede
G-dcpo. A` partir de la` et e'tant donne'e une action associe'e au dcpo X, on pourra de'finirles actions associe'es a` T, S et R.

Lemme 6.4 (X , A, Z, L, P G-dCPO).Les structures X , A,

Z et L sont des G-dcpo discrets.

De'monstration :Action de

G sur X , A et Z : oex i x (idem pour ff et n). Action de G sur L : oe` i oep`q.oe

Soit actX l'action associe'e au G-dcpo X. Puisque G-dCPO est une cate'gorie bi-carte'sienne,les dcpo T

X, SX et RX peuvent chacun e^tre munis d'une structure de G-dcpo dont les actionsrespectives sont donne'es inductivement par :

actTX oeT

X intpnq i n

oeTX addrp`q i addrpoe`q

oeTX pairpv1, v2q i pairpoeTX v1, oeTXv2q

oeTX basepxq i basepoeXxq

actSX oeS

X pL, e, 'q i poeL, oee, oeTX \Pi  ' \Pi  oe\Delta 1q

actRX oeR

X pt, sq i poeTX t, oeSX sq

ou` on a utilise' la notation oeffx pour de'signer l'e'le'ment ffpoe, xq.

Proposition 6.19.Si

f : X N~ Y est G-invariante, alors Tf , Sf et Rf sont G-invariantes.

De'monstration :On rappelle que S

f pL, e, 'q i pL, e, Tf \Pi  'q et Rf pt, sq i pTf ptq, Sf psqq. Il suffit donc deve'rifier que si
f est G-invariante (*), alors oeTY pTf ptqq i Tf poeTX tq pour tout t P TX.

oepTf pintpnqqq i oeintpnq i intpnq i Tf pintpnqq i Tf poeintpnqq
oepTf paddrp`qqq i oeaddrp`q i addrpoe`q i Tf paddrpoe`qq i Tf poeaddrp`qq

126 Chapitre 6 - Se'mantique de'notationnelle de MLimp

oepTf ppairpt1, t2qqq i oepairpTf pt1q, Tf pt2qq

i pairpoepTf pt1qq, oepTf pt2qqq
i pairpTf poet1q, Tf poet2qq pHIq
i Tf ppairpoet1, oet2qq
i Tf poepairpt1, t2qq

oepTf pbasepxqqq i oebasepf pxqq

i basepoepf pxqqq
i basepf poexqq p\Sigma q
i Tf pbasepoexqq
i Tf poebasepxqq oe

Fonctorialite' de  dans G-CPOip De me^me, en suivant la de'finition de l'espace desfonctions entre

G-dcpo, on remarque qu'on peut munir le cpo X d'une action qui est donne'epar :

actX oeX f i t:u \Pi  oeRX \Pi  f \Pi  oe\Delta 1RX
Proposition 6.20.Si

f : X n~ Y est une injection-projection G-invariante, alors f : X n~ Y est e'galementune injection-projection

G-invariante.

De'monstration :C'est une conse'quence de la proposition pre'ce'dente. En effet, si

f : X n~ Y est uneinjection-projection
G-invariante, alors f \Gamma  : X N~ Y et f \Delta  : Y N~ X sont deux fonctions
G-invariantes. Par conse'quent,

Rf \Gamma  : RX N~ RYR

f \Delta  : RY N~ RX

sont deux fonctions G-invariantes. On montre maintenant que \Gamma f et \Delta f sont G-invariantes,i.e. que pour toute fonction continue

,, si , P X alors oep\Gamma f p,qq i \Gamma f poe,q, et si , P Yalors
oep\Delta f p,qq i \Delta f poe,q.On rappelle d'abord que, par de'finition,

oep\Gamma f p,qq i oe \Pi  p\Gamma f p,qq \Pi  oe\Delta 1 p\Sigma q
de me^me que :

fl De'finition de \Gamma f : X N~ YPour tous

, P X et u P RY on pose

\Gamma f p,qpuq i #K si ,pRf

\Delta puqq i K

tRf \Gamma pu1qu si ,pRf \Delta puqq i tu1u

6.2. Le mode`le de MLimp dans G-dCPO et dans G-CPOip 127
fl De'finition de \Delta f : Y N~ XPour tous

, P Y et u P RX on pose

\Delta f p,qpuq i #K si ,pRf

\Gamma puqq i K

tRf \Delta pu1qu si ,pRf \Gamma puqq i tu1u
Supposons que , P X et montrons que oep\Gamma f p,qq i \Gamma f poe,q. Par (*), il s'agit demontrer que

\Gamma f poe,qpuq i oep\Gamma f p,qpoe\Delta 1uqq pour tout u P RX. On distingue deux cas :- soit
poe,qpRf \Delta puqq i K, auquel cas \Gamma f poe,qpuq i K. Par de'finition de oe, et par G-invariance de R

f \Delta , on a e'galement :

oep,pRf \Delta poe\Delta 1uqqq i poe \Pi  , \Pi  oe\Delta 1qpRf \Delta puqq i poe,qpRf \Delta puqq i K
et donc :

,pRf \Delta poe\Delta 1uqq i oe\Delta 1K i K

d'ou` \Gamma f p,qpoe\Delta 1uq i K et finalement oep\Gamma f p,qpoe\Delta 1uqq i K, ce qui permet d'obtenirl'e'galite' voulue.

- soit poe,qpRf \Delta puqq i tu1u, auquel cas \Gamma f poe,qpuq i tRf \Gamma pu1qu. Par de'finition de oe, etpar

G-invariance de Rf \Delta , on a e'galement :

oep,pRf \Delta poe\Delta 1uqqq i poe \Pi  , \Pi  oe\Delta 1qpRf \Delta puqq i poe,qpRf \Delta puqq i tu1u
et donc :

,pRf \Delta poe\Delta 1uqq i toe\Delta 1u1u

d'ou` \Gamma f p,qpoe\Delta 1uq i tRf \Gamma poe\Delta 1u1qu. Finalement, par G-invariance de Rf \Gamma , on peutconclure que

oep\Gamma f p,qpoe\Delta 1uqq i tRf \Gamma pu1qu, ce qui permet d'obtenir l'e'galite' voulue.

Supposons maintenant que , P Y et montrons que oep\Delta f p,qq i \Delta f poe,q. Par (*), ils'agit de montrer que

\Delta f poe,qpuq i oep\Delta f p,qpoe\Delta 1uqq pour tout u P RY . On distingue deuxcas :

- soit poe,qpRf \Gamma puqq i K, auquel cas \Delta f poe,qpuq i K. Par de'finition de oe, et par G-invariance de R

f \Gamma , on a e'galement :

oep,pRf \Gamma poe\Delta 1uqqq i poe \Pi  , \Pi  oe\Delta 1qpRf \Gamma puqq i poe,qpRf \Gamma puqq i K
et donc :

,pRf \Gamma poe\Delta 1uqq i oe\Delta 1K i K

d'ou` \Delta f p,qpoe\Delta 1uq i K et finalement oep\Delta f p,qpoe\Delta 1uqq i K, ce qui permet d'obtenirl'e'galite' voulue.

- soit poe,qpRf \Gamma puqq i tu1u, auquel cas \Delta f poe,qpuq i tRf \Delta pu1qu. Par de'finition de oe, etpar

G-invariance de Rf \Gamma , on a e'galement :

oep,pRf \Gamma poe\Delta 1uqqq i poe \Pi  , \Pi  oe\Delta 1qpRf \Gamma puqq i poe,qpRf \Gamma puqq i tu1u
et donc :

,pRf \Gamma poe\Delta 1uqq i toe\Delta 1u1u

d'ou` \Delta f p,qpoe\Delta 1uq i tRf \Delta poe\Delta 1u1qu et finalement, par G-invariance de Rf \Delta , on peutconclure que

oep\Delta f p,qpoe\Delta 1uqq i tRf \Delta pu1qu, ce qui permet d'obtenir l'e'galite' voulue. oe

128 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Point-fixe de  dans G-dCPO On conside`re maintenant la structure pA8, pffiqiP!q,colimite dans CPOip du diagramme

A i ppAiqiP!, pfi : Ai n~ Ai\Gamma 1qiP!q qui est de'fini induc-tivement par :

A0 i 1 Ai\Gamma 1 i Ai

f0 i pKKpA0q, Kflq fi\Gamma 1 i fi

On ve'rifie aise'ment que A0 est un G-cpo dont l'action est donne' par Kfl et que l'injection-projection

f0 est G-invariante. Par la Proposition 6.20, on en de'duit imme'diatement que Aest un
!-diagramme dans G-CPOip. Il s'ensuit, par la Proposition 5.10, que pA8, pffiqiP!q estun coco^ne de

A dans G-CPOip. (On aurait e'ventuellement pu montrer qu'il s'agit me^me d'unecolimite, mais cela n'est pas utile pour la suite.) On peut donc conclure que :

Proposition 6.21.
A8 est un G-cpo dont l'action est donne'e par : oev i poeviqiP!

Proposition 6.22.L'isomorphisme

A8 ' A8 dans CPOip constitue un isomorphisme dans G-dCPO.

De'monstration :Par le Lemme 5.4, cet isomorphisme est donne' par

u\Gamma  ou` u : A8 n~ A8 est l'isomor-phisme de coco^ne donne' par la Proposition 5.4. Par de'finition,

u i pu\Gamma , u\Delta q et :

u\Gamma pvq i sup

iP! 

\Gamma ffipviq et u\Delta pcq i \Gamma \Delta ffipcq\Phi 

iP!

pour tout v P A8 et c P A8. Puisque les ffi sont G-invariantes, la Proposition 6.20 garantitque

\Gamma ffi et \Delta ffi sont G-invariantes. On peut conclure par la Proposition 5.9 que u\Gamma  et u\Delta sont

G-invariantes. oe

Actions de G sur les valeurs et les stores On rappelle que les dcpo V et S sontde'finis par

V i TA8 et S i SA8. Il s'ensuit imme'diatement que V et S sont des G-dcpodont les actions sont donne'es respectivement par :

actV oeintpnq i n

oeaddrp`q i addrpoep`qq
oepairpv1, v2q i pairpoev1, oev2q

oebasepf q i basepoe \Pi  f \Pi  oe\Delta 1q

actS oepL, e, 'q i poeL, oe \Pi  e, oe \Pi  ' \Pi  oe\Delta 1q

Par de'finition, on obtient que poesqp`q i oepspoe\Delta 1`qq et que oeps\Gamma t` ThN~ vuq i oes\Gamma toe` ThN~ oevu.De plus, on ve'rifie imme'diatement le lemme suivant :

Lemme 6.5.Quels que soient

` P L, L P PfinpLq et oe P FixpLq, on a :1.

e P EnumpLcq implique oee P EnumpoeLcq ;2.
` P s ssi oe` P oes ;
3. oefreepsq i freepoesq (G-invariance de free) ;4.

oeextpsq i extpoesq (G-invariance de ext).

6.3. Interpre'tation de'notationnelle de MLimp 129
6:3 Interpre'tation de'notationnelle de MLimp

Dans cette section, nous interpre'tons le langage MLimp (et le langage de programmationsymbolique qui lui est associe' dans MLDL) dans la cate'gorie

G-dCPO, a` l'aide des G-dcpo Vet
S. Nous e'tablirons ensuite les re'sultats de correction en montrant que la cate'gorie G-dCPOest un mode`le de'notationnel de ML

imp, a` la fois vis-a`-vis de sa se'mantique ope'rationnelle(Proposition 6.29) et vis-a`-vis de la re'duction symbolique (Proposition 6.31).

6:3:1 La fonction d'interpre'tation

Dans un premier temps, on interpre`te le langage de programmation concret MLimp. Celasignifie que nous n'avons pas a` conside'rer les noms abstraits d'adresses.

Les valuations Les valuations ont pour ro^le de clore les programmes en substituant leursvariables libres par des valeurs. Une valuation est donc une fonction dont le domaine est un

ensemble fini de variables. Le dcpo des valuations, dont les e'le'ments seront note's ae, ae1, etc,est naturellement donne' par :

VAL i y"

XPPfinpX q

VX

(Le fait que X soit un dcpo discret garantit que toute valuation est une fonction continue.)E'tant donne'e une valuation

ae, on note ae; x ThN~ v la valuation de'finie par :

pae; y ThN~ vqpxq i #v si x , yaepyq sinon

Clo^ture d'un programme par une valuation On dira que la valuation ae P VAL clo^tle programme

p lorsque toutes les variables libres de p sont dans le domaine de ae :

FVppq D^ dompaeq

Action du groupe G Le dcpo des valuations peut naturellement e^tre muni d'une actionqui est donne'e par

oeae i oe \Pi  ae. (Comme dans le cas des e'nume'rations, l'action par conjugaisona pu e^tre simplifie'e car X

XL i ?.) Par ailleurs, on remarque que oepae; x ThN~ vq i poeaeq; x ThN~ oev.

Interpre'tation des programmes de MLimp Pour e^tre e'value', un programme doite^tre place' dans un store. Son e'valuation peut alors renvoyer un re'sultat (un e'tat

v ffi s), oubien ne pas terminer. Il est donc naturel d'interpre'ter les programmes clos par des e'le'ments

de l'espace des fonctions continues P j S N~ pV \Theta  SqK, l'e'le'ment K repre'sentant la nonterminaison de l'e'valuation.

De'finition 6.3.1 (Interpre'tation des programmes).L'interpre'tation d'un programme

p dans une valuation ae P VAL qui clo^t p est donne'e par lafonction continue J
pKae P P de'finie par induction sur la structure de p a` l'aide des e'quationsde la Figure 6.1.

130 Chapitre 6 - Se'mantique de'notationnelle de MLimp

JnKaepsq i tpintpnq, squ J`Kaepsq i tpaddrp`q, squ JxKaepsq i tpaepxq, squ

Jfpp1, : : : , pkqKaeps0q i

$'''''''''&

'''''''''%

tpintp~fpn1, : : : , nkqq, skqu si pour tout i, 1 d^ i d^ k,J

piKaepsi\Delta 1q i tpintpniq, siqu
tpintp0q, skqu si pour tout i, 1 d^ i d^ k,

il existe inji P taddr, pair, baseu tq.J

piKaepsi\Delta 1q i tpinjipviq, siqu
K sinon

Jpp1, p2qKaepsq i #tppairpv1, v2q, s2qu si Jp1Kaepsq i tpv1, s1qu et Jp2Kaeps1q i tpv2, s2quK sinon

JfstppqKaepsq i $'&'%

tpv1, s1qu si JpKaepsq i tppairpv1, v2q, s1qu
tpintp0q, s1qu si JpKaepsq i tpinjpvq, s1qu, inj P tint, addr, baseu
K sinon

JsndppqKaepsq i $'&'%

tpv2, s1qu si JpKaepsq i tppairpv1, v2q, s1qu
tpintp0q, s1qu si JpKaepsq i tpinjpvq, s1qu, inj P tint, addr, baseu
K sinon

Jp1 i p2Kaepsq i $'&'%

tpintpEqupv1, v2qq, s2qu si Jp1Kaepsq i tpv1, s1qu etJ

p2Kaeps1q i tpv2, s2qu
K sinon

Jif p then q1 else q2Kaepsq i

$''''''&

''''''%J

q1Kaeps1q si JpKaepsq i tpintpnq, s1qu et n , 0J
q2Kaeps1q si JpKaepsq i tpintp0q, s1qu
tpintp0q, s1qu si JpKaepsq i tpinjpvq, s1qu et

inj P taddr, pair, baseu
K sinon

Figure 6.1 - Interpre'tation des programmes de MLimp - (1/2)

6.3. Interpre'tation de'notationnelle de MLimp 131
J*x: pKaepsq i tpbasepf q, squ ou` f est la fonction pv, s1q ThN~ JpKae;xThN~vps1q

Jp1 p2Kaepsq i $''''&''''%

f pv, s2q si Jp1Kaepsq i tpbasepf q, s1qu et Jp2Kaeps1q i tpv, s2qu
tpintp0q, s2qu si Jp1Kaepsq i tpinjpvq, s1qu, inj P tint, addr, pairu etJ

p2Kaeps1q i tpv, s2qu
K sinonJ

ref pKaepsq i #tpaddrpfreeps

1q0q, extps1q\Gamma tfreeps1q0 ThN~ vuqu si JpKaepsq i tpv, s1qu

K sinon

Jp :i qKaepsq i

$'''''''''&

'''''''''%

tpintp0q, s2 \Gamma t` ThN~ vuqu si JpKaepsq i tpaddrp`q, s1qu,J

qKaeps1q i tpv, s2qu et ` P domps2q
tpintp0q, s2qu si JpKaepsq i tpinjpv1q, s1qu,J

qKaeps1q i tpv2, s2qu et soit inj , addr
soit inj i addr et v1 R domps2q
K sinon

J!pKaepsq i $''''&''''%

tps1p`q, s1qu si JpKaepsq i tpaddrp`q, s1qu, ` P domps1q
tpintp0q, s1qu si JpKaepsq i tpaddrp`q, s1qu et ` R domps1q ou siJ

pKaepsq i tpinjpvq, s1qu, inj P tint, pair, baseu
K sinon

Figure 6.1 - Interpre'tation des programmes de MLimp - (2/2)

132 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Proposition 6.23 (Continuite' de l'interpre'tation des programmes).Pour tout programme

p, la fonction JpK : VAL \Theta  S N~ pV \Theta  SqK est continue.

De'monstration :
Monotonie Il s'agit essentiellement de montrer par induction sur p, que quels que soient
ae, ae1 P VAL et s, s1 P S, si ae d^ ae1 et s d^ s1 alors JpKaepsq d^ JpKae1ps1q. La plupart des cass'obtiennent imme'diatement par l'hypothe`se d'induction et la de'finition <<par point>> de l'ordre

sur V \Theta  S. Les autres cas sont de'taille's ci-dessous :-

p j pp1 i p2q : le re'sultat de'coule de l'hypothe`se d'induction ainsi que de la continuite'de la fonction Equ (Proposition 6.6).

- p j *x: q : on a JpKaepsq i tpbasepf q, squ et JpKae1ps1q i tpbasepf 1q, s1qu avec f i

pv0, s0q ThN~ JqKae;xThN~v0ps0q et f 1 i pv0, s0q ThN~ JqKae1;xThN~v0ps0q. Par hypothe`se d'inductionon a donc que J

qKae;xThN~v0ps0q d^ JqKae1;xThN~v0ps0q. D'ou` f d^ f 1.

- p j p1 p2 : avec Jp1Kaeptsuq i tpbasepf q, s1qu et Jp2Kaeps1q i tpv, s2qu. L'hypothe`sed'induction donne J

p1Kae1 ps1q i tpbasepf 1q, s11qu et Jp2Kae1pts11uq i tpv1, s12qu avec f d^ f 1,
v d^ v1, s1 d^ s11 et s2 d^ s12. D'ou` l'on peut conclure, par continuite' de f et f 1 que :J

pKaepsq i f pv, s2q d^ f pv1, s12q d^ f 1pv1, s12q i JpKaeps1q.

- p j ref q : avec JqKaeptsuq i tpv, pL, e, 'qqu. Par (HI), il vient JqKae1 ps1q i tpv1, pL, e, '1qqu,avec

v d^ v1 et ' d^ '1, d'ou` l'on peut conclure :J

pKaepsq i tpeo, pL, '\Gamma teo ThN~ vuqqu

d^ tpeo, pL, '1 \Gamma teo ThN~ v1uqqu (Lemme 6.3)
i JpKae1 ps1q

- p j pp1 :i p2q : avec Jp1Kaepsq i tpaddrp`q, s1qu, Jp2Kaeps1q i tpv, pL, e, 'qqu et ` P L.Par (HI), on a que J

p1Kae1ps1q i tpaddrp`q, s11qu avec s1 d^ s11, Jp2Kae1 ps11q i tpv1, pL, e, '1qquavec
v d^ v1, et ' d^ '1. Par conse'quent :J

pKaepsq i tpintp0q, pL, '\Gamma t` ThN~ vuqqu

d^ tpintp0q, pL, '1 \Gamma t` ThN~ v1uqqu (Lemme 6.3)
i JpKae1ps1q

- p j !q : avec JqKaepsq i tpaddrp`q, s1qu et ` P domps1q. L'hypothe`se d'induction donneJ

qKae1ps1q i tpaddrp`q, s11qu, avec domps1q i domps11q et ss3ps1q d^ ss3ps11q. Par conse'quent :J
pKaepsq i tpss3ps1qp`q, s1qu d^ tpss3ps11qp`q, s11qu i JpKae1 ps1q.

Continuite' (Continuite' sur le deuxie`me argument) Il s'agit de montrer par inductionsur

p que pour toute valuation ae et pour toute !-chai^ne psiqiP! P S!, on a bien :J

pKaepl/

iP!

siq i l/

iP! J

pKaepsiq

La plupart des cas reposent exclusivement sur la continuite' de la fonction t:u, de la de'fi-nition de l'ordre par point sur

V \Theta  S et de l'hypothe`se d'induction. Les autres sont de'taille'sci-dessous :

6.3. Interpre'tation de'notationnelle de MLimp 133
- p j pref qq : on distingue deux cas :- soit pour tout

i P !, JqKaepsiq i K, auquel cas JqKaepZ^iP! siq i K i Z^iP!JqKaepsiq. Etfinalement, Jref

qKaepsiq i K i Z^iP!Jref qKaepsiq.

- soit JqKaepZ^iP! siq ipHIq Z^iP!JqKaepsiq i tpZ^ie^j vi, Z^ie^jpL, e, 'iqqu avec j P !, pviqie^jet

p'iqie^j des !-chai^nes, et JqKaepsiq i tpvi, pL, e, 'iqqu pour tout i e^ j, et JqKaepsiq i Kpour

i a* j. Par conse'quent :J

ref qKaepZ^iP! siq i tpaddrpe0q, pL, e, pZ^ie^j 'iq\Gamma te0 ThN~ Z^ie^j viuqqu

i Z^ie^jtpaddrpe0q, pL, e, 'i \Gamma te0 ThN~ viuqqu
i Z^iP!Jref qKaepsiq

- p j pp1 :i p2q :- si J

p1KaepZ^iP! siq ipHIq Z^iP!Jp1Kaepsiq n'est pas de la forme tpaddrp`q, s1qu, ou siJ
p2Kaeps1q i K ou si Jp2Kaeps1q i tpv, s2qu mais que ` R domps2q : imme'diat.

- si Jp1KaepZ^iP! siq ipHIq Z^iP!Jp1Kaepsiq i tpaddrp`q, pL, e, Z^ie^j 'iqqu pour j P !,J

p2KaeppL, e, Z^ie^j 'iqq i Z^iP!Jp2KaeppL, e, 'iqq i tpZ^ie^j1 vi, pL1, e1, Z^ie^j1 '1iqqu pour
j1 P ! et ` P L1, alors p'iqiPj, p'1iqiPj1 et pviqiPj1 sont des !-chai^nes. Par conse'quent :J

p1 :i p2KaepZ^iP! siq i tpintp0q, pL1, e1, pZ^ie^j '1iq\Gamma t` ThN~ Z^ie^j viuqqu

i Z^ie^jtpintp0q, pL1, e1, '1i \Gamma  t` ThN~ viuqqu
i Z^iP!Jp1 :i p2Kaepsiq

- p j p!qq : on distingue deux cas :- soit J

qKaepZ^iP! siq ipHIq Z^iP!JqKaepsiq n'est pas de la forme tpaddrp`q, squ, auquel casJ!
qKaepsiq i K i Z^iP!J!qKaepsiq (car, par monotonie, aucun des J!qKaepsiq n'est de cetteforme). Idem si

` R dompsq (car pour tout i P !, dompsiq i dompsi\Gamma 1q).

- soit JqKaepZ^iP! siq ipHIq Z^iP!JqKaepsiq i tpaddrp`q, pL, e, Z^ie^j 'iqqu pour un j P !,avec J

qKaepsiq i tpaddrp`q, pL, e, 'iqqu si i e^ j, JqKaepsiq i K si i a* j et p'iqiP! une
!-chai^ne. Alors :J

!qKaepl/

iP!

siq i tppl/

ie^j

'iqp`q, pL, e, l/

ie^j

'iqqu i l/

ie^j

tp'ip`q, pL, e, 'iqqu i l/

iP! J!

qKaepsiq

(Continuite' sur le premier argument) Il s'agit de montrer par induction sur p que pourtout store

s et pour toute !-chai^ne paeiqiP! P VAL!, on a bien :J

pKZ^iP! aeipsq i l/

iP! J

pKaeipsq

La plupart des cas reposent exclusivement sur la continuite' de la fonction t:u, de la de'fi-nition de l'ordre par point sur

V \Theta  S et de l'hypothe`se d'induction. Les autres sont de'taille'sci-dessous :

- p j pref qq : si JqKZ^iP! aeipsq ipHIq Z^iP!JqKaeipsq i tpZ^ie^j vi, Z^ie^jpL, e, 'iqqu avec j P !,et J

qKaeipsq i tpvi, pL, e, 'iqqu pour tout i e^ j. Alors, pviqie^j et p'iqie^j sont des !-chai^nes :J

ref qKZ^iP! aeipsq i tpaddrpe0q, pL, e, pZ^ie^j 'iq\Gamma te0 ThN~ Z^ie^j viuqqu

i Z^ie^jtpaddrpe0q, pL, e, 'i \Gamma te0 ThN~ viuqqu
i Z^iP!Jref qKaeipsq

134 Chapitre 6 - Se'mantique de'notationnelle de MLimp

- p j pp1 :i p2q : si Jp1KZ^iP! aeipsq ipHIq Z^iP!Jp1Kaepsiq i tpaddrp`q, pL, e, Z^ie^j 'iqqu,J

p2KZ^iP! aeippL, e, Z^ie^j 'iqq ipHIq Z^iP!Jp2KaeippL, e, Z^ie^j 'iqq

i tpZ^ie^j1 vi, pL1, e1, Z^ie^j1 '1iqqu

et ` P L1, alors p'iqiPj, p'1iqiPj1 et pviqiPj1 sont des !-chai^nes, et :J

p1 :i p2KZ^iP! aeipsq i tpintp0q, pL1, e1, pZ^ie^j1 '1iq\Gamma t` ThN~ Z^ie^j1 viuqqu

i Z^ie^j1 tpintp0q, pL1, e1, '1i \Gamma t` ThN~ viuqqu
i Z^iP!Jp1 :i p2Kaeipsq

- p j !q : si JqKZ^iP! aeipsq ipHIq Z^iP!JqKaepsq i tpaddrp`q, pL, e, Z^ie^j 'iqqu pour un j P !,alors

p'iqiPj est une !-chai^ne et :J

!qKZ^iP! aeipsq i tppl/

ie^j

'iqp`q, pL, e, l/

ie^j

'iqqu i l/

ie^j

tp'ip`q, pL, e, 'iqqu i l/

iP! J!

qKZ^iP! aeipsq

Puisqu'elle est continue en chacun de ses arguments, la fonction JpK : VAL \Theta  S N~ pV \Theta  SqKest une fonction continue (Proposition 5.1). oe

Remarque 6.3.1. L'ensemble P des programmes de MLimp peut e^tre conside're' comme un dcpodiscret. La fonction d'interpre'tation J

:K : P \Theta  VAL \Theta  S Y'N~ pV \Theta  SqK est donc clairementcontinue. De plus, on ve'rifie aise'ment le lemme suivant :

Lemme 6.6.Soit

p un programme et ae, ae1 P VAL des valuations qui closent p. Si aepxq i ae1pxq pour toutevariable

x P FVppq, alors JpKae i JpKae1 .

Corollaire 6.23.1.Si

p est un programme clos, alors pour toutes valuations ae, ae1 P VAL, JpKae i JpKae1 .

Par ailleurs, on ve'rifie imme'diatement que l'interpre'tation des valeurs closes ne de'pendpas du store :

Proposition 6.24 (De'notation des valeurs closes).Soit

v P V une valeur close. Alors il existe une unique valeur v1 P V telle que pour toutevaluation

ae P VAL et tout store s P S, JvKaepsq i tpv1, squ.

Remarque 6.3.2. Une valeur close n'est pas ne'cessairement identique a` sa de'notation. Parexemple, la de'notation de la valeur fonctionnelle

*x: p3 \Gamma  1qx est donne'e par la fonction
v, s ThN~ tp4v, squ. Ainsi, toutes les valeurs *x: p3 \Gamma  1qx, *x: 4x, *x: p8 \Lambda  2qx, etc, ont la me^mede'notation. C'est pre'cise'ment pour cette raison que nous avons choisi un mode`le de'notationnel. Celui-ci peut donc refle'ter a` la fois la se'mantique ope'rationnelle (e'valuation de te^tefaible) et l'e'valuation symbolique (passage a` tous les contextes).

E'tant donne'e une valeur close v P V, on appellera de'notation de v et on notera Denpvq,l'unique valeur

w P V telle que pour toute valuation ae P VAL, JvKaeps?q i tpw, s?qu ou` s?de'signe n'importe quel store

s tel que dompsq i ?.

6.3. Interpre'tation de'notationnelle de MLimp 135
Interpre'tation des programmes symboliques Pour interpre'ter les programmessymboliques, il suffit d'e'tendre les valutions aux noms d'adresses et de modifier la de'finition

de la fonction d'interpre'tation.
Valuations symboliques Les noms d'adresses constituent un second jeu de variablesqui sont soumises a` des contraintes supple'mentaires : les noms (utilise's par un programme)
de'notent tous des adresses me'moires, deux noms distincts (utilise's par un programme) de'no-tent des adresses me'moire distinctes et finalement si un nom est utilise', alors l'adresse qu'il
de'note est alloue'e dans le store courant. La nouvelle de'finition des valuations ne tient pascompte de cette dernie`re condition qui sera ve'rifie'e a posteriori -- voir les proprie'te's de bonne
de'finition dans un store (plus bas dans la section Interpre'tation des stores syntaxiques) ainsiqu'a` travers la notion de domination (Section 6.4.4).

De'sormais, une valuation est non seulement de'finie sur les variables libres d'un programme(auxquelles elle associe des valeurs), mais e'galement sur ses noms d'adresses, auxquelles elle
associe des adresses concre`tes de manie`re a` ce que deux noms distincts soient interpre'te's pardeux adresses distinctes. Formellement, le dcpo des valuations est de'fini par :

VALsym i $&%f P y"

EPPfinpX \Gamma Aq

VE -- f--A est injective,.-

(Le fait qu'il s'agisse bien d'un dcpo de'pend du fait que A et L sont des dcpo discrets.) Onve'rifie aise'ment que :

Lemme 6.7.VAL

sym est un G-dcpo dont l'action est donne'e par : oeae i oe \Pi  ae.

Interpre'tation et clo^ture par une valuation On dira qu'une valuation symbolique
ae P VALsym clo^t un programme symbolique p lorsque toutes les variables libres et nomsd'adresses de

p sont dans le domaine de ae i.e. FVppq Y FNppq D^ dompaeq. Pour ce qui estde l'interpre'tation des programmes symboliques (de'finie pour une valuation

ae P VALsym quiclo^t
p), il suffit de remplacer le cas des adresses concre`tes J`Kaepsq i tpaddrp`q, squ de la Fig-ure 6.1 par le cas des noms d'adresses :J

ffKaepsq i tpaddrpaepffqq, squ
Lemme 6.8.Soit

p un programme symbolique et ae, ae1 P VALsym deux valuations qui closent p. Si pourtoute variable

x P FVppq et tout nom ff P FNppq on a aepxq i ae1pxq et aepffq i ae1pffq, alors,J
pKae i JpKae1 .

Corollaire 6.24.1.Si

p est un programme clos, alors pour toutes valuations ae, ae1 P VALsym, JpKae i JpKae1 .

Continuite' et G-invariance Puisque A et L sont des dcpo discrets, alors on ve'rifieaise'ment que pour tout programme symbolique

p, la fonction JpK : VALsym \Theta  S N~ pV \Theta  SqK estune fonction continue. (Si
paeiqiP! est une !-chai^ne de valuations, alors pour tout ff et i P !,
aeipffq i aei\Gamma 1pffq.) En fait, on peut me^me ve'rifier que la fonction JpK est G-invariante :

136 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Proposition 6.25 (G-invariance de l'interpre'tation).Pour tout programme symbolique

p, la fonction JpK : VALsym \Theta S N~ pV \Theta SqK est G-invariante,en ce sens que pour toute valuation

ae P VALsym , pour tout store s P S et pour toute permu-tation
oe P G on a : oepJpKaepsqq i JpKoeaepoesq.

De'monstration :On raisonne par induction sur

p.
p j ff : oepJffKaepsqq i oetpaddrp`q, squ i tpaddrpoe`q, oesqu i JffKoeaepoesq.

p j *x: q : on a oepJpKaepsqq i tpbasepoef q, oesqu et JpKoeaepoesq i tpbasepgq, oesqu, ou` f i

pv0, s0q ThN~ JqKae;xThN~v0ps0q et g i pv0, s0q ThN~ JqKoeae;xThN~v0ps0q. Il suffit de ve'rifier que oef i g :

oef i oe \Pi  f \Pi  oe\Delta 1 i pv0, s0q ThN~ oepJqKae;xThN~oe\Delta 1v0poe\Delta 1s0qq

i pv0, s0q ThN~ JqKoeae;xThN~oeoe\Delta 1v0poeoe\Delta 1s0q (HI)
i pv0, s0q ThN~ JqKoeae;xThN~v0ps0q
i g

p j pp1 p2q : on a Jp1Kaepsq i tpbasepf q, s1qu et Jp2Kaeps1q i tpv, s2qu ssi par hypothe`sed'induction J

p1Koeaepoesq i tpbasepoef q, oes1qu et Jp2Koeaepoesq i tpoev, oes2qu. Par suite :

oepJpKaepsqq i oe \Pi  f pv, s2q

i oe \Pi  f \Pi  oe\Delta 1poev, oes2q
i poef qpoev, oes2q paction de f q
i JpKoeaepoesq

p j ref q : on a JqKaepsq i tpv, s1qu ssi par hypothe`se d'induction JqKoeaepoesq i tpoev, oes1qu.Par suite :

oepJref qKaepsqq i oetpfreeps1q0, extps1q\Gamma tfreeps1q0 ThN~ oevuqu

i tpaddrpoefreeps1q0q, oes1 \Gamma toefreeps1q0 ThN~ oevuqu
i tpaddrpfreepoes1q0q, oes1 \Gamma tfreepoes1q0 ThN~ oevuqu pLemme 6:5q
i Jref qKoeaepoesq

p j pp1 :i p2q : on a Jp1Kaepsq i tpaddrp`q, s1qu, Jp2Kaeps1q i tpv, s2qu avec ` P domps2qssi (par hypothe`se d'induction) J

p1Koeaepoesq i tpaddrpoe`q, oes1qu, Jp2Koeaepoesq i tpoev, oes2quet
oe` P dompoes1q. Par suite :

oepJpKaepsqq i tpintp0q, oes2 \Gamma toe` ThN~ oevuqu i JpKoeaepoesq
p j !q : on a JqKaepsq i tpaddrp`q, s1qu et ` P domps1q ssi par hypothe`se d'inductionJ

qKoeaepoesq i tpaddrpoe`q, oes1qu et oe` P dompoes1q. Finalement :

oepJpKaepsqq i oetps1p`q, s1qu

i tpoe \Pi  s1p`q, oes1qu
i tpoe \Pi  s1 \Pi  oe\Delta 1poe`q, oes1qu
i tppoes1qpoe`q, oes1qu (De'finition actS)
i JpKoeaepoesq oe

6.3. Interpre'tation de'notationnelle de MLimp 137
Remarque 6.3.3.

1. La Proposition 6.25 ne vaut que parce que le programme symbolique p ne fait re'fe'rencea` aucune adresse. Toutes les adresses pre'sentes dans la de'notation de

p sont en re'alite'cache'es dans la valuation
ae et dans le store s. Si on veut e'noncer la proprie'te' e'quivalentepour les programmes re'els (qui peuvent mentionner des adresses re'elles), on devra donc

remplacer l'e'galite' pre'ce'dente par :J

oepKoeaepoesq i oepJpKaepsqq ,
ou` oep de'signe le programme p dans lequel chaque occurrence d'une adresse re'elle ` estremplace'e par l'adresse

oep`q. (Formellement, ceci revient a` munir le dcpo discret desprogrammes syntaxiques d'une action de

G.)

2. En revanche, lorsqu'on fixe la valuation ae, la de'notationJ

pKae : S N~ pV \Theta  SqK
n'est en ge'ne'ral pas une fonction G-invariante, sauf dans le cas ou` la valuation ae estelle-me^me

G-invariante, en ce sens que oeae i ae pour tout oe P G. C'est pre'cise'mentl'objet de la the'orie de la domination que de de'terminer (entre autres) les sous-groupes

de G pour lesquels la de'notation JpKae est invariante.
Proposition 6.26 (De'notation des valeurs symboliques).Soient v une valeur symbolique et

ae P VALsym une valuation qui clo^t v. Il existe une uniquevaleur
v dans V telle que pour tout e'le'ment s P S, JvKaepsq i tpv, squ.

De'monstration :On raisonne par induction sur la structure de v.

- v j n, ff, x ou *x: p : imme'diat.
- v j fpv1, : : : , vkq : par hypothe`se d'induction il vient que pour tout s P S et pour tout

i P t1, : : : , ku, JviKaepsq i tpinjipviq, squ. Alors, soit pour tout i P t1, : : : , ku, inji i int et
vi P Z, auquel cas Jfpv1, : : : , vkqKaepsq i tpintp~fpv1, : : : , vkqq, squ ; soit il existe i P t1, : : : , kutel que inj

i P taddr, pair, baseu, auquel cas Jfpv1, : : : , vkqKaepsq i tpintp0q, squ.

- v j pv1, v2q : Par HI, il existe v1, v2 telles que pour tout s, Jv1Kaepsq i tpv1, squ etJv

2Kaepsq i tpv2, squ, alors pour tout s Jpv1, v2qKaepsq i tppairpv1, v2q, squ.

- v j fstpv1q : Par HI, il existe v P V telle que Jv1Kaepsq i tpv, squ pour tout s. S'il existe

pv1, v2q P V \Theta  V tel que v i pairpv1, v2q, alors Jfstpv1qKaepsq i tpv1, squ pour tout s. Si
v i injpv1q avec inj P tint, addr, baseu et v1 P V, alors Jfstpv1qKaepsq i tp0, squ. Me^meraisonnement dans le cas ou` v

j sndpv1q.

- v j pv1 i v2q : il existe pv1, v2q P V2 tel que pour tout s, Jv1Kaepsq i tpv1, squ etJv

2Kaepsq i tpv2, squ, alors pour tout s Jpv1, v2qKaepsq i tpintpEqupv1, v2qq, squ.

- v j pif v1 then v1 else v2q : soit v P V telle que Jv1Kaepsq i tpv, squ pour tout s. Si v n'estpas de la forme int

pnq, alors Jif v1 then v1 else v2Kaepsq i tpintp0q, squ pour tout s. Si vest de la forme int
pnq, alors Jif v1 then v1 else v2Kaepsq vaut Jv1Kaepsq si n , 0, et Jv2Kaepsqsi
n i 0. Dans les deux cas l'hypothe`se d'induction permet de conclure.

138 Chapitre 6 - Se'mantique de'notationnelle de MLimp

oe
De'finition 6.3.2 (De'notation des valeurs symboliques).La de'notation d'une valeur symbolique v dans une valuation

ae P VALsym (qui clo^t v), note'eDen
pvqae, est l'unique valeur w P V telle que JvKaeps?q i tpw, s?qu ou` s? de'signe n'importe quelstore

s tel que dompsq i ?.

Interpre'tation des stores syntaxiques On rappelle que les stores syntaxiques (e'le'-ments de S) sont des fonctions des adresses dans les valeurs de ML

imp dont le domaine fini estun segment initial de
", l'e'nume'ration donne'e par la se'mantique ope'rationnelle. La diffe'renceentre stores syntaxiques et stores se'mantiques est la suivante : alors que le domaine d'un store

syntaxique (qui est une fonction) est ne'cessairement un segment initial de ", le domaine d'unstore se'mantique (qui est un triplet) est un simple ensemble. En revanche, le store se'mantique conserve l'information indiquant les prochaines adresses a` allouer. Il est donc natureld'interpre'ter un store syntaxique par un store se'mantique dont l'allocateur est compatible
avec ". Formellement, l'interpre'tation d'un store ps : L N~ Vq P S -- qui ne de'pend pas d'unevaluation donne'e (

s ne contient que des valeurs closes) -- est de'finie par :J

sK i pL, e, 'q
ou` e i popnp"q (pour n i 7L) et ' est de'finie par :

' : L N~ V

` ThN~ Denpsp`qq

Par de'finition, dompJsKq i dompsq et e0 i "n. Par conse'quent, on ve'rifie que :

Lemme 6.9.Pour tout

s P S, n i 7dompsq et toute ` P dompsq Y t"nu, Js 4 ` DH vK i JsK\Gamma t` ThN~ Denpvqu

De'monstration :Soit

L et ' tels que JsK i pL, popnp"q, 'q. On a :J

sK \Gamma te0 ThN~ Denpvqu i pL, popnp"q, 'q\Gamma t"n ThN~ Denpvqu pe0 i "nq

i pL Y t"nu, popn\Gamma 1p"q, '\Gamma t"n ThN~ Denpvquq
i Js\Gamma t"n ThN~ vuK oe

Proposition 6.27 (Continuite').Pour tout store syntaxique

ps : L N~ Vq P S, la fonction JsK est continue.

6:3:2 Exemples

Quelques programmes de MLimp Soit s P S.

1. A` partir de l'interpre'tation du programme *x: p et de la Proposition 6.24, on calculeimme'diatement que J

p*x: pq vKaepsq i JpKae;xThN~Denpvqpsq.

6.3. Interpre'tation de'notationnelle de MLimp 139
2. Supposons que JpKaepsq i tpv1, s1qu. A` partir de l'encodage plet x i p in qq j p*x: qq p etdu point pre'ce'dent, on calcule imme'diatement que : Jlet

x i p in qKaepsq i JqKae;xThN~v1ps1q.

3. De me^me, si JpKaepsq i tpv1, s1qu alors Jp ; qKaepsq i JqKaeps1q -- rappel : pp ; qq j p*x: qq p.
4. L'interpre'tation de la fonction d'allocation (*x: ref x) se calcule aise'ment :J

*x: ref xKaepsq i tpbasepf q, squ ou` f j pv1, s1q ThN~ tpe10, s1 \Gamma te10 ThN~ v1uqu pour e10 i ss2ps1q.

5. De me^me, l'interpre'tation de la fonction d'affectation (*x*y: x :i y) se calcule aise'-ment :J

incrKaepsq i tpbasepf q, squ ou`

f j pv1, s1q ThN~ pv2, s2q ThN~

$'''''''''&

'''''''''%

tpintp0q, s2 \Gamma t` ThN~ v2uqu si v1 i addrp`q et ` P domps2q
tpintp0q, s2qu si v1 i addrp`q ^ ` R domps2q

ou v1 i injpdq ^ inj , addr

K sinon
6. L'interpre'tation de la fonction d'incre'mentation incr j p*x: x :i !x \Gamma  1q se calculeaise'ment et on peut en de'duire que si

` P dompsq alors Jincr `Kaepsq i tpintp0q, s\Gamma t` ThN~ vuquou`
v i ss3psqp`q \Gamma  1.

7. A` l'aide des points pre'ce'dents, on calcule facilement l'interpre'tation du programmenext

j plet x i ref 0 in *y: pincr x ; !xqq :

JnextKaepsq j Jlet x i ref 0 in *y: pincr x ; !xqKaepsq

i J*y: pincr x ; !xqKae;xThN~e0ps\Gamma te0 ThN~ 0uq pe i freepsqq
i tpbasepf q, s\Gamma te0 ThN~ 0uqu

ou` f j pv1, s1q ThN~ Jincr x ; !xKae;xThN~e0ps1q

i pv1, s1q ThN~ J!xKae;xThN~e0ps1 \Gamma te0 ThN~ nuq pn i s1pe0q \Gamma  1q
i pv1, s1q ThN~ tpintpnq, s1 \Gamma te0 ThN~ nuqu

Bien entendu, si e0 R domps1q alors f j pv1, s1q ThN~ tpintp0q, s1qu.
Non surjectivite' de l'interpre'tation Nous donnons quelques exemples de fonctionscontinues dans

P i S N~ pV \Theta  SqK qui ne correspond a` aucun programmes de MLimp. Enparticulier, nous pouvons construire :

1. Une fonction size P P qui compte le nombre d'adresses alloue'es dans le store courant :size

j s ThN~ tpintp7dompsqq, squ.

2. Une fonction freeall P P qui libe`re toutes les adresses alloue'es dans le store courant :freeall

j s ThN~ tpintp0q, s?qu ou` s? i p?, ", ?q.

140 Chapitre 6 - Se'mantique de'notationnelle de MLimp

3. Une fonction used P V qui teste si une adresse passe'e en argument est alloue'e ou nondans la me'moire :

used j pv, sq ThN~ $'&'%

tpintp1q, squ si v i addrp`q ^ ` P dompsq
tpintp0q, squ si v i addrp`q ^ ` R dompsq
tpintp\Delta 1q, squ sinon

4. Une fonction chambouletout P P qui me'lange toutes les adresses sans distinguer lesadresses libres des adresses alloue'es et modifie l'allocateur :

chambouletout j s ThN~ tpintp0q, poeL, oe1e, oe2'qqu ou` pL, e, 'q i s et oe, oe1, oe2 sont troisautomorphismes d'adresses quelconques.

5. Une fonction WFdata P V qui teste si la donne'e pure passe'e en argument est bien forme'evis-a`-vis du store courant :

WFdatapv, sq i

$''''''''''
'''''''''&

'''''''''''''
''''''%

tpintp1q, squ si v i intpnq

ou si v i addrp`q et ` P dompsq

tpintp0q, squ si v i addrp`q et ` R dompsq
tpintpn1 \Theta  n2q, squ si v i pairpv1, v2q et

WFdatapv1, sq i tpintpn1q, squ et
WFdatapv2, sq i tpintpn2q, squ

K sinon
Les donne'es pures consistuent un sous-dcpo discret de V. La fonction WFdata est doncclairement continue.

6:3:3 Proprie'te's de correction

Correction de la se'mantique ope'rationnelle de MLimp

Proposition 6.28 (Substitutivite').Soient

p un programme et v une valeur close. Pour toute valuation ae qui clo^t p, on aJ
rv-xspKae i JpKae;xThN~Denpvq

De'monstration :Re'currence imme'diate sur la structure de

p. oe

Proposition 6.29 (Correction de la se'mantique ope'rationnelle).Soient

p ffi s et p1 ffi s1 deux e'tats d'e'valuation bien forme's. Si p ffi s a,\Sigma  p1 ffi s1 alors pour toute
ae P VAL qui clo^t p et p1, on a JpKaepJsKq i Jp1KaepJs1Kq.

De'monstration :Tous les cas d'erreur se ve'rifient aise'ment car les conditions d'erreur de la Figure 6.2(b)
sont les me^mes que celles de l'interpre'tation (Figure 6.1). Pour les e'tapes de la Figure 6.2(a),on a :

6.3. Interpre'tation de'notationnelle de MLimp 141
p ffi s a, p1 ffi s1
Cppq ffi s a, Cpp1q ffi s1

f pn1, : : : , nkq ffi s a, ~fpn1, : : : , nkq ffi s

p*x: pq v ffi s a, rv-xsp ffi s

fstpv1, v2q ffi s a, v1 ffi s
sndpv1, v2q ffi s a, v2 ffi s

if n then p1 else p2 ffi s a, p1 ffi s psi n , 0q

if 0 then p1 else p2 ffi s a, p2 ffi s

n i m ffi s a, ffin,m ffi s

ff i fi ffi s a, ffiff,fi ffi s
pv1, v2q i pv11, v12q ffi s a, pv1 i v11q \Theta  pv2 i v12q ffi s

*x: p i v ffi s a, 0 ffi s
v i *x: p ffi s a, 0 ffi s

ref v ffi s a, "n ffi ps 4 "n DH vq pou` n i 7dompsqq
` :i v ffi s a, 0 ffi s 4 ` DH v psi ` P dompsqq

!` ffi s a, sp`q ffi s psi ` P dompsqq

(a) Re`gles de calcul

Figure 6.2 - Rappel : Se'mantique ope'rationnelle (1/2)

- On a vu que Jp*x: pq vKaepJsKq i JpKae;xThN~DenpvqpJsKq. La Proposition 6.28 permet de con-clure.

- Posons e i ss2pJsKq et n i 7dompsq. On a alors e0 i "n et :Jref

vKaepJsKq i tpaddrpe0q, JsK \Gamma te0 ThN~ Denpvququ i J"nKaepJs 4 "n DH vKq

- J` :i vKaepJsKq i tpintp0q, JsK \Gamma t` ThN~ Denpvququ i J0KaepJs 4 ` DH vKq
- on pose ' i ss3pJsKq. Alors : J!`KaepJsKq i tp'p`q, JsKqu i Jsp`qKaepJsKq

Une re'currence e'vidente sur le nombre d'e'tape de l'e'valuation p ffi s a,\Sigma  p1 ffi s1 permet deconclure. oe

Corollaire 6.29.1.Soient

p un programme et s P S. S'il existe pv, s1q P Vs1 \Theta  S tels que p ffi s a,\Sigma  v ffi s1 alors pourtoute valuation

ae qui clo^t p, on a JpKaepJsKq ,K.

De'monstration :Par la Proposition 6.29, on a que J

pKaepJsKq i JvKaepJs1Kq. Or par la Proposition 6.24, il existeune unique valeur
v1 P V telle que JvKaepJs1Kaeq i tpv1, Js1Kaequ. Par conse'quent, JpKaepJsKaeq , K.

142 Chapitre 6 - Se'mantique de'notationnelle de MLimp

v1 v2 ffi s a, 0 ffi s psi v1 n'est pas une abstractionq
f pv1, : : : , vkq ffi s a, 0 ffi s psi vi R Z pour un i P r1::ksq
if v then p1 else p2 ffi s a, 0 ffi s psi v R Zq

fstpvq ffi s a, 0 ffi s psi v n'est pas une paireq
sndpvq ffi s a, 0 ffi s psi v n'est pas une paireq

v :i v1 ffi s a, 0 ffi s psi v R dompsqq

!v ffi s a, 0 ffi s psi v R dompsqq

n i ` ffi s a, 0 ffi s
` i n ffi s a, 0 ffi s
n i pv1, v2q ffi s a, 0 ffi s
pv1, v2q i n ffi s a, 0 ffi s

` i pv1, v2q ffi s a, 0 ffi s
pv1, v2q i ` ffi s a, 0 ffi s

*x: p i v ffi s a, 0 ffi s
v i *x: p ffi s a, 0 ffi s
*x: p i v ffi s a, 0 ffi s
v i *x: p ffi s a, 0 ffi s

(b) Cas d'erreur

Figure 6.2 - Rappel : Se'mantique ope'rationnelle (2/2) oe

Correction de l'e'valuation symbolique

Proposition 6.30 (Substitution symbolique).Soit

p un programme symbolique, v une valeur symbolique et ae P VALsym qui clo^t p et v. AlorsJ
rv-xspKae i JpKae;xThN~Denpvqae

De'monstration :On raisonne par induction sur la structure de

p. Modulo ff-renommage, on peut supposerque
x ainsi que les variables libres de v ne sont pas lie'es dans p. Soit s P S :-

p j x : J

rv-xsxKaepsq i JvKaepsq i tpDenpvqae, squ i JxKae;xThN~Denpvqaepsq

- p j n ou p j ` : imme'diat.
- p j fpp1, : : : , pkq : on posant s0 i s. Par hypothe`se d'induction, on a pour tout

i P t1, : : : , ku, que Jrv-xspiKaepsi\Delta 1q i JpiKae;xThN~Denpvqaepsi\Delta 1q. S'ils sont tous de la forme

6.3. Interpre'tation de'notationnelle de MLimp 143
tpintpniq, siqu, on a :J

rv-xsfpp1, : : : , pkqKaepsq i Jfprv-xsp1, : : : , rv-xspkqKaepsq

i tpintp~fpn1, : : : , nkqq, skqu
i Jfpp1, : : : , pkqKae;xThN~Denpvqaepsq

Dans le cas contraire, on a soit Jrv-xspKaepsq i tpintp0q, skqu i JpKae;xThN~Denpvqaepsq, soitJ

rv-xspKaepsq i K i JpKae;xThN~Denpvqaepsq.Tous les autres cas sont similaires et s'obtiennent directement a` partir de l'hypothe`se d'induction. oe
Corollaire 6.30.1.Quelles que soient v et v

1 et ae P VALsym qui clo^t v et v1, on a Denprv-xsv1qae i Denpv1qae;xThN~Denpvq

ae.

fpn1, : : : , nkq * ~fpn1, : : : , nkq

p*x: pq v * rv-xsp
fstppv1, v2qq * v1snd

ppv1, v2qq * v2

if n then p else p1 * p pn , 0qif 0 then

p else p1 * p1

pn i mq * ffin,m

pff i fiq * ffiff,fi
pv1, v2q i pv11, v12q * pv1 i v11q \Theta  pv2 i v12q

p*x: p i *y: p1q * 0

Figure 6.3 - Rappel : E'valuation symbolique des programmes (calcul)
Proposition 6.31 (Correction de l'e'valuation symbolique).Si

p * p1 alors pour toute valuation ae P VALsym qui clo^t p et p1 et tout store s P S, on a :J

pKaepsq i Jp1Kaepsq

De'monstration :On raisonne par induction sur

p * p1 dont les re`gles sont rappele'es dans la Fig-ure 6.3, p. 143.

- p j x j p1 : imme'diat. De me^me, pour p j n, ff.
- p j fpn1, : : : , nkq et p1 j ~fpn1, : : : , nkq :clairement, on a Jf

pn1, : : : , nkqKaepsq i tpintp~fpn1, : : : , nkqq, squ i J~fpn1, : : : , nkqKaepsq.

- p j p*x: qq v et p1 j rv-xsq : On a J*x: qKaepsq i tpbasepf q, squ ou` f est la fonction

pv0, s0q ThN~ JqKae;xThN~v0ps0q. Par la Proposition 6.30, on a :J

pKaepsq i JqKae;xThN~Denpvqaepsq i Jrv-xsqKaepsq

144 Chapitre 6 - Se'mantique de'notationnelle de MLimp

- p j fstppv1, v2qq et p1 j v1 : On a Denppv1, v2qqae i pairpDenpv1qae, Denpv2qaeq et par suiteDen

ppqae i Denpv1qae i Denpp1qae. Le raisonnement est tout a` fait identique pour lecas snd

ppv1, v2qq * v2.

- p j pn i mq et p1 j ffin,m : Denppqae i intpEqupintpnq, intpmqqq i intpffin,mq i Denpffin,mq.De me^me pour

p j pff i fiq et p1 j ffiff,fi, et de me^me pour p j p*x: p1 i *y: p2q et p1 j 0car la fonction continue Equ renvoie toujours 0 lorsque les arguments sont des fonctions.

- p j ppv1, v2q i pv11, v12qq et p1 j ppv1 i v11q \Theta  pv2 i v12qq. On a directement :

Denppqae i intpEqupDenpv1qae, Denpv11qaeq \Theta  EqupDenpv2qae, Denpv12qaeqq

i Denppv1 i v11q \Theta  pv2 i v12qqae
i Denpp1qae

- p j pif n then p1 else p2q et p1 j p1 avec n , 0 : imme'diat, de me^me avec n i 0 et

p1 j p2.Tous les autres cas (transitivite' et passages au contexte) sont imme'diats ou de'coulent directement de l'hypothe`se d'induction. oe
Corollaire 6.31.1.Si v

* v1 alors pour toute valuation ae P VALsym qui clo^t v et v1, on a Denpvqae i Denpv1qae.

6:4 Relation de domination et invariants lie's a` la me'moire

6:4:1 Motivations

La correction de MLDL repose sur l'invariance de l'interpre'tation des programmes vis-a`-visdes permutations d'adresses (re`gles de commutation entre

*-lieurs), mais aussi vis-a`-vis del'allocation de nouvelles adresses (commutation
*-lieurs et boi^tes). Les invariants sur lesquelsrepose la logique de MLDL sont incompatibles avec les programmes pathologiques indique's a`

la Section 6.3.2 tels que la fonction freeall :

*ff: rfreealls DxDn: !x i n ss rfreealls *ff: DxDn: !x i n
Il va donc falloir restreindre le mode`le de manie`re a` faire disparai^tre ces objets qui cassentles invariants du syste`me. C'est pourquoi on introduit la relation de domination

v Y" L, ou` vest une valeur se'mantique et
L un ensemble fini d'adresses.

De'finition 6.4.1 (Relation de domination).Soit

X un G-dcpo. On appelle une relation de domination sur X toute relation binaire
Y"X D^ X \Theta  PfinpLq telle que :

(1) Si x Y"X L, alors oex i x pour tout oe P FixpLq ;
(2) Si x Y"X L, alors oex Y"X oeL pour toute permutation oe P G ;

6.4. Relation de domination et invariants lie's a` la me'moire 145
(3) Si x Y"X L et L D^ L1, alors x Y"X L1 ;
(4) Si x1 d^ x et x Y"X L, alors x1 Y"X L ;
(5) Si pxiqiP! est une chai^ne d'e'le'ments de X telle que xi Y"X L pour tout i P !,alors

psupiP! xiq Y"X L.

Intuitivement, la relation v Y" L exprime que :
i. la de'notation v ne << connait >> que les adresses dans l'ensemble L. La relation Denpvq Y" Lpeut donc e^tre vue comme une formulation se'mantique de la relation loc

pvq D^ L ou`
v est une valeur MLimp. Techniquement, cette condition correspond au fait que v estFix

pLq-invariante.

ii. les de'notations fonctionnelles cache'es dans v respectent la bonne formation des stores etla politique d'allocation. (En particulier, elles ne de'truisent aucune adresse.)

Par ailleurs, on notera que les conditions (4) et (5) expriment pre'cise'ment que l'ensembledes

x P X tels que x Y"X L (pour L fixe') est un ferme' au sens de Scott.Comme la de'finition de

V est re'cursive, il est maintenant ne'cessaire de de'finir cette notionde domination de proche en proche sur quasiment tous les dcpo qui interviennent dans la

construction du mode`le.

6:4:2 Passage de X a` X

Le but de cette section est de montrer comment a` partir d'une relation de domination Y"Xsur un

G-dcpo X on peut construire une autre relation de domination Y"X sur le G-dcpo
X i RX N~ pRXqK. (On verra ensuite comment passer a` la colimite.)Pour cela, on suppose donne' un

G-dcpo X muni d'une relation de domination Y"X, et onde'finit successivement :

- Une relation de domination sur le G-dcpo TX ;- Un pre'dicat de bonne formation sur les

G-dcpos SX, RX i TX \Theta  SX et pRXqK ;- Une relation de domination sur le
G-dcpo X i RX N~ pRXqK.

De'finition de la relation de domination sur TX La relation t Y"TX L est de'finiepar induction sur

t P TX :

basepxq Y"TX L si x Y"X L (cas de base)int

pnq Y"TX L est toujours vrai ;addr

p`q Y"TX L si ` P L
pt1, t2q Y"TX L si t1 Y"TX L et t2 Y"TX L

Lemme 6.10.La relation binaire

Y"TX D^ TX \Theta  PfinpLq est une relation de domination.

De'finition des e'le'ments de SX bien forme's On dit qu'un e'le'ment s P SX est bienforme' lorsque pour toute adresse

` P dompsq on a sp`q Y"TX dompsq. L'ensemble des e'le'mentsde S
X bien forme's, note' WFpSXq, est donc de'fini par

WFpSXq i ts P SX : @` P dompsq sp`q Y"TX dompsqu:

146 Chapitre 6 - Se'mantique de'notationnelle de MLimp

Lemme 6.11.Le sous-ensemble WF

pSXq des stores bien forme's dans SX est un ferme' de SX qui est clospar l'action de groupe.

De'finition des e'le'ments de RX bien forme's Comme pour les stores, on dit qu'un<< re'sultat >>

r i pt, sq P RX i TX \Theta SX est bien forme' lorsque s est bien forme' et lorsque t estdomine' (dans T

X) par dompsq. L'ensemble des e'le'ments bien forme's de RX, note' WFpRXq,est donc de'fini par :

WFpRXq i tpt, sq P RX : s P WFpSXq ^ t Y"TX dompsqu
Lemme 6.12.Le sous-ensemble WF

pRXq des e'tats bien forme's dans RX est un ferme' de RX qui est clospar l'action de groupe.

La notation WFpRXq s'e'tend imme'diatement au dcpo pRXqK en adoptant la conventionsuivant laquelle la de'notation

K est bien forme'e :

WFppRXqKq i tWFpRXqu Y tKu :
La` encore :

Lemme 6.13.Le sous-ensemble WF

ppRXqKq constitue' des e'le'ments de pRXqK bien forme's est un ferme'de
pRXqK qui est clos par l'action de groupe.

De'finition de la relation de domination sur X Soient f P X i RX N~ pRXqKet

L P PfinpLq. On dit que la fonction f est domine'e par L dans X (ce que l'on note f Y"X L)si la fonction

f satisfait les conditions suivantes :

(1) Pour tout oe P FixpLq on a oef i f .
(2) Pour tout r P WFpRXq tel que L D^ domprq,si

f prq i tr1u, alors r1 P WFpRXq et r I^ r1.

(3) Pour tout r P WFpRXq tel que L D^ domprq :(3a) Si

f prq i K, alors f pextprqq i K ;(3b) Si

f prq i tr1u, alors f pextprqq i toeextpr1qu, avec oe i rotr, r1.

Intuitions- La condition (1) exprime que

f est FixpLq-invariante. (C'est pre'cise'ment la premie`recondition requise pour que la relation

f Y"X L soit une relation de domination.) Dansla mesure ou` l'action de groupe sur
X est de'finie par conjugaison, cette conditionexprime que pour tout
r P RX et pour tout oe P FixpLq, on a f poerq i oepf prqq. Onpeut voir cette condition comme l'expression d'une certaine forme de parame'tricite' de

la fonction f vis-a`-vis des adresses en dehors de l'ensemble L (c'est-a`-dire vis-a`-vis desadresses << inconnues >> de

f ).- La condition (2) exprime que l'image d'un e'tat bien forme' dont le domaine contient au

moins L est soit inde'fini, soit (le lifte' d')un e'tat bien forme'. De plus, elle exprime quele store sous-jacent croi^t au cours de l'appel de

f en suivant la politique d'allocationfournie par l'e'tat de de'part.

6.4. Relation de domination et invariants lie's a` la me'moire 147
- Enfin, les conditions (3a) et (3b) permettent de de'crire le comportement de f a` traversl'allocation d'une adresse supple'mentaire dans le store. Elles expriment notamment que

f pextprqq est de'fini si et seulement si f prq est de'fini, et que dans le cas ou` f prq i tr1u, lesre'sultats

f pextprqq et extpf prqq sont les me^mes modulo la rotation rotr, r1. (Ces re'sultatse'tant conditionne's -- comme dans (2) -- par l'hypothe`se que

r est bien forme' et queson domaine contient au moins
L.)

Lemme 6.14.La relation binaire

Y"X D^ X \Theta  PfinpLq est une relation de domination.

Respect de la domination a` travers une injection-projection Soient X et Y deux
G-cpo, munis chacun d'une relation de domination. On dit qu'une injection-projection f i
pf \Gamma , f \Delta q : X n~ Y respecte les relations de domination sur X et Y si :- Pour tous

L P PfinpLq et x P X, x Y"X L implique f \Gamma pxq Y"Y L ;- Pour tous
L P PfinpLq et y P Y , y Y"Y L implique f \Delta pyq Y"X L.

Lemme 6.15.Si

f : X n~ Y respecte les relations de domination sur X et Y , alors pf q : X n~ Yrespecte les relations de dominations induites sur

X et Y .

6:4:3 Passage a` la colimite

On conside`re a` pre'sent la chai^ne ppAiqiP!, pfiqiP!q de'finie par

A0 i tflu Ai\Gamma 1 i Ai

f0 i pKpKKq, Kflq fi\Gamma 1 i fi

On munit le G-cpo A0 de la relation de domination de'finie par fl Y" L pour tout L P PfinpLq,et chacun des

G-cpos Ai (i e^ 1) des relations de dominations induites par  (de proche enproche). On ve'rifie alors que l'injection-projection

f0 : A0 n~ A1 respecte les relations dedomination sur
A0 et A1, d'ou` il ressort (par re'currence sur i) que fi : Ai n~ Ai\Gamma 1 respecteles relations de domination sur

Ai et Ai\Gamma 1 pour tout i P !.Soit
pA8, pffiqiP!q la colimite de la chai^ne ppAiqiP!, pfiqiP!q. On munit cette colimite de larelation

u Y"A8 L de'finie par

u Y"A8 L j @i P ! ff\Delta i puq Y"Ai L
et on ve'rifie que :
Lemme 6.16.La relation binaire

Y"A8 D^ A8 \Theta  PfinpLq est une relation de domination, et pour tout i P !,l'injection-projection

ffi : Ai n~ A8 respecte les relations de domination sur Ai et A8.

En posant V i TA8 et S i SA8, on munit ainsi le dcpo V d'une relation de domination(induite par le foncteur T) et le dcpo

S d'une notion de bonne formation (induite par lefoncteur
S) satisfaisant les proprie'te's voulues. En particulier, l'ensemble WFpSq i WFpSA8qest un ferme' de Scott qui est clos par l'action du groupe

G sur S.

148 Chapitre 6 - Se'mantique de'notationnelle de MLimp

6:4:4 Correction de la fonction d'interpre'tation

Relation de domination sur les valuations E'tant donne'e une valuation ae P VALsymet un ensemble fini d'adresses

L, on note ae Y"VALsym L lorsque :

(1) Pour toute variable x P dompaeq, aepxq Y"V L ;
(2) Pour toute adresse symbolique ff P dompaeq, aepffq P L.

Lemme 6.17.La relation

Y"VALsym D^ VALsym \Theta  PfinpLq est une relation de domination.

Relation de domination sur S N~ pV \Theta  SqK On de'finit par analogie avec la relationde domination sur

X une relation de domination sur le cpo S N~ pV \Theta  SqK de la manie`resuivante. E'tant donne'e une fonction

h : S N~ pV \Theta  SqK et un ensemble fini d'adresses L, ondit que la fonction
h est domine'e par L dans S N~ pV \Theta  SqK (ce que l'on note h Y" L) si lafonction
h satisfait les conditions suivantes :

(1) Pour tout oe P FixpLq on a oeh i h.
(2) Pour tout s P WFpSq tel que L D^ dompsq,si

hpsq i tpv1, s1qu, alors pv1, s1q P WFpV \Theta  Sq et s I^ s1.

(3) Pour tout s P WFpSq tel que L D^ dompsq :(3a) Si

hpsq i K, alors hpextpsqq i K ;(3b) Si

hpsq i tpv1, s1qu, alors hpextpsqq i oetpv1, extps1qqu, avec oe i rots, s1.

Lemme 6.18.La relation

Y"P D^ P \Theta  PfinpLq est une relation de domination.

Proposition 6.32 (Correction vis-a`-vis de l'adressage).Pour tout programme symbolique

p, pour toute valuation ae P VALsym qui clo^t p et pour toutensemble fini d'adresses
L, si ae Y" L (dans le G-dcpo des valuations), alors JpKae Y" L (dans le
G-cpo S N~ pV \Theta  SqK).

De'monstration :

fl Cas ou` p j p1p2 (application). On suppose donne'e une valuation ae telle que ae Y" L. Parhypothe`se d'induction, on a J

p1Kae Y"L et Jp2Kae Y"L. Il s'agit de de'montrer que Jp1p2Kae Y"L.Soit
s0 P S tel que L D^ domps0q. On ne conside`re que le cas ou` l'application retourneune valeur de'finie, c'est-a`-dire :

- Jp1Kps0q i tpv1, s1qu, avec v1 i basepf1q ;- J

p2Kps1q i tpv2, s2qu ;-
f1pv2, s2q i tpv3, s3qu ;auquel cas J

p1p2Kps0q i tpv3, s3qu.(1) Par hypothe`se d'induction, on a

oeJp1Kae i Jp1Kae et oeJp2Kae i Jp2Kae, et donc :J

p1Kaepoe\Delta 1s0q i tpoe\Delta 1f, oe\Delta 1s1qu et Jp2Kaepoe\Delta 1s1q i tpoe\Delta 1v2, oe\Delta 1s2qu
d'ou` :

poeJp1 p2Kaeqps0q i oepJp1 p2Kaepoe\Delta 1s0qq i oeppoe\Delta 1f qpoe\Delta 1v2, oe\Delta 1s2qq i f pv2, s2q:

6.4. Relation de domination et invariants lie's a` la me'moire 149
Pour montrer les conditions (2), (3a) et (3b), on suppose que s0 P WFpSq.Comme J

p1Kae Y" L et L D^ domps0q, on a :

s0 ! s1, s1 P WFpSq et f1 Y" domps1q :
Comme Jp2Kae Y" L et L D^ domps0q D^ domps1q, on a e'galement :

s1 ! s2, s2 P WFpSq et v2 Y" domps2q :
Enfin, comme f1 Y" domps1q et domps1q D^ domps2q, il vient

s2 ! s3, s3 P WFpSq et v3 Y" domps3q :
Ce qui prouve que pv3, s3q P WFpV \Theta Sq et s0 ! s3 (condition 2). On cherche maintenanta` prouver la condition (3b). Il s'agit de de'montrer l'e'galite'J

p1p2Kaepextppqs0qq i oetpv3, extppqs3qqu ,
avec oe i rotps0, s3q. Pour cela on de'compose oe sous la forme oe i oe1 \Pi  oe2 \Pi  oe3, avec
oe1 i rotps0, s1q, oe2 i rotps1, s2q et oe3 i rotps2, s3q. On remarque que :
fl oe1Jp1Kae i Jp1Kae, car Jp1Kae Y" L et oe1 P FixpLq (car supppoe1q X L i ?).
fl oe2f1 i f1, car f1 Y" domps1q et oe2 P Fixpdomps1qq (supppoe2q X domps1q i ?).Ce qui nous permet de montrer successivement que :J

p1Kaepextppqs0qq i oe1tpbasepf1q, extppqs1qqu

i tpbasepoe1f1q, oe1extppqs1qquJ

p2Kaepoe1extppqs1qq i oe1pJp2Kaepextppqs1qqq

i oe1oe2tpv2, extppqs2qqu
i tpoe1oe2v2, oe1oe2extppqs2qqu

pcar oe1Jp2Kae i Jp2Kaeq

poe1f1qpoe1oe2v2, oe1oe2extppqs2qq i oe1\Gamma f1poe2v2, oe2extppqs2qq\Phi 

i oe1oe2pf1pv2, extppqs2qqq
i oe1oe2oe3tpv3, extppqs3qqu

pde'f. actionq
pcar oe2f1 i f1q

D'ou` il ressort queJ

p1p2Kaepextppqs0qq i poe1f1qpoe1oe2v2, oe1oe2extppqs2qq i oetpv3, extppqs3qqu :
fl Cas ou` p j *x: p1 (abstraction). Par construction, on a pour tout s P S :J

pKaepsq i J*x: p1Kaepsq i tpbasepf q, squ ,
ou` f : pV \Theta  Sq N~ pV \Theta  SqK est la fonction de'finie pour tout pv0, s0q P V \Theta  S par
f pv0, s0q i Jp1Kae,xDHv0ps0q. (On notera que la fonction f construite dans le store s nede'pend pas de

s.) Il s'agit de montrer que JpKae Y" L (dans S N~ pV \Theta  SqK). Pour cela, oncommence par de'montrer que

f Y" L (dans pV \Theta  Sq N~ pV \Theta  SqK).(1) Soit
oe P FixpLq. Pour tout pv0, s0q P V \Theta  S, on a

f poev0, oes0q i Jp1Kae,xDHoev0poes0q

i Jp1Koepoe\Delta 1ae,xDHv0qpoes0q
i Jp1Koepae,xDHv0qpoes0q
i oe\Gamma Jp1Kae,xDHv0ps0q\Phi 
i oef pv0, s0q

pcar oeae i ae, puisque ae Y" Lq

pProp. 6.25q

Ce qui prouve que oef i f , pour tout oe P FixpLq.

150 Chapitre 6 - Se'mantique de'notationnelle de MLimp

(2) Soit pv0, s0q P WFpV \Theta  Sq tel que L D^ domps0q et f pv0, s0q i tpv1, s1qu. D'apre`s lade'finition de

f , on a

f pv0, s0q i Jp1Kae,xDHv0ps0q i tpv1, s1qu :
Or, comme ae Y" L et L D^ domps0q, il vient ae Y" domps0q. De plus v0 Y" domps0q, car
pv0, s0q est bien forme'. D'ou` pae, x DH v0q Y" domps0q. D'apre`s l'hypothe`se d'induction,on a J

p1Kae,xDHv0 Y" domps0q, et comme Jp1Kae,xDHv0ps0q i tpv1, s1qu, ceci entrai^ne que
pv1, s1q P WFpV \Theta  Sq et que s0 ! s1.(3) Soit

pv0, s0q P WFpV \Theta  Sq tel que L D^ domps0q. On commence par remarquer(comme en (2)) que

pae, x DH v0q Y" domps0q. D'apre`s l'hypothe`se d'induction, on adonc J
p1Kae,xDHv0 Y" domps0q dans le cpo S N~ pV \Theta  SqK.(3a) Supposons que

f pv0, s0q i K. Dans ce cas on a (d'apre`s la de'finition de f )J
p1Kae,xDHv0ps0q i K. Comme Jp1Kae,xDHv0 Y" domps0q et s0 P WFpSq, il vient :

f pv0, extps0qq i Jp1Kae,xDHv0pextps0qq i K
(3b) Supposons que f pv0, s0q i tpv1, s1qu. Dans ce cas on a (d'apre`s la de'finition de f )J

p1Kae,xDHv0ps0q i tpv1, s1qu. Comme Jp1Kae,xDHv0 Y" domps0q et s0 P WFpSq, il vientJ
p1Kae,xDHv0pextps0qq i oetpv1, extps1qqu, avec oe i rotps0, s1q. D'ou` f pv0, extps0qq i
oetpv1, extps1qqu, toujours d'apre`s la de'finition de f .Nous avons de'montre' que

f Y" L dans le cpo pV \Theta  Sq N~ pV \Theta  SqK. Montrons a` pre'sentque J
pKae Y" L dans le cpo S N~ pV \Theta  SqK.(1) Pour tout

oe P FixpLq et pour tout s P S, on aJ

pKaepoesq i tpbasepf q, oesqu

i tpbasepoef q, oesqu
i oetpbasepf q, squ
i oepJpKaepsqq ,

pcar oef i f, puisque f Y" Lq

ce qui prouve que oeJpKae i JpKae pour tout oe P FixpLq.(2) Pour tout

s P WFpSq tel que L D^ dompsq, on a JpKaepsq i tpbasepf q, squ. Il estimme'diat que

pbasepf q, sq est bien forme' (car f Y" L D^ dompsq) et que s ! s.(3) Soit
s P WFpSq tel que L D^ dompsq.(3a) Cette condition est imme'diate, car J

pKaepsq , K et JpKaepextpsqq , K.(3b) Comme J
pKaepsq i tbasepf q, su, on note oe i rotps, sq i idL. On a alors imme'di-atement J
pKaepextpsqq i oetbasepf q, extpsqu.

fl Cas ou` p j pref qq (allocation). Soit s tel que L D^ dompsq. On suppose que Jref qKaepsqest une valeur de'finie c'est-a`-dire queJ

ref qKaepsq i tpaddrpfreeps1q0q, extps1q\Gamma tfreeps1q0 ThN~ vuqu,
avec JqKaepsq i tpv, s1qu. Par hypothe`se d'induction, on a que JqKae Y" L(1) Par hypothe`se d'induction, on a : J

qKaepoe\Delta 1sq i tpoe\Delta 1v, oe\Delta 1s1qu. On ve'rifie alors(gra^ce au Lemme 6.5) :

poeJref qKaeqpsq i oe \Pi  Jref qKae \Pi  oe\Delta 1psq

i oetpaddrpfreepoe\Delta 1s1q0q, extpoe\Delta 1s1q\Gamma tfreepoe\Delta 1s1q0 ThN~ oe\Delta 1vuqu
i tpaddrpfreeps1q0q, extps1q\Gamma tfreeps1q0 ThN~ vuqu
i Jref qKaepsq

6.4. Relation de domination et invariants lie's a` la me'moire 151
(2) On suppose que s P WFpSq. On a alors s1 P WFpSq et v Y" domps1q, d'ou` l'on conclutque

s1 I^ pextps1q\Gamma tfreeps1q0 ThN~ vuq et pextps1q\Gamma tfreeps1q0 ThN~ vuq P WFpSq.(3a) On suppose que

s P WFpSq. Il est clair que si Jref qKaepsq i K c'est que JqKaepsq i K.Par hypothe`se d'induction, on a donc J

qKaepextpsqq i K, d'ou` l'on peut conclure queJref
qKaepsq i K.(3b) On suppose que

s P WFpSq. Par hypothe`se d'induction, on a JqKaepextpsqq i
tpoev, extpoes1qqu avec oe i rots, s1. En invoquant le Lemme 6.5 on a donc :J

ref pKaepextpsqq i tpfreepextpoes1qq, extpextpoes1q\Gamma tfreepoes1q ThN~ oevuqqu

i oetpfreepextps1qq, extpextps1q\Gamma tfreeps1q ThN~ vuqqu

ce qui est l'e'galite' recherche'e.
fl Cas ou` p j pp1 :i p2q (affectation). Soit s0 P S tel que L D^ domps0q. On suppose que :J

p1 :i p2Kaeps0q i tpintp0q, s2 \Gamma t` ThN~ vuqu avec :- J

p1Kaeps0q i tpaddrp`q, s1qu, ` P domps2q ;- J
p2Kaeps1q i tpv, s2qu ;Par hypothe`se d'induction, on a J

p1Kae Y" L et Jp2Kae Y" L.(1) Par hypothe`se d'induction, on a :J

p1Kaepoe\Delta 1s0q i tpaddrpoe\Delta 1`q, oe\Delta 1s1quJ
p2Kaepoe\Delta 1s1q i tpoe\Delta 1v, oe\Delta 1s2qu

d'ou` l'on peut tirer :

poeJp1 :i p2Kaeqps0q i oepJp1 :i p2Kaepoe\Delta 1s0qq

i oetpintp0q, oe\Delta 1s2 \Gamma toe\Delta 1` ThN~ oe\Delta 1vuqu
i tpintp0q, s2 \Gamma t` ThN~ vuqu
i Jp1 :i p2Kaeps0q

(2) On suppose que s0 P WFpSq. Comme Jp1Kae Y" L et L D^ domps0q, on a :

s0 ! s1, s1 P WFpSq et ` P domps1q :
Comme Jp2Kae Y" L et L D^ domps0q D^ domps1q, on a e'galement :

s1 ! s2, s2 P WFpSq et v Y" domps2q :
d'ou` l'on de'duit imme'diatement que s2\Gamma t` ThN~ vu P WFpSq et puisque ` P domps2q ona aussi

s0 I^ s2 \Gamma t` ThN~ vu.(3a) On suppose que

s0 P WFpSq. Si Jp1Kaeps0q i K alors Jp1Kaepextps0qq i K et doncJ
pKaepextps0qq i K. De me^me, si Jp2Kaeps1q i K alors Jp2Kaepextps1qq i K et doncJ
pKaepextps0qq i K.(3b) On suppose que

s0 P WFpSq. On a Jp1Kaepextps0qq i tpaddrpoe1`q, oe1extps1qqu etaussi : J

p2Kaepoe1extps0qq i oe1pJp2Kaepextps0qqq poe1Jp2Kae i Jp2Kaeq

i oe1tpoe2v, oe2extps2qqu pHIq
i tpoe1oe2v, oe1oe2extps2qqu

avec oe1 i rotps0, s1q et oe2 i rotps1, s2q. Par conse'quent, on a oe1 P Fixpdomps0qq et
oe2 P Fixpdomps1qq. Puisque ` P domps1q on a aussi oe2` i ` et ` , freepextps2qq0, d'ou`

152 Chapitre 6 - Se'mantique de'notationnelle de MLimp

l'on tire pextps2q\Gamma t` ThN~ vuq i extps2 \Gamma t` ThN~ vuq. On peut donc de'duire :J

p1 :i p2Kaepextps0qq i tpintp0q, oe1oe2extps2q\Gamma toe1` ThN~ oe1oe2vuqu

i oe1oe2tpintp0q, extps2q\Gamma t` ThN~ vuqu
i oe1oe2tpintp0q, extps2 \Gamma t` ThN~ vuqqu

fl Cas ou` p j!q (de're'fe'renciation). Soit s P S tel que L D^ dompsq. On suppose queJ!

qKaepsq i tpv, s1qu avec :- J

qKaepsq i tpaddrp`q, s1qu, ` P domps1q ;-
v i s1p`q.(1) par hypothe`se d'induction, on a

oeJqKae i JqKae et donc :

poeJ!qKaeqpsq i oetpoe\Delta 1ps1p`qq, oe\Delta 1s1qu i tps1p`q, s1qu
(2) On suppose que s P WFpSq. Par hypothe`se d'induction, on a donc que s1 P WFpSqet

` P domps1q, d'ou` l'on tire imme'diatement que s1p`q Y" domps1q.(3a) On suppose que

s P WFpSq. Si JqKaepsq i K alors JqKaepextpsqq i K. Par suite,J!
qKaepsq i K implique JqKaepextpsqq i K.(3b) On suppose que

s P WFpSq. Puisque ` P domps1q, alors extps1qp`q i s1p`q. On ve'rifiedonc que : J

!pKaepextpsqq i tppoeextps1qqpoe`q, oeextps1qqu

i tpoepextps1qp`qq, oeextps1qqu
i oetppextps1qqp`q, extps1qqu
i oetps1p`q, extps1qqu

ou` oe i rotps, s1q. oe

Comparaison avec la logique de se'paration On pourra remarquer que la condition(2) correspond intuitivement a` la proprie'te' de monotonie de la re`gle frame de la logique de
se'paration, a` savoir qu'une formule vraie pour une portion donne'e de l'e'tat me'moire restevraie pour toute extension de cet e'tat obtenue par allocation de nouvelles adresses. Il est donc
normal de retrouver a` la fois ici et dans la logique de se'paration, la me^me restriction sur lesprogrammes interdisant la libe'ration d'adresses me'moire.

7
Se'mantique de Kripke de MLDL

C

e chapitre est de'die' a` la construction du mode`le de MLDL et a` la preuve de correctionassocie'e. Le mode`le est pre'sente' dans la Section 7.1. La fonction d'interpre'tation et les

re'sultats de correction (G-invariance, domination et substitution) sont pre'sente's dansla Section 7.2. La correction de l'e'valuation symbolique sur les formules vis-a`-vis du mode`le
ainsi que la cohe'rence de MLDL sont e'tablis a` la Section 7.6.

7:1 Construction du mode`le

7:1:1 Vue d'ensemble

Mode`le de Kripke Le mode`le de MLDL que nous pre'sentons dans ce chapitre est unmode`le de Kripke dans l'esprit des mode`les de la logique dynamique (Section 2.2). Les mondes

sont interpre'te's par les stores se'mantiques bien forme's (qui repre'sentent les e'tats me'moire)tandis que chaque modalite' est interpre'te'e par une relation d'accessibilite' dans l'esprit de la
logique dynamique. Cependant, notre mode`le n'est pas a` strictement parler une instance dela notion de mode`le pre'sente'e a` la Section 2.2.2 car le langage de formules de MLDL est bien
plus riche que celui de la logique dynamique. En particulier :

i. Le mode`le n'est pas construit a` partir de la se'mantique ope'rationnelle du langage (tellequ'elle a e'te' de'finie au Chapitre 3) mais a` partir de sa se'mantique de'notationnelle (de'finie

au Chapitre 6). Dans notre mode`le, les points (ou mondes) sont des stores se'mantiquesbien forme's, tandis que les individus sont interpre'te's par des e'le'ments du

G-dcpo V(et non pas par des valeurs syntaxiques). Une conse'quence de ce choix de design est

que le mode`le comporte bien plus de relations d'accessibilite' que de programmes -- ily a en fait une relation pour chaque couple programme-valuation. De plus, il ne s'agit
pas de relations binaires sur les points de l'univers, mais de relations ternaires ou` figuree'galement la valeur calcule'e par le programme.
ii. Le domaine d'interpre'tation des individus n'est pas constant, mais de'pend du point(monde) conside're'. En effet, l'ensemble des valeurs bien forme'es vis-a`-vis d'un e'tat me'moire donne' croi^t avec cet e'tat. C'est la raison pour laquelle les quantifications ne com-mutent pas avec le

*-lieur et avec les boi^tes.

154 Chapitre 7 - Se'mantique de Kripke de MLDL

iii. La correction de l'e'valuation symbolique repose sur les proprie'te's d'invariance du mode`levis-a`-vis des permutations d'adresses (commutation des modalite's). Par conse'quent, les

notions de G-invariance et de domination de'finies dans le chapitre pre'ce'dent devronte^tre e'tendues a` toute la structure du mode`le, y compris aux pre'dicats se'mantiques qui
interpre`tent les individus du second ordre.
Remarque 7.1.1. Par ailleurs, on a vu (Section 4.1.3) que les updates peuvent e^tre vus commedes boi^tes particulie`res :

tv1 :i v11; : : : ; vk :i v1kuA j rv1 :i v11; : : : ; vk :i v1ks A. Il en est deme^me pour le
*-lieur : bien que la syntaxe interdise de lier un nom d'adresse par autre chosequ'un
*-lieur, les formules

*ff: A et rref 0 as ffs A

sont moralement e'quivalentes. C'est la raison pour laquelle les trois modalite's du langage(update,

*-lieur et boi^te) correspondent se'mantiquement au me^me type de relation d'acces-sibilite' de'finie par la de'notation des programmes, a` cette diffe'rence pre`s que les

*-lieurs etles updates correspondent a` des relations d'accessibilite' fonctionnelles et totales (les relations

associe'es au boi^tes e'tant fonctionnelles, mais pas toujours totales).

Un mode`le dans Set Le mode`le de MLDL est construit a` partir du mode`le de'notationnelde ML

imp. Mais il est important de noter qu'on utilisera les objets du mode`le de'notationnel(
V, S, VAL, etc) en oubliant leur structure de dcpo. Ceci est impose' par le fait que la boi^ten'est pas une ope'ration continue (ni me^me monotone) vis-a`-vis de l'ordre de Scott. Pour s'en

convaincre, il suffit de conside'rer l'exemple suivant : soit A la formule

A j xx 0 as _y J
qui exprime que la fonction de'signe'e par x termine quand on l'applique a` l'entier 0. Dans lemode`le, on se donne une valuation

ae quelconque, et on conside`re les deux fonctions f et gde'finies par
f pv, sq i K (fonction << inde'finie >>) et f pv, sq i tpv, squ (<< identite' >>) pour toute'tat bien forme'

pv, sq. Par construction, on a f d^ g, et donc pae, x DH f q d^ pae, x DH gq dansl'espace des valuations. Pourtant, on aura (dans n'importe quel store

s bien forme')

xs, pae, x DH f qy --u` A tandis que xs, pae, x DH gqy --u` A :
Le mode`le de MLDL est donc construit dans la cate'gorie Set ou` V, S, etc, seront conside're'suniquement en tant qu'ensembles. Cela ne nous empe^chera pas de conside'rer ces ensembles
munis de leur action du groupe G des permutations d'adresses a` support fini.

7:1:2 Structure du mode`le

Les mondes L'univers du mode`le est constitue' par l'ensemble des stores de'notationnelsbien forme's, note'

Swf . Autrement dit :

Swf i WFpSq
On rappelle que oes P Swf pour tout oe P G et s P Swf , autrement dit l'ensemble Swf est clospar action de groupe. On peut donc munir de l'action du groupe

G induite par l'action de Gsur
S.

7.1. Construction du mode`le 155
Individus du premier ordre : valeurs bien forme'es Soit V le G-dcpo des valeursse'mantiques, de'fini au Chapitre 6. Chaque variable du premier ordre est interpre'te'e, dans un

store s P Swf donne', par un e'le'ment du sous-ensemble Vs D^ V de'fini par :

Vs i tv P V : v Y" dompsqu :
Dans ce qui suit, on utilisera le sous-ensemble Vs D^ V comme domaine de quantification desindividus dans le store

s. Comme s I^ s1 implique Vs D^ Vs1, toute valeur bien forme'e dans unstore reste bien forme'e dans tout store ulte'rieur. On pourra noter que l'ensemble

Vs n'est pasclos par action de groupe, mais on ve'rifie aise'ment que la fonction qui a` tout store

s associel'ensemble
Vs est G-invariante :

Lemme 7.1.Pour tout store bien forme'

s P Swf et toute permutation oe P G, on a oeVs i Voes.

Certificats Soit k e^ 0 fixe'. On appelle un certificat d'arite' k (ou un k-certificat) tout

pk \Gamma  1q-uplet de la forme ps, v1, : : : , vkq, ou` s P Swf et v1, : : : , vk P Vs. L'ensemble des k-certificats, note' Cert

k, est donc de'fini par

Certk i y"

sPSwf

Vks :

Cet ensemble (que nous ne munissons d'aucune structure d'ordre) est naturellement munid'une action du groupe

G donne'e par :

oeps, v1, : : : , vkq i poes, oev1, : : : , oevkq
pour tous ps, v1, : : : , vkq P Certk et oe P G.

Individus du second ordre : les pre'dicats Dans ce qui suit, on interpre'tera lesvariables du second ordre d'arite'

k par des ensembles de k-certificats, c'est-a`-dire par dese'le'ments de l'ensemble Pred
k de'fini par

Predk i PpCertkq :
L'ensemble Predk est lui-me^me muni d'une action du groupe G qui est de'finie par :

oeP i poes, oev1, : : : , oevkq : ps, v1, : : : , vkq P P (

i ps, v1, : : : , vkq P Certk : poe\Delta 1s, oe\Delta 1v1, : : : , oe\Delta 1vkq P P (

pour tous P P Predk et oe P G.

Relation de domination sur Predk E'tant donne's un pre'dicat P P Predk et unensemble fini d'adresses

L P PfinpLq, on dit que P est domine' par L et on note P Y" L lorsque
oeP i P pour tout oe P FixpLq. Autrement dit :

P Y" L o^ @oe P FixpLq oeP i P

o^ @oe P FixpLq @ps, v1, : : : , vkq P Certki

ps, v1, : : : , vkq P P o^ poes, oev1, : : : , oevkq P P , :

156 Chapitre 7 - Se'mantique de Kripke de MLDL

(On ve'rifie aise'ment que les deux conditions P Y" L et L D^ L1 impliquent P Y" L1.) Dans ce quisuit, les variables du second ordre seront interpre'te'es dans un store

s donne' par les e'le'mentsde l'ensemble Pred
ks de'fini par

Predks i tP P Predk : P Y" dompsqu :
En particulier, s I^ s1 implique Predks D^ Predks1 . En posant oePredks i toeP -- P P Predks u onve'rifie la` aussi imme'diatement que la fonction qui a` tout store

s P Swf et tout entier k associel'ensemble Pred
ks est G-invariante :

Lemme 7.2.Pour tout

k P N, s P Swf et toute permutation oe P G, on a oePredks i Predkoes.

Les valuations logiques On appelle une valuation logique toute fonction ae de domainefini qui :

- a` chaque variable du premier ordre x P dompaeq, associe un e'le'ment aepxq P V ;- a` chaque adresse symbolique

ff P dompaeq, associe une adresse aepffq P L, de telle sorteque pour tous
ff , fi on ait aepffq , aepfiq ;- associe un pre'dicat d'arite'

k aepXq P Predk a` chaque variable du second-ordre X d'ar-ite'
k appartenant au domaine (fini) de ae.

Clo^ture par une valuation logique E'tant donne'es une valuation logique ae et uneformule

A, on dira que ae clo^t la formule A si et seulement si :- toutes les variables du 1er et 2e ordre libres de

A sont lie'es dans ae : FVpAq D^ dompaeq ;- tous les noms d'adresses libres de
A sont lie's dans ae : FNpAq D^ dompaeq.

Action du groupe G L'ensemble des valuations logiques est muni d'une action dugroupe

G de'finie par :-
poeaeqpxq i oepaepxqq pour toute variable du premier ordre x ;-
poeaeqpffq i oepaepffqq pour toute adresse symbolique ff ;-
poeaeqpXq i oepaepXqq pour toute variable du second ordre X d'arite' k.

Effacement des liaisons logiques Une valuation logique est essentiellement une valu-ation de'notationnelle (cf chap. 6) a` laquelle on a ajoute' des liaisons de la forme

X DH P (ou` Xest une variable du second ordre d'arite'
k et P P Predk). Pour toute valuation logique ae,on note
--ae-- la valuation de'notationnelle obtenue en conservant dans ae toutes les liaisons devariables et de noms d'adresses, et en effac,ant toutes les liaisons de variables du second ordre.

Par de'finition, on a donc les e'galite's :

--ae, x DH v-- i --ae--, x DH v

--ae, ff DH `-- i --ae--, ff DH `
--ae, X DH P -- i --ae--

--oeae-- i oe--ae--

pv P Vq

p` P Lq
pP P Predkq

poe P Gq

On ve'rifie aussi imme'diatement que si une valuation logique ae clo^t un programme p, alorsla valuation de'notationnelle

--ae-- clo^t p.

7.2. Interpre'tation et correction de MLDL 157
Relation de domination sur les valuations logiques E'tant donne's une valuationlogique

ae et un ensemble fini d'adresses L P PfinpLq, on note ae Y" L lorsque :

1. --ae-- Y" L au sens des valuations de'notationnelles ;
2. aepXq Y" L pour toute variable du second ordre X.
On notera que par de'finition, la relation de domination ae Y" L implique que oeae i ae pour tout
oe P FixpLq.

7:2 Interpre'tation et correction de MLDL

7:2:1 Interpre'tation des updates

Interpre'tation Chaque update est interpre'te' par une fonction de modification des stores,c'est a` dire par une fonction continue dans l'espace

Swf N~ Swf . Formellement, a` toute valua-tion de'notationnelle
ae P VALsym qui clo^t (les valeurs symboliques qui sont dans) u et a` toutstore
s P Swf, on associe un store JuKaepsq de'fini par induction sur u a` l'aide des e'quations :J

?Kaepsq i sJ

u; v1 :i v2Kaepsq i $'&'%J

uKaepsq \Gamma  t` :i Denpv2qaeu si Denpv1qae i addrp`q,avec

` P dompsq;J

uKaepsq sinon:

On notera que dans tous les cas on a dompJuKaepsqq i dompsq et Ju ; u1Kae i Ju1Kae \Pi  JuKae. Onve'rifie donc aise'ment que :

Lemme 7.3.Soit

u un update, s P Swf et ae P VALsym qui clo^t u. On a :

1. freepJuK--ae--psqq i freepsq ;
2. extpJuK--ae--psqq i JuK--ae--pextpsqq.

Correction Le lemme suivante e'tablit que les updates pre'servent la bonne formation desstores. La proposition suivante e'tablit la correction de l'application des updates (de'finie a` la

Section 4.1.2) vis a` vis de l'interpre'tation des updates et des valeurs.
Lemme 7.4.Soient

u un update, ae une valuation qui clo^t u et s P Swf. Si ae Y" dompsq et JuKaepsq i s1, alorson a dom

ps1q i dompsq et s1 P Swf .

Proposition 7.1 (Correction de l'application des updates).Soient

u, v, s et ae qui clo^t u et v. Si JuKaepsq i s1, alors le programme tuu!v est interpre'te'dans
Swf N~ pV \Theta  Swf qK par la fonction continue suivante :

Jtuu!vKaepsq i $'&'%

tps1p`q, squ si Denpvqae i addrp`q

et ` P dompsq i domps1q
K sinon

158 Chapitre 7 - Se'mantique de Kripke de MLDL

De'monstration :On montre le re'sultat par induction sur la structure de l'update

u. Le cas de base estdonne' par la de'finition J!vK
ae. Posons u i pu1 ; v1 :i v2q. On a soit s1 i Ju1Kaepsq (auquel casl'hypothe`se d'induction suffit), soit

s1 i s2 \Gamma t`1 ThN~ Denpv2qaeu avec :-

s2 i Ju1Kaepsq-
`1 P dompsq- Den

pv1qae i addrp`1qOn distingue alors deux cas. Si Den

pvq i addrp`q et ` , `1, alors Jv i v1Kaepsq i tpintp0q, squet donc :

Jtuu!vKaepsq i Jif v i v1 then v2 else tu1u!vKaepsq

i Jtu1u!vKaepsq
i tps2p`q, squ pHIq
i tps1p`q, squ p` , `1q

Si Denpvqae i Denpv1qae i addrp`1q, alors Jv i v1Kaepsq i tpintpnq, squ (n , 0) et donc :J

tuu!vKaepsq i Jif v i v1 then v2 else tuu!vKaepsq

i Jv2Kaepsq
i tpDenpv2qae, squ
i tps1p`q, squ oe

Proposition 7.2 (Substitution sur les updates).Soient

u un update, v une valeur symbolique. Pour toute valuation de'notationnelle ae P VALsymqui clo^t

u et v, on a Jprv-xsuqKae i JuKae;xThN~Denpvqae.

De'monstration :Par induction sur

u. Le cas de base (u i ?) est trivial. Pour le cas inductif, on pose
ae1 i ae; x ThN~ Denpvqae. Soit s P Swf . Alors :J

rv-xspu1 ; v1 :i v2qKaepsq i Jrv-xsu1 ; prv-xsv1 :i rv-xsv2qKaepsq

i pJrv-xsu1Kaepsqq\Gamma tDenprv-xsv1qae ThN~ Denprv-xsv2qaeu
i pJu1Kae1psqq\Gamma tDenprv-xsv1qae ThN~ Denprv-xsv2qaeu pHIq
i pJu1Kae1psqq\Gamma tDenpv1qae1 ThN~ Denpv2qae1u pCor. 6.30.1q
i Ju1 ; v1 :i v2Kae1 oe

Proposition 7.3 (G-invariance des updates).Soient

u un update, ae P VALsym une valuation qui clo^t u et s P Swf. Alors, pour toute permu-tation
oe P G, on a : J

uKoeaepoesq i oe\Gamma JuKaepsq\Phi 

De'monstration :

7.2. Interpre'tation et correction de MLDL 159
Induction sur u dont le cas critique est donne' par :

oepJu1 ; v1 :i v2Kaepsqq i oepJu1Kaepsq\Gamma tDenpv1qae ThN~ Denpv2qaeuq

i oepJu1Kaepsqq\Gamma toeDenpv1qae ThN~ oeDenpv2qaeu
i oepJu1Kaepsqq\Gamma tDenpv1qoeae ThN~ Denpv2qoeaeu pProp. 6:25q
i Ju1Koeaepoesq\Gamma tDenpv1qoeae ThN~ Denpv2qoeaeu pHIq
i Ju1 ; v1 :i v2Koeaepoesq oe

7:2:2 Interpre'tation des formules

Satisfaisabilite' E'tant donne'e une formule A, on appelle environnement d'interpre'tationde

A tout couple xs, aey compose' d'un store bien forme' et d'une valuation logique ae qui clo^t
A et qui est domine'e par s :

- s P Swf ;-

ae clo^t A ;-
ae Y" dompsq (au sens des valuations logiques).

La satisfaisabilite' d'une formule est toujours de'finie dans un environnement d'interpre'tation.

De'finition 7.2.1 (Satisfaisabilite' des formules).Soient

A une formule et xs, aey un environnement d'interpre'tation de A. La relation de satis-faisabilite'

xs, aey --u` A est de'finie par les e'quivalences de la Figure 7.1.

xs, aey --u` Xpv1, : : : , vkq ssi ps, Denpv1q--ae--, : : : , Denpvkq--ae--q P aepXq
xs, aey --u` Ipvq ssi Denpvq--ae-- i tintpnqu et n , 0
xs, aey --u` B ssi xs, aey * B
xs, aey --u` B ^ C ssi xs, aey --u` B et xs, aey --u` C
xs, aey --u` @x: B ssi pour toute v P Vs, xs, ae; x ThN~ vy --u` B
xs, aey --u` @Xn: B ssi pour toute P P Predks , xs, ae; X ThN~ P y --u` B
xs, aey --u` *ff:B ssi xextpsq, ae; ff ThN~ freepsq0y --u` B
xs, aey --u` tuuB ssi xJuK--ae--psq, aey --u` B

xs, aey --u` rp as xs B ssi #J si JpK--ae--psq i Kxs1, ae; x ThN~ v1y --u` B si JpK

--ae--psq i tpv1, s1qu

Figure 7.1 - Interpre'tation des formules

160 Chapitre 7 - Se'mantique de Kripke de MLDL

A` partir de la de'finition pre'ce'dente, on e'tend imme'diatement la se'mantique aux construc-tions de'rive'es de la manie`re suivante :

xs, aey --u` B . C ssi xs, aey --u` B ou xs, aey --u` C
xs, aey --u` B N~ C ssi xs, aey --u` B implique xs, aey --u` C
xs, aey --u` Dx: B ssi il existe v P Vs telle que xs, ae; x ThN~ vy --u` B
xs, aey --u` DXn: B ssi il existe P P Predks tel que xs, ae; X ThN~ P y --u` B

xs, aey --u` xp as xy B ssi #K si JpK--ae--psqxs1, ae; x ThN~ v1y --u` B si JpK

--ae--psq i tpv1, s1qu

La de'finition 7.2.1 s'e'tend imme'diatement a` la notion de se'quent en interpre'tant les vir-gules a` gauche du signe the`se comme des conjonctions, les virgules a` droite comme des disjonctions et le signe the`se comme une implication. On a donc :

xs, aey --u` p\Gamma  $ \Delta q ssi xs, aey --u` ^\Gamma  implique xs, aey --u` .\Delta 

Exemple (Domaine non constant) Le domaine de valeur des individus du premierordre est de'fini a` partir des adresses alloue'es dans le store courant. C'est pourquoi la quantification du premier ordre et le *-lieur ne peuvent pas e^tre permute's. On ve'rifie par exempleque les deux formules

A j Dx: *ff: rx :i 3 ; !x as ys Ipy i 3q B j *ff: Dx: rx :i 3 ; !x as ys Ipy i 3q
ne sont pas e'quivalentes se'mantiquement. Un contre-exemple est donne' avec s? i p?, ", ?q.Pour toute valuation logique

ae ne contenant pas d'adresse (ae Y" ?), on a :

xs?, aey * A et xs?, aey --u` B:
Dans le premier cas, la variable x ne peut pas e^tre instancie'e par une adresse. A` chaquefois, l'e'valuation symbolique de la boi^te produira une erreur et la variable

y sera instancie'epar 0. Dans le second cas, il suffit d'instancier la variable
x par l'adresse "0 qui vient d'e^trealloue'e.

Substitutivite' du premier ordre et G-invariance

Proposition 7.4 (Substitution du premier ordre sur les formules).Soient

A une formule, x une variable et v une valeur symbolique. Quel que soit xs, aey,environnement d'interpre'tation de la formule

rv-xsA, on a :

xs, aey --u` prv-xsAq ssi xs, ae; x ThN~ Denpvq--ae--y --u` A
De'monstration :On raisonne par induction sur la structure de la formule

A, en supposant que la variable
x n'apparai^t pas lie'e dans A. On pose ae1 i ae; x ThN~ Denpvq--ae-- :

7.2. Interpre'tation et correction de MLDL 161
Si A i Xpv1, : : : , vkq :

xs, aey --u` prv-xsXpv1, : : : , vkqq
o^ xs, aey --u` Xprv-xsv1, : : : , rv-xsvkq
o^ ps, Denprv-xsv1q--ae--, : : : , Denprv-xsvkq--ae--q P aepXq
o^ ps, Denpv1qae1 , : : : , Denpvkqae1 q P aepXq pCor. 6.30.1q
o^ ps, Denpv1qae1 , : : : , Denpvkqae1 q P ae1pXq
o^ xs, ae; x ThN~ Denpvq--ae--y --u` Xpv1, : : : , vkq

Si A i tuuB :

xs, aey --u` rv-xsptuuBq o^ xs, aey --u` trv-xsuurv-xsB

o^ xJrv-xsuKaepsq, aey --u` rv-xsB
o^ xJuKae1psq, aey --u` rv-xsB (Prop. 7.2)
o^ xJuKae1psq, ae1y --u` B (HI)
o^ xs, ae; x ThN~ Denpvq--ae--y --u` tuuB

Si A i rp as ys B :On suppose que

y , x (modulo ff-renommage). Par ailleurs, la Proposition 6.30 donneJ
rv-xspKae i JpKae1. Par suite, quel que soit le couple pv, s1q tel que Jrv-xspKae i tpv, s1qu,on a

tpv, s1qu i JpKae1, d'ou` l'on conclut par (HI) : xs, aey --u` rprv-xspq as ys prv-xsBq ssi
xs, ae1y --u` rp as ys B. oe

Corollaire 7.4.1 (Substitution paralle`le).Soient

A une formule, x1, : : : , xn des variables du premier ordre et v1, : : : , vn des valeurssymboliques. Quel que soit l'environnement d'interpre'tation

xs, aey, on a :

xs, aey --u` rv1-x1, : : : , vn-xnsA ssi xs, ae; x1 ThN~ Denpv1q--ae-- ; \Xi  \Xi  \Xi  ; xn ThN~ Denpvnq--ae--y --u` A

Proposition 7.5 (G-invariance de la satisfaisabilite').Soient

A une formule, oe P G et xs, aey un environnement d'interpre'tation de A, on a :

xs, aey --u` A ssi xoes, oeaey --u` A

De'monstration :Induction sur la structure de

A dont les cas critiques sont donne's par :

Si A i Xpv1, : : : , vnq : xs, aey --u` Xpv1, : : : , vnq

o^ ps, Denpv1q--ae--, : : : , Denpvnq--ae--q P aepXq
o^ poes, oeDenpv1q--ae--, : : : , oeDenpvnq--ae--q P oeaepXq
o^ poes, Denpv1qoeae, : : : , Denpvnqoeaeq P oeaepXq pProp. 6.25q
o^ poes, Denpv1qoeae, : : : , Denpvnqoeaeq P poeaeqpXq poeae idef oe \Pi  aeq
o^ xoes, oeaey --u` Xpv1, : : : , vnq

162 Chapitre 7 - Se'mantique de Kripke de MLDL

Si A i @x: B : conse'quence imme'diate de l'hypothe`se d'induction et du Lemme 7.1.
Si A i @Xk: B : conse'quence imme'diate de l'hypothe`se d'induction et du Lemme 7.2.
Si A i *ff: B :

xs, aey --u` *ff: B o^ xextpsq, ae; ff ThN~ freepsq0y --u` B

o^ xoepextpsqq, oepae; ff ThN~ freepsq0qy --u` B (HI)
o^ xextpoesq, oepaeq; ff ThN~ freepoesq0y --u` B pLemme 6.5q
o^ xoes, oeaey --u` *ff: B

Si A i tuuB :

xs, aey --u` tuuB o^ xJuK--ae--psq, aey --u` B

o^ xoepJuK--ae--psqq, oeaey --u` B (HI)
o^ xJuK--oeae--poesq, oeaey --u` B (Prop. 7.3)
o^ xoes, oeaey --u` tuuB

Si A i rp as xs B :Si J

pKaepsq i K alors par la Proposition 6.25 on a JpKoeaepoesq i oepJpKaepsqq i K, d'ou` l'onpeut conclure

xs, aey --u` rp as xs B i K i xoes, oeaey --u` rp as xs A.Si J
pKaepsq i tpv1, s1qu, alors on a JpKoeaepoesq i oepJpKaepsqq i tpoev1, oes1qu (Proposition 6.25),d'ou` l'on peut conclure :

xs, aey --u` rp as xs B o^ xs1, ae; x ThN~ v1y --u` B

o^ xoes1, oepae; x ThN~ v1qy --u` B (HI)
o^ xoes1, oeae; x ThN~ oev1qy --u` B
o^ xoes, oeaey --u` rp as xs B oe

De'notation d'un pre'dicat syntaxique et substitution du second ordre Dansle syste`me MLDL, chaque variable du second ordre d'arite'

k peut e^tre substitue'e (dans uneformule) par un pre'dicat syntaxique d'arite'
k, c'est-a`-dire par une formule abstraite parrapport a`
k-variables du premier ordre.Soit donc un pre'dicat syntaxique d'arite'

k, donne' sous la forme d'une formule B abstraitepar rapport a`
k variables du premier ordre x1, : : : , xk (et de'pendant e'ventuellement d'autresvariables du premier comme du second ordre). A` toute valuation logique

ae qui clo^t toutes lesvariables libres de
B sauf x1, : : : , xk, on associe le pre'dicat << se'mantique >> Pae P Predk de'finipar :

Pae i tps, v1, : : : , vkq P Certk : ae Y" dompsq ^ xs, pae, x1 DH v1, : : : , xk DH vkqy --u` Bu :
(On notera que dans le membre droit de l'e'galite' ci-dessus, la condition ae Y" dompsq per-met de s'assurer que

pae, x1 DH v1, : : : , xk DH vkq Y" dompsq, proprie'te' sans laquelle l'assertion
xs, pae, x1 DH v1, : : : , xk DH vkqy --u` B n'a pas de sens.)

Lemme 7.5 (Domination des pre'dicats se'mantiques).Pour toute valuation logique

ae qui clo^t B sauf x1, : : : , xk et pour tout ensemble fini d'adresses
L P PfinpLq. Si ae Y" L (au sens des valuations logiques) alors Pae Y" L (au sens des pre'dicats).

De'monstration :

7.2. Interpre'tation et correction de MLDL 163
Il s'agit de ve'rifier que pour tout oe P FixpLq, on a oePae i Pae. On commence par remarquerque puisque

ae Y" L et oe P FixpLq, alors oeae i oe\Delta 1ae i ae. Soit ps, v1, : : : , vkq P Certk :

ps, v1, : : : , vkq P oePae
o^ poe\Delta 1s, oe\Delta 1v1, : : : , oe\Delta 1vkq P Pae pae Y" dompsqq
o^ xoe\Delta 1s, pae; x1 ThN~ oe\Delta 1v1; : : : ; xk ThN~ oe\Delta 1vkqy --u` B pDe'f. Pae \Gamma  ae Y" dompsqq
o^ xoe\Delta 1s, oe\Delta 1pae; x1 ThN~ v1; : : : ; xk ThN~ vkqy --u` B poe\Delta 1ae i ae car ae Y" dompsqq
o^ xs, ae; x1 ThN~ v1; : : : ; xk ThN~ vky --u` B pProp. 7.5 \Gamma  ae Y" dompsqq
o^ ps, v1, : : : , vkq P Pae pae Y" dompsqqoe

Lemme 7.6 (Substitutivite' au second ordre).Soit

A une formule de'pendant e'ventuellement d'une variable du second ordre X d'arite' k.Pour tout store

s P S et pour toute valuation logique ae qui clo^t A et B (sauf x1, : : : , xk) telleque
ae Y" dompsq, on a :

xs, aey --u` rB-Xx1:::xk sA o^ xs, pae, X DH Paeqy --u` A :

De'monstration :Induction sur

A dont le cas critique est A i Xpv1, : : : , vnq.

xs, aey --u` rB-Xx1:::xnsXpv1, : : : , vnq
o^ xs, aey --u` rv1-x1, : : : , vn-xnsB
o^ xs, ae; x1 ThN~ Denpv1q--ae-- ; \Xi  \Xi  \Xi  ; xn ThN~ Denpvnq--ae--y --u` B pCor. 7.4.1q
o^ ps, Denpv1q--ae--, : : : , Denpvnq--ae--q P Pae pDe'f. Paeq
o^ ps, Denpv1q--ae--, : : : , Denpvnq--ae--q P pae; X ThN~ PaeqpXq
o^ xs, ae; X ThN~ Paey --u` Xpv1, : : : , vnq p--ae; X ThN~ Pae-- i --ae--qoe

7:2:3 Correction et cohe'rence de MLDL

Dans cette section, on e'tablit la correction de MLDL vis-a`-vis du mode`le. Pour cela, nousmontrerons tout d'abord la correction de l'e'valuation symbolique les formules (congruence
sur les updates et congruence sur les formules) et ensuite la correction du syste`me de'ductif.La cohe'rence de MLDL est une conse'quence triviale de ce re'sultat.

pu ; ff :i v1 ; fi :i v2q * pu ; fi :i v2 ; ff :i v1q
pu ; ff :i v1 ; ff :i v2q * pu ; ff :i v2q

v1 * v11
pu ; v1 :i v2q * pu ; v11 :i v2q

v2 * v12
pu ; v1 :i v2q * pu ; v1 :i v12q

Figure 7.2 - Rappel : E'valuation symbolique des updates

164 Chapitre 7 - Se'mantique de Kripke de MLDL

Proposition 7.6 (Congruence des updates).Soient

u et u1 deux updates et ae une valuation de'notationnelle qui clo^t u. Si u * u1, alorsJ
uKae i Ju1Kae.

De'monstration :Puisque

ff , fi, alors paepffq , aepfiqq et :

1. Ju ; ff :i v1 ; fi :i v2Kaepsq i JuKaepsq\Gamma taepffq ThN~ Denpv1qaeu\Gamma taepfiq ThN~ Denpv2qaeu

i JuKaepsq\Gamma taepfiq ThN~ Denpv2qaeu\Gamma taepffq ThN~ Denpv1qaeu
i Ju ; fi :i v2 ; ff :i v1Kaepsq

2. Ju ; ff :i v1 ; ff :i v2Kaepsq i JuKaepsq\Gamma taepffq ThN~ Denpv1qaeu\Gamma taepffq ThN~ Denpv2qaeu

i JuKae \Gamma taepffq ThN~ Denpv2qaeu
i Ju ; ff :i v2Kaepsq

3. v1 * v

11

pu ; v1 :i v2q * pu ; v11 :i v2q
(Le raisonnement est identique pour la dernie`re re`gle) Par le Corollaire 6.31.1, il vientDen

pv1qae i Denpv11qae. On a donc :J

u ; v1 :i v2Kaepsq i JuKaepsq\Gamma tDenpv1qae ThN~ Denpv2qaeu

i JuKaepsq\Gamma tDenpv11qae ThN~ Denpv2qaeu
i Ju ; v11 :i v2Kaepsq oe

Proposition 7.7 (Congruence des formules).Soient

A et A1 deux formules. Si A * A1, alors quel que soit xs, aey, environnement d'inter-pre'tation de

A et A1, on a :

xs, aey --u` A ssi xs, aey --u` A1

De'monstration :Soient

s P S un store et ae une valuation. On montre par induction sur A * A1 que
xs, aey --u` A si et seulement si xs, aey --u` A1.

Injection des valeurs symboliques(inj

K, injJ) : de'coule directement de la De'finition 7.2.1.(inj
^) : xs, aey --u` Ipvq ^ Ipv1q ssi Denpvqae i tintpnqu, Denpv1qae i tintpmqu et n , 0 , mssi
n \Theta  m , 0 ssi xs, aey --u` Ipv \Theta  v1q.De'composition des boi^tes

(alloc) : on remarque d'abord que pextpsq\Gamma tfreepsq0 ThN~ vuq i ps\Gamma tfreepsq0 ThN~ vuq.

xs, aey --u` rref v as xs A

o^ xextpsq\Gamma tfreepsq0 ThN~ Denpvqaeu, ae; x ThN~ freepsq0y --u` A

o^ xs\Gamma tfreepsq0 ThN~ Denpvqaeu, ae; x ThN~ freepsq0y --u` A
o^ xs\Gamma tfreepsq0 ThN~ Denpvqaeu, ae; ff ThN~ freepsq0; x ThN~ freepsq0y --u` A pff R FVpAqq
o^ xs\Gamma tfreepsq0 ThN~ Denpvqaeu, ae; ff ThN~ freepsq0y --u` rff-xsA (Prop. 7.4)
o^ xs\Gamma tfreepsq0 ThN~ 0u, ae; ff ThN~ freepsq0y --u` tff :i vurff-xsA
o^ xs, aey --u` *ff: tff :i vurff-xsA

7.2. Interpre'tation et correction de MLDL 165
(affec) : Imme'diat si Denpvqae n'est pas de la forme addrp`q. On pose Denpvqae i addrp`qet Den

pv1qae i v1.

xs, aey --u` rv :i v1 as xs A ssi xs\Gamma t` ThN~ v1u, ae; x ThN~ 0y --u` A

ssi xJv :i v1Kaepsq, ae; x ThN~ 0y --u` A
ssi xJv :i v1Kaepsq, aey --u` pr0-xsAq (Prop. 7.4)
ssi xs, aey --u` tv :i v1ur0-xsA

(del) :

xs, aey --u` rv as xs A ssi xs, ae; x ThN~ Denpvqaey --u` A pDe'f. 6.3.2q

ssi xs, aey --u` prv-xsAq pProp. 7.4q

(split) : Imme'diat si JpKaepsq i K ou JCespKaepsq i K. Posons (1) JpKaepsq i tpv1, s1qu et(2) JC

esppqKaepsq i tpv2, s2qu. Une induction e'vidente sur Ces permet de ve'rifier que (3)JC
espyqKae;yThN~v1ps1q i tpv2, s2qu.

xs, aey --u` rCesppq as xs A ssi xs2, ae; x ThN~ v2y --u` A p2q

ssi xs2, ae; y ThN~ v1; x ThN~ v2y --u` A py R FVpAqq
ssi xs1, ae; y ThN~ v1y --u` rCespyq as xs A p3q
ssi xs, aey --u` rp as ys rCespyq as xs A p1q

Propagation des updates

(upd I) :

xs, aey --u` tuuIpvq ssi xJuK--ae--psq, aey --u` Ipvq

ssi Denpvq--ae-- i tintpnqu et n , 0
ssi xs, aey --u` Ipvq

(upd @1) : puisque (*) x R FVpuq, on a :

xs, aey --u` tuu@x: A ssi xJuK--ae--psq, aey --u` @x: A

ssi pour toute v P Vs, xJuK--ae--psq, ae; x ThN~ vy --u` A
ssi pour toute v P Vs, xJuK--ae;xThN~v--psq, ae; x ThN~ vy --u` A p\Sigma q
ssi pour toute v P Vs, xs, ae; x ThN~ vy --u` tuuA
ssi xs, aey --u` @x: tuuA

(upd @2) :

xs, aey --u` tuu@Xn: Assi

xJuK--ae--psq, aey --u` @Xn: A

ssi pour tout P P Predns , xJuK--ae--psq, ae; X ThN~ P y --u` A
ssi pour tout P P Predns , xJuK--ae;XThN~P --psq, ae; X ThN~ P y --u` A p--ae; X ThN~ P -- i --ae--q
ssi pour tout P P Predns , xs, ae; X ThN~ P y --u` tuuA
ssi xs, aey --u` @Xn: tuuA

(upd *) : Par le Lemme 7.3 et puisque dompJuK--ae--psqq i dompsq, on a que :

freepextpJuK--ae--psqqq0 i freepJuK--ae--pextpsqqq0 i freepextpsqq0 p\Sigma q

166 Chapitre 7 - Se'mantique de Kripke de MLDL

On pose donc ` i freepextpsqq0 et on ve'rifie alors :

xs, aey --u` tuu*ff: A ssi xJuK--ae--psq, aey --u` *ff: A

ssi xextpJuK--ae--psqq, ae; ff ThN~ `y --u` A p\Sigma q
ssi xJuK--ae--pextpsqq, ae; ff ThN~ `y --u` A pLem. 7.3q
ssi xJuK--ae;ffThN~`--pextpsqq, ae; ff ThN~ `y --u` A pff R FNpuqq
ssi xextpsq, ae; ff ThN~ `y --u` tuuA
ssi xs, aey --u` *ff: tuuA

(upd seq) :

xs, aey --u` tuutu1uA ssi xJuK--ae--psq, aey --u` tu1uA

ssi xJu1K--ae-- \Pi  JuK--ae--psq, aey --u` A
ssi xJu ; u1K--ae--psq, aey --u` A
ssi xs, aey --u` tu ; u1uA

(read) : Posons JuK--ae--psq i s1 et Denpvq--ae-- i addrp`q avec ` P domps1q. Par la Proposi-tion 7.1, il vient J

tuu!vK--ae--psq i tps1p`q, squ. Par suite :

xs, aey --u` tuur!v as xs A ssi xJuK--ae--psq, aey --u` r!v as xs A

ssi xs1, ae; x ThN~ s1p`qy --u` A
ssi xs, ae; x ThN~ s1p`qy --u` tuuA px R FVpuqq
ssi xs, aey --u` rtuu!v as xs tuuA

Propagation du *-lieur(

*rule I) : imme'diat car ff R FNpvq.

(*rule commutation avec la boi^te) : On distingue deux cas suivant que JpK--ae--psq i Kou pas, en remarquant que dans les deux cas on a J

pK--ae-- Y" dompsq, puisque ae Y" dompsq.

Cas ou` JpK--ae--psq i K. Dans ce cas, l'assertion xs, aey --u` rp as xs*ff:A est vraie. Etcomme J

pK--ae-- Y" dompsq, on a JpK--ae--pextpsqq i K d'apre`s la condition de domination(3a). Par conse'quent, l'assertion

xs, aey --u` *ff:rp as xsA ,
qui par de'finition est e'quivalente a`

xextpsq, pae, ff DH freepsq0qy --u` rp as xsA ,
est elle aussi vraie.
Cas ou` JpK--ae--psq i tpv1, s1qu. Comme JpK--ae-- Y" dompsq, on a d'apre`s la condition dedomination (2) les assertions

s I^ s1, s1 P S et v1 Y" domps1q, ce qui nous permetnotamment d'introduire la permutation

oe i rotps, s1q. Et d'apre`s la condition dedomination (3b), on a e'galementJ

pK--ae,ffDHfreepsq0--pextpsqq i JpK--ae--pextpsqq i tpoev1, oeextps1qqu , p\Sigma q

7.2. Interpre'tation et correction de MLDL 167
en utilisant le fait que ff R FNppq. Ces diverses conside'rations nous permettentd'e'tablir les e'quivalences suivantes :

xs, aey --u` rp as xs*ff:A
o^ xs1, pae, x DH v1qy --u` *ff:A
o^ xextps1q, pae, x DH v1, ff DH freeps1q0qy --u` A
o^ xextps1q, pae, ff DH freeps1q0, x DH v1qy --u` A
o^ xoeextps1q, poeae, ff DH oefreeps1q0, x DH oev1qy --u` A pProp. 7.5q
o^ xoeextps1q, pae, ff DH oefreeps1q0, x DH oev1qy --u` A poeae i ae, car ae Y" dompsqq
o^ xoeextps1q, pae, ff DH freepsq0, x DH oev1qy --u` A poefreeps1q0 i freepsq0q
o^ xextpsq, pae, ff DH freepsq0qy --u` rp as xsA pd'apre`s p\Sigma qq
o^ xs, aey --u` *ff:rp as xsA

(*rule commutation entre *) : (Moralement, ce cas est une conse'quence du cas pre'ce'-dent.) On pose

`1 i freepsq0, `2 i freepextpsqq0 et oe i `1 O/ `2 la permutation quie'change
`1 et `2. Clairement `1 , `2. Finalement on a :

xs, aey --u` *ff: *fi: Assi

xextpextpsqq, ae; ff ThN~ `1; fi ThN~ `2y --u` A

ssi xoeextpextpsqq, oepae; ff ThN~ `1; fi ThN~ `2qy --u` A pProp. 7.5q
ssi xextpextpoesqq, oepae; ff ThN~ `1; fi ThN~ `2qy --u` A pLem. 6.5q
ssi xextpextpoesqq, ae; ff ThN~ `2; fi ThN~ `1y --u` A pDe'f. oeq
ssi xs, aey --u` *fi: *ff: A

Raisonnement par cas(cases) : Posons Den

pvq--ae-- i tintpnqu. Si n , 0, alors Jif n then p1 else p2K--ae-- i Jp1K--ae--,
xs, aey --u` Ipvq et xs, aey * Ipvq. Par conse'quent, on peut de'duire a` la fois :

xs, aey --u` Ipvq N~ rp1 as xs A et xs, aey --u` Ipvq N~ rp2 as xs A
On a donc l'e'quivalence voulue. Si n i 0, le raisonnement est tout a` fait similaire.
Passage aux contextesConcernant les re`gles de passage aux contextes de la congruence sur les programmes et

les updates, il s'agit de conse'quences directes de la Proposition 6.31 et de la Proposi-tion 7.6. Dans les autres cas, il s'agit de conse'quences directes de l'hypothe`se d'induction. oe

The'ore`me 7.1 (Correction du syste`me de'ductif).Soient \Gamma  et \Delta  des ensembles de formules bien forme'es. Si \Gamma 

$ \Delta , alors pour tout xs, aey,environnement d'interpre'tation de \Gamma  et \Delta , on a :
xs, aey --u` p\Gamma  $ \Delta q.

De'monstration :Induction sur la hauteur de la de'rivation de \Gamma 

$ \Delta . Les cas critiques sont donne's par :

168 Chapitre 7 - Se'mantique de Kripke de MLDL

Cas de la re`gle @2g : si xs, aey --u` p^\Gamma  ^ @Xn: Aq, alors xs, aey --u` ^\Gamma  et xs, aey --u` p@Xn: Aq.Par de'finition, on a donc

xs, ae; X ThN~ P y --u` A pour tout pre'dicat se'mantique P P Predns .Puisque
ae Y" dompsq, on a Pae Y" dompsq (Proposition 7.5). Il vient donc Pae P Predns .Par conse'quent, on a

xs, ae; X ThN~ Paey --u` A, d'ou` l'on tire que xs, aey --u` prB-Xx1:::xnsAq(Proposition 7.6). L'hypothe`se d'induction permet de conclure.

Cas de la re`gle @2d : si xs, aey --u` ^\Gamma , alors par (HI) on a xs, aey --u` A ou xs, aey --u` .\Delta . Si

xs, aey --u` .\Delta , on conclut imme'diatement. Sinon et puisque X R FVp\Delta q, alors pour toutpre'dicat se'mantique

P P Predns on a xs, ae; X ThN~ P y * .\Delta .Soit

P P Predns . Puisque X R FVp\Gamma q, il vient xs, ae; X ThN~ P y --u` ^\Gamma  et par (HI) il vient
xs, ae; X ThN~ P y --u` A ou xs, ae; X ThN~ P y --u` .\Delta . Or on a vu que xs, ae; X ThN~ P y * .\Delta ,c'est donc que

xs, ae; X ThN~ P y --u` A. On peut finalement conclure : xs, aey --u` p@Xn: Aq.

Cas de la re`gle *-ncs : la preuve repose sur la fonctionnalite' et la totalite' de la relationd'accessibilite' associe'e au

*-lieur. Supposons que xs, aey --u` p*ff: Aq pour toute formule
A P \Gamma . Alors xextpsq, ae; ff ThN~ freepsq0y --u` ^\Gamma . Par hypothe`se d'induction, il re'sulte que
xextpsq, ae; ff ThN~ freepsq0y --u` .\Delta . Si \Delta  i ?, alors on peut directement conclure. Sinon,il existe une formule

B appartenant a` \Delta  telle que xextpsq, ae; ff ThN~ freepsq0y --u` B c'est-a`-dire
xs, aey --u` *ff: B. On peut donc conclure.

Cas de la re`gle ncs-upd : De me^me, la preuve repose sur la fonctionnalite' et la totalite'de la relation d'accessibilite' associe'e a` l'update. Supposons que

xs, aey --u` ptuuAq pourtoute formule
A P \Gamma . Alors xJuK--ae--psq, aey --u` ^\Gamma . Par (HI), il vient xJuK--ae--psq, aey --u` .\Delta .Si \Delta 
i ?, alors on peut conclure directement. Sinon, il existe une formule B P \Delta  telleque
xJuK--ae--psq, aey --u` B. Finalement on a bien xs, aey --u` tuuB et on peut donc conclure.

Cas de la re`gle ncs-box : Si JpKaepsq i K, alors soit \Gamma  i ? et on peut conclure imme'di-atement car

xs, aey * rp as xs p^\Gamma q ; soit \Gamma  , ? auquel cas xs, aey --u` rp as xs p^\Gamma q. Orpuisque \Delta 
, ?, on a e'galement xs, aey --u` rp as xs p.\Delta q.Supposons J

pKaepsq i tpv1, s1qu et xs, aey --u` rp as xs ^ \Gamma . On a donc xs1, ae; x ThN~ v1y --u` ^\Gamma .Par conse'quent, avec (HI) il vient

xs1, ae; x ThN~ v1y --u` .\Delta , d'ou` : xs, aey --u` rp as xs . \Delta .

Cas des re`gles de congruence *g et *d : conse'quences directes de la Proposition 7.7.oe

Corollaire 7.7.1 (Cohe'rence de MLDL).Le syste`me MLDL est consistant :

&MLDL K
De'monstration :Contrapose'e du The'ore`me 7.1 ajoute'e au fait que pour tout environnement d'interpre'tation xs, aey, on a xs, aey * K. oe

8
Conclusion et perspectives

8:1 Bilan et contributions

Dans cette the`se, nous avons pre'sente' et e'tudie' le syste`me MLDL, un formalisme de'die' a`la preuve de programmes impe'ratifs e'crits dans le langage ML

imp. La the`se comporte deuxvolets : un volet syntaxique consacre' a` la pre'sentation du syste`me formel MLDL, et un volet

se'mantique consacre' a` la construction d'un mode`le de MLDL (lui-me^me base' sur un mode`lede'notationnel de ML

imp) afin de prouver la cohe'rence du formalisme.

Aspects syntaxiques Comme nous l'avons vu au Chapitre 4, MLDL est construit surune logique dynamique du second ordre dont les individus de base sont les valeurs de ML

imp,et dont le syste`me de'ductif combine des e'tapes de de'duction purement logiques et des e'tapes

d'e'valuation symbolique. Les principes fondamentaux de MLDL sont inspire's a` la fois de l'as-sistant a` la preuve PAF (logique du second ordre de'die'e a` la ve'rification d'un

*-calcul etcombine'e a` l'e'valuation symbolique, [Bar03b]) et du projet KeY (logique dynamique enrichie

avec un me'canisme d'updates et dont l'e'valuation symbolique est donne'e par une congru-ence, [BHS06]). De ce point de vue, nos contributions peuvent essentiellement se re'sumer en
deux points. Tout d'abord, le langage de programmation que nous e'tudions est un langageimpe'ratif d'ordre supe'rieur au sens ou` fonctions et re'fe'rences sont des valeurs et peuvent donc
e^tre passe'es en argument ou stocke'es dans la me'moire sans restriction particulie`re. Ensuite,la logique dynamique que nous avons de'finie pre'sente plusieurs particularite's :

Logique dynamique et second ordre Bien que la logique dynamique du second ordre neconstitue pas une nouveaute' en soi, le syste`me MLDL est a` notre connaissance le premier

formalisme de preuve de programme combinant la logique dynamique avec le secondordre qui lui ajoute un grand pouvoir d'expression.

Design de la boi^te La boi^te standard de la logique dynamique a du^ e^tre adapte'e a` MLimpou` tout programme est une expression. C'est pourquoi la boi^te modale de MLDL contient

un lieur dont le ro^le est de re'cupe'rer la valeur calcule'e par le programme.
Gestion des adresses La gestion des adresses me'moire (allocation, partage, etc) est re'al-ise'e en introduisant un jeu de noms d'adresses et le lieur associe', le

*-lieur, dont le ro^le

170 Chapitre 8 - Conclusion et perspectives

essentiel est de garantir et propager les conditions de frai^cheur des noms d'adresses.
Aspects se'mantiques Le volet se'mantique est consacre' a` la construction d'un mode`lede MLDL ainsi qu'aux preuves de corrections associe'es. Le but initial e'tait de construire

ce mode`le dans le cadre ge'ne'ral la se'mantique de Kripke pour la logique dynamique, ou`les relations d'accessibilite' sont habituellement indexe'es par la syntaxe des programmes (la
modalite' rps de'note une relation Rp). Cependant, nous avons vu que l'e'valuation symboliqueeffectuait un certain nombre d'identifications entre programmes qui n'e'taient pas faites par la
se'mantique ope'rationnelle de MLimp. C'est pourquoi nous avons construit le mode`le de MLDL a`partir d'un mode`le de'notationnel de ML

imp qui se charge de re'aliser toutes ces identifications.Le mode`le de ML
imp est construit par des techniques standard de re'solution d'e'quationsdans des domaines. Les principales difficulte's ont consiste' a` capturer la notion de bonne

formation des programmes (notamment des fonctions) vis-a`-vis de l'e'tat me'moire et la notiond'invariance vis-a`-vis de l'ordre d'allocation et des permutations d'adresses. Ceci a e'te' re'alise'
gra^ce a` la the'orie des actions de groupe sur les dcpo ainsi que la notion de domination quenous avons de'finies dans ce but. Finalement, les principales contributions du volet se'mantique
de cette the`se se re'sument essentiellement en deux points :
Action de groupes sur les dcpo et relation de domination Nous avons de'veloppe' lathe'orie des actions de groupe sur les dcpo et de'finit la relation de domination par un

ensemble d'adresses. Cela nous a permis de donner une se'mantique claire a` la notionsyntaxique de bonne formation des programmes et des stores. Il a ainsi e'te' possible de
traiter les invariants lie's a` l'allocation de nouvelles adresses me'moire.
Se'mantique de'notationnelle et se'mantique de Kripke L'association de la se'mantiquede'notationnelle (pour le langage de programmation) a` la se'mantique de Kripke (pour

le syste`me formel) a permis d'inte'grer les identifications faites par l'e'valuation symbol-ique aux relations d'accessibilite' du mode`le (de'sormais indexe'es par la de'notation des
programmes).

8:2 Perspectives

Bien entendu, une des premie`res ta^ches a` venir sera d'imple'menter un prototype base' surMLDL. Cela permettrait de tester notre syste`me sur des exemples plus conse'quents que ceux
pre'sente's au Chapitre 4. Le prototype serait constitue' entre autres d'un e'valuateur symboliqueguide' par l'utilisateur. Cet e'valuateur imple'menterait la congruence par une re'e'criture (non
de'cidable) que l'utilisateur pourrait contro^ler en indiquant le nombre d'e'tapes et l'orientation(re'duction - expansion). Cet outil interactif offrirait e'galement des tactiques automatiques
pour certains fragments du syste`me tels que la simplication et l'application des updates(comme dans KeY).

Sur le plan the'orique, nous avons travaille' sur un certain nombre de questions qui ne sontpas traite'es ici et qui, a` ce jour, sont toujours en suspens. Les dernie`res pages de ce manuscrit
sont consacre'es a` un rapide tour d'horizon des principales pistes que nous avons essaye'es etqu'il serait inte'ressant de poursuivre.

Liens avec la logique de se'paration Nous avons e'voque' (Section 6.4) les similitudesentre la relation de domination et la condition de monotonie exprime'e par la re`gle frame de la

logique de se'paration. Il serait inte'ressant de mieux comprendre ces liens et de les formaliser

8.2. Perspectives 171
clairement, voir par exemple s'il est possible de de'finir une se'mantique de la logique dese'paration en utilisant l'action des permutations et la domination. On voit par exemple que
l'ensemble des adresses modifiables par un programme modpssq, qu'on retrouve dans la re`gleframe, s'exprime naturellement avec la domination :

modpssq i c^

ssY"L

L

On remarque e'galement que le fait que deux stores ne partagent pas d'adresse s'exprimeaise'ment gra^ce a` la notion se'mantique de bonne formation. Les stores

s1 et s2 sont disjointssi et seulement si :

domps1q X domps2q i ?, s1 P WFpSq et s2 P WFpSq
En supposant donne'e une de'finition claire de szs1 (comple'ment de s1 dans s), on pourraitalors imaginer l'interpre'tation suivante de la conjonction de se'paration :

s --u` A b B ssi Ds1: s1 I^ s ^

s1 P WFpSq ^ szs1 P WFpSq ^
s1 --u` A ^ szs1 --u` B

Comple'tude de la se'mantique ope'rationnelle de MLimp La question de la com-ple'tude de la se'mantique ope'rationnelle de ML

imp vis-a`-vis de sa se'mantique de'notationnellen'est pas e'te' traite'e pour le moment. Il s'agirait de montrer le re'sultat suivant :

Pour tout programme p et tout store syntaxique s P S, si JpKaepsq , K alors il existe une'tat

v1 ffi s1 P Vs1 \Theta  S tel que p ffi s a,\Sigma  v1 ffi s1.

Dans ce but, nous pensons utiliser la technique des relations logiques de G. Winskel [Win93],de'finie pour montrer un re'sultat de comple'tude d'un language de programmation fonctionnel
et type'. L'ide'e ge'ne'rale est de contourner l'impossibilite' de faire une induction sur les termesen centrant la preuve sur la structure des types (gra^ce a` une relation d'approximation

A`o/entre les valeurs et les de'notations).

Pour la comple'tude de MLimp, il faudra e'tendre cette technique aux e'tats me'moires maissurtout l'adapter au cas non type'. Ceci pourrait e'ventuellement e^tre fait en utilisant la structure du mode`le et les foncteurs T, S et  : par construction, les dcpo V et S ont une structurehierarchique induite pas les indices qui permettent de passer a` la colimite ; ce sont ces indices
qui pourraient jouer le ro^le des types dans le mode`le.
Visibilite' des adresses me'moire Le syste`me MLDL ne tient pas compte des de'cla-rations locales de variables qui sont traite'es comme des de'clarations globales. A` travers les

re`gles de transformation de boi^tes (re`gle split notamment), le syste`me effectue en fait desouvertures de porte'e de la me^me manie`re qu'avec une ope'ration de lambda-lifting. Il s'ensuit
que n'importe quel programme peut modifier une adresse, bien que celle-ci ait e'te' alloue'elocalement. Par exemple, le programme

let next ilet

r i ref 0 in *_: r :i !r \Gamma  1 ; !rin next

pq

172 Chapitre 8 - Conclusion et perspectives

est traite' de la me^me manie`re que le programme

let r i ref 0 inlet next

i *_: r :i !r \Gamma  1 ; !r innext
pq

Il est clair que la re`gle split serait nettement plus complique'e si elle devait pre'server lalocalite' des variables. Le prix de la simplicite' de cette formulation est l'abandon de la distinction se'mantique entre variables locales et variables globales. Il serait ne'anmoins souhaitablede ge'rer les de'clarations de manie`re plus fine, afin de tenir compte des limitations de porte'e
et ve'rifier des proprie'te's telles que

rnext as ns l rnext as ms Ipn d^ mq
dont la validite' de'pend clairement de la localite' de l'adresse manipule'e par la fonction next.Pour cela, il faudra d'une part remanier le syste`me syntaxique et d'autre part comple'ter la

construction du mode`le. La premie`re ta^che parai^t la plus ardue et aucune piste viable n'ae'te' tente'e pour l'instant. Elle ne'cessite en tout cas de modifier le syste`me actuel de sorte
qu'aucune re`gle ne fasse d'ouverture de porte'e. Pour la seconde, une piste naturelle seraitd'ajouter au mode`le de ML

imp un dcpo L repre'sentant l'ensemble des adresses visibles par unprogramme donne'. On pourrait par exemple imaginer l'e'bauche suivante :

On pose : L i PfinpLq. On de'finit ensuite l'interpre'tation des programmes dans l'espacedes fonctions continues

pS \Theta  Lq N~ pV \Theta  S \Theta  LqK -- qui est clairement un dcpo --, dont lescas critiques seraient donne's par :

Jref pKaepps, Lqq i $'&'%

tp`, extps1q\Gamma t` ThN~ vu, L1 Y t`uqu si JpKaepps, Lqq i tpv, s1, L1qu

avec ` i freeps1q0
K sinon

Jp :i qKaepps, Lqq i $''''&''''%

tp0, s2 \Gamma t` ThN~ vu, L2 Y t`uqu si JpKaepps, Lqq i tp`, s1, L1qu,J

qKaepps1, L1qq i tpv, s2, L2qu
et ` P L1
K sinon

J!pKaepps, Lqq i $'&'%

tps1p`q, s1, L1qu si JpKaepps, Lqq i tp`, s1, L1qu

et ` P L1
K sinon

Jlet x i p in qKaepps, Lqq i $''''&''''%

tpv2, s2, L3qu si JpKaepps, Lqq i tpv1, s1, L1qu

et JqKae;xThN~v1pps1, L1qq i tpv2, s2, L2qu
avec L3 i pL2 \Delta  L1q \Gamma  L
K sinon

Intuitivement, le second parame`tre passe' a` la fonction JpKae indique les adresses auxquelles
p peut acce'der, d'ou` la condition ` P L1 dans les cas de l'affectation et de la de're'fe'renciation,au lieu de

` P Ls1. Par ailleurs, en plus de la valeur calcule'e et du nouvel e'tat me'moire, la

8.2. Perspectives 173
fonction JpKae renvoit aussi l'ensemble d'adresses visibles de l'exte'rieur. C'est pourquoi dansle cas du let-in, l'ensemble

L3 ne contient pas les adresses alloue'es par p.Enfin, le domaine de visibilite' devrait e'galement intervenir dans la se'mantique des formules. On pourrait par exemple re'duire le domaine des individus de base, qui ne contiendraitalors plus toutes les valeurs bien forme'es dans le store courant, mais seulement les valeurs
bien forme'es par rapport aux adresses visibles :

xs, L, aey --u` @x: A ssi pour toute v P VL, xs, L, ae; x ThN~ vy --u` A
xs, L, aey --u` rp as xs A ssi pour tout pv, s1, L1q P Vs1 \Theta  S \Theta  L,J

pKaepps, Lqq i tpv, s1, L1qu n~ xs1, L1, ae; x ThN~ vy --u` A

Typage certifie' Tous les langages fonctionnels de la famille ML (Caml, SML, Haskell)viennent avec un syste`me de typage statique qui permet de garantir un certain nombre d'invariants logiques au moment de l'exe'cution. Le typage statique permet de garantir par exemplequ'un programme de type boole'en, lorsqu'il termine, s'e'value ne'cessairement sur la valeur 0
ou sur la valeur 1. Dans la mesure ou` MLDL dispose de'ja` d'un langage expressif tre`s puissant,il est naturel de chercher a` exprimer les invariants du typage dans ce langage, le but e'tant
de de'finir une traduction (ici note'e ffi) des jugements de typage de MLimp dans les formulesde MLDL de telle sorte qu'a` tout jugement de'rivable corresponde une formule prouvable. Par
exemple : E

$ML p : o/ implique Effi $MLDL rp as xs o/ ffipxq

Une telle traduction, si elle existait, aurait un grand inte're^t a` la fois sur le plan the'oriqueet sur le plan pratique. Sur le plan the'orique, elle montrerait que le typage est en quelque

sorte de'ja` contenu dans le syste`me non type', ce qui nous dispenserait de modifier le syste`meexistant. Sur le plan pratique, une telle traduction nous permettrait d'automatiser la preuve
des invariants lie's au type des programmes en suivant l'algorithme d'infe'rence de type. Dansle cadre du fragment purement fonctionnel de ML-imp, la de'finition d'une telle traduction ne
pose pas de proble`me. (Elle se fait en introduisant des pre'dicats de relativisation dans l'espritde AF2 [Kri93], et c'est d'ailleurs sur cette ide'e que repose le typage fort de PAF !)

En pre'sence de re'fe'rences, la de'finition d'une telle traduction pose ne'anmoins de se'rieusesdifficulte's lie'es notamment aux proprie'te's d'invariance du typage des valeurs et du store.
Cette notion d'invariance du typage des valeurs n'a de sens que dans un cadre impe'ratifou` elle a une importance capitale puisqu'elle exprime le fait que les valeurs conservent leur
type tout au long de l'exe'cution (remarquons par ailleurs que cette notion d'invariance n'estpas incompatible avec des notions de sous-typage). On pourrait penser que cette proprie'te'
d'invariance du typage peut e^tre exprime'e a` l'aide de la boi^te ge'ne'rique de la manie`re suivante :

Effi $ o/ ffipvq implique Effi $ l o/ ffipvq
Pourtant, la boi^te ge'ne'rique peut e^tre instancie'e par n'importe quel programme, et rien negarantit par exemple qu'une adresse

` contenant un entier contienne encore un entier apre`sexe'cution d'un programme quelconque (par exemple

` :i p1, 1q). Une solution envisageableserait d'introduire une boi^te ge'ne'rique bien type'e, OE
A, correspondant a` l'exe'cution de n'im-porte quel programme bien type' -- e'tant entendu qu'un programme bien type' non seulement

renvoie une valeur du bon type, mais pre'serve les types des adresses alloue'es. Reste maintenant

174 Chapitre 8 - Conclusion et perspectives

a` de'terminer le statut de cette nouvelle construction : s'agit-il d'une primitive ou peut-on lade'finir dans la grammaire de MLDL (comme nous l'avons fait avec la boi^te ge'ne'rique) 1 ?

Pour re'pondre a` cette question, il convient d'abord d'e'tudier la se'mantique de la boi^tege'ne'rique bien type'e. Le but serait de construire un mode`le qui capture la notion de correction
induite par le typage statique de MLimp, a` savoir \Gamma  $ p : o/ , lorsque pour tout store s P S, si
s satisfait E (en un sens qui reste a` de'finir), alors non seulement la valeur retourne'e (si elleexiste) est bien de type

o/ , mais le store obtenu satisfait e'galement E, c'est-a`-dire respectele typage de
s (note' ici s D^ s1). Il s'agirait par exemple d'un mode`le de re'alisabilite' ou` lanotion de candidats de re'ductibilite' qui sert a` interpre'ter les types serait e'tendue et inclurait

les stores, par exemple :J

intK i tpp, sq P P \Theta  S -- @pv, s1q P Vs1 \Theta  S: JpKpsq i tpv, s1qu n~ v P Z ^ s D^ s1u

1. Toutes les tentatives que nous avons fait jusqu'a` pre'sent nous ame`nent a` penser que la boi^te ge'ne'riquebien type'e doit e^tre ajoute'e comme primitive.

Bibliographie
[AA96] J.R. Abrial and JR Abrial. The B-book, volume 146. Cambridge University Press,1996.
[Abe04] Andreas Abel. Termination checking with types. RAIRO - Theoretical Infor-matics and Applications, 38(4) :277-319, 2004. Special Issue : Fixed Points in

Computer Science (FICS'03).
[AC98] R.M. Amadio and P.L. Curien. Domains and lambda-calculi. Cambridge UnivPr, 1998.

[AL91] A. Asperti and G. Longo. Categories, types, and structures. MIT Pr., 1991.
[Bar98] H.P. Barendregt. The lambda calculus : its syntax and semantics. Elsevier, 1998.
[Bar03a] S. Baro. Conception et imple'mentation d'un syste`me d'aide a` la spe'cification eta` la preuve de programmes ML. PhD thesis, PPS, Universite' Paris VII - Denis

Diderot, Paris, France, 2003.
[Bar03b] S. Baro. Introduction to PAF, a proof assistant for ml programs verification. InTYPES, pages 51-65, 2003.

[BCES10] A. Bucciarelli, A. Carraro, T. Ehrhard, and A. Salibra. On linear informationsystems. Arxiv preprint arXiv :1003.5518, 2010.
[BDES11] A. Bouajjani, C. Dra*goi, C. Enea, and M. Sighireanu. On inter-procedural anal-ysis of programs with lists and data. In Proceedings of the 32nd ACM SIGPLAN

conference on Programming language design and implementation, pages 578-589.ACM, 2011.

[BdRdV01] P. Blackburn, M. de Rijke, and Y. de Venema. Modal logic. Cambridge UniversityPress, 2001.
[BFG\Gamma 04] G. Barthe, M.J. Frade, E. Gime'nez, L. Pinto, and T. Uustalu. Type-based ter-mination of recursive definitions. Mathematical Structures in Computer Science,

14(01) :97-141, 2004.
[BFMP11] F. Bobot, J.C. Fillia^tre, C. Marche', and A. Paskevich. Why3 : Shepherd yourherd of provers. Unpublished, 2011.

[BHS06] B. Beckert, R. Ha"hnle, and P. Schmitt, editors. Verification of Object-OrientedSoftware : The KeY Approach, volume 4334 of LNCS. Springer, 2006.
[BKdV03] M. Bezem, J.W. Klop, and R. de Vrijer. Term rewriting systems. CambridgeUniv Pr, 2003.

176 Bibliographie

[Bla04] F. Blanqui. A type-based termination criterion for dependently-typed higher-order rewrite systems. In Rewriting Techniques and Applications, pages 24-39.

Springer, 2004.
[BM10] Romain Bardou and Claude Marche'. Regions and permissions for verifying datainvariants. Technical Report RR-7412, INRIA, 2010.

[BRS\Gamma 00] M. Balser, W. Reif, G. Schellhorn, K. Stenzel, and A. Thums. Formal systemdevelopment with KIV. In Tom Maibaum, editor, Fundamental Approaches to

Software Engineering, volume 1783 of LNCS. Springer-Verlag, 2000.
[Car67] R. Carnap. Meaning and necessity. Univ. of Chicago Press, 1967.
[CH88] T. Coquand and G. Huet. The calculus of constructions. Information and Com-putation, 76(2/3), 1988.

[Cha10a] Arthur Chargue'raud. Characteristic Formulae for Mechanized Program Verifica-tion. PhD thesis, Universite' Paris-Diderot, 2010.
[Cha10b] Arthur Chargue'raud. Program verification through characteristic formulae. InPaul Hudak and Stephanie Weirich, editors, Proceeding of the 15th ACM SIGPLAN international conference on Functional programming (ICFP), pages 321-332. ACM, 2010.

[Che80] B. F. Chellas. Modal logic, an introduction. Cambridge University Press, 1980.
[Chu41] A. Church. The calculi of lambda-conversion. 1941.
[CMM\Gamma 09] A. Chlipala, G. Malecha, G. Morrisett, A. Shinnar, and R. Wisnesky. Effective in-teractive proofs for higher-order imperative programs. In ICFP '09 : Proceedings

of the 14th ACM SIGPLAN International Conference on Functional Program-ming, September 2009.

[Cou] P. Cousot. Methods and logics for proving programs. Handbook of theoreticalcomputer science, volume B, pages 843-993.
[Cou00] P. Cousot. Interpre'tation abstraite. Technique et science informatique, 19(1),2000.
[CP08] Arthur Chargue'raud and Franc,ois Pottier. Functional translation of a calculus ofcapabilities. In Proceedings of the 2008 ACM SIGPLAN International Conference

on Functional Programming (ICFP'08), pages 213-224, September 2008.
[CU08] J. Cheney and C. Urban. Nominal logic programming. ACM Transactions onProgramming Languages and Systems (TOPLAS), 30(5) :26, 2008.

[DHK03] G. Dowek, T. Hardin, and C. Kirchner. Theorem proving modulo. Journal ofAutomated Reasoning, 31(1) :33-72, 2003.
[Dij68] E.W. Dijkstra. Letters to the editor : go to statement considered harmful. Com-munications of the ACM, 11(3) :147-148, 1968.
[Dij75] E.W. Dijkstra. Guarded commands, nondeterminacy and formal derivation ofprograms. Communications of the ACM, 18(8) :453-457, 1975.
[DMB08] L. De Moura and N. Bjo/rner. Z3 : An efficient smt solver. Tools and Algorithmsfor the Construction and Analysis of Systems, pages 337-340, 2008.
[Eng] Pascal Engel. Modalite's, logique.
[ePM03] S. Baro et P. Manoury. Un syste`me x. raisonner formellement sur les programmesml. JFLA, 2003.

Bibliographie 177
[Fil99] J.-C. Fillia^tre. Preuve de programmes impe'ratifs en the'orie des types. The`se dedoctorat, Universite' Paris-Sud, July 1999.
[Fil03] J.-C. Fillia^tre. Why : a multi-language multi-prover verification tool. ResearchReport 1366, LRI, Universite' Paris Sud, March 2003.
[Flo67] R.W. Floyd. Assigning meanings to programs. Mathematical aspects of computerscience, 19(19-32) :1, 1967.
[GTL89] J.Y. Girard, P. Taylor, and Y. Lafont. Proofs and types, volume 7. Citeseer, 1989.
[HKT00] D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. Foundations of Computing.MIT Press, October 2000.

[Hoa69] C. A. R. Hoare. An axiomatic basis for computer programming. Communicationsof the ACM, 12(10) :576-580, 583, October 1969.
[HRS87] M. Heisel, W. Reif, and W. Stephan. Program verification by symbolic executionand induction. In K. Morik, editor, Proc. 11th German Workshop on Artifical

Intelligence, volume 152 of Informatik Fachberichte. Springer, 1987.
[Jon90] C.B. Jones. Systematic software development using VDM, volume 103. Citeseer,1990.

[Kes09] D. Kesner. A theory of explicit substitutions with safe and full composition.Logical Methods in Computer Science, 5(3-1) :1-29, 2009.
[KF09] J. Kanig and J.-C. Fillia^tre. Who : A Verifier for Effectful Higher-order Programs.In ACM SIGPLAN Workshop on ML, Edinburgh, Scotland, UK, August 2009.
[Kri59] S.A. Kripke. A completeness theorem in modal logic. The Journal of SymbolicLogic, 24(1) :1-14, 1959.
[Kri63] S. Kripke. Semantical considerations on modal logic. Acta philosophica fennica,16(1963) :83-94, 1963.
[Kri93] J. L. Krivine. Lambda-calculus, types and models. Masson, 1993.
[Lau08] O. Laurent. The'orie de la de'monstration. Cours, Master de Logique Mathe'ma-tique et Fondements de l'Informatique, Avril 2008.

[Lei04] D. Leivant. Partial correctness assertions provable in dynamic logics. In Founda-tions of Software Science and Computation Structures, pages 304-317. Springer,

2004.
[Lei08] D. Leivant. Reasoning in dynamic logic about program termination. In Pillarsof computer science, pages 441-456. Springer-Verlag, 2008.

[Lew60] C.I. Lewis. A survey of symbolic logic, volume 643. Dover Publications Inc., 1960.
[LT93] N.G. Leveson and C.S. Turner. An investigation of the therac-25 accidents. Com-puter, 26(7) :18-41, 1993.

[Mai09] S. Maingaud. Un mode`le de l'assistant a` la preuve PAF. In Studia InformaticaUniversalis, volume 7.2. JFLA09, Hermann, 2009.
[MBB\Gamma 10] S. Maingaud, R. Bubel, V. Balat, R. Ha"hnle, and A. Miquel. Specifying imper-ative ml-like programs using dynamic logic. volume 6528. FoVeOOS10, Springer

LNCS, 2010.
[ML84] P. Martin-Lof. Intuitionistic type theory. Bibliopolis, 1984.
[Mon96] J.F. Monin. Comprendre les me'thodes formelles. coll. cnet-enst, 1996.

178 Bibliographie

[ORS92] S. Owre, J. Rushby, and N. Shankar. Pvs : A prototype verification system.Automated Deduction--CADE-11, pages 748-752, 1992.
[P\Gamma 94] L.C. Paulson et al. The Isabelle reference manual. Citeseer, 1994.
[Pan92] C. Panaccio. La philosophie au xive sie`cle. Dialogue, 31(03) :363-376, 1992.
[Pau89] L.C. Paulson. The foundation of a generic theorem prover. Journal of AutomatedReasoning, 5(3) :363-397, 1989.

[Plo] GD Plotkin. Domains. pisa notes, 1983.
[Pot08] Franc,ois Pottier. Hiding local state in direct style : a higher-order anti-framerule. In Twenty-Third Annual IEEE Symposium on Logic In Computer Science

(LICS'08), pages 331-340, Pittsburgh, Pennsylvania, June 2008.
[Pra76] V.R. Pratt. Semantical consideration on floyd-hoare logic. In 17th annual sym-posium on foundations of computer science, pages 109-121. IEEE, 1976.

[Pra77] V. R. Pratt. Semantical considerations on Floyd-Hoare logic. In Proc. 17thAnnual IEEE Symposium on Foundation of Computer Science, Houston, TX,

USA, pages 109-121. IEEE Computer Society, 1977.
[Ray03] E.S. Raymond. This is jargon file, 2003.
[Rei95] W. Reif. The kiv-approach to software verification. KORSO : Methods, Lan-guages, and Tools for the Construction of Correct Software, pages 339-368, 1995.

[Rey02] J.C. Reynolds. Separation logic : A logic for shared mutable data structures.In Logic in Computer Science, 2002. Proceedings. 17th Annual IEEE Symposium

on, pages 55-74. IEEE, 2002.
[RGP08] Y. Re'gis-Gianas and F. Pottier. A hoare logic for call-by-value functional pro-grams. In Philippe Audebaud and Christine Paulin-Mohring, editors, Mathematics of Program Construction, 9th Intl. Conf., MPC 2008, Marseille, France,volume 5133 of LNCS, pages 305-335. Springer, 2008.

[Ru"m06] P. Ru"mmer. Sequential, parallel, and quantified updates of first-order structures.In Logic for Programming, Artificial Intelligence and Reasoning, volume 4246 of

LNCS, pages 422-436. Springer, 2006.
[Sco82] D. Scott. Domains for denotational semantics. Automata, languages and pro-gramming, pages 577-610, 1982.

[SS71] D.S. Scott and C. Strachey. Toward a mathematical semantics for computerlanguages. Oxford University Computing Laboratory, Programming Research

Group, 1971.
[Tria] J. Tricot. Aristote, Cate'gories : De l'interpre'tation,[traduction et notes]. Vrin.
[Trib] J. Tricot. Aristote, Organon III, Les Premiers analytiques,[traduction et notes].Paris, Vrin.

[Tur38] A.M. Turing. On computable numbers, with an application to the entschei-dungsproblem. a correction. Proceedings of the London Mathematical Society,

2(1) :544, 1938.
[Tur50] A.M. Turing. Computing machinery and intelligence. Mind, 59(236) :433-460,1950.

[Wad90] P. Wadler. Linear types can change the world. In IFIP TC, volume 2, pages347-359. Citeseer, 1990.

Bibliographie 179
[Win93] G. Winskel. The formal semantics of programming languages : an introduction.The MIT Press, 1993.
[YHB07] Nobuko Yoshida, Kohei Honda, and Martin Berger. Local State in Hoare Logicfor Imperative Higher-Order Functions. In Proc. Fossacs, volume 4423 of LNCS,

pages 361-377. Springer, 2007.

180 Bibliographie

Re'sume' Nous pre'sentons un syste`me formel de ve'rification de fiabilite' logicielle, MLDL,de'die' a` un

*-calcul non type' contenant des re'fe'rences d'ordre supe'rieur (MLimp) et dontl'e'valuation se fait en appel par valeur. MLDL adopte une approche de fiabilite' par certification

qui consiste a` prouver l'ade'quation entre un programme et sa spe'cification. Il est base' sur unelogique dynamique du second ordre dont le syste`me de'ductif combine des e'tapes de de'duction
purement logiques et des e'tapes d'e'valuation symboliques. Les modalite's spe'cifiques de MLDLsont de trois types : les boi^tes standard de la logique dynamique qui ont dues e^tre adapte'es
a` MLimp ou` tout programme est une expression, les updates qui permettent de repre'senter lesmodifications locales de la me'moire et un lieur particulier (le

*-lieur) qui prend en chargel'allocation de nouvelles adresses.

La the`se comporte deux volets : un volet syntaxique consacre' a` la pre'sentation de MLDL,et un volet se'mantique consacre' a` la construction d'un mode`le de MLDL afin de prouver la
cohe'rence du formalisme. Le mode`le de MLDL est construit a` partir d'un mode`le de'notationnelde ML

imp ou` deux programmes congruents (au sens de l'e'valuation symbolique) appartiennenta` une me^me classe d'e'quivalence. Ce mode`le de'notationnel est construit avec des techniques

standard de re'solution d'e'quations dans la cate'gorie des dcpo et la cate'gorie des cpo avecinjections-projections. Nous de'veloppons e'galement une the'orie des actions de groupe sur
les dcpo (applique'e en particulier au groupe des permutations d'adresses) ainsi qu'une no-tion de domination des programmes et des stores par un ensemble d'adresses. Ces nouveaux
outils nous permettent de traiter les questions de bonne formation et d'invariance lie'es a` lamanipulation des adresses me'moire.

Mots cle's : Preuve de programmes. Lambda-calcul avec re'fe'rences. Logique dynamique.Logique du second ordre. E'valuation symbolique. Actions de groupe sur les dcpo. Relation
de domination.
Abstract We present a formal system of software verification, MLDL, dedicated to anuntyped

*-calculus with higher-order references (MLimp) and call-by-value evaluation. MLDLfollows a certification approach which consists in proving the correspondence between a program and its specification. MLDL is based on a second-order dynamic logic which combinespurely logical deduction steps with symbolic evaluation. There are three types of modality in
MLDL : the box of dynamic logic is adapted to MLimp where each program is an expression,updates represents local modifications of the memory and a specific binder (the

*-binder)supports allocation of new memory cell.

The thesis consists of two parts : a syntactic part devoted to the presentation of MLDLand a semantic part devoted to the construction of a model of MLDL in order to prove the
consistency of the formalism. The model of MLDL is built on a denotational model of MLimpwhere congruent (through symbolic evaluation) programs belong to the same equivalence
class. This denotational model is built with standard techniques of solving equations in thecategory of dcpos and the category of cpos with injections- projections. We also develop
a theory of group action on the dcpo (especially applied to the group of permutations ofaddresses) and a notion of domination over programs and stores by a set of addresses. These
new tools allow to deal with issues of well-foundness and invariance associated with themanipulation of memory locations.

Key words Program certification. Lambda-calculus with references. Dynamic Logic. Sec-ond order Logic. Symbolic Evaluation. Group Actions on dcpo. Domination Relation.