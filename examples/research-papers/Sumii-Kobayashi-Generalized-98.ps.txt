

Electronic Notes in Theoretical Computer Science 16 No. 3 (1998)
URL: http://www.elsevier.nl/locate/entcs/volume16.html 23 pages

A Generalized Deadlock-Free Process Calculus

Eijiro Sumii and Naoki Kobayashi
Department of Information Science, Faculty of Science

University of Tokyo

Tokyo, Japan

Abstract
Deadlock is one of the most serious problems in concurrent programming. Recently,
Kobayashi proposed a static type system for a process calculus which ensures that
communication over some special channels never causes deadlock. However, since
the class of such channels was fixed ad hoc by the type system, the deadlock-free
fragment of the calculus was limited and the essence of the type system was not so
clear.

In this paper, we generalize his type system in order to extend the deadlockfree part of his calculus. For that purpose, we annotate each channel type with
an expression called a usage, which specifies how the channel can and must be
used. It is automatically checked by the type system that the usage does not
cause deadlock and that the channel is indeed used along the specification. As a
result, the deadlock-freedom property is treated more uniformly and guaranteed
more extensively.

1 Introduction
1.1 Background
Concurrent programming has been getting more and more important recently,
not only for popularity of parallel or distributed systems, but also for omnipresence of inherently concurrent applications. Many programming languages that support concurrency such as CML [14] and Pict [13] have been
developed, and many process calculi such as ss-calculus [9, 10] and HACL [4]
have been proposed as models of concurrent computation, where a group of
processes communicate with one another over communication channels. Those
calculi provided only a few primitive operations including dynamic creation
of communication channels, concurrent execution of processes, and reception/transmission of a channel from/to another channel. In spite of their
simplicity, those calculi were found to be expressive enough to provide other
higher-level constructs such as functions and concurrent objects [7, 12, 19].

cfl1998 Published by Elsevier Science B. V.

Sumii and Kobayashi
At the same time, those calculi are so low-level that they suffer from two
serious problems: non-determinism and deadlock. They complicate reasoning
about concurrent programs, cause unexpected results and obstruct compiletime optimization. However, there was no sufficient solution to those problems.

For example, suppose a programmer believes that a process P implements
a function f -- i.e., when P receives an argument x and a reply channel r,
it computes f (x) and sends it to r. How can we guarantee that? Early type
systems (before the work by Kobayashi, Pierce, and Turner [6]) only ensured
that communication over r does not cause arity mismatch [3, 9], or at best that
r is not used for input in P [11]. It was still possible that P returns no result at
all (which leads to deadlock) or returns different values simultaneously (which
leads to non-determinism).

Of course it is possible to provide functions as a primitive construct instead of implementing them as processes, but the problems are not limited
to functions, and it would be impossible to provide everything as a primitive
construct. Even if it is possible, the resultant calculus will be too complex.

1.2 Kobayashi's Type System for Deadlock-Freedom
As a solution to those problems, Kobayashi [5] recently proposed a type system that guarantees partial confluence and partial deadlock-freedom. He observed that most parts of concurrent programs are obviously confluent and/or
deadlock-free because they use communication channels only in limited manners. On the basis of that observation, he distinguished from other channels
a special class of channels called reliable channels, introduced constraints on
the order in which they are used, and proved that certain reliable channels do
not cause non-determinism and/or deadlock.

A reliable channel in his type system is either (1) a linear channel [6], which
is used just once each for input and output, (2) a replicated input channel,
which is used for (possibly recursive) definition of a parametric process, or
(3) a mutex channel, which is used like a binary semaphore. It was already
known that communication over linear channels and replicated input channels
is always confluent [6].

In addition, he annotated each channel type with a time tag, and controlled
by the type system the order in which a process uses reliable channels. A
type judgment of his type system has the form \Gamma  ; OE ` P , where \Gamma  is a type
environment and OE is a binary relation on time tags called a time tag ordering,
which expresses in what order P may use the reliable channels in \Gamma  and P .
He proved that P never reaches a deadlock if (1) all the channels in \Gamma  and P
are reliable and (2) the transitive closure of OE is a strict partial order.

For example, suppose two time tags s and t are attached to two linear
channels x and y, respectively. If a process P tries to receive a value from x
before it sends a value to y, the type judgment \Gamma 0 ; f(s; t)g ` P is valid while

2

Sumii and Kobayashi
\Gamma 0 ; f(t; s)g ` P is not. Conversely, if another process Q tries to receive a value
from y before it sends a value to x, the type judgment \Gamma 00 ; f(t; s)g ` Q is valid
while \Gamma 00 ; f(s; t)g ` Q is not. Thus, if we want to execute the two processes
in parallel as P j Q, we need a time tag ordering f(s; t); (t; s)g for a valid type
judgment \Gamma  ; f(s; t); (t; s)g ` P j Q, so we find that P and Q may deadlock on
x and y by the cycle s OE t OE s in the time tag ordering.

1.3 The Problem
Although Kobayashi's work was (to our knowledge) the first non-trivial result
on deadlock-freedom of a process calculus with first-class channels, 1 reliable
channels were limited only to three kinds in an ad hoc manner, so the deadlockfree fragment of the calculus was rather restricted. For example, a channel
used twice each for input and output was not regarded as reliable, so deadlockfreedom was not guaranteed for communication over such a channel. Our
purpose in this paper is to generalize the idea of reliable channels and to
extend the deadlock-free part of the calculus.

For that purpose, let us first consider one fundamental question: what is
deadlock? Basically, we take it as a deadlock that an input/output process
finds no corresponding output/input process and fails to perform communication. For example, suppose a process P is expected to send a value to a linear
channel c, and another process Q tries to receive the value from c. If P does
not actually send a value to c, then Q falls into deadlock. Conversely, if Q
is supposed to receive a value from c but actually does not, then P falls into
deadlock when it tries to send a value to c.

However, the problem is not so simple in fact. For instance, suppose a
function f is implemented as a process P that repeatedly receives an argument
and a reply channel. However many times P has been invoked, it still has to
wait for another call (which possibly never comes again), because it represents
the definition of f . We cannot take it as a deadlock.

Another example is a mutex channel [5], which is used like a binary
semaphore. An input from a mutex channel corresponds to a P-operation,
and an output to a mutex channel corresponds to a V-operation. The number
of output processes on a mutex channel represents the semaphore's current
value, so some output process should remain forever on each mutex channel.
We cannot take it as a deadlock either.

1.4 Our Approach and Result
Usage -- Capability and Obligation:
Those above examples indicate that whether or not a process is in deadlock
depends upon the programmer's intention. We need to express the intention

1 Yoshida [20] independently proposed a type system that can guarantee deadlock-freedom.
See the discussion in Section 7 for comparison.

3

Sumii and Kobayashi
somehow, so that we can check whether the program really agrees with it.
For that purpose, we annotate each channel type with an expression called a
usage, which specifies how the channel should be used. Our key idea is the
notion of capability and obligation.

Capability means that an input/output on a channel is guaranteed to succeed if it is tried (though it does not necessarily need to be tried). In other
words, (1) if a process has the capability to send a value to a channel, some
process will eventually receive the value from the channel, and (2) if a process has the capability to receive a value from a channel, some process will
eventually send the value to the channel. 2 Conversely, obligation means that
the input/output has to be performed (though it is not always guaranteed
to succeed). That is, if a process has the obligation to receive/send a value
from/to a channel, it must do so before it becomes irreducible.

For example, let us consider the usage of mutex channels. They are used
like binary semaphores. When a process has created a mutex channel m, the
process must send a value to m first. Then, any process can receive a value
from m. However, once a process has done so, the process must send some
value to m sometime. Thus, the usage of mutex channels can be expressed as
Oo j !(Ic : Oo), where I and O stand for input and output, c and o for capability
and obligation, j and : for concurrent execution and sequential execution, and
! for replication, respectively.

Another example is the usage of linear channels. They are used just once
each for input and output, both of which are capability and obligation. Therefore, their usage can be written as Ico j Oco.

We can also express a usage that was formerly regarded as `unreliable.' For
example, a usage written as Oo j Oo j Ic : Ic means that a channel must be used
twice for output concurrently, and can be used twice for input sequentially.

The idea of capability and obligation clarifies the notion of deadlock: a
process is in deadlock when it cannot be reduced any more while (1) an input/output with capability has not succeeded though it has been tried, or (2)
an input/output with obligation has not been performed.

In the rest of this paper, we target on an asynchronous variant of Milner's polyadic ss-calculus [9] whose syntax is shown in Figure 1. The annotation fU1; : : : ; Ung in the channel creation new x: [o/ ]=fU1; : : : ; Ung in P
means that the channel x should be used in accordance with one of the usages
U1; : : : ; Un. When there is only one possible usage (i.e., n = 1), we abbreviate
new x: [o/ ]=fU1g in P to new x: [o/ ]=U1 in P .

Usage Calculus:
The next question is: what kind of usage is reliable, i.e., do not cause deadlock?
Obviously, some usages are not reliable -- for example, consider a process
new x: [o/ ]=Ic in x?[v] : P , which creates a fresh channel x of a type [o/ ] with

2 provided that their reduction terminates

4

Sumii and Kobayashi
P (process) = new x: [o/1; : : : ; o/n]=fU1; : : : ; Umg in P (channel creation)

j x![x1; : : : ; xn] (asynchronous output)
j x?[x1; : : : ; xn] : P (input guard)
j P0 j P1 (parallel composition)
j def x[x1: o/1; : : : ; xn: o/n] = P0 in P1 (process definition)
j if x then P0 else P1 (conditional branch)

Fig. 1. Syntax of Processes
a usage Ic, and tries to receive a value from it. In spite of the capability of
input on x, the process cannot receive any value from it, since there is no
process that sends a value to it. This example suggests the following criterion
of reliability of a usage: if there is some capability of input (resp. output),
there must be a corresponding obligation of output (resp. input).

This condition must hold as well throughout reduction of processes. For
example, consider the following process.

new x: [o/ ]=(Ic j Ic j Oo) in (x![w] j x?[v1] : P1 j x?[v2] : P2)
It creates a fresh channel x with a usage Ic j Ic j Oo, sends a value to x once,
and tries to receive a value from x twice. After the value sent by the output
process x![w] is received by one of the input processes x?[v1] : P1 and x?[v2] : P2,
the other input process is left alone. Thus, it falls into deadlock.

In order to prevent such problems, we reduce a usage by canceling a concurrent pair of I/O, and check the reliability of each usage that appears in
the reduction. For example, the usage Ic j Ic j Oo in the example above can be
reduced to Ic, so we find it unreliable. We call this system the usage calculus.
By using the usage calculus, we can correctly judge whether a usage is reliable
or not.

Time Tag Ordering:
We have seen so far that (1) deadlock is a situation where a capability and/or
an obligation fails, and (2) with the usage calculus, every capability is guaranteed by a corresponding obligation. So the last question is: how can we
ensure that an obligation is fulfilled?

Suppose a process P has the obligation to send a value to a channel x.
If P immediately sends a value to x, there is no problem. But what if P
tries to receive a value from another channel y before sending a value to x,
as y?[v] : x![v] does? P may possibly never receive a value from y, and fail to
fulfill the obligation as a result. In order to avoid this, P needs the capability
to successfully receive a value from y. Then, the obligation will surely be
fulfilled, provided that reduction of the process terminates. In general, if a
process performs an input/output before it fulfills some obligation, the process

5

Sumii and Kobayashi
must have a capability for the input/output.

However, this scheme does not work if there is a cycle in the dependency
among capabilities and obligations. For example, consider a process x?[ ] : y![ ] j
y?[ ] : x![ ] where x and y are linear channels. The obligation of output on y
depends on the capability of input on x, which depends on the obligation of
output on x; it depends on the capability of input on y, which depends on
the obligation of output to y -- thus, none of them is actually guaranteed or
fulfilled.

This is why we attach a time tag to each I/O in a usage. We express the
dependency among capabilities and obligations as a binary relation on time
tags called a time tag ordering, just as Kobayashi [5] did. A relation s OE t
means that a process may make use of a capability tagged with s before it
fulfills an obligation tagged with t. A process is deadlock-free as long as the
time tag ordering has no cycle, i.e., its transitive closure is a strict partial
order. For example, suppose two time tags s and t are attached to two linear
channels x and y, respectively. Then, the process x?[ ] : y! j y?[ ] : x![ ] requires
a cyclic ordering s OE t OE s, because x?[ ] : y! requires s OE t and y?[ ] : x![ ]
requires t OE s. Thus, we find the possibility of deadlock on x and y.

The Result:
By combining the ideas above, we can guarantee that a process is deadlockfree if (1) the usage of each channel is reliable, where the notion of reliability is
generalized by the usage calculus, and (2) the time tag ordering has no cycle.

Note that our type system does not guarantee termination, which neither
the former type system [5] nor usual type systems for sequential languages do.
In our formulation, a process is never in deadlock as long as it is reducible.
Therefore, even a well-typed process may possibly fall into an `infinite loop'
and fail to fulfill an obligation as a result. We believe that to be a separate
issue, and do not take it as a deadlock.

1.5 Overview
The structure of the rest of this paper is as follows. Section 2 formally defines
the usage calculus and the reliability of usages. Section 3 describes details of
our type system. Section 4 discusses expressiveness of our calculus through
several examples. Section 5 shows soundness of our type system with respect
to the operational semantics of our calculus. Section 6 deals with issues on
type checking. Section 7 discusses the relationship between other work and
ours. Section 8 summarizes this paper, and mentions potential applications
of our type system.

Because of restriction of space, some details such as proofs of the theorems
are omitted in this paper. They are found in the full version [17] of this paper.

6

Sumii and Kobayashi
e (existence) = true (present)

j false (absent)
a (attribute) = (e0; e1) (capability and obligation)
U (usage) = 0 (inaction)

j Ota (asynchronous output)
j Ita : U (input guard)
j U0 j U1 (parallel composition)
j ! U (replication)

Fig. 2. Syntax of Usages
t (time tag) = t0 j t1 j t2 j : : : (outer tag)

j T0 j T1 j T2 j : : : (inner tag)
j ? (almighty tag)

Fig. 3. Time Tags
2 Usage Calculus

In this section, we describe the abstract syntax and the operational semantics
of the usage calculus, via which we formally define the reliability of usages.

2.1 Abstract Syntax
Usages are expressions that describe how communication channels should be
used. A usage consists of I's and O's annotated with attributes and time
tags (Figure 2). An attribute is a pair of a capability and an obligation: a
capability represents whether the input/output will succeed when it is tried;
an obligation represents whether the input/output has to be performed.

Time tags express the dependency among capabilities and obligations. The
set T of time tags is the disjoint sum of the set TO = ft0; t1; t2; : : :g of outer
tags, the set TI = fT0; T1; T2; : : :g of inner tags, and the singleton f?g of the
almighty tag (Figure 3). Outer tags are attached to outermost places of channel types, and inner tags are attached to other places of channel types. This
distinction is necessary in the typing rule for channel creations. 3 The almighty
tag is used for process definitions -- we do not need to manage an ordering
on the use of a channel introduced by a process definition, because it is syntactically ensured that output to such a channel never causes deadlock.

We write co, c, o and ; for (true; true), (true; false), (false; true) and

3 See the typing rule T-New in the next section for details.

7

Sumii and Kobayashi
U j V ,= V j U (CU-Comm)
U j (V j W ) ,= (U j V ) j W (CU-Assoc)

0 j U ,= U (CU-Zero)
U j ! U ,= ! U (CU-Spawn)
! U j ! U ,= ! U (CU-Fork)

Fig. 4. Structural Congruence on Usages

Osa j Itb : U ; U

(RU-Comm) U

; U 0

U j V ; U 0 j V

(RU-Par)

U ,= U 0 U 0 ; V 0 V 0 ,= V

U ; V

(RU-Cong)

Fig. 5. Reduction Relation on Usages
(false; false), respectively. We often write s, t, u, : : : for time tags in general, and S, T , : : : for inner tags. We sometimes omit 0 after an input guard.
We also omit attributes and/or time tags when they are not important. We
give higher precedence to the operators !, : and j in this order.

2.2 Operational Semantics
The operational semantics of the usage calculus is given in a standard manner
for process calculi, that is, via a structural congruence ,= and a reduction
relation ;.,

= is the smallest congruence relation on usages that satisfies the laws in
Figure 4. The first three laws mean that j is a commutative and associative
operator whose unit element is 0. The last two laws mean that a replication
! U is similar to an infinite parallel composition U j U j U j \Delta  \Delta  \Delta . 4

; is the smallest binary relation on usages that satisfies the rules in Figure
5. It means that we can reduce a usage by canceling a concurrent pair of I
and O.

2.3 Reliability of Usages
We define reliability of usages by means of the structural congruence and
the reduction relation. Intuitively, a usage is reliable when (1) if there is
a capability of input (resp. output), there is a corresponding obligation of

4 The law CU-Fork may seem unnecessary, but it is necessary for nested process definitions.
See the full version [17] of this paper for details.

8

Sumii and Kobayashi
output (resp. input), (2) if two I/O's are concurrent, they share a common
time tag, and (3) these conditions also hold after reduction. Formally, the set
of reliable usages R is the largest set S that satisfies the conditions below for
any U 2 S. Here, X and Y denote either I or O, U j \Delta  \Delta  \Delta  denotes U j V for some
V , and X : \Delta  \Delta  \Delta  denotes either X or X : V for some V .

(1a) 8s : 8e : 9t : 9f : (U ,= Is(true;e) : \Delta  \Delta  \Delta  j \Delta  \Delta  \Delta  ) U ,= Ot(f;true) j \Delta  \Delta  \Delta )

(1b) 8s : 8e : 9t : 9f : (U ,= Os(true;e) j \Delta  \Delta  \Delta  ) U ,= It(f;true) : \Delta  \Delta  \Delta  j \Delta  \Delta  \Delta )

(2) 8s : 8t : 8a : 8b : (U ,= Xsa : \Delta  \Delta  \Delta  j Ytb : \Delta  \Delta  \Delta  j \Delta  \Delta  \Delta  ) s = t)
(3) 8U 0 : (U ; U 0 ) U 0 2 S)

For example, the usage of linear channels Itco j Otco, which can be reduced
only to 0, is reliable. The usage of mutex channels Oto j !(Itc : Oto), which can
be reduced only to itself, is also reliable, because R is defined co-inductively
as the largest set that satisfies the conditions above. Another example of a
reliable usage is Oo j Oo j Ic : Ic. It is reduced to Oo j Ic, which is reduced to
0. A channel with a usage like this was formerly regarded as `unreliable' [5],
because it is neither a linear channel, a mutex channel, nor a replicated input
channel.

We also define the set of well-formed usages as the largest set S that
satisfies the conditions (2) and (3) for any U 2 S. We only consider wellformed usages throughout this paper. We also assume that any time tags
attached to different I/O's are distinct, unless they are explicitly required to
be equal by the conditions above (or by the typing rules described later).
Especially, any outer tags attached to different variables are distinct.

3 The Type System
In this section, we describe details of our type system and explain the techniques that we adopted.

3.1 Types
The abstract syntax of our calculus, which is an asynchronous variant of Milner's polyadic ss-calculus [9], and similar to the core language of Pict [13], has
already been shown in Figure 1.

However, we have not yet defined what a type o/ is: it is either a base type
or a channel type [o/1; : : : ; o/m]=U , where U is the usage of the channel (Figure
6). Here, we consider only bool as a base type, but we can treat other base
types similarly.

3.2 Type Judgments
A type judgment in our type system has the form \Gamma  ; OE ` P . \Gamma  is a type environment, which maps each free variable in P to a type, and OE is a time tag

9

Sumii and Kobayashi
o/ (type) = bool (boolean type)

j [o/1; : : : ; o/n]=U (channel type)

Fig. 6. Syntax of Types

tag (0) = ;
tag(Ota) = ftg
tag (Ita : U ) = ftg [ tag(U )
tag (U j V ) = tag (U ) [ tag (V )

tag (! U ) = tag (U )

tag (bool ) = ;
tag([~o/ ]=U ) = tag(U )

Fig. 7. Outer Tags in Usages and Types
ordering, which is a binary relation on time tags. Intuitively, \Gamma  represents capabilities and obligations of communication on the channels, and OE represents
in what order the communication may be performed. Since we do not give
any type to the process P itself, it is just well-typed under \Gamma  and OE.

We denote by tag(X) the set of time tags that appear in the outermost
places of X, where X is either a usage or a type. It is formally defined in
Figure 7. We often abbreviate X1; : : : ; Xn to ~X, as long as there is no danger
of confusion. We also abbreviate tag (X1) [ : : : [ tag (Xn) to tag ( ~X).

We assume that every outermost channel type has the form [~o/ ]=U such that
(1) U has no inner tag, (2) ~o/ has no outer tag, and (3) U has no almighty tag,
unless it is explicitly introduced by the typing rule for process definition. This
ensures that outer tags are attached only to outermost places while inner tags
are attached only to inner places, and that the almighty tag is used only for
process definition. In other words, we do not consider such types as [[ ]=Ot]=OT
or [bool ]=(O? j I?).

We also assume that each time tag ordering OE is well-formed, i.e., satisfies the following conditions, which mean that OE has no cycle except for the
almighty tag.

(i) 8(s; t) 2 OE : (s OE ? ^ t OE ? ^ ? OE s ^ ? OE t)
(ii) f(s; t) 2 OE such that s 6= ? ^ t 6= ?g+ is a strict partial order

3.3 Delaying an Obligation by a Capability
When a process has an obligation on a channel, it may immediately fulfill the
obligation, but it may also use a capability on another channel before that.
For example, suppose a process P has the obligation to send a value to a

10

Sumii and Kobayashi
t OE 0

f = true ) t OE s

t OE Os(e;f)

f = true ) t OE s

t OE Is(e;f) : U

t OE U
t OE ! U

t OE U t OE V

t OE U j V

t OE bool

t OE U
t OE [~o/ ]=U

t OE o/1 : : : t OE o/n

t OE x1: o/1; : : : ; xn: o/n
Fig. 8. Extension of OE
channel c, and tries to perform input/output on another channel d.

ffl If P is an input process d?[\Delta  \Delta  \Delta ] : c![\Delta  \Delta  \Delta ], it needs the capability to successfully

receive a value from d, and the time tag attached to d must be `less' than
the time tag attached to c, so that some process will eventually performs
output on d.

ffl If P is an output process d![c], it needs the capability to successfully send

a value to d, and the time tag attached to d must be `less' than the time
tag attached to c, so that some process will eventually performs input on d
(and takes over the obligation to send a value to c).

In order to express such conditions concisely, we define relations between
a time tag and a usage, between a time tag and a type, between a time tag
and a type environment by the rules in Figure 8. Intuitively, a relation t OE X
means that a capability tagged with t may be used before the obligations in X
are fulfilled, where X is either a usage, a type, or a type environment. Then,
we define relations between an I/O and a type environment, which means that
the action expressed by the I/O may precede the actions expressed by the type
environment, as follows.

It(e;f) OE \Gamma  () (ob(\Gamma ) ) (e = true ^ t OE \Gamma ))
Ot(e;f) OE \Gamma  () (ob(\Gamma ) ) (e = true ^ t OE \Gamma ))
Here, ob(\Gamma ) means that \Gamma  has some obligation. It is formally defined as follows.

ob(U ) () (U ,= Os(e;true) j V ) . (U ,= It(f;true) : U 0 j W )

ob(o/ ) () o/ = [~oe]=U ^ ob(U )
ob(x1: o/1; : : : ; xn: o/n) () ob(o/1) . : : : . ob(o/n)
We write noob(\Gamma ) for : ob(\Gamma ). It means that \Gamma  has no obligation.

3.4 Subtyping on Time Tags
There is another technical problem when a channel is passed through another
channel by such processes as new c: [~o/ ]=U in (x![c] j x?[d] : P j \Delta  \Delta  \Delta ). If some
ordering is required for the received channel d, the same ordering is required
for the sent channel c. However, if we naively assigned the same time tag to c

11

Sumii and Kobayashi
and d, too many processes that are actually deadlock-free would be ill-typed,
and the expressive power of our calculus would be seriously damaged.

In order to avoid that, we introduce a kind of subtyping on time tags just
as Kobayashi did in the former work [5]. Recall that an ordering u OE v means
that a capability tagged with u may be used before an obligation tagged with
v is fulfilled. If we want to use a channel of the type [ ]=Ot where a channel
of the type [ ]=Os is expected, t must have every ordering that s has. We can
express that by a condition [t=s]OE ` OE.

In general, a channel of a type [~o/ ]=U can be used safely as a channel of
another type [~o/ ]=V if there exists some substitution ` such that dom(`) =
tag(V ), `(V ) = U , and `(OE) ` OE. Therefore, we write OE ` ~o/ ^ ~oe when
`(OE) ` OE and o/i = `(oei) for each i and some substitution ` with dom(`) =
tag(~oe). Intuitively, it means that we can safely use channels of the types ~o/ as
channels of the types ~oe under the time tag ordering OE.

3.5 Typing Rules
Now we are ready to describe the typing rules. They are essentially similar to
the typing rules in the former work [5], but their essence was clarified thanks
to the usage calculus. Especially, the ad hoc rule for input on a mutex channel
was unified into a single rule for input on a channel in general. As a result,
our typing rules are syntax-directed besides the following rule for congruent
usages.

\Gamma ; x: [~o/ ]=U ; OE ` P U ,= U 0

\Gamma ; x: [~o/ ]=U 0 ; OE ` P

(T-Cong)

Conditional Branch:
In a conditional branch if x then P else Q, only one of P and Q is executed
according to the value of x, whose type must be bool . So the two processes
must be well-typed under the same type environment with the same time tag
ordering.

\Gamma  ; OE ` P \Gamma  ; OE ` Q
\Gamma  + x: bool ; OE ` if x then P else Q

(T-If)

Parallel Composition:
In a parallel composition P j Q, the two processes P and Q are executed in
parallel. If P and Q are respectively well-typed under \Gamma  and \Delta  with a common
time tag ordering OE, the process P j Q is well-typed under the `sum' of the

12

Sumii and Kobayashi
two type environments with the same time tag ordering.

\Gamma  ; OE ` P \Delta  ; OE ` Q

\Gamma  + \Delta  ; OE ` P j Q

(T-Par)

Here, the sum \Gamma  + \Delta  of two type environments \Gamma  and \Delta  is defined below.
Intuitively, it expresses the usages of channels that can be used according to
\Gamma  in one place and according to \Delta  in another place in parallel. It is undefined
in the cases not defined below.

[~o/ ]=U + [~o/ ]=V = [~o/ ]=(U j V )

bool + bool = bool

(\Gamma  + \Delta )(x) =

8???!

???:

\Gamma (x) + \Delta (x) (if x 2 dom(\Gamma ) ^ x 2 dom(\Delta ))
\Gamma (x) (if x 2 dom(\Gamma ) ^ x =2 dom(\Delta ))
\Delta (x) (if x =2 dom(\Gamma ) ^ x 2 dom(\Delta ))

Asynchronous Output:
In an asynchronous output x![~y], the channel x is used to send the values ~y. So
x must have a type of the form [~o/ ]=(Ota j \Delta  \Delta  \Delta ), and ~y must have some subtypes

~oe of ~o/ ( 1fl, 4fl). 5 If ~y have any obligation in ~oe, the obligation may be delayed
by the output ( 2fl). No obligation can be left after the output ( 3fl).

OE ` ~oe ^ ~o/ 1fl

Ota OE ~y: ~oe 2fl

noob(\Gamma ) 3fl

\Gamma  + x: [~o/ ]=Ota + ~y: ~oe ; OE ` x![~y] 4fl

(T-Out)

Input Guard:
An input guard x?[~y] : P receives values from a channel x, binds them to

~y, and then executes the process P . So x must have a type of the form
[~o/ ]=(Ita : U j \Delta  \Delta  \Delta ) ( 5fl), and P must be well-typed on the assumption that ~y have
some supertypes ~oe of ~o/ ( 1fl, 2fl).

If P has any obligation in \Gamma , the obligation may be delayed by the input
( 3fl). We can remove the outer tags in oe from OE ( 5fl), because they are local

5 By ~y: ~oe, we denote y

1: oe1 + : : : + yn: oen. It is possible in T-Out that yi = yj for some

i 6= j.

13

Sumii and Kobayashi
to P . 6

\Gamma  + x: [~o/ ]=U; ~y: ~oe ; OE ` P 1fl

OE ` ~o/ ^ ~oe 2fl

Ita OE \Gamma  3fl
tag (~o/ ) 6OE6O/ tag (~oe) 4fl

\Gamma  + x: [~o/ ]=(Ita : U ) ; OE n tag(~oe) ` x?[~y] : P 5fl

(T-In)

Here, the subtraction OE n S of a set of time tags S from a time tag ordering
OE is defined as

OE n S = f(s; t) such that s; t =2 S ^ s OE tg
S0 6OE6O/ S1 means that there is no ordering between any time tags s 2 S0 and
t 2 S1 except for the almighty tag.

S0 6OE6O/ S1 () 8s 2 S0 : 8t 2 S1 : (s 6= ? ^ t 6= ? ) : s OE t ^ : t OE s)

Process Definition:
A process definition def x[~y: ~o/ ] = P in Q creates a fresh channel x, spawns
an infinite parallel composition x?[~y] : P j x?[~y] : P j x?[~y] : P j \Delta  \Delta  \Delta , and then
executes the process Q. Since P and Q can successfully send values to x as
many times as they like (possibly never), \Gamma  cannot have any obligation ( 3fl)
and must be replicated ( 1fl, 6fl).

P must be well-typed on the assumption that x has the type [~o/ ]= ! O?c and
~y have some supertypes ~oe of ~o/ ( 1fl, 2fl). We can remove the outer tags in oe
from OE ( 4fl, 6fl), because they are local to P .

Q must be well-typed on the assumption that x has the type [~o/ ]= ! O?c
( 4fl). 7

! \Gamma ; x: [~o/ ]= ! O?c; ~y: ~oe ; OE ` P 1fl

OE ` ~o/ ^ ~oe 2fl

noob(\Gamma ) 3fl
\Delta ; x: [~o/ ]= ! O?c ; OE n tag (~oe) ` Q 4fl

tag (~o/ ) 6OE6O/ tag (~oe) 5fl

! \Gamma  + \Delta  ; OE n tag (~oe) ` def x[~y: ~o/ ] = P in Q 6fl

(T-Def)

6 The fourth condition ( 4fl) is necessary for a certain technical reason. See the full version
[17] of this paper for details.
7 The fifth condition ( 5fl) is necessary for the same reason as the fourth condition ( 4fl) in

T-In.

14

Sumii and Kobayashi
Here, the replication ! \Gamma  of a type environment \Gamma  is defined as follows.

!([~o/ ]=U ) = [~o/ ]= ! U

! bool = bool

(! \Gamma )(x) =

8!

:

!(\Gamma (x)) (if x 2 dom(\Gamma ))

undefined (if x =2 dom(\Gamma ))

Channel Creation:
A channel creation new x: [~o/ ]=f\Delta  \Delta  \Delta  ; U; \Delta  \Delta  \Delta g in P creates a fresh channel x of
the type [~o/ ]=U with some usage U 2 f\Delta  \Delta  \Delta  ; U; \Delta  \Delta  \Delta g, and then executes the
process P . So the usage U must be reliable ( 1fl), and the process P must be
well-typed on the assumption that x is a channel of the type [~o/ ]=U ( 2fl).

If some of the outer tags in U have no ordering with inner tags ( 3fl), they
can be removed from OE ( 4fl), because they are local to P , i.e., no other process
uses x so as to require any more orderings on them. This is essentially the
same condition as the former work [5] adopted for channel creation. Although
it may seem rather an ad hoc trick, it enables us to treat many recursive
processes (such as the process Fib10 described later) as deadlock-free.

U 2 R 1fl
\Gamma ; x: [~o/ ]=U ; OE ` P 2fl
TI 6OE6O/ S ` tag(U ) 3fl

\Gamma  ; OE \Gamma  S ` new x: [~o/ ]=f\Delta  \Delta  \Delta  ; U; \Delta  \Delta  \Delta g in P 4fl

(T-New)

Here, the subtraction OE \Gamma S of a set of time tags S from a time tag ordering
OE is defined as

OE \Gamma  S = f(s; t) such that s; t =2 S and

9n * 0 : 9u1; : : : ; un 2 S : s OE u1 OE : : : OE un OE tg
Note that it cannot be replaced with OE n S. For instance, consider a process

y?[ ] : x![ ] j new c: [ ]=(Iuco j Ouco) in (x?[ ] : c![ ] j c?[ ] : y![ ])
under a type environment x: [ ]=(IscojOsco); y: [ ]=(ItcojOtco). Obviously, the process
is in deadlock. As for the time tag ordering, y?[ ] : x![ ] requires t OE s, while
x?[ ]:c![ ]jc?[ ]:y![ ] requires s OE u and u OE t. If we let OE and S be f(s; u); (u; t)g
and fug respectively, OE\Gamma S is f(s; t)g while OEnS is fg. However, the subprocess

new c: [ ]=(Iuco j Ouco) in (x?[ ] : c![ ] j c?[ ] : y![ ])
should require s OE t instead of `nothing,' so that we can correctly detect a
cycle s OE t OE s.

In the third condition ( 3fl), the restriction TI 6OE6O/ S is necessary. This
is the reason why we distinguish inner tags from outer tags. Consider the

15

Sumii and Kobayashi
process below for instance, where c and d are linear channels of the types
[[ ]=ITcco ]=(Otcco j Itcco) and [[ ]=ITdco ]=(Otdco j Itdco), respectively.

(new x: [ ]=(Otxco j Itxco) in (c![x] j d?[y0] : x?[ ] : y0![ ]))j

(new y: [ ]=(Otyco j Ityco) in (d![y] j c?[x0] : y?[ ] : x0![ ]))

It obviously reaches a deadlock after reduction. However, but for the restriction TI 6OE6O/S, the whole process would be well-typed under a time tag ordering
f(tc; Tc); (td; Tc); (tc; Td); (td; Td)g, because the subprocess c![x]jd?[y0]:x?[ ]:y0![ ]
is well-typed under a time tag ordering f(tc; tx); (td; tx); (tx; Td)g and so is
d![y] j c?[x0] : y?[ ] : x0![ ] under f(td; ty); (tc; ty); (ty; Tc)g. With the restriction
TI 6OE6O/ S, the orderings cannot be removed in T-New and must be shared in
T-Par. Therefore, ty OE tx is required by c![x] with ty OE Tc, and tx OE ty is
required by d![y] with tx OE Td. Hence a cycle tx OE ty OE tx in the time tag
ordering, which tells us the possibility of deadlock on the channels x and y.

4 Examples
In this section, we discuss the expressive power of our calculus through several
examples.

4.1 `Good' Examples
Although there are some trivial technical differences, our calculus essentially
subsumes the deadlock-free part of Kobayashi's calculus, where functions and
typical concurrent objects can be encoded [5]. In addition, we here give several
examples that we can now treat as deadlock-free.

Counting Semaphore:
Just as binary semaphores are implemented as mutex channels, general counting semaphores can be implemented in our calculus. For example, a ternary
semaphore can be implemented as a channel with a usage Oo j Oo j !(Ic : Oo).

Race:
Suppose there are two servers waiting for requests on two channels c and d,
respectively. A client may want to send a request to both servers and use the
result returned first. Our calculus can express such behavior as

new r: [o/ ]=(Oo j Oo j Ic) in (c![arg; r] j d![arg; r] j r?[res] : \Delta  \Delta  \Delta )

16

Sumii and Kobayashi
Fibonacci:
Consider the following process Fib10 . We assume here that we have a base
type int and primitive operators !, + and \Gamma .

def fib[n: int ; r: [int ]=OTo ] =

if n ! 2

then r![1]
else new c: [int ]=(Oto j Oto j Itc : Itc) in

(fib![n \Gamma  2; c] j fib![n \Gamma  1; c] j c?[x] : c?[y] : r![x + y])
in fib![10; ans]

The parametric process fib receives an integer n with a channel r, computes
the n-th Fibonacci number recursively, and sends it to r. Thus, the whole
process computes the 10th Fibonacci number and sends it to ans.

We can derive a type judgment ans: [int ]=Oso ; ;`Fib10 by using the typing
rules in the previous section. It indicates that this program is deadlock-free,
i.e., the process Fib10 never fails to return an integer to the channel ans when
it is completely reduced. The former type system [5] was not able to guarantee
that, because it would have regarded the channel c as unreliable.

4.2 `Bad' Examples
Since it is essentially undecidable whether a process really reaches a deadlock,
there are certainly some processes that are ill-typed in our type system even
though they are actually deadlock-free.

For instance, when x and y are linear channels and b is a boolean value,
the process

x![ ] j y![ ] j if b then x?[ ] : y?[ ] : 0 else y?[ ] : x?[ ] : 0
cannot be well-typed, because the `then' part and the `else' part of the condition branch require contradictory orderings. 8

Another example is the process below, where x and y are linear channels
of the types [ ]=(Otxco j Itxco) and [ ]=(Otyco j Ityco), and c is a channel of the type
[[ ]=ITco]=(Os1co j Is1co : (Os2co j Is2co)), respectively.

x![ ] j y![ ] j c![x] j c?[x

0] : (c![y] j c?[y0] : (x0?[ ] : y0?[ ] : 0))

8 0 denotes an inactive process new d: [ ]=O

; in d![ ]. Note that this is not a deadlock,because the output to d has no capability.

17

Sumii and Kobayashi
It successfully reduces to 0 as follows.

x![ ] j y![ ] j c![x] j c?[x0] : (c![y] j c?[y0] : (x0?[ ] : y0?[ ] : 0))
c\Gamma \Gamma ! x![ ] j y![ ] j c![y] j c?[y0] : (x?[ ] : y0?[ ] : 0)

c\Gamma \Gamma ! x![ ] j y![ ] j x?[ ] : y?[ ] : 0
x\Gamma \Gamma \Gamma ! y![ ] j y?[ ] : 0

y\Gamma \Gamma \Gamma ! 0

However, the process is ill-typed in our type system. Suppose the channels x0
and y0 are given the types [ ]=It

0x

co and [ ]=I

t0y
co, respectively. Then, the subprocess

x0?[ ] : y0?[ ] : 0 requires an ordering t0x OE t0y. Since x0 and y0 are received from
c, Tc must have every ordering that t0x and t0y have. Thus, a cycle Tc OE Tc is
detected.

In the latter case, it is easy for a programmer to rewrite the process as

x![ ] j y![ ] j c1![x] j c1?[x

0] : (c2![y] j c2?[y0] : (x0?[ ] : y0?[ ] : 0))

so that the type system can correctly judge it to be deadlock-free. Furthermore, in both cases, the type system may just warn the programmer of the
possibility of deadlock, instead of rejecting the whole processes as errors. By
looking at the time tag ordering, our type system can tell where a deadlock
may occur and where it may not. For example, consider a process

x?[ ] : y![ ] j y?[ ] : x![ ] j c![ ] j c?[ ] : 0
where c, x and y are linear channels with time tags tc, tx and ty, respectively.
It requires a time tag ordering f(tx; ty); (ty; tx)g. While we find the possibility
of deadlock on x and y by the cycle tx OE ty OE tx, we also find that c will cause
no deadlock because there is no cycle on tc.

5 Type Soundness
In this section, we show soundness of our type system with respect to the
operational semantics of our calculus.

5.1 Operational Semantics
The operational semantics is defined via a structural congruence j and a
reduction relation !. Both of them are standard, except that each reduction
is annotated with a label, which represents how the reduction occurred. A
label l is either (1) a variable x, which represents a communication on the
channel, (2) the empty label ", which represents an internal transition, or (3)
an equation x[~y] = P , which represents a call to the process definition (Figure
9). We write P ! Q when P "\Gamma \Gamma ! Q or P x\Gamma \Gamma \Gamma ! Q for some x, and P 6!
when such Q does not exist.

18

Sumii and Kobayashi
l (label) = x (communication on channel)

j " (internal transition)
j x[~y] = P (call to process definition)

Fig. 9. Syntax of Labels

\Gamma  "\Gamma \Gamma ! \Gamma 

U ; V
\Gamma ; x: [~o/ ]=U x\Gamma \Gamma \Gamma ! \Gamma ; x: [~o/ ]=V
Fig. 10. Reduction Relation on Type Environments
We define a normal form of a process as

new x1: [~o/1]=f ~U1g in \Delta  \Delta  \Delta  new xm: [~o/m]=f ~Umg in

def y1[~z1: ~oe1] = Q1 in \Delta  \Delta  \Delta  def yn[~zn: ~oen] = Qn in (R1 j \Delta  \Delta  \Delta  j Rn)
where each Ri is either an input guard, an asynchronous output, or a conditional branch. Every process is structurally congruent to some normal form.

Since our type environment represents how the channels should be used
for the rest of the computation, it changes by reduction depending on how
the reduction occurred. Therefore, we also define a reduction relation on type
environments (Figure 10).

5.2 The Deadlock-Freedom Theorem
As usual, type soundness is guaranteed by two properties: freedom from immediate errors (i.e., deadlock) and subject reduction. 9 By combining them,
we obtain the deadlock-freedom theorem below, which guarantees that our
calculus is really deadlock-free. It intuitively says: when a well-typed process
is completely reduced, every input/output with capability has succeeded if it
is tried, and every input/output with obligation has been performed, unless
the process is blocked on an unreliable channel.

Theorem (Deadlock-Freedom)

Suppose that \Gamma 0 ; OE ` P0 and P0 l

1\Gamma \Gamma \Gamma ! P1 l2\Gamma \Gamma \Gamma ! : : : lr\Gamma \Gamma \Gamma ! P

r 6!. Suppose

also that Pr is congruent to the following normal form.

new x1: [~o/1]=f ~U1g in \Delta  \Delta  \Delta  new xn: [~o/n]=f ~Ung in

def y1[~z1: ~oe1] = Q1 in \Delta  \Delta  \Delta  def yd[~zd: ~oed] = Qd in (R1 j \Delta  \Delta  \Delta  j Rp)

9 See the full version [17] of this paper for their statements and proofs.

19

Sumii and Kobayashi
Then, \Gamma 0 l

1\Gamma \Gamma \Gamma ! \Gamma 1 l2\Gamma \Gamma \Gamma ! : : : lr\Gamma \Gamma \Gamma ! \Gamma 

r for some \Gamma 1; : : : ; \Gamma r and \Gamma 

0 ; OE0 `

R1 j \Delta  \Delta  \Delta  j Rp for some conservative extension OE0 of OE, where

\Gamma 

0 = \Gamma r; x1: [~o/1]=U1i

1; \Delta  \Delta  \Delta  ; xn: [~o/n]=Unin; y1: [~oe1]= ! O

?
c; \Delta  \Delta  \Delta  ; yd: [~oed]= ! O

?
c

for some i1; : : : ; in. Furthermore, all the following statements hold

(i) If \Gamma 0(c) ,= [ ~ae]=(Ot(true;e) j V ), then Ri 6= c![~v] for any i.
(ii) If \Gamma 0(c) ,= [ ~ae]=(It(true;e) : V j V 0), then Ri 6= c?[~v] : R0i for any i.
(iii) If \Gamma 0(c) ,= [ ~ae]=(Ot(e;true) j V ), then Ri = c![~v] for some i.

(iv) If \Gamma 0(c) ,= [ ~ae]=(It(e;true) : V j V 0), then Ri = c?[~v] : R0i for some i.
unless some Ri has the form c?[~v] : R

0i or c![~v] with \Gamma r(c) = [ ~ae]=U and U =2 R,

or the form if b then R0i else R00i with \Gamma r(b) = bool , b 6= true and b 6= false.

6 Type Checking
Type checking in our type system is essentially similar to that in the former
work [5]. It infers a time tag ordering automatically, so programmers do not
need to specify it explicitly. Our type checking algorithm is described in the
full version [17] of this paper. It takes exponential time in the worst case, but
it seems to work well in most cases. We have implemented in SML/NJ [1]
a prototype type checker based on the algorithm. It is available from http:
//www.is.s.u-tokyo.ac.jp/~sumii/pub/.

7 Related Work
The present work is an extension of Kobayashi's type system for deadlockfreedom [5]. In his type system, deadlock-freedom was guaranteed only for
linear, replicated input, and mutex channels. He used the notion of capability
and obligation only in the informal explanation of the intuition behind the
type system. This paper first formalized and exploited that notion, in order
to generalize and clarify the type system. Most of the extensions that he
mentioned are also applicable to our type system.

Pierce and Sangiorgi [11] classified communication channels by their usages
into those for output only, those for input only, and those for both input and
output. Kobayashi, Pierce, and Turner [6] proposed a type system for linear
channels, and proved that communication over a linear channel never causes
non-determinism. Those type systems are also ancestors of ours.

Boudol [2] used Hennessy-Milner logic with recursion [8] to express resources offered by processes. He conjectured that his type system guarantees
a kind of deadlock-freedom, by which he meant that every output message is
eventually received by some input process. However, his type system fails to
ensure that an input process does not deadlock.

Yoshida [20] introduced graph types, which are graphs of atomic actions, to

20

Sumii and Kobayashi
describe dynamic behavior of processes. Roughly speaking, her type system
and ours are similar in that a node of a graph type corresponds to an I/O with
both capability and obligation, and that an edge of a graph type corresponds
to an ordering between two time tags. However, a graph type cannot represent
`capability without obligation' or `obligation without capability,' so it would
be too restrictive for concurrent programming in practice.

8 Conclusion and Future Work
We have generalized Kobayashi's type system for deadlock-freedom [5] to extend the deadlock-free part of the calculus, and to clarify the essence of the
type system. The main technical contribution of this paper is (1) introduction
of the usage calculus to control how each channel may/must be used, and (2)
reformulation of the type system based on the usage calculus.

We expect that our type system is applicable to concurrent programming
languages that support first-class communication channels, such as CML [14],
HACL [4] and Pict [13]. A programmer has to annotate every channel with
its usage, but he/she can omit time tags and their ordering, because our
type checking algorithm automatically infers them. Although our type system sometimes detects a possibility of deadlock for an actually deadlock-free
program, a type checker can warn of the channels that may cause deadlock
(instead of rejecting the whole program as an error) by looking at the time tag
ordering. It can also intuitively explain why a program may deadlock without
referring to time tags and their ordering, so that a programmer does not need
to understand them.

Our type system is useful not only for preventing human errors but also for
performing compile-time optimization. Shimizu and Kobayashi [16] are now
working on that topic.

Our calculus may also be useful for specification and verification of concurrent systems, because it contains more information than ordinary process
calculi about how processes communicate over communication channels.

We believe that our idea is applicable to concurrent logic programming
languages [15] as well. We expect that we can detect a possibility of deadlock
in a well-moded [18] concurrent logic program, by encoding it into an extension
of our calculus with replicated output processes -- by translating each shared
logical variable into a channel with a usage ! Oo j ! Ic or Oco j Ico, instantiation of
the variable into a replicated output operation, and reference to the variable
into an input operation.

Acknowledgement
This work was originally motivated by discussions with Benjamin C. Pierce
on the essence of the previous deadlock-free type system [5] during the second
author's short visit to Indiana University. We would also like to thank Kenjiro

21

Sumii and Kobayashi
Taura, Toshihiro Shimizu, Atsushi Igarashi, and the anonymous referees for
their invaluable comments on earlier versions of this paper.

References

[1] Standard ML of New Jersey version 110. Available from http:

//cm.bell-labs.com/cm/cs/what/smlnj/NEWS/110-README.html.

[2] G'erard Boudol. Typing the use of resources in a concurrent calculus (extended

abstract). In The Third Asian Computing Science Conference (ASIAN '97),
volume 1345 of Lecture Notes in Computer Science, pages 239-253, 1997.

[3] Simon J. Gay. A sort inference algorithm for the polyadic ss-calculus.

In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 429-438, 1993.

[4] Naoki Kobayashi. Concurrent Linear Logic Programming. PhD thesis,

Department of Information Science, Graduate School of Science, University of
Tokyo, 1996.

[5] Naoki Kobayashi. A partially deadlock-free typed process calculus. ACM

Transactions on Programming Languages and Systems, 20(2):436-482, 1998.
A preliminary version appeared in Twelfth Annual IEEE Symposium on Logic
in Computer Science, pages 128-139, 1997.

[6] Naoki Kobayashi, Benjamin C. Pierce, and David N. Turner. Linearity and the

pi-calculus. In Conference Record of POPL '96: The 23rd ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, pages 358-371,
1996.

[7] Naoki Kobayashi and Akinori Yonezawa. Towards foundations for concurrent

object-oriented programming -- types and language design. Theory and
Practice of Object Systems, 1(4):243-268, 1995.

[8] Kim G. Larsen. Proof systems for satisfiability in Hennessy-Milner logic with

recursion. Theoretical Computer Science, 72:265-288, 1990.

[9] Robin Milner. The polyadic ss-calculus: a tutorial. In F. L. Bauer, W. Brauer,

and H. Schwichtenberg, editors, Logic and Algebra of Specification. SpringerVerlag, 1993.

[10] Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile

processes, I, II. Information and Computation, 100:1-77, 1992.

[11] Benjamin Pierce and Davide Sangiorgi. Typing and subtyping for mobile

processes. In Eighth Annual IEEE Symposium on Logic in Computer Science,
pages 376-385, 1993. Full version in Mathematical Structures in Computer
Science, Vol. 6, No. 5, pages 409-453, 1996.

22

Sumii and Kobayashi
[12] Benjamin C. Pierce and David N. Turner. Concurrent objects in a process

calculus. In Takayasu Ito and Akinori Yonezawa, editors, Theory and Practice
of Parallel Programming, volume 907 of Lecture Notes in Computer Science,
pages 187-215. Springer-Verlag, 1994.

[13] Benjamin C. Pierce and David N. Turner. Pict: A programming language based

on the pi-calculus. Technical Report CSCI 476, Computer Science Department,
Indiana University, 1997. To appear in Proof, Language and Interaction: Essays
in Honour of Robin Milner , Gordon Plotkin, Colin Stirling, and Mads Tofte,
editors, MIT Press.

[14] John H. Reppy. CML: A higher-order concurrent language. In Proceedings

of the ACM SIGPLAN '91 Conference on Programming Language Design and
Implementation, pages 293-305, 1991.

[15] Ehud Shapiro. The family of concurrent logic programming languages. ACM

Computing Surveys, 21(3):412-510, 1989.

[16] Toshihiro Shimizu and Naoki Kobayashi. Optimization of concurrent programs

using type system for deadlock-freedom. Technical report, Department of
Information Science, Faculty of Science, University of Tokyo. To appear.

[17] Eijiro Sumii and Naoki Kobayashi. A generalized deadlock-free process

calculus. Technical report, Department of Information Science, Faculty of
Science, University of Tokyo. To appear. Will be available from http:
//www.is.s.u-tokyo.ac.jp/~sumii/pub/.

[18] Kazunori Ueda and Masao Morita. Moded flat GHC and its message-oriented

implementation technique. New Generation Computing, 13(1):3-43, 1994.

[19] David Walker. Objects in the ss-calculus. Information and Computation,

116(2):253-271, 1995.

[20] Nobuko Yoshida. Graph types for monadic mobile processes. In V. Chandru

and V. Vinay, editors, Foundations of Software Technology and Theoretical
Computer Science, volume 1180 of Lecture Notes in Computer Science, pages
371-386. Springer-Verlag, 1996.

23