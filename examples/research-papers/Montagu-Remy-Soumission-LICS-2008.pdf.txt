

Towards a Simpler Account of Modules and Generativity:Abstract Types have Open Existential Types.

Beno^it MontaguINRIA
Benoit.Montagu@inria.fr

Didier R'emyINRIA
Didier.Remy@inria.fr

Abstract
We present a variant of the explicitly-typed secondorder polymorphic *-calculus with primitive open existen-tial types, i.e. a collection of more atomic constructs for

introduction and elimination of existential types. We equip
the language with a call-by-value small-step reduction se-mantics that enjoys the subject reduction property. Traditional closed existential types can be defined as syntacticsugar. Conversely, programs with no free existential types
can be rearranged to only use closed existential types, butthe translation is not compositional. We argue that open existential types model abstract types and modules with gen-erativity. We also introduce a new notion of paths at the
level of types instead of terms that allows for writing type
annotations more concisely and modularly.

Introduction

Modularity has always been the key to robust, manage-able, and maintainable large software. Modular programming requires good discipline from programmers but alsogood support from programming languages. Unsurprisingly, module systems and type systems for modules havebeen an area of intensive research in the programming language community for more than two decades.

The module system for the language ML first proposedby MacQueen [11] in the mid 80's and independently improved and simplified in the mid 90's by Harper and Lil-libridge [5] and by Leroy [8] is still the one in use in all
dialects of ML, with relatively minor differences. Abstracttypes, higher-order functors, and sharing a posteriori, are
key ingredients of its expressiveness and success.

However, there is still a discrepancy between the sim-plicity of the concepts necessary to understand and write

simple modular programs on the one hand and on the otherhand the complexity of the theoretical systems that have
been proposed to give them a meaning and the heavinessof their use in some larger scale but realistic situations.

Furthermore, previous works have highlighted the diffi-culty to define a reduction semantics at the level of modules
and circumvented the problem by giving a semantics via anon-trivial elaboration into an internal language, thus breaking the close correspondence between programs and logic.

In this paper, we present F. (read F-zip), a variantof System F with primitive

open existential types, alongwith a call-by-value operational semantics, that allows to

write programs more modularly, enjoys the subject reduction property, and whose underlying concepts are stronglyand directly related to logic. More precisely, we decompose

constructs for existentials into more atomic ones. We arguethat this is the key to model abstract types and generativity.

Thus, we claim that the notion of path is useless in thesole purpose of type abstraction. However, we also claim
that paths are useful to write compact programs. For thispurpose, we introduce a new notion of

path at the level oftypes, whereas it was usually defined at the level of terms.

Our present goal is not to increase the expressiveness ofthe module language, but instead to simplify the underlying concepts and to bridge the gap between the complexityof the state-of-the-art meta-theory of modules and the intuitive simplicity of the underlying mechanisms. We thinkthis is a necessary step towards the design of a language
with first-class modules that is conceptually economical yetmore expressive and flexible.

The rest of the paper is organized as follows. We reviewprevious approaches to abstract types in the next section.
We present open existential types in $2 and formal resultsin $3 and $4. We describe our notion of paths in $5. We
discuss related works in $6 before concluding remarks.

1. Previous approaches

Existing works on modules and type abstraction can besorted in two categories. In earlier works, abstract types

were usually identified with existential types. However, ithas been realized in the mid 80's that existential types do
not adequately model type abstraction. Since then, abstracttypes have been considered as types whose definition has

been forgotten and that are accessible through a path, i.e.modeled by strong sums and dependent types.

Our argument is that dependent types are actually toostrong for modeling abstract types, making the meta-theory
of modules unnecessarily involved. We instead argue thatwe can use existential types, once we "opened" them up.

We now review both approaches. For pedagogical pur-poses, we do not follow the chronological order.

1.1. Paths-based module systems

Paths are at the foundation of the majority of recent mod-ule systems [9, 17, 14]. They arise when a type is made abstract. Since the definition of the type has been forgotten,one cannot refer to it by how it is defined, instead one designate it by where it is defined: an abstract type is referred toa projection path from a value variable, which makes types
depend on values. In fact, types only depend on value vari-ables, and therefore only require a decidable fragment of
dependent types. However, this fragment is not stable underterm substitution, which impedes from defining a substitution semantics. This is a serious problem that has receivedmany different solutions in the literature, yet none of which
being quite satisfactory. A quick review follows.

Courant [1] designed a module system for the Coq proofassistant, together with a substitution semantics. To achieve

this, he used the full power of dependent types along withthe strong normalization property of Coq terms. This approach is not applicable to general purpose languages thatallows non terminating programs.

Lillibridge [10] designed a module calculus in whichpaths are extended so that they are stable under value substitution. He managed to define a substitution semantics andto prove the soundness of his system, but at the expense of
a substantial technical complexity.

Leroy [8] designed a module system and implemented itin the Objective Caml compiler [9], but did not give a direct

semantics. Instead he only gave a translation semantics ofhis system, using an untyped

*-calculus with records as thetarget, and proved the soundness of his system.

In the context of the definition of a formal specificationfor SML [17], Dreyer et al [3] defined a module type system along with a typed internal language. They defined anindirect semantics of their module system through a global
non trivial elaboration phase towards their internal languageand proved the soundness of the internal language.

1.2. Abstract types as existential types

Much earlier, Mitchell and Plotkin [13] had shown thatabstract types could be understood as existential types.

However, they also noticed that existential types do not ac-curately model type abstraction in modules, especially the
notion of generativity, and lack some modular properties.

In System F, existential types are introduced by the packconstruct. Provided the term

M has some type o/0 [ff  o/ ],the expression pack h
o/,Mi as 9ff.o/ 0 hides the type infor-mation
o/ , called the witness of the existential, from the typeof
M so that the resulting type is 9ff. o/ 0.

PACK \Gamma  `

M : o/ 0 [ff  o/ ]

\Gamma  ` pack ho/, Mi as 9ff. o/ 0 : 9ff. o/ 0

Existential types are eliminated by the unpack con-struct: provided

M has type 9ff. o/ , the expressionunpack
M as ff, x in M 0 binds the type variable ff to thewitness of the existential and the value variable

x to the unpacked term M in the body of M 0. The resulting type is theone of

M 0, in which ff must not appear free. The reason forthis restriction is that otherwise

ff, which is bound in M0,would escape its scope.

UNPACK\Gamma  `

M : 9ff. o/ \Gamma , ff, x : o/ ` M 0 : o/ 0 ff /2 ftv(o/ 0)

\Gamma  ` unpack M as ff, x in M0 : o/0

From now on we will consider System F is equippedwith the above constructs, as they can be recovered as a

well-known syntactic sugar.

2. Open existential types

Both of the pack and unpack constructs have modular-ity problems, but in different ways.
The problem with pack is verbosity: it requires to com-pletely specify the resulting type, thus duplicating type information in the parts that have not been abstracted away.This duplication happens, for instance, when hiding the type
of a single field of a large record, or maybe worse, whenhiding some type information deeply inside a record. It is
caused by the lack of separation between the introduction ofan existential quantifier, and the description of which parts
of the type must be made hidden.

The problem with unpack is non-locality: it imposes thesame scope to the type variable

ff and the value variable x,which is emphasized by the non escaping condition on

ff.As a result, all uses of the unpacked term must be anticipated. In other words, the only way to make the variable
ff available in the whole program is to put unpack earlyenough in the program, which is a non local, hence non

modular, program transformation. Again, the reason for itis that unpack is doing too many things at the same time.

In both cases, the lack of modularity is related to thelack of atomicity of the constructs. Therefore, we propose
to split both of them into more atomic constructs, recov-ering modularity while preserving--actually increasing--
expressiveness of existential types.

2.1. Atomic constructs for existential types

To achieve the decomposition of existential types intomore atomic constructs, we first need to enrich the context

of typing judgments.
Richer contexts for typing judgments. The contexts oftyping judgments in System F are sequences of items. An

item is either a binding x : o/ from a value variable to atype, which is introduced while typing functions, or a universal type variable 8ff, which is introduced while typingpolymorphic expressions.

We augment typing environments with two new items:existential type variables to keep track of the scope of
(open) abstract types, and type definitions ff = o/ to moreconcisely mediate between the abstract and concrete views
of types. That is, typing environments are as follows:

\Gamma  ::= " | \Gamma , b (Environments)
` ::= ff
b ::= x : o/ | 8` | ` = o/ | 9` (Bindings)

We shall see below that existential variables have to betreated linearly. The syntactic category

` is introduced hereto make easier the extension of F. with paths in $5.

Splitting pack. We replace pack by two orthogonal con-structs: existential introduction, which creates an existential
type, and coercion, which determines which parts of typesare to be hidden.

The existential introduction 9(ff = o/) M introduces anexistential type variable

ff with witness o/ (more precisely,the definition
ff = o/ ) in the environment while typing M ,and makes
ff existentially bound in the resulting type.

EXISTS\Gamma 

, ff = o/ ` M : o/0

\Gamma  ` 9(ff = o/ ) M : 9ff. o/ 0

The coercion (M : o/ ) replaces the type of M bysome compatible type

o/ . The compatibility relation ss isthe smallest structural equivalence that satisfies all typedefinitions occurring in the environment. A coercion is typi-cally employed to specify where some abstract types should
be used instead of their witnesses in the typing of M .

COERCE\Gamma  `

M : o/ 0 \Gamma  ` o/ 0 ss o/

\Gamma  ` (M : o/ ) : o/

The expressiveness of pack is retained, since it can beprovided as the following syntactic sugar:

pack ho/, Mi as 9ff. o/0 , 9(ff = o/) (M : o/0)
However, the description of what is being hidden can nowbe separated from the action of hiding, which avoids many

duplications of type information. Hence it makes the cre-ation of existential values, shorter, thus easier, and more
maintainable. Examples can be found in Appendix $A.1.

Splitting unpack. We also replace unpack by two or-thogonal constructs, opening and restriction, that implement scopeless unpacking of existential values and scoperestriction of abstract types, respectively.

The opening openff M expects M to have an existentialtype 9

ff. o/ and opens it under the name ff, which is trackedin the typing environment by the existential item 9

ff. Therule can also be read bottom-up, treating the item 9

ff as alinear resource that is consumed by the opening.

OPEN\Gamma  `

M : 9ff. o/ ff /2 dom \Gamma 

\Gamma , 9ff ` openff M : o/

The restriction *ff. M implements the non-escapingcondition of Rule U

NPACK. First, it requires ff not to ap-pear free in the type of

M, thus enforcing a limited scope.Second, it provides an existential resource 9

ff in the envi-ronment, that ought to be consumed by some open

ff M0

expression occurring within M .

NU\Gamma 

, 9ff ` M : o/ ff /2 ftv(o/ )

\Gamma  ` *ff. M : o/

Here again, we may provide unpack as syntactic sugar:
unpack M as ff, x in M0 , *ff. (let x = openff M in M0)
This explicits all the simultaneous operations performed byunpack: first, it defines a scope for the name

ff of the wit-ness of the existential type of
M; then, it opens M underthe name
ff; finally, it binds the resulting value to x in theremaining expression

M 0.

The main flaw of unpack, i.e. the scope restriction forthe abstract name, is essentially captured by the

restrictionconstruct. However, since it has been cut out in a separate

construct, which need not be always used anymore, the ab-stract type

ff may now be freely made available to the wholeprogram. Interestingly, this closely models type abstraction

in modules: the following program, written in an ML-likesyntax, defines an abstract module of integers.

module X : sig type t val z : t val s : t ! t end=struct

type t = int val z = 0 val s = *(x :int) x+1end

It provides the zero constant z and the successor function s.The type

X.t is abstract and available in the whole program.Its counterpart in F. is defined hereafter:

openfi 9(ff = int) ({z = 0 ; s = *(x : int) x+1} :{

z : ff ; s : ff ! ff})

Both codes look similar, except the fact that the signatureascription has been replaced by the opening of an existential

value. The counterpart of the signature is the type in thecoercion. Note that no type component, hence no name for
the module, is needed: the counterpart of X.t is the abstract

" . " = "(\Gamma 
1, b) . (\Gamma 2, b) = (\Gamma 1 . \Gamma 2) , b if b 6= 9ff(\Gamma 
1, 9ff) . (\Gamma 2, 8ff) = (\Gamma 1 . \Gamma 2) , 9ff(\Gamma 
1, 8ff) . (\Gamma 2, 9ff) = (\Gamma 1 . \Gamma 2) , 9ff

Figure 1. Zipping of two contexts.

type fi, which is present in the typing context. It is availablein the whole program and does not refer to a value variable.
Linearity to control openings. As openings use abstractnames given by the environment, one must be careful to
avoid "abstraction capture", as in the following example.

let f = openff 9(fi = int) (*(z : int) z + 1 : fi ! fi) inlet

x = openff 9(fi = bool) (true : fi) in f x

Here, f and x result from two different openings under thesame name

ff. Hence, f and x are assigned types ff ! ffand
ff, respectively, using the same abstract name ff. How-ever, each branch uses a different witness for

ff (int in thecase of
f and bool in the case of x). This yields to theapplication

f x, which is illegal indeed.
To prevent abstraction capture, it suffices that every name
ff be used in at most one opening under ff. This may beachieved by treating the existential items of the typing environment in a linear way. Linearity can easily be enforcedin typing rules by a

zipping operation that describes howtyping environments of the premises must be combined to

form the one of the conclusion. Zipping is a binary opera-tion, defined in Fig. 1, that proceeds by zipping individual
bindings pointwise. For all items but existential type vari-ables, zipping requires the two facing items to be identical,
as usual. The interesting case is when one of the two itemsis an existential variable

ff, in which case the other one mustbe a universal variable
ff, hence the zipper image. This en-sures that an existential variable in the conclusion can only

be used up in one of the premises.
2.2. Syntax of F.

The language F. is based on the explicitly typed versionof System F with records and is extended with constructs

of $2.1. Types and terms are described in Fig. 2.

As open existentials do not introduce new forms of types,types of F. are type variables, arrow types, record types,

universal types, and existential types. The notation (`i :
o/i)i21..n stands for a sequence of n pairs, each composed ofa label and a type. Type and environment wellformedness

are defined as usual (see Fig. 13 in the Appendix).

Terms of F. are variables, functions (whose argumentsare explicitly typed), applications, type generalizations and

applications, introductions and projections of records, andthe four constructs for open existentials described before.

Record fields are triples ` as x = M of a label name `,a variable name

x and a term M . The label name is used to

o/ ::= ff | o/ ! o/ | {(`i : o/i)i21..n}| 8

`. o/ | 9`. o/
M ::= x | *(x : o/ ) M | M M | \Lambda `. M|

M [o/ ] | 9(` = o/ ) M | (M : o/ )|
*`. M | openff M | {r} | M.`
r ::= ffl | ` as x = M ; r | ` : o/ as x = M ; r

Figure 2. Types and terms.

access the field externally, as usual with records. The vari-able name acts as a binding occurrence for the corresponding field whose scope extends to the end of the record. Thus,fields are visible to their successors and variable names can
be consistently renamed. We may omit the variable name xand just write

` = M when x does not occur in the remain-ing fields, as we have already done in the examples above.

Notice that our records generalize let-bindings, which arenot part of the syntax, as they can be expressed using the
following syntactic sugar:

let x = M in M 0 , {` as x = M ; `0 as x0 = M 0}.`0
Hence, we may freely use let-bindings in the examples.

In addition, we provide an optional type annotation onrecord fields, that behaves much as a coercion, but with the

following scoping: the type annotation is used for the exter-nal type of the record while remaining fields of the record
ignore it. This construct1 is theoretically unimportant, butpractically quite useful on real large examples.

For conciseness, we also use the following syntacticsugar in technical developments:

\Sigma fi(ff = o/ ) M , openfi 9(ff = o/) M
This can be understood as the creation of an abstract typewithout seeing the intermediate existential type--which is

a common programming pattern in modular programs.
2.3. Typing rules

Typing rules for open existentials have already been pre-sented in $2.1. A few more selected typing rules are given

on Fig. 3. The full type system can be found in Appendix.

Rule SHIFT states that if a term is typable in an environ-ment \Gamma  then it is also typable in every stronger environment

\Gamma 0, i.e. \Gamma 0 fl \Gamma . Environment entailment is the smallestpre-order satisfying the following commutation:

ff#b
\Gamma 1, 9ff, b, \Gamma 2 fl \Gamma 1, b, 9ff, \Gamma 2

The raison d'^etre of Rule SHIFT is to shift existential items

1In fact, this construct is slightly more general than coercion: expressing {`1 : o/1 as x1=M1 ; `2 as x2=M2} in terms of coercions requiresthe knowledge of the type of

M2. Conversely, the coercion (M : o/) canbe replaced by {
` : o/ = M}.`. The latter actually reduces to the former.Though coercions need not be exposed to the user, they must remain in the

syntax of terms.

VAR\Gamma  ` wf \Gamma  pure

\Gamma  ` x : \Gamma  (x)

APP\Gamma 

1 ` M1 : o/2 ! o/ \Gamma 2 ` M2 : o/2

\Gamma 1 . \Gamma 2 ` M1 M2 : o/

SHIFT\Gamma 0 `

M : o/ \Gamma  fl \Gamma 0

\Gamma  ` M : o/

Figure 3. More typing rules.

to the right of the environment (whenever this is sound):indeed Rule O

PEN needs the resource it consumes to bethe right-most item of the environment. Soundness of entailment is ensured by the natural interpretation of environ-ments as logical formulae.

The remaining typing rules are as in System F with twosmall differences described.
First, as mentioned above, typing rules with several typ-ing judgments as premises use zipping instead of equality
to relate their typing environments. This is exemplified byRule A

PP (and also used in typing rules for records).Typing rules must also ensure that values can be substituted without breaking linearity, which is the case whenthe typing environment does not contain any existential
items. When \Gamma  is such an environment, we say that \Gamma  ispure and write \Gamma  pure. This condition appears as an additional premise of typing rules of expressions that are non-compound values as exemplified by Rule V

AR. Purity willbe used and explained in more details in $2.4.

We consider now the typing derivation of term \Sigma fi(ff =
o/ ) M : this term abstracts (the type definition for) ff awayin two steps: first, the equation is forgotten returning the

existential value 9(ff = o/) M of type 9ff. o/ 0, which is thenopened under the name

fi. In a nutshell, type abstraction isthe composition of information erasure and generativity.

OPEN
EXISTS \Gamma , ff = o/ ` M : o/ 0\Gamma  ` 9(ff = o/) M : 9ff. o/ 0

\Gamma , 9fi ` openfi 9(ff = o/) M : o/ 0 [ff  fi]
2.4. Semantics

The language F. is equipped with a small-step call-by-value reduction semantics. We begin with important remarks about substitutability, then define and explain values,and finally describe the reduction steps.

Substitution and purity. Some terms cannot be safelysubstituted, since substitution may violate the linear treatment of openings. It turns out that pure terms, i.e. termsthat are typable in a pure environment, behave well with
respect to substitution:
Lemma 1 (Substitution lemma). If \Gamma  ` M : o/ and \Gamma 0, x :
o/, \Gamma 00 ` M 0 : o/ 0, where \Gamma  is pure and \Gamma  . \Gamma 0 is well
defined, then (\Gamma  . \Gamma 0) , \Gamma 00 ` M 0 [x  M] : o/ 0.

v ::= u | (u : o/) (Values)
u ::= x | *(x :o/ ) M (Pre-values)| \Lambda 

ff. M | 9(ff = o/ ) v | {rv}
rv ::= ffl | ` : o/ ? = v ; rv (Value-fields)

w ::= v | \Sigma fi(ff = o/ ) w (Results)
E ::= [] | E M | w E | E.` (Contexts)| 9(

ff = o/ ) E | openff E | (E : o/)|
*ff. E | {rv ; ` as x = E ; r}| {

rv ; ` : o/ ? as x = E ; r}

Figure 4. Values, results, evaluation contexts.

let x = \Sigma fi(ff = int)(1 : ff) in {`1 = x ; `2 = (*(y:fi)y) x}
1 \Sigma fi(ff = int)

let x = (1 : ff) in {`1 = x ; `2 = (*(y :ff) y) x}
1 \Sigma fi(ff = int) {`

1 = (1 : ff) ; `2 = (*(y :ff) y) (1 : ff)}
1 \Sigma fi(ff = int) {`

1 = (1 : ff) ; `2 = (1 : ff)}

Figure 5. Example of extrusion.

Therefore, if values are pure terms, they are substi-tutable. This leads us to the following question: is every
irreducible term also a pure term?
Results and values. Results are well-behaved irreducibleterms. These includes values. In System F (as in many other

languages) results actually coincide with values. However,this need not be the case. In F., results also include terms
such as \Sigma fi(ff = o/ ) *(x : ff) x, which are well-behaved andcannot be further reduced, but are not values, as they are not
pure and thus not substitutable.More precisely, values are defined in Fig. 4. They are
either pre-values or coerced pre-values, where pre-valuesare variables, functions, generalizations, existential values
or records of values. In particular, nested coercions are notvalues--they must be further reduced. Notice that no evaluation takes place under *'s or \Lambda 's. Finally, results are valuespreceded by a (possibly empty) sequence of \Sigma 's.

The purity premises in some of the typing rules ensurethat values are pure, hence by Lemma 1 substitutable.

Lemma 2 (Purity of values). If \Gamma  ` v : o/, then \Gamma  pure.
Extrusions. Values are substitutable, but some results arenot values. How can we handle these results, when they

ought to be substituted, without breaking linearity? Our an-swer is to move up the sources of linearity.

For example, consider the reduction steps on Fig. 5.The initial expression is a let-binding of the form let

x =
w in M where w is the result form \Sigma fi(ff = int) (1 : ff).Hence, the next expected reduction step is the substitution

of w for x in M. However, since x occurs twice in M , thiswould duplicate the opening appearing in

w breaking thelinear use of
fi. The solution is to first extrude the \Sigma  binding

{` as x = M ; r} " ` = M{
` : o/ as x = M ; r} " ` = (M : o/ ){
`0 : o/ ? as x = M ; r} " ` = {r} " ` if ` 6= `0

Figure 6. Projection of a record.

outside of the let-binding, so that the expression bound to xbecomes the substitutable value form (1 :

ff). However, byenlarging the scope of \Sigma , we have put
M in its scope, and asa consequence all occurrences of the external view

fi in Mshould be replaced by the internal view
ff. Then, we mayperform let-reduction safely and further reduce the

fi-redexthat has been created.

More generally, the reduction semantics will be set sothat \Sigma  can always be extruded out of redex forms.

Reduction. The semantics of F. is given by a call-by-value reduction strategy, described by a small-step reduction relation. We fix a left-to-right evaluation order so thatthe semantics is deterministic, although we could have left
the order unspecified. By contrast having a call-by-valuestrategy and a weak-reduction is essential.

Evaluation contexts are described in Fig. 4. A one-stepreduction is the application of a reduction rule in some evaluation context. The reduction relation is the transitive clo-sure of the one-step reduction relation. Due to lack of space,
we only describe a representative subset of the reductionrules in Fig. 7. The whole definition is available in the Appendix (Fig. 15). Reduction steps are sorted in three groups.

The main group of rules describe the contraction of re-dexes. The

fi-reduction and the reduction of type applica-tions are as usual and are omitted. Because our records

are dependent, they contain a form of let-reduction (RuleR

EDEX-RECORD). Record projection (Rule REDEX-PROJ)is as usual, except type annotations must be kept during

projection, as described in the definition of the projectionfunction in Fig. 6. The last form of this group is the contraction of abstract types described by rules NU-SIGMA1and N

U-SIGMA2, which is used to simplify terms of theform
*fi. \Sigma fi(ff = o/ ) M by substituting the witness o/ for ffinside

M . This is similar to the usual rule for contractingunpack-ing of pack's where the same substitution occurs.

The next group of rules implement the extrusion of \Sigma 's,in all cases where a \Sigma  comes up against a redex, as illustrated by rule SIGMA-APP-LEFT. As explained above, theinternal view

ff must be substituted for the external one fi interms that become in scope of

ff during the extrusion.

The last group of reduction rules keep track of coercionsduring reduction, as exemplified by Rule C

OERCE-APP.Notice that nested coercions are ignored, the outer one taking priority (Rule COERCE-COERCE).

3. Type soundness

Type soundness results from the combination of the sub-ject reduction and progress properties.

The subject reduction proof is, as usual, mainly built onthe substitution lemma (Lemma 1). The proof itself is not
really informative, but it is particularly interesting that theproof is absolutely standard and almost straightforward, as
this is not usually the case for other approaches to modules.
Proposition 1 (Subject reduction). If \Gamma  ` M : o/ and
M  M 0, then \Gamma  ` M0 : o/ .

This property is proved by induction on the reduction. Inorder to simplify case analysis, we first show that typing

derivations can be put in a canonical form, where successiveapplications of Rule S

HIFT have been fused.

Proposition 2 (Progress). If \Gamma  ` M : o/ and \Gamma  does not
contain value variable bindings, then either M is a result,or it is reducible.

Progress is proved by induction on the typing derivation.The side condition that \Gamma  does not contain any value variable is as usual. However, we cannot require the morerestrictive hypothesis that \Gamma  be empty as evaluation takes
place under existential quantifiers. Moreover, this allows toconsider the reduction of open programs, i.e. programs with
free type variables. This is the case for programs with ab-stract types, which comes from unrestricted openings. This
closely corresponds to ML programs composed of moduleswith abstract types.

4. Translations from and to System F

We propose a translation from System F to F. and, con-versely, from a subset of F. to System F. Although the first

one is compositional, the latter is not. This embodies thefact that F. is superior to system F in terms of modularity.

From F to F.. The syntactic sugar for pack and unpackprovides the translation from F to F., which is obviously
compositional and both type and semantic preserving.
From pure F. to F. The inverse translation merits closerexamination. Hereafter, we define a non-compositional

transformation from pure terms to terms of System F that isboth type and semantics preserving in the following sense:
the type-erasure2 of the translation of M is not equal butlet-reduces to the type-erasure of

M . This remark alreadysupplies some piece of information about modularity of F.

compared to F: the translation involves code shifting. As-suming that the translation is "optimal", this means that F.
brings more freedom, hence modularity, to write programs,whereas F requires a stricter definition discipline--imposed

2Type erasure is defined as usual--See Fig. 17 in the Appendix.

rv.`  rv " ` (REDEX-PROJ){
rv ; r}  {rv ; r [x  v]} if rv = \Gamma r0v ; ` : o/ ?i as x = v\Delta  and x 2 fv(r) (REDEX-RECORD)

*fi. \Sigma fi(ff = o/) v  *fi. \Sigma fi(ff = o/ ) v [ff  o/ ] if ff 2 ftv(v) (NU-SIGMA1)

*fi. \Sigma fi(ff = o/ ) v  v if ff /2 ftv(v) (NU-SIGMA2)

(\Sigma fi(ff = o/ ) w1) w2  \Sigma fi(ff = o/ ) (w1 (w2 [fi  ff])) if ff /2 ftv(w2) (SIGMA-APP-LEFT)

(u : o/1 ! o/2) v  (u v : o/2) (COERCE-APP)((

u : o/ ) : o/ 0)  (u : o/ 0) (COERCE-COERCE)

Figure 7. Reduction steps (selected rules).

\Gamma , ff = o/ ` M : o/0 . M0
\Gamma  ` 9(ff = o/ ) M : 9ff. o/ 0 . pack ho/, M 0 [ff  o/ ]i as 9ff. o/ 0

\Gamma  ` M : o/ 0 . M0 \Gamma  ` o/ 0 ss o/

\Gamma  ` (M : o/ ) : o/ . M0

\Gamma  ` M : o/ 0 . M 0 \Gamma  ` o/ 0 ss o/ \Gamma 0 ` {r} : {(`i : o/i)i21..n} . {r0}
\Gamma  . \Gamma 0 ` {` : o/ as x = M ; r} : {` : o/ ; (`i : o/i)i21..n} . {` as x = M0 ; r0}

Figure 8. From F. to F, first pass: recovering pack's (selected rules).

by the unpack construct, indeed. The translation is thecomposition of two sub-transformations: the first one takes
care of pack's, and the second one copes with unpack's.

The pack constructs are recovered from the typingderivation. The transformation is specified by a judgment

of the form \Gamma  ` M : o/0 . M 0 where M 0 is the transla-tion of

M. The main cases are given on Fig. 8: on the onehand, coercions are erased, regardless they are attached to

record fields or not; on the other hand, existential constructsare translated into pack's, where the witness substitution,
which is pushed into the context, is applied to the subtermbeing packed.

The recovering of unpack's requires more care, as itdoes not preserve the structure of terms. It is defined
through a rewriting system. Selected rules are given byFig. 9. It is based on the following property: if

*ff. M iswelltyped, then there is a
unique subterm openff M 0 inside
M and it is not located under *'s of \Lambda 's. Thus, M is a termof the form

Qff, as defined3 in Fig. 9. The rewriting rulesoperate on terms of the form

*ff. Qff and bring a restric-tion and its opening closer by decreasing the size of

Qff.This is done either by predefining the subterm containing

the opening thanks to a let when it is possible or by makingthe restriction go down otherwise. The last two rules are terminal: they replace openings by unpackings when the pat-tern of unpack is recognized. When no rewriting rule applies anymore, the term has no restriction left. If moreover
M is typable in a pure typing context, then it cannot con-tain openings either. So, the resulting term is in System F.

Furthermore, each rewriting rule is both type and seman-tics preserving (the type-erasure of the right-hand side letreduces to the type-erasure of the left-hand side). Appendix

3We temporarily add let's, pack's and unpack's to the syntax to allow
for easier reasoning.

^ ::= ? | ^ ! ^ | {(`i : ^i)i21..n} (Kinds)
` ::= ff 2 oe
oe ::= ? | o/ | [`] oe (Shapes)
o/ ::= . . . | o/.` | o/.1 | o/.2 (Projections)

Figure 10. Shapes and type projections.

contains an application of the translation on an example.It is an open question whether the translation can be extended to impure terms, i.e. terms that are welltyped in ar-bitrary contexts. The issue is how to keep track of linearity
of existential resources.
5. Paths and shapes

A sledgehammer argument for paths in modules is theirability to factorize code [6, 12], as exemplified by the wellknown diamond import pattern. Although this justifies theneed of a path system, this does not specifically vindicate
the use of paths at the term level. Instead, we introduce apath system at the level of types, which is composed of two
key ingredients: type shapes and type projections.
5.1. Definitions

Differences from F. are described on Fig. 10 and ex-plained below. We define kinds to forbid illegal projections:

they consist in the base kind, the kind of arrow types andthe kind of of record types. Rules for kinds are as expected.
See Fig. 18 and 19 in the Appendix for details. The syntac-tic categories

`, oe and o/ are mutually recursively defined.They are explained hereafter.

Shapes. Shapes represent sets of types and are used to re-strict the range of binding type variables. Their interpretation is given on Fig. 11: the top shape ? is the set of all

Qff ::= openff M | Qff M | M Qff | Qff [o/ ] | pack ho/, Qffi as 9fi. o/ 0 | unpack Qff as fi, x in M| unpack

M as fi, x in Qff if fi 6= ff | *fi. Qff if fi 6= ff | openfi Qff if fi 6= ff | Qff.`| {
r ; ` as x = Qff ; r0} | let x = M in Qff | let x = Qff in M

*ff. (Qff M) . *ff. let x = Qff in x M
*ff. (let x = M in Qff) . let x = M [ff  {}] in *ff. Qff

*ff. (openff M) . unpack M as ff, x in x
*ff. (let x = openff M in M0) . unpack M as ff, x in M0

Figure 9. From F. to F, second pass: recovering unpack's (selected rules).

\Gamma  ` o/ :: ^
\Gamma  ` o/ 2 ?

\Gamma  ` o/ :: ^
\Gamma  ` o/ 2 o/

\Gamma  ` o/ 2 oe \Gamma , 8 (ff 2 oe) ` o/0 2 oe0

\Gamma  ` o/ 0 [ff  o/ ] 2 [ff 2 oe] oe0

Figure 11. Meaning of shapes.

(wellformed) types, the singleton shape o/ is the set contain-ing the unique type

o/ , and the compound shape [ff 2 oe] oe0is the set of types
o/ 0 [ff  o/ ], where o/0 2 oe0 and o/ 2 oe.
Binding occurrences of type variables henceforth carry ashape. For example, the identity function on homogeneous

pairs (i.e. pairs whose components are of the same type),has type 8(

ff 2 ?) {` : ff ; `0 : ff} ! {` : ff ; `0 : ff}, butalso 8(
ff 2 [fi 2 ?] {` : fi ; `0 : fi}) ff ! ff. Shapes willplay the role of ML's module signatures.

Type projections. Shapes can already express sharingproperties, internally, as shown above. However, without
external access to shapes their benefits would be very lim-ited. We introduce projections to access shapes externally.

The typing rules ensure that a universally typed vari-able

ff of shape oe will only be instantiated by types thatare in

oe. Hence, if the shape only contains, for instance,arrow types, which is the case it has an arrow kind, then

ff.1and
ff.2 designate the domain and the codomain of ff. Sim-ilarly, if the shape only contains records with at least field

`, which is the case if the kind of the shape is a record kindwith a field

`, then ff.` designates the ` projection of ff.
For instance, a function taking two pairs as argumentsand returning the pair of their first components can be given

the following type:8

(ff1 2 [fi1 2 ?] {` : fi1 ; `0 : fi1})8(

ff2 2 [fi2 2 ?] {` : fi2 ; `0 : fi2})

ff1 ! ff2 ! {` : ff1.` ; `0 : ff2.`}The resulting type is defined in terms of projections of the

types of the arguments. Projections may also be used to ex-press sharing between the shapes of the arguments, much as
paths may express sharing between signatures of the argu-ments of a functor in ML. Pursuing the example, we may
require that the two first components have the same type, so

EQUI-VAR(

ff 2 o/ ) 2 \Gamma 

\Gamma  ` ff j o/

EQUI-PROJ-LABEL\Gamma  `

o/ j {`i : o/ i21..ni } 1 <= k <= n

\Gamma  ` o/.`k j o/k

EQUI-PROJ-ARROW\Gamma  `

o/ j o/1 ! o/2

\Gamma  ` o/.i j o/i

EQUI-FOLD

ff /2 ftv(\Gamma 0, o/, o/ 0)\Gamma 
, 8 (ff 2 oe) , 8 (ff0 2 oe0) , \Gamma 0 ` o/ j o/ 0

\Gamma , 8 (ff0 2 [ff 2 oe] oe0) , \Gamma 0 ` o/ j o/ 0

Figure 12. Type equivalence (selected rules).

that the result type is an homogeneous pair, as follows:8

(ff1 2 [fi1 2 ?] {` : fi1 ; `0 : fi1})8(

ff2 2 [fi2 2 ?] {` : ff1.` ; `0 : fi2})

ff1 ! ff2 ! {` : ff1.` ; `0 : ff1.`}

Equivalent types and shapes. Singleton shapes and typeprojections obviously suggest a notion of type equivalence,
which we introduce as a judgment of the form \Gamma  ` o/ j o/ 0.The main rules are shown in Fig. 12: Rule E

QUI-VAR iden-tifies elements of a singleton shape; types are equivalent up

to projections (rules EQUI-PROJ-*). Rule EQUI-FOLD un-folds compound shapes inside the typing environment so as
to expose inner sharing. Notice that this a form of extru-sion. (The whole set of rules can be found in the Appendix,
Fig. 22.) We also define an equivalence on shapes from theirset-based semantics: two shapes are equivalent if they contain the same types, which can also be characterized syntac-tically (Fig. 23 in the Appendix).

Of course, equivalent types are then identified throughan additional, straightforward typing rule.

Summary. Shapes are stunningly simple objects: a re-markable feature of shape equivalence is that shapes have a
canonical form, where only ? is used on the left-hand sideof compound shapes. Hence, shapes are nothing more than
types with holes (i.e. ?'s) and sharing: they can be repre-sented as dags. Thus, shapes could have been defined using
a different syntax. We may also extend the syntax with shar-ing constraints so as to define new shapes from older ones,
concisely.

5.2. Applications
Shapes increase conciseness and modularity. Shapesare an orthogonal extension to open existential types, and

can already increase conciseness in System F, as illustratedby the use of projections in the examples above.

Another explanation of the power of shapes, is givenby (a sketch of) a translation into System F: quantification over a type of the trivial shape ? is translatedinto the usual quantification; quantification over a type
of a singleton shape is translated by substituting the typeof the singleton, which illustrates the sharing power of
shapes. Finally, quantification over a compound shape8(

ff 2 [fi 2 oe] oe0) o/ is translated into an additional quan-tification 8(

fi 2 oe) 8(ff 2 oe0) o/. Thus, compound shapescan be seen as a way to save up explicit quantifications.

Simultaneous openings. An interesting application ofpaths is the factorization of openings, as in \Sigma 

fi(ff 2

[fl1 2 ?] [fl2 2 ?] {`1 : fl1;`2 : fl2} = o/ )M. This adds fi tothe typing context, hence provides two fresh names

fi.`1and
fi.`2 as if we had done two separate openings. Thisusage corresponds to modules with multiple abstract type

components.
Scopeless type definitions. Paths also provide F. withscopeless type definitions, as a side effect, by opening an

existential value whose witness is specified with a singletonshape as in \Sigma 

fi(ff 2 o/ = o/ ) M. Since fi has shape o/ , fi j o/

holds. This fact appears in the typing context of M as thebinder 9 (

fi 2 o/ ) is present and carried over by the zippingof contexts outside of

M as the binder 8 (fi 2 o/ ), so thatthe information
fi j o/ is reachable in the whole program.A simple example can be found in Appendix.

Wrap-up. In spite of its intrinsic simplicity, the path sys-tem we propose is sufficiently expressive to write modules
and functors as compactly as in ML, while avoiding thecumbersome use of type components.

6. Related work
Open existential types. Russo [16] justifies the pointless-ness of paths for module types, by interpreting modules and

signatures into semantic objects with System F types. Hemakes use of existential quantifiers to track type generativity. Unfortunately, no semantics is given for the semanticobjects, so that one cannot calculate with them. Perhaps,
F. can be seen as a concrete calculus for his system.

In the context of run-time type inspection, Rossberg [15]introduces

*N, a version of System F with a construct to de-fine abstract types and a mechanism of directed coercions.

His abstract types can be automatically extruded to allowsharper type analysis, and are thus close to our \Sigma  binder.
His coercions resemble ours, though ours are symmetric,because they never cross the abstraction barrier. Although

both systems seem kindred in spirit, they are subtly differ-ent, because they have been designed for different purposes:
in particular, *N is only partially related to traditional exis-tential types, since parametricity is purposely violated.

Dreyer defines RTG to deal with type generativity in thecontext of recursive modules [2]. He introduces

type refer-ences which can be written at most once. The creation of a

type reference with "new ff in M " introduces a type vari-able in the scope of

M that should be treated as a resourcethat can be set at most once, with his type reference update

"set ff := o/ in M". Then, M and only M will see theconcrete definition

o/ for ff while other paths of the programwill see
ff abstractly.

Technically, the treatment of these linear resources dif-fer significantly from ours: his semantics employs a type

store to model static but imperative type reference updates,whereas we just use extrusions of \Sigma  binders4. He uses an
effect type system to guarantee the uniqueness of writing,which exposes the evaluation order in the typing rules of

RTG, moving away from a logical specification, whereaswe use zipping of contexts--a symmetric operation--to enforce sound openings and maintain a close correspondencewith logic. Intuitively, we think of existential values as generating a fresh type when opened, while he sees them asfunctions in "destination passing style".

Despite these strong technical differences, the two sys-tems can be put in close correspondence, when we remove
paths from F. and equirecursive and higher-order typesfrom R

TG. In both directions, there exists an encoding5based on the typing derivation that replaces the new and

set constructs by our * and \Sigma  binders, or conversely. Inthe forward direction, we assume that F. terms have been
rearranged to use the pack form only. In the backward di-rection, we assume that terms of R

TG do not use a typevariable before it has been written, as this would translate

in the general case into recursively defined abstract types,which F. does not allow. Interestingly, R

TG has been de-signed to especially allow this situation, as its goal was to

model recursive modules, whereas F. has disallowed thissituation to avoid the complexity of equirecursive types in
a first step, as they are not needed to model ML modules.In this restrictive case, F. can

a posteriori be seen as analternative presentation of R
TG in direct style.

Paths. Our type projections are similar to Hofmann andPierce [7]'s type destructors, which they proposed to increase the expressiveness of F<=. However, the supertype
bounds of F<= have been replaced by shapes in F., whichare an considerably simpler.

4Perhaps, these two approaches could be related by seeing our extrusion as a local treatment of his type store, as has been proposed for valuereferences [4].

5The details of both encodings can be found in Appendix $A.4.

Concluding remarks

We have defined F., a variant of explicitly-typed Sys-tem F with primitive open existential types, which generalize the usual notion of (closed) existential types by splittingtheir creation and elimination into more atomic constructs.
The subject reduction and progress theorems holds for F.and have straightforward routine proofs.

We have shown how openings of existential valuestightly correspond to type abstraction and generativity in
modules. Translations from and to System F have illus-trated the modularity gain brought by F. and have restored
the close connexion between abstract programs and logic.

We have proposed a new notion of paths, at the levelof types, that brings back the conciseness of writing provided by ML modules with almost no complexity overhead.Moreover, we have kept type abstraction and paths as two
independent mechanisms, though they are usually presentedtogether as an atomic package.

We believe that F. is promising as the core of a program-ming language with first-class modules. The

bare simplicityof F. is its best asset.

We have purposely limited the expressiveness of F. tothe minimal that permits programming with modules in the
ML-like style, directly. The integration of general purposefeatures such as recursive types, value references or recursion, should be straightforward. Extended F. both withequirecursive and with higher-order kinds while preserving its direct and logical style is currently under work, andpromising. The former is required to enable for programming with--and hopefully provide a simpler foundationsfor--recursive modules and mixin modules. The latter is
motivated by Russo's work on modeling applicative func-tors. We have avoided the complication of using linear types
by keeping resources in the typing contexts. Interestingly,our systems remains sufficiently expressive to model MLlike modules. Still, this restriction prevents the definition ofimpure functions and breaks the usual symmetry between
contexts and expressions. Adding linear types should notraise technical problems, but this remains to be investigated.

Of course, some form of type inference would eventu-ally be needed in a real programming language based on
F.. An easy solution is to stratify the type system--just forthe purpose of type inference. We could infer ML-like types
for the base level and require explicit type information forthe module level, as for ML. Another more ambitious direction is to use a form of partial type inference with first-classpolymorphism, indeed.

Acknowledgments The authors owe much to Paul-Andr'eMelli`es for fruitful discussions that lead to technical simplifications of our proposal and for suggesting the zippermetaphor. We also thank Arthur Chargu'eraud and Franc,ois
Pottier for helpful discussions.

References

[1] J. Courant. An applicative module calculus. In Theory

and Practice of Software Development 97, Lecture Notes
in Computer Science, pages 622-636, Lille, France, april
1997. Springer-Verlag.

[2] D. Dreyer. Recursive type generativity. Journal of Functional Programming, pages 433-471, 2007.

[3] D. Dreyer, K. Crary, and R. Harper. A type system for

higher-order modules. In 2003 ACM SIGPLAN Symposium
on Principles of Programming Languages, 2003.

[4] M. Felleisen. The Calculi of Lambda-v-CS Conversion: A

Syntactic Theory of Control and State in Imperative HigherOrder Programming Languages. PhD thesis, Indiana University, 1987.

[5] R. Harper and M. Lillibridge. A type-theoretic approach to

higher-order modules with sharing. In Proceedings of the
21st ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, pages 123-137, New York, NY,
USA, 1994. ACM.

[6] R. Harper and B. C. Pierce. Design considerations for MLstyle module systems. In B. C. Pierce, editor, Advanced Topics in Types and Programming Languages, chapter 8, pages
293-345. The MIT Press, 2005.

[7] M. Hofmann and B. C. Pierce. Type destructors. In

D. R'emy, editor, Informal proceedings of the Fourth International Workshop on Foundations of Object-Oriented Languages (FOOL), Jan. 1998.

[8] X. Leroy. A syntactic theory of type generativity and sharing. Journal of Functional Programming, 6(5):667-698,
1996.

[9] X. Leroy, D. Doligez, J. Garrigue, D. R'emy, and J. Vouillon.

The Objective Caml system release 3.10. INRIA, may 2007.

[10] M. Lillibridge. Translucent Sums: A Foundation for HigherOrder Module Systems. PhD thesis, School of Computer
Science, Carnegie Mellon University, Pittsburgh, may 1997.

[11] D. MacQueen. Modules for standard ML. In Proceedings of

the ACM Symposium on LISP and functional programming,
pages 198-207, New York, NY, USA, 1984. ACM.

[12] D. B. MacQueen. Using dependent types to express modular structure. In Proceedings of the 13th ACM SIGACTSIGPLAN symposium on Principles of programming languages, pages 277-286, New York, NY, USA, 1986. ACM.

[13] J. C. Mitchell and G. D. Plotkin. Abstract types have existential type. ACM Trans. Program. Lang. Syst., 10(3):470-502,
1988.

[14] M. Odersky, V. Cremet, C. R"ockl, and M. Zenger. A nominal

theory of objects with dependent types. In Proceedings of
ECOOP, 2003.

[15] A. Rossberg. Generativity and dynamic opacity for abstract

types. In 5th ACM-SIGPLAN International Conference on
Principles and Practice of Declarative Programming, Uppsala, Sweden, September 2003.

[16] C. V. Russo. Types for modules. Electronic Notes in Theoretical Computer Science, 60, january 2003.

[17] Standard ML of New Jersey User's Guide.

A. Appendix
A.1. Additional example

The splitting of pack allows for putting the informationof hiding parts of a type deeply inside a term: in the following record, some leafs have been abstracted away.9

(ff = int)let

x = {`1 = (1 : ff) ; `2 = 2} inlet
y = {`1 = x ; `2 = x} in{
`1 = y ; `2 = y}The corresponding system F term requires to repeat the type

of the whole term.

let z =let

x = {`1 = 1 ; `2 = 2} inlet
y = {`1 = x ; `2 = x} in{
`1 = y ; `2 = y} inpack hint

, zi as9
ff. {`1 : {`1 : {`1 : ff ; `2 :int} ; `2 : {`1 : ff ; `2 :int}} ;

`2 : {`1 : {`1 : ff ; `2 :int} ; `2 : {`1 : ff ; `2 :int}}}Moreover, whereas the information of hiding was located at

a single place in the F.-term, it is duplicated in the F-term,as if each leaf had been abstracted independently.

A.2. Translations from and to system F

This section contains some formal results and an exam-ple about the transformations presented in $4.

A.2.1 From F to F.
The (compositional) transformation from F to F. consistsin unfolding the syntactic sugar for pack and unpack. Its

is characterized by the following property.
Proposition 3. There exists a compositional transformationJ*K

from F to F. such that:

* bJMKc = bMc

* if \Gamma  `F M : o/ then \Gamma  `F. JMK : o/ .

b*c is a type-erasure operation that is defined on Fig. 17.

A.2.2 From F. to F
The encoding of a subset of F. into F is enjoys the follow-ing property.

Proposition 4. There exists a global transformation L*M
from F. to F, defined for all terms M verifying \Gamma  `F.
M : o/ for some pure and type-definition-free context \Gamma ,
such that:

* bLM Mc let-! bMc

* if \Gamma  `F. M : o/, then \Gamma  `F LM M : o/ .

As described in $4, the translation consists in two sub-transformations: the first one deals with the recovering of
pack's, the second one copes with unpack's. The sound-ness of the first pass is ensured by the following lemma.

Lemma 3. If \Gamma  ` M : o/ . M0, then bM c = bM 0c.
Moreover, \Gamma oe ` M 0oe : o/ oe and \Gamma  ` o/ ss o/ oe where oe
denotes the substitution induced by the equations of \Gamma .

As the typing environment is required to be type-definition-free, the transformation is type preserving. The

property between the underlying untyped terms of thesource and the target are proved without difficulty by induction on the derivation.Soundness of the second pass (Fig. 16) is proved independently for each rule.
Example 1. A pure F.-term and its translation in F.
Before the transformation:

*ff.{

`1 as x = 9(fi = int){encode : int !

fi =
*(n : int)if

n < 0 then - 2 * n + 1 else 2 * n ;decode :
fi ! int =
*(n : int)if

n mod 2 = 0 then n/2 else (1-n)/2} ;
`2 as f = \Lambda fi.

*(p : {encode : int ! fi ; decode : fi ! int})

*(x : int) p.decode (p.encode x) ;
`3 = f [ff] (openff x) 2008 }

After the transformation:

let z ={

`1 = 9(fi = int){encode : int !

fi =
*(n : int)if

n < 0 then - 2 * n + 1 else 2 * n ;decode :
fi ! int =
*(n : int)if

n mod 2 = 0 then n/2 else (1-n)/2} ;
`2 = \Lambda fi.

*(p : {encode : int ! fi ; decode : fi ! int})

*(x : int) p.decode (p.encode x) } inlet
z0 = unpack z.`1 as ff, y in z.`2 [ff] y 2008 in{
`1 = z.`1 ; `2 = z.`2 ; `3 = z0}

A.3. Paths and shapes
A.3.1 Examples with functors
Example 2. Three versions of the identity function special-ized on pairs:

* In System F: \Lambda ff. \Lambda fi. *(x : {` : ff ; `0 : fi}) xAnd its type: 8

ff. 8fi. {` : ff ; `0 : fi} ! {` : ff ; `0 : fi}.

* With shapes:\Lambda (

ff 2 [fi1 2 ?] [fi2 2 ?] {` : fi1 ; `0 : fi2})
*(x : ff) xAnd its type:

8(ff 2 [fi1 2 ?] [fi2 2 ?] {` : fi1 ; `0 : fi2}) ff ! ff

* In ML:functor

(X : sig type t1 type t2 val x : t1 val x0 : t2 end)=

XAn its type:

functor(

X : sig type t1 type t2 val x : t1 val x0 : t2 end)! sig type t

1 = X.t1 type t2 = X.t2val x : t

1 val x0 : t2 end

Example 3. Three versions of a function taking two pairs asarguments and returning the pair of their first components:

* In System F:\Lambda 

ff1. \Lambda ff2. \Lambda fi1. \Lambda fi2.
*(x : {` : ff1 ; `0 : ff2}) *(y :{` : fi1 ; `0 : fi2}){

` = x.` ; `0 = y.`}And its type:

8ff1. 8ff2. 8fi1. 8fi2.{

` : ff1 ; `0 : ff2} ! {` : fi1 ; `0 : fi2}! {

` : ff1 ; `0 : fi1}

* With shapes:\Lambda (

ff 2 [ff1 2 ?] [ff2 2 ?] {` : ff1 ; `0 : ff2})\Lambda (
fi 2 [fi1 2 ?] [fi2 2 ?] {` : fi1 ; `0 : fi2})
*(x : ff) *(y : fi) {` = x.` ; `0 = y.`}And its type:

8(ff 2 [ff1 2 ?] [ff2 2 ?] {` : ff1 ; `0 : ff2})8(

fi 2 [fi1 2 ?] [fi2 2 ?] {` : fi1 ; `0 : fi2})

ff ! fi ! {` : ff.` ; `0 : fi.`}

* In ML:functor

(X : sig type t1 type t2 val x : t1 val x0 : t2 end)(

Y : sig type t1 type t2 val x : t1 val x0 : t2 end)= struct val x =

X.x val x0 = Y.x endAnd its type:

functor(

X : sig type t1 type t2 val x : t1 val x0 : t2 end)! functor

(Y : sig type t1 type t2 val x : t1 val x0 : t2 end)! sig val x :

X.t1 val x0 : Y.t2 end

A.3.2 Examples with existentials
Example 4. Comparison of scopeless type definitions inML and F. with paths.

* In ML:

module M =struct type t = int * bool val x = (1

, false) endlet
f (p : M.t) = (1 + fst p, snd p) in
f M.x

* In F. with paths:let

m =\Sigma 
fi(ff 2 {` = int ; `0 = bool} = {` = int ; `0 = bool}){

x = {` = 1 ; `0 = false}} inlet
f = *(p : fi) {` = 1 + p.` ; `0 = p.`0} in
f m.x

In the second program, let us call o/0 the type {` : int ; `0 :bool}. Then let us call

M and P the subterm that definesthe variable
m and the one following m's definition, respec-tively. The last node of its derivation is as follows:

9 (fi 2 o/0) ` M : {x : o/0}8 (
fi 2 o/0) , m : {x : o/0} ` P : {x : o/0}9

(fi 2 o/0) ` let m = M in P : o/0As
M opens an existential value with the name fi, its typ-ing environment contains the existential binding 9 (

fi 2 o/0).Notice the zipping operation transforms it into an universal

one 9 (fi 2 o/0) in the second branch of the let. Thus in bothbranches we can prove

fi j o/0. This is as in the above MLcode: inside and outside module

M, we know the definitionof
M.t since it is transparent.

A.4. Comparison between F. and RTG

Our system F. and Dreyer's RTG are tightly related. Us-ing Dreyer's

destination-passing style (DPS) encoding ofexistentials, we describe--informally--an encoding of F.

into RTG:J

9ff. o/ KRTG = 8"ff. unit ff#--! Jo/KJ
pack ho/, Mi as 9ff. o/ 0KRTG =let

x = JMKRTG in\Lambda "
ff. *(x : unit) set ff := Jo/ KRTG in x : Jo/ 0KRTGJ

*ff. M KRTG = new ff in JMKRTGJ
openff MKRTG = let x = JM KRTG in x [ff] ()

This puts in correspondence both points of view. Creatingan existential value consists in delaying a type variable assignment. Opening an existential value corresponds to re-leasing the writing of a type reference. Finally, the creation
of an existential resource in the typing environment is simi-lar to the creation of a writable type reference.

Although this encoding is compositional, it is restrictedto source terms where all existential values are introduced
with the pack form. Thus, the more liberal forms of exis-tential introduction 9(

ff = o/ ) M should have been put inpack forms first, based on their typing derivation.

The inverse translation can be informally defined on astrict subset of R

TG that does not use equirecursive, higherorder types and recursion. More precisely, we forbid usinga writable type reference before it has been written. We
purposely introduced this restriction in F., for simplicity,to keep the correspondence with System F, and because it
was sufficient to encode ML modules.Assuming this restriction on R

TG terms, we give--informally--the following translation:r

8"ff. o/1 ff#--! o/2zF. = Jo/1KF. ! 9ff. Jo/2KF.q
\Lambda "ff. *(x : o/1) eyF. =

*(x : o/1) *ff. let x = JeKF. in 9(fi = ff) (x : Jo/2KF.)where

o/2 is the type of M , extracted from the derivationJ

v1 [ff] v2KF. = openff (Jv1KF. Jv2KF.)J
let ff = o/ in eKF. = JeKF. [ff  Jo/ KF.]J
new ff in eKF. = *ff. JeKF.J
set ff := o/1 in e : o/2KF. =\Sigma 

ff(ff = Jo/1KF.) (JeKF. : Jo/2KF.)

Thanks to the restriction above, a "DPS function" has a
type 8"ff. o/1 ff#--! o/2 where ff is not free in o/1. Hence, it canbe translated into a function of type J

o/1KF. ! 9ff. Jo/2KF..Notice that this case requires the typing derivation, as in

the over direction. The application of a DPS function istranslated accordingly. The translation of other constructs
is rather obvious.
A.5. Rules and definitions

The rest of the appendix gathers the rules and definitionsused in this paper.

ff 2 dom \Gamma  \Gamma  ` wf

\Gamma  ` ff wf

\Gamma  ` o/ wf \Gamma  ` o/ 0 wf

\Gamma  ` o/ ! o/ 0 wf

8i, j, i 6= j ) `i 6= `j8

i 2 {1..n} , \Gamma  ` o/i wf

\Gamma  ` {(`i : o/i)i21..n} wf

\Gamma , 8ff ` o/ wf
\Gamma  ` 8ff. o/ wf

\Gamma , 9ff ` o/ wf
\Gamma  ` 9ff. o/ wf

" ` wf

\Gamma  ` wf \Gamma  ` o/ wf x /2 dom \Gamma 

\Gamma , x : o/ ` wf

\Gamma  ` wf ff /2 dom \Gamma 

\Gamma , 8ff ` wf

\Gamma  ` wf ff /2 dom \Gamma 

\Gamma , 9ff ` wf

Figure 13. Wellformed types and environments.

VAR\Gamma  ` wf \Gamma  pure

\Gamma  ` x : \Gamma  (x)

LAM\Gamma 

, x : o/1 ` M : o/2 \Gamma  pure

\Gamma  ` *(x : o/1) M : o/1 ! o/2

APP\Gamma 

1 ` M1 : o/2 ! o/ \Gamma 2 ` M2 : o/2

\Gamma 1 . \Gamma 2 ` M1 M2 : o/

GEN\Gamma 

, 8ff ` M : o/ \Gamma  pure

\Gamma  ` \Lambda ff. M : 8ff. o/

INST\Gamma  `

M : 8ff. o/0 \Gamma  ` o/ wf

\Gamma  ` M [o/ ] : o/ 0 [ff  o/ ]

RECORD-EMPTY\Gamma  ` wf \Gamma  pure

\Gamma  ` {} : {}
RECORD-VAL1 8

i 2 {1, . . . , n} , ` 6= `0i

\Gamma  ` M : o/ \Gamma 0, x : o/ ` {r} : {(`0i : o/ 0i )i21..n}

\Gamma  . \Gamma 0 ` {` as x = M ; r} : {` : o/ ; (`0i : o/ 0i )i21..n}

RECORD-VAL28

i 2 {1, . . . , n} , ` 6= `0i \Gamma  ` M : o/0

\Gamma  ` o/0 ss o/ \Gamma 0, x : o/0 ` {r} : {(`0i : o/0i )i21..n}

\Gamma  . \Gamma 0 ` {` : o/ as x = M ; r} : {` : o/ ; (`0i : o/ 0i )i21..n}

PROJ\Gamma  `

M : {(`i : o/i)i21..n} 1 <= k <= n

\Gamma  ` M.`k : o/k

EXISTS\Gamma 

, ff = o/ 0 ` M : o/

\Gamma  ` 9(ff = o/ 0) M : 9ff. o/

COERCE\Gamma  `

M : o/ 0 \Gamma  ` o/0 ss o/

\Gamma  ` (M : o/ ) : o/

OPEN\Gamma  `

M : 9ff. o/ ff /2 dom \Gamma 

\Gamma , 9ff ` openff M : o/

NU\Gamma 

, 9ff ` M : o/ ff /2 ftv(o/ )

\Gamma  ` *ff. M : o/

SHIFT\Gamma 0 `

M : o/ \Gamma  fl \Gamma 0

\Gamma  ` M : o/

Figure 14. All typing rules of F..

(*(x :o/ ) M) v  M [x  v] (REDEX-APP)(\Lambda 

ff. M) [o/ ]  M [ff  o/] (REDEX-INST)

rv.`  rv " ` (REDEX-PROJ){
rv ; r}  {rv ; r [x  v]} if rv = \Gamma r0v ; ` : o/ ?i as x = v\Delta  and x 2 fv(r) (REDEX-RECORD)(\Sigma 

fi(ff = o/ ) w1) w2  \Sigma fi(ff = o/ ) (w1 (w2 [fi  ff])) if ff /2 ftv(w2) (SIGMA-APP-LEFT)

v (\Sigma fi(ff = o/ ) w)  \Sigma fi(ff = o/) ((v [fi  ff]) w) if ff /2 ftv(v) (SIGMA-APP-RIGHT)(\Sigma 

fi(ff = o/ ) w) [o/ 0]  \Sigma fi(ff = o/ ) (w [o/0 [fi  ff]]) if ff /2 ftv(o/ 0) (SIGMA-INST)

(\Sigma fi(ff = o/ ) w).`  \Sigma fi(ff = o/ ) (w.`) (SIGMA-PROJ){
rv ; ` : o/ ? as x = \Sigma fi(ff = o/ ) w ; r} \Sigma 

fi(ff = o/ ) {rv [fi  ff] ; ` : o/ ? [fi  ff] as x = w ; r [fi  ff]}

if ff /2 ftv(rv) [ ftv(r) (S

IGMA-RECORD)

openfl (\Sigma fi(ff = o/ ) w)  \Sigma fi(ff = o/) (openfl w) if fl /2 {ff, fi} (SIGMA-OPEN)9(
fl = o/ 0) (\Sigma fi(ff = o/ ) w)  \Sigma fi(ff = o/ [fl  o/ 0]) (9(fl = o/ 0 [fi  ff]) w) if fl /2 {ff, fi} (SIGMA-EXISTS)

*fl. \Sigma fi(ff = o/ ) w  \Sigma fi(ff = o/ ) (*fl. w) if fl /2 {ff, fi} [ ftv(o/ ) (SIGMA-NU)(\Sigma 

fi(ff = o/ ) w : o/0)  \Sigma fi(ff = o/ ) (w : o/0 [fi  ff]) if ff /2 ftv(o/ 0) (SIGMA-COERCE)

(u : o/1 ! o/2) v  (u v : o/2) (COERCE-APP)(
u : 8ff. o/ 0) [o/]  (u [o/ ] : o/0 [ff  o/]) (COERCE-INST)(
u : {(`i : o/i)i21..n}).`k  (u.`k : o/k) if 1 <= k <= n (COERCE-PROJ)open

ff (u : 9ff. o/ )  (openff u : o/ ) (COERCE-OPEN)

((u : o/ ) : o/ 0)  (u : o/ 0) (COERCE-COERCE)
*fi. \Sigma fi(ff = o/) v  *fi. \Sigma fi(ff = o/ ) v [ff  o/ ] if ff 2 ftv(v) (NU-SIGMA1)

*fi. \Sigma fi(ff = o/ ) v  v if ff /2 ftv(v) (NU-SIGMA2)

These rules are closed under evaluation context and transitivity.

Figure 15. Reduction rules.

Qff ::= openff M | Qff M | M Qff | Qff [o/ ] | pack ho/, Qffi as 9fi. o/ 0 | unpack Qff as fi, x in M| unpack

M as fi, x in Qff if fi 6= ff | *fi. Qff if fi 6= ff | openfi Qff if fi 6= ff | Qff.`| {
r ; ` as x = Qff ; r0} | let x = M in Qff | let x = Qff in M

*ff. openff M . unpack M as ff, x in x

*ff. Qff M . *ff. let x = Qff in x M
*ff. M Qff . *ff. let x = Qff in M x
*ff. Qff [o/ ] . *ff. let x = Qff in x [o/ ]
*ff. pack ho/, Qffi as 9fi. o/ 0 . *ff. let x = Qff in pack ho/, xi as 9fi. o/ 0
*ff. unpack Qff as fi, y in M . *ff. let x = Qff in unpack x as fi, y in M
*ff. unpack M as fi, x in Qff . unpack M [ff  {}] as fi, x in *ff. Qff

*ff. *fi. Qff . *fi. *ff. Qff if fi 6= ff
*ff. openfi Qff . openfi *ff. Qff if fi 6= ff

*ff. Qff.` . *ff. let x = Qff in x.`
*ff. {(`i as xi = Mi)i21..n ;

` as x = Qff ; r} . let

y = {(`i as xi = Mi)i21..n} [ff  {}] in
*ff. let z = Qff([xi  y.`i])i21..n in{(

`i as xi = y.`i)i21..n ; ` as x = z ; r}
*ff. let x = M in Qff . let x = M [ff  {}] in *ff. Qff
*ff. let x = openff M in M0 . unpack M as ff, x in M 0

*ff. let x = Qff M in M0 . *ff. let y = Qff in let x = y M in M0 if y /2 fv(M, M0)
*ff. let x = M Qff in M0 . *ff. let y = Qff in let x = M y in M0 if y /2 fv(M, M0)

*ff. let x = Qff [o/ ] in M . *ff. let y = Qff in let x = y [o/ ] in M if y /2 fv(M)
*ff. let x =pack h

o/, Qffi as 9fi. o/ 0 in M .

*ff. let y = Qff inlet

x = pack ho/, yi as 9fi. o/ 0 in M if

y /2 fv(M)

*ff. let x = unpack Qff as fi, y in Min

M0 .

*ff. let z = Qff inlet

x = unpack z as fi, y in Min
M0

if z /2 fv(M, M 0)

*ff. let x = unpack M as fi, y in Qffin

M0 . unpack

M [ff  {}] as fi, y in
*ff. let x = Qff in M0 if

x 6= y

*ff. let x = *fi. Qff in M . *fi. *ff. let x = Qff in M
*ff. let x = openfi Qff in M . *ff. let y = Qff in let x = openfi y in M if y /2 fv(M, M0)

*ff. let x = Qff.` in M . *ff. let y = Qff in let x = y.` in M if y /2 fv(M)
*ff. let x ={(

`i as xi = Mi)i21..n ;
` as y = Qff ; r} in

M .

let z1 = {(`i as xi = Mi)i21..n} [ff  {}] in
*ff. let z2 = Qff([xi  z1.`i])i21..n inlet

x = {(`i as xi = z1.`i)i21..n ; ` as y = z2 ; r} in M

if z1, z2 /2 fv(Qff, r, M)

*ff. let x = let y = M in Qff in M 0 . let x = M [ff  {}] in

*ff. let z = Qff in let x = let y = x in z in M0 if

z /2 fv(M0)

*ff. let x = let y = Qff in M in M 0 . *ff. let x = Qff in let x = let y = x in M in M0

Figure 16. From F. to F, second pass: recovering unpack's.

bxc , x b*(x : o/ ) Mc , *(x) bMc bM M0c , bMc bM 0c b\Lambda ff. Mc , bMc bM [o/]c , bMc

b{(`i : o/ ?i as xi = Mi)i21..n}c , {(`i as xi = bMic)i21..n} bM.`c , bMc.` b9(ff = o/ ) Mc , bMc

b(M : o/ )c , bM c bopenff Mc , bMc b*ff. Mc , bMc

Figure 17. Type-erasure.

WF-VAR\Gamma 

, ff 2 oe, \Gamma 0 ` wf \Gamma  ` oe :: ^

\Gamma , ff 2 oe, \Gamma 0 ` ff :: ^

WF-ARROW\Gamma  `

o/1 wf \Gamma  ` o/2 wf

\Gamma  ` o/1 ! o/2 :: ^1 ! ^2

WF-EMPTY\Gamma  ` wf

\Gamma  ` { } :: ?
WF-RECORD1 <=

n 8i 2 {1..n} , \Gamma  ` o/i wf8

i, j, i 6= j ) `i 6= `j

\Gamma  ` {(`i : o/i)i21..n} :: {(`i : ^i)i21..n}

WF-PROJ-LABEL\Gamma  `

o/ :: {(`i : ^i)i21..n} 1 <= k <= n

\Gamma  ` o/.`k :: ^k

WF-PROJ-ARROW\Gamma  `

o/ :: ^1 ! ^2

\Gamma  ` o/.i :: ^i

WF-FORALL\Gamma  `

oe :: ^ \Gamma , ff 2 oe ` o/ :: ^0

\Gamma  ` 8(ff 2 oe) o/ :: ?

WF-EXISTS\Gamma  `

oe :: ^ \Gamma , ff 2 oe ` o/ :: ^0

\Gamma  ` 9 (ff 2 oe) o/ :: ?

Figure 18. Wellformed types.

WF-TOP\Gamma  ` wf

\Gamma  ` ? :: ?

WF-SINGLE\Gamma  `

o/ :: ^

\Gamma  ` o/ :: ^

WF-SHAPE\Gamma  `

oe :: ^ \Gamma , ff 2 oe ` oe0 :: ^0

\Gamma  ` [ff 2 oe] oe0 :: ^0

Figure 19. Wellformed shapes.

WF-EMPTY

" ` wf

WF-QUANTIFIER\Gamma  ` wf

\Gamma  ` oe :: ^ ff /2 dom \Gamma 

\Gamma , ff 2 oe ` wf

WF-EQ \Gamma  ` wf

\Gamma  ` oe :: ^ \Gamma  ` o/ :: ^0\Gamma  `

o/ 2 oe ff /2 dom \Gamma 

\Gamma , ff 2 oe = o/ ` wf

WF-VAR \Gamma  ` wf

\Gamma  ` o/ :: ^ x /2 dom \Gamma 

\Gamma , x : o/ ` wf

Figure 20. Wellformed environments.

2-TOP\Gamma  `

o/ :: ^

\Gamma  ` o/ 2 ?

2-SINGLE\Gamma  `

o/ :: ^

\Gamma  ` o/ 2 o/

2-SHAPE\Gamma  `

o/ 2 oe \Gamma , ff 2 oe ` o/ 0 2 oe0

\Gamma  ` o/ 0 [ff  o/ ] 2 [ff 2 oe] oe0

2-EQUIV\Gamma  `

o/0 2 oe \Gamma  ` o/ j o/ 0

\Gamma  ` o/ 2 oe

2-FOLD

ff1 /2 ftv(oe2) ff2 /2 ftv(\Gamma 2, o/, oe)\Gamma 

1, ff2 2 oe2, ff1 2 oe1, \Gamma 2 ` o/ 2 oe
\Gamma 1, ff1 2 [ff2 2 oe2] oe1, \Gamma 2 ` o/ 2 oe

Figure 21. Shapes membership.

EQUI-VAR-SINGLE\Gamma  ` wf

ff 2 o/ 2 \Gamma 

\Gamma  ` ff j o/

EQUI-RECORD8

i 2 {1..n} , \Gamma  ` o/i j o/ 0i

\Gamma  ` {(`i : o/i)}i21..n j {(`i : o/ 0i )}i21..n

EQUI-PROJ-LABEL

\Gamma  ` o/ j {(`i : o/i)i21..n}

\Gamma  ` o/.k j o/k

EQUI-PROJ-ARROW\Gamma  `

o/ j o/1 ! o/2

\Gamma  ` o/.i j o/i

EQUI-FORALL\Gamma  `

oe j oe0 \Gamma , ff :: ^ 2 oe ` o/ j o/ 0

\Gamma  ` 8(ff 2 oe) o/ j 8(ff 2 oe0) o/0

EQUI-EXISTS\Gamma  `

oe j oe0 \Gamma , ff :: ^ 2 oe ` o/ j o/ 0

\Gamma  ` 9 (ff 2 oe) o/ j 9 (ff 2 oe0) o/ 0

EQUI-FOLD

ff1 /2 ftv(oe2) ff2 /2 ftv(\Gamma 2, o/, o/ 0)\Gamma 

1, ff2 2 oe2, ff1 2 oe1, \Gamma 2 ` o/ j o/ 0
\Gamma 1, ff1 2 [ff2 2 oe2] oe1, \Gamma 2 ` o/ j o/ 0

EQUI-REFL\Gamma  `

o/ :: ^

\Gamma  ` o/ j o/

EQUI-SYM\Gamma  `

o/2 j o/1

\Gamma  ` o/1 j o/2

EQUI-TRANS\Gamma  `

o/1 j o/2 \Gamma  ` o/2 j o/3

\Gamma  ` o/1 j o/3

Figure 22. Equivalent types.

\Gamma  ` oe1 v oe2 \Gamma  ` oe2 v oe1

\Gamma  ` oe1 j oe2

\Gamma , ff 2 oe ` ff 2 oe0

\Gamma  ` oe v oe0

Figure 23. Equivalent shapes.

VAR\Gamma  ` wf \Gamma  pure

\Gamma  ` x : \Gamma  (x)

LAM\Gamma 

, x : o/1 ` M : o/2 \Gamma  pure

\Gamma  ` *(x : o/1) M : o/1 ! o/2

APP\Gamma 

1 ` M1 : o/2 ! o/ \Gamma 2 ` M2 : o/2

\Gamma 1 . \Gamma 2 ` M1 M2 : o/

GEN\Gamma 

, 8 (ff 2 oe) ` M : o/ \Gamma  pure

\Gamma  ` \Lambda (ff 2 oe) M : 8(ff 2 oe) o/

INST\Gamma  `

M : 8(ff 2 oe) o/ 0 \Gamma  ` o/ :: ^ \Gamma  ` o/ 2 oe

\Gamma  ` M [o/ ] : o/ 0 [ff  o/ ]

RECORD-EMPTY\Gamma  ` wf \Gamma  pure

\Gamma  ` {} : {}
RECORD-VAL1 8

i 2 {1, . . . , n} , ` 6= `0i

\Gamma  ` M : o/ \Gamma 0, x : o/ ` {r} : {(`0i : o/ 0i )i21..n}

\Gamma  . \Gamma 0 ` {` as x = M ; r} : {` : o/ ; (`0i : o/ 0i )i21..n}

RECORD-VAL28

i 2 {1, . . . , n} , ` 6= `0i \Gamma  ` M : o/0

\Gamma  ` o/0 ss o/ \Gamma 0, x : o/0 ` {r} : {(`0i : o/0i )i21..n}

\Gamma  . \Gamma 0 ` {` : o/ as x = M ; r} : {` : o/ ; (`0i : o/ 0i )i21..n}

PROJ\Gamma  `

M : {(`i : o/i)i21..n} 1 <= k <= n

\Gamma  ` M.`k : o/k

EXISTS\Gamma 

, ff 2 oe = o/ 0 ` M : o/

\Gamma  ` 9(ff 2 oe = o/0) M : 9 (ff 2 oe) o/

COERCE\Gamma  `

M : o/ 0 \Gamma  ` o/ 0 ss o/

\Gamma  ` (M : o/ ) : o/

OPEN\Gamma  `

M : 9 (ff 2 oe) o/ ff /2 dom \Gamma 

\Gamma , 9 (ff 2 oe) ` openff M : o/

NU\Gamma 

, 9 (ff 2 oe) ` M : o/ ff /2 ftv(o/ )

\Gamma  ` * (ff 2 oe) M : o/

SHIFT\Gamma 0 `

M : o/ \Gamma  fl \Gamma 0

\Gamma  ` M : o/

EQUIV\Gamma  `

M : o/ \Gamma  ` o/ j o/ 0

\Gamma  ` M : o/ 0

Figure 24. F. with paths: all typing rules. Differences with F. appear in a gray shade.