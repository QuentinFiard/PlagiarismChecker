

On the Theory of Structural Subtyping

Viktor Kuncak and Martin Rinard

Laboratory for Computer Science
Massachusetts Institute of Technology

Cambridge, MA 02139, USA
fvkuncak, rinardg@lcs.mit.edu

MIT-LCS-TR-879, January 2003

Abstract
We show that the first-order theory of structural subtyping
of non-recursive types is decidable.

Let \Sigma  be a language consisting of function symbols (representing type constructors) and C a decidable structure in
the relational language L containing a binary relation ^. C
represents primitive types; ^ represents a subtype ordering.
We introduce the notion of \Sigma -term-power of C, which generalizes the structure arising in structural subtyping. The
domain of the \Sigma -term-power of C is the set of \Sigma -terms over
the set of elements of C.

We show that the decidability of the first-order theory of
C implies the decidability of the first-order theory of the \Sigma -
term-power of C. This result implies the decidability of the
first-order theory of structural subtyping of non-recursive
types.

Our decision procedure is based on quantifier elimination
and makes use of quantifier elimination for term algebras
and Feferman-Vaught construction for products of decidable
structures.

We also explore connections between the theory of structural subtyping of recursive types and monadic second-order
theory of tree-like structures. In particular, we give an embedding of the monadic second-order theory of infinite binary tree into the first-order theory of structural subtyping
of recursive types.

Keywords: Structural Subtyping, Quantifier Elimination, Term Algebra, Decision Problem, Monadic SecondOrder Logic

\Lambda 

This research was supported in part by DARPA Contract F33615-

00-C-1692, NSF Grant CCR00-86154, NSF Grant CCR00-63513, and
the Singapore-MIT Alliance.

y

Draft of January 25, 2003, 10:54am,

see http://www.mit.edu/~vkuncak/papers for later versions.

Contents
1 Introduction 2
2 Preliminaries 2

2.1 Term Algebra . . . . . . . . . . . . . . . . . . 3
2.2 Terms as Trees . . . . . . . . . . . . . . . . . 3
2.3 First Order Structures with Partial Functions 3

3 Some Quantifier Elimination Procedures 6

3.1 Quantifier Elimination . . . . . . . . . . . . . 6
3.2 Quantifier Elimination for Boolean Algebras . 7
3.3 Feferman-Vaught Theorem . . . . . . . . . . . 8
3.4 Term Algebras . . . . . . . . . . . . . . . . . 11

3.4.1 Term Algebra in Selector Language . . 11
3.4.2 Quantifier Elimination . . . . . . . . . 12

4 The Pair Constructor and Two Constants 16

4.1 Boolean Algebras on Equivalent Terms . . . . 16
4.2 A Multisorted Logic . . . . . . . . . . . . . . 17
4.3 Quantifier Elimination for Two Constants . . 18

5 A Finite Number of Constants 25

5.1 Extended Term-Power Structure . . . . . . . 26
5.2 Structural Base Formulas . . . . . . . . . . . 27
5.3 Conversion to Base Formulas . . . . . . . . . 27
5.4 Conversion to Quantifier-Free Formulas . . . 28
5.5 One-Relation-Symbol Variance . . . . . . . . 29

6 Term-Powers of Decidable Theories 31

6.1 Product Theory of Terms of a Given Shape . 31
6.2 A Logic for Term-Power Algebras . . . . . . . 32
6.3 Some Properties of Term-Power Structure . . 32
6.4 Quantifier Elimination . . . . . . . . . . . . . 37
6.5 Handling Contravariant Constructors . . . . . 43
6.6 A Note on Element Selection . . . . . . . . . 44

7 Some Connections with MSOL 44

7.1 Structural Subtyping Recursive Types . . . . 45
7.2 A Decidable Substructure . . . . . . . . . . . 46
7.3 Embedding Terms into Terms . . . . . . . . . 47
7.4 Subtyping Trees of Known Shape . . . . . . . 47
7.5 Recursive Feature Trees . . . . . . . . . . . . 47
7.6 Reversed Binary Tree with Prefix-Closed Sets 48

8 Conclusion 48

1

1 Introduction
Subtyping constraints are an important technique for checking and inferring program properties, used both in type systems and program analyses [34, 16, 13, 28, 23, 4, 3, 1, 2, 20,
41, 17, 54, 7, 8, 5, 42, 47, 19].

This paper presents a decision procedure for the firstorder theory of structural subtyping of non-recursive types.
This result solves (for the case of non-recursive types) a
problem left open in [48]. [48] provides the decidability result for structural subtyping of only unary type constructors,
whereas we solve the problem for any number of constructors
of any arity. Furthermore, we do not impose any constraints
on the subtyping relation ^, it need not even be a partial order. The generality of our construction makes it potentially
of independent interest in logic and model theory.

We approach the problem of structural subtyping using
quantifier elimination and, to some extent, using monadic
second-order logic of tree-like structures. This paper makes
the contributions:

ffl we give a new presentation of Feferman-Vaught theorem for direct products using a multisorted logic (Section 3.3); for completeness we also include proof of
quantifier-elimination for boolean algebras of sets (Section 3.2);

ffl we give a new presentation of decidability of the firstorder theory of term algebras; the proof uses the language of both constructor and selector symbols (Section 3.4);

ffl as an introduction to main result, we show decidability

of structural subtyping with one covariant binary constructor and two constants (Section 4), this result does
not rely on Feferman-Vaught technique;

ffl we present a new construction, term-power algebra for

creating tree-like theories based on existing theories
(Section 5);

ffl as a central result, we prove that if the base theory

is decidable, so is the theory of term-power with arbitrary variance of constructors; we give an effective
decision procedure for quantifier elimination in termpower structure; the procedure combines elements of
quantifier elimination in Feferman-Vaught theorem and
quantifier elimination in term algebras (Sections 5, 6).

ffl we show the decidability of structural subtyping nonrecursive types as a direct consequence of the main result;

ffl we give a simple embedding of monadic second-order

theory of infinite binary tree into the theory of structural subtyping of recursive types with two primitive
types (Section 7.1);

ffl we show that structural subtyping of recursive types

where terms range over constant shapes is decidable
(Section 7.4);

In addition to showing the decidability of structural subtyping, our hope is to promote the important technique of
quantifier elimination, which forms the basis of our result.

Quantifier elimination [22, Section 2.7] is a fruitful technique that was used to show decidability and classification
of boolean algebras [46, 51] decidability of term algebras

[31, Chapter 23], [39, 30], with membership constraints [10]
and with queues [43], decidability of products [35, 14], [31,
Chapter 12], and algebraically closed fields [50],

The complexity of the decision problem for the first-order
theory of structural subtyping has a non-elementary lower
bound. This is a consequence of a general theorem about
pairing functions [15, Theorem 1.2, Page 163] and applies to
term algebras already, as observed in [39, 43].

2 Preliminaries
In this section we review some notions used in the this paper.

If w is a word over some alphabet, we write jwj for the
length of w. We write w1 \Delta  w2 to denote the concatenation
of words w1 and w2.

A node v in a directed graph is a sink if v has no outgoing
edges. A node v in a directed graph is a source if v has no
incoming edges.

We write E1 j E2 to denote equality of syntactic entities
E1 and E2.

We write _x to denote some sequence of variables
x1; : : : ; xn.

We assume that formulas are built from propositional
connectives ^, ., :, the remaining connectives are defined
as shorthands. Connective : binds the strongest, followed
by ^ and ..

A literal L is an atomic formula A or a negation of an
atomic formula :A. We define complementation of a literal
by A = :A and :A = A.

A formula  is in prenex form if it is of the form

Q1x1: : : : Qnxn:OE
where Qi 2 f8; 9g for 1 ^ i ^ n and OE is a quantifier free
formula. We call OE a matrix of .

If OE is a formula then FV(OE) denotes the set of free variables in OE.

We write [x1 7! a1; : : : ; xk 7! ak] for the substitution oe
such that oe(xi) = ai for 1 ^ i ^ k.

If OE is a formula and t1; : : : ; tk terms, we write OE[x1 :=
t1; : : : ; xk := tk] for the result of simultaneously substituting
free occurrences of variables xi with term ti, for 1 ^ i ^ k.

We write h(t) for the height of term t. h(a) = 0 if a is
a constant, h(x) = 0 if x is a variable. If f(t1; : : : ; tk) is a
term then

h(f(t1; : : : ; tk)) = 1 + max(h(t1); : : : ; h(tk))
We assume that all function symbols are of finite arity. If
there are finitely many function symbols then for any nonnegative integer k there is only a finite number of terms t
such that h(t) ^ k.

If OE(u) is a conjunction of literals, we say that OE

0

results

from 9u:OE(u) by dropping quantified variable u iff OE

0

is the

result of eliminating from OE(u) all conjunctions containing
u. More generally, if  is a formula of form

Q1x1 : : : Qu : : : Qkxk: 0
then the result of dropping u from  is

Q1x1 : : : Qkxk: 

0

0

where 

0

0

is the result of dropping u from 9u:OE0.

An equality is an atomic formula t1 = t2 where t1 and t2
are terms. A disequality is negation of an equality.

2

We use the usual Tarskian semantics of formulas. Unless
otherwise stated OE j=  will denote that formula OE ) 
is true in a fixed relational structure that is under current
consideration.

Occasionally we find it convenient to work with multisorted logic, where domain is union of disjoint sets called
sorts, and arity specifies the sorts of all operations. Constants are operations with zero arguments. Relations are
operations that return the result in a distinguished sort bool
interpreted over the boolean lattice ffalse; trueg or over the
distributive lattice of three-valued logic ffalse; true; undefg
from Section 2.3).

A structure C of a given language L is a pair of domain
C and the interpretation function J K

C

. Hence, we name operations of the structure using symbols of the language and
the interpretation function. If C is clear from the context
we write simply J K for J K

C

.

In Section 3.3 and Section 6 we use logic with several
kinds of quantifiers. Our logic is first-order, but we give
higher-order types to quantifiers. For example, a quantifier

Q :: (A ! B) ! B
denotes a quantifier that binds variables of A sort enclosed
within an expression of B sort and returns an expression of
B sort. If X and Y are sets then X ! Y denotes the set of
all functions from A to B. When specifying the semantics
of the quantifier Q we specify a function

JQK : (JAK ! JBK) ! JBK
The semantics of an expression M of sort B takes an environment oe which is a function from variable names to elements
of A and produces an element of B, hence JMKoe 2 JBK. We
define the semantics of an expression Qx: M by:

JQx: MKoe = JQKh
where h : JAK ! JBK is the function

h(a) = JMK(oe[x := a])
Here

oe[x := a](y) =

(

oe(y); if y 6j x

a; if y j x
Specifying types for quantifiers allows to express more

Let oeA be some arbitrary dummy global environment. If
F is a formula without global variables we write JF KoeA to
denote the truth value of F ; clearly JF KoeA does not depend
on oeA and we denote it simply JF K when no ambiguity arises.

We use Hilbert's epsilon as a notational convenience in
metatheory. If P (x) is a unary predicate, then "x:P (x) denotes an arbitrary element d such that P (d) holds, if such
element exists, or an arbitrary object otherwise.

2.1 Term Algebra
We introduce the notion of term algebra [22, Page 14].

Let Nat be the set of natural numbers. Let the signature
\Sigma  be a finite set of function symbols and constants and let
ar : \Sigma  ! Nat be a function specifying arity ar(f) for every
function symbol or constant f 2 \Sigma . Let FT(\Sigma ) denote the
set of finite ground terms over signature \Sigma . We assume that
\Sigma  contains at least one constant c 2 \Sigma , ar(c) = 0, and at
least one function symbol f 2 \Sigma , ar(f) ? 0. Therefore,
FT(\Sigma ) is countably infinite.

Let Cons(\Sigma ) be the term algebra interpretation of signature \Sigma , defined as follows [22, Page 14]. For every f 2 \Sigma  with

ar(f) = k define JfK 2 Cons(\Sigma ), with JfK : FT(\Sigma )

k

! FT(\Sigma )

by

JfK(t1; : : : ; tk) = f(t1; : : : ; tk)

We will write f instead of JfK when it causes no confusion.

2.2 Terms as Trees
We define trees representing terms as follows.

We use sequences of nonegative integers to denote paths
in the tree. Let \Sigma  be a signature. A tree over \Sigma  is a partial
function t from the set Nat

\Lambda 

of paths to the set \Sigma  of function

symbols such that:

1. if w 2 Nat

\Lambda 

, x 2 Nat, and t(w \Delta  x) is defined, then t(w)

is defined as well;

2. if t(w) = f with ar(f) = k, then

fi j t(w \Delta  i) is defined g = f1; : : : ; kg

A finite tree is a tree with a finite domain.
2.3 First Order Structures with Partial Functions
We make use of partial functions in our quantifier elimination procedures. In this section we briefly describe the approach to partial functions we chose to use; other approaches
would work as well, see e.g. [24].

A language of partial functions \Sigma 1 contains partial function symbols in addition to total function symbols and relation symbols. Consider a structure with the domain A interpreting a language with partial function symbols \Sigma 1. Given
some environment oe, we have JtKoe 2 A [ f?g where ? =2 A
is a special value denoting undefined results. We require the
interpretations of total and partial function symbols to be
strict in ?, i.e. f(a1; : : : ; ai; ?; ai+2; : : : ; ak) = ?.

We interpret atomic formulas and their negations over
the three-valued domain ffalse; true; undefg using strong
Kleene's three-valued logic [26, 24, 44]. We require that
JRK(a1; : : : ; ai; ?; ai+2; : : : ; ak) = undef for every relational
symbol R. Logical connectives in Kleene's strong threevalued logic are the strongest "regular" extension of the corresponding connectives on the two-valued domain [26]. The
regularity requirement means that the three-valued logic is
a sound approximation of two-valued logic in the following
sense. We may obtain the truth tables for three-valued logic
by considering the truth values false; true; undef as shorthands for sets ffalseg; ftrueg; ffalse; trueg and defining each
logical operation \Lambda  by:

s1 J\Lambda K s2 = fb1 ffi b2 j b1 2 s1 ^ b2 2 s2g
where ffi denotes the corresponding operation in the twovalued logic. As in a call-by-value semantics of lambda calculus, variables in the environments (oe) do not range over
?. We interpret quantifiers as ranging over the domain A
or its subset if the logic is multisorted; the interpretation of
quantifiers are similarly the best regular approximations of
the corresponding two-valued interpretations.

These properties of Kleene's three-valued logic have the
following important consequence. Suppose that we extend
the definition of all partial functions to make them total
functions on the domain A by assigning arbitrary values outside the original domain. Suppose that a formula OE evaluates

3

to an element of b 2 ffalse; trueg in Kleene's logic. Then OE
evaluates to the same truth-value b in the new logic of total
functions. This property of three-valued logic implies that
the algorithms that we use to transform formulas with partial functions will apply even for the logic that makes all
functions total by completing them with arbitrary elements
of A.

We say that a formula  is well-defined iff its truth value
is an element of ffalse; trueg.

Example 1 Consider the domain of real numbers. The following formulas are not well-defined:

3 = 1=0
8x: 1=x ? 0 . 1=x ! 0 . 1=x = 0

The following formulas are well-defined:

9x: 1=x = 3
8x: 1=x 6= 3
x = 0 . 1=x ? 0

\Upsilon 

We say that a formula OE1 is equivalent to a formula OE2
and write OE1

,

= OE2 iff

JOE1Koe = JOE2Koe
for all valuations oe (including those for which JOE1Koe =
undef).

Sections below perform equivalence-preserving transformations of formulas. This means that starting from a welldefined formula we obtain an equivalent well-defined formula.

When doing equivalence preserving transformations it is
useful to observe that ^; . still form a distributive lattice.
The partial order of this lattice is the chain false ^ undef ^
true. The element undef does not have a complement in
the lattice; unary operation : does not denote the lattice
complement. However, the following laws still hold:

:(x ^ y)

,

= :x . :y

:(x . y)

,

= :x ^ :y

::x

,

= x

The properties of ^; .; : are sufficient to transform any
quantifier-free formula into disjunction of conjunctions of literals using the well-known straightforward technique. However, this straightforward technique in some cases yields conjunctions that are not well-defined, even though the formula
as a whole is well-defined.

Example 2 Transforming a negation of well-defined formula:

:(x 6= 0 ^ (y = 1=x . z = x + 1))

may yield the following disjunction of conjunctions:

x = 0 . (y 6= 1=x ^ z 6= x + 1)
where y 6= 1=x ^ z 6= x + 1 is not a well-defined conjunction
for x = 0.

\Upsilon 

To enable the transformation of each well-defined formula into a disjunction of well-defined conjunctions of literals, we enrich the language of function and relation symbols
as follows. With each partial function symbol f 2 \Sigma 1 of
arity k = ar(f) we associate a domain description Df =
hhx1; : : : ; xki; OEi specifying the domain of f. Here x1; : : : ; xk
are distinct variables and OE is an unnested conjunction of
literals such that FV(OE) ` fx1; : : : ; xkg. We require every
interpretation of a first-order structure with partial function
symbols to satisfy the following property:

JfK(a1; : : : ; ak) 6= ? () JOEK[x1 7! a1; : : : ; xk 7! ak]
for all a1; : : : ; ak 2 A. We henceforth assume that every
structure with partial functions is equipped with a domain
description Df for every partial function symbol f.

The Proposition 8 below gives an algorithm for transforming a given well-defined formula into a disjunction of
well-defined conjunctions. We first give some definitions and
lemmas.

Definition 3 If  is a formula with free variables, a domain formula for  is a formula OE not containing partial
function symbols such that, for every valuation oe,

JKoe 6= undef () JOEKoe = true
From Definition 3 we obtain the following Lemma 4.
Lemma 4 Let  be a formula and OE a domain formula for
. Then



,

= ( ^ OE) . (undef ^ :OE)

Proof. Let oe be arbitrary valuation. Let v = JKoe. If
v 2 ftrue; falseg then JOEKoe = true and

J( ^ OE) . (undef ^ :OE)Koe =

(v ^ true) . (undef ^ false) = v:

If v = undef then JOEK = false, so

J( ^ OE) . (undef ^ :OE)Koe =

(undef ^ false) . (undef ^ true) = undef:

Observe that  ^OE in Lemma 4 is a well-defined conjunction. We use this property to construct domain formulas
using partial function domain descriptions.

Let

Df = hhx1; : : : ; xki; B

f

1

^ : : : ^ B

f

l

f

i

for each partial function symbol f 2 \Sigma 1 of arity k, where
B

f

1

; : : : ; B

f

l

f

are unnested literals. If t1; : : : ; tk are terms,

we write B

f

i

(t1; : : : ; tk) for B

f

i

[x1 := t1; : : : ; xk := tk]. Let

subt(t) denote the set of all subterms of term t.

For any literal B(t1; : : : ; tn) where B(t1; : : : ; tn) j
R(t1; : : : ; tn) or B(t1; : : : ; tn) j :R(t1; : : : ; tn), define

DomForm(B(t1; : : : ; tn)) =

V

f(s1;:::;s

k

)2[

1^i^n

subt(t

i

)

1^j^l

f

B

f

j

(s1; : : : ; sk)

(1)

4

Lemma 5 Let B(t1; : : : ; tn) be a literal containing partial
function symbols. Then DomForm(B(t1; : : : ; tn)) is a domain formula for B(t1; : : : ; tn).

Proof. Let oe be a valuation. By strictness of interpretations
of function and predicate symbols, JB(t1; : : : ; tn)Koe 6= undef
iff Jf(s1; : : : ; sk)Koe 6= ? for every subterm f(s1; : : : ; sk) of

every term ti, iff JB

f

j

(s1; : : : ; sk)Koe = true for every 1 ^ j ^

l

f

and every subterm f(s1; : : : ; sk).

Lemma 6 Let B be a literal and let

DomForm(B) = F1 ^ : : : ^ Fm:
Then

B

,

= (B ^ F1 ^ : : : ^ Fm) .

W

1^i^m

(undef ^ :Fi ^ DomForm(Fi))

Proof. If JBKoe 6= undef, then JFiKoe = true for every
1 ^ i ^ m, and

Jundef ^ :Fi ^ DomForm(Fi)Koe = false
so the right-hand side evaluates to JBKoe as well. Now
consider the case when JBKoe = undef. Then there exists
a term f(s1; : : : ; sk) such that Jf(s1; : : : ; sk)Koe = undef.
Because oe(x) 6= ? for every variable x, there exists a
term f(s1; : : : ; sk) such that Jf(s1; : : : ; sk)Koe = undef and
JsiKoe 6= undef for 1 ^ i ^ k. Then there exists a formula Fp

of form B

f

j

(s1; : : : ; sk) such that JB

f

j

(s1; : : : ; sk)Koe = false,

and

Jundef ^ :Fp ^ DomForm(Fp)Koe = undef:

Because

JB ^ F1 ^ : : : ^ FmKoe = false;

and for every q,

Jundef ^ :Fq ^ DomForm(Fq)Koe 2 fundef; falseg;
the right-hand side evaluates to undef.

Lemma 7 Let OE0(_y) and OE1(_y) be well-defined formulas
whose free variables are among _y and let

(_y) j (undef ^ OE0(_y)) . OE1(_y)
If (_y) is well-defined for all values of variables _y, then

(_y)

,

= OE1(_y)

Proof. Consider any valuation oe. Let

v = JOE1(_y)Koe
and

v

0

= J(_y)Koe

We need to show v = v

0

. Because OE(_y) and (_y) are welldefined, v; v

0

2 ffalse; trueg. We consider two cases.

Case 1. v = true. Then also v

0

= true.

Case 2. v = false. Then v

0

= undef ^ OE0(_y). Because

v

0

6= undef, we conclude v

0

= false.

Proposition 8 Every well-defined quantifier-free formula
 can be transformed into an equivalent disjunction 

0

of

well-defined conjunctions of literals.

Proof. Using the standard procedure, convert  to disjunction of conjunctions

C1 . : : : . Cn
Let Ci = B ^ C

0

i

where B is a literal and let DomForm(B) =

F1 ^ : : : ^ Fm. Replace B ^ C

0

i

by

(B ^ F1 ^ : : : ^ Fm ^ C

0

i

) .

W

1^i^m

(undef ^ :Fi ^ DomForm(Fi) ^ C

0

i

)

By Lemma 6 and distributivity, the result is an equivalent
formula. Repeat this process for every literal in C1.: : :.Cn.
The result can be written in the form

(undef ^ OE1) . : : : . (undef ^ OEp) . OEp+1 . : : : . OEp+q (2)
where each OEi for 1 ^ i ^ p+q is a well-defined conjunction.
Formula (2) is equivalent to

(undef ^ (OE1 . : : : . OEp)) . OEp+1 . : : : . OEp+q (3)
and is equivalent to the well-defined formula , so it is welldefined. Formulas OE1 . : : : . OEp and OEp+1 . : : : . OEp+q are
also well-defined. By Lemma 7, we conclude that formula
(3) is equivalent to

OEp+1 . : : : . OEp+q (4)
Because (4) is a disjunction of well-defined formulas, (4) is
the desired result 

0

.

The following proposition presents transformation to
unnested form for the structures with equality and partial
function symbols, building on Proposition 8. For a similar
unnested form in the first-order logic containing only total
function symbols, see [22, Page 58].

Proposition 9 Every well-defined quantifier-free formula
 in a language with equality can be effectively transformed
into an equivalent formula 

0

where 

0

is a disjunction of

existentially quantified well-defined conjunctions of the following kinds of literals:

ffl R(x1; : : : ; xk) where R is some relational symbol of arity k and x1; : : : ; xk are variables;

ffl :R(x1; : : : ; xk) where R is some relational symbol of

arity k and x1; : : : ; xk are variables;

ffl x1 = x2 where x1; x2 are variables;
ffl x = f(x1; : : : ; xk) where f is some partial or total function symbol of arity k and x; x1; : : : ; xk are variables;

ffl x1 6= x2 where x1 and x2 are variables.
Proof. Transform the formula to disjunction of well-formed
conjunctions of literals as in the proof of Proposition 8.

Then repeatedly perform the following transformation
on each well-defined conjunction OE. Let A(f(x1; : : : ; xk)) be
an atomic formula containing term f(x1; : : : ; xk). Replace
OE ^ A(f(x1; : : : ; xk)) with

9x0: OE ^ x0 = f(x1; : : : ; xk) ^ A(x0)

5

Replace x 6= f(x1; : : : ; xk) with

x0 = f(x1; : : : ; xk) ^ x0 6= x
Repeat this process until the resulting conjunction OE

0

is in

unnested form. OE

0

is clearly equivalent to the original conjunction OE when all partial functions are well-defined. When
some partial function is not well-defined, then both OE and OE

0

evaluate to false, because by construction of OE in the proof
of Proposition 8, each conjunction contains conjuncts that
evaluate to false when some application of a function symbol
is not well-defined.

Let a left-strict conjunction in Kleene logic be denoted
by ^

0

and defined by

p ^

0

q = (p ^ q) . (p ^ :p)

The correctness of the transformation to unnested form
in Proposition 9 relies on the presence of conjuncts that ensure that the entire conjunction evaluates to false whenever
some term is undefined. The following Lemma 10 enables
transformation to unnested form in an arbitrary context, allowing the transformation to unnested form to be performed
independently from ensuring well-definedness of conjuncts.

Lemma 10 Let OE(x) be a formula with free variable x and
let t be a term possibly containing partial function symbols.
Then

1. OE(t)

,
= (9x: x = t ^ OE(x)) . (undef ^ 8x::OE(x)) ;

2. OE(t)

,

= 9x: x = t ^

0

OE(x) ;

3. OE(t)

,
= (9x: x = t ^ OE(x)) . (t 6= t) .

Proof. Straightforward.

Proposition 13 below shows that a simplification similar
to one in Lemma 7 can be applied even within the scope
of quantifiers. To show Proposition 13 we first show two
lemmas.

Lemma 11 For all formulas OE0(x; _y) and OE1(x; _y),

9x: (undef ^ OE0(x; _y)) . OE1(x; _y)

,

=

(undef ^ 9x:OE0(x; _y)) . 9x:OE1(x; _y)

Proof. By distributivity of quantifiers and propositional
connectives in Kleene logic we have:

9x: (undef ^ OE0(x; _y)) . OE1(x; _y)

,

=

(9x:undef ^ OE0(x; _y)) . 9x:OE1(x; _y)

,

=

(undef ^ 9x:OE0(x; _y)) . 9x:OE1(x; _y)

Lemma 12 For all formulas OE0(x; _y) and OE1(x; _y),

8x: (undef ^ OE0(x; _y)) . OE1(x; _y)

,

=

(undef ^ 8x:OE0(x; _y) . OE1(x; _y)) . 8x:OE1(x; _y)

Proof. The following sequence of equivalences holds.

8x: (undef ^ OE0(x; _y)) . OE1(x; _y)

,

=

:9x::(undef ^ OE0(x; _y)) . OE1(x; _y)

,

=

:9x: (undef . :OE0(x; _y)) ^ :OE1(x; _y)

,

=

:9x: (undef ^ :OE1(x; _y)) . (:OE0(x; _y) ^ :OE1(x; _y))

,

=

: ((undef ^ 9x::OE1(x; _y)) . (9x: :OE0(x; _y) ^ :OE1(x; _y)))

,

=

(undef . 8x:OE1(x; _y)) . (8x: OE0(x; _y) . OE1(x; _y))

,

=

(undef ^ 8x:OE0(x; _y) . OE1(x; _y)) . 8x:OE1(x; _y)

Proposition 13 Let OE0(_x; _y) and OE1(_x; _y) be well-defined
formulas whose free variables are among _y and let

(_y) j Q1x1 : : : Qnxn: (undef ^ OE0(_x; _y)) . OE1(_x; _y)
where Q1; : : : ; Qn are quantifiers. If (_y) is well-defined for
all values of variables _y, then

(_y)

,

= Q1x1 : : : Qnxn: OE1(_x; _y)

Proof. Applying successively Lemmas 11 and 12 to quantifiers Qn; : : : ; Q1, we conclude

(_y)

,

= (undef ^ OE2(_y)) . Q1x1 : : : Qnxn: OE1(_x; _y)

for some formula OE2(_y). Then by Lemma 7,

(_y)

,

= Q1x1 : : : Qnxn: OE1(_x; _y):

3 Some Quantifier Elimination Procedures
As a preparation for the proof of the decidability of term
algebras of decidable theories, we present quantifier elimination procedures for some theories that are known to admit
quantifier elimination. We use the results and ideas from
this section to show the new results in Sections 4, 5, 6.

3.1 Quantifier Elimination
Our technique for showing decidability of structural subtyping of recursive types is based on quantifier elimination.
This section gives some general remarks on quantifier elimination.

We follow [22] in describing quantifier elimination procedures. According to [22, Page 70, Lemma 2.7.4] it suffices
to eliminate 9y from formulas of the form

9y:

^

0^i!n

i(_x; y) (5)

where _x is a tuple of variables and i(_x; y) is a literal whose
all variables are among _x; y. The reason why eliminating
formulas of the form (5) suffices is the following. Suppose
that the formula in prenex form and consider the innermost
quantifier of a formula. Let OE be the subformula containing
the quantifier and the subformula that is the scope of the
quantifier. If OE is of the form 8x: OE0 we may replace OE
with :9x::OE0. Hence, we may assume that OE is of the form

6

9x: OE1. We then transform OE1 into disjunctive normal form
and use the fact

9x: (OE2 . OE3) () (9x: OE2) . (9x: OE3) (6)
We conclude that elimination of quantifiers from formulas of
form (5) suffices to eliminate the innermost quantifier. By
repeatedly eliminating innermost quantifiers we can eliminate all quantifiers from a formula.

We may also assume that y occurs in every literal i,
otherwise we would place the literal outside the existential
quantifier using the fact

9y: (A ^ B) () (9y:A) ^ B
for y not occurring in B.

To eliminate variables we often use the following identity
of a theory with equality:

9x:x = t ^ OE(x) () OE(t) (7)
Section 2.3 presents analogous identities for partial functions.

Quantifier elimination procedures we give imply the decidability of the underlying theories. In this paper the interpretations of function and relation symbols on some domain
A are effectively computable functions and relations on A.
Therefore, the truth-value of every formula without variables is computable. The quantifier elimination procedures
we present are all effective. To determine the truth value of
a closed formula OE it therefore suffices to apply the quantifier elimination procedure to OE, yielding a quantifier free
formula , and then evaluate the truth value of .

3.2 Quantifier Elimination for Boolean Algebras
This section presents a quantifier elimination procedure for
finite boolean algebras. This result dates back at least to
[46], see also [51, 27, 32, 6, 49], [22, Section 2.7 Exercise 3].
Note that the operations union, intersection and complement are definable in the first-order language of the subset
relation. Therefore, quantifier elimination for the first-order
theory of the boolean algebra of sets is no harder than the
quantifier elimination for the first-order theory of the subset relation. However, the operations of boolean algebra are
useful in the process of quantifier elimination, so we give the
quantifier elimination procedure for the language containing
boolean algebra operations.

Instead of the first-order theory of the subtype relation
we could consider monadic second-order theory with no relation or function symbols. These two languages are equivalent because the first-order quantifiers can be eliminated
from monadic second-order theory using the subset relation
(see Section 7.1).

Finite boolean algebras are isomorphic to boolean algebras whose elements are all subsets of some finite set. We
therefore use the symbols for the set operations as the language of boolean algebras. t1 "t2, t1 [t2, t

c

1

, 0, 1, correspond

to set intersection, set union, set complement, empty set,
and full set, respectively. We write t1 ` t2 for t1 " t2 = t1,
we write t1 ae t2 for the conjunction t1 ` t2 ^ t1 6= t2.

For every nonnegative integer k we introduce formulas
jtj * k expressing that the set denoted by t has at least
k elements, and formulas jtj = k expressing that the set

denoted by t has exactly k elements. These properties are
first-order definable as follows.

jtj * 0 j true
jtj * k+1 j 9x: x ae t ^ jxj * k
jtj = k j jtj * k ^ :jtj * k+1

We call a language which contains terms jtj * k and jtj = k
the language of boolean algebras with finite cardinality constraints. Because finite cardinality constraints are first-order
definable, the language with finite cardinality constraints is
equally expressive as the language of boolean algebras.

Every inequality t1 ` t2 is equivalent to the equality
t1 " t2 = t1, and every equality t3 = t4 is equivalent to the
cardinality constraint

j(t3 " t

c

4

) [ (t4 " t

c

3

)j = 0

It is therefore sufficient to consider the first-order formulas
whose only atomic formulas are of the form jtj = 0. For
the purpose of quantifier elimination we will additionally
consider formulas that contain atomic formulas jtj=k for all
k * 1, as well as jtj*k for k * 0.

Note that we can eliminate negative literals as follows:

:jtj = k () jtj = 0 . \Delta  \Delta  \Delta  . jtj = k\Gamma 1 . jtj * k+1
:jtj * k () jtj = 0 . \Delta  \Delta  \Delta  . jtj = k\Gamma 1

(8)
Every formula in the language of boolean algebras can therefore be written in prenex normal form where the matrix of
the formulas is a disjunction of conjunctions of atomic formulas of the form jtj = k and jtj * k, with no negative
literals.

Note that if a term t contains at least one operation of
arity one or more, we may assume that the constants 0 and
1 do not appear in t, because 0 and 1 can be simplified away.
Furthermore, the expression j0j denotes the integer zero, so
all terms of form j0j = k or j0j * k evaluate to true or false.
We can therefore simplify every nontrivial term t so that
it either t contains no occurrences of constants 0 and 1, or
t j 1.

We next describe a quantifier elimination procedure for
finite boolean algebras.

We first transform the formula into prenex normal form
and then repeatedly eliminate the innermost quantifier. As
argued in Section 3.1, it suffices to show that we can eliminate an existential quantifier from any existentially quantified conjunction of literals. Consider therefore an arbitrary
existentially quantified conjunction of literals

9y:

^

1^i^n

i(_x; y)

where i is of the form jtj = k or of the form jtj * k. We
assume that y occurs in every formula i. It follows that no
i contains j0j or j1j.

Let x1; : : : ; xm; y be the set of variables occurring in formulas i for 1 ^ i ^ n.

First consider the more general case m * 1. Let for
i1; : : : ; im 2 f0; 1g,

ti

1:::im

= x

i1

1

" \Delta  \Delta  \Delta  " x

im

m

where t

0

= t and t

1

= t

c

. The terms in the set

P = fti

1:::im

j i1; : : : ; im 2 f0; 1gg

7

original formula eliminated form
9y: js " yj * k ^ js " y

c

j * l jsj * k + l

9y: js " yj = k ^ js " y

c

j * l jsj * k + l

9y: js " yj * k ^ js " y

c

j = l jsj * k + l

9y: js " yj = k ^ js " y

c

j = l jsj = k + l

Figure 1: Rules for Eliminating Quantifiers
form a partition; moreover every boolean algebra expression
whose variables are among xi can be written as a disjoint
union of some elements of the partition P . Any boolean
algebra expression containing y can be written, for some
p; q * 0 as

(s1 " y) [ \Delta  \Delta  \Delta  [ (sp " y)[

(t1 " y

c

) [ \Delta  \Delta  \Delta  [ (tq " y

c

)

where s1; : : : ; sp 2 P are pairwise distinct elements from the
partition and t1; : : : ; tq 2 P are pairwise distinct elements
from the partition. Because

j(s1 " y) [ \Delta  \Delta  \Delta  [ (sp " y) [ (t1 " y

c

) [ \Delta  \Delta  \Delta  [ (tq " y

c

)j =

js1 " yj + \Delta  \Delta  \Delta  + jsp " yj + jt1 " y

c

j + \Delta  \Delta  \Delta  + jtq " y

c

j

the constraint of form jtj = k can be written as

.

k1;:::;kp;l1;:::;lq

js1 " yj = k1 ^ \Delta  \Delta  \Delta  ^ jsp " yj = kp ^

jt1 " y

c

j = l1 ^ \Delta  \Delta  \Delta  ^ jtq " y

c

j = lp

where the disjunction ranges over nonnegative integers
k1; : : : ; kp; l1; : : : ; lq * 0 that satisfy

k1 + \Delta  \Delta  \Delta  + kp + l1 + \Delta  \Delta  \Delta  + lq = k
From (8) it follows that we can perform a similar transformation for constraints of form jtj * k. After performing this
transformation, we bring the formula into disjunctive normal form and continue eliminating the existential quantifier
separately for each disjunct, as argued in Section 3.1. We
may therefore assume that all conjuncts i are of one of the
forms: js " yj = k, js " y

c

j = k, js " yj * k, and js " y

c

j * k

where s 2 P .

If there are two conjuncts both of which contain js"yj for
the same s, then either they are contradictory or one implies
the other. We therefore assume that for any s 2 P , there is
at most one conjunct i containing js " yj. For analogous
reasons we assume that for every s 2 P there is at most one
conjunct i containing js " y

c

j. The result of eliminating

the variable y is then given in Figure 1. The case when a
literal containing js " yj does not occur is covered by the
case js " yj * k for k = 0, similarly for a literal containing
js " y

c

j.

It remains to consider the case m = 0. Then y is the
only variable occurring in conjuncts i. Every cardinality
expression t containing only y reduces to one of jyj or jy

c

j.

If there are multiple literals containing jyj, they are either
contradictory or one implies the others. We may therefore
assume there is at most one literal containing jyj and at
most one literal containing jy

c

j. We eliminate quantifier by

applying rules in Figure 1 putting formally s = 1 where 1 is
the universal set.

This completes the description of quantifier elimination
from an existentially quantified conjunction. By repeating
this process for all quantifiers we arrive at a quantifier-free
formula . Hence we have the following theorem.

Theorem 14 For every first-order formula OE in the language of boolean algebras with finite cardinality constraints
there exists a quantifier-free formula  such that  is a disjunction of conjunctions of literals of form jtj * k and jtj = k
where t are terms of boolean algebra, the free variables of 
are a subset of the free variables of OE, and  is equivalent to
OE on all algebras of finite sets.

Remark 15 Now consider the case when formula OE has no
free variables. By Theorem 14, OE is equivalent to  where 
contains only terms without variables. A term without variables in boolean algebra can always be simplified to 0 or 1.
Because j0j = 0, the literals with j0j reduce to true or false,
so we may simplify them away. The expression j1j evaluates
to the number of elements in the boolean algebra. We call
literals j1j = k and j1j * k domain cardinality constraints. A
quantifier-free formula  can therefore be written as a propositional combination of domain cardinality constraints. We
can simplify  into a disjunction of conjunctions of domain
cardinality constraints and transform each conjunction so
that it contains at most one literal. The result 

0

is a single disjunction of domain cardinality constraints. We may
further assume that the disjunct of form j1j * k occurs at
most once. Therefore, the truth value of each closed boolean
algebra formula is characterized by a set C of possible cardinalities of the domain. If 

0

does not contain any j1j * k literals, the set C is finite. Otherwise, C = C0 [ fk; k + 1; : : :g
for some k where C0 is a finite subset of f1; : : : ; k \Gamma  1g.

3.3 Feferman-Vaught Theorem

The Feferman-Vaught technique is a way of
discovering the first-order theories of complex structures by analyzing their components.
This description is a little vague, and in
fact the Feferman-Vaught technique itself has
something of a floating identity. It works
for direct products, as we shall see. Clever
people can make it work in other situations too.
-- [22], page 458

We next review Feferman-Vaught theorem for direct
products [14] which implies that the products of structures
with decidable first-order theories have decidable first-order
theories.

The result was first obtained for strong and weak powers of theories in [35]; [35] also suggests the generalization
to products. Our sketch here mostly follows [14] and [35],
see also [31, Chapter 12] as well as [22, Section 9.6]. Somewhat specific to our presentation is the fact that we use a
multisorted logic and build into the language the correspondence between formulas interpreted over C and the cylindric
algebra of sets of positions.

Let LC be a relational language. Let further I be some
nonempty finite or countably infinite index set. For each
i 2 I let Ci = hCi; J K

C

i

i be a decidable structure interpreting

the language LC.

We define direct product of the family of structures Ci,
i 2 I, as the structure

P = \Pi i2ICi

8

where P = hP; J K

P

i. P is the set of all functions t such that

t(i) 2 Ci for i 2 I, and J K

P

is defined by

JrK

P

(t1; : : : ; tk) = 8i: JrK

C

i

(t1(i); : : : ; tk(i))

for each relation symbol r 2 LC.

inner formula relations for r 2 LC

r :: tuple

k

! indset

inner logical connectives
^

I

; .

I

:: indset \Theta  indset ! indset

:

I

:: indset ! indset

true

I

; false

I

:: indset

inner formula quantifiers
9

I

; 8

I

:: (tuple ! indset) ! indset

index set equality
=

I

:: indset \Theta  indset ! bool

logical connectives
^;. :: bool \Theta  bool ! bool

: :: bool ! bool
true; false :: bool

index set quantifiers
9

L

; 8

L

:: (indset ! bool) ! bool

tuple quantifiers
9; 8 :: (tuple ! bool) ! bool

Figure 2: Operations in product structure
For the purpose of quantifier elimination we consider a
richer language of statements about product structure P.
Figure 2 shows this richer language. The corresponding
structure P2 = hP2; J K

P2

i contains, in addition to the function space P , a copy of the boolean algebra 2

I

of subsets of

the index set I. We interpret a relation r 2 LC by

JrK

P2

(t1; : : : ; tk) = f i j JrK

C

i

(t1(i); : : : ; tk(i)) g

We let Jtrue

I

K

P2

= I and write

r(t1; : : : ; tk) =

I

true

I

to express JrK

P

(t1; : : : ; tk). Hence P2 is at least as expressive

as P.

Note that Figure 2 does not contain an equality relation
between tuples. If we need to express the equality between
tuples, we assume that some binary relation r0 2 LC in the
base structure is interpreted as equality, and express the
equality between tuples t1 and t2 using the formula:

r0(t1; t2) =

I

true

I

:

Figure 3 shows the semantics of the language in Figure 2.
(The logic has no partial functions, so we interpret the sort
bool over the set ftrue; falseg.)

inner formula relations for r 2 LC
JrK

P2

(t1; : : : ; tk) = f i j JrK

C

i

(t1(i); : : : ; tk(i)) g

inner logical connectives
J^

I

K

P2

(A1; A2) = A1 ^ A2

J.

I

K

P2

(A1; A2) = A1 [ A2

J:

I

K

P2

(A) = I n A

Jtrue

I

K

P2

= I

Jfalse

I

K

P2

= ;

inner formula quantifiers
J9

I

K

P2

f =

S

t2P

f(t)

J8

I

K

P2

f =

T

t2P

f(t)

index set equality
J=

I

K

P2

(A1; A2) = (A1 = A2)

logical connectives
(interpreted as usual)
index set quantifiers
J9

L

K

P2

f =

S

A22

I f(A)

J8

L

K

P2

f =

T

A22

I f(A)

tuple quantifiers

J9K

P2

f = 9t 2 P: f(t)

J8K

P2

f = 8t 2 P: f(t)

Figure 3: Semantics of operations in product structure P2

9

We let A1 `

I

A2 stand for A1 ^

I

A2 =

I

A2.

Note that the interpretations of ^

I

, .

I

, :

I

, true

I

, false

I

,

=

I

, 9

L

, 8

L

form a first-order structure of boolean algebras of

subsets of the set I. We call formulas in this boolean algebra
sublanguage index-set algebra formulas.

On the other hand, relations r for r 2 LC, together with
^

I

, .

I

, :

I

, 9

I

, 8

I

form the signature of first-order logic with

relation symbols. We call formulas built only from these
operations inner formulas.

Let OE be a an inner formula with free tuple variables
t1; : : : ; tm and no free indset variables. Then OE specifies a
relation ae ` D

m

. Consider the corresponding first-order

formula OE

0

interpreted in the base structure C; formula OE

0

specifies a relation ae

0

` C

m

. The following property follows

from the semantics in Figure 3:

ae(t1; : : : ; tm) = f i 2 I j ae

0

(t1(i); : : : ; tm(i)) g (9)

Sort constraints imply that quantifiers 9

I

; 8

I

are only applied

to inner formulas. Let OE be a formula of sort bool. By labelling subformulas of sort indset with variables A1; : : : ; An,
we can write OE in form OE

1

:

9

L

A1; : : : ; An:

A1 =

I

OE1 ^ : : : ^ An =

I

OEn ^

(A1; : : : ; An)

where

OE = (OE1; : : : ; OEn)

Furthermore, by defining B1; : : : ; Bm to be the partition of
true

I

consisting of terms of form

A

p1

1

^

I

: : : ^

I

A

pn

n

for p1; : : : ; pn 2 f0; 1g, we can find a formula 

0

and formulas

OE

0

1

; : : : ; OE

0

m

such that OE

1

is equivalent to OE

2

:

9

L

B1; : : : ; Bm:

B1 =

I

OE

0

1

^ : : : ^ Bm =

I

OE

0

m

^



0

(B1; : : : ; Bn)

(10)

and where OE

0

1

; : : : ; OE

0

m

evaluate to sets that form partition of

true

I

for all values of free variables. (By partition of true

I

we

here mean a family of pairwise disjoint sets whose union is
true

I

, but we do not require the sets to be non-empty.)

Now consider a formula of form 9t:OE where OE is without 9; 8 quantifiers (but possibly contains 9

I

; 8

I

and 9

L

; 8

L

quantifiers). We transform OE into OE

2

as described, and then

replace

9t: 9

L

B1; : : : ; Bm:

B1 =

I

OE

0

1

^ : : : ^ Bm =

I

OE

0

m

^



0

(B1; : : : ; Bn)

(11)

with

9

L

D1; : : : ; Dm: 9

L

B1; : : : ; Bm:

D1 =

I

(9

I

t:OE

0

1

) ^ : : : ^ Dm =

I

(9

I

t:OE

0

m

) ^

B1 `

I

D1 ^ : : : ^ Bm `

I

Dm ^

partition(B1; : : : ; Bn) ^ 

0

(B1; : : : ; Bn)

(12)

where partition(B1; : : : ; Bn) denotes a boolean algebra expression expressing that sets B1; : : : ; Bn form the partition
of true

I

.

It is easy to see that 11 and 12 are equivalent.
By repeating this construction we eliminate all term
quantifiers from a formula. We then eliminate all set quantifiers as in Section 3.2. For that purpose we extend the
language with cardinality constraints.

As the result we obtain cardinality constraints on inner
formulas. Closed inner formulas evaluate to true

I

or false

I

depending on their truth value in base structure C. Hence,
if C is decidable, so is P2.

Theorem 16 (Feferman-Vaught) Let C be a decidable
structure. Then every formula in the language of Figure 2 is
equivalent on the structure P2 to a propositional combination
of cardinality constraints of the index-set boolean algebra i.e.
formulas of form jOEj * k and jOEj = k where OE is an inner
formula.

Example 17 Let r 2 LC be a binary relation on structure
C. Let us eliminate quantifier 9t from the formula OE(t1; t2):

9t:9

L

A1; A2; A3:

A1 =

I

r(t; t1) ^ A2 =

I

r(t1; t) ^ A3 =

I

r(t2; t) ^

j:

I

A1j = 0 ^ j:

I

A2j = 0 ^ j:

I

A3j * 1

We first introduce sets B0; : : : ; B7 that form partition of
true

I

. The formula is then equivalent to OE1:

9t:9

L

B0; B1; B2; B3; B4; B5; B6; B7:

B0 =

I

r(t; t1) ^

I

r(t1; t) ^

I

r(t2; t) ^

B1 =

I

:

I

r(t; t1) ^

I

r(t1; t) ^

I

r(t2; t) ^

B2 =

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

r(t2; t) ^

B3 =

I

:

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

r(t2; t) ^

B4 =

I

r(t; t1) ^

I

r(t1; t) ^

I

:

I

r(t2; t) ^

B5 =

I

:

I

r(t; t1) ^

I

r(t1; t) ^

I

:

I

r(t2; t) ^

B6 =

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

:

I

r(t2; t) ^

B7 =

I

:

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

:

I

r(t2; t) ^

OE0

where

OE0 j

jB1j = 0 ^ jB2j = 0 ^
jB3j = 0 ^ jB5j = 0 ^
jB6j = 0 ^ jB7j = 0 ^
jB4j * 1
We now eliminate the quantifier 9t from the formula OE1,

10

obtaining formula OE2:

9

L

D0; D1; D2; D3; D4; D5; D6; D7:

D0 =

I

9

I

t: r(t; t1) ^

I

r(t1; t) ^

I

r(t2; t) ^

D1 =

I

9

I

t: :

I

r(t; t1) ^

I

r(t1; t) ^

I

r(t2; t) ^

D2 =

I

9

I

t: r(t; t1) ^

I

:

I

r(t1; t) ^

I

r(t2; t) ^

D3 =

I

9

I

t: :

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

r(t2; t) ^

D4 =

I

9

I

t: r(t; t1) ^

I

r(t1; t) ^

I

:

I

r(t2; t) ^

D5 =

I

9

I

t: :

I

r(t; t1) ^

I

r(t1; t) ^

I

:

I

r(t2; t) ^

D6 =

I

9

I

t: r(t; t1) ^

I

:

I

r(t1; t) ^

I

:

I

r(t2; t) ^

D7 =

I

9

I

t: :

I

r(t; t1) ^

I

:

I

r(t1; t) ^

I

:

I

r(t2; t) ^

OE3

where

OE3 j 9

L

B0; B1; B2; B3; B4; B5; B6; B7:

B0 `

I

D0 ^ : : : ^ B7 `

I

D7 ^

OE0

We next apply quantifier elimination for boolean algebras
to formula OE3 and obtain formula OE

0

3

:

OE

0

3

j jD4j * 1 ^ j:

I

D0 ^

I

:

I

D4j = 0

Hence OE(t1; t2) is equivalent to

9

L

D0; D4:

D0 =

I

9

I

t: r(t; t1) ^

I

r(t1; t) ^

I

r(t2; t) ^

D4 =

I

9

I

t: r(t; t1) ^

I

r(t1; t) ^

I

:

I

r(t2; t) ^

jD4j * 1 ^ j:

I

D0 ^

I

:

I

D4j = 0

After substituting the definitions of D0 and D4, formula
OE(t1; t2) can be written without quantifiers 9; 8; 9

L

; 8

L

.

\Upsilon 

3.4 Term Algebras
In this section we present a quantifier elimination procedure
for term algebras (see Section 2.1). A quantifier elimination
procedure for term algebras implies that the first-order theory of term algebras is decidable. In the sections below we
build on the procedure in this section to define quantifier
elimination procedures for structural subtyping.

The decidability of the first-order theory of term algebras follows from Mal'cev's work on locally free algebras
[31, Chapter 23]. [39] also gives an argument for decidability of term algebra and presents a unification algorithm
based on congruence closure [38]. Infinite trees are studied
in [12]. [30] presents a complete axiomatization for algebra
of finite, infinite and rational trees. A proof in the style of
[22] for an extension of free algebra with queues is presented
in [43]. Decidability of an extension of term algebras with
membership tests is presented in [10] in the form of a terminating term rewriting system. Unification and disunification

problems are special cases of decision problem for first-order
theory of term algebras, for a survey see e.g. [45, 9].

We believe that our proof provides some insight into
different variations of quantifier elimination procedures for
term algebras. Like [22] we use selector language symbols,
but retain the usual constructor symbols as well. The advantage of the selector language is that 9y: z = f(x; y) is
equivalent to a quantifier-free formula x = f1(z) ^ Isf (z).
On the other hand, constructor symbols also increase the
set of relations on terms definable via quantifier-free formulas, which can slightly simplify quantifier-elimination procedure, as will be seen by comparing Proposition 34 and
Proposition 38. Compared to [22, Page 70], we find that the
termination of our procedure is more evident and the extension to the term-power algebra in Section 6 easier. Our
base formulas somewhat resemble formulas arising in other
quantifier elimination procedures [31, 11, 30]. Our terminology also borrows from congruence closure graphs like those
of [39, 38], although we are not primarily concerned with
efficiency of the algorithm described. Term algebra is an example of a theory of pairing functions, and [15] shows that
non-empty family of theories of pairing functions as nonelementary lower bound on time complexity.

3.4.1 Term Algebra in Selector Language
To facilitate quantifier elimination we use a selector language Sel(\Sigma ) for term algebra [22, Page 61]. We define term
algebra in selector language as a first-order structure with
partial functions.

The set Sel(\Sigma ) contains, for every function symbol f 2
\Sigma  of arity ar(f) = k, a unary predicate Isf ` FT(\Sigma ) and
functions f1; : : : ; fk : FT(\Sigma ) ! FT(\Sigma ) such that

Isf (t) () 9t1; : : : ; tk: t = f(t1; : : : ; tk)(13)
fi(f(t1; : : : ; tk)) = ti; 1 ^ i ^ k (14)

fi(t) = ?; :Isf (t) (15)

For every f 2 \Sigma  and 1 ^ i ^ ar(f), expression fi(t) defined
iff Isf(t) holds, so we let Df = hx; Isf (x)i.

As a special case, if d is a constant, then ar(d) = 0 and
Isd(t) () t = d.

Proposition 18 For every formula OE1 in the language
Cons(\Sigma ) there exists an equivalent formula OE2 in the selector
language.

Proof Sketch. Because of the presence of equality symbol, every formula in language Cons(\Sigma ) can be written in
unnested form such that every atomic formula is of two
forms: x1 = x2, or f(x1; : : : ; xk) = y, where y and xi are
variables. We keep every formula x1 = x2 unchanged and
transform each formula

f(x1; : : : ; xk) = y
into the well-defined conjunction

x1 = f1(y) ^ \Delta  \Delta  \Delta  ^ xk = fk(y) ^ Isf (y)

Note that predicates Isf form a partition of the set of all
terms i.e. the following formulas are valid:

8x:

W

f2\Sigma 

Isf (x)

8x: :(Isf (x) ^ Isg(x)); for f 6j g

(16)

11

quantifier-free

formula

disjunction of

base formulas

Proposition 28

oe

Proposition 34

-

:; ^; .

oe

9

Figure 4: Quantifier Elimination for Term Algebra
A constructor-selector language contains both constructor symbols f 2 Cons(\Sigma ) and selector symbols fi 2 Sel(\Sigma ).

3.4.2 Quantifier Elimination
We proceed to quantifier elimination for term algebra. A
schematic view of our proof is in Figure 4. The basic insight is that any quantifier-free formula can be written in a
particular unnested form, as a disjunction of base formulas.
Base formulas trivially permit elimination of an existential
quantifier, yet every base formula can be converted back to
a quantifier-free formula.

A semi-base formula is almost the base formula, except
that it may be cyclic. We introduce cyclicity after explaining
the graph representation of a semi-base formula.

Definition 19 (Semi-Base Formula) A semi-base formula fi with

ffl free variables x1; : : : ; xm,
ffl internal non-parameter variables u1; : : : ; up, and
ffl internal parameter variables up+1; : : : ; up+q
is a formula of form

9u1; : : : ; un

distinct(u1; : : : ; un) ^
structure(u1; : : : ; un) ^
labels(u1; : : : ; un; x1; : : : ; xm)

distinct(u1; : : : ; un) enforces that variables are distinct

distinct(u1; : : : ; un) j

^

1^i!j^n

ui 6= uj :

structure(u1; : : : ; un) specifies relationships between terms
denoted by variables:

structure(u1; : : : ; un) j

p
V

i=1

ui = ti(u1; : : : ; un)

where each ti(u1; : : : ; un) is a term of form f(ul

1

; : : : ; ul

k

)

for f 2 \Sigma , k = ar(f).

labels(u1; : : : ; un; x1; : : : ; xm) identifies some free variables with some parameter and non-parameter variables:

labels(u1; : : : ; un; x1; : : : ; xm) j

^

1^i^m

xi = uj

i

for some function j : f1; : : : ; mg ! f1; : : : ; ng.

We require each semi-base formula to satisfy the following congruence closure property: there are no two distinct
variables ui and u

i

0 such that both ui = f(u

l1; : : : ; ul

k

)

and u

i

0 = f(u

l1 ; : : : ; ul

k

) occur as conjuncts OEj in formula

structure.

We denote by U the set of internal variables of a given
semi-base formula, U = fu1; : : : ; ung.

Definition 20 A semi-base formula in selector language is
obtained from the base formula in constructor language by
replacing every conjunct of form

ui = f(ul

1

; : : : ; ul

k

)

with the well-defined conjunction

Isf (ui) ^ ul

1

= f1(ui) ^ \Delta  \Delta  \Delta  ^ ul

k

= fk(ui)

A semi-base formula in selector language is clearly a wellformed conjunction of literals. All atomic formulas in a semibase formula are unnested, in both constructor and selector
language.

We can represent a base formula as a labelled directed
graph with the set of nodes U; we call this graph graph associated with a semi-base formula. Nodes of the graph are
in a bijection with internal variables of the semi-base formula. We call nodes corresponding to parameter variables
up+1; : : : ; up+q parameter nodes; nodes u1; : : : ; up are nonparameter nodes. Each non-parameter node is labelled by
a function symbol f 2 \Sigma  and has exactly ar(f) successors,
with edge from uk to ul labelled by the positive integer i
iff fi(uk) = ul occurs in the semi-base formula written in
selector language. A constant node is a node labelled by
some constant symbol c 2 \Sigma , ar(c) = 0. A constant node
is a sink in the graph; every sink is either a constant or a
parameter node. In addition to the labelling by function
symbols, each node u 2 U of the graph is labelled by zero
or more free variables x such that equation x = u occurs in
the semi-base formula.

Definition 21 (Base Formula) A semi-base formula OE is
a base formula iff the graph associated with OE is acyclic.

A semi-base formula whose associated graph is cyclic is unsatisfiable in the term algebra of finite terms. Checking the
cyclicity of a base formula corresponds to occur-check in
unification algorithms (see e.g. [29, 11]).

Definition 22 By height H(u) of a node u in the acyclic
graph we mean the length of the longest path starting from
u.

A node u is sink iff H(u) = 0.
Definition 23 We say that an internal variable ul is a
source variable of a base formula fi iff ul is represented by
a node that is source in the directed acyclic graph corresponding to fi. Equivalently, if fi is written in the selector
language, then ul is a source variable iff fi contains no equations of form ul = fi(uk).

Definition 24 If ui and uj are internal variables, we write
ui ae

\Lambda 

uj if there is a path in the underlying graph from node

ui to node uj. Equivalently, ui ae

\Lambda 

uj iff there exists a term

t(ui) in the selector language such that j= fi ) uj = t(ui).

12

Relation ae

\Lambda 

is a partial order on internal variables of fi.

The following Lemma 25 is similar to the Independence
of Disequations Lemma in e.g. [10, Page 178].

Lemma 25 Let fi be a base formula of the form

9u1; : : : ; up; up+1; : : : ; up+q: fi0
where up+1; : : : ; up+q are parameter variables of fi, and fi0 is
quantifier-free. Let Sp+1; : : : ; Sp+q be infinite sets of terms.
Then there exists a valuation oe such that Jfi0Koe = true and
JuiKoe 2 Si for p + 1 ^ i ^ p + q.

Proof. To construct oe assign first the values to parameter
variables, as follows. Let hG be the length of the longest
path in the graph associated with fi. Pick oe(up+1) 2 Sp+1 so
that h(oe(up+1)) ? hG, and for each i where p+2 ^ i ^ p+q
pick oe(ui) 2 Si so that h(oe(ui)) ? h(oe(ui\Gamma 1)) + hG. The
set of heights of an infinite set of terms is infinite, so it is
always possible to choose such oe(ui).

Next consider internal nodes u1; : : : ; up+q in some topological order. For each non-parameter node ui such
that ui = f(ul

1

; : : : ; ul

k

) occurs in fi0, let oe(ui) =

f(oe(ul

i

); : : : ; oe(ul

k

)).

Finally assign the values to free variables by oe(x) = oe(u)
where x = u occurs in fi0.

By construction, JstructureKoe = true and JlabelsKoe =
true. It remains to show JdistinctKoe = true i.e. oe(ui) 6= oe(uj)
for 1 ^ i; j ^ p + q, i 6= j. We show this property of oe
by induction on m = min(H(ui); H(uj)). Without loss of
generality we assume H(ui) ^ H(uj).

Consider first the case m = 0. Then ui is a parameter
or a constant node.

If ui is a constant and uj is a non-parameter variable
then ui and uj are labelled by different function symbols so
oe(ui) 6= oe(uj).

If ui is a constant and uj is a parameter variable then
h(oe(ui)) = 0 whereas h(oe(uj)) ? hG * 0.

Consider the case where ui is a parameter variable and
uj is a non-parameter variable. Let

J = fj1 j uj

1

is a parameter variable s.t. uj ae

\Lambda 

uj

1

g

If J = ;, then fi0 uniquely specifies oe(uj), and

h(oe(uj)) = H(uj) ^ hG ! h(oe(ui))
Let J 6= ; and j0 = max J. If i ^ j0, then

h(oe(ui)) ^ h(oe(uj

0

)) ! h(oe(uj))

If j0 ! i then

h(oe(uj)) ^ h(oe(uj

0

)) + hG ! h(oe(uj

0+1

)) ^ h(oe(ui))

Now consider the case m ? 0. ui and uj are nonparameter nodes, so let ui = f(ui

1

; : : : ; ui

k

) and uj =

g(uj

1

; : : : ; uj

l

). If f 6= g then clearly oe(ui) 6= oe(uj). Otherwise, by congruence closure property of base formulas, there
exists d such that ui

d

6= uj

d

. Then by induction hypothesis

oe(ui

d

) 6= oe(uj

d

), so oe(ui) 6= oe(uj).

Corollary 26 Every base formula is satisfiable.
Proposition 27 (Quantification of Base Formula) If
fi is a base formula and x a free variable in fi, then there
exists a base formula fi1 equivalent to 9x:fi.

Proof. Consider a formula 9x:fi where fi is a base formula.
The only place where x occurs in fi is x = us

1

in the subformula labels. By dropping the conjunct x = us

1

from fi we

obtain a base formula fi1 where fi1 is equivalent to 9x:fi.

Proposition 28 (Quantifier-Free to Base) Every welldefined quantifier-free formula in constructor-selector language can be written as true, false, or a disjunction of base
formulas.

Proof Sketch. Let OE be a well-defined quantifier-free
formula in constructor-selector language. By Proposition 8
we can transform OE into an equivalent formula in disjunctive
normal form

1 . \Delta  \Delta  \Delta  . p

where each i is a well-defined conjunction of literals. Consider an arbitrary i. There exists an unnested quantifierfree formula 

0

i

with additional fresh free variables x1; : : : ; xq

such that i is equivalent to

9x1; : : : ; xq: 

0

i

By distributivity and (6) it suffices to transform each conjunction of unnested formulas into disjunction of base formulas. In the sequel we will assume transformations based
on distributivity and (6) are applied whenever we transform
conjunction of literals into a formula containing disjunction.
We also assume that every equation f(x1; : : : ; xn) = y is
replaced by the equivalent one y = f(x1; : : : ; xn) and every
equation fi(x) = y is replace by y = fi(x).

Because of our assumption that \Sigma  is finite, we can eliminate every literal of form :Isf (x) using the equivalence

:Isf (x) ()

.

g2\Sigma nffg

Isg(x) (17)

which follows from (16). We then transform formula back
into disjunctive normal form and propagate the existential
quantifiers to the conjunctions of literals. We may therefore
assume that there are no literals of form :Isf (x) in the conjunction. Furthermore, Isf (x) ^ Isg(x) () false for f 6j g,
so we may assume that for variable x there is at most one
literal Isf (x) for some f. If fi(x) occurs in the conjunction,
because the conjunction is well-defined, we may always add
the conjunct Isf (x). This way we ensure that exactly one
literal of form Isf (x) occurs in the conjunction.

We next ensure that every variable has either none or
all of its components named by variables. If the conjunction
contains literal Isf (x) but does not contain x = f(x1; : : : ; xn)
and does not contain an equation of form y = fi(x) for
every i, 1 ^ i ^ ar(f), we introduce a fresh existentially
quantified variable for each i such that a term of form y =
fi(x) does not appear in the conjunction. At this point
we may transform the entire conjunction into constructor
language by replacing

Isf (ui) ^ vl

1

= f1(ui) ^ \Delta  \Delta  \Delta  ^ vl

k

= fk(ui)

with ui = f(vl

1

; : : : ; vl

k

) for k = ar(f).

We next ensure that for every two variables x1 and x2
occurring in the conjunction exactly one of the conjunct
x1 = x2 or x1 6= x2 is present. Namely if both conjuncts
x1 = x2 and x1 6= x2 are present, the conjunction is false.
If none of the conjuncts is present, we insert the disjunction

13

x1 = x2 . x1 6= x2 as one of the conjuncts and transform
the result into disjunction of existentially quantified conjunctions.

We next perform congruence closure for finite terms [38]
on the resulting conjunction, using the fact that equality is
reflexive, symmetric, transitive and congruent with respect
to free operations f 2 Cons(\Sigma ) and that t(x) 6= x for every
term t 6j x. Syntactically, the result of congruence closure
can be viewed as adding new equations to the conjunction.
If the congruence closure procedure establishes that the formula is unsatisfiable, the result is false. Otherwise, all variables are grouped into equivalence classes. If a u1 = u2
occurs in the conjunction where both u1 and u2 are internal
variables, we replace u1 with u2 in the formula and eliminate the existential quantifier. If for some free variable x
there is no internal variable u such that conjunction x = u
occurs, we introduce a new existentially quantified variable
and a conjunct x = u. These transformations ensure that
for every equivalence class there exists exactly one internal
variable in the formula. It is now easy to pick representative
conjuncts from the conjunction to obtain conjunction of the
syntactic form in Definition 19 of semi-base formula. The
resulting formula is a base formula because congruence closure algorithm ensures that the associated graph is acyclic.

We next turn to the problem of transforming a base formula into a quantifier-free formula. We will present two
constructions. The first construction yields a quantifier-free
formula in constructor-selector language and is sufficient for
the purpose of quantifier elimination. The second construction yields a quantifier-free formula in selector language and
is slightly more involved; we present it to provide additional
insight into the quantifier elimination approach to term algebras.

We first introduce notions of covered and determined
variables of a base formula fi. The basic idea behind these
notions is that fi implies a functional dependence from the
free variables of fi to each of the determined variables.

In both constructions we use the notion of a a covered
variable, which denotes a component of a term denoted by
some free variable. In the first construction we also use the
notion of determined variable, which includes covered variables as well as variables constructed from covered variables
using constructor operations f 2 Cons(\Sigma ).

Definition 29 Consider an arbitrary base formula fi. We
say that an internal variable u is covered by a free variable
x iff x = u

0

occurs in fi for some u

0

such that u ae

\Lambda 

u

0

. An

internal variable u is covered iff u is covered by x for some
free variable x (in particular, if x = u occurs in fi then u
is covered). Let covered denote the set of covered internal
variables of base formula, and let uncovered = U n covered
where U is the set of all internal variables of fi.

Lemma 30 (Covered Base to Selector) Every base
formula without uncovered variables is equivalent to a
quantifier free formula in selector language.

Proof. Consider a base formula fi where every variable is
covered. Consider an arbitrary quantified variable u. Because u is covered, there exists variable x free in fi such that
u = t(x) for some term t in the selector language. Replace
every occurrence of u in the matrix of fi by t(x) and eliminate the quantification over u. Repeating this process for

every variable u we obtain a quantifier-free formula equivalent to fi.

Definition 31 Let fi be a base formula. The set determined
of determined variables of fi is the smallest set S that contains the set covered and satisfies the following condition:
if u is a non-parameter node and all successors u1; : : : ; uk
(k * 0) of u in the associated graph are in S, then u is also
in S.

In particular, every constant node is determined. A parameter node w is determined iff w is covered.

Lemma 32 If a node u is not determined, then there exists
an uncovered parameter node v such that u ae

\Lambda 

v.

Proof. The proof is by induction on H(()u). If H(()u) = 0
then u has no successors, and u cannot be a constant node
because it is not determined. Therefore, u is a parameter
node, so we may let v j u. Assume that the statement
holds for for every node u

0

such that H(()u

0

) = k and let

H(()u) = k + 1. Because u is not determined, there exists
a successor u

0

of u such that u

0

is not determined, so by

induction hypothesis there exists an uncovered parameter
node v such that u

0

ae

\Lambda 

v. Hence u ae

\Lambda 

u

0

ae

\Lambda 

v.

Lemma 33 Every base formula fi is equivalent to a base
formula fi

0

obtained from fi by eliminating all nodes that are

not determined.

Proof. Construct fi

0

from fi by eliminating all terms

containing a variable u 2 U n determined and eliminating
the corresponding existential quantifiers. Then all variables
in fi

0

are determined. fi

0

has fewer conjuncts than fi, so

j= fi ) fi

0

. To show j= fi

0

) fi, let oe be any assignment

of terms to determined variables of fi such that fi evaluate
to true under oe. As in the proof of Lemma 25, define the
extension oe

0

of oe as follows. Choose sufficiently large values

oe

0

(v) for every uncovered sink variable v, so that oe

00

defined

as the unique extension of oe

0

to the remaining undetermined

variables assigns different terms to different variables. This
is possible because the term model is infinite. The resulting assignment oe

00

satisfies the matrix of the base formula

fi. Therefore, j= fi

0

) fi, so fi and fi

0

are equivalent base

formulas.

First Construction
Proposition 34 (Base to Constructor-Selector)
Every base formula fi is equivalent to a quantifier-free
formula OE in constructor-selector language.

Proof. By Lemma 33 we may assume that all variables
in fi are determined. To every variable u we assign a term
o/ (u). Term o/ (u) is in constructor-selector language and the
variables of o/(u) are among the free variables of fi. If u 2
covered, we assign o/(u) as in the proof of Lemma 30. If
u1; : : : ; uk are the successors of a determined node u, we
put

o/ (u) = f(o/(u1); : : : ; o/ (uk))

where f is the label of node u. This definition uniquely
determines o/(u) for all u 2 determined. We obtain the
quantifier-free formula OE by replacing every variable u with
o/ (u) and eliminating all quantifiers.

14

For every u we have j= fi ) u = o/ (u), so j= fi ) OE.
Conversely, if OE is satisfied then o/ defines an assignment for
u variables which makes the matrix of fi true. Therefore fi
and OE are equivalent.

Second Construction The reason for using constructor
symbols f 2 Cons(\Sigma ) in the first construction is to preserve the constraints of form u 6= v when eliminating node
u with successors u1; : : : ; uk. Using constructor symbols we
would obtain the constraint f(u1; : : : ; uk) 6= v. Our second
construction avoids introducing constructor operations by
decomposing f(u1; : : : ; uk) 6= v into disjunction of inequalities of form ui 6= fi(v). When v is a parameter node, the
presence of term fi(v) potentially requires introducing a new
node in the associated graph, we call this process parameter expansion. Parameter expansion may increase the total
number of nodes in the graph, but it decreases the number of uncovered nodes, so the process of converting a base
formula to a quantifier-free formula in the selector language
terminates.

Lemma 35 Let fi be an arbitrary base formula.

1. If u is covered and u ae

\Lambda 

u

0

then u

0

is covered as well.

2. If u

0

is uncovered and u

0

is not a source, then there

exists u 6j u

0

such that u ae

\Lambda 

u

0

and u is also uncovered.

3. If fi contains an uncovered variable then fi contains an

uncovered variable that is a source.

Proof. By definition.

Parameter Expansion We define the operation of expanding a parameter node in a base formula as follows. Let
fi be an arbitrary base formula and w a parameter variable
in fi. The result of expansion of w is a disjunction of base
formulas fi

0

generated by applying (13) to w. In each of

the resulting formulas fi

0

variable w is not a parameter any

more. Each fi

0

contains Isf (w) for some f 2 \Sigma  and node w

has successors u1; : : : ; uk for k = ar(f). Each successor ui is
either an existing internal variable or a fresh variable. For a
given fi, sink expansion generates disjunction of formulas fi

0

for every choice of f 2 \Sigma  and every choice of successors ui,
subject to congruence closure so that fi

0

is a base formula:

we discard the choices of successors of w that yield formulas
fi

0

violating congruence of equality. (This process is similar to converting quantifier-free formulas into disjunction of
base formulas in the proof of Proposition 28.) The following
lemma shows the correctness of parameter expansion.

Lemma 36 (Parameter expansion soundness) Let
\Delta  = fi

0

1

. \Delta  \Delta  \Delta  fi

0

k

be the disjunction generated by parameter

expansion of a base formula fi. Then \Delta  is equivalent to fi.

Lemma 36 justifies the use of parameter expansion in the
following Lemma 37.

Lemma 37 Every base formula fi can be written as a disjunction of base formulas without uncovered variables.

Proof Sketch. By Lemma 33 we may assume that all variables of fi are determined. Suppose fi contains an uncovered
variable. Then by Lemma 35, fi contains an uncovered variable u0 such that u0 is a source. Because u0 is uncovered

and determined, it is not a parameter node. We show how to
eliminate u0 without introducing new uncovered variables.

Our goal is to eliminate u0 from the associated graph.
We need to preserve information that u0 is distinct from
variables u 2 U n fu0g in the graph. We consider two cases.

If u is not a parameter node, then by congruence closure
either u0 and u are labelled by different function symbols,
or they are labelled by the same function symbol f 2 \Sigma 
with ar(f) = k and there exists i, 1 ^ i ^ k and variables
ui = fi(u0) and u

0

i

= fi(u

0

) such that ui 6j u

0

i

. Hence the

constraint u0 6= u is deducible from the inequalities of other
variables in fi and we can eliminate u0 without changing the
truth value of fi.

Next consider the case when u is a parameter node. By
assumption u is determined, and because it is parameter, it
is covered. We then perform parameter node expansion as
described above. The result of elimination of u0 in fi is a
disjunction of base formulas fi

0

, in each fi

0

every parameter

node is expanded. If u is a parameter node in fi then the
constraint u0 6= u is preserved in each fi

0

because u is not a

parameter node in fi

0

so the previous argument applies.

Because the parameter nodes being expanded are covered, so are their successor nodes introduced by parameter
expansion. Therefore, by repeatedly applying elimination
of uncovered variables for every uncovered variable u0, we
obtain a disjunction \Delta  of formulas fi

0

where each fi

0

has no

uncovered variables, and \Delta  is equivalent to fi.

Proposition 38 (Base to Selector) For every base formula fi there exists an equivalent quantifier-free formula 
in selector language.

Proof. By Lemma 37, fi is equivalent to a disjunction
fi1 . \Delta  \Delta  \Delta  . fin where each fii has no uncovered variables. By
Lemma 30, each fii is equivalent to some quantifier free formula i, so fi is equivalent to the quantifier-free formula
1 . \Delta  \Delta  \Delta  . n.

The final theorem in this section summarizes quantifier elimination for term algebra.

Theorem 39 (Term Algebra Quantifier Elimination)
There exist algorithms A, B, C such that for a given formula
OE in constructor-selector language of term algebras:

a) A produces a quantifier-free formula OE

0

in constructorselector language

b) B produces a quantifier-free formula OE

0

in selector language

c) C produces a disjunction OE

0

of base formulas

Proof. a): Transform formula OE into prenex form

Q1x1 : : : Qn\Gamma 1xn\Gamma 1Qnxn:OE

\Lambda 

where OE

\Lambda 

is quantifier free, as in Section 3.1. We eliminate

the innermost quantifier Qn as follows.

Suppose first that Qn is 9. Transform the matrix OE

\Lambda 

into

disjunctive normal form C1 . \Delta  \Delta  \Delta  . Cn. By Proposition 28,
transform C1 . \Delta  \Delta  \Delta  . Cn into disjunction fi1 . \Delta  \Delta  \Delta  . fim of base
formulas. Then propagate 9 into individual disjuncts, using

9xn: fi1 . \Delta  \Delta  \Delta  . fim () (9xn:fi1) . \Delta  \Delta  \Delta  . (9xn:fim)

15

By Proposition 27, an existentially quantified base formula
is again a base formula, so 9xn:fii () fi

0

i

for some fi

0

i

. We

thus obtain the

Q1x1 : : : Qn\Gamma 1xn\Gamma 1: fi

0

1

. \Delta  \Delta  \Delta  . fi

0

m

(18)

By Proposition 34, every base formula is equivalent to a
quantifier-free formula in selector language, so 18 is equivalent to

Q1x1 : : : Qn\Gamma 1xn\Gamma 1:

where  is a quantifier free formula. Hence, we have eliminated the innermost existential quantifier.

Next consider the case when Qn is 8. Then OE is equivalent to

Q1x1 : : : Qn\Gamma 1xn\Gamma 1:9xn::OE

\Lambda 

Apply the procedure for eliminating xn to :OE

\Lambda 

. The result

is formula of form

Q1x1 : : : Qn\Gamma 1xn\Gamma 1: : (19)
where  is quantifier free. But : is also quantifier free, so
we have eliminated the innermost universal quantifier. By
repeating this process we eliminate all quantifiers, yielding
the desired formula OE

0

.

The direct construction for showing b) is analogous to
a), but uses Proposition 38 in place of Proposition 34. To
show c), apply e.g. construction a) to obtain a quantifierfree formula  and then transform  into disjunction of base
formulas using Proposition 28.

This completes our description of quantifier elimination
for term algebras.

We remark that there are alternative ways to define base
formula. In particular the requirement on disequality of all
variables is not necessary. This requirement may lead to
unnecessary case analysis when converting a quantifier-free
formula to disjunction of base formulas, but we believe that
it simplifies the correctness argument.

4 The Pair Constructor and Two Constants
In this section we give a quantifier elimination procedure for
structural subtyping of non-recursive types with two constant symbols and one covariant binary constructor. Two
constants corresponds to two primitive types; one binary
covariant constructor corresponds to the pair constructor
for building products of types.

The construction in this section is an introduction to
the more general construction in Section 5, where we give a
quantifier elimination procedure for any number of constant
symbols and relations between them. The construction in
this section demonstrates the interaction between the term
and boolean algebra components of the structural subtyping.
We therefore believe the construction captures the essence
of the general result of Section 5.

The basic observation behind the quantifier elimination
procedure for two constant symbols is that the structure of
terms in this language is isomorphic to a disjoint union of
boolean algebras with some additional term structure connecting elements from different boolean algebras. As we argue below, the structural subtyping structure contains one
copy of boolean algebra for every equivalence class of terms
that have the same "shape" i.e. are same up to the constants
in the leaves.

Consider a signature \Sigma  = fa; b; gg where a and b are
constant symbols and g is a function symbol of arity 2. We
define a partial order ^ on the set FT(\Sigma ) of ground terms
over \Sigma  as the least reflexive partial order relation ae satisfying

1. a ae b;
2. (s1 ae t1) ^ (s2 ae t2) ) g(s1; s2) ae g(t1; t2).
The structure with equality in the language fa; b; g; ^g,
where ^ is interpreted as above and a; b; g are interpreted
as free operations on term algebra corresponds to the structural subtyping with two base types a and b and one binary
type constructor g, with g covariant in both arguments. We
denote this structure by BS. We proceed to show that BS
admits quantifier elimination and is therefore decidable.

4.1 Boolean Algebras on Equivalent Terms
In preparation for the quantifier elimination procedure we
define certain operations and relations on terms. We also
establish some fundamental properties of the structure BS.

Define a new signature \Sigma 0 = fc

s

; g

s

g as an abstraction of

signature \Sigma  = fa; b; gg. Define function shapified : \Sigma  ! \Sigma 0
by

shapified(a) = c

s

shapified(b) = c

s

shapified(g) = g

s

Let ar(shapified(f)) = ar(f) for each f 2 \Sigma ; in this case c

s

is

a constant and g

s

is a binary function symbol. Let FT(\Sigma 0)

be the set of ground terms over the signature \Sigma 0. Define
shape of a term t, as the function sh : FT(\Sigma ) ! FT(\Sigma 0), by
letting

sh(f(t1; : : : ; tk)) =

shapified(f)(sh(t1); : : : ; sh(tk))
for k = ar(f). In this case we have

sh(a) = c

s

sh(b) = c

s

sh(g(t1; t2)) = g

s

(sh(t1); sh(t2))

Define t1 , t2 iff sh(t1) = sh(t2). Then , is the smallest
equivalence relation ae such that

1. a ae b;
2. (s1 ae t1) ^ (s2 ae t2) ) g(s1; s2) ae g(t1; t2).
For every term t define the word tCont(t) 2 f0; 1g

\Lambda 

by letting

tCont(a) = 0

tCont(b) = 1
tCont(f(t1; t2)) = tCont(t1) \Delta  tCont(t2)

The set of all words w 2 f0; 1g

n

is isomorphic the boolean

algebra of Bn of all subsets of some finite sets of cardinality
n, so we write w1"w2, w1[w2, w

c

for operations corresponding to intersection, union, and set complement in the set of
words w 2 f0; 1g

n

. We write w1 ` w2 for w1 " w2 = w1.

Define function ffi by

ffi(t) = hsh(t); tCont(t)i

16

For term t in any language containing constant symbols, let
tLen(t) denote the number of occurrences of constant symbols in t. If w is a sequence of elements of some set, let
sLen(w) denote the length of the sequence. Observe that
sLen(tCont(t)) = tLen(t) and tLen(sh(t)) = tLen(t). Moreover, t1 , t2 implies sLen(tCont(t1)) = sLen(tCont(t2)). Define the set B by

B = fhs; wi j s 2 FT(\Sigma 0); w 2 f0; 1g

\Lambda 

; tLen(s) = sLen(w)g

Function ffi is a bijection from the set FT(\Sigma ) to the set B.
For b1; b2 2 B define b1 ^ b2 iff ffi

\Gamma 1

(b1) ^ ffi

\Gamma 1

(b2). From

the definitions it follows

hs1; w1i ^ hs2; w2i () s1 = s2 ^ w1 ` w2
If g is defined on B via isomorphism ffi we also have

g(hs1; w1i; hs2; w2i) = hg

s

(s1; s2); w1 \Delta  w2i

For any fixed s 2 FT(\Sigma 0), the set

B(s0) = fhs; wi 2 B j s = s0g (20)
is isomorphic to the boolean algebra Bn, where n = tLen(s).
Accordingly, we introduce on each B(s) the set operations
t1 "s t2, t1 [s t2, t

c

1s

. Expressions t1 "s t2 and t1 [s t2 are

defined iff sh(t1) = s and sh(t2) = s, whereas expression t

c

1s

is defined iff sh(t1) = s.

We also introduce cardinality expressions as in Section 3.2. If t denotes a term, then the expression jtjs denotes the number of elements of the set corresponding to t.
Here we require s = sh(t). We use expressions jtjs = k and
jtjs * k as atomic formulas for constant integer k * 0. Note
that

t1 ^ t2 () sh(t1) = sh(t2) ^ jt1 " t

c

2

j

sh(t1)

= 0 (21)

t1 = t2 () sh(t1) = sh(t2) ^

j(t1 " t

c

2

) [ (t

c

1

" t2)j

sh(t1)

= 0

(22)

Let sh(t1) = s1, sh(t2) = s2, and s = g

s

(s1; s2). Then

jg(t1; t2)js = jt1js

1

+ jt2js

2

(23)

Equation 23 allows decomposing formulas of form
jg(t1; t2)js * k into propositional combinations of formulas
of form jt1js

1

* k and jt2js

2

* k.

Note further that the following equations hold:

g(t1; t2) " g(t

0

1

; t

0

2

) = g(t1 " t

0

1

; t2 " t

0

2

)

g(t1; t2) [ g(t

0

1

; t

0

2

) = g(t1 [ t

0

1

; t2 [ t

0

2

)

g(t1; t2)

c

= g(t

c

1

; t

c

2

)

If E(x1; : : : ; xn) denotes an expression consisting only of operations of boolean algebra, then from (4.1) by induction
follows that

E(g(t

1

1

; t

2

1

); : : : ; g(t

1

n

; t

2

n

)) = g(E(t

1

1

; : : : ; t

1

n

); E(t

2

1

; : : : ; t

2

n

))

(24)
Equations (24) and (23) imply

jE(g(t

1

1

; t

2

1

); : : : ; g(t

1

n

; t

2

n

))j = jE(t

1

1

; : : : ; t

1

n

)j + jE(t

2

1

; : : : ; t

2

n

)j

(25)
Boolean algebra B(g

s

(s1; s2)) is isomorphic to the product

of boolean algebras B(s1) and B(s2); the constructor g acts
as union of disjoint sets.

a; b :: term

g :: term \Theta  term ! term
Isg :: term ! bool
g1; g2 :: term ! term

= :: term \Theta  term ! bool
^ :: term \Theta  term ! bool

c

s

:: shape

g

s

:: shape \Theta  shape ! shape

Isgs :: shape ! bool
g

s

1

; g

s

2

:: shape ! shape

sh :: term ! shape
=

s

:: shape \Theta  shape ! bool

" ; [ :: shape \Theta  term \Theta  term ! term

c

:: shape \Theta  term ! term

1 ; 0 :: shape ! term
j j * k; j j = k :: shape \Theta  term ! bool

Figure 5: Operations and relations in structure FT2
4.2 A Multisorted Logic
To show the decidability of structure BS, we give a quantifier
elimination procedure for an extended structure, denoted
FT2. We use a first-order two-sorted logic with sorts term
and shape interpreted over FT2.

The domain of structure FT2 is FT(\Sigma ) [ FT(\Sigma 0) with elements FT(\Sigma ) having sort term and elements FT(\Sigma 0) having
sort shape. Variables in Var have term sort, variables in Var

s

have shape sort. In general, if t denotes an element of FT2,
we write t

S

to indicate that the element has sort shape.

Figure 5 shows operations and relations in FT2 with their
sort declarations. The signature is infinite because operations jtjs * k and jtjs = k are parameterized by a nonnegative integer k.

We require all terms to be well-sorted. Functions g1 and
g2 are interpreted as partial selector functions in the term
constructor-selector language, so Dg

1

= Dg

2

= hhxi; Isg(x)i.

Similarly, g

s

1

and g

s

2

are partial selector functions in the

shape constructor-selector language, so Dgs

1

= Dgs

2

=

hhxi; Isgs (x)i. The expressions t1 "s t2 and t1 [s t2 are defined
iff sh(t1) = sh(t2) = s, and t

c

s

is defined iff sh(t) = s. We

therefore let

D"

s

= D[

s

=

hhy

s

; x1; x2i; sh(x1) = y

s

^ sh(x2) = y

s

i

and

D c = hhy

s

; xi; sh(x) = y

s

i

For atomic formulas jtjs * k and jtjs = k we require atomic
formula sh(t) = s to ensure well-definedness:

D

j j =k

= D

j j *k

= hhy

s

; xi; sh(x) = y

s

i

Note that the language of Figure 5 subsumes the language fa; b; g; ^g for the structural subtyping structure. The

17

quantifier-elimination procedure we present in Section 4.3
is therefore sufficient for quantifier elimination in the firstorder logic interpreted over the structural subtyping structure FT2.

4.3 Quantifier Elimination for Two Constants
We are now ready to present a quantifier elimination procedure for the structure FT2. The quantifier elimination
procedure is based on the quantifier elimination for term algebras of Section 3.4 as well as the quantifier elimination for
boolean algebras of Section 3.2.

We first define an auxiliary notion of a u

s

-term as a term

formed starting from shape u

s

term variables and shape u

s

constants, using operations "us, [us, and

c

u

s.

Definition 40 (u

s

-terms) Let u

s

2 Var

s

be a shape variable. The set of u

s

-terms Term(u

s

) is the least set such that:

1. Var ` Term(u

s

)

2. 0us ; 1us 2 Term(u

s

)

3. if t; t

0

2 Term(u

s

), then also

t "us t

0

2 Term(u

s

);

t [us t

0

2 Term(u

s

); and

t

c

u

s 2 Term(u

s

)

Similarly to base formulas of Section 3.4, we define structural base formulas for FT2 structure. A structural base formula contains a copy of a base formula for the shape sort
(shapeBase), a base formula for the term sort without term
disequalities (termBase), a formula expressing mapping of
term variables to shape variables (hom), and cardinality constraints on term parameter nodes of the term base formula
(cardin).

Definition 41 (Structural Base Formula)

A structural base formula with:

ffl free term variables x1; : : : ; xm;
ffl internal non-parameter term variables u1; : : : ; up;
ffl internal parameter term variables up+1; : : : ; up+q;
ffl free shape variables x

s

1

; : : : ; x

s

m

s;

ffl internal non-parameter shape variables u

s

1

; : : : ; u

s

p

s;

ffl internal parameter shape variables u

s

p

s; : : : ; u

s

p

s

+q

s

is a formula of form:

9u1; : : : ; un; u

s

1

; : : : ; u

s

n

s:

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s) ^

termBase(u1; : : : ; un; x1; : : : ; xm) ^
hom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s) ^

cardin(up+1; : : : ; un; u

s

p

s

+1

; : : : ; u

s

n

s)

where n = p + q, n

s

= p

s

+ q

s

, and formulas shapeBase,

termBase, hom, and cardin are defined as follows.

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s) =

p

s

V

i=1

u

s

i

= ti(u

s

1

; : : : ; u

s

n

) ^

m

s

V

i=1

x

s

i

= u

s

j

i

^ distinct(u

s

1

; : : : ; u

s

n

)

where each ti is a shape term of form f(u

s

i1

; : : : ; u

s

i

k

) for

some f 2 \Sigma 0, k = ar(f), and j : f1; : : : ; m

s

g ! f1; : : : ; n

s

g is

a function mapping indices of free shape variables to indices
of internal shape variables.

termBase(u1; : : : ; un; x1; : : : ; xm) =

p
V

i=1

ui = ti(u1; : : : ; un) ^

m
V

i=1

xi = uj

i

where each ti is a term of form f(ui

1

; : : : ; ui

k

) for some

f 2 \Sigma , k = ar(f), and j : f1; : : : ; mg ! f1; : : : ; ng is a
function mapping indices of free term variables to indices of
internal term variables.

hom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s ) =

n
V

i=1

sh(ui) = u

s

j

i

where j : f1; : : : ; ng ! f1; : : : ; n

s

g is some function such

that fj1; : : : ; jpg ` f1; : : : ; p

s

g and fjp+1; : : : ; jp+qg ` fp

s

+

1; : : : ; p

s

+ q

s

g (a term variable is a parameter variable iff its

shape is a parameter shape variable).

cardin(up+1; : : : ; up+q; u

s

p

s

+1

; : : : ; u

s

p

s

+q

s) = 1 ^ \Delta  \Delta  \Delta  ^ r

where each i is of form

jt(up+1; : : : ; up+q)jus = k
or

jt(up+1; : : : ; up+q)jus * k

for some u

s

-term t(up+1; : : : ; up+q) that contains no variables other than some of the variables up+1; : : : ; up+q, and
the following condition holds:

If a variable up+j occurs in term
t(up+1; : : : ; up+q), then sh(up+j) = u

s

occurs in formula hom.

(26)

We require each structural base formula to satisfy the
following conditions:

P0) the graph associated with shape base formula

9u

s

1

; : : : ; u

s

n

s : shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s)

is acyclic (compare to Definition 21);
P1) congruence closure property for shapeBase subformula:

there are no two distinct variables u

s

i

and u

s

j

such that

both u

s

i

= f(u

s

l1

; : : : ; u

s

l

k

) and u

s

j

= f(u

s

l1

; : : : ; u

s

l

k

) occur

as conjuncts in formula shapeBase;

P2) congruence closure property for termBase subformula:

there are no two distinct variables ui and uj such that
both ui = f(ul

1

; : : : ; ul

k

) and uj = f(ul

1

; : : : ; ul

k

) occur

as conjuncts in formula termBase;

P3) homomorphism property of sh: for every non-parameter

term variable u such that u = f(ui

1

; : : : ; ui

k

) occurs

in termBase, if the conjunct sh(u) = u

s

occurs in

hom, then for some shape variables u

s

j1

; : : : ; u

s

j

k

the

term u

s

= f

s

(u

s

j1

; : : : ; u

s

j

k

) occurs in shapeBase where

f

s

= shapified(f) and for every r where 1 ^ r ^ k,

conjunct sh(ui

r

) = u

s

jr

occurs in hom.

18

uvz uzv
uv uz uw

uz1uv1 uw1 uz2uv2 uw2

v z w

uw2suw1s
uws

uvzs

Figure 6: One of the Base Formulas Resulting from (28)
According to Definition 41 a structural base formula contains no selector function symbols. Formulation using selector symbols is also possible, as in Definition 20. The
only partial function symbols occurring in a structural base
formula of Definition 41 are in cardin subformula. Condition (26) therefore ensures that functions in cardin and thus
the entire base formula are well-defined.

Note that acyclicity of shape base formula shapeBase
(condition P0) implies acyclicity of term base formula as
well. Namely, condition P3 ensures that any cycle in
termBase implies a cycle in shapeBase.

As in Section 3.4 we proceed to show that each quantifierfree formula can be written as a disjunction of base formulas
and each base formula can be written as a quantifier-free
formula.

We strongly encourage the reader to study the following
example because it illustrates the idea behind our quantifierelimination decision procedure.

Example 42 The following sentence is true in structure
FT2.

8x; y: x ^ y )

9z: z ^ x ^ z ^ y ^

8w: w ^ x ^ w ^ y )

8v: g(v; z) ^ g(z; v) ^ Isg(v) ^ Isg(w) ) g1(w) ^ g1(v)

(27)
An informal proof of sentence (27) is as follows. Suppose
that x ^ y. Then sh(x) = sh(y) = x

s

. Let z = x "xs y.

Now consider some w such that w ^ x and w ^ y. Then
sh(w) = x

s

, so w ^ z. Suppose that v is such that g(v; z) ^

g(z; v). Then by covariance of g we have z ^ v, so w ^ v. If
we assume Isg(w) and Isg(v), then g1(w) and g1(v) are well
defined and by covariance of g we conclude g1(w) ^ g1(v),
as desired.

We now give an alternative argument that shows that
sentence (27) is true. This alternative argument illustrates
the idea behind our quantifier-elimination decision procedure. For the sake of brevity we perform some additional
simplifications along the way that are not part of the procedure we present (although they could be incorporated to
improve efficiency), and we skip consideration of some uninteresting cases during the case analyses.

Let us first eliminate the quantifier from formula

8v: g(v; z) ^ g(z; v) ^ Isg(v) ^ Isg(w) ) g1(w) ^ g1(v) (28)
Formula (28) is equivalent to :9v:OE1 where

OE1 j g(v; z) ^ g(z; v) ^ Isg(v) ^ Isg(w) ^ :(g1(w) ^ g1(v))

(29)

We next use (21) to eliminate atomic formulas t1 ^ t2 and
replace them with cardinality constraints, resulting in formula OE2 equivalent to OE1:

OE2 j OE2;1 ^ OE2;2
where

OE2;1 j jg(v; z) " g(z; v)

c

j

sh(g(v;z))

= 0 ^

sh(g(v; z)) = sh(g(z; v)) ^
Isg(v) ^ Isg(w)

(30)

and

OE2;2 j

:

\Gamma 

jg1(w) " g1(v)

c

j

sh(g1(w))

= 0 ^ sh(g1(w)) = sh(g1(v))

\Delta 

(31)
Here we have written e.g.

jg(v; z) " g(z; v)

c

j

sh(g(v;z))

= 0

as a shorthand for

jg(v; z) "

sh(g(v;z))

g(z; v)

c

sh(g(v;z))

j

sh(g(v;z))

= 0

(In general, we omit term shape arguments for boolean algebra operations if the arguments are identical to the enclosing
term shape argument of the cardinality constraint.)

We next transform OE2 into disjunction of well-defined
conjunctions. Following the ideas in Proposition 8, we transform OE2;2 into OE3;1 . OE3;2 where

OE3;1 j

jg1(w) " g1(v)

c

j

sh(g1(w))

* 1 ^ sh(g1(w)) = sh(g1(v))

(32)
and

OE3;2 j sh(g1(w)) 6= sh(g1(v))

and then transform OE2;1 ^ OE2;2 into

(OE2;1 ^ OE3;1) . (OE2;1 ^ OE3;2)
For the sake of brevity we ignore the case OE2;1 ^ OE3;2; it is
possible to show that OE2;1 ^ OE3;2 is equivalent to false in the
context of the entire formula.

We transform OE2;1 ^OE3;1 into unnested form, introducing
fresh existentially quantified variables uvz,uzv,uw1,uv1, u

s

vz

,

u

s

w1

that denote terms occurring in OE2;1 ^ OE3;1. The result

is formula OE4 where

OE4 j 9uvz; uzv; uw1; uv1; u

s

vz

; u

s

w1

:

uvz = g(v; z) ^ uzv = g(z; v) ^
uw1 = g1(w) ^ uv1 = g1(v) ^
u

s

vz

= sh(uvz) ^ u

s

w1

= sh(uw1) ^

sh(uzv) = u

s

vz

^ sh(uv1) = u

s

w1

^

Isg(v) ^ Isg(w) ^
juvz " u

c

zv

jus

vz

= 0 ^ juw1 " u

c

v1

jus

w1

* 1

(33)
To transform OE4 into disjunction of structural base formulas
we keep introducing new existentially quantified variables
and adding derived conjuncts to satisfy the invariants of
Definition 41.

19

Because Isg(v) and Isg(w) appear in the conjunct, we
give names to the remaining successors of v, w, by introducing uw2 = g2(w), uv2 = g2(v). We may now write
the constraints in constructor language, using e.g. conjunct
v = g(uv1; uv2) instead of

Isg(v) ^ uv1 = g1(v) ^ uv2 = g2(v)
To ensure that every term variable has an associated shape
variable, we introduce fresh variables u

s

v

, u

s

w

, u

s

z

, u

s

w2

, u

s

v2

with conjuncts u

s

v

= sh(v), u

s

w

= sh(w), u

s

z

= sh(z), u

s

w2

=

sh(uw2), u

s

v2

= sh(uv2).

Note that base formula contains distinct(u

s

1

; : : : ; u

s

n

) subformula. In the case when the current conjunction is not
strong enough to entail the disequality between shape variables u

s

i

and u

s

j

, we perform case analysis, considering the

case u

s

i

= u

s

j

(then u

s

i

can be replaced by u

s

j

), and the case

u

s

i

6= u

s

j

. This case analysis will lead to a disjunction of structural base formulas (unless some of the formulas is shown
contradictory in the transformation process). In contrast to
shape variables, we do not not perform case analysis for disequality of term variables, because termBase in Definition 41
does not contain a distinct subformula.

In this example we perform case analysis on whether
u

s

w

= u

s

z

and u

s

w

= u

s

v

should hold. For the sake of the example let us consider the case when u

s

w

= u

s

z

= u

s

v

, u

s

v2

= u

s

w2

and u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

are all distinct. In that case shape

variables u

s

w

; u

s

z

; u

s

v

denote the same shape, so let us replace

e.g. u

s

z

and u

s

v

with u

s

w

. Similarly, we replace u

s

v2

with u

s

w2

.

We obtain conjuncts sh(v) = u

s

w

, sh(z) = u

s

w

, sh(uv2) = u

s

w2

:

We next ensure homomorphism property P3 in Definition 41. From conjuncts uvz = g(v; z), sh(uvz) = u

s

vz

, and

sh(v) = u

s

w

, we conclude

u

s

vz

= sh(uvz) =

sh(g(v; z)) =
g

s

(sh(v); sh(z)) =

g

s

(u

s

w

; u

s

w

)

so we add the conjunct u

s

vz

= g

s

(u

s

w

; u

s

w

) to the formula.

Similarly, from w = g(uw1; uw2), sh(w) = u

s

w

, sh(uw1) =

u

s

w1

, sh(uw2) = u

s

w2

we conclude u

s

w

= g(uw1; uw2) and add

this conjunct to the formula. Adding these two conjuncts
makes property P3 hold. (Note that, had we decided to
consider the case where sh(v) 6= sh(z) we would have arrived
at a contradiction due to sh(u

s

vz

) = sh(u

s

zv

).)

We next apply rule (25) to reduce all cardinality constraints into cardinality constraints on parameter nodes
(nodes u for which there there is no conjunct of form
u = f(ui

1

; : : : ; ui

k

)). We replace juvz " u

c

zv

jus

vz

= 0 with

juv " u

c

z

jus

w

= 0 ^ juz " u

c

v

jus

w

= 0 (34)

Variable v is a parameter variable, but z is not, which prevents application of (25). We therefore introduce uz1 and
uz2 such that z = g(uz1; uz2). Because sh(z) = u

s

w

, we have

sh(uz1) = u

s

w1

and sh(uz2) = u

s

w2

by homomorphism property. We can now continue applying rule (25) to (34). The
result is:

juv1 " u

c

z1

jus

w1

= 0 ^ juz1 " u

c

v1

jus

w1

= 0 ^

juv2 " u

c

z2

jus

w2

= 0 ^ juz2 " u

c

v2

jus

w2

= 0

To make the formula conform to Definition 41 we introduce
internal variables uv; uz; uw corresponding to free variables

v; z; w, respectively. The resulting structural base formula
is

9uvz; uzv; uv; uz; uw; uv1; uv2; uz1; uz2; uw1; uw2;

u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

:

shapeBase

1

^ termBase1 ^

hom1 ^ cardin1

(35)

where

shapeBase

1

= u

s

vz

= g

s

(u

s

w

; u

s

w

) ^ u

s

w

= g

s

(u

s

w1

; u

s

w2

) ^

distinct(u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

)

termBase1 = uvz = g(uv; uz) ^ uzv = g(uz; uv) ^

uv = g(uv1; uv2) ^ uz = g(uz1; uz2) ^
uw = g(uw1; uw2) ^
v = uv ^ z = uz ^ w = uw
hom1 =

sh(uvz) = u

s

vz

^ sh(uzv) = u

s

vz

^

sh(uv) = u

s

w

^ sh(uz) = u

s

w

^ sh(uw) = u

s

w

^

sh(uv1) = u

s

w1

^ sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

sh(uv2) = u

s

w2

^ sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

cardin1 = juv1 " u

c

z1

jus

w1

= 0 ^ juz1 " u

c

v1

jus

w1

= 0 ^

juv2 " u

c

z2

jus

w2

= 0 ^ juz2 " u

c

v2

jus

w2

= 0 ^

juw1 " u

c

v1

jus

w1

* 1

Figure 6 shows a graph representation of the subformulas
shapeBase

1

, termBase1, and hom1 of the resulting structural

base formula.

Recall that we are eliminating the quantification over v
from :9v:OE1. We can now existentially quantify over v. As
in Proposition 27, we simply remove the conjunct v = uv
from termBase and the quantifier 9v.

As in Figure 4 of Section 3.4 the structural base formula form allows us to eliminate an existential quantifier,
whereas the quantifier-free form allows us to eliminate a
negation. We transform the structural base formula (35)
into a quantifier-free formula as follows.

We first use rule (7) to eliminate variable uvz, replacing
it with g(v; z). In the resulting formula g(v; z) occurs only
in hom1 in the form

sh(g(uv; uz)) = u

s

vz

(36)

But (36) is a consequence of conjuncts u

s

vz

= g

s

(u

s

w

; u

s

w

),

sh(uv) = u

s

w

and sh(uw) = u

s

w

, so we omit (36) from the

formula. In analogous way we eliminate variable uzv and
the conjuncts that contain it. We also eliminate uv, analogously to uvz and uzv. In the resulting formula u

s

vz

occurs only in distinct subformula of shapeBase. Conjuncts
u

s

vz

6= u

s

w

, u

s

vz

6= u

s

w1

, and u

s

vz

6= u

s

w2

follow from the remaining conjuncts in shapeBase by acyclicity. Hence we may
replace distinct(u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

) by distinct(u

s

w

; u

s

w1

; u

s

w2

).

Now u

s

vz

does not occur in the matrix of the formula, so we

may eliminate 9u

s

vz

altogether.

20

The resulting formula is:
OE5 j 9uz; uw; uv1; uv2; uz1; uz2; uw1; uw2; u

s

w

; u

s

w1

; u

s

w2

:

u

s

w

= g

s

(u

s

w1

; u

s

w2

) ^ distinct(u

s

w

; u

s

w1

; u

s

w2

) ^

uz = g(uz1; uz2) ^ uw = g(uw1; uw2) ^
z = uz ^ w = uw ^
sh(uz) = u

s

w

^ sh(uw) = u

s

w

^

sh(uv1) = u

s

w1

^ sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

sh(uv2) = u

s

w2

^ sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

^

juv1 " u

c

z1

jus

w1

= 0 ^ juz1 " u

c

v1

jus

w1

= 0 ^

juv2 " u

c

z2

jus

w2

= 0 ^ juz2 " u

c

v2

jus

w2

= 0 ^

juw1 " u

c

v1

jus

w1

* 1

(37)
We next eliminate uv1. It suffices to eliminate it from conjuncts where it occurs, so we consider formula OE5;1:

OE5;1 j 9uv1:

sh(uv1) = u

s

w1

^ sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

juv1 " u

c

z1

jus

w1

= 0 ^ juz1 " u

c

v1

jus

w1

= 0 ^

juw1 " u

c

v1

jus

w1

* 1

(38)
Note that all variables from OE5;1 belong to B(s) where s
is the value of shape variable u

s

w1

(see (20)). This means

that we can apply quantifier elimination for boolean algebra
(Section 3.2) to eliminate uv1. The result is

OE5;2 j sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

juw1 " u

c

z1

jus

w1

* 1

(39)

Similarly, to eliminate uv2 we consider formula OE5;3:

OE5;3 j 9uv2:

sh(uv2) = u

s

w2

^ sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

^

juv2 " u

c

z2

jus

w2

= 0 ^ juz2 " u

c

v2

jus

w2

= 0

(40)
The result of boolean algebra quantifier elimination on OE5;3
is true (indeed, one may let uv2 = uz2). The resulting base
formula with uv1 and uv2 eliminated is OE6 :

OE6 j 9uz; uw; uz1; uz2; uw1; uw2; u

s

w

; u

s

w1

; u

s

w2

:

u

s

w

= g

s

(u

s

w1

; u

s

w2

) ^ distinct(u

s

w

; u

s

w1

; u

s

w2

) ^

uz = g(uz1; uz2) ^ uw = g(uw1; uw2) ^
z = uz ^ w = uw ^
sh(uz) = u

s

w

^ sh(uw) = u

s

w

^

sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

^

juw1 " u

c

z1

jus

w1

* 1

(41)

Observe that the equalities in OE6 are sufficient to express all
variables bound in OE6 in terms of free variables (all internal

variables are "covered"):

uz = z uw = w
uz1 = g1(z) uz2 = g2(z)
uw1 = g1(w) uw2 = g2(w)

u

s

w

= sh(w)

u

s

w1

= g

s

1

(sh(w)) u

s

w2

= g

s

2

(sh(w))

(42)

Structural base formula OE6 is therefore equivalent to the
quantifier-free formula OE7;1:

OE7;1 j Isgs(sh(w)) ^ Isg(w) ^ Isg(z) ^

distinct(g

s

1

(sh(w)); g

s

2

(sh(w)))

sh(z) = sh(w) ^ jg1(w) " g1(z)

c

j

g

s

1

(sh(w))

* 1

(43)
When transforming formula OE4 we chose the case u

s

w1

6= u

s

w1

.

If we choose the case u

s

w1

= u

s

w2

, we obtain quantifier-free

formula OE7;2:

OE7;2 j Isgs(sh(w)) ^ Isg(w) ^ Isg(z) ^

sh(z) = sh(w) ^ g

s

1

(sh(w)) = g

s

2

(sh(w)) ^

jg1(w) " g1(z)

c

j

g

s

1

(sh(w))

* 1

(44)
Our quantifier elimination would also consider the case
sh(g2(w)) 6= sh(g2(z)). The procedure finds the case contradictory in a larger context, when eliminating 9z, because
sh(z) = sh(x) = sh(w) follows from z ^ x and w ^ x. Ignoring this case, we observe that OE7;1 . OE7;2 is equivalent to
the quantifier-free formula OE8, where

OE8 j Isgs (sh(w)) ^ Isg(w) ^ Isg(z) ^

sh(z) = sh(w) ^ jg1(w) " g1(z)

c

j

g

s

1

(sh(w))

* 1

(45)
Let us therefore assume that the result of quantifier elimination in (28) is :OE8.

We proceed to eliminate the next quantifier, 8w, from

8w: w ^ x ^ w ^ y ) :OE8 (46)
(46) is equivalent to

:9w: w ^ x ^ w ^ y ^ OE8
After eliminating ^ we obtain

:9w: jw " x

c

j

sh(w)

= 0 ^ sh(x) = sh(w) ^

jw " y

c

j

sh(w)

= 0 ^ sh(y) = sh(w) ^

Isgs (sh(w)) ^ Isg(w) ^ Isg(z) ^
sh(z) = sh(w) ^ jg1(w) " g1(z)

c

j

g

s

1

(sh(w))

* 1

(47)
We now proceed similarly as in eliminating variable v. The
result is :OE9 where

OE9 j sh(x) = sh(z) ^ sh(y) = sh(z) ^

Isg(x) ^ Isg(y) ^ Isg(z) ^ Isgs (sh(z)) ^
jg1(x) " g1(y) " g1(z)

c

j

g

s

1

(sh(z))

* 1

(48)

The remaining quantifiers that bind z, y, and x are eliminated similarly.

21

To eliminate the quantifier 9z, we need to transform :OE9
into disjunction of base formulas. This transformation requires negation of OE9 and creates several disjuncts. We consider only the two cases, OE10 and OE11, that are not contradictory in the enclosing context of conjuncts z ^ x and z ^ y:

OE10 j sh(x) = sh(z) ^ sh(y) = sh(z) ^ :Isgs(sh(z))

(49)
OE11 j sh(x) = sh(z) ^ sh(y) = sh(z) ^

Isg(x) ^ Isg(y) ^ Isg(z) ^ Isgs(sh(z)) ^
jg1(x) " g1(y) " g1(z)

c

j

g

s

1

(sh(z))

= 0

(50)

OE10 is equivalent to

sh(x) = c

s

^ sh(y) = c

s

^ sh(z) = c

s

(51)

The result of eliminating 9z from

9z: jz " x

c

j

sh(z)

= 0 ^ jz " y

c

j

sh(z)

= 0 ^ OE10

is therefore

OE10;2 j sh(x) = sh(y) ^ :Isgs(sh(x)) (52)
The result of eliminating 9z from

9z: jz " x

c

j

sh(z)

= 0 ^ jz " y

c

j

sh(z)

= 0 ^ OE11

is

OE11;2 j sh(x) = sh(y) ^ Isgs (sh(x))

OE10;2 . OE11;2 is equivalent to sh(x) = sh(y). Converting

jx " y

c

j

sh(x)

= 0 ^ sh(x) = sh(y) ) sh(x) = sh(y)

to structural base formula yields true. We conclude that (27)
is a true sentence in the structure FT2, which completes our
quantifier elimination procedure example.

\Upsilon 

Formulas in the Example 42 do not contain disequalities between terms variables, only disequalities between shape variables. If a conjunction contains disequalities between term
variables, we eliminate the disequalities using rule (22) in
the process of converting formula to disjunction of structural base formulas. The following Example 43 illustrates
this process.

Example 43 Consider the formula

OE

0

6

j OE6 ^ uz 6= uw

Where OE6 is given by (41). By (22), literal uz 6= uw is
equivalent to 1 . 2 where

1 j sh(uz) 6= sh(uw) (53)
and

2 j sh(uz) = sh(uw) ^

j(uz " u

c

w

) [ (u

c

z

" uw)j

sh(uz)

* 1

(54)

unnested form cardinality constraint
x = x1 "s x2 jx + (x1 " x2)js = 0

x = x1 [s x2 jx + (x1 [ x2)js = 0
x = x

c

1s

jx + x

c

1

js = 0

Figure 7: Elimination of Boolean Algebra Unnested Formulas . Expression x + y is a shorthand for (x " y

c

) [ (y " x

c

).

In this case, formula OE6^1 is contradictory. Formula OE6^2
is equivalent to OE

00

6

where

OE

00

6

j 9uz; uw; uz1; uz2; uw1; uw2; u

s

w

; u

s

w1

; u

s

w2

:

u

s

w

= g

s

(u

s

w1

; u

s

w2

) ^ distinct(u

s

w

; u

s

w1

; u

s

w2

) ^

uz = g(uz1; uz2) ^ uw = g(uw1; uw2) ^
z = uz ^ w = uw ^
sh(uz) = u

s

w

^ sh(uw) = u

s

w

^

sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

^

juw1 " u

c

z1

jus

w1

* 1 ^

j(uz " u

c

w

) [ (u

c

z

" uw)jus

w

* 1

(55)

As in Example 42, we now apply rule (25) to

j(uz " u

c

w

) [ (u

c

z

" uw)jus

w

* 1

and transform OE

00

6

into a disjunction of base formulas.

\Upsilon 

We proceed to sketch the general case of quantifier elimination. The following Proposition 44 is analogous to Proposition 27; the proof is again straightforward.

Proposition 44 (Quantification of Structural Base)
If fi is a structural base formula and x a free term variable in fi, then there exists a base structural formula fi1
equivalent to 9x:fi.

The following Proposition 45 corresponds to Proposition 28.
Proposition 45 (Quantifier-Free to Structural Base)
Every well-defined quantifier-free formula OE in the language
of Figure 5 can be written as true, false, or a disjunction of
structural base formulas.

Proof Sketch. Let OE be a well-defined quantifier-free
formula in the language of Figure 5.

We first use rule (21) to eliminate occurrences of ^ in
the formula replacing them with cardinality constraints.

We then convert formula into disjunction OE1 . \Delta  \Delta  \Delta  . OEn of
well-formed conjunctions of literals. We next describe how
to transform each conjunction OEi into a disjunction of base
formulas.

Let OEi be a conjunction of literals. Using the technique
of Proposition 9, we convert the formula to unnested form,
adding existential quantifiers. We then eliminate unnested
conjuncts that contain boolean algebra operations, according to Figure 7. The only atomic formulas in the resulting

22

existentially quantified conjunction are of form x = a, x = b,
x = g(x1; x2), Isg(x), x1 = g1(x), x2 = g2(x), x1 = x2,
x

s

= c

s

, x

s

= g

s

(x

s

1

; x

s

2

), Isgs(x

s

), x

s

1

= g

s

1

(x

s

), x

s

2

= g

s

2

(x

s

),

x

s

1

= x

s

2

, x

s

= sh(x), as well as jt1jxs * k and jt2jxs = k for

some x

s

-terms t1 and t2. The only negated atomic formulas

are of form x1 6= x2, x

s

1

6= x

s

2

, :Isg(x) and :Isgs (x

s

). As in

the proof of Proposition 28, we use (17) to eliminate :Isg(x)
and :Isgs (x

s

). This process leaves formulas of form x1 6= x2

and x

s

1

6= x

s

2

as the only negated atomic formulas.

In the sequel, whenever we perform case analysis and
generate a disjunction of conjunctions, existential quantifiers
propagate to the conjunctions, so we keep working with a
existentially quantified conjunction. The existentially quantified variables will become internal variables of a structural
base formula.

We next convert conjuncts that contain only term variables to a base formula, and convert shape part to base
formula, as in the proof of Proposition 28. We simultaneously make sure every term variable has an associated shape
variable, introducing new shape variables if needed. (This
process is interleaved with conversion to base formula, to ensure that there is always a conjunct stating that newly introduced shape variables are distinct.) We also ensure homomorphism requirement by replacing internal variables when
we entail their equality. Another condition we ensure is that
parameter term variables map to parameter shape variables,
and non-parameter term variables to non-parameter shape
variables; we do this by performing expansion of term and
shape variables. We perform expansion of shape variables as
in Section 3.2. Expansion of term variables is even simpler
because there is no need to do case analysis on equality of
term variable with other variables.

The resulting existentially quantified conjunction might
contain disequalities u 6= u

0

between term variables. We

eliminate these disequalities as explained in Example 43,
by converting each disequality into a cardinality constraint
using (22). In general, we need to consider the case when
sh(u) 6= sh(u

0

) and generate another disjunct.

Elimination of disequalities might violate previously established homomorphism invariants, so we may need to
reestablish these invariants by repeating the previously described steps. The overall process terminates because we
never introduce new inequalities between term variables.

As a final step, we convert all cardinality constraints into
constraints on parameter term variables, using (25). In the
case when the shape of cardinality constraint is c

s

, we cannot apply (25). However, in that case the homomorphism
condition ensures that each of the participating variables is
equal to a or equal to b. This means that we can simply
evaluate the cardinality constraint in the boolean algebra
fa; bg. If the result is true we simply drop the constraint,
otherwise the entire base formula becomes false.

This completes our sketch of transforming a quantifierfree formula into disjunction of structural base formulas.

We introduce the notion of covered variables in structural
base formula by generalizing Definition 29.

Definition 46 The set covering of variable coverings of a
structural base formula fi is the least set S of pairs hu; ti
where u is an internal (shape or term) variable and t is a
term over the free variables of fi, such such that:

1. if x = u occurs in termBase then hu; xi 2 S;
2. if x

s

= u

s

occurs in shapeBase then hu

s

; x

s

i 2 S;

3. if hu; ti 2 S and u = f(u1; : : : ; uk) occurs in termBase

for some f 2 \Sigma  then fhu1; f1(t)i; : : : ; huk; fk(t)ig ` S;

4. if hu

s

; t

s

i 2 S and u

s

= f

s

(u

s

1

; : : : ; u

s

k

) occurs in

shapeBase then fhu

s

1

; f

s

1

(t

s

)i; : : : ; hu

s

k

; f

s

k

(t

s

)ig ` S;

5. if hu; ti 2 S and sh(u) = u

s

occurs in hom then

hu

s

; sh(t)i 2 S.

Definition 47 An internal term variable u is covered iff
there exists a term t such that hu; ti 2 S. An internal shape
variable u

s

is covered iff there exists a term t

s

such that

hu

s

; t

s

i 2 S.

Lemma 48 Let fi be a structural base formula with matrix
fi0 and let covering be the covering of fi.

1. If hu; ti 2 S then j= fi0 ) u = t.
2. If hu

s

; t

s

i 2 S then j= fi0 ) u

s

= t

s

.

Proof. By induction, using Definition 46.

Corollary 49 Let fi be a structural base formula such that
every internal variable is covered. Then fi is equivalent to a
well-defined quantifier-free formula.

Proof. By Lemma 48 using (7).

Lemma 50 Let u be an uncovered non-parameter term
variable in a structural base formula fi such that u is a source
i.e. no conjunct of form

u

0

= f(u1; : : : ; u; : : : ; uk)

occurs in termBase. Let fi

0

be the result of dropping u from

fi. Then fi is equivalent to fi

0

.

Proof. Let u occur in termBase in form

u = f(u1; : : : ; uk)
The only other occurrence of u in fi is in hom and has the
form sh(u) = u

s

. Because non-parameter term variables

are mapped to non-parameter shape variables, shapeBase
contains formula

u

s

= shapified(f)(u

s

1

; : : : ; u

s

k

) (56)

where u

s

1

; : : : ; u

s

k

are such that, by homomorphism property,

sh(ui) = u

s

i

occurs in hom. This means that the conjunct

sh(u) = u

s

is a consequence of the remaining conjuncts, so it

may be omitted. After that, applying (7) yields a structural
base formula fi

0

not containing u, where fi

0

is equivalent to

fi.

Corollary 51 Every base formula is equivalent to a base
formula without uncovered non-parameter term variables.

Proof. If a structural base formula has an uncovered
non-parameter term variable, then it has an uncovered nonparameter term variable that is a source. By repeated application of Lemma (50) we eliminate all uncovered nonparameter term variables.

The next example illustrates how we deal with cardinality constraints j1sjs * k and j1sj = k, which contain no
term variables. These constraints restrict the size of shape
s. Luckily, we can be translate them into shape base formula
constraints.

23

Example 52 (Shape Term Size Constraints)
Let x ! y denote conjunction x ^ y^x 6= y. Let us eliminate
quantifiers from formula 9x:OE(x) where

OE(x) j :(9y:9z: x ! y ^ y ! z) ^

:(9u: u ! x)

(57)

Eliminating variables y; z from the first conjunct and variable u from the second conjunct yields

:jx

c

j

sh(x)

* 2 ^ :jxj

sh(x)

* 1

which is equivalent to

(jx

c

j

sh(x)

= 0 . jx

c

j

sh(x)

= 1) ^ jxj

sh(x)

= 0

and further to disjunction

(jx

c

j

sh(x)

= 0 ^ jxj

sh(x)

= 0) . (jx

c

j

sh(x)

= 1 ^ jxj

sh(x)

= 0)

The first disjunct can be shown contradictory. Let us transform the second disjunct into a structural base formula. After introducing u = x and u

s

= sh(u), we obtain

9u; u

s

: x = u ^ sh(u) = u

s

^ jujus = 0 ^ ju

c

jus = 1

Then 9x:OE(x) is equivalent to

9u; u

s

: sh(u) = u

s

^ jujus = 0 ^ ju

c

jus = 1

Eliminating parameter term variable u yields

9u

s

: j1jus = 1

Constraint j1jus = 1 means that the largest set in the
boolean algebra B(s) where s is the value of u

s

has size

one. There exists exactly one boolean algebra of size one
in the structure FT2, namely fa; bg. Therefore, j1jus = 1 is
equivalent to u

s

= c

s

. We may now eliminate u

s

by letting

u

s

= c

s

. We conclude that the sentence 9x:OE(x) is true.

Notice that we have also established that formula OE(x)
is equivalent to sh(x) = c

s

, as a consequence of

j1

sh(x)

j

sh(x)

= 1

\Upsilon 

The following Proposition 53 corresponds to Proposition 38.

Proposition 53 (Struct. Base to Quantifier-Free)
Every structural base formula fi is equivalent to a quantifierfree formula OE in the language of Figure 5.

Proof Sketch. By Corollary 51 we may assume that fi
has no uncovered non-parameter term variables. By Corollary 49 we are done if there are no uncovered variables, so
it suffices to eliminate uncovered parameter term variables
and uncovered shape variables.

Let u be an uncovered parameter term variable. Then u
does not occur in termBase. Indeed, suppose for the sake of
contradiction that u occurs in termBase in some formula

u

0

= f(u1; : : : ; u; : : : ; uk)

Then u

0

is an uncovered non-parameter variable in fi, which

is a contradiction because we have assumed fi has no uncovered non-parameter variables. Therefore, u does no occur in

termBase, it occurs only in hom and cardin. Let sh(u) = u

s

occur in hom. Let 1; : : : ; p be all conjuncts of cardin that
contain u. Each i is of form jtijus * ki or jtijus = ki for
some u

s

-term ti. Let uj

1

; : : : ; uj

q

be all term variables appearing in ti terms other than u. Conjunct sh(uj

r

) = u

s

occurs in hom for each r where 1 ^ r ^ q. The base formula
can therefore be written in form

fi1 j 9x1; : : : ; xe; x

s

1

; : : : ; x

s

f

: OE ^ OE1

where

OE1 j 9u: sh(u) = u

s

^

sh(uj

1

) = u

s

^ : : : ^ sh(uj

q

) = u

s

^

1 ^ : : : ^ p

(58)

All term variables in 1; : : : ; k range over terms of shape
u

s

. Therefore, OE1 defines a relation in the boolean algebra

B(Ju

s

K). This allows us to apply construction in Section 3.2.

We eliminate u from 1 ^: : :^ p and obtain a propositional
combination 0 of cardinality constraints with u

s

-terms. OE0

does not contain variable u. We may assume that 0 is in
disjunctive normal form

0 j ff1 . : : : . ffw
Let

OE1;i j sh(uj

1

) = u

s

^ : : : ^ sh(uj

q

) = u

s

^ ffi

for 1 ^ i ^ w. Base formula fi1 is equivalent to disjunction
of base formulas fi1;i where

fi1;i j 9x1; : : : ; xe; x

s

1

; : : : ; x

s

f

: OE ^ OE1;i

We have thus eliminated an uncovered parameter term variable u from fi1. By repeating this process we eliminate all
uncovered parameter term variables from a base formula.
The resulting formula contains no uncovered term variables.

It remains to eliminate uncovered shape variables. This
process is similar to term algebra quantifier elimination in
Section 3.4. An essential part of construction in Section 3.4
is Lemma 25, which relies on the fact that uncovered parameter variables may take on infinitely many values. We
therefore ensure that uncovered parameter shape variables
are not constrained by term variables through conjuncts outside shapeBase.

Suppose that u

s

is an uncovered parameter shape variable in a base formula fi. u

s

does not occur in termBase.

u

s

does not occur in hom either, because all term variables

are covered, and a conjunct sh(u) = u

s

would imply that u

s

is covered. The only possible occurrence of u

s

is in cardinality constraint  of subformula cardin, where  is of form
jtjus = k or of form jtjus * k. Suppose there is some term
variable u occurring in t. Then sh(u) = u

s

so u

s

is covered,

which is a contradiction. Therefore, t has no variables. t
can thus be simplified to either 0us or 1us. In general, a constraint of form j1jus = k or j1jus * k is a domain cardinality
constraint for boolean algebra B(Ju

s

K) (see Remark 15 as

well as (20)). A constraint containing j0us j is equivalent to
true or false. A constraint j1jus = 0 is equivalent to false. A
constraint j1jus = k for k * 1 is equivalent to

u

s

= t

s

1

. \Delta  \Delta  \Delta  . u

s

= t

s

p

where t

s

1

; : : : ; t

s

p

is the list of all ground terms in signature \Sigma 0

that have exactly k occurrences of constant c

s

. We therefore

24

generate a disjunction of base formulas fi1; : : : ; fip where fii
results from fi by replacing j1jus = k with u

s

= t

s

i

. We convert each fii to a disjunction of base formulas by labelling
subterms of ti by internal shape variables and doing case
analysis on the equality between new internal shape variables to ensure the invariants of a base formula. The result
is a disjunction of base formulas where variable u

s

occurs

only in shapeBase subformula.

Similarly, j1jus * k + 1 is equivalent to :(j1jus = k) and
thus to

u

s

6= t

s

1

^ \Delta  \Delta  \Delta  ^ u

s

6= t

s

q

(59)

where t

s

1

; : : : ; t

s

q

is the list of all ground terms in signature

\Sigma 0 that have at most k occurrences of constant c

s

. We

replace j1jus * k + 1 by (59) and again convert the result
to a disjunction of base formulas where u

s

occurs only in

shapeBase subformula.

Each of the resulting base formulas fi

1

are such that every

uncovered variable in fi

1

is a shape variable that occurs only

in shapeBase. Let

fi

1

j 9u1; : : : ; un; u

s

1

; : : : ; u

s

p

s; u

s

p

s

+1

; : : : ; u

s

p

s

+q

s:

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s) ^

termBase(u1; : : : ; un; x1; : : : ; xm) ^
hom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

) ^

cardin(up+1; : : : ; up+q; u

s

p

s

+1

; : : : ; u

s

p

s

+q

s)

where u

s

1

; : : : ; u

s

p

s are uncovered shape variables. Then fi

1

is

equivalent to fi

2

:

fi

2

j 9u1; : : : ; un; u

s

p

s

+1

; : : : ; u

s

p

s

+q

s:

OE

2

(u

s

p

s

+1

; : : : ; u

s

p

s

+q

s; x

s

1

; : : : ; x

s

m

s )

termBase(u1; : : : ; un; x1; : : : ; xm) ^
hom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

) ^

cardin(up+1; : : : ; up+q; u

s

p

s

+1

; : : : ; u

s

p

s

+q

s)

Here OE

2

is a base formula (Definitions 19 and 21) whose free

variables are variables free in fi

2

as well as all covered shape

variables:

OE

2

(u

s

p

s

+1

; : : : ; u

s

p

s

+q

s; x

s

1

; : : : ; x

s

m

s) j 9u

s

1

; : : : ; u

s

p

s:

shapeBase(u

s

1

; : : : ; u

s

p

s ; u

s

p

s

+1

; u

s

p

s

+q

s; x

s

1

; : : : ; x

s

m

s )

Applying Lemma 37 we conclude that OE

2

is equivalent to

some disjunction

k
.

i=1

OE

3;i

of base formulas without uncovered variables. Let fi

3;i

be the

result of replacing OE

2

with OE

3;i

in fi

2

. Then fi

2

is equivalent

to

k
.

i=1

fi

3;i

and each fi

3;i

has no uncovered variables either, because

every free variable of OE

3;i

is either free or covered in fi

3;i

.

By Corollary 49 each fi

3;i

can be written as a quantifier free

formula.

The following Theorem 54 corresponds to 39 of Section 3.4.

Theorem 54 (Two Constants Quant. Elimination)
There exist algorithms A, B such that for a given formula
OE in the language of Figure 5:

a) A produces a quantifier-free formula OE

0

in selector language

b) B produces a disjunction OE

0

of structural base formulas

Proof. Analogous to proof of Theorem 39, using Proposition 45 in place of Proposition 28 and Proposition 53 in
place of Proposition 38.

Corollary 55 The first-order theory of the structure FT2 is
decidable.

This completes description of our quantifier elimination
for the first-order theory of structure FT2, which models
structural subtyping with two base types and one binary
constructor. It is straightforward to extend the construction of this section to any number of covariant constructors
if the base formula has only two constants. In Section 5 we
extend the result to any number of constants as well. Finally, in Section 6 we extend the result to allow arbitrary
decidable structures for primitive types, even if the number
of primitive types is infinite.

5 A Finite Number of Constants
In this section we prove the decidability of structural subtyping of any finite number of constant symbols (primitive
types) and any number of function symbols (constructors).
We first show the result when all constructors are covariant,
we then show the result when some of the constructors are
contravariant.

We introduce the notion of \Sigma -term-power of some structure C as a generalization of the structure of structural subtyping.

We represent primitive types in structural subtyping as
a structure C with a finite carrier C. We call C the base
structure. Without loss of generality, we assume that C has
only relations; functions and constants are definable using
relations. Let LC be a set of relation symbols and let ^ 2 LC
be a distinguished binary relation symbol. ^ represents the
subtype ordering between types. C is finite, so C is decidable
(see Section 6 for the case when C is infinite but decidable).

We represent type constructors as free operations in the
term algebra with signature \Sigma . To represent the variance
of constructors we define for each constructor f 2 \Sigma  of
arity ar(f) = k and each argument 1 ^ i ^ k the value
variance(f; i) 2 f\Gamma 1; 1g. The constructor f is covariant in
argument i iff variance(f; i) = 1. For convenience we assume
ar(f) * 1 for each f 2 \Sigma .

The \Sigma -term-power of C is a structure P defined as follows. Let \Sigma 

0

= \Sigma  [ C. The domain of P is the set P of

finite ground \Sigma 

0

-terms. Elements of C are viewed as constants of arity 1. The structure P has signature \Sigma [LC. The
constructors f 2 \Sigma  are interpreted in P as in a free term
algebra:

JfK

P

(t1; : : : ; tk) = f(t1; : : : ; tk)

A relation r 2 LC nf^g is interpreted pointwise on the terms
of same "shape" as follows. JrK

P

is the least relation ae such

that:

1. if JrK

C

(c1; : : : ; cn) then ae(c1; : : : ; cn)

25

2. if ae(ti1; : : : ; tin) for all i where 1 ^ i ^ k, then

ae(f(t11; : : : ; t1k); : : : ; f(tn1; : : : ; tnk))

The relation ^ 2 LC is interpreted similarly, but taking into
account the variance. J^K

P

is the least relation ae such that

1. if J^K

C

(c1; c2) then ae(c1; c2)

2. if

ae

variance(f;i)

(ti1; : : : ; tin)

for all i where 1 ^ i ^ k, then

ae(f(t11; : : : ; t1k); : : : ; f(tn1; : : : ; tnk))

Here we use the notation ae

v

for v 2 f\Gamma 1; 1g with the meaning: ae

1

= ae and ae

\Gamma 1

= fhy; xi j hx; yi 2 aeg.

We next sketch the decidability of structural subtyping
for any finite number of primitive types C. For now we assume that all constructors f 2 \Sigma  are covariant, the relation
^ thus does not play a special role.

5.1 Extended Term-Power Structure
For the purpose of quantifier elimination we define the structure PE by extending the domain and the set of operations
of the term-power structure P.

The domain of PE is PE = P [ PS where PS is the set
of shapes defined as follows. Let \Sigma 

s

= fc

s

g [ ff

s

j f 2 \Sigma g

be a set of function symbols such that c

s

is a fresh constant

symbol with ar(c

s

) = 0 and f

s

are fresh distinct constant

symbols with ar(f

s

) = ar(f) for each f 2 \Sigma . The set of

shapes PS is the set of ground \Sigma 

s

-terms. When referring to

elements of PE by term we mean an element of P ; by shape
we mean an element of PS. We write X

s

to denote an entity

pertaining to shapes as opposed to terms, so x

s

; u

s

denote

variables ranging over shapes, and t

s

to denotes terms that

evaluate to shapes.

The extended structure PE contains term algebra operations on terms and shapes (including selector operations and
tests, [22, Page 61]), the homomorphism sh, and cardinality
constraint relations jOEjts = k and jOEjts * k:

1. constructors in the term algebra of terms, f 2 \Sigma 

0

JfK

P

E

(t1; : : : ; tk) = f(t1; : : : ; tk);

2. selectors in term the algebra of terms,

JfiK

P

E

(f(t1; : : : ; tk)) = ti;

3. constructor tests in the term algebra of terms,

JIsf K

P

E

(t) = 9t1; : : : ; tk: t = f(t1; : : : ; tk);

4. constructors in the term algebra of shapes, f

s

2 \Sigma 

s

Jf

s

K

P

E

(t

s

1

; : : : ; t

s

k

) = f

s

(t

s

1

; : : : ; t

s

k

);

5. selectors in the term algebra of shapes,

Jf

s

i

K

P

E

(f

s

(t

s

1

; : : : ; t

s

k

)) = t

s

i

;

6. constructor tests in the term algebra of shapes,

JIsfsK

P

E

(t

s

) = 9t

s

1

; : : : ; t

s

k

: t

s

= f

s

(t

s

1

; : : : ; t

s

k

);

7. the homomorphism mapping terms to shapes such

that:

JshK

P

E

(f(t1; : : : ; tn)) =

shapified(f)(JshK

P

E

(t1); : : : ; JshK

P

E

(tn))

(60)

where

shapified(x) = c

s

; if x 2 C

shapified(f) = f

s

; if f 2 \Sigma 

(61)

8. cardinality constraint relations

JjOE(x1; : : : ; xk)jts = kK

P

E

(t1; : : : ; tk) =

jJOE(x1; : : : ; xk)K

P

E

(t1; : : : ; tk)j = k

(62)

and

JjOE(x1; : : : ; xk)jts * kK

P

E

(t1; : : : ; tk) =

jJOE(x1; : : : ; xk)K

P

E

(t1; : : : ; tk)j * k

(63)

where OE(x1; : : : ; xk) is is a first-order formula over the
base-structure language LC with free variables
x1; : : : ; xk, term t

s

denotes a shape, and k is a

nonnegative integer constant.

It remains to complete the semantics of cardinality constraint relations, by defining the set
JOE(x1; : : : ; xk)K

P

E

(t1; : : : ; tk). If s is a shape, we call

the set of positions of constant c

s

in s leaves of s, and

denote it by leaves(s). We represent a leaf as a sequence of
pairs hf; ii where f is a constructor of arity k and 1 ^ i ^ k.
If l 2 leaves(s) and sh(t) = s, then t[l] denotes the element
c 2 C at position l in term t i.e. if l = hf

1

; i

1

i : : : hf

n

; i

n

i

then

t[l] = f

n

i

n(: : : f

2

i

2 (f

1

i

1 (t)) : : :) (64)

We define:

JOE(x1; : : : ; xk)K

P

E

(t1; : : : ; tk) =

fl j JOE(x1; : : : ; xk)K

C

(t1[l]; : : : ; tk[l])g

(65)

The following equations follow from (65) and can be used as
an equivalent alternative definition for cardinality relations:

jJOE(x1; : : : ; xk)K

P

E

(c1; : : : ; ck)j =

(

1; JOE(x1; : : : ; xk)K

C

(c1; : : : ; ck)

0; :JOE(x1; : : : ; xk)K

C

(c1; : : : ; ck)

(66)

jJOE(x1; : : : ; xk)K

P

E

(f(t11; : : : ; t1l); : : : ; f(tk1; : : : ; tkl))j

= jJOE(x1; : : : ; xk)K

P

E

(t11; : : : ; tk1)j + : : :

+ jJOE(x1; : : : ; xk)K

P

E

(t1l; : : : ; tkl)j

(67)
Definition (65) generalizes [14, Definition 2.1, Page 63].
We write jOE(t1; : : : ; tk)jts = k as a shorthand for the
atomic formula (jOE(x1; : : : ; xk)jts = k)(t1; : : : ; tk), similarly
for jOE(t1; : : : ; tk)jts * k. This is more than a notational convenience, see Section 6 for an approach which introduces sets
of leaves as elements of the domain of PE and defines a cylindric algebra interpreted over sets of leaves. The approach in
this section follows [35] in merging the quantifier elimination
for products and quantifier elimination for boolean algebras.

Some of the operations in PE are partial. We use the
definitions and results of Section 2.3 to deal with partial
functions. fi(t) is defined iff Isf (t) holds, f

s

i

(t

s

) is defined

iff Isfs(t

s

) holds. Cardinality constraints jOE(t1; : : : ; tk)jts =

k and jOE(t1; : : : ; tk)jts * k are defined iff sh(t1) = : : : =
sh(tk) = t

s

holds.

The structure PE is at least as expressive as P because
the only operations or relations present in P but not in PE
are JrK

P

for r 2 LC, and we can express JrK

P

(t1; : : : ; tk) as

j: r(t1; : : : ; tk)j

sh(t1)

= 0.

Our goal is to give a quantifier elimination for first-order
formulas of structure PE. By a quantifier-free formula we
mean a formula without quantifiers outside cardinality constraints, e.g. the formula j8x:x ^ tjxs = k is quantifier-free.

26

5.2 Structural Base Formulas
In this section we define the notion of structural base formulas for any base structure C with a finite carrier.

Definition 56 of structural base formula for quantifier
elimination in PE differs from Definition 41 in the conjuncts
of cardin subformula. Instead of cardinality constraints on
boolean algebra terms, Definition 56 contains cardinality
constraints on first-order formulas.

The notion of base formula and Lemma 25 apply to terms
P as well as shapes PS in the structure PE because shapes
are also terms over the alphabet \Sigma 

s

. For brevity we write u

\Lambda 

for an internal shape or term variable, and similarly x

\Lambda 

for

a free shape or term variable, t

\Lambda 

for terms, f

\Lambda 

for term or

shape term algebra constructor and f

\Lambda 

i

for a term or shape

term algebra selector.

Definition 56 (Structural Base Formula)
A structural base formula with:

ffl free term variables x1; : : : ; xm;
ffl internal non-parameter term variables u1; : : : ; up;
ffl internal parameter term variables up+1; : : : ; up+q;
ffl free shape variables x

s

1

; : : : ; x

s

m

s;

ffl internal non-parameter shape variables u

s

1

; : : : ; u

s

p

s;

ffl internal parameter shape variables u

s

p

s; : : : ; u

s

p

s

+q

s

is a formula of the form:

9u1; : : : ; un; u

s

1

; : : : ; u

s

n

s :

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s) ^

termBase(u1; : : : ; un; x1; : : : ; xm) ^
termHom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s ) ^

cardin(up+1; : : : ; un; u

s

p

s

+1

; : : : ; u

s

n

s)

where n = p + q, n

s

= p

s

+ q

s

, and formulas shapeBase,

termBase, termHom, cardin are defined as follows.

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s ) =

p

s

V

i=1

u

s

i

= ti(u

s

1

; : : : ; u

s

n

s ) ^

m

s

V

i=1

x

s

i

= u

s

j

i

^ distinct(u

s

1

; : : : ; u

s

n

)

where each ti is a shape term of the form f

s

(u

s

i1

; : : : ; u

s

i

k

)

for some f 2 \Sigma 0, k = ar(f), and
j : f1; : : : ; m

s

g ! f1; : : : ; n

s

g is a function mapping indices

of free shape variables to indices of internal shape variables.

termBase(u1; : : : ; un; x1; : : : ; xm) =

p
V

i=1

ui = ti(u1; : : : ; un) ^

m
V

i=1

xi = uj

i

where each ti is a term of the form f(ui

1

; : : : ; ui

k

) for

some f 2 \Sigma , k = ar(f), and j : f1; : : : ; mg ! f1; : : : ; ng is
a function mapping indices of free term variables to indices
of internal term variables.

termHom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s ) =

n
V

i=1

sh(ui) = u

s

j

i

where j : f1; : : : ; ng ! f1; : : : ; n

s

g is some function such

that fj1; : : : ; jpg ` f1; : : : ; p

s

g and

fjp+1; : : : ; jp+qg ` fp

s

+ 1; : : : ; p

s

+ q

s

g (a term variable is

a parameter variable iff its shape is a parameter shape
variable).

cardin(up+1; : : : ; un; u

s

p

s

+1

; : : : ; u

s

n

s ) = 1 ^ \Delta  \Delta  \Delta  ^ d

where each i is a cardinality constraint of the form

jOE(uj

1

; : : : ; uj

l

)jus = k

or

jOE(uj

1

; : : : ; uj

l

)jus * k

where fj1; : : : ; jlg ` fp + 1; : : : ; ng and the conjunct
sh(uj

d

) = u

s

occurs in termHom for 1 ^ d ^ l. We require

each structural base formula to satisfy the following
conditions:

P0) the graph associated with shape base formula

9u

s

1

; : : : ; u

s

n

s : shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s)

is acyclic;
P1) congruence closure property for shapeBase subformula:

there are no two distinct variables u

s

i

and u

s

j

such that

both u

s

i

= f(u

s

l1

; : : : ; u

s

l

k

) and u

s

j

= f(u

s

l1

; : : : ; u

s

l

k

)

occur as conjuncts in formula shapeBase;

P2) congruence closure property for termBase subformula:

there are no two distinct variables ui and uj such that
both ui = f(ul

1

; : : : ; ul

k

) and uj = f(ul

1

; : : : ; ul

k

)

occur as conjuncts in formula termBase;

P3) homomorphism property of sh: for every

non-parameter term variable u such that
u = f(ui

1

; : : : ; ui

k

) occurs in termBase, if conjunct

sh(u) = u

s

occurs in termHom, then for some shape

variables u

s

j1

; : : : ; u

s

j

k

term u

s

= f

s

(u

s

j1

; : : : ; u

s

j

k

)

occurs in shapeBase where f

s

= shapified(f) and for

every r where 1 ^ r ^ k, conjunct sh(ui

r

) = u

s

jr

occurs in termHom.

Note that the validity of the occur check for term variables
follows from P0) and P3). Another immediate consequence
of Definition 56 is the following Proposition 57.

Proposition 57 (Quantification of Str. Base Form.)
If fi is a structural base formula and x a free shape or term
variable in fi, then there exists a base structural formula fi1
equivalent to 9x:fi.

We proceed to show that a quantifier-free formula can be
written as a disjunction of base formulas, and a base formula
can be written as a quantifier-free formula.

5.3 Conversion to Base Formulas
Conversion from a quantifier-free formula to the structural
base formula is given by Proposition 57. The proof of Proposition 58 is analogous to the proof of Proposition 45 but uses
of (67) instead of (25).

Proposition 58 (Quantifier-Free to Structural Base)
Every well-defined quantifier-free formula OE is equivalent
on PE to true, false, or some disjunction of structural base
formulas.

27

5.4 Conversion to Quantifier-Free Formulas
The conversion from structural base formulas to quantifierfree formulas is similar to the case of two constant symbols
in Section 4.3, but requires the use of Feferman-Vaught technique.

Definition 59 The set determinations of variable determinations of a structural base formula fi is the least set S of
pairs hu

\Lambda 

; t

\Lambda 

i where u

\Lambda 

is an internal term or shape variable

and t

\Lambda 

is a term over the free variables of fi, such such that:

1. if x

\Lambda 

= u

\Lambda 

occurs in termBase or shapeBase, then

hu

\Lambda 

; x

\Lambda 

i 2 S;

2. if hu

\Lambda 

; t

\Lambda 

i 2 S and u

\Lambda 

= f

\Lambda 

(u

\Lambda 

1

; : : : ; u

\Lambda 

k

) occurs in

shapeBase or termBase then
fhu

\Lambda 

1

; f

\Lambda 

1

(t

\Lambda 

)i; : : : ; hu

\Lambda 

k

; f

\Lambda 

k

(t

\Lambda 

)ig ` S;

3. if fhu

\Lambda 

1

; f

\Lambda 

1

(t

\Lambda 

)i; : : : ; hu

\Lambda 

k

; f

\Lambda 

k

(t

\Lambda 

)ig ` S and

u

\Lambda 

= f

\Lambda 

(u

\Lambda 

1

; : : : ; u

\Lambda 

k

) occurs in shapeBase or termBase

then hu

\Lambda 

; t

\Lambda 

i 2 S;

4. if hu; ti 2 S and sh(u) = u

s

occurs in termHom then

hu

s

; sh(t)i 2 S.

Definition 60 An internal variable u

\Lambda 

is determined if

hu

\Lambda 

; t

\Lambda 

i 2 determinations for some term t

s

. An internal variable is undetermined if it is not determined.

Lemma 61 Let fi be a structural base formula with matrix fi0 and let determinations be the determinations of fi. If
hu

\Lambda 

; t

\Lambda 

i 2 S then j= fi0 ) u

\Lambda 

= t

\Lambda 

.

Corollary 62 Let fi be a structural base formula such that
every internal variable is determined. Then fi is equivalent
to a well-defined quantifier-free formula.

Proof. By Lemma 61 using

9x:x = t ^ OE(x) () OE(t) (68)

Lemma 63 Let u be an undetermined non-parameter term
variable in a structural base formula fi such that u is a source
i.e. no conjunct of the form

u

0

= f(u1; : : : ; u; : : : ; uk)

occurs in termBase. Let fi

0

be the result of removing u and

conjuncts containing u from fi. Then fi is equivalent to fi

0

.

Proof. The conjunct containing u in termHom is a consequence of the remaining conjuncts, so we drop it. We then
apply (68).

Corollary 64 Every base formula is equivalent to a base
formula without undetermined non-parameter term variables.

Proof. If a structural base formula has an undetermined non-parameter term variable, then it has an undetermined non-parameter term variable that is a source. Repeatedly apply Lemma 63 to eliminate all undetermined
non-parameter term variables.

The following Lemma 65 is a consequence of the fact that
terms of a fixed shape s form a substructure of P isomorphic
to the finite power C

m

where m = jleaves(s)j and follows

from Feferman-Vaught theorem in Section 3.3.

Lemma 65 Let

ff j 9u: sh(u) = u

s

^

sh(u1) = u

s

^ : : : ^ sh(uk) = u

s

^

1 ^ : : : ^ p

(69)

where each i is a cardinality constraint of the form jOEjus =
k or jOEjus * k where all free variables of OE are among
u; u1; : : : ; uk. Then there exists formula  such that 
is a disjunction of conjunctions of cardinality constraints
jOE

0

j = k and jOE

0

j * k where the free variables in each OE

0

are

among u1; : : : ; uk and formula ff is equivalent on PE to ff

0

where

ff

0

j sh(u1) = u

s

^ : : : ^ sh(uk) = u

s

^  (70)

Proposition 66 (Struct. Base to Quantifier-Free)
Every structural base formula fi is equivalent on PE to
some well-defined quantifier-free formula OE.

Proof Sketch. By Corollary 64 we may assume that fi has
no undetermined non-parameter term variables. By Corollary 62 we are done if there are no undetermined variables,
so it suffices to eliminate undetermined parameter term variables and undetermined shape variables.

Let u be an undetermined parameter term variable. u
does not occur in termBase because it cannot have a successor or a predecessors in the graph associated with term base
formula. Therefore, u

0

occurs only in termHom and cardin.

Let u

s

be the shape variable such that u

s

= sh(u) occurs

in termHom. Let 1; : : : ; p be all conjuncts of cardin that
contain u.

Each i is of the form jOEjus * ki or jOEjus = ki and for
each variable u

0

free in OE the conjunct sh(u) = u

s

occurs

in termHom. The base formula can therefore be written in
form

fi1 j 9x1; : : : ; xe; x

s

1

; : : : ; x

s

f

: OE ^ ff

where ff has the form as in Lemma 65. Applying Lemma 65
we eliminate u and obtain  =

W

w

i=1

ffi where and each ffi is

a conjunction of cardinality constraints. Base formula fi1 is
thus equivalent to the disjunction

W

w

i=1

fi1;i where each fi1;i

is a base formula

fi1;i j 9x1; : : : ; xe; x

s

1

; : : : ; x

s

f

: OE ^ OE1;i

By repeating this process we eliminate all undetermined parameter term variables from a base formula. Each of the
resulting base formulas contains no undetermined term variables.

It remains to eliminate undetermined shape variables.
This process is similar to term algebra quantifier elimination; the key ingredient is Lemma 25, which relies on
the fact that undetermined parameter variables may take
on infinitely many values. We therefore ensure that undetermined parameter shape variables are not constrained
by term and parameter variables through conjuncts outside
shapeBase.

Consider an undetermined parameter shape variable u

s

.

u

s

does not occur in termHom, because all term variables

are determined and a conjunct u

s

= sh(u) would imply that

u

s

is determined as well. u

s

can thus occur only in cardin

within some cardinality constraint jOEjus = k or jOEjus * k.
Moreover, formula OE in each such cardinality constraint is
closed: otherwise OE would contain some free variable u, by

28

definition of base formula u would have to be a parameter variable, all parameter term variables are determined,
so u

s

would be determined as well. Let u

s

denote some

shape s. Because OE is a closed formula, jOEj is equal to

0 if JOEK

C

= false and to the shape size m = jleaves(s)j if

JOEK

C

= true. (The fact that closed formulas reduce to the

constraints on domain size appears in [35, Theorem 3.36,
Page 13].) After eliminating constraints equivalent to 0 = k
and 0 * k, we obtain a conjunction of simple linear constraints of the form m = k and m * k. These constraints
specify a finite or infinite set S ` f0; 1; : : :g of possible sizes
m. Let A = fs j jleaves(s)j 2 Sg. If the set S is infinite
then it contains an infinite interval of form fm0; m0 + 1; : : :g
so the set A is infinite. If \Sigma  contains a unary constructor and S is nonempty, then A is infinite. If \Sigma  contains
no unary constructors and S is finite then A is finite and
the cardinality constraints containing u

s

are equivalent to
W

p

i=1

u

s

= t

s

i

where A = ft

s

1

; : : : ; t

s

p

g. We therefore generate a disjunction of base formulas fi1; : : : ; fip where fii results from fi by replacing cardinality constraints containing
u

s

with with u

s

= t

s

i

. We convert each fii to a disjunction

of base formulas by labelling subterms of ti with internal
shape variables and doing case analysis on the equality between new internal shape variables to ensure the invariants
of a base formula, as in the proof of 58. By repeating this
process for all shape variables u

s

where the set S is finite,

we obtain base formulas where the set A is infinite for every
undetermined parameter shape variable u

s

. We may then

eliminate all undetermined parameter and non-parameter
shape variables along with the conjuncts that contain them.
The result is an equivalent formula by Lemma 25.

All variables in each of the resulting base formulas are
determined. By Corollary 62 each formula can be written
as a quantifier-free formula, and the resulting disjunction is
a quantifier-free formula.

5.5 One-Relation-Symbol Variance
So far we have assumed that all constructors are covariant.
In this section we describe the changes needed to extend
the result to the case when the constructors have arbitrary
variance with respect to some distinguished binary relation
denoted ^.

Definition 67 If OE is a first-order formula in the language
LC the contravariant version of OE, denoted OE

(\Gamma 1)

, is defined

by induction on the structure of formula by:

(r(t1; : : : ; tk))

(\Gamma 1)

= r(t1; : : : ; tk); if r 2 LC n f^g

(t1 ^ t2)

(\Gamma 1)

= t2 ^ t1

(OE1 ^ OE2)

(\Gamma 1)

= OE1

(\Gamma 1)

^ OE2

(\Gamma 1)

(OE1 . OE2)

(\Gamma 1)

= OE1

(\Gamma 1)

^ OE2

(\Gamma 1)

(:OE)

(\Gamma 1)

= :OE

(\Gamma 1)

(9t:OE)

(\Gamma 1)

= 9t:OE

(\Gamma 1)

(8t:OE)

(\Gamma 1)

= 8t:OE

(\Gamma 1)

(71)
Define C

\Gamma 1

to have the same domain and same interpretation

of operations and relations r 2 LC n f^g but where

J^K

C

\Gamma 1

= (J^K

C

)

\Gamma 1

(72)

We clearly have for every formula OE and every valuation oe:

JOE

(\Gamma 1)

K

C

= JOEK

C

\Gamma 1

(73)

If l 2 leaves(s) is a leaf l = hf

1

; i

1

i : : : hf

n

; i

n

i, define

variance(l) as the product of integers

n
Y

j=1

variance(f

j

; i

j

) (74)

We generalize (65) to

JOE(x1; : : : ; xk)K

P

E

(t1; : : : ; tk) =

fl j JOE(x1; : : : ; xk)K

C

0

(t1[l]; : : : ; tk[l])g

(75)

where C

0

denotes C for variancel = 1 and C

\Gamma 1

for variancel \Gamma 

1. Hence, isomorhism between terms of some fixed shape
s with jleaves(s)j = m and C

m

breaks, but there is still an

isomorphism with C

P(s)

\Theta  (C

\Gamma 1

)

N(s)

where

P (s) = jfl 2 leaves(s) j variance(l) = 1gj
N(s) = jfl 2 leaves(s) j variance(l) = \Gamma 1gj

(76)

Because of this isomorphism, Lemma 65 still holds and we
may still use Feferman-Vaught theorem from Section 3.3.

Equation (67) generalizes to:

jJOE(x1; : : : ; xk)K

P

E

(f(t11; : : : ; t1l); : : : ; f(tk1; : : : ; tkl))j

=

P

l

i=1

jJOE

(variance(f;l))

(x1; : : : ; xk)K

P

E

(t1i; : : : ; tki)j

(77)
The only change in the proof of Proposition 58 is the use
of (77) instead of (67). Most of the proof of Proposition 66
remains unchanged as well; the only additional difficulty is
eliminating constraints of the form jOEjus = k and jOEjus * k
where u

s

is a parameter shape variable and OE is a closed

formula. Lemma 68 below addresses this problem.

We say that an algorithm g finitely computes some function f : A ! 2

B

where B is an infinite set iff g is a function

from A to the set Fin(B) [ f1g where Fin(B) is the set of
finite subsets of set B, 1 is a fresh symbol, and

g(a) =

(

f(a); if f(a) 2 Fin(B)

1; if f(a) =2 Fin(B)

(78)

Lemma 68 There exists an algorithm that, given a shape
variable u

s

and a conjunction  j

V

n

i=1

i of cardinality

constraints where each i is of form jOEijus = ki or jOEijus * ki
for some closed formula OEi, finitely computes the set

A = fs j JK

P

[u

s

7! s]g (79)

of shapes which satisfy  in P.
Proof Sketch. Let OE be a closed formula in language LC.
Compute JOEK

C

and JOE

(\Gamma 1)

K

C

and then replace jOEjs with one

of the expressions P (s) + N(s), P (s), N(s), 0 according to
the following table.

JOEK

C

JOE

(\Gamma 1)

K

C

jOEjs =

true true P (s) + N(s)

true false P (s)
false true N(s)
false false 0

(80)

29

The constraints of the form N(s) + P (s) = k and N(s) +
P (s) = k can be expressed as propositional combinations of
constraints of the form N(s) = k, P (s) = k, P (s) * k and
N(s) * k. Therefore,  can be written as a propositional
combination of these four kinds of constraints and each conjunction C(s) can further be assumed to have one of the
forms:

F1) Ck

P

;k

N

(s) j P (s) = kP ^ N(s) = kN;

F2) C

k

P

;k

+

N

(s) j P (s) = kP ^ N(s) * kN;

F3) C

k

+

P

;k

N

(s) j P (s) * kP ^ N(s) = kN;

F4) C

k

+

P

;k

+

N

(s) j P (s) * kP ^ N(s) * kN.

Let A = fs 2 PS j C(s)g. To compute A when \Sigma  contains
unary constructors, we first restrict \Sigma  to the language \Sigma 

0

with no unary constructors, and compute the set A

0

` A

using language \Sigma 

0

. If A

0

is empty, so is A, otherwise A is

infinite. Assume that \Sigma  contains no unary constructors. Assume further \Sigma  contains at least one binary constructor and
at lest one constructor is contravariant in some argument.
Let

S = fhP (s); N(s)i j s 2 Ag

Because P (s)+N(s) = jleaves(s)j and there are only finitely
many shapes of any given size (every constructor is of arity
at least two), it suffices to finitely compute S. S can be
given an alternative characterization as follows. If f 2 \Sigma ,
ar(f) = k, f is covariant in l arguments and contravariant
in k\Gamma l arguments define

JfK

S

(hp1; n1i; : : : ; hpk; nki) =

h

P

l

i=1

pi +

P

k

i=l+1

ni;

P

l

i=1

ni +

P

k

i=l+1

pii

(81)

Let U be the subset of fhp; ni j p; n * 0g generated from
element h1; 0i using operations JfK

S

for f 2 \Sigma . Then

S = fhp; ni 2 U j c(p; n)g (82)
where c(p; n) is the linear constraint corresponding to the
constraint C(s).

Let C(s) = Ck

P

;k

N

(s). Then S ` fhp; ni j p + n =

kP + kNg. S is therefore a subset of a finite set and is easily
computable, which solves case F1).

Let C(s) = C

k

+

P

;k

+

N

(s). Because \Sigma  contains a binary constructor, S contains pairs hp; ni with arbitrarily large p+n,
so either the p components or n component of elements of
S grows unboundedly. Because \Sigma  contains a constructor f
contravariant in some argument, we can define using f an
operation o acting as a constructor covariant in at least one
argument and contravariant in at least one argument. Using
operation on tuples whose one component grows unboundedly yields tuples whose both components grow unboundedly. Therefore, S is infinite, which solves case F4).

Finally, consider the case C(s) = C

k

P

;k

+

N

(s) (this will

solve the case C(s) = C

k

+

P

;k

N

(s) as well). Observe that

C

k

P

;k

+

N

(s) = C

k

P

;0

+ (s) ^

k

P

\Gamma 1

^

i=0

:Ck

P

;i(s) (83)

Because the set S for each Ck

P

;i(s) is finite, it suffices to

finitely compute S for C

k

P

;0

+(s). In that case

S = fhp; ni 2 U j p = kP g (84)

Let

Si = fhp; ni 2 U j p = ig

Ti = fhp; ni 2 U j n = ig

(85)

To finitely compute S, finitely compute the sets Si and Ti
for 0 ^ i ^ kP . The algorithm starts with all sets Si and Ti
empty and keeps adding elements according to operations
JfK

S

.

Assume that S0; T0; : : : ; Si\Gamma 1; Ti\Gamma 1 are finitely computed.
The computation of Si and Ti proceeds as follows. Let f 2 \Sigma 
be a constructor of arity k with l covariant arguments. For
Si we consider all solutions of the equation

p1 + \Delta  \Delta  \Delta  + pl + nl+1 + : : : + nk = i (86)
for nonnegative integers p1; : : : ; pl; nl+1; : : : ; nk. First consider solution solutions where no variable is equal to i. If for
one of the solutions, one of the sets Sp

1

; : : : ; Sp

l

is infinite,

then Si is infinite, otherwise add to Si all elements hi; ni
where

n = n1 + \Delta  \Delta  \Delta  + nl + pl+1 + : : : + pk (87)

If n ^ kP then also add the same elements hi; ni to Tn.
Next, proceed analogously with Ti, considering solutions of

n1 + \Delta  \Delta  \Delta  + nl + pl+1 + : : : + pk = i (88)
If at this point Si is not infinite and not empty, then also
consider the solutions of (87) where pj = i for some j. If
such solution exists, then mark Si as infinite. Proceed analogously with Ti. Finally, if both Si and Ti are still finite
but there exists a solution for Si where nl+j = i for some j
and exists a solution for Tj where pl+d = i for some d, then
mark both Si and Ti as infinite. This completes the sketch
of one step of the computation. (This step also applies to
S0 and T0; we initially assume that h1; 0i 2 T0.)

Example 69 Let us apply this algorithm to the special case
where \Sigma  = ff; gg and

variance(g) = h1; 1i
variance(f) = h\Gamma 1; 1i
Let us see what the set S looks like. If hx; yi 2 S define
khx; yi = hkx; kyi as in a vector space.

First, h1; 0i 2 S because of c

s

. Next h1; 1i 2 S because

of f

s

and h2; 0i 2 S because of g

s

.

More generally, we have the following composition rule:
If hp1; n1i; hp2; n2i then

hp1 + p2; n1 + n2i 2 S
because of g

s

, and

hn1 + p2; p1 + n2i 2 S
because of f

s

.

Using g

s

we obtain all pairs hp; 0i for p * 1. Using f

s

once on those we obtain h1; ni for n * 0. Adding these we
additionally obtain hp; ni for p * 2 and n * 0. Hence we
have all pairs hp; ni for p * 1 and n * 0 and those are the
only ones that can be obtained. Thus,

S = fhp; ni j p * 1 ^ n * 0g
As expected, the case F1) yields a finite and the case F4)
an infinite set. The case F2) for kP = 0 is an empty set,
otherwise it is an infinite set. The case F3) always yields
an infinite set. This solves the problem for two constructors
f; g.

30

lifted relations r

0

for r 2 LC

r

0

:: term

k

! bool

term algebra on terms
constructors, f 2 \Sigma :

f :: term

k

! term

constructor test, f 2 \Sigma :
Isf :: term ! bool
selectors, f 2 \Sigma :

fi :: term ! term

Figure 8: Basic Operations of \Sigma -term-power Structure
\Upsilon 

Lemma 68 allows to carry our the proof of Proposition 66
so we obtain our main result for finite C.

Theorem 70 (Term Power Quant. Elimination)
There exists an algorithm that for a given well-defined
formula OE produces a quantifier-free formula OE

0

that is

equivalent to OE on PE.

Corollary 71 (Decidability of Structural Subtyping)
Let C be a structure with a finite carrier and P a \Sigma -termpower of C. Then the first-order theory of P is decidable.

6 Term-Powers of Decidable Theories
In this section we extend the result of Section 5 on decidability of term-powers of a base structure C to allow C to be an
arbitrary decidable theory, even if the carrier C is infinite.

To keep a finite language in the case when C is infinite,
we introduce a predicate IsPRI that allows testing whether
t 2 C for a term t 2 P .

In structural base formulas, we now distinguish between
1) composed variables, denoting elements t 2 P for which
Isf (t) holds for some constructor f 2 \Sigma , and 2) primitive
variables, denoting elements t 2 P for which IsPRI(t) holds.

Another generalization compared to Section 5 is the use
of a syntactically richer language for term power algebras; to
some extent this richer language can be viewed as syntactic
sugar and can be simplified away.

The generalization to infinitely many primitive types and
the generalization to a richer language are orthogonal.

For most of the section we focus on covariant constructors, Section 6.5 discusses a generalized notion of variance.

As in Section 3.3 let C = hC; Ri be a decidable structure
where C is a non-empty set and R is a set of relations interpreting some relational language LC, such that each r 2 R
is a relation of arity ar(r) on set C, i.e. r ` C

ar(r)

. We

assume that R contains a binary relation symbol r

=

2 R,

interpreted as equality on the set C.

Operations and relations of the \Sigma -term-power structure
are summarized in Figure 8. We will show the decidability of
the first-order theory of the structure with these operations.

In the special case when C = fa; bg and

r = fha; ai; ha; bi; hb; big

we obtain the theory in Section 4. When R = frg where r is
a partial order on types, we obtain the theory of structural
subtyping of non-recursive covariant types. For arbitrary
relational structure C, if f 2 \Sigma  for ar(f) = k we obtain a
structure that properly contains the k-th strong power of
structure C, in the terminology of [35].

The structure of this section follows Sections 4. We also
associate a boolean algebra of sets with each term t. However, in this case, the elements of the associated boolean
algebra are sets of occurrences of the constants that satisfy the given first-order formula interpreted over C. The
occurrences of constants within the terms of a given shape
correspond to the indices of the product structure in Section 3.3. We call these occurrences leaves, because they can
be represented as leaves of the tree corresponding to a term.

6.1 Product Theory of Terms of a Given Shape
In this section we define the notions shape and leafset, and
state some properties that we use in the sequel.

Let

\Sigma 0 = fc

s

g [ ff

s

j f 2 \Sigma g

be a set of function symbols such that c

s

is a fresh constant

symbol with ar(c

s

) = 0 and f

s

are fresh distinct constant

symbols with ar(f

s

) = ar(f) for each f 2 \Sigma . Let shapified :

\Sigma 

0

! \Sigma 0 be defined by

shapified(x) = c

s

; if x 2 C

shapified(f) = f

s

; if f 2 \Sigma 

Let FT(\Sigma 0) be the set of ground terms with signature \Sigma 0
and FT(\Sigma 

0

) the set of ground terms of signature \Sigma 

0

.

Define function sh :: FT(\Sigma 

0

) ! FT(\Sigma 0) mapping each

term to its shape by

sh(f(t1; : : : ; tn)) = shapified(f)(sh(t1); : : : ; sh(tn))
for each f 2 \Sigma 

0

. Define t1 , t2 iff sh(t1) = sh(t2).

Let t be a term or shape and t

0

the tree representing t as

in Section 2.2. If p is a path such that t

0

(p) is defined and

denotes a constant, we write t[p] to denote t

0

(p) and call p a

leaf. Note that t[p] is defined iff sh(t)[p] is defined. On the
set of equivalent terms leaves act as indices of Section 3.3. If
s is a shape, let leaves(s) denote the set of all leaves defined
on shape s.

Generalizing tCont of Section 4.1, define function tCont :
FT(\Sigma 

0

) ! C

\Lambda 

by:

tCont(c) = c

s

; if c 2 C

tCont(f(t1; : : : ; tk)) = tCont(t1) \Delta  : : : \Delta  tCont(tk)

Define ffi(t) = hsh(t); tCont(t)i and

B = fhs; wi j s 2 FT(\Sigma 0); w 2 C

\Lambda 

; tLen(s) = sLen(w)g

If all constructors f 2 \Sigma  are covariant then ffi is a bijection
between FT(\Sigma 

0

) and B. Let

B(s0) = fhs; wi 2 B j s = s0g
For a fixed s0, the set B(s0) is isomorphic to the power
structure C

n

where n = tLen(s).

For each shape s we introduce operations from Section 3.3. To distinguish the sets of positions belonging to
different shapes, we tag each set of positions L with a shape

31

s. We call the pair hs; Li a leafset. The interpretation of
each relation r 2 LC is the leafset:

JrsK(t1; : : : ; tk) = hs; fp j JrK

C

(t1[p]; : : : ; tk[p])gi

We let ^

I

s

, .

I

s

, :

I

s

, true

I

s

, false

I

s

stand for intersection, union,

complement, full set and empty set in the algebra of subsets
of the set leaves(s). We also introduce 9

I

s

as the union of a

family of subsets indexed by a term of shape s and 8

I

s

as the

intersection of a family of subsets indexed by a term.

We use constructor-selector language for the term algebra on terms. We introduce constructor-selector language
on shapes by generalizing operations in Section 4.1 in a natural way. In addition, we introduce a constructor-selector
language on leafsets. For each f 2 \Sigma  we introduce a constructor symbol f

L

on leafsets and define

leafified(f) = f

L

Constructors f

L

act on leafsets as follows. If Li ` leaves(si)

for 1 ^ i ^ k define

f

L

(hs1; L1i; : : : ; hsk; Lki) = hs; Li

where s = f

s

(s1; : : : ; sk), and L ` leaves(s) is given by

L = (f1g \Delta  L1) [ \Delta  \Delta  \Delta  [ (fkg \Delta  Lk)
(Here we define A \Delta  B = fa \Delta  b j a 2 A ^ b 2 Bg.)

We define selector functions on leafsets as follows. If s =
f

s

(s1; : : : ; sk) and L ` leaves(s), then f

L

i

(hs; Li) = hsi; Lii

where Li ` leaves(si) is defined by

Li = fw j w \Delta  i 2 Ag
Equivalently, we require that

f

L

i

(f

L

(hs1; L1i; : : : ; hsn; Lni)) = hsi; Lii

We can now express relations r

0

in Figure 8 using the fact:

r

0

(t1; : : : ; tk) ()

sh(t2) = sh(t1) ^ : : : ^ sh(tk) = sh(t1) ^
r

sh(t1)

(t1; : : : ; tk) = true

I

sh(t1)

(89)

To handle an infinite number of elements of the base
structure C, we do not introduce into the language constants
for every element of C as in Section 5. Instead, we introduce
the predicate IsPRI :: term ! bool called primitive-term test
that checks whether a term is a constant:

IsPRI(x) = (x 2 C)
and the predicate Is

PRI

L :: leafset ! bool called primitiveleafset test:

Is

PRI

L (hs; Li) = (s = c

s

)

Instead of the rule (16), we have for f; g 2 \Sigma  [ fPRIg:

8x:

W

f2\Sigma [fPRIg

Isf (x)

8x: :(Isf (x) ^ Isg(x)); for f 6j g

(90)

Analogous rules hold for term algebra of leafsets:

8x:

W

f2\Sigma [fPRIg

Is

f

L(x)

8x: :(Is

f

L(x) ^ Is

g

L(x)); for f 6j g

(91)

Term algebra of shapes satisfies the original rules (16) of
term algebra.

6.2 A Logic for Term-Power Algebras
To show the decidability of the first-order theory of the
structure FT\Lambda  with operations in Figure 8, we show decidability for a richer structure. Figure 9 shows the operations
and relations of this richer structure.

The structure has four sorts: bool representing truth values, term representing terms, shape representing shapes, and
leafset representing sets of leaves within a given shape. The
structure can be seen as as a combination of the operations
of Figure 5 and Figure 2.

For each relation symbol r 2 R we define a relation symbol r

\Lambda 

of sort shape \Theta  term

k

! bool acting on terms of the

same shape. While in Section 4.2 we associate a boolean
algebra with the terms of same shape, in this section we
associate a cylindric algebra [21] with terms of the same
shape. This is a particularly simple cylindric algebra resulting from lifting first-order logic on the base structure
C so that elements are replaced by terms of a given shape
(which are isomorphic to functions from leaves to elements),
and boolean values are replaced by sets of leaves (isomorphic to functions from leaves to booleans). In both cases,
operations on the set X are lifted to operations on the set
leaves(s) ! X. Syntactically, we introduce a copy of all

propositional connectives and quantifiers: ^

I

, .

I

, :

I

, true

I

,

false

I

. Like boolean algebra operations in Figure 5, these

syntactic constructs in Figure 9 take an additional shape
argument, because term-power algebra contains one copy of
a strong power C

n

of base structure for each shape. We call

formulas built using the operations of the cylindric algebra
inner formulas.

For each operation in Figure 2 there is an operation in
Figure 9, potentially taking a shape as an additional argument (for operations used to build inner formulas). The logic
further contains term algebra operations on terms, leafsets,
and shapes.

We use undecorated identifiers (e.g. u) to denote variables of term sort, variables with superscript S to denote
shape variables (e.g. u

s

) and variables with superscript L to

denote leafset variables (e.g. u

L

).

Figures 10 and 11 show the semantics of logic in Figure 9. The first row specifies semantics of operations in the
case when all arguments are defined and are in the domain
of the operation. The domain of each operation is in the
second column, it is omitted if it is equal to the entire domain resulting from interpreting the sort of the operation.
All operations except for plain logical operations and quantifiers over the bool domain are strict. Logical operations
and quantifiers over the bool domain are defined as in the
three-valued logic of Section 2.3.

We remark that values of leafset act as terms with two
constants in Figure 5. In fact, if the base structure C has
only two constants then the formula x = a and its propositional combinations are sufficient to express all facts about
C, so in that case there is no need to distinguish between
terms and leafsets.

6.3 Some Properties of Term-Power Structure
In this section we establish some further properties of the
term-power structure, including the homomorphism properties between the term algebra of terms and the term algebra
of leafsets. We also argue that it suffices to consider a restricted class of formulas called simple formulas.

32

per-shape product structure
inner formula relations for r 2 LC:

r :: shape \Theta  term

k

! leafset

inner logical connectives:

^

I

; .

I

:: shape \Theta  leafset \Theta  leafset ! leafset

:

I

:: leafset ! leafset

true

I

; false

I

:: leafset

inner formula quantifiers:

9

I

; 8

I

:: shape \Theta  (term ! leafset) ! leafset

leafset equality:

=

L

:: leafset \Theta  leafset ! bool

leafset cardinality constraints, k * 0:
j j * k; j j = k :: shape \Theta  leafset ! bool
leafset quantifiers:

9

L

; 8

L

:: (leafset ! bool) ! bool

term equality:

= :: term \Theta  term ! bool
term quantifiers:

9; 8 :: (term ! bool) ! bool
shape equality:

=

s

:: shape \Theta  shape ! bool

shape quantifiers:

9

s

; 8

s

:: (shape ! bool) ! bool

logical connectives:

^;. :: bool \Theta  bool ! bool

: :: bool ! bool
true; false; undef :: bool

term algebra on terms
constructors, f 2 \Sigma :

f :: term

k

! term

constructor test, f 2 \Sigma :

Isf :: term ! bool
primitive-term test:

IsPRI :: term ! bool
selectors, f 2 \Sigma :

fi :: term ! term
term shape:

sh :: term ! shape

term algebra on leafsets
constructors, f 2 \Sigma :

f

L

:: leafset

k

! leafset

constructor test, f 2 \Sigma :

Is

f

L :: leafset ! bool

primitive-leafset test:
Is

PRI

L :: leafset ! bool

selectors, f 2 \Sigma :

f

L

i

:: leafset ! leafset

leafset shape:

lssh :: leafset ! shape

term algebra on shapes
constructors, f 2 \Sigma 0:

f

s

:: shape

k

! shape

constructor test, f 2 \Sigma 0:

Isfs :: shape ! bool
selectors, f 2 \Sigma :

f

s

i

:: shape ! shape

Figure 9: Operations and relations in structure P

33

interpretation of sorts
JtermK = FT(\Sigma 

0

)

JshapeK = FT(\Sigma 0)
JleafsetK = fhs; Li j L ` leaves(s)g

JboolK = ftrue; false; undefg

semantics well-definedness
inner formula relations for r 2 LC:

JrK(s; t1; : : : ; tk) = hs; fl j JrK

C

(t1[l]; : : : ; tk[l])gi sh(t1) = s ^ : : : ^ sh(tk) = s

inner logical connectives:
J^

I

K(s; hs1; L1i; hs2; L2i) = hs; L1 " L2i s1 = s ^ s2 = s

J.

I

K(s; hs1; L1i; hs2; L2i) = hs; L1 [ L2i s1 = s ^ s2 = s

J:

I

K(s; hs1; L1i) = hs; leaves(s) n L1i s1 = s

Jtrue

I

K(s) = hs; leaves(s)i

Jfalse

I

K(s) = hs; ;i

inner formula quantifiers, for h : JtermK ! JleafsetK:

J9

I

K(s; h) = hs;

S

fL j 9t 2 JtermK: sh(t) = s ^ h(t) = hs; Ligi 8t 2 JtermK: lssh(h(t)) = s

J8

I

K(s; h) = h

T

fL j 9t 2 JtermK: sh(t) = s ^ h(t) = hs; Lig; i 8t 2 JtermK: lssh(h(t)) = s

leafset equality:

J=

L

K(hs1; L1i; hs2; L2i) = s1 = s2 ^ L1 = L2

leafset cardinality constraints:

Jjhs1; L1ijs * kK = (jL1j * k) s1 = s
Jjhs1; L1ijs = kK = (jL1j = k) s1 = s
leafset quantifiers, for h : JleafsetK ! JboolK:

J9

L

Kh = 9hs; ti 2 JleafsetK: h(hs; ti)

J8

L

Kh = 8hs; ti 2 JleafsetK: h(hs; ti)

term equality:

J=K(t1; t2) = (t1 = t2)
term quantifiers, for h : JtermK ! JboolK:

J9Kh = 9t 2 JtermK: h(t)
J8Kh = 8t 2 JtermK: h(t)
shape equality:

J=

s

K(t

s

1

; t

s

2

) = (t

s

1

= t

s

2

)

shape quantifiers, for h : JshapeK ! JboolK:

J9

s

Kh = 9t 2 JshapeK: h(t)

J8

s

Kh = 8t 2 JshapeK: h(t)

Figure 10: Semantics for Logic of Term-Power Algebra (Part I)

34

semantics well-definedness
term algebra on terms

constructors, f 2 \Sigma :

JfK(t1; : : : ; tk) = f(t1; : : : ; tk)
constructor test, f 2 \Sigma :

JIsf K(t) = 9t1; : : : ; tk: t = f(t1; : : : ; tk)
primitive-term test:

JIsPRIK(t) = (t 2 C)
selectors, f 2 \Sigma :

JfiK(t) = fflti: t = f(t1; : : : ; ti; : : : ; tk) JIsf K(t)
term shape:

Jsh(f(t1; : : : ; tn))K = shapified(f)(sh(t1); : : : ; sh(tn))

term algebra on leafsets
constructors, f 2 \Sigma :
Jf

L

K(hs1; L1i; : : : ; hsk; Lki) = hf(s1; : : : ; sk); (f1g \Delta  L1) [ \Delta  \Delta  \Delta  [ (fkg \Delta  Lk)i

constructor test, f 2 \Sigma :

JIs

f

LK(hs; Li) = 9s1; L1; : : : ; sk; Lk: hs; Li = Jf

L

K(hs1; L1i; : : : ; hsk; Lki)

primive-leafset test:

JIs

PRI

LK(hs; Li) = (s = c

s

)

selectors, f 2 \Sigma :

Jf

L

i

K(hs; Li) = fflhsi; Lii: hs; Li = Jf

L

K(hs1; L1i; : : : ; hsi; Lii; : : : ; hsk; Lki) JIs

f

LK(hs; Li)

leafset shape:

JlsshK(hs; Li) = s

term algebra on shapes
constructors, f 2 \Sigma :

Jf

s

K(s1; : : : ; sk) = f

s

(s1; : : : ; sk)

constructor test, f 2 \Sigma 0:

JIsfsK(s) = 9s1; : : : ; sk: s = f

s

(s1; : : : ; sk)

selectors, f 2 \Sigma :

Jf

s

i

K(s) = fflsi: s = f

s

(s1; : : : ; si; : : : ; sk) JIsfsK(s)

Figure 11: Semantics for Logic of Term-Power Algebra (Part II)

35

Recall that r

=

2 R is the equality relation on C. Given

r

=

, we can express the equality between terms by:

t1 = t2 () r

=0

(t1; t2)

() sh(t2) = sh(t1) ^ r

=

(t1; t2) = true

I

sh(t1)

(92)
We define the notion of a u

s

-term as in Definition 40

except that we use different symbols for boolean algebra
operations.

Definition 72 (u

s

-terms) Let u

s

2 Var

s

be a shape variable. The set of u

s

-terms Term(u

s

) is the least set such that:

1. u

L

2 Term(u

s

) for every leafset variable u

L

;

2. false

I

u

s; true

I

u

s 2 Term(u

s

);

3. if t

L

1

; t

L

2

2 Term(u

s

), then also

t

L

1

^

I

u

s t

L

2

2 Term(u

s

);

t

L

1

.

I

u

s t

L

2

2 Term(u

s

); and

:

I

u

st

L

1

2 Term(u

s

)

If t

s

is a term of shape sort, the notion of t

s

-inner formula

is defined as follows.

Definition 73 (u

s

-inner formula) Let u

s

2 Var

s

be a

shape variable. The set of u

s

-inner formulas Inner(u

s

) is

the least set such that:

1. if u1; : : : ; uk are term variables and r 2 LC such that

ar(r) = k, then

rus(u1; : : : ; uk) 2 Inner(u

s

)

2. false

I

u

s; true

I

u

s 2 Inner(u

s

)

3. if OE1; OE2 2 Inner(u

s

) then also

OE1 ^

I

u

s OE2 2 Inner(u

s

)

OE1 .

I

u

s OE2 2 Inner(u

s

)

:

I

u

s OE1 2 Inner(u

s

)

4. if OE 2 Inner(u

s

) and u is a term variable that does not

occur in u

s

, then also

9

I

u

su:OE 2 Inner(u

s

)

8

I

u

su:OE 2 Inner(u

s

)

If OE 2 Inner(u

s

) and u1; : : : ; un is the set of free term variables of OE, we write OE(u

s

; u1; : : : ; un) for OE. Furthermore, if

t

s

is a term of shape sort and t1; : : : ; tn terms of term sort,

we write OE(t

s

; t1; : : : ; tn) for

OE[u

s

:= t

s

; u1 := t1; : : : ; un := tn]

where we assume that variables bound by 9

I

and 8

I

are

renamed to avoid the capture of variables that are free in
t

s

; t1; : : : ; tn.

We call OE(t

s

; t1; : : : ; tn) an instance of the u

s

-inner formula OE(u

s

; u1; : : : ; un).

If OE(u

s

; u1; : : : ; un) is an inner formula, we abbreviate it by writing [OE

0

(u1; : : : ; un)]us where OE

0

results from

OE(u

s

; u1; : : : ; un) by omitting the shape argument u

s

from

the operations occurring in OE(u

s

; u1; : : : ; un). Similarly, we

write [OE

0

(t1; : : : ; tn)]ts for OE(t

s

; t1; : : : ; tn).

According to the semantics in Figure 10, sh is a homomorphism from the term algebra of terms to the term algebra of shapes. In addition, lssh is a homomorphism from the
term algebra of leafsets to the term algebra of shapes.

We also have the following important property. Let r 2
LC be a relation symbol of arity n, let f 2 \Sigma  be a function
symbol of arity k, and let

sh(t1j) = : : : = sh(tnj) = sj
for 1 ^ j ^ k. If f

s

= shapified(f), f

L

= leafified(f), and

s = f

s

(s1; : : : ; sk) then

rs(f(t11; : : : ; t1k); : : : ; f(tn1; : : : ; tnk)) =

f

L

(rs

1

(t11; : : : ; tn1); : : : ; rs

k

(t1k; : : : ; tnk))

(93)

Furthermore, if lssh(lj) = lssh(l

0

j

) = sj for 1 ^ j ^ k and

s = f

s

(s1; : : : ; sk) then

f

L

(l1; : : : ; lk) ^

I

s

f

L

(l

0

1

; : : : ; l

0

k

) =

L

f

L

(l1 ^

I

s1

l

0

1

; : : : ; lk ^

I

s

k

l

0

k

)

f

L

(l1; : : : ; lk) .

I

s

f

L

(l

0

1

; : : : ; l

0

k

) =

L

f

L

(l1 ^

I

s1

l

0

1

; : : : ; lk ^

I

s

k

l

0

k

)

:

I

s

f

L

(l1; : : : ; lk) =

L

f

L

(:

I

s1

l1; : : : ; :

I

s

k

lk)

9

I

s

t:f

L

(h1(t); : : : ; hk(t)) =

L

f

L

(9

I

s1

t:h1(t); : : : ; 9

I

s

k

t:hk(t))

8

I

s

t:f

L

(h1(t); : : : ; hk(t)) =

L

f

L

(8

I

s1

t:h1(t); : : : ; 8

I

s

k

t:hk(t))

(94)

From these properties by induction we conclude that if
OE(u

s

; u1; : : : ; un) is an inner formula, then

OE(s; f(t11; : : : ; t1k); : : : ; f(tn1; : : : ; tnk)) =

f

L

(OE(s1; t11; : : : ; tn1); : : : ; OE(sk; t1k; : : : ; tnk))

(95)

Let OE(u

s

; u1; : : : ; un) be an inner formula and let

OE

0

(u1; : : : ; un) be a first-order formula that results from replacing operations ^

I

s

; .

I

s

; :

I

s

, 8

I

s

; 9

I

s

by ^; .; :, 8; 9. Interpreting OE

0

(u1; : : : ; un) over the structure C yields a relation

ae

0

` C

n

. If

sh(t1) = : : : = sh(tk) = s

then

JOEK(s; t1; : : : ; tk) = hs; fl j ae

0

(t1[l]; : : : ; tk[l])gi

The following Definition 75 introduces a more restricted
set of formulas than the set of formulas permitted by sort
declarations in Figure 9. We call this restricted set of formulas simple formulas. One of the main properties of simple
formulas compared to arbitrary formulas is that simple formulas allow the use of operations 9

I

; 8

I

, and relations r ,

r 2 LC only within instances of u

s

-inner formulas.

Definition 74 A simple operation is any operation or relation in Figure 9 except for operations 9

I

; 8

I

, and relations

r for r 2 LC.

36

Definition 75 (Simple Formulas) The set of simple formulas is the least set that satisfies the following.

1. if OE(u

s

; u1; : : : ; un) is a an inner formula, t

s

a term of

shape sort, t1; : : : ; tn terms of term sort and u

L

is a

leafset variable, then

u

L

=

L

OE(t

s

; t1; : : : ; tn)

is a simple formula.
2. applying simple operations to simple formulas yields

simple formulas.

Example 76 A formula

u

L

=

L

9

I

u

s

1

u: rus

2

(u; u) (96)

is not a simple formula for u

s

1

6j u

s

2

. Formula

(u

s

1

= u

s

2

^ u

L

=

L

9

I

u

s

1

u: rus

1

(u; u)) .

(u

s

1

6= u

s

2

^ undef)

is a simple formula equivalent to formula (96). We abbreviate 9

I

u

s

1

u: rus

1

(u; u) as [9

I

u: r(u; u)]us

1

.

\Upsilon 

Lemma 77 shows that for every formula in the logic of
Figure 9 there exists an equivalent simple formula. Note
that even simple formulas are sufficient to express the relations of structural subtyping. A reader not interested in
the decidability of the more general logic of Figure 9 may
therefore ignore Lemma 77.

Lemma 77 (Formula Simplification) For every welldefined formula in the logic of Figure 9 there exists an equivalent well-defined simple formula.

Proof Sketch. According to the definition of simple formula, we need to ensure that every occurrence of quantifiers
8

I

; 9

I

and relations r is an occurrence in some inner-formula

instance OE(t

s

; t1; : : : ; tn). Each occurrence rts(t1; : : : ; tn) is

an inner formula instance by itself, so the main difficulty is
fitting the quantifiers 8

I

and 9

I

into inner formulas.

Let us examine the syntactic structure of formulas of
logic in Figure 9. This syntactic structure is determined
by sort declarations. Each expression of leafset is formed
starting from

1. relations r 2 LC;
2. leafset variables;
3. true

I

; false

I

using operations ^

I

, .

I

, :

I

, 8

I

, 9

I

, as well as f

L

and f

L

i

. The

leafset expressions can be used in a formula in the following
ways (in addition to constructing new leafset expressions):

1. to compare for equality using =

L

;

2. to test for the top-level constructor using Is

f

L;

3. to form leafset cardinality constraints;
4. to form a shape using lssh.

Because the top-level sort of a formula is bool, every
term t

L

0

of sort leafset occurs within some formula t

L

1

=

L

t

L

2

or Is

f

L(t

L

), jt

L

jts = k, jt

L

jts * k or as part of some term

lssh(t

L

). We can replace Is

f

L(t

L

) with

9u

L

: u

L

=

L

t

L

^

0

Is

f

L(u

L

)

according to Lemma 10, so we need not consider that case.
We can similarly eliminate non-variable leafset terms from
cardinality constraints. If a leafset term t

L

occurs in an

expression lssh(t

L

), we consider the smallest atomic formula

(lssh(t

L

)) enclosing lssh(t

L

), and replace (t

L

) with

9u

L

: u

L

=

L

t

L

^

0

(u

L

)

This transformation is valid by Lemma 10 because  and
lssh are strict.

We further assume that in every atomic formula t

L

1

=

L

t

L

2

,

the term t

L

1

is a leafset variable.

Suppose that a term t

L

in a formula u

L

=

L

t

L

is not an

instance of an inner formula. Then there are two possibilities.

1. There are some occurrences of leafset term algebra operations f

L

, f

L

i

or leafset variables u

L

1

in t

L

. Here by

"occurrence" in t

L

we mean occurrence that is reachable

without going through a shape argument or a relation,
but only through operations 8

I

; 9

I

, ^

I

; .

I

; :

I

. For example, we ignore the occurrences of f

L

, f

L

i

within terms

t

s

that occur in ^

I

t

s.

2. not all shape arguments in 8

I

; 9

I

, ^

I

; .

I

; :

I

,

true

I

; false

I

, r occurring in t

L

are syntactically identical.

We eliminate the first possibility by propagating leafset
term algebra operations f

L

, f

L

i

inwards until they reach expressions of form Lt

s

(t1; : : : ; tn), applying the equations (94)

from left to right. We then convert f

L

, f

L

i

operations of

term algebra of leafsets into operations of the term algebra
of terms applying (93) from right to left.

To eliminate the second possibility, let t

s

1

; : : : ; t

s

n

be the

occurrences (reachable through true

I

; false

I

, ^

I

, .

I

, :

I

,

8

I

, 9

I

) in term t

L

of the shape arguments of operations

true

I

; false

I

, ^

I

, .

I

, :

I

, 8

I

, 9

I

. Then replace

u

L

= t

L

(t

s

1

; : : : t

s

n

)

with

(9

s

u

s

: 8

CL

1

(u

s

=

s

t

s

1

) ^

0

: : : ^

0

8

CL

n

(u

s

=

s

t

s

n

)^

0

u

L

=

L

t

L

(u

s

; : : : ; u

s

)) .

(undef ^

W

1^i!j^n

t

s

i

6= t

s

j

)

Here 8

CL

i

denotes universal quantification 8ui;1; : : : ; ui;n

i

where ui;1; : : : ; ui;n

i

is a list of those term variables occurring in t

s

i

that are bound by some quantifier 9

I

; 8

I

within t

L

.

6.4 Quantifier Elimination
In this section we give a quantifier elimination procedure for
the term-power structure. The procedure of this section is
applicable whenever C is a structure with a decidable firstorder theory.

37

Definition 78 below generalizes the notion of structural
base formula of Definition 41, Section 4.3. There are two
main differences between Definition 41 and the present Definition 78.

The first difference is the presence of three (instead of
two) base formulas: shape base, leafset base, and term base.
This difference is a consequence of the distinction between
leafsets and terms and is needed whenever base structure
C has more than two elements. There is a homomorphism
formula relating leafset base formula to shape base formula
and a homomorphism formula relating term base formula to
shape base formula. Furthermore, some of the leafset variables are determined by term variables using inner formula
maps, which establishes the relationship between term base
formula and leafset base formula. Cardinality constraints
now apply to leafset variables.

The second difference is the distinction between composed and primitive non-parameter leafset and term variables. A composed non-parameter variable denotes a leafset
or a term whose shape s has property Isfs(s) for some f 2 \Sigma .
A primitive non-parameter variable denotes a leafset or a
term whose shape is c

s

and has property IsPRI or Is

PRI

L. The

purpose of this distinction is to allow cardinality constraints
and inner formula maps not only on parameter variables,
but also on primitive non-parameter variables, which is useful when the base structure C is decidable but infinite.

Definition 78 (Structural Base Formula)

A structural base formula with:

ffl free term variables x1; : : : ; xm;
ffl internal composed non-parameter term variables

u1; : : : ; ur;

ffl internal primitive non-parameter term variables

ur+1; : : : ; up;

ffl internal parameter term variables up+1; : : : ; up+q;
ffl free leafset variables x

L

1

; : : : ; x

L

m

L;

ffl internal composed non-parameter leafset variables

u

L

1

; : : : ; u

L

r

L;

ffl internal primitive non-parameter leafset variables

u

L

r

L

+1

; : : : ; u

L

p

L ;

ffl internal parameter leafset variables u

p

L

+1

; : : : ; u

p

L

+q

L;

ffl free shape variables x

s

1

; : : : ; x

s

m

s;

ffl internal non-parameter shape variables u

s

1

; : : : ; u

s

p

s;

ffl internal parameter shape variables u

s

p

s; : : : ; u

s

p

s

+q

s

is a formula of form:

9u1; : : : ; un; u

L

1

; : : : ; u

L

n

L ; u

s
1

; : : : ; u

s

n

s :

shapeBase(u

s

1

; : : : ; u

s

n

s ; x

s

1

; : : : ; x

s

m

s) ^

leafsetBase(u

L

1

; : : : ; u

L

n

L ; x

L
1

; : : : ; x

L

m

L) ^

leafsetHom(u

L

1

; : : : ; u

L

n

L; u

s
1

; : : : ; u

s

n

s) ^

termBase(u1; : : : ; un; x1; : : : ; xm) ^
termHom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s ) ^

cardin(u

L

r

L

+1

; : : : ; u

L

n

L; u

s
p

s

+1

; : : : ; u

s

n

s ) ^

innerMap(ur+1; : : : ; un; u

L

r

L

+1

; : : : ; u

L

n

L; u

s

p

s

+1

; : : : ; u

s

n

s)

where n = p + q, n

L

= p

L

+ q

L

, n

s

= p

s

+ q

s

, and formulas shapeBase, leafsetBase, termBase, leafsetHom, termHom,
cardin, innerMap are defined as follows.

shapeBase(u

s

1

; : : : ; u

s

n

s; x

s

1

; : : : ; x

s

m

s) =

p

s

V

i=1

u

s

i

= ti(u

s

1

; : : : ; u

s

n

s ) ^

m

s

V

i=1

x

s

i

= u

s

j

i

^ distinct(u

s

1

; : : : ; u

s

n

)

where each ti is a shape term of form f

s

(u

s

i1

; : : : ; u

s

i

k

) for

some f 2 \Sigma 0, k = ar(f), and j : f1; : : : ; m

s

g ! f1; : : : ; n

s

g is

a function mapping indices of free shape variables to indices
of internal shape variables.

leafsetBase(u

L

1

; : : : ; u

L

n

L ; x

L
1

; : : : ; x

L

m

L ) =

r

L

V

i=1

u

L

i

= ti(u

L

1

; : : : ; u

L

n

L) ^

p

L

V

i=r

L

+1

Is

PRI

L (u

L

i

) ^

m

L

V

i=1

x

L

i

= u

L

j

i

where each ti is a term of form f(ui

1

; : : : ; ui

k

) for some

f 2 \Sigma , k = ar(f), and j : f1; : : : ; m

L

g ! f1; : : : ; n

L

g is a

function mapping indices of free leafset variables to indices
of internal leafset variables.

leafsetHom(u

L

1

; : : : ; u

L

n

L ; u

s
1

; : : : ; u

s

n

s ) =

n

L

V

i=1

lssh(u

L

i

) = u

s

j

i

where j : f1; : : : ; n

L

g ! f1; : : : ; n

s

g is some function such

that fj1; : : : ; jpg ` f1; : : : ; p

s

g and fj

p

L

+1

; : : : ; j

p

L

+q

Lg `

fp

s

+1; : : : ; p

s

+q

s

g (a leafset variable is a parameter variable

iff its shape is a parameter shape variable).

termBase(u1; : : : ; un; x1; : : : ; xm) =

r
V

i=1

ui = ti(u1; : : : ; un) ^

p
V

i=r+1

IsPRI(ui) ^

m
V

i=1

xi = uj

i

where each ti is a term of form f(ui

1

; : : : ; ui

k

) for some

f 2 \Sigma , k = ar(f), and j : f1; : : : ; mg ! f1; : : : ; ng is a
function mapping indices of free term variables to indices of
internal term variables.

termHom(u1; : : : ; un; u

s

1

; : : : ; u

s

n

s ) =

n
V

i=1

sh(ui) = u

s

j

i

where j : f1; : : : ; ng ! f1; : : : ; n

s

g is some function such

that fj1; : : : ; jpg ` f1; : : : ; p

s

g and fjp+1; : : : ; jp+qg ` fp

s

+

1; : : : ; p

s

+ q

s

g (a term variable is a parameter variable iff its

shape is a parameter shape variable).

cardin(u

L

r

L

+1

; : : : ; u

L

n

L ; u

s

p

s

+1

; : : : ; u

s

n

s ) = 1 ^ \Delta  \Delta  \Delta  ^ d

where each i is of form

jt

L

(u

L

r

L

+1

; : : : ; u

L

n

L )ju

s = k

38

or

jt

L

(u

L

r

L

+1

; : : : ; u

L

n

L)ju

s * k

for some u

s

-term t

L

(u

L

r

L

+1

; : : : ; u

L

n

L) that contains no variables other than some of the variables u

L

r

L

+1

; : : : ; u

L

n

L , and

the following condition holds:

If a variable u

L

j

for r

L

+ 1 ^ j ^ n

L

occurs in

the term t

L

(u

L

r

L

+1

; : : : ; u

L

n

L), then lssh(u

L
j

) =

u

s

occurs in formula leafsetHom.

(97)

innerMap(ur+1; : : : ; un; u

L

r

L

+1

; : : : ; u

L

n

L ; u

s
p

s

+1

; : : : ; u

s

n

s ) =

j1 ^ \Delta  \Delta  \Delta  ^ je
where each ji is of form

u

L

j

= OE

I

(u

s

; ui

1

; : : : ; ui

k

)

for some inner formula OE

I

(u

s

; ui

1

; : : : ; ui

k

) 2 Inner(u

s

)

where L + 1 ^ j ^ n

L

i.e. u

L

j

is a primitive

non-parameter leafset variable or parameter leafset variable, fui

1

; : : : ; ui

k

g ` fur+1; : : : ; ung are primitive nonparameter term variables and parameter variables, the conjunct lssh(u

L

) = u

s

occurs in leafsetHom, and the following

condition holds:

sh(ui

j

) = u

s

occurs in formula termHom for

every j where 1 ^ j ^ k.

(98)

We require each structural base formula to satisfy the following conditions:

P0) the graph associated with shape base formula

9u

s

1

; : : : ; u

s

n

s : shapeBase(u

s

1

; : : : ; u

s

n

s; x

s

1

; : : : ; x

s

m

s)

is acyclic (compare to Definition 21);
P1) congruence closure property for shapeBase subformula:

there are no two distinct variables u

s

i

and u

s

j

such that

both u

s

i

= f(u

s

l1

; : : : ; u

s

l

k

) and u

s

j

= f(u

s

l1

; : : : ; u

s

l

k

) occur

as conjuncts in formula shapeBase;

P2) congruence closure property for leafsetBase subformula:

there are no two distinct variables u

L

i

and u

L

j

such that

both u

L

i

= f

L

(u

L

l1

; : : : ; u

L

l

k

) and u

L

j

= f

L

(u

L

l1

; : : : ; u

L

l

k

)

occur as conjuncts in formula leafsetBase;

P3) congruence closure property for termBase subformula:

there are no two distinct variables ui and uj such that
both ui = f(ul

1

; : : : ; ul

k

) and uj = f(ul

1

; : : : ; ul

k

) occur

as conjuncts in formula termBase;

P4) homomorphism property of lssh: for every nonparameter leafset variable u

L

such that u

L

=

f

L

(u

L

i1

; : : : ; u

L

i

k

) occurs in leafsetBase, if conjunct

lssh(u

L

) = u

s

occurs in leafsetHom, then for some shape

variables u

s

j1

; : : : ; u

s

j

k

term u

s

= f

s

(u

s

j1

; : : : ; u

s

j

k

) occurs

in shapeBase where f

s

= shapified(f) and for every r

where 1 ^ r ^ k, conjunct lssh(ui

r

) = u

s

jr

occurs in

leafsetHom.

P5) homomorphism property of sh: for every non-parameter

term variable u such that u = f(ui

1

; : : : ; ui

k

) occurs in termBase, if conjunct sh(u) = u

s

occurs in

termHom, then for some shape variables u

s

j1

; : : : ; u

s

j

k

term u

s

= f

s

(u

s

j1

; : : : ; u

s

j

k

) occurs in shapeBase where

f

s

= shapified(f) and for every r where 1 ^ r ^ k,

conjunct sh(ui

r

) = u

s

jr

occurs in termHom.

As in Section 3.4 and Section 4.3 we proceed to show that
each quantifier-free formula can be written as a disjunction
of base formulas and each base formula can be written as
a quantifier-free formula. We first give a small example to
illustrate how the techniques of Section 4.3 extend to the
more general case of \Sigma -term-power.

Example 79 We solve one subproblem from Example 42
using the language of term-power algebras.

Consider the formula

9v: g(v; z) ^ g(z; v) ^ Isg(v) ^ Isg(w) ^

:(g1(w) ^ g1(v))

(99)

Formula (99) is in the language of Figure 8, with ^ a binary
lifted relation. After converting (99) into the language of
Figure 9 we obtain as one of the possible cases formula:

9v: [g(v; z) _ g(z; v)]

sh(g(z;v))

=

L

true

I

sh(g(z;v))

^

sh(g(z; v)) =

s

sh(g(z; v)) ^

Isg(v) ^ Isg(w) ^
[g1(w) _ g1(v)]

sh(g1(w))

6=

L

true

I

sh(g1(w))

^

sh(g1(v)) =

s

sh(g1(w))

(100)

where _ is the subtyping relation on the base structure C so
that ^ = _

0

. We next transform the formula into unnested

form, obtaining:

9v; uvz; uzv; uw1; uv1: 9

L

u

L

vz

; u

L

w1

: 9

s

u

s

vz

; u

s

w1

:

uvz = g(v; z) ^ uzv = g(z; v) ^
uw1 = g1(w) ^ uv1 = g1(v) ^
u

s

vz

=

s

sh(uvz) ^ u

s

w1

=

s

sh(uw1) ^

sh(uzv) =

s

u

s

vz

^ sh(uv1) =

s

u

s

w1

^

Isg(v) ^ Isg(w) ^
u

L

vz

=

L

[uvz _ uzv]us

vz

j:u

L

vz

jus

vz

= 0 ^

u

L

w1

=

L

[uw1 _ uv1]us

w1

^

j:u

L

w1

j * 1

(101)

We next transform (101) into disjunction of base formulas.
A typical base formula is:

9uvz; uzv; uv; uz; uw; uv1; uv2; uz1; uz2; uw1; uw2:
9

L

u

L

vz

; u

L

v

; u

L

z

; u

L

v1

; u

L

v2

; u

L

z1

; u

L

z2

; u

L

w1

:

9

s

u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

:

shapeBase

1

^

leafsetBase1 ^ leafsetHom1 ^
termBase1 ^ termHom1 ^
cardin1 ^ innerMap

1

(102)

shapeBase

1

= u

s

vz

= g

s

(u

s

w

; u

s

w

) ^ u

s

w

= g

s

(u

s

w1

; u

s

w2

) ^

distinct(u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

)

39

leafsetBase1 = u

L

vz

= g

L

(u

L

v

; u

L

z

) ^

u

L

v

= g

L

(u

L

v1

; u

L

v2

) ^ u

L

z

= g

L

(u

L

z1

; u

L

z2

)

leafsetHom1 = lssh(u

L

vz

) = u

s

vz

^

lssh(u

L

v

) = u

s

w

^ lssh(u

L

z

) = u

s

w

^

lssh(u

L

v1

) = u

s

w1

^ lssh(u

L

v2

) = u

s

w2

^

lssh(u

L

z1

) = u

s

w1

^ lssh(u

L

z2

) = u

s

w2

^

lssh(u

L

w1

) = u

s

w1

termBase1 = uvz = g(uv; uz) ^ uzv = g(uz; uv) ^

uv = g(uv1; uv2) ^ uz = g(uz1; uz2) ^
uw = g(uw1; uw2) ^
z = uz ^ w = uw
termHom1 =

sh(uvz) = u

s

vz

^ sh(uzv) = u

s

vz

^

sh(uv) = u

s

w

^ sh(uz) = u

s

w

^ sh(uw) = u

s

w

^

sh(uv1) = u

s

w1

^ sh(uz1) = u

s

w1

^ sh(uw1) = u

s

w1

^

sh(uv2) = u

s

w2

^ sh(uz2) = u

s

w2

^ sh(uw2) = u

s

w2

innerMap

1

=

u

L

v1

=

L

[uv1 _ uz1]us

w1

^ u

L

z1

=

L

[uz1 _ uv1]us

w1

^

u

L

v2

=

L

[uv2 _ uz2]us

w2

^ u

L

z2

=

L

[uz2 _ uv2]us

w2

^

u

L

w1

=

L

[uw1 _ uv1]us

w1

cardin1 = j:u

L

v1

jus

w1

= 0 ^ j:u

L

z1

jus

w1

= 0 ^

j:u

L

v2

jus

w2

= 0 ^ j:u

L

z2

jus

w2

= 0 ^

j:u

L

w1

jus

w1

j * 1

We next show how to transform the base formula (102) into
quantifier-free form.

We substitute away non-parameter term variables
uvz; uzv; uv and non-parameter leafset variables u

L

vz

; u

L

v

; u

L

z

,

because the homomorphism constraints they participate in
may be derived from the remaining conjuncts. We next eliminate parameter term variables uv1; uv2 and parameter leafset variables u

L

v1

; u

L

v2

; u

L

z1

; u

L

z2

; u

L

w1

. Grouping the conjuncts

in cardin1 and innerMap

1

by their shape, we may extract the

subformulas 1 and 2 of (102).

1 j

9uv1:9

L

u

L

v1

; u

L

z1

; u

L

w1

:

sh(uv1) =

s

u

s

w1

^ sh(uz1) =

s

u

s

w1

^ sh(uw1) =

s

u

s

w1

^

lssh(u

L

v1

) =

s

u

s

w1

^ lssh(u

L

z1

) =

s

u

s

w1

^

lssh(u

L

w1

) =

s

u

s

w1

^

u

L

v1

=

L

[uv1 _ uz1]us

w1

^ u

L

z1

=

L

[uz1 _ uv1]us

w1

^

u

L

w1

=

L

[uw1 _ uv1]us

w1

^

j:u

L

v1

jus

w1

= 0 ^ j:u

L

z1

jus

w1

= 0 ^

j:u

L

w1

jus

w1

j * 1

and

2 j

9uv2:9

L

u

L

v2

; u

L

z2

:

sh(uv2) =

s

u

s

w2

^ sh(uz2) =

s

u

s

w2

^

sh(u

L

v2

) =

s

u

s

w2

^ sh(u

L

z2

) =

s

u

s

w2

^

u

L

v2

=

L

[uv2 _ uz2]us

w2

^ u

L

z2

=

L

[uz2 _ uv2]us

w2

^

j:u

L

v2

jus

w2

= 0 ^ j:u

L

z2

jus

w2

= 0

Formula 1 expresses a fact in a structure isomorphic to
the power C

n

where n is the number of leaves in the shape

denoted by u

s

w1

. Similarly, 2 expresses a fact in a product structure C

m

where m is the number of leaves in the

shape denoted by u

s

w2

. We can therefore use the technique

of Feferman-Vaught technique (Section 3.3) to eliminate the
quantifiers from formulas 1 and 2. According to Example 17, 1 is equivalent to:

9

L

u

L

0

; u

L

4

:

u

L

0

=

L

[9

I

t: t _ uz1 ^

I

uz1 _ t ^

I

uw1 _ t]us

w1

^

u

L

4

=

L

[9

I

t: t _ uz1 ^

I

uz1 _ t ^

I

:

I

uw1 _ t]us

w1

^

ju

L

4

jus

w1

* 1 ^ j:

I

u

L

0

^

I

:

I

u

L

4

jus

w1

= 0

We similarly apply Feferman-Vaught construction to 2 and
obtain the result true. We may now substitute the results of
quantifier elimination in 1 and 2. The resulting formula
is:

9uvz; uzv; uv; uz; uw; uv1; uv2; uz1; uz2; uw1; uw2:
9

L

u

L

vz

; u

L

v

; u

L

z

; u

L

v1

; u

L

v2

; u

L

z1

; u

L

z2

; u

L

w1

:

9

s

u

s

vz

; u

s

w

; u

s

w1

; u

s

w2

:

shapeBase

1

^

leafsetHom2 ^
termBase2 ^ termHom2 ^
cardin1 ^ innerMap

1

where

leafsetHom2 = lssh(u

L

0

) = u

s

w1

^ lssh(u

L

4

) = u

s

w1

termBase2 = uz = g(uz1; uz2) ^ uw = g(uw1; uw2) ^

z = uz ^ w = uw
innerMap

2

=

u

L

0

=

L

[9

I

t: t _ uz1 ^

I

uz1 _ t ^

I

uw1 _ t]us

w1

^

u

L

4

=

L

[9

I

t: t _ uz1 ^

I

uz1 _ t ^

I

:

I

uw1 _ t]us

w1

^

cardin2 = ju

L

4

jus

w1

* 1 ^ j:

I

u

L

0

^

I

:

I

u

L

4

jus

w1

= 0

In the resulting formula all variables are expressible in terms
of free variables, so we can write the formula without quantifiers 9; 8; 9

L

; 8

L

.

\Upsilon 

The following Proposition 80 is analogous to Proposition 44; the proof is straightforward.

40

Proposition 80 (Quantification of Struct. Base) If fi
is a structural base formula and x a free shape, leafset, or
term variable in fi, then there exists a base structural formula fi1 equivalent to 9x:fi.

The following Proposition 81 corresponds to Proposition 45.
Proposition 81 (Quantifier-Free to Structural Base)
Let OE be a well-defined simple formula without quantifiers
9

L

; 8

L

, 9; 8, 9

s

; 8

s

. Then OE can be written as true, false, or

a disjunction of structural base formulas.

Proof Sketch. The overall idea of the transformation to
base formula is similar to the transformation in the proof of
Proposition 45. Additional complexity is due to inner formulas. However, note that an inner formula OE(u

s

; u1; : : : ; un)

is well-defined iff ffi(u

s

; u1; : : : ; un) holds where

ffi(u

s

; u1; : : : ; un) j sh(u1) = u

s

^ : : : ^ sh(un) = u

s

Hence, each formula OE(u

s

; u1; : : : ; un) can be treated as a

partial operation p of sort

shape \Theta  term

n

! leafset

and the domain given by

Dp = hhu

s

; u1; : : : ; uni; ffi(u

s

; u1; : : : ; un)i

This means that we may apply Proposition 9 and convert
formula to disjunction existentially quantified well-defined
conjunctions of literals in one of the following forms:

1. equality with inner formulas: u

L

0

=

L

OE(u

s

; u1; : : : ; un)

where OE(u

s

; u1; : : : ; un) is a u

s

-inner formula;

2. formulas of leafset boolean algebra:

u

L

0

=

L

u

L

1

^

I

u

s u

L

2

u

L

0

=

L

u

L

1

.

I

u

s u

L

2

u

L

0

=

L

:

I

u

su

L

1

u

L

0

=

L

true

I

u

s

u

L

0

=

L

false

I

u

s

3. formulas of term algebra of terms:

u1 = u2; u1 6= u2
u0 = f(u1; : : : ; un)
u = fi(u0)
Isf (u0); :Isf (u0)
sh(u) = u

s

4. formulas of term algebra of leafsets:

u

L

1

=

L

u

L

2

; u

L

1

6=

L

u

L

2

u

L

0

=

L

f

L

(u

L

1

; : : : ; u

L

n

)

u

L

=

L

f

L

i

(u

L

0

)

Is

f

L(u

L

0

); :Is

f

L(u

L

0

)

lssh(u

L

) =

L

u

s

5. formulas of term algebra of shapes:

u

s

1

=

s

u

s

2

; u

s

1

6=

s

u

s

2

u

s

0

=

s

f

s

(u

s

1

; : : : ; u

s

n

)

u

s

=

s

f

s

i

(u

s

0

)

Isfs(u

s

0

); :Isfs(u

s

0

)

We next describe transformation of each existentially
quantified conjunction. In the sequel, whenever we perform
case analysis and generate a disjunction of conjunctions, existential quantifiers propagate to the conjunctions, so we
keep working with a existentially quantified conjunction.
The existentially quantified variables will become internal
variables of a structural base formula.

Analogously to the proof of Proposition 28, we use
(90), (91), (16) to eliminate literals :Isf (u0), :Is

f

Lf

L

(u

L

0

),

:Isgs(u

s

0

).

As in the proof of Proposition 45, we replace formulas of
leafset boolean algebra by cardinality constraints, similarly
to Figure 7.

We next convert formulas of term algebra of terms into
a base formula, formulas of term algebra of leafsets into a
base formula, and formulas of term algebra of shapes into a
base formula.

We simultaneously make sure that every term or leafset
variable has an associated associated shape variable, introducing new shape variables if needed.

We also ensure homomorphism requirements by replacing internal variables when we entail their equality.

Another condition we ensure is that parameter term variables map to parameter shape variables, and non-parameter
term variables to non-parameter shape variables; we do this
by performing expansion of term and shape variables.

We perform expansion of shape variables as in Section 3.2. Expansion of term and variables is even simpler
because there is no need to do case analysis on equality of
term variable with other variables.

We eliminate disequality between term variables using (92). We eliminate disequalities between leafset variables as in Example 43, by converting each disequality into
a cardinality constraint. Elimination of disequalities might
violate previously established homomorphism invariants, so
we may need to reestablish these invariants by repeating the
previously described steps. The overall process terminates
because we never introduce new inequalities between term
or leafset variables.

As a final step, we convert all cardinality constraints into
constraints on parameter term variables, using (95).

In the case when the shape of cardinality constraint is c

s

,

we cannot apply (95). However, in this case, unlike Proposition 45, we do not do case analysis on all possible constant
leafsets (this is not even possible in general). This is because
Definition 78, unlike Definition 41 implies no need to further
decompose cardinality constraints in that case, because we
allow primitive non-parameter leafset variables.

This completes our sketch of transforming a quantifierfree formula into disjunction of structural base formulas.

We introduce the notion of determined variables in structural base formula generalizing Definition 29 and Definition 46.

For brevity, we write u

\Lambda 

for internal shape, term, or leafset variables, similarly x

\Lambda 

for a free variable, t

\Lambda 

for a term

41

and f

\Lambda 

for a shape, term, or leafset term algebra constructor

and f

\Lambda 

i

for a shape, term, or leafset term algebra selector.

Definition 82 The set determinations of variable determinations of a structural base formula fi is the least set S of
pairs hu

\Lambda 

; t

\Lambda 

i where u

\Lambda 

is an internal term, leafset, or shape

variable and t

\Lambda 

is a term over the free variables of fi, such

such that:

1. if x

\Lambda 

= u

\Lambda 

occurs in termBase, leafsetBase, or

shapeBase, then hu

\Lambda 

; x

\Lambda 

i 2 S;

2. if hu

\Lambda 

; t

\Lambda 

i 2 S and u

\Lambda 

= f

\Lambda 

(u

\Lambda 

1

; : : : ; u

\Lambda 

k

) occurs in shapeBase, termBase, or leafsetBase then
fhu

\Lambda 

1

; f

\Lambda 

1

(t

\Lambda 

)i; : : : ; hu

\Lambda 

k

; f

\Lambda 

k

(t

\Lambda 

)ig ` S;

3. if fhu

\Lambda 

1

; f

\Lambda 

1

(t

\Lambda 

)i; : : : ; hu

\Lambda 

k

; f

\Lambda 

k

(t

\Lambda 

)ig ` S and u

\Lambda 

=

f

\Lambda 

(u

\Lambda 

1

; : : : ; u

\Lambda 

k

) occurs in shapeBase, termBase, or

leafsetBase then hu

\Lambda 

; t

\Lambda 

i 2 S;

4. if hu; ti 2 S and sh(u) = u

s

occurs in termHom then

hu

s

; sh(t)i 2 S;

5. if hu

L

; t

L

i 2 S and lssh(u

L

) = u

s

occurs in leafsetHom

then hu

s

; lssh(t

L

)i 2 S;

6. if u

L

= OE(u

s

; u1; : : : ; un) occurs in innerMap

where OE(u

s

; u1; : : : ; un) is an inner formula

and fhu

s

; t

s

i; hu1; t1i; : : : ; hun; tnig ` S, then

hu

L

; OE(t

s

; t1; : : : ; tn)i 2 S. (In the special case

when OE contains no free term variables, if hu

s

; t

s

i 2 S

then hu

L

; OE(u

s

)i 2 S.

Definition 83 An internal variable u

\Lambda 

is determined if

hu

\Lambda 

; t

\Lambda 

i 2 determinations for some term t

s

. An internal variable is undetermined if it is not determined.

Lemma 84 Let fi be a structural base formula with matrix fi0 and let determinations be the determinations of fi. If
hu

\Lambda 

; t

\Lambda 

i 2 S then j= fi0 ) u

\Lambda 

= t

\Lambda 

.

Proof. By induction, using Definition 82.

Corollary 85 Let fi be a structural base formula such that
every internal variable is determined. Then fi is equivalent to a well-defined formula without quantifiers 9

L

; 8

L

, 9; 8,

9

s

; 8

s

.

Proof. By Lemma 84 using (7).

Lemma 86 Let u be an undetermined composed nonparameter term variable in a structural base formula fi such
that u is a source i.e. no conjunct of form

u

0

= f(u1; : : : ; u; : : : ; uk)

occurs in termBase. Let fi

0

be the result of dropping u from

fi. Then fi is equivalent to fi

0

.

Proof. Because u is a composed non-parameter term
variable, it does not occur in innerMap, so it only occurs
in termBase and termHom. The conjunct containing u in
termHom is a consequence of the remaining conjuncts, so it
may be dropped. After that, applying (7) yields a structural
base formula fi

0

not containing u, where fi

0

is equivalent to

fi.

Lemma 87 Let u

L

be an undetermined composed nonparameter leafset variable in a structural base formula fi such
that u

L

is a source i.e. no conjunct of form

u

L

0

= f

L

(u

L

1

; : : : ; u

L

; : : : ; u

L

k

)

occurs in leafsetBase. Let fi

0

be the result of dropping u

L

from fi. Then fi is equivalent to fi

0

.

Proof. Because u

L

is a composed non-parameter term

variable, it does not occur in innerMap or cardin, so it only
occurs in leafsetBase and leafsetHom. The conjunct containing u

L

in leafsetHom is a consequence of the remaining

conjuncts, so it may be dropped. After that, applying (7)

yields a structural base formula fi

0

not containing u

L

, where

fi

0

is equivalent to fi.

Corollary 88 Every base formula is equivalent to a base
formula without undetermined composed non-parameter
term variables and without undetermined composed nonparameter leafset variables.

Proof. If a structural base formula has an undetermined
composed non-parameter term variable, then it has an undetermined composed non-parameter term variable that is
a source, similarly for leafset variables. By repeated application of Lemma 86 and Lemma 87 we eliminate all undetermined non-parameter term and leafset variables.

The following Proposition 89 corresponds to Proposition 53 and Proposition 66.

Proposition 89 (Struct. Base to Quantifier-Free)
Every structural base formula fi is equivalent to a welldefined simple formula OE without quantifiers 9

L

; 8

L

, 9; 8,

9

s

; 8

s

.

Proof Sketch. By Corollary 88 we may assume that
fi has no undetermined composed non-parameter term and
leafset variables. By Corollary 85 we are done if there are
no undetermined variables, so it suffices to eliminate:

1. undetermined parameter term variables,
2. undetermined primitive non-parameter term variables,
3. undetermined parameter leafset variables,
4. undetermined primitive non-parameter leafset variables, and

5. undetermined shape variables.
If u is an undetermined parameter term variable or a primitive non-parameter term variable, then u does not occur in
termBase, so it occurs only in termHom and innerMap. If
u

L

is an undetermined parameter leafset variable or a primitive non-parameter leafset variable then u

L

does not occur

in leafsetBase, so it occurs only in leafsetHom, innerMap, and
cardin.

For a undetermined term or leafset variable of shape u

s

such that there is an uncovered parameter or primitive nonparameter term or leafset variable with shape u

s

, consider

all conjuncts fli in innerMap of form

u

L

j

= OE(u

s

; ui

1

; : : : ; ui

k

)

42

and all conjuncts ffii from cardin of form:

jt

L

(u

L

r

L

+1

; : : : ; u

L

n

L)ju

s = k

or

jt

L

(u

L

r

L

+1

; : : : ; u

L

n

L)ju

s * k

Together with formulas from termHom and leafsetHom that
contain term and leafset variables free in formulas fli and ffii,
these conjuncts form a formula j which expresses a relation
in the substructure of term-power algebra which (because
constructors are covariant) is isomorphic to a term-power
of C. We therefore use Feferman-Vaught theorem from Section 3.3 to eliminate all term and parameter variables from
j. By repeating this process we eliminate all undetermined
parameter and leafset variables.

It remains to eliminate undetermined shape variables.
This process is similar to term algebra quantifier elimination in Section 3.4. An essential part of construction in
Section 3.4 is Lemma 25, which relies on the fact that undetermined parameter variables may take on infinitely many
values. We therefore ensure that undetermined parameter
shape variables are not constrained by term and parameter variables through conjuncts outside shapeBase. An undetermined parameter shape variable u

s

does not occur in

termHom or leafsetHom because there are no parameter term
and leafset variables, so u

s

can occur only in innerMap and

cardin.

However, because undetermined parameter and leafset
variables are eliminated from the formula, if u

s

is a parameter shape variable then exactly one of these two cases holds:

1. there are some conjuncts in innerMap and cardin that

contain u

s

and contain some determined term and leafset variables, in this case u

s

is determined, or

2. there are no conjuncts in innerMap containing u

s

and

cardin contains only domain cardinality constraints of
form j1jus = k and j1jus * k.

Hence, if u

s

is a shape variable it remains to eliminate the

constraints of form j1jus = k and j1jus * k. We eliminate
these constraints as in the proof of Proposition 66.

In the resulting formula all variables are determined. By
Corollary 85 the formula can be written as a formula without
quantifiers 9

L

; 8

L

, 9; 8, 9

s

; 8

s

.

The following is the main result of this paper.

Theorem 90 (Term Power Quant. Elimination)
There exist algorithms A, B such that for a given formula
OE in the language of Figure 9:

a) A produces a quantifier-free formula OE

0

in selector language

b) B produces a disjunction OE

0

of structural base formulas

We also explicitly state the following corollary.
Corollary 91 Let C be a structure with decidable first-order
theory. Then the set of true sentences in the logic of Figure 9
interpreted in the structure P according to Figures 10 and
11 is decidable.

6.5 Handling Contravariant Constructors
In this section we discuss the decidability of the \Sigma -termpower structure for a decidable theory C when some of the
function symbols f 2 \Sigma  are contravariant. We then suggest a generalization of the notion of variance to multiple
relations and to relations with arity greater than two.

The modifications needed to accommodate contravariance with respect to some distinguished relation symbol
^2 R for the case of infinite C are analogous to the modifications in Section 5.5. We this obtain a quantifier elimination procedure for any decidable theory C in the presence of
contravariant constructors.

Theorem 92 (Decidability of Structural Subtyping)
Let C be a decidable structure and P a \Sigma -term-power of C.
Then the first-order theory of P is decidable.

In the rest of this section we consider a generalization
that allows defining variance for every relation symbol r 2 R
of any arity, and not just the relation symbol ^2 R.

For a given relation symbol r 2 R, function symbol
f 2 \Sigma , with k = ar(f), and integer i where 1 ^ i ^ k,
let Pr(f; i) denote a permutation of the set f1; : : : ; kg that
specifies the variance of the i-th argument of f with respect
to the relation r. For example, if r is a binary relation then
Pr(f; i) is the identity permutation fh1; 1ih2; 2ig if i-th argument of f is covariant, or a the transpose permutation
fh1; 2i; h2; 1ig if i-th argument of f is contravariant.

If l 2 leaves(s) is a leaf l = hf

1

; i

1

i : : : hf

n

; i

n

i, define the

permutation variance(l) as the composition of permutations:

variance(l) = Pr(f

n

; i

n

) ffi \Delta  \Delta  \Delta  ffi Pr(f

1

; i

1

)

Then define JrK by

JrK(s; t1; : : : ; tk) =
hs; fl j JrK

C

(tp

1

[l]; : : : ; tp

k

[l]) ^

hp1; : : : ; pki = variance(l)
gi

We generalize (76) by defining

Nss(s) = jfl 2 leaves(s) j variance(l) = ssgj
As in Section 5.5, we can transform the constraints
j1jus = k and j1jus * k on each parameter shape variable
into a conjunction of constraints of form:

Nss(u

s

) = k

or

Nss(u

s

) * k

A problem on nonnegative integers. To solve the
problem of variance with any number of relation symbols of
any arity, it suffices to solve the following problem on sets
of tuples of non-negative integers.

Let Nat = f0; 1; 2; : : :g. Consider the structure St =

Nat

d

for some d * 2 and let D = f1; 2; : : : ; dg. If p is a

permutation on D, let Mp denote an operation St ! St
defined by

Mp(x1; : : : ; xd) = (xp

1

; : : : ; xp

d

)

43

If hx1; : : : ; xdi; hy1; : : : ; ydi 2 St define

hx1; : : : ; xdi + hy1; : : : ; ydi = hx1 + y1; : : : ; xd + ydi
Consider a finite set of operations f : St

k

! St where each

operation f is determined by k permutations p

f

1

; : : : ; p

f

k

in

the following way:

f(t1; : : : ; tk) = M

p

f

1

(t1) + : : : + M

p

f

k

(tk)

Hence, each operation f of arity k is given by a permutation
which specifies how to exchange the order of arguments in
the tuple. After permuting the arguments the tuples are
summed up.

Given a finite set F of operations f, let S be the set
generated by operations in F starting from the element
(1; 0; : : : ; 0) 2 St. Let C(n1; : : : ; nd) be a conjunction of
simple linear constraints of the forms

ni = ai
and

ni * ai

Consider the set

AC = f(n1; : : : ; nd) 2 SjC(n1; : : : ; nd)g
The problem is: For given set of operations F , is there an
algorithm that given C(n1; : : : ; nd) finitely computes the set
AC.
End of a problem on nonnegative integers.

We conjecture that the technique of Lemma 68 can be
generalized to yield a solution to the problem on nonnegative
integers and thus establish the decidability for the notion of
variance with respect to any number of relations with any
number of arguments.

6.6 A Note on Element Selection
We make a brief note related to the choice of the language
for making statements in term-power algebras. In Section 5
we avoided the use of leafset variables by substituting them
into cardinality constraints. In this section we use a cylindric
algebra of leafsets.

An apparently even more flexible alternative is to allow
the element selection operation

select :: term \Theta  leaf ! elem
where elem is a new sort, interpreted over the set C, and
leaf is a sort interpreted over the set of pairs of a shape and
a leaf. Instead of the formula

rus(t1; : : : ; tn) =

L

true

I

u

s

we would then write

8l: rus(select(t1; l); : : : ; select(tn; l)) =

L

true

I

u

s

Using select operation we can define update relation:

update(t1; l0; e; t2) j

8l: ((l = l0 ^ select(t2; l) = e) .

(l 6= l0 ^ select(t2; l) = select(t1; l)))

The resulting language is at least as expressive as the language in Figure 5. This language is interesting because it
allows reasoning about updates to leaves of a tree of fixed
shape, thus generalizing the theory of updatable arrays [33]
to the theory of trees with update operations, which would
be useful for program verification. We did not choose this
more expressive language in this report for the following
reason.

If the base structure C has a finite domain C, then for
certain reasonable choice of the relations interpreting LC it
is possible to express statements of this extended language
in the logic of Figure 9. The idea is to assume a partial order
on the elements of C with a minimal element, and use terms
t with exactly one leaf non-minimal to model the leaves.

On the other hand, in the more interesting case when C
is infinite, we can easily obtain undecidable theories in the
presence of selection operation. Namely, the selection operation allows terms to be used as finite sets of elements of C.
The term-power therefore increases the expressiveness from
the first-order theory to the weak monadic second-order theory, which allows quantification over finite sets of objects.
Weak monadic theory allows in particular inductive definitions. If theory of structure C is decidable, weak monadic
theory might therefore still be undecidable, as an example
we might take the term algebra itself, whose weak monadic
theory would allow defining subterm relation, yielding an
undecidable theory [56, Page 508].

7 Some Connections with MSOL
This section explores some relationships between the theory of structural subtyping and monadic second-order logic
(MSOL) interpreted over tree-like structures. We present
it as a series of remarks that are potentially useful for understanding the first-order theory of structural subtyping of
recursive types, see [36, 37] for similar results in the context
of the theory of feature trees.

In Section 7.1 we exhibit an embedding of MSOL of infinite binary tree into the first-order theory of structural
subtyping of recursive types with two constant symbols a,b
and one covariant binary function symbol f. MSOL of infinite binary tree is decidable. Although the embedding does
not give an answer to the decidability of the structural subtyping of recursive types, it does show that the problem is at
least as difficult as decidability of MSOL over infinite trees.
We therefore expect that, if the theory of structural subtyping of recursive types is decidable, the decidability proof will
likely either use decidability of MSOL over infinite trees, or
use directly techniques similar to those of [18, 57].

In Section 7.2 we use the embedding in Section 7.1 to
argue the decidability of formulas of the first-order theory
of structural subtyping of recursive types where variables
range over terms of certain fixed infinite shape se.

In Section 7.3 we present an encoding of all terms using
terms of shape se. We argue that the main obstacle in using this encoding to show the decidability of the first-order
theory of structural subtyping recursive types is inability to
define the set of all prefix-closed terms of the shape se.

In Section 7.4 we generalize the decidability result of Section 7.2 by allowing different variables to range over different
constant shapes.

In Section 7.5 we illustrate some of the difficulties in
reducing first-order theory of structural subtyping to MSOL
over tree-like structures. We show that if we use a certain

44

form of infinite feature trees instead of infinite terms, the
decidability follows.

In Section 7.6 we point out that monadic second-order
logic with prefix-closed sets is undecidable, which follows
from [48]. This fact indicates that if we hope to show the
decidability of structural subtyping of recursive types, it is
essential to maintain the incomparability of types of different
shape.

7.1 Structural Subtyping Recursive Types
In this section we define the problem of structural subtyping of recursive types. We then give an embedding of
MSOL of the infinite binary tree into the first-order theory
of structural subtyping of infinite terms over the signature
\Sigma  = fa; b; gg with the partial order ^.

We define MSOL over infinite binary tree [6, Page 317]

as the structure MSOL

(2)

= hf0; 1g

\Lambda 

; succ0; succ1i. The domain of the structure is the set f0; 1g

\Lambda 

of all finite strings

over the alphabet f0; 1g. We denote first-order variables by
lowercase letters such as x; y; z. First-order variables range
over finite words w 2 f0; 1g

\Lambda 

. We denote second-order variables by uppercase letters such as X; Y; Z. Second-order
variables range over finite and infinite subsets S ` f0; 1g

\Lambda 

.

The only relational symbol is equality, with the standard interpretation. There are two function symbols, denoting the
appending of the symbol 0 and the appending of the symbol
1 to a word:

succ0 w = w \Delta  0

succ1 w = w \Delta  1
For the purpose of embedding into the first-order theory
of structural subtyping, we consider a structure MSOL

(1)

=

hf0; 1g

\Lambda 

; j; Succ0; Succ1i equivalent to MSOL

(2)

. We use the

language of MSOL without first-order variables to make

statements within MSOL

(1)

. j is a binary relation on sets

denoting the subset relation:

Y1 j Y2 () 8x: x 2 Y1 ) x 2 Y2
Succ0 and Succ1 are binary relations on sets, Succ0; Succ1 `
2

f0;1g

\Lambda 

\Theta  2

f0;1g

\Lambda 

, defined as follows:

Succ0(Y1; Y2) () Y2 = fw \Delta  0 j w 2 Y1g
Succ1(Y1; Y2) () Y2 = fw \Delta  1 j w 2 Y1g

The structure MSOL

(1)

is similar to one in [18]; the difference is that relations Succ0 and Succ1 are true even for
non-singleton sets.

Lemmas 93 and 94 show the expected equivalence of
MSOL

(2)

and MSOL

(1)

.

Lemma 93 (MSOL

(2)

expresses MSOL

(1)

) Every relation on sets definable in MSOL

(1)

is definable in MSOL

(2)

.

Proof. We express relations `, Succ0, Succ1 as formulas in
MSOL

(2)

, as follows. We express Y1 ` Y2 as

8x: Y1(x) ) Y2(x);
Succ0(Y1; Y2) as

8x:Y2(x) () 9y:y = succ0(x);

and Succ1(Y1; Y2) as

8x:Y2(x) () 9y:y = succ1(x):
The statement follows by induction on the structure of formulas.

Let R ` (2

f0;1g

\Lambda 

)

k

\Theta  (f0; 1g

\Lambda 

)

n

be relation of arity k + n.

Define R

\Lambda 

` (2

f0;1g

\Lambda 

)

k

\Theta  (2

f0;1g

\Lambda 

)

n

by

R

\Lambda 

(Y1; : : : ; Yk; X1; : : : ; Xn) j

9x1; : : : ; xn: X1 = fx1g ^ \Delta  \Delta  \Delta  ^ Xn = fxng ^

R(Y1; : : : ; Yk; x1; : : : ; xn)

Lemma 94 (MSOL

(1)

expresses MSOL

(2)

) If R is definable in MSOL

(2)

, then R

\Lambda 

is definable in MSOL

(1)

.

Proof Sketch. Property of being an empty set is definable
in MSOL

(1)

by the formula

OE0(Y1) j 8Y2:Y1 j Y2
The relation ae of being a proper subset is definable in
MSOL

(1)

by formula

OE1(Y1; Y2) j Y1 j Y2 ^ Y1 6= Y2
and the relation ae1 of having one element more is definable
by formula

OE2(Y1; Y2) j Y1 ae Y2 ^ :9Z: Y1 ae Z ^ Z ae Y2
The property of being a singleton set can then be expressed
by formula

OE3(Y1) j 9Y0: OE0(Y0) ^ Y0 ae1 Y1
We define the relation on singletons corresponding to succ0
by

OE4(Y1; Y2) j OE3(Y1) ^ OE3(Y2) ^ Succ0(Y1; Y2)
Similarly, the relation corresponding to succ1 is defined by

OE5(Y1; Y2) j OE3(Y1) ^ OE3(Y2) ^ Succ1(Y1; Y2)
If R is expressible by some formula  in MSOL

(2)

, then R is

expressible by a formula in prenex normal form, so suppose
 is of form

Q1V1 : : : QnVn:0

where 0 is quantifier free. We construct a formula 

0

expressing R

\Lambda 

in MSOL

(1)

. We obtain the matrix 

0

0

of 

0

by translating 0 as follows. If x is a first-order variable in
0, we represent it with a second-order variable X denoting a singleton set. We replace membership relation Y (x)
with subset relation X ae Y . We replace succ0 with OE4 and
succ1 with OE5. We construct 

0

by adding quantifiers to



0

0

as follows. Second-order quantifiers remain the same.

First-order quantifiers are relativized to range over singleton sets: 8x:i becomes 8X:OE3(X) ) 

0

i

and 9x:i becomes

9X: OE3(X) ^ 

0

i

(X).

We can view MSOL

(1)

as a first-order structure with the

domain 2

f0;1g

\Lambda 

. We show how to embed MSOL

(1)

into the

first-order theory of structural subtyping.

45

We define the first-order structure of structural subtyping of recursive types similarly to the corresponding structure for non-recursive types in Section 4; the only difference
is that the domain contains both finite and infinite terms.
Infinite terms correspond to infinite trees [12, 30].

We define infinite trees as follows. We use alphabet fl; rg
to denote paths in the tree. A tree domain D is a finite or
infinite subset of the set fl; rg

\Lambda 

such that:

1. D is prefix-closed: if w 2 fl; rg

\Lambda 

, x 2 fl; rg then

w \Delta  x 2 D implies w 2 D;

2. if w 2 D then exactly one of the following two properties hold:

(a) w is an interior node: fw \Delta  l; w \Delta  rg ` D
(b) w is a leaf: fw \Delta  l; w \Delta  rg " D = ;.

A tree with a tree domain D is a total function T from the
set of leaves of D to the set fa; bg.

Note that the tree domain D of a tree T can be reconstructed from T as the prefix closure of the domain of the
graph of function T ; we write TDom(T ) for the tree domain
of tree T .

Two trees are equal if they are equal as functions. Hence,
equal trees have equal function domains and equal tree domains.

We say that T1 ^ T2 iff TDom(T1) = TDom(T2) and
T1(w) ^0 T2(w) for every word w 2 TDom(T1). Here ^0 is
the relation fha; ai; ha; bi; hb; big.

If T1 and T2 are trees, then g(T1; T2) denotes the tree T
such that

TDom(T ) = fl \Delta  w j w 2 T1g [ fr \Delta  w j w 2 T2g

T (l \Delta  w) = T1(w); if w 2 T1
T (r \Delta  w) = T2(w); if w 2 T2
Let IT denote the set of all infinite trees. The structural
subtyping structure is the structure SIT = hIT; g; a; b; ^i.
SIT is an infinite-term counterpart to the structure BS from
Section 4.

Similarly to the case of finite terms, define the relation
, of "being of the same shape" in SIT by

t1 , t2 j 9t0: t0 ^ t1 ^ t0 ^ t2
Observe that t1 , t2 iff TDom(t1) = TDom(t2).

We next present an embedding ' of MSOL

(1)

into SIT.

The image of the embedding ' are the infinite trees that are
in the same ,-equivalence-class with the tree te. We define
te as the unique solution of the equation:

te = g(g(te; te); a)
Trees in the ,-equivalence class of te have the tree domain
D = TDom(te) given by the regular context-free grammar

D ! ffl j r j l j lrD j llD
whereas the leaves L of D are given by the context-free grammar

L ! ffl j r j lrL j llL

or the regular expression (lrjll)

\Lambda 

r. Let h be the homomorphism of words from f0; 1g

\Lambda 

to fl; rg

\Lambda 

such that

h(0) = ll
h(1) = lr

If w = a1 : : : an is a word, then w

R

denotes the reverse of

the word, w

R

= an : : : a1.

We define the embedding ' to map a set Y ` f0; 1g

\Lambda 

into

the unique tree t such that t , te and for every w 2 f0; 1g

\Lambda 

,

w 2 Y () T (h(w

R

) \Delta  r) = b (103)

Observe that '(;) = te. Define formulas TSucc0(t1; t2) and
TSucc1(t1; t2) as follows:

TSucc0(t1; t2) j t2 = g(g(t1; te); te)
TSucc1(t1; t2) j t2 = g(g(te; t1); te)

It is straightforward to show that ' is an injection and that
' maps relation ae into ^, relation Succ0 into TSucc0, and
relation Succ1 into TSucc1. Moreover, the range of ' is the
set of all terms t such that sh(t) = se where se = sh(te).

7.2 A Decidable Substructure
Section 7.1 shows that terms of shape se form a substructure
within SIT that is isomorphic to MSOL

(1)

. In this section

we consider the following converse problem.

Consider the formulas BF that, instead of quantifiers
9; 8, contain bounded quantifiers 9e; 8e that range over the
elements of the set

Te = ft j sh(t) = seg
We show that the set of closed formulas from BF that are
true in SIT is decidable.

Although the quantifiers are bounded, terms in this logic
can still denote elements of shape other than se. For example, the in the atomic formula

g(x1; x2) ^ g(x3; g(g(x4; x5); b))
the term g(x1; x2) denotes a term of the shape g

s

(se; se).

First we show that all atomic formulas are of one of the
following forms:

1. x0 = g(g(x1; x2); a);
2. x0 = g(g(x1; x2); b);
3. x1 = x2;
4. x1 ^ x2.
Consider an atomic formula t1 = t2. The key idea is that if
sh(t1) 6= sh(t2) then the formula t1 = t2 is false.

If none of the term t1 and t2 is a variable then one of them
is a constant or a constructor application. If t1 j g(t11; t12)
then either t1 = t2 is false or t2 j g(t21; t22) for some t21; t22.
We may therefore decompose t1 = t2 into t11 = t21 and
t12 = t22. By repeating this decomposition we arrive at
terms of form t1 = t2 where both t1 and t2 are constants or
at the equality of form x0 = t(x1; : : : ; xn). The equalities
between the constants can be trivially evaluated. This leaves
only terms of form x0 = t(x1; : : : ; xn). Let t

s

(x

s

1

; : : : ; x

s

n

) be

a shape term that results from replacing a and b with c

s

and

replacing g with g

s

in t. Because all variables range over Te,

we conclude that x0 = t(x1; : : : ; xn) can be true only if

se = t

s

(se; : : : ; se)

46

If t(x1; : : : ; xn) 2 fa; bg is then (7.2) is false. If
t(x1; : : : ; xn) j x1, we obtain formula of the desired form.
So assume t(x1; : : : ; xn) j g(t21; t22). Then sh(t21) =
g

s

(se; se) and sh(t22) = c

s

. Therefore, t21 j g(t211; t212)

where either sh(t211) = sh(t212) = se or t1 = t2 is
false. Similarly, either t22 2 fa; bg or t1 = t2 is false.
Therefore, t(x1; : : : ; xn) j g(g(t211; t212); a), t(x1; : : : ; xn) j
g(g(t211; t212); b), or t1 = t2 is false. If t(x1; : : : ; xn) j
g(g(t211; t212); a) then we may replace the t1 = t2 with the
formula

9ey1; y2: x0 = g(g(y1; y2); a) ^ y1 = t211 ^ y2 = t212
and similarly in the other case. By continuing this process
by the induction on the structure of the term t(x1; : : : ; xn)
we either conclude that t1 = t2 is false, or we conclude that
t1 = t2 is equivalent to a conjunction of formulas of the
desired form.

Conversion of atomic formula of form t1 ^ t2 is analogous
to the conversion of formulas t1 = t2.

To see the decidability it now suffices to convert
the formulas of the form x0 = g(g(x1; x2); a) and
x0 = g(g(x1; x2); b) into formulas TSucc0(t1; t2) and
TSucc1(t1; t2). Expressibility of x0 = g(g(x1; x2); a) follows from the fact that the following relationship between
X0; X1; X2 is expressible in MSOL:

X0 = fw \Delta  0 j w 2 X1g [ fw \Delta  1 j w 2 X2g
Similarly, the expressibility of x0 = g(g(x1; x2); b) follows
from the fact that

X0 = fw \Delta  0 j w 2 X1g [ fw \Delta  1 j w 2 X2g [ ffflg
is expressible in MSOL. We conclude that the set of closed
BF formulas that are true in SIT is decidable.

7.3 Embedding Terms into Terms
We next give an embedding of the set of all terms into Te.
As in Section 7.1 te be the unique solution of the equation
te = g(g(te; te); a) and let

t4(x1; x2; x3; x4) j g(g(g(g(x1; x2); x3); te); x4)
Define

ta j t4(te; te; a; a)

tb j t4(te; te; a; b)
tg(x1; x2) j t4(x1; x2; b; b)

Then define the homomorphism hT from the set of all terms
to the set Te by

hT (a) = ta

hT (b) = tb
hT (g(t1; t2)) = tg(hT (t1); hT (t2))

Then hT is embedding of the set of all terms into the subset
subset Te of all terms. The term algebra operations a; b; g
map to ta; tb; tg and ^ maps to ^.

Note that, if it were possible to define a predicate P (t)
such that

P (x) () 9y:hT (y) = x (104)

then we could express all statements of SIT within the BF
subtheory, and therefore SIT would be decidable.

The fundamental problem with specifying P (x) is not the
use of two bits to encode the three possible elements fa; b; gg,
but the constraint that if a term contains a subterm of the
form t4(t1; t2; a; a) or t4(t1; t2; a; b) at some even depth, then
t1 j t2 j te. Compared to the relationships given by constructor g, this constraint requires taking about successor
relation at the opposite side of the paths within a tree, see
Section 7.6.

7.4 Subtyping Trees of Known Shape
We next argue that if we allow the logic to have a copy of
bounded quantifiers 9s; 8s for every constant shape s, we
obtain a decidable theory. To denote constant shapes in a
finite number of symbols we consider in addition to term
algebra symbols g

s

; c

s

the expressions that yield solutions of

mutually recursive equations on shapes; the details of the
representation of types are not crucial for our argument, see
e.g. [12]

Consider a closed formula in such language. Because every variable has an associated constant shape, we can compute the set of all shapes occurring in the formula. This
means that all variables of the formula range over a finite
known set of shapes. This allows us to define the predicate
P given by (104) as a disjunction of cases, one case for every shape. Define hmin, hmax functions that take a shape and
produce a lower and upper bound for terms of that shape:

hmin(c

s

) = ta

hmin(g

s

(t

s

1

; t

s

2

)) = tg(hmin(t

s

1

); hmin(t

s

2

))

hmax(c

s

) = tb

hmax(g

s

(t

s

1

; t

s

2

)) = tg(hmax(t

s

1

); hmax(t

s

2

))

If s1; : : : ; sn is the list of shapes occurring in a formula, we
then define a predicate P specific to that formula by

P (t) =

n
.

i=1

(hmin(si) ^ t ^ t ^ hmax(t))

We can therefore define P (t) and use it to translate the
formula into a BF formula of the same truth value. Therefore, structural subtyping with quantification bounded to
constant shapes is decidable.

For decidability of the structural subtyping recursive
types it would be interesting to examine the decision procedure for MSOL and determine whether there is some uniformity in it that would allow us to handle even quantification
over shapes that are determined by variables.

7.5 Recursive Feature Trees
We next remark that certain notion of subtyping of recursive
feature trees is decidable. By a feature tree we mean an infinite tree built using a constructor which takes other feature
trees and an optional node label as an argument. In this section we consider the simple case of one binary constructor f
and assume only one label denoted by 1. Hence, an empty
feature tree is a feature tree, and if t1 and t2 are feature trees
then so are f

ffl

(t1; t2) and f

1

(t1; t2). We represent an empty

feature tree e by an infinite tree that has all features ffl. We
compare feature trees as follows. Let ^ be defined on the

47

features fffl; 1g as the relation fhffl; ffli; hffl; 1i; h1; 1ig. Define ^
on trees as the least relation such that:

1. e ^ t for all terms t;
2. t1 ^ t

0

1

and t2 ^ t

0

2

implies

f

r1

(t1; t2) ^ f

r2

(t

0

1

; t

0

2

)

for all r1; r2 2 fffl; 1g such that r1 ^ r2.
The decidability of feature trees follows from Section 7.1
because of the isomorphism hF between the set of terms Te
and the set of feature trees. Here hF is defined by:

hF (e) = te
hF (f

ffl

(t1; t2)) = g(hF (t1); hF (t2); a)

hF (f

1

(t1; t2)) = g(hF (t1); hF (t2); b)

The feature trees as we defined them have a limited feature and node label alphabet. This is not a fundamental
problem. Muchnik's theorem [57] gives the decidability of
MSOL of trees over arbitrary decidable structures. It is
reasonable to expect that the decidability of MSOL over
decidable structures yields a generalization of the result of
Section 7.1 and therefore the decidability of feature trees
with a richer vocabulary of features.

The crucial property of our definition of feature trees is
that features can appear in any node of the tree. Hence,
there are no prefix closure requirements on trees as in Section 7.3, which is responsible for relatively simple reduction
to MSOL.

7.6 Reversed Binary Tree with Prefix-Closed Sets
It is instructive to compare the difficulties our approach
faces in showing the decidability of structural subtyping of
recursive types with the difficulties reported in [48]. In [48,
Section 5.3] the authors remark that the difficulty with applying tree automata is that the set x = f(y; z) is not regular. By reversing the set of paths in a tree representing
a term we have shown in Section 7.1 that the relationship
x = f(y; z) becomes expressible. However, the difficulty now
becomes specifying a set of words that represents a valid
term, because there is no immediate way of stating that a
set of words is prefix-closed. If we add an operation that
allows expressing relationship at both "ends" of the words,
we obtain a structure whose MSOL is undecidable due to
the following result [52, Page 183].

Theorem 95 MSOL theory of the structure with two successor operations w \Delta  0 and w \Delta  1 and one inverse successor
operation 0 \Delta  w is undecidable.

The case that is of interest of us is the dual to Theorem 95
under the word-reversing isomorphism: a structure with operations 0 \Delta  w, 1 \Delta  w, w \Delta  0 has undecidable MSOL closed
formulas.

Instead of expressing prefix-closure using operations w\Delta 0,
w \Delta  1, let us consider MSOL over the structure that contains
only operations 0 \Delta  w and 1 \Delta  w, but where all second-order
variables range over prefix-closed sets. This logic also turns
out to be undecidable.

Let PCl be the set of prefix-closed sets. For each word w,
there exists the smallest PCl set containing w, namely the
set C(w) given by:

C(w) = fw

0

j w

0

OE wg

Every subset of C(w) in PCl is a of the form C(w1) for some
word w1. Define PSucc0 and PSucc1 on PCl by:

PSucc0(X1; X2) = 9w: X1 = C(w) ^ X2 = C(0 \Delta  w)
PSucc1(X1; X2) = 9w: X1 = C(w) ^ X2 = C(1 \Delta  w)
Consider a monadic theory PrefT with relations PSucc0 and
PSucc1 where second-order variables range over the subsets
of PCl. It is easy to see that PrefT corresponds to the firstorder theory of non-structural subtyping of recursive types,
with subset relation ` corresponding to subtype relation ^,
empty set corresponding to the least type ?, PSucc0(X1; X2)
corresponding to X2 = f(X1; ?), and PSucc1(X1; X2) corresponding to X2 = f(?; X2). The first-order theory of
non-structural subtyping was shown undecidable in [48], so
PrefT is undecidable. An interesting open problem is the decidability of fragments of the first-order theory of structural
subtyping. This problem translates directly to the decidability of the fragments of PrefT, a monadic theory with
prefix-closed sets, or, under the word-reversal isomorphism,
the decidability of fragments of the monadic theory of two
successor symbols with suffix-closed sets.

8 Conclusion
In this paper we presented a quantifier elimination procedure for the first-order theory of structural subtyping of
non-recursive types. Our proof uses quantifier elimination.
Our decidability proof for the first-order theory of structural
subtyping clarifies the structure of the theory of structural
subtyping by introducing explicitly the notion of shape of a
term.

We presented the proof in several stages with the hope of
making the paper more accessible and self-contained. Our
result on the decidability of \Sigma -term-power is more general
than the decidability of structural subtyping non-recursive
types, because we allow even infinite decidable base structures for primitive types. We view this decidability result
as an interesting generalization of the decidability for term
algebras and decidability of products of decidable theories.
This generalization is potentially useful in theorem proving
and program verification.

Of potential interest might be the study of axiomatizability properties; the quantifier elimination approach is appropriate for this purpose [31, 30], we did not pay much attention to this because we view the language and the mechanism for specifying the axioms of secondary importance.

Our goal in describing quantifier elimination procedure
was to argue the decidability of the theory of structural subtyping. While it should be relatively easy to extract an algorithm from our proofs, we did not give a formal description
of the decision procedure. One possible formulation of the
decision procedure would be a term-rewriting system such as
[11]; this formulation is also appropriate for implementation
within a theorem prover. Our approach eliminates quantifiers as opposed to quantifier alternations. For that purpose
we extended the language with partial functions. The use of
Kleene logic for partial functions seems to preserve most of
the properties of two valued logic and appears to agree with
the way partial functions are used in informal mathematical
practice. An alternative direction for proving decidability
of structural subtyping would be to use Ehrenfeucht-Fraisse
games [53, Page 405]; [15] uses techniques based on games
to study both the decidability and the computational complexity of theories.

48

The complexity of our the decidability for structural subtyping non-recursive types is non-elementary and is a consequence of the non-elementary complexity of the term algebra, whose elements and operations are present in the theory
of structural subtyping. Tools like MONA [25] show that
non-elementary complexity does not necessarily make the
implementation of a decision procedure uninteresting. An
interesting property of quantifier elimination is that it can
be applied partially to elimination an innermost quantifier
from some formula. This property makes our decision procedure applicable as part of an interactive theorem prover
or a subroutine of a more general decision procedure.

In this paper we have left open the decidability of structural subtyping of recursive types, giving only a few remarks
in Section 7. In particular we have observed in Section 7.1
that every formula in the monadic second-order theory of the
infinite binary tree [6, Page 317] has a corresponding formula
in the first-order theory of structural subtyping of recursive
types. In that sense, the decision problem for structural
subtyping recursive types is at least as hard as the decision
problem for the monadic second-order logic interpreted over
the infinite binary tree. This observation is relevant for two
reasons.

First, it is unlikely that a minor modification of the quantifier elimination technique we used to show the decidability of structural subtyping non-recursive types can be used
to show the decidability of recursive types. Because of the
embedding in Section 7.1 such a quantifier-elimination proof
would have to subsume the determinization of tree automata
over infinite trees.

Second, the embedding suggests even greater difficulties
in implementing a decision procedure for the first-order theory of structural subtyping (provided that it exists). While
we know at least one interesting example of weak monadic
second-order logic decision procedure, namely [25] we are
not aware of any implementation of the full monadic secondorder logic decision procedure for the infinite tree.

The relationship between the non-structural as well as
structural subtyping and monadic second-order logic of the
infinite binary tree and tree like structures [58] requires further study. In that respect the work on feature trees [36, 37]
appears particularly relevant.

Acknowledgements The first author would like to thank
Albert Meyer for pointing out to the work [15], and Jens
Palsberg and Jakob Rehof for useful discussions about the
subject of this paper.

References

[1] Alexander Aiken. Introduction to set constraint-based

program analysis. Science of Computer Programming,
35:79-111, 1999.

[2] Alexander Aiken, Dexter Kozen, and Ed Wimmers. Decidability of systems of set constraints with negative
constraints. Information and Computation, 122, 1995.

[3] Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. Soft typing with conditional types. In Proc.
21st ACM POPL, pages 163-173, New York, NY, 1994.

[4] Roberto M. Amadio and Luca Cardelli. Subtyping recursive types. Transactions on Programming Languages
and Systems, 15(4):575-631, 1993.

[5] L. O. Andersen. Program Analysis and Specialization

of the C Programming Language. PhD thesis, DIKU,
University of Copenhagen, 1994.

[6] Egon Boerger, Erich Graedel, and Yuri Gurevich. The

Classical Decision Problem. Springer-Verlag, 1997.

[7] Witold Charatonik and Leszek Pacholski. Set constraints with projections are in NEXPTIME. In Proc.
35th Annual Symposium on Foundations of Computer
Science (FOCS), pages 642-653, 1994.

[8] Witold Charatonik and Andreas Podelski. Set constraints with intersection. In Proc. 12th IEEE LICS,
pages 362-372, 1997.

[9] Hubert Comon. Disunification: A survey. In JeanLouis Lassez and Gordon Plotnik, editors, Computational Logic: Essays in Honor of Alan Robinson. The
MIT Press, Cambridge, Mass., 1991.

[10] Hubert Comon and Catherine Delor. Equational formulae with membership constraints. Information and
Computation, 112(2):167-216, 1994.

[11] Hubert Comon and Pierre Lescanne. Equational problems and disunification. Journal of Symbolic Computation, 7(3):371, 1989.

[12] Bruno Courcelle. Fundamental properties of infinite

trees. Theoretical Computer Science, 25(2):95-169,
March 1983.

[13] Rowan Davies and Frank Pfenning. Intersection types

and computational effects. In Proc. ICFP, pages 198-
208, 2000.

[14] S. Feferman and R. L. Vaught. The first order properties of products of algebraic systems. Fundamenta
Mathematicae, 47:57-103, 1959.

[15] Jeanne Ferrante and Charles W. Rackoff. The Computational Complexity of Logical Theories, volume 718 of
Lecture Notes in Mathematics. Springer-Verlag, 1979.

[16] Tim Freeman and Frank Pfenning. Refinement types

for ML. In Proc. ACM PLDI, 1991.

[17] Alexandre Frey. Satisfying subtype inequalities in polynomial space. Theoretical Computer Science, 277:105-
117, 2002.

[18] Yuri Gurevich and Leo Harrington. Trees, automata,

and games. In Proceedings of the fourteenth annual
ACM symposium on Theory of computing, pages 60-
65, 1982.

[19] Nevin Heintze and Olivier Tardieu. Ultra-fast aliasing

analysis using CLA: A million lines of C code in a second. In Proc. ACM PLDI, 2001.

[20] Fritz Henglein and Jakob Rehof. The complexity of subtype entailment for simple types. In Proc. 12th IEEE
LICS, pages 352-361, 1997.

[21] L. Henkin, J. D. Monk, and A. Tarski. Cylindric Algebras, Part I. North Holland, 1971.

[22] Wilfrid Hodges. Model Theory, volume 42 of Encyclopedia of Mathematics and its Applications. Cambridge
University Press, 1993.

49

[23] Trevor Jim and Jens Palsberg. Type inference in systems of recursive types with subtyping. http://www.
cs.purdue.edu/homes/palsberg/, 1999.

[24] Manfred Kerber and Michael Kohlhase. A mechanization of strong Kleene logic for partial functions. In
Alan Bundy, editor, Proc. 12th CADE, pages 371-385,
Nancy, France, 1994. Springer Verlag, Berlin, Germany.
LNAI 814.

[25] Nils Klarlund, Anders Mo/ller, and Michael I.

Schwartzbach. MONA implementation secrets. In Proc.
5th International Conference on Implementation and
Application of Automata. Lecture Notes in Computer
Science, 2000.

[26] Stephen Cole Kleene. Introduction to Metamathematics. D. Van Nostrand Company, Inc., Princeton, New
Jersey, 1952. fifth reprint, 1967.

[27] Dexter Kozen. Complexity of boolean algebras. Theoretical Computer Science, 10:221-247, 1980.

[28] Dexter Kozen, Jens Palsberg, and Michael I.

Schwartzbach. Efficient recursive subtyping. Mathematical Structures in Computer Science, 5(1):113-125,
1995.

[29] John W. Lloyd. Foundations of Logic Programming.

Springer-Verlag, 2nd edition, 1987.

[30] Michael J. Maher. Complete axiomatizations of the

algebras of the finite, rational, and infinite trees. Proc.
3rd IEEE LICS, 1988.

[31] Anatolii Ivanovic Mal'cev. The Metamathematics of

Algebraic Systems, volume 66 of Studies in Logic and
The Foundations of Mathematics. North Holland, 1971.

[32] Ursula Martin and Tobias Nipkow. Boolean unification:

The story so far. Journal of Symbolic Computation,
7(3):275-293, 1989.

[33] John McCarthy and James Painter. Correctness of a

compiler for arithmetic expressions. In Proceedings of
Symposia in Applied Mathematics. American Mathematical Society, 1967.

[34] John C. Mitchell. Type inference with simple types.

Journal of Functional Programming, 1(3):245-285,
1991.

[35] Andrzej Mostowski. On direct products of theories.

Journal of Symbolic Logic, 17(1):1-31, March 1952.

[36] Martin Mueller and Joachim Niehren. Ordering

constraints over feature trees expressed in secondorder monadic logic. Information and Computation,
159(1/2):22-58, 2000.

[37] Martin Mueller, Joachim Niehren, and Ralf Treinen.

The first-order theory of ordering constraints over feature trees. Discrete Mathematics and Theoretical Computer Science, 4(2):193-234, September 2001.

[38] Greg Nelson and Derek C. Oppen. Fast decision procedures based on congruence closure. Journal of the
ACM (JACM), 27(2):356-364, 1980.

[39] Derek C. Oppen. Reasoning about recursively defined

data structures. Journal of the ACM, 27(3), 1980.

[40] Frank Pfenning. Unification and anti-unification in the

calculus of constructions. In Proc. 6th IEEE LICS,
pages 74-85, 1991.

[41] Francois Pottier. Simplifying subtyping constraints: A

theory. Information and Computation, 170(2):153-183,
November 2001.

[42] Jakob Rehof. The Complexity of Simple Subtyping

Systems. PhD thesis, Computer Science Department,
Univ. of Copenhagen (DIKU), April 1998.

[43] Tatiana Rybina and Andrei Voronkov. A decision procedure for term algebras with queues. ACM Transactions on Computational Logic (TOCL), 2(2):155-181,
2001.

[44] Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm.

Parametric shape analysis via 3-valued logic. ACM
Transactions on Programming Languages and Systems
(TOPLAS), 24(3):217-298, 2002.

[45] J"org H. Siekmann. Unification theory. Journal of Symbolic Computation, 7(3):207-274, 1989.

[46] Thoralf Skolem. Untersuchungen "uber die Axiome des

Klassenkalk"uls and "uber "Produktations- und Summationsprobleme", welche gewisse Klassen von Aussagen
betreffen. Skrifter utgit av Vidnskapsselskapet i Kristiania, I. klasse, no. 3, Oslo, 1919.

[47] Bjarne Steensgaard. Points-to analysis in almost linear

time. In Proc. 23rd ACM POPL, St. Petersburg Beach,
FL, January 1996.

[48] Zhendong Su, Alexander Aiken, Joachim Niehren, Tim

Priesnitz, and Ralf Treinen. First-order theory of subtyping constraints. In Proc. 29th ACM POPL, 2002.

[49] Madhu Sudan. Quantifier elimination for boolean algebras is trivial. Personal Communication, MIT LCS
Elevator, 9 October 2002.

[50] Alfred Tarski. Arithmetical classes and types of algebraically closed and real-closed fields. Bull. Amer.
Math. Soc., 55, 64, 1192, 1949.

[51] Alfred Tarski. Arithmetical classes and types of boolean

algebras. Bull. Amer. Math. Soc., 55, 64, 1192, 1949.

[52] Wolfgang Thomas. Automata on infinite objects. In

Handbook of Theoretical Computer Science, Volume B,
pages 133-191. Elsevier and The MIT Press, 1990.

[53] Wolfgang Thomas. Languages, automata, and logic. In

Handbook of Formal Languages Vol.3: Beyond Words.
Springer-Verlag, 1997.

[54] Jerzy Tiuryn. Subtype inequalities. In Proc. 7th IEEE

LICS, 1992.

[55] Ralf Treinen. The first-order theory of ordering constraints over feature trees. Discrete Mathematics and
Theoretical Computer Science, 4(2):193-234, 2001.

[56] K. N. Venkataraman. Decidability of the purely existential fragment of the theory of term algebras. Journal
of the ACM (JACM), 34(2):492-510, 1987.

50

[57] Igor Walukiewicz. Monadic second-order logic on treelike structures. In STACS'96, volume 1046 of Lecture
Notes in Computer Science, 1996.

[58] Igor Walukiewicz. Monadic second-order logic on treelike structures. Theoretical Computer Science, 275(1-
2):311-346, March 2002.

51