

Observers for Linear Types

Martin Odersky

\Lambda 

Yale University, Department of Computer Science,

Box 2158 Yale Station, New Haven, CT 06520

odersky@cs.yale.edu

European Symposium on Programming

February 1992

Abstract
Linear types provide the framework for a safe embedding of mutable state in
functional languages by enforcing the principle that variables of linear type must
be used exactly once. A potential disadvantage of this approach is that it places
read accesses to such variables under the same restriction as write accesses, and
thus prevents reads to proceed in parallel. We present here an extension of linear
types which augments the usual distinction between linear and non-linear by a
third state, observers of linear variables. Since, unlike linear variables, observers
can be duplicated, multiple concurrent reads are made possible. On the other hand,
observers must be short-lived enough to never overlap with mutations. The resulting
type system is in many aspects similar to the one of ML: It is polymorphic, has
principal types, and admits a type reconstruction algorithm.

1 Introduction
We are investigating a type system that addresses the update problem in functional
languages: How can we implement updates efficiently, but still retain a declarative semantics? Methods to solve this problem -- of which there are many -- usually come
under the name of effect analysis. Effect analysis looks for opportunities to replace costly non-destructive operations on aggregates such as arrays or hash tables by cheaper
destructive ones. This can take place at run-time, using reference counting [GSH88] or
reverse difference lists [Coh84]. It can also be performed at compile-time, using one of
the optimization techniques of [Hud87, NPD87, Blo89, Deu90, DP90], for instance. A
third alternative is to let the programmer perform effect analysis, and reduce the task
of the computer to effect checking; the computer simply verifies that the transition from
non-destructive to destructive operations is semantics preserving. In this setting it is

\Lambda work was done in part while at IBM T.J. Watson Research Center.

1

natural to regard effect information to be a kind of type information and effect checking
to be an extension of type checking.

The main advantage of this programmer-directed approach is that the choice between
copying and in-place updates is made visible. Hence, the programmer can avoid the
potentially drastic efficiency loss which could otherwise result from missed optimization
opportunities. This is most important in the presence of separate compilation and software component libraries. Users of such libraries have to know how they can access the
exported components without risking performance degradation. As the standard way of
communicating such legal use-patterns is a type system, it seems to be a good idea to
augment types with effect information. However, effect checking type systems face the
double challenge of avoiding being either too restrictive or too complex. After all, unlike
automatic optimizers, programmers are willing to digest only a limited amount of effect
information.

We present here an approach towards an effect checking type system which meets these
challenges. Observable linear types are loosely based on Wadler's "steadfast, standard"
version of linear types and extend it by adding "read-only" (in our terms: observer)
accesses to linear variables. In [Wad91] this extension was acknowledged to be an open
research problem.

Linear type systems [Laf88, Abr90, Wad91] are related by the Curry-Howard isomorphism
to Girard's linear logic [Gir87]. They are based on the principle that a variable of linear
type must be used exactly once. If linear types are steadfast, that is, not convertible
with non-linear types, this principle allows updates to linear variables to be performed
destructively and also obviates the need for garbage collecting them. In the terminology
of [Wad90b], linear variables make up the "world", which can be neither duplicated nor
discarded.

The "no-duplication" restriction on linear variables makes them a bit awkward to use in
programming. Observation of the world is placed under precisely the same restrictions
as changes to it, although it is clearly much less intrusive. To address this shortcoming,
Wadler suggested in [Wad90b] a construct which exceeds linear logic by allowing the
world to be observed in a local context. This is written

let! (a) x = e0 in e: (1)
Here, the linear variable a, used once in the outer expression e, may also be read arbitrarily often in the local expression e0. To make this construct safe, Wadler proposed
the following measures: First, a hyperstrict evaluation rule which specifies that e0 be
reduced to normal form before evaluation of e is begun. Second, a static restriction that
all components of a and x have mutually distinct types. Finally, a static restriction that
x may not be of function type. The static restrictions prevent the normal form of x
from sharing the value of the linear variable a. Together with the hyperstrict evaluation
rule this ensures safety, but at quite drastic cost: In particular the "mutually distinct
types" requirement is an overly conservative approximation to the actual aliasing in a
let! construct. The approximation becomes even worse if the type system is polymorphic
(the one in [Wad90b] isn't). In that case, the notion of equality between types has to
be replaced by unifiability. As a consequence, virtually every let! construct is unsafe in
which the type of either the linear or the bound variable is polymorphic. Hence, we see
that linear types have so far been better at changing the world than at observing it.

2

In this paper, we look at a more thorough solution to the observer problem. We will
be concerned only with the "no-duplication" property of linear types, not with the "nodiscarding" property which allows static garbage collection. The principal idea is to
extend the distinction between linear and nonlinear variables by a third state, which
denotes observers of linear variables. In the let! construct (1), all occurrences of the
linear variable a in e0 would now have type "observer". Unlike linear types themselves,
observers can be duplicated freely (this implies that updates to observers are forbidden).
However, observers have to be short-lived, they may not be exported out of the scope of
a let! binding. This enforces observation and updating of linear variables to occur in a
strictly alternating fashion, where no observer lives long enough to observe an update.

Linear, non-linear and observer constitute the three basic aliasing states of a variable.
These states are attributes of the types in our system. The type system has the following
useful properties:

ffl It is polymorphic in types and alias states. Type polymorphism means that a type

variable ranges over all types, linear, non-linear and observers. Aliasing polymorphism means that the aliasing attribute of a type may be a variable.

ffl It has the principal type property. That is, given a closed initial type assignment

A, every well-typed expression has a most general type-scheme oe.

ffl It admits a type reconstruction algorithm which assigns an expression its principal

type-scheme. Type reconstruction can work without type declarations for bound
variables.

ffl With a few straightforward abbreviations, function signatures can be written in

a concise form, of comparative complexity to the use of in and out specifiers in
Ada. This observation might seem somewhat surprising, since our type system is
definitely more complex than the standard Hindley/Milner system, say. A partial
explanation might be that much of our machinery has to do with observer types
which occur only in a local context, and by definition do not show up in the type
signatures of defined variables.

Other Related Work
Schmidt [Sch85] suggested a simple type system which gives conditions for safety of inplace updates. Other early work was done in the FX project [LG88, JG91] and the area
has been an active research subject in the last few years. Observable linear types build on
several previous approaches. Besides the strong connection to linear types, there is also a
connection to Baker's "free" region analysis [Bak90] for type reconstruction. Regions do
not enter our system explicitly, but the notion of region in [Bak90] or [TJ91] corresponds
exactly to a collection of types with the same alias variable as an attribute.

Another popular approach to the update problem uses abstract data types to encapsulate accesses to mutable data structures. The idea is to have an abstract type of "state
transformers", but no type for the transformed data structures itself [Wad90a]. There
is a single operation, block, which creates a mutable data structure serving as a scratch

3

area, applies a state transformer to it, and returns the (immutable) result of the application while discarding the scratch area. This has the advantage that no extension to
traditional type systems is needed, but it requires programming in a continuation passing
style. Also, it is currently not clear how the method should be extended to deal with
several mutated data structures. The latter problem is addressed in the non-standard
type system of [SRI91] which again requires continuation passing style. Continuation
passing style is problematic since it fully sequentializes lookups as well as updates. By
contrast, observable linear types allow lookups to proceed in parallel and generally impose much less restrictions on programming style. The latter point is important in the
situation where a purely functional program is transformed into a program with transparent updates by changing the implementation of some data types. Observable linear types
allow such efficiency-improving transformations to be performed incrementally, without
requiring a complete rewrite.

Compared to analyses based on liabilities and function effects [GH90, Ode91], linear
types augmented with observers are less precise in some cases and more precise in others. Liabilities give information about which variables are possible aliases of each other,
whereas alias states only record the fact that a variable might be aliased. Hence, using
liabilities we can verify some expressions to be safe which cannot be handled by all other
approaches. On the other hand, current liability-based approaches are less accurate for
non-flat mutable structures. Moreover, when extended to higher-order functions, they
do not admit "nice" principal types (i.e. they need disjunctive constraints, see [Ode91]
for an example). We believe that approaches based on linear types will turn out to be
more practical than liability-based approaches because they tend to be more concise and
generalize naturally to the higher-order case.

The rest of this paper is organized as follows: Section 2 defines the syntax of types in
a small example language. Section 3 discusses their use in several program examples.
Section 4 presents typing rules. Section 5 discusses a type reconstruction algorithm.
Section 6 concludes.

2 Observable Linear Types
Language
We use essentially the language of [Wad90b], with the exception of let! constructs, where
in our case observers of linear variables need not be quoted. Quoting these variables
explicitly is undesirable since it restricts polymorphism, and our type reconstruction
algorithm can work without it.

4

Expressions e ::= x identifiers

j e e0 application
j *x:e abstraction
j *1x:e linear abstraction
j let x = e0 in e definition
j let! x = e0 in e sequential definition
j if e1 then e2 else e3 conditional

Monomorphic Types
We start with a type system which is monomorphic in its aliasing aspects (but polymorphic in its structural aspects). A type in this system (called a monotype in the following)
consists of two parts ff\Delta AE which describe outside aliasing and internal structure, respectively. The components are separated by an infix dot (\Delta ).

Monomorphic types o/ = ^ basic type

j list o/ list type
j o/1 ! o/2 function type
j ff\Delta o/ alias state \Delta  type
j t type variable

Alias states ff = 0 j 1 j 2 observer, linear, non-linear
In our example language, we will use only a few different forms of types o/ , namely
(immutable) basic types, mutable lists, and function types. We will see in Section 3
how other mutable data structures such as arrays or matrices can be constructed from
mutable lists. Hence, there is no need for modeling these structures in the type system
(although an implementation should certainly treat them as special cases).

The aliasing part ff of a monotype is one of the three constants 0, 1, and 2. Variables
of a 1-type may be accessed only once, and we have the invariant that at most one
reference can exist to values of these types. 1-types correspond to linear types, and, in
a slight misuse of language, we will also call them linear. The correspondence is not
exact, since we are concerned only with the "no-duplication" property of 1-types, and
allow discarding a value of 1-type, whereas this is forbidden in pure linear type systems.
Variables of 2-type (or: non-linear type) may be accessed arbitrarily often and may share
references with other non-linear variables. The third category of types are the observer-,
or 0-types. Observer types allow linear variables to be used more than once. They don't
"add to" linear uses (that's why they are given denotation 0). When used locally in
a let! construct, all occurrences of a variable which is linear at the outside are given
observer type inside. There may be several such occurrences, but no observer variable
may form part of the value which is locally defined in that expression. Put in other
words, all components of the type of a variable defined by a let! must have 1- or 2-type.
Assuming that the evaluation of let! definitions is hyperstrict, we can hence ensure that
observation and updating of linear variables occur in a strictly alternating fashion.

5

Composite list types have an aliasing attribute for the whole type and an attribute for
the element type at each level. Not every combination of alias attributes is permissible,
we require that a list type is well-formed:

Definition. The monotype ff\Delta list (fi\Delta AE) is well-formed iff

ff 2 f0; 2g ) fi 2 f0; 2g
The well-formedness condition is needed to ensure that a linear element is not shared (or
observed) indirectly by sharing (or observing) its parent.

Monomorphic observable linear types give rise to a type system which extends the steadfast types of [Wad91] with observers. As an example of its use, consider a function which
copies an array element to another index position. Assume for the time being that arrays are implemented as lists, with operations (!) for indexing and (update) for in-place
updates.

assign = *i: *j: *a: let! x = a!i in update j x a
Our type system will assign type 0\Delta list (2\Delta v) to the first, local occurrence of the array a.
The type of the locally defined variable x is (2\Delta v) and thus satisfies the restriction that
local definitions in a let! cannot be of observer type. The last occurrence of a has type
1\Delta list 2\Delta v, reflecting the fact that variable a is modified. The type of the whole function
is:

assign : int ! int ! 1\Delta list (2\Delta v) ! 1\Delta list (2\Delta v):
This expresses that the array argument is modified (and therefore has to be linear),
whereas one of its elements is duplicated (and therefore must be non-linear). The observer
state was used only locally; it allowed us to use the linear variable a twice.

The monomorphic type system is still quite inflexible. For instance, it is not possible
to formulate a function head which works equally on linear and non-linear lists, since
the alias state of function arguments is fixed. The obvious way to lift this restriction
is to introduce variables which range over alias states, and we will do so in the next
sub-section.

Polymorphic Types
A polymorphic observable linear type (called polytype in the following) has a variable in
its alias component. The variable usually ranges over the three alias states, but its range
can be constrained by predicates. Following [Jon91a], we express this using the syntax
of qualified types:

Alias Parts ff = 0 j 1 j 2 j t j O ff
Qualified Types ae = ss ) ae j o/
Predicates ss = ff ^ 0 j ff ^ 1 j ff ^ 2 j ff ' o/
Type Schemes oe = 8t:oe j ae

6

Observer tags O are the polymorphic equivalent of the mapping from (monomorphic)
linear to observer status in the monomorphic system. If a bound variable x has type a\Delta AE
outside of a let!-construct, it is given type Oa\Delta AE inside. This serves as a "reminder" that
any value assumed by variable a at the outside has to be translated to observer status
inside.

Type variables can be constrained by predicates. There are two forms of such predicates.
The first form, ff ^ n, constrains the range of ff to a a subset of all three alias-sets. The
three two-element alias-sets are characterized as complements of a singleton set. 0 (nonobserver, or original) encompasses 1 and 2. Variables defined in a let! are required to be
originals. 1 (aliased) encompasses 0 and 2. If a function uses an argument several times
outside of a let! construct, the argument's type falls in this set. Finally, 2 encompasses
0 and 1.

Note that by combining any two of these constraints, we get a monotype!. For instance,
8a:a ^ 0 ) a ^ 1 ) a\Delta o/ is equivalent to 2\Delta o/ . If a variable is simultaneously bounded
by all three constraints, the constraint set is unsatisfiable and the corresponding type is
empty.

The second form of constraint makes the well-formedness criterion for list types explicit.
The predicate ff ' o/ is equivalent to the constraint set

ff ^ 1 ) fi ^ 1
where fi ranges over all the alias parts of o/ and its component types. The typing rules are
such that every occurrence of ff\Delta (list o/ ) in a principal type is constrained by a predicate
ff ' (list o/ ).

Example 2.1 The type of function map would be expressed as follows:

map : 8s8t8a8b: (a ' list s) ) (b ' list t) ) 2\Delta (s ! t) ! a\Delta list s ! b\Delta list t;

For conciseness, we will in the following drop (ff ' o/ ) constraints on a type if they are
implied by the structure of the type itself, i.e. if the type contains a subtype of the form
ff \Delta  o/ . We will also drop the alias part of a type altogether if it is trivial, i.e. equal to
an unconstrained, unshared type variable. Finally, we allow multiple predicates to be
grouped together, i.e. (ss1 ) ss2 ) ae) = (ss1; ss2 ) ae).

Example 2.2 Using these shorthands, the type of map would be written:

map : 8s8t: 2\Delta (s ! t) ! list s ! list t:

Predefined Identifiers
As predefined we assume the fixpoint operator fix, and a set of operators on lists.
Besides the conventional operators nil; cons; hd and tl, we also have a destructive update
operation on lists. rplac takes as arguments two functions f and g which map list heads
to list heads and list tails to list tails. Its third argument is a list xs of linear type. The
value of

rplac f g xs is cons (f (hd xs)) (g (tl xs));

7

and as a side-effect the first cons-node of xs is replaced by this value. The types of the
predefined identifiers are:

nil : 8a8t: a\Delta list t
cons : 8a8t: t ! a\Delta list t ! a\Delta list t
hd : 8a8t: a\Delta list t ! t
tl : 8a8t: a\Delta list t ! a\Delta list t
rplac : 8a8b8t: 2\Delta (t ! t) ! 2\Delta (a\Delta list t ! b\Delta list t) ! 1\Delta list t ! b\Delta list t
fix : 8v: 2\Delta (2\Delta v ! 2\Delta v) ! 2\Delta v :

The type of rplac merits further consideration. One might think that since the tailreplacing function in the second argument is passed a linear list, its type should really
be (1\Delta list t ! b\Delta list t). This would lead to some needless loss of polymorphism, however.
After all, just because an argument is linear (i.e. unshared), a function applied to it
should not be required to exploit the linearity by overwriting the argument. The correct
interpretation is that arguments which are known to be linear can safely be used in
any way whatsoever. The most general type of the tail-replacing function is therefore
(a\Delta list t ! b\Delta list t).

The type of the fixpoint operator also needs some explanation. fix is defined only on
transformations between non-linear values and its result is again a non-linear value. To
see why taking the fixpoint of a transformation between linear values is problematic,
consider the expression

mkcirc : 1\Delta list Int ! 1\Delta list Int
mkcirc = *xs: cons 1 (rplac (\Gamma 1) id xs) ;

where (\Gamma 1) is the predecessor function on integers. If fix were defined for transformations
between linear values, fix mkcirc would be legal, of type 1\Delta  list Int. But what is the
value of this expression? If we disregard side-effects and look at the definition of rplac's
result above, it should be the list [1; 0; 0; :::]. If we take side-effects into account, however,
and assume that the list is evaluated in a head-strict order, we get the list [0; 0; 0; :::].
This violates the requirement that all side-effects of well-typed expressions should be
transparent.

3 Examples
This section tries to give a "feel" of our type system by means of small example programs.
We hope to convey the impression that the type signatures of most functions occurring
in practice are quite reasonable in size and complexity and also closely correspond to the
programmer's intuition. First, here is a side-effecting version of the append function:

append = fix *append: *xs: *1ys:

if xs = nil then ys
else rplac id (*tl: append tl ys) xs

The typing rules presented in the next section give append the type:

8

append : 8a8t: 1\Delta list t ! 1\Delta (a\Delta list t ! a\Delta list t)
Since the first list argument to append gets updated, it must be linear, of type 1\Delta list t.
The type of a curried application like append xs must also be linear, because append xs
contains a reference to a linear variable. Otherwise, we could duplicate accesses to xs in
an expression such as

(*f: (f ys; f zs)) (append xs):
The language has a special form of *-abstraction, denoted *1, to define linear functions
which have "global" side-effects (i.e. which modify variables other than their arguments).
Having two forms of *-abstraction does cause some loss of polymorphism in that we have
to declare statically whether a function is going to have a global side-effect or not. This
can be difficult to predict for higher-order functions. It appears that our type system
could be extended to deal with just one kind of * abstraction for linear and non-linear
functions using a technique similar to the one in [Wad91]. This would add constraints
to type signatures, however, something we wanted to avoid because of the syntactic
overhead associated with it. A good alternative, which also avoids the use of *1, is to
have the modified argument come last:

append0 : 8a8t: a\Delta list t ! 1\Delta list t ! a\Delta list t
append0 xs ys = append ys xs

To simplify presentation, we will from now on allow functions to be written in the equational style. The translation to *-abstractions and fixpoint operators should be obvious.

The append function uses the rather "heavyweight" operation rplac. We can simplify
this by using specialized versions of rplac which replace only heads or only tails:

rplhd : 8t: 2\Delta (t ! t) ! 1\Delta list t ! list t
rpltl : 8a8t: 2\Delta (list t ! a\Delta list t) ! 1\Delta list t ! a\Delta list t

rplhd f = rplac f id
rpltl f = rplac id f

Remember that list t, the result type of rplhd, is an abbreviation for a\Delta list t, where a is
a fresh type variable. That is, the alias part of rplhd's result type is unconstrained.

Here are linear equivalents of the higher order functions map and foldl:

maplin : 8t: 2\Delta (t ! t) ! 1\Delta list t ! list t
maplin f = rplac f (maplin f)

foldlin : 8s:8t: 2\Delta (t ! s ! s) ! list t ! s ! s:
foldlin f xs acc= if xs = nil then acc

else foldlin f (tl xs) (f (hd xs) acc)

maplin maps a function on a linear list, replacing every node of that list by its corresponding node in the result list. foldlin does not restrict any argument to be linear, in

9

fact it is just Haskell's foldl with the second and third argument swapped. foldlin f is
side-effecting if f is, and is pure otherwise.

Here are some other functions on lists:

upd : 8t: int ! 2\Delta (t ! t) ! 1\Delta list t ! list t
upd i f = if i = 0 then rplhd f else upd (i \Gamma  1) f ffi tl

swap : 8t: int ! int ! 1\Delta list t ! list t
swap i j xs = let! x = xs!i in

let! y = xs!j
in (upd i (K y) ffi upd j (K x)) xs

Function upd updates a selected element of a list, and swap exchanges two list elements.
Using lookups (!) and updates (upd), we can express mutable vectors in terms of lists.
Higher-dimensional mutable arrays can be defined, too. For instance, the update operation for a matrix, represented as a list of lists, is:

type a\Delta mat t = a\Delta list (a\Delta list t)
upd2 : int ! int ! 2\Delta (t ! t) ! 1\Delta mat t ! mat t
upd2 i j f = upd i (upd j f)

For a larger example, we now turn to topological sorting. We want to find a total order
for the nodes of a graph in which every node precedes its successors. To make our task
of designing an efficient algorithm easier, we assume that the graph is in a convenient
representation, given by:

ffl the list sources : list node of all sources in the graph,
ffl a list succs : list (list node) which contains for every node in the graph the list of

all its successors.

ffl a linear list npreds : 1 \Delta  list int which contains for every node in the graph the

number of its predecessors. This list serves as a "scratch area".

We also assume that node = int such that we can index lists with nodes. Given this
graph representation, we can formulate the topological sorting function as follows:

tsort : 2\Delta list node ! list (list node) ! 1\Delta list int ! list node
tsort sources succs npreds =

if sources = nil then

nil
else

let src = hd sources in
let decnth = *n: upd n (\Gamma 1) in
let! npreds0 = foldlin decnth (succs!src) npreds in
let! sources0 = filter (*x: npreds0!x = 0) (succs!src) a` tl sources
in cons src (tsort sources0 succs npreds0)

10

var A; P ` x : oe (x : oe 2 A)
8I A; P ` e : oeA; P ` e : 8t:oe (t 62 tv A [ tv P )

8E A; P ` e : 8t:oeA; P ` e : [o/ =: t] oe
) I A; P:ss ` e : aeA; P ` e : ss ) ae
) E A; P ` e : ss ) aeA; P ` e : ae (P `` ss)

Figure 1: Structural Rules for OLT

taut P `` ss (ss 2 P )
lit P `` 1 ^ 0 P `` 2 ^ 0

P `` 0 ^ 1 P `` 2 ^ 1
P `` 0 ^ 2 P `` 1 ^ 2

obs P `` Off ^ 1 P `` ff ^ 2P `` Off ^ 2

wf P `` ff ' list (fi\Delta o/ )P `` ff ' o/ P `` ff ' list (fi\Delta o/ ) P `` ff ^ 1P `` fi ^ 1

Figure 2: Entailment Rules for ``
If we assume that mutable lists are implemented as vectors, such that lookups and
updates have both constant cost, then the complexity of topsort is O(jnodes j + j edgesj),
which matches the best known imperative algorithms. This remains true even if we use
a more standard graph representation consisting of a node list and an edge list, since
these lists can be converted in O(jnodes j + j edgesj) time into the representation we have
assumed.

4 Typing Rules
We formulate the system OLT of observable linear types as a a system of qualified types
[Jon91a]. Sequents are of the form A; P ` e : oe, where the type assignment A is a set
of assumptions x : oe0, and the context P is a set of predicates ss. We use tv oe or tv A

11

! I A:x : o/

0; P ` e : o/

A; P ` *x:e : ff \Delta  (o/ 0 ! o/ ) (P `` N L A)

!1 I A:x : o/

0; P ` e : o/

A; P ` *1x:e : 1\Delta (o/ 0 ! o/ )

! E A; P ` e : ff\Delta (o/

0 ! o/ ) A; P ` e0 : o/ 0

A; P ` e e0 : o/ (P `` fff ^ 0; g [ N L Ajfv e

0"fv e)

let A; P ` e

0 : oe A:x : sigma; P ` e : o/

A; P ` let x = e0 in e : o/ (P `` N L Ajfv e

0"fv e)

let! A

0; P ` e0 : oe A:x : oe; P ` e : o/

A; P ` let! x = e0 in e : o/ (obs(A

0; A; fv e); orig (P ) oe)

if A

0; P ` e1 : bool A; P ` e2 : o/ A; P ` e3 : o/

A; P ` if e1 then e2 else e3 : o/ (obs(A

0; A; fve1 [ fv e2))

Figure 3: Logical Rules for OLT

to denote the free type variables in a type scheme or type assignment. We use fv e to
denote the free program variables in an expression. We use letters P , Q, R to denote
sets of predicates ss. Type schemes oe will often be written 8ffi:P ) o/ , where ffi denotes
the bound variables and P denotes the predicates in oe. Analogous to qualified types, we
will also use qualified type schemes of the form P ) oe, where the predicate P constrains
the free variables in oe.

Structural rules for OLT are given in Figure 1. Rule () E) is based on an entailment
relation `` between predicate sets and predicates, which is defined in Figure 2. Here,
rules (lit) define the relationship between monomorphic alias sets 0; 1; 2 and alias sets
0; 1; 2, as explained Section 2. Rules (obs) determine the predicates that hold for tagged
alias parts Off: they are never linear, and are of 2-type iff the untagged alias part is of
2-type. Finally, rules (wf) correspond to the well-formedness criterion on list types.

Relation `` is extended to a relation between predicate sets by defining Q `` P iff Q `` ss
for all ss 2 P . It has the following useful properties:

Theorem 4.1 (a) `` is monotonic, ss 2 P implies P `` ss.
(b) `` is transitive, P `` Q and Q `` R imply P `` R.
(c) `` is closed under substitution, P `` Q implies SP `` SQ for every substitution S.

Proof: (a) follows from rule (taut), (b) and (c) follow from the fact that `` is defined by
a sequent calculus. 2

Definition. Let F denote the constraint set fff ^ n j n 2 f0; 1; 2gg, for an arbitrary
alias part ff. A constraint set P is satisfiable iff P 6`` F . A qualified type scheme
P ) (8ffi:Q ) ae) is empty if P [ Q is unsatisfiable.

12

Theorem 4.2 (a) For every constraint set P and substitution S, If P is unsatisfiable,
then so is SP .
(b) For every constraint set P , it is decidable whether P is satisfiable or not.

Proof: (a) is a direct consequence of Theorem 4.1(c). We now prove (b). Let P be a set
of predicates and let P \Lambda  be the `` closure of P . Then, P `` F iff P \Lambda  ' F . We show
that it suffices to look at the subset P 0 of P \Lambda  which consist of all predicates in P \Lambda  whose
alias-parts also appear in P . A predicate on an alias part that is in P \Lambda  but not in P can
only be generated by application of rule (obs), with conclusion Off ^ n, say. But then
there is no way to deduce O ff ^ 0, since there is no rule with a conclusion of this form.
Hence, P `` F , P \Lambda  ' F , P 0 ' F . Since P 0 is finite, (b) follows. 2

Logical rules are given in Figure 3. There are two rules for the introduction of functions.
Rule (!1 I) introduces linear functions which can have global side-effects. Rule (! I)
introduces functions without such effects. Absence of global side-effects is enforced in
(! I) by the condition that no identifier in the type assignment A can have linear type.

Rules (*I); (! E) and (let) impose a nonlinearity constraint on (part of a) type assignment. N L A yields a set of constraints which together imply that A contains no linear
types. It is defined by:

N L A = fff ^ 1 j x : ff\Delta o/ 2 Ag

The conditions in rule (let!) replace the "distinct types" condition of [Wad90b]. First,
the local environment A0 and the global environment A are related by a constraint
obs(A0; A; fv e), in words: A0 observes A on the free variables of e. We define relation
obs between type assignments, type schemes and types, and alias parts by a set of Horn
clauses as follows:

8x 2 fvs:obs(A0x; Ax) ) obs(A0; A; fvs)

obs(oe0; oe) ) obs(8ff:oe0; 8ff:oe)

obs(ae0; ae) ) obs(ss ) ae0; ss ) ae)
obs(o/ 0; o/ ) ) obs(Ot\Delta o/ 0; t\Delta o/ )
obs(o/ 0; o/ ) ) obs(2\Delta o/ 0; 2\Delta o/ )
obs(o/ 0; o/ ) ) obs(0\Delta o/ 0; 1\Delta o/ )
obs(o/ 0; o/ ) ) obs(list o/ 0; list o/ )
obs(o/ 01; o/1); obs(o/ 02; o/2) ) obs(o/ 01 ! o/ 02; o/1 ! o/2)

obs(^; ^)

This expresses that the local environment is isomorphic to the global environment, but
with every part in Ajfvs mapped to observer status. This mapping to observer state,
together with the requirement that the type o/ of the locally defined value may not
contain observers, make the let! construct safe. The latter requirement is expressed by
orig (P ) oe), defined as follows:

orig (P ) 8ffi:Q ) o/ ) = P [ Q `` fff ^ 0 j ff is an alias part in o/g

13

var A; P ` x : o/ (x : oe 2 A; oe * (P ) o/ ))
! I A:x : o/

0; P ` e : o/

A; P ` *x:e : ff\Delta (o/ 0 ! o/ ) (P `` N L A)

!1 I A:x : o/

0; P ` e : o/

A; P ` *1x:e : 1\Delta (o/ 0 ! o/ )

! E A; P ` e : ff\Delta (o/

0 ! o/ ) A; P ` e0 : o/ 0

A; P ` e e0 : o/ (P `` fff ^ 0g [ N L Ajfv e

0"fv e)

let A; P

0 ` e0 : o/ 0 A:x : gen(A; P 0 ) o/ 0); P ` e : o/

A; P ` let x = e0 in e : o/ (P `` N L Ajfv e

0"fv e)

let!

A0; P 0 ` e0 : o/ 0
A:x : gen(A0; P 0 ) o/ 0); P ` e : o/

A; P ` let! x = e0 in e : o/

(obs(A0; A; fv e)); orig (P 0 ) o/ 0))

if A

0; P 0 ` e1 : bool A; P ` e2 : o/ A; P ` e3 : o/

A; P ` if e1 then e2 else e3 : o/ (obs(A

0; A; fv e1 [ fv e2))

Figure 4: Deterministic Typing Rules for DOLT

The interpretation of these rules has to take into account that constraint sets may be unsatisfiable and that types may be empty. Since the primary motivation for type checking
is to detect empty types, we adopt the following definition:

Definition. An expression e has a type scheme oe under type assignment A and constraints P , written A; P oe e : oe, if there is a proof in OLT of A; P ` e : oe such that every
proof step has a conclusion A0; P 0 ` e0 : oe0 with P 0 ) oe0 satisfiable.

5 Principal Typings and Type Reconstruction
This section states and proves the principal type property for observable linear types
and gives a sketch of a type reconstruction algorithm. To simplify our task, we first
define in Figure 4 another type system, DOLT, and prove its equivalence to OLT. Unlike
OLT, DOLT is deterministic and syntax-directed; the structure of all proof trees for a
given typing are isomorphic, and every proof step is determined uniquely by the form
of the expression e. The typing rules of DOLT translate directly into a Prolog or Typol
[CDD+85] program for type reconstruction.

The following definitions, theorems, and proofs lean heavily on the theory of qualified
types developed in [Jon91a, Jon91b]. We will concentrate here on aspects which are
specific to observable linear types, while referring to Jones' work for all aspects that
apply to systems of qualified types in general. This is possible since the entailment
relation `` satisfies the requirements set out in [Jon91a], as stated in Theorem 4.1.

14

Definition. A qualified type scheme P ) (8ffi:Q ) o/ ) has a generic instance R ) _,
written P ) (8ffi:Q ) o/ ) * R ) _, iff there are types o/i such that

_ = [ffi 7! o/i] o/ and R `` P [ [ffi 7! o/i] Q:

Definition. A qualified type scheme P ) oe is more general than a qualified type scheme
P 0 ) oe0, written P ) oe * P 0 ) oe0, iff (P 0 ) oe0) * ae ) (P ) oe0) * ae: for all
qualified types ae.

Clearly, * is a preorder.
Definition. A qualified type scheme P ) oe is principal for an expression e and a type
assignment A, iff A; P oe e : oe, and, if A; P 0 oe e : oe0 then P ) oe * P 0 ) oe0.

In the following, we will use `0 for deduction in DOLT, and continue to use ` for
deduction in OLT .

Theorem 5.1 (Soundness of DOLT) If A; P `0 e : o/ then A; P ` e : o/ .
Proof: A straightforward induction on the structure of the proof of A; P `0 e : o/ . 2
The next four lemmata have equivalents in [Jon91b] and are proved in essentially the
same way as done there.

Lemma 5.2 (Substitution lemma) If A; P `0 e : o/ then SA; SP `0 e : So/ , for every
substitution S.

Lemma 5.3 If A; P `0 e : o/ and Q `` P then A; Q `0 e : o/ .
Lemma 5.4 If P `` P 0 then gen(A; P 0 ) o/ ) * gen(A; P ) o/ ).
Lemma 5.5 If A:x : oe; P `0 e : o/ and oe0 * P ) oe then A:x : oe0; P `0 e : o/ .
Theorem 5.6 (Completeness of DOLT) If A; P ` e : o/ then there is a set of predicates
P 0 and a type o/ such that A; P 0 ` e : o/ and gen(A; P 0 ) o/ ) * P ) oe.

Proof: By induction on the structure of the proof of A; P ` e : o/ . The structural rules
are treated exactly as in the proof of Theorem 2, [Jon91b]. The cases for the logical rules
are as follows:

Case(! I) : We have a derivation of the form

A:x : o/ 0; P ` e : o/
A; P ` *x:e : ff \Delta  (o/ 0 ! o/ ) (P `` N L A):

By induction, A:x : o/ 0; P 0 `0 e : AE for some P 0; AE with gen(A:x : o/ 0; P 0 ) AE) * P ) o/ . By
the definition of gen, there is a substitution S on the free type variables ffi of P 0 ) AE,

15

such that P `` SP 0 and o/ = SAE. By Lemma 5.2, and the fact that none of the ffi appear
in A:x : o/ 0, A:x : o/ 0; SP 0 `0 e : o/ . Define R = SP 0 [ N L A. Then P `` R `` SP 0. We can
thus construct the derivation:

A:x : o/ 0; SP 0 `0 e : o/

A:x : o/ 0; R `0 e : o/
A; R `0 *x:e : ff \Delta  (o/ 0 ! o/ )

(Lemma 5:3)
(! I)

Furthermore, by Lemma 5.4, gen(A; R ) ff \Delta  (o/ 0 ! o/ )) `0 * gen(A; P ) ff \Delta  (o/ 0 ! o/ )) *
P ) ff \Delta  (o/ 0 ! o/ ):

Case (! E) : We have a derivation of the form:

A; P ` e : ff\Delta (o/ 0 ! o/ ) A; P ` e0 : o/ 0

A; P ` e e0 : o/ (P `` ff ^ 0; P `` N L Ajfv e

0"fv e)

By induction, A; P 0 `0 e : AE with gen(A; P 0 ) AE) * P ) ff\Delta (o/ 0 ! o/ ). By the definition of
gen, there is a substitution S on the free type variables ffi of P 0 ) AE, such that P `` SP 0
and ff\Delta (o/ 0 ! o/ ) = SAE. By Lemma 5.2, and the fact that none of the ffi appear in A,
A; SP 0 `0 e : ff\Delta (o/ 0 ! o/ ). Using the induction hypothesis on the second premise of (! E),
we can show by a similar argument that A; S0Q0 `0 e0 : o/ 0 for some predicate set Q0 and
substitution S0 such that P `` S0Q0. Define R = SP [ S0P 0 [ fff ^ 0g [ N L Ajfv e0"fv e.
Then P `` R. We can thus construct the following derivation:

A; SP 0 `0 e : ff\Delta (o/ 0 ! o/ )

A; R `0 e : ff\Delta (o/ 0 ! o/ ) (Lemma 5:3)

A; S0Q0 `0 e0 : o/ 0

A; R `0 e0 : o/ 0
A; R `0 e e0 : o/

(Lemma 5:3)
(! E)

Also, by construction, R `` fff ^ 0g [ N L Ajfv e0"fv e). Furthermore, using Lemma 5.4,
gen(A; R ) o/ ) * gen(A; P ) o/ ) * P ) o/ .

Case (let!) : We have a derivation of the form:

A0; P ` e0 : oe A:x : oe; P ` e : o/

A; P ` let! x = e0 in e : o/ (obs(A

0; A; fv e); orig(P ) oe))

By induction, we have

A0; P 0 `0 e : AE; oe0 = gen(A0; P 0 ) AE) * P ) oe;
A:x : oe; Q0 `0 e0 : o/ 0; gen(A:x : oe; Q0 ) o/ 0) * P ) o/:

Without loss of generality, we can assume (A): tv P " tv (Q0 ) o/ 0) ` tv (A:x : oe): This
can always be achieved by a suitable renaming of the free variables in Q0 ) o/ 0. We can
construct the derivation

A0; P 0 `0 e : AE

A:x : oe; Q0 `0 e0 : o/ 0
A:x : oe; P [ Q0 `0 e0 : o/ 0
A:x : oe0; P [ Q0 `0 e0 : o/ 0
A; P [ Q0 `0 let! x = e0 in e : o/ 0

(Lemma 5:3)
(Lemma 5:5)
(let!)

with conditions obs(A0; A; fv e); orig(P [ Q0 ) oe) satisfied. Furthermore, using the induction hypothesis and (A):

16

gen(A; P [ Q0 ) o/ 0) * gen(A:x : oe; P [ Q0 ) o/ 0)

* P ) gen(A:x : oe; Q0 ) o/ 0)
* P ) P ) o/
= P ) o/

Cases (let) and (if) are similar to cases (let!) and (! E). 2
The rules in OLT translate directly into a Prolog program where every application of
a clause is determined uniquely by the outermost constructor of an expression. This
program can be used to find a candidate oe for a principal type scheme of an exprssion
e, together with its proof tree. Given this proof tree, we can check with Theorem 4.2
(b) that the type schemes in the conclusions of all proof steps are nonempty. If they
are, oe is a principal type scheme for e. If one of the types is empty, we can show with
Theorem 4.2 (a) that e has no type. It therefore follows:

Theorem 5.7 (a) If an expression e has a type scheme then it has a principal type
scheme. (b) There is a decision procedure tp which returns the principal type scheme of
an expression if it has one, and returns failure otherwise.

6 Conclusion
We have presented a type system which augments linear types with observers. We claim
that the extension makes linear types practical, since it is polymorphic, accommodates
a familiar programming style, and allows observer accesses to proceed in parallel. Although the typing rules are more complex than those of the classical Hindley/Milner
system, typical type signatures occurring in practice are quite moderate in size and complexity. Furthermore, programmers need not write down types since principal types can
be reconstructed. We see the type system as a possible candidate for future programming
languages which add state to a functional core.

On the theoretical side, more research is needed to explore connections between observer
types and linear logic.

References
[Abr90] S. Abramsky. Computational interpretations of linear logic. Preprint, Imperial

College, London, 1990.

[Bak90] H.G. Baker. Unify and conquer (garbage, updating, aliasing, ...) in functional languages. In Proc. ACM Conf. on LISP and Functional Programming, pages 218-226,
June 1990.

[Blo89] A. Bloss. Update analysis and the efficient implementation of functional aggregates.

In Proc. ACM Conf. on Functional Programming Languages and Computer Architecture, August 1989.

[CDD+85] D. Clement, J. Despeyroux, T. Despeyroux, L. Hascoet, and G. Kahn. Natural

semantics on the computer. Technical Report RR 416, INRIA, June 1985.

17

[Coh84] S. Cohen. Multi-version structures in prolog. In Proc. Conf. on Fifth Generation

Computer Systems, pages 265-274, 1984.

[Deu90] A. Deutsch. On determining lifetime and aliasing of dynamically allocated data in

higher-order functional specifications. In Proc. 17th ACM Symposium on Principles
of Programming Languages, Jan. 1990.

[DP90] M. Draghicescu and S. Puroshothaman. A compositional analysis of evaluation order

and its application. In Proc. ACM Conf. on Lisp and Functional Programming, June
1990.

[GH90] J.C. Guzm'an and P. Hudak. Single-threaded polymorphic lambda calculus. In Proc.

5th IEEE Symp. on Logic in Computer Science, June 1990.

[Gir87] J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1-102, 1987.
[GSH88] K. Gharachorloo, V. Sarkar, and J.L. Hennessy. A simple and efficient approach for

single assignment languages. In Proc. ACM Conf. on Lisp and Functional Programming, 1988.

[Hud87] P. Hudak. A semantic model of reference counting and its abstraction. In S. Abramsky and C. Hankin, editors, Abstract interpretation of declarative languages. Ellis
Horwood Ltd., 1987.

[JG91] P. Jouvelot and D.K. Gifford. Algebraic reconstruction of types and effects. In Proc.

18th ACM Symp. on Principles of Programming Languages, pages 303-310, Jan.
1991.

[Jon91a] Mark P. Jones. Towards a theory of qualified types. Technical Report PRG-TR-6-91,

Oxford University Computing Laboratory, Oxford, UK, 1991.

[Jon91b] Mark P. Jones. Type inference for qualified types. Technical Report PRG-TR-10-91,

Oxford University Computing Laboratory, Oxford, UK, 1991.

[Laf88] Y. Lafont. The linear abstract machine. Theoretical Computer Science, 59:157-180,

1988.

[LG88] J. Lucassen and D.K. Gifford. Polymorphic effect systems. In Proc. 15th ACM Symp.

on Principles of Programming Languages, pages 47-57, Jan. 1988.

[NPD87] A. Neirynk, P. Panangaden, and A. Demers. Computation of aliases and support

sets. In Proc. 14th ACM Symp. on Principles of Programming Languages, pages
274-283, Jan. 1987.

[Ode91] M. Odersky. How to make destructive updates less destructive. In Proc. 18th ACM

Symp. on Principles of Programming Languages, pages 25-36, Jan. 1991.

[Sch85] D.A. Schmidt. Detecting global variables in denotational specifications. ACM Transactions on Programming Languages and Systems, 5(2):299-310, 1985.

[SRI91] V. Swarup, U.S. Reddy, and E. Ireland. Assignments for applictive languages. In

Proc. ACM Conf. on Functional Programming Languages and Computer Architecture, August 1991.

[TJ91] J.-P. Talpin and P. Jouvelot. Type, effect and region reconstruction in polymorphic

functional languages. In Workshop on Static Analysis of Equational, Functional, and
Logic Programs, Bordeaux, Oct. 1991.

[Wad90a] P. Wadler. Comprehending monads. In Proc. ACM Conf. on LISP and Functional

Programming, pages 61-78, June 1990.

[Wad90b] Phil Wadler. Linear types can change the world! In Proc. IFIP TC2 Working

Conference on Programming Concepts and Methods, pages 547-566, April 1990.

[Wad91] P. Wadler. Is there a use for linear logic? In Proc. ACM Symp. on Partial Evaluation

and Semantic-Based Program Manipulation, pages 255-273, June 1991.

18