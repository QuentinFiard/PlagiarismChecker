

Type-driven Defunctionalization
Jeffrey M. Bell & Frangoise Bellegarde*& James Hookt

Pacific Software Research Center
Oregon Graduate Institute of Science & Technology

PO Box 91000
Portland, Oregon 97291-1000

USA
{bell ,belleger ,hook}@cse. ogi. edu

Abstract
In 1972, Reynolds outlined a general method for eliminating functional arguments known as dejunctionalization. Theidea underlying defunctionahzation is encoding a functional

value as first-order data, and then realizing the applicationsof the encoded function via an

apply function. Althoughthis process is simple enough, problems arise when defunctionalization is used in a polymorphic language. In such alanguage, a functional argument of a higher-order function
can take different type instances in different applications.As a consequence, its associated apply function can be untypable in the source language. In the paper we presenta defrmctionalization transformat ion which preserves typability. Moreover, the transformation imposes no restrictionon functional arguments of recursive functions, and it handles functions as results as well as functions encapsulated inconstructors. The key to thk success is the use of type information in the defunctionaliiation transformation. Run-timecharacteristics are preserved by defunctionalization; hence,

there is no performance improvement coming from the trans-formation itself. However closures need not be implemented
to compile the transformed program.

1 Introduction
Defunctionaiization is the transformation of a program thatuses higher-order functions into a semantically equivalent
first-order program. This paper presents defunctionalizationas a source-to-source translation in a Hindley-Milner typable

functional language. Defunctionalization is very closely re-lated to "closure conversion" in functional compilers. We

are motivated to investigate it as a separate transforma-tion because we have developed tools for functional language
compilation that are based on typed source-to-source trarts-formation and that generate typed first-order programs in
conventional languages such as Ada or C. In addition, weapply first-order program transformation techniques to the

defunctionalized representations of programs. The explicit

lCurrently at the Univernit6 de Franche-Cornt6 (F%.nce)tThe authors are supported by a contract with Air Force Material
Command (F19628-93-C-O069).
Permission to make digital/hard copy of part nr all this work for
personal or classroom use is granted without fee provided that
copies are not made or distributed for profil or commercial advantage, the copyright notice, the title of the publication and its date
appear, and notice is given that copying is by permission of ACM,
Inc. To copy otherwise, to republish, to posI on servers, or to
redistribute to lists, requires prior specific permission and/or a fee.
ICFP '97 Amsterdam, ND
@ 1997 ACM 0-69791 -918 -1/97 /0006,.. $3.50

fun map F y = case y of

Nil a NilI Cons(x, XS) * Cons(F z, map F XS)

fun addone 1 = map incr 1fun subone 1 = map deer 1

Figure 1: Example higher-order program
fun apply-map enwding arg =case encoding of

"incr" ~ incr argI "deer" + deer w-g
fun map' F y = case y ofNil ~ Nil

I Cons(x, XS) * Cons(apply-map F r, map' F XS)fun addone 1 = map' "incr" 1
fun subone 1 = map' "deer" 1

Figure 2: Defunctionalized progmn
study of typed defunctionalization illuminates issues relatedto type specialization. The algorithm presented performs
necessary type specialization but does not generate a strictlymonomorphic representation.

Reynolds outlined a general method for defunctionaliza-tion [Rey72]. The idea underlying defunctionalization is encoding functional values as fist-order data. Since a first-order value cannot be applied as a function, applications of
the encoded functional need to be modified, by introducinga call to an apply function. The apply function is called

wherever the functional argument was applied in the origi-nal higher-order function. The apply function takes as arguments the encoded functional and all the arguments to thefunctional. The apply function dispatches based on the encoding, and applies the appropriate function to the remain-ing arguments. For example, if the program in Figure 1 is

defunctionalized using strings containing the function nameas the representation of function values, the program in Figure 2 is the result.Reynolds' method defunctionalizes functions that have

25

fun W@y,nt ~ ,.t encoding UTg =case encoding of

"incr" * incr m-g
fun aPPIY~tring~,nt encoding arg =case encoding of

"str2int" * str2int argfun rnapint+int F y = case y of
Nil ~ Nil
I Cons(z, XS) = Cons( apply-map,n~+,~t F X,mapini+int F XS)

fun `aP3tri.g+int Fy= caseyofNil ~ Nil

1 Cons(z, ZS) * Cons(app~y-map,,ra~,+~~~ F Z,map~,,ing+in, F XS)
fun addone 1 = mapint+%mt "incr" 1fun subone 1 =

map,t,ing+imt "str2int" 1

Figure 3: Defunctionalized example with specialization
functional arguments, but not functions that return func-tions. Chin and Darlington address this in their
A-algorithm [CD96], which removes some functional resultsby q-expansion. Our transformation includes the capabilities of the A-algorithm.Problems arise when defunctionalization is used in a polymorphic language [Be194, BH94a]. In the above example,map is called twice, each time passing a function of type
id -) int. Suppose that the second call to map used afunction with a different type, e.g. str2irat : string + int.

Then the apply_map function would be:

fun apply-map enwding arg =case encoding of

"incr" + incr argI "str2int" * str2int arg

This function is ill typed in a Hindley-Milner language(although the resulting program will have no "wrong" behaviors if the original program was type correct). Our so-lution is to specialize apply functions by the type of the
functional whose encodings are interpreted in the applyfunction. Under this scheme, there would be one version
of apply-map that applies int + int functions, and anotherversion that applies string +

int functions. Since the applyfunctions are specialized by type, so must be the higherorder functions that rely on the various apply functions.Again, this specialization is according to the type of the
encoded functions. A type-correct defunctionalized versionof the modified example is given in Figure 3.

Another complication encountered by the defunctional-ization algorithm is illustrated in Figure 4, showing an implementation of the sum function using continuation-passing
style. Here, sum is called with a series of different functionvalues for the argument F. This requires an encoding for F

that accounts for all possible values of F, which is accom-plished by encoding

F in a recursive datatype, as describedin Section 2.5.

Our desire for a defunctionalization algorithm was moti-vated by work on software component generators that perform type-faithful translations of higher-order functional profun sum F y = case y ofNil~FO

I Cons(z, zs) * sum (An.z + F n) xs

I

Figure 4: Higher-order function in CPS

Terms t,M, e(terms are underlined in

transformation rules)Variables v, w, x, y,z, F,G, H
Function symbols ~, g, hType variables

~,~,~Type terms I-f,@, f-l,Q

Data constructors C labelled with the type and theterm it encodes

Type constructors T labelled with the type it encodesas an index

Table 2: Naming conventions
grams to first-order imperative languages (e.g. Ada) [B+94,KBB+94]. Although specialization-based techniques for defunctionalization exist [CD96], they fail on examples suchas Figure 4 where an infinite family of specializations would
be generated. In addition, they do not defunctionalize func-tions in data constructors (e.g. lists of functions).

Our type-driven transformation is presented as a set oftransformation rules. Two rules decrease higher-orderness
and three rules lessen polymorphism. The rules make clearthe amount of monomorphization which is necess=y for defunctionalization.The remainder of the paper is organized as follows. Section 2 describes how the type-driven defunctionalization trans-formation is applied to higher-order programs. Section 3
summarizes the results related to soundness, terminat ion,and effectiveness of the transformation (full proofs are given
in a tethnical report [BBH96] ). Section 4 presents our con-clusions and future work. The appendices include several
illustrative examples.

2 The transformation
The defunctionalization transformation applies to a restrictedform of a higher-order polymorphic strongly-typed functional
language. A grammar for the language is presented in Ta-ble 1. This is a simple polymorphic language without local
let or lambda bindings. Only function symbols, functionvariables, and constructors can appear in function application position. A program consists of datatype declarationsfollowed by function declarations followed by a (top-level)
term. This language form can be calculated from, say, acore ML program by the standard lambda-lifting transformation [Joh85]. These restrictions simplify the exposition;the language can be extended without fundamental changes.
The naming conventions used in this and following Sectionsare given in Table 2.

26

Datatypes: ddecl ::= datatype crl...a~ T = cdecscdecs ::= cdec 1 cdec I cdecs

cdec ::= Ctypel . ..typen (n ~ O)
Functions: jdecl ::= fun fvl. ..vn =tenn
Terms: term ::= raterI rater terml . . . termn

1 case term of patl => term] I . . .
TatO?- ::= flvlc
pat ::= Cvl. ..vn (n ~ O)

Types: type ::= a I typel +typez I Ttypel. ..type~

Program: program ::=ddecl" fdecl' term

pat. => term.

Table 1: Thegrammar of thepolymorphic higher-order language
2.1 Functional type specialization and arrow type param-eter encoding
The transformation relies on analyses of types. The basicidea is to replace arrow type arguments by appropriate elements of a datatype. A datatype Tn captures the arrow typearguments of the arrow type II where each arrow type argument of type II is encoded by a constructor in the datatypeTn. Consider the following example of a term: map id [1,2]
where map is declared as in Figure 1. The type of map is:

map : (a d /3) -+ list a -+ list ~
It is a higher-order function since it has an arrow type ar-gument. The type of id is a + cr. But in the context

of the application map id [1, 2], id is instantiated at type

int+ int. Therefore, this occurrence of id can be encodedby a constructor Cj~t+inf in a datatype

Tint+ int which iscreated to contain the encodings of arrow type arguments

of type int * int. So doing, the type of map has to be-come Tint+in~ + list int + list int. However, in another
application, the type of map could be instantiated other-wise. The solution is to create as many different versions,
called clones, of the higher-order function as needed. Thetransformation requires a different clone of the higher-order
function for each type at which the higher-order functionis applied in all of its applications. Cloning is necesszmy

because each clone of the higher-order function will use aspecialized encoding of function values.

When creating and manipulating clones, it is necessary
to keep track of which expressions are in the encoded repre-sentation and which are not. This information is indicated

with braces. Specifically, braces subscripted by a type (on)are placed around encoded fragments that are used in their
original context. In the dual case we write braces with aainverse ((.) -]). The definition is given in Figure 6.

The creation of a clone of a higher-order function is nota simple task. An arrow type parameter in the higher-order
function becomes a O-order type parameter in its clones, soit can no longer be applied as a function. The tirst step is
to create a clone in which the arrow type argument is stilla function but of a specialized type. For example, the clone
of map as presented in Figure 5 is of type:

~ = (int * int) ~ list int + list int.

fun map~ F y = case y ofNil * Nil

I CO~S(Z,ZS) + Cons( (F')int+int X,

map (F)int+int ZS)

Figure 5: Higher-order clone of map of type V
(t)n = the unencoded value oft
((v), )-' = v
(f t,...tn=-'= f (tl)-1 . ..(%)-'
(c t,... tnl-l = c (tl)-l... (tnl-l
(Vt,.. .tn)-l =V (tl)-l... (tnl-l
(case tofpl=>tll . . . I p. => t")-' =

case (t)-lof pl => (tl)-l I . . . I pn => (tn)-l
I

Figure 6: Definitions for semantic functions

A clone of ~ at a specialized type IT is given the functionsymbol ~11.It is created by taking a copy of the declaration
of ~ in which arrow type variables are replaced with an ap-plication of the function (.) n to the arrow type variable, as
shown in Figure 5. Note that at this point the recursive callto

map is not encoded. This will be addressed when thisfunction call is defunctionalized.

The next step is to encode arrow type arguments indatatypes. Then, in the body of the clone, an application of
(F)II must be transformed into an application of an applyfunction. In the body of mapw, the application

(F)ini+int z
is transformed mto applyint+,nt F x as shown in Figure 7.

The apply function depends on the datatype. It establishesa correspondence between the encoding and the encoded

terms. For the example, the transformation adds the decla-ration of an applyint+int function shown in Figure 8.

27

fun map~ F y = case y ofNil + Nil

\ CCHM(Z,ZS) + Cons( applyint+,nt F X,

map (F')i~t+,~tn)

Figure 7: Clone of map where F is seen as encoded

datatype !f'i.~+an~ = C~~t+intfun applyin,+int f x = caae f of

C~~,+,., * (id z)

Figure 8: Encoding-derived declarations

2.3 Higher-order recursive functions
In a clone, types can be deduced from the original terms,from the type label of the clone function symbol, and from

the type annotations on applications of on. For example,in the body of the mapy clone of map, the specialized type
of map in the recursive application: map (F')int+int zs isrecognized as the type w because of the subscript int + int.

Since we suppose Hindley-Milner typability of the orig-inal program, recursive calls in a set of mutually-recursive
declarations are of a consistent inferred type. Therefore,in a set of mutually-recursive specialized clones, the types
of recursive calls are of consistent specialized types. Thisserves the useful purpose of allowing the specialization rule

(Fum$pec) to fold the specialized recursive call artywhere itoccurs in the set of mutually-recursive clone declarations
without the need for further analysis. In our example, the
rule (FunSpec) can be used again to change the occurrenceof map (see Figure 7) into mapv in the body of the declaration of the clone mapW, and change (F)int+int into F via theapplication of (.) - 1. No more rules apply; the result of the
transformation is the first-order program composed of theterm map~ C~~t+imt [1,2] and the d&larations in Figure 8
and below:.2.2 Transformation rules

The transformation informally described in the previous sec-tion is guided by a set of transformation rules. A rule transforms an expression of type order O, which we call jully -apphed, in the context of a program P. It also updates the
set A of function symbol declarations of P and the set E)of datatype declarations of P, so that a transformation rule
transforms a triple (term, A, ~) into a new triple. Thethree rules (FunSpec), (EncodeClosed), (ApplyVar) shown
in Figures 9, 10 and 11, allow us to defunctionalize the fully-applied application map id

[1,2]. Definitions oft he functionsorder and functional used in these rules can be found in Figure 14.The rules reference type information calculated by type
inference on the original, untransformed terms. As the trans-formation progresses, this information is propagated unchanged. Since the transformation proceeds nondet ermin-istically through untyped intermediate representations, it is
important to note that sometimes the type does not applyto the term being manipulated, but the input term of which
it is a residual.The rule (FunSpec) specializes a fully-applied higherorder application of a function symbol according to the typeof its arrow type arguments. For instance, it transforms

map id [1, 2] into mapw id [1, 2] and adds the clone mapwfrom Figure 5 to the function declaration set A. The rule

(Encode Closed) encodes arrow type arguments into construc-tors of datatypes. For example,i~t transforms the expression mapW id [1, 2] into mapw Cint+int [1, 2] and adds theencoding-derived declarations in Figure 8 to the declaration
set A. Next, in the body of the declaration, the applica-tion (F')i.t+i.f z is transformed into applyw F z by the
rule (Appl Var). In the clone mapw there remains a fully-applied higher-order application of map which comes from

the original recursive application of map. No more transfor-mation rules are needed to cope with recursive calls in a set
of mutually recursive clone declarations, as explained in thefollowing section.

fun mapq F y = case y ofNil * Nil

I COTM(Z,ZS) * Cons(applyint+int F X, mapw F XS)

An example of mutually-recursive functions is presented inAppendix B.3.

2.4 Polymorphic higher-order application
Cloning a polymorphic function is not = simple when it isspecialized in such a way that it becomes a function that

returns a function. In such a case, a polymorphic functionsymbol ~ with arity a may be applied to a number of arguments n where n > a. For example, although id is ofarity 1, in id id (id 7) the first occurrence of id has two arguments. In this case, the specialized clone of the functiondefinition must not be simply a copy, but an q-extension
annotated with the types of the functional arguments. Thefunction id in the expression id id (id 7) is instantiated at
two types: the first-order type int + int and the second-order type @ =

(int+ int) -+ (int -+ int). In addition, thesecond id appears as a parameter to a higher-order function

and the third as a first-order function. The defunct ionaliza-tion must distinguish on both order and these distinct roles.
Since the outermost application has a functional argumentid, an q-extended clone fun ids. z y =

(~)int+int Y is pr~duced, along with a transformation of the application into:

;& id (id 7). This is accomplished by the rule (EzpandSpec)
shown in Figure 12.(EzpandSpec) expands the body M of the function it specializes with fresh variables so that it becomes fully-applied.This works fine if M is a function symbol or a variable, but

M can also be a case expression (see the grammar in Ta-ble 1). In this case, normalize uses the rewrite rule shown in
Figure 13, as much as needed, to push the variables insidecase arms so that case expressions do not occur as operators
in function applications,Both rules (FunSpec) and (ExpandSpec) help to decrease
the occurrences of polymorphic applications since the func-tional polymorphic arguments of fully-applied applications

28

IF

3 j, j ~ 1... n, functional(~j)
A all junctional variablesin fictional arguments are argumentsof (,)w for some WA n = order(rf) A order(fl) = OA ~ is a function symbol

AND r+ta : Ifi, Vi, iE1. ..n,

rt-fh ...k : Q,rt-f:n,

aI'I=rIl+. ..+ IIn+Q
THEN ft, . . . tn, A, f3=+ fen (t])-l . (tn)-l, A',@

WHERE

{

Au {jcn Z1 .xn = M[ral i- (Z,, )ni, . ..X.k + (Wk)nlk]}
A' = whereA(~)=~zl . ..z~=Mandij. j~ l.. .k,

are the indices of the fictional arguments

Figure 9: (AmSpec) Functional type specialization transformation rule

IF

3j, jE1. ..n A order(IIj)>OA tjisa closed term
A F is a function symbol or a function variable A order(f2) = O

AND rt-t; : II;,

Vi, iE1. ..n,rl-Ftl... tn:Q

THEN

Ftl ... i!j. ..tn, A,@~Ftl . C;, . ..tn. A',@'

WHERE

{

if ApplyHj has not been declared in A thenA

U {/@~YHj ~ !/1 ~ ?40rderf~, J =

A' = tcase z Of CnJj - tj VI . . . Yorder[n, ~} else

tadd to it the cose arm 6'n]j * tj Y1 . . yorde~f~j )

{

if TIIj has not been declared in @
9' = then @ u {datatype TII, = C~, }t

eke add to it the constructor C=;j

Figure 10: (EncodeClosed) Closed arrow type parameter encoding transformation rule

[F

order(fl) = OA F is a variable

4ND rFFtl... tn:Q

THEN (F)ntl . t., A, OsApplyn Ftl ,.. tn, A,E)

Figure 11: (ApplVar) Higher-order variable application

IF

32, 2 E 1...n, functional(m)
A all junctional variables in junctional arguments are arguments of (,)w for some W
A n > order(n) A order(~) = OA j is a function symbol

AND r+t~ : IIi, Vi,2E1. ..n,

r+ ftl. ..tn:~,
r+j:n,CT1-l=l-fl +.. .+ IIn+fl

THEN tt, . tn,A,@=~~II (t,)-' . . . (tn)-', A',@

WHERE

A' =

AU {frn xl xorder{n] U . . . Vp =
normalize(kfvl . Vp)[Zi~ 4- (Zi~ )11,1 . . . . Xi~ + (Zi~ )IIik ,
VI, + (V{l)rrtl ,. ... % + (Vmhlml

where A(f) = f zl . Xordertn) = M,

Zj,j= l...k,~dlj,j~ l.. .narethe indicesofthe functional arguments, p = n - order(II) + 1.

Figure 12: (ExpandSpec) Functional q-extension and specialization
(case t of pI => tI II . . IIpn => tn) t'+
case t ofpl => tl t' It ... IIpn => tn t'

Figure 13: Rewrite rule for case expression normalization

. order : type + int = At. case t of@*o

I a -)(? + 1 + order(~)lTII,...IIna O

l functional: type + bool =At.caae t of

a * }akelcr+~+true

IT HI... L * functaorsal(II~ )V... Vfunctional(lIn)

v3aconstructor c: I'lx. ..x~'~ +T Ill . .lI~ such that
finctiOnal(I'l ) v... v functional(r~)

Figure 14: Difference between order and functional
become monomorphic. The higher-orderness of programs isaddressed by the rules (Encode Closed) and (Appl Var).

In the above, example, the result of the transformation isthe term i~ CJ~t+:nt (id 7), with the declarations:

datatype Z'i.~+in~ = C~~~+intfun id x = 2;
fun aPPiYi.t+int x Y = c-e $ ofC~~,+l.f a (id y)
fun Z& X y = aPPIY;nt+;nt x Y

This example can be extended to require the encodingat an arbitrarily high order. Thus a defunctionalization
based on function declarations instead of function applica-tions cannot work. It is also clear from this example that
the algorithm must be sensitive to the set of monomorphictypes at which every function symbol in the program occurs.
It is necessary to start with an expression with a monomor-phic type and recursively perform type specialization on all
function symbols occurring in the monomorphic expression.The transformation rules require fully-applied applications, thereby intertwining the monomorphization of thehigher-order components and their encoding counterparts

during the transformation. Consider for example the appli-cation

id (id id) (id 7). Only the higher-order argument ofthe application differs from the example above; it is (id id)

which is itself a higher-order application. However in thiscontext it is a higher-order zugument and as such, it has to

be encoded by a constructor C~~~~t. Proceeding as above,we get first:

datatype Ti.f+i.i = C~~~~~~,fun applyint+int x y = case x of

C~~~/nt * id id yfun ida z y = applyine+,.t r y

with the term i~ C~~~~i~t (id 7). The application id idis fully-applied as

id id y in the body of the generatedappiy:nt+int function. Because the rules work solely from

fully-applied applications, it is only at this point that thedefunctionalization of id id y is done. This provides the
first-order program composed of the term i~ C$~~~~~,(id 7)with the declarations below:

30

Notice that polymorphism can induce functional argu-ments that are syntactically equal but are not of the same
type, as in the application id id id 7. The two argumentsid of types W = (znt + int) + (int -)

int)and int + int
are encoded by two different constructors: C~d and C/~t~intsince the constructor symbols are built on both the type and

the term they encode. The interested reader can find morerealistic examples in Appendix B.

2.5 Encoding nonclosed arrow type arguments
Closed arrow type arguments are always encodable into con-stant constructors, but arrow type arguments may contain

variables. The transformation must be able to encode bothkinds of arrow type arguments of fully-applied functional
applications.Arrow type argument expressions may contain arrow type
variables as well as first-order variables. For example an ar-gument could be t = ((Z)n (( F)int+(int+lnL) z)), where Q
is the type (int + int) -+ int + irzt. As above, such anarrow type argument must be encoded in a datatype that
corresponds to its type. This can be done by encoding theargument as a function constructor rather than as a firstorder constructor.First-order variables are not encoded by the transformation. The types of the values of the first-order variables thusremain variable types ancl parametric datatypes are generated to encode arrow type terms which contain first-ordervariables. Thus we are doing as much monomorphization as
needed, and no more.Since functional variable values are encoded, their types
are those of the encoding datatypes. In the above example,since

t contains a first-order variable, the functional argu-ment

tof type int + int must be encoded in a parametricdatatype a !f'in~+i.t by a constructor C~nf+in~ of type

(Tn X T~*t+(i.~+i.~) X Cl) ~ (int -+ int).
By encoding functional variable values, the datatypes thataxe created for the encodings can be recursive (See Section B. 1 for an example of such a recursive datat ype). Therule (Encode) given in Appendix A subsumes the rule (Encode Closed) given in Figure 10.

2.6 Higher-order constructors
A special case of higher-order application is higher-orderconstructor application.

A higher-order constructor can be an instance of a poly-morphic constructor. For example the list constructor Cons
haa the type (ini! + int) x ht(ant+ int) + Iist(int + int)in the application CoraS(Zrt,(~s)li~t(jnt+int) ). The functional
argument id of type int + int has to be encoded into aconstructor C~~t~ iflt as for an application of a higher-order
function. The rule (Encode) in Appendix A allows encodingsof functional arguments of higher-order functions as well aa
functional arguments of constructors.

By matching the type II of a term tagainst the datatypeof the patterns in a case expression, we know the functional
types of function variables in a pattern. These types areused to apply on to functional variables in the arm bodies.
This is accomplished by the rule (UpdateAnns) of Figure 15.For example:

case (Z)iistint+.int ofCons(xl, m) * (z1
*

case z of

Y)

Cons(zl, X2) * (( Zl)int~int Y)
This is accomplished by matching the functional typelist(int + int) of x against the parametric type list a with
the substitution u = {a + (irzt + int)}. The domain ofthe data constructor Cons is then specialized into (int +
int) x list(int + int), allowing the rule (UpdateArms) to ap-ply (.),. t+i.t to the arrow type variable xl. The interested
reader can consider example B.2.Notice that the type Iist(int + int) is considered as
functional (see Figure 14) though it is of type order O. Onlyterm arguments of type order greater than Oneed to be encoded but any term of a functional type may be an argumentof a polymorphic function which, in this case, has to be type
specialized.There is a minor complication when a datatype declares
a functional constructor explicitly, like the constructor Storein the declaration: datatype (a, ~) store = Store a ~ /?.
Unlike a function symbol, a constructor cannot have clonesin datatypes corresponding to different type instances of a
and ~. A way around this is to generalize such a datatype.Generalization is safe for type inference. Moreover since
the programs are type correct, it is useless to typecheck thearrow. By the rule (GeneralizeArrows) of Figure 16 the
datatype store becomes datatype o store = Store a sothat encoding of differently typed functional arguments in
different applications of the constructor Store is possible.Finally, notice that rules (FunSpec) and (ExpandSpec)
introduce applications of (.) v to functional terms. These ap-plications are ultimately removed when the functional term
is applied (in (Appl Var)), when the term is examined (in

(UpdateArms)), or by applying (.)-' (in (FunSpec) and (Ex-pandSpec)). However, applications of (.) w are not removed

when an (unapplied) functional term is used as an argumentto a higher-order constructor, as in Cons( (j) w, Nil). For
this, we use the rule (UpdateCon), as shown in Figure 17.

2.7 The use of types
In summary, types are used by the defunctionalization algo-rithm

l

l
l

to replace arrow type arguments of higher-order fnnc-tion applications by appropriate elements of a datatype
by creating a datatype Tn for functional arguments oftype If,

to create clones of polymorphic higher-order functionsspecialized by the types of their functional arguments;
the clone names are simply labelled by their types,
to recover the appropriate clone name in a recursivecall that occurs in (mutually) recursive clones of higherorder function declarations,

31

[F

functiOnal(T@l O,)

A all functional variables in t are arguments of (}w for some W

AND r~ t: T@l. ..@k

I'HEN case t of case (t)-l of

Clzll .Zlml a tl Clzl, . . .Zlml * t;

,A, @= ,A,9

Cnxn, . Xnmn +- t., Cnxn, . . . Xnmn +- ti
WHERE T is declared datatype al . . . a& T =

n

vi, iE 1... n, t:= ti[~;jlt (Zi,l)w]l,...,Zi,p )1+ (Gjp Wjp

ci appears as C;*1 ~~, in the instantiated Sumtype nICYI+ @I,..., ak + @k]jl, 1 E 1 . . .p are the indices of functional pattern variables.

Figure 15: (UpdateArms) rule for updating case arm variables
l to recognize the dat atype in which is encoded the valueof a functional variable so that its application can be

replaced by an application of an apply function,
l to know when a clone must be an q-extended copy of

the original polymorphic declaration, and

l to discriminate arrow type arguments of constructors

in different arms of a case expression by analyzing thetype of the matched expression.

The encoding of arrow type arguments into datatypes, to-gether with a type analysis originated by fully-applied applications, accommodates the transformation of higher-orderprograms into a first-order equivalent program.

3 Study of the transformation
A transformation rule transforms a program which containsan expression g in the context P denoted by P[eJ. In the
previous section, a transformation rule has been written inthe following abbreviated form:

ifCond g, A, @ = ~, A', @
Suppose that a function< extracts the set A of the functiondeclarations from the program and that a function O extracts the set e of type declarations from the program. Asusual, the notation iM[N' /N] denotes that the occurrence(s)
of the subterm N are replaced by the subterm N' in M. Atransformation rule on a program P[d could be expressed

as:

ifcona' PM * PH[A'/((P[4), Q'/O(P[e])]
Given a program, the defunctionalization algorithm ap-plies the seven rules {FunSpec, ExpandSpec, Encode, Appl Var, UpdateArms, GenemlizeArraws, Update Con) in anyorder untiI none of them is applicable. It relies upon the

original types of the terms and synthesized types for terms

introduced by the algorithm. The types of introduced termsare determined as follows, The type of (.)11 is II. The type
of au apply function is the type of the functional encodingterm `1; that is, applyw : T* + ~. The type of an encoded term is the datatype T*. Finally, the type of a clonefunction symbol fw is Q.

3.1 Theorems
Below are theorems addressing the iesues of soundness, ter-mination, and effectiveness of the transformation. Proofs of

these theorems can be found in an extended version of thispaper [BBH96].

Theorem 1 If a program is well typed according to the HindleyMilner algorithm, then the transformation results in a welltyped program equirraient to the original program.
Theorem 2 The transformation always terminates.
Theorem 3 The transformation of a closed program resultsin a first-order program.

4 Conclusion and future work
The defunctionalization transformation presented in this paper is a complete algorithm for transforming a closed higher-order well-t yped functional program, comprising an expression e together with its declarations, into an equivalent first-order program. As far as we know, a complete algorithm
such = this has not been presented before. The methodthat replaces functional applications by macros [Wad88] is
elegant but macros cannot be recursive. Although recursioncan be recovered by way of recursive local functions, the
macro method supports only functional quments whichremain identical in recursive calls. The method that specializes functional applications with respect to the values ofarrow type arguments is limited to so called uariabie-ordy

32

IF

3j, jE1. ..n, Aorder(@j)>0
A all variables of i!j are argumentsof (}w for some V

THEN

WHERE

Ci?I . ..tn. A,@u{~l . ..~m TIC@lx Cx@jx.. x@jx... x@nl...}-
CtI . ..t~. A,@u{B, . ../3~l( 7@IX(Xfl X... Xf}X... X%l...}

crl. ..cr~are thetype variablesin {.. .lC@IX@ jXXX@nl. .X@nl . ..}@l...,& arethetype variables inlC@lx C@lx . ..x~x... x@~}...}
~ is a fresh type variable

Figure 16: (GeneralizeArrows) Arrow constructor generalization
IF

3 j, j E 1... n, fUflC~i071Ul(l_Ij)

A all ~unctional variables in junctional argumentsare arguments of (.)w for some WA C is a constructor

AND rl-t; : II,, VZ, iE1. ..n,
rHEN Ct, . tn, A,@+C (tI)-' . (tJ-l, A,EI

Figure 17: (UpdateCon) Removes applications of (.)* from higher-order constructor arguments
arrow type arguments [CD961. None of these methods con-sider th-e-case`of higher~order"constructor applications.

Our transformation is based on Reynolds'smethod [Rey72] of encoding functional arguments. Our main
contribution is to bring together this idea and the idea ofusing functional application types to drive the defunctionalization transformation. This is crucial for handling polymor-phic higher-order functions as has been noted by Chin and
Darlington in their A-algorithm [CD96], which is used to re-move some functional results by eta-expansion. Our transformation includes the functionality of the d-algorithm.While it always produces a first-order program, this transformation has little effect on execution efficiency since thereduction steps of the first-order program are similar to the
reduction steps of the original higher-order program. Thereis some performance penalty imposed by the execution of

appiy functions to evaluate encoded values. In contrast,Chin and Darlington's `R algorithm [CD96] relies on specialization with respect to the values of functional argumentsand returns, when it is applicable, an improved first-order
program.The ideal solution is to add to our set of rules a transformation rule to specialize variable-only arrow type argu-ments with respect to their value to get the best of both

worlds. For example, the first argument of map in the in-troductory example in Section 2 is variable-only, as is the
first argument of wap in the example in Section B. 1. There-fore in applications of

map or mp, the functions map andmp can be specialized with respect to the value of their actual functional parameters rather than encoding them andconsequently creating an apply function that corresponds to
this encoding. At a functional application of j, variableonly functional arguments lead to a clone of f specializedwith respect to their valuea. In a combined transformation,
the values of the uarialde-only parameters of the applica-tion would be substituted in the clone body where= other
functional arguments would lead to a clone of ~ specializedwith respect to their types, their values being encoded into

a constructor term of a datatype. In the combined transfor-mation, since a clone is tied to its source application type,
the folding of a recursive clone application either comingfrom type specialization or from value specialization is always recognizable by its type. So, the type annotations andthe variable-only analysis of the version body together enable the algorithm to fold the recursive calls in recursive aswell as in mutually-recursive versions. We suggest performing the variable- only analysis beforehand and to carry ona variable-only annotation to the functional arguments of
functional versions. The result of applying such a combinedtransformation can be seen in the example in Section B. 1.

Note that the defunctionalization transformation per-forms a monomorphization of functions with respect to their
functional arguments and functional results. Full monomor-phization of the program can be obtained by specializing also
first order function symbol with respect to the type of theirapplications and annotating first-order variables as well as
functional variables. A similar treatment of defunctional-ization that relies upon a monorphic program as input, and
thus does not perform specialization of polymorphic func-tions, has been developed by Tolmach [T0197].

The defunctionalization transformation, we present inthis paper, is a step in a pipe-line of transformations designed to automatically derive a program generator [B+94,KBB+94] from the semantics of a domain-specific design lan33

guage. The purpose of the transformation is to obtain sat-isfactory performance and to tailor the implementation to a
specific platform and software environment. Defunctional-ization accommodates software environments which penalize

or prohibit functional. It is also used to translate func-tional programs into term-rewriting systems in the transformation system Astre [Be195b, Be195a] which uses term-rewriting techniques to perform algebraic manipulation on

functional programs.

References

[B+94]

[BBH96]

[Be194]

[Be195a]
[Be195b]

[BH94a]

[BH94b]
[CD96]
[Joh85]

[KBB+94]

J. Bell et al. Software Design for Reliability andReuse: A proof-of-concept demonstration. In

TRI-Ada '94 Proceedings, pages 396-404. ACM,November 1994.

Jeffrey M. Bell, Frangoise Bellegarde, and JamesHook. Type-driven defunctionalization. Technical Report CSE-96-009, Oregon Graduate Insti-tute, 1996.

J. M. Bell. An Implementation of Reynold'sDefunctionafization Method for a Modern Functional Language. Master's thesis, Departmentof Computer Science and Engineering, Oregon
Graduate Institute, January 1994.
F. Bellegarde. Astre: Towards a fully automatedprogram transformation system. In Proceedings

of the sizth conference on Rewriting Techniquesand Applications, volume 914 of LNCS. SpringerVerlag, 1995.
F. Bellegarde. Automatic Synthesis by Comple-tion. In Journ.4es Ihancophones SW- les Langages

Applicatifs, INRIA, collection didactiques, 1995.
Jeffrey M. Bell and James Hook. Defunctional-ization of typed programs. Technical Report 94-

025, Department of Computer Science and En-gineering, Oregon Graduate Institute, February

1994.
Fraqoise Bellegarde and James Hook. Substitu-tion: A formal methods case study using monads

and transformations. Science of Computer Pro-gramming, 23(2-3):287-311, 1994.

Wei-Ngan Chin and John Darlington. A higherorder removal method. Lisp and Symbolic Computation, 9(4):287-322, 1996.
Thomas Johnsson. Lambda lifting: transform-ing programs to recursive equations. In JP. Jouannaud, editor, Functional ProgrammingLanguages and Computer Architecture, volume

201 of LNCS, pages 190-203. Springer-Verlag,1985.

R]chard B. Kieburtz, Frangoise Bellegarde, JefBell, James Hook, Jeffrey Lewis, Dino Oliva,
Tim Sheard, Lisa Walton, and Tong Zhou. Cal-culating software generators from solution specifications. Technicaf Report 0GI-CSE-94-032B,Department of Computer Science and Engineering, Oregon Graduate Institute, October 1994.

[Rey72]
[To197]

[Wad88]

John C. Reynolds. Definitional interpreters forhigher-order programming languages. In ACM

National Conference, pages 717-740. ACM,1972.

Andrew Tolmach. Combining closure conversion
with closure analysis using algebraic types. In~pes in Compilation Workshop, June 1997.

P. Wadler. Deforestation: Transforming Pro-grams to eliminate trees. In Proceedings of the

second European Symposium on ProgrammingESOP '88, volume 300 of LNCS. Springer-Verlag,

1988.

34

A (Encode) rule for encoding functional arguments

:F 3 j, j G 1... n, t,is not a variable A o~de~(IIj) >0

A all ~unctionai variables in tj are arguments of (}W for some W

A ~ is a function symbol, a function variable, or a data constructor
A order(Q) = O

kND vz,z~l,..~,r~ti : n,,

ri-Ftl.. .,tn : Q
w . vk am the variables in tj

L'HEN Ftl . ..tj. ..tn. A,@~Ftl . ..(C~j V1 ,., vk). ..tn,,@, @'

iVHERE

{

ij Applynj has not been declared in A thenA

U {Applvnj Y ~1 `order(nj ) =

A' = tC&Sf! y OfC~j V1 .Vk * ~J ~1 . . ~order(~j)}

teke add to it the arm Cnjj VI . ?)k + tj XI . . . `order(nj J

~{

if Tnj has not been declared in @ then
@U{datatypeal... a~ Tnj =C~j *1 x... x*~}

e' =

{

if vi is annotated by V
v2,2E1... k,@t= then IIwhere eke /? where ~

is a fresh type variable

crl . . am are the type variables in @l . @k

eke add to it the constructor C~j @l x . x @k

B Examples
B.1 Second-order argument:
This example is inspired from [BH94b].

Program:fun mpZFx=casezof

Nil q NilI Cons(z, ZS) s Cons(F z, mp Z (Z F) ZS)
fundb Fx=F(Fz)funincx=z+l

Term:mp db inc [2,3,4] of type: list int
Is transformed to
Program:
datatype Tint+iflt = C~~~+,n, , ~::k:jnt T(int+int)+(int+ int) x ~int--t:nt
datatype T(in~+int)+(int+ irlL)-- cfint+int)+(tnt-t* nt)

fun mp&ZFz=caaexof

Ifun

Ifun

Nil'~ Nil

Cons(x, zs) a Cons(upplyTi.,+ln, F X, mp~ Z (@~fl~nt (-Z, F)) XS)
apdYTi~t+i,tt Fx=case Fof

35

~db(,nt+ant)+(,nt+tnt) ~ db~ F z
fundb~ FX=applyT,n, +,n, F(app[y7 ,," +,nt F Z)funincz=x+l

Where@ = ((int + int) + irli?+ int) + (int +

int)+ listZ'nt+ listh!
v = (id + id) + int+ int

If combined with specialization with respect to the value of the variable-only fist argument of mp, as described in Sec-tion 4, this program becomes:

datat ype Tint+int = c~%+i.t `b `) Txnt+,ntI d?-?,fun mpe F x = case x of

Nil ~ Nil

`db `) (db, F)) ZS)I cons(z, ZS) * C0n5(app~y7,~t+i=t F x, mpa (Cin,+:n,fun apply7im,+i~t Fz=case Fof

C~~~+,.t * inc x
I (Cfj~~, G)* (db~ G z)fun db~ f z = a@yTim,+in, F (applyTin,+,m, F z)

funincz=z+l

Where:@ = ((int +

ire!)+ int + int) + (int + int) + list int -+ list int

8.2 List of functions:
This example is borrowed from [CD96].

Program:fun maph Fs y = case Fs of

Nil + NilI

Cons(F, Fs) - Cons(F y, maph Fs y)fun add5 y = case y of

Nil a Nil
I Cons(z, ZS) + Cons(k z, add5 ZS)
funkx.z=z +5*x

Term:maph (add5 ZS) y of type: list

int

Is transformed to
Program:
datatype a Tint+int - ,n,+in, afun map&, Fs y - ~~%(~)of--

Nil ~ Nil
I Cons(F, Fs) * Cons(app/yTin,+i., F y, maph@ Fs y)
fun add5 y = case y of

Nil a Nil

I Cons(z, ZS) + Cons(C\~,~in, z, add5 ZS)fun appiy~. Fy=case Fof

c~;t$;t-~; k ~ y
funkzz=z +5*x

Term:

36

7nuph.#,(aw Zs) ~
Where:@ =

li9t (int + int) + int list -+ list int.

B.3 Mutually recursive functions:
Program:datatype a dec = Dec a x exp a

datatype CYezp = Vm a \ App ezp a x ezp a \ Let dec a x ezp afun fold-dec D V A L x = case x of

Dec(v)z) + D v (Jold-ezp D V A L z)fun fold-exp D V A L x = case x of

V4rv* VUlApp (y, z) + A (fold-ezp D VA L g) (jold-ezp D VA L z)
lLet (x, z) = Let (fold-dec D V A Lx) (fold-exp D VA L z)
Term:
fold-ezp proj2 unit append append ( Var `z' )

Is transformed to
Program:
datat ype TA+ E+E = C~~J~<E

- C%ing+zdatat ype T'string+E-
datat ype Tz+ x-tz = @~p~~~fun jold-dec+ D V A L x = case z of

Dec(v, z) * app@&+e+~ D v (fo~d-e~pn D V A L ~)fun fold-expn D V A L x = case x of

Var v * applyst~ng+x v v
lApp (y, z) a appl&_~+E A (fold-expn D J' A L Y) (fold-exprr D V A L Z)ILet (x, z) * applyz.~+~ L (fold-declv D V A L ~) (fold-e~pn D v' A L Z)

fun applyA+=+= v x z = case v of

C~4z+z * proj2 x z
fun applyst~ng+x v x = case v of

G'~t~&+x * unit z
fun applyx+z+x v x y = case v of

C%%% * append x y
Term:

Where:

37