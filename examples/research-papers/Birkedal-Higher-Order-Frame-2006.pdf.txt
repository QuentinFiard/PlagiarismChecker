

Logical Methods in Computer Science
Vol. 2 (5:1) 2006, pp. 1-33
www.lmcs-online.org Submitted Dec. 21, 2005Published Nov. 3, 2006

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER

FRAME RULES FOR ALGOL-LIKE LANGUAGES *

LARS BIRKEDAL a, NOAH TORP-SMITH b, AND HONGSEOK YANG c
a;b IT University of Copenhagen, Denmark

e-mail address: {birkedal,noah}@itu.dk
c Seoul National University, Korea

e-mail address: hyang@ropas.snu.ac.kr

Abstract. We show how to give a coherent semantics to programs that are well-specified
in a version of separation logic for a language with higher types: idealized algol extended
with heaps (but with immutable stack variables). In particular, we provide simple sound
rules for deriving higher-order frame rules, allowing for local reasoning.

1. Introduction
Separation logic [17, 16, 5, 14, 8, 4] is a Hoare-style program logic, and variants of it have
been applied to prove correct interesting pointer algorithms such as copying a dag, disposing
a graph, the Schorr-Waite graph algorithm, and Cheney's copying garbage collector. The
main advantage of separation logic compared to ordinary Hoare logic is that it facilitates
local reasoning, formalized via the so-called frame rule using a connective called separating
conjunction. The development of separation logic has mostly focused on low-level languages
with heaps and pointers, although in recent work [9] it was shown how to extend separation
logic to a language with a simple kind of procedures, and a second-order frame rule was
proved sound.

Our aim here is to extend the study of separation logic to high-level languages, in
particular to higher-order languages, in such a way that a wide collection of frame rules
are sound, thus allowing for local reasoning in the presence of higher-order procedures. For
concreteness, we choose to focus on the language of idealized algol extended with heaps
and pointers and we develop a semantics for this language in which all commands and
procedures are appropriately local. Our approach is to refine the type system of idealized
algol extended with heaps, essentially by making specifications be types, and give semantics
to well-specified programs. Thus we develop a separation-logic type system for idealized algol
extended with heaps. It is a dependent type theory and the types include Hoare triples, rules
corresponding to the rules of separation logic, and subtyping rules formalizing higher-order
versions of the frame rule of separation logic.

2000 ACM Subject Classification: F.3, D.3.
Key words and phrases: Program Verification, Separation Logic.
* An extended abstract of this paper appeared at LICS'05.

LOGICAL METHODSl IN COMPUTER SCIENCE DOI:10.2168/LMCS-2 (5:1) 2006 cfl L. Birkedal, N. Torp-Smith, and H. Yang

CCfl Creative Commons

2 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

Our type system is related to modern proposals for type systems for low-level imperative
languages, such as TAL [7], in that types may express state changes (since they include forms
of Hoare triples as types). The type system for TAL was proved sound using an operational
semantics. We provide a soundness proof of our type system using a denotational semantics
which we, moreover, formally relate to the standard semantics for idealized algol [11, 18].
The denotational semantics of a well-typed program is given by induction on its typing
derivation and the relation to the standard semantics for idealized algol is then used to
prove that the semantics is coherent (i.e., is independent of the chosen typing derivation).
We should perhaps stress that soundness is not a trivial issue: Reynolds has shown [9] that
already the soundness of the second-order frame rule is tricky, by proving that if a proof
system contains the second-order frame rule and the conjunction rule, together with the
ordinary frame rule and the rule of Consequence, then the system becomes inconsistent. The
semantics of our system proves that if we drop the conjunction rule, then we get soundness
of all higher-order frame rules, including the second-order one. We also show how to get
soundness of all higher-order frame rules without dropping the conjunction rule, by instead
restricting attention to so-called precise predicates (see Section 5).

In idealized algol, variables are allocated on a stack and they are mutable (i.e., one
can assign to variables). We only consider immutable variables (as in the ML programming
language) for simplicity. The reason for this choice is that all mutation then takes place in
the heap and thus we need not bother with so-called modifies clauses on frame rules, which
become complicated to state already for the second-order frame rule [9].

We now give an intuitive overview of the technical development. Recall that the standard semantics of idealized algol is given using the category CPO of pointed complete partial
orders and continuous functions. Thus types are interpreted as pointed complete partial
orders and terms (programs) are interpreted as continuous functions. The semantics of our
refined type system is given by refining the standard semantics. A type ` in our refined
type system specifies which elements of the "underlying" type in the standard semantics
satisfy the specification corresponding to ` and are appropriately local (to ensure soundness of the frame rules), that is, it "extracts" those elements. Moreover, the semantics also
equates elements, which cannot be distinguished by clients, that is, it quotients some of the
extracted elements. Corresponding to these two aspects of the semantics we introduce two
categories, C and D, where C just contains the extracted elements and D is a quotient of C.
Thus there is a faithful functor from C to CPO and a full functor from C to D. We show that
the categories C and D are cartesian closed and have additional structure to interpret the
higher-order frame rules, and that the mentioned functors preserve all this structure. The
semantics of our type system is then given in the category D and the functors relating C, D,
and CPO are then used to prove coherence of the semantics. In fact, as mentioned above,
our type system is a dependent type theory, with dependent product type \Pi i` intuitively
corresponding to the specification given by universally quantifying i in the specification corresponding to ` (the usual Curry-Howard correspondence). For this reason the semantics
is really not given in D but rather in the family fibration Fam(D) ! Set over D.

The remainder of this paper is organized as follows. In Section 2, we define the storage
model and assertion language used in this paper, thus setting the stage for our model. In
Section 3, we provide the syntax of the version of idealized algol we use in this paper.
In particular, we introduce our separation-logic type system, which includes an extended
subtype relation. We also include two extended examples of typings in our typing system,
one of which exemplifies the use of a third-order frame rule. In Section 4, we present the

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 3
main contribution of the paper, a model which allows a sound interpretation, which we also
show to be coherent and in harmony with the standard semantics. For simplicity, we omit
treatment of the conjunction rule in Sections 3 and 4 -- in Section 5 we show how to treat
the conjunction rule. In the last sections we give pointers to related and future work, and
conclude.

An extended abstract of this paper was presented at the LICS 2005 conference. Compared to the conference paper, the present paper includes proofs, more detailed examples
of the use of the typing system, and a treatment of the conjunction rule.

2. Storage Model and Assertion Language
We use the usual storage model of separation logic with one minor modification: we
make explicit the shape of stack storage. Let Ids = {i; j; : : :} be a countably infinite set of
variables, and let \Delta  range over finite subsets of Ids. We use the following semantic domains:

Loc def= PositiveInt ;

Val def= Int ;
j 2 [[\Delta ]] def= \Delta  ! Val ;
h 2 Heap def= Loc *fin Val ;
(j; h) 2 State(\Delta ) def= [[\Delta ]] * Heap:
In this storage model, locations are positive integers, so that they can be manipulated by
arithmetic operations. The set \Delta  models the set of variables in scope, and an element j
in [[\Delta ]] specifies the values of those stack variables. We sometimes call j an environment
instead of a stack, in order to emphasize that all variables are immutable. An element h
in Heap denotes a heap; the domain of h specifies the set of allocated cells, and the actual
action of h determines the contents of those allocated cells. We recall the disjointness
predicate h#h0 and the (partial) heap combination operator h * h0 from separation logic.
The predicate h#h0 means that dom(h) " dom(h0) = ;; and, h * h0 is defined only for such
disjoint heaps h and h0, and in that case, it denotes the combined heap h [ h0.

Properties of states are expressed using the assertion language of classical separation
logic [17]: 1

E ::= i | 0 | 1 | E + E | E - E;

P ::= E = E | E 7! E | emp | P * P | true | P ^ P | P . P | ~P | 8i: P: | 9i: P:

The assertion E 7! E0 means that the current heap has only one cell E and, moreover, that
the content of the cell is E0. When we do not care about the contents, we write E 7! -;
formally, this is an abbreviation of 9i: E 7! i for some i not occurring in E. The next two
assertions, emp and P * Q, are the most interesting features of this assertion language. The
empty predicate emp means that the current heap is empty, and the separating conjunction
P * Q means that the current heap can be partitioned into two parts, one satisfying P and
another satisfying Q.

As in the storage model, we make explicit which set of free variables we are considering
an expression or an assertion under. Thus, letting fv be a function that takes an expression
or an assertion and returns the set of free variables, we often write assertions as \Delta  ` P to

1The assertion language of separation logic also contains the separating implication -* . Since that
connective does not raise any new issues in connection with the present work, we omit it here.

4 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
indicate that fv(P ) ` \Delta , and that P is currently being considered for environments of the
shape \Delta . Likewise, we often write \Delta  ` E for expressions.

The interpretations of an expression \Delta  ` E and an assertion \Delta  ` P are of the forms

[[\Delta  ` E]] : [[\Delta ]] ! Val ; [[\Delta  ` P ]] : [[\Delta ]] ! P(Heap):
The interpretation of expressions is standard, just like that of assertions. We include part
of the definition of the interpretation of assertions here.

[[\Delta  ` E 7! E0]]j = if ([[\Delta  ` E]]j <= 0) then ; else \Phi [[[\Delta  ` E]]j![[\Delta  ` E0]]j]\Psi ;

[[\Delta  ` emp]]j = {[]};
[[\Delta  ` P * P 0]]j = {h * h0 | h#h0 ^ h 2 [[\Delta  ` P ]]j ^ h0 2 [[\Delta  ` P 0]]j};

[[\Delta  ` 8i: P ]]j = {h | 8n 2 Val : h 2 [[\Delta  [ {i} ` P ]]j[i!n]}:

3. Programming Language
The programming language is Reynolds's idealized algol [18] adapted for "separationlogic typing." It is a call-by-name typed lambda calculus, extended with heap operations,
dependent functions, and Hoare-triple types. As explained in the introduction, we only
consider immutable variables.

The types of the language are defined as follows. We write \Delta  ` ` : Type for a type ` in
context \Delta . The set of types is defined by the following inference rules (in which P and Q
range over assertions):

\Delta  ` P \Delta  ` Q

\Delta  ` {P }-{Q} : Type

\Delta  ` ` : Type \Delta  ` P

\Delta  ` ` \Omega  P : Type

\Delta  [ {i} ` ` : Type (i =2 \Delta )

\Delta  ` \Pi i` : Type

\Delta  ` ` : Type \Delta  ` `0 : Type

\Delta  ` ` ! `0 : Type
Note that the types are dependent types, in that they may depend on variables i (see
the first rule above). One way to understand a type is to read it as a specification for terms,
i.e., through the Curry-Howard correspondence. A Hoare-triple type {P }-{Q} is a direct
import from separation logic; it denotes a set of commands c that satisfy the Hoare triple
{P }c{Q}. An invariant extension ` \Omega  P is satisfied by a term M if and only if for one part
of the heap, the behavior of M satisfies ` and for the other part of the heap, M maintains
the invariant P . We remark that ` \Omega  P allows M to transfer cells between the `-part of
the heap and the P -part of the heap. For instance, {P }-{Q} \Omega  P0 intuitively consists of
the following commands c: given an input state satisfying P * P0, so that the input state
may be split into a P -part and a P0-part, command c changes these two parts, sometimes
transferring cells between the two, such that in the end, the P -part satisfies Q and the
P0-part satisfies P0.

The type \Pi i` is a dependent product type, as in standard dependent type theory
(under Curry-Howard it corresponds to the specification given by universally quantifying
i in the specification corresponding to `). Intuitively, \Pi i` denotes functions from integers
such that given an integer n, they return a value satisfying `[n=i]. For example, the type
\Pi i{j 7! -}-{j 7! i!} specifies a factorial function that computes the factorial of i and stores
the result in the heap cell j.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 5
The pre-terms of the language are given by the following grammar:

M ::= x | *x : `:M | M M | *i:M | M E

| fix M | ifz E M M | skip | M ; M
| let i = new in M | free(E) | [E] := E | let i = [E] in M ;

where E is an integer expression defined in Section 2. The language has the usual constructs
for a higher-order imperative language with heap operations, but it has two distinct features.
First, it treats the integer expressions as "second class": the terms M never have the
integer type, and all integer expressions inside a term are from the separate grammar for
E defined in Section 2. Second, no "integer variables" i can be modified in this language;
only heap cells can be modified. Note that the language has two forms of abstraction and
application, one for general terms and the other for integer expressions. A consequence of
this stratification is that all integer expressions terminate, because the grammar for E does
not contain the recursion operator.

The language has four heap operations. Command let i = new in M allocates a heap cell,
binds i to the address of the allocated cell, and executes the command M .2 An allocated
cell i can be disposed by free(i). The remaining two commands access the content of a cell.
The command [i] := E0 changes the content of cell i by E0; and let j = [i] in M reads the
content of cell i, binds j to the read value, and executes M . Note that the allocation and
lookup commands involve the "continuation", and make the bound variable available in the
continuation; such indirect-style commands are needed because all variables are immutable.

In this paper, we assume a hygiene condition on integer variables i, in order to avoid
the (well-known) issue of variable capturing. That is, we assume that no terms or types in
the paper use a single symbol i for more than one bound variables, or for a bound variable
and a free variable at the same time.

The typing rules of the language decide a judgment of the form \Gamma  `\Delta  M : `, where
\Gamma  is a list of type assignments to identifiers \Gamma  = x1 : `1; : : : ; xn : `n, and where the set \Delta 
contains all the free variables appearing in \Gamma ; M; `.

The type system is shown in Figures 1 and 2. For notational simplicity we have omitted
some obvious side-conditions of the form \Delta  ` ` : Type which ensure that, for a judgment
\Gamma  `\Delta  M : `, the set \Delta  always contains all the free variables appearing in \Gamma ; M; `, and that
the type assignment \Gamma  is always well-formed. There are three classes of rules. The first class
consists of the rules from the simply typed lambda calculus extended with dependent product types and recursion. The second class consists of the rules for the imperative constructs,
all of which come from separation logic. The last class consists of the subsumption rule
based on the subtype relation _\Delta , which is the most interesting part of our type system.
The proof rules for _\Delta  are shown in Figure 2. They define a preorder between types with
free variables in \Delta , and include all the usual structural subtyping rules in the chapter 15
of [13]. The rules specific to our system are: the covariant structural rule for ` \Omega  P ; the
encoding of Consequence in Hoare logic; the generalized frame rule that adds an invariant
to all types; and the distribution rules for an added invariant assertion.

The generalized frame rule, ` _\Delta  ` \Omega  P0, means that if a program satisfies ` and an
assertion P0 does not "mention" any cells described by `, then the program preserves P0.
Note that this rule indicates that the types in our system are tight [5, 17]: if a program
satisfies `, it can only access heap cells "mentioned" in `. This is why an assertion P0 for

2We consider single-cell allocation only in order to simplify the presentation; it is straightforward to adapt
our results to a language with allocation of n consecutive cells.

6 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

\Gamma ; x : ` `\Delta  x : `

\Gamma ; x : ` `\Delta  M : `0

\Gamma  `\Delta  *x : `:M : ` ! `0

\Gamma  `\Delta  M : `0 ! ` \Gamma  `\Delta  M 0 : `0

\Gamma  `\Delta  M M 0 : `

\Gamma  `\Delta [{i} M : `0 (i 62 fv(\Gamma ; \Delta ))
\Gamma  `\Delta  *i:M : \Pi i`0

\Gamma  `\Delta  M : \Pi i` \Delta  ` E

\Gamma  `\Delta  M E : `[E=i]

\Gamma  `\Delta  M : ` ! `

\Gamma  `\Delta  fix M : `

\Gamma  `\Delta  M : {P ^ E=0}-{Q} \Gamma  `\Delta  M 0 : {P ^ E6=0}-{Q}

\Gamma  `\Delta  ifz E M M 0 : {P }-{Q}

\Delta  ` P
\Gamma  `\Delta  skip : {P }-{P }

\Gamma  `\Delta  M : {P }-{P 0} \Gamma  `\Delta  M 0 : {P 0}-{Q}

\Gamma  `\Delta  (M ; M 0) : {P }-{Q}

\Delta  ` E
\Gamma  `\Delta  free(E) : {E7!-}-{emp}

\Gamma  `\Delta [{i} M : {i7!- * P }-{Q} (i 62 fv(\Gamma ; \Delta ; P; Q))
\Gamma  `\Delta  let i = new in M : {P }-{Q}

\Delta  ` E \Delta  ` E0
\Gamma  `\Delta  [E]:=E0 : {E7!-}-{E7!E0}

\Gamma  `\Delta [{i} M : {E7!i * P }-{Q} (i 62 fv(\Gamma ; \Delta ; E; Q))
\Gamma  `\Delta  let i=[E] in M : {9i: E7!i * P }-{Q}

\Gamma  `\Delta  M : ` ` _\Delta  `0

\Gamma  `\Delta  M : `0

Figure 1: Typing Rules

Inference Rules
` _\Delta  ` `0 _\Delta  `00

` _\Delta  `00

`00 _\Delta  `0 `1 _\Delta  `01
(`0 ! `1) _\Delta  (`00 ! `01)

` _\Delta [{i} `0 (i 62 \Delta )
(\Pi i`) _\Delta  (\Pi i`0)

` _\Delta  `0
(` \Omega  P ) _\Delta  (`0 \Omega  P )

8j 2 [[\Delta ]]: [[P 0]]j ` [[P ]]j ^ [[Q]]j ` [[Q0]]j

{P }-{Q} _\Delta  {P 0}-{Q0}

Axioms
` _\Delta  ` ` _\Delta  ` \Omega  P
({P }-{Q}) \Omega  P0 '\Delta  {P * P0}-{Q * P0} (\Pi i`) \Omega  P '\Delta  \Pi i(` \Omega  P ) (when i62\Delta )

(` \Omega  Q) \Omega  P '\Delta  ` \Omega  (Q * P ) (` ! `0) \Omega  P '\Delta  (` \Omega  P ! `0 \Omega  P )

Figure 2: Rules for the Subtyping Relation _\Delta 

"unmentioned" cells is preserved by the program. For instance, if a program M has a type
of the form

`1 ! : : : ! `n ! {P }-{Q};

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 7
the tightness of the type says that all the cells that M can directly access must appear in
the pre-condition P . Thus, if no cells in an assertion P0 appear in P , program M maintains
P0, as long as argument procedures maintain it. Such a fact can, indeed, be inferred by the
generalized frame rule together with the distribution rules:

`1 ! : : : ! `n ! {P }-{Q}
_\Delta  (* ` _\Delta  ` \Omega  P0)

(`1 ! : : : ! `n ! {P }-{Q}) \Omega  P0
_\Delta  (* (` ! `0) \Omega  P0 _\Delta  (` \Omega  P0 ! `0 \Omega  P0))

(`1 \Omega  P0 ! : : : ! `n \Omega  P0 ! {P }-{Q} \Omega  P0)
_\Delta  (* {P }-{Q} \Omega  P0 _\Delta  {P * P0}-{Q * P0})

(`1 \Omega  P0 ! : : : ! `n \Omega  P0 ! {P * P0}-{Q * P0}):

The generalized frame rule, the distribution rules, and the structural subtyping rule for
function types all together give many interesting higher-order frame rules, including the
second-order frame rule. The common mechanism for obtaining such a rule is: first, add an
invariant assertion by the generalized frame rule, and then, propagate the added assertion
all the way down to a base triple type by the distribution rules. The structural subtyping
rule for the function type allows us to apply this construction for a sub type-expression in
an appropriate covariant or contravariant way. For instance, we can derive a third-order
frame rule as follows:

({P1}-{Q1} ! {P2}-{Q2}) ! {P3}-{Q3}
_\Delta  (* ` _\Delta  ` \Omega  P )i

({P1}-{Q1} ! {P2}-{Q2}) ! {P3}-{Q3}j \Omega  P
_\Delta  (* (` ! `0) \Omega  P '\Delta  (` \Omega  P ! `0 \Omega  P ))

({P1}-{Q1}\Omega P ! {P2}-{Q2}\Omega P ) ! {P3}-{Q3}\Omega P
_\Delta  (* structural subtyping)

({P1}-{Q1}\Omega P ! {P2}-{Q2}) ! {P3}-{Q3}\Omega P
_\Delta  (* {P0}-{Q0} \Omega  P '\Delta  {P0 * P }-{Q0 * P })

({P1*P }-{Q1*P } ! {P2}-{Q2}) ! {P3*P }-{Q3*P }:

3.1. Example Proofs in the Type System. We illustrate how the type system works,
with the verification of two example programs.

The first example is a procedure that disposes a linked list. With this example we
demonstrate how a standard proof in separation logic yields a typing in our type system.
Let lst(i) be an assertion which expresses that the heap contains a linked list i terminating
with 0, and all the cells in the heap are in the list.3 We define a procedure Dlist for list
disposal as follows:

Dlist def= fix *f : (\Pi i{lst(i)}-{emp}): i*i: ifz i \Gamma skip\Delta  (let j = [i] in f (j); free(i))j:
The program Dlist takes a linked list i, and disposes the list, first the tail and then the
head of the list.

3Formally, lst(i) is the (parameterized) assertion that satisfies the equivalence:

lst(i) () (i = 0 ^ emp) . (9j: (i 7! j) * lst(j))
-- it can be defined as the minimal fixed point, expressible in higher-order separation logic [3].

8 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

We derive the typing judgment `{} Dlist : (\Pi i{lst(i)}-{emp}). Note that this derivation
captures the correctness of Dlist , because the judgment means that when Dlist is given a
linked list i as argument, then it disposes all the cells in the list.

The main part of the derivation is a proof tree for the false branch of the conditional
statement. Let \Gamma  be f : (\Pi i{lst(i)}-{emp}). The proof tree for the false branch is given
below:

\Gamma  `{i;j} f : \Pi i{lst(i)}-{emp}
\Gamma  `{i;j} f (j) : {lst(j)}-{emp} 1
\Gamma  `{i;j} f (j) : {i7!j * lst(j)}-{i7!j}

\Gamma  `{i;j} free(i) : {i7!-}-{emp} 2

\Gamma  `{i;j} free(i) : {i7!j}-{emp}
\Gamma  `{i;j} (f (j); free(i)) : {i7!j * lst(j)}-{emp}
\Gamma  `{i} (let j=[i] in f (j); free(i)) : {9j: i7!j * lst(j)}-{emp} 3

\Gamma  `{i} (let j=[i] in f (j); free(i)) : {lst(i) ^ i6=0}-{emp}
Most of the steps in this tree use syntax-directed rules, such as those for the sequential
composition and procedure application. The only exceptions are the steps marked by 1,
2 and 3, where we apply the subsumption rule. These steps express structural rules in
separation logic. Step 1 is an instance of the ordinary frame rule, and attaches the invariant
(i7!j) to the pre- and post-conditions of the triple type {lst(j)}-{emp}. The other steps
are an instance of Consequence. Step 2 strengthens the pre-condition of {i7!-}-{emp},
and step 3 replaces the pre-condition of {9j:i7!j * lst(j)}-{emp} by the equivalent assertion
lst(j) ^ i6=0. In the tree above, we have not shown how to derive the necessary subtype
relations in 1, 2 and 3. They are straightforward to derive:

{lst(j)}-{emp} _{i;j} ({lst(j)}-{emp}) \Omega  i7!j (* ` _\Delta  ` \Omega  R)

_{i;j} {lst(j) * i7!j}-{emp * i7!j} (* {P }-{Q} \Omega  R '\Delta  {P * R}-{Q * R})
_{i;j} {i7!j * lst(j)}-{i7!j} (* 8j: [[P *Q]]j = [[Q*P ]]j ^ [[emp*P ]]j = [[P ]]j)

{i7!-}-{emp} _{i;j} {i7!j}-{emp} (* 8j: [[i7!j]]j ` [[i7!-]]j)
{9j: i7!j * lst(j)}-{emp} _{i} {lst(i) ^ i6=0}-{emp} (* 8j: [[9j:i7!j*lst(j)]]j = [[lst(i) ^ i6=0]]j):
The complete derivation of `{} Dlist : \Pi i{lst(i)}-{emp} is shown in Figure 3.

The second example is a client program that uses a randomized memory manager. The
verification of this program demonstrates the use of a third-order frame rule.

The randomized memory manager is a module with two methods, Malloc for allocating
a cell and Mfree for deallocating a cell. The memory manager maintains a free list whose
starting address is stored in the cell l. When Malloc is called, the module first checks this
free list [l]. If the free list is not empty, Malloc takes one cell from the list and returns it
to the client. Otherwise, Malloc makes a system call, obtains a new cell from the operating
system, and returns this cell to the client. When Mfree is called to deallocate cell i, the
randomized memory manager first flips a coin. Then, depending on the result of the coin,
it either adds the cell i to the free list or returns the cell to the operating system. Note
that randomization is used only in Mfree. We will focus on the method Mfree.

Let inv(l) be the assertion 9l0: (l7!l0) * lst(l0), which expresses that cell l stores the
starting address of a linked list. The following program implements the Mfree method of

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 9
\Gamma  `{i;j} f :\Pi i{lst(i)}-{emp}
\Gamma  `{i;j} f (j):{lst(j)}-{emp} 1
\Gamma  `{i;j} f (j):{i7!j * lst(j)}-{i7!j}

\Gamma  `{i;j} free(i):{i7!-}-{emp} 2

\Gamma  `{i;j} free(i):{i7!j}-{emp}
\Gamma  `{i;j} (f (j); free(i)):{i7!j * lst(j)}-{emp}
\Gamma  `{i} let j=[i] in (f (j); free(i)):{9j: i7!j * lst(j)}-{emp} 3

\Gamma  `{i} let j=[i] in (f (j); free(i)):{lst(i) ^ i6=0}-{emp}

\Gamma  `{i} skip:{emp}-{emp} 4
\Gamma  `{i} skip:{lst(i) ^ i=0}-{emp}
\Gamma  `{i} \Gamma ifz i (skip) (let j=[i] in (f (j); free(i)))\Delta :{lst(i)}-{emp}
\Gamma  `{} \Gamma *i: ifz i (skip) (let j=[i] in (f (j); free(i)))\Delta :\Pi i{lst(i)}-{emp}
`{} \Gamma *f:*i: ifz i (skip) (let j=[i] in (f (j); free(i)))\Delta :(\Pi i{lst(i)}-{emp}) ! (\Pi i{lst(i)}-{emp})

`{} Dlist:\Pi i{lst(i)}-{emp}
In the tree, \Gamma  is f : \Pi i{lst(i)}-{emp}; and at 1 - 4 of the tree, the subsumption rule is

used with the following subtype relations:

{lst(j)}-{emp} _{i;j} {i7!j * lst(j)}-{i7!j}

{i7!-}-{emp} _{i;j} {i7!j}-{emp}
{9j: i7!j * lst(j)}-{emp} _{i} {lst(i) ^ i6=0}-{emp}

{emp}-{emp} _{i} {lst(i) ^ i=0}-{emp}

Figure 3: Derivation of the Typing Judgment `{} Dlist : \Pi i{lst(i)}-{emp}

the randomized memory manager:

Mfree : i\Gamma \Pi i{i7!-}-{i7!-}\Delta  ! \Gamma \Pi i{i7!-}-{emp}\Delta j \Omega  inv(l)
Mfree def= *cflip: *i: cflip(i); let i0=[i] in iifz i0 (free(i)) \Gamma let l0=[l] in ([i]:=l0; [l]:=i)\Delta j
Note that before disposing cell i, method Mfree uses the cell to store the result of flipping a
coin by calling cflip with i. The declared type of the method Mfree has the form ` \Omega  inv(l).
The ` part expresses that the method has the expected behavior externally, and the inv(l)
part indicates that it maintains the module invariant internally. The derivation of the
declared type is shown in Figure 4.

We now consider the following client of the randomized memory manager.

Rd : \Pi i{i7!-}-{i7!-}
Rd def= *i: let i0 = [i] in [i]:=i0+1

Client : (\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}) ! {j7!-}-{emp}
Client def= *mfree: (mfree Rd j)
The client Client takes a "randomized" method mfree for deallocating a cell. Then, it instantiates the method with the (degenerate) "random function" Rd , and calls the instantiated
method to dispose cell j. Suppose that Client is "linked" with the Mfree of the randomized

10 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

Consider \Gamma ; \Delta  such that cflip 62 dom(\Gamma ) and l0; i0; i 62 \Delta  but l 2 \Delta . Define \Gamma 0, FBranch,

and Body as follows:

\Gamma 0 def= \Gamma ; cflip : \Pi i{i7!-}-{i7!-}
FBranch def= let l0=[l] in ([i]:=l0; [l]:=i)

Body def= let i0=[i] in (ifz i0 (free(i)) FBranch)
The term Mfree and its subterms FBranch and Body are typed as follows:

\Gamma 0 `\Delta [{i;i0;l0} [i]:=l0:{i7!-}-{i7!l0} 1
\Gamma 0 `\Delta [{i;i0;l0} [i]:=l0:{l7!-*i7!-}-{l7!-*i7!l0}

\Gamma 0 `\Delta [{i;i0;l0} [l]:=i:{l7!-}-{l7!i} 2
\Gamma 0 `\Delta [{i;i0;l0} [l]:=i:{l7!-*i7!l0}-{l7!i*i7!l0}
\Gamma 0 `\Delta [{i;i0;l0} ([i]:=l0; [l]:=i):{l7!-*i7!-}-{l7!i*i7!l0} 3
\Gamma 0 `\Delta [{i;i0;l0} ([i]:=l0; [l]:=i):{l7!l0*i7!i0*lst(l0)}-{l7!i*i7!l0*lst(l0)}
\Gamma 0 `\Delta [{i;i0} let l0=[l] in ([i]:=l0; [l]:=i):{9l0: l7!l0*i7!i0*lst(l0)}-{l7!i*i7!l0*lst(l0)} 4

\Gamma 0 `\Delta [{i;i0} FBranch:{i7!i0*inv(l) ^ i06=0}-{inv(l)}

\Gamma 0 `\Delta [{i;i0} free(i):{i7!-}-{emp} 5
\Gamma 0 `\Delta [{i;i0} free(i):{i7!i0*inv(l) ^ i0=0}-{inv(l)} \Gamma 0 `\Delta [{i;i0}FBranch:{i7!i0*inv(l) ^ i06=0}-{inv(l)}

\Gamma 0 `\Delta [{i;i0} (ifz i0 (free(i)) FBranch):{i7!i0*inv(l)}-{inv(l)}
\Gamma 0 `\Delta [{i} let i0=[i] in (ifz i0 (free(i)) FBranch):{9i0:i7!i0*inv(l)}-{inv(l)} 6

\Gamma 0 `\Delta [{i} Body :{i7!-*inv(l)}-{inv(l)}

\Gamma 0 `\Delta [{i} cflip(i):{i7!-}-{i7!-} 7
\Gamma 0 `\Delta [{i} cflip(i):{i7!-*inv(l)}-{i7!-*inv(l)} \Gamma 0 `\Delta [{i} Body :{i7!-*inv(l)}-{inv(l)}

\Gamma 0 `\Delta [{i} cflip(i); Body :{i7!-*inv(l)}-{inv(l)}
\Gamma 0 `\Delta  *i: cflip(i); Body :\Pi i{i7!-*inv(l)}-{inv(l)}
\Gamma  `\Delta  Mfree:\Gamma \Pi i{i7!-*inv(l)}-{i7!-*inv(l)}\Delta  ! \Gamma \Pi i{i7!-*inv(l)}-{inv(l)}\Delta  8

\Gamma  `\Delta  Mfree:i\Gamma \Pi i{i7!-}-{i7!-}\Delta  ! \Gamma \Pi i{i7!-}-{emp}\Delta j \Omega  inv(l)

where the steps marked by 1-8 use the subsumption rule.

Figure 4: Derivation of the Typing Judgment for Mfree

memory manager, that is, that it is applied to Mfree. We prove the correctness of this
application by deriving the typing judgment `{j;l} (Client Mfree) : {j7!- * inv(l)}-{inv(l)}.

The derivation of the mentioned typing judgment consists of three parts: the sub prooftrees for Mfree and Client , and the part that links these two proof trees. The sub proof-trees
for Mfree and Client are shown in Figures 4 and 5. Note that the internal free list [l] of the
memory manager does not appear in the proof tree for Client in Figure 5; all the rules in
the tree concern just cell j, the only cell that Client directly manipulates.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 11
\Gamma  `{j;l}mfree:\Pi i{i7!-}-{i7!-}!\Pi i{i7!-}-{emp}

\Gamma  `{j;l;i;i0}[i]:=i0+1:{i7!-}-{i7!i0+1} 1

\Gamma  `{j;l;i;i0}[i]:=i0+1:{i7!i0}-{i7!-}
\Gamma  `{j;l;i}let i0=[i] in [i]:=i0+1:{9i0: i7!i0}-{i7!-} 2

\Gamma  `{j;l;i}let i0=[i] in [i]:=i0+1:{i7!-}-{i7!-}

\Gamma  `{j;l}Rd:\Pi i{i7!-}-{i7!-}
\Gamma  `{j;l}mfree Rd:\Pi i{i7!-}-{emp}

\Gamma  `{j;l}mfree Rd j:{j7!-}-{emp}
`{j;l} Client:(\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}) ! {j7!-}-{emp}
where \Gamma  is mfree : \Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}. In the tree, the subsumption

rule is applied at 1 and 2, and in both cases, it uses subtype relations that express

Consequence.

Figure 5: Typing Derivation for Client

It is the third-order frame rule that lets us ignore the internal free list [l] of the memory
manager when constructing the proof tree for Client . The third-order frame rule adds the
missing free list [l] to the derived type for Client , so that we can link Client with Mfree,
without producing a type error. More precisely, the rule allows the following derivation:

`{j;l} Client : (\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}) ! {j7!-}-{emp} 1

`{j;l} Client : \Gamma (\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}) \Omega  inv(l)\Delta  ! {j7!-*inv(l)}-{inv(l)}

`{j;l} Client Mfree : {j7!- * inv(l)}-{inv(l)}
Here the step marked by 1 is an instance of the third-order frame rule, and it applies the
subsumption rule with the subtype relation proved below:\Gamma 

\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}\Delta  ! {j7!-}-{emp}
_{j;l} (* ` _\Delta  ` \Omega  P )i\Gamma 

\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}\Delta  ! {j7!-}-{emp}j \Omega  inv(l)
_{j;l} (* (` ! `0) \Omega  P '\Delta  (` \Omega  P ! `0 \Omega  P ))i\Gamma 

\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}\Delta  \Omega  inv(l)j ! i{j7!-}-{emp} \Omega  inv(l)j
_{j;l} (* {P }-{Q} \Omega  R '\Delta  {P * R}-{Q * R})i\Gamma 

\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}\Delta  \Omega  inv(l)j ! {j7!- * inv(l)}-{emp * inv(l)}
_{j;l} (* 8j: [[P ]]j = [[P * emp]]j)i\Gamma 

\Pi i{i7!-}-{i7!-} ! \Pi i{i7!-}-{emp}\Delta  \Omega  inv(l)j ! {j7!- * inv(l)}-{inv(l)}:

12 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

4. Semantics
In this section we present our main contribution, the semantics that formalizes the
underlying intuitions of the separation-logic type system. In particular, we formalize the
following three intuitive properties of the type system:

(1) The types in the separation-logic type system refine the conventional types. A

separation-logic type specifies a stronger property of a term, and restricts clients of
such terms by asking them to only depend upon what can be known from the type.
For instance, the type {1 7! 3}-{1 7! 0} of a term M indicates not just that M is a
command, but also that M stores 0 to cell 1 if cell 1 contains 3 initially. Moreover,
this type forces clients to run M only when cell 1 contains 3.
(2) The higher-order frame rules in the type system imply that all programs behave

locally.
(3) The type system, however, does not change the computational behavior of each

program.

We formalize the first intuitive property by means of partial equivalence relations. Roughly,
each type ` in our semantics determines a partial equivalence relation (in short, per) over
the meaning of the "underlying type" `. The domain of a per over a set A is a subset
of A; this indicates that ` indeed specifies a stronger property than `. The other part
of a per, namely the equivalence relation part, explains that the type system restricts the
clients, so that no type-checked clients can tell apart two equivalent programs. For instance,
{1 7! 3}-{1 7! 0} determines a per over the set of all commands. The domain of this per
consists of commands satisfying {1 7! 3}-{1 7! 0}, and the per equates two such commands
if they behave identically when cell 1 contains 3 initially. The equivalence relation implies
that type-checked clients run a command of {1 7! 3}-{1 7! 0} only when cell 1 contains 3.

We justify the other two intuitive properties by proving technical lemmas about our
semantics. For number 2, we prove the soundness of all the subtyping rules, including
the generalized frame rule and the distribution rules. For number 3, we prove that our
semantics has been obtained by extracting and then quotienting semantic elements in the
conventional semantics; yet, this extraction and quotienting does not reduce the computational information of semantic elements.

In this section, we first define categories C and D, corresponding to the extraction and
quotienting, respectively. Next we give the interpretation of types and terms. Finally, we
connect our semantics with the conventional semantics, and prove that our semantics is
indeed obtained by extracting and quotienting from the conventional semantics.

To make the paper accessible for a wider audience, we have decided to present the
categories C and D and the proofs of their properties in a very concrete way -- it is possible
to give equivalent, but more abstract, descriptions of C and D and use known abstract
results ?From category theory to prove some of their properties (e.g., cartesian closure).
For simplicity, we use the Hoare powerdomain to model the nondeterminism of commands
in the semantics. Our results can be adapted to other alternatives, such as the Plotkin
powerdomain for countable nondeterminism, using the idea from the chapter 9.3.2 of [23].

4.1. Categories C and D. We construct C and D by modifying the category CPO of
pointed cpos and continuous functions. For C, we impose a parameterized per on each cpo,
and extract only those morphisms in CPO that preserve such pers (at all instantiations).
The pers formalize that each type ` corresponds to a specification over the underlying

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 13
type `, and the preservation of the pers guarantees that all the morphisms in C satisfy
the corresponding specifications. The parameterization of each per gives an additional
guarantee that all morphisms in C behave locally (in the sense of higher-order frame rules).
The other category D is a quotient of C. Intuitively, the quotienting of C reflects that
our type system also restricts the clients of a term; thus, more terms become equivalent
observationally.

We define the "extracting" category C first. Let Pred be the set of predicates, i.e.,
subsets of Heap. We recall the semantic version of separating connectives, emp and *, on
Pred . For p; q 2 Pred ,

h 2 emp () h = *n:undef ;
h 2 p * q () 9h1h2: h1 * h2 = h ^ h1 2 p ^ h2 2 q:

The category C is defined as follows:

* objects: (A; R) where A is a pointed cpo, and R is a family of admissible pers4

indexed by predicates such that

8p; q 2 Pred : R(p) ` R(p * q);

* morphisms: f : (A; R) ! (B; S) is a continuous function from A to B such that

8p 2 Pred : f [R(p) ! S(p)]f;
i.e., f maps R(p) related elements to S(p) related elements.
Intuitively, an object (A; R) denotes a specification parameterized by invariant extension.
The first component A denotes the underlying set from which we select "correct" elements.
R(emp) denotes the initial specification of this object where no invariant is added by the
frame rule. The domain |R(emp)| of per R(emp) indicates which elements satisfy the
specification, and the equivalence relation on |R(emp)| expresses how the specification is
also used to limit the interaction of a client: the client can only do what the specification
guarantees, so more elements become equivalent observationally. The per R(p) at another
predicate p denotes an extended specification by the invariant p.

We illustrate the intuition of C with a "Hoare-triple" object [p; q] for p; q 2 Pred . Let
comm be the set of all functions c from Heap to P(Heap [ {wrong }) that satisfy safety
monotonicity and the frame property:

* Safety Monotonicity: for all h; h0 2 State , if h#h0 and wrong 62 c(h), then wrong 62

c(h * h0);

* Frame Property: for all h; h0; h01 2 State, if h#h0, wrong 62 c(h), and h01 2 c(h * h0),

then there exists h0 such that h01 = h0 * h0 and h0 2 c(h).

The above two properties are from the work on separation logic, and they form a sufficient
and necessary condition that commands satisfy the (first-order) frame rule [24]. Note that
the safety monotonicity and frame property are equivalent to the following condition:5

if h#h0 and wrong isn't in c(h), then c(h * h0) ` {h0 * h0 | h0 2 c(h) and h0#h0}.
4A per R

0 on A is admissible iff (?; ?) 2 R0 and R0 is a sub-cpo of A * A.5

The inclusion is one way only. For a counterexample, consider two disjoint heaps h=[1!0] and h0=[2!0]
and the command

` let j=new in `free(j); (ifz (j-2) ([1] := 5) ([1] := 6))' : {1 7! -}-{1 7! -}:
When this command is run in h, it nondeterministically assigns 5 or 6 to location 1, but when it is run in a
bigger heap h * h0, the command always assigns 6 to the same location.

14 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
The set comm is the first component of the Hoare-triple object [p; q], where the order on
comm is given by:

c v c0 () 8h: c(h) ` c0(h):

The real meaning of [p; q] is given by the second component R. For each predicate p0,
the domain of R(p0) consists of all "commands" in comm that satisfy {p * p0}-{q * p0}:

c 2 |R(p0)| () 8h 2 p * p0: c(h) ` q * p0:
The equivalence relation R(p0) relates c and c0 in |R(p0)| iff c and c0 behave the same for
the inputs in p * p0 * true:

true = {h | h 2 Heap}
c[R(p0)]c0 () 8h 2 p * p0 * true: c(h) = c0(h):

This equivalence relation means that the type system allows a client to execute c or c0 in h
only when h satisfies p * p0 * p0 for some p0, which is added by the frame rule. We remark
that the * operator in the definition of |R(p0)| is allowed to partition the heap differently
before and after the execution of c. For instance, when

p = {[1!1]}; q = {[2!0]}; and p0 = {[2!0; 3!0]; [1!0; 3!1]};
the initial heap h in the definition is split into cell 1 for p and cells 2; 3 for p0, but the final
heap is split into cell 2 for q and cells 1; 3 for p0.

The category C is cartesian closed, has all small products, and contains the least fixpoint
operator. The terminal object is ({?}; CR) where CR(p) is {(?; ?)} for all p, and the small
products are given pointwise; for instance, (A; R) * (B; S) is (A * B; {R(p) * S(p)}p). The
exponential of (A; R) and (B; S) is subtle, and its per component involves the quantification
over all predicates. The cpo component of the exponential (A; R) ) (B; S) is the continuous
function space A ) B, and the per component of (A; R) ) (B; S), denoted R ) S, is
defined as follows:

f 2 |(R ) S)(p)| () 8q 2 Pred : f [R(p * q) ! S(p * q)]f;

f [(R ) S)(p)]g () f; g 2 |(R ) S)(p)| ^ 8q 2 Pred : f [R(p * q) ! S(p * q)]g:

Note that the right hand sides of the above equivalences quantify over all *-extension p * q
of p. This quantification ensures that R ) S satisfies the requirement

8p; p0 2 Pred : (R ) S)(p) ` (R ) S)(p * p0)
in the category C.

Lemma 4.1. C is cartesian closed, and has all small products.
Proof. First, we prove that for every (small) family {(Ai; Ri)}i2I of objects in C, its product
is (\Pi i2I Ai; \Pi i2I Ri) and the i-th projection ssi is *x:x(i). Here we write (\Pi i2;Ai; \Pi i2;Ri) for
({?}; CR). It is straightforward to show that (\Pi i2I Ai; \Pi i2I Ri) is an object in C and ssi is a
morphism in C. So, we focus on proving the usual universality requirement for the product.
Consider an object (B; S) and a family fi : (B; S) ! (Ai; Ri)i2I of morphisms in C. We
need to prove that there exists a unique morphism k from (B; S) to (\Pi i2I Ai; \Pi i2I Ri), such
that

8i 2 I: fi = ssi ffi k:

The above formula is equivalent to saying that k is g = *b:*i:fi(b). In particular, when
I = ;, k has to be the unique function g0 = *b:?. Note that these characterizations give
the uniqueness of k. We prove the existence of k, by showing that g and g0 are morphisms

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 15
in C. The continuity of g and g0 is well-known. The relation preservation of g0 also easily
follows, since CR is a family of complete relations. For the relation preservation of g, we
use the fact that fi's are the morphisms in C. Pick an arbitrary predicate p, and choose
b; b0 from B such that b[S(p)]b0. Then,

8i 2 I: fi(b)[Ri(p)]fi(b0) () 8i 2 I: g(b)(i)\Theta Ri(p)\Lambda g(b0)(i) (* the definition of g)

() g(b)\Theta (\Pi i2I Ri)(p)\Lambda g(b0) (* the definition of \Pi i2I Ri):

Next, we prove that (A ) B; R ) S) is an exponential of (A; R) and (B; S), with the
evaluation morphism ev = *(f; x):f (x). It is straightforward to prove that ev is a morphism
in C and (A ) B; R ) S) is an object in C. So, we focus on the universality requirement
for the exponentials. Consider a morphism f : (C; T ) * (A; R) ! (B; S) in C. We need to
show that there exists a unique morphism curry(f ) : (C; T ) ! (A ) B; R ) S) such that

8(c; a) 2 C * A: f (c; a) = ev(curry(f )(c); a):
Since ev(curry(f )(c); a) = curry(f )(c)(a), the above is equivalent to curry(f ) = *c:*a:f (c; a).
Note that this characterizes curry(f ) completely, so it gives the uniqueness of curry(f ). It
remains to prove that curry(f ) is a morphism in C. It is well-known that curry(f ) is a
continuous function from C to A ) B. Thus, we only prove the relation preservation of
curry(f ), using the fact that f [T (p) * R(p) ! S(p)]f for all p. Pick arbitrary predicate
p and c; c0 in C such that c[T (p)]c0. Then, for all predicates q, we have that c[T (p * q)]c0,
because T (p) ` T (p * q). Thus,

8q:8a; a0 2 A: a[R(p * q)]a0 =) f (c; a)[S(p * q)]f (c0; a0)
() (* the definition of R ) S)

(*a:f (c; a))\Theta (R ) S)(p)\Lambda (*a0:f (c0; a0))
() (* the definition of curry(f ))

curry(f )(c)\Theta (R ) S)(p)\Lambda curry(f )(c0):

Lemma 4.2. For every object (A; R) in C, the least fixpoint operator lfixA : [A ) A] ! A
on A is a morphism in C.

Proof. Pick arbitrary predicate p, and continuous functions f; g of type A ! A, such
that f [(R ) R)(p)]g; equivalently, f [R(p * q) ! R(p * q)]g for all q. We need to show
that lfix(f )[R(p)]lfix(g). Note that since R is admissible, it is sufficient to prove that
f k(?)[R(p)]gk(?) for all k >= 0. This sufficient condition holds because f [R(p) ) R(p)]g
and ?[R(p)]?.

Another important feature of C is that it validates higher-order frame rules. Let Pr be
the preorder (Pred ; v) with v defined by predicate extension:

p v r () 9q:p * q = r:
Category C has an "invariant-extension" functor inv from C * Pr to C defined by:

inv((A; R); p) = (A; R(p * -)) and inv(f; p v q) = f:
Functor inv corresponds to the type constructor \Omega  in our language; given a "type" (A; R)
and a predicate p, inv extends (A; R) by adding the invariant p. For instance, when a triple
object [p0; q0] is extended with p, it becomes [p0 * p; q0 * p].

Functor inv validates the subtyping rules that express higher-order frame rules: the
generalized frame rule ` _\Delta  `\Omega P and the rules for distributing \Omega  over each type constructor.

16 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
We first show that the functoriality of inv gives the soundness of the generalized frame rule.
Note that emp v p for all predicates p, and that inv(-; emp) is the identity functor on C.
Thus, for each (A; R), the functoriality of inv gives a morphism from (A; R) to inv((A; R); p).
This morphism gives the soundness of the subtyping rule ` _\Delta  ` \Omega  P .

The soundness of the other distribution rules follows from the fact that for all p, inv(-; p)
preserves most of the structure of C. For instance, inv(-; p) preserves the exponential of C,
because for all objects (A; R) and (B; S) and all predicates q, we have that

f [(R(p * -) ) S(p * -))(q)]g () 8q0:f [R(p * (q * q0)) ! S(p * (q * q0))]g

() 8q0:f [R((p * q) * q0) ! S((p * q) * q0)]g
() f [(R ) S)(p * q)]g:

Lemma 4.3. For each predicate p, inv(-; p) preserves the cartesian closed structure and
all the small products of C on the nose.

Proof. It is sufficient to prove that inv(-; p) preserves exponential objects, small product
objects, evaluation morphisms, and projection morphisms. First, we prove the preservation
of the small product objects and projection morphisms. Consider a family {(Ai; Ri)}i2I of
objects in C. The following shows that the product \Pi i2I (Ai; Ri) of this family is preserved
by inv(-; p):

inv\Gamma \Pi i2I (Ai; Ri); p\Delta  = inv\Gamma \Gamma \Pi i2I Ai; \Pi i2I Ri\Delta ; p\Delta  (* the definition of products in C)

= \Gamma \Pi i2I Ai; (\Pi i2I Ri)(p * -)\Delta  (* the definition of inv)
= \Gamma \Pi i2I Ai; \Pi i2I (Ri(p * -))\Delta 
= \Pi i2I \Gamma Ai; Ri(p * -)\Delta 
= \Pi i2I \Gamma inv((Ai; Ri); p)\Delta  (* the definition of inv):

Since inv(f; p) = f , functor inv preserves the i-th projection from \Pi i2I (Ai; Ri).

Next, we show that inv(-; p) preserves the exponential objects and evaluation morphisms in C. Let (A; R) and (B; S) be objects in C. By what we have shown before this
lemma, we have that

(R ) S)(p * -) = R(p * -) ) S(p * -):
?From this follows the preservation of exponential objects:

inv\Gamma (A; R) ) (B; S); p\Delta  = inv\Gamma (A ) B; R ) S); p\Delta  (* Def. of exponentials in C)

= \Gamma A ) B; (R ) S)(p * -)\Delta  (* Def. of inv)
= \Gamma A ) B; (R(p * -) ) S(p * -))\Delta 
= \Gamma A; R(p * -)\Delta  ) \Gamma B; S(p * -)\Delta  (* Def. of exponentials in C)
= inv\Gamma (A; R); p\Delta  ) inv\Gamma (B; S); p\Delta  (* Def. of inv):

Functor inv(-; p) preserves the the evaluation morphism ev for (A; R) ) (B; S), because
inv(-; p) preserves the products and exponentials and inv(f; p) only changes the type of f ,
not modifying its "meaning" (i.e., inv(f; p) = f ).

Lemma 4.4. For all predicates p and q, inv(-; p) ffi inv(-; q) = inv(-; p * q).
Proof. Both inv(-; p) ffi inv(-; q) and inv(-; p * q) map a morphism f to the same f with
perhaps different domain and codomain. Thus, if they act the same on the objects in C,
they must act the same on the morphisms. In fact, they do act the same on the objects;

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 17
for each (A; R) in C,

(inv(-; p) ffi inv(-; q))(A; R) = (A; R(p * (q * -))) (* the definition of inv)

= (A; R((p * q) * -)) (* * is associative)
= inv(-; p * q)(A; R) (* the definition of inv):

For now, the final remark on C is that the triple-object generator [-; -] can be made
into a functor, whose morphism action validates the subtyping rule for Consequence. Let P
be the set of predicates ordered by the subset inclusion `. Generator [-; -] can be extended
to a functor tri from Pop * P to C:

tri(p; q) = [p; q] and tri(p0 ` p; q ` q0)(c) = c:
Note that tri is contravariant in the first argument and covariant on the second argument.
This mixed variance reflects that the pre-condition of a triple can be strengthened, and
the post-condition can be weakened; thus, it validates the subtyping rule for Consequence.
We also note that the subtyping rule that moves an invariant assertion into the pre- and
post-conditions is sound.

Lemma 4.5. For each predicate p, let - * p : P ! P be a functor that maps a predicate q
to q * p. Then,

inv(-; p) ffi tri = tri(- * p; - * p):

Proof. Both inv(-; p) ffi tri and tri(- * p; - * p) map the morphisms in Pop * P to inclusions
between pointed cpos. Thus, it is sufficient to prove that inv(-; p) ffi tri and tri(- * p; - * p)
act the same on objects. Pick an arbitrary object (p0; q0) in Pop * P. Then, by the definition
of inv and tri, there exist families R; S of pers such that

(comm; R) = (inv(-; p) ffi tri)(p0; q0) and (comm; S) = (tri(- * p; - * p))(p0; q0):
Thus, to prove (inv(-; p) ffi tri)(p0; q0) = (tri(- * p; - * p))(p0; q0), we only need to show R = S.
For each predicate p0, the domains of R(p0) and S(p0) are the same, because

c 2 |R(p0)| () 8h 2 p0 * (p * p0): c(h) ` q0 * (p * p0) (* Def. of inv(tri(p0; q0); p))

() 8h 2 (p0 * p) * p0: c(h) ` (q0 * p) * p0 (* * is associative)
() c 2 |S(p0)| (* Def. of tri(p0 * p; q0 * p)):

And, R(p0) and S(p0) specify the same relation on their domains, because

c[R(p0)]c0 () 8h 2 p0 * (p * p0) * true: c(h) = c0(h) (* Def. of inv(tri(p0; q0); p))

() 8h 2 (p0 * p) * p0 * true: c(h) = c0(h) (* * is associative)
() c[S(p0)]c0 (* Def. of tri(p0 * p; q0 * p)):

The category D is obtained from C by equating morphisms according to an equivalence
relation ,. Morphisms f and g in C[(A; R); (B; S)] are related by , iff

8p 2 Pred : f [R(p) ! S(p)]g:
, is an equivalence relation; it is reflexive, because every morphism in C[(A; R); (B; S)]
should map R(p)-related elements to S(p)-related elements, for all p; it is symmetric and
transitive because, for all p, R(p) and S(p) are symmetric and transitive. The interesting
property of , is that it is preserved by all the structure of C:

Lemma 4.6 (Preservation). The relation , is preserved by the following operators in C:

18 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

* the functor inv(-; p v q) on C, for all predicates p; q such that p v q;

* the composition of morphisms;

* the currying of morphisms; and

* the pairing into all the small products.

Proof. First, we prove the preservation by inv. Let p and q be predicates such that p v q.
Pick arbitrary two morphisms f; g : (A; R) ! (B; S) in C such that f , g. We will show
that inv(f; p v q) , inv(g; p v q). Morphism inv(f; p v q) and inv(g; p v q) both have the
type (A; R(p * -)) ! (B; S(q * -)). Thus, proving inv(f; p v q) , inv(g; p v q) amounts to
showing the formula:

8r 2 Pred : f [R(p * r) ! S(q * r)]g:

The formula holds, because f [R(p * r) ! S(p * r)]g and S(p * r) ` S(q * r) for all r.

Second, we prove the preservation by the composition of morphisms. Consider morphisms f; f 0 : (A; R) ! (B; S) and g; g0 : (B; S) ! (C; T ) such that f , f 0 and g , g0. Then,
for all predicates p and all a; a0 2 A such that a[R(p)]a0, we have that f (a)[S(p)]f 0(a0), so
g(f (a))[T (p)]g0(f 0(a0)). This proves that (g ffi f ) , (g0 ffi f 0).

Third, we show the preservation by the currying operator. Consider morphisms f; f 0
from (C; T ) * (A; R) to (B; S), such that f , f 0. Pick an arbitrary predicate p, and choose
T (p)-related c; c0 from C. Then, for all predicates q, we have that c[T (p * q)]c0, because
T (p) ` T (p * q). Thus,

8q:8a; a0 2 A: a[R(p * q)]a0 ) f (c; a)[S(p * q)]f 0(c0; a0)
() (* the definition of R ) S)

(*a:f (c; a))\Theta (R ) S)(p)\Lambda (*a0:f 0(c0; a0))
() (* the definition of curry(f ))

curry(f )(c)\Theta (R ) S)(p)\Lambda curry(f 0)(c0)

What we have just proved shows that curry(f ) , curry(f 0).

Finally, we prove the preservation by the pairing into the small products. Consider
a family {(Ai; Ri)}i2I of objects in C. Pick two families of morphisms in C, {fi}i2I and
{f 0i }i2I , such that

8i 2 I: fi : (B; S) ! (Ai; Ri); f 0i : (B; S) ! (Ai; Ri); and fi , f 0i:
We need to show the following equivalence:i

*b : B:*i : I:fi(b)j , i*b0 : B:*i : I:f 0i(b0)j:
For all predicates p and all b; b0 in B such that b[S(p)]b0, we have that

8i 2 I: fi(b)[Ri(p)]f 0i (b0):
Thus,

(*i : I: fi(b))[(\Pi i2I Ri)(p)](*i : I: f 0i(b0)):

This relationship gives the required equivalence.

Lemma 4.6 ensures that taking a quotient of morphisms in C gives a well-defined category, which we call D. Category D inherits all the interesting structure of C by Lemma 4.6;
it is cartesian closed, has all small products, and has a functor inv0 : D * Pr ! D that preserves the CCC structure and the small products of D. Let E be the "quotienting"functor
from C to D, and tri0 : Pop * P ! D the composition of E with tri. We summarize the main
property of D in the following two lemmas:

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 19
Lemma 4.7. The category D is a CCC with all small products, and has two functors
inv0 : D * Pr ! D and tri0 : Pop * P ! D such that

(1) inv0(-; p) preserves all the CCC structure and the small products of D;
(2) inv0(-; p) ffi inv0(-; q) = inv0(-; p * q); and
(3) inv0(-; p) ffi tri0 = tri0(- * p; - * p).

Proof. First, we prove that D has all the small products. Let {(Ai; Ri)}i2I be a small family
of objects in D. We show that the product of this family is (\Pi i2I Ai; \Pi i2I Ri) and the i-th
projection is [ssi], where [f ] means the equivalence class of the morphism f . Consider an
arbitrary family {[fi] : (B; S) ! (Ai; Ri)}i2I of morphisms in D. This family induces some
family {fi}i2I in C. Since (\Pi i2I Ai; \Pi i2I Ri) is the product in C, there exists a morphism
hfiii2I : (B; S) ! (\Pi i2I Ai; \Pi i2I Ri) such that ssi ffi hfiii2I = fi for all i 2 I. The equivalence
class [hfiii2I ] of this morphism is the required unique morphism in D. It makes the required
diagrams for the products commute, because

8i 2 I: [ssi] ffi [hfiii2I ] = [ssi ffi hfiii2I ] = [fi]:
For the uniqueness, suppose that [k] is another morphism in D that makes the diagram
commutes. Then, [k] must be equal to [k] = [hfiii2I ], as shown below:

(8i 2 I: [ssi] ffi [k] = [fi]) () (8i 2 I: [ssi ffi k] = [fi]) (* , is preserved by ffi)

=) [hssi ffi kii2I ] = [hfiii2I ] (* , is preserved by the pairing)
() [k] = [hfiii2I ]:

Second, we show that D has the exponentials. Let ((A; R); (B; S)) be a pair of objects
in D. We prove that (A ) B; R ) S) is an exponential of this pair, and the evaluation
morphism is the equivalence class [ev]. Consider a morphism [f ] : (C; T ) * (A; R) ! (B; S)
in D. We need to prove that the universality requirement holds for [f ]: there exists a unique
morphism [g] : (C; T ) ! (A ) B; R ) S) in D such that

[f ] = [ev] ffi h[g] ffi [ss0]; [ss1]i:
The equation in the requirement implies that [g] should be equal to [curry(f )]:

[f ] = [ev] ffi h[g] ffi [ss0]; [ss1]i =) [f ] = [ev] ffi h[g ffi ss0]; [ss1]i (* the composition preserves ,)

=) [f ] = [ev] ffi [hg ffi ss0; ss1i] (* the pairing preserves ,)
=) [f ] = [ev ffi hg ffi ss0; ss1i] (* the composition preserves ,)
=) [curry(f )] = [curry(ev ffi hg ffi ss0; ss1i)] (* curry preserves ,)
=) [curry(f )] = [g]:

Thus, D has at most one morphism [g] that satisfies the universality requirement. We now
show that [curry(f )] satisfies the requirement. By the definition of curry, we have that

f = ev ffi hcurry(f ) ffi ss0; ss1i:
This equation implies that [curry(f )] makes the required diagram commute:

f = ev ffi hcurry(f ) ffi ss0; ss1i =) [f ] = [ev ffi hcurry(f ) ffi ss0; ss1i]

=) [f ] = [ev] ffi [hcurry(f ) ffi ss0; ss1i] (* ffi preserves ,)
=) [f ] = [ev] ffi h[curry(f ) ffi ss0]; [ss1]i (* pairing preserves ,)
=) [f ] = [ev] ffi h[curry(f )] ffi [ss0]; [ss1]i (* ffi preserves ,):

Finally, we prove the three properties of inv0. Note that the categories C and D have the
same collection of objects, and they have the same exponentials and same small products,
as far as the objects are concerned. Moreover, for objects, the functors inv0(-; p) and

20 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
inv(-; p) are identical. Thus, inv0(-; p) : D ! D preserves the exponential objects and
small product objects in D if and only if inv(-; p) preserves those in C; the right hand side
of this equivalence holds by Lemma 4.3. The functor inv0(-; p) also preserves [ev] and [ssi],
because inv0([f ]; p) = [inv(f; p)] = [f ]. So, inv0(-; p) preserves the CCC structure and the
small products.

For the second property of inv0, we note that the equation in the property holds for
the objects, because for all predicates r, functors inv0(-; r) and inv(-; r) behave the same
on the objects, and inv(-; p) ffi inv(-; q) = inv(-; p * q). The equation also holds for the
morphisms, because inv0([f ]; r) = [f ] for all f; r.

For the third property of inv0, we recall that tri0 = E ffi tri. Thus, it is sufficient to show
that

inv0(-; p) ffi E ffi tri = E ffi tri(- * p; - * p):

The equation holds for the objects; E is the identity on the objects, inv and inv0 are the
same for objects, and inv(-; p) ffi tri = tri(- * p; - * p). For the morphisms, the equation also
holds, because both sides of the equation map each morphism in Pop * P to the equivalence
class of an inclusion.

Lemma 4.8. The functor E from C to D is full, preserves the CCC structure as well as
small products, and makes the following diagrams commute:

C * Pr inv //
E*Id

fflffl

C

E
fflfflD * P

r

inv0 // D

Pop * P tri //

Id

fflffl

C

E
fflfflPop * P tri0
// D

Proof. The categories C and D have the same collection of objects, and their CCC structure
and small products are identical, as far as the objects are concerned. Since E is the identity
on objects, it preserves the exponential objects and small product objects. Moreover, E
preserves the evaluation and projection morphisms, because the evaluation and projection
morphisms in D are just the equivalence classes of the corresponding morphisms in C, and
E maps f to its equivalence class [f ]. Thus, functor E preserves the CCC structure and
the small products of C.

The commutative diagram for inv holds for the objects, because inv and inv0 behave the
same for the objects and E is the identity on the objects. To show that the diagram also
holds for the morphisms, we pick an arbitrary morphism (f; p v q) in C * Pr. Then,

(inv0 ffi (E * Id))(f; p v q) = inv0([f ]; p v q) = [f ] = (E ffi inv)(f; p v q):
Finally, the commutative diagram for tri0 is the definition of tri0, so it must hold.

4.2. Interpretation of the Language. We interpret the language in two steps. First,
we define the semantics [[-]]C in the family fibration Fam(C) ! Set. Each base set in the
fibration models all the possible environments for a fixed shape of the stack (i.e., a fixed
set of integer variables \Delta ). For instance, the object {(A; R)j }j2[[\Delta ]] assumes that all the
available integer variables are in \Delta , and it specifies a type dependent on the values of
such variables, given by j. The types and terms of our language are interpreted using the
categorical structure of the fibration. Next, we quotient the semantics [[-]]C to get more
abstract, official interpretation [[-]], which uses category D instead of C.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 21
4.2.1. Semantics [[-]]C in Fam(C) ! Set. The interpretation is explicit about the set of
variables under which we consider types, type assignments, and terms. Write \Delta  ` \Gamma  to
mean that \Delta  ` \Gamma (x) : Type, for all x in the domain of \Gamma .

The semantics of \Delta  ` `(: Type) and \Delta  ` \Gamma  is given by a family of objects in C indexed
by the environments in [[\Delta ]]. The precise definition of [[`]]C and [[\Gamma ]]C is given as follows: for
j in [[\Delta ]],

[[\Delta  ` {P }-{Q}]]Cj = tri([[\Delta  ` P ]]j; [[\Delta  ` Q]]j);

[[\Delta  ` ` \Omega  P ]]Cj = inv([[\Delta  ` `]]Cj ; [[\Delta  ` P ]]j);
[[\Delta  ` ` ! `0]]Cj = [[\Delta  ` `]]Cj ) [[\Delta  ` `0]]Cj ;

[[\Delta  ` \Pi i`]]Cj = \Pi n2Val [[\Delta  [ {i} ` `]]Cj[i!n];

[[\Delta  ` \Gamma ]]Cj = \Pi x2dom(\Gamma )[[\Delta  ` \Gamma (x)]]Cj :
Note that tri is used to interpret the triple type {P }-{Q}, and inv to interpret the invariant
extension ` \Omega  P .

Each subtype relation ` _\Delta  `0 is interpreted as a family of morphisms in C of the shape

{*x: x : [[\Delta  ` `]]Cj ! [[\Delta  ` `0]]Cj }j2[[\Delta ]]:
Note that every morphism in the family is implemented (or realized) by the identity function.
In order for this definition to typecheck, the underlying cpo of the source object [[`]]Cj should

be included in that of the target [[`0]]Cj , and the parameterized per of the source should imply
that of the target for all instantiations. In the lemma below, we prove that both of these
requirements hold.

Lemma 4.9. If a subtype relation ` _\Delta  `0 is derivable, then for all j in [[\Delta ]],

(1) objects [[\Delta  ` `]]Cj and [[\Delta  ` `0]]Cj have the same underlying cpo, and
(2) their per parts R and R0 satisfy that 8p: R(p) ` R0(p).

Proof. The proof proceeds by the induction on the derivation of ` _\Delta  `0. First, we consider
the base cases where ` _\Delta  `0 is proved by an axiom. In all the base cases except the generalized frame rule, objects [[`]]Cj and [[`0]]Cj are identical, because inv preserve all categorical
structure used to interpret types (Lemmas 4.3, 4.4 and 4.5). When ` _\Delta  `0 is derived by
the generalized frame rule, so that `0 = ` \Omega  P for some P , object [[`0]]Cj is inv([[`]]Cj ; [[P ]]j).
Thus, by the definition of inv, there exist A and R such that

[[`0]]Cj = (A; R([[P ]]j * -)) and [[`]]Cj = (A; R):
The above two equations show that [[`0]]Cj and [[`]]Cj have the same underlying cpo. They also
imply the requirement for the parameterized pers, because R(p) ` R(p*[[P ]]j) = R([[P ]]j *p)
for all p.

Second, we consider the case that Consequence is applied in the last step of the derivation. In this case, the derivation of ` _\Delta  `0 has the following shape:

8j0 2 [[\Delta ]]: [[P 0]]j0 ` [[P ]]j0 ^ [[Q]]j0 ` [[Q0]]j0

{P }-{Q} _\Delta  {P 0}-{Q0}
By the definition of the semantics of types, both [[{P }-{Q}]]Cj and [[{P 0}-{Q0}]]Cj have comm
as their underlying cpo. We will now show that their parameterised pers also satisfy the requirement in the lemma. Let R; R0 be parameterized pers of [[{P }-{Q}]]Cj and [[{P 0}-{Q0}]]Cj ,

22 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
respectively. Then, for all p and c0; c1 2 comm,

c0[R(p)]c1 () (8h 2 [[P ]]j*p*true: c0(h)=c1(h)) ^ (c0; c1 2 |R(p)|)

() (8h 2 [[P ]]j*p*true: c0(h)=c1(h)) ^ (8h 2 [[P ]]j*p: (c0(h); c1(h) ` [[Q]]*p))

=) (8h 2 [[P 0]]j*p*true: c0(h)=c1(h)) ^ (8h 2 [[P 0]]j*p: (c0(h); c1(h) ` [[Q0]]*p))
() (8h 2 [[P 0]]j*p*true: c0(h)=c1(h)) ^ (c0; c1 2 |R0(p)|)
() c0[R0(p)]c1:
The implication above uses the assumption that P 0 is the strengthening of P and Q0 is
the weakening of Q, and all the equivalences are simply the rolling or unrolling of some
definition. We have just shown that R(p) ` R0(p) for all p, as required.

Third, we consider the cases of inference rules for the type constructors, !, \Pi  and
\Omega . All these cases follow from the induction hypothesis and the definition of appropriate
functors, which are used to interpret !, \Pi  and \Omega . We illustrate this general pattern by
proving the case of !. Suppose that the last step of the derivation of ` _\Delta  `0 has the form:

`00 _\Delta  `0 `1 _\Delta  `01

`0 ! `1 _\Delta  `00 ! `01
For i = 0; 1, let (Ai; Ri) = [[`i]]Cj and (A0i; R0i) = [[`0i]]Cj . Then, by the induction hypothesis,
we have that

A00 = A0; A01 = A1; (8p: R00(p) ` R0(p)); and (8p: R1(p) ` R01(p)):
So, the underlying cpos of [[`0 ! `1]]Cj and [[`00 ! `01]]Cj are the same cpo of continuous
functions from A0 to A1. The remaining requirement is to show that (R0 ) R1)(p) `
(R00 ) R01)(p) for all p, and it is proved below:

f [(R0 ) R1)(p)]g () 8p0: f [R0(p*p0) ! R1(p*p0)]g (* Def. of R0 ) R1)

=) 8p0: f [R00(p*p0) ! R01(p*p0)]g (* 8q:R00(q)`R0(q) ^ R1(q)`R01(q))
() f [(R00 ) R01)(p)]g (* Def. of R00 ) R01):
Finally, we consider the inference rule for transitivity. Suppose that the last step of the
derivation of ` _\Delta  `0 has the form:

` _\Delta  `0 `0 _\Delta  `0

` _\Delta  `0
By the induction hypothesis, all of [[`]]Cj , [[`0]]Cj and [[`0]]Cj have the same underlying cpos. Let
R; R0; R0 be parameterized pers of [[`]]Cj , [[`0]]Ce ta and [[`0]]Cj , respectively. By the induction
hypothesis again, we have that

8p: R(p) ` R0(p) ` R0(p):
We have just shown that the lemma holds in this case.

Finally, we define the semantics of each typing judgment \Gamma  `\Delta  M : ` by an indexed
family of morphisms in C of the form:

{fj : [[\Delta  ` \Gamma ]]Cj ! [[\Delta  ` `]]Cj }j2[[\Delta ]]:

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 23
The semantics is given by induction on the derivation of the judgment, and it is shown in
Figure 6. The interpretation uses the categorical structure of C in a standard way. The
only specific parts are the interpretation of basic imperative operations, where we use six
basic semantic constants

skip; seq; new ; read ; free; and write;
which are also defined in the figure.

For this interpretation of terms, the question of well-definedness arises, because of the
introduction and elimination of dependent function type \Pi i`. The semantic definition of
*i:M assumes that if \Gamma  does not contain the variable i, it is interpreted as the same object
in C no matter how we change or even drop the value of i in the index. The definition
of [[M E]]C assumes that the reindexing precisely models the substitution. The following
lemmas show that these two assumptions indeed hold.

Lemma 4.10. If i 62 \Delta  and \Delta  ` `, then

8j 2 [[\Delta ]]: 8n 2 Val : [[\Delta  ` `]]Cj = [[\Delta  [ {i} ` `]]Cj[i!n]:

Proof. The lemma can be proved by straightforward induction on the structure of `. We
omit the details.

Lemma 4.11. If i 62 \Delta  and \Delta  ` P , then

8j 2 [[\Delta ]]: 8n 2 Val : [[\Delta  ` \Gamma ]]Cj = [[\Delta  [ {i} ` \Gamma ]]Cj[i!n]:

Proof. The lemma follows from Lemma 4.10, as shown below:

[[\Delta  [ {i} ` \Gamma ]]Cj[i7!n] = \Pi x2dom(\Gamma )[[\Delta  [ {i} ` \Gamma (x)]]Cj[i7!n]

= \Pi x2dom(\Gamma )[[\Delta  ` \Gamma (x)]]Cj (* Lemma 4.10)
= [[\Delta  ` \Gamma ]]Cj :

Lemma 4.12. If i 62 \Delta , \Delta  [ {i} ` `, and \Delta  ` E, then

8j 2 [[\Delta ]]: [[\Delta  ` `[E=i]]]Cj = [[\Delta  [ {i} ` `]]Cj[i![[E]]j]:

Proof. This lemma holds because the reindexing of the family fibration Fam (C) ! Set
preserves on the nose all the categorical structure that is used to interpret types. A more
concrete, direct proof can be obtained by induction on the structure of `. We omit the
details.

4.2.2. Semantics [[-]] in Fam(D) ! Set. The official semantics [[-]] of the language uses
the fibration Fam(D) ! Set, rather than Fam(C) ! Set. It is obtained by applying the
embedding functor E : C ! D to the semantics [[-]]C of the previous section. Concretely,
the semantics [[-]] is defined as follows: for all j 2 [[\Delta ]],

[[\Delta  ` `]]j = E([[\Delta  ` `]]Cj) = [[\Delta  ` `]]Cj;
[[\Delta  ` \Gamma ]]j = E([[\Delta  ` \Gamma ]]Cj ) = [[\Delta  ` \Gamma ]]Cj ;
[[` _\Delta  `0]]j = E([[` _\Delta  `0]]Cj );
[[\Gamma  `\Delta  M : `]]j = E([[\Gamma  `\Delta  M : `]]j):
Note that in the first two equations, we use the fact that E is the identity on objects.

24 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

[[\Gamma ; x : ` `\Delta  x : `]]Cj ae = ae(x)
[[\Gamma  `\Delta  *x : `:M : ` ! `0]]Cj ae = *c: [[\Gamma ; x : ` `\Delta  M : `0]]Cj (ae[x!c])

[[\Gamma  `\Delta  M M 0 : `]]Cj ae = ([[\Gamma  `\Delta  M : `0 ! `]]Cj ae) ([[\Gamma  `\Delta  M 0 : `0]]Cj ae)
[[\Gamma  `\Delta  *i:M : \Pi i`]]Cj ae = *n: [[\Gamma  `\Delta [{i} M : `]]Cj[i!n]ae
[[\Gamma  `\Delta  M E : `[E=i]]]Cj ae = ([[\Gamma  `\Delta  M : \Pi i`]]Cj ae) ([[E]]j )

[[\Gamma  `\Delta  M : `0]]Cj ae = ([[` _\Delta  `0]]Cj ) ([[\Gamma  `\Delta  M : `]]Cj ae)
[[\Gamma  `\Delta  fix M : `]]Cj ae = lfix ([[\Gamma  `\Delta  M : ` ! `]]Cj ae)
[[\Gamma  `\Delta  ifz E M M 0 : {P }-{Q}]]Cj ae = if ([[\Delta  ` E]]j = 0)

then [[\Gamma  `\Delta  M : {P ^ E=0}-{Q}]]Cj ae
else [[\Gamma  `\Delta  M 0 : {P ^ E6=0}-{Q}]]Cj ae
[[\Gamma  `\Delta  M ; M 0 : {P }-{Q}]]Cj ae = seq ([[\Gamma  `\Delta M :{P }-{P 0}]]Cj ae;

[[\Gamma  `\Delta M 0:{P 0}-{Q}]]Cj ae)
[[\Gamma  `\Delta  skip : {P }-{P }]]Cj ae = skip (?)

[[\Gamma  `\Delta  let i=new in M : {P }-{Q}]]Cj ae = new (*n: [[\Gamma  `\Delta [{i}M :{i7!-*P }-{Q}]]Cj[i!n]ae)
[[\Gamma  `\Delta let i=[E] in M :{9i:E7!i*P }-{Q}]]Cj ae = read ([[\Delta  ` E]]j)

(*n: [[\Gamma  `\Delta [{i}M :{E7!i*P }-{Q}]]Cj[i!n]ae)

[[\Gamma  `\Delta  free(E) : {E7!-}-{emp}]]Cj ae = free ([[\Delta  ` E]]j) (?)
[[\Gamma  `\Delta  [E]:=E0 : {E7!-}-{E7!E0}]]Cj ae = write ([[\Delta  ` E]]j; [[\Delta  ` E0]]j) (?)

where skip, seq, new , read (m), free(m), and write(m; m0) are the following morphisms in

C:

m7!- 2 Pred def= {[m!n] | n 2 Val } m7!n 2 Pred def= {[m!n]}

skipp : 1 ! tri(p; p)
skipp def= *x: *h:{h}

seqp;p0;q : tri(p; p0) * tri(p0; q) ! tri(p; q)

seq def= *(c; c0): *h: {wrong | wrong 2 c(h)} [ S{c0(h0) | h0 2 c(h)}

new p;q : (\Pi n2Val tri(n7!- * p; q)) ! tri(p; q)

new def= *c: *h: S{c(n)([n!n0] * h) | n; n0 2 Val ^ n 62 dom(h)}

read (m)({pn}n;q) : (\Pi n2Val tri(m7!n * pn; q)) ! tri(S{m7!n * pn | n 2 Val }; q)

read (m) def= *c: *h: if m 2 dom(h) then c(h(m))(h) else {wrong }

free(m) : 1 ! tri(m7!-; emp)
free(m) def= *x: *h: if m 2 dom(h) then {h[m!undef ]} else {wrong }

write(m; m0) : 1 ! tri(m7!-; m7!m0)
write(m; m0) def= *x: *h: if m 2 dom(h) then {h[m!m0]} else {wrong }

Figure 6: Interpretation of Terms

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 25
We point out that [[-]] can be presented in a compositional style, using the categorical
structure of the fibration Fam(D) ! Set.6 In that presentation, the types are interpreted
using exponentials, small products, inv0 and tri0 for D; and the terms are interpreted by appropriate categorical combinators and the embedding of the six constants in Figure 6. This
direct definition of [[-]] is identical to the semantics in this section, because the embedding
functor E preserves all the relevant categorical structure (Lemma 4.8).

4.3. Adequacy. Our semantics of terms needs further justification in two ways. First,
the interpretation of a typing judgment needs to be shown coherent. The interpretation is
defined over a proof derivation of the judgment, so two different derivations of the same
judgment might have different denotations. This is troublesome for us especially, because
our goal is to give a semantics of a programming language with a separation-logic type
system, instead of a semantics of a proof in separation logic. Second, the connection with
the standard semantics needs to be provided. Our semantics uses subsumption which never
arises in the standard interpretation. Thus, it could be substantially different from the
standard interpretation. In this section, we provide justification for both of these two
issues.

We consider another interpretation [[-]]CPO of our language, called standard interpretation, which ignores all assertions in the types. In the standard interpretation, {P }-{Q}
means the same thing no matter what P and Q are, and for all P , ` \Omega  P and ` have
identical interpretations. Let tri00 be the constant functor from Pop * P to CPO such that
tri00(p; q) = comm, and let inv00 be a functor given by the first projection from CPO * Pr to
CPO. The standard interpretation is the interpretation in Section 4.2.1, where we use CPO,
tri00 and inv00 instead of C, tri and inv. It interprets types and type assignments just like the
interpretation in Section 4.2.1, but it uses functors on CPO, instead of those on C.

Lemma 4.13. If a subtype relation ` _\Delta  `0 is derivable, then ` and `0 have the identical
denotation in the standard interpretation.

Proof. We prove the lemma by induction on the derivation of the subtype relation ` _\Delta  `0.
First, we consider the case that the subtype relation is derived by an axiom. In all six
axioms, ` and `0 are both Hoare-triple types, or they are different only for the invariant
added by \Omega . Note that in the standard interpretation, all triple types mean the same cpo
comm and the added invariants by \Omega  are ignored. Thus, we have that [[`]]CPOj = [[`0]]CPOj for
all environments j 2 [[\Delta ]]. Next, we consider the cases where some inference rule is applied
at the last step of the derivation. Pick an environment j in [[\Delta ]]. If the last rule in the
derivation is Consequence, both ` and `0 are Hoare-triple objects, so [[`]]CPOj and [[`0]]CPOj are
the same cpo comm. If the last applied rule is an inference rule other than Consequence,
[[`]]CPOj and [[`0]]CPOj are obtained by applying the same functor on the denotations of their
subparts. By applying the induction hypothesis to these subparts, we can prove the lemma.
For instance, if the last applied rule is the structural rule for !, there are `0; `00; `1; `01 such
that

` = `0 ! `1; ` = `00 ! `01; `00 _\Delta  `0; and `1 _\Delta  `01:

By the induction hypothesis, [[`i]]CPOj = [[`0i]]CPOj for i = 0; 1. This implies that [[`]]CPOj and
[[`]]CPOj are identical.

6The conference version of this paper defined [[-]] in such a style.

26 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

The standard interpretation defines the meaning of typing judgments \Gamma  `\Delta  M : `,
by repeating the clauses in Figure 6. Although the interpretation is given inductively
on the typing derivation, Lemma 4.13 ensures that [[\Gamma  `\Delta  M : `]]CPO does not depend on
derivations, because it guarantees that [[` _\Delta  `0]]CPO is the identity morphism. As usual, we
can give the operational semantics, and prove the computational adequacy of the standard
interpretation. Since this is completely standard, we omit it.

The standard interpretation is closely related to the semantics [[-]]C in Section 4.2.1.
Note that from the category C to CPO, there is a forgetful functor F that maps an object
(A; R) to A, and a morphism f to f . This forgetful functor preserves all the categorical
structure of C that we use to interpret the types of our language:

Lemma 4.14. F is a faithful functor that preserves the CCC structure and the small
products of C, and makes the following diagrams commute.

C * Pr inv //
F *Id

fflffl

C

F
fflfflCPO * P

r

inv00 // CPO

Pop * P tri //

Id

fflffl

C

F
fflfflPop * P tri00
// CPO

Proof. First, we prove that the forgetful functor F preserves the exponentials and small
products of C. For this, it is sufficient to prove the preservation of four elements: exponential objects, small product objects, evaluation morphisms, and projection morphisms. Note
that both the CCC structure and small products of C are defined using the corresponding
structure of CPO; the first components of exponential objects and small product objects
of C are defined by exponential objects and small product objects of CPO, and evaluation
morphisms and projection morphisms in C are precisely evaluation morphisms and projection morphisms in CPO. Since F projects the first component of each object in C and maps
each morphism in C to itself, it preserves the required four elements. For instance, for all
objects (A; R); (B; S) in C, the first component of their exponential (A; R) ) (B; S) is the
cpo A ) B of continuous functions from A to B, which is precisely the exponential of A
and B in CPO. Thus, F ((A; R) ) (B; S)) is F (A) ) F (B).

Next, we prove that the diagram for inv and inv00 commutes. Since inv00 is the projection
of the first component, inv00 ffi (F * Id) is F ffi fst. So, it suffices to show that F ffi fst = F ffi inv.
Consider objects ((A; R); p), ((B; S); q) and a morphism (f; p v q) : ((A; R); p) ! ((B; S); q)
in C * Pr. Then,

(F ffi inv)((A; R); p) = F (A; R(p * -)) = A = (F ffi fst)((A; R); p); and
(F ffi inv)(f; p v q) = F (f ) = f = (F ffi fst)(f; p v q):

Thus, F ffi fst = F ffi inv, as required.

Finally, we prove the commutative diagram for tri and tri00. Consider objects (or predicate pairs) (p; q); (p0; q0) and a morphism (p0 ` p; q ` q0) : (p; q) ! (p0; q0) in Pop * P.
Then,

(F ffi tri)(p; q) = F ([p; q]) = comm and (F ffi tri)(p0 ` p; q ` q0) = id:
Thus, F ffi tri is the constant functor to comm, so it is identical to tri00.

Lemma 4.14 implies that the interpretation of types in CPO factors through the interpretation in C. The following lemma show that the interpretation of terms has a similar
property.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 27
Proposition 4.15. The functor F : C ! CPO preserves the interpretation of terms: for all
typing judgments \Gamma  `\Delta  M : ` and all j 2 [[\Delta ]],

F ([[\Gamma  `\Delta  M : `]]Cj ) = [[\Gamma  `\Delta  M : `]]CPOj :

Proof. Pick an arbitrary j 2 [[\Delta ]] and choose any ae0 2 [[\Gamma ]]CPOj . Then,

F ([[\Gamma  `\Delta  M : `]]Cj )(ae0) = [[\Gamma  `\Delta  M : `]]Cj ae0;
because F (f ) only changes the "type" of f , not the implementation of f . Thus, it is
sufficient to show that

8j; ae0: [[\Gamma  `\Delta  M : `]]Cj ae0 = [[\Gamma  `\Delta  M : `]]CPOj ae0:

We prove this equality by induction on the derivation of \Gamma  `\Delta  M : `. Since [[-]]CPO and
[[-]] use the same clauses to define the meaning of \Gamma  `\Delta  M : `, the induction easily goes
through in all cases. For instance, consider the case where the subsumption rule is applied
at the last step of the derivation. For all environments j 2 [[\Delta ]] and all ae0 2 [[\Gamma ]]CPOj ,

[[\Gamma  `\Delta  M : `]]Cj ae0 = [[`0 _\Delta  `]]Cj ([[\Gamma  `\Delta  M : `0]]Cj ae0)

= [[\Gamma  `\Delta  M : `0]]Cj ae0 (* [[`0 _\Delta  `]]Cj x = x)
= [[\Gamma  `\Delta  M : `0]]CPOj ae0 (* Induction Hypothesis)
= ([[`0 _\Delta  `]]CPOj ) ffi ([[\Gamma  `\Delta  M : `0]]CPOj ae0) (* [[`0 _\Delta  `]]CPOj x = x)
= [[\Gamma  `\Delta  M : `]]CPOj :

Recall that the official semantics [[-]] of our language is obtained by applying the full
functor E to the semantics [[-]]C, and that the functor F is faithful. Together with these
facts, Lemma 4.14 and Proposition 4.15 show that the official semantics [[-]] is obtained from
the standard interpretation [[-]]CPO by first selecting some elements, and then quotienting
those selected elements.

Corollary 4.16. The semantics [[-]] is coherent: the semantics of a typing judgment does
not depend on derivations.

Proof. Let P1 and P2 be two derivations of a judgment \Gamma  `\Delta  M : `. We note that the
standard semantics is coherent; only the subsumption rule is not syntax-directed, but in
the standard semantics, this rule does not contribute to the interpretation, because all
the subtype relations ` _\Delta  `0 denote the family of identity morphisms. Thus, for all
environments j 2 [[\Delta ]], we have

[[P1]]CPOj = [[P2]]CPOj :
Then, by Proposition 4.15 and the faithfulness of F ,

[[P1]]CPOj = [[P2]]CPOj =) F ([[P1]]Cj ) = F ([[P2]]Cj )

=) [[P1]]Cj = [[P2]]Cj (* F is faithful)
=) E([[P1]]Cj ) = E([[P2]]Cj )
=) [[P1]]j = [[P2]]j (* Definition of [[-]]):

28 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

5. Conjunction Rule
The conjunction rule is often omitted from Hoare logic, but it is a useful proof rule that
lets one combine two Hoare triples about a single command. In our type system, it can be
expressed as follows:

\Gamma  `\Delta  M : {P }-{Q} \Gamma  `\Delta  M : {P 0}-{Q0}

\Gamma  `\Delta  M : {P ^ P 0}-{Q ^ Q0}
Unfortunately, we cannot immediately include the conjunction rule in our type system. In [9], Reynolds has proved that if a proof system contains the conjunction rule
and the second-order frame rule, together with Consequence and the ordinary (first-order)
frame rule, then the system becomes inconsistent. More specifically, Reynolds's result implies that once the conjunction rule is added to our type system, we can derive `{} skip :
{(9x; y:x7!y) * true}-{false}, which incorrectly expresses that skip diverges when the input
heap is not empty.

In the case of the second-order frame rule, several solutions have been proposed to
overcome this problem. In this section we adopt one of the proposals, modify the separationlogic type system accordingly, and extend the modified system with the conjunction rule.
Then, we define an adequate semantics of the new type system, thereby showing that all
the higher-order frame rules can be used with the conjunction rule, as long as the frame
rules add only precise invariants.

We recall the definition of precise predicates in separation logic [9]. A predicate p is
precise if and only if for every heap h, there is at most one subheap h0 of h (i.e., h0 * h1 = h
for some h1) such that h0 2 p. We also call an assertion \Delta  ` P precise when [[P ]]j is a
precise predicate for all j 2 [[\Delta ]].

The proposal that we use is to restrict the second-order frame rule such that it is used
with only precise assertions. We adopt the proposal in our separation-logic type system by
limiting the second parameter of the type constructor \Omega  to precise assertions. Note that
in the resulting restricted type system, only precise assertions can be added as invariants,
because the generalized frame rule ` _\Delta  ` \Omega  P is applicable only with a precise assertion P .
Thus, the second or third order frame rule can add only precise assertions as invariants. We
may then extend the restricted type system with the conjunction rule. Note that the result
of this extension, denoted T, includes the conjunction rule and all (restricted) higher-order
frame rules. In the remainder of this section, we focus on giving an adequate semantics of
T.

Before giving the semantics of T, we point out that requiring invariants to be precise
is not as restrictive as it seems; all the examples in Section 3.1 use precise invariants only,
so they typecheck in T.

The semantics of the type system T is given by categories C0 and D0. The category C0
is identical to C, except that the per component of each object is parameterized by precise
predicates, instead of all predicates. An object in C0 is a pair of cpo A and parameterized
per R, such that (1) the parameterization of R is over precise predicates, and (2) for all
precise predicates p; q, the per R(p) implies R(p * q), i.e., R(p) ` R(p * q). A morphism
f : (A; R) ! (B; S) in C0 is a continuous function ?From A to B that maps R(p)-related
elements to S(p)-related elements for all precise p. The other category D0 is constructed
by quotienting morphisms in C0, in the same way as D is constructed from C.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 29
The categories C0 and D0 have all the categorical structure that we have used in the
semantics in Section 4. They are cartesian closed categories with all the small products, and
they have functors for invariant extension and Hoare triples. The only subtlety is that the
preorder Pr, which is used for functors for invariant extension in Section 4, is now replaced
by the preorder of precise predicates with the following order vp: for all precise predicates
p; q,

p vp q () there exists a precise r such that p * r = q:

This categorical structure is preserved by the functors for invariant extension, the forgetful
functor F0 : C0 ! CPO, and the quotienting functor E0 : C0 ! D0, in the way expressed by
Lemmas 4.3, 4.14, and 4.8. All the definitions and results in Section 4.2 and 4.3 can easily
be transferred to C0 and D0, as long as they are concerned with T without the conjunction
rule. We now explain how to soundly interpret the conjunction rule.

Define a continuous function con from comm * comm to comm as follows:

wrong 2 con(c; c0)(h) () wrong 2 c(h) [ c0(h)

h0 2 con(c; c0)(h) () h0 2 c(h) " c0(h)

Function con is the key element in our interpretation of the conjunction rule. Intuitively,
con(c; c0) is a command that is better than c and c0: it satisfies more Hoare triples than
c and c0, as long as we consider triples with sufficiently strong preconditions, those which
ensure that both c and c0 run without generating wrong .

Lemma 5.1. Function con is well-defined. In particular, for all (c; c0) 2 comm * comm,
con(c; c0) satisfies the safety monotonicity and frame property.

Proof. The continuity follows from the fact that con(c; -) and con(-; c) preserve arbitrary
nonempty unions. Here we focus on proving that con is a well-defined function. Pick
(c; c0) 2 comm * comm. To prove that con(c; c0) 2 comm, we should show that con(c; c0)
satisfies the safety monotonicity and the frame property.

* Safety Monotonicity: Consider heaps h0; h1 such that wrong 62 con(c; c0)(h0) and

h0#h1. Then, wrong is neither in c(h0) nor in c0(h0). Thus, by the safety monotonicity of c and c0, we have that wrong 62 c(h0 * h1) and wrong 62 c0(h0 * h1). This
implies that wrong 62 con(c; c0)(h0 * h1), as required.

* Frame Property: Suppose that h0#h1, wrong 62 con(c; c0)(h0), and h0 2 con(c; c0)(h0*

h1). Note that while proving the previous item, we have shown two facts: (1)
con(c; c0)(h0 * h1) does not contain wrong , and (2) neither c(h0) nor c0(h0) contains
wrong . The first fact implies that con(c; c0)(h0 * h1) = c(h0 * h1) " c0(h0 * h1), because
by the definition of con,

c(h0 * h1) " c0(h0 * h1) ` con(c; c0)(h0 * h1)

` \Gamma c(h0 * h1) " c0(h0 * h1)\Delta  [ {wrong }:

Since h0 is in con(c; c0)(h0 * h1) and con(c; c0)(h0 * h1) = c(h0 * h1) " c0(h0 * h1), heap
h0 is in c(h0 * h1) as well as in c0(h0 * h1). Moreover, by the second fact proved in the
previous item, wrong 62 c(h0) and wrong 62 c0(h0). Thus, we can apply the frame
property of c and c0 here. Once the property is applied, we obtain subheaps h00; h000
of h0 such that

h00 * h1 = h000 * h1 = h0 ^ h00 2 c(h0) ^ h000 2 c0(h0):

30 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG

Note that the equalities force h00 and h000 to be the same. So, h00 should be in
c(h0) " c0(h0) = con(c; c0)(h0). We have just proved that h00 is the heap required by
the frame property of con(c; c0).

For all predicates p; q, define an object [p; q] in C0 just like the corresponding triple
object in C, except that the second component of [p; q] is a family of pers indexed by precise
predicates. The following lemma expresses that con properly models a semantic version of
the conjunction rule in C0.

Lemma 5.2. For all predicates p; q; p0; q0, function con is a morphism in C0 that has type
[p; q] * [p0; q0] ! [p " p0; q " q0].

Proof. Let R; S; T be pers parameterized by precise predicates, such that

(comm; R) = [p; q]; (comm; S) = [p0; q0]; and (comm; T ) = [p " p0; q " q0]:
Because of Lemma 5.1, con is a well-defined continuous function from comm * comm to
comm. Thus, it suffices to show that for all precise predicates r,

con[R(r) * S(r) ! T (r)]con:
Consider precise predicate r, and command pairs (c0; c00); (c1; c01), such that

(c0; c00)[R(r) * S(r)](c1; c01):
First, we show that con(c0; c00) and con(c1; c01) are in the domain of per T (r). We focus on
con(c0; c00), because con(c1; c01) 2 |T (r)| can be proved similarly. Pick a heap h in (p " p0) * r.
Then, h is in p * r and p0 * r. Note that c0 and c00 are in |R(r)| and |S(r)|, and R and S
are the per components of [p; q] and [p0; q0]. Thus, neither c0(h) nor c00(h) contains wrong ,
c0(h) ` q * r, and c00 ` q0 * r. Thus,

con(c0; c00)(h) = c0(h) " c00(h) ` p * r " q0 * r = (p " q0) * r:
The first equality follows from the definition of con, because wrong 62 c0(h) and wrong 62
c00(h). And the last equality holds, because for all precise predicates r0, - * r0 distributes
over ".

Next, we show that con(c0; c00) and con(c1; c01) are T (r)-related. Since both con(c0; c00)
and con(c1; c01) are in |T (r)|, it is enough to prove that

8h 2 (p " p0) * r * true: con(c0; c00)(h) = con(c1; c01)(h):
Pick h from (p " p0) * r * true . Then, h 2 p * t * true and h 2 p0 * t * true . Since c0[R(p)]c1 and
c00[S(p)]c01, these two membership relations of h imply that none of c0(h); c1(h); c00(h); c01(h)
contains wrong , c0(h) = c1(h), and c00(h) = c01(h). Thus,

con(c0; c00)(h) = c0(h) " c00(h) = c1(h) " c01(h) = con(c1; c01)(h):
Since none of c0(h); c1(h); c00(h); c01(h) contains wrong , the first and last equalities follow
from the definition of con.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 31
The conjunction rule

\Gamma  `\Delta  M : {P }-{Q} \Gamma  `\Delta  M : {P 0}-{Q0}

\Gamma  `\Delta  M : {P ^ P 0}-{Q ^ Q0}
is now interpreted as follows:

[[\Gamma  `\Delta  M : {P ^ P 0}-{Q ^ Q0}]]Xj = con0 ffih[[\Gamma  `\Delta  M : {P }-{Q}]]Xj ; [[\Gamma  `\Delta  M : {P 0}-{Q0}]]Xj i
where X is C0, D0 or CPO. The standard semantics in CPO and the filtering semantics in
C0 uses con for con0, and in a direct-style presentation, the quotienting semantics in D0 uses
the equivalence class [con] for con0. Note that in the standard semantics, the conjunction
rule is interpreted as the identity, because con ffi hf; f i = f , for all morphisms f in CPO.

Since E0 and F 0 preserve the semantic entities for con0, they preserve the interpretation
of terms in the three semantics. ?From this preservation, the coherence of the quotienting
semantics follows. Moreover, since the conjunction rule means the identity in the standard
semantics, the preservation of interpretations also implies that the conjunction rule is always
implemented by the identity function in all three semantics, thereby reflecting the fact that
the rule does not have any computational meaning.

6. Related Work
The (first order) frame rule was discovered in the early days of separation logic [5], and
it was a main reason for the success of that logic. For example, it was vital in the proofs
of garbage collection algorithms in [21] and [4]. Recently, the second-order frame rule,
which allows reasoning about simple first-order modules, was discovered [9]. This naturally
encouraged the question of whether there are more general frame rules that apply to higher
types.

Other type systems which track state changes have been proposed in the work on typed
assembly languages [7, 2, 20]. Their main focus is to obtain sound rules for proving the safety
of programs. Thus, they mostly use easy-to-define conventional operational semantics, and
prove the soundness of the proof system syntactically (i.e., by subject reduction and progress
lemmas), or "logically" [20]: each type is interpreted as a subset of a single universe of
"meanings," and a typing judgment is interpreted as a specification for the behavior of
programs, like a Hoare triple in separation logic. Our separation-logic type system is more
refined in that it allows the full power of separation logic in the types and, moreover, we
also treat higher-order procedures.

The semantics of idealized algol has been studied intensively [11, 18, 10, 14]. Normally,
the semantics is parameterized by the shape of the memory. The indexing in the fibration
in our semantics follows this tradition, and it models the shape of the stack. However, the
other indexing of our semantics, the indexing by invariant predicates over heaps, has not
been used in the literature before.

The construction of the category D is an instance of the Kripke quotient by Mitchell
and Moggi [6]. The families of pers in D form a Kripke logical relation on CPO indexed
by the preorder category Pr; our condition on each family ensures that the requirement
of Kripke monotonicity holds. This Kripke logical relation produces D by Mitchell and
Moggi's construction.

The idea of proving coherence by relating two languages comes from Reynolds [19].
Reynolds proved the coherence of the semantics of typed lambda calculus with subtyping, by

32 L. BIRKEDAL, N. TORP-SMITH, AND H. YANG
connecting it with the semantics of untyped lambda calculus. We use the general direction
of Reynolds's proof, but the details of our proof are quite different from Reynolds's, because
we consider very different languages.

7. Conclusion and Future Directions
We have presented a type system for idealized algol extended with heaps that includes
separation-logic specifications as types and, moreover, defined the coherent semantics of
idealized algol typed with this system.

One shortcoming of our type system is that the higher-order frame rules in the system
allow only static modularity [12]. With the higher-order frame rules alone, we cannot
capture all the the information hiding aspect of dynamically allocated data structures as
needed for modeling abstract data types. However, it is well-known that abstract data
types can be modeled using existential types and we are currently considering to enrich
the assertion language with predicate variables, as in the recently introduced higher-order
version of separation logic [3], and to extend the types with dependent product and sums
over predicates.

Yet another future direction is to define a parametric model. Uday Reddy pointed out
that separation-logic types should validate stronger reasoning principles for data abstraction
than ordinary types, because they let us control what clients can access more precisely.
Formalizing his intuition is the goal of the parametricity semantics. We currently plan to
use category C0 which replaces each predicate-indexed family of pers in C by a relationindexed family of saturated relations: an object in C0 is a cpo paired with a family T of
binary relations such that (1) T is indexed by a "typed" relation r : p $ q on heaps (i.e.,
r ` p * q); (2) for each predicate p, T at the diagonal relation \Delta p is a per; (3) for all
r : p $ q, T (r) is a saturated relation between pers T (\Delta p) and T (\Delta q); (4) T (r) ` T (r * r0).
The morphisms in C0 are continuous functions that preserve the families of relations. This
category has all the categorical structure of C that we used in the semantics of this paper.
However, it is difficult to interpret the triple types such that the memory allocator new lives
in the category. Overcoming this problem will be the focus of our research in this direction.

Finally, we would like to extend the relational separation logic [22] to higher-order, following the style of system R [1], and we want to explore the Curry-Howard correspondence
of our type system with specification logic [15].

Acknowledgements
We have benefitted greatly from discussions with Uday Reddy, Peter O'Hearn, and
David Naumann. We would like to thank anonymous referees and Rasmus Lerchedahl
Petersen for providing useful suggestions, which in particular helped us to improve the
presentation of the paper. Yang was supported by grant No. R08-2003-000-10370-0 ?From
the Basic Research Program of the Korea Science & Engineering Foundation. Yang, Birkedal
and Torp-Smith were supported by Danish Technical Research Council Grant 56-00-0309.

SEMANTICS OF SEPARATION-LOGIC TYPING AND HIGHER-ORDER FRAME RULES 33

References
[1] M. Abadi, L. Cardelli, and P.-L. Curien. Formal parametric polymorphism. Theoretical Comput. Sci.,

121(1-2):9-58, December 1993.
[2] A. Ahmed, L. Jia, and D. Walker. Reasoning about hierarchical storage. In Proc. of LICS'03, 2003.
[3] B. Biering, L. Birkedal, and N. Torp-Smith. BI-hyperdoctrines and higher order separation logic. In

Proc. of ESOP'05, Edinburgh, Scotland, April 2005.
[4] L. Birkedal, N. Torp-Smith, and J. C. Reynolds. Local reasoning about a copying garbage collector. In

Proc. of POPL'04, pages 220 - 231, Venice, Italy, 2004.
[5] S. Ishtiaq and P. W. O'Hearn. BI as an assertion language for mutable data structures. In Proc. of

POPL'01, 2001.
[6] J. C. Mitchell and E. Moggi. Kripke-style models for typed lambda calculus. Annals of Pure and Appl.

Logic, 51:99-124, 1991.
[7] G. Morrisett, D. Walker, K. Crary, and N. Glew. From system F to typed assembly language. ACM

Trans. Program. Lang. and Syst., 21(3):527 - 568, 1999.
[8] P. W. O'Hearn, H. Yang, and J. C. Reynolds. Local reasoning about programs that alter data structures.

In Proc. of CSL'01, pages 1 - 19, Paris, France, September 2001.
[9] P. W. O'Hearn, H. Yang, and J. C. Reynolds. Separation and information hiding. In Proc. of POPL'04,

pages 268 - 280, Venice, Italy, 2004.
[10] Peter W. O'Hearn and Robert D. Tennent. Parametricity and local variables. J. ACM, 42(3):658-709,

1995.
[11] F. J. Oles. A Category-Theoretic Approach to the Semantics of Programming Languages. PhD thesis,

Syracuse University, 1982.
[12] M. Parkinson and G. Bierman. Separation logic and abstraction. In Proc. of POPL'05, Long Beach,

CA, USA, January 2005.
[13] B. Pierce. Types and Programming Languages. MIT Press, 2002.
[14] U. Reddy and H. Yang. Correctness of data representations involving heap data structures. Science of

Computer Programming, 50(1):129 - 160, March 2004.
[15] J. C. Reynolds. Idealized Algol and its specification logic. In D. Neel, editor, Tools and Notions for

Program Construction, pages 121-161. Cambridge University Press, 1982.
[16] J. C. Reynolds. Intuitionistic reasoning about shared mutable data structure. In J. Davies, B. Roscoe,

and J. Woodcock, editors, Millennial Perspectives in Computer Science, pages 303-321. Palgrave,
Houndsmill, Hampshire, 2000.
[17] J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In Proc. of LICS'02, pages

55 - 74, Copenhagen, Denmark, 2002.
[18] John C. Reynolds. The essence of Algol. In J. W. de Bakker and J. C. van Vliet, editors, Algorithmic

Languages, pages 345-372. North-Holland, 1981.
[19] John C. Reynolds. The meaning of types -- from intrinsic to extrinsic semantics. Research Series

RS-00-32, BRICS, DAIMI, Department of Computer Science, University of Aarhus, December 2000.
http://www.brics.dk/RS/00/32/.
[20] G. Tan, A. W. Appel, K. N. Swadi, and D. Wu. Construction of a semantic model for a typed assembly

language. In Proc. of VMCAI '04, January 2004.
[21] H. Yang. Local Reasoning for Stateful Programs. PhD thesis, University of Illinois, Urbana-Champaign,

2001.
[22] H Yang. Relational separation logic. Submitted to Theoretical Comput. Sci., October 2004.
[23] Hongseok Yang. Local Reasoning for Stateful Programs. PhD thesis, University of Illinois at UrbanaChampaign, 2001. (Technical Report UIUCDCS-R-2001-2227).
[24] Hongseok Yang and Peter W. O'Hearn. A semantic basis for local reasoning. In Proceedings of the 5th

Conference on Foundations of Software Science and Computation Structures, volume 2303 of Lecture
Notes in Computer Science, pages 402-416. Springer-Verlag, April 2002.

This work is licensed under the Creative Commons Attribution-NoDerivs License. To viewa copy of this license, visit

http://creativecommons.org/licenses/by-nd/2.0/ or send aletter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.