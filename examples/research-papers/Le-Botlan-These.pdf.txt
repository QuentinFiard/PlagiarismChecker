

Anne'e : 2004N
o attribue' par la bibliothe`que

THE`SE

pre'sente'e a`
l'E'COLE POLYTECHNIQUE

pour obtenir le titre de
DOCTEUR EN SCIENCES

Spe'cialite'
Informatique

soutenue par
Didier Le Botlan

le 06/05/2004

Titre
MLF : Une extension de ML avec

polymorphisme de second ordre

et instanciation implicite.

Directeur de the`se : Didier Re'my

INRIA Rocquencourt

Jury
Directeur Didier Re'my
Rapporteurs Benjamin Pierce

Jacques Garrigue

Pre'sident Roberto Di Cosmo
Examinateurs Claude Kirchner

Dale Miller

2

2

3
Abstract
We propose a type system MLF that generalizes ML with first-class polymorphism as
in System F. Expressions may contain second-order type annotations. Every typable
expression admits a principal type, which however depends on type annotations. Principal types capture all other types that can be obtained by implicit type instantiation
and they can be inferred.

All expressions of ML are well-typed without any annotations. All expressions of
System F can be mechanically encoded into MLF by dropping all type abstractions
and type applications, and injecting type annotations of lambda-abstractions into MLF
types. Moreover, only parameters of lambda-abstractions that are used polymorphically
need to remain annotated.

Keywords:
Type Inference, First-Class Polymorphism, Second-Order Polymorphism, System F,
ML, Type Annotations.

Re'sume'

Nous nous inte'ressons a` une extension de ML avec polymorphisme de premie`re
classe, a` la manie`re du Syste`me F. Cette extension, nomme'e MLF, utilise les annotations de types d'ordre supe'rieur donne'es explicitement dans le programme pour infe'rer
de manie`re principale le type le plus ge'ne'ral. Toute expression admet ainsi un type
principal, qui de'pend des annotations pre'sentes initialement dans le programme.

Toute expression de ML est typable dans MLF sans annotation supple'mentaire. Les
expressions du Syste`me F sont encode'es de manie`re syste'matique dans MLF en supprimant les abstractions et les applications de types, et en traduisant les annotations de
types dans le langage de types de MLF. De plus, les parame`tres de lambda-abstractions
qui ne sont pas utilise's de manie`re polymorphe n'ont pas besoin d'e^tre annote's.

Mots Clefs

Infe'rence de types, Polymorphisme de premie`re classe, Polymorphisme d'ordre deux,
Syste`me F, ML, Annotations de type

This document is the "french" version of the thesis : the main introduction and the
introductions to chapters are written in french. A full english version is also available as
an INRIA technical report. Please look at http://www.inria.fr/rrrt/index.en.html

3

4
4
TABLE DES MATIE`RES 5
Table des matie`res

Abstract / Re'sume' 3

Introduction 11
Conventions 35

I Les Types 37
1 Types, pre'fixes et relations sous pre'fixe 39

1.1 Syntaxe des types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
1.2 Pre'fixes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
1.3 Occurrences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

1.3.1 Les squelettes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
1.3.2 Les projections . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
1.3.3 Variables libres et variables non lie'es . . . . . . . . . . . . . . . . 43
1.3.4 Renommages et substitutions . . . . . . . . . . . . . . . . . . . . 44
1.4 Relations sous pre'fixe . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
1.5 La relation d'e'quivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

1.5.1 Les re'arrangements . . . . . . . . . . . . . . . . . . . . . . . . . . 50
1.5.2 Les occurrences et l'e'quivalence . . . . . . . . . . . . . . . . . . . 51
1.5.3 Forme canonique des types . . . . . . . . . . . . . . . . . . . . . 52
1.6 La relation d'abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
1.7 La relation d'instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
1.8 Exemples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

2 Proprie'te's des relations sous pre'fixes 63

2.1 Projections et instanciation . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.2 Repre'sentants canoniques et bornes dans un pre'fixe . . . . . . . . . . . . 69

5

6 TABLE DES MATIE`RES

2.3 De'rivations restreintes et de'rivations e'conomes . . . . . . . . . . . . . . 69
2.4 Contextes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
2.5 Re`gles locales pour l'abstraction et l'instanciation . . . . . . . . . . . . . 77

2.5.1 Re`gles base'es sur les contextes . . . . . . . . . . . . . . . . . . . 77
2.5.2 Relations d'abstraction et d'instance alternatives . . . . . . . . . 80
2.6 Re`gles d'instances atomiques . . . . . . . . . . . . . . . . . . . . . . . . 83

2.6.1 De'finitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
2.6.2 E'quivalence entre les relations . . . . . . . . . . . . . . . . . . . . 84
2.7 E'quivalence et instanciation . . . . . . . . . . . . . . . . . . . . . . . . . 86

2.7.1 Polyno^mes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
2.7.2 Poids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
2.7.3 L'abstraction est bien-fonde'e . . . . . . . . . . . . . . . . . . . . 96
2.8 Confluence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

3 Relations sur les pre'fixes 101

3.1 Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
3.2 Relation d'instance du pre'fixe . . . . . . . . . . . . . . . . . . . . . . . . 103
3.3 Domaines des pre'fixes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
3.4 Re`gles pour l'e'quivalence, l'abstraction et l'instance du pre'fixe . . . . . . 104
3.5 De'coupage du pre'fixe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
3.6 Les pre'fixes et l'instanciation . . . . . . . . . . . . . . . . . . . . . . . . 113

4 Unification 119

4.1 De'finition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
4.2 Algorithmes auxiliaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.3 Algorithme d'unification . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
4.4 Correction de l'algorithme . . . . . . . . . . . . . . . . . . . . . . . . . . 126
4.5 Terminaison de l'algorithme . . . . . . . . . . . . . . . . . . . . . . . . . 128
4.6 Comple'tude de l'algorithme . . . . . . . . . . . . . . . . . . . . . . . . . 131

II Le langage de programmation 139
5 Syntaxe et se'mantique 143

5.1 Syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
5.2 Se'mantique statique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

5.2.1 ML comme sous ensemble de MLF . . . . . . . . . . . . . . . . . 146
5.2.2 Exemples de typage . . . . . . . . . . . . . . . . . . . . . . . . . 146
5.3 Syste`me dirige' par la syntaxe . . . . . . . . . . . . . . . . . . . . . . . . 149
5.4 Se'mantique dynamique . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

6

TABLE DES MATIE`RES 7
6 Su^rete' du typage 151

6.1 Proprie'te's standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

6.1.1 Renommages et substitutions . . . . . . . . . . . . . . . . . . . . 151
6.1.2 Renforcement et spe'cialisation des jugements de typage . . . . . 152
6.1.3 Substitutivite' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.2 E'quivalence entre le syste`me dirige' par la syntaxe et le syste`me original 155
6.3 Su^rete' du typage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

7 Infe'rence de types 163

7.1 Algorithme d'infe'rence de type . . . . . . . . . . . . . . . . . . . . . . . 163
7.2 Su^rete' de l'algorithme . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
7.3 Comple'tude de l'algorithme . . . . . . . . . . . . . . . . . . . . . . . . . 165
7.4 De'cidabilite' de l'infe'rence . . . . . . . . . . . . . . . . . . . . . . . . . . 168

8 Annotations de type 171

8.1 MLF sans annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
8.2 Introduction aux annotations de type . . . . . . . . . . . . . . . . . . . . 174
8.3 Les annotations comme primitives . . . . . . . . . . . . . . . . . . . . . 174

III Expressivite' de MLF 177
9 Encodage de Syste`me F dans MLF 181

9.1 De'finition du Syste`me F . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
9.2 Encodage des types et des environnements de typage . . . . . . . . . . . 182
9.3 Encodage des expressions . . . . . . . . . . . . . . . . . . . . . . . . . . 183

10 Shallow MLF 187

10.1 De'finition et caracte'risation . . . . . . . . . . . . . . . . . . . . . . . . . 187
10.2 Expressivite' de Shallow MLF . . . . . . . . . . . . . . . . . . . . . . . . 190
10.3 Comparaison avec le Syste`me F . . . . . . . . . . . . . . . . . . . . . . . 191

10.3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
10.3.2 Re'sultats pre'liminaires sur le Syste`me F . . . . . . . . . . . . . . 192
10.3.3 Encodage des types shallow dans le Syste`me F . . . . . . . . . . 194
10.3.4 Encodage de Shallow F dans le Syste`me F . . . . . . . . . . . . . 197
10.4 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

11 Extensions du langage 203

11.1 Tuples et enregistrements . . . . . . . . . . . . . . . . . . . . . . . . . . 203
11.2 Les re'fe'rences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
11.3 Propagation des annotations de type . . . . . . . . . . . . . . . . . . . . 206

7

8 TABLE DES MATIE`RES
12 MLF en pratique 209

12.1 Quelques encodages standard . . . . . . . . . . . . . . . . . . . . . . . . 209
12.2 Types existentiels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
12.3 Quand faut-il annoter ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
12.4 Exemple de'taille' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
12.5 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

Conclusion 217
Bibliographie 223
IV Appendice 229
A Preuves (de'tails techniques) 231

Index 319
Index des re`gles 319
Index des notations 322

8

TABLE DES MATIE`RES 9
Remerciements

Ma propre expe'rience, quoique limite'e, m'incite a` croire que mener a` bien une the`se
reste moins difficile qu'e'lever un be'be'. Cependant, ceci ne re've`le rien de la difficulte' a`
diriger une the`se. Je tiens a` remercier chaleureusement Didier Re'my pour avoir accepte'
le ro^le de directeur de the`se qu'il a exerce' avec une attention et une patience exemplaires.
Parmi une multitude d'autres enseignements, il m'a montre' l'importance de prendre du
recul en recadrant le travail en cours, me^me inacheve', dans un contexte plus large. J'ai
pu be'ne'ficier avec joie de sa connaissance pointue de TEX , incarne'e notamment dans
le tre`s utile WhizzyTEX .

Je remercie tout particulie`rement Benjamin Pierce et Jacques Garrigue, rapporteurs, pour l'attention particulie`re qu'ils ont porte'e a` mon travail, ainsi que les nombreuses heures de de'calage horaire qu'ils ont du^ subir pour participer a` la soutenance.
Leurs suggestions furent particulie`rement bienvenues et me seront profitables a` l'avenir.
Merci e'galement aux autres membres du jury pour l'inte're^t qu'ils ont manifeste' envers
ma the`se : Roberto Di Cosmo, Claude Kirchner, et Dale Miller. Je remercie au passage
Roberto pour son intervention salvatrice sur mon ordinateur portable, re'alise'e gra^ce a`
Demolinux.

Merci a` tous les membres de ma famille pour leur soutien ine'puisable : mes parents,
mes beaux-parents, mon e'pouse, et a` sa manie`re, mais tout aussi ine'puisable, PierreGilles.

Merci a` Vincent Simonet pour ses multiples compe'tences, notamment sa relecture
minutieuse et sa mai^trise de TeX. J'ai aussi appre'cie' l'aide linguistique apporte'e par
James Leifer.

Tous les membres du projet Cristal, passe's et pre'sents, se caracte'risent par une
disponibilite' exceptionnelle. Merci en particulier a` Xavier Leroy qui prend toujours le
temps de partager ses vastes connaissances alors me^me que sa nouvelle fonction de
directeur de projet ne lui laisse que peu de temps.

Je remercie Jean-Jacques Le'vy pour avoir su pre'senter la recherche en informatique de manie`re motivante, ainsi que pour les sorties piscine. Maxence Guesdon e'tant
complice, je le remercie e'galement.

9

10 TABLE DES MATIE`RES
10
Introduction 11
Introduction

En 1965, Gordon Moore fit une observation devenue fort ce'le`bre depuis : le nombre
de transistors des circuits inte'gre's croi^t de manie`re exponentielle. Ce phe'nome`ne remarquable s'est maintenu pendant quarante ans, accroissant conside'rablement la puissance
des ordinateurs, et permettant a` un nombre toujours plus grand de programmeurs
d'e'crire des programmes de plus en plus gros et de plus en plus complexes. Une conse'quence moins plaisante est que le nombre de programmes mal e'crits suit la me^me
courbe, et le nombre d'e'checs logiciels risque e'galement de croi^tre de manie`re exponentielle. Fort heureusement, la recherche en matie`re de langages de programmation
apporte des solutions efficaces e'vitant aux programmeurs de sombrer dans la folie. Une
de ces techniques est le typage statique. Le typage statique peut e^tre vu comme une
validation effectue'e par le compilateur garantissant que le programme n'effectuera pas
d'ope'ration mal forme'e, c'est-a`-dire qu'il ne plantera pas. En particulier, le typage garantit que chaque type de donne'e n'est manipule' que par des fonctions ade'quates. Il est
de coutume de dire qu'<<un programme bien type' ne provoque pas d'erreur d'exe'cution>>.
Bien mieux, la pratique montre qu'un nombre conside'rable d'erreurs sont de'tecte'es automatiquement par le typage statique, et que le de'veloppement des logiciels s'en trouve
significativement acce'le're'.

Pour permettre le typage statique d'un programme, un compilateur peut reque'rir
des informations explicites de type dans le programme source. C'est le cas en C ou Java,
ou` chaque de'claration de variable ou de fonction est irre'me'diablement annote'e avec des
types. Ce compromis reste acceptable quand les types sont simples. Cependant, afin de
gagner en expressivite' et de typer des programmes plus complexes, il devient rapidement ne'cessaire d'introduire une syntaxe plus riche pour les types, comme par exemple
celle des langages fonctionnels d'ordre supe'rieur tels que ML [DM82]. Dans ce cas, les
compilateurs ruse's utilisent l'infe'rence de types (type inference ou type reconstruction)
afin de retrouver automatiquement les annotations de type. En ce qui concerne ML,
l'algorithme d'infe'rence est complet, ce qui signifie qu'aucune annotation de type n'est
ne'cessaire dans le programme source, et que toutes les informations peuvent e^tre infe're'es par le compilateur. Il est cependant possible de laisser des annotations explicites
a` des fins de documentation.

11

12 Introduction

Les types sont une approximation des programmes et le compilateur peut parfaitement rejeter un programme correct qu'il ne parvient pas a` typer. Une telle limitation
se rencontre par exemple dans un syste`me de types monomorphes, ou` chaque fonction
est contrainte a` e^tre utilise'e avec toujours le me^me type. Alors, une fonction donne'e
ne pourra pas s'appliquer a` deux structures de donne'es ayant des types incompatibles.
Par exemple, la fonction List.length, qui renvoie le nombre d'e'le'ments d'une liste,
ne pourrait s'appliquer qu'aux listes d'entiers, et une autre fonction devient ne'cessaire
pour ope'rer sur les listes de caracte`res. Toutefois, les deux fonctions ont exactement
le me^me code, seuls les types sont diffe'rents. Cette duplication inutile peut e^tre e'vite'e
gra^ce a` des syste`mes de type plus expressifs. En effet, plusieurs solutions ont e'te' propose'es pour permettre de typer des fonctions applique'es a` des arguments ayant des types
incompatibles. Ces solutions utilisent entre autres les notions de sous-typage, de types
intersection, ou encore de polymorphisme parame'trique. Nous ne de'veloppons pas les
pseudo-solutions utilise'es en C ou Java qui consistent a` oublier le type des expressions
en utilisant l'annotation void* ou Object et a` les placer dans des structures de donne'es
ge'ne'riques. Lorsqu'une valeur est sortie d'une telle structure, une ope'ration non su^re est
ne'cessaire pour transformer le type Object en une classe donne'e, ou pour transformer
void* en un pointeur de type donne'. Cette pratique casse la su^rete' du typage, et conduit
ou bien a` un plantage a` l'exe'cution, ou bien a` des erreurs dynamiques de typage. Dans
les deux cas, des erreurs de'tectables statiquement ne se manifestent qu'a` l'exe'cution.
Nous ne jugeons pas cette approche satisfaisante. Nous de'taillons maintenant les autres
solutions mentionne'es ci-dessus.

Le sous-typage permet d'oublier une partie de l'information d'un type [Car88, Mit83,

Pot98b]. Par exemple, les entiers et les nombres re'els sont habituellement de types
incompatibles, mais peuvent e^tre vus comme des membres du type plus ge'ne'ral
"nombre". Une liste d'entiers peut alors e^tre vue comme une liste de nombres, or
encore comme une liste quelconque, en oubliant le type du contenu. La fonction
List.length peut alors s'appliquer a` une liste quelconque, incluant par sous
typage les listes d'entiers et les listes de chai^nes de caracte`res. Des extensions de
ML avec sous-typage et infe'rence de type ont e'te' conc,ues [OSW99, Pot98a]. Il
reste a` tester cette approche sur une grande e'chelle. Un pas en cette direction a
e'te' re'alise' avec Flow Caml [Sim03], un analyseur de flot pour Caml utilisant le
sous-typage.

Les types intersection e'nume`rent pre'cise'ment les diffe'rents types qu'une valeur donne'e peut avoir, et peuvent e^tre vus comme un raffinement du sous-typage [CDC78,
CDCS79, Sal82, Pot80, Pie91]. Par exemple, List.length peut e^tre type'e avec
un type intersection qui indique que c'est a` la fois une fonction acceptant les
listes d'entiers et une fonction acceptant les listes de chai^nes de caracte`res. Les

12

Introduction 13

types intersection sont d'une certaine manie`re aussi expressifs que le programme
lui-me^me [CC90]. En particulier, un programme est typable avec des types intersection si et seulement si il termine [Pot80]. Des restrictions base'es sur les rangs
ont e'te' propose'es pour inte'grer les types intersection dans le cadre d'un langage
avec infe'rence de types [KW99, Jim00]. Toutefois, de telles restrictions ne favorisent pas la modularite' : une valeur ne peut pas toujours e^tre passe'e en argument
a` une fonction si son rang est trop haut. En effet, le type de la fonction applique'e
a` l'argument doit e^tre de rang supe'rieur a` l'argument, ce qui peut e^tre interdit.
Ainsi, bien que les types intersection be'ne'ficient de bonnes proprie'te's, ils sont en
re'alite' trop expressifs et doivent e^tre limite's en pratique.

Le polymorphisme parame'trique ou plus simplement polymorphisme, permet la

quantification des variables de types dans les types me^mes. Ainsi, toute expression
polymorphe peut avoir une infinite' de types. Par exemple, List.length est une
fonction acceptant des listes de ff, pour tout ff. Nous de'veloppons la pre'sentation
du polymorphisme ci-apre`s.

Ces solutions permettent a` une unique fonction d'e^tre utilise'e avec diffe'rents types,
c'est-a`-dire d'appliquer une unique fonction a` des structures de donne'es avec des types
incompatibles. Elles aident toutes a` e'viter la duplication inutile de code, et contribuent
ainsi a` garder le code concis. Dans le langage ML, la troisie`me approche est retenue :
le polymorphisme parame'trique. Plus pre'cise'ment, le moteur d'infe'rence de ML est capable d'infe'rer les types polymorphes des fonctions nomme'es. En particulier, toutes les
fonctions de'finies a` top-level sont munies d'un type polymorphe si possible. Cette caracte'ristique contribue largement a` la concision et a` l'expressivite' de ML. De plus, bien
que le cou^t de l'infe'rence soit exponentiel en the'orie, il reste tre`s efficace en pratique.
Le succe`s de ML sugge`re que le polymorphisme parame'trique est une caracte'ristique
expressive qui s'adapte bien aux gros programmes.

Polymorphisme de seconde classe

Le polymorphisme en ML est seulement de seconde classe : comme mentionne' cidessus, seulement les valeurs nomme'es peuvent avoir un type polymorphe, c'est-a`-dire
seules les valeurs lie'es par un let. Par conse'quent, il n'est pas possible pour l'argument
d'une fonction d'e^tre utilise' avec un type polymorphe. Par exemple, soit id la fonction
identite' *(x) x. Son type en ML est polymorphe et e'gal a` 8 (ff) ff ! ff, que nous e'crirons
oeid. Alors, (*(x) x x) id (1) n'est pas typable en ML, alors que let x = id in x x (2)
l'est. En effet, typer le corps de la fonction *(x) x x impose a` x un type polymorphe,
tel que oeid. Pourtant, x n'est pas lie' par un let mais par un *. Par conse'quent, son

13

14 Introduction
type est monomorphe en ML, et le typage de (1) e'choue. Au contraire, x est d'abord
lie' par un let dans (2), et ensuite le corps x x est type'. en ML, cela permet d'infe'rer
un type polymorphe pour x, a` savoir oeid, ce qui suffit ensuite a` typer (2). Cet exemple
montre pourquoi le polymorphisme en ML est de seconde classe seulement ; c'est-a`-dire
qu'il n'est pas autorise' dans les *-abstractions. Cela montre e'galement que le let peut,
dans certaines situations, contourner le proble`me. Toutefois, il existe des situations ou`
le polymorphisme par let a la ML n'est pas suffisant.

Motivation

Nous de'taillons maintenant la motivation pour ce travail de the`se, dont le re'sultat
est un langage de programmation appele' MLF. Le point de de'part est le langage ML.

En pratique, ML est particulie`rement puissant pour de'finir, manipuler, et ite'rer sur
des structures de donne'es complexes. En effet, les structures de donne'es sont souvent
type'es en utilisant des constructeurs de type parame'triques tels que ceux du langage ou
ceux de'finis par l'utilisateur. Le parame`tre de type repre'sente alors le type des valeurs
que l'on trouve dans la structure. Par exemple, une liste d'e'le'ments de type ff a le type
parame'trique ff list en OCaml [LDG+02]. Dans ce cas, les constructeurs associe's a` ce
type, tels que la liste vide, l'ope'rateur cons, ou les constructeurs de'finis pas l'utilisateur,
sont automatiquement type's de manie`re polymorphe, avec quantification en te^te. Ainsi,
la liste vide rec,oit le type 8 (ff) ff list. La plupart des fonctions de'finies sur ces
structures de donne'es, comme les ite'rateurs, sont aussi type'es de manie`re polymorphe,
avec quantification en te^te. Par exemple, List.fold rec,oit le type polymorphe 8 (ff, fi)
fi list ! (ff ! fi ! ff) ! ff ! ff.

Lorsque la structure de donne'e est connue du programmeur, ML convient parfaitement, et le polymorphisme de te^te permet de prendre plusieurs instances de la structure
de donne'e et de les remplir avec des valeurs de types incompatibles. En effet, il est possible d'utiliser les constructeurs de listes pour de'finir des listes d'entiers, de tableaux,
ou plus ge'ne'ralement des listes de ff, quel que soit ff. Aucune coercion ou information
de type explicite n'est requise dans le programme. Ce n'est pas le cas dans certains
langages de programmation tels que C ou Java. Il est remarquable que l'introduction
de parame`tres de types a e'te' e'tudie'e dans le cas de Java [BOSW98].

Cependant, de`s qu'un niveau supple'mentaire d'abstraction est requis, ML ne suffit
plus. En effet, supposons que la structure de donne'e a` manipuler n'est pas connue
du programmeur : il souhaite e'crire une fonction recevant une structure de donne'es
inconnue comme argument, ainsi qu'un ite'rateur sur cette structure. Alors, le syste`me
de types de ML contraint la structure de donne'es et l'ite'rateur a` e^tre monomorphes.
Il n'est pas possible d'explorer la structure de donne'es en utilisant deux instances
incompatibles de l'ite'rateur.

14

Introduction 15

Par exemple, conside'rons un programme qui prend une liste en argument et ne manipule cette liste qu'au travers de la fonction List.fold. Ce programme peut toujours
e^tre e'crit de la manie`re suivante :

*(ls)

let fold = List.fold ls in
a2

ou` ls n'est pas libre dans a2. Afin d'offrir plus de flexibilite', le programmeur peut
souhaiter abstraire l'imple'mentation de la structure de donne'e. Alors, le programme
devient une fonction qui rec,oit seulement un ite'rateur : *(fold) a2. Ainsi, il devient
possible d'utiliser ce programme avec diffe'rentes structures de donne'es comme des listes,
des arbres e'quilibre's, des tables de hash, etc. Malheureusement, une telle fonction ne
type pas en ML de`s lors que son argument est utilise' de manie`re polymorphe. Remarquer qu'il suffit pour cela de parcourir la structure de donne'e avec deux instances
incompatibles de l'ite'rateur fold. Dans le chapitre 12, nous de'veloppons un exemple
similaire dans le cadre d'une imple'mentation prototype de MLF. Un autre exemple lie'
est fourni section 11.1 (page 203); il montre que l'encodage des paires dans le System F
n'est pas correct en ML.

Le polymorphisme de premie`re classe (que l'on appelle e'galement polymorphisme
de second ordre) permet de typer de tels exemples ; nous de'crivons ce me'canisme plus
en de'tail dans la section suivante. Dans ce cadre, l'argument fold peut recevoir un type
polymorphe 8 (ff) (ff ! fi ! ff) ! ff ! ff), ou` fi repre'sente le type des e'le'ments de la
structure de donne'es.

En re'sume', l'abstraction des structures de donne'es n'est en pratique pas possible
dans ML (bien que certaines imple'mentations le permettent au niveau des modules).
Plus ge'ne'ralement, ML ne convient pas pour manipuler des valeurs dont une partie du
type est cache'e.

Comme premier exemple, conside'rons les types existentiels, qui peuvent servir a`
encapsuler une valeur et cacher une partie de l'information de type, c'est-a`-dire qu'une
partie de la structure de la valeur est cache'e au reste du programme. Par exemple,
conside'rons un serveur qui rec,oit des ta^ches a` effectuer de manie`re asynchrone, les
enregistre dans une liste, et les exe'cute de manie`re se'quentielle. La liste contient des
ta^ches qui attendent d'e^tre exe'cute'es : son type est task list. Mais comment est
de'finie le type task ? En ML une ta^che est en ge'ne'ral un calcul qui attend d'e^tre
de'clenche', c'est-a`-dire une fonction de type unit ! unit. Cependant, il est souvent
plus pratique de de'crire une ta^che comme la paire d'une fonction et de l'argument qu'elle
recevra. Alors, une ta^che est une paire (f, a) dont le type est un existentiel : 9ff.(ff !
unit) * ff. Gra^ce a` cette forme d'encapsulation, il est possible de placer des paires de
types incompatibles dans la liste des ta^ches. Les existentiels ne sont pas disponibles dans
core-ML, mais seulement dans certaines extensions du langage [LO94a]. Toutefois, des

15

16 Introduction
informations de type explicites sont requises a` la fois pour l'encapsulation et l'ouverture,
ce qui sera ame'liore' avec MLF. Les types existentiels peuvent e^tre encode's de manie`re
assez e'le'gante en utilisant le polymorphisme de premie`re classe.

En deuxie`me exemple, les objets sont une autre forme d'encapsulation. Comme
chaque objet peut contenir toute sorte de structure de donne'e, en ge'ne'ral cache'e au
monde exte'rieur, son interface (ses me'thodes) doit fournir un moyen de copier, transformer, ou ite'rer sur lui-me^me. C'est pour cette raison que des fonctions polymorphes
sont souvent ne'cessaires dans l'interface. Conside'rons par exemple une classe dlist
repre'sentant les listes doublement lie'es. Puisque le type des e'le'ments de la liste, disons
ff, n'est qu'un parame`tre de type de la classe, les me'thodes1 rev, car, et cdr sont
monomorphes. Leur type est, respectivement, ff dlist, ff, et ff dlist. Par contre, une
me'thode comme fold doit e^tre polymorphe : son type est 8 (fi) (fi ! ff ! fi) ! fi ! fi.
Un tel type ne peut pas e^tre exprime' dans ML a` cause de l'absence de polymorphisme
de premie`re classe. Dans le cas d'OCaml, une extension spe'ciale du langage est requise
pour permettre les me'thodes polymorphes dans les objets [GR99].

L'encodage des monades, tel que celui mentionne' par Peyton Jones et Shields [JS04],
requiert aussi le polymorphisme de premie`re classe. En effet, le type d'un monade, que
nous e'crivons ff m, est en ge'ne'ral parame'tre' par une variable de type ff, et les fonctions
de l'interface doivent e^tre polymorphes. Par exemple, return et bind rec,oivent les
types polymorphes 8 (ff) ff ! (ff m) et 8 (ff, fi) ff m ! (ff ! fi m) ! fi m. Alors, les
fonctions attendant un monade en argument ne'cessitent le polymorphisme de second
ordre.

Un autre exemple nous est fourni par les types re'cursifs non uniformes [Oka98],
qui sont connus pour ne'cessiter la re'cursion polymorphisme. Deux cas peuvent e^tre
identifie's.

- Le premier correspond aux types finis : par exemple, le type de donne'es (datatype)

de'fini par type ff T = None | Some of ff * (int T ). Une fonction de'finie pour
ce type requiert certainement d'e^tre applicable aux types ff T et int T . Si la
re'cursion polymorphe n'est pas disponible, il est toujours possible de de'finir deux
fois la me^me fonction : la premie`re fois pour le type int T , la deuxie`me pour le
type ff T . Cet exemple illustre que la duplication de code peut parfois pallier les
limitations du syste`me de type.
- Le second correspond aux types infinis : conside'rer par exemple la de'finition

type ff T = None | Some of ff list T . Une fonction re'cursive de'finie sur ce type
doit e^tre polymorphe. Dans ce cas, il n'est pas possible de dupliquer le code pour
contourner la limitation.
Tous les exemples cite's ne requie`rent que du polymorphisme de rang 2. Toutefois,
Peyton Jones et Shields [JS04] fournissent un exemple qui illustre la manie`re dont le

1En respect de la tradition, rev, car, et cdr sont les fonctions qui, respectivement, inverse une liste,
retourne le premier e'le'ment, et retourne la liste sans le premier e'le'ment.

16

Introduction 17
polymorphisme de rang 3 peut e^tre utilise'. Ils de'finissent une fonction re'cursive map sur
un type re'cursif : la fonction re'cursive est de'compose'e en un ope'rateur de point fixe
re'cursif et une fonction map non re'cursive. Bien que cette se'paration soit quelque peu
artificielle, elle montre que des types de rang 3 sont susceptibles d'apparai^tre dans les
programmes utilisant des fonctions polymorphes chaque fois qu'un peu plus d'abstraction est introduit. En effet, ajouter un niveau supple'mentaire d'abstraction, tel que la
se'paration explicite de'crite ici, augmente aussito^t le rang des types concerne's.

En conclusion de cette section, nous avons vu que bien que le polymorphisme a
la ML soit en ge'ne'ral suffisant pour cre'er et manipuler des structures de donne'es parame'triques, des extensions du syste`me de types sont requises de`s que l'on souhaite
davantage d'abstraction sur les structures de donne'es, l'encapsulation de valeurs, ou
des types re'cursifs non uniformes. En effet, dans chacun de ces cas, l'absence de polymorphisme de premie`re classe empe^che ML de typer les programmes correspondant.

Polymorphisme de premie`re classe

Dans un syste`me de types avec du polymorphisme de premie`re classe, toute variable
peut e^tre affuble'e d'un type polymorphe, y compris les variables lie'es par un *. Dans
les anne'es 1970, Girard [Gir72] et Reynolds [Rey74] ont inde'pendamment conc,u un tel
syste`me, appele' Syste`me F. Puisque l'infe'rence totale de types est inde'cidable pour
Syste`me F [Wel94], des informations explicites de type sont ne'cessaires pour permettre
de typer les expressions. En conse'quence, Syste`me F est ge'ne'ralement de'fini dans un
style dit a` la Church, ou` les expressions ont suffisamment d'informations de type pour
que la de'rivation de typage puisse e^tre reconstruite. Trois sortes d'informations de
type sont pre'sentes dans les expressions de Syste`me F : les abstractions de type, les
annotations de type, et les applications de type. Les abstractions de type sont des
abstractions par des variables de type note'es \Lambda (ff) a. Elles indiquent que l'expression
a est polymorphe en ff. La variable de type abstraite (ff dans notre cas) se retrouvera
dans des annotations de type ou des applications de type. Les annotations de type sont
des types utilise's pour annoter les variables lie'es par un *. Par exemple, l'identite'
s'e'crit \Lambda (ff) *(x : ff) x (3) dans le Syste`me F. Une abstraction de type est utilise'e
pour indiquer que cette fonction est polymorphe. L'annotation de type sur le x relie
la variable de type abstraite ff au type de x. Dans le Syste`me F, l'expression (3) a
le type 8 ff * ff ! ff.2 Intuitivement, une valeur polymorphe repre'sente un nombre
infini de types. Choisir l'un de ces types (ou un sous-ensemble de ces types) s'appelle
instancier. Dans le Syste`me F, l'instanciation est explicite via les applications de type.

2Remarquer que nous utilisons deux notations : la premie`re est 8 (ff) oe pour les types polymorphes
de ML, que nous utiliseront e'galement pour les types de MLF; la seconde est 8 ff * t pour les types
polymorphes de Syste`me F.

17

18 Introduction
Pour poursuivre l'exemple, instancier l'identite' en vue de l'appliquer a` des entier s'e'crit
id [int]. Les applications de type indiquent explicitement comment instancier une
valeur polymorphe. L'argument de type (ici int), sert a` remplacer la variable de type
abstraite (ici ff) dans le corps de l'abstraction, ce qui conduit au type int ! int.

Il y a une grande diffe'rence entre programmer en ML et programmer dans le Syste`me F : alors que le premier be'ne'ficie de l'infe'rence de type totale, ce qui signifie
qu'aucun type n'est ne'cessaire dans le programme source, le second ne'cessite toutes
les informations de type de'crites ci-dessus. Toutefois, Syste`me F est plus expressif que
ML car le polymorphisme y est de premie`re classe. Afin de combiner les deux syste`mes,
une premie`re approche peut consister a` tenter de re'aliser suffisamment d'infe'rence de
type dans le Syste`me F, de telle sorte que les programmes n'aient pratiquement pas
besoin d'annotation de type. Prenant F!<: comme base, Cardelli a expe'rimente' une
telle solution [Car93]. Cela a conduit ensuite a` l'infe'rence locale [PT98], re'cemment
ame'liore'e en infe'rence locale colore'e [OZZ01]. Ces deux syste`mes de types parviennent
a` combiner le sous-typage avec le polymorphisme d'ordre supe'rieur, tout en re'alisant
suffisamment d'infe'rence de type. Toutefois, aucun de ces syste`mes ne parvient a` typer
l'ensemble des programmes ML non annote's. De plus, bien que l'infe'rence locale semble
satisfaisante en pratique, elle souffre de limitations intrinse`ques apparemment difficiles
a` corriger [HP99].

Une seconde approche consiste a` e'tendre ML avec des types d'ordre supe'rieur, de
telle manie`re que les programmes ML restent typable sans annotations et le Syste`me F
puisse e^tre encode' dans le langage e'tendu [LO94b, Re'm94, OL96, GR99]. Cependant,
les solutions existantes sont encore limite'es dans leur expressivite' et la quantite' d'information de type requise ne facilite pas tellement l'usage de polymorphisme de premie`re
classe. Plus pre'cise'ment, toutes ces solutions incorporent le polymorphisme de premie`re
classe dans les monotypes de ML en utilisant des constructeurs de type. On appelle cette
technique l'encapsulation (boxed polymorphism). Alors, toute valeur polymorphe peut
soit avoir un type polymorphe, comme c'est de'ja` le cas en ML, ou avoir un type polymorphe encapsule', conside're' comme un monotype. Des coercions explicites sont alors
ne'cessaires pour transformer un type polymorphe en un type polymorphe encapsule'.
Inversement, alors qu'un type polymorphe peut e^tre instancie' implicitement en ML,
une coercion explicite est ne'cessaire pour transformer un type polymorphe encapsule'
en un type polymorphe. La quantite' d'information de type explicite varie d'un syste`me
a` l'autre. Par exemple, dans Poly-ML [GR99] les coercions des types encapsule's vers
les types polymorphes sont une simple marque, qui ne de'pend pas du type coerce' (la
construction h*i). Cependant, une annotation explicite reste ne'cessaire pour coercer un
type polymorphe vers un type encapsule'. Bien que Poly-ML ait e'te' utilise' pour formaliser l'ajout de me'thodes polymorphes a` OCaml, il n'est sans doute pas assez le'ger
pour apporter du polymorphisme de premie`re classe au langage me^me. En re'sume', les
solutions existantes sont pour l'instant peu pratiques, a` cause notamment de la quantite'

18

Introduction 19
d'information de type qu'il est ne'cessaire d'ajouter explicitement dans les programmes.

Dans cette the`se, nous suivons la seconde approche : notre objectif est de typer
tous les programmes ML sans annotation, et de typer les expressions du Syste`me F
en utilisant des annotations si ne'cessaire. Nous repartons du travail de'ja` fait avec
Poly-ML, et visons a` l'e'limination des coercions entre les types encapsule's et les types
polymorphes. Nous ne cherchons pas cependant a` deviner des types polymorphes, ce qui
implique qu'il restera des cas ou` des annotations seront ne'cessaires pour typer certaines
expressions de Syste`me F. En bref, les programmes MLF contiennent des annotations
de type, mais pas de coercions, pas d'abstraction de type, et pas d'application de type.

Infe'rence de types

Le langage ML be'ne'ficie de l'infe'rence totale, contrairement a` Syste`me F. Nous
nous inte'ressons de plus pre`s a` cette proprie'te'. En core-ML, les programmes consistent
en des lambda-expressions non type'es et d'une construction let. Remarquer que, par
construction, les programmes n'ont pas d'annotation de type. Tous les programmes
ainsi e'crits ne sont pas des programmes valides : certains d'entre eux seulement seront
typables d'apre`s un ensemble de re`gles de typage. Heureusement, il existe un algorithme
d'infe'rence, qui de'termine si un programme donne' un typable ou non. De plus, cet algorithme est complet, c'est-a`-dire qu'il termine toujours en de'terminant si le programme
est typable ou non. En re'sume', l'infe'rence de type en ML consiste a` trouver si un programme donne' est typable selon les re`gles de typage de ML. Il convient de noter que,
par de'finition, les programmes ne contiennent aucune information de type.

Une approche similaire dans le Syste`me F est appele'e Syste`me F a` la Curry : les
programmes sont des lambda-termes non annote's, c'est-a`-dire des lambda-termes purs
sans aucune information de type. Les re`gles de typage sont alors de'finies sur les lambdatermes purs, et un proble`me d'infe'rence consiste a` trouver s'il existe une de'rivation en
utilisant les re`gles de typage du Syste`me F a` la Curry. Malheureusement, ce proble`me
est inde'cidable en ge'ne'ral [Wel94], c'est-a`-dire qu'il n'existe aucun algorithme complet
qui de'termine si un programme est typable ou non. C'est sans doute la raison pour
laquelle les programmes sont souvent e'crits dans un style a` la Church, c'est-a`-dire avec
beaucoup d'informations de type. De plus, les re`gles de typage sont de'finies sur les
programmes annote's. Ainsi, de'finir l'infe'rence comme nous l'avons fait pour ML serait
vain : puisque toutes les informations de type sont de'ja` pre'sentes dans les programmes,
il est imme'diat d'e'crire un algorithme d'infe'rence de type qui se contente de ve'rifier
que le programme e'crit est typable. En ce sens, nous avons un algorithme d'infe'rence
complet pour le Syste`me F a` la Church. D'autre part, alors qu'un programme dans
le Syste`me F a` la Church a la me^me structure que sa de'rivation de typage suppose'e,
un programme dans le Syste`me F a` la Curry peut admettre plusieurs de'rivations de
typage.

19

20 Introduction

Puisque l'infe'rence de type est inde'cidable dans le Syste`me F a` la Church, il n'est
pas possible de reconstruire toutes les abstractions de type, applications de type, et
annotations de type. En outre, reconstruire les annotations de type lorsque les abstractions de type et la position des applications de type sont donne'es est tout aussi
inde'cidable [Pfe93]. Avec MLF, nous visons a` l'e'limination des abstractions de type
et des applications de type, mais pas de toutes les annotations sur les lambdas. Par
conse'quent, un programme MLF est un programme ML qui peut contenir des annotations de type. Comme nous l'avons vu ci-dessus, un programme dans le Syste`me F
annote' correspond exactement a` sa de'rivation de typage, et donc l'infe'rence de type est
imme'diate pour le Syste`me F a` la Church. Au contraire, un programme MLF requiert
une infe'rence significative : d'une part, les annotations de type ne sont pas requises
pour toutes les variables, et donc il reste a` infe'rer les types des variables non annote'es,
comme en ML ; d'autre part, les abstractions de type et les applications de type ne sont
pas explicites, et donc il reste a` infe'rer les endroits ou` le polymorphisme est introduit,
et les endroits ou` il est instancie'. Nous voyons que le proble`me de l'infe'rence de type des
programmes MLF annote's n'est a priori pas imme'diat, et certainement plus difficile que
l'infe'rence de type des programme du Syste`me F annote'. Dans cette the`se, nous conside'rons seulement ce proble`me d'infe'rence. En particulier, nous ne nous inte'ressons pas
a` l'infe'rence de type pour MLF sans annotation (c'est-a`-dire des lambda-termes purs
conside're's comme des programmes MLF). Toutefois, la de'cidabilite' d'un tel proble`me
sera e'voque'e lorsque nous comparerons MLF et le Syste`me F.

En bref, notre ambition est d'infe'rer tous les types des programmes ML et d'infe'rer
les abstractions et applications de type des programmes du Syste`me F. Par contre,
notre objectif n'est pas de deviner les annotations de type polymorphes, et donc les
programmes qui sont en de'faut d'annotation de type doivent e^tre imme'diatement rejete's. Ceci explique pourquoi, a` l'inverse de ML, la se'mantique statique de MLF prend
en compte les annotations de type.

Types principaux

L'infe'rence de type en ML est efficacement mene'e gra^ce a` la proprie'te' suivante : tous
les types possibles d'un programme sont les instances d'un unique type, appele' son type
principal. Comme nous l'avons fait pour l'infe'rence de type, il est utile de comparer la
de'finition des types principaux dans les diffe'rentes versions de Syste`me F. Nous avons
vu qu'un programme dans le Syste`me F a` la Church admet au plus un type, qui peut
e^tre conside're' comme son type principal e'vident. Inversement, un programme dans le
Syste`me F a` la Curry peut admettre plusieurs typages et plusieurs types incomparables.
En guise d'exemple, prendre l'expression *(x) x x. En choisissant oeid pour le type de
x (et en ajoutant l'application de type ade'quate), l'expression devient typable et son
type est oeid ! oeid. D'autre part, en prenant 8 ff * ff pour le type de x, l'expression est

20

Introduction 21
e'galement typable de type (8 ff * ff) ! (8 ff * ff). Ces deux types sont incomparables.
De plus, aucun type n'est a` la fois un type valide pour *(x) x x et plus ge'ne'ral que
ces deux types. En effet, le Syste`me F a` la Curry n'admet pas la proprie'te' des types
principaux.

Dans MLF, toute expression typable admet un type principal : tous les types possibles d'un programme sont les instances d'un unique type. Noter que ceci est vrai
pour les programmes annote's. Comme pour l'infe'rence de type, le proble`me des types
principaux n'est a priori pas e'vident dans MLF annote', alors qu'il est e'vident dans le
Syste`me F annote'. Dans cette the`se, nous ne conside'rons le proble`me des types principaux que pour les programmes MLF annote's, et ne nous inte'ressons pas a` la question
des types principaux pour MLF sans annotation. En conse'quence, le type principal de
toute expression typable de'pend des annotations de type explicites. Il devrait e^tre clair
d'apre`s cette discussion que ceci n'est pas une limitation due a` la conception de MLF,
mais seulement une conse'quence de nos ambitions.

En bref, nous ne conside'rons que la question de l'infe'rence de type et des types
principaux pour les programmes MLF partiellement annote's. Alors que ces proble`mes
sont triviaux dans le Syste`me F annote', ils ne le sont pas dans MLF, car nous cherchons
a` infe'rer les abstractions de type et les applications de type. En conse'quence, le type
principal d'une expression doit capturer toutes les abstractions de type et toutes les applications de type possibles gra^ce a` une relation d'instance idoine et a` une syntaxe des
types enrichies. Examinons un exemple. Nous supposons que choose est une expression
de type 8 ff * ff ! ff ! ff (prendre par exemple *(x) *(y) if true then x else y). Appliquons choose a` l'identite' id : en ajoutant les abstractions de type et les applications
de type omises, nous pouvons obtenir au moins deux typages pour choose id dans le
Syste`me F :

choose [8 fi * fi ! fi] id : (8 fi * fi ! fi) ! (8 fi * fi ! fi)
\Lambda (fi) choose [fi ! fi] (id [fi]) : 8 fi * (fi ! fi) ! (fi ! fi)

Le premier typage est obtenu en gardant l'identite' pleinement polymorphe. Alors,
choose id est une fonction attendant un argument qui doit e^tre aussi polymorphe
que l'identite'. Le second typage est obtenu est instanciant d'abord l'identite' vers le
type fi ! fi. Alors, choose id est une fonction attendant un argument monomorphe
de type fi ! fi.

Dans MLF, nous devons donner un type principal a` choose id qui peut capturer
ces deux types par instanciation. Nous remarquons que ces deux types ont la me^me
structure t ! t. En fait, il est facile de ve'rifier que tous les types de choose id dans
le Syste`me F ont la forme 8 _ff * t ! t pour certaines variables _ff et un certain type t
instance de 8 ff * ff ! ff (en incluant 8 ff * ff ! ff). Dans MLF, nous capturons ceci en
e'crivant 8 (ff >= oeid) ff ! ff pour le type de choose id. La notation (ff >= oeid) lie ff a`

21

22 Introduction
une instance de l'identite' oeid. Une telle liaison est appele'e flexible. Par analogie, nous
e'crivons 8 (ff=oeid) ff ! ff pour le type oeid ! oeid. La liaison (ff=oeid) est appele'e rigide.
Comme sugge're' par la notation, la relation d'instance de MLF permet de remplacer la
borne de ff par une instance de oeid dans 8 (ff >= oeid), mais ne le permet pas dans la
borne de ff dans 8 (ff = oeid). Cette nouvelle syntaxe des types, accompagne'e d'une
relation d'instance approprie'e, suffit en re'alite' a` capturer toutes les abstractions de
type et les applications de type implicites. En d'autre termes, nous obtenons des types
principaux dans MLF en suivant simplement l'intuition derrie`re la notation 8 (ff >= oe) oe0,
qui signifie "le type oe0 ou` ff est une instance de oe". En bref, les types de MLF sont plus
riches avec des contraintes sur les bornes des variables, de sorte que l'instanciation de ces
variables peut e^tre retarde'e jusqu'a` ce que l'information ne'cessaire pour les instancier
soit disponible.

Infe'rence de type compositionnelle

Un typage principal [Jim96] est un jugement de typage qui repre'sente, d'une certaine
manie`re, tous les jugements de typage possibles pour l'expression conside're'e. En particulier, il doit repre'senter tous les environnements de typage possibles qui permettent
de typer l'expression. Nous observons au passage que MLF n'a pas la proprie'te' des typages principaux, pas plus que Syste`me F ou ML [Wel02]. En guise de contre-exemple
dans le Syste`me F, ML, et MLF, prendre x x (dans un environnement de'finissant x) :
un seul jugement ne peut pas capturer tous les jugements permettant de typer x x.
En conse'quence, un soin particulier doit e^tre pris dans MLF pour que l'infe'rence soit
effectue'e de manie`re compositionnelle.

Comme point de de'part, prenons justement *(x) x x. Cette expression n'est pas
typable en ML. De plus, elle n'est pas typable telle quelle dans MLF car cela ne'cessiterait de deviner le type polymorphe de x. En fait, une annotation de type est requise,
e.g. (x : oeid), pour typer cette expression. Cela conduit a` l'expression *(x : oeid) x x,
que nous appellerons auto, et qui est typable dans MLF. Nous nous inte'ressons maintenant a` une variante : au lieu de retourner seulement x x, nous retournons une paire
compose'e de x x et de x. Nous conside'rons donc l'expression *(x) (x x, x). Elle n'est
pas typable dans MLF telle quelle, pour la raison de'ja` mentionne'e. Une annotation
de type est de nouveau ne'cessaire. Dans MLF, toute expression peut e^tre annote'e, et
donc les expressions *(x) ((x : oeid) x, x) (1) et *(x) (x x, (x : oeid)) (2) sont bien
forme'es. De plus, les annotations sur les variables introduites par un *, qui sont les
seules annotations trouve'es dans le Syste`me F, sont du sucre syntaxique dans MLF :
*(x : oeid) (x x, x) s'e'panche en *(x) let x = (x : oeid) in (x x, x) (3). Dans ces trois
exemples (1), (2), et (3), une annotation de type (x : oeid) est fournie, et donc il n'y
a pas a` deviner le type polymorphe de x. Cependant, bien que (1) et (3) soient dans
MLF, nous rejetterons (2) afin de garder l'infe'rence compositionnelle. Nous justifions

22

Introduction 23
ce choix. Le typage de (2) requiert le typage de (x x) (4) et le typage de (x : oeid) (5).
De plus, l'environnement de typage initial ne fournit aucune information au sujet de
x. En conse'quence, si l'algorithme d'infe'rence commence par essayer de typer l'expression (5), il "apprend" que le type de x est oeid. Ensuite, gra^ce a` cette information, il
peut tre`s bien parvenir a` typer (4). Au contraire, si l'algorithme commence par essayer
de typer l'expression (4), il ne peut que e'chouer car il ne peut pas deviner le type polymorphe de x. Une solution serait d'autoriser le retour en arrie`re (backtracking) dans
l'algorithme d'infe'rence. Toutefois, l'information de type (x : oeid) peut se situer dans
une sous-expression arbitrairement profonde ; le cou^t du backtracking en devient alors
conside'rable, et l'infe'rence contre-intuitive. Pour e'viter une telle situation dans MLF,
nous avons conc,u le syste`me de types de telle sorte que l'expression (2) ne soit pas
typable. De cette manie`re, l'algorithme d'infe'rence et la spe'cification sont de'finis de
manie`re compositionnelle. Nous expliquons maintenant comment les re`gles de typage
de MLF permettent de typer (1) mais rejettent (2).

En ML, la re`gle de typage d'une *-abstraction est restreinte, afin de permettre l'infe'rence de type. Plus pre'cise'ment, le typage de *(x) a permet seulement d'assigner un
monotype au type de x (c'est-a`-dire un type non polymorphe). En MLF, nous utilisons
la me^me technique : les *-abstractions ne peuvent introduire que des monotypes dans
l'environnement de typage. Toutefois, le typage de (1) requiert manifestement un type
polymorphe pour x. L'astuce est d'assigner une variable de type a` x, disons ff, et de
lier ff a` un type polymorphe dans un pre'fixe. Alors, une variable lie'e par un * telle
que x rec,oit le monotype ff qui repre'sente un type polymorphe gra^ce au pre'fixe. Une
proprie'te' fondamentale du pre'fixe est que ses variables sont "abstraites", c'est-a`-dire
qu'elles sont cache'es pour les re`gles de typage. Pour continuer l'exemple, nous disons
que la variable ff est une abstraction du type polymorphe oeid. Afin d'utiliser x comme
une expression polymorphe, il est ne'cessaire au pre'alable de re've'ler son polymorphisme,
ce qui se fait par le moyen d'une annotation de type. Bien entendu, l'annotation sur x
doit correspondre a` la borne de ff dans le pre'fixe.

Pour re'sumer, les re`gles de typage de MLF sont e'nonce'es sous un pre'fixe. Alors,
les variables de type peuvent repre'senter des polytypes en ajoutant la liaison correspondante dans le pre'fixe. Toutefois, l'information contenue dans le pre'fixe ne peut pas
e^tre utilise'e pour typer l'expression : une annotation de type explicite est requise pour
re've'ler le type polymorphe associe' a` une variable de type. Remarquer, cependant, qu'il
n'est pas ne'cessaire de re've'ler le type d'une expression qui n'est pas utilise'e de manie`re
polymorphe. De plus, une caracte'ristique essentielle de MLF est que les variables de
type peuvent toujours e^tre instancie'es implicitement par des types polymorphes. Pour
illustrer ceci, conside'rer l'application (*(x) x id) auto (en rappelant que auto est de'fini
comme *(x : oeid) x x). Cette expression est typable telle quelle dans MLF, c'est-a`-dire
sans application de type ni annotation de type --excepte' bien su^r dans la de'finition
me^me de auto. Le type de x est polymorphe (c'est le type de auto), mais x n'est pas

23

24 Introduction
utilise' de manie`re polymorphe. Ainsi, le type de x peut e^tre garde' abstrait si bien que sa
re've'lation n'est pas ne'cessaire. En fait, la ge'ne'ralisation de cet exemple est la fonction
app *(f ) *(x) f x, dont le type principal dans MLF est 8 (ff, fi) (ff ! fi) ! ff ! fi. Il
est remarquable que si a1 a2 est typable dans MLF, alors app a1 a2 l'est aussi, sans aucune annotation de type supple'mentaire ou aucune application de type. Ceci comprend
e'galement les cas ou` a1 requiert une valeur polymorphe comme argument, comme dans
app auto id. Nous pre'tendons que ces exemples sont importants en pratique car il
mode'lisent des ite'rateurs (e.g. app) applique's a` des fonctions polymorphes (e.g. auto)
et a` des structures contenant des valeurs polymorphes (e.g. id).

Pour conclure, les re`gles de typage de MLF de'finissent une spe'cification compositionnelle. La technique consiste a` enrichir les jugements de typage avec un pre'fixe qui
lie les variables de type a` des polytypes, et ne permet qu'aux annotations explicites de
type de re've'ler le polytype associe' a` une variable. Inversement, il est possible d'abstraire implicitement un polytype par une variable de type. Ceci se formalise en MLF par
une relation sous pre'fixe appele'e abstraction. Ainsi, MLF be'ne'ficie de trois relations sur
les types : l'e'quivalence, l'abstraction, et l'instance. Plus pre'cise'ment, l'instance inclut
l'abstraction, et l'abstraction inclut l'e'quivalence. La relation inverse de l'abstraction
est appele'e la re've'lation. Elle est utilise'e par les annotations de type pour re've'ler un
polytype abstrait dans le pre'fixe. L'abstraction et la re've'lation jouent un ro^le clef dans
l'infe'rence de type en imposant une distinction claire entre les informations de type
explicites et infe're'es, ce qui constitue l'essence de MLF.

Variantes de MLF

Tous les programmes ML sont typables dans MLF tels quels. De plus, tous les programme de Syste`me F peuvent e^tre encode's dans MLF en effac,ant les abstractions de
type et les applications de type. Ainsi, MLF semble e^tre suffisamment expressif. Toutefois, subject reduction ne peut pas s'exprimer de manie`re simple dans MLF (les re`gles
de re'duction concernant les annotations de type ne'cessiteraient des calculs globaux sur
la de'rivation de typage du programme). C'est pour cette raison que nous conside'rons
une variante MLF? ou` les annotations de type sont remplace'es par un emplacement permettant une re've'lation, appele' un oracle. Par exemple, en utilisant le symbole ? pour
l'oracle, *(x : ?) x x appartient a` MLF? car *(x : oeid) x x appartient a` MLF. Puisque
les annotations de type sont remplace'es par des oracles, les re`gles de re'duction s'expriment de manie`re simple et ne ne'cessitent pas de calculs globaux sur la de'rivation
de typage. Subject reduction et progress sont prouve's pour MLF?. Alors, la su^rete' du
typage s'ensuit dans MLF? et, indirectement, dans MLF.

En fait, la formalisation de MLF? est parame'tre'e par une collection de primitives, ce
qui permet d'inclure MLF dans MLF? en conside'rant les annotations de type comme cer24

Introduction 25
taines de ces primitives, et en interdisant les oracles dans les programmes source. Ainsi,
bien que nous nous inte'ressons in fine au syste`me MLF, la plupart des de'veloppements
techniques ont lieu dans MLF?.

Autres travaux

Ce travail a un rapport avec tous les autres travaux qui visent a` faire de l'infe'rence
de type en pre'sence de polymorphisme. Le plus proche des ces travaux est sans conteste
Poly-ML [GR99], qui s'inscrit lui-me^me dans la continuite' d'autre travaux :

Polymorphisme encapsule'

Des propositions ante'rieures [Re'm94, OL96] capturent le polymorphisme de premie`re classe dans les datatypes. Dans ces syste`mes, un programme doit inclure des
de'finitions de type pre'liminaires pour tous les types polymorphes qui sont cite's dans le
programme. Par exemple, le programme suivant de'finit deux variantes de auto et les
applique a` id :

type sid = Sid of 8ff. ff ! ff
let id = Sid (*(x) x)
let auto1 x = match x with Sid x' ! x' x'
let auto2 x = match x with Sid x' ! x' x
(auto1 id, auto2 id)

Noter la diffe'rence entre auto1 et auto2 : le premier retourne l'identite' non encapsule'e ;
le second retourne l'identite' encapsule'e.

Nous voyons que le type sid est utilise' a` la fois comme un constructeur pour la
cre'ation de la valeur polymorphe id (deuxie`me ligne) et comme un destructeur dans la
lambda-abstraction (troisie`me et quatrie`me lignes). En pratique, du sucre syntaxique
permet de de'finir auto1 de la manie`re suivante :

let auto1 (Sid x) = x x
Poly-ML re'alise un progre`s par rapport a` ces propositions car la coercion des monotypes vers les polytypes est une simple marque, inde'pendante du type coerce'. Ainsi, les
types polymorphes n'ont pas besoin d'e^tre de'finis (attache's a` un constructeur) avant
leur utilisation, bien qu'il soit toujours possible de le faire.

L'exemple ci-dessus peut maintenant s'e'crire comme suit :

let id = [*(x) ! x : 8ff. ff ! ff]
let auto1 (x:8ff. ff ! ff) = hxi hxi
let auto2 (x:8ff. ff ! ff) = hxi x
(auto1 id, auto2 id)

25

26 Introduction
La cre'ation explicite d'une valeur polymorphe est toujours ne'cessaire a` la premie`re
ligne. Cependant, l'utilisation d'une valeur polymorphe (deuxie`me et troisie`me lignes)
est plus facile car la coercion depuis la valeur encapsule'e x vers une valeur polymorphe
s'e'crit simplement hxi. Noter que l'abstraction d'une valeur polymorphe requiert une
information de type explicite mais que son utilisation requiert seulement une marque.

Toutefois, Poly-ML n'est pas totalement satisfaisant car l'information de type explicite ne'cessaire a` la cre'ation d'une valeur polymorphe encapsule'e (premie`re ligne) reste
trop redondante : un programmeur peut-il accepter de devoir e'crire un type qui est
de'ja` infe're' par le syste`me de types ?

La proposition de Odersky et La"ufer [OL96] pre'sente en re'alite' deux aspects : le
premier me'canisme est celui de'crit pre'ce'demment ; un second me'canisme permet dans le
me^me syste`me une forme de quantification pre'dicative. En pratique, l'exemple ci-dessus
peut s'e'crire d'une nouvelle manie`re :

let id = *(x) x
let auto (x:8ff. ff ! ff) = x x
auto id

C'est e'galement la manie`re dont ce programme est e'crit en MLF. Cependant, cette
forme de quantification est pre'dicative chez Odersky et La"ufer [OL96], alors qu'elle est
impre'dicative chez MLF. Cette diffe'rence entre les deux syste`mes est fondamentale :
alors qu'ils permettent tout deux de typer l'expression *(x : oe) a pour n'importe quel
sche'ma de type oe, l'encapsulation est requise pour passer cette fonction comme une valeur de premie`re classe, et par exemple la placer dans une liste. En MLF, cette fonction
peut e^tre manipule'e comme n'importe quelle autre valeur, sans aucune forme d'encapsulation explicite. Un autre exemple : dans le syste`me d'Odersky et La"ufer, si f a est
typable, alors il n'est pas garanti que app f a soit typable aussi. Ainsi, cette forme
restreinte de polymorphisme pre'dicatif limite la compositionnalite'. De plus, l'encodage
du Syste`me F donne' par Odersky et La"ufer n'utilise jamais les annotations sur les *-
abstractions, mais seulement les datatypes polymorphes. En re'alite', la quantification
pre'dicative et les datatypes polymorphes sont deux me'canismes inde'pendants qui ne
peuvent conduire qu'a` un style de programmation non uniforme, en ce qui concerne le
polymorphisme de premie`re classe.

MLF prolonge toutes ces propositions : les annotations de type ne sont requises que
sur certaines lambda-abstractions et aucune sorte de coercion explicite entre les types
polymorphes et les types polymorphes encapsule's dans des monotypes n'est jamais ne'cessaire. De plus, MLF est un syste`me de types impre'dicatif et l'encodage du Syste`me F
dans MLF est une transformation locale des expressions qui se contente d'effacer les abstractions de type et les applications de type. Au contraire, les encodages base's sur les

26

Introduction 27
datatypes polymorphes doivent analyser le programme dans son inte'gralite', c'est-a`-dire
toute la de'rivation de typage ; la transformation n'est pas locale et les de'finitions de
constructeurs de type introduites peuvent e^tre parfois complique'es (cf. lifting des types
chez Odersky et La"ufer [OL96]).

L'encodage du Syste`me F dans Poly-ML ne requiert pas ces de'finitions auxiliaires ;
cependant, chaque valeur polymorphe doit e^tre encapsule'e en utilisant une annotation
de type explicite, comme dans let id = [fun x !x : 8ff. ff!ff]. En conse'quence,
l'encodage d'une expression donne'e du Syste`me F peut e^tre plus grande que l'expression initiale. En MLF, les valeurs polymorphes sont cre'es implicitement ; ainsi, aucune
annotation explicite n'est requise. De plus, l'encodage du Syste`me F produit toujours
des expressions plus petites.

Une nouvelle extension du travail d'Odersky et La"ufer est celle re'alise'e par Peyton
Jones et Shields [JS04] ; nous l'e'voquons plus loin.

Fragments du Syste`me F

D'autres approches conside`rent des fragments du Syste`me F et tentent d'effectuer
de l'infe'rence de types. Le polymorphisme de rang limite' a` 2 permet l'infe'rence totale [KW94, Jim95]. Il est inte'ressant de noter que ce syste`me, que Jim appelle \Lambda 2,
type les me^mes programmes que I2, le syste`me des types intersection de rang 2 [Jim95].
Comme de'ja` e'voque' plus haut, ces approches ne sont pas compositionnelles a` cause de
la limitation de rang. Puisque le polymorphisme de premier ordre re'pond justement au
besoin d'abstraction supple'mentaire, cette restriction fondamentale ne nous semble pas
acceptable : seulement les abstractions sur des valeurs ML sont possibles, ce qui n'est
tout simplement pas assez. En outre, l'algorithme donne' pour \Lambda 2 proce`de par re'duction
du programme source et ne semble pas tre`s intuitif. Pire, cet algorithme ne peut s'appliquer que sur des programmes complets : il n'est pas possible de typer des modules
de bibliothe`ques se'pare'ment. Noter que l'algorithme donne' par Trevor Jim pour I2 a
de meilleures proprie'te's, notamment celle des typages principaux. Cependant, l'e'quivalence entre I2 et \Lambda 2 est prouve'e par re'e'criture du programme, et donc, bien que I2
parvienne a` infe'rer les types de manie`re modulaire, cela ne permet pas de construire
un typage modulaire dans \Lambda 2.

Notre manie`re de traiter les annotations comme des primitives re've'lant les types
e'voque les fonctions de retypage (fonctions qui se comportent comme l'identite') [Mit88].
Cependant, nos annotations sont explicites et ne contiennent que certaines formes des
fonctions de retypage. L'infe'rence de type pour le Syste`me F modulo j-expansion est
e'galement inde'cidable [Wel96].

Plusieurs groupes ont conside're' l'infe'rence partielle dans le Syste`me F [JWOG89,
Boe85, Pfe93] et e'tabli des re'sultats d'inde'cidabilite' pour certaines variantes. Par
exemple, Boehm [Boe85] et Pfenning [Pfe93] conside`rent les programmes du Syste`me F

27

28 Introduction
ou` les *-abstractions peuvent e^tre sans annotation, et seulement les emplacements des
applications de type sont donne's, sans l'argument de type. Ils montrent tous deux que
l'infe'rence de type dans ce syste`me est inde'cidable en encodant l'unification de secondordre. Les deux encodages reviennent a` introduire une *-abstraction non annote'e dont
l'argument est utilise' de manie`re polymorphe. Ceci est pre'cise'ment ce que nous e'vitons
dans MLF : toutes les *-abstraction polymorphes doivent e^tre annote'es, alors que les
abstractions et les applications de type sont infe're'es.

Un autre travail concernant les fragments du Syste`me F est celui de Schubert [Sch98]
qui conside`re les sequent decision problems a` la fois pour le Syste`me F a` la Curry et
pour le Syste`me F a` la Church. Un sequent decision problem dans le Syste`me F a` la
Curry correspond a` l'infe'rence de type dans le Syste`me F, comme celle conside're'e par
Wells [Wel94], et tous les types de proble`mes conside're's sont re'pute's inde'cidables.

Un proble`me inte'ressant dans le Syste`me F a` la Church consiste a` trouver un environnement de typage \Gamma  qui permette de typer un programme M donne' (le terme M est
entie`rement annote'). Schubert montre que ce proble`me est inde'cidable en ge'ne'ral en
encodant une forme restreinte d'unification du second ordre, qu'il montre e'quivalente
au proble`me de l'arre^t des automates a` deux compteurs. Ainsi, alors que le programme
est entie`rement annote', la connaissance de l'environnement de typage reste ne'cessaire
pour que le typage soit de'cidable. Fort heureusement, c'est l'approche utilise'e dans
MLF, exactement comme en ML. Au contraire, les syste`mes base's sur les types intersection, et plus ge'ne'ralement les syste`mes visant a` e'tablir des typages principaux
doivent infe'rer a` la fois le type et l'environnement de typage.

Unification de second ordre

L'unification de second ordre, bien que fameusement inde'cidable, a e'te' utilise'e pour
explorer la mise en pratique de l'infe'rence dans le Syste`me F par Pfenning [Pfe88].
Bien que nous faisions le choix oppose', c'est-a`-dire de ne pas faire d'unification de
second ordre, deux comparaisons au moins peuvent e^tre faites. D'abord, le travail de
Pfenning ne couvre pas le langage ML en soi, mais seulement le *-calcul puisque les
let sont remplace's avant l'infe'rence. En effet, ML n'est pas le *-calcul simplement
type' et l'infe'rence de type en ML ne peut pas, en pratique, se ramener a` l'infe'rence de
type dans le *-calcul simplement type' apre`s expansion des let. D'autre part, l'un des
syste`mes semble reque'rir des annotations exactement la` ou` l'autre les infe`re : dans le
syste`me de Pfenning [Pfe88], des marques doivent e^tre place'es aux abstractions de type
et aux applications de type (sans plus d'information), mais pas d'annotation de type.
Dans MLF, la situation est exactement inverse'e : des annotations de type sont requises
sur certains arguments des *-abstractions.

Notre proposition est implicitement parame'tre'e par la relation d'instance entre les
types et l'algorithme d'unification correspondant. Ainsi, la plupart des de'tails tech28

Introduction 29
niques peuvent e^tre encapsule's dans cette relation d'instance. Il serait souhaitable d'interpre'ter notre notion d'unification comme un cas particulier d'unification de secondordre. Dans ce but, il faudrait sans doute conside'rer une approche modulaire base'e
sur des contraintes de l'unification de second-ordre [DHKP96]. Les bornes flexibles de
MLF peuvent peut-e^tre capturer, en un seul type principal, ce que les algorithmes base's
sur des contraintes capturent comme des e'quations partiellement re'solues. Un autre
exemple d'unification restreinte avec des termes de second ordre est l'unification sous
un pre'fixe mixte [Mil92]. Il faut remarquer toutefois que notre notion de pre'fixe et que
son ro^le d'abstraction de polytypes est nettement diffe'rente. En particulier, les pre'fixe
mixtes mentionnent des quantificateurs universels et existentiels (d'ou` leur nom), alors
que les pre'fixes de MLF sont quantifie's universellement. De plus, MLF associe une borne
a` chaque variable, alors que les pre'fixes mixtes sont toujours non borne's.

En fait, aucun des travaux mentionne's ne conside`re le sous-typage. Ceci marque une
diffe'rence notable avec les travaux base'es sur l'infe'rence locale [Car93, PT98, OZZ01]
ou` le sous-typage est requis. L'ajout de sous-typage a` MLF reste a` explorer.

L'infe'rence de type locale

La diffe'rence principale entre l'infe'rence locale [PT98] et l'approche suivie pour
MLF est que la premie`re e'vite l'unification globale et ne re'concilie (match) les sche'mas de type qu'aux noeuds d'application du programme : les informations de type ne
peuvent se propager qu'entre noeuds adjacents. Le re'sultat est un moyen astucieux de
me^ler le sous-typage et une forme d'infe'rence de type pour le Syste`me F. La motivation de l'infe'rence locale est avant tout pratique. En conse'quence, aucune traduction
syste'matique du Syste`me F n'est donne'e (a` part l'identite'), ce qui aurait pu illustrer la
quantite' d'annotations de type requise dans une traduction automatique. Les auteurs
donnent pluto^t une mesure de la quantite' d'information requise sur des programmes
ML existants. Quoiqu'il en soit, le style de programmation impose' par l'infe'rence locale
exige que les de'finitions "top-level" soient annote'es et que le polymorphisme soit introduit explicitement. Tous les programmes ML ne sont pas typables tels quels, y compris
en ajoutant les annotations a` top-level et les abstractions de type : certaines annotations peuvent e^tre ne'cessaires en profondeur. L'une des difficulte's provient des fonctions
anonymes ainsi que des arguments "difficiles a` synthe'tiser" [HP99]. Par exemple, l'application app f x peut ne pas e^tre typable si f est polymorphe3. Les types principaux
sont force's en trouvant syste'matiquement un "meilleur argument" chaque fois qu'un
type polymorphe est instancie'. Si aucun argument n'est le meilleur, le typeur e'met une
erreur. De telles erreurs ne sont pas possibles en ML ni en MLF, car toute expression
typable admet un type principal. Remarquer toutefois que trouver le "meilleur argu3Le proble`me disparai^t dans la forme non-currifie'e, mais la transformation n'est pas toujours possible, ou peut revenir a` introduire une fonction anonyme avec une annotation de type explicite.

29

30 Introduction
ment", et donc infe'rer des types principaux pour l'infe'rence locale, est nettement plus
difficile a` cause du sous-typage.

L'infe'rence locale colore'e [OZZ01] se pre'sente comme une ame'lioration de l'infe'rence
locale, bien que certains termes typables dans ce dernier syste`me ne le soient pas dans
le premier. Cette nouvelle approche consiste a` permettre a` des informations de type
partielles d'e^tre propage'es.

Au dela` de l'introduction du sous-typage, l'infe'rence locale apporte une ide'e originale, a` savoir que les annotations de type peuvent e^tre propage'es le long du programme
source en suivant des re`gles bien de'termine'es. Intuitivement, ces re`gles peuvent e^tre
comprises comme un pre'-processing du programme source. Un tel me'canisme est utilise' dans le compilateur Haskell GHC, et peut e'galement e^tre ajoute' au langage MLF,
comme explique' au chapitre 11.

Et pendant ce temps, a` Cambridge

Adaptant les ide'es provenant a` la fois du travail d'Odersky et La"ufer et du travail
sur l'infe'rence locale, Peyton Jones et Shields ont conc,u un algorithme d'infe'rence de
types pour des rangs arbitraires [JS04]. Leur syste`me de types utilise une restriction de
la relation de containment de Mitchell [Mit88], qui est contravariante sur le domaine des
types fle`ches et covariante sur leur codomaine. Ceci constitue une premie`re diffe'rence
avec MLF, ou` la relation d'instance est toujours covariante (en particulier sur le domaine
ou le codomaine des types fle`che). Conside'rons un exemple du papier de Peyton Jones
et Shields [JS04].

Nous supposons que les fonctions g, k1 et k2 respectent la signature suivante :

val g : ((8fi. fi list ! fi list) ! int) ! int
val k1 : (8ff. ff ! ff) ! int
val k2 : (int list ! int list) ! int

Par subsomption,
(8ff. ff ! ff) ! int
est moins polymorphe que
(8fi. fi list ! fi list) ! int
En conse'quence, (g k1) n'est pas typable chez Peyton Jones et Shields, alors que (g k2)
l'est. En MLF, le type associe' a` g est 8 (fl = 8 (fi) fi list ! fi list) (fl ! int) !
int (1). Ainsi, aucune des deux expressions (g k1) et (g k2) n'est typable, parce que
MLF n'admet aucune forme de contravariance.

Ne'anmoins, le syste`me de types de MLF contient des bornes flexibles, qui peuvent
re'soudre ce cas particulier. Plus pre'cise'ment, le type de g indique que c'est une fonction

30

Introduction 31
qui attend un argument x de type (8fi.fi list ! fi list) ! int. Ainsi, x doit e^tre
une fonction attendant un argument de type 8fi.fi list ! fi list. Supposons qu'un
terme h soit une fonction de ce type. Alors, g peut se de'finir par :

let g (x:(8fi. fi list ! fi list) ! int) = x h
Nous voyons que x n'est pas utilise' de manie`re polymorphe, et donc la de'finition suivante est e'galement typable dans MLF :

let g2 x = x h
De plus, le type principal infe're' pour g2 est 8 (fl >= 8fi.fi list ! fi list) 8 (ffi) (ff !
ffi) ! ffi (2). En comparant (1) et (2), nous voyons que la liaison rigide de fl est remplace'e
par une liaison flexible. Alors la variable de type fl repre'sente 8fi.fi list ! fi list ou
n'importe laquelle de ses instances, y compris int list ! int list. En conse'quence,
(g2 k2) est typable dans MLF (et (g2 k1) n'est toujours pas typable parce que la borne
de fl ne peut s'instancier en 8ff.ff ! ff).

Ainsi, bien que MLF ne be'ne'ficie d'aucune forme de contravariance, il peut ne'anmoins typer certains exemples qui, a` premie`re vue, semble reque'rir la contravariance.

Une autre diffe'rence entre le syste`me de Peyton Jones et Shields et MLF est que le
premier est pre'dicatif. Alors, comme de'ja` explique', la compositionnalite' est restreinte ;
les structures de donne'es ne peuvent pas accueillir des valeurs polymorphes ; les fonctions ge'ne'riques ne peuvent pas s'appliquer a` des valeurs polymorphes. Nous pensons
que ceci constitue une limitation conside'rable. Un exemple tre`s simple est fourni par
l'expression [auto] (c'est-a`-dire, auto dans une liste singleton).

En outre, ce syste`me emprunte des ide'es de l'infe'rence locale, a` savoir la propagation
des informations de type vers l'inte'rieur des termes, qui est formalise'e dans la spe'cification du syste`me de types. En MLF, la propagation des annotations de type peut e^tre
effectue'e avant le typage, par un simple me'canisme syntaxique inde'pendant du typage.
Ceci apporte des proprie'te's comparables, telles que la propagation des informations
de type depuis les fichiers d'interface vers les fichiers d'imple'mentation. Toutefois, ceci
reste un me'canisme auxiliaire, qui ne joue qu'un ro^le mineur dans MLF.

Noter cependant que la metathe'orie de Peyton Jones et Shields est plus simple que
celle de MLF. Pour le programmeur, toutefois, il n'est pas clair quel syste`me est le plus
simple a` utiliser.

Organisation de ce document

L'expressivite' de MLF repose essentiellement sur son syste`me de types, alors que
sa se'mantique statique et dynamique est pratiquement identique a` celle de ML. Cette
combinaison de types plus expressifs et d'une se'mantique a` la ML conduit a` un langage

31

32 Introduction
avec polymorphisme de premie`re classe. Les types sont de'finis et e'tudie's partie I. Les
se'mantiques statique et dynamique sont de'finies et e'tudie'es partie II. L'expressivite' de
MLF est aborde'e partie III.

Partie I : Les Types Les types sont de'finis au chapitre 1 ; ils sont compose's de
monotypes et de polytypes. Les monotypes sont des types monomorphes, sans quantificateurs. Les polytypes sont des types d'ordre supe'rieur, et consistent en une se'quence
de quantificateurs, appele'e un pre'fixe, devant un monotype. La relation d'e'quivalence
(j) et la relation d'instance (v) sont alors de'finies, ainsi qu'une relation interme'diaire,
la relation d'abstraction (@-). Les deux premie`res correspondent a` des extensions des
relations correspondantes de ML. Quant a` la relation d'abstraction, elle n'a pas de
contrepartie en ML. C'est une relation re'versible, comme l'e'quivalence, mais seulement
explicitement, c'est-a`-dire par le biais d'annotations de type dans le code source. On
l'utilise pour distinguer entre l'information sur les types qui a e'te' infe're'e et celle qui
a e'te' donne'e explicitement. Le chapitre 2 rassemble plusieurs proprie'te's utiles sur les
types et leurs relations. Certains de ces re'sultats sont des extensions directes de re'sultats identiques en ML, e'tendus au cadre plus ge'ne'ral de MLF. D'autres re'sultats n'ont
pas de contrepartie en ML4, et notamment ceux concernant la relation d'abstraction.
Les trois relations sur les types induisent les relations correspondantes sur les pre'fixes.
Les pre'fixes ge'ne'ralisent la notion de substitution en permettant, intuitivement, la substitution de variables de types par des polytypes. Les types et les substitutions sont
au coeur du syste`me de types de ML. De manie`re similaire, les types et les pre'fixes
contiennent l'expressivite' de MLF. Le chapitre 3 se concentre sur les pre'fixes. Comme
pour les proprie'te's sur les types, les proprie'te's sur les pre'fixes ge'ne'ralisent des re'sultats
sur les substitutions en ML, dans un cadre plus large. Le travail effectue' sur les types
et les pre'fixes est utilise' au chapitre 4, ou` l'algorithme d'unification est prouve' correct
et complet. Comme l'on peut s'y attendre, l'algorithme d'unification est une extension
de l'algorithme d'unification de ML qui manipule des polytypes, et retourne un pre'fixe
au lieu d'une substitution.

Partie II : Le langage de programmation Comme explique' dans l'introduction,
nous de'finissons le langage MLF?, qui est constitue' des expressions de ML enrichies par
une construction appele'e un oracle. La diffe'rence entre ML et MLF? provient essentiellement de leurs syste`mes de types respectifs, pas seulement de l'oracle. L'oracle est
une simple marque sur une expression qui permet, explicitement, d'inverser la relation
d'abstraction. Les oracles ne contribuent pas a` la re'duction des expressions mais sont
propage's. Les expressions et la se'mantique dynamique de MLF? sont de'crites chapitre 5,
ainsi que la se'mantique statique. Celle-ci est similaire a` celle de ML : les re`gles de ty4En fait, ces re'sultats sont souvent triviaux lorsqu'ils sont e'nonce's dans le cadre de ML.

32

Introduction 33
page sont seulement enrichies par un pre'fixe. En ML, toutes les bornes des variables du
pre'fixe sont sans contraintes, et il est donc laisse' implicite. Une re`gle de typage supple'mentaire est ne'cessaire pour l'oracle ; elle permet d'inverser la relation d'abstraction.
Ensuite, comme en ML, un syste`me dirige' par la syntaxe est donne'. L'objectif d'un
syste`me de types est la su^rete', c'est-a`-dire qu'un programme bien type' se comporte
bien. Le chapitre 6 prouve la su^rete' de MLF?. La su^rete' pour MLF, qui correspond a`
MLF? sans oracles, s'ensuit. Comme sugge're' par leur appellation, les oracles ne peuvent
pas e^tre devine's. Plus pre'cise'ment, les oracles inversent la relation d'abstraction, ce
qui est su^r, (la su^rete' du typage est pre'serve'e), mais empe^che l'infe'rence de type. En
effet, le chapitre 7 introduit l'algorithme d'infe'rence qui est prouve' correct et complet
pour MLF, mais pas pour MLF?, ou` le proble`me de l'infe'rence est probablement inde'cidable. En re'sume', un langage plus riche est introduit, MLF?, qui permet de montrer
la su^rete' du typage dans MLF. Cependant MLF est le langage destine' a` e^tre utilise'
et qui be'ne'ficie de l'infe'rence de type. Comme MLF est cense' e^tre plus expressif que
ML, il reste a` expliquer comment introduire le polymorphisme d'ordre supe'rieur alors
que les deux langages sont identiques. En fait, le chapitre 8 montre que MLF pur et
ML sont e'quivalents. Ensuite, nous introduisons les annotations de type comme un
ensemble de primitives et montrons que la su^rete' du typage est maintenue. Quelques
exemples montrent comment les primitives "annotations de type" peuvent e^tre utilise'es pour introduire du polymorphisme d'ordre supe'rieur. L'algorithme d'infe'rence de
type maintient simplement l'information donne'e par les annotations de type pre'sentes
dans le code source. L'expressivite' de MLF avec des annotations est conside're'e dans la
troisie`me partie.

Partie III : L'expressivite' de MLF L'inte're^t de MLF est parai^t-il d'e^tre un langage
avec polymorphisme de premie`re classe. Nous e'tayons cette affirmation en proposant
un encodage de Syste`me F dans MLF. Dans le chapitre 9, cette encodage est prouve' correct, c'est-a`-dire que l'encodage d'une expression typable dans le Syste`me F est typable
dans MLF. Il est notable que l'encodage se contente d'effacer les abstractions de type
et les abstractions de type de sorte qu'un programme MLF est toujours plus petit que
le programme Syste`me F e'quivalent. Le chapitre 10 s'inte'resse a` la question oppose'e :
Peut-on encoder MLF dans le Syste`me F ? Nous conside'rons d'abord une restriction de
MLF, Shallow MLF, ou` les annotations ne peuvent e^tre que des types du Syste`me F. Ensuite nous montrons que le Syste`me F peut e^tre encode' dans Shallow MLF. Inversement,
nous proposons une interpre'tation des types de Shallow MLF, et montrons que chaque
typage dans Shallow MLF correspond a` un ou plusieurs typage dans le Syste`me F. En
conse'quence, Shallow MLF et le Syste`me F ont le me^me ensemble de termes typables, si
l'on efface les informations de type. Nous utilisons cette e'quivalence entre Shallow MLF
et Syste`me F pour discuter des diffe'rences entre MLF et le Syste`me F. Ensuite, en conside'rant MLF comme une base pour un vrai langage de programmation, nous examinons

33

34 Introduction
quelques extensions utiles dans le chapitre 11. Par exemple, les re'fe'rences peuvent e^tre
incluses dans MLF. Toutefois, comme pour ML, la ge'ne'ralisation doit e^tre restreinte
et nous conside'rons la restriction habituelle nomme'e "value-only polymorphism". Une
restriction plus utile, invente'e par Jacques Garrigue [Gar02] est e'galement pre'sente'e et
discute'e. En second exemple, nous montrons comment les annotations de type peuvent
e^tre propage'es des fichiers d'interface vers les fichiers d'imple'mentation en suivant une
proce'dure simple. Finalement, le chapitre 12 donne un aperc,u de MLF en pratique.
Nous donnons quelques exemples e'crits en MLF et teste's avec notre prototype.

34

Introduction 35
Conventions

Tout au long de ce manuscrit, nous distinguerons quatre sortes d'e'nonce's : les
lemmes, corollaires, proprie'te's, et the'ore`mes. Un lemme e'tablit un seul re'sultat, en ge'ne'ral utilise' pour de'montrer d'autres re'sultats. Plusieurs re'sultats mineurs sont parfois
rassemble's dans un seul e'nonce'. Chacun de ces re'sultats est alors appele' proprie'te'. Les
proprie'te's servent en ge'ne'ral a` de'montrer des lemmes. Un corollaire est toujours e'nonce'
apre`s un re'sultat dont il est une conse'quence directe. Un the'ore`me est un re'sultat fondamental de la the`se.

Les preuves sont donne'es a` la suite de l'e'nonce' concerne', ou bien de'place'es en
Appendice A lorsqu'elles sont similaires a` des preuves pre'ce'dentes, ou trop longues et
d'un inte're^t limite'. De plus, un nombre tre`s re'duit de re'sultats ne sont pas prouve's
dans cette the`se ; le lecteur devrait pouvoir les de'montrer sans aucune difficulte'.

Certains e'nonce's locaux, tels que les re'sultats interme'diaires dans les preuves ou
certaines constructions introduites localement, sont parfois e'tiquete'es avec un nombre
souligne' comme ceci (1). Ils sont ensuite cite's de cette manie`re (1). Voici un exemple
complet :

Epime'nide est un Cre'tois (2). Epime'nide dit : <<Tous les Cre'tois sont des
menteurs.>> (3). Nous concluons de (2) et (3) que Epime'nide ment (4),
c'est-a`-dire qu'il existe au moins un Cre'tois qui n'est pas un menteur. Nous
savons (4) que Epime'nide n'est pas ce Cre'tois (5). En conse'quence de (2)
et (5), il existe au moins deux Cre'tois.

Les re`gles d'infe'rence sont e'crites en petites majuscules, comme par exemple pour la
re`gle R-Trans. Certaines re`gles de'rivables sont e'galement introduites. Leur nom finit
syste'matiquement par une e'toile, comme par exemple Eq-Mono?. Toutes les re`gles
d'infe'rence de cette the`se sont rassemble'es dans un index, page 319. Ces re`gles servent
a` construire des de'rivations, de la manie`re habituelle. Sauf mention spe'cifique, la taille
d'une de'rivation est le nombre de re`gles qu'elle mentionne.

Nous utilisons le symbole

M= pour nommer explicitement un e'le'ment. Par exemple

nous e'crivons o/

M= o/1 ! o/2 pour e'noncer que, a` partir de maintenant, o/ signifie o/1 ! o/2.

35

36 Introduction
Noter la diffe'rence avec o/ = o/1 ! o/2 qui indique que l'objet o/ , de'ja` de'fini, se trouve
e^tre e'gal a` o/1 ! o/2.

Notation Une se'quence ou un ensemble seront note's _x. Par exemple, _ff est un ensemble de variables de type. Nous utiliserons e'galement les lettres I et J pour de'signer
certains ensembles non ordonne's de variables de type. Un index de toutes les notations
utilise'es se trouve page 322.

En accord avec les conventions habituelles, l'application d'un *-terme est associative
a` gauche, et la porte'e d'un lieur *(x) s'e'tend a` droite autant que possible. En ce qui
concerne les types, la fle`che ! est associative a` droite, et le quantificateur 8 (ff) s'e'tend
a` droite autant que possible.

36

37
Premie`re partie

Les Types

37

39
Chapitre 1
Types, pre'fixes et
relations sous pre'fixes

Comme explique' dans l'introduction, MLF utilise une nouvelle syntaxe pour les
types, qui autorise la quantification de premie`re classe.

En ML, les monotypes sont de simples types sans quantificateur et les polytypes
(ou sche'mas de types) sont une liste de variables quantifie'es 8 ( _ff) suivies par un monotype, par exemple 8 (ff, fi) ff ! fi. En MLF e'galement, nous distinguons monotypes et
polytypes. Les monotypes sont similaires aux monotypes de ML. Quant aux polytypes,
ils sont plus e'labore's : la liste des variables quantifie'es associe une borne avec chaque
variable. Par exemple, 8 (ff1 >= oe1, ff2 = oe2) est une quantification correcte en MLF. Une
liste de variables avec leur borne est appele'e un pre'fixe. Pour poursuivre l'exemple,
(ff1 >= oe1, ff2 = oe2) est un pre'fixe valide en MLF. La premie`re quantification, celle de ff1
est dite flexible et sa borne pourra e^tre instancie'e. La seconde quantification, celle de
ff2 est dite rigide. Le polymorphisme de sa borne ne pourra pas e^tre instancie'. Intuitivement, les bornes rigides correspondent au type des arguments dont le polymorphisme
est requis. Quant aux bornes flexibles, elles correspondent au type des arguments qui
se trouvent e^tre polymorphes, mais non contraints a` l'e^tre.

Les types et pre'fixes sont introduits dans les sections 1.1 et 1.2, respectivement.
Ensuite, la section 1.3 de'finit les occurrences dans un type, les variables libres et les
substitutions.

L'expressivite' d'un syste`me de types repose sur les relations entre les types. En MLF,
trois relations sur les types composent une hie'rarchie : l'e'quivalence (j), l'abstraction
(@-) et l'instance (v). Ces trois relations sont de'finies sous pre'fixe, ce qui signifie que
nous e'crivons (Q) oe1 v oe2 au lieu de oe1 v oe2. Le pre'fixe Q associe une borne a`
chaque variable libre de oe1 et oe2. Les relations d'e'quivalence, d'abstraction et d'instance
sont de'crites dans les sections 1.5, 1.6 et 1.7, respectivement. De plus, nous montrons

39

40 Types, pre'fixes et relations sous pre'fixe
section 1.5 que les types ont une unique forme canonique, modulo commutation des
quantificateurs inde'pendants. Cela signifie que la relation d'e'quivalence est capture'e
par une notion de forme canonique.

1.1 Syntax of types

The syntax of types is the following :

o/ ::= ff | gn o/1 .. o/n Monotypes
oe ::= o/ | ? | 8 (ff >= oe) oe | 8 (ff = oe) oe Polytypes

We distinguish between monotypes and polytypes. By default, "types" refers to the
more general form, i.e. to polytypes. The syntax of monotypes is parameterized by an
enumerable set of type variables ff 2 # and a family of type symbols g 2 G given with
their arity |g|. To avoid degenerate cases, we assume that G contains at least a symbol
of arity two (the infix arrow !) and a symbol of arity zero (e.g. unit). We write g n if
g is of arity n. As shown by the definition, a monotype is either a type variable in #,
or a constructed type gn o/1 .. o/n. An example of constructed type is (!) o/ o/ 0, which
we write o/ ! o/ 0. As in ML, monotypes do not contain quantifiers.

Polytypes generalize ML type schemes. They are either a monotype o/ , bottom
(written ?), or a binding quantified in front of a polytype, that is, 8 (ff >=oe) oe 0 or 8 (ff =
oe) oe0. Inner quantifiers as in System F cannot be written directly inside monotypes.
However, they can be simulated with types of the form 8 (ff = oe) oe0, which stands,
intuitively, for the polytype oe0 where all occurrences of ff would have been replaced
by the polytype oe. Noticeably, our notation contains additional meaningful sharing
information. Finally, the general form 8 (ff >= oe) oe0 intuitively stands for the collection
of all polytypes oe0 where ff is an instance of oe. We say that ff has a rigid bound in
(ff = oe) and a flexible bound in (ff >= oe). Intuitively, the polytype ? corresponds to the
ML scheme 8ff.ff. More precisely, it is made equivalent to 8 (ff >= ?) ff. Actually, ML
type schemes can be seen as polytypes of the form 8 (ff1 >= ?) . . . 8 (ffn >= ?) o/ with
outer quantifiers. Indeed, a particular case of flexible bound is the unconstrained bound
(ff >= ?), which we abbreviate as (ff).

Notations Given a sequence ff1, . . . ffn of variables, we define the type rff1,...ffn as
an abbreviation for ff1 ! . . . ! ffn ! unit. We write _o/ for tuples of types, and _ff # _fi
means that the sets _ff and _fi are disjoint. For convenience, we write (ff \Pi  oe) for either
(ff = oe) or (ff >= oe). The symbol \Pi  acts as a meta-variable and two occurrences or more
of \Pi  in the same context mean that they stand for = or all stand for >=. To allow
independent choices we use indices like in \Pi 1 and \Pi 2 for unrelated occurrences.

40

1.2 Pre'fixes 41
1.2 Prefixes

A polytype is a sequence of bindings, called a prefix, in front of a monotype. As
remarked in the introduction, the expressiveness of types essentially comes from the
expressiveness of prefixes. Indeed, the only difference between ML polytypes and MLF
polytypes lie in their bindings, that is, in their prefixes.

A prefix Q is a sequence of bindings (ff1 \Pi 1 oe1) . . . (ffn \Pi n oen) where variables
ff1, . . . ffn are pairwise distinct and form the domain of Q, which we write dom(Q). The
order of bindings in a prefix is significant : bindings are meant to be read from left
to right ; furthermore, we require the variables ffj not to occur in oei whenever i <= j
(up to ff-conversion of bound variables). As an example, (ff >= ?, fi = ff ! ff) is well
formed, but (ff = fi ! fi, fi >= ?) is not. A prefix is called unconstrained when it is of
the form (ff1 >= ?, . . . ffn >= ?). One can consider that in ML, the prefix is implicit and
unconstrained.

Notations Since ff1, . . . ffn are pairwise distinct, we can unambiguously write (ff\Pi oe) 2
Q to mean that Q is of the form (Q1, ff \Pi  oe, Q2).

We write rQ for rdom(Q), Q # Q0 for dom(Q) # dom(Q0), and 8 (Q) oe for the
type 8 (ff1 \Pi 1 oe1) . . . 8 (ffn \Pi n oen) oe.

1.3 Occurrences

In this section, we define a projection function which maps occurrences in the domain of a given type to a type symbol such as ?, a type constructor, or a type variable.
We first introduce skeletons which are trees representing the projection function.

1.3.1 Skeletons
Definition 1.3.1 Skeletons are defined by the following grammar :

t ::= ff | ? | gn t1 .. tn

Substitutions are defined on skeletons in the obvious way. Since skeletons do not bind
any variables, substitutions on skeletons are always capture-avoiding. The substitution
of ff by t0 is written [t0/ff]. We write t[t0/ff] for the skeleton t where ff is substituted by
t0. Substitutions on skeletons are written \Theta .

1.3.2 Projections

An occurrence is a sequence of natural numbers. We write ffl for the empty sequence,
and kn for the sequence k, . . . , k of length n (and, in particular, k0 is ffl). The projection

41

42 Types, pre'fixes et relations sous pre'fixe
function maps pairs t/u composed of a skeleton t and an occurrence u to a type symbol,
that is, to an element of the set {?} [ # [ G. It is defined inductively by the following
rules :

?/ffl = ? ff/ffl = ff gn t1 .. tn/ffl = g i 2 1..ngn t

1 .. tn/iu = ti/u

We write t/ for the projection function u 7! t/u. We note that the projection t/ is
isomorphic to t.

Definition 1.3.2 The projection of an MLF-type oe to a skeleton, written proj(oe), is
defined inductively as follows :

proj(o/ ) = o/ proj(?) = ? proj(8 (ff \Pi  oe) oe0) = proj(oe0)[proj(oe)/ff]
Given a prefix Q equal to (ff1 \Pi 1 oe1, . . . ffn \Pi n oen), we define \Theta Q as the idempotent
substitution on skeletons [proj(oe1)/ff1] ffi . . . ffi [proj(oen)/ffn] (it is the composition of n
elementary substitutions).

We write oe/ for the function proj(oe)/. We call occurrences of a polytype oe the domain
of the function oe/, which we abbreviate as dom(oe). Notice that dom(oe) is a set of
occurrences, while dom(Q) is a set of variables. We write oe * u/ to denote the function
u0 7! oe/uu0. Note that oe * ffl/ is equal to the projection oe/.

Example 1.3.1 Occurrences ignore quantifiers and only retain the structure of types.
For instance, the polytypes oe1

M= 8 (ff >= ?) ff ! ff and oe2 M= 8 (fi = ?) 8 (fl >= ?) fi ! fl

have the same occurrences, that is, oe1/ = oe2/. Equivalently, proj(oe1) and proj(oe2) are
both equal to ? ! ?. More precisely, the domains of both oe1 and oe2 are equal to
{ffl, 1, 2} and both oe1/ffl and oe2/ffl are equal to !. Additionally, oe1/1, oe1/2, oe2/1 and
oe2/2 are all equal to ?.

Properties 1.3.3 The following properties hold, for any prefix Q and types oe, oe1, oe2 :

i) proj(8 (Q) oe) is \Theta Q(proj(oe)).
ii) If oe1/ = oe2/, then (8 (Q) oe1)/ = (8 (Q) oe2)/.

Proof: Property i : It is shown by induction on the size of Q. If Q is ;, then \Theta Q is
the identity, and the result follows. Otherwise, Q is (ff \Pi  oe0, Q0) and proj(8 (Q) oe) is
proj(8 (ff \Pi  oe0) 8 (Q0) oe) by notation, that is, proj(8 (Q0) oe)[proj(oe0)/ff] (6) by definition.
By induction hypothesis on Q0, proj(8 (Q0) oe) is \Theta Q0(proj(oe)). Hence by (6), proj(8 (Q) oe)
is (\Theta Q0 (proj(oe0)))[proj(oe0)/ff], that is, ([proj(oe0)/ff] ffi \Theta Q0)(proj(oe0)). We get the expected
result by observing that [proj(oe0)/ff] ffi \Theta Q0 is \Theta Q by definition. Property ii : We have by
hypothesis oe1/ = oe2/, that is, proj(oe1) = proj(oe2). Hence, \Theta Q(proj(oe1)) = \Theta Q(proj(oe2))
holds, which gives proj(8 (Q) oe1) = proj(8 (Q) oe2) by Property i. By definition, this
means that 8 (Q) oe1/ = 8 (Q) oe2/ holds.

42

1.3 Occurrences 43
1.3.3 Free type variables and unbound type variables

In ML, type variables that appear in a type are either bound or free. In MLF, the set
of free variables is only a subset of unbound variables. For example, consider the type oe
equal to 8 (ff =fi ! fi) fl ! fl. Since ff is bound but not used, oe is considered equivalent
to fl ! fl. Hence, fl is free in oe, while fi is only unbound. We give the two definitions
for unbound variables and free variables. To ease the presentation, free variables are
defined using skeletons.

Definition 1.3.4 A type variable ff is free in oe if there exists an occurrence u such
that oe/u is ff. We write ftv(oe) the set of free type variables of oe. The set of unbound
type variables of oe, written utv(oe), is defined inductively as follows :

utv(ff)

M= {ff} utv(gn o/1 .. o/n) M= [

i21..n

utv(o/i) utv(?)

M= ;

utv(8 (ff \Pi  oe) oe0)

M= \Gamma utv(oe0) - {ff}\Delta  [ utv(oe)

The definition of free variables is equivalent to the usual inductive definition. In particular, we have the usual properties ftv(ff) = {ff} (since ff/ffl = ff), and ftv(o/1 ! o/2) =
ftv(o/1) [ ftv(o/2) (since (o/1 ! o/2)/u = ff holds if and only if u is of the form iv (a number
i followed by a path v) such that o/i/v = ff). Moreover, the given definition amounts
to considering that ff is bound in oe0, but not in oe in the polytype 8 (ff \Pi  oe) oe0. That
is, ftv(8 (ff \Pi  oe) oe0) is (ftv(oe0) - {ff}) [ ftv(oe) if ff is free in oe0, and ftv(oe0) otherwise.
Indeed, by definition, fi is free in 8 (ff \Pi  oe) oe0 if and only if there exists u such that
(proj(oe0)[proj(oe)/ff])/u = fi. We see that fi is free in 8 (ff \Pi  oe) oe0 if and only if fi is
free in oe0 and is not ff, or ff is free in oe0 and fi is free in oe. Additionally, we note
that utv(o/ ) = ftv(o/ ) for any monotype o/ . Moreover, it is straightforward to check by
structural induction that ftv(oe) ` utv(oe) holds for any oe.

By extension, the free variables of a set of types {oe1, . . . oen} is defined as the unionS

i=1..n ftv(oei). Similarly, we write utv(oe1, . . . , oen) for the union Si=1..n utv(oei). A po-lytype is closed if it has no unbound type variable. When

utv(oe) ` dom(Q), we also

say that oe is closed under prefix Q. We define utv(Q) as utv(8 (Q) ?). When utv(Q) is
empty, that is, 8 (Q) ? is closed, we say that Q is a closed prefix.

ff-conversion Polytypes are considered equal modulo ff-conversion where 8 (ff \Pi  oe) oe 0
binds ff in oe0, but not in oe. Let Q be (ff1 \Pi 1 oe1, . . . ffn \Pi n oen). Note that the ffi's can
be renamed in the type 8 (Q) oe, but not in the stand-alone prefix Q. For instance,
8 (ff >= ?) ff ! ff is considered equal to 8 (fi >= ?) fi ! fi, but (ff >= ?) and (fi >= ?) are
distinct prefixes. We easily check that free variables and unbound variables are stable
under ff-conversion.

43

44 Types, pre'fixes et relations sous pre'fixe
1.3.4 Renamings and substitutions

Given a function f from type variables to monotypes (typically a renaming or a
substitution, as defined next), we define the domain of f , written dom(f ), as the set of
type variables ff such that f (ff) 6= ff. The codomain of f , written codom(f ), is the set
ftv(f (dom(f ))), that is, Sff2dom(f) ftv(f (ff)). Such functions are extended to types and
type schemes in the obvious way, by avoiding capture of bound variables. An idempotent
function f is such that f ffi f = f , this amounts to having dom(f ) # codom(f ). The
composition f1 ffi f2 is well-formed if we have codom(f1) # dom(f2). A function is said
invariant on _ff whenever dom(f ) # _ff.

A renaming OE is an idempotent function mapping type variables to type variables
that is injective on the finite set dom(OE). Renamings are bijective from their domain to
their codomain, but are never bijective on # (except the identity). A renaming OE is said
disjoint from _ff whenever _ff # dom(OE) [ codom(OE) holds. If OE is a renaming, we write
OE~ for the inverse renaming, whose domain is codom(OE) and codomain is dom(OE). More
precisely, for every fi in codom(OE), we define OE~(fi) as ff such that OE(ff) = fi. We say
that OE is a renaming of a set _ff if OE is a renaming and if dom(OE) ` _ff and codom(OE) # _ff
hold. For example, the swapping ff 7! fi, fi 7! ff is bijective on # but is not a renaming.
The mapping ff 7! fi is a renaming, though, and its inverse fi 7! ff is a renaming too.
Note that OE~ ffi OE is not the identity, but is OE~ (which is invariant on dom(OE), though).
Conversely, OE ffi OE~ is OE.

A substitution ` is an idempotent function mapping type variables to monotypes
such that dom(`) is finite. Any renaming is also a substitution. We write id for the
identity on type variables, considered as a substitution.

Notation The capture-avoiding substitution of ff by o/ in oe is written oe[o/ /ff]. Given
a prefix Q equal to (ffi \Pi i oei)i2I , and a substitution `, we define `(Q) as (`(ffi) \Pi i `(oei))
provided that ` restricted to dom(Q) is a renaming of dom(Q). In particular, if OE is a
renaming of dom(Q), then OE(Q) is a well-formed prefix. Note also that 8 (OE(Q)) OE(o/ )
is alpha-convertible to 8 (Q) o/ . Additionally, if ` is a substitution such that dom(Q) #
dom(`) [ codom(`) holds, then `(Q) is the prefix (ffi \Pi i `(oei))i2I .

Example 1.3.2 As already mentioned, types only allows quantifiers to be outermost,
or in the bound of other bindings. Therefore, the type 8 ff * (8 fi * (o/ [fi] ! ff)) ! ff of
System F cannot be written directly. (Here, o/ [fi] means a type o/ in which the variable
fi occurs.) However, it can be represented in MLF by the type 8 (ff) 8 (fi0 = 8 (fi) o/ [fi] !
ff) fi0 ! ff. In fact, all types of System F can easily be represented as polytypes
by recursively binding all occurrences of inner polymorphic types to fresh variables
beforehand (an encoding from System F into MLF is given in Section 9.2). In this
translation, auxiliary variables are used in a linear way. For instance, (8 ff*o/ ) ! (8 ff*o/ )
is translated into 8 (ff1 = 8 (ff) o/ ) 8 (ff2 = 8 (ff) o/ ) ff1 ! ff2. Intuitively, 8 (ff0 = 8 (ff)

44

1.3 Occurrences 45
o/ ) ff0 ! ff0 could also represent the same System F type, more concisely. However, this
type is not equivalent to the previous one, but only an abstraction of it, as explained
further.

Graphs For illustration purposes, we represent types as graphs throughout this document. More precisely, a type can be represented by two DAGs (Directed Acyclic
Graphs) sharing the same set of nodes. The nodes are labelled with either a type symbol g, ?, or a type variable. The first DAG corresponds to the symbolic structure of a
type. The second DAG corresponds to its binding structure. For example, we consider
the type of the identity, oeid, equal to 8 (ff >= ?) ff ! ff. Its skeleton is ? ! ?. Such a
representation ignores that the left-hand side and the right-side of the arrow correspond
to the same variable ff. In graphs, we make this information explicit by sharing the two
nodes, as shown below :

!

?
In this graph, we show explicitly that the left-hand child and the right-hand child of
the arrow are both the type variable ff. The bottom node represents ff, and is therefore
labelled by the bound of ff, that is ?.

It remains to represent the binding structure of the type. We use dotted arrows and
dashed arrows to represent, respectively, flexible bindings and rigid bindings. To pursue
the above example, the node labelled by ?, which corresponds to the type variable ff, is
bound at top-level. This binding is flexible, thus it is represented by a dotted arrow :

!

?
For the sake of comparison, the type 8 (ff >= ?, fi = ?) ff ! fi is represented by the
following graph, where ff is represented by the left-hand node, and fi by the right-hand
node.

!

? ?

45

46 Types, pre'fixes et relations sous pre'fixe
As another example, the representation of 8 (ff >= ?) 8 (fi = 8 (fl >= ?) fl ! ff) fi ! ff
is given below. The middle node represents fi, it is rigid and bound at top-level, hence
the dashed arrow. The leftmost node is fl, it is bound at the level of fi (that is, fl is
introduced syntactically in the bound of fi) and it is flexible, hence the dotted arrow
from this node to the middle node representing fi. The rightmost node is ff, it is flexible
and bound at top-level.

!

!
? ?
Although graphs are only a convenient representation of types, they may be used as a
basis for an implementation.

Types are meant to be instantiated implicitly as in ML along an instance relation
v. As explained in the introduction, we also consider an abstraction relation @- and
its inverse relation A- that is used by annotations to reveal a polymorphic type. In
Section 1.5, we first define an equivalence relation between types, which is the kernel
of both @- and v. In Section 1.6, we define the relation @-. The instance relation v,
which contains @-, is defined in Section 1.7. All these relations have common properties
captured by the notion of relations under prefix, as defined in the following section.

1.4 Relations under prefix

The equivalence, abstraction, and instance relation of MLF, as well as auxiliary
relations introduced later in the thesis, are all relations under prefix. The prefix is
meant to bind all unbound variables of considered types. In the following definition, ""
is meant to be replaced by either j, @-, or v.

Definition 1.4.1 A relation under prefix "" is a relation on triples composed of a wellformed prefix Q and two types oe1 and oe2 such that utv(oe1, oe2) ` dom(Q). It is written
(Q) oe1 "" oe2.

By notation oe1 "" oe2 means (Q) oe1 "" oe2 for some unconstrained prefix Q such that
utv(oe1, oe2) ` dom(Q).

The relations under prefix we consider in this document are all meant to be used
transitively. While some of these relations are transitive by definition (such as the

46

1.4 Relations sous pre'fixe 47
equivalence, abstraction, and instance relations), some other relations are first defined
non-transitively, and then extended with transitivity. Hence the following definition :

Definition 1.4.2 A relation under prefix "" is said transitive if and only if it satisfies
the following rule :

R-Trans

(Q) oe1 "" oe2 (Q) oe2 "" oe3

(Q) oe1 "" oe3

Given a relation "", we write ""* for its transitive closure, that is, ""* is the smallest
relation containing "" and satisfying Rule R-Trans.

Relations under prefix are also meant to operate under the leading prefix of a type.
For example, if oe1 "" oe2 holds, we expect 8 (Q) oe1 "" 8 (Q) oe2 to hold too. This can be
captured by a single rule :

R-Context-R

(Q, ff \Pi  oe) oe1 "" oe2 ff /2 dom(Q)

(Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe2

Some rules can also operate on the bounds of the leading prefix. For example, if oe1 "" oe2
holds, we may have 8 (ff >= oe1) oe "" 8 (ff >= oe2) oe. A similar example could be given with
a rigid bound instead of a flexible bound. This is captured by the two following rules

R-Context-Flexible

(Q) oe1 "" oe2

(Q) 8 (ff >= oe1) oe "" 8 (ff >= oe2) oe

R-Context-Rigid

(Q) oe1 "" oe2

(Q) 8 (ff = oe1) oe "" 8 (ff = oe2) oe

Definition 1.4.3 A relation under prefix "" is said flexible-compliant iff it satisfies rules
R-Context-Flexible and R-Context-R. It is said rigid-compliant iff it satisfies
rules R-Context-Rigid and R-Context-R. It is said congruent iff it satisfies these
three rules.

When a relation is congruent, it satisfies the following rule, which stands for both
R-Context-Flexible and R-Context-Rigid, thanks to the meta-variable \Pi .

R-Context-L

(Q) oe1 "" oe2

(Q) 8 (ff \Pi  oe1) oe "" 8 (ff \Pi  oe2) oe

The three following sections define the equivalence, abstraction, and instance relations, respectively. As expected, the equivalence is a congruent relation. The abstraction
relation happens to be a rigid-compliant relation, and the instance relation is a flexiblecompliant relation.

47

48 Types, pre'fixes et relations sous pre'fixe

Fig. 1.1 - Type equivalence under prefix
Eq-Refl
(Q) oe j oe

Eq-Free

ff /2 ftv(oe1)

(Q) 8 (ff \Pi  oe) oe1 j oe1

Eq-Comm

ff1 /2 ftv(oe2) ff2 /2 ftv(oe1) ff1 6= ff2

(Q) 8 (ff1 \Pi 1 oe1) 8 (ff2 \Pi 2 oe2) oe j 8 (ff2 \Pi 2 oe2) 8 (ff1 \Pi 1 oe1) oe

Eq-Var
(Q) 8 (ff \Pi  oe) ff j oe

Eq-Mono

(ff \Pi  oe0) 2 Q (Q) oe0 j o/0

(Q) o/ j o/ [o/0/ff]

1.5 Type equivalence

The order of quantifiers and some other syntactical notations are not always meaningful. Such syntactic artifacts are captured by a notion of type equivalence. As expected, the equivalence relation is symmetric, that is, if (Q) oe1 j oe2 holds, then
(Q) oe2 j oe1 holds too.

Definition 1.5.1 (Equivalence) The equivalence under prefix j is the smallest symmetric, transitive, and congruent relation under prefix that satisfies the rules of Figure 1.1.

Rule Eq-Comm allows the reordering of independent binders ; Rule Eq-Free eliminates unused bound variables. Rule Eq-Mono allows the reading of the bound of a
variable from the prefix when it is (equivalent to) a monotype. An example of use of
Eq-Mono is (Q, ff = o/0, Q0) ff ! ff j o/0 ! o/0. Rule Eq-Mono makes no difference
between >= and = whenever the bound is equivalent to a monotype. The restriction of
Rule Eq-Mono to the case where oe0 is equivalent to a monotype is required for the
well-formedness of the conclusion. Moreover, it also disallows (Q, ff = oe0, Q0) ff j oe0 :
variables with polymorphic bounds must be treated abstractly and cannot be silently expanded. In particular, we do not wish (Q) 8 (ff =oe0, ff0 =oe0) ff ! ff0 j 8 (ff =oe0) ff ! ff
to hold.

Rule Eq-Var expands into both 8 (ff = oe) ff j oe and 8 (ff >= oe) ff j oe. The former
captures the intuition that 8 (ff = oe) oe0 stands for oe0[oe/ff], which however, is not always
well-formed. The latter may be surprising : it states that oe is an instance of 8 (ff >= oe) ff,
and conversely. On the one hand, the interpretation of 8 (ff >= oe) ff as the set of all ff

48

1.5 La relation d'e'quivalence 49
where ff is an instance of oe implies (intuitively) that oe itself is an instance of 8 (ff>=oe) ff.
On the other hand, however, it is not immediate to consider 8 (ff >= oe) ff, that is, the
set of all instance of oe, as an instance of oe. Actually, we could remove this second part
of the equivalence without changing the set of typable terms. However, it is harmless
and allows for a more uniform presentation.

Reasoning under prefixes makes it possible to break a polytype 8 (Q) oe and "look
inside under prefix Q". For instance, it follows from iterations of Rule R-Context-R
that (Q) oe j oe0 suffices to show (;) 8 (Q) oe j 8 (Q) oe0.

Definition 1.5.1 mentions that j is a symmetric relation. Therefore, in the proofs, we
implicitly assume that each rule defining equivalence is symmetric. Actually, it suffices
to consider only the symmetric variants of rules Eq-Var, Eq-Mono, and Eq-Free.
Indeed, the other rules are already symmetric by construction.

It is not necessary to bind explicitly a monotype, as in 8 (ff = o/ ) ff ! ff. Indeed,
this type is equivalent to o/ ! o/ . More generally, the following rule is derivable with
rules R-Context-R, R-Context-L, Eq-Mono, R-Trans, and Eq-Free :

Eq-Mono?

(Q) oe0 j o/

(Q) 8 (ff \Pi  oe0) oe j oe[o/ /ff]

Conversely, replacing Eq-Mono by Eq-Mono? would restrict the set of judgments.
Indeed, whereas Eq-Mono is derivable by Eq-Mono? under an empty prefix, it is not
the case under an arbitrary prefix. For a counter-example, (fi, ff = fi ! fi) ff j fi ! fi
holds by Eq-Mono, but it is not derivable if only Eq-Mono? is allowed and not
Eq-Mono.

In graphs, monotypes are nodes not binding any other node. Rules Eq-Mono and
Eq-Mono? state that such nodes can be equivalently duplicated. For example, the
following equivalence holds by Eq-Mono? :

8 (ff >= ?) 8 (fi = ff ! ff) fi ! fi j 8 (ff >= ?) (ff ! ff) ! (ff ! ff)
This means that the two following graphs are considered equivalent :

!

! !

?

!
!

?

49

50 Types, pre'fixes et relations sous pre'fixe
All other equivalence rules, namely Eq-Refl, Eq-Free, Eq-Var, and Eq-Comm are
already captured by graphs.

The following rule is derivable with rules Eq-Free and Eq-Var :

Eq-Var?

(ff \Pi  oe) 2 Q

(Q0) 8 (Q) ff j 8 (Q) oe

1.5.1 Rearrangements

Normal forms will be unique, up to commutation of independent binders, that is,
up to Rule Eq-Comm. We define an equivalence relation that captures only such a
reordering of binders.

Definition 1.5.2 The relation ss is the smallest equivalence relation satisfying the
following rules :

oe1 ss oe2
8 (ff \Pi  oe) oe1 ss 8 (ff \Pi  oe) oe2

oe1 ss oe2
8 (ff \Pi  oe1) oe ss 8 (ff \Pi  oe2) oe

ff1 /2 ftv(oe2) ff2 /2 ftv(oe1) ff1 6= ff2
8 (ff1 \Pi 1 oe1) 8 (ff2 \Pi 2 oe2) oe ss 8 (ff2 \Pi 2 oe2) 8 (ff1 \Pi 1 oe1) oe

When oe1 ss oe2 holds, we say that oe1 is a rearrangement of oe2. When 8 (Q1) ? ss 8 (Q2) ?
holds, we say that Q1 is a rearrangement of Q2.

Note that the relation 8 (Q1) rQ1 ss 8 (Q2) rQ1 mentions rQ1 (that is, a type mentioning all type variables of dom(Q1)) on both sides. Thus, it prevents implicit ff-conversion
of the domain of Q1 between 8 (Q1) rQ1 and 8 (Q2) rQ1.

Properties 1.5.3

i) If oe ss o/ , then oe = o/ .
ii) If oe1 ss oe2 holds and ` is a substitution, then `(oe1) ss `(oe2) holds.
iii) If oe1 ss oe2, then (Q) oe1 j oe2 holds for any well-formed prefix Q such that we have

utv(oe1, oe2) ` dom(Q)
iv) If Q0 ss Q and (Q) oe1 j oe2 hold, then (Q0) oe1 j oe2.

v) If QQ0 is well-formed and (Q) oe1 j oe2 holds, then (QQ0) oe1 j oe2 holds.

Proof: Property i : It only states that any rearrangement of a monotype o/ is o/ itself.
Property ii : It is shown by induction on the derivation of oe1 ss oe2.
Property iii : By definition ss is a binary relation. Let .ss be the relation on triples defined
as (Q) oe1 .ssoe2 if and only if oe1 ss oe2 holds and Q is well-formed. Then .ss is the smallest

50

1.5 La relation d'e'quivalence 51

relation satisfying rules Eq-Refl, R-Trans, R-Context-R, R-Context-L, and EqComm (where j is replaced by .ss). Consequently, .ss is included in j. Therefore, if oe1 ss oe2
holds, then (Q) oe1 j oe2 holds for any well-formed Q binding the variables of utv(oe1, oe2).

Property iv : It is shown by induction on the derivation of (Q) oe1 j oe2. Cases Eq-Refl,
Eq-Free, Eq-Comm, and Eq-Var are immediate. Cases R-Trans and R-Context-L
are by induction hypothesis. Case R-Context-R is by induction hypothesis, observing
that (Q, ff\Pi oe0) is a rearrangement of (Q0, ff\Pi oe0). As for Eq-Mono, oe1 is o/ , oe2 is o/ [o/0/ff],
and the premises are (ff \Pi  oe0) 2 Q and (Q) oe0 j o/0. By induction hypothesis, we have
(Q0) oe0 j o/0 (1). Since Q0 is a rearrangement of Q, we have (ff \Pi  oe00) 2 Q0, where oe00
is a rearrangement of oe0. Hence, (Q0) oe0 j oe00 (2) holds by property iii. Consequently,
(Q0) oe00 j o/0 holds by R-Trans, (1), and (2). Then (Q0) oe1 j oe2 holds by Rule EqMono.

Property v : It is a subcase of the following, more general property :

If Q1Q2Q3 is well-formed, and if (Q1Q3) oe1 j oe2 holds, then (Q1Q2Q3) oe1 j
oe2 holds.

It is shown by induction on the derivation of (Q1Q3) oe1 j oe2.

1.5.2 Occurrences and equivalence

Occurrences--and therefore free type variables--are stable under type equivalence :

Properties 1.5.4

i) If (QQ0) oe1 j oe2 holds and Q is unconstrained, then 8 (Q0) oe1/ = 8 (Q0) oe2/.
ii) We have o/1 j o/2 iff o/1 is o/2.
iii) If oe1 j oe2 holds, then ftv(oe1) = ftv(oe2).

Proof: Property i : By definition of occurrences, it suffices to show that whenever (QQ0)
oe1 j oe2 (1) holds, then proj(8 (Q0) oe1) and proj(8 (Q0) oe2) are equal. The proof is by
induction on the derivation of (1). Case R-Trans is by induction hypothesis. In Cases
Eq-Refl, Eq-Free, Eq-Comm, and Eq-Var, we have proj(oe1) = proj(oe2), thus we get
the expected result by Property 1.3.3.ii (page 42). Remaining cases are:

ffi Case R-Context-L: We have oe1 = 8 (ff \Pi  oe01) oe (2), oe2 = 8 (ff \Pi  oe02) oe (3), and
the premise is (QQ0) oe01 j oe02. By ff-conversion, we can freely assume that ff is not in
dom(QQ0). We have proj(8 (Q0) oe01) = proj(8 (Q0) oe02) by induction hypothesis, that is,
\Theta Q0 (proj(oe01)) = \Theta Q0(proj(oe02)) (4). Hence, we have the following, where i can be 1 or 2:

proj(8 (Q0) oei) = proj(8 (Q0) 8 (ff \Pi  oe0i) oe) by (2) or (3)

= \Theta Q0(proj(8 (ff \Pi  oe0i) oe)) by Property 1.3.3.i (page 42)
= \Theta Q0(proj(oe)[proj(oe0i)/ff]) by Definition 1.3.2
= \Theta Q0(proj(oe))[\Theta Q0 (proj(oe0i))/ff] (5)

51

52 Types, pre'fixes et relations sous pre'fixe

Additionally, by (4), we get

\Theta Q0 (proj(oe))[\Theta Q0 (proj(oe01))/ff] = \Theta Q0(proj(oe))[\Theta Q0 (proj(oe02))/ff] (6)
Hence, proj(8 (Q0) oe1) = proj(8 (Q0) oe2) holds by (5) and (6).

ffi Case R-Context-R: We have oe1 = 8 (ff \Pi  oe) oe01, oe2 = 8 (ff \Pi  oe) oe02, and the premise is (QQ0, ff \Pi  oe) oe01 j oe02. By induction hypothesis, we get proj(8 (Q0, ff \Pi  oe) oe01) =
proj(8 (Q0, ff \Pi  oe) oe02), which is the expected result.

ffi Case Eq-Mono: We have oe1 = o/ and oe2 = o/ [o/0/ff]. The premises are (QQ0) oe0 j
o/0 (7) and (ff \Pi  oe0) 2 QQ0. Necessarily, (ff \Pi  oe0) is in Q0 (8) because Q is unconstrained
by hypothesis. By induction hypothesis and (7), we get proj(8 (Q0) oe0) = proj(8 (Q0) o/0),
which gives \Theta Q0(proj(oe0)) = \Theta Q0(proj(o/0)) (9) by Property 1.3.3.i (page 42). We have

proj(8 (Q0) o/ ) = \Theta Q0(o/ ) by Property 1.3.3.i (page 42)

= \Theta Q0(o/ [\Theta Q0 (proj(oe0))/ff]) by (8) and Definition 1.3.2
= \Theta Q0(o/ [\Theta Q0 (proj(o/0))/ff]) by (9)
= \Theta Q0(o/ [o/0/ff]) by Definition 1.3.2
= proj(8 (Q0) o/ [o/0/ff]) by Property 1.3.3.i (page 42)

This is the expected result

Property ii: Assume o/ j o/ 0. By definition, this means that we have (;) o/ j o/ 0. Hence, by
Property i, we have o/ / = o/ 0/, that is proj(o/ )/ = proj(o/ 0)/. Hence, the skeletons proj(o/ )
and proj(o/ 0) are equal. Since by definition proj(o/ ) is o/ and proj(o/ 0) is o/ 0, we have the
expected result, that is, o/ = o/ 0.

Property iii : It is a direct consequence of property i.

1.5.3 Canonical forms for types

In this section, we define a function nf that maps all equivalent types to the same
normal form, up to rearrangement.

Definition 1.5.5 We define the function nf(oe) inductively as follows :

nf(?)

M= ? nf(o/ ) M= o/ nf(8 (ff \Pi  oe) oe0) M= 8????!????:

nf(oe) if nf(oe0) is ff
nf(oe0)[o/ /ff] if nf(oe) is o/
nf(oe0) if ff /2 ftv(oe0)
8 (ff \Pi  nf(oe)) nf(oe0) otherwise

If nf(oe) = oe, we say that oe is in normal form.

We state here some useful properties about normal forms.

52

1.5 La relation d'e'quivalence 53
Properties 1.5.6 The following hold for any type oe and any substitution ` :

i) nf(oe) j oe.
ii) ftv(oe) = ftv(nf(oe)).
iii) nf(`(oe)) = `(nf(oe)).

iv) nf(oe) is in normal form.

These properties are shown by induction on the number of universal quantifiers appearing in oe. The full proof can be found in Appendix (page 231).

In MLF, we distinguish monotypes o/ and polytypes oe. Actually, we also need to
spot monotypes up to equivalence, that is, polytypes that are equivalent to monotypes.
Similarly, we spot type variables up to equivalence, that is, polytypes that are equivalent
to type variables.

Definition 1.5.7 The set of polytypes oe such that nf(oe) = o/ for some monotype o/
is written T . The set of polytypes oe such that nf(oe) = ff for some type variable ff is
written V.

By Rule Eq-Mono?, R-Trans, and Property 1.5.6.i, if oe is in T , we have 8 (ff = oe)
oe0 j 8 (ff >= oe) oe0. This is the reason why, in the following, any binding (ff \Pi  oe) where oe
is in T is considered both flexible and rigid. In other words, flexibility is not meaningful
for a bound in T . This is not surprising since monotypes cannot be instantiated anyway.

Definition 1.5.8 The substitution extracted from a prefix Q, written bQ, is defined
by :

b; M= id "(ff \Pi  oe, Q0) M= ([nf(oe)/ff] ffi cQ0 if oe 2 Tc

Q0 otherwise

Notice that "Q1Q2 = cQ1 ffi cQ2 holds for any well-formed prefix Q1Q2. Besides, for
any oe and Q, we have (Q) oe j bQ(oe) by using Eq-Mono repeatedly. Note also that
the domain of bQ is the set of variables of dom(Q) whose bound is in T . Therefore,
dom( bQ) ` dom(Q) holds. This can be compared with the domain of \Theta Q, which is
always dom(Q).

As expected, normal forms capture the equivalence relation, up to commutation and
alpha-conversion of binders. Since the equivalence relation is defined under a prefix, it
has to be taken into account when comparing normal forms. This is stated precisely by
the following lemma :

Lemma 1.5.9 If (Q) oe1 j oe2 holds, then so does bQ(nf(oe1)) ss bQ(nf(oe2)).

53

54 Types, pre'fixes et relations sous pre'fixe

Proof: by induction on the derivation of (Q) oe1 j oe2.

ffi Case Eq-Refl : Immediate.
ffi Case R-Trans : By induction hypothesis and transitivity of the relation ss.
ffi Case Eq-Free : We have oe2 = 8 (ff \Pi  oe) oe1 and ff /2 ftv(oe1). By definition, nf(oe2) is
nf(oe1), thus bQ(nf(oe1)) is bQ(nf(oe2)), and bQ(nf(oe1)) ss bQ(nf(oe2)) holds.

ffi Case Eq-Comm : We have oe1 ss oe2 by hypothesis, thus bQ(nf(oe1)) ss bQ(nf(oe2)) holds
by Property 1.5.3.ii.

ffi Case Eq-Var: We have oe2 = 8 (ff \Pi  oe1) ff. By definition, nf(oe2) is nf(oe1), thus we
have bQ(nf(oe1)) = bQ(nf(oe2)), which implies bQ(nf(oe1)) ss bQ(nf(oe2)).

ffi Case R-Context-R: We have oe1 = 8 (ff \Pi  oe) oe01 and oe2 = 8 (ff \Pi  oe) oe02. The premise
is (Q, ff \Pi  oe) oe01 j oe02 (1). By induction hypothesis and (1), we have the rearrangement

"(Q, ff \Pi  oe)(nf(oe01)) ss "(Q, ff \Pi  oe)(nf(oe02)) (2). Note that (Q, ff \Pi  oe) is well-formed only if

ff /2 dom(Q), thus, ff /2 dom( bQ) [ codom( bQ) (3). We proceed by case analysis.

Subcase nf(oe) is o/ : Let ` be [o/ /ff]. We have "Q, ff \Pi  oe = bQ ffi `, thus, by (2), bQ ffi
`(nf(oe01)) ss bQ ffi `(nf(oe02)). Since nf(8 (ff \Pi  oe) oe01) is by definition `(nf(oe01)) and nf(8 (ff \Pi  oe)
oe02) is `(nf(oe02)), we have shown that bQ(nf(oe1)) ss bQ(nf(oe2)). In the following subcases,
we assume that nf(oe) is not a monotype o/ , which implies "Q, ff \Pi  oe = bQ (4). Note also
that bQ(ff) = ff (5) holds from (3). We have bQ(nf(oe01)) ss bQ(nf(oe02)) (6) from (4) and (2).

Subcase nf(oe01) is ff: From (6) and (5), we have ff ss bQ(nf(oe02)). By Property 1.5.3.i,
this gives bQ(nf(oe02)) = ff. Hence, nf(oe02) is ff by (3). By definition, nf(oe1) and nf(oe2) are
nf(oe), thus bQ(nf(oe1)) ss bQ(nf(oe2)) holds by reflexivity.

Subcase nf(oe02) is ff is similar.
Subcase ff /2 ftv(nf(oe01)): By (3), we get ff /2 ftv( bQ(nf(oe01))). By (6) and Property 1.5.4.iii, we get ff /2 ftv( bQ(nf(oe02))). By (3), we get ff /2 ftv(nf(oe02)). Hence, nf(oe1)
is nf(oe01) and nf(oe2) is nf(oe02), thus we get the result by (6).

Subcase ff /2 ftv(nf(oe02)) is similar.
Otherwise, nf(oe) is not equal to a monotype o/ , ff 2 ftv(nf(oe01)), ff 2 ftv(nf(oe02)),
nf(oe01) is not ff, and nf(oe02) is not ff. By definition nf(oe1) is 8 (ff\Pi  nf(oe)) nf(oe01) and nf(oe2)
is 8 (ff \Pi  nf(oe)) nf(oe02). From (6), we get 8 (ff \Pi  bQ(oe)) bQ(nf(oe01)) ss 8 (ff \Pi  bQ(oe)) bQ(nf(oe02)),
that is bQ(nf(oe1)) ss bQ(nf(oe2)).

ffi Case R-Context-L : We have oe1 = 8 (ff \Pi  oe01) oe and oe2 = 8 (ff \Pi  oe02) oe. The premise
is (Q) oe01 j oe02. By induction hypothesis, we have bQ(nf(oe01)) ss bQ(nf(oe02)) (7). We proceed
by case analysis :

Subcase nf(oe) is ff : Then nf(oe1) is nf(oe01) and nf(oe2) is nf(oe02), thus (7) is the
expected result.

Subcase ff /2 nf(oe) : nf(oe1) is nf(oe) and nf(oe2) is nf(oe). Hence, bQ(nf(oe1)) =b
Q(nf(oe2)), which implies the expected result.

54

1.5 La relation d'e'quivalence 55

Subcase nf(oe01) is o/1 : By induction hypothesis (7), nf(oe02) is a monotype o/2 such
that bQ(o/1) = bQ(o/2) (8) holds. By definition 1.5.5, nf(oe1) is nf(oe)[o/1/ff] (9) and nf(oe2)
is nf(oe)[o/2/ff] (10). Hence, we have :b

Q(nf(oe1)) = bQ(nf(oe)[o/1/ff]) by (9)

= bQ(nf(oe)[ bQ(o/1)/ff])
= bQ(nf(oe)[ bQ(o/2)/ff]) by (8)
= bQ(nf(oe)[o/2/ff])
= bQ(nf(oe2)) by (10)

This is the expected result.

Subcase nf(oe02) is o/2 is similar.
Otherwise, nf(oe1) is 8 (ff \Pi  nf(oe01)) nf(oe) and nf(oe2) is 8 (ff \Pi  nf(oe02)) nf(oe). Hence,
we have bQ(nf(oe1)) ss bQ(nf(oe2)) by (7).

ffi Case Eq-Mono : We have oe1 = o/ , oe2 = o/ [o/0/ff], (ff\Pi oe0) 2 Q (11), and (Q) oe0 j o/0.
By induction hypothesis, we have bQ(nf(oe0)) ss bQ(o/0), which implies bQ(nf(oe0)) = bQ(o/0)
by Property 1.5.3.i. Hence, nf(oe0) = o/ 0 (12) such that bQ(o/ 0) = bQ(o/0) (13). We haveb
Q(oe1) = bQ(o/ ) = bQ(o/ [o/ 0/ff]) (14) by (11), by definition of bQ, and by (12). We also haveb
Q(oe2) = bQ(o/ [o/0/ff]) = bQ(o/ [o/ 0/ff]) (15) by (13). Hence, bQ(oe1) = bQ(oe2) holds from (14)
and (15), that is, bQ(nf(oe1)) = bQ(nf(oe2)) since nf(oe1) = nf(o/ ) = o/ = oe1 and nf(oe2) = oe2.

The next corollary characterizes equivalence under prefix. It shows that the only
information that is used from the prefix Q is its associated substitution bQ.

Corollary 1.5.10 We have (Q) oe1 j oe2 iff bQ(oe1) j bQ(oe2).
See proof in the Appendix (page 232).

As a consequence, we have the following characterization of normal forms :

nf(oe) is a rearrangement of nf(oe0) iff (Q) oe j oe0 holds for any well-formed
prefix Q such that utv(oe, oe0) ` dom(Q).

Next is a set of properties used throughout the thesis. For instance, Property i states
that equivalent types have equal normal form, up to rearrangement. Property v shows
that equivalence is preserved under substitution. Property vii shows that equivalent
monotypes are actually equal, up to the substitution extracted from the prefix. Property viii will be used directly for showing the soundness of the unification algorithm. It
states that two types are equivalent (under a given prefix) if and only if their subparts
are equivalent.

55

56 Types, pre'fixes et relations sous pre'fixe
Properties 1.5.11 For any polytypes oe, oe1, oe2, any well-formed prefix Q, and any
substitution `, we have :

i) If oe1 j oe2, then nf(oe1) ss nf(oe2).
ii) oe is in T iff oe j o/ for some monotype o/
iii) oe is in V iff oe j ff for some type variable ff

iv) `(oe) is in T iff oe is in T .

v) If oe1 j oe2, then `(oe1) j `(oe2).
vi) If (Q) oe1 j oe2, then bQ(oe1)/ = bQ(oe2)/.
vii) (Q) o/1 j o/2 iff bQ(o/1) = bQ(o/2).
viii) (Q) g o/1 . . . o/n j g0 o/ 01 . . . o/ 0m holds if and only if g = g0, n = m and (Q) o/i j o/ 0i

holds for all i in 1..n.
ix) If (Q) oe1 j oe2 and ff /2 dom( bQ) hold, then ff 2 ftv(oe1) iff ff 2 ftv(oe2).

x) If oe1 2 T and (Q) oe1 j oe2 hold, then oe2 2 T .

These properties are shown using Lemma 1.5.9 or Corollary 1.5.10.

Constructed forms

Types of the form 8 (ff \Pi  oe) ff are equivalent to oe by Rule Eq-Var. However such
types hide their structure in the bound of ff. We sometimes need to force the structure
of a type to be apparent. Hence, the following definition :

Definition 1.5.12 A type oe is in constructed form if and only if oe is ?, or oe is of the
form 8 (Q) o/ and o/ /2 dom(Q).

We note that every type o/ is in constructed form. Moreover, every type admits a
constructed form : the function cf, defined below, maps every type to a constructed
form.

cf(?)

M= ? cf(o/ ) M= o/ cf(8 (ff \Pi  oe) oe0) M= (cf(oe) if nf(oe0) is ff

8 (ff \Pi  oe) cf(oe0) otherwise

Properties 1.5.13

i) For any type oe, we have cf(oe) j oe.
ii) If oe is in constructed form, then cf(oe) is oe.

The equivalence under (a given) prefix is a symmetric operation. In other words,
it captures reversible transformations. Irreversible transformations are captured by an
instance relation v. Moreover, as explained in the introduction, we distinguish a subrelation @- of v called abstraction. The inverse of abstraction is used by type annotations

56

1.6 La relation d'abstraction 57

Fig. 1.2 - The abstraction relation
A-Equiv

(Q) oe1 j oe2

(Q) oe1 @- oe2

A-Hyp

(ff1 = oe1) 2 Q

(Q) oe1 @- ff1

to reveal the polymorphic type bound to a type variable in the prefix. In contrast, inverse of instance relations would, in general, be unsound. Indeed, reversing the instance
relation is not sound in ML either.

1.6 The abstraction relation
Definition 1.6.1 (Abstraction) The abstraction relation @- is the smallest transitive
and rigid-compliant relation under prefix that satisfies the rules of Figure 1.2.

We write (Q) oe1 @- oe2, which is read "oe2 is an abstraction of oe1" or "oe1 is a revelation
of oe2" under prefix Q. The abstraction relation is a rigid-compliant relation under
prefix, which means that abstraction under flexible bounds is not allowed. Equivalence
is included in abstraction by Rule A-Equiv. Rule A-Hyp replaces a polytype oe1 by
a variable ff1, provided ff1 is rigidly bound to oe1 in Q. Note that Rule A-Hyp is not
reversible. In particular, (ff1 = oe1) 2 Q does not imply (Q) ff1 @- oe1, unless oe1 is in
T . This asymmetry is essential, since uses of @- will be inferred, but uses of A- will
not. When (Q) oe1 @- ff1 holds, we say that the polytype oe1 is abstracted with ff1.
This operation can also be seen as hiding the polymorphic type oe1 under the abstract
name ff1. Conversely, (Q) ff1 A- oe1 consists of revealing the polytype abstracted by the
name ff1. An abstract polytype, i.e. a variable bound to a polytype in Q, can only be
manipulated by its name, i.e. abstractly. The polytype must be revealed explicitly (by
using the relation A-) before it can be further instantiated (along the relations @- or v).
(See also Examples 6.2.12 and 6.2.13 below.)

Example 1.6.3 The abstraction (ff = oe) 8 (ff = oe) oe0 @- oe0 is derivable : on the one
hand, (ff = oe) oe @- ff holds by A-Hyp, leading to (ff = oe) 8 (ff = oe) oe0 @- 8 (ff = ff) oe0 by
R-Context-Rigid ; on the other hand, (ff = oe) 8 (ff = ff) oe0 j oe0 holds by Eq-Mono?.
Hence, we conclude by A-Equiv and R-Trans.

The following rule is derivable by A-Hyp, R-Context-Rigid and Eq-Mono? :

A-Up?

ff0 /2 ftv(oe0)

8 (ff = 8 (ff0 = oe0) oe) oe0 @- 8 (ff0 = oe0) 8 (ff = oe) oe0

57

58 Types, pre'fixes et relations sous pre'fixe
This rule can be represented with graphs as follows :

g

gff
gff0

@-

g
gff
gff0
The top level node is labelled with g, which is defined as oe0/ffl. The two other
nodes are labelled with gff and gff0 , which are defined respectively as oe/ffl and oe0/ffl. The
symbolic structure of the type is not known in detail. However, we expect ff to be free
in oe0 and ff0 to be free in oe. This is represented by the doubled dashed lines.

Intuitively, only rigid bindings in Q are read (abstracted) in the derivation of (Q)
oe1 @- oe2, flexible bindings are simply ignored. Hence, if Q is unconstrained, it can be
replaced by any other well-formed prefix, as stated by the following property :

Lemma 1.6.2 If we have oe1 @- oe2, then (Q) oe1 @- oe2 holds whenever it is well-formed.

Proof: This lemma is a consequence of the following, more general statement, taking
Q0 = ;.

If Q is unconstrained and (QQ0) oe1 @- oe2 holds, if dom(Q) ` dom(Q00) holds
and Q00Q0 is well-formed, then (Q00Q0) oe1 @- oe2 holds too.

It is shown by induction on the derivation of (QQ0) oe1 @- oe2. Cases R-Trans, RContext-R, and R-Context-Rigid are by induction hypothesis. Note that the reinforcement of the statement is necessary for the case R-Context-R.

ffi Case A-Equiv : By hypothesis (QQ0) oe1 j oe2 holds. Let ` be bQ ffi cQ0. By Corollary 1.5.10, we have `(oe1) j `(oe2) (1) Since Q is unconstrained, bQ is the identity. Hence,
` is cQ0. As a consequence, "Q00Q0 is cQ00 ffi ` (2). By Property 1.5.11.v and (1), we havec
Q00 ffi `(oe1) j cQ00 ffi `(oe2). By Corollary 1.5.10 and (2), we get (Q00Q0) oe1 j oe2. Hence,
(Q00Q0) oe1 @- oe2 holds by A-Equiv.

ffi Case A-Hyp : We have oe2 = ff and (ff = oe1) 2 QQ0. Since Q is unconstrained, we
must have (ff = oe1) 2 Q0. Hence, (ff = oe1) 2 Q00Q0, thus (Q00Q0) oe1 @- ff holds by A-Hyp.
This is the expected result.

The abstraction relation can only hide a polytype under its abstract name, but
cannot modify the structure of the polytype. This is why this relation is (explicitly)
reversible. In order to instantiate polytypes, as we do in ML, we need an irreversible
instance relation.

58

1.7 La relation d'instance 59
1.7 The instance relation
Definition 1.7.1 (Instance) The instance relation v is the smallest transitive and
flexible-compliant relation under prefix that satisfies the rules of Figure 1.3.

We write (Q) oe1 v oe2, which is read "oe2 is an instance of oe1" or "oe1 is more general
than oe2" under prefix Q.

It is a flexible-compliant relation under prefix, thus only flexible bindings may be
instantiated. Conversely, instantiation cannot occur under rigid bounds, except when
it is an abstraction, and we have to use I-Abstract then. Rule I-Bot means that ?
behaves as a least element for the instance relation. Rule I-Rigid mean that flexible
bounds can be changed into rigid bounds. An interesting rule is I-Hyp--the counterpart of rule A-Hyp, which replaces a polytype oe1 by a variable ff1, provided oe1 is a
flexible bound of ff1 in Q.

Example 1.7.4 The instance relation (ff >= oe) 8 (ff >= oe) oe0 v oe0 holds. The derivation
follows the one of Example 1.6.3 but uses I-Hyp and R-Context-Flexible instead
of A-Hyp and R-Context-Rigid. More generally, the following rule is derivable :

I-Drop?

(QQ0Q00) 8 (Q0) oe v oe

Example 1.7.5 The relation1 (Q) 8 (ff >= oe) 8 (fi >= oe ) ff ! fi v 8 (ff >= oe) 8 (fi >= ff )
ff ! fi follows by rules R-Context-R, R-Context-Flexible, and I-Hyp. The right
hand side is equivalent to 8 (ff >= oe) ff ! ff by Eq-Mono?.

The following rules are derivable as well :

I-Equiv?

(Q) oe1 j oe2

(Q) oe1 v oe2

I-Up?

ff2 /2 ftv(oe)

(Q) 8 (ff1 >= 8 (ff2 \Pi  oe2) oe1) oe v 8 (ff2 \Pi  oe2) 8 (ff1 >= oe1) oe

We represent I-Up? with graphs as follows :

g

gff
gff0

v

g
gff
gff0

59

60 Types, pre'fixes et relations sous pre'fixe

Fig. 1.3 - Type instance
I-Abstract

(Q) oe1 @- oe2

(Q) oe1 v oe2

I-Hyp

(ff1 >= oe1) 2 Q

(Q) oe1 v ff1

I-Bot
(Q) ? v oe

I-Rigid

(Q) 8 (ff >= oe1) oe v 8 (ff = oe1) oe

We now state a few simple properties about abstraction and instantiation, using
the meta-symbol "".

Properties 1.7.2

i) Given a renaming OE of dom(Q), if (Q) oe1 "" oe2 holds, then we have a derivation

with the same size of (OE(Q)) OE(oe1) "" OE(oe2).
ii) If Q0 ss Q and (Q) oe1 "" oe2 hold, then we have (Q0) oe1 "" oe2.
iii) If QQ0 is well-formed and (Q) oe1 "" oe2 holds, then we have (QQ0) oe1 "" oe2.

The proofs are by induction on the input derivation.

1.8 Examples

In this section, we consider two examples. The first one illustrates how the usual
ML instance relation is subsumed by the instance relation of MLF. The second example
considers a well-known isomorphism in System F, which is partially captured by our
instance relation.

Example 1.8.6 The relation v generalizes the instance relation of ML. For example,
the type 8 (ff) o/ [ff] is more general than 8 (ff, ff0) o/ [ff ! ff0], as shown by the following
derivation (valid under any prefix) :

8 (ff) o/ [ff]
= 8 (ff >= ?) o/ [ff] (1)
j 8 (ff0, ff00) 8 (ff >= ?) o/ [ff] (2)
v 8 (ff0, ff00) 8 (ff >= ff0 ! ff00) o/ [ff] (3)
j 8 (ff0, ff00) o/ [ff0 ! ff00] (4)
= 8 (ff, ff0) o/ [ff ! ff0] (5)

(1) by notation ; (2) by Eq-Free ; (3) by R-Context-Flexible, since (ff0, ff00) ? v
ff0 ! ff00 ; (4) by Eq-Mono? ; and (5) by renaming.

1The single difference between the two types is highlighted.

60

1.8 Exemples 61

We represent this instance relation by the graphs below. The symbol g is the top
symbol of o/ , that is, o/ /ffl. The node labelled with ? in the left-hand graph represents ff.
The two nodes labelled with ? in the right-hand graph represent ff and ff0, respectively.

g

? v

g
!
? ?
Note that another derivation is possible :

8 (ff) o/ [ff]
= 8 (ff >= ?) o/ [ff] (6)
v 8 (ff >= 8 (ff0, ff00) ff0 ! ff00) o/ [ff] (7)
v 8 (ff0, ff00) 8 (ff >= ff0 ! ff00) o/ [ff] (8)
j 8 (ff0, ff00) o/ [ff0 ! ff00] (9)
j 8 (ff, ff0) o/ [ff ! ff0] (10)

(6) by notation ; (7) by R-Context-Flexible and I-Bot ; (8) by I-Up? ; (9) by EqMono? ; and (10) by renaming.

Two instantiations are used (namely (7) and (8)). We represent them with the following
graphs :

g

? v

g
!
? ?

v

g
!
? ?
Example 1.8.7 The instance relation of MLF covers an interesting case of type isomorphism [Cos95]. In System F, type 8 ff*o/ 0 ! o/ is isomorphic2 to o/ 0 ! 8 ff*o/ whenever

2That is, there exists a function jfi-reducible to the identity that transforms one into the other,
and conversely.

61

62 Types, pre'fixes et relations sous pre'fixe
ff is not free in o/ 0. In MLF, the two corresponding polytypes are not equivalent but in an
instance relation. Precisely, 8 (ff0 >= 8 (ff) o/ ) o/ 0 ! ff0 is more general than 8 (ff) o/ 0 ! o/ ,
as shown by the following derivation :

8 (ff0 >= 8 (ff) o/ ) o/ 0 ! ff0
v 8 (ff) 8 (ff0 >= o/ ) o/ 0 ! ff0 by I-Up?
j 8 (ff) o/ 0 ! o/ by Eq-Mono?

As a particular case, let oeid

M= 8 (fi) fi ! fi ; then 8 (ff, ff0 >= oe

id) ff ! ff0 is more generalthan

8 (ff, fi) ff ! fi ! fi (the derivation closely follows the one of example 1.8.6). It

should be noticed that we encoded the System F type o/ 0 ! 8 ff * o/ by 8 (ff0 >= 8 (ff) o/ )
o/ 0 ! ff0. Another valid encoding would be 8 (ff0 = 8 (ff0 = 8 (ff) o/ )) o/ 0 ! ff. Then the
bound of ff0 is rigid, and the derivation given above is not possible. In that case, the
types are not in an instance relation. However, as in System F, it is possible to write a
retyping function from one type to the other.

This example shows that MLF types and instance relation can capture part of this
isomorphism. This is actually a standard approach when addressing the problem of
type inference with first class polymorphism. For example, the intermediate language
\Lambda -2 [KW94] forbids quantifiers at the right of arrows. This language is shown equivalent
to System F, thanks to the aforementioned isomorphism. As another example, taken
from Odersky and La"ufer's article [OL96] 8 ff * int ! ff list is made a subtype of
int ! 8 ff * ff list using an appropriate instance relation.

In summary, MLF partially captures the type isomorphism given above. It should
also be noted that, as opposed to type containment [Mit88], the instance relation cannot
express any form of contravariance.

62

63
Chapitre 2
Proprie'te's des relations sous
pre'fixes

L'instanciation consiste, en ML, a` appliquer une substitution : e'tant donne' un
sche'ma de type oe

M= 8 (_ff) o/ , ses instances sont de la forme `(o/ ) pour une substitution

` sont le domaine est inclus dans _ff. Cette de'finition de l'instanciation en ML implique
une se'rie de proprie'te's utiles, que nous nous attendons a` retrouver dans MLF.

Dans la section 2.1 nous e'tablissons quelques proprie'te's en rapport avec l'observation des squelettes. Par exemple, en ML, oe et ses instances ont des structures comparables, c'est-a`-dire des squelettes comparables. Plus pre'cise'ment, le squelette de l'instance `(o/ ) correspond au squelette de oe ou` les variables quantifie'es _ff ont e'te' substitue'es
par `. Ainsi, le squelette de `(o/ ) est le squelette de oe, excepte' aux occurrences correspondant aux variables quantifie'es. En MLF, nous de'finissons un ordre partiel 6/ sur
les occurrences (ou, de manie`re e'quivalente, sur les squelettes) qui capture l'ide'e que
seulement les variables quantifie'es peuvent e^tre instancie'es. Le re'sultat est e'nonce' dans
la proprie'te' 2.1.3.ii, qui concerne la relation d'instance. Inversement, la relation d'abstraction est, intuitivement, une relation re'versible. Pour cette raison, elle conserve les
squelettes, comme l'e'nonce la proprie'te' 2.1.3.i. Une autre proprie'te' de la relation d'instance de ML concerne les variables libres : si ff est libre dans oe, alors ff est libre dans
toutes les instances de oe (et plus pre'cise'ment, ff apparai^t au moins aux me^mes occurrences). Ce re'sultat est e'galement vrai dans MLF, comme le montre le lemme 2.1.4, que
l'on peut lire dans un premier temps en prenant Q1 = ;. Un re'sultat imme'diat en ML
e'tablit que les monotypes n'ont pas d'instance (a` part eux-me^mes). Ceci est e'galement
vrai en MLF, a` e'quivalence pre`s, comme le montre le lemme 2.1.6.

Dans certaines imple'mentations de ML, comme OCaml, les variables de type deviennent des alias pendant l'unification. Par exemple, l'unification de ff ! ff et fi ! fi
peut cre'er un alias de ff vers fi, ce qui s'e'crit (ff = fi) (1). Ensuite, chaque fois qu'une

63

64 Proprie'te's des relations sous pre'fixes
variables de type est rencontre'e, l'imple'mentation utilise une fonction repr qui trouve
son repre'sentant. En poursuivant l'exemple, le repre'sentant de ff est fi et le repre'sentant
de fi est fi. Un tel me'canisme joue un ro^le important dans l'efficacite' de l'unification
de ML. Toutefois il est rarement formalise'. En MLF, l'alias de ff vers fi apparai^t directement dans le pre'fixe, sous la forme (1). Dans la section 2.2, nous de'finissons le
repre'sentant d'une variable, selon un pre'fixe donne', et e'tablissons quelques proprie'te's. Le repre'sentant de ff dans Q est e'crit Q[ff], et la borne du repre'sentant (qui est
intuitivement la borne implicite de ff) est note'e Q(ff).

La section 2.3 examine diffe'rentes manie`res de de'composer la de'rivation d'un jugement d'e'quivalence, d'abstraction, ou d'instance, l'objectif e'tant de garantir certains
invariants. Un premier ensemble de restrictions permet de de'finir les de'rivations restreintes (restricted derivations) ; une autre restriction inde'pendante, qui concerne seulement la re`gle de contexte R-Context-R, de'finit les de'rivations e'conomes (thrifty derivations). La proprie'te' 2.3.3 montre que les de'rivations qui sont restreintes et e'conomes
sont aussi expressives que les de'rivations normales. Ces restrictions sont utiles pour
e'carter certains cas pathologiques, qui compliqueraient abusivement les preuves.

Dans la section 2.4, nous e'tudions les contextes qui sont des types avec un trou [ ].
Nous les utilisons section 2.5 pour de'finir un ensemble de re`gles qui remplace les re`gles
de contexte par des contextes explicites. Plus pre'cise'ment, les re`gles de contexte telles
que R-Context-R, R-Context-Flexible ou R-Context-Rigid sont retire'es, et
toutes les autres re`gles mentionnent explicitement un contexte C. Ce nouvel ensemble
de re`gles est prouve' e'quivalent a` l'ensemble original. Un autre ensemble de re`gles inde'pendant est introduit ; il de'finit les re`gles @- _ff et v_ff. Ces relations sont similaires
a` @- et v, mais restreignent fortement les re`gles A-Hyp et I-Hyp. Afin de conserver
l'expressivite', nous introduisons de nouvelles re`gles, a` savoir A-Up', A-Alias', I-Up'
et I-Alias'. Les de'rivations avec @- _ff et v_ff rendent les transformations sur les quantificateurs plus explicites que les de'rivations avec @- et v. Plus pre'cise'ment, alors que
ces dernie`res ne permettent que l'unification de quantificateurs (re`gles A-Hyp et IHyp), les premie`res distinguent l'unification locale de quantificateurs (re`gles A-Alias'
et I-Alias'), l'extrusion de quantificateur (re`gles A-Up' et I-Up'), et l'unification de
quantificateurs avec le pre'fixe (re`gles A-Hyp' et I-Hyp').

Dans la section 2.6, nous de'finissons des relations atomiques. Les relations atomiques
peuvent de'composer une de'rivation d'abstraction ou une de'rivation d'instance en une
se'quence de transformations atomiques effectives. Nous utilisons les de'compositions
atomiques pour montrer certains re'sultats de confluence ; en effet, si une de'rivation est
de'compose'e en une se'quence de transformations, la confluence peut e^tre montre'e en
conside'rant toutes les paires possibles de transformations.

Le re'sultat principal de la section 2.7 est la proprie'te' 2.7.7.i, qui montre que la
relation d'e'quivalence est le noyau syme'trique de la relation d'instance. Ce re'sultat est
montre' en associant un polyno^me a` trois variables a` chaque type et en montrant que la

64

2.1 Projections et instanciation 65
relation d'instance de'croi^t strictement le polyno^me si et seulement si elle est irre'versible
(c'est-a`-dire lorsqu'il n'y a pas e'quivalence). Les polyno^mes sont aussi utilise's pour
montrer que la relation @- conside're'e comme un ordre sur les types (sous un pre'fixe
donne') est bien fonde'e. Ce re'sultat est utilise' dans la section suivante pour montrer la
confluence entre @- et v. En effet, le re'sultat principal de la section 2.8 est le lemme
du diamant (lemme 2.8.4), qui e'tablit la confluence de @- et v sous un pre'fixe sans
contraintes (unconstrained ).

2.1 Projections and instantiation

Skeletons, projections and occurrences were defined formally in section 1.3. We have
seen that a skeleton is a tree composed of type variables, type constructors g n (such as
the arrow !), and ?. Intuitively, only the leaves labeled with ? can be instantiated.
This is captured by the following definition, which introduces the notation 6/. Then,
we immediately show that this relation is actually a partial order on skeletons.

Definition 2.1.1 We define a relation on skeletons, written 6/, as follows : t1 6/ t2
holds if and only if dom(t1) ` dom(t2) and for all u 2 dom(t1), we have t1/u 6= t2/u
implies t1/u = ?.

The definition immediately applies to projections since they are isomorphic to skeletons
(see Section 1.3.2). By extension, we write oe1 6/ oe2 to mean oe1/ 6/ oe2/.

Properties 2.1.2

i) The relation 6/ is a partial order.
ii) If t1 6/ t2 holds, then for any substitution `, we have `(t1) 6/ `(t2).
iii) If t1 6/ t2 holds, then for any skeleton t, we have t[t1/ff] 6/ t[t2/ff].

These properties are direct consequences of Definition 2.1.1.
See details in the Appendix (page 233).

As a consequence of Property 2.1.2.i, if we have oe1 6/ oe2 and oe2 6/ oe1, then
oe1/ = oe2/ (that is, proj(oe1) = proj(oe2)). However, this does not imply oe1 = oe2 in
general, as shown by example 1.3.1. Actually, it does not imply oe1 j oe2 either, since
types contain more information than skeletons.

Projections, instantiation and free variables

Projections are stable under abstraction, but not (in general) under instantiation.
This is stated more precisely by the following lemma :

65

66 Proprie'te's des relations sous pre'fixes
Properties 2.1.3

i) If (Q) oe1 @- oe2, then (8 (Q) oe1)/ = (8 (Q) oe2)/.
ii) If (Q) oe1 v oe2, then 8 (Q) oe1 6/ 8 (Q) oe2.

Proof: Property i : It is shown by induction on the derivation of (Q) oe1 @- oe2.

ffi Case A-Equiv : By Property 1.5.4.i (page 51).
ffi Case R-Trans: By induction hypothesis.
ffi Case A-Hyp: By hypothesis, we have (ff = oe1) 2 Q and oe2 is ff. We have 8 (Q) oe2 =
8 (Q) ff j 8 (Q) oe1 by Eq-Var?. Consequently, 8 (Q) oe1 j 8 (Q) oe2 holds. We get the
expected result by Property 1.5.4.i (page 51).

ffi Case R-Context-R: We have oe1 = 8 (ff \Pi  oe) oe01 and oe2 = 8 (ff \Pi  oe) oe02. Besides,
the premise is (Q, ff \Pi  oe) oe01 @- oe02. Hence, by induction hypothesis, we have (8 (Q, ff \Pi  oe)
oe01)/ = (8 (Q, ff \Pi  oe) oe02)/, which is the expected result.

ffi Case R-Context-Rigid: Like for the case R-Context-L in the proof of Property 1.5.4.i (page 51).

Property ii : It is shown by induction on the derivation of (Q) oe1 v oe2.

ffi Case I-Abstract: By Property i.
ffi Case R-Trans : By induction hypothesis and transitivity of 6/ (Property 2.1.2.i).
ffi Case I-Bot: We have oe = ?, thus (8 (Q) oe1)/ = ?/. We get the expected result by
observing that ? 6/ (8 (Q) oe2) always holds.

ffi Case R-Context-Flexible: We have oe1 = 8 (ff >= oe01) oe (1) and oe2 = 8 (ff >= oe02)
oe (2). The premise is (Q) oe01 v oe02. By induction hypothesis, we know that (8 (Q) oe01)/ 6
(8 (Q) oe02)/, that is \Theta Q(proj(oe01))/ 6 \Theta Q(proj(oe02))/ (3) by Property 1.3.3.i (page 42).
We have

(8 (Q) oe1)/ = (8 (Q) 8 (ff >= oe01) oe)/ from (1)

= \Theta Q(proj(oe)[ proj(oe01)/ff])/ by Property 1.3.3.i (page 42)

and Definition 1.3.2
= \Theta Q(proj(oe))[\Theta Q(proj(oe01))/ff]/
6/ \Theta Q(proj(oe))[\Theta Q(proj(oe02))/ff]/ by Property 2.1.2.iii and (3).
= \Theta Q(proj(oe)[ proj(oe02)/ff])/
= (8 (Q) 8 (ff >= oe02) oe)/ by Property 1.3.3.i (page 42)

and Definition 1.3.2
= (8 (Q) oe2)/ from (2)

Finally, we have shown 8 (Q) oe1/ 6/ 8 (Q) oe2/, which is the expected result.

ffi Case I-Hyp is similar to case A-Hyp above.
ffi Case I-Rigid: 8 (ff >= oe) oe0 and 8 (ff = oe) oe0 have the same projection.

66

2.1 Projections et instanciation 67
Considering an instance (Q) oe1 v oe2, we need to track occurrences of variables bound
in Q but free in oe1. The following lemma states that, in general, such variables also
occur in oe2, at the same occurrence. We require (ff \Pi  oe) to be in the prefix, because
the instance relation is only defined under a prefix that binds all free variables of the
judgment. Additionally, we require oe not to be equivalent to a monotype, otherwise it
could be equivalently substituted by Rule Eq-Mono, and the result would not hold.
As a counterexample, take (Q, ff = o/ ) ff v o/ (where ff cannot be free in o/ ).

Lemma 2.1.4 Assume oe is not in T . If (Q, ff \Pi  oe, Q1) oe1 "" oe2 and (8 (Q1) oe1)/u = ff
hold, then (8 (Q1) oe2)/u = ff. As a consequence, if ff 2 ftv(8 (Q1) oe1), then ff 2
ftv(8 (Q1) oe2).

The proof is by induction on the derivation. See the details in Appendix (page 234).

Monotypes

By Definition 1.5.7, a type oe is in T if its normal form has no quantifiers. Like in ML,
this means that monotypes cannot be instantiated. Monotypes play an important role
in MLF, since they can be inferred (like in ML), whereas polymorphic types can only
be propagated. Throughout the proofs, we need to characterize monotypes, variables,
or ?. Definition 1.5.7 uses normal forms. The following properties use projection.

Properties 2.1.5

i) oe 2 T iff for all u 2 dom(oe) we have oe/u 6= ?.
ii) We have oe/ffl = ff iff oe j ff.
iii) We have oe/ffl = ? iff oe j ?.

See proof in the Appendix (page 235).

The following lemma is essential : it shows that any instance of a monotype o/ is only
equivalent to o/ , even under a prefix. In particular, assume oe is some polymorphic type
scheme. If we have (ff = oe) ff v oe0, then oe0 must be ff (when put in normal form). In
other words, even if ff is rigidly bound to a polytype oe in the prefix, there is no way to
take an instance of it other than ff itself. This is also why we say that the information
(ff = oe) is hidden in the prefix : we can propagate the variable ff, bound to oe, but we
cannot use its polymorphism. Decidability of type inference relies on this result.

Lemma 2.1.6 If oe1 2 T and (Q) oe1 "" oe2 hold, then we have (Q) oe1 j oe2.

Proof: By induction on the derivation of (Q) oe1 "" oe2.

ffi Case A-Equiv : By hypothesis, (Q) oe1 j oe2 holds, which is the expected result.

67

68 Proprie'te's des relations sous pre'fixes

ffi Case R-Trans By induction hypothesis, Property 1.5.11.x (page 56) and R-Trans.
ffi Case A-Hyp and I-Hyp: We have (Q) oe1 v ff1 (that is, oe2 is ff1), and the premise
is (ff1 \Pi  oe1) 2 Q (1). By hypothesis, oe1 2 T , thus oe1 j o/ (2) for some monotype o/ by
Property 1.5.11.ii (page 56). By Property 1.5.3.v (page 50) and (2), we get (Q) oe1 j
o/ (3). By (2), Eq-Mono, and (1), we get (Q) o/ j ff1 (4). Hence, (Q) oe1 j ff1 holds by
R-Trans, (3), and (4). This is the expected result.

ffi Case R-Context-R We have oe1 = 8 (ff \Pi  oe) oe01 and oe2 = 8 (ff \Pi  oe) oe02. The premise
is (Q, ff \Pi  oe) oe01 "" oe02 (5). By hypothesis we have 8 (ff \Pi  oe) oe01 2 T . By Property 2.1.5.i,
we must have oe01 2 T . Hence (Q, ff \Pi  oe) oe01 j oe02 holds by induction hypothesis on (5).
Consequently, (Q) 8 (ff \Pi  oe) oe01 j 8 (ff \Pi  oe) oe02 holds by R-Context-R and this is the
expected result.

ffi Case R-Context-Rigid and R-Context-Flexible: We have oe1 = 8 (ff \Pi  oe) oe0
and oe2 = 8 (ff \Pi  oe0) oe0. The premise is (Q) oe "" oe0 (6). If ff /2 ftv(oe0), then oe1 j oe2 by
Eq-Free, which is the expected result. Otherwise, we necessarily have oe and oe0 in T by
Property 2.1.5.i. Hence, (Q) oe j oe0 holds by induction hypothesis on (6). Consequently,
(Q) oe1 j oe2 holds by R-Context-L.

ffi Case I-Bot implies oe1 = ?, which is a contradiction with the hypothesis oe1 2 T ,
by Property 2.1.5.i.

ffi Case I-Rigid: we have oe1 = 8 (ff >= oe) oe0 and oe2 = 8 (ff = oe) oe0. If ff /2 ftv(oe0),
then oe1 j oe2. Otherwise, we necessarily have oe and oe0 in T by Property 2.1.5.i. Consequently, oe j o/ for some monotype o/ . Hence oe1 j oe0[o/ /ff] (7) holds by Eq-Mono? as
well as oe0[o/ /ff] j oe2 (8). We get the expected result by R-Trans, (7), (8), and by
Property 1.5.3.v (page 50).

Cycles

Types in MLF are not recursive, thus a type cannot be strictly included in itself. As
a consequence, an instance of a given polytype cannot be a strict subterm.

Properties 2.1.7

i) If oe * ffl/ 6/ oe * u/, then u is ffl.
ii) If we have either (Q) oe v ff or (Q) ff v oe and if ff 2 ftv(oe), then oe j ff.

Proof: Property i : We have oe * ffl/ 6/ oe * u/. By definition, this implies oe/u 6/ oe/uu.
Hence uu, that is u2, is in dom(oe). By immediate induction, we show that ui is in dom(oe)
for all natural number i. By definition, dom(oe) is dom(proj(oe)), where proj(oe) is a skeleton
(that is, a tree). By construction, dom(proj(oe)) is a finite set of occurrences. Hence, we
necessarily have u = ffl.

Property ii : By hypothesis, we have (Q) oe v ff (1), or (Q) ff v oe (2), and ff 2 ftv(oe),
that is, there exists u such that oe/u = ff. If u is ffl, then we get the expected result by
Property 2.1.5.ii. Otherwise, we have u 6= ffl (3) and (8 (Q) oe) * u/ = (8 (Q) ff) * ffl/ (4) by

68

2.2 Repre'sentants canoniques et bornes dans un pre'fixe 69

definition of occurrences. If (1) holds, we get 8 (Q) oe/ 6/ 8 (Q) ff/ by Property 2.1.3.ii.
Hence, we get (8 (Q) oe) * ffl/ 6/ (8 (Q) oe) * u/ by (4), and we conclude by Property i that
u is ffl. Otherwise, (2) holds, and we get (Q) ff j oe by Lemma 2.1.6. Hence, 8 (Q) ff/ =
8 (Q) oe/ (5) holds by Property 1.5.4.i (page 51). By (5) and (4), we get (8 (Q) oe) * u/ =
(8 (Q) oe) * ffl/. This leads to u = ffl by Property i. In both cases, we have u = ffl, which is
a contradiction with (3).

2.2 Canonical representatives and bounds in a prefix

In the prefix (ff >= ?, fi = ff), we can see fi as an alias for ff. The following definition
captures the intuition that ff and fi have the same representative :

Definition 2.2.1 Given a prefix Q and a type variable ff in dom(Q), we define the
representative of ff in Q, which we write Q[ff], by the following induction :

(Q, ff \Pi  oe, Q0)[ff]

M= (Q[fi] if nf(oe) = fi

ff otherwise

The bound of Q[ff] in Q is written Q(ff). Note that if Q(ff) is defined, it is not in V.

Intuitively, Q(ff) is the "real" bound of ff in Q, and Q[ff] is a type variable equivalent
to ff under Q whose bound is the "real" bound of ff. As an example, taking Q

M=

(ff >= ?, fi = ff), we have Q[ff] = ff, Q[fi] = ff, Q(ff) = Q(fi) = ?.

Properties 2.2.2 We have the following properties for any closed well-formed prefix
Q, and ff, fi in dom(Q) :

i) (Q) ff j Q[ff].
ii) If bQ(ff) = fi, then we have Q[ff] = fi and Q(ff) = Q(fi) follows.
iii) If bQ(ff) /2 V, then (Q) ff j Q(ff) holds.

iv) We have Q(ff) /2 T iff bQ(ff) 2 #

v) If (Q) ff j fi, then (Q) Q(ff) j Q(fi).
vi) If (Q) ff "" oe and Q(ff) /2 T hold, then nf(oe) 2 # and Q(nf(oe)) /2 T .

See proof in the Appendix (page 235).

2.3 Restricted and thrifty derivations

We wish to put equivalence, abstraction, and instance derivations in canonical forms.
In this section, we introduce some syntactic restrictions on the derivations. We prove
that these restrictions do not actually reduce the expressiveness of relations.

69

70 Proprie'te's des relations sous pre'fixes
Restricted derivations Some rules can be restricted by adding some side-conditions
that do not reduce the set of derivable judgments. Reasoning on restricted derivations
often simplifies proofs.

Lemma 2.3.1 Given a derivation of (Q) oe "" oe0, there exists a derivation of the same
judgment such that the following hold :

- In Rule I-Bot, nf(oe) is not ? and oe /2 V.
- In Rules R-Context-L, R-Context-Rigid, R-Context-Flexible, ff is in

ftv(oe) and nf(oe) is not ff.
- In Rule I-Rigid, ff 2 ftv(oe), oe1 is not in T , and nf(oe) is not ff.
- In rules I-Hyp and A-Hyp, oe1 is not in T .
A derivation which follows those restrictions is called a restricted derivation.

The proof is by induction on the initial derivation. It should be simply remarked that
whenever a rule is not restricted, as described above, it can be freely replaced by an
equivalence. See proof in the Appendix (page 236).

Thrifty derivations Consider the following occurrence of the right-context rule. The
symbol "" stands for either j, @-, or v :

R-Context-R

(Q, ff \Pi  oe) oe1 "" oe2

(Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe2

This occurrence is said to be squandering when either nf(oe1) or nf(oe2) is ff, but not
both simultaneously. We will show in Lemma 2.3.3 that squandering occurrences of
R-Context-R can always be removed.

Definition 2.3.2 (Thrifty Derivations) A derivation with no squandering rules is
a thrifty derivation.

This means that, in a thrifty derivation each occurrence of Rule R-Context-R (such
as the one given above) nf(oe1) is ff if and only if nf(oe2) is ff.

Lemma 2.3.3 Any derivation can be rewritten into a thrifty restricted derivation.
The proof proceeds by rewriting derivations into thrifty derivations, and then by observing that restricted derivations are kept restricted. See the details of the proof in the
Appendix (page 238).

The following corollary characterizes abstraction. It states that if a type oe1 that
is not a variable can be instantiated to a variable ff, then it means that oe1 has been

70

2.4 Contextes 71
abstracted by ff. This must be done in two steps : first, oe1 is instantiated to the bound
of ff, then it is abstracted by A-Hyp or I-Hyp. As a consequence, we know that the
bound of ff is an instance of oe1.

Corollary 2.3.4 Assume (ff \Pi  oe) 2 Q and oe1 /2 V. If (Q) oe1 "" ff holds, then so does
(Q) oe1 "" oe. Besides, if "" is @-, then \Pi  is rigid.

See proof in the Appendix (page 242).

2.4 Contexts

An occurrence points to a location in the skeleton of a type : the projection function
cannot provide more information than skeletons do. However MLF types are richer than
skeletons, thus occurrences are not accurate enough. In order to point to a location in
a type more accurately, we define contexts, which have the same structure as types.

We first define generic contexts, which are the most general form of contexts with
a single hole. We also define special forms of generic contexts that are narrow contexts,
flexible contexts and rigid contexts. Finally, we define contexts with multiple holes.

Generic contexts Generic one-hole contexts are defined by the following grammar :

C ::= [ ] | 8 (ff \Pi  oe) C | 8 (ff \Pi  C) oe
A well-formed context does not bind the same variable twice. The prefix of a well-formed
context C, written C, is defined recursively by

[ ]

M= ; 8 (ff \Pi  oe) C M= (ff \Pi  oe)C 8 (ff \Pi  C) oe M= C

We write dom(C) for dom(C), and bC for bC. If C is well-formed, then C is well-formed.
For example, let C be the context

8 (ff >= ?, fi = 8 (fl = ff ! ff) 8 (ffi >= [ ]) fl ! ffi) fi ! fi
Then C is (ff >= ?, fl = ff ! ff), and bC is [ff ! ff/fl]. We can informally represent this
context by the graph below. The node labelled ? corresponds to ff, the node labelled
[ ] corresponds to ffi. The former is flexible and bound at top-level ; and the latter is
flexible and bound at fi. The middle node labelled ! represents fi ; it is rigid and bound
at top-level. The bottom node labelled ! represents fl. It is a monotype, thus it is not
bound.

71

72 Proprie'te's des relations sous pre'fixes

!
!
! [ ]

?
The next definition introduces the notion of a useful context and of equivalence
between contexts.

Definition 2.4.1

- A context C is said useless if, for all oe1 and oe2, C(oe1) j C(oe2) holds. Otherwise,

it is said useful.
- Two contexts C1 and C2 are said _ff-equivalent if and only if C1(oe) j C2(oe) holds

for any oe such that ftv(oe) " (dom(C1) [ dom(C2)) ` _ff.
- Two contexts C1 and C2 are said equivalent if and only if C1(oe) j C2(oe) holds

for any oe.

For example, 8 (ff=[ ]) fi ! fi is useless, whereas 8 (ff=[ ]) ff ! fi is useful. Additionally,
the contexts 8 (ff >= ?, fi >= ?) [ ] and 8 (ff >= ?, fl >= ?) [ ] are ff-equivalent, but are not
fi- or fl-equivalent. Note that C1 equivalent to C2 means that C1 is #-equivalent to C2.

We define next the level of a context C. It is intuitively the depth of the hole in C.
More precisely, it will be shown that a useless context has level 0 (and conversely), and
a context of the form 8 (Q) [ ] has level 1 (and conversely). For example, a context such
as 8 (ff >= [ ]) ff ! ff has level 2, and a context such as 8 (ff >= 8 (fi >= [ ]) fi ! fi) ff ! ff
has level 3.

Then we define the level-1 domain of a context C. It corresponds intuitively to the
type variables bound directly in front of the hole. For example, the level-1 domain of
8 (ff >= ?, fi >= 8 (fl = ff ! ff, ffi >= ?) [ ]) ff ! fi is the set {fl, ffi}. Indeed, the bindings
(fl = ff ! ff, ffi >= ?) are in front of the hole [ ]. They are, intuitively, at the same level
as the hole. Other bindings, such as (ff >= ?) are not at the same level, thus ff do not
appear in the level-1 domain.

Definition 2.4.2

72

2.4 Contextes 73

- The level of a context C, written level(C), is defined inductively as follows :

level([ ])

M= 1 level(8 (ff \Pi  C) oe) M= 8????!????:

level(C) if oe j ff
0 if ff /2 ftv(oe)
0 if level(C) = 0
level(C) + 1 otherwise

level(8 (ff \Pi  oe) C)

M= level(C)

- The level-1 domain of a context C, written dom1(C), is defined inductively as

follows :

dom1(C)

M= ; if level(C) = 0 dom1(C) M= dom(C) if level(C) = 1

dom1(C)

M= dom1(C0) if level(C) > 1 and 8?!?:C = 8 (ff \Pi  oe) C

0

or
C = 8 (ff \Pi  C0) oe

Properties 2.4.3

i) If C is a useful context, then there exists u such that for any oe and u0 in dom(oe),

we have C(oe)/uu0 = oe/u0.
ii) If C is a useful context, and oe /2 T , then C(oe) /2 T .
iii) A context C is useful iff level(C) > 0.

See proof in the Appendix (page 242).

We introduce three restrictions of generic contexts, namely narrow, flexible, and
rigid contexts. Narrow contexts are intuitively contexts of the form 8 (Q) [ ]. However,
thanks to rule Eq-Var, a context Cn such as 8 (ff >= ?, fi >= 8 (Q0) [ ]) fi is equivalent to
8 (ff >= ?, Q0) [ ]. Hence, a context such as Cn is also considered narrow. This is captured
by the following definition.

Narrow contexts Narrow contexts are a restriction of generic contexts defined by
the following grammar :

Cn ::= [ ] | 8 (ff \Pi  oe) Cn | 8 (ff \Pi  Cn) oe where nf(oe) = ff
The following properties explain what a narrow context is.

73

74 Proprie'te's des relations sous pre'fixes
Properties 2.4.4

i) A prefix C is narrow iff level(C) = 1.
ii) If level(C) = 1, then C is equivalent to 8 (C) [ ].
iii) If level(C) > 1, then there exists C 0 such that C is equivalent to C 0(8 (ff \Pi  8 (Q1)

[ ]) oe) and level(C0) = level(C) - 1.
iv) If level(C) ? 1, then there exists C 0 and Cn such that C is equivalent to C 0(Cn),

and level(Cn) = 1, dom1(C0) = ;, and dom1(C) = dom(Cn).
v) If C(oe) 2 V, then level(C) 6 1.

These properties are shown by structural induction on the context C.
See details in Appendix (page 243).

Intuitively, instantiation occurs only at flexible occurrences, that is, only in flexible
bounds. It can also occur in the bound of ff in 8 (ff = oe) ff, because it is equivalent to
oe by Eq-Var. Flexible contexts, defined next, are contexts suitable for instantiation.

Flexible contexts Flexible contexts are a restriction of generic contexts defined by
the following grammar :

Cf ::= [ ] | 8 (ff \Pi  oe) Cf | 8 (ff >= Cf ) oe | 8 (ff = Cf ) oe where nf(oe) = ff
Similarly, abstraction occurs only at rigid occurrences, that is, only in rigid bounds.
Rigid contexts are contexts suitable for abstraction.

Rigid contexts Rigid contexts are a restriction of generic contexts defined by the
following grammar :

Cr ::= [ ] | 8 (ff \Pi  oe) Cr | 8 (ff = Cr) oe | 8 (ff >= Cr) oe where nf(oe) = ff

The following lemma shows that the normal form of a type C(oe1) is of the form
C0(nf( bC(oe1))) for some context C0. Intuitively, C0 is some sort of normal form of C,
which is partially captured by the statement that C 0 is _ff-equivalent to C (where the
interface _ff is the set of free variables of bC(oe1)). For instance, take the following :

C

M= 8 (ff >= ?, fi = ff ! ff, fl >= [ ]) fi ! fl oe1 M= 8 (ffi >= ?) ffi ! fi

oe

M= C(oe1) = 8 (ff >= ?, fi = ff ! ff, fl >= 8 (ffi >= ?) ffi ! fi) fi ! fl

We have bC = [ff ! ff/fi]. Then the normal form of oe is 8 (ff >= ?, fl >= 8 (ffi >= ?) ffi !
(ff ! ff)) (ff ! ff) ! fl. Taking C0 = 8 (ff >= ?, fl >= [ ]) (ff ! ff) ! fl, we have
nf(oe) = C0(8 (ffi >= ?) ffi ! (ff ! ff)), that is, nf(oe) = C 0( bC(oe1)). Additionally, C 0 and
C are ff-equivalent.

74

2.4 Contextes 75
Lemma 2.4.5 If C is a useful well-formed context, oe = C(oe1) and oe1 /2 T , then there
exists C0 such that

- C0 is ftv( bC(oe1))-equivalent to C
- dom(C0) ` dom(C)
- nf(oe) = C0(nf( bC(oe1)))

Proof: This is proved by induction on the number of quantifiers of the context C. By
hypothesis, oe1 /2 T (1). Let _ff be ftv( bC(oe1)) (2). We proceed by case analysis on the
structure of C.

ffi Case C is [ ] : Then oe is oe1 and taking C0 = [ ] is appropriate.
ffi Case C is 8 (ff0 \Pi  oe0) C0 (3) : Then oe is 8 (ff0 \Pi  oe0) C0(oe1) (4). Necessarily, C0 is
useful. By well-formedness of C, we must have ff0 /2 dom(C0) (5). We have ff0 /2 _ff by
(2) and well-formedness of (3).

Subcase C0(oe1) j ff0 : By Property 1.5.11.ii (page 56), we have C0(oe1) 2 T . By
Property 2.4.3.ii and (1), we have C0(oe1) /2 T . This is a contradiction, which means that
this subcase cannot occur.

Subcase oe0 2 T : By Property 1.5.11.ii (page 56), we have oe0 j o/0 for some monotype o/0. Let ` be [o/0/ff0]. The normal form of oe is by definition `(nf(C0(oe1))), from
(4). By Property 1.5.6.iii (page 53), we get nf(oe) = nf(`(C0(oe1))), that is, nf(oe) =

nf(`(C0)(`(oe1))) (6) thanks to (5). Observing that the substitution bC is ` ffi cC0 (7),
we get ftv("`(C0)(`(oe1))) = ftv( bC(oe1)) = _ff. By induction hypothesis on `(C0), there
exists a context C1 that is _ff-equivalent to `(C0) (8) and such that nf(`(C0)(`(oe1))) =

C1(nf("`(C0)(`(oe1)))) (9) and dom(C1) ` dom(`(C0)), that is, dom(C1) ` dom(C0) (10).
By (9), (6), and (7), nf(oe) is C1(nf( bC(oe1))). Hence, `(C0) is _ff-equivalent to 8 (ff0\Pi oe0) C0,
that is, to C (11). By (8) and (11), C1 is _ff-equivalent to C. Finally, dom(C1) ` dom(C)
by (10) and (3). This is the expected result.

Subcase ff0 /2 ftv(C0(oe1)) (12): Then nf(oe) is nf(C0(oe1)), thus we conclude directly
by induction hypothesis. Indeed, C is 8 (ff0 \Pi  oe0) C0 and is _ff-equivalent to C0 by (12).

Besides, dom(C0) ` dom(C), and cC0 = bC.

Otherwise nf(oe) is 8 (ff0 \Pi  nf(oe0)) nf(C0(oe1)), and bC = cC0 (13). By induction
hypothesis, there exists C1, _ff-equivalent to C0, such that nf(C0(oe1)) = C1(nf(cC0(oe1))).
By (13), we get nf(C0(oe1)) = C1(nf( bC(oe1))). We get the expected result by taking
C0 = 8 (ff0 \Pi  nf(oe0)) C1. Besides, C0 is equivalent to 8 (ff0 \Pi  oe0) C1, which is _ff-equivalent
to 8 (ff0 \Pi  oe0) C0, that is C. Finally, dom(C0) = {ff0} [ dom(C1) and dom(C1) ` dom(C0)
by induction hypothesis, thus dom(C0) ` {ff0} [ dom(C0) = dom(C).

ffi Case C is 8 (ff0 \Pi  C0) oe0: then, oe is 8 (ff0 = C0(oe1)) oe0. We must have ff0 2 ftv(oe0)
and C0 is useful (otherwise C would be useless). Moreover, bC = cC0 (14) by definition.

Subcase nf(oe0) is ff0: then, nf(oe) is nf(C0(oe1)) and we conclude directly by induction
hypothesis. Indeed, C is equivalent to C0, dom(C0) = dom(C), and bC = cC0 from (14).

Subcase C0(oe1) 2 T is not possible by Property 2.4.3.ii.

75

76 Proprie'te's des relations sous pre'fixes

Otherwise nf(oe) is 8 (ff0 \Pi  nf(C0(oe1))) nf(oe0). By induction hypothesis, there exists
C1, _ff-equivalent to C0 such that nf(C0(oe1)) = C1(nf(cC0(oe1))) (15) and dom(C1) `
dom(C0) (16). Hence, by (15) and (14), we have nf(C0(oe1)) = C1(nf( bC(oe1))). We get
the expected result by taking C0 = 8 (ff0 \Pi  C1) nf(oe0). Besides, C0 is equivalent to
8 (ff0 \Pi  C1) oe0, which is _ff-equivalent to 8 (ff0 \Pi  C0) oe0, that is, C. From (16), we get
dom(C1) ` dom(C). Finally, dom(C0) = dom(C1) ` dom(C) holds. This is the expected
result.

Contexts with multiple holes Generic contexts with n holes C n are defined by the
following grammar :

C0 ::= oe no hole
C1 ::= C
Cm+p ::= 8 (ff \Pi  Cm) Cp for m + p > 1.

The notation C2(oe1, oe2) means that the first hole is filled with oe1 and the second hole
filled with oe2.1 Note that the notion of useful context is more delicate : the "usefulness"
of the first hole might depend on what is put in the second hole. For instance, take
8 (ff = [ ]) [ ].

Matching contexts We say that two generic contexts C1 and C2 match on oe if there
exist oe1 and oe2 such that oe = C1(oe1) = C2(oe2). Two matching contexts C1 and C2 are
nested when there exists C3 such that C1 = C2(C3) or C2 = C1(C3). Otherwise, they
are said disjoint.

Lemma 2.4.6 Assume oe is in normal form. If C1 and C2 are disjoint and match on oe,
then there exist a two-hole context C 2 such that C1 = C2([ ], oe2) and C2 = C2(oe1, [ ]).
Besides, if C1 is flexible (resp. rigid), then C 2([ ], oe02) is flexible (resp. rigid), for any
oe02. A similar result holds for C2.

Proof: By induction on the structures of C1 and C2. By hypothesis, we have oe =
C1(oe1) = C2(oe2) (1), and C1 and C2 are not nested.

ffi Case C1 = [ ] is not possible, since otherwise C1 and C2 are nested.
ffi Case C2 = [ ] is not possible either.
1We should explain formally how to assign a number to each hole. However, this would only obfuscate the notations. Hence, we leave some harmless "artistic blur", and assume that we have a way to
assign a different number to each hole in a context.

76

2.5 Re`gles locales pour l'abstraction et l'instanciation 77

ffi Case C1 = 8 (ff \Pi  oe) C01, C2 = 8 (ff0 \Pi 0 oe0) C02 : Then (1) implies (ff \Pi  oe) = (ff0 \Pi 0 oe0) and
C01(oe1) = C02(oe2). By induction hypothesis, there exists C2a such that C01 = C2a([ ], oe2) and
C02 = C2a(oe1, [ ]). Hence taking C2 = 8 (ff\Pi oe) C2a([ ], [ ]) gives the expected result. Besides,
if C1 is flexible (resp. rigid), then C01 is flexible (resp. rigid). By induction hypothesis,
C2a([ ], oe02) is flexible (resp. rigid) for any oe02. Hence, C2([ ], oe02) is flexible (resp. rigid).
Similarly for C2(oe01, [ ]).

ffi Case C1 = 8 (ff\Pi oe) C01, C2 = 8 (ff0 \Pi 0 C02) oe0 : Then (1) implies (ff\Pi oe) = (ff0 \Pi 0 C02(oe2))
and oe0 = C01(oe1). Let C2 be 8 (ff \Pi  C02) C01, where the first hole is in C01, the second hole in
C02. We have C1 = C2([ ], oe2) and C2 = C2(oe1, [ ]), which is the expected result. Besides,
if C1 is flexible (resp. rigid), then C01 is flexible (resp. rigid). Hence, C2([ ], oe02) is flexible
(resp. rigid). If C2 is flexible (resp. rigid), then C02 is flexible (resp. rigid) and \Pi 0 is >=
(resp =). The case where nf(oe0) is ff0 and \Pi 0 is = (resp >=) is not possible here, because
oe is in normal form by hypothesis. Hence, C2(oe01, [ ]) is flexible (resp. rigid).

ffi Case C1 = 8 (ff \Pi  C01) oe, C2 = 8 (ff0 \Pi 0 oe0) C02 is similar.
ffi Case C1 = 8 (ff \Pi  C01) oe, C2 = 8 (ff0 \Pi 0 C02) oe0 : Then (1) implies ff = ff0, \Pi  = \Pi 0,
oe = oe0, and C01(oe1) = C02(oe2). Thus, by induction hypothesis there exists C2a such that
C01 = C2a([ ], oe2) and C02 = C2a(oe1, [ ]). Hence, taking C2 = 8 (ff \Pi  C2a) oe gives the expected
result. Besides, if C1 is flexible (resp. rigid), then \Pi  is >= (resp. =) and C01 is flexible
(resp. rigid). By induction hypothesis, C2a([ ], oe02) is flexible (resp. rigid), for any oe02.
Hence, C2([ ], oe02) is flexible (resp. rigid) for any oe02. Similarly for C2(oe01, [ ]).

Derivable context rules The following rules are derivable by induction on the
context. They can represent any sequence of context rules.

Eq-Context?

(QC) oe1 j oe2

(Q) C(oe1) j C(oe2)

A-Context?

(QCr) oe1 @- oe2

(Q) Cr(oe1) @- Cr(oe2)

I-Context?

(QCf ) oe1 v oe2

(Q) Cf (oe1) v Cf (oe2)

2.5 Local abstraction and instance rules

The rules defining abstraction and instance were given in Figure 1.2 and 1.3, in Sections 1.6 and 1.7. In order to show confluence results on abstraction and instantiation,
we need to put derivations in canonical forms. This amounts to lifting transitivity to
top-level, and to replacing some rules, such as A-Hyp by local rules. Besides, we wish
to get rid of context rules such as R-Context-R and R-Context-Rigid by using
contexts defined in the previous section.

We recall that R* is the transitive closure of R.

2.5.1 Context-based rules

The following lemma states that transitivity can always be lifted to top-level.

77

78 Proprie'te's des relations sous pre'fixes
Lemma 2.5.1 If we have a derivation of (Q) oe "" oe0, then, there exists a tuple oe1 . . . oen
such that oe1 = oe, oen = oe0 and for all i < n we have a derivation of (Q) oei "" oei+1
which does not use Rule R-Trans.

Proof: By induction on the derivation of (Q) oe "" oe0. All cases are easy.

Abstraction

We wish to define a relation that has the same expressiveness as @- and that uses
contexts instead of context rules. We consider the relation @-C defined by the single
following rule :

Ac-Hyp

(ff = oe1) 2 QCr

(Q) Cr(oe1) @-C Cr(ff)

Intuitively, @-C captures abstraction, but not equivalence. Hence, we define (j|@-C ) as
(j) [ (@-C ), that is :

(Q) oe1 (j|@-C ) oe2 if and only if (Q) oe1 j oe2 or (Q) oe1 @-C oe2 holds.
As expected, the transitive closure of (j|@-C) is equivalent to abstraction.

Lemma 2.5.2 The relations @- and (j|@-C )* are equal.

Proof: We need to show that (j|@-C)* is included in @-, and conversely.
Directly : Rule Ac-Hyp is derivable with A-Hyp and A-Context?. Hence, @-C is included in @-. Moreover, j is included in @- and @- is transitive, thus (j|@-C)* is included
in @-.

Conversely, we show that @- is included in (j|@-C)*. Thanks to Lemma 2.5.1, it suffices to
show that if we have a derivation of (Q) oe1 @- oe2 not using R-Trans, then (Q) oe1 j oe2
or (Q) oe1 @-C oe2 is derivable. We assume we have a derivation of (Q) oe1 @- oe2 that does
not use R-Trans. All abstractions rules of this derivation have at most one premise.
Namely, the rules with one premise are context rules R-Context-R and R-ContextRigid. The topmost abstraction rule is either A-Equiv or A-Hyp. If it is A-Equiv,
then (Q) oe1 j oe2 is derivable, and this case is solved. Otherwise, we have a derivation
of the form

A-Hyp (ff = oe0) 2 QQ

0

(QQ0) oe0 @- ff

...

(Q) oe1 @- oe2

78

2.5 Re`gles locales pour l'abstraction et l'instanciation 79

By structural induction on this derivation, we can show that there exists a rigid context
Cr such that oe1 = Cr(oe0), oe2 = Cr(ff), and Q0 = Cr. Hence, we have (ff=oe0) 2 QCr and
the derivation ends with (Q) Cr(oe0) @- Cr(ff). Consequently, we have (Q) Cr(oe0) @-C
Cr(ff) by Rule Ac-Hyp, that is, (Q) oe1 @-C oe2. This is the expected result.

Instance

As we have done for @-c, we define the relation vC in order to capture type instantiation through context-based rules.

Ic-Bot

(Q) Cf (?) vC Cf (oe)

Ic-Hyp

(ff >= oe) 2 QCf

(Q) Cf (oe) vC Cf (ff)

Ic-Abstract

(QCf ) oe @-C oe0

(Q) Cf (oe) vC Cf (oe0)

Ic-Rigid

(Q) Cf (8 (ff >= oe) oe0 vC Cf (8 (ff = oe) oe0)

The relation (j|vC ) is defined as (j) [ (vC ).
Lemma 2.5.3 The relations v and (j|vC )* are equal.

Proof: We need to show that (j|vC)* is included in v, and conversely.
Directly : rules Ic-Bot, Ic-Hyp, Ic-Rigid, and Ic-Abstract are derivable with IContext? and I-Bot, I-Hyp, I-Rigid, and I-Abstract, respectively. Hence, vC is
included in v. Moreover, j is included in v and v is transitive, thus (j|vC)* is included
in v.

Conversely, we show that v is included in (j|vC)*. We assume that (Q) oe1 v oe2 (1)
holds. We have to show that (Q) oe1 (j|vC)* oe2 is derivable. Like in the proof of
Lemma 2.5.2, we assume that the derivation of (1) does not use transitivity (thanks
to Lemma 2.5.1). Hence, the derivation of (1) is actually a sequence of context-rules
starting with a one-premise rule I-X, which can be either I-Abstract, I-Hyp, I-Bot
or I-Rigid. Hence, the derivation of (1) is of the form :

I-X (QQ0) oe0

1 v oe02

...

(Q) oe1 v oe2
In the first case (I-Abstract), following the proof of Lemma 2.5.2, we have a sequence
of context rules (namely R-Context-Rigid or R-Context-R) starting with A-Hyp
or A-Equiv. If it starts with A-Equiv, then (Q) oe1 j oe2 holds, and the result is shown.

79

80 Proprie'te's des relations sous pre'fixes

Otherwise, and for other choices of I-X also, there exists a flexible context Cf such that
Cf = Q0, oe1 = Cf (oe01) and oe2 = Cf (oe02). Then we get the expected result by using rules
(respectively) Ic-Abstract, Ic-Hyp, Ic-Bot and Ic-Rigid, and using Lemma 2.5.2
for I-Abstract.

2.5.2 Alternative abstraction and alternative instance

Rules A-Hyp and Ac-Hyp are not local. Indeed, both rules replace a type oe by a
variable ff, provided the binding (ff =oe) is in the prefix. For example, 8 (ff =oe) 8 (fi =oe)
ff ! fi @- 8 (ff = oe) 8 (fi = ff) ff ! fi is derivable, taking Cr = 8 (ff = oe) 8 (fi = [ ]) ff ! fi
in Ac-Hyp. In that case, the binding (ff = oe) is next to the hole. However, the context
Cr can be of any level, which means that the information (ff = oe) is propagated from
one subterm of the type to another arbitrarily distant subterm. We wish to force rigid
contexts to be of level 1 or 2 only. This gives more granularity to derivations, and makes
it possible to show some "local" invariants that would possibly be broken by non-local
rules.

In order to help the understanding of the following, we introduce the informal notion
of frozen binding : Given a derivation D ending with (Q) oe1 "" oe2, we call Q the frozen
prefix. Inside the derivation D we may find a sequent such as (QQ0) oe01 "" oe02. Whereas
the bindings of Q are frozen, the bindings of Q0, which were introduced by context
rules, are not.

Pursuing the analysis, we see that Rule A-Hyp can be used with three different
flavors :

1. Abstraction between types at the same level ; e.g. the following is derivable (as

seen above) : (Q) 8 (ff = oe) 8 (fi = oe) ff ! fi @- 8 (ff = oe) 8 (fi = ff) ff ! fi.

2. Extrusion of a quantifier, as in A-Up? : (Q) 8 (ff = 8 (fi = oe) oe0) o/ @- 8 (fi = oe)

8 (ff = oe0) o/ , provided fi /2 ftv(o/ ).

3. Abstraction of a type found in the frozen prefix : (ff = oe) 8 (fi = oe) fi ! fi @-

8 (fi = ff) fi ! fi.

We have already illustrated the extrusion of a quantifier by graphs page 59. The
abstraction between a type and the prefix can also be represented by the same graphs,
considering the top-level node in the prefix. The abstraction between types at the same
level can be captured by graphs as follows :

!

oe oe

v

!

oe

80

2.5 Re`gles locales pour l'abstraction et l'instanciation 81

The same flavors, illustrated by similar examples, exist for I-Hyp. We now define two
relations @-_ff and v_ff (frozen abstraction and frozen instance relations) that explicitly
separate these different flavors. In order to keep track of frozen bindings, we annotate
the relation with a set of variables _ff that corresponds to variables introduced in the
prefix by context rules (that is, non-frozen variables). Hence, we consider the following
rule, which is meant to replace R-Context-R :

R-Context-R'

(Q, ff \Pi  oe) oe1 ""_ff[{ff} oe2

(Q) 8 (ff \Pi  oe) oe1 ""_ff 8 (ff \Pi  oe) oe2

Definition 2.5.4 (Frozen abstraction and frozen instance) We define the relation @-_ff as the smallest transitive relation under prefix that satisfies the rules of figure 2.1 as well as rules R-Context-Rigid and R-Context-R'.

The relation v_ff is the smallest transitive relation under prefix that satisfies the
rules of figure 2.2 as well as rules R-Context-Flexible and R-Context-R'.

Note that @-_ff is almost a rigid-compliant relation ; the only difference lies in Rule
R-Context-R', which is used instead of R-Context-R. Similarly, v _ff is almost a
flexible-compliant relation, the difference being in Rule R-Context-R'.

The rules for @-_ff and v_ff are similar to the rules defining @- and v, except A-Hyp'
and I-Hyp', which require the binding read in the prefix not to be in _ff (that is, the
binding must be frozen). In order to make local unification or extrusion of binders
possible, rules A-Alias' and A-Up' are added to the definition of @- _ff, and rules IAlias' and I-Up' are added to the definition of v _ff. They are meant to be used instead
of A-Hyp or I-Hyp, when the binding read in the prefix is in _ff (that is, not frozen).
A judgment (Q) oe1 ""_ff oe2 is well formed if and only if Q is well-formed, and oe1 and
oe2 are closed under Q. All derivations are implicitly well-formed. We note that @- _ff is
included in @-_ff[ _fi for any sets of variables _ff and _fi. As expected, these new relations
are equivalent to the original ones :

Lemma 2.5.5 The relations @- and @-; are equal. The relations v and v; are equal.
See proof in the Appendix (page 244).

The following rule is derivable :

I-Equiv?'

(Q) oe1 j oe2

(Q) oe1 v_ff oe2

Some proofs are made easier by considering restricted derivations for @- _ff and v_ff.
The following lemma introduces new restrictions for the new rules A-Up, A-Alias, . . .

81

82 Proprie'te's des relations sous pre'fixes

Fig. 2.1 - Frozen abstraction relation
A-Equiv'

(Q) oe1 j oe2

(Q) oe1 @-_ff oe2

A-Hyp'

(ff = oe) 2 Q ff /2 _ff

(Q) oe @-_ff ff

A-Up'

ff1 /2 ftv(oe0)

(Q) 8 (ff = 8 (ff1 = oe1) oe) oe0 @-_ff 8 (ff1 = oe1) 8 (ff = oe) oe0

A-Alias'

(Q) 8 (ff1 = oe1) 8 (ff2 = oe1) oe @-_ff 8 (ff1 = oe1) 8 (ff2 = ff1) oe

Lemma 2.5.6 The restrictions stated in Lemma 2.3.1 are still applicable with v _ff and
@-_ff, together with a few more restrictions :

- In rules A-Hyp' and I-Hyp', oe is not in T .
- In rules A-Up' and I-Up', ff 2 ftv(oe0), nf(oe0) is not ff, ff1 2 ftv(oe), nf(oe) is not

ff1, and oe1 is not in T
- In rules A-Alias' and I-Alias', oe1 is not in T , and ff1 and ff2 are in ftv(oe)

Proof: Similar to the proof of Lemma 2.3.1, and we only need to consider the new rules
A-Hyp', I-Hyp', A-Up', I-Up', A-Alias', and I-Alias'. We assume given a judgment
(Q) oe1 ""_ff oe2 derived with such a rule. If the restrictions above do not hold, then it is
easy to check that (Q) oe1 j oe2 holds, and we conclude by Lemma 2.3.1, A-Equiv' or
I-Equiv?'.

A derivation with v_ff or @-_ff that keeps skeletons unchanged cannot instantiate ?,
but only replaces types by an alias (like A-Alias'), or extrudes binders (like A-Up').
Since A-Up' and A-Alias' do not modify the set of free variables, only A-Hyp can
introduce new variables, which are necessarily frozen, that is, not in _ff. This is expressed
by the following lemma :

Lemma 2.5.7 If we have

(Q) oe1 ""_ff oe2 8 (Q) oe1/ = 8 (Q) oe2/ ff 2 _ff ff 2 ftv( bQ(oe2))
Then we have ff 2 ftv( bQ(oe1)).

82

2.6 Re`gles d'instances atomiques 83

Fig. 2.2 - Frozen instance relation
I-Abstract'

(Q) oe1 @-_ff oe2

(Q) oe1 v_ff oe2

I-Bot'
(Q) ? v_ff oe

I-Rigid'

(Q) 8 (ff >= oe1) oe v_ff 8 (ff = oe1) oe
I-Hyp'

(ff >= oe) 2 Q ff /2 _ff

(Q) oe v_ff ff

I-Up'

ff1 /2 ftv(oe0)

(Q) 8 (ff >= 8 (ff1 \Pi  oe1) oe) oe0 v_ff 8 (ff1 \Pi  oe1) 8 (ff >= oe) oe0

I-Alias'

(Q) 8 (ff1 >= oe1) 8 (ff2 >= oe1) oe v_ff 8 (ff1 >= oe1) 8 (ff2 = ff1) oe

The proof is by induction on the derivation of (Q) oe1 ""_ff oe2.
See details in the Appendix (page 246).

2.6 Atomic instances

In this section, we define new relations, namely, .v and .@-_ff, that have the same
expressiveness as v and @- but ensure canonical derivations. Besides, these relations
are not transitive, so that all the steps of the instantiation are clearly separated. Furthermore, each step is always irreversible, in the sense that it is not an equivalence. In
other words, all steps are useful.

2.6.1 Definitions

The one-step strict instance relation .@ is defined in Figure 2.3. The one-step abstraction relation .@-_ff is defined in Figure 2.4. These rules mention flexible and rigid
contexts, defined formally in section 2.4. The one-step instance relation .v, which combines .@ and .@- is defined in Figure 2.5. The symbol R stands either for .v or .@-;. As
usual, we write oe1 R oe2 for (Q) oe1 R oe2, where Q is unconstrained and oe1 and oe2 are
closed under Q.

Definition 2.6.1 We define the relations (j .@-;) and (j .v) : (Q) oe1 (jR) oe2 holds if
and only if (Q) oe1 j oe2 or there exists oe01 and oe02 such that (Q) oe1 j oe01, (Q) oe01 R oe02
and (Q) oe02 j oe2.

83

84 Proprie'te's des relations sous pre'fixes

Fig. 2.3 - Strict instance
In all rules, Cf is a well-formed useful context.

S-Hyp

oe0 /2 T

(ff >= oe1) 2 Q ff /2 dom(Cf ) (Q) oe1 j cCf (oe0)

(Q) Cf (oe0) .@ Cf (ff)

S-Up

fi 2 ftv(oe00) ff 2 ftv(oe0) oe0, oe00 /2 V oe /2 T

ff /2 dom(QCf Q0) ftv(oe) # dom(Q0)

(Q) Cf (8 (fi >= 8 (Q0, ff \Pi  oe) oe0) oe00) .@ Cf (8 (ff \Pi  oe) 8 (fi >= 8 (Q0) oe0) oe00)

S-Alias

ff1 2 ftv(oe0) ff2 2 ftv(oe0) dom(Q0) # ftv(oe1, oe2) oe1 /2 T

oe1 j oe2 oe = 8 (ff1 >= oe1, Q0, ff2 >= oe2) oe0

(Q) Cf (oe) .@ Cf (8 (ff1 >= oe1, Q0, ff2 = ff1) oe0)

S-Nil

ftv(oe) = ;

(Q) Cf (?) .@ Cf (oe)

S-Rigid

oe0 /2 T ff 2 ftv(oe) oe /2 V

(Q) Cf (8 (ff >= oe0) oe) .@ Cf (8 (ff = oe0) oe)

As already mentioned, R* is the transitive closure of the relation R. Note that StShHyp is restricted to variables ff not in _ff. The only rule introducing variables in _ff is
C-Abstract-F, which adds Cf .

2.6.2 Equivalence between relations

These new relations have the same expressiveness as the original relations, as stated
by the following lemma.

Properties 2.6.2

i) The relations (@-) and (j .@-;)

* are equal.

ii) The relations (v) and (j .v)* are equal.
See proof in the Appendix (page 247).

The relations .@ and .@-_ff can be seen as rewriting relations, under a given prefix.
Then (Q) oe1 .@ oe2 corresponds to reducing the argument oe1 by .@, and getting oe2 as
a result. Similarly, the relation .@-_ff is viewed as a rewriting relation. These (rewriting)

84

2.6 Re`gles d'instances atomiques 85

Fig. 2.4 - Strict Abstraction Relation
In all rules, Cr is a well-formed useful context.

StSh-Hyp

oe0 /2 T

(ff = oe1) 2 Q ff /2 dom(Cr) ff /2 _ff (Q) oe1 j cCr(oe0)

(Q) Cr(oe0) .@-_ff Cr(ff)

StSh-Up

fi 2 ftv(oe00) ff 2 ftv(oe0) oe0, oe00 /2 V oe /2 T

ff /2 dom(QCRQ0) ftv(oe) # dom(Q0)

(Q) Cr(8 (fi = 8 (Q0, ff = oe) oe0) oe00) .@-_ff Cr(8 (ff = oe) 8 (fi = 8 (Q0) oe0) oe00)

StSh-Alias

ff1 2 ftv(oe0) ff2 2 ftv(oe0) dom(Q0) # ftv(oe1, oe2) oe1 /2 T

oe = 8 (ff1 = oe1, Q0, ff2 = oe2) oe0 oe1 j oe2

(Q) Cr(oe) .@-_ff Cr(8 (ff1 = oe1, Q0, ff2 = ff1) oe0)

Fig. 2.5 - Combined instance
C-Strict

(Q) oe1 .@ oe2

(Q) oe1 .v oe2

C-Abstract-F

(QCf ) oe1 .@-Cf oe2 level(Cf ) > 1

(Q) Cf (oe1) .v Cf (oe2)

C-Abstract-R

(Q) oe1 @- oe2

(Q) oe1 .v oe2

relations have a remarkable property : if they can reduce an argument oe, then they can
also reduce its normal form nf(oe). Besides, the results are equivalent. This is stated
below :

Properties 2.6.3 The following properties hold for R being .@-_ff and .@.

i) If (Q) oe1 R oe2 holds, then there exists oe02 such that (Q) nf(oe1) R oe02 and (Q) oe2 j

oe02 hold.
ii) If (Q) oe1 R oe2 holds, oe1 is in normal form, and oe01 ss oe1, then there exists oe02 such

that (Q) oe01 R oe02 and (Q) oe2 j oe02 hold.

This is shown by considering each rule individually. In all cases, the projection of
the redex to its normal form leads to a similar redex, thanks to Lemma 2.4.5 (page 75).
See proof in the Appendix (page 250).

85

86 Proprie'te's des relations sous pre'fixes

This result will be used in the proof of the main confluence result, namely the
Diamond Lemma (Lemma 2.8.4).

2.7 Equivalence vs instantiation

The key result of this section is Property 2.7.7.i, which shows that the equivalence
relation is the kernel of the instance relation. The second main result of this section
is Corollary 2.7.10, which shows that both the abstraction relation and its inverse the
revelation relation are stationary.

While occurrences describe only the symbolic structure of types, i.e. their skeleton,
we here use polynomials to describe their binding structure. The polynomial associated
to the binding structure of a type is called its weight. As expected, a type with no
binding structure, i.e. a monotype, weighs zero, as stated by Lemma 2.7.4. The converse
is also true.

We start by stating a few properties about polynomials, then we define weights, and
show some useful properties. Then we prove the main results, which are Property 2.7.7.i
and Corollary 2.7.10.

2.7.1 Polynomials

The set of three-variable polynomials in X, Y, Z, which we simply call "polynomials", is defined as Z[X][Y ][Z]. The addition + and multiplication * are, as expected,
commutative, thus, for instance X * Y equals Y * X. It is well known [Bou59] that
Z[X][Y ][Z] is isomorphic to (Z[Y ][Z])[X]. In other words, any polynomial can be seen
as a polynomial in variable X, with coefficients in the ring Z[Y ][Z]. Similarly, Z[Y ][Z]
can be seen as polynomials in variable Y , with coefficients in the ring Z[Z].

Given a total ordering 6 on a ring A , we define a total ordering on A [X] as the
lexicographic order on the sequence of coefficients, higher degrees coming first. Formally,
if P and Q are in A [X], we can always write them in the form pnXn+. . .+p1X +p0 and
qnXn + . . . + q1X + q0. (we can have pn = 0 if, for instance, the degree of P is smaller
than the degree of Q). Then P 6 Q if and only if (pn, . . . , p1, p0) 6 (qn, . . . , q1, q0),
taking the lexicographic order over A n+1.

Using the usual total ordering on Z, we get a total ordering on Z[Z]. We use again
this ordering to build a total ordering on (Z[Z])[Y ]. This new ordering is used too to
build a total ordering on (Z[Z][Y ])[X].

Because of the above hierarchy, polynomial variables do not play equivalent roles,
with respect to the orderings. More precisely, X is prevailing over Y which is in turn
prevailing over Z.

86

2.7 E'quivalence et instanciation 87
Example The following sequence is an increasing sequence : Z, Z 2, Y , X, X + Y 3,
X2, Y 2X2, X3 + Z, X4.

Intuitively, each binder of a type will be associated a polynomial variable (X, Y ,
or Z). Whereas the abstraction relation only modifies Y and Z binders, irreversible
instantiations modify X binders. The following definition make it easier to talk about
the X variables of a given polynomial.

Definition 2.7.1 The X-degree of a polynomial P is its degree in the variable X,
where the coefficients are considered in the ring (Z[Z][Y ]). We write X 2 P if the
X-degree of P is not 0. As a matter of fact, we have X 2 P if and only if X appears
in the reduced form of P .

This definition is used in the first and fourth properties of the following. The other
results are straightfoward. We omit the proof.

Properties 2.7.2 We have the following properties for any P, Q and R in Z[X][Y ][Z] :

i) If X /2 P and X /2 P 0, then X /2 P + P 0.
ii) If P ? Q, then P + R ? Q + R.
iii) If P > 0 and R > 0, then P * R > 0.

iv) If we have P 6 Q 6 R and X /2 R - P , then X /2 R - Q and X /2 Q - P .

The latter property can be intuitively interpreted as follows : consider three types oep,
oeq and oer such that oep v oeq (1) and oeq v oer (2) hold (under some unspecified prefix).
We write P , Q and R for the polynomials associated to oep, oeq and oer, respectively.
If some X binder is modified during the first instantiation (1) or during the second
one (2), which implies X 2 Q - P or X 2 R - Q, then X is to appear in R - P . In
other words, each transformation on some X binder during instantiation will remain
visible forever.

2.7.2 Weight

If (Q) oe1 j oe2 holds, then we have (Q) oe1 v oe2 and (Q) oe2 v oe1 by I-Equiv?
and symmetry of j. Conversely, we want to show that if both (Q) oe1 v oe2 and (Q)
oe2 v oe1 hold, then (Q) oe1 j oe2 is derivable. As mentioned above, each type is given a
weight which reflects its binding structure. While weights are stable under equivalence,
they strictly decrease by irreversible instantiation and irreversible abstraction. In the
following paragraph, we give an illustrating example that should give the intuition
behind weights. The definitions or terms that we introduce there are not meant to be
formal and are not used further in the document.

87

88 Proprie'te's des relations sous pre'fixes
Introduction to weights Weights are meant to give some information about the
binding structure of types. For example, take the following type, written oe (the type
being too large, we display it on several lines)

8 (ff >= ? )
8 (fi >= 8 (fi1 >= ? ) 8 (fi2 = ? ) fi1 ! fi2)
8 (fl = 8 (fl1 >= ? ) 8 (fl2 = ? ) fl1 ! fl2)
ff ! fi ! fl

Its binding structure depends only on the locations of ?. In the above example, ?
occurs five times. For illustration purposes, we give a number to each occurrence of ? :

8 (ff >= ?1 )
8 (fi >= 8 (fi1 >= ?2 ) 8 (fi2 = ?3 ) fi1 ! fi2)
8 (fl = 8 (fl1 >= ?4 ) 8 (fl2 = ?5 ) fl1 ! fl2)
ff ! fi ! fl

We represent this type with the following graph :

!

?1 !

! !
?2 ?3 ?4 ?5
We consider all occurrences of ? and (informally) associate a path to each occurrence.
In this context, a path is a word in the set {=, >=}, such as >= >= = >= >=.

- ?1 appears inside a flexible context (see page 74) that is directly in the bound of

ff, which is flexible. Hence, the path associated to ?1 is >=.
- ?2 appears directly in the bound of fi1, and fi1 is in the bound of fi. Both fi and

fi1 are flexible, thus the path associated to ?2 is written >=>=.
- ?3 appears in the bound of fi2, which is rigid, and fi2 is in the bound of fi, which

is flexible. Hence, the path associated to ?3 is >==.
- Similarly, the path associated to ?4 is =>=, and the path associated to ?5 is ==.

88

2.7 E'quivalence et instanciation 89

On graphs, we simply label flexible bindings with >= and rigid bindings with =.

!

?1 !

! !
?2 ?3 ?4 ?5

>=

>=

=

>= = >= =
We now show in detail how we compute the polynomial associated to this type.
The first step consists in associating a polynomial variable to each binding arrow.
Then, each path can be easily mapped to a monomial. The second step simply adds all
the monomials associated to the paths of occurrences of ?.

- Both ?1 and ?2 appear in flexible contexts (see page 74), that is, their path is of

the form >=* (a sequence of >=). Instantiation (v) is allowed in such contexts. We
will weight such contexts using the polynomial variable X. More precisely, the
weight associated to >= (that is, to the path of ?1) is X, and the weight associated
to >=>= (that is, to the path of ?2) is XX, that is X2.

- Both ?3 and ?5 appear in rigid contexts (see page 74), that is, their path is

of the form >=*=+ (a sequence of >= followed by a non-empty sequence of =).
Abstraction (@-) is allowed in such contexts, but not instantiation. We will weight
the rigid part of such contexts using the polynomial variable Y . More precisely,
the weight associated to >== (that is, the path of ?3) is XY , and the weight
associated to == (that is, the weight of ?5) is Y Y , that is Y 2.

- Finally, the path associated to ?4 is =>=. The context of ?4 is of the form Cr(Cf ),

and neither abstraction nor instantiation is possible in such a context. We will
weight the non-flexible and non-rigid part of such contexts using the polynomial
variable Z. More precisely, the weight associated to =>= (that is, the path of ?4)
is Y Z.

The total weight of oe is obtained by adding all the monomials computed for each
occurrence of ?. Thus, we get the polynomial X + X 2 + XY + Y 2 + Y Z.

89

90 Proprie'te's des relations sous pre'fixes

Fig. 2.6 - Paths and weights
Path Associated polynomial variable

i timesz ""-- -
>= . . . >=-- -z ""

Xi

X

i timesz ""-- -
>= . . . >=-- -z ""

Xi

j + 1 timesz ""-- -

= . . . =-- -z ""

Y j+1

Y

i timesz ""-- -
>= . . . >=-- -z ""

Xi

j + 1 timesz ""-- -

= . . . =-- -z ""

Y j+1

k timesz ""-- -
>= \Pi 1 . . . \Pi k-- -z ""

Zk+1

Z

We can also label each binder of the graph above with its corresponding weight.

!

?1 !

! !
?2 ?3 ?4 ?5

X

X

Y

X Y Z Y
In summary, we use polynomial variables to weigh the contexts in which ? occurs.
The polynomial variable X is used for flexible contexts whose path is of the form >=i, the
polynomial variable Y is used for rigid contexts whose path is of the form >=i=j+1 and
the polynomial variable Z is used for contexts whose path if of the form >=i =j+1 >=\Pi k.
This is summarized in Figure 2.6. We wish to define weight incrementally. Hence, we
assume given a "current" path that we incrementally extend. Assume the current path is
>=i. It weighs Xi, and its associated variable is X. If we add >= to this path, we see that
the weight is multiplied by X, which gives X i+1. If we add =, the weight is multiplied
by Y , which gives XiY . This is why we define the auxiliary operator ? below, such

90

2.7 E'quivalence et instanciation 91
that X ? >= is X and X ? = is Y . To continue, assume the current path is >=i=j+1. It
weighs XiY j+1, and its associated variable is Y . If we add >= to this path, the weight
is multiplied by Z, which gives X iY j+1Z. If we add =, the weight is multiplied by Y .
Hence, we define Y ?>= as Z and Y ?= as Y . Similarly, if the current path is >=i=j+1 >=\Pi k,
the associated variable is Z. Adding X or Y to such a path multiplies the weight by
Z. Hence, Z ? >= and Z ? = are both equal to Z. This should explain the following
definition :

Definition 2.7.3 We define the auxiliary binary operator ? on the set {X, Y, Z} *
{>=, =} as follows :

X ? >= is X X ? = is Y Y ? >= is Z Y ? = is Y Z ? \Pi  is Z
As seen above, the weight associated to each occurrence of ? depends on the its path,
that is, on its context. The polynomial variables X, Y , and Z represent three kinds of
paths. This is why we define three functions wA for A in {X, Y, Z}, where A represents
intuitively the current path. Each wA maps types to polynomials in Z[X][Y ][Z]. Here
is the structural definition of wA :

wA(?)

M= 1 wA(o/ ) M= 0

wA(8 (ff \Pi  oe) oe0)

M= 8?!?:wA(oe

0) if ff /2 ftv(oe0)

wA(oe) if nf(oe0) = ff
wA?\Pi (oe) * (A ? \Pi ) + wA(oe0) otherwise

By default, the notation w(oe) means wX(oe). Note that wA(oe) ? 0 for any A and oe,
that is, wA(oe) is in IN [X][Y ][Z].

Examples One can check that oe, given above, does weigh X + X 2 + XY + Y 2 + Y Z.
As another example, the weight of 8 (fi = 8 (ff >= ?) ff ! ff) fi ! fi is Z 2 and the weight
of the type of the identity 8 (ff >= ?) ff ! ff is X. Note that 8 (ff >= ?) ff ! ff and
8 (ff >= ?) (ff ! ff) ! (ff ! ff) have the same weight, whereas their structure (skeleton)
are different.

We have characterized monotypes by their normal form, or by their projection (as
in Property 2.1.5.i (page 67)). Another way is to use weights:

Lemma 2.7.4 We have wA(oe) = 0 iff oe 2 T .

Proof: By Property 2.1.5.i (page 67), we only have to show that wA(oe) = 0 if and
only if there is no u such that oe/u = ?. The proof by structural induction on oe is
straightforward.

91

92 Proprie'te's des relations sous pre'fixes
Understanding weight

Let's have a look at the rules defining abstraction @- and instantiation v. We can
consider these rules as rewriting rules taking a type and returning an instantiated type.
Rules such as R-Context-R, R-Context-Flexible, . . . define the contexts in which
the rewriting can be applied. Some rules are not symmetric, and possibly not reversible,
namely the rules A-Hyp, I-Hyp, I-Rigid and I-Bot. Each time I-Bot is used (with
restrictions of Lemma 2.3.1), the domain of the projection of its argument grows : if
(Q) oe v oe0 holds by I-Bot and context rules, then the domain of oe is included in
the domain oe0. For example, consider ? v ff ! ff : the domain grows from {ffl} to
{ffl, 1, 2}. However, rules A-Hyp, I-Hyp and I-Rigid keep the same projection (relative
to a given prefix). This is immediate for I-Rigid since projections ignore the kind of
bounds. As for A-Hyp (or, similarly, I-Hyp), consider this typical example :

(ff = oe) 8 (fi = oe) fi ! ff v 8 (fi = ff) fi ! ff
It can be derived by R-Context-Rigid and A-Hyp. The skeleton associated to both
sides (and under the prefix (ff = oe)) is proj(oe) ! proj(oe). Hence, in such an example,
the projection is kept unchanged. Binders, however, have been modified, and weights
are modified too. Indeed, the weight of 8 (fi = oe) fi ! ff is Y * wY (oe), while the weight
of 8 (fi = ff) fi ! ff is 0. We see that weights and projections are complementary :
although projections are stable under A-Hyp, I-Hyp and I-Rigid, these rules decrease
weights. However, we do not have (Q) oe1 j oe2 if and only if w(oe1) = w(oe2) and
8 (Q) oe1/ = 8 (Q) oe2/. This result is true only if oe2 is known to be an instance of

oe1 under Q, as stated in Property 2.7.6.ii. As a counterexample, take oe1

M= 8 (ff >= ?)

8 (fi >= oeid) (ff ! ff) ! fi and oe2

M= 8 (ff >= ?) 8 (fi >= oe

id) fi ! (ff ! ff), to be takenunder an empty prefix. We do have

oe1/ = oe2/, more precisely both oe1 and oe2 have the

skeleton (? ! ?) ! (? ! ?). Besides, w(oe1) and w(oe2) are both equal to X + X2.
However, oe1 and oe2 are not equivalent since they do not have the same normal form
up to rearrangement.

Like projections, weights are stable under equivalence :

Lemma 2.7.5 If (Q) oe1 j oe2 holds, then wA(oe1) = wA(oe2).

Proof: By induction on the derivation of (Q) oe1 j oe2. Case Eq-Refl is obvious. Cases
Eq-Comm, Eq-Var, and Eq-Free are immediate by definition of wA. In the case EqMono, both sides weigh 0. Cases R-Trans and R-Context-L are by induction hypothesis. As for R-Context-R, we have oe1 = 8 (ff\Pi oe) oe01, oe2 = 8 (ff\Pi oe) oe02, and the premise
is (Q, 8 (ff\Pi oe)) oe01 j oe02 (1) We have to show that wA(8 (ff\Pi oe) oe01) = wA(8 (ff\Pi oe) oe02). By
induction hypothesis and (1), we have wA0(oe01) = wA0 (oe02) (2), for any A0 in {X, Y, Z}.
We proceed by case analysis :

92

2.7 E'quivalence et instanciation 93

Subcase oe 2 T : Then by Lemma 2.7.4 we have wA(oe) = 0, thus we have wA(8 (ff\Pi oe)
oe01) = wA(oe01) and wA(8 (ff \Pi  oe) oe02) = wA(oe02), and the result follows from (2). We can

now consider oe not in T , that is ff /2 dom( "Q, ff \Pi  oe). Writing ` for "Q, ff \Pi  oe, we have
ff /2 dom(`) (3).

Subcase ff /2 ftv(oe01): Then by Property 1.5.11.ix (page 56), (1), and (3), we have
ff /2 ftv(oe02). Hence, we have wA(8 (ff \Pi  oe) oe01) = wA(oe01), wA(8 (ff \Pi  oe) oe02) = wA(oe02), and
we conclude by (2).

Subcase ff /2 ftv(oe02): similar. We consider now that ff 2 ftv(oe01) and ff 2 ftv(oe02).
Subcase nf(oe01) = ff: Then `(ff) = `(nf(oe02)) holds from Lemma 1.5.9 and (1).
Hence, we get ff = `(nf(oe02)) (4) from (3). By well-formedness of (Q, ff \Pi  oe), we have ff /2

ftv( "Q, ff \Pi  oe), thus we have ff /2 codom(`). Hence (4) gives nf(oe02) = ff. Thus wA(8 (ff \Pi  oe)
oe01) = wA(oe) = wA(8 (ff \Pi  oe) oe02), which is the expected result.

Subcase nf(oe02) = ff : similar.
Otherwise we have nf(oe01) 6= ff, nf(oe02) 6= ff, ff 2 ftv(oe01), and ff 2 ftv(oe02), hence by
definition we get wA(8 (ff \Pi  oe) oe01) = wA?\Pi (oe) * (A ? \Pi ) + wA(oe01) and wA(8 (ff \Pi  oe) oe02) =
wA?\Pi (oe) * (A ? \Pi ) + wA(oe02). They are equal by (2).

How to lose weight

Although weights are stable under equivalence, instantiation decreases weight and
increases the domain of projections.

Properties 2.7.6 If (Q) oe1 @- oe2 holds, then the two following properties are true for
A = Y and A = X. If (Q) oe1 v oe2 holds, then the two following properties are true for
A = X.

i) If 8 (Q) oe1/ = 8 (Q) oe2/, then wA(oe1) ? wA(oe2).
ii) If 8 (Q) oe1/ = 8 (Q) oe2/ and wA(oe1) = wA(oe2), then (Q) oe1 j oe2 holds.

Proof: We prove both properties simultaneously. By Lemma 2.5.5, we have a derivation
of (Q) oe1 ""_ff oe2 (1). By Lemma 2.5.6, the derivation is assumed restricted. We prove
both properties by induction on the derivation of (1).

ffi Case A-Equiv' : We have (Q) oe1 j oe2. By Lemma 2.7.5, we have wA(oe1) = wA(oe2).
Hence, Properties i and ii hold.

ffi Case R-Trans The premises are (Q) oe1 ""_ff oe01 (2) and (Q) oe01 ""_ff oe2 (3). By
induction hypothesis on (2), if 8 (Q) oe1/ = 8 (Q) oe01/, then wA(oe1) ? wA(oe01) (4).
By induction hypothesis on (3), if 8 (Q) oe01/ = 8 (Q) oe2/, then wA(oe01) ? wA(oe2) (5).
By Property 2.1.3.ii (page 66), (2), and (3), we have 8 (Q) oe1 6/ 8 (Q) oe01 (6), and
8 (Q) oe01 6/ 8 (Q) oe2 (7). We prove Property i : Assume 8 (Q) oe1/ = 8 (Q) oe2/ holds.
Then we have 8 (Q) oe2 6/ 8 (Q) oe01 from (6) thus 8 (Q) oe01/ = 8 (Q) oe2/ = 8 (Q) oe1/
holds by antisymmetry (Property 2.1.2.i (page 65)) and (7). As a consequence, we have

93

94 Proprie'te's des relations sous pre'fixes

wA(oe1) ? wA(oe01) (8) from (4) and wA(oe01) ? wA(oe2) (9) from (5). Thus, we have
wA(oe1) ? wA(oe2) by transitivity of ? on polynomials. This proves Property i.

By induction hypothesis on (2), if 8 (Q) oe1/ = 8 (Q) oe01/, and wA(oe1) = wA(oe01), then
there exists a derivation of (Q) oe1 j oe01 (10). By induction hypothesis on (3), if 8 (Q)
oe01/ = 8 (Q) oe2/, and wA(oe01) = wA(oe2), then there exists a derivation of (Q) oe01 j
oe2 (11). We prove Property ii : As seen above, if 8 (Q) oe1/ = 8 (Q) oe2/, then 8 (Q)
oe1/ = 8 (Q) oe2/ = 8 (Q) oe01/. Additionally, if wA(oe1) = wA(oe2), then (8) and (9) imply
wA(oe1) = wA(oe01) = wA(oe2), by antisymmetry of ? on polynomials. Consequently, we
have a derivation of (Q) oe1 j oe01 by (10) and a derivation of (Q) oe01 j oe2 by (11). Hence,
we get a derivation of (Q) oe1 j oe2 by R-Trans. This proves Property ii.

ffi Case A-Hyp' and I-Hyp' : We have either (Q) oe1 v ff1 (that is, oe2 is ff1), with
(ff1 >= oe1) 2 Q, or (Q) oe1 @- ff1 with (ff1 = oe1) 2 Q. By Lemma 2.3.1, oe1 is not in T , thus
wA(oe1) 6= 0 by Lemma 2.7.4. Additionally, wA(oe2) = wA(ff1) = 0 by definition. Hence,
wA(oe1) > wA(oe2), which proves Properties i and ii.

ffi Case A-Alias' and I-Alias' : We have oe1 = 8 (ff1\Pi oe) 8 (ff2\Pi oe) oe0 and oe2 = 8 (ff1\Pi oe)
8 (ff2 = ff1) oe0. By restrictions of Lemma 2.5.6, we have ff1 2 ftv(oe0) and ff2 2 ftv(oe0).
Besides, oe /2 T (1). By definition we have wA(oe1) = wA(oe0) + 2 * B * wB(oe), where B is
A?\Pi , and we have wA(oe2) = wA(oe0)+B *wB(oe). Hence, wA(oe1)-wA(oe2) = B *wB(oe),
which is strictly greater than 0 by Lemma 2.7.4 and (1). This implies wA(oe1) > wA(oe2)
by Property 2.7.2.ii (page 87), thus Properties i and ii hold.

ffi Case A-Up' and I-Up' : We have oe1 = 8 (ff \Pi  8 (ff0 \Pi 0 oe0) oe) oe00 and oe2 = 8 (ff0 \Pi 0 oe0)
8 (ff \Pi  oe) oe00. We have wA(oe1) = wA(oe00) + B * (wB(oe) + C * wC (oe0)) (1), where B is
A ? \Pi  and C is B ? \Pi 0. Similarly, we have wA(oe2) = wA(oe00) + D * wD(oe0) + B * wB(oe) (2)
where D is A ? \Pi 0. If we are in the case A-Up', then \Pi  and \Pi 0 are rigid, thus B is A? =,
that is Y (A is X or Y ), C is Y , and D is Y . If we are in the case I-Up', then \Pi  is >,
A is X, thus B is X, C is X ? \Pi 0, and D is X ? \Pi 0. In both cases, C = D. Hence, we
have wA(oe2) = wA(oe00) + C * wC(oe0) + B * wB(oe) (3) from (2). From (1) and (3), we
get wA(oe1) - wA(oe2) = C * wC (oe0) * (B - 1) (4). Since B is X or Y , we have B > 1,
that is, B - 1 > 0 (5). Since oe0 is not in T , we have wC(oe0) > 0 (6) by Lemma 2.7.4.
Hence wA(oe1) - wA(oe2) > 0 by Property 2.7.2.iii (page 87), (5), (6), and (4), that is,
wA(oe1) > wA(oe2). This proves Properties i and ii.

ffi Case R-Context-R We have (Q) oe1 ""_ff oe2, with oe1 = 8 (ff \Pi  oe0) oe01, oe2 = 8 (ff \Pi  oe0)
oe02, and the premise is (Q, ff \Pi  oe0) oe01 ""_ff[{ff} oe02 (1). If 8 (Q) oe1/ = 8 (Q) oe2/, then by
notation 8 (Q, ff \Pi  oe0) oe01/ = 8 (Q, ff \Pi  oe0) oe02/, thus, by induction hypothesis, Property i,
and (1), we have wA(oe01) ? wA(oe02) (2). We proceed by case analysis.

Subcase oe0 2 T : Then by definition we have wA(oe1) = wA(oe01) and wA(oe2) =
wA(oe02), thus (2) proves Property i. Additionally, if we have wA(oe1) = wA(oe2), then we
have wA(oe01) = wA(oe02), thus (Q, ff \Pi  oe0) oe01 j oe02 holds by induction hypothesis and (1).
We get (Q) oe1 j oe2 by R-Context-R, which proves Property ii. In the following, we
assume oe0 /2 T (3).

Subcase nf(oe01) = ff : Then we have (Q, ff\Pi oe0) oe01 j oe02 by Lemma 2.1.6 and (1). Thus
(Q) oe1 j oe2 holds by R-Context-R, and we get the expected result by Lemma 2.7.5.
In the following, we assume that nf(oe01) is not ff.

94

2.7 E'quivalence et instanciation 95

Subcase nf(oe02) = ff and ff 2 ftv(oe01) (4): Then oe01 j ff by Property 2.1.7.ii (page 68)
and (1), and this is the previous subcase.

Subcase ff 2 ftv(oe01) and ff /2 ftv(oe02): This is not possible by Lemma 2.1.4 (page 67)
and (3).

Subcase ff 2 ftv(oe02) and ff /2 ftv(oe01) (5): This is not possible by Lemma 2.5.7
(page 82) and (3) (ff is in _ff [ {ff}). In the following, we assume that nf(oe02) is not ff
(because such a case corresponds necessarily to subcases (4) or (5)).

Subcase ff 2 ftv(oe02) and ff 2 ftv(oe01): We assumed that nf(oe01) 6= ff and nf(oe02) 6= ff,
thus by definition, we have wA(oe1) = wB(oe0) * B + wA(oe01), where B is A ? \Pi . Similarly,
we have wA(oe2) = wB(oe0)*B +wA(oe02). Hence wA(oe1)-wA(oe2) = wA(oe01)-wA(oe02) (6)
which is greater or equal to 0 by (2). This proves Property i. If wA(oe1) = wA(oe2), then
(6) implies wA(oe01) = wA(oe02). Hence, by induction hypothesis and (1), there exists a
derivation of (Q, ff \Pi  oe0) oe01 j oe02. We get (Q) oe1 j oe2 by R-Context-R. This proves
Property ii.

ffi Case A-Context-L' and I-Context-L' : We have (Q) oe1 "" oe2, with oe1 = 8 (ff\Pi oe01)
oe0 and oe2 = 8 (ff \Pi  oe02) oe0. The premise is (Q) oe01 ""_ff oe02 (1). Moreover, if ""_ff is v_ff,
then \Pi  is flexible ; if ""_ff is @-_ff, then \Pi  is rigid. By Lemma 2.5.6, we have nf(oe0) 6= ff and
ff 2 ftv(oe0), that is, there exists u such that oe0/u = ff (2). We prove Property i. Assume
8 (Q) oe1/ = 8 (Q) oe2/ holds. Then by Property 1.3.3.i (page 42), we get \Theta Q(oe1) =
\Theta Q(oe2). Hence, we have \Theta Q(oe1) * u/ = \Theta Q(oe2) * u/, that is, \Theta Q(oe01) = \Theta Q(oe02) by (2).
By Property 1.3.3.i (page 42), this implies 8 (Q) oe01/ = 8 (Q) oe02/. Let B be A ? \Pi .
By induction hypothesis and (1), we get wB(oe01) ? wB(oe02) (3). We have wA(oe1) =
wA(oe0)+wB(oe01)*B. Similarly, wA(oe2) = wA(oe0)+wB(oe02)*B. Hence we have wA(oe1)-
wA(oe2) = B*(wB(oe01)-wB(oe02)) (4), thus we get wA(oe1) ? wA(oe2) from (3). This proves
Property i. If wA(oe1) = wA(oe2), then (4) implies wB(oe01) = wB(oe02), thus (Q) oe01 j oe02
is derivable by induction hypothesis and (1). Hence (Q) oe1 j oe2 is derivable by RContext-L. This proves Property ii.

ffi Case I-Abstract' : By induction hypothesis.
ffi Case I-Bot' : We have oe1 = ?. Hence, (8 (Q) oe1)/ffl = ?. By Lemma 2.5.6, we have
oe2 /2 V, and oe2 is not ?. Hence, oe2/ffl is a type constructor g. By definition, we have
8 (Q) oe1 </ 8 (Q) oe2, which proves Properties i and ii.

ffi Case I-Rigid' : In this case, ""_ff is v_ff, and A is X. We have 8 (Q) oe1/ = 8 (Q) oe2/
and oe1 is of the form 8 (ff>=oe) oe0, while oe2 is of the form 8 (ff=oe) oe0. By Lemma 2.5.6, we
have ff 2 ftv(oe0), nf(oe0) 6= ff, and oe /2 T (1). By definition, wX (oe1) is wX (oe0)+X*wX(oe),
while wX(oe2) equals wX (oe0) + Y * wY (oe). We get w(oe1) - w(oe2) = XwX(oe) - Y wY (oe).
By (1) and Lemma 2.7.4, we get wX (oe) 6= 0. The X-degree of XwX (oe) is at least 1, but
the X-degree of Y wY (oe) is 0. Hence, XwX (oe) - Y wY (oe) > 0, that is, w(oe1) > w(oe2).
This proves Properties i and ii.

Then we can show that the equivalence relation is the symmetric kernel of the
instance relation.

95

96 Proprie'te's des relations sous pre'fixes
Properties 2.7.7

i) If we have (Q) oe1 v oe2 and (Q) oe2 v oe1, then (Q) oe1 j oe2 holds.
ii) If (Q) oe v ? holds, then nf(oe) is ?.

Proof: Property i : By Property 2.1.3.ii (page 66), we get 8 (Q) oe1/ 6/ 8 (Q) oe2/ and
8 (Q) oe2/ 6/ 8 (Q) oe1/. Hence, by antisymmetry (Property 2.1.2.i (page 65)), we get
8 (Q) oe1/ = 8 (Q) oe2/. By Property 2.7.6.i, we get w(oe1) ? w(oe2) and w(oe2) ? w(oe1).
Hence, w(oe1) = w(oe2), thus, by Property 2.7.6.ii, there exists a derivation of (Q) oe1 j oe2.

Property ii: By I-Bot, we have (Q) ? v oe. By Property i, we get (Q) oe j ?. By
Lemma 1.5.9, we get nf( bQ(oe)) = ?. By Property 1.5.6.iii (page 53), this gives bQ(nf(oe)) =
?. Hence, we must have nf(oe) = ?.

Weight watchers

As mentioned above, X corresponds intuitively to flexible contexts. Besides, the
abstraction relation only occurs in rigid contexts. Thus, we expect "X-binders" to be
kept unchanged by abstraction. Conversely, if an instantiation does not modify "Xbinders", we expect it to be a true abstraction. This last point is stated exactly in the
following lemma :

Lemma 2.7.8 Assume bQ(nf(oe2)) /2 #. Then we have (Q) oe1 v oe2, 8 (Q) oe1/ = 8 (Q)
oe2/, and X /2 w(oe1) - w(oe2) if and only if (Q) oe1 @- oe2.

It is shown by induction on the derivation of (Q) oe1 v oe2 for the first implication and
by induction on the derivation of (Q) oe1 @- oe2 for the second.
See details in the Appendix (page 253).

Note that "X-binders are kept unchanged" is expressed formally by X /2 w(oe1) -
w(oe2).

2.7.3 Abstraction is well-founded

In this section we show that abstraction is well-founded, as stated formally by
Corollary 2.7.10. First, we show that the weight associated to a type oe is bounded by
a polynomial that depends only on the size of oe.

Preliminary definitions We associate to any type oe a one-variable polynomial P (oe)
defined as w(oe)(X, X, X). The depth of oe, written d(oe), is by definition the degree of
P (oe). The size of oe is written #oe and is by definition the size of the finite set dom(oe).
The cardinal of the set ftv(oe) is written noe.

96

2.8 Confluence 97
Properties 2.7.9 We have the following properties :

i) For any polytype oe, each coefficient in P (oe) is bounded by #oe - noe.
ii) For any polytype oe, we have d(oe) 6 #oe.

The proof is by structural induction on oe. See details in the Appendix (page 256).

A weak ascending sequence of polytypes (oei)i2IN is a sequence such that (Q) oei @-
oei+1 holds for all i ? 0. A weak descending sequence is such that (Q) oei+1 @- oei (or,
equivalently, (Q) oei A- oei+1).

Corollary 2.7.10 Any weak ascending or weak descending sequence (oei)i2IN is stationary, that is, there exists n such that (Q) oei j oen holds for any i ? n

Proof: By Property 2.1.3.i (page 66), we have oei/ = oei+1/ for any i. Hence, for any i, we
have oei/ = oe0/ and #oei = #oe0. Let wi be w(oei). If the sequence is ascending, we have
(Q) oei @- oei+1, thus wi ? wi+1 holds by Property 2.7.6.i. If the sequence is descending,
we have wi 6 wi+1 for all i. Let Pi be the polynomial wi(X, X, X).

* We say that P is bounded by n, when each coefficient in P is bounded by n, and the

degree of P is bounded by n too. By Property 2.7.9.i, each coefficient in Pi is bounded
by #oei, that is, by #oe0. The degree of Pi is also bounded by #oe0 by Property 2.7.9.ii.
Hence, Pi is bounded by a constant #oe0. We note that Pi is in IN [X] (the coefficients
of P cannot be negative).

* The subset S of IN [X] of polynomials P bounded by n is finite, for any n. Hence,

the increasing (or decreasing) sequence (Pi)i2IN , which is included in S, is stationary.
Consequently, there exists a polynomial P and k such that for any i ? k, we have
Pi = P .

* The set of polynomials w in IN [X][Y ][Z] such that w(X, X, X) is P is finite too (indeed,

the equation nx + ny + nz = n, where n is given, admits a finite number of solutions in
IN 3.) Hence, the increasing (or decreasing) sequence (wi) is stationary. Consequently,
there exists n such that, by Property 2.7.6.i, (Q) oei j oen holds for i ? n. This is the
expected result.

In summary, any weak ascending sequence is finite, which also means that the
abstraction relation can be considered as a well-founded order (up to equivalence) on
the set of types. Such a result will be useful to show confluence of the abstraction
relation in Lemma 2.8.2.

2.8 Confluence

We wish to show two important confluence results. The first one is the confluence
of the abstraction relation (see Lemma 2.8.2). The second one is the commutation of
the abstraction relation and the instance relation, as stated in the Diamond Lemma

97

98 Proprie'te's des relations sous pre'fixes
(Lemma 2.8.4). To begin with, we show some auxiliary confluence results on the atomic
relations defined in Section 2.6. The properties below are used only in Lemma 2.8.2 and
(indirectly) in Lemma 2.8.4. These lemmas state the confluence of @- on the one hand,
and of @- and v on the other hand.

Properties 2.8.1

i) Assume oe1 is in normal form and Q is unconstrained. If we have (Q) oe1 .@-_ff oe2

and (Q) oe1 .@-_ff oe3, then there exists oe4 such that (Q) oe2 @- oe4 and (Q) oe3 @- oe4.

ii) The relation (j .@-;) is weakly confluent under an unconstrained prefix.
iii) Assume oe1 is in normal form and Q is unconstrained. If we have (Q) oe1 .@ oe2 and

(Q) oe1 .@- oe3, then there exist oe4 such that (Q) oe2 .@- oe4 and (Q) oe3 .@ oe4 holds.
iv) Assume Cf (oe1) is in normal form, level(Cf ) > 1, and Q is unconstrained. If we

have (QCf ) oe1 .@-

dom(Cf ) oe2, and (Q) Cf (oe1) .@-_ff oe3, then there exists oe4 such that

(Q) Cf (oe2) .@-_ff oe4 and (Q) oe3 .v oe4 hold.

These results are shown by considering the critical pairs.
See the full proof in the Appendix (page 257).

The following diagram illustrates the confluence of the abstraction relation (under
an unconstrained prefix).

oe1 oe2

oe3 oe4

@-

@-
@-

@-

This result is stated formally by the following lemma.
Lemma 2.8.2 (Confluence of the abstraction relation) If oe1 @- oe2 and oe1 @- oe3
hold, then there exists oe4 such that oe2 @- oe4 and oe3 @- oe4 hold.

Proof: By Property 2.6.2.i (page 84), the relations (j .@-;)

* and

@- are equivalent. Hence,

by hypothesis, we can derive both oe1 (j .@-;)

* oe

2 and oe1 (j .@-

;)* oe

3. By Property 2.8.1.ii,

(j .@-;) is weakly confluent. Besides, by Corollary 2.7.10, (j .@-;) is well-founded (up to

equivalence). Note that (j .@-;) is defined up to equivalence. Hence, (j .@-;)

* is confluent,

that is, there exists oe4 such that oe2 (j .@-;)

* oe

4 and oe3 (j .@-

;)* oe

4. We can equivalently

write oe2 @- oe4 and oe3 @- oe4. This is the expected result.

The instance relation v is not confluent. This is not surprising since the ML instance
relation, which is a subcase, is not : two incompatible instantiations of the same type

98

2.8 Confluence 99
variable cannot be merged. However, abstraction and instance commute, as described
by the following diagram, to be taken under an unconstrained prefix.

oe1 oe2

oe3 oe4

@-

v
@-

v

Lemma 2.8.3 Assume Q is unconstrained. If we have (Q) oe1 (j .v) oe2 and (Q)
oe1 (j .@-;) oe3, then there exists oe4 such that (Q) oe2 (j .@-;) oe4 and (Q) oe3 (j .v) oe4
hold.

Proof: If (Q) oe1 j oe2 or (Q) oe1 j oe3 hold, we get the expected result by taking
(respectively) oe4 = oe3 or oe4 = oe2. Otherwise, we have by definition

(Q) oe1 j oea1 (1) (Q) oea1 .v oe02 (Q) oe02 j oe2 (Q) oe1 j oeb1 (Q) oeb1 .@-_ff oe03

(Q) oe03 j oe3
Let oe01 be nf(oe1). By Property 1.5.6.iv (page 53), oe01 is in normal form and by Property 1.5.6.i (page 53), (Q) oe01 j oe1 holds. Besides, by Property 1.5.11.i (page 56) and (1),
oe01 ss nf(oea1 ) holds. By Property 2.6.3.i (page 85), there exists oe002 such that (Q) oe002 j oe02
and (Q) oe01 .v oe002 . Similarly, there exists oe003 such that (Q) oe003 j oe03 and (Q) oe01 .@-_ff oe003 .
Hence, we have

(Q) oe1 j oe01 (Q) oe01 .v oe002 (2) (Q) oe01 .@-_ff oe003 (Q) oe002 j oe2 (Q) oe003 j oe3
We have three rules to derive (2):

ffi Case C-Strict: Then (Q) oe01 .@ oe002 holds. By Property 2.8.1.iii, there exists oe4 such
that (Q) oe003 .@ oe4 and (Q) oe002 .@-_ff oe4. Hence, (Q) oe3 (j .v) oe4 and (Q) oe2 (j .@-;) oe4 hold,
which is the expected result.

ffi Case C-Abstract-F: Then by Property 2.8.1.iv, there exists oe4 such that (Q)
oe002 .@-_ff oe4 and (Q) oe003 .v oe4. Hence, we get (Q) oe2 (j .@-;) oe4 and (Q) oe3 (j .v) oe4, which
is the expected result.

ffi Case C-Abstract-R: then, (Q) oe1 @- oe2 and (Q) oe1 @- oe3, thus we conclude directly
by Lemma 2.8.2.

Lemma 2.8.4 (Diamond Lemma) If Q is unconstrained, (Q) oe1 v oe2 and (Q) oe1 @-
oe3 hold, then there exist oe4 such that (Q) oe2 @- oe4 and (Q) oe3 v oe4 hold.

99

100 Proprie'te's des relations sous pre'fixes

Proof: By Property 2.6.2.i (page 84), the relation @- is equivalent to (j .@-;)

* and the

relation v is equivalent to (j .v)*. Lemma 2.8.3 states the strong confluence of (j .@-;)
and (j .v), hence, there exist oe4 such that (Q) oe2 (j .@-;)

* oe

4 and (Q) oe3 (j .v) oe4. By
Properties 2.6.2.i (page 84) and 2.6.2.ii (page 84), this amounts to writing (Q) oe2 @- oe4

and (Q) oe3 v oe4.

The diamond lemma is stated under an unconstrained prefix. This restriction is
mandatory, as shown by the following counter-example. Take

oe1

M= 8 (ff) ff ! ff Q M= (fi = oe1) oe2 M= int ! int oe3 M= ff

Graphically, this gives

8 (ff) ff ! ff int ! int

ff ?

@-

v
@-

v

It is impossible to find any suitable oe4 which closes the diagram. Indeed, the only
instance of ff are types equivalent to ff, which cannot be abstractions of int ! int.

100

101
Chapitre 3
Relations sur les pre'fixes

Les pre'fixes jouent un ro^le crucial dans MLF. Alors que les solutions d'un proble`me
d'unification sont des substitutions en ML, c'est-a`-dire des fonctions des variables de
type vers les monotypes, en MLF les solutions d'un proble`me d'unification sont des pre'fixes, c'est-a`-dire des fonctions des variables de type vers les types (e'ventuellement des
polytypes). Ainsi, les pre'fixes peuvent e^tre vus comme une ge'ne'ralisation de la notion
de substitution aux polytypes. La section 3.1 montre comment un pre'fixe peut repre'senter une substitution sur les monotypes, comme en ML. Une substitution `1 est dite
plus ge'ne'rale qu'une substitution `2 lorsqu'il existe ` telle que `2 = ` ffi `1. Inversement,
on peut dire que `2 est une instance de `1. Une relation d'instance similaire, sur les pre'fixes, est donc envisageable dans MLF. Plus pre'cise'ment, les re`gles R-Context-Rigid
et R-Context-Flexible montrent que deux types 8 (Q) oe et 8 (Q0) oe avec le me^me
suffixe peuvent e^tre en relation d'instance, quel que soit le suffixe oe. Ceci sugge`re une
notion d'instance entre pre'fixes seuls. Cependant, comme les pre'fixes sont "ouverts",
cette relation doit e^tre de'finie par rapport a` un ensemble de variables qui contient les
variables libres de oe. Cet ensemble est alors appele' une interface et note'e I. Les relations entre pre'fixes sont de'finies section 3.2. Ensuite, nous e'tablissons quelques re'sultats
sur les pre'fixes et leur relation d'instance. Le re'sultat principal de ce chapitre est le
lemme 3.6.4, qui montre que si (Q) oe1 v oe2 (1) et Q0 est une instance de Q, alors
(Q0) oe1 v oe2 (2) est e'galement vrai. Ce re'sultat est utilise' pour montrer la correction
de l'algorithme d'unification. En effet, il montre qu'une relation d'instance e'tablie sous
pre'fixe Q sera toujours vraie (2) sous une instance de ce pre'fixe.

3.1 Substitutions

A monotype prefix is a prefix whose bounds are all in T . For example (ff1=o/1, . . . ffn=
o/n) is a monotype prefix, which embeds the substitution [o/1/ff1] ffi . . . ffi [o/n/ffn] within

101

102 Relations sur les pre'fixes
type expressions1. Conversely, given an idempotent substitution `, we write ` for the
corresponding monotype prefix. More precisely, ` is the prefix (ff = `(ff))ff2dom(`). Note
that since ` is idempotent, ` is automatically a well-formed prefix. As expected, we have
(Q) 8 (`) oe j `(oe) and (Q`) oe j `(oe) (the former by Rule Eq-Mono? and the latter
by iteration of Rule Eq-Mono). The following rule is derivable using R-Context-R
and Eq-Mono? :

Pr-Subst?

(Q`) oe1 "" oe2

(Q) `(oe1) "" `(oe2)

Note also that the substitution extracted from `, that is b`, is equal to `.

In Section 1.3.4 we defined the application of a substitution ` to a prefix Q. In
the particular case where Q is itself a substitution `0, we may wonder what is `(Q).
The answer is expressed in Property 3.1.1.i below. The case where ` is a renaming
OE corresponds to Property 3.1.1.ii. Finally, Property 3.1.1.iii gives the substitution
extracted from `(Q).

Properties 3.1.1 If we have dom(`0) # dom(`) [ codom(`), then the following properties hold :

i) The prefix `(`0) is a monotype prefix corresponding to the substitution ` ffi `0 restricted to dom(`0).
ii) The prefix OE(`0) is a monotype prefix corresponding to the substitution OE ffi `0 ffi OE~.

iii) For any prefix Q and renaming OE on dom(Q), we have [OE(Q) = OE ffi bQ ffi OE~.

Proof: Property i : By construction, `(`0) is a monotype prefix. The domain of `(`0) is
by definition dom(`0), that is, dom(`0). Let ff be in dom(`0). By definition, `(`0)(ff) is
`(`0(ff)), that is, ` ffi `0(ff). Hence, `(`0) and ` ffi `0 are equal on dom(`0).

Property ii : By definition, OE(`0) is a monotype prefix whose associated substitution `00
is defined as follows : ff 2 dom(`00) if and only if there exists fi 2 dom(`0) such that
OE(fi) = ff ; then `00(ff) is OE(`0(fi)) (1). Given any ff, we have OE ffi `0 ffi OE~(ff) = OE ffi `0(fi),
where ff is OE(fi). If ff 2 dom(`00), then OE ffi `0(fi) = `00(ff) by (1). Otherwise, `00(ff) is ff
and fi /2 dom(`0). Hence, `0(fi) = fi, thus OE ffi `0(fi) = OE(fi) = ff. In both cases, we have
OE ffi `0 ffi OE~(ff) = `00(ff). This holds for all ff, therefore `00 is OE ffi `0 ffi OE~.

Property iii : By definition, [OE(Q) is OE( bQ). We get the expected result by Property ii.
1Actually, prefixes are slightly more precise than substitutions because they are kept as a sequence
of elementary substitutions rather than just their composition.

102

3.2 Relation d'instance du pre'fixe 103
3.2 Prefix instance

As explained above, we define an instance relation on prefixes, relative to a set of
type variables I, called an interface. For example, we expect the prefixes (fi >=?, ff=fi !
fi) and (fl >= ?, ff = fl ! fl) to be equivalent under the interface {ff}, but not under the
interface {ff, fi} or {ff, fl}. To ease the presentation, we introduce a new notation : We
write \Sigma I for the set of types whose unbound variables are in I.

Definition 3.2.1 (Prefix instance) Let Q and Q0 be closed well-formed prefixes,
and I be a set of variables such that I ` dom(Q) " dom(Q0) holds. A prefix Q0 is an
instance of a prefix Q under the interface I, and we write Q vI Q0, if and only if
8 (Q) oe v 8 (Q0) oe holds for all types oe in \Sigma I . We omit I in the notation when it is
equal to dom(Q). We define Q jI Q0 and Q @-I Q0 similarly.

Let Q be a well-formed closed prefix. Then ; j Q holds, which means by notation
; j; Q. Conversely, Q jI ; holds if and only if I is empty. In particular, Q j ; does
not hold if Q is not empty. Although the relation jI is symmetric, we see that the
relation j (where the interface is left implicit) is not.

Example 3.2.8 For any oe, we can derive (;) 8 (ff >= ?) oe v 8 (fi) 8 (ff >= fi ! fi) oe by
Eq-Free, I-Nil, and context rules. More generally, if we have Q and Q0 unconstrained,
dom(`) ` dom(Q), and codom(`) ` dom(Q0), then we have Q v Q0`. This covers the
instantiation of substitutions in ML, where free variables have the implicit bound ?,
just as in Q (which is unconstrained), and where free variables can be substituted by
any monotype.

Properties 3.2.2

i) We have Q1 jI Q2 iff Q1 vI Q2 and Q2 vI Q1.
ii) If Q1 ss Q2, then Q1 j Q2.

It is a direct consequence of Property 2.7.7.i (page 96). See Appendix (page 265).

Assume we have (Q) oe v ff and oe is not a type variable. Then oe is instantiated to
a type variable bound in the prefix. The only way to do so is by either Rule A-Hyp
or Rule I-Hyp. This means that oe can be instantiated into the bound of ff. This is
expressed formally by the following properties.

Properties 3.2.3

i) If we have (Q) oe @- ff and oe /2 V, then (Q) oe @- Q(ff) holds.
ii) If we have (Q) oe v ff and oe /2 V, then (Q) oe v Q(ff) holds.
iii) For all Q and ff, (Q) Q(ff) v ff holds.

See proof in the Appendix (page 266).

103

104 Relations sur les pre'fixes
3.3 Domains of prefixes

As seen in Section 1.2, if Q is the prefix (ff1 \Pi 1 oe1, . . . ffn \Pi n oen), then its domain
dom(Q) is the set {ff1, . . . ffn}. We need to capture the notion of useful domain of a
prefix Q.

Definition 3.3.1 If I is a set of type variables, the domain of Q useful for I, written
dom(Q/I), is defined as follows :

ff 2 dom(Q/I) if and only if Q = (Q1, ff \Pi  oe, Q2) and ff 2 ftv(8 (Q2) rI )
We also write dom(Q/oe) instead of dom(Q/ ftv(oe)) and similarly dom(Q/oe1, oe2) instead
of dom(Q/ ftv(oe1) [ ftv(oe2)).

Intuitively, dom(Q/oe) is the domain of Q which is useful for oe. For example, if Q0
corresponds to Q, where all bindings not in dom(Q/oe) have been removed, then we
have 8 (Q) oe j 8 (Q0) oe by Eq-Free.

Properties 3.3.2

i) We have dom(Q/I [ J ) = dom(Q/I) [ dom(Q/J ).
ii) If Q ss Q0 holds, and _ff ` dom(Q), then dom(Q/ _ff) = dom(Q0/_ff).

See proof in the Appendix (page 268).

The notion of useful domain of a prefix can be viewed as an extension of the notion
of free variables. Indeed, in ML, all free variables have the bound ?, which means that
the implicit prefix Q is unconstrained. Then the domain of Q useful for a polytype oe,
i.e. dom(Q/oe), is exactly the set of free variables of oe. In MLF, however, a variable fi
can be in dom(Q/oe) directly or indirectly. For a direct example, take 8 (ff >= ?) ff ! fi
for oe, and (fi >= ?) for Q. For an indirect example, take 8 (ff >= ?) ff ! fl for oe, and
(fi >= ?, fl >= 8 (ffi) ffi ! fi) for Q. In the indirect example, fi is not free in oe, but fl is free
in oe and fi is free in the bound of fl. We see that fi is "indirectly" free in oe via the prefix
Q. This is captured by the notion of useful domain of the prefix, which is therefore an
extension of the notion of free variables.

3.4 Rules for prefix equivalence, abstraction, and instance

Prefix instance was defined in Definition 3.2.1. Below, we give a syntactic characterization. Inference rules defining prefix equivalence, prefix abstraction, and prefix
instance are given in figures 3.1, 3.2, and 3.3. As in Section 1.7, we use the symbol
""` as a meta-variable standing for j`, @-`, or v`. The notation Q ""I` Q0 implicitly requires Q and Q0 to be closed well-formed prefixes such that I ` dom(Q) " dom(Q0).

104

3.4 Re`gles pour l'e'quivalence, l'abstraction et l'instance du pre'fixe 105

Fig. 3.1 - Prefix equivalence
PE-Refl
Q jI` Q

PE-Trans

Q1 jI` Q2 Q2 jI` Q3

Q1 jI` Q3

PE-Free

ff /2 dom(Q) ff /2 I

Q jI` (Q, ff \Pi  oe)

PE-Mono

(Q, ff >= o/, Q0) jI` (Q, ff = o/, Q0)

PE-Context-L

(Q) oe1 j oe2

(Q, ff \Pi  oe1, Q0) jI` (Q, ff \Pi  oe2, Q0)

PE-Swap

oe /2 T

(Q, ff1 \Pi  oe, ff2 = ff1, Q0) jI` (Q, ff2 \Pi  oe, ff1 = ff2, Q0)

PE-Comm

ff1 /2 ftv(oe2) ff2 /2 ftv(oe1)

(Q, ff1 \Pi 1 oe1, ff2 \Pi 2 oe2, Q0) jI` (Q, ff2 \Pi 2 oe2, ff1 \Pi 1 oe1, Q0)

Fig. 3.2 - Prefix Abstraction
PA-Equiv

Q1 jI` Q2

Q1 @-I` Q2

PA-Trans

Q1 @-I` Q2

Q2 @-I` Q3

Q1 @-I` Q3

PA-Context-L

(Q) oe1 @- oe2

(Q, ff = oe1, Q0) @-I` (Q, ff = oe2, Q0)

Unsurprisingly, these rules are similar to the rules defining equivalence, abstraction,
and instantiation of types, except for Rule PE-Swap, which corresponds to (implicit)
ff-conversion between types.

We wish to show the equivalence between the relation vI` and the relation vI. To
begin with, we check that vI` is included in vI .

Lemma 3.4.1 If Q ""I` Q0 holds, then Q ""I Q0.

Proof: We show by induction on the derivation of Q ""I` Q0 that for any oe such that
ftv(oe) ` I, we have 8 (Q) oe "" 8 (Q0) oe. All cases are easy.

105

106 Relations sur les pre'fixes

Fig. 3.3 - Prefix instance
PI-Abstract

Q1 @-I` Q2

Q1 vI` Q2

PI-Trans

Q1 vI` Q2

Q2 vI` Q3

Q1 vI` Q3

PI-Rigid

(Q, ff >= oe1, Q0) vI` (Q, ff = oe1, Q0)
PI-Context-L

(Q) oe1 v oe2

(Q, ff >= oe1, Q0) vI` (Q, ff >= oe2, Q0)

The following rule is derivable by PE-Context-L and Eq-Mono :

PE-Mono?

(Q) oe j o/

(Q, ff = oe, Q0) j` (Q, ff = oe, Q0[o/ /ff])

We now prove some useful properties about prefix relations. For instance, Property i
below shows that the interface of a relation can always be shrinked. Notice also that
Q1 "";` Q2 always holds, for any prefixes Q1 and Q2. Property ii simply states that
derivations are stable under renaming. Property iii shows that it is always possible to
append a non-interfering prefix Q to both sides of a derivation of Q1 ""I` Q2. Property iv
shows that the equivalence between a prefix a renaming of this prefix can be derived.
Property v states if a sequence of binders is duplicated in a prefix (up to renaming),
both sequences can be merged by instantiation.

Properties 3.4.2

i) If Q1 ""I` Q2 and J ` I hold, then we have Q1 ""J` Q2.
ii) If OE is a renaming of dom(Q) [ dom(Q0), and if there is a derivation of Q ""I` Q0

of size n, then we have a derivation of OE(Q) ""OE(I)` OE(Q0) of size n.
iii) If Q1 ""I` Q2, Q # Q1, Q # Q2, and utv(Q) ` I, then Q1Q ""I[

dom(Q)

` Q2Q.iv) If OE is a renaming of
dom(Q) and Q a closed well-formed prefix, then we have

Q j` OE(Q)OE.
v) If OE is a renaming of domain dom(Q) such that Q1QOE(Q)Q2 is a well-formed

closed prefix, then we can derive Q1QOE(Q)Q2 v` Q1QOE~Q2.

See proof in the Appendix (page 268).

As explained in the introduction of this chapter, the main result is Lemma 3.6.4
(page 114). A less general case is stated by the next lemma. Namely, if two types oe and

106

3.4 Re`gles pour l'e'quivalence, l'abstraction et l'instance du pre'fixe 107
oe0 are equivalent under a prefix Q, and if Q0 is an instance of Q, then we expect oe and
oe0 to be equivalent under Q0 too. This statement is refined by providing the interface I
of the instance relation, as well as the set of free variables of oe and oe0. We recall that
\Sigma I is the set of types whose unbound variables are in I.

Lemma 3.4.3 If we have Q1 ""I` Q2, then for all oe and oe0 in \Sigma I such that (Q1) oe j oe0
holds, we have (Q2) oe j oe0.

Proof: By hypothesis, we have Q1 ""I` Q2 (1), (Q1) oe j oe0 (2), and ftv(oe) [ ftv(oe0) `
I (3). We have to show that (Q2) oe j oe0 (4) holds. We note that it suffices to show thatc

Q1 and cQ2 are equal on I (5). Indeed, Corollary 1.5.10 and (2) imply cQ1(oe) j cQ1(oe0) (6).
Additionally, (5), and (3) give cQ1(oe) = cQ2(oe) (7) and cQ1(oe0) = cQ2(oe0) (8). By (6), (7),
and (8), we get cQ2(oe) j cQ2(oe0), which implies (4) thanks to Corollary 1.5.10. We prove
either (4) or (5) according to which one is easier. The proof is by induction on the
derivation of (1).

ffi Case PE-Refl : Immediate.
ffi Case PE-Trans, PA-Trans, PI-Trans, PA-Equiv, and PI-Abstract : By induction hypothesis.

ffi Case PE-Comm and PI-Rigid : cQ1 is cQ2, thus (5) holds.

ffi Case PE-Free : We have Q2 = (Q1, ff\Pi oe). Hence, cQ2 = cQ1ffi`, where dom(`) ` {ff}.
By hypothesis, ff /2 I. Hence, cQ2 and cQ1 are equal on I, and we have shown (5).

ffi Case PE-Mono : By definition, cQ1 and cQ2 are equal, thus we have (5).
ffi Case PE-Context-L, PA-Context-L and PI-Context-L : By hypothesis, we
have Q1 = (Qa, ff \Pi  oe1, Qb) and Q2 = (Qa, ff \Pi  oe2, Qb). Besides, (Qa) oe1 "" oe2 (9) holds.

Let `a be cQa and `b be cQb. If ff /2 dom( cQ1), then, cQ1 is `a ffi `b, and cQ2 is `a ffi ` ffi `b,
where dom(`) ` {ff}. Hence, cQ2 is `a ffi ` ffi `a ffi `b, that is, `a ffi ` ffi cQ1 (10). By (6), (10),
and Property 1.5.11.v, we get `a ffi ` ffi cQ1(oe) j `a ffi ` ffi cQ1(oe0), that is, cQ2(oe) j cQ2(oe0)
by (10). This implies (4) by Corollary 1.5.10. Otherwise, ff 2 dom( cQ1), which means that
oe1 2 T . By Lemma 2.1.6 and (9), we get oe2 2 T and (Qa) oe1 j oe2. By Lemmas 1.5.9

and 1.5.6.iii (page 53), we get `a ffi "(ff \Pi  oe1) = `a ffi "(ff \Pi  oe2), thus cQ1 = cQ2 holds, that
is (5).

ffi Case PE-Swap: We have Q1 = (Qa, ff1 \Pi  oe, ff2 = ff1, Qb) (11) and Q2 = (Qa, ff2 \Pi 
oe, ff1 = ff2, Qb). Let `a be cQa and `b be cQb. Let `1 be "(ff1 \Pi  oe) and `2 be "(ff2 \Pi  oe). Note
that the substitution [ff2/ff1] ffi `1 ffi [ff1/ff2] is equal to the substitution `2 ffi [ff2/ff1] (12)
(consider the images of ff1 and ff2 for the two cases oe 2 T and oe /2 T ). Then using

these notations, cQ1 is `a ffi `1 ffi [ff1/ff2] ffi `b (13) and cQ2 is `a ffi `2 ffi [ff2/ff1] ffi `b (14).
By (6) and (13), we have `a ffi `1 ffi [ff1/ff2] ffi `b(oe) j `a ffi `1 ffi [ff1/ff2] ffi `b(oe0). Composing
by [ff2/ff1] (Property 1.5.11.v (page 56)), we get [ff2/ff1] ffi `a ffi `1 ffi [ff1/ff2] ffi `b(oe) j
[ff2/ff1] ffi `a ffi `1 ffi [ff1/ff2] ffi `b(oe0) (15). By well-formedness of (11), we have ff1 /2 dom(`a)
and ff2 /2 codom(`a). Hence, `a and [ff2/ff1] commute: from (15), we get `a ffi [ff2/ff1] ffi

107

108 Relations sur les pre'fixes

`1 ffi [ff1/ff2] ffi `b(oe) j `a ffi [ff2/ff1] ffi `1 ffi [ff1/ff2] ffi `b(oe0). By (12), we get `a ffi `2 ffi [ff2/ff1] ffi
`b(oe) j `a ffi `2 ffi [ff2/ff1] ffi `b(oe0). By (14), this is cQ2(oe) j cQ2(oe0). This implies (4) by
Corollary 1.5.10.

The instance relation on types v and the instance relation on prefixes are closely
related. In particular, if Q1 vI Q2 holds, and o/ 2 \Sigma I , we have by definition 8 (Q1)
o/ v 8 (Q2) o/ (1). Conversely, if (1) holds, we expect the prefix Q2 to be an instance
of the prefix Q1, under the interface ftv(o/ ), that is Q1 vftv(o/) Q2. Actually, we show

in the next lemma that Q1 v

ftv(o/)

` Q2 (2) holds, which implies Q1 v

ftv(o/) Q2 (3) by

Lemma 3.4.1. Showing (2) instead of (3) is more general, and is a key result used to
show the equality between vI` and vI. In summary, we show in Lemma 3.4.4 that (1)
implies (2). The statement of the lemma is, however, a bit more involved.

First, the main hypothesis (Q) oe1 "" oe2 is more general than (1). Additionally, the
constructed form of oe1 is 8 (Q1) o/1, which discards the case where nf(oe1) is ?. Similarly,
the constructed form of oe2 is 8 (Q2) o/2.

The main conclusion is QQ1 ""

dom(Q)[I

` QQ2` (4), which corresponds to (2) afteradding the prefix Q and a substitution `. The role of the substitution ` is to map

variables of Q1 to variables of Q2. Indeed, by renaming, 8 (Q1) o/1 and 8 (Q2) o/2 might
use different variable names ; we use the substitution ` to map names from 8 (Q1) o/1
to names of 8 (Q2) o/2. The correctness of this mapping could be intuitively expressed
by the equality `(o/1) = o/2 (5). Actually, (5) does not always hold, because the prefixes
Q and Q2 must be taken into account. Lemma 3.4.4 is more precise and provides the
correct result, that is, (QQ2) `(o/1) j o/2 (6). Note, though, that (5) implies (6). What
is more, ` is a substitution, but is not necessarily a renaming. For example, we have
(ff) 8 (fi = ff ! ff) fi ! fi j (ff ! ff) ! (ff ! ff) by Eq-Mono. In such a case,
the left-hand prefix is (fi = ff ! ff), and the right-hand prefix is empty. Then ` is the
substitution [ff ! ff/fi] ; it is not a renaming.

The lemma considers the constructed forms of oe1 and oe2 (see page 56), in order to
avoid degenerate cases. A type such as oe1

M= 8 (ff = 8 (Q0

1) o/1) ff hides its structure inthe bound of ff. By

Eq-Var, we have oe1 j 8 (Q01) o/1 (7). As mentioned above, the

substitution ` is used to link variables of dom(Q2) to variables of dom(Q1). If we do
not take the constructed form of oe1, Q1 would be a single binding (ff = 8 (Q01) o/1) (8).
However, because of the equivalence (7), the meaningful bindings are those of Q01, but
not only (8). In other words, it is not possible to map variables of dom(Q2) to ff only,
but it is possible to map them to dom(Q01). Taking the constructed form ensures that
the considered prefix is always the "meaningful" prefix.

Moreover, Lemma 3.4.4 assumes that we have nf(oe2) /2 # or Q(nf(oe2)) 2 T . This
assumption is also necessary to discard degenerate cases. For instance, let oe be 8 (Q) o/ .
We have (ff >= oe) oe v ff by I-Hyp. Without the assumption above, it could be given

108

3.4 Re`gles pour l'e'quivalence, l'abstraction et l'instance du pre'fixe 109
as input to the lemma. However, we cannot find a meaningful relation between the
prefix (ff >= oe, Q) and the prefix (ff >= oe), as required by (4). In such a case, we cannot
express (6) either.

Lemma 3.4.4 We assume we have nf(oe2) /2 # or Q(nf(oe2)) 2 T . We assume cf(oe1)
and cf(oe2) have well-formed prefixes. If we have (Q) oe1 "" oe2 and nf(oe1) 6= ?, cf(oe1)
is 8 (Q1) o/1, and Q1 # Q, then there exist an ff-conversion 8 (Q2) o/2 of cf(oe2) and a
substitution ` such that the following facts hold, writing I for dom(Q1/o/1).

(QQ2) `(o/1) j o/2 dom(`) ` I `(I) ` dom(Q) [ dom(Q2/o/2)

QQ1 ""dom(Q)[I` QQ2`
The proof is by induction on the derivation of (Q) oe1 "" oe2.
See details in the Appendix (page 270).

As explained above, Lemma 3.4.4 is a main result for proving the equivalence
between the relations vI and vI` . Actually, a first corollary of Lemma 3.4.4 is Property 3.4.5.i below. Then the expected equivalence (Property 3.4.5.ii) is a direct consequence.

Properties 3.4.5 We have the following properties :

i) If (;) 8 (Q1) rI "" 8 (Q2) rI , then Q1 ""I` Q2.
ii) We have Q1 ""I Q2 iff Q1 ""I` Q2.

Proof: Property i : Assume that we have 8 (Q1) rI "" 8 (Q2) rI. By Lemma 3.4.4, there
exists a renaming OE and a substitution ` such that the following hold :

(OE(Q2)) `(rI ) j OE(rI ) (1) J

M= dom(Q

1/I) (2) dom(`) ` J

`(J) ` dom(OE(Q2)/OE(I)) Q1 ""J` OE(Q2)` (3)
We have I ` J (4) from (2). Hence, we have Q1 ""I` OE(Q2)` (5) by Property 3.4.2.i, (4)
and (3). By Property 1.5.11.vii (page 56) and (1), we have "OE(Q2)ffi`(rI ) = "OE(Q2)ffiOE(rI ).
This implies that "OE(Q2) ffi ` and "OE(Q2) ffi OE are the same substitution on I. Hence,
OE(Q2)( "OE(Q2) ffi `) jI` OE(Q2)( "OE(Q2) ffi OE) (6) holds by PE-Free. Moreover, OE(Q2) "OE(Q2) ffi
OE jI` OE(Q2)OE (7) holds by PE-Mono?. Besides, Q2 j` OE(Q2)OE (8) holds by Property 3.4.2.iv. Additionally, we have OE(Q2)` jI` OE(Q2) "OE(Q2) ffi ` (9) by PE-Mono?.
By (5), (9), (6), (7), (8), and PE-Trans, we get Q1 ""I` Q2. This is the expected result.
Property ii: Directly, we have Q1 ""I Q2. Hence, 8 (Q1) rI "" 8 (Q2) rI holds by
definition. Hence by Property i, Q1 ""I` Q2 holds. The converse is from Lemma 3.4.1.

109

110 Relations sur les pre'fixes

We have shown that ""I and ""I` are the same relation. In the rest of the document,
we will use only the symbols jI , @-I , and vI to make the presentation lighter.

ML types as a particular case

The next lemma shows that under an unconstrained prefix the instance relation
corresponds to the instance relation of ML (in ML free variables are implicitly unconstrained in the prefix). As explained in Section 1.1, ML types can be injected in MLF
in the form 8 (ff1 >= ?) . . . 8 (ffn >= ?) o/ . Hence, in the framework of MLF, we call such
types ML types :

Definition 3.4.6 Polytypes of the form 8 (Q) o/ where Q is unconstrained are called
ML types.

Lemma 3.4.7 We assume Q unconstrained and that oe1 and oe2 are ML types, closed
under Q. Then (Q) oe1 v oe2 holds iff oe2 is an instance of oe1 in ML.

See proof in the Appendix (page 274).

Graphs representing ML types may only have binding arrows from nodes labelled
? to the top-level node. Besides, these arrows must be flexible. Here is an example of
an ML type :

!

!
? ?
This graph represents the type 8 (ff, fi) (ff ! fi) ! ff ! fi, that is, the type of
*(f ) *(x) f x, which we also call app. More precisely, we have represented 8 (ff, fi)
8 (fl = ff ! fi) fl ! fl, which is equivalent. The middle node represents fl, the left-hand
node is ff and the right-hand node is fi. The only bindings are from ff and fi to the
top-level node.

110

3.5 De'coupage du pre'fixe 111

Here is the type of a common function in ML :

!

!
! ! !

?

?
?

We have represented the type 8 (ff, fi, fl) (ff ! fi) ! (fi ! fl) ! ff ! fl, which is the
type of the (reversed) composition function *(f ) *(g) *(x) g (f x). (The type of the
normal composition function gives a more intricate graph.)

3.5 Splitting prefixes

In this section we present the split algorithm, which takes a prefix Q and a set of
variables _ff, and splits Q into two parts Q1 and Q2 such that the domain of Q1 is the
domain of Q useful for _ff (see Definition 3.3.1). In order to show how the split algorithm
is used, the following short story talks about generalization, which will be defined only
in Chapter 5. This means that the following explanation is better understood by readers
familiar with ML generalization, but should not frighten the others.

A short story of type generalization In ML, polymorphism is introduced by
generalization. More precisely, if an expression a has type oe and if ff is not free in the
typing environment \Gamma , then the expression a can be given the type scheme 8 (ff) oe.
This is possible for any type variable ff not free in \Gamma , that is, if ff and fi are not
free in \Gamma , a can be given the type 8 (ff) oe as well as 8 (fi) oe. As already mentioned
in Section 1.2, the prefix in ML is implicit and unconstrained. Hence, generalizing a
variable ff consists mostly of taking ff from the prefix and quantifying it in oe. The
prefix before generalization is (Q, ff), and the prefix after generalization is simply Q.
As for the type of a, it is oe before generalization, and 8 (ff) oe after. Note that in ML,

111

112 Relations sur les pre'fixes
bindings in the prefix are mutually independent, which implies that the prefixes (ff, fi)
and (fi, ff) are equivalent.

In MLF, we follow the same idea for generalization : a binding is taken from the
prefix and quantified in front of the type of the expression. Whereas bindings are
unconstrained in ML, they are of the general form (ff \Pi  oe) in MLF. Moreover, whereas
bindings are mutually independent in ML, they can depend on each other in MLF. For
instance, in the prefix Q = (ff >= ?, fi = 8 (fl) fl ! ff), the binding for fi depends on
ff because ff is free in the bound of fi. In ML, we could only have (ff >= ?, fi >= ?),
which is equivalent to (fi >= ?, ff >= ?), as remarked above. In ML, if ff is not free in
\Gamma , we can generalize it. Similarly, if fi is not free in \Gamma , we can generalize it. In MLF,
however, things are not so direct. Under prefix Q, we can generalize fi (if fi is not free
in \Gamma ), but we cannot generalize ff directly because ff is needed in the prefix, namely in
the bound of fi. As a consequence, the only way to generalize ff is first to generalize fi
(if possible), then to generalize ff. As a conclusion, generalization in MLF must follow
the dependencies of bindings. Therefore, when we wish to generalize as many variables
as possible (according to a given typing environment \Gamma ), we have to split the prefix
Q in two parts. The first part contains all bindings of variables free in \Gamma , as well as
bindings they depend on. The second part contains all remaining bindings, that is, type
variables that do not appear in \Gamma , directly or indirectly. In this section, we describe
this operation, the split algorithm. Note that, as mentioned above, splitting is trivial
in ML since bindings do not depend on each other.

In the following definition, we write q 1-! (Q1, Q2) for the pair (Q1q, Q2) and
q 2-! (Q1, Q2) for the pair (Q1, Q2q).

Definition 3.5.1 The split algorithm takes a closed prefix Q and a set _ff included
in dom(Q) and returns a pair of prefixes, which we write Q"_ff. It is defined inductively
as follows :

;" _ff = (;, ;) (Q, ff \Pi  oe)" _ff = ( (ff \Pi  oe)

1-! Q"(_ff - ff) [ ftv(oe) if ff 2 _ff

(ff \Pi  oe) 2-! Q" _ff if ff /2 _ff

It is obvious to check that this algorithm always terminates and never fails. The next
lemma shows its correctness.

Lemma 3.5.2 If Q" _ff is the pair (Q1, Q2), then we have (i) Q1Q2 ss Q, (ii) _ff `
dom(Q1), and (iii) dom(Q1/ _ff) = dom(Q1).

See proof in the Appendix (page 275).

112

3.6 Les pre'fixes et l'instanciation 113
3.6 Prefixes and Instantiation

This section gathers technical results that will be used mostly for unification. A
main result is Lemma 3.6.4 : it states that a judgment under a prefix Q still holds
under all instances of Q. In ML, a substitution ` can be applied to a whole typing
derivation. This can be viewed as instantiating all free type variables of the derivation.
In particular, if oe2 is an instance of oe1 in ML, then `(oe2) is an instance of `(oe1). In MLF,
we state a more general result : typing derivations are stated under a given prefix, and
instantiating the whole derivation amounts to instantiating the prefix. Thus, if oe2 is an
instance of oe1 under prefix Q, then oe2 must be an instance of oe1 under any instance of
Q (including monotypes instances, which represent substitutions). Hence, Lemma 3.6.4
entails that typing judgments are stable under substitution.

The next property extends the interface of an instantiation. For example, it takes
a derivation of Q vI Q0 as an input, and provides a derivation of Q vJ Q0` as an
output, with I ` J. This result is used for showing the completeness of the unification
algorithm (to be found in Chapter 4).

Lemma 3.6.1 Assume we have Q ""I Q0. Let J be dom(Q/I) and OE be a renaming of
dom(Q0), disjoint from I. Then there exists a substitution ` such that Q ""J OE(Q0)` and
dom(`) ` J - I hold.

Proof: By Definition 3.2.1, we have 8 (Q) rI "" 8 (Q0) rI. Alpha-converting the righthand side with the renaming OE, and observing that OE is disjoint from I, we get 8 (Q) rI ""
8 (OE(Q0)) rI. Let J be dom(Q/I). By Lemma 3.4.4, there exists an alpha-conversion
8 (Q00) o/ of 8 (OE(Q0)) rI (1) and a substitution `0 such that we have

(Q00) `0(rI ) j o/ (2) dom(`0) ` J `0(J) ` dom(Q00/o/ ) Q ""J Q00`0 (3)
From (1), there exists a renaming OE0 such that Q00 = OE0(OE(Q0)), that is, Q00 = OE0 ffi OE(Q0),
and o/ = OE0(rI ) (4). Let `00 be the substitution defined as OE0 on I and as `0 elsewhere (5).
From (2) and (4), we get (Q00) `0(rI ) j OE0(rI ), hence by Property 1.5.11.vii (page 56),

we have cQ00 ffi `0(rI ) = cQ00 ffi OE0(rI ), that is, cQ00 ffi `0 and cQ00 ffi OE0 are equal on I (6).
Therefore, we have cQ00 ffi `0 = cQ00 ffi `00 from (5) and (6). Then from (3), we get Q ""J Q00`00
by PE-Mono?. Hence, 8 (Q) rJ "" 8 (Q00) `00(rJ ) (7) holds by Definition 3.2.1 and
Eq-Mono?. Let ` be OE0~ ffi `00 restricted to J. We note that 8 (OE(Q0)) `(rJ ) is an alphaconversion of 8 (Q00) `00(rJ ). Hence, 8 (Q) rJ "" 8 (OE(Q0)`) rJ holds from (7). By
Property 3.4.5.i, we get Q ""J OE(Q0)`. Besides, dom(`) ` J and ` is invariant on I, thus
dom(`) ` J - I. This is the expected result.

The next property is a variant : we also extend the interface of an instantiation
Q ""I Q0, but the extended interface is the entire domain dom(Q) instead of dom(Q/I).

113

114 Relations sur les pre'fixes
Lemma 3.6.2 If we have Q ""I Q0, then there exists a renaming OE on dom(Q0) disjoint
from I, a prefix Q0, a substitution ` and a prefix Q00 such that we have

Q "" OE(Q0)Q0 dom(Q0) # I OE(Q0)Q0 jI Q0 Q0 = `Q00

dom(Q00) # dom(Q/I)
See proof in the Appendix (page 275).

As claimed in the introduction of this chapter, one main result is Lemma 3.6.4,
to be found next page. The following properties are used directly in the proof of the
lemma.

Properties 3.6.3 Let "" be v or @-. We have the following properties :

i) If (Q, ff \Pi  oe) oe1 "" oe2 holds and ff /2 ftv(oe1) [ ftv(oe2), then (Q) oe1 "" oe2 holds.
ii) If (Q, ff >= o/, Q0) oe1 "" oe2, then (Q, ff = o/, Q0) oe1 "" oe2, and conversely.
iii) If (Q, ff \Pi  oe, ff0 = ff, Q0) oe1 "" oe2, then (Q, ff0 \Pi  oe, ff = ff0, Q0) oe1 "" oe2.

iv) Assume (Q) oe j oe0. If (Q, ff \Pi  oe, Q0) oe1 "" oe2, then (Q, ff \Pi  oe0, Q0) oe1 "" oe2.

v) Assume (Q) oe @- oe0. If (Q, ff = oe, Q0) oe1 "" oe2, then (Q, ff = oe0, Q0) oe1 "" oe2.
vi) Assume (Q) oe v oe0. If (Q, ff >= oe, Q0) oe1 "" oe2, then (Q, ff >= oe0, Q0) oe1 "" oe2.
vii) If (Q, ff >= oe, Q0) oe1 "" oe2, then (Q, ff = oe, Q0) oe1 "" oe2.

See proof in the Appendix (page 276).

Lemma 3.6.4 Assume oe1 and oe2 are in \Sigma I . If Q1 ""I Q2 and (Q1) oe1 "" oe2 hold, then
we have (Q2) oe1 "" oe2.

See proof in the Appendix (page 278).

The following properties are used to show the correctness of unification.

Properties 3.6.5 If we have

Q1 ""I Q2 fl 2 I dom(Q1/fl) ` I oe1 /2 V
then we have the following :

i) If (fl >= oe1) 2 Q1 and (fl \Pi  oe2) 2 Q2, then (Q2) oe1 v oe2.
ii) If (fl = oe1) 2 Q1 and (fl \Pi  oe2) 2 Q2, then (Q2) oe1 @- oe2.
iii) If (fl >= oe1) 2 Q1, then (Q2) oe1 v Q2(fl)

iv) If (fl = oe1) 2 Q1, then (Q2) oe1 @- Q2(fl)

114

3.6 Les pre'fixes et l'instanciation 115

Proof: Property i : By hypothesis, (fl >= oe1) 2 Q1. Hence, (Q1) oe1 v fl (1) holds by
I-Hyp, and we have ftv(oe1) ` dom(Q1/fl). Since we have dom(Q1/fl) ` I by hypothesis,
this gives ftv(oe1) ` I. Lemma 3.6.4 and (1) gives (Q2) oe1 v fl. By Corollary 2.3.4, there
exists a derivation of (Q2) oe1 v oe2.

Property ii : It is similar, using A-Hyp instead of I-Hyp.
Properties iii and iv : Let (fl \Pi  oe2) be the binding of fl in Q2. By Property i or ii, we
have (Q2) oe1 "" oe2 (2). If oe2 /2 #, then Q2(fl) = oe2 by definition, thus (Q2) oe1 "" Q2(fl)
holds. Otherwise, oe2 2 #, thus oe2 j ff and Q2[fl] = Q2[ff] (3) by definition. Hence,
we have Q2(fl) = Q2(ff) by definition and (3). Besides, (2) becomes (Q2) oe1 "" ff. By
Property 3.2.3.i (page 103) or Property 3.2.3.ii (page 103), we get (Q2) oe1 "" Q2(ff). This
is the expected result.

The following lemma is used to prove the completeness of unification.
Lemma 3.6.6 If we have (Q) oe1 v oe2 and (Q) oe2 v oe3 and (Q) oe1 @- oe3, then we
have both (Q) oe1 @- oe2 and (Q) oe2 @- oe3.

See proof in the Appendix (page 278).

The following lemma is used in the proof of Theorem 5, which states that System F
can be encoded into MLF.

Lemma 3.6.7 If 8 (ff) oe @- oe0 holds, then oe0 j 8 (ff) oe00 and oe @- oe00.
See proof in the Appendix (page 279).

The following property is used only in the proof of Lemma 3.6.9.
Lemma 3.6.8 If 8 (Q) ff/u = ? holds, then there exist Q1, Q2, fi, oe, u1, and u2 such
that Q is (Q1, fi \Pi  oe, Q2), u = u1u2, 8 (Q2) ff/u1 = fi, and oe/u2 = ?.

See proof in the Appendix (page 280).

The following lemma is a key result for the soundness of the abstraction-check
algorithm (Def. 4.2.1), which is used by the unification algorithm.

Lemma 3.6.9 If we have the following :

oe2 2 \Sigma I oe2 /2 V (Q) oe1 v oe2 Q vI Q0 (Q0) oe1 @- oe2
then, we also have (Q) oe1 @- oe2.

115

116 Relations sur les pre'fixes
See proof in the Appendix (page 280).

The following property is only used in Lemma 4.6.4, which shows that unification
in MLF implements usual first-order unification as a special case. Indeed, as said in the
introduction this Chapter, page 101, prefixes can be viewed as extended substitutions.
Then prefix instance corresponds to composing substitutions. More precisely, we say
that `1 is more general than `2, which we can write `1 v `2, whenever there exists `
such that `2 = ` ffi `1. The following property extends such a result to prefixes.

Lemma 3.6.10 If Q1 vI Q2 holds, then there exists a substitution ` such that cQ2 and
` ffi cQ1 are equal on I.

See proof in the Appendix (page 281).

The following lemma is used in showing subject reduction in MLF?.

Lemma 3.6.11 If we have (;) 8 (Q1) o/11 ! o/12 "" 8 (Q2) o/21 ! o/22 then, (;) 8 (Q1)
o/11 "" 8 (Q2) o/21 and (;) 8 (Q1) o/12 "" 8 (Q2) o/22 hold.

See proof in the Appendix (page 281).
Note that the above lemma is stated under an empty prefix (;), and with any relation
"" in {j, @-, v}. One could wonder whether the result still holds under a well-formed
prefix Q. Actually, such a result is easy to prove for the relations j and v. We do not
know if it holds for @-. Fortunately, we only use it with @- and under an empty prefix.

The following property is used only in the proof of the Recomposition Lemma
(Lemma 3.6.13).

Lemma 3.6.12 If we have Q v Q1Q2 and dom(Q) = dom(Q/I) and I ` dom(Q1),
then dom(Q2/ dom(Q)) ` dom( cQ2) and cQ2(dom(Q)) ` dom(Q1).

See proof in the Appendix (page 281).

The recomposition lemma, to be found next, is a key result used to show the completeness of unification and, independently, of type inference. It states, basically, that
generalization can commute with the instantiation of the prefix. In ML, we would have
the following diagram, where \Gamma  ` a : oe means that the expression a has type oe under the typing environment \Gamma . We assume that ff, fi, and fl are not free in the typing
environment \Gamma .

116

3.6 Les pre'fixes et l'instanciation 117

\Gamma  ` a : ff ! ff \Gamma  ` a : (fi ! fl) ! (fi ! fl)

\Gamma  ` a : 8 (ff) ff ! ff \Gamma  ` a : 8 (fi, fl) (fi ! fl) ! (fi ! fl)

Gen(ff)

v (1)

Gen(fi, fl)
v (2)
The arrow Gen(ff) means that we generalize type variable ff. Similarly, Gen(fi, fl)
means that we generalize fi and fl. The instantiation (1) consists, in ML, in applying the
substitution [fi ! fl/ff] to the whole judgment. In MLF, it consists of instantiating the
implicit prefix (ff) into (fi, fl, ff = fi ! fl) (by PE-Free, PI-Context-L, and I-Nil).
The instantiation (2) simply instantiates 8 (ff) ff ! ff into 8 (fi, fl) (fi ! fl) ! (fi ! fl) ;
this is valid in ML and in MLF. Using the same notations as in the recomposition lemma,
we have the following diagram :

(Q1) \Gamma  ` a : o/ (Q2Q3) \Gamma  ` a : o/

(Qa) \Gamma  ` a : 8 (Qb) o/ (3) (Q2) \Gamma  ` a : 8 (Q3) o/ (4)

Q1 ss QaQb

Gen(Qb)

v

Gen(Q3)
v
Actually, the recomposition lemma does not mention typing judgments, but only
prefixes. This is due to the expressiveness of prefixes, which can capture most of the
type information of typing judgments. Indeed, a typing judgment such as (3) can be
equivalently written (Qa, fl >= 8 (Qb) o/ ) \Gamma  ` a : fl (5). Similarly, (4) can be written
(Q2, fl >= 8 (Q3) o/ ) \Gamma  ` a : fl (6). We see that all the interesting information is put in
the prefix. We now understand why the recomposition lemma does not mention typing
judgments but uses prefixes such as in (5) and (6) instead.

Lemma 3.6.13 (Recomposition lemma) If we have

Q1 vI[J Q2Q3 (Qa, Qb) = Q1"I I ` dom(Q2) ftv(o/ ) ` I [ J
then, for fl fresh (that is, fl not in dom(Q1) [ dom(Q2) [ dom(Q3)), we can derive
(Qa, fl >= 8 (Qb) o/ ) vI[{fl} (Q2, fl >= 8 (Q3) o/ ).

See proof in the Appendix (page 283).

117

118 Relations sur les pre'fixes
118

119
Chapitre 4
Unification

La force de ML repose en partie sur son algorithme d'unification du premier ordre,
qui permet l'infe'rence de types avec polymorphisme de te^te (ou, polymorphisme a la
ML). En ML, chaque proble`me d'unification soluble admet une solution principale,
qui est une substitution. Une telle solution est toujours trouve'e par l'algorithme si
elle existe : l'algorithme d'unification de ML est complet. Au contraire, l'unification de
types d'ordre supe'rieur est inde'cidable en ge'ne'ral, et donc un algorithme d'unification
d'ordre supe'rieur ne peut e^tre correct et complet. En MLF, les types sont d'ordre supe'rieur, mais l'unification reste de premier ordre. En effet, alors que l'unification d'ordre
supe'rieur ne'cessite en ge'ne'ral de deviner le polymorphisme, la relation d'abstraction
de MLF est conc,ue pour empe^cher l'introduction implicite de polymorphisme. Ainsi,
seulement les annotations de type explicites peuvent cre'er des types d'ordre supe'rieur,
et donc l'algorithme d'unification de MLF n'a pas besoin de deviner le polymorphisme.
Dans ce chapitre, nous de'finissons l'unification sur les types, et donnons un algorithme
d'unification correct et complet.

La solution a` un proble`me d'unification n'est pas une substitution, comme en ML,
mais un pre'fixe. Comme mentionne' plus to^t, les pre'fixes peuvent e^tres vus comme des
substitutions e'tendues. En ML, un proble`me d'unification prend souvent la forme de
deux types o/1 et o/2, et la solution est une substitution ` qui unifie o/1 et o/2. En modifiant le'ge`rement la pre'sentation, nous pouvons conside'rer qu'un proble`me d'unification
consiste en deux types o/1 et o/2, et une substitution ` (qui repre'sente intuitivement
la substitution "courante"). Alors, une solution a` ce proble`me est une substitution ` 0,
instance de `, qui unifie o/1 et o/2. Cela signifie qu'il existe `00 telle que `0 est `00 ffi `.
Remarquer que `00 est en fait l'unificateur de `(o/1) et `(o/2). Nous choisissons cette approche en MLF : un proble`me d'unification consiste en deux types o/1 et o/2, et un pre'fixe
Q. Ensuite, une solution est un pre'fixe Q0, instance de Q, qui unifie o/1 et o/2, c'est-a`-dire
tel que (Q0) o/1 j o/2. Cette de'finition est donne'e section 4.1, et nous prouvons que c'est
une extension de l'unification en ML.

119

120 Unification

Comme remarque' section 3.1, les pre'fixes monotype contiennent plus d'information que les substitutions. En particulier, ils contiennent l'historique de l'unification,
qui est e'galement visible dans les imple'mentations habituelles de l'unification de ML.
Plus pre'cise'ment, un pre'fixe monotype correspond a` la composition de substitutions
e'le'mentaires. Prenons par exemple le pre'fixe Q e'gal a` (fi >= ?, fl = fi, ff = fl), qui est un
unificateur de ff ! fl et fl ! fi. Sa substitution extraite bQ, qui unifie les deux types, est
ff 7! fi, fl 7! fi. Alors que la substitution seule ne donne pas tellement d'information,
le pre'fixe Q montre l'historique : ff a d'abord e'te' unifie' avec fl, d'ou` la liaison (ff = fl),
ensuite fl a e'te' unifie' avec fi, d'ou` la liaison (fl = fi). Dans les imple'mentations habituelles de l'unification de ML, nous observerions que ff est un alias pour fl, et que fl
est un alias pour fi. Une optimisation importante consiste a` mettre a` jour les liens, afin
que ff et fl soient tous deux des alias pour fi. De manie`re similaire en MLF, le pre'fixe
(fi >=?, fl =fi, ff =fi) est e'quivalent a` Q par PE-Context-L et Eq-Mono. Nous voyons
que l'optimisation n'est pas transparente en MLF et correspond a` une e'quivalence entre
pre'fixes. Cet exemple illustre que les pre'fixes monotypes capturent plus d'information
que les substitutions, et sont plus proches de l'imple'mentation. En fait, les pre'fixes monotypes sont tre`s similaires aux multi-e'quations [Re'm92], car ils fournissent la me^me
information. Cependant, les pre'fixes de MLF sont plus riches que les multi-e'quations
car une variables de type peut e^tre lie'e a` un polytype. C'est la raison pour laquelle
un algorithme auxiliaire est ne'cessaire, nomme'ment update, qui met a` jour la borne
d'une variable avec un polytype. Cet algorithme re'ordonne les e'le'ments du pre'fixe pour
satisfaire les de'pendances.

Les algorithmes auxiliaires abstraction-check, merge et update sont de'finis section 4.2. L'algorithme d'unification, appele' unify, est donne' section 4.3. Comme l'unification reste de premier ordre, l'algorithme est tre`s semblable a` l'algorithme d'unification
de ML, avec seulement quelques cas supple'mentaires pour ge'rer les bornes polytypes.
La correction, terminaison et comple'tude de l'algorithme d'unification sont montre'es
respectivement sections 4.4, 4.5, et 4.6.

4.1 Definition

We first give a simple specification of the unifier of two types under a given initial
prefix. As explained above, the unifier is not a substitution, but rather a prefix.

Definition 4.1.1 (Unification) A prefix Q0 unifies o/1 and o/2 under Q if and only if
Q v Q0 and (Q0) o/1 j o/2 hold.

Such a definition is an extension of ML unification, as shown by the following lemma.

120

4.2 Algorithmes auxiliaires 121

Fig. 4.1 - Abstraction-check algorithm
We assume that (Q) oe1 v oe2 holds. We define (Q) oe1 @-? oe2 as follows :

1. If proj(8 (Q) oe1) and proj(8 (Q) oe2) are not equal, then return false.
2. If bQ(nf(oe1)) is a monotype, then return true.
3. If bQ(nf(oe2)) is not in #, then return true if and only if X /2 w(oe1) - w(oe2).
4. If bQ(nf(oe2)) is ff, find (ff = oe) in Q (if such a binding cannot be found, return

false), and return (Q) oe1 @-? oe.

Lemma 4.1.2 Let ` be a substitution and Q an unconstrained prefix that binds variables of codom(`). If Q0 unifies o/1 and o/2 under the prefix Q`, then cQ0 is a unifier of
o/1 and o/2 in ML.

Proof: Direct consequence of Property 1.5.11.vii (page 56).

4.2 Auxiliary algorithms

The unification algorithm uses three auxiliary algorithms : the abstraction-check
algorithm, the update algorithm, and the merge algorithm.

The abstraction-check algorithm checks that the operations performed on binders are all safe. For example, it prevents the instantiation of oeid in the type 8 (ff = oeid)
ff ! ff, which may occur for example when unifying this type with (int ! int) !
(int ! int). Indeed, the former type represents a function that expects a polymorphic argument and must not be instantiated. Interestingly, the check can be done a
posteriori, and need not be done each time a binder is moved.

Definition 4.2.1 The abstraction-check algorithm (Q) oe @-? oe0 is defined in Figure 4.1. It takes a prefix Q and two polytypes oe and oe0 such that (Q) oe v oe0 holds
and tells if (Q) oe @- oe0 holds.

Lemma 4.2.2 Assume we have (Q) oe1 v oe2. Then (Q) oe1 @- oe2 iff (Q) oe1 @-? oe2
returns true.

Proof: The termination, completeness and soundness of the abstraction-check algorithm are shown independently.

121

122 Unification

Termination There is only one place where the algorithm calls itself recursively. All
other steps immediately terminate. In that case, bQ(nf(oe2)) is ff and (ff = oe) 2 Q. By

definition of bQ, we must have oe /2 T . Hence, bQ(nf(oe)) /2 #, and in this case the call to
(Q) oe1 @-? oe terminates immediately.

Completeness Completeness is shown by induction on the recursive calls to the
abstraction-check algorithm. We assume (Q) oe1 @- oe2 holds. We show that (Q) oe1 @-?
oe2 returns true. By Lemmas 2.1.3.i (page 66) and 2.7.8, we have 8 (Q) oe1/ = 8 (Q)

oe2/ (1) and X /2 w(oe1)-w(oe2) (2) provided bQ(nf(oe2)) /2 V. From (1), we have proj(8 (Q)
oe1) = proj(8 (Q) oe2) (3).

- The first step does not return false thanks to (3).
- If (Q) oe1 j o/ holds, then bQ(nf(oe1)) is a monotype bQ(o/ ) by Lemma 1.5.9. Hence, the

second step returns true. We can now assume that (Q) oe1 j o/ does not hold for any
monotype o/ . In particular, we can assume that oe1 /2 V (4).
- If bQ(nf(oe2)) is not in #, then the algorithm returns true thanks to (2).
- Otherwise, bQ(nf(oe2)) is ff, thus (Q) oe1 @- ff (5) holds by Property 1.5.6.i (page 53)

and Eq-Mono. Let (ff \Pi  oe) be the binding of ff in Q. By (4), (5) and Corollary 2.3.4,
we have a derivation of (Q) oe1 @- oe (6) and \Pi  is rigid. Hence, the algorithm finds
(ff = oe) in Q and calls (Q) oe1 @-? oe. By induction hypothesis and (6), the algorithm
returns true. This is the expected result.

Soundness Soundness is shown by induction on the recursive calls to the algorithm.
We assume (Q) oe1 @-? oe2 returns true, and we must show that (Q) oe1 @- oe2 holds. By
hypothesis, (Q) oe1 v oe2 (7) holds.
- Since the first step does not return false, we must have proj(8 (Q) oe1) = proj(8 (Q) oe2),

that is, 8 (Q) oe1/ = 8 (Q) oe2/ (8).
- If the algorithm returns true at the second step, we must have bQ(nf(oe1)) = o/ for some

type o/ . Hence, we have nf(oe1) = o/ 0, which means oe1 2 T . By Lemma 2.1.6 and (7),
we get (Q) oe1 j oe2, which implies (Q) oe1 @- oe2 by A-Equiv.
- If the algorithm returns true at the third step, we must have bQ(nf(oe2)) /2 # (9) and

X /2 w(oe1) - w(oe2) (10). By (7), (8), (10) and (9) and by Lemma 2.7.8, we have
(Q) oe1 @- oe2. This is the expected result.
- Otherwise, the algorithm necessarily returns true at the recursive call of the fourth

step and bQ(nf(oe2)) is ff (11). Hence, (ff = oe) 2 Q and (Q) oe1 @-? oe returns true.
By induction hypothesis, we have (Q) oe1 @- oe. By A-Hyp, we have (Q) oe @- ff, thus
(Q) oe1 @- ff holds by R-Trans. Finally, (Q) oe @- oe2 holds by Lemmas 1.5.10, 1.5.6.i
(page 53), and (11).

The update algorithm replaces the bound of a prefix binding by a new one. It
reorders the bindings in the prefix if necessary to make the resulting prefix well-formed.
The condition ff /2 dom(Q/oe) ensures that there is no circular dependency, just like the

122

4.2 Algorithmes auxiliaires 123

Fig. 4.2 - Update algorithm
We assume ff 2 dom(Q), ftv(oe) ` dom(Q) and ff /2 dom(Q/oe).
We define Q ( (ff \Pi  oe) as follows :

1. let (Q1, Q2) be Q" ftv(oe) in
2. let (Qa2, ff \Pi 0 oe0, Qb2) be Q2 in
3. If \Pi 0 is = and (Q) oe0 @-? oe is false, then fail.
4. return (Q1Qa2, ff \Pi  oe, Qb2).

occur-check in ML. The algorithm fails if a rigid bound is updated by a strict instance,
using the abstraction-check algorithm. This algorithm is defined in Figure 4.2.

For example, if Q is (ff >= oeid, fi >= ?), then the update Q ( (ff = fi ! fi) returns
the prefix (fi >= ?, ff = fi ! fi). Notice that the binders ff and fi have been reordered, so
that the resulting prefix is well-formed. As another example, if Q is (ff = oeid, fi >= ?),
then the update Q ( (ff = fi ! fi) fails because it tries to instantiate the rigid bound
oeid to a strict instance fi ! fi.

The following lemma will be used to show the equivalence between the unification
algorithm and a variant that reorders the bindings of the input prefix and removes
unused bindings.

Lemma 4.2.3 If Q1 ( (ff \Pi  oe) is well defined, and if Q2 is a rearrangement of Q1,
then Q2 ( (ff \Pi  oe) is a rearrangement of Q1 ( (ff \Pi  oe).

The following lemma states the completeness of the update algorithm.
Lemma 4.2.4 If we have

Q1 vI Q2 (ff \Pi  oe) 2 Q1 (Q1) oe v oe0 (Q1) oe @- oe0 if \Pi  is rigid
ff /2 dom(Q1/oe0) ftv(oe0) [ {ff} ` I (Q2) oe0 v ff (Q2) oe0 @- ff if \Pi 0 is rigid

then, we have (Q1 ( (ff \Pi 0 oe0)) vI Q2, and the update is well-defined.
See proof in the Appendix (page 284).

This lemma states the soundness of the update algorithm.
Lemma 4.2.5 If we have (ff \Pi  oe) 2 Q, (Q) oe v oe0 and (Q ( (ff \Pi  oe0)) returns Q0, then
Q v Q0.

See proof in the Appendix (page 285).

123

124 Unification

The merge algorithm unifies two type variables, which must have the same bound.
The resulting binding is flexible if and only if the two variables are flexible. Otherwise,
the new binding is rigid. This algorithm cannot fail.

Definition 4.2.6 The merge algorithm Q ( ff ^ ff0 takes two variables ff and ff0 and
a prefix Q such that Q is (Q0, ff \Pi  oe, Q1, ff0 \Pi 0 oe, Q2) or Q is (Q0, ff0 \Pi 0 oe, Q1, ff \Pi  oe, Q2)
and returns the prefix (Q0, ff \Pi 00 oe, ff0 = ff, Q1Q2) where \Pi 00 is flexible if both \Pi  and \Pi 0
are flexible, and rigid otherwise.

The two following lemmas state the soundness and completeness of the merge algorithm, respectively.

Lemma 4.2.7 If Q ( ff ^ ff0 returns Q0, then Q v Q0 and (Q0) ff j ff0.
See proof in the Appendix (page 285).

Lemma 4.2.8 If we have

Q1 vI Q2 ff, ff0 2 I (ff \Pi  oe) 2 Q1 (ff0 \Pi 0 oe) 2 Q1 (Q2) ff j ff0
then (Q1 ( ff ^ ff0) vI Q2.
See proof in the Appendix (page 285).

4.3 Unification algorithm

The algorithm unify takes a prefix Q and two types o/ and o/ 0 and returns a prefix
that unifies o/ and o/ 0 under Q, as described in Theorem 1 (page 136), or fails. In
fact, the algorithm unify is recursively defined with an auxiliary unification algorithm
polyunify for polytypes: polyunify takes a prefix Q and two type schemes oe1 and oe2
not in V and returns a pair (Q0, oe0) such that Q v Q0 and (Q0) oe1 v oe0 and (Q0) oe2 v oe0
hold.

The algorithms unify and polyunify are described in Figures 4.3 and 4.4, respectively. For the sake of comparison with ML, think of the input prefix Q as a substitution
given to unify and of the result prefix Q0 as an instance of Q (i.e. a substitution of
the form Q00 ffi Q) that unifies o/ and o/ 0. Unification of polytypes essentially follows the
general structure of first-order unification of monotypes. The main differences are that
(i) the computation of the unifying substitution is replaced by the computation of a
unifying prefix, (ii) additional work must be performed when a variable bound to a
strict polytype (i.e. other than ? and not equivalent to a monotype) is being unified:

124

4.3 Algorithme d'unification 125

Fig. 4.3 - Unification algorithm (monotypes)
unify (Q, o/1, o/2)
-- Proceeds by case analysis on (o/1, o/2) :

Case (ff, ff): return Q.
Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ):

* let Q0 be Q in

* let Qi be unify (Qi-1, o/ i-11 , o/ i-12 ) for i 2 1..n in

* return Qn.

Case (g1 o/ 11 .. o/ p1 , g2 o/ 12 .. o/ q2 ) with g1 6= g2: fail.
Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q and oe 2 V: return unify (Q, o/, nf(oe)).
Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q, o/ /2 #, and oe /2 V:

* fail if ff 2 dom(Q/o/ ).

* let (Q0, _) be polyunify (Q, oe, o/ ) in

* return (Q0) ( (ff = o/ )

Case (ff1, ff2) with (ff1 \Pi 1 oe1) 2 Q, (ff2 \Pi 2 oe2) 2 Q, ff1 6= ff2, and oe1, oe2 not in V:

* fail if ff1 2 dom(Q/oe2) or ff2 2 dom(Q/oe1).

* let (Q0, oe3) be polyunify (Q, oe1, oe2) in

* return (Q0) ( (ff1 \Pi 1 oe3) ( (ff2 \Pi 2 oe3) ( ff1 ^ ff2.

its bound must be further unified (last case of polyunify) and the prefix must then be
updated accordingly.

The following is a stability property: it shows that if a binding (ff \Pi  oe) 2 Q is
useless, regarding two types o/1 and o/2, (that is, ff /2 dom(Q/o/1, o/2)), then the unify
algorithm does not remove the binding, and does not use it either (it is still useless
after unification). Like all results about the unification algorithm, it is two-folded:
one statement concerns the unification of monotypes (unify); the other concerns the
unification of polytypes (polyunify). We recall that the notation dom(Q/o/1, o/2) means
dom(Q/o/1) [ dom(Q/o/2).

Properties 4.3.1 Assume (ff \Pi  oe) 2 Q.

i) If unify (Q, o/1, o/2) returns a prefix Q0, and if ff /2 dom(Q/o/1, o/2), then (ff\Pi oe) 2 Q0

and ff /2 dom(Q0/o/1, o/2).
ii) If polyunify (Q, oe1, oe2) returns (Q0, oe3), and if ff /2 dom(Q/oe1, oe2), then (ff\Pi oe) 2

Q0 and ff /2 dom(Q0/oe1, oe2, oe3).

See proof in the Appendix (page 286).

125

126 Unification

Fig. 4.4 - Unification algorithm (polytypes)
polyunify (Q, oe1, oe2)
-- Rewrite oe1 and oe2 in constructed form, and then:

Case (?, oe) or (oe, ?): return (Q, oe)
Case (8 (Q1) o/1, 8 (Q2) o/2) with Q1, Q2, and Q having disjoint domains (which

usually requires renaming oe1 and oe2)

* let Q0 be unify (QQ1Q2, o/1, o/2) in

* let (Q3, Q4) be Q0" dom(Q) in

* return (Q3, 8 (Q4) o/1)

The following property shows that the unify algorithm is stable under rearrangement of the prefix, and under addition of new (unused) bindings.

Properties 4.3.2 Assume Q ss Q1Q2.

i) If ftv(o/, o/ 0) ` dom(Q1), then unify (Q1, o/, o/ 0) returns Q01 if and only if unify

(Q, o/, o/ 0) returns a rearrangement of Q01Q2.
ii) If ftv(oe, oe0) ` dom(Q1), then polyunify (Q1, oe, oe0) returns Q01 and oe00 if and only

if polyunify (Q, oe, oe0) returns a rearrangement of Q01Q2 and a rearrangement of
oe00.

See proof in the Appendix (page 286).

4.4 Soundness of the algorithm

In this section, we show the soundness of the unify and polyunify algorithms.
More precisely, we show that if unify returns a prefix, it is an instance of the initial
prefix and it does unify the types given in input. As for polyunify, it also returns two
elements : an instance of the initial prefix and a common instance of oe1 and oe2 under
this prefix. This means that polyunify returns the least upper bound of oe1 and oe2.

Lemma 4.4.1 (Soundness of the unification algorithm) These two results hold:

(i) If unify (Q, o/1, o/2) succeeds with Q0, then Q v Q0 and (Q0) o/1 j o/2.
(ii) Assume oe1 /2 V and oe2 /2 V. If polyunify (Q, oe1, oe2) succeeds with (Q0, oe), then
Q v Q0, (Q0) oe1 v oe and (Q0) oe2 v oe hold.

Proof: By induction on the recursive calls to both algorithms. We show the result for
unify by case analysis on (o/1, o/2):

126

4.4 Correction de l'algorithme 127

ffi Case (ff, ff) is immediate.
ffi Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ): Let Q0 be Q, and Qi be unify (Qi-1, o/ i-11 , o/ i-12 )
for i 2 1..n. By definition, Q0 is Qn. By induction hypothesis, we have Q0 v Q1 . . . v
Qn-1 v Q0. Besides, (Qi) o/ i-11 j o/ i-12 holds for i 2 1..n. Hence, by Lemma 3.4.3, we get
(Q0) o/ i-11 j o/ i-12 . By Property 1.5.11.viii (page 56), this implies (Q0) o/1 j o/2.

ffi Case (g1 . . . , g2 . . .) is not possible since the algorithm succeeds by hypothesis.
ffi Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q and oe 2 V: By induction hypothesis, unify
(Q, o/, nf(oe)) returns Q0 such that (Q0) o/ j nf(oe) (1) and Q v Q0. Moreover, we have
(Q) ff j nf(oe) by Eq-Mono, thus (Q0) ff j nf(oe) (2) holds by Lemma 3.6.4. Then
(Q0) o/ j ff holds by R-Trans, (1), and (2). This is the expected result.

ffi Case (ff, o/ ) or (o/, ff) : We have (ff \Pi  oe) 2 Q (3), o/ /2 V, and oe /2 V. Let (Q0, oe0) be
polyunify (Q, oe, o/). By induction hypothesis, we have Q v Q0 (4), (Q0) oe v oe0 (5) and
(Q0) o/ v oe0. By Lemma 2.1.6, this gives (Q0) o/ j oe0 (6). Hence, (Q0) oe v o/ (7) holds
by R-Trans, (5), and (6). We have ff /2 dom(Q/oe) by well-formedness of Q and (3).
Besides, ff /2 dom(Q/o/), otherwise the algorithm would fail on the first step. Hence, by
Property 4.3.1.i, (ff \Pi  oe) 2 Q0 (8) and ff /2 dom(Q0/o/ ) (9). Let Q0 be Q0 ( (ff = o/ ) (10).
This update is well-defined by (9) and succeeds by hypothesis (the algorithm succeeds).
By Lemma 4.2.5, (7) and (8), we get Q0 v Q0 (11). By PI-Trans, (4), and (11), we get
Q v Q0. As a consequence of (10), we have (ff = o/ ) 2 Q0. Hence, (Q0) ff j o/ holds by
Eq-Mono.

ffi Case (ff1, ff2): We have (ff1 \Pi 1 oe1) 2 Q and (ff2 \Pi 2 oe2) 2 Q. Moreover, oe1 and oe2 are
not in V and ff1 6= ff2. Let (Q0, oe3) be polyunify (Q, oe1, oe2). By induction hypothesis,
we have Q v Q0 (12) and (Q0) oe1 v oe3 (13) as well as (Q0) oe2 v oe3 (14). We have
ff1 /2 dom(Q/oe1) and ff1 /2 dom(Q/oe2), otherwise the algorithm would fail on the first
step. Hence, by Property 4.3.1.i, (ff1 \Pi 1 oe1) 2 Q0 (15), ff1 /2 dom(Q0/oe3) (16) and
ff2 /2 dom(Q0/oe3) (17). Let Q1 be Q0 ( (ff1 \Pi 1 oe3), Q2 be Q1 ( (ff2 \Pi 2 oe3), and Q0
be Q2 ( ff1 ^ ff2. The updates are well-defined by (16) and (17). By Lemma 4.2.5, (13)
and (15), we get Q0 v Q1 (18). By Lemma 3.6.4, (18), and (14), we get (Q1) oe2 v
oe3 (19). We show that (ff2 \Pi 2 oe2) 2 Q0 as we showed (15). thus (ff2 \Pi 2 oe2) 2 Q1 (20)
(the update does not modify the binding of ff2). Hence, by Lemma 4.2.5, (19) and (20),
we get Q1 v Q2 (21). Finally, we have Q2 v Q0 (22) and (Q0) ff1 j ff2 by Lemma 4.2.7.
By PI-Trans, (12), (18), (21), and (22), we get Q v Q0.

We show the result for polyunify by case analysis on the constructed forms of (oe1, oe2):

ffi Case (?, oe) or (oe, ?): We return (Q, oe), thus the expected result holds by Property 1.5.13.i (page 56), and by rules PE-Refl, Eq-Refl and I-Bot.

ffi Case 8 (Q1) o/1, 8 (Q2) o/2: Let Q0 = unify (QQ1Q2, o/1, o/2). By induction hypothesis, Q0 is such that QQ1Q2 v Q0 (1) and (Q0) o/1 j o/2 (2). Let (Q3, Q4) be
Q0" dom(Q) (3). The returned prefix is Q0 = Q3. By Lemma 3.5.2 and (3), Q0 is a rearrangement of Q3Q4 (4). Hence (1) gives QQ1Q2 vdom(Q) Q3Q4 (5) by Property 3.2.2.ii
(page 103) and Property 3.4.2.i (page 106). Since dom(Q1Q2) # dom(Q) by hypothesis
and dom(Q4) # dom(Q) (6) by Lemma 3.5.2 and (3), we get Q v Q3 (7) by PE-Free

127

128 Unification

and (5). Additionally, ftv(oe1) ` dom(Q), thus dom(Q4) # ftv(oe1) (8) holds by (6). We
have

oe1 j 8 (Q1) o/1 by Property 1.5.13.i (page 56)
(QQ1Q2) oe1 v o/1 by I-Drop?

(Q3Q4) oe1 v o/1 by Lemma 3.6.4 and (5)

(Q3) 8 (Q4) oe1 v 8 (Q4) o/1 by R-Context-R
(Q3) oe1 v 8 (Q4) o/1 by (8) and Eq-Free.

Similarly, we can show that (Q3) oe2 v 8 (Q4) o/2 holds. Moreover, by (2) and (4), we
have (Q3Q4) o/1 j o/2, and we get (Q3) 8 (Q4) o/1 j 8 (Q4) o/2 by R-Context-R. To sum
up, we have (7) as well as (Q3) oe1 v 8 (Q4) o/1 and (Q3) oe2 v 8 (Q4) o/1. This is the
expected result.

4.5 Termination of the algorithm

In order to make the proof of termination easier, we consider a variant of the
unification algorithm, composed of two sub-algorithms unify0 and polyunify0. The
body of polyunify0 is the body of polyunify, where the occurrence of unify is replaced
by unify0. The algorithm unify0 is given in Figure 4.5.

The differences between unify and unify0 are in the cases (ff, o/ ) and (ff1, ff2) : The
recursive call to polyunify is given a prefix Q1 in unify0, instead of Q in unify. The
prefix Q1 contains all the bindings of Q which do not depend on ff (in the first case),
or on ff1 or ff2 (in the second case). Intuitively all the bindings that depends on ff or
on ff1 or ff2 are useless during the unification of ff and o/ or of ff1 and ff2 (respectively).
In unify0, we explicitly remove such bindings, thus the recursive call to polyunify
is made with a "smaller" prefix. This helps to show termination. First, we show that
unify and unify0 are equivalent. Then we define sizes and weights associated to a
unification problem. Finally, we show that the algorithm unify0 calls itself recursively
with a strictly smaller weight, thus it terminates.

Lemma 4.5.1 The algorithms unify and unify0 are equivalent. More precisely, the
algorithm unify (Q, o/1, o/2) returns Q0 if and only if the algorithm unify0 (Q, o/1, o/2)
returns a rearrangement of Q0.

See proof in the Appendix (page 286).

Definition 4.5.2 We define doee as the number of universal quantifiers appearing syntactically in oe (considering 8 (ff1 \Pi 1 oe1, Q) oe as syntactic sugar for 8 (ff1 \Pi 1 oe1) 8 (Q) oe.
Similarly, d(ff1 \Pi 1 oe1, . . . ffn \Pi n oen)e is n + doe1e + . . . doene. We also define #o/ as the size
of the set dom(o/ ).

128

4.5 Terminaison de l'algorithme 129

Fig. 4.5 - Unification algorithm (variant)
unify0 (Q, o/1, o/2)
-- Proceeds by case analysis on (o/1, o/2) :

Case (ff, ff) : return Q.
Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ) :

* let Q0 be Q in

* let Qi be unify0 (Qi-1, o/ i-11 , o/ i-12 ) for i 2 1..n in

* return Qn.

Case (g1 o/ 11 .. o/ p1 , g2 o/ 12 .. o/ q2 ) with g1 6= g2 : fail
Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q and oe 2 V :

* return unify0 (Q, o/, nf(oe)).

Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q, o/ /2 #, and oe /2 V :

* fail if ff 2 dom(Q/o/ ).

* let I be {fi 2 dom(Q) | fi 6= ff and ff /2 dom(Q/fi)}

* let (Q1, Q2) be Q"I

* let (Q01, _) be polyunify0 (Q1, oe, o/ ).

* return Q01Q2 ( (ff = o/ ).

Case (ff1, ff2) with (ff1 \Pi 1 oe1) 2 Q, (ff2 \Pi 2 oe2) 2 Q, ff1 6= ff2, and oe1, oe2 not in V :

* fail if ff1 2 dom(Q/oe2) or ff2 2 dom(Q/oe1).

* let I be {fi 2 dom(Q) | fi /2 {ff1, ff2} and {ff1, ff2} # dom(Q/fi)}

* let (Q1, Q2) be Q"I

* let (Q01, oe3) be polyunify0 (Q1, oe1, oe2)

* return Q01Q2 ( (ff1 \Pi 1 oe3) ( (ff2 \Pi 2 oe3) ( ff1 ^ ff2

Note that we have #o/ > 0 for any o/ , while do/ e = 0.
Properties 4.5.3

i) For any Q and o/ , we have d8 (Q) o/ e = dQe.
ii) For any prefix Q1Q2, we have dQ1Q2e = dQ1e + dQ2e.
iii) If Q ss Q0, then dQe = dQ0e.

iv) If unify0 (Q, o/1, o/2) returns Q0, then dQ0e 6 dQe.

v) If polyunify0 (Q, oe1, oe2) returns (Q0, oe3), then dQ0e + doe3e 6 dQe + doe1e + doe2e.

See proof in the Appendix (page 288).

Properties 4.5.3.iv and 4.5.3.v tell us an interesting story. Indeed, by definition,
dQe and doee are the number of quantifiers appearing in Q and oe. Hence, the two

129

130 Unification
aforementioned properties show that the number of quantifiers only decreases during
unification. This corroborates the intuition that we perform only first-order unification,
and that we never guess polymorphism, that is, we never introduce new quantifiers.

Weights

We associate a weight to each call to unify0 (Q, o/1, o/2) and polyunify0 (Q, oe1, oe2).
A weight is a triple in IN 3, with its natural lexicographic ordering.

Definition 4.5.4 The weight associated to unify0 (Q, o/1, o/2) is

(2 * dQe , #o/1 + #o/2 , card(dom(Q/o/1)) + card(dom(Q/o/2)))
The weight associated to polyunify0 (Q, oe1, oe2) is

(1 + 2 * (dQe + doe1e + doe2e) , 0 , 0)
Lemma 4.5.5 (Termination of unification) The unify algorithm always terminates, either by failing or by returning a prefix.

Proof: By Lemma 4.5.1, unify (Q, o/1, o/2) terminates if and only if unify0 (Q, o/1, o/2) (1)
terminates. Hence, we show termination for unify0 and polyunify0. Actually, we show
that in the body of (1), all recursive calls to unify0 and polyunify0 have strictly smaller weights than the weight of (1). Similarly, we show that in the body of polyunify0
(Q, oe1, oe2) (2), recursive calls to unify0 and polyunify0 have strictly smaller weights
than the weight of (2). Termination follows. We proceed by case analysis.

ffi Case (ff, ff) has no recursive call.
ffi Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ): By Property 4.5.3.iv, dQie 6 dQe. Besides, #o/ i1 < #o/1
and #o/ i2 < #o/2. Hence, the weight of unify (Qi, o/ i1, o/ i2) is strictly smaller than the weight
of (1).

ffi Case (g1 o/ 11 .. o/ n1 , g2 o/ 12 .. o/ n2 ): both calls fail.
ffi Case (ff, o/ ) with (ff = oe) 2 Q and oe 2 V: We call unify (Q, o/, nf(oe)) (3). By
hypothesis, we have oe 2 V, which means that nf(oe) is a type variable fi such that
dom(Q/ff) = dom(Q/fi) [ {ff}. Hence, card(dom(Q/ff)) = card(dom(Q/fi)) + 1 (4). The
weight of (1) is the triple

(2 * dQe, #ff + #o/ , card(dom(Q/ff)) + card(dom(Q/o/)))
The weight of (3) is

(2 * dQe, #fi + #o/ , card(dom(Q/fi)) + card(dom(Q/o/ )))
By (4), and observing that #fi = #ff, this weight is equal to

(2 * dQe, #ff + #o/ , card(dom(Q/ff)) - 1 + card(dom(Q/o/)))

130

4.6 Comple'tude de l'algorithme 131

Hence, the weight of (3) is strictly smaller than the weight of (2).

ffi Case (ff, o/ ): Let I be {fi 2 dom(Q) | fi 6= ff and ff /2 dom(Q/fi)}. Let (Q1, Q2) be
Q"I. There is a recursive call to polyunify0 (Q1, oe, o/ ) (5). By Lemmas 3.5.2 and 4.5.3.ii,
we have dQe = dQ1e + dQ2e (6) Besides, ff 2 dom(Q2), thus we have dQ2e ? 1 + doee.
This implies dQ1e + 1 + doee 6 dQ1e + dQ2e, that is, dQ1e + 1 + doee 6 dQe (7) by (6).
The first element of the weight of (1) is 2 * dQe. The first element of the weight of (5)
is w = 1 + 2 * (dQ1e + doee + do/ e), that is, w = 1 + 2 * (dQ1e + doee). Hence, we have
w < 2 * (dQ1e + 1 + doee). By (7), we get w < 2 * dQe. This implies that the weight
of (5) is strictly smaller than the weight of (1).

ffi Case (ff1, ff2) : Let I be {fi 2 dom(Q) | fi /2 {ff1, ff2} and {ff1, ff2} # dom(Q/fi)} and
(Q1, Q2) be Q"I. There is a recursive call to polyunify (Q1, oe1, oe2) (8). By Lemmas 3.5.2
and 4.5.3.ii, we have dQe = dQ1e + dQ2e (9). Besides, ff1, ff2 2 dom(Q2), thus dQ2e ?
2 + doe1e + doe2e (10). Hence, dQ1e + 2 + doe1e + doe2e 6 dQe (11) holds from (9) and (10).
The first element of the weight of (1) is 2 * dQe. The first element of the weight of (8)
is w = 1 + 2 * (dQ1e + doe1e + doe2e). We have w < 2 * (dQ1e + 2 + doe1e + doe2e). Hence,
by (11), we get w < 2 * dQe. As a consequence, the weight of (8) is strictly smaller than
the weight of (1).

In polyunify0 (Q, oe1, oe2) (12), we call unify0 (QQ1Q2, o/1, o/2) (13). The first element
of the weight of (12) is 1 + 2 * (dQe + doe1e + doe2e), that is, by Property 4.5.3.i, 1 +
2 * (dQe + dQ1e + dQ2e). By Property 4.5.3.ii, the first element of the weight of (13) is
2 * (dQe + dQ1e + dQ2e). Hence, the weight of (13) is strictly smaller than the weight
of (12).

4.6 Completeness of the algorithm

In this section, we show that the unification algorithm is also complete : if the
unification problem admits a solution, then the algorithm finds a solution, which is
equivalent or better (that is, more general).

The following property is used in the proof of completeness.

Lemma 4.6.1 If oe1 and oe2 are not in V, and if polyunify (Q, oe1, oe2) returns (Q0, oe3),
then, oe3 is not in V.

See proof in the Appendix (page 288).

The intuitive specification of completeness is the following : if there is a solution
to a given unification problem (e.g. (Q2) o/1 j o/2 below), then unification succeeds and
returns a better result (e.g. Q01 vI Q2 below).

Lemma 4.6.2 (Completeness of unification) Let I be dom(Q1). We assume that
o/1, o/2, oe1, and oe2 are in \Sigma I . Furthermore, we assume that Q1 vI Q2 holds.

131

132 Unification

(i) If (Q2) o/1 j o/2 holds, then unify (Q1, o/1, o/2) succeeds with Q01 and we have
Q01 vI Q2.

(ii) If oe1, oe2, and oe3 are not in V, and if we have (Q2) oe1 v oe3 and (Q2) oe2 v oe3,
then polyunify (Q1, oe1, oe2) succeeds with Q01 and oe03 such that (Q01, fl >= oe03) vI[{fl}
(Q2, fl >= oe3)

Proof: We prove both properties simultaneously by induction on the recursive calls to
the algorithm.

The unify algorithm :
Let I be dom(Q1) (1). We have to show that the algorithm cannot fail, thanks to the
hypotheses (Q2) o/1 j o/2 (2) and Q1 v Q2 (3), and that the returned prefix, Q01 is such
that Q01 vI Q2. We proceed by case analysis on (o/1, o/2).

ffi Case (ff, ff) is immediate.
ffi Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ) : We will shown this case by iteration (from 1 to n).
By Property 1.5.11.viii (page 56) applied to (2), we have (Q2) o/ i1 j o/ i2 for all i 2 1..n.
Let Q0 be Q1 and Qi be unify (Qi-1, o/ i-11 , o/ i-12 ). We have Q0 v Q2 by hypothesis.
We prove by (local) induction on i, that there exists a renaming OEi on dom(Q2) disjoint
from I, and a prefix Qi0 such that Qi v OEi(Q2)Qi0 holds and dom(Qi0) # I. This is
obviously true for i = 0, taking OE0 = id and Qi0 = ;. By (local) induction hypothesis,
we have Qi-1 v OEi-1(Q2)Qi-10 (4). By Property 3.4.2.iv (page 106), we have Q2 j
OEi-1(Q2)OEi-1, thus Q2 jI OEi-1(Q2) holds by Property 3.4.2.i (page 106) and PE-Free.

Then Q2 jI OEi-1(Q2)Qi-10 (5) holds by PE-Free. We have (Q2) o/ i1 j o/ i2 (6), thus
(OEi-1(Q2)Qi-10 ) o/ i1 j o/ i2 (7) holds by Lemma 3.6.4 applied to (5) and (6). Hence, by
induction hypothesis, (4), and (7), Qi is defined (that is, the algorithm succeeds) and
we have Qi vI OEi-1(Q2)Qi-10 . By Lemma 3.6.2 (page 114), there exists a renaming OE
disjoint from I and a prefix Q0 such that we have Qi v OE(OEi-1(Q2)Qi-10 )Q0. Taking
OEi = OE ffi OEi-1 and Qi0 = OE(Qi-10 )Q0 gives the expected result.

By (local) induction, the result holds for n, hence, we have

Q01 = Qn v OEn(Q2)Qn0 jI Q2
Finally, we have Q01 vI Q2. This is the expected result.

ffi Case (g1 . . . , g2 . . .) with g1 6= g2: The algorithm fails. Indeed, according to Property 1.5.11.viii, it is not possible to find Q2 such that (Q2) g1 . . . j g2 . . ., thus this
case does not happen.

ffi Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q1 and oe 2 V : By hypothesis, (Q2) o/ j ff (8)
holds. We have (Q1) ff j nf(oe) (9) by Eq-Mono. Moreover, ftv(nf(oe)) ` dom(Q1)
holds, thus we have ftv(nf(oe)) ` I from (1). Hence, by Lemma 3.6.4, (3), and (9), we get
(Q2) ff j nf(oe) (10). Consequently, (Q2) o/ j nf(oe) holds by R-Trans, (10), and (8).
Hence, we get the result by induction hypothesis applied to unify (Q1, o/, nf(oe)).

ffi Case (ff, o/ ) or (o/, ff) : We have (ff \Pi  oe) 2 Q1 (11), as well as o/ /2 # (12) and
oe /2 V (13). By hypothesis, (Q2) o/ j ff (14) holds. In the first point, below, we show that

132

4.6 Comple'tude de l'algorithme 133

the algorithm cannot fail in the first step of the case (ff, o/ ). In the second point, we use
the induction hypothesis and the completeness of the update algorithm (Lemma 4.2.4) to
show the result. The case where the binding is rigid might fail because of the abstractioncheck algorithm. It is not the case thanks to Lemma 3.6.9, as shown below.
- If ff 2 dom(Q1/o/ ), then Q1 is of the form (Qa, ff \Pi  oe, Qb) and ff 2 ftv(8 (Qb) o/ ) (15).

Since o/ /2 #, we have 8 (Qb) o/ /2 V (16). We can derive (Q1) 8 (Qb) o/ v o/ (17) by
I-Drop?. Hence, (Q2) 8 (Qb) o/ v o/ holds by Lemma 3.6.4, (17), and (3). By (14), we
get (Q2) 8 (Qb) o/ v ff (18). By Property 2.1.7.ii (page 68), (15), and (18), we have
8 (Qb) o/ j ff, which is not possible by (16). Hence, ff /2 dom(Q1/o/ ) (19), and the
algorithm does not fail on the first step.
- From (14) and Corollary 1.5.10, we must have ff 2 dom( cQ2). Hence, there exists o/ 0

and oe0 such that (ff = oe0) 2 Q2 (20) and nf(oe0) = o/ 0. Then (Q2) ff j oe0 (21) holds by
Eq-Mono and Property 1.5.6.i. Note that (11) gives ff 2 I (22) and dom(Q1/ff) `
I (23) by (1). By Property 3.6.5.i (page 114), (2), (22), (23), (13), (11), and (20),
we have (Q2) oe v oe0 (24), thus (Q2) oe v o/ (25) holds by R-Trans, (24), (21),
and (14). We have (Q2) o/ v o/ (26) by Eq-Refl. By induction hypothesis, (3),
(13), (12), (25), and (26), polyunify (Q1, oe, o/ ) succeeds with (Q0, oe3) (27) such that
(Q0, fl >= oe3) vI[{fl} (Q2, fl >= o/ ). By Property 3.4.2.i (page 106) and PE-Free, we get
Q0 vI Q2 (28). By Property 4.3.1.i (page 125) and (19), we have (ff\Pi oe) 2 Q0 (29) and
ff /2 dom(Q0/o/ ) (30). By (14), A-Equiv, and I-Abstract, we get (Q2) o/ @- ff (31)
and (Q2) o/ v ff (32). The Soundness Lemma (Lemma 4.4.1) applied to (27) give
(Q0) o/ v oe3 (33), (Q0) oe v oe3 (34), and Q1 v Q0. By Lemma 2.1.6 and (33), we have
(Q0) oe3 j o/ (35), thus (Q0) oe v o/ (36) holds by R-Trans, (35), and (34). If \Pi  is
rigid, we can derive (Q2) oe @- o/ by Property 3.6.5.ii (page 114), thus (Q0) oe @- o/ (37)
holds by Lemma 3.6.9, (28), (36), and (12). Let Q01 be Q0 ( (ff = o/ ). By Lemma 4.2.4
(page 123), (28), (29), (37), (36), (30), (32) and (31), Q01 is well defined and Q01 vI Q2
holds. This is the expected result.

ffi Case (ff1, ff2) : We have (ff1 \Pi 1 oe1) 2 Q1 (38), and (ff2 \Pi 2 oe2) 2 Q1 (39). By
hypothesis, (Q2) ff1 j ff2 (40) holds, oe1, oe2 /2 V (41). By well-formedness of (3), Q1 is
closed. Hence, (38) and (39) imply utv(oe1)[utv(oe2) ` dom(Q1), that is, oe1, oe2 2 \Sigma I (42)
by (1).

We show, in a first time, that the algorithm does not fail on its first step. Assume, by
a way of contradiction, that ff2 2 dom(Q1/oe1) holds. Then Q1 is of the form (Qa, ff2 \Pi 2
oe2, Qb) and ff2 2 ftv(8 (Qb) oe1) (43). From (41), we have 8 (Qb) oe1 /2 V (44). We can
derive (Q1) 8 (Qb) oe1 v ff1 by I-Drop?, and I-Hyp or A-Hyp. Hence, (Q2) 8 (Qb) oe1 v
ff1 holds by Lemma 3.6.4 and (3). With (40) and R-Trans, we get (Q2) 8 (Qb) oe1 v
ff2 (45). By Property 2.1.7.ii (page 68), (43), and (45), we have 8 (Qb) oe1 j ff2, which
is not possible by (44). Hence, the hypothesis ff2 2 dom(Q1/oe1) is not true. Similarly,
we can show ff1 /2 dom(Q1/oe2) (46). As a consequence, the algorithm does not fail on
the first step.

We now gather the necessary intermediate results to use the completeness of the update
algorithm (Lemma 4.2.4). This proof is quite similar to the case (ff, o/ ) above. It is a
little more intricate, though, because both bounds are type schemes (not monotypes),
and so is their unifier. If \Pi 1 is rigid, we have (Q1) oe1 @- ff1 (47) by A-Hyp, and (Q1)
oe1 v ff1 (48) by I-Abstract. If \Pi 1 is flexible, we have (48) directly by I-Hyp. By

133

134 Unification

Lemma 3.6.4, (47), (48), and (3), we get (Q2) oe1 @- ff1 (49) (when \Pi 1 is rigid), and
(Q2) oe1 v ff1 (50). By Property 3.2.3.i, (49), and (41), we get (Q2) oe1 @- Q2(ff1) (51)
(when \Pi 1 is rigid). By Property 3.2.3.ii, (50), and (41), we get (Q2) oe1 v Q2(ff1) (52).
Similarly, we have (Q2) oe2 v Q2(ff2) (53), and (Q2) oe2 @- Q2(ff2) when \Pi 2 is rigid. By
Property 2.2.2.v (page 69) and (40), we have (Q2) Q2(ff1) j Q2(ff2) (54). Let oe3 be
Q2(ff1) (55). Note that by Definition 2.2.1, we have oe3 /2 V (56). By (52) and (55),
we have (Q2) oe1 v oe3 (57). By (53), (55), and (54), we get (Q2) oe2 v oe3 (58). By
induction hypothesis, (3), (41), (56), (57), and (58), polyunify (Q1, oe1, oe2) succeeds with
(Q0, oe03) such that (Q0, fl >= oe03) vI[{fl} (Q2, fl >= oe3) holds. By Lemma 3.6.1 (page 113),
there exists a renaming OE disjoint from I [ {fl} and a substitution ` such that (Q0, fl >=
oe03) vJ[{fl} (OE(Q2), fl >= OE(oe3), `) (59) holds, J is the domain dom(Q0/I [ ftv(oe03)) (60),
and dom(`) ` J - I (61). From (59), PE-Comm, and (61), we get (Q0, fl >= oe03) vJ[{fl}
(OE(Q2)`, fl >= OE(oe3)) (62). Let oe003 be OE(oe3) (63) and Q02 be OE(Q2)` (64) Then (62)
becomes (Q0, fl >=oe03) vJ[{fl} (Q02, fl >=oe003 ) (65). We get Q0 vJ Q02 (66) by Property 3.4.2.i
(page 106) and PE-Free. By Lemma 4.6.1, we have oe03 /2 V (67). By (60), we have
dom(Q0, fl >= oe03/fl) ` J [ {fl} (68). We have (Q02) oe03 v oe003 (69) by Property 3.6.5.i
(page 114), (65), (68), (67). Additionally, Q2 j OE(Q2)OE (70) holds by Property 3.4.2.iv

(page 106), which leads to Q2 jI OE(Q2)` (71) by Property 3.4.2.i (page 106) and PEFree. From (71) and (64), we get Q2 jI Q02 (72). By soundness (Lemma 4.4.1), we have
(Q0) oe1 v oe03 (73). Hence, (Q02) oe1 v oe03 (74) holds by Lemma 3.6.4 and (66). By (46) and
Property 4.3.1.i (page 125), we have (ff1\Pi 1oe1)2 Q0 (75) as well as ff1 /2 dom(Q0/oe03) (76).
By Property 3.2.3.iii (page 103) and (55), we get (Q02) oe003 v ff1 (77). By (77), (69), and
R-Trans, we get (Q02) oe03 v ff1 (78).

We temporarily consider, in this paragraph, that \Pi 1 is rigid. Then (51) holds, that is,
(Q2) oe1 @- oe3. Then by (70) and Lemma 3.6.4, we get (Q02OE) oe1 @- oe3, thus we get
(Q02) OE(oe1) @- OE(oe3) by R-Context-R. Since OE is a renaming disjoint from I, and by (63)
and (42), this gives (Q02) oe1 @- oe003 (79) . By Lemma 3.6.6, (74), (69) and (79), we get
(Q02) oe1 @- oe03 (80) and (Q02) oe03 @- oe003 (81). By Lemma 3.6.9, (60), (67), (73), (66), (80),
we get (Q0) oe1 @- oe03 (82). (Q0) oe1 @- ff1 holds by A-Hyp and (75). Hence, (Q02) oe1 @-
ff1 (83) holds by Lemma 3.6.4 and (66). By Property 2.2.2.i (page 69), we have (Q02)
ff1 j Q02[ff1] (84). Thus, we get (Q02) oe1 @- Q02[ff1] (85) by R-Trans, (83), and (84).
By Corollary 2.3.4, (85) and (41), the bound of Q02[ff1] is rigid. Hence, (Q02) Q02(ff1) @-
Q02[ff1] holds by A-Hyp. That is, (Q02) oe003 @- ff1 (86) by (63), (84), and R-Trans. Then
(Q02) oe03 @- ff1 (87) holds by (81), (86), and R-Trans.

We get back to the general case. We have ftv(oe03) ` J (88) from (60). By hypothesis,
we have ff1 2 I, thus ff1 2 J (89). Let Qa be Q0 ( (ff1 \Pi 1 oe03), let Qb be Qa (
(ff2 \Pi 2 oe03), and Q01 be Qb ( ff1 ^ ff2. By Lemma 4.2.4 (page 123), (66), (75), (73), (82),
(76), (88), (89), (78) and (87), Qa is well-defined and we have Qa vJ Q02. Similarly, Qb
is well-defined and we have Qb vJ Q02. By Property 3.4.2.i (page 106), we get Qb vI Q02,
and by (72), we have Qb vI Q2. Then by Lemma 4.2.8 (page 124), we have Q01 vI Q2.
This is the expected result.

The polyunify algorithm:
By hypothesis, oe1, oe2, and oe3 are not in V, and we have (Q2) oe1 v oe3 (1) and (Q2) oe2 v
oe3 (2). Besides, Q1 vI Q2 (3) holds with I = dom(Q1). Hence, I ` dom(Q2) (4). We

134

4.6 Comple'tude de l'algorithme 135

show that the algorithm does not fail and returns (Q01, oe03) such that (Q01, fl >= oe03) vI[{fl}
(Q2, fl >= oe3) holds. We proceed by case on (oe1, oe2).

ffi Case (?, oe) or (oe, ?): Then we return (Q1, oe). We have (Q2) oe v oe3 (5) by (1)
or (2). By hypothesis, we have utv(oe) ` dom(Q1), that is utv(oe) ` I. Thus, we have
(Q1, fl >= oe) vI[{fl} (Q2, fl >= oe) by Property 3.4.2.iii (page 106). Then (Q1, fl >= oe) vI[{fl}
(Q2, fl >= oe3) holds by PI-Context-L, (5) and PI-Trans.

ffi Case (8 (P1) o/1, 8 (P2) o/2): By hypothesis, we have dom(Q1), dom(P1) and dom(P2)
disjoint. We have to gather the intermediate results necessary to use the Recomposition
Lemma (Lemma 3.6.13), which immediately gives the expected result, as shown below.

By Lemma 3.4.4, (1) and (2), there exist two substitutions `1 and `2 and two alphaconversions of oe3, which we write 8 (P3) o/3 and 8 (P4) o/4 , such that we have

Q2P1 vdom(Q2)[I1 Q2P3`1 (6) Q2P2 vdom(Q2)[I2 Q2P4`2

I1

M= dom(P

1/ ftv(o/1)) I2

M= dom(P

2/ ftv(o/2))

(Q2P3) `1(o/1) j o/3 (7) (Q2P4) `2(o/2) j o/4

By Lemma 3.6.2 (page 114) and (6), there exists a renaming OE1 on dom(Q2P3`1), disjoint
from dom(Q2) [ I1, and a prefix Q0 such that we have Q2P1 v OE1(Q2P3`1)Q0. Note that
OE1(o/1) is o/1. Since OE1 is disjoint from dom(Q2), we have Q2P1 v Q2OE1(P3`1)Q0. We
define P 03 as OE1(P3), o/ 03 as OE1(o/3), and `01 as the substitution extracted from OE1(`1).
The last judgment can now be written Q2P1 v Q2P 03`01Q0 (8). By Property 1.7.2.i
(page 60) and (7), we get (Q2P 03) `01(o/1) j o/ 03 (9). Similarly, there exists OE2 disjoint
from dom(Q2) [ I2 and Q00, and we define P 04 as OE2(P4), o/ 04 as OE2(o/4) and `02 as the
substitution extracted from OE2(`2), so that we have Q2P2 v Q2P 04`02Q00 (10) and (Q2P 04)
`02(o/2) j o/ 04 (11). By definition, 8 (P4) o/4 is an alpha-conversion of 8 (P3) o/3, thus there
exists a renaming  of dom(P3) such that P4 = (P3) and o/4 = (o/3) hold. Let 0 be
a renaming mapping dom(P 04) to fresh variables, (that is, outside dom(Q1) [ dom(Q2) [
dom(P 03) [ dom(P1) [ dom(P2) [ dom(`02Q00)). Let OE be 0 ffi OE2 ffi  ffi OE~1 , let P5 be 0(P 04)
and o/5 be 0(o/ 04). We have P5 = OE(P 03) as well as o/5 = OE(o/ 03) (12) Hence, 8 (P5) o/5 is an
alpha-renaming of 8 (P 03) o/ 03. By Property 3.4.2.iv (page 106), we have Q2P 04 j Q2P50.
By Property 3.4.2.iii (page 106), it leads to Q2P 04`02Q00 j Q2P50`02Q00 (13). Let `002 be
0 ffi `02 (14). By PI-Trans, (13), (10), and (14), we get Q2P2 v Q2P5`002 Q00 (15). By
Property 1.7.2.i (page 60) and (11), we get (Q2P5) `002 (o/2) j o/5 (16). By construction,
we have P 03 # P5.

By Property 3.4.2.iii (page 106) and (8), we get Q2P1P2 v Q2P 03`01Q0P2, which gives by
PE-Comm Q2P1P2 v Q2P2P 03`01Q0 (17). By Property 3.4.2.iii (page 106), (15), we get

Q2P2P 03`01Q0 v Q2P5`002 Q00P 03`01Q0
which gives by PE-Comm

Q2P2P 03`01Q0 v Q2P 03P5`01`002 Q0Q00 (18)

135

136 Unification

By PI-Trans, (17) and (18), we have

Q2P1P2 v Q2P 03P5`01`002 Q0Q00 (19)
By Property 3.4.2.v (page 106), we get

Q2P 03P5`01`002 Q0Q00 v Q2P 03OE~`01`002 Q0Q00 (20)
Hence, by PI-Trans, (19), and (20), we have

Q2P1P2 v Q2P 03OE~`01`002 Q0Q00 (21)
By Lemma 3.6.4, (16), and (20), we have (Q2P 03OE~`01`002 Q0Q00) `002 (o/2) j o/5 (22). Moreover, we have

(Q2P 03OE~`01`002 Q0Q00) o/1 j `01(o/1) by Eq-Mono

j(23) o/ 03 by (9)
= OE~(o/5) by (12)
j o/5 by Eq-Mono
j `002 (o/2) by (22)
j o/2 by Eq-Mono

In summary, we have shown that we have (Q2P 03OE~`01`002 Q0Q00) o/1 j o/2 (24). Additionally, (Q2) 8 (P 03OE~`01`002 Q0Q00) o/1 j 8 (P 03OE~`01`002 Q0Q00) o/ 03 holds by (23) and RContext-R, that is, (Q2) 8 (P 03OE~`01`002 Q0Q00) o/1 j oe3 (25). Similarly, we have (Q2)
8 (P 03OE~`01`002 Q0Q00) o/2 j oe3. By Property 3.4.2.iii (page 106) and (3), we get Q1P1P2 v
Q2P1P2. Hence, we have Q1P1P2 v Q2P 03OE~`01`002 Q0Q00 (26) from (21). Hence, by (26),
(24), and induction hypothesis, the call to unify (Q1P1P2, o/1, o/2) succeeds with Q0 such
that Q0 vdom(Q1P1P2) Q2P 03OE~`01`002 Q0Q00 (27).

Let (Q3, Q4) be Q0" dom(Q1), that is, Q0"I. By Lemma 3.6.13, (27), and (4), ftv(o/1) `
I [ dom(P1), taking J = dom(P1P2), and by (25), we get (Q3, fl >= 8 (Q4) o/1) vI[{fl}
(Q2, fl >= oe3). The algorithm returns (Q3, 8 (Q4) o/1), thus Q01 is Q3 and oe03 is 8 (Q4) o/1.
Hence, we have shown that (Q01, fl >= oe03) vI[{fl} (Q2, fl >= oe3) holds. This is the expected
result.

Corollary 4.6.3 Assume Q1 vI Q2 and o/1, o/2 are in \Sigma I . If (Q2) o/1 j o/2 holds, then
unify (Q1, o/1, o/2) succeeds with Q01 such that Q01 vI Q2.

See proof in the Appendix (page 289).

Theorem 1 For any prefix Q and monotypes o/1 and o/2, unify (Q, o/1, o/2) returns the
smallest prefix (for the relation vdom(Q)) that unifies o/1 and o/2 under Q, or fails if there
exists no prefix Q0 that unifies o/1 and o/2 under Q.

136

4.6 Comple'tude de l'algorithme 137
This theorem is a direct consequence of the soundness of the unification algorithm
(Lemma 4.4.1), of its completeness (Lemma 4.6.2), and of its proof of termination
(Lemma 4.5.5). Indeed, given a unification problem, the unification algorithm either
fails or returns a prefix Q (termination). It it fails, the unification problem has no solution (completeness). Otherwise, Q is a solution to the unification problem (soundness)
and all other solutions are instances of Q (completeness).

First-order unification The next lemma shows that the unification algorithm for
MLF returns the same result as the unification algorithm for ML when the given unification problem is actually an ML unification problem.

Lemma 4.6.4 Given two monotypes o/1 and o/2, and an unconstrained prefix Q such
that o/1 and o/2 are closed under Q, unify (Q, o/1, o/2) returns Q0 such that cQ0 is the
principal unifier of o/1 and o/2, or fails if o/1 and o/2 cannot be unified.

Proof: Termination : By Lemma 4.5.5, we know that unify (Q, o/1, o/2) always terminates.
Soundness : If unify (Q, o/1, o/2) returns a prefix Q0, then by Lemma 4.4.1, we have Q v Q0
and (Q0) o/1 j o/2 (1). Let ` be cQ0. By Property 1.5.11.vii (page 56) and (1), we have
`(o/1) = `(o/2). Hence, ` is a unifier of o/1 and o/2.

Completeness: Assume there exists a substitution ` such that `(o/1) = `(o/2). Then (`)
o/1 j o/2 (2) holds by Eq-Mono. Let I be ftv(oe1) [ ftv(oe2). Let Q00 be an unconstrained
prefix such that ftv(`(I)) ` dom(Q00). Then Q vI Q00` (3) holds by PE-Free, PIContext-L, and I-Bot. By Corollary 4.6.3, (2), and (3), unify (Q, o/1, o/2) succeeds and
returns Q0 such that Q0 vI Q00`. By Lemma 3.6.10 (page 116), there exists `0 such that

we have ` = `0 ffi cQ0. This is the expected result.

137

138 Unification
138

139
Deuxie`me partie
Le langage de programmation

139

141
L'expressivite' des types, que nous avons e'tudie'e en partie I, est plus riche que celle de
ML : les types contiennent le polymorphisme d'ordre supe'rieur. Dans cette partie, nous
expliquons comment utiliser ces types dans le cadre d'un langage de programmation,
MLF, et montrons que ce langage est su^r, c'est-a`-dire que les programmes bien type's ne
provoquent pas d'erreur d'exe'cution. La su^rete' en MLF est montre'e par une combinaison
habituelle de progress, qui e'tablit que les expressions bien type'es sont soit les valeurs
soit peuvent e^tre re'duites, et de subject reduction, qui montre que la re'duction pre'serve
les types. Puisque MLF vise a` e^tre une extension de ML, la syntaxe de MLF contient
la syntaxe de ML, avec les me^mes re`gles de re'duction. En fait, les expressions de MLF
sont exactement les expressions de ML. De plus, nous montrons dans le corollaire 8.1.7
que le noyau MLF admet le me^me ensemble de termes typables que ML.

Fort heureusement, la puissance disponible dans les types de MLF peut e^tre introduite gra^ce aux annotations de type, qui sont un ensemble de primitives. Ces primitives
ne cou^tent rien a` l'exe'cution : elles se comportent comme l'identite', mais leur type
rend possible l'introduction de polymorphisme d'ordre supe'rieur dans les programmes.
Bien su^r, ces primitives ont un type qui, en ge'ne'ral, ne peut pas e^tre exprime' en ML.
Elles requie`rent toute la puissance des types de MLF. Puisque nous souhaitons montrer
subject reduction, nous devons associer une re`gle de re'duction a` chaque annotation de
type. Cependant, les re`gles associe'es a` certaines annotations ne'cessiteraient un langage
des types encore plus riche que celui de MLF. En d'autres termes, il n'est pas possible
d'associer une re`gle de re'duction a` chaque annotation de type dans MLF. En conse'quence, nous utilisons une astuce, appele'e oracle. Un oracle est une simple marque
ajoute'e sur une expression, qui sera intuitivement remplace'e par l'annotation de type
ade'quate. Ainsi, les re`gles de re'duction associe'es aux annotations de type sont faciles
a` e'crire en utilisant les oracles. Le langage compose' de MLF et des oracles est appele'
MLF?. Puisque nous souhaitons montrer la su^rete' dans MLF, et puisque les annotations
de type cre'ent des oracles par re'duction, nous devons montrer subject-reduction et
progress dans MLF?. Remarquer que, comme pour les annotations de types, les oracles
n'ont aucun cou^t a` l'exe'cution : ils se comportent comme l'identite'. En fait, leur ro^le
est uniquement statique. Ils sont utilise's en remplacement des annotations de type pour
permettre l'introduction de polymorphisme d'ordre supe'rieur. Une diffe'rence essentielle
entre les oracles et les annotations de type, ou encore entre MLF? et MLF, re'side dans la
remarque que les annotations de type contiennent toute l'information ne'cessaire pour
l'infe'rence de type, alors que les oracles ne contiennent aucune information explicite,
mais indiquent seulement un emplacement ou` une annotation doit e^tre inse're'e. Ceci
implique que l'infe'rence est possible en MLF. Quant a` MLF?, l'infe'rence est probablement aussi difficile que pour le Syste`me F, me^me si l'inde'cidabilite' de l'un n'implique
pas l'inde'cidabilite' de l'autre. Voir la partie III et en particulier le chapitre 10 pour une
discussion plus e'labore'e a` ce sujet.

141

142

Cette partie est organise'e comme suit : nous de'finissons MLF et MLF? au chapitre 5,
et nous donnons leur se'mantique statique et dynamique. La su^rete' est montre'e pour
MLF? au chapitre 6, et la su^rete' pour MLF en de'coule. L'algorithme d'infe'rence de MLF
est montre' correct et complet au chapitre 7. Finalement, les annotations de type sont
introduites comme un ensemble de primitives au chapitre 8. Les annotations de type
peuvent e^tre vues comme un pont entre MLF, qui autorise l'infe'rence, et MLF?, qui
utilise les oracles ne'cessaires pour montrer la su^rete'.

142

143
Chapitre 5
Syntaxe et se'mantique

Ce chapitre introduit la syntaxe de MLF?, qui est la syntaxe ML avec des oracles
(section 5.1). Ensuite, la se'mantique statique est donne'e, sous forme de re`gles de typage
pour MLF?, dans la section 5.2. Elles sont similaires a` celles de ML, avec une re`gle
supple'mentaire pour les oracles qui permet d'inverser la relation d'abstraction. Ceci est
appele' re've'lation. Comme la re've'lation implicite empe^che l'infe'rence de type, les oracles
ne sont pas autorise's dans MLF, pour lequel nous donnons un algorithme d'infe'rence.
Ils seront remplace's par des annotations explicites, de'crites chapitre 8. Comme pour
ML, nous e'tablissons un ensemble de re`gles dirige'es par la syntaxe section 5.3. Alors
que la pre'sentation dirige'e par la syntaxe de ML force les jugements a` e^tre autant
instancie's que possible, les jugements de MLF? sont ge'ne'ralise's autant que possible.
En effet, le polymorphisme doit e^tre maintenu en profondeur dans les types afin de
garder les types principaux. Les quantificateurs peuvent ensuite e^tre extrude's vers la
surface si besoin. Finalement, la section 5.4 donne la se'mantique dynamique de MLF?,
qui est identique a` celle de ML. Les oracles ne contribuent pas a` la re'duction. Ils sont
simplement propage's pour indiquer les emplacements qui ne'cessitent une annotation
dans les re'ductions successives.

Nous conside'rons e'galement une variante de MLF?, appele'e UMLF (unannotated
MLF), ou` les oracles sont laisse's implicites. Bien entendu, MLF, MLF?, et UMLF ont le
me^me ensemble de termes typables (en ignorant les annotations), mais l'infe'rence n'est
possible que dans MLF.

5.1 Syntax

We assume given a countable set of variables, written with letter x, and a countable
set of constants c 2 C. Every constant c has an arity |c|. A constant is either a primitive f or a constructor C. The distinction between constructors and primitives lies in

143

144 Syntaxe et se'mantique

Fig. 5.1 - Expressions of MLF?
a ::= x | c | *(x) a | a a | let x = a in a Terms

| (a : ?) Oracles
c ::= f | C Constants
z ::= x | c Identifiers

their dynamic semantics : primitives (such as +) are reduced when fully applied, while
constructors (such as cons) represent data structures, and are only reduced by other
primitives (or pattern matching in a suitable extension of the language). We use letter
z to refer to identifiers, i.e. either variables x or constants c.

Expressions of MLF?, written with letter a, are described in Figure 5.1. Expressions
are those of ML extended with oracles. An oracle, written (a : ?) is a place holder for
an implicit type annotation around the expression a. Equivalently, the oracles can be
replaced by explicit type annotations before type inference. Explicit annotations (a : oe),
which are described in Chapter 8, are actually syntactic sugar for applications (oe) a
where (oe) are constants. Some examples given in the introduction use the notation
*(x : oe) a, which is not defined in Figure 5.1 because it is syntactic sugar for *(x)
let x = (x : oe) in a. Similarly, *(x : ?) a means *(x) let x = (x : ?) in a.

The language MLF is the restriction of MLF? to expressions that do not contain
oracles. Programmers are expected to write their programs in MLF, so that type inference is possible. Reductions rules, however, may introduce oracles. More precisely,
oracles are only introduced by type annotation primitives. Hence, the language MLF?
is only needed to show subject reduction for programs that contain type annotations.

5.2 Static semantics

Typing environments (or typing contexts), written with letter \Gamma , are lists of assertions of the form z : oe that bind each identifier at most once. We write z : oe 2 \Gamma  to
mean that z is bound in \Gamma . We note that the order of assertions is not significant in \Gamma 
since identifiers are bound at most once. We assume given an initial typing context \Gamma 0
mapping constants to closed polytypes. A typing environment \Gamma  extends \Gamma 0 whenever
for all z : oe in \Gamma 0, we have z : oe in \Gamma .

Typing judgments are of the form (Q) \Gamma  ` a : oe. A tiny difference with ML is the
presence of the prefix Q that assigns bounds to type variables appearing free in \Gamma  or oe.
By comparison, this prefix is left implicit in ML because all free type variables have

144

5.2 Se'mantique statique 145

Fig. 5.2 - Typing rules for MLF and MLF?
Var

z : oe 2 \Gamma 

(Q) \Gamma  ` z : oe

App

(Q) \Gamma  ` a1 : o/2 ! o/1 (Q) \Gamma  ` a2 : o/2

(Q) \Gamma  ` a1 a2 : o/1

Fun

(Q) \Gamma , x : o/0 ` a : o/

(Q) \Gamma  ` *(x) a : o/0 ! o/

Let

(Q) \Gamma  ` a1 : oe

(Q) \Gamma , x : oe ` a2 : o/

(Q) \Gamma  ` let x = a1 in a2 : o/

Gen

(Q, ff \Pi  oe) \Gamma  ` a : oe0 ff /2 ftv(\Gamma )

(Q) \Gamma  ` a : 8 (ff \Pi  oe) oe0

Inst

(Q) \Gamma  ` a : oe (Q) oe v oe0

(Q) \Gamma  ` a : oe0

Oracle

(Q) \Gamma  ` a : oe (Q) oe A- oe0

(Q) \Gamma  ` (a : ?) : oe0

the same (implicit) bound ?. In MLF and MLF?, we require oe and all polytypes of \Gamma  to
be closed with respect to Q, that is, utv(\Gamma ) [ utv(oe) ` dom(Q).

Typing rules The typing rules of MLF? and MLF are described in Figure 5.2. They
correspond to the typing rules of ML modulo the richer types, the richer instance relation, and the explicit binding of free type variables in judgments (in the prefix). In
addition, Rule Oracle allows for the revelation of polytypes, that is, the transformation of types along the inverse of the abstraction relation. (This rule would have
no effect in ML where abstraction is the same as equivalence.) As explained in the
introduction, we also consider UMLF, a variant of MLF? where oracles are left implicit.
This amounts to replacing Rule Oracle by U-Oracle given below or, equivalently,
combine Oracle with Inst into U-Inst.

U-Oracle

(Q) \Gamma  ` a : oe (Q) oe A- oe0

(Q) \Gamma  ` a : oe0

U-Inst

(Q) \Gamma  ` a : oe (Q) oe A-vA- oe0

(Q) \Gamma  ` a : oe0

In Rule U-Inst, we have to allow revelation before and after instantiation because v
and A- do not commute in general, under an arbitrary prefix. However, A-vA-v happens
to be equal1 to A-vA-. Thus, Rule U-Inst never needs to be used twice on the same
expression.

1This statement is not shown in this document. It is proved under an unconstrained prefix using
the Diamond Lemma (Lemma 2.8.4).

145

146 Syntaxe et se'mantique

As in ML, there is an important difference between rules Fun and Let : while
typechecking their bodies, a let-bound variable can be assigned a polytype, but a *-
bound variable can only be assigned a monotype in \Gamma . Indeed, the latter must be
guessed while the former can be inferred from the type of the bound expression. This
restriction is essential to enable type inference. Notice that a *-bound variable can refer
to a polytype abstractly via a type variable ff bound to a polytype oe in Q. However,
this will not make it possible to take different instances of oe while typing the body of
the abstraction, unless the polytype bound oe of ff is first revealed by an oracle. Indeed,
the only possible instances of ff under a prefix Q that contains the binding (ff = oe) are
types equivalent to ff under Q, as shown by Lemma 2.1.6. However, (Q) ff j oe does
not hold (see Property 1.5.11.x (page 56)). Thus, if x : ff is in the typing context \Gamma , the
only way of typing x (modulo equivalence) is (Q) \Gamma  ` x : ff, whereas (Q) \Gamma  ` x : oe is
not derivable. Conversely, (Q) \Gamma  ` (x : ?) : oe is derivable, since (Q) ff A- oe holds. This
prevents, for example, *(x) x x from being typable in MLF--see Example 6.2.12.

5.2.1 ML as a subset of MLF

ML can be embedded into MLF by restricting all bounds in the prefix Q to be
unconstrained. Rules Gen and Inst are then exactly those of ML, by Lemma 3.4.7.
Hence, any closed program typable in ML is also typable in MLF.

The converse will be shown in Section 8.1 ; that is, terms typable in MLF without
primitives are also typable in ML.

5.2.2 Examples of typings

In this section, we consider three examples of typings :
- The first one illustrates that the canonical typing in MLF (or principal typing) of

a term can be quite different from its typing in ML.
- The second example focuses on the role of rigid bindings in types : we introduce

two constants whose type differ only by one rigid binding. In the type of the
first constant, a single rigid binding is used. In the type of the second constant,
the same rigid binding is duplicated. We compare the typing of expressions using
either one of these constants.
- The third example considers the "app" property, which illustrates the compositionality of MLF.

Example 5.2.9 This first example of typing illustrates the use of polytypes in typing
derivations : we consider the simple expression K 0 defined by *(x) *(y) y. Following

146

5.2 Se'mantique statique 147
ML, one possible typing derivation is (recall that (ff, fi) stands for (ff >= ?, fi >= ?)) :

Gen

Fun (ff, fi) x : ff, y : fi ` y : fi

Fun (ff, fi) x : ff ` *(y) y : fi ! fi(ff, fi) ` K0 : ff ! (fi ! fi)

` K0 : 8 (ff, fi) ff ! (fi ! fi)
There is, however, another typing derivation that infers a more general type for K 0 in
MLF (for conciseness we write Q for (ff, fi >=oeid), and we recall that oeid is 8 (ff) ff ! ff) :

Inst

Gen

Fun (Q, fl) x : ff, y : fl ` y : fl(Q, fl) x : ff ` *(y) y : fl ! fl

(Q) x : ff ` *(y) y : oeid (Q) oeid v fi I-Hyp

Fun (Q) x : ff ` *(y) y : fi

Gen (Q) ` K

0 : ff ! fi

` K0 : 8 (Q) ff ! fi

Notice that the polytype 8 (Q) ff ! fi is more general than 8 (ff, fi) ff ! (fi ! fi),
which follows from Example 1.8.7. Actually, this derivation gives the principal type of
K0. Satisfyingly, this is also the type inferred by the type inference algorithm (given in
Chapter 7), and implemented in a prototype of MLF :

# let k' = fun x y -> y ;;
val k' : ['a] ['b > ['c] 'c -> 'c] 'a -> 'b

Here are graphs representing the type of K 0. The left-hand graph represents its
principal type in MLF, given above. The right-hand graph represents the type of K 0 in
ML, that is, 8 (ff, fi) ff ! fi ! fi.

!

?

!

?

!
?

!

?

147

148 Syntaxe et se'mantique
Example 5.2.10 This example emphasizes the role of the relation A- during typing.
Let f1 and f2 be two functions of respective types :

oe1

M= 8 (ff = oe

id) 8 (ff0 = oeid) ff ! ff0

oe2

M= 8 (ff = oe

id) ff ! ff

The graphs representing these types are the following :

!

!

?

!

?

!
!

?
Intuitively, f1 and f2 behave like the identity (they just return their argument). Let
us check that the expression a1 defined as *(x) (f1 x) x, is typable but a2, defined as
*(x) (f2 x) x, is not. In the former case, we can easily derive the following judgment,
where Q stands for (ff = oeid, ff0 = oeid) and \Gamma  is x : ff :

App (Q) \Gamma  ` f1 : ff ! ff

0 (Q) \Gamma  ` x : ff

(Q) \Gamma  ` f1 x : ff0 (1)

Hence (ff = oeid) \Gamma  ` f1 x : 8 (ff0 = oeid) ff0 holds by Rule Gen since ff0 is not free
in the context. By Rule Eq-Var, we get 8 (ff0 = oeid) ff0 j oeid (under any prefix).
Besides, we also have oeid v ff ! ff under any prefix that binds ff. Consequently, we
get (ff = oeid) \Gamma  ` f1 x : ff ! ff by Rule Inst. Hence, ` *(x) (f1 x) x : oe2 follows by
App and Gen. However, when f1 is replaced by f2, we can only derive (Q) \Gamma  ` f2 x : ff
instead of the judgment (1) and we cannot apply Rule Gen with ff. Additionally, it
happens that oe1 @- oe2 is derivable (see for example Rule A-Alias'), thus (f2 : ?) can
be given the type oe1 so that *(x) (f2 : ?) x x is typable.

We see that the expression a2 is not typable as such, but becomes typable with an
oracle. In this very example, the role of the oracle is to "transform" the function f2 into
f1. The function f2 can be viewed as the identity, that is, a silent function, whereas
f1 can be viewed as a type annotation. Hence, the oracle transforms a silent binding
let x = x in x x into an annotated binding let x = (x : oeid) in x x.

Example 5.2.11 We recall that app is defined as *(x) *(y) x y. An interesting
property of MLF is that whenever an application a1 a2 is typable, then app a1 a2

148

5.3 Syste`me dirige' par la syntaxe 149

Fig. 5.3 - Syntax-directed typing rules
Var

O

z : oe 2 \Gamma 
(Q) \Gamma  `

O z : oe

Fun

O

ff /2 ftv(o/0)
(QQ0) \Gamma , x : o/0 `

O a : oe dom(Q0) # ftv(\Gamma )

(Q) \Gamma  `

O *(x) a : 8 (Q0, ff >= oe) o/0 ! ff

App

O

(Q) \Gamma  `

O a1 : oe1 (Q) \Gamma  `O a2 : oe2

(Q) oe1 v 8 (Q0) o/2 ! o/1 (Q) oe2 v 8 (Q0) o/2

(Q) \Gamma  `

O a1 a2 : 8 (Q0) o/1

Let

O

(Q) \Gamma  `

O a1 : oe1

(Q) \Gamma , x : oe1 `

O a2 : oe2

(Q) \Gamma  `

O let x = a1 in a2 : oe2

Oracle

O

(Q) \Gamma  `

O a : oe

(Q) oe v oe00 (Q) oe00 A- oe0

(Q) \Gamma  `

O (a : ?) : oe0

is also typable, without any need for extra type annotations. Indeed, app has type
8 (ff, fi) (ff ! fi) ! ff ! fi (the typing derivation is similar to the one in ML). Besides,
since a1 a2 is typable, we must have a1 of type o/2 ! o/1 and a2 of type o/2. Then by
instantiation, app can be given the type (o/2 ! o/1) ! o/2 ! o/1, and app a1 a2 is easily
typed, then. It should be noted that, whereas only monotypes seem to be used, o/1 and
o/2 can actually be type variables bound to polytypes in the current prefix. We see that
although o/1 and o/2 can be aliases to polytypes, they are transparently propagated to
the type of app by implicit instantiation.

5.3 Syntax-directed presentation

As in ML, we can replace the typing rules of MLF? by a set of equivalent syntaxdirected typing rules, which are given in Figure 5.3. Naively, a sequence of non-syntaxdirected typing rules Gen and Inst should be placed around any other rule. However,
many of these occurrences can be proved unnecessary by following an appropriate strategy. For instance, in ML, judgments are maintained instantiated as much as possible
and are only generalized on the left-hand side of Rule Let. In MLF?, this strategy
would require more occurrences of generalization. Instead, we prefer to maintain typing
judgments generalized as much as possible. Then it suffices to allow Rule Gen right
after Rule Fun and to allow Rule Inst right before Rule App (see rules Fun

O and

149

150 Syntaxe et se'mantique
App

O). Syntax-directed rules are slightly less intuitive. However, they are much more

convenient for proving formal properties. In particular, induction on derivations can be
replaced by structural induction on terms. The equivalence between the syntax-directed
and original presentations of the typing rules is stated in section 6.2.

5.4 Dynamic semantics

The semantics of MLF? is the standard call-by-value semantics of ML. Another
choice, such as e.g. call-by-name would satisfy the same essential properties, including
type safety. However, the discussion about imperative features such as references, to
be found in Part III, assumes a call-by-value semantics. We present it as a small-step
reduction semantics. Values and call-by-value evaluation contexts are described below.

v ::= w | (w : ?)
w ::= *(x) a

| f v1 . . . vn n < |f |
| C v1 . . . vn n <= |C|
E ::= [ ] | E a | v E | (E : ?) | let x = E in a

A value is either a function (*(x) a), a partially applied primitive (f v1 . . . vn), or
a constructed value C v1 . . . vn. Additionally, it can be an annotated value, that is
(w : ?), where w is a non-annotated value. We distinguish two classes, v and w, in
order to forbid ((v : ?) : ?), which is not a value. Indeed, it can be reduced to (v : ?)
by Rule ??, to be found next. The reduction relation -! is parameterized by a set of
ffi-rules of the form (ffi) :

f v1 . . . vn -! a when |f | = n (ffi)

(*(x) a) v -! a[v/x] (fiv)
let x = v in a -! a[v/x] (filet)

(v1 : ?) v2 -! (v1 v2 : ?) (?)
((v : ?) : ?) -! (v : ?) (??)

The main reduction is the fi-reduction that takes two forms Rule (fiv) and Rule (filet).
Oracles are maintained during reduction, to which they do not contribute : they are
simply pushed out of applications by Rule (?). Moreover, two oracles do not have more
power than one single oracle, as stated by Rule (??). Finally, the reduction is the
smallest relation containing (ffi), (fiv), (filet), (?), and (??) rules that is closed under
E-congruence :

E[a] -! E[a0] if a -! a0 (Context)

Note that the semantics of MLF is untyped. See Remark 9.3.1 on page 184 for more
discussion of this issue.

150

151
Chapitre 6
Su^rete' du typage

La su^rete' du typage de MLF? est montre'e en combinant deux re'sultats : subject reduction, qui garantit que les types sont pre'serve's par re'duction et progress, qui garantit
que les programmes bien type's n'e'tant pas des valeurs peuvent se re'duire. Quelques
re'sultats standards sont d'abord montre's section 6.1. Nous montrons ensuite subject
reduction et progress dans le syste`me dirige' par la syntaxe, et devons donc montrer au
pre'alable l'e'quivalence entre le syste`me dirige' par la syntaxe et le syste`me original. Ceci
est fait section 6.2. La su^rete' est montre'e pour MLF? parame'tre' par un ensemble de primitives et de constructeurs. Bien su^r, certaines proprie'te's concernant le comportement
et le type de ces primitives sont requises. Ces proprie'te's, ainsi que subject reduction et
progress, sont e'nonce'es section 6.3.

6.1 Standard Properties

In this section, we give a few standard properties, which are similar to well known
properties in ML. A first one states that typing judgments can be renamed. Then we
show that the hypotheses gathered in the prefix can be instantiated (Rule Weaken)
and that the hypotheses of the typing environment can be replaced by more general
assumptions (Rule Strengthen). Finally, the Substitutivity Lemma is a key result
for showing subject-reduction.

6.1.1 Renaming and substitutions
Lemma 6.1.1 (Renaming of judgment) Given a derivation of the judgment (Q)
\Gamma  ` a : oe and a renaming OE on type variables, the judgment (OE(Q)) OE(\Gamma ) ` a : OE(oe)
admits a derivation of the same size.

151

152 Su^rete' du typage

Proof: By induction on the derivation of (Q) \Gamma  ` a : oe. All cases are easy.
6.1.2 Strengthening and weakening typing judgments

The instance relation between typing contexts (Q) \Gamma 0 v \Gamma  is an abbreviation for

8z 2 dom(\Gamma ), we have z 2 dom(\Gamma 0) and (Q) \Gamma 0(z) v \Gamma (z)
The next lemma states two standard properties of typing judgments, presented in the
form of rules Strengthen and Weaken, along with a variant Weaken?. In a judgment (Q) \Gamma  ` a : oe, the polytype oe can be weakened as described by Rule Inst.
Conversely, the context \Gamma  can be strengthened, as described by Rule Strengthen. In
addition to weakening the type or strengthening the context, the whole judgment can
be instantiated. In ML, this is expressed by stability of typing judgments under substitutions. In MLF, this is modeled by instantiating the prefix of the typing judgment, as
described by Rule Weaken. To see this, consider prefixes as a generalization of substitutions. An ML derivation \Gamma  ` a : oe would be represented in MLF by (Q) \Gamma  ` a : oe
where Q assigns unconstrained bounds to the type variables of ftv(\Gamma ) [ ftv(oe). The
substitution lemma says that for any substitution `, the derivation `(\Gamma ) ` a : `(oe) (1)
is also valid. In MLF, applying Rule Weaken to (Q) \Gamma  ` a : oe, we can first deduce
that the derivation (Q0, (ff >= `(ff))ff2Q) \Gamma  ` a : oe holds where Q0 assigns unconstrained bounds to ftv(`(Q)). By notation, this is (Q0, `) \Gamma  ` a : oe. Then we can derive
(Q0) `(\Gamma ) ` a : `(oe) (which represents the ML judgment (1)) using rules Strengthen,
Gen and Inst and the equivalences (Q0`) \Gamma  j `(\Gamma ) and (Q0`) oe j `(oe). In summary,
the stability of typing judgments under substitution in ML is here expressed as Rule
Weaken, which allows the instantiation of the current prefix. Indeed, prefixes are a
generalization of substitutions, and prefix instance corresponds to substitution composition. While Rule Weaken requires Q0 to be an instance of Q under interface dom(Q),
Rule Weaken? specifies an interface I which must only contain free variables of \Gamma  and
oe ; this version is not used further.

Lemma 6.1.2 The following rules are admissible :

Strengthen

(Q) \Gamma  ` a : oe (Q) \Gamma 0 v \Gamma 

(Q) \Gamma 0 ` a : oe

Weaken

(Q) \Gamma  ` a : oe Q v Q0

(Q0) \Gamma  ` a : oe

Weaken?

(Q) \Gamma  ` a : oe ftv(\Gamma , oe) ` I Q vI Q0

(Q0) \Gamma  ` a : oe

152

6.1 Proprie'te's standard 153

Proof: We prove Strengthen by induction on the derivation of (Q) \Gamma  ` a : oe. Cases
App, Fun, Let, Inst and Oracle are by induction hypothesis.

ffi Case Var : We have (Q) \Gamma  ` z : oe and z : oe is in \Gamma . By definition, z : oe0 is in \Gamma 0,
with (Q) oe0 v oe. Hence, we have (Rule Var) (Q) \Gamma 0 ` z : oe0 and we get the expected
result (Q) \Gamma 0 ` z : oe by Rule Inst.

ffi Case Gen : The premises are (Q, ff\Pi oea) \Gamma  ` a : oe0 (1) and ff /2 ftv(\Gamma ). The conclusion
is (Q) \Gamma  ` a : 8 (ff\Pi oea) oe0. We have (Q) \Gamma 0 v \Gamma  by hypothesis. By well-formedness all free
type variables of \Gamma  and \Gamma 0 must be bound in Q, and ff /2 dom(Q) holds by hypothesis,
hence we have ff /2 ftv(\Gamma 0). The result is by induction hypothesis on (1) and Rule Gen,
then.

We prove Weaken by induction on the derivation of (Q) \Gamma  ` a : oe. Case Var is
immediate. Cases Fun, App, and Let are by induction hypothesis. Case Gen : The
premise is (Q, ff\Pi oe1) \Gamma  ` a : oe2 (2) and ff /2 ftv(\Gamma ). The conclusion is (Q) \Gamma  ` a : 8 (ff\Pi oe1)
oe2. By alpha-conversion, we can freely assume that ff /2 dom(Q0). By Property 3.4.2.iii
(page 106) and the hypothesis Q v Q0, we get (Q, ff \Pi  oe1) v (Q0, ff \Pi  oe1). By induction
hypothesis and (2), we get a derivation of (Q0, ff \Pi  oe1) \Gamma  ` a : oe2. By Rule Gen, we get
(Q0) \Gamma  ` a : 8 (ff \Pi  oe1) oe2, which is the expected result. Cases Inst and Oracle are
direct consequences of Lemma 3.6.4.

Proof of Weaken? : The hypotheses are (Q) \Gamma  ` a : oe (1), ftv(\Gamma ) ` I (2), ftv(oe) ` I (3),
and Q vI Q0 (4). By Lemma 3.6.2 (page 114) and (4), there exists a renaming OE disjoint
from I and a prefix Q0 such that Q v OE(Q0)Q0 (5) and dom(Q0) # I (6) hold. Hence,
by Weaken, (5) and (1), we have (OE(Q0)Q0) \Gamma  ` a : oe. By Rule Gen, (6) and (2), we get
(OE(Q0)) \Gamma  ` a : 8 (Q0) oe (7). By Eq-Free, (6) and (3), we get 8 (Q0) oe j oe (8). Hence,
(OE(Q0)) \Gamma  ` a : oe (9) holds by Rule Inst, (7), and (8). The renaming OE is disjoint from
I, thus OE~(\Gamma ) = \Gamma  and OE~(oe) = oe hold by (2) and (3). By (9) and Lemma 6.1.1 applied
with the renaming OE~, we get (Q0) \Gamma  ` a : oe, which is the expected result.

Corollary 6.1.3 If QQ0 is well-formed and if (Q) \Gamma  ` a : oe holds, then so does
(QQ0) \Gamma  ` a : oe.

As a consequence, the following rule is admissible :

App?

(Q) \Gamma  ` a1 : 8 (Q0) o/2 ! o/1 (Q) \Gamma  ` a2 : 8 (Q0) o/2

(Q) \Gamma  ` a1 a2 : 8 (Q0) o/1

Proof: Corollary 6.1.3 is a direct consequence of Rule Weaken, observing that Q j QQ0
holds by PE-Free.

App? is derivable : By alpha-conversion, we can assume that Q0 # Q and dom(Q0) #
ftv(\Gamma ). By Corollary 6.1.3, we have (QQ0) \Gamma  ` a1 : 8 (Q0) o/2 ! o/1 (1) as well as (QQ0) \Gamma  `

153

154 Su^rete' du typage

a2 : 8 (Q0) o/2 (2). By Rule I-Drop?, we have (QQ0) 8 (Q0) o/2 ! o/1 v o/2 ! o/1 (3) as well
as (QQ0) 8 (Q0) o/2 v o/2 (4). Hence, (QQ0) \Gamma  ` a1 : o/2 ! o/1 and (QQ0) \Gamma  ` a2 : o/2 hold
by Rule Inst, (1) and (3), as well as (2) and (4) respectively. Then (QQ0) \Gamma  ` a1 a2 : o/1
holds by App. Finally, (Q) \Gamma  ` a1 a2 : 8 (Q0) o/1 holds by Rule Gen.

6.1.3 Substitutivity

Lemma 6.1.4, next, is a usual result in ML, which states that unused hypotheses
can be added to the typing environment.

Lemma 6.1.4 If \Gamma  and \Gamma 0 have disjoint domains, and if (Q) \Gamma  ` a : oe holds, then so
does (Q) \Gamma , \Gamma 0 ` a : oe.

See proof in the Appendix (page 289).

The substitutivity lemma is a key result for showing subject reduction.
Lemma 6.1.5 (Substitutivity) If we have (Q) \Gamma , x : oe ` a0 : oe0 and (Q) \Gamma  ` a : oe,
then (Q) \Gamma  ` a0[a/x] : oe0 holds.

Proof: We write ` for the substitution [a/x]. By hypothesis, (Q) \Gamma  ` a : oe (1) holds.
The proof is by induction on the derivation of (Q) \Gamma , x : oe ` a0 : oe0. Cases App, Inst,
Gen and Oracle are by induction hypothesis.

ffi Case Fun : The premise is (Q) \Gamma , x : oe, y : o/0 ` a1 : o/ (2) and the conclusion is
(Q) \Gamma , x : oe ` *(y) a1 : o/0 ! o/ . The judgment (2) can as well be written (Q) \Gamma , y : o/0, x :
oe ` a1 : o/ (3). By Lemma 6.1.4 and (1), we have (Q) \Gamma , y : o/0 ` a : oe (4). By induction
hypothesis, (3), and (4) we have (Q) \Gamma , y : o/0 ` `(a1) : o/. Hence, by Rule Fun, we get
(Q) \Gamma  ` `(*(y) a1) : o/0 ! o/ , which is the expected result.

ffi Case Var : we have (Q) \Gamma , x : oe ` z : oe0. If z is not x, then `(z) is z, and we have
(Q) \Gamma  ` `(z) : oe0. Otherwise, we have z = x and oe0 = oe. By hypothesis, (Q) \Gamma  ` x : oe
holds, that is, (Q) \Gamma  ` a : oe.

ffi Case Let : we have (Q) \Gamma , x : oe ` let y = a1 in a2 : oe0, and the premises are
(Q) \Gamma , x : oe ` a1 : oey (5) and (Q) \Gamma , x : oe, y : oey ` a2 : oe0, which can also be
written (Q) \Gamma , y : oey, x : oe ` a2 : oe0 (6). Thanks to Lemma 6.1.4 and (1), we have
(Q) \Gamma , y : oey ` a : oe. By induction hypothesis applied once to (5) and once to (6), we get
(Q) \Gamma  ` `(a1) : oey and (Q) \Gamma , y : oey ` `(a2) : oe0. Thus (Q) \Gamma  ` let y = `(a1) in `(a2) :
oe0 holds by Rule Let. This is equivalent to (Q) \Gamma  ` `(let y = a1 in a2) : oe0, which is
the expected result.

154

6.2 E'quivalence entre le syste`me dirige' par la syntaxe et le syste`me original 155
6.2 Equivalence between the syntax-directed system and

the original system

The equivalence between the syntax-directed (`

O ) and original presentations (`) of

the typing rules is proved by showing the inclusion of `

O in ` first. The inverse inclusion

is not so direct, and we start by proving the equivalence between ` and an intermediate
type system (`0), described below.

Lemma 6.2.1 The system `

O is included in `, that is, if (Q) \Gamma  `O a : oe is derivable,

then (Q) \Gamma  ` a : oe is derivable.

See proof in the Appendix (page 289).

We introduce an auxiliary system `0 composed of the rules of `

O plus rules Gen and

Inst.

Lemma 6.2.2 The system ` is included in `0.

Proof: Indeed, rules Var, Fun, App, Let, and Oracle can be derived using (respectively) Var

O, FunO and Inst, AppO, LetO, and OracleO. Hence, any derivation in the

system ` can be rewritten into a derivation into the system `0.

Lemma 6.2.3 The following rule is admissible :

Strengthen'

(Q) \Gamma  `0 a : oe (Q) \Gamma 0 v \Gamma 

(Q) \Gamma 0 `0 a : oe

The proof is similar to the proof of Rule Strengthen. The details can be found in
the Appendix (page 290).

It remains to be shown that `0 is included in `

O . Intuitively, occurrences of Rule

Gen can be moved up (and absorbed on the way up), whereas occurrences of Rule
Inst can be moved down (and partially absorbed by Rule App).

Definition 6.2.4 The size of a typing derivation in the system `0 is the number of
rules it uses, ignoring the right premise in Rule Let

O.

In the following properties, we show that the system `0 keeps judgments as generalized as possible : Rule Gen can always be merged with other rules.

155

156 Su^rete' du typage
Properties 6.2.5

i) If we have a derivation of (Q) \Gamma  `0 a : oea ending with Rule Gen, then there exists

oe0a and a strictly smaller derivation of (Q) \Gamma  `0 a : oe0a such that oea j oe0a holds.
ii) If we have a derivation of (Q) \Gamma  `0 a : oea, then there exists oe0a such that we have

a derivation of (Q) \Gamma  `0 a : oe0a not using Gen, and such that oea j oe0a hold.
iii) If we have a derivation of (Q) \Gamma  `0 a : oea not using Gen, then there exists oe0a

such that (Q) \Gamma  `

O a : oe0

a and (Q) oe0a v oea holds.

See proof in the Appendix (page 290).

Thanks to these properties, it is now possible to state the equivalence between the
syntax-directed system and the original system :

Lemma 6.2.6 (Syntax-Directed Typings) We have (Q) \Gamma  ` a : oe iff there exists
oe0 such that (Q) \Gamma  `

O a : oe0 and (Q) oe0 v oe.

Proof: If there exists oe0 such that (Q) \Gamma  `

O a : oe0 and (Q) oe0 v oe (1) hold, then

(Q) \Gamma  ` a : oe0 is derivable by Lemma 6.2.1, thus (Q) \Gamma  ` a : oe is derivable by Rule Inst
and (1). Conversely, if (Q) \Gamma  ` a : oe holds, then there exists a derivation of (Q) \Gamma  `0 a : oe
by Lemma 6.2.2. We get the expected result by Lemmas 6.2.5.ii and 6.2.5.iii, then.

Example 6.2.12 As we claimed in the introduction, a *-bound variable that is used
polymorphically must be annotated. Let us check that *(x) x x is not typable in MLF
by means of contradiction. A syntax-directed type derivation of this expression would
be of the form :

Fun

O

App

O

Var

O (Q) x : o/0 `O x : o/0 (Q) x : o/0 `O x : o/0 VarO

(Q) o/0 v 8 (Q0) o/2 ! o/1 (2) (Q) o/0 v 8 (Q0) o/2 (1)

(Q) x : o/0 `

O x x : 8 (Q0) o/1

(Q) ; `

O *(x) x x : 8 (ff >= 8 (Q0) o/1) o/0 ! ff

By rules I-Drop?, (2), and (1), we get respectively (QQ0) o/0 v o/2 ! o/1 and (QQ0)
o/0 v o/2. Then (QQ0) o/2 ! o/1 j o/2 follows by Lemma 2.1.6 and R-Trans. Thus, by
Property 1.5.11.vii, there exists a substitution ` such that `(o/2) = `(o/2 ! o/1), that is,
`(o/2) = `(o/2) ! `(o/1), which is impossible.

This example shows the limit of type inference, which is actually the strength of our
system ! We maintain principal types by rejecting examples where type inference would
need to guess second-order types.

156

6.3 Su^rete' du typage 157
Example 6.2.13 Let us recover typability by introducing an oracle and building a
derivation for *(x) (x : ?) x. Taking (ff = oeid) for Q and ff for o/0, we obtain :

App

O

Oracle

O

Var

O (Q) x : ff `O x : ff

(Q) ff A- oeid (3)
(Q) x : ff `

O (x : ?) : oe

id (Q) x : ff `

O x : ff VarO

(Q) oeid v ff ! ff

Fun

O (Q) x : ff `

O (x : ?) x : ff

`

O *(x) (x : ?) x : 8 (ff = oe

id) ff ! ff

The oracle plays a crucial role in (3)--the revelation of the type scheme oeid that is the
bound of the type variable ff used in the type of x. We have (Q) oeid v ff, indeed, but
the converse relation does not hold, so Rule Inst cannot be used here to replace ff by
its bound oeid. Chapter 8 shows how an explicit annotation (x : oeid) can replace the
oracle (x : ?).

6.3 Type safety

Of course, type soundness cannot hold without some assumptions relating the static
semantics of constants described by the initial typing context \Gamma 0 and their dynamic
semantics. To ease the presentation, we introduce a relation `\Gamma  between programs for
any typing environment \Gamma  extending \Gamma 0 : we write a `\Gamma  a0 if and only if every typing
of a under \Gamma , i.e. every pair (Q, oe) such that (Q) \Gamma  ` a : oe holds, is also a typing of
a0. A relation R on programs preserves typings under \Gamma  whenever it is a sub-relation
of `\Gamma . Then showing subject-reduction for a given reduction relation R under a typing
environment \Gamma  amounts to showing that R preserve typings under \Gamma .

We now introduce the three hypotheses that the constants are required to validate.

Definition 6.3.1 (Hypotheses) We assume that the following properties hold for
constants.

(H0) (Arity) Each constant c 2 dom(\Gamma 0) has a closed type \Gamma 0(c) of the form 8 (Q)

o/1 ! . . . o/|c| ! o/ and such that (8 (Q) o/ )/ffl is not in {!, ?} whenever c is a
constructor.

(H1) (Subject-Reduction) All ffi-rules preserve typings. That is (ffi) is a sub-relation

of `\Gamma , for any \Gamma  extending \Gamma 0.

(H2) (Progress) Any expression a of the form f v1 . . . v|f|, such that (Q) \Gamma  ` a : oe is

in the domain of (ffi).

157

158 Su^rete' du typage
The first hypothesis (H0) links the dynamic arity |c| of a constant c to its type. Intuitively, a constant of arity n must have a type with exactly n arrows, no more. The
second hypothesis (H1) simply states subject-reduction for each constant. The third
hypothesis (H2) is progress for primitives, that is, when a primitive f is applied to |f |
arguments, it must reduce to a value.

The language MLF? is parameterized by a set of primitives and constants that satisfy
the hypotheses above. These hypotheses are sufficient to ensure type safety, which we
prove by a combination of subject-reduction, next, and progress. In MLF and MLF?,
subject reduction holds only under \Gamma 0 (actually, under any closed typing environment
extending \Gamma 0). This means that reduction is only allowed at top-level, and not under a
*-abstraction. As a counterexample, consider the expression *(x) (x : ?) x. It is typable
in MLF?. However, if we allowed reduction under *-abstractions, we could use Rule (?)
to reduce the above expression to *(x) (x x : ?), which is not typable in MLF?. It is
typable in UMLF, though, adding an implicit oracle on the first occurrence of x. We see
that subject reduction does not hold under any context in MLF?. This is why subject
reduction is stated only under under the initial typing environment \Gamma 0 (which may
contain any closed bindings, though). Conversely, subject reduction does hold under
any typing environment in UMLF. This means that partial reduction is not possible in
MLF because it would lose type information needed for type inference. However, it is
possible in UMLF where oracles are implicit. We formalize this by giving two statements
for subject reduction.

Theorem 2 (Subject reduction) Reduction preserves typings in UMLF, and preserve typings under \Gamma 0 in MLF?.

Proof: We must show that (-!) is a subrelation of (`\Gamma ) in UMLF and a subrelation
of (`\Gamma 0) in MLF?. We proceed by case analysis on the different reduction rules. In each
case, by hypothesis, we have an expression a1 that reduces to a2 and a derivation of
(Q) \Gamma  ` a1 : oe (1). We must show that (Q) \Gamma  ` a2 : oe holds (2). By Lemma 6.2.6 and (1),
we have a derivation in the syntax-directed system, that is, we have (Q) \Gamma  `

O a

1 : oe0 (3)

with (Q) oe0 v oe (4). It suffices to show that (Q) \Gamma  ` a2 : oe0 (5) holds. Indeed, (2) then

holds by Inst and (4). We show either (2) or (5), depending which one is easier. We

note that the rules (?) and (??) make no sense in UMLF (indeed, since oracles can be
implicitly inserted, these reduction rules have no effect). Hence, we consider the cases

(?) and (??) only in MLF?, which imply that the typing environment is \Gamma 0.

ffi Case ffi : The judgment (2) holds by hypothesis (H1).
ffi Case filet : The reduction is let x = v in a -! a[v/x], and we know by (3) that the
judgment (Q) \Gamma  `

O let x = v in a : oe0 holds. The derivation must end as follows :

(Q) \Gamma  `

O v : oe

1 (Q) \Gamma , x : oe1 `

O a : oe0

(Q) \Gamma  `

O let x = v in a : oe0 Let

O

158

6.3 Su^rete' du typage 159

Applying the Substitutivity Lemma (Lemma 6.1.5), we get (Q) \Gamma  `

O a[v/x] : oe0, which is

the expected result (5).

ffi Case fiv : The reduction is (*(x) a) v -! a[v/x], and we know that the judgment
(Q) \Gamma  `

O (*(x) a) v : oe0 holds. By definition of `O , there must exist Q

1, Q2, o/ , o/1, o/2, oe1,

oe2, and ff such that this derivation is of the form :

Fun

O (QQ1) \Gamma , x : o/ `

O a : oe

1 (9) dom(Q1) " \Gamma  = ;

(Q) \Gamma  `

O *(x) a : 8 (Q

1, ff >= oe1) o/ ! ff (Q) \Gamma  `

O v : oe

2 (8)

(Q) 8 (Q1, ff >= oe1) o/ ! ff v 8 (Q2) o/2 ! o/1 (7) (Q) oe2 v 8 (Q2) o/2 (6).

(Q) \Gamma  `

O (*(x) a) v : 8 (Q

2) o/1

App

O

Here oe0 is 8 (Q2) o/1. Let Q01 be the prefix (Q1, ff >= oe1). Without lost of generality,
we can assume ff /2 dom(Q) (otherwise, we rename ff). This implies Q01 # Q ; besides
dom(Q01) # ftv(\Gamma ) (10) since \Gamma  must be closed under Q by well-formedness of (8). We can
also assume dom(Q01) = dom(Q01/o/ ! ff) (11) (otherwise Q01 contains useless binders
that can be freely removed). We get a derivation of (QQ01) \Gamma , x : o/ ` a : ff (12) by
Corollary 6.1.3, Inst and I-Hyp applied to (9). From (7), we get (Q) 8 (Q01) o/ ! ff v
8 (Q2) o/2 ! o/1 (13). Applying Lemma 3.4.4 to (13), there exists a substitution ` and
an alpha-conversion of 8 (Q2) o/2 ! o/1, written 8 (Q02) o/ 02 ! o/ 01 such that (QQ02) `(o/ !
ff) j o/ 02 ! o/ 01 (14) and QQ01 vI QQ02` (15), where I = dom(Q) [ dom(Q01/o/ ! ff)
and dom(`) ` dom(Q01/o/ ! ff) (16). Note that ftv(\Gamma ) ` dom(Q) (17) hold by wellformedness of (8). From (15) and (11), we get QQ01 v QQ02` (18). Hence, by Rule
Weaken, (12), and (18), we get (QQ02`) \Gamma , x : o/ ` a : ff. By Strengthen, and observing
that (QQ02`) oe0 j `(oe0) holds by Eq-Mono for any oe0, we get the judgment (QQ02`)
`(\Gamma ), x : `(o/ ) ` a : ff. By Gen, we get (QQ02) `(\Gamma ), x : `(o/ ) ` a : 8 (`) ff. By Inst and
(QQ02) 8 (`) ff j `(ff), it leads to (QQ02) `(\Gamma ), x : `(o/ ) ` a : `(ff) (19). From (14) and
Property 1.5.11.viii (page 56), we get (QQ02) `(o/ ) j o/ 02 and (QQ02) `(ff) j o/ 01. Hence,
by Strengthen and Inst on (19), we get (QQ02) `(\Gamma ), x : o/ 02 ` a : o/ 01 (20). By (16)
and (10), we get dom(`) # dom(Q). Hence, by (17), we get `(\Gamma ) = \Gamma . Then, from (20)
we have the judgment (QQ02) \Gamma , x : o/ 02 ` a : o/ 01 (21). From (6), we get (Q) oe2 v 8 (Q02) o/ 02
by alpha-conversion. Hence, (QQ02) oe2 v o/ 02 (22) holds by Property 1.7.2.iii (page 60)
and I-Drop?. From (8) and Corollary 6.1.3 (page 153), we get (QQ02) \Gamma  ` v : oe2. By
Inst and (22), we get (QQ02) \Gamma  ` v : o/ 02 (23). Hence, applying the Substitutivity Lemma
(Lemma 6.1.5) to (21) and (23), we get (QQ02) \Gamma  ` a[v/x] : o/ 01 (24). Moreover, we have
dom(Q02) # ftv(\Gamma ) from (17), so that applying Rule Gen to (24) leads to (Q) \Gamma  ` a[v/x] :
8 (Q02) o/ 01, that is, by alpha-conversion (Q) \Gamma  ` a[v/x] : 8 (Q2) o/1. This is the expected
result.

ffi Case (?) : The reduction is (v1 : ?) v2 -! (v1 v2 : ?) and a is (v1 : ?) v2. As explained
above, this case concerns only MLF? ; it cannot occur in UMLF. As a consequence, the
typing environment we consider is the initial typing environment \Gamma 0. By hypothesis
(H0), \Gamma 0 is closed, that is, ftv(\Gamma 0) = ;. Applying repeatedly Rule Gen to (1), we get
(;) \Gamma 0 ` (v1 : ?) v2 : 8 (Q) oe. By Lemma 6.2.6, we have a derivation of (;) \Gamma 0 `

O (v

1 :

?) v2 : 8 (Q0) o/1 such that 8 (Q0) o/1 v 8 (Q) oe (25). This derivation necessarily ends

159

160 Su^rete' du typage

with the following rules :

App

O

Oracle

O

(;) \Gamma 0 `

O v

1 : oe1 (31)

oe1 v oe001 (30) oe01 @- oe001 (29)

(;) \Gamma 0 `

O (v

1 : ?) : oe01 (;) \Gamma 0 `

O v

2 : oe2 (28)

oe01 v 8 (Q0) o/2 ! o/1 (27) oe2 v 8 (Q0) o/2 (26)

(;) \Gamma 0 `

O (v

1 : ?) v2 : 8 (Q0) o/1

The relations between types, above, can be represented by the following diagram :

oe01 8 (Q0) o/2 ! o/1

oe1 oe001v

(30) @-

(29)

v(27)

Applying the Diamond Lemma (Lemma 2.8.4) to the above diagram, we know that there
exists oe3 such that the following holds :

oe01 8 (Q0) o/2 ! o/1

oe1 oe001 oe3v

(30)

@-

v(27)

@-(32)v(
33)

We can freely assume that oe3 is in normal form. By Property 2.1.3.ii (page 66) and (32),
we conclude that oe3 is of the form 8 (Q3) o/ 02 ! o/ 01. By Lemma 3.6.11 and (32), 8 (Q0) o/2 @-
8 (Q3) o/ 02 (34) and 8 (Q0) o/1 @- 8 (Q3) o/ 01 (35) hold. By Rule Inst, (31), (30), and (33) we
get (;) \Gamma 0 ` v1 : 8 (Q3) o/ 02 ! o/ 01 (36). By Rule Inst, (28), (26), and (34), we can derive
(;) \Gamma 0 ` v2 : 8 (Q3) o/ 02 (37). Consequently, by Rule App?, (36) and (37), (;) \Gamma 0 ` v1 v2 :
8 (Q3) o/ 01 holds. Finally, by Oracle and (35), we get (;) \Gamma 0 ` (v1 v2 : ?) : 8 (Q0) o/1.
By (25) and Inst, we get (;) \Gamma 0 ` (v1 v2 : ?) : 8 (Q) oe, that is, (;) \Gamma 0 ` a0 : 8 (Q) oe. By
Corollary 6.1.3 (page 153), we get (Q) \Gamma 0 ` a0 : 8 (Q) oe. Besides, (Q) 8 (Q) oe v oe holds
by I-Drop?. Hence, (Q) \Gamma 0 ` a0 : oe holds by Inst. This is the expected result (2).

ffi Case (??): This case concerns only MLF?, thus the typing environment is \Gamma 0. We
have a derivation of (Q) \Gamma 0 ` ((a0 : ?) : ?) : oe. As in the previous case (?), we have
(;) \Gamma 0 ` ((a0 : ?) : ?) : 8 (Q) oe by Gen. By Lemma 6.2.6, we have a derivation of
(;) \Gamma 0 `

O ((a

0 : ?) : ?) : oe0 (38), with oe0 v 8 (Q) oe (39). The derivation of (38) is

necessarily of the form

Oracle

O

Oracle

O (;) \Gamma 0 `

O a

0 : oe3 (40) (;) oe3 v oe4 (;) oe1 @- oe4

(;) \Gamma 0 `

O (a

0 : ?) : oe1 (;) oe1 v oe2 (;) oe0 @- oe2

(;) \Gamma 0 `

O ((a

0 : ?) : ?) : oe0

160

6.3 Su^rete' du typage 161

We can represent the relation between these polytypes by the solid arrows in the following
diagram :

oe0

oe1 oe2
oe3 oe4 oe5v

(41)

@-

v

@-(42)

v(43)

@-(44)

By the Diamond Lemma 2.8.4, there exists oe5 such that the relations represented by
the dotted arrows hold. By R-Trans, (41), and (43), we get oe3 v oe5 (45). By RTrans, (42), and (44), we get oe0 @- oe5 (46). Hence, by (40), Oracle

O, (45), and (46),

we get (;) \Gamma 0 `

O (a0 : ?) : oe0. By Inst and (39), we get (;) \Gamma 0 ` (a0 : ?) : 8 (Q) oe. By

Corollary 6.1.3 (page 153), Inst and I-Drop?, we can derive (Q) \Gamma 0 ` (a0 : ?) : oe. This
is the expected result (2).

ffi Case Context: The hypothesis is a -! a0. We know that (;) \Gamma  ` E[a] : oe0 holds.
We must show that (Q) \Gamma  ` E[a0] : oe (2) also holds. The proof is immediate by structural
induction on E:

The second step in showing type safety consists of showing progress.
Theorem 3 (Progress) Any expression a such that we have (Q) \Gamma 0 ` a : oe is a value
or can be further reduced.

Proof: We reason by induction on the structure of a.

ffi Case x : This is not possible, since \Gamma 0 does not bind any variable.
ffi Case c : Then a is a value.
ffi Case *(x) a : Then a is a value.
ffi Case let x = a1 in a2 : Necessarily, a1 is typable in the typing environment \Gamma 0. By
induction hypothesis, either a1 is a value or it can be further reduced. In either case, a
can be further reduced (by Rule filet or by Rule Context).

ffi Case a1 a2 Necessarily, a1 and a2 are also well-typed in (Q), \Gamma 0. Thus, by induction
hypothesis, either a1 can be further reduced (and so can a) or a1 is a value. We continue
with the second case. In turn, either a2 can be further reduced and so can a or it is also
a value. We continue with the second case and reason on the structure of a1 :

Subcase (w : ?) : then a can be reduced by (?).
Subcase *(x) a0 : then a can be reduced by fiv.
Subcase f v1 . . . vn with n < |f | : then either n + 1 < |f | and a is a value, or
n + 1 = |f | and a can be reduced by hypothesis (H2) for constants.

161

162 Su^rete' du typage

Subcase C v1 . . . vn with n <= |C| : By Lemma 6.2.6, we have a typing derivation of
(Q) \Gamma 0 `

O a

1 : oe. This derivation starts with Var

O and uses AppO repeatedly, once for

each vi. Let oei be the type given to C v1 . . . vi in the ith Rule App

O. Let oe0 be \Gamma (C).

We show by induction on the number of rules App

O, that (8 (Q) oei)/2|C|-i is neither !,

nor ?.
- This result holds for i = 0 by hypothesis (H0).
- Assuming the result holds for i, we show it also holds for i + 1 : By Rule App

O, we

have (Q) oei v 8 (Q0) o/2 ! o/1 and oei+1 is 8 (Q0) o/1. By Property 2.1.3.ii (page 66),
(8 (QQ0) o/2 ! o/1)/2|C|-i is neither !, nor ?. Hence, (8 (QQ0) o/1)/2|C|-(i+1) is neither
!, nor ?, which is the expected result.
By induction, the result holds for all i 2 0..|C|. If n is |C|, then (8 (Q) oen)/ffl is neither !
nor ? (1). Besides, Rule App

O is used to type a1 a2, which implies that (Q) oen v 8 (Q0)

o/2 ! o/1 (2) holds for some Q0, o/2 and o/1. We have a contradiction between (1), (2), and
Property 2.1.3.ii. Hence n cannot be |C|. Thus, a is a value.

ffi Case (a0 : ?) : Necessarily, a0 is well-typed. By induction hypothesis, either a0 is a
value or it can be further reduced. In the latter case, a can be reduced by Rule Context.
In the former case, a0 is either a value of the form w, and a is a value, or it is a value v
of the form (w : ?). Then a can be reduced by (??).

Combining theorems 2 and 3 ensures that the reduction of well-typed programs
either proceeds forever or ends up with a value. This holds for programs in MLF? but
also for programs in MLF, since MLF is a subset of MLF?. Hence MLF is also sound.
However, MLF does not enjoy subject reduction, since reduction may create oracles.
Notice, however, that oracles can only be introduced by ffi-rules.

162

163
Chapitre 7
Infe'rence de types

Comme mentionne' auparavant, l'infe'rence dans MLF? est probablement aussi difficile
que l'infe'rence totale pour Syste`me F, car les oracles ne fournissent aucune information
de type sur l'annotation attendue a` leur emplacement. Heureusement, un programme
MLF mentionne des annotations de type, qui sont des primitives, au lieu des oracles.
Dans ce chapitre, nous donnons un algorithme d'infe'rence pour MLF, que nous prouvons correct et complet. Il est inte'ressant de noter que nous ne conside'rons pas les
annotations de type dans ce chapitre car elles ne sont que des primitives, et le type
des primitives est toujours connu par le biais de l'environnement de typage initial \Gamma 0.
Ainsi, l'algorithme d'infe'rence n'a pas a` deviner le polymorphisme, mais se contente de
propager les informations de type. C'est la raison pour laquelle il est simple, et surtout
il est complet.

7.1 Type inference algorithm

Figure 7.1 defines the type-inference algorithm WF for MLF. The algorithm follows
the algorithm W for ML [Mil78], with only two differences : first, the algorithm builds a
prefix Q instead of a substitution ; second, all free type variables not in \Gamma  are quantified
at each abstraction or application. Since free variables of \Gamma  are in dom(Q), finding
quantified variables consists of splitting the current prefix according to dom(Q), as
described by Definition 3.5.1.

Definition 7.1.1 A pair (Q0, oe0) is an instance of a pair (Q, oe) under interface I if we
have (Q, ff >= oe) vI[{ff} (Q0, ff >= oe0) for any ff not in dom(Q) [ dom(Q0).

A type inference problem is a triple (Q, \Gamma , a), where all free type variables in \Gamma  are
bound in Q. A pair (Q0, oe) is a solution to this problem if Q v Q0 and (Q0) \Gamma  ` a : oe

163

164 Infe'rence de types

Fig. 7.1 - Algorithm WF
The algorithm infer (Q, \Gamma , a) is defined by cases on expression a :
Case x : return Q, \Gamma (x)
Case *(x) a :

* let Q1 = (Q, ff >= ?) with ff /2 dom(Q)

* let (Q2, oe) = infer (Q1, (\Gamma , x : ff), a)

* let fi /2 dom(Q2) and (Q3, Q4) = Q2" dom(Q)

* return Q3, 8 (Q4, fi >= oe) ff ! fi

Case a b :

* let (Q1, oea) = infer (Q, \Gamma , a)

* let (Q2, oeb) = infer (Q1, \Gamma , b)

* let ffa, ffb, fi /2 dom(Q2)

* let Q3 = unify ((Q2, ffa >= oea, ffb >= oeb, fi >= ?), ffa, ffb ! fi)

* let (Q4, Q5) = Q3" dom(Q)

* return (Q4, 8 (Q5) fi)

Case let x = a1 in a2 :

* let (Q1, oe1) = infer (Q, \Gamma , a1)

* return infer (Q1, (\Gamma , x : oe1), a2)

holds. A solution of a type inference problem (Q, \Gamma , a) is principal if all other solutions
are instances of the given one, under interface dom(Q).

7.2 Soundness of the algorithm
Lemma 7.2.1 (Soundness of type inference) The algorithm W F is sound ; that is,
for any Q, \Gamma , and a, if infer (Q, \Gamma , a) returns a pair (Q0, oe), then we have :

Q v Q0 (Q0) \Gamma  ` a : oe

Proof: By structural induction on a.

ffi Case x : We have Q0 = Q and oe = \Gamma (x), thus the result is immediate by Rule Var.
ffi Case *(x) a : Let Q1 be (Q, ff >= ?) and (Q2, oe) be infer (Q1, \Gamma , x : ff, a). By
induction hypothesis, we have Q1 v Q2 and (Q2) \Gamma , x : ff ` a : oe (1). Let (Q3, Q4)
be Q2" dom(Q). We have Q2 j Q3Q4 (2) by Lemma 3.5.2. Hence, by Weaken, (2),
and (1), we have (Q3Q4) \Gamma , x : ff ` a : oe. By Rule Fun

O, we get (Q3) \Gamma  ` *(x) a :

8 (Q4, fi >= oe) ff ! fi, which is the expected result. Moreover, we have Q j Q1 v Q2 j
Q3Q4 jdom(Q1) Q3. Hence Q v Q3 holds.

164

7.3 Comple'tude de l'algorithme 165

ffi Case a b : Let (Q1, oea) be infer (Q, \Gamma , a) and (Q2, oeb) be infer (Q1, \Gamma , b). By
induction hypothesis, we have Q v Q1 v Q2 (1) and (Q1) \Gamma  ` a : oea (2) as well as
(Q2) \Gamma  ` a : oeb (3). Hence, by Weaken on (2) and (1), we have (Q2) \Gamma  ` a : oea (4).
Let Q0 be (Q2, ffa >= oea, ffb >= oeb, fi >= ?). By rules Weaken, Inst and I-Hyp applied
once to (3) and once to (4), we get (Q0) \Gamma  ` a : ffa (5) and (Q0) \Gamma  ` b : ffb (6). Let
Q3 be unify (Q0, ffa, ffb ! fi). By Lemma 4.4.1, we have Q0 v Q3 (7) and (Q3) ffa j
ffb ! fi (8). Let (Q4, Q5) be Q3" dom(Q). We have Q3 j Q4Q5 (9) by Lemma 3.5.2.
By Weaken, (7), once on (5) and once on (6), we have (Q3) \Gamma  ` a : ffa (10) and
(Q3) \Gamma  ` b : ffb. By Inst applied to (8) and (10), we get (Q3) \Gamma  ` a : ffb ! fi (11). By
Rule App, we get (Q3) \Gamma  ` a b : fi. By Weaken applied to (9), we get (Q4Q5) \Gamma  ` a b : fi.
Since ftv(\Gamma ) ` dom(Q) ` dom(Q4), we get by Rule Gen (Q4) \Gamma  ` a b : 8 (Q5) fi, which is
the expected result. Moreover, we have Q v Q1 v Q2 j Q0 v Q3 j Q4Q5 jdom(Q) Q4.
Hence, Q v Q4 holds.

ffi Case let x = a1 in a2 : Let (Q1, oe1) be infer (Q, \Gamma , a1). By induction hypothesis,
we have Q v Q1 (1) and (Q1) \Gamma  ` a1 : oe1 (2). Let (Q2, oe2) be infer (Q1, \Gamma , x : oe1, a2).
By induction hypothesis, we have Q1 v Q2 (3) and (Q2) \Gamma , x : oe1 ` a2 : oe2 (4). By Rule
Weaken, (2), and (3), we have (Q2) \Gamma  ` a1 : oe1 (5). Rule Let applies on (5) and (4)
and gives (Q2) \Gamma  ` let x = a1 in a2 : oe2. Moreover, by PI-Trans on (1) and (3), we
have Q v Q2. This is the expected result.

7.3 Completeness of the algorithm
Lemma 7.3.1 (Completeness of type inference) The algorithm W F is complete,
that is, if there exists a solution to a type inference problem (Q, \Gamma , a), then the algorithm
infer (Q, \Gamma , a) succeeds and returns a principal solution.

Proof: Let I be dom(Q). By hypothesis and Lemma 6.2.6, we have a solution (Q2, oe2),
that is (Q2) \Gamma  `

O a : oe

2and Q v Q2 (1) hold. Note that dom(Q) ` dom(Q2) (2)

holds. We have to show that infer (Q, \Gamma , a) succeeds and returns (Q1, oe1) such that

(Q1, fl > oe1) vI[{fl} (Q2, fl > oe2) (3). The proof is by induction on the structure of a.
We proceed by case analysis on the last rule of the derivation of (Q2) \Gamma  `

O a : oe

2.

ffi Case Var : Then a is a variable x, oe2 is \Gamma (x) and infer (Q, \Gamma , a) succeeds and
returns (Q, \Gamma (x)). Hence, oe1 = oe2 and Q1 = Q. Then (3) holds by Property 3.4.2.iii
(page 106) and (1).

ffi Case Fun: Then a is *(x) a0. By hypothesis, (Q2Q02) \Gamma , x : o/0 `

O a0 : oe0

2 (4) and

dom(Q02) " ftv(\Gamma ) = ; hold, and oe2 is 8 (Q02, fi >= oe02) o/0 ! fi (5). Let ff be a fresh

type variable outside dom(Q2Q02). We have (Q2Q02, ff = o/0) \Gamma , x : ff `

O a0 : oe0

2 (6) byCorollary 6.1.3 (page 153),

Strengthen, and (4). We can derive (Q, ff>=?) v (Q2Q02, ff=

o/0) (7) from (1) by Property 3.4.2.iii (page 106) and rules PE-Free, PI-ContextL, and I-Nil. By induction hypothesis on (6) and (7), infer (Q, ff > ?, \Gamma , x : ff, a0)
succeeds with (Q01, oe01) such that (Q01, fl >= oe01) vI[{ff,fl} (Q2Q02, ff = o/0, fl >= oe02) (8)

165

166 Infe'rence de types

holds. Let (Q3, Q4) be Q01" dom(Q). We note that the prefixes (Q3, (Q4, fl >= oe01)) and
(Q01, fl >= oe01)" dom(Q) are equal (9) by Definition 3.5.1 and since fl /2 dom(Q). Remember
that I is a shorthand for dom(Q). By Lemma 3.6.13 applied to (8), (9), and (2), and
taking o/ = ff ! fl, we get

(Q3, fl0 >= 8 (Q4, fl >= oe01) ff ! fl) vI[{fl

0} (Q

2, fl0 >= 8 (Q02, ff = o/0, fl >= oe02) ff ! fl) (10)

The algorithm returns (Q3, 8 (Q4, fl >= oe01) ff ! fl), that is, Q1 is Q3 and oe1 is 8 (Q4, fl >=
oe01) ff ! fl). Additionally, from (5), Eq-Mono? and ff-conversion, oe2 is equivalent to
8 (Q02, ff = o/0, fl >= oe02) ff ! fl. Then (10) is equivalent to

(Q1, fl0 >= oe1) vI[{fl

0} (Q

2, fl0 >= oe2)

This is the expected result.

ffi Case Let : We have a of the form let x = a1 in a2. By hypothesis, we have (Q2)
\Gamma  `

O a

1 : oe0 and (Q2) \Gamma , x : oe0 `

O a

2 : oe2 (11). By induction hypothesis, infer (Q, \Gamma , a)

succeeds and returns (Q3, oe3) such that (Q3, fl >=oe3) vI[{fl} (Q2, fl >=oe0). By Lemma 3.6.2

(page 114), there exists a renaming OE and a substitution ` both invariant on I [ {fl}, as
well as a prefix Q00 such that we have (Q3, fl >= oe3) v (OE(Q2, fl >= oe0)`Q00) (12). Besides,
we have dom(Q00) # dom((Q3, fl >= oe3)/I [ {fl}), that is, dom(Q00) # fl [ dom(Q3/I [
ftv(oe3)) (13). By Property 3.4.2.i (page 106), (12), and PE-Free, Q3 v (OE(Q2, fl >=
oe0)`Q00) (14) holds. From (11), we get (Q2, fl >= oe0) \Gamma , x : oe0 ` a2 : oe2 by Corollary 6.1.3
(page 153). Hence, by Lemma 6.1.1, we get (OE(Q2, fl >= oe0)) OE(\Gamma , x : oe0) ` a2 : OE(oe2).
Since OE is disjoint from I, OE is invariant on \Gamma , thus this rewrites to (OE(Q2, fl >= oe0))
\Gamma , x : OE(oe0) ` a2 : OE(oe2). By Corollary 6.1.3 (page 153), we have (OE(Q2, fl >= oe0)`Q00)
\Gamma , x : OE(oe0) ` a2 : OE(oe2) (15). We can derive (Q3, fl >= oe3) oe3 v fl (16) by I-Hyp.
From (12), (16), and Lemma 3.6.4, we get (OE(Q2), fl >= OE(oe0), `Q00) oe3 v fl. By (13), we
have fl /2 dom(Q00) and dom(Q00) # ftv(oe3). Hence, by R-Context-R and Eq-Free, we
get (OE(Q2), fl >=OE(oe0)), `(oe3) v `(fl). Observing that `(fl) is fl and that fl /2 ftv(`(oe3)) (by
well-formedness of (12)), we get (OE(Q2)) `(oe3) v OE(oe0) by R-Context-R, Eq-Free,
and Eq-Var. By Property 1.7.2.iii (page 60), we get (OE(Q2, fl >= oe0)`Q00) `(oe3) v OE(oe0).
By Eq-Mono, we get (OE(Q2, fl >= oe0)`Q00) oe3 v OE(oe0). By Strengthen on (15), we get
(OE(Q2, fl >= oe0)`Q00) \Gamma , x : oe3 ` a2 : OE(oe2) (17). By induction hypothesis applied to (17)
and (14), infer (Q3, \Gamma , x : oe3, a2) succeeds with (Q01, oe1) such that (Q01, fl0 >= oe1) vI[{fl

0}

(OE(Q2, fl >= oe0)`Q00, fl0 >= OE(oe2)) (18). We note that ftv(oe2) 2 dom(Q2) by well-formedness
of (11). Hence, ftv(OE(oe2)) 2 dom(OE(Q2)) (19). We have

(OE(Q2, fl >= oe0)`Q00, fl0 >= OE(oe2))
j (OE(Q2, fl0 >= oe2, fl >= oe0)`Q00) by (19) and Eq-Comm
jI[{fl

0} (OE(Q

2, fl0 >= oe2)) by Eq-Free

jI[{fl

0} (OE(Q

2, fl0 >= oe2))OE by Eq-Free

jI[{fl

0} (Q

2, fl0 >= oe2) by Property 3.4.2.iv (page 106)

Hence, (OE(Q2, fl >=oe0)`Q00, fl0 >=OE(oe2)) jI[{fl

0} (Q

2, fl0>=oe2) holds, and we get the expected

result from (18), that is,

(Q01, fl0 >= oe1) vI[{fl

0} (Q

2, fl0 >= oe2)

166

7.3 Comple'tude de l'algorithme 167

ffi Case App: By hypothesis, we have

(Q2) \Gamma  `

O a

1 : oea (20) (Q2) \Gamma  `

O a

2 : oeb (21) (Q2) oea v 8 (Q3) o/2 ! o/1 (22)

(Q2) oeb v 8 (Q3) o/2 (23) oe2 = 8 (Q3) o/1
Let ffa, ffb, fi be fresh variables. Let Ia be I [ {ffa}, and Ib be I [ {ffb}. By induction hypothesis, (20), and (1), infer (Q,\Gamma , a1) succeeds and returns (Qa, oe0a) such that
(Qa, ffa >= oe0a) vIa (Q2, ffa >= oea) holds. By Lemma 3.6.2 (page 114), there exists a renaming OEa and a substitution `a, both invariant on Ia, as well as Q00 such that we
have (Qa, ffa >= oe0a) v (OEa(Q2, ffa >= oea)`aQ00) (24) holds. Moreover, we have dom(Q00) #
dom(Qa/I [ ftv(oe0a)) (25). We have Qa v (OEa(Q2, ffa >= oea)`aQ00) (26) from (24) and
PE-Free. Let I0 be dom(Qa) (27). By Lemmas 6.1.1 and 6.1.3, and by (21), we get
(OEa(Q2, ffa >= oea)`aQ00) \Gamma  ` a2 : OEa(oeb) (28). Hence, by induction hypothesis, (26)

and (28), infer (Qa, \Gamma , a2) succeeds and returns (Qb, oe0b) such that (Qb, ffb>=oe0b) vI

0[{ff

b}

(OEa(Q2, ffa >= oea)`aQ00, ffb >= OEa(oeb)) (29) holds. Let OE0 be a renaming of ffa to a fresh
variable ff0a (that is, not in the domain or in the free variables of Q1, Q2, OEa, `a, Q00). Let
`0a be the substitution extracted from OE0(`a) and Q000 be OE0(Q000 ). We remark from (21)
that ftv(oeb) ` dom(Q2). Hence, ftv(OEa(oeb)) ` dom(OEa(Q2)) (30), thus ffa /2 ftv(OEa(oeb)).
As a consequence, OE ffi OEa(oeb) = OEa(oeb) (31). By Property 3.4.2.iv (page 106) (using the
renaming OE), and (31), we get (OEa(Q2, ffa >= oea)`aQ00, ffb >= OEa(oeb)) jI

0[{ff

b} (OEa(Q2, ff0a >=

oea)`0aQ000, ffb >= OEa(oeb))OE (32). Additionally, ffa was chosen such that ffa /2 I0 [ {ffb} (33).
Hence, by PE-Free, (32), and (33), we get

(OEa(Q2, ffa >= oea)`aQ00, ffb >= OEa(oeb)) jI

0[{ff

b} (OEa(Q2, ff0a >= oea)`0aQ000, ffb >= OEa(oeb))

With (29) and PI-Trans, we get

(Qb, ffb >= oe0b) vI

0[{ff

b} (OEa(Q2, ff0a >= oea)`0aQ000, ffb >= OEa(oeb))

Observing that we have utv(oe0a) ` I0 from (24) and (27), we get by Property 3.4.2.iii
(page 106)

(Qb, ffb>=oe0b, ffa>=oe0a, fi>=?) vI

0[{ff

b,ffa,fi} (OEa(Q2, ff0a>=oea)`0aQ000 , ffb>=OEa(oeb), ffa>=oe0a, fi>=?)

By Property 3.4.2.i (page 106), we get
(Qb, ffb >=oe0b, ffa >=oe0a, fi >=?) vI[{ffb,ffa} (OEa(Q2, ff0a >=oea)`0aQ000, ffb >=OEa(oeb), ffa >=oe0a, fi >=?)
Let Q4 be (Qb, ffa >= oe0a, ffb >= oe0b, fi >= ?), J be I [ {ffb, ffa, fi}, and P4 be (OEa(Q2, ff0a >=
oea)`0aQ000, ffb >= OEa(oeb), ffa >= oe0a, fi >= ?). The above relation can be written

Q4 vJ P4 (34)
We have (Qa, ffa >= oe0a) oe0a v ffa, thus by Lemma 3.6.4 applied to (24), we can derive
(OEa(Q2, ffa >= oea)`aQ00) oe0a v ffa. Observing that ffa /2 ftv(oe0a), we get (OEa(Q2, ff0a >=
oea)`0aQ000) oe0a v ff0a by Property 1.7.2.i (page 60). Hence, we have

P4 v (OEa(Q2, ff0a >= oea)`0aQ000, ffb >= OEa(oeb), ffa = ff0a, fi >= ?) (35)

167

168 Infe'rence de types

and we write P5 for the right-hand side. By PE-Swap and PE-Commut, using (30), we
get

P5 j (OEa(Q2), ffa >= OEa(oea), ffb >= OEa(oeb), fi >= ?, ff0a = ffa, `0aQ000) (36)
and we write P6 for the right-hand side. By Property 1.7.2.i (page 60) applied to (22)
and (23), we get (OEa(Q2)) OEa(oea) v OEa(8 (Q3) o/2 ! o/1) and (OEa(Q2)) OEa(oeb) v OEa(8 (Q3)
o/2). Hence, we can derive

P6 v (OEa(Q2), ffa >= OEa(8 (Q3) o/2 ! o/1), ffb >= OEa(8 (Q3) o/2), fi >= ?, ff0a = ffa, `0aQ000) (37)
and we write P7 for the right-hand side. By PE-Free and I-Drop? (twice on OEa(Q3)),
we can derive

P7 v (OEa(Q2Q3), ffa = OEa(o/2 ! o/1), ffb = OEa(o/2), fi >= ?, ff0a = ffa, `0a) (38)
and we write P8 for the right-hand side. Finally, by Property 3.4.2.iv (page 106) and
I-Bot, we get

P8 vJ (Q2Q3, ffa = o/2 ! o/1, ffb = o/2, fi = o/1) (39)
Let Q6 be (Q2Q3, ffa = o/2 ! o/1, ffb = o/2, fi = o/1). By (34), (35), (36), (37), (38), and (39),
we get Q4 vJ Q6. Moreover, we have (Q6) ffa j ffb ! fi by lemma 1.5.10.

By completeness of unification, (Lemma 4.6.2), unify (Q4) ffa .= ffb ! fi succeeds and
returns Q5 such that we have Q5 vJ Q6. Let (Q7, Q8) be Q5" dom(Q). By hypothesis,
I = dom(Q), and I ` dom(Q2). By Lemma 3.6.13, we have a derivation of

(Q7, fl >= 8 (Q8) fi) vI[{fl} (Q2, fl >= 8 (Q3) o/1)
This is the expected result.

ffi Case Oracle cannot appear since type inference is only performed in MLF, not in
MLF?.

7.4 Decidability of type inference
Lemma 7.4.1 The type inference algorithm always terminates, either by failing or by
returning a prefix and a type scheme.

Proof: By induction on the size of the expression being typed. All cases are straightforward, using Lemma 4.5.5 for the termination of unify.

Thanks to Lemmas 7.2.1 and 7.3.1, the type inference algorithm is proved sound
and complete. Additionally, the algorithm always terminates by Lemma 7.4.1. Hence,
the following theorem :

168

7.4 De'cidabilite' de l'infe'rence 169
Theorem 4 (Type inference) The set of solutions of a solvable type inference problem admits a principal solution. Given any type inference problem, the algorithm W F
either returns a principal solution or fails if no solution exists.

169

170 Infe'rence de types
170

171
Chapitre 8
Annotations de type

Dans ce chapitre, nous nous restreignons a` MLF, c'est-a`-dire aux expressions qui
ne contiennent pas d'oracles. Puisque les expressions de MLF sont exactement celles
de ML, la seule diffe'rence re'side dans les types plus riches et les re`gles de typage.
Toutefois, ces diffe'rences ne suffisent pas a` rendre le polymorphisme de premie`re classe
accessible, puisque MLF sans annotations de type et ML sont e'quivalents. Ce re'sultat est
montre' dans la section ci-dessous. Les sections suivantes introduisent les annotations
de type comme des primitives et montrent comment les utiliser pour introduire du
polymorphisme.

8.1 MLF without type annotations

In the following, we write vML for the ML generalized instance relation. It allows
instantiation of quantified variables with any monotype and immediate generalization
of freshly introduced variables. We define it as follows :

8 ( _ff) oe vML 8 ( _fi) oe[_o/ /_ff] holds if and only if _fi is disjoint from ftv(oe).
The following property is standard in ML :
Lemma 8.1.1 If we have 8 (_ff) o/1 vML 8 ( _fi) o/2, then for any o/ such that ftv(o/ ) # _ff
and ftv(o/ ) # _fi, we have 8 ( _ff) o/ [o/1/fl] vML 8 ( _fi) o/ [o/2/fl]

Proof: By definition, we have _fi # ftv(o/1), and o/2 = o/1[_o/ /_ff] (1). By hypothesis, we have_
fi # ftv(o/ ), thus _fi # ftv(o/ [o/1/fl]). As a consequence, we have 8 (_ff) o/ [o/1/fl] vML 8 ( _fi)
o/ [o/1/fl][_o//_ff]. By hypothesis, we have _ff # ftv(o/ ) (2). We get the expected result by
observing that 8 ( _fi) o/ [o/1/fl][_o//_ff] is equal to 8 ( _fi) o/[o/2/fl] by (1) and (2).

171

172 Annotations de type

Polytypes that do not contain rigid bindings are said to be flexible. Let flex be the
function defined on polytypes and prefixes that transforms every rigid binding into a
flexible binding. For instance, flex (8 (ff = oe1, fi >= oe2) oe) is 8 (ff >= flex (oe1), fi >= flex
(oe2)) flex (oe). We say that a derivation is flexible if it does not contain any rigid
bindings in types or in the prefix. A judgment is flexible if it has a flexible derivation.

Properties 8.1.2

i) If (Q) oe1 j oe2, then (flex (Q)) flex (oe1) j flex (oe2) is flexible.
ii) If (Q) oe1 @- oe2, then (flex (Q)) flex (oe1) v flex (oe2) is flexible.
iii) If (Q) oe1 v oe2, then (flex (Q)) flex (oe1) v flex (oe2) is flexible.

Proof: For each property, by induction on the derivation. Equivalence and Instance cases
are easy. As for the abstraction relation, the cases A-Hyp and R-Context-Rigid are replaced by (respectively) I-Hyp and R-Context-Flexible. Finally, I-Rigid is replaced
by Eq-Refl and I-Equiv?.

We lift the function flex to typing environments and typing judgments in the natural
way. This operation is correct in the following sense :

Lemma 8.1.3 If (Q) \Gamma  ` a : oe holds in MLF, then so does flex ((Q) \Gamma  ` a : oe).

Proof: By induction on the derivation of (Q) \Gamma  ` a : oe. Case Var is immediate. Cases
App, Fun and Let are by induction hypothesis. Case Inst is by Property 8.1.2.iii. Case
Gen: We have (Q) \Gamma  ` a : 8 (ff \Pi  oe1) oe2, and the premise is (Q, ff \Pi  oe1)` a : oe2, with
ff /2 ftv(\Gamma ). Note that ff /2 ftv(flex (\Gamma )). By induction hypothesis, (flex (Q), ff >= flex
(oe1)) flex (\Gamma ) ` a : flex (oe2) holds. Hence, (flex (Q)) flex (\Gamma ) ` a : 8 (ff >= flex
(oe1)) flex (oe2) holds by Gen. By definition, this means (flex (Q)) flex (\Gamma ) ` a : flex
8 (ff \Pi  oe1) oe2. This is the expected result.

Definition 8.1.4 We define the ML approximation hhoeii of an MLF flexible type oe as
follows :

hh?ii = 8 (ff) ff hho/ ii = o/ hhoeii = 8 (Q) o/hh8 (ff >= oe) oe0ii = 8 (Q) hhoe0ii[o/ /ff]
We extend hh*ii to prefixes by returning a pair of an unconstrained prefix and a substitution :

hh;ii = ;, id hhoeii = 8 (Q1) o/1 hhQ

0ii = Q2, `2

hh(ff \Pi  oe, Q0)ii = Q1Q2, [o/1/ff] ffi `2

172

8.1 MLF sans annotations 173
Note that ML types are invariant by hh*ii. Indeed, we have hh8 ( _ff) o/ ii = 8 ( _ff) o/ . Note
also that if hhoeii is 8 (Q) o/ , then Q is unconstrained.

Properties 8.1.5

i) For any oe and any substitution `, we have hh`(oe)ii = `(hhoeii).
ii) The following implications hold :

hhQii = Q0, `
hh8 (Q) oeii = 8 (Q0) `(hhoeii)

hhQ1ii = Q01, `1 hhQ2ii = Q02, `2

hhQ1Q2ii = Q01Q02, `1 ffi `2

iii) We have hhoeii/ = oe/ for any oe.

iv) If oe j o/ holds, then hhoeii = 8 (Q) o/ with dom(Q) # ftv(o/ ).

v) If hhQii is (Q0, `), then there exists `0 such that ` is `0 ffi bQ.
vi) If (Q) oe1 v oe2 is flexible, and hhQii = (Q0, `), then `(hhoe1ii) vML `(hhoe2ii) holds.

See proof in the Appendix (page 293).

We lift hh*ii to typing environments in the obvious way.
Lemma 8.1.6 If we have a flexible derivation of (Q) \Gamma  ` a : oe, then we have a
derivation of `(hh\Gamma ii) ` a : `(hhoeii) in ML, where hhQii is Q0, `.

Proof: By induction on the derivation. Case Var is immediate. Cases Fun, App, and
Let are by induction hypothesis. Case Inst is a direct consequence of Property 8.1.5.vi.
Case Gen: The premise is (Q, ff \Pi  oe1) \Gamma  ` a : oe2. Let 8 (Q1) o/1 be hhoe1ii, and `1 be
[o/1/ff]. We chose Q1 such that dom(Q1) # ftv(\Gamma ) (1). By Property 8.1.5.ii, we have
hh(Q, ff \Pi  oe1)ii = Q0Q1, ` ffi `1. By induction hypothesis, we have ` ffi `1(hh\Gamma ii) `ML a : ` ffi
`1(hhoe2ii). Since ff /2 ftv(\Gamma ), we have `1(hh\Gamma ii) = hh\Gamma ii. Hence, `(hh\Gamma ii) `ML a : ` ffi `1(hhoe2ii
holds. From (1), we get by Rule Gen of ML, `(hh\Gamma ii) `ML a : 8 (Q1) ` ffi `1(hhoe2ii). This
is `(hh\Gamma ii) `ML a : `(8 (Q1) `1(hhoe2ii)). This is the expected result, by observing that
hh8 (ff \Pi  oe1) oe2ii is 8 (Q1) `1(hhoe2ii).

Corollary 8.1.7 If an expression a is typable under a flexible typing environment \Gamma  in
MLF, then a is typable under hh\Gamma ii in ML.

Proof: Direct consequence of Lemmas 8.1.6 and 8.1.3.

The inverse inclusion has already been stated in Section 5.2.1. In the particular
case where the initial typing context \Gamma 0 contains only ML types, a closed expression
can be typed in MLF under \Gamma 0 if and only if it can be typed in ML under \Gamma 0. This is
not true for MLF? in which the expression *(x) (x : ?) x is typable. Indeed, as shown
in Chapter 9, all terms of System F can be typed in MLF?.

173

174 Annotations de type
8.2 Introduction to type annotations

The following example, which describes a single annotation, should provide intuition
for the general case.

Example 8.2.14 Let f be a constant of type oe = 8 (ff = oeid, ff0 >= oeid) ff ! ff0 with the
ffi-reduction f v -! (v : ?). Then the expression a defined as *(x) (f x) x behaves like
*(x) x x and is well-typed, of type 8 (ff = oeid) ff ! ff. To see this, let Q and \Gamma  stand
for (ff = oeid, ff0 >= oeid) and x : ff. By rules Inst, Var, and App (Q) \Gamma  ` f x : ff0 holds ;
hence by Rule Gen, we get (ff=oeid) \Gamma  ` f x : 8 (ff0 >=oeid) ff0 since ff0 is not free in \Gamma . By
Rule Eq-Var, we have 8 (ff0 >= oeid) ff0 j oeid (under any prefix) ; besides, oeid v ff ! ff
holds under any prefix that binds ff. Thus, we get (ff = oeid) \Gamma  ` f x : ff ! ff by Rule
Inst. The result follows by rules App, Fun, and Gen.

Observe that the static effect of f in f x is (i) to force the type of x to be abstracted
by a type variable ff bound to oeid in Q and (ii) to allow f x, that is x, to have the
type oeid, exactly as the oracle (x : ?) would. Notice that the bound of ff in oe is rigid :
the function f expects a value v that must have type oeid, and not an instance of oeid.
Conversely, the bound of ff0 is flexible : the type of f v is oeid but may also be any
instance of oeid.

Note that a behaves as the auto-application function *(x) x x (when applied to
the same value, reduction steps of the latter can be put in correspondence with major
reduction steps of the former), which is not typable (see Example 6.2.12).

8.3 Annotation primitives
Definition 8.3.1 We call annotations the denumerable collection of unary primitives
(9 (Q) oe), defined for all prefixes Q and polytypes oe closed under Q. The initial typing
environment \Gamma 0 contains these primitives with their associated type :

(9 (Q) oe) : 8 (Q) 8 (ff = oe) 8 (fi >= oe) ff ! fi 2 \Gamma 0
We may identify annotation primitives up to the equivalence of their types.
Besides, we write (a : 9 (Q) oe) for the application (9 (Q) oe) a. We also abbreviate
(9 (Q) oe) as (oe) when all bounds in Q are unconstrained. Actually, replacing an annotation (9 (Q) oe) by (oe) preserves typability and, more precisely, preserves typings.

Note the difference between (9 (Q) oe) and (8 (Q) oe). The latter would require the
argument to have type 8 (Q) oe while the former only requires the argument to have
type oe under some prefix Q0 to be determined from the context.

174

8.3 Les annotations comme primitives 175
Example 8.3.15 As seen in Example 6.2.12, *(x) x x is not typable in MLF. We also
claimed that it would be typable with annotations. We give a typing derivation for
*(x) let y = (x : oeid) in y y. We write a for this expression and oea for 8 (ff = oeid)
8 (ff0 >= oeid) ff ! ff0.

Let

(ff = oeid) \Gamma , x : ff ` (x : oeid) : oeid (2)
(ff = oeid) \Gamma , x : ff, y : oeid ` y y : oeid (1)

Fun (ff = oe

id) \Gamma , x : ff ` let y = (x : oeid) in y y : oeid

Gen (ff = oe

id) \Gamma  ` a : 8 (ff0 >= oeid) ff ! ff0

(;) \Gamma  ` a : oea

The judgment (1) can be easily derived, since y is known to have the polymorphic
type oeid. The key point of this derivation is how we get the judgment (2). That is,
having x : ff in the typing environment, and (ff = oeid) in the prefix, how can we derive
(Q) \Gamma  ` (x : oeid) : oeid ? Here is the derivation, writing Q for (ff = oeid) :

App
Inst (Q) \Gamma  ` (oe

id) : 8 (ff1 = oeid) 8 (ff2 = oeid) ff1 ! ff2

(Q) \Gamma  ` (oeid) : 8 (ff2 = oeid) ff ! ff2 (Q) \Gamma  ` x : ff

(Q) \Gamma  ` (x : oeid) : oeid

The instantiation simply shares ff1 with ff in the prefix (rules A-Hyp and R-ContextRigid).

While annotations have been introduced as primitives for simplicity of presentation,
they are obviously meant to be applied. Notice that the type of an annotation may be
instantiated before the annotation is applied. However, the annotation keeps exactly the
same "revealing power" after instantiation. This is described by the following technical
lemma (the reader may take ; for Q0 at first).

Lemma 8.3.2 We have (Q0) \Gamma  ` (a : 9 (Q) oe) : oe0 iff there exists a type 8 (Q0) oe01
such that (Q0) \Gamma  ` a : 8 (Q0) oe01 holds together with the following relations :

Q0Q v Q0Q0 (Q0Q0) oe01 A- oe (Q0) 8 (Q0) oe v oe0
The prefix Q of the annotation 9 (Q) oe may be instantiated into Q0. However, Q0
guards oe01 A- oe in (Q0Q0) oe01 A- oe. In particular, the lemma would not hold with
(Q0) 8 (Q0) oe01 A- 8 (Q00) oe and (Q0) 8 (Q00) oe01 v oe0. Lemma 8.3.2 has similarities with
Rule Annot of Poly-ML [GR99].
See proof in the Appendix (page 295).

175

176 Annotations de type
Corollary 8.3.3 The judgment (Q) \Gamma  ` (a : ?) : oe0 holds iff there exists an annotation
(oe) such that (Q) \Gamma  ` (a : oe) : oe0 holds.

See proof in the Appendix (page 296).
Hence, all expressions typable in MLF? are typable in MLF as long as all annotation
primitives are in the initial typing context \Gamma 0. Conversely, the annotation (9 (Q) oe) can
be simulated by *(x) (x : ?) in MLF?, both statically and dynamically. Hence annotation
primitives are unnecessary in MLF?.

Reduction of annotations The ffi-reduction for annotations just replaces explicit
type information by oracles.

(v : 9 (Q) oe) -! (v : ?)

Lemma 8.3.4 (Soundness of type annotations) Type annotation primitives validate the required hypotheses H0 (arity), H1 (subject-reduction), and H2 (progress).

See proof in the Appendix (page 296).

Syntactic sugar As mentioned earlier, *(x : oe) a is syntactic sugar for *(x) let x =
(x : oe) in a. The derived typing rule is :

Fun?

(Q) \Gamma , x : oe ` a : oe0 Q0 v Q

(Q) \Gamma  ` *(x : 9 (Q0) oe) a : 8 (ff = oe) 8 (ff0 >= oe0) ff ! ff0

This rule is actually simpler than the derived annotation rule suggested by Lemma 8.3.2,
because instantiation is here left to each occurrence of the annotated program variable
x in a.

The derived reduction rule is (*(x : 9 (Q) oe) a) v fi

?-! let x = (v : 9 (Q) oe) in a.

Indeed, values must then be extended with expressions of the form *(x : 9 (Q) oe) a.

176

177
Troisie`me partie
Expressivite' de MLF

177

179
Nous avons vu que les programmes ML pouvaient e^tre e'crits dans MLF sans annotations. Dans le chapitre 9, nous donnons une traduction compositionnelle tre`s simple des
termes de Syste`me F vers MLF. Dans le chapitre 10, nous identifions un sous-syste`me
de MLF, appele' Shallow MLF, dont la version sans let est exactement l'image de l'encodage de Syste`me F. Nous donnons une interpre'tation des types de Shallow MLF qui
permet de transformer chaque typage dans Shallow MLF en un ou plusieurs typages
dans le Syste`me F, e'tablissant ainsi une e'quivalence entre le Syste`me F et Shallow MLF.
Au chapitre 11 nous conside'rons des extensions de MLF, notamment les re'fe'rences et la
propagation des annotations de type. Le chapitre 12 met le langage MLF a` l'e'preuve en
conside'rant quelques exemples de programmes utilisant le polymorphisme de premier
ordre.

179

180
180

181
Chapitre 9
Encodage de Syste`me F dans MLF

Dans ce chapitre, nous prouvons que le Syste`me F peut e^tre me'caniquement encode'
dans MLF avec les primitives-annotations de type (langage que nous appelons simplement MLF). Nous montrons que la traduction est correcte, c'est-a`-dire que si un terme
est typable dans le Syste`me F, alors sa traduction est typable dans MLF. Ce re'sultat
illustre l'expressivite' de MLF : il montre que l'ensemble des expressions d'ordre supe'rieur
de Syste`me F sont effectivement disponibles dans MLF. De plus, gra^ce aux re'sultats du
chapitre 7, nous savons que les termes traduits contiennent toute l'information ne'cessaire pour permettre l'infe'rence de type. La dernie`re question concerne la concision de
la traduction et son utilite' en MLF : combien d'annotations sont ne'cessaires ? En fait, la
traduction efface syste'matiquement les abstractions de type et les applications de type,
et donc restent seulement les annotations sur les lambda-abstractions. De plus, puisqu'une annotation avec un monotype est inutile en MLF, certaines de ces annotations
sont inutiles. En bref, nous voyons que MLF requiert strictement moins d'information
de types que le Syste`me F. De plus, tous les programmes ML sont typables sans annotations. Ainsi nous supposons que MLF est re'ellement utilisable en pratique : il combine
la concision de ML et la puissance du second ordre de Syste`me F.

Apre`s avoir donne' la de'finition du Syste`me F, nous de'finissons la traduction des
environnement du Syste`me F, ainsi que la traduction des expressions du Syste`me F.
Finalement, nous prouvons la correction de la traduction.

9.1 Definition of System F

The types, terms, and typing contexts of system F are given below :

t ::= ff | t ! t | 8 ff * t Types
M ::= x | M M 0 | *(x : t) M | \Lambda (ff) M | M [t] Terms

A ::= ; | A, x : t | A, ff Typing Contexts

181

182 Encodage de Syste`me F dans MLF

Types are not divided into monotypes and polytypes, as in MLF, and are simply
polymorphic types : the 8 quantifier can appear at any occurrence. Expressions are
either variables such as x, applications M M 0, annotated abstractions *(x : t) M , type
abstractions \Lambda (ff) M , which explicitly bind the type variable ff in the expression M ,
or type applications M [t], which explicitly instantiate the polymorphic type of M , say
8 (ff) t0, by using t, leading to t0[t/ff]. Typing environments bind variables to types, and
bind free type variables. In System F, all type variables must be explicitly introduced.

The typing rules of System F are the following :

F-Var

x : t 2 A

A ` x : t

F-App

A ` a1 : t2 ! t1 A ` a2 : t2

A ` a1 a2 : t1

F-Tapp

A ` a : 8 ff * t

A ` a [t0] : t[t0/ff]

F-Fun

A, x : t ` a : t0

A ` *(x : t) a : t ! t0

F-Tfun

A, ff ` a : t ff /2 A

A ` \Lambda (ff) a : 8 ff * t

We see that polymorphism is explicitly introduced by type abstraction in Rule F-Tfun,
and that it is explicitly instantiated by type application in Rule F-Tapp.

9.2 Encoding types and typing environments

The translation of types of System F into MLF types uses auxiliary rigid bindings
for arrow types. This ensures that there are no inner polytypes left in the result of the
translation, which would otherwise be ill-formed. Quantifiers that are present in the
original types are translated to unconstrained bounds.

[[ff]] = ff [[8 ff * t]] = 8 (ff) [[t]] [[t1 ! t2]] = 8 (ff1 = [[t1]]) 8 (ff2 = [[t2]]) ff1 ! ff2
In order to state the correspondence between typing judgments, we must also translate
typing contexts. The translation of A, written [[A]], returns a pair (Q) \Gamma  of a prefix and
a typing context and is defined inductively as follows :

[[;]] = () ; [[A]] = (Q) \Gamma [[A, x : t]] = (Q) \Gamma , x : [[t]] [[A]] = (Q) \Gamma  ff /2 dom(Q)[[A, ff]] = (Q, ff) \Gamma 
The translation of types enjoys the following property :
Lemma 9.2.1 For any t and t0, we have [[t0[t/ff]]] @- 8 (ff = [[t]]) [[t0]].

Proof: Let oe be [[t]]. We reason by structural induction on t0.

182

9.3 Encodage des expressions 183

ffi Case t0 is ff : The left-hand side is [[t]], that is oe, the right-hand side is 8 (ff = oe) ff.
They are equivalent by Eq-Var. We conclude by A-Equiv.

ffi Case t0 is fi and fi 6= ff : The left-hand side is fi, the right-hand side is 8 (ff = oe) fi.
They are equivalent by Eq-Free, and we conclude by A-Equiv.

ffi Case t0 is 8 fi * t00 : By induction hypothesis, we have [[t00[t/ff]]] @- 8 (ff = oe) [[t00]]. By
notation, this means (Q) [[t00[t/ff]]] @- 8 (ff = oe) [[t00]], where Q is unconstrained and binds
free variables of the judgment. We can freely assume that Q is of the form (Q0, fi >= ?)
(using Lemma 1.6.2 (page 58) if necessary). Hence, by R-Context-R, we get 8 (fi)
[[t00[t/ff]]] @- 8 (fi) 8 (ff = oe) [[t00]] (1). By definition, the left-hand side is [[8 fi * t00[t/ff]]],
i.e. [[t0[t/ff]]]. The right-hand side is equivalent to 8 (ff = oe) 8 (fi) [[t00]] by Eq-Comm, i.e.
8 (ff = oe) [[t0]] by definition of [[*]] and of t0. Hence, (1) gives [[t0[t/ff]]] @- 8 (ff = oe) [[t0]],
which is the expected result.

ffi Case t0 is t1 ! t2: By induction hypothesis, we have [[t1[t/ff]]] @- 8 (ff = [[t]]) [[t1]] and
[[t2[t/ff]]] @- 8 (ff=[[t]]) [[t2]]. which we write oe01 @- 8 (ff=oe) oe1 (2) and oe02 @- 8 (ff=oe) oe2 (3).
We only have to show that 8 (ff1 = oe01) 8 (ff2 = oe02) ff1 ! ff2 @- 8 (ff = oe) 8 (ff1 = oe1)
8 (ff2 = oe2) ff1 ! ff2 holds. This is shown by R-Context-Rigid, (2) and (3), and by
A-Up?.

9.3 Encoding expressions

The translation of System F terms into MLF terms forgets type abstractions and
applications, and translates types inside term abstractions.

[[\Lambda (ff) M ]] = [[M ]] [[M t]] = [[M ]] [[x]] = x [[M M 0]] = [[M ]] [[M 0]]

[[*(x : t) M ]] = *(x : [[t]]) [[M ]]

The soundness of this translation is stated by the following theorem :
Theorem 5 For any closed typing context A (that does not bind the same type variable
twice), term M , and type t of System F such that A ` M : t, there exists a derivation
(Q) \Gamma  ` [[M ]] : oe such that (Q) \Gamma  = [[A]] and [[t]] @- oe hold.

Proof: We reason by induction on the derivation of A ` M : t. Let (Q) \Gamma  be [[A]].

ffi Case F-Var : By hypothesis, we have x : t 2 A. By definition of [[A]], we have
x : [[t]] 2 \Gamma , and \Gamma  is closed under Q. Hence, (Q) \Gamma  ` x : [[t]] holds by Var. This is the
expected result.

ffi Case F-App : We have M = M1 M2 and the premises are A ` M1 : t2 ! t1 and
A ` M2 : t2. By induction hypothesis, we have both (Q) \Gamma  ` [[M1]] : oe (1) and (Q) \Gamma  `
[[M2]] : oe2 (2) with [[t2 ! t1]] @- oe (3) and [[t2]] @- oe2 (4). By definition of [[t2 ! t1]], we
have 8 (ff2 = [[t2]], ff1 = [[t1]]) ff2 ! ff1 @- oe (5) from (3). By (4) and R-Context-Rigid,

183

184 Encodage de Syste`me F dans MLF

we have 8 (ff2 = [[t2]], ff1 = [[t1]]) ff2 ! ff1 @- 8 (ff2 = oe2, ff1 = [[t1]]) ff2 ! ff1 (6). Thus
by Lemma 2.8.2, (5), and (6), there exists a type oe0 such that we have oe @- oe0 (7) and
8 (ff2 = oe2, ff1 = [[t1]]) ff2 ! ff1 @- oe0 (8). We can freely assume that oe0 is in normal form.
By Property 2.1.3.ii (page 66), oe0 is of the form 8 (Q0) o/2 ! o/1 (9). By Inst, (1), (7),
and (9), we get (Q) \Gamma  ` [[M1]] : 8 (Q0) o/2 ! o/1 (10). By Lemma 3.6.11, (8), and (9) we
have oe2 @- 8 (Q0) o/2 (11) as well as [[t1]] @- 8 (Q0) o/1 (12). Consequently, we can derive
(Q) \Gamma  ` [[M2]] : 8 (Q0) o/2 (13) by (11), (2), and Inst. Thus, (Q) \Gamma  ` [[M1]] [[M2]] : 8 (Q0) o/1
holds by App?, (10), and (13). This and (12) are the expected result.

ffi Case F-Tapp : The premise is A ` M : 8 ff * t0. By induction hypothesis, we have
(Q) \Gamma  ` [[M]] : oe (14) where [[8 ff * t0]] @- oe (15). By definition, [[8 ff * t0]] is 8 (ff) [[t0]],
thus (15) is 8 (ff) [[t0]] @- oe. By Lemma 3.6.7, this implies that oe is equivalent to 8 (ff)
oe0 (16) with [[t0]] @- oe0 (17). Let oe0 be 8 (ff = [[t]]) oe0. We have oe v oe0 (18) by (16), RContext-Flexible, and I-Bot. By Rule Inst, (14), and (18) gives (Q) \Gamma  ` [[M ]] : oe0.
Furthermore, we have 8 (ff = [[t]]) [[t0]] @- oe0 (19) by (17) and R-Context-R. We note
that [[t0[t/ff]]] @- 8 (ff = [[t]]) [[t0]] (20) holds by Lemma 9.2.1. Hence, by R-Trans, (20),
and (19), we get [[t0[t/ff]]] @- oe0. This is the expected result.

ffi Case F-Fun: The premise is A, x : t ` a : t0. By induction, we have (Q) \Gamma , x : [[t]] ` a :
oe0, where [[t0]] @- oe0 (21). By Rule Fun?, we have (Q) \Gamma  ` *(x : [[t]]) a : 8 (ff = [[t]], ff0 >= oe0)
ff ! ff0. Let oe00 be 8 (ff = [[t]], ff0 = oe0) ff ! ff0. By Rule Inst, we have (Q) \Gamma  ` a : oe00.
By (21), we have: 8 (ff = [[t]], ff0 = [[t0]]) ff ! ff0 @- oe00, i.e. [[t ! t0]] @- oe00.

ffi Case F-Tfun: The premise is A, ff ` a : t By induction, we have (Q, ff) \Gamma  ` a : oe with
[[t]] @- oe (22). We have ff /2 \Gamma , since ff /2 A. By Rule Gen, we have (Q) \Gamma  ` a : 8 (ff) oe.
From (22), we have 8 (ff) [[t]] @- 8 (ff) oe. That is [[8 ff * t]] @- 8 (ff) oe.

Noticeably, translated terms contain strictly fewer annotations than original terms ;
this property that was not true in Poly-ML. In particular, all type \Lambda -abstractions
and type applications are dropped and only annotations of *-bound variables remain.
Moreover, some of these annotations are still superfluous, since, for instance, removing
monotype annotations preserves typings in MLF.

Remark 9.3.1 System F can be viewed in Curry style, where terms are unannotated,
or in Church style, where terms come with sufficient type information so that full
type information can be uniquely reconstructed. In Church style, terms can be given a
typed semantics. For instance, type abstraction may stop the evaluation just like value
abstractions.

UMLF is somehow the Curry's view. However, there is no exact Church style for
MLF : type abstractions, i.e. places where polymorphism is introduced, are left implicit,
and type applications, i.e. places where polymorphism is used, are inferred. Even terms
with fully annotated *-abstractions can place type-abstraction and type application at
different occurrences.

There is thus no obvious typed semantics for MLF : if the semantics were given on
type derivations, one should then show some coherence property that the semantics is

184

9.3 Encodage des expressions 185
independent of the translation, and in particular on places where type-abstractions or
type-applications would be inserted.

Encodage de Poly-ML

Although not stated formally, terms of Poly-ML [GR99] can be translated to terms
of System F. As a corollary of Theorem 5, terms typable in Poly-ML can also be typed
in MLF. note that all polymorphism-elimination annotations h*i that were mandatory
in Poly-ML are indeed removed in the translation.

185

186 Encodage de Syste`me F dans MLF
186

187
Chapitre 10
Shallow MLF

Le chapitre 9 montre que le Syste`me F peut e^tre encode' dans MLF en effac,ant
simplement les applications de type et les abstractions de type. Ainsi, l'ensemble des
lambda-termes non annote's typables dans le Syste`me F est inclus dans l'ensemble
des lambda-termes typables dans MLF. Inversement, il est le'gitime de se demander si
MLF est strictement plus puissant que le Syste`me F, c'est-a`-dire s'il existe un terme
typable dans MLF dont le lambda-terme associe' (sans annotation) n'est pas typable
dans le Syste`me F. Cela semble e^tre le cas. Plus pre'cise'ment, nous identifions un sousensemble strict de MLF qui est suffisant pour encoder le Syste`me F. Dans ce chapitre,
nous de'crivons ce sous-syste`me appele' Shallow MLF.

10.1 Definition and characterization

In the following, a type of System F is called a System F type. We also introduce a
subset of MLF types, called F-types, which are, intuitively, the translation of System F
types into MLF.

Definition 10.1.1 A type in normal form is an F-type if and only if all its flexible
bounds are unconstrained (that is, of the form (ff >= ?)). A type is an F-type if and
only if its normal form is an F-type.

Types that are not F-types, e.g. 8 (ff >= oe) o/ (1), where oe is equivalent neither to a
monotype nor to ?, have been introduced to factor out choices during type inference.
Such types are indeed used in a derivation of let f = choose id in (f auto) (f succ).
However, they are never used in the encoding of System F. We wish to show that
restricting MLF derivations to use only F-types preserves the encoding of System F.
We do not show this result directly, but first consider a less restrictive subset of types,
called shallow types. Shallow types are a superset of F-types that also allow types

187

188 Shallow MLF
such as (1), except in rigid bounds. Indeed, a rigid bound corresponds intuitively to an
explicit type annotation in the source code. Then restricting rigid bounds to F-types
amounts to restricting type annotations to F-types only. From a practical point of view,
this means that the type annotation primitives available to the programmer are F-types
only. Shallow types are still needed, however, because they are introduced by the type
inference algorithm e.g. in the typing of choose id).

Definition 10.1.2 Let a type in normal form be shallow if and only if all its rigid
bounds are F-types. A type is shallow if and only if its normal form is shallow. A prefix
Q is shallow if and only if 8 (Q) rdom(Q) is shallow.

Since shallowness depends on the binding structure of types, it can be captured by
polynomials, as defined in Section 2.7.2. Actually, polynomial variables X, Y , and
Z correspond respectively to top-level flexible bindings, rigid bindings, and flexible
bindings under rigid bindings. Hence, we expect Z to correspond exactly to the bounds
that are unconstrained in shallow types. which leads to the following definition :

Definition 10.1.3 Let P and P 0 be polynomials in IN [X, Y, Z]. We write P 6Z P 0 if
and only if the maximal degree of variable Z in P is less than or equal to the maximal
degree of variable Z in P 0.

For example, we have X2Y Z 6Z Z2, XY 6Z Y , as well as 1 6Z 0. Note that 6Z is
defined with the maximal degree, hence we have some unusual properties. For instance
we have P1 + P2 6Z P 0 if and only if P1 6Z P 0 and P2 6Z P 0. Moreover, we have
P 6Z P1 + P2 if and only if P 6Z P1 or P 6Z P2.

The shallowness of a type oe can be tested by looking only at the degree of its weight
in variable Z (weights wA were defined page 91), as formalized by Property 10.1.4.ii
below. For example, the type 8 (ff >= oeid, fi = oeid) ff ! fi is shallow, and its polynomial
is X2 + Y Z. Conversely, the type 8 (fi = 8 (ff >= oeid) ff ! ff) fi ! fi is not shallow, and
its polynomial is Y Z 2.

Properties 10.1.4

i) A type oe is an F-type iff wY (oe) 6Z Z.
ii) A type oe is shallow iff wX (oe) 6Z Z.
iii) For any oe, we have wX(oe) 6Z wY (oe).

Proof: Property i : By Property 1.5.6.i and Lemma 2.7.5, we have wY (oe) = wY (nf(oe)).
Moreover, by definition, a type is shallow if and only if its normal form is shallow. As a
consequence, it suffices to show that nf(oe) is an F-type if and only if wY (nf(oe)) 6Z Z.
To ease the presentation, we simply assume that oe is in normal form. We proceed by
case analysis on the form of oe.

ffi Case o/ or ? : Then wY (oe) is 0 or 1, and wY (oe) 6Z Z holds.

188

10.1 De'finition et caracte'risation 189

ffi Case 8 (ff >= oe1) oe2 : Then wY (oe) is wZ(oe1) *Z + wY (oe2) (1). If oe is an F-type, then,
by definition, oe1 is ?, and oe2 is an F-type. Hence, we have wZ (oe1) = 1 by definition and
wY (oe2) 6Z Z (2) by induction hypothesis. This gives wZ (oe1) * Z 6Z Z, which implies
wY (oe) 6Z Z by (1) and (2). Conversely, if wY (oe) 6Z Z holds, then from (1), we have
wZ (oe1) 6Z 1 and wY (oe2) 6Z Z. The former implies that wZ (oe1) is 0 or 1. Hence, oe1
is ? (it cannot be a monotype o/ because oe is in normal form). The latter implies, by
induction hypothesis, that oe2 is an F-type. Hence, oe, that is 8 (ff >= ?) oe2, is an F-type.

ffi Case 8 (ff = oe1) oe2 : Then wY (oe) is wY (oe1) * Y + wY (oe2). Hence, on the one hand,
we have wY (oe) 6Z Z if and only if wY (oe1) 6Z Z and wY (oe2) 6Z Z. On the other hand,
oe is an F-type if and only if oe1 and oe2 are F-types. We conclude by induction hypothesis.

Property ii : By structural induction on oe. As in Property i, we assume that oe is in
normal form.

ffi Case o/ or ? : Then wX (oe) is 0 or 1, and wX (oe) 6Z Z holds.
ffi Case 8 (ff >= oe1) oe2 : Then wX (oe) is wX (oe1) * X + wX(oe2). Hence, on the one hand,
we have wX(oe) 6Z Z if and only if wX (oe1) 6Z Z and wX (oe2) 6Z Z. On the other hand,
oe is shallow if and only if oe1 and oe2 are shallow. We conclude by induction hypothesis.

ffi Case 8 (ff=oe1) oe2 : Then wX (oe) is wY (oe1)*Y +wX(oe2). Hence, we have wX (oe) 6Z Z
if and only if wY (oe1) 6Z Z and wX (oe2) 6Z Z. We conclude by induction hypothesis
and Property i.

Property iii : By structural induction on oe.

These properties provide a convenient way to characterize F-types and shallow
types. It remains to define Shallow MLF as a subset of MLF : Recall that MLF (with
type annotations) is a type system that allows all MLF-types as annotations and in
derivations. Additionally, MLF? allows the guessing of type annotations thanks to Rule
Oracle.

Definition 10.1.5 (Shallow MLF) We define Shallow MLF as the subset of MLF
where type annotations are restricted to F-types and derivations can only mention
shallow types. Similarly, Shallow MLF? is the subset of MLF? where derivations can
only mention shallow types and Rule Oracle can only be used with F-types.

As mentioned earlier, restricting type annotations to F-types amounts to restricting
the type of the annotation primitive to a shallow type. Indeed, the type annotation
primitive (oe) (we assume oe is closed) has type 8 (ff1 = oe) 8 (ff2 = oe) ff1 ! ff2. This
type is shallow if and only if oe is an F-type.

We have given an encoding of System F into MLF in Chapter 9. In the next section,
we show that this encoding is actually an encoding into Shallow MLF. That is, not
only the type annotations are F-types (which is obvious), but the typing derivations
themselves are actually shallow. This means that Shallow MLF, though it is a subset
of MLF, is sufficient to provide all the expressiveness of System F.

189

190 Shallow MLF
10.2 Expressiveness of Shallow MLF

It is immediate to check that the translation of System F types are F-types. Hence,
the encoding of a term of System F gives a term whose type annotations are F types.
Besides, the encoding of a typing environment is a pair composed of a shallow typing
environment and an unconstrained prefix. As a consequence, we expect the typing
derivation of the encoding to be shallow. The main result of this section gives a stronger
result (it is not restricted to translations of System F terms) : Lemma 10.2.3 states
that if a term is typable in MLF under a shallow typing environment and a shallow
prefix, then it is typable in Shallow MLF. The next lemma is a preliminary result which
implies that an abstraction of an F-type is also an F-type.

Lemma 10.2.1 If (Q) oe1 @- oe2 holds, then so does wY (oe2) 6Z wY (oe1).
See proof in the Appendix (page 296).

Our goal is to show that a shallow typable term admits a shallow derivation. Actually, the inference and unification algorithms are "shallow-stable", that is, when given
shallow terms (resp. types), they return shallow derivations (resp. types). This implies
that the principal type of a shallow term is a shallow type. We formalize the above
result for the unification algorithm, after having stated two useful properties.

Properties 10.2.2

i) If Q is shallow, then 8 (Q) o/ is shallow.
ii) If Q is shallow and (Q1, Q2) = Q" _ff, then Q1 and Q2 are shallow.
iii) If Q is shallow and Q0 = unify (Q, o/1, o/2), then Q0 is shallow.

iv) If Q, oe1, and oe2 are shallow, and (Q0, oe3) = polyunify (Q, oe1, oe2), then Q0 and

oe3 are shallow.

Proof: Properties i and ii are easily shown by structural induction on Q. We prove
properties iii and iv simultaneously by induction on the recursive calls to the algorithms.
All cases are easy, except the case unify (Q, ff1, ff2), where (ff1 \Pi 1 oe1) and (ff2 \Pi 2 oe2) are
in Q. In this case, we call polyunify as follows : (Q0, oe3) = polyunify (Q, oe1, oe2). By
induction hypothesis Q0 and oe3 are shallow. Besides, without loss of generality, Q0 is of
the form (Q1, ff1 \Pi 1 oe1, Q2, ff2 \Pi 2 oe2, Q3). We note that Q1, Q2, and Q3 are shallow. We
return Q00 defined as (Q1, ff1 \Pi  oe3, Q2, ff2 = ff1, Q3), where \Pi  is rigid if and only if \Pi 1 or
\Pi 2 is rigid. If \Pi  is flexible, then Q00 is shallow by construction, and the case is solved.
Otherwise, \Pi  is rigid, which means that \Pi 1 or \Pi 2 is rigid. We show the result for \Pi 1 rigid,
the other case being similar. The update algorithm calls the abstraction-check algorithm,
which ensures that (Q0) oe1 @- oe3 holds. By hypothesis, (ff1 = oe1) is in Q and Q is shallow,
thus oe1 must be an F-type. By Lemma 10.2.1 and Property 10.1.4.i, oe3 is an F-type too.
Hence, Q00 is shallow.

190

10.3 Comparaison avec le Syste`me F 191

We can now state the main result of the section : a shallow term typable in MLF is
typable in Shallow MLF.

Lemma 10.2.3 If Q, \Gamma , and a are shallow, and (Q) \Gamma  ` a : oe holds in MLF for some
oe, then there exists a shallow derivation of (Q) \Gamma  ` a : oe0 for some shallow type oe0.

Proof: By completeness of the type inference algorithm, we know that infer (Q, \Gamma , a)
succeeds. We show by induction on the recursive calls to infer that if Q, \Gamma , and a are
shallow, and Q0, oe is infer (Q, \Gamma , a), then Q0 and oe are shallow. All cases are easy, using
Property 10.2.2.iii for the application case.

As a conclusion, if a shallow term a is typable in MLF, under a shallow prefix and a
shallow typing environment, then it admits a derivation in Shallow MLF. In that case,
it is noticeable that the inference algorithm returns a shallow principal type. As a first
corollary, subject reduction holds in Shallow MLF since it holds in MLF. As a second
corollary, the encoding given for System F also holds in Shallow MLF. Hence we have
shown the inclusion System F ` Shallow MLF (considering only type erasure of terms).
The next section covers the converse inclusion : is Shallow MLF included in System F ?

10.3 Comparison with System F
10.3.1 Introduction

An immediate issue prevents Shallow MLF from being compared to System F :
Let-bindings. Usually, a let-binding let x = a1 in a2 in encoded as (*(x) a2) a1.
We note that let-bindings do not increase expressiveness in MLF or MLF?, since the
above encoding can always be used, inserting explicit type annotations or oracles if
necessary. For example, let oe be the type 8 (ff >= oeid) ff ! ff. Then the expression
let x = choose id in a can be encoded as (*(x : oe) a) (choose id) in MLF, or as
(*(x : ?) a) (choose id) in MLF?. The same property is not true for Shallow MLF,
since shallow-types that are not F-types cannot be used as annotations. Indeed, the
principal type given to choose id, namely oe, is a shallow type but not a F-type.
Hence, whereas let x = choose id in a is in Shallow MLF, its natural encoding as a
*-abstraction is not in Shallow MLF.1 Therefore, we also have to consider the restriction
Shallow F of Shallow MLF to programs without let-bindings. The encoding of System F
into MLF given in Section 9.1 is actually an encoding into Shallow F, by considering
*(x : oe) a as syntactic sugar for *(x) a[(x : oe)/x] instead of *(x) let x = (x : oe) in a.
Similarly, *(x : ?) a is syntactic sugar for *(x) a[(x : ?)/x]. Hence, we have the inclusion

1This does not imply that the type erasure of the encoding is not in Shallow MLF. See the comparison
between MLF and System F in Section 10.4 for more details about this issue.

191

192 Shallow MLF
System F ` Shallow F, considering only the type erasure of terms. We wish to show
the converse inclusion : the type erasure of terms typable in Shallow F, that is in
Shallow MLF without Let-binding, is included in the type erasure of terms typable in
System F.

10.3.2 Preliminary results about System F

Types of System F are written with letter t. We recall that types of Shallow MLF
are written oe in general, and o/ when they are monotypes. We implicitly consider that a
monotype o/ is in Shallow MLF as well as in System F. We define below the projection
of an F-type (which is a type in MLF) into a System F type : Given an F-type oe in
normal form, we define oe as its projection into an F-type :

?

M= 8 ff * ff o/ M= o/ 8 (ff = oe) oe0 M= oe0[oe/ff] 8 (ff >= ?) oe M= 8 ff * oe

As for the general case, oe is nf(oe). As mentioned above, we consider that o/ is in
System F, thus we have o/ = o/ .

Next, we formalize the instance relation of System F, which we write vF . We use it
to define the function fsub (t) as the set of all instances of t. The relation vF is defined
as follows :

8 _ff * t vF 8 _fi * t[_t/ _ff] holds if and only if _fi is disjoint from ftv(t).
We define fsub (t) as {t0 | t vF t0}.

We also extend the function proj() (defined page 42) to System F types. This function takes a System F type and returns a skeleton.

proj(ff)

M= ff proj(t1 ! t2) M= proj(t1) ! proj(t2) proj(8 ff * t) M= proj(t)[?/ff]

We write oe 6/ t for oe/ 6/ t/.

We can now state a few properties. In the following, we write S for a set of types
of System F. We define 8 ff * S as the set {8 ff * t | t 2 S}, and fsub (S) is the setS

t2S fsub (t). We use the letter ` for substitutions in System F. It should be clear from
the context if a given substitution ` is a substitution in System F or in Shallow MLF.

Substitutions are implicitly capture-avoiding. We note that [(8 fi * fi ! fi)/ff] is a valid
substitution in System F. It is not the case in Shallow MLF or in MLF, where only
monotype substitutions are allowed. We write `(S) for the set {`(t) | t 2 S}.

Properties 10.3.1

i) We have ftv(oe) = ftv(oe).
ii) We have `(fsub (S)) ` fsub (`(S)).
iii) We have 8 ff * fsub (S) ` fsub (8 ff * S).

iv) If fsub (S1) = fsub (S2), then fsub (8 _ff * S1) = fsub (8 _ff * S2).

v) We have fsub (`(t)) = fsub (`(fsub (t))).

192

10.3 Comparaison avec le Syste`me F 193

Proof: Property i : Straightforward structural induction on oe.
Property ii : Let t be in `(fsub (S)). By definition, there exists t1 2 S and t2 such that
t1 vF t2 (1) and t = `(t2). Then we get `(t1) vF `(t2) from (1), that is, `(t1) vF t.
Hence, t 2 fsub (`(S)).

Property iii : Let t be in 8 ff * fsub (S). By definition, t is of the form 8 ff * t0 for some
System F type t0 and there exists t00 in S such that t00 vF t0 (1). Then 8 ff * t00 vF 8 ff * t0
holds from (1), that is 8 ff * t00 vF t. Hence, t 2 fsub (8 ff * S).

Property iv : We have fsub (S1) ` fsub (S2). Prefixing both sets with 8ff, we get the
inclusion 8 ff * fsub (S1) ` 8 ff * fsub (S2). Applying fsub (), we get fsub (8 ff * fsub (S1)) `
fsub (8 ff * fsub (S2)) (1). By Property iii, we have 8 ff * fsub (S2) ` fsub (8 ff * S2). Hence,
we get fsub (8 ff * fsub (S1)) ` fsub (fsub (8 ff * S2)) from (1). This happens to be equivalent
to fsub (8 ff * fsub (S1)) ` fsub (8 ff * S2) (2). Additionally, we have S1 ` fsub (S1), thus
fsub (8 ff * S1) ` fsub (8 ff * fsub (S1)) holds. Then, fsub (8 ff * S1) ` fsub (8 ff * S2) holds
from (2). By symmetry, we get fsub (8 ff * S1) = fsub (8 ff * S2).

Property v : We have t 2 fsub (t). Hence, `(t) is in the set `(fsub (t)), which implies that
fsub (`(t)) ` fsub (`(fsub (t))) (1) holds. Conversely, we show that fsub (`(fsub (t))) `
fsub (`(t)) holds. Let t1 be in fsub (`(fsub (t))). By definition, there exists t2 such that
t vF t2 (2) and `(t2) vF t1 (3). Then `(t) vF `(t2) (4) holds from (2). Thus `(t) vF t1
holds by (4) and (3). This means that t1 is in fsub (`(t)). As a conclusion, we have
fsub (`(fsub (t))) ` fsub (`(t)) (5). By (1) and (5), we get fsub (`(t)) = fsub (`(fsub (t))).

The next definition captures the idea that a set S depends only on a given set
of type variables. For example, given a type t, consider the set S defined as fsub (t).
Since S is generated only from t, it can depend only on the free variables of t. As a
consequence, if the type fi ! fi is in S, and fi is not free in t, this means that fl ! fl
is also in S for any fl. Actually, we can even expect t0 ! t0 to be in S, for any type
t0. This is captured by the following definition (think of _ff as the set of type variables
used to generate the set S) :

Definition 10.3.2 We say that a set of types S is _ff-stable if and only if for any
substitution ` invariant on _ff, we have `(S) ` S.

We note that if S is _ff-stable, then it is also ( _ff [ _fi)-stable. We defined \Sigma _ff page 103
as the set of MLF-types whose unbound variables are included in _ff. We now define \Sigma ~_ff
as the set of System F types whose free variables are disjoint from _ff. The notation
S1 =_ff S2, defined next, intuitively means that the sets S1 and S2 are equal, except for
some "uninteresting" types that mentions variables in _ff. Formally, we write S1 =_ff S2

193

194 Shallow MLF
if S1 " \Sigma ~_ff = S2 " \Sigma ~_ff holds. We write S1 `_ff S2 if S1 " \Sigma ~_ff ` S2 " \Sigma ~_ff holds. We note
that S1 =_ff S2 holds if and only if S1 `_ff S2 and S1 `_ff S2 hold. Additionally, S1 =; S2
means S1 = S2.

Properties 10.3.3

i) If S is _ff-stable, then fsub (S) is _ff-stable.
ii) The set fsub (t) is ftv(t)-stable.
iii) If S is _ff-stable and _fi-stable, then it is (_ff " _fi)-stable.

iv) If S1 and S2 are _ff-stable, _ff # _fi, and S1 ` _fi S2, then S1 ` S2.

v) If S1 and S2 are _ff-stable, _ff # _fi, and S1 = _fi S2, then S1 = S2.
vi) If we have S1 `_ff[{ff} S2 for all ff in an infinite set I, then S1 `_ff S2 holds.
vii) If we have S1 =_ff[{ff} S2 for all ff in an infinite set I, then S1 =_ff S2 holds.
viii) If we have S1 `_ff S2, then fsub (S1) `_ff fsub (S2) holds.

ix) If we have S1 =_ff S2, then fsub (S1) =_ff fsub (S2) holds.

x) If we have _ff # codom(`) and S1 =_ff S2, then `(S1) =_ff `(S2).

See proof in the Appendix (page 297).

Thanks to these properties about sets of System F types, we are ready to introduce
the interpretation of Shallow MLF types as sets of System F types.

10.3.3 Encoding shallow types into System F

Shallow types are more expressive than types of System F. As an example, the
principal type given to the expression choose id, that is, 8 (ff >= oeid) ff ! ff has no
direct counterpart in System F. More precisely, the above expression can be annotated
in multiple ways, leading to multiple typings in System F. In particular, it can be typed
with oeid ! oeid and also with (t ! t) ! (t ! t) for any type t. This is the reason why
the encoding of a shallow type is not a single System F type, but rather a set of types.
Intuitively, the encoding of a type oe is the set of all instances of oe that are F-types.
Hence, the following definition :

Definition 10.3.4 The interpretation of a shallow type oe, written ((oe)), is a set of
System F types defined inductively as follows :

((o/ ))

M= fsub (o/ ) ((?)) M= fsub (8 ff * ff) ((8 (ff = oe) oe0)) M= fsub \Gamma ((oe0))[oe/ff]\Delta  (1)

((8 (ff >= oe) oe0))

M= fsub 0@

_ff#ftv(oe,oe0)[

t2((oe))

8 _ff * ((oe0))[t/ff]1A

194

10.3 Comparaison avec le Syste`me F 195
We note that ((o/ )) is fsub (o/ ), which is different from {o/ } since it contains all types
equivalent to o/ is System F. For instance, the type 8 ff * o/ is in fsub (o/ ) if ff /2 ftv(o/ ).
In (1), note that oe is an F-type since 8 (ff = oe) oe0 is shallow. Hence, we substitute ff by
oe in the set ((oe0)).

Example The interpretation of the polymorphic type oeid is (after simplification)
fsub 0@

_ff#{ff}[

t

8 _ff * t ! t1A, which is exactly the set fsub (8 ff * ff ! ff). Actually, we show

in Property 10.3.6.viii, below, that the interpretation of any F-type oe is the set of all
instances of oe in System F. Note also that we consider the union over all _ff disjoint from
{ff}. This restriction is unnecessary, and we could as well consider variables _ff containing
ff. However, since both definitions are equivalent, we chose the first one, which makes
some proofs easier. It will be shown in Property 10.3.6.ix that more restrictions can be
put on _ff without changing the definition.

Given two sets of substitutions S1 and S2, we write S1 * S2 for the set {`1 ffi `2 |
`1 2 S1, `2 2 S2}. We also write S1 ffi ` for S1 * {`}.

Definition 10.3.5 The interpretation of a shallow prefix Q, written ((Q)), is a set of
substitutions of System F, defined inductively as follows :

((;))

M= {id} ((Q0, ff = oe)) M= ((Q0)) ffi [oe/ff]

((Q0, ff >= oe))

M= ((Q0)) * [

t2((oe))

[nf(t)/ff] (2)

In (2), we write nf(t) to mean the normal form of t in System F. We could equivalently
keep t unchanged, but taking the normal form eases some proofs. We note that ((Q1Q2))
is ((Q1)) * ((Q2)).

We now establish a number of properties that will be used to show the soundness of
the interpretation of shallow types, in Lemma 10.3.10. For instance, Property i shows
that the interpretation of a type scheme is closed with respect to the instance relation
of System F.

Some results below require the argument oe to be in normal form. This requirement is
introduced in order to simplify the corresponding proof. Actually, all of these properties
are extended to type schemes not in normal forms, once the necessary results have been
shown.

195

196 Shallow MLF
Properties 10.3.6

i) We have fsub (((oe))) = ((oe)).
ii) If oe is in normal form and ff /2 ftv(oe), then 8 ff * ((oe)) ` ((oe)).
iii) If oe is in normal form, ((oe)) is ftv(oe)-stable.

iv) If t is not equivalent to ff, then fsub (t[t0/ff]) =ff (fsub (t))[t0/ff].

v) If ` is a substitution and the normal form of t is not in dom(`), then we have

`(fsub (t)) =dom(`) fsub (`(t)).
vi) For all t in ((oe)), we have oe 6/ t.
vii) If nf(oe) 6= ff and nf(oe) 6= ?, we have fsub (((oe))[t/ff]) =ff ((oe))[t/ff].
viii) If oe is an F-type in normal form, then ((oe)) = fsub (oe).

ix) If the sets S and S0 are _fi-stable, then we have

_ff# _fi[

t2S

8 _ff*S0[t/ff] =

_ff# _fi[_fl[

t2S

8 _ff*S0[t/ff]

x) If ` is a monotype substitution, then we have `(fsub (S)) =dom(`) fsub (`(S)).
xi) If ` is a monotype substitution and oe is in normal form, then `(((oe))) =dom(`)

((`(oe))) holds.
xii) If oe1 j oe2 holds, then we have ((oe1)) = ((oe2)).
xiii) If ` is in ((Q)), there exists a System F substitution `0 such that ` = `0 ffi bQ(t).

See proof in the Appendix (page 299).

Some of the properties above require their argument to be in normal form. Thanks
to Property xii, this requirement can be discarded :

Properties 10.3.7

i) If ff /2 ftv(oe), then 8 ff * ((oe)) ` ((oe)).
ii) The set ((oe)) is ftv(oe)-stable.
iii) If oe is an F-type, then ((oe)) = fsub (oe).

iv) If ` is a monotype substitution, we have `(((oe))) =dom(`) ((`(oe))).

Abstraction is a relation that hides information in the prefix. Its converse relation
is revelation, which exposes a type scheme bound to a variable in the prefix, and is
possible only by explicit type annotations. These two relations are at the heart of type
inference. However, the interpretation of shallow types is not designed for preserving
type inference, but only for comparing expressiveness of Shallow MLF and System F.
Thus abstraction and revelation are ignored by the interpretation, as stated by the
following lemma :

Lemma 10.3.8 If we have a shallow derivation of (Q) oe1 @- oe2, then for all ` in ((Q)),
the sets fsub (`(((oe1)))) and fsub (`(((oe2)))) are equal.

See proof in the Appendix (page 310).

196

10.3 Comparaison avec le Syste`me F 197
Note, however, that a corollary of this lemma is that the interpretation of shallow types
captures the equivalence relation (as well as the abstraction relation).

The next lemma shows that the interpretation of shallow types is consistent with
the instance relation : if oe2 is an instance of oe1 in Shallow MLF, then each type in ((oe2))
must be an instance (in System F) of a type in ((oe1)). Actually it amounts to having
((oe2)) ` ((oe1)). This holds for the instance relation under an empty prefix. The following
lemma takes the prefix into account thanks to a substitution `.

Lemma 10.3.9 If we have a shallow derivation of (Q) oe1 "" oe2, then for all ` in ((Q)),
we have `(((oe2))) ` `(((oe1))).

See proof in the Appendix (page 313).

10.3.4 Encoding Shallow F into System F

We consider the Curry-style version of System F, which we call implicit System F.
Expressions are expressions of the pure lambda-calculus, so that type applications,
type abstractions, and type annotations are all implicit. The typing rules of implicit
System F are the following :

IF-Var

x : t 2 A

A `F x : t

IF-Fun

A, x : t `F a : t0

A `F *(x) a : t ! t0

IF-App

A `F a1 : t2 ! t1 A `F a2 : t2

A `F a1 a2 : t1

IF-Inst

A `F a : t t vF t0

A `F a : t0

IF-Gen

A `F a : t ff /2 ftv(A)

A `F a : 8 ff * t

As expected, these rules correspond to the rules of System F, where type annotations
are removed on lambda-bound variables, type abstractions are type applications are
made implicit in rules IF-Gen and IF-Inst, respectively.

In order to prove that Shallow F and System F have the same expressiveness, we introduce Shallow UMLF as Shallow F with implicit oracles and without type annotations.
The type erasure of an expression typable in Shallow F is typable in Shallow UMLF.
Conversely, if an expression is typable in Shallow UMLF, it can be annotated in order
to be typable in Shallow F. We simply say that Shallow F and Shallow UMLF have
the same set of typable terms. We show in the following lemma that a term typable in
Shallow UMLF is also typable in implicit System F.

Lemma 10.3.10 Assume \Gamma  is a type environment with monotypes only. If we have
a derivation of (Q) \Gamma  ` a : oe in Shallow UMLF, then `(\Gamma ) `F a : `(t) holds for all
System F substitutions `, and System F type t such that ` 2 ((Q)), and t 2 ((oe)).

197

198 Shallow MLF

Proof: By induction on the shallow derivation of (Q) \Gamma  ` a : oe. Let ` be in ((Q)) and t
be in ((oe)) (1).

ffi Case Var : By hypothesis, we have \Gamma (x) = o/ . Hence, `(\Gamma )(x) is `(o/ ). Thus, we
can derive `(\Gamma ) `F a : `(o/ ) (2) by IF-Var. Additionally, t is in ((o/ )). Hence, t is in
fsub (o/), which means that t is equivalent to o/ . Then `(t) is equivalent to `(o/ ). Thus,
`(\Gamma ) `F a : `(t) holds from (2) by IF-Inst.

ffi Case App : The premises are (Q) \Gamma  ` a1 : o/2 ! o/1, (Q) \Gamma  ` a2 : o/2, a is a1 a2, and oe
is o/1. By induction hypothesis, we have `(\Gamma ) `F a1 : `(o/2 ! o/1), as well as `(\Gamma ) `F a2 :
`(o/2). By IF-App, we get `(\Gamma ) `F a : `(o/1) (3). We note that ((o/1)) = fsub (o/1), hence,
t is equivalent to o/1 (from (1)). This implies `(t) equivalent to `(o/1). Then by IF-Inst
and (3), we get `(\Gamma ) `F a : `(t).

ffi Case Fun : The premise is (Q) \Gamma , x : o/0 ` a0 : o/ , a is *(x) a0, and oe is o/0 ! o/ . We
note that ((o/0 ! o/)) = fsub (o/0 ! o/ ), hence, t is equivalent to o/0 ! o/ (from (1)). Then
`(t) is equivalent to `(o/0 ! o/ ). By induction hypothesis, we have `(\Gamma , x : o/0) `F a0 : `(o/ ).
By IF-Fun, we get `(\Gamma ) `F *(x) a0 : `(o/0) ! `(o/ ). By IF-Inst, we get `(\Gamma ) `F a : `(t).

ffi Case Gen : The premise is (Q, ff\Pi oe1) \Gamma  ` a : oe2 with ff /2 ftv(\Gamma ), and oe is 8 (ff\Pi oe1) oe2.
We consider two subcases :

Subcase oe is 8 (ff = oe1) oe2 : By definition, we have ((oe)) = fsub \Gamma ((oe2))[oe1/ff]\Delta .
From (1), there exists t2 in ((oe2)) such that t2[oe1/ff] vF t holds. This implies the inclusion `(t2[oe1/ff]) vF `(t) (4). Let `0 be ` ffi [oe1/ff]. We note that `0 2 ((Q, ff = oe1)). By
induction hypothesis, we have `0(\Gamma ) `F a : `0(t2), that is, `(\Gamma ) `F a : `(t2[oe1/ff]). By (4)
and IF-Inst, we get `(\Gamma ) `F a : `(t).

Subcase oe is 8 (ff >= oe1) oe2 : By definition, we have

((oe)) = fsub 0@

_ff#ftv(oe1,oe2)[

t12((oe1))

8 _ff * ((oe2))[t1/ff]1A

Let J be ftv(oe1, oe2) [ ftv(`(\Gamma )) [ dom(`) [ codom(`) (5). By Properties 10.3.7.ii and
10.3.6.ix, we get

((oe)) = fsub 0@

_ff#J[

t12((oe1))

8 _ff * ((oe2))[t1/ff]1A

From (1), there exist t2 2 ((oe2)), t1 2 ((oe1)), and _ff disjoint from J such that 8 _ff *
t2[t1/ff] vF t (6) holds. Let `0 be ` ffi [nf(t1)/ff]. We note that `0 2 ((Q, ff >= oe1)). By
induction hypothesis, we have `0(\Gamma ) `F a : `0(t2), that is, `(\Gamma ) `F a : `(t2[nf(t1)/ff]).
By (5) and IF-Gen, we get `(\Gamma ) `F a : 8 _ff * `(t2[nf(t1)/ff]). By (5), this is equal to
`(\Gamma ) `F a : `(8 _ff * t2[nf(t1)/ff]). By (6) and F-Inst, we get `(\Gamma ) `F a : `(t).

ffi Case Inst : The premise is (Q) \Gamma  ` a : oe0 and (Q) oe0 v oe holds. By Lemma 10.3.9,
we have `(((oe))) ` `(((oe0))). Hence, we have `(t) 2 `(((oe0))), that is, there exists t0 in ((oe0))
such that `(t) = `(t0). By induction hypothesis, we have a derivation of `(\Gamma ) `F a : `(t0),
that is, `(\Gamma ) `F a : `(t).

198

10.3 Comparaison avec le Syste`me F 199

ffi Case Oracle : The premises are (Q) \Gamma  ` a : oe0 and (Q) oe @- oe0. By Lemma 10.3.8, we
have fsub (`(((oe)))) = fsub (`(((oe0)))). We note that `(t) is in fsub (`(((oe)))). Hence, `(t) is
in fsub (`(((oe0)))), that is, there exists t0 in ((oe0)) such that `(t0) vF `(t) (7). By induction
hypothesis we have `(\Gamma ) `F a : `(t0). By (7) and IF-Inst, we get `(\Gamma ) `F a : `(t).

Note that the above lemma makes sense since ((Q)) and ((oe)) are not empty by
construction.

In order to illustrate this result, we consider the expression a equal to choose id. In
MLF, a has the principal type 8 (ff >= oeid) ff ! ff, which we write oe. The corresponding
derivation is the following : (for the sake of readability we only show a meaningful
excerpt of the derivation)

Gen

App
Inst

(ff >= oeid) ; ` choose : 8 (fi) fi ! fi ! fi
(ff >= oeid) 8 (fi) fi ! fi ! fi v ff ! ff ! ff

(ff >= oeid) ; ` choose : ff ! ff ! ff

(ff >= oeid) ; ` id : oeid

(ff >= oeid) oeid v ff

(ff >= oeid) ; ` id : ff Inst
(ff >= oeid) ; ` a : ff ! ff
(;) ; ` a : 8 (ff >= oeid) ff ! ff

The above lemma states that for any System F type t in ((oe)), `F a : t holds (the
prefix is empty). We write idff for ff ! ff, and tid for 8 ff * idff. We give two derivations
corresponding to two choices of t, namely tid ! tid and 8 ff * idff ! idff.

IF-App
IF-Inst

`F choose : 8 fi * fi ! fi ! fi
8 fi * fi ! fi ! fi vF tid ! tid ! tid

`F choose : tid ! tid ! tid `F id : tid

`F a : tid ! tid

IF-Inst

`F choose : 8 fi * fi ! fi ! fi
8 fi * fi ! fi ! fi vF idff ! idff ! idff

`F choose : idff ! idff ! idff (8)

IF-Inst

`F id : tid tid vF idff

`F id : idff (9)

IF-Gen

IF-App (8) (9)`F a : id

ff ! idff

`F a : 8 ff * idff ! idff

199

200 Shallow MLF

In the first derivation, the substitution taken from ((ff >= oeid)) is [tid/ff], while it is
[idff/ff] in the second derivation.

As a conclusion, each term typable in Shallow UMLF is also typable in System F,
thus System F and Shallow F have the same set of typable terms. As a corollary, type
inference in Shallow UMLF is undecidable, and so is type inference in Shallow MLF?.
However, this does not imply undecidability of type inference in MLF?, even though the
converse would be surprising.

Since Shallow F and System-F have the same expressiveness, for every term a of
Shallow F there exists a term M of explicitly typed system F that has the same erasure
as a. However, there is no unicity of a.

The interpretation of shallow types in System F suggests a semantics for types. However, the encoding ((oe)) of shallow types is disappointing : On the one hand, as stated
by Lemma 10.3.8, abstraction and revelation are not covered by the interpretation. On
the other hand, the strength of MLF lies in the way it propagates type information via
abstraction and revelation, which makes type inference possible. Thus, the given encoding does not provide a semantics meaningful for type inference. Fixing this amounts
to finding an interpretation that makes the difference between e.g. 8 (ff = oeid) ff ! ff
and 8 (ff = oeid, fi = oeid) ff ! fi. We are not aware of any such semantics.

10.4 Discussion

Let us summarize the results shown above. This document studies MLF (with type
annotations) and MLF? (with oracles), which have the same set of typable terms. We
wish to compare MLF and System F. We have already shown in Chapter 9 that System F
can be encoded in MLF. Hence, the set of typable terms of System F is included in
the set of typable terms of MLF. We simply say that System F is included in MLF.
We do not show the converse inclusion, but rather consider a restriction of MLF, called
Shallow MLF. In Section 10.2, we have shown that a term is typable in Shallow MLF
if and only if it is shallow and typable in MLF. Thus, Shallow MLF can as well be
defined as MLF where type annotations are required to be types of System F only.
As a consequence, System F is included in Shallow MLF. More precisely, terms of
System F do not have the let construct, thus System F is included in Shallow F, which
is Shallow MLF without let. Conversely, we have shown in Section 10.3, that Shallow F
is included in System F. Hence, Shallow F and System F have the same set of typable
terms. This can be pictured by the following sequence of relations :

MLF = MLF? ' Shallow MLF ' Shallow F = System F

200

10.4 Discussion 201

A remaining question is whether Shallow F is a strict subset of Shallow MLF (encoding let constructs as *-abstractions). We conjecture that this is true.

More precisely, our candidate for discrimination is the term a0 given below. We first
introduce some notations that make the term a0 more readable. Given a number n, we
write _n for the church numeral n, that is, *(f ) *(x) (f . . . (f x)) with f repeated n
times. We write S the successor function, that is, *(n) *(f ) *(x) f (n f x). We recall
that auto is *(x) x x. Additionally, given two terms a and a0, the sequence a; a0 is
syntactic sugar for _0 a a0. Then the term a0 is defined as let x = a1 in a2 where a1 is
the function *(f ) f id and a2 is the sequence x auto ; (*(y) x y ; y S) (*(z) *(z0) z _2).

The term a0 is in Shallow MLF. However, we conjecture that a0 is not typable in
System F. The intuition is that the two occurrences of x have "incompatible types"
((8 ff * (ff ! ff)) ! t) ! t for some type t and (N2 ! N2) ! N2 in System F where N is
the type 8 ff * (ff ! ff) ! ff ! ff of church numerals and N2 is N ! N. In Shallow MLF,
x can be assigned the type (8 (fi, ff >= oeid) ff ! fi) ! fi.

Furthermore, assuming that a is not in System F, we can build the term a0 equal
to _1 (*(x) a2) a1, which is in MLF but not in Shallow MLF. Indeed, (*(x) a2) a1 is
typable in MLF (annotating x with the type given above), thus a0 is typable, as shown in
Example 5.2.11. However, a0 is not typable in Shallow MLF. Indeed, it would otherwise
be typable in Shallow F (it does not use let), and therefore it would be typable in
System F. This has been conjectured not to hold.

Still, MLF remains a second-order system and in that sense should not be significantly more expressive than System F. In particular, we conjecture that the term
(*(y) y I ; y K) (*(x) x x) that is typable in F! but not in F [GR88] is not typable
in MLF either. Conversely, we do not know whether there exists a term of MLF that is
not typable in F!.

Notice however that the term a0 given above is typable in F!. The hint is to encode
the type 8 (fi) 8 (ff0>=8 (ff) ff ! ff) (ff0 ! fi) ! fi as 8 A*8 fi*((8 ff*A ff ! A ff) ! fi) !
fi and use \Lambda (fl) fl or \Lambda (fl) N for A to recover the types of the two occurrences of x. Then
a can be typed as follows in F! : (*(x : 8 A * 8 fi * ((8 ff * A ff ! A ff) ! fi) ! fi) a02) a01,
where, a01 is \Lambda (A) \Lambda (fi) *(f : (8 ff * A ff ! A ff) ! fi) f (\Lambda (ff) id[A ff]) and a02 is

\Lambda (ff)

x [\Lambda (fi) fi] [idff] (*(x : oeid) x [idff] x[ff]) ;

(*(y : N2 ! N2) x [\Lambda (ff) N2] [N] y ; y S)

(*(z : N2) *(z0 : N) z _2)

This suggests that there may exist an encoding of MLF into F!.

201

202 Shallow MLF

We can now enrich the above diagram with these conjectures :

F!

MLF
MLF? ! oe

(10)  Shallow MLFShallow MLF

? ! oe

(11) Shallow F = System F

ae(12) oe(13)

The inclusion (11) corresponds to the encoding of System F, which is shallow (proved).
It is conjectured to be a strict inclusion. The inclusion (10) is by construction. It is
strict whenever (11) is strict. The inclusion (13) is by construction of F!. It is known
to be a strict inclusion [GR88]. We expect the inclusion (12) to hold, as suggested by
the example above, however we are not able to give a systematic encoding of MLF into
F!. This inclusion is also conjectured to be strict.

Reducing all let-bindings in a term of Shallow MLF produces a term in Shallow F.
Hence, terms of Shallow MLF are strongly normalizable. We conjecture that so are all
terms of MLF.

202

203
Chapitre 11
Extensions du langage

Nous avons de'fini MLF comme un langage noyau a` partir des expressions de ML
et des annotations de type. Nous avons montre' que tous les programmes de ML sont
typables dans MLF, sans annotation. Cependant, les programmes ML re'els utilisent
souvent des extensions du langage. Nous montrons dans ce chapitre comment de telles
extensions peuvent e^tre ajoute'es a` MLF. Certaines constructions, comme les tuples ou
enregistrements, sont mentionne'es section 11.1 et sont facilement ajoute'es a` MLF. A`
noter, cependant, que le polymorphisme de premie`re classe permet d'encoder certaines
constructions (notamment les paires) directement, alors que ce n'est pas toujours possible en ML. Les extensions impe'ratives sont conside're'es section 11.2 : les re'fe'rences
sont re'pute'es proble'matiques en pre'sence de polymorphisme ; cette extension est en
effet plus de'licate et ne'cessite des restrictions. Dans la section 11.3, nous conside'rons
une extension utile qui n'a pas d'e'quivalent en ML car les annotations de type ne sont
pas requises pour l'infe'rence. Cette extension consiste a` propager les annotations de
type du niveau exte'rieur vers les sous-expressions. Comme application imme'diate, elle
peut e^tre utilise'e pour propager les annotations de type depuis les fichiers d'interface
vers les fichiers d'imple'mentation. Par exemple, l'information de type donne'e dans la
signature d'un module peut e^tre automatiquement propage'e vers chaque e'le'ment et
chaque sous-expression de ce module.

11.1 Tuples, Records

Because the language is parameterized by constants, which can be used either as
constructors or primitive operations, the language can import foreign functions defined
via appropriate ffi-rules. These could include primitive types (such as integers, strings,
etc.) and operations over them. Sums and products, as well as predefined datatypes,

203

204 Extensions du langage
can also be treated in this manner, but some (easy) extension is required to declare
new data-types within the language itself.

As an example, the primitives that handle pairs have the same types as in ML :

(_, _) : 8 (ff, fi) ff ! fi ! ff * fi

fst : 8 (ff, fi) ff * fi ! ff
snd : 8 (ff, fi) ff * fi ! fi

The corresponding ffi-rules are

fst (v1, v2) -! v1
snd (v1, v2) -! v2

We could also introduce pairs using the usual encoding of pairs in System F :

(_, _) = *(x) *(y) *(f ) f x y
fst = *(p) p (*(x) *(y) x)
snd = *(p) p (*(x) *(y) y)

However, as remarked by Fritz Henglein [Hen93], this encoding is not correct in ML.
Indeed, the type given to *(p) (fst p, snd p) is then 8 ff * ff * ff ! ff * ff, whereas it
is 8 fffi * ff * fi ! ff * fi when using the primitive pairs. This cannot be fixed in ML,
but it can in MLF, adding a type annotation to the argument of fst and snd :

fst = *(p : 9 (ff, fi) 8 (fl) (ff ! fi ! fl) ! fl) p (*(x) *(y) x)
snd = *(p : 9 (ff, fi) 8 (fl) (ff ! fi ! fl) ! fl) p (*(x) *(y) y)

Then the pairs encoded as functions and the primitive pairs have the same typing
behavior.

11.2 References

To give an account of references, the simplest modification of the dynamic semantics
is to use a global store (mapping store locations to values) and a small-step reduction
relation over store-expression pairs. This carries over to MLF without any difficulty.

Adapting the static semantics to ensure that store locations are always used at
the same type is more difficult. In ML, this can be done by restricting implicit letpolymorphism to syntactic values [Wri95]. Hence, the type of a location, which must
be the type of the non-value expression creating the location, cannot be polymorphic.
This solution can be adapted to MLF as well.

204

11.2 Les re'fe'rences 205
Value restriction The value restriction consists of restricting Rule Gen to values
(non-expansive expressions) only :

Gen-vr

(Q, ff \Pi  oe) \Gamma  ` a : oe0 ff /2 ftv(\Gamma ) a non-expansive

(Q) \Gamma  ` a : 8 (ff \Pi  oe) oe0

Then the type inference algorithm (page 164) is modified as follows :
Case a b :

* let (Q1, oea) = infer (Q, \Gamma , a)

* let (Q2, oeb) = infer (Q1, \Gamma , b)

* let ffa, ffb, fi /2 dom(Q2)

* let Q3 = unify ((Q2, ffa >= oea, ffb >= oeb, fi >= ?), ffa, ffb ! fi) return (Q3, fi)

We return Q3 whereas, in the previous version of the algorithm, Q3 is split in two
parts Q4 and Q5. Then Q4 is returned as the new prefix, and Q5 is generalized in front
of fi.

However, this solution is likely to be very disappointing when applied to MLF, whose
machinery relies on type generalization and the use of polymorphic non-functional expressions (which cannot be j-expanded). As a first example, type annotations are primitives that reveal polymorphism upon application. If the value-restriction holds, a
type annotation primitive does no longer reveal polymorphism, because generalization
is forbidden. Hence, the introduction of the value-restriction requires a dedicated typing
rule for type annotations. Fortunately, there is a simple relaxation of value-only polymorphism that allows type variables to remain polymorphic in the type of non-values,
as long as they only occur covariantly [Gar02]. Since this extension was designed for
Poly-ML in the first place (even though it is more general), we expect this solution to
work well for MLF as well and to be sufficient in practice.

Relaxed value restriction Given a flat type t, we define ftv-(t) inductively as
follows :

ftv-(ff) = ; ftv-(?) = ; ftv-(t1 ! t2) = ftv(t1) [ ftv-(t2)
Given a type scheme oe, ftv-(oe) is by definition ftv-(proj(t)). We note that all free
variables of oe occurring at the left of an arrow are in ftv-(oe). This definition of negative
occurrences is not usual, since ff is considered negative in (ff ! fi) ! fi, while it is
often considered positive in other type systems.

The relaxed value restriction consists of restricting Rule Gen as follows :

Gen-rvr

(Q, ff \Pi  oe) \Gamma  ` a : oe0 ff /2 ftv(\Gamma ) a non-expansive or ff /2 ftv-(oe0)

(Q) \Gamma  ` a : 8 (ff \Pi  oe) oe0

205

206 Extensions du langage

In order to implement this rule in the type inference algorithm, we need to modify
the split algorithm (defined page 112) according to the occurrence of variables. Hence
the following definition :

Definition 11.2.1 The positive splitting of a closed prefix Q according to the set _ff
and the type scheme oe is written Q"oe _ff and defined inductively as follows (we require

_ff ` dom(Q)). :

;"oe _ff = (;, ;)

(Q, ff \Pi  oe)"o/ _ff = ( (ff \Pi  oe)

1-! Q"oe0 ( _ff - ff) [ ftv(oe) when ff 2 _ff or ff 2 ftv-(oe0)

(ff \Pi  oe) 2-! Q"8 (ff\Pi oe)oe

0 _ff otherwise

Then the type-inference algorithm is modified as follows :
Case a b :

* let (Q1, oea) = infer (Q, \Gamma , a)

* let (Q2, oeb) = infer (Q1, \Gamma , b)

* let ffa, ffb, fi /2 dom(Q2)

* let Q3 = unify ((Q2, ffa >= oea, ffb >= oeb, fi >= ?), ffa, ffb ! fi)

* let (Q4, Q5) = Q"fi dom(Q)

* return (Q4, 8 (Q5) fi)

The only difference is that variables that are generalized (namely Q5) are those
obtained from the positive splitting of Q, which takes the occurrence of the variables
into account.

This restriction has been implemented and seems to work well on a few significant
examples. It remains to find if it is usable in practice for larger programs.

11.3 Propagating type annotations

In MLF, type annotations are only needed on arguments of *-abstractions that are
used polymorphically. However, for documentation purposes or for readability, it can
be useful to put extra type annotations. For instance, consider the following top-level
definition : let delta = *(x : oeid) x x. One could wish to give explicitly the type of
delta (the annotation oeid ! oeid is syntactic sugar for 8 (ff = oeid) 8 (fi = oeid) ff ! fi) :
let (delta : oeid ! oeid) = *(x : oeid) x x (14). In this case, the two annotations are
obviously redundant. We would like to get rid of the second one (x : oeid), which is
subsumed by the first one.

In a first time, we define some syntactic sugar to give meaning to the notation
let (x : oe) = a. Then we show how type annotations can be automatically propagated
in order to avoid useless redundancy.

206

11.3 Propagation des annotations de type 207

let-bound variables and *-bound variables can be annotated, using the following
syntactic sugar (the first rule was already defined in Section 8.3) :

*(x : 9 (Q) oe) a -! *(x) let x = (x : 9 (Q) oe) in a
let (x : 9 (Q) oe) = a in a0 -! let x = (a : 9 (Q) oe) in a0
let rec (x : 9 (Q) oe) = a in a0 -! let rec x =

let x = (x : 9 (Q) oe) in
(a : 9 (Q) oe) in a0

Next, we show how the outer type annotation in (14) can be propagated to the inner
*-abstraction. More generally, we show how type annotations are propagated to inner
terms. Since flexible bindings and rigid bindings are quite different in nature, they are
propagated differently. The flexible domain and rigid domain of a prefix, defined next,
clearly separate those two kinds of bindings.

Definition 11.3.1 The flexible domain and the rigid domain of a prefix Q , written
dom>(Q) and dom=(Q) respectively, are defined as follows :

- ff 2 dom>(Q) if and only if (ff >= oe) 2 Q or (ff = oe0) 2 Q and oe0 2 T .
- ff 2 dom=(Q) if and only if (ff = oe) 2 Q or (ff >= oe0) 2 Q and oe0 2 T .
We note that dom(Q) is the union of dom>(Q) and dom=(Q), and that dom( bQ) is their
intersection. Indeed, as explained in Definition 1.5.7, bindings (ff \Pi  oe) where oe 2 T are
considered both flexible and rigid.

The rules given below syntactically propagate type annotations. To ease readability,
we do not keep the original type annotation in place but only show the propagation
mechanism. Actually, the outer type annotation is meant to be kept in place and propagated.

(a1 a2 : 9 (Q) oe) -! (a1 : 9 (ff, Q) 8 (ff0 = oe) ff ! ff0) a2
(let x = a1 in a2 : 9 (Q) oe) -! let x = a1 in (a2 : 9 (Q) oe)
(a1, a2 : 9 (Q) 8 (Q0) o/1 * o/2) -! ((a1 : 9 (Q) 8 (Q0) o/1),

(a2 : 9 (Q) 8 (Q0) o/2))
(*(x) a : 9 (Q) 8 (Q0) o/1 ! o/2) -! *(x : 9 (QQ1) 8 (Q01) o/1)

(a : 9 (QQ2) 8 (Q02) o/2)
where

(Q1, Q01)

M= Q0" ftv(o/2) [ dom>(Q0)

(Q2, Q02)

M= Q0" ftv(o/1)

Hence, if the expression let (delta : oeid ! oeid) = *(x) x x is given in input, it
is first replaced by let delta = (*(x) x x : 8 (ff = oeid, fi = oeid) ff ! fi). Then the
type annotation is propagated as follows (writing type annotations in normal form) :
let delta = (*(x : oeid) ((x : 9 (ff) ff ! oeid) x : oeid) : 8 (ff = oeid, fi = oeid) ff ! fi). The

207

208 Extensions du langage
type annotation (_ : oeid) has been automatically propagated to the *-bound variable
x. Note that the expression let (delta : 9 (ff) oeid ! ff) = *(x) x x is also typable by
syntactic propagation of type annotations.

208

209
Chapitre 12
MLF en pratique

One of the main motivations for designing MLF was that the amount of explicit type
information required in some previous proposals was too big. Satisfyingly, the encoding
of System F is light, and we know that arguments of *-abstractions that are not used
polymorphically need not be annotated.

12.1 Some standard encodings

Using the prototype, we were able to test a few simple examples such as the usual
encodings of Church integers, booleans, and tuples in System F. As expected, very few
type annotations are needed, and always at predictable places. Indeed, for arguments
that are known to have a polymorphic type (for example the polymorphic type encoding
integers), it is usually good practice to annotate them using an abbreviation : on the
one hand, such arguments are most of the time more "significant" than monomorphic
arguments ; on the other hand, the inferred types will be much easier to read, thanks
to the abbreviation. Besides, although some functions abstract over polymorphic types,
they do not necessarily use their argument in a polymorphic way. As a result, a substantial number of function definitions does not actually need the type annotation that
the programmer already provided for his own convenience.

In the following example, we define Church integers and some operations over them.1

# type Int = 8ff. (ff ! ff) ! (ff ! ff)
type Int defined.

# let succ (n:Int) = fun f x ! n f (f x)
val succ : 8(fi >= 8ff. (ff ! ff) ! ff ! ff) Int ! fi

1The output is taken from the prototype, but slightly modified to make it more readable.

209

210 MLF en pratique

# let add (n:Int) (m:Int) = n succ m
val add : 8(fi >= Int ! Int) Int ! fi

Actually, both of these functions can be written without type annotations (indeed, they
are typable in ML). But then the inferred type, which is equivalent, is harder to read :

# let add n m = n succ m
val add : 8(ff >= 8(fl >= 8 x.(x ! x) ! x ! x) Int ! fl)

8(ffi) 8(ffl) (ff ! ffi ! ffl) ! ffi ! ffl

Moreover, it sometimes happens that, although a function is typable without any type
annotation, the type annotation is mandatory in order to get the "correct" type (see
the example with pairs in Section 11.1). Indeed, the principal type of an expression
depends on the polymorphic type annotations.

Notice that in all of these cases, the annotation could be propagated from the
signature file to the implementation, using the technique described in Section 11.3.

We admit that these examples are only simple encodings that do not make strong
use of first-class polymorphism. Thus, it is not surprising that so few annotations are
actually needed. However, it would be possible to build more involved examples by
using these encodings with complex data structures. For example, it is possible to store
Church integers (which are polymorphic) in a hashtable without any need for type
annotations. The following piece of code typechecks in MLF with the value restriction.

let table = Hashtbl.create 10
Hashtbl.add table "one" (*(f) *(x) f x)
Hashtbl.add table "two" (*(f) *(x) f (f x))
add (Hashtbl.find table "one") (Hashtbl.find table "two")

The last line applies add, which requires its two arguments to be polymorphic of type
Int (Church integers). The type of table is monomorphic, namely ff hashtable, where
ff is a weak type variable. Still, ff is bound to Int in the prefix. We see that the
type parameter of the type constructor hashtable is implicitly instantiated by (a type
variable standing for) a polymorphic type. This makes hashtables, or any data structure,
compositionnally usable, including with polymorphic values.

12.2 Existential Types

Another interesting example is the encoding of existentials. In System F, the existential type 9ff.t is isomorphic to the polymorphic type 8 fi * (8 ff * t ! fi) ! fi. Then,
an existential value v with type 9ff.t is encoded as a function expecting a polymorphic
argument : let v0 = \Lambda (fi) *(x : 8 ff * t ! fi) x v.

210

12.3 Quand faut-il annoter ? 211

In order to open an existential v0, one must apply it to a polymorphic function, that
is, a function parametric over the type being abstracted : (we omit the type application)
v0 [..] (\Lambda (ff) *(x : ff) (x, x)).

In MLF, the encoding of existentials gets a real benefit from type inference. Indeed,
while the creation of the existential itself requires a type annotation, the opening does
not require any type annotation. This is the best we can expect since the abstract type
given to the encapsulated value can only be defined by the programmer himself.

Let us consider a concrete example : we build an encapsulation for tasks, that is,
a pair of a function and its argument. Tasks can be put in a list and evaluated by a
server. The server opens each encapsulation and applies the function (second element
of the pair) to its argument (first element of the pair).

let encapsulate v = *(f : 8ff. ff * (ff ! unit) ! fi) f v
let create f arg = encapsulate (arg, f)

let serve box = box (*p (snd p) (fst p))
New tasks are easily created using create, put in any data structure such as a list,
and served using serve :

let taskList = (create f1 arg1) :: (create f2 arg2) :: ...
let server () = List.iter serve taskList

Notice that only a single type annotation is needed for the whole example.

12.3 When are annotations needed ?

MLF motto is "annotate arguments that are used polymorphically". This does not
mean that the argument is used twice. Indeed, in some examples, an annotation is
required on an argument which is only used once.

Consider the following example :

let auto (x : 8ff. ff ! ff) = x x
let t z = auto z
t id

auto is defined as usual : it requires a polymorphic argument. Then, we define t that
expects a polymorphic argument z and applies auto to it. The argument z is not
annotated because it is not used polymorphically, but only passed through.

We consider a variant auto2 defined as follows :

let auto2 (z:8ff. unit ! ff ! ff) = (z ()) (z ())

: 8(fi = 8ff. unit ! ff ! ff) 8(fl >= 8ff. ff ! ff) fi ! fl

211

212 MLF en pratique

Finally, we build t2 that, intuitively, takes the identity as an argument, builds a
*-abstraction, and applies auto2 to the result.

let t2 y = auto2 (*() y)
This expression is not typable in MLF. It is an example of a function which uses its
argument only once, but which requires an annotation. Indeed, annotating y with 8 (ff)
ff ! ff suffices to make the expression typable. In this example, the argument y is used
polymorphically in the sense that it is used to build a function which is required to
be polymorphic. On the contrary, in *z.auto z, the argument z is not used but only
passed through.

12.4 A detailed example

In the following example, we aim at writing some generic functions that can be used
with different kinds of data structures. For instance, we define the functions size, sum
and max that return, respectively, the number of elements of the given data structure,
the sum of all (integers) elements of the data structure, and the maximal element of
the structure. These functions are written only once, but are applied on two different
incompatible implementations. The first one is a list of integers, the second one is a
balanced binary tree. Both of these data structures are viewed abstractly, using their
associated iterator.

The following type definition corresponds to the type of iterators over type structures holding integers. Since such data structures are typically special instances of
graphs, we simply call this type graph.

type graph = 8ff. (int ! ff ! ff) ! ff ! ff
The first data structure we use is a list. The iterator over lists is easily defined as
follows2 :

let rec list_iter list f accu =

if list = [] then accu
else list_iter (cdr list) f (f (car list) accu)
: 8ff. 8fi. ff list ! (ff ! fi ! fi) ! fi ! fi

The second data structure is a balanced binary tree. We define a datatype for such
trees and the corresponding iterator.

2This full example is written as such in our prototype implementation of MLF; only the output is
slightly modified to make it easier to read.

212

12.4 Exemple de'taille' 213

type tree = Empty | Node of tree * tree | Leaf of int
(* left-to-right traversal of the tree. *)
let rec (tree_iter: tree ! graph) tree f accu =

begin match tree with
| Empty ! accu
| Node (left, right) ! tree_iter right f (tree_iter left f accu)
| Leaf x ! f x accu
end
: tree ! graph

The annotation on tree_iter could be omitted here. It makes the inferred type more
readable.

Next, we define a few generic functions that can be applied on any data structure,
using the iterator.

let size gr = gr (fun x n ! n+1) 0 (* Number of elements. *)
let nodes gr = gr (fun x l ! x::l) [] (* List of elements. *)
let sum gr = gr (fun x s ! s+x) 0 (* Sum of all elements. *)
let last gr = gr (fun x a ! x) 0 (* Last element, 0 if none. *)
let max gr = gr (fun x m ! if x > m then x else m) 0
let min gr = gr (fun x m ! if x < m then x else m) (last gr)

Since no type annotation is given, the inferred types may be quite large ; for example :

val last : 8(ff >= 8fi. 8(fl >= 8ffi. ffi ! fi) fi ! fl) 8ffl. (ff ! int ! ffl) ! ffl
val max: 8ff. ((int ! int ! int) ! int ! ff) ! ff

The following function converts a given graph (whose actual representation is unknown)
to a list, provided the given graph is quite small. The list is exported as another graph.

let convert (gr:graph) =

if size gr < 10 then list_iter (nodes gr)
else gr
: graph ! graph

An annotation is required because the argument gr is used twice with incompatible
types ; that is, gr is used polymorphically. The inferred type is also much easier to read
than the above types.

The next function (inefficiently) inserts an element in a balanced tree (usual ML
code).

213

214 MLF en pratique

let rec insert tree x =

begin match tree with
| Empty ! Leaf x
| Leaf y ! Node (Leaf x, Leaf y)
| Node (left, right) !

if size (tree_iter left) <= size (tree_iter right)
then Node (insert left x, right)
else Node (left, insert right x)
end
: tree ! int ! tree

Next, we build a balanced tree with the values 1, .., 6.

let tree = insert Empty 1
let tree = insert tree 2
let tree = insert tree 3
let tree = insert tree 4
let tree = insert tree 5
let tree = insert tree 6

We define three different graphs. The first one is implemented by a balanced tree ; the
second one is a conversion of it (and will actually be converted to a list) ; the third one
is implemented by a list.

let graph1 = tree_iter tree
let graph2 = convert graph1
let graph3 = list_iter [1; 2; 3; 4; 5; 6]

The function print_info below prints all kinds of information about a given graph,
including its size and all its nodes. It is a generic function : it does not depend on the
underlying implementation.

(* Tool function *)
let rec print_list l =

if l = [] then print "[]"
else (print_int (car l) ; print "; " ; print_list (cdr l))

214

12.4 Exemple de'taille' 215

let print_info (gr:graph) =

begin

print "Size : " ; print_int (size gr) ; print "\n" ;
print "Sum : " ; print_int (sum gr) ; print "\n" ;
print "Last : " ; print_int (last gr) ; print "\n" ;
print "Max : " ; print_int (max gr) ; print "\n" ;
print "Min : " ; print_int (min gr) ; print "\n" ;
print "Nodes : " ; print_list (nodes gr) ; print "\n" ;
end
: graph ! unit

This function is annotated because its argument gr is used polymorphically.

Finally, we call the generic function print_info with the three different graphs we
have defined. Two of them are actually implemented by lists and one of them by a
balanced tree.

print "Graph1 \n" ; print_info graph1 ;
print "Graph2 \n" ; print_info graph2 ;
print "Graph3 \n" ; print_info graph3 ;

The output we get is the following :

Graph1
Size : 6
Sum : 21
Last : 1
Max : 6
Min : 1
Nodes : 1; 4; 6; 2; 3; 5; []

Graph2
Size : 6
Sum : 21
Last : 5
Max : 6
Min : 1
Nodes : 5; 3; 2; 6; 4; 1; []

215

216 MLF en pratique

Graph3
Size : 6
Sum : 21
Last : 6
Max : 6
Min : 1
Nodes : 6; 5; 4; 3; 2; 1; []

12.5 Discussion

In the above example, only two type annotations are mandatory, namely in convert
and print_info. Another one was provided for convenience in tree_iter. Writing this
sample code, it was always very clear when to put an annotation.

A different style would be to annotate generic functions such as size, nodes, etc.,
although they do not require any annotation. As a result, the inferred types would be
nicer, and the function print_info would not need an annotation.

More generally, the "generic functions" above can be viewed as library functions.
Then, their type would be provided in a signature file. As a consequence, user-defined
functions using this library would, in most cases, not need type annotations.

216

CONCLUSION 217
Conclusion

Nous avons pre'sente' MLF, qui est une extension de ML avec des types plus expressifs qui permettent le polymorphisme de premie`re classe. L'algorithme d'unification sur
ces types est prouve' correct et complet ; bien que les types soient d'ordre supe'rieur,
l'unification reste de premier ordre. En effet, le polymorphisme n'est jamais devine',
mais seulement propage' implicitement. Il peut e^tre introduit, comme en ML, par une
construction let, ou par des annotations de type explicites. Alors, il est est implicitement instancie', exactement comme en ML.

Les re`gles de typage de MLF sont les re`gles de typage de ML, a` la diffe'rence qu'elles
manipulent les types plus riches et la relation d'instance de MLF. En conse'quence,
l'algorithme d'infe'rence de MLF est similaire a` celui de ML et repose essentiellement
sur l'unification et la ge'ne'ralisation. Comme en ML, toute expression typable de MLF
admet un type principal, qui de'pend toutefois des annotations explicites de type. La
similarite' entre MLF et ML implique que tous les programmes ML sont typables dans
MLF tels quels. De plus, les types plus riches permettent d'introduire les annotations
de type comme des primitives, dont nous avons prouve' la su^rete' du typage. Gra^ce a`
ces primitives, nous donnons un encodage du Syste`me F en effac,ant simplement les
abstractions de type et les applications de type.

Il est inte'ressant de noter que toutes les annotations que l'on trouve dans un programme du Syste`me F ne sont pas toujours ne'cessaires en MLF : les annotations monotypes, de me^me que les annotations sur les variables qui ne sont pas utilise'es de manie`re polymorphe peuvent e^tre infe're'es. Par exemple, la fonction app, de'finie comme
*(f ) *(x) f x peut e^tre applique'e a` n'importe quelle paire d'arguments a1 et a2 tels
que a1 a2 est typable. Ceci n'est pas vrai dans le Syste`me F ou` des applications de type
sont ne'cessaires pour spe'cialiser le type de app. De manie`re comparable, la fonction
*(x) x id peut e^tre applique'e a` la fois a` une fonction reque'rant un argument monomorphe tel que List.map, et a` une fonction reque'rant un argument polymorphe, tel
que auto (de'fini comme *(x : oeid) x x). Aucune application de type ni coercion n'est
ne'cessaire pour choisir entre une instance monomorphe de l'identite' et l'identite' "polymorphe". Ceci n'e'tait pas vrai dans les autres syste`mes de type essayant de me'langer
ML et le polymorphisme de premie`re classe, y compris Poly-ML.

217

218 CONCLUSION

En re'sume', MLF est une inte'gration de ML et du Syste`me F qui combine les avantages de l'infe'rence de type de ML et l'expressivite' du polymorphisme de second ordre.
Les informations de type ne sont requises que pour les arguments des fonctions qui
sont utilise's de manie`re polymorphe dans leur corps. Nous e'mettons l'hypothe`se que
cette spe'cification est intuitive pour l'utilisateur. De plus, elle est modulaire puisque
les annotations de'pendent davantage du comportement du code me^me que du contexte
dans lequel le code est place'. En particulier, les fonctions qui se contentent de propager
le polymorphisme sans l'utiliser n'ont pas besoin d'annotation.

Une application imme'diate de ce travail serait d'e'tendre un langage base' sur ML
avec du polymorphisme de second ordre tout en conservant l'infe'rence de type totale
pour une large partie du langage, incluant notamment les programmes ML. Nous avons
d'ailleurs imple'mente' un prototype de MLF et ve'rifie' sur une varie'te' d'exemples que
peu d'annotations sont effectivement ne'cessaires et toujours a` des endroits pre'visibles.

En explorant les diffe'rences entre MLF et Syste`me F, nous avons conside're' une
restriction de MLF appele'e Shallow MLF. Nous avons montre' que Shallow MLF peut
e^tre vu comme MLF ou` les annotations de type sont restreintes aux types du Syste`me F.
Tous les programmes de ML et de Syste`me F restent typables dans Shallow MLF. Ceci
signifie que le programmeur n'a pas besoin de comprendre les types de MLF pour e'crire
des programmes de Shallow MLF. Toutefois, les types "shallow" sont introduits par
l'algorithme d'infe'rence, par exemple lors du typage de choose id qui introduit le type
8 (ff >= oeid) ff ! ff. Il semble donc que la connaissance des types shallow soit ne'cessaire
pour comprendre les types infe're's, en particulier ceux apparaissant dans les messages
d'erreur. Ne'anmoins, nous avons montre' que Shallow MLF (sans le let) permet de
typer les me^mes termes que le Syste`me F. Plus pre'cise'ment, le typage d'une expression
de Shallow MLF correspond a` un ou plusieurs typages dans le Syste`me F. Ainsi, il est
sans doute possible de concevoir un typeur base' sur MLF qui cache les types MLF : le
programmeur ne voit que les types du Syste`me F. Dans ce cas, alors que le typeur peut
toujours trouver le type principal d'une expression, il ne peut pas toujours l'imprimer.
Ceci peut poser proble`me lors de l'e'criture des fichiers d'interface. Ainsi, alors que les
types de MLF ne sont a priori pas ne'cessaires dans les programmes source, ils risquent
d'apparai^tre dans les messages du typeur.

Ouvertures
MLF et F! Puisque le Syste`me F peut e^tre encode' dans MLF, il est le'gitime de
conside'rer une extension de MLF avec des types d'ordre supe'rieur, c'est-a`-dire des types
de F!. En conservant les abstractions de type et les applications de type explicites pour
les kinds d'ordre supe'rieur, il est vraisemblablement possible de conserver l'infe'rence de
type. En conse'quence, l'infe'rence des abstractions de type et des applications de type
pour la kind type de F! doit e^tre possible. Ceci doit cependant e^tre formalise'.

218

CONCLUSION 219
Une imple'mentation efficace de l'unification L'algorithme d'unification est de'fini sur des types "syntaxiques". En imple'mentant les types comme des graphes, comme
de'crit page 45, il doit e^tre possible de concevoir un algorithme d'unification plus efficace.
Plus pre'cise'ment, les graphes et les proble`mes d'unification peuvent e^tre encode's comme
des multi-e'quations telles que re'soudre un proble`me d'unification revient a` re'duire un
ensemble de multi-e'quations en forme re'solue. Ensuite, l'algorithme d'unification peut
e^tre de'crit simplement comme un ensemble de re`gles de re'e'criture invariantes sur l'ensemble de solution. Du point de vue de l'imple'mentation, un algorithme d'unification
sur les graphes proce'derait en deux e'tapes : une premie`re e'tape effectue l'unification de
premier ordre, en ignorant les quantificateurs ; la seconde e'tape de'place et combine les
quantificateurs. Cette seconde e'tape e'choue si un quantificateur rigide est ille'galement
de'place'. Par exemple, la re'e'crire le type 8 (ff=oeid) ff ! o/ en 8 (fi) 8 (ff=fi ! fi) ff ! o/
revient a` de'placer le quantificateur de fi, ce qui n'est pas autorise' sous un quantificateur rigide. En effet, le premier type requiert un argument polymorphe, de type oeid,
alors que le second type peut e^tre applique' a` n'importe quelle instance monomorphe.
En conse'quence, cette instanciation n'est pas correcte car elle permettrait d'appliquer
auto, qui attend un argument polymorphe, a` une valeur monomorphe telle que succ
(la fonction successeur). Sur les graphes, cela signifie que l'e'tape suivante n'est pas
autorise'e :

!

! o/

?

v

!
! o/

?
En outre, certaines conditions de bonne formation impliquent que chaque noeud
ne doit apparai^tre que sous le noeud ou` il est quantifie'. Chez les types "syntaxiques",
cela correspond au fait qu'une variable ne peut pas e^tre utilise'e en dehors de sa porte'e
lexicale. Il devient alors ne'cessaire d'effectuer des tests supple'mentaires afin de conserver
la bonne formation, et parfois de de'placer des quantificateurs n'ayant pas de rapport
avec l'e'tape d'unification locale conside're'e. De'tecter quels quantificateurs doivent e^tre
de'place's peut e^tre une ope'ration cou^teuse qui ne'cessite une analyse plus pousse'e. Pour
illustrer ce phe'nome`ne, nous donnons un exemple. Le graphe de gauche repre'sente le
type 8 (ff >= 8 (fi) 8 (fl >= 8 (ffi) fi ! ffi) fi ! fl) 8 (fl0) ff ! fl0. Le graphe de droite est
similaire, mais les noeuds sont e'tiquete's avec la variable les de'finissant. Le noeud racine
(en haut) ne correspond a` aucune variable, et est e'tiquete' ffl.

219

220 CONCLUSION

ffl
ff fl0

fl

fi

ffi

!
! ?

!
?

?

Nous souhaitons unifier fl et fl0. La premie`re e'tape de l'unification sur les graphes se
contente d'effectuer l'unification de premier ordre des structures, ce qui conduit au
graphe suivant :

ffl
ff

fl

fi

ffi

Ce graphe ne correspond a` aucun type syntaxique car fl est quantifie' a` deux endroits.
Heureusement, les quantificateurs de fl et de ff sont flexibles, ce qui autorise a` de'placer
le quantificateur de fl au noeud racine. Ceci produit le re'sultat suivant :

ffl
ff

fl

fi

ffi

Malheureusement, ce graphe n'est pas bien forme' non plus : il n'est pas possible de
l'e'crire sous la forme d'un type syntaxique. La raison est que fi apparai^t dans la borne
de fl mais est lie' au niveau de ff. Or, fl est lie' au niveau de la racine, et donc fi n'est
pas dans la porte'e de fl. En conse'quence, le quantificateur de fi doit aussi e^tre de'place'
comme suit :

220

CONCLUSION 221

ffl
ff

fl

fi

ffi

Ce graphe repre'sente le type 8 (fi) 8 (fl >= 8 (ffi) fi ! ffi) (fi ! fl) ! fl, qui est la solution
au proble`me d'unification conside're'.

Cet exemple illustre comment l'unification de deux noeuds fl et fl 0 peut avoir des
conse'quences sur des quantificateurs n'ayant pas de rapport direct avec fl ou fl 0 : dans
notre exemple, il est ne'cessaire de de'placer le quantificateur de fi pour obtenir un graphe
bien forme'. Alors que les algorithmes d'unification du premier ordre sont bien connus,
et que l'algorithme d'unification des quantificateurs semble trivial, il reste a` concevoir
un algorithme efficace qui de'tecte les graphes mal forme's et trouve quel quantificateur
bouger. Ceci est probablement l'ope'ration la plus cou^teuse puisque le de'placement
d'un seul quantificateur peut transformer un nombre arbitraire de quantificateurs en
quantificateurs ille'gaux.

Une se'mantique pour les types de MLF. L'interpre'tation des types shallow
comme des ensembles de types du Syste`me F esquisse une se'mantique pour les types de
MLF. Toutefois, comme de'ja` mentionne', cette interpre'tation n'est pas correcte vis a` vis
de la relation d'abstraction. Ainsi, il nous reste a` trouver une se'mantique ade'quate qui
capture le sens des types de MLF, ainsi que le sens de la relation d'abstraction. En effet,
la relation @- est fondamentale pour l'infe'rence de type, et une se'mantique des types doit
e^tre capable de distinguer par exemple 8 (ff = oeid) ff ! ff et 8 (ff = oeid, fi = oeid) ff ! fi.
Un point de de'part a` l'e'laboration d'une se'mantique ade'quate pourrait e^tre les graphes,
comme de'crit ci-dessus.

221

222 CONCLUSION
222
BIBLIOGRAPHIE 223
Bibliographie
[Boe85] H.-J. Boehm. Partial polymorphic type inference is undecidable. In 26th

Annual Symposium on Foundations of Computer Science, pages 339-345.
IEEE Computer Society Press, October 1985.

[BOSW98] Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. Making the future safe for the past: Adding genericity to the java programming
language. In Proc. OPPSLA'98, October 1998.

[Bou59] Nicolas Bourbaki. Livre XI, Ele'ments de Mathe'matique, Alge`bre, Chap 4:

Polynomes et Fractions Rationnelles. Hermann, 1959.

[Car88] Luca Cardelli. A semantics of multiple inheritance. Information and Computation, 76(2-4):138-164, 1988.

[Car93] Luca Cardelli. An implementation of FSub. Research Report 97, Digital

Equipment Corporation Systems Research Center, 1993.

[CC90] Felice Cardone and Mario Coppo. Two extensions of Curry's type inference

system. In Logic and Computer Science, pages 19-76. Academic Press, 1990.

[CDC78] Mario Coppo and Mariangiola Dezani-Ciancaglini. A new type-assignment

for *-terms. Archiv Math. Logik, 19:139-156, 1978.

[CDCS79] Mario Coppo, Mariangiola Dezani-Ciancaglini, and Patrick Salle'. Functional characterization of some semantic equalities inside *-calculus. In
Hermann A. Maurer, editor, Proceedings of the 6th Colloquium on Automata, Languages and Programming, volume 71 of LNCS, pages 133-146,
Graz, Austria, July 1979. Springer.

[Cos95] Roberto Di Cosmo. Isomorphisms of Types: from lambda-calculus to information retrieval and language design. Birkhauser, 1995.

[DHKP96] Gilles Dowek, The're`se Hardin, Claude Kirchner, and Frank Pfenning.

Higher-order unification via explicit substitutions: the case of higher-order
patterns. In M. Maher, editor, Joint international conference and symposium on logic programming, pages 259-273, 1996.

223

224 BIBLIOGRAPHIE
[DM82] Luis Damas and Robin Milner. Principal type-schemes for functional programs. In Proceedings of the Ninth ACM Conference on Principles of Programming Langages, pages 207-212, 1982.

[Gar02] Jacques Garrigue. Relaxing the value-restriction. Presented at the third

Asian workshop on Programmaming Languages and Systems (APLAS),
2002.

[Gir72] Jean-Yves Girard. Interpre'tation fonctionnelle et e'limination des coupures

de l'arithme'tique d'ordre supe'rieur. The`se d'e'tat, University of Paris VII,
1972.

[GR88] P. Giannini and S. Ronchi Della Rocca. Characterization of typings in polymorphic type discipline. In Third annual Symposium on Logic in Computer
Science, pages 61-70. IEEE, 1988.

[GR99] Jacques Garrigue and Didier Re'my. Extending ML with Semi-Explicit

higher-order polymorphism. Journal of Functional Programming, vol 155,
pages pages 134-169, 1999. A preliminary version appeared in TACS'97.

[Hen93] Fritz Henglein. Type inference with polymorphic recursion. ACM Transactions on Programming Languages and Systems, 15(2):253-289, 1993.

[HP99] Haruo Hosoya and Benjamin C. Pierce. How good is local type inference?

Technical Report MS-CIS-99-17, University of Pennsylvania, June 1999.

[Jim95] Trevor Jim. Rank-2 type systems and recursive definitions. Technical Report MIT/LCS/TM-531, Massachusetts Institute of Technology, Laboratory for Computer Science, November 1995.

[Jim96] Trevor Jim. What are principal typings and what are they good for? In

ACM, editor, ACM Symposium on Principles of Programming Languages
(POPL), St. Petersburg Beach, Florida, pages 42-53, 1996.

[Jim00] Trevor Jim. A polar type system. In Electronic Notes in Theoretical Computer Science, 2000.

[JS04] S. Peyton Jones and M. Shields. Practical type inference for arbitrary-rank

types, 2004.

[JWOG89] Jr. James William O'Toole and David K. Gifford. Type reconstruction with

first-class polymorphic values. In SIGPLAN '89 Conference on Programming Language Design and Implementation, Portland, Oregon, June 1989.
ACM. also in ACM SIGPLAN Notices 24(7), July 1989.

[KW94] Assaf J. Kfoury and Joe B. Wells. A direct algorithm for type inference

in the rank-2 fragment of the second-order lambda -calculus. In ACM
Conference on LISP and Functional Programming, 1994.

224

BIBLIOGRAPHIE 225
[KW99] Assaf J. Kfoury and Joe B. Wells. Principality and decidable type inference

for finite-rank intersection types. In ACM Symposium on Principles of
Programming Languages (POPL), pages 161-174. ACM, January 1999.

[LDG+02] Xavier Leroy, Damien Doligez, Jacques Garrigue, Didier Re'my, and Je'ro^me

Vouillon. The Objective Caml system, documentation and user's manual release 3.05. Technical report, INRIA, July 2002. Documentation distributed with the Objective Caml system.

[LO94a] Konstantin La"ufer and Martin Odersky. Polymorphic type inference and

abstract data types. ACM Transactions on Programming Languages and
Systems (TOPLAS), 16(5):1411-1430, September 1994. An earlier version
appeared in the Proceedings of the ACM SIGPLAN Workshop on ML and
its Applications, 1992, under the title "An Extension of ML with First-Class
Abstract Types".

[LO94b] Konstantin La"ufer and Martin Odersky. Polymorphic type inference and

abstract data types. ACM Transactions on Programming Languages and
Systems, 16(5):1411-1430, September 1994.

[Mil78] R. Milner. A theory of type polymorphism in programming. Journal of

Computer and System Sciences, 17:348-375, December 1978.

[Mil92] Dale Miller. Unification under a mixed prefix. Journal of Symbolic Computation, 14:321-358, 1992.

[Mit83] John C. Mitchel. Coercion and type inference. In ACM Symp. on Priciples

of Programming Languages, pages 175-185. ACM, 1983.

[Mit88] John C. Mitchell. Polymorphic type inference and containment. Information and Computation, 2/3(76):211-249, 1988.

[Oka98] Chris Okasaki. Purely Functional Data Structures. Cambridge University

Press, Cambridge, England, 1998.

[OL96] Martin Odersky and Konstantin La"ufer. Putting type annotations to work.

In Proceedings of the 23rd ACM Conference on Principles of Programming
Languages, pages 54-67, January 1996.

[OSW99] Martin Odersky, Martin Sulzmann, and Martin Wehr. Type inference with

constrained types. Theory and Practice of Object Systems, 5(1):35-55, 1999.

[OZZ01] Martin Odersky, Christoph Zenger, and Matthias Zenger. Colored local

type inference. ACM SIGPLAN Notices, 36(3):41-53, March 2001.

[Pfe88] Frank Pfenning. Partial polymorphic type inference and higher-order unification. In Proceedings of the ACM Conference on Lisp and Functional
Programming, pages 153-163. ACM Press, July 1988.

225

226 BIBLIOGRAPHIE
[Pfe93] Frank Pfenning. On the undecidability of partial polymorphic type reconstruction. Fundamenta Informaticae, 19(1,2):185-199, 1993. Preliminary
version available as Technical Report CMU-CS-92-105, School of Computer Science, Carnegie Mellon University, January 1992.

[Pie91] Benjamin C. Pierce. Programming with Intersection Types and Bounded

Polymorphism. PhD thesis, Carnegie Mellon University, December 1991.
Available as School of Computer Science technical report CMU-CS-91-205.

[Pot80] Garrell Pottinger. A type assignment for the strongly normalizable *-terms.

In To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and
Formalism, pages 561-577. Academic Press, New York, 1980.

[Pot98a] Franc,ois Pottier. A framework for type inference with subtyping. In Proceedings of the third ACM SIGPLAN International Conference on Functional
Programming (ICFP'98), pages 228-238, September 1998.

[Pot98b] Franc,ois Pottier. Synthe`se de types en pre'sence de sous-typage: de la the'orie

a` la pratique. PhD thesis, Universite' Paris 7, July 1998.

[PT98] Benjamin C. Pierce and David N. Turner. Local type inference. In Proceedings of the 25th ACM Conference on Principles of Programming Languages, 1998. Full version in ACM Transactions on Programming Languages
and Systems (TOPLAS), 22(1), January 2000, pp. 1-44.

[Re'm92] Didier Re'my. Extending ML type system with a sorted equational theory.

Research Report 1766, Institut National de Recherche en Informatique et
Automatisme, Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France,
1992.

[Re'm94] Didier Re'my. Programming objects with ML-ART: An extension to ML

with abstract and record types. In Masami Hagiya and John C. Mitchell,
editors, Theoretical Aspects of Computer Software, volume 789 of Lecture
Notes in Computer Science, pages 321-346. Springer-Verlag, April 1994.

[Rey74] John C. Reynolds. Towards a theory of type structure. In Proc. Colloque sur

la Programmation, pages 408-425, New York, 1974. Springer-Verlag LNCS
19.

[Sal82] P. Salle'. Une extension de la theorie des types en *-calcul. In Lecture Notes

in Computer Science No. 62, pages 398-410. Springer-Verlag, 1982.

[Sch98] Aleksy Schubert. Second-order unification and type inference for Churchstyle polymorphism. In Conference Record of POPL 98: The 25TH ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages,
San Diego, California, pages 279-288, New York, NY, 1998.

226

BIBLIOGRAPHIE 227
[Sim03] Vincent Simonet. The Flow Caml System: documentation and user's manual. Technical Report 0282, Institut National de Recherche en Informatique et en Automatique (INRIA), July 2003. cflINRIA.

[Wel94] J. B. Wells. Typability and type checking in the second order *-calculus are

equivalent and undecidable. In Ninth annual IEEE Symposium on Logic in
Computer Science, pages 176-185, July 1994.

[Wel96] Joe B. Wells. Type Inference for System F with and without the Eta Rule.

PhD thesis, Boston University, 1996.

[Wel02] J. B. Wells. The essence of principal typings. In Proc. 29th Int'l Coll.

Automata, Languages, and Programming, volume 2380 of LNCS, pages 913-
925. Springer-Verlag, 2002.

[Wri95] Andrew K. Wright. Simple imperative polymorphism. Lisp and Symbolic

Computation, 8(4):343-355, 1995.

227

228 BIBLIOGRAPHIE
228

229
Quatrie`me partie

Appendice

229

231
Appendix A
Preuves (de'tails techniques)

Felix qui potuit rerum cognescere causas -- Virgile Ge'orgiques II, 489
Proof of Property 1.5.6
Property i: It is by induction on the number of universal quantifiers appearing in oe. If
oe has no universal quantifiers, then oe is ? or o/ , and we get the result by Rule Eq-Refl
since nf(oe) is oe itself. Otherwise, oe is 8 (ff \Pi  oe1) oe2, where oe1 and oe2 have strictly less
universal quantifiers than oe. We proceed by case analysis:

ffi Case nf(oe2) is ff: Then nf(oe) is nf(oe1) (1), and oe2 j ff by induction hypothesis. By
Property 1.5.3.v (page 50), (ff \Pi  oe1) oe2 j ff also holds. Hence, oe j oe1 (2) holds by rules
R-Context-R and Eq-Var. By induction hypothesis on oe1, we have oe1 j nf(oe1) (3),
therefore oe j nf(oe1) holds by R-Trans, (2), and (3). By (1), we get oe j nf(oe).

ffi Case ff /2 ftv(oe2): then, nf(oe) is nf(oe2) (4). We have oe j oe2 by Eq-Free, thus
oe j nf(oe2) holds by induction hypothesis and R-Trans. By (4), this means oe j nf(oe).

ffi Case nf(oe1) is o/1: We have oe2 j nf(oe2) by induction hypothesis on oe2, thus oe j
8 (ff\Pi oe1) nf(oe2) (5) holds by R-Context-R and Property 1.5.3.v (page 50). Moreover,
we have oe1 j o/1 by induction hypothesis on oe1, hence we have oe j nf(oe2)[o/1/ff] by Rule
Eq-Mono? on (5) and R-Trans. We conclude by observing that nf(oe) is nf(oe2)[o/1/ff].

ffi Otherwise, nf(oe) is 8 (ff \Pi  nf(oe1)) nf(oe2). By induction hypothesis, oe1 j nf(oe1)
and oe2 j nf(oe2). Hence, (ff \Pi  oe1) oe2 j nf(oe2) holds by Property 1.5.3.v (page 50). We
conclude by rules R-Context-R, R-Context-R and R-Trans.
Property ii: It is a consequence of Properties i and 1.5.4.iii (page 51).
Property iii: It is shown by induction on the number of universal quantifiers appearing
in oe. If oe has no universal quantifiers, then oe is ? or o/ , and we get the expected result
since nf(oe) is oe itself and nf(`(oe)) is `(oe). Otherwise, oe is 8 (ff \Pi  oe1) oe2, where oe1 and
oe2 have strictly less universal quantifiers than oe. By alpha-conversion, we can assume
ff /2 dom(`) [ codom(`), thus `(oe) = 8 (ff \Pi  `(oe1)) `(oe2). We proceed by case analysis:

231

232 Preuves (de'tails techniques)

ffi Case nf(oe2) is ff: By induction hypothesis, nf(`(oe2)) is `(nf(oe2)), that is ff. Hence,
nf(`(oe)), that is, nf(8 (ff \Pi  `(oe1)) `(oe2)), is by definition nf(`(oe1)). By induction hypothesis, nf(`(oe1)) is `(nf(oe1)), thus nf(`(oe)) is `(nf(oe1)), that is, `(nf(oe)).

ffi Case nf(oe1) is o/1: Let `0 be [o/1/ff] and `00 be [`(o/1)/ff]; since ff /2 dom(`)[codom(`),
we have ` ffi `0 = `00 ffi ` (6). By induction hypothesis nf(`(oe1)) is `(o/1), thus nf(`(oe))
is by definition `00(nf(`(oe2))). By induction hypothesis, it is also `00(`(nf(oe2))), that is
` ffi `0(nf(oe2)) by (6). We conclude by observing that `0(nf(oe2)) is nf(oe).

ffi Case ff /2 ftv(oe2): Since ff /2 codom(`), we have ff /2 ftv(`(oe2)). Hence, nf(`(oe)) is
by definition nf(`(oe2)) and we conclude directly by induction hypothesis.

ffi Otherwise, we know that nf(oe2) is not ff, thus, by induction hypothesis, nf(`(oe2))
is not ff. Moreover, nf(oe1) is not a monotype o/1, thus, by induction hypothesis,
nf(`(oe1)) is not a monotype. Additionally, ff 2 ftv(oe2), thus ff 2 ftv(`(oe2)). Consequently, nf(`(oe)) is by definition 8 (ff \Pi  nf(`(oe1))) nf(`(oe2)). By induction hypothesis,
it is equal to 8 (ff \Pi  `(nf(oe1))) `(nf(oe2)), that is, `(nf(oe)).
Property iv: It is shown by induction on the number of universal quantifiers appearing
in oe. If oe has no universal quantifiers, then oe is ? or o/ , and we get the expected result
since nf(oe) is oe itself. Otherwise, oe is 8 (ff \Pi  oe1) oe2, where oe1 and oe2 have strictly less
universal quantifiers than oe. We proceed by case analysis:

ffi Case nf(oe2) is ff: then, nf(oe) is nf(oe1), which is in normal form by induction
hypothesis.

ffi Case nf(oe1) is o/1: let ` be [o/1/ff]; by definition, nf(oe) is `(nf(oe2)), that is, nf(`(oe2))
by Property iii. Since nf(`(oe2)) is in normal form by induction hypothesis, we conclude
that nf(oe) is normal form.

ffi Case ff /2 ftv(oe2): then, nf(oe) is nf(oe2), which is in normal form by induction
hypothesis.

ffi Otherwise, nf(oe) is 8 (ff \Pi  nf(oe1)) nf(oe2). We know that nf(oe2) is not ff, that
nf(oe1) is not a monotype o/1, and that ff 2 ftv(oe2). By Property i, we have nf(oe2) j oe2.
Hence, by Property 1.5.4.iii (page 51), we have ff 2 ftv(nf(oe2)). Additionally, by
induction hypothesis, nf(nf(oe1)) is nf(oe1) and nf(nf(oe2)) is nf(oe2). Hence, nf(nf(oe)) is
nf(8 (ff \Pi  nf(oe1)) nf(oe2)), that is by definition 8 (ff \Pi  nf(oe1)) nf(oe2), that is nf(oe). Hence,
nf(oe) is in normal form.

Proof of Corollary 1.5.10
Directly, if (;) bQ(oe1) j bQ(oe2) holds, then, by Property 1.5.3.v (page 50), we have
(Q) bQ(oe1) j bQ(oe2). Since we have (Q) oe1 j bQ(oe1) and (Q) oe2 j bQ(oe2) by Eq-Mono,
we conclude directly using R-Trans twice. Conversely, if we have (Q) oe1 j oe2, then by

Lemma 1.5.9 we know that nf( bQ(oe1)) ss nf( bQ(oe2)) holds. Hence, nf( bQ(oe1)) j nf( bQ(oe2))
holds by Property 1.5.3.iii (page 50). We conclude by observing that bQ(oe1) j nf( bQ(oe1))
and nf( bQ(oe2)) j bQ(oe2) hold by Property 1.5.6.i (page 53).

232

233
Proof of Property 2.1.2
Property i: Reflexivity: immediate Transitivity: Assume we have t1 6/ t2 (1) and
t2 6/ t3 (2). We have dom(t1) ` dom(t2) ` dom(t3), thus dom(t1) ` dom(t3). Besides,
for all u 2 dom(t1), if t1/u 6= t3/u, then either t1/u = t2/u, or t1/u 6= t2/u. In the
second case, we have t1/u = ? by definition of (1), which is the expected result. In
the first case, we must have t2/u 6= t3/u, thus t2/u = ? by definition of (2), and
t1/u = t2/u = ? holds. Antisymmetry: Assume t1 6/ t2 (3) and t2 6/ t1 (4).
We have dom(t1) ` dom(t2) and dom(t2) ` dom(t1), thus dom(t1) = dom(t2) holds.
Besides, for any u in dom(t1), if we have t1/u 6= t2/u, then t1/u = ? by definition
of (3). However, we then also have t2/u 6= t1/u, which implies t2/u = ? by definition
of (4). Consequently, t1/u = ? = t2/u, which is a contradiction. As a consequence,
t1/ = t2/, that is, t1 = t2.

Property ii: Assume we have t1 6/ t2 (1) By definition, we have dom(t1) ` dom(t2) (2).
Let ` be a substitution. Note that dom(t) ` dom(`(t)) (3) holds for any t. Let u be
in dom(`(t1)). Either u is in dom(t1), or u is of the form u1u2, with t1/u1 = ff (4)
and `(ff)/u2 = t1/u. In the first case, we know that u is in dom(t2) from (2). Hence,
u is in dom(`(t2)) by (3). In the second case, we know that u1 is in dom(t2) from (2),
and that t2/u1 is ff by definition of (1) and by (4). Hence, u1u2 is in dom(`(t2)).
Consequently, we have shown that dom(`(t1)) ` dom(`(t2)) holds (5). Let u be such
that `(t1)/u 6= `(t2)/u (6). Either u is in dom(t1), or u is of the form u1u2, with
t1/u1 = ff and `(ff)/u2 = t1/u. In the first case, u is in dom(t2) by (2), and t1/u 6= t2/u,
which implies t1/u = ? by definition of (1). Hence, `(t1)/u = ?, since ? is not
substituted by `. In the second case, t1/u1 = ff, thus t2/u2 = ff by definition of (1).
Hence, we have `(t1)/u1u2 = `(ff)/u2 = `(t2)/u1u2, that is `(t1)/u = `(t2)/u. This is
a contradiction with (6). Hence, this second case cannot occur. In summary, we have
shown that whenever `(t1)/u 6= `(t2)/u, then `(t1)/u = ?. With (5), this implies that
we have `(t1) 6/ `(t2).

Property iii: We assume we have t1 6/ t2 (1) and a skeleton t. By definition, dom(t1) `
dom(t2) (2) holds. Let t01 be t[t1/ff] and t02 be t[t2/ff]. Note that we have dom(o/ ) `
dom(t1) and dom(t) ` dom(t2) (3). We have to show that t01 6/ t02 holds. Let u be
in dom(t01). Either u is in dom(t), or u is of the form u1u2 with t/u1 = ff (4) and
t1/u2 = t01/u. In the first case, u is in dom(t02) by (3). In the second case, we have u2 2
dom(t1), hence u2 2 dom(t2) (5) by (2). Then u1u2 is in dom(t[t2/ff]) by (4) and (5).
We have shown that dom(t01) ` dom(t02) (6). Let u be such that t01/u 6= t02/u (7).
Either u is in dom(t), or u is of the form u1u2 with t/u1 = ff and t1/u2 = t01/u. In
the first case, we necessarily have t/u = ff (otherwise, t01/u = t/u = t02/u). Hence,
t01/u = t1/ffl and t02/u = t2/ffl, thus we have t1/ffl 6= t2/ffl from (7), which implies t1/ffl = ?
by definition of (1). This leads to t01/u = ?. In the second case, we have t01/u = t1/u2

233

234 Preuves (de'tails techniques)
and t02/u = t2/u2. Hence, t1/u2 6= t2/u2 holds from (7), which implies t1/u2 = ? by
definition of (1). This leads to t01/u = ?. In both cases, t01/u = ?. With (6), this
implies that we have t01 6/ t02.

Proof of Lemma 2.1.4
By induction on the derivation of (Q, ff \Pi  oe, Q1) oe1 "" oe2. By hypothesis, we have
(8 (Q1) oe1)/u = ff (1).

ffi Case A-Equiv: we have (Q, ff \Pi  oe, Q1) oe1 j oe2, thus (Q, ff \Pi  oe) 8 (Q1) oe1 j 8 (Q1)
oe2 (2) holds by Rule R-Context-R. Let ` be "(Q, ff \Pi  oe). Since oe /2 T , we have
ff /2 dom(`). By well-formedness of (Q, ff \Pi  oe), we have Q closed and ff /2 dom(Q), thus
ff /2 codom(`) (3). By Corollary 1.5.10 applied to (2), we have `(8 (Q1) oe1) j `(8 (Q1)
oe2). By Property 1.5.11.vi (page 56), we have `(8 (Q1) oe1)/ = `(8 (Q1) oe2)/ (4).
By (1), we have `(8 (Q1) oe1)/u = `(ff)/ffl = ff and `(8 (Q1) oe2)/u = ff by (4), which
implies (8 (Q1) oe2)/u = ff, by (3).

ffi Case R-Trans: By induction hypothesis.
ffi Case R-Trans: By induction hypothesis.
ffi Case I-Hyp: we have (Q, ff \Pi  oe, Q1) oe1 v fi with (fi \Pi 0 oe1) 2 (Q, ff \Pi  oe, Q1). If
(fi \Pi 0 oe1) 2 (Q, ff \Pi  oe), necessarily ftv(oe1) # {ff} [ dom(Q1) by well-formedness of
(Q, ff \Pi  oe, Q1), thus 8 (Q1) oe1 j oe1 (by Eq-Free) and ff /2 ftv(8 (Q1) oe1), which is a
contradiction with (1). Hence, fi 2 dom(Q1). Therefore, 8 (Q1) oe1 j 8 (Q1) fi by EqVar?. Consequently, (8 (Q1) fi)/u = (8 (Q1) oe1)/u = ff by Property 1.5.4.i (page 51)
and (1).

ffi Case A-Hyp: similar to I-Hyp.
ffi Case R-Context-R: By induction hypothesis.
ffi Case R-Context-R: By induction hypothesis.
ffi Case R-Context-Flexible: We have (Q, ff \Pi  oe, Q1) 8 (fi \Pi  oe1) oe0 "" 8 (fi \Pi  oe2) oe0
and the premise is (Q, ff \Pi  oe, Q1) oe1 "" oe2 (5). Besides, (8 (Q1) 8 (fi \Pi  oe1) oe0)/u = ff by
hypothesis (1). By Property 1.3.3.i (page 42), we have \Theta Q1(proj(oe0)[proj(oe1)/ff])/u =
ff. If u is of the form u1u2 with oe0/u1 = fi, then \Theta Q1(proj(oe1))/u2 = ff, thus 8 (Q1)
oe1/u2 = ff by Property 1.3.3.i (page 42). Hence, by induction hypothesis on (5), we get
(8 (Q1) oe2)/u2 = ff, which implies (8 (Q1) 8 (fi \Pi  oe2) oe0)/u1u2 = ff by Property 1.3.3.i
(page 42). Otherwise, we have (8 (Q1) 8 (fi \Pi  oe1) oe0)/u = (8 (Q1) oe0)/u = (8 (Q1)
8 (fi \Pi  oe2) oe0)/u, which is the expected result.

ffi Case R-Context-Rigid is similar to R-Context-Flexible.
ffi Case I-Abstract: By induction hypothesis.
ffi Case I-Bot cannot occur since (8 (Q1) ?)/u = ff is not possible.
ffi Case I-Rigid is immediate.

234

235
Proof of Property 2.1.5
Property i: If there exists u 2 dom(oe) such that oe/u = ?, then by Property 1.5.4.i
(page 51), oe is not equivalent to a type (no type o/ is such that o/ /u = ?). Hence, by
Property 1.5.11.ii (page 56), oe is not in T . Conversely, assume that oe is not equivalent
to a type. We have to show that there exists u such that oe/u = ?. The proof is
by induction on the structure of oe. If oe is ?, we get the result by taking u = ffl.
Otherwise, oe is of the form 8 (ff \Pi  oe1) oe2. If both oe1 and oe2 are equivalent to types o/1
and o/2, then by Rule Eq-Mono, oe would be equivalent to a monotype o/2[o/ /ff], which
is not possible by hypothesis. Hence, oe1 or oe2 is not equivalent to a type. If oe2 is not
equivalent to a type, then by induction hypothesis, there exists u such that oe2/u = ?,
thus oe/u = ?. If oe2 is equivalent to a type, then necessarily oe1 is not and ff 2 dom(oe2)
(otherwise oe would be equivalent to oe2 by Rule Eq-Free). Hence, there exists u2
such that oe2/u2 = ff. Furthermore, by induction hypothesis, there exists u1 such that
oe1/u1 = ?. Consequently, oe/u2u1 = ?.

Property ii: Directly, by Property 1.5.4.i (page 51). Conversely, we assume oe/ffl is ff.
Since ff is of arity 0, we must have dom(oe) = {ffl}. Hence, there is no u 2 dom(oe) such
that oe/u = ?. By Property i, this implies oe 2 T . Consequently, nf(oe) = o/ such that
o/ / = oe/ = ff/, by Properties 1.5.6.i (page 53) and 1.5.4.i (page 51). This implies o/ = ff
(o/ and ff are viewed as skeletons). Hence, nf(oe) = ff, that is, oe j ff by Property 1.5.6.i
(page 53).

Property iii: It is shown by induction on the structure of oe. By hypothesis, we have
oe/ffl = ? (1). If oe is ?, the result is immediate. Otherwise, by Property i and (1), we
know that oe is not a type o/ . If oe is 8 (ff \Pi  oe1) oe2, either oe2/ffl = ? and we conclude by
induction hypothesis and Eq-Free, either oe2/ffl = ff and oe1/ffl = ? (2). In the latter
case, we get oe1 j ? (3) by induction hypothesis on (2) and oe2 j ff (4) by Property ii,
thus we conclude that 8 (ff \Pi  oe1) oe2 j ? by R-Trans, R-Context-L, R-Context-R,
Eq-Var, (3), and (4). This is the expected result.

Proof of Property 2.2.2
Property i : It is shown by induction on the size of Q.

Property ii: We show by induction on the size of Q that Q[ff] = fi.
Property iii : It is shown by structural induction on Q. By hypothesis, we have bQ(ff) /2
V (1). If Q is (Q0, fi \Pi  oe), with fi 6= ff, then we have ff 2 dom(Q0), cQ0(ff) = bQ(ff),
and Q(ff) = Q0(ff), thus we get the result by induction hypothesis. If Q is (Q0, ff \Pi  oe)
and nf(oe) = fi, then we have fi 2 dom(Q0) by well-formedness and (Q) ff j fi (2) by

235

236 Preuves (de'tails techniques)
Property 1.5.6.i (page 53) and Eq-Mono. Additionally, we have Q[ff] = Q0[fi], thus
Q(ff) = Q0(fi) (3) holds. Moreover, we have bQ(ff) = cQ0(fi), hence cQ0(fi) /2 V holds by
(1). By induction hypothesis, (Q0) fi j Q0(fi) holds. Hence, we have (Q) fi j Q0(fi) (4)
by Property 1.5.3.v (page 50). Finally, (Q) ff j Q(ff) holds by (2), (4), and (3). This is
the expected result. In the last case, Q is (Q0, ff \Pi  oe), and oe /2 #. Then Q[ff] is ff, thus
Q(ff) is oe. Moreover, if oe /2 T , then bQ(ff) is ff, which is a contradiction. Consequently,
oe 2 T , and bQ(ff) j oe (5) by Definition 1.5.8 and Property 1.5.6.i (page 53). Hence,
by Eq-Mono and (5), we get (Q) ff j oe, that is, (Q) ff j Q(ff).

Property iv: It is shown by induction on the size of Q. Necessarily, Q is of the form
(Q1, ff \Pi  oe, Q2). By definition, Q[ff] is Q1[fi] if nf(oe) is fi and ff otherwise (1). In the
first case, Q(ff) is Q1(fi) by definition and bQ(ff) is cQ1(fi), hence we get the expected
result by induction hypothesis on Q1. In the second case, Q(ff) is oe (2). Directly, we

have by hypothesis Q(ff) /2 T , thus (2) implies ff /2 dom( bQ), that is, bQ(ff) = ff, which
is the expected result. Conversely, we have by hypothesis Q(ff) 2 T , that is oe 2 T .

Then bQ(ff) is cQ1(nf(oe)) (3). By hypothesis (1), nf(oe) is not in #, hence, neither isc
Q1(nf(oe)). By (3), this implies bQ(ff) /2 #. This is the expected result.

Property v: By Property i, we have (Q) Q[ff] j Q[fi] (1). If Q[ff] is Q[fi], then
Q(ff) = Q(fi) by definition, which gives the expected result by Eq-Refl. Otherwise,
by Corollary 1.5.10 and (1), we have bQ(Q[ff]) = bQ(Q[fi]). If bQ(Q[ff]) is a type variable
fl, then Q(Q[ff]) = Q(fl) by Property ii, that is, Q(ff) = Q(fl). Similarly, Q(fi) = Q(fl),
thus Q(ff) = Q(fi) and the result holds by Eq-Refl. Otherwise, bQ(Q[ff]) /2 # and by
Property iii, we have (Q) Q[ff] j Q(Q[ff]), that is, (Q) Q[ff] j Q(ff) (2). Similarly,
(Q) Q[fi] j Q(fi) (3). By (1), (2), and (3), we get (Q) Q(ff) j Q(fi). This is the
expected result.

Property vi: By hypothesis, (Q) ff "" oe (1) holds. By Lemma 2.1.6 on (1), we must have
(Q) oe j ff. By Lemma 1.5.9 and Property 1.5.6.iii (page 53), we have bQ(nf(oe)) ss bQ(ff),
that is bQ(nf(oe)) = bQ(ff) (2) since bQ(ff) is a monotype (does not have any quantifier). By hypothesis, Q(ff) /2 T . Hence, by Property iv, we have bQ(ff) 2 #, that is,b
Q(ff) 2 dom(Q) since Q is closed by well-formedness of (1). Hence, bQ(nf(oe)) 2 dom(Q)
holds from (2). Necessarily, nf(oe) is a type variable fi such that bQ(fi) 2 dom(Q). By
Property iv, we get Q(fi) /2 T .

Proof of Lemma 2.3.1
We first prove the two following results, namely (1) and (2):

For any oe, there exists a restricted derivation of oe j nf(oe).

236

237
If oea and oeb are in normal forms, and if oea ss oeb holds, then there exists a
restricted derivation of oea j oeb.

Proof sketch of (1): Property 1.5.6.i states that oe j nf(oe) holds. We have to show
that this derivation is, moreover, restricted. Actually, the proof of Property 1.5.6.i
(page 53) is still appropriate. Indeed, the proof of Property 1.5.6.i (page 53) does not
use R-Context-L, and builds only restricted derivations. \Lambda 
Proof sketch of (2): The proof of oea j oeb only uses rules R-Context-R, R-ContextL, and Eq-Comm. Every occurrence of Rule R-Context-L is necessarily restricted
since oea and oeb are in normal form: for instance, if oea is 8 (ff \Pi  oe1) oe, we must have
ff 2 ftv(oe), nf(oe) 6= ff, and nf(oe) 6= ?. \Lambda 

We first prove the result for a derivation of (Q) oe1 j oe2: By Lemma 1.5.9, we
have bQ(nf(oe1)) ss bQ(nf(oe2)). Hence, bQ(nf(oe1)) j bQ(nf(oe2)) (3) holds and is restricted
by Result (2). By Property 1.5.6.iii (page 53), (3) can also be written nf( bQ(oe1)) j
nf( bQ(oe2)) (4). By Result (1), we have restricted derivations of bQ(oe1) j nf( bQ(oe1)) (5)
and nf( bQ(oe2)) j bQ(oe2) (6). Besides, (Q) oe1 j bQ(oe1) (7) holds by Eq-Mono and is
restricted. Similarly, (Q) bQ(oe2) j oe2 (8) is restricted. By Property 1.5.3.v (page 50),
R-Trans, (7), (5), (4), (6), and (8), we have a restricted derivation of (Q) oe1 j oe2.
This is the expected result.

In summary, the following rule is admissible:

Equiv-R

(Q) oe1 j oe2

(Q) oe1 "" oe2 (restricted)

Then we prove the result for an abstraction or instantiation derivation. The proof
is by induction on the derivation.

ffi Case I-Bot: We proceed by case analysis.

Subcase nf(oe) is ?: Then (Q) ? j oe holds by Property 1.5.6.i (page 53). We
conclude by Rule Equiv-R.

Subcase oe 2 V: Then nf(oe) = ff by definition. By Property 1.5.6.ii (page 53),
we have ff 2 ftv(oe). By well-formedness, we must have ff 2 dom(Q). Let ff0 be Q[ff].
We have (ff0 \Pi 0 oe0) 2 Q, oe0 /2 V (9), and (Q) ff j ff0 (10) by Property 2.2.2.i (page 69).
By Rule Equiv-R and (10), we have a restricted derivation of (Q) ff "" ff0 (11).
Moreover, if nf(oe0) is not ?, we have a restricted derivation of (Q) ? v oe0 (12) by
I-Nil and (9). If nf(oe0) is ?, (Q) ? j oe0 by Property 1.5.6.i (page 53), and (12) holds
by Equiv-R. In both cases, we have a restricted derivation of (12). If oe0 is in T , then
(Q) oe0 v ff0 (13) holds by Eq-Mono and I-Equiv?. Otherwise, (13) holds by I-Hyp.
In both cases, (13) is restricted. From (12), (13), (11) and R-Trans, we get a restricted
derivation of (Q) ? v ff This is the expected result.

237

238 Preuves (de'tails techniques)

Otherwise, the judgment is already restricted.
ffi Case R-Context-Rigid and R-Context-Flexible: The premise is the judgment (Q) oe1 "" oe2 (14) and the conclusion is (Q) 8 (ff \Pi  oe1) oe "" 8 (ff \Pi  oe2) oe. By
induction hypothesis, we have a restricted derivation of (14). If ff /2 ftv(oe), then
(Q) 8 (ff \Pi  oe1) oe j 8 (ff \Pi  oe2) oe is derivable by Eq-Free and R-Trans, and we conclude
by Equiv-R. If nf(oe) is ff, then (Q) 8 (ff \Pi  oe1) oe j oe1 (15) holds by Property 1.5.6.i
(page 53), R-Context-R, and Eq-Var. Similarly, (Q) 8 (ff \Pi  oe2) oe j oe2 (16) holds.
By Equiv-R, (15), (16), and (14), we have a restricted derivation of (Q) 8 (ff \Pi  oe1) oe ""
8 (ff \Pi  oe2) oe. This is the expected result. If nf(oe) is ?, then (Q) 8 (ff \Pi  oe1) oe j ? and
(Q) 8 (ff \Pi  oe2) oe j ? hold. By R-Trans and Equiv-R, we have a restricted derivation
of (Q) 8 (ff \Pi  oe1) oe "" 8 (ff \Pi  oe2) oe. Otherwise, the judgment is restricted, and there
exists a restricted derivation of the premise (14). This is the expected result.

ffi Case R-Context-R: If (Q, ff\Pi oe) oe1 j oe2 holds, then (Q) 8 (ff\Pi oe) oe1 j 8 (ff\Pi oe) oe2
holds by R-Context-R, and we get the expected result by A-Equiv or I-Equiv?.

ffi Case I-Rigid: If ff /2 ftv(oe), then we can derive (Q) 8 (ff >= oe1) oe j oe by EqFree, as well as (Q) oe j 8 (ff = oe1) oe. We conclude by Equiv-R. If oe1 is in T ,
then nf(oe1) is o/1 by definition and we have (Q) 8 (ff >= oe1) oe j oe[o/1/ff] by Eq-Mono,
as well as (Q) oe[o/1/ff] j 8 (ff = oe1) oe. We conclude by Equiv-R. If nf(oe) is ff,
then (Q) 8 (ff >= oe1) oe j oe1 by Property 1.5.6.i (page 53) and Eq-Var, as well as
(Q) oe1 j 8 (ff = oe1) oe. We conclude by Equiv-R. Otherwise, the judgment is already
restricted.

ffi Case A-Hyp: We have (ff1 = oe1) 2 Q. If oe1 2 T , then (Q) oe1 j o/1 (17) holds
for some monotype o/1 by Properties 1.5.11.ii (page 56) and 1.5.3.v (page 50). Hence,
(Q) ff1 j o/1 (18) holds by Eq-Mono. Finally, (Q) ff1 j oe1 by (18), (17), and
R-Trans. By Rule Equiv-R, we get the expected result (Q) oe1 @- ff1.

ffi Case I-Hyp: similar.
ffi All other cases are by induction hypothesis.

Proof of Lemma 2.3.3
We first show the three following properties, then we show the lemma.

1. For any type oe, there exists a thrifty derivation of oe j nf(oe).
2. Any equivalence derivation can be rewritten into a thrifty derivation.
3. Any derivation can be rewritten into a thrifty derivation.
Property 1 : It is by induction on the number of universal quantifiers appearing in oe. If
oe has no universal quantifiers, then oe is ? or o/ , and we get the result by Rule Eq-Refl

238

239
since nf(oe) is oe itself. Otherwise, oe is 8 (ff \Pi  oe1) oe2 (1), where oe1 and oe2 have strictly
less universal quantifiers than oe. We proceed by case analysis:

ffi Case nf(oe2) is ff: Then nf(oe) is nf(oe1), and oe2 j ff holds and is thrifty by induction
hypothesis. By Property 1.5.3.v (page 50), (ff \Pi  oe1) oe2 j ff also holds, and is thrifty.
Hence, 8 (ff \Pi  oe1) oe2 j 8 (ff \Pi  oe1) ff (2) holds by R-Context-R. This equivalence is
thrifty since nf(oe2) and nf(ff) are both ff. We have 8 (ff \Pi  oe1) ff j oe1 by Eq-Var (3).
Since oe is 8 (ff\Pi oe1) oe2 (from (1)), we get oe j oe1 by R-Trans, (2) and (3). By induction
hypothesis we also have a thrifty derivation of oe1 j nf(oe1), therefore oe j nf(oe1) holds
by R-Trans and is thrifty. In the following, we assume nf(oe2) is not ff.

ffi Case nf(oe1) is o/1 (4): We have a thrifty derivation of oe2 j nf(oe2) by induction
hypothesis, thus we get a thrifty derivation of oe j 8 (ff \Pi  oe1) nf(oe2) by R-ContextR. Moreover, we have oe1 j o/1 by induction hypothesis on (4), hence we have oe j
nf(oe2)[o/1/ff] by Rule Eq-Mono? and R-Trans. This derivation is thrifty. We conclude
by observing that nf(oe) is nf(oe2)[o/1/ff].

ffi Case ff /2 ftv(oe2): Then nf(oe) is nf(oe2), and oe j oe2 by Eq-Free, thus we get a
thrifty derivation of oe j nf(oe2) by induction hypothesis and R-Trans.

ffi Otherwise, nf(oe) is 8 (ff \Pi  nf(oe1)) nf(oe2). By induction hypothesis, oe1 j nf(oe1)
and oe2 j nf(oe2). Hence, (ff \Pi  oe1) oe2 j nf(oe2) holds by Property 1.5.3.v (page 50).
By rules R-Context-L, R-Context-R and R-Trans, we get a thrifty derivation of
oe j nf(oe).

Property 2: By hypothesis, we have (Q) oe1 j oe2. By Corollary 1.5.10, we have a
derivation of bQ(oe1) j bQ(oe2) (1). Note that (Q) oe1 j bQ(oe1) (2) is thrifty since it only
uses Eq-Mono. Similarly, (Q) bQ(oe2) j oe2 (3) is thrifty. By Property 1.5.11.i (page 56)
applied to (1), we have nf( bQ(oe1)) ss nf( bQ(oe2)) (4). The derivation of (4) provides a
derivation of nf( bQ(oe1)) j nf( bQ(oe2)) (5) by Property 1.5.3.iii (page 50). Besides, the
derivation of (5) is thrifty: indeed, each occurrence or Rule R-Context-R operates
on normal forms. By Property 1, we have a thrifty derivation of bQ(oe1) j nf( bQ(oe1)) (6)
and nf( bQ(oe2)) j bQ(oe2) (7). By R-Trans, (2), (6), (5), (7), and (3), we get a thrifty
derivation of (Q) oe1 j oe2.

Before going on proving the remaining properties, we prove the following result,
which we refer to as Thrifty-Var.

Assume (ff \Pi  oe) 2 Q. If (Q) oe1 "" oe2 is thrifty, and (Q) oe2 j ff holds
but (Q) oe1 j ff does not hold, then there exists a thrifty derivation of
(Q) oe1 "" oe. Besides, if "" is @-, then \Pi  is rigid.

Proof: By induction on the derivation. None of the equivalence cases occur since
oe1 is not equivalent to ff under Q, while oe2 is.

239

240 Preuves (de'tails techniques)

ffi Case R-Trans The premises are (Q) oe1 "" oe01 (1) and (Q) oe01 "" oe2 (2). Besides,
both derivations are thrifty. If (Q) oe01 j ff, we conclude directly by induction hypothesis
on (1). Otherwise, we know by induction hypothesis on (2) that we have a thrifty
derivation of (Q) oe01 "" oe (3). Hence, by R-Trans, (1), and (3), we have a thrifty
derivation of (Q) oe1 "" oe. Additionally, if "" is @-, then \Pi  is rigid.

ffi Case R-Context-R We have oe1 = 8 (fi \Pi 0 oe0) oe01 (4) and oe2 = 8 (fi \Pi 0 oe0) oe02. The
premise is (Q, fi \Pi 0 oe0) oe01 "" oe02 (5) and is thrifty. By hypothesis, we have (Q) 8 (fi \Pi 0 oe0)
oe02 j ff (6).

Subcase nf(oe02) is fi: By Eq-Var, R-Trans, and (6), we get (Q) oe0 j ff (7).
Moreover, nf(oe01) is not fi (otherwise, we would have (Q) oe1 j ff by Property 1.5.6.i
(page 53), (7), (4), and Eq-Var). Hence, this occurrence of R-Context-R is squandering, which is not possible by hypothesis.

Subcase fi /2 ftv(oe02): We have nf(oe) 6= fi (8) by Property 1.5.6.ii (page 53).
Since by hypothesis this occurrence of R-Context-R or R-Context-R is thrifty, we
must have nf(oe01) 6= fi (9). By Eq-Free, we have (Q) oe02 j ff. By induction hypothesis
on (5), we have a thrifty derivation of (Q, fi \Pi 0 oe0) oe01 "" oe (10). Besides, if "" is @-,
then \Pi  is rigid. By (10), R-Context-R, we get (Q) 8 (fi \Pi 0 oe0) oe01 "" 8 (fi \Pi 0 oe0) oe (11).
This derivation is thrifty since nf(oe01) 6= fi (from (9)) and nf(oe) 6= fi (from (8)). By
Eq-Free, we have (Q) 8 (ff \Pi 0 oe0) oe j oe. Hence, (Q) 8 (ff \Pi 0 oe0) oe "" oe (12) holds by
A-Equiv and I-Abstract, and is thrifty. By R-Trans, (11), and (12), we have a
thrifty derivation of (Q) 8 (fi \Pi 0 oe0) oe01 "" oe. This is the expected result.

Otherwise fi 2 ftv(oe02) (13) and nf(oe02) is not fi (14). We show that oe 2
T . Let ` be bQ. note that fi /2 dom(`) [ codom(`) by well-formedness of (5). By
Corollary 1.5.10 applied to (6), we have `(8 (fi \Pi 0 oe0) oe02) j `(ff) (15). By (13), there
exists an occurrence u such that oe02/u = fi (16). We cannot have oe02 j fi, because
of (14) and Property 1.5.11.i (page 56). By Property 2.1.5.ii (page 67), this implies
oe02/ffl 6= fi. Hence, u is not ffl in (16). As a consequence, oe02/ffl must be a type constructor
g. By Property 1.5.4.i (page 51) applied to (15), we have `(ff)/ffl = g. Hence, ff must
be in dom(`), which means that oe 2 T (17). By Property 1.5.11.ii (page 56), there
exists o/ such that oe j o/ . In summary, (ff \Pi  oe) 2 Q, and oe j o/ (18) holds. We have
(Q) ff j o/ (19) by Eq-Mono, thus (Q) ff j oe (20) holds by R-Trans (18), and
(19). By (6), (20), and R-Trans, we get (Q) oe2 j oe. By Property 2, we have a thrifty
derivation of (Q) oe2 j oe (21). By hypothesis, (Q) oe1 "" oe2 (22) is thrifty, hence
(Q) oe1 "" oe is thrifty by (22), (21), and R-Trans. Besides since oe 2 T (from (17)),
the binding (ff \Pi  oe) is considered flexible and rigid. This is the expected result.

ffi Case A-Hyp: We have (ff1 = oe1) 2 Q, and oe2 is ff1. By hypothesis, (Q) ff1 j
ff (23).

Subcase ff is ff1: We have oe1 = oe and (Q) oe1 @- oe holds by Eq-Refl, and is
thrifty. Besides, "" is @- and \Pi  is rigid.

240

241
Otherwise, oe1 cannot be in T (otherwise we would have (Q) oe1 j ff by (23)
and Eq-Mono). By Property 1.5.11.vii (page 56) and (23), we have bQ(ff1) = bQ(ff),
that is, ff1 = bQ(ff). As a consequence, we must have ff 2 dom( bQ), that is, oe 2 T . Then
(Q) ff j oe (24) holds, thus (Q) ff1 j oe (25) holds by R-Trans, (23), and (24). By
Property 2, (25) is made thrifty. Hence, we get a thrifty derivation of (Q) ff1 @- oe (26)
by A-Equiv. Additionally, (Q) oe1 @- ff1 (27) holds by A-Hyp and is thrifty by
definition. Therefore, we get a thrifty derivation of (Q) oe1 @- oe by R-Trans, (27),
and (26).

ffi Case I-Hyp is similar.
ffi Case I-Bot: Since oe1 is ?, we can derive (Q) oe1 v oe by I-Bot, and it is thrifty.
ffi Case I-Abstract: By induction hypothesis.
ffi Case I-Rigid: We have oe1 = 8 (ff >= oe01) oe02 and oe2 = 8 (ff = oe01) oe02. If ff /2 ftv(oe02),
then oe1 j oe2, which is a contradiction. Since (Q) oe2 j ff holds by hypothesis, we
must have oe2 2 T by Property 1.5.11.x (page 56). Hence, oe02 2 T and oe01 2 T by
Property 2.1.5.i (page 67). Then oe1 j oe2 by Eq-Mono and R-Trans, which is a
contradiction. Hence, this case cannot occur.

ffi Case R-Context-Rigid and R-Context-Flexible: We have oe1 = 8 (fi \Pi  oe01) oe0
and oe2 = 8 (fi \Pi  oe02) oe0. The premise is (Q) oe01 "" oe02 (28), and the conclusion is
(Q) oe1 "" oe2 (29). Moreover, by hypothesis, we have (Q) oe2 j ff (30), that is,
(Q) 8 (fi \Pi  oe02) oe0 j ff (31) holds.

Subcase nf(oe0) is fi: Then (Q) oe02 j ff (32) holds by Eq-Var and (31).
Besides, (Q) oe01 j ff does not hold (33) otherwise, we would have (Q) oe1 j ff. By
induction hypothesis on (28), (32), and (33), we have a thrifty derivation of (Q) oe 01 "" oe,
which gives (Q) 8 (fi \Pi  oe01) oe0 "" 8 (fi \Pi  oe) oe0 by R-Context-Rigid or R-ContextFlexible. Then by Eq-Var, we get (Q) 8 (fi \Pi  oe01) oe0 "" oe. Additionally, by induction
hypothesis on (28), if "" is @-, then \Pi  is rigid.

Subcase fi /2 ftv(oe0): Then (Q) oe1 j oe2 holds by Eq-Free, which is a contradiction.

Otherwise, fi 2 ftv(oe0) and nf(oe0) is not fi. Then oe0/ffl must be a type constructor g. By Property 1.5.11.vi (page 56) and (31), we must have bQ(ff)/ffl = g, which
implies ff 2 dom( bQ), that is oe 2 T (34). As a consequence, (Q) ff j oe (35) holds, thus
(Q) oe2 j oe (36) holds by R-Trans, (30), and (35). By Property 2 and (36), there
exists a thrifty derivation of (Q) oe2 j oe. By A-Equiv or I-Equiv?, (Q) oe2 "" oe (37)
holds and is thrifty. Then (Q) oe1 "" oe holds by R-Trans or R-Trans, (29) and (37),
and is thrifty. Since oe 2 T (from (34)), the binding (ff \Pi  oe) is flexible and rigid. \Lambda 

Thanks to Thrifty-Var, we can prove remaining properties:
Property 3: We show that any derivation with exactly one squandering rule, used last,
can be made thrifty and keep the same conclusion. The result for any given derivation

241

242 Preuves (de'tails techniques)
is immediate by induction on the number of squandering rule of the derivation. By
definition, there are two ways of being a squandering rule:

ffi First case: The conclusion is (Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi oe) oe2, where nf(oe2) is ff and
nf(oe1) is not ff. The last rule used is X-Context-R, thus the premise is a derivation
of (Q, ff \Pi  oe) oe1 "" oe2 (1), which is thrifty by hypothesis. By Property 1.5.6.i (page 53),
oe2 j ff (2) holds.

Subcase oe1 is not equivalent to ff under (Q, ff \Pi  oe): By thrifty-var and
(1), there exists a thrifty derivation of (Q, ff \Pi  oe) oe1 "" oe. Hence, by X-ContextR, we get a thrifty derivation of (Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe (3). Additionally,
(Q) 8 (ff \Pi  oe) oe j oe (4) holds by Eq-Free, and (Q) oe j 8 (ff \Pi  oe) ff (5) by Eq-Var.
Finally, by R-Trans, (4), and (5), and (2), we get (Q) 8 (ff \Pi  oe) oe j 8 (ff \Pi  oe) oe2 (6).
By Property 2, this equivalence can be made thrifty. Hence, by R-Trans, (3), and
(6), we have a thrifty derivation of (Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe2. This is the expected
result.

Subcase oe1 is equivalent to ff under (Q, ff \Pi  oe): By Lemma 2.1.6 and (1), we
get (Q, ff \Pi  oe) oe2 j ff. Hence, (Q) 8 (ff \Pi  oe) oe1 j 8 (ff \Pi  oe) oe2 holds by R-Context-R.
By Property 2, we have a thrifty derivation of (Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe2.

ffi Second case: The conclusion is (Q) 8 (ff \Pi  oe) oe1 "" 8 (ff \Pi  oe) oe2, where nf(oe2) is
not ff and nf(oe1) is ff. By Property 1.5.6.i (page 53), we have oe1 j ff. The premise is
a thrifty derivation of (Q, ff \Pi  oe) oe1 "" oe2. By Lemma 2.1.6, we have (Q, ff \Pi  oe) oe1 j oe2.
Hence, (Q) 8 (ff \Pi  oe) oe1 j 8 (ff \Pi  oe) oe2 holds by R-Context-R, and we conclude
directly by Property 2.

Lemma 2.3.3 (proof sketch): We use Property 3 and we prove that any thrifty derivation
is kept thrifty when using the rewriting rules suggested in the proof of Lemma 2.3.1.
As a matter of fact, none of them uses a right-context rule, thus no squandering rule
can be introduced. This means that the derivation is kept thrifty.

Proof of Corollary 2.3.4
By Property 3, we have a thrifty derivation of (Q) oe1 "" ff (1). If (Q) oe1 j ff
does not hold, then we get the expected result by thrifty-var (to be found in the
preceding proof) and (1). Otherwise, we have (Q) oe1 j ff (2) and oe1 /2 V. This implies
ff 2 dom( bQ) by Corollary 1.5.10 and 1.5.4.i (page 51). Hence, oe 2 T (3). Thus,
(Q) ff j oe (4) holds and (Q) oe1 j oe follows by R-Trans, (2), and (4). Since oe 2 T
(from (3)), the binding (ff \Pi  oe) is flexible and rigid. This is the expected result.

Proof of Property 2.4.3
Property i : It is proved by structural induction on the context.

242

243
Property ii: It is a consequence of Properties i and 2.1.5.i.
Property iii : It is by structural induction on C. The cases [ ], and 8 (ff \Pi  C) oe when
ff /2 ftv(oe) are immediate. The cases level(C) = 0, 8 (ff \Pi  oe) C 0, and 8 (ff \Pi  C0) oea
with oea j ff are by induction hypothesis. The last case is C = 8 (ff \Pi  C 0) oe, when
ff 2 ftv(oe) (1), oe /2 V and level(C 0) 6= 0 (2). By definition of (1), there exists an
occurrence u such that oe/u = ff. By induction hypothesis and (2), C 0 is useful. Let
fi and fl be two fresh variables. By Property i, there exists u0 such that C0(fi)/u0 = fi
and C0(fl)/u0 = fl. Hence, we have C(fi)/uu0 = fi and C(fl)/uu0 = fl. By corollary
1.5.11.vi (page 56), we cannot have C(fi) j C(fl). Hence, C is useful.

Proof of Property 2.4.4
Property i: We prove by structural induction that for any narrow context Cn, we have
level(Cn) = 1 (straightforward). Conversely, we assume that level(C) = 1 (1) We prove
by structural induction on C that C is narrow. If C is [ ], then C is narrow. If C is
8 (ff \Pi  oe) C0 (2), then level(C0) = level(C) by definition of levels, thus level(C 0) = 1 by
(1). Hence, C0 is narrow by induction hypothesis, which implies that C is narrow by (2).
If C is 8 (ff \Pi C0) oeff, where oeff j ff, then we have level(C0) = level(C) by definition, thus
level(C0) = 1 by (1). Hence, C0 is narrow by induction hypothesis, which implies that
C is narrow too. If C is 8 (ff \Pi  C 0) oe and oe 6j ff, then, either level(C 0) = 0, which implies
level(C) = 0 and this is a contradiction, or level(C 0) > 0 and level(C) = level(C 0) + 1,
thus level(C) > 1, which is a contradiction too. This case is not possible.

Property ii: If level(C) = 1, we know that C is narrow. We prove by structural induction on C that C is equivalent to 8 (C) [ ].

ffi Case [ ]: immediate.
ffi Case 8 (ff \Pi  oe) C0: By induction hypothesis C 0 is equivalent to 8 (C0) [ ]. Hence,
C is equivalent to 8 (ff \Pi  oe) 8 (C 0) [ ], which is the expected result since 8 (ff \Pi  oe) C 0 is
(ff \Pi  oe)C0.

ffi Case 8 (ff \Pi  C0) oeff: We have C equivalent to C 0, and we get the expected result by
induction hypothesis and by observing that C is C 0.

Property iii: It is shown by induction on C:

ffi Case [ ] cannot occur since level(C) > 1.
ffi Case 8 (ff \Pi  C1) oeff and oeff j ff: Then level(C1) > 1 and C is equivalent to C1, thus
the result is by induction hypothesis.

ffi Case 8 (ff \Pi  C1) oe and oe 6j ff: Then level(C1) = level(C) - 1. If level(C1) = 1, then
we get the expected result by Property ii, taking Q1 = C1. Otherwise, by induction

243

244 Preuves (de'tails techniques)
hypothesis, C1 is equivalent to C01(8 (fi \Pi  8 (Q1) [ ]) oe0), and we get the expected result
by taking C0 = 8 (ff \Pi  C01) oe.

ffi Case 8 (ff\Pi oe) C1: We have level(C) = level(C1) > 1. We get the result by induction
hypothesis.

Property iv: If level(C) = 1, then we get the result by taking C 0 = [ ] and Cn = C.
Hence, we assume level(C) > 1, and we prove the result by structural induction on C:

ffi Case [ ]: Not possible since level(C) > 1.
ffi Case 8 (ff \Pi  oe) C0: By induction hypothesis.
ffi Case 8 (ff\Pi C0) oeff and oeff j ff: We have level(C0) = level(C), dom1(C0) = dom1(C),
and C0 is equivalent to C. Hence, we get the result by induction hypothesis.

ffi Case 8 (ff \Pi  C0) oe and oe 6j ff: We have level(C0) = level(C) - 1. If level(C 0) = 1, we
get the expected result. Otherwise, we get the result by induction hypothesis.

Property v: It is shown by structural induction on C:

ffi Case [ ]: immediate.
ffi Case 8 (ff \Pi  oe0) C0: Since C(oe) 2 V, we must have C 0(oe) 2 V, and we get the result
by induction hypothesis.

ffi Case 8 (ff\Pi C0) oeff and oeff j ff: Since C(oe) j C0(oe) by Eq-Var, we have C0(oe) 2 V,
and we get the result by induction hypothesis, observing that level(C) = level(C 0).

ffi Case 8 (ff \Pi  C0) oe0 and oe0 6j ff: If level(C0) = 0, or ff /2 ftv(oe0), then level(C) =
0, which is the expected result. Otherwise, ff 2 ftv(oe0) and level(C0) > 0. Hence,
level(C) = level(C0) + 1 by definition. Thus we have level(C) > 1. We must show that
this case is not possible, that is, C(oe) cannot be in V. Indeed, we have ff 2 ftv(oe 0) and
oe0 6j ff, thus oe0/ffl /2 #. Hence, 8 (ff \Pi  C0(oe)) oe0/ffl /2 #, which implies that C(oe) /2 V by
Property 1.5.4.i (page 51).

Proof of Lemma 2.5.5
The relations @-_ff and v_ff are included (respectively) in @- and v for any set _ff. Indeed,
the new set of rules defining (respectively) @- _ff and v_ff is derivable from the old set of
rules defining (respectively) @- and v.

Conversely, we have to show that @- is included in @-;. By Lemma 2.5.2 (page 78),
this amounts to showing that (j|@-C )* is included in @-;. Since @-; is transitive, it
suffices to show that (j|@-C ) is included in @-;. Additionally, j is included in @-; by
RuleA-Equiv', thus we only need to prove the following property:

If (Q) oe1 @-C oe2 (1) holds, then (Q) oe1 @-; oe2 holds too.

244

245
Necessarily, Ac-Hyp is used to derive (1). Hence, we have oe1 = Cr(oe0), oe2 = Cr(ff),
and (ff = oe0) 2 QCr. If ff 2 dom(Q), then ff is frozen in the derivation of (Q) oe1 @- oe2,
that is, ff is not introduced in _ff by context rules. Hence, (Q) oe1 @-_ff oe2 holds, by
A-Hyp' and context rules. Otherwise, ff 2 dom(Cr), which implies that the context
Cr is of the form Ca(8 (ff = oe0) Cb). In summary, we have:

oe1 = Ca(8 (ff = oe0) Cb(oe0)) (2) oe2 = Ca(8 (ff = oe0) Cb(ff)) (Q) oe1 @-C oe2 (3)
We have to show that (Q) oe1 @-; oe2 holds too. In fact, it suffices to show that (QCa)
8 (ff = oe0) Cb(oe0) @-_ff (dom(Ca))8 (ff = oe0) Cb(ff) (4) holds. Then context rules AContext-L' and R-Context-R give the expected result. We show (4) by case on
the level of Cb.

ffi Case level(Cb) = 1: Then Cb is equivalent to 8 (Cb) [ ] by Property 2.4.4.ii (page 74).
Hence, Cb(oe0) j 8 (Cb) oe0 (5) holds. Since (2) and (3) are well-formed, we must
have ftv(oe0) ` dom(QCa), and ftv(oe0) # dom(Cb). Hence, 8 (Cb) oe0 is equivalent
to oe0 (6) by Eq-Free. Similarly, we have 8 (ff = oe0) Cb(ff) j 8 (ff = oe0) ff (7)
by Eq-Free, and 8 (ff = oe0) ff j oe0 (8) by Eq-var. Hence, R-Trans, (7), and
(8) give 8 (ff = oe0) Cb(ff) j oe0 (9). Consequently, by (5), (6), and (9), we have
(QCa) 8 (ff = oe0) Cb(oe0) j 8 (ff = oe0) Cb(ff), which implies the expected result (4) by
A-Equiv'.

ffi Case level(Cb) = 2: Then by Property 2.4.4.iii (page 74), Cb is equivalent to 8 (Q1)
8 (ff0 = 8 (Q2) [ ]) oe0, for some prefixes Q1, Q2. As above, we note that ftv(oe0) #
dom(Q1Q2), thus 8 (ff = oe0) Cb(oe0) j 8 (ff = oe0) 8 (ff0 = oe0) 8 (Q1) oe0 (10) holds by
Eq-Free and Eq-Comm, and 8 (ff = oe0) Cb(ff) j 8 (ff = oe0) 8 (ff0 = ff) 8 (Q1) oe0 (11).
Hence, by rules A-Alias', A-Equiv', (10), and (11), we derive (QCa) 8 (ff = oe0)
Cb(oe0) @-dom(Ca) 8 (ff = oe0) Cb(ff). This is the expected result (4).

ffi Case level(Cb) > 1 (12): We prove the following result:

Given n > 0, for any rigid context Cr such that level(Cr) = n + 1, and oe0
such that ftv(oe0) [ {ff} # dom(Cr), there exists a rigid context C 0r such that
level(C0r) = n, Cr(oe0) @-; C0r(oe0) and Cr(ff) j C0r(ff).

Proof: This is proved by structural induction on Cr.

Subcase [ ] is not possible since level(Cr) > 1.
Subcase 8 (fi \Pi  oe) C1: By induction hypothesis.
Subcase 8 (fi \Pi  C1) oe and oe j fi: Then Cr is equivalent to C1, and we get the
result by induction hypothesis.

Subcase 8 (fi = C1) oe and oe 6j fi: If level(C1) > 1, then we get the result by
induction hypothesis. Otherwise, level(C1) = 2, thus, by Properties 2.4.4.iii (page 74)
and 2.4.4.ii (page 74), C1 is equivalent to 8 (Q01) 8 (fi0=8 (Q02) [ ]) oe1 for some prefixes Q01
and Q02. Besides, we have ftv(oe0) # dom(Q01Q02) by hypothesis. This implies C1(oe0) j

245

246 Preuves (de'tails techniques)
8 (fi0 = oe0) 8 (Q1) oe1 by Eq-Free and Eq-Comm. Hence, C(oe0) j 8 (fi = 8 (fi0 = oe0)
8 (Q1) oe1) oe. By A-Up', we get C(oe0) @- [;]8 (fi0 = oe0) 8 (fi = 8 (Q1) oe1) oe. Similarly,
C(ff) j 8 (fi0 = ff) 8 (fi = 8 (Q1) oe1) oe. Hence, the context C 0r = 8 (fi0 = [ ]) 8 (fi = oe1) oe
is of level n = 1 and is appropriate. \Lambda 

Back to the main proof. By well-formedness of (2), we have ftv(oe)[{ff} # dom(Cb).
By (12), level(Cb) = n > 1, hence there exists a rigid context C 0b of level n - 1 such that
Cb(oe0) @-; C0b(oe0) and Cb(ff) j C0b(ff). By immediate iteration, we build a sequence
Cib of rigid contexts, such that Cb(oe0) @-; Cnb [oe0] (13) holds by R-Trans, Cb(ff) j
Cnb [ff] (14) hold, and Cnb is of level 1. Moreover, 8 (ff = oe0) Cnb [oe0] @-_ff 8 (ff = oe0)
Cnb [ff] (15) holds by Eq-Comm and A-Alias'. Hence, by R-Trans, (13), (15), and
(14), we get 8 (ff = oe0) Cb(oe0) @-; 8 (ff = oe0) Cb(ff), which is the expected result (4).

The proof of the equivalence between v and v _ff is similar. A new proof for the case
I-Abstract is needed, though, since the induction hypothesis cannot be used (indeed,
@- is equal to @-;, but not in general to @-_ff).

Proof of Lemma 2.5.7
By induction on the derivation of (Q) oe1 ""_ff oe2.

ffi Case A-Equiv': by Corollary 1.5.10 and Property 1.5.11.ix (page 56).
ffi Case R-Trans The premises are (Q) oe1 ""_ff oe01 (1) and (Q) oe01 ""_ff oe2 (2). We
have 8 (Q) oe1/ 6/ 8 (Q) oe01/ (3) by Property 2.1.3.ii (page 66), and 8 (Q) oe01/ 6/
8 (Q) oe2/ (4) Since 8 (Q) oe1/ = 8 (Q) oe2/ (by hypothesis), (3) become 8 (Q) oe2/ 6/
8 (Q) oe01/ (5). By (4), (5) and antisymmetry of 6 (Property 2.1.2.i (page 65)), we get
8 (Q) oe2/ = 8 (Q) oe01/. Similarly, 8 (Q) oe1/ = 8 (Q) oe01/ (6) holds. If ff 2 ftv( bQ(oe2))
and ff 2 _ff, then ff 2 ftv( bQ(oe01)) by induction hypothesis on (2), thus ff 2 ftv( bQ(oe1))
by induction hypothesis on (1).

ffi Case R-Context-R': We have oe1 = 8 (fi\Pi oe) oe01 and oe2 = 8 (fi\Pi oe) oe02. We choose fi
fresh, that is, fi /2 dom( bQ) [ codom( bQ). The premise is (Q, fi \Pi  oe) oe01 ""_ff[{fi} oe02 (1). By
hypothesis, we have 8 (Q) oe1/ = 8 (Q) oe2/, that is, 8 (Q, fi \Pi  oe) oe01/ = 8 (Q, fi \Pi  oe) oe02/.
Let ff be in _ff and in ftv( bQ(oe2)) (2). If ff is in ftv( bQ(oe02)), then by induction hypothesis
on (1), ff is in ftv( bQ(oe01)), thus ff 2 ftv( bQ(oe1)). Otherwise, we have ff /2 ftv( bQ(oe02))
and (2), thus we necessarily have fi 2 ftv(oe02) (3). and ff 2 ftv( bQ(oe)) (4). Let `0 be

"Q, fi \Pi  oe. We proceed by case analysis.

Subcase oe /2 T : Then `0 is bQ (5), thus we have fi 2 ftv(`0(oe02)) from (3), and
fi is obviously in _ff [ {fi}. By induction hypothesis and (1), we get fi 2 ftv(` 0(oe01)).
Consequently, fi 2 ftv( bQ(oe01)) (6) by (5), thus ff 2 ftv( bQ(oe1)) by (6) and (4). This is
the expected result.

246

247
Subcase oe 2 T : Then oe j o/ (7) by Property 1.5.11.ii (page 56) and `0 isb
Q ffi [fi = o/ ] (8). We have ff 2 ftv( bQ(o/ )) from (4) and (7), thus ff 2 ftv(`0(oe02)) by (8)
and (3). Hence, by induction hypothesis and (1), we have ff 2 ftv(`0(oe01)). Consequently,
ff 2 ftv( bQ(8 (fi \Pi  oe) oe01)) by (8) and (7). This is the expected result.

ffi Case A-Context-L' and I-Context-L': We have oe1 = 8 (fi \Pi  oe01) oe and oe2 =
8 (fi \Pi  oe02) oe. The premise is (Q) oe01 ""_ff oe02 (1). We have ff 2 ftv( bQ(oe2)) by hypothesis.
If ff 2 ftv( bQ(oe)), then ff 2 ftv( bQ(oe1)), which is the expected result. Otherwise, we
must have ff 2 ftv( bQ(oe02)) (2) and fi 2 ftv(oe) (3). By definition, there exists u such
that oe/u = fi. By hypothesis, 8 (Q) oe1/ = 8 (Q) oe2/. Hence, 8 (Q) oe1 * u/ = 8 (Q)
oe2 * u/. By Property 1.3.3.i (page 42), this means \Theta Q(oe1) * u/ = \Theta Q(oe2) * u/, that is,
\Theta Q(oe01) * ffl/ = \Theta Q(oe02) * ffl/. By Property 1.3.3.i (page 42), we get 8 (Q) oe01/ = 8 (Q) oe02/.

By induction hypothesis,(1), and (2), we get ff 2 ftv( bQ(oe01)), thus ff 2 ftv( bQ(oe1)) by
(3).

ffi Case I-Rigid': Both sides have the same set of free variables.
ffi Case A-Hyp' and I-Hyp': Here oe2 is fi, and fi is not in _ff, hence there is no
ff 2 ftv(oe2) such that ff is in _ff.

ffi Case A-Alias' and I-Alias': Both sides have the same set of free variables.
ffi Case A-Up' and I-Up': Both sides have the same set of free variables.
ffi Case I-Nil': We have (Q) ? v oe2 and 8 (Q) ?/ = 8 (Q) oe2/. Hence, oe2 is either
?, or a type variable. This is a contradiction with restrictions of Lemma 2.5.6. Hence,
this case does not happen.

Proof of Property 2.6.2
We are glad to prove each point.
Property i: it is easy to check that .@-_ff is included in @- (indeed, rules StSh-Hyp, StShUp and StSh-Alias are derivable with @-). Additionally, j is included in @-, and @-

is transitive, thus (j .@-;)

* is included in @-. Conversely, we show that @- is included in

(j .@-;)

*.

As seen in Lemma 2.5.5, the relations @- and @- _ff are equivalent. Hence, it suffices
to show that @-_ff is included in (j .@-;)

*. By Lemma 2.5.6, we can assume that the

given derivation is restricted. As we did in Lemma 2.5.1 (page 78), transitivity can be
lifted to top-level for @-_ff too, thus it suffices to show that @- _ff without transitivity is
included in (j .@-;). More precisely, we prove that if we have a restricted derivation of
(Q) oe1 @-_ff oe2 without transitivity, then (Q) oe1 (j .@-;) oe2 is derivable. As we did in the
proof of Lemma 2.5.2 (page 78), we can write the derivation of (Q) oe1 @-_ff oe2 in the

247

248 Preuves (de'tails techniques)
form

A-X . . .(QQ0) oe0

1 @-_ff oe02.

..

(Q) oe1 @-_ff oe2

Where, A-X is either A-Equiv, A-Up', A-Hyp' or A-Alias', and the symbol ... represents a sequence of context rules. If A-X is A-Equiv, then (Q) oe1 j oe2 holds,

thus (Q) oe1 (j .@-;) oe2 holds by definition. Otherwise, as we did in the proof of
Lemma 2.5.2 (page 78), we can associate a rigid context Cr to the sequence of context

rules (...), such that Q0 = Cr, oe1 = Cr(oe01) and oe2 = Cr(oe02). In summary, we have
(Q) Cr(oe01) @-_ff Cr(oe02), and we must show that (Q) Cr(oe01) (j .@-;) Cr(oe02) holds.

ffi Case Rule A-X is A-Hyp': Then we have (ff = oe01) 2 Q (since ff /2 _ff) and oe02 = ff.
Hence, (Q) Cr(oe01) .@-_ff Cr(oe02) holds by Rule StSh-Hyp whenever oe01 /2 T . If oe01 2 T ,

then (Q) Cr(oe01) j Cr(ff) is easily derivable by Eq-Mono, thus (Q) Cr(oe01) (j .@-;)
Cr(oe02) holds.

ffi Case Rule A-X is A-Up': Then we have oe01 = 8 (ff = 8 (ff1 = oe1) oe) oe0 and
oe02 = 8 (ff1 = oe1) 8 (ff = oe) oe0. Hence, (Q) oe1 .@-_ff oe2 holds by Rule StSh-Up (all side
conditions obviously hold since Q0 is ; and the rule is restricted).

ffi Case Rule A-X is A-Alias': Then we have oe01 = 8 (ff1 = oe0) 8 (ff2 = oe0) oe and
oe02 = 8 (ff1 = oe0) 8 (ff2 = ff1) oe. Hence, (Q) Cr(oe01) .@-_ff Cr(oe02) holds by StSh-Alias
(because the judgment is restricted, the side conditions hold).

We have shown that (Q) oe1 (j .@-;) oe2 holds, thus @- is included in (j .@-;)

*. Consequently, @- and (j .@-;)

* are equivalent. \Lambda 

Property ii: We have @- included in .v by C-Abstract-R. Hence, @- is included in
(j .v)* (1).

We introduce a derivable rule:

The following rule is derivable:

C-Abstract (QQ

0) oe1 @-dom(Q0) oe2 Q0 = Cf

(Q) Cf (oe1) (j .v)* Cf (oe2)

Proof: We assume (QQ0) oe1 @-_ff oe2 (2) holds. If level(Cf ) = 0, then Cf is
useless by Property 2.4.3.iii (page 73), thus Cf (oe1) j Cf (oe2) by definition, and (Q)
Cf (oe1) (j .v) Cf (oe2) holds. If level(Cf ) is 1, then Cf is narrow by Property 2.4.4.i
(page 74) thus Cf is also a rigid context. Hence, (Q) Cf (oe1) @-_ff Cf (oe2) holds by context

248

249
rules. Thus (Q) Cf (oe1) (j .v)* Cf (oe2) holds by Lemma 2.5.5 and (1). Otherwise,
level(Cf ) > 1. By Lemma 2.5.5, Property i, and (2), we have (QQ0) oe1 (j .@-;)

* oe

2.

Since (j .v)* is transitive, it suffices to show that if (QQ0) oea (j .@-;) oeb holds, then
(Q) Cf (oea) (j .v)* Cf (oeb) holds too. Additionally, since j is included in (j .v), it
suffices to show that if (QQ0) oea .@-_ff oeb holds, then (Q) Cf (oea) (j .v)* Cf (oeb) holds
too. We get such a result by C-Abstract-F. \Lambda 

The relation .@ is included in v, as well as j and .@-_ff. Besides, v is a congruence
under flexible prefixes Cf . Hence, .v is included in v. Since v is transitive, .v* is also
included in v. Additionally, j is included in v by I-Equiv?, thus (j .v)* is included
in v.

Conversely, we show that v is included in (j .v)*. By Lemma 2.5.5, it suffices to
show that v_ff is included in (j .v)*. As shown in Lemma 2.5.1 (page 78), transitivity
can be lifted at top-level, and the derivation is made restricted by Lemma 2.5.6; thus,
we only have to show that if we have a restricted derivation of (Q) oe1 v_ff oe2, without
using transitivity, then (Q) oe1 (j .v)* oe2 holds too. The derivation of (Q) oe1 v_ff oe2 is
of the form

I-Context-X'

I-X (QQ

0) oe01 v_ff oe02

...

(Q) oe1 v_ff oe2

The context rules (represented by ...) are associated to a flexible context Cf such that
Cf = Q0, oe1 = Cf (oe01) and oe2 = Cf (oe02). The top Rule I-X is I-Abstract', I-Bot',
I-Hyp', I-Rigid', I-Up', or I-Alias'.

ffi Case I-Abstract': By hypothesis (QQ0) oe01 @-dom(Q

0) oe0

2 holds. We have (Q)oe

1 (j .v)* oe2 by C-Abstract. This is the expected result.

ffi Case I-Hyp': By rules S-Hyp and C-Strict.
ffi Case I-Rigid': By rules S-Rigid and C-Strict.
ffi Case I-Bot': We have oe01 = ?. If oe02 is closed, we conclude directly by S-Nil and
C-Strict. Otherwise, we consider 8 (QQ0) oe02, which is necessarily closed. We can
derive (Q) oe1 .v Cf (8 (QQ0) oe02) by S-Nil and C-Strict. By iteration of S-Hyp and
C-Strict, or A-Hyp and C-Abstract, we derive (Q) Cf (8 (QQ0) oe02) .v* Cf (oe02).
Hence, (Q) oe1 .v* Cf (oe02) holds by transitivity, that is (Q) oe1 .v* oe2.

ffi Case I-Up': By S-Up and C-Strict.
ffi Case I-Alias': By S-Alias and C-Strict.

249

250 Preuves (de'tails techniques)
Proof of Property 2.6.3
Each point deserves its own proof.

Property i for R being .@-_ff: By case on the rule used to derive (Q) oe1 .@-_ff oe2.

ffi Case StSh-Hyp: By hypothesis, we have oe1 = Cr(oe01), (ff = oe001 ) 2 Q (1), oe2 =
Cr(ff) and (Q) cCr(oe01) j oe001 (2). Besides, oe01 /2 T and Cr is a useful well-formed
context by hypothesis. By Lemma 2.4.5 (page 75), there exists a context C0r, which is
ftv(cCr(oe01))-equivalent to Cr, such that nf(oe1) = C0r(oef ) (3), where oef is nf(cCr(oe01)).
Hence, oef j cCr(oe01) (4) by Property 1.5.6.i (page 53). Consequently, (2) and (4) lead
to (Q) oef j oe001 (5). We have (Q) nf(oe1) .@-_ff C0r(ff) (6) by StSh-Hyp, (3), (1), and
(5). Besides, (Q) C0r(ff) j Cr(ff) (7) holds since C0r and Cr are ftv(cCr(oe01))-equivalent
and ff /2 dom(Cr) [ dom(C0r). We have the expected result, namely (6) and (7), taking
oe02 = C0r(ff).

ffi Case StSh-Up: By hypothesis, we have oe1 = Cr(8 (fi = 8 (Q0, ff0 = oe0) oe0) oe00),
and oe2 = Cr(8 (ff0 = oe0) 8 (fi = 8 (Q0) oe0) oe00) (8). along with a bunch of sideconditions. Let oea be 8 (fi = 8 (Q0, ff0 = oe0) oe0) oe00. By hypothesis we have oe0 /2 T ,
ff0 2 ftv(oe0) and fi 2 ftv(oe00), thus oea /2 T by Property 2.1.5.i (page 67). Let ` bec
Cr and _ff be ftv(`(oea)). By hypothesis, Cr is a useful well-formed context, thus, by
Lemma 2.4.5 (page 75), there exists a context C0r, that is _ff-equivalent to Cr, such that
nf(oe1) = C0r(oe01) (9), with oe01 = nf(`(oea))). Hence, by Property 1.5.6.iii (page 53), we
have oe01 = `(8 (fi = oe001 ) nf(oe00)) (10), where oe001 is nf(8 (Q0) 8 (ff0 = oe0) oe0). We write `0
for cQ0. By definition of normal form oe001 is 8 (Q00) 8 (ff0 = nf(oe0)) `0(nf(oe0)) (11), with
8 (Q00) `0(nf(oe0)) = nf(8 (Q0) oe0) (12). Combining (9), (10), and (11), nf(oe1) is (you
may take a deep breath) C0r(8 (fi = 8 (`(Q00)) 8 (ff0 = `(nf(oe0))) ``0(nf(oe0))) `(nf(oe00))).
In addition, all side conditions of StSh-Up are satisfied. Hence, StSh-Up can be
applied: (Q) nf(oe1) .@-_ff C0r(8 (ff0 = `(nf(oe0))) 8 (fi = 8 (`(Q00)) ``0(nf(oe0))) `(nf(oe00))).

Now, watchful readers expect a proof that C 0r(8 (ff0 = `(nf(oe0))) 8 (fi = 8 (`(Q00))
``0(nf(oe0))) `(nf(oe00))) is equivalent to oe2. Let oe02 be the former. We get oe02 j C0r(8 (ff0=
`(oe0)) 8 (fi =`(8 (Q0) oe0)) `(oe00)) from (12) and Property 1.5.6.i (page 53). As for oe2, we
use Eq-Mono and derive oe2 j Cr(8 (ff0 = `(oe0)) 8 (fi = `(8 (Q0) oe0)) `(oe00)) from (8).
Hence, oe2 j Cr(oe3) and oe02 j C0r(oe3), where oe3 is 8 (ff0 = `(oe0)) 8 (fi = `(8 (Q0) oe0))
`(oe00). We know that Cr and C0r are _ff-equivalent. Moreover, ftv(oe3) = ftv(`(ftv(oea))) =

_ff, thus by definition of _ff-equivalence, we have Cr(oe3) j C0r(oe3), which gives oe2 j oe02.
This is the expected result.

ffi Case StSh-Alias: We have oe1 = Cr(8 (ffa = oea) 8 (Q0) 8 (ffb = oeb) oe0) with
oea j oeb, and oe2 is Cr(8 (ffa = oea) 8 (Q0) 8 (ffb = ffa) oe0). Let oe0 be 8 (ffa = oea) 8 (Q0)
8 (ffb = oeb) oe0 (13). Let ` be cCr and _ff be ftv(`(oe0)). By hypothesis, oea /2 T and

250

251
ffa 2 ftv(oe0), thus oe0 /2 T by Property 2.1.5.i (page 67). Besides, Cr is a useful wellformed context, thus by Lemma 2.4.5 (page 75), there exists a context C 0r which is

_ff-equivalent to Cr such that nf(oe1) = C0r(nf(`(oe0))). By Property 1.5.6.iii (page 53),
we have nf(oe1) = C0r(`(nf(oe0))) (14).

Let `0 be cQ0. From (13), nf(oe0) is of the form 8 (ffa = nf(oea)) 8 (Q00) 8 (ffb = nf(oeb))
`0(nf(oe0)) (15). Consequently, from (14) and (15), nf(oe1) is C0r(8 (ffa = `(nf(oea)))
8 (`(Q00)) 8 (ffb = `(nf(oeb))) ``0(nf(oe0))) (16), besides, ffa, ffb 2 ftv(``0(nf(oe0))) (17)
by Property 1.5.6.ii (page 53). By hypothesis oea /2 T , hence `(nf(oea)) /2 T (18) by
property 1.5.11.iv (page 56). Moreover oea j oeb, thus nf(oea) j nf(oeb) by Property 1.5.6.i
(page 53) and R-Trans. This gives `(nf(oea)) j `(nf(oeb)) (19) by Property 1.5.11.v
(page 56). Consequently, from (16), (17), (18), (19), and StSh-Alias, we can derive
(Q) nf(oe1) .@-_ff oe02, where oe02 is C0r(8 (ffa = `(nf(oea))) 8 (`(Q00)) 8 (ffb = ffa) ``0(nf(oe0))).

It remains to be shown that oe2 j oe02 holds. We have oe2 j Cr(8 (ffa = `(nf(oea)))

8 (`(Q00)) 8 (ffb = ffa) ``0(nf(oe0))) using Eq-Mono* on cCr and cQ0. Hence, oe2 j Cr(oez)
and oe02 is C0r(oez), where oez is 8 (ffa = `(nf(oea))) 8 (`(Q00)) 8 (ffb = ffa) ``0(nf(oe0)). By
Property 1.5.4.i (page 51), we have ftv(oez) = `(ftv(oe0)), thus we get ftv(oez) = _ff.
Hence, by definition of _ff-equivalence, we get Cr(oez) j C0r(oez), which leads to oe2 j oe02.
This is the expected result.

Property ii for R being .@-_ff: By hypothesis, oe1 ss oe01 (1) and (Q) oe1 .@-_ff oe2 (2) hold.
We prove the result for a single commutation only, then we get the expected result
by immediate induction. We assume that (1) holds by a single commutation. More
precisely, let oer, oe0r and C be such that

oer = 8 (fl = oea, fi = oeb) oec oe0r = 8 (fi = oeb, fl = oea) oec oe1 = C(oer) (3)

oe01 = C(oe0r) fi /2 ftv(oea) fl /2 ftv(oeb) (4).
Since oe1 is in normal form, we also know that fl, fi 2 ftv(oec). We prove the result by
case on the rule used to derive (2).

ffi Case StSh-Hyp: oe1 is of the form Cr(oe0) and (ff = oe0) 2 Q with (Q) oe0 j cCr(oe0).
Since oe1 is in normal form, we have cCr = id. By (3), we have C(8 (fl = oea, fi = oeb)
oec) = Cr(oe0). By alpha-conversion, we can freely assume that fl /2 ftv(oe0). We proceed
by case analysis on C and Cr.

Subcase C and Cr are disjoint: By Lemma 2.4.6 (page 76), there exists a
two-hole context C2 such that Cr = C2([ ], 8 (fl = oea, fi = oeb) oec) and C = C2(oe0, [ ]).
Besides, C0r = C2([ ], 8 (fi = oeb, fl = oea) oec) (5) is rigid. We have oe01 = C0r(oe0). Let oe02
be C0r(ff) (6). Note also that oe2 is C2(ff, 8 (fl = oea, fi = oeb) oec) (7). By StSh-Hyp, we
get (Q) oe01 .@-_ff oe02, and oe02 ss oe2 by (6), (5), and (7). This is the expected result.

Subcase C is of the form Cr(C0): We have oe0 = C0(oer), (Q) oe0 j C0(oe0r), and
(Q) ff j ff. We get the expected result by StSh-Hyp.

251

252 Preuves (de'tails techniques)

Subcase Cr is of the form C(8 (fl = C 0, fi = oeb) oec): immediate
Subcase Cr is of the form C(8 (fl = oea, fi = C0) oec): immediate
Subcase Cr is of the form C(8 (fl = oea, fi = oeb) C0): immediate
Subcase Cr is of the form C(8 (fl =oea) [ ]): We must have oe1 = C(8 (fl =oea, fi =
oeb) oec) and (Q) oe0 j 8 (fi = oeb) oec. However, fl 2 ftv(oec), thus fl 2 ftv(8 (fi = oeb) oec).
Hence, by Property 1.5.4.i (page 51), we must have fl 2 ftv(oe0), which is a contradiction.
Hence this case cannot occur.

ffi Case StSh-Up: oe1 is of the form Cr(8 (ffb =8 (Q0, ffa =oe) oe0) oe00), with oe /2 T , ffa 2
ftv(oe0), oe0, oe00 /2 V (8), ffa /2 dom(QCrQ0) (9), ftv(oe) # dom(Q0), ffb 2 ftv(oe00) (10),
and oe2 is Cr(8 (ffa = oe) 8 (ffb = 8 (Q0) oe0) oe00). We have C(8 (fl = oea, fi = oeb) oec) =
Cr(8 (ffb = 8 (Q0, ffa = oe) oe0) oe00). We proceed by case on the form of C and Cr:

Subcase C and Cr are disjoint: immediate
Subcase C is Cr: We have fl = ffb (11), oea = 8 (Q0, ffa = oe) oe0 and oe00 =
8 (fi =oeb) oec (12) Then oe01 is Cr(8 (fi =oeb, fl =8 (Q0, ffa =oe) oe0) oec). We have fl 2 ftv(oec)
by (10), (11), (12) and (4). Besides, oec /2 V by (12) and (8) and ffa /2 ftv(oec) by (12)
and (9). Hence, StSh-Up applies and gives (Q) oe01 .@-_ff Cr(8 (fi=oeb, ffa =oe, fl =8 (Q0) oe0)
oec). We get the expected result by observing that Cr(8 (fi =oeb, ffa = oe, fl = 8 (Q0) oe0) oec)
is equivalent to oe2.

Subcase C is of the form Cr(C0): immediate.
Subcase Cr is of the form C(C0): immediate.

ffi Case StSh-Alias: all subcases are easy.

Property i for R being .@: By case on the rule used to derive (Q) oe1 .@ oe2. Cases SHyp, S-Up and S-Alias are similar to cases StSh-Hyp, StSh-Up, and StSh-Alias
of Property i.

ffi Case S-Nil: We have oe1 = Cf (?), oe2 = Cf (oe) and oe is closed by hypothesis. By
Lemma 2.4.5 (page 75), there exists C0r, ;-equivalent to Cr, such that nf(oe1) = C0r(?).
Consequently, nf(oe1) .@ C0r(oe) holds by S-Nil. Additionally, we have Cr(oe) j C0r(oe)
by definition of ;-equivalence.

ffi Case S-Rigid: We have oe1 = Cf (8 (ff >= oe0) oe) and oe2 = Cf (8 (ff = oe0) oe). By
hypothesis, oe /2 V, oe0 /2 T (13) and ff 2 ftv(oe) (14). Let oe0 be 8 (ff >= oe0) oe, _ff
be ftv(`(oe0)) and ` be cCr. By Property 2.1.5.i (page 67) applied to (13) and (14),
we have oe0 /2 T . By Lemma 2.4.5 (page 75), there exists C0r, _ff-equivalent to Cr,
such that nf(oe1) = C0r(nf(`(oe0))). Hence, by Property 1.5.6.iii (page 53), nf(oe1) is
C0r(`(8 (ff >= nf(oe0)) nf(oe))), that is, C0r(8 (ff >= `(nf(oe0))) `(nf(oe))). By Rule S-Rigid,
we can derive (Q) nf(oe1) .@ C0r(oe00), where oe00 is 8 (ff = `(nf(oe0))) `(nf(oe)). We note
that oe00 is `(nf(8 (ff = oe0) oe)). Consequently, oe2 j Cr(oe00) holds by by Property 1.5.6.i
(page 53) and by Rule Eq-Mono. We have ftv(oe00) = `(ftv(oe0)) by Property 1.5.6.ii
(page 53), thus ftv(oe00) = _ff. Hence, by definition of _ff-equivalence, Cr(oe00) j C0r(oe00).

252

253
Property ii for R being .@: By case on the rule used to derive (Q) oe1 .@ oe2. Cases SHyp, S-Up and S-Alias are similar to cases StSh-Hyp, StSh-Up, and StSh-Alias
of Property ii.

ffi Case S-Nil: immediate.
ffi Case S-Rigid: immediate.

Proof of Lemma 2.7.8
Directly, we assume that we haveb

Q(nf(oe2)) /2 # (1) (Q) oe1 v oe2 (2) 8 (Q) oe1/ = 8 (Q) oe2/ (3)

X /2 w(oe1) - w(oe2) (4)
By Lemma 2.5.5 and (2), we have a derivation of (Q) oe1 v_ff oe2 (5). By Lemma 2.5.6,
this derivation is restricted. The proof is by induction on the derivation of (5).

ffi Case I-Abstract': The premise is (Q) oe1 @-_ff oe2 and we conclude by Lemma 2.5.5.
ffi Case R-Trans: The premises are (Q) oe1 v_ff oe01 (6) and (Q) oe01 v_ff oe2 (7).
By hypothesis (3), 8 (Q) oe1/ = 8 (Q) oe2/ holds. Hence, 8 (Q) oe1/ = 8 (Q) oe01/ =
8 (Q) oe2/ (8) holds (see case R-Trans in the proof of Property 2.7.6.i (page 93) for
details). Besides, by Property 2.7.6.i (page 93), (6), and (7), we have w(oe1) ? w(oe01) ?
w(oe2) (9). By Property 2.7.2.iv (page 87), (4), and (9), we get X /2 w(oe1)-w(oe01) (10)
and X /2 w(oe01) - w(oe2) (11). Now, by hypothesis (1), we have bQ(nf(oe2)) /2 #. Assumeb
Q(nf(oe01)) 2 # holds. By definition, this means that we have bQ(nf(oe01)) = ff (12) for
some type variable ff. If, by a way of contradiction, ff 2 dom( bQ) holds, then, by wellformedness of Q, we must have ff /2 codom( bQ), which implies ff /2 bQ(nf(oe01)), and this is
a contradiction with (12). Consequently, we have ff /2 dom( bQ) (13), that is, bQ(ff) = ff.
Then (12) gives bQ(nf(oe01)) j bQ(ff) (14) by Eq-Refl. By Corollary 1.5.10 and (14),
we get (Q) nf(oe01) j ff. By Property 1.5.6.i and R-Trans, this gives (Q) oe01 j ff (15).
Hence, by Lemma 2.1.6, (7), and (15), we have (Q) oe01 j oe2 (16). By R-Trans, (16),
and (15), we get (Q) oe2 j ff. Consequently, bQ(nf(oe2)) 2 # holds by Corollary 1.5.10
and (13), which is a contradiction with (1). Hence, we have bQ(nf(oe01)) /2 V (17). By
induction hypothesis, (6), (8), (10), and (17), we have (Q) oe1 @- oe01 (18). By induction
hypothesis, (7), (8), (11), and (1), we have (Q) oe01 @- oe2 (19). By R-Trans, (18), and
(19), we get (Q) oe1 @- oe2. This is the expected result.

ffi Case R-Context-R: We have oe1 = 8 (ff \Pi  oe) oe01 and oe2 = 8 (ff \Pi  oe) oe02. The
premise is (Q, ff \Pi  oe) oe01 v_ff[{ff} oe02 (20). By hypothesis (3), we have 8 (Q, ff \Pi  oe) oe01/ =

8 (Q, ff \Pi  oe) oe02/ (21). Let `0 be "Q, ff \Pi  oe and ` be bQ. We proceed by case analysis.

Subcase oe 2 T : We have oe j o/ by Property 1.5.11.ii (page 56). By definition,
we have w(oe1) = w(oe01) and w(oe2) = w(oe02). Hence, we get X /2 w(oe01) - w(oe02) (22)

253

254 Preuves (de'tails techniques)
from (4). From (1), we have `(nf(oe02)[ff = o/ ]) /2 V, which can also be written
`0(nf(oe02)) /2 V (23). By induction hypothesis, (20), (21), (22), and (23), we get
(Q, ff \Pi  oe) oe01 @- oe02. We conclude by R-Context-R.

In the following, we assume oe /2 T , which implies `0 = `. Besides, if ff 2 ftv(oe02),
then ff 2 ftv(oe01) by Lemma 2.5.7 (page 82), (20), and (21), and ff /2 codom( bQ)).
Conversely, if ff 2 ftv(oe01), then ff 2 ftv(oe02) by Lemma 2.1.4 (page 67). Hence, we know
that ff 2 ftv(oe02) if and only if ff 2 ftv(oe01) (24).

Subcase nf(oe01) = ff: Then oe02 j ff by Property 2.1.7.ii (page 68), (24), and
(20). Hence, oe1 j oe j oe2 holds by Eq-Var, and we have (Q) oe1 @- oe2 by A-Equiv.

Subcase nf(oe02) = ff: Then oe01 j ff by Property 2.1.7.ii (page 68), and we also
have (Q) oe1 j oe2. In the following, we assume that nf(oe01) 6= ff and nf(oe02) 6= ff (25)
hold.

Otherwise, let x be 1 if ff 2 ftv(oe01) and 0 otherwise. Let A be X ? \Pi . We
have w(oe1) = x * A * wA(oe) + w(oe01) and w(oe2) = x * A * wA(oe) + w(oe02). Hence,
w(oe1) - w(oe2) = w(oe01) - w(oe02), thus X /2 w(oe01) - w(oe02) (26) by (4). We have
`(nf(oe2)) /2 V from (1), and nf(oe02) is not ff from (25). Thus we have `(nf(oe02)) /2 V (27)
(otherwise, oe02 would be equivalent to a type variable fi, and 8 (ff \Pi  oe) oe02 j fi would
also hold, which is a contradiction with (1)). By induction hypothesis, (20), (21), (26),
and (27), we get (Q, ff \Pi  oe) oe01 @- oe02. Then (Q) oe1 @- oe2 holds by R-Context-R. This
is the expected result.

ffi Case I-Context-L': We have oe1 = 8 (ff >= oe01) oe and oe2 = 8 (ff >= oe02) oe. The
premise is (Q) oe01 v_ff oe02. We have 8 (Q) oe1/ = 8 (Q) oe2/ (1) by hypothesis, and
nf(oe) 6= ff, and ff 2 ftv(oe) (2) by Lemma 2.5.6. By Property 1.3.3.i (page 42), (1),
and (2), we get 8 (Q) oe01/ = 8 (Q) oe02/ (3). We have w(oe1) = X * w(oe01) + w(oe) and
w(oe2) = X*w(oe02)+w(oe). Hence, w(oe1)-w(oe2) = X *(w(oe01)-w(oe02)). By hypothesis,
we have X /2 w(oe1) - w(oe2). Consequently, we must have w(oe01) - w(oe02) = 0, that is,
w(oe01) = w(oe02) (4). By Property 2.7.6.ii (page 93), (3), and (4), we get (Q) oe01 j oe02.
Hence, (Q) oe1 j oe2 holds by R-Context-L, and (Q) oe1 @- oe2 holds by A-Equiv.

ffi Case I-Bot': We have oe1 = ?. Hence, (8 (Q) oe1)/ffl = ?. By Lemma 2.5.6,
we have oe2 /2 V, and oe2 is not ?. Hence, oe2/ffl is a type constructor g. This is a
contradiction with the hypothesis 8 (Q) oe1/ = 8 (Q) oe2/. Hence, this case cannot
occur.

ffi Case I-Hyp': We have (ff1 >= oe1) 2 Q, and oe2 is ff1. By Lemma 2.5.6, we have
oe1 /2 T , thus we have bQ(nf(oe2)) = ff1 2 V, which is a contradiction (by hypothesis).
Hence, this case cannot occur.

ffi Case I-Up': We have oe1 = 8 (ff1>=8 (ff2\Pi oe00) oe0) oe and oe2 = 8 (ff2\Pi oe00) 8 (ff1>=oe0) oe.
By hypothesis, we have X /2 w(oe1) - w(oe2). By restrictions of Lemma 2.5.6, we have
ff1 2 ftv(oe), nf(oe) 6= ff1, ff2 2 ftv(oe0), oe00 /2 T (5), and nf(oe0) 6= ff2. Let A be
X ? \Pi . We have w(oe1) = w(oe) + X * (w(oe0) + A * wA(oe00)). We have w(oe2) =

254

255
w(oe) + X * w(oe0) + A * wA(oe00). Hence, w(oe1) - w(oe2) = A * wA(oe00) * (X - 1).
By Lemma 2.7.4 (page 91) and (5), wA(oe00) 6= 0, thus X 2 w(oe1) - w(oe2), which is a
contradiction (by hypothesis). Hence, this case cannot occur.

ffi Case I-Alias': We have oe1 = 8 (ff1 >= oe0) 8 (ff2 >= oe0) oe and oe2 = 8 (ff1 >= oe0) 8 (ff2 =
ff1) oe. By restrictions of Lemma 2.5.6, we have ff1 and ff2 in ftv(oe), and oe0 /2 T (6).
By definition, we have w(oe1) = w(oe) + 2 * X * w(oe0) and w(oe2) = w(oe) + X * w(oe0).
Hence w(oe1) - w(oe2) = X * w(oe0). By Lemma 2.7.4 (page 91) and (6), this implies
X 2 w(oe1) - w(oe2), which is a contradiction. Hence, this case cannot occur.

ffi Case I-Rigid': We have oe1 = 8 (ff >= oe0) oe and oe2 = 8 (ff = oe0) oe. By restrictions
of Lemma 2.3.1, we have oe0 not in T (7), ff 2 ftv(oe), and nf(oe) 6= ff. Hence, w(oe1) =
w(oe) + X * w(oe0) and w(oe2) = w(oe) + Y * wY (oe0). We get w(oe1) - w(oe2) = Xw(oe0) -
Y wY (oe0) (8). Since X /2 Y wY (oe0), the X-degree of Y wY (oe0) is 0. Since w(oe0) is
not 0 by Lemma 2.7.4 (page 91) and (7), the X-degree of Xw(oe0) is not zero. Hence,
X 2 Xw(oe0) - Y wY (oe0), that is, X 2 w(oe1) - w(oe2) by (8). This is a contradiction.
Hence, this case cannot occur.

Conversely, we assume that (Q) oe1 @- oe2 holds. By Property 2.1.3.i, we have
8 (Q) oe1/ = 8 (Q) oe2/. By I-Abstract, we have (Q) oe1 v oe2. It remains only to
be shown that X /2 w(oe1) - w(oe2) (1) holds. By Lemma 2.5.5 we have a derivation
of (Q) oe1 @-_ff oe2 (2). By Lemma 2.5.6, this derivation is restricted. We prove (1) by
induction on the derivation of (2).

ffi Case A-Equiv': By Lemma 2.7.5 (page 92), we have wX (oe1) - wX(oe2) = 0.
ffi Case R-Trans: The premises are (Q) oe1 @-_ff oe01 (3) and (Q) oe01 @-_ff oe2 (4).
If bQ(nf(oe01)) is in V, then (Q) oe2 j oe01 holds by Lemma 2.1.6, thus bQ(nf(oe2)) is
in V by Lemma 1.5.9, which is a contradiction. Hence, bQ(nf(oe01)) /2 V, and we get
X /2 wX (oe1) - wX (oe01) by induction hypothesis on (3), as well as X /2 wX(oe01) - wX(oe2)
by induction hypothesis on (4). This gives X /2 wX(oe1) - wX (oe2) by addition.

ffi Case A-Hyp': We have (ff = oe1) 2 Q, and oe2 is ff. By Lemma 2.5.6, oe1 /2 T , that
is, ff /2 dom( bQ). Hence, bQ(oe2) = bQ(ff) = ff. This is a contradiction. This case is not
possible.

ffi Case R-Context-R: We have oe1 = 8 (ff\Pi oe) oe01 and oe2 = 8 (ff\Pi oe) oe02. The premise
is (Q, ff \Pi  oe) oe01 @-_ff[{ff} oe02 (5). We proceed by case analysis.

Subcase oe 2 T : Then w(oe1) = w(oe01) and w(oe2) = w(oe02). By induction
hypothesis on (5), we get X /2 w(oe01) - w(oe02), that is X /2 w(oe1) - w(oe2).

In the following, we assume that oe /2 T . By Lemmas 2.5.7 (page 82) and 2.1.4
(page 67), we have ff 2 ftv(oe01) if and only if ff 2 ftv(oe02) (6).

Subcase oe02 2 V and ff 2 ftv(oe02): Necessarily nf(oe02) = ff. Besides, we have
ff 2 ftv(oe01) from (6). Hence, oe01 j ff holds by Property 2.1.7.ii (page 68). Consequently,
oe1 j oe2 and w(oe1) - w(oe2) = 0.

255

256 Preuves (de'tails techniques)

Subcase oe02 2 V and ff /2 ftv(oe02): Then ff /2 ftv(oe01) by (6). Hence, w(oe1) =
w(oe01) (7) and w(oe2) = w(oe02) (8). Besides, we have oe2 j oe02 by Eq-Free. Hence,b
Q(nf(oe02)) ss bQ(nf(oe2)) holds by Lemma 1.5.9. This implies bQ(nf(oe02)) /2 #. We conclude
by induction hypothesis on (5), (7), and (8).

In the following, we assume that oe02 /2 V.

Subcase oe01 j ff: By Lemma 2.1.6 and (5), we get (Q, ff \Pi  oe) oe01 j oe02, thus
(Q) oe1 j oe2 holds by R-Context-R, and w(oe1)-w(oe2) = 0 by Lemma 2.7.5 (page 92).

Otherwise let x be 1 if ff 2 ftv(oe01) and 0 otherwise. Let A be X ? \Pi . We
have w(oe1) = w(oe01) + x * A * wA(oe) and w(oe2) = w(oe02) + x * A * wA(oe). Hence,
w(oe1) - w(oe2) = w(oe01) - w(oe02) and we conclude directly by induction hypothesis on
(5).

ffi Case A-Context-L': We have oe1 = 8 (ff = oe01) oe and oe2 = 8 (ff = oe02) oe. By
Lemma 2.5.6, we have ff 2 ftv(oe). By definition, we have w(oe1) = wY (oe01) * Y + w(oe)
and w(oe2) = wY (oe02) * Y + w(oe). Hence, w(oe1) - w(oe2) = (wY (oe01) - wY (oe02)) * Y ,
thus X /2 w(oe1) - w(oe2).

ffi Case A-Alias': We have oe1 = 8 (ff1 = oe) 8 (ff2 = oe) oe0, and ff1 and ff2 are in
ftv(oe0). Moreover, oe is not in T . We have w(oe1) = w(oe0) + 2 * Y * wY (oe) and w(oe2) =
w(oe0) + Y * wY (oe). Hence, w(oe1) - w(oe2) = Y * wY (oe), thus X /2 w(oe1) - w(oe2).

ffi Case A-Up': We have oe1 = 8 (ff1 = 8 (ff2 = oe00) oe0) oe and oe2 = 8 (ff2 = oe00)
8 (ff1 = oe0) oe. Moreover, ff1 2 ftv(oe), ff2 2 ftv(oe0), nf(oe) is not ff1, nf(oe0) is not
ff2, and oe00 is not in T . We have w(oe1) = w(oe) + Y * (wY (oe0) + Y * wY (oe00)) and
w(oe2) = w(oe) + Y * wY (oe0) + Y * wY (oe00). Hence, w(oe1) - w(oe2) = Y wY (oe00) * (Y - 1).
We see that X /2 w(oe1) - w(oe2).

Proof of Property 2.7.9
Property i: It is shown by structural induction on oe.

ffi Case o/ : We have P (oe) = 0 and #oe ? nff, thus the result holds.
ffi Case ?: We have P (oe) = 1, #oe = 1, and oe is closed, thus the result holds.
ffi Case 8 (ff\Pi oe1) oe2, with nf(oe2) = ff: By definition we have P (oe) = P (oe1), noe = noe1,
and #oe = #oe1, thus we get the result by induction hypothesis on oe1.

ffi Case 8 (ff\Pi oe1) oe2, with ff /2 ftv(oe2): By definition we have P (oe) = P (oe2), noe = noe2,
and #oe = #oe2, thus we get the result by induction hypothesis on oe2.

ffi Case 8 (ff \Pi  oe1) oe2 (other cases): By definition, P (oe) is P (oe2) + X * P (oe1). By
induction hypothesis, the coefficients of P (oe1) are bounded by #oe1 - noe1, and the
coefficients of P (oe2) are bounded by #oe2 - noe2. Hence, the coefficients of P (oe) are
bounded by #oe1 + #oe2 - noe1 - noe2 . Since ftv(oe) = ftv(oe1) [ ftv(oe2) - {ff}, and
ff 2 ftv(oe2), we have noe 6 noe1 + noe2 - 1. Consequently, -noe1 - noe2 6 -noe - 1 holds.
Hence, we have #oe1 + #oe2 - noe1 - noe2 6 #oe1 + #oe2 - noe - 1, thus the coefficients

256

257
of P (oe) are bounded by #oe1 + #oe2 - noe - 1. Let kff be the number of occurrences
of ff in oe2 (that is, the cardinal of the set of all u such that oe2/u = ff). We have
#oe = #oe2 - kff + kff * #oe1. Hence, #oe = #oe2 + kff * (#oe1 - 1). Since ff 2 ftv(oe2),
we have kff ? 1, thus #oe ? #oe2 + #oe1 - 1 (1), that is #oe1 + #oe2 6 #oe + 1. Since
all the coefficients of P (oe) are bounded by #oe1 + #oe2 - noe - 1, they are also bounded
by #oe - noe, which is the expected result.

Property ii: It is shown by structural induction on oe. All cases are straightforward,
except the last one:

ffi Case 8 (ff \Pi  oe1) oe2, when oe2 6j ff and ff 2 ftv(oe2). By definition, P (oe) = P (oe2) +
X * P (oe1), thus d(oe) = max(d(oe2), d(oe1) + 1). We have d(oe2) 6 #oe2 by induction
hypothesis as well as d(oe1) 6 #oe1. Hence, d(oe) 6 max(#oe2, #oe1 + 1) (2). Moreover,
as shown above (1), we have #oe ? #oe2 + #oe1 - 1 (3). Additionally, we have #oe2 6
#oe2 + #oe1 - 1 (4). Since oe2 6j ff, and ff 2 ftv(oe2), we must have #oe2 ? 2 by
Property 2.1.5.ii (page 67). Hence, #oe1 + 1 6 #oe1 + #oe2 - 1 (5). As a consequence of
(4) and (5), we have max(#oe2, #oe1+1) 6 #oe2+#oe1-1, thus max(#oe2, #oe1+1) 6 #oe
holds by (3). Finally, we get d(oe) 6 #oe by (2).

Proof of Property 2.8.1

Property i: Intuitively, this proof is quite long because we have to consider many critical
pairs. Two rules can be used to derive (Q) oe1 .@-_ff oe2, namely StSh-Up and StShAlias (note that the prefix is unconstrained). Similarly, two rules can be used to derive
(Q) oe1 .@-_ff oe3. By symmetry, this makes three cases to consider:

ffi Case StSh-Up and StSh-Up: We have
oe1 = Cr(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec) (1) oe2 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec)

oe1 = C0r(8 (fi0 = 8 (Q2) 8 (ff0 = oe0a) oe0b) oe0c) (2)

oe3 = C0r(8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c)
Besides, the premises give the following hypotheses (3):

fi 2 ftv(oec) fi0 2 ftv(oe0c) ff 2 ftv(oeb) ff0 2 ftv(oe0b) oeb, oe0b, oec, oe0c /2 V

oea, oe0a /2 T ff /2 dom(QCrQ1) ff0 /2 dom(QCrQ2)
We proceed by case analysis on Cr and C0r.

257

258 Preuves (de'tails techniques)

Subcase Cr = C0r: Then from (1) and (2), we get 8 (Q2) 8 (ff0 = oe0a) oe0b = 8 (Q1)
8 (ff = oea) oeb. If ff is ff0, we have oe3 = oe2, thus we get the result by taking oe4 = oe2.
Otherwise, with no loss of generality, we can freely assume that ff 2 dom(Q2). Hence,
we have oe1 of the form Cr(8 (fi = 8 (Qa, ff = oea, Qb, ff0 = oe0a) oe0b) oec), oe2 of the form
Cr(8 (ff = oea) 8 (fi = 8 (QaQb, ff0 = oe0a) oe0b) oec, and oe3 of the form Cr(8 (ff0 = oe0a) 8 (fi =
8 (Qa, ff=oea, Qb) oe0b) oec. Then taking oe4 = Cr(8 (ff=oea, ff0=oe0a) 8 (fi=8 (QaQb) oe0b) oec),
we can derive (Q) oe2 .@-_ff oe4 (4) and (Q) oe3 .@-_ff oe4 (5) by StSh-Up. The premises
of (4) and (5) are ensured by (3).

Subcase Cr and C0r disjoint: By Lemma 2.4.6 (page 76), there exists a twohole context C2 such that Cr = C2([ ], 8 (fi0 = 8 (Q2) 8 (ff0 = oe0a) oe0b) oe0c) and C0r =
C2(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec, [ ]). Then taking oe4 = C2(8 (ff = oea) 8 (fi = 8 (Q1)
oeb) oec, 8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c) gives the expected result.

Subcase Cr and C0r nested: without loss of generality, we can freely assume
that C0r is of the form Cr(C). Hence, we have

oe1 = Cr(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec) (6) oe2 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec)

oe1 = Cr(C(8 (fi0 = 8 (Q2) 8 (ff0 = oe0a) oe0b) oe0c)) (7)

oe3 = Cr(C(8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c))
From (6) and (7), we get C(8 (fi0 = 8 (Q2) 8 (ff0 = oe0a) oe0b) oe0c) = 8 (fi = 8 (Q1) 8 (ff = oea)
oeb) oec. We have six choices for C:

* C is of the form 8 (fi = 8 (Q1) 8 (ff = oea) oeb) C0. We get the expected solution by

taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) C0(8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c))

* C is of the form 8 (fi = 8 (Q0) [ ]) oec and dom(Q0) ae dom(Q1): Then oe0c is

8 (Q00) 8 (ff = oea) oeb. We get the expected result by taking oe4 = Cr(8 (ff = oea)
8 (fi = 8 (Q0) 8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) 8 (Q00) oeb) oec).

* C is of the form 8 (fi = 8 (Q1) [ ]) oec: Then fi0 is ff. We get the expected result

by taking oe4 = Cr(8 (ff0 = oe0a) 8 (ff = 8 (Q2) oe0b) 8 (fi = 8 (Q1) oe0c) oec).

* C is of the form 8 (fi = 8 (Qa) 8 (fl = C0) 8 (Qb) 8 (ff = oea) oeb) oec: We get the

expected solution by taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Qa) 8 (fl = C0(8 (ff0 = oe0a)
8 (fi0 = 8 (Q2) oe0b) oe0c)) 8 (Qb) oeb) oec)

* C is of the form 8 (fi = 8 (Q1) 8 (ff = C0) oeb) oec: We get the expected solution by

taking oe4 = Cr(8 (ff = C0(8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c)) 8 (fi = 8 (Q1) oeb) oec)

258

259

* C is of the form 8 (fi = 8 (Q1) 8 (ff = oea) C0) oec: We get the expected solution by

taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) C0(8 (ff0 = oe0a) 8 (fi0 = 8 (Q2) oe0b) oe0c)) oec)

ffi Case StSh-Up and StSh-Alias: We have
oe1 = Cr(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec) oe1 = C0r(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe02) oe001 )

oe2 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec) oe3 = C0r(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) oe001 )
and by hypothesis, oe01 j oe02. We proceed by case analysis on Cr and C0r.

Subcase Cr = C0r: then, fi = ff1, thus we have
oe1 = Cr(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec) oe1 = Cr(8 (fi = oe01) 8 (Q0) 8 (ff2 = oe02) oe001 )

oe2 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec) oe3 = Cr(8 (fi = oe01) 8 (Q0) 8 (ff2 = fi) oe001 )

oe01 = 8 (Q1) 8 (ff = oea) oeb oec = 8 (Q0) 8 (ff2 = oe02) oe001
Taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) 8 (Q0) 8 (ff2 = fi) oe001 ) is appropriate.

Subcase Cr and C0r are disjoint: by Lemma 2.4.6 (page 76), there exists a
two-hole context C2 such that Cr = C2([ ], 8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe02) oe001 ) and
C0r = C2(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec, [ ]). Then taking oe4 = C2(8 (ff = oea) 8 (fi =
8 (Q1) oeb) oec, 8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) oe001 ) is appropriate.

Subcase Cr is of the form C0r(C): we have

oe1 = C0r(C(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec))

oe1 = C0r(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe02) oe001 )
oe2 = C0r(C(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec))

oe3 = C0r(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) oe001 )
We have five choices for C:

* C = 8 (ff1 = C0) 8 (Q0) 8 (ff2 = oe02) oe001 : we get the expected solution by taking

oe4 = C0r(8 (ff1 = C0(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec)) 8 (Q0) 8 (ff2 = ff1) oe001 )

* C = 8 (ff1 = oe01) 8 (Qa) [ ] with ff2 /2 dom(Qa). We have 8 (Qa) 8 (fi = 8 (Q1)

8 (ff = oea) oeb) oec = 8 (Q0) 8 (ff2 = oe02) oe001 .

259

260 Preuves (de'tails techniques)

If fi = ff2, then taking oe4 = C0r(8 (ff = oea) 8 (ff1 = 8 (Q1) oeb) 8 (Q0) 8 (ff2 = ff1) oec)
is appropriate.

Otherwise, fi 2 dom(Q0) and oec is of the form 8 (Q2) 8 (ff2 = oe02) oe001 . Then taking
oe4 = C0r(8 (ff1 = oe01) 8 (Qa) 8 (ff = oea) 8 (fi = 8 (Q1) oeb) 8 (Q2) 8 (ff2 = ff1) oe001 ) is
appropriate.

* C = 8 (ff1 = oe01) 8 (Qa) 8 (fl = C0) 8 (Qb) 8 (ff2 = oe02) oe001 : we get the expected

solution by taking oe4 = C0r(8 (ff1 = oe01) 8 (Qa) 8 (fl = C0(8 (ff = oea) 8 (fi = 8 (Q1)
oeb) oec)) 8 (Qb) 8 (ff2 = ff1) oe001 )

* C = 8 (ff1 = oe01) 8 (Q0) 8 (ff2 = C0) oe001 : we get the expected solution by taking

oe4 = C0r(8 (ff1 = C0(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec)) 8 (Q0) 8 (ff2 = ff1) oe001 )

* C = 8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe02) C0: we get the expected solution by taking

oe4 = C0r(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) C0(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec))

Subcase C0r is of the form Cr(C): we have

oe1 = Cr(8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec) (8)
oe1 = Cr(C(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe02) oe001 )) (9)

oe2 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) oec)
oe3 = Cr(C(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) oe001 ))
From (8) and (9), we get

C(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = oe01) oe001 )) = 8 (fi = 8 (Q1) 8 (ff = oea) oeb) oec
We have eight choices for C:

* C is of the form 8 (fi = 8 (Q1) 8 (ff = oea) oeb) C0: we get the expected result by

taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) oeb) C0(8 (ff1 = oe01) 8 (Q0) 8 (ff2 = ff1) oe001 )).

* C is of the form 8 (fi = 8 (Qa) [ ]) oec with dom(Qa) ae dom(Q1) and ff = ff2: then,

Q1 = (Qa, ff1 = oe01, Q0). We get the expected result by taking oe4 = Cr(8 (ff1 =
oe01, ff = ff1) 8 (fi = 8 (Qa, Q0) oeb) oec).

* C is of the form 8 (fi = 8 (Qa) [ ]) oec with dom(Qa) ae dom(Q1) and ff 2 dom(Q0):

then, Q0 = (Qb, ff = oea, Qc) We get the expected result by taking oe4 = Cr(8 (ff =
oea) 8 (fi = 8 (Qa, ff1 = oe01, Qb, Qc, ff2 = ff1) oe001 ))).

260

261

* C is of the form 8 (fi =8 (Qa) [ ]) oec with dom(Qa) ae dom(Q1) and ff2 2 dom(Q1):

then, Q1 = (Qa, ff1 = oe01, Q0, ff2 = oe02, Qb) We get the expected result by taking
oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Qa, ff1 = oe01, Q0, ff2 = ff1, Qb) oeb) oec).

* C is of the form 8 (fi = 8 (Q1) [ ]) oec (that is, ff1 = ff): we get the expected result

by taking oe4 = Cr(8 (ff1 = oe01, ff2 = ff1) 8 (fi = 8 (Q1, Q0) oe001 ) oec).

* C is of the form 8 (fi = 8 (Qa) 8 (fl = C0) 8 (Qb) 8 (ff = oea) oeb) oec: we get the

expected result by taking oe4 = Cr(8 (ff=oea) 8 (fi=8 (Qa, fl=C0(8 (ff1=oe01, Q0, ff2=
ff1) oe001 ), Qb) oeb) oec).

* C is of the form 8 (fi = 8 (Q1) 8 (ff = C0) oeb) oec: we get the expected result by

taking oe4 = Cr(8 (ff = C0(8 (ff1 = oe01, Q0, ff2 = ff1) oe001 )) 8 (fi = 8 (Q1) oeb) oec).

* C is of the form 8 (fi = 8 (Q1) 8 (ff = oea) C0) oec: we get the expected result by

taking oe4 = Cr(8 (ff = oea) 8 (fi = 8 (Q1) C0(8 (ff1 = oe01, Q0, ff2 = ff1) oe001 )) oec).

ffi Case StSh-Alias and StSh-Alias: we have

oe1 = Cr(8 (ff1 = oea, Q, ff2 = oeb) oe) oe2 = Cr(8 (ff1 = oea, Q, ff2 = ff1) oe)

oe1 = C0r(8 (ff01 = oe0a, Q0, ff02 = oe0b) oe0) oe3 = C0r(8 (ff01 = oe0a, Q0, ff02 = ff01) oe0)
By hypothesis, we have oea j oeb and oe0a j oe0b.

We proceed by case analysis on Cr and C0r.

Subcase Cr = C0r: then, ff1 = ff01. If ff2 is ff02, then oe2 = oe3 and we get the
result by taking oe4 = oe3. Otherwise, without loss of generality, we can assume that oe1
is of the form Cr(8 (ff1 = oea, Q, ff2 = oeb, Q1, ff02 = oe1) oe0) We get the expected result by
taking oe4 = Cr(8 (ff1 = oea, Q, ff2 = ff1, Q1, ff02 = ff1) oe0)

Subcase Cr and C0r are disjoint: by Lemma 2.4.6 (page 76), there exists a
two-hole context C2 such that Cr = C2([ ], 8 (ff01 = oe0a, Q, ff02 = oe0b) oe0) and C0r =
C2(8 (ff1 = oea, Q, ff2 = oeb) oe, [ ]). Then we get the expected result by taking oe4 =
C2(8 (ff1 = oea, Q, ff2 = ff1) oe, 8 (ff01 = oe0a, Q, ff02 = ff01) oe0).

Subcase Cr and C0r are nested: without loss of generality, we can freely assume
that C0r is of the form Cr(C). Hence, we have

oe1 = Cr(8 (ff1 = oea, Q, ff2 = oeb) oe) (10) oe2 = Cr(8 (ff1 = oea, Q, ff2 = ff1) oe)
oe1 = Cr(C(8 (ff01 = oe0a, Q0, ff02 = oe0b) oe0)) (11) oe3 = Cr(C(8 (ff01 = oe0a, Q0, ff02 = ff01) oe0))

261

262 Preuves (de'tails techniques)
From (10) and (11), we get

8 (ff1 = oea, Q, ff2 = oeb) oe = C(8 (ff01 = oe0a, Q0, ff02 = oe0b) oe0)
We have eight choices for C:

* C = 8 (ff1 = C0, Q, ff2 = oeb) oe: Then we get the expected result by taking oe4 =

Cr(8 (ff1 = C0(8 (ff01 = oe0a, Q0, ff02 = ff01) oe0), Q, ff2 = ff1) oe).

* C = 8 (ff1 = oea, Q1, 8 (fl = C0), Q2, ff2 = oeb) oe: Then we get the expected result by

taking oe4 = Cr(8 (ff1 =oea, Q1, 8 (fl =C0(8 (ff01=oe0a, Q0, ff02=ff01) oe0)), Q2, ff2=ff1) oe.

* C = 8 (ff1 = oea, Q, ff2 = C0) oe: Then we get the expected result by taking oe4 =

Cr(8 (ff1 = C0(8 (ff01 = oe0a, Q0, ff02 = ff01) oe0)Q, ff2 = ff1) oe.

* C = 8 (ff1 = oea, Q, ff2 = oeb) C0: Then we get the expected result by taking

oe4 = Cr(8 (ff1 = oea, Q, ff2 = ff1) C0(8 (ff01 = oe0a, Q0, ff02 = ff01) oe0)).

* C = 8 (ff1 = oea, Q1) [ ] with dom(Q1) ae dom(Q) and ff02 2 dom(Q): We have

Q = (Q1, ff01 = oe0a, Q0, ff02 = oe0b, Q2). Then we get the expected result by taking
oe4 = Cr(8 (ff1 = oea, Q1, ff01 = oe0a, Q0, ff02 = ff01, Q2, ff2 = ff1) oe).

* C = 8 (ff1 = oea, Q1) [ ] with dom(Q1) ae dom(Q) and ff2 = ff02: we have oe1 = oe01

and Q = (Q1, ff01 = oe0a, Q0). Then we get the expected result by taking oe4 =
Cr(8 (ff1 = oea, Q1, ff01 = ff1, Q0, ff2 = ff1) oe).

* C = 8 (ff1 = oea, Q1) [ ] with dom(Q1) ae dom(Q) and ff2 2 dom(Q0): we have

Q0 = (Qa, ff2=oeb, Qb). Then we get the expected result by taking oe4 = Cr(8 (ff1 =
oea, Q1, ff01 = oe0a, Qa, ff2 = ff1, Qb, ff02 = ff01) oe0).

* C = 8 (ff1 = oea, Q) [ ] (that is, ff2 = ff01): we have oe1 = oe01. Then we get the

expected result by taking oe4 = Cr(8 (ff1 = oea, Q, ff01 = ff1, Q0, ff02 = ff1) oe0).

Property ii: By hypothesis, we have oe1, oe2 and oe3 such that (Q) oe1 (j .@-;) oe2 and
(Q) oe2 (j .@-;) oe3 hold. We have to show that there exists oe4 such that (Q) oe2 (j .@-;)

* oe

4

and (Q) oe3 (j .@-;)

* oe

4. By Property 2.6.2.i (page 84), the relations (j .@-;)

* and @- are

equivalent, thus it suffices to show that there exists oe4 such that (Q) oe2 @- oe4 and
(Q) oe3 @- oe4. If (Q) oe1 j oe2 or (Q) oe1 j oe3 hold, then taking (respectively) oe4 = oe3 or
oe4 = oe2 gives the expected result. Otherwise, by definition, there exist oea1 , oe02, oeb1 and
oe03 such that we have

(Q) oe1 j oea1 (1) (Q) oea1 .@-; oe02 (2) (Q) oe02 j oe2 (Q) oe1 j oeb1

(Q) oeb1 .@-; oe03 (Q) oe03 j oe3

262

263
Figure A.1: Commutation
oe1 oea1 oe02 oe2

oeb1 oe01 oe002
oe03 oe003 oe4
oe3

j
j

j

j

j

j
.@-;

.@-;

j

j

.@-;
.@-; @-

@-

Let oe01 be nf(oe1). By Property 1.5.6.iv (page 53), oe01 is in normal form, and by Property 1.5.6.i (page 53), oe01 j oe1 holds.

We represent these relations by the solid arrows of figure A.1, to be read under
prefix Q. The dotted arrows correspond to relations shown below.

By Property 1.5.11.i (page 56) and (1), nf(oea1 ) ss oe01 holds. By (2), Properties 2.6.3.i

(page 85) and 2.6.3.ii (page 85), there exists oe002 such that (Q) oe02 j oe002 and (Q) oe01 .@-; oe002 .
Similarly, there exists oe003 such that (Q) oe03 j oe003 and (Q) oe01 .@-; oe003 . Hence, we have

(Q) oe1 j oe01 (Q) oe01 .@-; oe002 (Q) oe002 j oe2 (Q) oe01 .@-; oe003 (Q) oe003 j oe3
By Property i, there exists oe4 such that (Q) oe002 @- oe4 and (Q) oe003 @- oe4. Consequently,
(Q) oe2 @- oe4 holds by A-Equiv and R-Trans. Similarly, (Q) oe3 @- oe4 holds. This is
the expected result.

Property iii: Intuitively, there are no critical pair in this configuration. By hypothesis,
we have (Q) oe1 .@ oe2 (1) and (Q) oe1 .@-_ff oe3 (2). All rules available to derive (1) are
of the form (Q) Cf (oe01) .@ Cf (oe02), thus there exist a flexible context Cf and types
oe01 and oe02 such that we have oe1 = Cf (oe01) (3) and oe2 = Cf (oe02). Similarly, there
exist a rigid context Cr and types oe001 and oe03 such that we have oe1 = Cr(oe001 ) (4)
and oe3 = Cr(oe03). We proceed by case analysis on the pair (Cf , Cr). Since oe1 is
in normal form, Cf cannot be of the form 8 (Q1, ff = C0f ) oeff and Cr cannot be of
the form 8 (Q1, ff >= C0r) oeff, with nf(oeff) = ff. By (3) and (4), we must always have

263

264 Preuves (de'tails techniques)
oe1 = Cf (oe01) = Cr(oe001 ) (5). Additionally, Rule StSh-Hyp cannot be used to derive (2)
because the prefix is unconstrained.

ffi Case 8 (Q1) [ ], 8 (Q1) [ ]: The rule used to derive (2) is either StSh-Up, or
StSh-Alias. In both cases oe1 is of the form Cr(8 (ff = oea) oeb) (6). Hence, oe1
must be of the form 8 (Q1) (8 (ff = oea) oeb). If Rule S-Hyp is used to derive (1),
then oe1 must be of the form Cf (oe0), where (Q) ? j cCf (oe0) (because Q is unconstrained). By Property 1.5.11.vi (page 56), we must have oe0/ffl = ?. Hence, oe0 j ?
by Property 2.1.5.iii (page 67). Moreover, oe0 is in normal form since oe1 is in normal form. Hence, oe0 must be ?. In summary, oe1 is 8 (Q1) ?, which is a contradiction with (6). Hence, Rule S-Hyp cannot be used. All other rules available to
derive (1) imply that oe1 is of the form Cf (8 (ff >= oea) oeb). Consequently, we should have
8 (Q1) 8 (ff >= oea) oeb = 8 (Q1) 8 (ff = oea) oeb, which is a contradiction. Thus this case
cannot occur.

ffi Case (8 (Q1, ff >= C0f ) oe0, 8 (Q1, ff >= oea) C0r): By (5), we must have oea = C0f (oe01) and
oe0 = C0r(oe001 ). Hence, oe1 is 8 (Q1, ff >= C0f (oe01)) C0r(oe001 ). We get the expected result by
taking oe4 = 8 (Q1, ff >= C0f (oe02)) C0r(oe03).

ffi Case (8 (Q1, ff = oea) C0f , 8 (Q1, ff = C0r) oe0): By (5), we must have oea = C0r(oe001 ) and
oe0 = C0f (oe01). Hence, oe1 is 8 (Q1, ff = C0r(oe001 )) C0f (oe01). We get the expected result by
taking oe4 = 8 (Q1, ff = C0r(oe03)) C0f (oe02).

ffi Case 8 (Q1) [ ], 8 (Q1) C0r (the case where C0r is [ ] has already been discarded):
By (5), we must have oe01 = C0r(oe001 ) (7). We consider the rule used to derive (1):

Subcase S-Hyp: Necessarily, oe1 is of the form 8 (Q1) ?. This is a contradiction
with oe1 = 8 (Q1) C0r(oe001 ) and C0r different from [ ].

Subcase S-Up: we have oe01 = 8 (fi >= 8 (Q0, ff \Pi  oe) oe0) oe00. By (7), we must have
C0r = 8 (fi >= 8 (Q0, ff \Pi  oe) oe0) C00r and C00r (oe001 ) = oe00. We get the expected result by taking
oe4 = 8 (Q1) 8 (ff \Pi  oe) 8 (fi >= 8 (Q0) oe0) C00r (oe03).

Subcase S-Alias: We have oe01 = 8 (ff1 >= oea, Q0, ff2 >= oeb) oe0. If C0r is of the form
8 (Q1, ff = C00r ) oe0 with ff 2 dom(Q0) or ff2 2 dom(Q1), we get the expected result by
taking oe4 = 8 (Q01, ff = C00r (oe03)) oe00, and Q01 and oe00 are, respectively, Q1 and oe0, where
the binding (ff2 >= oeb) is replaced by (ff2 = ff1). Otherwise, C0r is of the form 8 (Q2) [ ].
We proceed by case on the rule used to derive (2).

* Rule StSh-Up: we have oe001 = 8 (fi = 8 (Qa, ff \Pi  oe) oe0) oe00. Hence, by (7), we get

8 (ff1 >= oea, Q0, ff2 >= oeb) oe0 = 8 (Q2, fi = 8 (Qa, ff \Pi  oe) oe0) oe00. Necessarily, fi is in
dom(Q0) or ff2 is in dom(Q2). In both cases, we get the expected result by taking
oe4 = 8 (Q02, ff \Pi  oe, fi = 8 (Qa) oe0) oe002 and Q02 and oe002 are, respectively, Q2 and oe00,
where the binding (ff2 >= oeb) is replaced by (ff2 = ff1).

* Rule StSh-Alias: We have oe001 = 8 (ff01 = oe0a, Q00, ff02 = oe0b) oe00. By (7), we get

8 (ff1 >= oea, Q0, ff2 >= oeb) oe0 = 8 (Q2, ff01 = oe0a, Q00, ff02 = oe0b) oe00. Necessarily, ff2 is

264

265
in dom(Q2) [ dom(Q00) or ff01 and ff02 are in dom(Q0). In all cases, we get the
expected result by taking 8 (Q02, ff01 = oe0a, Q002, ff02 = ff01) oe002 and Q02, Q002 and oe002 are,
respectively, Q2, Q00 and oe00, where the binding (ff2 >= oeb) is replaced by (ff2 = ff1).

Subcase S-Nil: We have oe01 = ?. By (7), we must have ? = C 0r(oe001 ), which is
a contradiction, since C0r is not [ ].

Subcase S-Rigid: We have oe01 = 8 (ff>=oe0) oe. By (7), we must have C 0r = 8 (ff>=
oe0) C00r and C00r (oe001 ) = oe. We get the expected result by taking oe4 = 8 (ff = oe0) C00r (oe03).

ffi Case 8 (Q1) C0f , 8 (Q1) [ ] (the case where C0f is [ ] has already been discarded):
By (5), we must have oe001 = C0f (oe01). We consider the rule used to derive (2):

Subcase StSh-Up: similar to S-Up above.
Subcase StSh-Alias: similar to S-Alias above.

Property iv: Intuitively, there are no critical pair in this configuration. By hypothesis,
we have (Q) Cf (oe1) .@-_ff oe3 (1) and (QCf ) oe1 .@-_ff oe2. From (1), we have Cf (oe1) =
Cr(oe01) (2) for some Cr and oe01, and oe3 is Cr(oe03). We proceed by case analysis on the
pair (Cf , Cr):

ffi Case Cf and Cr are disjoint: By Lemma 2.4.6 (page 76) and (2), there exists a twohole context C2 such that Cf = C2([ ], oe01) and Cr = C2(oe1, [ ]). Taking oe4 = C2(oe2, oe03)
gives the expected result.

ffi Case Cr is of the form Cf (C0) is not possible since level(Cf ) > 1.
ffi Case Cf is of the form Cr(C0f ): necessarily, level(Cr) = 1, that is, by Property 2.4.4.i
(page 74), Cr is of the form 8 (Q1) [ ]. Besides, level(C0f ) > 1. The hypothesis (1) can

be written this way: (Q) 8 (Q1) C0f (oe1) .@-_ff 8 (Q1) oe03 (3). Two rules can be used to
derive (3):

Subcase StSh-Up: Then C 0f (oe1) = 8 (fi = 8 (Q0, ff = oe) oe0) oe00. Necessarily, C0f
is of the form 8 (fi = 8 (Q0, ff = oe) oe0) C00f . Then we get the expected result by taking
oe4 = 8 (Q1, ff = oe, fi = 8 (Q0) oe0) C00f (oe2)

Subcase StSh-Alias: Then C 0f (oe1) = 8 (ff1 = oe, Q0, ff2 = oe0) oe00 with oe j oe0,
and oe3 is 8 (ff1 = oe, Q0, ff2 = ff1) oe00. Necessarily, C0f is of the form 8 (ff1 = oe) 8 (Q0)
8 (ff >= C00f ) oe0, where ff 2 dom(Q0) or ff2 2 dom(Q0). In both cases, we get the expected
result by taking oe4 = 8 (Q) 8 (ff1=oe, Q00, ff>=C00f (oe2)) oe00 and Q00 and oe00 are, respectively,
Q0 and oe0 where the binding (ff2 = oe0) is replaced by (ff2 = ff1).

Proof of Property 3.2.2
Property i: Directly, if we have Q1 jI Q2, then, for any oe such that ftv(oe) ` I, we
have 8 (Q1) oe j 8 (Q2) oe, which implies 8 (Q1) oe v 8 (Q2) oe (1) by I-Equiv?, as
well as 8 (Q2) oe v 8 (Q1) oe (2). By definition, (1) implies Q1 vI Q2, and (2) implies

265

266 Preuves (de'tails techniques)
Q2 vI Q1. Conversely, let oe be such that ftv(oe) ` I. By hypothesis, Q1 vI Q2 and
Q2 vI Q1 hold, thus we have by definition 8 (Q1) oe v 8 (Q2) oe and 8 (Q2) oe v 8 (Q1) oe.
By Property 2.7.7.i (page 96), we have 8 (Q1) oe j 8 (Q2) oe. Hence, by definition,
Q1 jI Q2 holds.

Property ii: By hypothesis, we have a derivation of 8 (Q1) ? ss 8 (Q2) ? (3). We show
by induction on the derivation of (3) that there exists a derivation of 8 (Q1) oe ss 8 (Q2)
oe (4) for any oe. Actually, we get a derivation of (4) by replacing ? by oe in the
derivation of (3). Then by Property 1.5.3.iii (page 50), we have 8 (Q1) oe j 8 (Q2) oe.
Hence, by definition, Q1 j Q2 holds.

Proof of Property 3.2.3
Property i: If (Q) ff j Q(ff) holds, then we conclude by I-Equiv? and R-Trans.
From now on, we assume (Q) ff j Q(ff) does not hold. This implies bQ(ff) 2 V (1)
by Property 2.2.2.iii (page 69). By hypothesis, (Q) oe @- ff holds. By Property 2.6.2.i

(page 84), we have a derivation of (Q) oe (j .@-;)

* ff. Assume we proved the following

property:

If we have (Q) oe1 (j .@-;) oe2 and (Q) oe2 j ff, then we have either (Q) oe1 j
ff, or (Q) oe1 @- Q(ff).

Then we may conclude by induction on the size of (Q) oe (j .@-;)

* ff, Property 2.6.2.i

(page 84) and R-Trans. Therefore, it only remains to prove the property above. We
reason by case analysis. By hypothesis, we have (Q) oe2 j ff (2) and (Q) oe1 (j .@-;) oe2.
If (Q) oe1 j oe2 (3), then (Q) oe1 j ff holds by R-Trans, (3) and (2), and the result

is shown. Otherwise, by definition of (j .@-;), there exist oe01 and oe02 such that (Q) oe1 j
oe01 (4), (Q) oe01 .@-_ff oe02 (5) and (Q) oe02 j oe2 (6) hold. We have (Q) oe02 j ff by R-Trans,
(6), and (2). Hence, we have bQ(oe02) j bQ(ff) by Corollary 1.5.10. By (1), this meansb
Q(oe02) j fi, where fi = bQ(ff) (7). Hence, nf( bQ(oe02)) is fi by Property 1.5.11.i (page 56).
We get bQ(nf(oe02)) = fi by Property 1.5.6.iii (page 53), which implies nf(oe02) = fl (8)
for some variable fl such that bQ(fl) = fi (9). Three rules are available to derive (5):
However, rules StSh-Up and StSh-Alias cannot be used to derive (5), because the
side-conditions of these rules prevent oe02 from being in V. Thus, Rule StSh-Hyp must
be used. Then oe01 is Cr(oe0) (10), oe02 is Cr(ff0) (11), with (ff0 = oe0) 2 Q (12) and
(Q) oe0 j cCr(oe0) (13). Additionally, ff0 /2 dom(Cr) (14) and Cr is necessarily useful
(otherwise, we would have (Q) oe01 j oe02). We have (Q) Cr(oe0) j Cr(cCr(oe0)) (15) by
Eq-Mono, R-Context-L, and R-Context-R. From (13), we get (Q) Cr(cCr(oe0)) j
Cr(oe0) (16). By R-Trans, (10), (15), and (16), we get (Q) oe01 j Cr(oe0) (17). By
(14), we get ff0 2 ftv(Cr(ff0)), that is ff0 2 ftv(oe02), which implies ff0 2 ftv(nf(oe02))

266

267
by Property 1.5.6.ii (page 53). By (8), this means that ff0 is fl. Consequently, oe0 =
Q(fl) (18) holds from (12). By Property 2.4.4.v (page 74), (8), and (11), we must have
level(Cr) 6 1, that is level(Cr) = 1 (19) since Cr is useful (Property 2.4.3.iii (page 73)).
We have dom(Cr) # ftv(oe0) (20) by well-formedness of (12). By (19) and (20), we get
(Q) Cr(oe0) j oe0 (21) by Property 2.4.4.ii (page 74) and Eq-Free. Finally, this gives
(Q) oe1 j Q(fl) by (4), (17), (21), (18), and R-Trans. We get (Q) oe1 @- Q(fl) (22) by
A-Equiv. By Property 2.2.2.ii (page 69) applied to (7) and (9), we have Q(ff) = Q(fi)
and Q(fi) = Q(fl). Therefore, (22) gives (Q) oe1 @- Q(ff), which is the expected result.

Property ii: If (Q) oe @- ff holds, then Property i and I-Abstract give the expected
result. Hence, we assume (Q) oe @- ff does not hold. This implies oe /2 T by Lemma 2.1.6.
Furthermore, we also assume that (Q) ff j Q(ff) does not hold (if it holds, we get the
result by I-Equiv? and R-Trans). This implies bQ(ff) 2 V (1) by Property 2.2.2.iii
(page 69). By Property 2.6.2.ii (page 84), we have a derivation of (Q) oe (j .v)* ff.
Assume we proved the following property:

If we have (Q) oe1 (j .v) oe2 and (Q) oe2 j ff, then we have either (Q) oe1 j ff,
or (Q) oe1 v Q(ff).

Then we conclude by induction on the size of (Q) oe (j .v)* ff, Property 2.6.2.ii (page 84)
and R-Trans. Therefore, it remains only to show the property above. We reason by
case analysis. By hypothesis, we have (Q) oe2 j ff (2) and (Q) oe1 (j .v) oe2. If
(Q) oe1 j oe2 (3), then (Q) oe1 j ff holds by R-Trans, (3) and (2), and the result
is shown. Otherwise (4) there exist oe01 and oe02 such that (Q) oe1 j oe01 (5), (Q) oe01 .v
oe02 (6) and (Q) oe02 j oe2 (7). We have (Q) oe02 j ff (8) by R-Trans, (7), and (2).
Hence, we have bQ(oe02) j bQ(ff) by Corollary 1.5.10. By (1), this means bQ(oe02) j fi,
where fi = bQ(ff) (9). Hence, nf( bQ(oe02)) is fi by Property 1.5.11.i (page 56). We getb
Q(nf(oe02)) = fi by Property 1.5.6.iii (page 53), which implies nf(oe02) = fl (10) for some
variable fl such that bQ(fl) = fi (11) holds. Three rules are available to derive (6):

ffi Case C-Strict: Then we have (Q) oe01 .@ oe02 (12) and oe02 2 V (13) (by (10)). Rules
S-Up, S-Alias, S-Rigid cannot be used to derive (12), because the side-conditions of
these rules prevent oe02 from being in V. If Rule S-Nil is used, then there exists a useful
context Cf and a closed type oe such that oe02 is Cf (oe). Since oe02 2 V, this implies
oe 2 V, which is a contradiction with ftv(oe) = ;. Hence this rule cannot be used. Last,
Rule S-Hyp is used to derive (12), and oe01 is Cf (oe0) (14), oe02 is Cf (ff0) (15), with

(ff0 >= oe0) 2 Q (16) and (Q) oe0 j cCf (oe0) (17). Additionally, ff0 /2 dom(Cf ) (18),
and Cf is necessarily useful (otherwise, we would have (Q) oe01 j oe02). We have (Q)

Cf (oe0) j Cf ( cCf (oe0)) (19) by Eq-Mono, R-Context-L, and R-Context-R. By
(17), we have (Q) Cf ( cCf (oe0)) j Cf (oe0) (20). By R-Trans, (14), (19), and (20), we
get (Q) oe01 j Cf (oe0) (21). By (18), we get ff0 2 ftv(Cf (ff0)), that is ff0 2 ftv(oe02), which

267

268 Preuves (de'tails techniques)
implies ff0 2 ftv(nf(oe02)) by Property 1.5.6.ii (page 53). By (10), this means that ff0 is
fl. Consequently, oe0 = Q(fl) (22). By Property 2.4.4.v (page 74), (13), and (15), we
must have level(Cf ) 6 1, that is level(Cf ) = 1 (23) since Cf is useful (Property 2.4.3.iii
(page 73)). We have dom(Cf ) # ftv(oe0) (24) by well-formedness of (16). By (23)
and (24), we get (Q) Cf (oe0) j oe0 (25) by Property 2.4.4.ii (page 74) and Eq-Free.
Finally, this gives (Q) oe1 j Q(fl) by (5), (21), (25), (22), and R-Trans. We get
(Q) oe1 v Q(fl) (26) by I-Equiv?. By Property 2.2.2.ii (page 69) applied to (9) and
(11), we have Q(ff) = Q(fi) and Q(fi) = Q(fl). Therefore, (26) gives (Q) oe1 v Q(ff),
which is the expected result.

ffi Case C-Abstract-F: We must have oe02 of the form Cf (oe0) with level(Cf ) > 1.
By (10), oe02 2 V. By Property 2.4.4.v (page 74), this implies level(Cf ) 6 1, which is a
contradiction. Therefore, this case cannot occur.

ffi Case C-Abstract-R: Then by hypothesis, (Q) oe01 @- oe02 (27) holds, thus (Q)
oe1 @- ff holds by R-Trans, A-Equiv and (5), (27) and (8). We assumed (in (4)), that
(Q) oe1 j oe2 does not hold. This implies oe1 /2 T by Lemma 2.1.6. Hence, (Q) oe1 @- Q(ff)
by Property i, which gives (Q) oe1 v Q(ff) by I-Abstract. This is the expected result.

Property iii: We have (Q) Q(ff) v Q[ff] by I-Hyp or A-Hyp and I-Abstract. We
conclude by Property 2.2.2.i (page 69).

Proof of Property 3.3.2
Property i : It is shown by observing that ff 2 ftv(8 (Q2) rI[J ) is equivalent to ff 2
ftv(8 (Q2) rI ) [ ftv(8 (Q2) rJ ).
Property ii : It suffices to show the result for a single commutation. Then the result
follows by immediate induction on the number of commutations. Hence, it suffices to
show that dom(Q1, ff \Pi  oe, ff0 \Pi 0 oe0, Q0/ _ff) and dom(Q1, ff0 \Pi 0 oe0, ff \Pi  oe, Q0/_ff) are equal
when ff /2 ftv(oe0) and ff0 /2 ftv(oe). We get the expected result by observing that ff is
in ftv(8 (ff0 \Pi 0 oe0, Q0) rI ) if and only if ff is in ftv(8 (Q0) rI ), and similarly, ff0 is in
ftv(8 (ff \Pi  oe, Q0) rI ) if and only if ff0 is in ftv(8 (Q0) rI).

Proof of Property 3.4.2
Property i : It is shown by induction on the derivation of Q1 ""I` Q2. All cases are easy.

Property ii: We say that ff appears in a judgment Q1 ""I` Q2 if ff is in dom(Q1) [
dom(Q2). We say that ff appears in a derivation when it appears in one of its judgments.

By hypothesis, we have a derivation of Q ""I` Q0 (1). We show that OE(Q) ""OE(I)` OE(Q0)
holds for a renaming OE such that codom(OE) is fresh, that is, disjoint from the set of type
variables appearing in the derivation of (1). All cases are easy. Then any renaming

268

269
OE can be decomposed into OE1 ffi OE2 such that OE2 is fresh, relatively to the derivation of
Q vI` Q0, and OE1 is fresh, relatively to the derivation of OE2(Q) vOE2(I)` OE2(Q0).

Property iii: By hypothesis, we have a derivation of Q1 ""I` Q2 (1). Let OE be a renaming
mapping the domain dom(Q) - I to fresh variables (that is, outside dom(QQ1Q2)). By

Property ii, we have a derivation of OE(Q1) ""OE(I)` OE(Q2) (2). Since dom(OE) # I, we have
OE(Q1) ""I` OE(Q2) (3) from (2). Besides, by hypothesis, we have dom(Q) # dom(Q1) [
dom(Q2) (4), hence OE is invariant on Q1 and Q2. Then (3) is written Q1 ""I` Q2 (5).
The difference between (1) and (5) lies in the fact that intermediate variables (variables
introduced by PE-Free) are renamed by OE in (5), and therefore such variables are
outside dom(Q). By hypothesis utv(Q) ` I, thus utv(Q) ` dom(Q1) " dom(Q2) (6)
by well-formedness of (5). Hence, by (4) and (6), Q1Q and Q2Q are well-formed
and closed. The proof is by induction on the derivation of (5). Case PE-Refl is
immediate. We show directly cases PE-Mono, PE-Swap, PE-Comm, PE-ContextL, PA-Context-L, PI-Context-L and PI-Rigid by replacing Q0 by Q0Q. Cases
PA-Equiv and PI-Abstract are by induction hypothesis.

ffi Case PE-Free: We have Q2 = (Q1, ff \Pi  oe), with ff /2 dom(Q1) and ff /2 I (7).
Thanks to the renaming OE, we know that ff /2 dom(Q). Besides, (7) and the hypothesis
utv(Q) ` I imply that ff /2 utv(Q). Hence Q1Q j` (Q1, ff \Pi  oe, Q) holds by PE-Free
and PE-Comm. This is the expected result.

ffi Case PE-Trans, PA-Trans and PI-Trans: We have Q1 ""I` Q01 and Q01 ""I` Q2.

By induction hypothesis, we get Q1Q ""I[dom(Q)` Q01Q and Q01Q ""I[dom(Q)` Q2Q. By
PE-Trans, PA-Trans, or PI-Trans, we get Q1Q ""I[dom(Q)` Q2Q.

Property iv: By hypothesis, Q is closed (1) and well-formed, and OE is a renaming
of dom(Q). This implies that OE is injective on dom(Q). Hence, OE(Q) is closed and
well-formed. Additionally, dom(OE) ` dom(Q) holds by hypothesis, thus codom(OE) `
dom(OE(Q)). As a consequence, OE(Q)OE is closed and well-formed. Let I be dom(Q) (2).
The proof is by induction on the size of the finite set dom(OE). If this set is empty, then
Q = OE(Q) and we get the result by PE-Refl. Otherwise, let (ff \Pi  oe) be the leftmost
binding of Q such that ff 2 dom(OE). We can write Q in the form (Q1, ff \Pi  oe, Q2), and
dom(Q1) # dom(OE) (3). Since Q is closed by (1), we have ftv(oe) ` dom(Q1), hence
ftv(oe) # dom(OE) by (3). As a consequence, we have OE(oe) = oe (4). We write ff0 for
OE(ff) (5). Since OE is a renaming of dom(Q), we have dom(Q) # codom(OE), which
implies ff0 /2 dom(Q) (6). We have the following:

Q = (Q1, ff \Pi  oe, Q2) by notation

jI (Q1, ff \Pi  oe, ff0 = ff, Q2) by PE-Free and (6)
jI (Q1, ff0 \Pi  oe, ff = ff0, Q2) by PE-Swap
jI (Q1, ff0 \Pi  oe, ff = ff0, Q2[ff0/ff]) by PE-Mono?
jI (Q1, ff0 \Pi  oe, Q2[ff0/ff], ff = ff0) by PE-Comm

269

270 Preuves (de'tails techniques)
Let Q01 be (Q1, ff0 \Pi  oe, Q2[ff0/ff], ff = ff0). We have shown that Q jI Q01 (7) holds.
Applying the induction hypothesis to Q01 and on the renaming OE0 = OE| dom(OE)-ff, we get
Q01 j OE0(Q01)OE0. This gives Q01 j (Q1, ff0 \Pi  oe, OE0(Q2[ff0/ff]), ff = ff0, OE0), that is, Q01 j
(Q1, ff0 \Pi  oe, OE(Q2), ff = ff0, OE0). Since (ff = ff0, OE0) is OE, we get Q01 j (Q1, ff0 \Pi  oe, OE(Q2), OE).
Hence, Q01 j OE((Q1, ff \Pi  oe, Q2))OE holds by (4) and (5), that is, Q01 j OE(Q)OE. By
Property i, we get Q01 jI OE(Q)OE (8). By PE-Trans, (7), and (8), we get Q jI OE(Q)OE,
that is, Q j OE(Q)OE by notation and (2).

Property v: By induction on the size of dom(Q). If Q is empty, the result is by EqRefl. Otherwise, Q is (ff\Pi oe, Q0) and OE is OE1ffiOE0 = OE0ffiOE1 (1), where dom(OE0) = dom(Q0),
dom(OE1) = {ff} and OE1(ff) = ff0. We have

Q1QOE(Q)Q2
= (Q1, ff \Pi  oe, Q0, ff0 \Pi  oe, OE(Q0)Q2) by definition
v (Q1, ff \Pi  oe, Q0, ff0 = ff, OE(Q0)Q2) by PI-Context-L and I-Hyp or

by PA-Context-L and A-Hyp
= (Q1, ff \Pi  oe, Q0OE~1 OE(Q0)Q2) by definition of OE1
j (Q1, ff \Pi  oe, Q0OE~1 OE~1 (OE(Q0)Q2)) by PE-Mono?
= (Q1, ff \Pi  oe, Q0OE~1 OE0(Q0)Q2) since OE is OE1 ffi OE0 (from (1))
j (Q1, ff \Pi  oe, OE~1 Q0OE0(Q0)Q2) by PE-Comm
v (Q1, ff \Pi  oe, OE~1 Q0OE0~Q2) by induction hypothesis
j (Q1, ff \Pi  oe, Q0OE~1 OE0~Q2) by PE-Comm
= (Q1, ff \Pi  oe, Q0OE~Q2) since OE~ is OE~1 ffi OE0~ (from (1))
= Q1QOE~Q2

This is the expected result.

Proof of Lemma 3.4.4
By Lemma 2.3.3 (page 70) and (Q) oe1 "" oe2, we have a derivation of (Q) oe1 "" oe2 (1)
which is thrifty and follows the restrictions of Lemma 2.3.1. The proof is by induction
on the derivation of (1).

ffi Case Eq-Refl: Taking ` = id gives the expected result.
ffi Case Eq-Free: We have two subcases:

Subcase oe1 is 8 (ff \Pi  oe) oe2: Then Q1 is (ff \Pi  oe, Q2) and o/2 is o/1. We take
` = id. Then (QQ2) `(o/1) j o/2 holds. Let I be dom(Q1/o/1), that is, dom(Q2/o/1) since
ff /2 ftv(8 (Q2) o/1). This gives I = dom(Q2/o/2), and `(I) ` dom(Q2/o/2). Moreover,

QQ1 j

dom(Q)[I

` QQ2` holds by PE-Comm and PE-Free since ff /2 I and ff is not freein any bound of Q

2.

270

271
Subcase oe2 is 8 (ff \Pi  oe) oe1: similar.
ffi Case Eq-Comm: By taking ` = id and by PE-Comm.
ffi Case Eq-Var: We get the expected result by taking ` = id, and by observing that
cf(oe1) = cf(oe2).

ffi Case Eq-Mono: By hypothesis, (ff \Pi  oe) 2 Q and (Q) oe j o/ holds. Besides, oe2 and
oe1 are o/2 and o/1 respectively. Consequently, Q2 and Q1 are ;. Taking ` = id gives the
expected result.

ffi Case R-Context-L, R-Context-Rigid, and R-Context-Flexible: We have
oe1 = 8 (ff \Pi  oe01) oe and oe2 = 8 (ff \Pi  oe02) oe. The premise is (Q) oe01 "" oe02 (2). By hypothesis
(Lemma 2.3.1), ff 2 ftv(oe) and nf(oe) is not ff. Hence, cf(oe1) is 8 (ff \Pi  oe01) cf(oe) and
cf(oe2) is 8 (ff \Pi  oe02) cf(oe), thus Q1 is (ff \Pi  oe01, Q0) and Q2 is (ff \Pi  oe02, Q0). Then we get
the expected result by taking ` = id and by rules PE-Context-L, PA-Context-L
or PI-Context-L, and (2).

ffi Case A-Equiv: By induction hypothesis and PA-Equiv.
ffi Case I-Hyp and A-Hyp: Then oe2 is ff, with (ff \Pi  oe) 2 dom(Q). By restrictions of
Lemma 2.3.1, we must have oe /2 T . Hence, Q(ff) /2 T , which is a contradiction since,
by hypothesis, nf(oe2) 2 # implies Q(nf(oe2)) 2 T . Hence, these cases cannot occur.

ffi Case I-Abstract: By induction hypothesis, and by PI-Abstract.
ffi Case R-Trans: By hypothesis, we have (Q) oe1 "" oe01 (3) and (Q) oe01 "" oe2 (4).
Additionally, nf(oe2) 2 # implies Q(nf(oe2)) 2 T (5). Besides, nf(oe1) 6= ? (6) by
hypothesis. By Property 2.7.7.ii (page 96) and Property 1.5.6.i (page 53) applied to (3)
and (6), we get nf(oe01) 6= ?. By Properties 2.2.2.vi (page 69) and 1.5.6.i (page 53)
applied to (4) and (5), nf(oe01) 2 # implies Q(nf(oe01)) 2 T . Let 8 (Q1) o/1 be cf(oe1).
By induction hypothesis on (3), there exists an alpha-conversion of cf(oe 01), written
8 (Q01) o/ 01 and a substitution `1 such that we have

(QQ01) `1(o/1) j o/ 01 (7) I1

M= dom(Q1/o/1) (8) dom(`1) ` I1 (9)

`1(I1) ` dom(Q) [ dom(Q01/o/ 01) (10) QQ1 ""dom(Q)[I1` QQ01`1 (11)
From (9) and (8), we get dom(`1) ` dom(Q1) (12). By induction hypothesis and (4),
there exists an alpha-conversion of cf(oe2), written 8 (Q2) o/2 and a substitution `2 such
that we have

(QQ2) `2(o/ 01) j o/2 (13) I2

M= dom(Q0

1/o/ 01) (14) dom(`2) ` I2 (15)

`2(I2) ` dom(Q) [ dom(Q2/o/2) (16) QQ01 ""dom(Q)[I2` QQ2`2 (17)

271

272 Preuves (de'tails techniques)
Let OE (18) be a renaming mapping dom(Q2) to fresh variables (that is, outside the
domain dom(QQ1) [ dom(Q01)). We have dom(OE) ` dom(Q2) (19) and OE is a renaming of dom(QQ2) (20). Let Q02 be OE(Q2) and o/ 02 be OE(o/2). We note that 8 (Q02) o/ 02
is an alpha-conversion of 8 (Q2) o/2, that is, an alpha-conversion of cf(oe2). Let `02 be
OE ffi `2 restricted to I2. By definition, we have dom(`02) ` I2 (21). By Property 1.7.2.i
(page 60) applied to (13), we get (QOE(Q2)) OE(`2(o/ 01)) j OE(o/2), that is, (QQ02) `02(o/ 01) j
o/ 02 (22). The prefix QQ2 is a closed well-formed prefix (23). By Property 3.4.2.iv
(page 106), (20) and (23), we get QQ2 j OE(QQ2)OE, that is, QQ2 j QOE(Q2)OE (24).
By well-formedness of (17), QQ2`2 is well-formed. Hence, dom(`2) # dom(QQ2)
holds (we simply write `2 # QQ2 (25)). From (19) and (25), we get `2 # OE (26).
From (15) and (14), we get dom(`2) ` dom(Q01). By definition of OE (18), this implies
dom(`2) # codom(OE), thus `2 # OE(Q2) (27) holds. Hence, from (25), (26), and (27),
we have `2 # QOE(Q2)OE (28). Additionally, codom(`2) ` dom(Q) [ dom(Q2) (29)
holds from (16). By Property 3.4.2.iii (page 106), (28), (25), (29), and (24), we
get QQ2`2 j QOE(Q2)OE`2 (30). By PE-Free and (30), we get QQ2`2 jdom(Q)[I2

QQ02`02 (31). By PE-Trans, (17), and (31), we have QQ01 ""

dom(Q)[I2

` QQ02`02 (32).Applying OE to (16), we get `0

2(I2) ` dom(Q) [ dom(Q02/o/ 02) (33). By (21) and (14), weget
dom(`02) ` dom(Q01). In summary, we have shown

(QQ02) `02(o/ 01) j o/ 02 (22) I2

M= dom(Q0

1/o/ 01) (14) dom(`02) ` I2 (21)

`02(I2) ` dom(Q) [ dom(Q02/o/ 02) (33) QQ01 ""

dom(Q)[I2

` QQ02`02 (32)

Since (11) is well-formed, we have `1 # QQ01 (34). By (14), we get I2 ` dom(Q01).
Hence, dom(`1) # dom(Q) [ I2 (35) holds by (34). Thus, by (21), is also gives
dom(`1) # dom(`02) (36). By (12) and by definition of OE (18), we have dom(`1) #
dom(Q02) (37). Hence, we have `1 # QQ02`02 (38) from (34), (37), and (36). Additionally, codom(`1) ` dom(Q) [ dom(Q01/o/ 01) holds by (10). Hence, by (14), we get
codom(`1) ` dom(Q) [ I2 (39). In summary, we have shown

`1 # QQ01 (34) `1 # QQ02`02 (38) codom(`1) ` dom(Q) [ I2 (39)
By Property 3.4.2.iii (page 106) and (32), we get the relation

QQ01`1 ""

dom(Q)[I2[dom(`1)

` QQ02`02`1

(40). Additionally, from (10), we have I1 ` dom(Q01/o/ 01) [ dom(`1), that is, I1 `
I2 [ dom(`1). Hence, by Property 3.4.2.i (page 106) applied to (40), we get the relation QQ01`1 ""

dom(Q)[I1

` QQ02`02`1 (41). Then, by transitivity, (11), and (41), we get

QQ1 ""dom(Q)[I1` QQ02`02`1 (42). Let ` be `02ffi`1 restricted to I1, so that dom(`) ` I1 (43)

272

273
holds. By Eq-Free and (42), we get QQ1 ""

dom(Q)[I1

` QQ02` (44). We have

`(I1) = `02 ffi `1(I1) by definition

` `02(dom(Q) [ dom(Q01/o/ 01)) by (10).
= dom(Q) [ `02(dom(Q01/o/ 01)) since dom(`02) # dom(Q) by (21).
= dom(Q) [ `02(I2) by (14).
` dom(Q) [ dom(Q02/o/ 02) by (33).

Consequently, we have `(I1) ` dom(Q) [ dom(Q02/o/ 02) (45).

We have ftv(o/1) ` dom(Q)[dom(Q1/o/1). Hence, ftv(`1(o/1)) ` dom(Q)[`1(I1), that
is, by (10), ftv(`1(o/1)) ` dom(Q) [ I2. Additionally, ftv(o/ 01) ` dom(Q) [ dom(Q01/o/ 01),
that is, ftv(o/ 01) ` dom(Q) [ I2 by (14). Hence, from (7), (32) and Lemma 3.4.3, we get
(QQ02`02) `1(o/1) j o/ 01. By R-Context-R, we get (QQ02) `02(`1(o/1)) j `02(o/ 01), that is,
(QQ02) `(o/1) j `02(o/ 01). By R-Trans and (22), we get (QQ02) `(o/1) j o/ 02 (46).

We have the expected result, that is, (46), (8), (43), (45) and (44).

ffi Case I-Bot: We have oe1 = ?, thus nf(oe1) is ? and this case is not possible by
hypothesis.

ffi Case I-Rigid: By taking ` = id and by PI-Rigid.
ffi Case R-Context-R: We have oe1 = 8 (ff\Pi oe) oe01 and oe2 = 8 (ff\Pi oe) oe02. The premise
is (Q, ff \Pi  oe) oe01 "" oe02 (47). We proceed by case analysis:

Subcase nf(oe01) = ff and nf(oe02) = ff: Hence, cf(oe1) is cf(oe) and cf(oe2) is cf(oe),
thus we get the expected result by taking ` = id.

Subcase nf(oe01) 6= ff and nf(oe02) = ff is not possible since the derivation is
thrifty.

Subcase nf(oe01) = ff and nf(oe02) 6= ff is not possible since the derivation is
thrifty.

Otherwise nf(oe01) 6= ff and nf(oe02) 6= ff (48): By definition, cf(oe1) is 8 (ff \Pi  oe)
cf(oe01) and cf(oe2) is 8 (ff \Pi  oe) cf(oe02). If we have nf(oe01) = ?, then nf(oe1) is ?, which is
not possible by hypothesis. Hence, nf(oe01) 6= ?. If we have nf(oe02) 2 dom(Q, ff \Pi  oe), and
(Q, ff \Pi  oe)(nf(oe02)) /2 T , then, either nf(oe02) 2 dom(Q) (49) and Q(nf(oe02)) /2 T (50), or
nf(oe02) is ff. The latter is not possible by (48). In the former case, we have nf(oe2) =
nf(oe02), thus (49) and (50) give nf(oe2) 2 dom(Q) and Q(nf(oe2)) /2 T , which is not
possible by hypothesis. Hence, nf(oe02) /2 dom((Q, ff \Pi  oe)), or (Q, ff \Pi  oe)(nf(oe02)) 2 T .
We have cf(oe1) = 8 (ff \Pi  oe) 8 (Q01) o/1. By induction hypothesis on (47), there exists an
alpha-conversion of cf(oe02) written 8 (Q02) o/2 and a substitution ` such that

(Q, ff \Pi  oe, Q02) `(o/1) j o/2 I

M= dom(Q0

1/o/1) dom(`) ` I

`(I) ` dom(Q) [ {ff} [ dom(Q02/o/2) (Q, ff \Pi  oe, Q01) ""dom(Q)[{ff}[I` (Q, ff \Pi  oe, Q02)` (51)

273

274 Preuves (de'tails techniques)

Let Q1 be (ff \Pi  oe, Q01) and Q2 be (ff \Pi  oe, Q02). The constructed form of oe1 is 8 (Q1) o/1
and 8 (Q2) o/2 is an alpha-conversion of cf(oe2). By defining I0

M= dom(Q1/o/1), we have

I ` I0 ` I [ {ff} (52). We immediately have

(QQ2) `(o/1) j o/2 I0

M= dom(Q1/o/1) dom(`) ` I0

`(I0) ` dom(Q) [ dom(Q2/o/2) (QQ1) ""dom(Q)[I

0

` (QQ2)` (53)

We get (53) from (51) by using Property 3.4.2.i (page 106) and (52).

Proof of Lemma 3.4.7
Directly, (Q) oe1 v oe2 holds by hypothesis, and Q is unconstrained. Besides, oe1 and oe2
are ML types. We proceed by case analysis:

ffi Case nf(oe1) is ?: Then oe1 is necessarily of the form 8 (Q1) ff1, with ff1 2 dom(Q1)
and Q1 is an unconstrained prefix. In ML, oe1 is written 8 (_ff) 8 (ff) ff, and we have
oe1 vML oe2, provided oe2 is an ML type.

ffi Case oe1 is in V: We have nf(oe1) = ff. Necessarily, oe1 is of the form 8 ( _ff) ff with
ff /2 _ff. By Lemma 2.1.6, (Q) oe2 j ff holds. Thus bQ(ff) is a rearrangement of bQ(nf(oe2))
by Lemma 1.5.9. Observing that bQ = id, we get nf(oe2) = ff. Hence, oe2 is of the form
8 ( _fi) ff with ff /2 _fi. Consequently, oe1 and oe2 are equivalent in ML.

ffi Case oe2 is in V: We assume nf(oe1) is not ? and oe1 is not in V. By Properties 2.1.5.ii
and 2.1.5.iii (page 67), oe1/ffl is a type constructor g. Hence, (8 (Q) oe1)/ffl is g. Since
Q is unconstrained and oe2 2 V, we have (8 (Q) oe2)/ffl = ?. This is a contradiction by
Property 2.1.3.ii (page 66). Hence, this case cannot occur.

ffi Case oe2 is not in constructed form: Necessarily, oe2 is of the form 8 ( _ff) ff, with
ff 2 _ff. Hence, oe2/ffl is ?. By Property 2.1.3.ii (page 66), we must have oe1/ffl = ? or
oe1/ffl = ff with ff 2 dom(Q). In the first case, nf(oe1) is ? by Property 2.1.5.iii (page 67)
and Property 1.5.11.i (page 56), thus this case has already been solved above. In the
second case, oe1 j ff by Property 2.1.5.ii (page 67), thus oe1 2 T by Property 1.5.11.x
(page 56) and (Q) oe1 j oe2 holds by Lemma 2.1.6. Thus, bQ(oe1) j bQ(oe2) holds by
Corollary 1.5.10. Observing that bQ is id, we get oe1 j oe2, which is a contradiction with
Property 1.5.4.i (page 51).

ffi Otherwise: oe1 is of the (constructed) form 8 (Q1) o/1, where Q1 is unconstrained.
Besides, oe2 is in constructed form too. By Lemma 3.4.4, there exists an alphaconversion of oe2, written 8 (Q2) o/2, and a substitution ` such that (QQ2) `(o/1) j o/2
holds, with dom(`) ` dom(Q1). Observing that QQ2 is unconstrained, we get `(o/1) =
o/2 by Property 1.5.11.vii (page 56). Let _ff be dom(Q1) and _fi be dom(Q2). We can write
` in the form [_o/ / _ff]. Hence, oe2 is 8 ( _fi) o/1[_o/ / _ff] (up to renaming) As a consequence, oe2
is an instance of oe1 in ML.

274

275
Conversely, oe2 is by hypothesis an instance of oe1. This means that oe1 is 8 ( _ff) o/
and oe2 is 8 ( _fi) o/ [ _o/ 0/_ff]. We can derive (Q) oe1 v oe2 by rules R-Context-Flexible,
I-Bot and Eq-Mono?.

Proof of Lemma 3.5.2
By induction on the size of Q. If Q is ;, then necessarily _ff = ;, and the algorithm
returns the pair (;, ;), which is correct. Otherwise, Q is of the form Q0q (1), where q
is (ff \Pi  oe). We consider two cases:

ffi Case ff /2 _ff: Let (Q01, Q02) be Q0" _ff. By definition, we have Q1 = Q01 (2) and Q2 =
(Q02q) (3). By induction hypothesis, we have Q01Q02 ss Q0 (4), _ff ` dom(Q01) (5), as well
as dom(Q01/ _ff) = dom(Q01) (6). Then Q01Q02q ss Q0q holds from (4), (1), (2), and (3),
that is, Q1Q2 ss Q (i). By (2), (5) and (6), we have _ff ` dom(Q1) and dom(Q1/ _ff) =
dom(Q1), which is the expected result (ii) and (iii).

ffi Case ff 2 _ff: Let _fi be ( _ff - ff) [ ftv(oe). By definition 3.3.1 and (1), we have
dom(Q/ _ff) = ff [ dom(Q0/ _fi) (7). Let (Q01, Q02) be Q0" _fi. By definition, we have
Q1 = Q01q (8) and Q2 = Q02 (9). By induction hypothesis, Q01Q02 ss Q0 (10), _fi `
dom(Q01) (11) and dom(Q01/ _fi) = dom(Q01) (12). We have ftv(oe) ` _fi. Hence, by (11),
ftv(oe) ` dom(Q01), which implies ftv(oe) # dom(Q02). Hence, we have Q01qQ02 ss Q01Q02q,
thus Q01qQ02 ss Q0q holds from (10), that is, Q1Q2 ss Q (i) from (8) and (9). From (11),
we have _ff ` dom(Q01) [ {ff}, that is, _ff ` dom(Q1) (ii). Finally, dom(Q/ _ff) is
dom(Q01qQ02/ _ff) (13) by Property 3.3.2.ii (page 104) and (i). Besides, dom(Q01qQ02/ _ff)
is dom(Q01q/_ff) (14) since _ff # dom(Q02). Similarly, dom(Q0/ _fi) is dom(Q01/ _fi) (15).

Thus, we can prove the following sequence of equalities:

dom(Q1/ _ff) = dom(Q01q/ _ff) by (8)

= dom(Q01qQ02/_ff) by (14)
= dom(Q/ _ff) by (13)
= ff [ dom(Q0/ _fi) by (7)
= ff [ dom(Q01/ _fi) by (15)
= ff [ dom(Q01) by (12)
= dom(Q1) by (8)

This is the expected result (iii).

Proof of Lemma 3.6.2
By hypothesis, we have Q ""I Q0 (1). Let (Q1, Q00) be Q"I. By Lemma 3.5.2, Q1Q00 (2)
is a rearrangement of Q, I ` dom(Q1) (3) and dom(Q1/I) = dom(Q1) (4). We get
dom(Q/I) = dom(Q1) (5) from (4) and (2). From (2), we get dom(Q00) # dom(Q1),

275

276 Preuves (de'tails techniques)
which implies dom(Q00) # dom(Q/I) (6) by (5) as well as dom(Q00) # I (7) by (3).
We have Q jI Q1 by (2), Property 3.2.2.ii (page 103), PE-Free, and (7). Thus
Q1 ""I Q0 (8) holds from (1) and R-Trans. Moreover, dom(Q/I) # dom(Q00) holds
from (2) and (5). Let OE be a renaming of dom(Q0) disjoint from I such that dom(OE(Q0))"
dom(Q1) = I and OE(Q0) # Q00 (9). By Lemma 3.6.1 (page 113) and (8), there exists
a substitution ` such that Q1 ""J OE(Q0)` (10) holds, where J is dom(Q1/I), that is
dom(Q1) (11) by (4). Additionally, we have dom(`) ` J - I, which implies dom(`) #
I (12) and dom(`) # dom(Q00) (13) by (11) and (2). We have Q1 "" OE(Q0)` (14)
from (10) and (11). By Property 3.4.2.iii (page 106), (9), (13), and (14) we get Q1Q00 ""
OE(Q0)`Q00 (15). We define Q0 as `Q00 (16). Note that dom(Q0) # I (17) by (7)
and (12). From (15), (2), and (16), we get Q "" OE(Q0)Q0 (18). Finally, we have
Q0 j OE(Q0)OE by Property 3.4.2.iv (page 106). Since OE is disjoint from I, we get
Q0 jI OE(Q0) (19) by PE-Free. Besides we have OE(Q0)Q0 jI OE(Q0) (20) by PEFree and (17). Hence, by PE-Trans, (19), and (20), we get Q0 jI OE(Q0)Q0 (21).
We have shown the expected results, namely, (18), (17), (21), (16), and (6).

Proof of Property 3.6.3
We prove each property independently.

Property i: By hypothesis, (Q, ff \Pi  oe) oe1 "" oe2 holds. Hence, (Q) 8 (ff \Pi  oe) oe1 ""
8 (ff \Pi  oe) oe2 holds by R-Context-R. We conclude by R-Trans and observing that
(Q) 8 (ff \Pi  oe) oe1 j oe1 and (Q) 8 (ff \Pi  oe) oe2 j oe2 hold by Eq-Free.

Property ii: We prove by induction that for any Q, Q0, oe1 and oe2, if (Q, ff >= o/, Q0)
oe1 "" oe2 holds, then (Q, ff = o/, Q0) oe1 "" oe2 holds too. Equivalence cases are discarded
since "" is @- or v. Cases R-Trans, R-Context-Rigid, R-Context-Flexible and
I-Abstract are by induction hypothesis. Cases I-Bot and I-Rigid do not read the
prefix, thus (Q, ff = o/, Q0) oe1 v oe2 still holds.

ffi Case R-Context-R we have oe1 = 8 (fi\Pi oe) oe01 and oe2 = 8 (fi\Pi oe) oe02. By hypothesis,
(Q, ff>=o/, Q0, fi \Pi oe) oe01 "" oe02 holds. By induction hypothesis, (Q, ff=o/, Q0, fi \Pi oe) oe01 "" oe02
holds too. Hence, (Q, ff = o/, Q0) oe1 "" oe2 holds by R-Context-R.

ffi Case A-Hyp: Then oe2 = fi. If fi is not ff, the result is immediate. Otherwise,
(Q, ff \Pi  o/, Q0) o/ @- ff holds by Eq-Mono.

ffi Case I-Hyp: similar.

Remark that we do not read the prefix, except in the last two cases. As a consequence, we use the same proof structure for the next properties, and we only need to
show the result for cases A-Hyp and I-Hyp.

Property iii: We have (Q, ff \Pi  oe, ff0 = ff, Q0) oe1 "" oe2.

276

277
ffi Case A-Hyp: We have oe2 = fi. If fi is neither ff nor ff0, we get the result by
A-Hyp. If fi is ff, we have oe1 = oe, and (Q, ff0 \Pi  oe, ff = ff0, Q0) oe1 @- ff0 holds by A-Hyp,
thus (Q, ff0 \Pi  oe, ff = ff0, Q0) oe1 @- ff holds by R-Trans, Eq-Mono and A-Equiv. If fi
is ff0, we have oe1 = ff, and (Q, ff0 \Pi  oe, ff = ff0, Q0) oe1 @- ff0 holds by Eq-Mono.

ffi Case I-Hyp: similar.

Property iv: We have (Q) oe j oe0 (1) and (Q, ff \Pi  oe, Q0) oe1 "" oe2. As explained above,
we only need to consider cases A-Hyp and I-Hyp. In both cases, oe2 is a variable fi.

ffi Case A-Hyp: If fi is not ff, the result is by A-Hyp. Otherwise, we have oe1 = oe
and \Pi  is =. We have (Q, ff \Pi  oe0, Q0) oe j oe0 (2) from (1) and Property 1.5.3.v (page 50).
Additionally, (Q, ff \Pi  oe0, Q0) oe0 @- ff (3) holds by A-Hyp. Hence, (Q, ff \Pi  oe0, Q0) oe @- ff
holds by A-Equiv, R-Trans, (2), and (3).

ffi Case I-Hyp: similar.

Property v: We have (Q) oe @- oe0 (1) and (Q, ff = oe, Q0) oe1 "" oe2.

ffi Case A-Hyp: We have oe2 = fi. If fi is not ff, we get the result by A-Hyp.
Otherwise, oe1 is oe. By Property 1.7.2.iii (page 60), (Q, ff = oe0, Q0) oe @- oe0 (2) holds
from (1). Hence, (Q, ff = oe0, Q0) oe @- ff holds by R-Trans, (2), and A-Hyp.

ffi Case I-Hyp: We have oe2 = fi. We cannot have fi = ff, since the binding of ff is
rigid. Thus, we get the result by I-Hyp.

Property vi: We have (Q) oe v oe0 (1) and (Q, ff >= oe, Q0) oe1 "" oe2.

ffi Case A-Hyp: We have oe2 = fi. We cannot have fi = ff, since the binding of ff is
flexible. Thus, we get the result by A-Hyp.

ffi Case I-Hyp: We have oe2 = fi. If fi is not ff, we get the result by I-Hyp. Otherwise,
oe1 is oe. By Property 1.7.2.iii (page 60) and (1), (Q, ff>=oe0, Q0) oe v oe0 (2) holds. Hence,
(Q, ff >= oe0, Q0) oe v ff holds by R-Trans, (2), and I-Hyp.

Property vii: We have (Q, ff >= oe, Q0) oe1 "" oe2.

ffi Case A-Hyp: We have oe2 = fi. We cannot have fi = ff, since the binding of ff is
flexible. Thus, we get the result by A-Hyp.

ffi Case I-Hyp: We have oe2 = fi. If fi is not ff, we get the result by I-Hyp. Otherwise,
oe1 is oe. By A-Hyp, we can derive (Q, ff = oe, Q0) oe1 @- ff. Then by I-Abstract, we
get (Q, ff = oe, Q0) oe1 v ff. This is the expected result.

277

278 Preuves (de'tails techniques)
Proof of Lemma 3.6.4
If "" is j, then we get the result by Lemma 3.4.3. Otherwise, "" is @- or v. The
proof is by induction on the derivation of Q1 ""I Q2. Cases PE-Trans, PA-Trans,
PI-Trans, PA-Equiv, PI-Abstract are by induction hypothesis. Case PE-Refl is
immediate. Other cases are:

ffi Case PE-Free: If Q1 is (Q2, ff\Pi oe), we get the result by Property 3.6.3.i (page 114).
If Q2 is (Q1, ff \Pi  oe), we get the result by Property 1.7.2.iii (page 60).

ffi Case PE-Mono: Direct consequence of Property 3.6.3.ii (page 114).
ffi Case PE-Context-L: Direct consequence of Property 3.6.3.iv (page 114).
ffi Case PE-Swap: Direct consequence of Property 3.6.3.iii (page 114).
ffi Case PE-Comm: Direct consequence of Property 1.7.2.ii (page 60).
ffi Case PA-Context-L: Direct consequence of Property 3.6.3.v (page 114).
ffi Case PI-Context-L: Direct consequence of Property 3.6.3.vi (page 114).
ffi Case PI-Rigid: Direct consequence of Property 3.6.3.vii (page 114).

Proof of Lemma 3.6.6
We have the hypotheses

(Q) oe1 v oe2 (1) (Q) oe2 v oe3 (2) (Q) oe1 @- oe3 (3)
We consider two cases:

ffi Case bQ(nf(oe3)) /2 V: Then we have bQ(nf(oe2)) /2 V by Lemmas 2.1.6, (2), and 1.5.9.
We have 8 (Q) oe1/ 6/ 8 (Q) oe2/ 6/ 8 (Q) oe3/ by Property 2.1.3.ii (page 66), (1),
and (2). We have 8 (Q) oe1/ = 8 (Q) oe3/ by Property 2.1.3.i (page 66) and (3). Hence,
by antisymmetry (Property 2.1.2.i (page 65)), we get 8 (Q) oe1/ = 8 (Q) oe2/ = 8 (Q)
oe3/. We have w(oe1) ? w(oe2) ? w(oe3) by Property 2.7.6.i (page 93), (1), and (2). We
have X /2 w(oe1) - w(oe3) by Lemma 2.7.8 and (3), thus we get X /2 w(oe1) - w(oe2) and
X /2 w(oe2) - w(oe3) by Property 2.7.2.iv (page 87). Hence, by Lemma 2.7.8 and (1),
we get (Q) oe1 @- oe2. Similarly, by Lemma 2.7.8 and (2), we get (Q) oe2 @- oe3.

ffi Case bQ(nf(oe3)) = ff (4): Note that necessarily bQ(ff) = ff (5) holds, because bQ is
idempotent. We consider two subcases.

Subcase oe2 2 V: Then (Q) oe2 j oe3 (6) holds by Lemma 2.1.6, thus (Q) oe1 @-
oe2 holds by A-Equiv, R-Trans, (6) and (3). Besides, (Q) oe2 @- oe3 holds by A-Equiv
and (6).

Subcase nf(oe2) /2 #: Then we have oe2 /2 V (7). If we have oe1 2 V, then
by (1), (2), and Lemma 2.1.6, we get (Q) oe1 j oe2 and (Q) oe2 j oe3, which leads
to the expected result by A-Equiv. Now, we assume oe1 /2 V (8). From (2), we
get (Q) oe2 v bQ(nf(oe3)) by Eq-Mono, Property 1.5.6.i (page 53), and I-Equiv?.

278

279
Hence, we have (Q) oe2 v ff (9) from (4). Let (ff \Pi  oe) be the binding of ff in Q (10).
We get by Corollary 2.3.4, (10), (7), and (9) (Q) oe2 v oe (11). From (4), we have
(Q) oe3 j ff (12) by Eq-Mono and Property 1.5.6.i. Hence, by (3) and R-Trans, we
get (Q) oe1 @- ff (13). By Corollary 2.3.4, (10), (8), and (13), we get (Q) oe1 @- oe (14)
and \Pi  is rigid, that is, (ff=oe) 2 Q (15). We have bQ(nf(oe)) /2 V (16) by (15) and (5). In
summary, we have shown (Q) oe1 v oe2 from (1), (Q) oe2 v oe from (11), and (Q) oe1 @- oe
from (14). Hence, thanks to (16), we fall back in the first case. As a consequence, we
have (Q) oe1 @- oe2 (17) and (Q) oe2 @- oe (18).

By A-Hyp and (15), we get (Q) oe @- ff (19). By R-Trans, (18), and (19), we get
(Q) oe2 @- ff (20). By R-Trans, (20) and (12), we get (Q) oe2 @- oe3. With (17), this is
the expected result.

Proof of Lemma 3.6.7
By hypothesis, we have (Q) 8 (ff) oe @- oe0, where Q is unconstrained and binds the free
variables of 8 (ff) oe and oe0. By Property 2.6.2.i (page 84), there exists a derivation of

(Q) 8 (ff) oe (j .@-;)

* oe0. More precisely, there exist oe

1, . . . oen, such that oe1 = 8 (ff) oe,

oen = oe0, and (Q) oei (j .@-;) oei+1 for i 2 [1..n[. We prove the following property (where
Q is unconstrained):

If we have oea j 8 (ff) oe0a and (Q) oea (j .@-;) oeb, then there exists oe0b such
that oeb j 8 (ff) oe0b and (Q, ff) oe0a @- oe0b.

Proof: By hypothesis, we have oea j 8 (ff) oe0a (1) and (Q) oea (j .@-;) oeb. By
definition, either oea j oeb (the result is immediate, then), or there exist oec and oed such
that we have

oea j oec (2) (Q) oec .@-_ff oed (3) oed j oeb (4).
Hence, we have oec j 8 (ff) oe0a (5) by R-Trans, (1) and (2). We can choose ff such that
ff /2 ftv(oeb). If ff /2 ftv(oe0a), then oec j oe0a, thus taking oe0b = oeb is appropriate. Hence,
we assume that ff 2 ftv(oe0a) (6). By Property 2.6.3.i (page 85) on (3), there exists
oe0d such that (Q) nf(oec) .@-_ff oe0d (7) and oe0d j oed (8). By Property 1.5.11.i (page 56)
on (5), nf(oec) is a rearrangement of nf(8 (ff) oe0a). By Property 2.6.3.ii (page 85) applied
to (7), there exists oe00d such that we have (Q) nf(8 (ff) oe0a) .@-_ff oe00d (9) and oe00d j
oe0d (10). By R-Trans, (10), (8), and (4), we get oe00d j oeb (11). If oe0a j ff, then
nf(8 (ff) oe0a) is ?. This is a contradiction with (9) since no rule can be used to derive
(Q) ? .@-_ff oe00d (note that the prefix is unconstrained). Hence, oe0a is not equivalent to ff.
From (6), we get nf(8 (ff) oe0a) = 8 (ff) nf(oe0a). Hence, (Q) 8 (ff) nf(oe0a) .@-_ff oe00d (12) holds
from (9). Moreover, (12) is derived by StSh-Up or StSh-Alias (indeed, the prefix is
unconstrained). Hence, 8 (ff) nf(oe0a) is of the form Cr(oe0) and oe00d is of the form Cr(oe00).

279

280 Preuves (de'tails techniques)
Necessarily, Cr is 8 (ff) C0r and C0r(oe0) = nf(oe0a) (13). The premises of StSh-Up or
StSh-Alias are independent of Cr and Q. Hence, (Q, ff) C0r(oe0) .@-_ff C0r(oe00) (14) holds
too. Let oe0b be C0r(oe00). Then oe00d is 8 (ff) oe0b (15) and (14) gives (Q, ff) C 0r(oe0) .@-_ff oe0b.
By Property 2.6.2.i (page 84), we get (Q, ff) C0r(oe0) @- oe0b (16). From (16), (13),
and Property 1.5.6.i (page 53), we get (Q, ff) oe0a @- oe0b. From (11) and (15), we get
oeb j 8 (ff) oe0b. This is the expected result. \Lambda 

The lemma is then proved by induction on i.

Proof of Lemma 3.6.8
By induction on the size of Q. By hypothesis, Q is of the form (Q1, ff \Pi  oea, Q2). If
oea/u is defined and is ?, then we get the expected result by taking fi = ff, u1 = ffl,
and u2 = u. Otherwise, there exist v1 and v2 such that u = v1v2 and oea/v1 = fi (1)
with fi 2 dom(Q1). Then 8 (Q1) fi/v2 = ?. By induction hypothesis, Q1 is of the
form (Q11, fl \Pi  oec, Q12), v2 is of the form w1w2 such that 8 (Q12) fi/w1 = fl (2) and
oec/w2 = ? (3). Then Q is of the form (Q11, fl \Pi  oec, Q12, ff \Pi  oea, Q2), u is of the form
v1w1w2 such that

8 (Q12, ff \Pi  oea, Q2) ff/v1w1 = 8 (Q12) oea/v1w1

= 8 (Q12) fi/w1 from (1)
= fl from (2)

Additionally, oec/w2 = ? holds from (3). This is the expected result.

Proof of Lemma 3.6.9
By hypothesis, we have

oe2 2 \Sigma I (1) oe2 /2 V (2) (Q) oe1 v oe2 (3) Q vI Q0 (4) (Q0) oe1 @- oe2 (5)
We first show that 8 (Q) oe1/ = 8 (Q) oe2/ holds. By Property 2.1.3.ii (page 66) applied
to (3), we have 8 (Q) oe1 6/ 8 (Q) oe2 (6). By Definition 3.2.1 (page 103), (4), and (1),
we get 8 (Q) oe2 v 8 (Q0) oe2 (7). By Property 2.1.3.ii (page 66) applied to (7), we
get 8 (Q) oe2 6/ 8 (Q0) oe2 (8). By Property 2.1.3.i (page 66) applied to (5), we get
8 (Q0) oe1/ = 8 (Q0) oe2/(9). Let u be an occurrence in dom(8 (Q) oe1) such that
(8 (Q) oe1)/u 6= (8 (Q) oe2)/u. By definition of 6/ and (6), we have (8 (Q) oe1)/u = ?
and (8 (Q) oe2)/u = g (10), where g is not ?. Can u be in dom(oe1)? We would have
oe1/u = ?, thus 8 (Q0) oe1/u = ? (11). However, we have 8 (Q0) oe2/u = g by (10)
and (8). This is a contradiction with (11) and (9). Consequently, u is not in dom(oe1),
which means that it is of the form u1u2 (12) with oe1/u1 = ff (13) and 8 (Q) ff/u2 = ?.
By Lemma 3.6.8 (page 115), Q is of the form (Q1, fi \Pi  oeb, Q2) (14) and u2 is of the form

280

281
v1v2 (15) such that 8 (Q2) ff/v1 = fi (16) and oeb/v2 = ? (17). Note that oeb is not
in T by Property 2.1.5.i (page 67). We have (8 (Q2) oe1/u1v1) = fi by (13) and (16).
Thus, by Lemma 2.1.4 applied to (3), we get (8 (Q2) oe2)/u1v1 = fi (18). Hence,
(8 (Q) oe2)/u = ? holds from (12), (15), (18), (14), and (17). This is a contradiction
with (10). In summary, we have shown by way of contradiction that 8 (Q) oe1/ = 8 (Q)
oe2/ (19) holds. By Lemma 2.7.8, (2), and (5), we get X /2 w(oe1) - w(oe2) (20). By
Lemma 2.7.8, (2), (3), (19), and (20), we get (Q) oe1 @- oe2.

Proof of Lemma 3.6.10
By hypothesis, Q1 vI Q2 holds. By Lemma 3.6.1 (page 113), there exists a renaming
OE on dom(Q2) and a substitution `0 invariant on I such that J = dom(Q1/I) and
Q1 vJ OE(Q2)`0 (1) hold. We have (Q1) rI j cQ1(rI ) by Eq-Mono. By Lemma 3.6.4
and (1), we get (OE(Q2)`0) rI j cQ1(rI ). By Property 1.5.11.vii (page 56), we have

"OE(Q2) ffi `0(rI ) = "OE(Q2) ffi `0 ffi cQ1(rI ) (2). Let `0 be "OE(Q2) ffi `0. Since `0 is invariant

on I, (2) gives "OE(Q2)(rI ) = `0 ffi cQ1(I) (3). By Property 3.1.1.iii (page 102), we have

"OE(Q2) = OE ffi cQ2 ffi OE~. Hence, (3) becomes OE ffi cQ2 ffi OE~(rI ) = `0 ffi cQ1(I) (4). Since OE

is a renaming disjoint from I, we have OE~(rI ) = rI . Hence (4) gives OE ffi cQ2(rI ) =
`0 ffi cQ1(I). Applying OE~, we get cQ2(rI ) = OE~ ffi `0 ffi cQ1(rI ). Let ` be OE~ ffi `0. We getc
Q2(rI ) = ` ffi cQ1(rI ), which implies that cQ2 and ` ffi cQ1 are equal on I.

Proof of Lemma 3.6.11
First, notice that we can show the lemma for any alpha-conversion of 8 (Q2) o/21 ! o/22
(indeed, 8 (Q2) o/21 and 8 (Q2) o/22 can always be alpha-converted accordingly). Hence,
we can freely assume 8 (Q2) o/21 ! o/22 to be suitable for Lemma 3.4.4, thus we get a
substitution ` such that

(Q2) `(o/11 ! o/12) j o/21 ! o/22 (1) I = dom(Q1/o/11 ! o/12) dom(`) ` I

Q1 ""dom(Q)[I Q2` (2)
By Property 1.5.11.viii applied to (1), we get (Q2) `(o/11) j o/21 (3) and (Q2) `(o/12) j
o/22. By (2) and Definition 3.2.1, we have 8 (Q1) o/11 "" 8 (Q2`) o/11. By (3), this gives
8 (Q1) o/11 "" 8 (Q2) o/21. We show similarly that 8 (Q1) o/12 "" 8 (Q2) o/22 holds. This is
the expected result.

Proof of Lemma 3.6.12
We prove the first statement. By hypothesis Q v Q1Q2 (1), dom(Q) = dom(Q/I) (2),
I ` dom(Q1) (3), and dom(Q1) # dom(Q2) (4) by well-formedness of Q1Q2. Thus

281

282 Preuves (de'tails techniques)
I # dom(Q2) (5) holds from (3) and (4). Let ff0 be in dom(Q2/ dom(Q)) (6). By Property 3.3.2.i (page 104), we have dom(Q2/ dom(Q)) = Sff2dom(Q) dom(Q2/ff). Hence,
from (6), there exists ff 2 dom(Q) (7) such that we have ff0 2 dom(Q2/ff) (8). Hence,
ff is in dom(Q) " dom(Q2). Therefore, Q is of the form (Qa, ff \Pi 1 oe1, Qb) (9) and
Q2 of the form (Qa2, ff \Pi 2 oe2, Qb2) (10). Additionally, from (8), Qa2 is of the form
(Qc2, ff0 \Pi 3 oe3, Qd2) (11) and ff0 2 ftv(8 (Qd2) oe2) (12). By we have ff 2 dom(Q/I)
from (2) and (7). By (9), this means that ff 2 ftv(8 (Qb) rI ) (13). We have the
following:

(Q) 8 (Qb) rI v rI by I-Drop? and (9)
(Q1Q2) 8 (Qb) rI v rI by Lemma 3.6.4 and (1)
(Q1Qa2, ff \Pi 2 oe2, Qb2) 8 (Qb) rI v rI by (10)
(Q1Qa2, ff \Pi 2 oe2) 8 (Qb2Qb) rI v 8 (Qb2) rI by R-Context-R
(Q1Qa2, ff \Pi 2 oe2) 8 (Qb2Qb) rI v rI by (5) and Eq-Free

Since we have ff 2 dom(Q2) and (5), we have ff /2 I, that is, ff /2 ftv(rI ). Hence, by
R-Context-R and Eq-Free, we get

(Q1Qa2) 8 (ff \Pi 2 oe2) 8 (Qb2Qb) rI v rI
(Q1Qc2, ff0 \Pi 3 oe3, Qd2) 8 (ff \Pi 2 oe2) 8 (Qb2Qb) rI v rI by (11)

We get (Q1Qc2, ff0 \Pi 3 oe3) 8 (Qd2) 8 (ff \Pi 2 oe2) 8 (Qb2Qb) rI v 8 (Qd2) rI by R-ContextR. By (5) and Eq-Free, we get (Q1Qc2, ff0 \Pi 3 oe3) 8 (Qd2) 8 (ff \Pi 2 oe2) 8 (Qb2Qb) rI v
rI (14). By (13), we have ff 2 ftv(8 (Qb2Qb) rI). Hence, by (12), ff0 2 ftv(8 (Qd2) 8 (ff\Pi 2
oe2) 8 (Qb2Qb) rI ) (15). Moreover, ff0 /2 I by (6) and (5). Hence, ff0 /2 ftv(rI ) (16).
By Lemma 2.1.4 (page 67) on (14), (15), and (16), we get oe3 2 T , which implies
ff0 2 dom( cQ2). This result holds for any ff0 in dom(Q2/ dom(Q)), hence we have
dom(Q2/ dom(Q)) ` dom( cQ2).

We prove the second statement. Let ff be in dom(Q) (1). We have to show that
ftv( cQ2(ff)) ` dom(Q1). It suffices to show that ftv( cQ2(ff)) # dom(Q2) holds. By a way
of contradiction, assume that fi 2 ftv( cQ2(ff)) (2) and fi 2 dom(Q2). Then Q2 is of the
form (Qa, fi \Pi  oe, Qb). By definition of cQ2 (which is idempotent) and (2), we must have
fi /2 dom( cQ2) (3). From (2), we have fi 2 ftv( cQb(ff)). Hence, fi 2 ftv(8 (Qb) cQb(ff))
(since fi /2 dom(Qb)). This gives fi 2 ftv(8 (Qb) ff) (4) by Property 1.5.11.vi (page 56)
and by observing that 8 (Qb) ff j 8 (Qb) cQb(ff) holds by Eq-Mono. Therefore,
from (4), we have fi 2 dom(Q2/ff), which implies fi 2 dom(Q2/ dom(Q)) from (1).
The first property ensures that fi 2 dom( cQ2), which is a contradiction with (3). We
have shown a contradiction, thus the hypothesis fi 2 ftv( cQ2(ff)) and fi 2 dom(Q2) was
wrong. As a consequence, we have cQ2(dom(Q)) ` dom(Q1).

282

283
Proof of Lemma 3.6.13
By hypothesis, Q1 vI[J Q2Q3 holds. By Lemma 3.6.1 (page 113), there exists a
renaming OE on dom(Q2Q3) and a substitution ` both invariant on I [ J such that
Q1 vK OE(Q2Q3)` holds, and K = dom(Q1/I [ J ) (1). Since ftv(o/ ) ` I [ J , we
have `(o/ ) = o/ (2). Let Q02 be OE(Q2) and Q03 be OE(Q3). We have Q1 vK Q02Q03` (3).
Additionally, (Qa, Qb) is Q1"I, thus by Lemma 3.5.2, we have I ` dom(Qa) (4),
dom(Qa/I) = dom(Qa) (5), and QaQb ss Q1 (6). Hence, (3) becomes QaQb vK
Q02Q03` (7). From (1) and Property 3.3.2.i (page 104), we have dom(Q1/I) ` K (8).
From (5), (4), and (6), we get dom(Q1/I) = dom(Qa/I) = dom(Qa) (9). By (9) and (8),
we have dom(Qa) ` K (10). By Property 3.4.2.i (page 106), PE-Free, (7) and (10)
we get Qa v Q02Q03` (11). Hence, we get (Qa, fl >= 8 (Qb) o/ ) v (Q02Q03`, fl >= 8 (Qb) o/ ) by

Property 3.4.2.iii (page 106). Let `0 be cQ03 ffi `. By Eq-Mono?, we get (Qa, fl >= 8 (Qb)
o/ ) v (Q02Q03`, fl >= `0(8 (Qb) o/ )) (12). We also have

(QaQb) 8 (Qb) o/ v o/ by I-Drop?
(Q02Q03`) 8 (Qb) o/ v o/ by Lemma 3.6.4 and (7)
(Q02) 8 (Q03) `(8 (Qb) o/ ) v 8 (Q03) `(o/ ) by R-Context-R
(Q02) 8 (Q03) `0(8 (Qb) o/ ) v 8 (Q03) `0(o/ ) by Eq-Mono?

Hence, (Q02) 8 (Q03) `0(8 (Qb) o/ ) v 8 (Q03) `0(o/ ) (13) holds. We have I ` dom(Q2)
by hypothesis, and OE disjoint from I, thus I ` dom(Q02) (14). By Lemma 3.6.12
(page 116) applied to (11), (14) and (5), we get dom(Q03`/ dom(Qa)) ` dom(`0) and
`0(dom(Qa)) ` dom(Q02) (15). Consider the instantiation (13). The free variables of
8 (Qb) o/ are in dom(Qa) (since QaQb ss Q1). Hence, the free variables of `0(8 (Qb) o/ ) are
in `0(dom(Qa)). By (15), they are in dom(Q02). In particular, they are not in dom(Q03)
(since Q02 # Q03 holds by well-formedness of (3)). Hence, 8 (Q03) `0(8 (Qb) o/ ) j `0(8 (Qb)
o/ ) holds by Eq-Free. Consequently, (13) gives

(Q02) `0(8 (Qb) o/ ) v 8 (Q03) `0(o/ ) (16)
Additionally, we have

(Qa, fl >= 8 (Qb) o/ ) v (Q02, fl >= `0(8 (Qb) o/ ), Q03`) by PE-Comm on (12).
(Qa, fl >= 8 (Qb) o/ ) v (Q02, fl >= 8 (Q03) `0(o/ ), Q03`) by PI-Context-L

and (16).
(Qa, fl >= 8 (Qb) o/ ) v (Q02, fl >= 8 (Q03) `(o/ ), Q03`) by Eq-Mono?.
(Qa, fl >= 8 (Qb) o/ ) v (Q02, fl >= 8 (Q03) o/, Q03`) by (2).
(Qa, fl >= 8 (Qb) o/ ) v (OE(Q2), fl >= 8 (OE(Q3)) o/, Q03`) by definition.
(Qa, fl >= 8 (Qb) o/ ) v (OE(Q2), fl >= OE(8 (Q3) o/ ), Q03`) by alpha-renaming.
(Qa, fl >= 8 (Qb) o/ ) v (OE(Q2, fl >= 8 (Q3) o/ ), Q03`)

283

284 Preuves (de'tails techniques)
Then (Qa, fl >=8 (Qb) o/ ) vI[{fl} (OE(Q2, fl >=8 (Q3) o/ )) (17) holds by PE-Free and Property 3.4.2.i (page 106). By Property 3.4.2.iv (page 106), we have (Q2, fl >= 8 (Q3) o/ ) j
(OE(Q2, fl >= 8 (Q3) o/ )OE), thus (Q2, fl >= 8 (Q3) o/ ) jI[{fl} (OE(Q2, fl >= 8 (Q3) o/ )) holds by

PE-Free and Property 3.4.2.i (page 106). With (17), we get (Qa, fl >= 8 (Qb) o/ ) vI[{fl}
(Q2, fl >= 8 (Q3) o/ ). This is the expected result.

Proof of Lemma 4.2.4
By Lemma 3.6.1 (page 113), there exists a renaming OE on dom(Q2) and a substitution `
invariant on I such that Q1 vJ OE(Q2)` (1) holds, and J is dom(Q1/I). Let (Q3, Q4) be
Q1" ftv(oe0). By Lemma 3.5.2, we have Q3Q4 ss Q1 (2) and ftv(oe0) # dom(Q4) (3). Then
Q4 is (Q5, ff \Pi  oe, Q6) and Q1 is a rearrangement of (Q3Q5, ff \Pi  oe, Q6) by (2). From (3),
we have ftv(oe0) # dom(Q6) (4). Let Qa be Q3Q5 and Qb be Q6 (5). Then Q1 is a
rearrangement of (Qa, ff \Pi  oe, Qb) (6). By hypothesis, if \Pi  is =, then (Q1) oe @- oe0 holds.
This implies that (Q1) oe @-? oe0 returns true, by Lemma 4.2.2. Hence, Q1 ( (ff \Pi 0 oe0) is
well-defined (that is, it does not fail on the fourth step). We write it Q01.

By definition, Q01 is (Qa, ff \Pi 0 oe0, Qb) (7) and dom(Qb) # ftv(oe0) holds from (4)
and (5).

We have the following:

(Qa, ff \Pi  oe, Qb) 8 (Qb) rI v rI by I-Drop?.

(Q1) 8 (Qb) rI v rI by (6)

and Property 1.7.2.ii
(OE(Q2)`) 8 (Qb) rI v rI by Lemma 3.6.4 on (1).

8 (OE(Q2)`Qb) rI v 8 (OE(Q2)`) rI by R-Context-R
8 (OE(Q2)`Qb) rI v 8 (OE(Q2)) rI since dom(`) # I.
8 (OE(Q2)`Qb) rI v 8 (Q2) rI by alpha-conversion

Hence, 8 (OE(Q2)`Qb) rI v 8 (Q2) rI (8) holds. By hypothesis, we have (Q2) oe0 v
ff (9) and (Q2) oe0 @- ff (10) when \Pi 0 is rigid. We have Q2 jI OE(Q2)OE by Property 3.4.2.iv (page 106). We get Q2 jI OE(Q2)` (11) by PE-Free (twice). Hence, we
have (OE(Q2)`) oe0 v ff (12) (and possibly (OE(Q2)`) oe0 @- ff (13)) by Lemma 3.6.4, (9),
possibly (10), and (11). Then we have the following (we abbreviated R-ContextFlexible and R-Context-Rigid into RC-Flexible and RC-Rigid, respectively):

(Qa, ff \Pi  oe, Qb) 8 (Q01) rI v 8 (ff \Pi 0 oe0, Qb) rI by I-Drop? and (7)

(Q1) 8 (Q01) rI v 8 (ff \Pi 0 oe0, Qb) rI by (6)
(OE(Q2)`) 8 (Q01) rI v 8 (ff \Pi 0 oe0, Qb) rI by Lemma 3.6.4 and (1)
(OE(Q2)`) 8 (Q01) rI v 8 (ff \Pi 0 ff, Qb) rI by RC-Flexible and (12)

or RC-Rigid and (13)
(OE(Q2)`) 8 (Q01) rI v 8 (Qb) rI by Eq-Mono?

8 (Q01) rI v 8 (OE(Q2)`Qb) rI by R-Context-R

284

285
The left-hand side 8 (Q01) rI is closed, thus 8 (OE(Q2)`) 8 (Q01) rI and 8 (Q01) rI
are equivalent by Eq-Free. This is why we get the last line by Eq-Free. Finally,
combining with (8), we get 8 (Q01) rI v 8 (Q2) rI , thus Property 3.4.5.i (page 109)
gives the expected result.

Proof of Lemma 4.2.5
By hypothesis, we have (Q) oe v oe0 (1). Let (Q1, Q2) be Q" ftv(oe0). By Lemma 3.5.2,
we have Q1Q2 ss Q. By hypothesis, we have Q2 of the form (Qa2, ff \Pi  oe, Qb2). If \Pi  is =,
then (Q) oe @-? oe0 returns true, thus we have (Q) oe @- oe0 (2) by Lemma 4.2.2 and (1).
Finally, the algorithm returns Q0 = (Q1Qa2, ff \Pi  oe0, Qb2). The prefix (Q1Qa2, ff \Pi  oe, Qb2)
is a rearrangement of Q. Besides, (Q1Qa2, ff \Pi  oe, Qb2) v Q0 holds by PA-Context-L
and (2) or PI-Context-L and (1). Hence, Q v Q0 holds, which is the expected result.

Proof of Lemma 4.2.7
By hypothesis, Q is of the form (Q0, ff \Pi  oe, Q1, ff0 \Pi 0 oe, Q2), or (Q0, ff0 \Pi 0 oe, Q1, ff \Pi  oe, Q2).
By well-formedness of Q, we must have ftv(oe) # dom(Q1). Hence, by Eq-Comm,
we get Q j (Q0, ff \Pi  oe, ff0 \Pi 0 oe, Q1Q2) (1). If \Pi  and \Pi 0 are flexible, then \Pi 00 is >= and
Q v (Q0, ff \Pi 00 oe, ff0 \Pi 00 oe, Q1Q2) (2) holds from (1) by PE-Refl. Otherwise, \Pi 00 is =
and (2) holds from (1) and by Rule PI-Rigid (if necessary). Finally, Q v (Q0, ff \Pi 00
oe, ff0 = ff, Q1Q2) (3) holds from (2), by PI-Trans, PI-Context-L on the binding
(ff0 >= oe), and I-Hyp when \Pi 00 is flexible, or PA-Context-L on the binding (ff0 = oe)
and A-Hyp when \Pi 00 is rigid. Hence, Q v Q0 holds from (3). Additionally, (Q0) ff j ff0
holds by Eq-Mono.

Proof of Lemma 4.2.8
Merging is only a particular case of Updating. More precisely, let \Pi 00 be >= if both \Pi 
and \Pi 0 are >=, and = otherwise. Let Qa be Q1 ( (ff \Pi 00 oe), let Qb be Qa ( (ff \Pi 00 oe),
and Qc be Qb ( (ff0 = ff). We show that Qa, Qb, and Qc are well-defined (that is, the
updates do not fail) and that Qc is a rearrangement of Q ( ff ^ ff0. By hypothesis
and without loss of generality Q1 is of the form (Q4, ff \Pi  oe, Q5, ff0 \Pi 0 oe, Q6) (1). By
well-formedness, we have ff0 /2 dom(Q1/oe), thus ff0 /2 dom(Qb/ff). This implies that
Qb ( (ff0 = ff) can be applied. Let (P1, P2) be Q1" ftv(oe). By Lemma 3.5.2, we have
P1P2 ss Q1 and dom(P1) = dom(Q1/oe) (2). Besides, by well-formedness of (1), we must
have ftv(oe) ` dom(Q4) (3). More precisely, we must have dom(Q1/oe) ` dom(Q4) (4).
Hence dom(P1) ` dom(Q4) (5) holds from (4) and (2). By Lemma 4.2.2, (Q) oe @-? oe
holds. Hence, the algorithm does not fail on its fourth step. Finally, it returns Qa,
which is a rearrangement of (Q4, ff\Pi 00 oe, Q5, ff0 \Pi 0 oe, Q6). Similarly, Qb is a rearrangement

285

286 Preuves (de'tails techniques)
of (Q4, ff \Pi 00 oe, Q5, ff0 \Pi 00 oe, Q6) (6). Since ftv(oe) ` dom(Q4) (from (3)), Qb is also a
rearrangement of (Q4, ff\Pi 00 oe, ff0\Pi 00oe, Q5Q6). Then observing that (Qb) oe @- ff holds when
\Pi 00 is rigid, we see that Qb ( (ff0 = ff) is well-defined, that is, Qc is well-defined, and is a
rearrangement of (Q4, ff \Pi 00 oe, ff0 = ff, Q4Q6), that is, a rearrangement of Q ( ff ^ ff0 (7).
By Lemma 3.6.1 (page 113), there exists a renaming OE on dom(Q2) and a substitution
` invariant on I such that Q1 vJ OE(Q2)` (8) holds, and J is dom(Q1/I). Hence,
ftv(oe) [ {ff} ` J (9) holds from the hypothesis ff, ff0 2 I. We have (Q1) oe v ff by
I-Hyp, thus (OE(Q2)`) oe v ff holds by Lemma 3.6.4 and (8). We have (Q2) ff j ff0
by hypothesis, and Q2 jI OE(Q2)` (10) is derivable by Property 3.4.2.iv (page 106)
and PE-Free (observing that OE and ` are invariant on I), thus (OE(Q2)`) ff j ff0 (11)
holds. Besides, if \Pi 00 is =, then either \Pi  or \Pi 0 is =. In the first case, we have (Q1) oe @- ff
by A-Hyp. In the second case, we have (Q1) oe @- ff0 by A-Hyp. Then (OE(Q2)`) oe @- ff
or (OE(Q2)`) oe @- ff0 (12) holds by Lemma 3.6.4 and (8). By (12) and (11), we get
(OE(Q2)`) oe @- ff (13). Note that (Q1) oe @- oe (14) and (Q1) oe v oe (15) hold
by Eq-Refl, A-Equiv, and I-Equiv?. By Lemma 4.2.4 (page 123), (8), (1), (14),
(15), (9), and (13) we have Qa vJ OE(Q2)`. Similarly, Qb vJ OE(Q2)` is derivable. By
Property 3.4.2.i (page 106) and (10), we get Qb vI Q2 (16). From (6), (Qb) oe v ff0 (17)
holds by I-Hyp when \Pi 00 is flexible, and (Qb) oe @- ff0 (18) holds by A-Hyp when \Pi 00 is
rigid. By well-formedness of Qb, we have ff0 /2 dom(Qb/ff) (19). We have by hypothesis
ff, ff0 2 I (20) and (Q2) ff j ff0 (21). By Lemma 4.2.4 (page 123), (16), (6), (17), (18),
(19), (20), (21), we get Qc vI Q2. Hence, (Q1 ( ff ^ ff0) vI Q2 holds from (7).

Proof of Property 4.3.1
We prove both properties simultaneously, by induction on the recursive calls to unify
and polyunify.

Proof of Property 4.3.2
By induction on the recursive calls to unify. All cases are easy.

Proof of Lemma 4.5.1
We prove the result for unify0 and polyunify0 simultaneously, by induction on the
recursive calls. We get the result for polyunify0 by induction hypothesis and Property 4.3.2.i (page 126). As for unify0, we proceed by case analysis on (o/1, o/2). Cases
(ff, ff) and (g1 . . . , g2 . . .) with g1 6= g2 are immediate (unify and unify0 return the
same result). Cases (g o/ 11 . . . , g o/ 12 . . .) and (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q and oe 2 V
are by induction hypothesis (unify and unify0 are identical).

286

287
ffi Case (ff, o/ ) or (o/, ff) with (ff \Pi  o/ 0) 2 Q: In this case, unify simply returns unify
(Q, o/, o/ 0), while unify0 is more elaborate. We have to consider the two following subcases:

Subcase ff 2 dom(Q/o/ ) (1): By Property 1.5.11.vii (page 56), we have bQ(o/ ) =b
Q(ff) (2) if and only if (Q) o/ j ff holds. If (2) does not hold, then unify0 fails. We
have to show that unify fails too. By a way of contradiction, assume unify succeeds
with a prefix Q0. Then by soundness (Lemma 4.4.1), we would have Q v Q0 (3) and
(Q0) ff j o/ (4). From (1), Q is of the form (Qa, ff \Pi  oe, Qb) and ff 2 ftv(8 (Qb) o/ ) (5).
Hence, we can derive (Q) 8 (Qb) o/ v o/ (6) by I-Drop?. By Lemma 3.6.4, (6), and (3),
we get (Q0) 8 (Qb) o/ v o/ . From (4), we get (Q0) 8 (Qb) o/ v ff (7) By Property 2.1.7.ii
(page 68), (7), and (5), we get 8 (Qb) o/ j ff. Hence, (6) gives (Q) ff v o/ . By
Lemma 2.1.6, it leads to (Q) ff j o/ . This is a contradiction with the hypothesis
that (2) does not hold. Hence, unify cannot succeed, and this is the expected result.

Otherwise, (2) holds, and unify0 returns Q. From (2), we have (Q) ff j o/ (8). We
have to show that unify returns a rearrangement of Q. From (1), Q is of the form
(Qa, ff \Pi  oe, Qb) and ff 2 ftv(8 (Qb) o/ ) (9). Hence, we can derive (Q) 8 (Qb) o/ v o/ by
I-Drop?. From (8), we get (Q) 8 (Qb) o/ v ff (10) By Property 2.1.7.ii (page 68), (10),
and (9), we get 8 (Qb) o/ j ff (11). This implies that either o/ is ff, or it is a variable
fi such that fi 2 dom(Qb). In the first case, unify (Q, o/, ff) returns Q, which is the
expected result. In the second case, Qb is of the form (Q1b , fi \Pi b oeb, Q2b ). From (11)
and Eq-Var, we get 8 (Q1b ) oeb j ff. This implies oeb 2 V, that is, oeb j fl such that
fl 2 dom(Q1b ).

Subcase ff /2 dom(Q/o/ ):

ffi Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q (12): Both algorithms fail in the first
step, or both continue. Let I be {fi 2 dom(Q) | fi 6= ff and ff /2 dom(Q/fi)} and
(Q1, Q2) be Q"I. The algorithm unify0 calls polyunify0 (Q1, oe, o/ ) while unify calls
polyunify (Q, oe, o/ ). By Lemma 3.5.2, Q1Q2 is a rearrangement of Q, I ` dom(Q1)
and dom(Q1/I) = dom(Q1). We have ff /2 dom(Q/oe) by well-formedness of Q and (12),
hence ftv(oe) ` I. We have ff /2 dom(Q/o/ ) (otherwise both algorithms fail in the first
step), hence ftv(o/ ) ` I. Thus, we have ftv(o/ ) [ ftv(oe) ` dom(Q1). By Property 4.3.2.ii
(page 126) and induction hypothesis, polyunify0 (Q1, oe, o/ ) returns Q01 if and only if
polyunify (Q, oe, o/ ) returns Q0, a rearrangement of Q01Q2. Then Q01Q2 ( (ff = o/ ) is a
rearrangement of Q0 ( (ff = o/ ) by Lemma 4.2.3 (page 123). This is the expected result.

ffi Case (ff1, ff2): Both algorithms fail if ff1 2 dom(Q/oe2) or ff2 2 dom(Q/oe1). Let
I be {fi 2 dom(Q) | fi /2 {ff1, ff2} and {ff1, ff2} # dom(Q/fi)}. Let (Q1, Q2) be
Q"I. The algorithm unify0 calls polyunify0 (Q1, oe1, oe2), while unify calls polyunify
(Q, oe1, oe2). By Lemma 3.5.2 and by definition of I, Q1Q2 is a rearrangement of Q,
and we have ftv(oe1) [ ftv(oe2) ` dom(Q1). Hence, by Property 4.3.2.i (page 126) and
induction hypothesis, polyunify0 (Q1, oe1, oe2) returns (Q01, oe03) if and only if polyunify
(Q, oe1, oe2) returns (Q0, oe3) such that Q0 is a rearrangement of Q01Q2 and oe3 is a rear287

288 Preuves (de'tails techniques)
rangement of oe03. Hence, Q01Q2 ( (ff1 \Pi 1 oe03) ( (ff2 \Pi 2 oe03) ( ff1 ^ ff2 is a rearrangement
of Q0 ( (ff1 \Pi 1 oe3) ( (ff2 \Pi 2 oe3) ( ff1 ^ ff2. This is the expected result.

Proof of Property 4.5.3
Properties i, ii, and iii are immediate.

We show Properties iv and v simultaneously, by induction on the recursive calls to
unify0 and polyunify0. For unify0, we proceed by case on (o/1, o/2):

ffi Case (ff, ff): We return Q and we have dQe 6 dQe.
ffi Case (g o/ 11 .. o/ n1 , g o/ 12 .. o/ n2 ): by induction hypothesis.
ffi Case (g1 o/ 11 .. o/ p1 , g2 o/ 12 .. o/ q2 ) with g1 6= g2: is not possible since, by hypothesis, we
succeed.

ffi Case (ff, o/ ) or (o/, ff) with (ff \Pi  oe) 2 Q and oe 2 V: By induction hypothesis.
ffi Case (ff, o/ ) or (o/, ff): We have (Q1, Q2) = Q"I. By Lemmas 3.5.2 and ii, we get
dQe = dQ1e + dQ2e (1). Note that (ff \Pi  oe) 2 Q2. We have (Q01, oe0) = polyunify0
(Q1, oe, o/ ). By induction hypothesis, dQ01e + doe0e 6 dQ1e + doee + do/ e, that is, dQ01e +
doe0e 6 dQ1e + doee. Hence, we have dQ01e 6 dQ1e + doee (2). Let Q0 be Q01Q2 (
(ff = o/ ). We note that dQ0e = dQ01e + dQ2e - doee + do/ e. Hence, by (2), we get
dQ0e 6 dQ1e + doee + dQ2e - doee, that is, dQ0e 6 dQ1e + dQ2e. By (1), this gives
dQ0e 6 dQe.

ffi Case (ff1, ff2): Similarly, dQe = dQ1e + dQ2e and by induction hypothesis, dQ01e +
doe3e 6 dQ1e + doe1e + doe2e (3). Let Q0 be Q01Q2 ( (ff1 \Pi 1 oe3) ( (ff2 \Pi 2 oe3) ( ff1 ^ ff2.
We note that dQ0e = dQ01e + dQ2e - doe1e - doe2e + doe3e. Hence, dQ0e 6 dQ1e + dQ2e
holds from (3), that is, dQ0e 6 dQe. This is the expected result.

For polyunify, we have oe1 = 8 (Q1) o/1 and oe2 = 8 (Q2) o/2. We compute Q0 =
unify (QQ1Q2, o/1, o/2) and (Q3, Q0) = Q0" dom(Q). By Lemma 3.5.2, Q3Q0 ss Q0.
Hence, by Property ii, we get dQ0e = dQ3e + dQ0e (1). We have oe3 = 8 (Q0) o/1, thus
doe3e = dQ0e (2) by Property i. By induction hypothesis, we have dQ0e 6 dQQ1Q2e (3).
By (3), (1), (2), we get dQ3e + doe3e 6 dQQ1Q2e. By Properties ii and i, we get
dQ3e + doe3e 6 dQe + doe1e + doe2e. This is the expected result.

Proof of Lemma 4.6.1
In the cases (?, oe), or (oe, ?), polyunify returns oe, which is oe1 or oe2, thus it is not in
V by hypothesis. In the last case, it returns 8 (Q4) o/1, where the constructed form of
oe1 is 8 (Q1) o/1. Since oe1 is not in V, we must have o/1 /2 #, thus 8 (Q4) o/1 /2 V.

288

289
Proof of Corollary 4.6.3
By hypothesis, Q1 vI Q2 (1) holds. By Lemma 3.6.2 (page 114) on (1), there exists
a renaming OE disjoint from I and a prefix Q0 such that we have Q1 v OE(Q2)Q0 and
OE(Q2)Q0 jI Q2 (2). By Lemma 4.6.2, unify (Q1, o/1, o/2) succeeds with Q01 and we
have Q01 vdom(Q1) OE(Q2)Q0. By Property 3.4.2.i (page 106) and (2), we get Q01 vI Q2.
This is the expected result.

Proof of Lemma 6.1.4
This property is shown by induction on the the derivation of (Q) \Gamma  ` a : oe. Case Var
is immediate. Cases App, Inst and Oracle are by induction hypothesis.

ffi Case Fun: The premise is (Q) \Gamma , x : o/0 ` a0 : o/ and oe is o/0 ! o/ . By alphaconversion of the lambda-bound variable x, we can freely assume that x is not bound in
\Gamma 0. Hence, by induction hypothesis, we have (Q) \Gamma , x : o/0, \Gamma 0 ` a0 : o/ , which is identified
with (Q) \Gamma , \Gamma 0, x : o/0 ` a0 : o/ . Hence, by Rule Fun, we get (Q) \Gamma , \Gamma 0 ` *(x) a0 : o/0 ! o/ ,
which is the expected result.

ffi Case Let: We have (Q) \Gamma  ` a1 : oe1 and (Q) \Gamma , x : oe1 ` a2 : oe. By induction
hypothesis, we have (Q) \Gamma , \Gamma 0 ` a1 : oe1 and (Q) \Gamma , x : oe1, \Gamma 0 ` a2 : oe, which can be
written (Q) \Gamma , \Gamma 0, x : oe1 ` a2 : oe. Hence, by Rule Let, we get the expected result.

ffi Case Gen: The premise is (Q, ff \Pi oea) \Gamma  ` a : oe0 (1), and oe is 8 (ff \Pi oea) oe0. Besides,
ff /2 ftv(\Gamma ). Let ff0 be a fresh variable (that is, not in ftv(\Gamma , \Gamma 0)). By Lemma 6.1.1 applied
to (1) with the renaming [ff0/ff], we get (Q, ff0 \Pi  oea) \Gamma  ` a : oe0[ff0/ff], and this derivation
has the same size as (1). Hence, by induction hypothesis, we have a derivation of
(Q, ff0\Pi oea) \Gamma , \Gamma 0 ` a : oe0[ff0/ff]. Applying Gen, we get (Q) \Gamma , \Gamma 0 ` a : 8 (ff0\Pi oea) oe0[ff0/ff],
that is (by alpha-conversion) (Q) \Gamma , \Gamma 0 ` a : oe, which is the expected result.

Proof of Lemma 6.2.1
It suffices to show that each rule defining `

O is derivable in `.

ffi Case Var

O: This rule is identical to Rule Var.

ffi Case Fun

O: We choose ff fresh, that is ff /2 dom(QQ0)[ftv(\Gamma , o/0, oe). By hypothesis,

(QQ0) \Gamma , x : o/0 ` a : oe holds, and dom(Q0) # ftv(\Gamma ). By Corollary 6.1.3 (page 153), we
get (QQ0, ff >= oe) \Gamma , x : o/0 ` a : oe. Hence, the following derivation:

(QQ0, ff >= oe) \Gamma , x : o/0 ` a : oe (QQ0, ff >= oe) oe v ff I-Hyp

(QQ0, ff >= oe) \Gamma , x : o/0 ` a : ff
(QQ0, ff >= oe) \Gamma  ` *(x) a : o/0 ! ff
(Q) \Gamma  ` *(x) a : 8 (Q0, ff >= oe) o/0 ! ff Gen

Fun

Inst

289

290 Preuves (de'tails techniques)

ffi Case App

O: We have already shown that App? is derivable. Then AppO can be

derived with Inst and App?.

ffi Case Let

O We choose ff fresh, and Q2 is an abbreviation for (Q, ff >= oe2). By

hypothesis, we have (Q) \Gamma  ` a1 : oe1 and (Q) \Gamma , x : oe1 ` a2 : oe2. By Corollary 6.1.3
(page 153), we get (Q2) \Gamma  ` a1 : oe1 and (Q2) \Gamma , x : oe1 ` a2 : oe2. Then we have the
following derivation:

(Q2) \Gamma  ` a1 : oe1

(Q2) \Gamma , x : oe1 ` a2 : oe2

(Q2) oe2 v ff

(Q2) \Gamma , x : oe1 ` a2 : ff Inst
(Q2) \Gamma  ` let x = a1 in a2 : ff

(Q) \Gamma  ` let x = a1 in a2 : oe2 Gen+Inst

Let

ffi Case Oracle

O is a combination of Oracle and Inst.

Proof of Lemma 6.2.3
By induction on the derivation of (Q) \Gamma  `0 a : oe. Cases App

O, FunO, LetO, Inst and

Oracle

O are by induction hypothesis.

ffi Case Var

O: We have (Q) \Gamma  `0 z : oe and z : oe is in \Gamma . By definition, z : oe0 is in \Gamma 0,

with (Q) oe0 v oe. Hence, we have (Rule Var

O) (Q) \Gamma 0 `0 z : oe0 and we get the expected

result (Q) \Gamma 0 `0 z : oe by Rule Inst.

ffi Case Gen: The premises are (Q, ff \Pi  oea) \Gamma  `0 a : oe0 (1) and ff /2 ftv(\Gamma ). The
conclusion is (Q) \Gamma  `0 a : 8 (ff \Pi  oea) oe0. We have (Q) \Gamma 0 v \Gamma . By well-formedness, all
free type variables of \Gamma 0 must be bound in Q. Since ff /2 dom(Q), we have ff /2 ftv(\Gamma 0).
The result is by induction hypothesis on (1) and Rule Gen, then.

Proof of Property 6.2.5
Property i: By hypothesis, we have a derivation ending with Gen. Its premise is
(Q, ff \Pi  oe) \Gamma  `0 a : oe0 (1) and its conclusion is (Q) \Gamma  `0 a : 8 (ff \Pi  oe) oe0 (2). Besides,
ff /2 ftv(\Gamma ) (3). We have to show that there exists a derivation of (Q) \Gamma  `0 a : oe00 (4),
with oe00 j 8 (ff \Pi  oe) oe0 (5), and the size of (4) must be strictly smaller than the size
of (2), or, equivalently, the size of (4) is smaller than or equal to the size of (1). The
proof is by induction on the size of the term, then on the size of the derivation, and
then by case on the penultimate rule (the last rule being, by hypothesis, Rule Gen).

ffi Case Var

O: The premise of this penultimate rule is x : oe0 2 \Gamma  (6), and its

conclusion is (1), with a being x. We have ff /2 ftv(oe0) by (3) and (6). Thus 8 (ff \Pi  oe)
oe0 j oe0 (7) holds by Eq-Free. We have (Q) \Gamma  `0 x : oe0 (8) by Var

O, that is (4),

290

291
taking oe00 = oe0. As expected (5) holds by (7). Besides, the size of (8) is one, which is
equal to the size of (1).

ffi Case Fun

O: The premise is (Q, ff \Pi  oe, Q0) \Gamma , x : o/0 `0 a0 : oe0 (9) and dom(Q0) #

ftv(\Gamma ) (10). Besides, oe0 is 8 (Q0, fi >= oe0) o/0 ! fi (11). Hence, (1) is written (Q, ff \Pi  oe)
\Gamma  `0 *(x) a0 : 8 (Q0, fi >= oe0) o/0 ! fi. By (3) and (10), we have dom(ff \Pi  oe, Q0) # ftv(\Gamma ).
Hence, by Rule Fun

O applied to (9), we get (Q) \Gamma  `0 *(x) a0 : 8 (ff \Pi  oe, Q0, fi >= oe0)

o/0 ! fi (12). Taking oe00 = 8 (ff \Pi  oe, Q0, fi >= oe0) o/0 ! fi, we have shown (4) and (5),
using (11). Additionally, the size of (12) is the size of (1).

ffi Case App

O: The premises are (Q, ff \Pi  oe) \Gamma  `0 a1 : oe1 (13) and (Q, ff \Pi  oe) \Gamma  `0

a2 : oe2 (14). Moreover, we have (Q, ff \Pi  oe) oe1 v 8 (Q0) o/2 ! o/1 (15) and (Q, ff \Pi  oe)
oe2 v 8 (Q0) o/2 (16). Besides, oe0 is 8 (Q0) o/1. By (3), (13) and Rule Gen, we get
(Q) \Gamma  `0 a1 : 8 (ff \Pi  oe) oe1 (17). Besides, the size of (17) is the size of (13) plus one. By
induction hypothesis, (Q) \Gamma  `0 a1 : oe01 (18) is derivable with oe01 j 8 (ff \Pi  oe) oe1 (19).
Moreover, the size of (18) is strictly smaller than the size of (17), that is, smaller
than or equal to the size of (13). Similarly, (Q) \Gamma  `0 a2 : oe02 (20) is derivable with
oe02 j 8 (ff \Pi  oe) oe2 (21), and the size of (20) is smaller than or equal to the size
of (14). By (19), (15) and R-Context-R we get (Q) oe01 v 8 (ff \Pi  oe, Q0) o/2 ! o/1 (22).
Similarly, (21) and (16) give (Q) oe02 v 8 (ff\Pi oe, Q0) o/2 (23). By (18), (20), (22), and (23),
and Rule App

O, we get (Q) \Gamma  `0 a1 a2 : 8 (ff \Pi  oe, Q0) o/1 (24). This corresponds to (4).

Additionally, the size of (24) is one plus the size of (18) and the size of (20). Hence, it
is smaller than or equal to one plus the size of (13) plus the size of (14), that is, the
size of (1).

ffi Case Inst: The premises are (Q, ff\Pi oe) \Gamma  `0 a : oe0 (25). and (Q, ff\Pi oe) oe0 v oe0 (26).
By Rule Gen, (Q) \Gamma  `0 a : 8 (ff \Pi  oe) oe0 holds. By induction hypothesis, (Q) \Gamma  `0 a :
oe00 (27) holds, with oe00 j 8 (ff \Pi  oe) oe0 (28), and the size of (27) is smaller than or equal
to the size of (25). From (26), R-Context-R, and (28), we get (Q) oe00 v 8 (ff \Pi  oe) oe0.
Hence, with (27) and Inst, this gives (Q) \Gamma  `0 a : 8 (ff \Pi  oe) oe0 (29). Besides, the size
of (29) is smaller than or equal to one plus the size of (25). Hence, it is smaller than
or equal to the size of (1).

ffi Case Oracle

O is similar.

ffi Case Gen: The premise is (Q, ff \Pi  oe, ff1 \Pi 1 oe1) \Gamma  `0 a : oe0 (30), and oe0 is 8 (ff1 \Pi 1 oe1)
oe0. By induction hypothesis, we have a derivation of (Q, ff \Pi  oe) \Gamma  `0 a : oe00 (31) which
is smaller than or equal to the size of (30) and with oe00 j oe0 (32). By Rule Gen,
we get (Q) \Gamma  `0 a : 8 (ff \Pi  oe) oe00. By induction hypothesis, we have a derivation of
(Q) \Gamma  `0 a : oe00 (33), where oe00 j 8 (ff \Pi  oe) oe00 (34), and the size of (33) is smaller than
or equal to the size of (31). We note that oe00 j 8 (ff \Pi  oe) oe0 by (32) and (34). Besides,
the size of (33) is smaller than or equal to the size of (30). Thus, it is strictly smaller
than the size of (1).

ffi Case Let

O: The premises are (Q, ff \Pi  oe) \Gamma  `0 a1 : oe1 (35) as well as (Q, ff \Pi  oe) \Gamma , x :

oe1 `0 a2 : oe0 (36). By Gen and (35), we get (Q) \Gamma  `0 a1 : 8 (ff \Pi  oe) oe1. By induction

291

292 Preuves (de'tails techniques)
hypothesis, we have a derivation of (Q) \Gamma  `0 a1 : oe01 (37), with oe01 j 8 (ff \Pi  oe) oe1 (38).
Besides, the size of (37) is smaller than or equal to the size of (35). We note that
(Q, ff \Pi  oe) 8 (ff \Pi  oe) oe1 v oe1 (39) is derivable by I-Drop?. From (39) and (38), we get
(Q, ff \Pi  oe) oe01 v oe1 (40). By Strengthen', (36), and (40), we get (Q, ff \Pi  oe) \Gamma , x : oe01 `0
a2 : oe0 (41). Note that we have ff /2 ftv(oe) by well formedness of the prefix of (35).
Hence, we have ff /2 ftv(8 (ff\Pi oe) oe1), which implies ff /2 ftv(oe01) (42) by Property 1.5.4.iii
(page 51) and (38). By Rule Gen, (42) and (41), we get (Q) \Gamma , x : oe01 `0 a2 : 8 (ff \Pi  oe)
oe0 (43). By Rule Let

O, (37) and (43), we get (Q) \Gamma  `0 a : 8 (ff \Pi  oe) oe0 (44). The size

of (44) is one plus the size of (37) (remember that the right premise of Let

O is not

counted). Hence, the size of (44) is smaller than or equal to one plus the size of (35).
Consequently, the size of (44) is smaller than or equal to the size of (1).

Property ii: By induction on the size of the term, then on the size of the derivation.
Case Var

O is immediate. Cases FunO, AppO, Inst, and OracleO are by induction

hypothesis.

ffi Case Let

O: The premises are (Q) \Gamma  `0 a1 : oe1 and (Q) \Gamma , x : oe1 `0 a2 : oe2 (1). By

induction hypothesis, (Q) \Gamma  `0 a1 : oe01 (2) is derivable not using Gen, with oe01 j oe1.
By Strengthen' and (1), we get (Q) \Gamma , x : oe01 `0 a2 : oe2. By induction hypothesis (a2
is a subexpression of a), we have a derivation of (Q) \Gamma , x : oe01 `0 a2 : oe02 (3) not using
Gen and oe02 j oe2. By Let

O, (2), and (3), we have a derivation of (Q) \Gamma  `0 a : oe02 not

using Gen, and oe02 j oe2. This is the expected result.

ffi Case Gen: By Property i, there exists a strictly smaller derivation not ending with
Gen of (Q) \Gamma  `0 a : oe00a with oe00a j oea (4). Hence, by induction hypothesis, we have
a derivation not using Gen of (Q) \Gamma  `0 a : oe0a with oe0a j oe00a (5). By R-Trans, (5),
and (4), we have oe0a j oea, which is the expected result.

Property iii: By induction on the size of the term and on the derivation.

ffi Case Var

O is immediate.

ffi Case Inst: The premises are (Q) \Gamma  `0 a : oe (1) and (Q) oe v oea (2). We get the
expected result by induction hypothesis on (1) and (2).

ffi Case Gen: By hypothesis, this case cannot occur.
ffi Case Fun

O: The premise is (QQ0) \Gamma , x : o/0 `O a : oe and dom(Q0) " ftv(\Gamma ) = ;. By

induction hypothesis, we have a derivation of (QQ0) \Gamma , x : o/0 `

O a : oe0 (not using Inst)

such that (QQ0) oe0 v oe (3). By Rule Fun

O, we have (Q) \Gamma  `O *(x) a : 8 (Q0, ff >= oe0)

o/0 ! ff, and we easily check that (Q) 8 (Q0, ff >= oe0) o/0 ! ff v 8 (Q0, ff >= oe) o/0 ! ff
holds by rules R-Context-R, R-Context-Flexible, and (3).

ffi Case Oracle

O and AppO: These rules already contains an occurrence of Inst by

construction. Thus, the we get the result by induction hypothesis.

ffi Case Let

O The premises are (Q) \Gamma  `0 a1 : oe1 and (Q) \Gamma , x : oe1 `0 a2 : oe2.

By induction hypothesis, we have a derivation of (Q) \Gamma  `

O a1 : oe0

1 (4) such that

292

293
(Q) oe01 v oe1 holds. Hence, by Rule Strengthen, we have (Q) \Gamma , x : oe01 `0 a2 : oe2 (5).
Note that a2 is a subterm of a, thus the induction hypothesis can be applied to (5).
Hence, by induction hypothesis, we have a derivation of (Q) \Gamma , x : oe01 `

O a2 : oe0

2 with(Q) oe0

2 v oe2 (6). We conclude with Rule Let

O, (4), and (6).

Proof of Property 8.1.5
Property i: It is shown by structural induction on oe.

Property ii: We prove the first rule by induction on the size of Q. If Q is ;, hh;ii is ;, id,
and hhoeii = 8 (;) id(hhoeii) holds. Otherwise, Q is (ff \Pi  oe0, Q0). Let 8 (Q1) o/1 be hhoe0ii
and Q01, `1 be hhQ0ii. By induction hypothesis, hh8 (Q0) oeii = 8 (Q01) `1(hhoeii). Hence,
by Definition 8.1.4, hh8 (Q) oeii is 8 (Q1Q01) `1(hhoeii)[o/1/ff] (1). By definition, hhQii is
Q1Q01, [o/1/ff] ffi `1. Hence, (1) is the expected result.

The second rule is proved by induction on the size of Q1. If Q1 is ;, the result is
immediate. Otherwise, Q1 is (ff \Pi  oe, Q01). Let Q001, `01 be hhQ01ii. By induction hypothesis,
hhQ01Q2ii is Q001Q02, `01 ffi`2. Let 8 (Q) o/ be hhoeii. By definition, hhQ1Q2ii is QQ001Q02, [o/ /ff]ffi
`01 ffi `2. We get the expected result by observing that hhQ1ii is QQ001, [o/ /ff] ffi `01.

Property iii: It is shown by structural induction on oe.
Property iv: By hypothesis, we have oe j o/ . By Property 1.5.4.i (page 51), we have
oe/ = o/ /. By Property iii, we have oe/ = hhoeii/. Hence, hhoeii/ = o/ /. Moreover, hhoeii is
necessarily of the form 8 ( _ff) o/ 0. For any u in dom(hhoeii), we have hhoeii/u = o/ /u, hence
hhoeii/u 6= ?, that is, 8 ( _ff) o/ 0/u 6= ? for any u in dom(8 ( _ff) o/ 0). Hence, we must have

_ff # ftv(o/ 0). Consequently, 8 ( _ff) o/ 0/ = o/ 0/, thus o/ 0/ = o/ /. This implies o/ = o/ 0. We
have shown that hhoeii is 8 (_ff) o/ with _ff # ftv(o/ ).

Property v: It is shown by induction on the size of Q. If Q is ;, the result is immediate.
Otherwise, Q is (Q0, ff \Pi  oe). Let 8 (Q1) o/1 be hhoeii, and Q01, `1 be hhQ0ii. By induction

hypothesis, `1 is of the form `01 ffi cQ0. By definition, ` is [o/1/ff]ffi `1, that is [o/1/ff] ffi `01 ffi cQ0.
If oe /2 T , then bQ = cQ0, and ` is [o/1/ff] ffi `01 ffi bQ. This is the expected result. Otherwise,
oe j o/ , and o/1 is o/ by Property iv. Moreover, bQ is [o/ /ff] ffi cQ0. Then ` is [o/ /ff] ffi `01 ffi cQ0.
Consequently, ` is equivalent to [o/ /ff] ffi `01 ffi [o/ /ff] ffi cQ0, that is, [o/ /ff] ffi `01 ffi bQ. This is
the expected result.

Property vi: It is by induction on the derivation of (Q) oe1 v oe2. Cases R-Trans,
A-Hyp, . . . and I-Rigid are not possible since the derivation is flexible.

ffi Case Eq-Refl: immediate.
ffi Case R-Trans: By induction.

293

294 Preuves (de'tails techniques)

ffi Case R-Trans: By induction.
ffi Case Eq-Free: This case corresponds to adding or removing useless binders in an
ML type scheme.

ffi Case Eq-Comm: This case corresponds to commuting binders in an ML type
scheme.

ffi Case Eq-Var: hh8 (ff >= oe) ffii and hhoeii are identical.
ffi Case R-Context-R: Let Qa be (Q, ff >= oe0). Let 8 (Q0) o/0 be hhoe0ii. Let Q0, ` be
hhQii, and let `0 be [o/0/ff]. The premise is (Qa) oe01 v oe02, and we have oe1 = 8 (ff>=oe0) oe01,
as well as oe2 = 8 (ff>=oe0) oe02. We have hhQaii = Q0Q0, ` ffi`0 by Property ii. By induction
hypothesis, we have ` ffi `0(hhoe01ii) vML ` ffi `0(hhoe02ii) (1). Hence, we have

`(hh8 (ff >= oe0) oe1ii) = `(8 (Q0) `0(hhoe1ii) by definition

= 8 (Q0) ` ffi `0(hhoe1ii)
vML 8 (Q0) ` ffi `0(hhoe2ii) by (1)
= `(8 (Q0) `0(hhoe2ii))
= `(hh8 (ff >= oe0) oe2ii) by definition

This is the expected result.

ffi Case R-Context-L: See R-Context-Flexible
ffi Case R-Context-Flexible: The premise is 8 (Q) oe01 v oe02, and the conclusion is
8 (Q) 8 (ff>=oe01) oe v 8 (ff>=oe02) oe. Let Q0` be hhQii. Let 8 (Q1) o/1 be hhoe01ii and 8 (Q2) o/2
be hhoe02ii. Let `1 be [o/1/ff] and `2 be [o/2/ff]. We have hh8 (ff >= oe01) oeii = 8 (Q1) `1(hhoeii)
and hh8 (ff >= oe02) oeii = 8 (Q2) `2(hhoeii). By induction hypothesis, we have `(hhoe01ii) vML
`(hhoe02ii), that is, 8 (Q1) `(o/1) vML 8 (Q2) `(o/2). By Lemma 8.1.1 (page 171), we get
8 (Q1) ` ffi `1(hhoeii) vML 8 (Q2) ` ffi `2(hhoeii), which is the expected result.

ffi Case Eq-Mono: The premises are (ff \Pi  oe0) 2 Q and (Q) oe0 j o/0. The conclusion
is (Q) o/ j o/ [o/0/ff]. We have bQ(ff) = bQ(o/0) by definition. Let Q0, ` be hhQii. We have
`(ff) = `(o/0) by Property v. Hence, we have `(o/ ) = `(o/ [o/0/ff]). This is the expected
result.

ffi Case I-Hyp: We have (ff1 >= oe1) 2 Q and the conclusion is (Q) oe1 v ff1. Let
8 (Q1) o/1 be hhoe1ii and Q0, ` be hhQii. By definition, `(ff1) = `(o/1). Besides, `(8 (Q1) o/1)
is 8 (Q1) `(o/1) since Q1 is unconstrained, and 8 (Q1) `(o/1) vML `(o/1) holds, that is,
8 (Q1) `(o/1) vML `(ff1). Thus we have the expected result `(8 (Q1) o/1) vML `(ff1).

ffi Case I-Bot: 8 (ff) ff vML oe holds for any ML type oe.

This proves the property.

294

295
Proof of Lemma 8.3.2
Let us name the conclusions (1) through (4) in order of appearance:

(Q0) \Gamma  ` a : 8 (Q0) oe01 (1) Q0Q v Q0Q0 (2) (Q0Q0) oe01 A- oe (3)

(Q0) 8 (Q0) oe v oe0 (4)
We write Q00 for (Q, ff1 = oe, ff0 = oe). By Lemma 6.2.6, it suffices to show the result for
(Q0) \Gamma  `

O (a : 9 (Q) oe) : 8 (Q1) o/0 (5) with (Q0) 8 (Q1) o/0 v oe0 (6). The premises

of (5) are necessarily

(Q0) \Gamma  `

O a : oe1 (7) (Q0) oe1 v 8 (Q1) o/1 (8)

(Q0) 8 (Q00) ff1 ! ff0 v 8 (Q1) o/1 ! o/0 (9)
ffi Soundness Assume (1), (2), (3), and (4). Take (Q0, ff1 = oe01, ff0 = oe) for Q1, ff1
for o/1, and ff0 for o/0. By Lemma 6.2.6 and (1), there exists oe1 such that (7) holds and
(Q0) oe1 v 8 (Q0) oe01 (10) holds. By Eq-Var?, we have (Q0) 8 (Q1) o/1 j 8 (Q0) oe01.
Hence, (10) gives (Q0) oe1 v 8 (Q1) o/1 (8). We have (Q0Q) 8 (Q00) ff1 ! ff0 v 8 (ff1 = oe)
8 (ff0 = oe) ff1 ! ff0 (11) by I-Drop?. By (2) and Lemma 3.6.4 applied to (11), we get
(Q0Q0) 8 (Q00) ff1 ! ff0 v 8 (ff1 = oe) 8 (ff0 = oe) ff1 ! ff0. Using I-Abstract with (3),
we get (Q0Q0) 8 (Q00) ff1 ! ff0 v 8 (ff1 = oe01) 8 (ff0 = oe) ff1 ! ff0. Hence, by RContext-R and Eq-Free, we get (Q0) 8 (Q00) ff1 ! ff0 v 8 (Q0) 8 (ff1 =oe01) 8 (ff0 =oe)
ff1 ! ff0, that is (Q0) 8 (Q00) ff1 ! ff0 v 8 (Q1) ff1 ! ff0 (9). The premises (7), (8), (9)
are checked, thus Rule App applies and gives (Q0) \Gamma  `

O (a : 9 (Q) oe) : 8 (Q1) o/0 (5).

Finally, (Q0) 8 (Q1) o/0 j 8 (Q0) oe holds by Eq-Var?, thus (Q0) 8 (Q1) o/0 v oe0 (6)
holds by (4).

ffi Completeness For simplicity, we assume that dom(Q/ ftv(oe)) = dom(Q) (12),
that is, Q contains only useful bindings. By hypothesis, (5) and (6) hold, thus we
have the premises (7), (8), and (9). By Rule Inst, (7) and (8), we have (Q0) \Gamma  `
a : 8 (Q1) o/1 (13). By Lemma 3.4.4 applied to (9), there exists a prefix P1 such that
8 (P1) o/ 01 ! o/ 00 is an alpha-conversion of 8 (Q1) o/1 ! o/0, and a substitution ` such that

(Q0P1) `(ff1 ! ff0) j o/ 01 ! o/ 00 (14) J = dom(Q00/ff1 ! ff0) (15) dom(`) ` J

Q0Q00 vdom(Q0)[J Q0P1` (16)
From (12) and (15), we get J = dom(Q00). Hence, (16) becomes Q0Q00 v Q0P1` (17).
By Property 3.4.2.i (page 106) and PE-Free, we get Q0Q v Q0P1`, that is (2) by
taking Q0 = P1`. By Property 1.5.11.viii (page 56) on (14), we get (Q0P1) `(ff1) j
o/ 01 (18) and (Q0P1) `(ff0) j o/ 00 (19). By alpha-conversion, (13) becomes (Q0) \Gamma  `
a : 8 (P1) o/ 01. From (18), and Inst, we get (Q0) \Gamma  ` a : 8 (P1) `(ff1), that is, (Q0)

295

296 Preuves (de'tails techniques)
\Gamma  ` a : 8 (Q0) ff1 (1) by taking oe01 = ff1. We have (Q0Q00) oe @- ff1 by A-Hyp.
Hence, by Lemma 3.6.4 on (17), we get (Q0Q0) oe @- ff1, that is, (3). Similarly, we
can derive (Q0Q0) oe @- ff0. Hence, (Q0) 8 (Q0) oe v 8 (Q0) ff0 (20) holds by RContext-R. We have (Q0) 8 (Q0) ff0 j 8 (P1) o/ 00 from (19). By alpha-conversion, we
have (Q0) 8 (Q0) ff0 j 8 (Q1) o/0 (21). By R-Trans on (20), (21), and (6) we get
(Q0) 8 (Q0) oe v oe0, that is, (4).

Proof of Corollary 8.3.3
Directly, we assume (Q0) \Gamma  ` (a : ?) : oe0 holds. By Lemma 6.2.6, (Q0) \Gamma  `

O (a :

?) : oe00 (1) holds with (Q0) oe00 v oe0 (2). The judgment (1) must be derived by Rule
Oracle. Thus there must exists oe1 and oe2 such that we have

(Q0) \Gamma  `

O a : oe1 (3) (Q0) oe1 v oe2 (4) (Q0) oe2 A- oe0

0 (5)

Let OE be a renaming of domain dom(Q0). Let Q be OE(Q0) and oe be OE(oe0). Let Q0 be
OE~. Let oe01 be OE(oe2) and oe be OE(oe00). By Rule Inst, (3) and (4), we get (Q0) \Gamma  ` a : oe2,
which gives by Eq-Mono? (Q0) \Gamma  ` a : 8 (Q0) oe01 (6). We have Q0Q v Q0Q0 (7)
by Property 3.4.2.v (page 106). From (5), we get (Q0Q0) OE(oe00) @- OE(oe2), that is,
(Q0Q0) oe @- oe01 (8). By (2), we have (Q0) 8 (Q0) oe v oe0 (9). Hence, by (6), (7), (8), (9),
and by Lemma 8.3.2 we have (Q0) \Gamma  ` (a : 9 (Q) oe) : oe0. This is the expected result.

Conversely, by Lemma 8.3.2, there exists Q0 and oe01 such that (Q0) \Gamma  ` a : 8 (Q0)
oe01 (10) holds as well as (Q0Q0) oe01 A- oe (11) and (Q0) 8 (Q0) oe v oe0 (12). By Rule
R-Context-R on (11), we get (Q0) 8 (Q0) oe01 A- 8 (Q0) oe (13). Hence, by (10), (13)
and Rule Oracle, we get (Q0) \Gamma  ` (a : ?) : 8 (Q0) oe. We get the expected result by
Rule Inst and (12).

Proof of Lemma 8.3.4
Hypothesis H0 is easily checked. Hypothesis H1 is a direct consequence of Corollary 8.3.3. Hypothesis H2: (v : 9 (Q) oe) always reduces.

Proof of Lemma 10.2.1
By Lemmas 2.5.5 and 2.5.6, we have a restricted derivation of (Q) oe1 @-_ff oe2 (1). We
show wY (oe2) 6Z wY (oe1) by induction on the derivation of (1). Case A-Equiv' is a
direct consequence of Lemma 2.7.5. Case R-Trans is by induction hypothesis.

ffi Case A-Context-L': We have oe1 = 8 (ff = oe01) oe, oe2 = 8 (ff = oe02) oe, and the
premise is (Q) oe01 @- oe02. By induction hypothesis, we have wY (oe02) 6Z wY (oe01) (2).
By Lemma 2.5.6, we have nf(oe) 6= ff, and ff 2 ftv(oe). Hence, by definition we have
wY (oe1) = Y * wY (oe01) + wY (oe) and wY (oe2) = Y * wY (oe02) + wY (oe). We conclude
by (2), then.

296

297
ffi Case R-Context-R: We have oe1 = 8 (ff \Pi  oe) oe01, oe2 = 8 (ff \Pi  oe) oe02, and the
premise is (Q, ff \Pi  oe) oe01 @-_ff[{ff} oe02 (3). By induction hypothesis, we have wY (oe02) 6Z
wY (oe01) (4). We consider a four subcases:

Subcase oe 2 T : Then wY (oe1) = wY (oe01) and wY (oe2) = wY (oe02). We conclude
by (4). In the following, we assume oe /2 T . By (3), and Lemmas 2.5.7 (page 82)
and 2.1.4 (page 67), we have ff 2 ftv(oe01) if and only if ff 2 ftv(oe02) (5).

Subcase nf(oe01) = ff: Then we have (Q, ff \Pi  oe) oe01 j oe02 by Lemma 2.1.6, which
implies (Q) oe1 j oe2. We conclude by Lemma 2.7.5.

Subcase ff /2 ftv(oe01): Then ff /2 ftv(oe02) by (5). Hence, we have wY (oe1) =
wY (oe01) and wY (oe2) = wY (oe02). We conclude by (4).

Subcase ff 2 ftv(oe01): Then ff 2 ftv(oe02) by (5). Either wY (oe2) is Y * wY (oe) +
wY (oe02) or it is wY (oe) if nf(oe02) = ff. In both cases, we see that wY (oe2) =Z wY (oe) +
wY (oe02). By (4), we have wY (oe2) 6Z wY (oe) + wY (oe01), that is, wY (oe2) 6Z wY (oe1).

ffi Case A-Hyp': We have oe2 = ff, with (ff = oe1) 2 Q. We simply note that wY (oe2)
is wY (ff), that is, 0.

ffi Case A-Alias': We check that wY (oe1) =Z wY (oe2).
ffi Case A-Up': We check that wY (oe1) =Z wY (oe2).

Proof of Property 10.3.3
Property i: Let S be an _ff-stable set. Let ` be a substitution invariant on _ff. By definition, we have `(S) ` S. This implies fsub (`(S)) ` fsub (S) (1). By Property 10.3.1.ii,
we have `(fsub (S)) ` fsub (`(S)) (2). By (2) and (1), we get `(fsub (S)) ` fsub (S).
This means that fsub (S) is _ff-stable.

Property ii: This is a direct consequence of Property i, by observing that {t} is ftv(t)-
stable.

Property iii: By hypothesis, S is _ff-stable (1) and _fi-stable (2). Let ` be a substitution
invariant on _ff " _fi (3). We show by induction on the size of dom(`) that `(S) ` S
holds. If dom(`) = ;, then result is immediate. Otherwise, ` can be decomposed into
[t/ff] ffi `0, such that the size of dom(`0) is the size of dom(`) minus one. We have to
show [t/ff] ffi `0(S) ` S. By induction hypothesis, we have `0(S) ` S. Hence, it suffices
to show that S[t/ff] ` S (4). If ff /2 _ff, the substitution [t/ff] is invariant on _ff, thus (4)
holds by (1). Otherwise, ff 2 _ff. By hypothesis (3), we must have ff /2 _ff " _fi. Hence,
we have ff /2 _fi. Then the substitution [t/ff] is invariant on _fi. Thus (4) holds by (2).
In both cases, we have shown (4). Hence, by induction, we have `(S) ` S. This holds
for any ` invariant on _ff " _fi, thus S is ( _ff " _fi)-stable.

Property iv: By hypothesis, S1 is _ff-stable (1) and S2 is _ff-stable (2). Let t1 be in S1. If
t1 2 \Sigma ~_fi , then t1 2 S1 "\Sigma ~_fi , thus t1 2 S2 "\Sigma ~_fi by hypothesis. Hence, t1 2 S2. Otherwise,

297

298 Preuves (de'tails techniques)
t1 /2 \Sigma ~_fi , which means that some free variables of t1 are in _fi. Let OE be a renaming of
domain _fi mapping _fi to fresh variables, that is, variables outside _ff [ _fi [ ftv(t1). Since
we have _fi # _ff by hypothesis, OE is invariant on _ff. Hence, OE(S1) ` S1 holds by (1).
This implies OE(t1) 2 S1. Besides, OE(t1) 2 \Sigma ~_fi . Hence, as shown above, OE(t1) 2 S2.

We note that OE~ is a renaming invariant on _ff [ _fi [ ftv(t1). Hence, OE~(S2) ` S2 holds
by (2). This implies OE~ ffi OE(t1) 2 S2, that is, t1 2 S2. As a conclusion, we have shown
S1 ` S2.

Property v: It is a direct consequence of Property iv.

Property vi: As a preliminary result, we show [

ff2I

\Sigma ~_ff[{ff} = \Sigma ~_ff (1). Indeed, we have

\Sigma ~_ff[{ff} ` \Sigma ~_ff for any ff. Hence, Sff2I \Sigma ~_ff[{ff} ` \Sigma ~_ff holds. Conversely, let t be in \Sigma ~_ff.
The set ftv(t) is finite and the set I is infinite. Hence, there exists ff 2 I such that
ff /2 ftv(t). Then we have t 2 \Sigma ~_ff[{ff}, that is, t 2 Sff2I \Sigma ~_ff[{ff}. As a conclusion, we

have shown (1).

We get back to the proof of the property. We have S1 " \Sigma ~_ff[{ff} ` S2 " \Sigma ~_ff[{ff} for

all ff in I. Hence, taking the union we get [

ff2I

S1 " \Sigma ~_ff[{ff} ` [

ff2I

S2 " \Sigma ~_ff[{ff}, that is,

S1 "  [

ff2I

\Sigma ~_ff[{ff}! ` S2 "  [

ff2I

\Sigma ~_ff[{ff}!. By (1), we get S1 " \Sigma ~_ff ` S2 " \Sigma ~_ff, which

means S1 `_ff S2.

Property vii: Direct consequence of Property vi.
Property viii: By hypothesis, we have S1 `_ff S2 (1). We have to show fsub (S1) `_ff
fsub (S2). Let t be in fsub (S1) " \Sigma ~_ff. By definition, we have ftv(t) # _ff, and there exists
t1 in S1 such that t1 vF t (2). Observing that ftv(t1) ` ftv(t), we have ftv(t1) # _ff.
Hence, t1 2 S1 " \Sigma ~_ff. From (1), we get t1 2 S2. Hence, from (2), we have t 2 fsub (S2).
This is the expected result.

Property ix: Direct consequence of Property viii.
Property x: If we have _ff # codom(`) and S1 =_ff S2, then `(S1) =_ff `(S2). Let t be in
`(S1) " \Sigma ~_ff. There exists t1 in S1 such that t = `(t1). Since _ff # ftv(t), we must have

_ff # ftv(t1). Hence, t1 is in S1 "\Sigma ~_ff, which implies t1 2 S2. Then `(t1) 2 `(S2). We have
shown `(S1) `_ff `(S2). By symmetry, we have `(S2) `_ff `(S1), thus `(S1) =_ff `(S2)
holds.

298

299
Proof of Property 10.3.6
Property i: In all cases ((oe)) is of the form fsub (S) for some set of types S, and we
simply note that fsub (fsub (S)) = fsub (S).

Property ii: By structural induction on oe.

ffi Case oe is o/ : Then ((oe)) is fsub (o/ ). Let t be in ((oe)). We have o/ vF t, which implies
that t is equivalent to o/ . Hence, ftv(t) = ftv(o/ ), and 8 ff * t is equivalent to t. As a
consequence, we have 8 ff * t 2 ((oe)), which is the expected result.

ffi Case oe is ?: Then ((oe)) is fsub (8 (ff) ff). We immediately have 8 ff * t 2 ((oe)) for
any t. Hence, 8 ff * ((oe)) ` ((oe)).

ffi Case oe is 8 (fi = oe1) oe2: We can freely assume fi 6= ff. By definition, ((oe))
is fsub \Gamma ((oe2))[oe1/fi]\Delta . Hence, 8 ff * ((oe)) is 8 ff * fsub \Gamma ((oe2))[oe1/fi]\Delta . Thus, by Property 10.3.1.iii, we have 8 ff * ((oe)) ` fsub \Gamma 8 ff * (((oe2))[oe1/fi])\Delta . By hypothesis, ff /2
ftv(oe) and oe is in normal form, hence ff /2 ftv(oe1). By Property 10.3.1.i, we get
ff /2 ftv(oe1), thus 8 ff* and the substitution [oe1/fi] commute, leading to 8 ff * ((oe)) `
fsub \Gamma (8 ff * ((oe2)))[oe1/fi]\Delta . By induction hypothesis, we have 8 ff * ((oe2)) ` ((oe2)). Hence,
8 ff * ((oe)) ` fsub \Gamma ((oe2))[oe1/fi]\Delta  holds, that is, 8 ff * ((oe)) ` ((oe)).

ffi Case oe is 8 (fi >= oe1) oe2: We can freely assume fi 6= ff. By definition, ((oe)) is

fsub 0@

_ff#ftv(oe1,oe2)[

t12((oe1))

8 _ff * ((oe2))[t1/fi]1A

Hence, we have

8 ff * ((oe)) = 8 ff * fsub iS_ff#

ftv(oe1,oe2)

t12((oe1)) 8 _ff * ((oe2))[t1/fi]j

` fsub iS_ff#

ftv(oe1,oe2)

t12((oe1)) 8 ff * 8 _ff * ((oe2))[t1/fi]j by Prop. 10.3.1.iii

By hypothesis, ff /2 ftv(oe) and oe is in normal form. We simply note that ff [ _ff #
ftv(oe1, oe2) holds for all _ff disjoint from ftv(oe1, oe2). Hence, we have

8 ff * ((oe)) ` fsub 0@

_ff#ftv(oe1,oe2)[

t12((oe1))

8 _ff * ((oe2))[t1/fi]1A

That is, 8 ff * ((oe)) ` ((oe)).
Property iii: Let ` be a substitution invariant on ftv(oe). Let _ff be its domain. By Property ii, we have 8 _ff * ((oe)) ` ((oe)). Hence, applying fsub (), we get fsub (8 _ff * ((oe))) `
fsub (((oe))). By Property i, this is fsub (8 _ff * ((oe))) ` ((oe)). We simply note that

299

300 Preuves (de'tails techniques)
`(((oe))) ` fsub (8 _ff * ((oe))). Hence, we have `(((oe))) ` ((oe)). This holds for all ` invariant on ftv(oe), thus ((oe)) is ftv(oe)-stable.

Property iv: Let t1 be in (fsub (t))[t0/ff]. By definition, there exists t01 such that
t vF t01 (1) and t1 is t01[t0/ff]. We note that t[t0/ff] vF t01[t0/ff] holds from (1),
that is, t[t0/ff] vF t1. Hence, t1 is in fsub (t[t0/ff]). We have shown (fsub (t))[t0/ff] `
fsub (t[t0/ff]) (2).

Conversely, let t1 be in fsub (t[t0/ff]) " \Sigma ~ff. This means that t[t0/ff] vF t1 (3) holds
and ff /2 ftv(t1) (4). If ff /2 ftv(t), we have t1 2 fsub (t), thus we have t1[t0/ff] 2
(fsub (t))[t0/ff], that is, by (4), t1 2 (fsub (t))[t0/ff] (5). From now on, we assume that
ff 2 ftv(t) (6). By hypothesis and alpha-conversion, t is of the form 8 _ff * t0, with
{ff} [ ftv(t0) # _ff (7), t0 6= ff, and t0 is not a quantified type. Hence, t[t0/ff] is equal
to 8 _ff * (t0[t0/ff]), and t0[t0/ff] is not a quantified type. From (3), t1 is of the form
8 _fi * (t0[t0/ff])[_t/ _ff] (8), for some types _t and _fi disjoint from ftv(t0[t0/ff]) (9). From (9)
and (6), we get _fi # ftv(t0) (10). By alpha-conversion, we can freely assume that
ff /2 _fi (11). Hence, we have _fi # ftv(t0) from (9) and (11). Therefore, 8 _ff * t0 vF
8 _fi * t0[_t/ _ff] holds (by definition of vF ). Let t2 be 8 _fi * t0[_t/ _ff]. We have shown t vF t2.
Additionally, ff /2 ftv(_t) (12) holds from (4) and (8). We note that t1 = t2[t0/ff] holds
from (8), (11), (7), (12), and (10). Hence, we have shown that t1 is in (fsub (t))[t0/ff].
In both cases, we have shown (5). This implies fsub (t[t0/ff]) " \Sigma ~ff ` (fsub (t))[t0/ff].
Thus, fsub (t[t0/ff]) `ff (fsub (t))[t0/ff] (13) holds.

From (2) and (13), we have fsub (t[t0/ff]) =ff (fsub (t))[t0/ff].

Property v: By Property 10.3.1.ii, we have `(fsub (t)) ` fsub (`(t)) (1). Conversely,
we show by induction on the size of dom(`) that fsub (`(t)) `dom(`) `(fsub (t)). If
dom(`) is empty, the result is immediate. Otherwise, we can write ` in the form
`0 ffi [t0/ff], with ff /2 dom(`0) and the size of dom(`0) is strictly smaller than the size
of dom(`). By hypothesis, the normal form of t is not in dom(`). Hence, the normal
form of t is not ff. By Property iv, we get fsub (t[t0/ff]) =ff (fsub (t))[t0/ff] (2). Let t1
be in fsub (`(t)) " \Sigma ~dom(`) (3). We have t1 2 fsub (`1(t[t0/ff])), and t1 2 \Sigma ~dom(`

1).By induction hypothesis, we get t

1 2 `1(fsub (t[t0/ff])). Hence, there exists t01 in
fsub (t[t0/ff]) such that t1 = `1(t01). We note that ff /2 ftv(t1) holds from (3). It implies

ff /2 ftv(t01). Hence, t01 is in fsub (t[t0/ff]) " \Sigma ~ff. By (2), we get t01 2 (fsub (t))[t0/ff].
Hence, t1 is in `1(fsub (t))[t0/ff], that is, t1 2 `(fsub (t)). In summary, we have shown
fsub (`(t)) `dom(`) `(fsub (t)). With (1), we get fsub (`(t)) =dom(`) `(fsub (t)).

Property vi: First, we note that if t1 vF t2 holds, then we have t1 6/ t2 (1). Then we
proceed by structural induction on oe.

ffi Case oe is o/ : Then ((oe)) is fsub (o/ ), thus t is equivalent to o/ , and o/ / = t/ holds.
Hence, we have o/ 6/ t.

300

301
ffi Case oe is ?: Then oe 6/ t always holds.
ffi Case oe is 8 (ff1 = oe1) oe2: Then ((oe)) is fsub \Gamma ((oe2))[oe1/ff]\Delta . Thanks to Remark (1)
above, it suffices to show the result for t in ((oe2))[oe1/ff]. Hence, we assume t of the
form t2[oe1/ff] for t2 2 ((oe2)). By induction hypothesis, we have oe2 6/ t2. Hence,
we have proj(oe2)[proj(oe1)/ff] 6/ t2[proj(oe1)/ff] by Property 2.1.2.ii. We note that
proj(oe2)[proj(oe1)/ff] is proj(oe), and that proj(oe1) = proj(oe1). Hence, we get proj(oe) 6/
t2[proj(oe1)/ff], that is, oe 6/ t, which is the expected result.

ffi Case oe is 8 (ff1 >= oe1) oe2: As above, it suffices to show the result for t in 8 _ff *
((oe2))[t1/ff], with t1 2 ((oe1)), and _ff # ftv(oe1, oe2). Hence, t is of the form 8 _ff *
t2[t1/ff], for t2 2 ((oe2)). By induction hypothesis, we have proj(oe2) 6/ proj(t2). By
Property 2.1.2.ii, we get proj(oe2)[proj(oe1)/ff] 6/ proj(t2)[proj(oe1)/ff] (2). By induction hypothesis, we have proj(oe1) 6/ proj(t1). Hence, by Property 2.1.2.iii, we get
proj(t2)[proj(oe1)/ff] 6/ proj(t2)[proj(t1)/ff] (3). By transitivity of 6/, (2), and (3), we
get proj(oe) 6/ proj(t2[t1/ff]), that is, oe 6/ t2[t1/ff]. It implies 8 ( _ff) oe 6/ 8 _ff * t2[t1/ff],
that is 8 ( _ff) oe 6/ t. Observing that 8 (_ff) oe j oe by Eq-Free, we get oe 6/ t by
Property 1.5.4.i.

Property vii: By hypothesis, nf(oe) is not ?. By Property 2.1.5.iii, it implies oe/ffl 6= ?.
Hence, for all t0 in ((oe)), we have t0/ffl = oe/ffl (1) by Property vi. By hypothesis, nf(oe)
is not ff, that is, oe/ffl 6= ff by Property 2.1.5.ii. Hence, t0/ffl 6= ff holds from (1),
which implies that t0 is not equivalent to ff. As a consequence, fsub (t0[t/ff]) =ff
fsub (t0) [t/ff] holds by Property iv. This holds for all t0 in ((oe)), thus fsub (((oe))[t/ff]) =ff
fsub (((oe))) [t/ff]. We conclude by Property i, then.

Property viii: We show by structural induction on oe that ((oe)) = fsub (oe).

ffi Case oe is o/ : Then we have ((oe)) = fsub (o/ ) and oe = o/ , which gives ((oe)) = fsub (oe).
ffi Case oe is ?: Then we have ((oe)) = fsub (8 ff * ff) and oe = 8 ff * ff. Hence, ((oe)) =
fsub (oe).

ffi Case oe is 8 (ff = oe1) oe2: Then we have both ((oe)) = fsub \Gamma ((oe2))[oe1/ff]\Delta  (1) and
oe = oe2[oe1/ff]. We note that oe2 is not ff because oe is in normal form. Hence, we
have fsub (oe) =ff fsub \Gamma oe2\Delta  [oe1/ff] by Property iv. By induction hypothesis, we get
fsub (oe) =ff ((oe2))[oe1/ff] (2). Since oe is in normal form, nf(oe2) is neither ff nor ?, hence
the relation fsub \Gamma ((oe2))[oe1/ff]\Delta  =ff ((oe2))[oe1/ff] (3) holds by Property vii. From (1), (2)
and (3), we get fsub (oe) =ff ((oe)). This holds for any suitable choice of ff, thus we get
fsub (oe) =; ((oe)) by Property 10.3.3.vii. That is fsub (oe) = ((oe)).

ffi Case oe is 8 (ff >= ?) oe2: Then we have ((oe)) = fsub iS_ff#

ftv(oe2)

t2((?)) 8 _ff * ((oe2))[t/ff]j (4)

and oe = 8 ff * oe2 (5). We note that ((?)) is fsub (8 ff * ff) by definition. Hence, t 2
((?)) holds for any t. Additionally, fsub (oe) is by definition the set of instances of oe.

From (5), it is the set S_ff#ftv(oe2)t 8 _ff * fsub \Gamma oe2\Delta  [t/ff]. By induction hypothesis, we get

301

302 Preuves (de'tails techniques)
fsub (oe) = S_ff#

ftv(oe2)

t 8 _ff * ((oe2))[t/ff]. We see that fsub (fsub (oe)) = ((oe)) holds from (4),that is,

fsub (oe) = ((oe)).

Property ix: We obviously have

_ff# _fi[_fl[

t2S

8 _ff * S0[t/ff] `

_ff# _fi[

t2S

8 _ff * S0[t/ff]. Hence, we only

have to show

_ff# _fi[

t2S

8 _ff * S0[t/ff] `

_ff# _fi[_fl[

t2S

8 _ff * S0[t/ff]. Let t1 be in the left-hand term.

There exist _ff disjoint from _fi, t in S and t0 in S0 such that t1 = 8 _ff * t0[t/ff]. Let
OE be a renaming of domain _ff mapping its domain to fresh variables, that is, outside

_ff [ _fi [ _fl [ ftv(t) [ ftv(t0) [ {ff}. Let OE0 be OE restricted to _ff - {ff}. We note that
OE and OE0 are invariant on _fi. Hence, OE(S) ` S and OE0(S0) ` S0 hold. We note that
8 OE( _ff)*OE0(t0)[OE(t)/ff] is an alpha-conversion of t1. Additionally, OE( _ff) # _fi [ _fl, OE0(t0) 2 S0

and OE(t) 2 S. Hence, we have t1 2

_ff# _fi[_fl[

t2S

8 _ff * S0[t/ff], which is the expected result.

Property x: Thanks to Property 10.3.1.ii (page 192), it suffices to show the relation
fsub (`(S)) `dom(`) `(fsub (S)) (1). Let t be in fsub (`(S)) " \Sigma ~dom(`) (2). By definition,

there exists t0 in S such that `(t0) vF t (3). We can freely assume that t0 is in normal
form. We consider two cases.

ffi Case t0 2 dom(`): Then `(t0) is a monotype (by hypothesis), thus t and `(t0) are
equivalent from (3). This implies that there exists t00 equivalent to t0 such that t = `(t00).
Thus, we have t 2 `(fsub (S)).

ffi Otherwise we have t0 /2 dom(`), and t /2 dom(`) holds from (2). From (3) we have
t 2 fsub (`(t0)). By Property iv, we get t 2 `(fsub (t0)), which implies t 2 `(fsub (S)).

In both cases, we have t 2 `(fsub (S)). Hence, (1) is shown and fsub (`(S)) =dom(`)
`(fsub (S)) holds.

Property xi: This is shown by structural induction on oe. Before all, we note that
`(((oe))) ` \Sigma ~dom(`) holds since ` is idempotent by convention. Hence, `(((oe))) =dom(`)

((`(oe))) implies `(((oe))) ` ((`(oe))). We will implicitly apply this result to the induction
hypothesis in some of the following cases.

ffi Case oe is o/ : Then ((oe)) is fsub (o/ ), thus `(((oe))) is fsub (`(o/ )), that is, ((`(o/ ))).
ffi Case oe is ?: Then ((`(oe))) is fsub (8 ff * ff), that is, ((?)). Hence, it remains to show
((?)) =dom(`) `(((?))) (1). We clearly have `(((?))) ` ((?)) (2). Conversely, let t be in
((?)) " \Sigma ~dom(`). We have ftv(t) # dom(`). Hence, `(t) = t. Thus, t is in `(((?))). We

have shown ((?)) `dom(`) `(((?))) (3). From (2) and (3), we get (1).

302

303
ffi Case oe is 8 (ff = oe1) oe2: We can freely consider ff /2 dom(`) [ codom(`). We have
((oe)) = fsub \Gamma ((oe2))[oe1/ff]\Delta  (4). Besides, `(oe) is 8 (ff = `(oe1)) `(oe2), thus ((`(oe))) is by

definition the set fsub i((`(oe2)))[`(oe1)/ff]j (5). We have

`(((oe))) = `(fsub \Gamma ((oe2))[oe1/ff]\Delta ) from (4)

` fsub \Gamma `(((oe2))[oe1/ff])\Delta  by Property 10.3.1.ii
= fsub \Gamma `(((oe2)))[`(oe1)/ff]\Delta 

= fsub i`(((oe2)))[`(oe1)/ff]j since `(oe1) = `(oe1) (easy)

(6) `(((oe))) ` fsub i`(((oe2)))[`(oe1)/ff]j as a summary

Additionally, we have

(7) `(((oe2))) ` ((`(oe2)))
(8) `(((oe2)))[`(oe1)/ff] ` ((`(oe2)))[`(oe1)/ff]

(9) fsub i`(((oe2)))[`(oe1)/ff]j ` fsub i((`(oe2)))[`(oe1)/ff]j

We have (7) by induction hypothesis, (8) by applying [`(oe1)/ff] to (7), and (9) by
applying fsub () to (8). Combining (6), (9), and (5), we get `(((oe))) ` ((`(oe))) (10).

Conversely, we show ((`(oe))) `dom(`)[{ff} `(((oe))). Since oe is in normal form,
nf(oe2) is neither ff nor ?. Hence, nf(`(oe2)) is neither ff nor ?. Then by Property vii and (5), we get ((`(oe))) =ff ((`(oe2)))[`(oe1)/ff] (11). Let t be in ((`(oe))) "
\Sigma ~dom(`)[{ff} (12). From (11), we have t 2 ((`(oe2)))[`(oe1)/ff]. Hence, there exists

t2 2 ((`(oe2))) (13) such that t = t2[`(oe1)/ff] (14). By induction hypothesis, we
have ((`(oe2))) =dom(`) `(((oe2))) (15). Since we have ftv(t) # dom(`) from (12),
we get ftv(t2) # dom(`) (16) by (14). From (13), (16), and (15), we have t2 2
`(((oe2))). Hence, t is in `(((oe2)))[`(oe1)/ff], that is, in `(((oe2))[oe1/ff]). This implies

t 2 `(fsub \Gamma ((oe2))[oe1/ff]\Delta ). Hence, we have t 2 `(((oe))). This holds for all t in ((`(oe))) "
\Sigma ~dom(`)[{ff}, hence we have ((`(oe))) `dom(`)[{ff} `(((oe))) (17). By (10) and (17), we

have ((`(oe))) =dom(`)[{ff} `(((oe))). This holds for any choice of ff. Hence, by Property 10.3.3.vii, we get ((`(oe))) =dom(`) `(((oe))).

ffi Case oe is 8 (ff>=oe1) oe2: We can freely assume ff # dom(`)[codom(`). By definition,

we have ((oe)) = fsub 0@

_ff#ftv(oe1,oe2)[

t12((oe1))

8 _ff * ((oe2))[t1/ff]1A. Hence, the set `(((oe))) is equal to

_ff#ftv(oe1,oe2)[

t12((oe1))

`(fsub (8 _ff * ((oe2))[t1/ff])). Let J be ftv(oe1)[ftv(oe2)[{ff}[dom(`)[codom(`).

By Property iii, ((oe1)) and ((oe2)) are J -stable. By Property ix, we have `(((oe))) =

303

304 Preuves (de'tails techniques)

_ff#J[
t12((oe1))

`(fsub (8 _ff * ((oe2))[t1/ff])) (18). Additionally, `(oe) is 8 (ff = `(oe1)) `(oe2), thus

((`(oe))) is

_ff#ftv(oe1,oe2)[

t12((`(oe1))))

fsub (8 _ff * ((`(oe2)))[t1/ff]). By Property iii, ((`(oe1))) and ((`(oe2)))

are J -stable. By Property ix, ((`(oe))) =

_ff#J[

t12((`(oe1))))

fsub (8 _ff * ((`(oe2)))[t1/ff]) (19) holds.

Let t1 be in ((oe1)) and _ff disjoint from J. We have the following:

(20) `(fsub (8 _ff * ((oe2))[t1/ff])) ` fsub (`(8 _ff * ((oe2))[t1/ff]))
(21) ` fsub (8 _ff * `(((oe2))[t1/ff]))
(22) = fsub (8 _ff * `(((oe2)))[`(t1)/ff])
(23) `(fsub (8 _ff * ((oe2))[t1/ff])) ` fsub (8 _ff * ((`(oe2)))[`(t1)/ff]))

We have (20) by Property 10.3.1.ii, (21) by commutation of ` and 8 _ff* since _ff # J , (22)
by propagating `, and (23) since `(((oe2))) ` ((`(oe2))) holds by induction hypothesis.
We have (23) for all t1 in ((oe1)) and _ff disjoint from J . Hence, taking the union, we get
by (18)

`(((oe))) `

_ff#J[

t12((oe1))

fsub (8 _ff * ((`(oe2)))[`(t1)/ff]))

Observing that the sets {`(t1) | t1 2 ((oe1))} and {t1 | t1 2 `(((oe1)))} are equal, we get

`(((oe))) `

_ff#J[

t12`(((oe1)))

fsub (8 _ff * ((`(oe2)))[t1/ff])) (24)

By induction hypothesis, we have `(((oe1))) ` ((`(oe1))). Hence, by (24) and (19), we get
`(((oe))) ` ((`(oe))) (25). Conversely, we show that ((`(oe))) `dom(`)[{ff} `(((oe))) holds.
Let t be in ((`(oe)))"\Sigma ~dom(`)[{ff} (26). From (19), there exists t1 2 ((`(oe1))) (27), _ff # J,

and t2 2 ((`(oe2))) such that 8 _ff * t2[t1/ff] vF t (28). We have ftv(t) # dom(`) (29)
from (26). Thus, ftv(t2) # dom(`) holds from (28). Hence, by induction hypothesis,
we have t2 2 `(((oe2))). Hence, there exists t02 2 ((oe2)) such that t2 = `(t02). From (28),
we get t 2 fsub (8 _ff * `(t02)[t1/ff]). If ff /2 ftv(t2), then (28) can as well be written
8 _ff * t2[t01/ff] vF t for some t01 in `(((oe1))), and we have t 2 fsub (8 _ff * `(t02)[t01/ff]) (30).
Otherwise, we have ff 2 ftv(t2), thus (28) and (29) imply ftv(t1) # dom(`). Hence, by
induction hypothesis and (27), we get t1 2 `(((oe1))), that is, there exists t01 2 `(((oe1)))
(namely t01 = t1), such that t 2 fsub (8 _ff * `(t02)[t01/ff]). We see that (30) holds in
both cases for some t01 2 `(((oe1))). Hence, there exists t001 in ((oe1)) such that t01 =
`(t001) and t 2 fsub (8 _ff * `(t02)[`(t001)/ff]), that is, t 2 fsub (`(8 _ff * t02[t001/ff])). From (26)

304

305
and Property x, we get t 2 `(fsub (8 _ff * t02[t001/ff])). As a consequence, we have t 2

_ff#J[

t001 2((oe1))

`(fsub \Gamma 8 _ff * ((oe2))[t001/ff]\Delta , that is, t 2 `(((oe))). This holds for all t in ((`(oe))) "

\Sigma ~dom(`)[{ff}, thus we have ((`(oe))) `dom(`)[{ff} `(((oe))) (31). From (25) and (31), we
get ((`(oe))) =dom(`)[{ff} `(((oe))). This holds for any choice of ff, thus Property 10.3.3.vii
gives ((`(oe))) =dom(`) `(((oe))).

Property xii: First, we show that ((oe)) = ((nf(oe))). Then we show that if oe ss oe0 holds
for oe and oe0 in normal form, then ((oe)) = ((oe0)) holds. We conclude by Property 1.5.11.i,
then.

First, we show by induction on the number of universal quantifiers of oe that ((oe)) =
((nf(oe))). We proceed by case analysis on the shape of oe.

ffi Case o/ : We have nf(o/ ) = o/ .
ffi Case ?: We have nf(?) = ?.
ffi Case 8 (ff = oe1) oe2: We consider five subcases:

Subcase nf(oe2) = ff: We have nf(oe) = nf(oe1) and by definition ((oe)) is
fsub \Gamma ((oe2))[oe1/ff]\Delta . By induction hypothesis, ((oe2)) = fsub (ff). Hence, ((oe)) equals

fsub \Gamma oe1\Delta , that is, fsub inf(oe1)j (by definition). By Property viii, we get ((oe)) =
((nf(oe1))).

Subcase nf(oe2) = ?: Then, nf(oe) is ? and by definition the interpretation ((oe))
is fsub \Gamma ((oe2))[oe1/ff]\Delta . By induction hypothesis, ((oe2)) = fsub (8 fi * fi). Hence, ((oe)) =
fsub \Gamma (fsub (8 fi * fi))[oe1/ff]\Delta . By Property 10.3.1.v, we get ((oe)) = fsub \Gamma (8 fi * fi)[oe1/ff]\Delta ,
that is, ((oe)) = fsub (8 fi * fi). Hence, ((oe)) = ((?)).

From now on, we assume that nf(oe2) is neither ? nor ff, so that ((oe)) is by definition
fsub \Gamma ((oe2))[oe1/ff]\Delta . Then by Property vii, we have ((oe)) =ff ((oe2))[oe1/ff] (1).

Subcase ff /2 ftv(oe2): Then nf(oe) is nf(oe2). From (1), we have ((oe)) =ff
((oe2))[oe1/ff] (2). By Property iii, ((oe2)) is ftv(oe2)-stable. As a consequence, the inclusion ((oe2))[oe1/ff] ` ((oe2)) (3) holds. Conversely, if t is in ((oe2)) " \Sigma ~ff, we have
ff /2 ftv(t), thus t[oe1/ff] = t, which implies t 2 ((oe2))[oe1/ff]. As a consequence,
((oe2)) " \Sigma ~ff ` ((oe2))[oe1/ff]. This is by definition ((oe2)) `ff ((oe2))[oe1/ff] (4). By (3)
and (4), we get ((oe2)) =ff ((oe2))[oe1/ff] (5). By (2) and (5), we get ((oe)) =ff ((oe2)) (6).
By Property iii, ((oe)) is ftv(oe)-stable, that is, ftv(oe2)-stable. Additionally, we recall that
ff /2 ftv(oe2). Hence, by Property 10.3.3.v and (6), we get ((oe)) = ((oe2)). By induction
hypothesis, we have ((oe)) = ((nf(oe2))), that is, ((oe)) = ((nf(oe))).

Subcase oe1 2 T : Let o/ be nf(oe1). We have nf(oe) = nf(oe2)[o/ /ff] (7). From (1),
we have ((oe)) =ff ((oe2))[oe1/ff]. By induction hypothesis, we get the relation ((oe)) =ff
((nf(oe2)))[o/ /ff] (8). By Property xi, we have ((nf(oe2)))[o/ /ff] =ff ((nf(oe2)[o/ /ff])) (9).
By (7), (8), and (9), we get ((oe)) =ff ((nf(oe))). This holds for any choice of ff, thus we
get ((oe)) = ((nf(oe))) by Property 10.3.3.vii.

305

306 Preuves (de'tails techniques)

Otherwise, nf(oe) is 8 (ff = nf(oe1)) nf(oe2), and ((oe)) is fsub \Gamma ((oe2))[oe1/ff]\Delta , that
is, fsub i((oe2))[nf(oe1)/ff]j. By definition, ((nf(oe))) is fsub i((nf(oe2)))[nf(oe1)/ff]j. By

induction hypothesis, it is equal to fsub i((oe2))[nf(oe1)/ff]j, that is, ((oe)).

ffi Case 8 (ff >= oe1) oe2: By definition, ((oe)) is fsub 0@

_ff#ftv(oe1,oe2)[

t2((oe1))

8 _ff * ((oe2))[t/ff]1A (10).

We consider five subcases:

Subcase nf(oe2) = ff: From (10) and induction hypothesis, the set ((oe)) is equal

to fsub 0@

_ff#ftv(oe1,oe2)[

t2((nf(oe1)))

8 _ff * t1A. This can also be written

((oe)) = [

_ff#ftv(oe1,oe2)

fsub (8 _ff * ((nf(oe1)))) (11).

We immediately have ((nf(oe1))) ` ((oe)) (12), taking _ff = ;. Conversely, we have
8 _ff * ((oe1)) ` ((nf(oe1))) by Property ii. Hence, fsub (8 _ff * ((oe1))) ` fsub (((nf(oe1)))) by
applying fsub (), that is, fsub (8 _ff * ((oe1))) ` ((nf(oe1))) by Property i. Taking the union
over _ff, and by (11), we get ((oe)) ` ((nf(oe1))) (13). By (12) and (13), we get ((oe)) =
((nf(oe1))), which is the expected result.

Subcase nf(oe2) = ?: From (10) and induction hypothesis, we have ((oe)) equal

to fsub 0@

_ff#ftv(oe1,oe2)[

t2((nf(oe1)))

8 _ff * ((?))[t/ff]1A. Observing that ((?)) is fsub (8 (fi) fi), and taking

_ff = ;, we have fsub (fsub (8 fi * fi) [t/ff]) ` ((oe)) Hence, by Property 10.3.1.v, we have
fsub ((8 fi * fi)[t/ff]) ` ((oe)), that is, fsub (8 fi * fi) ` ((oe)), that is, ((?)) ` ((oe)). Conversely, ((oe)) ` ((?)) obviously holds, thus we have ((oe)) = ((?)), which is the expected
result.

Subcase ff /2 ftv(nf(oe2)): From (10) and induction hypothesis, we have ((oe))

equal to fsub 0@

_ff#ftv(oe1,oe2)[

t2((oe1))

8 _ff * ((nf(oe2)))[t/ff]1A (14). We have 8 ff*((nf(oe2))) ` ((nf(oe2)))

by Property ii. Hence, (8 ff * ((nf(oe2))))[t/ff] ` ((nf(oe2)))[t/ff] holds, that is, 8 ff *
((nf(oe2))) ` ((nf(oe2)))[t/ff]. Applying fsub, we get the inclusion fsub (8 ff * ((nf(oe2)))) `
fsub (((nf(oe2)))[t/ff]). Observing that ((nf(oe2))) ` fsub (8 ff * ((nf(oe2)))) holds, we get
((nf(oe2))) ` fsub (((nf(oe2)))[t/ff]). Hence, we have ((nf(oe2))) ` ((oe)), taking _ff = ;
in (14). Conversely, ((nf(oe2))) is ftv(oe2)-stable by Property iii. Note that [t/ff] is invariant on ftv(oe2). Hence, ((nf(oe2)))[t/ff] ` ((nf(oe2))). This gives 8 _ff * ((nf(oe2)))[t/ff] `
((nf(oe2))) by Property ii. Hence, ((oe)) ` ((nf(oe2))) holds by (14), taking the union over
t and _ff. We have shown ((oe)) = ((nf(oe2))), which is the expected result.

306

307
Subcase oe1 2 T : Let o/ be nf(oe1). From (10) and induction hypothesis, ((oe))
is equal to fsub 0@

_ff#ftv(oe1,oe2)[

t2((o/))

8 _ff * ((nf(oe2)))[t/ff]1A (15). We note that t 2 ((o/ )) implies

t equivalent to o/ . Hence, ((oe)) is also equal to fsub 0@

_ff#ftv(oe1,oe2)[

8 _ff * ((nf(oe2)))[o/ /ff]1A.

Taking _ff = ;, we have ((nf(oe2)))[o/ /ff] ` ((oe)). By Property xi, we get ((nf(oe2)[o/ /ff])) `ff
((oe)), that is ((nf(oe))) `ff ((oe)) (16). Conversely, by Property xi we have ((nf(oe2)))[t/ff] `
((nf(oe2)[t/ff])), that is, ((nf(oe2)))[t/ff] ` ((nf(oe))). Hence, 8 _ff * ((nf(oe2)))[t/ff] ` 8 _ff *
((nf(oe))). By Property ii, we get 8 _ff * ((nf(oe2)))[t/ff] ` ((nf(oe))). Hence, the inclusion
fsub (8 _ff * ((nf(oe2)))[t/ff] ` ((nf(oe)))). This holds for all _ff disjoint from ftv(oe1, oe2) and
all t in ((o/ )), hence we get ((oe)) ` ((nf(oe))) (17) from (15). From (16) and (17), we get
((oe)) =ff ((nf(oe))). This holds for any choice of ff, hence we have ((oe)) = ((nf(oe))) by
Property 10.3.3.vii.

Otherwise: By induction hypothesis applied to oe1 and oe2, and (10), the set

((oe)) is equal to fsub 0@

_ff#ftv(oe1,oe2)[

t2((nf(oe1)))

8 _ff * ((nf(oe2)))[t/ff]1A. Hence ((oe)) = ((8 (ff >= nf(oe1))

nf(oe2))), that is ((oe)) = ((nf(oe))).

Then we have to show that if we have oe ss oe0 for oe and oe0 in normal form, then
((oe)) = ((oe0)) holds. The proof is by induction on the derivation of oe ss oe0. Three rules
define the relation ss. Two of them are context rules. These cases are shown directly
by induction hypothesis. The third case is the commutation rule: by hypothesis we
have ff1 /2 ftv(oe2) and ff2 /2 ftv(oe1), and

8 (ff1 \Pi 1 oe1, ff2 \Pi 2 oe2) oe ss 8 (ff2 \Pi 2 oe2, ff1 \Pi 1 oe1) oe
Let oea be the left-hand type, and oeb be the right-hand type. The definitions to compute the sets ((oea)) and ((oeb)) depend on the symbols \Pi 1 and \Pi 2. In order to factorize the four possible cases, we consider the following remark: Let oe0 be a type and
oe00 be an F-type. Let S be {oe0}. Then we note that fsub (((oe))[oe0/ff]) can be written fsub 0@

_ff#ftv(oe,oe0)[

t2S

8 _ff * ((oe))[t/ff]1A. Hence, taking S1

M= ((oe1)) if \Pi 1 is flexible and

S1

M= {oe1} is \Pi 1 is rigid, ((oea)) is equal to

fsub 0@

_ff#ftv(oea)[{ff1}[

t12S1

8 _ff * ((8 (ff2 \Pi 2 oe2) oe))[t1/ff1]1A

307

308 Preuves (de'tails techniques)
Taking S2

M= ((oe2)) if \Pi 2 is flexible and S2 M= {oe2} if \Pi 2 is rigid, ((oea)) is then equal to

fsub 0@

_ff#ftv(oea)[{ff1}[

t12S1

8 _ff * fsub 0@

_fi#ftv(oe2,oe)[

t22S2

8 _fi * ((oe))[t2/ff2]1A [t1/ff1]1A

Let J be ftv(oe1) [ ftv(oe2) [ ftv(oe). By Properties iii and ix, we get

fsub 0@

_ff#J[

t12S1

8 _ff * fsub 0@

_fi#J[

t22S2

8 _fi * ((oe))[t2/ff2]1A [t1/ff1]1A

By notation, it is equal to

fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * fsub \Gamma 8 _fi * ((oe))[t2/ff2]\Delta  [t1/ff1]1A

By Property 10.3.1.iii, we get

((oea)) ` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

fsub \Gamma 8 _ff * 8 _fi * ((oe))[t2/ff2]\Delta  [t1/ff1]1A

By notation, and observing that fsub (fsub (S)) = fsub (S), we get

((oea)) ` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t2/ff2][t1/ff1]1A (18)

Let _ff and _fi be disjoint from J . Let t1 and t2 be in S1 and S2, respectively. Let fl1 and
fl2 be fresh variables, that is, not in J [ ftv(t1) [ ftv(t2) [ _ff [ _fi [ {ff1} [ {ff2}. Let t01
be t1[fl2/ff2] and t02 be t2[fl1/ff1]. We recall that S1 is either ((oe1)) or {oe1}. In the first
case, S1 is ftv(oe1)-stable by Property iii. By hypothesis, we have ff2 /2 ftv(oe1). Hence,
S1[fl2/ff2] ` S1, thus t01 2 S1 (19). In the second case, t1 is oe1 and ftv(t1) = ftv(oe1)
by Property 10.3.1.i, hence t01 = t1. In both cases, (19) holds. Similarly, t02 2 S2 holds.
Additionally, we have {fl1, fl2} # J . Hence, we have {fl1, fl2}[ _ff # J . As a consequence,
we have

8 fl1fl2 _ff _fi * ((oe))[t01/ff1][t02/ff2] 2

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]

Applying fsub (), we get

fsub \Gamma 8 fl1fl2 _ff _fi * ((oe))[t01/ff1][t02/ff2]\Delta  ` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]1A

308

309
Observing that we have ((oe))[t01/ff1][t02/ff2] = ((oe))[t02/ff2][t01/ff1], we get

fsub \Gamma 8 fl1fl2 _ff _fi * ((oe))[t02/ff2][t01/ff1]\Delta  ` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]1A

Additionally, we note that the type 8 _ff _fi * ((oe))[t2/ff2][t1/ff1] belongs to the set

fsub \Gamma 8 fl1fl2 _ff _fi * ((oe))[t02/ff2][t01/ff1]\Delta 
Thus, we get

8 _ff _fi * ((oe))[t2/ff2][t1/ff1] 2 fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]1A

This holds for all t1 and t2 in S1 and S2, respectively, and for all _ff and _fi disjoint from
J. Hence, taking the union over t1, t2, _ff and _fi, we get

fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff _fi * ((oe))[t2/ff2][t1/ff1]1A

` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]1A

Applying fsub (), and by (18), we get

((oea)) ` fsub 0@

_ff#J[

t12S1

_fi#J[
t22S2

8 _ff * 8 _fi * ((oe))[t1/ff1][t2/ff2]1A

By commutation of the union symbols, we get

((oea)) ` fsub 0@

_fi#J[

t22S2

_ff#J[
t12S1

8 _fi * 8 _ff * ((oe))[t1/ff1][t2/ff2]1A

This can also be written

((oea)) ` fsub 0@

_fi#J[

t22S2

8 _fi * [

t12S1

((oe))[t1/ff1][t2/ff2]1A

309

310 Preuves (de'tails techniques)
Observing that we have [

t12S1

((oe))[t1/ff1] ` ((8 (ff1 \Pi 1 oe1) oe)), we get

((oea)) ` fsub 0@

_fi#J[

t22S2

8 _fi * ((8 (ff1 \Pi 1 oe1) oe))[t2/ff2]1A

That is,

((oea)) ` ((8 (ff2 \Pi 2 oe2) 8 (ff1 \Pi 1 oe1) oe))

Hence, we have shown ((oea)) ` ((oeb)). By symmetry, we immediately get ((oeb)) ` ((oea)).
Hence, ((oea)) = ((oeb)), which is the expected result. Finally, we have shown that oe ss oe0
implies ((oe)) = ((oe0)).

Property xiii: We prove the property by structural induction on Q. Let ` be in ((Q)).
We proceed by case analysis on the shape of Q.

ffi Case ;: Immediate.
ffi Case (Q0, ff \Pi  oe) with oe /2 T : Then ` is equal to `0 ffi [t/ff] for t being oe if \Pi  is
rigid, or t being in ((oe)) otherwise. By induction hypothesis, there exists ` 00 such that
`0 = `00 ffi cQ0. We get the expected result by observing that bQ = cQ0.

ffi Case (Q0, ff = oe) with oe 2 T : Then ` is equal to `0 ffi [oe/ff] for some `0 in ((Q0)).
Let o/ be nf(oe). By induction hypothesis, there exists `00 such that `0 = `00 ffi cQ0. Hence
` = `00 ffi cQ0 ffi [oe/ff]. By definition, oe is o/ , that is, o/ . Hence, ` = `00 ffi cQ0 ffi [o/ /ff]. We
conclude by observing that bQ is cQ0 ffi [o/ /ff].

ffi Case (Q0, ff >= oe) with oe 2 T : Then ` is equal to `0 ffi [t/ff] for some t in ((oe)), and
`0 in ((Q0)). Let o/ be nf(oe). By Property xii, we have t 2 ((o/ )), that is, t 2 fsub (o/ ). As
a consequence, t is equivalent to o/ . Thus, nf(t) is o/ . By induction hypothesis, there
exists `00 such that `0 = `00 ffi cQ0. Hence we have ` = `00 ffi cQ0 ffi [o/ /ff]. We conclude by
observing that bQ is cQ0 ffi [o/ /ff].

Proof of Lemma 10.3.8
By induction on the derivation of (Q) oe1 @- oe2 (1). Let ` be in ((Q)). We proceed by
case analysis on the last rule in the derivation of (1).

ffi Case A-Equiv: By hypothesis, (Q) oe1 j oe2 holds. By Corollary 1.5.10, we haveb
Q(oe1) j bQ(oe2). Hence, by Property 10.3.6.xii, we have (( bQ(oe1))) = (( bQ(oe2))). By
Property iv, we get bQ(((oe1))) =dom( bQ) bQ(((oe2))) (2). Since bQ is idempotent, we haveb

Q(((oe1))) " \Sigma ~dom( bQ) = bQ(((oe1))) as well as bQ(((oe2))) " \Sigma ~dom( bQ) = bQ(((oe2))). Hence,
from (2), we get bQ(((oe1))) = bQ(((oe2))) (3). By Property 10.3.6.xiii, we have ` = `0 ffi bQ.

310

311
Composing (3) by `0, we get `(((oe1))) = `(((oe2))). This leads to fsub (`(((oe1)))) =
fsub (`(((oe2)))).

ffi Case R-Trans: By induction hypothesis.
ffi Case R-Context-Rigid: The premise is (Q) oe01 @- oe02 (4), oe1 is 8 (ff = oe01) oe, and
oe2 is 8 (ff = oe02) oe. Since oe1 and oe2 are shallow, oe01 and oe02 are F-types. Hence, we

have ((oe01)) = fsub ioe01j and ((oe02)) = fsub ioe02j by Property iii. By induction hypothesis and (4), it gives fsub (`(((oe01)))) = fsub (`(((oe02)))), that is, fsub i`(fsub ioe01j)j =
fsub i`(fsub ioe02j)j. By Property 10.3.1.v, we get fsub i`(oe01)j = fsub i`(oe02)j (5). In
particular, we have `(oe01) 2 fsub i`(oe01)j. Hence, by (5), we have `(oe01) 2 fsub i`(oe02)j,
which means that `(oe02) vF `(oe01) (6) holds. Similarly, we show that `(oe01) vF `(oe02) (7)
holds. As a consequence of (6) and (7), `(oe01) and `(oe02) are equivalent (8) in System F.
Now, by definition, ((oe1)) is ((oe))[oe01/ff]. Hence, `(((oe1))) is `(((oe)))[`(oe01)/ff]. By (8), this
implies `(((oe)))[`(oe02)/ff] ae fsub (`(((oe1)))), that is, `(((oe2))) ae fsub (`(((oe1)))). Similarly,
we have `(((oe1))) ae fsub (`(((oe2)))). As a result, `(((oe1))) and `(((oe2))) are equivalent in
System F. This implies fsub (`(((oe1)))) = fsub (`(((oe2)))).

ffi Case R-Context-R: The premise is (Q, ff \Pi  oe) oe01 @- oe02, oe1 is 8 (ff \Pi  oe) oe01, and oe2
is 8 (ff \Pi  oe) oe02.

Subcase \Pi  is rigid: Then ((oe1)) is fsub (((oe01))[oe/ff]) and ((oe2)) is fsub (((oe02))[oe/ff]).
Let `0 be ` ffi [oe/ff]. We note that `0 is in ((Q, ff = oe)). By induction hypothesis, we have

fsub \Gamma `0(((oe01)))\Delta  = fsub \Gamma `0(((oe02)))\Delta 
Thus, by Property 10.3.1.v, we get the equality

fsub \Gamma `(fsub \Gamma ((oe01))[oe/ff]\Delta )\Delta  = fsub \Gamma `(fsub \Gamma ((oe02))[oe/ff]\Delta )\Delta 
This is exactly fsub (`(((oe1)))) = fsub (`(((oe2)))).

Subcase \Pi  is flexible: By definition, we have

((oe1)) = fsub 0@

_ff#ftv(oe,oe01)[

t2((oe))

8 _ff * ((oe01))[t/ff]1A

((oe2)) = fsub 0@

_ff#ftv(oe,oe02)[

t2((oe))

8 _ff * ((oe02))[t/ff]1A

311

312 Preuves (de'tails techniques)
This leads to the following:

fsub (`(((oe1)))) = fsub 0@` 0@fsub 0@

_ff#ftv(oe,oe01)[

t2((oe))

8 _ff * ((oe01))[t/ff]1A1A1A

fsub (`(((oe2)))) = fsub 0@` 0@fsub 0@

_ff#ftv(oe,oe02)[

t2((oe))

8 _ff * ((oe02))[t/ff]1A1A1A

By Property 10.3.1.v, we get

fsub (`(((oe1)))) = fsub 0@` 0@

_ff#ftv(oe,oe01)[

t2((oe))

8 _ff * ((oe01))[t/ff]1A1A

and

fsub (`(((oe2)))) = fsub 0@` 0@

_ff#ftv(oe,oe02)[

t2((oe))

8 _ff * ((oe02))[t/ff]1A1A

This can also be written

fsub (`(((oe1)))) =

_ff#ftv(oe,oe01)[

t2((oe))

fsub \Gamma ` \Gamma 8 _ff * ((oe01))[t/ff]\Delta \Delta 

fsub (`(((oe2)))) =

_ff#ftv(oe,oe02)[

t2((oe))

fsub \Gamma ` \Gamma 8 _ff * ((oe02))[t/ff]\Delta \Delta 

Let J be ftv(oe, oe01, oe02)[ dom(`) [ codom(`) (9). By Property ii, ((oe)) is ftv(oe, oe02)-stable,
((oe01)) is ftv(oe, oe01)-stable, and ((oe02)) is ftv(oe, oe02)-stable. Hence, by Property 10.3.6.ix,
we get

fsub (`(((oe1)))) =

_ff#J[

t2((oe))

fsub \Gamma ` \Gamma 8 _ff * ((oe01))[t/ff]\Delta \Delta  (10)

fsub (`(((oe2)))) =

_ff#J[

t2((oe))

fsub \Gamma ` \Gamma 8 _ff * ((oe02))[t/ff]\Delta \Delta  (11)

312

313
We have to show that these two sets are equal. Let t 2 ((oe)) and _ff disjoint from J (12).
Let `0 be ` ffi [nf(t)/ff] (13). We note that `0 is in ((Q, ff >= oe)). We have

(14) fsub (`0(((oe01)))) = fsub (`0(((oe02))))
(15) fsub (`(((oe01))[nf(t)/ff])) = fsub (`(((oe02))[nf(t)/ff]))
(16) fsub (`(((oe01))[t/ff])) = fsub (`(((oe02))[t/ff]))
(17) fsub (8 _ff * `(((oe01))[t/ff])) = fsub (8 _ff * `(((oe02))[t/ff]))
(18) fsub (`(8 _ff * ((oe01))[t/ff])) = fsub (`(8 _ff * ((oe02))[t/ff]))

Equality (14) holds by induction hypothesis. Equality (15) holds by (13) and (14).
Equality (16) holds by (15) by observing that t and nf(t) are equivalent, thus the set
fsub (`(((oe0))[nf(t)/ff])) is equal to fsub (`(((oe0))[t/ff])) for oe0 being oe01 or oe02. Equality (17) holds by Property 10.3.1.iv and (16). Equality (18) holds by commutation of `
and 8 _ff*, thanks to (12) and (9). In summary, (18) holds for all t in ((oe)) and _ff disjoint
from J , hence we have fsub (`(((oe1)))) = fsub (`(((oe2)))) from (10) and (11).

ffi Case A-Hyp: We have (ff = oe1) 2 Q and oe2 is ff. By definition, ((oe2)) is fsub (ff).
Necessarily, Q is of the form (Q1, ff = oe1, Q2). Hence, ((Q)) is ((Q1)) * ((ff = oe1)) * ((Q2)).
This implies that ` is of the form `1 ffi `0 ffi `2 (19), with `1 2 ((Q1)), `2 2 ((Q2)), and `0
is [oe1/ff]. Hence, we have fsub (`(((oe2)))) = fsub (`(fsub (ff))), that is, fsub (`(((oe2)))) =
fsub (`(ff)) by Property 10.3.1.v. By (19), we get fsub (`(((oe2)))) = fsub \Gamma `1(oe1)\Delta  (20).
By Property iii, we have ((oe1)) = fsub \Gamma oe1\Delta . Hence, fsub (`(((oe1)))) = fsub \Gamma `(fsub \Gamma oe1\Delta )\Delta .
By Property 10.3.1.v, fsub (`(((oe1)))) is fsub \Gamma `(oe1)\Delta , that is, fsub \Gamma `1(oe1)\Delta . Then, we
get fsub (`(((oe1)))) = fsub (`(((oe2)))) by (20).

Proof of Lemma 10.3.9
By Lemma 2.3.3, we have a restricted thrifty derivation of (Q) oe1 "" oe2 (1). Let ` be
in ((Q)). We consider a first case that corresponds to equivalence, then we proceed by
case analysis on the last rule in the derivation of (1).

ffi Case (Q) oe1 j oe2 holds: As in the proof of Lemma 10.3.8, we have `(((oe1))) =
`(((oe2))). This case being solved, we can freely consider that, in the following, (Q) oe1 j
oe2 does not hold.

ffi Case A-Equiv: See the above remark.
ffi Case I-Abstract: By induction hypothesis.
ffi Case R-Trans: By induction hypothesis.
ffi Case R-Context-R: The premise is (Q, ff \Pi  oe) oe01 "" oe02 (2), oe1 is 8 (ff \Pi  oe) oe01, and
oe2 is 8 (ff \Pi  oe) oe02. We can freely consider ff /2 codom(`). If nf(oe01) is ?, then nf(oe1) is
?, thus ((oe1)) is ((?)) by Property 10.3.6.xii. In this case, `(((oe2))) ` `(((oe1))) obviously
holds. If nf(oe02) is ?, then nf(oe2) is ?, which implies nf(oe1) = ? by Property 2.7.7.ii.
We solve this case as above. In the following, we consider nf(oe1) and nf(oe2) different

313

314 Preuves (de'tails techniques)
from ? (3). Since the derivation is thrifty, we have nf(oe01) = ff if and only if nf(oe02) = ff.
We note that if nf(oe01) = ff, then ((oe01)) is fsub (ff) by Properties 1.5.6.i and 10.3.6.xii.
Hence, in this case, ((oe1)) and ((oe2)) are equal, which solves this case. In the following,
we consider nf(oe1) and nf(oe2) different from ff (4). Additionally, if nf(oe01) is a type
variable fi, then (Q, ff \Pi  oe) oe01 j oe02 holds by Property 2.1.6, thus (Q) oe1 j oe2 holds.
We have already proved such a case. In the following, we consider that nf(oe1) is not a
type variable (5). We consider two subcases.

Subcase \Pi  is rigid: By definition, ((oe1)) is the set fsub (((oe01))[oe/ff]) (6) and
((oe2)) is the set fsub (((oe02))[oe/ff]). Let `0 be ` ffi [oe/ff]. We note that `0 is in ((Q, ff =
oe)). By induction hypothesis and (2), we have `0(((oe02))) ` `0(((oe01))) (7). By Property 10.3.6.vii, (3), (4), and (6), we get ((oe1)) =ff ((oe01))[oe/ff]. By Property 10.3.3.x,
we get `(((oe1))) =ff `0(((oe01))). Similarly, `(((oe2))) =ff `0(((oe02))). From (7), we get
`(((oe2))) `ff `(((oe1))). This holds for any choice of ff not in codom(`), thus, by Property 10.3.3.vi, we get `(((oe2))) ` `(((oe1))).

Subcase \Pi  is flexible: By definition, we have

((oe1)) = fsub 0@

_ff#ftv(oe,oe01)[

t2((oe))

8 _ff * ((oe01))[t/ff]1A

((oe2)) = fsub 0@

_ff#ftv(oe,oe02)[

t2((oe))

8 _ff * ((oe02))[t/ff]1A

Let J be ftv(oe) [ ftv(oe01) [ ftv(oe02) [ dom(`) [ codom(`). By Properties 10.3.7.ii
and 10.3.6.ix, we get

((oe1)) = fsub 0@

_ff#J[

t2((oe))

8 _ff * ((oe01))[t/ff]1A (8)

((oe2)) = fsub 0@

_ff#J[

t2((oe))

8 _ff * ((oe02))[t/ff]1A (9)

Let t2 be in `(((oe2))). We note that ftv(t2) # dom(`) (10) holds. By (9), there
exist t in ((oe)) and _ff disjoint from J such that t2 is in `(fsub \Gamma 8 _ff * ((oe02))[t/ff]\Delta ). By
Property 10.3.1.ii, we have t2 in the set fsub \Gamma `(8 _ff * ((oe02))[t/ff])\Delta . Since _ff is disjoint from
J, this set is equal to fsub \Gamma 8 _ff * ` ffi [t/ff](((oe02)))\Delta . This set is closed by equivalence in
System F (it is of the form fsub (S)), hence it is equal to fsub \Gamma 8 _ff * ` ffi [nf(t)/ff](((oe02)))\Delta .
Let `0 be ` ffi[nf(t)/ff]. We note that `0 is in ((Q, ff>=oe)). Hence, by induction hypothesis,
we have `0(((s02))) ` `0(((oe01))). As a consequence, t2 is in fsub \Gamma 8 _ff * ` ffi [nf(t)/ff](((oe01)))\Delta ,

314

315
that is, t in fsub \Gamma `(8 _ff * ((oe01))[nf(t)/ff])\Delta . For any t1 in 8 _ff * ((oe01))[nf(t)/ff], we have
t1/ffl = oe01/e by Property 10.3.6.vi, (3), and (4). In particular, (5) implies that the
normal form of t1 is not in the set dom(`). By Property 10.3.6.v and (10), the type t2
is in the set `(fsub \Gamma 8 _ff * ((oe01))[nf(t)/ff]\Delta ). Since t and nf(t) are equivalent, we also have
t2 in `(fsub \Gamma 8 _ff * ((oe01))[t/ff]\Delta ). Hence, t2 is in

`(fsub 0@

_ff#J[

t2((oe))

8 _ff * ((oe01))[t/ff]1A)

By (8), that is t2 2 `(((oe1))) In summary, we have shown `(((oe2))) ` `(((oe1))).

ffi Case R-Context-Rigid: The premise is (Q) oe01 @- oe02 (11), oe1 is 8 (ff = oe01) oe,
and oe2 is 8 (ff = oe02) oe. We can freely assume ff /2 codom(`). By definition, ((oe1))

is fsub i((oe))[oe01/ff]j and ((oe2)) is fsub i((oe))[oe02/ff]j. By restrictions of Lemma 2.3.1,
we have nf(oe) 6= ff and nf(oe) 6= ?, which imply ((oe1)) =ff ((oe))[oe01/ff] and ((oe2)) =ff
((oe))[oe02/ff] by Property 10.3.6.vii (page 196). By Property 10.3.3.x (page 194), we
get `(((oe1))) =ff `(((oe))[oe01/ff]) and `(((oe2))) =ff `(((oe))[oe02/ff]). This is equivalent
to `(((oe1))) =ff `(((oe))[`(oe01)/ff]) (12) and `(((oe2))) =ff `(((oe))[`(oe02)/ff]) (13). By
Lemma 10.3.8 (page 196) and (11), we have fsub (`(((oe01)))) = fsub (`(((oe02)))). By Property 10.3.7.iii (page 196), it gives

fsub i`(fsub ioe01j)j = fsub i`(fsub ioe02j)j

By Property 10.3.1.v, we get fsub i`(oe01)j = fsub i`(oe02)j (14). In particular, we have
`(oe01) 2 fsub i`(oe01)j. Hence, by (14), we have `(oe01) 2 fsub i`(oe02)j, which means that
`(oe02) vF `(oe01) (15) holds. Similarly, we show that `(oe01) vF `(oe02) (16) holds. As a
consequence of (15) and (16), `(oe01) and `(oe02) are equivalent in System F. Observing
that oe01 and oe02 are in normal form by definition, we get `(oe01) = `(oe02). By (12) and (13),
it leads to `(((oe1))) =ff `(((oe1))). This holds for any choice of ff such that ff /2 codom(`).
Hence, by Property 10.3.3.vii, we get `(((oe1))) = `(((oe2))).

ffi Case R-Context-Flexible: The premise is (Q) oe01 v oe02 (17), oe1 is 8 (ff >= oe01)
oe, and oe2 is 8 (ff >= oe02) oe. By induction hypothesis and (17), we get `(((oe02))) `
`(((oe01))) (18). By definition, we have

((oe1)) = fsub 0@

_ff#ftv(oe01,oe)[

t012((oe01))

8 _ff * ((oe))[t01/ff]1A

((oe2)) = fsub 0@

_ff#ftv(oe02,oe)[

t022((oe02))

8 _ff * ((oe))[t02/ff]1A

315

316 Preuves (de'tails techniques)
Let J be ftv(oe, oe01, oe02) [ dom(`) [ codom(`). By Properties 10.3.7.ii and 10.3.6.ix, we
get

((oe1)) = fsub 0@

_ff#J[

t012((oe01))

8 _ff * ((oe))[t01/ff]1A

((oe2)) = fsub 0@

_ff#J[

t022((oe02))

8 _ff * ((oe))[t02/ff]1A

Applying `, we get

`(((oe1))) = ` 0@fsub 0@

_ff#J[

t012((oe01))

8 _ff * ((oe))[t01/ff]1A1A

`(((oe2))) = ` 0@fsub 0@

_ff#J[

t022((oe02))

8 _ff * ((oe))[t02/ff]1A1A

By restrictions of Lemma 2.3.1, we have ff 2 ftv(oe), and nf(oe) 6= ff. As a consequence,
oe/ffl is a type constructor g. Hence, for all t in ((oe)), for all _ff and all t01 2 ((oe01)),
8 _ff * t[t01/ff]/ffl = g. In particular, t /2 dom(`). By Property 10.3.6.v, we get

`(((oe1))) =dom(`) fsub 0@

_ff#J[

t012((oe01))

`(8 _ff * ((oe))[t01/ff])1A

`(((oe2))) =dom(`) fsub 0@

_ff#J[

t022((oe02))

`(8 _ff * ((oe))[t02/ff])1A

Hence, we have

`(((oe1))) =dom(`) fsub 0@

_ff#J[

t012((oe01))

8 _ff * `(((oe)))[`(t01)/ff]1A

`(((oe2))) =dom(`) fsub 0@

_ff#J[

t022((oe02))

8 _ff * `(((oe)))[`(t02)/ff]1A

316

317
We note that the sets {`(t01) | t01 2 ((oe01))} and {t01 | t01 2 `(((oe01)))} are equal. Hence, we
have

`(((oe1))) =dom(`) fsub 0@

_ff#J[

t012`(((oe01)))

8 _ff * `(((oe)))[t01/ff]1A

`(((oe2))) =dom(`) fsub 0@

_ff#J[

t022`(((oe02)))

8 _ff * `(((oe)))[t02/ff]1A

By (18), we get `(((oe2))) `dom(`) `(((oe1))). We note that ` is idempotent, thus `(((oei)))"
\Sigma ~dom(`) = `(((oei))) for oei being oe1 or oe2. Hence, `(((oe2))) ` `(((oe1))) holds.

ffi Case A-Hyp: We have (ff = oe1) 2 Q and oe2 is ff. By definition, ((oe2)) is fsub (ff).
Necessarily, Q is of the form (Q1, ff = oe1, Q2). Hence, ((Q)) is ((Q1)) * ((ff = oe1)) * ((Q2)).
This implies that ` is of the form `1 ffi[oe1/ff]ffi`2, with `1 2 ((Q1)) and `2 2 ((Q2)). Hence,
all types in `(((oe2))) are equivalent to `1(oe1), that is, `(oe1). This implies `(((oe2))) `
fsub \Gamma `(oe1)\Delta . By Property 10.3.1.v, we get `(((oe2))) ` fsub \Gamma `(fsub \Gamma oe1\Delta )\Delta . By Property 10.3.7.iii, we have `(((oe2))) ` fsub (`(((oe1)))). The restrictions of Lemma 2.3.1
ensure that oe1 is not in T . Hence, nf(oe1) is not in dom(`). As a consequence, we
have `(((oe2))) `dom(`) `(fsub (((oe1)))). By Property 10.3.6.i, we get `(((oe2))) `dom(`)
`(((oe1))). Observing that ` is idempotent, we get `(((oe2))) " \Sigma ~dom(`) = `(((oe2))), thus

`(((oe2))) `dom(`) `(((oe1))).

ffi Case I-Hyp: We have (ff >= oe1) 2 Q and oe2 is ff. By definition, ((oe2)) is fsub (ff).
Necessarily, Q is of the form (Q1, ff >= oe1, Q2). Hence, ((Q)) is ((Q1)) * ((ff >= oe1)) * ((Q2)).
This implies that ` is of the form `1 ffi [t/ff] ffi `2, with `1 2 ((Q1)), `2 2 ((Q2)), and
t 2 ((oe1)). Hence, all types in `(((oe2))) are equivalent to `1(t), that is, `(t). We
conclude as in the case A-Hyp.

ffi Case I-Bot: We have oe1 = ?, and observing that ((?)) is fsub (8 ff * ff), we have
`(((oe2))) ` `((?)).

ffi Case I-Rigid: We have oe1 = 8 (ff >= oe) oe0, and oe2 = 8 (ff = oe) oe0. By definition,

((oe2)) is fsub (((oe0))[oe/ff]), and ((oe1)) is fsub 0@

_ff#ftv(oe,oe0)[

t2((oe))

8 _ff * ((oe0))[t/ff]1A (19) By Property 10.3.7.iii, we have oe 2 ((oe)). Let t be oe. Taking _ff = ; in (19), we immediately
have fsub (((oe0))[t/ff]) ` ((oe1)), that is, ((oe2)) ` ((oe1)). This implies `(((oe2))) ` `(((oe1))).

317

318 Preuves (de'tails techniques)
318
Rules 319
Index
Defined rules
Many inference rules are introduced in the document. They are listed in the following
table. Names of derived rules are followed by a star ? and can be found page 321.

Rule name Relation Page [fig] Rule name Relation Page [fig]
A-Alias' @-_ff p.82 [2.1] A-Context-L' @-_ff p.82 [2.1]
A-Context? @- p.77 A-Equiv' @-_ff p.82 [2.1]
A-Equiv @- p.57 [1.2] A-Hyp' @-_ff p.82 [2.1]
A-Hyp @- p.57 [1.2] A-Up' @-_ff p.82 [2.1]
A-Up? @- p.57 Ac-Hyp @-C p.78
App

O `O p.149 [5.3] App ` p.145 [5.2]

C-Abstract-F .v p.85 [2.5] C-Abstract-R .v p.85 [2.5]
C-Strict .v p.85 [2.5] Eq-Comm j p.48 [1.1]
Eq-Context? j p.77 Eq-Free j p.48 [1.1]
Eq-Mono? j p.49 Eq-Mono j p.48 [1.1]
Eq-Refl j p.48 [1.1] Eq-Var? j p.50
Eq-Var j p.48 [1.1] Fun

O `O p.149 [5.3]

Fun? ` p.176 Fun ` p.145 [5.2]
Gen ` p.145 [5.2] I-Abstract' v_ff p.83 [2.2]
I-Abstract v p.60 [1.3] I-Alias' v_ff p.83 [2.2]
I-Bot' v_ff p.83 [2.2] I-Bot v p.60 [1.3]
I-Context-L' v_ff p.83 [2.2] I-Context? v p.77

continued. . . continued. . .

319

320 Rules

Rule name Relation Page [fig] Rule name Relation Page [fig]
I-Drop? v p.59 I-Equiv? v p.59
I-Hyp' v_ff p.83 [2.2] I-Hyp v p.60 [1.3]
I-Rigid' v_ff p.83 [2.2] I-Rigid v p.60 [1.3]
I-Up' v_ff p.83 [2.2] I-Up? v p.59
Ic-Abstract vC p.79 Ic-Bot vC p.79
Ic-Hyp vC p.79 Ic-Rigid vC p.79
Inst ` p.145 [5.2] Let

O `O p.149 [5.3]

Let ` p.145 [5.2] Oracle

O `O p.149 [5.3]

Oracle ` p.145 [5.2] PA-Context-L @-I` p.105 [3.2]
PA-Equiv @-I` p.105 [3.2] PA-Trans @-I` p.105 [3.2]
PE-Comm jI` p.105 [3.1] PE-Context-L jI` p.105 [3.1]
PE-Free jI` p.105 [3.1] PE-Mono? jI` p.106
PE-Mono jI` p.105 [3.1] PE-Refl jI` p.105 [3.1]
PE-Swap jI` p.105 [3.1] PE-Trans jI` p.105 [3.1]
PI-Abstract vI` p.106 [3.3] PI-Context-L vI` p.106 [3.3]
PI-Rigid vI` p.106 [3.3] PI-Trans vI` p.106 [3.3]
Pr-Subst? "" p.102 R-Context-Flexible "" p.47
R-Context-Rigid "" p.47 R-Context-L "" p.47
R-Context-R "" p.47 R-Trans "" p.47
S-Alias .@ p.84 [2.3] S-Hyp .@ p.84 [2.3]
S-Nil .@ p.84 [2.3] S-Rigid .@ p.84 [2.3]
S-Up .@ p.84 [2.3] StSh-Alias .@-_ff p.85 [2.4]
StSh-Hyp .@-_ff p.85 [2.4] StSh-Up .@-_ff p.85 [2.4]
Strengthen' `0 p.155 -6.2.3 Strengthen ` p.152 -6.1.2
Var

O `O p.149 -5.3 Var ` p.145 [5.2]

Weaken? ` p.152 -6.1.2 Weaken ` p.152 6.1.2

320

Rules 321
Derivable rules
Some of the rules in the previous table are actually derivable rules. We explicitly give
such rules here.

N ame Rule Page
Eq-Mono? (Q) oe

0 j o/

(Q) 8 (ff \Pi  oe0) oe j oe[o/ /ff] P.49

Eq-Var? (ff \Pi  oe) 2 Q(Q

0) 8 (Q) ff j 8 (Q) oe P.50

A-Up? ff

0 /2 ftv(oe0)

8 (ff = 8 (ff0 = oe0) oe) oe0 @- 8 (ff0 = oe0) 8 (ff = oe) oe0 P.57

I-Drop? (QQ0Q00) 8 (Q0) oe v oe P.59

I-Equiv? (Q) oe1 j oe2(Q) oe

1 v oe2 P.59

I-Up? ff2 /2 ftv(oe)(Q) 8 (ff

1 >= 8 (ff2 \Pi  oe2) oe1) oe v 8 (ff2 \Pi  oe2) 8 (ff1 >= oe1) oe P.59

Eq-Context? (QC) oe1 j oe2(Q) C(oe

1) j C(oe2) P.77

A-Context? (QCr) oe1 @- oe2(Q) C

r(oe1) @- Cr(oe2) P.77

continued. . .

321

322 Notations

N ame Rule Page
I-Context? (QCf ) oe1 v oe2(Q) C

f (oe1) v Cf (oe2) P.77

Pr-Subst? (Q`) oe1 "" oe2(Q) `(oe

1) "" `(oe2) P.102

PE-Mono? (Q) oe j o/(Q, ff = oe, Q0) j

` (Q, ff = oe, Q0[o/ /ff]) P.106

Notations
The following table lists the symbols and notations used in this document. The left
column contains a symbol or a word. Then comes the page where it is defined. In most
cases, the third column provides the corresponding definition, or it simply reads the
symbol.

In a few cases, the prefix Q is supposed equal to (ff1 \Pi 1 oe1, . . . ffn \Pi n oen) (1). We
explicitly refer to this definition, then.

Symbol Page Meaning

ff, o/ , oe 40 A type variable, a monotype, a polytype

_ff, _o/ 40 A tuple of type variables, a tuple of monotypes

Q1 # Q2 41 dom(Q1) # dom(Q2)

_ff # _fi 40 _ff " _fi = ;
OE disjoint from _ff 44 _ff # dom(OE) [ codom(OE)

#(oe) 96 The cardinal of dom(oe)

? 91 Binary operator on {X, Y, Z}
8 (Q) oe 41 8 (ff1 \Pi 1 oe1) . . . 8 (ffn \Pi n oen) oe when Q is (1)

continued. . .

322

Notations 323

Symbol Page Meaning

8 ff * S 192 {8 ff * t | t 2 S}

v 59 The instance relation, figure 1.3

.v 85 See figure 2.5

.@ 84 See figure 2.3
vI 103 Prefix instance relation
vI` 106 See figure 3.3
vC 79

vF 192 The instance relation of System F.

v_ff 83 See figure 2.2

@- 57 The abstraction relation, figure 1.2
.@-_ff 85 See figure 2.4

(Q) oe1 @-? oe2 121 The abstraction-check algorithm

@-I 103 Prefix abstraction relation
@-I` 105 See figure 3.2
@-C 78

@-_ff 82 See figure 2.1

ffl 41 The empty sequence
ss 50 The rearrangement relation, Definition 1.5.2
S1 =_ff S2 194 S1 " \Sigma ~_ff = S2 " \Sigma ~_ff

j 48 The equivalence relation, figure 1.1
(j .@-;), (j .v) 83 See Definition 2.6.1

(j|vC ) 79
(j|@-C ) 78

jI 103 Prefix equivalence relation
jI` 105 See figure 3.1
\Pi , \Pi 0, \Pi 1 40 Meta-variables standing for = or >=, as in e.g.

(ff1 \Pi 1 oe1, ff2 \Pi 2 oe2)

T 53 The set {oe | 9o/.nf(oe) = o/ }

continued. . .

323

324 Notations

Symbol Page Meaning

? 40 "bottom", equivalent to 8 (ff) ff

OE 44 An idempotent renaming
OE~ 44 The inverse renaming of OE
OE(Q) 44 (OE(ff1) \Pi 1 OE(oe1) . . . OE(ffn) \Pi n OE(oen)) when Q

is (1)

"" 46 Meta-variable standing for j, @-, or v, as in

e.g. (Q) oe1 "" oe2

Q "" Q0 103 Q ""dom(Q) Q0

oe * u/ 42 The function u0 7! oe/uu0

doee 128 See Definition 4.5.2
oe0[oe/ff] 44 The substitution [oe/ff] applied to the type oe0

oe/ 42 The function mapping occurrences in oe to

type symbols

oe/u 42 The type symbol at occurrence u in oe

oe 192 The projection of an F-type oe to a type of

System F.

[oe/ff] 44 The capture-avoiding substitution of ff by oe

\Sigma I 103 The set {oe | utv(oe) ` I}
\Sigma ~_ff 193 The set of System F types {t | ftv(oe) # _ff}
P 6 P 0 (polynomials) 86

6/ 65 A partial order on skeletons
S1 `_ff S2 194 S1 " \Sigma ~_ff ` S2 " \Sigma ~_ff

` 145 Typing judgments, see figure 5.2
`

O 149 Syntax-directed typing judgments, see figure 5.3
\Theta  41 A substitution on skeletons

` 44 An idempotent substitution
`(S) 192 {`(t) | t 2 S}
`(Q) 44

continued. . .

324

Notations 325

Symbol Page Meaning

` 102 The monotype prefix corresponding to `
\Theta Q 42 Assuming Q is (1), this is the substitution

[proj(oe1)/ff1] ffi .. ffi [proj(oen)/ffn]

[ ] 71 A hole (in contexts)
rQ 41 rdom(Q)
rff1,...ffn 40 ff1 ! . . . ! ffn ! unit

C 71 Generic contexts
C 71 The prefix corresponding to Cb
C 71 The extracted substitution bC
Cn 76 Contexts with n holes

Cf 74 Flexible contexts
Cn 73 Narrow contexts

Cr 74 Rigid contexts
cf(oe) 56 The constructed form of oe
codom(f ) 44 The set Sff2dom(f) ftv(f (ff))

d(oe) 96 The degree of P (oe)
dom(Q) 41 The set {ff1, . . . ffn}

dom(oe) 42 The domain of oe/

dom(f ) 44 The set {ff | f (ff) 6= ff}
dom=(Q), dom>(Q) 207 Rigid domain of Q, flexible domain of Q

dom1(C) 73 The 1-level of context C

dom(C) 71 The domain dom(C)
dom(Q/I) 104 See Definition 3.3.1
dom(Q/oe1, . . . oei) 104 The domain dom(Q/ ftv(oe1) [ . . . ftv(oei))

dom(Q/oe) 104 The domain dom(Q/ ftv(oe))

fsub (S) 192 St2S fsub (t)

fsub (t) 192 {t0 | t vF t0}

ftv(oe) 43 The set of free type variables of oe

continued. . .

325

326 Notations

Symbol Page Meaning
ftv(oe1, oe2) 43 The set ftv(oe1) [ ftv(oe2)

g or gn 40 A type constructor, of arity n

I 101 An interface, that is, a set of type variables _ff
level(C) 73 The level of context C

nf(oe) 52 The normal form of oe

P (oe) 96 wX (oe)(X, X, X)
proj(oe) 42 The function mapping types to skeletons

Q 41 A prefix, e.g.(1)
Q" _ff 112 The splitting of Q according to _ff
Q[ff] 69 The representative of ff in Q
Q(ff) 69 The bound of Q[ff] in Q
Q ( (ff \Pi  oe) 123 Update algorithm, see figure 4.2
Q ( ff1 ^ ff2 124 Merge algorithm, see Definition 4.2.6b

Q 53 The substitution extracted from Q
R* 36 The transitive closure of R

R 36 A meta-variable standing for a relation (depending on the context)

S 192 A set of System F types.

t 41 A skeleton
utv(oe) 43 The set of unbound type variables of oe

# 40 The set of type variables.
V 53 The set {oe | 9ff.nf(oe) = ff}
wX (oe), wY (oe), wZ (oe) 91 Weights of oe (polynomials)

constructed form 56 See Definition 1.5.12

flexible binding 40 (ff >= oe)
f invariant on _ff 44 _ff # dom(f )

rigid binding 40 (ff = oe)
unconstrained binding 40 (ff >= ?) also written (ff)

326