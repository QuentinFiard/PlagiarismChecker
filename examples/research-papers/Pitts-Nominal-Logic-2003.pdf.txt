

Information and Computation 186 (2003) 165-193

www.elsevier.com/locate/ic

Nominal logic, a first order theory of names and binding

Andrew M. Pitts*
University of Cambridge Computer Laboratory, William Gates Building, J.J. Thomson Avenue,

Cambridge CB3 0FD, UK

Received 18 March 2002; revised 27 May 2002

Abstract

This paper formalises within first-order logic some common practices in computer science to do with rep-resenting and reasoning about syntactical structures involving lexically scoped binding constructs. It introduces
Nominal Logic, a version of first-order many-sorted logic with equality containing primitives for renaming vianame-swapping, for freshness of names, and for name-binding. Its axioms express properties of these constructs
satisfied by the FM-sets model of syntax involving binding, which was recently introduced by the author andM.J. Gabbay and makes use of the Fraenkel-Mostowski permutation model of set theory. Nominal Logic serves
as a vehicle for making two general points. First, name-swapping has much nicer logical properties than moregeneral, non-bijective forms of renaming while at the same time providing a sufficient foundation for a theory of
structural induction/recursion for syntax modulo \Delta -equivalence. Secondly, it is useful for the practice of operationalsemantics to make explicit the equivariance property of assertions about syntax - namely that their validity is
invariant under name-swapping.(C) 2003 Elsevier Science (USA). All rights reserved.

Keywords: Abstract syntax; Variable binding; Permutation; Fresh names

1. Introduction

It is commonplace, when using formal languages in computer science or mathematical logic, to ab-stract away from details of concrete syntax in terms of strings of symbols and instead work solely with
parse trees - the `abstract syntax' of a language. Doing so gives one access to two extremely useful and

* Fax: +44-1223-334678.
E-mail address: Andrew.Pitts@cl.cam.ac.uk.

0890-5401/$ - see front matter (C) 2003 Elsevier Science (USA). All rights reserved.
doi:10.1016/S0890-5401(03)00138-X

166 A.M. Pitts / Information and Computation 186 (2003) 165-193
inter-related tools: definition by recursion on the structure of parse trees and proof by induction on thatstructure. However, conventional abstract syntax is not abstract enough if the formal language involves
variable-binding constructs. In this situation the common practice of human (as opposed to computer)provers is to say one thing and do another. We say that we will quotient the collection of parse trees
by a suitable equivalence relation of \Delta -conversion, identifying trees up to renaming of bound variables;but then we try to make the use of

\Delta -equivalence classes as implicit as possible by dealing with themvia suitably chosen representatives. How to make good choices of representatives is well understood,

so much so that it has a name - the `Barendregt Variable Convention': choose a representative parsetree whose bound variables are fresh, i.e., mutually distinct and distinct from any (free) variables in the
current context. This informal practice of confusing an \Delta -equivalence class with a member of the classthat has sufficiently fresh bound variables has to be accompanied by a certain amount of hygiene on the
part of human provers: our constructions and proofs have to be independent of which particular freshnames we choose for bound variables. Nearly always, the verification of such independence properties
is omitted, because it is tedious and detracts from more interesting business at hand. Of course thisintroduces a certain amount of informality into `pencil-and-paper' proofs that cannot be ignored if one
is in the business of producing fully formalised, machine-checked proofs. But even if you are not inthat business and are content with your pencil and paper, I think there is a good reason to examine this
informal use of `sufficiently fresh names' and put it on a more precise, mathematical footing.The reason I have in mind has to do with those intuitive and useful tools mentioned above: structural
recursion for defining functions on parse trees and structural induction for proving properties of them.Although it is often said that the Barendregt Variable Convention allows one to work with

\Delta -equivalenceclasses of parse trees as though they were just parse trees, this is not literally the case when it comes to

structural recursion/induction. For example, when dealing with an induction step for a variable-bindingconstruct, it often happens that the step can be proved for a sufficiently fresh bound variable, but not for
an arbitrary one, as the induction principle demands. The Barendregt Variable Convention papers overthe crack in the proof at this point by preventing one considering the case of an arbitrary bound variable
rather than a fresh one, but the crack is still there. Although one can sometimes side-step the problem byusing a suitable size function on parse trees and replacing structural induction with mathematical induction, this is not a very satisfying solution. The size function will be defined by structural recursion andthe crucial fact that

\Delta -equivalent parse trees have the same size will be proved by structural induction; sowe are using structural recursion/induction anyway, but somehow not in the direct way we would like.

We can do better than this.Indeed, the work reported in [16,17,35] does do better, by providing a mathematical notion of `sufficiently fresh name' that remains very close to the informal practice described above while enabling
\Delta -equivalence classes of parse trees to gain useful inductive/recursive properties. The theory stems fromthe somewhat surprising observation that all of the concepts we need (

\Delta -equivalence, freshness, variable-binding, . . . ) can be defined purely in terms of the operation of swapping pairs of names. In particular,

the freshness of a name for an object is expressed by saying that the name is not in some finite setof names that supports the object, which means that the finite set has the property that swapping any
pair of names not in it leaves the object unchanged. This notion of support is weak second order, sinceit involves an existential quantification over finite sets of names. However, much of the development
in [17] only makes use of certain first-order properties of the freshness (i.e., `not-in-the-support-of')predicate in combination with the swapping operation. This paper presents this first-order theory of
names, swapping and freshness, called Nominal Logic.

A.M. Pitts / Information and Computation 186 (2003) 165-193 167
1.1. Outline of the paper

Section 2 presents some motivations for basing a theory of syntax and binders upon the notions ofatoms (names), swapping atoms, and freshness of atoms. Section 3 introduces the syntax we use for these
concepts, together with some typical examples of what can be expressed with them. As explained in [17],the Nominal Logic notions of atom, swapping and freshness can be given a meaning independent of any
particular object-level syntax using FM-sets - the Fraenkel-Mostowski permutation model of set theory;in Section 4 we describe the category of nominal sets, which provides a simplified presentation of FMsets emphasising swapping over more general permutations of atoms. Then in Section 5 we axiomatisethe key first-order properties of the nominal sets model of atoms, swapping and freshness. Section 6
makes a definitional extension of this theory with a quantifier expressing a characteristic `some/any'property of fresh atoms. In Section 7 we make another definitional extension to deal with variablebinding operations in a more uniform way. This completes the definition of Nominal Logic, which issummarised in Appendix A. Section 7 illustrates its use by presenting a first-order theory of

\Theta -termsmodulo
\Delta -equivalence containing a convenient structural induction axiom. Section 8 discusses the factthat Nominal Logic is incompatible with the use of choice functions to select a `next' fresh atom in any

particular context. Finally, Sections 9 and 10 describe some related approaches to fully formal treatmentsof names and binding and draw some conclusions.

2. Equivariant predicates

The fundamental assumption underlying Nominal Logic is that the only predicates we ever deal with(when describing properties of syntax) are equivariant ones, in the sense that their validity is invariant
under swapping (i.e., transposing, or interchanging) names.Names of what? Names of entities that may be subject to binding by some of the syntactical constructions under consideration. In Nominal Logic these sorts of names, the ones that may be bound andhence that may be subjected to swapping without changing the validity of predicates involving them,
will be called atoms. The terminology refers back to the origins of the theory in the Fraenkel-Mostowskipermutation model of set theory. Atoms turn out to have quite different logical properties from constants
(in the usual sense of first-order logic) which, being constant, are not subjected to swapping. Note thatthis distinction between atom and constant has to do with the issue of binding, rather than substitution:
a syntactic category of variables, by which is usually meant entities that may be subject to substitu-tion, might be represented in Nominal Logic by atoms or by constants, depending upon circumstances:
constants will do if we are in a situation where variables are never bound, but can be substituted for;otherwise we should use atoms. The interesting point is that we can make this (useful!) distinction
between `bindable' names and names of constants entirely in terms of properties of swapping names,prior to any discussion of substitution and its properties.

Why the emphasis on the operation of swapping two names, rather than on the apparently moreprimitive notion of renaming one name by another? The answer to this question lies in the combination
of the following two facts.* First, even though swapping seems less general than renaming (since after all, the act of swapping

aand
b can be expressed as the simultaneous renaming of b by a and a by b), it is possible to found atheory of syntax modulo

\Delta -equivalence, free and bound variables, substitution, etc., upon this notion- this is the import of the work in [17].

168 A.M. Pitts / Information and Computation 186 (2003) 165-193

* Secondly, swapping is an involutive operation: a swap followed by the same swap is equivalent todoing nothing. This means that the class of equivariant predicates, i.e., those whose validity is invariant

under atom-swapping, has excellent logical properties. It contains the equality predicate and is closedunder negation, conjunction, disjunction, existential and universal quantification, formation of least
and greatest fixed points of monotone operators, etc. The same is not true for renaming. For example,the validity of a negated equality between atoms is not necessarily preserved under renaming.
In other words we can found a theory of variable-binding upon swapping, and it is convenient to do sobecause of its good logical properties. Here are a couple of examples to illustrate these points, taken
from \Theta -calculus and type theory.
Example 1 (\Delta -equivalence of \Theta -terms). Consider the terms of the untyped \Theta -calculus, which we can taketo be

\Delta -equivalence classes [t ]\Delta  of parse trees t given by the grammar

t ::= a -- \Theta a.t -- t t (1)
where a ranges over an infinite set of variables. The relation of \Delta -equivalence between such parse trees,
t \Theta \Delta  t\Lambda , is usually defined to be the congruence generated by relating \Theta a.t and \Theta b.-b/a""t if there are nooccurrences of

b in t (be they free, bound or binding occurrences). Here -b/a""t is the parse tree obtainedfrom
t by replacing all free occurrences of a with b. The properties of this form of renaming are ratherinconvenient for our aim of developing a theory of variable-binding in which logical equality subsumes

\Delta -equivalence. This is because the operation -b/a""(-), as a total function on all parse trees, does notnecessarily respect

\Delta -equivalence when applied to trees that do contain occurrences of b - because ofthe possible `capture' of

b by binders \Theta b.(-) occurring in t . (For example \Theta b.a \Theta \Delta  \Theta c.a holds, but-
b/a""(\Theta b.a) = \Theta b.b\Delta \Delta \Theta c.b = -b/a""(\Theta c.a).) In the development of the theory of \Theta -calculus [1], thisinconvenient fact immediately leads to the formulation of more complicated, `capture-avoiding' notions

of renaming and substitution. However, it is possible to go in the other direction and replace -b/a""(-)with another, equally simple form of renaming which does respect

\Delta -equivalence whatever term it isapplied to. For as pointed out in [17, Section 2], if
b does not occur in t , then -b/a""t is \Delta -equivalentto the parse tree obtained from
t by swapping all occurrences of a and b (be they free, bound, or evenbinding occurrences): we denote this parse tree by

(a b)u*t. The total function (a b)u*(-) on parse trees isin a sense more fundamental than -
b/a""(-), because its definition does not depend upon knowing whatis a free variable, i.e., upon knowing which of the syntax-constructors is supposed to be a binder: for the

definition of (a b)u*(-) on a \Theta -abstraction term takes just the same form as for an application term - onejust applies the swap to all immediate subtrees:

(a b)u*(\Theta c.t )= \Theta ((a b)u*c).((a b)u*t)

(a b)u*(t t\Lambda )= ((a b)u*t)((a b)u*t\Lambda )

where (a b)u*c = \Delta \Theta \Lambda 

a if c = b
b if c = a
c otherwise

Proposition 2.2 of [17] proves that the relation \Theta \Delta  can be inductively generated by syntax-directed rulesof the following three kinds:

a \Theta \Delta  a (2)

A.M. Pitts / Information and Computation 186 (2003) 165-193 169
t1 \Theta \Delta  t\Lambda 1 t2 \Theta \Delta  t\Lambda 2

t1 t2 \Theta \Delta  t \Lambda 1 t\Lambda 2 (3)

(a b)u*t \Theta \Delta  (a\Lambda  b)u*t\Lambda 

\Theta a.t \Theta \Delta  \Theta a\Lambda .t\Lambda  b \Xi = a, a\Lambda  and b does not occur in t or t \Lambda  (4)
It is immediate from this characterisation of \Theta \Delta  that it is equivariant, in the sense that

for all t and t\Lambda , t \Theta \Delta  t \Lambda  implies (a b)u*t \Theta \Delta  (a b)u*t\Lambda 
(a property that we have noted does not hold for the renaming operation -b/a""(-)). The reason why theequivariance property holds is quite general: any relation inductively defined by an equivariant set of

rules (in the sense that swapping a pair of names throughout the hypotheses and conclusion of any ruleyields another element of the set of rules) is easily seen to be an equivariant relation, i.e., closed under
applying the swapping operation. And as we mentioned above, once we know that \Theta \Delta  is equivariant, sowill be predicates built up from it using the usual logical operations. To illustrate the usefulness of this
observation, consider proving from the above inductive characterisation of \Theta \Delta  that it is transitive. Wecan proceed by `rule induction' and show that the relation

\Lambda (t, t\Lambda ) \Delta  (\Pi t \Lambda \Lambda ) t\Lambda  \Theta \Delta  t\Lambda \Lambda  \Sigma  t \Theta \Delta  t\Lambda \Lambda  (5)
is closed under the rules (2)-(4) inductively defining \Theta \Delta . We will just consider the case of the third rule,since it illustrates the usefulness of equivariance.

So suppose we have

\Lambda ((a b)u*t, (a\Lambda  b)u*t\Lambda ) (6)
where b \Xi = a, a\Lambda  and b does not occur in t or t \Lambda . We have to show that \Lambda (\Theta a.t, \Theta a\Lambda .t \Lambda ) holds, i.e., that forany

t\Lambda \Lambda , \Theta a\Lambda .t\Lambda  \Theta \Delta  t\Lambda \Lambda  implies \Theta a.t \Theta \Delta  t \Lambda \Lambda . Now the syntax-directed nature of the rules comes to our aid: if
\Theta a\Lambda .t\Lambda  \Theta \Delta  t\Lambda \Lambda  holds, it must have been deduced by an application of rule (4): so t\Lambda \Lambda  = \Theta a\Lambda \Lambda .t \Lambda \Lambda \Lambda  say, and

(a\Lambda  c)u*t\Lambda  \Theta \Delta  (a\Lambda \Lambda  c)u*t\Lambda \Lambda \Lambda  (7)
holds for some c \Xi = a\Lambda , a\Lambda \Lambda  with c not occurring in t \Lambda  or t \Lambda \Lambda \Lambda . Let d be a fresh variable, i.e., one not occurringin

t, t \Lambda , or t\Lambda \Lambda  and not in -a, a\Lambda , a\Lambda \Lambda , b, c"". Now we use the equivariance property of \Lambda : since (6) holds, sodoes the predicate with

b and d swapped throughout; and since b and d do not occur in t or t\Lambda  and arenot equal to
a or a\Lambda , the result of this swapping is provably equivalent to

\Lambda ((a d)u*t, (a\Lambda  d)u*t\Lambda ) (8)
Similarly, the equivariance property of \Theta \Delta  itself means that by swapping c and d in (7), we also have

(a\Lambda  d)u*t\Lambda  \Theta \Delta  (a\Lambda \Lambda  d)u*t \Lambda \Lambda \Lambda  (9)
Remembering the definition of \Lambda , (8) and (9) combine to yield

(a d)u*t \Theta \Delta  (a\Lambda \Lambda  d)u*t \Lambda \Lambda \Lambda 
and since d \Xi = a, a\Lambda \Lambda  and d does not occur in t or t\Lambda \Lambda , we can apply rule (4) to this to deduce \Theta a.t \Theta \Delta 
\Theta a\Lambda \Lambda \Lambda .t\Lambda \Lambda \Lambda , i.e., \Theta a.t \Theta \Delta  t \Lambda \Lambda , as required. \Theta 

Example 2 (Weakening in type theory). McKinna and Pollack [28] note that in the nai"ve approach tonamed bound variables referred to in Section 1, there is a difficulty with proving the weakening property

170 A.M. Pitts / Information and Computation 186 (2003) 165-193
of type systems by rule induction. For example, consider the usual typing relation assigning simple typesto terms of the untyped

\Theta -calculus. As in the previous example, we take the latter to mean \Delta -equivalenceclasses [
t]\Delta  of parse trees t given by the grammar (1). The typing relation takes the form \Xi  \Upsilon  [t]\Delta  : \Pi  ,where types

\Pi  are given by the grammar \Pi  ::= X -- \Pi  \Phi  \Pi  (with X ranging over an infinite collection oftype variables); and where the typing context

\Xi  is a finite partial function from variables to types. Thetyping relation is inductively generated by rules following the structure of the parse tree

t. (If the readeris not familiar with these rules, see [19, Chapter 2], for example; but note that as mentioned in Section

1, the literature usually does not bother to make a notational distinction between t and [t]\Delta .)When trying to prove the weakening property of the typing relation, namely

(\Pi \Xi )(\Pi t)(\Pi \Pi  ) \Xi  \Upsilon  [t]\Delta  : \Pi  \Sigma  (\Pi \Pi  \Lambda )(\Pi a\Lambda  /\Psi  dom(\Xi )) \Xi , a\Lambda  : \Pi  \Lambda  \Upsilon  [t]\Delta  : \Pi  (10)
it is natural to try to proceed by rule induction and show that the predicate \Lambda (\Xi , [t]\Delta , \Pi  ) given by

(\Pi \Pi  \Lambda )(\Pi a\Lambda  /\Psi  dom(\Xi )) \Xi , a\Lambda  : \Pi  \Lambda  \Upsilon  [t]\Delta  : \Pi 
defines a relation that is closed under the rules inductively defining the typing relation and hence containsthat relation. But the induction step for the rule for typing

\Theta -abstractions

\Xi , a : \Pi 1 \Upsilon  [t ]\Delta  : \Pi 2
\Xi  \Upsilon  [\Theta a.t]\Delta  : \Pi 1 \Phi  \Pi 2 a /\Psi  dom(\Xi ) (11)
is problematic: we have to prove

\Lambda (\Xi , a : \Pi 1, [t]\Delta , \Pi 2) \Omega  a /\Psi  dom(\Xi ) \Sigma  \Lambda (\Xi , [\Theta a.t]\Delta , \Pi 1 \Phi  \Pi 2);
i.e., given

\Lambda (\Xi , a : \Pi 1, [t]\Delta , \Pi 2) (12)
and

a /\Psi  dom(\Xi ) (13)
we have to prove that

\Xi , a\Lambda  : \Pi  \Lambda  \Upsilon  [\Theta a.t ]\Delta  : \Pi 1 \Phi  \Pi 2 (14)
holds for all a\Lambda  /\Psi  dom(\Xi ) (and all \Pi  \Lambda ) - and there is a problem with doing this for the case a\Lambda  = a.But this difficulty with the induction step is easily circumvented if we take equivariance into account.

The axioms and rules defining typing are closed under the operations of swapping pairs of variables(and also under swapping pairs of type variables, but we do not need to use that here). For example, if
we have an instance of rule (11) and we swap any pair of variables throughout both the hypotheses andthe conclusion, we get another valid instance of this rule.1 As we mentioned in the previous example,
it follows from this swapping property of the axioms and rules that the typing relation, being the leastrelation closed under the axioms and rules, is also closed under the swapping operations. Therefore
any assertion about typing that we make by combining the typing relation with other such equivariantpredicates (such as `

a \Psi  dom(\Xi )') using the usual logical connectives and quantifiers will be equivariant.In particular the predicate

\Lambda  defined above is equivariant. Thus if we know that (12) holds, then so does

1 To see this, strictly speaking we have to make use of the fact, noted in Example 1, that (a b)u*(-) preserves \Theta \Delta  and hence
that the result of swapping a and b throughout the set [t]\Delta  is the equivalence class [(a b)u*t]\Delta .

A.M. Pitts / Information and Computation 186 (2003) 165-193 171
\Lambda (\Xi , b : \Pi 1, [(a b)u*t]\Delta , \Pi 2) for any fresh variable b (i.e., one not occurring in \Xi , t , or -a, a\Lambda ""). So by defi-nition of

\Lambda , since a\Lambda  /\Psi  dom(\Xi , b : \Pi 1), we have (\Xi , b : \Pi 1), a\Lambda  : \Pi  \Lambda  \Upsilon  [(a b)u*t]\Delta  : \Pi 2. Since (\Xi , b : \Pi 1), a\Lambda  :
\Pi  \Lambda  = (\Xi , a\Lambda  : \Pi  \Lambda ), b : \Pi 1 (we are using partial functions for typing contexts) and b /\Psi  dom(\Xi , a\Lambda  : \Pi  \Lambda ) (bychoice of

b), we can apply typing rule (11) to conclude that \Xi , a\Lambda  : \Pi  \Lambda  \Upsilon  [\Theta b.((a b)u*t)]\Delta  : \Pi 1 \Phi  \Pi 2. But
\Theta b.((a b)u*t ) and \Theta a.t are \Delta -equivalent parse trees, so \Xi , a\Lambda  : \Pi  \Lambda  \Upsilon  [\Theta a.t]\Delta  : \Pi 1 \Phi  \Pi 2 holds. Thus if (12)and (13) hold, so does

\Lambda (\Xi , [\Theta a.t ]\Delta , \Pi 1 \Phi  \Pi 2) and we have completed the induction step. \Theta 

From the considerations of this section we abstract the following ingredients for a language to de-scribe syntax involving names and binding: the language should contain a notion of atom together with
operations for swapping atoms in expressions (in general we may need several different sorts of atoms- for example, atoms for variables and atoms for type variables in Example 2); and the formulas of the
language should all be equivariant with respect to these swapping operations. Atoms and swapping aretwo of the three novelties of Nominal Logic. The third has to do with the crucial step in the proofs in
Examples 1 and 2 when we chose a fresh variable (d in the first example and b in the second one): weneed to give a freshness relation between atoms and expressions with sufficient properties to make such
arguments go through.

3. Syntax of swapping and freshness

The syntax of Nominal Logic is that of many-sorted first-order logic with equality, augmented by thefollowing extra features.

* The collection of sorts (typical symbol S) is partitioned into two kinds: sorts of atoms (typical symbol

A) and sorts of data.* For each sort of atoms

A and each sort S there is a distinguished function symbol of arity A, A, S -\Phi 
S whose effect on terms t1 : A, t2 : A and t3 : S we write as the term (t1 t2)u*t3 and pronounce `swap t1and

t2 in t3'.* For each sort of atoms

A and each sort S there is a distinguished relation symbol of arity A, S whoseeffect on terms
t1 : A and t2 : S we write as the formula t1 # t2 and pronounce `t1 is fresh for t2'.Later on we will add extra syntax for freshness quantification (Section 6) and atom-abstraction sorts and

terms (Section 7). These extra concepts are first-order definable in terms of the basic ones given above,so we stick with these for the moment for simplicity's sake.

Just as for ordinary first-order logic, a theory in Nominal Logic is specified by a signature of sort,function and relation symbols, together with a collection of (non-logical) axioms, which are first-order formulas built up in the usual way from variables and the symbols of the signature, but now ofcourse possibly using the swapping functions and the freshness relation. Here is an example of how
this language of Nominal Logic can be used; we formalise some familiar concepts from \Theta -calculus init. Exploring the logical properties of these formalisations has to wait until we introduce the axioms of
Nominal Logic in Section 5.
Example 3 (\Delta , \Sigma , and \Upsilon  equivalence). Consider the following signature for \Theta -calculus, with a sort ofatoms for variables and a sort of data for

\Theta -terms over those variables.Sort of atoms: Var

Sort of data: Term

172 A.M. Pitts / Information and Computation 186 (2003) 165-193
Function symbols: var : Var -\Phi  Termapp : Term

, Term -\Phi  Termlam : Var
, Term -\Phi  TermAs discussed in Example 1, we can use swapping and freshness to express

\Delta -conversion:

(\Pi a, a\Lambda  : Var)(\Pi t : Term) a\Lambda  # t \Sigma  lam(a, t ) = lam(a\Lambda , (a a\Lambda )u*t ) (15)
Instead of axiomatising \Delta -conversion on a theory-by-theory basis, in Section 7 we move it into thelogical infrastructure via a notion of atom-abstraction. In particular, we can then take lam to be a function

symbol of arity [Var]Term -\Phi  Term, where [Var]Term is a sort of atom-abstractions (see Definition 4),whose logical properties ensure that extra axioms for

\Delta -conversion like (15) are no longer necessary.Another typical use of the freshness relation # is to internalise the usual side-condition on

\Upsilon -conver-sion, as in the following axiom:

(\Pi a : Var)(\Pi t : Term) a # t \Sigma  t = lam(a, app(t, var(a))) (16)
How may we express \Sigma -conversion in this language? One way is to augment the signature with afunction symbol for capture-avoiding substitution

subst : Term, Var, Term -\Phi  Term
and then express \Sigma -conversion by

(\Pi a : Var)(\Pi t, t\Lambda  : Term) app(lam(a, t \Lambda ), t ) = subst(t, a, t \Lambda ) (17)
together with axioms for substitution:

(\Pi t : Term)(\Pi a : Var) subst(t, a, var(a)) = t (18)

(\Pi t : Term)(\Pi a, a\Lambda  : Var) ~ a = a\Lambda  \Sigma  subst(t, a, var(a\Lambda )) = var(a\Lambda ) (19)

(\Pi t, t\Lambda , t\Lambda \Lambda  : Term)(\Pi a : Var) subst(t, a, app(t\Lambda , t\Lambda \Lambda ))=

app(subst(t, a, t \Lambda ), subst(t, a, t \Lambda \Lambda )) (20)

(\Pi t, t\Lambda  : Term)(\Pi a, a\Lambda  : Var) ~ a\Lambda  = a \Omega  a\Lambda  # t \Sigma 

subst(t, a, lam(a\Lambda , t\Lambda )) = lam(a\Lambda , subst(t, a, t\Lambda )) (21)

Since the last axiom only specifies how to substitute under a \Theta -binder when the bound variable a\Lambda  issufficiently fresh, i.e., when ~

a\Lambda  = a and a\Lambda  # t, it might seem that the axioms for subst do not specifyit uniquely. However, in view of axiom (15), any lam

(a\Lambda , t\Lambda ) is equal to some lam(a\Lambda \Lambda , t\Lambda \Lambda ) for which thefreshness condition is satisfied. In Section 7, we give a theory in Nominal Logic for

\Theta -terms modulo
\Delta -equivalence (Example 6) that includes a structural induction principle codifying this familiar practiceof only dealing with

\Theta -abstractions whose bound variables are sufficiently fresh.

4. Nominal sets

As explained in [17], the Nominal Logic notions of atom, swapping and freshness can be given ameaning independent of any particular object-level syntax using FM-sets - the Fraenkel-Mostowski
permutation model of set theory. Here we give a simplified, but essentially equivalent, presentation of

A.M. Pitts / Information and Computation 186 (2003) 165-193 173
FM-sets that emphasises swapping over more general permutations of atoms. At the same time we usea mild generalisation of [17] (mentioned in [16, Section 7]) in which the set of atoms is partitioned into
countably many different kinds (and we only swap atoms of the same kind).Fix a countably infinite family

(An -- n \Psi  N) of pairwise disjoint, countably infinite sets. We write Afor the union of all the A

n and call its elements atoms.

Definition 1 (Nominal sets). A nominal set X is a set --X-- equipped with a well-behaved notion ofswapping atoms in elements of the set. By definition this means that for each element

x \Psi  --X-- and eachpair of atoms
a, a\Lambda  of the same kind (i.e., a, a\Lambda  \Psi  An for some n \Psi  N), we are given an element (a a\Lambda )u*Xxof
X, called the result of swapping a and a\Lambda  in x. These swapping operations are required to have thefollowing properties:

(i) Equational properties of swapping: for each x \Psi  --X-- and all pairs of atoms of equal sort, a, a\Lambda  \Psi  Amand

b, b\Lambda  \Psi  An (any m, n \Psi  N)

(a a)u*Xx =x (22)

(a a\Lambda )u*X(a a\Lambda )u*Xx =x (23)

(a a\Lambda )u*X(b b\Lambda )u*Xx =((a a\Lambda )b (a a\Lambda )b\Lambda  )u*X(a a\Lambda )u*Xx (24)where

(a a\Lambda )b\Delta  \Delta \Theta \Lambda 

a if b = a\Lambda 
a\Lambda  if b = a
b otherwise (25)

and similarly for (a a\Lambda )b\Lambda .(ii) Finite support property: we require that each

x \Psi  --X-- only involve finitely many atoms, in the sensethat given
x, there exists a finite subset w ff A with the property that (a a\Lambda )u*Xx = x holds for all
a, a\Lambda  \Psi  An - w (any n \Psi  N). Then it can be shown that

suppX(x)\Delta  \Xi 

n\Psi N-

a \Psi  An -- -a\Lambda  \Psi  An -- (a a\Lambda )u*Xx \Xi = x"" is not finite"" (26)

is a finite set of atoms (see the proof of [17, Proposition 3.4]), which we call the support of x in X.A morphism of nominal sets,

f : X -\Phi  Y , is by definition a function from the set --X-- to the set --Y --that respects the swapping operations in the sense that

f ((a a\Lambda )u*Xx) = (a a\Lambda )u*Y f (x) (27)
holds for all x \Psi  --X-- and all atoms a, a\Lambda  (of the same kind). Clearly the composition of two such functionsis another such; and identity functions are morphisms. Therefore nominal sets and morphisms form a

category, which we denote by Nom.
Remark 1 (From swapping to permutations). It is a standard result of the mathematical theory of groupsand group actions that the group of all permutations of the

n-element set -1, . . . , n"" is isomorphic to thegroup freely generated by
n - 1 symbols gi (i = 1, . . . , n - 1), subject to the identities

(gi)2 = id (i < n)
(gi gi+1)3 = id (i < n - 1)
(gi gj )2 = id (j < i - 1)

with the generator gi corresponding to the permutation transposing i and i + 1. (See for example [24,Beispiel 19.7].) From this fact one can easily deduce that the group of all (kind-respecting) finite

174 A.M. Pitts / Information and Computation 186 (2003) 165-193
permutations of the set of atoms A is freely generated by the transpositions (a a\Lambda ) (with a and a\Lambda  ofthe same kind, i.e.,

a, a\Lambda  \Psi  An for some n \Psi  N), subject to the identities

(a a) = id
(a a\Lambda )(a a\Lambda ) = id
(a a\Lambda )(b b\Lambda ) = ((a a\Lambda )b (a a\Lambda )b\Lambda  )(a a\Lambda )

where the atoms (a a\Lambda )b and (a a\Lambda )b\Lambda  are defined as in Eq. (25). It follows that if --X-- is a set equippedwith swapping operations satisfying Eqs. (22)-(24), then these operations extend uniquely to an action

of all finite permutations on elements of --X--. If --X-- also satisfies property (ii) of Definition 1, then thisaction extends uniquely to all (kind-respecting) permutations, finite or not; and the elements of --

X-- havethe finite support property for this action in the sense of [17, Definition 3.3]. These observations form the

basis of a proof that the category Nom of Definition 1 is equivalent to the Schanuel topos [17, Section 7],which underlies the universe of FM-sets used in [17].

It is not hard to see that products X OE Y in the category Nom are given simply by taking the cartesianproduct -

(x, y) -- x \Psi  --X-- \Omega  y \Psi  --Y --"" of underlying sets and defining the swapping operations compo-nentwise:

(a a\Lambda )u*XOEY (x, y)\Delta ((a a\Lambda )u*Xx, (a a\Lambda )u*Y y)
(Clearly (x, y) has the finiteness property in X OE Y required by Definition 1(ii), because x has it in
X and y has it in Y .) Similarly, the terminal object 1 in Nom has a one-element underlying set and(necessarily) trivial swapping operations.

So we can interpret many-sorted first-order signatures in the category Nom: sorts S are interpretedas objects [[

S]]; function symbols f , of arity S1, . . . , Sn -\Phi  S say, as morphisms [[f ]] : [[S1]] OE u* u* u* OE[[
Sn]] -\Phi  [[S]]; and relation symbols R, of arity S1, . . . , Sn say, as subobjects of [[S1]] OE u* u* u* OE [[Sn]].Indeed, Nom has sufficient properties to soundly interpret classical first-order logic with equality 2 using

the usual techniques of categorical logic - see [26] or [33, Section 5] for a brief overview. In fact, readersunfamiliar with such techniques need not become so just to understand the interpretation of first-order
logic in the category of nominal sets, since it is just like the usual Tarskian semantics of first-order logicin the category of sets (at the same time remaining within the world of equivariant properties). For it is
not hard to see that the subobjects of an object X in the category Nom are in bijection with the subsets
A ff --X-- of the underlying set that are equivariant, in the sense that (a a\Lambda )u*Xx \Psi  A whenever x \Psi  A, forany atoms

a, a\Lambda  (of the same kind). As we mentioned in Section 2, the collection of equivariant subsetsis closed under all the usual operations of first-order logic and contains equality. So it just remains to

explain the interpretation in Nom of the distinctive syntax of Nominal Logic - atoms, swapping andfreshness.

Definition 2. Here is the intended interpretation of atoms, swapping and freshness in the category ofnominal sets of Definition 1.
Atoms. A sort of atoms in a Nominal Logic signature is interpreted by a nominal set of atoms An (forsome

n \Psi  N), which by definition has underlying set --An-- = An and is equipped with the swappingoperations given by

2 And much more besides, since it is equivalent to the Schanuel topos, but that will not concern us here.

A.M. Pitts / Information and Computation 186 (2003) 165-193 175
(a a\Lambda )u*b\Delta  \Delta \Theta \Lambda 

a if b = a\Lambda 
a\Lambda  if b = a
b otherwise

(where b \Psi  An and a, a\Lambda  \Psi  Am for any m \Psi  N). We always assume that distinct sorts of atoms areinterpreted by distinct kinds of atoms. (So we are implicitly assuming that signatures contain at

most countably many such sorts.)Swapping. Note that by virtue of Eq. (24), the function

a, a\Lambda , x fi\Phi  (a a\Lambda )u*Xx determines a morphism
An OE An OE X -\Phi  X in the category Nom. This morphism is used to interpret the distinguishedfunction symbol

A, A, S -\Phi  S for swapping, assuming the nominal set of atoms An is the inter-pretation of the sort of atoms

A and that X is the interpretation of S. Thus[[

(a a\Lambda )u*s]] = ([[a]] [[a\Lambda ]])u*X[[s]] when s : S and [[S]] = X.
Freshness. The distinguished relation symbol # of arity A, S for freshness is interpreted as the `not inthe support of' relation

(-) /\Psi  suppX(-) between atoms and elements of nominal sets. Thus if thenominal set of atoms
An is the interpretation of the sort of atoms A and X is the interpretation ofthe sort
S, then for terms a : A, s : S, the formula a # s is satisfied by the interpretation if and onlyif [[
a]] /\Psi  suppX([[s]]), where suppX is as in Eq. (26). (It is not hard to see that this is an equivariantsubset of A

n OE --X-- and hence determines a subobject of [[A]] OE [[S]] in Nom.)

We turn next to an axiomatisation within first-order logic of properties of this nominal sets interpre-tation of atoms, swapping and freshness.

5. Nominal logic axioms

For simplicity, we will use a Hilbert-style presentation of Nominal Logic: a single rule of ModusPonens, the usual axiom schemes of first-order logic with equality, plus axiom schemes for swapping
and freshness. These latter are listed in Appendix A as (S1)-(S3), (E1)-(E4) and (F1)-(F4). (AppendixA also gives axioms for the freshness quantifier and atom-abstraction constructs that we consider in later
sections.) Axiom scheme (F4) expresses within our first-order language the very important principle thatthere is a sufficient supply of fresh atoms, in the sense that it is not finitely exhaustible. The other axioms
express rather anodyne properties of swapping and freshness. Indeed, the following results show thatthese axioms validate the properties of swapping given in Section 4 and the fundamental assumption
mentioned at the start of Section 2, namely that all properties expressible in Nominal Logic are invariantunder swapping atoms.

Proposition 1 (Equational properties of swapping). The equations in part (i) of Definition 1 are allprovable in Nominal Logic

.

Proof. Eqs. (22), (23) and (24) are just axioms (S1), (S2) and (E1) respectively. Eq. (25) correspondsto four properties (taking into account the fact that we allow more than one sort of atoms):

(\Pi a, a\Lambda  : A) (a a\Lambda )u*a = a\Lambda  (28)
(\Pi a, a\Lambda  : A) (a a\Lambda )u*a\Lambda  = a (29)

176 A.M. Pitts / Information and Computation 186 (2003) 165-193

(\Pi a, a\Lambda , b : A) ~b = a \Omega  ~b = a\Lambda  \Sigma  (a a\Lambda )u*b = b (30)
(\Pi a, a\Lambda  : A)(\Pi b : A\Lambda ) (a a\Lambda )u*b = b (31)
where A and A\Lambda  are different sorts of atoms. Property (28) is just axiom (S3); applying (a a\Lambda )u*(-) toboth sides of Eq. in (28) and using axiom (S2), we obtain (29). Property (30) follows from axioms (F1)

and (F2); and property (31) from (F1) and (F3). \Theta 
Proposition 2 (Equivariance). For each term t and formula \Lambda , with free variables amongst flx : flS say, wehave

(\Pi a, a\Lambda  : A)(\Pi flx : flS) (a a\Lambda )u*t (flx) = t ((a a\Lambda )u*flx) (32)
(\Pi a, a\Lambda  : A)(\Pi flx : flS) \Lambda (flx) ffi \Lambda ((a a\Lambda )u*flx) (33)
where t ((a a\Lambda )u*flx) denotes the result of simultaneously substituting (a a\Lambda )u*xi for xi in t (as xi ranges overfl
x) and similarly for \Lambda ((a a\Lambda )u*flx).

Proof. Property (32) follows from axioms (E1) and (E3), by induction on the structure of the term t.For (33) we proceed by induction on the structure of the formula

\Lambda , using standard properties of first-order logic for the induction steps for connectives and quantifiers. Note that by virtue of axiom (S2),

Eq. (33) holds if and only if

(\Pi a, a\Lambda  : A)(\Pi flx : flS) \Lambda (flx) \Sigma  \Lambda ((a a\Lambda )u*flx) (34)
does. So the base case when \Lambda  is equality follows from the usual axioms for equality, the base casefor the freshness predicate # follows from axiom (E2), and that for relation symbols from axiom (E4)

(using (32) in each case). \Theta 
Theorem 1 (Soundness). The axioms of Nominal Logic (see Appendix A) are all satisfied by the nominalsets interpretation of atoms

, swapping and freshness given in Definition 2.

(At the moment we are only considering the axioms (S1)-(S3), (E1)-(E4) and (F1)-(F4) of AppendixA, but the proposition remains true for the nominal sets interpretation of the freshness quantifier and
atom-abstraction given below.)
Proof. Satisfaction of axioms (S1)-(S3) and (E1) is guaranteed by part (i) of Definition 1 (since theswapping action for a nominal set of atoms is given by Eq. (25)). Satisfaction of axioms (E2) and (F1)-
(F3) is a simple consequence of the definition of support in Eq. (26). Axioms (E3) and (E4) are satisfiedbecause function and relation symbols are interpreted by morphisms and subobjects in the category
of nominal sets, which have these equivariance properties. Finally, axiom (F4) is satisfied because thesupport of an element of a nominal set is a finite subset of the fixed, countably infinite set A of all
atoms. \Theta 

Did we forget any axioms? In other words are the axiom schemes in Appendix A complete for theintended interpretation in the category of nominal sets? Axiom (F4) says that there is an inexhaustible
supply of atoms that are fresh, i.e., not in the support of elements in the current context. This is certainlya consequence of property (ii) of Definition 1, which guarantees that elements of nominal sets have finite

A.M. Pitts / Information and Computation 186 (2003) 165-193 177
support. However, that property is ostensibly a statement of weak second order logic, since it quantifiesover finite sets of atoms. So we should not expect Nominal Logic, a first-order theory, to completely
axiomatise the notion of finite support. Example 4 confirms this expectation. Before giving it we state auseful property of freshness in Nominal Logic that we need below.

Proposition 3. For any term t, with variables amongst the list of distinct variables flx : flS say, we have

(\Pi a : A)(\Pi flx : flS) a # flx \Sigma  a # t (flx) (35)
where we write a # flx for the finite conjunction of the formulas a # xi as xi ranges over flx.

Proof. Given any a : A and flx : flS, by axiom (F4) there is some a\Lambda  : A with a\Lambda  # flx and a\Lambda  # t (flx). So if
a # flx, then by axiom (F1) (a a\Lambda )u*xi = xi holds for each xi. So since a\Lambda  # t (flx) by choice of a\Lambda , we have

a = (a a\Lambda )u*a\Lambda  by axioms (S2) and (S3)#

(a a\Lambda )u*t (flx) by axiom (E2)=

t ((a a\Lambda )u*flx) by (32)=
t (flx) by axiom (F1)

as required. \Theta 

Corollary 1. If a Nominal Logic theory contains a closed term t : A (i.e. one with no variables3) with
A a sort of atoms, then it is an inconsistent theory.

Proof. Suppose that A is a sort of atoms and that t : A is a term with no variables. By the aboveproposition we have

(\Pi a : A) a # t. Thus t # t and by axiom (F2) this means ~ t = t , contradiction. \Theta 

Example 4 (Incompleteness). Consider the following Nominal Logic theory.Sort of atoms:

ASorts of data:
D, NFunction symbols:

o : N

s : N -\Phi  N
f : D, N -\Phi  AAxioms:
(\Pi x : N ) ~ o = s(x)
(\Pi x, x\Lambda  : N ) s(x) = s(x\Lambda ) \Sigma  x = x\Lambda 

Claim. Any model of this theory in the category of nominal sets satisfies the formula

(\Pi y : D)(fflx, x\Lambda  : N ) ~ x = x\Lambda  \Omega  f (y, x) = f (y, x\Lambda ) (36)
but that formula cannot be proved in Nominal Logic from the axioms of the theory.

Proof of claim. Note that in any model of this theory in the category Nom, the interpretation of theclosed terms

nk : N (k \Psi  N) defined by\Pi 

n0 \Delta o
nk+1 \Delta s(nk)

3 Since the syntax of Nominal Logic does not contain any binding constructs at the level of terms, all occurrences of variables
in terms are free ones.

178 A.M. Pitts / Information and Computation 186 (2003) 165-193
are distinct elements [[nk]] \Psi  --[[N ]]-- of the nominal set [[N ]]. Therefore, to see that (36) is satisfied bythe model it suffices to show for each

d \Psi  --[[D]]-- that [[f ]]([[nk1]], d) = [[f ]]([[nk2]], d) \Psi  --[[A]]-- holds forsome
k1 \Xi = k2 \Psi  N. Note that [[A]] is a nominal set of atoms, An say. Suppose to the contrary that allthe [[
f ]]([[nk]], d) are distinct atoms in An. Then since the support supp[[D]](d) of d \Psi  --[[D]]-- is a finitesubset of A, we can find

k1 \Xi = k2 \Psi  N so that

a1\Delta [[f ]]([[nk1]], d) and a2\Delta [[f ]]([[nk2]], d)
satisfy a1, a2 /\Psi  supp[[D]](d). We also have a1, a2 /\Psi  supp[[N]](nk) for all k (using (35) and the fact thatthe terms

nk are closed). Hence a1, a2 /\Psi  suppAn([[f ]]([[nk]]), d) and thus (a1 a2)u*An[[f ]]([[nk]], d) =[[
f ]]([[nk]], d), for all k \Psi  N. Taking k = k1 and recalling the definition of a1 and a2, we conclude that[[

f ]]([[nk2]], d) = a2 = (a1 a2)u*Ana1 = (a1 a2)u*An[[f ]]([[nk1]], d) = [[f ]]([[nk1]], d)
with k1 \Xi = k2, contradicting our assumption that all the [[f ]]([[nk]], d) are distinct.To see that (36) is not provable in Nominal Logic it suffices to find a model, in the usual sense of firstorder logic, for the general axioms of Nominal Logic and the particular axioms of this theory which doesnot satisfy (36). We can get such a model by modifying Definition 1 and using an uncountable set of
atoms and sets equipped with swapping actions all of whose elements have countable support. More con-cretely, we get a model

M by taking [[A]]M to be an uncountable set, the set R of real numbers say; taking[[
N ]]M to be a countable subset of this set, the set N of natural numbers say; and taking [[D]]M to be theset RN of all functions from N to R (all such functions are countably supported). Define the interpretation

of the function symbols o, s and f to be respectively zero, successor (n fi\Phi  n + 1) and the evaluationfunction RN OE N -\Phi  R (

d, n fi\Phi  d(n)). The interpretation of the swapping operation for sort A is as inEq. (25) (i.e.,
(r r\Lambda )u*Rr\Lambda \Lambda  = (r r\Lambda )r\Lambda \Lambda  for all r, r\Lambda , r\Lambda \Lambda  \Psi  R); for sort N , swapping is trivial (i.e., (r r\Lambda )u*Nn = nfor all
r, r\Lambda  \Psi  R and n \Psi  N); and for sort D, it is given by (r r\Lambda )u*RN d = \Theta n \Psi  N.(r r\Lambda )u*Rd(n). The inter-pretation of the freshness predicate for sort

A is \Xi =; for sort N , it is trivial (i.e., r # n holds for all r \Psi  Rand
n \Psi  N); and for sort D, r # d holds if and only if r \Xi = d(n) for all n \Psi  N. With these definitions onecan check that all the axioms are satisfied. However (36) is not satisfied, because the inclusion of N into

R gives an element d \Psi  RN = [[D]]M for which n fi\Phi  [[f ]]M (d, n) is injective. \Theta 

Even though there is this incompleteness, it appears that the axioms of Nominal Logic are sufficientfor a useful theory of names and name-binding along the lines of [17,13]. Sections 6 and 7 give some
evidence for this claim. We leave to another occasion the investigation of whether the notion of `nominalset' can be generalised to provide a completeness result for Nominal Logic.

6. The freshness quantifier

In this section we extend the Nominal Logic we have considered so far with a quantifier for freshatoms. We begin by proving, within the version of Nominal Logic considered so far, the characteristic
`some/any' property of fresh atoms noted in [17, Proposition 4.10].
Proposition 4. Suppose \Lambda  is a formula with free variables among the list of distinct variables a : A, flx : flS(with

A a sort of atoms). Then

(ffla : A) a # flx \Omega  \Lambda (a, flx) ffi (\Pi a : A) a # flx \Sigma  \Lambda (a, flx) (37)
is provable in Nominal Logic.

A.M. Pitts / Information and Computation 186 (2003) 165-193 179
Proof. If \Lambda (a, flx) holds, then by Proposition 2 and axiom (S3) we also have \Lambda (a\Lambda , (a a\Lambda )u*flx); so if a # flxand

a\Lambda  # flx, then axiom (F1) gives \Lambda (a\Lambda , flx). Thus we have the left-to-right implication in (37).Conversely suppose

(\Pi a : A) a # flx \Sigma  \Lambda (a, flx) holds. For any flx : flS, using axiom (F4) we can find
a : A such that a # flx and hence by the assumption, also satisfying \Lambda (a, flx). \Theta 

This property of freshness crops up frequently in proofs about syntax with named bound variables(see [28] for example): we choose some fresh name with a certain property and later on, in a wider
context, we have to revise the choice to accommodate finitely many more constraints and so need toknow that we could have chosen any fresh name with that property. For this reason it is convenient to
introduce a notation that tells us we have this `some/any' property without mentioning the context offree variables fl

x explicitly. (Note that (37) holds for any list flx of distinct variables, so long as it containsthe free variables of

\Lambda  other than the atom a being quantified over.)

Definition 3 ( N-quantifier). We extend the syntax of formulas with a new variable-binding operationwhich takes a formula

\Lambda , a sort of atoms A and a variable a of that sort and produces a formula ( Na : A)\Lambda whose free variables are those of

\Lambda  except a. We add the following axiom scheme that defines this newquantifier within first-order logic in terms of the freshness relation #:

(( Na : A)\Lambda (a, flx)) ffi (ffla : A)a # flx \Omega  \Lambda (a, flx) (Q)
where a, flx is a list of distinct variables containing the free variables of \Lambda . In view of Proposition 4 wealso have

(( Na : A)\Lambda (a, flx)) ffi (\Pi a : A) a # flx \Sigma  \Lambda (a, flx)
and could have used this as the axiom defining N.

Remark 2. Because of the form of axiom (Q), it is easy to see that the equivariance property (33) ofProposition 2 continues to hold for formulas involving the

Nquantifier.

Evidence for the naturalness of the N-quantifier is provided by the fact that, in the nominal setssemantics given in Section 3, it coincides with a cofiniteness quantifier. For, using the right-hand side of
axiom (Q) to give the semantics of ( Na : A) \Lambda  in the category of nominal sets, we find that it holds if andonly if

\Lambda (a) holds for all but finitely many atoms a. See [13] for the proof of this and the developmentof the properties and applications of the

N-quantifier within the setting of FM-set theory.

Example 5 (\Delta , \Sigma  and \Upsilon  equivalence, version 2). We can re-express some of the axioms considered inExample 3 using the

N-quantifier. For the \Delta -conversion axiom (15), note that modulo the axioms ofNominal Logic it is equivalent to

(\Pi a : Var)(\Pi t : Term)(\Pi a\Lambda  : Var) a\Lambda  \Xi = a \Omega  a\Lambda  # t \Sigma  lam(a, t ) = lam(a\Lambda , (a a\Lambda )u*t ).
So by Proposition 4, we can instead use the axiom

(\Pi a : Var)(\Pi t : Term)( Na\Lambda  : Var) lam(a, t) = lam(a\Lambda , (a a\Lambda )u*t) (38)
Similarly, using Nwe can re-express the \Upsilon -conversion axiom (16) as

(\Pi t : Term)( Na : Var) t = lam(a, app(t, var(a))) (39)

180 A.M. Pitts / Information and Computation 186 (2003) 165-193
Finally, note that the last clause in the axiomatisation of capture-avoiding substitution, axiom (21), couldbe expressed as

(\Pi t, t\Lambda  : Term)(\Pi a : Var)( Na\Lambda  : Var) subst(t, a, lam(a\Lambda , t\Lambda ))=

lam(a\Lambda , subst(t, a, t\Lambda )) (40)

Remark 3 (Alternative axiomatisations of N). It follows immediately from Definition 3 and Proposition 4that the

N-quantifier satisfies

((\Pi a : A) a # flx \Sigma  \Lambda (a, flx)) \Sigma  ( Na : A)\Lambda (a, flx) (41)
and

(( Na : A)\Lambda (a, flx)) \Sigma  (ffla : A) a # flx \Omega  \Lambda (a, flx) (42)
when a, flx is a list of distinct variables containing the free variables of \Lambda . In fact these formulas providean alternative axiomatisation of the

N-quantifier which subsumes the crucial axiom (F4) asserting asufficient supply of fresh atoms. For modulo the other axioms, one can prove (F4) \Omega  (Q) ffi (41) \Omega  (42).

We chose the presentation in terms of axioms (F4) and (Q) because the former is a principle one usescontinually when reasoning with freshness in this setting and the latter makes it clear that we remain
within the realm of first order logic when we use the N-quantifier in Nominal Logic.Properties (41) and (42) suggest how to formulate introduction and elimination rules for the

N-quan-tifier within a natural deduction formulation of Nominal Logic:

\Phi , a # flx \Upsilon  \Lambda 
\Phi  \Upsilon  ( Na : A)\Lambda  ( N-intro)

\Phi  \Upsilon  ( Na : A)\Lambda  \Phi , a # flx, \Lambda  \Upsilon  \Psi 

\Phi  \Upsilon  \Psi  ( N-elim)

where fv(\Phi ) ff flx and fv(\Lambda ) ff a, flx. Similarly, they suggest how to formulate right and left rules for thequantifier in a sequent calculus formulation:

\Phi , a # flx \Upsilon  \Lambda , \Omega 
\Phi  \Upsilon  ( Na : A)\Lambda , \Omega  ( N-right)

\Phi , a # flx, \Lambda  \Upsilon  \Omega 
\Phi , ( Na : A)\Lambda  \Upsilon  \Omega  ( N-left)

where fv(\Phi , \Omega ) ff flx and fv(\Lambda ) ff a, flx. The proof theoretical properties of these formulations have yetto be explored. (However, see [4] for a sequent calculus admitting cut-elimination for a modal process

logic involving the N-quantifier, in which freshness predicates like a # x appear as side-conditions ratherthan as formulas in sequents.)

7. Binding

In this section we extend the Nominal Logic we have considered so far to deal with variable-bindingoperations in a more uniform way. To motivate this, consider Example 3 once again, where the fact that

A.M. Pitts / Information and Computation 186 (2003) 165-193 181
lam is a variable-binding operation is captured by axiom (15). Instead of axiomatising the propertiesof such binders on a theory-by-theory basis, we endow the underlying logic, Nominal Logic, with sortand term-forming operations for atom-abstraction, together with appropriate axioms. This is analogousto enriching our term language with lambda-abstraction and application in order to use functionals to
represent binding operations a` la higher-order abstract syntax [32]. However, an interesting differencehere is that we are able to keep within first-order logic: atom-abstractions are merely a definitional
extension within first-order logic of what we have considered so far (see Remark 4 below).
Definition 4 (Atom-abstraction). Extend the syntax of sorts by adding a sort-forming operation that takesa sort of atoms

A and a sort S and produces a new sort [A]S, called the sort of A-atom-abstractions ofelements of sort

S. Extend the syntax of terms with a new operation that takes terms t1 : A, t2 : S andproduces a term

t1.t2 : [A]S. The properties of these new terms are described by the following axiomschemes.

(\Pi b, b\Lambda  : A\Lambda )(\Pi a : A)(\Pi x : S) (b b\Lambda )u*(a.x) = ((b b\Lambda )u*a).((b b\Lambda )u*x) (E5)
(\Pi a, a\Lambda  : A)(\Pi x, x\Lambda  : S) a.x = a\Lambda .x\Lambda  ffi (a = a\Lambda  \Omega  x = x\Lambda ) i (a\Lambda  # x \Omega  x\Lambda  = (a a\Lambda )u*x) (A1)
(\Pi y : [A]S)(ffla : A)(fflx : S) y = a.x (A2)
Axiom (E5) ensures that the equivariance properties of Proposition 2 (and hence also the freshnessproperty of Proposition 3) continue to hold for the extended syntax. Axiom (A2) just tells us that

everything of atom-abstraction sort is an atom-abstraction. The crucial axiom is (A1), which capturesan essence of

\Delta -equivalence in terms of Nominal Logic's primitives of atom-swapping and freshness.Should not we have added axioms that explain when an atom is fresh for an atom-abstraction, to

complement axioms (F1)-(F4)? In fact the following proposition shows that the freshness propertiesof atom-abstractions we expect from [17, Section 5] turn out to be derivable without further axioms.
Thus with these additions we have completed the definition of Nominal Logic, which is summarised inAppendix A.

Proposition 5. The following formulas are provable in Nominal Logic

(\Pi a, a\Lambda  : A)(\Pi x : S) a\Lambda  # a.x ffi (a\Lambda  = a i a\Lambda  # x) (43)
(\Pi a : A)(\Pi a\Lambda  : A\Lambda )(\Pi x : S) a\Lambda  # a.x ffi a\Lambda  # x (44)
where in the second formula A and A\Lambda  are distinct sorts of atoms.

Proof. In view of axioms (F2) and (F3), it suffices to prove

(\Pi a : A)(\Pi x : S) a # a.x (45)
(\Pi a : A)(\Pi a\Lambda  : A\Lambda )(\Pi x : S) a\Lambda  # x \Sigma  a\Lambda  # a.x (46)
(\Pi a : A)(\Pi a\Lambda  : A\Lambda )(\Pi x : S) a\Lambda  # a \Omega  a\Lambda  # a.x \Sigma  a\Lambda  # x (47)

for all sorts of atoms A and A\Lambda  (possibly equal).For (45), given

a : A and x : S, by axiom (F4) we can find a\Lambda  : A with a\Lambda  # a.x and hence

182 A.M. Pitts / Information and Computation 186 (2003) 165-193

a = (a a\Lambda )u*a\Lambda  by axioms (S2) and (S3)#

(a a\Lambda )u*(a.x) by axiom (E2) on a\Lambda  # a.x=

a\Lambda .((a a\Lambda )u*x) by axioms (E5) and (S3)=
a.x by axiom (A1).

For (46), given a : A, a\Lambda  : A\Lambda  and x : S with a\Lambda  # x, we argue by cases according to whether A and A\Lambda are the same and whether

a\Lambda  = a or not. If the sorts are the same and a\Lambda  = a, then we have a\Lambda  # a.x by(45); in the other three cases we always have

a\Lambda  # a (using axioms (F2) and (F3)); so since a\Lambda  # a and
a\Lambda  # x, we have a\Lambda  # a.x by Proposition 3 (which holds for the extended syntax by virtue of axiom (E5)).For (47), given

a : A, a\Lambda  : A\Lambda  and x : S with a\Lambda  # a and a\Lambda  # a.x, by axiom (F4) we can find a\Lambda \Lambda  : A\Lambda with
a\Lambda \Lambda  # a, a\Lambda \Lambda  # x and a\Lambda \Lambda  # a.x. Then

a.x = (a\Lambda  a\Lambda \Lambda )u*a.x by axiom (F1)=

((a\Lambda  a\Lambda \Lambda )u*a).(a\Lambda  a\Lambda \Lambda )u*x) by axiom (E5)=
a.((a\Lambda  a\Lambda \Lambda )u*x) by axiom (F1)

and hence x = (a\Lambda  a\Lambda \Lambda )u*x by axiom (A1). Since a\Lambda \Lambda  # x, we get a\Lambda  = (a\Lambda  a\Lambda \Lambda )u*a\Lambda \Lambda  # (a\Lambda  a\Lambda \Lambda )u*x = x, as re-quired. \Theta 

The intended interpretation of atom-abstraction is given by the following construction on nominalsets.

Definition 5 (Nominal set of atom-abstractions). Given a nominal set X and a nominal set of atoms An(cf. Definition 2), the nominal set of atom-abstractions [

An]X is defined as follows.Underlying set --[
An]X-- is the set of equivalence classes for the equivalence relation on An OE --X-- thatrelates
(a, x) and (a\Lambda , x\Lambda ) if and only if (a a\Lambda \Lambda )u*Xx = (a\Lambda  a\Lambda \Lambda )u*Xx\Lambda  for some (or indeed any) a\Lambda \Lambda  \Psi  Ansuch that

a\Lambda \Lambda  /\Psi  suppX(x) j suppX(x\Lambda ) j -a, a\Lambda "". We write a.x for the equivalence class of the pair
(a, x).Swapping action is inherited from that for the product

An OE X:

(b b\Lambda )u*[An]X(a.x) \Delta  a\Lambda .x\Lambda , where a\Lambda  = (b b\Lambda )a and x\Lambda  = (b b\Lambda )u*Xx.
With these definitions one can check that the requirements of Definition 1 are satisfied; in particular thesupport of

a.x turns out to be the finite set suppX(x) - -a"" (cf. Proposition 5).

Thus if a sort of atoms A gets interpreted as a nominal set of atoms [[A]] and a sort S gets interpretedas a nominal set [[

S]], then the sort [A]S is interpreted as the nominal set of atom-abstractions [[[A]]][[S]].Similarly if
t1 : A and t2 : S, then [[t1.t2]] = [[t1]].[[t2]] \Psi  [[[A]]][[S]]. With these definitions, the sound-ness result of Theorem 1 continues to hold. To prove this one needs the following, more symmetric

characterisation in Nominal Logic of equality of atom-abstractions; it matches the definition of theequivalence relation used to define --[

An]X-- from An OE --X-- in Definition 5 (see also the definition of \Theta \Delta in Example 1).

Proposition 6. If A is a sort of atoms and S is any sort, then the following formula is provable inNominal Logic

.

(\Pi a, a\Lambda  : A)(\Pi x, x\Lambda  : S) a.x = a\Lambda .x\Lambda  ffi ( Na\Lambda \Lambda  : A) (a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda  (48)

A.M. Pitts / Information and Computation 186 (2003) 165-193 183
Proof. First suppose a.x = a\Lambda .x\Lambda  holds. By axiom (Q), to prove ( Na\Lambda \Lambda  : A) (a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda  wehave to find some

a\Lambda \Lambda  # a, a\Lambda , x, x\Lambda  such that (a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda . By axiom (F4), we can certainly find
a\Lambda \Lambda  satisfying a\Lambda \Lambda  # a, a\Lambda , x, x\Lambda . If in addition we have a = a\Lambda , then by axiom (A1) we also have x = x\Lambda and we are done. So suppose

a \Xi = a\Lambda , in which case by axiom (A1) we also have a\Lambda  # x and x\Lambda  = (a a\Lambda )u*x.Hence

(a\Lambda  a\Lambda \Lambda )u*x\Lambda  = (a\Lambda  a\Lambda \Lambda )u*(a a\Lambda )u*x=

((a\Lambda  a\Lambda \Lambda )u*a (a\Lambda  a\Lambda \Lambda )u*a\Lambda )u*(a\Lambda  a\Lambda \Lambda )u*x by axiom (E1)=
(a a\Lambda \Lambda )u*(a\Lambda  a\Lambda \Lambda )u*x by Proposition 1=
(a a\Lambda \Lambda )u*x by axiom (F1)

as required.Conversely, if

( Na\Lambda \Lambda  : A) (a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda  does hold, then by axiom (Q) there is some a\Lambda \Lambda  with
a\Lambda \Lambda  # a, a\Lambda , x, x\Lambda  and

(a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda  (49)
If a = a\Lambda , then applying (a a\Lambda \Lambda )u*(-) to both sides of (49), by axiom (S2) we get

x = (a a\Lambda \Lambda )u*(a a\Lambda \Lambda )u*x = (a a\Lambda \Lambda )u*(a a\Lambda \Lambda )u*x\Lambda  = x\Lambda 
and hence a.x = a\Lambda .x\Lambda . So suppose a \Xi = a\Lambda . Applying (a\Lambda  a\Lambda \Lambda )u*(-) to a\Lambda \Lambda  # x\Lambda , by axioms (E2) and (S3) weget

a\Lambda  # (a\Lambda  a\Lambda \Lambda )u*x\Lambda  and hence by (49) that a\Lambda  # (a a\Lambda \Lambda )u*x. Hence

a\Lambda  = (a a\Lambda \Lambda )u*a\Lambda  by Proposition 1#

(a a\Lambda \Lambda )u*(a a\Lambda \Lambda )u*x by axiom (E2)=

x by axiom (S2).

and then also

x\Lambda  = (a\Lambda  a\Lambda \Lambda )u*(a\Lambda  a\Lambda \Lambda )u*x\Lambda  by axiom (S2)=

(a\Lambda  a\Lambda \Lambda )u*(a a\Lambda \Lambda )u*x by (49)=
((a\Lambda  a\Lambda \Lambda )u*a (a\Lambda  a\Lambda \Lambda )u*a\Lambda \Lambda )u*(a\Lambda  a\Lambda \Lambda )u*x by axiom (E1)=
(a a\Lambda )u*(a\Lambda  a\Lambda \Lambda )u*x by Proposition 1=
(a a\Lambda )u*x by axiom (F1).

Thus a.x = a\Lambda .x\Lambda  by axiom (Q). \Theta 

The construction in Definition 5 is used in [13,17] to treat, within the Fraenkel-Mostowski permuta-tion model of set theory, sets of parse trees modulo

\Delta -equivalence as inductively defined sets with usefulassociated structural induction/recursion principles. For example, [17, Theorem 6.2] shows that the set

of \Delta -equivalence classes of \Theta -terms (Example 1) has an inductive characterisation as the least nominalset satisfying

X = A + (X OE X) + [A]X (50)
(where A is a nominal set of atoms, + indicates disjoint union and OE cartesian product). From this wecan derive a theory in Nominal Logic for

\Theta -terms modulo \Delta -equivalence, in much the same way as theinductive description of the natural numbers (namely, the least set

X such that X = 1 + X) can lead toPeano's axioms for arithmetic.

Example 6 (Nominal theory of \Theta -terms modulo \Delta -equivalence). The signature of this theory has a sortof atoms Var, a sort of data Term, function symbols

184 A.M. Pitts / Information and Computation 186 (2003) 165-193

var : Var -\Phi  Termapp : Term

, Term -\Phi  Termlam : [Var]Term -\Phi  Term

and the following axioms.

(\Pi a : Var)(\Pi t, t\Lambda  : Term) ~ var(a) = app(t, t \Lambda ) (51)

(\Pi a : Var)(\Pi s : [Var]Term) ~ var(a) = lam(s) (52)
(\Pi s : [Var]Term)(\Pi t, t\Lambda  : Term) ~ lam(s) = app(t, t \Lambda ) (53)

(\Pi t : Term) (ffla : Var) t = var(a)i

(fflt\Lambda , t \Lambda \Lambda  : Term) t = app(t \Lambda , t\Lambda \Lambda ) (54)i
(ffls : [Var]Term) t = lam(s)

(\Pi a, a\Lambda  : Var) var(a) = var(a\Lambda ) \Sigma  a = a\Lambda  (55)
(\Pi t, t\Lambda , t \Lambda \Lambda , t\Lambda \Lambda \Lambda  : Term) app(t, t \Lambda ) = app(t\Lambda \Lambda , t\Lambda \Lambda \Lambda ) \Sigma  t = t\Lambda \Lambda  \Omega  t\Lambda  = t\Lambda \Lambda \Lambda  (56)
(\Pi s, s\Lambda  : [Var]Term) lam(s) = lam(s\Lambda ) \Sigma  s = s\Lambda  (57)
(\Pi flx : flS)(\Pi a : Var) \Lambda (var(a), flx)\Omega 

(\Pi t, t\Lambda  : Term) \Lambda (t, flx) \Omega  \Lambda (t \Lambda , flx) \Sigma  \Lambda (app(t, t\Lambda ), flx)\Omega 
( Na : Var)(\Pi t : Term) \Lambda (t, flx) \Sigma  \Lambda (lam(a.t ), flx)\Sigma 

(\Pi t : Term) \Lambda (t, flx)

(58)

Axioms (51)-(57) just state that there is a bijection (induced by var, app and lam) between Term andthe disjoint union of Var, Term OE Term and [Var]Term. The interesting axiom is the last one, (58). It is
an induction principle reflecting the initiality of (50) (cf. [17, Theorem 6.8]), much as Peano's inductionaxiom reflects the initiality of the set of natural numbers.

To illustrate the use of axiom (58) consider adding to the theory a relation symbol Subst or arityTerm

, Var, Term, Term and the following axiom.

Subst(t, a, t\Lambda , t\Lambda \Lambda ) ffi

t\Lambda  = var(a) \Omega  t \Lambda \Lambda  = ti

(ffla\Lambda  : Var) t\Lambda  = var(a\Lambda ) \Omega  ~a\Lambda  = a \Omega  t\Lambda \Lambda  = var(a\Lambda )i
(fflt \Lambda 1, t\Lambda \Lambda 1 , t\Lambda 2, t \Lambda \Lambda 2 : Term) t \Lambda  = app(t\Lambda 1, t \Lambda 2) \Omega  t\Lambda \Lambda  = app(t\Lambda \Lambda 1 , t \Lambda \Lambda 2 )\Omega  Subst

(t, a, t \Lambda 1, t\Lambda \Lambda 1 ) \Omega  Subst(t, a, t\Lambda 2, t\Lambda \Lambda 2 )i
(ffla\Lambda  : Var)(fflt\Lambda 1, t\Lambda \Lambda 1 : Term) t \Lambda  = lam(a\Lambda .t\Lambda 1) \Omega  t\Lambda \Lambda  = lam(a\Lambda .t\Lambda \Lambda 1 )\Omega 

a\Lambda  # t \Omega  Subst(t, a, t\Lambda 1, t\Lambda \Lambda 1 )

(59)

The intention is that Subst is the graph of the capture-avoiding substitution function. The reason forformulating this with a relation symbol rather than a function symbol (as we did in Example 3) is to
allow us to state that Subst is indeed the graph of a total function

(\Pi t, t\Lambda  : Term)(\Pi a : Var)(ffl!t\Lambda \Lambda  : Term) Subst(t, a, t \Lambda , t\Lambda \Lambda ) (60)
even though axiom (59) only specifies the result of substitution under a \Theta -binder when the bound variable
a\Lambda  is sufficiently fresh (i.e., when a\Lambda  # t holds). Indeed, in the presence of the other axioms, (60) follows

A.M. Pitts / Information and Computation 186 (2003) 165-193 185
by applying the structural induction principle (58) to prove (\Pi t\Lambda  : Term)\Lambda (t\Lambda , t, a) where \Lambda (t \Lambda , t, a) is
(ffl!t \Lambda \Lambda  : Term) Subst(t, a, t\Lambda , t\Lambda \Lambda ). We omit the details.

Remark 4 (Definability of atom-abstraction). Atom-abstraction sorts are convenient for expressing prop-erties of binding operations, but they do not represent an essential extension of the version of Nominal
Logic we presented in Section 5. The situation is analogous to the one for cartesian products, which aredefinable within ordinary first-order logic: given sorts

S1, S2 and S, there is a first-order theory in all ofwhose models the interpretation of
S is isomorphic to the cartesian product of the interpretations of S1and
S2. Indeed there are several such theories; for example, take a function symbol pair : S1, S2 -\Phi  Sand axioms

(\Pi x1, x\Lambda 1 : S1)(\Pi x2, x\Lambda 2 : S2) pair(x1, x2) = pair(x\Lambda 1, x\Lambda 2) \Sigma  (x1 = x\Lambda 1) \Omega  (x2 = x\Lambda 2) (61)
(\Pi x : S)(fflx1 : S1)(fflx2 : S2) x = pair(x1, x2) (62)
Within Nominal Logic there is a similar definability result for atom-abstraction sorts. Given sorts A, Sand

S\Lambda  (with A a sort of atoms), and a function symbol abs : A, S -\Phi  S\Lambda , the axioms

(\Pi a, a\Lambda  : A) (\Pi x, x\Lambda  : S) abs(a, x) = abs(a\Lambda , x\Lambda ) ffi

( Na\Lambda \Lambda  : A) (a a\Lambda \Lambda )u*x = (a\Lambda  a\Lambda \Lambda )u*x\Lambda  (63)

(\Pi x\Lambda  : S\Lambda )(ffla : A)(fflx : S) x\Lambda  = abs(a, x) (64)
ensure that in the semantics of Section 3, the interpretation of S\Lambda  is isomorphic to [An]X, where An and
X are the nominal sets interpreting A and S respectively.

The following result shows that atom-abstraction sorts [A]X have a dual nature: their elements a.xembody not only the notion of abstraction as a `(bound variable, body)-pair modulo renaming the bound
variable', but also the notion of abstraction as a function (albeit a partial one) from atoms to individuals(cf. Section 9).

Proposition 7. The following formula is provable in Nominal Logic.

(\Pi y : [A]S)(\Pi a : A) a # y \Sigma  (ffl!x : S) y = a.x (65)
(where ffl! means `there exists a unique . . .' and has the usual encoding in first-order logic).

Proof. The uniqueness part of (65) follows from

(\Pi a : A)(\Pi x, x\Lambda  : S) a.x = a.x\Lambda  \Sigma  x = x\Lambda 
which is a corollary of axioms (A1) and (S1). For the existence part of (65), note that by Proposition 4

(\Pi y : [A]S)(\Pi a : A) a # y \Sigma  (fflx : S) y = a.x
holds if and only if

(\Pi y : [A]S)(ffla : A) a # y \Omega  (fflx : S) y = a.x
and the latter follows from axiom (A2) and Proposition 5 (specifically, property (45)). \Theta 

186 A.M. Pitts / Information and Computation 186 (2003) 165-193
8. Choice

In informal arguments about syntax one often says things like `choose a fresh name such that . . . '.Axiom (F4) ensures that we can comply with such directives for Nominal Logic's formalisation of
freshness. But it is important to note that in nominal Logic such choices cannot be made uniformly inthe parameters: it is in general inconsistent with the other axioms to skolemize (F4) by adding function
symbols fresh : flS -\Phi  A satisfying (\Pi flx : flS) fresh(flx) # flx. Here is the simplest possible example of thisphenomenon.

Proposition 8. Suppose A is a sort of atoms. The formula

(\Pi a : A)(ffla\Lambda  : A) ~ a = a\Lambda  (66)
is a theorem of Nominal Logic. However, it is inconsistent to assume there is a function that, for eachatom

, picks out an atom different from it. In other words, the Nominal Logic theory with a functionsymbol

f : A -\Phi  A and the axiom

(\Pi a : A) ~ a = f (a) (67)
is inconsistent.

Proof. The formula (66) is an immediate consequence of axioms (F2) and (F4). For the second partwe show that

(ffla : A) a = f (a) is a theorem. First note that by axiom (F4) (with the empty list ofparameters fl
x), there is an atom a of sort A.4 We show that a = f (a). For any a\Lambda  : A, by Proposition 3we have
a\Lambda  # a \Sigma  a\Lambda  # f (a), i.e., (by axiom (F2)) ~ a\Lambda  = a \Sigma  ~ a\Lambda  = f (a), i.e., a\Lambda  = f (a) \Sigma  a\Lambda  = a.Taking
a\Lambda  to be f (a), we get f (a) = a. \Theta 

This phenomenon is a reflection of the fact that the category Nom of nominal sets fails to satisfythe Axiom of Choice (see [12] for a categorical treatment of choice), which in turn reflects the fact
that, by design, the Axiom of Choice fails to hold in the Fraenkel-Mostowski permutation model of settheory [25]. However, there is no problem with principles of unique choice (in contrast to the situation
for the Theory of Contexts [23], a close cousin of Nominal Logic). For example, if a Nominal Logictheory has a model in Nom satisfying the sentence

(\Pi flx : flS)(ffl!x\Lambda  : S\Lambda ) \Lambda (flx, x\Lambda ) (68)
then the theory extended by a function symbol f : flS -\Phi  S\Lambda  and axiom

(\Pi flx : flS) \Lambda (flx, f (flx)) (69)
can also be modelled in Nom (simply because in a cartesian category any subobject satisfying the prop-erties of a single-valued and total relation is the graph of some morphism). Unfortunately a far more

common situation than (68) is to have `conditional unique existence':

(\Pi flx : flS) ff(flx) \Sigma  (ffl!x\Lambda  : S\Lambda ) \Lambda (flx, x\Lambda ) (70)
so that \Lambda (flx, x\Lambda ) is the graph of a partial function with domain of definition containing those flx such that
ff(flx). We have already seen an example of this in Proposition 7. If the formula (70) is a theorem of aNominal Logic theory, adding a function symbol

f : flS -\Phi  S\Lambda  and axiom

4 The reader can deduce at this point that the author, being of a category-theoretic bent, is not assuming a formulation of
first-order logic that entails that all sorts are non-empty. Possibly empty sorts, like the empty set, have their uses!

A.M. Pitts / Information and Computation 186 (2003) 165-193 187
(\Pi flx : flS) ff(flx) \Sigma  \Lambda (flx, f (flx)) (71)
to the theory can result in inconsistency. This is because f represents a total function from flS to S\Lambda .Given terms fl

t : flS, even if ff(flt) does not hold and so (71) cannot be used to deduce properties of theterm
f (flt ) : S\Lambda , nevertheless one may be able to use results such as Proposition 3 to deduce properties of
f (flt) : S\Lambda  that lead to inconsistency, especially if S\Lambda  happens to be a sort of atoms. The simplest possibleexample of this phenomenon is when fl

S is the empty list of sorts and ff is false. In this case formula (70)is trivially a theorem; the skolemizing function

f is a constant of sort S\Lambda , so if that is a sort of atoms weget inconsistency by Corollary 1.

This difficulty with introducing notations for possibly partially defined expressions is masked in [16]by the untyped nature of FM-set theory.5 That work introduces, among other things, a term-former for
concretion of atom-abstractions at atoms, skolemizing the conditional unique existence formula (65) ofProposition 7. Terms involving concretion only have a definite meaning when certain preconditions are
met. Nevertheless they can be given a semantics as total elements of the universe of FM-sets simply bytaking their meaning when the preconditions are not met to be some default element with empty support
(the empty set, say). Such a `hack' is available to us in classical logic when there are enough terms ofempty support. One such term is enough in an untyped setting such as FM-set theory. In a many-sorted
Nominal Logic theory there is nothing to guarantee that a sort S possesses a term t : S of empty support(i.e., satisfying

(\Pi a : A) a # t for all sorts of atoms A); indeed Corollary 1 shows that sorts of atoms donot possess such terms in a consistent theory. To provide Nominal Logic with a richer term language,

incorporating such things as concretions of atom-abstractions at atoms and maybe more besides (suchas locally fresh atoms - see [17, Lemma 6.3] et seq), one may be able to adapt the work of Miller [30,
Section 6] on a sound treatment of skolemization in higher order logic without choice (see also [10,Section 7]). One might also consider merging Nominal Logic's novel treatment of atoms and freshness
with some conventional treatment of the logic of partial expressions (such as [2, Section VI.1] or [37]).We leave such considerations to the future and turn instead to a brief survey of existing work more
directly related to the concerns of this paper.

9. Related work

One can classify work on fully formal treatments of names and binding according to the mathematicalconstruct used to model the notion of abstraction:

* Abstractions as (name, term)-pairs. Here one tries to work directly with parse trees and the relationof

\Delta -equivalence between them; [28,38] are examples of work in this spirit. The drawback of thisapproach is not so much that many tedious details left implicit by informal practice become explicit,

but rather that many of these details have to be revisited on a case-by-case basis for each objectlanguage. The use of parse trees containing de Bruijn indices [7] is more elegant; but this has its own
complications and also side-steps the issue of formalising informal practice to do with named boundvariables.

5 It is also masked in the programming language FreshML sketched in [35], which has a richer term language than does
Nominal Logic; this is because FreshML features unrestricted fixed point recursion in order to be Turing powerful, and hence
naturally contains partially defined expressions.

188 A.M. Pitts / Information and Computation 186 (2003) 165-193

* Abstractions as functions from terms to terms. The desire to take care of the tedious details of \Delta -equiv-alence and substitution once and for all at the meta-level leads naturally to encodings of object-level

syntax in a typed \Theta -calculus modulo \Delta , \Sigma  (and \Upsilon ) equivalence. This is the approach of higher-orderabstract syntax (HOAS) [32], an idea dating back to Church and then Martin-Lo"f. It is well-supported
by existing systems for machine-assisted reasoning based on typed \Theta -calculus. It does not lend itselfvery easily to principles of structural recursion and induction for the encoded object-language, but
nevertheless such principles have been developed. For example, McDowell and Miller have developeda way of using Hallna"s' notion of partial inductive definitions [20] to enable inductive reasoning
about HOAS specifications in an intuitionistic higher-order logic [27]; and Despeyroux, Pfenning andSchu"rmann have developed a modal typed

\Theta -calculus that allows primitive recursive functions onHOAS-encoded object-language syntax without destroying the adequacy of the encoding [8,36].

* Abstractions as functions from names to terms. The Theory of Contexts [23] reconciles the elegance ofhigher-order abstract syntax with the desire to deal with names at the object-level and have relatively

simple forms of structural recursion/induction. It does so by axiomatising a suitable type of nameswithin classical higher order logic. The Theory of Contexts involves a `non-occurrence' predicate and
axioms quite similar to those for freshness in FM-set theory [17] and in the Nominal Logic presentedhere. However, `non-occurrence' in [23] is dependent upon the object language, whereas our notion
of freshness is a purely logical property, independent of any particular object syntax with binders.(The same remark applies to the axiomatisation of

\Delta -equivalence of \Theta -terms in higher order logicin [18]; and to the extension of first-order logic with binders studied in [9].) Furthermore, the use

of total functions on names to model abstraction means that the Theory of Contexts is incompatiblewith the Axiom of Unique Choice (cf. Section 8), forcing the theory to have a relational rather than
functional feel: see [29]. On the other hand, the Theory of Contexts is able to take advantage ofexisting machine-assisted infrastructure (namely Coq [6]) quite easily, whereas Gabbay had to work
hard to adapt the Isabelle [31] set theory package to produce his Isabelle/FM-sets package: see [13,Chapter III] and [15].
The notion of abstraction that is definable within Nominal Logic (see Section 7) captures somethingof the first and third approaches mentioned above: atom-abstractions are defined to be pairs in which
the name-component has been made anonymous via swapping; but we saw in Proposition 7 that atom-abstractions also behave like functions, albeit partial ones. Whatever the pros and cons of the various
views of name abstraction, at least one can say that, being first-order, Nominal Logic gives a moreelementary explanation of names and binding than much the work mentioned above; and a more fundamental one, I would claim, because of the independence of the notions of atoms, swapping, freshnessand atom-abstraction from any particular object-level syntax involving binders.

10. Conclusion

Nominal Logic gives a first-order axiomatisation of some of the key concepts of FM-set theory -atoms, swapping and freshness - which were used in [17] to model syntax modulo

\Delta -equivalence with in-ductively defined sets whose structural induction/recursion properties remain close to informal practice.

We have seen that, being first-order, Nominal Logic does not give a complete axiomatisation of thenotion of finite support that underlies the notion of freshness in FM-sets. Nevertheless, the first-order
properties of a notion of freshness of names presented in this paper seem sufficient to develop a use-ful theory, independent of any particular object-level language involving binders. Indeed, many of the

A.M. Pitts / Information and Computation 186 (2003) 165-193 189
axioms listed in Appendix A arose naturally in Gabbay's implementation of FM-set theory in the Isabellesystem [13,15] as the practically useful properties of finite support. Nominal Logic and the theories
we can formulate in it, are a vehicle for exhibiting those properties clearly. They are also a necessaryprecursor for the study of the computational properties of the logic of freshness: work is in progress on
a version of first-order logic programming extended with Nominal Logic's primitives of swapping andfreshness of atoms (cf. Hamana's logic programming language [21] based on the presheaf semantics of
binding in [11]).However, if one wants a single, expressive foundational theory in which to develop the mathematics
of syntax in the style of this paper, one can use FM-set theory (and its automated support within Isa-belle); or, as Gabbay argues in [14], a version of higher-order logic incorporating atoms, swapping and
freshness.Finally, even if one does not care about the details of Nominal Logic, I think that two simple, but
important ideas underlying it are worth taking on board for the practice of operational semantics (be itwith pencil-and-paper, or with machine assistance):

* Name-swapping (a b)u*(-) has much more convenient logical properties than renaming -b/a""(-).* The only assertions about syntax we should deal with are ones whose validity is invariant under

swapping bindable names.Even if one only takes the nai"ve view of abstractions as (name, term)-pairs, it seems useful to define
\Delta -equivalence and capture-avoiding substitution in terms of name-swapping and to take account of equi-variance in inductive arguments. We gave some illustrations of this in Section 2. A further example is
provided by the work of Caires and Cardelli on modal logic for the spatial structure of concurrent sys-tems [3,4]; this and the related work [5] make use of the freshness quantifier of Section 6. See also [22]
for the use of permutative renaming to treat naming aspects of process calculi.

Acknowledgments

This paper is a revised and expanded version of [34] and has benefitted from the comments of Rene'Vestergaard and the anonymous referees. The work described here draws upon joint work with Jamie
Gabbay [16,17,35] and was partly funded by UK EPSRC Grant GR/R07615. I also gratefully acknowl-edge conversations about FM-sets and Nominal Logic with members of the Cambridge Logic and Semantics Group, particularly Michael Norrish, Mark Shinwell and Christian Urban.

Appendix A: Syntax and axioms of nominal logic
A.1 Signatures and sorts

A nominal logic signature is specified by the following data.* A collection of ground sort symbols, partitioned into two kinds: sorts of atoms and sorts of data.

* A collection of function symbols, each equipped with an arity consisting of a list of argument sorts anda result sort (where the sorts over the signature are defined below); we write

f : flS -\Phi  S to indicatethat function symbol
f has argument sorts given by the list flS and result sort S.

190 A.M. Pitts / Information and Computation 186 (2003) 165-193

* A collection of relation symbols, each equipped with an arity consisting of a list of argument sorts;we write

R < : flS to indicate that relation symbol R has argument sorts given by the list flS.The sorts over a signature are built up by forming atom-abstraction sorts from the ground sort

symbols:

Sorts S ::= A sorts of atoms

D sorts of data[

A]S sorts of atom-abstractions

A.2 Terms and formulas

Given a nominal logic signature, we fix mutually disjoint, countably infinite sets of variable symbolsof each sort over the signature.
The terms over the signature are inductively defined as follows. Each well-formed term has a uniquesort; we write

t : S to indicate that t is a term of sort S.*
x : S, if x is a variable symbol of sort S.*
f (t1, . . . , tn) : S, if f : S1, . . . , Sn -\Phi  S and t1 : S1, . . . , tn : Sn.*
(t1 t2)u*t3 : S, if t1 : A, t2 : A and t3 : S, with A a sort of atoms and S any sort.*
t1.t2 : [A]S, if t1 : A and t2 : S, with A a sort of atoms.The formulas over the signature are inductively defined as follows.

* R(t1, . . . , tn) is a formula, if R < : S1, . . . , Sn and t1 : S1, . . . , tn : Sn.*

t1 = t2 is a formula, if t1 : S and t2 : S for some sort S.*
t1 # t2 is a formula, if t1 : A for some sort of atoms A and t2 : S for some sort S.* ~

\Lambda , fi \Omega  \Psi , fi i \Psi , fi \Sigma  \Psi  and fi ffi \Psi  are formulas, if \Lambda  and \Psi  are.*
(\Pi x : S)\Lambda  and (fflx : S)\Lambda  are formulas, if \Lambda  is a formula, where S is any sort and x is a variable symbolof sort

S.*
( Nx : A)\Lambda  is a formula, if \Lambda  is a formula, where A is any sort of atoms and x is a variable symbol ofsort

A.Like \Pi  and ffl, the freshness quantifier

Nis a binder - the free variables of ( Nx : A)\Lambda  are all the freevariables of
\Lambda  except x.

A.3 Axioms

A nominal logic theory consists of a signature and a collection of formulas over the signature, calledthe (non-logical) axioms of the theory. The theorems of the theory are all the formulas derivable using
the rule of Modus Ponens from the usual axioms of first-order logic with equality augmented by thefollowing axioms specific to nominal logic. In what follows,

A and A\Lambda  range over sorts of atoms, Sranges over arbitrary sorts, and fl
S over lists of sorts.

Properties of swapping

(\Pi a : A)(\Pi x : S) (a a)u*x = x (S1)
(\Pi a, a\Lambda  : A)(\Pi x : S) (a a\Lambda )u*(a a\Lambda )u*x = x (S2)

A.M. Pitts / Information and Computation 186 (2003) 165-193 191
(\Pi a, a\Lambda  : A) (a a\Lambda )u*a = a\Lambda  (S3)
Equivariance

(\Pi a, a\Lambda  : A)(\Pi b, b\Lambda  : A\Lambda )(\Pi x : S) (a a\Lambda )u*(b b\Lambda )u*x = ((a a\Lambda )u*b (a a\Lambda )u*b\Lambda )u*(a a\Lambda )u*x (E1)
(\Pi a, a\Lambda  : A)(\Pi b : A\Lambda )(\Pi x : S) b # x \Sigma  (a a\Lambda )u*b # (a a\Lambda )u*x (E2)
(\Pi a, a\Lambda  : A)(\Pi flx : flS) (a a\Lambda )u*f (flx) = f ((a a\Lambda )u*flx) (E3)
where f is a function symbol of arity flS -\Phi  S and (a a\Lambda )u*flx indicates the finite list of arguments givenby

(a a\Lambda )u*xi as xi ranges over flx.

(\Pi a, a\Lambda  : A)(\Pi flx : flS) R(flx) \Sigma  R((a a\Lambda )u*flx) (E4)

where R is a relation symbol of arity flS.

(\Pi b, b\Lambda  : A\Lambda )(\Pi a : A)(\Pi x : S) (b b\Lambda )u*(a.x) = ((b b\Lambda )u*a).((b b\Lambda )u*x) (E5)
Properties of freshness

(\Pi a, a\Lambda  : A)(\Pi x : S) a # x \Omega  a\Lambda  # x \Sigma  (a a\Lambda )u*x = x (F1)
(\Pi a, a\Lambda  : A) a # a\Lambda  ffi ~a = a\Lambda  (F2)
(\Pi a : A)(\Pi a\Lambda  : A\Lambda ) a # a\Lambda  (F3)
where A and A\Lambda  are different sorts of atoms.

(\Pi flx : flS)(ffla : A) a # flx (F4)
where a # flx indicates the finite conjunction of the formulas a # xi as xi ranges over the list flx.

Definition of N

(( Na : A)\Lambda ) ffi (ffla : A)a # flx \Omega  \Lambda  (Q)
where a, flx is a list of distinct variables containing the free variables of \Lambda .
Properties of atom-abstraction

(\Pi a, a\Lambda  : A)(\Pi x, x\Lambda  : S) a.x = a\Lambda .x\Lambda  ffi x(a = a\Lambda  \Omega  x = x\Lambda ) i (a\Lambda  # x \Omega  x\Lambda  = (a a\Lambda )u*x) (A1)
(\Pi y : [A]S)(ffla : A)(fflx : S) y = a.x (A2)

References

[1] H.P. Barendregt, The Lambda Calculus: Its Syntax and Semantics, revised ed., North-Holland, Amsterdam, 1984.
[2] M.J. Beeson, Foundations of Constructive Mathematics, Ergebnisse der Mathematik und ihrer Grenzgebeite, Springer,

Berlin, 1985.

192 A.M. Pitts / Information and Computation 186 (2003) 165-193

[3] L. Caires, L. Cardelli, A spatial logic for concurrency (part I), in: N. Kobayashi, B.C. Pierce (Eds.), Theoretical Aspects of

Computer Software, 4th International Symposium, TACS 2001, Sendai, Japan, October 29-31, 2001, Proceedings, Lecture
Notes in Computer Science, vol. 2215, Springer, Berlin, 2001, pp. 1-38.
[4] L. Caires, L. Cardelli, A spatial logic for concurrency (part II), in: 13th International Conference on Concurrency Theory,

CONCUR 2002, Proceedings, Lecture Notes in Computer Science, Springer, Berlin, 2002.
[5] L. Cardelli, A.D. Gordon, Logical properties of name restriction, in: S. Abramsky (Ed.), Typed Lambda Calculus and

Applications, 5th International Conference, Lecture Notes in Computer Science, vol. 2044, Springer, Berlin, 2001.
[6] The Coq proof assistant, version 7.2, January 2002. Institut National de Recherche en Informatique et en Automatique,

France. Available from <coq.inria.fr>.
[7] N.G. de Bruijn, Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem, Indag. Math. 34 (1972) 381-392.
[8] J. Despeyroux, F. Pfenning, C. Schu"rmann, Primitive recursion for higher-order abstract syntax, in: Typed Lambda Calculus and Applications, 3rd International Conference, Lecture Notes in Computer Science, vol. 1210, Springer, Berlin, 1997,
pp. 147-163.
[9] G. Dowek, T. Hardin, C. Kirchner. A completeness theorem for an extension of first-order logic with binders, in: S.

Ambler, R. Crole, A. Momigliano (Eds.), Mechanized Reasoning about Languages with Variable Binding (MERLIN
20001), Proceedings of a Workshop held in conjunction with the International Joint Conference on Automated Reasoning,
IJCAR 2001, Siena, June 2001, Department of Computer Science Technical Report 2001/26, University of Leicester,
2001, pp. 49-63.
[10] G. Dowek, T. Hardin, C. Kirchner, HOL-\Theta fl : An intentional first-order expression of higher-order logic, Mathematical

Structures in Computer Science 11 (1) (2001) 21-45.
[11] M.P. Fiore, G.D. Plotkin, D. Turi, Abstract Syntax and Variable Binding, 14th Annual Symposium on Logic in Computer

Science, IEEE Computer Society Press, Washington, 1999, pp. 193-202.
[12] P.J. Freyd, The axiom of choice, Journal of Pure and Applied Algebra 19 (1980) 103-125.
[13] M.J. Gabbay, A theory of inductive definitions with \Delta -equivalence: semantics, implementation, programming language,

Ph.D. thesis, University of Cambridge, 2000.
[14] M.J. Gabbay, FM-HOL, a higher-order theory of names, in: Thirty Five years of Automath, Heriot-Watt University, Edinburgh, April 2002, Informal Proceedings, 2002.
[15] M.J. Gabbay, FM techniques in Isabelle, Preprint, March 2002.
[16] M.J. Gabbay, A.M. Pitts, A new approach to abstract syntax involving binders, 14th Annual Symposium on Logic in

Computer Science, IEEE Computer Society Press, Washington, 1999, pp. 214-224.
[17] M.J. Gabbay, A.M. Pitts, A new approach to abstract syntax with variable binding, Formal Aspects of Computing 13

(2002) 341-363.
[18] A.D. Gordon, T. Melham, Five axioms of alpha-conversion, in: Theorem Proving in Higher Order Logics: 9th Interational

Conference, TPHOLs'96, Lecture Notes in Computer Science, vol. 1125, Springer, Berlin, 1996, pp. 173-191.
[19] C.A. Gunter, Semantics of Programming Languages: Structures and Techniques, Foundations of Computing, MIT Press,

Cambridge, 1992.
[20] L. Hallna"s, Partial inductive definitions, Theoretical Computer Science 87 (1991) 115-142.
[21] M. Hamana, A logic programming language based on binding algebras, in: N. Kobayashi, B.C. Pierce (Eds.), Theoretical Aspects of Computer Software, 4th International Symposium, TACS 2001, Sendai, Japan, October 29-31, 2001,
Proceedings, Lecture Notes in Computer Science, vol. 2215, Springer, Berlin, 2001, pp. 243-262.
[22] K. Honda, Elementary structures in process theory (1): sets with renaming, Mathematical Structures in Computer Science

10 (2000) 617-663.
[23] F. Honsell, M. Miculan, I. Scagnetto, An axiomatic approach to metareasoning on nominal algebras in hoas, in: F. Orejas,

P.G. Spirakis, J. van Leeuwen (Eds.), 28th International Colloquium on Automata, Languages and Programming, ICALP
2001, Crete, Greece, July 2001, Proceedings, Lecture Notes in Computer Science, vol. 2076, Springer, Heidelberg, 2001,
pp. 963-978.
[24] B. Huppert, in: Endliche Gruppen I, Grundlehren Math. Wiss., vol. 134, Springer, Berlin, 1967.
[25] T.J. Jech, About the axiom of choice, in: J. Barwise (Ed.), Handbook of Mathematical Logic, North-Holland, Amsterdam,

1977, pp. 345-370.
[26] M. Makkai, G.E. Reyes, Lecture Notes in Mathematics, Springer, Berlin, 1977.

A.M. Pitts / Information and Computation 186 (2003) 165-193 193
[27] R.C. McDowell, D.A. Miller, Reasoning with higher-order abstract syntax in a logical framework, ACM Transactions on

Computational Logic 3 (1) (2002) 80-136.
[28] J. McKinna, R. Pollack, Some type theory and lambda calculus formalised, Journal of Automated Reasoning 23 (1999)

373-409.
[29] M. Miculan. Developing (meta)theory of lambda-calculus in the theory of contexts, in: S. Ambler, R. Crole, A. Momigliano (Eds.), Mechanized Reasoning about Languages with Variable Binding (MERLIN 20001), Proceedings of a Workshop
held in conjunction with the International Joint Conference on Automated Reasoning, IJCAR 2001, Siena, June 2001,
Department of Computer Science Technical Report 2001/26, University of Leicester, 2001, pp. 65-81.
[30] D.A. Miller, A compact representation of proofs, Studia Logica 46 (4) (1987) 347-370.
[31] L.C. Paulson, in: Isabelle: A Generic Theorem Prover, Lecture Notes in Computer Science, vol. 828, Springer, Berlin,

1994.
[32] F. Pfenning, C. Elliott, Higher-order abstract syntax, Proceedings ACM-SIGPLAN Conference on Programming Language

Design and Implementation, ACM Press, New York, 1988, pp. 199-208.
[33] A.M. Pitts, Categorical logic, in: S. Abramsky, D.M. Gabbay, T.S.E. Maibaum (Eds.), Handbook of Logic in Computer

Science, vol. 5. Algebraic and Logical Structures, Oxford University Press, 2000 (Chapter 2).
[34] A.M. Pitts, Nominal logic: A first order theory of names and binding, in: N. Kobayashi, B.C. Pierce (Eds.), Theoretical Aspects of Computer Software, 4th International Symposium, TACS 2001, Sendai, Japan, October 29-31, 2001, Proceedings,
Lecture Notes in Computer Science, vol. 2215, Springer, Berlin, 2001, pp. 219-242.
[35] A.M. Pitts, M.J. Gabbay, A metalanguage for programming with bound names modulo renaming, in: R. Backhouse, J.N.

Oliveira (Eds.), Mathematics of Program Construction, 5th International Conference, MPC2000, Ponte de Lima, Portugal,
July 2000, Proceedings, Lecture Notes in Computer Science, vol. 1837, Springer, Heidelberg, 2000, pp. 230-255.
[36] C. Schu"rmann, Automating the meta-theory of deductive systems, Ph.D. thesis, Carnegie-Mellon University, 2000.
[37] D.S. Scott, Identity and existence in intuitionistic logic, in: M.P. Fourman, C.J. Mulvey, D.S. Scott (Eds.), Applications of

Sheaves, Proceedings, Durham 1977, Lecture Notes in Mathematics, vol. 753, Springer, Berlin, 1979, pp. 660-696.
[38] R. Vestergaard, J. Brotherson, A formalised first-order confluence proof for the \Theta -calculus using one-sorted variable names,

in: A. Middeldorp (Ed.), Rewriting Techniques and Applications, 12th International Conference, RTA 2001, Utrecht, The
Netherlands, May 2001, Proceedings, Lecture Notes in Computer Science, vol. 2051, Springer, Heidelberg, 2001, pp.
306-321.