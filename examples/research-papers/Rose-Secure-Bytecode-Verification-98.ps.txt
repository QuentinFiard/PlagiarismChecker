

Towards
Secure Bytecode Verification

on a Java Card

Eva Rose 1DIKU, University of Copenhagen
Universitetsparken 1, 2100 Copenhagen O/, Denmark

September 14, 1998

1Current address: Ecole Normale Sup'erieure de Lyon (LIP/PLUME), 46, All'ee d'Italie,
69364 Lyon cedex 7, France. E-mail: Eva.Rose@ens-lyon.fr.

Abstract
There is a growing interest for using "intelligent" or "smart" cards such as Sun's
Java Cards, because of the independence they offer their users by having an on-card
microprocessor. Furthermore we have, during the last decade, become accustomed
to global, fast and flexible information exchange, as offered by the Internet. Hence
an incipient interest has emerged for combining the independence of a Java Card
with the extensive flexibility of the Internet in a manner which respects the high
security requirements one must demand when dealing with intelligent cards. In
particular the "Smart Card" standards do currently not support downloading of executable code onto the card since it opens up too many security breaches. The
establishment of a trusted relation with the code distributer, e.g., based on cryptographic techniques, would create a single point of failure relation, which could
be fatal when dealing with large distributions of cards. Moreover, the administration of such trusted relations seems poorly realizable within the sparse resources
of todays intelligent card design.

In this master thesis we investigate how to extend the functionality of the existing Java Card to permit downloading of Java programs (applets) on the fly. In
particular we formally investigate a technique by which bytecode verification can
be performed on the Java Card itself without having to rely on a trusted relation.
We pursue this goal, first by setting up a formal framework by which we can reason.
We define an object-oriented Java subset language JavaOb, which can be seen as a
restricted version of the Java Card language, targeted at writing down-loadable applets that can be verified by a bytecode verifier, implemented on the card. First by
specifying its abstract syntax, then its static semantics and finally its dynamic semantics, based on the official Java language description by Gosling, Joy and Steele.
Subsequently, we specify an abstract translation into JVMOb, a simplified version
of the Java Virtual Machine. We specify JVMOb semantically, based on the official machine description by Lindholm and Yellin. In particular the formalization
suggests how bytecode safety-verification can be seen as a simple type check of the
typed bytecode.

We exploit this formal framework to propose a new bytecode-safety verificationprocedure for future Java Cards to ensure the safety of the downloaded code, independent of any trusted relation. This by borrowing from the idea of "Proof-carrying
code" by Necula and Lee. To be precise, we propose that safe bytecode is loaded
together with a small, justifying type-certificate which is simply checked upon
arrival, and suggest a type-checker algorithm with a space-consumption which is
realistic with respect to the limited scratch-area available on the contemporary Java
Card. In particular we argue that the bytecode checking is tamper-proof.

Preface
The present master thesis is submitted to DIKU, Department of Computer Science, Copenhagen University as "speciale", in partial fulfillment of the requirements for a Danish "cand. scient." degree in Computer Science. (This being the
Danish equivalent of the Anglo-American (research) M.Sc. degree or the French
D.E.A.)

The master thesis was written from April 1997 to January 1998 based on my
initial work on a formalization of the Java Virtual Machine, presented at a DIKU
Java Coffee Shop meeting in December 1996. My idea of replacing Verification on
a Java Card with Proof Checking based on the notion of a "Bytecode Check Certificate", has been presented at the Palo Alto workshop on languages and security
in California, USA, in October 1997 (Abadi 1997), and at the VIP (Verification of
Internet Protocols) meeting in Rennes, France, in November 1997.

The material presented in this report is original research by the author except
where explicitly stated otherwise.

Prerequisites
This master thesis is targeted at readers with interest in semantic specifications of
object oriented programming languages, and at Java developers with an interest in
formal proofs and Java Card technicalities.

A knowledge of semantic specifications and reasoning for object-oriented language design in general, and of Java and the Java Virtual Machine in particular, is
assumed.

Furthermore I recommend readers of this document to have access to the official Java Language Specification (Gosling, Joy and Steele 1996) and the Java
Virtual Machine Specification (Lindholm and Yellin 1996) when going through
this work.

Acknowledgements
The master thesis has been prepared under the firm and skilled supervision of
DIKU lektor Mads Tofte in a collaboration which has given me the greatest scientific respect for Mads and the way he supports and encourages his students. Then I
would like to thank my husband, Kristoffer Rose, for his qualified critiques of this

3

4
work, for our good scientific discussions in general, and last for his nice TEXnical
assistance (Rose and Moore 1995) during the master thesis write-up phase. Thanks
for being such a wonderfully positive, energetic and very special person to me.

I am grateful to Pierre Lescanne for including me in his new select group
"PLUME" where I can continue my study of Java along the lines introduced in
this master thesis. Also I would like to thank the DYADE group of INRIA Rocquencourt for their continuing interest in and support of this work; I look forward to strengthen the industrial relations. In particular I would like to thank team
leader Dominique Bolignano and ing"enieur de recherches Jean Goubault-Larrecq
for their detailed comments on this work which helped me to find numerous bugs
and unclarities at the end.

I have been lucky to benefit from the encouragement of several people in the
very enthusiastic spirit of this new area; I would like to acknowledge valuable
encouragement (in alphabetical order) from Martin Abadi, Sophia Drossopoulou,
Steven Freund, Peter Lee, Xavier Leroy, Barbara Liskov, Franc,ois Rouaix, Raymie
Stata, and Guy Steele.

Finally I would like to acknowledge lektor Eric Jul at DIKU for his kind
support and scientific encouragement when it was most needed and lektor Klaus
Hansen at DIKU for opening my eyes to networking and formal methods. In general I would like to thank the DISTLAB group, not to forget DIKU secretary Ruth
Schl"uter, for our many enjoyable afternoons in the cake and (Java) coffee corner
over the last years.

Eva Rose
January 1998

Before final submission to the University of Copenhagen this Master's Thesis
underwent some minor but important modifications, in particular several details
were cleaned up, the algorithm in Chapter 6 improved, and the conclusion chapter
completed.

Eva Rose
June 1998

Contents

Preface 3
Contents 5
1 Introduction 7

1.1 Java Programming and Internet Security . . . . . . . . . . . . . . 7
1.2 Java Cards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3 Bytecode Verification as Type Reconstruction . . . . . . . . . . . 13
1.4 Proof-Carrying Bytecode . . . . . . . . . . . . . . . . . . . . . . 15
1.5 Why not Cryptography? . . . . . . . . . . . . . . . . . . . . . . 17
1.6 Why not Source Code? . . . . . . . . . . . . . . . . . . . . . . . 17
1.7 Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.8 Overview of the Report . . . . . . . . . . . . . . . . . . . . . . . 18

2 Preliminaries 20

2.1 The Java Card Language . . . . . . . . . . . . . . . . . . . . . . 20
2.2 Bytecode Verification . . . . . . . . . . . . . . . . . . . . . . . . 21
2.3 Natural Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.4 Proof-Carrying Code . . . . . . . . . . . . . . . . . . . . . . . . 28

3 A Java Card Sublanguage 31

3.1 Design Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2 Abstracting the Program Syntax . . . . . . . . . . . . . . . . . . 33
3.3 Preprocessing Semantics . . . . . . . . . . . . . . . . . . . . . . 42
3.4 Static Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.5 Dynamic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . 53

4 A Java Virtual Machine for the Sublanguage 68

4.1 Bytecode Safety . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.2 Abstracting the Class File Format . . . . . . . . . . . . . . . . . 75
4.3 Resolution Semantics . . . . . . . . . . . . . . . . . . . . . . . . 83
4.4 Static Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
4.5 Dynamic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . 99

5

6 CONTENTS
5 Compiling the Sublanguage 111

5.1 Abstract compilation strategy . . . . . . . . . . . . . . . . . . . . 111
5.2 Block compilation . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.3 Statement compilation . . . . . . . . . . . . . . . . . . . . . . . 116
5.4 Statement Expressions compilation . . . . . . . . . . . . . . . . . 117
5.5 Expression compilation . . . . . . . . . . . . . . . . . . . . . . . 119
5.6 Putting It All Together . . . . . . . . . . . . . . . . . . . . . . . 124

6 Secure Bytecode Verification on a Java Card 126

6.1 Verification and Proof Carrying Code . . . . . . . . . . . . . . . 126
6.2 A Secure, Optimized Certificate . . . . . . . . . . . . . . . . . . 130
6.3 A Checker Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 135

7 Conclusions 140

7.1 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
7.2 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
7.3 Future directions . . . . . . . . . . . . . . . . . . . . . . . . . . 146

A Appendix 147

A.1 JDK Example Runs . . . . . . . . . . . . . . . . . . . . . . . . . 147

Bibliography 159
Detailed Table of Contents 162
List of Figures 168
List of Tables 168
Index 169

Chapter 1
Introduction
In this chapter we motivate the interest of this work and account for the chosen approach. We start in Section 1.1 with a brief introduction to the security-problems
related to Java in general, continuing in Section 1.2 with a discussion of the pariticular problems pertaining to code downloadable onto Java Cards, our area of interest. In Section 1.3 we then explain how a part of the existing Java security model
is really an application of type reconstruction, which leads to a presentation in in
Section 1.4 of why one formal paradigm, "Proof-carrying code", has our special attention in this quest. In Sections 1.5 and 1.6 we briefly account for the reasons why
we do not consider approaches based on cryptographic techniques and certyified
source code, respectively, safe for our application. In Section 1.7, we summarize
the chosen approach and the main goals of this work, and finally in Section 1.8 we
explain the structure of the remainder of this master thesis.

1.1 Java Programming and Internet Security
One of the biggest challenges in computer science within this decade is how to
manage security-problems related to the global connectivity of the Internet and
other world-wide, electronic networks, as reflected by many recent discussions,
workshops, and books in this area (Garfinkel and Spafford 1996, Abadi 1997, McGraw and Felten 1997, Garfinkel and Spafford 1997).

On the one hand, such networks have provided an enormous flexibility for
users to exchange information, in particular with the introduction of the WWW,
World-Wide Web. On the other hand, they have prepared the way for new kinds
of adversaries, attempting to exploit the available resources in ways not intended
by their owners. This is primarily due to the fact that most well-known security
measures scale badly for networks of this size and nature, i.e., for nets extending
at random over often haphazardly organized connections.

The particular consequence that concerns us in this thesis is that the common
Internet user today is largely forced to download programs from the net uncritically,
without the realistic possibility of verifying the quality or authenticity thereof.

7

8 CHAPTER 1. INTRODUCTION
Even if it is possible with common WWW-browser programs such as Netscape
and Internet Explorer to control such access lists, these programs typically come
preinstalled with long lists of "fully trusted" companies, and even then the list is
disabled more often than not because of the overwhelming number of times the system interrupts the user with yet another inquiry about whether to accept a certain
"cookie" or execute an "embedded object", etc

Generally speaking, security problems appear for two reasons: because of simple programming bugs (such as adding, unintentionally, a number to a pointer in
C, resulting in e.g. buffer overflow if this advances a stack pointer etc) or because
of proper hostile attacks (such as Trojan horse attacks, computer viruses, and other
denial of service attacks). In this thesis we will adapt the common viewpoint of
this to define program safety (or reliability) as when it is guaranteed that a program will produce results which adhere to the program's specification; we define
system security as when it is guaranteed that a program cannot cheat the computer system in ways which are beyond user interest (Anderson 1996, Garfinkel
and Spafford 1997). As pointed out by Anderson, security assumes program safety
in the sense that safety is considered as the fundamental property of any security
model.

Recently, the appearance of the Java programming language and the extended
use of secured browsers has provided a promising means to counter some of the
problems of how to ensure the security when transferring code over the Internet (Gosling and McGilton 1995, HotJava - The Security Story n.d.). The Java
programming language was intentionally designed with the purpose of encouraging programmers to write inherently reliable, i.e., safe, code. At the beginning it
was not intended for working in unsecure environments, but for programs which
where send over local networks from "approved" code producers (Garfinkel and
Spafford 1997, p43). However, from the moment it was repositioned for the Internet, notably the WWW, a security model was additionally developed in terms of
a variety of techniques which limits what a downloaded program can do. Thus it
is fair to say that the Java security model was essentially developed in an ad hoc
manner. Nevertheless, it has been very succesful, probably first of all because of
the very conservative attitude of Sun with respect to changes: Java contains much
"proven technology" and few "innovative features". The Java language is specified by a language definition text (Gosling, Joy and Steele 1996) and a standard
library in the form of a standardised Java API, Application Programmer Interface
(Gosling, Yellin et al. 1996a, Gosling, Yellin et al. 1996b).

So what is the Java programming language? First of all it is an object-oriented
language. This means that the compilation unit of Java programs is a class, which
is essentially the data type of objects, which are instances of the class, together
with the code of the methods on objects of that class (as well as global methods
and values that are just bundled with the class but we will not discuss those much
here). The compiled classes must be in a standardized class file format specified
for the Java platform by Lindholm and Yellin (1996) which defines the Java Virtual
Machine, JVM, (Lindholm and Yellin 1996), independently of the Java language

1.1. JAVA PROGRAMMING AND INTERNET SECURITY 9
(at least it is the intention of the authors that the JVM specification is independent
of the Java language even if this is not yet so).

A Java class is "loaded" either explicitly or when an an object which is an
instance of the class is created. It is the task of the class loader to check whether
the new class file comes from a source that is sufficiently trusted that accepting it
is reasonable. Determining this will be done based on name lists: locally available
classes are always trusted, and it is possible to use a digital signatures to certify
that the class comes from a trusted source, for example.

It is then the task of the bytecode verifier to subsequently verify that the loaded
code is, in fact, safe to execute in the current environment, i.e., that all assumptions
in the downloaded class are consistent with the environment (including the new
class itself).

Finally, while running code in the class the system makes certain run-time
checks. In particular calls of methods in the environment are controlled by the
security manager, a special Java class (SecurityManager) which is designed to be
called before any critical operation is performed, filtering out those which presents
a risk based on the origin of the class that calls it.

Thus the Java security model is basically realized by the class loader restricting
what can be loaded, the bytecode verifier guaranteeing the safety of the loaded
code, and the security manager restricting what library methods are called. This
was pioneered by the HotJava browser, which is programmed entirely in Java with
a large portion loadable remotely as needed (HotJava - The Security Story n.d.).

However, since the unit of Java downloading is the class file, the security model
is specified based on the binary class file format used by the Java Virtual Machine,
JVM, (Lindholm and Yellin 1996), which specifies the properties of the Java runtime environment (even if it is the intention of the authors that at least the JVM
specification is independent of the Java language this is not yet so). This means
that in order to understand what a secure downloadable Java fragment is we must
formalize both the source language and the (virtual) machine language, and relate
the values.

One kind of Java class deserves special mention, namely the case where the
Java class comes from a completely untrusted source. Such classes must run in
a completely protected environment, called a sand-box, ensuring that even hostile
code will remain harmless. This is the case for the very popular applets that can
be embedded in WWW pages: they are only permitted to interact with their environment through the Abstract Window Toolkit part of the API (Gosling, Yellin
et al. 1996b), and run with a fixed security manager that prevents any interaction
with the environment except in the form of dialogue with the user and with other
applets from the same source (otherwise multi-class programs would be impossible as applets). Due to the popularity of applets the meaning of the term has been
somewhat generalized and now often comprises any kind of downloadable code.

However, despite the above careful measures, many bugs were reported in the
early releases of the Java security system, first of all mistakes in the conception
of the class loader and bytecode verifier: even if the implementation was cor10 CHAPTER 1. INTRODUCTION
rect, some of the imposed constraints were not sufficiently strong (McGraw and
Felten 1997, Frequently Asked Questions - Applet Security 1997). For this reason
it is useful to embark on using a more formal understanding of Java to raise the
confidence in the model.

1.2 Java Cards
Integrated Circuit Cards, or Smart Cards, is a generic term denoting credit card
sized computing devices that can do more than just store data (Sun 1997d). Typically they contain a microprocessor and a few applications that can be invoked
from the "outside" using one of two standards: ISO 7816 or EMV '96 (a collaboration between the companies Europay, MasterCard, and Visa). These standards
specify how the electric connection between a CAD (Card Accepting Device) such
as an automatic teller machine, and the smart card works; in particular how an application on the Smart Card is invoked with some parameters, and how the result
is returned, meaning that only data is exchanged. Having applications on the card
is "smart" since it is the logic on the card which decides which data are exported;
hence data can be kept confidential in a very secure manner.

Smart Cards where the implementation of the logic is based on Java are called
Java Cards and are standardized by Sun (Sun 1997d, Sun 1997a, Sun 1997b); procedures residing on a Java Card are called applets (probably for marketing reasons).
The associated subset of the Java language is called the Java Card language (the
restrictions are summarised more precisely in Section 2.1).

On a Smart Card, the repertoire of commands is limited by the sparse spaceresources which are available. Java Cards typically offer around 16k bytes of
ROM (Read-Only Memory), in which the applications reside (traditionally one
uses the word "mask" for storing data into a ROM), possibly around 8k bytes EEPROM (Electrically Erasable, Programmable Read-Only-Memory) containing infrequently changing data, and around 256 bytes of RAM (Random-Access Memory)
in which mutable data can be kept; the RAM is the persistent kind that is kept even
when no power is available. The link with the outside world is a simple connector
(that also provides the power to the microprocessor), by which application parameters and application results are communicated as explained by the Smart Card
standards.

However, none of the current "Smart Card" standards support downloading
of runnable code,1 since this would open up numerous security problems. The
multitude and haphazard organization of the Internet is one reason; another, is the
sparse space-resources which are available on "intelligent" cards today for possible
implementations of security procedures. With the above examples, however, we
believe to have argued for the interest of studying how to extend the functionality

1A very recent announcement of Sun and EMV seems to indicate that this is being worked on and
that smart cards will soon support downloading of digitally signed code, however, no details have
been available yet.

1.2. JAVA CARDS 11
of "intelligent" cards to allow that programs are downloaded in a secure manner.

Specifically, downloading of applets to be executed on a Java Card are explicitly excluded from the Java Card 2.0 specification (Sun 1997a) which merely states
that one can imagine that code can be "installed through a secure installation process immediately after the card has been issued". In Section 1.1, however, we
discussed how Java provides one of the currently most promising, secured settings
for sending even untrusted programs over the Internet (as Java applets).

In this report, we will therefore take on the challenge of proposing a useful
paradigm for down-loadable applets on Java Cards, based on the existing Java
Security model. We will work under the assumption that Java Cards are designed
to be carried by a person and are imagined to be distributed in large numbers of
copies. (In fact, the current distribution of the ROM, RAM and EEPROM seems
already to be a result of a detailed analysis of price and storage ability, realistic for
personalized cards). This means that an extended Java Card should fulfill (at least)
the following requirements:

ffl be trusted primarily by its owner,
ffl be standardized such that they can be used in CADs all over the world,
ffl maintain the current card-architecture with some functional extensions,
ffl be protectable in the sense that a card should be able to contain information

which is inaccessible to CADs,

ffl permit a wide range of general operations not all of which were necessarily

predicted when the card was issued, and finally

ffl implement all this respecting the Java security model, but with a minimum

of resources on the card.

To illustrate this we give an example of the sort of problems which appear when
permitting applets to be downloaded with a personalized Java Card. We use this as
one of our continuing examples, and to illustrate the chosen approach of this thesis.

Example 1.2.1 (Tax Computation). There is a tendency that the computation of
the annual income tax varies with not only the politics of the residing, governmental
majority, but also to some extend the regulations dictated by the European Union
(EU). Hence a computation based on a frequently changing algorithm.

Let us for a moment imagine that citizens of the EU were equipped with an
"ETHIC" (for "employment tax help income card") on which they can keep a personal account of all income-relations they have had with various employers (such
a card has been discussed in Denmark (Dybkjaer and Christensen 1994)).

Clearly we do not wish such a card to be a mere "data card" where the CAD
performs the tax-computation based on the retrieved data. Such a procedure would
permit the CAD to record personal information and hence open up for misuse. An
extended Java Card should hence be able to contain information that is inaccessible

12 CHAPTER 1. INTRODUCTION
to CADs. Instead the program which implements the tax computation algorithm
should be stored, controlled and executed on the card. Consequently, our user can
have her salary added every month at the employer's "paycheck terminal" CAD
without the risk of revealing to the employer's CAD what other income she has
had.

This example illustrates in which ways the user has to trust the code on the
Java Card. On the conventional Java Cards programs can only be installed right
after the card has been issued by what is described as a "trustworthy installation
procedure". Our tax-computation applet, however, has to be downloaded to the
card, presumably once a year, or more often in case her employment or family
situation changes. For this she has to trust the provider of the tax-computation
applet.

Our user's trust in the tax-computing applet comes in two flavors which we
here call tax-applet safety and tax-applet correctness:

Safety: Is it safe to execute the tax applet? Malicious applets might pose as "supereffective this-is-not-a-hoax tax computation" applets. Safe applets should
neither overwrite information on the card, nor access unrelated information
on the card, nor export previous employers or other (possibly) sensitive information, nor simply destroy the card by rendering it useless in some way.

Correctness: Is the tax-computation applet correct with respect to the original

specification, that is with respect to the extensional meaning of the specification? If it is not, then our user will pay the wrong tax.

Tax-applet safety typically has the effect that no information is exported from the
computation except for the tax result (even if the actual tax computation depends
on this information). Notice, that "safety" as defined here does not guarantee that
a tax-applet actually computes the tax as intended by the specification. To obtain
such a guarantee, correctness of the tax-applet must be established. In particular a
correct applet implements neither more nor less than indicated by its specification.
We have that program correctness implies program safety.

Surely correctness of such a tax-applet is the ultimate way to ensure its safety,
and hence ensure the card against misuse or destruction. However, not a realistic
requirement to demand every time an applet is loaded over the network. For that
purpose, safety suffices.

When no networking is involved, or when we simply transfer over a small and
controlled network, an obvious way to ensure the quality of such an applet would
be to built the safety-requirements into the compiler as reliable checks (a trusted
compiler). Over larger networks, other security means has to be applied in order to
ensure the authentication of the code. Typically by use of digital signatures or other
crypto-based techniques. The problem of these techniques is that they involve that
the receiver of the applet still has to trust an external authority (the provider of
the "private key") which for cards, distributed in large numbers, means that if ever
this trust is broken, the effect might be the destruction of millions of personalized

1.3. BYTECODE VERIFICATION AS TYPE RECONSTRUCTION 13
cards! Moreover, many of these techniques involve the management of large lists
over trusted sources, something which is not possible on a sparse resourced card
as the Java Card. (We comment further on these issues in the following Sections.)
The obvious way of ensuring safety, and the way we advocate it in this thesis, is to
validate on the card that the applet is safe, just before permitting the algorithm to
be executed. In this way, the user will only have to trust the verifying programs on
the card (to the extend permitted by the limited resources on the card.) This means
that a universal method ensuring the desired safety policy should be installed on
the card. One way that this can be achieved is through the type system of the
programming language used.

Clearly all three aspects of the Java security model - class loading, bytecode
verification, and security management - are relevant even on a Java Card.

Observation 1.2.2 (Focus on Bytecode Verification). Class loading and security
management is essentially tables, possibly hidden behind digital signatures, so they
do not pose a problem of the same difficulty. To understand bytecode verification
is the main challenge.

The official definition of bytecode verification is summarized in Section 2.2.

1.3 Bytecode Verification as Type Reconstruction
In this section we will explain the notion of program safety for Java bytecode and
describe our formal approach to this issue.

Recall that the fundamental approach to security, and the one chosen in this
thesis, is to ensure program safety. In Java, this is ensured by the bytecode verifier
which verifies that the virtual machine bytecode does not violate basic Java language rules, even when dealing with "native bytecode" (as explicitly pointed out
by Guy Steel (Sun) at the FOOLS'97 workshop). The technique is described in the
official specification (Lindholm and Yellin 1996, $4.8-9), and has served as Sun's
implementation approach, even though the specification is held in a rather narrative
and informal style.

We shortly explain the meaning of the different verification aspects.
The bytecode verifier works on units of method code which are stored as "attributes" of the class file. There are basically two steps in any verification process:
first a "pre-verification" step which has for purpose to ensure that the actual bytestream can be interpreted as a valid sequence of java machine-instructions with
well-defined operands; then the actual verification step which generally speaking
has for purpose to ensure that the the code instructions only access values of the
type they are designed for, that variables which are not set are referenced, etc.

The verification-step is implemented in terms of a data-flow analysis which
abstractly executes the method bytecode, based on the type-information by the
bytecode being typed (in other words an interpretation of method bytecode over a
non-standard value-domain).

14 CHAPTER 1. INTRODUCTION

Specifically, the official verification algorithm (Lindholm and Yellin 1996, $4.9)
is implemented as an iterative data-flow analysis algorithm which at each execution point of the method code (that is at the beginning of each instruction), assigns
an abstracted execution-description of the associated memory state, i.e., of the local variables and the operand stack of the method frame in question, based on the
types of the potential runtime values. These types being statically deducible from
the type of the bytecode-instructions. For example, assume at execution point A,
the instruction istore [n], with the effect that the value on the top of the operand
stack, which by the i-type annotation of the store-instruction is bound to be an integer, is assigned to the local variable at index n and subsequently popped. Formally,
the effect on a memory frame can be abstractly expressed by the effect on an abstracted operand stack structure S of types which grows towards the left, and on
an abstracted local variable table T where each table element T[n] is either unset
or contains a type. For istore [n] this means that the the stack int \Delta  S, where int
is an integer, becomes S, and the local variable table T becomes T0, where T0 = T
for all table indices except n, where now T0[n] = int. Furthermore, assume that
the execution point B which immediately follows A is jumped to from yet a different execution point and that the effective local variable table T 00 at index n is
left unset by the jump. The data-flow analysis principle seeks to extract all global,
i.e., execution-path independent information about the actual memory state at B. In
this example, the local variable table is set to the "most conservative" of T0 and T00
(and similarly for the operand stacks). Hence by the data-flow analysis, the local
variable table is abstracted by T00. In this section we will avoid to go further into
the nitty-gritty details for how the verifier merges these structures but refer to the
official specification.

Finding an assignment of frame types to execution points that is sufficiently
conservative for all execution paths requires testing it for them all, and this is what
the verification is basically about. (By "basically" we mean apart from the preverification step). In practice it is done by assigning approximate frame types to
each execution point while running through all the execution paths, updating each
frame type to be valid for all the execution paths seen so far, as illustrated by the
example. Whenever a frame type is adjusted then all frame types that depend on it
have to be adjusted, too, thus leading to a need for iteration. The final verification
frame type assignment is a proof of the verification being done - or, put differently, of the welltypedness of the bytecode. Thus, technically bytecode verification
can be seen as type reconstruction of method bytecode's frame types, where then
the reconstructed frame types expresses and guarantees that evaluation "cannot go
wrong", i.e., that the bytecode is "safe" to execute.

In relation to the distribution issues discussed above the situation can be illustrated as follows:

GF ED@A BCJavaProgram javac ON MLHI JKVerifiedJVM

bytecode
// Internet ON MLHI JKUntrustedJVMbytecode// verifier ON MLHI JKTrustedJVMbytecode// execution

Thus the trust of the program executed depends on the ability of the verifier to

1.4. PROOF-CARRYING BYTECODE 15
reestablish the trust based on the JVM bytecode alone. This is why the JVM bytecode is typed and carries information about all external types. The verifier can
then reconstruct all types used internally by the bytecode and thus reestablish the
trust. In the following we use the term program points instead of execution points
(in accordance with the official bytecode description).

Finally observe that a principle for downloading onto Java Cards should be
carefully designed because any mistake that involves a security breach could demand that millions of cards with risky algorithms masked into the ROM need to
be replaced! Thus a formal approach seems worthwhile to ensure that this does
not happen. We follow in this tradition and formalize subsets of the type systems
of Java and JVM such that we can express bytecode verification formally as type
reconstruction.

1.4 Proof-Carrying Bytecode
Given the context above, one formal paradigm, "Proof-carrying code", has our
special attention, because it permits replacing a type inference with a type checker.

This is important because the JVM bytecode carries sufficient information for
the bytecode verifier to prove welltypedness. However, the bytecode verifier still
has to do some work to reconstruct the types - this is implemented as a dataflow analysis of the JVM bytecode that is essentially an iteration of a small "type
improvement" step that refines the type of the bytecode until the type constraints of
all the individual JVM instructions are satisfied. This simple analysis still requires
substantial resources, in particular memory resources to keep all the constraints in
memory.

Independently of the Java development, Necula and Lee proposed the paradigm
of Proof-Carrying Code or PCC (Necula 1997), intended for integrating small
fragments of "proper" machine code into operating system kernels in a secure
way (Necula and Lee 1996b). The idea is to include in the binary format a proof of
its type-correctness: the recipient (for PCC the operating system kernel) then only
needs to include a proof checker, which is a significantly smaller program than a
the theorem prover required to build the proof in the first place. We summarize the
ideas of PCC in Section 2.4.

Our main observation in this thesis is the following.

Observation 1.4.1 (Bytecode Checking). Typed bytecode is almost PCC: only a
few key properties of the JVM bytecode need to be included to make it possible to
replace the bytecode verifier with a bytecode checker (BCC).

This is the subject of the core contribution of the thesis in Chapter 6, and the
way we sustain the claim that it is realistic to download and verify applets on a
Java Card.

Example 1.4.2. To illustrate: an applet implementing a tax calculation on a Java

16 CHAPTER 1. INTRODUCTION
Card, as discussed in Example 1.2.1, will typically be called with a method invocation statement like the following (in code on the card):

taxApplet.recalculate(income);
where taxApplet is an instance of the downloaded class and income is an instance
of the class Income with declaration (already on the card)

class Income {ReadOnlyAmount total; Amount tax, available; }
The verifier checks that the Tax class has a method recalculate which accepts
one argument of type Income. This is then checked in detail, in particular that all
accesses to this argument are correct, i.e., use only field accesses to the three fields,
total, tax, and available; this goes on recursively, so it is also checked that the
operations on these fields are legal operations on objects of type ReadOnlyAmount
and Amount, respectively. It also checks that the bytecode for recalculate uses
its execution frame properly.

The example is interesting because it illustrates the level of access control that
one can exhibit using the Java type system. For example one would typically define

class Amount extends Object {

int a;
int get() { return a; }
void set(int what) { a = what; }
}

class ReadOnlyAmount extends Amount {

void set(int what) {}
}

to prevent instances of the ReadOnlyAmount class to change the value of the field
(in other packages, in particular this would include when used in an applet).

We return to this example later when we have the formal tools to deal with it in
Chapter 6; the full text of the sample is in the appendix as Example A.1.2. program

The above can be extended to systems with additional information, in the tradition of abstract interpretation, to require stronger conditions. One could imagine
a supplement to the declaration of Income as follows:

class Income usedby Tax {

ReadOnlyAmount total;
Amount tax, available;
assert total = tax + available;
}

with specific restrictions for Tax applet's use of the Income class. Then the verifier
is obliged to check that the manipulations of the tax and available fields ensures
that their sum is equal to total.

1.5. WHY NOT CRYPTOGRAPHY? 17

Notice that since the declarations reside on the Java Card, the verifier, which
is also on the card, can be tuned to the types actually used: there is no need for a
general theorem prover.

1.5 Why not Cryptography?
One can use cryptography over large networks by "signing" code with a digital
signature ensuring the authenticity of the code, i.e., that it originates from a particular compiler which is supposedly trustworthy. This does not, however, scale
well: when the number of trusted sources increases, all recipients must have their
signature database updated from a trustworthy source, which then in return has to
be trusted etc.

Furthermore, as elaborated so well by Anderson (1993), cryptographic systems tend to lead to false confidence because the real details of the system are
hidden behind obscure encodings that are kept secret: not only does this make
systems vulnerable in non-expected ways, it sometimes even helps adversaries to
remain hidden because the illegal traffic appears as yet another crypted message.
Furthermore, secrecy also helps adversaries because security organizations only
reluctantly admit to breaches of security.

The Java standard version 1.1 (Sun 1997c) includes a standardized interface to
digital signatures such that Java classes can be sent over the network in encrypted
form, so-called "jar" files (for Java Archive), originally developed to permit sending of signed applets to Sun's HotJava "secured web browser" (HotJava - The
Security Story n.d.).

This particularly means that the user can selectively open permit more operations for specific trusted code sources. This control is still based on the type system
as outlined above, so the bytecode verifier is a critical a system component as ever:

All of these techniques, however, suffer from creating a single point of failure
security-system since they all depend crucially on the trust in one, external, private
key. Moreover, the program receiver manages an often considerable amount of
trusted lists which is highly incompatible with the limited space-resources on a
Java Card.

1.6 Why not Source Code?
This is a question that often arises, and the immediate answer - that sending bytecode protects the "intellectual property" of the programmer - is easily refuted because it is simpler to reproduce Java source from the bytecode than to "unmangle"
source code where an effort has been made to "obfuscate" the meaning. Another
non-reason is the speed of execution: today interpreted languages are used in many
application areas with great success.

However, there is another very good reason which is particularly true for such
applications as Java Cards, and even more so for this masters thesis: virtual ma18 CHAPTER 1. INTRODUCTION
chines have smaller definitions than source languages. This is important because
it means that competing implementations are less difficult to make compatible, and
the source language can be extended to some extent without having to recode all
execution environments (this is how "inner classes" were added to the Java language with version 1.1, for example (Sun 1997c)). On a Java Card it is doubly
important that the implementation is small and has a stable definition, of course,
since the cost of affecting a change worldwide is prohibitive.

1.7 Goals
In this masters thesis we will attempt to go as far as possible towards a completely
formal basis for Java bytecode verification with special regard for the considerations relevant for downloading code to be executed on very limited systems such
as Java Cards. We advocate that formalization is particularly important because

ffl It is excessively expensive to reissue an application on Java Card distributed

in a large number of copies since one cannot "patch" code that is masked
into ROM. This certainly justifies the cost of some formal development!

ffl It is hoped that many different vendors will provide Java Cards and many

different implementations exist that accept the same down-loadable applet
format. For such a plethora of systems a formal model is the only sensible
common reference.

Thus a formal specification of both high-level and low-level aspects of a Java Card
sublanguage with possibility for down-loading code to the card is our primary
goal.

However, in order not to loose contact with the practical Java world we insist
on the importance of relating formal concepts to informal specifications such as
they exist.

Our specification formalism will be Natural Semantics since it is easy to read
and reason about, and because it maintains an operational approach on complete
evaluations. The formalism is summarized in Section 2.3.

1.8 Overview of the Report
In Chapter 2 we briefly summarize the concepts mentioned above as needed for
the subsequent chapters. In Chapter 3 we identify and formalize a sublanguage of
the Java Card Language, "JavaOb", which will serve as the basis for our formal
development. In the following two Chapters we derive a virtual machine subset,
"JVMOb", with an associated class file format corresponding to this subset. Chapter 4 gives the formalization of the class file format and the semantics of binaries
but the subset was driven by the translation from JavaOb in Chapter 5. In Chapter 6 we put it all together, and present our solution to how one can realize formal

1.8. OVERVIEW OF THE REPORT 19
verification of simple structural properties of JVMOb executables. Finally we conclude in Chapter 7 by summarizing our contributions, discussing related work, and
pointing out some future directions.

We have included a comprehensive index of concepts, definition, and all names
of inference rules and sorts. Furthermore the detailed index last includes all judgment forms that we define.Chapter 2

Preliminaries
In this Chapter, we introduce the concepts on which we base our semantic Java
Card sublanguage formalizations and improved Bytecode-Verification method. We
first introduce the subset of Java permitted on "Java Cards" in Section 2.1, followed
by a summary of the relevant part of the Java Virtual Machine specification in Section 2.2; in particular, we are concerned with the informal description of bytecode
safety. In Section 2.3 we explain the notion of Natural Semantics used as our semantical specification formalism, followed in Section 2.4 by the "Proof Carrying
Code" framework on which we base our card verification-techniques.

2.1 The Java Card Language
In this section we introduce the Java Card subset of the Java language defined by
Sun (Sun 1997a, Sun 1997b) to address the limitations on Smart Cards as discussed
in the introduction, and discuss its relation to the "full" Java language (Gosling, Joy
and Steele 1996), which we assume known.

The adaption of Java to the domain of Smart Cards is called the Java Card
Language and consists of three parts:

ffl A set of language restrictions discussed below.
ffl A restricted JVM, which we call JCVM (for Java Card Virtual Machine) and

discuss in the next section.

ffl A restricted API, which defines how applications, called applets (of course),

start, and what they can do. We do not discuss the API in this document but
refer the reader to the official documentation.

The language restrictions are as follows (in addition to the restrictions imposed
implicitly by the sparse memory):

ffl Class Loading is not supported - all classes must be masked into the ROM

of the card or "installed through a secure installation process after the card

20

2.2. BYTECODE VERIFICATION 21

has been issued" (what this means is not detailed in the documentation from
Sun). In general all security management is "hardwired" onto the card.

ffl The available types are severely restricted: There is no long, no float, and

no char type (and consequently no String class), and array types can only
have one dimension. Some cards will even reject int (and thus only permit
boolean, byte, and short).

ffl There are quantitative limits on several properties: classes can have at most

127 instance methods (including inherited ones), instances can have at most
255 bytes of field data, and no more than 127 bytes is available for each
method invocation frame. This last is the most severe restriction because the
invocation frame contains both the actual parameters to the method, the local
variables, and the local stack used for expression evaluation!

ffl Threads are not supported.
ffl There is no (required) garbage collector so Java Card objects, allocated with

new as usual, are categorized several ways:

Persistent objects are those that must be maintained from one CAD sessions

to the next. Persistence is contagious: when an object handle is stored
in a field in a persistent object it also becomes persistent. The Java
Card also carefully defines "transactions" such that the programmer
can ensure that persistent data is kept consistent in case of power failure
etc., by grouping updates together.

Transient Transient objects are objects that the system is permitted to reset

when power is lost (or other "major" events happen). They have the
advantage that even if they are persistent they do not transmit this to
objects they reference.

Otherwise objects can be silently cleared when power is reset because they

are then known not to be referenced (or they would be persistent), however, the Java Card Specification does not guarantee that this happens
so even temporarily allocated objects might take up space indefinitely.

In general the programmer cannot deallocate objects (and consequently finalize()
methods are ignored). So the programmer must be careful to avoid space
leaking programs, hence this is one property that we might be interested in
considering formally.

2.2 Bytecode Verification
The Java Virtual Machine is the official means of executing Java programs: it defines a binary executable file format, called the class file format, to which Java
programs are compiled. In a class file, an actual method code-sequence is residing

22 CHAPTER 2. PRELIMINARIES
in the code-array structure. Together with method-specific layout-information, i.e.,
the maximal opstack size and the maximal number of used local variables, it constitute the code-attribute, part of a method-info structure; we explain these again in
Chapter 4.

Before explaining how and when verification is done, we briefly describe the
general, chronological stages which the Java bytecode goes through when transfered over a network:

The Java transfer-units are the class files. To begin with, the Java classes of
a Java program are each translated into independent class files at compile-time.
Upon a load request, a class file is then transferred over the network, arriving at
the recipient at load-time. Then, at link-time, symbolic references are resolved.
Upon method invocation, the relevant method code from the class file is finally
interpreted by the Java Virtual Machine at runtime.

We proceed by an informal description of the notion of bytecode verification,
or, as it is properly called, class file verification, based on the official description
(Lindholm and Yellin 1996, $4.9.1).

Class-file verification ensures that a class file, received by the Java Virtual Machine, is safe. It consists of a series of check and analysis at loading, linkage,
and running time, performed in such a manner that problematic code never passes
through to runtime. The notion of wellformedness is defined in terms of two sets
of constraints (Lindholm and Yellin 1996, $4.8): static and structural. These can
be characterized as follows:

static constraints define the wellformedness of a Java class file; i.e., that the class

file adheres to the syntactic description of the basic file format

structural constraints define the relationship between the individual Java Virtual

Machine instructions within a code-array; i.e., that the method code adheres
to the restrictions set by the semantic description of the original Java class.1

The verification procedure operates in four successive phases. Generally speaking,
phase one and two check the static constraints whereas phase three and four check
the structural constraints. In this report we focus on phase three, which is known
as bytecode verification. In Table 2.1, we have listed these together with a short
characterization of their verification purpose and at which stage in the transfer cycle
they take place.

We proceed with a more detailed (though still informal) description of the third
phase. For a complete presentation we refer to the official specification (Lindholm
and Yellin 1996, $4.9.2).

In Table 2.1, we characterize bytecode verification as the link-time phase where
the code-attribute correctness of the method in question is ensured. This means,
in brief, that the method's possible runtime behavior is semantically well-defined,

1It may seem surprising that bytecode must correspond to Java programs but this is what the
specification says and was confirmed by Guy Steele at FOOL4 (Paris, January 1997).

2.2. BYTECODE VERIFICATION 23

Phase Characterization Time

1 Basic class-file representation load
2 Class-component integrity except for code-array link
3 Static type reconstruction ("bytecode verification") link
4 Dynamic checks run

Table 2.1: The class-file verification phases.

before actually running the code. Technically, this is obtained by performing a
type-based data-flow analysis of the code-array in the code-attribute, based on the
context-given class-file type-information, in fulfillment of the following structural
constraints:

Definition 2.2.1 (Bytecode Safety). We quote from (Lindholm and Yellin 1996,

$4.9.1, Pass 3)

Pass 3: Still during linking, the verifier checks the code array of the
Code attribute for each method of the class file by performing dataflow analysis on each method. The verifier ensures that at any given
point in the program, no matter what code path is taken to reach that
point:

ffl The operand stack is always the same size and contains the same

types of objects.

ffl No local variable is accessed unless it is known to contain a value

of an appropriate type.

ffl Methods are invoked with the appropriate arguments.
ffl Fields are assigned only values of appropriate types.
ffl All opcodes have appropriate type arguments on the operand

stack and in the local variables.

For further information on this pass see (Lindholm and Yellin 1996,

$4.9.2), "The Bytecode Verifier."

We will briefly clarify the use of `appropriate' in the last four items:
ffl By a local variable value of the "appropriate type", we simply understand

that the opcode of the accessing instruction must indicate a type which conforms to that of the value.

ffl By "appropriate arguments" to a method, we understand that the the number,

and the order of the types of the argument values on the operand stack, must
conform to what has been registered for that method (in the constant pool of
the class file.)

24 CHAPTER 2. PRELIMINARIES

ffl By a field-variable value of the "appropriate type", we understand that the

type of the value on the operand stack, must conform to the type which has
been registered for that field variable (in the constant pool of the class file.)

ffl By the opcodes having "appropriate type arguments", we understand that an

argument value has got a type which is identical to what is indicated by the
instruction's opcode (e.g., iload expects an integer in the local-variable table,
astore expects a reference type on the stack, etc.)

Remark 2.2.2. Technically, opcode denotes the identifying number contained in
the first byte of an instruction. Hence `opcode' and `instruction' can be used interchangeably.

Remark 2.2.3. We notice that bytecode verification is performed independently
on each method in the method table of the class file. If a method cannot pass, the
associated class file cannot be verified and is consequently rejected.

We finish by a short description of the basic ideas behind data or program
flow-analysis (Jones and Mycroft 1985), (Cousot and Cousot 1977).

Data or program flow-analysis is concerned with foreseeing a program's runtime behavior as precisely as possible without actually running it. Hence providing
us with a "safe" description of program behavior (notice that this implies a description, given with the most conservative interpretation). Since runtime information,
such as the actual input data values, isn't normally available prior to execution, the
best an analysis may provide, is information about sets of possible computations.
The essential semantical tool for describing data-flow analysis is "Collecting Semantics" (Cousot and Cousot 1977) summarized as follows by Jones and Mycroft
(1985):

The concept of a collecting semantics associates with each program
point the set of all memory states which can ever be obtained when
program control reaches that point, provided that the program is run on
data from a given (perhaps infinite) initial data space. The effect of the
program as a whole is then a function mapping a program's initial data
into a set of states at each program point. : : : The collecting semantics
is expressed in terms of a lattice of sets of program states (ordered by
inclusion),and the various approximations are expressed by simpler
lattices, connected to the program state lattice by adjoined abstraction
and concretisation functions. Flow analysis may be simply thought of
as executing the program, but over a domain of state descriptions in
the approximate lattice, instead of the precise, but infinite collecting
semantics lattice.

2.3. NATURAL SEMANTICS 25
2.3 Natural Semantics
Since our approach is operational, we chose natural semantics by Kahn (1987) as
our formal specification language. The operational modeling of the store, however,
is based on ideas by Plotkin (1981). Nevertheless we make use of domain theory
from denotational semantics to describe the sets of values of a language. In this
section we introduce the involved formal notations: functions, syntax, semantic
sorts, and finally inference rules.

Notation 2.3.1 (Lists and Quantifiers).
Lists We enumerate lists of things using notations such as x1; ::; x3 which means

x1; x2; x3. The start- and end-index can be any integers, and several components can be indexed in parallel, e.g., anbn::ambm, where n ^ m, is a
sequence of aibi groups.

As a special case we permit dummy lists on the form xn; ::; xn-1 which
denotes a list with no elements.

If we wish to indicate that we pick an element from a list we write, for example, i : 1::n, which is synonymous with i 2 f1; ::; ng, or, if n = 0, with
i 2 fg.

Quantifying over a set 8x 2 S [ px ] where px is a proposition, is true if px is true

for all x drawn from S, in particular 8x : 1::0 [ px ] is true regardless of px.
Conversely, 9x 2 S [ px ] is true if a single x can be drawn from S such that
px is true.

Notation 2.3.2 (Functions).
Partial functions. A partial function f 2 A ! B is defined as a function mapping

each element of the set A to an element of the union B [ ?, where "?" is
a special value defined such that for all x 2 A where f(x) is undefined we
say that f(x) = ?. In particular we define the domain of a partial function,
Dom(f), to be the set f x 2 A j f(x) 6= ? g. Within this report we use "function" and "partial function" interchangeably unless explicitly stated otherwise.

Empty function. ffl denotes the empty partial function with Dom(ffl) = f g (the

empty set).

Finite maps. We write f 2 A fin\Gamma ! B when f is a finite map, i.e., a function with a

finite domain. A finite map is written [a1 7! b1; a2 7! b2; : : : ; ak 7! bk] for
the map defined over fa1; : : : ; akg with f(ai) = bi for all i : 1::k. The size of
a map jfj is the number of elements in the domain, in particular jfflj = 0.

Tuples. Finite maps f with domain Dom(f) = f0; 1; : : : ; kg with k 2 N, are also

called tuples, with the special notation f = hb0; b1; : : : ; bki used interchangeably with the map notation f = [0 7! b0; 1 7! b1; : : : ; k 7! bk]. We will often
make use of the fact that jfj = k + 1.

26 CHAPTER 2. PRELIMINARIES
Notation 2.3.3 (Function Operations).
Update The function f + g is defined in terms of the functions f and g such that

(f + g)(x) = ffig(x) if x 2 Dom(g)f(x) otherwise (2.1)

Restriction The function fjS is defined by the properties Dom(fjS) = Dom(f) " S

and 8x 2 Dom(fjS) [ f(x) = fjS(x) ].

Concatenation For tuples f and g we define

(f \Delta  g)(x) = ffif(x) if x : 0:: jfj - 1g(x - jfj) otherwise (2.2)

Notation 2.3.4 (Syntax). We use BNF (Naur et al. 1960) in syntactical descriptions. Syntax productions look like

EX 2 EXAMPLE ::= EX token j ffl (2.3)
which illustrates several of our notational conventions:

ffl Alternatives are separated by "j".
ffl The empty string is denoted "ffl".
ffl Syntactic classes (nonterminal names) are written like "EXAMPLE"; metavariables denoting actual occurrences of elements of these are abbreviated
and written like "EX" in the example.

ffl For every NONTERMINAL (with metavariable NT, say) we implicitly define

the nonterminal NONTERMINAL\Lambda  by the production

NT\Lambda  2 NONTERMINAL\Lambda  ::= ffl j NT\Lambda  NT

ffl We decorate the \Lambda  with a token when this symbol plays the r^ole of an explicit

infix constructor in the repetition production. Formally this can be expressed
for a NONTERMINAL by

NT\Lambda token 2 NONTERMINAL\Lambda token ::= ffl j NTtoken\Lambda  NT

NTtoken 2 NONTERMINALtoken ::= NT token

ffl Everything else denotes terminals, either primitive tokens such as this or

members of well-known sorts such as the natural numbers, N = f0; 1; : : : g,
or the identifiers, Id = fx; y; Kristoffer; oops; : : : g.

2.3. NATURAL SEMANTICS 27
Notation 2.3.5 (Semantic sorts). Semantic sorts are defined by equations such as

s 2 SortExample = N \Theta  (Id fin\Gamma ! N) (2.4)
which defines the sort SortExample with associated metavariable s (meta-variables
can be several characters, e.g., mv). The defining equation can employ the semantic sort constructions A \Theta  B (binary tuples), A1 \Theta  \Delta  \Delta  \Delta  \Theta  An (n-ary tuples), etc, A\Lambda  (all
finite tuples analogous to the similar syntax and function notations), A? ("lifting"),
as well as the function and syntax constructions introduced above.

Furthermore we use disjoint sums written a(A) + b(B) where the a and b are
tags to make injection of elements of sort A or B, respectively (e.g., a(a) 2 a(A) +
b(B) when a 2 A). We will, however, omit the tags when they can be derived
otherwise from the sort context (e.g., if A and B are disjoint sorts to start with).

Notation 2.3.6 (Inference rules). Our notation for natural semantics (Kahn 1987)
inference rules was inspired by the rules of Milner, Tofte, Harper and MacQueen
(1997):

ffl An inference system always implements a judgment which is a particular combination of symbols and sorts defined with a syntax-like notation,
e.g., " env ` EX ) v " expresses that a set of inference rules will define propositions involving semantic values env (of an appropriate sort, say
Environment), syntactic values EX (built according to some production, say

EXAMPLE), and semantic values v (again of an appropriate sort, say Value).

ffl A judgment is defined by "rules" of the shape

J1 J2 \Delta  \Delta  \Delta  Jk

J0 C

where each of the Ji is a judgment conforming to the required form and C
is a side condition that may be any logical formula. J0 is the "conclusion"
whereas the Ji (i 6= 0), are the "premises"; if a rule has no premises (k = 0)
then it is an "axiom".

All (syntactic and semantic) meta-variables occurring are assumed universally quantified over the entire rule. We permit explicit (finite) universal
quantifications using 8 of Notation 2.3.1. In addition we use the annotation
(9 x) in side conditions to indicate the exceptional case where the side condition has a variable x which is existentially quantified, i.e., represents a value
that must be found by a search.

ffl A proof is a tree build from inference rules by instantiating all meta-variables

in the root rule such that its side condition is true (if any) and there is a
subproof tree for each instantiated premise.

ffl Further we use pattern matching, with - for meta-variables where the instantiation does not matter.

28 CHAPTER 2. PRELIMINARIES
Notice that the premise judgments of inference rules are not ordered. But they be
easier to prove in a certain sequence because of dependencies: if a given metavariable occurs in a "positive occurrence" (i.e., instantiated by a subproof) in one judgment and in a "negative occurrence" (i.e., needed for construction of the subproof)
in another judgment, then one is best served by constructing the first subproof first.
We will generally order the premises such that they are best considered in left-toright (or top-to-bottom) order.

2.4 Proof-Carrying Code
Proof-carrying code, or PCC for short, is a new technique (Necula and Lee 1996b,
Necula and Lee 1996a) for ensuring safety of code communicated over the network
where the source cannot be trusted. The constituent word should be understood as
follows:

Proof. This here means a formal proof object relative to some formal system. In

case the formal system is a logic specified by axioms and inference rules then
the proof object is a usual "proof tree" with axioms for leaves and inference
steps as branches.

Carrying. Signifies that the proof is "carried by" and thus loaded together with

the code it proves a property for, and does not necessarily make sense in
other contexts.

Code. We are concerned with proving properties for binary executable code units

such as could be produced by separate compilation. In Java the class file is
such a unit.

A code module and its associated proof object is together called a PCC binary.

To explain exactly how PCC works, and why it is safe, let us summarize the
pretext precisely: The parties involved in a PCC-based exchange are the following:

Consumer. The agent who wishes to execute the code sent over the network. In

the PCC setup the consumer is the party who needs to be convinced that the
code does not result in damage to her system, or loss of money, etcThus the
consumer is the "paranoid" party with a safety policy that must be locally
verifiable.

Producer. The agent who writes (and compiles) the code. PCC assumes that producers are interested in convincing consumers that it is safe to execute their
code (and also that they are interested in doing the least amount of work to
obtain it). Thus producers deliver code packaged with a proof that it adheres
to the safety policy.

Network. The means by which communication from producer to consumer takes

place. PCC does not assume anything about the safety of the communication
so in general it is here there is potential for tampering with the code.

2.4. PROOF-CARRYING CODE 29
Using PCC involves the stages and decisions shown in Table 2.2:

Stage Producer Consumer
0 Safety Policy Determine safety requirements and publish safety
logic in which they can be
proved formally.
Acquire proof generation
technology.

Write proof checker.

1 Certification Write code and prove adherence to safety policy in
the safety logic.
Send PCC binary.

Receive PCC binary
2 Validation Validate PCC binary by

checking proof against
safety policy.
3 Execution Execute code.

Table 2.2: Proof-Carrying Code stages.

The important characteristics of PCC is that it is consumer-driven: The consumer publishes the safety policy and then it is up to the producer to write code with
certificates that adhere to it. This should satisfy even the most paranoid consumer:

ffl The consumer only needs to trust the proof checker used locally to be convinced that the received code adheres to the safety policy. It is "tamperproof": if the code is modified the proof will fail. (If it is modified in a
harmless way, or if both proof and safety policy are modified to remain consistent, then the tamperer will, in fact, merely have produced a different PCC
binary which can be run without worries by the consumer.)

This also highlights the critical issue of the process:

ffl The safety policy really needs to be bullet-proof since it is publicly available

(at least indirectly through its presence in PCC binaries): all undesired code
behavior must violate the safety policy.

ffl The proof checker used to verify the certified code must be correct an not

itself impose risks (say by checking proofs in a way that may not terminate).

ffl Producers need to be convinced that consumers have a right to be paranoid.
So the safety logic formalism is crucial for the success: to rich a logic makes it
to difficult to create and verify the proofs and to weak a logic may not prevent all
undesired effects of code execution.

30 CHAPTER 2. PRELIMINARIES
Remark 2.4.1 (relation to digital signatures). Formally one can see digital signatures as an instance of PCC where the "logic" is a cryptographic one expressing
judgments of the form "the origin of the code object is consistent with the public
key x", the "safety policy" is the public key of the producer (since that is what the
consumer "accepts") and the "proof" is the digital signature which can be "proof
checked" by comparison with the public key. Thus the difference between PCC
and cryptographic approaches is not in the definition but

ffl philosophical - a "safety policy" such as the one sketched cannot really be

said to not require the consumer to trust the producer, and

ffl technological - the "proof checking" of a digital signature involves much

more complicated (numeric) computation than does proof checking in simple
formal logics.

Chapter 3
A Java Card Sublanguage
The purpose of this chapter is to define JavaOb, a subset of Java, strong enough for
writing down-loadable applets to be run on a Java Card.

We begin in Section 3.1 by explaining which principles are followed when
restricting the Java language. In Section 3.2 we present an abstract syntax for
the sublanguage and explain which concrete, syntactic Java features have been
omitted or made a compulsory part of the Java subset. Then we formally describe
how programs are started. Finally we introduce some general, semantic sorts and
rules in Section 3.3 to be used both in the static semantics in Section 3.4, and the
dynamic semantics in Section 3.5.

3.1 Design Issues
Our goal is to define a small, representative subset of Java. We particularly wish
to focus on the sequential and operational aspects of the object-oriented features
found in the Java Card language. The intention is to provide a clear semantics for
a study of class instances, fields and methods in a language, only providing the
Java features which are available on a Java Card. Since moreover, we are in particular focused on the Java Virtual Machine level, and because semantic simplicity
and clarity has a high priority, we drastically simplify the amplitude of the Java
Card language by leaving out many Java language features like parallel features
(threads), exceptions, packages, arrays, etc.

Formally we base our subset, in the following called JavaOb, on The Java
Language Specification, version 1.0 (Gosling, Joy and Steele 1996), respecting
the syntactic restrictions imposed by the Sun Java Card Specification, version 2.0
(Sun 1997a). (The former being the only official Java language specification.)
Consequently, our subset is intended to be more restricted than both Java (version
1.0) and Java Card (version 2.0).

Remark 3.1.1 (The subset specification-format). Because we are primarily concerned with the semantics of JavaOb, we specify the JavaOb subset syntax by its

31

32 CHAPTER 3. A JAVA CARD SUBLANGUAGE
abstract syntax, since a concrete syntax would be very complex without contributing at all to the readability of the semantic specifications.

Hence, what we mean by JavaOb being a subset of Java (within the limits of a
Java Card) is that the concrete syntax, behind the abstract one defining JavaOb,
constitutes a subset of Java. Within the limits of this master thesis, we do not go
further into showing that the abstract syntax of JavaOb has indeed been defined
upon a systematic restriction of the specification of the concrete Java syntax (to the
extend where this in fact has as been specified Gosling, Joy and Steele 1996) .

Principle 3.1.2. All JavaOb programs written in concrete Java syntax can run on
a Java System.

Specifically, we apply the following principles when restricting Java:.
ffl First of all, the subset must be defined within the limits of the Java Card

language.

ffl We aim at a subset which is semantically self-contained with respect to Java

1.0, i.e., its semantics should be fully described by the official Java language
specification (Gosling, Joy and Steele 1996).

ffl Language features which serve to organize the programming of "large" programs, e.g., multiple packages, abstract interfaces, and abstract classes are
left out, since we only are concerned with small, down-loadable applets.

ffl Language features which heavily increase the complexity of the semantic

descriptions , e.g., exceptions, arrays, and threads are omitted, in particular
those which do not in particular contribute with increased semantic insight.

ffl The type system is simplified as much as possible, without reducing the expressiveness, e.g., by excluding subtyping and implicittype conversions.

ffl Access/protection patterns and inheritance properties should be the same for

all objects in particular, since we aim at establishing a general and simplified
object model.

ffl To avoid leaving too many "magic" results to semantically unspecified "preprocessors", e.g., the use of static argument types in method invocation, we
make syntactic features, which help to clarify the semantics, an explicit and
required part of the syntax. (This is the idea behind requiring that all expressions for which the static type information is needed in the semantic context,
to be given as a cast expression.)

Notice that we do not emphasize the subset syntax to be particularly user friendly.
Firstly, because our focus is really the machine level and since our main concern is
the semantic specifications.

Within the time limits of this master thesis, and since we do not include exceptions, we decide not to treat error handling explicitly.

3.2. ABSTRACTING THE PROGRAM SYNTAX 33
Remark 3.1.3 (Error handling). Our goal is only to interpret correct JavaOb programs. Hence we are leaving erroneous programs unspecified by our semantics,
merely ensuring that no proofs can be constructed in those cases. However, adding
simple error-handler rules can be done in a straight-forward manner, due to the
compositionality of the chosen specification formalism.

We conclude this overview by presenting the intended object and store models
for JavaOb, together with our explanation of these informal concepts.

Definition 3.1.4 (The JavaOb model). By the JavaOb object model we understand
those concepts involved in order to define its objects. By the JavaOb store model
we understand the principles behind the way the object store is organized, externally as well as within the objects themselves.

Object model includes: classes, inheritance, class instances (objects in JavaOb),

instance methods with dynamic dispatch, and instance variables (fields in
JavaOb) with static lookup.

Store model organizes the store as a heap with all class instances, which in turn

organizes the class instances with instance variable.

We will attempt to separate aspects of the semantic descriptions pertaining to the
object and store models.

Remark 3.1.5. Notice that the type system of Java is the same as the Java object
model by (Abadi and Cardelli 1996). By reducing the object model for JavaOb, we
hence reduces the JavaOb type system.

3.2 Abstracting the Program Syntax
We present the JavaOb abstract syntax followed by an explanation of the syntactic
sorts, including a discussion of which syntactic features have been included and
which have been omitted; we use the notational conventions of Section 2.3 here
and in the following, and we refer to the restrictions discussed in Section 3.1. Then
follows a separate specification of program startup. Finally we give some examples
of JavaOb programs.

Definition 3.2.1 (Syntax).

P 2 PROGRAM ::= C\Lambda 

C 2 CLASS ::= class CID extends CID { F\Lambda  M\Lambda  }
CID 2 CLASSID ::= Object j ID

F 2 FIELD ::= D;
D 2 DECLARATION ::= T ID

M 2 METHOD ::= R ID( A\Lambda , ) B

34 CHAPTER 3. A JAVA CARD SUBLANGUAGE

R 2 RETURNTYPE ::= T j void
A 2 ARGDECLARATION ::= D

T 2 TYPE ::= CID j PT
PT 2 PRIMTYPE ::= boolean j int

B 2 BLOCK ::= { V\Lambda  S\Lambda  }
V 2 VARDECLARATION ::= D;

S 2 STATEMENT ::= B j SE; j return E; j return;

j if (CO) S else S j while (CO) S
CO 2 CONDITIONALS ::= E == 0 j E > 0 j E == null j E
SE 2 STATEXPRESSION ::= AC = E j new CID() j MI

E 2 EXPRESSION ::= SE j this j (E) j AC j CE j AE j L
MI 2 METHODINVOCATION ::= (CE).ID(CE\Lambda ;) j super . ID ( CE\Lambda ; )

AC 2 ACCESS ::= ID j (CE).ID
CE 2 CASTEXPRESSION ::= (T)E
AE 2 ADDITIVEEXPRESSION ::= E + E j E - E

L 2 LITERAL ::= null j PV
PV 2 PRIMVALUE ::= BL j INT
BL 2 BOOLEANLITERAL ::= true j false

INT 2 Z

ID 2 Id

PROGRAM The concept of a "Java program" is not well-defined by the official

specification (Gosling, Joy and Steele 1996). The closest thing to a definition we have found is a set of classes, where one of them includes a main
"bootstrap" method. Moreover it includes the possibility of importing several packages from the environment, interfaces and abstract classes. Since
we only deal with small card programs, we simplify this and define a JavaOb
program to be a (finite) collection of class declarations, one of these containing the bootstrap method defined in Definition 3.2.3 (however, not considered as part of the JavaOb syntax). In particular we ignore the package
concept, since packages only serve as a way to organize class definitions.
To be precise, we semantically consider a JavaOb program to behave as an
unnamed, default package in Java, i.e., only classes inside the same program
are mutually visible, and cannot be neither referenced nor imported by others. Notice, that the basic system class java.lang (Chan and Lee 1997)
is automatically included by any package in Java. Since many important
classes such as the Object class are found here, we tacitly assume that this
package is available for our JavaOb programs.

CLASS Formally, class declarations define new reference types (Gosling, Joy and

3.2. ABSTRACTING THE PROGRAM SYNTAX 35

Steele 1996, $8.1). In order to maintain a uniform and simplified access and
inheritance pattern, we omit the optional list of class access, inheritance and
application modifiers. By excluding the access modifier public we adapt
a package protection scheme (Gosling, Joy and Steele 1996, $6.6),(Lemay,
Perkins and Morrison 1996, Table 15.1). (Notice that since a JavaOb program is considered as one program in Java, package and public protection
coincide on the subset which constitute JavaOb ). By excluding final, we
obtain that all JavaOb classes can be inherited by their subclasses. We want
the class hierarchy to appear explicit at the syntactic level in JavaOb in order
to simplify our semantics (this could be replaced by a preprocessing performing the hierarchy analysis on the program). This can be obtained by making
the optional Java extends clause a compulsory part of JavaOb class declarations, indicating the direct superclass of a class. However, where Object
is given special status in that it is the only predefined class which cannot be
defined by the user. We restrict a JavaOb class body only to include declared
class members, i.e., fields and method declarations, something which prohibits the users in defining their own constructors (and static initializers). In
JavaOb, we will consequently fall back on the implicit Java default initialization pattern (Gosling, Joy and Steele 1996, $4.5.4,$8.6,$12.5). In order to
simplify our syntax, we finally require all field declarations to appear before
the method declarations in the class body, something which does not limit
the semantics since we will not allow initializers in our field declarations,
hence no side effects can appear.

CLASSID A class identifier, CID, specifies the fully qualified name of a class,

which means that it uniquely identifies the class (in a program). Since we
semantically operate with just a single, unnamed Java package, we have that
the simple name (Gosling, Joy and Steele 1996, $6.3) is the fully qualified
name (Gosling, Joy and Steele 1996, $6.7). The simple names in JavaOb are
either the special class name Object or a identifier ID.

FIELD Formally, method declarations are defined in the official specification (Gosling,

Joy and Steele 1996, $8.2,3), and represents the variables of a class. In order
to maintain a uniform and simplified access , applicability, and inheritance
pattern, we omit the optional list of field protection, inheritance or application modifiers. By excluding the access modifiers, i.e., public protected
and private, we adapt the so called package protection scheme for our
JavaOb fields (Gosling, Joy and Steele 1996, $6.6),(Lemay et al. 1996, Table
15.1). By excluding the class modifier static, we adapt our object model
to include instance variables, only. In particular obtain that all fields can be
inherited by their subclasses, by excluding final. We mention that omitting
volatile means nothing since we have excluded threads from JavaOb. We
notice, that since JavaOb programs operate as one Java package, package
protection coincide with the protection schemes for public and protected.

36 CHAPTER 3. A JAVA CARD SUBLANGUAGE

In order to simplify JavaOb field declarations syntactically, we do not allow explicit initialization, but relies on the default field initialization pattern
adapted from Java (Gosling, Joy and Steele 1996, $4.5.4,$12.5) upon instance creation.

With respect to a future extension of JavaOb we notice, that fields are only
allowed to be modified by final if variable initializers are allowed in the
field declarations.

Also notice that some redundancy has been allowed in the specification of
declarations D, since this allow us to distinguish between the conceptually
different sorts they belongs to (i.e., field declarations, local variable declarations, and method argument declarations).

METHOD Formally, method declarations are defined in the official official specification (Gosling, Joy and Steele 1996, $8.2,4), and represents the executive
parts of a class. As for fields, we omit the optional list of protection, inheritance and application modifiers, hence adapting a package protection
scheme (Gosling, Joy and Steele 1996, $6.6),(Lemay et al. 1996, Table
15.1) (which in JavaOb coincide with the protection schemes for public
and protected since we semantically only operate with one Java package).
Moreover, we only allow instance methods (not modified by static), i.e.,
methods which can only be called on a class instance (Gosling, Joy and
Steele 1996, $15.11.1) (giving access to the use of this). In particular,
this entails that method overriding is always permitted (Gosling, Joy and
Steele 1996, $8.4.6) in JavaOb. Like for variable, we want all methods to be
uniformly represented, hence being inheritable by all classes (not modified
by final). In particular we have that synchronized gives no meaning since
we have excluded parallel features (threads). Nor do native, since we are
only concerned with the study of pure Java, or abstract, since we do not
allow abstract classes. Notice, that the absence of the two latter, entails that
the body of a method must not be a ; but always a proper block (Gosling, Joy
and Steele 1996, $8.4.5). In JavaOb we have omitted the empty statement ;
because it can be replaced by the empty block, {}.

For the sake of completeness, we finally mention that the throws clause
has been omitted from our definition, since exceptions are not available in
JavaOb.

With respect to the special method main, we have excluded this from JavaOb,
and replaced it by an initial instance call with its own syntax, defined in
Definition 3.2.3. Because "bootstrap" features are not normally considered
as part of a language, it is not considered as an integral part of the JavaOb
syntax

TYPE We do not include array types, and we can use the same type production for

all declarations because there are no modifiers.

3.2. ABSTRACTING THE PROGRAM SYNTAX 37

PRIMTYPE To simplify our semantics we only included integers and booleans.

Consequently, we do not consider arithmetic conversions in the following.

BLOCK Notice that all local variables are expected to appear before the statements

of the block. This has no semantic significance because we do not permit
initializers (the sequence of initializers is important when they include side
effects).

STATEMENT Formally, statements are defined in the official specification (Gosling,

Joy and Steele 1996, $14). We have only included a representative minimum
of statement forms in JavaOb, i.e., blocks, which also mimic the empty statement, the two types of return statements, one conditional statement, and one
iteration statement. In particular JavaOb only includes the NoShortIf variants
of the conditional statements in order to avoid the "dangling else" problem
to make a single production sufficient.

CONDITIONALS Formally, conditionals are relational expressions (Gosling, Joy

and Steele 1996, $15.19). In JavaOb, those have been separated them out
since they are primarily used in conditional statements. In particular, because
the machine level only provides support for jumps based on conditional expressions. Hence it seems natural to integrate this observation to the JavaOb
source level. For example, when the Java compiler meets the assignment
b=(i>0); it must generate the same code as for

if (i>0) b=true; else b=false;
because the machine test instructions must always result in jumps. See Example A.1.4.

STATEXPRESSION Formally, statement expressions are defined in in the official

specification (Gosling, Joy and Steele 1996, $14.7,15). Again only a few,
representative forms are permitted in JavaOb, i.e., assignment, method invocation, and instance creation. In the latter we exploit that constructors are
not available in JavaOb, thus new never takes any arguments in JavaOb.

EXPRESSION Expressions are formally defined in the official specification (Gosling,

Joy and Steele 1996, $15). Here we have simplified hugely, first of all by ignoring precedence. In order to give an overview over the JavaOb expression
hierarchy, we have been "pruning" the full Java hierarchy of the expression
grammar (Gosling, Joy and Steele 1996, $19.12) in Figure 3.1, showing only
the nonterminal that are included. In addition to statement expressions we
include a representative part of expressions, i.e., self-reference, nesting, variable access, cast expressions, additive expressions, and literals. However,
leaving out exceptions since their treatment are beyond the limits of this report (however, a very interesting feature to add, as discussed in Section 7.3).

38 CHAPTER 3. A JAVA CARD SUBLANGUAGE

EXPRESSION
ASSIGNMENTr

rrrrr

rrr

CONDITIONALEXPRESSION

LLLLL
LLLL

ADDITIVEEXPRESSION

UNARYEXPRESSION
POSTFIXEXPRESSIONr

rrrrr

rrr

PRIMARYr

rrrrr

rrr

NAME
LLLLL
LLLL CASTEXPRESSION

LLLLL
LLLL

Figure 3.1: JavaOb Expression Syntax Hierarchy.
METHODINVOCATION Formally, method invocation is defined in the official specification (Gosling, Joy and Steele 1996, $15.11). In particular we the Java
MethodName-invocation forms since JavaOb has no static methods and since
a local method ID in class a CID can be invoked by ((CID)this).ID (Gosling,
Joy and Steele 1996, $15.11.1,15.11.4), which is possible to do in JavaOb .
In order to ease type checking and method lookup we require all static type
information for the method arguments are made explicit in the syntax (recall
that these are used to perform dynamic method look-up). Hence we require
all expressions, where static type information is of semantic importance, to
be given as explicit cast expressions. (one can easily imagine a type preprocess inserting the static types, in fact our typing rules check the validity of
these casts and could insert them instead).

ACCESS Formally, accesses are defined in the official specification (Gosling, Joy

and Steele 1996, $15.10,15.13.1). In order to ease recognizing the difference between local variables (or parameters) and fields at the syntactic level,
JavaOb does not permit using simple field names; instead one must write
((CID)this).ID which also works in Java (Gosling, Joy and Steele 1996,

$15.10,15.13.1). This means that simple names are always local variables
(or parameters). Moreover, as for method invocations, we require that the
primary expression, i.e., an expression which is alway of reference type
(Gosling, Joy and Steele 1996, 15.7), is a cast expression, in order to explicit the type at the syntactic level. Finally, we omit the form super.ID
since it can be replaced by ((CID 0)this).ID in JavaOb, when it occurs in
a method in a class declared by class extends CID 0{...} ( recall that

3.2. ABSTRACTING THE PROGRAM SYNTAX 39

superclass information in JavaOb is made explicit in the syntax by making
the extend clause an integral part of the language).

ADDITIVEEXPRESSION Only plus and minus is included but others can easily be

added.

Id This is the set of simple names in Java (Gosling, Joy and Steele 1996, $6.3).

Within the restrictions imposed for JavaOb, these fully describe the field
names in JavaOb field declarations, class names in JavaOb class declarations,
method names in JavaOb method declarations, etc.

Now follows a discussion of how programs are imagined to start up in JavaOb,
followed by a formal definition of the startup syntax. Notice, that this is not considered as part of the JavaOb syntax.

Discussion 3.2.2 (Program startup and input/output behavior). One of the programs in Java contains the "bootstrap" method main(), by which the program is
invoked. (In fact, main() is the method which the operating system calls at runtime in order to start the Java process which then executes the program.) However,
main() is statically defined, i.e., no heap space needs to be allocated at program
startup. In JavaOb, however, we have chosen only to include instance methods. In
order to maintain this approach, we redefine program start-up to perform a call of
an instance method ID of a newly created CID class instance. Moreover JavaOb
does not model input/output behavior so far, so we need the program to return a
value. Hence we decide that a JavaOb program accepts a set of primitive value
arguments, i.e., booleans or integers, and returns a general JavaOb value, i.e., an
object on the heap (including all objects it points to, etc) or a primitive value.

Invoking a JavaOb program hence corresponds to evaluating the code fragment

new CID().ID(CPV\Lambda )
where ID is defined within the class CID or a super class hereof.

Notice that we can semantically model the initial method call by requiring
main() to call the code fragment and adapting the input/output behavior by converting the string arguments of main() to primitive values and, e.g., by applying a
print() method before returning.

In order to ease the indication of program startup (instead of reserved names
like main()), we extend the syntax of JavaOb with a syntactic constructor startup,
taking the class from which the initial object is created as first argument, the program method name ID as second argument, and finally the primitive argument values CPV\Lambda ,.

Definition 3.2.3 (Startup sort).

st 2 STARTUP ::= startup(CID; ID; CPV\Lambda ,)
CPV 2 CASTPRIMVALUE ::= (PT)PV

40 CHAPTER 3. A JAVA CARD SUBLANGUAGE

Finally we present some small programs written in JavaOb which we pursuit
throughout the report as our canonical examples.

Example 3.2.4 (JavaOb Toy-program). This is a simple example of a class Toy
with just one method defined with one looping statement. We notice that the local
variable r is only set if the method argument is positive, otherwise left undefined.
The program is started up by calling startup(Toy; toy; (int)n)

class Toy extends Object {

int toy(int n) {

int m;
int r;
m = 0;
while (n > 0) {

n = n - 1;
r = 1;
m = m + r;
}
return m;
}
}

Example 3.2.5 (Tax computation). The tax computation discussed in the introduction (Example 1.2.1) can now be written fully out in JavaOb. We commence
with the definition of the "communications" object used to encapsulate the information that can be accessed by the applet: this needs to be standardized globally,
of course:

class Income extends Object {

ReadOnlyAmount total;
Amount tax;
Amount available;
}

where the two used classes are defined as follows in JavaOb:
class Amount extends Object {

int a;
int get() { return ((Amount)this).a; }
void set(int what) { ((Amount)this).a = what; }
}

class ReadOnlyAmount extends Amount {

void set(int what) {}
}

3.2. ABSTRACTING THE PROGRAM SYNTAX 41
where the excessive casting does not do anything but make our semantic job easier.
An example applet computing a rather limited tax algorithm using only the limited
arithmetic capabilities of JavaOb is the following:

class Tax extends Object {

boolean recalculate (Income inc) {

int rest; int tax;

if (inc == null) return false;
else {}

rest = ((Income)inc).total.get();
if (((Income)inc).total.get() - 10000 > 0) {

tax = 5000; rest = rest - 5000;
}
else

tax = 0;

((Income)inc).tax.set(tax);
((Income)inc).available.set(rest);
return true;
}
}

(it merely deducts 5000 units when the total income is above 10000, hardly a realistic taxation algorithm).

The Tax class is the part that is supposed to be downloaded, i.e., the part that
will be compiled centrally and downloaded in binary form onto the card through a
CAD. We can test it by emulating the environment it will be bexecuted in on the

ETHIC card; there it will be called by a kind of class wrapper such as the following:

class Ethic extends Object {

static Income test(int total) {

Income forTax;
Tax tax;

if (total == 0) forTax = null;
else {

forTax = new Income();
((Income)forTax).total = new ReadOnlyAmount();
((Income)forTax).total.a = total;
((Income)forTax).tax = new Amount();
((Income)forTax).tax.a = 0;

42 CHAPTER 3. A JAVA CARD SUBLANGUAGE

((Income)forTax).available = new Amount();
((Income)forTax).available.a = 0;
}

tax = new Tax();
if (((Tax)tax).recalculate((Income)forTax))

return forTax;
else

return null;
}
}

which can the be invoked using the bootstrap code
startup(Ethic,test,20000)
for trying it out with the amount 20000. (In practice the parameters will come from
another procedure running on the CAD because that is where the user must type
the input; this must also be driven by code on the card, of course, using the usual
protocol for asking data off the CAD.)

Remark 3.2.6 (package protection desired). Notice how the lack of packages here
bites us: the field a of Amount is not really protected against a malicious Tax that
sets it directly. Thus we should include package protection in order to implement
a realistic ETHIC or other Java Card applications that have protected data!

3.3 Preprocessing Semantics
We introduce some basic semantic sorts which are used in the following. In particular we aim at constructing the static information which can be retrieved from the
program prior to any static and dynamic checks. (This corresponds roughly to the
verification and consistency checks performed on the class file at machine level cf.
Section 2.2.) Notice that the specification is based on the syntactic sorts defined in
Definition 3.2.

Definition 3.3.1 (Static Sorts).

s 2 SuperClass = CLASSID fin\Gamma ! CLASSID class hierarchy

ms 2 Methods = CLASSID fin\Gamma ! MethodDecl program methods
md 2 MethodDecl = MethodSig fin\Gamma ! MethodContents method declaration

MethodSig = MethodName \Theta  ArgTypeList signature
MethodName = Id method name

ArgTypeList = TYPE\Lambda  arg types

3.3. PREPROCESSING SEMANTICS 43

MethodContents = FormalParList \Theta  MethodBody contents

FormalParList = Id\Lambda  parameter names

MethodBody = BLOCK method code

mts 2 MethodTypes = CLASSID fin\Gamma ! MethodTyping method types

mt 2 MethodTyping = MethodSig fin\Gamma ! RETURNTYPE return type

fs 2 Fields = CLASSID fin\Gamma ! FieldDecl field declarations
fd 2 FieldDecl = Id fin\Gamma ! TYPE field type
We briefly explain those sorts for which the intention is not immediate.
SuperClass is a function which to every class in a JavaOb program, except for

Object, assigns its super class (something which can be recognized from the
program syntax where the super class is always stated explicitly by extend).
Recall that classes are uniquely identified by their names in a given package
(Gosling, Joy and Steele 1996, $8.1.1), and all, except Object have a superclass. Hence s is well-defined for any JavaOb program. In the following we
can assume a uniquely defined class hierarchy for a given program.

Methods is a function which to each class in a given class hierarchy assigns the

methods declared. Since any class hierarchy for a given JavaOb program is
unique, and since all of its classes contains zero or more method declarations,
we have that ms is well-defined.

MethodDecl is a function which to every method signature in a given class assigns

the actual method contents, i.e., the locally valid, formal method parameters,
and the method body to be executed. Recall that a method signature uniquely
identifies a method within a class (Gosling, Joy and Steele 1996, $8.4.2) and
that all methods are declared with a formal parameter list and method body.
Hence md is well-defined.

MethodSig is a tuple which consists of the name of a given method and the ordered

set of its static argument types. (In JavaOb, these types are always explicitly
available, since all method arguments are required to be casted.)

ArgTypeList is a tuple which consists of the static types of the arguments.
MethodTypes is a function which to every class in a class hierarchy assigns the associated type information for its declared methods. Since any class hierarchy
for a given JavaOb program is unique, and since all of its classes contains
zero or more method declarations, mts is well-defined.

MethodTyping is a function which to every method signature in a class assigns the

associated method return type. Since method signatures are unique within
a class, and since all methods are indicated with a return type, mt is welldefined.

44 CHAPTER 3. A JAVA CARD SUBLANGUAGE
Fields is a function which for every class in the class hierarchy indicates all fields

which are declared. Since any class hierarchy for a given JavaOb program
is unique, and all of its classes contains zero or more field declarations, fs is
well-defined.

FieldDecl is a function which to every field name in a class assigns the associated

type. Since field names are unique within a class, and since all fields are
declared with their type, fd is well-defined.

These are realized by the following rules for a concrete JavaOb program P.
Definition 3.3.2 (Global semantic rules).
` P ! s; fs; mts; ms : The super-function s is defined for the JavaOb program P,

hence indirectly representing the class hierarchy of the program. Each class
in P is assigned the set of declared fields, constituting fs, the the set of return
types of declared methods, constituting mts, and the list of formal parameters and the actual method body, constituting ms.

` s; fs; mts; ms; C ! s0; fs0; mts0; ms0 : The functions s0 extends s , fs0 extends

fs, mts0 extends mts, and ms0 extends ms by adding the JavaOb class
(name) C to their domains. For the super function s0, a class is assigned its
super class. For the field declaration function fs0, a class is assigned the
set of field declarations for that class. For the method return-type function
mts0, a class is assigned the set of declared method return types for that
class. For the method contents function ms0, a class is assigned the set of
formal parameter lists and declared method bodies within that class.

` fd; F ! fd0 : The field declaration function fd0 extends fd by adding the field

name of a field declaration F to its domain, and assigning it its declared type,
assuming that all described fields in the domain are declared in the same
class.

` mt; md; M ! mt0; md0 : The functions mt0 extends mt and md0 extends md

by adding the method signature of a method declaration M to their domains.
For the method type function mt0 the method signature is assigned to the
return type, for the method contents function md0 the method signature is
assigned to the formal parameter list and the declared method body. The
latter, assuming that all described methods in the domain are declared in the
same class.

` P ! s; fs; mts; ms
8i 2 1::n [ ` si-1; fsi-1; mtsi-1; msi-1; Ci ! si; fsi; mtsi; msi ]

` C1::Cn ! sn; fsn; mtsn; msn (Program)

3.4. STATIC SEMANTICS 45
where

s0 = fs0 = mts0 = ms0 = ffl

` s; fs; mts; ms; C ! s0; fs0; mts0; ms0
8i 2 1::n [ ` fdi-1; Fi ! fdi ]
8i 2 1::k [ ` mti-1; mdi-1; Mi ! mti; mdi ]
` s; fs; mts; ms; class CID extends CID 0 { F1.:Fn M1::Mk }!

s0; fs0; mts0; ms0

(Class)

where

CID =2 Dom(s)
s0 = s + [CID 7! CID 0]
fd0 = mt0 = md0 = ffl
fs0 = fs + [CID 7! fdn]
mts0 = mts + [CID 7! mtk]
ms0 = ms + [CID 7! mdn]

` fd; F ! fd0

` fd; T ID; ! fd0 ID =2 Dom(fd); fd

0 = fd + [ID 7! T] (Field)

` mt; md; M ! mt0; md0
` mt; md; R ID(T1 ID1,::Tn IDn) B ! mt0; md0 (Method)
where

(ID; T1::Tn) =2 Dom(mt)
mt0 = mt + [(ID; T1::Tn) 7! R]
md0 = md + [(ID; T1::Tn) 7! (ID1::IDn; B)]

3.4 Static Semantics
In this Section we formally define a static semantics for JavaOb programs (cf. Remark 3.1.3). Following Section 3.1 we assume JavaOb to be semantically selfcontained, hence following the official Java Language Specification (Gosling, Joy
and Steele 1996), which we will therefore use as our canonical reference when
justifying the specified semantics choices. And as

46 CHAPTER 3. A JAVA CARD SUBLANGUAGE

In addition to the sorts introduced in Section 3.3, we present some semantic
sorts, specific to type checking.

In order to express static statement type checking semantically, we introduce a
semantic typing sort to capture where uncertainty about the return type information
is permitted and where it is not. It is defined as a semantic extension of the syntactic
specification of a method return type in Definition obsyntax.

Definition 3.4.1 (Completion sorts).

ct 2 CompletionType = RETURNTYPE + maybe(RETURNTYPE) + none
CompletionType: captures that a method must complete with a return-statement

of the appropriate kind in our semantics: it is a simple RETURNTYPE R if
the statement is guaranteed to return with that R; it is none if the statement is
guaranteed not to return with a type and it is maybe(R) if the statement may
or may not return but if it does it is with the return type R.

We introduce a type-check context abbreviation for the JavaOb static semantics.

Definition 3.4.2 (Typing context sorts).

\Delta  2 DeclContext = SuperClass \Theta  Fields \Theta  MethodTypes
\Gamma  2 LocalContext = CLASSID \Theta  Locals

ld 2 Locals = Id fin\Gamma ! TYPE

ffl \Delta  denotes the triple hs; fs; mtsi, describing the type-declaration context, for

a given JavaOb program. It consists of the associated class hierarchy given
by s, all class associated field type declarations, fs, as well as method return
type declarations, mts.

ffl \Gamma  denotes the pair hCID; ldi, describing the local type-binding context, valid

within an block. It consists of a context given class CID and the locally
declared variable types, given by the function ld.

When the class CID in \Gamma  is defined by s in \Delta , we say that the local typing
context \Gamma  exists within the typing context \Delta .

Definition 3.4.3 (Declarations).
` P : The JavaOb program P is well-typed.
` P : \Delta  : The JavaOb program P has the program type \Delta .
\Delta  ` C : In the typing context \Delta , the JavaOb class C is well-typed.

3.4. STATIC SEMANTICS 47
\Delta ; CID ` F : In a class CID which exists within the typing context \Delta , its declared

field F is well-typed.

\Delta ; CID ` M : In a class CID which exists within the typing context \Delta , its declared

method M is well-typed.

` ld; D ! ld0 : The local variable declaration function ld0 extends ld by adding

the local variable D's name to its domain, assigning it to its declared type.

` P
` P ! s; fs; mts; - ` P : hs; fs; mtsi

` P (Program)

` P : \Delta 
8i 2 1::n [ \Delta  ` Ci ]

` C1::Cn : \Delta  (Program Type)

\Delta  ` C
8j 2 1::k [ \Delta ; CID ` Fj ] 8j 2 1::k [ \Delta ; CID ` Mj ]
\Delta  ` class CID extends CID 0 { F1.:Fn M1::Mk } (Class)

\Delta ; CID ` F

\Delta ; CID ` T ID;

\Delta  = h ; fs; i
fs(CID)(ID) = T (Field)

\Delta ; CID ` M

8i 2 1::n [ ` ldi-1; Ti IDi ! ldi ] \Delta ; \Gamma  ` B : R

\Delta ; CID ` R ID(T1 ID1,::Tn IDn) B

ld0 = ffl
\Gamma  = hCID; ldni
\Delta  = h ; ; mtsi
mts(CID)(ID; T1::Tn) = R

(Method)

` ld; D ! ld0

` ld; T ID; ! ld0 ld

0 = ld + [ID 7! T] (Local Vars)

Remark 3.4.4. Notice that in the rule for class type checking (Class), the methods

48 CHAPTER 3. A JAVA CARD SUBLANGUAGE

Mj has access to its fields Fj through fs in \Delta  (i.e.by application of the class in which
the method is declared).

Definition 3.4.5 (Statements).
\Delta ; \Gamma  ` S : ct : Given that the local typing context \Gamma  exists within the typing context

\Delta , the statement S is well-typed with the completion type ct.

\Delta ; \Gamma  ` S : ct
8i 2 1::n [ Di ` di-1 ! di ] \Delta ; \Gamma 0 ` S\Lambda  : ct

\Delta ; \Gamma  ` { D1;::Dn; S\Lambda  } : ct

\Gamma  = hCID; d0i
\Gamma 0 = hCID; dni (Block)

\Delta ; \Gamma  ` SE : R
\Delta ; \Gamma  ` SE; : none (Expression Statement)

\Delta ; \Gamma  ` E : T
\Delta ; \Gamma  ` return E; : T (Value Return)

\Delta ; \Gamma  ` return; : void (Void Return)
\Delta ; \Gamma  ` CO \Delta ; \Gamma  ` S1 : none \Delta ; \Gamma  ` S2 : none

\Delta ; \Gamma  ` if (CO) S1 else S2 : none (Non-returning If)

\Delta ; \Gamma  ` CO \Delta ; \Gamma  ` S1 : R \Delta ; \Gamma  ` S2 : R

\Delta ; \Gamma  ` if (CO) S1 else S2 : R (Returning If)

\Delta ; \Gamma  ` CO \Delta ; \Gamma  ` S1 : maybe(R) \Delta ; \Gamma  ` S2 : maybe(R)

\Delta ; \Gamma  ` if (CO) S1 else S2 : maybe(R) (Maybe-returning If)

\Delta ; \Gamma  ` CO \Delta ; \Gamma  ` S : none
\Delta ; \Gamma  ` while (CO) S : none (Non-returning While)

\Delta ; \Gamma  ` CO \Delta ; \Gamma  ` S : maybe(R)
\Delta ; \Gamma  ` while (CO) S : maybe(R) (Maybe-returning While)

\Delta ; \Gamma  ` S : none
\Delta ; \Gamma  ` S : maybe(R) (Weakening Non-returning)

\Delta ; \Gamma  ` S : R
\Delta ; \Gamma  ` S : maybe(R) (Weakening Returning)

Notice that the two weakening rules corresponds to introducing the following
ordering on CompletionType for each R, and then taking the least upper bound for

3.4. STATIC SEMANTICS 49
the if-then-else statement:

maybe(R)
none???

????

R""
""""
"

In general we should only use the weakening rules when required by one of the
premises of (Maybe-returning While) or (Maybe-returning If).

Definition 3.4.6 (Statement sequences).
\Delta ; \Gamma  ` S\Lambda  : ct : Given that the local typing context \Gamma  exists within the typing context \Delta , the statement sequence S\Lambda  is well-typed and finishes with the completion type ct.

\Delta ; \Gamma  ` S+ : ct : Given that the local typing context \Gamma  exists within the typing context \Delta , the non-empty statement sequence S+ is well-typed and finishes with
the completion type ct (this is a strict sub-judgment of the previous).

\Delta ; \Gamma  ` S\Lambda  : ct

\Delta ; \Gamma  ` ffl : none (Empty Statement Sequence)

\Delta ; \Gamma  ` S+ : ct
\Delta ; \Gamma  ` S : none \Delta ; \Gamma  ` S+ : none

\Delta ; \Gamma  ` S S+ : none (Non-returning Statement Sequence)

\Delta ; \Gamma  ` S : maybe(R) \Delta ; \Gamma  ` S+ : R

\Delta ; \Gamma  ` S S+ : R (Returning Statement Sequence)

\Delta ; \Gamma  ` S : maybe(R) \Delta ; \Gamma  ` S+ : maybe(R)

\Delta ; \Gamma  ` S S+ : maybe(R)

(Maybe-returning Statement Sequence)

We should use the weakening rules when needed for (Returning Statement Sequence)
and (Maybe-returning Statement Sequence).

Definition 3.4.7 (Conditions).
\Delta ; \Gamma  ` CO : Given that the local typing context \Gamma  exists within the typing context

\Delta , the conditional expression CO is well-typed.

\Delta ; \Gamma  ` CO
\Delta ; \Gamma  ` E : int

\Delta ; \Gamma  ` E == 0 (Zero Test)

50 CHAPTER 3. A JAVA CARD SUBLANGUAGE

\Delta ; \Gamma  ` E : int

\Delta ; \Gamma  ` E > 0 (Plus Test)

\Delta ; \Gamma  ` E : CID 0
\Delta ; \Gamma  ` E == null (Null Test)

\Delta ; \Gamma  ` E : boolean

\Delta ; \Gamma  ` E (Expression Test)

Definition 3.4.8 (Statement Expressions).

\Delta ; \Gamma  ` SE : R : Given that the local typing context \Gamma  exists within the typing context \Delta , the statement expression SE : R is well-typed with the return type

R.

\Delta ; \Gamma  ` SE : R
\Delta ; \Gamma  ` ID : T \Delta ; \Gamma  ` E : T

\Delta ; \Gamma  ` ID = E : T (Local Assignment)

\Delta ; \Gamma  ` CE : CID
s ` CID ^: CID 0
\Delta ; \Gamma  ` E : T
\Delta ; \Gamma  ` (CE).ID = E : T

\Delta  = hs; fs; i
fs(CID 0)(ID) = T (Field Assignment)

\Delta ; \Gamma  ` new CID() : CID CID 2 Dom(s) (Instance Creation)
\Delta ; \Gamma  ` CE : CID 0 s ` CID 0 ^: CID 00 8i 2 1::n [ \Delta ; \Gamma  ` CEi : Ti ]

\Delta ; \Gamma  ` (CE).ID(CE1::CEn) : R (Method Invocation)

where

\Delta  = hs; ; i
mst(CID 00)(ID; T1::Tn) = R

s ` CID !: CID 0 8i 2 1::n [ \Delta ; \Gamma  ` CEi : Ti ]

\Delta ; \Gamma  ` super.ID(CE1::CEn) : R

\Delta  = hs; ; i
\Gamma  = hCID; i
mts(CID 0)(ID; T1::Tn) = R

(Super-method Invocation)

The two assignment rules assign the two expression the common type of the
declared variable type and the expression type. Notice, that this is due to the fact
that we do not consider assignment conversion in JavaOb (Gosling, Joy and Steele

3.4. STATIC SEMANTICS 51
1996, $5.2). In particular we have, that assigning a value to a field at runtime uses
the static type of the primary expression (Gosling, Joy and Steele 1996, $15.10.1)
to determine where the field is declared. (For local assign, the local context \Gamma 
uniquely determines which local variable to use.)

For method invocation, the situation is somewhat similar in that Java and hence
JavaOb, at runtime uses the static types of the arguments (Gosling, Joy and Steele
1996, $15.11) to determine which method to invoke in a given class. At runtime,
however, it is the runtime reference type of the primary expression which determines which class to lookup the method. At static time, we simply check whether
a method with the indicated signature exists within the class indicated by the static
reference type of the primary expression or one of its super-classes. Hence the
static rules here simply ensures the existence of an appropriate method, under
the assumption that the runtime class is a subclass of the compile-time class. In
Java there must be a "most specific" method fitting the signature of the invocation (Gosling, Joy and Steele 1996, $15.11.2.2), however, we do not permit (static)
subtypes to be passed as parameters hence this is not a concern for JavaOb.

Definition 3.4.9 (Expressions).
\Delta ; \Gamma  ` E : T : Given that the local typing context \Gamma  exists within the typing context

\Delta , the expression E is well-typed with the type T.

\Delta ; \Gamma  ` E : T

\Delta ; \Gamma  ` this : CID \Gamma  = hCID; i (Self)

\Delta ; \Gamma  ` E : T
\Delta ; \Gamma  ` (E) : T (Nesting)

\Delta ; \Gamma  ` ID : T

\Gamma  = h ; ldi
ld(ID) = T (Local Access)

\Delta ; \Gamma  ` CE : CID 0 s ` CID 0 ^: CID 00

\Delta ; \Gamma  ` (CE).ID : T

\Delta  = hs; fs; i
fs(CID 00)(ID) = T (Field Access)

\Delta ; \Gamma  ` E1 : int \Delta ; \Gamma  ` E2 : int

\Delta ; \Gamma  ` E1 + E2 : int (Addition)

\Delta ; \Gamma  ` E1 : int \Delta ; \Gamma  ` E2 : int

\Delta ; \Gamma  ` E1 - E2 : int (Subtraction)

\Delta ; \Gamma  ` null : Object (Null)
Definition 3.4.10 (Cast Expressions).

52 CHAPTER 3. A JAVA CARD SUBLANGUAGE
\Delta ; \Gamma  ` CE : T : Given that the local typing context \Gamma  exists within the typing context \Delta , the expression CE is well-typed with the type T.

\Delta ; \Gamma  ` CE : T
\Delta ; \Gamma  ` E : CID1 s ` CID1 ^: CID2

\Delta ; \Gamma  ` (CID2)E : CID2 (Upcast)

\Delta ; \Gamma  ` E : CID1 s ` CID2 ^: CID1

\Delta ; \Gamma  ` (CID2)E : CID2 (Downcast)

\Delta ; \Gamma  ` E : PT
\Delta ; \Gamma  ` (PT)E : PT (Primitive Cast)

The Java type-checker accepts both up- and down-casts but not cross-casts as
demonstrated by Example A.1.3.

Definition 3.4.11 (Primitive Values).
\Delta ; \Gamma  ` PV : PT : Given that the local typing context \Gamma  exists within the typing context \Delta , the expression PV is well-typed with the type PT.

\Delta ; \Gamma  ` PV : T
\Delta ; \Gamma  ` BL : Boolean (BooleanLiteral)

\Delta ; \Gamma  ` INT : int (IntegerLiteral)
Definition 3.4.12 (Subtyping).

s ` CID ^: CID 0 : Given that CID, CID 0 are within the class hierarchy represented

by s we have that CID is either a subclass of, or identical to CID 0.

s ` CID !: CID 0 : Given that CID, CID 0 are within the class hierarchy represented

by s we have that CID is a subclass of CID 0.

s ` CID ^: CID
s ` CID ^: CID (Reflexivity)
s ` CID !: CID 0
s ` CID ^: CID 0 (Strong)

3.5. DYNAMIC SEMANTICS 53

c ` CID !: CID
s ` CID !: CID 0 s(CID) = CID (Simple)
s ` CID !: CID 0 s ` CID 0 !: CID 00

s ` CID !: CID 00 (Transitivity)

3.5 Dynamic Semantics
In this Section we formally define the runtime semantics of correct JavaOb programs (cf. Remark 3.1.3). With a few exceptions, argued in Section 3.1, we have
assumed JavaOb to be semantically self-contained hence following the official Java
Language Specification (Gosling, Joy and Steele 1996), which we will therefore
use as our current reference when justifying the semantic rules.

Remark 3.5.1 (Runtime type checking). Some type checks are postponed to runtime as part of the class verification phase four (Lindholm and Yellin 1996, $4.9).
Specifically down-casts, i.e., casting to a subtype.

We present the basic semantic sorts of the JavaOb runtime structures and entities which we operate with at the dynamic source level. These are based on the
syntactic sorts of Definition obsyntax and the basic (pre-semantic) sorts specified
in Definition 3.3.1.

Definition 3.5.2 (Semantic Sorts).

oe 2 Store = Handle fin\Gamma ! Instance object store

Instance = CLASSID \Theta  FieldBindings class instance

fbs 2 FieldBindings = CID fin\Gamma ! FieldBinding instance variables

fb 2 FieldBinding = Id fin\Gamma ! Value instance variable

ae 2 Environment = LocalBinding\Lambda  local variables

lb 2 LocalBinding = Id fin\Gamma ! LocalValue local variable

lv 2 LocalValue = Value? local values

v 2 Value = Reference + Primitive value
Reference = null + Handle reference
h 2 Handle instance reference
pv 2 Primitive = INT + BL primitive constants
cs 2 CompletionState = normal + abrupt(RetValue) termination state

rv 2 RetValue = Value + voidvalue return values

We briefly explain those sorts for which the intention is not clear from the
specification.

54 CHAPTER 3. A JAVA CARD SUBLANGUAGE
Store is a function which assign the objects stored on the heap to their handles

(that is runtime references which are not null)

Instance is a tuple which consists of the object's reference type and the set of

field bindings which are valid for that object. In contrast to the list of local variable bindings, the set of valid field bindings should contain all the
fields declared in the referenced class as well as its super-classes. (This corresponding to field resolution at machine level.)

FieldBindings is a function which indicates all the field bindings declared and instantiated for a given class. These are organized after the class hierarchy: if
a class is associated a set of field bindings, all its super-classes are equally
associated a set of field bindings.

FieldBinding is a function which indicates which values the fields of a class are

dynamically bound to.

Environment is a tuple of those local variable bindings which are valid within the

scope of a given method. The tuple is expected to grow towards the right
as a stack as described in Section 2.3, and implements hence local variable
scoping.

LocalBinding is a function indicating those local variables which have been dynamically bound to a value.

LocalValue We express the fact that local variables can be uninitialized as if they

are bound to the semantic value ?. Otherwise, local variables are bound to
JavaOb values.

Value indicates the set of valid JavaOb values, i.e., references to objects, the null

reference, integers or booleans.

Reference in this report it denotes either an object handle or the null value.
Handle denotes a reference to an object. (At machine level, this is nothing but an

address into the associated object in the heap area. Hence, a formalization
going further, might describe this sort by an Address or Integer sort.)

Primitive describes the JavaOb values which are primitively typed: integers and

booleans.

CompletionState and RetValue denote in which state a JavaOb statement can terminate (Gosling, Joy and Steele 1996, $14.1). If a return-statement is encountered within a given statement, execution of this statement is terminated
(hence control is given to the context given method). This is indicated by the
semantic abrupt value. If the returning statement is returning with a JavaOb
value (i.e., the evaluated method is of some JavaOb type), this value is indicated as an argument.If the returning statement is returning with no value

3.5. DYNAMIC SEMANTICS 55

(i.e., the evaluated method is of void type), this value is indicated by a special semantic value voidvalue. If no return statements are encountered, all
statements are executed and control is only returned at the end, indicated by
the semantic value normal.

RetValue indicates the semantic values which can be returned by an abrupt statement evaluation completion.

Semantic operations We define a series of standard semantic operations: to perform dynamic look-up, update, and initialization of variables and methods.

Definition 3.5.3 (Look-up operations).

ae ` lookup(ID) ! v

ae \Delta  lb ` lookup(ID) ! v lb(ID) = v (Local Lookup Found)

ae ` lookup(ID) ! v
ae \Delta  lb ` lookup(ID) ! v ID =2 Dom(lb) (Local Lookup Nest)

s; fbs ` flookup(CID; ID) ! v

s; fbs ` flookup(CID; ID) ! v fbs(CID)(ID) = v (Field Lookup Found)

s; fbs ` flookup(CID 0; ID) ! v

s; fbs ` flookup(CID; ID) ! v ID =2 Dom(fbs(CID)); CID

0 = s(CID)

(Field Lookup Nest)

s; ms ` mlookup(CID; (ID; T\Lambda ;)) ! (ID\Lambda ;; B); CID

s; ms ` mlookup(CID; (ID; T1::Tn))!

(ID1::IDn; B); CID

ms(CID)(ID; T1::Tn) = (ID1::IDn; B)

(Method Lookup Found)
s; ms ` mlookup(CID 0; (ID; T1::Tn))!

(ID1::IDn; B); CID 00

s; ms ` mlookup(CID; (ID; T1::Tn))!

(ID1::IDn; B); CID 00

CID 0 = s(CID)
(ID; T1::Tn) =2 Dom(ms(CID))

(Method Lookup Nest)
We explain the three kinds of look-up operations, i.e., local variable look-up,
field or instance variable look-up, and method look-up.

56 CHAPTER 3. A JAVA CARD SUBLANGUAGE

ffl lookup performs a search through the context-given list of local variable

bindings, ae, and return the associated value when found. It is applied in
the context of local variable access, only, cf. Definition 3.5.16.

ffl flookup only appears in the semantic context of field access (CID)E.ID .

It performs a successive search from the static reference type CID as described in Definition 3.5.16. The search is organized by in turn inspecting
the context-given field bindings, fbs, while ascending towards the root of
the class hierarchy (object), i.e., by following the structure of the contextgiven superclass relation, s. When the variable ID is found, the associated
value is returned as result. We notice, that this require the context-given field
binding list fbs to be defined for CID. In other terms, an object must have
been created as an instance of a class which is a subclass to CID.

ffl mlookup only appears in the semantic descriptions of method invocation.

It performs a successive search from the dynamically given reference type,
as described in Definition 3.5.14. The search is organized by inspecting
the context-given method declarations, ms, for each class in turn, using
the method signature as search key. This, while ascending towards the the
root of the class hierarchy (object), i.e., by following the structure of the
context-given superclass relation, s. When the method is found, the formal
parameters, the method body, and the class in which the method is defined,
is returned as result.

Notice that all searches will eventually succeed since the use of either a local variable, field variable, or a method which has not been declared or instantiated before
has already been captured statically, i.e., at compile or load (class verification)
time. Hence there is no point in considering the failing search-case.

Definition 3.5.4 (Update operations).

` update(ae; ID; v) ! ae

` update(ae \Delta  lb; ID; v) ! (ae \Delta  lb0) ID 2 Dom(lb); lb

0 = lb + [ID 7! v]

(Local Update Found)
` update(ae; ID; v) ! ae0
` update(ae \Delta  lb; ID; v) ! (ae0 \Delta  lb) ID =2 Dom(lb) (Local Update Nest)

s ` fupdate(fbs; CID; ID; v) ! fbs

s ` fupdate(fbs; CID; ID; v) ! fbs0

ID 2 Dom(fbs(CID))
fbs0 = fbs + \Theta CID 7! (fbs(CID) + [ID 7! v])\Lambda 

(Field Update Found)

3.5. DYNAMIC SEMANTICS 57

s ` fupdate(fbs; CID 0; ID; v) ! fbs0

s ` fupdate(fbs; CID; ID; v) ! fbs0 ID =2 Dom(fbs(CID)); CID

0 = s(CID)

(Field Update Nest)

(3.1)

We explain the field and local variable update-operations, assuming that all updates will eventually ( If variables are not declared or instantiated before use, this
will already have been captured statically, i.e., at compile or load (class verification) time.)

ffl update performs a search through the context-given list of local variable

bindings, ae, and overwrites the variable when found. It is applied in the
context of local variable assign, only, cf. Definition 3.5.14.

ffl fupdate only appears in the semantic context of field assignment (CID)E.ID = v ,

cf. Definition 3.5.14, where it first performs a successive search, using the
static reference type CID, corresponding to the field look-up operation in
Definition 3.5.3 . The search is organized by in turn inspecting the field
bindings, given by the argument fbs, while ascending towards the root of
the class hierarchy (object), i.e., by following the structure of the contextgiven superclass relation s . When the variable ID is found, the actual update
is performed by overwriting it with the argument value v. We notice, that
Gosling, Joy and Steele (1996) do not mention the use of the dynamic reference type, say CIDdyn, returned by E, indicating in which class instance the
variable id is used. In order for fupdate to work, however, not only do we require that the class in which the field was found to be declared is a superclass
of CIDdyn, we also require CIDdyn to be a subclass of CID in order to ensure
that fbs is defined. Since this is part of performing a successful update, we
assume this in our definition. (One could argue, that since the dynamic reference type is not known until runtime, it would have been appropriate to
add the subtype check to our semantics. However, we have chosen only to
describe correct program evaluations, and actually it is only a guess how the
specification should have been.)

58 CHAPTER 3. A JAVA CARD SUBLANGUAGE
Definition 3.5.5 (Initialization operations).

s; fs ` newinit(CID) ! fbs

s; fs ` newinit(CID 0) ! fbs0

s; fs ` newinit(CID) ! fbs

CID 6= Object
CID 0 = s(CID)

fb = init ffi fs(CID)

where init(int) = 0

init(boolean) = false

init(CID) = null

fbs = fbs0 + [CID 7! fb]

(Field Initialization Iteration)

s; fs ` newinit(Object) ! ffl (Field Initialization Base)
newinit only appears in the context of instance creation (newCID()), cf. Definition 3.5.14, at which time all declared (instance) fields for the class and all its
super-classes, are initialized by their default values (Gosling, Joy and Steele 1996,

$4.5.4,$8.6,$12.5). The declared fields are available through fs, whereas the actual initialization is performed by the function init : TYPE ! Value, assigning
0 to (variables of) type int, false to (variables of) type boolean, and null to
(variables of) type CID, building a function of instantiated variables fbs valid for
the given class. (This actually corresponds to what happen at machine level under
field resolution.)

Program evaluation context Evaluating a JavaOb program corresponds to evaluating an initially given method, the program method, invoked with an initially
given object as described in Definition 3.2.3. It corresponds to evaluating the code
fragment

new CID().ID(CPV\Lambda )
performed in a context of the classes which constitute the program cf. Section 3.3,
and a context defining how "self" (Abadi and Cardelli 1996, Chap.6) is bound for
that method evaluation. Generally we have, that any program part is performed
within the globally valid class context defined by the program, whereas the context describing the self-binding is locally valid during execution of the associated
method.

Definition 3.5.6 (Evaluation context).

\Omega  2 ClassContext = SuperClass \Theta  Fields \Theta  Methods

\Upsilon  2 SelfContext = CLASSID \Theta  Handle

3.5. DYNAMIC SEMANTICS 59

ffl \Omega  denotes the triple hs; fs; msi, describing the (global) class context for a

given JavaOb program. It consists of the associated class hierarchy given by
s, all class associated field declarations, fs, as well as method declarations,
ms.

ffl \Upsilon  denotes the pair hCLASS; thisi where CLASS 2 CLASSID and this 2

Handle. This describes a local evaluation context, the self context, valid for
a given method evaluation. It consists of the CLASS where the method is declared (static aspect), and the self reference to the associated object with the
valid field variables (dynamic aspect). (Notice that the CLASS information is
absolutely necessary when invoking a super method cf. Definition 3.5.14.)

Remark 3.5.7. Notice, that the self-binding is what at Java Virtual Machine level
corresponds to the initially set this-reference (local variable value at index zero),
and the class-reference in the frame of the executing (instance) method. (For
further details, we refer to Section 4.5.)

When the CLASS in \Upsilon  is defined by s in \Omega , we say that the self context \Upsilon  exists
within the class context \Omega .

We now define the dynamic semantic rules for JavaOb together with some clarifying text and remarks.

Definition 3.5.8 (Programs). ` P; startup(CID; ID; CPV1::CPVk) ) v; oe :

The JavaOb program P is started up by invoking the method ID with the
primitive arguments CPV1 to CPVk on an instance of the class CID. The
output of running P is a return value v, and the resulting (object) store oe.

` P; ST ) v; oe
P ` s; fs; -; ms
s; fs ` newinit(CID) ! fbs
s; ms ` mlookup(CID; (ID; PT1; ::PTk)) ! (ID1; ::IDk; B); CID 0
\Omega ; \Upsilon  ` B; ae; oe ) cs; ae0; oe0

` P; startup(CID; ID; CPV1; ::CPVk) ) v; oe0(Program Invocation)

\Omega  = hs; fs; msi

oe = [this 7! (CID; fbs)]
\Upsilon  = \Omega CID 0; thisff
8i : 1::k [ CPVi = (PTi)PVi ]

ae = [ID1 7! PV1::IDn 7! PVn]
cs = abrupt(v)

60 CHAPTER 3. A JAVA CARD SUBLANGUAGE

The first premise builds the static class-context \Omega  from the program P as described in Definition 3.3.2. The second and third premise defines the initial (object)
store oe with just the initial object created by the newinit operation, on which the
method ID is invoked after having been looked up by the mlookup operation, hence
building the self context \Upsilon . In particular the formal parameters to ID are bound to
its argument values forming the initial (local) environment ae. The fourth premise
defines the resulting value of program evaluation as the value v returned upon completion when the method body is evaluated on the initial store in the initially given
environment. We have tacitly assumed the following:

Remark 3.5.9 (Well-formed JavaOb programs).

ffl the invoked program method ID always completes with a return value statement,

ffl CID is a class in p and ID is defined in either CID or a superclass hereof.
Definition 3.5.10 (Statements). \Omega ; \Upsilon  ` S; ae; oe ) cs; ae0; oe0 : Assume that the self

context \Upsilon  exists within the class context \Delta . Then a statement S completes
on an object store oe in an environment ae in either a "normal" or an "abrupt"
state cs with a modified store oe0 and a modified environment ae0.

\Omega ; \Upsilon  ` S; ae; oe ) cs; ae; oe
\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` return E;; ae; oe ) abrupt(v); ae0; oe0 (Value Return)

\Omega ; \Upsilon  ` return;; ae; oe ) abrupt(voidvalue); ae; oe (Void Return)

\Omega ; \Upsilon  ` SE; ae; oe ) rv; ae0; oe0
\Omega ; \Upsilon  ` SE;; ae; oe ) normal; ae0; oe0 (Expression Statement)

\Omega ; \Upsilon  ` CO; ae; oe ) true; ae0; oe0 \Omega ; \Upsilon  ` S1; ae0; oe0 ) cs; ae00; oe00

\Omega ; \Upsilon  ` if (CO) S1 else S2; ae; oe ) cs; ae00; oe00 (If True)

\Omega ; \Upsilon  ` CO; ae; oe ) false; ae0; oe0 \Omega ; \Upsilon  ` S2; ae0; oe0 ) cs; ae00; oe00

\Omega ; \Upsilon  ` if (CO) S1 else S2; ae; oe ) cs; ae00; oe00 (If False)

\Omega ; \Upsilon  ` CO; ae; oe ) true; ae0; oe0 \Omega ; \Upsilon  ` S while (CO) S; ae0; oe0 ) cs; ae00; oe00

\Omega ; \Upsilon  ` while (CO) S; ae; oe ) cs; ae00; oe00 (While True)

\Omega ; \Upsilon  ` CO; ae; oe ) false; ae0; oe0
\Omega ; \Upsilon  ` while (CO) S; ae; oe ) normal; ae0; oe0 (While False)

3.5. DYNAMIC SEMANTICS 61

\Omega ; \Upsilon  ` S\Lambda ; ae \Delta  lb; oe ) cs; ae0 \Delta  ; oe0
\Omega ; \Upsilon  ` { T1 ID1::Tn IDn S\Lambda  }; ae; oe ) cs; ae0; oe0 lb = [ID1 7! ?::IDn 7! ?](Block)

The first four statement rules introduce entities of the CompletionState, Definition 3.5.2, for JavaOb: any return-statement gives rise to an interrupted evaluation, i.e., terminating in an abrupt(v) or abrupt(voidvalue) completion state. The
former by returning a value v, the latter by returning the void non-value voidvalue.
JavaOb statement expressions and empty statements on the contrary, are said to
complete evaluation "normally", i.e., terminating in a normal completion state. We
notice that the reason why JavaOb statement expressions always terminate "normally" relies on the fact that all expressions and conditions terminate this way in
JavaOb. (Adding exception expressions, however, would introduce "abrupt" termination for expressions.) The following rules indicate what evaluation completion means for JavaOb conditional and looping statements. These are, generally
speaking, compositionally defined from the completion states of the branches, and
depends on the value of the conditional. Formally speaking we notice:

Remark 3.5.11 (Compositionality). The present (While-True) rule is neither compositional nor semi-compositional.

Evaluating a JavaOb block statement (as well as the present "While true" statement) requires that sequence-evaluation is well-defined: it corresponds to evaluating the block statement-sequence in the block's environment, extended with the
set of locally declared variables. The resulting completion state for the block statement on environment ae is that of evaluating the statement-sequence on the locally
extended environment ae \Delta  lb.

Definition 3.5.12 (Statement sequence). \Omega ; \Upsilon  ` S\Lambda ; ae; oe ) cs; ae0; oe0 : Assume that

the self context \Upsilon  exists within the class context \Delta . Then a statement sequence S\Lambda  completes evaluation on an object store oe in an environment ae
in either a "normal" or an "abrupt" state cs, with a modified store oe0 and a
modified environment ae0.

\Omega ; \Upsilon  ` S\Lambda ; ae; oe ) cs; ae; oe
\Omega ; \Upsilon  ` S; ae; oe ) normal; ae0; oe0 \Omega ; \Upsilon  ` S\Lambda ; ae0; oe0 ) cs; ae00; oe00

\Omega ; \Upsilon  ` S S\Lambda ; ae; oe ) cs; ae00; oe00

(Normal Statement Sequence)
\Omega ; \Upsilon  ` S; ae; oe ) abrupt(rv); ae0; oe0
\Omega ; \Upsilon  ` S S\Lambda ; ae; oe ) abrupt(rv); ae0; oe0 (Abrupt Statement Sequence)

\Omega ; \Upsilon  ` ffl; ae; oe ) normal; ae; oe (Empty Statement Sequence)

62 CHAPTER 3. A JAVA CARD SUBLANGUAGE

A statement sequence completes in a normal state if all constituting statements
completes in a normal state. Consequently, the empty sequence always terminates
normally. However, if just one statement completes abrupted, evaluation of the
remaining statement sequence is interrupted, and the sequence is said to complete
abruptly. In particular we have that if the the first abrupted statement (in evaluation
order) returns a value v, the whole sequence is said to return the value v. If the first
abrupted statement returns void (voidvalue) the whole sequence is said the return
void (voidvalue).

Definition 3.5.13 (Conditional Expression).
\Omega ; \Upsilon  ` CO; ae; oe ) v; ae0; oe0 : Assume that the self context \Upsilon  exists within the class

context \Delta . Then a conditional expression CO evaluates to a value v on an
object store oe and an environment ae, with a store oe0 and an environment ae0.

\Omega ; \Upsilon  ` CO; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` E; ae; oe ) 0; ae0; oe0
\Omega ; \Upsilon  ` E == 0; ae; oe ) true; ae00; oe0 (True Zero Test)

\Omega ; \Upsilon  ` E; ae; oe ) INT; ae0; oe0
\Omega ; \Upsilon  ` E == 0; ae; oe ) false; ae00; oe0 INT 6= 0 (False Zero Test)

\Omega ; \Upsilon  ` E; ae; oe ) INT; ae0; oe0
\Omega ; \Upsilon  ` E > 0; ae; oe ) true; ae00; oe0 INT ? 0 (True Plus Test)

\Omega ; \Upsilon  ` E; ae; oe ) INT; ae0; oe0
\Omega ; \Upsilon  ` E > 0; ae; oe ) false; ae00; oe0 INT ^ 0 (False Plus Test)

\Omega ; \Upsilon  ` E; ae; oe ) null; ae0; oe0
\Omega ; \Upsilon  ` E == null; ae; oe ) true; ae00; oe0 (True Null Test)

\Omega ; \Upsilon  ` E; ae; oe ) h; ae0; oe0
\Omega ; \Upsilon  ` E == null; ae; oe ) false; ae00; oe0 (False Null Test)

In order to ease compilation of while and if-statements from JavaOb to the
Java virtual machine level (actually to resemble the code generated by the SUN
compiler), we have restricted the conditional expression in those statements only
to include the above. This is justified since our main interest is the Java virtual
machine level, and since these restricted statements cover their generic use.

Definition 3.5.14 (Statement Expressions).
\Omega ; \Upsilon  ` SE; ae; oe ) rv; ae0; oe0 : Assume that the self context \Upsilon  exists within the class

context \Delta . Then a statement expression SE evaluates to a return value rv in an
object store oe and an environment ae with a modified store oe0 and a modified
environment ae0.

3.5. DYNAMIC SEMANTICS 63

\Omega ; \Upsilon  ` SE; ae; oe ) rv; ae0; oe0
\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0

` update(ae0; ID; v) ! ae00
\Omega ; \Upsilon  ` ID = E; ae; oe ) v; ae00; oe0 (Local Assign)

\Omega ; \Upsilon  ` ((CID1)E1); ae; oe ) h; ae1; oe1
\Omega ; \Upsilon  ` E2; ae1; oe1 ) v2; ae2; oe2
s ` fupdate(fbs; CID1; ID; v2) ! fbs0
\Omega ; \Upsilon  ` ((CID1)E1).ID = E2; ae; oe ) v2; ae2; oe0

\Omega  = hs; ; i
oe2(h) = (CID2; fbs)
oe0 = oe2 + [h 7! (CID2; fbs0)]

(Field Assign)

s; fs ` newinit(CID) ! fbs
\Omega ; \Upsilon  ` new CID(); ae; oe ) h; ae; oe0

\Omega  = hs; fs; i
h =2 Dom(oe)
oe0 = oe + [h 7! (CID; fbs)]

(Instance Creation)

\Omega ; \Upsilon  ` CE; ae; oe ) h0; ae0; oe0
8i 2 1::n [ \Omega ; \Upsilon  ` (Ti)Ei; aei-1; oei-1 ) vi; aei; oei ]
s; ms ` mlookup(CID0; (ID; T1::Tn)) ! (ID1::IDn; B); CID 0
\Omega ; \Upsilon 0 ` B; ae0; oen ) abrupt(rv); ae00; oe00

\Omega ; \Upsilon  ` CE.ID((T1)E1::(Tn)En); ae; oe ) rv; aen; oe00

oe0(h0) = (CID0; -)
\Omega  = hs; ; msi
\Upsilon 0 = \Omega CID 0; h0ff
ae0 = [ID1 7! v1::IDn 7! vn]
(Virtual Method Invocation)

8i 2 1::n [ \Omega ; \Upsilon  ` (Ti)Ei; aei-1; oei-1 ) vi; aei; oei ]
s; ms ` mlookup(CID 0; (ID; T1::Tn)) ! (ID1::IDn; B); CID 00
\Omega ; \Upsilon 0 ` B; ae0; oen ) abrupt(rv); ae00; oe00

\Omega ; \Upsilon  ` super.ID((T1)E1::(Tn)En); ae; oe ) rv; aen; oe00

(ae0; oe0) = (ae; oe)
\Upsilon  = hCLASS; thisi

CID 0 = s(CLASS)
\Omega  = hs; ; msi
\Upsilon 0 = \Omega CID 00; thisff
ae0 = [ID1 7! v1::IDn 7! vn]
(Super Method Invocation)

The evaluation order of JavaOb assignment expressions and their effect on
the store and environment, is assumed to reflect that of binary Java expressions
(Gosling, Joy and Steele 1996, $15.6). Briefly that is: the operands are evaluated
before the operation, and operands are always evaluated left to right. This, because
some expressions can produce side-effects. (For JavaOb these are embedded assignments and method invocations.) Formally, this is simply expressed by the order

64 CHAPTER 3. A JAVA CARD SUBLANGUAGE
of the premises because the store and environment produced by the first premise is
inherited by the second, etc.

The update for local assignment is performed by the update operation and for
field assignments by the fupdate operation of Definition 3.5.4.

We notice, that our JavaOb semantics equally allows assignment to any field in
the superclass of the actual class even though we have omitted super.ID = E from
our syntax, namely by writing (SUPERCLASS)this:ID = E, where SUPERCLASS is
the immediate superclass of the static class of the assignment, i.e., the class in
which the assignment text is.

Object creation expressions extends the store with a new class instance where
all associated instance variables are initialized by their default values. Default
variable-initialization is performed by the newinit operation of Definition 3.5.5.

Finally, method invocation deserve special mentioning since these are the only
expressions which are allowed to return nothing (void expressions) (Gosling, Joy
and Steele 1996, $15.1, $15.11). This, however, only when used as expression
statement i.e., at expression top-level. Actually, method invocation can appear in
two syntactic contexts: as a statement (SE;), or as a non-top-level expression (E).
In the latter case, a value is always expected as the result of evaluation.

Generally speaking, (virtual) method invocation evaluates in five, consecutive
steps:

1. First we evaluate the object for which the method is invoked.
2. The method arguments are evaluated, in left to right order.
3. Then, dynamic dispatch is performed by the mlookup operation using the

dynamic reference type of the object. Notice that the method is actually
found by using the name and the static argument types, the latter being made
syntactically explicit in JavaOb.

4. Finally, the method's body, a block statement, is evaluated in a new selfcontext (corresponding to a new activation frame at machine level) consisting
of the new CLASS, i.e., the class in which the invoked method was declared,
and the new this, i.e., the dynamic reference to the object.

5. There are exactly two possibilities for the invoked method to be a void expression: either if the method body completes in an abrupt(voidvalue) state,
or when it completes in a normal state. Otherwise, the expression result is
the value returned by the method.

Invoking a (super) method initiates the same event sequence except for step 3 where
dynamic dispatch is performed using the superclass of the statically given CLASS
reference type, i.e., CLASS

As remarked for the static semantics of method invocation, the method is only
guaranteed to exist if the runtime class CID0 is a subclass of the compile-time

3.5. DYNAMIC SEMANTICS 65
class (in CE). But since JavaOb has dynamic dispatch we merely search (in the
mlookup rules) for any method with the right signature. If none exists the program
is undefined.

Upon method invocation completion, we observe the following:

Observation 3.5.15. If \Upsilon  = hCLASS; thisi and oe(this) = (CID; ) at the end of
a method invocation, we have the following relation between the static CLASSreference and the instance class for the dynamically given object for which the
method was invoked.

CLASS :* CID

Definition 3.5.16 (Expressions).
\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0 : Assume that the self context \Upsilon  exists within the class

context \Delta . Then an expression E evaluates to a value v in an object store
oe and an environment ae with a modified store oe0 and a modified environment ae0.

\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` this; ae; oe ) this; ae; oe \Upsilon  = h ; thisi (Self)

\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` (E); ae; oe ) v; ae0; oe0 (Nesting)

ae ` lookup(ID) ! v
\Omega ; \Upsilon  ` ID; ae; oe ) v; ae; oe (Local Access)

\Omega ; \Upsilon  ` (CID1)E1; ae; oe ) h0; ae0; oe0 s; fbs ` flookup(CID1; ID) ! v

\Omega ; \Upsilon  ` ((CID1)E1).ID; ae; oe ) v; ae0; oe0

\Omega  = hs; ; i
oe0(h0) = (-; fbs)
(Field Access)

\Omega ; \Upsilon  ` E1; ae; oe ) v1; ae0; oe0
\Omega ; \Upsilon  ` E2; ae0; oe0 ) v2; ae00; oe00
\Omega ; \Upsilon  ` E1 + E2; ae; oe ) v; ae00; oe00 v = v1 + v2 (Addition)

\Omega ; \Upsilon  ` E1; ae; oe ) v1; ae0; oe0
\Omega ; \Upsilon  ` E2; ae0; oe0 ) v2; ae00; oe00
\Omega ; \Upsilon  ` E1 - E2; ae; oe ) v; ae00; oe00 v = v1 - v2 (Subtraction)

\Omega ; \Upsilon  ` null; ae; oe ) null; ae; oe (NullLiteral)

66 CHAPTER 3. A JAVA CARD SUBLANGUAGE

These expressions are all assumed to appear syntactically as non-top-level expression, i.e., always expected to return a value (in contrast to statement expressions as explained in Definition 3.5.14). We briefly go through the various cases.

Self expressions simply extracts the actual self-reference from the self-context.
Nesting an expression appears to be nothing than syntactic sugar: the result of
evaluating a nested expression is identic to evaluating the expression itself. Local
variable access is performed by the lookup operation, defined in Definition 3.5.3,
which simply searches for the local variable in the local environment.

Field or instance variable access uses the static reference type information of
the left operand expression to determine which class to search for the variable
(Gosling, Joy and Steele 1996, $15.10.1). This search is performed by the flookup
operation from Definition 3.5.3 in our presentation. (We notice, that the static type
information has been made explicit in JavaOb as a forced cast to the static reference
type.)

We notice, that even though we have omitted super.ID as valid syntactic construct in JavaOb, field access to a superclass can be obtained, simply by writing
(SUPERCLASS)this:ID , where SUPERCLASS is the immediate superclass of the
static class of the access expression.

The evaluation of arithmetic expressions are evaluated as binary Java operators,
i.e., operands before operators, left to right order. The null literal is already on
value-form and returned as such.

Definition 3.5.17 (Cast Expression).
\Omega ; \Upsilon  ` CE; ae; oe ) v; ae0; oe0 : Assume that the self context \Upsilon  exists within the class

context \Delta . Then the cast expression CE evaluates to a value v in an object
store oe and an environment ae with a modified store oe0 and a modified environment ae0.

\Omega ; \Upsilon  ` CE; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` E; ae; oe ) h; ae0; oe0 s ` CID1 ^: CID2

\Omega ; \Upsilon  ` (CID2)E; ae; oe ) h; ae0; oe0 oe

0(h) = (CID1; -) (Nullcast)

\Omega ; \Upsilon  ` E; ae; oe ) v; ae0; oe0
\Omega ; \Upsilon  ` (PT)E; ae; oe ) v; ae0; oe0 (Primitive Cast)

Casting at runtime is always up-casting: one cannot claim operations on an object
that it does not have. It is worth noting, however, that the actual type of an object
never changes - the cast only serves as a checkpoint. Primitive cast expressions
are only permitted if the casted expression can be evaluated to a primitive value.

Definition 3.5.18 (Primitive Values).
\Omega ; \Upsilon  ` PV; ae; oe ) pv; ae; oe : Assume that the self context \Upsilon  exists within the class

context \Delta . Then a constant expression PV evaluates to itself without changing the given object store oe and environment ae.

3.5. DYNAMIC SEMANTICS 67

\Omega ; \Upsilon  ` PV; ae; oe ) pv; ae; oe
\Omega ; \Upsilon  ` BL; ae; oe ) BL; ae; oe (BooleanLiteral)
\Omega ; \Upsilon  ` INT; ae; oe ) INT; ae; oe (IntegerLiteral)
These are the constant expressions of JavaOb, i.e., expressions which are primitively typed (Gosling, Joy and Steele 1996, $15.27). As expected, they never
modify neither store nor environment, and return themselves as their evaluation
value.

Chapter 4
A Java Virtual Machine for theSublanguage

In this chapter we formalize a subset of the Java Virtual Machine, JVMOb, chosen
to provide what is needed for the translation from the JavaOb sublanguage in Chapter 5, hence inheriting the syntactic and semantic restrictions from the source-level.
The formalizations include a static and a dynamic semantic specification where the
first is our formalization of the Bytecode Verifier.

We start by an analysis, in Section 4.1, of what safety means for bytecode and
how it is realized using types. We then identify the aspects of the Java class file
format that are relevant for JVMOb, notably the required instruction set, and define
an abstraction of it in Section 4.2. In Section 4.3 we define formally the special
Java notion of dynamic class loading, called resolution. In Section 4.4 we then
express bytecode verification formally as a type reconstruction problem. Finally, in
Section 4.5, we give the dynamic semantics formalizing how execution of JVMOb
class files works.

4.1 Bytecode Safety
In this first section we explain the formal ideas behind the official and informal
definition of bytecode safety and verification hereof (Lindholm and Yellin 1996,

$4.8-4.9). With this insight we prepare a formalization of the notion of safety, for
use in the bytecode verification rules in the following section.

Bytecode verification is concerned with foreseeing the runtime behavior of a
method well enough to guarantee its safety without actually having to run it. (By
a `method' we actually mean the bytecode of a code-array in the method table). A
natural way to analyze the behavior of a program is to study its presumed effect on
the states of the memory. The relevant part of the JVM memory which is affected
during method execution is the current stack-frame. At runtime, each program
point, indicated by the frame-PC, can be associated a frame machine-state which
describes the runtime values on operand stack and the runtime values in the local

68

4.1. BYTECODE SAFETY 69
variable-table.
Remark 4.1.1 (Ill-formed bytecode handling). We assume that a class file, to be
well-formed, is correct with respect to Java's class-file verification pass one and
two (Lindholm and Yellin 1996, $4.9.1) (summarized in Section 2.2). This means
that the class file, except for the code arrays in the method table's code-attributes,
to adhere to the syntactical description of the class file format. Since our main
focus of the bytecode verification is the data-flow analysis, we will abstract away
the initial stage, i.e., assuming that the method bytecode-sequence being verified
can be interpreted as a sequence of JVMOb-instructions, taking the right number
of arguments. (This corresponding to abstract away what is marked as stage 1,
and the static constraint check (5) in Section 2.2, listing the official specification
of bytecode safety (Lindholm and Yellin 1996, $4.9.2).) Consequently, method
bytecode-sequences which do not adhere to this are left unspecified by our semantics. We notice that adding rules to manage ill-formed bytecode cannot, unlike
error-handling discussed for JavaOb in Remark 3.1.3, be added in a trivial way,
since it requires that we re-abstract the notion of bytecode as a sequence of instructions in Definition 4.2.4 to a sequence of bytes.

Recall that bytecode verification has been defined as a type-based data-flow
analysis (cf. Section 2.2). This means that the Bytecode Verifier does not reason
over the possible current-frame states based on possible input-values but over their
abstraction by type.

Before we begin the formal discussion we demonstrate the issue with a semiformal example.

Example 4.1.2 (Frame types). int m(int p) { int x; int y;

/*1*/
if (p==0) { x = 1; /*2*/ ... }
else { y = 2; /*3*/ ... }
/*4*/
... }
This is compiled into JVMOb bytecode, of course. The program point in the
bytecode corresponding to /*1*/ can at most assume that the JVMOb local variable occupied by the parameter p is an int, symbolically we can write that

/*1*/ 7! [p 7! int; x 7! ?; y 7! ?]
where "?" means that we do not have information about the type of the local variable. After each of the two branches in the if statement we get richer information,
namely

/*2*/ 7! [p 7! int; x 7! int; y 7! ?]
/*3*/ 7! [p 7! int; x 7! ?; y 7! int]

However, when building the type list for point /*4*/ we cannot assume anything
about neither x nor y because the flow of the program might go through the branch

70 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
that did not set it. Hence the only type list we can assign to the variables at the last
point are

/*4*/ 7! [p 7! int; x 7! ?; y 7! ?]
The general principle is that if two execution paths seem to lead to two possible
frame-state types for a variable, only the one which contains less information can
be considered as `safe' in the sense that the other could cause the verifier to accept an illegal program by violating one of the instruction requirements by having
insufficient information.

In fact, it might be even worse, because the JVM (and hence JVMOb) does not
use variable names but rather local variable indices. These are not scoped except
for belonging to a single method invocation. So if the p parameter is not used any
further in the above example then an optimizing compiler can decide to reuse it's
position in the table and assign the following types:

/*1*/ 7! [p; x 7! int; y 7! ?]
/*2*/ 7! [p; x 7! int; y 7! ?]
/*3*/ 7! [p; x 7! int; y 7! int]
/*4*/ 7! [p; x 7! int; y 7! ?]

where the only thing the bytecode verifier can detect is that there is some int value
in the location shared by p and x. A similar problem occurs with variables in local
scopes: if we change the example to

void m(int p) {

/*1*/
if (p==0) { int x = 1; /*2*/ ... }
else { int y = 2; /*3*/ ... }
/*4*/
... }

then all three variables can share the same local variable entry in the frame, thus
the bytecode verifier will assign

/*1*/ 7! [p; x; y 7! int]
/*2*/ 7! [p; x; y 7! int]
/*3*/ 7! [p; x; y 7! int]
/*4*/ 7! [p; x; y 7! int]

By the way, as documented in Example A.1.5, Sun's compiler uses three local
variables for the first example, but only two for the last, corresponding to the as4.1. BYTECODE SAFETY 71
signment

/*1*/ 7! [p 7! int; x; y 7! ?]
/*2*/ 7! [p 7! int; x; y 7! ?]
/*3*/ 7! [p 7! int; x; y 7! int]
/*4*/ 7! [p 7! int; x; y 7! int]

In order to analyze how to approach this, we first formalize the JVMOb machine types. At the JavaOb source level, we have restricted ourselves only to consider booleans and integers as primitive types, and (simple) class-identifiers as our
reference types. Since booleans are represented as integers at machine-level, this
leaves us with the two latter. Furthermore, we let return-type void be presented
by V (reflecting the way it is represented in JVM (Lindholm and Yellin 1996,

$4.3.3)).

Definition 4.1.3 (Machine type sorts).

MT 2 MTYPE ::= INT j CID machine type
RMT 2 RMTYPE ::= V j MT return descriptor

where INT and CID (denoting elements of Z and CLASSID, respectively) are reused
from Definition 3.2.1.

A JVM frame-state type is a structured type construct which reflects a frame state
in terms of the types of the elements on the operand stack and in the local variabletable at some program point. Formally, this is expressed by the following semantic
sorts

Definition 4.1.4 (Frame state type sorts).

ft 2 FrameType = StackType \Theta  LvType frame-state type

st 2 StackType = MTYPE\Lambda  stack descriptor

lvt 2 LvType = MTYPE?\Lambda  local-variable descriptor

In order to provide the formal basis for specifying the Bytecode Verifier, we
apply the idea of a "collecting semantics" (Cousot and Cousot 1977) (there called
a static semantics). This implies viewing the Bytecode Verifier as a (non-standard)
collecting semantics over the abstract domain of JVM machine-state types. In
particular we have that the abstract domain can be ordered in a lattice-like structure,
reflecting the "degree of type-information" in a frame state for a program point,
i.e., the more the stack and the local variables are defined, the higher in the lattice
is the associated frame-state type depicted. The basis of this is to represent the
unknown type by the special value ?. All approximate machine value types are in

72 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
the domain

MTYPE? =

?
int???

??

Object"

"""

CID1888
???? """

" \Delta  \Delta  \Delta  CID

k\Sigma \Sigma 

\Sigma 

???? """

"

(4.1)

where the CID1; : : : ; CIDk denote all the available reference types in the usual subtype hierarchy with subtypes larger than supertypes based on the paradigm that
subtypes have more type-information. This way the ordering contains the object
hierarchy as a subtree.

The stack must always have a unique length we will not need to compare stacks
with different length, furthermore the only way the stack can grow is by the instructions pushing a value of some known type onto it, hence the stack-type can never
contain ?.

Next, the local variable table. The number of local variables is fixed to the
number mlv for each method. But each of the variables can be any member of

MTYPE?. Even if the first is always initially the class name of which the present
object is an instance (we return to this below), there is no guarantee that the code
does not reuse local variable number 0 for something else in case this is not
needed by a method.

Thus in general both the stack and local variable table types are finite tuples
of MTYPE? elements for which we can use the point-wise ordering. Figure 4.1
shows what this looks like for a particular tuple size in the simplified case where

? ? \Delta  \Delta  \Delta  ?
int ? \Delta  \Delta  \Delta  ?

XXXXXXXXXXX
XXXXXXXXXXX
X ? int \Delta  \Delta  \Delta  ?

KKKKK
KKKK

\Delta  \Delta  \Delta  ? ? \Delta  \Delta  \Delta  int

fffffffffff

fffffffffff

f

int int \Delta  \Delta  \Delta  ?

KKKKK
KKKK

XXXXXXXXXXX
XXXXXXXXXXX
X

????

? """""

\Delta  \Delta  \Delta int ? \Delta  \Delta  \Delta  int

sssss

ssss

[[[[[[[[[[[[[[[[[[
[[[[[[[[[[[[[[[[[[
[

????

? """""

\Delta  \Delta  \Delta  \Delta  \Delta  \Delta  ? int \Delta  \Delta  \Delta  int

fffffffffff

fffffffffff

f

KKKKK
KKKK

????

? """""

\Delta  \Delta  \Delta 

int int \Delta  \Delta  \Delta  int
? int \Delta  \Delta  \Delta  int

fffffffffff
fffffffffff
f

""""

" ????? int ? \Delta  \Delta  \Delta  int

sssss
ssss

""""

" ????? \Delta  \Delta  \Delta  int int \Delta  \Delta  \Delta  ?

XXXXXXXXXXX

XXXXXXXXXXX

X

""""

" ?????

Figure 4.1: Local variable table lattice structure.
only the int type is permitted. In the full ordering each simple relation, such as

4.1. BYTECODE SAFETY 73
the ? @ int illustrated, creates a similar pattern. Since MTYPE? is a pointed cpo
(complete partial ordering), and this is preserved by tupling with the point-wise
ordering (Schmidt 1986), the resulting domain is itself a pointed cpo (with the
tuple containing only ? as bottom element). We give the formal definition.

Definition 4.1.5 (Frame type order).

ffl Given MT1; MT2 2 MTYPE?. We define that MT1 is less defined than MT2,

with notation MT1 v MT2, if either MT1 = ?, or both types are classes and

MT1 ^: MT2.

ffl We extend the definition of v to FrameType as the point-wise ordering, i.e.,

ft1 v ft2, if one can obtain ft1 from ft2 by replacing a number of MTYPE?
components with less defined ones.

ffl The greatest lower bound of ft1 and ft2, written ft1 u ft2, is the unique

largest ft for which ft v ft1 and ft v ft2, and is written ft = ft1 u ft2.

Proposition 4.1.6 (Uniqueness of greatest lower bound). Divide FrameType into
disjoint subdomains FrameTypems;mlv = MTYPEms \Theta  MTYPE?mlv for all combinations of ms; mlv 2 N. The greatest lower bound ft1 u ft2 exists if and only if
the two frame types belong to the same subdivision.

This property is important because it implies two things:

ffl unicity of types found during "merge" of two types for the static semantics, the essential property ensuring that a principal type exists for the static
semantics given next: when merging we need to find ft satisfying two constraints of the form ft v ft1 and ft v ft2. Using ft = ft1 u ft2 is obviously
the "best" solution since as little information as possible is dropped.

ffl The ordering automatically encodes that the maximal stack and local variable

sizes do not change because if they differ the frame types are incomparable.

Now we can formulate our main principle based on the similarity of ^: and v :
Principle 4.1.7 (Bytecode safety is Type Inference). The basic principle of a collecting semantics in this context is explained as follows: at each program point, all
reachable frame-state types are "collected" into a set. "Reachable" means instructions that can be reached through emulation of a method execution on all
possible input types over all possible execution paths. Bytecode being safe then
means that to any program point, this semantics will assign a unique frame-state
type that satisfies all the typing constraints imposes by the instructions in the different execution paths (Lindholm and Yellin 1996, $4.8.2). Since this is all expressed
by type assignment rules, it corresponds to a type reconstruction problem, or type
inference, of the type of the stack and frame at any point.

74 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
Remark 4.1.8. The real reason why only a single (representative) frame-state type
can be related to a given program point relies on the fact of JVM that branching
conditions cannot depend on types, i.e., a type can never be split by some condition,
factoring out a subset (as would be the case with a standard collecting semantics,
i.e., over a concrete input-value domain.)

Example 4.1.9 (Dependent frame types). The following JavaOb method uses a
non-Java construct typeof (which does exist in some languages, for example the
GNU C language, FSF 1996) together with a "subtype of" non-Java relation <=:
to test whether the b argument, declared of type class C1, has a type which is a
subtype of class C2 (which does not exist in any real programming language that
we know of); the result then determines whether one or another variable is assigned
to before we continue with more complicated things (not included here):

void m(C1 b) {

/*1*/
if (typeof(b) <=: C2)) x = 0; else y = 0;
/*2*/
... }

If we assume that neither x nor y have been set before this point then the frame-type
information after the snippet depends on the frame-type before (namely whether
the class assigned to b in the frame-type is a subclass of the C class). Fortunately
Java does not have a dependent type system such as this would require.

The following remark explains that while the bytecode type system discussed
above is sufficiently simple to make data-flow analysis simple, it is still sufficiently
complex to permit interesting properties to be represented.

Remark 4.1.10. Notice that the definition of bytecode safety in terms of framestate types requires the JVM type system to be sufficiently expressive to capture
enough information about the runtime state to decide whether the code is "safe" to
execute. To be precise: the degree to which the type system captures the runtime
state defines the limits for what it means to be safe. As it turns out, the JVM
type-system used by the Verifier is not always sufficiently precise: some safety
checks have to be postponed to runtime and some complicated "safe" programs
have recently been shown to crash (we discuss this in the related work on "typesafe" Java in Section 7.2).

Consequently, the size of the initial collecting set remains constant throughout
verification. Within the scope of this thesis, we will not go further into this, but
simply argue why the initial set, upon which verification is based, consists of a
single frame-state type, namely the one given by abstracting the frame-state upon
method invocation. (If a parameter is not used, and the parameter's storage is used
elsewhere in a different way, then the initial frame-type may also be replaced by a
smaller type in the final verification typing.)

4.2. ABSTRACTING THE CLASS FILE FORMAT 75
Definition 4.1.11 (Initial frame-state type). The initial frame-state type corresponds
to the initial runtime-state upon method invocation as explained in Definition 4.5.3
(and illustrated in Figure 4.3). Since the initial state is well-defined for any method
invocation, and since any JavaOb value has a well-defined type, the initial framestate type is well-defined. It is given by the stack type st and the local variable
types lvt.

st = ffl
lvt = hACID; MT1; : : : ; MTk; ?; : : : ?i

where ffl is the empty stack type, ACID (defined in Definition 4.2.9) is the static
reference type for the class instance on which the method will be invoked, and

MT1 : : : MTk are the static types of the method arguments. We notice, that ? is the
special semantical value for an undefined local variable used as the filler for the
mlv - k local variables not yet assigned when the frame is created.

4.2 Abstracting the Class File Format
The main purpose of this section is to present a formal abstraction of the JavaOb
Virtual Machine, JVMOb, i.e., an identification of the JVMOb instruction set, the
class file, and related concepts, suitable for formally specifying the Bytecode Verifier in the following. In particular our formalizations should reflect those restrictions imposed by JavaOb through the translation in Chapter 5 (which was written
before this chapter but we recommend that it is read afterwards), and by the Java
Card Virtual Machine, JVCM, introduced in Section 2.1.

Firstly, we present the JVMOb instruction set and syntax. We compare the
restrictions imposed by JVMOb and, notably, JCVM, and list the numeric limitations for the different categories of instruction arguments. Then follows an algebraic formalization of bytecode and programming points based on the notion of an
instruction sequence. Finally, we present the abstraction of a class file for JVMOb.

Definition 4.2.1 (JVMOb instruction-syntax). The JVMOb instruction set is defined in the top part of Table 4.1 in the first column. The second column gives the
type of the parameter to the instruction, if any, whereas the third column shows the
bytes used to represent the instruction in the code-array as a sequence of numbers
in 0::255. Here, div denotes integer division and mod integer remainder (satisfying
the usual formula n = (n div q) \Theta  q + (n mod q) and 0 ^ n mod q ! q). The page
numbers refer to the definition in the specification (Lindholm and Yellin 1996, $6).
The operand types and numeric ranges are given in the lower part of the table; the
meaningful range is the values that can actually be used as argued in the following
Discussion 4.2.2.

76 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

Instruction Operand Type Machine Format Page
aconst null 1 159
aload[n] local variable index 25 (n) 160
areturn 176 163
astore[n] local variable index 58 (n) 165
checkcast[n] constant pool index 192 (n div 256) (n mod 256) 174
dup 89 198
getfield[n] constant pool index 180 (n div 256) (n mod 256) 226
goto[n] jump offset 167 (n div 256) (n mod 256) 230
iadd 96 238
iconst 0 3 242
iconst 1 4 242
ifeq[n] jump offset 153 (n div 256) (n mod 256) 247
ifgt[n] jump offset 157 (n div 256) (n mod 256) 247
ifnull[n] jump offset 198 (n div 256) (n mod 256) 250
iload[n] local variable index 21 (n) 252
invokespecial[n] constant pool index 183 (n div 256) (n mod 256) 261
invokevirtual[n] constant pool index 182 (n div 256) (n mod 256) 267
ireturn 172 273
istore[n] local variable index 25 (n) 275
isub 100 277
ldc w[n] constant pool index 19 (n div 256) (n mod 256) 292
new[n] constant pool index 187 (n div 256) (n mod 256) 318
pop 87 323
putfield[n] constant pool index 181 (n div 256) (n mod 256) 325
return 177 330

Operand Type Formal range Meaningful range
local variable index 0::255 0::30

constant pool index 0::65535 1::65534

code offset -32768::32767 -32768::32767

Table 4.1: JVMOb Instruction Codes.

4.2. ABSTRACTING THE CLASS FILE FORMAT 77
Discussion 4.2.2 (Limitations of JVMOb). The instruction set imposes some restrictions on the class files we can handle. these compare as follows to the restrictions of JVM itself (Lindholm and Yellin 1996, $4.10) and the JCVM-specific
restrictions (Sun 1997a) summarized in Section 2.1:

ffl The primitive value size is always one word in JVMOb, as it is for JCVM.

JVM has long integers and double floats that take two words.

ffl The per-class constant pool size is limited to 65534 entries by the fact that

indices into it are in 1::65534. This is similar to JVM and JCVM: entry
0 cannot be used and all indices must be less than constant pool count
which is at most 65535 (Lindholm and Yellin 1996, $4.1), so the only real
limitation is the memory size. One should note, however, that JCVM and
JVM also uses constant pool entries for the internal nodes of items which we
have abstracted away.

ffl There is no limit on the method code size but the offset interval -32768::32767

for branch instructions means that single methods with code larger than
32768 bytes are difficult to handle (and will not be handled correctly by
the translation in Chapter 5, for example). JCVM and JVM impose the restriction that the code is never larger than 65535 bytes since several tables,
notably controlling exceptions, can only specify code addresses in 0::65534.
So again the only real limitation is the memory size.

ffl In JVMOb all instructions accessing local variables give the number as a

single unsigned byte in 0::255 hence limiting the maximal number of local
variables to 256. (Basically this relies on the fact that the wide-instruction
is not included in our JVM-subset.) For JCVM the real limit is the fact
that stack frames are limited to 127 bytes so local variable indices must be
in 0::30, shared with the stack. In the full JVM the range is 0::65534 because max locals must be in 0::65535 and the last usable local variable is
at max locals - 1.

ffl The number of fields and methods of a class is not limited by JVMOb. JCVM

limits this to 255 bytes of field data thus no more than 63 fields. JVM imposes the limit 65535 because fields count and methods count must be
in 0::65535.

ffl The size of the operand stack at runtime is not limited by JVMOb. For

JCVM the stack and local variables together must be less than 127 bytes,
i.e., at most 31 words. This is much less that for JVM that just limits the
stack size to 65535 words because max stack can only be 0::65535.

ffl The complexity of method types is not constrained by JVMOb other than

indirectly by the fact that all arguments must be storable in the local variables, so in 31 words minus the stack size, similar to for JCVM. In JVM the

78 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

method descriptor format imposes a similar constraint: method arguments
(excluding the this argument for instance methods) must require 255 or
fewer words.

The bytecode concept indicates a consecutive sequence of bytes in the codearray of the Code-attribute of a method (Lindholm and Yellin 1996, $4.7.4). The
initial pass of a bytecode verification, breaks up the byte sequence into a sequence
of instructions, registering the absolute byte-position of each instruction-opcode
starting with 0 (Lindholm and Yellin 1996, $4.9.2). These called the method code's
program points.Some static constraint checks are performed in order to ensure that
the bytecode sequence can be interpreted as a sequence of instructions, taking the
right number of arguments. As argued in Remark 4.1.1, we assume that any JVMOb bytecode sequences can be specified as sequence of JVMOb instructions
hence with an associated set of JVMOb program points. This being formalized
in the following.

Remark 4.2.3. Notice that we have nothing assumed yet on the semantically correctness of the operands (e.g.whether a code-index does not point out of the codearray etc) , but only assumed that the bytecode sequence can be correctly interpreted as an instruction sequence, taking the right number of bytes as its arguments.

Definition 4.2.4 (Bytecode sorts).

C 2 CODE ::= I\Lambda  bytecode
I 2 OBINSTR ::= : : : instructions, see table 4.1

We define the set of program points as an algebraic sort.
Definition 4.2.5 (Program point sorts).

pp 2 PPoints = N bytecode program points
PP 2 PPointSets = P(PPoints) sets of pps

In fact, we can mimic the effect of this initial pass of bytecode verification
(Lindholm and Yellin 1996, $4.9.2) by the following operation, which extracts the
programming points from a given instruction sequence, formally given by C. In
particular we define jIj to be the number of opcode and operand bytes for I (as
specified in table 4.1).

Definition 4.2.6 (Program point operations).
` CtoPP(C) ! PP: The function CtoPP decodes the set of program points PP in

the bytecode sequence C.

` CtoPP h(I\Lambda ) ! PP; n: The function CtoPP h "helps" decoding the program points

given by an instruction sequence I\Lambda , including 0.

4.2. ABSTRACTING THE CLASS FILE FORMAT 79

` CtoPP(C) ! PP
` CtoPP(Ch) ! PP; n

` CtoPP(C) ! PP (Code Program Points)

` CtoPP h(I\Lambda ) ! PP; n

` CtoPP h(ffl) ! /0; 0 (Empty Sequence)
` CtoPP h(I\Lambda ) ! PP; n
` CtoPP h(I\Lambda I) ! PP 0; n0

PP 0 = PP [ fng
n0 = n + jIj (Proper Sequence)

Discussion 4.2.7 (Abstracting the class file format). We intend to define an abstract JVMOb class file format, suitable for formalizing bytecode verification. Recall that verification (primarily) performs a data-flow analysis on the declared
methods in each loaded class, based on the available, static, type information in
the actual class file and through its statically-related superclasses (Lindholm and
Yellin 1996, $4.9.2). Consequently, all type information (and any context-given
interpretation) must in particular be abstractly represented in a way which does not
abstract away issues which affects the data-flow analysis. Generally speaking we
assume the class file abstraction to follow the storage and data structures of the
existing JVM class file. However, only to the extend where the actual relation between data are reflected, hence abstracting away all internal representation. (For
the constant pool this is in particular an issue).

The instructions checkcast, ldc w, getfield, putfield, invokevirtual, and invokespecial, save their real arguments as items in the constant pool. These are formalized
as structured values, abstracting away all internal representation in the constant
pool as explained in Discussion 4.2.7.

Definition 4.2.8 (Constant pool sorts).

CP 2 CONSTPOOL ::= IT\Lambda  constant pool table

IT 2 ITEM ::= INT j FREF j MREF constant pool item
FREF 2 FIELDREF ::= fieldref(CID; ID; MT) field reference
MREF 2 METHODREF ::= methref(CID; MSIG; RMT) method invocation reference

MSIG 2 METHODSIG = hID; MT\Lambda i method identifier

These sorts are simply explained since we already analysed their contents:

CONSTPOOL, ITEM: The constant pool with items indexed from instructions with

numbers 1::65534.

FIELDREF: The argument of a getfield or putfield instruction, essentially the CID,

ID, and type of the field ACCESS.

80 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

METHODREF: The argument of an invokevirtual or invokespecial instruction, essentially the CID, ID, the argument types, and the return type of the METHODINVOCATION.

METHODSIG: Identifies a method uniquely, as for JavaOb.
Definition 4.2.8 abstracts away a lot of detail from the constant pool[] variablelength table that contains various constants of semantical interest: class names
(Lindholm and Yellin 1996, $4.2), field names, types (Lindholm and Yellin 1996,

$4.3), etcThese are defined as cp info structure entries, or simply "items", in the
table. Generally speaking, they hold either an internal Utf81 encoding (Lindholm
and Yellin 1996, $4.4.7) of some constant string value, or references into structures
holding class, field, method or type information. We simplify these as follows in
order to abstract unnecessary details away. The idea is to make several cp info
items implicit and only work with the "top-level" items we need and not the "internal" ones:

ffl Class name items with values "CID" corresponding to the CONSTANT Class

type (and the CONSTANT Utf8 which it uses to hold the actual string with the
name).

ffl Field reference items with values fieldref(CID; ID; T) (corresponding to the

type CONSTANT Fieldref which is required to link to three internal items
of type CONSTANT Class (with its implicit CONSTANT Utf8), and two items
bundled as CONSTANT NameAndType, namely the name and type descriptors
as CONSTANT Utf8 items.

ffl Method reference items with values methref(CID; MSIG; R) where MSIG is a

pair hID; T1::Tki (corresponding to the type CONSTANT Methref which is required to link to two internal items: a CONSTANT Class with the CID and
a CONSTANT NameAndType with yet another two internal CONSTANT Utf8
items: one encoding ID and one encoding T1::Tk and ID.

ffl Integer literal items with values "INT" corresponding to CONSTANT Integer

items.

We have quietly ignored the additional items in the JVM constant pool that are irrelevant for JVMOb such as access flags (since we only permit one class within
which all classes can "see" each other), Interfaces, and Attributes; we return
to this in Discussion 4.2.10.

Here is our formalization of the JVMOb ClassFile structure, based on the
official specification (Lindholm and Yellin 1996, $4.1).

1Utf8 is an expanding encoding of the Unicode (16 bit) character set (Uni 1996) that represents
sequences of (7 bit) ASCII characters as themselves.

4.2. ABSTRACTING THE CLASS FILE FORMAT 81
Definition 4.2.9 (Class file format sorts).

CFs 2 ClassFiles = CassId fin\Gamma ! Classfile

CF 2 ClassFile = CONSTPOOL \Theta  ACTUAL \Theta  SUPER class file format

\Theta  Fields \Theta  Methods

ACID 2 ACTUAL = CLASSID actual class

SCID 2 SUPER = CLASSID actual superclass

Fs 2 Fields = Id fin\Gamma ! MTYPE field-info table
Ms 2 Methods = METHODSIG fin\Gamma ! RMTYPE \Theta  CodeAttr method-info table

ca 2 CodeAttr = MaxStack \Theta  MaxLv \Theta  CODE code attribute
ms 2 MaxStack = N max stack-words
mlv 2 MaxLVar = N max lvar-words

We explain the sorts.
ClassFiles: Class files are indexed by their name.
ClassFile, ACTUAL, SUPER: Each class file contains its context in the class hierarchy, i.e., its name and that of the superclass. In addition the constants (the
constant pool format was given in Definition 4.2.8), fields, and methods.

Fields: Fields are described by their type for use in type checking and initialization

(the types were described in Definition 4.1.4).

Methods: Methods are, as in JavaOb, indexed by their method signature which

gives the return type and what is needed to execute the method.

CodeAttr, MaxStack, MaxLVar: In order to execute the code of a method we need

the size of the stack and local variable list in addition to the actual code
(described in Definition 4.2.9).

Explaining the relation to the JVM class file format (Lindholm and Yellin 1996,

$4.1) unfortunately involves comparing directly with the binary ClassFile structure format that is the only official specification. We do not compare to JCVM as
there is no special class file format for JCVM classes. (This is not needed because
there has been no need until now for exchanging classes destined for Java Cards.)

Discussion 4.2.10 (Relation to JVM class files).
magic, minor version, major version The first eight bytes of ClassFile structures contain compiler-related information which is of no semantical interest
in this context, hence omitted from our abstract format.

constant pool[] This was discussed above: the constant pool contains entries

with class names, field references, and method invocations, as used by the
instructions, where we ignore "internal" nodes.

82 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
access flags Then follows two bytes which indicate class (or interface) access

and modifier flags. Since JavaOb only permits package protected, non-final
classes (i.e., the flag has a fixed value of 0x0020), these are tacitly omitted
in our JVMOb semantics.

this class, super class Then follows two bytes which indicate the actual class

name, and two bytes which indicate its superclass name. These are in reality references into the constant pool where their fully qualified names are
represented as CONSTANT Utf8 info structures (Lindholm and Yellin 1996,

$4.4.1,4.4.7), which hold the internal (Utf8) encoding of the actual string
with the name. However, this just being an internal way to organize varying
length information we can, without loss of generality, abstract away the references and directly express the class names as the algebraic sorts ACTUAL
and SUPER.

(By name in the following, we tacitly understand a Java reference into the
constant pool which holds an internal (Utf8) encoding of the associated
string.)

Since JavaOb only operates with a single package all class names are simple
names. This restriction being carried over to the JVMOb level, permits us to
reuse the JavaOb class name sort CLASSID, when specifying the actual class
and superclass sorts. (If the actual class is Object, then no superclass must
be indicated, indicated by the distinct value 00 in Java. This, however, will
according to earlier be specified by the semantical rules where this matters.)

interfaces[] Now follows four bytes concerning interface information. Since

interfaces are omitted from JavaOb, these are omitted from our abstracted
JVMOb class file specification.

fields[] This variable-length table contains fields declared within the actual

class. Each declaration is registered in a field info (Lindholm and Yellin
1996, $4.5) structure containing access and modifier flags, field name, field
type information, and a field-attribute table with constant values (Lindholm
and Yellin 1996, $4.7). Since JavaOb only allows package-protected nonconstant instance fields, the access flags are assumed preset to 0x0000 and
the field-attribute table has no semantical meaning in this context. Since
the Java language specification defines that field names are to be uniquely
declared within a class (Gosling, Joy and Steele 1996, $8.3), we can simply express a fields table as an algebraic sort Fields defined as a (finite)
mapping from the name sort Id to the type sort MTYPE.

methods[] This variable-length table contains the methods which are declared

within the actual class. These are registered in a method info (Lindholm
and Yellin 1996, $4.6) structure containing access and modifier flags, the
method name, method argument and return type information, and a methodattribute table with code and exception information (Lindholm and Yellin

4.3. RESOLUTION SEMANTICS 83

1996, $4.7). Since JavaOb only allows package protected methods, the flag
information has no semantical meaning in this context (again it is assumed
preset to 0x0000). Moreover, JavaOb contains no exceptions, hence the only
method attribute of semantically significance is the code attribute. Following the Java language specification, a method name and its type arguments
(its "signature") is sufficient to identify a method within its class (Gosling,
Joy and Steele 1996, $8.4). Thus we express a method signature by the sort

METHODSIG, defined compositionally as a (finite) crossproduct of the name
sort Id and the argument type sorts MTYPE. Consequently, method identification can be expressed as a (finite) mapping from the identifier sort to
the return type sort RMTYPE and the code information sort CodeAttr. The
latter not only specified by an abstraction of the method body code by the
sort CODE, but also by static layout information: MaxStack for the maximal number of words which will appear on the stack during evaluation, and
MaxLv for the maximal index in the local variable table which will be accessed during evaluation.

In JVM, all classes must include one or more definitions of the special
method name <init> which defines the possible invocations of new. JavaOb
always assumes the default behavior for new, hence no <init> method is required (or supported).

attribute[] Finally comes a variable-length table with various descriptive information. However, these are not allowed to affect the semantics of the class
file cf. (Lindholm and Yellin 1996, p.89) and is therefore ignored in our abstract format. (In fact the SourceFile attribute is an exception, but since we
do not consider semantical issues where the source file needs to be identified
we tacitly ignore this.)

This concludes the definition of the abstract class file format. We give examples
of complete class files last in Chapter 5 where they are generated from our sample
JavaOb programs.

4.3 Resolution Semantics
The first thing that happens to a class file is that it gets loaded into the runtime
environment where it is to be executed. In this section we formally define a semantics of JVMOb resolution which is the generic JVM mechanism assuring that
referenced declarations are available as needed (Lindholm and Yellin 1996, $5).

Remark 4.3.1 (Dynamic loading). JVM is special in that it permits dynamic loading of classes when they are needed. There are several situations where this can
happen (Lindholm and Yellin 1996, $5.5):

ffl When JVM wishes to type check a cast or conversion involving a class which

is not loaded then it must load that class and all classes needed to ensure

84 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

that the cast is legal, i.e., that the instance-class is a sub- or supertype (as
appropriate) of the cast-class. (This might involve a search of the entire
class hierarchy!)

ffl When a class instance is created (or a class method of - field accessed) then

the class and all its superclasses must be loaded

Since our sublanguage always creates instances, and in particular starts by creating an instance, the first thing that will happen is that the class mentioned in the
startup bootstrap code is loaded.

For JVM the name-space is the entire network (in practice as mirrored by the
CLASSPATH search variable). In the simplified JVMOb setting the CFs structure
defined in the previous section plays this role.

This requires that we define the "constant" parts of the JVMOb runtime state: the
method area (Lindholm and Yellin 1996, $3.5.4) and constant pool (Lindholm and
Yellin 1996, $3.5.5). The definition of the first follows (the latter was Definition 4.2.8).

Definition 4.3.2 (Method area sorts).

MA 2 MethodArea = ACTUAL fin\Gamma ! ClassStructure all loaded classes
CS 2 ClassStructure = RunConstPool \Theta  SUPER one loaded class

\Theta  FieldOffsetTypes \Theta  Methods

RCP 2 RunConstPool = RunItem\Lambda  partially resolved CP

it 2 RunItem = ITEM + Offset + Jump possibly resolved item

off 2 Offset = N field number in fvs
jmp 2 Jump = CLASSID \Theta  METHODSIG "jump to" method
fots 2 FieldOffsetTypes = Id ! (Offset \Theta  MTYPE) field presence in instance

The individual sorts are explained as follows:
MethodArea, ClassStructure: All class files are stored in their runtime form here,

each as a structure indexed by its unique name.

RunConstPool, RunItem, Offset, Jump: The constant pool is initially the same as

in the class file, however, as fields and methods are resolved, the items get
replaced by "offsets", giving a field's number directly, and "jumps", locating
a start of the method directly.

FieldOffsetTypes: Assigns a numeric position and a type to each field (declared by

a class) into the field area of an instance.

We specify resolution below in the two cases where it is needed for JVMOb: class
resolution and field reference resolution. Only the latter requires a decision.

4.3. RESOLUTION SEMANTICS 85
Principle 4.3.3 (Field offset order). We will number fields such that fields in superclasses are allocated before their subclasses, i.e., with lower offset numbers:
this is the only useful choice since it makes the field numbering static, i.e., the field
number does not depend on the instance class.

Definition 4.3.4 (Resolution rules).
CFs ` MA + CID  MA0 : Resolve the class file for CID in CFs, if necessary

loading it and adding it to the method area MA thus extending it to MA0.

CFs ` MA + FREF  MA0; off : Resolve the field reference FREF in CFs to the

field offset off, if necessary loading classes, adding it to the method area
MA thus extending it to MA0.

CFs ` MA + CID  MA0
CFs ` MA + Object  MA (Object Class Resolution)
CFs ` MA + CID  MA CID 2 Dom(MA) (Class Reresolution)

CFs ` MA + CID 0  MA0
CFs ` MA + CID  MA00

CID =2 (Dom(MA) [ fObjectg)
CFs(CID) = \Omega CP; ; CID 0; Fs; Msff
MA0(CID 0) = \Omega  ; ; fots0; ff
n = fififots0fifi
Fs = [ID0 7! MT0; ::; IDk-1 7! MTk-1]
fots00 = fots0 + [ID0 7! hn; MT0i ; ::; IDk-1 7! hn + k; MTk-1i]
MA00 = MA0 + [CID 7! \Omega CP; CID 0; fots00; Msff]

(Class Load)

CFs ` MA + off  MA + off

CFs ` MA + off  MA; off (Field Reresolution)

CFs ` MA + FREF  MA + off

CFs ` MA + CID ! MA0
CFs ` MA + CID.ID  MA0 + off

MA0(CID) = h ; ; fots; i
foffs(ID) = hoff; MTi

(Field Resolution)

The first two rules simply state that we neither need to load the (builtin) Object
class nor a class which is already loaded. The third rule is where class loading

86 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
happens (the first side condition establishes that it is needed), in the following
steps:

ffl "Load" the class by getting the class file from CFs.
ffl Resolve the superclass.
ffl Extract the field offset assignment fots0 from the superclass.
ffl Add the fields declared in the class after those in the superclass, i.e., from

offset n and onwards

ffl Store the complete field offset assignment fots00 in the now resolved class's

structure.

The fourth rule merely ensures that an already-resolved field reference is not resolved again; In JVM this corresponds to the "optimized" getfield quick and putfield quick variants of the JVM instructions (Lindholm and Yellin 1996, $9.2), we
do not, however, consider rewriting the code as JDK does. The last rule resolves
a field reference by a simple lookup in the field offset assignment of the resolved
class. There is no rule with jmp since it is not possible to resolve a Jump.

Notice how the field offset assignment construction resolution follows the same
pattern as the field lookup rules for JavaOb of Definition 3.5.3, but JVM does the
lookup once only because the number (corresponding to the depth of the lookup
search) is precomputed and stored in the resolved class structure.

Essentially this is because field lookup is static and means that fields are almost
as effective to use as local variables once resolved: they require adding a pointer
(the object handle) and an offset.

Remark 4.3.5 (Method resolving). Method resolving is completely dynamic so
nothing can be "precomputed" and hence defined here. If we changed the representation of the method area to be more low-level, for example using absolute
memory addresses for the method area code.

4.4 Static Semantics
In this section we formally define a static semantics of JVMOb class files which
have been through pass one and two of the class file verification procedure (Lindholm
and Yellin 1996, $4.9.1) as summarized in Section 2.2. This is a formalization of
bytecode verification. In particular we assume that JVMOb is semantically selfcontained with respect to JCVM and thus JVM, hence we will heavily base our
formalization and algebraic abstractions on the official bytecode verification specifications (Lindholm and Yellin 1996, $4.9.1,4.9.2). This, however, within the restrictions imposed by the Java Card context as described in Remark 4.2.2.

First, we discuss the approach to take for a static formalization of JVMOb.
Then we formalize the semantics of type checking, i.e., verifying that a given preconstructed type is correct for the class file. We conclude with briefly arguing

4.4. STATIC SEMANTICS 87
formally why such a type can always be constructed using generic data-flow analysis techniques; how is the subject of the next chapter. This together constitutes
the Bytecode Verifier semantics, i.e., the static semantics of JVMOb according to
Principle 4.1.7. We conclude the section with two examples.

Discussion 4.4.1 (Formalization strategy and welltypedness). In Section 4.1 we
explained the concept of bytecode safety based on the official specification, i.e., as
the result of performing a data-flow analysis on each method bytecode. We explained that this is not a data-flow analysis on the concrete value set which can be
assigned each program point based the possible input values, but a data-flow analysis on the abstracted domain of value types which can be assigned each program
point based on the initial frame-state type. In particular we concluded, that the
set of abstracted frame-state types at each program point of a method, could only
contain one element. This, being the unique descriptor, casually mentioned in the
official specification.

By narrowing down the formal theory behind bytecode verification, we have
thus been enabled to apply well-established methods and well-known statements
(Muchnick 1997, Chap.8). In particular it permit us to regard data-flow analysis
as a fixed point iteration over the set of frame-state types. (Each new iteration
caused by a branch or jump-instruction). This data-flow analysis thus in reality
implements the type reconstruction of the frame-state types which at the end are
assigned each program point.

We observed, that since the set of possible frame-state types is finite for a given
method, the set of possible frame-state types is finite, and hence the number of
method descriptors one can enumerate for a given method. Consequently, bytecode
verification can be seen as the process of going through the set of possible method
descriptors and the process of checking whether the given frame-state types of each
method descriptor adheres to the semantics of the single instructions in the method
code. (Notice, that such an enumeration does not guarantee to find us the least
fixed point method-descriptor, but only to find us a method-descriptor, depending
on the enumeration algorithm.)

We conclude that bytecode verification can be regarded as an iterative phase,
launching all possible method descriptors in turn, and a phase where these descriptors are checked. The latter being nothing but type checking of the frame-state types
which can be assigned each program point. Since our main focus is on the correctness of our formalizations merely than on efficiency, we will split our formalization according to the two phases sketched above: first by formalizing a Bytecode
Checker, which checks that a given method type descriptor, given by bcv, satisfies
the bytecode safety requirements. Then by briefly formalizing an iterative part
which for all methods enumerate the possible bcv. Together with the checker, this
constitute a complete formalization of the "Bytecode Verifier".

Notice, that we have formalized bytecode verification per class as well as per
method. (We imagine that a class will be rejected if simply one of its methods fail
to be bytecode verified, though this assumption is left unspecified by the official

88 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
specification.)

We proceed by formalizing the check of welltypedness for a bytecode sequence
based on the above discussion.

Notation 4.4.2. Since we deal with a low-level language we will use the usual ":"
for typing with the meaning "is well-typed with the typing", since the indicated
type is sometimes a type for more than just what is specified.

Definition 4.4.3 (Descriptor type sorts).

bcvs 2 BCVs = CLASSID fin\Gamma ! BCV program type descriptor

bcv 2 BCV = METHODSIG fin\Gamma ! MDescr class type descriptor
md 2 MDescr = PPoints fin\Gamma ! FrameType method type descriptor

BCVs is a function which assigns a class type descriptor to each of a collection of

classes (probably produced by translating a JavaOb program). In particular
we decide that no class type descriptor is assigned to Object.

BCV is a function which assigns a method descriptor to each method signature in

a class file. Since all method signatures uniquely identify a method in a class
file and since only one type descriptor can be assigned to a correct method,
the function is well-defined. We will thus say that a class "has type" bcv if
its individual methods can be typed by bcv.

MDescr is a function which assigns frame-state types to program points of a

method. Since only one frame-state type is assigned a program point of a
correct method, the function is well-defined. Similarly We will say that a
method "has type" md if its individual program points can be typed by bcv.

Remark 4.4.4. Notice that an algebraic specification of md is not sufficient for
stating the existence of a unique method type-descriptor for all method program
points because md by definition is defined as a partial function cf. Section 2.3.5.
Only if md can be stated as total over the set of used program points for a given
method's code, the method code is verified.

First we introduce a type-check context abbreviation for the JVMOb bytecode
checker semantics.

Definition 4.4.5 (Typing context sorts).

\Xi  2 StatMethInfo = SuperClass \Theta  CONSTPOOL

\Theta  MaxStack \Theta  MaxLVar \Theta  RMTYPE

s 2 SuperClass = CLASSID fin\Gamma ! CLASSID

4.4. STATIC SEMANTICS 89

ffl \Xi  denotes the quintuple hs; CP; ms; mlv; RMTi with all relevant static (load

time) information for a given method bytecode sequence to be type checked:
the context given class hierarchy given by s, the context given constant pool

CP with types for the method's access and invocation instructions, the maximal stack size ms, the maximal local variable size mlv, and finally the return
type for that method.

ffl s is the function denoting the superclass of each class (and thus undefined

for Object), defined by the single rule

CFs ` s

CFs ` s

s = ss2 ffi CFs
ss2 h ; ; SCID; ; i = SCID (Superclass Hierarchy)

ffl Finally we will permit implicit use of the ` and ^: orderings relative to the

s which is always present.

We can now present a formal specification of bytecode checking. Notice that
we merely express checking a single class, corresponding to phase three of a classfile verification (Gosling, Joy and Steele 1996, $4.9.1) (only that we here treat type
checking instead of verification).

Remark 4.4.6. If other classes in the class hierarchy need to be checked as part of
the class-file checking, this is done when needed by an explicit check-rule and not
in advance. (This corresponding to the dynamic class-file loading "on demand"
during bytecode verification).

Definition 4.4.7 (Bytecode class-check rules).
` CFs : The class file collection CFs is well-typed.
s ` bcv : The class type descriptor bcv is valid for a class within the class hierarchy described by s. (For the moment we leave this as an "oracle" that will
just magically "guess" a legal class type-descriptor for a class in the class
hierarchy).

s ` CF : bcv : The class file CF in the class hierarchy described by s is well-typed

with the class-file type-descriptor bcv.

` CFs
CFs ` s 8CID : Dom(CFs) [ s ` CFCID : bcvCID ]

` CFs (Class Collection Check)

90 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

s ` CF : bcv
s ` bcv
8 MSIG 2 Dom(Ms) [s ` CP; ACID; Ms; MSIG : bcv]

s ` CF : bcv (Class Check)

CF = \Omega CP; ACID; CID 0; Fs; Msff
This rule says that the class file CF is well-typed with bcv only if all its methods
given by MSIG are well-typed by bcv within the class hierarchy described by s.

The following rule formalizes bytecode checking at the method-level, again the
"type" bcv covers more than just the method in question.

Definition 4.4.8 (Bytecode method check rules).
s ` CP; ACID; Ms; MSIG : bcv : The method indicated by MSIG, belonging to a class

named ACID, is well-typed by the class-file type-descriptor bcv, if ACID is
a class in the class hierarchy defined by s, with the constant pool CP and
method array Ms.

s ` CP; ACID; Ms; MSIG : bcv
\Xi  ` o/; 0; C : md ! PP
s ` CP; ACID; Ms; MSIG : bcv (Method Check)

bcv(MSIG) = md

MSIG = hIDMSIG; MT1 MSIG : : : MTn MSIGi
Ms(MSIG) = hRMT; hms; mlv; Cii

\Xi  = hs; CP; ms; mlv; RMTi
Dom(lvt) = f 0; : : : ; mlv - 1 g

lvt = hACID; MT1; : : : ; MTn; ?; : : : ; ?i
md(0) = hffl; lvti
Dom(md) = PP

It is the side conditions of this rule which define what it means, formally, that
the method indicated by MSIG is "safe". The first condition extracts the relevant
method frame-type descriptor md from bcv. The next two simply expands the
relevant method declaration structurally, and the fourth define the actual method
typing-context when checking the method code C. Then follows two side conditions which define the initial frame-state type for C following Definition 4.1.11,
and a third which performs an initial check of program point 0: the a priori given
frame-state type at this point md(0) must be the initial frame-state type for the

4.4. STATIC SEMANTICS 91
the method bytecode. The question of whether C is safe or not, however, relies
crucially on the last condition: only if all program points of C can be checked successfully against md we can consider the method bytecode to be "safe". Another
way to express this is to say that md must be total on the set of all program points
of the method bytecode sequence C (which is not given a priori cf. Remark 4.4.4).
Formally this is specified as:

Proposition 4.4.9 (Totality of md). The method bytecode-checker semantics specifies that PP in judgment (Method Check) satisfies

PP = CtoPP(C) (4.2)
in (Method Check).
where CtoPP(C) is the set of all program points in C and PP is the set of program points in C which are well-typed. Hence the proposition is easily seen as a
consequence of the following rules.

We recall that well-typed bytecode means that the typing semantics over the
individual instructions are respected cf. Principle 4.1.7. Thus, we let the proof
construction of valid type checking be syntax directed over the bytecode structure:

Definition 4.4.10 (Instruction sequence check rules).
\Xi  ` PP; pp; C : md ! PP 0 : If instruction sequence C has type bcv, then the set of

program points PP can be extended with all well-typed program points from
program point pp in C, yielding PP 0.

The extension of PP is performed successively over the remaining instruction
sequence starting from pp, formally specified by the transitive rules:

\Xi  ` PP; pp; C : md ! PP
\Xi  ` pp; I : bcv ! pp0 \Xi  ` PP 0; pp0; C : md ! PP 00

\Xi  ` PP; pp; I C : md ! PP 00 PP

0 = PP [ fppg

(Proper Sequence)

\Xi  ` PP; pp; ffl : bcv ! PP PP

0 = PP [ fppg (Empty Sequence)

We see that the actual bytecode check is specified at the level of the individual instructions, that is whether the associated program points are well-typed with
the same, context-given method type-descriptor MD. We present a common rule
for each of the JVMOb instruction-set partitions: instructions without index, instructions with a local variable index, instructions with a constant pool index, and
instructions with a code offset. (For a justification of this we refer to Table 4.1.)
Each of these operating with a different set of side-conditions.

92 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
Definition 4.4.11 (Single instruction check rules).
\Xi  ` pp; I : md ! pp0 : If instruction I with program point pp is well-typed with

md, in the typing context \Xi , then we can advance to the target program point
pp0.

The rules for the judgment are given below in Definitions 4.4.12 through 4.4.17,
one for each instruction-set partition. We carefully comment the first partition rule,
hence only commenting the significant differences from this in the remaining rules.

Definition 4.4.12 (Single "No-index" check rules).

\Xi  ` pp; I : md ! pp0

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
pp0 = pp + 1
md(pp) = hst; lvti
md(pp0) v \Omega st0; lvtfffi

fist0fifi ! ms

(Simple Instruction)

where

I st st0
dup st1 \Delta  MT st1 \Delta  MT \Delta  MT
pop st1 \Delta  MT st1
iconst 0 st st \Delta  int
iconst 1 st st \Delta  int
aconst null st st \Delta  Object

The instructions in this partition are marked in the side-condition table. This table
expresses a frame-type abstraction of each instructions runtime transition-behavior
as described in Table 4.4. Hence hst; lvti is the frame-state type prior to the instruction (type) transition, hst0; lvt0i the the frame-state type. (Notice, that lvt0 is
identical with lvt for this partition.)

First we observe that for each instruction in this partition, the target program
point pp0 is the next in the sequence, hence given by adding the length of the
instruction to pp. (Following Table 4.1 these are each one byte long for this partition.)

The instructions all manipulate the stack. Hence the stack size at pp0 must be
checked not to exceed the statically predicted maximal stack size of that method
(where "size" is the number of elements, here their types, on the stack).

The third and fourth condition expresses the actual type check. The former says
that the a priori given frame-state type at pp, i.e., md(pp), must be s frame-type
hst; lvti such that st is restricted according to the side-condition table. Notice

4.4. STATIC SEMANTICS 93
the use of v, the partial order defined on the frame-state type domain in Definition 4.1.5, in the latter condition: this means that we permit the a priori given
frame-state type at pp0, i.e., md(pp0), to be lesser or equally defined than the
formally established frame-state type at pp0, i.e., hst0; lvti. This requirement accounts for the possibility of pp0 being the target of other instructions, say, branch
instructions. (To illustrate this we refer to Example 4.4.20).

Definition 4.4.13 (Single "Local-index" check rules).

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
pp0 = pp + 2
md(pp) = hst; lvti
md(pp0) v \Omega st0; lvt0fffi

fist0fifi ! ms

n ! mlv

(Local Access Instructions)

where

I st st0 lvt0
istore[n] st0 \Delta  int st0 lvt + [n 7! int]
astore[n] st0 \Delta  CID st0 lvt + [n 7! CID]

iload[n] st st \Delta  lvt(n) where lvt(n) = int lvt
aload[n] st st \Delta  lvt(n) where lvt(n) = CID lvt

For this instruction-set partition, pp0 is given by adding the common partitioninstruction length two to pp. They all accesses local variables at some index
n, hence impose particular constraints on the local variable-table types: the store variants require the stack type at pp to be respected by the appropriate local
variable-table type after instruction state-transition; the -load variants conversely
require that the type of the accessed local variable is respected on the stack afterwards.

Definition 4.4.14 (Single "CP-indexed" check rules).

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
pp0 = pp + 3
md(pp) = hst; lvti
md(pp0) v \Omega st0; lvt0ff

CP(n) = ITfi

fist0fifi ! ms

(Simple Constant Pool Instructions)

94 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
where

I st st0 IT
checkcast[n] st1 \Delta  CID1 st1 \Delta  CID CID

ldc w[n] st st \Delta  int int

new[n] st st \Delta  CID CID

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
pp0 = pp + 3
md(pp) = hst; lvti
md(pp0) v \Omega st0; lvt0ff

CP(n) = IT
CID ^: CID 0fi

fist0fifi ! ms

(Object Instructions)

where

I st st0 IT
putfield[n] st0 \Delta  CID \Delta  MT st0 fieldref(CID 0; ID; MT)
getfield[n] st1 \Delta  CID st1 \Delta  MT fieldref(CID 0; ID; MT)
invokevirtual[n] st0 \Delta  CID \Delta  MT1 : : : MTm st0 methref(CID 0; h-; MT1; ::; MTmi ; V)
invokevirtual[n] st1 \Delta  CID \Delta  MT1 : : : MTm st1 \Delta  MT methref(CID 0; h-; MT1; ::; MTmi ; MT)
invokespecial[n] st0 \Delta  CID \Delta  MT1 : : : MTm st0 methref(CID 0; h-; MT1; ::; MTmi ; V)
invokespecial[n] st1 \Delta  CID \Delta  MT1 : : : MTm st1 \Delta  MT methref(CID 0; h-; MT1; ::; MTmi ; MT)

This group is interesting, because while the instructions do very complicated things
at runtime, cf. Definition 4.5.5, its runtime specification in Definition 4.5.6, they are
actually quite easy to type-check (at least with our restrictions):

ffl The checkcast instruction amounts to actually relaxing the type at pp0 (with

respect to the dynamic type which we do not yet know, but which we assumed to be accepted by check cast, i.e., is a subtype of the class type in
the constant pool) by replacing the type of the top stack element with the
class type in the constant pool. This because the instruction will be verified
at runtime. In doing so, however, we have to be sure that any safe JVMOb
bytecode sequence using check cast with a correct method type descriptor,
md, will pass the bytecode check at the check cast instruction. The problem is if md(pp0) = st \Delta  CID 0 where CID 0 ^: CID. Then the side condition
md(pp0) v hst0; lvt0i will fail, even when the bytecode is safe. However,
we uses the observation that the only time a check cast instruction is generated at compile time is when a cast to a subtype is performed at source level.
Hence we can exclude this possibility.

ffl ldc w can only load integer constants.

4.4. STATIC SEMANTICS 95

ffl new merely pushes an element of the indicated class on the stack.
ffl putfield and getfield check types at two levels: first the object must be sure

to have the field, hence the assumed type of the object must be a subtype of
the object where the field is indicated to exist. Second, the actual field type
must match the value type.

ffl invokevirtual and invokespecial check the object similarly, and require all

argument types to match those required by the method signature (JVM only
requires each to be a subclass but we follow JavaOb strictly to make it easier
to lookup the method at runtime). The return type controls what is left on
the stack: nothing for void methods and the returned value type for non-void
methods.

Definition 4.4.15 (Single "Code-indexed" check rules).

\Xi  ` pp; goto[n] : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
md(pp) = hst; lvti
pp0 = pp + 3
pp00 = pp + n
md(pp00) v hst; lvti

(Goto Instruction)

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
md(pp) = hst; lvti
pp0 = pp + 3
md(pp0) v \Omega st0; lvtff
pp00 = pp + n
md(pp00) v \Omega st0; lvtff

(Branch Instructions)

where

I st
ifeq[n] st0 \Delta  int

ifgt[n] st0 \Delta  int
ifnull[n] st0 \Delta  CID

The goto statement simple demands that the frame type of the target program point
is the same (or less defined, of course). Branching statements require that both
branches have an appropriate frame type, after having consumed a value to test of
the appropriate type.

Remark 4.4.16 (Least frame type). We have talked about finding the "least" type.
It should be clear from the above that there is always a least type because each
frame type ft is determined by at least one constraint ft ` ft0 where ft0 is the
initial frame state type or is again similarly constrained

96 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
Definition 4.4.17 (Return check rules).

\Xi  ` pp; I : md ! pp0

\Xi  = hs; CP; ms; mlv; RMTi
pp0 = pp + 1
md(pp) = hst; lvti

(Return Instructions)

where

I st Condition
return RMT = V
ireturn \Delta  int RMT = int
areturn \Delta  CID CID ^: RMT

These require that the returned top stack element has the right type for the method.
They do not impose constraints on any other program points.

Finally we briefly outline a bytecode verifier based on the specification of the
bytecode checker. The verifier is defined with no intent of being efficient; in fact
we will only formalize the major principle by non-algorithmic rules, postponing
algorithmic issues to the next chapter.

The naive way to specify verification on top of a check is to claim the existence
of a type descriptor bcv which passes the Bytecode Checker. This being expressed
by the subsequent naive judgment.

" 9 " bcv [ ` CF : bcv ]

` CF

However, this lacks an indication of where and how to search for an appropriate
class type-descriptor for the class being verified. In order to remedy this, we suggest the following formalization.

Definition 4.4.18 (Bytecode verification rules).
CFs ` CID : The class file CID passes bytecode verification in the class collection CFs.

s ` bcv : the class hierarchy described by s generates the class type bcv (this is

discussed below).

We give the rule for the first of these. The middle premise in the verification rule
below thus makes explicit that a candidate bcv is found by a search and subsequently checked in the right premise.

CFs ` CID
CFs ` s s ` bcv s ` CF : bcv

CFs ` CF CF = CFS(CID) (Class Verification)

4.4. STATIC SEMANTICS 97

A class file which does not pass verification is expected to be rejected at some
point, i.e., when no appropriate class type-descriptor can be found. In other words
it must be computable whether bcv exists. This requires two things: first, the
set of possible class type-descriptors must be recursively enumerable, second, the
search-process must not be able to repeat investigating the same candidates infinitely. Fortunately this is trivial in our case because of the rigid structure of the
types.

Observation 4.4.19 (Enumeration of frame types). Given natural numbers ms
and mlv and a finite class hierarchy described by s, then the set of possible frame
types is finite and enumerable.

We discuss how the search can be made efficient in the following chapter; further treatment is beyond the scope of this master thesis. We conclude with two
larger examples.

Example 4.4.20 (Verifying the Toy). The Toy class from Example 3.2.4, translated in Example 5.5.1, verifies as follows:

pp st lvt I

0 ffl Toy; int; ?; ? iconst 0
1 int Toy; int; int; ? istore [2]
3 ffl Toy; int; int; ? goto [+19]

6 ffl Toy; int; int; ? iload [1]
8 int Toy; int; int; ? iconst 1
9 int; int Toy; int; int; ? isub
10 int Toy; int; int; ? istore [1]
12 ffl Toy; int; int; ? iconst 1
13 int Toy; int; int; ? istore [3]
15 ffl Toy; int; int; int iload [2]
17 int Toy; int; int; int iload [3]
19 int; int Toy; int; int; int iadd
20 int Toy; int; int; int istore [2]

22 ffl Toy; int; int; ? iload [1]
24 int Toy; int; int; ? ifgt [-18]
27 ffl Toy; int; int; ? iload [2]
29 int Toy; int; int; ? ireturn

We have indicated the "basic blocks", i.e., the code fragments without jumps to
internal labels (Aho, Sethi and Ullman 1986, Muchnick 1997), by boxes. The flow

98 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
graph of the method, the basis for the data-flow analysis, is as follows:

0 - 3

22 - 29fflffl

6 - 20**

UU (4.3)

This illustrates the critical comparisons in the verification as explained in Example 4.1.2: The only place where the stack and/or local variables needs to be be less
(in the domain order) than the default is at the head of a basic block where there is a
jump from another. In Toy this only happens between instruction 20 and 22 where
the type of local variable 3 (r) "drops" from int to ? (because this is needed to
satisfy the requirement that instruction 22 may come after instruction 3).

Example 4.4.21 (Verification fails with bad Toy). If we replace the above bytecode instruction at 27 with iload[3] then the bytecode verification will fail because
local variable 3, corresponding to r, is not guaranteed to be defined at pp = 27
(because it was not set if the while condition was never true).

Example 4.4.22 (Verifying the Tax). This is a somewhat larger example; empty
lines denote repetition:

pp S LV (this,inc,rest,tax) I
-- ---------------- --------------- ---------------

0 e Tax int - - aload[1]
2 int ifnull[+4]
5 e goto[+3]
8 iconst_0
9 int ireturn
10 e aload[1]
12 Income getfield[1]
15 ReadOnlyAmount invokevirtual[2]
18 int istore[2]
20 e Tax int int - aload[1]
22 Income getfield[1]
25 ReadOnlyAmount invokevirtual[2]
28 int ldc_w[3]
31 int int isub
32 int ifgt[+10]
35 e iconst_0
36 int istore[3]
39 e goto[+27]
42 ldc_w[4]

4.5. DYNAMIC SEMANTICS 99

45 int istore[3]
48 e Tax int int int iload[2]
50 int ldc_w[4]
53 int int isub
54 int istore[2]
56 e aload[1]
58 Income getfield[5]
61 Amount iload[3]
63 Amount int invokevirtual[6]
66 e aload[1]
68 Income getfield[7]
71 Amount iload[2]
73 Amount int invokevirtual[6]
76 e iconst_1
77 int ireturn
78 e

4.5 Dynamic Semantics
In this Section we formally define a dynamic semantics describing the runtime behavior of JVMOb class files. In particular we also here assume that JVMOb is
semantically self-contained, hence follows the official Java Virtual Machine Specification (Lindholm and Yellin 1996), which we will therefore use as our current
reference when justifying the semantical rules. Moreover, we impose the restrictions described in the official Java Card specification following (Sun 1997a) and
discussed in Remark 4.2.2.

Discussion 4.5.1 (Dynamic loading). JVM is special (for an abstract machine) in
that it includes both a class loader and a static semantics, as described above, in
addition to the usual dynamic semantics describing how the binary instructions
are executed. This is manifest in the rules below by the fact that the dynamic semantics includes loading and verifying of a class when it is loaded. This has the
advantage (from the execution point of view) of making the dynamic semantics
simpler because we know that several of the checks usually done by (both virtual
and real) machines, e.g., illegal instruction checks, have already been done. Hence
this section with our dynamic semantics for JVMOb is nice and short, based on
the assumption that the class file has already been verified, i.e., been proved welltyped by the static semantics. We will argue along with each rule why this means
that it "cannot go wrong", or rather, where it can go wrong: the cases where JVMOb requires runtime type checking. In accordance with our general principle
(Remark 4.1.1) we do not treat the error situations except by not permitting proofs
of program evaluations with errors.

The first task is the formalization of the runtime state. This follows the runtime

100 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
state for JavaOb closely with only a few variations, explained below; Figure 4.2
illustrates the runtime state graphically.

Definition 4.5.2 (Runtime state sorts).

RS 2 RunState = MethodArea \Theta  JavaStack \Theta  Heap JVMOb state

JS 2 JavaStack = Frame\Lambda 

F 2 Frame = LocalVars \Theta  Stack \Theta  PC execution frame
LV 2 Localvars = Word\Lambda  current local vars

S 2 Stack = Word\Lambda  current stack

pc 2 PC = (ACTUAL \Theta  METHODSIG \Theta  PPoints) + halt program counter

H 2 Heap = Handle fin\Gamma ! Object heap of instances
h 2 Handle = N adress into heap
ob 2 Object = INSTOF \Theta  FieldValues class instance
fvs 2 FieldValues = Word\Lambda 

ICID 2 INSTOF = CLASSID class we're an instance of

v; w 2 Word = Integer + Reference one machine word
i; j 2 Integer = Z usual integers
r 2 Reference = Null + Handle possible object
null 2 NULL = Unit special reference value

The individual sorts are explained as follows:
RunState: The complete runtime state as depicted in Figure 4.2.
JavaStack, Frame: The stack of execution frames with the current on top (i.e., to

the right); the last two components sorts of a frame are lifted to make it
possible to have undefined in these values for administrative frames;i.e., the
initial one.

Localvars, Stack, PC: The execution context as stored in the current frame. In the

figure we have shown with a ffl how this is stored just after an instance
method invocation (in order to show an object). The special PC-value halt
signifies that execution has ended.

Heap, Object, Handle: All class instances are stored as objects in the heap, each

addressed by a unique handle.

FieldValues, INSTOF: The field data and type of an object.
Word, Integer, Reference, NULL: These are the primitive values, all stored in a single word (because we have omitted the JVM double-word types from JVMOb). We follow the Java convention of distinguishing a Reference, which

4.5. DYNAMIC SEMANTICS 101

ffl
0 mlv-1LV

0

"""" """" """"

ms-1S

pc
F
...

. . . . . . . . . . . . .O/
O/
O/
O/
O/
O/
O/
O/
O/
O/
O/
O/
O/

O/

O/
O/
O/
O/
O/
O/
O/
O/
O/
O/
O/
O/. . . . . . . . . . . . .

JS

fvs
ICID

ob . . .

. . . . . . . . . . . . . . .O/
O/
O/
O/
O/
O/
O/
O/

O/
O/
O/
O/
O/
O/
O/
O/. . . . . . . . . . . . . . .

H

...
CID 7!

RCP

...
MSIG 7! hRMT; hmlv; ms; Cii...

SCID

CS.
..

. . . . . . . . . . . . . . . . . . .O/
O/
O/
O/
O/O/

O/
O/
O/
O/O/

O/
O/
O/O/

O/

O/O/
O/
O/
O/O/

O/
O/
O/
O/O/

O/
O/
O/O/

O/. . . . . . . . . . . . . . . . . . .
MA

h

44

''

yy

AEAE

RS
Figure 4.2: JVMOb runtime state picture.

102 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

may be null of the sort Null, i.e., not pointing to an object, or Handle, which
always points to an object.

Initializing the JVMOb is interesting. We start with a startup-problem, just
as in JavaOb. But we start without any classes of the program being loaded. So
just as for JavaOb we emulate a bit of bootstrap code, in this case a new instruction
followed by several constant value instructions followed by invokevirtiual. Thus
first a comment in method invocation.

Remark 4.5.3 (Initial frame-state). When a method is invoked, the new framestate is an empty stack and a local-variable table instantiated by the method arguments cf. (Lindholm and Yellin 1996, p.268). The first entry, this, is by definition
set to the object on which the method is called, if any. (For JVMOb, this will always be set since we only deal with instance methods.) Thus the initial frame-state
type of each method is fixed and corresponds to the initial runtime-state, illustrated
in Figure 4.3.

\Omega  ffl ; this ARG1 \Delta  \Delta  \Delta  ARGn ? \Delta  \Delta  \Delta  ? ff

Figure 4.3: Initial method invocation frame.
Definition 4.5.4 (JVMOb startup rules).
` CFs; startup(CID; ID; CPV1; ::; CPVk) ) w; H : The JVMOb class file collection CFs is run by invoking the method ID on a new instance of the class

CID, passing it the primitive (and typed) arguments CPV1 to CPVk. The result of the run is a word w in the resulting heap H.

` CFs; ST ) w; H
CFs ` ffl + CID  MA
MA0; hF0; F1i ; H0 ) MA00; F00; H00
CFs ` startup(CID,ID; (PT1)PV1,::,(PTk)PVk) ) w00; H00

F0 = hffl; ffl; ?; halti
F1 = \Omega hh; PV1; ::; PVki ; ffl; 0; CID 0ff
H0 = [0 7! ob0]
F00 = \Omega  ; w00; ; ff
(Program Invocation)

The first premise corresponds to loading the class file into the method area: we do
not do this "lazily" as the proper JVM does because in a Java Card this will typically already have happened at mask time (except for actual downloaded applets,
of course). All the classes are then assigned field offsets (as discussed below) and

4.5. DYNAMIC SEMANTICS 103
left in the method area. The second premise then resolves the startup method call.
The information

The machine keeps executing until a halt program counter value is encountered.
Then the value on the the stack is returned as the value of the computation.

Definition 4.5.5 (JVMOb instruction sequence execution rules).
CFs ` RS ) w; H: In the class files context CFs the machine state RS computes

the the value and heap pair w; H when the machine halts.

` CFse ` RS ) w; H
CFs ` RS ) RS0 CFs ` RS0 ) w; H

CFs ` RS ) w; H (Continued Execution)

CFs ` RS ) w; H

RS = hMA; F; Hi
F = h ; w; halti (Halted Execution)

These rules are quite straight-forward: if we can execute an instruction the we do
it. If not, then the Java stack must contain only one frame, the initial one, with just
one value on the stack, the return value.

Single instruction execution is merely a "small-step" modification of the runtime state.

Definition 4.5.6 (Instruction execution rules).
CFs ` RS ! RS0: In the class files context CFs the machine state RS is transformed into the machine state RS0 by executing one instruction.

The rules implementing these are split up below.
Definition 4.5.7 (Local instruction execution rules).

CFs ` RS1 ! RS2

CFs ` RS1 ! RS2

RSj = hMA; JS \Delta  Fj; Hi (8j : 1::2)
Fj = hLVj; Sj; pcji (8j : 1::2)
pcj = hACID; MSIG; ppji (8j : 1::2)
MA(ACID) = hRCP; ; ; Msi
Ms(MSIG) = h ; hms; mlv; Cii

C(pp1) = I

(Local Instruction)

where S1, S2, pp2, and LV2 depend on I as shown in Table 4.4.

104 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

Instruction Test(s) S1 S2 pp2 LV2
aconst null S S \Delta  null pp1 + 1 LV1
aload[n] S S \Delta  LV1(n) pp1 + 2 LV1
astore[n] S \Delta  r S pp1 + 2 LV1 + [n 7! r]
dup S \Delta  v S \Delta  v \Delta  v pp1 + 1 LV1
goto[n] S S pp1 + n LV1
iadd S \Delta  i1 \Delta  i2 S \Delta  (i1 + i2) pp1 + 1 LV1
iconst 0 S S \Delta  0 pp1 + 1 LV1
iconst 1 S S \Delta  1 pp1 + 1 LV1
ifeq[n] i = 0 S \Delta  i S pp1 + n LV1

i 6= 0 S \Delta  i S pp1 + 3 LV1
ifgt[n] i ? 0 S \Delta  i S pp1 + n LV1

i ^ 0 S \Delta  i S pp1 + 3 LV1
ifnull[n] r = null S \Delta  r S pp1 + n LV1

r 6= null S \Delta  r S pp1 + 3 LV1
iload[n] S S \Delta  LV1(n) pp1 + 2 LV1
istore[n] S \Delta  i S pp1 + 2 LV1 + [n 7! i]
isub S \Delta  i1 \Delta  i2 S \Delta  (i1 - i2) pp1 + 1 LV1
ldc w[n] S S \Delta  RCP(n) pp1 + 3 LV1
pop S \Delta  v S pp1 + 1 LV1

Figure 4.4: JVMOb Local Instructions.

4.5. DYNAMIC SEMANTICS 105

These all involve simple stack manipulations, requiring certain values on the
stack or in local variables and leaving other values instead.

Definition 4.5.8 (Return instruction execution rules).

CFs ` RS ! RS0

RS = \Omega MA; JS \Delta  F0 \Delta  F; Hff
F = hLV; S; pci
pc = hACID; MSIG; ppi
MA(ACID) = h ; ; ; Msi
Ms(MSIG) = h ; h ; ; Cii

C(pp) = I
RS0 = \Omega MA; JS \Delta  F00; Hff
F0 = \Omega LV 0; S0; pc0ff
F00 = \Omega LV 0; S00; pc0ff

(Return Instruction)

where S0 and S00 depend on the instruction I as follows:

I S S00
areturn \Delta  r S0 \Delta  r

ireturn \Delta  i S0 \Delta  i

return S0

These are very simple. The value-returning instructions move the top element
on the stack of the current frame (F) onto the stack of the surrounding frame (F0)
which then becomes the new top frame (F00) after the frame we are returning from
has been discarded. When no value is present the top frame is merely discarded.

Definition 4.5.9 (Checkcast rule).

CFs ` MA1 + CID  MA2
CFs ` s
s ` ICID ^: CID

CFs ` RS1 ! RS2

RSj = hMAj; JS \Delta  Fj; Hi (8j : 1::2)
Fj = hLV; S \Delta  h; pcji (8j : 1::2)
H(h) = hicid; i
pcj = hACID; MSIG; ppji
MA1(ACID) = hRCP1; ; ; Msi (8j : 1::2)
Ms1(MSIG) = h ; h ; ; Cii

C(pp1) = checkcast[n]
RCP1(n) = CID
pp2 = pp1 + 3

(Cast Instruction)

Checkcast checks whether the cast (CID)h, where h is an instance of class ICID, is
legal, that is: whether ICID is a subclass of CID. No down-casts at runtime when the
exact class is known! This is illustrated by Example A.1.3. This is the only place
where runtime types are checked by JVM (Lindholm and Yellin 1996, $2.6.5).

106 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
Definition 4.5.10 (Field instruction rules).

CFs ` MA1 + it  MA2; off

CFs ` RS1 ! RS2

RSj = hMAj; JS \Delta  Fj; Hji (8j : 1::2)
Fj = hLV; Sj; pcji (8j : 1::2)
pcj = hACID; MSIG; ppji (8j : 1::2)
MA1(ACID) = hRCP1; ; ; Msi
Ms(MSIG) = h ; h ; ; Cii

C(pp1) = I
RCP1(n) = it
pp2 = pp1 + 3

(Field Instruction)

where S1, S2, and H2 depend on I as follows:

I S1 S2 H2
getfield[n] S \Delta  h S \Delta  fvs(off) H1

where H1(h) = h ; fvsi
putfield[n] S \Delta  h \Delta  v S H1 + \Theta h 7! H1(h) + [off 7! v]\Lambda 

Field accesses are similar except we first have to ensure that the class, in which
the field is claimed to exist, is loaded.

Definition 4.5.11 (Instance creation instruction rules).

CFs ` MA1 + CID  MA2

` MA2; CID ! fvs

CFs ` RS1 ! RS2

RSj = hMAj; JS \Delta  Fj; Hji (8j : 1::2)
Fj = hLV; Sj; pcji (8j : 1::2)
pcj = hACID; MSIG; ppji (8j : 1::2)
MA1(ACID) = hRCP; ; ; Msi
Ms(MSIG) = hRMT; hms; mlv; Cii

C(pp1) = new [n]
RCP(n) = CID
MA2(CID) = h ; ; fots; i
m = jfotsj
h =2 Dom(H)
H2 = H1 + [ h 7! hCID; fvsi ]
S2 = S1 \Delta  h
pp2 = pp1 + 3

(Instance Creation Instruction)

with the auxiliary rule for initializing a single object,

` MA; CID ! fvs

` MA; Object  ffl (Object Field Initialization)

4.5. DYNAMIC SEMANTICS 107

` MA; SCID  fvs

` MA; CID  fvs0

MA(CID) = h ; SCID; fots; i
fvs0 = fvs + X

ID2Dom(fots)

init(fots(ID))

where init hoff; inti = [off 7! 0]

init hoff; CIDi = [off 7! null]

(Class Fields Initialization)

where the P in the side condition of the last rule merely means that we "add"
the component functions to fvs one by one (with function update "+", cf. Notations 2.3.3).

This is by far the most complicated rule. The main part takes care of the object
allocation, which happens in several steps:

ffl First extract the instruction out of the state, determine that it is a new instruction, and extract the class to use from the constant pool.

ffl Resolve the class.
ffl Extract the field definitions from the class structure (which is now certain to

be available, in MA2).

ffl Build the object ob with a fresh handle h in the new heap H2.
ffl Leave the new handle on the stack.
The auxiliary rule does initialization mimicking the newinit semantic operation of
Definition 3.5.5: It initializes the fields of each class in order from Object (declaring none) to the present class. The only reason this is necessary is because some
names might be "hidden" inside the function fots by their name being defined in
several of the classes, otherwise a single pass through the top-level fots would do.

108 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE
Definition 4.5.12 (Virtual method invocation instruction).

CFs ` ICID
CFs ` s
MA ` ICID; MSIG 0 ! CID 00; MSIG 00

CFs ` RS ! RS0

RS = hMA; JS \Delta  F; Hi
F = hLV; S; pci
pc = hACID; MSIG; ppi
MA(ACID) = hRCP; ; ; Msi
Ms(MSIG) = hRMT; hms; mlv; Cii

C(pp) = invokevirtual [n]
RCP(n) = methref( ; MSIG 0; )

MSIG 0 = h ; MT1::MTki
S = S0 \Delta  h \Delta  w1 \Delta  \Delta  \Delta  wk
H(h) = hicid; i
pc0 = hACID; MSIG; pp + 3i
F0 = hLV; S; pci
pc00 = \Omega icid; MSIG 00ff
F00 = \Omega  hh; w1; ::; wki ; ffl ; pc00 ff
RS00 = \Omega MA; JS \Delta  F0 \Delta  F00; Hff

(Method Invocation Instruction)

with the auxiliary rule

MA ` CID; MSIG ! CID; MSIG

MA ` CID; MSIG ! CID; MSIG

MA(CID) = h ; ; ; Msi

MSIG 2 Dom(Ms)

(Method Lookup Found)

MA ` SCID; MSIG ! CID 0; MSIG 0

MA ` CID; MSIG ! CID 0; MSIG 0

MA(CID) = h ; SCID; ; Msi

MSIG =2 Dom(Ms)

(Method Lookup Nest)

The following steps are involved:

ffl First we extract the instruction from the state as usual, and extract the MREF

item from the constant pool, which reveals the class ICID of interest.

ffl Next we bytecode verify the class (which is already resolved since the object

on which we apply a method must have been created with new, which means
it is resolved).

ffl Now we search dynamically through the class hierarchy for the real method

signature to invoke: in our case this just means going backwards in the class

4.5. DYNAMIC SEMANTICS 109

hierarchy until a method signature exists in a superclass of ICID - this is the
auxiliary operation modeled closely after mlookup of Definition 3.5.3.

ffl Before actually invoking we prepare the return frame F0 such that the program point is the right one when the method eventually returns.

ffl Now we create a new frame F00 containing: a self-pointer; the argument values in local variables 1::k and nothing in the rest of the local variables (this is
indicated by not defining them: we do not actually use the mlv and ms limits at runtime since they have already been checked: in a real implementation
they would be used to allocate just enough space, of course); an empty stack;
and a fresh pc00 using the method signature found by the dynamic lookup.

Note: it is quite wasteful to verify the class for every method invocation but formally harmless. In practice we should only verify the method, and only the first
time it is invoked; this is easily implemented in a safe manner with a flag per
method that is reset by the class loader and set by verification.

Definition 4.5.13 (Super-method invocation instruction).

CFs ` ICID
CFs ` s
MA ` SCID; MSIG 0 ! CID 00; MSIG 00

CFs ` RS ! RS0

RS = hMA; JS \Delta  F; Hi
F = hLV; S; pci
pc = hACID; MSIG; ppi
MA(ACID) = hRCP; SCID; ; Msi
Ms(MSIG) = hRMT; hms; mlv; Cii

C(pp) = invokespecial [n]
RCP(n) = methref( ; MSIG 0; )

MSIG 0 = h ; MT1::MTki
S = S0 \Delta  h \Delta  w1 \Delta  \Delta  \Delta  wk
pc0 = hACID; MSIG; pp + 3i
F0 = hLV; S; pci
pc00 = \Omega CID 00; MSIG 00ff
F00 = \Omega  hh; w1; ::; wki ; ffl ; pc00 ff
RS00 = \Omega MA; JS \Delta  F0 \Delta  F00; Hff

(Super-method Invocation Instruction)

(4.4)
reusing the auxiliary rule from virtual method invocation.
This is completely identical to virtual method invocation except for one crucial
point: We search through the class hierarchy starting from the superclass SCID of
the current class. This means that we do not investigate the current object handle
h at all.

110 CHAPTER 4. A JAVA VIRTUAL MACHINE FOR THE SUBLANGUAGE

This concludes the semantics of the JVMOb virtual machine.

Chapter 5
Compiling the Sublanguage
In this chapter we present an abstract translation of the JavaOb language of Chapter 3 into the JVMOb language of Chapter 4; the latter was in fact determined by
the instructions of JVM needed to do this translation such that the code resembles
that produced by Sun's Java compiler.

It is a technical chapter without much explanation, mostly to show that our
hand-translations of JavaOb into JVMOb is systematic and that the JVMOb instruction set was chosen right.

We start by making some general observations that lead to a compilation strategy. Then we give the full compilation scheme.

5.1 Abstract compilation strategy
In this section we analyze how to perform an abstract, syntax directed translation of JVMOb into JVM, i.e., a translation of (abstract) JavaOb programs into
(abstracted) JVM class-files, performed in a way which is compositional over the
(abstract) syntax of JavaOb. In doing this, however, we do not intend to make requirements to actual implementations, but merely to divide the abstract translation
into logical stages which respects the source language's semantics.

In the rest of this chapter, we will only state 'abstract' if needed to resolve any
ambiguities. We notice

ffl JavaOb programs need types that are defined anywhere in the program.
ffl Otherwise JavaOb programs or program parts have no references to other

programs or program parts.

ffl JavaOb classes can refer to other classes in the same class hierarchy, defined

by a JavaOb program.

The first observation is, as we shall see, merely a consequence of the fact that
JavaOb permits type casts yet only generates runtime checks when the cast may be
a cast to a subtype. The second observation relies on the fact that JavaOb programs

111

112 CHAPTER 5. COMPILING THE SUBLANGUAGE
are designed to work as unnamed Java packages, where all classes are package protected (we refer to Section 3.1 and 3.2 for further details). In other words, JavaOb
programs are semantically independent. Consequently, programs can be translated
separately of one another without loss of generality. The second observation means
that compiling a separate JavaOb class will have to account for where in the class
hierarchy the class is situated, when a method declared in another class is invoked
or when a field in another class is referenced.

Observation 5.1.1 (Cross-class field and method invocation referencing). Crossclass referencing is encountered when analyzing the method bodies of the methods
declared locally to the class in question.

At the virtual machine level, field and method invocation references (the instructions getfield, putfield, invokevirtual, invokespecial, and the auxiliary instructions checkcast and ldc w) are registered in the constant pool (see Definition 4.2.8
for further details). Hence Observation 5.1.1 suggests that the compilation of the
method body and the construction of the constant pool must be done during the
same pass as code generation and constant pool construction cannot be separated.

Since this is the only interclass dependency (apart from typing), it suggests
that the compilation of a separate class can be done in essentially two syntaxdirected passes: a pre-compilation pass, where field and method types declared
locally to the class are compiled, and an actual code generating pass, where the
method bodies are compiled, the maximal size of an associated frame when running
the generated code is determined, and where the constant pool is constructed. This
is summarized by the following list:

1. Translating the (static) field and method type declarations.
2. Code generation from the method body.
3. Calculation of the maximal stack and local variable size.
4. Construction of the constant pool with the relevant method and field reference information.

In practice a compiler will have just a single pass and use standard "back-patching"
techniques, of course (Aho et al. 1986).

Observation 5.1.2. The compilation of JavaOb field types and the method return
types can be done compositionally over the program's class set.

We exploit this observation to divide the abstract compilation of a JavaOb
program into the two passes: one where all the type information is translated
(a preliminary-pass since no code is translated), and the second pass where the
method contents, i.e., the methods formal parameters and their bodies, are translated. The first pass is characterized by the fact that it can be done for each individual class in opposition to the second pass, which cannot. Hence we need to specify

5.1. ABSTRACT COMPILATION STRATEGY 113
a semantical construct, a preliminary class-file PCF, corresponding to the state of a
class after an initial compilation where only the field and method type-declarations
of the class have been translated, leaving the method bodies as untranslated source
code. The structure is formally specified by the following sorts:

Definition 5.1.3 (Pre-class file sort).

PCFs 2 PreClassFiles = CLASSID fin\Gamma ! PreClassFile

PCF 2 PreClassFile = ACTUAL \Theta  SUPER \Theta  FieldTable \Theta  PreMethodTable

PMs 2 PreMethodTable = MethodSig fin\Gamma ! RMTYPE \Theta  MethodContents

We briefly explain the newly introduced sort:
PreMethodTable is a finite function which to every method signature in a given

JavaOb class file assigns the translation of the method's return-type and the
method's contents, not yet translated.

We can now formally state how compilation of a JavaOb program is composed:
Definition 5.1.4 (Compilation strategy). We can now express the overall rule for
class-file generation from a JavaOb program P by the two preliminary judgments,
one for each pass, invoked by the following root rule:

Typingz ""-- -
` P : \Delta 

Pre-compilationz ""-- -
` P ! PCFs

Proper Compilationz ""-- -
` \Delta ; PCFs ! CFs
` P ! CFs (5.1)

The type of the program is extracted using a "preprocessing semantics" judgment from Section 3.3.

` C1::Cn ! s; fs; mts; -

` C1::Cn : \Delta  \Delta  = hs; fs; mtsi (5.2)

A full type check is not needed for the translation but of course included in the
statement of correctness in Section 5.6.

We exploit that the information stored in a preclass file can be retrieved compositionally over a JavaOb program's (abstract) class set and express the pre-compilation
step by the judgments.

8i : 1::n [ ` Ci ! PCFi ]

` C1::Cn ! PCFs (5.3)

with the program being the classes and the preclassfile containing all the found
classes:

8i : 1::n \Theta  PCFi = hCIDi; ; ; i \Lambda  (5.3a)
8i : 1::n \Theta  PCFs(CIDi) = PCFi \Lambda  (5.3b)

114 CHAPTER 5. COMPILING THE SUBLANGUAGE

For each class we merely collect all the needed information for the relevant
PCF structure:

` class CID extends CID 0 { T1ID1::TnIDn M1::Mm } ! hCID; CID 0; Fs; PMsi

(5.4)

with side-conditions expressing how the information is stored in the pre-class file.

8i : 1::n \Theta  Fs(IDi) = Ti \Lambda  (5.4a)

8j : 1::m \Theta  Mj j RjIDj(IDj1Tj1::IDjkj Tjkj)Bj \Lambda  (5.4b)
8j : 1::m\Theta PMs(IDj; Tj1::Tjkj; R) = Bj \Lambda  (5.4c)

defining how the field declarations T1ID1::TnIDn and method declarations M1::Mm
(with arities k1::km) are inserted into the preclass-file structure.

Pass 2 with the proper compilation is expressed by the following judgments
where the construction of the constant pool is directed by the methods code generation. Programs are translated class by class, where we propagate the typing
information:

8CID 2 Dom(PCFs) [ \Delta ; PCFs ` CID ! CFCID ]

` \Delta ; PCFs ! CFs (5.5)

with side-conditions for extracting the class information out of the pre-class file

8CID 2 Dom(PCFs) \Theta  CFs(CID) = CFCID \Lambda  (5.5a)
Classes are translated method by method:

8i 2 1::n \Theta ` ldi-1; Ti IDi ! ldi \Lambda 
8j : 1::m \Theta  \Delta ; \Gamma ; PCFs ` CID; CPj-1; MSIGj; STj; Bj ! CPj; msj; mlvj; Cj \Lambda 

\Delta ; PCFs ` CID ! hCPm; CID; CID 0; Fs; Msi

(5.6)

with side-conditions for building the local type context \Gamma  (again using judgments
from Section 3.3):

ld0 = ffl (5.6a)

\Gamma  = hCID; ldni (5.6b)

and for how to combine the code and derived information about each method into

5.2. BLOCK COMPILATION 115
a complete class file

PCFs(CID) = \Omega CID; CID 0; Fs; PMsff (5.6c)

m = jPMsj (5.6d)
CP0 = /0 (5.6e)
8j : 1::m \Theta  PMs(MSIGj) = (Rj; IDj1::IDjk) \Lambda  (5.6f)

8j : 1::m \Theta  MSIGj j hIDj; Tj1::Tjki \Lambda  (5.6g)

8j : 1::m \Theta  STj = [ IDj1 7! h1; Tj1i ; : : : ; IDjkj 7! \Omega k; Tjkjff ] \Lambda 

(5.6h)

8j : 1::m \Theta  Ms(IDj; Tj1::Tjkj) = hRj; msj; mlvj; Cji \Lambda  (5.6i)

where we use jPMsj to denote the "size" of the finite domain of PMs, i.e., the
number of methods declared in class CID.

Next we generate the actual code and construct the constant pool. Recall
that it contains information for the Bytecode Verifier and the runtime system.

We will build it as an accumulating function CP : N fin\Gamma ! Items with the invariant
that Dom(CP) = f1:: jCPjg. In (5.6), the local variables, i.e., the arguments of the
method, are required in a structure ST, a symmetric table for local variables, simulating the placement in the JVM runtime structure.

The syntax-directed compilation of method bodies is the subject of Sections 5.2
through 5.5 below.

5.2 Block compilation
For each block we translate all statements in an environment where the local variables have been added to the scope which initially contains just the self- and formal
parameters (arguments) of the method.

8i : 1::r \Theta  Di ` di-1 ! di \Lambda 
8i : 1::q \Theta  \Delta ; \Gamma 0; PCFs ` CID; CPi-1; MSIG; ST0; Si ! CPi; msi; mlvi; Ci \Lambda 

\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; { D1;::Dr; S1::Sq }!

CPq; ms; mlv; C1::Cq

(5.7)

with side-conditions for extending the local type context with the local variables,

\Gamma  = hCID; d0i (5.7a)
\Gamma 0 = hCID; dri (5.7b)

the symbol table with the local variable indices for the new variables,

jSTj = k (5.7c)

ST0 = ST + [ ID1 7! k + 1; : : : ; IDr 7! k + r ] (5.7d)
CP0 = CP (5.7e)

116 CHAPTER 5. COMPILING THE SUBLANGUAGE
and synthesize the maximal needed number of stack entries and local variables:

ms = max

j:1::q msj (5.7f)

mlv = max

j:1::q mlvj (5.7g)

Remark that the only place where the symbol table ST is "modified" in the translation is when ST is extended to ST0. This is used to synthesize mlv as the largest
number of local variables accessible in any nested block; it means we must produce
an mlv for any statement that might have a block nested inside it. Similarly we
collect the maximal stack size ms produced by any expression.

5.3 Statement compilation
All statements (including blocks) generate code with the invariant that the stack
has nothing on it before and after the code is executed. The simplest is the empty
statement which uses neither local variables nor stack:

\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; ; ! CP; 0; 0; ffl (5.8)
Expressions used as statements are special in that even expressions without a value
(or rather, with void value) are permitted. Thus we pass information on to the rules
generating code for STATEXPRESSION that the value produced is not used in the
form of the flag "void".

\Delta ; \Gamma ; PCFs ` CID; CP; 0; ST; void; SE ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; SE; ! CP 0; ms0; 0; C0C00 (5.9)

The branching statements are simple once one has calculated the right jump distances:

\Delta ; \Gamma ; PCFs ` CID; CP; ST; CO ! ; CP0; ms0; C0; IFCOND
\Delta ; \Gamma ; PCFs ` CID; CP0; MSIG; ST; S1 ! CP1; ms1; mlv1; C1
\Delta ; \Gamma ; PCFs ` CID; CP1; MSIG; ST; S2 ! CP2; ms2; mlv2; C2
\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; if (CO) S1 else S2!

CP2; max

i:0::2 msi; maxi:1::2 mlvi; C0 IFCOND[jC2j + 6] C2 goto[jC1j + 3] C1(5.10)

and

\Delta ; \Gamma ; PCFs ` CID; CP; ST; CO ! CP0; ms0; C0; IFCOND
\Delta ; \Gamma ; PCFs ` CID; CP0; MSIG; ST; S ! CP1; ms1; mlv1; C1
\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; while (CO) S!

CP1; max

i:0::1 msi; mlv1; goto[jC1j + 3] C1 C0 IFCOND[- jC0j - jC1j - 3](5.11)

5.4. STATEMENT EXPRESSIONS COMPILATION 117
sharing the auxiliary translation for compiling the actual branch test instruction

\Delta ; \Gamma ; PCFs ` CID; CP; 0; ST; E ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; ST; E == 0 ! CP 0; ms0; C0; ifeq (5.12)

\Delta ; \Gamma ; PCFs ` CID; CP; 0; ST; E ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; ST; E > 0 ! CP 0; ms0; C0; ifgt (5.13)

\Delta ; \Gamma ; PCFs ` CID; CP; 0; ST; E ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; ST; E == null ! CP 0; ms0; C0; ifnull (5.14)
where we have used the auxiliary sort

IFCOND 2 IFCONDITIONAL ::= ifeq j ifgt j ifnull (5.15)
to represent the possible branch instructions.

The three possibilities for returning from a method are very similar. The void
return is particularly simple:

\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; return; ! CP; 0; 0; return (5.16)
whereas the two other require that we lookup the return-type of the hosting method
(this is the reason for making the MSIG accessible to statements).

\Delta ; \Gamma ; PCFs ` CID; CP; 0; ST; E ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; MSIG; ST; return E; ! CP 0; 0; ms0; C0 C00 (5.17)

with side-conditions for generating the return instruction corresponding to the returned type:

PCFs(CID) = h-; -; -; PMsi (5.17a)
PMs(MSIG) = hT; -; -i (5.17b)

C00 = ffiireturn if T 2 fboolean; intgareturn if T = CID 0 (5.17c)

5.4 Statement Expressions compilation
Statement expressions are those that can appear as statements, hence the rules exist
in two variants with a flag vf indicating whether "void" or a "value" should be left
on the stack. First, object creation:

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; vf; new CID 0() ! CP 0; s + 1; new[n] C (5.18)
with a side-condition for extending the constant pool if this is needed, i.e., if the
desired constant is not already in it:

CP 0 = CP + [n 7! CID 0] where n = ffim if CP(m) = CID

0

jCPj + 1 otherwise (5.18a)

118 CHAPTER 5. COMPILING THE SUBLANGUAGE
and a side-condition for popping a non-needed value off the stack:

C = ffipop if vf = voidffl if vf = value (5.18b)
Local assignment statements generate store instructions:

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E ! CP 0; ms0; C
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; vf; ID=E ! CP 0; max(ms; s0); C C0 C00 (5.19)

with side-conditions for saving the value before the store if it is needed afterwards,
keeping track of the maximal stack size, and for ensuring that the right type of
value is stored:

C0; s0 = ffiffl; s + 1 if vf = voiddup; s + 2 if vf = value (5.19a)
ST(ID) = n (5.19b)

\Gamma (ID) = ld (5.19c)

C00 = ffiistore [n] if ld(ID) = intastore [n] if ld(ID) = CID 0 (5.19d)
Field-assignment statements are similar.

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (CID1)E1 ! CP1; ms1; C1
\Delta ; \Gamma ; PCFs ` CID; CP; s0; ST; E2 ! CP2; ms2; C2
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; vf; ((CID1)E1).ID=E2!

CP 0; max(ms1; ms2); C1 C0 C2 putfield [n]

(5.20)

with side-conditions

C0; s0 = ffiffl; s + 1 if vf = voiddup; s + 2 if vf = value (5.20a)

CP 0 = CP2 + [n 7! F] where n = ffim if CP2(m) = FjCP

2j + 1 otherwise

(5.20b)

F = Fieldref(CID1; ID; Fs1(ID)) (5.20c)
PCFs(CID1) = hCID1; -; Fs1; -i (5.20d)

where we have again reused existing F entries in the CP.

Finally we translate method invocations.

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (CID0)E0 ! CP0; ms0; C0
8i : 1::n \Theta  \Delta ; \Gamma ; PCFs ` CID; CPi-1; s + i; ST; (Ti)Ei ! CPi; msi; Ci \Lambda 

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; vf; ((CID0)E0).ID((T1)E1; : : : ; (Tn)En)!

CP 0; max

i:0::n msi; C0::Cn invokevirtual [m] C

0

(5.21)

5.5. EXPRESSION COMPILATION 119
with similar side-conditions, except for the fact that we must pop off a return value
that is not used:

PCFs(CID0) = h-; -; -; PMs0i (5.21a)
PMs0(ID; T1::Tn) = hR; -; -i (5.21b)

CP 0 = CPn + [m 7! M] where m = ffik if CPn(k) = MjCP

nj + 1 otherwise

(5.21c)

M = Methref(CID0; hID; T1::Tni ; R) (5.21d)

C0 = ffipop if vf = void ^ R 6= voidffl otherwise (5.21e)

Similarly for super-object method invocation:
8i : 1::n \Theta  \Delta ; \Gamma ; PCFs ` CID; CPi-1; s + i - 1; ST; (Ti)Ei ! CPi; msi; Ci \Lambda 

\Delta ; \Gamma ; PCFs ` CID; CP0; s; ST; vf; super.ID((T1)E1; : : : ; (Tn)En)!

CP 0; max

i:1::n msi; C1::Cn invokespecial [m] C

0

(5.22)
with side-conditions

PCFs(CID) = \Omega -; CID 0; -; -ff (5.22a)
PCFs(CID0) = h-; -; -; PMs0i (5.22b)
PMs0(ID; T1::Tn) = hR; -; -i (5.22c)

CP 0 = CPn + [m 7! M] where m = ffik if CPn(k) = MjCP

nj + 1 otherwise

(5.22d)

M = Methref(CID 0; hID; T1::Tni ; R) (5.22e)

C0 = ffipop if vf = void ^ R 6= voidffl otherwise (5.22f)

5.5 Expression compilation
Expressions are characterized by invariably compiling into code that produces one
value on the stack - only for statement expressions is there a risk that the "value"
is void. So expressions are simpler in this respect. However, expressions can
be nested, and the maximal stack size needed will be a function of this nesting.
Fortunately one cannot in Java nest declarations inside expressions, so we do not
have to synthesize an mlv value from an expression.

120 CHAPTER 5. COMPILING THE SUBLANGUAGE

We start with the code for looking up local variables.

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; ID ! CP; s + 1; C (5.23)
with side-conditions for using the right type of load instruction:

ST(ID) = n (5.23a)

\Gamma (ID) = ld (5.23b)

C = ffiiload [n] if ld(ID) = intaload [n] if ld(ID) = CID 0 (5.23c)

Looking up fields is very similar, except we do not have to consider the type (it
will be checked at runtime):

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (CID 0)E 0 ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; ((CID 0)E 0).ID 0 ! CP 00; ms; C0 getfield [n]

(5.24)

with side-conditions for extending the constant pool if needed, just as for field
assignment:

CP 00 = CP 0 + [n 7! F0] where n = ffim if CP

0(m) = F0

jCP 0j + 1 otherwise

(5.24a)

F0 = Fieldref(CID 0; ID 0; Fs0(ID)) (5.24b)
PCFs(CID 0) = \Omega -; -; Fs0; -ff (5.24c)

Primitive cast expressions generate no special code.

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E 0 ! CP 0; ms0; C0
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (int)E 0 ! CP 0; ms0; C0 (5.25)

Object cast expressions are ignored if the compiler knows that it is an up-cast,
otherwise a check is generated.

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E 0 ! CP 0; ms0; C0
\Delta ; \Gamma  ` E 0 : CID 00 s ` CID 00 ^: CID 0
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (CID 0)E 0 ! CP 0; ms0; C0 (5.26)

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E 0 ! CP 0; ms0; C0
\Delta ; \Gamma  ` E 0 : CID 00 s ` CID 0 !: CID 00
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; (CID 0)E 0 ! CP 00; ms0; C0 checkcast[n] (5.27)

5.5. EXPRESSION COMPILATION 121
with side-conditions for extracting the type hierarchy and adding the new type to
the constant pool, if needed:

\Delta  = hs; ; i (5.27a)

CP 00 = CP + [n 7! CID 0] where n = ffim if CP(m) = CID

0

jCPj + 1 otherwise (5.27b)
This is the only place in the entire translation where we need \Delta : everywhere else it
suffices with just the local type context.

The rules for LITERALs: the current object,

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; this ! CP; s + 1; aload [0] (5.28)
the constants,

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; null ! CP; s + 1; aconst null (5.29)

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; false ! CP; s + 1; iconst 0 (5.30)

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; true ! CP; s + 1; iconst 1 (5.31)
and integers:

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; 0 ! CP; s + 1; iconst 0 (5.32)

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; 1 ! CP; s + 1; iconst 1 (5.33)
and

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; INT ! CP; s + 1; ldc w [n] (5.34)
with side-conditions INT =2 f0; 1g and

CP 0 = CP + [n 7! INT] where n = ffim if CP(m) = INTjCPj + 1 otherwise (5.34a)
Finally the compilation rules for addition and subtraction

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E1 ! CP1; ms1; C1
\Delta ; \Gamma ; PCFs ` CID; CP1; s + 1; ST; E2 ! CP2; ms2; C2
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E1 + E2 ! CP2; maxi:1::2 msi; C1 C2 iadd (5.35)

\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E1 ! CP1; ms1; C1
\Delta ; \Gamma ; PCFs ` CID; CP1; s + 1; ST; E2 ! CP2; ms2; C2
\Delta ; \Gamma ; PCFs ` CID; CP; s; ST; E1 - E2 ! CP2; maxi:1::2 msi; C1 C2 isub (5.36)

122 CHAPTER 5. COMPILING THE SUBLANGUAGE
Example 5.5.1 (Toy translation). Compiling our simple Toy class from Example 3.2.4 generates the following abstract class file:

h h i ; Toy ; Object ; h i ; [hToy; inti 7! hint ; CODEi] i (5.37)
where

CODE = h3; 25; 2; 167; 0; 21; 21; 1; 4; 100; 25; 1; 4; 25; 3; 21; 2; 21; 2;

96; 25; 2; 21; 1; 157; 255; 238; 21; 2; 172i

which is more readable as

CODE = iconst 0 istore[2] goto[+21] iload[1] iconst 1 isub

istore[1] iconst 1 istore[3] iload[2] iload[3] iadd
istore[2] iload[1] ifgt[-20] iload[2] ireturn

or even

pp CODE Remarks

0 iconst 0
1 istore [2] m is local variable 2
3 goto [+19]
6 iload [1] n is local variable 1
8 iconst 1
9 isub
10 istore [1]
12 iconst 1
13 istore [3] r is local variable 3
15 iload [2]
17 iload [3]
19 iadd
20 istore [2]
22 iload [1]
24 ifgt [-18]
27 iload [2]
29 ireturn

For comparison, Example A.1.1 shows the code generated by Suns javac compiler. We see that the code is identical to the code produced by javac except that
our translator does not include as many "compact" special case instructions such
as istore 2 that takes one byte instead of istore[2] that takes two bytes.

Example 5.5.2 (Compiling Tax). This is a somewhat larger example.
< 1 : fieldref(Income,total,ReadOnlyAmount) ,

2 : methref(Amount,<get,<>>,int) ,

5.5. EXPRESSION COMPILATION 123

3 : 10000 ,
4 : 5000 ,
5 : fieldref(Income,tax,OnlyAmount) ,
6 : methref(Amount,<set,<int>>,V> ,
7 : fieldref(Income,available,Amount) ,
>,
Tax,
Object,
< 0 aload[1]

2 ifnull[+4]
5 goto[+3]
8 iconst_0
9 ireturn
10 aload[1]
12 getfield[1]
15 invokevirtual[2]
18 istore[2]
20 aload[1]
22 getfield[1]
25 invokevirtual[2]
28 ldc_w[3]
31 isub
32 ifgt[+10]
35 iconst_0
36 istore[3]
39 goto[+27]
42 ldc_w[4]
45 istore[3]
48 iload[2]
50 ldc_w[4]
53 isub
54 istore[2]
56 aload[1]
58 getfield[5]
61 iload[3]
63 invokevirtual[6]
66 aload[1]
68 getfield[7]
71 iload[2]
73 invokevirtual[6]
76 iconst_1
77 ireturn
>

124 CHAPTER 5. COMPILING THE SUBLANGUAGE
Compared to Example A.1.2 we see again that the code is identical except for the
ordering of the if statement and the use of compact versions.

5.6 Putting It All Together
With the translation above all the components are specified. To summarize: we first
gave the judgments for the static and dynamic semantics of JavaOb and JVMOb in
each of the two preceding chapters:

JavaOb JVMOb
Static ` P ` CFs
Dynamic ` P; ST ) v; oe ` CFs; ST ) w; H

Then in this chapter we have added translation judgments:

Compile-time Run-time
Translation ` P ! CFs ` v; oe ! w; H

We can compose these two express formally what it means to execute a JavaOb
program in the JVMOb runtime environment.

Given a JavaOb program P and a startup problem ST. The user's view of executing the JavaOb program is expressed by the following proposition:

` P ` P ! CFs ` CFs; ST ) w; H ` w; H ! v; oe

` P; ST ) v; oe (5.38)

This makes it explicit that in order to execute a JavaOb program one should

1. type-check it,
2. compile it,
3. run the compiled code, and
4. reconstruct the run-time state corresponding to the resulting heap;
the only judgment of these that we have not specified in the thesis is how a value/store
pair corresponds to a machine value/heap pair, expressed by ` w; H ! v; oe, but this
is simple by "forgetting" all the heap addresses.

The inference can also be seen as a proposition stating the completeness of
the result obtained by running the compiled code: if the compiled code runs correctly for a well-typed program then we can reproduce the result with the dynamic
semantics.

Another interesting property is type soundness of the source language, studied
by several other authors (we comment on this in the conclusion). It is based on the

5.6. PUTTING IT ALL TOGETHER 125
usual subject reduction, denoted "SR", is the equation for programs (which ripples
down to similar equations for each syntactic category):

` SR(P)

` P; ST : T ` P; ST ) v; oe v; oe : T 0

` SR(P) T :* T

0 (5.39)

Again we need to specify the (easy) rules for typing a program/startup pair and a
value/store pair.

In future work we hope to be able to prove these results using the techniques
of Kahn (1987).

Chapter 6
Secure Bytecode Verification on aJava Card

In this Chapter we suggest how bytecode verification of JVMOb bytecode could be
realized on a Java Card, extended to allow download of applets on the fly. In particular we apply ideas from Proof Carrying Code (Necula and Lee 1996a, Necula
1997) in order to eliminate the iterative part of bytecode verification from the Java
Card, hence reducing the space-consumption complexity from that of a typical
verification algorithm (a standard dataflow algorithm (Muchnick 1997)) without
introducing new security holes or relying on a trusted relation.

In Section 6.1 we discuss our approach to bytecode verification of downloaded
applets and explain how this can be realized by applying ideas from Proof Carrying
code. In Section 6.2 we present a formalized specification of a proof certificate
and argue why this makes it possible to reduce bytecode verification to bytecode
checking along the lines of Section 4.4 without introducing new security holes.
Then in Section 6.3 follows an algorithmic specification of the bytecode checker
and certificate. We argue that this can be done within a reduced space consumation
in comparison with the officially specified bytecode verifier.

6.1 Verification and Proof Carrying Code
We discuss our approach to bytecode verification of applets, downloaded on a card,
and explain how this can be realized by applying ideas from Proof Carrying code.
Hence, eliminating the iterative part of bytecode verification from being performed
on the Java Card.

Discussion 6.1.1 (Downloading applets on card). Today, it is not possible, with
the current card design, to download applets onto a Java Card (Sun 1997b). (Something which is reflected by the fact that the JCVM class-file format is not standardized as it is for the JVM.) In the future, however, we imagine that this will be one of
the aspects demanded by Java Card users for reasons illustrated by Example 1.2.1.

126

6.1. VERIFICATION AND PROOF CARRYING CODE 127
In order to add this feature to the current Card functionality, several things have to
be taken into consideration:

ffl Dynamic class loading must, to some extend be permitted, hence some security management may have to reside outside ROM.

ffl A class file format should be decided.
ffl The idea of an independent, personal, communication card encourages its

use for carrying personal and financial information, i.e., sensitive information, which strongly requires that the loaded applets are "safe" to execute.

ffl Safety procedures are normally either performed by the CAD (Card Acceptance Device), or directly on the Java Card. The former imposing an extra
level of trust between the applet producer and the applet consumer, the latter
putting forward space requirements which may not be possible to fulfill on a
Java Card.

ffl Assuming that safety is checked directly on the Java Card, the question raises

how much space it requires to be stored, and how much it requires to run,
and where on the card the safety procedure should be placed: ROM or RAM.

Remark 6.1.2 (Approach). Our approach to these questions is to consider how
to guarantee bytecode safety through verification performed on the card directly
instead of in the associated CAD. This with the intention of keeping the number
of trusted levels between applet producer and consumer at a minimum. Secondly,
we imagine the verification algorithm to be masked directly into the ROM, because
the bytecode verification algorithm is not expected to change in any essential way.
Consequently, the following issues has in particular to be addressed during the
design of such an extendible card:

ffl Because Java Cards are typically published in millions of copies, serious efforts should be taken to avoid storing an erroneous verifier in the unchangeable ROM. In this case, with a rather small piece of code, it is without doubt
worth going through the time and effort of providing a formal security evaluation of the bytecode verifier card program. This including a formal specification and an automatic verification of the bytecode verifier, e.g., following
the industrial ITSEC standard evaluation scheme (ITS 1997).

ffl The verification algorithm must be sufficiently small for it to be realistic to be

stored in ROM. To put this into pespective, the current Sun implementation
of the Bytecode Verifier in the JDK (written in C) uses approximately 1
MB of storage. Clearly, it is out of reach to place it on a card, even when
assuming serious advances in Java Card technology.

ffl Care should moreover be taken that the bytecode (dataflow) verification algorithm uses as little RAM as possible, this being a sparce and expensive

128 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD

ressource as indicated in Section 2.1. In other words, the the worst case
space complexity should be analysed and kept within the given limitations.

Discussion 6.1.3 (Borrowing from "Proof Carrying Code"). Because a Java Card
is imagined primarily to contain sensive information, we want the Java Card to trust
the applet sender as little as possible. This drawing our attention towards the Proof
Carrying Code technique, in the following denoted "PCC". (For an introduction
we refer to Section 2.4). As we shall see, this also makes it possible to reduce
bytecode verification to a bytecode check on the card, along the lines which were
formally discussed in Section 4.4. There are several reasons for considering Proof
Carying Code in connection with verification on card.

ffl There is no need for trusting the applet or other parties at all.

ffl Method frame-type descriptors seem to illustrate the PCC "Certificates", justifying that the bytecode adheres to the bytecode safety requirements.

ffl The Bytecode Checker, formally specified in the previous section for JVMOb, seems to illustrate the PCC notion of a "Proof Checker", checking
whether a method frame-type descriptor, adheres to the bytecode it comes
with.

ffl Currently existing Bytecode Verifiers seem to closely mimic a "Proof Generator", generating a method frame-type descriptor for those methods which
are safe. By "close" we mean the following: according to the official specification (Lindholm and Yellin 1996, $4.9.2), a bytecode verifier records information about each program point, terminating with what we called the
complete method frame-state types in an array structure. This information
could without problems be exploited in a subsequent certificate, construction
pass, hence would not require existing bytecode verifiers or compilers to be
rewritten.

In order for certificate information to be carried over without violating the existing
JVM class-file format, we suggest to add a method attribute (Lindholm and Yellin
1996, $4.7), the safety-certificate attribute, as a compulsary part of an extended
Java Card class file format.

We proceed by evaluating the space consumption of what we know or will
require from a Verifier, a Checker and a Certificate. This in order to identify the
"bottlenecs" with respect to the available memory on a Java Card.

Discussion 6.1.4 (Space-critical consumption). We consider two aspects: an estimation of the expected or known (byte) size of an implementation, or the expected
or known (RAM) space consumed when running the algorithm.

Size of a Verifier We recall that the current Sun implementation of the Bytecode

Verifier for full Java in the JDK (written in C) uses approximately 1 MB of
storage. Evidently, something of those dimensions is far too big to fit on a
Java Card.

6.1. VERIFICATION AND PROOF CARRYING CODE 129
Size of a Checker This requires an implementation, or at least an algorithm, in

order to analyse which data-structures are build and how these could be compressed are encoded.

Space consumed by a Verifier The official specification of the Bytecode Verifier,

roughly explains how verification is expected to be implemented (Lindholm
and Yellin 1996, $4.9.2):

: : : the bytecode is broken up into a sequence of instructions, and
the index into the code array of the start of each instruction is
placed in an array. The verifier then goes through the code a second time and parses the instructions. During this paa a datastructure is built to hold information about each Java Virtual Machine
instruction in the method. : : :

That is, requiring a frame-state type for each instruction to be stored. Eventhough various compression techniques (Tichy 1985) can be applied, the
space needed to maintain the method frame-state type under the dataflow
evaluation, is hence linear in the number of instructions.

Space consumed by a Checker The Bytecode Checker, specified in Section 4.4,

describes how bytecode checking is performed given a method type descriptor, that is a function assigning to each program point, a frame-state type.
Generally speaking, however, it is not satisfactory to represent this function by a frame-type description of each program point, even when applying
compression techniques, because this would always be linear in the number
of instructions, precisely as was the case for the Bytecode Verifier. With a
limited RAM, as on a Java Card, this seems not a feasible.

Size of a Certificate Should be considerably smaller than the proof it is accompagning in order to be a meaningful. As pointed out by Necula and Lee. (1997),
most logical encodings (namely those which can be encoded in their logical
framework) permit a compression of a certificate by removing redundant information in the proof, an encoding the remain informassion. Eventhough
we do not pursuit their strictly formal approach within the time limits of this
master thesis, this permit us, at least informally, to argue for the optimizations which we will apply in the following section.

We summarize the problems to be resolved. The size of a certificate must
be considerably smaller than that of the migrating applet it is accompagning, and
small enough to fit on a Java Card until checking has been performed. The memory
consumed by the checker algorithm must respect the space limitations of the Java
Card RAM. Finally, the size of an actual implementation of the Checker algorithm,
should be feasible in the Java Card ROM.

In the two next section we outline a definition of certificates with an associated
algoritm with these properties.

130 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD
6.2 A Secure, Optimized Certificate
In Discussion 6.1.4 we stated some space-critical "bottlenecks" to resolve in order
to adapt verification to a Java Card. In this section, we will consider the size and
hence a design for a compact Certificate used by an appropriate Bytecode Checker
algorithm, which is based on the abstract specification in Section 4.4. We argue,
that the size of such a Certificate, depends on the number of branches, and suggest
an algorithm for a Bytecode Checker, exploiting such a certificate. Finally, we
argue why these optimisations neither introduce new security holes, nor cause the
checker to perform wrongly.

Remark 6.2.1 (Concrete JVMOb representation). In the following, we apply the
JVM terminology in relation to the abstractly specified JVMOb, meaning the concrete representation of JVMOb class files and method bytecode. We recall, that all
JavaOb programs (and thus all JVMOb class files) are designed to run on a Java
system cf. Principle 3.1.2. In this section, we thus write JVMOb, when we refer
to its associated, concrete JVM-representation (for a detailed discussion of how
JVMOb relates to JVM, we refer to Discussion 4.2.10).

DEF: bytecode sequence order = code array order.

The main goals for a Java Card, bytecode checker algorithm, using a Java Card
certificate can be listed as follows:

Principle 6.2.2 (Goals).

ffl A Java Card Bytecode Checker algorithm should only go linearly through

the JVMOb bytecode sequence being checked.

ffl A Java Card Certificate should supply the Checker with as little extra information as possible.

ffl All information, supplied by the Certificate, should not give rise to new security holes.

We start our analysis by the following observations about the JVMOb- instruction's control flow and state transition behaviour:

Discussion 6.2.3 (Bytecode instruction behaviour).

1. We recall that each JVMOb instruction describes a frame-state transition

from the associated program point to the one executed immediately afterwards (for the if-instruction, there are two possibilities, though) specified
by their runtime effect. (For the complete specification of the JVMOb runtime state-transition system we refer to Definition 4.5.6.) For all instructions
except: goto, return, ireturn and areturn, this includes the program point following immediately in bytecode sequence order.

6.2. A SECURE, OPTIMIZED CERTIFICATE 131

2. The iterative part of bytecode verification in JVMOb is either caused by one

of its conditional jump-instruction, i.e., the branching instructions ifeq, ifgt,
or ifnull, or the unconditional jump-instruction, i.e., goto.

3. The initial frame-state type for a method being verified is specified in Definition 4.1.11. We notice, that all type information constituing the initial
type, i.e., the (static) reference type of the class on which the method is
called and the (static) argument types, are directly available in the loaded
class file (Lindholm and Yellin 1996, $4.4). Hence the initial frame-state
type (corresponding to program point) does not need to be provided by a
certificate.

4. Bytecode verification always starts by the first instruction in a method's JVM

code array (Lindholm and Yellin 1996, $4.9.2). For JVMOb, that means the
instruction at program point 0 of the method bytecode sequence.

Definition 6.2.4 (Delimiter instructions). We will refer to the instructions goto,
return, ireturn or areturn as delimiter instructions.

From the above, we gain the following insight:
Ad 1. The frame state following a delimiter instruction in the code array cannot in general be deduced from its predecessor (except in the special case
where the jump is to the successor). This suggests that if we a priori are
given a frame-state type after such a delimiter-instruction, we can step-wise
reconstruct, in successive code array order, a frame-state type-path using
the predefined rules for the instruction's state transition behaviour, until the
subsequent delimiter-instruction is encountered.

Ad 3,4. In addition to the insight just discussed, we conclude that from the beginning of all bytecode to the first delimiter instruction in code array order,
we can automatically reconstruct a frame-state type-path as just described,
without depending on other information than that given in the constant pool
and that given by the instruction's state transitional behaviour.

Ad 1,2. These observations suggest that any algorithmic analysis should be based

on the bytecode flow-graph, i.e., a graph which illustrates the control flow
for some

machine code, as illustrated by Example 4.4.20.

In order to perform a flow-based analysis (Muchnick 1997) on the bytecode we
need to adapt the notion of a basic block (Aho et al. 1986) to JVMOb bytecode:

Definition 6.2.5 (JVMOb basic block). A JVMOb basic block is a bytecode fragment without jumps to internal instructions.

132 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD
Remark 6.2.6. An "internal" instruction is one that is not the first in the bytecode
fragment. For JVMOb this means that a delimiter instruction may only appear as
the last instruction in a basic block. Moreover, all possible jumps to a basic block
goes to the first instruction.

Remark 6.2.7 (Internal basic-block type-check). With the new definition of basic blocks we have, cf. Discussion 6.2.3, that each basic block can be type checked
by going step-wise through the instructions, given the frame-type of the first instruction in that block; something which only require that we can store one framestate type at a time whilst comparing it with the subsequent frame-state type.

Remark 6.2.8 (Dead code). Notice that for Java bytecode, "dead code" is not allowed (Gosling, Joy and Steele 1996, $14.19), i.e., all instructions should be reachable. We tacitly assume the same for JVMOb.

In other words:
Proposition 6.2.9 (JVMOb bytecode connectivity). Flow-graphs which are constructed from safe JVMOb method bytecode are connected graphs, rooted in the
basic block which contains the first instruction in the method code array.

Principle 6.2.10. Since we have not considered checking for dead code as part of
our verification, we tacitly assume, that all JVMOb method bytecode to be verified
or checked, is a priori "free" from dead code.

We can now concentrate on the relation between basic blocks, given by the
jumps from one to the other.

Observation 6.2.11 (Basic-block type-check order).

1. The basic blocks of a JVMOb method bytecode are organized in a connected

flow-graph rooted in the basic block which contains the first instruction in
the code array (program point 0). Thus the graph has a spanning tree which
defines a partial order with the root block as the least element.

2. So if we give a sequence of the blocks which is topologically sorted by this

ordering then for each block there is a jump to it in one of the preceeding
blocks. Thus, if we check in that order from the least basic block, we already
know the frame type to use for the first instruction in this block.

Remark 6.2.12 (Block ordering). The pre-ordering of the basic blocks requires a
pre-processing of the bytecode which sorts and devides the blocks into the checkorder described. Because the program point of the first instruction in each basic
block uniquely identifies the block, it suffices to order these in an ordered set,
giving the order of checking. In our context, it is only feasible with respect to a
Java Card, if we let the code producer provide this set, and let it be provided by a
Certificate.

6.2. A SECURE, OPTIMIZED CERTIFICATE 133

Assume for a moment, that such an order has defined in what sequence the
basic blocks of a method's bytecode should be checked.

Discussion 6.2.13 (Jump analysis). We need to describe, how to manage the checks
caused by branching instructions. Recall that these can appear all over, but that
they all jumps to the beginning of a basic block. If we want only to go through
the basic block once with a minimum of storing, this should be done as decribed
in Remark 6.2.7. However, we have to mark the frame-types of those program
points which are either jumped to or jumped from, since these are the places where
frame-types has to be checked against each other according to the rules given by
the abstract Bytecode Checker specification in Definition 4.4.11. First we analyse
forward and backward jumps (in code array order) individually.

Jumps to unvisited basic blocks: When meeting a jump to a basic block we have

not yet visited then we do not know the frame type associated with that
program point. Therefore we must save a delayed check to be triggered
when we reach that program point later. At that time we then need to know
what the frame state was at this program point, so that needs to be saved.

Thus the Checker can (and must, see below) itself save and manage a set
of frame states meant to be saved against later, and the locations where the
delayed check must happen.

Jumps to previously visited basic blocks: When meeting a jump to a basic block

we have already visited, we must have saved the frame type back then to
be able to do the comparison. This requires that the user indicated that the
program point, which is the target of this instruction, is "interesting" and
must be saved. When the actual backwards jump is encountered then the
check can be performed immediatetely.

Thus the user is responsible for marking the program points to which there
will be jumps later when they are encountered before the corresponding
jump: these we cannot know in advance from going successively through
the code. Either we have to "give in" and perform an iteration, or we perform
a pre-verification of the bytecode, providing us with the correct frame-state
types, which can then be checked straight away.

Frame type merging: When studying the effect of an instructikon on the frame

type the checker should always attempt to preserve as much information as
possible, i.e., whenever the semantic rules require a "v" relation between
frame types then we interpret this as the most conservative, namely "=".
However, sometimes this will give a conflict later, as we saw in the verification examples last in Section 4.4: if several types are merged then we have
to pick a more general type when deriving it from the information in just one
execution flow.

134 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD

We propose that the user is permitted to insert explicit "deltas" describing explicitly if components of the frame type are less defined than what the default
procedure proposes. (The name "deltas" we borrow from Tichy (1985)).

The previous analysis towards a Bytecode Checking algorithm on a Java Card
with a minimum of RAM available, hence suggest that two sorts of extraordinary
space-consuming operations should be done "off-Card" and send with a Certificate:
cf. Remark 6.2.12, the sender should provide the program points identifying the
basic blocks of the bytecode, and the order in which they should be checked. Then,
cf. Remark 6.2.13, the sender should provide the frame-types of the backwards
jumps and the program points to which they adhere. This is formalised here.

Definition 6.2.14 (Bytecode certificate sorts). A bytecode certificate is a structure with sufficient information to permit verifying the bytecode in a single pass.
It is a table as follows:

mc 2 MCertificate = Delta \Theta  Label

ffi 2 Delta = PPoint fin\Gamma ! (FTDelta \Theta  STDelta)

FTDelta = FrameType ! FrameType

STDelta = StackType ! StackType

` 2 Label = PPoint fin\Gamma ! (true + false)

with the constraint that all functions in FTDelta and STDelta are v-monotonic, i.e.,
always return a type descriptor that is less defined.

A pair hffi; `i is used to denote the certificate for an entire method, where

ffl ffi(pp) describes the downwards distance from the ft that is guessed by the

algorithm to the ft that is actually the one in the certificate.

ffl `(pp) indicates if the program point as being a target of a jump.

MCertificate denotes the certificate for an entire method, ordered by program point.
Hint is the hint needed at the program point.
SequenceHint means merely that after the instruction at the program point another

one should be used than the default.

FrameTypeHints, FrameTypeDelta denotes hints to the checker that makes it possible to reconstruct the FrameType for the program point correctly the first
time. The ffi component type hints at which parts of the default frame type
need to be replaced with smaller components to make it right (this should be
clear from the examples below).

Label means that the present program point is the target of a jump from a program

point not yet visited.

6.3. A CHECKER ALGORITHM 135
However, the certificate is best illustrated with an example.
Example 6.2.15 (Toy certificate). The Toy class verified in Example 4.4.20 has
the certificate

h[ 3 7! [22 7! h'; 'i] ; 29 7! [6 7! h'; 'i] ] ; 22 7! hlabelii
since with that sequencing the default frame type is always right. We do, however,
need the sequencing because the goto is a delimiter and thus does not have a default
frame type for the instruction immediately after it in the code array. And we need
the label because if program point 22 is checked before program point 20 then we
must save the frame type at 22 such that it is available for testing when we get to
instruction 20. Finally the delimiter ireturn in program point 29 must specify 6 to
ensure that we pass through all instructions once.

Example 6.2.16 (Certificate for Tax). This is empty since there are only forward
jumps in the Tax code!

Discussion 6.2.17 (Safety analysis). What is needed to make sure that the checking is tamper-proof ? Essentially we must ensure that only methods where a verification proof exists can be accepted by the checker. This amounts to ensuring that
all individual constraints imposed during verification are checked. Since the logic
"per instruction" is the same in the two systems the only real trouble is to prove
that all instructions are reached and all delayed tests are performed.

6.3 A Checker Algorithm
Definition 6.3.1 (auxiliary sorts). Add the following sort definitions.

saved; delayed 2 CheckList = (PPoint \Theta  FrameType)\Lambda 

checked 2 CheckedSet = P(PPoint)

p 2 PPpoint?

We generalise n and 2 to also denote list element removal and membership test.
Definition 6.3.2 (auxiliary procedures). Define the following auxiliary procedures:
init state(ACID; SIG) returns hffl; lvt0i] as defined by (Method Check) of Def. 4.4.8.
instruction possible(C; pp; ft) is true if the constraints imposed on the frametype

before execution of the instruction C(pp) are satisfied by ft. The constraints
are defined by those of the side-conditions to the single instruction check
rules of Definition 4.4.11 that do no depend on other program points than pp.
(So they do, for example, include checking for stack overflow.)

136 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD
follower(C; pp; ft) has two cases: (1) If C(pp) is a (Return Instruction) or a (Goto Instruction)

then h?; fti is returned. (2) In all other cases the program point and frame
type representing the standard continuation of the instruction is returned,
namely hpp0; md(pp0)i that would be obtained from the rules of Definition 4.4.11 from the parameters if v in the rules is replaced by =.

jump(C; pp; ft) similarly has two cases: (1) If C(pp) is a jump instruction (with

code offset) then the hpp00; md(pp00)i that would be obtained from the rules
of Definition 4.4.15 is returned. (2) If C(pp) is not a jump instruction then
h?; fti is returned.

Definition 6.3.3 (lightweight bytecode checker). Given a class hierarchy s 2 SuperClass,
a class ACID 2 CLASSID with CP 2 CONSTPOOL, a method signature SIG 2 SIG,
the mi 2 METHINFO where the code contains the program points PP 2 P(PPoint),
and the method's lightweight certificate mc 2 MCertificate.

The algorithm is described by the following procedure which terminates either
when executing ok denoting that the algorithm accepts the code, or by executingfail

meaning that it rejects it.

1. Initialize.

saved := ffl; checked := /0; delayed := ffl;
hrmt; hms; mlv; Cii := mi;
hp; fti := h0; init state(ACID; SIG)i.

2. Use certificate.

ft := ffi(pp)(ft);
if `(pp) then saved := saved \Delta  hp; fti.

3. Check instruction constraints.

if not instruction possible(C; p; ft) then fail.

4. Check delayed constraints.

for each hp0; ft0i 2 delayed where p0 = p
do if ft 6v ft0 then fail;

delayed := delayed n hp0; ft0i.

5. Advance.

checked := checked [ fpg.

6. Compute possible continuations.

hp1; ft1i := follower(c; p; ft);
hp2; ft2i := jump(c; p; ft);
if p1 6= ? and p1 =2 checked
then hp; fti := hp1; ft1i; p1 := ?;
else if p2 6= ? and p2 =2 checked

then hp; fti := hp2; ft2i; p2 := ?;
else if delayed 6= ffl

6.3. A CHECKER ALGORITHM 137

then hp; fti \Delta  delayed := delayed;
else p := ?.

7. Check saved primary.

if p1 6= ? and p1 2 checked
then if no ft0 where hp1; ft0i 2 saved

or there is but ft0 6v ft1
then fail.

8. Check saved or delay unsaved secondary.

if p2 6= ?
then if p2 2 checked

then if no ft0 where hp2; ft0i 2 saved

or there is but ft0 6v ft2
then fail;
else delayed := delayed \Delta  hp2; ft2i.

9. Terminate or reiterate.

if p = ?
then if checked = PP

then ok;
else fail;
else repeat from step 2.

Theorem 6.3.4. If the lightweight bytecode checker accepts with inputs s; ACID; CP; SIG; C; mc; PP,
and C has the program points PP, then s ` CP; ACID; SIG; mi : md is provable.

Proof. The proof is by showing that an execution of the algorithm resulting in accepting a method implies the existence of a proof tree for s ` CP; ACID; SIG; mi :
md. Recall that we only show implication, so we can make demands on the certificate as we need them (in fact this proof can be read as the rules for creating the
certificate).

We first observe that the initialization step 1 indeed constructs the values needed
in the premise of the root rule, (Method Check). This subproof for the premise
will always be a right-recursive list of (Proper Sequence)-steps terminated by one
(Empty Sequence) step; these only serve to ensure that there is one judgement
\Xi  ` pp; I : md ! pp0 for each program point.

Each of these again is just a collection of sideconditions checked by instruction possible except for the constraints involving other program points. Thus we
first observe that instruction possible(C; pp; ft) is invoked once for each pp 2 PP
because at that point pp is added to checked, and acceptance is guarded by the
condition that PP = checked. This also ensures the termination of the algorithm:
each run through the loop will start with a p =2 checked (and p 6= ?) and will add
that p to it.

What remains to prove is thus that the algorithm will establish a value for md
that satisfies all the constraints. Define this by setting md(p) = ft just after step 2.

138 CHAPTER 6. SECURE BYTECODE VERIFICATION ON A JAVA CARD
Now consider the constraints introduced by the rule corresponding to the present
instruction. Each introduced constraint will, after we have chosen the next instruction in step 6, be either

ffl "primary saved," a comparison of ft with md(p), p 2 checked, which will

be checked by step 7 (requiring that hp; md(p)i 2 saved, i.e., that `(p2)), or

ffl "primary new," a comparison of ft with md(p), where p =2 checked which

will be checked implicitly the next iteration (the one for p) provided we
ensure that md(p) = ffi(p)(ft) and ffi(p) is FrameType-decreasing (note that
p can be either of p1, p2, or extracted from delayed), or

ffl "secondary saved," a comparison of ft with md(p2) where p2 2 checked,

this is checked immediately afterwards by step 8 (requiring that hp2; md(p2)i 2
saved, i.e., that `(p2)), or

ffl "secondary new," a comparison of ft with md(p2) where p2 =2 checked

when p = p1), this is stored into delayed.

Clearly all the constraints are trivially discharged except those delayed. That they
are also discharged can be seen from the fact that each pair in delayed is either

ffl selected by step 6 at some point, thus discharged implicitly by the next iteration, or

ffl discharged by being checked explicitly by step 4.
Thus we see that all side conditions of all the rules in the proof tree can be satisfied
by appropriate choice of the certificate.

Discussion 6.3.5 (complexity). The time-complexity of the checking is almostlinear in the code size, since the code is traversed exactly once. The interesting
issue - and the critical issue for Java Cards - is the space consumption. This is
linked to the

ffl certificate size: for every label we must store a full frame type (in saved),

and

ffl number of non-resolved forward jumps since each results in storing a full

frame type (in delayed).

Thus the order chosen for the traversal is significant.
Example 6.3.6 (tax computation). Let us conclude with a small example of a tax
computation applet, i.e., some bytecode implementing the getTax method discussed in the introduction, taking one EconReader argument and returning an

6.3. A CHECKER ALGORITHM 139
Amount object. It's code is the following 31 bytes (for instruction lengths consult
Lindholm and Yellin 1996, Chapter 6):

0 : aload[1]; invokevirtual[1];
5 : ifeq[];
8 : aload[1]; invokevirtual[2]; astore[2];
15 : aload[2]; invokevirtual[3]; astore[2];
21 : aload[1]; aload[1]; invokevirtual[1];
28 : ifgt[-\Lambda ]; areturn:

with a constant pool describing the invoked methods (ignoring the method names
that do not matter):

1 7! methref(EconReader; h ; ffli ; Int)
2 7! methref(EconReader; h ; ffli ; Amount)
3 7! methref(Amount; h ; ffli ; Amount)

The certificate for this code must satisfy two constraints to be valid: (1) `(15)
must be true, because there is a backwards jump to it, and (2) ffi(21) must force the
frame type for local variable 2 to ? because there is a froward jump to 21 where
the delayed constraint has a frame type with local variable 2 uninitialized. Then
the algorithm will accept the method.

Chapter 7
Conclusions
In this Chapter we first present our main contributions; then in Section 7.2 follows a
presentation on works done by others in this area and finally in Section 7.3, we list
those (many) questions and ideas which came along while working on this master
thesis.

7.1 Contributions
The main single contributes of this master thesis are as follows:

ffl The proposition of a new technique towards making bytecode-safety verification on a Java Card feasible.

ffl A formal definition of a Java sublanguage which is sufficiently small to fit

on a Java Card; however interesting in that it maintains an object model with
all the basic instance related features: instance methods, instance fields, instance creation, etc. In particular default initialization of fields upon method
creation, and dynamic method lookup upon method invocation has been formally specified by the dynamic semantics.

ffl A formal specification of a translation from the sublanguage to the Java Virtual Machine, which defines a subset of the Virtual Machine which includes
instructions for creating and manipulating instance related features.

ffl A formal definition of the Virtual Machine for the subset, including a semantical specification of the Java bytecode verifier restricted to the subset Virtual
Machine, hence a formal specification of bytecode safety. This, requiring a
proper, formal abstraction of the set of machine types.

ffl A formal specification of how classes are dynamically loaded at the Virtual

Machine level, a formal specification of field resolution, and finally a formal
specification of class resolution.

140

7.2. RELATED WORK 141

ffl The presence of all four semantical components specified with the same

specification formalism: the static and dynamic semantics of the source level
language, the static and dynamic semantics of the machine level code, provide a perfect framework for proving semantical properties, (primarily correctness of the translation).

We conclude that a basic, formal framework, focused on object oriented features has been provided for a Java sublanguage small enough to fit on a Java Card.
This being a first step towards the extending the functionality of Java Cards to include applet download in a secure manner. Based on this, we have proposed a new
technique, both formally and by a a detailed algorithmic specification, and argued
why this does not introduce new security leaks. We think that this master thesis
all together provides not only a promising but also formally grounded step towards
making bytecode verification on card feasible in a secure manner.

7.2 Related work
We have found no publicly available work which deals with the problems of downloading programs, notably applets, to work on Smart Cards, notably Java Cards,
without applying cryptographic methods or other trust-based techniques. Several
people, however, have been contributing in adjacent areas; in particular during the
last year, many articles have emerged treating different operational formalization
aspects of Java.

Sun/Visa standard for Java/Smart Cards Recently, Sun and Visa/Eurocard/Mastercard

announced a new standard for smart cards that is claimed to contain a facility
for downloading authorized code. We do not yet know the details.

Type soundness formalizations of Java One of the first to approach and report

this subject are Drossopoulou and Eisenbach in January 1997 (Drossopoulou
and Eisenbach 1997a). Later that year, at the ECOOP'97 conference, they
present a formal type soundness proof for a major subset of the java source
language given as a formal property of the dynamic semantics of the subset (Drossopoulou and Eisenbach 1997b). The treated subset is called the
"sequential" or the "kernel" of Java, i.e., Java without parallel features (threads):
notably primitive types, classes, interfaces, inheritance, instance variables
and methods, objects (that is class instances and multiple arrays), and exceptions. Hence excluding static methods and static variables, local variables, initializers, finalizers, constructors, class modifiers, abstract classes
and methods, the super-class relation (super), strings, numeric promotions,
widenings, packages and concurrency. This subset is hence very close to our
JavaOb subset described in Section 3. It mainly differs on four points: the
treatment of exceptions, arrays, and interfaces which we have excluded, and
local variables, which we have included, since they play an essential part in

142 CHAPTER 7. CONCLUSIONS

bytecode verification analysis. Most of the syntactical sugar imposed to ease
the formal analysis on the two subsets are interestingly the same: field variables X must be denoted this.X in order to recognize them syntactically as
such, and class declarations as CLASSID ext CLASSID in order to introduce
the class hierarchy directly at the syntactic level. For the same reason, we
moreover require that method argument expressions are written as explicit
cast expressions in JavaOb in order for the static types to be available at the
syntactic level.

Where the purpose of formalization for Drossopoulou and Eisenbach is to
prove type soundness, our formalization has been to have a way to reason
about program safety at the program level. A difference which has been
reflected by the difference in the use of formalization formalisms: where
we use Natural Semantics, hence a "big step" approach, Drossopoulou and
Eisenbach use a Transaction Semantics, hence a "small step" approach. This
means that their rules have to formalize the entire Java state, essentially making it available to all rules. This makes localized data, such as local variables, troublesome to represent. This they overcome by simply excluding
them, something which has no real importance for the type soundness proof,
wheras local variables are essential features in analysing the dataflow, and
hence the program safety.

Automated type soundness formalizations of Java The proof and formalization

work of Drossopoulou and Eisenbach was subsequently automated by Syme (Syme
1997) by means of the theorem prover DECLARE. A process which unravelled two significant faults in the formalization work, apparently due to
the small step approach. In parallel with the work by Drossopoulou, Eisenbach and Syme, Nipkow and Oheimb provided an automatically verified type
soundness proof which was presented at the POPL'98 conference for yet another Java subset, BALI, based on a formalization of its dynamic semantics
using the theorem prover Isabelle/HOL (Nipkow and von Oheimb 1998).

In this section we have chosen only to discuss the formalization approach
taken by Nipkow and Oheimb and compare it with JavaOb, since their basic
formalization approach is that of a "big step"semantics like for JavaOb, and
since the formalization by Drossopoulou and Eisenbach and hence the basic
approach taken by Syme has already been discussed above. (Formalization
aspects which has to do with the general aspect of automatization, is just
as well covered here.) At the end, however, we give our opinion on future
automatization work.

The subset, BALI or Javalight, is syntactically very close to the one given by
Drossopoulou and Eisenbach and yet to our JavaOb. The main difference is
that only a very few system exceptions are treated. Otherwise the difference

7.2. RELATED WORK 143

with JavaOb is really the same as with JAVAs. We notice, that also BALI's
conceptual view of a Java program which has never been officially specified,
is the same as for JavaOb: a (finite) collection of classes and interfaces (notexisting for JavaOb, though, but easy to add). Three semantic generalizations has been adopted for BALI with respect to the official Java semantics:
widening of a method's return type if it is overriden by yet another method
(normally strict identity is required) and no check of result types in dynamic
method lookup; moreover, the type of an assignment is determined by the
right-hand side (instead of the left-hand side). The first two generalizations
simply help the dynamic method-lookup process (for a detailed description
of this we refer to Section 3.5.14); the latter eases the assignment processing,
since the complicated expression normally is to find on the right hand side.

The formalized representation of BALI's syntax is based on the type system
of ISABELLE/HOL (HOL's logical types). Since the well-foundness of inductively or recursively defined relations such as subclass and subinterface
relations is not expressible within this system, the representation of program
syntax and environment structures must support a "hand-written" proof argumentation herefore. In particular, representations are limited by the set of the
available, finite built-in types of ISABELLE/HOL such as (none-recursively
defined) lists and tuples. The possibility of representing BALI structures by
finite ISABELLE/HOL types, is essential for the none-automated proof of
well-foundness properties. In JavaOb, however, we have taken the liberty
of using a variety of algebraic features whenever we find it convenient to
improve readability. In BALI, declarations are hence represented as finite
lists or tables, where we introduce sets with descriptive constructor names,
or finite functions with descriptive names to express the same.

With respect to the formalization of the BALI and JavaOb semantics, their
type and evaluation environment structures, contain the same, basic information components as ours. Their way of building these structures, however, is
significantly different. In JavaOb, we depart from a syntactical correct program (a one-to-one abstraction of a concrete Java program). From this we
constructively build the semantic environment structures. This is formalized
by a preprocessing semantics in Section 3.3. In BALI, however, environment structures are automatically given as the result of a process outside the
formalization. Hence an evaluation environment is organized as a mixed
representation of abstract program syntax, prog, and static type-information
annotations. In JavaOb, the latter is handled directly during the semantical
interpretation, by requiring expressions to have the form of a cast, hence
requiring that the necessary static type information is available syntactically.

Where the JavaOb type-environment is adjusted only to contain the necessary information for type-checking, the BALI type-environment also contains the complete (formalized) program syntax as it is used for the dynamic
semantics. This difference is due to the different formalization purposes:

144 CHAPTER 7. CONCLUSIONS

where our goal is to enhance a readable semantics, hence as simple and pure
a description as possible, they have for purpose to set-up a technical correct
proof for type-soundness, which moreover adhere strictly to the formalization requirements of ISABELLE/HOL.

Their formalization of a Java language-leve runtime-state, state, is described
in Section 4:4:1. It consists of a four-tuple: an optional (system) exception,
xcpt, the object heap, heap, the current invocation frame, val, and the Java
self-pointer (this), loc. Hence a state-description which, except for xcpt,
describes the machine-level data-structures at the Java virtual machine level,
though used to describe a source-level evaluation.

Notice, that even though they only include instance methods meaning that
the self-pointer is always set to a class instance in the heap, this is not checked
by their formalization. Instead, loc is left unspecified!

In summary, Nipkow and Oheimbs formalization approach serve their purpose: to automatize a type soundness proof for a Java subset based on a
formalization of its dynamic semantics, and with as short a machine proof as
possible. It is a higly impressive, and the most complete work on automated
proofs of Java properties we are aware of at the moment. We consider it as
an important first step towards automatization of proofs of Java properties in
general. However, for that purpose, some inadequacies are either inherently
present in the chosen theorem prover system or should be considered to be
elaborated or changed at the formalization level in future versions. Though
JavaOb is not exactly matching BALI, its formalization has a more clear
approach: the environment structures are deduced from the program to be
interpreted and they are only containing exactly the information needed for
the atual approach (static source-level, dynamic source-level, static machinelevel, or dynamic machine-level). This enhancing the readability and modularity of the semantics which could be exploited to built-up a user-library for
those wishing to prove other properties than type-soundness. Generally, this
reduces to three comments on the work of Nipkow and Oheimb:

ffl The mix of high-level and machine-level views, as well as static and

dynamic semantic features, makes the formalization difficult to read
and reuse for other proof purposes. JavaOb proposes a general way to
separate these views.

ffl The type and evaluation environment structures are not the result of

a contructive deduction process based on the syntax of a BALI program. Hence the confidentiality due to the proof automatization, does
not include the formalization of these. JavaOb offers a formalization
of building these structures (preprocessing semantics).

ffl ISABELLE/HOL's type system is not strong enough for well-foundness

to be automized. Hence textual arguments have to be given outside
the system before the application of induction based automated proofs.

7.2. RELATED WORK 145

Other theorem provers such as Coq, has a type system which is strong
enough to express well-foundedness of a relation.

Formalization work on the Java Virtual Machine Among the formalization works

done at the Java Virtual Machine level, the most significant contribution has
been the static formalization of Java subroutine calls (that is jsr and ret instructions) by Stata and Abadi (1998) using typing rules as static specification approach.

Stata and Abadi define a small instruction-subset (9 instructions), JVML0,
which includes jsr and ret.

This is interesting since they use types for giving a short, non-algorithmic
specification. However, they cannot handle object-oriented features, this being pointed out by themselves. (They are used to generate compact code for
the try-catch-finally source-level statement used for managing exceptions.)

While the use of static semantics is the same, the work is largely orthogonal
to ours since the two instructions are not needed to implement JavaOb, so
rather than comparing we are interested in merging their rules into ours in
future work.

With respect to the formalization of the dynamic semantics of the Java Virtual Machine, Bertelsen (1997) is the first complete formalisation of JVM
execution that we know of, also based on the JVM defininition book. It is
similar to ours in that it uses an abstraction of the class file format. However, it is a small step semantics, giving transition rules for the individual
instructions acting on a global state. We think this makes it harder to use
the formalization in proofs of inductive properties since the proof structure
is not inductive.

Type checking by interpretation of code At the Aachen '92 workshop on functional programming languages, Stefan Kahrs launched the idea that one can
view type checking as abstract interpretation of code. Instead of leaving to
the compiler or interpreter to infer the types of functions and other values by
directly inspecting the source code of a program, he suggests that programs
are first translated into machine code and then a non-standard interpreter is
applied which infers the type of the corresponding values.

The type inference algorithm used by Karhs is very close to bytecode verification, however, the assembly lanugage used is much easier to analyse. In
particular, jumps must obey a simple "if-then-else" structure which means
that it is always possible to infer the type by investigating the instructions
from top to bottom. So with those restrictions our type checker in Chapter 6
would find the type with an empty certificate.

Proof-carrying Code Finally we based our work on PCC of Necula (1997) as discussed at length in the introduction and preliminaries sections. However, as

146 CHAPTER 7. CONCLUSIONS

mentioned earlier, it is not today possible to apply PCC directly to bytecode
because of the lack of a Curry-Howard isomorphism for object-oriented languages.

7.3 Future directions
We list the following points of interest:

ffl Do the formal correctness proof of the JavaOb translator.
ffl To use standard program analysis techniques to strengthen the type system

of Java to include semantic properties. This, because it would allow us to
specify and hence ensure more precise safety requirements.

ffl Two is to bring verification of the checker software up to a high formal security level (ITSEC EAL5 or EAL6 (ITS 1997)) by proving it formally correct.

ffl Adding features of security interest, notably exceptions and private modifiers.

ffl Change card instructions to use the quick version instead, exploiting that on

a Java Card, all that refers to the constant pools is a priori resolved.

ffl Add the check for "dead code" to the bytecode checker.
ffl Show formally, that a method descriptor which is accepted by our bytecode

check specification is a fix-point for the verification.

ffl Show formally, that all JavaOb programs can run on a Java system.
ffl Add a formal specification for dynamic allocation.
ffl Prove that a JavaOb program of a given return type results in a JVMOb

bytecode returning the same type.

ffl Prove that a safe bytecode guaranteed that the bytecode can evaluate.

Appendix A
Appendix

A.1 JDK Example Runs
This appendix shows the full text of the programs used throughout the thesis, along withdisassembled code as appropriate.

All examples were compiled with Sun's JavaDevelopment Kit JDK (Sun 1997c) withthe
javac compiler (with commands such as "javac Toy.java") as printed by the javapdisassembler (with commands like "

javap -c -s -verbose Toy").

Example A.1.1 (Toy from Examples 3.2.4, 4.4.20, and 5.5.1).

1 class Toy extends Object {
2 int toy(int n) {
3 int m;
4 int r;
5 m = 0;
6 while (n > 0) {
7 n = n - 1;
8 r = 1;
9 m = m + r;
10 }
11 return m;
12 }
13 }

Compiled from Toy.java
synchronized class Toy extends java.lang.Object

/* ACC_SUPER bit set */
{

int toy(int);

/* (I)I */
/* Stack=2, Locals=4, Args_size=2 */
Toy();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

147

148 APPENDIX A. APPENDIX
Method int toy(int)

0 iconst_0
1 istore_2
2 goto 15
5 iload_1
6 iconst_1
7 isub
8 istore_1
9 iconst_1
10 istore_3
11 iload_2
12 iload_3
13 iadd
14 istore_2
15 iload_1
16 ifgt 5
19 iload_2
20 ireturn

Method Toy()

0 aload_0
1 invokespecial #3 <Method java.lang.Object.<init>()V>
4 return

}
Example A.1.2 (Tax, from Examples 1.2.1, 3.2.5, 4.4.22). We only show the disassem-bled classes

Tax, Amount, and ReadOnlyAmount.

1 // Tax computation on Java Card.
2
3 // Income class: type of object presented to ETHIC applet
4 class Income extends Object {
5 ReadOnlyAmount total;
6 Amount tax;
7 Amount available;
8 }
9
10 // Tax class: downloadable ETHIC applet
11 class Tax extends Object {
12
13 boolean recalculate (Income inc) {
14 int rest; int tax;
15
16 if (inc == null) return false;
17 else {}
18
19 rest = ((Income)inc).total.get();
20 if (((Income)inc).total.get() - 10000 > 0) {
21 tax = 5000; rest = rest - 5000;

A.1. JDK EXAMPLE RUNS 149

22 }
23 else
24 tax = 0;
25
26 ((Income)inc).tax.set(tax);
27 ((Income)inc).available.set(rest);
28 return true;
29 }
30 }
31
32 // Amount: wrapper class for integer (in 1/100th ECU)
33 class Amount extends Object {
34 int a;
35 int get() { return ((Amount)this).a; }
36 void set(int what) { ((Amount)this).a = what; }
37 }
38
39 // ReadOnlyAmount: protected wrapper class for Amount
40 class ReadOnlyAmount extends Amount {
41 void set(int what) {}
42 }
43
44 // IncomeManager: private ETHIC stuff
45 class Ethic extends Object {
46
47 static Income test(int total) {
48 Income forTax;
49 Tax tax;
50
51 if (total == 0) forTax = null;
52 else {
53 forTax = new Income();
54 ((Income)forTax).total = new ReadOnlyAmount();
55 ((Income)forTax).total.a = total;
56 ((Income)forTax).tax = new Amount();
57 ((Income)forTax).tax.a = 0;
58 ((Income)forTax).available = new Amount();
59 ((Income)forTax).available.a = 0;
60 }
61
62 tax = new Tax();
63
64 if (((Tax)tax).recalculate((Income)forTax))
65 return forTax;
66 else
67 return null;
68 }
69
70 // Java "main" emulating startup(test,i)

150 APPENDIX A. APPENDIX

71 public static void main(String[]args) {
72 int argument = new Integer(args[0]).intValue();
73 System.out.println("ETHIC argument = " + argument);
74 Income result = test(argument);
75 if (result == null)
76 System.out.println("ETHIC returned null");
77 else
78 System.out.println("ETHIC Income after tax recalculation:\n"
79 + " total = " + result.total.get() + "\n"
80 + " tax = " + result.tax.get() + "\n"
81 + " available = " + result.available.get() + "");
82 }
83 }

Compiled from Tax.java
synchronized class Tax extends java.lang.Object

/* ACC_SUPER bit set */
{

boolean recalculate(Income);

/* (LIncome;)Z */
/* Stack=2, Locals=4, Args_size=2 */
Tax();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method boolean recalculate(Income)

0 aload_1
1 ifnonnull 6
4 iconst_0
5 ireturn
6 aload_1
7 getfield #12 <Field Income.total LReadOnlyAmount;>
10 invokevirtual #9 <Method Amount.get()I>
13 istore_2
14 aload_1
15 getfield #12 <Field Income.total LReadOnlyAmount;>
18 invokevirtual #9 <Method Amount.get()I>
21 sipush 10000
24 isub
25 ifle 41
28 sipush 5000
31 istore_3
32 iload_2
33 sipush 5000
36 isub
37 istore_2
38 goto 43
41 iconst_0
42 istore_3

A.1. JDK EXAMPLE RUNS 151

43 aload_1
44 getfield #11 <Field Income.tax LAmount;>
47 iload_3
48 invokevirtual #10 <Method Amount.set(I)V>
51 aload_1
52 getfield #8 <Field Income.available LAmount;>
55 iload_2
56 invokevirtual #10 <Method Amount.set(I)V>
59 iconst_1
60 ireturn

Method Tax()

0 aload_0
1 invokespecial #7 <Method java.lang.Object.<init>()V>
4 return

}
Compiled from Tax.java
synchronized class Amount extends java.lang.Object

/* ACC_SUPER bit set */
{

int a;

/* I */
int get();

/* ()I */
/* Stack=1, Locals=1, Args_size=1 */
void set(int);

/* (I)V */
/* Stack=2, Locals=2, Args_size=2 */
Amount();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method int get()

0 aload_0
1 getfield #8 <Field Amount.a I>
4 ireturn

Method void set(int)

0 aload_0
1 iload_1
2 putfield #8 <Field Amount.a I>
5 return

Method Amount()

0 aload_0
1 invokespecial #7 <Method java.lang.Object.<init>()V>
4 return

152 APPENDIX A. APPENDIX
}
Compiled from Tax.java
synchronized class ReadOnlyAmount extends Amount

/* ACC_SUPER bit set */
{

void set(int);

/* (I)V */
/* Stack=0, Locals=2, Args_size=2 */
ReadOnlyAmount();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method void set(int)

0 return

Method ReadOnlyAmount()

0 aload_0
1 invokespecial #6 <Method Amount.<init>()V>
4 return

}
When run with the argument 20000 it produces
ETHIC argument = 20000
ETHIC Income after tax recalculation:

total = 20000
tax = 5000
available = 15000

Example A.1.3 (UpDownCast, from the discussion of (UpCast) and (DownCast) in Section 3.4).The following program illustrates what castings are and are not permitted by Java.

1 class C extends Object { int f; }
2 class C1 extends C { int f1; }
3 class C2 extends C { int f2; }
4
5 class UpDownCast {
6 public static void main(String[]args) {
7 C2 x2 = new C2();
8 //C1 x1 = (C1)x2; // Static crosscast: Compile error!
9 C x = (C)x2; // Upcast: OK.
10 C1 b = (C1)x; // Downcast: Runtime error!
11 }
12 }

Compiled from UpDownCast.java
synchronized class UpDownCast extends java.lang.Object

/* ACC_SUPER bit set */

A.1. JDK EXAMPLE RUNS 153
{

public static void main(java.lang.String[]);

/* ([Ljava/lang/String;)V */
/* Stack=2, Locals=3, Args_size=1 */
UpDownCast();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method void main(java.lang.String[])

0 new #3 <Class C2>
3 dup
4 invokespecial #6 <Method C2.<init>()V>
7 astore_1
8 aload_1
9 astore_2
10 aload_2
11 checkcast #2 <Class C1>
14 pop
15 return

Method UpDownCast()

0 aload_0
1 invokespecial #7 <Method java.lang.Object.<init>()V>
4 return

}
Running the program yields the error message
java.lang.ClassCastException:

at UpDownCast.main(UpDownCast.java:10)

(and uncommenting the "crosscast" makes the compiler reject the program).
Example A.1.4 (BooleanEval, from description of CONDITIONALS on page 37). Hereis the full text of classes to test the code generated for conditionals in java.

1 class BooleanEval {
2 boolean test(int i) {
3 return i>0;
4 }
5 }
6
7 class BooleanEval2 {
8 boolean test(int i) {
9 if (i>0) return true;
10 else return false;
11 }
12 }

Compiled from BooleanEval.java

154 APPENDIX A. APPENDIX
synchronized class BooleanEval extends java.lang.Object

/* ACC_SUPER bit set */
{

boolean test(int);

/* (I)Z */
/* Stack=1, Locals=2, Args_size=2 */
BooleanEval();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method boolean test(int)

0 iload_1
1 ifgt 6
4 iconst_0
5 ireturn
6 iconst_1
7 ireturn

Method BooleanEval()

0 aload_0
1 invokespecial #4 <Method java.lang.Object.<init>()V>
4 return

}
Compiled from BooleanEval.java
synchronized class BooleanEval2 extends java.lang.Object

/* ACC_SUPER bit set */
{

boolean test(int);

/* (I)Z */
/* Stack=1, Locals=2, Args_size=2 */
BooleanEval2();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method boolean test(int)

0 iload_1
1 ifle 6
4 iconst_1
5 ireturn
6 iconst_0
7 ireturn

Method BooleanEval2()

0 aload_0
1 invokespecial #4 <Method java.lang.Object.<init>()V>
4 return

A.1. JDK EXAMPLE RUNS 155
}
Example A.1.5 (Sharing variables, from Example 4.1.2). Here is the full text of the SharedVarsclasses in JavaOb (one variant with toplevel variables and one with local variables).

1 class SharedVars extends Object { int x; int y;
2 int f;
3 int m(int p) {
4 /*1*/
5 if (p==0) { x = 1; /*2*/ ((SharedVars)this).f = x; }
6 else { y = 2; /*3*/ ((SharedVars)this).f = y; }
7 /*4*/
8 return this.f;
9 }
10 }
11
12 class SharedVars2 extends Object {
13 int f;
14 int m(int p) {
15 /*1*/
16 if (p==0) { int x = 1; /*2*/ ((SharedVars2)this).f = x; }
17 else { int y = 2; /*3*/ ((SharedVars2)this).f = y; }
18 /*4*/
19 return this.f;
20 }
21 }

Compiled from SharedVars.java
synchronized class SharedVars extends java.lang.Object

/* ACC_SUPER bit set */
{

int x;

/* I */
int y;

/* I */
int f;

/* I */
int m(int);

/* (I)I */
/* Stack=2, Locals=2, Args_size=2 */
SharedVars();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method int m(int)

0 iload_1
1 ifne 20
4 aload_0
5 iconst_1
6 putfield #6 <Field SharedVars.x I>

156 APPENDIX A. APPENDIX

9 aload_0
10 aload_0
11 getfield #6 <Field SharedVars.x I>
14 putfield #5 <Field SharedVars.f I>
17 goto 33
20 aload_0
21 iconst_2
22 putfield #7 <Field SharedVars.y I>
25 aload_0
26 aload_0
27 getfield #7 <Field SharedVars.y I>
30 putfield #5 <Field SharedVars.f I>
33 aload_0
34 getfield #5 <Field SharedVars.f I>
37 ireturn

Method SharedVars()

0 aload_0
1 invokespecial #4 <Method java.lang.Object.<init>()V>
4 return

}
Compiled from SharedVars.java
synchronized class SharedVars2 extends java.lang.Object

/* ACC_SUPER bit set */
{

int f;

/* I */
int m(int);

/* (I)I */
/* Stack=2, Locals=3, Args_size=2 */
SharedVars2();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method int m(int)

0 iload_1
1 ifne 14
4 iconst_1
5 istore_2
6 aload_0
7 iload_2
8 putfield #5 <Field SharedVars2.f I>
11 goto 21
14 iconst_2
15 istore_2
16 aload_0
17 iload_2

A.1. JDK EXAMPLE RUNS 157

18 putfield #5 <Field SharedVars2.f I>
21 aload_0
22 getfield #5 <Field SharedVars2.f I>
25 ireturn

Method SharedVars2()

0 aload_0
1 invokespecial #4 <Method java.lang.Object.<init>()V>
4 return

}
Example A.1.6 (Castexp illustrating the role of casts). Here is the full text of the Castexpclass in JavaOb.

1 //$Id: runs.tex,v 1.6 1998/06/26 01:48:55 evarose Exp $
2 class TS{}
3
4 class TD extends TS{}
5
6 class Castexp extends TD{
7
8 void m(TS a1){System.out.println("\t Static argtype binding.");}
9 void m(TD a1){System.out.println("\t Dynamic argtype binding.");}
10
11 public static void main(String[] args){
12 Castexp ob = new Castexp();
13 TS x; //local var.
14 (ob).m( (TS)(x = new TD()) );
15 }
16 }

Compiled from Castexp.java
synchronized class Castexp extends TD

/* ACC_SUPER bit set */
{

void m(TS);

/* (LTS;)V */
/* Stack=2, Locals=2, Args_size=2 */
void m(TD);

/* (LTD;)V */
/* Stack=2, Locals=2, Args_size=2 */
public static void main(java.lang.String[]);

/* ([Ljava/lang/String;)V */
/* Stack=3, Locals=3, Args_size=1 */
Castexp();

/* ()V */
/* Stack=1, Locals=1, Args_size=1 */

Method void m(TS)

158 APPENDIX A. APPENDIX

0 getstatic #11 <Field java.lang.System.out Ljava/io/PrintStream;>
3 ldc #2 <String " Static argtype binding.">
5 invokevirtual #12 <Method java.io.PrintStream.println(Ljava/lang/String;)V>
8 return

Method void m(TD)

0 getstatic #11 <Field java.lang.System.out Ljava/io/PrintStream;>
3 ldc #1 <String " Dynamic argtype binding.">
5 invokevirtual #12 <Method java.io.PrintStream.println(Ljava/lang/String;)V>
8 return

Method void main(java.lang.String[])

0 new #3 <Class Castexp>
3 dup
4 invokespecial #8 <Method Castexp.<init>()V>
7 astore_1
8 aload_1
9 new #4 <Class TD>
12 dup
13 invokespecial #9 <Method TD.<init>()V>
16 dup
17 astore_2
18 invokevirtual #10 <Method Castexp.m(LTS;)V>
21 return

Method Castexp()

0 aload_0
1 invokespecial #9 <Method TD.<init>()V>
4 return

}

Bibliography
Abadi, M. and Cardelli, L.: 1996, A Theory of Objects, Monographs in Computer Science,Springer-Verlag.
Abadi, M. (ed.): 1997, Workshop on security and languages, Digital SRC, WWW:

http://www.research.digital.com/SRC/personal/Martin Abadi/sal/
home.html, Palo Alto, California.

Aho, A. V., Sethi, R. and Ullman, J. D.: 1986, Compilers: Principles, Techniques andTools, Addison-Wesley.

Anderson, R.: 1993, Why cryptosystems fail, First ACM Conference on Computer and

Communications Security, Fairfax, VA, pp. 215-227. A shortened version of thispaper appeared in Communications of the ACM, 11/94.

Anderson, R.: 1996, Liability and computer security: Nine principles, Computer Security- ESORICS 94, number 875 in LNCS, Springer-Verlag, pp. 231-245.
Bertelsen, P.: 1997, Semantics of java byte code, Student report, Technical University ofDenmark.
Chan, P. and Lee, R.: 1997, The Java Class Libraries, An Annotated Reference, The JavaSeries, Addison-Wesley.
Cousot, P. and Cousot, R.: 1977, Abstract interpretation: A unified lattice model for staticanalysis of programs by construction or approximation of fixpoints,

POPL '77--4th
Annual ACM Symposium on Principles of Programming Languages, ACM Press, LosAngeles, California, pp. 238-252.

Drossopoulou, S. and Eisenbach, S.: 1997a, Is the java type system sound?, Proc. 4th Int.Workshop Foundations of Object-Oriented Languages, ACM Press.
Drossopoulou, S. and Eisenbach, S.: 1997b, Java is type safe - probably, European Conference of Object Oriented Programming, Springer-Verlag. Lecture Notes in ComputerScience.

Dybkjaer and Christensen: 1994, Info-society 2000. Report from the Ministry of research,available from

ftp://ftp.denet.dk/pub/info2000.

Frequently Asked Questions - Applet Security: 1997, World-Wide Web page at

java.sun.com.

FSF: 1996, GCC - The GNU C Compiler. Part of the GNU gcc distribution; see

http://www.gnu.org/software/gcc/.

Garfinkel, S. and Spafford, G.: 1996, Practical UNIX & Internet Security, second edn,O'Reilly & Associates, Inc.

159

160 BIBLIOGRAPHY
Garfinkel, S. and Spafford, G.: 1997, Web Security & Commerce, Risks, Technologies, andStrategies, O'Reilly & Associates, Inc.
Gosling, J., Joy, B. and Steele, G.: 1996, The Java Language Specification, The JavaSeries, Addison-Wesley.
Gosling, J. and McGilton, H.: 1995, A white paper, Technical report, Sun.URL: http://www.java.sun.com/doc/language environment/
Gosling, J., Yellin, F. et al.: 1996a, The Java Application Programming Interface, Volume 1: Core Packages, The Java Series, Addison-Wesley.

Gosling, J., Yellin, F. et al.: 1996b, The Java Application Programming Interface Volume 2:Window Toolkit and Applets, The Java Series, Addison-Wesley.

HotJava - The Security Story: n.d., World-Wide Web page at java.sun.com.
ITS: 1997, Information technology security evaluation criteria, WWW:

http://www.itsec.gov.uk/.

Jones, N. and Mycroft, A.: 1985, Dataflow analysis of applicative programs using minimalfunction graphs,

rapport 85/8, DIKU, Datalogisk Institut, Ko/benhavns Universitet.

Kahn, G.: 1987, Natural semantics, Rapport de Recherche 601, INRIA, Sophia-Antipolis,France.

Lemay, L., Perkins, C. L. and Morrison, M.: 1996, Teach Yourself Java in 21 Days, Professional Reference Edition, Sams.net Publishing.

Lindholm, T. and Yellin, F.: 1996, The Java Virtual Machine Specification, The Java Series,Addison-Wesley.

McGraw, G. and Felten, E. W.: 1997, Java Security: Hostile Applets, Holes, and Antidotes,Wiley Computer Publishing.
Milner, R., Tofte, M., Harper, R. and MacQueen, D.: 1997, The Definition of Standard ML,second edn, The MIT Press.
Muchnick, S. S.: 1997, Advanced Compiler Design & Implementation, Morgan Kaufmann.
Naur, P. et al.: 1960, Report on the algorithmic language ALGOL 60, Communications of

the ACM 3, 299-314.

Necula, G. C.: 1997, Proof-carrying code, POPL '97--24th Annual ACMSymposium on Principles of Programming Languages, SIGPLAN Notices.

http://www.cs.cmu.edu/ necula/popl97.ps.gz.
Necula, G. C. and Lee, P.: 1996a, Proof-carrying code, Technical Report CMU-CS-96-165,School of Computer Science, Carnegie-Mellon University, Pittsburgh, PA 15213.

Necula, G. C. and Lee, P.: 1996b, Safe kernel extensions without run-time checking, OSDI'96-Second Symposium on Operating Systems Design and Implementation, Seattle,

Washington.
Necula, G. C. and Lee., P.: 1997, Efficient representation and validation of proofs. Avail-able as

http://www.cs.cmu.edu/~necula/lics98.ps.gz, marked "Submitted toLICS".

BIBLIOGRAPHY 161
Nipkow, T. and von Oheimb, D.: 1998, Javalight is type-safe - definitely, POPL '98--

25th Annual ACM Symposium on Principles of Programming Languages, SIGPLANNotices, pp. 161-170.

Plotkin, G. D.: 1981, A structural approach to operational semantics, Technical ReportFN-19, DAIMI, Aarhus University, Aarhus, Denmark.
Rose, K. H. and Moore, R. R.: 1995, XY-pic, version 3, computer software kit. availablefrom

ftp://ftp.ens-lyon.fr/users/LIP/krisrose/TeX/Xy-pic/.

Schmidt, D. A.: 1986, Denotational Semantics, a Methodology for Language Develop-ment, Allyn and Bacon, Boston.

Stata, R. and Abadi, M.: 1998, A type system for java bytecode subroutines, POPL '98--25th Annual ACM Symposium on Principles of Programming Languages, SIGPLAN

Notices.
Sun: 1997a, Java Card 2.0 Language Subset and Virtual Machine Specification, revision1.0 final edn.

http://java.sun.com/products/javacard/.

Sun: 1997b, Java Card 2.0 Programming Concepts, revision 1.0 final edn.
Sun: 1997c, JDK 1.1 Documentation. Available from http://java.sun.com/

products/jdk/1.1/docs/.

Sun: 1997d, What is a Smart Card? Found on java.sun.com.
Syme, D.: 1997, Proving java typesoundness, Technical Report 427, University of Cam-bridge Computer Laboratory.

Tichy, W. F.: 1985, Design, implementation and evaluation of a revision control system,Software--Practice & Experience 7, 637-654.
Uni: 1996, The Unicode Standard: Worldwide Character Encoding, 1.1.5 edn. Newestversion available from

http://www.unicode.org.

Detailed Table of Contents

Preface 3
Contents 5
1 Introduction 7

1.1 Java Programming and Internet Security . . . . . . . . . . . . . . . . . . 7
1.2 Java Cards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.2.1 Tax Computation (Example) . . . . . . . . . . . . . . . . . . . . 11
1.2.2 Focus on Bytecode Verification (Observation) . . . . . . . . . . . 13
1.3 Bytecode Verification as Type Reconstruction . . . . . . . . . . . . . . . 13
1.4 Proof-Carrying Bytecode . . . . . . . . . . . . . . . . . . . . . . . . . . 15

1.4.1 Bytecode Checking (Observation) . . . . . . . . . . . . . . . . . 15
1.4.2 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.5 Why not Cryptography? . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.6 Why not Source Code? . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.7 Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.8 Overview of the Report . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

2 Preliminaries 20

2.1 The Java Card Language . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.2 Bytecode Verification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.2.1 Bytecode Safety (Definition) . . . . . . . . . . . . . . . . . . . . 23
2.2.2 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.2.3 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.3 Natural Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

2.3.1 Lists and Quantifiers (Notation) . . . . . . . . . . . . . . . . . . 25
2.3.2 Functions (Notation) . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.3 Function Operations (Notation) . . . . . . . . . . . . . . . . . . 26
2.3.4 Syntax (Notation) . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.3.5 Semantic sorts (Notation) . . . . . . . . . . . . . . . . . . . . . 27
2.3.6 Inference rules (Notation) . . . . . . . . . . . . . . . . . . . . . 27
2.4 Proof-Carrying Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.4.1 relation to digital signatures (Remark) . . . . . . . . . . . . . . . 30

3 A Java Card Sublanguage 31

3.1 Design Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

3.1.1 The subset specification-format (Remark) . . . . . . . . . . . . . 31
3.1.2 Principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

162

DETAILED TABLE OF CONTENTS 163

3.1.3 Error handling (Remark) . . . . . . . . . . . . . . . . . . . . . . 33
3.1.4 The JavaOb model (Definition) . . . . . . . . . . . . . . . . . . . 33
3.1.5 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.2 Abstracting the Program Syntax . . . . . . . . . . . . . . . . . . . . . . 33

3.2.1 Syntax (Definition) . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.2.2 Program startup and input/output behavior (Discussion) . . . . . 39
3.2.3 Startup sort (Definition) . . . . . . . . . . . . . . . . . . . . . . 39
3.2.4 JavaOb Toy-program (Example) . . . . . . . . . . . . . . . . . . 40
3.2.5 Tax computation (Example) . . . . . . . . . . . . . . . . . . . . 40
3.2.6 package protection desired (Remark) . . . . . . . . . . . . . . . 42
3.3 Preprocessing Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3.3.1 Static Sorts (Definition) . . . . . . . . . . . . . . . . . . . . . . 42
3.3.2 Global semantic rules (Definition) . . . . . . . . . . . . . . . . . 44

` P ! s; fs; mts; ms . . . . . . . . . . . . . . . . . . . . . . . . 44
` s; fs;mts; ms; C ! s0;fs0; mts0; ms0 . . . . . . . . . . . . . . 45
` fd; F ! fd0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
` mt;md; M ! mt0; md0 . . . . . . . . . . . . . . . . . . . . . 45
3.4 Static Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

3.4.1 Completion sorts (Definition) . . . . . . . . . . . . . . . . . . . 46
3.4.2 Typing context sorts (Definition) . . . . . . . . . . . . . . . . . . 46
3.4.3 Declarations (Definition) . . . . . . . . . . . . . . . . . . . . . . 46

` P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
` P : \Delta  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
\Delta  ` C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
\Delta ; CID ` F . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
\Delta ; CID ` M . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
` ld; D ! ld0 . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.4.4 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.4.5 Statements (Definition) . . . . . . . . . . . . . . . . . . . . . . . 48

\Delta ; \Gamma  ` S : ct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.4.6 Statement sequences (Definition) . . . . . . . . . . . . . . . . . 49

\Delta ; \Gamma  ` S\Lambda  : ct . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
\Delta ; \Gamma  ` S+ : ct . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.4.7 Conditions (Definition) . . . . . . . . . . . . . . . . . . . . . . . 49

\Delta ; \Gamma  ` CO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.4.8 Statement Expressions (Definition) . . . . . . . . . . . . . . . . 50

\Delta ; \Gamma  ` SE : R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3.4.9 Expressions (Definition) . . . . . . . . . . . . . . . . . . . . . . 51

\Delta ; \Gamma  ` E : T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.4.10 Cast Expressions (Definition) . . . . . . . . . . . . . . . . . . . 51

\Delta ; \Gamma  ` CE : T . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.4.11 Primitive Values (Definition) . . . . . . . . . . . . . . . . . . . . 52

\Delta ; \Gamma  ` PV : T . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.4.12 Subtyping (Definition) . . . . . . . . . . . . . . . . . . . . . . . 52

s ` CID ^: CID . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
c ` CID !: CID . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.5 Dynamic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

3.5.1 Runtime type checking (Remark) . . . . . . . . . . . . . . . . . 53
3.5.2 Semantic Sorts (Definition) . . . . . . . . . . . . . . . . . . . . 53

164 DETAILED TABLE OF CONTENTS

3.5.3 Look-up operations (Definition) . . . . . . . . . . . . . . . . . . 55

ae ` lookup(ID) ! v . . . . . . . . . . . . . . . . . . . . . . . . . 55
s; fbs ` flookup(CID; ID) ! v . . . . . . . . . . . . . . . . . . . 55
s; ms ` mlookup(CID;(ID; T\Lambda ;)) ! (ID\Lambda ;; B); CID . . . . . . . . . 55
3.5.4 Update operations (Definition) . . . . . . . . . . . . . . . . . . . 56

` update(ae; ID; v) ! ae . . . . . . . . . . . . . . . . . . . . . . . 56
s ` fupdate(fbs; CID; ID;v) ! fbs . . . . . . . . . . . . . . . . . 56
3.5.5 Initialization operations (Definition) . . . . . . . . . . . . . . . . 58

s; fs ` newinit(CID) ! fbs . . . . . . . . . . . . . . . . . . . . . 58
3.5.6 Evaluation context (Definition) . . . . . . . . . . . . . . . . . . . 58
3.5.7 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.5.8 Programs (Definition) . . . . . . . . . . . . . . . . . . . . . . . 59

` P; ST ) v;oe . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.5.9 Well-formed JavaOb programs (Remark) . . . . . . . . . . . . . 60
3.5.10 Statements (Definition) . . . . . . . . . . . . . . . . . . . . . . . 60

\Omega ; \Upsilon  ` S;ae; oe ) cs; ae;oe . . . . . . . . . . . . . . . . . . . . . . 60
3.5.11 Compositionality (Remark) . . . . . . . . . . . . . . . . . . . . 61
3.5.12 Statement sequence (Definition) . . . . . . . . . . . . . . . . . . 61

\Omega ; \Upsilon  ` S\Lambda ;ae; oe ) cs; ae;oe . . . . . . . . . . . . . . . . . . . . . . 61
3.5.13 Conditional Expression (Definition) . . . . . . . . . . . . . . . . 62

\Omega ; \Upsilon  ` CO;ae; oe ) v;ae0; oe0 . . . . . . . . . . . . . . . . . . . . . 62
3.5.14 Statement Expressions (Definition) . . . . . . . . . . . . . . . . 62

\Omega ; \Upsilon  ` SE;ae; oe ) rv;ae0;oe0 . . . . . . . . . . . . . . . . . . . . . 63
3.5.15 Observation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.5.16 Expressions (Definition) . . . . . . . . . . . . . . . . . . . . . . 65

\Omega ; \Upsilon  ` E;ae;oe ) v;ae0; oe0 . . . . . . . . . . . . . . . . . . . . . . 65
3.5.17 Cast Expression (Definition) . . . . . . . . . . . . . . . . . . . . 66

\Omega ; \Upsilon  ` CE; ae;oe ) v; ae0;oe0 . . . . . . . . . . . . . . . . . . . . . 66
3.5.18 Primitive Values (Definition) . . . . . . . . . . . . . . . . . . . . 66

\Omega ; \Upsilon  ` PV; ae;oe ) pv; ae;oe . . . . . . . . . . . . . . . . . . . . . 67

4 A Java Virtual Machine for the Sublanguage 68

4.1 Bytecode Safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

4.1.1 Ill-formed bytecode handling (Remark) . . . . . . . . . . . . . . 69
4.1.2 Frame types (Example) . . . . . . . . . . . . . . . . . . . . . . . 69
4.1.3 Machine type sorts (Definition) . . . . . . . . . . . . . . . . . . 71
4.1.4 Frame state type sorts (Definition) . . . . . . . . . . . . . . . . . 71
4.1.5 Frame type order (Definition) . . . . . . . . . . . . . . . . . . . 73
4.1.6 Uniqueness of greatest lower bound (Proposition) . . . . . . . . . 73
4.1.7 Bytecode safety is Type Inference (Principle) . . . . . . . . . . . 73
4.1.8 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.1.9 Dependent frame types (Example) . . . . . . . . . . . . . . . . . 74
4.1.10 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.1.11 Initial frame-state type (Definition) . . . . . . . . . . . . . . . . 75
4.2 Abstracting the Class File Format . . . . . . . . . . . . . . . . . . . . . 75

4.2.1 JVMOb instruction-syntax (Definition) . . . . . . . . . . . . . . 75
4.2.2 Limitations of JVMOb (Discussion) . . . . . . . . . . . . . . . . 77
4.2.3 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.2.4 Bytecode sorts (Definition) . . . . . . . . . . . . . . . . . . . . . 78

DETAILED TABLE OF CONTENTS 165

4.2.5 Program point sorts (Definition) . . . . . . . . . . . . . . . . . . 78
4.2.6 Program point operations (Definition) . . . . . . . . . . . . . . . 78

` CtoPP(C) ! PP . . . . . . . . . . . . . . . . . . . . . . . . . 79
` CtoPP h(I\Lambda ) ! PP;n . . . . . . . . . . . . . . . . . . . . . . . 79
4.2.7 Abstracting the class file format (Discussion) . . . . . . . . . . . 79
4.2.8 Constant pool sorts (Definition) . . . . . . . . . . . . . . . . . . 79
4.2.9 Class file format sorts (Definition) . . . . . . . . . . . . . . . . . 81
4.2.10 Relation to JVM class files (Discussion) . . . . . . . . . . . . . . 81
4.3 Resolution Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.3.1 Dynamic loading (Remark) . . . . . . . . . . . . . . . . . . . . . 83
4.3.2 Method area sorts (Definition) . . . . . . . . . . . . . . . . . . . 84
4.3.3 Field offset order (Principle) . . . . . . . . . . . . . . . . . . . . 85
4.3.4 Resolution rules (Definition) . . . . . . . . . . . . . . . . . . . . 85

CFs ` MA + CID  MA0 . . . . . . . . . . . . . . . . . . . . . 85
CFs ` MA + off  MA + off . . . . . . . . . . . . . . . . . . 85
CFs ` MA + FREF  MA + off . . . . . . . . . . . . . . . . . 85
4.3.5 Method resolving (Remark) . . . . . . . . . . . . . . . . . . . . 86
4.4 Static Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

4.4.1 Formalization strategy and welltypedness (Discussion) . . . . . . 87
4.4.2 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.4.3 Descriptor type sorts (Definition) . . . . . . . . . . . . . . . . . 88
4.4.4 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.4.5 Typing context sorts (Definition) . . . . . . . . . . . . . . . . . . 88

CFs ` s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.4.6 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.4.7 Bytecode class-check rules (Definition) . . . . . . . . . . . . . . 89

` CFs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
s ` CF : bcv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.4.8 Bytecode method check rules (Definition) . . . . . . . . . . . . . 90

s ` CP; ACID; Ms; MSIG : bcv . . . . . . . . . . . . . . . . . . . 90
4.4.9 Totality of md (Proposition) . . . . . . . . . . . . . . . . . . . . 91
4.4.10 Instruction sequence check rules (Definition) . . . . . . . . . . . 91

\Xi  ` PP;pp; C : md ! PP . . . . . . . . . . . . . . . . . . . . . . 91
4.4.11 Single instruction check rules (Definition) . . . . . . . . . . . . . 92
4.4.12 Single "No-index" check rules (Definition) . . . . . . . . . . . . 92

\Xi  ` pp; I : md ! pp0 . . . . . . . . . . . . . . . . . . . . . . . . 92
4.4.13 Single "Local-index" check rules (Definition) . . . . . . . . . . . 93
4.4.14 Single "CP-indexed" check rules (Definition) . . . . . . . . . . . 93
4.4.15 Single "Code-indexed" check rules (Definition) . . . . . . . . . . 95
4.4.16 Least frame type (Remark) . . . . . . . . . . . . . . . . . . . . . 95
4.4.17 Return check rules (Definition) . . . . . . . . . . . . . . . . . . . 96
4.4.18 Bytecode verification rules (Definition) . . . . . . . . . . . . . . 96

CFs ` CID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.4.19 Enumeration of frame types (Observation) . . . . . . . . . . . . . 97
4.4.20 Verifying the Toy (Example) . . . . . . . . . . . . . . . . . . . . 97
4.4.21 Verification fails with bad Toy (Example) . . . . . . . . . . . . . 98
4.4.22 Verifying the Tax (Example) . . . . . . . . . . . . . . . . . . . . 98
4.5 Dynamic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

4.5.1 Dynamic loading (Discussion) . . . . . . . . . . . . . . . . . . . 99

166 DETAILED TABLE OF CONTENTS

4.5.2 Runtime state sorts (Definition) . . . . . . . . . . . . . . . . . . 1004.5.3 Initial frame-state (Remark) . . . . . . . . . . . . . . . . . . . . 102
4.5.4 JVMOb startup rules (Definition) . . . . . . . . . . . . . . . . . 102

` CFs; ST ) w; H . . . . . . . . . . . . . . . . . . . . . . . . . 1024.5.5 JVMOb instruction sequence execution rules (Definition) . . . . . 103

` CFse ` RS ) w; H . . . . . . . . . . . . . . . . . . . . . . . . 1034.5.6 Instruction execution rules (Definition) . . . . . . . . . . . . . . 103
4.5.7 Local instruction execution rules (Definition) . . . . . . . . . . . 103

CFs ` RS1 ! RS2 . . . . . . . . . . . . . . . . . . . . . . . . . 1034.5.8 Return instruction execution rules (Definition) . . . . . . . . . . 105

4.5.9 Checkcast rule (Definition) . . . . . . . . . . . . . . . . . . . . . 1054.5.10 Field instruction rules (Definition) . . . . . . . . . . . . . . . . . 106
4.5.11 Instance creation instruction rules (Definition) . . . . . . . . . . . 106

` MA; CID ! fvs . . . . . . . . . . . . . . . . . . . . . . . . . 1064.5.12 Virtual method invocation instruction (Definition) . . . . . . . . . 108

MA ` CID; MSIG ! CID; MSIG . . . . . . . . . . . . . . . . . . 1084.5.13 Super-method invocation instruction (Definition) . . . . . . . . . 109

5 Compiling the Sublanguage 1115.1 Abstract compilation strategy . . . . . . . . . . . . . . . . . . . . . . . . 111

5.1.1 Cross-class field and method invocation referencing (Observation) 1125.1.2 Observation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.1.3 Pre-class file sort (Definition) . . . . . . . . . . . . . . . . . . . 1135.1.4 Compilation strategy (Definition) . . . . . . . . . . . . . . . . . 113
5.2 Block compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1155.3 Statement compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.4 Statement Expressions compilation . . . . . . . . . . . . . . . . . . . . . 1175.5 Expression compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

5.5.1 Toy translation (Example) . . . . . . . . . . . . . . . . . . . . . 1225.5.2 Compiling

Tax (Example) . . . . . . . . . . . . . . . . . . . . . 1225.6 Putting It All Together . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

` SR(P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
6 Secure Bytecode Verification on a Java Card 1266.1 Verification and Proof Carrying Code . . . . . . . . . . . . . . . . . . . 126

6.1.1 Downloading applets on card (Discussion) . . . . . . . . . . . . 1266.1.2 Approach (Remark) . . . . . . . . . . . . . . . . . . . . . . . . 127
6.1.3 Borrowing from "Proof Carrying Code" (Discussion) . . . . . . . 1286.1.4 Space-critical consumption (Discussion) . . . . . . . . . . . . . . 128
6.2 A Secure, Optimized Certificate . . . . . . . . . . . . . . . . . . . . . . 1306.2.1 Concrete JVMOb representation (Remark) . . . . . . . . . . . . 130

6.2.2 Goals (Principle) . . . . . . . . . . . . . . . . . . . . . . . . . . 1306.2.3 Bytecode instruction behaviour (Discussion) . . . . . . . . . . . 130
6.2.4 Delimiter instructions (Definition) . . . . . . . . . . . . . . . . . 1316.2.5 JVMOb basic block (Definition) . . . . . . . . . . . . . . . . . . 131
6.2.6 Remark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1326.2.7 Internal basic-block type-check (Remark) . . . . . . . . . . . . . 132
6.2.8 Dead code (Remark) . . . . . . . . . . . . . . . . . . . . . . . . 1326.2.9 JVMOb bytecode connectivity (Proposition) . . . . . . . . . . . 132
6.2.10 Principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

DETAILED TABLE OF CONTENTS 167

6.2.11 Basic-block type-check order (Observation) . . . . . . . . . . . . 1326.2.12 Block ordering (Remark) . . . . . . . . . . . . . . . . . . . . . . 132
6.2.13 Jump analysis (Discussion) . . . . . . . . . . . . . . . . . . . . . 1336.2.14 Bytecode certificate sorts (Definition) . . . . . . . . . . . . . . . 134
6.2.15 Toy certificate (Example) . . . . . . . . . . . . . . . . . . . . . . 1356.2.16 Certificate for

Tax (Example) . . . . . . . . . . . . . . . . . . . 1356.2.17 Safety analysis (Discussion) . . . . . . . . . . . . . . . . . . . . 135

6.3 A Checker Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1356.3.1 auxiliary sorts (Definition) . . . . . . . . . . . . . . . . . . . . . 135

6.3.2 auxiliary procedures (Definition) . . . . . . . . . . . . . . . . . . 1356.3.3 lightweight bytecode checker (Definition) . . . . . . . . . . . . . 136
6.3.4 Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1376.3.5 complexity (Discussion) . . . . . . . . . . . . . . . . . . . . . . 138
6.3.6 tax computation (Example) . . . . . . . . . . . . . . . . . . . . . 138
7 Conclusions 1407.1 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

7.2 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1417.3 Future directions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

A Appendix 147A.1 JDK Example Runs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

A.1.1 Toy from Examples 3.2.4, 4.4.20, and 5.5.1 (Example) . . . . . . 147A.1.2

Tax, from Examples 1.2.1, 3.2.5, 4.4.22 (Example) . . . . . . . . 148A.1.3
UpDownCast, from the discussion of (UpCast) and (DownCast) inSection 3.4 (Example) . . . . . . . . . . . . . . . . . . . . . . . 152

A.1.4 BooleanEval, from description of CONDITIONALS on page 37(Example) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
A.1.5 Sharing variables, from Example 4.1.2 (Example) . . . . . . . . . 155A.1.6

Castexp illustrating the role of casts (Example) . . . . . . . . . . 157

Bibliography 159
Detailed Table of Contents 162
List of Figures 168
List of Tables 168
Index 169

List of Figures

3.1 JavaOb Expression Syntax Hierarchy. . . . . . . . . . . . . . . . . . . . 38
4.1 Local variable table lattice structure. . . . . . . . . . . . . . . . . . . . . 724.2 JVMOb runtime state picture. . . . . . . . . . . . . . . . . . . . . . . . . 101

4.3 Initial method invocation frame. . . . . . . . . . . . . . . . . . . . . . . 1024.4 JVMOb Local Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . 104

List of Tables

2.1 The class-file verification phases. . . . . . . . . . . . . . . . . . . . . . . 232.2 Proof-Carrying Code stages. . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 JVMOb Instruction Codes. . . . . . . . . . . . . . . . . . . . . . . . . . 76

168

Index
<init>, 83(

Object Class Resolution), 85(
Object Field Initialization), 106

8, 25, 27(Abrupt Statement Sequence), 61
abstract, 32
abstract, 36abstract classes, 32

abstract interfaces, 32abstract machine, 99
Abstract Window Toolkit, 9A

CCESS, 34, 38, 79access, 32

access flags, 82
aconst null, 76, 92, 104A

CTUAL, 81, 82(Addition), 51, 65

ADDITIVEEXPRESSION, 34, 39
aload, 76, 93, 104API, 8, 20

applets, 9, 10, 31Application Programmer Interface, 8
areturn, 76, 96, 105A

RGDECLARATION, 34
ArgTypeList, 42, 43arrays, 32

astore, 76, 93, 104
attribute[], 83

Basic-block type-check order, 132
BCV, 88BCVs, 88

binary executable file format, 21B

LOCK, 34, 37(Block), 48, 61

Block ordering, 132BNF, 26
BooleanEval, 153B

OOLEANLITERAL, 34(BooleanLiteral), 52, 67

booleans, 71bootstrap method, 34
?, 25, 27, 69, 71(Branch Instructions), 95
bytecode certificate, 134Bytecode Checker, 87
bytecode checker, 15Bytecode Checker algorithm, 130
bytecode connectivity, 132bytecode safety, 68
bytecode verification, 22, 68, 96bytecode verifier, 9, 96
bytecode verify, 108bytes, 77

CAD, 10, 127Card Accepting Device, 10
cast, 83(Cast Instruction), 105
Castexp, 157C

ASTEXPRESSION, 34C
ASTPRIMVALUE, 39catch, 145

Certificate, 130
checkcast, 76, 79, 94
CheckedSet, 135CheckList, 135

CLASS, 33, 34(Class), 45, 47
class, 8(Class Check), 90
(Class Collection Check), 89(Class Fields Initialization), 107
class file format, 8, 21class file verification, 22
class instances, 33(Class Load), 85
class loader, 99(Class Reresolution), 85
class resolution, 85class type descriptor, 88

169

170 INDEX
(Class Verification), 96
class-loading, 85
classes, 33
ClassFile, 81
ClassFile, 81
ClassFiles, 81

CLASSID, 33, 35
CLASSPATH, 84
ClassStructure, 84

CODE, 78
(Code Program Points), 79
CodeAttr, 81
compilation, 114
compiling

addition, 121
assignment, 118
block, 115
class, 113, 114
conditional, 117
expression, 117
expressions, 120
fields, 120
literals, 121
method, 114
method invocation, 118
statement, 116
statement expression, 117
subtraction, 121
variables, 120
CompletionType, 46
concatenation, 26
concrete syntax, 32

CONDITIONALS, 34, 37
constant pool, 79, 84

internal, 77
resolution, 83
constant pool size, 77
CONSTANT Class, 80
CONSTANT Fieldref, 80
CONSTANT Integer, 80
CONSTANT NameAndType, 80
constant pool[], 81
constant pool count, 77
CONSTANT Utf8, 80
CONSTANT Utf8 info, 82

CONSTPOOL, 79
(Continued Execution), 103
conversion, 83
cryptography, 17

CtoPP, 78, 91
Dead code, 132D

ECLARATION, 33Delimiter instructions, 131

\Delta , 46
Delta, 134dependent type system, 74

digital signature, 17disjoint sums, 27
Dom( ), 25domain, 25
\Delta , 26
double float, 77down-casts, 53

(Downcast), 52
dup, 76, 92, 104dynamic dispatch, 33

dynamic loading, 83dynamic semantics, 99

9, 25, 27empty partial function, 25
(Empty Sequence), 79, 91(Empty Statement Sequence), 49, 61
empty string, 26encrypted, 17
enumerate, 25error handling, 33

ETHIC, 11, 41EU, 11
exceptions, 32existentially quantified, 27

EXPRESSION, 34, 37(Expression Statement), 48, 60
(Expression Test), 50
extends, 35

(False Null Test), 62(False Plus Test), 62
(False Zero Test), 62F

IELD, 33, 35(Field), 45, 47

(Field Access), 51, 65(Field Assign), 63
(Field Assignment), 50(Field Initialization Base), 58
(Field Initialization Iteration), 58(Field Instruction), 106
(Field Lookup Found), 55

INDEX 171
(Field Lookup Nest), 55field numbering, 85
field offsetorder, 85
field offset assignment, 86(Field Reresolution), 85
(Field Resolution), 85(Field Update Found), 56
(Field Update Nest), 57
field info, 82
FieldDecl, 43, 44FieldOffsetTypes, 84

FIELDREF, 79
fieldref, 79, 80
Fields, 43, 44, 81fields, 33

fields, 82
fields[], 82
FieldValues, 100
final, 35, 36finally, 145

finite map, 25
flookup, 56formalization, 18

FormalParList, 43forward jumps, 138
Frame, 100frame type

order, 73
FrameType, 71, 73
FTDelta, 134function, 25

fupdate, 57
\Gamma , 46
getfield, 76, 79, 94, 106
getfield quick, 86
goto, 76, 104(Goto Instruction), 95

greatest lower bound, 73guess, 89

(Halted Execution), 103
Handle, 100
Heap, 100heap, 33

HOL, 142HotJava, 9, 17

iadd, 76, 104

iconst 0, 76, 92, 104
iconst 1, 76, 92, 104identifiers, 26

(If False), 60(If True), 60
ifeq, 76, 95, 104
ifgt, 76, 95, 104
ifnull, 76, 95, 104ill-formed bytecode, 69

iload, 76, 93, 104inference rules, 27
inheritance, 32, 33Initial frame-state type, 75
Initial frame-state, 102injection, 27
(Instance Creation), 50, 63(Instance Creation Instruction), 106
instance methods, 33instance variables, 33

INSTOF, 100instruction behaviour, 130
Integer, 100(IntegerLiteral), 52, 67
integers, 71
interfaces[], 82Internal basic-block type-check, 132

Internet, 7Internet Explorer, 8
invokespecial, 76, 79, 80, 94
invokevirtual, 76, 79, 80, 94
ireturn, 76, 96, 105Isabelle/HOL, 142

istore, 76, 93, 104
isub, 76, 104I

TEM, 79items, 79, 84

jar, 17Java, 8
Java Archive, 17Java Card, 20
Java Card Specification, 31Java Cards, 10
Java Virtual Machine, 8, 9
java.lang, 34
javac, 147JavaDevelopment Kit, 147

JavaOb, 31design, 31

principles, 32

172 INDEX

syntax, 33JavaOb abstract syntax, 33
JavaOb modelJavaOb object model, 33

JavaOb store model, 33JavaOb Toy-program, 40
javap, 147
JavaStack, 100JCVM, 77

JDK, 147judgment, 27
Jump, 84JVM, 83
JVM frame-state type, 71JVMOb

instruction set, 75, 92, 96limitations, 75
JVMOb representation, 130
Label, 134
ldc w, 76, 79, 94, 104less defined, 73

lifting, 27lists, 25

LITERAL, 34loading, 102
(Local Access), 51, 65(Local Access Instructions), 93
(Local Assign), 63(Local Assignment), 50
(Local Instruction), 103(Local Lookup Found), 55
(Local Lookup Nest), 55(Local Update Found), 56
(Local Update Nest), 56local variable table, 72
local variables, 93(Local Vars), 47
Localvars, 100
long integer, 77
lookup, 56
LvType, 71

machine types, 71
magic, 81
main, 36
main(), 39
major version, 81mapping, 25

mask, 10

MaxLVar, 81
MaxStack, 81(Maybe-returning If), 48

(Maybe-returning Statement Sequence), 49(Maybe-returning While), 48
MCertificate, 134
MDescr, 88meaningful range, 75

merges, 14M

ETHOD, 33, 36(Method), 45, 47

method area, 84(Method Check), 90
method code size, 77method descriptor, 88
(Method Invocation), 50(Method Invocation Instruction), 108
(Method Lookup Found), 55, 108(Method Lookup Nest), 55, 108
method signature, 81
method info, 82
MethodArea, 84
MethodBody, 43MethodContents, 43

MethodDecl, 42M

ETHODINVOCATION, 34, 38, 80MethodName, 42

METHODREF, 79, 80Methods, 42, 43, 81
methods[], 82M

ETHODSIG, 79, 80MethodSig, 42, 43

MethodTypes, 43
MethodTyping, 43
methref, 79, 80
minor version, 81
mlookup, 56MT

YPE, 71

name, 82natural numbers, 26

natural semantics, 27negative occurrence, 28
(Nesting), 51, 65Netscape, 8
new, 76, 94
new, 37, 83
newinit, 58(Non-returning If), 48

(Non-returning Statement Sequence), 49

INDEX 173
(Non-returning While), 48nonterminal, 26
(Normal Statement Sequence), 61N

ULL, 100(Null), 51

(Null Test), 50(Nullcast), 66
(NullLiteral), 65

OBINSTR, 78
Object, 100
Object, 34, 35, 82(Object Instructions), 94

object model, 33object-oriented, 8
objects, 33
Offset, 84
\Omega , 59operational, 31

oracle, 89
packages, 32, 42partial function, 25
pattern matching, 27PC, 100
PCC, 15, 128pick an element from a list, 25
(Plus Test), 50point-wise ordering, 73
pop, 76, 92, 104positive occurrence, 28
PPoints, 78
PPointSets, 78
PPpoint, 135pre-compilation, 113

PreClassFile, 113
PreClassFiles, 113
PreMethodTable, 113(Primitive Cast), 52, 66

primitive types, 71primitive value size, 77

PRIMTYPE, 34, 37P

RIMVALUE, 34
private, 35P

ROGRAM, 33, 34(Program), 44, 47

(Program Invocation), 59, 102program safety, 13
Program startup and input/output behav-ior, 39

(Program Type), 47proof, 27
Proof Carrying Code, 128proof checker, 15
Proof-Carrying Code, 15(Proper Sequence), 79, 91
protected, 35, 36protection, 32
public, 35, 36
putfield, 76, 79, 94, 106
putfield quick, 86

quantifying, 25
Reference, 100reference types, 71
(Reflexivity), 52resolution, 83, 85
resolved, 84, 108restriction, 26
return, 76, 96, 105return frame, 109
(Return Instruction), 105(Return Instructions), 96
(Returning If), 48(Returning Statement Sequence), 49

RETURNTYPE, 34RMT

YPE, 71run-time checks, 9

RunConstPool, 84RunItem, 84
RunState, 100runtime, 99
runtime state, 99
safety, 68safety policy, 13
sand-box, 9search, 27
security, 8security manager, 9
security model, 8
SecurityManager, 9(Self), 51, 65

semantic sorts, 27sequence, 25
sequential, 31side condition, 27
signed applets, 17signing, 17

174 INDEX
(Simple), 53(Simple Constant Pool Instructions), 93
(Simple Instruction), 92single pass, 134
size limitations, 75size of a map, 25
Smart Cards, 10, 20sort constructions, 27
SourceFile, 83space consumption, 138
spanning tree, 132
Stack, 100StackType, 71

STARTUP, 39startup, 39
startup, 39, 84, 102S

TATEMENT, 34, 37S
TATEXPRESSION, 34, 37
static, 35, 36static lookup, 33

static semantics, 99
StatMethInfo, 88
STDelta, 134store model, 33

string, 80(Strong), 52
subject reduction, 125(Subtraction), 51, 65
subtyping, 32S

UPER, 81, 82(Super Method Invocation), 63

(Super-method Invocation), 50(Super-method Invocation Instruction), 109
super class, 82SuperClass, 42, 43, 88
(Superclass Hierarchy), 89syntax, 26

tags, 27tamper-proof, 135
Tax, 122, 135, 148tax-applet correctness, 12
tax-applet safety, 12terminals, 26
The Java Language Specification, 31theorem prover, 15
this, 36
this class, 82threads, 32

topologically sorted, 132

Toy, 40, 122, 147(Transitivity), 53
tree, 27(True Null Test), 62
(True Plus Test), 62(True Zero Test), 62
try, 145tuples, 25, 27

TYPE, 34, 36type

order, 73type checking, 87
type conversions, 32type inference, 73
type of an object never changes, 66type reconstruction, 14, 73
type soundness, 124
typeof, 74Typing context, 88

unicity of types, 73universally quantified, 27
(Upcast), 52update, 26
update, 57
UpDownCast, 152
\Upsilon , 59user's view, 124

Utf8, 80
V, 71(Value Return), 48, 60

VARDECLARATION, 34(Virtual Method Invocation), 63
void, 71(Void Return), 48, 60
volatile, 35
(Weakening Non-returning), 48(Weakening Returning), 48
(While False), 60(While True), 60
wide, 77
Word, 100World-Wide Web, 7

WWW, 7
(Zero Test), 49