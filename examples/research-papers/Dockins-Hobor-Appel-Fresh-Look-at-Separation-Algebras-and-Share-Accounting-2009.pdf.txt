

A Fresh Look at
Separation Algebras and Share Accounting?

Robert Dockins1, Aquinas Hobor2, and Andrew W. Appel1

1 Princeton University
2 National University of Singapore

Abstract. Separation Algebras serve as models of Separation Logics;
Share Accounting allows reasoning about concurrent-read/exclusive-write
resources in Separation Logic. In designing a Concurrent Separation
Logic and in mechanizing proofs of its soundness, we found previous
axiomatizations of separation algebras and previous systems of share accounting to be useful but imperfect. We adjust the axioms of separation
algebras; we demonstrate an operator calculus for constructing new separation algebras; we present a more powerful system of share accounting
with a new, simple model; and we provide a reusable Coq development.

1 Introduction
Separation logic is an elegant solution to the pointer aliasing problem of Hoarelogic. We have been using separation logic to examine the metatheory of C minor
enhanced with primitives for shared-memory concurrency [6, 5]. Along the way,we developed a generic library of constructions and proof techniques for separation logic. Here we explain two related parts of our toolkit: separation algebrasand share models.

Contribution 0: Our proofs are machine checked in Coq.3Calcagno, O'Hearn and Yang [4] present a semantics of separation logic based

on structures they call "separation algebras." Although Calcagno's definition isadequate for their purposes, we found it too limiting in some ways and too permissive in others. Contribution 1: We make several alterations to the definitionof separation algebras to produce a class of objects that have more pleasing mathematical properties and that are better suited to the task of generating usefulseparation logics.

Different separation logics often require different separation algebra models,but verifying that a complex object is a separation algebra can be both tedious
and surprisingly difficult. Contribution 2: We demonstrate an operator calcu-lus for rapidly constructing a wide variety of new separation algebras.

We also revisit share accounting, which is used to reason about read-sharingconcurrent protocols. Share accounting allows a process to "own" some share of

? Supported in part by National Science Foundation grant CNS-0627650 and a Lee

Kuan Yew Postdoctoral Fellowship.
3 The Coq development corresponding to this paper is part of the Mechanized Semantic Library, available at http://msl.cs.princeton.edu/.

a memory location: the full share gives read/write/deallocate permissions, whilea partial share gives only the read permission.

Contribution 3: We present anew share model that is superior to those by Bornat et al. [1] and Parkinson [8].

2 Separation Algebras
Calcagno, O'Hearn, and Yang [4] introduced the notion of a separation algebra,which they defined as "a cancellative, partial commutive monoid." That is, a
separation algebra (SA) is a tuple hA, \Phi , ui where A is a set, \Phi  is a partialbinary operation on

A and u is an element of A satisfying the following axioms:

x \Phi  y = y \Phi  x (1)
x \Phi  (y \Phi  z) = (x \Phi  y) \Phi  z (2)
u \Phi  x = x (3)
x1 \Phi  y = x2 \Phi  y ! x1 = x2 (4)

The primary interest of a separation algebra is that it can be used to build aseparation logic [11]. However, for most of this paper, we are going to consider

separation algebras as first-class objects and investigate their properties.We wish to construct our models in Coq. Dealing with partial functions in
Coq can be tricky, since the function space of Coq's metatheory contains onlycomputable total functions.

4 We would like to be able to construct models whose

combining operation is not computable. Therefore, we adopt a convention fromphilosophical logic, where it is common to give the semantics of substructural

connectives in terms of 3-place relations rather than binary functions [10].We recast the separation algebra ideas of Calcagno et al. in this relational
setting by considering the join relation J(x, y, z), usually written suggestivelyas

x \Phi  y = z. The partiality of the \Phi  operation follows from the fact that for agiven

x and y we are not guaranteed that there is some z such that x \Phi  y = z.Reinterpreted in this setting, we say that h

A, Ji, (where A is a carrier set and
J is a three-place relation on A) is a separation algebra provided that:

x \Phi  y = z1 ! x \Phi  y = z2 ! z1 = z2 (5)
x1 \Phi  y = z ! x2 \Phi  y = z ! x1 = x2 (6)
x \Phi  y = z ! y \Phi  x = z (7)
x \Phi  y = a ! a \Phi  z = b ! 9c. y \Phi  z = c ^ x \Phi  c = b (8)9

u. 8x. u \Phi  x = x (9)

That is, \Phi  is a functional relation (5), it is cancellative (6), commutative (7),associative (8), and has a unit

u (9).We are justified in calling this object "the" unit because the cancellation

axiom guarantees that it must be unique. In addition, the unit is exactly theunique element

u satisfying u \Phi  u = u, again by the cancellation axiom.

4 Uncomputable functions can be built if one assumes the axiom of description.

2

3 The algebra of separation algebras
A new separation algebra can be built by applying operators to preexisting SAs.
Definition 1 (SA product operator). Let hA, JAi and hB, JBi be SAs. Thenthe product SA is h

A * B, Ji, where J is defined componentwise:

J((xa, xb), (ya, yb), (za, zb)) j JA(xa, ya, za) ^ JB(xb, yb, zb) (10)
Definition 2 (SA function operator). Let A be a set and let hB, JBi be aSA. Then the function SA is h

A ! B, Ji, where J is defined pointwise:

J(f, g, h) j 8a 2 A. JB(f (a), g(a), h(a)) (11)
The SA product and the SA function operators are isomorphic to specialcases of the general indexed product (i.e., dependent function space) operator.

Definition 3 (SA indexed product operator). Let I be a set, called theindex set, and let

P be a mapping from I to separation algebras. Then the indexedproduct SA is h
\Pi x : I. P (x), Ji where J is defined pointwise:

J(f, g, h) j 8i 2 I. JP (i)(f (i), g(i), h(i)) (12)
What about the disjoint union operator? Can it be constructed? Unfortu-nately, it cannot. Suppose we have two SAs h

A, JAi, hB, JBi. We would like todefine h
A + B, Ji such that J is the smallest relation satisfying:

JA(x, y, z) ! J(inl x, inl y, inl z) for all x, y, z 2 A (13)
JB(x, y, z) ! J(inr x, inr y, inr z) for all x, y, z 2 B (14)

Here A + B is the disjoint union of A and B with inl and inr as the leftand right injections. This structure cannot be a separation algebra under the

original axioms: if uA and uB are the units of A and B, then both inl uA andinr

uB satisfy u \Phi  u = u. We noted the unit u is the unique element satisfyingthis equation, so inl

uA = u = inr uB. However, this is a contradiction asthe injection functions for disjoint union always produce unequal elements. The

generalization of disjoint union to the indexed sum fails for the same reason.One option for dealing with this problem is to use the "almost" disjoint
sum, which is the disjoint sum of the nonunit elements together with a singleunit. This solution is adequate, but not entirely satisfactory; it combines two
distinct operations (the disjoint sum and the combining of units) which are betterunderstood separately. In other words, the construction is not compositional.

There is good news, however: we can slightly relax the SA axioms to allowthe desired construction. Recall the SA axiom for the existence of a unit:

9u. 8x. u \Phi  x = x (9)
If we simply swap the order of the quantifiers in this axiom, we get a weakerstatement which says that every element of the SA has an associated unit:

8x. 9ux. ux \Phi  x = x (15)

3

To distinguish these species of separation algebras, we call SAs defined by axioms5, 6, 7, 8, and 9 Single-unit Separation Algebras (SSA), we call SAs defined by
axioms 5, 6, 7, 8, and 15 Multi-unit Separation Algebras (MSA). Note that axiom9 implies axiom 15, and thus the SSAs are a strict subset of the MSAs.

Although the relaxation to multiple units is common in the tradition of rel-evant logic [10], it is significant here because it enables a number of additional
operators, including na"ive indexed sums and the discrete separation algebra.
Definition 4 (MSA indexed sum operator). Let I be a set, called the indexset. Let

S be a mapping from I to separation algebras. Then the indexed sumMSA is h

\Sigma i : I. S(i), Ji such that J is the least relation satisfying:

JS(i)(x, y, z) ! J(inj i(x), inj i(y), inj i(z)) for all i 2 I; x, y, z 2 S(i) (16)
Here inj i is the injection function associated with i. As with products, if|
I| = 2, the indexed sum is isomorphic to the disjoint union operator.

Definition 5 (discrete MSA). Let A be a set. Then the discrete MSA is hA, Jiwhere

J is defined as the smallest relation satisfying:

J(x, x, x) for all x 2 A (17)
The discrete MSA has a join relation that holds only when all three argumentsare equal: every element of the discrete MSA is a unit. The discrete MSA is

useful for constructing MSAs over tuples where only some of the componentshave interesting joins; the other components can be turned into discrete MSAs.
Note the compositionality of this construction using the discrete and productoperators together. With SSAs, one would instead have to "manually" construct
an appropriate tupling operator because the discrete SA is not available.Sometimes we wish to coerce an MSA into an SSA; the lifting operator removes all the units from an MSA and replaces them with a new unique unit.5
Definition 6 (MSA lifting operator). Let hA, JAi be a multi-unit separationalgebra. Define

A+ to be the subset of A containing all the nonunit elements,
A+ = {x 2 A|~(x \Phi  x = x)}. Let ? be a distinguished element such that ? /2 A.Then the lifting SA is h

A+ [ {?}, Ji where J is the least relation satisfying:

J(?, x, x) for all x 2 A+ [ {?} (18)
J(x, ?, x) for all x 2 A+ [ {?} (19)
JA(x, y, z) ! J(x, y, z) for all x, y, z 2 A+ (20)

Note that the "almost" disjoint union described above can be constructedusing the lifting operator applied to the na"ive disjoint sum operator on MSAs.

Again compositionality is increased by working with MSAs.The above operators can construct many kinds of separation algebras. The
associated Coq development includes a number of additional operators (e.g.,lists, subsets, bijections, etc.) that we have also found useful.

5 Considered as a functor from MSA to SSA, the lifting operator is left adjoint to

the inclusion functor from SSA to MSA.

4

Assume we have a MSA hA, Ji. The following is a model of
HBI (a Hilbert-style axiomatization of the logic of bunched
implications). Prop is the type of Coq propositions, and the
right-hand sides are stated in Coq's metalogic.

formula j A ! Prop
a |= p j p(a)
p ` q j 8a. a |= p ! a |= q

? j *a. True? j

*a. False
p ^ q j *a. a |= p ^ a |= q
p . q j *a. a |= p . a |= q
p ! q j *a. a |= p ! a |= q
emp j *a. a \Phi  a = a
p * q j *a. 9a1.9a2. a1 \Phi  a2 = a ^ a1 |= p ^ a2 |= q
p --* q j *a. 8a1.8a0. a1 \Phi  a = a0 ! a1 |= p ! a0 |= q

Table 1. A model of HBI given a SA

4 Inducing a separation logic

The purpose of a separation algebra is to generate a separation logic, that is, aHoare-style program logic where the assertion language is the logic of bunched
implications (BI). Calcagno et al. demonstrated that their interpretation leadsto a Boolean BI algebra, a model of BI. Here we demonstrate that we are still
generating models for the desired class of logics despite relaxing the unit axiom.

We too will interpret formulae of separation logic as predicates on the ele-ments of a separation algebra (equivalently, members of the powerset). In Coq

we simply define the formulae as A -> Prop, where A is the type of elements inthe MSA, and

Prop is the type of propositions in Coq's metatheory.
We have chosen to directly link our models to the proof theory of BI byshowing

6 a soundness proof with respect to the system HBI, a Hilbert-style axiomatic system for the (propositional) logic of bunched implications [9, Table 2].The definitions which give rise to HBI are summarized in table 1; they are quite

standard, except for the definition of the empty proposition emp.

Ordinarily, one defines emp as the predicate which accepts only the unit ofthe SSA. However, by relaxing the unit axiom we allow multiple units, each of

which must be characterized. Recall that an MSA is a set of equivalence classesdistinguished by unique units, each of which satisfies the equation

u \Phi  u = u.In fact, only units satisfy that equation, so we define emp as the predicate that

accepts any element x provided that x \Phi  x = x. This subsumes the ordinarydefinition in the event that the unit is unique. More importantly, however, from
this definition we can prove that emp is the unit for separating conjunction.

Thus we see that relaxing the unit axiom does not take us outside the classof models of the logic of bunched implications.

6 The accompanying Coq development contains the full set of definitions and proofs.

5

5 Useful restrictions of SAs
Positivity. Calcagno et al.'s definition of separation algebras [4] permits verystrange logics that do not correspond well to the common view that the formulae
in separation logic describe resources.

Consider the structure h{0, 1, 2}, +3i, of the integers with addition modulo3. This structure satisfies the separation algebra axioms given in the previous

section and the integer 0 is the unique unit. The problem is that the followingholds: 1 +

3 2 = 0. The resource 1 combines with the resource 2 to give the"empty" resource 0. Stated another way, we can split the empty resource 0 to

get two nonempty resources 1 and 2. By analogy to physics, 1 and 2 act as aresource/antiresource pair that annihilate each other when combined.

This is not at all how one expects resources to behave. If one has, for example,an empty pile of bricks and splits it into two piles, one expects to have two empty
piles. One does not expect to get one pile of bricks and another pile of antibricks.

The existence of antiresources is particularly troublesome because it interactsbadly with the frame rule, a ubiquitous feature of separation logic. A program

with no resources can write to memory! Proof: it splits the empty permission,obtaining a write and an anti-write permission. Using the frame rule, it "frames
out" the antipermission, giving it the permission to perform a write.

Calcagno et al. resolve this problem by requiring that all actions be "local."The locality condition captures the requirement that actions must be compatible

with the frame rule; as a side-effect, the locality condition ensures that any"negative" resources that may exist cannot be used for any interesting purpose.
The ultimate consequence is that proving the required locality properties is moredifficult (if not impossible) in SAs with negative resources.

We prefer to directly rule out this troublesome class of separation algebrasby disallowing negative resources. We require that SAs be positive by adding the
following positivity axiom:

a \Phi  b = c ! c \Phi  c = c ! a \Phi  a = a (21)
That is, whenever two elements join to create a unit element, these joined ele-ments must themselves be units (and hence the same element). This axiom rules
out separation algebras such as the addition-modulo-3 example above. Further-more, this axiom is preserved by the all the SA operators we examined above,
which means we have not lost the ground we gained by relaxing the unit axiom.

One of most compelling reasons for including (21) in the axiom base is thatall the nontoy SAs known to the authors (that is, those which can be used to

reason about some computational system), including all five examples listed byCalcagno et al. [4], satisfy this axiom.

7

7 Brotherson and Calcagno [3] investigate Classical BI, whose models have negative,

or dual, elements. However, the combination of an element with its dual gives the
distinguished element 1, which is not necessarily the unit, so (21) may still hold.

6

The positivity axiom also allows us to make a connection to order theory.We define an ordering relation on the elements of a separation algebra:

a _ b j 9x. a \Phi  x = b (22)
This relation is reflexive and transitive, which makes it a preorder. The preorder_ is antisymmetric, and thus a partial order, if and only if axiom (21) holds.

Disjointness. The disjointness property is that no nonempty share joins withitself. If a separation logic over program heaps lacks disjointness then unusual
things can happen when defining predicates about inductive data in a programheap. For example, without disjointness, the "obvious" definition of a formula
to describe binary trees in fact describes directed acyclic graphs [1].Disjointness is easy to axiomatize:

a \Phi  a = b ! a = b (23)
The disjointness axiom requires that any SA element that joins with itself be aunit. Equivalently, it says that any nonunit element cannot join with itself (is

disjoint). This axiom captures the same idea as Parkinson's "disjoint" axiom [8]:

` 7!s v * ` 7!s v $ false (24)
The primary difference is that our axiom is on separation algebras, whereasParkinson's axiom is on separation logic.

As with the positivity axiom, the disjointness axiom is preserved by theSA operators presented in the previous section. It also implies positivity. The
converse does not hold: disjointness is strictly stronger than positivity.To see why disjointness (23) implies positivity (21), consider the following
proof sketch. Assume a \Phi  b = c and c \Phi  c = c for some a, b, and c; we wish toshow

a \Phi  a = a. Then the following hold (modulo some abuse of notation):

c \Phi  c = c assumed(

a \Phi  b) \Phi  (a \Phi  b) = a \Phi  b subst. a \Phi  b = c(
a \Phi  a) \Phi  (b \Phi  b) = a \Phi  b comm. and assoc.(
a \Phi  a) \Phi  b = a \Phi  b disjointness
a \Phi  a = a cancellation

The converse fails: consider the structure hN, +i of natural numbers with ad-dition. This fulfills the SA axioms, including positivity. However, every natural

number i > 0 falsifies the disjointness axiom.Two alternative ways of formulating the disjointness property are inspired
by order theory and provide additional insight. First, if a \Phi  b = c, then any lowerbound of

a and b is a unit:

a \Phi  b = c ! d _ a ! d _ b ! d \Phi  d = d (25)
Second, a \Phi  b is minimal in the following sense:

a \Phi  b = c ! a _ d ! b _ d ! d _ c ! c = d (26)
This implies that if a and b join and have a least upper bound, then it is a \Phi  b.

7

Cross-split. The alternative formulations of disjointness bring up an interestingpoint about separation algebras: even for two elements in the same equivalence
class, there is no guarantee that either least upper bounds or greatest lowerbounds exist. The lack of greatest lower bounds (i.e., intersections), in particular, proved to be troublesome in Hobor et al.'s proof of soundness of a concurrentseparation logic for Concurrent C minor [6, 5], when they needed to track permissions being transferred between threads. At the time they were using a modifiedversion of Parkinson's share model (discussed below) in which intersections did
not always exist. This failure resulted in an unpleasant workaround and spurreddevelopment of the alternate model discussed in section 7.

The particular property required was as follows: suppose a single resourcecan be split in two different ways; then one should be able to divide the original
resource into four pieces that respect the original splittings.

a \Phi  b = z ^ c \Phi  d = z !9

ac, ad, bc, bd. a b ac

ad bdbccdac \Phi  ad = a ^ bc \Phi  bd = b ^
ac \Phi  bc = c ^ ad \Phi  bd = d

(27)

That is, if an element can be split in two different ways, then there should be foursubelements that partition the original element and respect the splittings. We
call this property the cross-split axiom and, as with positivity and disjointness,this property is preserved by the separation algebra operators.

8

Splittability. Another frequently desirable property of SAs is infinite splittability,which is a useful property for reasoning about the kinds of resource sharing that
occur in divide-and-conquer style computations. Splittability means that we cantake any element of the SA and split it into two pieces that recombine into the
original. To avoid degenerate splittings, both the split pieces must be nonemptyif the original was nonempty. Thus, a SA is infinitely splittable if there exists a
function split that calculates such a splitting.

split x = (x1, x2) ! x1 \Phi  x2 = x (28)
split x = (x1, x2) ! x1 \Phi  x1 = x1 ! x \Phi  x = x (29)
split x = (x1, x2) ! x2 \Phi  x2 = x2 ! x \Phi  x = x (30)
There are reasonable separation logics that have models where disjointness,cross-split, and/or infinite splittability are false. We present these axioms because we (and others such as Parkinson) found them useful in separation logicproofs and metaproofs, and because any separation algebra built with our operator calculus can inherit them for free if desired. In contrast, every nontoyseparation algebra used for reasoning about computational systems and known
to the authors satisfies the positivity axiom (21). In our own work we find thatadding the disjointness axiom (which implies positivity) to the SA axiom base
to be quite convenient and suggest that "disjoint" MSAs, defined by axioms 5,6, 7, 8, 15 and 23, are very natural structures for reasoning in this domain.

8 To pull an intersection property through the lifting operator, one needs to apply lifts

only where there is a computable test for units, or use the axiom of description.

8

6 Shares
An important application of separation algebras is to model Hoare logics of pro-gramming languages with mutable memory. We generate an appropriate separation logic by choosing the correct semantic model, that is, the correct separationalgebra. A natural choice is to simply take the program heaps as the elements
of the separation algebra together with some appropriate join relation.In most of the early work in this direction, heaps were modeled as partial
functions from addresses to values. In those models, two heaps join iff theirdomains are disjoint, the result being the union of the two heaps. However, this
simple model is too restrictive, especially when one considers concurrency. Itrules out useful and interesting protocols where two or more threads agree to
share read permission to an area of memory.

There are a number of different ways to do the necessary permission account-ing. Bornat et al. [1] present two different methods; one based on fractional permissions, and another based on token counting. Parkinson, in chapter 5 of histhesis [8], presents a more sophisticated system capable of handling both methods. However, this model has some drawbacks, which we shall address below.

Fractional permissions are used to handle the sorts of accounting situationsthat arise from concurrent divide-and-conquer algorithms. In such algorithms, a

worker thread has read-only permission to the dataset and it needs to divide thispermission among various child threads. When a child thread finishes, it returns
its permission to its parent. Child threads, in turn, may need to split theirpermissions among their own children and so on. In order to handle any possible
pattern of divide-and-conquer, splitting must be possible to an unbounded depth.

The token-counting method is intended to handle the accounting problemthat arises from reader-writer locks. When a reader acquires a lock, it receives

a "share token," which it will later return when it unlocks. The lock tracks thenumber of active readers with an integer counter that is incremented when a
reader locks and decremented when a reader unlocks. When the reader countis positive there are outstanding read tokens; when it is zero there are no outstanding readers and a writer may acquire the lock.Here we will show how each of the above accounting systems arises from the
choice of a "share model," and we present our own share model which can handleboth accounting methods and avoids a pitfall found in Parkinson's model.

Suppose we have a separation algebra hS, JSi of shares. If L and V are setsof addresses and values, respectively, we can define a SA over heaps as follows:

H j L ! (S * V=)? (31)
This equation is quite concise but conceals some subtle points. The operatorsin this equation are the operators on SAs defined in $ 3. We let

V= be the"discrete" MSA over values (i.e., values
V with the trivial join relation) and
S * V= is the MSA over pairs of shares and values.Next we construct the "lifted"SSA (

S * V=)?, which removes the unit values and adds a new, distinguishedunit ?. This requires values to be paired only with nonunit shares. Finally,

9

L ! (S *V=)? builds the function space SSA. Thus, heaps are partial functionsfrom locations to pairs of nonunit shares and values.

9

Now we can define the points-to operator of separation logic as:

` 7!s v j *h. h(`) = (s, v) ^ (8`0.` 6= `0 ! h(`0) = ?) (32)
Here, ` 2 L is an address, v 2 V is a value, and s 2 S+ is a nonunit share.In English,

` 7!s v means "the memory location at address ` contains v, I haveshare
s at this location, and I have no permission at any other locations." Nowthe exact behavior of the points-to operator depends only on the share model

S.An important property of this definition is that the separation algebra on

shares lifts in a straightforward way through the separation logic:

s1 \Phi  s2 = s $ (` 7!s v $ ` 7!s1 v * ` 7!s2 v) (33)
Thus we can use properties of our share model in the separation logic.We can produce a separation logic very similar to the ones studied by Reynolds

[11] and by Ishtiaq and O'Hearn [7] by choosing S to be the SA over Booleanswith the smallest join relation such that "false" is the unique unit.

Definition 7 (Boolean shares). The Boolean share model is h{ffi, *}, Ji where
J is the least relation satisfying J(ffi, x, x) and J(x, ffi, x) for all x 2 {ffi, *}.

Here ffi and * stand for "false" and "true", respectively. This share model isunsophisticated: one either has unrestricted permission or no permission at all.

Note that the lifting operator removes ffi, leaving * as the only legal annotation.This justifies omitting the annotation, resulting in the more familiar

` 7! v.Boyland proposed a model which takes shares as fractions in the interval

[0, 1] as shares [2]. Although Boyland works in the reals, the rationals suffice.
Definition 8 (Fractional shares). The fractional share model is h[0, 1]"Q, +iwhere + is the restriction of addition to a partial operation on [0

, 1].

The main advantage of the fractional share model is that it is infinitely splittable.The splitting function is simple: to split a share

s, let s1 = s2 = s/2. Thefractional share model satisfies the positivity axiom but not the disjointness

axiom, which leads to the problems noticed by Bornat et al. [1, $13.1].Bornat et al. also examined the token factory model, where a central authority starts with total ownership and then lends out permission tokens. Theauthority counts the outstanding tokens; when the count is zero, all have returned. A slight modification of Bornat's construction yields a suitable model:
Definition 9 (Counting shares). The counting share model is hZ [ {?}, Jiwhere

J is defined as the least relation satisfying:

J(?, x, x) for all x 2 Z [ {?} (34)
J(x, ?, x) for all x 2 Z [ {?} (35)

(x < 0 . y < 0) ^ ((x + y >= 0) . (x < 0 ^ y < 0)) ! J(x, y, x + y)for all

x, y 2 Z (36)

9 Our heaps are quite similar those defined by Bornat et al. [1, $10.1]. Their "partial

commutative semigroup" of shares arises here from the nonunit elements of a SA.

10

This definition sets up the nonnegative integers as token factories and negativeintegers as tokens. To absorb a token back into a factory, the integers are simply
added. The token factory has collected all its tokens when its share is zero. Likethe fractional model, the counting model satisfies positivity but not disjointness.

This share model validates the following logical axioms:

` 7!n v $ (` 7!n+m v * ` 7!-m v) for n >= 0 and m > 0 (37)
` 7!-(n+m) v $ (` 7!-n v * ` 7!-m v) for n, m > 0 (38)
(` 7!0 v * ` 7!n v) $ false (39)

Equation (37) says that a token factory with n tokens outstanding can be splitinto a token (of size

m) and a new factory, which has n + m tokens outstanding.Furthermore the operation is reversable: a token and its factory can be recombined to get a factory with fewer outstanding tokens. Equation (38) says thatthe tokens themselves may be split and merged. Finally, equation (39) says that
it is impossible to have both a full token factory (with no outstanding tokens)and any other share of the same location (whether a factory or a token).

If one only utilizes tokens of size one, then equations (37)-(39) describe thesorts of share manipulations required for a standard reader-writer lock. Other
token sizes allow more subtle locking protocols where, for example, one threadmay acquire the read tokens of several others and release them all at once.

In his thesis, Parkinson defines a more sophisticated share model that cansupport both the splitting and the token counting use cases.

Definition 10 (Parkinson's named shares). Parkinson's named share modelis given by hP(N)

, ]i, where P(N) is the set of subsets of the natural numbersand ] is disjoint union.

10

This model satisfies the disjointness axiom, and thus positivity. It also satisfiesthe cross-split axiom: the required subshares are calculated by set intersection.

In order to support the token-counting use case, Parkinson considers thefinite and cofinite subsets of N. These sets can be related to the counting model
given above by considering the cardinality of the set (or set complement, forcofinite sets). We will see the details of this embedding later.

Unfortunately, this share model is not infinitely splittable, since there is noway to split a singleton set into two nonempty subsets. Therefore we cannot
define a total function which calculates the splitting of a share in this model,and this makes it difficult to support the parallel divide-and-conquer use case.

We can fix this problem by restricting the model to include only the infinitesubsets of N (and the empty set). We can split an infinite set

s by enumeratingits elements and generating
s1 from those in even positions and s2 from the thosein odd positions. Then
s1 and s2 are infinite, disjoint, and partition s.Unfortunately, restricting to infinite subsets means that we cannot use finite

and cofinite sets to model token counting. This problem can be solved, at thecost of some complication, with an embedding into the infinite sets [8].

10 That is, the union of disjoint sets rather than discriminated union.

11

The problem with that solution is that the infinite subsets of N are also notclosed under set intersection, which means the share model no longer satisfies
the cross split axiom. To see why this axiom fails, consider splitting N into theprimes/nonprimes and the even/odd numbers. All four sets are infinite, but the
set {2} of even primes is finite and thus not in the share model.

Hobor suggested further restricting the model by reasoning about equivalenceclasses of subsets of N, where two subsets are equivalent when their symmetric

difference is finite; but developing this model in Coq was difficult [5].

We will present a new model with all the right properties: disjointness axiom,cross-split axiom, infinitely splittable, supports token counting, and is straightforward to represent in a theorem prover. As a bonus, we also achieve a decidabletest for share equality.

7 Binary tree share model
Before giving the explicit construction of our share model, we shall take a shortdetour to show how we can induce a separation algebra from a lattice.

Definition 11 (Lattice SA). Let hA, v, u, t, 0, 1i be a bounded distributivelattice. Then, h

A, Ji is a separation algebra where J is defined as:

J(x, y, z) j x t y = z ^ x u y = 0 (40)
Disjointness follows from the right conjunct of the join relation; cross split followsfrom the existence of greatest lower bounds. It also has a unique unit, 0.

It is interesting to note that all of the share models we have examined thusfar that satisfy the disjointness axiom are instances of this general construction.11 The Boolean share model is just the lattice SA derived from the canon-ical 2-element Boolean algebra, and Parkinson's model (without the restriction
to infinite subsets) is the separation algebra derived from the powerset Booleanalgebra. Restricting Parkinson's model to infinite sets as described above buys
the ability to do infinite splitting at the price of destroying part of the structureof the lattice. Below we show that paying this price is unnecessary.

If the structure is additionally a Boolean algebra, then we can make thefollowing pleasant connection:

x _ y $ x v y (41)
That is, the lattice order coincides with the SA order. The forward directionholds for any bounded distributive lattice. The backward direction relies on
the complement operator to construct the witness (~x u y) for the existentialquantifier in the definition of _. Any bounded distributive lattice satisfying (41)
is a Boolean algebra; the witness of _ gives the complement for x when y = 1.
11 This is not necessarily so. There exist disjoint SAs which are not distributive lattices.

12

Trees. Now we can restate our goal; we wish to construct a bounded distributivelattice which supports splitting and token counting. This means we must support
a splitting function and we must be able to embed the finite and cofinite subsetsof the naturals. We can build a model of shares supporting all these operations by
starting with a very simple data structure: the humble binary tree. We considerbinary trees with Boolean-valued leaves and unlabeled internal nodes.

o/ ::= ffi | * | o/ o/ (42)
We use an empty circle ffi to represent a "false" leaf and the filled circle * torepresent a "true" leaf. Thus * is a tree with a single leaf, ffi * is a tree with one

internal node and two leaves, etc.We define the ordering on trees as the least relation v satisfying:

ffi v ffi (43)ffi v *

(44)* v *
(45)ffi ,
= ffi ffi (46)* ,
= * * (47)
x1 v x2 ! y1 v y2 ! x1 y1 v x2 y2 (48)

Here, x ,= y is defined as x v y ^ y v x. The intuitive meaning is that x v yholds iff

x has a ffi in at least every position y does once we expand leaf nodesusing the congruence rules until the trees are the same shape. The congruence

rules allow us to "fold up" any subtree which has the same label on all its leaves.This relation is reflexive and transitive; however it is not antisymmetric because of the structural congruence rules. We can get around this by workingonly with the "canonical" trees. A tree is canonical if it is the tree with the
fewest nodes in the equivalence class generated by ,=. Canonical trees alwaysexist and are unique, and the ordering relation is antisymmetric on the domain
of canonical trees. Therefore we can build a partial order using the canonicalBoolean-labeled binary trees with the above ordering relation.

The details of canonicalization are straightforward but tedious, so we willwork informally up to congruence. In the formal Coq development, however,
we give a full account of canonicalization and show all the required properties.The short story is that we normalize trees after every operation by finding and
reducing all the subtrees which can be reduced by one of the congruence rules.Our next task is to implement the lattice operations. The trees ffi and * are
the least and greatest element of the partial order, respectively. The least up-per bound of two trees is calculated as the pointwise disjunction of Booleans
(expanding the trees as necessary to make them the same shape). For exam-ple, *

* ffi t * ffi ffi ,= * * * ffi t * ffi ffi ffi ,= * * * ffi ,= * * ffi . Likewise, thegreatest lower bound is found by pointwise conjunction, so that * * ffi u * ffi ffi

,= * * * ffi u * ffi ffi ffi ,= * ffi ffi ffi ,= * ffi ffi . Finally, this structure is a Boolean
algebra as well as a distributive lattice, and the complement operation is point-wise Boolean complement: ~ *

* ffi ,= ffi ffi * . The Boolean algebra axioms can beverified by simple inductive arguments over the structure of the trees.

13

We can also define a decidable test for equality by simply checking structuralequality of trees. Trees form a lattice, and thus a decision procedure for equality also yields a test for the lattice order. In contrast, Parkinson's model overarbitrary subsets of N lacks both decidable equality and decidable ordering.

In addition to the lattice operations, we require an operation to split trees.Given some tree

s, we wish to find two trees s1 and s2 such that s1 t s2 ,= s and
s1 u s2 ,= ffi and both s1 AE ffi and s2 AE ffi provided that s AE ffi. We can calculate s1and

s2 by recursively replacing each * leaf in s with * ffi and ffi * respectively.We can usefully generalize this procedure by defining the "relativization"

operator x on y, which replaces every * leaf in x with the tree y. This operatoris associative with identity *. It distributes over t and u on the left, and is
injective for non-ffi arguments.

x on * = x = * on x (49)
x on ffi = ffi = ffi on x (50)
x on (y on z) = (x on y) on z (51)
x on (y t z) = (x on y) t (x on z) (52)
x on (y u z) = (x on y) u (x on z) (53)
x on y1 = x on y2 ! x = ffi . y1 = y2 (54)
x1 on y = x2 on y ! x1 = x2 . y = ffi (55)

Given this operator, we can more succinctly define the split of x as returningthe pair containing

x on * ffi and x on ffi *. The required splitting properties followeasily from this definition and the above properties of on.

If this were the only use of the relativization, however, it would hardly beworthwhile to define it. Instead, the main purpose of this operator is to allow us
to glue together arbitrary methods for partitioning permissions. In particular, wecan split or perform token counting on any nonempty permission we obtain, no
matter how it was originally generated. In addition, we only have to concentrateon how to perform accounting of the full permission * because we can let the on
operator handle relativizing to some other permission of interest.Following Parkinson, we will consider finite and cofinite sets of the natural
numbers to support token counting. This structure has several nice properties.First, it is closed under set intersection, set union and set complement and it
contains N and ;; in other words, it forms a sub-Boolean algebra of the power-set Boolean algebra over N. Furthermore the cardinalities of these sets can be
mapped to the integers in following way:

[[p]]Z = ae -|p| when p is finite and nonempty|N\p| when p is cofinite (56)
The cardinalities of disjoint (co)finite sets combine in exactly the way definedby the counting share model (equation 36).

We can embed the (co)finite subsets of N into our binary tree model byencoding the sets as right-biased trees

12 (trees where the left subtree of each

12 We could just as well have used left-biased trees.

14

internal node is always a leaf). Such trees form a list of Booleans together withone extra Boolean, the rightmost leaf in the tree. Then the

ith Boolean in thelist encodes whether the natural number
i is in the set. The final terminatingBoolean stands for all the remaining naturals. If it is ffi, the set is finite and

does not contain the remaining naturals, and if it is * the set is infinite andcontains all the remaining naturals. This interpretation is consistent with the
congruence rules that allow you to unfold the rightmost terminating Booleaninto a arbitrarily long list of the same Boolean value.

For example, the finite set {0, 2} is encoded in tree form as * ffi * ffi. The
coset N\{0, 2} is encoded as ffi * ffi *. And, of course, * ffi * ffi \Phi  ffi * ffi * = *.

This encoding is in fact a Boolean algebra homomorphism; GLBs, LUBs,complements and the top and bottom elements are preserved. This homomorphism allows us to transport the token counting results on (co)finite sets tobinary trees. We write [[

p]]o/ = s when s is the tree encoding the (co)finite set p.
Now we can define a more sophisticated points-to operator which allows usto incorporate token counting along with permission splitting.

` 7!s,n v j *h. 9p. h(`) = (s on [[p]]o/ , v) ^ [[p]]Z = n^ 8`0.` 6= `0 ! h(`0) = ? (57)
Then ` 7!s,n v means that ` contains value v and we have a portion of thepermission

s indexed by n. If n is zero, we have all of s. If n is positive, we havea token factory over

s with n tokens missing, and if n is negative, we have atoken of
s (of size -n).
This points-to operator satisfies the following logical axioms:

(` 7!s,0 v * ` 7!s,n v) $ false (58)
s1 \Phi  s2 = s ! ((` 7!s1,0 v * ` 7!s2,0 v) $ ` 7!s,0 v) (59)
n1 \Phi  n2 = n ! ((` 7!s,n1 v * ` 7!s,n2 v) $ ` 7!s,n v) (60)
` 7!s,n v ! 9!s0. ` 7!s,n v $ ` 7!s0,0 v (61)

Equation (58) generalizes both the disjointness axiom from Parkinson (24)and the disjointness axiom for token factories (39). Likewise, equation (59) generalizes the share axiom (33). Essentially, if we fix n = 0 we get back the simplerdefinition of the points-to operator from above as a special case. In equation
(60), n1 \Phi  n2 = n refers to the token counting join relation on integers definedin equation 36, and this axiom generalizes the token factory axioms (37) and
(38). Both of those axioms follow as a special case when we fix s = ?. Finally,equation (61) allows one to project a tokenized share into a nontokenized share
(one where n = 0). This might be useful if one needs to perform share splittingon a share which was derived from a token factory, for example.

This collection of axioms allow fluid reasoning about both the token-countingand splitting use cases, which enables a unified way to do flexible and precise
permission accounting.

15

8 Conclusion
We have presented a new formulation of multi-unit separation algebras which wefind easier to use than the original definition by Calcagno et al. [4]. The original
definition is both too restrictive (it rules out desirable constructions, includingthe na"ive disjoint sum and the discrete SA) and too permissive (it allows badlybehaved "exotic" SAs). We examined a variety of operators over separationalgebras that allow us to easily construct complicated separation algebras from
simpler ones, and have shown an example of their utility.We have also constructed a new solution to the share accounting problem.
Our share model based on Boolean-labeled binary trees fully supports both thesplitting and token counting use cases for read sharing, and yet still validates the
cross split axiom; it also enjoys a decidable equality test. No previously publishedsystem for share accounting has all these properties. Parkinson's model [8] comes
closest, but suffers from the inability to find splittings for some shares and lacksdecidable equality.

We have implemented the constructions discussed in this paper and provedtheir relevant properties using the proof assistant Coq.

3

References

1. R. Bornat, C. Calcagno, P. O'Hearn, and M. Parkinson. Permission accounting in

separation logic. In POPL '05: Proc. of the 32nd ACM SIGPLAN-SIGACT Symp.
on Principles of Programming Languages, pages 259-270, 2005.
2. J. Boyland. Checking interference with fractional permissions. In R. Cousot,

editor, Static Analysis: 10th International Symp., volume 2694 of Lecture Notes in
Computer Science, pages 55-72. Springer, 2003.
3. J. Brotherston and C. Calcagno. Classical BI: a logic for reasoning about dualising

resources. In POPL '09: Proc. of the 36th ACM SIGPLAN-SIGACT Symp. on
Principles of Programming Languages, pages 328-339, 2009.
4. C. Calcagno, P. W. O'Hearn, and H. Yang. Local action and abstract separation

logic. In LICS '07: Proceedings of the 22nd IEEE Symp. on Logic in Computer
Science, pages 366-378, 2007.
5. A. Hobor. Oracle Semantics. PhD thesis, Princeton University, 2008.
6. A. Hobor, A. W. Appel, and F. Zappa Nardelli. Oracle semantics for concurrent

separation logic. In Proc. European Symp. on Programming (ESOP 2008), volume
4960/2008, pages 353-367, 2008.
7. S. S. Ishtiaq and P. W. O'Hearn. BI as an assertion language for mutable data

structures. In POPL '01: Proc. of the 28th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, pages 14-26, 2001.
8. M. Parkinson. Local Reasoning for Java. PhD thesis, Univ. of Cambridge, 2005.
9. D. J. Pym, P. W. O'Hearn, and H. Yang. Possible worlds and resources: the

semantics of BI. Theor. Comput. Sci., 315(1):257-305, 2004.
10. G. Restall. An Introduction to Substructural Logics. Routledge, London, 2000.
11. J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In

LICS '02: Proc. of the 17th Annual IEEE Symp. on Logic in Computer Science,
pages 55-74, 2002.

16