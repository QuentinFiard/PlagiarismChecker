

Recursion  and  Dynamic  Data-structures  in  Bounded  Space: 

Towards  Em.bedded  ML  Programming 

John  Hughes  Lars  Pareto 
Department  of  Computing  Science 
Chalmers  University;  S  412  96  Gateborg {rjmh,pareto}@cs.  Chalmers.  se 

Abstract 
We  present  a functional  language with  a type  system  such that  well  typed  programs  run  within  stated  space-bounds. 
The  language  is  a  strict,  first-order  variant  of  ML  with  con- structs  for  explicit  storage  management.  The  type  system 
is  a  variant  of  Tofte  and  TaIpin's  region  inference  system to  which  the  notion  of  sized  types,  of  Hughes,  Pareto  and 
Sabry,  has  been  added. 

1  Introduction 
During  the  last  decade,  declarative  programming  has  found its  way  to  large-scale  industrial  practice:  Erlang  [AVW93] 
is  used  by  Ericsson  to  program  telecommunication  systems; Lustre  [HCRPSl]  by  Aerospatiale  (among  others)  for  em- 
bedded  systems  programming.  Aimed  at  different  domains, these  two  languages  are  different  in  nature.  Erlang  is  rich, 
but  not  very  safe:  it  is  a  general  purpose  programming  lan- guage  extended  with  constructs  for  concurrency,  but  does 
not  prevent  a  program  from  crashing  -  it's  not  even  stati- cally  typed.  Lustre  is  safe  but  very  restricted:  it  guarantees 
that  all  programs  terminate  and  that  they  do  not  run  out  of space,  but  then,  all  computations  must  be  expressed  using 
booleans,  numbers,  streams  and  operations  on  these  -  not even  function  definitions  are  allowed. 

These  languages  might  be  sufficient  for  their  intended domains,  but  it  is  not  hard  to  think  of  applications  where 
they  are  not:  picture  an  embedded  program  that  maintains a  few  lookup-tables.  In  Lustre,  such  a  computation  cannot 
conveniently  be  expressed.  In  Erlang  it  can,  but  at  the  cost of  a  potential  abortion  at  run-time.  That  a  program  eventu- 

ally  computes  a  result  is  a  fundamental  requirement  on  any embedded  program. 

We  propose  a  programming  language  that  guarantees termination  and  execution  in  constant  space  and  that  al- 
lows  user-defined  recursive  functions  and  dynamic  data- structures. 

Our  approach  is  to  use  a  type  and  effect  system  with 1)  a  built  in  induction  principle  to  guarantee  that  recursive 
programs  terminate,  with  2)  a  notion  of  sizes  for  data-types to  allow  manipulation  of  dynamic  data-structures  (such  as 

Permission  to  make  digital  or  hard  copies  of  all  or  part  of  this  work  for personal 

or  classroom  use  is  granted  without  fee  provided  that 
copies  are  not  made  or  distributed  for  profit  or  commercial  advan- 
tage  and  that  copies  bear  this  notice  and  the  full  citation  on  the  first  page. 

To  copy  otherwise,  to  republish,  to  post  on  SMW~S  or  to 
redistribute  to  lists,  requires  prior  specific  permission  and/or  e  fee. 

ICFP  `99  S/99  Paris,  France 
Q  1999  ACM  l-58113-11  I-9/99/0009...~5.00 

lists)  in  constant  space;  that  3)  maintains  an  upper  bound on  the  height  of  the  run-time  stack  to  guarantee  that  a  pro- 
gram  never  runs  out  of  stack  space,  and  that  4)  maintains an  upper  bound  on  the  memory  allocations  to  guarantee 
that  a  program  never  runs  out  of  heap  space.  The  tech- nique  for  termination  proofs  (1)  and  the  notion  of  sizes  (2) 

are  immediately  inherited  from  our  previous  work  on  sized types  [HPS96,  Par98],  which  does  not  address  the  bounded 
space  problem.  The  techniques  for  memory  allocation  (4) are  based  on  Tofte's  and  Talpin's  work  on  region  infer- 
ence  [TT97],  which  takes  storage  use  into  account,  but  which cannot  give  space  bounds  for  recursive  data-structures.  The 

use  of  a  type  and  effect  system  to  compute  an  upper  bound for  the  run-time  stack  (3)  is  novel. 

In  the  next  section,  we  will  introduce  our  working  lan- guage  MML  (embedded  ML):  a  strict,  first  order,  purely 
functional  language  with  explicit  regions;  we  start  by  moti- vating  our  approach,  and  then  give  an  informal  introduction 
to  regions  and  to  what  programming  in  the  language  looks like  (sec.  2.1  and  2.2).  The  technical  part  of  the  paper  de- 
fines  the  syntax  (sec.  2.3),  the  semantics  (sec.  3),  and  the type  system  (sec.  4)  of  MML.  The  technical  part  is  followed 
by  a  discussion  of  the  correctness  of  the  type  system  (sec.  5.1 and  5.2),  of  the  implementation  aspects  of  MML  (sec.  5.3, 

5.4,  and  5.5),  of  four  possible  language  extensions  (sec.  5.6, 5.7,  5.8,  and  5.9),  and  of  two  possible  widenings  of  our  ap- 
proach  (sec.  5.10,  and  5.11). 

2  A  Functional  Language  with  Explicit  Regions 
One  praised  aspect  of  functional  programming  is  that  it entirely  relieves  the  programmer  from  specifying  where  in 
memory  any  run-time  values  should  reside  --  storage  issues are  left  to  the  compiler  and  to  the  run-time-system. 

Coincidentally,  a  long  cursed  aspect  of  functional  pro- gramming  has  been  that  programs  use  far  too  much  mem- 
ory  and  that  its  hard  for  the  programmer  to  mend  this  - functional  compilers  and  run-time  systems  seem  not  able  to 
solve  these  storage  issues  in  a  satisfying  way A  valid  question,  thus,  is  whether  traditional  functional 

language  designs  have  taken  the  abstraction  from  storage management  too  far?  Will  there  not  always  be  cases  where 
the  programmer  can  do  a  better  job  than  the  compiler,  and in  which  he  is  willing  to  undertake  this  effort?  Is  a  program- 
ming  language  that  does  not  abstract  away  from  storage management  necessarily  a  lesser  language? 

The  ML  Kit  project  at  Diku  has  convincingly  demon- strated  that  SML  can  be  given  a  semantics  that  also  takes 

70 

storage  management  into  account,  that  the  programmer  who understands  this  can  tune  his  programs  to  use  significantly 

less  space  than  before,  and  that  the  traditional  advantages  of high-level  programming  by  no  means  are  lost  by  giving  the 

programmer  control  over  the  storage  management  [TBE+]. Undeniably,  advances  in  compiler  technology  will  reduce 
the  potential  win  of  this  approach,  but  we  shall  proceed under  the  assumption  that  programmers  -  at  least  in  the 

near  future  -  are  cleverer  than  the  compilers  they  use. In  the  ML  Kit,  storage  management  is  implicit.  The 
source  language,  SML,  is  automatically  translated  into  a compiler  intermediate  language  with  constructs  for  storage 
management.  It  is  an  understanding  of  this  intermediate language,  and  of  the  translation  process  that  gives  the  pro- 
grammer  the  desired  control. Our  approach,  instead,  is  to  make  storage  management 
explicit.  The  storage  constructs  of  the  ML  Kit's  interme- diate  language  are  present  at  the  source  level  of  ours.  We 
believe  that  in  the  domain  of  embedded  systems,  program- mers  want  that  explicit  control. 

2.1  Programming  with  Regions 

Regions  can  be  thought  of  as  short-lived  heaps  that  are  in- troduced  and  disposed  of  by  the  programmer.  A  region  is 

empty  at  its  point  of  creation,  successively  filled  with  values during  its  lifetime,  and  discarded  in  one  go  when  disposed. 
In  contrast  to  heaps,  regions  are  never  garbage-collected: neither  during  their  lifetimes,  nor  when  they  cease  to  exist. 

Regions  are  associated  with  a  region  size  that  denotes the  number  of  machine  words  occupied  by  a  region;  this  size 
is  constant  during  the  lifetime  of  a  region. In  MML,  a  region  is  introduced  by  the  construct 

letreg  z#e  in  e' 
which  creates  a  region  of  the  size  determined  by  the  expres- sion  e  (a  number),  binds  a  reference  to  this  region  (a  name) 
to  the  variable  2,  evaluates  e'  in  the  current  environment extended  with  this  binding,  and  which,  finally,  discards  the 
region  before  returning  the  value  of  e'.  Clearly,  the  value  of e'  must  not  be  stored  in  this  region;  the  region  is  merely  to 

be  used  by  the  computations  that  produce  this  value. Two  kinds  of  values  -  tuples  and  constructors  -  can 
be  stored  in  regions,  and  these  values  can  only  be  stored  in regions.  To  specify  in  which  region  a  value  should  be  stored 
tuple-  and  constructor-expressions  are  augmented  with  re- gion  parameters.  Atomic  values,  such  as numbers,  are  stored 
either  on  the  stack  or  in  the  region  of  an  enclosing  tuple  or constructor,  and  thus  do  not  need  any  region  parameters. 

For  example,  the  program  to  store  the  pair  (5,66)  in  a  re- gion  accessible  by  x,  and  to  compute  the  sum  of  the  elements 
of  this  pair  (which  can  be  retrieved  with  the  projection  op- erators  ~1  and  ~2)  is 

letreg  x#i  in  let  a  =  (5,66),  in  ~1  a  +  ~2  a 
The  annotation  on  the  region  size  indicates  that  the  expres- sion  is  a 

region  size  expression  and  not  an  ordinary  natural number.  This  distinction  is  necessary,  because  these  two 

classes  of  numbers  have  different  types  -  we  shall  return  to this  below. 

The  size  of  the  region  above  is  taken  to  be  2  because  two words  are  necessary  to  store  a  pair. 

Regions  in  MML  can  be  passed  to  functions  and  also  be returned.  The  above  program,  for  example,  can  be  rewritten 
to: 

f  XY  r  =  (%Y)P 

gp  =  7np+nzp 

letreg  x#i  in  let  a  =  f  5 66  z  in  g  a 

Here,  the  function  f  creates  a  pair  in  an  arbitrary  region specified  by  the  region  parameter  r;  the  function  g  computes 
the  sum  of  a  pair  stored  in  an  arbitrary  region  -  note  that no  region  parameter  is  necessary  for  this. 

Regions  cannot,  however,  be  constructed,  decomposed or  compared:  the  only  way  to  introduce  a  region  is  by  the 
letreg-construct;  the  only  way  to  use  a  region  (except  for passing  it  around)  is  as  a  storage  designator  in  a  tuple-  or  a 
constructor  expression. 

2.2  Sized  Region  Types 
Consider  the  program 
lenxs  =casemofnil-+O;  conszm'-+l+Zenas 
full  n  r  =  cons  n  (  case  n  of 0  +  nil  T 

2  +  1 +  full  2  r)  r 
letreg  x#&3  i  i  in  Zen(fuZZ  4  z) 

which  presents  two  typical  programming  slips,  that  would both  lead  to  a  crash.  In  the  definition  of  Zen,  the  recursive 

call  is  given  xs  rather  than  xs',  causing  the  run-time  stack  to grow  out  of  hand;  in  the  letreg-declaration,  the  programmer 
has  correctly  remembered  that  it  takes  3  words  to  store  a cons  cell,  and  one  word  to  store 

nil;  what  he  has  overlooked is  that  the  list  returned  by  fall  4  x  -  or  not  returned  in 

this  case  -  has  a  length  of  five  rather  than  four.  This'leads to  an  overfull  region, 

Let  us  look  at  how  the  type  system  of  MML  prevents errors  of  these  kinds.  We  start  by  looking  at  the  basic  notion 
of  sized  types.  First  of  all,  every  inductively  defined  value  is associated  with  a  size  that  denotes  the  number  of  iterations 
of  the  type  definition  necessary  to  define  the  value,  e.g.,  the. natural  number  1  (which  denotes  succ 

zero)  has  size  two;  the list 
nil  has  size  one.  No  value  can  have  size  zero.  Moreover, every  inductively  defined  type  carries  a  size  that  gives  an 

upper  bound  on  the  sizes  of  the  values  in  the  type,  e.g.,  the type 

Lists  Nat2  contains  the  elements  nil,  0  :  nil,  1  :  nil,  0  : 0  : 
nil,  . . . , l:l:nil,  but  neither  2:nil,  nor  0:O:O:nil.  (Refer  to [HPS96,  Par981  for  more  details  on  sized  types.) 

This  paper  extends  these  types  with  region  parameters: tuple-  and  data-types  (but,  notably,  not  numbers)  are  aug- 
mented  with  a  parameter  that  specifies  in  which  region  a value  is  stored. 

The  type  of  the  intended  list  length  function  above,  for example,  would  typically  be 

Zen  :: V  k a  r  . Listk  a  r  +  Natk  with  d  =  5k 
and  with  the  following  interpretation:  given  a  list  of  size  k, with  elements  of  type  a,  and  that  resides  in  region 

r,  Zen will return  a  natural  number  of  size  Ic. 

Another  extension  present  in  this  type  is  the  stack  effect 6,  which  states  that  the  temporary  use  of  stack-space  during 
any  execution  of  Zen,  is  5  times  k  words.  (Five,  because,  at each  recursive  call,  the  values  of  x,  m',  1,  and  m'  again,  as 

71 

well  as  a  return  address,  will  reside  on  the  run-time  stack  - this  will  be  evident  when  we  introduce  the  abstract  machine 
semantics  below.) The  termination-proof-technique  employed  by  the  type 
system,  and  that  traps  the  first  bug  above,  consi.sts  of  a base  case,  and  an  inductive  case,  which,  for  len,  reduces  to 
showing  that 

len"  x3  =  case  x3  of  nil  +  0;  cons  x  xd  +  1  +  Zen'  m 
is  typable  under  the  type  assignment 

Een'  ::  Lkitk  a r  -+  Natk  with  d  =  5k 
Zen"  ::  Lktk+l  a r  +  k&+1  with  6  =  5 *  (k  +  1) 

But  this  is  not  possible.  The  variable  D  cannot  both  have size 

k  and  size  k  +  1,  which  this  non-proof  would  require. The  program  is  rejected  on  this  ground. 

If  we  correct  the  bug  by  replacing  the  second  occurrence of  m,  with  xs',  this  verification  step  will  succeed. 
To  see how  the  second  bug  is  detected  by  the  type  system, we  introduce  a  type  for  fall 

fall  :: Vkr  . Natk  x  r  --+  ktkfl  (Natk)  r  with 

S=5k;  r+=  3k+1 

which  causes  no  problems.  By  coincidence,  the  stack  effect is  again  5k:  at  each  recursive  call,  the  values  of  n,  2,  Z,  T, 

plus  a  return  address  will  have  been  pushed  onto  the  stack. The  type  of  fall  also  has  a  put  e&t 

(r  +=  3k  +  1)  telling  us that  the  function  will  store  att  most 
3k  +  1  words  in  region 
r.  (Three,  because  every  cons-node  occupies  one  word  each for  the  constructor-name,  the  head,  and  for  the  tail.) 

Returning  to  our  fallacious  program,  let  p  be  the  type  of the  region  bound  `to  x  by  the  letreg-construct,  and  note  that 
4  has  type  Nab,  the  type  of  fall  gives  that  the  expression falZ 

4  x  has  type  Lists  Nat5  p  with  the  stack  effect  b  =  28 (five  times  five,  plus  three  words  for  the  parameters  and  the 

return  address  of  the  call)  and  the  put  effect,  p +=  16.  These effects  will  be  propagated  through  Zen,  so  the  body  of  the 
letreg-expression  will  also  have  the  put  effect  p+=  16.  The type  system  rejects  the  program  because  16  g  4 *  3 +  1.  To 
fix  the  problem,  the  programmer  simply  has  to  increase  the region  size  by  three. 

The  type  of  the  corrected  program,  is 

Nat5  with  6  =  33;  C$ =  17 
Notice  that  this  type  has  no  put  effects:  put-effects  concern regions  in  scope,  and  at  the  top-level  of  a  program,  there 
are  no  regions  in  scope.  Instead,  the  program  has  a  store eflect  Q that  gives  the  maximum  size  of  the  store  during  its 
evaluation. Notice,  also,  that  this  store-effect  is  one  word  larger  than 
the  put-effect  of  the  let-expression's  body.  To  understand why,  we  need  to  take  a  look  at  the  run-time  system. 

The  run-time  system  of  MML  maintains  two  stacks:  a value  stack  in  the  style  of  traditional  implementations  of 
strict  languages,  and  a  region  stack  in  style  of  the  ML  Kit, and  on  which  letreg-expressions  will  push  and  pop  region 
frames  -  run-time  representations  of  regions.  A  region  of size  s  is  represented  by  s  machine  words  in  sequence  pre- 

ceded  by  a  region  offset  that  divides  the  region  into  an  occu- pied  and  a free  part.  This  offset  will  be  0  at  the  creation  of  a 
region,  and  successively  increased  by  the  allocations  in  that region  by  the  number  of  words  required  to  store  a value.  The 

offset  is  never  decreased.  For  example,  writing  w  ' . . w  for a  sequence  of  machine  words,  and  _ for  an  undefined  value, 

the  region  stack  during  the  evaluation  of 

letreg  x#4  in  letreg  y#i  in let  a  =:  (7,8,9)z  in  let  b  =  (6,7),,  in  0 

would  be  0 - - __ just  after  the  binding  of  x,  .and  3 7 8 9 _ 2 6 7 after  the  binding  of  b.  This  representation  explains  why 
the  store  effect  of  a  letreg-expression  is  that  of  its  body's put-effect  plus  one. 

As  for  the  stack  effect,  we  need  one  word  to  store  the  re- gion  on  the  stack.  Thus  the  stack  effect  of  a Ietreg-expression 
is  one  greater  than  that  of  its  body.  In  this  example,  the  call of  len  requires  32  words  (30  plus  two  for  the  parameter  and 
the  return  address  of  the  first  call).  Hence  the  stack  effect b  =  33. 

As  mentioned  above,  region  size  expressions  are  not  ordi- nary  natural  numbers  (hence  the  annotations).  The  distinc- 
tion  is  required  by  the  type  system,  which,  at  letregs,  needs to  know  the  region  size  exactly.  As  the  type  Natk  only  give 
bounds  on  sizes,  we  need  a  different  type,  Sizek,  that  gives us  this.  To  avoid  overloading,  we  use  a  different  syntax  for 
region  size  expressions  and  write  jL,  e i  e,  etc.,  as  in 

i  ::  Size]  iii  :: Sizes 
Types  with  this  precision  will,  of  course,  impose  severe  re- strictions  on  the  programs  that  compute  with  their  elements; 
one  cannot,  for  example,  use  a  case  expressions  to  return  dif- ferent  sizes.  Fortunately,  such  computations  do  not  have  to 
be  very  expressive.  What  we  typically  want  to  express  is how  the  put  effect  of  a  function  depends 

on  the  arguments of  this  function,  i.e,  the  dependency  that  also  appears  in  the 

type  of  a  function.  Now,  these  dependencies  are  themselves severely  restricted:  as  we  shall  see,  size  expressions  are  con- 
fined  to  linear  functions.  As  long  as  we  can  express  such, programming  with  sizes  is  permissive  enough. 

Let  us  illustrate  the  use  of  computations  with  sizes  by showing  how  our  main  example  can  be  made  more  readable 
through  the  use  of  a  function  fall'  to  compute  the  put  effect, of  fall: 

len  ::  Vkar,  Listk  a r  +  Natk  with  6  =  51c 
lenxs  =casexsofnil+O;  consxs--+17lens 

fall  ::  Vkr  . Natk  x  r  +  Lktk+L  (N&k)  r  with 6=5/c;  r+=  31c+1 

fall  n  r  =  cons  `n  (  case  n  of 0 

+  nil  r x  +  1  +  fall  x  r)  r 

fan'  ::  Vk.  Sizek  +  Sizeak+l fall'  s  =  339  i  i 
letreg  x#  fall'  5  in  Zen( fall  4  x) 

72 

2.3  The  Syntax  of  MML 

We  move  on  to  formalise  our  development  so  far,  and  start with  MML's  syntax: 

P  ..- ..-  9 aa-9  e 

9  ::=  d,..d d  ..- ..- 

f  x...x  =  e 
e  ::=  nliilxl  ce---ee  1  eoe  1  fe.--e 

I  let  2  =  e in  e 
I  letregx#eine  I  (e,...,e),  I  7rne I 

caseeofO+e[z+l+e  1  caseeofA...A 
0  ::=  +  1  -  1  *  1  -j-  I-  1  i 
A  ..- ..-  cx..-  2  +  e 

n  E  NAT  x  E VAR  c  E CON  f  E FUNVAR 

A  program  (P)  consists  of  a  sequence  of  groups  of  mutually recursive  function  definitions  (g)  followed  by  an  expression. 

Such  groups,  in  turn,  are  sequences  of  basic  function  defini- tions  (d)  that  take  the  form  f  z  a. * z  =  e.  The  top-level  of 
a  program  is  the  only  place  where  function  definitions  are allowed:  there  are  no  lambda  expressions  or  other  means  of 
defining  a  function  within  an  expression. The  form  of  an  expression  (e)  is  more-or-less  standard, 
but  with  occasional  twists  that  call  for  our  attention: Numbers  are  present  both  as  naturals  (n)  and  as  sizes 

(ii)  as  discussed  above.  Variables  (z)  are  standard. Constructor  expressions  (c  er  . . .  e,  e)  consist  of  n  argu- 
ment  expressions,  in  the  style  of  Haskell,  plus  an  additional region  expression.  Constructors  cannot  be  partially  applied. 

The  arithmetic  operators  (0)  are  restricted  to  addition, subtraction,  and  multiplication,  but  more  operators  could 
easily  be  added. Function  calls  (f  ei  . . . e,)  are  standard.  Partial  appli- 
cation  is  not  allowed. Let  expressions  (let  z  =  e  in  e')  are  monomorphic,  and 

must  be  non-recursive  (lacking  expressions  of  function  type, the  language  has  no  need  for  a  polymorphic  let). 

The  letreg-  (letreg  x:#e  in  e'),  tupling-  ((el,.  . . , en)e)r and  projection-constructs  (7-r, e)  have  already  been  covered. 

There  are  case  expressions  of  two  forms:  for  natural  num- bers  (case  e of  0  +  ei  0 z  +  1 +  ez)  and  for  constructor  ex- 
pressions  (case  e  of  A1  . . . An),  that  is,  for  unboxed  values (vahres  stored  on  the  run-time  stack)  and  for  boxed  values 

(values  stored  in  a  region).  Constructor  alternatives  (A)  are restricted  to  simple  patterns  (c  21  . . .  z:,)  with  one  variable 
for  each  constructor  parameter,  but  the  last  one.  (Pattern matching  cannot  be  used  to  retrieve  region  names.) 

The  syntax  of  MML's  types, 
u  ::=  Vk.a  1  vt.a  1  vp.a  1  Y 

u  ..- .a-  r'x  . . .  xr6w%  1  rx.0*x-rxp--+n 
7  ::=  t  1  p  1  [TX...  x  ~1~  1  Nat,  I  Size,  I  K. 
n  ..- ..-  T8.ms T.--rp 

P  ::=  {p+bn,...,p*n} 

S  ..- ..-  w  1  i 

i  ::=  k  1  n  1  n*i  1  i+i k E  SIZEVAR t  E TYPEVAR 

p  E REGVAR S, C#J, n  E NAT 

also  invites  a few  remarks.  There  are  three  kinds  of  polymor- phism:  in  size-  (Vlc),  type- 

(Vt),  and  region-variables  (VP). 

Polymorphism  is  restricted  to  function  or  constructor  types 

(u). 

Function  types  (~1  x  . . .  x  rn  "3'  r)  take  the  form  of a  mapping  from  a  tuple  of  types  rather  than  from  a  type; 

this  is  to  manifest  that  our  language  is  first  order.  Func- tion  arrows  are  labelled  with  the  three  kinds  of  effects  dis- 
cussed  above:  stack  effects  (b)  which  are  natural  numbers; put  effects  (p)  which  are  mappings  from  region  variables  to 

natural  numbers  ({PI  H  nl,  . . . , pn  I+  nk});  store  effects (4)  which  are  also  natural  numbers.  In  the  informal  devel- 
opment  above,  we  used  a  sugared  syntax  for  our  function types  and  wrote 

~1  x...xr%-+rwithS=ni;  p+=  n2;  q5=723 
rather  than  ri  x  . a .  x  rn  nl:iP"+2h~3  7. Constructor  types  (~1  x  ..  .  x  m  x  p  +  r)  have  the 
same  shape  as  function  types,  but  for  the  absence  of  effects. This  is  because  the  effects  of  a  constructor  application  are 
uniquely  determined  by  its  arity  and  the  effects  of  its  argu- ments. 

A  basic  type  (7)  can  be: A  standard  type  variable  (t),  or  a  region  variable  (p). 
A  tuple  type  ([ ri  x  . . .  x  r,  I,,)  composed  from  element- types,  as  usual,  but  here  also  from  a  region  variable  that 
specifies  where  the  tuple  is  stored. One  of  the  built-in  types  for  numbers 

(Nat,  and  Size,), covered  above. 

A  constructor  type  (K).  These  are  introduced  by  data- type  declarations.  The  general  form  of  a  constructor  type  is 
Tsl...+,  rl  . . . r,  p,  where  the  first  size  parameter  si  gives  the size  of  the  type,  and  where  s2 . . + sn  and  ri  . . . r,,,  are  actual 
size  and  type  parameters  (refer  to  [Par981  for  details);  the last  parameter  p  plays  the  same  role  as  in  tuple  types. 

A  size  expression  (s)  is  either  the  limit  ordinal  literal (u),  or  a  positive  integer  expression  (i).  Such  an  expression, 
in  turn,  is  either  a  variable  (Ic),  a  constant  (n),  a  linear multiplication  (n*i),  or  an  addition  (i+i).  This  form  of  size 

expressions  is  inherited  from  the  theory  of  sized-types,  which requires  that:  1)  all  size  expressions  are  strictly  monotonic 
in  all  their  size  variables,  and  that  2)  all  size  expressions  are linear  in  each  size  variable  [Par98]. 

The  syntax  for  declarations  is: 

D  ::=  Vlc.D  1  Vt.D  1  Vp.D  1  E 

&  ..- ..-  n=r 
r  ..- ..-  CT..`TP  1  ...  1  CT"`7P 

A  declaration  (D)  is  a,  possibly  quantified,  equality  (E)  be- tween  a  constructor  type  (K)  and  a  right:hand-type  (r);  a 
right  hand  type  is  a  sequence  of  tagged  type-sequences,  each with  a  trailing  region  type  (c  ri  . . . m  p). 

We  write  D  for  the  set  of  declarations,  and,  in  this  paper, take  this  set  to  be 

D  =  {  V  k a  r  , Listk+l  a  r  =  nil  r  1  cons  a  (Listk  a  r)  r  } 
3  The  Semantics  of  MML 
The  role  of  our  language  semantics  is  manifold,  and  we  must carefully  design  the  semantics  with  respect  to  all  its  intended 
uses:  the  semantics  are  used  to  reason  about  a  type  system with  stack  and  store  effects,  so  some  notion  of  a  stack  and 

73 

a  store  must  be  provided;  the  semantics  serve  as  a  specifi- cation  for  compilers,  so  it  must  be  designed  with  language 
implementation  techniques  in  mind;  the  model  is  used  in numerous  proofs,  so  it  must  be  mathematically  tractable. 

Under  these  three  requirements,  semantics  by  an abstract-machine  in  the  style  of  Landin  [Lan64]  has  turned 
out  to  be  a  suitable  choice.  By  adding  a  store  and.  a  few new  instructions  to  his  SECD-machine,  and  by  coalescing 
its  dump  and  stack,  we  get  a  semantic  model  that  satisfies these  requirements. 

3.1  The  Abstract  Machine 
An  abstract  machine  is  a  transition  system  between  machine states  M,  which,  in  MML,  take  this  form: 

A4  ::=  (V,S,E,C) 

V  ..- ..-  w:v  1  v 

V  ::=  n  1  ii  1  a  1  p  1  c  1  Cm 
a  ..- ..-  op 
S  ::=  {pi+  R,...,p++  R} 
R  .,- ..-  (0  +k  v,  . . . ) 0  I--) v}" 
E  ..- ..-  {x  c)  v,  . . . )X  I-+ v} 

C  ::=  L: c  1  call,  I  ret,  1  sretzEs  1  end 

L  ..- ..-  elo  I  eOze I  b  I  0"  I  77-n I  cn 

1  A.-.A  I  Xz.e  1  {jze 

0  E  NAT  p  E REGVAR 

A  machine  state  (M)  consists  of  a  value  stack  (V)  that  rep- resents  the  run-time  stack  of  a  language  implementation,  a 
store  (S)  that  represents  the  region  stack,  an  environment (E)  that  maps  program  variables  to  values,  and  which  has 

no  immediate  run-time  representation,  and  an  instruction sequence  (C)  that  represents  the  machine  instructions  in  an 
executable  program. A  value  (v)  is  either  a  natural  number  (n),  a  size  (ii),  an 
address  (a)  which  points  to  either  a tuple  or  a  constructor  in the  store,  a  region  identifier  (p)  which  can  be  thought  of  as  a 
reference  to  a region,  a  constructor  tag  (c),  or  a  continuation CES,  which  corresponds  to  a  return  address  in  an  activation 
record. An  address  (a)  is  a  pair  of  the  form  oP  where  p  is  a 
region  identifier  and  o  an  offset  in  that  region  (o  is  a  natural number). 

A  store  (S)  is  a  mapping  {pl  H  RI,.  . . , pk  c)  Rlc}  from region  variables  to  regions  (R),  which  in  turn  are  fixed-size 
mappings  {or  t+  vr,  . . . , ok  t-b  vk}=  from  offsets  to  values, where  k  must  not  exceed  n.  The  value  in  a  store  S  pointed 
to  by  an  address  oP  can  thus  be  expressed  as  S(p)(o).  We write  S+  {p  ti  R}  to  extend  a  store  with  region  R  identified 

by  p;  to  make  our  manipulation  of  stores  more  concise,  we introduce  the  syntactic  abbreviations  S(o,)  E  S(p)(,o)  and 

s  +  {OP t-)  v)  E  s  +  {p  I-+  S(p)  +  (0  I+  v}}. An  instruction  sequence  (C)  is  a  sequence  of  ordinary 
machine  instructions  (L)  followed  by  a  control  flow  instruc- 
tion  (callf  ,  ret,,  sretgEs  ,  and  end).  The  execution  of  an ordinary  instruction  will  remove  it  from  the  instruction  se- 

quence,  change  the  machine  state  according  to  the  instruc- tion,  and  then  execute  the  remainder  of  the  sequence.  The 
execution  of  a  control  flow  instructions  will  install  a  new instruction  sequence. 

We  devote  the  remainder  of  this  section  to  the  meaning of  these  instructions. 
3.2  Numbers  and  Variables 
All  expressions  in  our  language  also  constitute  machine  in- structions  that,  when  executed,  leave  one  value  on  the  value 

stack,  e.g., 

(V,S,E,n:C)  -+  (n:V,S,E,C) 
(V,S,E,x:C)  +  (E(x):V,S,E,C) 

3.3  Constructors 
The  execution  of  an  expression  is  typically  divided  into  a  se- quence  of  sub-computations  that,  together,  form  the  desired 

result.  To  execute  a  constructor  expression,  for  example,  we fist  execute  all  argument  expressions,  which  will  leave  a 

value  for  each  instruction  on  the  stack;  then,  we  execute an  instruction  that,  using  these  values,  will  -write  the  ma- 
chine  representation  of  the  constructor  to  the  store,  and  that will  leave  the  address  to  this  machine  representation  on  the 
value-stack: 

(V,S,E,cel.-.e,  e:C)  +  (V,S,E,el:...:e,:e:c":C) 
(p:v,:+*.  : VI  : V,  S, E,  cn : C)  -+  (oP : V,  S',  E,  C);  o  =  IS(P)~  I 

Is'  E  s  +  {op  b-b c}  +  { (0  +  i)p  +l  Vi} 

Here,  by  So  we  mean  the  domain  of  the  region  bound  to  p in  S,  and  by  IS(p),-,I  the  number  of  elements  in  this  set:  this 

gives  a  fresh  offset  in  the  designated  region  (assuming  that all  binding  offsets  in  S(p)  have  been  introduced  in  this  way). 
A  constructor  value  is  simply  represented  as  the  constructor tag  followed  by  the  argument  values.  The  address  left  on 
the  value  stack  will  point  to  the  first  word  of  this  sequence. 

3.4  Arithmetic  Operators 
The  rules  for  arithmetic  operations  are  straightforward,  e.g, 

(V,  S,  E,  el  +  e2 : C)  -3  (V,S,E,el:ez:+:C) 
(n:!:nl:V,S,E,+:C)  +  (nl  +nz:V,S,E,C) 

We  omit  the  rules  for  (-,*,i,  I,  and  g). 

3.5  Function  Calls 
At  the  abstract  machine  level,  a  function  call  can  be  divided into  1)  creation  of  a  continuation  to  use  the  computed  value, 

2)  evaluation  of  the  function's  arguments,  3)  creation  of  an environment  that  maps  the  formal  variables  of  the  function 
to  the  actual  values  of  the  call,  4)  execution  of  the  function's body  in  this  environment,  5)  removal  of  actual  parameters 
from  the  stack,  and  6)  execution  of  the  continuation.  The rules  to  accomplish  this  process  are: 

(V,  S, E,  f  el  . . . erL :C)  +  (CE.q:V,S,E,el:-,aa:e,:callf) 

(v,  : *.  . :7~1:C&:V,S,E',callf)  + 

(v,  : . . . :vI:CESJ:V,S,{~;  tivvi},ef:ret,) 

(v:wn:...  :v1:C&:V,S,E',ret,)  -+  (w:V,.S,E,C);  S'  c  S 

When  executed,  a  call-expression-instruction  (the  first  rule) pushes  a  continuation  on  the  stack,  and  places  the  argument 

expressions  plus  a  call  instruction,  callf  ,  in  the  instruction 

74 

sequence.  The  continuation,  CES,  consists  of  the  instruc- tion  sequence  following  the  call  plus  the  environment  and 

the  store  at  the  call;  the  continuation  must  carry  both  the environment  and  the  store,  because  the  environment  maps 
variables  to  values,  and  values  can  be  addresses.  To  cap- ture  the  store  in  this  way  is,  of  course,  not  realistic  in  an 
implementation,  so  we  play  the  following  trick:  we  only  al- low  continuations  to  be  reinstalled  in  machine  states  with  a 
store  larger  than  that  of  the  continuation  (the  side  condition of  the  third  rule  above).  In  our  semantics,  this  will  always 

be  the  case  so  a  language  implementor  can  forget  about  this condition;  we  need  it,  however,  for  our  proofs. 

The  execution  of  a  call-instruction  (the  second  rule)  cre- ates  the  new  environment  and  places  the  called  function's 
body  plus  a  return  instruction  in  the  instruction  sequence. To  allow  the  environment  to  be  implemented  using  indirect 
addressing  relative  to  the  top  of  the  stack  (a  standard  tech- nique),  We  leave  the  actual  parameters  on  the  stack. 

Return  instructions  (the  third  rule)  are  parameterised  on the  number  of  arguments  that  the  return-value  should  be  slid 
over  at  the  return  (sliding  is  another  standard  technique). In  addition  to  the  slid  arguments,  the  return  instruction 
removes  the  continuation  from  the  stack  and  reinstalls  its instruction  sequence  and  environment. 

3.6  Let-Bindings 
The  execution  of  a  let-expression  resembles  a  function  call in  many  ways;  it  involves  1)  computation  of  an  argument, 

2)  creation  of  an  environment  that  binds  this  value  to  a variable,  3)  creation  of  a  continuation,  4)  execution  of  an 
expression  in  the  new  environment,  5)  sliding,  and  6)  re- installation  of  a  continuation.  The  most  notable  difference 
is  that,  in  a  function  call,  the  continuation  is  a  dynamic object  (i.e.,  it  will  be  present  at  run-time),  whereas,  in  a 
let  expression,  a  continuations  is  a  static  object  (i.e.,  it  will only  be  present  at  compile  time): 

(V,S,E,letz=eine':C)  +  (V,S,E,e:Xz.e':C) 
(v:V,S,E,Xz.e:C)  +  (w:V,S,E+  {x  k+  v},e:sretF) 

( u:vn:--  .:vl  : V,  S, E',  sretE@)  +  (u:V,S,E,C);  S'C  S 
Here,  the  instruction  Xx.e  provides,  Yn-line"  functions,  and 
the  instruction  sretz=  static  returns.  Note  that  the  body of  a  lambda-instruction  is  an  expression,  not  an  instruction, 

so  nested  lambda  expressions  can  never  arise. 

3.7  Letreg 
Letreg  expressions,  in  turn,  resemble  let-expressions,  but there  are  two  important  differences:  1)  the  life  and  death 

of  a  new  region  is  involved  in  their  executions;  2)  the  ex- pression  computed  first  will  not  itself  be  bound  to  the  intro- 

duced  variable,  but  used  to  determine  the  size  of  the  created region  -  what  is  bound  is  a  reference  to  this  region.  The 
rewrite  process  uses  the  region-creation  instruction  {}=  and the  region-destruction  instruction  p: 

(V,S,  E,letreg  x#e  in  e':C>  -+  (V,S,  E,e:{},  e':C) 
(fi:V,  S, E,  Oz  e:  c)  +  (p:V,S',E',e:p:sret~~);  p$!  SD 
s'%9+{pc,{}"+`};  E'=E+{xc,p} 

(w:p:  V,  S,  E,  4:  sretp'S')  +  (v:p:  V,  S\p,  {},  sretprs') 

By  SD  above,  we  mean  the  domain  of  S,  and  by  S\p  we mean  {p'  ,c)  R  E  S  1 p'  #  p}. 
3.8  Tuples  and  Tuple  Projections 
The  tuple  construction  process  is  almost  identical  to  that  of constructors;  the  absence  of  a  leading  constructor  name  in 

the  representation  is  the  only  difference: 

(V  S, E,  (el,.  . .ren)e:C)  -+  (V,S,E,el:--.:e,:e:()m:C) 
(p:v,:**.  : VI  : v,  s,  E,  ()"  : C)  -b  (c$  : V,  S',  E,  C);  0  =  IS(p)DI 

S'rS+{(o+i-1),~wvi} 

Given  this  representation,  tuple  projection  is  trivial: 

(V,S,E,r;  e:C)  +  (V,S,E,e:ri:C) 
(op:V,S,E,ri:C)  +  (S(p)(o+i-l):V,S,E,C) 

3.9  Case  Exppessions 
The  execution  of  a  case  expression  essentially  follows  that for  a  let-expression,  except  for  some  added  control  flow,  and 

a  decrement  or  decomposition  of  the  tested  expression.  For numeric  case,  the  transition  rules  are 

(V,S,E,caseeofO+el  [a:+l+ea:C)  + 

(V,S,E,e:el[,ez:C) 
(O:V,S,E,el  0% ez:C)  +  (V,S,E,el:C) 

(v:V,S,E,el  no es:C)  -+  (v  -  l:V,S,E',ez:sretyES) 

EkE+{xc,w-1) 

The  instruction  el  oZ ea  is  called  the  branching  instruction. The  rules  for  constructor-case, 

(V,S,E,caseeof  A...A:C)  +  (V,S,E,e:A.+.A:C) 
(o,, : V,  S, E,  {G  ~1  . . . mini  +  ei}  : C)  + 

(vn,  :.  . . :vl:V,S,E',ek:sretzr) 
CAT =  S(op);  vj  3  S((~+j)p);  E'  E  E  +  {~kj  C)  uj} 
are  essentially  the  same:  the  case-alternative  instruction A1.u.  A,,  which  we  also  write  as,  {ci  zii  . . . mini  +  ei}  is  a 

generalisation  of  el  I2  e2:  the  test  refers  to  the  store  rather than  to  the  stack;  decomposition,  as  in  the  rule  for  tuple- 
projection,  has  replaced  the  decrement. 

4  A  Type  System  with  Space  Effects 

A  type  and  effect  system  is  a  type  system  that,  in  addition to  a  type,  associates  a  collection  of  observable  side  effects 
with  each  node  of  a  derivation  tree.  In  MML,  there  are three  kinds  of  effects:  stack  effects  (a),  put  effects  (p),  and 

store  effects  (0).  In  this  section,  we  shall  formulate  the  type system  that  lets  us  infer  these  effects;  we  start  with  a  few 
standard  definitions  and  then  proceed  to  the  actual  rules. A  type  assignment  I'  is  a  set  of  basic  typing  statements 

of  the  form  z  ::  r;  a  function  type  assignment  F  is  a  set  of function  typing  statements  of  the  form  f  :: u.  By  l?,x  ::  r 
we  refer  to  the  set  {z  ::  r}  U  {z'  ::  7'  E  I'  1 z'  #  z},  and similarly  for  F,  f  :: CT. A  typing  judgement  is  a  7-tuple  of  the 
form 

l?  b  e :: T!  6;  pi  4 

75 

where  e,  r,  6,  p,  and  4  are  given  by  the  grammar  in  section 2.3.  A  typing  judgement  is  said  to  be  valid  if  it  is  derivable 
using  the  inference  rules  of  the  type  system. A  subtyping  judgement  is  a  pair  of  the  form  ri 

D  '~2,  read as  7-1 is  a subtype  of  72,  or  of  the  form  v  D  Y'  read  similarly. 

A  subtyping  judgement  is  valid  if  it  can  be  derived  using  the subtype  inference  rules  of  the  type 

system. The  set  of  valid  typing  judgements  for  MML  is  given  by 

the  rules  in  appendix  A;  we  devote  the  remainder  of  this section  to  their  principles. 

4.1  Typing  Numbers 
As  we  have  already  seen,  the  size  of  a  natural  number  is  one plus  its  value,  so  the  best  type  we  can  give  a  number  n  is 

Nah+l.  For  sizes,  the  size  of  the  type  is  always  that  of  the number  itself,  i.e,  ii  ::  Size,.  Evaluation  of  any  expression 
-  numbers  in  particular  -  will  push  one  element  on  the 

value  stack,  so  for  numbers,  6  =  1;  there  are  no  side  effects in  the  store,  so  p  =  8  and  4  =  0: 

r  b  n  ::  Natn+l  !  1;  (1;  0  I?  I-  ii  ::  Size,  !  1;  {};  0 
Because  the  size  s  of  a  type  Nab  is  an  upper  bound  on  the sizes  of  the  elements  in  the  type,  we  can  also  give  n  any  type 

Nat8  such  that  n  +  1  5  s.  A  number  6,  however,  can  only have  type 

Size,,  hence: 

Nat,,  D  Natsz  Sl  I  32  Sizes  D  Sizes 
4.2  Typing  Constructors 
From  the  set  of  declarations  D,  one  can  easily  derive  a  set of  constructor  type  assumptions  C.  For  our  declarations  we 

get 

C  =  {nil  ::  Va  r  . r  +  List1  a r, 

cons  ::  V  k a  r . a  x  Listk  a  r  x  r  +  Listk+l  a  r} 

The  effects  of  a  constructor  application  are  given  by  the  rule 

c  ::  7-l  x  ...  xmxp+K  7;  D  ri  (vi) 

I?  $  ei  ::  7-i  !  6i;  pi;  q&  (Vi)  JT  IF  e  ::  p  ! &+I;  p,+l;  #h+l r 

bcCel--.e,  e  :: K!!;  p; 95 

When  ei  is  evaluated,  no  value  has  been  pushed  on  the  stack, when  e2  is  evaluated  one  value  has  been  pushed,  etc.,  hence 

the  definition  of  6. The  put  effect  p  is  the  cumulative  put-effect  of  all  sub- 
expressions,  plus  the  effect  of  writing  1 +  n  values  to  p  (1 for  the  c,  and  n  for  the  `ui's  -  recall  the  representation  of 

constructors  ).  Let  pR  denote  the  range  of  the  effect  p;  the sum  of  two  effects  is 

P+P'={P(P)+~`(P)  I PE  ~RUP'R)) 
The  store  effect  4  is  simply  the  maximum  store  effect  of  any sub-expression. 

4.3  Typing  Function  Calls 

The  type  inference  rule  for  function  calls, 

r  b  f  ::  Tl  x  .  .  x  rn  6n+1'  p?$l'  hi-l  7 
r  bei  ::  7;  ! 6;;  pi;  lq!Ji  (Vi>  T,!  D  ?-i  (vi) r 
bfe1.e.  e,  :: r!  1+~~;-+1'(i-l+ai:r;  Zipi;  lJi& 

is  straightforward.  In  contrast  to  constructors,  the  effect  of a  function  call  is  derived  from  the  function's  type.  Notice 
that  the  stack  effect  accounts  for  an  activation  record  on the  stack  (return  address  plus  actual  parameters)  during 
the  call. 

4.4  Typing  Letreg 
Any  excesses  in  space  use  are  effectively  trapped  at  the  letreg rule.  It  checks  that  the  put  effect  of  the  region  it  introduces 

is  less  than  or  equal  to  the  size  assigned  to  the  region: 

r  $ e  :: Sizes  ! 6;  p;  4  r, 5 :: p  IF e'  :: T  ! 6';  p';  4' r 
bletregz#eine'  :: T  ! S Ll (1  +  6');  p+p'\p;  4  U  (s  +  1+  d') 

The  put  effect  of  the  local  region  p  should  not  be  visible outside  the  letreg-expression,  so  it  is  removed  from  the  effect 
set  p'.  To  account  for  the  allocations,  the  size  of  the  region's frame  (s+l)  is  added  to  the  store  effect  of  the  expression  that 
uses  it. The  side  condition  p  @ FV(I',  7)  prohibits  deallocations 
that  introduce  dangling  pointers,  e.g. 

let  a  =  letreg  s#3  in  (1,  l)Z  in  ~1  a  +  TZ  a 

4.5  Typing  Case  Expressions 

Two  aspects  of  the  numeric  case  rule, 

6  E  60 u  61 u  (1  +  62);  p  =  po  +  ($1  u  p2);  9  =  fJi  4i 

I?  IF  e  ::  Nat,+1  ! SO;  PO;  40 r  IT 

el  :: 71 ! bl; pl;  C#II 
IT, x  ::  Nat,  IF  e2  ::  r2  ! 82;  pp;  q52  pi  D  T  (Vi) r  tg7 

case  e of  0  +  el  0 x  +  1  +  e2  ::  7  ! 6;  p;  4 

are  worth  notice:  1)  The  binding  of  the  pattern-variable  in the  second  branch  (x)  requires  one  word  of  stack  space.  The 
rule  accounts  for  this  by  adding  one  to  the  stack  effect  of  the expression  in  the  second  branch.  2)  The  potential  effects  of 

the  two  branches  have  to  be  merged  in  some  way;  we  do  SO by  taking  their  least  upper  bound: 

P u  P'  =  {P(P)  u  P'(P)  1 P  E  (PR  u  P'R)  1 
The  typing  rule  for  constructor-case  is,  essentially,  a  gener- alisation  of  that  for  numeric-case.  (See  app.  A.) 

4.6  Typing  Function  Definitions 
It  remains  to  relate  the  function  type  assignment  F,  that occurs  in  the  typing  judgements  for  expressions,  to  the  func- 

tion  definitions  of  a  program.  For  this  purpose,  we  introduce four  new  kinds  of  judgements:  F  E  d  ::  v  for  basic  func- 

tion  definitions,  F  E  g  !+  F  for  recursive  groups  of  such, 

76 

g  e  F  for  sequences  of  such  groups,  and  P  :: r  ! 6;  p;  C$ for programs. 

The  inference  rule  for  the  first  kind  of  judgements, 

22  :: 71,.  . . ,zn  :: 7n  b  e :: T  ! 6;  p;  C# 
F  I-  f21..-zn=e  ::  T~XX-.XT~~`J$~T 
is  trivial,  but  the  one  that  uses  it, 

F,  fi  :: Ol[k],  . . . , fn  :: bn[k]  t-  fi  Zi  =  ei  :: Y,! (Vi)  u~[o]  =  U  (Vi) 

Ft{fiZi  =  ei)  K-  F,fi::Vlc.al[k~,...,f~::tlrE.~~[k] 

is  more  involved.  To  guarantee  termination,  the  rule  has the  same  built  in  induction  principle  as  the  letrec-rule  of 

the  sized  type  system  (see  [HPS96,  Par981  for  details). The  second  premise  in  the  rule  for  mutual  recursion 

(FV(Vk.cri[kl)  =  0)  states  that  the  type  schemes  introduced by  the  rule  must  not  contain  free  variables;  this  is  to  preserve 
the  invariant  "F  contains  no  free  variables"  which  makes  the usual  side  condition  for  generalisation  -  a  generalised  vari- 
able  must  not  occur  in  the  type  assignment  -  trivial. The  third  and  fourth  premises  together  form  the  induc- 
tion  step.  They  generalise  the  idea  that  the  body  of  a  func- tion  f  ::  Vk.  b[k]  should  have  type  f  :: 

b[k+l]  under  the assumption  f  :: cqk]. 

The  last  premise  of  the  rule  (uilol  =  U)  constitutes  the base  case  of  the  built  in  induction  proof.  The  predicate  =  U 
(see  appendix  A)  holds  for  universal  types,  i.e.,  types  that denote  all  values. 

5  Discussions 
5.1  Correctness  of  the  Type  System 
The  following  property  of  MML  has  been  proved:  if  a  pro- gram  is  well-typed  with  the  stack  effect  b  and  the  store  effect 

4,  then  the  program  will  use  at  most  S +  4  words  of  memory (neither  counting  the  words  necessary  to  store  the  program, 
nor  the  machine  registers). The  first  step  of  this  proof  is  to  introduce  a  notion  of 
size  for  machine  states,  written  ]M],  which  is  defined  as  the height  of  the  stack  plus  the  sum  of  the  sizes  of  all  region 
frames: 

I(K s, E, C>l  =  VI  + ISI 1211 :..-:wnl  = 

n 

ISI  =  &SD  IS( 
I(01  Ih?Jl,...,Ok  t)Wk}rrl  =  n 

Environments  (E)  and  instruction  sequences  (C)  are  com- pile  time  objects,  and  are  thus  not  included  in  the  size. 

The  second  step  is  to  introduce  a type  system  for  machine states,  in  which  both  the  stack  and  the  store  are  assigned 
types.  The  syntax  for  the  types  in  this  system  is 

x  ::=  e  @  A 8  ::=  v:e  1 v 

V  ..- ..-  TIC 

C  ..- ..-  X2-$X 
A  ::=  (pmP,...,pmP) 

77  E  NAT  ~LENAT 

A  machine  type  (X)  consists  of  a  stack-type  ((3) and  a  store- type  (A),  where  a  stack-type  is  a  sequence  of  value  types 

(V)  which  in  turn  are  either  basic  types  (T)  or  continuation 
types  (Cl. 

A  continuation  type  is  of  the  form  Xi  G  Xz,  where  Xi  is the  type  of  the  machine  state  that  the  continuation  expects, 

XZ  the  type  of  the  state  that  it  returns,  and  q,  $  the  absolute stack-  and  store  effects  (6  and  4  are  relative  effects). 

A  store-type  (A)  is  a  mapping  {pr  t)  uy',  . . . , pk  ti ui"}  from  region-variables  (pi)  to  pairs  un,  where  n  denotes 
the  size  of  the  region  frame  and  u  the  allocations  in  it. The  third  step  of  the  proof  is  to  define  the  notion  of  a 
well-typed  machine  state  using  five  new  typing-judgements: for  stacks  (S  l-  V::8),  for  stores  (S  ::  A),  for  environments 

(S  +  E  :: I'),  for  instruction  sequences  (I  I-  C  :: 8  @  A  %$ X),  and  for  machine  states  (M  ::  X  !  7;  @).  We  omit  the 
inference  rules  for  the  first  four  judgements,  and  just  look at  the  rule  for  a  well-typed  machine  state: 

stv::eo  S::A,  Sl-E::l?  rtc::eo  @J Aow  X 

(V,S,E,C)  :: X!  q;  + 

A  typing  M  ::  X  !  q;  2c, tells  us  that  the  machine  state M,  when  executed,  will  reduce  to  a  state  of  type  X  (cf., 

e  ::  Natw,  which  tells  us  that  e  will  reduce  to  a  natural number.) 

The  fourth  step  of  the  proof  is  to  show  that  the  size  of  a well  typed  machine  state  is  less  than  or  equal  to  the  sum  of 
its  stack  and  store  effects,  i.e,  if  M  ::  X  ! q;  $  is  valid,  then IN  Iv++. 

The  fifth  step  is  to  prove  subject  reduction,  i.e,  if  M  :: X  ! q;  1c, is  valid  and  M  +  M'  , then  M'  :: X  ! 7;  $. 
Together  with  a  notion  of  initial  machine  states,  the  last two  statements  let  us  infer  the  desired  result:  let  MO  be  the 
initial  machine  state  for  the  expression  e;  if  P  ::  7  ! S;  p;  4 is  valid  and  MO  +  . . . -+  Mn,  thenVi.]Mi]  sS+@. 

A  thorough  presentation  of  the  proof  is  beyond  the  scope of  this  paper;  a  correctness  proof  for  an  extended  version  of 
the  type  system  will  appear  in  the  first  authors  forthcoming PhD-thesis. 

5.2  Termination 
The  statement  of  the  last  section  tells  us  that  a  well  typed program  runs  in  constant  space,  but  does  not  mention  termi- 

nation.  However,  MML's  type  system  being  a  strengthening of  the  sized  type  system  (which  does  guarantee  termination) 
we  have  strong  reasons  to  expect  that  the  desired  termina- tion  proof  can  be  established.  This  appr.oach  includes  the 
development  of  a  denotational  model  for  MML,  and  a  proof that  our  abstract  machine  correctly  implements  this  model. 
Another  approach  would  be  to  re-develop  the  theory  of  sized types  in  an  operational  setting. 

5.3  Implementation  of  the  Type  System 
The  type  system  described  in  this  paper  has  not  been  im- plemented,  but  its  predecessor,  the  sized-type  system,  has 

been  given  an  efficient  implementation  [Par98];  there  is  no evident  reason  why  our  extended  type  system  could  not  be 
implemented  using  the  same  techniques. The  potential  complication  of  the  extension  would  be 
subtyping  constraints  harder  to  solve  than  before.  In  the 

77 

sized  type  system  the  constraints  reduce  to  Presburger- Arithmetic  formulae,  which  we  solve  using  the  omega 
test  [Pug92].  We  expect  this  to  be  possible  also  in  the  pres- ence  of  stack-  store-  and  put-effects. 

5.4  Implementation  of  the  Run-Time  System 
The  run-time  system  of  MML  has  not  been  implemented either,  but  as the  abstract  machine  has  been  designed  with 

conventional  compiler  implementation  techniques  in  mind, we  expect  an  implementation  to  be  routine. 

Let  us  look  at  the  intended  run-time  representa,tion  of machine  states  (V, S, E,  C): 
The  value  stack  (V)  is  implemented  using  the  CPU's stack-pointer  as  usual,  and  the  store  (S)  using  a  separate 
region  stack  pointer. The  environment  (E)  of  a  machine  state  mirrors  values 
stored  on  the  run-time  stack,  but  has  no  run-time  represen- tation  in  addition  to  this. 

The  instruction  sequence  (C)  is represented  by  a program counter  that  points  into  a  sequence  of  CPU-instructions 
which  has  been  generated  by  the  compiler. To  avoid  tagging,  a  value  (u)  is  represented  using  one 
machine  word  only:  a  number  (n  or  ii)  is  represented  by  an unsigned  integer;  an  address  (o,,)  by  a  pointer  that  points 
directly  to  the  tuple-  or  constructor-representation  that  the address  represents;  a  region  (p)  by  a  pointer  to  a  region 
frame;  a constructor  tag  (c)  by  an  integer  constant;  a contin- uation  (CES)  by  a code-pointer.  (There  is  no  run-time  rep- 
resentation  for  environments  in  continuations,  nor  for  their stores  -  recall  our  discussions  in  sec.  3.5). 

To  verify  that  a  compiler  actually  can  be  implemented along  these  lines  -  we  might  have  overlooked  something  in 
our  design  of  the  abstract  machine  -  is  future  work. 

5.5  Trading  Efficiency  for  Predictability 
The  semantics  of  MML  is  very  explicit  about  evaluation  or- der,  the  size of representations,  the  layout  of the  stack  and  so 

on.  These  are factors  which  optimising  compilers  often  vary, for  example  changing  evaluation  order  to  improve  register 
utilisation.  An  MML  compiler  must  not  make  such  trans- formations,  because  they  could  invalidate  the  space bounds 
which  our  type  system  guarantees.  We  must  therefore  ex- pect  MML  programs  to  run  somewhat  more  slowly  than 
those  in  other  languages. We  do  not  consider  this  to  be  a  serious  problem.  Our 

intended  application  domain  is  one  where  space  bounds  are essential,  and  we consider  some loss of  performance  to  be an 
acceptable  price  to  pay. 

5.6  Tail  Recursion 
A  well  known  technique  to  make  recursive  programs  use less space is to  distinguish  tail  calls  from  arbitrary  function  calls, 

and  to  exploit  the  fact  that  tail-calls  can  be  implemented more  efficiently.  This  technique  is  of  particular  importance 
in  the  context  of  embedded  programming,  so in  this  section we  shall  study  how  it  can  be  added  to  MML. 

The  idea  is  to  avoid  chains  of  continuations  in  which  a continuation  just  passes  its  parameter  on  to  the  next.  To 
avoid  such  chains  is  to  save  stack-space,  because  continua- tions  are  represented  using  the  stack. 

The  function  calls  that  give  rise  to  such  chains  can  be syntactically  identified  using  a notion  of 

tail  expressions:  the 

body  of  a  functio:n  definition  is  a  tail  expression;  if  a  case- expression  is a tail-expression,  then  so are the  expressions  of 
its  branches.  If  a function  call  (f  e.  . . e)  is a tail  expression, then  it  can  be replaced  by  a  tail  call  (fn  e.  . . e): 

d  ..-. ..-.  f  x-.*x  =  b 

b  ..-. .,-.  f n  e.,  .e  1  caseeofO-+b[z+l+b  1  e 

Tail  calls  carry  an  environment-size  n  -that  is  used to  discard the  environment  in  which  the  tail-call  occurs.  For  example, 
in  the  tail  recursive  version  of  fuc, 

fucan=casenofO+u[z+1+&3(n*u)z 
the  environment  size  is  3,  for,  at  the  call,  the  environment binds  a,  n,  and  x. 

We  make  tail-calls  explicit  for  the  same  reason  as  we made  storage  management  explicit:  we believe  that  the  em- 
bedded  programmer  wants  this  explicit  control. To give  meaning  to  our  new  construct,  we extend  the  call- 
instruction  of the  abstract  machine  with  an environment-size to  become  call?,  and  then  introduce  two  new  rules: 

(V,S,E,  fk  el-.+e,:C)  +  (V,S,E,el:.--:e,:callF) 
(u,  :.  * ' : 211 : w: :.  . . :vk:C&:V,S,E',call~)  + 

(v,  :.  . . :v~:C~~:V,S,  {xi  I-+ vi},bf:r&) 

Here,  the  number  n  in  the  second  rule  is  t'he  arity  of  the function  f,  which  we,  as with  its  body,  take  to  be  globally 
known. We  must  also  extend  our  rule  for  ordinary  function  calls 
with  respect  to  our  extended  instruction: 

(K  S, E,  f  el  ...e,:~)  +  (CES:V,S,E,el:...:e,:callof) 

To  type  programs  with  tail-calls,  we  introduce  a  new judgement,  P  bg  b  ::  r  !  6;  p;  (p, that  accounts  for  the 

number  of  variables  in  the  environment  (n)  The  inference rules  for  this  judgement  (which  we  omit)  assert  that  the 
appropriate  number  of  values  are  removed  from  the  stack  at any  tail-call. 

In  the  extended  system  we  can  give  fat  the  type 

f ac  ::  Vk.  Nat,  x  Natk  3ao  Nat, 
i.e,  a  type  in  which  the  relative  stack  effect  is  three  words regardless  of  the  recursion  depth. 

5.7  Region  Resetting 

A  fundamental  problem  with  the  letreg-construct  is  that  it only  allows  for  regions  with  nested  lifetimes,  and,  thus,  is 

ill-suited  for  computations  in  which  data-lifetimes  overlap, e.g.,  insertion-sorting  using 

sort  23 d r  =  case  23  of 

nil  +  nil  T 
cons  x  s  +  letreg  t#Z  in  insert  x  (sort  s  1 t)  r 

insert  a  xs  r  =  case  23  of 

nil  -+  nil  r 
cons  2  s  -b  cons  (min  CL x)  (insert  (mtax  a  x)  s  r)  r 

78 

At  each  recursive  call,  the  function  sort  creates  a  temporary region  to  store  the  sorted  tail  of  its  argument  list.  These 

lists  start  their  lives  at  the  call  to  insert,  after  the  evalu- ation  of  the  actual  parameters,  and  end  their  lives  at  the 
returns  from  this  call.  But  the  regions  to  hold  these  lists start  their  lives 

before  the  evaluation  of  the  sctuals.  This leads  to  a  complexity  of  O(n')-space  (where  n  is  the  length 

of  the  list)  rather  than  O(n)-space,  which  one  would  expect from  a  sorting  function.  (It  is  worth  noting  that  the  pro- 

gram  above  would  not  even  be  typable  in  MML,  because  of the  restriction  to  programs  with  linear  space  behaviour.) 

To  get  around  this  problem,  we  extend  our  language  with a  construct 

reset  e 
that,  given  a  reference  to  a  region,  returns  the  same  refer- ence,  but  with  the  side-effect  of  resetting  this  region's  region- 
offset  to  0: 

(V,S,E,reset  e:C)  -+  (V,S,E,e:reset:C) 
(p:V,S,E,reset:C)  +  (V,S\p+{pti  {}`"`""},E,C) 

With  this  extension,  we  can  rewrite  sort  to  run  in  linear space,  by  using  two,  alternately  reset,  regions: 

sort  23  r1  r2  =  case  x-s of nil  -+  nil  r2 

cons  x  8  +  insertx  (sorts  r2  rl)(resetr2) 
With  the  addition  of  this  construct,  our  type  system  needs a  new  kind  of  put  effect,  called  reset  effect,  that  takes  the 

form  of  a  triple 

where  a,  b,  and  c  denote  the  number  of  allocations  before, between,  and  after  any  resets  in  the  program.  The  put  ef- 
fects  of  programs  without  resetting  will  be  natural  numbers as  before.  For  example,  the  put  effect  of 

let  z  =  (3,4),  in 
let  y  =  (7r2  x,  m  xLeset  r  in let  x  =  (5,  ~1 y  +  ~2 v)~  in  z 

isr+=  21014. The  only  extension  of  our  type  system  necessary  to  han- 

dle  such  effects  is  a  new  rule  for  the  reset  construct,  and an  extension  of  the  operator  +  in  the  type  system  to  apply, 
also,  to  reset  effects.  We  omit  the  details  of  this  extension. To  retain  our  guarantees  about  termination,  we  must 

prevent  resetting  of  regions  that  contain  live  data,  eg,  the program 

let  2  =  (3,44),  in  let  y  =  (z,  4)resetr  in  nl(7r1  9)) 
should  be  illegal,  whereas  the  same  program,  but  with  7rz y as  body,  should  be  allowed. 

For  this  purpose,  we  introduce  a  type  based  region  live- ness  analysis  in  which  the  types,  by  the  use  of  a  universal 
type  U,  indicate  any  dangling  references,  e.g.,  y  in  the  pro- gram  above  would  have  type  [U  x  Nat5  lp,  ~1  y  the  type  U, 

and  7ri(ni  y)  would  not  be  typable.  The  definition  of  this type  system  is  beyond  the  scope  of  this  paper. 

5.8  References  and  Assignment 
We  would  like  to  add  references  and  assignment  to  MML, to  show  that  we  can  also  guarantee  space  bounds  for  im- 

perative  programs,  but  unfortunately  this  is  not  straight- forward.  References  are  already  a  `bad  case'  for  Tofte  and 
Talpin's  region  type  system,  which  cause  programs  to  use unexpectedly  much  memory,  and  of  course  this  is  reflected 
in  the  space  bounds  we  can  obtain. The  problem  is  that,  since  all  values  stored  in  a  reference 
must  have  the  same  type,  then  they  must  also  reside  in  the same  region.  This  region  must  therefore  have  a  lifetime  at 
least  as  long  as  that  of  the  reference,  and  so  no  value  stored in  a reference  can  be  deallocated  until  the  reference  itself  has 

been.  For  example,  every  value  stored  in  a  counter  must be  retained  until  the  counter  itself  is  deallocated.  This  is 
certainly  not  the  behaviour  the  programmer  intends. Interestingly,  very  similar  problems  arise  with  lazy 
datatypes  such  as  streams,  and  with  constructions  for  ex- plicit  concurrency  such  as  communication  channels.  The 
elements  of  a  lazy  stream,  or  the  values  passed  over  a  chan- nel,  must  naturally  all  have  the  same  type.  Therefore  they 
must  all  be  allocated  in  the  same  region,  whose  lifetime must  then  be  longer  than  that  of  the  stream  or  channel 
respectively.  This  prevents  us  deriving  space  bounds  for networks  of  processes  that  run  continuously,  which  is  unfor- 

tunate  since  these  are  common  in  embedded  systems. Here  we  see  the  same  problem  recurring  in  different 
guises,  which  is  not  so  surprising  considering  that  lazy streams  and  channels  can  both  be  implemented  in  terms  of 
references.  One  possible  solution  is  to  use  region  resetting, as  in  the  last  section;  this  is  how  the  problem  is  handled 

in  Tofte's  work.  We  are  also  investigating  `cyclic  regions', which  behave  as  circular  buffers,  and  an  effect  system  to  ver- 
ify  that  values  are  dead  by  the  time  they  are  overwritten. This  would  spare  the  programmer  the  need  to  reset  regions 
explicitly. 

5.9  Higher-order  Functions 
One  of  the  great  strengths  of  functional  languages  is  their support  for  higher-order  programming,  which  is  just  as  use- 

ful  in  embedded  programs  as  in  any  other.  But  MML  as  we have  defined  it  is  a  first-order  language.  However,  we  see 

no  great  difficulties  in  extending  our  type  system  to  handle function  values  also;  type-and-effect  systems  usually  work 
well  for  higher-order  languages. The  only  awkwardness  is  that  the  effect  of  a  X-expression 

must  specify  how  many  words  are  allocated  to  hold  the  rep- resentation  of  the  function  value.  If  we  represent  functions 

closures  containing  a  code  pointer  and  the  values  of  the  free variables,  then  the  typing  rule  for  X  would  need  to  specify 

exactly  which  variables  are  built  into  the  closure  represen- tation.  This  is  both  awkward  and  perhaps  hard  for  the 
programmer  to  predict. We  are  therefore  planning  to  introduce  higher-order  func- 
tions  via  an  explicit  partial  application  construct  instead: for  example  f(z,  Y)~  would  denote  the  partial  application  of 

top-level  function  f  to  arguments  x  and  y,  and  it  is  easy  to see  that  the  representation  occupies  three  words  in  region  r. 

5.10  Real  Time 
Not  only  does  a  region  based  run-time  model  let  us  prove that  a  program  runs  in  constant  space,  but  it  also  paves 

79 

the  way  for  functional  programming  with  hard  real-time constraints:  it  eliminates  the  problem  of  garbage  collec- 
tion  present  in  traditional  implementations  of  functional  lan- guages  . 

[HPSSG]  John  Hughes,  Lam  Pareto,  and  Amr  Sabry, Proving  the  correctness  of  react:ive  systems  us- 

ing  sized  types,  POPL  `96,  January  1996. 
We  expect  that  we,  in  a  way  similar  to  our  use  of  sized  [Lan64]  P.  J.  Landin,  The  Mechanical  Evaluation  of  Ex- types  to  guarantee  execution  in  bounded  space,  will  be  able  pressions,  Computer  Journal  6  (1964),  no.  4, 
to  use  sized  types  to  guarantee  execution  in  bounded  time.  308-320. 

5.11  Type  Inference 
Once  we  know  that  type  checking  for  MML  is  feasible,  an immediate  question  is  whether  type  inference  would  be  fea- 

sible  too?  While  this  may  be  so,  there  are  a  number  of difficulties  to  be  overcome.  The  type  system  possesses  sub- 
typing,  which  most  likely  would  lead  to  incomprehensible  er- ror  messages,  and  polymorphic  recursion,  which  is  generally 
hard;  moreover,  inferring  size  formulae  is  a  harder  problem than  the  already  difficult  problem  of  checking  Presburger- 
arithmetic  formulae  for  truth. A  half-way  house  would  be  to  make  the  programmer  de- 
clare  function  types,  but  automatically  infer  their  effects, thus  relieving  the  programmer  of  the  need  to  explicitly  ex- 
press  the  memory  usage.  We  believe  this,  at  least,  would  be feasible. 

6  Conclusions 
We  have  presented  a  core  programming  language  that  guar- antees  termination  and  execution  in  bounded  space,  that 
allows  user-defined  recursive  functions  and  dynamic  data- structures,  and  that  does  not  rely  on  garbage  collection. 
The  language  is  a  strict,  first  order,  functional  language, with  non-standard  constructs  for  storage-management. 

Termination  and  execution  in  bounded  space  is  guaran- teed  by  a  type  and  effect  system  that  combines  Tofte  and 
Talpin's  region  types  [TT97]  with  the  sized  types  of  Hughes, Pareto,  and  Sabry  [HPSSG]. 

A  correctness  proof  for  the  type  system  has  been  out- lined,  but  not  presented  in  detail:  the  correctness  of  the  type 
system  is,  for  termination  by  the  observation  that  the  type system  is  a  strengthening  of  the  sized  type  system,  and  for 

execution  in  bounded  space  by  a  classical  subject-reduction proof  using  abstract  machine  semantics. 

Acknowledgements 
We  would  like  to  thank  Fritz  Henglein  who  ignited  this work  and  Mads  Tofte  who  encouraged  us  to  take  it  further. 

Thanks,  also,  to  Jorgen  Gustavsson  for  helpful  discussions on  abstract  machine  semantics,  and  to  the  anonymous  re- 
viewers  for  their  many  remarks  and  suggestions. 

References 

[AVW93]  Joe  Armstrong,  Robert  Virding,  and  Mike Williams,  Concurrent  programming  in  erlang, 

Prentice  Hall,  1993. 
[HCRPSl]  N.  Halbwachs,  P.  Caspi,  P.  Raymond,  and  D.  Pi- laud,  The  synchronous  dataflow  programming 

language  Lustre,  Proc.  IEEE  79  (1991),  no.  9, l.305-1320. 

[Par981  Laxs  Pareto,  :%zed  types,  Licentiate  the- sis,  Chalmers  U:niversity  of  Technology,  1998, 

(http://www.cs.chalmers.se/Np;treto/lic.ps). 
Pg921  William  Pugh,  A  practical  algorithm  for  exact array  dependence  analysis,  Communications  of 

the  ACM  35  (19!32),  no.  8,  102-114. 
[TBE+]  Mads  Tofte,  Lars  Birkedal,  Martin  Elsman,  Niels Hallenberg,  Tommy  Hojfeld  Olesen,  Peter  Ses- 

toft,  and  Peter  Bertelsen,  Programming  with  re- gions  in  the  ML  Kit,  Tech.  Report  DIKU-TR- 
97/12,  University  of  Copenhagen. 
[TT97]  Mads  Tofte  and  Jean-Pierre  `l'alpin,  Region- based  memory  management,  Information  and 

Computation  132  (1997),  no.  2,  109-176. 

80 

A  Type  System 

I'  b  n  ::  Nat,+1  ! 1;  {};  0  r  I-  ii  :: Size,  ! 1;  {);  0  I?,$  :: 7  tp x  ::  7  ! 1;  {};  0 

c  ::  TlX...  xr,xp+lc  r  IF ei  :: 9-l ! &;  pi;  q& (Vi)  I?  IF e :: p  ! &+I;  pn+l;  &+I  T;  D  ?-i (t/i) 

I?  IF c  el  .*-en  e  ::  fc!  u;=+L'(i--l+di);  Cipi+{pN++};  Uiq5i 

I'  IF el  ::  Nat,,  ! 61;  PI;  41  I?  $  e2 ::  Nat,,+tl  ! 62;  ~2;  42  I?  IF el  ::  Nats,  ! 61;  pl;  ~$1  r  IF e2  ::  Nat+  ! 62;  p2;  q5: 

I'  TV el  +  e2  ::  Nat,,+,,  ! 61  u  (1  +  62);  Pl  +p2;  41  u  42  I?  In el  -  e2  ::  Nat*,  ! 61 u  (1+  62);  p1  f  p2;  91  u  $2 

I?  IF ei  ::  Nat,,  ! hi;  pi;  4:  (Vi)  r  Ce  ::  7  ! 6;  p;  4  r,a: :: f  b e'  :: 7' ! 6'; p'; 4 r  b el * e2 

::  Nat,  ! 61 U  (1  +  ~52); PI  +PZ;  41 U 42  r  b let  2  =  e  in  e'  ::  T'!6u(1+6');  p+p';  +uy 

r  b  f  ::  TI  x  . . .  x  Tn  6n+1'  pn!$l'  `,+I  T  r  IF ep'  :: T: ! &; pi;  q5i  (Vi)  T,! D  I  (vi) r 

bfe1.e.  e,  ::  T  ! 1 +  UF=+l'(i  -  1 +  &);  Qi;  ui  4; 

r  b ei :: Size,,  ! 6;;  pi;  &  (Vi)  r  b el  :: SizesI+,,  ! 61;  PI;  .f#~l  r  b  e2  :: Size,,  ! 62;  ~2;  4 r  b 
el  -T-e2  :: Sizes,+,,  ! 61 U  (1  +  62);  PI  +p2;  42  U 42  r  IF el-  e2  :: Size,,  ! 61 U  (1  +  62);  PI  +  ~2;  ~$1 U 42 

r  be1  ::Size,!&;pl;  ~$1  r  be2::Sizes!62;p2;  42 r  t13 

el  i e2  :: Sizen*s  !61u(l+S2);  p1+p2;  dlU42 

r  IF e  :: Size,  ! b;  p;  I$  I?`, 2  :: p  C e'  :: T  ! 8;  p';  q5' r 
IF Ietregzc#eine'  :: T  ! 6 U  (1  +  6');  p +p'\p;  c$ U  (8  +  1 +  qY)  P  4  FVF,7);  P'(P)  I  5 

r  t15 e;  :: ri ! SC; pi; c#i (Vi)  I?  IF e  :: p  ! &+I;  p,+l;  &+I  r  IP e  :: [ 71 x . . . x rn lp ! S; p;  Cp r+(el,...,e,),::[Tl  x0.* 

xTm]p!U~-+l'(i-1+6i);  Cipi+{fJHn};  Ui~i  r  lp 7ri e :: 7; ! 6; p;  q5 

I?  IF e  ::  Nat,+l  ! do;  po;  +.  r  Gel  ::  Tl  ! 61;  p1;  41  l?,x  :: Nat+  lp  e2  ::  72 ! 62;  ~2;  42  ri  D  7  (Vi) r  b 

case  e of  0  +  el  0 2  +  1 +  e2  ::  7  ! 60 u  61 u  (1+  62);  po  +  (pl  u  p2);  ui  9i 

KJ =  Cl  ?l  1 . . .  1 Cm m  r  b  e :: IE ! SO; po;  ~$0  I?, xi1  :: nil,.  . .  , mini  :: Tin; b ei  :: pi  ! &;  pi;  #i  (Vi)  pi  D  T (Vi) r 

~caseeofc121~el...c,E,-+eh  :I  T!60UU~=`=,(?%+&);  pO+U~=lPi;  U;$id;P;4 

a$u -c::uEC  adu 

c :: Y  r  $f::uf"uEF  VjEfp  . v  +  v~/&][@-`/~]  +  D  E  D  Vj@.  E  4  E[`/~]T/#`/~] 

g&F  []  be::  T  ! 6;  p;  d,  []  t  gl  e  Fl  . . .  Fn-I  I-  gn  I+  I?,, 

ij  e  ::  7  ! s;  p;  4  91 ---gn  I+  F,  -- 

F,  fl  :: 61[k],  . . . , fn  :: cT,[k]  l-  fi  Zi  =  ei  ::  V:  (Vi)  Ui[O] =  u  (Vi)  U,! D  Vi[k+l]  (vi) 

F  I-  {fi  3i  =  ei}  I+  F,  fl  :: Vk  .OI  [k],  .  .  .  ,  fn  ::  Vk  .  bn[k] 

Ui[k]  E  VLiti&.&[k] 

FV(Vk.Di[k])  =  8 

x1  :: ~1,.  . . , xn  :: rn  b  e :: r  ! 6;  p;  C$  o=o  n=O  i=o  il  =o  i2  =  0 
F  I-  fm  *--xl,=e  ::  TI  X*.*X7,  6:llj@  T  n*i=O  n*i=O  il  +  i2  =  0 

u=u  u=u  u=u  T$  =  E  7;  =  E 
vlc.u=u  vl? . lJ =  u  vp.u=u  Pi) Tl  X  *  *  '  X  T,  +pTCU  [Tl  X  *-*  x  T,,]@ =  E  (vi) 

Nat0  =  E  si  =  0  (Vi  E  A)  ~i=E(v-)(A,B)ET=E Ts?p=E  $1  <  $2 Natal  D  Natdz  ,-  Size,  D  Size, 

Si  D  S:  (Vi)  Ti  D  T,!(w) 
T-al..+  71 * - * Tm  p  D  Ts; ...s;  T;  -  *  *  r:,  J.'  -31  I  s2 

Ti  D  T;  (vi) 
91  D  52  [Tl  X  '  -  *  X  T,,]p  D  [TI  X  *  '  .  X  Tn]p 

T,  D  Ti(vi)  T  D  T'  616';  PlP';  454' 
Q-1 X  . . .  X  Tn  J;q@  T  D  r;  X  . . .  x  r:,  S';PJ+i  4'  7'  pip'  PD  c  P'D;  VP  c  PD  . p(P)  5  p'(P) 

81 