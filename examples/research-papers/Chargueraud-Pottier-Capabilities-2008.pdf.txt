

Functional Translation of a Calculus of Capabilities

Arthur Chargu'eraud

INRIA
arthur.chargueraud@inria.fr

Franc,ois Pottier

INRIA
francois.pottier@inria.fr

Abstract
Reasoning about imperative programs requires the ability to trackaliasing and ownership properties. We present a type system that

provides this ability, by using regions, capabilities, and singletontypes. It is designed for a high-level calculus with higher-order
functions, algebraic data structures, and references (mutable mem-ory cells). The type system has polymorphism, yet does not require
a value restriction, because capabilities act as explicit store typings.We exhibit a type-directed, type-preserving, and meaningpreserving translation of this imperative calculus into a pure calcu-lus. Like the monadic translation, this is a store-passing translation.
Here, however, the store is partitioned into multiple fragments,which are threaded through a computation only if they are relevant
to it. Furthermore, the decomposition of the store into fragmentscan evolve dynamically to reflect ownership transfers.

The translation offers deep insight about the inner workings andsoundness of the type system. If coupled with a semantic model
of its target calculus, it leads to a semantic model of its imperativesource calculus. Furthermore, it provides a foundation for our longterm objective of designing a system for specifying and certifyingimperative programs with dynamic memory allocation.

1. Introduction
Reasoning about imperative programs in the presence of dynamicmemory allocation is a challenging task. The existence of aliasing

means that an update to a memory block by one principal can affectother principals with which the address of the block is shared,
possibly violating their invariants, if aliasing was unintended. Thus,a correctness argument for an imperative program must deal, in one
way or another, with aliasing (which object, or group of objects,might a certain pointer denote?) and with ownership (who holds
the right to access a certain object, or group of objects?).There are many ways of attacking this problem (see our discussion of related work in $8). We are interested in a line of workthat uses type-theoretic machinery, including regions, capabilities,
and singleton types, in order to control aliasing and ownership. Afew landmark papers in this area include Crary, Walker, and Morrisett's Calculus of Capabilities [7], Smith, Walker, and Morrisett'sAlias Types [19, 22], and F"ahndrich and DeLine's Adoption and
Focus [12].Our long-term research project is to design a system (say, a
Hoare logic) for proving properties of pointer programs on top of

[copyright notice will appear here]

such a capability-based type system. The idea is to express andcheck assertions about aliasing and ownership at the level of the
type system, so that, at the level of the Hoare logic, a view ofthe store as a collection of separate regions becomes available at
no cost. Our approach is closely related to Separation Logic [18].However, instead of expressing assertions about aliasing and ownership within the logic, we are interested in using more basicmachinery--a type system--for this purpose.

In this paper, we present a type system that is designed for astandard, high-level programming language and that combines the
key features of the systems cited above. It extends Fu (that is,System

F with recursive types), and permits the co-existence ofnon-linear values and linear capabilities. Note that, for the moment,

we are not interested in type inference or in surface syntax.On top of this type system, we define a type-directed translation
that transforms an imperative program into a purely functional one.In the translation, a capability becomes either a finite map (which
encodes a region of the store) or an individual value (which encodesa single, unaliased object). Thus, capabilities, which in the source
program are purely type-theoretic entities, are translated to runtimevalues. The translation is semantics-preserving, and produces welltyped programs in Fu.Just like the standard monadic translation [13, 21], this translation is store-passing. It is, however, much more fine-grained thanthe monadic translation: instead of a single, monolithic store, it
exploits multiple store fragments. This has a double benefit: first,separation between regions is made syntactically explicit; second,
homogeneous store fragments can be type-checked in Fu, whereasa monolithic, heterogeneous store would require a more complex
type system, equipped perhaps with dependent types.The value of such a translation is two-fold.

First, we claim that it provides a deep justification and intuitionfor the soundness of the type system. The design of the system is
subtle: it can be hard, even for an expert, to grasp why it all makessense. We find that, by explaining the type system in terms of a
pure y"-calculus, the translation helps expose the intuition behindit. In fact, the soundness of the type system and the soundness of
the translation are proved together, in a single statement ($7). Whencoupled with a semantic model of its target calculus, the translation
leads to a semantic model of its imperative source calculus. Thus,the translation is, in a sense, a semantic interpretation. In this
sense, our translation serves the same purpose as O'Hearn andReynolds's translation of Idealized Algol into the polymorphic
linear y"-calculus [15].Second, such a translation provides a foundation for our longterm objective of designing a system for specifying and certifyingimperative programs with dynamic memory allocation. The techniques available today for reasoning about purely functional pro-grams can, in principle, be applied to the translated programs. The
details of this process are left to future work.The paper begins with an informal overview of the type system
and of the translation ($2), followed with a couple of examples ($3).

1 2008/7/2

Definitions of the untyped source and target calculi follow ($4). Thetype system and type-directed translation are defined ($5, $6) and
proven sound ($7). (A complete proof of soundness appears in theonline addendum [1].) The paper ends with discussions of related
work ($8) and future work ($9).

2. Overview
2.1 Regions and capabilities
A region denotes a set of values. Unlike in previous work, these val-ues are not necessarily memory locations. We distinguish between

singleton regions ?, which have exactly one inhabitant, and groupregions

!, which have an arbitrary number of inhabitants. A valuethat inhabits region

o"" has type [o""] (pronounced: "at o"""). A typeof the form
[?] has exactly one inhabitant: it is a singleton type. Atype of the form

[!] can have zero, one, or more inhabitants.A capability over a region

o"" is a static token of the form {o"" : t,}.Such a capability serves two roles. First, it witnesses the ownership

of region o"", that is, it represents an exclusive right to access andupdate the inhabitants of this region. Second, it carries a memory
type t,, which describes the actual structure of the inhabitants.Indeed, the type

[o""], alone, does not contain this information. Forinstance, the capability {

! : ref int} describes and controls a groupregion whose inhabitants are pointers to integer cells.

Because capabilities represent exclusive ownership, they arelinear: they are never duplicated. (By "linear", we mean "nonduplicable", that is, "affine". Discarding a capability is permitted.)Memory types

t,, which occur within capabilities and also representownership, are linear as well. Value types

#, on the other hand,are non-linear. Because the system imposes no restriction on the

number of uses of a value, values can be duplicated by r'-reduction,and must receive non-linear types. In our system, the value types
form a subset of the memory types.A type of the form

[o""] is a value type. As a result, the valuesthat inhabit region
o"" can be duplicated at will, while the linearcapability {
o"" : t,}, which controls access to this region, remainsunique. Thanks to this distinction between non-linear values and

linear capabilities, the system provides the same degree of controlas offered by traditional linear type systems, yet provides greater
flexibility, by allowing sharing and multiple uses of values. Thisdistinction appears in earlier work [7, 19, 2].

Compound capabilities are built out of atomic capabilities viaconjunction: the composite capability

C1 * C2 controls two storefragments, respectively described by the capabilities

C1 and C2.Because capabilities are linear, this is naturally a separating conjunction, in the terminology of Separation Logic [18].Regions and capabilities encode definite non-aliasing information. For instance, if the capability {!1 : ref int} * {!2 : ref int} isavailable, then the regions

!1 and !2 must be distinct. This impliesthat the sets of their inhabitants are disjoint: no memory location

can simultaneously have type [!1] and type [!2]. As another ex-ample, consider the capability {

? : ref int * ref int}. Because thememory type "ref int*ref int" is interpreted linearly, this capability

asserts that the unique inhabitant of region ? is a pair of pointersto two distinct integer cells. In contrast, a pair of possibly aliased
integer references would be described by a value type [!] * [!],together with the group capability {

! : ref int}.

2.2 Functions and references
A function may accept not only an argument (a value), but also a(possibly compound) capability. Similarly, a function returns not

only a value, but also a capability. For this reason, function typestake the form

A^1 ! A^2, where computation types A^ include theproductions:
A^ ::= # | A^ * C. (The * connective is overloaded.)Furthermore, if a function creates fresh regions, then the names

of these regions must be quantified in the return type of the func-tion: for this reason, computation types also include the production
A^ ::= 9o"".A^.An example of a function whose return type is a non-trivial
computation type is the primitive operation "ref". The semantics of"

(ref v)" is to allocate a memory cell at a fresh location l, initializeit with

v, and return l. The axiom schema for "ref" is:

ref : # ! 9?.[?] * {? : ref #}
This means that "ref" accepts a value of type # and returns: (1)a singleton region

?, (2) the inhabitant l of region ?, and (3) thecapability {
? : ref #}, which controls this region, and indicatesthat its inhabitant

l is the location of a cell that currently holds avalue of type
#.The primitive operations "get" and "set", which read and write

a reference cell, have the following axiom schemata:

get : [?] * {? : ref #} ! # * {? : ref #}set

: ([?] * #2) * {? : ref #1} ! unit * {? : ref #2}

The "get" operation accepts a memory location l, of type [?], anda capability {

? : ref #}. This indicates that, in order to derefer-ence a pointer to a cell, one must provide a capability over that

cell. The "get" operation returns the contents of the cell, which hastype

#, together with an unchanged capability. The "set" opera-tion supports strong update: the type of the contents of the cell is

allowed to change from #1 to #2. In an ordinary typed program-ming language, such as ML, the need for strong update is seldom
perceived. Here, strong update is not just useful (e.g., to enable de-layed initialization): it is made necessary by the fact that types are
so fine-grained. For instance, without strong update, a reference oftype ref

[?] would effectively be immutable. Indeed, [?] is a single-ton type, so a type-preserving update cannot change the content of

such a reference.In type and effect systems, function types are annotated with
an effect: a set of regions that the function potentially accesses, forreading or writing. One can view an effect as a particular pattern
of use of a capability: an effect is a capability that is requiredand returned. To reflect this, we define

A^1 !C A^2 as sugar for
A^1 * C ! A^2 * C. In general, capabilities are more generalthan effects, as they also allow describing functions that allocate,

destroy, or re-organize memory. However, the effect notation, whenapplicable, is quite convenient. For instance, the types of "get" and
"set" (in the restricted case of a weak update, for the latter) can bewritten as follows:

get : [?] !{?:ref #} #set

: [?] * # !{?:ref #} unit

2.3 Ownership transfers
Reading a memory cell duplicates a value, while writing a memorycell discards a value. For this reason, the operations "ref", "get"

and "set" are restricted to references whose contents are non-linear.This restriction, which also appears in earlier work [12], is enforced
through the use of capabilities of the form {? : ref #}, where # isa value type, as opposed to {

? : ref t,}, where t, is a memory type.The latter form is more general. In fact, even though this form is

not a suitable argument to "get" or "set", it is legal: for instance,the capability {

? : ref (ref int)} describes and controls a referenceto a (unique) reference to an integer. So, how does one construct or

exploit a capability of the form {? : ref t,}?Our answer is to offer a mechanism for splitting the capability
{? : ref t,}, which controls both the reference cell denoted by ?and the contents of that cell, into two separate capabilities. In order
to do so, we introduce a fresh singleton region ?1, which serves asa name for the contents of the cell. The capability {

? : ref t,} isthen converted into the conjunction {
? : ref [?1]} * {?1 : t,}. The

2 2008/7/2

first conjunct controls just the cell denoted by ?, and tells that itscontents is the unique inhabitant of region

?1. The second conjunctcontrols
?1, and tells that its inhabitant has type t,. This splittingprocess is reversible. It is described by a symmetric subtyping

axiom (FOCUS-REF, Figure 13):

{? : ref t,} t^ 9?1.{? : ref [?1]} * {?1 : t,}
An illustration is found in Figure 14. After splitting, because thetype

[?1] is non-linear, the capability {? : ref [?1]} can be used toread and write the reference as many times as desired. In particular,

reading the reference duplicates its contents, at type [?1], but doesnot duplicate the capability {

?1 : t,}, which remains unique.There is another way in which the operations "ref", "get", and

"set" are restricted: they act only on singleton regions ?, as opposedto group regions

!. So, how does one allocate or access a cell withina group region? To address this question, we rely on the adoption

and focus mechanisms proposed by F"ahndrich and DeLine [12].Empty group regions can be created at any time. Adoption is
used to populate a group region: adoption dissolves a singletonregion

? into an existing group region ! (ADOPT-GRP, Figure 13).Once adopted, a value

v can never be extracted back out of agroup region
!. Indeed, the information that v has type [!], whichmeans that
v inhabits !, can be duplicated: thus, it must remaintrue forever. Nevertheless, in order to gain access to

v, it maybe necessary to temporarily isolate it out of the group region

!.The focus operation permits this by placing
v in a fresh singletonregion
? (FOCUS-GRP, Figures 13 and 14).Focus accepts a capability {

! : t,}, together with an elementof
!, that is, a value of type [!]. It creates a fresh singleton region ?,which holds just that element, now viewed at type

[?]. Because thecapability {
? : t,} is now available, and has overlap with {! : t,},letting these two capabilities co-exist would be unsound. Instead,

the latter is revoked, and replaced with the weaker form {! : t, \?}.Such a capability can be thought of as "region

!, in which a holehas been carved out at
?", in Boyland and Retert's terminology [4].This disabled capability does not allow access to

!, but can betransformed back into {
! : t,} when {? : t,} is released (UNFOCUSGRP, Figure 13).In the particular case of references with non-linear contents, a

version of "ref" that allows allocation within a group region canbe derived using adoption. Similarly, surrounding "get" and "set"
with instances of focus and unfocus allows deriving versions ofthese operations that are applicable directly to group regions.

2.4 Translation
In a well-typed program, capabilities over regions are threadedthrough computations. Whereas, in the source program, capabilities

are type-theoretic entities, they are turned by the translation intoruntime representations of the contents of regions. Thus, in the
translated program, representations of fragments of memory arethreaded through computations.

A group capability {! : t,} is translated as a finite map thatassociates keys with values. The inhabitants of region

!, which havetype
[!], are translated as keys. (We assume that the target languagehas primitive notions of keys and of finite association maps.) The

logical operations that involve group regions, such as adoption andfocus, are translated as operations over keys and finite maps, such
as fresh key generation, and map lookup, update, and extension.A singleton capability {

? : t,} is translated as a map of unit toa value, which, in practice, is represented simply as a value. The

"ref" type constructor vanishes: that is, the translation of "ref t,"is just the translation of

t,. This may seem surprising, but is ex-plained by the fact that "ref" is a type of unique references. The

translation introduces keys and maps only where there is aliasing,that is, where group regions are used. For instance, the capability

{? : ref int * ref int}, which describes a pair of distinct integer ref-erences, is translated simply as a pair of integers. The inhabitant of
region ?, which has type [?], is translated as the unit value.
2.5 Contribution
Type system Regions [20], group capabilities [7], singleton ca-pabilities and strong update [19, 22], adoption and focus [12] are

borrowed from earlier work. Our type system combines these ideas,adapts them to a high-level programming language in the style of
ML, streamlines their presentation, and introduces a few new fea-tures, which we now summarize.

- Decoupling logical and physical indirection. Our type con-structors for memory indirection (ref *) and for membership in

a region ([*]) are orthogonal. Our regions denote sets of valuesthat are not necessarily memory locations. In the systems cited
above, a single type constructor conflates the properties of beinga memory location and of belonging to a certain region.

- Nested memory types. Our "ref" types can be nested and com-bined with other memory type constructors, such as products,

sums, and recursive types. For instance, ur'.ref (unit + o"" * r')($3.1) is a valid memory type, which represents the ownership
of an entire list, including all of the list items. By contrast, inearlier systems [22, 12], memory types are shallow: a capability
for a list structure is encoded as a capability for the root cell, un-der the convention that each cell of the list stores a capability for
its successors. Although the two approaches have equivalent ex-pressive power, viewing nested memory types as primitive seems
more suited to a high-level programming language.-
Sum types. Our type system offers a direct treatment of thesum type constructor (*

+*). Earlier type systems have dealt onlywith lower-level, untagged unions (* [ *) [19, 22].

- Unrestricted polymorphism. The type system offers universaland existential quantification, in the style of System

F , overvalue and memory types, capabilities, and regions. This is done

in the presence of references, yet without a value restriction [16,p. 336], thanks to capabilities, which act as explicit store typings.
Although this idea seems natural, we believe that it has notappeared in the literature.

Translation Our translation of well-typed imperative programsinto semantically equivalent, purely functional programs is perhaps the most visible contribution of this paper. This translationsubsumes the standard monadic translation. By using fine-grained
store fragments, it produces programs in which a great amount ofseparation information is syntactically apparent. By using homogeneous store fragments, it produces programs that are well-typedin

Fu. This is not true of the monadic translation, due to its use ofa monolithic, heterogeneous store.

3. Examples
In order to better explain the type system and the translation, wepresent two examples of imperative data structures: mutable linked

lists and union-find. We show the types of each operation in thesource and target calculi, separated with a B symbol. Source code
and translated code is shown only for list reversal. For more detailsand additional examples, see the online addendum [1].

The translation produces redundant occurrences of the unit type,which correspond, in the source program, to occurrences of singleton types of the form [?]. In principle, these redundant units couldbe eliminated in a separate pass. For clarity, we have kept them.

3.1 Mutable Lists
Consider a linked list where every cell is mutable, owns an itemof type

o"", and owns the next cell (so that, indirectly, it owns the

3 2008/7/2

tail of the list). Such a data structure is described by a recursivememory type: a list is a reference to either unit (if the list is empty)
or a pair of an item (the head) and a list (the tail). We introduce anabbreviation for this recursive type:

mlist o"" := ur'.ref (unit + o"" * r')
In the target calculus, ordinary, immutable lists are described by thefollowing recursive type:

list o"" := ur'.(unit + o"" * r')
Because the "ref" type constructor vanishes through the translation,the image of "mlist

o""" through the translation is "list o""". Thatis, a mutable list is translated simply to an immutable list. (Of

course, the type of the list items is translated too. Here, this is notvisible, because the type variable

o"" is translated to itself.) This ispossible only because, in this simple example, there is no aliasing:

the definition of "mlist" forbids two mutable lists from sharing acommon tail. When there is aliasing in the source program, that
is, when group regions are used, then the translation involves finitemaps and keys.

Nil and cons Two functions help construct mutable lists. Thefunction "nil" creates a fresh empty list in a fresh singleton region.
The function "cons" accepts an item, a mutable list, as well ascapabilities for each of these values, and returns a mutable list,
together with a capability for this list. Through the translation, thesebecome the standard "nil" and "cons" constructors for immutable
lists (up to redundant units).

nil : 8o"". unit ! 9?.[?] * {? : mlist o""}B 8

o"". unit ! unit * list o""

cons : 8o"" ?1 ?2. ([?1] * [?2]) * {?1 : o""} * {?2 : mlist o""}! 9

?.[?] * {? : mlist o""}B 8
o"". unit * unit * o"" * list o"" ! unit * list o""

The idiom of packaging together a value and a capability for thisvalue is common enough that it could warrant an abbreviation. Let

t,* stand for 9?.[?] * {? : t,}. (A similar notation appears in earlierwork [12, 2].) This corresponds to a traditional linear type, in the
sense that a value and a permission are packaged together. With thisnotation, the types of "nil" and "cons" in the source calculus could
be written:

nil : 8o"". unit ! (mlist o"")*cons

: 8o"". o""* * (mlist o"")* ! (mlist o"")*

These are the types ascribed to "nil" and "cons" in a traditional lin-ear type system. Although this abbreviated notation is convenient,

it is not always applicable: there are many situations where separat-ing values and capabilities offers extra expressive power (see, e.g.,
the type of "iter" below).
Reverse Let us now consider a function that performs in-placereversal of a mutable list. The function "reverse" accepts a mutable list, together with a capability, and produces a mutable list,together with a capability. The capability for the argument list is
not returned, which indicates that this list is no longer valid--itscells have been re-used to construct the new list. The translation of
"reverse" simply maps an immutable list to an immutable list (upto redundant units).

reverse : 8o"". (mlist o"")* ! (mlist o"")*B 8

o"". unit * list o"" ! unit * list o""

In the source program, "reverse" traverses the list, flipping pointersas it goes. The auxiliary function "aux", which implements a loop,

expects a pointer l to the current list cell, a pointer p to the previ-ous list cell, as well as capabilities over the two lists that these cells
represent. In the translated version of "aux", the pointers l and p

become unit, while the capabilities over l and p become immutablelists, which respectively represent a list to be reversed and a list that
is already reversed. In summary, up to redundant units, the trans-lation of "reverse" is a standard version of reversal for immutable
lists: a tail-recursive function that uses an accumulator. The sourceand translated code for "reverse" is shown below:

reverse = let aux = uaux.y"(l, p).match (get l) with| inj

1 () ) p|

inj2 (h, t) ) set (l, inj2 (h, p)) ; aux (t, l)in
y"l. (aux (l, nil ()))B

let aux = uaux.y"((), (), l, p).match l with| inj

1 () ) ((), p)|

inj2 (h, t) )let

l0 = inj2 (h, p) in aux ((), (), t, l0)in
y"((), l). (aux ((), (), l, nil ()))

Iter Last, let us consider a higher-order iterator over mutable lists.The client function

f, which is applied to each item of the listin succession, has effect {

? : o""} * r', where r' is a capabilityvariable. The first conjunct allows

f to access and modify thecurrent list item. The second conjunct allows

f to perform side-effects on some piece of the outside world, described by

r'. Theapplication of "iter" to
f has effect {? : mlist o""} * r', which meansthat it affects both the list and the store fragment controlled by

r'.Note that, because of the separating conjunction, the capabilities

{? : mlist o""} and r' represent disjoint store fragments. This impliesthat the client function

f is not allowed to modify the structure ofthe list while it is being traversed.

iter : 8o""r'. (8?. [?] !{?:o""}*r' unit)!

(8?. [?] !{?:mlist o""}*r' unit)B 8
o""r'. (unit * o"" * r' ! unit * o"" * r')!

(unit * list o"" * r' ! unit * list o"" * r')

In the target calculus, "iter" is translated to a combination of thestandard "map" and "fold" combinators over immutable lists.

3.2 Union-find
Our next example illustrates how group regions are used to describedata structures with sharing. It is a version of Tarjan's unionfind data structure. This data structure consists of a set of nodes,organized as a forest: each node either is a root or points to a parent
node. Nodes are mutable: the forest evolves over time. The nodes ofa single instance of the union-find algorithm are placed in a group
region !. Their structure is given by the following memory type:

node ! := ref (unit + [!]) B unit + key
A node is a reference to either unit (if this a root node) or a node (ifthis is an internal node).

The group capability {! : node !} describes the entire datastructure: it represents the ownership of all nodes. Its translation,
a finite map, maps a key (which represents a node) to either unit (ifthis is a root node) or a key (if this is an internal node):

forest := map (unit + key)
The following functions, which manipulate the union-find datastructure, require and return the capability {

! : node !}. Throughthe translation, they become functions that require and return an

explicit representation of the forest.

new : 8!. unit !{!:node !} [!]B unit * forest ! key * forest

find : 8!. [!] !{!:node !} [!]B key * forest ! key * forest
union : 8!. [!] * [!] !{!:node !} unitB key * key * forest ! unit * forest

4 2008/7/2

Values v := x | () | injiv | (v1, v2) | uf.y"x.t | p | lPrim. ops.

p := case | proji | ref | get | setTerms
t := v | (v t)

Figure 1. Source language syntax

((uf.y"x.t) v) / s -! ([f ! uf.y"x.t] [x ! v] t) / s
(case ((inji v), v1, v2)) / s -! (vi v) / s
(proji (v1, v2)) / s -! vi / s
(ref v) / s -! l / s ] [l 7! v]
(get l) / s -! s[l] / s
(set (l, v)) / s -! () / s[l 7! v]
(v t) / s -! (v t0) / s0 if (t / s -! t / s0)

Figure 2. Source language semantics

Values w := x | () | inji w | (w1, w2) | uf.y"x.u | q | k | m
Prim. ops. q := case | proji |map fresh | map add | map get | map set

Terms u := w | (w u)

Figure 3. Target language syntax

The function "new" creates a new node; its translation extends themap that represents the region

! at a fresh key and returns thatkey. "find" follows parent pointers out of a given node until it

reaches a root node, and performs path compression; its translationinvolves map lookup and update operations. "union" merges two
components, via a side effect; its translation involves calls to "find",as well as direct map lookup and update operations.

The capability {! : node !} does not encode the fact that thenodes form a forest, that is, the fact that there are no cycles. The
type system is not capable of expressing this property. In a programlogic defined on top of the type system, this property would be
expressed as an invariant (a pre- and post-condition) of the abovefunctions.

4. Source and target languages
The source language of our translation is a y"-calculus equippedwith imperative features. The target language is a pure

y"-calculusequipped with a primitive form of finite association maps. Figures 1

through 4 give the syntax and small-step operational semantics ofthe two languages.

A source language configuration is a pair of a term t and ofa store

s. A store is a finite map of locations l to values v. Val-ues are built out of variables, unit, injections, pairs, recursive

y"-abstractions, unary primitive operations
p, and locations l. (Thevariables
x and f range over a single class. The binder uf isomitted when unnecessary.) The primitive operations include eliminators for sums and products as well as the standard operationsfor allocating, reading, and writing a reference cell. Terms include values v and function applications (v t). The asymmetriccharacter of applications prevents any ambiguity about evaluation
order and simplifies the reduction and typing rules. Sequencing
(let x = t1 in t2) is encoded as ((y"x. t2) t1), and (t1 ; t2) is en-coded as

(let () = t1 in t2).

(uf.y"x.u) w -! [f ! uf.y"x.u][x ! w] uproj

i (w1, w2) -! wi

case (inji w, w1, w2) -! (wi w)map fresh

m -! min {k | k 62 dom(m)}map add
(m, k, w) -! m ] [k 7! w]map get
(m, k) -! m[k]map set
(m, k, w) -! m[k 7! w]
(w u) -! (w u0) if (u -! u0)

Figure 4. Target language semantics

o := o"" | ? | ? | unit | [o] | o + o | o * o | o ! o | ref o |

o * o | 8o"".o | 9o"".o | uo"".o | ; | {o : o} | {o : o \ o} |? |

o, o"" | o, x : o

u* := VAL | MEM | CMP | CAP | SNG | GRP | DNV | LNV

Figure 5. Syntax of types, capabilities, environments and kinds

(# : VAL) (t, : MEM) (A^ : CMP) (C : CAP)

(? : SNG) (! : GRP) (\Delta  : DNV) (\Gamma  : LNV)

Figure 7. Conventional metavariables

The target language is purely functional. Its values are written wand its terms are written

u. In lieu of memory locations l andmemory stores
s, it has keys k (isomorphic to the natural numbers)and finite association maps

m from keys to values. The primitiveoperations
q include operations on finite maps instead of operationson references. In short, "map fresh" deterministically returns a key

that does not appear in the domain of its argument; "map get" looksup a key in a map; "map set" updates a map at an existing key,
producing a new map; and "map add" extends a map at a previouslyundefined key, also producing a new map. We let "map empty"
stand for the empty map; it is a value.

5. Capabilities and types
The definition of the type system involves various kinds of enti-ties, and several connectives are shared between multiple kinds. In

order to avoid a combinatorial explosion in the syntax, we find itnecessary to define a single syntactic category of objects

o, and tothen classify objects using kinds
u* (Figure 5). The well-kindednessrules (Figure 6) are unfortunately quite technical; we suggest skipping them upon first reading. Throughout the paper, kinds remainimplicit, thanks to the use of conventional metavariables (Figure 7).
Type variables of all kinds are written o"". We assume that every typevariable

o"" intrinsically belongs to some fixed kind u*, in which casewe write

o"" : u*. We now briefly and informally review each of thekinds.

Value types # Value types include the standard constructors bot-tom, top, unit, sum, product, and arrow. The type

[o""] ("at o""") rep-resents membership in the region
o"". The bottom type ? is usefulin combination with the type constructor for sums: for instance, a

value of type (# + ?) must be a left injection.
Memory types t, Memory types describe the structure of the el-ements of a region. They appear in capabilities, such as {

? : t,},and describe the extent of the piece of memory that is controlled

by this capability. The grammar of memory types extends that ofvalue types with references (

t, ::= ref t,) and with a separating con5 2008/7/2

o : VAL
o : CMP

o : VAL
o : MEM ? : VAL ? : VAL unit : VAL

o : u*
[o] : VAL

u*2{SNG,GRP}

o1 : u* o2 : u*

(o1 + o2) : u*

u*2{VAL,MEM} o1 : u* o2 : u*(o

1 * o2) : u*

u*2{VAL,MEM} o1 : CMP o2 : CMP(o

1 ! o2) : VAL

o : MEM
(ref o) : MEM

o1 : u* o2 : CAP

(o1 * o2) : u*

u*2{MEM,CAP,CMP} o"" : u*1 o : u*2(8o"".o) : u*

2

u*12{VAL,MEM,CAP,SNG,GRP}
u*22{VAL}

o"" : u*1 o : u*2

(9o"".o) : u*2

u*12{VAL,MEM,CAP,SNG,GRP}
u*22{VAL,MEM,CAP,CMP}

o"" : u* o : u*

(uo"".o) : u*

u*2{VAL,MEM,CAP}
o not a variable or a u form

; : CAP

o1 : u* o2 : MEM{

o1 : o2} : CAP

u*2{SNG,GRP} o1 : GRP o2 : MEM o3 : SNG{o

1 : o2 \ o3} : CAP

? : u* u*2{

DNV,LNV} o : u*1 o"" : u*2(o, o"") : u*

1

u*12{DNV,LNV}
u*22{VAL,MEM,CAP,SNG,GRP}
o""#o

o1 : u*1 o2 : u*2

(o1, x : o2) : u*1

(u*12{DNV} ^ u*22{VAL})
or (u*12{LNV} ^ u*22{VAL,CMP,CAP})
x#o1 ^ fv(o2)t,dom(o1)

Figure 6. Well-kindedness

J?K = ?J?K

= ?JunitK
= unitJ
[?] K = unitJ
[!] K = key

Jo1 + o2K = Jo1K + Jo2KJ

o1 * o2K = Jo1K * Jo2KJ
o1 ! o2K = Jo1K ! Jo2KJref

oK = JoKJ
o1 * o2K = Jo1K * Jo2K

J;K = unitJ{

? : o}K = JoKJ{
! : o}K = map JoKJ{
! : o \ ?}K = map JoK * keyJ?K

= ?J
o1, x : o2K = Jo1K, x : Jo2K

If (o"" : SNG)or

(o"" : GRP):J8
o"".oK = JoKJ9
o"".oK = JoKJ
uo"".oK = JoKJ
o, o""K = JoK

Otherwise:J

o""K = o""J8

o"".oK = 8o"".JoKJ9
o"".oK = 9o"".JoKJ
uo"".oK = uo"".JoKJ
o, o""K = JoK, o""

Figure 8. Translation of types, capabilities and environments

junction (t, ::= t, * C), which allows capabilities to be embeddedwithin memory types. Notice that a value type for a memory location l must be of the form [o""]. The type of the contents of thelocation appears in the capability {

o"" : ref t,} that controls l.

Computation types A^ As explained earlier ($2.2), computationtypes admit the productions

A^ ::= # | A^ * C | 9o"".A^. They areused in function types, which take the form

A^1 ! A^2.

Capabilities C Atomic capabilities include the null capability ;,singleton capabilities {

? : t,}, group capabilities {! : t,}, anddisabled capabilities {
! : t, \ ?}. The latter represents ownershipof all elements of a group region

!, except the unique elementof a singleton region
?. Compound capabilities are built via theseparating conjunction

C1 * C2.

Regions ?, ! The kinds of singleton regions ? and of group re-gions

! contain only variables. We take the liberty of using ? and !to denote region variables, so we write 8

?, 9!, etc.

Environments \Delta , \Gamma  A duplicable, or non-linear, environment \Delta binds type variables

o"", and binds variables to value types (x : #).A linear environment

\Gamma  can additionally bind variables to compu-tation types
(x : A^) or to capabilities (x : C). Bindings commute,provided dependencies are respected. When a variable

x is boundto a capability
C, it cannot occur in the program: in the source cal-culus, capabilities are not values, and do not exist at runtime. We

assign names to capabilities not only for sake of uniformity, butalso because these names are naturally used in the translation.

Quantification Universal quantification (8) is present in the syn-tax of value types (

# ::= 8o"".#). It is not present in the syntax of

memory types or capabilities, as it would not make sense to quan-tify over a type variable that occurs in a store typing. Existential
quantification (9) and recursive definition (u) are available not onlywithin value types, but also within memory types and capabilities.

Translation of types The target language is typed in Fu withtype constructors "key" (of arity 0) and "map" (of arity 1). Our
translation of programs preserves types. Figure 8 shows how asource object

o is translated to an Fu object JoK. The translationconcerns objects of all kinds except

SNG and GRP, as regions vanishin the translation. The translation of region membership types

[o""],of references, and of atomic capabilities has been described earlier

($2.4). The translation of disabled capabilities is explained later on($6.2). A separating conjunction is translated as a product. The rest
of the translation is structural.

6. Type system and translation
6.1 Structural rules
Judgements Values admit a non-linear value type in a non-linearenvironment, while terms admit a linear computation type in a

linear environment. The corresponding judgements are

\Delta  ` v : # and \Gamma  r^ t : A^
In other words, the construction of a value v does not consume orproduce any capability. The evaluation of a term

t, on the otherhand, consumes the capabilities contained in the linear context

\Gamma and produces the capabilities contained in the computation type
A^.The type-directed translation of values and terms into the target language is defined via translation judgements that extend the

6 2008/7/2

UNIT

\Delta  ` () : unit B ()

INJ

\Delta  ` v : #i B w

\Delta  ` (inji v) : (#1 + #2) B (inji w)

PAIR

\Delta  ` v1 : #1 B w1 \Delta  ` v2 : #2 B w2

\Delta  ` (v1, v2) : (#1 * #2) B (w1, w2)

VAR

(x : #) 2 \Delta 

\Delta  ` x : # B x

FIX

\Delta , f : (A^1 ! A^2), x : A^1 r^ t : A^2 B u

\Delta  ` (uf.y"x.t) : (A^1 ! A^2) B (uf.y"x.u)

Figure 9. Type-checking and type-directed translation: values

VAL

\Delta  ` v : # B w

\Delta  r^ v : # B w

APP

\Delta  r^ v : (A^1 ! A^2) B u1 \Delta , \Gamma  r^ t : A^1 B u2

\Delta , \Gamma  r^ (v t) : A^2 B (u1 u2)

SUB

\Gamma  r^ t : A^1 B u A^1 <= A^2 B w

\Gamma  r^ t : A^2 B (w u)

*-INTRO (FRAME)

\Gamma  r^ t : A^ B u

\Gamma , (x : C) r^ t : (A^ * C) B (u, x)

*-ELIM

\Gamma , (x1 : o), (x2 : C) r^ t : A^ B u

\Gamma , x1 : (o * C) r^ t : A^ B let (x1, x2) = x1 in u

Figure 10. Type-checking and type-directed translation: terms

8-INTRO-VAL

\Delta , o"" ` v : # B w

\Delta  ` v : (8o"".# ) B w

8-ELIM-VAL

\Delta  ` v : (8o"".#) B w

\Delta  ` v : ([o"" ! o] #) B w

9-INTRO-VAL

\Delta  ` v : ([o"" ! o] #) B w

\Delta  ` v : (9o"".# ) B w

9-ELIM-VAL

\Delta 1, o"", (x : #1), \Delta 2 ` v : # B w

\Delta 1, x : (9o"".#1), \Delta 2 ` v : # B w

8-INTRO-TRM

\Gamma , o"" r^ t : # B u

\Gamma  r^ t : (8o"".#) B u

8-ELIM-TRM

\Gamma  r^ t : (8o"".#) B u

\Gamma  r^ t : ([o"" ! o] #) B u

9-INTRO-TRM

\Gamma  r^ t : ([o"" ! o] A^) B u

\Gamma  r^ t : (9o"".A^) B u

9-ELIM-TRM

\Gamma 1, o"", (x : A^1), \Gamma 2 r^ t : A^ B u

\Gamma 1, x : (9o"".A^1), \Gamma 2 r^ t : A^ B u

Figure 11. Additional rules for values and terms: quantifier introduction and elimination

typing judgements:

\Delta  ` v : # B w and \Gamma  r^ t : A^ B u
(The symbol B should be read: "is translated to".) The left-handjudgement states that the source value

v is translated to the targetvalue
w. The right-hand judgement states that the source term t istranslated to the target term

u.The translation preserves well-typedness, compositionally. This

fact admits the following succinct statement (in which the symbol`

Fu indicates well-typedness in Fu):

Lemma (Type preservation)

\Delta  ` v : # B w implies J\Delta K `Fu w : J#K
\Gamma  r^ t : A^ B u implies J\Gamma K `Fu u : JA^K e,

The translation judgements extend the typing judgements in thefollowing sense. First, every valid translation judgement contains a

valid typing judgement, which can be recovered simply by erasingthe translation-specific annotations. Conversely, every valid typing
judgement is the erasure of some valid translation judgement.In order to save space and avoid redundancy, only the translation rules are presented in this paper (Figures 9, 10 and 11). Thetranslation-specific parts are printed on a gray background, so that,
by ignoring them, one recovers the typing rules.

Values (Figure 9) Values are type-checked in a standard way.Their translation is structural.

The rule that type-checks recursive functions does hide a coupleof subtleties. First, it uses computation types

A^, which describe thetransfer not only of a value, but also of capabilities. Second, it uses

a duplicable environment \Delta , which means that a closure cannotcapture a capability that happens to be available at its allocation
site. This is required for type soundness [12].
Terms (Figure 10) VAL states that a value of type # can be viewedas a term of type

#. This statement is well-formed, because everyduplicable environment is also a linear environment, and every

value type is also a computation type.

APP states that the application (v t) has type A^2 if the function vhas type

A^1 ! A^2 and the argument t has type A^1. Because theleft-hand side is a value, which consumes no capability, all of the

available capabilities, represented by \Gamma , are transmitted to the right-hand side

t. The environment fragment \Delta , which is duplicated,does not contain any capability. An application is translated to an

application.The subtyping rule,

SUB, weakens the type of a term. Thesubtyping relation is defined later on ($6.2). For the moment, note

that a subtyping judgement translates to a coercion, that is, a closed
y"-term, and that an instance of SUB gives rise, in the translatedterm, to an application of a coercion.

7 2008/7/2

*-INTRO, also known as FRAME, states that if a term is fed witha capability

C that it does not need, then its evaluation preservesthat capability. This is the first-order frame rule of Separation

Logic [18]. An instance of FRAME is translated to a pair, whosefirst component is the translation of the term

t, and whose secondcomponent is the translation of the capability
C. (In order to satisfyour syntactic restrictions, the notation
(u, x) is defined as syntacticsugar for the
r'-expanded form "let x0 = u in (x0, x)".)*-
ELIM is a left elimination form for separating conjunctions,which may be of the form

A^ * C or C1 * C2. Because conjunc-tions are translated as pairs, the deconstruction of a conjunction is

translated as pair decomposition.
Quantifiers (Figure 11) All quantifier introduction and elimina-tion rules are standard, except 8-

INTRO-TRM, which states that itis permitted to generalize the type of a term. The very existence of

this rule means that there is no value restriction [16, p. 336]. Yet,the system is sound. This is guaranteed by a restriction on the syntax of types: while (8o"".#) is a valid type, (8o"".A^) is not. Indeed,a computation type

A^ may contain capabilities, which describe thestructure of a piece of store; the type variables that occur within

these capabilities must not be generalized.
Deriving LET Because the "let" construct is sugar for a r'-redex,its typing rule follows from

APP, FIX, VAL, and FRAME:

LET

\Delta , \Gamma 1 r^ t1 : A^1 B u1 \Delta , (x : A^1), \Gamma 2 r^ t2 : A^2 B u2

\Delta , \Gamma 1, \Gamma 2 r^ (let x = t1 in t2) : A^2 B (let x = u1 in u2)

6.2 Primitive operations and subtyping
The subtyping judgement takes the form:

o1 <= o2 B w
where o1 and o2 have kind u* 2 {VAL, MEM, CMP, CAP}. Thecoercion

w is a closed value of the target calculus (a coercion),whose type is J

o1K ! Jo2K. It is used to translate the subtypingoperation.

In the following, the types of the primitive operations (Fig-ure 12) and the subtyping rules (Figure 13) are explained together.

Notation In Figure 13, we use y"-abstractions of the form (y"ij. u),where

ij is a pattern, that is, a value composed of unit, pairs,injections, and distinct variables. We write

(ij A~ u) for (y"ij. u),and let the symmetric subtyping axiom:
o1 t^ o2 B (ij1 ! ij2)stand for the conjunction of axioms:
o1 <= o2 B (ij1 A~ ij2) and
o2 <= o1 B (ij2 A~ ij1).

Illustration Among the subtyping rules, four FOCUS rules, whichreorganize regions, are informally illustrated in Figure 14. There, a

solid arrow points to an object that is owned by the origin region ofthe arrow, so it never crosses a region boundary. On the contrary, a
dashed arrow points into some distinct region, so it always crossesa region boundary. The object at the end of such an arrow has a
type of the form [o""], for some region o"", and it is controlled by thecapability associated with region

o"".

General SNG-CREATE states that every value can be viewed as amember of a singleton type. This helps derive variants of several

other rules. Conversely, SNG-EXTRACT turns a singleton type [?]back into a value type

#, provided the capability {? : #} is present.(
SNG-EXTRACT can be used to show that SNG-CREATE is in fact anequivalence.) These rules reflect the fact that ownership of a nonlinear value is never exclusive. This is acceptable, because valuesare immutable.

FREE discards a capability C. Technically, its presence meansthat capabilities are affine, rather than linear. Its translation,

(y"x. ()),discards
x, which represents the memory controlled by C.

References The types of the primitive operations "ref", "get", and"set", as well as the subtyping rule

FOCUS-REF (illustrated in Fig-ure 14), have been explained earlier ($2.2). The translation of "ref",

"get" and "set" is exactly the standard monadic translation [13, 21],in the particular case where the state consists of a single memory cell. In the translated y"-terms, x stands for the translation of{

? : ref #}, that is, the contents of the cell. The location l at type
[?] is translated to unit.

Pairs Just like the primitive operations on references, the pairprojections extract a non-linear component out of a linear container.

That is, "proj1" requires a capability of the form {? : #1 * t,2}, andreturns a value of type

#1.In order to extract a linear component out of a pair, one relies

on the subtyping rule FOCUS-PAIR1 (from left to right) to isolatethe first component of a pair in a fresh region (See Figure 14).
This mechanism is identical to that provided by FOCUS-REF foraccessing references with linear contents.

Conversely, applying rule FOCUS-PAIR1 twice, from right toleft, allows constructing a linear pair {

? : t,1 * t,2} out of a valueof type
([?1] * [?2]) and out of the two capabilities {?1 : t,1} and{
?2 : t,2}.The traditional type (

#1 * #2 ! #i) for projection out of a non-linear pair can be derived, via

SNG-CREATE and FREE. Moreover,up to
r't^-equivalence, its translation is just projection.

Sums The type of "case" is somewhat complex. The reason is that"case" performs two tasks: on the one hand, it branches on a tag;

on the other hand, it deconstructs a sum by stripping off its tag andreturning the underlying value. In the following, we explain how
these tasks could be assigned separate types. The type of "case" isthen derived as a combination of these types and of a focusing step.

First, a hypothetical primitive operation, whose dynamic se-mantics is to examine the tag of a sum and transfer control, accordingly, to one of two branches, could be assigned the type:a,

(unit * {? : t,1 + ?} * C ! A^)*
(unit * {? : ? + t,2} * C ! A^)*

[?]c' * {? : t,1 + t,2} * C ! A^

Here, each branch consumes a capability C and produces a resultof type

A^; the same is true of the entire "case" construct. Thecapability {

? : t,1 + t,2} is transformed to {? : t,1 + ?} in the firstbranch and to {

? : ? + t,2} in the second branch, reflecting theknowledge acquired by examining the tag. This knowledge can be

discarded, so as to recover the original capability, via the subtypingaxiom ? <=

t,.Second, a hypothetical primitive operation, whose dynamic semantics is to deconstruct a left injection could be assigned the type:

(# + ?) ! #
The application of this function is well-typed only if its argumentis statically known to be a left injection.

Third and last, it is natural to introduce the subtyping rule
FOCUS-SUMi. This rule is analogous to FOCUS-PAIRi. It allowsisolating the contents of an injection in a fresh region, when the tag

is statically known (see Figure 14).Combining the types of the above two hypothetical primitive
operations with instances of FOCUS-SUMi yields the type of "case",shown in Figure 12.

Regions There are four subtyping rules for producing or consum-ing group regions [12]. These rules are purely logical: they change
one's view of memory, but have no runtime effect in the source lan-guage. In the translation, these subtyping rules become instructions
for rearranging the finite maps that represent regions.

NEW-GRP allows the creation of n fresh, empty group regions.Every

t,i can contain free occurrences of every !j, which is why

8 2008/7/2

ref : # ! 9?.[?] * {? : ref #} B y"x. ((), x)
get : [?] * {? : ref #} ! # * {? : ref #} B y"((), x). (x, x)
set : ([?] * #2) * {? : ref #1} ! unit * {? : ref #2} B y"((), x2, x1). ((), x2)
proj1 : [?] * {? : #1 * t,2} ! #1 * {? : #1 * t,2} B y"((), (x1, x2)). (x1, (x1, x2))
case : a, ((9?1.([?1] * {? : [?1] + ?} * {?1 : t,1} * C)) ! A^) B y"(f1, f2, (), x, c). case (*

((9?2.([?2] * {? : ? + [?2]} * {?2 : t,2} * C)) ! A^) (y"x1. (f1 ((), inj1(), x1, c))),*
[?] c' * {? : t,1 + t,2} * C ! A^ (y"x2. (f2 ((), inj2(), x2, c))), x)

Figure 12. Typing and translation of primitives
General

SNG-CREATE : # <= 9?.[?] * {? : #} B x A~ ((), x)
SNG-EXTRACT : [?] * {? : #} <= # * {? : #} B ((), x) A~ (x, x)
FREE : C <= ; B x A~ ()

Focus-value

FOCUS-REF : {? : ref t,1} t^ 9?1.{? : ref [?1]} * {?1 : t,1} B x ! ((), x)
FOCUS-PAIR1 : {? : t,1 * t,2} t^ 9?1.{? : [?1] * t,2} * {?1 : t,1} B (x1, x2) ! (((), x2), x1)
FOCUS-SUM1 : {? : t,1 + ?} t^ 9?1.{? : [?1] + ?} * {?1 : t,1} B (inj1 x) ! (inj1 (), x)

Regions

NEW-GRP : ; <= 9!1 * * * !n.{!1 : t,1} * . . . * {!n : t,n} B () A~ (map empty, . . . , map empty)
ADOPT-GRP : [?] * {? : t,} * {! : t,} <= [!] * {! : t,} B ((), x, m) A~ let k = map fresh m in

(k, map add (m, k, x))
FOCUS-GRP : [!] * {! : t,} <= 9?.[?] * {? : t,} * {! : t, \ ?} B (k, m) A~ ((), map get (m, k), (m, k)))
UNFOCUS-GRP : {? : t,} * {! : t, \ ?} <= {! : t,} B (x, (m, k)) A~ map set (m, k, x)

Embedding9.

EMBED : {? : (9o"".t,)} t^ 9o"".{? : t,} B x ! x*.
EMBED : {? : (t, * C)} t^ {? : t,} * C B x ! x

Administrative*.

COMM-CAP : C1 * C2 t^ C2 * C1 B (x1, x2) ! (x2, x1)*.
ASSOC : (o * C1) * C2 t^ o * (C1 * C2) B ((x1, x2), x3) ! (x1, (x2, x3))*.
NEUTRAL : o * ; t^ o B (x, ()) ! x9.

COMM : 9o""1.9o""2.o t^ 9o""2.9o""1.o B x ! x9.
EXTRUDE-L : o1 * (9o"".o2) t^ 9o"".(o1 * o2) B x ! x9.
EXTRUDE-R : (9o"".o1) * o2 t^ 9o"".(o1 * o2) B x ! x

Figure 13. Subtyping rules and their translation

permitting n > 1 is useful. The capabilities over these emptyregions are translated as empty maps.

ADOPT-GRP dissolves a singleton region ? into an existinggroup region

!. The capability over ? is lost. The unique inhabitantof
? henceforth becomes an inhabitant of !. Its type is coercedfrom

[?] to [!], so as to reflect this change. In the target calculus,the capability {

! : t,} is translated to an association map m, whichrepresents the initial state of region

!. The capability {? : t,} istranslated to a value
x, which represents the state of the object ?.Because
? is a singleton region, the object itself is translated tounit. An application of "map fresh" produces a key

k that doesnot already appear in the domain of
m. Then, an application of"map add" extends the association map

m with x at k, yielding anupdated representation of region
!. Finally, because ! is a groupregion, the adopted object, at type

[!], is translated to the key k.
FOCUS-GRP isolates a particular object out of a group region:this creates a fresh singleton region, and disables the group region.

UNFOCUS-GRP undoes this effect. This mechanism was explainedearlier ($2.3; Figure 14). In the target language, a disabled capability {! : t, \ ?} is translated to a pair (m, k), where the associationmap

m represents the full capability {! : t,}, and the key k repre-sents the index of object

? within region !. Intuitively, the meaningof the pair
(m, k) is that the state of region ! is m, except at key k,where the value is stale and must not be accessed.

FOCUS-GRP cre-ates such a pair
(m, k), which forms the translation of {! : t, \ ?},and looks up the map

m at index k, so as to form the translation of{
? : t,}. UNFOCUS-GRP requires a pair (m, k), which represents{
! : t, \ ?}, and updates m at k with a new value x, which repre-sents {

? : t,}. The value previously found in m at k, which at thispoint is stale, is overwritten.

A typical imperative coding pattern consists in focusing on anobject

?, updating it via a side effect, then de-focusing. In thetranslation, this corresponds to looking up a value at some key

kin an association map, computing an updated value, then updating

the map at key k with that new value. Such a sequence is a typicalfunctional programming idiom.

9 2008/7/2

focus-ref
ref

oe

` `

ref

oe

oe1

focus-pair1
`1 `2 `1 `2

pair pair

oe oe

oe1

focus-sum1
`1 ?

inj1

oe

`1 ?

inj1

oe

oe1

focus-grp

`

`

ae

`
[ae] [oe]

`

`

ae

oe
`

Figure 14. Illustration of the focus operations
Embedding *.EMBED and 9.EMBED help attach regions and ca-pabilities to the components of a data structure, and, conversely,
extract them back out. For instance, they can convert the conjunc-tion 9

!.({? : t,} * {! : t,0}) to the atom {? : 9!.(t, * {! : t,0})},where region

! is owned by region ?. This mechanism allows re-gions to form an ownership hierarchy. Because both inner and outer

conjunctions are translated as pairs, the coercions that witness theserules are the identity.

Administrative The * connective is commutative, when appliedto two capabilities, associative, and admits the null capability ; as
a neutral element. Moreover, existential binders can commute andbe extruded out of conjunctions.

6.3 Subtyping under a context
Subtyping is applicable under a context. Most of the correspondingrules are standard, thus not shown (see the online addendum [1]).

Subtyping references The "ref" type constructor is covariant.This might come as a shock, as it is well-known that soundness
requires references to be invariant in extensions of simply-typed y"-calculus with references and subtyping [16, p. 198]. Here, however,
"ref" is not a value type constructor. Instead, it is a memory typeconstructor: it is linear. It is safe to weaken the type of the contents
of a reference, for the same reason that it is safe to perform a strongupdate: there exists only one copy of this type.

Subtyping recursive types For comparing recursive types, we userules that closely resemble those of Brandt and Henglein [5]. The
rules involve subtyping contexts \Sigma , which are sets of subtypingassumptions. Two symmetric rules allow unfolding a recursive
type, so as to compare it with some other type. The left rule is:

SUB-REC-LEFT

o1 = uo"".o \Sigma , (o1 <= o2 B x ) ` ([o"" ! o1] o) <= o2 B w

\Sigma  ` o1 <= o2 B ux.w
The conclusion of the rule appears as part of the subtyping contextin the premise. This is sound, because all recursive types are contractive. The corresponding coercion is a recursive function. (Be-cause

w is necessarily an abstraction, (ux.w) is a well-formed re-cursive

y"-abstraction.) A standard "fold/unfold" axiom is provable:

uo"".o t^ ([o"" ! uo"".o] o) B y"x. x

7. Soundness of the type system and translation
We use a syntactic approach to soundness, via subject reductionand progress theorems. We prove roughly the following simulation

statement, which subsumes subject reduction: if a well-typed term t

is translated as u, and if t reduces to t0, then t0 is well-typed, and itstranslation

u0 is a reduct of u. Formalizing this statement requiresthe introduction of several new definitions.

Region maps We must explain how to type-check and translatesource configurations, rather than just source terms. To that end,
we introduce an oracle, known as a region map, which records thecontents of regions. (This is analogous to a standard type soundness
proof for ML [16, $13.4], where an oracle, known as a store typing,records the types of the memory locations.) A region map

u maps asingleton region
? to a closed source value u[?], and maps a groupregion
! to a map u[!] from keys to closed source values.The typing and translation judgements are extended so as to

carry u as a parameter. This new parameter is ignored by the typingand translation rules shown earlier. It is, however, exploited in the
following two new rules, which assign type [o""] to an inhabitant ofregion

o"", and translate it appropriately:

SNG

u; \Delta  ` u[?] : [?] B ()

GRP

u; \Delta  ` u[!][k] : [!] B k
Executable terms Moreover, we introduce a new judgement fortyping and translating closed source terms. The judgement:

s; u; _o""; P ||= t : A^ B u
states that the term t has type A^ and is translated as the term
u. This judgement is relative to a store s, a region map u, aset of type variables

_o"" (in the absence of a value restriction, auniversal quantifier introduction rule is an evaluation context, hence

execution takes place in the context of a set of type variables), anda set

P of locations and regions that the term t consumes (thatis, must initially own). The derivation rules for this judgement are

quite similar to those that define the original typing judgement for(potentially opened) terms. An exception is the frame rule, which,
for this judgement, takes the form:

EXE-FRAME

s; u; _o""; P1 ||= t : A^ B u s; u ` C " P2 B w

s; u; _o""; (P1 ] P2) ||= t : (A^ * C) B (u, w)
This rule states that, if the term t consumes P1 to produce a resultof type

A^, and if the capability C controls exactly the locations andregions in the set

P2, then, when provided with the disjoint unionof
P1 and P2, the term t produces a result of type (A^ * C). Theright-hand premise involves another judgement form, which typechecks and translates a capability. By lack of space, this judgementis not described here; see the online addendum [1] for details.

Monotonicity A last ingredient is needed to state soundness. Weintroduce the notation

(s, u)\P v (s0, u0)\P0 to indicate that, as

10 2008/7/2

a term is executed, regions can only grow, and that a term cannotaffect or acquire a piece of state that it initially does not own. This
notation is an abbreviation for a conjunction of three statements:

(1) u v u0 (2) s\P t, s0\P0 (3) u\P t, u0\P0
Proposition (1) states that the region map grows: singleton regionsremain fixed, and group regions grow. It is defined as follows:

u v u0 := ! 8 ? 2 dom(u), u[?] = u0[?]8 ! 2 dom(u), u[!] t, u0[!]
Propositions (2) and (3) are set-theoretic inclusions between re-strictions of finite maps. Proposition (2) means that for every memory location l in (dom(s) \ P ), the value s0[l] equals the value s[l](locations not owned cannot be affected) and

l is not in P 0 (loca-tions not owned cannot be acquired). Proposition (3) is an analogous statement about regions.
Stating soundness We can now formally state that a reductionstep in a well-typed source term is matched by one or more reduction steps in the translation of this term. The facts that regionsgrow with time, and that inaccessible locations and regions are unaffected and remain inaccessible, are required for the proof by in-duction to go through.

Theorem (Simulation) If the following hypotheses hold:!

t / s -! t0 / s0
s; u; _o""; P ||= t : A^ B u

then there exists u0, P 0 and u0 such that8!:

u -!+ u0
s0; u0; _o""; P 0 ||= t0 : A^ B u0
(s, u)\P v (s0, u0)\P0 e,

Conclusion Independently, we prove a progress theorem: a well-typed and irreducible source term is necessarily a value. Furthermore, we prove that the translation of a value, considered as a term,must converge to a value. By combining these facts with the simulation theorem, we conclude that the type system is sound (well-typedprograms do not go wrong), and that the type-directed translation
is meaning-preserving (a program and its translation either bothdiverge, or converge to related values).

8. Related work
Capabilities The Calculus of Capabilities [7] introduces a typesystem with non-linear values and linear capabilities. Regions are

sets of memory locations (of possibly heterogeneous type). As inthis paper, a capability represents an exclusive right to access and
free the contents of a region. The use of capabilities allows ar-bitrary separation of allocation and deallocation points, a significant gain in expressiveness compared to earlier work by Tofte andTalpin [20], where regions have lexical scope. The Calculus of Capabilities enjoys a complete collection property. Thus, it does notrequire garbage collection: instead, it has runtime support for regions. Specifically, the calculus has a primitive type of region han-dles, as well as primitive operations for creating, extending, and
freeing regions. In contrast, because we are interested in a high-level language, where ownership and deallocation of immutable
data structures are implicit, we omit this machinery and rely ongarbage collection.

The calculus of Alias Types [19] uses singleton capabilities todescribe the structure of the store at the level of individual objects
and support strong update. A later paper [22] adds the ability toembed capabilities within data structures, which effectively gives
rise to an ownership hierarchy.

Building upon these works, F"ahndrich and DeLine's Vault [12]allows reasoning about both aliased and unique objects. Furthermore, Vault introduces adoption and focus. Together with thesemechanisms comes the ability for an aliased object to own a unique
object. The soundness of the type system is not argued, but Boylandand Retert later prove the soundness of a similar system, where
focus works at the level of object fields [4]. Our presentation ofadoption and focus is closely inspired by F"ahndrich and DeLine's
work, with two simplifications in the presentation, which we feelare important. First, F"ahndrich and DeLine conflate regions and
objects: every variable ! serves both as the name of a unique ob-ject and as the name of a group region, which holds the object's
adoptees. We avoid this unfortunate identification between a staticentity (a region) and a dynamic one (an object). Second, F"ahndrich
and DeLine require every object to keep a list of its adoptees atruntime. This list is part of the runtime machinery that is used to
avoid garbage collection. In our case, no such list is needed. Ourpresentation of adoption as a subtyping rule emphasizes the fact
that adoption has no computational content.

L3, a Linear Language with Locations [2], is a linear y"-calculusextended with support for references and strong updates. Following

Alias Types [7], pointers and capabilities are distinguished. Point-ers are typically unrestricted, while capabilities are linear. In contrast with the capabilities found in Alias Types and in this paper,which are static entities, capabilities in

L3 are values: they exist atruntime. This makes quite a difference. In our system, the only runtime operations are "ref", "get", and "set"; everything else, includ-ing the operations that move capabilities around and re-organize the
ownership hierarchy (adoption, the various forms of focus, embed-ding, etc.), takes the form of subtyping axioms, which in the source
calculus have no computational content.Not every well-typed ML program is well-typed in our system.
One tentative way of translating an ML program into our systemwould be to place all references in a single, global region, and
to thread a capability over that region throughout the program.However, that would require a heterogeneous region, while our
regions are homogeneous.Adopting the second author's higher-order anti-frame rule [17]
does allow encoding every ML program. However, it is not yet clearhow to extend our functional translation in order to support this
extra rule.
Monads Monads [13, 21] and effects [20] offer a way of staticallycontrolling which regions of memory are read or written by a

program term. Monads and effects are closely related. We haveexplained earlier ($2.2) how an effect is just a capability that is
required and returned. A monad is just a universe of computationswith a fixed effect: that is,

M o"" can be viewed as an abbreviationfor
(unit !C o""), for a fixed capability C. With this in mind, theconnection between linear types and monads imagined by Chen

and Hudak [6] can be made precise in our system. A monad thatencapsulates a mutable data structure, such as a linked list or a
binary search tree, can be defined by the programmer (in termsof a concrete capability

C for the data structure) and, thanks toexistential quantification, given an abstract interface (so, in the end,

only an abstract type constructor M is published).Such a precise connection between effects, monads, and a linear type system is already fleshed out, in two stages, by Ahmed,Fluet, and Morrisett [10, 11]. First, Fluet and Morrisett [10] encode Tofte and Talpin's type and effect system into F RGN, an ex-tension of

F with a region-indexed monad. Second, Ahmed, Fluet,and Morrisett [11] encode

F RGN into y"rgnUL, a linear y"-calculusequipped with regions and capabilities; their encoding of the monad

is the one suggested above. Much of the complexity of the firstencoding stage lies in the fact that Tofte and Talpin's effects are
sets of regions, while the monad in F RGN is indexed with a sin11 2008/7/2

gle region. This difficulty is resolved by exploiting the fact that re-gions have nested lifetimes, and by introducing region subtyping in
F RGN. It seems that it could be avoided entirely by encoding Tofteand Talpin's system directly into

y"rgnUL.Is it possible, analogously, to encode Tofte and Talpin's type

and effect system into our type system? Maybe, but there is asnag. Whereas Tofte and Talpin's system, as well as

y"rgnUL, haveheterogeneous regions, our system has homogeneous regions: a

group region stores objects of a single, fixed type. It is an openquestion whether the former can be encoded into the latter.

Translations into pure calculi The monadic translation [13, 21]is perhaps the most famous translation of imperative programs into
purely functional ones. Filli^atre [8] presents a refined version ofthis translation, where monads are indexed with effects, so that the
store consists of multiple, independent fragments. This technique,implemented in the Why tool [9], does not support aliasing. The
translations of Java and C into Why implemented in the Krakatoaand Caduceus tools [9] deal with aliasing by introducing arrays that
play the same role as our maps. These arrays are global, however:there is one such array per record field in the source program.

O'Hearn and Reynolds translate two variants of Algol into apolymorphic linear

y"-calculus [15]. Linearity is used to establishthe fact that store fragments are never duplicated, and are created and destroyed in well-identified places. On the one hand, ourtranslation is more ambitious, since our source calculus supports
dynamic memory allocation. On the other hand, we have not at-tempted to exploit linearity in the target calculus. It must be true
that our store fragments are linear, but we have not yet proved thisfact. A technical difference between the two translations is in the
treatment of the FRAME rule. O'Hearn and Reynolds encode it interms of polymorphism (a full store is passed down into

FRAME, ata partially abstract type), whereas our translation is direct (only a

fragment of the store is passed down).
Program logics Separation Logic [18] and Stateful Views [23]are related to one another, and to our work. In fact, the syntaxes
of separation logic formulae, of stateful views, and of our ca-pabilities, share a basic fragment: all three have constructs for
empty heap, singleton heap, separating conjunction, and quantifi-cation over (static names for) memory locations. Neither of the two
systems cited above has primitive group capabilities or primitivemechanisms for adoption and focus.

The Spec# static program verifier [3] extracts proof obligationsout of programs expressed in a variant of the C# programming
language. Like our type system, it relies on an ownership hierarchy,which can evolve dynamically. Its "pack" and "unpack" constructs,
which attach and detach an owned object and an owner object, servethe same purpose as the subtyping axiom

FOCUS-REF in this paper.We share with the authors of Hoare Type Theory (HTT) [14]

a motivation: reasoning about imperative programs with dynamicmemory allocation. HTT incorporates Hoare-style specifications
into types. In keeping with a tradition of type theory, HTT blursthe distinction between code, types, and specifications, whereas we
intend to preserve this distinction: we are not convinced that it isuseful to let effectful code appear within specifications.

9. Future work
In this paper, we have focused on just code and types. In the future,we plan to add support for Hoare-style specifications on top of our

type system. Our specification language will be a pure type the-ory, such as the Calculus of Inductive Constructions. This would
allow decorating imperative programs with logical assertions andextracting proof obligations, while taking advantage of the separation information provided by the type system.

We also wish to further augment the expressiveness of our sys-tem. There are several interesting candidates for new type-theoretic
mechanisms. Multi-focus permits simultaneously focusing on mul-tiple elements of a group region, as long as they are provably distinct. Fusion, a generalization of adoption, dissolves an entire re-gion into another region. These mechanisms are more complex than
those presented in this paper. They involve new forms of capabili-ties, and entail proof obligations: that is, the translated program is
equivalent to the source program only up to validation of certainassertions embedded in the translated code.

References

[1] Arthur Chargu'eraud and Franc,ois Pottier. Technical appendix.

http://arthur.chargueraud.org/research/2008/icfp/.

[2] Amal Ahmed, Matthew Fluet, and Greg Morrisett. L3: A linearlanguage with locations. Fundamenta Informaticae, 77(4), 2007.

[3] Mike Barnett, Rob DeLine, Manuel F"ahndrich, K. Rustan M. Leino,and Wolfram Schulte. Verification of object-oriented programs with

invariants. Journal of Object Technology, 3(6), 2004.
[4] John Tang Boyland and William Retert. Connecting effects anduniqueness with adoption. In POPL, pages 283-295, January 2005.

[5] Michael Brandt and Fritz Henglein. Coinductive axiomatization ofrecursive type equality and subtyping. Fundamenta Informaticae,

33:309-338, 1998.
[6] Chih-Ping Chen and Paul Hudak. Rolling your own mutable ADT--aconnection between linear types and monads. In POPL, 1997.

[7] Karl Crary, David Walker, and Greg Morrisett. Typed memorymanagement in a calculus of capabilities. In POPL, 1999.
[8] Jean-Christophe Filli^atre. Verification of non-functional programsusing interpretations in type theory. JFP, 13(4), 2003.
[9] Jean-Christophe Filli^atre and Claude March'e. The Why/Krakatoa/Ca-duceus platform for deductive program verification. In CAV, volume

4590 of LNCS, 2007.
[10] Matthew Fluet and Greg Morrisett. Monadic regions. JFP, 16(4-5):485-545, 2006.

[11] Matthew Fluet, Greg Morrisett, and Amal Ahmed. Linear regions areall you need. In ESOP, volume 3924 of LNCS, March 2006.
[12] Manuel F"ahndrich and Robert DeLine. Adoption and focus: practicallinear types for imperative programming. In PLDI, 2002.
[13] Eugenio Moggi. An abstract view of programming languages.Technical Report ECS-LFCS-90-113, University of Edinburgh, 1989.
[14] Aleksandar Nanevski, Amal Ahmed, Greg Morrisett, and LarsBirkedal. Abstract predicates and mutable ADTs in Hoare type

theory. In ESOP, LNCS, March 2007.
[15] Peter W. O'Hearn and John C. Reynolds. From Algol to polymorphiclinear lambda-calculus. Journal of the ACM, 47(1):167-223, 2000.

[16] Benjamin C. Pierce. Types and Programming Languages. MIT Press,2002.
[17] Franc,ois Pottier. Hiding local state in direct style: a higher-orderanti-frame rule. In LICS, 2008.
[18] John C. Reynolds. Separation logic: A logic for shared mutable datastructures. In LICS, 2002.
[19] Frederick Smith, David Walker, and Greg Morrisett. Alias types. InESOP, volume 1782 of LNCS, 2000.
[20] Mads Tofte and Jean-Pierre Talpin. Region-based memory manage-ment. Information and Computation, 132(2):109-176, 1997.
[21] Philip Wadler. The essence of functional programming. In POPL,1992.
[22] David Walker and Greg Morrisett. Alias types for recursive datastructures. In TIC, volume 2071 of LNCS, 2000.
[23] Dengping Zhu and Hongwei Xi. Safe programming with pointersthrough stateful views. In PADL, volume 3350 of LNCS, 2005.

12 2008/7/2