

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Math. Struct. in Comp. Science (2004), vol. 14, pp. 97E^141. c\Delta  2004 Cambridge University Press
DOI: 10.1017/S0960129503004122 Printed in the United Kingdom

Type-based termination of recursive deS,nitions
G. B A R T H EA,, M. J. F R A D EC', E. G I M t^E N E Zg*, L. P I N T O||
and T. U U S T A L U\Theta 
A,INRIA Sophia-Antipolis, 2004 route des Lucioles, BP 93,
F-06902 Sophia-Antipolis Cedex, France
C'Dep. de Informt^atica, Universidade do Minho, Campus de Gualtar,
P-4710-057 Braga, Portugal
g*Trusted Logic, 5 rue du Bailliage, F-78000 Versailles, France
and
Instituto de Computacit^on, Universidad de la Rept^ublica, Julio Herrera y Reissig 565,
11300 Montevideo, Uruguay

||Dep. de Matemt^atica, Universidade do Minho, Campus de Gualtar,
P-4710-057 Braga, Portugal
\Theta Dep. de Informt^atica, Universidade do Minho, Campus de Gualtar,
P-4710-057 Braga, Portugal
and
Institute of Cybernetics, Akadeemia tee 21, EE-12618 Tallinn, Estonia

Received 19 December 2000; revised 7 July 2002

This paper introduces \Delta \Delta , a simply typed lambda calculus supporting inductive types and
recursive function deS,nitions with termination ensured by types. The system is shown to
enjoy subject reduction, strong normalisation of typable terms and to be stronger than a
related system \Delta G in which termination is ensured by a syntactic guard condition. The
system can, at will, be extended to support coinductive types and corecursive function
deS,nitions also.

1. Introduction
Background Most functional programming languages (ML, Haskell, and so on) and
proof development systems based on the proofs-as-programs paradigm of logic (Coq,
HOL, PVS, and so on) rely on powerful type theories featuring inductive types such as
natural numbers or lists. These languages come equipped with a mechanism for recursive
deS,nition of functions. However, there are signiS,cant differences between the mechanisms
used in functional programming languages and in proof development systems.

The S,rst difference concerns the termination of recursive functions. While in functional
programming languages recursive functions are allowed to diverge, in proof development
systems non-terminating functions must be banished from the language, as they almost
always lead to logical paradoxes.

The second difference concerns the way in which recursive deS,nitions are introduced.
In functional programming languages, recursive functions are described in terms of a

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 98
pattern-matching operator (case) and a general S,xpoint operator (let-rec). For example,
the addition of two natural numbers could be introduced as follows:

let rec plus n m =

case m of

0 -> n
| (S p) -> (S (plus n p))
end

On the other hand, in the traditional presentations of type-based proof development
systems (Coquand and Paulin 1990; Dybjer 1994; Luo 1994; Nordstrl'om et al. 1990), a
recursive function f : d \Lambda  \Theta  on an inductive type d is deS,ned by means of the elimination
rule of d, where both pattern matching and recursion are built into a single scheme
that ensures termination. In this approach, the function plus can be encoded using the
elimination rule of natural numbers nat elim \Theta  : \Theta  \Lambda  (Nat \Lambda  \Theta  \Lambda  \Theta ) \Lambda  Nat \Lambda  \Theta , which
corresponds to the primitive recursion scheme:

let plus n m = (nat_elim nat n (fun p r -> (S r)) m)
This approach is theoretically sound. However, practice has shown that eliminators are
rather cumbersome to use, whereas case-expressions and S,xpoint expressions lead to more
concise and readable deS,nitions. In looking for a good compromise between termination
and presentation issues, Coquand (1992) suggested that recursors should be replaced by
case-expressions and a restricted form of S,xpoint expressions, see also Gimt^enez (1995).
The restriction is imposed through a predicate Gf on untyped terms. This predicate
enforces termination by constraining all recursive calls to be applied to terms smaller
than the formal argument x of f E^ for instance, a pattern variable issued from a case
expression on x. Hence the restricted typing rule for S,xpoint expressions becomes:

f : Nat \Lambda  \Theta  \Xi  e : Nat \Lambda  \Theta \Xi 

(letrec f = e) : Nat \Lambda  \Theta  if Gf(e) (*)

This alternative approach, called guarded by destructors recursion in Gimt^enez (1995), has
been implemented in the Coq system. Five years of experiments carried out with Coq
have shown that it actually provides much more palatable representations of recursive
functions.

However, the use of an external predicate G on untyped terms suffers from several
weaknesses:

1 The guard predicate is too syntax-sensitive and too weak. The acceptance of a recursive

deS,nition becomes too sensitive to the syntactical shape of its body. Sometimes a small
change in the deS,nition could prevent it from satisfying the guardedness condition.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 99

As an example, consider the following modiS,cation of the plus function, where the
condition is no longer satisS,ed because of the introduction of a redex in the deS,nition:

let comp f g x = (f (g x))
let rec plus n m =

case m of

0 -> n
| (S p) -> (comp S (plus n) p)
end

In addition, the guard predicate rejects many terminating recursive deS,nitions such as
the Euclidean division, AckermannR^s function, or functions that swap arguments, such
as subtyping algorithms for higher-order languages

let rec sub a a' =

case a a' of

(base b) (base b') -> sub_base b b'
| (fun b1 b2) (fun b'1 b'2) -> (sub b'1 b1) && (sub b2 b'2)
| ... -> ...
end

2 The guard predicate is hard to implement and hard to extend. The guardedness condition is among the main sources of bugs in the implementation of the proof system. In
order to improve the number of deS,nitions accepted by the system, the guardedness
condition has become more and more complicated, and thus prone to errors.

Besides, it is easier to extend the type system than to extend the guardedness
condition: type conditions are expressed as local constraints associated to each
construction of the language, whereas the guard predicate yields global constraints.

3 The guard predicate is often deS,ned on normal forms. The guard predicate is often

deS,ned on normal forms only, which renders the typing rule (*) useless in practice.
Subsequently, the typing rule (*) is usually replaced by the more liberal typing rule

f : Nat \Lambda  \Theta  \Xi  e : Nat \Lambda  \Theta \Xi 

(letrec f = e) : Nat \Lambda  \Theta  if Gf(nf e)

where nf is the partial function associating the normal form to an expression. Now the
modiS,ed rule introduces two further complications:

(a) The new guard condition leads to inefficient type-checking. Verifying the guardedness condition makes type-checking less efficient as the body of a recursive
deS,nition has to be reduced in order for it to be checked E^ expanding previously
deS,ned constants like the constant comp in the example above.
(b) The new guard condition destroys strong normalisation. For example, the normal

form of the following deS,nition satisS,es the guardedness condition, but not the
deS,nition itself:

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 100

let K x y = x
let rec diverging_id n =

case n of 0 -> K 0 (diverging_id n)
| (S p) -> S (diverging_id p)
end

There is an inS,nite reduction sequence for the term diverging id 0A,:

diverging id 0 \Lambda  (K 0 (diverging id 0))\Lambda 

(K 0 (K 0 (diverging id 0)))\Lambda 
. . .

One solution for getting around this problem (the solution has been considered
for Coq) is to store recursive deS,nitions with their bodies in normal forms, as
enforced by the rule

f : Nat \Lambda  \Theta  \Xi  e : Nat \Lambda  \Theta \Xi 

(letrec f = (nf e)) : Nat \Lambda  \Theta  if Gf(nf e).

However, the rule has some severe drawbacks:
(1) proof terms become huge;
(2) the expressions being stored are not those constructed interactively by the

user;

(3) the modiS,ed typing rule for S,xpoint expressions is not syntax-directed, that

is, one cannot guess the expression e appearing in the premise from the
conclusion of the rule.

In order to circumvent those weaknesses, some authors have proposed semantically
motivated type systems that ensure the termination of recursive deS,nitions through typing
(Gimt^enez 1998; Amadio and Coupet-Grimal 1998; Barras 1999). The idea, which had
already appeared in MendlerR^s work (Mendler 1991), consists of regarding an inductive
type d as the least S,xpoint of a monotonic operator \Delta L/d on types, and to enforcing
termination of recursive functions by requiring that the deS,nition of f : \Delta \Lambda d \Lambda  \Theta , where \Lambda 
may be thought of as a subtype of d, only relies on structurally smaller function calls,
embodied by a function fih : \Lambda  \Lambda  \Theta . This approach to terminating recursion, which we
call type-based, offers several advantages over the guarded by destructors approach. In
particular, it addresses all the above-mentioned weaknesses.

This paper The purpose of this paper is to introduce \Delta \Delta , a simply typed \Delta -calculus that
supports type-based recursive deS,nitions. Although greatly inspired by previous work
by Gimt^enez (Gimt^enez 1998) and closely related to recent work by Amadio and Coupet
(Amadio and Coupet-Grimal 1998), the technical machinery behind our system puts a
slightly different emphasis on the interpretation of types. More precisely, we formalise the

A, In fact, Coq 7.1 accepts this deS,nition of diverging id!

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 101
notion of type-based termination using a restricted form of type dependency (also known
as indexed types), as popularised by Xi and Pfenning (1998; 1999). This leads to a simple
and intuitive system that is robust under several extensions, such as mutually inductive
datatypes and mutually recursive function deS,nitions; however, such extensions are not
treated in this paper.

The basic idea is to proceed as follows:

D^ First, every datatype d is replaced by a family of approximations indexed over a set

of stages, which are used to record a bound on the R'depthR^ of values. Here, we adopt
a simple-minded approach and let stages range over the syntax

s := Z^ -- \Delta s -- \Sigma 
where Z^ ranges over stage variables, the hat operator \Delta L/ is a function mapping a stage
to its R'successorR^ and \Sigma  is the stage at which the iterative approximation process
converges to the datatype itself.

D^ Second, a recursive deS,nition of a function, say f : d \Lambda  \Theta , should be given by a term

e constructing a function g\Upsilon  : d\Delta Z^ \Lambda  \Theta  from g : dZ^ \Lambda  \Theta , where Z^ ranges over stages (in
other words, e should be stage-polymorphic).

In order to illustrate the machinery involved, consider the inductive type Nat whose
constructors are o : Nat and s : Nat \Lambda  Nat. The typing rules are

\Xi  o : Nat\Delta s \Xi 

n : Nats\Xi 
s n : Nat\Delta s

and, as an instance of the subsumption rule,

\Xi  n : Nats\Xi 

n : Nat\Delta s

Finally, recursive functions from Nat to \Theta  are constructed using the following typing rule:

f : NatZ^ \Lambda \Theta  \Xi  e : Nat\Delta Z^ \Lambda  \Theta \Xi 

(letrec f = e) : Nat \Lambda  \Theta 

where Z^ is fresh with respect to \Theta . As we shall show later, such recursive functions
are terminating and, despite its simplicity, this mechanism is powerful enough to capture
course-of-value primitive recursion. Conformance with the scheme, and hence termination,
is enforced through types.

Organisation of the paper The remainder of this paper is organised as follows. In Section 2
we present the system \Delta \Delta  formally. In Section 3 we show that \Delta \Delta  is well-behaved, and, in
particular, enjoys subject reduction and strong normalisation. In Section 4 we introduce
\Delta G and prove that \Delta \Delta  strictly extends the system \Delta G. In Section 5 we consider an extension
of \Delta \Delta  with coinductive types. We review related work in Section 6 and give conclusions in
Section 7.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 102
2. The System \Delta \Delta 
In this section we will introduce \Delta \Delta , a simply typed lambda calculus featuring strongly
positive, S,nitely iterated parametric inductive types (in the sense of, for example, MartinLl'of (1971)) and type-based termination of recursive deS,nitions. The calculus is `a la Curry:
terms come without any type annotations.

2.1. Datatypes and constructors
Datatypes and constructors are named: we assume two denumerable sets D of datatype
identiS,ers and C of constructor identiS,ers. We assume a stratiS,cation on datatypes that
ensures that the dependency relation between datatypes is well-founded. Hence, each
datatype d is assigned a stratum str(d) \Phi  \Delta . Datatypes and constructors may only
accept a S,xed number of arguments, so we stipulate that every datatype identiS,er d
and constructor c have S,xed arities ar(d) \Phi  \Delta  and ar(c) \Phi  \Delta  that indicate the number
of parameters taken by d and c, respectively. Finally, we require that every datatype
d \Phi  D comes equipped with a vector C(d) \Psi  C of constructors, and if d \Omega = d\Upsilon , then
C(d) ff C(d\Upsilon ) = \Delta .

For the sake of clarity, we adopt the following naming conventions: d, d\Upsilon , di, . . . range
over D and c, c\Upsilon , ci, . . . range over C.

2.2. Terms and reduction
Terms are built from variables, abstractions, applications, constructors, case-expressions
and recursive deS,nitions. Assume we have a denumerable set VE of (object) variables, and
let x, x\Upsilon , xi, y, . . . range over VE.

Notation 2.1. For every set A, we let A* denote the set of lists over A, and fifl denote
the empty list. \Xi a ranges over A* if a ranges over A. #\Xi a denotes the length of \Xi a, and \Xi a[i]
denotes, when it exists, the ith element of \Xi a. For convenience, we will sometimes write
lists in the form fia1, . . . , anfl instead of a1 . . . an.

DeS,nition 2.2 (Terms). The set E of terms is given by the abstract syntax

e, e\Upsilon  ::= x -- \Delta x. e -- e e\Upsilon  -- c -- case e\Upsilon  of -\Xi c ffi \Xi e"" -- (letrec x = e)
where in the clause for case-expressions it is assumed that \Xi c = C(d) for some d \Phi  D.
Free and bound variables, substitution, and so on, are deS,ned as usual. We let e[x := e\Upsilon ]
be the result of replacing all free occurrences of x in e by e\Upsilon .

The reduction calculus is given by \Pi -reduction for function application, \Sigma -reduction for
case analysis and t,-reduction for unfolding recursive deS,nitions, which is only allowed in
the context of application to a constructor application.

DeS,nition 2.3 (Reduction calculus).
1 \Pi -reduction \Lambda \Pi  is deS,ned as the compatible closure of the rule

(\Delta x. e) e\Upsilon  \Lambda \Pi  e[x := e\Upsilon ].

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 103
2 \Sigma -reduction \Lambda \Sigma  is deS,ned as the compatible closure of the rule

case (ci \Xi a) of -c1 ffi e1 -- . . . -- cn ffi en"" \Lambda \Sigma  ei \Xi a
where #\Xi a = ar(ci).
3 t,-reduction \Lambda t, is deS,ned as the compatible closure of the rule

(letrec f = e) (c \Xi a) \Lambda t, e[f := (letrec f = e)] (c\Xi a)
where #\Xi a = ar(c).
4 \Pi \Sigma t,-reduction \Lambda \Pi \Sigma t, is deS,ned as \Lambda \Pi  ffl \Lambda \Sigma  ffl \Lambda t,.

Remark 2.4. Our formulation of the \Pi - and t,-reduction rules relies on a variable
convention: in the \Pi -rule, the bound variables of e are assumed to be different from
the free variables of e\Upsilon ; in the t,-rule, the bound and the free variables of e are assumed
to be different.

The mechanics of the reduction calculus is illustrated by the following example.
Example 2.5. Consider the inductive type of natural numbers Nat with C(Nat) = -o, s"".
Let plus i (letrec plus = \Delta x. \Delta y. case x of -o ffi y -- s ffi \Delta x\Upsilon . s (plus x\Upsilon  y)""). The following
is a reduction sequence that computes one plus two, where, as usual, \Delta \Pi  denotes the
reT^exive and transitive closure of \Lambda \Pi .

plus (s o) (s (s o))\Lambda 

t, (\Delta x. \Delta y. case x of -o ffi y -- s ffi \Delta x\Upsilon . s (plus x\Upsilon  y)"") (s o) (s (s o))
\Delta \Pi  case s o of -o ffi s (s o) -- s ffi \Delta x\Upsilon . s (plus x\Upsilon  (s (s o)))""\Lambda 

\Sigma  (\Delta x\Upsilon . s (plus x\Upsilon  (s (s o)))) o\Lambda 
\Pi  s (plus o (s (s o)))\Lambda 

t, s ((\Delta x. \Delta y. case x of -o ffi y -- s ffi \Delta x\Upsilon . s (plus x\Upsilon  y)"") o (s(s o)))
\Delta \Pi  s (case o of -o ffi s (s o) -- s ffi \Delta x\Upsilon . s (plus x\Upsilon  (s (s o)))"")\Lambda 

\Sigma  s (s (s o))

2.3. Types and typing system
We now assume we are given two denumerable sets VT of type variables and VS of
stage variables, and adopt the naming convention that \Lambda , \Lambda \Upsilon , \Lambda i, \Pi , \Upsilon , . . . range over VT, and
Z^, j, . . . range over VS. Proceeding from these, we deS,ne stage and type expressions. Stage
expressions are built of stage variables, a symbol for the successor function on stages, and
a symbol for the limit stage. A type expression is either a type variable, a function type
expression or a datatype approximation expression.

DeS,nition 2.6 (Stages and types).
1 The set S of stage expressions is given by the abstract syntax:

s, r ::= Z^ -- \Sigma  -- \Delta s.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 104
2 The set T of type expressions is given by the abstract syntax:

\Psi , \Omega  ::= \Lambda  -- \Omega  \Lambda  \Psi  -- ds \Xi \Omega 
where in the last clause, it is assumed that the length of \Xi \Omega  is exactly ar(d).
Notation 2.7. Very often we write \Xi \Omega  \Lambda  \Psi  as an abbreviation for \Omega 1 \Lambda  . . . \Lambda  \Omega n \Lambda  \Psi , and d \Xi \Psi 
as an abbreviation for d\Sigma  \Xi \Psi .

In order to present the typing rules for constructor and case expressions, we have to
have a means for S,xing the intended typings of the constructors. To this end, we introduce
notions of constructor scheme and constructor scheme instantiation.

DeS,nition 2.8 (Constructor scheme). A constructor scheme is a triple (\Upsilon ,\Xi \Lambda ,\Xi \Psi ) where
\Upsilon ,\Xi \Lambda  \Phi  VT and \Xi \Psi  \Phi  T such that:

1 Each \Psi i is positive with respect to \Upsilon , see Figure 5.
2 Each \Psi i is positive with respect to each \Lambda j, see Figure 5.
3 \Xi \Lambda , \Upsilon  are pairwise distinct.
4 \Xi \Lambda , \Upsilon  are the only type variables that can occur in \Xi \Psi .
5 There are no occurrences of stage variables in \Xi \Psi .

The set of constructor schemes is denoted by CS.

Observe that type parameters can only appear positively in the argument types of the
constructors. This makes it possible to parameterise the type of lists with respect to the
type of elements, binary trees with respect to the type of node labels, and arbitrarily
branching trees with respect to the type of node labels, but not with respect to the
branching type.

In the rest of this paper, we assume a map D : C \Lambda  CS that respects arities: formally,
for every datatype d and c \Phi  C(d),

D(c) = (\Upsilon ,\Xi \Lambda ,\Xi \Psi ) with #\Xi \Lambda  = ar(d) and #\Xi \Psi  = ar(c).
This mapping has to satisfy the following condition: if c \Phi  C(d) and D(c) = (\Upsilon ,\Xi \Lambda ,\Xi \Psi ),
any d\Upsilon  \Phi  D appearing in \Xi \Psi  satisS,es str(d\Upsilon ) < str(d). This ensures that only S,nitely iterated
inductive deS,nitions are permitted (excluding mutual induction) and is made use of in
the model construction (DeS,nition 3.23) in the proof of strong normalisation.

Constructor schemes specify the possible typings for the arguments of each given
constructor of every possible datatype: if \Upsilon  is an approximation of the datatype, and \Xi \Lambda 
are the parameters of the datatype, then \Xi \Psi  is a possible typing for the arguments of the
constructor.

Example 2.9. Consider Bool, Nat, List, Tree, Ord \Phi  D. We have

C(Bool) = -true, false"" D(true) = (\Upsilon , fifl, fifl)D(false) = (\Upsilon , fifl, fifl)
for the datatype of booleans;

C(Nat) = -o, s"" D(o) = (\Upsilon , fifl, fifl)D(s) = (\Upsilon , fifl, fi\Upsilon fl)

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 105

(reT^) s \Theta  s (trans) s \Theta  r r \Theta  ps \Theta  p (hat) s \Theta  \Delta s (infty) s \Theta  \Sigma 
Fig. 1. Stage comparison rules

(reT^) \Psi  j \Psi  (data) s \Theta  r \Omega i j \Omega \Upsilon i (1 \Lambda  i \Lambda  ar(d))

ds\Xi \Omega  j dr\Xi \Omega \Upsilon 

(func) \Omega \Upsilon  j \Omega  \Psi  j \Psi \Upsilon \Omega \Lambda \Psi  j \Omega \Upsilon  \Lambda \Psi \Upsilon 

Fig. 2. Subtyping rules

for the datatype of natural numbers;

C(List) = -nil, cons"" D(nil) = (\Upsilon , fi\Lambda fl, fifl)D(cons) = (\Upsilon , fi\Lambda fl, fi\Lambda , \Upsilon fl)
for lists;

C(Tree) = -branch"" D(branch) = (\Upsilon , fi\Lambda fl, fi\Lambda , List \Upsilon fl)
for S,nitely branching trees; and

C(Ord) = -zero, succ, lim""

D(zero) = (\Upsilon , fifl, fifl)
D(succ) = (\Upsilon , fifl, fi\Upsilon fl)
D(lim) = (\Upsilon , fifl, fiNat \Lambda  \Upsilon fl)

for ordinals (or more exactly, for ordinal notations).

Each particular legal typing for the arguments of a constructor is obtained by
instantiating the associated constructor scheme. The concept of instance of a constructor
scheme is formally deS,ned as follows.

DeS,nition 2.10 (Instance). Let d \Phi  D, c \Phi  C(d), s \Phi  S and \Xi \Omega  \Phi  T such that #\Xi \Omega  = ar(d).
Assume D(c) = (\Upsilon ,\Xi \Lambda ,\Xi \Psi ). An instance of c with respect to s and \Xi \Omega  is deS,ned as follows

Instsc \Xi \Omega  = \Xi \Psi [\Upsilon  := ds\Xi \Omega ][\Xi \Lambda  := \Xi \Omega ].
We now turn to the typing system. We introduce a comparison relation on the stages.
Importantly, the stage comparison rules state that all stages beyond the limiting stage are
equivalent. On top of the stage comparison relation, another set of rules deS,nes a subtyping
relation on types. A crucial fact stated by these rules is that a given approximation of a
datatype is always included in the next one.

DeS,nition 2.11 (Stage comparison and subtyping). \Omega  is a subtype of \Psi , written \Omega  j \Psi , is
deS,ned by the rules of Figure 2, where s \Theta  r is deS,ned by the rules of Figure 1.

Notation 2.12. We write \Xi \Psi  j \Xi \Omega  if #\Xi \Psi  = #\Xi \Omega  and \Psi [i] j \Omega [i] for i = 1..#\Xi \Psi .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 106
Lemma 2.13. If \Psi  j \Omega  and \Omega  j \Theta , then \Psi  j \Theta .
Lemma 2.14. If \Delta r \Theta  \Delta s, then r \Theta  s.

Proof. By induction on the proof of p \Theta  \Delta s, one can show that p \Theta  \Delta s implies p \Theta  s or
p = \Delta s, from which the claim can be inferred by instantiating p = \Delta r.

Lemma 2.15. If r \Theta  s, then Instrc \Xi \Omega  j Instsc \Xi \Omega .

In order to deS,ne the typing relation between terms and type expressions, we need the
concepts of context and judgment.

DeS,nition 2.16 (Contexts and judgments).
1 A context is a S,nite sequence x1 : \Psi 1, . . . , xn : \Psi n, where x1, . . . , xn are pairwise disjoint

(object) variables and \Psi 1, . . . , \Psi n are types.
2 A typing judgment is a triple of the form \Lambda  \Xi  e : \Psi , where \Lambda  is a context, e is a term

and \Psi  is a type expression.

The deS,nition of the typing relation itself depends on that of subtyping.
DeS,nition 2.17 (Typing).
1 A typing judgment is derivable if it can be inferred from the rules of Figure 3 where

the positivity condition Z^ pos \Psi  in the (rec) rule is deS,ned in Figure 4.
2 A term e \Phi  E is typable if \Lambda  \Xi  e : \Psi  is derivable for some context \Lambda  and type \Psi .

The rules (var), (abs) and (app) come from the standard simply typed \Delta -calculus. The
rule (sub) is present in any \Delta -calculus with subtyping and provides a linkage between the

(var) \Lambda  \Xi  x : \Psi  if (x : \Psi ) \Phi  \Lambda 
(abs) \Lambda , x : \Omega  \Xi  e : \Psi \Lambda  \Xi  \Delta x. e : \Omega \Lambda \Psi 
(app) \Lambda  \Xi  e : \Omega \Lambda \Psi  \Lambda  \Xi  e\Upsilon  : \Omega \Lambda  \Xi  e e\Upsilon  : \Psi 
(cons) \Lambda  \Xi  c : Insts

c \Xi \Omega \Lambda d\Delta s\Xi \Omega 

if c \Phi  C(d)

(case) \Lambda  \Xi  e\Upsilon  : d\Delta 

s\Xi \Omega  \Lambda  \Xi  ei : Instsc

i \Xi \Omega  \Lambda \Theta  (1 \Lambda  i \Lambda  n)

\Lambda  \Xi  case e\Upsilon  of -c1 ffi e1 -- . . . -- cn ffi en"" : \Theta  if C(d) = -c1, . . . , c

n""

(rec) \Lambda , f : d

Z^\Xi \Omega \Lambda \Theta  \Xi  e : d\Delta Z^\Xi \Omega  \Lambda \Theta [Z^ := \Delta Z^] Z^ pos \Theta 

\Lambda  \Xi  (letrec f = e) : ds\Xi \Omega \Lambda \Theta [Z^ := s] if Z^ not in \Lambda ,\Xi \Omega 

(sub) \Lambda  \Xi  e : \Psi  \Psi  j \Psi \Upsilon \Lambda  \Xi  e : \Psi \Upsilon 

Fig. 3. Typing rules for \Delta \Delta 

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 107

(sp1) Z^ pos \Lambda 
(sp2) Z^ neg \Omega  Z^ pos \Psi Z^ pos \Omega  \Lambda  \Psi 
(sp3) Z^ pos \Omega i (1 \Lambda  i \Lambda  ar(d))Z^ pos ds\Xi \Omega 

(sn1) Z^ neg \Lambda 
(sn2) Z^ pos \Omega  Z^ neg \Psi Z^ neg \Omega  \Lambda  \Psi 
(sn3) Z^ nocc s Z^ neg \Omega i (1 \Lambda  i \Lambda  ar(d))Z^ neg ds\Xi \Omega 

Fig. 4. Positive and negative occurrences of a stage variable

(pos1) \Pi  pos \Lambda 
(pos2) \Pi  neg \Omega  \Pi  pos \Psi \Pi  pos \Omega  \Lambda  \Psi 
(pos3) \Pi  pos \Omega i (1 \Lambda  i \Lambda  ar(d))\Pi  pos ds\Xi \Omega 

(neg1) \Pi  \Omega = \Lambda \Pi  neg \Lambda 
(neg2) \Pi  pos \Omega  \Pi  neg \Psi \Pi  neg \Omega  \Lambda  \Psi 
(neg3) \Pi  neg \Omega i (1 \Lambda  i \Lambda  ar(d))\Pi  neg ds\Xi \Omega 

Fig. 5. Positive and negative occurrences of a type variable
subtyping and typing relations. The remaining rules E^ (cons), (case) and (rec) E^ deserve
some brief comments.

The (cons) rule says that applying a constructor of a given datatype to values in an
approximation of the datatype gives a value that is guaranteed to be an element in the
next approximation. The (case) rule says that the converse is also true: any value in the
approximation next to some given one is a result of applying one of the constructors of
the datatype to values in the given approximation and can therefore be subjected to case
analysis. Finally, the (letrec) rule says that any systematic way of extending a function
deS,ned on a given approximation of a datatype to work also on the next approximation
induces a function deS,ned on the whole datatype, the limit of the approximations. The
premiss of this rule involves an implicit universal quantiS,cation over the set of all stages
(freshness condition!).

2.4. Some examples
We now give a few examples of programming to illustrate the mechanics and expressive
power of our calculus. We start from simple recursive deS,nitions that are deS,nable in all
useful existing systems.

Example 2.18 (Standard examples).
D^ The addition of two natural numbers. The only recursive call in this program is made

on a depth-one recursive component of the argument value.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 108

plus i (letrec plus:NatZ^\Lambda Nat\Lambda Nat =

\Delta x:Nat\Delta Z^. \Delta y:Nat. case x of -o ffi y--

s ffi \Delta x\Upsilon :NatZ^ . s (plus x\Upsilon  y)\Theta  \Lambda \Xi  \Pi 

:Nat""

) : Nats \Lambda  Nat \Lambda  Nat

D^ The concatenation of two lists and the concatenation of a list of lists.

append i (letrec append:ListZ^\Omega \Lambda List \Omega \Lambda List \Omega  = \Delta x:List\Delta Z^\Omega . \Delta y:List \Omega .

case x of -nil ffi y--

cons ffi \Delta z:\Omega . \Delta x\Upsilon :ListZ^\Omega . cons z (append x\Upsilon  y)\Theta  \Lambda \Xi  \Pi 

:List \Omega ""

) : Lists \Omega  \Lambda  List \Omega  \Lambda List \Omega 

conc i (letrec conc:ListZ^(List \Omega )\Lambda List \Omega  = \Delta x:List\Delta Z^(List \Omega ).

case x of -nil ffi nil--

cons ffi \Delta z:List \Omega . \Delta x\Upsilon :ListZ^(List \Omega ). append z (conc x\Upsilon )\Theta  \Lambda \Xi  \Pi 

:List \Omega ""

) : Lists (List \Omega ) \Lambda  List \Omega 
D^ The addition of two ordinals.

add i (letrec add:OrdZ^\Lambda Ord\Lambda Ord = \Delta x:Ord\Delta Z^. \Delta y:Ord.

case x of -zero ffi y--

succ ffi \Delta x\Upsilon :OrdZ^ . succ (add x\Upsilon  y)\Theta  \Lambda \Xi  \Pi 

:Ord--
lim ffi \Delta x\Upsilon :Nat\Lambda OrdZ^. lim (\Delta z:Nat. add (x\Upsilon  z)\Theta  \Lambda \Xi  \Pi 

OrdZ^

y\Theta  \Lambda \Xi  \Pi 

:Ord

)\Theta  \Lambda \Xi  \Pi 

:Ord""
) : Ords \Lambda  Ord \Lambda  Ord

The following example illustrates the use of subsumption.

Example 2.19 (Example using subsumption). The predicate that decides whether a natural
number is even or not may be deS,ned as follows. This program involves a recursive call on
a deep recursive component of the argument value. To type it, therefore, the subsumption

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 109
rule has to be used.

(letrec even:NatZ^\Lambda Bool = \Delta x:Nat\Delta Z^.

case x of -o ffi true--

s ffi \Delta x\Upsilon :NatZ^jNat\Delta Z^. case x\Upsilon  of -o ffi false--

s ffi \Delta x\Upsilon \Upsilon :NatZ^ . even x\Upsilon \Upsilon \Theta  \Lambda \Xi  \Pi 

:Bool """"

) : Nats \Lambda Bool
The following examples demonstrate the speciS,c, novel features of \Delta \Delta . First of all, stages
provide a limited means of controlling the effect of a recursively deS,ned function in terms
of the relation between the depths of argument and result values.

Example 2.20 (Examples of R'exactR^ typings).
D^ The length of a list. This standard program for calculating the length of a list admits

an unusually R'exactR^ (that is, tight and therefore informative) type in \Delta ^.

length i (letrec length:ListZ^\Omega \Lambda NatZ^ =

\Delta x:List\Delta Z^\Omega . case x of -nil ffi o--

cons ffi \Delta z:\Omega . \Delta x\Upsilon :ListZ^\Omega . s (length x\Upsilon )\Theta  \Lambda \Xi  \Pi 

:NatZ^\Theta  \Lambda \Xi  \Pi 
:Nat\Delta Z^""

) : Lists\Omega \Lambda  Nats
D^ The map of a function on a list. This program is very similar to that for the length

function and also admits an R'exactR^ typing, but becomes crucial in an example below.

map i \Delta f:\Omega \Lambda \Psi . (letrec map:ListZ^\Omega \Lambda ListZ^\Psi  = \Delta x:List\Delta Z^\Omega .

case x of -nil ffi nil--

cons ffi \Delta z:\Omega . \Delta x\Upsilon :ListZ^\Omega . cons (f z)\Theta  \Lambda \Xi  \Pi 

:\Psi 

(map x\Upsilon )\Theta  \Lambda \Xi  \Pi 

:ListZ^\Psi \Theta  \Lambda \Xi  \Pi 
:List\Delta Z^\Psi ""

):Lists\Omega \Lambda Lists\Psi 
Further, recursive calls are allowed on structurally smaller arguments that cannot be
veriS,ed to be structurally smaller using a viable syntactic criterion.

Example 2.21 (Examples not handled by the guard condition).
D^ The Euclidean division ` xy+1 '. This program for the Euclidean division depends on a

program for subtraction. It is not typable in systems with a syntactic guard predicate,
as, syntactically, (minus x\Upsilon  y) is not properly structurally smaller than x in the program
below. In \Delta \Delta , it is typable because of the R'exactR^ type assignable to minus.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 110

minus i (letrec minus:NatZ^\Lambda Nat\Lambda NatZ^ = \Delta x:Nat\Delta Z^. \Delta y:Nat.

case x of -o ffi x--

s ffi \Delta x\Upsilon :NatZ^. case y of -o ffi x--

s ffi \Delta y\Upsilon :Nat. minus x\Upsilon  y\Upsilon \Theta  \Lambda \Xi  \Pi 

:NatZ^ """"

) : Nats \Lambda  Nat \Lambda  Nats

(letrec div :NatZ^\Lambda Nat\Lambda NatZ^ =

\Delta x:Nat\Delta Z^ . \Delta y:Nat. case x of -o ffi o--

s ffi \Delta x\Upsilon :NatZ^. s (div (minus x\Upsilon  y)\Theta  \Lambda \Xi  \Pi 

:NatZ^

y)\Theta  \Lambda \Xi  \Pi 

:NatZ^""
) : Nats \Lambda  Nat \Lambda  Nats
D^ Flattening of S,nitely branching trees. This program depends on map and conc. As with

div, it is not typable in systems with a syntactic guard predicate.

(letrec T^atten:TreeZ^\Omega \Lambda List \Omega  =

\Delta x:Tree\Delta Z^\Omega . case x of -

branch ffi \Delta z:\Omega . \Delta x\Upsilon :List (TreeZ^\Omega ). cons z (conc (map T^atten x\Upsilon )\Theta  \Lambda \Xi  \Pi 

:List (List \Omega )

)\Theta  \Lambda \Xi  \Pi 

:List \Omega ""
) : Trees\Omega  \Lambda  List \Omega 
Finally, we give an example demonstrating the usefulness of having the capability of
naming stages explicitly: if one recursion is nested in another, we need two distinct free
stage variables.

Example 2.22 (Examples involving several stage variables). The Ackermann function. The
natural deS,nition of the Ackermann function is not typable in our system. A deS,nition
with two recursions, one nesting the other, however, is easy to type.

ack i (letrec ack:NatZ^\Lambda Nat\Lambda Nat = \Delta x:Nat\Delta Z^ .

case x of -o ffi \Delta z. (s z)\Theta  \Lambda \Xi  \Pi 

:Nat\Lambda Nat--
s ffi \Delta x\Upsilon :NatZ^ . (letrec ack x :Natj\Lambda Nat = \Delta y:Nat\Delta j .

case y of -o ffi ack x\Upsilon  (s o)\Theta  \Lambda \Xi  \Pi 

:Nat--
s ffi \Delta y\Upsilon :Natj . ack x\Upsilon  (ack x y\Upsilon )\Theta  \Lambda \Xi  \Pi 

:Nat\Theta  \Lambda \Xi  \Pi 
:Nat

""

):Nat\Lambda Nat""
) : Nats \Lambda Nat \Lambda  Nat

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 111
3. Meta-theoretical results
In this section, we prove two important meta-theoretic properties of \Delta \Delta  E^ subject reduction
and strong normalisability of typable terms.

3.1. Subject reduction
The proof of subject reduction for \Delta \Delta  is quite standard. Before going into this proof,
some lemmas involving monotonicity and substitution properties for stages, as well as
generation and substitution properties for typing, are considered.

Lemma 3.1 (Generation lemma for subtyping).
1 \Psi  j \Omega 1 \Lambda  \Omega 2 ffi \Psi  i \Omega \Upsilon 1 \Lambda  \Omega \Upsilon 2 ^ \Omega 1 j \Omega \Upsilon 1 ^ \Omega \Upsilon 2 j \Omega 2.
2 \Omega 1 \Lambda  \Omega 2 j \Psi  ffi \Psi  i \Omega \Upsilon 1 \Lambda  \Omega \Upsilon 2 ^ \Omega \Upsilon 1 j \Omega 1 ^ \Omega 2 j \Omega \Upsilon 2.
3 \Theta  j ds\Xi \Omega  ffi \Theta  i dr\Xi \Psi  ^ r \Theta  s ^ \Xi \Psi  j \Xi \Omega .
4 ds\Xi \Omega  j \Theta  ffi \Theta  i dr\Xi \Psi  ^ s \Theta  r ^ \Xi \Omega  j \Xi \Psi .
5 \Lambda  j \Psi  ffi \Psi  i \Lambda .
6 \Psi  j \Lambda  ffi \Psi  i \Lambda .

Proof. The proof is immediate by analysis of the subtyping rules.
Lemma 3.2 (Generation lemma for typing).
1 \Lambda  \Xi  x : \Psi  ffi (x : \Omega ) \Phi  \Lambda  ^ \Omega  j \Psi .
2 \Lambda  \Xi  a b : \Psi  ffi \Lambda  \Xi  a : \Omega  \Lambda  \Psi \Upsilon  ^ \Lambda  \Xi  b : \Omega  ^ \Psi \Upsilon  j \Psi .
3 \Lambda  \Xi  \Delta x.e : \Psi  ffi \Psi  i \Omega 1 \Lambda  \Omega 2 ^ \Lambda , x : \Omega \Upsilon 1 \Xi  e : \Omega \Upsilon 2 ^ \Omega 1 j \Omega \Upsilon 1 ^ \Omega \Upsilon 2 j \Omega 2.
4 \Lambda  \Xi  c : \Psi  ffi \Psi  i \Xi ff \Lambda  \Theta  ^ \Xi ff j Instsc \Xi \Omega  ^ d\Delta s\Xi \Omega  j \Theta  ^ c \Phi  C(d).
5 \Lambda  \Xi  case a of -\Xi c ffi \Xi b"" : \Psi  ffi \Lambda  \Xi  a : d\Delta s\Xi \Omega  ^ \Lambda  \Xi  bi : Instsci \Xi \Omega  \Lambda  \Theta  ^ \Theta  j \Psi  .
6 \Lambda  \Xi  letrec f = e : \Psi  ffi \Lambda , f : dZ^\Xi \Omega  \Lambda  \Theta  \Xi  e : (dZ^\Xi \Omega  \Lambda  \Theta )[Z^ := \Delta Z^ ] ^ (dZ^\Xi \Omega  \Lambda  \Theta )[Z^ :=

s] j \Psi  with Z^ \Phi  VS, Z^ pos \Theta  and Z^ fresh in \Lambda ,\Xi \Omega .

Proof. The proof is by inspection on the derivation of the antecedent judgments.
Lemma 3.3.
1 If Z^ pos \Theta  and r \Theta  s, then \Theta [Z^ := r] j \Theta [Z^ := s].
2 If Z^ neg \Theta  and r \Theta  s, then \Theta [Z^ := s] j \Theta [Z^ := r].
3 If \Omega  j \Psi  and \Lambda  pos \Theta , then \Theta [\Lambda  := \Omega ] j \Theta [\Lambda  := \Psi ].
4 If \Omega  j \Psi  and \Lambda  neg \Theta , then \Theta [\Lambda  := \Psi ] j \Theta [\Lambda  := \Omega ].

Proof. Properties 1 and 2 are proved by simultaneous induction on the structure of \Theta .
Properties 3 and 4 are proved in the same way.

Lemma 3.4.
1 If \Psi  j \Psi \Upsilon , then \Psi [Z^ := s] j \Psi \Upsilon [Z^ := s] .
2 If \Psi  j \Psi \Upsilon , then \Psi [\Lambda  := \Omega ] j \Psi \Upsilon [\Lambda  := \Omega ] .

Proof. The proof is by induction on the structure of \Psi .
Lemma 3.5. If r \Theta  s and \Xi \Omega  j \Xi \Psi , then Instrc \Xi \Omega  j Instsc \Xi \Psi .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 112

Proof. This follows from the previous lemmas.
Lemma 3.6. \Lambda 1, x : \Omega , \Lambda 2, \Lambda 3 \Xi  a : \Psi  ffi \Lambda 1, \Lambda 2, x : \Omega , \Lambda 3 \Xi  a : \Psi .

Proof. The proof is by induction on the derivation of \Lambda 1, x : \Omega , \Lambda 2, \Lambda 3 \Xi  a : \Psi .
Lemma 3.7 (Substitution lemma).

If \Lambda , x : \Omega  \Xi  a : \Psi  and \Lambda  \Xi  b : \Omega , then \Lambda  \Xi  a[x := b] : \Psi .

Proof. The proof is by induction on the derivation of \Lambda , x : \Omega  \Xi  a : \Psi .
The following lemma shows the polymorphic nature of stage variables. In fact, in
a derivable judgment a stage variable can be replaced throughout by a stage without
affecting derivability.

Lemma 3.8. If \Lambda  \Xi  a : \Psi  , then \Lambda [Z^ := s] \Xi  a : \Psi [Z^ := s].

Proof. Without loss of generality, one can assume Z^ nocc s, otherwise one could S,rst
apply this weaker version of the lemma with Z^ being replaced by a new stage variable fi
(for the set of stage variables is inS,nite) and then use again the weaker version of the
lemma with fi replaced by s.

We then use induction on the derivation of \Lambda  \Xi  a : \Psi . The only interesting case is when
the last rule applied is (rec). (The other cases can be easily proved using the induction
hypothesis.) Assume the last step is

\Lambda , f : dj\Xi \Omega  \Lambda  \Theta  \Xi  e : d\Delta j\Xi \Omega  \Lambda  \Theta [j := \Delta j] j pos \Theta 

\Lambda  \Xi  (letrec f = e) : dr\Xi \Omega  \Lambda  \Theta [j := r] j fresh in \Lambda ,\Xi \Omega 

A stage variable fi can be chosen such that fi is fresh in \Lambda ,\Xi \Omega , \Theta , fi \Omega = Z^ and fi nocc s. Then,
from the induction hypothesis, \Lambda , f : dfi\Xi \Omega  \Lambda  \Theta [j := fi] \Xi  e : d\Delta fi\Xi \Omega  \Lambda  \Theta [j := \Delta j][j := fi].
Therefore, \Lambda , f : dfi\Xi \Omega  \Lambda  \Theta [j := fi] \Xi  e : d\Delta fi\Xi \Omega  \Lambda  \Theta [j := fi][fi := \Delta fi] and therefore, using the
induction hypothesis again,

\Lambda [Z^ := s], f : dfi\Xi \Omega [Z^ := s] \Lambda  \Theta [j := fi][Z^ := s] \Xi 

e : d\Delta fi\Xi \Omega [Z^ := s] \Lambda  \Theta [j := fi][fi := \Delta fi][Z^ := s].

Since fi nocc s, the substitutions [fi := \Delta fi] and [Z^ := s] can be exchanged to give

\Lambda [Z^ := s], f : dfi\Xi \Omega [Z^ := s] \Lambda  \Theta [j := fi][Z^ := s] \Xi 

e : d\Delta fi\Xi \Omega [Z^ := s] \Lambda  \Theta [j := fi][Z^ := s][fi := \Delta fi], (1)

and, as fi is fresh in \Lambda [Z^ := s] and in \Xi \Omega [Z^ := s], one can apply the rule (rec).

Let u i r[Z^ := s]. From (1) by (rec),

\Lambda [Z^ := s] \Xi  (letrec f = e) : du\Xi \Omega [Z^ := s] \Lambda  \Theta [j := fi][Z^ := s][fi := u].
So, as fi nocc s, Z^ nocc s and fi is \Theta -fresh, \Lambda [Z^ := s] \Xi  (letrec f = e) : (dr\Xi \Omega )[Z^ := s] \Lambda 
\Theta [j := u][Z^ := s]. Hence, \Lambda [Z^ := s] \Xi  (letrec f = e) : (dr\Xi \Omega  \Lambda  \Theta [j := r])[Z^ := s].

We are now ready to prove that \Delta \Delta  enjoys the property of subject reduction.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 113
Proposition 3.1 (Subject reduction).

\Lambda  \Xi  e1 : \Psi  ^ e1 \Lambda \Pi \Sigma t, e2 ffi \Lambda  \Xi  e2 : \Psi .
Proof. The proof is by induction on the derivation of \Lambda  \Xi  e1 : \Psi . The interesting cases
are when the last rule applied is (app) or (case):

(app) Assume e1 i a b and the last step is

\Lambda  \Xi  a : \Omega 1 \Lambda  \Omega 2 \Lambda  \Xi  b : \Omega 1

\Lambda  \Xi  a b : \Omega 2 .

Then one may have the following cases:
e2 i e[x := b], with a i \Delta x.e

From the typing derivation for a, using Lemma 3.2, it follows that \Lambda , x : \Omega \Upsilon 1 \Xi  e : \Omega \Upsilon 2,
\Omega 1 j \Omega \Upsilon 1 and \Omega \Upsilon 2 j \Omega 2, and from the typing derivation for b, by (sub), we derive
\Lambda  \Xi  b : \Omega \Upsilon 1. Thus, by Lemma 3.7, \Lambda  \Xi  e[x := b] : \Omega \Upsilon 2, and, S,nally, by the rule (sub),
\Lambda  \Xi  e[x := b] : \Omega 2.

e2 i (e[f := (letrec f = e)]) (c\Xi a), with a i (letrec f = e) and b i (c\Xi a)

Applying Lemma 3.2 to the typing derivation for a,

\Lambda , f : dZ^\Xi \Omega  \Lambda  \Theta  \Xi  e : (dZ^\Xi \Omega  \Lambda  \Theta )[Z^ := \Delta Z^ ], (2)

(dZ^\Xi \Omega  \Lambda  \Theta )[Z^ := s] j \Omega 1 \Lambda  \Omega 2, (3)
Z^ \Phi  VS ^ Z^ pos \Theta  ^ Z^ fresh in \Lambda ,\Xi \Omega . (4)

From (3) by Lemma 3.1, \Omega 1 j ds\Xi \Omega  ^ \Theta [Z^ := s] j \Omega 2 and thus, using Lemma 3.1
again,

\Omega 1 i dp\Xi \Omega \Upsilon  ^ p \Theta  s ^ \Xi \Omega \Upsilon  j \Xi \Omega .
From (2) and (4), by (rec), \Lambda  \Xi  (letrec f = e) : (dZ^\Xi \Omega  \Lambda  \Theta )[Z^ := q] holds for
an arbitary stage q. Therefore, choosing q i Z^ and taking (2) into account, by
Lemma 3.7, we can derive

\Lambda  \Xi  e[f := (letrec f = e)] : (dZ^\Xi \Omega  \Lambda \Theta )[Z^ := \Delta Z^ ]. (5)
Thus we have \Lambda  \Xi  (c\Xi a) : dp\Xi \Omega \Upsilon , so, by Lemmas 3.1 and 3.2, one of two possibilities
for p must arise: p i jn with n \Xi  1 or p i \Sigma m with m \Xi  0, where for a stage s and
for k \Phi  IN, sk means s hatted k times.

D^ Case p i jn with n \Xi  1. Using Lemma 3.8 on (5) with substitution [Z^ := j(nL/1)],

and since Z^ is fresh with respect to \Lambda  and \Xi \Omega ,

\Lambda  \Xi  e[f := (letrec f = e)] : dj

n\Xi \Omega  \Lambda  \Theta [Z^ := jn].

Thus, since \Lambda  \Xi  (c\Xi a) : \Omega 1 and \Omega 1 i dp\Xi \Omega \Upsilon , by (sub) and (app), we have
\Lambda  \Xi  e[f := (letrec f = e)] (c\Xi a) : \Theta [Z^ := jn]. We have jn \Theta  s and Z^ pos \Theta , so, by
Lemma 3.3, \Theta [Z^ := jn] j \Theta [Z^ := s] and the proof of this case is concluded using
the rule (sub).

D^ Case p i \Sigma m with m \Xi  0. Observing that, by (sub), \Lambda  \Xi  (c\Xi a) : d\Sigma 

(m+1)\Xi \Omega \Upsilon , and

the proof can now be completed arguing as in the previous case.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 114

The remaining cases, where e2 i a\Upsilon  b with a \Lambda \Pi \Sigma t, a\Upsilon , or e2 i a b\Upsilon  with b \Lambda \Pi \Sigma t, b\Upsilon , follow
by routine induction.
(case) Assume e1 i case a of -c1 ffi b1 -- . . . -- cn ffi bn"" and the last step is

\Lambda  \Xi  a : d\Delta s\Xi \Omega  \Lambda  \Xi  bi : Instsci \Xi \Omega  \Lambda  \Theta  (1 \Lambda  i \Lambda  n)

\Lambda  \Xi  case a of -c1 ffi b1 -- . . . -- cn ffi bn"" : \Theta  .
Then we may have:
e2 i bi a1 . . . aar(ci), with a i ci a1 . . . aar(ci)

From \Lambda  \Xi  ci a1 . . . aar(ci) : d\Delta s\Xi \Omega , by Lemma 3.2, it follows that

\Lambda  \Xi  ci : \Xi ff \Lambda  \Psi  ^ \Psi  j d\Delta s\Xi \Omega 
and, also, for 1 \Lambda  j \Lambda  ar(ci)

\Lambda  \Xi  aj : ffj ^ ffj j Instrci \Xi fl[j] ^ d\Delta r\Xi fl j \Psi .
So, d\Delta r\Xi fl j d\Delta s\Xi \Omega , and therefore, by Lemmas 3.1 and 2.14, r \Theta  s and \Xi fl j \Xi \Omega . Using
Lemma 3.5 and the (sub) rule, we have \Lambda  \Xi  aj : Instsci \Xi \Omega [j] for 1 \Lambda  j \Lambda  ar(ci),
which can be combined with the typing derivation of bi, by means of the rule
(app), to conclude the proof of this case.

The remaining cases,

e2 i case a\Upsilon  of -\Xi c ffi \Xi b"" with a \Lambda \Pi \Sigma t, a\Upsilon ,
and

e2 i case a\Upsilon  of -c1 ffi b1 -- . . . -- ci ffi b\Upsilon i -- . . . -- cn ffi bn"" with bi \Lambda \Pi \Sigma t, b\Upsilon i,
follow by routine induction.

3.2. Strong normalisation
As usual, we say that a term e is strongly normalising with respect to \Lambda \Pi \Sigma t, if all \Pi \Sigma t,-
reduction sequences starting with e terminate. Let SN denote the set of terms that are
strongly normalising with respect to \Lambda \Pi \Sigma t,.

To prove that every typable term is in SN, we use the method of saturated sets. This
is a standard technique, see, for example, Luo (1994). The idea is to provide the system
with a semantics in which terms are interpreted as terms and type expressions as sets of
terms known by construction only to contain strongly normalising terms and always to be
non-empty (saturated sets). The strong normalisability of all typable terms then follows
immediately as soon it is proved that the system is sound with respect to it.

3.2.1. Saturated sets and interpretation domains We start by deS,ning the notions of base
terms and key reduction (which is also known as weak head reduction).

DeS,nition 3.10 (Base terms). The set Base of base terms is deS,ned inductively as follows:
D^ VE \Psi  Base.
D^ If b \Phi  Base and e \Phi  SN, then b e \Phi  Base.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 115
D^ If b \Phi  Base and e1, . . . , en \Phi  SN, then case b of -c1 ffi e1 -- . . . -- cn ffi en"" \Phi  Base.
D^ If b \Phi  Base and e \Phi  SN, then (letrec f = e) b \Phi  Base.

Every base term is strongly normalising.
Lemma 3.11. Base \Psi  SN.
DeS,nition 3.12 (Key reduction). The relation of key reduction between terms is deS,ned
inductively as follows:

D^ If e is a \Pi \Sigma t,-redex and e\Upsilon  is the contractum, then e \Lambda k e\Upsilon .
D^ If a \Lambda k a\Upsilon , then a e \Lambda k a\Upsilon  e.
D^ If a \Lambda k a\Upsilon , then case a of -c1 ffi e1 -- . . . -- cn ffi en"" \Lambda k case a\Upsilon  of -c1 ffi e1 -- . . . -- cn ffi

en"".
D^ If a \Lambda k a\Upsilon , then (letrec f = e) a \Lambda k (letrec f = e) a\Upsilon .

Key reduction commutes with reduction in the following sense.
Lemma 3.13. If a \Lambda k b and a \Lambda  a\Upsilon  \Omega = b, then a\Upsilon  \Lambda k b\Upsilon  and b \Delta  b\Upsilon  for some b\Upsilon .

The following two lemmas provide sufficient conditions for an expression to be strongly
normalising.

Lemma 3.14.
1 If a \Phi  SN, a \Lambda k b and b e \Phi  SN, then a e \Phi  SN.
2 If a \Phi  SN, a \Lambda k b and case b of -c1 ffi e1 -- . . . -- cn ffi en"" \Phi  SN, then case a of -c1 ffi

e1 -- . . . -- cn ffi en"" \Phi  SN.
3 If a \Phi  SN, a \Lambda k b and (letrec f = e) b \Phi  SN, then (letrec f = e) a \Phi  SN.

Proof. We will just prove (1). Suppose a \Phi  SN, a \Lambda k b and b e \Phi  SN. First note that
e \Phi  SN as b e \Phi  SN. The proof of a e \Phi  SN is by simultaneous induction on R'a \Phi  SNR^ and
R'e \Phi  SNR^. We have to prove that c \Phi  SN for any one c such that a e \Lambda  c. As a can be
neither a lambda-abstraction nor a letrec, there are two cases: either c = a\Upsilon  e and a \Lambda  a\Upsilon 
or c = a e\Upsilon  and e \Lambda  e\Upsilon .

D^ Suppose c = a\Upsilon  e and a \Lambda  a\Upsilon . If a\Upsilon  = b, then c = a\Upsilon  e \Phi  SN, since b e \Phi  SN. Otherwise,

by Lemma 3.13, there is b\Upsilon  such that a\Upsilon  \Lambda k b\Upsilon  and b \Delta  b\Upsilon . We have a\Upsilon  \Phi  SN (as a \Phi  SN),
a\Upsilon  \Lambda k b\Upsilon  and b\Upsilon  e \Phi  SN (as b e \Phi  SN). By the induction hypothesis, c = a\Upsilon  e \Phi  SN.
D^ Suppose c = a e\Upsilon  and e \Lambda  e\Upsilon . We have a \Phi  SN, a \Lambda k b, b e\Upsilon  \Phi  SN (as b e \Phi  SN). By the

induction hypothesis, c = a e\Upsilon  \Phi  SN.

Lemma 3.15.
1 If a, e, a[x := e] \Phi  SN, then (\Delta x. a) e \Phi  SN.
2 If \Xi a, e1, . . . , en, ei \Xi a \Phi  SN, then case (ci \Xi a) of -c1 ffi e1 -- . . . -- cn ffi en"" \Phi  SN.
3 If \Xi a, e, e[f := (letrec f = e)] (c \Xi a) \Phi  SN, then (letrec f = e) (c \Xi a) \Phi  SN.

Next we deS,ne saturated sets and state some of their closure properties. Saturated sets
are sets of strongly normalising terms containing the base terms and closed with respect
to key expansion.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 116
DeS,nition 3.16 (Saturated sets).
1 A set X \Psi  E is said to be a saturated set, if

D^ X \Psi  SN,
D^ Base \Psi  X,
D^ if a \Phi  SN and a \Lambda k a\Upsilon  for some a\Upsilon  \Phi  X, then a \Phi  X.
The set of all saturated sets is denoted by SAT.
2 For any X \Psi  E, let \Pi X\Sigma  = -a \Phi  SN -- *b \Phi  Base ffl X.a \Delta k b"".

The following lemma establishes some basic properties of the closure operator \Pi *\Sigma .
Lemma 3.17.
1 If X \Psi  SN, then \Pi X\Sigma  is a saturated set, in fact, the smallest saturated set containing X.
2 \Pi X1 ffl . . . ffl Xn\Sigma  = \Pi X1\Sigma  ffl . . . ffl \Pi Xn\Sigma .
3 If Xi is a saturated set for any i \Phi  I, then \Sigma  i \Phi  I.Xi is a saturated set. (We say that\Sigma 

i \Phi  \Delta .Xi = \Pi \Delta \Sigma .)

On saturated sets, we can deS,ne a function-space forming operation. This is needed for
the interpretation of function-space types.

DeS,nition 3.18. For any X, Y \Psi  E, let X \Lambda Y = -a \Phi  E -- _e \Phi  X. a e \Phi  Y "".
Lemma 3.19. If X and Y are saturated sets, then so is X \Lambda  Y .

Proof. Suppose X and Y are saturated. Clearly any a \Phi  X \Lambda Y is strongly normalising:
as X is non-empty, we can pick some e \Phi  X, and then a \Phi  SN because a e \Phi  Y \Psi  SN. Let
us check that X \Lambda  Y satisS,es the conditions of saturatedness.

D^ Suppose b \Phi  Base and consider any e \Phi  X. As e \Phi  SN, we have that b e \Phi  Base \Psi  Y .

Hence b \Phi  X \Lambda  Y .
D^ Suppose a \Phi  SN, a \Lambda k a\Upsilon  and a\Upsilon  \Phi  X \Lambda  Y . We have to show that a \Phi  X \Lambda  Y , that

is, that, for any e \Phi  X, a e \Phi  Y . Consider any e \Phi  X. We have a e \Lambda k a\Upsilon  e and
a\Upsilon  e \Phi  Y \Psi  SN, hence Lemma 3.14 applies and a e \Phi  SN. Since Y is saturated, we get
a e \Phi  Y .

3.2.2. Type and term interpretation In the following we deS,ne a semantics of the language
of stages, types and terms, and show that the rules of stage comparison, subtyping and
typing are sound with respect to that semantics. Types will be interpreted as saturated
sets of terms, terms will be interpreted as terms.

We start with the deS,nitions of valuations and interpretation for stages and types. Stages
will be interpreted as ordinals below \Omega , the S,rst uncountable ordinal, types as saturated
sets of terms. Inductive types are interpreted as limits of a monotone approximation
process from below. As the universe, SN, is countable, the approximation process is
guaranteed to converge before \Omega .

DeS,nition 3.20 (Stage valuation).
1 A stage valuation is a map ffi : VS \Lambda  \Omega  + 1.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 117
2 For every stage valuation ffi, Z^ \Phi  VS, and x \Phi  \Omega  + 1, the stage valuation ffi(Z^ := x) is

deS,ned as follows:

ffi(Z^ := x)(Z^\Upsilon ) = \Upsilon x if Z^\Upsilon  i Z^ffi(Z^\Upsilon ) if Z^\Upsilon  \Omega i Z^.

DeS,nition 3.21 (Interpretation of stages). Let ffi be a type valuation. The corresponding
stage interpretation function [[.]]ffi : S \Lambda  \Omega  + 1 is deS,ned as follows:

[[Z^]]ffi = ffi(Z^) if Z^ \Phi  VS
[[\Sigma ]]ffi = \Omega 

[[^s]]ffi = \Upsilon [[s]]ffi + 1 if [[s]]ffi < \Omega [[s]]

ffi if [[s]]ffi = \Omega .

DeS,nition 3.22 (Type valuation).
1 A type valuation is a map ffl : VT \Lambda SAT.
2 For every type valuation ffl, \Lambda  \Phi  VT and X \Phi  SAT, the type valuation ffl(\Lambda  := X) is

deS,ned as follows:

ffl(\Lambda  := X)(\Lambda \Upsilon ) = \Upsilon X if \Lambda \Upsilon  i \Lambda ffl(\Lambda \Upsilon ) if \Lambda \Upsilon  \Omega i \Lambda .

DeS,nition 3.23 (Interpretation of types). Let ffi be a stage valuation and ffl a type
valuation. The corresponding type interpretation function [[.]]ffi,ffl : T \Lambda  SAT is deS,ned by
induction on heights (because of the stratiS,cation on datatype identiS,ers, every type has
S,nite height):

[[\Lambda ]]ffi,ffl = ffl(\Lambda ) if \Lambda  \Phi  VT
[[\Omega \Lambda  \Psi ]]ffi,ffl = [[\Omega ]]ffi,ffl \Lambda  [[\Psi ]]ffi,ffl

[[ds\Xi \Omega ]]ffi,ffl = D([[\Xi \Omega ]]ffi,ffl, [[s]]ffi)

where D(\Xi X, x) is deS,ned by induction on x by

D(\Xi X, 0) = \Pi \Delta \Sigma 
D(\Xi X, y + 1) = \Pi c1 [[\Xi \Psi 1]]ffi,ffl(\Upsilon :=D(\Xi X,y),\Xi \Lambda :=\Xi X) ffl . . . ffl cn [[\Xi \Psi n]]ffi,ffl(\Upsilon :=D(\Xi X,y),\Xi \Lambda :=\Xi X)\Sigma 

where D(ci) = (\Upsilon ,\Xi \Lambda , \Xi \Psi i)
D(\Xi X, x) = \Phi  y < x. D(\Xi X, y) if x is a limit ordinal.

Lemma 3.24 (Substitution lemma for the interpretation of types).
1 [[\Psi [\Sigma  := s]]]ffi,ffl = [[\Psi ]]ffi(\Sigma :=[[s]]ffi),ffl
2 [[\Psi [\Lambda  := \Omega ]]]ffi,ffl = [[\Psi ]]ffi,ffl(\Lambda :=[[\Omega ]]ffi,ffl).

The following lemma states that the sequence of approximates of any datatype is
non-decreasing with respect to set inclusion and converges before \Omega .

Lemma 3.25.
1 If X \Psi  X\Upsilon  and \Lambda  pos \Psi , then [[\Psi ]]ffi,ffl(\Lambda :=X) \Psi  [[\Psi ]]ffi,ffl(\Lambda :=X\Upsilon ).

If X \Psi  X\Upsilon  and \Lambda  neg \Psi , then [[\Psi ]]ffi,ffl(\Lambda :=X\Upsilon ) \Psi  [[\Psi ]]ffi,ffl(\Lambda :=X).

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 118
2 If x \Lambda  x\Upsilon , then D(\Xi X, x) \Psi  D(\Xi X, x\Upsilon ).
3 D(\Xi X, \Omega  + 1) = D(\Xi X, \Omega ).

Proof.
1 The proof is by mutual induction on the height of \Psi .
2 The proof is from (1), by induction on x.
3 The proof is from (2), using the fact that E is countable. The iteration process has

to converge before \Omega : the opposite would imply that E is uncountable, as \Omega  is
uncountable.

Lemma 3.26.
1 [[d\Delta s\Xi \Omega ]]ffi,ffl = \Pi c1 [[Instsc1 \Xi \Omega ]]ffi,ffl ffl . . . ffl cn [[Instscn \Xi \Omega ]]ffi,ffl\Sigma 
2 [[d\Sigma \Xi \Omega ]]ffi,ffl = \Pi c1 [[Inst\Sigma c1 \Xi \Omega ]]ffi,ffl ffl . . . ffl cn [[Inst\Sigma cn \Xi \Omega ]]ffi,ffl\Sigma .

Next we deS,ne valuations and interpretation for terms.
DeS,nition 3.27 (Term valuation).
1 A term valuation is a map i : VE \Lambda  E.
2 For every term valuation i, e \Phi  E and x \Phi  VE, the term valuation i(x := e) is deS,ned

as follows:

i(x := e)(z) = \Upsilon e if z i xi(z) if z \Omega i x.

DeS,nition 3.28 (Interpretation of terms). For any term valuation i, the map ([.])i : E \Lambda  E
is deS,ned inductively as follows:

([x])i = i(x)
([\Delta x. e])i = \Delta x.([e])i(x:=x)

([e e\Upsilon ])i = ([e])i ([e\Upsilon ])i

([ck])i = ck
([case e of -c1 ffi e1 -- . . . -- cn ffi en""])i = case ([e])i of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i""

([letrec f = e])i = letrec f = ([e])i(f:=f).

Remark 3.29. The clauses for lambda-abstraction and letrec rely on a form of variable
convention: namely, x and f, respectively, are assumed not to appear as a free variable
in any of the terms i(y) where y is free in e. Alternatively, without the convention, some
variable renaming may be necessary: in the case of lambda-abstraction, one would set

([\Delta x. e])i = \Delta x\Upsilon .([e])i(x:=x\Upsilon )
where x\Upsilon  is some variable free in no i(y) where y is free in e.
Lemma 3.30 (Substitution lemma for the interpretation of terms).
D^ ([e[x := e\Upsilon ]])i = ([e])i(x:=([e\Upsilon ])i).
D^ ([e])i = e[\Xi y := i(\Xi y)] where \Xi y are the free variables of e.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 119

The notion of satisfaction and validity are deS,ned as usual: satisfaction of subtyping is
set inclusion, and satisfaction of typing is set membership.

DeS,nition 3.31 (Satisfaction, validity).
1 A stage valuation ffi satisS,es a stage comparison judgment s \Theta  s\Upsilon  if [[s]]ffi \Lambda  [[s\Upsilon ]]ffi. A

stage comparison judgment s \Theta  s\Upsilon  is valid, if every stage valuation satisS,es it.
2 A stage valuation ffi and a type valuation ffl satisfy a subtyping judgment \Psi  j \Psi \Upsilon  if

[[\Psi ]]ffi,ffl \Psi  [[\Psi \Upsilon ]]ffi,ffl. A subtyping judgment \Psi  j \Psi \Upsilon  is valid if every pair of stage and type
valuations satisS,es it.
3 A valuation is a triple (ffi, ffl, i), where ffi is a stage valuation, ffl is a type valuation and

i is a term valuation.
4 Let (ffi, ffl, i) be a valuation.

(a) (ffi, ffl, i) satisS,es a context \Lambda , written (ffi, ffl, i) --= \Lambda , if i(x) \Phi  [[\Omega ]]ffi,ffl for each

(x : \Omega ) \Phi  \Lambda .

(b) (ffi, ffl, i) satisS,es a typing judgment \Lambda  \Xi  e : \Psi  if

(ffi, ffl, i) --= \Lambda  ffi ([e])i \Phi  [[\Psi ]]ffi,ffl.
5 A typing judgment \Lambda  \Xi  e : \Psi  is valid, written \Lambda  --= e : \Psi  if every valuation satisS,es it.

3.2.3. Soundness with respect to the semantics Next we prove that the rules of \Delta \Delta  for stage
comparison, subtyping and typing are sound with respect to the semantics just deS,ned.
The strong normalisation theorem follows as a corollary from the typing soundness.

Proposition 3.32 (Stage comparison soundness).

s \Theta  s\Upsilon  derivable ffi s \Theta  s\Upsilon  valid.
Proof. The proof is by induction on the derivation of s \Theta  s\Upsilon .
Proposition 3.33 (Subtyping soundness).

\Psi  j \Psi \Upsilon  derivable ffi \Psi  j \Psi \Upsilon  valid.
Proof. The proof is by induction on the derivation of \Psi  j \Psi \Upsilon .
Lemma 3.34. Let ffl be a type valuation. Then:
1 If Z^ pos \Psi  and x \Lambda  x\Upsilon , then [[\Psi ]]ffi(Z^:=x),ffl \Psi  [[\Psi ]]ffi(Z^:=x\Upsilon ),ffl.
2 If Z^ neg \Psi  and x \Lambda  x\Upsilon , then [[\Psi ]]ffi(Z^:=x),ffl * [[\Psi ]]ffi(Z^:=x\Upsilon ),ffl.

Proof. The proof is by simultaneous induction on the structure of \Psi .
Proposition 3.35 (Typing soundness).

\Lambda  \Xi  e : \Psi  derivable ffi \Lambda  --= e : \Psi .
Proof. The proof is by induction on the derivation of \Lambda  \Xi  e : \Psi .
(var) Assume the last (and only) step is

\Lambda  \Xi  x : \Omega  and (x : \Omega ) \Phi  \Lambda .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 120

Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([x])i \Phi  [[\Omega ]]ffi,ffl. This is true, as (x : \Omega ) \Phi  \Lambda .
(abs) Assume the last step is

\Lambda , x : \Omega  \Xi  e : \Psi 
\Lambda  \Xi  \Delta x. e : \Omega \Lambda  \Psi  .
Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([\Delta x. e])i \Phi  [[\Omega  \Lambda  \Psi ]]ffi,ffl. Since [[\Omega  \Lambda  \Psi ]]ffi,ffl =
[[\Omega ]]ffi,ffl \Lambda  [[\Psi ]]ffi,ffl and ([\Delta x. e])i = \Delta x.([e])i0, where i0 = i(x := x), this amounts to showing
that (\Delta x. ([e])i0) a \Phi  [[\Psi ]]ffi,ffl for any a \Phi  [[\Omega ]]ffi,ffl.
Observe S,rst that, since (ffi, ffl, i0) --= \Lambda  and i0(x) = x \Phi  VE \Psi  [[\Omega ]]ffi,ffl, the induction
hypothesis tells us that ([e])i0 \Phi  [[\Psi ]]ffi,ffl \Psi  SN.
Now suppose a \Phi  [[\Omega ]]ffi,ffl \Psi  SN, and let i\Upsilon  = i(x := a). Since (ffi, ffl, i\Upsilon ) --= \Lambda  and
i\Upsilon (x) = a \Phi  [[\Omega ]]ffi,ffl, by the induction hypothesis, we get that ([e])i\Upsilon  \Phi  [[\Psi ]]ffi,ffl \Psi  SN. Write
\Xi y for the free variables of e, then (\Delta x. ([e])i0) a \Lambda k ([e])i0[x := a] = e[\Xi y := i0(\Xi y)][x :=

a] = e[\Xi y := i\Upsilon (\Xi y)] = ([e])i\Upsilon  (by the variable convention, Remark 3.29, x does not occur
free in i0(\Xi y)). By Lemma 3.15, (\Delta x. ([e])i0) a \Phi  SN. As [[\Psi ]]ffi,ffl is a saturated set, we get
that (\Delta x. ([e])i0) a \Phi  [[\Psi ]]ffi,ffl.

(app) Assume the last step is

\Lambda  \Xi  e : \Omega \Lambda  \Psi  \Lambda  \Xi  e\Upsilon  : \Omega 

\Lambda  \Xi  e e\Upsilon  : \Psi  .

Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([e e\Upsilon ])i \Phi  [[\Psi ]]ffi,ffl. As ([e e\Upsilon ])i = ([e])i ([e\Upsilon ])i,
which amounts to showing that ([e])i ([e\Upsilon ])i \Phi  [[\Psi ]]ffi,ffl.
As (ffi, ffl, i) --= \Lambda , the induction hypothesis gives ([e])i \Phi  [[\Omega  \Lambda  \Psi ]]ffi,ffl = [[\Omega ]]ffi,ffl \Lambda  [[\Psi ]]ffi,ffl
and ([e\Upsilon ])i \Phi  [[\Omega ]]ffi,ffl. Thus ([e])i ([e\Upsilon ])i \Phi  [[\Psi ]]ffi,ffl.

(cons) Assume the last (and the only) step is

\Lambda  \Xi  ck : Instsck \Xi \Omega \Lambda  d\Delta s\Xi \Omega  and k \Phi  1..n.
Suppose that (ffi, ffl, i) --= \Lambda . We have to show that ([ck])i \Phi  [[Instsck \Xi \Omega  \Lambda  d\Delta s\Xi \Omega ]]ffi,ffl =
[[Instsck \Xi \Omega ]]ffi,ffl \Lambda  [[d\Delta s\Xi \Omega ]]ffi,ffl. As ([ck])i = ck, this amounts to showing that ck\Xi a \Phi  [[d\Delta s\Xi \Omega ]]ffi,ffl for
any \Xi a \Phi  [[Instsck \Xi \Omega ]]ffi,ffl. But this holds trivially, since [[d\Delta s\Xi \Omega ]]ffi,ffl = \Pi c1 [[Instsc1 \Xi \Omega ]]ffi,ffl ffl . . . ffl
cn [[Instscn \Xi \Omega ]]ffi,ffl\Sigma .
(case) Assume the last step is

\Lambda  \Xi  e : d\Delta s\Xi \Omega  \Lambda  \Xi  e1 : Instsc1 \Xi \Omega  \Lambda \Theta  . . . \Lambda  \Xi  en : Instscn \Xi \Omega \Lambda  \Theta 

\Lambda  \Xi  case e of -c1 ffi e1 -- . . . -- cn ffi en"" : \Theta  .

Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([case e of -c1 ffi e1 -- . . . -- cn ffi en""])i \Phi 
[[\Theta ]]ffi,ffl. As ([case e of -c1 ffi e1 -- . . . -- cn ffi en""])i = case ([e])i of -c1 ffi ([e1])i -- . . . --
cn ffi ([en])i"", this amounts to showing that case ([e])i of -c1 ffi ([e1])i -- . . . -- cn ffi
([en])i"" \Phi  [[\Theta ]]ffi,ffl.
As (ffi, ffl, i) --= \Lambda , from the induction hypothesis we get that ([e])i \Phi  [[d\Delta s\Xi \Omega ]]ffi,ffl \Psi  SN and
([ek])i \Phi  [[Instsck \Xi \Omega \Lambda  \Theta ]]ffi,ffl = [[Instsck \Xi \Omega ]]ffi,ffl \Lambda  [[\Theta ]]ffi,ffl \Psi  SN for each k \Phi  1..n.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 121

Since [[d\Delta s\Xi \Omega ]]ffi,ffl = \Pi c1 [[Instsc1 \Xi \Omega ]]ffi,ffl ffl. . .fflcn [[Instscn \Xi \Omega ]]ffi,ffl\Sigma , it must be the case that ([e])i \Delta k b
for some b \Phi  Base ffl c1 [[Instsc1 \Xi \Omega ]]ffi,ffl ffl . . . ffl cn [[Instscn \Xi \Omega ]]ffi,ffl.
From b \Phi  Base ffl c1 [[Instsc1 \Xi \Omega ]]ffi,ffl ffl . . . ffl cn [[Instscn \Xi \Omega ]]ffi,ffl, it follows that case b of -c1 ffi
([e1])i -- . . . -- cn ffi ([en])i"" \Phi  [[\Theta ]]ffi,ffl \Psi  SN. Indeed, if b \Phi  Base, then case b of -c1 ffi
([e1])i -- . . . -- cn ffi ([en])i"" \Phi  Base \Psi  [[\Theta ]]ffi,ffl, as ([ek])i \Phi  SN for each k \Phi  1..n; if
b \Phi  ck [[Instsck \Xi \Omega ]]ffi,ffl for some k \Phi  1..n, then b = ck\Xi a for some \Xi a \Phi  [[Instsck \Xi \Omega ]]ffi,ffl
and therefore case b of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i"" \Lambda k ([ek])i\Xi a \Phi  [[\Theta ]]ffi,ffl and, by
Lemma 3.15, case b of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i"" \Phi  SN, and hence case b of -c1 ffi
([e1])i -- . . . -- cn ffi ([en])i"" \Phi  [[\Theta ]]ffi,ffl as [[\Theta ]]ffi,ffl is saturated.
From ([e])i \Delta k b it follows that case ([e])i of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i"" \Delta k
case b of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i""; furthermore, by Lemma 3.14, we get
case ([e])i of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i"" \Phi  SN. Since [[\Theta ]]ffi,ffl is saturated, we get
that case ([e])i of -c1 ffi ([e1])i -- . . . -- cn ffi ([en])i"" \Phi  [[\Theta ]]ffi,ffl.

(rec) Assume the last step is

\Lambda , f : dZ^\Xi \Omega \Lambda  \Theta  \Xi  e : d\Delta Z^\Xi \Omega  \Lambda  \Theta [Z^ := \Delta Z^] Z^ pos \Theta 

\Lambda  \Xi  (letrec f = e) : ds\Xi \Omega  \Lambda  \Theta [Z^ := s] and Z^ fresh in \Lambda , \Xi \Omega .

Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([(letrec f = e)])i \Phi  [[ds\Xi \Omega  \Lambda  \Theta [Z^ := s]]]ffi,ffl.
As [[ds\Xi \Omega  \Lambda  \Theta [Z^ := s]]]ffi,ffl = [[dZ^\Xi \Omega  \Lambda  \Theta ]]ffi0,ffl = [[dZ^\Xi \Omega ]]ffi0,ffl \Lambda  [[\Theta ]]ffi0,ffl and ([(letrec f = e)])i =
(letrec f = ([e])i0) where ffi0 = ffi(Z^ := [[s]]ffi) and i0 = i(f := f), this amounts to
showing that (letrec f = ([e])i0) a \Phi  [[\Theta ]]ffi0,ffl for any a \Phi  [[dZ^\Xi \Omega ]]ffi0,ffl.
As (ffi0, ffl, i0) --= \Lambda  and i0(f) = f \Phi  VE \Psi  [[dZ^\Xi \Omega  \Lambda \Theta ]]ffi0,ffl, by the induction hypothesis we
get ([e])i0 \Phi  [[d\Delta Z^\Xi \Omega  \Lambda \Theta [Z^ := \Delta Z^]]]ffi0,ffl \Psi  SN.
We prove our goal by induction on ffi0(Z^).

(ffi0(Z^) = 0) Suppose a \Phi  [[dZ^\Xi \Omega ]]ffi0,ffl = \Pi \Delta \Sigma  \Psi  SN. Then a \Delta k b for some b \Phi  Base.

Since ([e])i0 \Phi  SN, from b \Phi  Base it follows that (letrec f = ([e])i0) b \Phi  Base \Psi 
[[\Theta ]]ffi0,ffl \Psi  SN.
From a \Delta k b it follows that (letrec f = ([e])i0) a \Delta k (letrec f = ([e])i0) b and, by
Lemma 3.14, (letrec f = ([e])i0) a \Phi  SN.
Since [[\Theta ]]ffi0,ffl is a saturated set, we can conclude that (letrec f = ([e])i0) a \Phi  [[\Theta ]]ffi0,ffl.

(ffi0(Z^) = y + 1) Let ffi\Upsilon  = ffi(Z^ := y) and i\Upsilon  = i(f := (letrec f = ([e])i0)). As (ffi\Upsilon , ffl, i\Upsilon ) --=

\Lambda , and, as by the inner induction hypothesis i\Upsilon (f) = (letrec f = ([e])i0) \Phi  [[dZ^\Xi \Omega ]]ffi\Upsilon ,ffl \Lambda 
[[\Theta ]]ffi\Upsilon ,ffl = [[dZ^\Xi \Omega  \Lambda  \Theta ]]ffi\Upsilon ,ffl, we get by the outer induction hypothesis that ([e])i\Upsilon  \Phi  [[d\Delta Z^\Xi \Omega  \Lambda 
\Theta [Z^ := \Delta Z^]]]ffi\Upsilon ,ffl = [[dZ^\Xi \Omega  \Lambda  \Theta ]]ffi0,ffl.
Suppose a \Phi  [[dZ^\Xi \Omega ]]ffi0,ffl = \Pi c1 [[InstZ^c1 \Xi \Omega ]]ffi\Upsilon ,ffl ffl . . . ffl cn [[InstZ^cn \Xi \Omega ]]ffi\Upsilon ,ffl\Sigma  \Psi  SN. Then a \Delta k b
for some b \Phi  Base ffl c1 [[InstZ^c1 \Xi \Omega ]]ffi\Upsilon ,ffl ffl . . . ffl cn [[InstZ^cn \Xi \Omega ]]ffi\Upsilon ,ffl.
From b \Phi  Base ffl c1 [[InstZ^c1 \Xi \Omega ]]ffi\Upsilon ,ffl ffl . . . ffl cn [[InstZ^cn \Xi \Omega ]]ffi\Upsilon ,ffl we get that (letrec f =
([e])i0) b \Phi  [[\Theta ]]ffi0,ffl \Psi  SN. Indeed, if b \Phi  Base, then (letrec f = ([e])i0) b \Phi  Base \Psi 
[[\Theta ]]ffi0,ffl, since ([e])i0 \Phi  SN; if b \Phi  ck[[InstZ^ck \Xi \Omega ]]ffi\Upsilon ,ffl \Psi  [[dZ^\Xi \Omega ]]ffi0,ffl for some k \Phi  1..n, then
(letrec f = ([e])i0) b \Lambda k ([e])i0[f := (letrec f = ([e])i0)] b = ([e])i\Upsilon  b \Phi  [[\Theta ]]ffi0,ffl, and, by
Lemma 3.15, (letrec f = ([e])i0) b \Phi  SN, and hence (letrec f = ([e])i0) b \Phi  [[\Theta ]]ffi0,ffl as
[[\Theta ]]ffi0,ffl is saturated.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 122

From a \Delta k b it follows that (letrec f = ([e])i0) a \Delta k (letrec f = ([e])i0) b and, by
Lemma 3.14, (letrec f = ([e])i0) a \Phi  SN.
Since [[\Theta ]]ffi0,ffl is a saturated set, we can conclude that (letrec f = ([e])i0) a \Phi  [[\Theta ]]ffi0,ffl.

(ffi0(Z^) = x where x is a limit ordinal) Suppose that

a \Phi  [[dZ^\Xi \Omega ]]ffi0,ffl = \Phi  y < x. [[dZ^\Xi \Omega ]]ffi(Z^:=y),ffl.
Then a \Phi  [[dZ^\Xi \Omega ]]ffi(Z^:=y),ffl for some y < x. By the inner induction hypothesis and by the
positivity of Z^ in \Theta , we therefore get that (letrec f = ([e])i0) a \Phi  [[\Theta ]]ffi(Z^:=y),ffl \Psi  [[\Theta ]]ffi0,ffl.

(sub) Assume the last step is

\Lambda  \Xi  e : \Psi  \Psi  j \Psi \Upsilon 

\Lambda  \Xi  e : \Psi \Upsilon  .
Suppose (ffi, ffl, i) --= \Lambda . We have to show that ([e])i \Phi  [[\Psi \Upsilon ]]ffi,ffl. As (ffi, ffl, i) --= \Lambda , the

induction hypothesis gives ([e])i \Phi  [[\Psi ]]ffi,ffl and the subtyping soundness gives [[\Psi ]]ffi,ffl \Psi 
[[\Psi \Upsilon ]]ffi,ffl. Together, these give ([e])i \Phi  [[\Psi \Upsilon ]]ffi,ffl.

The main result of this subsection follows as an immediate corollary of the soundness
of the typing system.

Proposition 3.36 (Strong normalisation). \Lambda  \Pi \Sigma t, is strongly normalising on typable expressions:

\Lambda  \Xi  e : \Psi  derivable ffi e \Phi  SN.

Proof. Assume \Lambda  \Xi  e : \Psi . Then, by Proposition 3.35, \Lambda  --= e : \Psi . Consider a valuation
(ffi, ffl, i) where, for every x \Phi  VE, i(x) = x. For every (x : \Omega ) \Phi  \Lambda , we have ([x])i = x \Phi 
[[\Omega ]]ffi,ffl, since [[\Omega ]]ffi,ffl is saturated, hence (ffi, ffl, i) --= \Lambda . Therefore ([e])i \Phi  [[\Psi ]]ffi,ffl. As ([e])i = e,
we have

e \Phi  [[\Psi ]]ffi,ffl \Psi  SN.

4. The System \Delta G
In this section we present the system \Delta G, a simply typed \Delta -calculus with inductive types.
The terms allowed in \Delta G are the same as those allowed in \Delta \Delta . In particular, we continue
to have the letrec constructor for deS,ning functions recursively, but in \Delta G (following
Gimt^enez (1995)) termination of typable recursively deS,ned functions is ensured by a
syntactical condition G constraining uses of recursive calls in the body of deS,nitions. The
condition G is checked directly on the body of the function and not on its normal form,
because of the problem this would raise (as discussed in the introduction).

4.1. The syntax of \Delta G
The systems \Delta G and \Delta \Delta  allow the same set of terms; they differ at the level of types in the
following aspects:

1 Stages are not present in \Delta G, so datatypes are not annotated by stages.
2 There is no subtyping relation in \Delta G.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 123
3 The set of typing rules is different, and \Delta GR^s typing rule

\Lambda , f : d\Xi \Omega  \Lambda  \Psi  \Xi  e : d\Xi \Omega  \Lambda  \Psi  Gxf(\Delta , a)

\Lambda  \Xi  (letrec f = e) : d\Xi \Omega  \Lambda  \Psi  if e i \Delta x.a

for letrec-expressions is complemented by the syntactical condition G.
4 Following Gimt^enez (1995), the datatypes allowed in \Delta G are slightly more restricted

than those of \Delta \Delta  for, in the argument types of the constructors of a datatype, such
a datatype can only have strictly positive occurences; so throughout this section we
assume that constructor schemes (\Upsilon ,\Xi \Lambda ,\Xi \Psi ) are as in DeS,nition 2.8 except that condition
1 is replaced by the condition: each \Psi i is strictly positive with respect to \Upsilon , or in other
words, if \Upsilon  occurs in \Psi i, \Psi i is of the form \Xi ff \Lambda \Upsilon  where \Xi ff has no occurrences of \Upsilon .

Let us focus on the letrec operator and on the syntactical condition G it satisS,es. This
condition complements the reduction rule \Lambda t,, ensuring that each expansion of the letrec
operator consumes (at least) the constructor in the head of its argument. Informally, for
a term (letrec f = e) we should have the following:

1 f may occur in e only as the head of an application.
2 Any application of f must be protected by a case analysis of the formal argument of

e, say x (for this reason f is said to be guarded by destructors); therefore f must occur
inside eiR^s in the following context:

case x of - c1 ffi \Delta x11. . . . \Delta x1m1. e1

...

cn ffi \Delta xn1. . . . \Delta xnmn. en""
.

3 Considering that the components of x are the xij (direct components) together with the

components of each xij (inner components), f must be applied to a term of the form
z\Xi a where z is a recursive component of x (that is, z is a component of x whose type
has occurrences of the type of x).

To illustrate the above observations, let us consider the examples already given in
Section 2, plus and even, now transposed to \Delta G.

Example 4.1.
D^ The addition of two natural numbers.

(letrec plus = \Delta x. \Delta y. case x of -o ffi y--

s ffi \Delta n.s (plus n y)""

) : Nat \Lambda  Nat \Lambda  Nat
Here the only application of plus is protected by a case analysis on x, which is the
formal argument of plus. The argument of this application is the pattern variable n,
which is a direct component of x.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 124
D^ A function that indicates whether or not a natural number is even.

(letrec even = \Delta x. case x of -o ffi true--

s ffi \Delta y. case y of -o ffi false--

s ffi \Delta z. even z """"

) : Nat \Lambda  Bool
In this example the application of even is guarded by a case analysis on the argument
x. The argument of this application is the pattern variable z, which is an inner
component of x that becomes available in the case analysis on the pattern variable y,
which is a direct component of x.

The formal description of the guarded-by-destructors condition is provided by the
predicate Gxf(V , a) deS,ned below. The V argument is a set of variables used to collect the
pattern variables in a representing the recursive components of x. In order to identify the
recursive components of a variable, we start by characterising the recursive positions of
a constructor scheme as follows.

DeS,nition 4.2. Let c be a \Delta G constructor such that D(c) = (\Upsilon ,\Xi \Lambda ,\Xi \Psi ). We say that the number
j corresponds to a recursive position of D(c), written RP(j, D(c)), if \Psi j is of the form \Xi ff \Lambda  \Upsilon .

The predicate G is now deS,ned as follows.
DeS,nition 4.3 (G predicate). Let U \Psi  V, let x and f be distinct variables not in U and
let a \Phi  E. The predicate Gxf(U, a) is derivable using the rules in Figure 6.

Lemma 4.4. If f nocc a then Gxf(U, a).

Proof. The proof is by induction on the structure of a.
One can check that the guard predicate holds on addition.
Example 4.5. The function plus of Example 4.1 can be shown guarded as follows

plus \Omega = yG

xplus(\Delta , y) 1 G

xplus(-n"", s) 4

plus \Omega = nG

xplus(-n"", n) 1

Gxplus(-n"", plus n) 6

plus \Omega = yG

xplus(-n"", y) 1

Gxplus(-n"", plus n y) 5G
xplus(-n"", s (plus n y)) 5

Gxplus(\Delta , case x of -o ffi y -- s ffi \Delta n.s (plus n y)"") 8G

xplus(\Delta , \Delta y.case x of -o ffi y -- s ffi \Delta n.s (plus n y)"") 2

As suggested in the introduction, the predicate G is very sensitive to syntax. This is
illustrated by the example below.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 125

1. f \Omega = yGx

f(U, y)

if y is a variable

2. G

x
f(U, a)G

xf(U, \Delta z.a)

3. G

x
f(U, e)G

xf(U, letrec g = e)

4. Gx

f(U, c)

5. G

xf(U, a) Gxf(U, b)

Gxf(U, a b)

6. G

x
f(U, z\Xi a)G

xf(U, f (z\Xi a)) if z \Phi  U

7. G

x
f(U, e) G

x
f(U, bi) (1 \Lambda  i \Lambda  n)G

x
f(U, case e of -c1 ffi b1 -- . . . -- cn ffi bn"")

if \Psi \Omega ff\Omega fi

e \Omega i z\Xi a,

(e i z\Xi a ^ z \Omega \Phi  U ffl -x"")

8. G

xf(U, aj) (1 \Lambda  j \Lambda  m) Gxf(Vi, ei) (1 \Lambda  i \Lambda  n)

Gxf(U, case (z a1 . . . am) of -c1 ffi b1 -- . . . -- cn ffi bn"")

if \Psi \Omega ff\Omega fi

z \Phi  U ffl -x""
bi i \Delta y1. . . . \Delta yar(ci). ei
Vi i U ffl -yj -- RP(j, D(ci)) for 1 \Lambda  j \Lambda  ar(ci)""

Fig. 6. Guarded-by-destructors rules

Example 4.6. Consider the following expression:

letrec plus = \Delta x. \Delta y. case x of -o ffi y--

s ffi \Delta n.s ((\Delta g. g n y) plus)""

This expression also deS,nes the addition of two natural numbers: it is obtained from the
plus function deS,ned in Example 4.1 by a \Pi -expansion. However, this deS,nition of plus
does not satisfy condition G because the occurrence of plus in the letrec body is not
the head of an application. So, when trying to prove the condition G we would have to
derive Gxplus(-n"", plus), which, by looking at the rules deS,ning G, we can immediately say
is underivable.

Another example of an expression not satisfying the guard condition is the Euclidean
division already considered.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 126

(var) \Lambda  \Xi  x : \Psi  if (x : \Psi ) \Phi  \Lambda 
(abs) \Lambda , x : \Omega  \Xi  e : \Psi \Lambda  \Xi  \Delta x.e : \Omega  \Lambda  \Psi 
(app) \Lambda  \Xi  e : \Omega  \Lambda  \Psi  \Lambda  \Xi  e\Upsilon  : \Omega \Lambda  \Xi  e e\Upsilon  : \Psi 
(cons) \Lambda  \Xi  c : Inst

c \Xi \Omega  \Lambda  d\Xi \Omega 

if c \Phi  C(d)

(case) \Lambda  \Xi  e : d\Xi \Omega  \Lambda  \Xi  e

i : Instci \Xi \Omega  \Lambda  \Theta  (1 \Lambda  i \Lambda  n)

\Lambda  \Xi  case e of -c1 ffi e1 -- . . . -- cn ffi en"" : \Theta  if C(d) = -c1, . . . , c

n""

(rec) \Lambda , f : d\Xi \Omega  \Lambda  \Psi  \Xi  e : d\Xi \Omega  \Lambda  \Psi  G

x
f(\Delta , a)

\Lambda  \Xi  (letrec f = e) : d\Xi \Omega  \Lambda  \Psi  if e i \Delta x.a

Fig. 7. Typing rules for \Delta G
Example 4.7. The Euclidean division deS,ned in Example 2.21 does not satisfy G for in
the recursive call of the div function (div (minus x\Upsilon  y) y) its argument (minus x\Upsilon  y) is not
a recursive component of its formal argument (x), but instead the result of applying the
previously deS,ned minus to a recursive component (x\Upsilon ) of x.

We now turn to the typing system. First, one needs to deS,ne instances of constructors.
The deS,nition is almost identical to the one for \Delta \Delta , the only difference being the absence
of stages.

DeS,nition 4.8. Let d \Phi  D, c \Phi  C(d) and \Xi \Omega  \Phi  T such that #\Xi \Omega  = ar(d). Assume D(c) =
(\Upsilon ,\Xi \Lambda ,\Xi \Psi ). An instance of c with respect to \Xi \Omega  is deS,ned as follows:

Instc \Xi \Omega  = \Xi \Psi [\Upsilon  := d\Xi \Omega ][\Xi \Lambda  := \Xi \Omega ].
Typing of terms is deS,ned in the usual way.
DeS,nition 4.9 (Typing). The typing judgment \Lambda  \Xi  e : \Psi  is derivable if it can be inferred
by the rules of Figure 7, where Gxf(\Delta , a) is the guarded-by-destructors condition deS,ned
in Figure 6.

We will now present some properties of \Delta G that will be used in the interpretation of \Delta G
into \Delta \Delta  exhibited in the following section.

Lemma 4.10. \Lambda 1, \Lambda 2, x : \Omega , \Lambda 3 \Xi  a : \Psi  ffi \Lambda 1, x : \Omega , \Lambda 2, \Lambda 3 \Xi  a : \Psi .

Proof. The proof is by induction on the derivation of \Lambda 1, \Lambda 2, x : \Omega , \Lambda 3 \Xi  a : \Psi .
Lemma 4.11 (Generation lemma for G). If Gxf(U, a) has a derivation D, then only one
rule can be applied as the last step of D.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 127

Proof. The proof is by case analysis on a. Note that only the conclusions of the rules
5 and 6 can be matched. Furthermore, in order to match the conclusions of such rules, a
must be of the form f (z\Xi b), in which case rule 5 cannot be applied as last rule since its
left premise would be underivable.

Lemma 4.12. If Gxf(U, a) and U \Psi  V , then Gxf(V , a).

Proof. The proof is by induction on the derivation of Gxf(U, a). The interesting case is
when the last rule applied is rule 7.

Assume a i case e of -c1 ffi b1 -- . . . -- cn ffi bn"" and that the last step isG

xf(U, e) Gxf(U, bi) (1 \Lambda  i \Lambda  n)

Gxf(U, case e of -c1 ffi b1 -- . . . -- cn ffi bn"") .
D^ If e \Omega i z\Xi a or if e i z a1 . . . am, z \Omega \Phi  U ffl -x"" and z \Omega \Phi  V , then by induction hypothesisG

xf(V , e) and Gxf(V , bi) for 1 \Lambda  i \Lambda  n, thus Gxf(V , a) can be derived using rule 7.

D^ Now consider e i z a1 . . . am, z \Omega \Phi  U ffl -x"" and z \Phi  V . Each bi must be of the form

\Delta y1. . . . \Delta yar(ci). ei. Let Qi i V ffl -yj -- RP(j, D(ci)) for 1 \Lambda  j \Lambda  ar(ci)"". For 1 \Lambda  i \Lambda  n,
since V \Psi  Qi, using the induction hypothesis Gxf(Qi, bi), and then, by Lemma 4.11,G

xf(Qi, ei). Also, from the induction hypothesis we have Gxf(V , aj) for 1 \Lambda  j \Lambda  m, and

therefore, applying rule 8, Gxf(V , a).
The remaining cases can be easily proved using the induction hypothesis.

Lemma 4.13 (Generation lemma for \Delta G).
1 \Lambda  \Xi  x : \Psi  ffi (x : \Psi ) \Phi  \Lambda .
2 \Lambda  \Xi  e e\Upsilon  : \Psi  ffi * \Omega  \Phi  T. \Lambda  \Xi  e : \Omega  \Lambda  \Psi  ^ \Lambda  \Xi  e\Upsilon  : \Omega .
3 \Lambda  \Xi  \Delta x.e : \Theta  ffi \Theta  i \Omega  \Lambda  \Psi  ^ \Lambda , x : \Omega  \Xi  e : \Psi .
4 \Lambda  \Xi  c : \Theta  ffi \Theta  i Instc \Xi \Omega  \Lambda  d\Xi \Omega  with c \Phi  C(d).
5 \Lambda  \Xi  case e of -c1 ffi e1-- . . . --cn ffi en"" : \Theta  ffi * d \Phi  D *\Xi \Omega  \Phi  T. \Lambda  \Xi  e : d\Xi \Omega  ^ \Lambda  \Xi  ei :

Instci \Xi \Omega  \Lambda  \Theta  for 1 \Lambda  i \Lambda  n with ci \Phi  C(d).
6 \Lambda  \Xi  letrec f = e : \Theta  ffi \Theta  i d\Xi \Omega  \Lambda  \Psi  ^ \Lambda , f : d\Xi \Omega  \Lambda  \Psi  \Xi  e : d\Xi \Omega  \Lambda  \Psi  ^ e i

\Delta x.a ^ Gxf(\Delta , a).

4.2. From \Delta G to \Delta \Delta 
In this section we show that \Delta \Delta  is a more general system than \Delta G. The Examples 4.6
and 4.7 already illustrated that some terms typable in \Delta \Delta  cannot be typed in \Delta G. In this
section we show that: if \Lambda  \Xi \Delta G a : \Psi  then \Lambda  \Xi \Delta \Delta  a : \Psi  (the subscript at the turnstyle
sign indicating the type system considered). Naturally, the main difficulty in passing from
\Delta G to \Delta \Delta  is posed by letrec-expressions because the two systems have different kinds of
typing rules for these expressions.

Given \Lambda  \Xi \Delta G letrec f = \Delta x.a : d\Xi \Omega  \Lambda  \Psi , by the generation lemma for \Delta G, we have

\Lambda , f : d\Xi \Omega  \Lambda  \Psi , x : d\Xi \Omega  \Xi \Delta G a : \Psi  ^ Gxf(\Delta , a). (6)
However, we would want to have

\Lambda , f : dZ^\Xi \Omega  \Lambda  \Psi , x : d\Delta Z^\Xi \Omega  \Xi \Delta \Delta  a : \Psi  (Z^ fresh in \Lambda ,\Xi \Omega ) (7)

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 128
in order to use the \Delta \Delta  rec-rule and so derive \Lambda  \Xi \Delta \Delta  letrec f = \Delta x.a : d\Xi \Omega  \Lambda  \Psi . Intuitively,
(6) is sufficient to guarantee (7) because, as we have Gxf(\Delta , a), all the possible occurrences
of f in a are of the form f (z\Xi a), with z being a recursive component of x. In (7) we have
x : d\Delta Z^\Xi \Omega , so, if z is a recursive component of x, we should have z : \Xi ff \Lambda  dZ^\Xi \Omega . Hence f (z\Xi a) is
also typable in \Delta \Delta  .

The remainder of this subsection is devoted to the embedding of \Delta G into \Delta \Delta . In
this embedding the Main Lemma below plays a central role. There we present the full
construction underlying the lemma because it lays open the details of the relation between
the systems \Delta G and \Delta \Delta  .

In the following we assume that each variable xi is uniquely associated to a stage
variable ji. Recall also that, in \Delta \Delta , the notation d\Xi \Omega  abbreviates the datatype d\Sigma \Xi \Omega .

Lemma 4.14 (Main Lemma). Let

\Lambda 0 = \Lambda 
\Lambda i = \Lambda iL/1, fi : di \Xi \Omega i \Lambda  \Psi i, xi : di \Xi \Omega i for 1 \Lambda  i \Lambda  nfl

\Lambda 0 = \Lambda 0fl
\Lambda i = ffi\Lambda iL/1, fi : djii \Xi \Omega i \Lambda  \Psi i, xi : d\Delta jii \Xi \Omega i for 1 \Lambda  i \Lambda  n

where ji is a fresh stage variable
associated to xi

and, for 1 \Lambda  i \Lambda  n, let Ui be a set of variables such that for each z \Phi  Ui, z : \Xi ff \Lambda  di\Xi \Omega i \Phi  \Lambda 
and so that all the UiR^s are disjoint. Then,

\Lambda n \Xi \Delta G a : \Psi  ^ ffl_i \Phi  -1, . . . , n"". Gxifi (Ui, a)i ffi [fl\Lambda n]U \Xi \Delta \Delta  a : \Psi 

where U = \Sigma 1\Lambda i\Lambda n Ui and [fl\Lambda n]U is obtained from fl\Lambda n by replacing each declaration
z : \Xi ff \Lambda  di\Xi \Omega i (with z \Phi  Ui) by z : \Xi ff \Lambda  djii \Xi \Omega i. Note that in order to make \Lambda n a context, in
particular, all the fiR^s and xiR^s must be distinct and cannot be declared in \Lambda .

Proof. The proof is by induction on the structure of a.
1 Case a i x: the hypothesis is

\Lambda n \Xi \Delta G x : \Psi  ^ _i \Phi  -1, . . . , n"". Gxifi (Ui, x).

D^ If x i xi for some i \Phi  -1, . . . , n"", then \Psi  i di \Xi \Omega i, so, [fl\Lambda n]U \Xi \Delta \Delta  x : d\Delta jii \Xi \Omega i. As

d\Delta jii \Xi \Omega i j d\Sigma i \Xi \Omega i, using the rule (sub),

[fl\Lambda n]U \Xi \Delta \Delta  x : di\Xi \Omega i.
D^ If x \Omega i xi for every i \Phi  -1, . . . , n"", then, since _i \Phi  -1, . . . , n"". Gxifi (Ui, x), x \Omega i fi for

every i \Phi  -1, . . . , n"". Therefore, using Lemma 4.13, (x : \Psi ) \Phi  \Lambda . Hence,

(a) If x \Omega \Phi  U, then [fl\Lambda n]U \Xi \Delta \Delta  x : \Psi .
(b) If x \Phi  U, then, \Psi  i \Xi ff \Lambda  di\Xi \Omega i for some i \Phi  -1, . . . , n"". So, [fl\Lambda n]U \Xi \Delta \Delta  x : \Xi ff \Lambda  djii \Xi \Omega i,

and, since \Xi ff \Lambda  djii \Xi \Omega i j \Xi ff \Lambda  d\Sigma i \Xi \Omega i, by (sub)

[fl\Lambda n]U \Xi \Delta \Delta  x : \Psi .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 129
2 Case a i e e\Upsilon : the hypothesis is

\Lambda n \Xi \Delta G e e\Upsilon  : \Psi  ^ _i \Phi  -1, . . . , n"". Gxifi (Ui, e e\Upsilon ).

D^ If e i fi for some i \Phi  -1, . . . , n"", then, by Lemma 4.11, e\Upsilon  i z\Xi b, Gxifi (Ui, e\Upsilon ) and

z \Phi  Ui. Moreover:

(a) \Lambda n \Xi \Delta G fi : di\Xi \Omega i \Lambda  \Psi i and \Psi  i \Psi i. So, [fl\Lambda n]U \Xi \Delta \Delta  fi : djii \Xi \Omega i \Lambda  \Psi .
(b) \Lambda n \Xi \Delta G z : \Xi ff \Lambda  di\Xi \Omega i. So, [fl\Lambda n]U \Xi \Delta \Delta  z : \Xi ff \Lambda  djii \Xi \Omega i because z \Phi  Ui.

(c) \Lambda n \Xi \Delta G \Xi b : \Xi ff (using this notation to abbreviate the list of judgments \Lambda n \Xi \Delta G

bk : ffk for each bk \Phi  \Xi b) and for every bk \Phi  \Xi b, Gxifi (Ui, bk) because z \Omega = fi. For

j \Phi  -1, . . . , n"" L/ -i"", e \Omega = fj and, by Lemma 4.11, Gxjfj (Uj, bk) for every bk \Phi  \Xi b.
Therefore, by the induction hypothesis,

[fl\Lambda n]U \Xi \Delta \Delta  \Xi b : \Xi ff.
From (a), (b) and (c), using (app), we then get

[fl\Lambda n]U \Xi \Delta \Delta  fi (z\Xi b) : \Psi .
D^ If e \Omega i fi for every i \Phi  -1, . . . , n"", then, using Lemmas 4.11 and 4.13,

\Lambda n \Xi \Delta G e : ff \Lambda  \Psi  ^ \Lambda n \Xi \Delta G e\Upsilon  : ff
and _

i \Phi  -1, . . . , n"". Gxifi (Ui, e) ^ Gxifi (Ui, e\Upsilon ).
Hence, by the induction hypothesis,

[fl\Lambda n]U \Xi \Delta \Delta  e : ff \Lambda  \Psi  ^ [fl\Lambda n]U \Xi \Delta \Delta  e\Upsilon  : ff.
Using the rule (app), we get [fl\Lambda n]U \Xi \Delta \Delta  e e\Upsilon  : \Psi .
3 Case a i \Delta y.e: the hypothesis is

\Lambda n \Xi \Delta G \Delta y.e : \Psi  ^ _i \Phi  -1, . . . , n"". Gxifi (Ui, \Delta y.e).
Using Lemmas 4.13 and 4.10, \Psi  i ff \Lambda  \Psi \Upsilon  for some ff, \Psi \Upsilon  \Phi  T, and

\Lambda , y : ff, f1 : d1\Xi \Omega 1 \Lambda  \Psi 2, x1 : d1\Xi \Omega 1, . . . , fn : dn\Xi \Omega n \Lambda  \Psi , xn : dn\Xi \Omega n \Xi \Delta G e : \Psi \Upsilon .
By Lemma 4.11, _i \Phi  -1, . . . , n"". Gxifi (Ui, e). Hence, by the induction hypothesis,j

\Lambda , y : ff, f1 : dj11 \Xi \Omega 1 \Lambda  \Psi 1, x1 : d\Delta j11 \Xi \Omega 1, . . . , fn : djnn \Xi \Omega n \Lambda  \Psi n, xn : d\Delta jnn \Xi \Omega n`U \Xi \Delta \Delta  e : \Psi \Upsilon .
We know that y \Omega \Phi  \Lambda , so y \Omega \Phi  U. Therefore, using Lemma 3.6, [fl\Lambda n]U, y : ff \Xi \Delta \Delta  e : \Psi \Upsilon  and
the proof of this case is concluded by applying rule (abs).
4 Case a i c and c \Phi  C(d): we assume \Lambda n \Xi \Delta G c : Instc \Xi \Omega  \Lambda  d\Xi \Omega  . Thus in \Delta \Delta  we can

apply (cons) to obtain [fl\Lambda n]U \Xi \Delta \Delta  c : Inst\Sigma c \Xi \Omega  \Lambda  d\Delta \Sigma \Xi \Omega , and since, Instc \Xi \Omega  is being used as
an abbreviation for Inst\Sigma c \Xi \Omega  and d\Delta \Sigma \Xi \Omega  j d\Sigma \Xi \Omega , we also have

[fl\Lambda n]U \Xi \Delta \Delta  c : Instc \Xi \Omega  \Lambda  d\Xi \Omega .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 130
5 Case a i case e of -c1 ffi b1-- . . . --cm ffi bm"": the hypotheses are

\Lambda n \Xi \Delta G case e of -\Xi c ffi \Xi b"" : \Psi  (8)_
i \Phi  -1, . . . , n"". Gxifi (Ui, case e of -\Xi c ffi \Xi b"") (9)

and from (8), applying Lemma 4.13, there exists d, \Xi \Omega  such that

\Lambda n \Xi \Delta G e : d\Xi \Omega  (10)
\Lambda n \Xi \Delta G bk : Instck \Xi \Omega  \Lambda  \Psi  (11)

for each 1 \Lambda  k \Lambda  m. Two cases can now occur:
D^ If e \Omega i z\Xi a or e i z\Xi a and z \Omega \Phi  Ui ffl -xi"" for every i \Phi  -1, . . . , n"", then from (9) by

Lemma 4.11,

_i \Phi  -1, . . . , n""._k \Phi  -1, . . . , m"". Gxifi (Ui, e) ^ Gxifi (Ui, bk).
Thus, applying the induction hypothesis to (10), followed by rule (sub), we have
[fl\Lambda n]U \Xi \Delta \Delta  e : d\Delta \Sigma \Xi \Omega , and applying the induction hypothesis to (11), we get [fl\Lambda n]U \Xi \Delta \Delta 
bk : Inst\Sigma ck \Xi \Omega  \Lambda  \Psi . Derivations of these judgments can now be put together by means
of the rule (case), proving

[fl\Lambda n]U \Xi \Delta \Delta  case e of -\Xi c ffi \Xi b"" : \Psi .
D^ Assume now that e i z\Xi a and z \Phi  Ui ffl -xi"" for some i \Phi  -1, . . . , n"" (recall that such

i must be unique since the UjR^s are disjoint and contain none of the xjR^s, and the
xjR^s are distinct). Let, for each 1 \Lambda  k \Lambda  m,\Psi \Omega \Omega ff

\Omega \Omega fi

bk i \Delta \Xi yk.ek
Vk,i i Ui ffl -yk,r -- RP(r, D(ck)) for 1 \Lambda  r \Lambda  ar(ck)""
Vk,j i Uj for j \Phi  -1, . . . , n"" L/ -i""
Vk i \Sigma 1\Lambda j\Lambda n Vk,j

where yk,r denotes the r-th component of vector \Xi yk. Applying Lemma 4.11 to (9),
we can now assume that for each 1 \Lambda  j \Lambda  n

_ as \Phi  \Xi a . Gxjfj (Uj, as) ^ _ k \Phi  -1, . . . , m"" . Gxjfj (Vk,j, ek). (12)
From (11) by Lemmas 4.13 and 4.10, we have

\Lambda , \Xi yk : Instck \Xi \Omega , \Lambda n \ \Lambda  \Xi \Delta G ek : \Psi 
where \Lambda n \ \Lambda  is the context \Lambda n without the declarations in \Lambda . Moreover, yk,r :

\Xi ffyk,r \Lambda  di\Xi \Omega i \Phi  (\Xi yk : Instck \Xi \Omega ) for each 1 \Lambda  r \Lambda  ar(ck) such that RP(r, D(ck)) and
thus, for each 1 \Lambda  k \Lambda  m and 1 \Lambda  j \Lambda  n, and for each z \Phi  Vk,j, we have
z : \Xi ffz \Lambda  di\Xi \Omega i \Phi  (\Lambda , \Xi yk : Instck \Xi \Omega ). Hence, by the induction hypothesis,

[ ffi\Lambda , \Xi yk : Instck \Xi \Omega , \Lambda n \ \Lambda ]Vk \Xi \Delta \Delta  ek : \Psi ,
from which one can show [fl\Lambda n]U, \Xi yk : Instjick \Xi \Omega  \Xi \Delta \Delta  ek : \Psi  (observe that Vk = U ffl-yk,r --
RP(r, D(ck)) for 1 \Lambda  r \Lambda  ar(ck)"") and therefore, by the rule (abs), [fl\Lambda n]U \Xi \Delta \Delta  bk :
Instjick \Xi \Omega  \Lambda  \Psi  holds.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 131

To conclude the proof of this case, it now suffices to show that

[fl\Lambda n]U \Xi \Delta \Delta  e : d\Delta jii \Xi \Omega i, (13)
and then to use the rule (case). In order to prove (13), we proceed as follows:
(a) Case e i xi, [fl\Lambda n]U \Xi \Delta \Delta  xi : d\Delta jii \Xi \Omega i is derivable.
(b) Case e i z\Xi a with z \Phi  Ui, from (10) by Lemma 4.13, \Lambda n \Xi \Delta G z : \Xi ff \Lambda  d\Xi \Omega  (thus,

d\Xi \Omega  i di \Xi \Omega i) and

\Lambda n \Xi \Delta G \Xi a : \Xi ff. (14)
Now, since (12) holds, we can apply the induction hypothesis to (14) to obtain
[fl\Lambda n]U \Xi \Delta \Delta  \Xi a : \Xi ff. It is also true that z : \Xi ff \Lambda  djii \Xi \Omega i \Phi  [fl\Lambda n]U, for z \Phi  Ui, and since
\Xi ff \Lambda  djii \Xi \Omega i j \Xi ff \Lambda  d\Delta jii \Xi \Omega i, by (sub) and (app), [fl\Lambda n]U \Xi \Delta \Delta  z\Xi a : d\Delta jii \Xi \Omega i holds.

6 Case a i letrec f = \Delta x.a\Upsilon : we must have \Psi  i d\Xi \Omega  \Lambda  \Psi \Upsilon  for some d\Xi \Omega , \Psi \Upsilon  \Phi  T, and the

hypothesis is

\Lambda n \Xi \Delta G letrec f = \Delta x.a\Upsilon  : d\Xi \Omega  \Lambda  \Psi \Upsilon  ^ _i \Phi  -1, . . . , n"". Gxifi (Ui, letrec f = \Delta x.a\Upsilon ).
By Lemma 4.13, we get

\Lambda n, f : d\Xi \Omega  \Lambda  \Psi \Upsilon , x : d\Xi \Omega  \Xi \Delta G a\Upsilon  : \Psi \Upsilon 
and Gxf(\Delta , a\Upsilon ). Again by the hypothesis, by Lemma 4.11, _i \Phi  -1, . . . , n"". Gxifi (Ui, a\Upsilon ), and

hence, assuming Un+1 = \Delta , xn+1 = x and fn+1 = f, we have_

i \Phi  -1, . . . , n + 1"". Gxifi (Ui, a\Upsilon ).

So, by the induction hypothesis, [ ffi\Lambda n+1]U \Xi \Delta \Delta  a\Upsilon  : \Psi \Upsilon . Applying (abs) and (rec), we get
[fl\Lambda n]U \Xi \Delta \Delta  letrec f = \Delta x.a\Upsilon  : (dZ^\Xi \Omega  \Lambda  \Psi \Upsilon )[Z^ := \Sigma ]. Hence, for Z^ has no occurrences in
either \Xi \Omega  or \Psi \Upsilon ,

[fl\Lambda n]U \Xi \Delta \Delta  (letrec f = \Delta x.a\Upsilon ) : d\Xi \Omega  \Lambda  \Psi \Upsilon .

We are now ready to prove the main result of this section.
Proposition 4.15.

\Lambda  \Xi \Delta G a : \Psi  ffi \Lambda  \Xi \Delta \Delta  a : \Psi .

Proof. The proof is by induction on the derivation of \Lambda  \Xi \Delta G a : \Psi .
(rec) Assume the last step is

\Lambda , f : d\Xi \Omega  \Lambda  \Psi  \Xi \Delta G e : d\Xi \Omega  \Lambda  \Psi  Gxf(\Delta , a)

\Lambda  \Xi \Delta G (letrec f = e) : d\Xi \Omega  \Lambda  \Psi  with e i \Delta x.a
By Lemma 4.13, \Lambda , f : d\Xi \Omega  \Lambda  \Psi , x : d\Xi \Omega  \Xi \Delta G a : \Psi , and since Gxf(\Delta , a), we have the
conditions for applying the Main Lemma and conclude \Lambda , f : dZ^\Xi \Omega  \Lambda  \Psi , x : d\Delta Z^\Xi \Omega  \Xi \Delta \Delta  a : \Psi .
Hence, applying the rules (abs) and (rec), we derive \Lambda  \Xi \Delta \Delta  (letrec f = e) : (dZ^\Xi \Omega  \Lambda 
\Psi )[Z^ := \Sigma ], which is the same as

\Lambda  \Xi \Delta \Delta  (letrec f = e) : d\Xi \Omega  \Lambda  \Psi 
for Z^ does not occur in \Psi  or \Xi \Omega .

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 132

All the remaining cases can be easily proved using the induction hypothesis.

5. Extension to coinductive types
Coinductive types are a mechanism for the introduction of inS,nite objects into type theory,
and are useful in the modelling of perpetual computations, for example, the operation of
process systems. The system \Delta \Delta  is readily extensible to support coinductive types. We shall
here outline the syntax of an appropriate extension of \Delta \Delta  and give some programming
examples.

First, the deS,nition of the set E of terms is extended with corecursive deS,nitions:

e ::= . . . -- (coletrec f = e).
In addition to \Pi -, \Sigma - and t,-reduction, we deS,ne j-reduction as the compatible closure of
the rule

case (coletrec f = e) \Xi a of -c1 ffi e1 -- . . . -- cn ffi en""\Lambda 

j case e[f := (coletrec f = e)] \Xi a of -c1 ffi e1 -- . . . -- cn ffi en"".
The form of the j-reduction rule may look unexpected, but it is dual to t,-reduction: while
the t,-reduction rule allows unfolding of a recursive deS,nition provided that the argument
value is produced by a constructor, the j-reduction rule allows it, if the result value is
consumed by a case-expression.

Second, the deS,nition of the set T of type expressions is extended with codatatype
approximation expressions:

\Psi , \Omega  ::= . . . -- cods \Xi \Omega 
cod\Sigma  \Xi \Omega  will also be written as cod \Xi \Omega .

The subtyping rules are supplemented by the following (codata) rule, which is dual to
the (data) rule:

(codata) s \Theta  r \Omega i j \Omega \Upsilon i (1 \Lambda  i \Lambda  ar(d))codr\Xi \Omega  j cods\Xi \Omega  .
The typing rules are supplemented by the rules (cons\Upsilon ), (case\Upsilon ) and (corec). The S,rst
two of these are essentially the same as the rules (cons), (case), but they are used for the
construction and destruction of values of coinductive, not inductive types. Below coInstsc \Xi \Omega 
stands for \Xi \Psi [\Upsilon  := cods\Xi \Omega ][\Xi \Lambda  := \Xi \Omega ].

(cons\Upsilon )

\Lambda  \Xi  c : coInstsc \Xi \Omega  \Lambda  cod\Delta s\Xi \Omega 

if c \Phi  C(d)

(case\Upsilon ) \Lambda  \Xi  e\Upsilon  :

cod\Delta s\Xi \Omega  \Lambda  \Xi  ei : coInstsc

i \Xi \Omega  \Lambda \Theta  (1 \Lambda  i \Lambda  n)

\Lambda  \Xi  case e\Upsilon  of -c1 ffi e1 -- . . . -- cn ffi en"" : \Theta  if C(d) = -c1 . . . , cn""

(corec) \Lambda , f : \Xi \Psi  \Lambda 

codZ^\Xi \Omega  \Xi  e : (\Xi \Psi  \Lambda  codZ^\Xi \Omega )[Z^ := \Delta Z^] Z^ pos \Xi \Psi 

\Lambda  \Xi  (coletrec f = e) : (\Xi \Psi  \Lambda  codZ^\Xi \Omega )[Z^ := s] if Z^ not in \Lambda ,\Xi \Omega .
Below are some programming examples that illustrate the use of co-recursive functions.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 133
Example 5.1.
D^ The colist of all natural numbers starting from a given one (in the ascending order).

(coletrec from = \Delta n. cons n (from (s n))) : Nat \Lambda  coList Nat
D^ The inS,nite colist consisting of zeros.

(coletrec zeros = cons o zeros) : coList Nat
D^ Concatenation of two colists. This program admits a type containing the information

that the concatenation of two colists is in the same approximation of the colist type
as the two individual colists are.

append i (coletrec append:coListZ^\Omega \Lambda coListZ^\Omega \Lambda coListZ^\Omega  =

\Delta x:coList\Delta Z^ \Omega . \Delta y:coList\Delta Z^ \Omega . case x of -nil ffi

:coList\Delta Z^ \Omega \Xi \Pi \Theta \Lambda 

y--
cons ffi \Delta a:\Omega . \Delta x\Upsilon :coListZ^\Omega . cons a (append x\Upsilon  y)\Theta  \Lambda \Xi  \Pi 

:coListZ^\Omega \Theta  \Lambda \Xi  \Pi 
:coList\Delta Z^\Omega ""

) : coLists \Omega  \Lambda coLists \Omega  \Lambda  coLists \Omega 
D^ Exchange of every S,rst and second element in a given colist.

(coletrec exch:coList\Omega \Lambda coListZ^\Omega  = \Delta l:coList\Omega .

case l of -

nil ffi nil--
cons ffi \Delta a:\Omega . \Delta l\Upsilon :coList\Omega .case l\Upsilon  of -

nil ffi cons a nil--
cons ffi \Delta a\Upsilon :\Omega . \Delta l\Upsilon \Upsilon :coList\Omega . cons a\Upsilon  (cons a (exch l\Upsilon \Upsilon )\Theta  \Lambda \Xi  \Pi 

:coListZ^\Omega 

)\Theta  \Lambda \Xi  \Pi 

:coList\Delta \Delta Z^\Omega  j coList\Delta Z^\Omega 

""

""
) : coList \Omega \Lambda  coLists \Omega 

Although the exchange function does not alter the length of a colist, the type we have
given to the program above is the best possible in our setting.
D^ Given a colist, compute its inS,nite repetition. The typability of this program is a

consequence of the typing we have given for append.

(coletrec rep:coListZ^\Omega \Lambda coListZ^\Omega  = \Delta l:coList\Delta Z^\Omega .

case l of -nil ffi nil--

cons ffi \Delta a:\Omega . \Delta l\Upsilon :coListZ^\Omega . cons a (append l\Upsilon  (rep l)\Theta  \Lambda \Xi  \Pi 

:coListZ^\Omega 

)\Theta  \Lambda \Xi  \Pi 

:coList\Delta Z^\Omega ""
) : coLists\Omega  \Lambda  coLists\Omega 

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 134

The extended \Delta \Delta  enjoys the same properties of subject reduction and strong normalisability of typable terms as the original \Delta \Delta . The proof for \Delta \Delta  extends readily; we omit it for
space reasons. We believe that \Delta G extended with guarded by constructors corecursion is
embeddable in the extended \Delta \Delta  as the original \Delta G is embeddable in \Delta \Delta .

6. Related work
For the sake of clarity, we will divide the existing systems into S,ve categories:
(1) Those based on traditional-style terminating recursors.
(2) Those based on a S,xpoint operator controlled by a syntactic guard predicate.
(3) Those exploiting pattern matching.
(4) Those based on a S,xpoint operator controlled by an unusual typing ensuring that

the recursion actually terminates.
(5) Those relying on other type-based techniques for ensuring termination.

Comparison with Martin-Ll'of (1971) and other work on traditional-style terminating
recursors

Most formalisations of inductive types in type theory only support recursive deS,nitions indirectly via eliminators behaving as iterators or primitive recursors (Martin-Ll'of
1971; Leivant 1983; Pierce et al. 1989; Pfenning and Paulin-Mohring 1990; Coquand
and Paulin 1990; Paulin-Mohring 1993; Dybjer 1994; Geuvers 1992; Altenkirch 1999;
Matthes 1999; Sp\Pi lawski and Urzyczyn 1999). Such systems are well understood metatheoretically and enjoy good properties, but are hard to use in practical programming:
this requires the programmer to translate all recursive deS,nitions he would like to make
into explicit deS,nitions involving primitive recursion.

It is possible to devise similar eliminators capturing more sophisticated schemes
of terminating recursion such as course-of-value iteration or course-of-value primitive
recursion (Uustalu 1998; McBride 1999), but the resulting systems are even clumsier to
use in practice.

Comparison with Coquand (1994) and other work relying on a S,xpoint operator controlled
by an external guard predicate

Coquand (1994) introduces a simple guard predicate to ensure termination of S,xpoint
expressions in a calculus of inS,nite objects. Building on CoquandR^s work, Gimt^enez (1995)
deS,nes a more liberal guarded-by-constructors predicate for terminating corecursion as
well as a guarded-by-destructors predicate for terminating recursion. Gimt^enez shows
that primitive recursor expressions can be rendered as S,xpoint expressions guarded by
one destructor. In the reverse direction, a S,xpoint expression guarded by destructors
can be coded as an expression involving primitive recursors, but the translation is
not uniform. The predicates deS,ned by Gimt^enez form the basis of the mechanism for
(co)inductive types in Coq. More recently, Blanqui et al. (2002), building on Jouannaud
and Okada (1997), proposed another deS,nition of the guard predicate for inductive types

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 135
that allows for yet more expressions to be typed. Following a similar line of research,
Abel and Altenkirch (2002) proposed a basic framework for studying and comparing the
different termination conditions that have been proposed so far, focusing their attention
on what conditions should be fulS,lled for a checking to be sound. An application of such
framework to a particular condition can be found in Abel (2000).

One possible objection to this line of work is that the system becomes more unpredictable to the user as the complexity of the guard predicate builds up. Besides, the guard
predicate remains purely syntactic, which is not appropriate for a number of applications,
including separate compilation or interactive proof construction.

Comparison with Coquand (1992) and other work on pattern-matching
Coquand (1992) pioneered the use of pattern-matching in type theory. While patternmatching yields leaner deS,nitions, its proof-theoretical status in the context of dependent
types remains unclear. Unlike guarded-by-destructors recursion, general pattern-matching
is not a conservative improvement over primitive recursors: Hofmann and Streicher (1994)
proved the derivability of uniqueness of equality proofs in a type theory with patternmatching, while equality proofs cannot be shown to be unique in the usual Calculus
of Inductive Constructions. To our knowledge, there is no complete account of the
meta-theoretical properties of pattern-matching in dependent type theory. McBride (1999)
showed that, under the uniqueness of equality proofs as an extra axiom, pattern matching is
admissible. Gimt^enez has remarked (Gimt^enez 1996) that in a typing system with dependent
pattern matching the computation rule used in this article for corecursive deS,nitions only
satisS,es a weak form of the subject reduction property. Ongoing work on checking the
termination of recursive function deS,nitions in functional languages (see, for example,
Telford and Turner (1997), Abel and Altenkirch (2002), Giesl et al. (1998), and Manoury
and Simonot (1994)) is relevant for this direction of type-theoretic developments. Of
particular interest for the future type-theoretic formalisations might be recent work (Lee
et al. 2001) on the size-change principle for program termination.

As for implementations, restricted forms of pattern-matching have been implemented
in Coq (Cornes 1997) and Lego (Elbers 1998). Both implementations take advantage of
translations to recursors. Pattern-matching has also been consistently supported in Alf
and its subsequent versions, although no mechanism for termination checking was ever
implemented. In order to simplify the proof engine, Agda, which is the latest incarnation
of Alf, only supports a limited form of pattern-matching in which variables are only
allowed to occur once in the type of a constructor. This restriction rules out, for example,
inductive deS,nitions such as equality.

Comparison with Gimt^enez (1998) and other work on guarded types
This line of work is really about non-traditional-style terminating recursors that look like
S,xpoint operators, but where the computation is guaranteed to terminate by an unusual
(stronger) typing system. Such a system involves introducing some kind of annotations on
recursive types, a notion of sub-typing enabling the transformation of such annotations,

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 136
and a typing rule for the term letrec f = e where the type of f and the type of e are
marked differently. In this sense, some of the systems mentioned in this section are not
far from the so called abstract interpretation techniques (Cousot and Cousot 1996), even
though they are formulated from a type-theoretical point of view. The exact relation
of such typing systems with respect to abstract interpretation techniques has not been
studied in detail yet, and could be a subject for further research.

Mendler (1987) was, as far as we are aware, the S,rst author to propose a formalisation
of inductive and coinductive types in a simply typed lambda calculus where primitive
recursion and primitive corecursion were formulated in a S,xpoint-like style. In MendlerR^s
system, type annotations on the S,xpoint rule correspond to type variables. Mendler (1991)
considered a system supporting only iteration and coiteration. Work that comments on
these two papers include Leivant (1990), Geuvers (1992), Uustalu and Vene (1997),
Uustalu (1998), Matthes (1998; 2002), and Sp\Pi lawski and Urzyczyn (1999). Of these,
Leivant (1990) and Geuvers (1992) were the S,rst papers to contrast and compare
traditional-style and Mendler-style terminating recursors. Uustalu and Vene (1997; 2002)
and Uustalu (1998) showed that MendlerR^s approach is readily generalisable for courseof-value (co)recursion (in other words, full structural (co)recursion).

Gimt^enez (1996) introduced an extension of the Calculus of Constructions with inductive
and coinductive types, called CC\Sigma . The S,xpoint rules in CC\Sigma  make use of three kinds
of marks, corresponding, using the notation of this article, to the stages \Sigma , \Sigma  and ^\Sigma . This
means that in CC\Sigma  the hat operator cannot be applied to another stage, but only to
stage variables. In Gimt^enez (1996), marks also have a second component, which speciS,es
whether the recursive type is inductive or coinductive. There is no stage polymorphism,
and hence the function div of Example 2.21 cannot be typed.

One of the main disadvantages of Gimt^enez (1996) is that it tried to tackle too many
problems at once, rendering the typing calculus less clear. Among the extra features
introduced in CC\Sigma  that are not considered in this article we may cite the following:

D^ Inductive lists are considered a subtype of coinductive ones, so that a function deS,ned

on the type coList can also be used on an element of type List.

D^ Annotations are placed on typing judgments, writing x :s List instead of x : Lists.

One of the original motivations for this notation was to enable the description of
abstract recursion schema, where the type of the decreasing argument of the function
is abstracted away using a term of the form \Delta A : Set * letrec f = \Delta x :s A * e.
Also, the choice of having two different universal quantiS,ers renders unnecessary the
introduction of two types of lists (one for inductive lists and the other for coinductive
ones) with the same constructors. On the other hand, it is less clear how an ordinal
based semantics like the one proposed in this paper could be used to make sense
of a term of the form \Delta A : Set * \Delta x :s A * e. This is why, even though annotated
quantiS,cations were kept, the calculus in Gimt^enez (1996) forces A in a term of the
form \Delta x :s A * e to have a recursive type at its rightmost position.

D^ C\Sigma  is built on top of the Calculus of Constructions, so it uses ChurchR^s style for

variable binding, where the type of the abstracted variable is explicitly mentioned.
Thus, types E^ and hence marks E^ may appear in the terms. As a consequence, the

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 137

reduction rule for S,xpoints has to replace all mark variables by the \Sigma  mark in order
to avoid having residual unbound mark identiS,ers in the deS,niens. Note that this
problem does not arise in \Delta \Delta , where variable binding is R'`a la CurryR^.

Gimt^enez (1998) introduced CCR, a different extension of the Calculus of Constructions
with inductive and coinductive types, based on (not fully general) sub- and supertyping
and bounded universal quantiS,cation over types. In CCR, marks are represented as type
variables (as in MendlerR^s work), the hat operator is a type constructor, and stages are
just types. Since stage variables are type variables, stage replacement just corresponds
to the ordinary substitution operation of the calculus. The calculus in Gimt^enez (1998)
was the S,rst calculus to introduce stage polymorphism, enabling us to type deS,nitions like
the function div of Example 2.21 and the stream rep of Example 5.1. The calculus of the
present paper is very much inspired by Gimt^enez (1998), but replaces sub- and supertypes
with approximating types, and bounded type quantiS,cation with stage quantiS,cation E^
the change allows the structure of stages to be uniform over all datatypes and simpliS,es
the introduction of recursive deS,nitions on mutually dependent inductive types. No
studies have yet been made of the meta-theory of CCR or its connection to implemented
extensions of a calculus of (co)inductive constructions like the system Coq. The detailed
study of the main meta-theoretical properties of \Delta \Delta  presented in this paper can be seen as a
basic stage for developing the meta-theory of an extension of the Calculus of Construction
where the termination of functions is ensured by typing constraints.

Amadio and Coupet-Grimal (1998) deS,nes a simply typed \Delta -calculus R'`a la CurryR^
featuring guarded coinductive types. Starting from CoquandR^s guardedness condition, they
propose a semantics for such an extension of lambda calculus based on partial equivalent
relations and ordinal iteration to interpret coinductive types. From that semantics, they
derive a typing rule for corecursive deS,nitions using a mark system with three kinds
of marks, which correspond in our notation to \Sigma , \Sigma  and ^\Sigma . The semantic interpretation
used to study the meta-theory of \Delta \Delta  in this article is actually an extension of the one
introduced in Amadio and Coupet-Grimal (1998) for coinductive types. Also, the need
for the constraint Z^ pos \Psi  in the typing rule for recursive deS,nitions has already been
noticed by Amadio and Coupet. Their calculus introduces an extra rule enabling the
treatment of nested S,xpoint deS,nitions of the form (letrec f = (letrec g = e)) by reusing
the mark introduced in the deS,nition of f as the mark for the variable g. However, the
calculus described in Amadio and Coupet-Grimal (1998) lacks full stage polymorphism,
so deS,nitions like the function rep in Example 5.1 cannot be typed in their system. Their
calculus does not consider inductive types. On the positive side, their calculus is shown to
have decidable type inference in Bac (1998).

Barras (1999) formalises in Coq a variant of Gimt^enezR^ calculus CC\Sigma , with the aim
of proving the decidability of its typing judgment and extracting a type-checker from
the proof. In BarrasR^ calculus, inductive types are annotated with lists of marks, each
corresponding to the stages \Sigma , \Sigma  and ^\Sigma  of our system. The use of lists of marks enables
the typing of nested recursive function deS,nitions like the ones considered in Amadio
and Coupet-Grimal (1998), but for inductive types. He does not consider coinductive
types nor stage polymorphism. As the underlying lambda calculus is R'`a la ChurchR^, Barras

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 138
introduces a distinguished primitive type M for marks, and marks are just variables
of that type. Mark variables are bound in S,xpoint terms, so mark erasure in S,xpoint
reductions just corresponds to ordinary variable substitution. The complete meta-theory
of BarrasR^ system has not been studied yet, but his system is the only mark based one for
which a type-checking algorithm has been developed.

Other type-based approaches to termination analysis
Xi (2001) proposes a system of restricted dependent types, built upon DML (Xi and
Pfenning 1999), to ensure program termination. In essence, his system is closely related to
ours since it uses stage information to ensure termination. However, XiR^s system differs
from ours in its expressiveness and complexity: while we focus on the weakest calculus that
uses type-based termination and extends other calculi based on a simple syntactic guard
predicate, Xi presents a very rich system with stage arithmetic, and a notion of metric
that is very useful for handling functions in several arguments. Of course, expressiveness is
achieved to the detriment of simplicity and XiR^s system is much more complex than ours.
Grobauer (2001) uses DML to S,nd cost recurrences for S,rst-order recursive deS,nitions:
a cost recurrence is an upper bound to the running time of the program with respect to
the size of its input, and hence a witness that the recursive deS,nition is terminating. In
his work, Grobauer exploits complex features of DML, including stage arithmetic, so his
techniques do not seem directly applicable to \Delta \Delta . Closely related is the recent work on
sized types (Hughes et al. 1996; Pareto 2000; Chin and Khoo 2001).

7. Conclusion
We have introduced \Delta \Delta  as a novel type system for terminating recursive functions. The
salient features of \Delta \Delta  are its type-based approach to ensure termination through the notion
of stage, and its support for stage polymorphism. The calculus is powerful enough to
encode many recursive deS,nitions rejected by existing type systems, scales up easily to
mutually inductive types and supports separate compilation. In comparison to \Delta G, it has
a much clearer syntax and admits a clean semantics; the strong normalisation can be
proved by means of a standard method. In practice, this means that \Delta \Delta  is less difficult to
implement (implementing the guard condition of \Delta G is error-prone) and the code written
in it is more easily maintainable. This makes \Delta \Delta  a good candidate base system for type
theory based proof-assistants such as Coq.

In order to validate this claim, the following steps need to be taken:

D^ Scale up \Delta \Delta  to dependent types and explicit polymorphism as in Barras (1999) and

Gimt^enez (1998).
D^ Develop type checking and type inference algorithms for \Delta \Delta . For the purpose of proof

assistants, it may be of interest to study a calculus where type annotations are given
and stage annotations are inferred.
D^ Provide mechanisms to support mutually inductive datatypes, mutually recursive

deS,nitions and recursive functions in several parameters. For the latter, some form of
stage arithmetic might be needed.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 139
For a different line of work, it may be of interest to give a precise characterisation of the
functions from \Delta  to \Delta  that are representable in \Delta \Delta .

Acknowledgments
We are grateful to our anonymous referees for the very constructive feedback we received
and to Roberto Amadio for making Bac (1998) available to us.

The work by Gilles Barthe, Maria Jo~ao Frade, Lut^Z^s Pinto, and Tarmo Uustalu was
partially supported by the Portuguese Foundation for Science and Technology under grant
number PRAXIS XXI/C/EEI/14172/98, by the INRIA-ICCTI collaboration and by the
FP5 IST project TYPES. Lut^Z^s Pinto was partially supported by Centro de Matem t^atica da
Universidade do Minho. Tarmo Uustalu also received support from the Estonian Science
Foundation under grant number 4155.

References
Abel, A. (2000) SpeciS,cation and veriS,cation of a formal system for structurally recursive functions.

In: Coquand, T., Dybjer, P., Nordstrl'om, B. and Smith, J. (eds.) Proceedings of TYPESR^99.
Springer-Verlag Lecture Notes in Computer Science 1956 1E^20.
Abel, A. and Altenkirch, T. (2002) A predicative analysis of structural recursion. J. of Functional

Programming 12 (1) 1E^41.
Altenkirch, T. (1999) Logical relations and inductive/coinductive types. In: Gottlob, G., Grandjean,

E. and Seyr, K. (eds.) Proceedings of CSLR^98. Springer-Verlag Lecture Notes in Computer Science
1584 343E^354.
Amadio, R. M. and Coupet-Grimal, S. (1998) Analysis of a guard condition in type theory

(extended abstract). In: Nivat, M. (ed.) Proceedings of FoSSaCSR^98. Springer-Verlag Lecture
Notes in Computer Science 1378 48E^62.
Bac, A. (1998) Un algorithme dR^inft^erence de types pour les types coinductifs. Memoire de DEA,

t^Ecole Normale Supt^erieure de Lyon.

Barras, B. (1999) Auto-validation dR^un syst`eme de preuves avec familles inductives, Ph.D. thesis,

Universitt^e Paris 7.
Blanqui, F., Jouannaud, J.-P. and Okada, M. (2002) Inductive data type systems. Theoretical

Computer Science 272 (1-2) 41E^68.
Chin, W.-N. and Khoo, S.-C. (2001) Calculating sized types. Higher-Order and Symbolic Computation

14 (2-3) 261E^300.
Coquand, T. (1992) Pattern matching with dependent types. In: B. Nordstrl'om, K. Pettersson, and

G. Plotkin (eds.) Informal Proceedings of TYPESR^92, Dept. of Computing Science, Chalmers
Univ. of Technology and Gl'oteborg Univ. 71E^84. (Available at ftp://ftp.cs.chalmers.se/pub/csreports/baastad.92/proc.ps.Z.)
Coquand, T. (1994) InS,nite objects in type theory. In: Barendregt, H. and Nipkow, T. (eds.)

Proceedings of TYPESR^93. Springer-Verlag Lecture Notes in Computer Science 806 62E^78.
Coquand, T. and Paulin, C. (1990) Inductively deS,ned types (preliminary version). In: Martin-Ll'of,

P. and Mints, G. (eds.) Proceedings of COLOGR^88. Springer-Verlag Lecture Notes in Computer
Science 417 50E^66.
Cornes, C. (1997) Conception dR^un langage de haut niveau de representation de preuves: Rt^ecurrence

par S,ltrage de motifs; UniS,cation en prt^esence de types inductifs primitifs; Synth`ese de lemmes
dR^inversion, Ph.D. thesis, Universitt^e de Paris 7.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

G. Barthe, M. J. Frade, E. Gimt^enez, L. Pinto and T. Uustalu 140
Cousot, P. and Cousot, R. (1996) Abstract interpretation. ACM Computing Surveys 28 (2) 324E^328.
Dybjer, P. (1994) Inductive families. Formal Aspects of Computing 6 (4) 440E^465.
Elbers, H. (1998) Connecting formal and informal mathematics, Ph.D. thesis, Technische Universiteit

Eindhoven.
Geuvers, H. (1992) Inductive and coinductive types with iteration and recursion. In:

Nordstrl'om, B., Pettersson, K. and Plotkin, G. (eds.) Informal Proceedings of TYPESR^92, Dept. of
Computing Science, Chalmers Univ. of Technology and Gl'oteborg Univ. 193E^217. (Available at
ftp://ftp.cs.chalmers.se/pub/cs-reports/baastad.92/proc.ps.Z.)
Giesl, J., Walther, C. and Brauburger, J. (1998) Termination analysis for functional programs.

In: Bibel, W. and Schmitt, P. (eds.) Automated Deduction: A Basis for Applications, Vol. 3:
Applications. Applied Logic Series, Kluwer Academic Publishers 10 135E^164.
Gimt^enez, E. (1995) Codifying guarded deS,nitions with recursion schemes. In: Dybjer, P. and

Nordstrl'om, B. (eds.) Proceedings of TYPESR^94. Springer-Verlag Lecture Notes in Computer Science
996 39E^59.
Gimt^enez, E. (1996) A calculus of inS,nite constructions and its application to the veriS,cation of reactive

systems, Ph.D. thesis, Ecole Normale Supt^erieure de Lyon.
Gimt^enez, E. (1998) Structural recursive deS,nitions in Type Theory. In: Larsen, K. G., Skyum, S. and

Winskel, G. (eds.) Proceedings of ICALPR^98. Springer-Verlag Lecture Notes in Computer Science
1443 397E^408.
Grobauer, B. (2001) Cost recurrences for DML programs. In: Proceedings of ICFPR^01. SIGPLAN

Notices 36 (10) 253E^264.
Hofmann, M. and Streicher, T. (1994) The groupoid model refutes uniqueness of identity proofs.

In: Proceedings of LICSR^94, IEEE CS Press 208E^212.
Hughes, J., Pareto, L. and Sabry, A. (1996) Proving the correctness of reactive systems using sized

types. In: Proceedings of POPLR^96, ACM Press 410E^423.
Jouannaud, J. P. and Okada, M. (1997) Abstract data type systems. Theoretical Computer Science

173 (2) 349E^391.
Lee C.-S., Jones, N. D. and Ben-Amram, A. M. (2001) The size-change principle for program

termination. In: Proceedings of POPLR^01. SIGPLAN Notices 36 (3) 81E^92.
Leivant, D. (1983) Reasoning about functional programs and complexity classes associated with

type disciplines. In: Proceedings of FOCSR^83, IEEE Computer Society Press 460E^469.
Leivant, D. (1990) Contracting proofs to programs. In: Odifreddi, P. (ed.) Logic and Computer

Science. APIC Studies in Data Processing, Academic Press 31 279E^327.
Luo, Z. (1994) Computation and Reasoning: A Type Theory for Computer Science. Int. Series of

Monographs in Computer Science, Clarendon Press 11.
Manoury, P. and Simonot, M. (1994) Automatizing termination proofs of recursively deS,ned

functions. Theoretical Computer Science 135 (2) 319E^343.
Martin-Ll'of, P. (1971) Hauptsatz for the intuitionistic theory of iterated inductive deS,nitions. In:

Fenstad, J. E. (ed.) Proceedings of 2nd Scandinavian Logic Symp. Studies in Logic and the
Foundations of Mathematics, North-Holland 63 179E^216.
Matthes, R. (1998) Extensions of System F by Iteration and Primitive Recursion on Monotone Inductive

Types, Ph.D. thesis, Fachbereich Mathematik, Ludwig-Maximilians-Universitl'at Ml'unchen.
Matthes, R. (1999) Monotone S,xed-point types and strong normalization. In: Gottlob, G.,

Grandjean, E. and Seyr, K. (eds.) Proceedings of CSLR^98. Springer-Verlag Lecture Notes in
Computer Science 1584 298E^312.
Matthes, R. (2002) TarskiR^s S,xed-point theorem and lambda calculi with monotone inductive types.

Synthese 133 (1) 107E^129.

http://journals.cambridge.org Downloaded: 29 Jul 2009 IP address: 192.93.2.32

Type-based termination of recursive deS,nitions 141
McBride, C. (1999) Dependently Typed Functional Programs and Their Proofs, Ph.D. thesis,

Laboratory for Foundations of Computer Science, Dept. of Computer Science, Univ. of
Edinburgh.
Mendler, N. P. (1987) Recursive types and type constraints in second-order lambda-calculus. In:

Proceedings of LICSR^87, IEEE Computer Society Press 30E^36.
Mendler N. P. (1991) Inductive types and type constraints in the second-order lambda-calculus.

Annals of Pure and Applied Logic 51 (1-2) 159E^172.
Nordstrl'om, B., Petersson, K. and Smith, J. (1990) Programming in Martin-Ll'ofR^s Type Theory: An

Introduction. Int. Series of Monographs on Computer Science, Clarendon Press 7.
Pareto, L. (2000) Types for crash prevention, Ph.D. thesis, Chalmers Univ. of Techn., Gl'oteborg.
Paulin-Mohring, C. (1993) Inductive deS,nitions in the system Coq: Rules and properties. In: Bezem,

M. and Groote, J. F. (eds.) Proceedings of TLCAR^93. Springer-Verlag Lecture Notes in Computer
Science 664 328E^345.
Pfenning, F. and Paulin-Mohring, C. (1990) Inductively deS,ned types in the calculus of constructions.

In: Main, M., Melton, A., Mislove, M. and Schmidt, D. (eds.) Proceedings of MFPSR^89. SpringerVerlag Lecture Notes in Computer Science 442 209E^228.
Pierce, B., Dietzen, S. and Michaylov, S. (1989) Programming in higher-order typed lambda-calculi.

Technical Report CMU-CS-89-111, School of Computer Science, Carnegie-Mellon Univ.
Sp\Pi lawski, Z. and Urzyczyn, P. (1999) Type S,xpoints: Iteration vs. recursion. In: Proceedings of

ICFPR^99. SIGPLAN Notices 34 (9) 102E^113.
Telford, A. and Turner, D. (1997) Ensuring streams T^ow. In: Johnson, M. (ed.) Proceedings of

AMASTR^97. Springer-Verlag Lecture Notes in Computer Science 1349 509E^523.
Uustalu, T. (1998) Natural Deduction for Intuitionistic Least and Greatest Fixedpoint Logics, with an

Application to Program Construction, Ph.D. thesis (Dissertation TRITA-IT AVH 98:03), Dept. of
Teleinformatics, Royal Inst. of Technology, Stockholm.
Uustalu, T. and Vene, V. (1997) A cube of proof systems for the intuitionistic predicate t,, j-logic.

In: Haveraaen, M. and Owe, O. (eds.) Proceedings of NWPTR^96. Research Report 248, Dept. of
Informatics, University of Oslo 237E^246.
Uustalu, T. and Vene, V. (2002) Least and greatest S,xedpoints in intuitionistic natural deduction.

Theoretical Computer Science 272 (1-2) 315E^339.
Xi, H. and Pfenning, F. (1998) Eliminating array bound checking through dependent types. In:

Proceedings of PLDIR^98. SIGPLAN Notices 33 (5) 249E^257.
Xi, H. and Pfenning, F. (1999) Dependent types in practical programming. In: Proceedings of

POPLR^99, ACM Press 214E^227.
Xi, H. (2001) Dependent types for program termination veriS,cation. In: Proceedings of LICSR^01,

IEEE CS Press 231E^242.