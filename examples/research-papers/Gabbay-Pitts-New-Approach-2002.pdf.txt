

Formal Aspects of Computing (2002) 13: 341-363

cfl 2002 BCS

A New Approach to Abstract Syntax
with Variable Binding1
Murdoch J. Gabbay and Andrew M. Pitts
Cambridge University Computer Laboratory, Cambridge, UK

Keywords: Abstract syntax; Alpha-conversion; Permutation actions; Set theory; Structural induction

Abstract. The permutation model of set theory with atoms (FM-sets), devised by Fraenkel and Mostowskiin the 1930s, supports notions of `name-abstraction' and `fresh name' that provide a new way to represent,
compute with, and reason about the syntax of formal systems involving variable-binding operations. In-ductively defined FM-sets involving the name-abstraction set former (together with Cartesian product and
disjoint union) can correctly encode syntax modulo renaming of bound variables. In this way, the standardtheory of algebraic data types can be extended to encompass signatures involving binding operators. In particular, there is an associated notion of structural recursion for defining syntax-manipulating functions (suchas capture avoiding substitution, set of free variables, etc.) and a notion of proof by structural induction,
both of which remain pleasingly close to informal practice in computer science.

1. Introduction
This paper presents a simple variant of classical set theory that turns out to be very convenient for developingthe metamathematics of formal systems involving variable-binding operations. The main message we wish to
get across is that a relatively small change to classical set theory, involving the use of atoms (or urelements,as they are often referred to), can reap great benefits for this aspect of metamathematics. In particular we
will see that in such a set theory it is possible to represent ff-equivalence classes of abstract syntax trees asthe elements of an inductively defined set, rather than just the quotient of such a set. Moreover, this can be
done in such a way that the techniques of structural induction and recursion, which Burstall did so muchto promote in computer science [Bur69, Bur77], extend in a pleasant fashion from conventional algebraic
datatypes to ones involving variable-binding operations.But of course using a different set theory, even though it is very close to the usual one, is not a step
to be undertaken lightly; so we begin with a critique of the current state of the art. It is oriented towards

Correspondence and offprint requests to: Andrew M. Pitts, Cambridge University Computer Laboratory, J. J. Thompson
Avenue, Cambridge CB3 0FD, UK. e-mail: Andrew.Pitts@cl.cam.ac.uk
1 This paper is dedicated to Rod Burstall. It is a revised and expanded version of Gabbay and Pitts [GaP99].

342 M. J. Gabbay and A. M. Pitts
the particular use of such a metatheory of variable binding that most concerns us, namely machine-assistedproofs about the structural operational semantics [Plo81] of programming languages.

1.1. Background
The theory and practice of specifying and reasoning about syntactical structures that do not involve variable-binding constructs is well understood. The theory involves such indispensable concepts as algebraic data
types [GTWW77], inductively defined sets, definition by structural recursion and proof by structural induc-tion [Bur69]; the practice can be seen in several general-purpose systems for machine-assisted proof (such
as [GoM93, PaM93]). This algebraic, `no binders' machinery is often applied to syntax that does involvebinders; but in that case it yields overly-concrete representations in which large numbers of essentially routine constructions and proofs to do with renaming bound variables, capture avoiding substitution, and so on,must be done and redone for each object-language on a case-by-case basis. To make large, machine-checkable
proofs feasible, one has to take a more sophisticated approach.One such approach involves representing object-level variables by variables in a metalanguage based
on typed *-calculus. This shifts renaming and substitution to the meta-level where their properties areestablished once and for all. This is the `higher order abstract syntax' (HOAS) approach [PfE88] -- an idea
going back to Church [Chu40] and Martin-L"of [Mar84] that has found its way into many of the current logicalframeworks and proof assistants. Its big drawback, in its original form at least, is that one loses the ability
to define functions on syntax by structural recursion and to prove properties by structural induction --absolutely essential tools, especially for applications to operational semantics. There are recent proposals to
overcome this shortcoming [McM97, DPS97]. They result in systems that are technically very interesting butforce the designer of algorithms and proofs `moduloff-conversion' to use forms of expression that are ratherfar from familiar informal practice. Indeed, the whole HOAS approach by its very nature disallows a feature

that we regard of key practical importance: the ability to manipulate names of bound variables explicitly incomputation and proof.

2 The same criticism applies to approaches to variable binding based upon de Bruijn's

nameless terms [dB72] or categorical combinators [Cur93]: these are good for machine implementations, butnot, we would argue, for representations intended for machine-assisted human reasoning.

Instead of the HOAS approach of moving both ff-conversion and substitution to the meta-level, we willjust promote the former, leaving notions of substitution to be defined (by structural recursion) on a case-bycase basis by the user. This does not seem too bad a compromise, since we show that it permits both a nicecalculus of bound names and notions of structural recursion and structural induction for variable-binding
constructs. We present these in a theory with the expressive power of classical set theory (without the axiomof choice) and which remains close to informal practice in its forms of expression. This, and the focus on
ff-conversion rather than substitution as primitive, makes our work close in spirit to that of Gordon andMelham [GoM96], who axiomatise a type of untyped

*-terms modulo ff-conversion within Church's higher-order logic. However, we take a more foundational approach, in that the necessary properties of

ff-conversionbecome part of the underlying set theory
3 itself. This results in notions of structural recursion and induction

that seem rather simpler than those in [GoM96] (cf. Example 6.10 below).

1.2. Overview of the paper
The Fraenkel-Mostowski permutation model of set theory was devised in order to prove the independence ofthe Axiom of Choice (AC) from the other axioms of Zermelo-Fraenkel set theory with atoms (ZFA) (and some
decades later Cohen proved the harder result of independence of AC from set theory without atoms (ZF),via his celebrated forcing method; see [Jec77, Section 6] for a brief survey of these matters). Our application
of the permutation model of set theory to abstract syntax with variable binding is rather far from this
2 Of course, one can introduce a type of `names' in a HOAS-style signature, as is done for example in [HMS98]; but as the
authors of that work say (p. 26): `The main drawback of HOAS is the difficulty of dealing with metatheoretic issues concerning
names. . . . As a consequence, some metatheoretic properties involving substitution and freshness of names. . . cannot be proved
inside the framework and instead have to be postulated.' It is precisely such problems with names that we claim our approach
overcomes in a simple way.
3 Instead of using set theory, one can use a higher-order logic based on Church's simple theory of types [Chu40] as the basis of

the approach described here, but we have yet to develop this formulation.

A New Approach to Abstract Syntax with Variable Binding 343
original purpose! To motivate its use, in Section 2 we consider a paradigmatic example of syntax involvingvariable binding, the lambda calculus, and show that

ff-conversion of *-terms can be expressed in terms ofthe primitive operation of permuting a term's variables, be they free, bound or binding (Proposition 2.2).

This motivates the use of sets equipped with permutation actions as a general setting for discussing syntax:the basic notions, including the key notion of `finite support', are reviewed in Section 3; and the FraenkelMostowski cumulative hierarchy of sets with finite support is recalled in Section 4. That section introducesFM-set theory, an axiomatisation of the Fraenkel-Mostowski permutation model whose special features,
compared with the usual Zermelo-Fraenkel set theory, are expressed in terms of a set of atoms, a `freshness'predicate

a # x (meaning `atom a is not in the (finite) support of object x') and a quantifier Na 2 A OE(meaning `for all but finitely many atoms

a, OE holds'). As far as we know, the N-quantifier is novel; ithas a dual `some/any' character (see Lemma 4.10), which gives it very pleasant logical properties that we

exploit throughout the rest of the paper. Our main contribution occurs in Section 5, where we define anew notion of `atom-abstraction' within FM-set theory. Then in Section 6 we show that atom-abstraction
can be used in combination with Cartesian product and disjoint union to form inductively defined sets inthe Fraenkel-Mostowski permutation model that represent syntax modulo

ff-conversion (Theorem 6.2). Thestandard theory of algebraic data types extends to encompass signatures involving binding operators. In

particular, there are notions of structural recursion (Corollary 6.7) and induction (Theorem 6.8) for theseinductively defined FM-sets that respect indistinguishability of

ff-variants and yet are pleasingly close toinformal practice when manipulating
ff-equivalence classes via representatives with explicitly named boundvariables. Section 7 discusses related work; and in Section 8, we conclude by mentioning some ways in which

the theory presented here is being developed and applied.

2. Permutative Renaming
As a motivating example, consider the terms M of the untyped lambda calculus [Bar84]:

M ::= a | M M | *a.M (1)
where a ranges over some countably infinite set A of names of variables.
Definition 2.1. The countably infinite set A will be fixed throughout this paper. We call its elements atoms.

Given a, a0 2 A, consider the following three versions of the notion of variable-renaming for *-terms M :{
a0/a}M, the textual substitution of a0 for all free occurrences of a in M;
[a0/a]M, the capture-avoiding substitution of a0 for all free occurrences of a in M ;
(a0 a) * M, the transposition of all occurrences (be they free, bound, or binding) of a and a0 in M.

For example, when M is (*a0.a a0)(*a.a), then{

a0/a}M = (*a0.a0a0)(*a.a),
[a0/a]M = (*a00.a0a00)(*a.a) (a00 fresh),
(a0 a) * M = (*a.a0a)(*a0.a0).

We assume the reader is familiar with the first two notions of renaming (if not, see [Bar84], for example).Although the third version is possibly less familiar, it is in fact more basic than the other two, because:

firstly, one does not need to know whether any of the operations in the underlying signature for *-termsare supposed to be variable-binders in order to define it; secondly, it can nevertheless be used to define
ff-conversion, as the following result shows (cf. [Gun92, p. 36], which uses {a0/a}(-) in place of (a0 a) * (-)for the same purpose). Recall that

ff-conversion, =ff, is usually defined as the least congruence on the set of
*-terms that identifies *a.M with *a0.[a0/a]M .

Proposition 2.2. The relation of ff-conversion between *-terms, =ff, coincides with the binary relation ,inductively generated by the following axioms and rules.

a 2 Aa , a M1 , M 01 M2 , M 02

M1 M2 , M01 M02

(a00 a) * M , (a00 a0) * M 0 a00 6= a, a0

a00 does not occur in M, M0

*a.M , *a0.M 0

344 M. J. Gabbay and A. M. Pitts
Proof. It is not hard to see that (a0 a) * (-) preserves =ff and hence that =ff is closed under the axioms andrules defining ,. Therefore , is contained in =

ff. The converse follows by proving that , is a congruencerelating *a.M and *a0.[a0/a]M : this follows from the easily verified facts that (a0 a) * (-) preserves ,, and

that if a0 does not occur in M, then (a0 a) * M , [a0/a]M .
This proposition shows that matters to do with variable binding can be phrased in terms of the elementaryoperation of variable-transposition, (

a0 a) * (-), rather than the more complicated operation of variable-substitution, be it textual or capture-avoiding. Both are more complicated than transposition because they

depend on the auxiliary definition of what are the free variables of a term. Note that transposition is aninstance of the more general operation of permuting the atoms in

M according to a bijection ss : A ,= A,the result of which we write as
ss * M. This `permutation action' permits one to formalise an importantabstractness property of metatheoretic assertions involving the notion of `variable', namely that the validity

of assertions about syntactical objects should be sensitive only to distinctions between variable names, ratherthan to the particular names themselves. Put more formally, this is the equivariance property of an assertion
OE(M ) about terms M :8

ss, M (OE(M ) , OE(ss * M)) (2)
the validity of which of course depends upon the nature of the assertion OE(M) (in particular one would expect
M to be the only free metavariable in OE for (2) to be valid; cf. Lemma 4.7). Such notions belong to the richmathematical theory of sets equipped with a permutation action, which we recall next. It is worth noting

that much of that theory would be inapplicable were one to try to base the development upon arbitrary (oreven injective) renaming functions from atoms to atoms, rather than upon permutations.

3. Permutation Actions and Finite Support
Let perm(A) denote the group of all permutations of A. Thus the elements ss of perm(A) are bijections fromA to itself. The group multiplication takes two such bijections

ss and ss0 and composes them -- we writethe composition of
ss followed by ss0 as ss0 ffi ss. The group identity is the identity function on A, denoted byid

A. As one may gather from the discussion above, we will be particularly concerned with the elements ofperm(A) that are transpositions: given a, b 2 A, we write (a b) for the permutation that interchanges a and

b, leaving all other atoms fixed:

(a b)(c) , 8!:

a if c = b
b if c = a
c otherwise

(3)

Definition 3.1. A perm(A)-set consists of a set X equipped with an action of the group perm(A): this isa function (-) *

X (-) mapping pairs (ss, x) 2 perm(A) * X to elements ss *X x of X and satisfying

ss0 *X (ss *X x) = (ss0 ffi ss) *X x and id A *X x = x

for all ss, ss0 2 perm(A) and x 2 X.

We will usually refer to a perm(A)-set via its underlying set when the associated action is clear from thecontext.

Example 3.2. Of the many examples of sets equipped with an action of the group perm(A), we mentionsome that will be relevant here.

(i) The set A itself has a perm(A)-action given by applying the permutation, qua function, to atoms:

ss *A a , ss(a).
(ii) The set \Lambda  of *-terms M, defined as in equation (1), possesses a perm(A)-action defined by inductionon the structure of

M by:8!:

ss *\Lambda  a , ss *A a
ss *\Lambda  (M M 0) , (ss *\Lambda  M )(ss *\Lambda  M 0)
ss *\Lambda  (*a.M ) , *(ss *A a).(ss *\Lambda  M)

A New Approach to Abstract Syntax with Variable Binding 345
(iii) Note that if two *-terms are ff-equivalent, M =ff M 0, then for any permutation ss one also has ss *\Lambda  M =ff

ss *\Lambda  M 0. It follows that (-) *\Lambda  (-) induces an action on the quotient set \Lambda /=ff:

ss *(\Lambda /=ff) [M ]ff , [ss *\Lambda  M]ff
(where we write [M ]ff for the ff-equivalence class of the *-term M).
(iv) If X is a perm(A)-set, with action (-) *X (-), then we can endow its powerset pow (X) = {S | S ` X}with a perm(A)-action by defining:

ss *pow(X) S , {ss *X x | x 2 S}
(v) If X and Y are perm(A)-sets, then we can endow the disjoint union X + Y = {(0, x) | x 2 X} [ {(1, y) |

y 2 Y } with a perm(A)-action by defining:

ss *(X+Y ) z , ae(0, ss *X x) if z = (0, x)(1, ss *

Y y) if z = (1, y)

(vi) The unique function A * ; ! ; is a perm(A)-action on the emptyset ;.
(vii) We say that X is a sub-perm(A)-set of Y if X ` Y and ss *Y (-) restricts to a function X ! X, forany

ss 2 perm(A). In that case X with the restricted action is itself a perm(A)-set. If X is a set ofperm(A)-sets that is linearly ordered by this relation, then the union S X = {

x | 9X 2 X (x 2 X)} hasa perm(A)-action given by the actions on each
X 2 X (which agree where they overlap):

ss *(S X ) x = ss *X x if x 2 X 2 X
In general, an action of perm(A) on a set X gives us an abstract way of regarding the elements x of X assomehow `involving atoms from A in their construction', in as much as the action tells us how permuting

atoms changes x -- which turns out to be all we need for an abstract theory of variable renaming andbinding. An important part of this theory is the notion of finite support. This generalises the property of an
abstract syntax tree that it only involves finitely many atoms in its construction to the abstract level of anelement of any set equipped with a perm(A)-action.

Definition 3.3 (Finite support). Given a perm(A)-set X and an element x 2 X, a set of atoms w ` Ais said to support

x if all permutations ss 2 perm(A) that fix every element of w also fix x:8

a 2 w(ss(a) = a) ) ss *X x = x (4)
We say that x is finitely supported (in X) if there is some finite subset w ` A supporting it. The perm(A)-set
X has the finite support property if all its elements are finitely supported.

Proposition 3.4 (The support of an object). If an element x of a perm(A)-set X is finitely supported,then there is a least finite subset of A supporting

x. We write supp(x) for this (necessarily unique) finite setof atoms and call it the support of
x (leaving implicit which perm(A)-set X is being referred to).

Proof. We give a proof that emphasises the role of transpositions (see equation (3)) and the predicate `a isnot in the support of

x', which play crucial roles in the theory we develop in this paper. Indeed, one can givean explicit formula for supp(

x) in terms of the action of transpositions on x:

supp(x) , {a 2 A | {b 2 A | (a b) *X x 6= x} is not finite} (5)
Thus for any a 2 A, a /2 supp(x) holds if and only if (a b) *X x = x holds for all but finitely many b 2 A.(Cf. the definition of the

N-quantifier given below in Definition 4.4.) We show that this definition of supp(x)has the following three properties:

(i) If w is a finite set of atoms supporting x, then supp(x) ` w.
(ii) If a, b 2 A - supp(x), then (a b) *X x = x.
(iii) If w is a finite set of atoms supporting x, then so is w - {a}, for any a 2 w - supp(x).

So if x is finitely supported, (i) together with finitely many applications of (iii) allows us to deduce thatsupp(

x) is indeed a finite set supporting x and is the least such. We need (ii) in order to prove (iii).Property (i) follows almost immediately from the definition of supp(

x) in equation (5). For suppose wis a finite set of atoms supporting
x. If a, b /2 w, then 8c 2 w . (a b)(c) = c, so since w supports x, we have

346 M. J. Gabbay and A. M. Pitts
(a b) *X x = x. Therefore a /2 w implies {b 2 A | (a b) *X x 6= x} is contained in w and hence is finite, so that
a /2 supp(x). Thus a 2 supp(x) implies a 2 w, as required.To prove property (ii), clearly it suffices to consider the case when

a 6= b. So suppose a and b are distinctatoms not belonging to supp(
x). By definition of supp(x), the set of atoms {c 2 A | (a c) *X x 6= x} [ {c 2A | (
b c) *X x 6= x} [ {a, b} is finite; so we can find an atom c not in this set, i.e. such that c 6= a, b and

(a c) *X x = x = (b c) *X x (6)
Since a, b, c are all distinct, the permutations (a b) and (a c)ffi(b c)ffi(a c) are equal. Therefore from equation (6)we have

(a b) *X x = ((a c) ffi (b c) ffi (a c)) *X x = (a c) *X ((b c) *X ((a c) *X x)) = x
as required.Finally, to prove property (iii), suppose

w is a finite set of atoms supporting x, that a 2 w - supp(x),and that
ss 2 perm(A) satisfies 8b 2 w - {a}(ss(b) = b). We have to prove that ss *X x = x. We may assume
ss(a) 6= a, for otherwise ss fixes every element of w and hence ss *X x = x, because x is supported by w. Butthen we also have

ss-1(a) /2 w - {a}, since otherwise ss-1(a), being an element of w - {a}, would be fixedby
ss, so that a = ss(ss-1(a)) = ss-1(a), and hence ss(a) = a, contrary to assumption. By property (i) andassumption on

a, we have supp(x) ` w - {a} and hence a, ss-1(a) /2 supp(x). Therefore by property (ii),(
ss-1(a) a) *X x = x. So

ss *X x = ss *X ((ss-1(a) a) *X x) = (ss ffi (ss-1(a) a)) *X x (7)
But the permutation ss ffi (ss-1(a) a) clearly fixes a; and it fixes every element of w - {a} because (ss-1(a) a)and

ss do so. So ss ffi (ss-1(a) a) fixes all of w and therefore, since w supports x, we have

(ss ffi (ss-1(a) a)) *X x = x (8)
Combining equations (7) and (8) yields ss *X x = x, as required.
Example 3.5. Consider the perm(A)-sets in Example 3.2.

(i) A has the finite support property, with supp(a) = {a} for each a 2 A.
(ii) \Lambda  has the finite support property: the support of a *-term M turns out to be the finite set of atomsoccurring in it, whether as free, bound, or binding occurrences.

(iii) The quotient set \Lambda /=ff also has the finite support property, with the support of an ff-equivalence classof

*-terms being the finite set of atoms occurring freely in any representative of the class (it does notmatter which).

(iv) A powerset pow (X) does not necessarily have the finite support property even if X does. For example,the only elements of finite support in pow (A) are the subsets

S ` A that are either finite or cofinite(i.e. whose relative complement A -
S is finite). However, note that given any perm(A)-set X, if S 2pow (
X) is supported by a finite set of atoms w, then ss *pow(X) S is supported by the finite set ss *pow(A) w,for any

ss 2 perm(A). Therefore the perm(A)-action on pow (X) restricts to one on the subset

powfs(X) , {S ` X | S is finitely supported in pow (X)}
and pow fs(X) has the finite support property (whether or not X does).
(v) If X and Y have the finite support property, then so does their disjoint union X + Y : each z 2 X + Yis either of the form (0

, x) and supported by the finite set of atoms supporting x in X, or is of the form(1
, y) and supported by the finite set of atoms supporting y in Y .

(vi) The empty set has the finite support property, for rather trivial reasons.
(vii) If each element of a linearly ordered set X of perm(A)-sets has the finite support property, then so doesits union: each

x 2 S X is supported by the finite set of atoms that supports it in any X 2 X containing
x.

4. FM-Set Theory
The perm(A)-sets with the finite support property are the objects of a category whose morphisms f : X -! Yare the so-called equivariant functions -- those functions satisfying

f (ss *X x) = ss *Y f (x) for all ss 2 perm(A)

A New Approach to Abstract Syntax with Variable Binding 347
and x 2 X. At this point we could develop our theory of name-abstraction in terms of constructions withinthis category: see [PiG00, Appendix]. Instead, here we take a set-theoretic approach and construct a single,
`large' perm(A)-set FM(A) with the finite support property, in which our theory can be expressed usingfamiliar, set-theoretic language. One benefit is that if a particular construction can be expressed in this
language, then the action of permutations is inherited from the ambient universe FM(A) without having todefine it explicitly and without having to prove the associated finite support property. (Compare this with
the approach to denotational metalanguages initiated by Scott [Sco93] in which questions of domain-theoreticcontinuity are made implicit.)

Recall the usual von Neumann cumulative hierarchy of sets [Sho77]:8!

:

V0 , ;V

ff+1 , pow(Vff)V
* , Sff6* Vff (* a limit ordinal)

(9)

More generally, given a set A we can define a cumulative hierarchy of `sets involving atoms from A':8!

:

V0(A) , ;V

ff+1(A) , A + pow (Vff(A))V
*(A) , Sff6* Vff(A) (* a limit ordinal)

(10)

where + denotes disjoint union of sets and pow (-) the powerset operation (see (v) and (iv) in Example 3.2).We can build the notions of `permutation action' and `finite support property' into such a set-theoretic
hierarchy by taking A to be the perm(A)-set A of atoms and replacing pow (-) by the pow fs(-) operationfrom Example 3.5(iv):8!

:

FM0(A) , ;FM

ff+1(A) , A + pow fs(FMff(A))FM
*(A) , Sff6* FMff(A) (* a limit ordinal)

(11)

Because of the properties noted in Example 3.5, each FMff(A) is a perm(A)-set with the finite supportproperty and FM

ff(A) is a sub-perm(A)-set of FMfi(A) when ff 6 fi -- enabling us to use the unionoperation at limit ordinals as in Example 3.5(vii). More generally, when we consider the union of all the

FMff(A) we get one large perm(A)-set (i.e. a perm(A)-class) in which every element has finite support.

Definition 4.1 (FM-sets). The union of all FMff(A) (as ff ranges over the ordinals) is called the Fraenkel-Mostowski universe (over the set of atoms A) and is denoted FM(A). Using the suggestive names atm and set
for the functions x 7! (0, x) and x 7! (1, x) giving the two inclusions into a disjoint union, from definition (11)we have that every element

x of FM(A) is either of the form atm(a) with a 2 A, or of the form set(X) where
X is a finitely supported set of FM-sets formed at an earlier ordinal stage than x (cf. Example 3.5(iv)). We callelements of the form set(

X) FM-sets and elements of the form atm(a) atoms (a slight abuse of terminology).We will just write (-) * (-) for the perm(A)-action on the Fraenkel-Mostowski universe; it satisfies

ss * atm(a) = atm(ss(a)), ss * set(X) = set({ss * x | x 2 X}) (12)
Remark 4.2 (Pure FM-sets). Given an element x of the Fraenkel-Mostowski universe FM(A), let TC (x)denote the transitive closure of

x under the appropriate membership relation, namely 2FM(A) = {(x, y) |9

Y (x 2 Y ^ set(Y ) = y}. Note that FM(A) contains a copy of the von Neumann universe V, consisting ofthose FM-sets

x for which TC (x) is disjoint from {atm(a) | a 2 A}. We call such an x a pure FM-set.

The usual set-theoretic constructions can be carried out within FM(A) to build various sets. In particularwe will make use of the set

! of natural numbers, and the usual constructions of ordered pairs, Cartesianproducts, disjoint unions, power- and function-sets. To be more precise and to develop the properties of the

Fraenkel-Mostowski universe further, we introduce a suitable theory of atoms and FM-sets within classicalfirst-order logic with equality. This theory is based upon ZFA -- Zermelo-Fraenkel set theory with Atoms
(see for example [Fou80], or [JoM95, $5]). This has a signature containing not only a binary relation symbol

348 M. J. Gabbay and A. M. Pitts
`2' for membership, but also a constant A for the set of atoms, A. The axioms of ZFA are as follows:

(Sets) x 2 y ) y /2 A
(Extensionality) x /2 A ^ y /2 A ^ 8z(z 2 x , z 2 y) ) x = y
(Separation) 9y /2 A 8z(z 2 y , (z 2 x ^ OE)), y not free in OE
(2-Induction) 8x(8y 2 x [y/x]OE ) OE) ) 8x OE
(Collection) 8y 2 x 9w OE ) 9z 8y 2 x 9w 2 z OE
(Pairing) 9z(x 2 z ^ y 2 z)
(Union) 9y 8z(z 2 y , 9w 2 x(z 2 w))
(Powerset) 9y 8z(z 2 y , 8w 2 z(w 2 x))
(Infinity) 9x(9y(y 2 x) ^ 8y 2 x 9w 2 x(y 2 w)).

Remark 4.3 (Atoms). Axiom (Sets) expresses the fact that only non-atoms can have elements (`atomsare empty'); the other axioms are like those of the usual Zermelo-Fraenkel set theory, except that certain

quantifications Qx . (-) (for Q = 8, 9) have to be restricted to Qx /2 A . (-) when x must range just oversets rather than over sets and atoms. This difference is mathematically innocuous, but makes it very hard
to re-use machine-checked versions of Zermelo-Fraenkel set theory to develop a theory of the Fraenkel-Mostowski universe within a proof assistant. The first author's implementation of such a theory within
the Isabelle generic theorem prover [Gab00, Chapter III] gets round this problem by working in a non-well-founded setting and replacing `empty atoms' by so-called Quine atoms [Qui63, Section 4] -- objects
satisfying a = {a} -- at the expense of having to alter the axiom of (2-Induction).
The above axioms capture the basic, set-theoretic properties of FM(A) without saying anything very specificabout properties of the set of atoms itself, or of the permutation action. The properties relevant to our

intended application depend upon the fact that A is (countably) infinite and that every element of FM(A)is finitely supported in the sense of Definition 3.3. We can capture these two properties with the following
axioms, which use notation introduced in Definition 4.4:

(A-Not-Finite) A /2 powfin(A)
(Fresh) 9a 2 A(a # x)

Definition 4.4. Here and elsewhere we will freely augment the rather sparse language of ZFA with exten-sions involving new function and relation symbols (written in

this font) uniquely defined by formulas of ZFA.In particular we make the following definitions.

Finite subsets. Define powfin(x) to be a term denoting the set of finite subsets of x. One practically usefulway of formulating this is to define

powfin(x) to be the least set of subsets of x containing the empty set; and closed under the operations of adding an element of

x, s 7! s [ {y}, for each y 2 x.

Cofinite subsets. Define powcof(x) to be a term denoting the set of cofinite subsets of x, i.e. those s ` xsuch that the relative complement

x - s is in powfin(x).

Permutation action. Define perm(A) to be a term denoting the set of permutations of A. In view of (12),the action of such permutations

ss 2 perm(A) can be defined by 2-recursion as follows:

ss * x = aess(x) if x 2 A{ss * y | y 2 x} if x /2 A
In particular, define (a b) * x to be a term denoting the result of interchanging a, b 2 A in x.
N-quantifier. For each formula OE of the language of ZFA, define Na 2 A OE (`for all but finitely many atoms

a, OE') to be the formula 9s 2 powcof (A) 8a(a 2 s , OE) expressing that {a 2 A | OE} is a cofinite set ofatoms.

Freshness relation. Define the formula a # x (`atom a is fresh with respect to x') as follows:

a # x 4, Nb 2 A((a b) * x = x) (13)
That this is a reasonable definition of `freshness' may not be immediately apparent; however, the followingproposition shows (amongst other things) that

a # x holds if and only if a is not in the support of x, asdefined in Proposition 3.4.

A New Approach to Abstract Syntax with Variable Binding 349
Proposition 4.5. The axioms of FM-set theory are by definition the axioms of ZFA plus the two axioms(

A-Not-Finite) and (Fresh). Modulo the other axioms, axiom (Fresh) is equivalent to asserting that every xhas the finite support property of Definition 3.3, suitably formulated in the language of ZFA:

8x 9a 2 A(a # x) , 8x 9w 2 powfin(A) 8ss 2 perm(A) (8a 2 w(ss(a) = a)) ) ss * x = x (14)
In particular the Fraenkel-Mostowski universe FM(A) over an infinite set A (Definition 4.1) satisfies theseaxioms if we interpret the membership relation `2' by the binary relation {(

x, y) 2 FM(A) * FM(A) |9
Y (x 2 Y ^ set(Y ) = y} and the constant A by the element set({atm(a) | a 2 A}) 2 FM(A).

Proof. To prove (14), first note that for any x, if a, b, c are distinct atoms satisfying (a c) * x = x = (b c) * x,then (

a b) * x = x (see the proof of property (ii) in the proof of Proposition 3.4). From this we can deducethe following two useful facts:

a # x ^ b # x ) (a b) * x = x (15)
9a 2 A(a # x) , Na 2 A(a # x) (16)
Note also that if we define supp(x) as in equation (5), then by definition of # we have

a # x , a /2 supp(x) (17)
So if the right-hand side of (14) holds, then for each x, the proof of Proposition 3.4 yields that supp(x) 2
powfin(A); and hence from (A-Not-Finite) supp(x) 6= A, so that by (16) again, 9a 2 A(a # x).Conversely, if 8

x 9a 2 A(a # x), then for each x, supp(x) 2 powfin(A) by (16) and (17); and by (15)and (17), (
a b) * x = x for any a, b /2 supp(x). So any permutation ss 2 perm(A) that is finite (i.e. with{
a 2 A | ss(a) 6= a} 2 powfin(A)) and that fixes each element of supp(x) satisfies ss * x = x, because such apermutation is expressible as the composition of finitely many transpositions (

a b) with a, b /2 supp(x). Butaxiom (Fresh) implies that any
ss 2 perm(A) is finite: for if a # ss, it is not hard to see that ss(a) = a; so from(16) we have
ss(a) = a for cofinitely many atoms a, so that ss is finite. Thus if (Fresh) holds then for each
x, supp(x) defined as in (5) is a finite set of atoms supporting x. Thus we do indeed have the left-to-rightimplication in (14).

Remark 4.6 (Failure of the Axiom of Choice). In the literature, careful presentations of the definitionof capture-avoiding substitution quite often make use of a choice function for picking out fresh variables:
see [Sto88, Section 2], for example. The vague feeling that such concrete choices should be irrelevant crys-tallises here into the fact that such choice functions are inconsistent with FM-set theory, because its axioms
contradict the Axiom of Choice (AC). For example, the axiom (A-Not-Finite) implies that the set of cofinitesubsets of

A is a set of non-empty sets; but there can be no choice function for it -- a diagonalisation argu-ment (using the fact that the graph of any function from

powfin(A) to A must be finitely supported) showsthis. (Indeed it can be shown that the axiom of countable choice is inconsistent with FM-set theory.)

Mechanised proof assistants based on set theory, or on higher-order logic, often include Hilbert's choiceoperator,

"x . OE, to provide anonymous notations for terms defined by formulas (see [LaP99, Section 2.1]).Since the

"-operator can be used to prove AC, we cannot add it to FM-set theory without inconsistency.However, in a fully formal presentation of FM-set theory it would be both consistent and useful to augment

the language of FM-set theory with a notation and axioms for forming terms uniquely defined by a formula.As mentioned in Definition 4.4, here we proceed in a semi-formal fashion and just introduce new notation on
the fly, uniquely defined by formulas. Corollary 4.8 allows us to bound the support of terms involving suchnew notation by the support of the notation's parameters. It is a consequence of the following equivariance
property (cf. equation (2)), which is important in its own right.
Lemma 4.7 (Equivariance property of FM-set theory). Suppose OE(~x) is a formula of FM-set theory,with free variables contained in the list of distinct variables

~x. Then

8a, b 2 A 8~x (OE(~x) , OE((a b) * ~x)
is provable in FM-set theory (where OE((a b) * ~x) denotes the simultaneous (capture-avoiding) substitution of(

a b) * xi for all free occurrences of xi in OE, as xi ranges over ~x).

Proof. By induction on the structure of OE, using the following properties of the constant and relation symbols

350 M. J. Gabbay and A. M. Pitts
of the language:

x = y ) (a b) * x = (a b) * y (18)
x 2 y ) (a b) * x 2 (a b) * y (19)
(a b) * A = A (20)

Property (18) is a trivial consequence of the usual properties of equality; and properties (19) and (20) followfrom the definition of the permutation action in Definition 4.4.

Corollary 4.8 (Support of defined notation). Suppose OE(~x) and (~x, y) are formulas of FM-set theory,with free variables contained in the indicated lists of variables, and that

OE(~x) ) 9!y (~x, y) (21)
holds. If we define the term f(~x) to be the unique y such that (~x, y), so that OE(~x) ) 8y(y = f(~x) , (~x, y)),then

OE(~x) ) 8a 2 A(a # ~x ) a # f(~x)) (22)
(where a # ~x stands for a conjunction of freshness formulas, one for each variable in the list ~x). Hence
OE(~x) ) supp(f(~x)) ` supp(x1) [ * * * [ supp(xn), if ~x = x1, . . . xn.

Proof. Suppose OE(~x) and a # ~x hold. We have to prove a # y for the unique y such that (~x, y). By axiom(Fresh) we can find

b 2 A with b # ~x, y. Since b # y, by Lemma 4.7 we have a # (a b) * y. But (a b) * y = yby the uniqueness part of property (21): for not only does

(~x, y) hold (by definition of y), but so also does
(~x, (a b) * y) (since Lemma 4.7 applied to (~x, y) gives ((a b) * ~x, (a b) * y) and (a b) * ~x = ~x by property (15),because

a, b # ~x). So we do indeed have a # y.

Example 4.9 (Functions). As usual, an FM-set f is a (partial) function if it only contains ordered pairsand is single-valued, i.e. if

Fun(f ) holds, where

Fun(f ) 4, 8x 2 f 9y, z(x = (y, z))^ 8

y, z, z0((y, z) 2 f ^ (y, z0) 2 f ) z = z0)

Using (Collection) and (Separation), if Fun(f ) holds then the domain of definition of f is the uniquely definedFM-set

dom(f ) of first components of elements of f, i.e. dom(f) = {x | 9y((x, y) 2 f )}. Similarly the imageof
f is img(f) = {y | 9x((x, y) 2 f)}. If Fun(f ) and x 2 dom(f ), then there is a unique y such that (x, y) 2 fand in this case, as usual, we define the application notation

f(x) to stand for this y. From Corollary 4.8 wehave

Fun(f ) ) 8a 2 A(a # f ) a # dom(f) ^ a # img(f )) (23)
Fun(f ) ^ x 2 dom(f) ) 8a 2 A(a # f ^ a # x ) a # f(x)) (24)
While we are about it, let us mention another piece of notation associated with functions. If X and Y areFM-sets, then the function set

X ! Y is the FM-set defined by: f 2 (X ! Y ) , Fun(f ) ^ dom(f) =
X ^ img(f) ` Y .

In Definition 4.4 we introduced the notation Na 2 A OE to stand for a quantification over all but finitelymany atoms. However, the nature of the set of atoms in FM-set theory endows this quantifier with very

special properties, as Proposition 4.10 and Corollary 4.11 show.
Proposition 4.10 ( Nas a `freshness' quantifier). For any formula OE and list of distinct variables a, ~xin the language of FM-set theory, consider the following formulas:

8a 2 A (a # ~x ) OE) (25)

Na 2 A OE (26)9
a 2 A (a # ~x ^ OE) (27)

Then in FM-set theory, (25) ) (26) ) (27). If the free variables of OE are contained in the list a, ~x, then also(27) ) (25) and hence in this case the three formulas are provably equivalent.

A New Approach to Abstract Syntax with Variable Binding 351
Proof. Note that by axiom (Fresh) and (16) (and the fact that cofinite sets are closed under finite intersec-tion), we have {

a 2 A | a # ~x} 2 powcof (A). So if (25) holds, {a 2 A | OE} contains {a 2 A | a # ~x} and henceis cofinite, i.e. (26) holds. Similarly, if (26) holds then {

a 2 A | a # ~x} " {a 2 A | OE} is the intersection of twocofinite sets, hence is cofinite and hence by (
A-Not-Finite) is non-empty: so (27) holds.Now suppose the free variables of
OE are contained in {a, ~x} and that (27) holds. We use the equivarianceproperty of formulas of FM-set theory given in Lemma 4.7 to deduce from

a # ~x ^ OE that for any b 2 A

b # (a b) * ~x ^ OE(b, (a b) * ~x) (28)
where OE(b, (a b) * ~x) denotes the result of substituting b for all free occurrences of a and (a b) * xi for all freeoccurrences of

xi in OE, as xi ranges over ~x. So if b # ~x, since we also have a # ~x, from (15) we get (a b) * ~x = ~xand hence (28) implies

OE(b, ~x). So (27) does indeed imply (25).

Corollary 4.11. The quantifier Na 2 A . (-) commutes with the propositional connectives: for all formulas
OE and 

Na 2 A(OE * ) , ( Na 2 A OE) * ( Na 2 A ) where * is ^, ., ) or , (29)

Na 2 A(~OE) , ~( Na 2 A OE) (30)
Na 2 A true (31)
are all provable in FM-set theory. Moreover, if all the elements of an FM-set X have empty support (forexample, if

X is pure in the sense of Remark 4.2), then Na 2 A . (-) commutes with existential and universalquantification over elements of

X:

X /2 A ^ 8a 2 A 8x 2 X(a # x) )

( Na 2 A 9x 2 X OE , 9x 2 X Na 2 A OE) ^ ( Na 2 A 8x 2 X OE , 8x 2 X Na 2 A OE). (32)

Proof. These properties of the N-quantifier follow easily from its dual 8-9 nature established in Proposi-tion 4.10. (For property (32), we also need to note that if

X /2 A ^ 8a 2 A 8x 2 X(a # x) holds, then so does8
a 2 A(a # X).)

In view of Proposition 4.10, we are justified in reading Na 2 A . OE as `for some/any fresh atom a, it is thecase that

OE'. This dual 9-8 flavour of the N-quantifier seems to exactly fit many situations where a statementabout freshness of variables is required: we choose some fresh variable with a particular property, but later

on may need the fact that any such variable will do. For example, when reasoning about ff-conversion of
*-terms using the rules in Proposition 2.2 in a `top-down' fashion, we satisfy the side-condition in the thirdrule by picking some fresh

a00; and when using them in a `bottom-up' fashion, it is useful to know that anyfresh
a00 will do. We will see further examples of this phenomenon in subsequent sections, where we put the
N-quantifier to work.

5. Abstraction Sets
In Proposition 2.2 we saw that ff-conversion of *-terms can be formulated in terms of the operation oftransposing two variables in a term, together with the relation that a variable does not occur in a term. In
view of Example 3.5(ii), equation (17) and Proposition 4.10, we can re-express the rule for ff-conversion of
*-abstractions in Proposition 2.2 as

Na00((a00 a) * t , (a00 a0) * t0)

*a.t , *a0.t0
This suggests how to generalise the notion of ff-conversion from the syntax trees of *-terms to arbitraryobjects in the Fraenkel-Mostowski universe FM(A) introduced by Definition 4.1. Let ,

A be the binaryrelation on A * FM(A) defined by

(a, x) ,A (b, y) 4, a 2 A ^ b 2 A ^ Nc 2 A((c a) * x = (c b) * y) (33)
It is not hard to see that ,A is an equivalence relation. The following lemma shows that its equivalenceclasses are FM-sets.

352 M. J. Gabbay and A. M. Pitts
Lemma 5.1 (Atom-abstractions). FM-set theory satisfies

(a, x) ,A (b, y) , a 2 A ^ b 2 A ^ y = (b a) * x ^ (b = a . b # x) (34)
Hence by the axiom (Collection), for each a 2 A and x 2 FM(A) there is an FM-set

a.x , {(b, (b a) * x) | b 2 A ^ (b = a . b # x)} (35)
which is the ,A-equivalence class of the pair (a, x). We call a.x the atom-abstraction determined by a and
x.

Proof. We split the proof of (34) into two cases, according to whether b = a or not. In the first case, theresult follows from the easily verified implication

(a, x) ,A (a, y) ) x = y (36)
So suppose b 6= a. If (a, x) ,A (b, y), then there is some c 2 A with c # a, x, b, y and

(c a) * x = (c b) * y (37)
Since c # y, by the equivariance property (Lemma 4.7) we also have b = (c b) * c # (c b) * y and hence by (37),
b # (c a) * x. From this we get (c a) * b # (c a) * ((c a) * x) = x, i.e. b # x (since (c a) leaves b fixed). So for theleft-to-right implication in (34), it just remains to show that

y = (b a) * x. But

y = (c b) * ((c b) * y) = (c b) * ((c a) * x) by (37)

= (b a) * ((c b) * x) since (c b) ffi (c a) = (b a) ffi (c b)
= (b a) * x by (15) applied to c # x ^ b # x.

Conversely, if y = (b a) * x and b # x, then by axiom (Fresh) there is some c 2 A with c # a, x, b, y and

(c b) * y = (c b) * ((b a) * x) since y = (b a) * x

= (c a) * ((c b) * x) since (c b) ffi (b a) = (c a) ffi (c b)
= (c a) * x since c # x ^ b # x

Therefore Nc 2 A((c a) * x = (c b) * y), i.e. (a, x) ,A (b, y), as required.
Corollary 5.2. FM-set theory satisfies

a # a.x (38)
b 6= a ^ b # x ) b # a.x (39)
b 6= a ^ b # a.x ) b # x (40)

Hence 8b 2 A(b # a.x , (b = a . b # x)) and therefore supp(a.x) = supp(x) - {a}.
Proof. First note that as a consequence of the equivariance property of Lemma 4.7 one has

(c b) * (a.x) = ((c b)(a)).((c b) * x) (41)
So if b # a, x, then (b a) * (a.x) = b.((b a) * x) = a.x by (34); thus Nb 2 A((b a) * (a.x) = a.x) holds, whichis (38). Property (39) follows from property (22) and the easily verified fact that

b 6= a , b # a. Finallyfor (40), if
b 6= a and b # a.x, i.e. Nc 2 A((c b) * (a.x) = a.x), then by (41) we have Nc 2 A(a.((c b) * x) = a.x);hence by (36),

Nc 2 A((c b) * x = x), as required.

The definition of atom-abstraction embodies a form of `abstraction as information hiding', since a.x acts likea pair (

a, x) in which the name in the first component has been hidden, or made anonymous. However, atom-abstractions also embody a notion of `abstraction as function', since (36) shows that each atom-abstraction

a.x is a partial function; and by construction, the domain of definition of this partial function is a set ofatoms. In other words, using the notation of Example 4.9,

Fun(a.x) ^ dom(a.x) ` A holds. Indeed, by (35)and Corollary 5.2

dom(a.x) = {b 2 A | b = a . b # x} = A - supp(a.x) (42)
We will use the following special notation for the result of applying such a partial function to an atom in itsdomain of definition.

A New Approach to Abstract Syntax with Variable Binding 353
Definition 5.3 (Concretion of atom-abstractions). The result of applying an atom-abstraction y, re-garded as a partial function, to an atom

b 2 dom(y) = A - supp(y) will be called the concretion of yat
b and written y@b. From (35) we have that if y = a.x, then following form of fi-conversion holds foratom-abstraction/concretion:

8b 2 A((b = a . b # x) ) (a.x)@b = (b a) * x) (43)
Definition 5.4 (Abstraction sets). For each FM-set X, we can use the (Collection) axiom to deduce theexistence of an FM-set [

A]X of atom-abstractions of elements of X, defined by:

y 2 [A]X 4, 9a 2 A 9x 2 X(y = a.x ^ a # X) (44)
One might wonder why the condition `a # X' is included in the above definition. It is needed to ensure thatthe concretion of an element of [

A]X at a fresh atom lands us back in X:

8y 2 [A]X Nb 2 A(y@b 2 X) (45)
For note that because of the condition a # X in (44), plus the fact that a # y holds when y = a.x (byCorollary 5.2), from Proposition 4.10 we have

y 2 [A]X , Na 2 A 9x 2 X(y = a.x) (46)
Hence given y 2 [A]X and b # X, y, then y = a.x for some a 2 A and x 2 X with a # b, X. By (43),
y@b = (b a) * x; and since x 2 X, we have (b a) * x 2 (b a) * X. But (b a) * X = X, since a # X and b # X; andhence

y@b 2 X, as required for (45).

Proposition 5.5 (Extensionality for atom-abstractions). A form of j-conversion holds for atom-ab-straction/concretion, namely:

8y 2 [A]X Nb 2 A(b.(y@b) = y) (47)
and hence the following extensionality principle holds:

8y, y0 2 [A]X(y = y0 , Nb 2 A(y@b = y0@b)) (48)
Proof. Given y 2 [A]X and b # y, by (44) we can find a 2 A and x 2 X with y = a.x (and a # X). Then

b.(y@b) = b.((b a) * x) since y@b = (b a) * x by (43)

= a.x by (34)
= y

Thus (47) holds by Proposition 4.10.
Remark 5.6. The abstraction-set former [A](-) is remarkably well behaved. In particular it preserves Carte-sian products, disjoint unions and even function-sets, up to natural bijections:

[A](X * Y ) ,= ([A]X) * ([A]Y )
[A](X + Y ) ,= ([A]X) + ([A]Y )
[A](X ! Y ) ,= ([A]X) ! ([A]Y )

For proofs of these bijections, see [Gab00, Corollary 9.6.9].

6. Inductively Defined FM-Sets
We can use the [A](-) construct in combination with Cartesian product and disjoint union to form inductivelydefined FM-sets that allow us to view sets of syntax involving binders modulo

ff-conversion as algebraic datatypes in FM(A), generalising the `classical' theory for syntax without binders. To see this, we first need to

recall a little of the theory of inductively defined sets, within the context of FM-set theory.Suppose

F is a definable function from FM-sets to FM-sets. In other words, suppose that there is aformula
OE(X, Y ) of FM-set theory with the indicated free variables and satisfying 8X /2 A 9!Y /2 A OE(X, Y );

354 M. J. Gabbay and A. M. Pitts
and suppose that for each X, F (X) is the unique Y such that OE(X, Y ). Suppose further that the function Fis monotone for inclusions

X /2 A ^ Y /2 A ^ X ` Y ) F (X) ` F (Y ) (49)
and preserves unions of countable ascending chains8

n 2 !(X(n) /2 A ^ X(n) ` X(n + 1)) ) F (S{X(n) | n 2 !}) = S{F (X(n)) | n 2 !} (50)
(Just as we require F to be definable in FM-set theory, so we only consider countable chains of FM-sets(

X(n) | n 2 !) that are definable in FM-set theory; so in particular there is one finite set of atoms supportingevery

X(n), rather than one such set for each n 2 !.) Then F possesses a least (pre)fixed point, u(F ):

F (u(F )) = u(F ) (51)

F (X) ` X ) u(F ) ` X (52)
We call u(F ) the inductively defined FM-set determined by F . It can be constructed via the familiar Tarskiformula:

u(F ) , S{F n(;) | n 2 !} where aeF

0(;) , ;

F n+1(;) , F (F n(;)) (53)
The inductively defined FM-sets in which we are interested are all determined by functions F that are alsothe object part of functors preserving inclusions. In other words, not only is

F a definable monotone functionon FM-sets preserving definable countable chains, but also there is another definable function (traditionally

also denoted by F ) acting on functions between FM-sets:

f 2 (X ! Y ) ) F (f ) 2 (F (X) ! F (Y ))
that preserves composition:

f 2 (X ! Y ) ^ g 2 (Y ! Z) ) F (g ffi f) = F (g) ffi F (f )
and inclusion functions:

X ` Y ) F (iX,Y ) = iF (X),F (Y )
where iX,Y 2 (X ! Y ) is {(x, x) | x 2 X}. In this case u(F ) is the initial algebra for the functor F : for
every FM-set X and function f 2 F (X) ! X, there is a unique f 2 (u(F )) ! X such that

F (u(F ))
F (f)

u(F )

f
F (X) f X

(54)

commutes (i.e. f = f ffi F (f )). Indeed, paralleling the construction of u(F ) in (53), we have

f , S{fn 2 (F n(;) ! X) | n 2 !} where (f

0 , ;

f n+1 , f ffi F (fn) (55)
Lemma 6.1. The abstraction-set operation [A](-) of Definition 5.4 is monotone, preserves unions of defin-able countable ascending chains of FM-sets and is the object part of a functor preserving inclusions.

Proof. The fact that [A](-) preserves inclusions and unions of definable countable chains follows immediatelyfrom the characterisation of [

A]X in (46) together with the fact (Corollary 4.11) that Na 2 A(-) preservesimplications and commutes with 9

n 2 !(-) (because ! is pure). We extend it to a functor on FM-sets asfollows. Given
f 2 (X ! Y ), define

[A]f , {(u, v) 2 ([A]X) * ([A]Y ) | Na 2 A(f(u@a) = v@a)}
That this does give an element of ([A]X) ! ([A]Y ) and that f 7! [A]f preserves composition and inclusionfunctions all follow from the properties of atom-abstractions established in Section 5 (see [Gab00, Section 10]

for more details).

A New Approach to Abstract Syntax with Variable Binding 355
It is well known that set-functions F built up from constants and projections using the operations of Cartesianproduct, (-)*(-), and disjoint union, (-)+(-), enjoy the above properties of monotonicity, preservation of
unions of chains and functoriality; and hence such set-functions can be used to form inductively defined sets
u(F ) with the above initial algebra property. This is the starting point for the initial algebra semantics ofalgebraic signatures [GTWW77] within the usual ZF set theory and its model, the von Neumann hierarchy

V defined by equation (9). All this remains unchanged if we move from V to the larger (cf. Remark 4.2)Fraenkel-Mostowski cumulative hierarchy FM(A) and replace ZF by FM-set theory. But now the above
lemma shows that within this larger setting of FM-sets we can also use the abstraction-set operation [A](-)in the construction of

F and still be able to form the inductive FM-set u(F ) as in (53), with its initial algebraproperty (54). In this way we are able to extend initial algebra semantics to deal with signatures with binding

and in particular to get a purely inductive representation of the quotient modulo ff-equivalence of the set ofabstract syntax trees over such a signature. Rather than treat the case of arbitrary `binding signatures' (for
which see [Gab00, Section 10.2]), we will illustrate these ideas with respect to the paradigmatic example,the signature for the untyped

*-calculus.

Theorem 6.2 (\Lambda /=ff as an inductive FM-set). Consider the FM-set \Lambda  of untyped *-terms, given as theinductively defined FM-set

u(F ) where

F (X) , A + (X * X) + (A * X) (56)
Then the FM-set of equivalence classes of *-terms modulo the equivalence relation of ff-conversion, \Lambda /=ff,is in bijection with the inductively defined FM-set \Lambda 

ff = u(Fff), where

Fff(X) , A + (X * X) + ([A]X) (57)
Proof. This follows by combining the characterisation of =ff given by Proposition 2.2 with the definition ofatom-abstraction in Section 5 in terms of the equivalence relation ,

A given by equation (33).

In passing from \Lambda /=ff to the bijectively equivalent set \Lambda ff, we replace the global use of quotienting by =ffwith local, inductive use of quotienting by ,

A. This is a simplifying step because the quotient sets [A]X(they are the quotient of {(a, x) 2 A * X | a # X} by ,

A) have some very pleasant properties. In particular,the following lemma gives a simple characterisation of functions of atom-abstractions a.x 2 [A]X in terms

of functions of pairs (a, x) 2 A * X.
Lemma 6.3. For all functions f 2 (A * X) ! Y in FM(A), there is a unique function ^f 2 ([A]X) ! Ysatisfying

Na 2 A 8x 2 X( ^f(a.x) = f(a, x)) (58)
if and only if f satisfies

Na 2 A 8x 2 X(a # f(a, x)) (59)

Proof. First note that if such an ^f exists, then applying Proposition 4.10 to (58), there is some a 2 A with

a # X, ^f , f ^ 8x 2 X( ^f(a.x) = f (a, x))
But for any x 2 X we always have a # a.x (Corollary 5.2); and a # ^f holds by assumption on a; hence by
property (24), a # ^f(a.x), i.e. a # f (a, x). Thus a satisfies

a # X, f ^ 8x 2 X(a # f (a, x))

which by Proposition 4.10 again, is condition (59). There can be at most one function ^f satisfying prop-erty (58), because by (44) we have that (

a, x) 7! a.x is a surjection from {(a, x) 2 A * X | a # X} onto[
A]X.Conversely, suppose condition (59) does hold. Thus by Proposition 4.10 we have

8a 2 A(a # X, f ) 8x 2 X(a # f (a, x))) (60)
Define an FM-set ^f by

^f , {(z, y) 2 ([A]X) * Y | Na 2 A 9x 2 X(z = a.x ^ f(a, x) = y)}

356 M. J. Gabbay and A. M. Pitts
This is a single-valued relation, because if (z, y) 2 ^f and (z, y0) 2 ^f, then by definition of ^f, and using axiom(Fresh), we can find some

a # X, f, z, y, y0 and x, x0 2 X with z = a.x, z = a.x0, y = f (a, x) and y = f(a, x0);then
x = x0 by property (36) and hence y = y0. Moreover, for each z 2 [A]X there is some y 2 Y satisfying

(z, y) 2 ^f: for, picking a # X, z, f and taking x to be the concretion z@a (Definition 5.3), we have x 2 X byproperty (45) and hence by property (60),

y = f(a, x) 2 Y satisfies a # y. Thus we have

9a 2 A(a # X, z, f, y ^ 9x 2 X(z = a.x ^ f(a, x) = y)) (61)

so that (z, y) 2 ^f (by Proposition 4.10). So ^f is indeed an element of ([A]X) ! Y . Furthermore, property (58)holds of it: for if

a # X, f, then for any x 2 X property (61) holds with z = a.x and y = f (a, x) (since in

that case a # z by (38) and a # y by (59)), so that (z, y) 2 ^f, i.e. ^f (a.x) = ^f(z) = y = f (a, x), as required.

Remark 6.4 (Locally fresh atoms). Given f 2 (A*X) ! Y satisfying property (59) and given z 2 [A]X,we use the notation

case z of {a.x ! f(a, x)} (62)
(where the variables a and x are bound in this expression) for the element ^f(z) 2 Y specified by the abovelemma. From property (58) we have that this `eliminator' for the abstraction-set construct satisfies the

conversion law

8a0 2 A 8x0 2 X Nb 2 A(case a0.x0 of {a.x ! f (a, x)} = f(b, (b a0) * x0)) (63)
As a special case of this construct, given by taking X = 1 = {0} in Lemma 6.3, we have that for each
f 2 A ! Y satisfying Na 2 A(a # f(a)), there is a unique element of Y , that we denote by

new a 2 A in f (a) (64)
(once again, a is a bound variable in this expression), satisfying

Na0 2 A(new a 2 A in f(a) = f(a0)) (65)
In effect, the expression new a 2 A in f (a) denotes the use of a `locally fresh' atom a in the expression f(a);and this is meaningful if the value of

f (a) is independent of the choice of a, in the sense that a # f(a) holdsfor some/any fresh atom
a.For example, taking
f 2 A ! ([A]A) to be a 7! a.a, by property (38) we have 8a 2 A(a # a.a) and hence

there is an element (new a 2 A in a.a) 2 [A]A. In fact there is a bijection [A]A ,= 1 + A , {(0, 0)} [ {(1, b) |
b 2 A} given in one direction by

[A]A ! 1 + A

z 7! case z of {a.b ! if a = b then (0, 0) else (1, b)}

and in the other by

1 + A ! [A]A(0

, 0) 7! new a 2 A in a.a(1

, b) 7! new a 2 A in a.b

Expression-formers such as case (-) of {a.x ! (-)} and new a 2 A in (-) are part of a term-calculusfor atom-abstractions that forms part of the functional programming language proposed by the authors

in [PiG00].
Returning to the inductively defined FM-set \Lambda ff = u(Fff) introduced in Theorem 6.2, from property (51) wehave that \Lambda 

ff is a disjoint union of three components

\Lambda ff = A + (\Lambda ff * \Lambda ff) + ([A]\Lambda ff)

Let

var 2 A ! \Lambda ff app 2 (\Lambda ff * \Lambda ff) ! \Lambda ff lam 2 ([A]\Lambda ff) ! \Lambda ff
denote the inclusion functions of the components into the disjoint union. Combining the least fixed point

A New Approach to Abstract Syntax with Variable Binding 357
and initial algebra properties of \Lambda ff = u(Fff) with Lemma 6.3, we obtain the following principles of struc-tural iteration, recursion and induction for our inductive FM-set representing

*-terms modulo ff-conversion.(Compare them with the Recursion Scheme of [GoM96, Section 3.1].)

Theorem 6.5 (Structural iteration for \Lambda ff). Given functions f 2 A ! X, g 2 (X * X) ! X, and
h 2 (A * X) ! X in FM(A) with h satisfying

Na 2 A 8x 2 X(a # h(a, x)) (66)
there is a unique k 2 \Lambda ff ! X such that8

a 2 A(k(var(a)) = f (a))^ 8
t 2 \Lambda ff 8t0 2 \Lambda ff(k(app(t, t0)) = g(k(t), k(t0)))^

Na 2 A 8t 2 \Lambda ff(k(lam(a.t)) = h(a, k(t))) (67)

Proof. By Lemma 6.3, the condition (66) means that it induces a function ^h 2 ([A]X) ! X. Then f , g and^
h fit together to give a function from the coproduct A + (X * X) + ([A]X) to X, i.e. a function Fff(X) ! X.Then

k is the unique function u(Fff) ! X given by the initial algebra property (54).

Remark 6.6. Note that this structural iteration principle for \Lambda ff proves the existence of total functions outof \Lambda 

ff even though in property (67), as far as *-abstractions are concerned, we only have to specify what thefunction does for fresh bound variables. Indeed, we can slightly strengthen Theorem 6.5 by only requiring h

to be a partial function with dom(h) = {(a, x) 2 A * X | a # X}, for which condition (66) still makes sense.However, if

supp(X) = ;, as is the case in the examples below, then dom(h) is in fact the whole of A * X.

Corollary 6.7 (Structural recursion for \Lambda ff). Given functions f 2 A ! X, g 2 (\Lambda ff*\Lambda ff*X *X) ! X,and

h 2 (\Lambda ff * A * X) ! X in FM(A) with h satisfying

Na 2 A 8t 2 \Lambda ff 8x 2 X(a # h(t, a, x)) (68)
there is a unique k 2 \Lambda ff ! X such that8

a 2 A(k(var(a)) = f (a))^ 8
t 2 \Lambda ff 8t0 2 \Lambda ff(k(app(t, t0)) = g(t, t0, k(t), k(t0))^

Na 2 A 8t 2 \Lambda ff(k(lam(a.t)) = h(t, a, k(t)) (69)

Proof. The passage from iteration to (primitive) recursion for initial algebras uses a standard trick relyingupon the uniqueness part of the initial algebra property: define

X0 to be \Lambda ff * X and consider f0 2 A ! X0,
g 2 (X0 * X0) ! X0, and h0 2 (A * X0) ! X0 given by

f0(a) , (var(a), f(a))
g0((t, x), (t0, x0)) , (app(t, t0), g(t, t0, x, x0))

h0(a, (t, x)) , (lam(a.t), h(t, a, x))
Note that h0 satisfies condition (66) because of property (38) and because h satisfies (68). So let k0 2 \Lambda ff ! X0be the function uniquely defined by iteration from (

f 0, g0, h0) as in Theorem 6.5. Writing ss1 and ss2 forthe projection functions (
t, x) 7! t and (t, x) 7! x, one verifies that ss1 ffi k0 and the identity function
id\Lambda ff 2 \Lambda ff ! \Lambda ff both satisfy the conditions required of the function iteratively defined by (var, app, lam),where lam 2 (

A * \Lambda ff) ! \Lambda ff is (a, t) 7! lam(a.x). (Note that this triple of functions is suitable for astructurally iterative definition because lam satisfies the necessary condition (66), thanks to property (38).)

Hence ss1 ffik0 = id\Lambda ff . Using this one easily verifies that k = ss2 ffik0 2 \Lambda ff ! X is the uniquely defined functionwith the required property (69).

Theorem 6.8 (Structural induction for \Lambda ff). Given a subset S ` \Lambda ff in FM(A), to prove that S is thewhole of \Lambda 

ff it suffices to show8

a 2 A(var(a) 2 S)^ 8
t 2 S 8t0 2 S(app(t, t0) 2 S)^

Na 2 A 8t 2 S(lam(a.t) 2 S) (70)

Proof. Condition (70) tells us that the inclusion

A + (S * S) + ([A]S) ` A + (\Lambda ff * \Lambda ff) + ([A]\Lambda ff) = \Lambda ff

358 M. J. Gabbay and A. M. Pitts
factors through S ` \Lambda ff (we use property (46) to see this for the third component of the disjoint union).Hence

Fff(S) ` S and therefore by property (52) we have \Lambda ff = u(Fff) ` S. Thus S = \Lambda ff.

This structural induction principle for \Lambda ff seems to correspond well to informal inductive arguments about ff-equivalence classes of

*-terms that proceed by picking representative names of bound variables and applyingstructural induction at the level of abstract syntax trees (i.e. structural induction for \Lambda  =

u(F ), as definedin Theorem 6.2), leaving mute the tedious proofs that such choices do not affect the argument. In effect, by

restricting to objects with finite support (Definition 3.3) and equivariant properties (Lemma 4.7), FM-settheory ensures that such choices are guaranteed not to affect meaning, provided freshness conditions like
property (66) in Theorem 6.5 are satisfied.In the rest of this section we give some simple examples of the use of Theorems 6.5 and 6.8.

Example 6.9 (Capture-avoiding substitution). Given s 2 \Lambda ff and b 2 A, in Theorem 6.5 take X = \Lambda ffand define

f 2 A ! \Lambda ff, g 2 (\Lambda ff * \Lambda ff) ! \Lambda ff and h 2 (A * \Lambda ff) ! \Lambda ff by

f(a) , if a = b then s else var(a)
g(t, t0) , app(t, t0)

h(a, t) , lam(a.t)
Note that h satisfies condition (66) because of property (38). So by the theorem there is a unique functionin \Lambda 

ff ! \Lambda ff, whose value at t 2 \Lambda ff we write as sub s for b in t, satisfying8

a 2 A sub s for b in var(a) =

if a = b then s else var(a)^ 8
t0 2 \Lambda ff 8t00 2 \Lambda ff sub s for b in app(t, t0) =

app(sub s for b in t, sub s for b in t0)^
Na 2 A 8t 2 \Lambda ff sub s for b in lam(a.t) =

lam(a.(sub s for b in t))

From the above properties it follows that under the bijection of Theorem 6.2 between elements s of \Lambda ffand

ff-equivalence classes of *-terms N , the function sub s for b in (-) corresponds to the capture-avoidingsubstitution function [

N/b](-). Note that in the clause for *-abstractions lam(a.t), we only have to specifythe result of substitution for the simple case that

a is fresh in order for sub s for b in (-) to be defined onthe whole of \Lambda 

ff.One property of capture-free substitution is that the only free occurrences of b in [N/b]M are due to free

occurrences of b in N . The analogue for \Lambda ff of this property is

b # s ) 8t 2 \Lambda ff(b # sub s for b in t) (71)
This can be proved by structural induction on t by taking S = {t 2 \Lambda ff | b # sub s for b in t} in Theorem 6.8and making use of the easily verified fact that

b # s ) b # (if a = b then s else var(a))
Applying Proposition 4.10 to (71), we have for each s 2 \Lambda ff that

Nb 2 A 8t 2 \Lambda ff(b # sub s for b in t)
Thus by Lemma 6.3, for each s 2 \Lambda ff the element of (A * \Lambda ff) ! \Lambda ff given by (b, t) 7! sub s for b in t inducesa function ([

A]\Lambda ff) ! \Lambda ff. In this way we get a substitution function oe 2 (([A]\Lambda ff) * \Lambda ff) ! \Lambda ff satisfyingfor all (
y, s) 2 ([A]\Lambda ff) * \Lambda ff that Na 2 A(oe(y, s) = sub s for a in (y@a)). (Compare with the substitutionfunction

oe : ffi\Lambda  * \Lambda  ! \Lambda  in [FPT99, Section 3].)

Example 6.10 (A size function). In Theorem 6.5, taking X to be the set ! of natural numbers, f 2 A !
! to be the constant function a 7! 1, g 2 (! * !) ! ! to be addition and h 2 (A * !) ! ! to be the function(

a, n) 7! n + 1, we can deduce that there is a unique function k 2 \Lambda ff ! ! satisfying

8a 2 A(k(var(a)) = 1)^ 8

t 2 \Lambda ff 8t0 2 \Lambda ff(k(app(t, t0)) = k(t) + k(t0))^

Na 2 A 8t 2 \Lambda ff(k(lam(a.t)) = k(t) + 1)

A New Approach to Abstract Syntax with Variable Binding 359
Condition (66) is satisfied in this case because ! is a pure FM-set (see Remark 4.2) and hence 8a 2 A 8n 2
!(a # n).By Proposition 4.10, the last property of

k in the above conjunction is equivalent to8

a 2 A(a # k ) 8t 2 \Lambda ff(k(lam(a.t)) = k(t) + 1))
But Corollary 4.8 implies that a # k holds for any a 2 A. Therefore we can strengthen this last definingclause for

k to8

a 2 A 8t 2 \Lambda ff(k(lam(a.t)) = k(t) + 1))
Thus the formalism we have developed allows us to express very easily the properties we expect a size functionto have on

ff-equivalence classes of *-terms. Compare this example with the complications encounteredby Gordon and Melham when defining a similar function by recursion using their axiomatisation of

ff-conversion [GoM96, Section 3.3].

Example 6.11 (Set of free atoms). In Theorem 6.5, take X to be the set powfin(A) of finite sets of atoms,
f 2 A ! powfin(A) to be the singleton function a 7! {a}, g 2 (powfin(A) * powfin(A)) ! powfin(A) to beunion and

g 2 (A * powfin(A)) ! powfin(A) to be the subtraction function (a, w) 7! w - {a}. Note that hsatisfies condition (66), because the support of a finite set of atoms

w 2 powfin(A) is just w itself and hence
a # (w - {a}), for any a 2 A. So there is a unique function k 2 \Lambda ff ! powfin(A) satisfying

8a 2 A(k(var(a)) = {a})^ 8

t 2 \Lambda ff 8t0 2 \Lambda ff(k(app(t, t0)) = k(t) [ k(t0))^ 8
a 2 A 8t 2 \Lambda ff(k(lam(a.t)) = k(t) - {a})

where in the last conjunct we have strengthened Na 2 A . . . to 8a 2 A . . . using the same argument asin the previous example. This function

k gives a structurally iterative definition of the `finite set of freeatoms' for elements of \Lambda 

ff. Using the structural induction principle of Theorem 6.8, one can show for allt 2 \Lambda 
ff that in fact k(t) = supp(t). Thus under the bijection of Theorem 6.2, the set of (names of) freevariables of an ff-equivalence class of *-terms is identified with the support of the corresponding element of

\Lambda ff (cf. Example 3.5(iii)). In particular, {t 2 \Lambda ff | supp(t) = ;} corresponds to the subset of closed *-termsmodulo =

ff.

Example 6.12 (Binding occurrences of atoms). It is simple enough to define a function \Lambda  ! powfin(A)sending each

*-term M to the finite set of atoms that occur in M in binding position. Clearly this set isnot invariant under

ff-conversion and so does not induce a function on \Lambda /=ff. Correspondingly, there is nofunction ba 2 \Lambda 

ff ! powfin(A) in FM(A) picking out the finite set of `binding atoms' of elements of \Lambda ff, inthe sense that it satisfies

8a 2 A(ba(var(a)) = ;)^ 8

t 2 \Lambda ff 8t0 2 \Lambda ff(ba(app(t, t0)) = ba(t) [ ba(t0))^

Na 2 A 8t 2 \Lambda ff(ba(lam(a.t)) = {a} [ ba(t))

(Note that we cannot use Theorem 6.5 to define such a function because in this case condition (66) wouldrequire

a # {a} [ w (any w 2 powfin(A)), which is certainly false.) Indeed, we can argue by contradiction tosee that no such function exists in FM(A): if it did, picking any atoms

a 6= a0 not in its support, we wouldhave (
a0 a) * ba = ba (by property (15)); then t = lam(a.var(a)) satisfies ba(t) = {a} and so{

a0} = (a0 a) * {a} = (a0 a) * ba(t)

= ba(t) since a, a0 # ba(t), by (24)
= {a}

i.e. a0 = a, contradicting the choice of a and a0.
The theory we have presented seems rather well adapted to expressing the `usual' forms of recursion/inductionfor abstract syntax, while at the same time dealing with freshness of variables and variable renaming systematically, at the meta-level. Of course much more needs to be done to establish the utility of these structuralrecursion and induction principles (see Section 8). However, we regard the sheer simplicity of the above
examples (compared with analogous examples in other formalisms) as a good sign! We finish this section bymentioning some extensions of the theory.

360 M. J. Gabbay and A. M. Pitts
Remark 6.13 (Binding signatures). The terms of the lambda calculus are the terms over a signaturewith one binary operation (application) and one unary binder (

*-abstraction). The results of this sectioncan be extended to deal with more general signatures, consisting of

k operators (for some k >= 0) each ofwhich takes
m arguments (for some m >= 0) with each argument an n-ary abstraction (for some n >= 0) --these are the binding signatures considered in [FPT99, Section 2]. The function

F on FM-sets correspondingto such a signature takes the form

F (-) = A +

k summandsz ""-- -* * *
+ (* * * * [A]n(-) * * * *-- -z ""

m factors

) + * * *

whereae

[A]0(X) , X
[A]n+1(X) , [A]([A]n(X))

Generalising Theorem 6.2, one can show that the inductively defined FM-set u(F ) determined by F is inbijection with the set of terms modulo

ff-conversion over the binding signature. This FM-set is an initialalgebra for the functor associated with
F ; and from the shape of the signature can be read off principles ofstructural recursion and induction like those above. Many-sorted signatures can be dealt with using FM-sets

mutually inductively defined by several such functions. See [Gab00, Section 10] for more details.
Remark 6.14 (Splitting the set of atoms). To support syntax involving finitely many different sortsof variables one can use the following mild generalisation of the Fraenkel-Mostowski universe FM(A) of

Definition 4.1. Partition the set of atoms A into a countably infinite set of infinite subsets:

A = S{A(n) | n 2 !}^ 8

n 2 !(A(n) /2 powfin(A(n)))^ 8
n, n0 2 !(n 6= n0 ) A(n) " A(n0) = ;)

Working with sets equipped with an action of the subgroup G of perm(A) consisting of permutations thatrespect the partition (so that

G is isomorphic to the product group Qn2! perm(A(n))), we can repeat thedevelopment of Sections 3 and 4, forming a universe of sets with hereditarily finite support with respect to

the action of G. There is a corresponding generalisation of FM-set theory to Fraenkel-Mostowski set theorywith many Sorts of atoms (FMS-set theory), whose axioms we will not give here. Within that theory one
can develop the theory of transpositions (a b) *A x, a freshness predicate a #A x, a quantifier Na 2 A(-)and abstraction sets [

A]X, where a, b 2 A 2 {A(n) | n 2 !}. The latter can be used in combination withCartesian products and disjoint unions to form inductively defined sets in the universe just as in Section 6.

For example, taking two distinct sorts of atoms, T , A(0) and V , A(1) naming type variables and termvariables respectively, the mutually inductively defined FMS-sets

Type = tyvar(T ) + Fun(Type * Type) + all([T ]Type)
Term = var(V ) + app(Term * Term) + lam(Type * [V ]Term)+

spec(Term * Type) + gen([T ]Term) 9=;

(72)

represent, respectively, the types and terms of the Girard-Reynolds polymorphic lambda calculus [Gir72,Rey83] modulo renaming of bound type variables and bound term variables. (The disjoint union inclusion
functions have been named explicitly in (72) to indicate the intended meaning.)

7. Related Work
One origin of the work presented here lies in the `*-calculus', a fragment of ML [MTHM97] introduced bythe second author and Stark [PiS93a, Sta95] to explore the properties, with respect to semantic equivalence of programs, of call-by-value higher order functions and dynamically created names (see also [JeR99]).In [Sta96a], Stark studies a model of the

*-calculus based on one of Moggi's `dynamic allocation' monads [Mog89] in the presheaf category SetI, where I is the category of finite ordinals and injective functionsbetween them. Crucial ingredients of the dynamic allocation monad used there are the `object of names',

A New Approach to Abstract Syntax with Variable Binding 361
given by the inclusion functor I ,! Set, and the shift functor ffi : SetI ! SetI, given by ffiX(n) = X(n + 1).
These ingredients also occur in subsequent work on modelling ss-calculus names in SetI [FMS96, Sta96b]and, most relevantly, recent work on modelling variable-binding abstract syntax [FPT99, Hof99], where other

presheaf categories besides SetI are considered.Now, a somewhat overlooked model of the

*-calculus, mentioned in [PiS93b, Examples 4.3], is the full

subcategory of SetI whose objects are the pullback preserving functors. This is equivalent to a well-knowntopos, sometimes called the Schanuel topos -- the category of continuous

G-sets for the topological group G =perm(A) of permutations of a countably infinite set A topologised as a subspace of Baire space: see [Joh83,

Lemma 1.8] and [MaM92, Section III.9]. Put more concretely, and this is the point, the objects of the Schanueltopos are perm(A)-sets (Definition 3.1) in which every element has finite support (Definition 3.3), and its
morphisms are the equivariant functions defined at the beginning of Section 4. Thus on the one hand, theSchanuel topos relates to the cumulative hierarchy of FM-sets defined by equation (11) much as the usual
von Neumann cumulative hierarchy, defined by equation (9), relates to the topos of sets (see [JoM95] formore on the category theory of universes of sets); on the other hand, the Schanuel topos is a sheaf subtopos
of the presheaf category SetI, with the inclusion sending the FM-set of atoms A to the object of namesI

,! Set and the abstraction operator [A](-) to the shift functor ffi(-) mentioned above.Both the presheaf toposes used in [FPT99, Hof99] and the Schanuel topos (and indeed many other

categories equipped with a faithful functor to Set!) support an initial algebra semantics for signatureswith binding. So does the Schanuel topos, and its associated FM-set theory, have any advantage over these
other, related categories? It is well known that toposes correspond to theories in extensional, higher-order,intuitionistic logic [LaS86]. Unlike presheaf toposes in general, the Schanuel topos models classical rather
than intuitionistic higher-order logic; furthermore, its higher-order structure (function and power objects)is rather amenable to making calculations, compared with the higher-order structure of presheaf categories.
Thus if one is looking for a single, general-purpose setting for modelling variable-binding syntax, the logic ofthe Schanuel topos is both a bit more powerful and familiar. One can view [FPT99] as establishing, amongst
other things, a very nice categorical algebra for the de Buijn, `nameless' style of treating variable-binding andsubstitution. By contrast, here we have presented a useful logic for variable-binding in which names occur
explicitly. The motivation for such a `nameful' rather than nameless style is partly to formalise existingcommon practice; but the logic can also serve as a basis for proving that de Bruijn-like formulations are
correct with respect to more concrete representations. Crucial to all this is the notion of `finite support'(leading to the

N-quantifier and our FM-set-theoretic notion of atom-abstraction), which is present in theSchanuel toposes, but not, apparently, in the presheaf toposes used in [FPT99] -- or at least not with such

pleasant properties.Finally, it is worth emphasising that although we have chosen to use a set-theoretic rather than a topostheoretic presentation here -- because we think it is more accessible -- the same fundamental ideas to dowith names and name-abstraction underlie both FM-set theory and the Schanuel topos.

8. Conclusion and Further Developments
The Fraenkel-Mostowski permutation model of ZFA is well over sixty years old. Yet the use to which we haveput it here seems new. The idea that one might want to treat syntax up to permutative renamings of variables
is hardly original, but we hope we have demonstrated convincingly that the theory really takes off when onecombines that idea with the subtle notion of `finite support' inherent in the Fraenkel-Mostowski model. Using
it, we introduced a useful quantifier Nfor fresh names and a new set-forming operation for name-abstraction,[

A](-), whose properties seem better suited to modelling variable-binding than the function space A ! (-)that is often used for that purpose. Among other things, we saw that the theory of inductively defined FMsets using this notion of abstraction can correctly model ff-equivalence classes of variable-binding syntax. Atthe same time we remain pleasantly close to the familiar theory of first-order algebraic data types -- witness
Theorems 6.5 and 6.8, and Examples 6.9-6.12.We believe that the theory of inductively defined FM-sets will be a useful setting for developing programming language semantics based on structural operational semantics [Plo81]. Syntax-directed, rule-basedinductive definitions of relations quite often contain side-conditions to do with freshness of variables, and
the hope is that these can be assimilated and manipulated conveniently via the freshness predicate # andthe

N-quantifier we have introduced here. This approach seems particularly relevant for the labelled transi362 M. J. Gabbay and A. M. Pitts
tion semantics of process calculi such as the ss-calculus and its relations [MPW92, AbG99, CaG00b]; bothbecause complicated forms of binding to do with names and names restriction play a key role there and
because analyses based on `name-abstraction as functions' [HMS98, Des00] are not entirely satisfactory. Theformalism of permutation actions and finite support has been rediscovered independently by Honda in his
work on a general framework for processes [Hon00]. It also features in work on finite state transition systemsfor checking bisimilarity of

ss-calculus processes in [MoP00]. Cardelli and Gordon have taken up some of theideas presented here and used permutative renaming and the

N-quantifier as part of a modal logic for theirambient calculus [CaG00a].

This paper is a revised and expanded version of [GaP99]. Since that paper appeared, the theory we havedescribed here has been developed and applied in two somewhat different directions. The first author has
developed an implementation of FM-set theory within the Isabelle generic theorem prover [Pau94]. Thisrequired a good deal of `proof engineering' to reuse the existing Isabelle ZF theory; an account may be
found in Chapter III of the first author's thesis [Gab00] (Chapter II of which contains a development ofFM-set theory more detailed than the one given here). Secondly, we have begun to design an ML-style
metalanguage, FreshML, for programming with recursively defined functions on inductively defined FM-sets. The ingredients of

FreshML are described in [PiG00]. It has a type of atoms, a type constructor foratom-abstractions, and facilities for defining recursive functions involving locally fresh names and patternmatching on atom-abstractions (cf. Remark 6.4). The FreshML type system infers not only conventionaltyping information, but also information about freshness assertions

a # x; the crucial point is that the typesystem ensures that the language's facilities for manipulating bound names can only be used in well-typed

programs in ways that are insensitive to renaming those bound names.

References
[AbG99] Abadi, M. and Gordon, A. D.: A calculus for cryptographic protocols: the spi calculus. Information and Computation, 148:1-70, 1999.
[Bar84] Barendregt, H. P.: The Lambda Calculus: Its Syntax and Semantics (rev. edn). North-Holland, Amsterdam, 1984.
[Bur69] Burstall R. M.: Proving properties of programs by structural induction. Computer Journal, 12:41-48, 1969.
[Bur77] Burstall, R. M.: Design considerations for a functional programming language. In Proc. of the Infotech State of

the Art Conference, Copenhagen, 1977.
[CaG00a] Cardelli, L. and Gordon A. D.: Logical properties of name restriction. In Typed Lambda Calculus and Applications,

5th International Conference, Vol. 2044 of Lecture Notes in Computer Science. Springer-Verlag, Berlin, 2001.
[CaG00b] Cardelli, L. and Gordon, A. D.: Mobile ambients. Theoretical Computer Science, 240:177-213, 2000.
[Chu40] A. Church. A formulation of the simple theory of types. Journal of Symbolic Logic, 5:56-68, 1940.
[Cur93] P.-L. Curien. Categorical Combinators, Sequential Algorithms, and Functional Programming. Birkh"auser, Basel,

1993.
[dB72] de Bruijn, N. G.: Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation,

with application to the Church-Rosser theorem. Indag. Math., 34:381-392, 1972.
[Des00] Despeyroux, J.: A higher-order specification of the pi-calculus. In IFIP International Conference on Theoretical

Computer Science, IFIP TCS'2000, Sendai, Japan, 2000.
[DPS97] J. Despeyroux, F. Pfenning, and C. Sch"urmann. Primitive recursion for higher-order abstract syntax. In Typed

Lambda Calculus and Applications, 3rd International Conference, Vol.1210 of Lecture Notes in Computer Science.
Springer, Berlin, 1997, pp. 147-163.
[FMS96] Fiore, M. P., Moggi, E. and Sangiorgi, D.: A fully abstract model for the ss-calculus (extended abstract). In

Eleventh Annual Symposium on Logic in Computer Science. IEEE Computer Society Press, Washington, DC,
1996, pp. 43-54.
[Fou80] Fourman, M. P.:. Sheaf models for set theory. Journal of Pure and Applied Algebra, 19:91-101, 1980.
[FPT99] Fiore, M. P., Plotkin, G. D. and Turi, D.: Abstract syntax and variable binding. In 14th Annual Symposium on

Logic in Computer Science. IEEE Computer Society Press, Washington, DC, 1999, pp. 193-202
[Gab00] Gabbay, M. J.: A Theory of Inductive Definitions with ff-Equivalence: Semantics, Implementation, Programming

Language. PhD thesis, Cambridge University, 2000.
[Gir72] Girard, J.-Y.: Interpr'etation fonctionelle et 'elimination des coupures dans l'arithmetique d'ordre sup'erieur. PhD

thesis, Universit'e Paris VII, 1972.
[GoM93] Gordon M. J. C. and Melham T. F.: Introduction to HOL. A theorem proving environment for higher order logic.

Cambridge University Press, Cambridge UK, 1993.
[GoM96] Gordon A. D. and Melham, T.: Five axioms of alpha-conversion. In Theorem Proving in Higher Order Logics:

9th Interational Conference, TPHOLs'96, Vol. 1125 of Lecture Notes in Computer Science. Springer, Berlin, 1996,
pp. 173-191
[GaP99] Gabbay, M. J. and Pitts, A. M.: A new approach to abstract syntax involving binders. In 14th Annual Symposium

on Logic in Computer Science. IEEE Computer Society Press, Washington, DC, 1999, pp. 214-224.
[GTWW77] Goguen, J. A. , Thatcher, J. W., Wagner, E. G. and Wright, J. B.: Initial algebra semantics and continuous

algebras. Journal of the Association for Computing Machinery, 24:68-95, 1977.

A New Approach to Abstract Syntax with Variable Binding 363
[Gun92] Gunter, C. A.: Semantics of Programming Languages: Structures and Techniques. Foundations of Computing.

MIT Press, Cambridge, MA, 1992.
[HMS98] Honsell, F., Miculan, M. and Scagnetto, I.: ss-Calculus in (co)inductive type theory. Technical report, Dipartimento

di Matematica e Informatica, Universit`a degli Studi di Udine, 1998.
[Hof99] Hofmann, M.: Semantical analysis of higher-order abstract syntax. In 14th Annual Symposium on Logic in

Computer Science. IEEE Computer Society Press, Washington, DC, 1999, pp. 204-213.
[Hon00] Honda, K.: Elementary structures in process theory (1): Sets with renaming. Mathematical Structures in Computer

Science, 10:617-663, 2000.
[Jec77] Jech, T. J.: About the axiom of choice. In J. Barwise, editor, Handbook of Mathematical Logic. North-Holland,

Amsterdam, 1977, pp. 345-370.
[JoM95] Joyal, A. and Moerdijk, I.: Algebraic Set Theory. Number 220 in London Mathematical Society Lecture Notes in

Mathematics. Cambridge University Press, Cambridge, UK, 1995.
[Joh83] Johnstone, P. T.: Quotients of decidable objects in a topos. Math. Proc. Cambridge Philosophical Society, 93:409-

419, 1983.
[JeR99] Jeffrey, A. and Rathke, J.: Towards a theory of bisimulation for local names. In 14th Annual Symposium on Logic

in Computer Science. IEEE Computer Society Press, Washington, DC, 1999, , pp. 56-66.
[LaP99] Lamport, L. and Paulson, L. C.: Should your specification language be typed? ACM Transactions on Programming

Languages and Systems, 21(3):502-526, 1999.
[LaS86] Lambek, J. and Scott, P. J.: Introduction to Higher Order Categorical Logic. Cambridge University Press, Cambridge, UK, 1986.
[Mar84] Martin-L"of, P.: Intuitionistic Type Theory. Bibliopolis, Naples, 1984.
[MaM92] MacLane, S. and Moerdijk, I.: Sheaves in Geometry and Logic. A First Introduction to Topos Theory. Springer,

New York, 1992.
[McM97] McDowell, R. and Miller, D: A logic for reasoning with higher-order abstract syntax. In 12th Annual Symposium

on Logic in Computer Science. IEEE Computer Society Press, Washington, DC, 1997, , pp. 434-445.
[Mog89] Moggi, E.: An abstract view of programming languages. Technical Report ECS-LFCS-90-113, Department of

Computer Science, University of Edinburgh, 1989.
[MoP00] Montanari, U. and Pistore, M.: ss-Calculus, structured coalgebras and minimal HD-automata. In 25th International

Symposium on Mathematical Foundations of Computer Science, Bratislava, Slovak Republic, Vol. 1893 of Lecture
Notes in Computer Science. Springer, Berlin, 2000.
[MPW92] Milner, M., Parrow, J. and Walker, D.: A calculus of mobile processes (parts I and II). Information and Computation, 100:1-77, 1992.
[MTHM97] Milner, R., Tofte, M., Harper, R. and MacQueen, D.: The Definition of Standard ML (Revised). MIT Press,

Cambridge, MA, 1997.
[Pau94] Paulson, L. C.: Isabelle: A Generic Theorem Prover. Vol. 828 of Lecture Notes in Computer Science. Springer,

Berlin, 1994.
[PfE88] Pfenning, F. and Elliott, C.: Higher-order abstract syntax. In Proc. ACM-SIGPLAN Conference on Programming

Language Design and Implementation. ACM Press, New York, 1988, pp. 199-208.
[PiG00] Pitts, A. M. and Gabbay, M. J.: A metalanguage for programming with bound names modulo renaming. In R. Backhouse and J. N. Oliveira, editors, Mathematics of Program Construction. 5th International Conference, MPC2000,
Ponte de Lima, Portugal, July 2000. Vol. 1837 of Lecture Notes in Computer Science. Springer, Heidelberg, 2000,
pp. 230-255.
[Plo81] Plotkin, G. D.: A structural approach to operational semantics. Technical Report DAIMI FN-19, Aarhus University,

1981.
[PaM93] Paulin-Mohring, C.: Inductive definitions in the system Coq; rules and properties. In M. Bezem and J. F. Groote,

editors, Typed Lambda Calculus and Applications. Vol. 664 of Lecture Notes in Computer Science. Springer, Berlin,
1993, pp. 328-345.
[PiS93a] Pitts, A. M. and Stark, I. D. B. : Observable properties of higher order functions that dynamically create local

names, or: What's new? In Mathematical Foundations of Computer Science, Proceedings of the 18th International
Symposium, Gda'nsk. Vol. 711 of Lecture Notes in Computer Science. Springer, Berlin, 1993, pp. 122-141.
[PiS93b] Pitts, A. M. and Stark, I. D. B. : On the observable properties of higher order functions that dynamically create local

names (preliminary report). In Workshop on State in Programming Languages, Copenhagen. ACM SIGPLAN.
Technical Report YALEU/DCS/RR-968, Yale University Department of Computer Science, 1993, pp. 31-45.
[Qui63] Quine, W. V. O.: Set Theory and its Logic (rev. edn). Harvard University Press, Cambridsge, MA, 1963.
[Rey83] Reynolds, J. C.: Types, abstraction and parametric polymorphism. In R. E. A. Mason, editor, Information

Processing 83. North-Holland, Amsterdam, 1983, pp. 513-523.
[Sco93] Scott, D. S.: A type-theoretical alternative to ISWIM, CUCH, OWHY. Theoretical Computer Science, 121:411-440,

1993.
[Sho77] Shoenfield, J. R.: Axioms of set theory. In J. Barwise, editor, Handbook of Mathematical Logic. North-Holland,

Amsterdam, 1977, pp. 321-344.
[Sta95] Stark, I. D. B.: Names and Higher-Order Functions. PhD thesis, University of Cambridge, 1995. Also published

as Technical Report 363, University of Cambridge Computer Laboratory, April 1995.
[Sta96a] Stark, I. D. B.: Categorical models for local names. Lisp and Symbolic Computation, 9(1):77-107, 1996.
[Sta96b] Stark, I. D. B.: A fully abstract domain model for the ss-calculus. In 11th Annual Symposium on Logic in Computer

Science. IEEE Computer Society Press, Washington, DC, 1996, pp. 36-42.
[Sto88] Stoughton, A.: Substitution revisited. Theoretical Computer Science, 59:317-325, 1988.