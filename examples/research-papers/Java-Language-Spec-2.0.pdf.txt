

The Java(TM)Language Specification
Second Edition

The Java(TM) Series
Lisa Friendly, Series Editor
Bill Joy, Technical Advisor

The Java(TM) Programming LanguageKen Arnold and James Gosling
ISBN 0-201-63455-4
The Java(TM) Language Specification Second EditionJames Gosling, Bill Joy, Guy Steele and Gilad Bracha
ISBN  0-201-31008-2
The Java(TM) Virtual Machine Specification Second EditionTim Lindholm and Frank Yellin
ISBN 0-201-43294-3
The Java(TM) Application Programming Interface,Volume 1: Core Packages
James Gosling, Frank Yellin, and the Java TeamISBN 0-201-63452-X

The Java(TM) Application Programming Interface,Volume 2: Window Toolkit and Applets
James Gosling, Frank Yellin, and the Java TeamISBN 0-201-63459-7

The Java(TM) Tutorial: Object-Oriented Programming for the InternetMary Campione and Kathy Walrath
ISBN 0-201-63454-6
The Java(TM) Class Libraries: An Annotated ReferencePatrick Chan and Rosanna Lee
ISBN 0-201-63458-9
The Java(TM) FAQ: Frequently Asked QuestionsJonni Kanerva
ISBN 0-201-63456-2

The Java(TM)Language Specification
Second Edition

James Gosling

Bill Joy
Guy Steele
Gilad Bracha

ADDISON-WESLEYAn imprint of Addison Wesley Longman, Inc.
Reading, Massachusetts l Harlow, England l Menlo Park, CaliforniaBerkeley, California

l Don Mills, Ontario l Sydney

Bonn l Amsterdam l Tokyo l Mexico City

Copyright (C) 1996-2000 Sun Microsystems, Inc.901 San Antonio Road, Mountain View, California 94303 U.S.A.
All rights reserved.
Duke logo(TM) designed by Joe Palrang.

RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the United StatesGovernment is subject to the restrictions set forth in DFARS 252.227-7013 (c)(1)(ii) and

FAR 52.227-19.
The release described in this manual may be protected by one or more U.S. patents,foreign patents, or pending applications.

Sun Microsystems, Inc. (SUN) hereby grants to you a fully paid, nonexclusive, nontransferable, per-petual, worldwide limited license (without the right to sublicense) under SUN's intellectual property
rights that are essential to practice this specification. This license allows and is limited to the cre-ation and distribution of clean room implementations of this specification that: (i) include a complete implementation of the current version of this specification without subsetting or supersetting;(ii) implement all the interfaces and functionality of the required packages of the Java(TM) 2 Platform,
Standard Edition, as defined by SUN, without subsetting or supersetting; (iii) do not add any addi-tional packages, classes, or interfaces to the java.* or javax.* packages or their subpackages; (iv)
pass all test suites relating to the most recent published version of the specification of the Java(TM) 2Platform, Standard Edition, that are available from SUN six (6) months prior to any beta release of
the clean room implementation or upgrade thereto; (v) do not derive from SUN source code orbinary materials; and (vi) do not include any SUN source code or binary materials without an appropriate and separate license from SUN.
Sun, Sun Microsystems, Sun Microsystems Computer Corporation, the Sun logo, the SunMicrosystems Computer Corporation logo, Solaris, Java, JavaSoft, JavaScript, HotJava,

JDK, and all Java-based trademarks or logos are trademarks or registered trademarks ofSun Microsystems, Inc. UNIX

(R) is a registered trademark in the United States and othercountries, exclusively licensed through X/Open Company, Ltd. Apple and Dylan are

trademarks of Apple Computer, Inc. All other product names mentioned herein are thetrademarks of their respective owners.

THIS PUBLICATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANYKIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULARPURPOSE, OR NON-INFRINGEMENT.

THIS PUBLICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPO-GRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION HEREIN; THESE CHANGES WILL BE INCORPORATED IN NEWEDITIONS OF THE PUBLICATION. SUN MICROSYSTEMS, INC. MAY MAKE
IMPROVEMENTS AND/OR CHANGES IN THE PRODUCT(S) AND/OR THE PRO-GRAM(S) DESCRIBED IN THIS PUBLICATION AT ANY TIME.

Credits and permissions for quoted material appear in a separate section on page 503.

Text printed on recycled and acid-free paper
ISBN 0-201-31008-21 2 3 4 5 6 7 8 9-MA-99989796

First printing, June 2000

vii

Table of Contents
Table of Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  vii
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  xix
Preface to the Second Edition . . . . . . . . . . . . . . . . . . . . . . . . .  xxiii
1 Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.1 Example Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51.2 Notation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

1.3 Relationship to Predefined Classes and Interfaces . . . . . . . . . . . . . . . . . . . . 61.4 References  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

2 Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.1 Context-Free Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92.2 The Lexical Grammar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.3 The Syntactic Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102.4 Grammar Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

3 Lexical Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.1 Unicode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133.2 Lexical Translations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.3 Unicode Escapes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143.4 Line Terminators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.5 Input Elements and Tokens. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163.6 White Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.7 Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183.8 Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.9 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203.10 Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.10.1 Integer Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213.10.2 Floating-Point Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.10.3 Boolean Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253.10.4 Character Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.10.5 String Literals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273.10.6 Escape Sequences for Character and String Literals . . . . . . . . . . 28
3.10.7 The Null Literal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

TABLE OF CONTENTS
viii

3.11 Separators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293.12 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4 Types, Values, and Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  31

4.1 The Kinds of Types and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324.2 Primitive Types and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

4.2.1 Integral Types and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334.2.2 Integer Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.2.3 Floating-Point Types, Formats, and Values. . . . . . . . . . . . . . . . . . 354.2.4 Floating-Point Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.2.5 The boolean Type and boolean Values. . . . . . . . . . . . . . . . . . . . 404.3 Reference Types and Values  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.3.1 Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424.3.2 The Class

Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 444.3.3 The Class
String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454.3.4 When Reference Types Are the Same . . . . . . . . . . . . . . . . . . . . . . 45

4.4 Where Types Are Used  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464.5 Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

4.5.1 Variables of Primitive Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484.5.2 Variables of Reference Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
4.5.3 Kinds of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484.5.4

final Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504.5.5 Initial Values of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

4.5.6 Types, Classes, and Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

5 Conversions and Promotions  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55

5.1 Kinds of Conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585.1.1 Identity Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

5.1.2 Widening Primitive Conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . 585.1.3 Narrowing Primitive Conversions . . . . . . . . . . . . . . . . . . . . . . . . . 59
5.1.4 Widening Reference Conversions . . . . . . . . . . . . . . . . . . . . . . . . . 625.1.5 Narrowing Reference Conversions . . . . . . . . . . . . . . . . . . . . . . . . 63
5.1.6 String Conversions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645.1.7 Forbidden Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.1.8 Value Set Conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 655.2 Assignment Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5.3 Method Invocation Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 715.4 String Conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
5.5 Casting Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 725.6 Numeric Promotions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

5.6.1 Unary Numeric Promotion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785.6.2 Binary Numeric Promotion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

6 Names  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  81

6.1 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

TABLE OF CONTENTS

ix
6.2 Names and Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 836.3 Scope of a Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

6.3.1 Shadowing Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 866.3.2 Obscured Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.4 Members and Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 896.4.1 The Members of a Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.4.2 The Members of a Class Type . . . . . . . . . . . . . . . . . . . . . . . . . . . 906.4.3 The Members of an Interface Type  . . . . . . . . . . . . . . . . . . . . . . . 91
6.4.4 The Members of an Array Type . . . . . . . . . . . . . . . . . . . . . . . . . . 926.5 Determining the Meaning of a Name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
6.5.1 Syntactic Classification of a Name According to Context. . . . . . 946.5.2 Reclassification of Contextually Ambiguous Names. . . . . . . . . . 96
6.5.3 Meaning of Package Names. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 986.5.3.1 Simple Package Names  . . . . . . . . . . . . . . . . . . . . . . . 98

6.5.3.2 Qualified Package Names. . . . . . . . . . . . . . . . . . . . . . 986.5.4 Meaning of PackageOrTypeNames  . . . . . . . . . . . . . . . . . . . . . . . 98
6.5.4.1 Simple PackageOrTypeNames . . . . . . . . . . . . . . . . . . 986.5.4.2 Qualified PackageOrTypeNames  . . . . . . . . . . . . . . . . 99
6.5.5 Meaning of Type Names  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 996.5.5.1 Simple Type Names . . . . . . . . . . . . . . . . . . . . . . . . . . 99

6.5.5.2 Qualified Type Names  . . . . . . . . . . . . . . . . . . . . . . . 1006.5.6 Meaning of Expression Names  . . . . . . . . . . . . . . . . . . . . . . . . . 100
6.5.6.1 Simple Expression Names . . . . . . . . . . . . . . . . . . . . 1016.5.6.2 Qualified Expression Names  . . . . . . . . . . . . . . . . . . 102
6.5.7 Meaning of Method Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1046.5.7.1 Simple Method Names . . . . . . . . . . . . . . . . . . . . . . . 104

6.5.7.2 Qualified Method Names . . . . . . . . . . . . . . . . . . . . . 1046.6 Access Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
6.6.1 Determining Accessibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1056.6.2 Details on

protected Access . . . . . . . . . . . . . . . . . . . . . . . . . . 1056.6.2.1 Access to a

protected Member . . . . . . . . . . . . . . . 1066.6.2.2 Qualified Access to a

protected Constructor. . . . . 1066.6.3 An Example of Access Control . . . . . . . . . . . . . . . . . . . . . . . . . 106

6.6.4 Example: Access to public and Non-public Classes . . . . . . . 1076.6.5 Example: Default-Access Fields, Methods, and Constructors. . 108
6.6.6 Example: public Fields, Methods, and Constructors . . . . . . . . 1096.6.7 Example:

protected Fields, Methods, and Constructors . . . . . 1106.6.8 Example:
private Fields, Methods, and Constructors . . . . . . . 1116.7 Fully Qualified Names and Canonical Names . . . . . . . . . . . . . . . . . . . . . 111

6.8 Naming Conventions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1136.8.1 Package Names  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

6.8.2 Class and Interface Type Names  . . . . . . . . . . . . . . . . . . . . . . . . 1146.8.3 Method Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.8.4 Field Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1156.8.5 Constant Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
6.8.6 Local Variable and Parameter Names  . . . . . . . . . . . . . . . . . . . . 116

TABLE OF CONTENTS
x

7 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  119

7.1 Package Members  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1197.2 Host Support for Packages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120

7.2.1 Storing Packages in a File System  . . . . . . . . . . . . . . . . . . . . . . . 1217.2.2 Storing Packages in a Database. . . . . . . . . . . . . . . . . . . . . . . . . . 122
7.3 Compilation Units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1237.4 Package Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

7.4.1 Named Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1247.4.2 Unnamed Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
7.4.3 Observability of a Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1257.4.4 Scope of a Package Declaration  . . . . . . . . . . . . . . . . . . . . . . . . . 125
7.5 Import Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1257.5.1 Single-Type-Import Declaration . . . . . . . . . . . . . . . . . . . . . . . . . 126

7.5.2 Type-Import-on-Demand Declaration . . . . . . . . . . . . . . . . . . . . . 1277.5.3 Automatic Imports. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
7.5.4 A Strange Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1287.6 Top Level Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
7.7 Unique Package Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

8 Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  135

8.1 Class Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1368.1.1 Class Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

8.1.1.1 abstract Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . 1378.1.1.2

final Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1398.1.1.3
strictfp Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . 1398.1.2 Inner Classes and Enclosing Instances . . . . . . . . . . . . . . . . . . . . 140

8.1.3 Superclasses and Subclasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1428.1.4 Superinterfaces  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
8.1.5 Class Body and Member Declarations  . . . . . . . . . . . . . . . . . . . . 1478.2 Class Members. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
8.2.1 Examples of Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1498.2.1.1 Example: Inheritance with Default Access . . . . . . . . 149

8.2.1.2 Inheritance with public and protected. . . . . . . . . 1508.2.1.3 Inheritance with

private . . . . . . . . . . . . . . . . . . . . . 1518.2.1.4 Accessing Members of Inaccessible Classes. . . . . . . 151

8.3 Field Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1538.3.1 Field Modifiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154

8.3.1.1 static Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1558.3.1.2

final Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1568.3.1.3
transient Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . 1568.3.1.4
volatile Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1568.3.2 Initialization of Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

8.3.2.1 Initializers for Class Variables . . . . . . . . . . . . . . . . . . 1598.3.2.2 Initializers for Instance Variables  . . . . . . . . . . . . . . . 159
8.3.2.3 Restrictions on the use of Fields during Initialization1608.3.3 Examples of Field Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . 162
8.3.3.1 Example: Hiding of Class Variables  . . . . . . . . . . . . . 162

TABLE OF CONTENTS

xi
8.3.3.2 Example: Hiding of Instance Variables  . . . . . . . . . . 1638.3.3.3 Example: Multiply Inherited Fields . . . . . . . . . . . . . 165
8.3.3.4 Example: Re-inheritance of Fields . . . . . . . . . . . . . . 1668.4 Method Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
8.4.1 Formal Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1688.4.2 Method Signature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.4.3 Method Modifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1698.4.3.1

abstract Methods. . . . . . . . . . . . . . . . . . . . . . . . . . 1708.4.3.2
static Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . 1718.4.3.3
final Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1728.4.3.4
native Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . 1738.4.3.5
strictfp Methods. . . . . . . . . . . . . . . . . . . . . . . . . . 1738.4.3.6
synchronized Methods. . . . . . . . . . . . . . . . . . . . . . 1748.4.4 Method Throws  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175

8.4.5 Method Body . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1768.4.6 Inheritance, Overriding, and Hiding  . . . . . . . . . . . . . . . . . . . . . 177

8.4.6.1 Overriding (by Instance Methods) . . . . . . . . . . . . . . 1778.4.6.2 Hiding (by Class Methods). . . . . . . . . . . . . . . . . . . . 178
8.4.6.3 Requirements in Overriding and Hiding  . . . . . . . . . 1788.4.6.4 Inheriting Methods with the Same Signature . . . . . . 179
8.4.7 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1808.4.8 Examples of Method Declarations . . . . . . . . . . . . . . . . . . . . . . . 180

8.4.8.1 Example: Overriding  . . . . . . . . . . . . . . . . . . . . . . . . 1808.4.8.2 Example: Overloading, Overriding, and Hiding  . . . 181
8.4.8.3 Example: Incorrect Overriding. . . . . . . . . . . . . . . . . 1818.4.8.4 Example: Overriding versus Hiding . . . . . . . . . . . . . 182
8.4.8.5 Example: Invocation of Hidden Class Methods . . . . 1848.4.8.6 Large Example of Overriding. . . . . . . . . . . . . . . . . . 185
8.4.8.7 Example: Incorrect Overriding because of Throws . 1868.5 Member Type Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.5.1 Access Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1888.5.2 Static Member Type Declarations . . . . . . . . . . . . . . . . . . . . . . . 188
8.6 Instance Initializers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1888.7 Static Initializers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
8.8 Constructor Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1908.8.1 Formal Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191

8.8.2 Constructor Signature  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1918.8.3 Constructor Modifiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
8.8.4 Constructor Throws . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1928.8.5 Constructor Body . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192

8.8.5.1 Explicit Constructor Invocations  . . . . . . . . . . . . . . . 1938.8.6 Constructor Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.8.7 Default Constructor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1958.8.8 Preventing Instantiation of a Class. . . . . . . . . . . . . . . . . . . . . . . 197

9 Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199

9.1 Interface Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2009.1.1 Interface Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

TABLE OF CONTENTS
xii

9.1.1.1 abstract Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . 2009.1.1.2

strictfp Interfaces  . . . . . . . . . . . . . . . . . . . . . . . . . 2009.1.2 Superinterfaces and Subinterfaces. . . . . . . . . . . . . . . . . . . . . . . . 201

9.1.3 Interface Body and Member Declarations. . . . . . . . . . . . . . . . . . 2029.1.4 Access to Interface Member Names . . . . . . . . . . . . . . . . . . . . . . 202
9.2 Interface Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2029.3 Field (Constant) Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203

9.3.1 Initialization of Fields in Interfaces. . . . . . . . . . . . . . . . . . . . . . . 2049.3.2 Examples of Field Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . 204

9.3.2.1 Ambiguous Inherited Fields  . . . . . . . . . . . . . . . . . . . 2049.3.2.2 Multiply Inherited Fields . . . . . . . . . . . . . . . . . . . . . . 205
9.4 Abstract Method Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2059.4.1 Inheritance and Overriding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206

9.4.2 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2079.4.3 Examples of Abstract Method Declarations . . . . . . . . . . . . . . . . 207

9.4.3.1 Example: Overriding . . . . . . . . . . . . . . . . . . . . . . . . . 2079.4.3.2 Example: Overloading . . . . . . . . . . . . . . . . . . . . . . . . 208
9.5 Member Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208

10 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  209

10.1 Array Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21010.2 Array Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210

10.3 Array Creation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21110.4 Array Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
10.5 Arrays: A Simple Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21210.6 Array Initializers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
10.7 Array Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21310.8

Class Objects for Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21510.9 An Array of Characters is Not a

String . . . . . . . . . . . . . . . . . . . . . . . . . . 21510.10 Array Store Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

11 Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  219

11.1 The Causes of Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22011.2 Compile-Time Checking of Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . 221

11.2.1 Why Errors are Not Checked  . . . . . . . . . . . . . . . . . . . . . . . . . . . 22111.2.2 Why Runtime Exceptions are Not Checked . . . . . . . . . . . . . . . . 222
11.3 Handling of an Exception  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22211.3.1 Exceptions are Precise. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223

11.3.2 Handling Asynchronous Exceptions . . . . . . . . . . . . . . . . . . . . . . 22411.4 An Example of Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
11.5 The Exception Hierarchy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22611.5.1 Loading and Linkage Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227

11.5.2 Virtual Machine Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227

12 Execution  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  229

12.1 Virtual Machine Start-Up  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229

TABLE OF CONTENTS

xiii
12.1.1 Load the Class Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23012.1.2 Link

Test: Verify, Prepare, (Optionally) Resolve . . . . . . . . . . . 23012.1.3 Initialize

Test: Execute Initializers . . . . . . . . . . . . . . . . . . . . . . 23112.1.4 Invoke
Test.main . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23212.2 Loading of Classes and Interfaces  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232

12.2.1 The Loading Process  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23312.3 Linking of Classes and Interfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
12.3.1 Verification of the Binary Representation . . . . . . . . . . . . . . . . . 23412.3.2 Preparation of a Class or Interface Type  . . . . . . . . . . . . . . . . . . 234
12.3.3 Resolution of Symbolic References . . . . . . . . . . . . . . . . . . . . . . 23512.4 Initialization of Classes and Interfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . 236
12.4.1 When Initialization Occurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23612.4.2 Detailed Initialization Procedure . . . . . . . . . . . . . . . . . . . . . . . . 239
12.4.3 Initialization: Implications for Code Generation . . . . . . . . . . . . 24112.5 Creation of New Class Instances  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
12.6 Finalization of Class Instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24512.6.1 Implementing Finalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246

12.6.2 Finalizer Invocations are Not Ordered . . . . . . . . . . . . . . . . . . . . 24712.7 Unloading of Classes and Interfaces  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
12.8 Program Exit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249

13 Binary Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251

13.1 The Form of a Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25213.2 What Binary Compatibility Is and Is Not. . . . . . . . . . . . . . . . . . . . . . . . . 256

13.3 Evolution of Packages  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25713.4 Evolution of Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257

13.4.1 abstract Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25713.4.2

final Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25813.4.3
public Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25813.4.4 Superclasses and Superinterfaces. . . . . . . . . . . . . . . . . . . . . . . . 258

13.4.5 Class Body and Member Declarations. . . . . . . . . . . . . . . . . . . . 25913.4.6 Access to Members and Constructors  . . . . . . . . . . . . . . . . . . . . 261
13.4.7 Field Declarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26213.4.8

final Fields and Constants. . . . . . . . . . . . . . . . . . . . . . . . . . . . 26413.4.9
static Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26613.4.10
transient Fields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26613.4.11 Method and Constructor Declarations . . . . . . . . . . . . . . . . . . . . 267

13.4.12 Method and Constructor Parameters . . . . . . . . . . . . . . . . . . . . . 26713.4.13 Method Result Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
13.4.14 abstract Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26813.4.15

final Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26813.4.16
native Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26913.4.17
static Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26913.4.18
synchronized Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27013.4.19 Method and Constructor Throws . . . . . . . . . . . . . . . . . . . . . . . . 270

13.4.20 Method and Constructor Body . . . . . . . . . . . . . . . . . . . . . . . . . . 27013.4.21 Method and Constructor Overloading . . . . . . . . . . . . . . . . . . . . 270
13.4.22 Method Overriding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271

TABLE OF CONTENTS
xiv

13.4.23 Static Initializers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27113.5 Evolution of Interfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
13.5.1 public Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27213.5.2 Superinterfaces  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
13.5.3 The Interface Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27213.5.4 Field Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
13.5.5 Abstract Method Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . 273

14 Blocks and Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  275

14.1 Normal and Abrupt Completion of Statements . . . . . . . . . . . . . . . . . . . . . 27614.2 Blocks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277

14.3 Local Class Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27714.4 Local Variable Declaration Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . 279

14.4.1 Local Variable Declarators and Types. . . . . . . . . . . . . . . . . . . . . 27914.4.2 Scope of Local Variable Declarations . . . . . . . . . . . . . . . . . . . . . 280
14.4.3 Shadowing of Names by Local Variables . . . . . . . . . . . . . . . . . . 28314.4.4 Execution of Local Variable Declarations. . . . . . . . . . . . . . . . . . 283
14.5 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28414.6 The Empty Statement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
14.7 Labeled Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28614.8 Expression Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
14.9 The if Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28714.9.1 The

if-then Statement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28814.9.2 The
if-then-else Statement  . . . . . . . . . . . . . . . . . . . . . . . . . . 28814.10 The
switch Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28814.11 The
while Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29214.11.1 Abrupt Completion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292

14.12 The do Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29314.12.1 Abrupt Completion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294

14.12.2 Example of do statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29414.13 The

for Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29514.13.1 Initialization of

for statement. . . . . . . . . . . . . . . . . . . . . . . . . . . 29514.13.2 Iteration of
for statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29614.13.3 Abrupt Completion of

for statement . . . . . . . . . . . . . . . . . . . . . 29714.14 The
break Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29714.15 The
continue Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29914.16 The
return Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30114.17 The
throw Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30214.18 The
synchronized Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30414.19 The
try statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30514.19.1 Execution of

try-catch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30714.19.2 Execution of
try-catch-finally. . . . . . . . . . . . . . . . . . . . . . . 30814.20 Unreachable Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310

15 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  317

15.1 Evaluation, Denotation, and Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31715.2 Variables as Values  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318

TABLE OF CONTENTS

xv
15.3 Type of an Expression  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31815.4 FP-strict Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
15.5 Expressions and Run-Time Checks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31915.6 Normal and Abrupt Completion of Evaluation  . . . . . . . . . . . . . . . . . . . . 320
15.7 Evaluation Order. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32215.7.1 Evaluate Left-Hand Operand First . . . . . . . . . . . . . . . . . . . . . . . 322

15.7.2 Evaluate Operands before Operation . . . . . . . . . . . . . . . . . . . . . 32415.7.3 Evaluation Respects Parentheses and Precedence . . . . . . . . . . . 325
15.7.4 Argument Lists are Evaluated Left-to-Right . . . . . . . . . . . . . . . 32615.7.5 Evaluation Order for Other Expressions  . . . . . . . . . . . . . . . . . . 327
15.8 Primary Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32715.8.1 Lexical Literals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328

15.8.2 Class Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32815.8.3

this . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32815.8.4 Qualified

this . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32915.8.5 Parenthesized Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330

15.9 Class Instance Creation Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33015.9.1 Determining the Class being Instantiated  . . . . . . . . . . . . . . . . . 331

15.9.2 Determining Enclosing Instances. . . . . . . . . . . . . . . . . . . . . . . . 33215.9.3 Choosing the Constructor and its Arguments  . . . . . . . . . . . . . . 334
15.9.4 Run-time Evaluation of Class Instance Creation Expressions . . 33415.9.5 Anonymous Class Declarations . . . . . . . . . . . . . . . . . . . . . . . . . 335

15.9.5.1 Anonymous Constructors . . . . . . . . . . . . . . . . . . . . . 33515.9.6 Example: Evaluation Order and Out-of-Memory Detection . . . 336
15.10 Array Creation Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33715.10.1 Run-time Evaluation of Array Creation Expressions. . . . . . . . . 338

15.10.2 Example: Array Creation Evaluation Order. . . . . . . . . . . . . . . . 33915.10.3 Example: Array Creation and Out-of-Memory Detection . . . . . 340
15.11 Field Access Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34115.11.1 Field Access Using a Primary  . . . . . . . . . . . . . . . . . . . . . . . . . . 342

15.11.2 Accessing Superclass Members using super  . . . . . . . . . . . . . . 34415.12 Method Invocation Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
15.12.1 Compile-Time Step 1: Determine Class or Interface to Search . 34615.12.2 Compile-Time Step 2: Determine Method Signature  . . . . . . . . 347

15.12.2.1 Find Methods that are Applicable and Accessible . . 34715.12.2.2 Choose the Most Specific Method . . . . . . . . . . . . . . 349
15.12.2.3 Example: Overloading Ambiguity . . . . . . . . . . . . . . 35015.12.2.4 Example: Return Type Not Considered . . . . . . . . . . 351
15.12.2.5 Example: Compile-Time Resolution  . . . . . . . . . . . . 35215.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate? . . . 354
15.12.4 Runtime Evaluation of Method Invocation  . . . . . . . . . . . . . . . . 35615.12.4.1 Compute Target Reference (If Necessary) . . . . . . . . 356

15.12.4.2 Evaluate Arguments . . . . . . . . . . . . . . . . . . . . . . . . . 35715.12.4.3 Check Accessibility of Type and Method. . . . . . . . . 357
15.12.4.4 Locate Method to Invoke . . . . . . . . . . . . . . . . . . . . . 35815.12.4.5 Create Frame, Synchronize, Transfer Control . . . . . 359
15.12.4.6 Example: Target Reference and Static Methods. . . . 36015.12.4.7 Example: Evaluation Order  . . . . . . . . . . . . . . . . . . . 361

TABLE OF CONTENTS
xvi

15.12.4.8 Example: Overriding . . . . . . . . . . . . . . . . . . . . . . . . . 36115.12.4.9 Example: Method Invocation using super . . . . . . . . . 363
15.13 Array Access Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36415.13.1 Runtime Evaluation of Array Access . . . . . . . . . . . . . . . . . . . . . 364

15.13.2 Examples: Array Access Evaluation Order. . . . . . . . . . . . . . . . . 36515.14 Postfix Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
15.14.1 Postfix Increment Operator ++  . . . . . . . . . . . . . . . . . . . . . . . . . . 36715.14.2 Postfix Decrement Operator

-- . . . . . . . . . . . . . . . . . . . . . . . . . . 36815.15 Unary Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368

15.15.1 Prefix Increment Operator ++ . . . . . . . . . . . . . . . . . . . . . . . . . . . 36915.15.2 Prefix Decrement Operator

--  . . . . . . . . . . . . . . . . . . . . . . . . . . 36915.15.3 Unary Plus Operator
+. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37015.15.4 Unary Minus Operator

- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37015.15.5 Bitwise Complement Operator

~. . . . . . . . . . . . . . . . . . . . . . . . . 37115.15.6 Logical Complement Operator
!. . . . . . . . . . . . . . . . . . . . . . . . . 37115.16 Cast Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372

15.17 Multiplicative Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37315.17.1 Multiplication Operator

* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37315.17.2 Division Operator
/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37415.17.3 Remainder Operator

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37615.18 Additive Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377

15.18.1 String Concatenation Operator +. . . . . . . . . . . . . . . . . . . . . . . . . 37815.18.1.1 String Conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . 378

15.18.1.2 Optimization of String Concatenation . . . . . . . . . . . . 37915.18.1.3 Examples of String Concatenation  . . . . . . . . . . . . . . 379
15.18.2 Additive Operators (+ and -) for Numeric Types . . . . . . . . . . . . 38115.19 Shift Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
15.20 Relational Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38415.20.1 Numerical Comparison Operators

<, <=, >, and >=. . . . . . . . . . . 38415.20.2 Type Comparison Operator
instanceof . . . . . . . . . . . . . . . . . . 38515.21 Equality Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386

15.21.1 Numerical Equality Operators == and != . . . . . . . . . . . . . . . . . . 38715.21.2 Boolean Equality Operators

== and !=. . . . . . . . . . . . . . . . . . . . 38815.21.3 Reference Equality Operators

== and != . . . . . . . . . . . . . . . . . . 38815.22 Bitwise and Logical Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388

15.22.1 Integer Bitwise Operators &, ^, and | . . . . . . . . . . . . . . . . . . . . . 38915.22.2 Boolean Logical Operators

&, ^, and | . . . . . . . . . . . . . . . . . . . . 38915.23 Conditional-And Operator
&& . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39015.24 Conditional-Or Operator
||. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39015.25 Conditional Operator
? :  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39115.26 Assignment Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392

15.26.1 Simple Assignment Operator = . . . . . . . . . . . . . . . . . . . . . . . . . . 39315.26.2 Compound Assignment Operators  . . . . . . . . . . . . . . . . . . . . . . . 398
15.27 Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40515.28 Constant Expression  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405

16 Definite Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  407

16.1 Definite Assignment and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412

TABLE OF CONTENTS

xvii
16.1.1 Boolean Constant Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . 41216.1.2 The Boolean Operator

&&. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41316.1.3 The Boolean Operator
||. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41316.1.4 The Boolean Operator
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41416.1.5 The Boolean Operator
? : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41416.1.6 The Conditional Operator

? : . . . . . . . . . . . . . . . . . . . . . . . . . . 41416.1.7 Assignment Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415

16.1.8 Operators ++ and -- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41616.1.9 Other Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
16.2 Definite Assignment and Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41716.2.1 Empty Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418

16.2.2 Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41816.2.3 Local Class Declaration Statements. . . . . . . . . . . . . . . . . . . . . . 418
16.2.4 Local Variable Declaration Statements  . . . . . . . . . . . . . . . . . . . 41916.2.5 Labeled Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
16.2.6 Expression Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41916.2.7

if Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42016.2.8
switch Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42016.2.9
while Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42116.2.10
do Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42116.2.11
for Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42216.2.11.1 Initialization Part  . . . . . . . . . . . . . . . . . . . . . . . . . . . 423

16.2.11.2 Incrementation Part. . . . . . . . . . . . . . . . . . . . . . . . . . 42316.2.12
break, continue, return, and throw Statements. . . . . . . . . . 42316.2.13
synchronized Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42416.2.14
try Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42416.3 Definite Assignment and Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425

16.4 Definite Assignment and Array Initializers . . . . . . . . . . . . . . . . . . . . . . . 42516.5 Definite Assignment and Anonymous Classes. . . . . . . . . . . . . . . . . . . . . 426
16.6 Definite Assignment and Member Types . . . . . . . . . . . . . . . . . . . . . . . . . 42616.7 Definite Assignment and Static Initializers  . . . . . . . . . . . . . . . . . . . . . . . 426
16.8 Definite Assignment, Constructors, and Instance Initializers  . . . . . . . . . 427

17 Threads and Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429

17.1 Terminology and Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43117.2 Execution Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433

17.3 Rules about Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43417.4 Nonatomic Treatment of

double and long . . . . . . . . . . . . . . . . . . . . . . . 43517.5 Rules about Locks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436

17.6 Rules about the Interaction of Locks and Variables . . . . . . . . . . . . . . . . . 43617.7 Rules for Volatile Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
17.8 Prescient Store Actions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43817.9 Discussion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
17.10 Example: Possible Swap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43917.11 Example: Out-of-Order Writes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
17.12 Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44517.13 Locks and Synchronization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
17.14 Wait Sets and Notification  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446

TABLE OF CONTENTS
xviii

18  Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  449

18.1 The Grammar of the Java Programming Language. . . . . . . . . . . . . . . . . . 449

Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  457
Credits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  503
Colophon  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  505

xix

Preface
THE Java(TM) programming language was originally called Oak, and was designedfor use in embedded consumer-electronic applications by James Gosling. After
several years of experience with the language, and significant contributions by EdFrank, Patrick Naughton, Jonathan Payne, and Chris Warth it was retargeted to the
Internet, renamed, and substantially revised to be the language specified here. Thefinal form of the language was defined by James Gosling, Bill Joy, Guy Steele,
Richard Tuck, Frank Yellin, and Arthur van Hoff, with help from Graham Hamil-ton, Tim Lindholm, and many other friends and colleagues.

The Java programming language is a general-purpose concurrent class-basedobject-oriented programming language, specifically designed to have as few
implementation dependencies as possible. It allows application developers towrite a program once and then be able to run it everywhere on the Internet.

This book attempts a complete specification of the syntax and semantics ofthe language. We intend that the behavior of every language construct is specified
here, so that all implementations will accept the same programs. Except for timingdependencies or other non-determinisms and given sufficient time and sufficient
memory space, a program written in the Java programming language should com-pute the same result on all machines and in all implementations.

We believe that the Java programming language is a mature language, readyfor widespread use. Nevertheless, we expect some evolution of the language in the
years to come. We intend to manage this evolution in a way that is completelycompatible with existing applications. To do this, we intend to make relatively few
new versions of the language, and to distinguish each new version with a differentfilename extension. Compilers and systems will be able to support the several versions simultannously, with complete compatibility.Much research and experimentation with the Java platform is already underway. We encourage this work, and will continue to cooperate with external groupsto explore improvements to the language and platform. For example, we have
already received several interesting proposals for parameterized types. In techni-cally difficult areas, near the state of the art, this kind of research collaboration is
essential.

PREFACE
xx

We acknowledge and thank the many people who have contributed to thisbook through their excellent feedback, assistance and encouragement:
Particularly thorough, careful, and thoughtful reviews of drafts were providedby Tom Cargill, Peter Deutsch, Paul Hilfinger, Masayuki Ida, David Moon, Steven
Muchnick, Charles L. Perkins, Chris Van Wyk, Steve Vinoski, Philip Wadler,Daniel Weinreb, and Kenneth Zadeck. We are very grateful for their extraordinary
volunteer efforts.We are also grateful for reviews, questions, comments, and suggestions from
Stephen Adams, Bowen Alpern, Glenn Ammons, Leonid Arbuzov, Kim Bruce,Edwin Chan, David Chase, Pavel Curtis, Drew Dean, William Dietz, David Dill,
Patrick Dussud, Ed Felten, John Giannandrea, John Gilmore, Charles Gust,Warren Harris, Lee Hasiuk, Mike Hendrickson, Mark Hill, Urs Hoelzle, Roger
Hoover, Susan Flynn Hummel, Christopher Jang, Mick Jordan, Mukesh Kacker,Peter Kessler, James Larus, Derek Lieber, Bill McKeeman, Steve Naroff,
Evi Nemeth, Robert O'Callahan, Dave Papay, Craig Partridge, Scott Pfeffer,Eric Raymond, Jim Roskind, Jim Russell, William Scherlis, Edith Schonberg,
Anthony Scian, Matthew Self, Janice Shepherd, Kathy Stark, Barbara Steele, RobStrom, William Waite, Greg Weeks, and Bob Wilson. (This list was generated
semi-automatically from our E-mail records. We apologize if we have omittedanyone.)

The feedback from all these reviewers was invaluable to us in improving thedefinition of the language as well as the form of the presentation in this book. We
thank them for their diligence. Any remaining errors in this book--we hope theyare few--are our responsibility and not theirs.

We thank Francesca Freedman and Doug Kramer for assistance with mattersof typography and layout. We thank Dan Mills of Adobe Systems Incorporated for
assistance in exploring possible choices of typefaces.Many of our colleagues at Sun Microsystems have helped us in one way or
another. Lisa Friendly, our series editor, managed our relationship with Addison-Wesley. Susan Stambaugh managed the distribution of many hundreds of copies
of drafts to reviewers. We received valuable assistance and technical advice fromBen Adida, Ole Agesen, Ken Arnold, Rick Cattell, Asmus Freytag, Norm Hardy,
Steve Heller, David Hough, Doug Kramer, Nancy Lee, Marianne Mueller, AkiraTanaka, Greg Tarsy, David Ungar, Jim Waldo, Ann Wollrath, Geoff Wyant, and
Derek White. We thank Alan Baratz, David Bowen, Mike Clary, John Doerr, JonKannegaard, Eric Schmidt, Bob Sproull, Bert Sutherland, and Scott McNealy for
leadership and encouragement.The on-line Bartleby Library of Columbia University, at URL:

http://www.cc.columbia.edu/acis/bartleby/

PREFACE

xxi
was invaluable to us during the process of researching and verifying many of thequotations that are scattered throughout this book. Here is one example:

They lard their lean books with the fat of others' works.

--Robert Burton (1576-1640)

We are grateful to those who have toiled on Project Bartleby, for saving us a greatdeal of effort and reawakening our appreciation for the works of Walt Whitman.

We are thankful for the tools and services we had at our disposal in writingthis book: telephones, overnight delivery, desktop workstations, laser printers,
photocopiers, text formatting and page layout software, fonts, electronic mail, theWorld Wide Web, and, of course, the Internet. We live in three different states,
scattered across a continent, but collaboration with each other and with ourreviewers has seemed almost effortless. Kudos to the thousands of people who
have worked over the years to make these excellent tools and services workquickly and reliably.

Mike Hendrickson, Katie Duffy, Simone Payment, and Rosa Aime'e Gonza'lezof Addison-Wesley were very helpful, encouraging, and patient during the long
process of bringing this book to print. We also thank the copy editors.Rosemary Simpson worked hard, on a very tight schedule, to create the index.
We got into the act at the last minute, however; blame us and not her for any jokesyou may find hidden therein.

Finally, we are grateful to our families and friends for their love and supportduring this last, crazy, year.

In their book The C Programming Language, Brian Kernighan and DennisRitchie said that they felt that the C language "wears well as one's experience with
it grows." If you like C, we think you will like the Java programming language.We hope that it, too, wears well for you.

James GoslingCupertino, California
Bill JoyAspen, Colorado
Guy SteeleChelmsford, Massachusetts
July, 1996

xxiii

Preface to the Second Edition
OVER the past few years, the Java(TM) programming language has enjoyedunprecedented success. This success has brought a challenge: along with explosive growth in popularity, there has been explosive growth in the demands madeon the language and its libraries. To meet this challenge, the language has grown
as well (fortunately, not explosively) and so have the libraries.This second edition of The Java

(TM) Language Specification reflects these developments. It integrates all the changes made to the Java programming languagesince the publication of the first edition in 1996. The bulk of these changes were

made in the 1.1 release of the Java platform in 1997, and revolve around the addi-tion of nested type declarations. Later modifications pertained to floating-point
operations. In addition, this edition incorporates important clarifications andamendments involving method lookup and binary compatibility.

This specification defines the language as it exists today. The Java program-ming language is likely to continue to evolve. At this writing, there are ongoing
initiatives through the Java Community Process to extend the language withgeneric types and assertions, refine the memory model, etc. However, it would be
inappropriate to delay the publication of the second edition until these efforts areconcluded.

The specifications of the libraries are now far too large to fit into this volume,and they continue to evolve. Consequently, API specifications have been removed
from this book. The library specifications can be found on the java.sun.comWeb site (see below); this specification now concentrates solely on the Java programming language proper.Readers may send comments on this specification to:

jls@java.sun.com. Tolearn the latest about the Java 2 platform, or to download the latest Java 2 SDK

PREFACE TO THE SECOND EDITION
xxiv

release, visit http://java.sun.com. Updated information about the Java Series,including errata for The Java

(TM) Language Specification, Second Edition, and pre-views of forthcoming books, may be found at

http://java.sun.com/Series.Many people contributed to this book, directly and indirectly. Tim Lindholm

brought extraordinary dedication to his role as technical editor. He also madeinvaluable technical contributions, especially on floating-point issues. The book
would likely not see the light of day without him. Lisa Friendly, the Series editor,provided encouragement and advice for which I am very thankful.

David Bowen first suggested that I get involved in the specifications of theJava platform. I am grateful to him for introducing me to this uncommonly rich
area.John Rose, the father of nested types in the Java programming language, has
been unfailingly gracious and supportive of my attempts to specify them accu-rately.

Many people have provided valuable comments on this edition. Specialthanks go to Roly Perera at Ergnosis and to Leonid Arbouzov and his colleagues
on Sun's Java platform conformance team in Novosibirsk: Konstantin Bobrovsky,Natalia Golovleva, Vladimir Ivanov, Alexei Kaigorodov, Serguei Katkov, Dmitri
Khukhro, Eugene Latkin, Ilya Neverov, Pavel Ozhdikhin, Igor Pyankov,Viatcheslav Rybalov, Serguei Samoilidi, Maxim Sokolnikov, and Vitaly Tchaiko.
Their thorough reading of earlier drafts has greatly improved the accuracy of thisspecification.

I am indebted to Martin Odersky and to Andrew Bennett and the members ofSun's

javac compiler team, past and present: Iris Garcia, Bill Maddox, DavidStoutamire, and Todd Turnidge. They all worked hard to make sure the reference

implementation conformed to the specification. For many enjoyable technicalexchanges, I thank them and my other colleagues at Sun: Lars Bak, Joshua Bloch,
Cliff Click, Robert Field, Mohammad Gharahgouzloo, Ben Gomes, SteffenGrarup, Robert Griesemer, Graham Hamilton, Gordon Hirsch, Peter Kessler,
Sheng Liang, James McIlree, Philip Milne, Srdjan Mitrovic, Anand Palaniswamy,Mike Paleczny, Mark Reinhold, Kenneth Russell, Rene Schmidt, David Ungar,
Chris Vick, and Hong Zhang.Tricia Jordan, my manager, has been a model of patience, consideration and
understanding. Thanks are also due to Larry Abrahams, director of Java 2 Stan-dard Edition, for supporting this work.

The following individuals all provided useful comments that have contributedto this specification: Godmar Bak, Hans Boehm, Philippe Charles, David Chase,
Joe Darcy, Jim des Rivieres, Sophia Drossopoulou, Susan Eisenbach, Paul Haahr,Urs Hoelzle, Bart Jacobs, Kent Johnson, Mark Lillibridge, Norbert Lindenberg,
Phillipe Mulet, Kelly O'Hair, Bill Pugh, Cameron Purdy, Anthony Scian, JaniceShepherd, David Shields, John Spicer, Lee Worall, and David Wragg.

PREFACE TO THE SECOND EDITION

xxv
Suzette Pelouch provided invaluable assistance with the index and, togetherwith Doug Kramer and Atul Dambalkar, assisted with FrameMaker expertise;
Mike Hendrickson and Julie Dinicola at Addison-Wesley were gracious, helpfuland ultimately made this book a reality.

On a personal note, I thank my wife Weihong for her love and support.Finally, I'd like to thank my coauthors, James Gosling, Bill Joy, and Guy
Steele for inviting me to participate in this work. It has been a pleasure and a priv-ilege.

Gilad BrachaLos Altos, California
April, 2000

1DRAFT

C H A P T E R 1
Introduction

1.0
The Java(TM) programming language is a general-purpose, concurrent, class-based,object-oriented language. It is designed to be simple enough that many programmers can achieve fluency in the language. The Java programming language isrelated to C and C++ but is organized rather differently, with a number of aspects
of C and C++ omitted and a few ideas from other languages included. It isintended to be a production language, not a research language, and so, as C. A. R.
Hoare suggested in his classic paper on language design, the design has avoidedincluding new and untested features.

The Java programming language is strongly typed. This specification clearlydistinguishes between the compile-time errors that can and must be detected at
compile time, and those that occur at run time. Compile time normally consists oftranslating programs into a machine-independent byte code representation. Runtime activities include loading and linking of the classes needed to execute a pro-gram, optional machine code generation and dynamic optimization of the program, and actual program execution.The Java programming language is a relatively high-level language, in that
details of the machine representation are not available through the language. Itincludes automatic storage management, typically using a garbage collector, to
avoid the safety problems of explicit deallocation (as in C's free or C++'s
delete). High-performance garbage-collected implementations can have bound-ed pauses to support systems programming and real-time applications. The language does not include any unsafe constructs, such as array accesses withoutindex checking, since such unsafe constructs would cause a program to behave in
an unspecified way.The Java programming language is normally compiled to the bytecoded
instruction set and binary format defined in The Java(TM) Virtual Machine Specifica-tion, Second Edition (Addison-Wesley, 1999).

1 Introduction INTRODUCTION
2 DRAFT

This specification is organized as follows:Chapter 2 describes grammars and the notation used to present the lexical and
syntactic grammars for the language.Chapter 3 describes the lexical structure of the Java programming language,
which is based on C and C++. The language is written in the Unicode characterset. It supports the writing of Unicode characters on systems that support only
ASCII.Chapter 4 describes types, values, and variables. Types are subdivided into
primitive types and reference types.The primitive types are defined to be the same on all machines and in all
implementations, and are various sizes of two's-complement integers, single- anddouble-precision IEEE 754 standard floating-point numbers, a

boolean type, anda Unicode character
char type. Values of the primitive types do not share state.Reference types are the class types, the interface types, and the array types.

The reference types are implemented by dynamically created objects that areeither instances of classes or arrays. Many references to each object can exist. All
objects (including arrays) support the methods of the class Object, which is the(single) root of the class hierarchy. A predefined

String class supports Unicodecharacter strings. Classes exist for wrapping primitive values inside of objects.

Variables are typed storage locations. A variable of a primitive type holds avalue of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass ofthat class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of anarray type can hold a null reference or a reference to an array. A variable of class
type Object can hold a null reference or a reference to any object, whether classinstance or array.

Chapter 5 describes conversions and numeric promotions. Conversionschange the compile-time type and, sometimes, the value of an expression.
Numeric promotions are used to convert the operands of a numeric operator to acommon type where an operation can be performed. There are no loopholes in the
language; casts on reference types are checked at run time to ensure type safety.Chapter 6 describes declarations and names, and how to determine what
names mean (denote). The language does not require types or their members to bedeclared before they are used. Declaration order is significant only for local variables, local classes, and the order of initializers of fields in a class or interface.The Java programming language provides control over the scope of names
and supports limitations on external access to members of packages, classes, andinterfaces. This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it. Recommended naming con-ventions that make for more readable programs are described here.

INTRODUCTION Introduction 1

3DRAFT
Chapter 7 describes the structure of a program, which is organized into pack-ages similar to the modules of Modula. The members of a package are classes,
interfaces, and subpackages. Packages are divided into compilation units. Compi-lation units contain type declarations and can import types from other packages to
give them short names. Packages have names in a hierarchical name space, andthe Internet domain name system can usually be used to form unique package
names.Chapter 8 describes classes. The members of classes are classes, interfaces,
fields (variables) and methods. Class variables exist once per class. Class methodsoperate without reference to a specific object. Instance variables are dynamically
created in objects that are instances of classes. Instance methods are invoked oninstances of classes; such instances become the current object

this during theirexecution, supporting the object-oriented programming style.

Classes support single implementation inheritance, in which the implementa-tion of each class is derived from that of a single superclass, and ultimately from
the class Object. Variables of a class type can reference an instance of that classor of any subclass of that class, allowing new types to be used with existing methods, polymorphically.Classes support concurrent programming with

synchronized methods.Methods declare the checked exceptions that can arise from their execution, which

allows compile-time checking to ensure that exceptional conditions are handled.Objects can declare a

finalize method that will be invoked before the objectsare discarded by the garbage collector, allowing the objects to clean up their state.

For simplicity, the language has neither declaration "headers" separate fromthe implementation of a class nor separate type and class hierarchies.
Although the language does not include parameterized classes, the semanticsof arrays are those of a parameterized class with some syntactic sugar. Like the
programming language Beta, the Java programming language uses a run-time typecheck when storing references in arrays to ensure complete type safety.

Chapter 9 describes interface types, which declare a set of abstract methods,member types, and constants. Classes that are otherwise unrelated can implement
the same interface type. A variable of an interface type can contain a reference toany object that implements the interface. Multiple interface inheritance is supported.Chapter 10 describes arrays. Array accesses include bounds checking. Arrays
are dynamically created objects and may be assigned to variables of type Object.The language supports arrays of arrays, rather than multidimensional arrays.

Chapter 11 describes exceptions, which are nonresuming and fully integratedwith the language semantics and concurrency mechanisms. There are three kinds
of exceptions: checked exceptions, run-time exceptions, and errors. The compilerensures that checked exceptions are properly handled by requiring that a method

1 Introduction INTRODUCTION
4 DRAFT

or constructor can result in a checked exception only if the method or constructordeclares it. This provides compile-time checking that exception handlers exist,
and aids programming in the large. Most user-defined exceptions should bechecked exceptions. Invalid operations in the program detected by the Java virtual
machine result in run-time exceptions, such as NullPointerException. Errorsresult from failures detected by the virtual machine, such as

OutOfMemoryError.Most simple programs do not try to handle errors.

Chapter 12 describes activities that occur during execution of a program. Aprogram is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java virtual machine, linked to otherclasses and interfaces, and initialized.

After initialization, class methods and class variables may be used. Someclasses may be instantiated to create new objects of the class type. Objects that are
class instances also contain an instance of each superclass of the class, and objectcreation involves recursive creation of these superclass instances.

When an object is no longer referenced, it may be reclaimed by the garbagecollector. If an object declares a finalizer, the finalizer is executed before the
object is reclaimed to give the object a last chance to clean up resources thatwould not otherwise be released. When a class is no longer needed, it may be
unloaded.Chapter 13 describes binary compatibility, specifying the impact of changes
to types on other types that use the changed types but have not been recompiled.These considerations are of interest to developers of types that are to be widely
distributed, in a continuing series of versions, often through the Internet. Goodprogram development environments automatically recompile dependent code
whenever a type is changed, so most programmers need not be concerned aboutthese details.

Chapter 14 describes blocks and statements, which are based on C and C++.The language has no

goto statement, but includes labeled break and continuestatements. Unlike C, the Java programming language requires

boolean expres-sions in control-flow statements, and does not convert types to

boolean implic-itly, in the hope of catching more errors at compile time. A

synchronizedstatement provides basic object-level monitor locking. A
try statement caninclude
catch and finally clauses to protect against non-local control transfers.Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability.Overloaded methods and constructors are resolved at compile time by picking the
most specific method or constructor from those which are applicable.Chapter 16 describes the precise way in which the language ensures that local
variables are definitely set before use. While all other variables are automatically

INTRODUCTION Notation 1.2

5DRAFT
initialized to a default value, the Java programming language does not automati-cally initialize local variables in order to avoid masking programming errors.

Chapter 17 describes the semantics of threads and locks, which are based onthe monitor-based concurrency originally introduced with the Mesa programming
language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.

Chapter 18 presents a syntactic grammar for the language.The book concludes with an index, credits for quotations used in the book,
and a colophon describing how the book was created.

1.1   Example Programs
Most of the example programs given in the text are ready to be executed and aresimilar in form to:

class Test {public static void main(String[] args) {

for (int i = 0; i < args.length; i++)System.out.print(i == 0 ? args[i] : " " + args[i]);
System.out.println();}
}
On a Sun workstation using Sun's JDK(TM) or Java 2 SDK software, this class,stored in the file

Test.java, can be compiled and executed by giving the com-mands:

javac Test.javajava Test Hello, world.
producing the output:

Hello, world.

1.2   Notation
Throughout this book we refer to classes and interfaces drawn from the Java andJava 2 platforms. Whenever we refer to a class or interface which is not defined in
an example in this book using a single identifier N, the intended reference is to theclass or interface named

N in the package java.lang. We use the canonical name($6.7) for classes or interfaces from packages other than

java.lang.

1.3 Relationship to Predefined Classes and Interfaces INTRODUCTION

6 DRAFT

1.3   Relationship to Predefined Classes and Interfaces
As noted above, this specification often refers to classes of the Java and Java 2platforms. In particular, some classes have a special relationship with the Java
programming language. Examples include classes such as Object, Class,
ClassLoader, String, Thread, and the classes and interfaces in package
java.lang.reflect, among others. The language definition constrains thebehavior of these classes and interfaces, but this document does not provide a

complete specification for them. The reader is referred to other parts of the Javaplatform specification for such detailed API specifications.

Thus this document does not describe reflection in any detail. Many linguisticconstructs have analogues in the reflection API, but these are generally not discussed here. So, for example, when we list the ways in which an object can be cre-ated, we generally do not include the ways in which the reflective API can
accomplish this. Readers should be aware of these additional mechanisms eventhough they are not mentioned in this text.

1.4   References
Apple Computer. Dylan(TM) Reference Manual. Apple Computer Inc., Cupertino, California.September 29, 1995. See also

http://www.cambridge.apple.com.

Bobrow, Daniel G., Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, GregorKiczales, and David A. Moon. Common Lisp Object System Specification, X3J13

Document 88-002R, June 1988; appears as Chapter 28 of Steele, Guy. Common Lisp:The Language, 2nd ed. Digital Press, 1990, ISBN 1-55558-041-6, 770-864.

Ellis, Margaret A., and Bjarne Stroustrup. The Annotated C++ Reference Manual.Addison-Wesley, Reading, Massachusetts, 1990, reprinted with corrections October

1992, ISBN 0-201-51459-1.
Goldberg, Adele and Robson, David. Smalltalk-80: The Language. Addison-Wesley,Reading, Massachusetts, 1989, ISBN 0-201-13688-0.

Harbison, Samuel. Modula-3. Prentice Hall, Englewood Cliffs, New Jersey, 1992, ISBN0-13-596396.
Hoare, C. A. R. Hints on Programming Language Design. Stanford University ComputerScience Department Technical Report No. CS-73-403, December 1973. Reprinted in

SIGACT/SIGPLAN Symposium on Principles of Programming Languages. Associa-tion for Computing Machinery, New York, October 1973.

IEEE Standard for Binary Floating-Point Arithmetic. ANSI/IEEE Std. 754-1985. Avail-able from Global Engineering Documents, 15 Inverness Way East, Englewood, Colorado 80112-5704 USA; 800-854-7179.

INTRODUCTION References 1.4

7DRAFT
Kernighan, Brian W., and Dennis M. Ritchie. The C Programming Language, 2nd ed.Prentice Hall, Englewood Cliffs, New Jersey, 1988, ISBN 0-13-110362-8.
Madsen, Ole Lehrmann, Birger Mo/ller-Pedersen, and Kristen Nygaard. Object-OrientedProgramming in the Beta Programming Language. Addison-Wesley, Reading, Massachusetts, 1993, ISBN 0-201-62430-3.
Mitchell, James G., William Maybury, and Richard Sweet. The Mesa ProgrammingLanguage, Version 5.0. Xerox PARC, Palo Alto, California, CSL 79-3, April 1979.

Stroustrup, Bjarne. The C++ Progamming Language, 2nd ed. Addison-Wesley, Reading,Massachusetts, 1991, reprinted with corrections January 1994, ISBN 0-201-53992-6.
Unicode Consortium, The. The Unicode Standard: Worldwide Character Encoding, Ver-sion 1.0, Volume 1, ISBN 0-201-56788-1, and Volume 2, ISBN 0-201-60845-6.

Updates and additions necessary to bring the Unicode Standard up to version 1.1 maybe found at

http://www.unicode.org.

Unicode Consortium, The. The Unicode Standard, Version 2.0, ISBN 0-201-48345-9.Updates and additions necessary to bring the Unicode Standard up to version 2.1 may

be found at http://www.unicode.org.

9DRAFT

C H A P T E R 2
Grammars

THIS chapter describes the context-free grammars used in this specification todefine the lexical and syntactic structure of a program.
2.1   Context-Free Grammars
A context-free grammar consists of a number of productions. Each production hasan abstract symbol called a nonterminal as its left-hand side, and a sequence of
one or more nonterminal and terminal symbols as its right-hand side. For eachgrammar, the terminal symbols are drawn from a specified alphabet.

Starting from a sentence consisting of a single distinguished nonterminal,called the goal symbol, a given context-free grammar specifies a language,
namely, the set of possible sequences of terminal symbols that can result fromrepeatedly replacing any nonterminal in the sequence with a right-hand side of a
production for which the nonterminal is the left-hand side.

2.2   The Lexical Grammar
A lexical grammar for the Java programming language is given in ($3). Thisgrammar has as its terminal symbols the characters of the Unicode character set. It
defines a set of productions, starting from the goal symbol Input ($3.5), thatdescribe how sequences of Unicode characters ($3.1) are translated into a
sequence of input elements ($3.5).These input elements, with white space ($3.6) and comments ($3.7) discarded, form the terminal symbols for the syntactic grammar for the Java pro-gramming language and are called tokens ($3.5). These tokens are the identifiers
($3.8), keywords ($3.9), literals ($3.10), separators ($3.11), and operators ($3.12)of the Java programming language.

2.3 The Syntactic Grammar GRAMMARS

10 DRAFT

2.3   The Syntactic Grammar
The syntactic grammar for the Java programming language is given in Chapters 4,6-10, 14, and 15. This grammar has tokens defined by the lexical grammar as its
terminal symbols. It defines a set of productions, starting from the goal symbolCompilationUnit ($7.3), that describe how sequences of tokens can form syntactically correct programs.

2.4 Grammar Notation
Terminal symbols are shown in fixed width font in the productions of the lexicaland syntactic grammars, and throughout this specification whenever the text is
directly referring to such a terminal symbol. These are to appear in a programexactly as written.

Nonterminal symbols are shown in italic type. The definition of a nonterminalis introduced by the name of the nonterminal being defined followed by a colon.
One or more alternative right-hand sides for the nonterminal then follow on suc-ceeding lines. For example, the syntactic definition:

IfThenStatement:

if ( Expression ) Statement

states that the nonterminal IfThenStatement represents the token if, followed by aleft parenthesis token, followed by an Expression, followed by a right parenthesis

token, followed by a Statement.As another example, the syntactic definition:

ArgumentList:Argument

ArgumentList , Argument
states that an ArgumentList may represent either a single Argument or anArgumentList, followed by a comma, followed by an Argument. This definition of

ArgumentList is recursive, that is to say, it is defined in terms of itself. The resultis that an ArgumentList may contain any positive number of arguments. Such
recursive definitions of nonterminals are common.The subscripted suffix "opt", which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbolactually specifies two right-hand sides, one that omits the optional element and
one that includes it.This means that:

GRAMMARS Grammar Notation 2.4

11DRAFT
BreakStatement:

break Identifieropt ;

is a convenient abbreviation for:

BreakStatement:

break ;
break Identifier ;

and that:

ForStatement:

for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement

is a convenient abbreviation for:

ForStatement:

for ( ; Expressionopt ; ForUpdateopt ) Statement
for ( ForInit ; Expressionopt ; ForUpdateopt ) Statement

which in turn is an abbreviation for:

ForStatement:

for ( ; ; ForUpdateopt ) Statement
for ( ; Expression ; ForUpdateopt ) Statement
for ( ForInit ; ; ForUpdateopt ) Statement
for ( ForInit ; Expression ; ForUpdateopt ) Statement

which in turn is an abbreviation for:

ForStatement:

for ( ; ; ) Statement
for ( ; ; ForUpdate ) Statement
for ( ; Expression ; ) Statement
for ( ; Expression ; ForUpdate ) Statement
for ( ForInit ; ; ) Statement
for ( ForInit ; ; ForUpdate ) Statement
for ( ForInit ; Expression ; ) Statement
for ( ForInit ; Expression ; ForUpdate ) Statement

so the nonterminal ForStatement actually has eight alternative right-hand sides.A very long right-hand side may be continued on a second line by substantially indenting this second line, as in:

ConstructorDeclaration:ConstructorModifiers

opt ConstructorDeclaratorThrows

opt ConstructorBody

2.4 Grammar Notation GRAMMARS
12 DRAFT

which defines one right-hand side for the nonterminal ConstructorDeclaration.When the words "one of " follow the colon in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alterna-tive definition. For example, the lexical grammar contains the production:

ZeroToThree: one of

0 1 2 3

which is merely a convenient abbreviation for:

ZeroToThree:

0
1
2
3

When an alternative in a lexical production appears to be a token, it representsthe sequence of characters that would make up such a token. Thus, the definition:

BooleanLiteral: one of

true false

in a lexical grammar production is shorthand for:

BooleanLiteral:

t r u e
f a l s e

The right-hand side of a lexical production may specify that certain expan-sions are not permitted by using the phrase "but not" and then indicating the

expansions to be excluded, as in the productions for InputCharacter ($3.4) andIdentifier ($3.8):

InputCharacter:UnicodeInputCharacter but not

CR or LF

Identifier:IdentifierName but not a Keyword or BooleanLiteral or NullLiteral

Finally, a few nonterminal symbols are described by a descriptive phrase inroman type in cases where it would be impractical to list all the alternatives:
RawInputCharacter:any Unicode character

13DRAFT

C H A P T E R 3
Lexical Structure

THIS chapter specifies the lexical structure of the Java programming language.Programs are written in Unicode ($3.1), but lexical translations are provided
($3.2) so that Unicode escapes ($3.3) can be used to include any Unicode charac-ter using only ASCII characters. Line terminators are defined ($3.4) to support the
different conventions of existing host systems while maintaining consistent linenumbers.

The Unicode characters resulting from the lexical translations are reduced to asequence of input elements ($3.5), which are white space ($3.6), comments
($3.7), and tokens. The tokens are the identifiers ($3.8), keywords ($3.9), literals($3.10), separators ($3.11), and operators ($3.12) of the syntactic grammar.

3.1   Unicode
Programs are written using the Unicode character set. Information about thisencoding may be found at:

http://www.unicode.org
Versions of the Java programming language prior to 1.1 used Unicode version1.1.5 (see The Unicode Standard: Worldwide Character Encoding ($1.4) and

updates). Later versions prior to JDK version 1.1.7 used Unicode version 2.0.Since JDK version 1.1.7, Unicode 2.1 has been in use. The Java platform will
track the Unicode specification as it evolves. The precise version of Unicode usedby a given release is specified in the documentation of the class

Character.Except for comments ($3.7), identifiers, and the contents of character and

string literals ($3.10.4, $3.10.5), all input elements ($3.5) in a program are formedonly from ASCII characters (or Unicode escapes ($3.3) which result in ASCII
characters). ASCII (ANSI X3.4) is the American Standard Code for InformationInterchange. The first 128 characters of the Unicode character encoding are the
ASCII characters.

3.2 Lexical Translations LEXICAL STRUCTURE
14 DRAFT

3.2   Lexical Translations
A raw Unicode character stream is translated into a sequence of tokens, using thefollowing three lexical translation steps, which are applied in turn:

1. A translation of Unicode escapes ($3.3) in the raw stream of Unicode charac-ters to the corresponding Unicode character. A Unicode escape of the form

\uxxxx, where xxxx is a hexadecimal value, represents the Unicode characterwhose encoding is

xxxx. This translation step allows any program to beexpressed using only ASCII characters.

2. A translation of the Unicode stream resulting from step 1 into a stream ofinput characters and line terminators ($3.4).
3. A translation of the stream of input characters and line terminators resultingfrom step 2 into a sequence of input elements ($3.5) which, after white space

($3.6) and comments ($3.7) are discarded, comprise the tokens ($3.5) that arethe terminal symbols of the syntactic grammar ($2.3).

The longest possible translation is used at each step, even if the result does notultimately make a correct program while another lexical translation would. Thus
the input characters a--b are tokenized ($3.5) as a, --, b, which is not part of anygrammatically correct program, even though the tokenization

a, -, -, b could bepart of a grammatically correct program.

3.3   Unicode Escapes
Implementations first recognize Unicode escapes in their input, translating theASCII characters

\u followed by four hexadecimal digits to the Unicode characterwith the indicated hexadecimal value, and passing all other characters unchanged.

This translation step results in a sequence of Unicode input characters:

UnicodeInputCharacter:UnicodeEscape

RawInputCharacter
UnicodeEscape:

\ UnicodeMarker HexDigit HexDigit HexDigit HexDigit

UnicodeMarker:

uUnicodeMarker

 u

LEXICAL STRUCTURE Unicode Escapes 3.3

15DRAFT
RawInputCharacter:any Unicode character
HexDigit: one of

0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

The \, u, and hexadecimal digits here are all ASCII characters.In addition to the processing implied by the grammar, for each raw input character that is a backslash \, input processing must consider how many other \ char-acters contiguously precede it, separating it from a non\ character or the start ofthe input stream. If this number is even, then the
\ is eligible to begin a Unicodeescape; if the number is odd, then the
\ is not eligible to begin a Unicode escape.For example, the raw input
"\\u2297=\u2297" results in the eleven characters
" \ \ u 2 2 9 7 = A" " (\u2297 is the Unicode encoding of the character "A"").If an eligible

\ is not followed by u, then it is treated as a RawInputCharacterand remains part of the escaped Unicode stream. If an eligible

\ is followed by u,or more than one
u, and the last u is not followed by four hexadecimal digits, thena compile-time error occurs.

The character produced by a Unicode escape does not participate in furtherUnicode escapes. For example, the raw input

\u005cu005a results in the six char-acters
\ u 0 0 5 a, because 005c is the Unicode value for \. It does not result inthe character

Z, which is Unicode character 005a, because the \ that resulted fromthe
\u005c is not interpreted as the start of a further Unicode escape.The Java programming language specifies a standard way of transforming a

program written in Unicode into ASCII that changes a program into a form thatcan be processed by ASCII-based tools. The transformation involves converting
any Unicode escapes in the source text of the program to ASCII by adding anextra

u--for example, \uxxxx becomes \uuxxxx--while simultaneously convert-ing non-ASCII characters in the source text to a

\uxxxx escape containing a sin-gle
u.This transformed version is equally acceptable to a compiler for the Java programming language ("Java compiler") and represents the exact same program.The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple u's are present to a sequence of Unicodecharacters with one fewer

u, while simultaneously converting each escapesequence with a single
u to the corresponding single Unicode character.Implementations should use the

\uxxxx notation as an output format to dis-play Unicode characters when a suitable font is not available.

3.4 Line Terminators LEXICAL STRUCTURE

16 DRAFT

3.4   Line Terminators
Implementations next divide the sequence of Unicode input characters into linesby recognizing line terminators. This definition of lines determines the line numbers produced by a Java compiler or other system component. It also specifies thetermination of the

// form of a comment ($3.7).

LineTerminator:the ASCII

LF character, also known as "newline"the ASCII
CR character, also known as "return"the ASCII
CR character followed by the ASCII LF character

InputCharacter:UnicodeInputCharacter but not

CR or LF

Lines are terminated by the ASCII characters CR, or LF, or CR LF. The twocharacters

CR immediately followed by LF are counted as one line terminator, nottwo.

The result is a sequence of line terminators and input characters, which are theterminal symbols for the third step in the tokenization process.

3.5   Input Elements and Tokens
The input characters and line terminators that result from escape processing ($3.3)and then input line recognition ($3.4) are reduced to a sequence of input elements.
Those input elements that are not white space ($3.6) or comments ($3.7) aretokens. The tokens are the terminal symbols of the syntactic grammar ($2.3).

This process is specified by the following productions:
Input:InputElements

opt Subopt

InputElements:InputElement

InputElements InputElement
InputElement:WhiteSpace

CommentToken

LEXICAL STRUCTURE White Space 3.6

17DRAFT
Token:Identifier

KeywordLiteral
SeparatorOperator

Sub:the ASCII

SUB character, also known as "control-Z"

White space ($3.6) and comments ($3.7) can serve to separate tokens that, ifadjacent, might be tokenized in another manner. For example, the ASCII characters - and = in the input can form the operator token -= ($3.12) only if there is nointervening white space or comment.

As a special concession for compatibility with certain operating systems, theASCII

SUB character (\u001a, or control-Z) is ignored if it is the last character inthe escaped input stream.

Consider two tokens x and y in the resulting input stream. If x precedes y,then we say that

x is to the left of y and that y is to the right of x.For example, in this simple piece of code:

class Empty {
}

we say that the } token is to the right of the { token, even though it appears, in thistwo-dimensional representation on paper, downward and to the left of the

{ token.This convention about the use of the words left and right allows us to speak, for

example, of the right-hand operand of a binary operator or of the left-hand side ofan assignment.

3.6 White Space
White space is defined as the ASCII space, horizontal tab, and form feed charac-ters, as well as line terminators ($3.4).

WhiteSpace:the ASCII

SP character, also known as "space"the ASCII
HT character, also known as "horizontal tab"the ASCII
FF character, also known as "form feed"LineTerminator

3.7 Comments LEXICAL STRUCTURE

18 DRAFT

3.7   Comments
There are two kinds of comments:

/* text */ A traditional comment: all the text from the ASCIIcharacters

/* to the ASCII characters */ is ignored(as in C and C++).

// text A end-of-line comment: all the text from the ASCIIcharacters

// to the end of the line is ignored (as inC++).

These comments are formally specified by the following productions:

Comment:TraditionalComment

EndOfLineComment
TraditionalComment:

/ * NotStar CommentTail

EndOfLineComment:

/ / CharactersInLineopt LineTerminator

CommentTail:

* CommentTailStarNotStar CommentTail

CommentTailStar:

/
* CommentTailStarNotStarNotSlash CommentTail

NotStar:InputCharacter but not

*LineTerminator

NotStarNotSlash:InputCharacter but not

* or /LineTerminator

CharactersInLine:InputCharacter

CharactersInLine InputCharacter
These productions imply all of the following properties:

LEXICAL STRUCTURE Identifiers 3.8

19DRAFT

* Comments do not nest.

* /* and */ have no special meaning in comments that begin with //.

* // has no special meaning in comments that begin with /* or /**.
As a result, the text:

/* this comment /* // /** ends here: */
is a single complete comment.The lexical grammar implies that comments do not occur within character literals ($3.10.4) or string literals ($3.10.5).

3.8 Identifiers
An identifier is an unlimited-length sequence of Java letters and Java digits, thefirst of which must be a Java letter. An identifier cannot have the same spelling
(Unicode character sequence) as a keyword ($3.9), boolean literal ($3.10.3), orthe null literal ($3.10.7).

Identifier:IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
IdentifierChars:JavaLetter

IdentifierChars JavaLetterOrDigit
JavaLetter:any Unicode character that is a Java letter (see below)

JavaLetterOrDigit:any Unicode character that is a Java letter-or-digit (see below)
Letters and digits may be drawn from the entire Unicode character set, whichsupports most writing scripts in use in the world today, including the large sets for
Chinese, Japanese, and Korean. This allows programmers to use identifiers intheir programs that are written in their native languages.

A "Java letter" is a character for which the method Character.isJavaIdentifierStart returns true. A "Java letter-or-digit" is a character for which themethod

Character.isJavaIdentifierPart returns true.The Java letters include uppercase and lowercase ASCII Latin letters

A-Z(
\u0041-\u005a), and a-z (\u0061-\u007a), and, for historical reasons, theASCII underscore (

_, or \u005f) and dollar sign ($, or \u0024). The $ charactershould be used only in mechanically generated source code or, rarely, to access

preexisting names on legacy systems.

3.9 Keywords LEXICAL STRUCTURE
20 DRAFT

The "Java digits" include the ASCII digits 0-9 (\u0030-\u0039).Two identifiers are the same only if they are identical, that is, have the same
Unicode character for each letter or digit.Identifiers that have the same external appearance may yet be different. For
example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A(

A, \u0041), LATIN SMALL LETTER A (a, \u0061), GREEK CAPITAL LETTER ALPHA(
A, \u0391), and CYRILLIC SMALL LETTER A (a, \u0430) are all different.Unicode composite characters are different from the decomposed characters.

For example, a LATIN CAPITAL LETTER A ACUTE (A', \u00c1) could be consideredto be the same as a

LATIN CAPITAL LETTER A (A, \u0041) immediately followedby a
NON-SPACING ACUTE (', \u0301) when sorting, but these are different inidentifiers. See The Unicode Standard, Volume 1, pages 412ff for details about

decomposition, and see pages 626-627 of that work for details about sorting.Examples of identifiers are:

String i3 areth MAX_VALUE isLetterOrDigit

3.9   Keywords
The following character sequences, formed from ASCII letters, are reserved foruse as keywords and cannot be used as identifiers ($3.8):

Keyword: one of

abstract default if private this
boolean do implements protected throw
break double import public throws
byte else instanceof return transient
case extends int short try
catch final interface static void
char finally long strictfp volatile
class float native super while
const for new switch
continue goto package synchronized

The keywords const and goto are reserved, even though they are not cur-rently used. This may allow a Java compiler to produce better error messages if

these C++ keywords incorrectly appear in programs.While

true and false might appear to be keywords, they are technicallyBoolean literals ($3.10.3). Similarly, while

null might appear to be a keyword, itis technically the null literal ($3.10.7).

LEXICAL STRUCTURE Integer Literals 3.10.1

21DRAFT
3.10 Literals
A literal is the source code representation of a value of a primitive type ($4.2), the
String type ($4.3.3), or the null type ($4.1):

Literal:IntegerLiteral

FloatingPointLiteralBooleanLiteral
CharacterLiteralStringLiteral
NullLiteral

3.10.1   Integer Literals
See $4.2.1 for a general discussion of the integer types and values.An integer literal may be expressed in decimal (base 10), hexadecimal

(base 16), or octal (base 8):

IntegerLiteral:DecimalIntegerLiteral

HexIntegerLiteralOctalIntegerLiteral

DecimalIntegerLiteral:DecimalNumeral IntegerTypeSuffix

opt

HexIntegerLiteral:HexNumeral IntegerTypeSuffix

opt

OctalIntegerLiteral:OctalNumeral IntegerTypeSuffix

opt

IntegerTypeSuffix: one of

l L

An integer literal is of type long if it is suffixed with an ASCII letter L or l(ell); otherwise it is of type

int ($4.2.1). The suffix L is preferred, because the let-ter
l (ell) is often hard to distinguish from the digit 1 (one).A decimal numeral is either the single ASCII character

0, representing theinteger zero, or consists of an ASCII digit from
1 to 9, optionally followed by oneor more ASCII digits from
0 to 9, representing a positive integer:

3.10.1 Integer Literals LEXICAL STRUCTURE

22 DRAFT

DecimalNumeral:

0NonZeroDigit Digits

opt

Digits:Digit

Digits Digit
Digit:

0NonZeroDigit

NonZeroDigit: one of

1 2 3 4 5 6 7 8 9

A hexadecimal numeral consists of the leading ASCII characters 0x or 0X fol-lowed by one or more ASCII hexadecimal digits and can represent a positive,

zero, or negative integer. Hexadecimal digits with values 10 through 15 are repre-sented by the ASCII letters

a through f or A through F, respectively; each letterused as a hexadecimal digit may be uppercase or lowercase.

HexNumeral:

0 x HexDigits
0 X HexDigits

HexDigits:HexDigit

HexDigit HexDigits
The following production from $3.3 is repeated here for clarity:

HexDigit: one of

0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

An octal numeral consists of an ASCII digit 0 followed by one or more of theASCII digits

0 through 7 and can represent a positive, zero, or negative integer.

OctalNumeral:

0 OctalDigits

OctalDigits:OctalDigit

OctalDigit OctalDigits
OctalDigit: one of

0 1 2 3 4 5 6 7

LEXICAL STRUCTURE Integer Literals 3.10.1

23DRAFT
Note that octal numerals always consist of two or more digits; 0 is alwaysconsidered to be a decimal numeral--not that it matters much in practice, for the
numerals 0, 00, and 0x0 all represent exactly the same integer value.The largest decimal literal of type

int is 2147483648 ( ). All decimal liter-als from
0 to 2147483647 may appear anywhere an int literal may appear, butthe literal

2147483648 may appear only as the operand of the unary negationoperator
-.The largest positive hexadecimal and octal literals of type

int are
0x7fffffff and 017777777777, respectively, which equal 2147483647( ). The most negative hexadecimal and octal literals of type

int are
0x80000000 and 020000000000, respectively, each of which represents the deci-mal value

-2147483648 ( ). The hexadecimal and octal literals 0xffffffffand
037777777777, respectively, represent the decimal value -1.A compile-time error occurs if a decimal literal of type

int is larger than
2147483648 ( ), or if the literal 2147483648 appears anywhere other than asthe operand of the unary

- operator, or if a hexadecimal or octal int literal doesnot fit in 32 bits.

Examples of int literals:

0 2 0372 0xDadaCafe 1996 0x00FF00FF

The largest decimal literal of type long is 9223372036854775808L ( ).All decimal literals from

0L to 9223372036854775807L may appear anywhere a
long literal may appear, but the literal 9223372036854775808L may appear onlyas the operand of the unary negation operator

-.The largest positive hexadecimal and octal literals of type

long are
0x7fffffffffffffffL and 0777777777777777777777L, respectively, whichequal

9223372036854775807L ( ). The literals 0x8000000000000000Land
01000000000000000000000L are the most negative long hexadecimal andoctal literals, respectively. Each has the decimal value

-9223372036854775808L( ). The hexadecimal and octal literals
0xffffffffffffffffL and
01777777777777777777777L, respectively, represent the decimal value -1L.A compile-time error occurs if a decimal literal of type

long is larger than
9223372036854775808L ( ), or if the literal 9223372036854775808L appearsanywhere other than as the operand of the unary

- operator, or if a hexadecimal oroctal
long literal does not fit in 64 bits.Examples of

long literals:

0l 0777L 0x100000000L 2147483648L 0xC0B0L

231
231 1-

231-

231

263
263 1-
263-

263

3.10.2 Floating-Point Literals LEXICAL STRUCTURE

24 DRAFT

3.10.2 Floating-Point Literals
See $4.2.3 for a general discussion of the floating-point types and values.A floating-point literal has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an expo-nent, and a type suffix. The exponent, if present, is indicated by the ASCII letter

eor
E followed by an optionally signed integer.At least one digit, in either the whole number or the fraction part, and either a

decimal point, an exponent, or a float type suffix are required. All other parts areoptional.

A floating-point literal is of type float if it is suffixed with an ASCII letter For
f; otherwise its type is double and it can optionally be suffixed with an ASCIIletter

D or d.

FloatingPointLiteral:Digits

 . Digitsopt ExponentPartopt FloatTypeSuffixopt
. Digits ExponentPartopt FloatTypeSuffixoptDigits ExponentPart FloatTypeSuffix

optDigits ExponentPart
opt FloatTypeSuffix

ExponentPart:ExponentIndicator SignedInteger

ExponentIndicator: one of

e E

SignedInteger:Sign

opt Digits

Sign: one of

+ -

FloatTypeSuffix: one of

f F d D

The elements of the types float and double are those values that can be rep-resented using the IEEE 754 32-bit single-precision and 64-bit double-precision

binary floating-point formats, respectively.The details of proper input conversion from a Unicode string representation of
a floating-point number to the internal IEEE 754 binary floating-point representa-tion are described for the methods

valueOf of class Float and class Double ofthe package
java.lang.The largest positive finite

float literal is 3.40282347e+38f. The smallestpositive finite nonzero literal of type

float is 1.40239846e-45f. The largest

LEXICAL STRUCTURE Boolean Literals 3.10.3

25DRAFT
positive finite double literal is 1.79769313486231570e+308. The smallest posi-tive finite nonzero literal of type

double is 4.94065645841246544e-324.A compile-time error occurs if a nonzero floating-point literal is too large, so

that on rounded conversion to its internal representation it becomes an IEEE 754infinity. A program can represent infinities without producing a compile-time
error by using constant expressions such as 1f/0f or -1d/0d or by using the pre-defined constants

POSITIVE_INFINITY and NEGATIVE_INFINITY of the classes
Float and Double.A compile-time error occurs if a nonzero floating-point literal is too small, so

that, on rounded conversion to its internal representation, it becomes a zero. Acompile-time error does not occur if a nonzero floating-point literal has a small
value that, on rounded conversion to its internal representation, becomes a non-zero denormalized number.

Predefined constants representing Not-a-Number values are defined in theclasses

Float and Double as Float.NaN and Double.NaN.Examples of

float literals:

1e1f 2.f .3f 0f 3.14f 6.022137e+23f
Examples of double literals:

1e1 2. .3 0.0 3.14 1e-9d 1e137
There is no provision for expressing floating-point literals in other than deci-mal radix. However, method

intBitsToFloat of class Float and method longBitsToDouble of class Double provide a way to express floating-point values interms of hexadecimal or octal integer literals.

For example, the value of:
Double.longBitsToDouble(0x400921FB54442D18L)
is equal to the value of Math.PI.

3.10.3 Boolean Literals
The boolean type has two values, represented by the literals true and false,formed from ASCII letters.

A boolean literal is always of type boolean.
BooleanLiteral: one of

true false

3.10.4 Character Literals LEXICAL STRUCTURE

26 DRAFT

3.10.4   Character Literals
A character literal is expressed as a character or an escape sequence, enclosed inASCII single quotes. (The single-quote, or apostrophe, character is

\u0027.)A character literal is always of type
char.

CharacterLiteral:

' SingleCharacter '
' EscapeSequence '

SingleCharacter:InputCharacter but not

' or \

The escape sequences are described in $3.10.6.As specified in $3.4, the characters

CR and LF are never an InputCharacter;they are recognized as constituting a LineTerminator.

It is a compile-time error for the character following the SingleCharacter orEscapeSequence to be other than a

'.It is a compile-time error for a line terminator to appear after the opening

'and before the closing
'.The following are examples of

char literals:

'a'
'%'
'\t'
'\\'
'\''
'\u03a9'
'\uFFFF'
'\177'
'\Omega '
'A"'

Because Unicode escapes are processed very early, it is not correct to write
'\u000a' for a character literal whose value is linefeed (LF); the Unicode escape
\u000a is transformed into an actual linefeed in translation step 1 ($3.3) and thelinefeed becomes a LineTerminator in step 2 ($3.4), and so the character literal is

not valid in step 3. Instead, one should use the escape sequence '\n' ($3.10.6).Similarly, it is not correct to write

'\u000d' for a character literal whose value iscarriage return (
CR). Instead, use '\r'.In C and C++, a character literal may contain representations of more than

one character, but the value of such a character literal is implementation-defined.In the Java programming language, a character literal always represents exactly
one character.

LEXICAL STRUCTURE String Literals 3.10.5

27DRAFT
3.10.5 String Literals
A string literal consists of zero or more characters enclosed in double quotes.Each character may be represented by an escape sequence.

A string literal is always of type String ($4.3.3. A string literal always refersto the same instance ($4.3.1) of class

String.

StringLiteral:

" StringCharactersopt "

StringCharacters:StringCharacter

StringCharacters StringCharacter
StringCharacter:InputCharacter but not

" or \EscapeSequence

The escape sequences are described in $3.10.6.As specified in $3.4, neither of the characters

CR and LF is ever considered tobe an InputCharacter; each is recognized as constituting a LineTerminator.

It is a compile-time error for a line terminator to appear after the opening "and before the closing matching

". A long string literal can always be broken upinto shorter pieces and written as a (possibly parenthesized) expression using the

string concatenation operator + ($15.18.1).The following are examples of string literals:

"" // the empty string
"\"" // a string containing " alone
"This is a string" // a string containing 16 characters
"This is a " + // actually a string-valued constant expression,

"two-line string" // formed from two string literals

Because Unicode escapes are processed very early, it is not correct to write
"\u000a" for a string literal containing a single linefeed (LF); the Unicode escape
\u000a is transformed into an actual linefeed in translation step 1 ($3.3) and thelinefeed becomes a LineTerminator in step 2 ($3.4), and so the string literal is not

valid in step 3. Instead, one should write "\n" ($3.10.6). Similarly, it is not correctto write

"\u000d" for a string literal containing a single carriage return (CR).Instead use

"\r".Each string literal is a reference ($4.3) to an instance ($4.3.1, $12.5) of class

String ($4.3.3). String objects have a constant value. String literals--or, moregenerally, strings that are the values of constant expressions ($15.28)--are
"interned" so as to share unique instances, using the method String.intern.

3.10.6 Escape Sequences for Character and String Literals LEXICAL STRUCTURE
28 DRAFT

Thus, the test program consisting of the compilation unit ($7.3):
package testPackage;
class Test {

public static void main(String[] args) {

String hello = "Hello", lo = "lo";
System.out.print((hello == "Hello") + " ");
System.out.print((Other.hello == hello) + " ");
System.out.print((other.Other.hello == hello) + " ");
System.out.print((hello == ("Hel"+"lo")) + " ");
System.out.print((hello == ("Hel"+lo)) + " ");
System.out.println(hello == ("Hel"+lo).intern());
}
}

class Other { static String hello = "Hello"; }

and the compilation unit:

package other;
public class Other { static String hello = "Hello"; }
produces the output:

true true true true false true
This example illustrates six points:

* Literal strings within the same class ($8) in the same package ($7) representreferences to the same

String object ($4.3.1).

* Literal strings within different classes in the same package represent refer-ences to the same

String object.

* Literal strings within different classes in different packages likewise representreferences to the same

String object.

* Strings computed by constant expressions ($15.28) are computed at compiletime and then treated as if they were literals.

* Strings computed at run time are newly created and therefore distinct.

* The result of explicitly interning a computed string is the same string as anypre-existing literal string with the same contents.

3.10.6 Escape Sequences for Character and String Literals
The character and string escape sequences allow for the representation of somenongraphic characters as well as the single quote, double quote, and backslash

characters in character literals ($3.10.4) and string literals ($3.10.5).

LEXICAL STRUCTURE Separators 3.11

29DRAFT
EscapeSequence:

\ b /* \u0008: backspace BS */
\ t /* \u0009: horizontal tab HT */
\ n /* \u000a: linefeed LF */
\ f /* \u000c: form feed FF */
\ r /* \u000d: carriage return CR */
\ " /* \u0022: double quote " */
\ ' /* \u0027: single quote ' */
\ \ /* \u005c: backslash \ */OctalEscape

/* \u0000 to \u00ff: from octal value */

OctalEscape:

\ OctalDigit
\ OctalDigit OctalDigit
\ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of

0 1 2 3 4 5 6 7

ZeroToThree: one of

0 1 2 3

It is a compile-time error if the character following a backslash in an escape isnot an ASCII

b, t, n, f, r, ", ', \, 0, 1, 2, 3, 4, 5, 6, or 7. The Unicode escape \u isprocessed earlier ($3.3). (Octal escapes are provided for compatibility with C, but

can express only Unicode values \u0000 through \u00FF, so Unicode escapes areusually preferred.)

3.10.7   The Null Literal
The null type has one value, the null reference, represented by the literal null,which is formed from ASCII characters. A null literal is always of the null type.

NullLiteral:

null

3.11   Separators
The following nine ASCII characters are the separators (punctuators):

Separator: one of

( ) { } [ ] ; , .

3.12 Operators LEXICAL STRUCTURE
30 DRAFT

3.12   Operators
The following 37 tokens are the operators, formed from ASCII characters:

Operator: one of

= > < ! ~ ? :
== <= >= != && || ++ --
+ - * / & | ^ % << >> >>>
+= -= *= /= &= |= ^= %= <<= >>= >>>=

31DRAFT

C H A P T E R 4
Types, Values, and Variables

THE Java programming language is a strongly typed language, which meansthat every variable and every expression has a type that is known at compile time.
Types limit the values that a variable ($4.5) can hold or that an expression can pro-duce, limit the operations supported on those values, and determine the meaning
of the operations. Strong typing helps detect errors at compile time.The types of the Java programming language are divided into two categories:
primitive types and reference types. The primitive types ($4.2) are the booleantype and the numeric types. The numeric types are the integral types

byte, short,
int, long, and char, and the floating-point types float and double. The refer-ence types ($4.3) are class types, interface types, and array types. There is also a

special null type. An object ($4.3.1) is a dynamically created instance of a classtype or a dynamically created array. The values of a reference type are references
to objects. All objects, including arrays, support the methods of class Object($4.3.2). String literals are represented by

String objects ($4.3.3).Names of types are used ($4.4) in declarations, casts, class instance creation

expressions, array creation expressions, class literals, and instanceof operatorexpressions.

A variable ($4.5) is a storage location. A variable of a primitive type alwaysholds a value of that exact type. A variable of a class type

T can hold a null refer-ence or a reference to an instance of class
T or of any class that is a subclass of T.A variable of an interface type can hold a null reference or a reference to any

instance of any class that implements the interface. If T is a primitive type, then avariable of type "array of

T " can hold a null reference or a reference to any arrayof type "array of
T "; if T is a reference type, then a variable of type "array of T "can hold a null reference or a reference to any array of type "array of

S" such thattype
S is assignable ($5.2) to type T. A variable of type Object can hold a nullreference or a reference to any object, whether class instance or array.

4.1 The Kinds of Types and Values TYPES, VALUES, AND VARIABLES

32 DRAFT

4.1   The Kinds of Types and Values
There are two kinds of types in the Java programming language: primitive types($4.2) and reference types ($4.3). There are, correspondingly, two kinds of data
values that can be stored in variables, passed as arguments, returned by methods,and operated on: primitive values ($4.2) and reference values ($4.3).

Type:PrimitiveType

ReferenceType
There is also a special null type, the type of the expression null, which has noname. Because the null type has no name, it is impossible to declare a variable of

the null type or to cast to the null type. The null reference is the only possiblevalue of an expression of null type. The null reference can always be cast to any
reference type. In practice, the programmer can ignore the null type and just pre-tend that

null is merely a special literal that can be of any reference type.

4.2   Primitive Types and Values
A primitive type is predefined by the Java programming language and named byits reserved keyword ($3.9):

PrimitiveType:NumericType

boolean
NumericType:IntegralType

FloatingPointType
IntegralType: one of

byte short int long char

FloatingPointType: one of

float double

Primitive values do not share state with other primitive values. A variablewhose type is a primitive type always holds a primitive value of that same type.

The value of a variable of primitive type can be changed only by assignment oper-ations on that variable.

The numeric types are the integral types and the floating-point types.

TYPES, VALUES, AND VARIABLES Integer Operations 4.2.2

33DRAFT
The integral types are byte, short, int, and long, whose values are 8-bit,16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and
char, whose values are 16-bit unsigned integers representing Unicode characters.The floating-point types are

float, whose values include the 32-bit IEEE 754floating-point numbers, and
double, whose values include the 64-bit IEEE 754floating-point numbers.

The boolean type has exactly two values: true and false.

4.2.1   Integral Types and Values
The values of the integral types are integers in the following ranges:

* For byte, from -128 to 127, inclusive

* For short, from -32768 to 32767, inclusive

* For int, from -2147483648 to 2147483647, inclusive

* For long, from -9223372036854775808 to 9223372036854775807, inclusive

* For char, from '\u0000' to '\uffff' inclusive, that is, from 0 to 65535

4.2.2   Integer Operations
The Java programming language provides a number of operators that act on inte-gral values:

* The comparison operators, which result in a value of type boolean:

u The numerical comparison operators <, <=, >, and >= ($15.20.1)
u The numerical equality operators == and != ($15.21.1)

* The numerical operators, which result in a value of type int or long:

u The unary plus and minus operators + and - ($15.15.3, $15.15.4)
u The multiplicative operators *, /, and % ($15.17)
u The additive operators + and - ($15.18.2)
u The increment operator ++, both prefix ($15.15.1) and postfix ($15.14.1)
u The decrement operator --, both prefix ($15.15.2) and postfix ($15.14.2)
u The signed and unsigned shift operators <<, >>, and >>> ($15.19)
u The bitwise complement operator ~ ($15.15.5)
u The integer bitwise operators &, |, and ^ ($15.22.1)

4.2.2 Integer Operations TYPES, VALUES, AND VARIABLES
34 DRAFT

* The conditional operator ? : ($15.25)

* The cast operator, which can convert from an integral value to a value of anyspecified numeric type ($5.5, $15.16)

* The string concatenation operator + ($15.18.1), which, when given a Stringoperand and an integral operand, will convert the integral operand to a

String representing its value in decimal form, and then produce a newly cre-ated

String that is the concatenation of the two strings

Other useful constructors, methods, and constants are predefined in the classes
Byte, Short, Integer, Long, and Character.If an integer operator other than a shift operator has at least one operand of

type long, then the operation is carried out using 64-bit precision, and the resultof the numerical operator is of type

long. If the other operand is not long, it isfirst widened ($5.1.4) to type
long by numeric promotion ($5.6). Otherwise, theoperation is carried out using 32-bit precision, and the result of the numerical

operator is of type int. If either operand is not an int, it is first widened to type
int by numeric promotion.The built-in integer operators do not indicate overflow or underflow in any

way. The only numeric operators that can throw an exception ($11) are the integerdivide operator

/ ($15.17.2) and the integer remainder operator % ($15.17.3),which throw an
ArithmeticException if the right-hand operand is zero.The example:

class Test {

public static void main(String[] args) {

int i = 1000000;
System.out.println(i * i);
long l = i;
System.out.println(l * l);
System.out.println(20296 / (l - i));
}
}

produces the output:

-727379968
1000000000000

and then encounters an ArithmeticException in the division by l - i, because
l - i is zero. The first multiplication is performed in 32-bit precision, whereas thesecond multiplication is a

long multiplication. The value -727379968 is the deci-mal value of the low 32 bits of the mathematical result,

1000000000000, which isa value too large for type
int.

TYPES, VALUES, AND VARIABLES Floating-Point Types, Formats, and Values 4.2.3

35DRAFT
Any value of any integral type may be cast to or from any numeric type. Thereare no casts between integral types and the type

boolean.

4.2.3   Floating-Point Types, Formats, and Values
The floating-point types are float and double, which are conceptually associ-ated with the single-precision 32-bit and double-precision 64-bit format IEEE 754

values and operations as specified in IEEE Standard for Binary Floating-PointArithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).

The IEEE 754 standard includes not only positive and negative numbers thatconsist of a sign and magnitude, but also positive and negative zeros, positive and
negative infinities, and special Not-a-Number values (hereafter abbreviated NaN).A NaN value is used to represent the result of certain invalid operations such as
dividing zero by zero. NaN constants of both float and double type are pre-defined as

Float.NaN and Double.NaN.Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the float value set and thedouble value set. In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point valuesets, called the float-extended-exponent value set and the double-extended-exponent value set. These extended-exponent value sets may, under certain circum-stances, be used instead of the standard value sets to represent the values of
expressions of type float or double ($5.1.8, $15.4).The finite nonzero values of any floating-point value set can all be expressed
in the form , where s is +1 or -1, m is a positive integer less than, and e is an integer between and , inclusive, and where N and K are parameters that depend on the value set. Some valuescan be represented in this form in more than one way; for example, supposing that
a value v in a value set might be represented in this form using certain values for s,m, and e, then if it happened that m were even and e were less than , one
could halve m and increase e by 1 to produce a second representation for the samevalue v. A representation in this form is called normalized if ; otherwise the representation is said to be denormalized. If a value in a value set cannotbe represented in such a way that , then the value is said to be a denormalized value, because it has no normalized representation.The constraints on the parameters N and K (and on the derived parameters
Emin and Emax) for the two required and two optional floating-point value sets aresummarized in Table 4.1.

Where one or both extended-exponent value sets are supported by an imple-mentation, then for each supported extended-exponent value set there is a specific

s m 2 e N- 1+( )OE OE
2N Emin 2K 1- 2-( )-= Emax 2K 1- 1-=

2K 1-
m 2 N 1-( )>=
m 2 N 1-( )>=

4.2.3 Floating-Point Types, Formats, and Values TYPES, VALUES, AND VARIABLES

36 DRAFT

implementation-dependent constant K, whose value is constrained by Table 4.1;this value K in turn dictates the values for E

min and Emax.Each of the four value sets includes not only the finite nonzero values that are

ascribed to it above, but also NaN values and the four values positive zero, nega-tive zero, positive infinity, and negative infinity.

Note that the constraints in Table 4.1 are designed so that every element of thefloat value set is necessarily also an element of the float-extended-exponent value
set, the double value set, and the double-extended-exponent value set. Likewise,each element of the double value set is necessarily also an element of the doubleextended-exponent value set. Each extended-exponent value set has a larger rangeof exponent values than the corresponding standard value set, but does not have
more precision.The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard.The elements of the double value set are exactly the values that can be represented
using the double floating-point format defined in the IEEE 754 standard. Note,however, that the elements of the float-extended-exponent and double-extendedexponent value sets defined here do not correspond to the values that can be repre-sented using IEEE 754 single extended and double extended formats, respectively.

The float, float-extended-exponent, double, and double-extended-exponentvalue sets are not types. It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value oftype

float; however, it may be permissible in certain regions of code for animplementation to use an element of the float-extended-exponent value set

instead. Similarly, it is always correct for an implementation to use an element ofthe double value set to represent a value of type

double; however, it may be per-missible in certain regions of code for an implementation to use an element of the

double-extended-exponent value set instead.Except for NaN, floating-point values are ordered; arranged from smallest to
largest, they are negative infinity, negative finite nonzero values, positive and neg-ative zero, positive finite nonzero values, and positive infinity.

Parameter float float-extended-exponent double double-extended-exponent
N 24 24 53 53
K 8 >= 11 11 >= 15
Emax +127 >= +1023 +1023 >= +16383
Emin -126 <= -1022 -1022 <= -16382

Table 4.1 Floating-point value set parameters

TYPES, VALUES, AND VARIABLES Floating-Point Operations 4.2.4

37DRAFT
IEEE 754 allows multiple distinct NaN values for each of its single and dou-ble floating-point formats. While each hardware architecture returns a particular
bit pattern for NaN when a new NaN is generated, a programmer can also createNaNs with different bit patterns to encode, for example, retrospective diagnostic
information.For the most part, the Java platform treats NaN values of a given type as
though collapsed into a single canonical value (and hence this specification nor-mally refers to an arbitrary NaN as though to a canonical value). However, version
1.3 the Java platform introduced methods enabling the programmer to distinguishbetween NaN values: the

Float.floatToRawIntBits and Double.doubleToRawLongBits methods. The interested reader is referred to the specificationsfor the

Float and Double classes for more information.Positive zero and negative zero compare equal; thus the result of the expression 0.0==-0.0 is true and the result of 0.0>-0.0 is false. But other opera-tions can distinguish positive and negative zero; for example,

1.0/0.0 has thevalue positive infinity, while the value of
1.0/-0.0 is negative infinity.NaN is unordered, so the numerical comparison operators

<, <=, >, and >=return
false if either or both operands are NaN ($15.20.1). The equality operator
== returns false if either operand is NaN, and the inequality operator != returns
true if either operand is NaN ($15.21.1). In particular, x!=x is true if and only if
x is NaN, and (x<y) == !(x>=y) will be false if x or y is NaN.Any value of a floating-point type may be cast to or from any numeric type.

There are no casts between floating-point types and the type boolean.

4.2.4   Floating-Point Operations
The Java programming language provides a number of operators that act on float-ing-point values:

* The comparison operators, which result in a value of type boolean:

u The numerical comparison operators <, <=, >, and >= ($15.20.1)
u The numerical equality operators == and != ($15.21.1)

* The numerical operators, which result in a value of type float or double:

u The unary plus and minus operators + and - ($15.15.3, $15.15.4)
u The multiplicative operators *, /, and % ($15.17)
u The additive operators + and - ($15.18.2)
u The increment operator ++, both prefix ($15.15.1) and postfix ($15.14.1)

4.2.4 Floating-Point Operations TYPES, VALUES, AND VARIABLES
38 DRAFT

u The decrement operator --, both prefix ($15.15.2) and postfix ($15.14.2)

* The conditional operator ? : ($15.25)

* The cast operator, which can convert from a floating-point value to a value ofany specified numeric type ($5.5, $15.16)

* The string concatenation operator + ($15.18.1), which, when given a Stringoperand and a floating-point operand, will convert the floating-point operand

to a String representing its value in decimal form (without information loss),and then produce a newly created

String by concatenating the two strings

Other useful constructors, methods, and constants are predefined in the classes
Float, Double, and Math.If at least one of the operands to a binary operator is of floating-point type,

then the operation is a floating-point operation, even if the other is integral.If at least one of the operands to a numerical operator is of type

double, thenthe operation is carried out using 64-bit floating-point arithmetic, and the result of

the numerical operator is a value of type double. (If the other operand is not a
double, it is first widened to type double by numeric promotion ($5.6).) Other-wise, the operation is carried out using 32-bit floating-point arithmetic, and the

result of the numerical operator is a value of type float. If the other operand isnot a

float, it is first widened to type float by numeric promotion.Operators on floating-point numbers behave as specified by IEEE 754 (with

the exception of the remainder operator ($15.17.3)). In particular, the Java pro-gramming language requires support of IEEE 754 denormalized floating-point
numbers and gradual underflow, which make it easier to prove desirable proper-ties of particular numerical algorithms. Floating-point operations do not "flush to
zero" if the calculated result is a denormalized number.The Java programming language requires that floating-point arithmetic
behave as if every floating-point operator rounded its floating-point result to theresult precision. Inexact results must be rounded to the representable value nearest
to the infinitely precise result; if the two nearest representable values are equallynear, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as round to nearest.The language uses round toward zero when converting a floating value to an
integer ($5.1.3), which acts, in this case, as though the number were truncated,discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely preciseresult.

Floating-point operators produce no exceptions ($11). An operation that over-flows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically

TYPES, VALUES, AND VARIABLES Floating-Point Operations 4.2.4

39DRAFT
definite result produces NaN. All numeric operations with NaN as an operand pro-duce NaN as a result. As has already been described, NaN is unordered, so a
numeric comparison operation involving one or two NaNs returns false and any
!= comparison involving NaN returns true, including x!=x when x is NaN.The example program:

class Test {

public static void main(String[] args) {

// An example of overflow:
double d = 1e308;
System.out.print("overflow produces infinity: ");
System.out.println(d + "*10==" + d*10);

// An example of gradual underflow:
d = 1e-305 * Math.PI;
System.out.print("gradual underflow: " + d + "\n ");
for (int i = 0; i < 4; i++)

System.out.print(" " + (d /= 100000));
System.out.println();

// An example of NaN:
System.out.print("0.0/0.0 is Not-a-Number: ");
d = 0.0/0.0;
System.out.println(d);

// An example of inexact results and rounding:
System.out.print("inexact results with float:");
for (int i = 0; i < 100; i++) {

float z = 1.0f / i;
if (z * i != 1.0f)

System.out.print(" " + i);
}
System.out.println();

// Another example of inexact results and rounding:
System.out.print("inexact results with double:");
for (int i = 0; i < 100; i++) {

double z = 1.0 / i;
if (z * i != 1.0)

System.out.print(" " + i);
}
System.out.println();

// An example of cast to integer rounding:
System.out.print("cast to int rounds toward 0: ");
d = 12345.6;
System.out.println((int)d + " " + (int)(-d));
}
}

4.2.5 The boolean Type and boolean Values TYPES, VALUES, AND VARIABLES
40 DRAFT

produces the output:

overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305

3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345

This example demonstrates, among other things, that gradual underflow canresult in a gradual loss of precision.

The results when i is 0 involve division by zero, so that z becomes positiveinfinity, and

z * 0 is NaN, which is not equal to 1.0.

4.2.5 The boolean Type and boolean Values
The boolean type represents a logical quantity with two possible values, indi-cated by the literals

true and false ($3.10.3). The boolean operators are:

* The relational operators == and != ($15.21.2)

* The logical-complement operator ! ($15.15.6)

* The logical operators &, ^, and | ($15.22.2)

* The conditional-and and conditional-or operators && ($15.23) and || ($15.24)

* The conditional operator ? : ($15.25)

* The string concatenation operator + ($15.18.1), which, when given a Stringoperand and a boolean operand, will convert the boolean operand to a

String(either
"true" or "false"), and then produce a newly created String that isthe concatenation of the two strings

Boolean expressions determine the control flow in several kinds of statements:

* The if statement ($14.9)

* The while statement ($14.11)

* The do statement ($14.12)

* The for statement ($14.13)

A boolean expression also determines which subexpression is evaluated in theconditional

? : operator ($15.25).

TYPES, VALUES, AND VARIABLES Reference Types and Values 4.3

41DRAFT
Only boolean expressions can be used in control flow statements and as thefirst operand of the conditional operator

? :. An integer x can be converted to a
boolean, following the C language convention that any nonzero value is true, bythe expression

x!=0. An object reference obj can be converted to a boolean,following the C language convention that any reference other than

null is true,by the expression
obj!=null.A cast of a
boolean value to type boolean is allowed ($5.1.1); no other castson type
boolean are allowed. A boolean can be converted to a string by stringconversion ($5.4).

4.3   Reference Types and Values
There are three kinds of reference types: class types ($8), interface types ($9), andarray types ($10).

ReferenceType:ClassOrInterfaceType

ArrayType
ClassOrInterfaceType:ClassType

InterfaceType
ClassType:TypeName

InterfaceType:TypeName
ArrayType:Type

 [ ]

Names are described in $6; type names in $6.5 and, specifically, $6.5.5.The sample code:

class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
declares a class type Point, an interface type Move, and uses an array type int[](an array of

int) to declare the field metrics of the class Point.

4.3.1 Objects TYPES, VALUES, AND VARIABLES

42 DRAFT

4.3.1 Objects
An object is a class instance or an array.The reference values (often just references) are pointers to these objects, and a

special null reference, which refers to no object.A class instance is explicitly created by a class instance creation expression
($15.9). An array is explicitly created by an array creation expression ($15.9).A new class instance is implicitly created when the string concatenation operator + ($15.18.1) is used in an expression, resulting in a new object of type
String ($4.3.3). A new array object is implicitly created when an array initializerexpression ($10.6) is evaluated; this can occur when a class or interface is initialized ($12.4), when a new instance of a class is created ($15.9), or when a localvariable declaration statement is executed ($14.4).

Many of these cases are illustrated in the following example:
class Point {

int x, y;
Point() { System.out.println("default"); }
Point(int x, int y) { this.x = x; this.y = y; }

// A Point instance is explicitly created at class initialization time:
static Point origin = new Point(0,0);

// A String can be implicitly created by a + operator:
public String toString() {

return "(" + x + "," + y + ")";
}
}

class Test {

public static void main(String[] args) {

// A Point is explicitly created using newInstance:
Point p = null;
try {

p = (Point)Class.forName("Point").newInstance();
} catch (Exception e) {

System.out.println(e);
}

// An array is implicitly created by an array constructor:
Point a[] = { new Point(0,0), new Point(1,1) };

// Strings are implicitly created by + operators:
System.out.println("p: " + p);
System.out.println("a: { " + a[0] + ", "+ a[1] + " }");

// An array is explicitly created by an array creation expression:
String sa[] = new String[2];

TYPES, VALUES, AND VARIABLES Objects 4.3.1

43DRAFT
sa[0] = "he"; sa[1] = "llo";
System.out.println(sa[0] + sa[1]);
}
}

which produces the output:

default
p: (0,0)
a: { (0,0), (1,1) }
hello

The operators on references to objects are:

* Field access, using either a qualified name ($6.6) or a field access expression($15.11)

* Method invocation ($15.12)

* The cast operator ($5.5, $15.16)

* The string concatenation operator + ($15.18.1), which, when given a Stringoperand and a reference, will convert the reference to a

String by invokingthe
toString method of the referenced object (using "null" if either the ref-erence or the result of

toString is a null reference), and then will produce anewly created
String that is the concatenation of the two strings

* The instanceof operator ($15.20.2)

* The reference equality operators == and != ($15.21.3)

* The conditional operator ? : ($15.25).

There may be many references to the same object. Most objects have state,stored in the fields of objects that are instances of classes or in the variables that
are the components of an array object. If two variables contain references to thesame object, the state of the object can be modified using one variable's reference
to the object, and then the altered state can be observed through the reference inthe other variable.

The example program:
class Value { int val; }
class Test {

public static void main(String[] args) {

int i1 = 3;
int i2 = i1;
i2 = 4;
System.out.print("i1==" + i1);

4.3.2 The Class Object TYPES, VALUES, AND VARIABLES
44 DRAFT

System.out.println(" but i2==" + i2);
Value v1 = new Value();
v1.val = 5;
Value v2 = v1;
v2.val = 6;
System.out.print("v1.val==" + v1.val);
System.out.println(" and v2.val==" + v2.val);
}
}

produces the output:

i1==3 but i2==4
v1.val==6 and v2.val==6

because v1.val and v2.val reference the same instance variable ($4.5.3) in theone

Value object created by the only new expression, while i1 and i2 are differ-ent variables.

See $10 and $15.10 for examples of the creation and use of arrays.Each object has an associated lock ($17.13), which is used by

synchronizedmethods ($8.4.3) and the
synchronized statement ($14.18) to provide controlover concurrent access to state by multiple threads ($17.12).

4.3.2   The Class Object
The class Object is a superclass ($8.1) of all other classes. A variable of type
Object can hold a reference to any object, whether it is an instance of a class oran array ($10). All class and array types inherit the methods of class

Object,which are summarized here:

package java.lang;
public class Object {public final Class getClass() { . . . }

public String toString() { . . . }public boolean equals(Object obj) { . . . }
public int hashCode() { . . . }protected Object clone()

throws CloneNotSupportedException { . . . }public final void wait()
throws IllegalMonitorStateException,InterruptedException { . . . }
public final void wait(long millis)throws IllegalMonitorStateException,

InterruptedException { . . . }public final void wait(long millis, int nanos) { . . . }
throws IllegalMonitorStateException,InterruptedException { . . . }

TYPES, VALUES, AND VARIABLES When Reference Types Are the Same 4.3.4

45DRAFT
public final void notify() { . . . }throws IllegalMonitorStateException
public final void notifyAll() { . . . }throws IllegalMonitorStateException
protected void finalize()throws Throwable { . . . }
}
The members of Object are as follows:

* The method getClass returns the Class object that represents the class ofthe object. A

Class object exists for each reference type. It can be used, forexample, to discover the fully qualified name of a class, its members, its

immediate superclass, and any interfaces that it implements. A class methodthat is declared

synchronized ($8.4.3.6) synchronizes on the lock associatedwith the
Class object of the class.

* The method toString returns a String representation of the object.

* The methods equals and hashCode are very useful in hashtables such as

java.util.Hashtable. The method equals defines a notion of objectequality, which is based on value, not reference, comparison.

* The method clone is used to make a duplicate of an object.

* The methods wait, notify, and notifyAll are used in concurrent program-ming using threads, as described in $17.

* The method finalize is run just before an object is destroyed and isdescribed in $12.6.

4.3.3   The Class String
Instances of class String represent sequences of Unicode characters. A Stringobject has a constant (unchanging) value. String literals ($3.10.5) are references to

instances of class String.The string concatenation operator

+ ($15.18.1) implicitly creates a new
String object.

4.3.4   When Reference Types Are the Same
Two reference types are the same compile-time type if they have the same binaryname ($13.1), in which case they are sometimes said to be the same class or the

same interface.At run time, several reference types with the same binary name may be loaded
simultaneously by different class loaders. These types may or may not represent

4.4 Where Types Are Used TYPES, VALUES, AND VARIABLES
46 DRAFT

the same type declaration. Even if two such types do represent the same type dec-laration, they are considered distinct.

Two reference types are the same run-time type if:

* They are both class or both interface types, are loaded by the same classloader, and have the same binary name ($13.1), in which case they are sometimes said to be the same run-time class or the same run-time interface.

* They are both array types, and their component types are the same run-timetype($10).

4.4 Where Types Are Used
Types are used when they appear in declarations or in certain expressions.The following code fragment contains one or more instances of most kinds of
usage of a type:

import java.util.Random;
class MiscMath {

int divisor;
MiscMath(int divisor) {

this.divisor = divisor;
}

float ratio(long l) {

try {

l /= divisor;
} catch (Exception e) {

if (e instanceof ArithmeticException)

l = Long.MAX_VALUE;
else

l = 0;
}
return (float)l;
}

double gausser() {

Random r = new Random();
double[] val = new double[2];
val[0] = r.nextGaussian();
val[1] = r.nextGaussian();
return (val[0] + val[1]) / 2;
}

}

TYPES, VALUES, AND VARIABLES Variables 4.5

47DRAFT
In this example, types are used in declarations of the following:

* Imported types ($7.5); here the type Random, imported from the type

java.util.Random of the package java.util, is declared

* Fields, which are the class variables and instance variables of classes ($8.3),and constants of interfaces ($9.3); here the field

divisor in the class
MiscMath is declared to be of type int

* Method parameters ($8.4.1); here the parameter l of the method ratio isdeclared to be of type

long

* Method results ($8.4); here the result of the method ratio is declared to be oftype

float, and the result of the method gausser is declared to be of type
double

* Constructor parameters ($8.8.1); here the parameter of the constructor for

MiscMath is declared to be of type int

* Local variables ($14.4, $14.13); the local variables r and val of the method

gausser are declared to be of types Random and double[] (array of double)

* Exception handler parameters ($14.19); here the exception handler parameter

e of the catch clause is declared to be of type Exception

and in expressions of the following kinds:

* Class instance creations ($15.9); here a local variable r of method gausser isinitialized by a class instance creation expression that uses the type

Random

* Array creations ($15.10); here the local variable val of method gausser isinitialized by an array creation expression that creates an array of

doublewith size 2

* Casts ($15.16); here the return statement of the method ratio uses the

float type in a cast

* The instanceof operator ($15.20.2); here the instanceof operator testswhether

e is assignment compatible with the type ArithmeticException

4.5 Variables
A variable is a storage location and has an associated type, sometimes called itscompile-time type, that is either a primitive type ($4.2) or a reference type ($4.3).
A variable always contains a value that is assignment compatible ($5.2) with itstype. A variable's value is changed by an assignment ($15.26) or by a prefix or
postfix ++ (increment) or -- (decrement) operator ($15.14.1, $15.14.2, $15.15.1,$15.15.2).

4.5.1 Variables of Primitive Type TYPES, VALUES, AND VARIABLES
48 DRAFT

Compatibility of the value of a variable with its type is guaranteed by thedesign of the Java programming language. Default values are compatible ($4.5.5)
and all assignments to a variable are checked for assignment compatibility ($5.2),usually at compile time, but, in a single case involving arrays, a run-time check is
made ($10.10).

4.5.1   Variables of Primitive Type
A variable of a primitive type always holds a value of that exact primitive type.

4.5.2   Variables of Reference Type
A variable of reference type can hold either of the following:

* A null reference

* A reference to any object ($4.3) whose class ($4.5.6) is assignment compati-ble ($5.2) with the type of the variable

4.5.3   Kinds of Variables
There are seven kinds of variables:

1. A class variable is a field declared using the keyword static within a classdeclaration ($8.3.1.1), or with or without the keyword

static within an inter-face declaration ($9.3). A class variable is created when its class or interface is

prepared ($12.3.2) and is initialized to a default value ($4.5.5). The class vari-able effectively ceases to exist when its class or interface is unloaded ($12.7).

2. An instance variable is a field declared within a class declaration withoutusing the keyword

static ($8.3.1.1). If a class T has a field a that is aninstance variable, then a new instance variable

a is created and initialized to adefault value ($4.5.5) as part of each newly created object of class

T or of anyclass that is a subclass of
T ($8.1.3). The instance variable effectively ceasesto exist when the object of which it is a field is no longer referenced, after any

necessary finalization of the object ($12.6) has been completed.
3. Array components are unnamed variables that are created and initialized todefault values ($4.5.5) whenever a new object that is an array is created

($15.10). The array components effectively cease to exist when the array is nolonger referenced. See $10 for a description of arrays.

4. Method parameters ($8.4.1) name argument values passed to a method. Forevery parameter declared in a method declaration, a new parameter variable is

TYPES, VALUES, AND VARIABLES Kinds of Variables 4.5.3

49DRAFT
created each time that method is invoked ($15.12). The new variable is initial-ized with the corresponding argument value from the method invocation. The
method parameter effectively ceases to exist when the execution of the bodyof the method is complete.

5. Constructor parameters ($8.8.1) name argument values passed to a construc-tor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression ($15.9) orexplicit constructor invocation ($8.8.5) invokes that constructor. The new
variable is initialized with the corresponding argument value from the cre-ation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor iscomplete.

6. An exception-handler parameter is created each time an exception is caughtby a

catch clause of a try statement ($14.19). The new variable is initializedwith the actual object associated with the exception ($11.3, $14.17). The

exception-handler parameter effectively ceases to exist when execution of theblock associated with the

catch clause is complete.

7. Local variables are declared by local variable declaration statements ($14.4).Whenever the flow of control enters a block ($14.2) or

for statement($14.13), a new variable is created for each local variable declared in a local

variable declaration statement immediately contained within that block or forstatement. A local variable declaration statement may contain an expression
which initializes the variable. The local variable with an initializing expres-sion is not initialized, however, until the local variable declaration statement
that declares it is executed. (The rules of definite assignment ($16) prevent thevalue of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist whenthe execution of the block or

for statement is complete.

Were it not for one exceptional situation, a local variable could always beregarded as being created when its local variable declaration statement is executed. The exceptional situation involves the switch statement ($14.10),where it is possible for control to enter a block but bypass execution of a local
variable declaration statement. Because of the restrictions imposed by therules of definite assignment ($16), however, the local variable declared by
such a bypassed local variable declaration statement cannot be used before ithas been definitely assigned a value by an assignment expression ($15.26).

The following example contains several different kinds of variables:

4.5.4 final Variables TYPES, VALUES, AND VARIABLES
50 DRAFT

class Point {

static int numPoints; // numPoints is a class variable
int x, y; // x and y are instance variables
int[] w = new int[10]; // w[0] is an array component
int setX(int x) { // x is a method parameter

int oldx = this.x; // oldx is a local variable
this.x = x;
return oldx;
}
}

4.5.4 final Variables
A variable can be declared final. A final variable may only be assigned to once.It is a compile time error if a final variable is assigned to unless it is definitely

unassigned ($16) immediately prior to the assignment.A blank final is a final variable whose declaration lacks an initializer.

Once a final variable has been assigned, it always contains the same value.If a
final variable holds a reference to an object, then the state of the object maybe changed by operations on the object, but the variable will always refer to the

same object. This applies also to arrays, because arrays are objects; if a finalvariable holds a reference to an array, then the components of the array may be
changed by operations on the array, but the variable will always refer to the samearray.

Declaring a variable final can serve as useful documentation that its valuewill not change and can help avoid programming errors.
In the example:
class Point {

int x, y;
int useCount;
Point(int x, int y) { this.x = x; this.y = y; }
final static Point origin = new Point(0, 0);
}

the class Point declares a final class variable origin. The origin variableholds a reference to an object that is an instance of class

Point whose coordinatesare (0, 0). The value of the variable
Point.origin can never change, so it alwaysrefers to the same
Point object, the one created by its initializer. However, anoperation on this
Point object might change its state--for example, modifying its
useCount or even, misleadingly, its x or y coordinate.

4.5.5 Initial Values of Variables
Every variable in a program must have a value before its value is used:

TYPES, VALUES, AND VARIABLES Initial Values of Variables 4.5.5

51DRAFT

* Each class variable, instance variable, or array component is initialized with adefault value when it is created ($15.9, $15.10):

u For type byte, the default value is zero, that is, the value of (byte)0.
u For type short, the default value is zero, that is, the value of (short)0.
u For type int, the default value is zero, that is, 0.
u For type long, the default value is zero, that is, 0L.
u For type float, the default value is positive zero, that is, 0.0f.
u For type double, the default value is positive zero, that is, 0.0d.
u For type char, the default value is the null character, that is, '\u0000'.
u For type boolean, the default value is false.
u For all reference types ($4.3), the default value is null.

* Each method parameter ($8.4.1) is initialized to the corresponding argumentvalue provided by the invoker of the method ($15.12).

* Each constructor parameter ($8.8.1) is initialized to the corresponding argu-ment value provided by a class instance creation expression ($15.9) or explicit

constructor invocation ($8.8.5).

* An exception-handler parameter ($14.19) is initialized to the thrown objectrepresenting the exception ($11.3, $14.17).

* A local variable ($14.4, $14.13) must be explicitly given a value before it isused, by either initialization ($14.4) or assignment ($15.26), in a way that can

be verified by the compiler using the rules for definite assignment ($16).
The example program:
class Point {

static int npoints;
int x, y;
Point root;
}

class Test {

public static void main(String[] args) {

System.out.println("npoints=" + Point.npoints);
Point p = new Point();
System.out.println("p.x=" + p.x + ", p.y=" + p.y);
System.out.println("p.root=" + p.root);
}
}

4.5.6 Types, Classes, and Interfaces TYPES, VALUES, AND VARIABLES
52 DRAFT

prints:

npoints=0
p.x=0, p.y=0
p.root=null

illustrating the default initialization of npoints, which occurs when the class
Point is prepared ($12.3.2), and the default initialization of x, y, and root, whichoccurs when a new

Point is instantiated. See $12 for a full description of allaspects of loading, linking, and initialization of classes and interfaces, plus a

description of the instantiation of classes to make new class instances.

4.5.6 Types, Classes, and Interfaces
In the Java programming language, every variable and every expression has a typethat can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Referencetypes are introduced by type declarations, which include class declarations ($8.1)
and interface declarations ($9.1). We often use the term type to refer to either aclass or an interface.

Every object belongs to some particular class: the class that was mentioned inthe creation expression that produced the object, the class whose

Class objectwas used to invoke a reflective method to produce the object, or the

String classfor objects implicitly created by the string concatenation operator
+ ($15.18.1).This class is called the class of the object. (Arrays also have a class, as described

at the end of this section.) An object is said to be an instance of its class and of allsuperclasses of its class.

Sometimes a variable or expression is said to have a "run-time type". Thisrefers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not null.The compile time type of a variable is always declared, and the compile time
type of an expression can be deduced at compile time. The compile time type lim-its the possible values that the variable can hold or the expression can produce at
run time. If a run-time value is a reference that is not null, it refers to an object orarray that has a class, and that class will necessarily be compatible with the compile-time type.Even though a variable or expression may have a compile-time type that is an
interface type, there are no instances of interfaces. A variable or expression whosetype is an interface type can reference any object whose class implements ($8.1.4)
that interface.Here is an example of creating new objects and of the distinction between the
type of a variable and the class of an object:

TYPES, VALUES, AND VARIABLES Types, Classes, and Interfaces 4.5.6

53DRAFT
public interface Colorable {

void setColor(byte r, byte g, byte b);
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {

byte r, g, b;
public void setColor(byte rv, byte gv, byte bv) {

r = rv; g = gv; b = bv;
}

}
class Test {

public static void main(String[] args) {

Point p = new Point();
ColoredPoint cp = new ColoredPoint();
p = cp;
Colorable c = cp;
}
}

In this example:

* The local variable p of the method main of class Test has type Point and isinitially assigned a reference to a new instance of class

Point.

* The local variable cp similarly has as its type ColoredPoint, and is initiallyassigned a reference to a new instance of class

ColoredPoint.

* The assignment of the value of cp to the variable p causes p to hold a refer-ence to a

ColoredPoint object. This is permitted because ColoredPoint is asubclass of

Point, so the class ColoredPoint is assignment compatible($5.2) with the type

Point. A ColoredPoint object includes support for allthe methods of a
Point. In addition to its particular fields r, g, and b, it hasthe fields of class

Point, namely x and y.

* The local variable c has as its type the interface type Colorable, so it canhold a reference to any object whose class implements

Colorable; specifi-cally, it can hold a reference to a
ColoredPoint.

* Note that an expression such as "new Colorable()" is not valid because it isnot possible to create an instance of an interface, only of a class.

Every array also has a class; the method getClass, when invoked for an arrayobject, will return a class object (of class

Class) that represents the class of thearray.

4.5.6 Types, Classes, and Interfaces TYPES, VALUES, AND VARIABLES

54 DRAFT

The classes for arrays have strange names that are not valid identifiers; forexample, the class for an array of

int components has the name "[I" and so thevalue of the expression:

new int[10].getClass().getName()
is the string "[I"; see the specification of Class.getName for details.

55DRAFT
C H A P T E R 5
Conversions and Promotions

EVERY expression written in the Java programming language has a type thatcan be deduced from the structure of the expression and the types of the literals,
variables, and methods mentioned in the expression. It is possible, however, towrite an expression in a context where the type of the expression is not appropriate. In some cases, this leads to an error at compile time; for example, if theexpression in an

if statement ($14.9) has any type other than boolean, a com-pile-time error occurs. In other cases, the context may be able to accept a type that

is related to the type of the expression; as a convenience, rather than requiring theprogrammer to indicate a type conversion explicitly, the language performs an
implicit conversion from the type of the expression to a type acceptable for its sur-rounding context.

A specific conversion from type S to type T allows an expression of type S tobe treated at compile time as if it had type

T instead. In some cases this willrequire a corresponding action at run time to check the validity of the conversion

or to translate the run-time value of the expression into a form appropriate for thenew type

T. For example:

* A conversion from type Object to type Thread requires a run-time check tomake sure that the run-time value is actually an instance of class

Thread orone of its subclasses; if it is not, an exception is thrown.

* A conversion from type Thread to type Object requires no run-time action;

Thread is a subclass of Object, so any reference produced by an expressionof type

Thread is a valid reference value of type Object.

* A conversion from type int to type long requires run-time sign-extension ofa 32-bit integer value to the 64-bit

long representation. No information islost.

A conversion from type double to type long requires a nontrivial translationfrom a 64-bit floating-point value to the 64-bit integer representation. Depending
on the actual run-time value, information may be lost.

5 Conversions and Promotions CONVERSIONS AND PROMOTIONS

56 DRAFT

In every conversion context, only certain specific conversions are permitted.For convenience of description, the specific conversions that are possible in the
Java programming language are grouped into several broad categories:

* Identity conversions

* Widening primitive conversions

* Narrowing primitive conversions

* Widening reference conversions

* Narrowing reference conversions

* String conversions

* Value set conversions

There are five conversion contexts in which conversion of expressions mayoccur. Each context allows conversions in some of the categories named above but
not others. The term "conversion" is also used to describe the process of choosinga specific conversion for such a context. For example, we say that an expression
that is an actual argument in a method invocation is subject to "method invocationconversion," meaning that a specific conversion will be implicitly chosen for that
expression according to the rules for the method invocation argument context.One conversion context is the operand of a numeric operator such as

+ or *.The conversion process for such operands is called numeric promotion. Promotion

is special in that, in the case of binary operators, the conversion chosen for oneoperand may depend in part on the type of the other operand expression.

This chapter first describes the seven categories of conversions ($5.1), includ-ing the special conversions to

String allowed for the string concatenation opera-tor
+. Then the five conversion contexts are described:

* Assignment conversion ($5.2, $15.26) converts the type of an expression tothe type of a specified variable. The conversions permitted for assignment are

limited in such a way that assignment conversion never causes an exception.

* Method invocation conversion ($5.3, $15.9, $15.12) is applied to each argu-ment in a method or constructor invocation and, except in one case, performs

the same conversions that assignment conversion does. Method invocationconversion never causes an exception.

* Casting conversion ($5.5) converts the type of an expression to a type explic-itly specified by a cast operator ($15.16). It is more inclusive than assignment

or method invocation conversion, allowing any specific conversion other thana string conversion, but certain casts to a reference type may cause an exception at run time.

CONVERSIONS AND PROMOTIONS Conversions and Promotions 5

57DRAFT

* String conversion ($5.4, $15.18.1) allows any type to be converted to type

String.

* Numeric promotion ($5.6) brings the operands of a numeric operator to acommon type so that an operation can be performed.

Here are some examples of the various contexts for conversion:
class Test {

public static void main(String[] args) {

// Casting conversion ($5.4) of a float literal to
// type int. Without the cast operator, this would
// be a compile-time error, because this is a
// narrowing conversion ($5.1.3):
int i = (int)12.5f;

// String conversion ($5.4) of i's int value:
System.out.println("(int)12.5f==" + i);

// Assignment conversion ($5.2) of i's value to type
// float. This is a widening conversion ($5.1.2):
float f = i;

// String conversion of f's float value:
System.out.println("after float widening: " + f);

// Numeric promotion ($5.6) of i's value to type
// float. This is a binary numeric promotion.
// After promotion, the operation is float*float:
System.out.print(f);
f = f * i;

// Two string conversions of i and f:
System.out.println("*" + i + "==" + f);

// Method invocation conversion ($5.3) of f 's value
// to type double, needed because the method Math.sin
// accepts only a double argument:
double d = Math.sin(f);

// Two string conversions of f and d:
System.out.println("Math.sin(" + f + ")==" + d);

}
}
which produces the output:

(int)12.5f==12
after float widening: 12.0

5.1 Kinds of Conversion CONVERSIONS AND PROMOTIONS
58 DRAFT

12.0*12==144.0
Math.sin(144.0)==-0.49102159389846934

5.1   Kinds of Conversion
Specific type conversions in the Java programming language are divided intoseven categories.

5.1.1   Identity Conversions
A conversion from a type to that same type is permitted for any type.This may seem trivial, but it has two practical consequences. First, it is always

permitted for an expression to have the desired type to begin with, thus allowingthe simply stated rule that every expression is subject to conversion, if only a trivial identity conversion. Second, it implies that it is permitted for a program toinclude redundant cast operators for the sake of clarity.

The only permitted conversion that involves the type boolean is the identityconversion from

boolean to boolean.

5.1.2 Widening Primitive Conversion
The following 19 specific conversions on primitive types are called the wideningprimitive conversions:

* byte to short, int, long, float, or double

* short to int, long, float, or double

* char to int, long, float, or double

* int to long, float, or double

* long to float or double

* float to double

Widening primitive conversions do not lose information about the overallmagnitude of a numeric value. Indeed, conversions widening from an integral type
to another integral type and from float to double do not lose any information atall; the numeric value is preserved exactly. Conversions widening from

float to
double in strictfp expressions also preserve the numeric value exactly; how-ever, such conversions that are not

strictfp may lose information about theoverall magnitude of the converted value.

CONVERSIONS AND PROMOTIONS Narrowing Primitive Conversions 5.1.3

59DRAFT
Conversion of an int or a long value to float, or of a long value to double,may result in loss of precision--that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be acorrectly rounded version of the integer value, using IEEE 754 round-to-nearest
mode ($4.2.4).A widening conversion of a signed integer value to an integral type

T simplysign-extends the two's-complement representation of the integer value to fill the

wider format. A widening conversion of a character to an integral type T zero-extends the representation of the character value to fill the wider format.

Despite the fact that loss of precision may occur, widening conversionsamong primitive types never result in a run-time exception ($11).
Here is an example of a widening conversion that loses precision:
class Test {

public static void main(String[] args) {

int big = 1234567890;
float approx = big;
System.out.println(big - (int)approx);
}
}

which prints:

-46
thus indicating that information was lost during the conversion from type int totype

float because values of type float are not precise to nine significant digits.

5.1.3 Narrowing Primitive Conversions
The following 23 specific conversions on primitive types are called the narrowingprimitive conversions:

* byte to char

* short to byte or char

* char to byte or short

* int to byte, short, or char

* long to byte, short, char, or int

* float to byte, short, char, int, or long

* double to byte, short, char, int, long, or float

Narrowing conversions may lose information about the overall magnitude of anumeric value and may also lose precision.

5.1.3 Narrowing Primitive Conversions CONVERSIONS AND PROMOTIONS
60 DRAFT

A narrowing conversion of a signed integer to an integral type T simply dis-cards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude ofthe numeric value, this may cause the sign of the resulting value to differ from the
sign of the input value.A narrowing conversion of a character to an integral type

T likewise simplydiscards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude ofthe numeric value, this may cause the resulting value to be a negative number,
even though characters represent 16-bit unsigned integer values.A narrowing conversion of a floating-point number to an integral type

T takestwo steps:

1. In the first step, the floating-point number is converted either to a long, if T is

long, or to an int, if T  is byte, short, char, or int, as follows:

u If the floating-point number is NaN ($4.2.3), the result of the first step of theconversion is an

int or long 0.

u Otherwise, if the floating-point number is not an infinity, the floating-pointvalue is rounded to an integer value

V, rounding toward zero using IEEE754 round-toward-zero mode ($4.2.3). Then there are two cases:

v If T is long, and this integer value can be represented as a long, then theresult of the first step is the

long value V.

v Otherwise, if this integer value can be represented as an int, then theresult of the first step is the

int value V.

u Otherwise, one of the following two cases must be true:

v The value must be too small (a negative value of large magnitude or nega-tive infinity), and the result of the first step is the smallest representable

value of type int or long.
v The value must be too large (a positive value of large magnitude or posi-tive infinity), and the result of the first step is the largest representable

value of type int or long.
2. In the second step:

u If T is int or long, the result of the conversion is the result of the first step.
u If T is byte, char, or short, the result of the conversion is the result of anarrowing conversion to type

T ($5.1.3) of the result of the first step.

The example:

CONVERSIONS AND PROMOTIONS Narrowing Primitive Conversions 5.1.3

61DRAFT
class Test {

public static void main(String[] args) {

float fmin = Float.NEGATIVE_INFINITY;
float fmax = Float.POSITIVE_INFINITY;
System.out.println("long: " + (long)fmin +

".." + (long)fmax);
System.out.println("int: " + (int)fmin +

".." + (int)fmax);
System.out.println("short: " + (short)fmin +

".." + (short)fmax);
System.out.println("char: " + (int)(char)fmin +

".." + (int)(char)fmax);
System.out.println("byte: " + (byte)fmin +

".." + (byte)fmax);
}
}

produces the output:

long: -9223372036854775808..9223372036854775807
int: -2147483648..2147483647
short: 0..-1
char: 0..65535
byte: 0..-1

The results for char, int, and long are unsurprising, producing the minimumand maximum representable values of the type.

The results for byte and short lose information about the sign and magni-tude of the numeric values and also lose precision. The results can be understood
by examining the low order bits of the minimum and maximum int. The mini-mum

int is, in hexadecimal, 0x80000000, and the maximum int is 0x7fffffff.This explains the

short results, which are the low 16 bits of these values, namely,
0x0000 and 0xffff; it explains the char results, which also are the low 16 bits ofthese values, namely,

'\u0000' and '\uffff'; and it explains the byte results,which are the low 8 bits of these values, namely,

0x00 and 0xff.Despite the fact that overflow, underflow, or other loss of information may

occur, narrowing conversions among primitive types never result in a run-timeexception ($11).

Here is a small test program that demonstrates a number of narrowing conver-sions that lose information:

class Test {

public static void main(String[] args) {

// A narrowing of int to short loses high bits:
System.out.println("(short)0x12345678==0x" +

Integer.toHexString((short)0x12345678));

5.1.4 Widening Reference Conversions CONVERSIONS AND PROMOTIONS
62 DRAFT

// A int value not fitting in byte changes sign and magnitude:
System.out.println("(byte)255==" + (byte)255);

// A float value too big to fit gives largest int value:
System.out.println("(int)1e20f==" + (int)1e20f);

// A NaN converted to int yields zero:
System.out.println("(int)NaN==" + (int)Float.NaN);

// A double value too large for float yields infinity:
System.out.println("(float)-1e100==" + (float)-1e100);

// A double value too small for float underflows to zero:
System.out.println("(float)1e-50==" + (float)1e-50);

}
}

This test program produces the following output:

(short)0x12345678==0x5678
(byte)255==-1
(int)1e20f==2147483647
(int)NaN==0
(float)-1e100==-Infinity(float)1e-50==0.0

5.1.4   Widening Reference Conversions
The following conversions are called the widening reference conversions:

* From any class type S to any class type T, provided that S is a subclass of T.(An important special case is that there is a widening conversion to the class

type Object from any other class type.)

* From any class type S to any interface type K, provided that S implements K.

* From the null type to any class type, interface type, or array type.

* From any interface type J to any interface type K, provided that J is a sub-interface of

K.

* From any interface type to type Object.

* From any array type to type Object.

* From any array type to type Cloneable.

* From any array type to type java.io.Serializable

CONVERSIONS AND PROMOTIONS String Conversions 5.1.6

63DRAFT

* From any array type SC[] to any array type TC[], provided that SC and TCare reference types and there is a widening conversion from

SC to TC.

Such conversions never require a special action at run time and therefore neverthrow an exception at run time. They consist simply in regarding a reference as
having some other type in a manner that can be proved correct at compile time.See $8 for the detailed specifications for classes, $9 for interfaces, and $10 for
arrays.

5.1.5   Narrowing Reference Conversions
The following conversions are called the narrowing reference conversions:

* From any class type S to any class type T, provided that S is a superclass of T.(An important special case is that there is a narrowing conversion from the

class type Object to any other class type.)

* From any class type S to any interface type K, provided that S is not final anddoes not implement

K. (An important special case is that there is a narrowingconversion from the class type

Object to any interface type.)

* From type Object to any array type.

* From type Object to any interface type.

* From any interface type J to any class type T that is not final.

* From any interface type J to any class type T that is final, provided that Timplements

J.

* From any interface type J to any interface type K, provided that J is not a sub-interface of

K and there is no method name m such that J and K both contain amethod named

m with the same signature but different return types.

* From any array type SC[] to any array type TC[], provided that SC and TCare reference types and there is a narrowing conversion from

SC to TC.

Such conversions require a test at run time to find out whether the actual referencevalue is a legitimate value of the new type. If not, then a

ClassCastException isthrown.

5.1.6   String Conversions
There is a string conversion to type String from every other type, including thenull type.

5.1.7 Forbidden Conversions CONVERSIONS AND PROMOTIONS
64 DRAFT

5.1.7   Forbidden Conversions

* There is no permitted conversion from any reference type to any primitivetype.

* Except for the string conversions, there is no permitted conversion from anyprimitive type to any reference type.

* There is no permitted conversion from the null type to any primitive type.

* There is no permitted conversion to the null type other than the identity con-version.

* There is no permitted conversion to the type boolean other than the identityconversion.

* There is no permitted conversion from the type boolean other than the iden-tity conversion and string conversion.

* There is no permitted conversion other than string conversion from class type

S to a different class type T if S is not a subclass of T and T is not a subclassof

S.

* There is no permitted conversion from class type S to interface type K if S is

final and does not implement K.

* There is no permitted conversion from class type S to any array type if S is not

Object.

* There is no permitted conversion other than string conversion from interfacetype

J to class type T if T is final and does not implement J.

* There is no permitted conversion from interface type J to interface type K if Jand

K contain methods with the same signature but different return types.

* There is no permitted conversion from any array type to any class type otherthan

Object or String.

* There is no permitted conversion from any array type to any interface type,except to the interface types

java.io.Serializable and Cloneable, whichare implemented by all arrays.

* There is no permitted conversion from array type SC[] to array type TC[] ifthere is no permitted conversion other than a string conversion from

SC to TC .

CONVERSIONS AND PROMOTIONS Value Set Conversion 5.1.8

65DRAFT
5.1.8   Value Set Conversion
Value set conversion is the process of mapping a floating-point value from onevalue set to another without changing its type.

Within an expression that is not FP-strict ($15.4), value set conversion pro-vides choices to an implementation of the Java programming language:

* If the value is an element of the float-extended-exponent value set, then theimplementation may, at its option, map the value to the nearest element of the

float value set. This conversion may result in overflow (in which case thevalue is replaced by an infinity of the same sign) or underflow (in which case
the value may lose precision because it is replaced by a denormalized numberor zero of the same sign).

* If the value is an element of the double-extended-exponent value set, then theimplementation may, at its option, map the value to the nearest element of the

double value set. This conversion may result in overflow (in which case thevalue is replaced by an infinity of the same sign) or underflow (in which case
the value may lose precision because it is replaced by a denormalized numberor zero of the same sign).

Within an FP-strict expression ($15.4), value set conversion does not provideany choices; every implementation must behave in the same way:

* If the value is of type float and is not an element of the float value set, thenthe implementation must map the value to the nearest element of the float

value set. This conversion may result in overflow or underflow.

* If the value is of type double and is not an element of the double value set,then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow.
Within an FP-strict expression, mapping values from the float-extended-exponentvalue set or double-extended-exponent value set is necessary only when a method
is invoked whose declaration is not FP-strict and the implementation has chosento represent the result of the method invocation as an element of an extendedexponent value set.Whether in FP-strict code or code that is not FP-strict, value set conversion
always leaves unchanged any value whose type is neither float nor double.

5.2 Assignment Conversion CONVERSIONS AND PROMOTIONS

66 DRAFT

5.2   Assignment Conversion
Assignment conversion occurs when the value of an expression is assigned($15.26) to a variable: the type of the expression must be converted to the type of
the variable. Assignment contexts allow the use of an identity conversion ($5.1.1),a widening primitive conversion ($5.1.2), or a widening reference conversion
($5.1.4). In addition, a narrowing primitive conversion may be used if all of thefollowing conditions are satisfied:

* The expression is a constant expression of type byte, short, char or int.

* The type of the variable is byte, short, or char.

* The value of the expression (which is known at compile time, because it is aconstant expression) is representable in the type of the variable.

If the type of the expression cannot be converted to the type of the variable by aconversion permitted in an assignment context, then a compile-time error occurs.

If the type of the variable is float or double, then value set conversion isapplied after the type conversion:

* If the value is of type float and is an element of the float-extended-exponentvalue set, then the implementation must map the value to the nearest element

of the float value set. This conversion may result in overflow or underflow.

* If the value is of type double and is an element of the double-extended-expo-nent value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow orunderflow.

If the type of an expression can be converted to the type of a variable byassignment conversion, we say the expression (or its value) is assignable to the
variable or, equivalently, that the type of the expression is assignment compatiblewith the type of the variable.

An assignment conversion never causes an exception. (Note, however, that anassignment may result in an exception in a special case involving array elements
--see $10.10 and $15.26.1.)The compile-time narrowing of constants means that code such as:

byte theAnswer = 42;
is allowed. Without the narrowing, the fact that the integer literal 42 has type intwould mean that a cast to

byte would be required:

byte theAnswer = (byte)42; // cast is permitted but not required

CONVERSIONS AND PROMOTIONS Assignment Conversion 5.2

67DRAFT
A value of primitive type must not be assigned to a variable of reference type;an attempt to do so will result in a compile-time error. A value of type

booleancan be assigned only to a variable of type
boolean.The following test program contains examples of assignment conversion of

primitive values:

class Test {

public static void main(String[] args) {

short s = 12; // narrow 12 to short
float f = s; // widen short to float
System.out.println("f=" + f);

char c = '\u0123';
long l = c; // widen char to long
System.out.println("l=0x" + Long.toString(l,16));

f = 1.23f;
double d = f; // widen float to double
System.out.println("d=" + d);
}
}

It produces the following output:

f=12.0
l=0x123
d=1.2300000190734863

The following test, however, produces compile-time errors:

class Test {

public static void main(String[] args) {

short s = 123;
char c = s; // error: would require cast
s = c; // error: would require cast
}
}

because not all short values are char values, and neither are all char values
short values.A value of the null type (the null reference is the only such value) may be

assigned to any reference type, resulting in a null reference of that type.Here is a sample program illustrating assignments of references:

public class Point { int x, y; }
public class Point3D extends Point { int z; }
public interface Colorable {

void setColor(int color);
}

5.2 Assignment Conversion CONVERSIONS AND PROMOTIONS
68 DRAFT

public class ColoredPoint extends Point implements Colorable
{

int color;
public void setColor(int color) { this.color = color; }
}

class Test {

public static void main(String[] args) {

// Assignments to variables of class type:
Point p = new Point();
p = new Point3D(); // ok: because Point3D is a

// subclass of Point

Point3D p3d = p; // error: will require a cast because a

// Point might not be a Point3D
// (even though it is, dynamically,
// in this example.)

// Assignments to variables of type Object:
Object o = p; // ok: any object to Object
int[] a = new int[3];
Object o2 = a; // ok: an array to Object

// Assignments to variables of interface type:
ColoredPoint cp = new ColoredPoint();
Colorable c = cp; // ok: ColoredPoint implements

// Colorable

// Assignments to variables of array type:
byte[] b = new byte[4];
a = b; // error: these are not arrays

// of the same primitive type
Point3D[] p3da = new Point3D[3];
Point[] pa = p3da; // ok: since we can assign a

// Point3D to a Point
p3da = pa; // error: (cast needed) since a Point

// can't be assigned to a Point3D

}
}

Assignment of a value of compile-time reference type S (source) to a variableof compile-time reference type

T (target) is checked as follows:

* If S is a class type:

u If T is a class type, then S must either be the same class as T, or S must be asubclass of

T, or a compile-time error occurs.

u If T is an interface type, then S must implement interface T, or a compile-time error occurs.

CONVERSIONS AND PROMOTIONS Assignment Conversion 5.2

69DRAFT
u If T is an array type, then a compile-time error occurs.

* If S is an interface type:

u If T is a class type, then T must be Object, or a compile-time error occurs.
u If T is an interface type, then T must be either the same interface as S or asuperinterface of

S, or a compile-time error occurs.

u If T is an array type, then a compile-time error occurs.

* If S is an array type SC[], that is, an array of components of type SC:

u If T is a class type, then T must be Object, or a compile-time error occurs.
u If T is an interface type, then a compile-time error occurs unless T is thetype

java.io.Serializable or the type Cloneable, the only interfacesimplemented by arrays.

u If T is an array type TC[], that is, an array of components of type TC, then acompile-time error occurs unless one of the following is true:

v TC and SC are the same primitive type.
v TC and SC are both reference types and type SC is assignable to TC, asdetermined by a recursive application of these compile-time rules for

assignability.
See $8 for the specification of classes, $9 for interfaces, and $10 for arrays.The following test program illustrates assignment conversions on reference

values, but fails to compile because it violates the preceding rules, as described inits comments. This example should be compared to the preceding one.

public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable
{

int color;
public void setColor(int color) { this.color = color; }
}

class Test {

public static void main(String[] args) {

Point p = new Point();
ColoredPoint cp = new ColoredPoint();
// Okay because ColoredPoint is a subclass of Point:
p = cp;

5.2 Assignment Conversion CONVERSIONS AND PROMOTIONS
70 DRAFT

// Okay because ColoredPoint implements Colorable:
Colorable c = cp;

// The following cause compile-time errors because
// we cannot be sure they will succeed, depending on
// the run-time type of p; a run-time check will be
// necessary for the needed narrowing conversion and
// must be indicated by including a cast:
cp = p; // p might be neither a ColoredPoint

// nor a subclass of ColoredPoint
c = p; // p might not implement Colorable

}
}
Here is another example involving assignment of array objects:

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {

public static void main(String[] args) {

long[] veclong = new long[100];
Object o = veclong; // okay
Long l = veclong; // compile-time error
short[] vecshort = veclong; // compile-time error
Point[] pvec = new Point[100];
ColoredPoint[] cpvec = new ColoredPoint[100];
pvec = cpvec; // okay
pvec[0] = new Point(); // okay at compile time,

// but would throw an
// exception at run time
cpvec = pvec; // compile-time error
}
}

In this example:

* The value of veclong cannot be assigned to a Long variable, because Longis a class type other than

Object. An array can be assigned only to a variableof a compatible array type, or to a variable of type

Object.

* The value of veclong cannot be assigned to vecshort, because they arearrays of primitive type, and

short and long are not the same primitive type.

* The value of cpvec can be assigned to pvec, because any reference thatcould be the value of an expression of type

ColoredPoint can be the value ofa variable of type
Point. The subsequent assignment of the new Point to acomponent of
pvec then would throw an ArrayStoreException (if the pro-gram were otherwise corrected so that it could be compiled), because a

CONVERSIONS AND PROMOTIONS Method Invocation Conversion 5.3

71DRAFT
ColoredPoint array can't have an instance of Point as the value of a com-ponent.

* The value of pvec cannot be assigned to cpvec, because not every referencethat could be the value of an expression of type

ColoredPoint can correctlybe the value of a variable of type
Point. If the value of pvec at run time werea reference to an instance of
Point[], and the assignment to cpvec wereallowed, a simple reference to a component of

cpvec, say, cpvec[0], couldreturn a
Point, and a Point is not a ColoredPoint. Thus to allow such anassignment would allow a violation of the type system. A cast may be used

($5.5, $15.16) to ensure that pvec references a ColoredPoint[]:

cpvec = (ColoredPoint[])pvec; // okay, but may throw an

// exception at run time

5.3   Method Invocation Conversion
Method invocation conversion is applied to each argument value in a method orconstructor invocation ($15.9, $15.12): the type of the argument expression must
be converted to the type of the corresponding parameter. Method invocation con-texts allow the use of an identity conversion ($5.1.1), a widening primitive conversion ($5.1.2), or a widening reference conversion ($5.1.4).If the type of an argument expression is either

float or double, then valueset conversion ($5.1.8) is applied after the type conversion:

* If an argument value of type float is an element of the float-extended-expo-nent value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow orunderflow.

* If an argument value of type double is an element of the double-extended-exponent value set, then the implementation must map the value to the nearest

element of the double value set. This conversion may result in overflow orunderflow.

Method invocation conversions specifically do not include the implicit nar-rowing of integer constants which is part of assignment conversion ($5.2). The
designers of the Java programming language felt that including these implicit nar-rowing conversions would add additional complexity to the overloaded method
matching resolution process ($15.12.2). Thus, the example:

class Test {

static int m(byte a, int b) { return a+b; }

5.4 String Conversion CONVERSIONS AND PROMOTIONS
72 DRAFT

static int m(short a, short b) { return a-b; }
public static void main(String[] args) {

System.out.println(m(12, 2)); // compile-time error
}

}

causes a compile-time error because the integer literals 12 and 2 have type int, soneither method

m matches under the rules of ($15.12.2). A language that includedimplicit narrowing of integer constants would need additional rules to resolve

cases like this example.

5.4 String Conversion
String conversion applies only to the operands of the binary + operator when oneof the arguments is a

String. In this single special case, the other argument to the
+ is converted to a String, and a new String which is the concatenation of thetwo strings is the result of the

+. String conversion is specified in detail within thedescription of the string concatenation

+ operator ($15.18.1).

5.5   Casting Conversion
Casting conversion is applied to the operand of a cast operator ($15.16): the typeof the operand expression must be converted to the type explicitly named by the
cast operator. Casting contexts allow the use of an identity conversion ($5.1.1), awidening primitive conversion ($5.1.2), a narrowing primitive conversion
($5.1.3), a widening reference conversion ($5.1.4), or a narrowing reference con-version ($5.1.5). Thus casting conversions are more inclusive than assignment or
method invocation conversions: a cast can do any permitted conversion other thana string conversion.

Value set conversion ($5.1.8) is applied after the type conversion.Some casts can be proven incorrect at compile time; such casts result in a
compile-time error.A value of a primitive type can be cast to another primitive type by identity
conversion, if the types are the same, or by a widening primitive conversion or anarrowing primitive conversion.

A value of a primitive type cannot be cast to a reference type by casting con-version, nor can a value of a reference type be cast to a primitive type.
The remaining cases involve conversion between reference types. Thedetailed rules for compile-time correctness checking of a casting conversion of a

CONVERSIONS AND PROMOTIONS Casting Conversion 5.5

73DRAFT
value of compile-time reference type S (source) to a compile-time reference type
T (target) are as follows:

* If S is a class type:

u If T is a class type, then S and T must be related classes--that is, S and Tmust be the same class, or

S a subclass of T, or T a subclass of S; otherwisea compile-time error occurs.

u If T is an interface type:

v If S is not a final class ($8.1.1), then the cast is always correct at com-pile time (because even if

S does not implement T, a subclass of S might).

v If S is a final class ($8.1.1), then S must implement T, or a compile-time error occurs.

u If T is an array type, then S must be the class Object, or a compile-timeerror occurs.

* If S is an interface type:

u If T is an array type, then T must implement S, or a compile-time erroroccurs.

u If T is a class type that is not final ($8.1.1), then the cast is always correctat compile time (because even if

T does not implement S, a subclass of Tmight).

u If T is an interface type and if T and S contain methods with the same signa-ture ($8.4.2) but different return types, then a compile-time error occurs.

* If S is an array type SC[], that is, an array of components of type SC :

u If T is a class type, then if T is not Object, then a compile-time error occurs(because

Object is the only class type to which arrays can be assigned).

u If T is an interface type, then a compile-time error occurs unless T is thetype

java.io.Serializable or the type Cloneable, the only interfacesimplemented by arrays.

u If T is an array type TC[], that is, an array of components of type TC, then acompile-time error occurs unless one of the following is true:

v TC  and SC are the same primitive type.
v TC and SC are reference types and type SC can be cast to TC by a recursiveapplication of these compile-time rules for casting.

See $8 for the specification of classes, $9 for interfaces, and $10 for arrays.

5.5 Casting Conversion CONVERSIONS AND PROMOTIONS
74 DRAFT

If a cast to a reference type is not a compile-time error, there are two cases:

* The cast can be determined to be correct at compile time. A cast from thecompile-time type

S to compile-time type T is correct at compile time if andonly if
S can be converted to T by assignment conversion ($5.2).

* The cast requires a run-time validity check. If the value at run time is null,then the cast is allowed. Otherwise, let

R be the class of the object referred toby the run-time reference value, and let

T be the type named in the cast opera-tor. A cast conversion must check, at run time, that the class

R is assignmentcompatible with the type
T, using the algorithm specified in $5.2 but using theclass
R instead of the compile-time type S as specified there. (Note that R can-not be an interface when these rules are first applied for any given cast, but

Rmay be an interface if the rules are applied recursively because the run-time

reference value may refer to an array whose element type is an interface type.)The modified algorithm is shown here:

u If R is an ordinary class (not an array class):

v If T is a class type, then R must be either the same class ($4.3.4) as T or asubclass of

T, or a run-time exception is thrown.

v If T is an interface type, then R must implement ($8.1.4) interface T, or arun-time exception is thrown.

v If T is an array type, then a run-time exception is thrown.
u If R is an interface:

v If T is a class type, then T must be Object ($4.3.2), or a run-time excep-tion is thrown.

v If T is an interface type, then R must be either the same interface as T or asubinterface of

T, or a run-time exception is thrown.

v If T is an array type, then a run-time exception is thrown.
u If R is a class representing an array type RC[]--that is, an array of compo-nents of type

RC:

v If T is a class type, then T must be Object ($4.3.2), or a run-time excep-tion is thrown.

v If T is an interface type, then a run-time exception is thrown unless T isthe type

java.io.Serializable or the type Cloneable, the only inter-faces implemented by arrays (this case could slip past the compile-time

checking if, for example, a reference to an array were stored in a variableof type

Object).

CONVERSIONS AND PROMOTIONS Casting Conversion 5.5

75DRAFT
v If T is an array type TC[], that is, an array of components of type TC, thena run-time exception is thrown unless one of the following is true:

C TC and RC are the same primitive type.
C TC and RC are reference types and type RC can be cast to TC by a recur-sive application of these run-time rules for casting.

If a run-time exception is thrown, it is a ClassCastException.Here are some examples of casting conversions of reference types, similar to
the example in $5.2:

public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable
{

int color;
public void setColor(int color) { this.color = color; }
}

final class EndPoint extends Point { }
class Test {

public static void main(String[] args) {

Point p = new Point();
ColoredPoint cp = new ColoredPoint();
Colorable c;

// The following may cause errors at run time because
// we cannot be sure they will succeed; this possibility
// is suggested by the casts:
cp = (ColoredPoint)p; // p might not reference an

// object which is a ColoredPoint
// or a subclass of ColoredPoint
c = (Colorable)p; // p might not be Colorable

// The following are incorrect at compile time because
// they can never succeed as explained in the text:
Long l = (Long)p; // compile-time error #1
EndPoint e = new EndPoint();
c = (Colorable)e; // compile-time error #2

}
}
Here the first compile-time error occurs because the class types Long and Pointare unrelated (that is, they are not the same, and neither is a subclass of the other),

so a cast between them will always fail.The second compile-time error occurs because a variable of type

EndPointcan never reference a value that implements the interface
Colorable. This is

5.5 Casting Conversion CONVERSIONS AND PROMOTIONS
76 DRAFT

because EndPoint is a final type, and a variable of a final type always holds avalue of the same run-time type as its compile-time type. Therefore, the run-time
type of variable e must be exactly the type EndPoint, and type EndPoint doesnot implement

Colorable.Here is an example involving arrays ($10):

class Point {

int x, y;
Point(int x, int y) { this.x = x; this.y = y; }
public String toString() { return "("+x+","+y+")"; }
}

public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable
{

int color;
ColoredPoint(int x, int y, int color) {

super(x, y); setColor(color);
}

public void setColor(int color) { this.color = color; }
public String toString() {

return super.toString() + "@" + color;
}

}
class Test {

public static void main(String[] args) {

Point[] pa = new ColoredPoint[4];
pa[0] = new ColoredPoint(2, 2, 12);
pa[1] = new ColoredPoint(4, 5, 24);
ColoredPoint[] cpa = (ColoredPoint[])pa;
System.out.print("cpa: {");
for (int i = 0; i < cpa.length; i++)

System.out.print((i == 0 ? " " : ", ") + cpa[i]);
System.out.println(" }");
}

}
This example compiles without errors and produces the output:

cpa: { (2,2)@12, (4,5)@24, null, null }

CONVERSIONS AND PROMOTIONS Numeric Promotions 5.6

77DRAFT
The following example uses casts to compile, but it throws exceptions at runtime, because the types are incompatible:
public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable
{

int color;
public void setColor(int color) { this.color = color; }
}
class Test {

public static void main(String[] args) {

Point[] pa = new Point[100];
// The following line will throw a ClassCastException:
ColoredPoint[] cpa = (ColoredPoint[])pa;

System.out.println(cpa[0]);
int[] shortvec = new int[2];
Object o = shortvec;
// The following line will throw a ClassCastException:
Colorable c = (Colorable)o;

c.setColor(0);
}
}

5.6   Numeric Promotions
Numeric promotion is applied to the operands of an arithmetic operator. Numericpromotion contexts allow the use of an identity conversion ($5.1.1) or a widening
primitive conversion ($5.1.2).Numeric promotions are used to convert the operands of a numeric operator to
a common type so that an operation can be performed. The two kinds of numericpromotion are unary numeric promotion ($5.6.1) and binary numeric promotion
($5.6.2). The analogous conversions in C are called "the usual unary conversions"and "the usual binary conversions."

Numeric promotion is not a general feature of the Java programming lan-guage, but rather a property of the specific definitions of the built-in operations.

5.6.1 Unary Numeric Promotion CONVERSIONS AND PROMOTIONS
78 DRAFT

5.6.1   Unary Numeric Promotion
Some operators apply unary numeric promotion to a single operand, which mustproduce a value of a numeric type:

* If the operand is of compile-time type byte, short, or char, unary numericpromotion promotes it to a value of type

int by a widening conversion($5.1.2).

* Otherwise, a unary numeric operand remains as is and is not converted.
In either case, value set conversion ($5.1.8) is then applied.Unary numeric promotion is performed on expressions in the following situations:

* Each dimension expression in an array creation expression ($15.10)

* The index expression in an array access expression ($15.13)

* The operand of a unary plus operator + ($15.15.3)

* The operand of a unary minus operator - ($15.15.4)

* The operand of a bitwise complement operator ~ ($15.15.5)

* Each operand, separately, of a shift operator >>, >>>, or << ($15.19); thereforea

long shift distance (right operand) does not promote the value being shifted(left operand) to

long

Here is a test program that includes examples of unary numeric promotion:
class Test {

public static void main(String[] args) {

byte b = 2;
int a[] = new int[b]; // dimension expression promotion
char c = '\u0001';
a[c] = 1; // index expression promotion
a[0] = -c; // unary - promotion
System.out.println("a: " + a[0] + "," + a[1]);

b = -1;
int i = ~b; // bitwise complement promotion
System.out.println("~0x" + Integer.toHexString(b)

+ "==0x" + Integer.toHexString(i));

i = b << 4L; // shift promotion (left operand)
System.out.println("0x" + Integer.toHexString(b)

 + "<<4L==0x" + Integer.toHexString(i));
}
}

CONVERSIONS AND PROMOTIONS Binary Numeric Promotion 5.6.2

79DRAFT
This test program produces the output:

a: -1,1
~0xffffffff==0x00xffffffff<<4L==0xfffffff0

5.6.2 Binary Numeric Promotion
When an operator applies binary numeric promotion to a pair of operands, each ofwhich must denote a value of a numeric type, the following rules apply, in order,

using widening conversion ($5.1.2) to convert operands as necessary:

* If either operand is of type double, the other is converted to double.

* Otherwise, if either operand is of type float, the other is converted to float.

* Otherwise, if either operand is of type long, the other is converted to long.

* Otherwise, both operands are converted to type int.
After the type conversion, if any, value set conversion ($5.1.8) is applied to eachoperand.

Binary numeric promotion is performed on the operands of certain operators:

* The multiplicative operators *, / and % ($15.17)

* The addition and subtraction operators for numeric types + and - ($15.18.2)

* The numerical comparison operators <, <=, >, and >= ($15.20.1)

* The numerical equality operators == and != ($15.21.1)

* The integer bitwise operators &, ^, and | ($15.22.1)

* In certain cases, the conditional operator ? : ($15.25)

An example of binary numeric promotion appears above in $5.1. Here isanother:
class Test {

public static void main(String[] args) {

int i = 0;
float f = 1.0f;
double d = 2.0;

// First int*float is promoted to float*float, then
// float==double is promoted to double==double:
if (i * f == d)

System.out.println("oops");

5.6.2 Binary Numeric Promotion CONVERSIONS AND PROMOTIONS
80 DRAFT

// A char&byte is promoted to int&int:
byte b = 0x1f;
char c = 'G';
int control = c & b;
System.out.println(Integer.toHexString(control));

// Here int:float is promoted to float:float:
f = (b==0) ? i : 4.0f;
System.out.println(1.0/f);

}
}
which produces the output:

7
0.25

The example converts the ASCII character G to the ASCII control-G (BEL), bymasking off all but the low 5 bits of the character. The

7 is the numeric value ofthis control character.

81DRAFT

C H A P T E R 6

Names

NAMES are used to refer to entities declared in a program. A declared entity($6.1) is a package, class type, interface type, member (class, interface, field, or
method) of a reference type, parameter (to a method, constructor, or exceptionhandler), or local variable.

Names in programs are either simple, consisting of a single identifier, orqualified, consisting of a sequence of identifiers separated by "

." tokens ($6.2).Every declaration that introduces a name has a scope ($6.3), which is the part

of the program text within which the declared entity can be referred to by a simplename.

Packages and reference types (that is, class types, interface types, and arraytypes) have members ($6.4). A member can be referred to using a qualified name
N.x, where N is a simple or qualified name and x is an identifier. If N names apackage, then

x is a member of that package, which is either a class or interfacetype or a subpackage. If

N names a reference type or a variable of a reference type,then
x names a member of that type, which is either a class, an interface, a field, ora method.

In determining the meaning of a name ($6.5), the context of the occurrence isused to disambiguate among packages, types, variables, and methods with the
same name.Access control ($6.6) can be specified in a class, interface, method, or field
declaration to control when access to a member is allowed. Access is a differentconcept from scope; access specifies the part of the program text within which the
declared entity can be referred to by a qualified name, a field access expression($15.11), or a method invocation expression ($15.12) in which the method is not
specified by a simple name. The default access is that a member can be accessedanywhere within the package that contains its declaration; other possibilities are
public, protected, and private.Fully qualified and canonical names ($6.7) and naming conventions ($6.8) are
also discussed in this chapter.The name of a field, parameter, or local variable may be used as an expression
($15.14.1). The name of a method may appear in an expression only as part of a

6.1 Declarations NAMES
82 DRAFT

method invocation expression ($15.12). The name of a class or interface type mayappear in an expression only as part of a class literal ($15.8.2), a qualified

thisexpression ($15.8.4), a class instance creation expression ($15.9), an array creation expression ($15.10), a cast expression ($15.16), or an instanceof expres-sion ($15.20.2), or as part of a qualified name for a field or method. The name of a
package may appear in an expression only as part of a qualified name for a classor interface type.

6.1   Declarations
A declaration introduces an entity into a program and includes an identifier ($3.8)that can be used in a name to refer to this entity. A declared entity is one of the following:

* A package, declared in a package declaration ($7.4)

* An imported type, declared in a single-type-import declaration ($7.5.1) or atype-import-on-demand declaration ($7.5.2)

* A class, declared in a class type declaration ($8.1)

* An interface, declared in an interface type declaration ($9.1)

* A member of a reference type ($8.2, $9.2, $10.7), one of the following:

u A member class ($8.5, $9.5).
u A member interface ($8.5, $9.5).
u A field, one of the following:

v A field declared in a class type ($8.3)
v A constant field declared in an interface type ($9.3)
v The field length, which is implicitly a member of every array type($10.7)

u A method, one of the following:

v A method (abstract or otherwise) declared in a class type ($8.4)
v A method (always abstract) declared in an interface type ($9.4)

* A parameter, one of the following:

u A parameter of a method or constructor of a class ($8.4.1, $8.8.1)
u A parameter of an abstract method of an interface ($9.4)

NAMES Names and Identifiers 6.2

83DRAFT
u A parameter of an exception handler declared in a catch clause of a trystatement ($14.19)

* A local variable, one of the following:

u A local variable declared in a block ($14.4)
u A local variable declared in a for statement ($14.13)
Constructors ($8.8) are also introduced by declarations, but use the name of theclass in which they are declared rather than introducing a new name.

6.2   Names and Identifiers
A name is used to refer to an entity declared in a program.There are two forms of names: simple names and qualified names. A simple
name is a single identifier. A qualified name consists of a name, a "." token, andan identifier.

In determining the meaning of a name ($6.5), the context in which the nameappears is taken into account. The rules of $6.5 distinguish among contexts where
a name must denote (refer to) a package ($6.5.3), a type ($6.5.5), a variable orvalue in an expression ($6.5.6), or a method ($6.5.7).

Not all identifiers in programs are a part of a name. Identifiers are also used inthe following situations:

* In declarations ($6.1), where an identifier may occur to specify the name bywhich the declared entity will be known

* In field access expressions ($15.11), where an identifier occurs after a "."token to indicate a member of an object that is the value of an expression or

the keyword super that appears before the "." token

* In some method invocation expressions ($15.12), where an identifier mayoccur after a "

." token and before a "(" token to indicate a method to beinvoked for an object that is the value of an expression or the keyword

superthat appears before the "
." token

* In qualified class instance creation expressions ($15.9), where an identifieroccurs immediately to the right of the leftmost

new token to indicate a typethat must be a member of the compile-time type of the primary expression

preceding the "." preceding the leftmost new token.

* As labels in labeled statements ($14.7) and in break ($14.14) and continue($14.15) statements that refer to statement labels.

6.2 Names and Identifiers NAMES
84 DRAFT

In the example:

class Test {

public static void main(String[] args) {

Class c = System.out.getClass();
System.out.println(c.toString().length() +

args[0].length() + args.length);
}

}

the identifiers Test, main, and the first occurrences of args and c are not names;rather, they are used in declarations to specify the names of the declared entities.

The names String, Class, System.out.getClass, System.out.println,
c.toString, args, and args.length appear in the example. The first occur-rence of

length is not a name, but rather an identifier appearing in a method invo-cation expression ($15.12). The second occurrence of

length is not a name, butrather an identifier appearing in a method invocation expression ($15.12).

The identifiers used in labeled statements and their associated break and
continue statements are completely separate from those used in declarations.Thus, the following code is valid:

class TestString {

char[] value;
int offset, count;
int indexOf(TestString str, int fromIndex) {

char[] v1 = value, v2 = str.value;
int max = offset + (count - str.count);
int start = offset + ((fromIndex < 0) ? 0 : fromIndex);
i:

for (int i = start; i <= max; i++)
{

int n = str.count, j = i, k = str.offset;
while (n-- != 0) {

if (v1[j++] != v2[k++])

continue i;
}
return i - offset;
}
return -1;
}

}

This code was taken from a version of the class String and its method indexOf,where the label was originally called

test. Changing the label to have the samename as the local variable
i does not obscure ($6.3.2) the label in the scope of the

NAMES Scope of a Declaration 6.3

85DRAFT
declaration of i. The identifier max could also have been used as the statementlabel; the label would not obscure the local variable

max within the labeled state-ment.

6.3 Scope of a Declaration
The scope of a declaration is the region of the program within which the entitydeclared by the declaration can be referred to using a simple name (provided it is
visible ($6.3.1)). A declaration is said to be in scope at a particular point in a pro-gram if and only if the declaration's scope includes that point.

The scoping rules for various constructs are given in the sections that describethose constructs. For convenience, the rules are repeated here:
The scope of the declaration of an observable ($7.4.3) top level package is allobservable compilation units ($7.3). The declaration of a package that is not
observable is never in scope. Subpackage declarations are never in scope.The scope of a type imported by a single-type-import declaration ($7.5.1) or
type-import-on-demand declaration ($7.5.2) is all the class and interface type dec-larations ($7.6) in the compilation unit in which the import declaration appears.

The scope of a top level type is all type declarations in the package in whichthe top level type is declared.
The scope of a label declared by a labeled statement is the statement immedi-ately enclosed by the labeled statement.
The scope of a declaration of a member m declared in or inherited by a class
type C is the entire body of C, including any nested type declarations.

The scope of the declaration of a member m declared in or inherited by an
interface type I is the entire body of I, including any nested type declarations.
The scope of a parameter of a method ($8.4.1) or constructor ($8.8.1) is the entirebody of the method or constructor.

The scope of a local variable declaration in a block ($14.4.2) is the rest of theblock in which the declaration appears, starting with its own initializer ($14.4) and
including any further declarators to the right in the local variable declaration state-ment.

The scope of a local class declared in a block is the rest of the immediatelyenclosing block, including its own class declaration.
The scope of a local variable declared in the ForInit part of a for statement($14.13) includes all of the following:

* Its own initializer

* Any further declarators to the right in the ForInit part of the for statement

6.3.1 Shadowing Declarations NAMES
86 DRAFT

* The Expression and ForUpdate parts of the for statement

* The contained Statement

The scope of a parameter of an exception handler that is declared in a catchclause of a

try statement ($14.19) is the entire block associated with the catch.These rules imply that declarations of class and interface types need not appear

before uses of the types.In the example:

package points;
class Point {

int x, y;
PointList list;
Point next;

}

class PointList {

Point first;

}

the use of PointList in class Point is correct, because the scope of the class dec-laration

PointList includes both class Point and class PointList, as well asany other type declarations in other compilation units of package

points.

6.3.1   Shadowing Declarations
Some declarations may be shadowed in part of their scope by another declarationof the same name, in which case a simple name cannot be used to refer to the

declared entity.A declaration

d of a type named n shadows the declarations of any other typesnamed
n that are in scope at the point where d occurs throughout the scope of d.A declaration

d of a field, local variable, method parameter, constructorparameter or exception handler parameter named

n shadows the declarations ofany other fields, local variables, method parameters, constructor parameters or

exception handler parameters named n that are in scope at the point where doccurs throughout the scope of

d.A declaration
d of a label named n shadows the declarations of any otherlabels named
n that are in scope at the point where d occurs throughout the scopeof
d.A declaration

d of a method named n shadows the declarations of any othermethods named
n that are in an enclosing scope at the point where d occursthroughout the scope of

d.

NAMES Shadowing Declarations 6.3.1

87DRAFT
A package declaration never shadows any other declaration.A single-type-import declaration

d in a compilation unit c of package p thatimports a type named
n shadows the declarations of:

* any top level type named n declared in another compilation unit of p.

* any type named n imported by a type-import-on-demand declaration in c.

throughout c.A type-import-on-demand declaration never causes any other declaration to
be shadowed.A declaration

d is said to be visible at point p in a program if the scope of dincludes
p, and d is not shadowed by any other declaration at p. When the pro-gram point we are discussing is clear from context, we will often simply say that a

declaration is visible.Note that shadowing is distinct from hiding ($8.3, $8.4.6.2, $8.5, $9.3, $9.5).
Hiding, in the technical sense defined in this specification, applies only to mem-bers which would otherwise be inherited but are not because of a declaration in a
subclass. Shadowing is also distinct from obscuring ($6.3.2).Here is an example of shadowing of a field declaration by a local variable declaration:

class Test {

static int x = 1;
public static void main(String[] args) {

int x = 0;
System.out.print("x=" + x);
System.out.println(", Test.x=" + Test.x);
}

}

produces the output:

x=0, Test.x=1
This example declares:

* a class Test

* a class (static) variable x that is a member of the class Test

* a class method main that is a member of the class Test

* a parameter args of the main method

* a local variable x of the main method

6.3.2 Obscured Declarations NAMES

88 DRAFT

Since the scope of a class variable includes the entire body of the class ($8.2)the class variable

x would normally be available throughout the entire body of themethod
main. In this example, however, the class variable x is shadowed withinthe body of the method

main by the declaration of the local variable x.A local variable has as its scope the rest of the block in which it is declared

($14.4.2); in this case this is the rest of the body of the main method, namely itsinitializer "

0" and the invocations of print and println.This means that:

* The expression "x" in the invocation of print refers to (denotes) the value ofthe local variable

x.

* The invocation of println uses a qualified name ($6.6) Test.x, which usesthe class type name

Test to access the class variable x, because the declara-tion of
Test.x is shadowed at this point and cannot be referred to by its sim-ple name.

The following example illustrates the shadowing of one type declaration byanother:
import java.util.*;
class Vector {

int val[] = { 1 , 2 };}

class Test {

public static void main(String[] args) {

Vector v = new Vector();
System.out.println(v.val[0]);
}

}

compiles and prints:

1
using the class Vector declared here in preference to class java.util.Vectorthat might be imported on demand.

6.3.2   Obscured Declarations
A simple name may occur in contexts where it may potentially be interpreted asthe name of a variable, a type or a package. In these situations, the rules of $6.5

specify that a variable will be chosen in preference to a type, and that a type willbe chosen in preference to a package. Thus, it is may sometimes be impossible to

NAMES The Members of a Package 6.4.1

89DRAFT
refer to a visible type or package declaration via its simple name. We say that sucha declaration is obscured.

Obscuring is distinct from shadowing ($6.3.1) and hiding ($8.3, $8.4.6.2,$8.5, $9.3, $9.5). The naming conventions of $6.8 help reduce obscuring.

6.4 Members and Inheritance
Packages and reference types have members.This section provides an overview of the members of packages and reference
types here, as background for the discussion of qualified names and the determi-nation of the meaning of names. For a complete description of membership, see

$7.1, $8.2, $9.2, and $10.7.

6.4.1 The Members of a Package
The members of a package ($7) are specified in $7.1. For convenience, we repeatthat specification here:

The members of a package are subpackages and all the top level ($7.6) class($8) and top level interface ($9) types declared in all the compilation units ($7.3)
of the package.In general, the subpackages of a package are determined by the host system
($7.2). However, the package java always includes the subpackages lang and ioand may include other subpackages. No two distinct members of the same package may have the same simple name ($7.1), but members of different packagesmay have the same simple name.

For example, it is possible to declare a package:
package vector;
public class Vector { Object[] vec; }
that has as a member a public class named Vector, even though the package
java.util also declares a class named Vector. These two class types are differ-ent, reflected by the fact that they have different fully qualified names ($6.7). The

fully qualified name of this example Vector is vector.Vector, whereas
java.util.Vector is the fully qualified name of the standard Vector class.Because the package

vector contains a class named Vector, it cannot also have asubpackage named
Vector.

6.4.2 The Members of a Class Type NAMES

90 DRAFT

6.4.2   The Members of a Class Type
The members of a class type ($8.2) are classes ($8.5, $9.5), interfaces ($8.5, $9.5),fields ($8.3, $9.3, $10.7), and methods ($8.4, $9.4). Members are either declared

in the type, or inherited because they are accessible members of a superclass orsuperinterface which are neither private nor hidden nor overridden ($8.4.6).

The members of a class type are all of the following:

* Members inherited from its direct superclass ($8.1.3), if it has one (the class

Object has no direct superclass)

* Members inherited from any direct superinterfaces ($8.1.4)

* Members declared in the body of the class ($8.1.5)

Constructors ($8.8) are not members.There is no restriction against a field and a method of a class type having the
same simple name. Likewise, there is no restriction against a member class ormember interface of a class type having the same simple name as a field or
method of that class type.A class may have two or more fields with the same simple name if they are
declared in different interfaces and inherited. An attempt to refer to any of thefields by its simple name results in a compile-time error ($6.5.7.2, $8.2).

In the example:
interface Colors {

int WHITE = 0, BLACK = 1;

}

interface Separates {

int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;

}

class Test implements Colors, Separates {

public static void main(String[] args) {

System.out.println(BLACK); // compile-time error: ambiguous
}

}

the name BLACK in the method main is ambiguous, because class Test has twomembers named

BLACK, one inherited from Colors and one from Separates.A class type may have two or more methods with the same simple name if the

methods have different signatures ($8.4.2), that is, if they have different numbersof parameters or different parameter types in at least one parameter position. Such
a method member name is said to be overloaded.

NAMES The Members of an Interface Type 6.4.3

91DRAFT
A class type may contain a declaration for a method with the same name andthe same signature as a method that would otherwise be inherited from a superclass or superinterface. In this case, the method of the superclass or superinterfaceis not inherited. If the method not inherited is

abstract, then the new declarationis said to implement it; if the method not inherited is not

abstract, then the newdeclaration is said to override it.

In the example:
class Point {

float x, y;
void move(int dx, int dy) { x += dx; y += dy; }
void move(float dx, float dy) { x += dx; y += dy; }
public String toString() { return "("+x+","+y+")"; }

}

the class Point has two members that are methods with the same name, move.The overloaded

move method of class Point chosen for any particular methodinvocation is determined at compile time by the overloading resolution procedure

given in $15.12.In this example, the members of the class

Point are the float instance vari-ables
x and y declared in Point, the two declared move methods, the declared
toString method, and the members that Point inherits from its implicit directsuperclass

Object ($4.3.2), such as the method hashCode. Note that Point doesnot inherit the

toString method of class Object because that method is overrid-den by the declaration of the

toString method in class Point.

6.4.3   The Members of an Interface Type
The members of an interface type ($9.2) may be classes ($8.5, $9.5), interfaces($8.5, $9.5), fields ($8.3, $9.3, $10.7), and methods ($8.4, $9.4).The members of

an interface are:

* Those members declared in the interface.

* Those members inherited from direct superinterfaces.

* If an interface has no direct superinterfaces, then the interface implicitlydeclares a public abstract member method

m with signature s, return type r,and
throws clause t corresponding to each public instance method m withsignature

s, return type r, and throws clause t declared in Object, unless amethod with the same signature, same return type, and a compatible

throwsclause is explicitly declared by the interface.

6.4.4 The Members of an Array Type NAMES

92 DRAFT

An interface may have two or more fields with the same simple name if they aredeclared in different interfaces and inherited. An attempt to refer to any such field
by its simple name results in a compile-time error ($6.5.6.1, $9.2).In the example:

interface Colors {

int WHITE = 0, BLACK = 1;

}

interface Separates {

int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;

}

interface ColorsAndSeparates extends Colors, Separates {

int DEFAULT = BLACK; // compile-time error: ambiguous
}

the members of the interface ColorsAndSeparates include those membersinherited from

Colors and those inherited from Separates, namely WHITE,
BLACK (first of two), CYAN, MAGENTA, YELLOW, and BLACK (second of two). Themember name

BLACK is ambiguous in the interface ColorsAndSeparates.

6.4.4 The Members of an Array Type
The members of an array type are specified in $10.7. For convenience, we repeatthat specification here.

The members of an array type are all of the following:

* The public final field length, which contains the number of componentsof the array (

length may be positive or zero)

* The public method clone, which overrides the method of the same name inclass

Object and throws no checked exceptions

* All the members inherited from class Object; the only method of Object thatis not inherited is its

clone method

The example:

class Test {

public static void main(String[] args) {

int[] ia = new int[3];
int[] ib = new int[6];
System.out.println(ia.getClass() == ib.getClass());

NAMES Determining the Meaning of a Name 6.5

93DRAFT
System.out.println("ia has length=" + ia.length);
}

}

produces the output:

true
ia has length=3

This example uses the method getClass inherited from class Object and thefield

length. The result of the comparison of the Class objects in the first
println demonstrates that all arrays whose components are of type int areinstances of the same array type, which is

int[].

6.5 Determining the Meaning of a Name
The meaning of a name depends on the context in which it is used. The determina-tion of the meaning of a name requires three steps. First, context causes a name
syntactically to fall into one of six categories: PackageName, TypeName, Expres-sionName, MethodName, PackageOrTypeName, or AmbiguousName. Second, a
name that is initially classified by its context as an AmbiguousName or as a Pack-ageOrTypeName is then reclassified to be a PackageName, TypeName, or ExpressionName. Third, the resulting category then dictates the final determination ofthe meaning of the name (or a compilation error if the name has no meaning).

PackageName:Identifier

PackageName . Identifier
TypeName:Identifier

PackageOrTypeName . Identifier
ExpressionName:Identifier

AmbiguousName . Identifier
MethodName:Identifier

AmbiguousName . Identifier
PackageOrTypeName:Identifier

PackageOrTypeName . Identifier

6.5.1 Syntactic Classification of a Name According to Context NAMES
94 DRAFT

AmbiguousName:Identifier

AmbiguousName . Identifier
The use of context helps to minimize name conflicts between entities of dif-ferent kinds. Such conflicts will be rare if the naming conventions described in

$6.8 are followed. Nevertheless, conflicts may arise unintentionally as typesdeveloped by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible todistinguish between a method and a field with the same name, since the context of
a use always tells whether a method is intended.

6.5.1 Syntactic Classification of a Name According to Context
A name is syntactically classified as a PackageName in these contexts:

* In a package declaration ($7.4)

* To the left of the "." in a qualified PackageName

A name is syntactically classified as a TypeName in these contexts:

* In a single-type-import declaration ($7.5.1)

* In an extends clause in a class declaration ($8.1.3)

* In an implements clause in a class declaration ($8.1.4)

* In an extends clause in an interface declaration ($9.1.2)

* As a Type (or the part of a Type that remains after all brackets are deleted) inany of the following contexts:

u In a field declaration ($8.3, $9.3)
u As the result type of a method ($8.4, $9.4)
u As the type of a formal parameter of a method or constructor ($8.4.1,$8.8.1, $9.4)

u As the type of an exception that can be thrown by a method or constructor($8.4.4, $8.8.4, $9.4)
u As the type of a local variable ($14.4)
u As the type of an exception parameter in a catch clause of a try statement($14.19)

u As the type in a class literal ($15.8.2)

NAMES Syntactic Classification of a Name According to Context 6.5.1

95DRAFT
u As the qualifying type of a qualified this expression ($15.8.4).
u As the class type which is to be instantiated in an unqualified class instancecreation expression ($15.9)

u As the direct superclass or direct superinterface of an anonymous class($15.9.5) which is to be instantiated in an unqualified class instance creation

expression ($15.9)
u As the element type of an array to be created in an array creation expression($15.10)

u As the qualifying type of field access using the keyword super ($15.11.2)
u As the qualifying type of a method invocation using the keyword super($15.12)

u As the type mentioned in the cast operator of a cast expression ($15.16)
u As the type that follows the instanceof relational operator ($15.20.2)
A name is syntactically classified as an ExpressionName in these contexts:

* As the qualifying expression in a qualified superclass constructor invocation($8.8.5.1)

* As the qualifying expression in a qualified class instance creation expression($15.9)

* As the array reference expression in an array access expression ($15.13)

* As a PostfixExpression ($15.14)

* As the left-hand operand of an assignment operator ($15.26)

A name is syntactically classified as a MethodName in this context:

* Before the "(" in a method invocation expression ($15.12)

A name is syntactically classified as a PackageOrTypeName in these contexts:

* To the left of the "." in a qualified TypeName

* In a type-import-on-demand declaration ($7.5.2)

A name is syntactically classified as an AmbiguousName in these contexts:

* To the left of the "." in a qualified ExpressionName

* To the left of the "." in a qualified MethodName

* To the left of the "." in a qualified AmbiguousName

6.5.2 Reclassification of Contextually Ambiguous Names NAMES
96 DRAFT

6.5.2   Reclassification of Contextually Ambiguous Names
An AmbiguousName is then reclassified as follows:

* If the AmbiguousName is a simple name, consisting of a single Identifier:

u If the Identifier appears within the scope ($6.3) of a local variable declara-tion ($14.4) or parameter declaration ($8.4.1, $8.8.1, $14.19) or field declaration ($8.3) with that name, then the AmbiguousName is reclassified as anExpressionName.

u Otherwise, if the Identifier appears within the scope ($6.3) of a local classdeclaration ($14.3) or member type declaration ($8.5, $9.5) with that name,

then the AmbiguousName is reclassified as a TypeName.
u Otherwise, if a type of that name is declared in the compilation unit ($7.3)containing the Identifier, either by a single-type-import declaration ($7.5.1)

or by a top level class ($8) or interface type declaration ($9), then theAmbiguousName is reclassified as a TypeName.

u Otherwise, if a type of that name is declared in another compilation unit($7.3) of the package ($7.1) of the compilation unit containing the

Identifier, then the AmbiguousName is reclassified as a TypeName.
u Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration ($7.5.2) of the compilation unit containing the

Identifier, then the AmbiguousName is reclassified as a TypeName.
u Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit containing the Identifier,

then a compile-time error results.
u Otherwise, the AmbiguousName is reclassified as a PackageName. A laterstep determines whether or not a package of that name actually exists.

* If the AmbiguousName is a qualified name, consisting of a name, a ".", and anIdentifier, then the name to the left of the "

." is first reclassified, for it is itselfan AmbiguousName. There is then a choice:

u If the name to the left of the "." is reclassified as a PackageName, then ifthere is a package whose name is the name to the left of the "

." and thatpackage contains a declaration of a type whose name is the same as the

Identifier, then this AmbiguousName is reclassified as a TypeName. Other-wise, this AmbiguousName is reclassified as a PackageName. A later step
determines whether or not a package of that name actually exists.

NAMES Reclassification of Contextually Ambiguous Names 6.5.2

97DRAFT
u If the name to the left of the "." is reclassified as a TypeName, then if theIdentifier is the name of a method or field of the class or interface denoted

by TypeName, this AmbiguousName is reclassified as an ExpressionName.Otherwise, if the Identifier is the name of a member type of the class or
interface denoted by TypeName, this AmbiguousName is reclassified as aTypeName. Otherwise, a compile-time error results.

u If the name to the left of the "." is reclassified as an ExpressionName, thenlet T be the type of the expression denoted by ExpressionName. If the Identifier is the name of a method or field of the class or interface denoted by T,this AmbiguousName is reclassified as an ExpressionName. Otherwise, if
the Identifier is the name of a member type ($8.5, $9.5) of the class or inter-face denoted by T, then this AmbiguousName is reclassified as a TypeName.
Otherwise, a compile-time error results.
As an example, consider the following contrived "library code":
package org.rpgpoet;
import java.util.Random;
interface Music { Random[] wizards = new Random[4]; }

and then consider this example code in another package:

package bazola;
class Gabriel {

static int n = org.rpgpoet.Music.wizards.length;

}

First of all, the name org.rpgpoet.Music.wizards.length is classified as anExpressionName because it functions as a PostfixExpression. Therefore, each of

the names:

org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org

is initially classified as an AmbiguousName. These are then reclassified:

* The simple name org is reclassified as a PackageName (since there is no vari-able or type named

org in scope).

* Next, assuming that there is no class or interface named rpgpoet in any com-pilation unit of package

org (and we know that there is no such class or inter6.5.3 Meaning of Package Names NAMES
98 DRAFT

face because package org has a subpackage named rpgpoet), the qualifiedname

org.rpgpoet is reclassified as a PackageName.

* Next, because package org.rpgpoet has an interface type named Music, thequalified name

org.rpgpoet.Music is reclassified as a TypeName.

* Finally, because the name org.rpgpoet.Music is a TypeName, the qualifiedname

org.rpgpoet.Music.wizards is reclassified as an ExpressionName.

6.5.3 Meaning of Package Names
The meaning of a name classified as a PackageName is determined as follows.

6.5.3.1 Simple Package Names
If a package name consists of a single Identifier, then this identifier denotes a toplevel package named by that identifier. If no top level package of that name is in

scope ($7.4.4), then a compile-time error occurs.
6.5.3.2 Qualified Package Names
If a package name is of the form Q.Id, then Q must also be a package name. Thepackage name

Q.Id names a package that is the member named Id within thepackage named by

Q. If Q does not name an observable package ($7.4.3), or Id isnot the simple name an observable subpackage of that package, then a compiletime error occurs.

6.5.4   Meaning of PackageOrTypeNames
6.5.4.1 Simple PackageOrTypeNames
If the PackageOrTypeName, Q, occurs in the scope of a type named Q, then thePackageOrTypeName is reclassified as a TypeName.

Otherwise, the PackageOrTypeName is reclassified as a PackageName. Themeaning of the PackageOrTypeName is the meaning of the reclassified name.

6.5.4.2 Qualified PackageOrTypeNames
Given a qualified PackageOrTypeName of the form Q.Id, if the type or packagedenoted by

Q has a member type named Id, then the qualified PackageOrType-Name name is reclassified as a TypeName.

Otherwise, it is reclassified as a PackageName. The meaning of the qualifiedPackageOrTypeName is the meaning of the reclassified name.

NAMES Meaning of Type Names 6.5.5

99DRAFT
6.5.5   Meaning of Type Names
The meaning of a name classified as a TypeName is determined as follows.

6.5.5.1 Simple Type Names
If a type name consists of a single Identifier, then the identifier must occur in thescope of a declaration of a type with this name, or a compile-time error occurs.

It is possible that the identifier occurs within the scope of more than one typewith that name, in which case the type denoted by the name is determined as follows:

* If the simple type name occurs within the scope of a visible local class decla-ration ($14.3) with that name, then the simple type name denotes that local

class type.

* Otherwise, if the simple type name occurs within the scope of exactly one vis-ible member type ($8.5, $9.5), then the simple type name denotes that member type.

* Otherwise, if the simple type name occurs within the scope of more than onevisible member type, then the name is ambiguous as a type name; a compiletime error occurs.

* Otherwise, if a type with that name is declared in the current compilation unit($7.3), either by a single-type-import declaration ($7.5.1) or by a declaration

of a class or interface type ($7.6), then the simple type name denotes thattype.

* Otherwise, if a type with that name is declared in another compilation unit($7.3) of the package ($7.1) containing the identifier, then the identifier

denotes that type.

* Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration ($7.5.2) of the compilation unit containing the identifier,

then the simple type name denotes that type.

* Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit, then the name is ambiguous as

a type name; a compile-time error occurs.

* Otherwise, the name is undefined as a type name; a compile-time error occurs.

This order for considering type declarations is designed to choose the mostexplicit of two or more applicable type declarations.

6.5.6 Meaning of Expression Names NAMES

100 DRAFT

6.5.5.2 Qualified Type Names
If a type name is of the form Q.Id, then Q must be either a type name or a pack-age name. If

Id names exactly one type that is a member of the type or packagedenoted by
Q, then the qualified type name denotes that type. If Id does not namea member type ($8.5, $9.5) within

Q, or the member type named Id within Q is notaccessible ($6.6), or
Id names more than one member type within Q, then a com-pile-time error occurs.

The example:
package wnj.test;
class Test {

public static void main(String[] args) {

java.util.Date date =

new java.util.Date(System.currentTimeMillis());
System.out.println(date.toLocaleString());
}

}

produced the following output the first time it was run:

Sun Jan 21 22:56:29 1996
In this example the name java.util.Date must denote a type, so we first use theprocedure recursively to determine if

java.util is an accessible type or a pack-age, which it is, and then look to see if the type

Date is accessible in this package.

6.5.6 Meaning of Expression Names
The meaning of a name classified as an ExpressionName is determined as follows.

6.5.6.1 Simple Expression Names
If an expression name consists of a single Identifier, then:

* If the Identifier appears within the scope ($6.3) of a visible local variable dec-laration ($14.4) or visible parameter declaration ($8.4.1, $8.8.1, $14.19) with

that name, then the expression name denotes a variable, that is, that local vari-able or parameter. There is necessarily at most one such local variable or
parameter. The type of the expression name is the declared type of the localvariable or parameter.

* Otherwise, if the Identifier appears within a class declaration ($8):

u If the Identifier appears within the scope ($6.3) of a visible field declarationwith that name, then there must be a lexically enclosing type declaration of

NAMES Meaning of Expression Names 6.5.6

101DRAFT
which that field is a member. Let T be the innermost such declaration. Ifthere is not exactly one member of

T that is a field with that name, then acompile-time error results.

u Otherwise, if the single member field with that name is declared final($8.3.1.2), then the expression name denotes the value of the field. The type

of the expression name is the declared type of the field. If the Identifierappears in a context that requires a variable and not a value, then a compiletime error occurs.
u Otherwise, the expression name denotes a variable, the single member fieldwith that name. The type of the expression name is the field's declared type.

If the field is an instance variable ($8.3.1.1), the expression name must appearwithin the declaration of an instance method ($8.4), constructor ($8.8), or
instance variable initializer ($8.3.2.2). If it appears within a static method($8.4.3.2), static initializer ($8.7), or initializer for a

static variable($8.3.1.1, $12.4.2), then a compile-time error occurs.

* Otherwise, the identifier appears within an interface declaration ($9):

u If the Identifier appears within the scope ($6.3) of a visible field declarationwith that name, then there must be an enclosing type declaration

T of whichthat field is a member. If there is not exactly one member of
T that is a fieldwith that name, then a compile-time error results.

u Otherwise, the expression name denotes the value of the single memberfield of that name. The type of the expression name is the declared type of

the field. If the Identifier appears in a context that requires a variable and nota value, then a compile-time error occurs.

In the example:

class Test {

static int v;
static final int f = 3;
public static void main(String[] args) {

int i;
i = 1;
v = 2;
f = 33; // compile-time error
System.out.println(i + " " + v + " " + f);
}

}

6.5.6 Meaning of Expression Names NAMES
102 DRAFT

the names used as the left-hand-sides in the assignments to i, v, and f denote thelocal variable

i, the field v, and the value of f (not the variable f, because f is a
final variable). The example therefore produces an error at compile timebecause the last assignment does not have a variable as its left-hand side. If the

erroneous assignment is removed, the modified code can be compiled and it willproduce the output:

1 2 3
6.5.6.2 Qualified Expression Names
If an expression name is of the form Q.Id, then Q has already been classified as apackage name, a type name, or an expression name:

* If Q is a package name, then a compile-time error occurs.

* If Q is a type name that names a class type ($8), then:

u If there is not exactly one accessible ($6.6) member of the class type that isa field named

Id, then a compile-time error occurs.

u Otherwise, if the single accessible member field is not a class variable (thatis, it is not declared

static), then a compile-time error occurs.

u Otherwise, if the class variable is declared final, then Q.Id denotes thevalue of the class variable. The type of the expression

Q.Id is the declaredtype of the class variable. If
Q.Id appears in a context that requires a vari-able and not a value, then a compile-time error occurs.

u Otherwise, Q.Id denotes the class variable. The type of the expression

Q.Id is the declared type of the class variable.

* If Q is a type name that names an interface type ($9), then:

u If there is not exactly one accessible ($6.6) member of the interface typethat is a field named

Id, then a compile-time error occurs.

u Otherwise, Q.Id denotes the value of the field. The type of the expression

Q.Id is the declared type of the field. If Q.Id appears in a context thatrequires a variable and not a value, then a compile-time error occurs.

* If Q is an expression name, let T be the type of the expression Q:

u If T is not a reference type, a compile-time error occurs.
u If there is not exactly one accessible ($6.6) member of the type T that is afield named

Id, then a compile-time error occurs.

u Otherwise, if this field is any of the following:

NAMES Meaning of Method Names 6.5.7

103DRAFT
v A field of an interface type
v A final field of a class type (which may be either a class variable or aninstance variable)

v The final field length of an array type
then Q.Id denotes the value of the field. The type of the expression Q.Id isthe declared type of the field. If

Q.Id appears in a context that requires avariable and not a value, then a compile-time error occurs.

u Otherwise, Q.Id denotes a variable, the field Id of class T, which may beeither a class variable or an instance variable. The type of the expression

Q.Id is the declared type of the field
The example:
class Point {

int x, y;
static int nPoints;

}

class Test {

public static void main(String[] args) {

int i = 0;
i.x++; // compile-time error
Point p = new Point();
p.nPoints(); // compile-time error
}

}

encounters two compile-time errors, because the int variable i has no members,and because

nPoints is not a method of class Point.

6.5.7 Meaning of Method Names
A MethodName can appear only in a method invocation expression ($15.12). Themeaning of a name classified as a MethodName is determined as follows.

6.5.7.1 Simple Method Names
If a method name consists of a single Identifier, then Identifier is the method nameto be used for method invocation. The Identifier must name at least one method of

a class or interface within whose declaration the Identifier appears. See $15.12 forfurther discussion of the interpretation of simple method names in method invocation expressions.

6.6 Access Control NAMES
104 DRAFT

6.5.7.2 Qualified Method Names
If a method name is of the form Q.Id, then Q has already been classified as apackage name, a type name, or an expression name. If

Q is a package name, then acompile-time error occurs. Otherwise,
Id is the method name to be used formethod invocation. If
Q is a type name, then Id must name at least one staticmethod of the type
Q. If Q is an expression name, then let T be the type of theexpression
Q; Id must name at least one method of the type T. See $15.12 for fur-ther discussion of the interpretation of qualified method names in method invocation expressions.

6.6   Access Control
The Java programming language provides mechanisms for access control, to pre-vent the users of a package or class from depending on unnecessary details of the
implementation of that package or class. If access is permitted, then the accessedentity is said to be accessible.

Note that accessibility is a static property that can be determined at compiletime; it depends only on types and declaration modifiers. Qualified names are a
means of access to members of packages and reference types; related means ofaccess include field access expressions ($15.11) and method invocation expressions ($15.12). All three are syntactically similar in that a "." token appears, pre-ceded by some indication of a package, type, or expression having a type and
followed by an Identifier that names a member of the package or type. These arecollectively known as constructs for qualified access.

Access control applies to qualified access and to the invocation of construc-tors by class instance creation expressions ($15.9) and explicit constructor invocations ($8.8.5). Accessibility also effects inheritance of class members ($8.2),including hiding and method overriding ($8.4.6.1).

6.6.1   Determining Accessibility

* A package is always accessible.

* If a class or interface type is declared public, then it may be accessed by anycode, provided that the compilation unit ($7.3) in which it is declared is

observable. If a top level class or interface type is not declared public, then itmay be accessed only from within the package in which it is declared.

* An array type is accessible if and only if its element type is accessible.

NAMES Details on protected Access 6.6.2

105DRAFT

* A member (class, interface, field, or method) of a reference (class, interface,or array) type or a constructor of a class type is accessible only if the type is

accessible and the member or constructor is declared to permit access:
u If the member or constructor is declared public, then access is permitted.All members of interfaces are implicitly

public.

u Otherwise, if the member or constructor is declared protected, then accessis permitted only when one of the following is true:

C Access to the member or constructor occurs from within the packagecontaining the class in which the

protected member or constructor isdeclared.

C Access is correct as described in $6.6.2.
u Otherwise, if the member or constructor is declared private, then access ispermitted if and only if it occurs within the body of the top level class ($7.6)

that encloses the declaration of the member.
u Otherwise, we say there is default access, which is permitted only when theaccess occurs from within the package in which the type is declared.

6.6.2   Details on protected Access
A protected member or constructor of an object may be accessed from outsidethe package in which it is declared only by code that is responsible for the implementation of that object.
6.6.2.1 Access to a protected Member
Let C be the class in which a protected member m is declared. Access is permit-ted only within the body of a subclass

S of C. In addition, if Id denotes aninstance field or instance method, then:

* If the access is by a qualified name Q.Id, where Q is an ExpressionName,then the access is permitted if and only if the type of the expression

Q is S or asubclass of
S.

* If the access is by a field access expression E.Id, where E is a Primaryexpression, or by a method invocation expression

E.Id(. . .), where E is aPrimary expression, then the access is permitted if and only if the type of

E is
S or a subclass of S.

6.6.3 An Example of Access Control NAMES

106 DRAFT

6.6.2.2 Qualified Access to a protected Constructor
Let C be the class in which a protected constructor is declared and let S be theinnermost class in whose declaration the use of the

protected constructoroccurs. Then:

* If the access is by a superclass constructor invocation super(. . .) or by aqualified superclass constructor invocation of the form

E.super(. . .), where
E is a Primary expression, then the access is permitted.

* If the access is by an anonymous class instance creation expression of theform

new C(. . .){...} or by a qualified class instance creation expression ofthe form

E.new C(. . .){...}, where E is a Primary expression, then theaccess is permitted.

* Otherwise, if the access is by a simple class instance creation expression ofthe form

new C(. . .) or by a qualified class instance creation expression of theform
E.new C(. . .), where E is a Primary expression, then the access is notpermitted. A

protected constructor can be accessed by a class instance cre-ation expression (that does not declare an anonymous class) only from within

the package in which it is defined.

6.6.3   An Example of Access Control
For examples of access control, consider the two compilation units:

package points;
class PointVec { Point[] vec; }

and:

package points;
public class Point {

protected int x, y;
public void move(int dx, int dy) { x += dx; y += dy; }
public int getX() { return x; }
public int getY() { return y; }

}

which declare two class types in the package points:

* The class type PointVec is not public and not part of the public interfaceof the package

points, but rather can be used only by other classes in thepackage.

* The class type Point is declared public and is available to other packages. Itis part of the

public interface of the package points.

NAMES Example: Access to public and Non-public Classes 6.6.4

107DRAFT

* The methods move, getX, and getY of the class Point are declared publicand so are available to any code that uses an object of type

Point.

* The fields x and y are declared protected and are accessible outside thepackage

points only in subclasses of class Point, and only when they arefields of objects that are being implemented by the code that is accessing

them.
See $6.6.7 for an example of how the protected access modifier limits access.

6.6.4   Example: Access to public and Non-public Classes
If a class lacks the public modifier, access to the class declaration is limited tothe package in which it is declared ($6.6). In the example:

package points;
public class Point {

public int x, y;
public void move(int dx, int dy) { x += dx; y += dy; }}

class PointList {

Point next, prev;

}

two classes are declared in the compilation unit. The class Point is available out-side the package

points, while the class PointList is available for access onlywithin the package.

Thus a compilation unit in another package can access points.Point, eitherby using its fully qualified name:

package pointsUser;
class Test {

public static void main(String[] args) {

points.Point p = new points.Point();
System.out.println(p.x + " " + p.y);
}

}

or by using a single-type-import declaration ($7.5.1) that mentions the fully quali-fied name, so that the simple name may be used thereafter:

6.6.5 Example: Default-Access Fields, Methods, and Constructors NAMES

108 DRAFT

package pointsUser;
import points.Point;
class Test {

public static void main(String[] args) {

Point p = new Point();
System.out.println(p.x + " " + p.y);
}

}

However, this compilation unit cannot use or import points.PointList, whichis not declared

public and is therefore inaccessible outside package points.

6.6.5   Example: Default-Access Fields, Methods, and Constructors
If none of the access modifiers public, protected, or private are specified, aclass member or constructor is accessible throughout the package that contains the

declaration of the class in which the class member is declared, but the class mem-ber or constructor is not accessible in any other package.

If a public class has a method or constructor with default access, then thismethod or constructor is not accessible to or inherited by a subclass declared outside this package.For example, if we have:

package points;
public class Point {

public int x, y;
void move(int dx, int dy) { x += dx; y += dy; }
public void moveAlso(int dx, int dy) { move(dx, dy); }

}

then a subclass in another package may declare an unrelated move method, withthe same signature ($8.3.2) and return type. Because the original

move method isnot accessible from package
morepoints, super may not be used:

package morepoints;
public class PlusPoint extends points.Point {

public void move(int dx, int dy) {

super.move(dx, dy); // compile-time error
moveAlso(dx, dy);
}

}

Because move of Point is not overridden by move in PlusPoint, the method
moveAlso in Point never calls the method move in PlusPoint.

NAMES Example: protected Fields, Methods, and Constructors 6.6.7

109DRAFT
Thus if you delete the super.move call from PlusPoint and execute the testprogram:
import points.Point;
import morepoints.PlusPoint;
class Test {
    public static void main(String[] args) {
        PlusPoint pp = new PlusPoint();
        pp.move(1, 1);  }

}
it terminates normally. If move of Point were overridden by move in PlusPoint,then this program would recurse infinitely, until a

StackoverflowErroroccurred.

6.6.6   Example: public Fields, Methods, and Constructors
A public class member or constructor is accessible throughout the packagewhere it is declared and from any other package, provided the package in which it

is declared is observable ($7.4.3). For example, in the compilation unit:

package points;
public class Point {

int x, y;
public void move(int dx, int dy) {

x += dx; y += dy;
moves++;
}

public static int moves = 0;
}

the public class Point has as public members the move method and the movesfield. These

public members are accessible to any other package that has accessto package
points. The fields x and y are not public and therefore are accessibleonly from within the package

points.

6.6.7   Example: protected Fields, Methods, and Constructors
Consider this example, where the points package declares:

6.6.7 Example: protected Fields, Methods, and Constructors NAMES
110 DRAFT

package points;
public class Point {

protected int x, y;
void warp(threePoint.Point3d a) {

if (a.z > 0) // compile-time error: cannot access a.z

a.delta(this);
}

}

and the threePoint package declares:

package threePoint;
import points.Point;
public class Point3d extends Point {

protected int z;
public void delta(Point p) {

p.x += this.x; // compile-time error: cannot access p.x
p.y += this.y; // compile-time error: cannot access p.y}

public void delta3d(Point3d q) {

q.x += this.x;
q.y += this.y;
q.z += this.z;
}

}

which defines a class Point3d. A compile-time error occurs in the method deltahere: it cannot access the protected members

x and y of its parameter p, becausewhile
Point3d (the class in which the references to fields x and y occur) is a sub-class of

Point (the class in which x and y are declared), it is not involved in theimplementation of a

Point (the type of the parameter p). The method delta3dcan access the protected members of its parameter

q, because the class Point3d isa subclass of
Point and is involved in the implementation of a Point3d.The method

delta could try to cast ($5.5, $15.16) its parameter to be a
Point3d, but this cast would fail, causing an exception, if the class of p at runtime were not

Point3d.A compile-time error also occurs in the method warp: it cannot access the protected member z of its parameter a, because while the class Point (the class inwhich the reference to field

z occurs) is involved in the implementation of a
Point3d (the type of the parameter a), it is not a subclass of Point3d (the class inwhich

z is declared).

NAMES Fully Qualified Names and Canonical Names 6.7

111DRAFT
6.6.8   Example: private Fields, Methods, and Constructors
A private class member or constructor is accessible only within the class body inwhich the member is declared and is not inherited by subclasses. In the example:

class Point {

Point() { setMasterID(); }
int x, y;
private int ID;
private static int masterID = 0;

private void setMasterID() { ID = masterID++; }
}

the private members ID, masterID, and setMasterID may be used onlywithin the body of class

Point. They may not be accessed by qualified names,field access expressions, or method invocation expressions outside the body of the

declaration of Point.See $8.8.8 for an example that uses a

private constructor.

6.7 Fully Qualified Names and Canonical Names
Every package, top level class, top level interface, and primitive type has a fullyqualified name. An array type has a fully qualified name if and only if its element
type has a fully qualified name.

* The fully qualified name of a primitive type is the keyword for that primitivetype, namely

boolean, char, byte, short, int, long, float, or double.

* The fully qualified name of a named package that is not a subpackage of anamed package is its simple name.

* The fully qualified name of a named package that is a subpackage of anothernamed package consists of the fully qualified name of the containing package,

followed by ".", followed by the simple (member) name of the subpackage.

* The fully qualified name of a top level class or top level interface that isdeclared in an unnamed package is the simple name of the class or interface.

* The fully qualified name of a top level class or top level interface that isdeclared in a named package consists of the fully qualified name of the package, followed by ".", followed by the simple name of the class or interface.

* A member class or member interface M of another class C has a fully qualifiedname if and only if

C has a fully qualified name. In that case, the fully quali6.7 Fully Qualified Names and Canonical Names NAMES
112 DRAFT

fied name of M consists of the fully qualified name of C, followed by ".", fol-lowed by the simple name of

M.

* The fully qualified name of an array type consists of the fully qualified nameof the component type of the array type followed by "

[]".

Examples:

* The fully qualified name of the type long is "long".

* The fully qualified name of the package java.lang is "java.lang" becauseit is subpackage

lang of package java.

* The fully qualified name of the class Object, which is defined in the package

java.lang, is "java.lang.Object".

* The fully qualified name of the interface Enumeration, which is defined inthe package

java.util, is "java.util.Enumeration".

* The fully qualified name of the type "array of double" is "double[]".

* The fully qualified name of the type "array of array of array of array of

String" is "java.lang.String[][][][]".

In the example:

package points;
class Point { int x, y; }
class PointVec {

Point[] vec;

}

the fully qualified name of the type Point is "points.Point"; the fully qualifiedname of the type

PointVec is "points.PointVec"; and the fully qualified nameof the type of the field

vec of class PointVec is "points.Point[]".Every package, top level class, top level interface, and primitive type has a

canonical name. An array type has a canonical name if and only if its elementtype has a canonical name. A member class or member interface

M declared inanother class
C has a canonical name if and only if C has a canonical name. In thatcase, the canonical name of

M consists of the canonical name of C, followed by"
.", followed by the simple name of M. For every package, top level class, toplevel interface and primitive type, the canonical name is the same as the fully

qualified name. The canonical name of an array type is defined only when thecomponent type of the array has a canonical name. In that case, the canonical
name of the array type consists of the canonical name of the component type ofthe array type followed by "

[]".

NAMES Package Names 6.8.1

113DRAFT
The difference between a fully qualified name and a canonical name can beseen in examples such as:
package p;
class O1 { class I{}}
class O2 extends O1{};

In this example both p.O1.I and p.O2.I are fully qualified names that denote thesame class, but only

p.O1.I is its canonical name.

6.8   Naming Conventions
The class libraries of the Java platform attempt to use, whenever possible, nameschosen according to the conventions presented here. These conventions help to
make code more readable and avoid certain kinds of name conflicts.We recommend these conventions for use in all programs written in the Java
programming language. However, these conventions should not be followed slav-ishly if long-held conventional usage dictates otherwise. So, for example, the

sinand
cos methods of the class java.lang.Math have mathematically conventionalnames, even though these method names flout the convention suggested here

because they are short and are not verbs.

6.8.1   Package Names
Names of packages that are to be made widely available should be formed asdescribed in $7.7. Such names are always qualified names whose first identifier

consists of two or three lowercase letters that name an Internet domain, such as
com, edu, gov, mil, net, org, or a two-letter ISO country code such as uk or jp.Here are examples of hypothetical unique names that might be formed under this

convention:

com.JavaSoft.jag.Oak
org.npr.pledge.driver
uk.ac.city.rugby.game

Names of packages intended only for local use should have a first identifierthat begins with a lowercase letter, but that first identifier specifically should not

be the identifier java; package names that start with the identifier java arereserved by Sun for naming Java platform packages.

When package names occur in expressions:

6.8.2 Class and Interface Type Names NAMES

114 DRAFT

* If a package name is obscured by a field declaration, then import declarations($7.5) can usually be used to make available the type names declared in that

package.

* If a package name is obscured by a declaration of a parameter or local vari-able, then the name of the parameter or local variable can be changed without

affecting other code.
The first component of a package name is normally not easily mistaken for atype name, as a type name normally begins with a single uppercase letter. (The
Java programming language does not actually rely on case distinctions to deter-mine whether a name is a package name or a type name.)

6.8.2   Class and Interface Type Names
Names of class types should be descriptive nouns or noun phrases, not overlylong, in mixed case with the first letter of each word capitalized. For example:

ClassLoader
SecurityManager
Thread
Dictionary
BufferedInputStream

Likewise, names of interface types should be short and descriptive, not overlylong, in mixed case with the first letter of each word capitalized. The name may be

a descriptive noun or noun phrase, which is appropriate when an interface is usedas if it were an abstract superclass, such as interfaces

java.io.DataInput and
java.io.DataOutput; or it may be an adjective describing a behavior, as for theinterfaces

Runnable and Cloneable.Obscuring involving class and interface type names is rare. Names of fields,

parameters, and local variables normally do not obscure type names because theyconventionally begin with a lowercase letter whereas type names conventionally
begin with an uppercase letter.

6.8.3   Method Names
Method names should be verbs or verb phrases, in mixed case, with the first letterlowercase and the first letter of any subsequent words capitalized. Here are some

additional specific conventions for method names:

NAMES Field Names 6.8.4

115DRAFT

* Methods to get and set an attribute that might be thought of as a variable Vshould be named

getV and setV. An example is the methods getPriorityand
setPriority of class Thread.

* A method that returns the length of something should be named length, as inclass

String.

* A method that tests a boolean condition V about an object should be named

isV. An example is the method isInterrupted of class Thread.

* A method that converts its object to a particular format F should be named

toF. Examples are the method toString of class Object and the methods
toLocaleString and toGMTString of class java.util.Date.

Whenever possible and appropriate, basing the names of methods in a new classon names in an existing class that is similar, especially a class from the Java
Application Programming Interface classes, will make it easier to use.Method names cannot obscure or be obscured by other names ($6.5.7).

6.8.4   Field Names
Names of fields that are not final should be in mixed case with a lowercase firstletter and the first letters of subsequent words capitalized. Note that well-designed

classes have very few public or protected fields, except for fields that are con-stants (

final static fields) ($6.8.5).Fields should have names that are nouns, noun phrases, or abbreviations for

nouns. Examples of this convention are the fields buf, pos, and count of the class
java.io.ByteArrayInputStream and the field bytesTransferred of the class
java.io.InterruptedIOException.Obscuring involving field names is rare.

* If a field name obscures a package name, then an import declaration ($7.5)can usually be used to make available the type names declared in that package.

* If a field name obscures a type name, then a fully qualified name for the typecan be used unless the type name denotes a local class ($14.3).

* Field names cannot obscure method names.

* If a field name is shadowed by a declaration of a parameter or local variable,then the name of the parameter or local variable can be changed without

affecting other code.

6.8.5 Constant Names NAMES
116 DRAFT

6.8.5   Constant Names
The names of constants in interface types should be, and final variables of classtypes may conventionally be, a sequence of one or more words, acronyms, or

abbreviations, all uppercase, with components separated by underscore "_" char-acters. Constant names should be descriptive and not unnecessarily abbreviated.
Conventionally they may be any appropriate part of speech. Examples of namesfor constants include

MIN_VALUE, MAX_VALUE, MIN_RADIX, and MAX_RADIX of theclass
Character.A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with acommon acronym as a name prefix, as in:

interface ProcessStates {

int PS_RUNNING = 0;
int PS_SUSPENDED = 1;

}

Obscuring involving constant names is rare:

* Constant names normally have no lowercase letters, so they will not normallyobscure names of packages or types, nor will they normally shadow fields,

whose names typically contain at least one lowercase letter.

* Constant names cannot obscure method names, because they are distin-guished syntactically.

6.8.6   Local Variable and Parameter Names
Local variable and parameter names should be short, yet meaningful. They areoften short sequences of lowercase letters that are not words. For example:

* Acronyms, that is the first letter of a series of words, as in cp for a variableholding a reference to a

ColoredPoint

* Abbreviations, as in buf holding a pointer to a buffer of some kind

* Mnemonic terms, organized in some way to aid memory and understanding,typically by using a set of local variables with conventional names patterned

after the names of parameters to widely used classes. For example:
u in and out, whenever some kind of input and output are involved, patternedafter the fields of

System

NAMES Local Variable and Parameter Names 6.8.6

117DRAFT
u off and len, whenever an offset and length are involved, patterned after theparameters to the

read and write methods of the interfaces DataInputand
DataOutput of java.io

One-character local variable or parameter names should be avoided, exceptfor temporary and looping variables, or where a variable holds an undistinguished

value of a type. Conventional one-character names are:

* b for a byte

* c for a char

* d for a double

* e for an Exception

* f for a float

* i, j, and k for integers

* l for a long

* o for an Object

* s for a String

* v for an arbitrary value of some type

Local variable or parameter names that consist of only two or three lowercaseletters should not conflict with the initial country codes and domain names that are

the first component of unique package names ($7.7).

6.8.6 Local Variable and Parameter Names NAMES

118 DRAFT119DRAFT

C H A P T E R 7

Packages

PROGRAMS are organized as sets of packages. Each package has its own set ofnames for types, which helps to prevent name conflicts. A top level type is accessible ($6.6) outside the package that declares it only if the type is declared public.The naming structure for packages is hierarchical ($7.1). The members of a

package are class and interface types ($7.6), which are declared in compilationunits of the package, and subpackages, which may contain compilation units and
subpackages of their own.A package can be stored in a file system ($7.2.1) or in a database ($7.2.2).
Packages that are stored in a file system have certain constraints on the organiza-tion of their compilation units to allow a simple implementation to find classes
easily.A package consists of a number of compilation units ($7.3). A compilation
unit automatically has access to all types declared in its package and also automat-ically imports all of the public types declared in the predefined package
java.lang.For small programs and casual development, a package can be unnamed
($7.4.2) or have a simple name, but if code is to be widely distributed, uniquepackage names should be chosen ($7.7). This can prevent the conflicts that would
otherwise occur if two development groups happened to pick the same packagename and these packages were later to be used in a single program.

7.1 Package Members

The members of a package are subpackages and all the top level ($7.6) class($8) and top level interface ($9) types declared in all the compilation units ($7.3)
of the package.For example, in the Java Application Programming Interface:

7.2 Host Support for Packages PACKAGES
120 DRAFT

* The package java has subpackages awt, applet, io, lang, net, and util,but no compilation units.

* The package java.awt has a subpackage named image, as well as a numberof compilation units containing declarations of class and interface types.
If the fully qualified name ($6.7) of a package is P, and Q is a subpackage of P,then

P.Q is the fully qualified name of the subpackage.A package may not contain two members of the same name, or a compiletime error results.Here are some examples:

* Because the package java.awt has a subpackage image, it cannot (and doesnot) contain a declaration of a class or interface type named

image.

* If there is a package named mouse and a member type Button in that package(which then might be referred to as

mouse.Button), then there cannot be anypackage with the fully qualified name

mouse.Button or mouse.Button.Click.

* If com.sun.java.jag is the fully qualified name of a type, then there cannotbe any package whose fully qualified name is either

com.sun.java.jag or
com.sun.java.jag.scrabble.

The hierarchical naming structure for packages is intended to be convenientfor organizing related packages in a conventional manner, but has no significance
in itself other than the prohibition against a package having a subpackage with thesame simple name as a top level type ($7.6) declared in that package. There is no
special access relationship between a package named oliver and another pack-age named

oliver.twist, or between packages named evelyn.wood and evelyn.waugh. For example, the code in a package named oliver.twist has nobetter access to the types declared within package

oliver than code in any otherpackage.

7.2 Host Support for Packages
Each host determines how packages, compilation units, and subpackages are cre-ated and stored, and which compilation units are observable ($7.3) in a particular
compilation.The observability of compilation units in turn determines which packages are
observable, and which packages are in scope.

PACKAGES Storing Packages in a File System 7.2.1

121DRAFT
The packages may be stored in a local file system in simple implementationsof the Java platform. Other implementations may use a distributed file system or
some form of database to store source and/or binary code.

7.2.1   Storing Packages in a File System
As an extremely simple example, all the packages and source and binary code ona system might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, onewhose fully qualified name consists of a single simple name. The directory might
contain the following immediate subdirectories:

com
gls
jag
java
wnj

where directory java would contain the Java Application Programming Interfacepackages; the directories

jag, gls, and wnj might contain packages that three ofthe authors of this specification created for their personal use and to share with

each other within this small group; and the directory com would contain packagesprocured from companies that used the conventions described in $7.7 to generate
unique names for their packages.Continuing the example, the directory

java would contain, among others, thefollowing subdirectories:

applet
awt
io
lang
net
util

corresponding to the packages java.applet, java.awt, java.io, java.lang,
java.net, and java.util that are defined as part of the Java Application Pro-gramming Interface.

Still continuing the example, if we were to look inside the directory util, wemight see the following files:

BitSet.java Observable.java
BitSet.class Observable.class
Date.java Observer.java
Date.class Observer.class
...

7.2.2 Storing Packages in a Database PACKAGES
122 DRAFT

where each of the .java files contains the source for a compilation unit ($7.3)that contains the definition of a class or interface whose binary compiled form is
contained in the corresponding .class file.Under this simple organization of packages, an implementation of the Java
platform would transform a package name into a pathname by concatenating thecomponents of the package name, placing a file name separator (directory indicator) between adjacent components.For example, if this simple organization were used on a UNIX system, where
the file name separator is /, the package name:

jag.scrabble.board
would be transformed into the directory name:

jag/scrabble/board
and:

com.sun.sunsoft.DOE
would be transformed to the directory name:

com/sun/sunsoft/DOE
A package name component or class name might contain a character that can-not correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As aconvention, the character can be escaped by using, say, the

@ character followedby four hexadecimal digits giving the numeric value of the character, as in the

\uxxxx escape ($3.3), so that the package name:

children.activities.crafts.papierM\u00e2ch\u00e9
which can also be written using full Unicode as:

children.activities.crafts.papierMa^che'
might be mapped to the directory name:

children/activities/crafts/papierM@00e2ch@00e9
If the @ character is not a valid character in a file name for some given host filesystem, then some other character that is not valid in a identifier could be used

instead.

7.2.2   Storing Packages in a Database
A host system may store packages and their compilation units and subpackages ina database.

PACKAGES Compilation Units 7.3

123DRAFT
Such a database must not impose the optional restrictions ($7.6) on compila-tion units in file-based implementations. For example, a system that uses a database to store packages may not enforce a maximum of one public class orinterface per compilation unit.

Systems that use a database must, however, provide an option to convert aprogram to a form that obeys the restrictions, for purposes of export to file-based
implementations.

7.3   Compilation Units
CompilationUnit is the goal symbol ($2.1) for the syntactic grammar ($2.3) ofJava programs. It is defined by the following productions:

CompilationUnit:PackageDeclaration

opt ImportDeclarationsopt TypeDeclarationsopt

ImportDeclarations:ImportDeclaration

ImportDeclarations ImportDeclaration
TypeDeclarations:TypeDeclaration

TypeDeclarations TypeDeclaration
Types declared in different compilation units can depend on each other, circularly.A Java compiler must arrange to compile all such types at the same time.

A compilation unit consists of three parts, each of which is optional:

* A package declaration ($7.4), giving the fully qualified name ($6.7) of thepackage to which the compilation unit belongs. A compilation unit that has no

package declaration is part of an unnamed package ($7.4.2).

* import declarations ($7.5) that allow types from other packages to bereferred to using their simple names

* Top level type declarations ($7.6) of class and interface types

Which compilation units are observable is determined by the host system.However, all the compilation units of the package

java and its subpackages langand
io must always be observable. The observability of a compilation unit influ-ences the observability of its package ($7.4.3).

Every compilation unit automatically and implicitly imports every publictype name declared by the predefined package

java.lang, so that the names ofall those types are available as simple names, as described in $7.5.3.

7.4 Package Declarations PACKAGES
124 DRAFT

7.4   Package Declarations
A package declaration appears within a compilation unit to indicate the packageto which the compilation unit belongs.

7.4.1   Named Packages
A package declaration in a compilation unit specifies the name ($6.2) of the pack-age to which the compilation unit belongs.

PackageDeclaration:

package PackageName ;

The package name mentioned in a package declaration must be the fully qualifiedname ($6.7) of the package.

7.4.2   Unnamed Packages
A compilation unit that has no package declaration is part of an unnamed package.Note that an unnamed package cannot have subpackages, since the syntax of a

package declaration always includes a reference to a named top level package.As an example, the compilation unit:

class FirstCall {

public static void main(String[] args) {

System.out.println("Mr. Watson, come here. "

+ "I want you.");
}
}

defines a very simple compilation unit as part of an unnamed package.An implementation of the Java platform must support at least one unnamed

package; it may support more than one unnamed package but is not required to doso. Which compilation units are in each unnamed package is determined by the
host system.In implementations of the Java platform that use a hierarchical file system for
storing packages, one typical strategy is to associate an unnamed package witheach directory; only one unnamed package is observable at a time, namely the one
that is associated with the "current working directory." The precise meaning of"current working directory" depends on the host system.

Unnamed packages are provided by the Java platform principally for conve-nience when developing small or temporary applications or when just beginning
development.

PACKAGES Import Declarations 7.5

125DRAFT
7.4.3 Observability of a Package
A package is observable if and only if either:

* A compilation unit containing a declaration of the package is observable.

* A subpackage of the package is observable.

One can conclude from the rule above and from the requirements on observ-able compilation units, that the packages

java, java.lang, and java.io arealways observable.

7.4.4 Scope of a Package Declaration
The scope of the declaration of an observable ($7.4.3) top level package is allobservable compilation units ($7.3). The declaration of a package that is not

observable is never in scope. Subpackage declarations are never in scope.It follows that the package

java is always in scope ($6.3).Package declarations never shadow other declarations.

7.5 Import Declarations
An import declaration allows a named type to be referred to by a simple name($6.2) that consists of a single identifier. Without the use of an appropriate

importdeclaration, the only way to refer to a type declared in another package is to use a

fully qualified name ($6.7).

ImportDeclaration:SingleTypeImportDeclaration

TypeImportOnDemandDeclaration
A single-type-import declaration ($7.5.1) imports a single named type, bymentioning its canonical name. A type-import-on-demand declaration ($7.5.2)

imports all the accessible types of a named type or package as needed.The scope of a type imported by a single-type-import declaration ($7.5.1) or
type-import-on-demand declaration ($7.5.2) is all the class and interface type dec-larations ($7.6) in the compilation unit in which the import declaration appears.

An import declaration makes types available by their simple names onlywithin the compilation unit that actually contains the

import declaration. Thescope of the entities(s) it introduces specifically does not include the

packagestatement, other
import declarations in the current compilation unit, or othercompilation units in the same package. See $7.5.4 for an illustrative example.

7.5.1 Single-Type-Import Declaration PACKAGES
126 DRAFT

7.5.1   Single-Type-Import Declaration
A single-type-import declaration imports a single type by giving its canonicalname, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type import declaration appears.

SingleTypeImportDeclaration:

import TypeName ;

The TypeName must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible ($6.6) or a compile-time error occurs.A single-type-import declaration

d in a compilation unit c of package p thatimports a type named
n shadows the declarations of:

* any top level type named n declared in another compilation unit of p.

* any type named n imported by a type-import-on-demand declaration in c.

throughout c.The example:

import java.util.Vector;
causes the simple name Vector to be available within the class and interface dec-larations in a compilation unit. Thus, the simple name

Vector refers to the type
Vector in the package java.util in all places where it is not shadowed ($6.3.1)or obscured ($6.3.2) by a declaration of a field, parameter, local variable, or nested

type declaration with the same name.If two single-type-import declarations in the same compilation unit attempt to
import types with the same simple name, then a compile-time error occurs, unlessthe two types are the same type, in which case the duplicate declaration is ignored.
If another top level type with the same simple name is otherwise declared in thecurrent compilation unit except by a type-import-on-demand declaration ($7.5.2),
then a compile-time error occurs.So the sample program:

import java.util.Vector;
class Vector { Object[] vec; }

causes a compile-time error because of the duplicate declaration of Vector, asdoes:

import java.util.Vector;
import myVector.Vector;

PACKAGES Type-Import-on-Demand Declaration 7.5.2

127DRAFT
where myVector is a package containing the compilation unit:

package myVector;
public class Vector { Object[] vec; }
The compiler keeps track of types by their binary names ($13.1).Note that an import statement cannot import a subpackage, only a type. For

example, it does not work to try to import java.util and then use the name
util.Random to refer to the type java.util.Random:

import java.util; // incorrect: compile-time error
class Test { util.Random generator; }

7.5.2 Type-Import-on-Demand Declaration
A type-import-on-demand declaration allows all accessible ($6.6) types declaredin the type or package named by a canonical name to be imported as needed.

TypeImportOnDemandDeclaration:

import PackageOrTypeName . * ;

It is a compile-time error for a type-import-on-demand declaration to name atype or package that is not accessible. Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package; theeffect is as if there were exactly one such declaration. It is not a compile-time
error to name the current package or java.lang in a type-import-on-demand dec-laration. The type-import-on-demand declaration is ignored in such cases

A type-import-on-demand declaration never causes any other declaration tobe shadowed.
The example:
import java.util.*;
causes the simple names of all public types declared in the package java.utilto be available within the class and interface declarations of the compilation unit.

Thus, the simple name Vector refers to the type Vector in the package
java.util in all places in the compilation unit where that type declaration is notshadowed ($6.3.1) or obscured ($6.3.2). The declaration might be shadowed by a

single-type-import declaration of a type whose simple name is Vector; by a typenamed

Vector and declared in the package to which the compilation unit belongs;or any nested classes or interfaces. The declaration might be obscured by a declaration of a field, parameter, or local variable named Vector (It would be unusualfor any of these conditions to occur.)

7.5.3 Automatic Imports PACKAGES

128 DRAFT

7.5.3 Automatic Imports
Each compilation unit automatically imports all of the public type namesdeclared in the predefined package

java.lang, as if the declaration:

import java.lang.*;
appeared at the beginning of each compilation unit, immediately following any
package statement.

7.5.4 A Strange Example
Package names and type names are usually different under the naming conven-tions described in $6.8. Nevertheless, in a contrived example where there is an

unconventionally-named package Vector, which declares a public class named
Mosquito:

package Vector;
public class Mosquito { int capacity; }

and then the compilation unit:

package strange.example;
import java.util.Vector;
import Vector.Mosquito;
class Test {

public static void main(String[] args) {

System.out.println(new Vector().getClass());
System.out.println(new Mosquito().getClass());
}
}

the single-type-import declaration ($7.5.1) importing class Vector from package
java.util does not prevent the package name Vector from appearing and beingcorrectly recognized in subsequent

import declarations. The example compilesand produces the output:

class java.util.Vector
class Vector.Mosquito

7.6 Top Level Type Declarations
A top level type declaration declares a top level class type ($8) or a top level inter-face type ($9):

PACKAGES Top Level Type Declarations 7.6

129DRAFT
TypeDeclaration:ClassDeclaration

InterfaceDeclaration
;

By default, the top level types declared in a package are accessible onlywithin the compilation units of that package, but a type may be declared to be

public to grant access to the type from code in other packages ($6.6, $8.1.1,$9.1.1).

The scope of a top level type is all type declarations in the package in whichthe top level type is declared.
If a top level type named T is declared in a compilation unit of a packagewhose fully qualified name is

P, then the fully qualified name of the type is P.T.If the type is declared in an unnamed package ($7.4.2), then the type has the fully

qualified name T.Thus in the example:

package wnj.points;
class Point { int x, y; }
the fully qualified name of class Point is wnj.points.Point.An implementation of the Java platform must keep track of types within packages by their binary names ($13.1). Multiple ways of naming a type must beexpanded to binary names to make sure that such names are understood as referring to the same type.For example, if a compilation unit contains the single-type-import declaration
($7.5.1):

import java.util.Vector;
then within that compilation unit the simple name Vector and the fully qualifiedname

java.util.Vector refer to the same type.When packages are stored in a file system ($7.2.1), the host system may

choose to enforce the restriction that it is a compile-time error if a type is notfound in a file under a name composed of the type name plus an extension (such
as .java or .jav) if either of the following is true:

* The type is referred to by code in other compilation units of the package inwhich the type is declared.

* The type is declared public (and therefore is potentially accessible fromcode in other packages).
This restriction implies that there must be at most one such type per compilationunit. This restriction makes it easy for a compiler for the Java programming lan7.6 Top Level Type Declarations PACKAGES
130 DRAFT

guage or an implementation of the Java virtual machine to find a named classwithin a package; for example, the source code for a

public type
wet.sprocket.Toad would be found in a file Toad.java in the directory wet/
sprocket, and the corresponding object code would be found in the file
Toad.class in the same directory.When packages are stored in a database ($7.2.2), the host system must not

impose such restrictions.In practice, many programmers choose to put each class or interface type in its
own compilation unit, whether or not it is public or is referred to by code in othercompilation units.

A compile-time error occurs if the name of a top level type appears as thename of any other top level class or interface type declared in the same package
($7.6).A compile-time error occurs if the name of a top level type is also declared as
a type by a single-type-import declaration ($7.5.1) in the compilation unit ($7.3)containing the type declaration.

In the example:
class Point { int x, y; }
the class Point is declared in a compilation unit with no package statement, andthus

Point is its fully qualified name, whereas in the example:

package vista;
class Point { int x, y; }

the fully qualified name of the class Point is vista.Point. (The package name
vista is suitable for local or personal use; if the package were intended to bewidely distributed, it would be better to give it a unique package name ($7.7).)

In the example:
package test;
import java.util.Vector;
class Point {

int x, y;}

interface Point { // compile-time error #1

int getR();
int getTheta();
}

class Vector { Point[] pts; } // compile-time error #2

PACKAGES Top Level Type Declarations 7.6

131DRAFT
the first compile-time error is caused by the duplicate declaration of the name
Point as both a class and an interface in the same package. A second errordetected at compile time is the attempt to declare the name

Vector both by a classtype declaration and by a single-type-import declaration.

Note, however, that it is not an error for the name of a class to also to name atype that otherwise might be imported by a type-import-on-demand declaration
($7.5.2) in the compilation unit ($7.3) containing the class declaration. In theexample:

package test;
import java.util.*;
class Vector { Point[] pts; } // not a compile-time error
the declaration of the class Vector is permitted even though there is also a class
java.util.Vector. Within this compilation unit, the simple name Vector refersto the class

test.Vector, not to java.util.Vector (which can still be referredto by code within the compilation unit, but only by its fully qualified name).

As another example, the compilation unit:
package points;
class Point {

int x, y; // coordinates
PointColor color; // color of this point
Point next; // next point with this color
static int nPoints;
}

class PointColor {

Point first; // first point with this color
PointColor(int color) {

this.color = color;
}
private int color; // color components
}

defines two classes that use each other in the declarations of their class members.Because the class types

Point and PointColor have all the type declarations inpackage
points, including all those in the current compilation unit, as theirscope, this example compiles correctly--that is, forward reference is not a problem.It is a compile-time error if a top level type declaration contains any one of the
following access modifiers: protected, private or static.

7.7 Unique Package Names PACKAGES

132 DRAFT

7.7   Unique Package Names
Developers should take steps to avoid the possibility of two published packageshaving the same name by choosing unique package names for packages that are
widely distributed. This allows packages to be easily and automatically installedand catalogued. This section specifies a suggested convention for generating such
unique package names. Implementations of the Java platform are encouraged toprovide automatic support for converting a set of packages from local and casual
package names to the unique name format described here.If unique package names are not used, then package name conflicts may arise
far from the point of creation of either of the conflicting packages. This maycreate a situation that is difficult or impossible for the user or programmer to
resolve. The class ClassLoader can be used to isolate packages with the samename from each other in those cases where the packages will have constrained
interactions, but not in a way that is transparent to a nai"ve program.You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as sun.com. You then reverse thisname, component by component, to obtain, in this example,

com.sun, and use thisas a prefix for your package names, using a convention developed within your

organization to further administer package names.In some cases, the internet domain name may not be a valid package name.
Here are some suggested conventions for dealing with these situations:

* If the domain name contains a hyphen, or any other special character notallowed in an identifier ($3.8), convert it into an underscore.

* If any of the resulting package name components are keywords ($3.9) thenappend underscore to them.

* If any of the resulting package name components start with a digit, or anyother character that is not allowed as an initial character of an identifier, have

an underscore prefixed to the component.
Such a convention might specify that certain directory name components bedivision, department, project, machine, or login names. Some possible examples:

com.sun.sunsoft.DOE
com.sun.java.jag.scrabble
com.apple.quicktime.v2
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder

The first component of a unique package name is always written in all-lowercaseASCII letters and should be one of the top level domain names, currently

com,
edu, gov, mil, net, org, or one of the English two-letter codes identifying counPACKAGES Unique Package Names 7.7

133DRAFT
tries as specified in ISO Standard 3166, 1981. For more information, refer to thedocuments stored at

ftp://rs.internic.net/rfc, for example, rfc920.txtand
rfc1032.txt.The name of a package is not meant to imply where the package is stored

within the Internet; for example, a package named edu.cmu.cs.bovik.cheeseis not necessarily obtainable from Internet address

cmu.edu or from cs.cmu.eduor from
bovik.cs.cmu.edu. The suggested convention for generating uniquepackage names is merely a way to piggyback a package naming convention on top

of an existing, widely known unique name registry instead of having to create aseparate registry for package names.

135DRAFT

C H A P T E R 8

Classes

CLASS declarations define new reference types and describe how they areimplemented ($8.1).

A nested class is any class whose declaration occurs within the body ofanother class or interface. A top level class is a class that is not a nested class.
This chapter discusses the common semantics of all classes--top level ($7.6)and nested (including member classes ($8.5, $9.5), local classes ($14.3) and anonymous classes ($15.9.5)). Details that are specific to particular kinds of classes arediscussed in the sections dedicated to these constructs.

A named class may be declared abstract ($8.1.1.1) and must be declared
abstract if it is incompletely implemented; such a class cannot be instantiated,but can be extended by subclasses. A class may be declared

final ($8.1.1.2), inwhich case it cannot have subclasses. If a class is declared
public, then it can bereferred to from other packages.

Each class except Object is an extension of (that is, a subclass of) a singleexisting class ($8.1.3) and may implement interfaces ($8.1.4).
The body of a class declares members (fields and methods and nested classes
and interfaces), instance and static initializers, and constructors ($8.1.5). The
scope ($6.3) of a member ($8.2) is the entire declaration of the class to which the
member belongs. Field, method, member class, member interface, and constructor
declarations may include the access modifiers ($6.6) public, protected, or
private. The members of a class include both declared and inherited members
($8.2). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or
interface members declared in a superclass or superinterface. Newly declared
methods can hide, implement, or override methods declared in a superclass or
superinterface.

8.1 Class Declaration CLASSES
136 DRAFT

Field declarations ($8.3) describe class variables, which are incarnated once,and instance variables, which are freshly incarnated for each instance of the class.
A field may be declared final ($8.3.1.2), in which case it can be assigned to onlyonce. Any field declaration may include an initializer.

Member class declarations ($8.5) describe nested classes that are members ofthe surrounding class. Member classes may be

static, in which case they haveno access to the instance variables of the surrounding class; or they may be inner

classes ($8.1.2).Member interface declarations ($8.5) describe nested interfaces that are members of the surrounding class.Method declarations ($8.4) describe code that may be invoked by method
invocation expressions ($15.12). A class method is invoked relative to the classtype; an instance method is invoked with respect to some particular object that is
an instance of the class type. A method whose declaration does not indicate how itis implemented must be declared

abstract. A method may be declared final($8.4.3.3), in which case it cannot be hidden or overridden. A method may be

implemented by platform-dependent native code ($8.4.3.4). A synchronizedmethod ($8.4.3.6) automatically locks an object before executing its body and
automatically unlocks the object on return, as if by use of a synchronized state-ment ($14.18), thus allowing its activities to be synchronized with those of other
threads ($17).Method names may be overloaded ($8.4.7).

Instance initializers ($8.6) are blocks of executable code that may be used tohelp initialize an instance when it is created ($15.9).
Static initializers ($8.7) are blocks of executable code that may be used tohelp initialize a class when it is first loaded ($12.4).
Constructors ($8.8) are similar to methods, but cannot be invoked directly bya method call; they are used to initialize new class instances. Like methods, they
may be overloaded ($8.8.6).

8.1   Class Declaration
A class declaration specifies a new named reference type:

ClassDeclaration:ClassModifiers

opt class Identifier Superopt Interfacesopt ClassBody

The Identifier in a class declaration specifies the name of the class. A com-pile-time error occurs if a class has the same simple name as any of its enclosing

classes or interfaces.

CLASSES Class Modifiers 8.1.1

137DRAFT
8.1.1 Class Modifiers
A class declaration may include class modifiers.

ClassModifiers:ClassModifier

ClassModifiers ClassModifier
ClassModifier: one of

public protected private
abstract static final strictfp

Not all modifiers are applicable to all kinds of class declarations. The accessmodifier

public pertains only to top level classes ($7.6) and to member classes($8.5, $9.5), and is discussed in $6.6, $8.5 and $9.5. The access modifiers

protected and private pertain only to member classes within a directly enclos-ing class declaration ($8.5) and are discussed in $8.5.1. The access modifier
static pertains only to member classes ($8.5, $9.5). A compile-time error occursif the same modifier appears more than once in a class declaration.

If two or more class modifiers appear in a class declaration, then it is custom-ary, though not required, that they appear in the order consistent with that shown
above in the production for ClassModifier.
8.1.1.1 abstract Classes
An abstract class is a class that is incomplete, or to be considered incomplete.Only

abstract classes may have abstract methods ($8.4.3.1, $9.4), that is,methods that are declared but not yet implemented. If a class that is not

abstractcontains an
abstract method, then a compile-time error occurs. A class C has
abstract methods if any of the following is true:

* C explicitly contains a declaration of an abstract method ($8.4.3).

* Any of C's superclasses declares an abstract method that has not beenimplemented ($8.4.6.1) in C or any of its superclasses.

* A direct superinterface ($8.1.4) of C declares or inherits a method (which istherefore necessarily

abstract) and C neither declares nor inherits a methodthat implements it.

In the example:
abstract class Point {

int x = 1, y = 1;
void move(int dx, int dy) {

x += dx;
y += dy;
alert();

8.1.1 Class Modifiers CLASSES
138 DRAFT

}
abstract void alert();
}

abstract class ColoredPoint extends Point {

int color;
}

class SimplePoint extends Point {

void alert() { }
}

a class Point is declared that must be declared abstract, because it contains adeclaration of an

abstract method named alert. The subclass of Point named
ColoredPoint inherits the abstract method alert, so it must also be declared
abstract. On the other hand, the subclass of Point named SimplePoint pro-vides an implementation of

alert, so it need not be abstract.A compile-time error occurs if an attempt is made to create an instance of an

abstract class using a class instance creation expression ($15.9).Thus, continuing the example just shown, the statement:

Point p = new Point();
would result in a compile-time error; the class Point cannot be instantiatedbecause it is

abstract. However, a Point variable could correctly be initializedwith a reference to any subclass of

Point, and the class SimplePoint is not
abstract, so the statement:

Point p = new SimplePoint();
would be correct.A subclass of an

abstract class that is not itself abstract may be instanti-ated, resulting in the execution of a constructor for the

abstract class and, there-fore, the execution of the field initializers for instance variables of that class. Thus,

in the example just given, instantiation of a SimplePoint causes the default con-structor and field initializers for

x and y of Point to be executed.It is a compile-time error to declare an

abstract class type such that it is notpossible to create a subclass that implements all of its

abstract methods. Thissituation can occur if the class would have as members two

abstract methodsthat have the same method signature ($8.4.2) but different return types.

As an example, the declarations:
interface Colorable { void setColor(int color); }
abstract class Colored implements Colorable {

abstract int setColor(int color);
}

CLASSES Class Modifiers 8.1.1

139DRAFT
result in a compile-time error: it would be impossible for any subclass of class
Colored to provide an implementation of a method named setColor, taking oneargument of type

int, that can satisfy both abstract method specifications,because the one in interface

Colorable requires the same method to return novalue, while the one in class
Colored requires the same method to return a valueof type
int ($8.4).A class type should be declared

abstract only if the intent is that subclassescan be created to complete the implementation. If the intent is simply to prevent

instantiation of a class, the proper way to express this is to declare a constructor($8.8.8) of no arguments, make it

private, never invoke it, and declare no otherconstructors. A class of this form usually contains class methods and variables.

The class Math is an example of a class that cannot be instantiated; its declarationlooks like this:

public final class Math {

private Math() { } // never instantiate this class

. . . declarations of class variables and methods . . .}

8.1.1.2 final Classes
A class can be declared final if its definition is complete and no subclasses aredesired or required. A compile-time error occurs if the name of a

final classappears in the
extends clause ($8.1.3) of another class declaration; this impliesthat a
final class cannot have any subclasses. A compile-time error occurs if aclass is declared both

final and abstract, because the implementation of such aclass could never be completed ($8.1.1.1).

Because a final class never has any subclasses, the methods of a final classare never overridden ($8.4.6.1).

8.1.1.3 strictfp Classes
The effect of the strictfp modifier is to make all float or double expressionswithin the class declaration be explicitly FP-strict ($15.4). This implies that all

methods declared in the class, and all nested types declared in the class, areimplicitly

strictfp.Note also that all

float or double expressions within all variable initializ-ers, instance initializers, static initializers and constructors of the class will also be

explicitly FP-strict.

8.1.2 Inner Classes and Enclosing Instances CLASSES

140 DRAFT

8.1.2 Inner Classes and Enclosing Instances
An inner class is a nested class that is not explicitly or implicitly declared
static. Inner classes may not declare static initializers ($8.7) or member inter-faces. Inner classes may not declare static members, unless they are compile-time

constant fields ($15.28).To illustrate these rules, consider the example below:

class HasStatic{

static int j = 100;
}

class Outer{

class Inner extends HasStatic{

static final x = 3;// ok - compile-time constant
static int y = 4; // compile-time error, an inner class
}

static class NestedButNotInner{

static int z = 5; // ok, not an inner class
}

interface NeverInner{} // interfaces are never inner
}

Inner classes may inherit static members that are not compile-time constants eventhough they may not declare them. Nested classes that are not inner classes may

declare static members freely, in accordance with the usual rules of the Java pro-gramming language. Member interfaces ($8.5) are always implicitly static so they
are never considered to be inner classes.A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, orexplicit constructor statement enclosing the statement or expression is a static
method, a static initializer, the variable initializer of a static variable, or an explicitconstructor invocation statement ($8.8.5).

An inner class C is a direct inner class of a class O if O is the immediately lex-ically enclosing class of

C and the declaration of C does not occur in a static con-text. A class
C is an inner class of class O if it is either a direct inner class of O oran inner class of an inner class of

O.A class
O is the zeroth lexically enclosing class of itself. A class O is the nthlexically enclosing class of a class

C if it is the immediately enclosing class of thest lexically enclosing class of
C.An instance
i of a direct inner class C of a class O is associated with aninstance of
O, known as the immediately enclosing instance of i. The immediatelyenclosing instance of an object, if any, is determined when the object is created

($15.9.2).

n 1-

CLASSES Inner Classes and Enclosing Instances 8.1.2

141DRAFT
An object o is the zeroth lexically enclosing instance of itself. An object o isthe nth lexically enclosing instance of an instance

i if it is the immediatelyenclosing instance of the st lexically enclosing instance of

i.When an inner class refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosinginstance is used. A blank final ($4.5.4) field of a lexically enclosing class may not
be assigned within an inner class.An instance of an inner class

I whose declaration occurs in a static contexthas no lexically enclosing instances. However, if

I is immediately declared withina static method or static initializer then
I does have an enclosing block, which isthe innermost block statement lexically enclosing the declaration of

I.Furthermore, for every superclass
S of C which is itself a direct inner class of aclass
SO, there is an instance of SO associated with i, known as the immediatelyenclosing instance of i with respect to S. The immediately enclosing instance of an

object with respect to its class' direct superclass, if any, is determined when thesuperclass constructor is invoked via an explicit constructor invocation statement.

Any local variable, formal method parameter or exception handler parameterused but not declared in an inner class must be declared

final, and must be defi-nitely assigned ($16) before the body of the inner class.

Inner classes include local ($14.3), anonymous ($15.9.5) and non-static mem-ber classes ($8.5). Here are some examples:

class Outer {

int i = 100;

static void classMethod() {

final int l = 200;

class LocalInStaticContext{

int k = i; // compile-time error
int m = l; // ok
}
}

void foo() {

class Local { // a local class

int j = i;
}
}
}

The declaration of class LocalInStaticContext occurs in a static context--within the static method

classMethod. Instance variables of class Outer are notavailable within the body of a static method. In particular, instance variables of

Outer are not available inside the body of LocalInStaticContext. However,

n 1-
8.1.3 Superclasses and Subclasses CLASSES

142 DRAFT

local variables from the surrounding method may be referred to without error(provided they are marked

final).Inner classes whose declarations do not occur in a static context may freely

refer to the instance variables of their enclosing class. An instance variable isalways defined with respect to an instance. In the case of instance variables of an
enclosing class, the instance variable must be defined with respect to an enclosinginstance of that class So, for example, the class

Local above has an enclosinginstance of class
Outer. As a further example:

class WithDeepNesting{

boolean toBe;

WithDeepNesting(boolean b) { toBe = b;}
class Nested {

boolean theQuestion;
class DeeplyNested {

DeeplyNested(){

theQuestion = toBe || !toBe;
}
}
}
}

Here, every instance of WithDeepNesting.Nested.DeeplyNested has anenclosing instance of class

WithDeepNesting.Nested (its immediately enclos-ing instance) and an enclosing instance of class

WithDeepNesting (its 2nd lexi-cally enclosing instance).

8.1.3 Superclasses and Subclasses
The optional extends clause in a class declaration specifies the direct superclassof the current class. A class is said to be a direct subclass of the class it extends.

The direct superclass is the class from whose implementation the implementationof the current class is derived. The

extends clause must not appear in the defini-tion of the class
Object, because it is the primordial class and has no direct super-class. If the class declaration for any other class has no

extends clause, then theclass has the class
Object as its implicit direct superclass.

Super:

extends ClassType

The following is repeated from $4.3 to make the presentation here clearer:

ClassType:TypeName

CLASSES Superclasses and Subclasses 8.1.3

143DRAFT
The ClassType must name an accessible ($6.6) class type, or a compile-timeerror occurs. If the specified ClassType names a class that is

final ($8.1.1.2),then a compile-time error occurs;
final classes are not allowed to have sub-classes.

In the example:
class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; } // error

the relationships are as follows:

* The class Point is a direct subclass of Object.

* The class Object is the direct superclass of the class Point.

* The class ColoredPoint is a direct subclass of class Point.

* The class Point is the direct superclass of class ColoredPoint.
The declaration of class Colored3dPoint causes a compile-time error because itattempts to extend the

final class ColoredPoint.The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true:

* A is the direct subclass of C.

* There exists a class B such that A is a subclass of B, and B is a subclass of C,applying this definition recursively.

Class C is said to be a superclass of class A whenever A is a subclass of C.In the example:

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }

the relationships are as follows:

* The class Point is a superclass of class ColoredPoint.

* The class Point is a superclass of class Colored3dPoint.

* The class ColoredPoint is a subclass of class Point.

* The class ColoredPoint is a superclass of class Colored3dPoint.

* The class Colored3dPoint is a subclass of class ColoredPoint.

* The class Colored3dPoint is a subclass of class Point.

8.1.4 Superinterfaces CLASSES
144 DRAFT

A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier within asuperclass or superinterface name. A class

C depends on a reference type T if anyof the following conditions hold:

* C directly depends on T.

* C directly depends on an interface I that depends ($9.1.2) on T.

* C directly depends on a class D that depends on T (using this definition recur-sively).

It is a compile-time error if a class depends on itself.For example:

class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
causes a compile-time error.If circularly declared classes are detected at run time, as classes are loaded

($12.2), then a ClassCircularityError is thrown.

8.1.4   Superinterfaces
The optional implements clause in a class declaration lists the names of inter-faces that are direct superinterfaces of the class being declared:

Interfaces:

implements InterfaceTypeList

InterfaceTypeList:InterfaceType

InterfaceTypeList , InterfaceType
The following is repeated from $4.3 to make the presentation here clearer:

InterfaceType:TypeName

Each InterfaceType must name an accessible ($6.6) interface type, or a compile-time error occurs.

A compile-time error occurs if the same interface is mentioned two or moretimes in a single

implements clause.This is true even if the interface is named in different ways; for example, the

code:

CLASSES Superinterfaces 8.1.4

145DRAFT
class Redundant implements java.lang.Cloneable, Cloneable {

int x;
}

results in a compile-time error because the names java.lang.Cloneable and
Cloneable refer to the same interface.An interface type

I is a superinterface of class type C if any of the followingis true:

* I is a direct superinterface of C.

* C has some direct superinterface J for which I is a superinterface, using thedefinition of "superinterface of an interface" given in $9.1.2.

* I is a superinterface of the direct superclass of C.
A class is said to implement all its superinterfaces.In the example:

public interface Colorable {

void setColor(int color);
int getColor();
}

public interface Paintable extends Colorable {

int MATTE = 0, GLOSSY = 1;
void setFinish(int finish);
int getFinish();
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {

int color;
public void setColor(int color) { this.color = color; }
public int getColor() { return color; }
}

class PaintedPoint extends ColoredPoint implements Paintable
{

int finish;
public void setFinish(int finish) {

this.finish = finish;
}
public int getFinish() { return finish; }
}

the relationships are as follows:

8.1.4 Superinterfaces CLASSES

146 DRAFT

* The interface Paintable is a superinterface of class PaintedPoint.

* The interface Colorable is a superinterface of class ColoredPoint and ofclass

PaintedPoint.

* The interface Paintable is a subinterface of the interface Colorable, and

Colorable is a superinterface of Paintable, as defined in $9.1.2.

A class can have a superinterface in more than one way. In this example, the class
PaintedPoint has Colorable as a superinterface both because it is a superinter-face of

ColoredPoint and because it is a superinterface of Paintable.Unless the class being declared is

abstract, the declarations of all themethod members of each direct superinterface must be implemented either by a

declaration in this class or by an existing method declaration inherited from thedirect superclass, because a class that is not

abstract is not permitted to have
abstract methods ($8.1.1.1).Thus, the example:

interface Colorable {

void setColor(int color);
int getColor();
}

class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {

int color;
}

causes a compile-time error, because ColoredPoint is not an abstract class butit fails to provide an implementation of methods

setColor and getColor of theinterface
Colorable.It is permitted for a single method declaration in a class to implement methods

of more than one superinterface. For example, in the code:

interface Fish { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {

// You can tune a piano, but can you tuna fish?
int getNumberOfScales() { return 91; }
}

the method getNumberOfScales in class Tuna has a name, signature, and returntype that matches the method declared in interface

Fish and also matches themethod declared in interface
Piano; it is considered to implement both.On the other hand, in a situation such as this:

CLASSES Class Body and Member Declarations 8.1.5

147DRAFT
interface Fish { int getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {

// This declaration cannot be correct, no matter what type is used.
public ??? getNumberOfScales() { return 91; }
}

It is impossible to declare a method named getNumberOfScales with the samesignature and return type as those of both the methods declared in interface

Fishand in interface
StringBass, because a class can have only one method with agiven signature ($8.4). Therefore, it is impossible for a single class to implement

both interface Fish and interface StringBass ($8.4.6).

8.1.5 Class Body and Member Declarations
A class body may contain declarations of members of the class, that is, fields($8.3), classes ($8.5), interfaces ($8.5) and methods ($8.4). A class body may also

contain instance initializers ($8.6), static initializers ($8.7), and declarations ofconstructors ($8.8) for the class.

ClassBody:

{ ClassBodyDeclarationsopt }

ClassBodyDeclarations:ClassBodyDeclaration

ClassBodyDeclarations ClassBodyDeclaration
ClassBodyDeclaration:ClassMemberDeclaration

InstanceInitializerStaticInitializer
ConstructorDeclaration
ClassMemberDeclaration:FieldDeclaration

MethodDeclarationClassDeclaration
InterfaceDeclaration
;

The scope of a declaration of a member m declared in or inherited by a class
type C is the entire body of C, including any nested type declarations.

If C itself is a nested class, there may be definitions of the same kind (variable,method, or type) for

m in enclosing scopes. (The scopes may be blocks, classes, or

8.2 Class Members CLASSES
148 DRAFT

packages.) In all such cases, the member m declared or inherited in C shadows($6.3.1) the other definitions of

m.

8.2   Class Members

The members of a class type are all of the following:

* Members inherited from its direct superclass ($8.1.3), except in class Object,which has no direct superclass

* Members inherited from any direct superinterfaces ($8.1.4)

* Members declared in the body of the class ($8.1.5)

Members of a class that are declared private are not inherited by subclassesof that class. Only members of a class that are declared

protected or public areinherited by subclasses declared in a package other than the one in which the class

is declared.Constructors, static initializers, and instance initializers are not members and
therefore are not inherited.The example:

class Point {

int x, y;
private Point() { reset(); }
Point(int x, int y) { this.x = x; this.y = y; }
private void reset() { this.x = 0; this.y = 0; }
}

class ColoredPoint extends Point {

int color;
void clear() { reset(); } // error
}

class Test {

public static void main(String[] args) {

ColoredPoint c = new ColoredPoint(0, 0); // error
c.reset(); // error
}
}

causes four compile-time errors:

CLASSES Examples of Inheritance 8.2.1

149DRAFT

* An error occurs because ColoredPoint has no constructor declared with twointeger parameters, as requested by the use in

main. This illustrates the factthat
ColoredPoint does not inherit the constructors of its superclass Point.

* Another error occurs because ColoredPoint declares no constructors, andtherefore a default constructor for it is automatically created ($8.8.7), and this

default constructor is equivalent to:

ColoredPoint() { super(); }
which invokes the constructor, with no arguments, for the direct superclass ofthe class

ColoredPoint. The error is that the constructor for Point that takesno arguments is

private, and therefore is not accessible outside the class
Point, even through a superclass constructor invocation ($8.8.5).

Two more errors occur because the method reset of class Point is private, andtherefore is not inherited by class

ColoredPoint. The method invocations inmethod
clear of class ColoredPoint and in method main of class Test aretherefore not correct.

8.2.1   Examples of Inheritance
This section illustrates inheritance of class members through several examples.

8.2.1.1 Example: Inheritance with Default Access
Consider the example where the points package declares two compilation units:

package points;
public class Point {

int x, y;
public void move(int dx, int dy) { x += dx; y += dy; }
}

and:

package points;
public class Point3d extends Point {

int z;
public void move(int dx, int dy, int dz) {

x += dx; y += dy; z += dz;
}
}

and a third compilation unit, in another package, is:

8.2.1 Examples of Inheritance CLASSES
150 DRAFT

import points.Point3d;
class Point4d extends Point3d {

int w;
public void move(int dx, int dy, int dz, int dw) {

x += dx; y += dy; z += dz; w += dw; // compile-time errors
}
}

Here both classes in the points package compile. The class Point3d inherits thefields

x and y of class Point, because it is in the same package as Point. Theclass
Point4d, which is in a different package, does not inherit the fields x and yof class

Point or the field z of class Point3d, and so fails to compile.A better way to write the third compilation unit would be:

import points.Point3d;
class Point4d extends Point3d {

int w;
public void move(int dx, int dy, int dz, int dw) {

super.move(dx, dy, dz); w += dw;
}
}

using the move method of the superclass Point3d to process dx, dy, and dz. If
Point4d is written in this way it will compile without errors.

8.2.1.2 Inheritance with public and protected
Given the class Point:

package points;
public class Point {

public int x, y;
protected int useCount = 0;
static protected int totalUseCount = 0;
public void move(int dx, int dy) {

x += dx; y += dy; useCount++; totalUseCount++;
}

}
the public and protected fields x, y, useCount and totalUseCount are inher-ited in all subclasses of

Point.Therefore, this test program, in another package, can be compiled successfully:

CLASSES Examples of Inheritance 8.2.1

151DRAFT
class Test extends points.Point {

public void moveBack(int dx, int dy) {

x -= dx; y -= dy; useCount++; totalUseCount++;
}
}

8.2.1.3 Inheritance with private
In the example:

class Point {

int x, y;
void move(int dx, int dy) {

x += dx; y += dy; totalMoves++;
}

private static int totalMoves;
void printMoves() { System.out.println(totalMoves); }
}
class Point3d extends Point {

int z;
void move(int dx, int dy, int dz) {

super.move(dx, dy); z += dz; totalMoves++;
}

}
the class variable totalMoves can be used only within the class Point; it is notinherited by the subclass

Point3d. A compile-time error occurs because method
move of class Point3d tries to increment totalMoves.

8.2.1.4 Accessing Members of Inaccessible Classes
Even though a class might not be declared public, instances of the class might beavailable at run time to code outside the package in which it is declared if it has a

public superclass or superinterface. An instance of the class can be assigned to avariable of such a

public type. An invocation of a public method of the objectreferred to by such a variable may invoke a method of the class if it implements or

overrides a method of the public superclass or superinterface. (In this situation,the method is necessarily declared

public, even though it is declared in a classthat is not
public.)Consider the compilation unit:

8.2.1 Examples of Inheritance CLASSES

152 DRAFT

package points;
public class Point {

public int x, y;
public void move(int dx, int dy) {

x += dx; y += dy;
}
}

and another compilation unit of another package:

package morePoints;
class Point3d extends points.Point {

public int z;
public void move(int dx, int dy, int dz) {

super.move(dx, dy); z += dz;
}
public void move(int dx, int dy) {

move(dx, dy, 0);
}
}

public class OnePoint {

public static points.Point getOne() {

return new Point3d();
}
}

An invocation morePoints.OnePoint.getOne() in yet a third package wouldreturn a

Point3d that can be used as a Point, even though the type Point3d isnot available outside the package

morePoints. The two argument version ofmethod
move could then be invoked for that object, which is permissible becausemethod
move of Point3d is public (as it must be, for any method that overrides a
public method must itself be public, precisely so that situations such as this willwork out correctly). The fields

x and y of that object could also be accessed fromsuch a third package.

While the field z of class Point3d is public, it is not possible to access thisfield from code outside the package

morePoints, given only a reference to aninstance of class
Point3d in a variable p of type Point. This is because theexpression
p.z is not correct, as p has type Point and class Point has no fieldnamed
z; also, the expression ((Point3d)p).z is not correct, because the classtype
Point3d cannot be referred to outside package morePoints.The declaration of the field

z as public is not useless, however. If there wereto be, in package
morePoints, a public subclass Point4d of the class Point3d:

package morePoints;
public class Point4d extends Point3d {

public int w;

CLASSES Field Declarations 8.3

153DRAFT
public void move(int dx, int dy, int dz, int dw) {

super.move(dx, dy, dz); w += dw;
}
}

then class Point4d would inherit the field z, which, being public, could then beaccessed by code in packages other than

morePoints, through variables andexpressions of the
public type Point4d.

8.3   Field Declarations
The variables of a class type are introduced by field declarations:

FieldDeclaration:FieldModifiers

opt Type VariableDeclarators ;

VariableDeclarators:VariableDeclarator

VariableDeclarators , VariableDeclarator
VariableDeclarator:VariableDeclaratorId

VariableDeclaratorId = VariableInitializer
VariableDeclaratorId:Identifier

VariableDeclaratorId [ ]
VariableInitializer:Expression

ArrayInitializer
The FieldModifiers are described in $8.3.1. The Identifier in a FieldDeclaratormay be used in a name to refer to the field. Fields are members; the scope ($6.3)

of a field declaration is specified in $8.1.5. More than one field may be declared ina single field declaration by using more than one declarator; the FieldModifiers
and Type apply to all the declarators in the declaration. Variable declarationsinvolving array types are discussed in $10.2.

It is a compile-time error for the body of a class declaration to declare twofields with the same name. Methods, types, and fields may have the same name,
since they are used in different contexts and are disambiguated by different lookupprocedures ($6.5).

If the class declares a field with a certain name, then the declaration of thatfield is said to hide any and all accessible declarations of fields with the same
name in superclasses, and superinterfaces of the class. The field declaration also

8.3.1 Field Modifiers CLASSES
154 DRAFT

shadows ($6.3.1) declarations of any accessible fields in enclosing classes orinterfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.If a field declaration hides the declaration of another field, the two fields need
not have the same type.A class inherits from its direct superclass and direct superinterfaces all the
non-private fields of the superclass and superinterfaces that are both accessible tocode in the class and not hidden by a declaration in the class.

Note that a private field of a superclass might be accessible to a subclass (forexample, if both classes are members of the same class). Nevertheless, a private
field is never inherited by a subclass.It is possible for a class to inherit more than one field with the same name
($8.3.3.3). Such a situation does not in itself cause a compile-time error. However,any attempt within the body of the class to refer to any such field by its simple
name will result in a compile-time error, because such a reference is ambiguous.There might be several paths by which the same field declaration might be
inherited from an interface. In such a situation, the field is considered to be inher-ited only once, and it may be referred to by its simple name without ambiguity.

A hidden field can be accessed by using a qualified name (if it is static) orby using a field access expression ($15.11) that contains the keyword

super or acast to a superclass type. See $15.11.2 for discussion and an example.

A value stored in a field of type float is always an element of the float valueset ($4.2.3); similarly, a value stored in a field of type

double is always an ele-ment of the double value set. It is not permitted for a field of type

float to containan element of the float-extended-exponent value set that is not also an element of

the float value set, nor for a field of type double to contain an element of the dou-ble-extended-exponent value set that is not also an element of the double value
set.

8.3.1 Field Modifiers

FieldModifiers:FieldModifier

FieldModifiers FieldModifier
FieldModifier: one of

public protected private
static final transient volatile

The access modifiers public, protected, and private are discussed in $6.6. Acompile-time error occurs if the same modifier appears more than once in a field

CLASSES Field Modifiers 8.3.1

155DRAFT
declaration, or if a field declaration has more than one of the access modifiers
public, protected, and private.If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with thatshown above in the production for FieldModifier.

8.3.1.1 static Fields
If a field is declared static, there exists exactly one incarnation of the field, nomatter how many instances (possibly zero) of the class may eventually be created.

A static field, sometimes called a class variable, is incarnated when the class isinitialized ($12.4).

A field that is not declared static (sometimes called a non-static field) iscalled an instance variable. Whenever a new instance of a class is created, a new
variable associated with that instance is created for every instance variabledeclared in that class or any of its superclasses. The example program:

class Point {

int x, y, useCount;
Point(int x, int y) { this.x = x; this.y = y; }
final static Point origin = new Point(0, 0);
}

class Test {

public static void main(String[] args) {

Point p = new Point(1,1);
Point q = new Point(2,2);
p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
System.out.println("(" + q.x + "," + q.y + ")");
System.out.println(q.useCount);
System.out.println(q.origin == Point.origin);
System.out.println(q.origin.useCount);
}
}

prints:

(2,2)
0
true
1

showing that changing the fields x, y, and useCount of p does not affect the fieldsof

q, because these fields are instance variables in distinct objects. In this example,the class variable

origin of the class Point is referenced both using the classname as a qualifier, in

Point.origin, and using variables of the class type infield access expressions ($15.11), as in

p.origin and q.origin. These two ways

8.3.1 Field Modifiers CLASSES
156 DRAFT

of accessing the origin class variable access the same object, evidenced by thefact that the value of the reference equality expression ($15.21.3):

q.origin==Point.origin
is true. Further evidence is that the incrementation:

p.origin.useCount++;
causes the value of q.origin.useCount to be 1; this is so because p.origin and
q.origin refer to the same variable.

8.3.1.2 final Fields
A field can be declared final ($4.5.4). Both class and instance variables (staticand nonstatic fields) may be declared final.It is a compile-time error if a blank

final ($4.5.4) class variable is not defi-nitely assigned ($16.7) by a static initializer ($8.7) of the class in which it is

declared.A blank

final instance variable must be definitely assigned ($16.8) at the endof every constructor ($8.8) of the class in which it is declared; otherwise a compile-time error occurs.
8.3.1.3 transient Fields
Variables may be marked transient to indicate that they are not part of the per-sistent state of an object.

If an instance of the class Point:
class Point {

int x, y;
transient float rho, theta;
}

were saved to persistent storage by a system service, then only the fields x and ywould be saved. This specification does not specify details of such services; see

the specification of java.io.Serializable for an example of such a service.
8.3.1.4 volatile Fields
As described in $17, the Java programming language allows threads that accessshared variables to keep private working copies of the variables; this allows a

more efficient implementation of multiple threads. These working copies need bereconciled with the master copies in the shared main memory only at prescribed
synchronization points, namely when objects are locked or unlocked. As a rule, toensure that shared variables are consistently and reliably updated, a thread should

CLASSES Field Modifiers 8.3.1

157DRAFT
ensure that it has exclusive use of such variables by obtaining a lock that, conven-tionally, enforces mutual exclusion for those shared variables.

The Java programming language provides a second mechanism, volatilefields, that is more convenient for some purposes.
A field may be declared volatile, in which case a thread must reconcile itsworking copy of the field with the master copy every time it accesses the variable.
Moreover, operations on the master copies of one or more volatile variables onbehalf of a thread are performed by the main memory in exactly the order that the
thread requested.If, in the following example, one thread repeatedly calls the method

one (butno more than
Integer.MAX_VALUE times in all), and another thread repeatedlycalls the method

two:

class Test {

static int i = 0, j = 0;
static void one() { i++; j++; }
static void two() {

System.out.println("i=" + i + " j=" + j);
}

}

then method two could occasionally print a value for j that is greater than thevalue of

i, because the example includes no synchronization and, under the rulesexplained in $17, the shared values of

i and j might be updated out of order.One way to prevent this out-or-order behavior would be to declare methods

one and two to be synchronized ($8.4.3.6):

class Test {

static int i = 0, j = 0;
static synchronized void one() { i++; j++; }
static synchronized void two() {

System.out.println("i=" + i + " j=" + j);
}

}

This prevents method one and method two from being executed concurrently, andfurthermore guarantees that the shared values of

i and j are both updated beforemethod
one returns. Therefore method two never observes a value for j greaterthan that for

i; indeed, it always observes the same value for i and j.Another approach would be to declare

i and j to be volatile:

8.3.2 Initialization of Fields CLASSES
158 DRAFT

class Test {

static volatile int i = 0, j = 0;
static void one() { i++; j++; }
static void two() {

System.out.println("i=" + i + " j=" + j);
}

}

This allows method one and method two to be executed concurrently, butguarantees that accesses to the shared values for

i and j occur exactly as manytimes, and in exactly the same order, as they appear to occur during execution of

the program text by each thread. Therefore, the shared value for j is never greaterthan that for

i, because each update to i must be reflected in the shared value for
i before the update to j occurs. It is possible, however, that any given invocationof method

two might observe a value for j that is much greater than the valueobserved for

i, because method one might be executed many times between themoment when method

two fetches the value of i and the moment when method
two fetches the value of j.See $17 for more discussion and examples.

A compile-time error occurs if a final variable is also declared volatile.

8.3.2   Initialization of Fields
If a field declarator contains a variable initializer, then it has the semantics of anassignment ($15.26) to the declared variable, and:

* If the declarator is for a class variable (that is, a static field), then the vari-able initializer is evaluated and the assignment performed exactly once, when

the class is initialized ($12.4).

* If the declarator is for an instance variable (that is, a field that is not static),then the variable initializer is evaluated and the assignment performed each

time an instance of the class is created ($12.5).
The example:
class Point {

int x = 1, y = 5;
}

class Test {

public static void main(String[] args) {

Point p = new Point();
System.out.println(p.x + ", " + p.y);

CLASSES Initialization of Fields 8.3.2

159DRAFT
}
}

produces the output:

1, 5
because the assignments to x and y occur whenever a new Point is created.Variable initializers are also used in local variable declaration statements

($14.4), where the initializer is evaluated and the assignment performed each timethe local variable declaration statement is executed.

It is a compile-time error if the evaluation of a variable initializer for a staticfield or for a instance variable of a named class (or of an interface) can complete
abruptly with a checked exception ($11.2).
8.3.2.1 Initializers for Class Variables
If a reference by simple name to any instance variable occurs in an initializationexpression for a class variable, then a compile-time error occurs.

If the keyword this ($15.8.3) or the keyword super ($15.11.2, $15.12)occurs in an initialization expression for a class variable, then a compile-time
error occurs.One subtlety here is that, at run time,

static variables that are final and thatare initialized with compile-time constant values are initialized first. This also

applies to such fields in interfaces ($9.3.1). These variables are "constants" thatwill never be observed to have their default initial values ($4.5.5), even by devious
programs. See $12.4.2 and $13.4.8 for more discussion.Use of class variables whose declarations appear textually after the use is
sometimes restricted, even though these class variables are in scope. See $8.3.2.3for the precise rules governing forward reference to class variables.

8.3.2.2 Initializers for Instance Variables
Initialization expressions for instance variables may use the simple name of any
static variable declared in or inherited by the class, even one whose declarationoccurs textually later.

Thus the example:
class Test {

float f = j;
static int j = 1;
}

compiles without error; it initializes j to 1 when class Test is initialized, and ini-tializes

f to the current value of j every time an instance of class Test is created.

8.3.2 Initialization of Fields CLASSES
160 DRAFT

Initialization expressions for instance variables are permitted to refer to thecurrent object

this ($15.8.3) and to use the keyword super ($15.11.2, $15.12).Use of instance variables whose declarations appear textually after the use is

sometimes restricted, even though these instance variables are in scope. See$8.3.2.3 for the precise rules governing forward reference to instance variables.

8.3.2.3 Restrictions on the use of Fields during Initialization

The declaration of a member needs to appear before it is used only if themember is an instance (respectively

static) field of a class or interface C and allof the following conditions hold:

* The usage occurs in an instance (respectively static) variable initializer of Cor in an instance (respectively

static) initializer of C.

* The usage is not on the left hand side of an assignment.

* C is the innermost class or interface enclosing the usage.

A compile-time error occurs if any of the three requirements above are notmet.
This means that a compile-time error results from the test program:

class Test {

int i = j; // compile-time error: incorrect forward reference
int j = 1;

}

whereas the following example compiles without error:

class Test {

Test() { k = 2; }
int j = 1;
int i = j;
int k;

}

even though the constructor ($8.8) for Test refers to the field k that is declaredthree lines later.

These restrictions are designed to catch, at compile time, circular or otherwisemalformed initializations. Thus, both:

class Z {

static int i = j + 2;
static int j = 4;
}

and:

CLASSES Initialization of Fields 8.3.2

161DRAFT
class Z {

static { i = j + 2; }
static int i, j;
static { j = 4; }
}

result in compile-time errors. Accesses by methods are not checked in this way,so:

class Z {

static int peek() { return j; }
static int i = peek();
static int j = 1;
}

class Test {

public static void main(String[] args) {

System.out.println(Z.i);
}
}

produces the output:

0
because the variable initializer for i uses the class method peek to access thevalue of the variable

j before j has been initialized by its variable initializer, atwhich point it still has its default value ($4.5.5).

A more elaborate example is:
class UseBeforeDeclaration {

static {

x = 100; // ok - assignment
int y = x + 1; // error - read before declaration
int v = x = 3; // ok - x at left hand side of assignment
int z = UseBeforeDeclaration.x * 2;
// ok - not accessed via simple name

Object o = new Object(){

void foo(){x++;} // ok - occurs in a different class
{x++;} // ok - occurs in a different class
};
  }

{

j = 200; // ok - assignment
j = j + 1; // error - right hand side reads before declaration
int k = j = j + 1;
int n = j = 300; // ok - j at left hand side of assignment
int h = j++; // error - read before declaration
int l = this.j * 3; // ok - not accessed via simple name
Object o = new Object(){

8.3.3 Examples of Field Declarations CLASSES
162 DRAFT

void foo(){j++;} // ok - occurs in a different class
{ j = j + 1;} // ok - occurs in a different class
};
}

int w = x= 3; // ok - x at left hand side of assignment
int p = x; // ok - instance initializers may access static fields
static int u = (new Object(){int bar(){return x;}}).bar();
// ok - occurs in a different class
static int x;
int m = j = 4; // ok - j at left hand side of assignment
int o = (new Object(){int bar(){return j;}}).bar();
// ok - occurs in a different class
int j;
}

8.3.3 Examples of Field Declarations
The following examples illustrate some (possibly subtle) points about field decla-rations.

8.3.3.1 Example: Hiding of Class Variables
The example:

class Point {

static int x = 2;
}

class Test extends Point {

static double x = 4.7;
public static void main(String[] args) {

new Test().printX();
}
void printX() {

System.out.println(x + " " + super.x);
}
}

produces the output:

4.7 2
because the declaration of x in class Test hides the definition of x in class Point,so class

Test does not inherit the field x from its superclass Point. Within thedeclaration of class

Test, the simple name x refers to the field declared withinclass
Test. Code in class Test may refer to the field x of class Point as super.x(or, because

x is static, as Point.x). If the declaration of Test.x is deleted:

CLASSES Examples of Field Declarations 8.3.3

163DRAFT
class Point {

static int x = 2;
}

class Test extends Point {

public static void main(String[] args) {

new Test().printX();
}
void printX() {

System.out.println(x + " " + super.x);
}
}

then the field x of class Point is no longer hidden within class Test; instead, thesimple name

x now refers to the field Point.x. Code in class Test may still referto that same field as

super.x. Therefore, the output from this variant program is:

2 2

8.3.3.2 Example: Hiding of Instance Variables
This example is similar to that in the previous section, but uses instance variablesrather than static variables. The code:

class Point {

int x = 2;
}

class Test extends Point {

double x = 4.7;
void printBoth() {

System.out.println(x + " " + super.x);
}
public static void main(String[] args) {

Test sample = new Test();
sample.printBoth();
System.out.println(sample.x + " " +

((Point)sample).x);
}
}

produces the output:

4.7 2
4.7 2

because the declaration of x in class Test hides the definition of x in class Point,so class

Test does not inherit the field x from its superclass Point. It must benoted, however, that while the field

x of class Point is not inherited by class
Test, it is nevertheless implemented by instances of class Test. In other words,

8.3.3 Examples of Field Declarations CLASSES
164 DRAFT

every instance of class Test contains two fields, one of type int and one of type
float. Both fields bear the name x, but within the declaration of class Test, thesimple name

x always refers to the field declared within class Test. Code ininstance methods of class

Test may refer to the instance variable x of class Pointas
super.x.Code that uses a field access expression to access field

x will access the fieldnamed
x in the class indicated by the type of reference expression. Thus, theexpression

sample.x accesses a float value, the instance variable declared inclass
Test, because the type of the variable sample is Test, but the expression
((Point)sample).x accesses an int value, the instance variable declared inclass

Point, because of the cast to type Point.If the declaration of

x is deleted from class Test, as in the program:

class Point {

static int x = 2;
}

class Test extends Point {

void printBoth() {

System.out.println(x + " " + super.x);
}
public static void main(String[] args) {

Test sample = new Test();
sample.printBoth();
System.out.println(sample.x + " " +

((Point)sample).x);
}
}

then the field x of class Point is no longer hidden within class Test. Withininstance methods in the declaration of class

Test, the simple name x now refers tothe field declared within class
Point. Code in class Test may still refer to thatsame field as
super.x. The expression sample.x still refers to the field x withintype
Test, but that field is now an inherited field, and so refers to the field xdeclared in class

Point. The output from this variant program is:

2 2
2 2

8.3.3.3 Example: Multiply Inherited Fields
A class may inherit two or more fields with the same name, either from two inter-faces or from its superclass and an interface. A compile-time error occurs on any

attempt to refer to any ambiguously inherited field by its simple name. A qualifiedname or a field access expression that contains the keyword

super ($15.11.2) maybe used to access such fields unambiguously. In the example:

CLASSES Examples of Field Declarations 8.3.3

165DRAFT
interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {

public static void main(String[] args) {

new Test().printV();
}
void printV() { System.out.println(v); }
}

the class Test inherits two fields named v, one from its superclass SuperTest andone from its superinterface

Frob. This in itself is permitted, but a compile-timeerror occurs because of the use of the simple name

v in method printV: it cannotbe determined which
v is intended.The following variation uses the field access expression

super.v to refer tothe field named
v declared in class SuperTest and uses the qualified name
Frob.v to refer to the field named v declared in interface Frob:

interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {

public static void main(String[] args) {

new Test().printV();
}
void printV() {

System.out.println((super.v + Frob.v)/2);
}
}

It compiles and prints:

2.5
Even if two distinct inherited fields have the same type, the same value, andare both

final, any reference to either field by simple name is considered ambig-uous and results in a compile-time error. In the example:

interface Color { int RED=0, GREEN=1, BLUE=2; }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {

public static void main(String[] args) {

System.out.println(GREEN); // compile-time error
System.out.println(RED); // compile-time error

8.4 Method Declarations CLASSES

166 DRAFT

}
}

it is not astonishing that the reference to GREEN should be considered ambiguous,because class

Test inherits two different declarations for GREEN with differentvalues. The point of this example is that the reference to

RED is also consideredambiguous, because two distinct declarations are inherited. The fact that the two

fields named RED happen to have the same type and the same unchanging valuedoes not affect this judgment.

8.3.3.4 Example: Re-inheritance of Fields
If the same field declaration is inherited from an interface by multiple paths, thefield is considered to be inherited only once. It may be referred to by its simple

name without ambiguity. For example, in the code:

public interface Colorable {

int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}

public interface Paintable extends Colorable {

int MATTE = 0, GLOSSY = 1;
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {. . .

}
class PaintedPoint extends ColoredPoint implements Paintable
{ . . .

RED  . . .
}

the fields RED, GREEN, and BLUE are inherited by the class PaintedPoint boththrough its direct superclass

ColoredPoint and through its direct superinterface
Paintable. The simple names RED, GREEN, and BLUE may nevertheless be usedwithout ambiguity within the class

PaintedPoint to refer to the fields declared ininterface
Colorable.

8.4 Method Declarations
A method declares executable code that can be invoked, passing a fixed number ofvalues as arguments.

CLASSES Formal Parameters 8.4.1

167DRAFT
MethodDeclaration:MethodHeader MethodBody
MethodHeader:MethodModifiers

opt ResultType MethodDeclarator Throwsopt

ResultType:Type

void
MethodDeclarator:Identifer

 ( FormalParameterListopt )

The MethodModifiers are described in $8.4.3, the Throws clause in $8.4.4, and theMethodBody in $8.4.5. A method declaration either specifies the type of value that

the method returns or uses the keyword void to indicate that the method does notreturn a value.

The Identifier in a MethodDeclarator may be used in a name to refer to themethod. A class can declare a method with the same name as the class or a field,
member class or member interface of the class.For compatibility with older versions of the Java platform, a declaration form
for a method that returns an array is allowed to place (some or all of) the emptybracket pairs that form the declaration of the array type after the parameter list.
This is supported by the obsolescent production:

MethodDeclarator:MethodDeclarator

 [ ]

but should not be used in new code.It is a compile-time error for the body of a class to have as members two

methods with the same signature ($8.4.2) (name, number of parameters, and typesof any parameters). Methods and fields may have the same name, since they are
used in different contexts and are disambiguated by the different lookup proce-dures ($6.5).

8.4.1   Formal Parameters
The formal parameters of a method or constructor, if any, are specified by a list ofcomma-separated parameter specifiers. Each parameter specifier consists of a type

(optionally preceded by the final modifier) and an identifier (optionally followedby brackets) that specifies the name of the parameter:

8.4.1 Formal Parameters CLASSES

168 DRAFT

FormalParameterList:FormalParameter

FormalParameterList , FormalParameter
FormalParameter:

finalopt Type VariableDeclaratorId

The following is repeated from $8.3 to make the presentation here clearer:

VariableDeclaratorId:Identifier

VariableDeclaratorId [ ]
If a method or constructor has no parameters, only an empty pair of parenthe-ses appears in the declaration of the method or constructor.

If two formal parameters of the same method or constructor are declared tohave the same name (that is, their declarations mention the same Identifier), then a
compile-time error occurs.It is a compile-time error if a method or constructor parameter that is declared
final is assigned to within the body of the method or constructor.When the method or constructor is invoked ($15.12), the values of the actual
argument expressions initialize newly created parameter variables, each of thedeclared Type, before execution of the body of the method or constructor. The
Identifier that appears in the DeclaratorId may be used as a simple name in thebody of the method or constructor to refer to the formal parameter.

The scope of a parameter of a method ($8.4.1) or constructor ($8.8.1) is theentire body of the method or constructor.
These parameter names may not be redeclared as local variables of themethod, or as exception parameters of catch clauses in a try statement of the
method or constructor. However, a parameter of a method or constructor may beshadowed anywhere inside a class declaration nested within that method or constructor. Such a nested class declaration could declare either a local class ($14.3)or an anonymous class ($15.9).

Formal parameters are referred to only using simple names, never by usingqualified names ($6.6).
A method or constructor parameter of type float always contains an elementof the float value set ($4.2.3); similarly, a method or constructor parameter of type
double always contains an element of the double value set. It is not permitted fora method or constructor parameter of type

float to contain an element of thefloat-extended-exponent value set that is not also an element of the float value set,

nor for a method parameter of type double to contain an element of the double-extended-exponent value set that is not also an element of the double value set.

CLASSES Method Modifiers 8.4.3

169DRAFT
Where an actual argument expression corresponding to a parameter variable isnot FP-strict ($15.4), evaluation of that actual argument expression is permitted to
use intermediate values drawn from the appropriate extended-exponent value sets.Prior to being stored in the parameter variable the result of such an expression is
mapped to the nearest value in the corresponding standard value set by methodinvocation conversion ($5.3).

8.4.2   Method Signature
The signature of a method consists of the name of the method and the number andtypes of formal parameters to the method. A class may not declare two methods

with the same signature, or a compile-time error occurs.The example:

class Point implements Move {

int x, y;
abstract void move(int dx, int dy);
void move(int dx, int dy) { x += dx; y += dy; }
}

causes a compile-time error because it declares two move methods with the samesignature. This is an error even though one of the declarations is

abstract.

8.4.3 Method Modifiers

MethodModifiers:MethodModifier

MethodModifiers MethodModifier
MethodModifier: one of

public protected private abstract static
final synchronized native strictfp

The access modifiers public, protected, and private are discussed in$6.6. A compile-time error occurs if the same modifier appears more than once in

a method declaration, or if a method declaration has more than one of the accessmodifiers

public, protected, and private. A compile-time error occurs if amethod declaration that contains the keyword

abstract also contains any one ofthe keywords
private, static, final, native, strictfp, or synchronized. Acompile-time error occurs if a method declaration that contains the keyword

native also contains strictfp.

8.4.3 Method Modifiers CLASSES

170 DRAFT

If two or more method modifiers appear in a method declaration, it is custom-ary, though not required, that they appear in the order consistent with that shown
above in the production for MethodModifier.
8.4.3.1 abstract Methods
An abstract method declaration introduces the method as a member, providingits signature (name and number and type of parameters), return type, and

throwsclause (if any), but does not provide an implementation. The declaration of an

abstract method m must appear directly within an abstract class (call it A);otherwise a compile-time error results. Every subclass of

A that is not abstractmust provide an implementation for
m, or a compile-time error occurs as specifiedin $8.1.1.1.

It is a compile-time error for a private method to be declared abstract.It would be impossible for a subclass to implement a

private abstractmethod, because
private methods are not inherited by subclasses; therefore sucha method could never be used.

It is a compile-time error for a static method to be declared abstract.It is a compile-time error for a

final method to be declared abstract.An
abstract class can override an abstract method by providing another
abstract method declaration.This can provide a place to put a documentation comment, or to declare that

the set of checked exceptions ($11.2) that can be thrown by that method, when itis implemented by its subclasses, is to be more limited. For example, consider this
code:

class BufferEmpty extends Exception {

BufferEmpty() { super(); }
BufferEmpty(String s) { super(s); }
}

class BufferError extends Exception {

BufferError() { super(); }
BufferError(String s) { super(s); }
}

public interface Buffer {

char get() throws BufferEmpty, BufferError;
}

public abstract class InfiniteBuffer implements Buffer {

abstract char get() throws BufferError;
}

The overriding declaration of method get in class InfiniteBuffer statesthat method

get in any subclass of InfiniteBuffer never throws a BufferCLASSES Method Modifiers 8.4.3

171DRAFT
Empty exception, putatively because it generates the data in the buffer, and thuscan never run out of data.

An instance method that is not abstract can be overridden by an abstractmethod.
For example, we can declare an abstract class Point that requires its sub-classes to implement

toString if they are to be complete, instantiable classes:

abstract class Point {

int x, y;
public abstract String toString();
}

This abstract declaration of toString overrides the non-abstract toStringmethod of class

Object. (Class Object is the implicit direct superclass of class
Point.) Adding the code:

class ColoredPoint extends Point {

int color;
public String toString() {

return super.toString() + ": color " + color; // error
}
}

results in a compile-time error because the invocation super.toString() refersto method

toString in class Point, which is abstract and therefore cannot beinvoked. Method

toString of class Object can be made available to class
ColoredPoint only if class Point explicitly makes it available through someother method, as in:

abstract class Point {

int x, y;
public abstract String toString();
protected String objString() { return super.toString(); }
}

class ColoredPoint extends Point {

int color;
public String toString() {

return objString() + ": color " + color; // correct
}
}

8.4.3.2 static Methods
A method that is declared static is called a class method. A class method isalways invoked without reference to a particular object. An attempt to reference

the current object using the keyword this or the keyword super in the body of a

8.4.3 Method Modifiers CLASSES
172 DRAFT

class method results in a compile-time error. It is a compile-time error for a
static method to be declared abstract.A method that is not declared

static is called an instance method, and some-times called a nonstatic method. An instance method is always invoked withrespect to an object, which becomes the current object to which the keywords

this and super refer during execution of the method body.
8.4.3.3 final Methods
A method can be declared final to prevent subclasses from overriding or hidingit. It is a compile-time error to attempt to override or hide a

final method.A
private method and all methods declared in a final class ($8.1.1.2) areimplicitly

final, because it is impossible to override them. It is permitted but notrequired for the declarations of such methods to redundantly include the

finalkeyword.

It is a compile-time error for a final method to be declared abstract.At run time, a machine-code generator or optimizer can "inline" the body of a
final method, replacing an invocation of the method with the code in its body.The inlining process must preserve the semantics of the method invocation. In
particular, if the target of an instance method invocation is null, then a
NullPointerException must be thrown even if the method is inlined. The com-piler must ensure that the exception will be thrown at the correct point, so that the

actual arguments to the method will be seen to have been evaluated in the correctorder prior to the method invocation.

Consider the example:
final class Point {

int x, y;
void move(int dx, int dy) { x += dx; y += dy; }
}

class Test {

public static void main(String[] args) {

Point[] p = new Point[100];
for (int i = 0; i < p.length; i++) {

p[i] = new Point();
p[i].move(i, p.length-1-i);
}
}
}

Here, inlining the method move of class Point in method main would transformthe

for loop to the form:

CLASSES Method Modifiers 8.4.3

173DRAFT
for (int i = 0; i < p.length; i++) {

p[i] = new Point();
Point pi = p[i];
int j = p.length-1-i;
pi.x += i;
pi.y += j;
}

The loop might then be subject to further optimizations.Such inlining cannot be done at compile time unless it can be guaranteed that

Test and Point will always be recompiled together, so that whenever Point--and specifically its

move method--changes, the code for Test.main will also beupdated.

8.4.3.4 native Methods
A method that is native is implemented in platform-dependent code, typicallywritten in another programming language such as C, C++,

FORTRAN, or assemblylanguage. The body of a
native method is given as a semicolon only, indicatingthat the implementation is omitted, instead of a block.

A compile-time error occurs if a native method is declared abstract.For example, the class

RandomAccessFile of the package java.io mightdeclare the following
native methods:

package java.io;
public class RandomAccessFile

implements DataOutput, DataInput
{ . . .

public native void open(String name, boolean writeable)

throws IOException;
public native int readBytes(byte[] b, int off, int len)

throws IOException;
public native void writeBytes(byte[] b, int off, int len)

throws IOException;
public native long getFilePointer() throws IOException;
public native void seek(long pos) throws IOException;
public native long length() throws IOException;
public native void close() throws IOException;}

8.4.3.5 strictfp Methods
The effect of the strictfp modifier is to make all float or double expressionswithin the method body be explicitly FP-strict ($15.4).

8.4.3 Method Modifiers CLASSES

174 DRAFT

8.4.3.6 synchronized Methods
A synchronized method acquires a lock ($17.1) before it executes. For a class(

static) method, the lock associated with the Class object for the method'sclass is used. For an instance method, the lock associated with

this (the objectfor which the method was invoked) is used.

These are the same locks that can be used by the synchronized statement($14.18); thus, the code:

class Test {

int count;
synchronized void bump() { count++; }
static int classCount;
static synchronized void classBump() {

classCount++;
}
}

has exactly the same effect as:

class BumpTest {

int count;
void bump() {

synchronized (this) {

count++;
}
}
static int classCount;
static void classBump() {

try {

synchronized (Class.forName("BumpTest")) {

classCount++;
}
} catch (ClassNotFoundException e) {

...
}
}
}

The more elaborate example:

public class Box {

private Object boxContents;
public synchronized Object get() {

Object contents = boxContents;
boxContents = null;
return contents;
}

CLASSES Method Throws 8.4.4

175DRAFT
public synchronized boolean put(Object contents) {

if (boxContents != null)

return false;
boxContents = contents;
return true;
}

}
defines a class which is designed for concurrent use. Each instance of the class
Box has an instance variable contents that can hold a reference to any object.You can put an object in a

Box by invoking put, which returns false if the box isalready full. You can get something out of a

Box by invoking get, which returns anull reference if the
box is empty.If
put and get were not synchronized, and two threads were executingmethods for the same instance of

Box at the same time, then the code could misbe-have. It might, for example, lose track of an object because two invocations to

putoccurred at the same time.

See $17 for more discussion of threads and locks.

8.4.4 Method Throws
A throws clause is used to declare any checked exceptions ($11.2) that can resultfrom the execution of a method or constructor:

Throws:

throws ClassTypeList

ClassTypeList:ClassType

ClassTypeList , ClassType
A compile-time error occurs if any ClassType mentioned in a throws clause is notthe class

Throwable or a subclass of Throwable. It is permitted but not requiredto mention other (unchecked) exceptions in a

throws clause.For each checked exception that can result from execution of the body of a

method or constructor, a compile-time error occurs unless that exception type or asuperclass of that exception type is mentioned in a

throws clause in the declara-tion of the method or constructor.

The requirement to declare checked exceptions allows the compiler to ensurethat code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptionswill normally result in a compile-time error because of the lack of a proper exception type in a throws clause. The Java programming language thus encourages a

8.4.5 Method Body CLASSES
176 DRAFT

programming style where rare and otherwise truly exceptional conditions are doc-umented in this way.

The predefined exceptions that are not checked in this way are those for whichdeclaring every possible occurrence would be unimaginably inconvenient:

* Exceptions that are represented by the subclasses of class Error, for example

OutOfMemoryError, are thrown due to a failure in or of the virtual machine.Many of these are the result of linkage failures and can occur at unpredictable

points in the execution of a program. Sophisticated programs may yet wish tocatch and attempt to recover from some of these conditions.

* The exceptions that are represented by the subclasses of the class

RuntimeException, for example NullPointerException, result from run-time integrity checks and are thrown either directly from the program or in

library routines. It is beyond the scope of the Java programming language, andperhaps beyond the state of the art, to include sufficient information in the
program to reduce to a manageable number the places where these can beproven not to occur.

A method that overrides or hides another method ($8.4.6), including methodsthat implement

abstract methods defined in interfaces, may not be declared tothrow more checked exceptions than the overridden or hidden method.

More precisely, suppose that B is a class or interface, and A is a superclass orsuperinterface of

B, and a method declaration n in B overrides or hides a methoddeclaration
m in A. If n has a throws clause that mentions any checked exceptiontypes, then

m must have a throws clause, and for every checked exception typelisted in the

throws clause of n, that same exception class or one of its super-classes must occur in the

throws clause of m; otherwise, a compile-time erroroccurs.

See $11 for more information about exceptions and a large example.

8.4.5   Method Body
A method body is either a block of code that implements the method or simply asemicolon, indicating the lack of an implementation. The body of a method must

be a semicolon if and only if the method is either abstract ($8.4.3.1) or native($8.4.3.4).

MethodBody:Block

;

CLASSES Inheritance, Overriding, and Hiding 8.4.6

177DRAFT
A compile-time error occurs if a method declaration is either abstract or
native and has a block for its body. A compile-time error occurs if a method dec-laration is neither

abstract nor native and has a semicolon for its body.If an implementation is to be provided for a method but the implementation

requires no executable code, the method body should be written as a block thatcontains no statements: "

{ }".If a method is declared

void, then its body must not contain any returnstatement ($14.16) that has an Expression.

If a method is declared to have a return type, then every return statement($14.16) in its body must have an Expression. A compile-time error occurs if the
body of the method can complete normally ($14.1).In other words, a method with a return type must return only by using a return
statement that provides a value return; it is not allowed to "drop off the end of itsbody."

Note that it is possible for a method to have a declared return type and yetcontain no return statements. Here is one example:
class DizzyDean {

int pitch() { throw new RuntimeException("90 mph?!"); }
}

8.4.6   Inheritance, Overriding, and Hiding
A class inherits from its direct superclass and direct superinterfaces all the non-private methods (whether

abstract or not) of the superclass and superinterfacesthat are accessible to code in the class and are neither overridden ($8.4.6.1) nor

hidden ($8.4.6.2) by a declaration in the class.
8.4.6.1 Overriding (by Instance Methods)
An instance method m1 declared in a class C overrides another method with thesame signature,

m2, declared in class A iff both:

1. C is a subclass of A.
2. Either

u m2 is non-private and accessible from C, or
u m1 overrides a method m3, m3 distinct from m1, m3 distinct from m2, suchthat

m3 overrides m2.

Moreover, if m1 is not abstract, then m1 is said to implement any and all dec-larations of

abstract methods that it overrides.

8.4.6 Inheritance, Overriding, and Hiding CLASSES
178 DRAFT

A compile-time error occurs if an instance method overrides a staticmethod.
In this respect, overriding of methods differs from hiding of fields ($8.3), forit is permissible for an instance variable to hide a

static variable.An overridden method can be accessed by using a method invocation expression ($15.12) that contains the keyword super. Note that a qualified name or acast to a superclass type is not effective in attempting to access an overridden
method; in this respect, overriding of methods differs from hiding of fields. See$15.12.4.9 for discussion and examples of this point.

The presence or absence of the strictfp modifier has absolutely no effect onthe rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strictmethod and it is permitted for an FP-strict method to override a method that is not
FP-strict.

8.4.6.2 Hiding (by Class Methods)
If a class declares a static method, then the declaration of that method is said tohide any and all methods with the same signature in the superclasses and superinterfaces of the class that would otherwise be accessible to code in the class. Acompile-time error occurs if a

static method hides an instance method.In this respect, hiding of methods differs from hiding of fields ($8.3), for it is

permissible for a static variable to hide an instance variable. Hiding is also dis-tinct from shadowing ($6.3.1) and obscuring ($6.3.2).

A hidden method can be accessed by using a qualified name or by using amethod invocation expression ($15.12) that contains the keyword

super or a castto a superclass type. In this respect, hiding of methods is similar to hiding of

fields.

8.4.6.3 Requirements in Overriding and Hiding
If a method declaration overrides or hides the declaration of another method, thena compile-time error occurs if they have different return types or if one has a

return type and the other is void. Moreover, a method declaration must not have a
throws clause that conflicts ($8.4.4) with that of any method that it overrides orhides; otherwise, a compile-time error occurs.

In these respects, overriding of methods differs from hiding of fields ($8.3),for it is permissible for a field to hide a field of another type.
The access modifier ($6.6) of an overriding or hiding method must provide atleast as much access as the overridden or hidden method, or a compile-time error
occurs. In more detail:

CLASSES Inheritance, Overriding, and Hiding 8.4.6

179DRAFT

* If the overridden or hidden method is public, then the overriding or hidingmethod must be

public; otherwise, a compile-time error occurs.

* If the overridden or hidden method is protected, then the overriding or hid-ing method must be

protected or public; otherwise, a compile-time erroroccurs.

* If the overridden or hidden method has default (package) access, then theoverriding or hiding method must not be

private; otherwise, a compile-timeerror occurs.

Note that a private method cannot be hidden or overridden in the technicalsense of those terms. This means that a subclass can declare a method with the
same signature as a private method in one of its superclasses, and there is norequirement that the return type or

throws clause of such a method bear any rela-tionship to those of the
private method in the superclass.

8.4.6.4 Inheriting Methods with the Same Signature
It is possible for a class to inherit more than one method with the same signature.Such a situation does not in itself cause a compile-time error. There are then two

possible cases:

* If one of the inherited methods is not abstract, then there are two subcases:

u If the method that is not abstract is static, a compile-time error occurs.
u Otherwise, the method that is not abstract is considered to override, andtherefore to implement, all the other methods on behalf of the class that

inherits it. A compile-time error occurs if, comparing the method that is not
abstract with each of the other of the inherited methods, for any such pair,either they have different return types or one has a return type and the other

is void. Moreover, a compile-time error occurs if the inherited method thatis not

abstract has a throws clause that conflicts ($8.4.4) with that of anyother of the inherited methods.

* If all the inherited methods are abstract, then the class is necessarily an

abstract class and is considered to inherit all the abstract methods. Acompile-time error occurs if, for any two such inherited methods, either they

have different return types or one has a return type and the other is void.(The

throws clauses do not cause errors in this case.)

It is not possible for two or more inherited methods with the same signature not tobe

abstract, because methods that are not abstract are inherited only from thedirect superclass, not from superinterfaces.

8.4.7 Overloading CLASSES
180 DRAFT

There might be several paths by which the same method declaration might beinherited from an interface. This fact causes no difficulty and never, of itself,
results in a compile-time error.

8.4.7   Overloading
If two methods of a class (whether both declared in the same class, or both inher-ited by a class, or one declared and one inherited) have the same name but different signatures, then the method name is said to be overloaded. This fact causes nodifficulty and never of itself results in a compile-time error. There is no required
relationship between the return types or between the throws clauses of two meth-ods with the same name but different signatures.

Methods are overridden on a signature-by-signature basis.If, for example, a class declares two

public methods with the same name,and a subclass overrides one of them, the subclass still inherits the other method.

In this respect, the Java programming language differs from C++.When a method is invoked ($15.12), the number of actual arguments and the
compile-time types of the arguments are used, at compile time, to determine thesignature of the method that will be invoked ($15.12.2). If the method that is to be
invoked is an instance method, the actual method to be invoked will be determinedat run time, using dynamic method lookup ($15.12.4).

8.4.8   Examples of Method Declarations
The following examples illustrate some (possibly subtle) points about methoddeclarations.

8.4.8.1 Example: Overriding
In the example:

class Point {

int x = 0, y = 0;
void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {

int xLimit, yLimit;
void move(int dx, int dy) {

super.move(limit(dx, xLimit), limit(dy, yLimit));
}

CLASSES Examples of Method Declarations 8.4.8

181DRAFT
static int limit(int d, int limit) {

return d > limit ? limit : d < -limit ? -limit : d;
}

}
the class SlowPoint overrides the declarations of method move of class Pointwith its own

move method, which limits the distance that the point can move oneach invocation of the method. When the

move method is invoked for an instanceof class
SlowPoint, the overriding definition in class SlowPoint will always becalled, even if the reference to the

SlowPoint object is taken from a variablewhose type is
Point.

8.4.8.2 Example: Overloading, Overriding, and Hiding
In the example:

class Point {

int x = 0, y = 0;
void move(int dx, int dy) { x += dx; y += dy; }
int color;
}
class RealPoint extends Point {

float x = 0.0f, y = 0.0f;
void move(int dx, int dy) { move((float)dx, (float)dy); }
void move(float dx, float dy) { x += dx; y += dy; }
}

the class RealPoint hides the declarations of the int instance variables x and yof class

Point with its own float instance variables x and y, and overrides themethod
move of class Point with its own move method. It also overloads the name
move with another method with a different signature ($8.4.2).In this example, the members of the class

RealPoint include the instancevariable
color inherited from the class Point, the float instance variables x and
y declared in RealPoint, and the two move methods declared in RealPoint.Which of these overloaded

move methods of class RealPoint will be chosenfor any particular method invocation will be determined at compile time by the

overloading resolution procedure described in $15.12.
8.4.8.3 Example: Incorrect Overriding
This example is an extended variation of that in the preceding section:

8.4.8 Examples of Method Declarations CLASSES
182 DRAFT

class Point {

int x = 0, y = 0, color;
void move(int dx, int dy) { x += dx; y += dy; }
int getX() { return x; }
int getY() { return y; }
}
class RealPoint extends Point {

float x = 0.0f, y = 0.0f;
void move(int dx, int dy) { move((float)dx, (float)dy); }
void move(float dx, float dy) { x += dx; y += dy; }
float getX() { return x; }
float getY() { return y; }
}

Here the class Point provides methods getX and getY that return the values of itsfields

x and y; the class RealPoint then overrides these methods by declaringmethods with the same signature. The result is two errors at compile time, one for

each method, because the return types do not match; the methods in class Pointreturn values of type

int, but the wanna-be overriding methods in class
RealPoint return values of type float.

8.4.8.4 Example: Overriding versus Hiding
This example corrects the errors of the example in the preceding section:

class Point {

int x = 0, y = 0;
void move(int dx, int dy) { x += dx; y += dy; }
int getX() { return x; }
int getY() { return y; }
int color;
}
class RealPoint extends Point {

float x = 0.0f, y = 0.0f;
void move(int dx, int dy) { move((float)dx, (float)dy); }
void move(float dx, float dy) { x += dx; y += dy; }

CLASSES Examples of Method Declarations 8.4.8

183DRAFT
int getX() { return (int)Math.floor(x); }
int getY() { return (int)Math.floor(y); }
}

Here the overriding methods getX and getY in class RealPoint have the samereturn types as the methods of class

Point that they override, so this code can besuccessfully compiled.

Consider, then, this test program:
class Test {

public static void main(String[] args) {

RealPoint rp = new RealPoint();
Point p = rp;
rp.move(1.71828f, 4.14159f);
p.move(1, -1);
show(p.x, p.y);
show(rp.x, rp.y);
show(p.getX(), p.getY());
show(rp.getX(), rp.getY());
}

static void show(int x, int y) {

System.out.println("(" + x + ", " + y + ")");
}

static void show(float x, float y) {

System.out.println("(" + x + ", " + y + ")");
}

}
The output from this program is:

(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)

The first line of output illustrates the fact that an instance of RealPoint actu-ally contains the two integer fields declared in class

Point; it is just that theirnames are hidden from code that occurs within the declaration of class

RealPoint (and those of any subclasses it might have). When a reference to aninstance of class

RealPoint in a variable of type Point is used to access the field
x, the integer field x declared in class Point is accessed. The fact that its value iszero indicates that the method invocation

p.move(1, -1) did not invoke themethod
move of class Point; instead, it invoked the overriding method move ofclass
RealPoint.

8.4.8 Examples of Method Declarations CLASSES
184 DRAFT

The second line of output shows that the field access rp.x refers to the field xdeclared in class

RealPoint. This field is of type float, and this second line ofoutput accordingly displays floating-point values. Incidentally, this also illustrates

the fact that the method name show is overloaded; the types of the arguments inthe method invocation dictate which of the two definitions will be invoked.

The last two lines of output show that the method invocations p.getX() and
rp.getX() each invoke the getX method declared in class RealPoint. Indeed,there is no way to invoke the

getX method of class Point for an instance of class
RealPoint from outside the body of RealPoint, no matter what the type of thevariable we may use to hold the reference to the object. Thus, we see that fields

and methods behave differently: hiding is different from overriding.
8.4.8.5 Example: Invocation of Hidden Class Methods
A hidden class (static) method can be invoked by using a reference whose typeis the class that actually contains the declaration of the method. In this respect,

hiding of static methods is different from overriding of instance methods. Theexample:

class Super {

static String greeting() { return "Goodnight"; }
String name() { return "Richard"; }
}

class Sub extends Super {

static String greeting() { return "Hello"; }
String name() { return "Dick"; }
}

class Test {

public static void main(String[] args) {

Super s = new Sub();
System.out.println(s.greeting() + ", " + s.name());
}
}

produces the output:

Goodnight, Dick
because the invocation of greeting uses the type of s, namely Super, to figureout, at compile time, which class method to invoke, whereas the invocation of

name uses the class of s, namely Sub, to figure out, at run time, which instancemethod to invoke.

CLASSES Examples of Method Declarations 8.4.8

185DRAFT
8.4.8.6 Large Example of Overriding
Overriding makes it easy for subclasses to extend the behavior of an existingclass, as shown in this example:

import java.io.OutputStream;
import java.io.IOException;
class BufferOutput {

private OutputStream o;
BufferOutput(OutputStream o) { this.o = o; }
protected byte[] buf = new byte[512];
protected int pos = 0;
public void putchar(char c) throws IOException {

if (pos == buf.length)

flush();
buf[pos++] = (byte)c;
}

public void putstr(String s) throws IOException {

for (int i = 0; i < s.length(); i++)

putchar(s.charAt(i));
}

public void flush() throws IOException {

o.write(buf, 0, pos);
pos = 0;
}

}
class LineBufferOutput extends BufferOutput {

LineBufferOutput(OutputStream o) { super(o); }
public void putchar(char c) throws IOException {

super.putchar(c);
if (c == '\n')

flush();
}

}
class Test {

public static void main(String[] args)

throws IOException
{

LineBufferOutput lbo =

new LineBufferOutput(System.out);
lbo.putstr("lbo\nlbo");

8.4.8 Examples of Method Declarations CLASSES
186 DRAFT

System.out.print("print\n");
lbo.putstr("\n");
}
}

This example produces the output:

lbo
print
lbo

The class BufferOutput implements a very simple buffered version of an
OutputStream, flushing the output when the buffer is full or flush is invoked.The subclass

LineBufferOutput declares only a constructor and a single method
putchar, which overrides the method putchar of BufferOutput. It inherits themethods

putstr and flush from class BufferOutput.In the

putchar method of a LineBufferOutput object, if the character argu-ment is a newline, then it invokes the

flush method. The critical point about over-riding in this example is that the method

putstr, which is declared in class
BufferOutput, invokes the putchar method defined by the current object this,which is not necessarily the

putchar method declared in class BufferOutput.Thus, when
putstr is invoked in main using the LineBufferOutput object
lbo, the invocation of putchar in the body of the putstr method is an invocationof the

putchar of the object lbo, the overriding declaration of putchar thatchecks for a newline. This allows a subclass of

BufferOutput to change thebehavior of the
putstr method without redefining it.Documentation for a class such as

BufferOutput, which is designed to beextended, should clearly indicate what is the contract between the class and its

subclasses, and should clearly indicate that subclasses may override the putcharmethod in this way. The implementor of the

BufferOutput class would not,therefore, want to change the implementation of

putstr in a future implementa-tion of
BufferOutput not to use the method putchar, because this would breakthe preexisting contract with subclasses. See the further discussion of binary compatibility in $13, especially $13.2.
8.4.8.7 Example: Incorrect Overriding because of Throws
This example uses the usual and conventional form for declaring a new exceptiontype, in its declaration of the class

BadPointException:

class BadPointException extends Exception {

BadPointException() { super(); }
BadPointException(String s) { super(s); }
}

CLASSES Member Type Declarations 8.5

187DRAFT
class Point {

int x, y;
void move(int dx, int dy) { x += dx; y += dy; }
}

class CheckedPoint extends Point {

void move(int dx, int dy) throws BadPointException {

if ((x + dx) < 0 || (y + dy) < 0)

throw new BadPointException();
x += dx; y += dy;
}
}

This example results in a compile-time error, because the override of method
move in class CheckedPoint declares that it will throw a checked exception thatthe

move in class Point has not declared. If this were not considered an error, aninvoker of the method

move on a reference of type Point could find the contractbetween it and
Point broken if this exception were thrown.Removing the

throws clause does not help:

class CheckedPoint extends Point {

void move(int dx, int dy) {

if ((x + dx) < 0 || (y + dy) < 0)

throw new BadPointException();
x += dx; y += dy;
}
}

A different compile-time error now occurs, because the body of the method
move cannot throw a checked exception, namely BadPointException, that doesnot appear in the

throws clause for move.

8.5 Member Type Declarations
A member class is a class whose declaration is directly enclosed in another classor interface declaration. Similarly, a member interface is an interface whose declaration is directly enclosed in another class or interface declaration. The scope($6.3) of a member class or interface is specified in $8.1.5.

If the class declares a member type with a certain name, then the declarationof that type is said to hide any and all accessible declarations of member types
with the same name in superclasses and superinterfaces of the class.Within a class

C, a declaration d of a member type named n shadows the dec-larations of any other types named

n that are in scope at the point where d occurs.

8.5.1 Access Modifiers CLASSES
188 DRAFT

If a member class or interface declared with simple name C is directlyenclosed within the declaration of a class with fully qualified name

N, then themember class or interface has the fully qualified name
N.C.A class may inherit two or more type declarations with the same name, either

from two interfaces or from its superclass and an interface. A compile-time erroroccurs on any attempt to refer to any ambiguously inherited class or interface by
its simple name.If the same type declaration is inherited from an interface by multiple paths,
the class or interface is considered to be inherited only once. It may be referred toby its simple name without ambiguity.

8.5.1   Access Modifiers
The access modifiers public, protected, and private are discussed in $6.6.A compile-time error occurs if a member type declaration has more than one of

the access modifiers public, protected, and private.

8.5.2   Static Member Type Declarations
The static keyword may modify the declaration of a member type C within thebody of a non-inner class

T. Its effect is to declare that C is not an inner class. Justas a static method of
T has no current instance of T in its body, C also has no cur-rent instance of
T, nor does it have any lexically enclosing instances.It is a compile-time error if a

static class contains a usage of a non-staticmember of an enclosing class.

Member interfaces are always implicitly static. It is permitted but notrequired for the declaration of a member interface to explicitly list the

staticmodifier.

8.6   Instance Initializers
An instance initializer declared in a class is executed when an instance of the classis created ($15.9), as specified in $8.8.5.1.

InstanceInitializer:Block
An instance initializer of a named class may not throw a checked exceptionunless that exception or one of its superclasses is explicitly declared in the

throwsclause of each constructor of its class and the class has at least one explicitly

CLASSES Static Initializers 8.7

189DRAFT
declared constructor. An instance initializer in an anonymous class ($15.9.5) canthrow any exceptions.

The rules above distinguish between instance initializers in named and anony-mous classes. This distinction is deliberate. A given anonymous class is only
instantiated at a single point in a program. It is therefore possible to directly prop-agate information about what exceptions might be raised by an anonymous class'
instance initializer to the surrounding expression. Named classes, on the otherhand, can be instantiated in many places. Therefore the only way to propagate
information about what exceptions might be raised by an instance initializer of anamed class is through the

throws clauses of its constructors. It follows that amore liberal rule can be used in the case of anonymous classes. Similar comments

apply to instance variable initializers.It is a compile-time error if an instance initializer cannot complete normally
($14.20). If a return statement ($14.16) appears anywhere within an instance ini-tializer, then a compile-time error occurs.

Use of instance variables whose declarations appear textually after the use issometimes restricted, even though these instance variables are in scope. See

$8.3.2.3 for the precise rules governing forward reference to instance variables.Instance initializers are permitted to refer to the current object

this ($15.8.3)and to use the keyword
super ($15.11.2, $15.12).

8.7   Static Initializers
Any static initializers declared in a class are executed when the class is initializedand, together with any field initializers ($8.3.2) for class variables, may be used to
initialize the class variables of the class ($12.4).

StaticInitializer:

static Block

It is a compile-time error for a static initializer to be able to complete abruptly($14.1, $15.6) with a checked exception ($11.2). It is a compile-time error if a

static initializer cannot complete normally ($14.20).The static initializers and class variable initializers are executed in textual
order.Use of class variables whose declarations appear textually after the use is
sometimes restricted, even though these class variables are in scope. See $8.3.2.3for the precise rules governing forward reference to class variables.

If a return statement ($14.16) appears anywhere within a static initializer,then a compile-time error occurs.

8.8 Constructor Declarations CLASSES

190 DRAFT

If the keyword this ($15.8.3) or the keyword super ($15.11, $15.12) appearsanywhere within a static initializer, then a compile-time error occurs.
8.8   Constructor Declarations
A constructor is used in the creation of an object that is an instance of a class:

ConstructorDeclaration:ConstructorModifiers

opt ConstructorDeclaratorThrows

opt ConstructorBody

ConstructorDeclarator:SimpleTypeName

 ( FormalParameterListopt )

The SimpleTypeName in the ConstructorDeclarator must be the simple name ofthe class that contains the constructor declaration; otherwise a compile-time error

occurs. In all other respects, the constructor declaration looks just like a methoddeclaration that has no result type.

Here is a simple example:
class Point {

int x, y;
Point(int x, int y) { this.x = x; this.y = y; }
}

Constructors are invoked by class instance creation expressions ($15.9), bythe conversions and concatenations caused by the string concatenation operator +

($15.18.1), and by explicit constructor invocations from other constructors($8.8.5). Constructors are never invoked by method invocation expressions
($15.12).Access to constructors is governed by access modifiers ($6.6).

This is useful, for example, in preventing instantiation by declaring an inac-cessible constructor ($8.8.8).
Constructor declarations are not members. They are never inherited and there-fore are not subject to hiding or overriding.

8.8.1   Formal Parameters
The formal parameters of a constructor are identical in structure and behavior tothe formal parameters of a method ($8.4.1).

CLASSES Constructor Throws 8.8.4

191DRAFT
8.8.2   Constructor Signature
The signature of a constructor consists of the number and types of formal parame-ters to the constructor. A class may not declare two constructors with the same

signature, or a compile-time error occurs.

8.8.3   Constructor Modifiers

ConstructorModifiers:ConstructorModifier

ConstructorModifiers ConstructorModifier
ConstructorModifier: one of

public protected private

The access modifiers public, protected, and private are discussed in$6.6. A compile-time error occurs if the same modifier appears more than once in

a constructor declaration, or if a constructor declaration has more than one of theaccess modifiers

public, protected, and private.Unlike methods, a constructor cannot be

abstract, static, final, native,
strictfp, or synchronized. A constructor is not inherited, so there is no need todeclare it

final and an abstract constructor could never be implemented. Aconstructor is always invoked with respect to an object, so it makes no sense for a

constructor to be static. There is no practical need for a constructor to be synchronized, because it would lock the object under construction, which is nor-mally not made available to other threads until all constructors for the object have

completed their work. The lack of native constructors is an arbitrary languagedesign choice that makes it easy for an implementation of the Java virtual machine
to verify that superclass constructors are always properly invoked during objectcreation.

Note that a ConstructorModifier cannot be declared strictfp. This differ-ence in the definitions for ConstructorModifier and MethodModifier ($8.4.3) is an
intentional language design choice; it effectively ensures that a constructor is FP-strict ($15.4) if and only if its class is FP-strict.

8.8.4 Constructor Throws
The throws clause for a constructor is identical in structure and behavior to the
throws clause for a method ($8.4.4).

8.8.5 Constructor Body CLASSES

192 DRAFT

8.8.5   Constructor Body
The first statement of a constructor body may be an explicit invocation of anotherconstructor of the same class or of the direct superclass ($8.8.5.1).

ConstructorBody:

{ ExplicitConstructorInvocationopt BlockStatementsopt }

It is a compile-time error for a constructor to directly or indirectly invokeitself through a series of one or more explicit constructor invocations involving

this.If a constructor body does not begin with an explicit constructor invocation
and the constructor being declared is not part of the primordial class Object, thenthe constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "super();", an invocation of the constructor of itsdirect superclass that takes no arguments.

Except for the possibility of explicit constructor invocations, the body of aconstructor is like the body of a method ($8.4.5). A

return statement ($14.16)may be used in the body of a constructor if it does not include an expression.

In the example:
class Point {

int x, y;
Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {

static final int WHITE = 0, BLACK = 1;
int color;
ColoredPoint(int x, int y) {

this(x, y, WHITE);
}

ColoredPoint(int x, int y, int color) {

super(x, y);this.color = color;

}
}
the first constructor of ColoredPoint invokes the second, providing an additionalargument; the second constructor of

ColoredPoint invokes the constructor of itssuperclass
Point, passing along the coordinates.$12.5 and $15.9 describe the creation and initialization of new class instances.

CLASSES Constructor Body 8.8.5

193DRAFT
8.8.5.1 Explicit Constructor Invocations

ExplicitConstructorInvocation:

this ( ArgumentListopt ) ;
super ( ArgumentListopt ) ;Primary.super

 ( ArgumentListopt ) ;

Explicit constructor invocation statements can be divided into two kinds:

* Alternate constructor invocations begin with the keyword this. They areused to invoke an alternate constructor of the same class.

* Superclass constructor invocations begin with either the keyword super or aPrimary expression. They are used to invoke a constructor of the direct superclass. Superclass constructor invocations may be further subdivided:
u Unqualified superclass constructor invocations begin with the keyword

super.

u Qualified superclass constructor invocations begin with a Primary expres-sion. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the directsuperclass ($8.1.2). This may be necessary when the superclass is an inner
class.
Here is an example of a qualified superclass constructor invocation:
class Outer {

class Inner{}
}

class ChildOfInner extends Outer.Inner {

ChildOfInner(){(new Outer()).super();}
}

An explicit constructor invocation statement in a constructor body may notrefer to any instance variables or instance methods declared in this class or any

superclass, or use this or super in any expression; otherwise, a compile-timeerror occurs.

For example, if the first constructor of ColoredPoint in the example abovewere changed to:

ColoredPoint(int x, int y) {

this(x, y, color);
}

8.8.5 Constructor Body CLASSES
194 DRAFT

then a compile-time error would occur, because an instance variable cannot beused within a superclass constructor invocation.

If an anonymous class instance creation expression appears within an explicitconstructor invocation statement, then the anonymous class may not refer to any
of the enclosing instances of the class whose constructor is being invoked.For example:

class Top {

int x;

class Dummy {

Dummy(Object o) {}
}

class Inside extends Dummy {

Inside() {

super(new Object() { int r = x; }); // error
}

Inside(final int y) {

super(new Object() { int r = y; }); // correct
}
}
}

Let C be the class being instantiated, let S be the direct superclass of C, and let i bethe instance being created. The evaluation of an explicit constructor invocation

proceeds as follows:

* First, if the constructor invocation statement is a superclass constructor invo-cation, then the immediately enclosing instance of

i with respect to S (if any)must be determined. Whether or not
i has an immediately enclosing instancewith respect to
S is determined by the superclass constructor invocation as fol-lows:

u If S is not an inner class, or if the declaration of S occurs in a static context,no immediately enclosing instance of

i with respect to S exists. A compile-time error occurs if the superclass constructor invocation is a qualified

superclass constructor invocation.
u Otherwise:

v If the superclass constructor invocation is qualified, then the Primaryexpression

p immediately preceding ".super" is evaluated. If the primaryexpression evaluates to

null, a NullPointerException is raised, andthe superclass constructor invocation completes abruptly. Otherwise, the

result of this evaluation is the immediately enclosing instance of i withrespect to

S. Let O be the immediately lexically enclosing class of S; it is acompile-time error if the type of

p is not O or a subclass of O.

CLASSES Default Constructor 8.8.7

195DRAFT
v Otherwise:

C If S is a local class ($14.3), then S must be declared in a methoddeclared in a lexically enclosing class

O. Let n be an integer such that Ois the nth lexically enclosing class of

C. The immediately enclosinginstance of
i with respect to S is the nth lexically enclosing instance of
this.

C Otherwise, S is an inner member class ($8.5). It is a compile-time errorif

S is not a member of a lexically enclosing class. Let O be the inner-most lexically enclosing class of which

S is a member, and let n be aninteger such that
O is the nth lexically enclosing class of C. The imme-diately enclosing instance of

i with respect to S is the nth lexicallyenclosing instance of
this.

* Second, the arguments to the constructor are evaluated, left-to-right, as in anordinary method invocation.

* Next, the constructor is invoked.

* Finally, if the constructor invocation statement is a superclass constructorinvocation and the constructor invocation statement completes normally, then

all instance variable initializers of C and all instance initializers of C are exe-cuted. If an instance initializer or instance variable initializer

I textually pre-cedes another instance initializer or instance variable initializer

J, then I isexecuted before
J. This action is performed regardless of whether the super-class constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically. An alternate constructorinvocation does not perform this additional implicit action.

8.8.6   Constructor Overloading
Overloading of constructors is identical in behavior to overloading of methods.The overloading is resolved at compile time by each class instance creation

expression ($15.9).

8.8.7 Default Constructor
If a class contains no constructor declarations, then a default constructor thattakes no parameters is automatically provided:

8.8.7 Default Constructor CLASSES

196 DRAFT

* If the class being declared is the primordial class Object, then the defaultconstructor has an empty body.

* Otherwise, the default constructor takes no parameters and simply invokes thesuperclass constructor with no arguments.

A compile-time error occurs if a default constructor is provided by the com-piler but the superclass does not have an accessible constructor that takes no arguments.A default constructor has no

throws clause.It follows that if the nullary constructor of the superclass has a

throws clause,then a compile-time error will occur.

If the class is declared public, then the default constructor is implicitly giventhe access modifier

public ($6.6); if the class is declared protected, then thedefault constructor is implicitly given the access modifier

protected ($6.6); ifthe class is declared
private, then the default constructor is implicitly given theaccess modifier
private ($6.6); otherwise, the default constructor has the defaultaccess implied by no access modifier.

Thus, the example:
public class Point {

int x, y;
}

is equivalent to the declaration:

public class Point {

int x, y;
public Point() { super(); }
}

where the default constructor is public because the class Point is public.The rule that the default constructor of a class has the same access modifier as

the class itself is simple and intuitive. Note, however, that this does not imply thatthe constructor is accessible whenever the class is accessible. Consider

package p1;
public class Outer {

protected class Inner{}
}

package p2;
class SonOfOuter extends p1.Outer {

void foo() {

new Inner(); // compile-time access error
}
}

CLASSES Preventing Instantiation of a Class 8.8.8

197DRAFT
The constructor for Inner is protected. However, the constructor is protected rela-tive to

Inner, while Inner is protected relative to Outer. So, Inner is accessiblein
SonOfOuter, since it is a subclass of Outer. Inner's constructor is not accessi-ble in

SonOfOuter, because the class SonOfOuter is not a subclass of Inner!Hence, even though

Inner is accessible, its default constructor is not.

8.8.8 Preventing Instantiation of a Class
A class can be designed to prevent code outside the class declaration from creat-ing instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and declaring all constructors to be private. A
public class can likewise prevent the creation of instances outside its package bydeclaring at least one constructor, to prevent creation of a default constructor with

public access, and declaring no constructor that is public.Thus, in the example:

class ClassOnly {

private ClassOnly() { }
static String just = "only the lonely";
}

the class ClassOnly cannot be instantiated, while in the example:

package just;
public class PackageOnly {

PackageOnly() { }
String[] justDesserts = { "cheesecake", "ice cream" };
}

the class PackageOnly can be instantiated only within the package just, inwhich it is declared.

199DRAFT

C H A P T E R 9

Interfaces

AN interface declaration introduces a new reference type whose members areclasses, interfaces, constants and abstract methods. This type has no implementation, but otherwise unrelated classes can implement it by providing implementa-tions for its abstract methods.

A nested interface is any interface whose declaration occurs within the bodyof another class or interface. A top-level interface is an interface that is not a
nested interface.This chapter discusses the common semantics of all interfaces--top-level
($7.6) and nested ($8.5, $9.5). Details that are specific to particular kinds of inter-faces are discussed in the sections dedicated to these constructs.

Programs can use interfaces to make it unnecessary for related classes to sharea common abstract superclass or to add methods to

Object.An interface may be declared to be a direct extension of one or more other

interfaces, meaning that it implicitly specifies all the member types, abstractmethods and constants of the interfaces it extends, except for any member types
and constants that it may hide.A class may be declared to directly implement one or more interfaces, meaning that any instance of the class implements all the abstract methods specified bythe interface or interfaces. A class necessarily implements all the interfaces that its
direct superclasses and direct superinterfaces do. This (multiple) interface inherit-ance allows objects to support (multiple) common behaviors without sharing any
implementation.A variable whose declared type is an interface type may have as its value a
reference to any instance of a class which implements the specified interface. It isnot sufficient that the class happen to implement all the abstract methods of the
interface; the class or one of its superclasses must actually be declared to imple-ment the interface, or else the class is not considered to implement the interface.

9.1 Interface Declarations INTERFACES

200 DRAFT

9.1   Interface Declarations
An interface declaration specifies a new named reference type:

InterfaceDeclaration:InterfaceModifiers

opt interface IdentifierExtendsInterfaces

opt InterfaceBody

The Identifier in an interface declaration specifies the name of the interface. Acompile-time error occurs if an interface has the same simple name as any of its

enclosing classes or interfaces.

9.1.1   Interface Modifiers
An interface declaration may include interface modifiers:

InterfaceModifiers:InterfaceModifier

InterfaceModifiers InterfaceModifier
InterfaceModifier: one of

public protected private
abstract static strictfp

The access modifier public is discussed in $6.6. Not all modifiers are appli-cable to all kinds of interface declarations. The access modifiers

protected and
private pertain only to member interfaces within a directly enclosing class dec-laration ($8.5) and are discussed in $8.5.1. The access modifier

static pertainsonly to member interfaces ($8.5, $9.5). A compile-time error occurs if the same

modifier appears more than once in an interface declaration.
9.1.1.1 abstract Interfaces
Every interface is implicitly abstract. This modifier is obsolete and should notbe used in new programs.

9.1.1.2 strictfp Interfaces
The effect of the strictfp modifier is to make all float or double expressionswithin the interface declaration be explicitly FP-strict ($15.4).

This implies that all nested types declared in the interface are implicitly
strictfp.

INTERFACES Superinterfaces and Subinterfaces 9.1.2

201DRAFT
9.1.2   Superinterfaces and Subinterfaces
If an extends clause is provided, then the interface being declared extends eachof the other named interfaces and therefore inherits the member types, methods,

and constants of each of the other named interfaces. These other named interfacesare the direct superinterfaces of the interface being declared. Any class that
implements the declared interface is also considered to implement all the inter-faces that this interface

extends.

ExtendsInterfaces:

extends InterfaceTypeExtendsInterfaces

 , InterfaceType

The following is repeated from $4.2 to make the presentation here clearer:

InterfaceType:TypeName

Each InterfaceType in the extends clause of an interface declaration mustname an accessible interface type; otherwise a compile-time error occurs.
An interface I directly depends on a type T if T is mentioned in the extendsclause of

I either as a superinterface or as a qualifier within a superinterface name.An interface

I depends on a reference type T if any of the following conditionshold:

* I directly depends on T.

* I directly depends on a class C that depends ($8.1.3) on T.

* I directly depends on an interface J that depends on T (using this definitionrecursively).

A compile-time error occurs if an interface depends on itself.While every class is an extension of class

Object, there is no single interfaceof which all interfaces are extensions.

The superinterface relationship is the transitive closure of the direct super-interface relationship. An interface

K is a superinterface of interface I if either ofthe following is true:

* K is a direct superinterface of I.

* There exists an interface J such that K is a superinterface of J, and J is asuperinterface of

I, applying this definition recursively.

Interface I is said to be a subinterface of interface K whenever K is a superinter-face of

I.

9.1.3 Interface Body and Member Declarations INTERFACES
202 DRAFT

9.1.3   Interface Body and Member Declarations
The body of an interface may declare members of the interface:

InterfaceBody:

{ InterfaceMemberDeclarationsopt }

InterfaceMemberDeclarations:InterfaceMemberDeclaration

InterfaceMemberDeclarations InterfaceMemberDeclaration
InterfaceMemberDeclaration:ConstantDeclaration

AbstractMethodDeclarationClassDeclaration
InterfaceDeclaration
;

The scope of the declaration of a member m declared in or inherited by an
interface type I is the entire body of I, including any nested type declarations.

9.1.4   Access to Interface Member Names
All interface members are implicitly public. They are accessible outside thepackage where the interface is declared if the interface is also declared

public or
protected, in accordance with the rules of $6.6.

9.2   Interface Members
The members of an interface are:

* Those members declared in the interface.

* Those members inherited from direct superinterfaces.

* If an interface has no direct superinterfaces, then the interface implicitlydeclares a public abstract member method

m with signature s, return type r,and
throws clause t corresponding to each public instance method m withsignature

s, return type r, and throws clause t declared in Object, unless amethod with the same signature, same return type, and a compatible

throwsclause is explicitly declared by the interface.

It follows that it is a compile-time error if the interface declares a method withthe same signature and different return type or incompatible

throws clause.

INTERFACES Initialization of Fields in Interfaces 9.3.1

203DRAFT
The interface inherits, from the interfaces it extends, all members of thoseinterfaces, except for fields, classes, and interfaces that it hides and methods that it
overrides.

9.3   Field (Constant) Declarations

ConstantDeclaration:ConstantModifiers

opt Type VariableDeclarators

ConstantModifiers:ConstantModifier

ConstantModifier ConstantModifers
ConstantModifier: one of

public static final

Every field declaration in the body of an interface is implicitly public,
static, and final. It is permitted to redundantly specify any or all of these mod-ifiers for such fields.

If the interface declares a field with a certain name, then the declaration ofthat field is said to hide any and all accessible declarations of fields with the same
name in superinterfaces of the interface.It is a compile-time error for the body of an interface declaration to declare
two fields with the same name.It is possible for an interface to inherit more than one field with the same
name ($8.3.3.3). Such a situation does not in itself cause a compile-time error.However, any attempt within the body of the interface to refer to either field by its
simple name will result in a compile-time error, because such a reference isambiguous.

There might be several paths by which the same field declaration might beinherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.

9.3.1   Initialization of Fields in Interfaces
Every field in the body of an interface must have an initialization expression,which need not be a constant expression. The variable initializer is evaluated and

the assignment performed exactly once, when the interface is initialized ($12.4).

9.3.2 Examples of Field Declarations INTERFACES
204 DRAFT

A compile-time error occurs if an initialization expression for an interfacefield contains a reference by simple name to the same field or to another field
whose declaration occurs textually later in the same interface.Thus:

interface Test {

float f = j;
int j = 1;
int k = k+1;
}

causes two compile-time errors, because j is referred to in the initialization of fbefore

j is declared and because the initialization of k refers to k itself.One subtlety here is that, at run time, fields that are initialized with compiletime constant values are initialized first. This applies also to static final fieldsin classes ($8.3.2.1). This means, in particular, that these fields will never be
observed to have their default initial values ($4.5.5), even by devious programs.See $12.4.2 and $13.4.8 for more discussion.

If the keyword this ($15.8.3) or the keyword super (15.11.2, 15.12) occursin an initialization expression for a field of an interface, then unless the occurrence
is within the body of an anonymous class ($15.9.5), a compile-time error occurs.

9.3.2 Examples of Field Declarations
The following example illustrates some (possibly subtle) points about field decla-rations.

9.3.2.1 Ambiguous Inherited Fields
If two fields with the same name are inherited by an interface because, for exam-ple, two of its direct superinterfaces declare fields with that name, then a single

ambiguous member results. Any use of this ambiguous member will result in acompile-time error. Thus in the example:

interface BaseColors {

int RED = 1, GREEN = 2, BLUE = 4;
}

interface RainbowColors extends BaseColors {

int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7;
}

interface PrintColors extends BaseColors {

int YELLOW = 8, CYAN = 16, MAGENTA = 32;
}

interface LotsOfColors extends RainbowColors, PrintColors {

INTERFACES Abstract Method Declarations 9.4

205DRAFT
int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90;
}

the interface LotsOfColors inherits two fields named YELLOW. This is all right aslong as the interface does not contain any reference by simple name to the field

YELLOW. (Such a reference could occur within a variable initializer for a field.)Even if interface

PrintColors were to give the value 3 to YELLOW rather thanthe value
8, a reference to field YELLOW within interface LotsOfColors wouldstill be considered ambiguous.

9.3.2.2 Multiply Inherited Fields
If a single field is inherited multiple times from the same interface because, forexample, both this interface and one of this interface's direct superinterfaces

extend the interface that declares the field, then only a single member results. Thissituation does not in itself cause a compile-time error.

In the example in the previous section, the fields RED, GREEN, and BLUE areinherited by interface

LotsOfColors in more than one way, through interface
RainbowColors and also through interface PrintColors, but the reference tofield

RED in interface LotsOfColors is not considered ambiguous because onlyone actual declaration of the field

RED is involved.

9.4 Abstract Method Declarations

AbstractMethodDeclaration:AbstractMethodModifiers

opt ResultType MethodDeclarator Throwsopt ;

AbstractMethodModifiers:AbstractMethodModifier

AbstractMethodModifiers AbstractMethodModifier
AbstractMethodModifier: one of

public abstract

The access modifier public is discussed in $6.6. A compile-time error occursif the same modifier appears more than once in an abstract method declaration.

Every method declaration in the body of an interface is implicitly abstract,so its body is always represented by a semicolon, not a block.
Every method declaration in the body of an interface is implicitly public.For compatibility with older versions of the Java platform, it is permitted but
discouraged, as a matter of style, to redundantly specify the abstract modifierfor methods declared in interfaces.

9.4.1 Inheritance and Overriding INTERFACES
206 DRAFT

It is permitted, but strongly discouraged as a matter of style, to redundantlyspecify the

public modifier for interface methods.Note that a method declared in an interface must not be declared

static, or acompile-time error occurs, because
static methods cannot be abstract.Note that a method declared in an interface must not be declared

strictfpor
native or synchronized, or a compile-time error occurs, because those key-words describe implementation properties rather than interface properties. However, a method declared in an interface may be implemented by a method that isdeclared

strictfp or native or synchronized in a class that implements theinterface.

It is a compile-time error for the body of an interface to declare, explicitly orimplicitly, two methods with the same signature (name, number of parameters,
and types of any parameters) ($8.4.2). However, an interface may inherit severalmethod with the same signature ($9.4.1).

Note that a method declared in an interface must not be declared final or acompile-time error occurs. However, a method declared in an interface may be
implemented by a method that is declared final in a class that implements theinterface.

9.4.1   Inheritance and Overriding
If the interface declares a method, then the declaration of that method is said tooverride any and all methods with the same signature in the superinterfaces of the

interface.If a method declaration in an interface overrides the declaration of a method
in another interface, a compile-time error occurs if the methods have differentreturn types or if one has a return type and the other is

void. Moreover, a methoddeclaration must not have a
throws clause that conflicts ($8.4.4) with that of anymethod that it overrides; otherwise, a compile-time error occurs.

Methods are overridden on a signature-by-signature basis. If, for example, aninterface declares two

public methods with the same name, and a subinterfaceoverrides one of them, the subinterface still inherits the other method.

An interface inherits from its direct superinterfaces all methods of the super-interfaces that are not overridden by a declaration in the interface.
It is possible for an interface to inherit more than one method with the samesignature ($8.4.2). Such a situation does not in itself cause a compile-time error.
The interface is considered to inherit all the methods. However, a compile-timeerror occurs if, for any two such inherited methods, either they have different
return types or one has a return type and the other is void. (The throws clausesdo not cause errors in this case.) There might be several paths by which the same

INTERFACES Examples of Abstract Method Declarations 9.4.3

207DRAFT
method declaration is inherited from an interface. This fact causes no difficultyand never of itself results in a compile-time error.
9.4.2   Overloading
If two methods of an interface (whether both declared in the same interface, orboth inherited by an interface, or one declared and one inherited) have the same

name but different signatures, then the method name is said to be overloaded. Thisfact causes no difficulty and never of itself results in a compile-time error. There is
no required relationship between the return types or between the throws clausesof two methods with the same name but different signatures.

9.4.3 Examples of Abstract Method Declarations
The following examples illustrate some (possibly subtle) points about abstractmethod declarations.

9.4.3.1 Example: Overriding
Methods declared in interfaces are abstract and thus contain no implementation.About all that can be accomplished by an overriding method declaration, other

than to affirm a method signature, is to restrict the exceptions that might be thrownby an implementation of the method. Here is a variation of the example shown in

$8.4.3.1:

class BufferEmpty extends Exception {

BufferEmpty() { super(); }
BufferEmpty(String s) { super(s); }
}

class BufferError extends Exception {

BufferError() { super(); }
BufferError(String s) { super(s); }
}

public interface Buffer {

char get() throws BufferEmpty, BufferError;
}

public interface InfiniteBuffer extends Buffer {

 char get() throws BufferError; // override
}

9.5 Member Type Declarations INTERFACES

208 DRAFT

9.4.3.2 Example: Overloading
In the example code:

interface PointInterface {

void move(int dx, int dy);
}

interface RealPointInterface extends PointInterface {

void move(float dx, float dy);
void move(double dx, double dy);
}

the method name move is overloaded in interface RealPointInterface withthree different signatures, two of them declared and one inherited. Any nonabstract class that implements interface RealPointInterface must provideimplementations of all three method signatures.

9.5   Member Type Declarations
Interfaces may contain member type declarations ($8.5). A member type declara-tion in an interface is implicitly

static and public.If a member type declared with simple name

C is directly enclosed within thedeclaration of an interface with fully qualified name

N, then the member type hasthe fully qualified name
N.C.If the interface declares a member type with a certain name, then the declaration of that field is said to hide any and all accessible declarations of membertypes with the same name in superinterfaces of the interface.

An interface may inherit two or more type declarations with the same name.A compile-time error occurs on any attempt to refer to any ambiguously inherited
class or interface by its simple name. If the same type declaration is inherited froman interface by multiple paths, the class or interface is considered to be inherited
only once; it may be referred to by its simple name without ambiguity.

209DRAFT

C H A P T E R 10

Arrays

IN the Java programming language arrays are objects ($4.3.1), are dynamicallycreated, and may be assigned to variables of type

Object ($4.3.2). All methods ofclass
Object may be invoked on an array.An array object contains a number of variables. The number of variables may

be zero, in which case the array is said to be empty. The variables contained in anarray have no names; instead they are referenced by array access expressions that
use nonnegative integer index values. These variables are called the componentsof the array. If an array has n components, we say n is the length of the array; the
components of the array are referenced using integer indices from 0 to ,inclusive.

All the components of an array have the same type, called the component typeof the array. If the component type of an array is

T, then the type of the array itselfis written
T[].The value of an array component of type

float is always an element of thefloat value set ($4.2.3); similarly, the value of an array component of type

doubleis always an element of the double value set. It is not permitted for the value of an

array component of type float to be an element of the float-extended-exponentvalue set that is not also an element of the float value set, nor for the value of an
array component of type double to be an element of the double-extended-expo-nent value set that is not also an element of the double value set.

The component type of an array may itself be an array type. The componentsof such an array may contain references to subarrays. If, starting from any array
type, one considers its component type, and then (if that is also an array type) thecomponent type of that type, and so on, eventually one must reach a component
type that is not an array type; this is called the element type of the original array,and the components at this level of the data structure are called the elements of the
original array.There are some situations in which an element of an array can be an array: if
the element type is Object or Cloneable or java.io.Serializable, then someor all of the elements may be arrays, because any array object can be assigned to
any variable of these types.

n 1-
10.1 Array Types ARRAYS

210 DRAFT

10.1 Array Types
An array type is written as the name of an element type followed by some numberof empty pairs of square brackets

[]. The number of bracket pairs indicates thedepth of array nesting. An array's length is not part of its type.

The element type of an array may be any type, whether primitive or reference.In particular:

* Arrays with an interface type as the component type are allowed. The ele-ments of such an array may have as their value a null reference or instances of

any type that implements the interface.

* Arrays with an abstract class type as the component type are allowed. Theelements of such an array may have as their value a null reference or instances

of any subclass of the abstract class that is not itself abstract.
Array types are used in declarations and in cast expressions ($15.16).

10.2   Array Variables
A variable of array type holds a reference to an object. Declaring a variable ofarray type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array.However, the initializer part of a declarator ($8.3) may create an array, a reference
to which then becomes the initial value of the variable.Because an array's length is not part of its type, a single variable of array type
may contain references to arrays of different lengths.Here are examples of declarations of array variables that do not create arrays:

int[] ai; // array of int
short[][] as; // array of array of short
Object[] ao, // array of Object

otherAo; // array of Object
short s, // scalar short

aas[][]; // array of array of short

Here are some examples of declarations of array variables that create arrayobjects:

Exception ae[] = new Exception[3];
Object aao[][] = new Exception[2][3];
int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac[] = { 'n', 'o', 't', ' ', 'a', ' ',

 'S', 't', 'r', 'i', 'n', 'g' };String[] aas = { "array", "of", "String", };

ARRAYS Array Access 10.4

211DRAFT
The [] may appear as part of the type at the beginning of the declaration, or aspart of the declarator for a particular variable, or both, as in this example:

byte[] rowvector, colvector, matrix[];
This declaration is equivalent to:

byte rowvector[], colvector[], matrix[][];
Once an array object is created, its length never changes. To make an array vari-able refer to an array of different length, a reference to a different array must be

assigned to the variable.If an array variable

v has type A[], where A is a reference type, then v canhold a reference to an instance of any array type

B[], provided B can be assignedto
A. This may result in a run-time exception on a later assignment; see $10.10 fora discussion.

10.3   Array Creation
An array is created by an array creation expression ($15.10) or an array initializer($10.6).

An array creation expression specifies the element type, the number of levelsof nested arrays, and the length of the array for at least one of the levels of nesting.
The array's length is available as a final instance variable length.An array initializer creates an array and provides initial values for all its components.

10.4   Array Access
A component of an array is accessed by an array access expression ($15.13) thatconsists of an expression whose value is an array reference followed by an indexing expression enclosed by [ and ], as in A[i]. All arrays are 0-origin. An arraywith length

n can be indexed by the integers 0 to n-1.Arrays must be indexed by

int values; short, byte, or char values may alsobe used as index values because they are subjected to unary numeric promotion

($5.6.1) and become int values. An attempt to access an array component with a
long index value results in a compile-time error.All array accesses are checked at run time; an attempt to use an index that is

less than zero or greater than or equal to the length of the array causes an
ArrayIndexOutOfBoundsException to be thrown.

10.5 Arrays: A Simple Example ARRAYS
212 DRAFT

10.5 Arrays: A Simple Example
The example:

class Gauss {

public static void main(String[] args) {

int[] ia = new int[101];
for (int i = 0; i < ia.length; i++)

ia[i] = i;
int sum = 0;
for (int i = 0; i < ia.length; i++)

sum += ia[i];
System.out.println(sum);
}
}

that produces the output:

5050
declares a variable ia that has type array of int, that is, int[]. The variable ia isinitialized to reference a newly created array object, created by an array creation

expression ($15.10). The array creation expression specifies that the array shouldhave

101 components. The length of the array is available using the field length,as shown.

The example program fills the array with the integers from 0 to 100, sumsthese integers, and prints the result.

10.6 Array Initializers
An array initializer may be specified in a declaration, or as part of an array cre-ation expression ($15.10), creating an array and providing some initial values:

ArrayInitializer:

{ VariableInitializersopt ,opt }

VariableInitializers:VariableInitializer

VariableInitializers , VariableInitializer
The following is repeated from $8.3 to make the presentation here clearer:

VariableInitializer:Expression

ArrayInitializer

ARRAYS Array Members 10.7

213DRAFT
An array initializer is written as a comma-separated list of expressions,enclosed by braces "

{" and "}".The length of the constructed array will equal the number of expressions.

The expressions in an array initializer are executed from left to right in thetextual order they occur in the source code. The nth variable initializer specifies
the value of the n-1st array component. Each expression must be assignment-com-patible ($5.2) with the array's component type, or a compile-time error results.

If the component type is itself an array type, then the expression specifying acomponent may itself be an array initializer; that is, array initializers may be
nested.A trailing comma may appear after the last expression in an array initializer
and is ignored.As an example:

class Test {

public static void main(String[] args) {

int ia[][] = { {1, 2}, null };
for (int i = 0; i < 2; i++)

for (int j = 0; j < 2; j++)

System.out.println(ia[i][j]);
}
}

prints:

1
2

before causing a NullPointerException in trying to index the second compo-nent of the array

ia, which is a null reference.

10.7 Array Members

The members of an array type are all of the following:

* The public final field length, which contains the number of componentsof the array (

length may be positive or zero)

* The public method clone, which overrides the method of the same name inclass

Object and throws no checked exceptions

* All the members inherited from class Object; the only method of Object thatis not inherited is its

clone method

An array thus has the same public fields and methods as the following class:

10.7 Array Members ARRAYS
214 DRAFT

class A implements Cloneable, java.io.Serializable {

public final int length = X;
public Object clone() {

try {

return super.clone();
} catch (CloneNotSupportedException e) {

throw new InternalError(e.getMessage());
}
}

}
Every array implements the interfaces Cloneable and java.io.Serializable.That arrays are cloneable is shown by the test program:

class Test {

public static void main(String[] args) {

int ia1[] = { 1, 2 };
int ia2[] = (int[])ia1.clone();
System.out.print((ia1 == ia2) + " ");
ia1[1]++;
System.out.println(ia2[1]);
}
}

which prints:

false 2
showing that the components of the arrays referenced by ia1 and ia2 are differentvariables. (In some early implementations of the Java programming language this

example failed to compile because the compiler incorrectly believed that the clonemethod for an array could throw a

CloneNotSupportedException.)A
clone of a multidimensional array is shallow, which is to say that it createsonly a single new array. Subarrays are shared.

This is shown by the example program:
class Test {

public static void main(String[] args) throws Throwable {

int ia[][] = { { 1 , 2}, null };
int ja[][] = (int[][])ia.clone();
System.out.print((ia == ja) + " ");
System.out.println(ia[0] == ja[0] && ia[1] == ja[1]);
}
}

which prints:

false true

ARRAYS Array Store Exception 10.10

215DRAFT
showing that the int[] array that is ia[0] and the int[] array that is ja[0] arethe same array.
10.8 Class Objects for Arrays
Every array has an associated Class object, shared with all other arrays with thesame component type. The direct superclass of an array type is

Object. Everyarray type implements the interfaces
Cloneable and java.io.Serializable.This is shown by the following example code:

class Test {

public static void main(String[] args) {

int[] ia = new int[3];
System.out.println(ia.getClass());
System.out.println(ia.getClass().getSuperclass());
}
}

which prints:

class [I
class java.lang.Object

where the string "[I" is the run-time type signature for the class object "arraywith component type

int".

10.9 An Array of Characters is Not a String
In Java programming language, unlike C, an array of char is not a String, andneither a

String nor an array of char is terminated by '\u0000' (the NUL char-acter).

A String object is immutable, that is, its contents never change, while anarray of

char has mutable elements. The method toCharArray in class Stringreturns an array of characters containing the same character sequence as a

String. The class StringBuffer implements useful methods on mutable arraysof characters.

10.10   Array Store Exception
If an array variable v has type A[], where A is a reference type, then v can hold areference to an instance of any array type

B[], provided B can be assigned to A.

10.10 Array Store Exception ARRAYS
216 DRAFT

Thus, the example:
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {

public static void main(String[] args) {

ColoredPoint[] cpa = new ColoredPoint[10];
Point[] pa = cpa;
System.out.println(pa[1] == null);
try {

pa[0] = new Point();
} catch (ArrayStoreException e) {

System.out.println(e);
}
}
}

produces the output:

true
java.lang.ArrayStoreException

Here the variable pa has type Point[] and the variable cpa has as its value a ref-erence to an object of type

ColoredPoint[]. A ColoredPoint can be assignedto a
Point; therefore, the value of cpa can be assigned to pa.A reference to this array

pa, for example, testing whether pa[1] is null, willnot result in a run-time type error. This is because the element of the array of type

ColoredPoint[] is a ColoredPoint, and every ColoredPoint can stand in fora

Point, since Point is the superclass of ColoredPoint.On the other hand, an assignment to the array

pa can result in a run-time error.At compile time, an assignment to an element of

pa is checked to make sure thatthe value assigned is a
Point. But since pa holds a reference to an array of
ColoredPoint, the assignment is valid only if the type of the value assigned atrun-time is, more specifically, a

ColoredPoint.The Java virtual machine checks for such a situation at run-time to ensure that

the assignment is valid; if not, an ArrayStoreException is thrown. More for-mally: an assignment to an element of an array whose type is

A[], where A is areference type, is checked at run-time to ensure that the value assigned can be

assigned to the actual element type of the array, where the actual element typemay be any reference type that is assignable to

A.

ARRAYS Array Store Exception 10.10

217DRAFT219DRAFT
C H A P T E R 11

Exceptions

WHEN a program violates the semantic constraints of the Java programminglanguage, the Java virtual machine signals this error to the program as an exception. An example of such a violation is an attempt to index outside the bounds ofan array. Some programming languages and their implementations react to such
errors by peremptorily terminating the program; other programming languagesallow an implementation to react in an arbitrary or unpredictable way. Neither of
these approaches is compatible with the design goals of the Java platform: to pro-vide portability and robustness. Instead, the Java programming language specifies
that an exception will be thrown when semantic constraints are violated and willcause a non-local transfer of control from the point where the exception occurred
to a point that can be specified by the programmer. An exception is said to bethrown from the point where it occurred and is said to be caught at the point to
which control is transferred.Programs can also throw exceptions explicitly, using

throw statements($14.17).

Explicit use of throw statements provides an alternative to the old-fashionedstyle of handling error conditions by returning funny values, such as the integer
value -1 where a negative value would not normally be expected. Experienceshows that too often such funny values are ignored or not checked for by callers,
leading to programs that are not robust, exhibit undesirable behavior, or both.Every exception is represented by an instance of the class

Throwable or oneof its subclasses; such an object can be used to carry information from the point at

which an exception occurs to the handler that catches it. Handlers are establishedby

catch clauses of try statements ($14.19). During the process of throwing anexception, the Java virtual machine abruptly completes, one by one, any expressions, statements, method and constructor invocations, initializers, and field ini-tialization expressions that have begun but not completed execution in the current
thread. This process continues until a handler is found that indicates that it handles

11.1 The Causes of Exceptions EXCEPTIONS
220 DRAFT

that particular exception by naming the class of the exception or a superclass ofthe class of the exception. If no such handler is found, then the method
uncaughtException is invoked for the ThreadGroup that is the parent of thecurrent thread--thus every effort is made to avoid letting an exception go unhandled.The exception mechanism of the Java platform is integrated with its synchronization model ($17), so that locks are released as synchronized statements($14.18) and invocations of

synchronized methods ($8.4.3.6, $15.12) completeabruptly.

This chapter describes the different causes of exceptions ($11.1). It detailshow exceptions are checked at compile time ($11.2) and processed at run time
($11.3). A detailed example ($11.4) is then followed by an explanation of theexception hierarchy ($11.5).

11.1   The Causes of Exceptions
An exception is thrown for one of three reasons:

* An abnormal execution condition was synchronously detected by the Java vir-tual machine. Such conditions arise because:

u evaluation of an expression violates the normal semantics of the language,such as an integer divide by zero, as summarized in $15.6
u an error occurs in loading or linking part of the program ($12.2, $12.3)
u some limitation on a resource is exceeded, such as using too much memory
These exceptions are not thrown at an arbitrary point in the program, butrather at a point where they are specified as a possible result of an expression

evaluation or statement execution.

* A throw statement ($14.17) was executed.

* An asynchronous exception occurred either because:

u the method stop of class Thread was invoked
u an internal error has occurred in the virtual machine ($11.5.2)
Exceptions are represented by instances of the class Throwable and instancesof its subclasses. These classes are, collectively, the exception classes.

EXCEPTIONS Why Errors are Not Checked 11.2.1

221DRAFT
11.2   Compile-Time Checking of Exceptions
A compiler for the Java programming language checks, at compile time, that aprogram contains handlers for checked exceptions, by analyzing which checked
exceptions can result from execution of a method or constructor. For each checkedexception which is a possible result, the

throws clause for the method ($8.4.4) orconstructor ($8.8.4) must mention the class of that exception or one of the superclasses of the class of that exception. This compile-time checking for the presenceof exception handlers is designed to reduce the number of exceptions which are
not properly handled.The unchecked exceptions classes are the class

RuntimeException and itssubclasses, and the class
Error and its subclasses. All other exception classes arechecked exception classes. The Java API defines a number of exception classes,

both checked and unchecked. Additional exception classes, both checked andunchecked, may be declared by programmers. See $11.5 for a description of the
exception class hierarchy and some of the exception classes defined by the JavaAPI and Java virtual machine.

The checked exception classes named in the throws clause are part of thecontract between the implementor and user of the method or constructor. The
throws clause of an overriding method may not specify that this method willresult in throwing any checked exception which the overridden method is not permitted, by its throws clause, to throw. When interfaces are involved, more thanone method declaration may be overridden by a single overriding declaration. In
this case, the overriding declaration must have a throws clause that is compatiblewith all the overridden declarations ($9.4).

Static initializers ($8.7), class variable initializers, and instance initializers orinstance variable initializers within named classes and interfaces ($8.3.2), must
not result in a checked exception; if one does, a compile-time error occurs. Nosuch restriction applies to instance initializers or instance variable initializers
within anonymous classes ($15.9.5).

11.2.1 Why Errors are Not Checked
Those unchecked exception classes which are the error classes (Error and itssubclasses) are exempted from compile-time checking because they can occur at

many points in the program and recovery from them is difficult or impossible. Aprogram declaring such exceptions would be cluttered, pointlessly.

11.2.2 Why Runtime Exceptions are Not Checked EXCEPTIONS

222 DRAFT

11.2.2   Why Runtime Exceptions are Not Checked
The runtime exception classes (RuntimeException and its subclasses) areexempted from compile-time checking because, in the judgment of the designers

of the Java programming language, having to declare such exceptions would notaid significantly in establishing the correctness of programs. Many of the operations and constructs of the Java programming language can result in runtimeexceptions. The information available to a compiler, and the level of analysis the
compiler performs, are usually not sufficient to establish that such run-time excep-tions cannot occur, even though this may be obvious to the programmer. Requiring such exception classes to be declared would simply be an irritation toprogrammers.

For example, certain code might implement a circular data structure that, byconstruction, can never involve

null references; the programmer can then becertain that a
NullPointerException cannot occur, but it would be difficult for acompiler to prove it. The theorem-proving technology that is needed to establish

such global properties of data structures is beyond the scope of this specification.

11.3 Handling of an Exception
When an exception is thrown, control is transferred from the code that caused theexception to the nearest dynamically-enclosing

catch clause of a try statement($14.19) that handles the exception.

A statement or expression is dynamically enclosed by a catch clause if itappears within the

try block of the try statement of which the catch clause is apart, or if the caller of the statement or expression is dynamically enclosed by the

catch clause.The caller of a statement or expression depends on where it occurs:

* If within a method, then the caller is the method invocation expression($15.12) that was executed to cause the method to be invoked.

* If within a constructor or an instance initializer or the initializer for aninstance variable, then the caller is the class instance creation expression

($15.9) or the method invocation of newInstance that was executed to causean object to be created.

* If within a static initializer or an initializer for a static variable, then thecaller is the expression that used the class or interface so as to cause it to be

initialized.

EXCEPTIONS Exceptions are Precise 11.3.1

223DRAFT
Whether a particular catch clause handles an exception is determined bycomparing the class of the object that was thrown to the declared type of the
parameter of the catch clause. The catch clause handles the exception if the typeof its parameter is the class of the exception or a superclass of the class of the
exception. Equivalently, a catch clause will catch any exception object that is an
instanceof ($15.20.2) the declared parameter type.The control transfer that occurs when an exception is thrown causes abrupt

completion of expressions ($15.6) and statements ($14.1) until a catch clause isencountered that can handle the exception; execution then continues by executing
the block of that catch clause. The code that caused the exception is neverresumed.

If no catch clause handling an exception can be found, then the currentthread (the thread that encountered the exception) is terminated, but only after all
finally clauses have been executed and the method uncaughtException hasbeen invoked for the

ThreadGroup that is the parent of the current thread.In situations where it is desirable to ensure that one block of code is always

executed after another, even if that other block of code completes abruptly, a trystatement with a

finally clause ($14.19.2) may be used.If a
try or catch block in a try-finally or try-catch-finally statementcompletes abruptly, then the

finally clause is executed during propagation of theexception, even if no matching

catch clause is ultimately found. If a finallyclause is executed because of abrupt completion of a

try block and the finallyclause itself completes abruptly, then the reason for the abrupt completion of the

try block is discarded and the new reason for abrupt completion is propagatedfrom there.

The exact rules for abrupt completion and for the catching of exceptions arespecified in detail with the specification of each statement in $14 and for expressions in $15 (especially $15.6).

11.3.1   Exceptions are Precise
Exceptions are precise: when the transfer of control takes place, all effects of thestatements executed and expressions evaluated before the point from which the

exception is thrown must appear to have taken place. No expressions, statements,or parts thereof that occur after the point from which the exception is thrown may
appear to have been evaluated. If optimized code has speculatively executed someof the expressions or statements which follow the point at which the exception
occurs, such code must be prepared to hide this speculative execution from theuser-visible state of the program.

11.3.2 Handling Asynchronous Exceptions EXCEPTIONS

224 DRAFT

11.3.2   Handling Asynchronous Exceptions
Most exceptions occur synchronously as a result of an action by the thread inwhich they occur, and at a point in the program that is specified to possibly result

in such an exception. An asynchronous exception is, by contrast, an exception thatcan potentially occur at any point in the execution of a program.

Proper understanding of the semantics of asynchronous exceptions is neces-sary if high-quality machine code is to be generated.
Asynchronous exceptions are rare. They occur only as a result of:

* An invocation of the stop methods of class Thread or ThreadGroup

* An internal error ($11.5.2) in the Java virtual machine

The stop methods may be invoked by one thread to affect another thread or all thethreads in a specified thread group. They are asynchronous because they may
occur at any point in the execution of the other thread or threads. An
InternalError is considered asynchronous.The Java platform permits a small but bounded amount of execution to occur

before an asynchronous exception is thrown. This delay is permitted to allow opti-mized code to detect and throw these exceptions at points where it is practical to
handle them while obeying the semantics of the Java programming language.A simple implementation might poll for asynchronous exceptions at the point
of each control transfer instruction. Since a program has a finite size, this providesa bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator hassome flexibility to reorder computation between control transfers for greater performance.The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993
Conference on Functional Programming and Computer Architecture, Copen-hagen, Denmark, pp. 179-187, is recommended as further reading.

Like all exceptions, asynchronous exceptions are precise ($11.3.1).

11.4 An Example of Exceptions
Consider the following example:

class TestException extends Exception {

TestException() { super(); }
TestException(String s) { super(s); }
}

EXCEPTIONS An Example of Exceptions 11.4

225DRAFT
class Test {

public static void main(String[] args) {

for (int i = 0; i < args.length; i++) {

try {

thrower(args[i]);
System.out.println("Test \"" + args[i] +

"\" didn't throw an exception");
} catch (Exception e) {

System.out.println("Test \"" + args[i] +

"\" threw a " + e.getClass() +
"\n with message: " + e.getMessage());
}
}
}

static int thrower(String s) throws TestException {

try {

if (s.equals("divide")) {

int i = 0;
return i/i;
}
if (s.equals("null")) {

s = null;
return s.length();
}
if (s.equals("test"))

throw new TestException("Test message");
return 0;
} finally {

System.out.println("[thrower(\"" + s +

"\") done]");
}
}

}
If we execute the test program, passing it the arguments:

divide null not test
it produces the output:

[thrower("divide") done]
Test "divide" threw a class java.lang.ArithmeticException

with message: / by zero
[thrower("null") done]
Test "null" threw a class java.lang.NullPointerException

with message: null
[thrower("not") done]
Test "not" didn't throw an exception

11.5 The Exception Hierarchy EXCEPTIONS
226 DRAFT

[thrower("test") done]
Test "test" threw a class TestException

with message: Test message

This example declares an exception class TestException. The main methodof class

Test invokes the thrower method four times, causing exceptions to bethrown three of the four times. The

try statement in method main catches eachexception that the
thrower throws. Whether the invocation of thrower completesnormally or abruptly, a message is printed describing what happened.

The declaration of the method thrower must have a throws clause becauseit can throw instances of

TestException, which is a checked exception class($11.2). A compile-time error would occur if the

throws clause were omitted.Notice that the
finally clause is executed on every invocation of thrower,whether or not an exception occurs, as shown by the "

[thrower(...) done]" out-put that occurs for each invocation.

11.5 The Exception Hierarchy
The possible exceptions in a program are organized in a hierarchy of classes,rooted at class

Throwable ($11.5), a direct subclass of Object. The classes
Exception and Error are direct subclasses of Throwable. The class RuntimeException is a direct subclass of Exception.Programs can use the pre-existing exception classes in

throw statements, ordefine additional exception classes, as subclasses of
Throwable or of any of itssubclasses, as appropriate. To take advantage of the Java platform's compile-time

checking for exception handlers, it is typical to define most new exception classesas checked exception classes, specifically as subclasses of

Exception that are notsubclasses of
RuntimeException.The class

Exception is the superclass of all the exceptions that ordinary pro-grams may wish to recover from. The class

RuntimeException is a subclass ofclass
Exception. The subclasses of RuntimeException are unchecked exceptionclasses. The subclasses of

Exception other than RuntimeException are allchecked exception classes.

The class Error and its subclasses are exceptions from which ordinary pro-grams are not ordinarily expected to recover. See the Java API specification for a
detailed description of the exception hierarchy.The class

Error is a separate subclass of Throwable, distinct from Exception in the class hierarchy, to allow programs to use the idiom:

} catch (Exception e) {

EXCEPTIONS Virtual Machine Errors 11.5.2

227DRAFT
to catch all exceptions from which recovery may be possible without catchingerrors from which recovery is typically not possible.
11.5.1 Loading and Linkage Errors
The Java virtual machine throws an object that is an instance of a subclass of
LinkageError when a loading, linkage, preparation, verification or initializationerror occurs:

* The loading process is described in $12.2.

* The linking process is described in $12.3.

* The class verification process is described in $12.3.1.

* The class preparation process is described in $12.3.2.

* The class initialization process is described in $12.4.

11.5.2   Virtual Machine Errors
The Java virtual machine throws an object that is an instance of a subclass of theclass

VirtualMachineError when an internal error or resource limitation pre-vents it from implementing the semantics of the Java programming language. See

The Java(TM) Virtual Machine Specification Second Edition for the definitive discus-sion of these errors.

229DRAFT

C H A P T E R 12

Execution

THIS chapter specifies activities that occur during execution of a program. It isorganized around the life cycle of a Java virtual machine and of the classes, interfaces, and objects that form a program.A Java virtual machine starts up by loading a specified class and then invoking the method main in this specified class. Section $12.1 outlines the loading,linking, and initialization steps involved in executing

main, as an introduction tothe concepts in this chapter. Further sections specify the details of loading ($12.2),

linking ($12.3), and initialization ($12.4).The chapter continues with a specification of the procedures for creation of
new class instances ($12.5); and finalization of class instances ($12.6). It con-cludes by describing the unloading of classes ($12.7) and the procedure followed
when a program exits ($12.8).

12.1   Virtual Machine Start-Up
A Java virtual machine starts execution by invoking the method main of somespecified class, passing it a single argument, which is an array of strings. In the
examples in this specification, this first class is typically called Test.The precise semantics of virtual machine start-up are given in chapter 5 of
The Java(TM) Virtual Machine Specification, Second Edition. Here we present anoverview of the process from the viewpoint of the Java programming language.

The manner in which the initial class is specified to the Java virtual machine isbeyond the scope of this specification, but it is typical, in host environments that
use command lines, for the fully-qualified name of the class to be specified as acommand-line argument and for following command-line arguments to be used as
strings to be provided as the argument to the method main. For example, in aUNIX implementation, the command line:

12.1.1 Load the Class Test EXECUTION
230 DRAFT

java Test reboot Bob Dot Enzo
will typically start a Java virtual machine by invoking method main of class Test(a class in an unnamed package), passing it an array containing the four strings

"reboot", "Bob", "Dot", and "Enzo".We now outline the steps the virtual machine may take to execute

Test, as anexample of the loading, linking, and initialization processes that are described further in later sections.

12.1.1   Load the Class Test
The initial attempt to execute the method main of class Test discovers that theclass

Test is not loaded--that is, that the virtual machine does not currently con-tain a binary representation for this class. The virtual machine then uses a class

loader to attempt to find such a binary representation. If this process fails, then anerror is thrown. This loading process is described further in $12.2.

12.1.2   Link Test: Verify, Prepare, (Optionally) Resolve
After Test is loaded, it must be initialized before main can be invoked. And Test,like all (class or interface) types, must be linked before it is initialized. Linking

involves verification, preparation and (optionally) resolution. Linking is describedfurther in $12.3.

Verification checks that the loaded representation of Test is well-formed,with a proper symbol table. Verification also checks that the code that implements
Test obeys the semantic requirements of the Java programming language and theJava virtual machine. If a problem is detected during verification, then an error is
thrown. Verification is described further in $12.3.1.Preparation involves allocation of static storage and any data structures that
are used internally by the virtual machine, such as method tables. Preparation isdescribed further in $12.3.2.

Resolution is the process of checking symbolic references from Test to otherclasses and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linkedvery early, even to the point of resolving all symbolic references from the classes
and interfaces that are further referenced, recursively. (This resolution may resultin errors from these further loading and linking steps.) This implementation
choice represents one extreme and is similar to the kind of "static" linkage thathas been done for many years in simple implementations of the C language. (In

EXECUTION Initialize Test: Execute Initializers 12.1.3

231DRAFT
these implementations, a compiled program is typically represented as an"

a.out" file that contains a fully-linked version of the program, including com-pletely resolved links to library routines used by the program. Copies of these

library routines are included in the "a.out" file.)An implementation may instead choose to resolve a symbolic reference only
when it is actively used; consistent use of this strategy for all symbolic referenceswould represent the "laziest" form of resolution.

In this case, if Test had several symbolic references to another class, then thereferences might be resolved one at a time, as they are used, or perhaps not at all,
if these references were never used during execution of the program.The only requirement on when resolution is performed is that any errors
detected during resolution must be thrown at a point in the program where someaction is taken by the program that might, directly or indirectly, require linkage to
the class or interface involved in the error. Using the "static" example implemen-tation choice described above, loading and linkage errors could occur before the
program is executed if they involved a class or interface mentioned in the class
Test or any of the further, recursively referenced, classes and interfaces. In asystem that implemented the "laziest" resolution, these errors would be thrown

only when an incorrect symbolic reference is actively used.The resolution process is described further in $12.3.3.

12.1.3 Initialize Test: Execute Initializers
In our continuing example, the virtual machine is still trying to execute themethod

main of class Test. This is permitted only if the class has been initialized($12.4.1).

Initialization consists of execution of any class variable initializers and staticinitializers of the class

Test, in textual order. But before Test can be initialized,its direct superclass must be initialized, as well as the direct superclass of its direct

superclass, and so on, recursively. In the simplest case, Test has Object as itsimplicit direct superclass; if class

Object has not yet been initialized, then it mustbe initialized before
Test is initialized. Class Object has no superclass, so therecursion terminates here.

If class Test has another class Super as its superclass, then Super must beinitialized before

Test. This requires loading, verifying, and preparing Super ifthis has not already been done and, depending on the implementation, may also

involve resolving the symbolic references from Super and so on, recursively.Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.The initialization process is described further in $12.4.

12.1.4 Invoke Test.main EXECUTION
232 DRAFT

12.1.4   Invoke Test.main
Finally, after completion of the initialization for class Test (during which otherconsequential loading, linking, and initializing may have occurred), the method

main of Test is invoked.The method

main must be declared public, static, and void. It must accepta single argument that is an array of strings.

12.2 Loading of Classes and Interfaces
Loading refers to the process of finding the binary form of a class or interface typewith a particular name, perhaps by computing it on the fly, but more typically by
retrieving a binary representation previously computed from source code by acompiler, and constructing, from that binary form, a

Class object to represent theclass or interface.

The precise semantics of loading are given in chapter 5 of The Java(TM) VirtualMachine Specification, Second Edition. Here we present an overview of the process from the viewpoint of the Java programming language.The binary format of a class or interface is normally the

class file formatdescribed in The Java
(TM) Virtual Machine Specification cited above, but other formats are possible, provided they meet the requirements specified in $13.1. Themethod

defineClass of class ClassLoader may be used to construct Classobjects from binary representations in the

class file format.Well-behaved class loaders maintain these properties:

* Given the same name, a good class loader should always return the same classobject.

* If a class loader L1 delegates loading of a class C to another loader L2, then forany type

T that occurs as the direct superclass or a direct superinterface of C,or as the type of a field in

C, or as the type of a formal parameter of a methodor constructor in
C, or as a return type of a method in C, L1 and L2 shouldreturn the same class object.

A malicious class loader could violate these properties. However, it could notundermine the security of the type system, because the Java virtual machine
guards against this.For further discussion of these issues, see The Java

(TM) Virtual Machine Specification, Second Edition and the paper Dynamic Class Loading in the Java(TM) VirtualMachine, by Sheng Liang and Gilad Bracha, in Proceedings of OOPSLA '98, published as ACM SIGPLAN Notices, Volume 33, Number 10, October 1998, pages36-44. A basic principle of the design of the Java programming language is that

EXECUTION Linking of Classes and Interfaces 12.3

233DRAFT
the type system cannot be subverted by code written in the language, not even byimplementations of such otherwise sensitive system classes as

ClassLoader and
SecurityManager.

12.2.1   The Loading Process
The loading process is implemented by the class ClassLoader and its subclasses.Different subclasses of

ClassLoader may implement different loading policies.In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classestogether. These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because anolder version is cached by a class loader. It is the responsibility of a class loader,
however, to reflect loading errors only at points in the program they could havearisen without prefetching or group loading.

If an error occurs during class loading, then an instance of one of the follow-ing subclasses of class

LinkageError will be thrown at any point in the programthat (directly or indirectly) uses the type:

* ClassCircularityError: A class or interface could not be loaded becauseit would be its own superclass or superinterface ($13.4.4).

* ClassFormatError: The binary data that purports to specify a requestedcompiled class or interface is malformed.

* NoClassDefFoundError: No definition for a requested class or interfacecould be found by the relevant class loader.

Because loading involves the allocation of new data structures, it may failwith an

OutOfMemoryError.

12.3 Linking of Classes and Interfaces
Linking is the process of taking a binary form of a class or interface type and com-bining it into the runtime state of the Java virtual machine, so that it can be executed. A class or interface type is always loaded before it is linked.Three different activities are involved in linking: verification, preparation, and
resolution of symbolic references.The precise semantics of linking are given inchapter 5 of The Java

(TM) Virtual Machine Specification, Second Edition. Here we

present an overview of the process from the viewpoint of the Java programminglanguage.

12.3.1 Verification of the Binary Representation EXECUTION
234 DRAFT

This specification allows an implementation flexibility as to when linkingactivities (and, because of recursion, loading) take place, provided that the semantics of the language are respected, that a class or interface is completely verifiedand prepared before it is initialized, and that errors detected during linkage are
thrown at a point in the program where some action is taken by the program thatmight require linkage to the class or interface involved in the error.

For example, an implementation may choose to resolve each symbolic refer-ence in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (staticresolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.Because linking involves the allocation of new data structures, it may fail with
an OutOfMemoryError.

12.3.1   Verification of the Binary Representation
Verification ensures that the binary representation of a class or interface is struc-turally correct. For example, it checks that every instruction has a valid operation

code; that every branch instruction branches to the start of some other instruction,rather than into the middle of an instruction; that every method is provided with a
structurally correct signature; and that every instruction obeys the type disciplineof the Java virtual machine language.

For the specification of the verification process, see the separate volume ofthis series, The Java

(TM) Virtual Machine Specification, Second Edition.

If an error occurs during verification, then an instance of the following sub-class of class

LinkageError will be thrown at the point in the program thatcaused the class to be verified:

* VerifyError: The binary definition for a class or interface failed to pass a setof required checks to verify that it obeys the semantics of the Java virtual

machine language and that it cannot violate the integrity of the Java virtualmachine. (See $13.4.2, $13.4.4, $13.4.8, and $13.4.15 for some examples.)

12.3.2   Preparation of a Class or Interface Type
Preparation involves creating the static fields (class variables and constants) fora class or interface and initializing such fields to the default values ($4.5.5). This

does not require the execution of any source code; explicit initializers for staticfields are executed as part of initialization ($12.4), not preparation.

Implementations of the Java virtual machine may precompute additional datastructures at preparation time in order to make later operations on a class or interEXECUTION Resolution of Symbolic References 12.3.3

235DRAFT
face more efficient. One particularly useful data structure is a "method table" orother data structure that allows any method to be invoked on instances of a class
without requiring a search of superclasses at invocation time.

12.3.3 Resolution of Symbolic References
The binary representation of a class or interface references other classes and inter-faces and their fields, methods, and constructors symbolically, using the binary

names ($13.1) of the other classes and interfaces ($13.1). For fields and methods,these symbolic references include the name of the class or interface type that
declares the field or method as well as the name of the field or method itself,together with appropriate type information.

Before a symbolic reference can be used it must undergo resolution, whereina symbolic reference is checked to be correct and, typically, replaced with a direct
reference that can be more efficiently processed if the reference is used repeatedly.If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class
IncompatibleClassChangeError, but it may also be an instance of some othersubclass of

IncompatibleClassChangeError or even an instance of the class
IncompatibleClassChangeError itself. This error may be thrown at any pointin the program that uses a symbolic reference to the type, directly or indirectly:

* IllegalAccessError: A symbolic reference has been encountered thatspecifies a use or assignment of a field, or invocation of a method, or creation

of an instance of a class, to which the code containing the reference does nothave access because the field or method was declared

private, protected,or default access (not
public), or because the class was not declared public.

This can occur, for example, if a field that is originally declared public ischanged to be

private after another class that refers to the field has beencompiled ($13.4.6).

* InstantiationError: A symbolic reference has been encountered that isused in class instance creation expression, but an instance cannot be created

because the reference turns out to refer to an interface or to an abstractclass.

This can occur, for example, if a class that is originally not abstract ischanged to be

abstract after another class that refers to the class in questionhas been compiled ($13.4.1).

* NoSuchFieldError: A symbolic reference has been encountered that refersto a specific field of a specific class or interface, but the class or interface does

not contain a field of that name.

12.4 Initialization of Classes and Interfaces EXECUTION
236 DRAFT

This can occur, for example, if a field declaration was deleted from a classafter another class that refers to the field was compiled ($13.4.7).

* NoSuchMethodError: A symbolic reference has been encountered that refersto a specific method of a specific class or interface, but the class or interface

does not contain a method of that signature.
This can occur, for example, if a method declaration was deleted from a classafter another class that refers to the method was compiled ($13.4.11).

Additionally, an UnsatisfiedLinkError (a subclass of LinkageError)may be thrown if a class declares a

native method for which no implementationcan be found. The error will occur if the method is used, or earlier, depending on

what kind of resolution strategy is being used by the virtual machine ($12.3).

12.4 Initialization of Classes and Interfaces
Initialization of a class consists of executing its static initializers and the initializ-ers for

static fields (class variables) declared in the class. Initialization of aninterface consists of executing the initializers for fields (constants) declared there.

Before a class is initialized, its superclass must be initialized, but interfacesimplemented by the class are not initialized. Similarly, the superinterfaces of an
interface are not initialized before the interface is initialized.

12.4.1   When Initialization Occurs
Initialization of a class consists of executing its static initializers and the initializ-ers for static fields declared in the class. Initialization of an interface consists of

executing the initializers for fields declared in the interface.Before a class is initialized, its direct superclass must be initialized, but interfaces implemented by the class need not be initialized. Similarly, the superinter-faces of an interface need not be initialized before the interface is initialized.

A class or interface type T will be initialized immediately before the firstoccurrence of any one of the following:

* T is a class and an instance of T is created.

* T is a class and a static method declared by T is invoked.

* A static field declared by T is assigned.

* A static field declared by T is used and the reference to the field is not a com-pile-time constant ($15.28). References to compile-time constants must be

EXECUTION When Initialization Occurs 12.4.1

237DRAFT
resolved at compile time to a copy of the compile-time constant value, so usesof such a field never cause initialization.
Invocation of certain reflective methods in class Class and in package
java.lang.reflect also causes class or interface initialization. A class or inter-face will not be initialized under any other circumstance.

The intent here is that a class or interface type has a set of initializers that putit in a consistent state, and that this state is the first state that is observed by other
classes. The static initializers and class variable initializers are executed in textualorder, and may not refer to class variables declared in the class whose declarations
appear textually after the use, even though these class variables are in scope($8.3.2.3). This restriction is designed to detect, at compile time, most circular or
otherwise malformed initializations.As shown in an example in $8.3.2.3, the fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable canbe observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can bealso constructed for instance variable initialization; see the example at the end of

$12.5). The full power of the language is available in these initializers; program-mers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because the language is concurrent($12.4.3).

Before a class is initialized, its superclasses are initialized, if they have notpreviously been initialized.
Thus, the test program:
class Super {

static { System.out.print("Super "); }
}

class One {

static { System.out.print("One "); }
}

class Two extends Super {

static { System.out.print("Two "); }
}

class Test {

public static void main(String[] args) {

One o = null;
Two t = new Two();
System.out.println((Object)o == (Object)t);
}
}

12.4.1 When Initialization Occurs EXECUTION
238 DRAFT

prints:

Super Two false
The class One is never initialized, because it not used actively and therefore isnever linked to. The class

Two is initialized only after its superclass Super hasbeen initialized.

A reference to a class field causes initialization of only the class or interfacethat actually declares it, even though it might be referred to through the name of a
subclass, a subinterface, or a class that implements an interface.The test program:

class Super { static int taxi = 1729; }
class Sub extends Super {

static { System.out.print("Sub "); }
}

class Test {

public static void main(String[] args) {

System.out.println(Sub.taxi);
}
}

prints only:

1729
because the class Sub is never initialized; the reference to Sub.taxi is a referenceto a field actually declared in class

Super and does not trigger initialization of theclass
Sub.Initialization of an interface does not, of itself, cause initialization of any of its

superinterfaces.Thus, the test program:

interface I {

int i = 1, ii = Test.out("ii", 2);
}

interface J extends I {

int j = Test.out("j", 3), jj = Test.out("jj", 4);
}

interface K extends J {

int k = Test.out("k", 5);
}

class Test {

public static void main(String[] args) {

System.out.println(J.i);

EXECUTION Detailed Initialization Procedure 12.4.2

239DRAFT
System.out.println(K.j);
}

static int out(String s, int i) {

System.out.println(s + "=" + i);
return i;
}

}
produces the output:

1
j=3
jj=4
3

The reference to J.i is to a field that is a compile-time constant; therefore, itdoes not cause

I to be initialized. The reference to K.j is a reference to a fieldactually declared in interface

J that is not a compile-time constant; this causes ini-tialization of the fields of interface

J, but not those of its superinterface I, northose of interface
K. Despite the fact that the name K is used to refer to field j ofinterface
J, interface K is not initialized.

12.4.2 Detailed Initialization Procedure
Because the Java programming language is multithreaded, initialization of a classor interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the pos-sibility that initialization of a class or interface may be requested recursively as
part of the initialization of that class or interface; for example, a variable initial-izer in class

A might invoke a method of an unrelated class B, which might in turninvoke a method of class

A. The implementation of the Java virtual machine isresponsible for taking care of synchronization and recursive initialization by using

the following procedure. It assumes that the Class object has already been veri-fied and prepared, and that the

Class object contains state that indicates one offour situations:

* This Class object is verified and prepared but not initialized.

* This Class object is being initialized by some particular thread T.

* This Class object is fully initialized and ready for use.

* This Class object is in an erroneous state, perhaps because the verification orpreparation step failed, or because initialization was attempted and failed.

The procedure for initializing a class or interface is then as follows:

12.4.2 Detailed Initialization Procedure EXECUTION
240 DRAFT

1. Synchronize ($14.18) on the Class object that represents the class or interfaceto be initialized. This involves waiting until the current thread can obtain the

lock for that object ($17.13).
2. If initialization is in progress for the class or interface by some other thread,then

wait on this Class object (which temporarily releases the lock). Whenthe current thread awakens from the

wait, repeat this step.

3. If initialization is in progress for the class or interface by the current thread,then this must be a recursive request for initialization. Release the lock on the

Class object and complete normally.
4. If the class or interface has already been initialized, then no further action isrequired. Release the lock on the

Class object and complete normally.

5. If the Class object is in an erroneous state, then initialization is not possible.Release the lock on the

Class object and throw a NoClassDefFoundError.

6. Otherwise, record the fact that initialization of the Class object is now inprogress by the current thread and release the lock on the

Class object.

7. Next, if the Class object represents a class rather than an interface, and thesuperclass of this class has not yet been initialized, then recursively perform

this entire procedure for the superclass. If necessary, verify and prepare thesuperclass first. If the initialization of the superclass completes abruptly
because of a thrown exception, then lock this Class object, label it erroneous,notify all waiting threads, release the lock, and complete abruptly, throwing
the same exception that resulted from initializing the superclass.
8. Next, execute either the class variable initializers and static initializers of theclass, or the field initializers of the interface, in textual order, as though they

were a single block, except that final class variables and fields of interfaceswhose values are compile-time constants are initialized first ($8.3.2.1, $9.3.1,

$13.4.8).
9. If the execution of the initializers completes normally, then lock this Classobject, label it fully initialized, notify all waiting threads, release the lock, and

complete this procedure normally.
10. Otherwise, the initializers must have completed abruptly by throwing someexception

E. If the class of E is not Error or one of its subclasses, then createa new instance of the class

ExceptionInInitializerError, with E as theargument, and use this object in place of

E in the following step. But if a newinstance of
ExceptionInInitializerError cannot be created because an
OutOfMemoryError occurs, then instead use an OutOfMemoryError object inplace of

E in the following step.

EXECUTION Creation of New Class Instances 12.5

241DRAFT
11. Lock the Class object, label it erroneous, notify all waiting threads, releasethe lock, and complete this procedure abruptly with reason

E or its replace-ment as determined in the previous step.

(Due to a flaw in some early implementations, a exception during class initial-ization was ignored, rather than causing an

ExceptionInInitializerError asdescribed here.)

12.4.3 Initialization: Implications for Code Generation
Code generators need to preserve the points of possible initialization of a class orinterface, inserting an invocation of the initialization procedure just described. If

this initialization procedure completes normally and the Class object is fully ini-tialized and ready for use, then the invocation of the initialization procedure is no
longer necessary and it may be eliminated from the code--for example, by patch-ing it out or otherwise regenerating the code.

Compile-time analysis may, in some cases, be able to eliminate many of thechecks that a type has been initialized from the generated code, if an initialization
order for a group of related types can be determined. Such analysis must, how-ever, fully account for concurrency and for the fact that initialization code is unrestricted.

12.5   Creation of New Class Instances
A new class instance is explicitly created when evaluation of a class instance cre-ation expression ($15.9) causes a class to be instantiated.

A new class instance may be implicitly created in the following situations:

* Loading of a class or interface that contains a String literal ($3.10.5) maycreate a new

String object to represent that literal. (This might not occur ifthe same
String has previously been interned ($3.10.5).)

* Execution of a string concatenation operator ($15.18.1) that is not part of aconstant expression sometimes creates a new

String object to represent theresult. String concatenation operators may also create temporary wrapper

objects for a value of a primitive type.
Each of these situations identifies a particular constructor to be called with speci-fied arguments (possibly none) as part of the class instance creation process.

Whenever a new class instance is created, memory space is allocated for itwith room for all the instance variables declared in the class type and all the
instance variables declared in each superclass of the class type, including all the

12.5 Creation of New Class Instances EXECUTION
242 DRAFT

instance variables that may be hidden ($8.3). If there is not sufficient space avail-able to allocate memory for the object, then creation of the class instance completes abruptly with an OutOfMemoryError. Otherwise, all the instance variablesin the new object, including those declared in superclasses, are initialized to their
default values ($4.5.5).Just before a reference to the newly created object is returned as the result, the
indicated constructor is processed to initialize the new object using the followingprocedure:

1. Assign the arguments for the constructor to newly created parameter variablesfor this constructor invocation.
2. If this constructor begins with an explicit constructor invocation of anotherconstructor in the same class (using

this), then evaluate the arguments andprocess that constructor invocation recursively using these same five steps. If

that constructor invocation completes abruptly, then this procedure completesabruptly for the same reason; otherwise, continue with step 5.

3. This constructor does not begin with an explicit constructor invocation ofanother constructor in the same class (using

this). If this constructor is for aclass other than
Object, then this constructor will begin with an explicit orimplicit invocation of a superclass constructor (using

super). Evaluate thearguments and process that superclass constructor invocation recursively

using these same five steps. If that constructor invocation completes abruptly,then this procedure completes abruptly for the same reason. Otherwise, continue with step 4.
4. Execute the instance initializers and instance variable initializers for thisclass, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textuallyin the source code for the class. If execution of any of these initializers results
in an exception, then no further initializers are processed and this procedurecompletes abruptly with that same exception. Otherwise, continue with step 5.
(In some early implementations, the compiler incorrectly omitted the code toinitialize a field if the field initializer expression was a constant expression
whose value was equal to the default initialization value for its type.)
5. Execute the rest of the body of this constructor. If that execution completesabruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally.
In the example:
class Point {

int x, y;

EXECUTION Creation of New Class Instances 12.5

243DRAFT
Point() { x = 1; y = 1; }
}

class ColoredPoint extends Point {

int color = 0xFF00FF;
}

class Test {

public static void main(String[] args) {

ColoredPoint cp = new ColoredPoint();
System.out.println(cp.color);
}
}

a new instance of ColoredPoint is created. First, space is allocated for the new
ColoredPoint, to hold the fields x, y, and color. All these fields are then initial-ized to their default values (in this case,

0 for each field). Next, the ColoredPointconstructor with no arguments is first invoked. Since

ColoredPoint declares noconstructors, a default constructor of the form:

ColoredPoint() { super(); }
is provided for it automatically by the Java compiler.This constructor then invokes the

Point constructor with no arguments. The
Point constructor does not begin with an invocation of a constructor, so the com-piler provides an implicit invocation of its superclass constructor of no arguments,

as though it had been written:

Point() { super(); x = 1; y = 1; }
Therefore, the constructor for Object which takes no arguments is invoked.The class

Object has no superclass, so the recursion terminates here. Next,any instance initializers, instance variable initializers of

Object are invoked.Next, the body of the constructor of
Object that takes no arguments is executed.No such constructor is declared in
Object, so the compiler supplies a default one,which in this special case is:

Object() { }
This constructor executes without effect and returns.Next, all initializers for the instance variables of class

Point are executed. Asit happens, the declarations of
x and y do not provide any initialization expres-sions, so no action is required for this step of the example. Then the body of the

Point constructor is executed, setting x to 1 and y to 1.Next, the initializers for the instance variables of class

ColoredPoint areexecuted. This step assigns the value
0xFF00FF to color. Finally, the rest of thebody of the
ColoredPoint constructor is executed (the part after the invocation

12.5 Creation of New Class Instances EXECUTION
244 DRAFT

of super); there happen to be no statements in the rest of the body, so no furtheraction is required and initialization is complete.

Unlike C++, the Java programming language does not specify altered rules formethod dispatch during the creation of a new class instance. If methods are
invoked that are overridden in subclasses in the object being initialized, then theseoverriding methods are used, even before the new object is completely initialized.
Thus, compiling and running the example:

class Super {

Super() { printThree(); }

void printThree() { System.out.println("three"); }
}

class Test extends Super {

int three = (int)Math.PI; // That is, 3

public static void main(String[] args) {

Test t = new Test();
t.printThree();
}

void printThree() { System.out.println(three); }
}
produces the output:

0
3

This shows that the invocation of printThree in the constructor for class Superdoes not invoke the definition of

printThree in class Super, but rather invokesthe overriding definition of
printThree in class Test. This method thereforeruns before the field initializers of

Test have been executed, which is why the firstvalue output is
0, the default value to which the field three of Test is initialized.The later invocation of

printThree in method main invokes the same definitionof
printThree, but by that point the initializer for instance variable three hasbeen executed, and so the value

3 is printed.See $8.8 for more details on constructor declarations.

EXECUTION Finalization of Class Instances 12.6

245DRAFT
12.6 Finalization of Class Instances
The class Object has a protected method called finalize; this method can beoverridden by other classes. The particular definition of

finalize that can beinvoked for an object is called the finalizer of that object. Before the storage for an

object is reclaimed by the garbage collector, the Java virtual machine will invokethe finalizer of that object.

Finalizers provide a chance to free up resources that cannot be freed automat-ically by an automatic storage manager. In such situations, simply reclaiming the
memory used by an object would not guarantee that the resources it held would bereclaimed.

The Java programming language does not specify how soon a finalizer will beinvoked, except to say that it will happen before the storage for the object is
reused. Also, the language does not specify which thread will invoke the finalizerfor any given object. It is guaranteed, however, that the thread that invokes the
finalizer will not be holding any user-visible synchronization locks when the final-izer is invoked. If an uncaught exception is thrown during the finalization, the
exception is ignored and finalization of that object terminates.The

finalize method declared in class Object takes no action.The fact that class

Object declares a finalize method means that the
finalize method for any class can always invoke the finalize method for itssuperclass, which is usually good practice. (Unlike constructors, finalizers do not

automatically invoke the finalizer for the superclass; such an invocation must becoded explicitly.)

For efficiency, an implementation may keep track of classes that do not over-ride the

finalize method of class Object, or override it in a trivial way, such as:

protected void finalize() throws Throwable {

super.finalize();
}

We encourage implementations to treat such objects as having a finalizer thatis not overridden, and to finalize them more efficiently, as described in $12.6.1.

A finalizer may be invoked explicitly, just like any other method.The package

java.lang.ref describes weak references, which interact withgarbage collection and finalization. As with any API that has special interactions

with the language, implementors must be cognizant of any requirements imposedby the

java.lang.ref API. This specification does not discuss weak referencesin any way. Readers are referred to the API documentation for details.

12.6.1 Implementing Finalization EXECUTION

246 DRAFT

12.6.1   Implementing Finalization
Every object can be characterized by two attributes: it may be reachable, finalizer-reachable, or unreachable, and it may also be unfinalized, finalizable, or finalized.

A reachable object is any object that can be accessed in any potential continu-ing computation from any live thread. Optimizing transformations of a program
can be designed that reduce the number of objects that are reachable to be lessthan those which would naively be considered reachable. For example, a compiler
or code generator may choose to set a variable or parameter that will no longer beused to

null to cause the storage for such an object to be potentially reclaimablesooner. A finalizer-reachable object can be reached from some finalizable object

through some chain of references, but not from any live thread. An unreachableobject cannot be reached by either means.

An unfinalized object has never had its finalizer automatically invoked; afinalized object has had its finalizer automatically invoked. A finalizable object
has never had its finalizer automatically invoked, but the Java virtual machine mayeventually automatically invoke its finalizer.

The life cycle of an object obeys the following transition diagram, where weabbreviate "finalizer-reachable" as "f-reachable":

When an object is first created (A), it is reachable and unfinalized.As references to an object are discarded during program execution, an object
that was reachable may become finalizer-reachable (B, C, D) or unreachable (E, F).(Note that a finalizer-reachable object never becomes unreachable directly; it

M
reachable
unfinalized

reachable
finalizable

reachable

finalized

f-reachable

unfinalized

f-reachable

finalizable

f-reachable

finalized

objectcreated

storagereclaimed
unreachable

unfinalized

unreachable

finalized

finalize not overridden

A
E F

B C D

G

H

I

J
L N

O

K

EXECUTION Finalizer Invocations are Not Ordered 12.6.2

247DRAFT
becomes reachable when the finalizer from which it can be reached is invoked, asexplained below.)

If the Java virtual machine detects that an unfinalized object has become final-izer-reachable or unreachable, it may label the object finalizable (

G, H); moreover,if the object was unreachable, it becomes finalizer-reachable (
H).If the Java virtual machine detects that a finalized object has become unreachable, it may reclaim the storage occupied by the object because the object willnever again become reachable (

I).At any time, a Java virtual machine may take any finalizable object, label it

finalized, and then invoke its finalize method in some thread. This causes theobject to become finalized and reachable (

J, K), and it also may cause other objectsthat were finalizer-reachable to become reachable again (

L, M, N).A finalizable object cannot also be unreachable; it can be reached because its

finalizer may eventually be invoked, whereupon the thread running the finalizerwill have access to the object, as

this ($15.8.3). Thus, there are actually onlyeight possible states for an object.

After an object has been finalized, no further action is taken until the auto-matic storage management determines that it is unreachable. Because of the way
that an object progresses from the unfinalized state through the finalizable state tothe finalized state, the

finalize method is never automatically invoked more thanonce by a Java virtual machine for each object, even if the object is again made

reachable after it has been finalized.Explicit invocation of a finalizer ignores the current state of the object and
does not change the state of the object from unfinalized or finalizable to finalized.If a class does not override method

finalize of class Object (or overrides itin only a trivial way, as described above), then if instances of such a class become

unreachable, they may be discarded immediately rather than made to await a sec-ond determination that they have become unreachable. This strategy is indicated
by the dashed arrow (O) in the transition diagram.Therefore, we recommend that the design of

finalize methods be kept sim-ple and that they be programmed defensively, so that they will work in all cases.

12.6.2 Finalizer Invocations are Not Ordered
The Java programming language imposes no ordering on finalize method calls.Finalizers may be called in any order, or even concurrently.

As an example, if a circularly linked group of unfinalized objects becomesunreachable (or finalizer-reachable), then all the objects may become finalizable
together. Eventually, the finalizers for these objects may be invoked, in any order,or even concurrently using multiple threads. If the automatic storage manager
later finds that the objects are unreachable, then their storage can be reclaimed.

12.7 Unloading of Classes and Interfaces EXECUTION
248 DRAFT

It is straightforward to implement a class that will cause a set of finalizer-likemethods to be invoked in a specified order for a set of objects when all the objects
become unreachable. Defining such a class is left as an exercise for the reader.

12.7   Unloading of Classes and Interfaces
An implementation of the Java programming language may unload classes. Aclass or interface may be unloaded if and only if its defining class loader may be
reclaimed by the garbage collector as discussed in $12.6. Classes and interfacesloaded by the bootstrap loader may not be unloaded.

Here is the rationale for the rule given in the previous paragraph:Class unloading is an optimization that helps reduce memory use. Obviously,
the semantics of a program should not depend on whether and how a systemchooses to implement an optimization such as class unloading. To do otherwise
would compromise the portability of programs. Consequently, whether a class orinterface has been unloaded or not should be transparent to a program.

However, if a class or interface C was unloaded while its defining loader waspotentially reachable, then

C might be reloaded. One could never ensure that thiswould not happen. Even if the class was not referenced by any other currently

loaded class, it might be referenced by some class or interface, D, that had not yetbeen loaded. When

D is loaded by C's defining loader, its execution might causereloading of
C.Reloading may not be transparent if, for example, the class has:

* Static variables (whose state would be lost).

* Static initializers (which may have side effects).

* Native methods (which may retain static state).

Furthermore the hash value of the Class object is dependent on its identity.Therefore it is, in general, impossible to reload a class or interface in a completely
transparent manner.Since we can never guarantee that unloading a class or interface whose loader
is potentially reachable will not cause reloading, and reloading is never transpar-ent, but unloading must be transparent, it follows that one must not unload a class
or interface while its loader is potentially reachable. A similar line of reasoningcan be used to deduce that classes and interfaces loaded by the bootstrap loader
can never be unloaded.One must also argue why it is safe to unload a class

C if its defining classloader can be reclaimed. If the defining loader can be reclaimed, then there can

never be any live references to it (this includes references that are not live, but

EXECUTION Program Exit 12.8

249DRAFT
might be resurrected by finalizers). This, in turn, can only be true if there are cannever be any live references to any of the classes defined by that loader, including
C, either from their instances or from code.Class unloading is an optimization that is only significant for applications that
load large numbers of classes and that stop using most of those classes after sometime. A prime example of such an application is a web browser, but there are others. A characteristic of such applications is that they manage classes throughexplicit use of class loaders. As a result, the policy outlined above works well for
them.Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization. How-ever, the issue is very subtle, and so it is mentioned here by way of clarification.

12.8 Program Exit
A program terminates all its activity and exits when one of two things happens:

* All the threads that are not daemon threads terminate.

* Some thread invokes the exit method of class Runtime or class System andthe exit operation is not forbidden by the security manager.

.

251DRAFT

C H A P T E R 13
Binary Compatibility

Development tools for the Java programming language should support auto-matic recompilation as necessary whenever source code is available. Particular
implementations may also store the source and binary of types in a versioningdatabase and implement a

ClassLoader that uses integrity mechanisms of thedatabase to prevent linkage errors by providing binary-compatible versions of

types to clients.Developers of packages and classes that are to be widely distributed face a
different set of problems. In the Internet, which is our favorite example of awidely distributed system, it is often impractical or impossible to automatically
recompile the pre-existing binaries that directly or indirectly depend on a type thatis to be changed. Instead, this specification defines a set of changes that developers are permitted to make to a package or to a class or interface type while pre-serving (not breaking) compatibility with existing binaries.

The paper quoted above appears in Proceedings of OOPSLA '95, published asACM SIGPLAN Notices, Volume 30, Number 10, October 1995, pages 426-438.
Within the framework of that paper, Java programming language binaries arebinary compatible under all relevant transformations that the authors identify
(with some caveats with respect to the addition of instance variables). Using theirscheme, here is a list of some important binary compatible changes that the Java
programming language supports:

* Reimplementing existing methods, constructors, and initializers to improveperformance.

* Changing methods or constructors to return values on inputs for which theypreviously either threw exceptions that normally should not occur or failed by

going into an infinite loop or causing a deadlock.

* Adding new fields, methods, or constructors to an existing class or interface.

13.1 The Form of a Binary BINARY COMPATIBILITY
252 DRAFT

* Deleting private fields, methods, or constructors of a class.

* When an entire package is updated, deleting default (package-only) accessfields, methods, or constructors of classes and interfaces in the package.

* Reordering the fields, methods, or constructors in an existing type declaration.

* Moving a method upward in the class hierarchy.

* Reordering the list of direct superinterfaces of a class or interface.

* Inserting new class or interface types in the type hierarchy.

This chapter specifies minimum standards for binary compatibility guaranteedby all implementations. The Java programming language guarantees compatibility

when binaries of classes and interfaces are mixed that are not known to be fromcompatible sources, but whose sources have been modified in the compatible
ways described here. Note that we are discussing compatibility between releasesof an application. A discussion of compatibility among releases of the Java platform beyond the scope of this chapter.We encourage development systems to provide facilities that alert developers
to the impact of changes on pre-existing binaries that cannot be recompiled.This chapter first specifies some properties that any binary format for the Java
programming language must have ($13.1). It next defines binary compatibility,explaining what it is and what it is not ($13.2). It finally enumerates a large set of
possible changes to packages ($13.3), classes ($13.4) and interfaces ($13.5), spec-ifying which of these changes are guaranteed to preserve binary compatibility and
which are not.

13.1   The Form of a Binary
Programs must be compiled either into the class file format specified by the TheJava

(TM) Virtual Machine Specification, Second Edition, or into a representation that

can be mapped into that format by a class loader written in the Java programminglanguage. Furthermore, the resulting

class file must have certain properties. Anumber of these properties are specifically chosen to support source code transformations that preserve binary compatibility.The required properties are:

* The class or interface must be named by its binary name, which must meet thefollowing constraints:

u The binary name of a top-level type is its canonical name ($6.7).

BINARY COMPATIBILITY The Form of a Binary 13.1

253DRAFT
u The binary name of a member type consists of the binary name of its imme-diately enclosing type, followed by $ followed by the simple name of the

member.
u The binary name of any nested type must have, as a prefix, the binary nameof its enclosing top-level class.

* A reference to another class or interface type must be symbolic, using thebinary name of the type.

* Given a legal expression denoting a field access in a class C, referencing afield named

f declared in a (possibly distinct) class or interface D, we definethe qualifying type of the field reference as follows:

u If the expression is of the form Primary.f then the compile-time type of Pri-mary is the qualifying type of the reference.
u If the expression is of the form super.f then the superclass of C is the qual-ifying type of the reference.
u If the expression is of the form X.super.f then the superclass of X is thequalifying type of the reference.
u If the reference is of the form X.f, where X denotes a class or interface, thenthe class or interface denoted by

X is the qualifying type of the reference

u If the expression is referenced by a simple name, then if f is a member ofthe current class or interface,

C, then let T be C. Otherwise, let T be theinnermost lexically enclosing class of which

f is a member. T is the quali-fying type of the reference.

The reference to f must be compiled into a symbolic reference to the qualify-ing type of the reference, plus the simple name of the field,

f. The referencemust also include a symbolic reference to the declared type of the field so that

the verifier can check that the type is as expected. References to fields that are
final and initialized with compile-time constant expressions are resolved atcompile time to the constant value that is denoted. No reference to such a constant field should be present in the code in a binary file (except in the class orinterface containing the constant field, which will have code to initialize it),
and such constant fields must always appear to have been initialized; thedefault initial value for the type of such a field must never be observed. See

$13.4.8 for a discussion.

* Given a method invocation expression in a class or interface C referencing amethod named

m declared in a (possibly distinct) class or interface D, wedefine the qualifying type of the method invocation as follows:

13.1 The Form of a Binary BINARY COMPATIBILITY
254 DRAFT

If D is Object then the qualifying type of the expression is Object. Other-wise:
u If the expression is of the form Primary.m then the compile-time type ofPrimary is the qualifying type of the method invocation.
u If the expression is of the form super.m then the superclass of C is the qual-ifying type of the method invocation.
u If the expression is of the form X.super.m then the superclass of X is thequalifying type of the method invocation.
u If the reference is of the form X.m, where X denotes a class or interface, thenthe class or interface denoted by

X is the qualifying type of the method invo-cation

u If the method is referenced by a simple name, then if m is a member of thecurrent class or interface,

C, let T be C. Otherwise, let T be the innermostlexically enclosing class of which

m is a member. T is the qualifying type ofthe method invocation.

A reference to a method must be resolved at compile time to a symbolic refer-ence to the qualifying type of the invocation, plus the signature of the method
($8.4.2). A reference to a method must also include either a symbolic refer-ence to the return type of the denoted method or an indication that the denoted
method is declared void and does not return a value. The signature of amethod must include all of the following:

u The simple name of the method
u The number of parameters to the method
u A symbolic reference to the type of each parameter

* Given a class instance creation expression ($15.9) or a constructor invocationstatement ($8.8.5.1) in a class or interface

C referencing a constructor mdeclared in a (possibly distinct) class or interface

D, we define the qualifyingtype of the constructor invocation as follows:

u If the expression is of the form new D(...) or X.new D(...), then the qualifyingtype of the invocation is

D.

u If the expression is of the form new D(..){...} or X.new D(...){...}, then thequalifying type of the expression is the compile-time type of the expression.

u If the expression is of the form super(...) or Primary.super(...) then thequalifying type of the expression is the direct superclass of

C.

BINARY COMPATIBILITY The Form of a Binary 13.1

255DRAFT
u If the expression is of the form this(...), then the qualifying type of theexpression is

C.

A reference to a constructor must be resolved at compile time to a symbolicreference to the qualifying type of the invocation, plus the signature of the
constructor ($8.8.2). The signature of a constructor must include both:
u The number of parameters to the constructor
u A symbolic reference to the type of each parameter

In addition the constructor of a non-private inner member class must be com-piled such that it has as its first parameter, an additional implicit parameter
representing the immediately enclosing instance ($8.1.2).

* Any constructs introduced by the compiler that do not have a correspondingconstruct in the a source code must be marked as synthetic, except for default

constructors and the class initialization method.
A binary representation for a class or interface must also contain all of the follow-ing:

* If it is a class and is not class Object, then a symbolic reference to the directsuperclass of this class

* A symbolic reference to each direct superinterface, if any

* A specification of each field declared in the class or interface, given as thesimple name of the field and a symbolic reference to the type of the field

* If it is a class, then the signature of each constructor, as described above

* For each method declared in the class or interface, its signature and returntype, as described above

* The code needed to implement the class or interface:

u For an interface, code for the field initializers
u For a class, code for the field initializers, the instance and static initializers,and the implementation of each method or constructor

* Every type must contain sufficient information to recover its canonical name($6.7).

* Every member type must have sufficient information to recover its sourcelevel access modifier.

13.2 What Binary Compatibility Is and Is Not BINARY COMPATIBILITY

256 DRAFT

* Every nested class must have a symbolic reference to its immediately enclos-ing class.

* Every class that contains a nested class must contain symbolic references toall of its member classes, and to all local and anonymous classes that appear

in its methods, constructors and static or instance initializers.
The following sections discuss changes that may be made to class and inter-face type declarations without breaking compatibility with pre-existing binaries.

Under the translation requirements given above, the Java virtual machine and its
class file format support these changes. Any other valid binary format, such as acompressed or encrypted representation that is mapped back into class files by a

class loader under the above requirements will necessarily support these changesas well.

13.2   What Binary Compatibility Is and Is Not
A change to a type is binary compatible with (equivalently, does not break binarycompatibility with) preexisting binaries if preexisting binaries that previously
linked without error will continue to link without error.Binaries are compiled to rely on the accessible members and constructors of
other classes and interfaces. To preserve binary compatibility, a class or interfaceshould treat its accessible members and constructors, their existence and behavior,
as a contract with its users.The Java programming language is designed to prevent additions to contracts
and accidental name collisions from breaking binary compatibility; specifically:

* Addition of more methods overloading a particular method name does notbreak compatibility with preexisting binaries. The method signature that the

preexisting binary will use for method lookup is chosen by the method over-load resolution algorithm at compile time ($15.12.2). (If the language had
been designed so that the particular method to be executed was chosen at runtime, then such an ambiguity might be detected at run time. Such a rule would
imply that adding an additional overloaded method so as to make ambiguitypossible at a call site could break compatibility with an unknown number of
preexisting binaries. See $13.4.21 for more discussion.)
Binary compatibility is not the same as source compatibility. In particular, theexample in $13.4.5 shows that a set of compatible binaries can be produced from

sources that will not compile all together. This example is typical: a new declara-tion is added, changing the meaning of a name in an unchanged part of the source
code, while the preexisting binary for that unchanged part of the source code

BINARY COMPATIBILITY final Classes 13.4.2

257DRAFT
retains the fully-qualified, previous meaning of the name. Producing a consistentset of source code requires providing a qualified name or field access expression
corresponding to the previous meaning.

13.3   Evolution of Packages
A new top-level class or interface type may be added to a package without break-ing compatibility with pre-existing binaries, provided the new type does not reuse
a name previously given to an unrelated type. If a new type reuses a name previ-ously given to an unrelated type, then a conflict may result, since binaries for both
types could not be loaded by the same class loader.Changes in top-level class and interface types that are not

public and that arenot a superclass or superinterface, respectively, of a
public type, affect only typeswithin the package in which they are declared. Such types may be deleted or otherwise changed, even if incompatibilities are otherwise described here, providedthat the affected binaries of that package are updated together.

13.4   Evolution of Classes
This section describes the effects of changes to the declaration of a class and itsmembers and constructors on pre-existing binaries.

13.4.1 abstract Classes
If a class that was not abstract is changed to be declared abstract, then pre-existing binaries that attempt to create new instances of that class will throw either

an InstantiationError at link time, or (if a reflective method is used) an
InstantiationException at run time; such a change is therefore not recom-mended for widely distributed classes.

Changing a class that was declared abstract to no longer be declared
abstract does not break compatibility with pre-existing binaries.

13.4.2 final Classes
If a class that was not declared final is changed to be declared final, then a
VerifyError is thrown if a binary of a pre-existing subclass of this class isloaded, because

final classes can have no subclasses; such a change is not rec-ommended for widely distributed classes.

13.4.3 public Classes BINARY COMPATIBILITY
258 DRAFT

Changing a class that was declared final to no longer be declared finaldoes not break compatibility with pre-existing binaries.
13.4.3 public Classes
Changing a class that was not declared public to be declared public does notbreak compatibility with pre-existing binaries.

If a class that was declared public is changed to not be declared public,then an

IllegalAccessError is thrown if a pre-existing binary is linked thatneeds but no longer has access to the class type; such a change is not recommended for widely distributed classes.

13.4.4   Superclasses and Superinterfaces
A ClassCircularityError is thrown at load time if a class would be a super-class of itself. Changes to the class hierarchy that could result in such a circularity

when newly compiled binaries are loaded with pre-existing binaries are not rec-ommended for widely distributed classes.

Changing the direct superclass or the set of direct superinterfaces of a classtype will not break compatibility with pre-existing binaries, provided that the total
set of superclasses or superinterfaces, respectively, of the class type loses nomembers.

If a change to the direct superclass or the set of direct superinterfaces resultsin any class or interface no longer being a superclass or superinterface, respectively, then link-time errors may result if pre-existing binaries are loaded with thebinary of the modified class. Such changes are not recommended for widely distributed classes.For example, suppose that the following test program:

class Hyper { char h = 'h'; }
class Super extends Hyper { char s = 's'; }
class Test extends Super {
    public static void main(String[] args) {
        Hyper h = new Super();
        System.out.println(h.h);
    }
}

is compiled and executed, producing the output:

h
Suppose that a new version of class Super is then compiled:

BINARY COMPATIBILITY Class Body and Member Declarations 13.4.5

259DRAFT
class Super { char s = 's'; }
This version of class Super is not a subclass of Hyper. If we then run the existingbinaries of

Hyper and Test with the new version of Super, then a VerifyErroris thrown at link time. The verifier objects because the result of

new Super()cannot be assigned to a variable of type
Hyper, because Super is not a subclass of
Hyper.It is instructive to consider what might happen without the verification step:

the program might run and print:

s
This demonstrates that without the verifier the type system could be defeated bylinking inconsistent binary files, even though each was produced by a correct Java

compiler.The lesson is that an implementation that lacks a verifier or fails to use it will
not maintain type safety and is, therefore, not a valid implementation.

13.4.5 Class Body and Member Declarations
No incompatibility with pre-existing binaries is caused by adding an instance(respectively

static) member that has the same name, accessibility, (for fields)or same name, accessibility, signature, and return type (for methods) as an

instance (respectively static) member of a superclass or subclass. No erroroccurs even if the set of classes being linked would encounter a compile-time
error.Deleting a class member or constructor that is not declared

private maycause a linkage error if the member or constructor is used by a pre-existing binary.

If the program:
class Hyper {

void hello() { System.out.println("hello from Hyper"); }
}

class Super extends Hyper {

void hello() { System.out.println("hello from Super"); }
}

class Test {

public static void main(String[] args) {

new Super().hello();
}
}

is compiled and executed, it produces the output:

hello from Super

13.4.5 Class Body and Member Declarations BINARY COMPATIBILITY
260 DRAFT

Suppose that a new version of class Super is produced:

class Super extends Hyper { }
then recompiling Super and executing this new binary with the original binariesfor

Test and Hyper produces the output:

hello from Hyper
as expected.The

super keyword can be used to access a method declared in a superclass,bypassing any methods declared in the current class. The expression:

super.Identifier
is resolved, at compile time, to a method M in the superclass S. If the method M isan instance method, then the method

MR invoked at run time is the method withthe same signature as
M that is a member of the direct superclass of the class con-taining the expression involving

super. Thus, if the program:

class Hyper {

void hello() { System.out.println("hello from Hyper"); }
}

class Super extends Hyper { }
class Test extends Super {

public static void main(String[] args) {

new Test().hello();
}

void hello() {

super.hello();
}

}
is compiled and executed, it produces the output:

hello from Hyper
Suppose that a new version of class Super is produced:

class Super extends Hyper {

void hello() { System.out.println("hello from Super"); }
}

If Super and Hyper are recompiled but not Test, then running the new binarieswith the existing binary of

Test produces the output:

hello from Super
as you might expect. (A flaw in some early implementations caused them to print:

hello from Hyper

BINARY COMPATIBILITY Access to Members and Constructors 13.4.6

261DRAFT
incorrectly.)
13.4.6 Access to Members and Constructors
Changing the declared access of a member or constructor to permit less accessmay break compatibility with pre-existing binaries, causing a linkage error to be

thrown when these binaries are resolved. Less access is permitted if the accessmodifier is changed from default access to

private access; from protectedaccess to default or
private access; or from public access to protected,default, or
private access. Changing a member or constructor to permit lessaccess is therefore not recommended for widely distributed classes.

Perhaps surprisingly, the binary format is defined so that changing a memberor constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access.So, for example, if the package

points defines the class Point:

package points;
public class Point {

public int x, y;
protected void print() {

System.out.println("(" + x + "," + y + ")");
}
}

used by the Test program:

class Test extends points.Point {

protected void print() { System.out.println("Test"); }

public static void main(String[] args) {

Test t = new Test();
t.print();
}

}

then these classes compile and Test executes to produce the output:

Test
If the method print in class Point is changed to be public, and then only the
Point class is recompiled, and then executed with the previously existing binaryfor

Test then no linkage error occurs, even though it is improper, at compile time,for a

public method to be overridden by a protected method (as shown by thefact that the class

Test could not be recompiled using this new Point class unlessprint were changed to be

public.)

13.4.7 Field Declarations BINARY COMPATIBILITY
262 DRAFT

Allowing superclasses to change protected methods to be public withoutbreaking binaries of preexisting subclasses helps make binaries less fragile. The
alternative, where such a change would cause a linkage error, would create addi-tional binary incompatibilities.

13.4.7 Field Declarations
Widely distributed programs should not expose any fields to their clients. Apartfrom the binary compatibility issues discussed below, this is generally good software engineering practice. Adding a field to a class may break compatibility withpre-existing binaries that are not recompiled.

Assume a reference to a field f with qualifying type T. Assume further that fis in fact an instance (respectively

static) field declared in a superclass of T, S,and that the type of
f is X. If a new field of type X with the same name as f isadded to a subclass of

S that is a superclass of T or T itself, then a linkage errormay occur. Such a linkage error will occur only if, in addition to the above, either

one of the following conditions hold:

* The new field is less accessible than the old one.

* The new field is a static (respectively instance) field.

In particular, no linkage error will occur in the case where a class could nolonger be recompiled because a field access previously referenced a field of a

superclass with an incompatible type. The previously compiled class with such areference will continue to reference the field declared in a superclass.

Thus compiling and executing the code:
class Hyper { String h = "hyper"; }
class Super extends Hyper { String s = "super"; }
class Test {

public static void main(String[] args) {

System.out.println(new Super().h);
}
}

produces the output:

hyper
Changing Super to be defined as:

class Super extends Hyper {

String s = "super";
int h = 0;
}

BINARY COMPATIBILITY Field Declarations 13.4.7

263DRAFT
recompiling Hyper and Super, and executing the resulting new binaries with theold binary of

Test produces the output:

hyper
The field h of Hyper is output by the original binary of main. While this mayseem surprising at first, it serves to reduce the number of incompatibilities that

occur at run time. (In an ideal world, all source files that needed recompilationwould be recompiled whenever any one of them changed, eliminating such surprises. But such a mass recompilation is often impractical or impossible, espe-cially in the Internet. And, as was previously noted, such recompilation would
sometimes require further changes to the source code.)As an example, if the program:

class Hyper { String h = "Hyper"; }
class Super extends Hyper { }
class Test extends Super {

public static void main(String[] args) {

String s = new Test().h;
System.out.println(s);
}
}

is compiled and executed, it produces the output:

Hyper
Suppose that a new version of class Super is then compiled:

class Super extends Hyper { char h = 'h'; }
If the resulting binary is used with the existing binaries for Hyper and Test, thenthe output is still:

Hyper
even though compiling the source for these binaries:

class Hyper { String h = "Hyper"; }
class Super extends Hyper { char h = 'h'; }
class Test extends Super {

public static void main(String[] args) {

String s = new Test().h;
System.out.println(s);
}
}

13.4.8 final Fields and Constants BINARY COMPATIBILITY
264 DRAFT

would result in a compile-time error, because the h in the source code for mainwould now be construed as referring to the

char field declared in Super, and a
char value can't be assigned to a String.Deleting a field from a class will break compatibility with any pre-existing

binaries that reference this field, and a NoSuchFieldError will be thrown whensuch a reference from a pre-existing binary is linked. Only

private fields may besafely deleted from a widely distributed class.

13.4.8 final Fields and Constants
If a field that was not final is changed to be final, then it can break compatibil-ity with pre-existing binaries that attempt to assign new values to the field.

For example, if the program:
class Super { static char s; }
class Test extends Super {

public static void main(String[] args) {

s = 'a';
System.out.println(s);
}
}

is compiled and executed, it produces the output:

a
Suppose that a new version of class Super is produced:

class Super { final static char s = 'b'; }
If Super is recompiled but not Test, then running the new binary with the exist-ing binary of

Test results in a IllegalAccessError.Deleting the keyword

final or changing the value to which a field is initial-ized does not break compatibility with existing binaries.

If a field is a compile-time constant, then deleting the keyword final orchanging its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for the constant unlessthey are recompiled.

If the example:
class Flags { final static boolean debug = true; }
class Test {

public static void main(String[] args) {

if (Flags.debug)

System.out.println("debug is true");

BINARY COMPATIBILITY final Fields and Constants 13.4.8

265DRAFT
}
}

is compiled and executed, it produces the output:

debug is true
Suppose that a new version of class Flags is produced:

class Flags { final static boolean debug = false; }
If Flags is recompiled but not Test, then running the new binary with the exist-ing binary of

Test produces the output:

debug is true
because the value of debug was a compile-time constant, and could have beenused in compiling

Test without making a reference to the class Flags.This result is a side-effect of the decision to support conditional compilation,

as discussed at the end of $14.20.This behavior would not change if

Flags were changed to be an interface, asin the modified example:

interface Flags { boolean debug = true; }
class Test {

public static void main(String[] args) {

if (Flags.debug)

System.out.println("debug is true");
}
}

(One reason for requiring inlining of constants is that switch statements requireconstants on each

case, and no two such constant values may be the same. Thecompiler checks for duplicate constant values in a

switch statement at compiletime; the
class file format does not do symbolic linkage of case values.)The best way to avoid problems with "inconstant constants" in widely-distributed code is to declare as compile time constants only values which truly areunlikely ever to change. Many compile time constants in interfaces are small integer values replacing enumerated types, which the language does not support;these small values can be chosen arbitrarily, and should not need to be changed.
Other than for true mathematical constants, we recommend that source code makevery sparing use of class variables that are declared

static and final. If theread-only nature of
final is required, a better choice is to declare a private
static variable and a suitable accessor method to get its value. Thus we recom-mend:

private static int N;

13.4.9 static Fields BINARY COMPATIBILITY
266 DRAFT

public static int getN() { return N; }
rather than:

public static final int N = ...;
There is no problem with:

public static int N = ...;
if N need not be read-only. We also recommend, as a general rule, that only trulyconstant values be declared in interfaces. We note, but do not recommend, that if a

field of primitive type of an interface may change, its value may be expressed idi-omatically as in:

interface Flags {

boolean debug = new Boolean(true).booleanValue();
}

insuring that this value is not a constant. Similar idioms exist for the other primi-tive types.

One other thing to note is that static final fields that have constant values(whether of primitive or

String type) must never appear to have the default initialvalue for their type ($4.5.5). This means that all such fields appear to be initialized

first during class initialization ($8.3.2.1, $9.3.1, $12.4.2).

13.4.9 static Fields
If a field that is not declared private was not declared static and is changed tobe declared

static, or vice versa, then a linkage time error, specifically an
IncompatibleClassChangeError, will result if the field is used by a preexistingbinary which expected a field of the other kind. Such changes are not recommended in code that has been widely distributed.

13.4.10 transient Fields
Adding or deleting a transient modifier of a field does not break compatibilitywith pre-existing binaries.

13.4.11   Method and Constructor Declarations
Adding a method or constructor declaration to a class will not break compatibilitywith any pre-existing binaries, in the case where a type could no longer be recompiled because an invocation previously referenced a method or constructor of asuperclass with an incompatible type. The previously compiled class with such a

BINARY COMPATIBILITY Method Result Type 13.4.13

267DRAFT
reference will continue to reference the method or constructor declared in a super-class.

Assume a reference to a method m with qualifying type T. Assume further that
m is in fact an instance (respectively static) method declared in a superclass of T,
S. If a new method of type X with the same signature and return type as m is addedto a subclass of

S that is a superclass of T or T itself, then a linkage error mayoccur. Such a linkage error will occur only if, in addition to the above, either one

of the following conditions hold:

* The new method is less accessible than the old one.

* The new method is a static (respectively instance) method.

Deleting a method or constructor from a class may break compatibility withany pre-existing binary that referenced this method or constructor; a

NoSuchMethodError may be thrown when such a reference from a pre-existing binary islinked. Such an error will occur only if no method with a matching signature and

return type is declared in a superclass.If the source code for a class contains no declared constructors, the Java compiler automatically supplies a constructor with no parameters. Adding one or moreconstructor declarations to the source code of such a class will prevent this default
constructor from being supplied automatically, effectively deleting a constructor,unless one of the new constructors also has no parameters, thus replacing the
default constructor. The automatically supplied constructor with no parameters isgiven the same access modifier as the class of its declaration, so any replacement
should have as much or more access if compatibility with pre-existing binaries isto be preserved.

13.4.12   Method and Constructor Parameters
Changing the name of a formal parameter of a method or constructor does notimpact pre-existing binaries. Changing the name of a method, the type of a formal

parameter to a method or constructor, or adding a parameter to or deleting aparameter from a method or constructor declaration creates a method or constructor with a new signature, and has the combined effect of deleting the method orconstructor with the old signature and adding a method or constructor with the
new signature (see $13.4.11).

13.4.13   Method Result Type
Changing the result type of a method, replacing a result type with void, or replac-ing

void with a result type has the combined effect of deleting the old method and

13.4.14 abstract Methods BINARY COMPATIBILITY
268 DRAFT

adding a new method with the new result type or newly void result (see$13.4.11).
13.4.14 abstract Methods
Changing a method that is declared abstract to no longer be declared abstractdoes not break compatibility with pre-existing binaries.

Changing a method that is not declared abstract to be declared abstractwill break compatibility with pre-existing binaries that previously invoked the
method, causing an AbstractMethodError.If the example program:

class Super { void out() { System.out.println("Out"); } }
class Test extends Super {

public static void main(String[] args) {

Test t = new Test();
System.out.println("Way ");
t.out();
}
}

is compiled and executed, it produces the output:

Way
Out

Suppose that a new version of class Super is produced:

abstract class Super {

abstract void out();
}

If Super is recompiled but not Test, then running the new binary with the exist-ing binary of

Test results in a AbstractMethodError, because class Test has noimplementation of the method

out, and is therefore is (or should be) abstract.

13.4.15 final Methods
Changing an instance method that is not final to be final may break compati-bility with existing binaries that depend on the ability to override the method.

If the test program:
class Super { void out() { System.out.println("out"); } }
class Test extends Super {

public static void main(String[] args) {

Test t = new Test();

BINARY COMPATIBILITY static Methods 13.4.17

269DRAFT
t.out();
}

void out() { super.out(); }
}
is compiled and executed, it produces the output:

out
Suppose that a new version of class Super is produced:

class Super { final void out() { System.out.println("!"); } }
If Super is recompiled but not Test, then running the new binary with the exist-ing binary of

Test results in a VerifyError because the class Test improperlytries to override the instance method

out.Changing a class (
static) method that is not final to be final does notbreak compatibility with existing binaries, because the method could not have

been overridden.Removing the

final modifier from a method does not break compatibilitywith pre-existing binaries.

13.4.16 native Methods
Adding or deleting a native modifier of a method does not break compatibilitywith pre-existing binaries.

The impact of changes to types on preexisting native methods that are notrecompiled is beyond the scope of this specification and should be provided with
the description of an implementation. Implementations are encouraged, but notrequired, to implement

native methods in a way that limits such impact.

13.4.17 static Methods
If a method that is not declared private was declared static (that is, a classmethod) and is changed to not be declared

static (that is, to an instance method),or vice versa, then compatibility with pre-existing binaries may be broken, resulting in a linkage time error, namely an IncompatibleClassChangeError, if thesemethods are used by the pre-existing binaries. Such changes are not recommended
in code that has been widely distributed.

13.4.18 synchronized Methods BINARY COMPATIBILITY

270 DRAFT

13.4.18 synchronized Methods
Adding or deleting a synchronized modifier of a method does not break compat-ibility with existing binaries.

13.4.19   Method and Constructor Throws
Changes to the throws clause of methods or constructors do not break compati-bility with existing binaries; these clauses are checked only at compile time.

13.4.20 Method and Constructor Body
Changes to the body of a method or constructor do not break compatibility withpre-existing binaries.

We note that a compiler cannot expand a method inline at compile time.The keyword

final on a method does not mean that the method can be safelyinlined; it means only that the method cannot be overridden. It is still possible that

a new version of that method will be provided at link time. Furthermore, the struc-ture of the original program must be preserved for purposes of reflection.

In general we suggest that implementations use late-bound (run-time) codegeneration and optimization.

13.4.21   Method and Constructor Overloading
Adding new methods or constructors that overload existing methods or construc-tors does not break compatibility with pre-existing binaries. The signature to be

used for each invocation was determined when these existing binaries were com-piled; therefore newly added methods or constructors will not be used, even if
their signatures are both applicable and more specific than the signature originallychosen.

While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no
method or constructor that is most specific ($15.12.2.2), no such error occurswhen a program is executed, because no overload resolution is done at execution
time.If the example program:

class Super {

static void out(float f) { System.out.println("float"); }
}

BINARY COMPATIBILITY Evolution of Interfaces 13.5

271DRAFT
class Test {

public static void main(String[] args) {

Super.out(2);
}
}

is compiled and executed, it produces the output:

float
Suppose that a new version of class Super is produced:

class Super {

static void out(float f) { System.out.println("float"); }
static void out(int i) { System.out.println("int"); }
}

If Super is recompiled but not Test, then running the new binary with the exist-ing binary of

Test still produces the output:

float
However, if Test is then recompiled, using this new Super, the output is then:

int
as might have been naively expected in the previous case.

13.4.22 Method Overriding
If an instance method is added to a subclass and it overrides a method in a super-class, then the subclass method will be found by method invocations in pre-existing binaries, and these binaries are not impacted. If a class method is added to aclass, then this method will not be found unless the qualifying type of the reference is the subclass type.

13.4.23 Static Initializers
Adding, deleting, or changing a static initializer ($8.7) of a class does not impactpre-existing binaries.

13.5   Evolution of Interfaces
This section describes the impact of changes to the declaration of an interface andits members on pre-existing binaries.

13.5.1 public Interfaces BINARY COMPATIBILITY

272 DRAFT

13.5.1 public Interfaces
Changing an interface that is not declared public to be declared public does notbreak compatibility with pre-existing binaries.

If an interface that is declared public is changed to not be declared public,then an

IllegalAccessError is thrown if a pre-existing binary is linked thatneeds but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.

13.5.2   Superinterfaces
Changes to the interface hierarchy cause errors in the same way that changes tothe class hierarchy do, as described in $13.4.4. In particular, changes that result in

any previous superinterface of a class no longer being a superinterface can breakcompatibility with pre-existing binaries, resulting in a

VerifyError.

13.5.3   The Interface Members
Adding a method to an interface does not break compatibility with pre-existingbinaries. A field added to a superinterface of

C may hide a field inherited from asuperclass of
C. If the original reference was to an instance field, an IncompatibleClassChangeError will result. If the original reference was an assignment,an

IllegalAccessError will result.Deleting a member from an interface may cause linkage errors in pre-existing

binaries.If the example program:

interface I { void hello(); }
class Test implements I {

public static void main(String[] args) {

I anI = new Test();
anI.hello();
}

public void hello() { System.out.println("hello"); }
}
is compiled and executed, it produces the output:

hello
Suppose that a new version of interface I is compiled:

interface I { }

BINARY COMPATIBILITY Abstract Method Declarations 13.5.5

273DRAFT
If I is recompiled but not Test, then running the new binary with the existingbinary for

Test will result in a NoSuchMethodError. (In some early implementa-tions this program still executed; the fact that the method

hello no longer existsin interface
I was not correctly detected.)

13.5.4 Field Declarations
The considerations for changing field declarations in interfaces are the same asthose for

static final fields in classes, as described in $13.4.7 and $13.4.8.

13.5.5   Abstract Method Declarations
The considerations for changing abstract method declarations in interfaces are thesame as those for

abstract methods in classes, as described in $13.4.12,$13.4.13, $13.4.19, and $13.4.21.

275DRAFT

C H A P T E R 14
Blocks and Statements

THE sequence of execution of a program is controlled by statements, which areexecuted for their effect and do not have values.

Some statements contain other statements as part of their structure; such otherstatements are substatements of the statement. We say that statement

Simmediately contains statement
U if there is no statement T different from S and Usuch that
S contains T and T contains U. In the same manner, some statementscontain expressions ($15) as part of their structure.

The first section of this chapter discusses the distinction between normal andabrupt completion of statements ($14.1). Most of the remaining sections explain
the various kinds of statements, describing in detail both their normal behaviorand any special treatment of abrupt completion.

Blocks are explained first ($14.2), followed by local class declarations ($14.3)and local variable declaration statements ($14.4).
Next a grammatical maneuver that sidesteps the familiar "dangling else"problem ($14.5) is explained.
Statements that will be familiar to C and C++ programmers are the empty($14.6), labeled ($14.7), expression ($14.8),

if ($14.9), switch ($14.10), while($14.11),
do ($14.12), for ($14.13), break ($14.14), continue ($14.15), and
return ($14.16) statements.Unlike C and C++, the Java programming language has no

goto statement.However, the
break and continue statements are allowed to mention statementlabels.

The Java programming language statements that are not in the C language arethe
throw ($14.17), synchronized ($14.18), and try ($14.19) statements.The last section ($14.20) of this chapter addresses the requirement that every

statement be reachable in a certain technical sense.

14.1   Normal and Abrupt Completion of Statements

14.1 Normal and Abrupt Completion of Statements BLOCKS AND STATEMENTS

276 DRAFT

Every statement has a normal mode of execution in which certain computationalsteps are carried out. The following sections describe the normal mode of execution for each kind of statement.If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally. However, certain events mayprevent a statement from completing normally:

* The break ($14.14), continue ($14.15), and return ($14.16) statementscause a transfer of control that may prevent normal completion of statements

that contain them.

* Evaluation of certain expressions may throw exceptions from the Java virtualmachine; these expressions are summarized in $15.6. An explicit

throw($14.17) statement also results in an exception. An exception causes a transfer

of control that may prevent normal completion of statements.
If such an event occurs, then execution of one or more statements may be ter-minated before all steps of their normal mode of execution have completed; such
statements are said to complete abruptly.An abrupt completion always has an associated reason, which is one of the
following:

* A break with no label

* A break with a given label

* A continue with no label

* A continue with a given label

* A return with no value

* A return with a given value

* A throw with a given value, including exceptions thrown by the Java virtualmachine

The terms "complete normally" and "complete abruptly" also apply to theevaluation of expressions ($15.6). The only reason an expression can complete
abruptly is that an exception is thrown, because of either a throw with a givenvalue ($14.17) or a run-time exception or error ($11, $15.6).

If a statement evaluates an expression, abrupt completion of the expressionalways causes the immediate abrupt completion of the statement, with the same
reason. All succeeding steps in the normal mode of execution are not performed.Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the

BLOCKS AND STATEMENTS Local Class Declarations 14.3

277DRAFT
same reason, and all succeeding steps in the normal mode of execution of thestatement are not performed.

Unless otherwise specified, a statement completes normally if all expressionsit evaluates and all substatements it executes complete normally.

14.2   Blocks
A block is a sequence of statements, local class declarations and local variabledeclaration statements within braces.

Block:

{ BlockStatementsopt }

BlockStatements:BlockStatement

BlockStatements BlockStatement
BlockStatement:LocalVariableDeclarationStatement

ClassDeclarationStatement

A block is executed by executing each of the local variable declaration state-ments and other statements in order from first to last (left to right). If all of these
block statements complete normally, then the block completes normally. If any ofthese block statements complete abruptly for any reason, then the block completes
abruptly for the same reason.

14.3   Local Class Declarations
A local class is a nested class ($8) that is not a member of any class and that has aname. All local classes are inner classes ($8.1.2). Every local class declaration
statement is immediately contained by a block. Local class declaration statementsmay be intermixed freely with other kinds of statements in the block.

The scope of a local class declared in a block is the rest of the immediatelyenclosing block, including its own class declaration.
The name of a local class C may not be redeclared as a local class of thedirectly enclosing method, constructor, or initializer block within the scope of C,
or a compile-time error occurs. However, a local class declaration may be shad-owed ($6.3.1) anywhere inside a class declaration nested within the local class

14.4 Local Variable Declaration Statements BLOCKS AND STATEMENTS

278 DRAFT

declaration's scope. A local class does not have a canonical name, nor does it havea fully qualified name.

It is a compile-time error if a local class declaration contains any one of thefollowing access modifiers:

public, protected, private, or static.Here is an example that illustrates several aspects of the rules given above:

class Global {

class Cyclic {}
void foo() {

new Cyclic(); // create a Global.Cyclic
class Cyclic extends Cyclic{}; // circular definition
{

class Local{};
{

class Local{}; // compile-time error
}
class Local{}; // compile-time error
class AnotherLocal {

void bar() {

class Local {}; // ok
}
}
}
class Local{}; // ok, not in scope of prior Local
}

The first statement of method foo creates an instance of the member class Global.Cyclic rather than an instance of the local class Cyclic, because the localclass declaration is not yet in scope.

The fact that the scope of a local class encompasses its own declaration (notonly its body) means that the definition of the local class

Cyclic is indeed cyclicbecause it extends itself rather than
Global.Cyclic. Consequently, the declara-tion of the local class
Cyclic will be rejected at compile time.Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of
Local result in compile-time errors. However, Local can be redeclared in thecontext of another, more deeply nested, class such as

AnotherLocal.The fourth and last declaration of
Local is legal, since it occurs outside thescope of any prior declaration of
Local.

14.4 Local Variable Declaration Statements
A local variable declaration statement declares one or more local variable names.

BLOCKS AND STATEMENTS Local Variable Declarators and Types 14.4.1

279DRAFT
LocalVariableDeclarationStatement:LocalVariableDeclaration

 ;

LocalVariableDeclaration:

finalopt Type VariableDeclarators

The following are repeated from $8.3 to make the presentation here clearer:

VariableDeclarators:VariableDeclarator

VariableDeclarators , VariableDeclarator
VariableDeclarator:VariableDeclaratorId

VariableDeclaratorId = VariableInitializer
VariableDeclaratorId:Identifier

VariableDeclaratorId [ ]
VariableInitializer:Expression

ArrayInitializer
Every local variable declaration statement is immediately contained by ablock. Local variable declaration statements may be intermixed freely with other

kinds of statements in the block.A local variable declaration can also appear in the header of a

for statement($14.13). In this case it is executed in the same manner as if it were part of a local

variable declaration statement.

14.4.1   Local Variable Declarators and Types
Each declarator in a local variable declaration declares one local variable, whosename is the Identifier that appears in the declarator.

If the optional keyword final appears at the start of the declarator, the vari-able being declared is a final variable($4.5.4).
The type of the variable is denoted by the Type that appears in the local vari-able declaration, followed by any bracket pairs that follow the Identifier in the
declarator.Thus, the local variable declaration:

int a, b[], c[][];
is equivalent to the series of declarations:

14.4.2 Scope of Local Variable Declarations BLOCKS AND STATEMENTS
280 DRAFT

int a;
int[] b;
int[][] c;

Brackets are allowed in declarators as a nod to the tradition of C and C++. Thegeneral rule, however, also means that the local variable declaration:

float[][] f[][], g[][][], h[]; // Yechh!
is equivalent to the series of declarations:

float[][][][] f;
float[][][][][] g;
float[][][] h;

We do not recommend such "mixed notation" for array declarations.A local variable of type

float always contains a value that is an element ofthe float value set ($4.2.3); similarly, a local variable of type

double always con-tains a value that is an element of the double value set. It is not permitted for a

local variable of type float to contain an element of the float-extended-exponentvalue set that is not also an element of the float value set, nor for a local variable of
type double to contain an element of the double-extended-exponent value set thatis not also an element of the double value set.

14.4.2   Scope of Local Variable Declarations

The scope of a local variable declaration in a block ($14.4.2) is the rest of theblock in which the declaration appears, starting with its own initializer ($14.4) and

including any further declarators to the right in the local variable declaration state-ment.

The name of a local variable v may not be redeclared as a local variable of thedirectly enclosing method, constructor or initializer block within the scope of v, or
a compile-time error occurs. The name of a local variable v may not be redeclaredas an exception parameter of a catch clause in a try statement of the directly
enclosing method, constructor or initializer block within the scope of v, or a com-pile-time error occurs. However, a local variable of a method or initializer block
may be shadowed ($6.3.1) anywhere inside a class declaration nested within thescope of the local variable.

A local variable cannot be referred to using a qualified name ($6.6), only asimple name.
The example:
class Test {

static int x;
public static void main(String[] args) {

int x = x;

BLOCKS AND STATEMENTS Scope of Local Variable Declarations 14.4.2

281DRAFT
}
}

causes a compile-time error because the initialization of x is within the scope ofthe declaration of

x as a local variable, and the local x does not yet have a valueand cannot be used.

The following program does compile:
class Test {

static int x;
public static void main(String[] args) {

int x = (x=2)*2;
System.out.println(x);
}
}

because the local variable x is definitely assigned ($16) before it is used. It prints:

4
Here is another example:
class Test {

public static void main(String[] args) {

System.out.print("2+1=");
int two = 2, three = two + 1;
System.out.println(three);
}
}

which compiles correctly and produces the output:

2+1=3
The initializer for three can correctly refer to the variable two declared in an ear-lier declarator, and the method invocation in the next line can correctly refer to the

variable three declared earlier in the block.The scope of a local variable declared in a

for statement is the rest of the forstatement, including its own initializer.

If a declaration of an identifier as a local variable of the same method, con-structor, or initializer block appears within the scope of a parameter or local variable of the same name, a compile-time error occurs.Thus the following example does not compile:

class Test {

public static void main(String[] args) {

int i;
for (int i = 0; i < 10; i++)

System.out.println(i);

14.4.3 Shadowing of Names by Local Variables BLOCKS AND STATEMENTS
282 DRAFT

}
}

This restriction helps to detect some otherwise very obscure bugs. A similarrestriction on shadowing of members by local variables was judged impractical,

because the addition of a member in a superclass could cause subclasses to have torename local variables. Related considerations make restrictions on shadowing of
local variables by members of nested classes, or on shadowing of local variablesby local variables declared within nested classes unattractive as well. Hence, the
following example compiles without error:

class Test {

public static void main(String[] args) {

int i;
class Local {

{

for (int i = 0; i < 10; i++)
System.out.println(i);
}
}
new Local();
}
}

On the other hand, local variables with the same name may be declared in twoseparate blocks or

for statements neither of which contains the other. Thus:

class Test {

public static void main(String[] args) {

for (int i = 0; i < 10; i++)

System.out.print(i + " ");
for (int i = 10; i > 0; i--)

System.out.print(i + " ");
System.out.println();
}
}

compiles without error and, when executed, produces the output:

0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1

14.4.3 Shadowing of Names by Local Variables
If a name declared as a local variable is already declared as a field name, then thatouter declaration is shadowed ($6.3.1) throughout the scope of the local variable.

Similarly, if a name is already declared as a variable or parameter name, then thatouter declaration is shadowed throughout the scope of the local variable (provided
that the shadowing does not cause a compile-time error under the rules of

BLOCKS AND STATEMENTS Statements 14.5

283DRAFT

$14.4.2). The shadowed name can sometimes be accessed using an appropriatelyqualified name.

For example, the keyword this can be used to access a shadowed field x,using the form

this.x. Indeed, this idiom typically appears in constructors($8.8):

class Pair {

Object first, second;
public Pair(Object first, Object second) {

this.first = first;
this.second = second;
}
}

In this example, the constructor takes parameters having the same names as thefields to be initialized. This is simpler than having to invent different names for

the parameters and is not too confusing in this stylized context. In general, how-ever, it is considered poor style to have local variables with the same names as
fields.

14.4.4 Execution of Local Variable Declarations
A local variable declaration statement is an executable statement. Every time it isexecuted, the declarators are processed in order from left to right. If a declarator

has an initialization expression, the expression is evaluated and its value isassigned to the variable. If a declarator does not have an initialization expression,
then a Java compiler must prove, using exactly the algorithm given in $16, thatevery reference to the variable is necessarily preceded by execution of an assignment to the variable. If this is not the case, then a compile-time error occurs.Each initialization (except the first) is executed only if the evaluation of the
preceding initialization expression completes normally. Execution of the localvariable declaration completes normally only if evaluation of the last initialization
expression completes normally; if the local variable declaration contains no ini-tialization expressions, then executing it always completes normally.

14.5   Statements
There are many kinds of statements in the Java programming language. Most cor-respond to statements in the C and C++ languages, but some are unique.

As in C and C++, the if statement of the Java programming language suffersfrom the so-called "dangling

else problem," illustrated by this misleadingly for-matted example:

14.5 Statements BLOCKS AND STATEMENTS
284 DRAFT

if (door.isOpen())if (resident.isVisible())

resident.greet("Hello!");else door.bell.ring(); // A "dangling else"

The problem is that both the outer if statement and the inner if statement mightconceivably own the

else clause. In this example, one might surmise that the pro-grammer intended the

else clause to belong to the outer if statement. The Javaprogramming language, like C and C++ and many programming languages before

them, arbitrarily decree that an else clause belongs to the innermost if to whichit might possibly belong. This rule is captured by the following grammar:

Statement:StatementWithoutTrailingSubstatement

LabeledStatementIfThenStatement
IfThenElseStatementWhileStatement
ForStatement
StatementWithoutTrailingSubstatement:Block

EmptyStatementExpressionStatement
SwitchStatementDoStatement
BreakStatementContinueStatement
ReturnStatementSynchronizedStatement
ThrowStatementTryStatement

StatementNoShortIf:StatementWithoutTrailingSubstatement

LabeledStatementNoShortIfIfThenElseStatementNoShortIf
WhileStatementNoShortIfForStatementNoShortIf

The following are repeated from $14.9 to make the presentation here clearer:

IfThenStatement:

if ( Expression ) Statement

BLOCKS AND STATEMENTS Labeled Statements 14.7

285DRAFT
IfThenElseStatement:

if ( Expression ) StatementNoShortIf else Statement

IfThenElseStatementNoShortIf:

if ( Expression ) StatementNoShortIf else StatementNoShortIf

Statements are thus grammatically divided into two categories: those thatmight end in an

if statement that has no else clause (a "short if statement") andthose that definitely do not. Only statements that definitely do not end in a short

if statement may appear as an immediate substatement before the keyword elsein an

if statement that does have an else clause.This simple rule prevents the "dangling

else" problem. The execution behav-ior of a statement with the "no short
if" restriction is identical to the executionbehavior of the same kind of statement without the "no short

if" restriction; thedistinction is drawn purely to resolve the syntactic difficulty.

14.6 The Empty Statement
An empty statement does nothing.

EmptyStatement:

;

Execution of an empty statement always completes normally.

14.7   Labeled Statements
Statements may have label prefixes.

LabeledStatement:Identifier

 : Statement

LabeledStatementNoShortIf:Identifier

 : StatementNoShortIf

The Identifier is declared to be the label of the immediately contained Statement.Unlike C and C++, the Java programming language has no

goto statement;identifier statement labels are used with
break ($14.14) or continue ($14.15)statements appearing anywhere within the labeled statement.

The scope of a label declared by a labeled statement is the statement immedi-ately enclosed by the labeled statement.

14.8 Expression Statements BLOCKS AND STATEMENTS

286 DRAFT

Let l be a label, and let m be the immediately enclosing method, constructor,instance initializer or static initializer. It is a compile-time error if

l shadows($6.3.1) the declaration of another label immediately enclosed in
m.There is no restriction against using the same identifier as a label and as the

name of a package, class, interface, method, field, parameter, or local variable.Use of an identifier to label a statement does not obscure ($6.3.2) a package, class,
interface, method, field, parameter, or local variable with the same name. Use ofan identifier as a class, interface, method, field, local variable or as the parameter
of an exception handler ($14.19) does not obscure a statement label with the samename.

A labeled statement is executed by executing the immediately containedStatement. If the statement is labeled by an Identifier and the contained Statement
completes abruptly because of a break with the same Identifier, then the labeledstatement completes normally. In all other cases of abrupt completion of the
Statement, the labeled statement completes abruptly for the same reason.

14.8   Expression Statements
Certain kinds of expressions may be used as statements by following them withsemicolons:

ExpressionStatement:StatementExpression

 ;

StatementExpression:Assignment

PreIncrementExpressionPreDecrementExpression
PostIncrementExpressionPostDecrementExpression
MethodInvocationClassInstanceCreationExpression

An expression statement is executed by evaluating the expression; if theexpression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completesnormally.

Unlike C and C++, the Java programming language allows only certain formsof expressions to be used as expression statements. Note that the Java programming language does not allow a "cast to void"--void is not a type--so the tradi-tional C trick of writing an expression statement such as:

BLOCKS AND STATEMENTS The if-then-else Statement 14.9.2

287DRAFT
(void) ... ; // incorrect!
does not work. On the other hand, the language allows all the most useful kinds ofexpressions in expressions statements, and it does not require a method invocation

used as an expression statement to invoke a void method, so such a trick is almostnever needed. If a trick is needed, either an assignment statement ($15.26) or a
local variable declaration statement ($14.4) can be used instead.

14.9 The if Statement
The if statement allows conditional execution of a statement or a conditionalchoice of two statements, executing one or the other but not both.

IfThenStatement:

if ( Expression ) Statement

IfThenElseStatement:

if ( Expression ) StatementNoShortIf else Statement

IfThenElseStatementNoShortIf:

if ( Expression ) StatementNoShortIf else StatementNoShortIf

The Expression must have type boolean, or a compile-time error occurs.

14.9.1   The if-then Statement
An if-then statement is executed by first evaluating the Expression. If evaluationof the Expression completes abruptly for some reason, the

if-then statementcompletes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:

* If the value is true, then the contained Statement is executed; the if-thenstatement completes normally if and only if execution of the Statement completes normally.

* If the value is false, no further action is taken and the if-then statementcompletes normally.

14.9.2   The if-then-else Statement
An if-then-else statement is executed by first evaluating the Expression. Ifevaluation of the Expression completes abruptly for some reason, then the

if-
then-else statement completes abruptly for the same reason. Otherwise, execu-tion continues by making a choice based on the resulting value:

14.10 The switch Statement BLOCKS AND STATEMENTS
288 DRAFT

* If the value is true, then the first contained Statement (the one before the

else keyword) is executed; the if-then-else statement completes normallyif and only if execution of that statement completes normally.

* If the value is false, then the second contained Statement (the one after the

else keyword) is executed; the if-then-else statement completes normallyif and only if execution of that statement completes normally.

14.10   The switch Statement
The switch statement transfers control to one of several statements depending onthe value of an expression.

SwitchStatement:

switch ( Expression ) SwitchBlock

SwitchBlock:

{ SwitchBlockStatementGroupsopt SwitchLabelsopt }

SwitchBlockStatementGroups:SwitchBlockStatementGroup

SwitchBlockStatementGroups SwitchBlockStatementGroup
SwitchBlockStatementGroup:SwitchLabels BlockStatements

SwitchLabels:SwitchLabel

SwitchLabels SwitchLabel
SwitchLabel:

case ConstantExpression :
default :

The type of the Expression must be char, byte, short, or int, or a compile-time error occurs.
The body of a switch statement is known as a switch block. Any statementimmediately contained by the switch block may be labeled with one or more

caseor
default labels. These labels are said to be associated with the switch state-ment, as are the values of the constant expressions ($15.28) in the

case labels.All of the following must be true, or a compile-time error will result:

BLOCKS AND STATEMENTS The switch Statement 14.10

289DRAFT

* Every case constant expression associated with a switch statement must beassignable ($5.2) to the type of the

switch Expression.

* No two of the case constant expressions associated with a switch statementmay have the same value.

* At most one default label may be associated with the same switch state-ment.

In C and C++ the body of a switch statement can be a statement and state-ments with

case labels do not have to be immediately contained by that state-ment. Consider the simple loop:

for (i = 0; i < n; ++i) foo();
where n is known to be positive. A trick known as Duff's device can be used in Cor C++ to unroll the loop, but this is not valid code in the Java programming language:

int q = (n+7)/8;
switch (n%8) {
case 0: do { foo(); // Great C hack, Tom,
case 7: foo(); // but it's not valid here.
case 6: foo();
case 5: foo();
case 4: foo();
case 3: foo();
case 2: foo();
case 1: foo();

} while (--q >= 0);
}

Fortunately, this trick does not seem to be widely known or used. Moreover, it isless needed nowadays; this sort of code transformation is properly in the province

of state-of-the-art optimizing compilers.When the

switch statement is executed, first the Expression is evaluated. Ifevaluation of the Expression completes abruptly for some reason, the

switchstatement completes abruptly for the same reason. Otherwise, execution continues

by comparing the value of the Expression with each case constant. Then there is achoice:

* If one of the case constants is equal to the value of the expression, then wesay that the

case matches, and all statements after the matching case label inthe switch block, if any, are executed in sequence. If all these statements com14.10 The switch Statement BLOCKS AND STATEMENTS

290 DRAFT

plete normally, or if there are no statements after the matching case label,then the entire

switch statement completes normally.

* If no case matches but there is a default label, then all statements after thematching

default label in the switch block, if any, are executed in sequence.If all these statements complete normally, or if there are no statements after

the default label, then the entire switch statement completes normally.

* If no case matches and there is no default label, then no further action istaken and the

switch statement completes normally.

If any statement immediately contained by the Block body of the switchstatement completes abruptly, it is handled as follows:

* If execution of the Statement completes abruptly because of a break with nolabel, no further action is taken and the

switch statement completes normally.

* If execution of the Statement completes abruptly for any other reason, the

switch statement completes abruptly for the same reason. The case of abruptcompletion because of a

break with a label is handled by the general rule forlabeled statements ($14.7).

As in C and C++, execution of statements in a switch block "falls throughlabels."
For example, the program:
class Toomany {

static void howMany(int k) {

switch (k) {
case 1: System.out.print("one ");
case 2: System.out.print("too ");
case 3: System.out.println("many");
}
}

public static void main(String[] args) {

howMany(3);
howMany(2);
howMany(1);
}

}

contains a switch block in which the code for each case falls through into the codefor the next case. As a result, the program prints:

many
too many
one too many

BLOCKS AND STATEMENTS The while Statement 14.11

291DRAFT
If code is not to fall through case to case in this manner, then break statementsshould be used, as in this example:

class Twomany {

static void howMany(int k) {

switch (k) {
case 1: System.out.println("one");

break; // exit the switch
case 2: System.out.println("two");

break; // exit the switch
case 3: System.out.println("many");

break; // not needed, but good style
}
}

public static void main(String[] args) {

howMany(1);
howMany(2);
howMany(3);
}

}

This program prints:

one
two
many

14.11 The while Statement
The while statement executes an Expression and a Statement repeatedly until thevalue of the Expression is

false.

WhileStatement:

while ( Expression ) Statement

WhileStatementNoShortIf:

while ( Expression ) StatementNoShortIf

The Expression must have type boolean, or a compile-time error occurs.A

while statement is executed by first evaluating the Expression. If evalua-tion of the Expression completes abruptly for some reason, the

while statementcompletes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:

14.11.1 Abrupt Completion BLOCKS AND STATEMENTS

292 DRAFT

* If the value is true, then the contained Statement is executed. Then there is achoice:

u If execution of the Statement completes normally, then the entire whilestatement is executed again, beginning by re-evaluating the Expression.
u If execution of the Statement completes abruptly, see $14.11.1 below.

* If the value of the Expression is false, no further action is taken and the

while statement completes normally.

If the value of the Expression is false the first time it is evaluated, then theStatement is not executed.

14.11.1   Abrupt Completion
Abrupt completion of the contained Statement is handled in the following manner:

* If execution of the Statement completes abruptly because of a break with nolabel, no further action is taken and the

while statement completes normally.

u If execution of the Statement completes abruptly because of a continuewith no label, then the entire

while statement is executed again.

u If execution of the Statement completes abruptly because of a continuewith label

L, then there is a choice:

v If the while statement has label L, then the entire while statement is exe-cuted again.

v If the while statement does not have label L, the while statement com-pletes abruptly because of a

continue with label L.

u If execution of the Statement completes abruptly for any other reason, the

while statement completes abruptly for the same reason. Note that the caseof abrupt completion because of a

break with a label is handled by the gen-eral rule for labeled statements ($14.7).

14.12   The do Statement
The do statement executes a Statement and an Expression repeatedly until thevalue of the Expression is

false.

BLOCKS AND STATEMENTS Abrupt Completion 14.12.1

293DRAFT
DoStatement:

do Statement while ( Expression ) ;

The Expression must have type boolean, or a compile-time error occurs.A

do statement is executed by first executing the Statement. Then there is achoice:

* If execution of the Statement completes normally, then the Expression is eval-uated. If evaluation of the Expression completes abruptly for some reason, the

do statement completes abruptly for the same reason. Otherwise, there is achoice based on the resulting value:

u If the value is true, then the entire do statement is executed again.
u If the value is false, no further action is taken and the do statement com-pletes normally.

* If execution of the Statement completes abruptly, see $14.12.1 below.
Executing a do statement always executes the contained Statement at least once.

14.12.1   Abrupt Completion
Abrupt completion of the contained Statement is handled in the following manner:

* If execution of the Statement completes abruptly because of a break with nolabel, then no further action is taken and the

do statement completes normally.

* If execution of the Statement completes abruptly because of a continue withno label, then the Expression is evaluated. Then there is a choice based on the

resulting value:
u If the value is true, then the entire do statement is executed again.
u If the value is false, no further action is taken and the do statement com-pletes normally.

* If execution of the Statement completes abruptly because of a continue withlabel

L, then there is a choice:

u If the do statement has label L, then the Expression is evaluated. Then thereis a choice:

v If the value of the Expression is true, then the entire do statement is exe-cuted again.
v If the value of the Expression is false, no further action is taken and the

do statement completes normally.

14.12.2 Example of do statement BLOCKS AND STATEMENTS
294 DRAFT

u If the do statement does not have label L, the do statement completesabruptly because of a

continue with label L.

* If execution of the Statement completes abruptly for any other reason, the dostatement completes abruptly for the same reason. The case of abrupt completion because of a break with a label is handled by the general rule ($14.7).

14.12.2 Example of do statement
The following code is one possible implementation of the toHexString methodof class

Integer:

public static String toHexString(int i) {

StringBuffer buf = new StringBuffer(8);
do {

buf.append(Character.forDigit(i & 0xF, 16));
i >>>= 4;
} while (i != 0);
return buf.reverse().toString();
}

Because at least one digit must be generated, the do statement is an appropriatecontrol structure.

14.13 The for Statement
The for statement executes some initialization code, then executes an Expression,a Statement, and some update code repeatedly until the value of the Expression is
false.

ForStatement:

for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement

ForStatementNoShortIf:

for ( ForInitopt ; Expressionopt ; ForUpdateopt )StatementNoShortIf

ForInit:StatementExpressionList

LocalVariableDeclaration
ForUpdate:StatementExpressionList

BLOCKS AND STATEMENTS Iteration of for statement 14.13.2

295DRAFT
StatementExpressionList:StatementExpression

StatementExpressionList , StatementExpression
The Expression must have type boolean, or a compile-time error occurs.

14.13.1   Initialization of for statement
A for statement is executed by first executing the ForInit code:

* If the ForInit code is a list of statement expressions ($14.8), the expressionsare evaluated in sequence from left to right; their values, if any, are discarded.

If evaluation of any expression completes abruptly for some reason, the forstatement completes abruptly for the same reason; any ForInit statement
expressions to the right of the one that completed abruptly are not evaluated.
If the ForInit code is a local variable declaration, it is executed as if it were alocal variable declaration statement ($14.4) appearing in a block. The scope of a
local variable declared in the ForInit part of a for statement ($14.13) includes allof the following:

* Its own initializer

* Any further declarators to the right in the ForInit part of the for statement

* The Expression and ForUpdate parts of the for statement

* The contained Statement

If execution of the local variable declaration completes abruptly for any rea-son, the

for statement completes abruptly for the same reason.

* If the ForInit part is not present, no action is taken.

14.13.2   Iteration of for statement
Next, a for iteration step is performed, as follows:

* If the Expression is present, it is evaluated, and if evaluation of the Expressioncompletes abruptly, the

for statement completes abruptly for the same rea14.13.3 Abrupt Completion of for statement BLOCKS AND STATEMENTS

296 DRAFT

son. Otherwise, there is then a choice based on the presence or absence of theExpression and the resulting value if the Expression is present:
u If the Expression is not present, or it is present and the value resulting fromits evaluation is

true, then the contained Statement is executed. Then thereis a choice:

v If execution of the Statement completes normally, then the following twosteps are performed in sequence:

C First, if the ForUpdate part is present, the expressions are evaluated insequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the forstatement completes abruptly for the same reason; any ForUpdate statement expressions to the right of the one that completed abruptly are notevaluated. If the ForUpdate part is not present, no action is taken.

C Second, another for iteration step is performed.
v If execution of the Statement completes abruptly, see $14.13.3 below.
u If the Expression is present and the value resulting from its evaluation is

false, no further action is taken and the for statement completes normally.

If the value of the Expression is false the first time it is evaluated, then theStatement is not executed.

If the Expression is not present, then the only way a for statement can com-plete normally is by use of a

break statement.

14.13.3   Abrupt Completion of for statement
Abrupt completion of the contained Statement is handled in the following manner:

* If execution of the Statement completes abruptly because of a break with nolabel, no further action is taken and the

for statement completes normally.

* If execution of the Statement completes abruptly because of a continue withno label, then the following two steps are performed in sequence:

u First, if the ForUpdate part is present, the expressions are evaluated insequence from left to right; their values, if any, are discarded. If the

ForUpdate part is not present, no action is taken.
u Second, another for iteration step is performed.

* If execution of the Statement completes abruptly because of a continue withlabel

L, then there is a choice:

BLOCKS AND STATEMENTS The break Statement 14.14

297DRAFT
u If the for statement has label L, then the following two steps are performedin sequence:

v First, if the ForUpdate part is present, the expressions are evaluated insequence from left to right; their values, if any, are discarded. If the

ForUpdate is not present, no action is taken.
v Second, another for iteration step is performed.
u If the for statement does not have label L, the for statement completesabruptly because of a

continue with label L.

* If execution of the Statement completes abruptly for any other reason, the forstatement completes abruptly for the same reason. Note that the case of abrupt

completion because of a break with a label is handled by the general rule forlabeled statements ($14.7).

14.14   The break Statement
A break statement transfers control out of an enclosing statement.

BreakStatement:

break Identifieropt ;

A break statement with no label attempts to transfer control to the innermostenclosing

switch, while, do, or for statement of the immediately enclosingmethod or initializer block; this statement, which is called the break target, then

immediately completes normally.To be precise, a

break statement with no label always completes abruptly, thereason being a
break with no label. If no switch, while, do, or for statementencloses the
break statement, a compile-time error occurs.A
break statement with label Identifier attempts to transfer control to theenclosing labeled statement ($14.7) that has the same Identifier as its label; this

statement, which is called the break target, then immediately completes normally.In this case, the

break target need not be a while, do, for, or switch statement.A
break statement must refer to a label within the immediately enclosing methodor initializer block. There are no non-local jumps.

To be precise, a break statement with label Identifier always completesabruptly, the reason being a

break with label Identifier. If no labeled statementwith Identifier as its label encloses the

break statement, a compile-time erroroccurs.

It can be seen, then, that a break statement always completes abruptly.

14.14 The break Statement BLOCKS AND STATEMENTS
298 DRAFT

The preceding descriptions say "attempts to transfer control" rather than just"transfers control" because if there are any

try statements ($14.19) within thebreak target whose
try blocks contain the break statement, then any finallyclauses of those
try statements are executed, in order, innermost to outermost,before control is transferred to the break target. Abrupt completion of a

finallyclause can disrupt the transfer of control initiated by a
break statement.In the following example, a mathematical graph is represented by an array of

arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrowthat points from some node to some other node, or from a node to itself. In this
example it is assumed that there are no redundant edges; that is, for any two nodes
P and Q, where Q may be the same as P, there is at most one edge from P to Q.Nodes are represented by integers, and there is an edge from node

i to node
edges[i ][j ] for every i and j for which the array reference edges[i ][j ]does not throw an

IndexOutOfBoundsException.The task of the method

loseEdges, given integers i and j, is to construct anew graph by copying a given graph but omitting the edge from node

i to node j,if any, and the edge from node
j to node i, if any:

class Graph {

int edges[][];

public Graph(int[][] edges) { this.edges = edges; }

public Graph loseEdges(int i, int j) {

int n = edges.length;
int[][] newedges = new int[n][];
for (int k = 0; k < n; ++k) {

edgelist: {

int z;

search: {

if (k == i) {

for (z = 0; z < edges[k].length; ++z)

if (edges[k][z] == j)

break search;
} else if (k == j) {

for (z = 0; z < edges[k].length; ++z)

if (edges[k][z] == i)

break search;
}
// No edge to be deleted; share this list.
newedges[k] = edges[k];
break edgelist;
} //search

// Copy the list, omitting the edge at position z.
int m = edges[k].length - 1;

BLOCKS AND STATEMENTS The continue Statement 14.15

299DRAFT
int ne[] = new int[m];
System.arraycopy(edges[k], 0, ne, 0, z);
System.arraycopy(edges[k], z+1, ne, z, m-z);
newedges[k] = ne;
} //edgelist

}
return new Graph(newedges);
}

}
Note the use of two statement labels, edgelist and search, and the use of breakstatements. This allows the code that copies a list, omitting one edge, to be shared

between two separate tests, the test for an edge from node i to node j, and the testfor an edge from node

j to node i.

14.15 The continue Statement
A continue statement may occur only in a while, do, or for statement; state-ments of these three kinds are called iteration statements. Control passes to the
loop-continuation point of an iteration statement.

ContinueStatement:

continue Identifieropt ;

A continue statement with no label attempts to transfer control to the inner-most enclosing

while, do, or for statement of the immediately enclosing methodor initializer block; this statement, which is called the continue target, then immediately ends the current iteration and begins a new one.To be precise, such a

continue statement always completes abruptly, the rea-son being a
continue with no label. If no while, do, or for statement of theimmediately enclosing method or initializer block encloses the

continue state-ment, a compile-time error occurs.

A continue statement with label Identifier attempts to transfer control to theenclosing labeled statement ($14.7) that has the same Identifier as its label; that
statement, which is called the continue target, then immediately ends the currentiteration and begins a new one. The continue target must be a

while, do, or forstatement or a compile-time error occurs. A
continue statement must refer to alabel within the immediately enclosing method or initializer block. There are no

non-local jumps.More precisely, a

continue statement with label Identifier always completesabruptly, the reason being a

continue with label Identifier. If no labeled state14.15 The continue Statement BLOCKS AND STATEMENTS
300 DRAFT

ment with Identifier as its label contains the continue statement, a compile-timeerror occurs.

It can be seen, then, that a continue statement always completes abruptly.See the descriptions of the

while statement ($14.11), do statement ($14.12),and
for statement ($14.13) for a discussion of the handling of abrupt terminationbecause of

continue.The preceding descriptions say "attempts to transfer control" rather than just

"transfers control" because if there are any try statements ($14.19) within thecontinue target whose

try blocks contain the continue statement, then any
finally clauses of those try statements are executed, in order, innermost to out-ermost, before control is transferred to the continue target. Abrupt completion of a

finally clause can disrupt the transfer of control initiated by a continue state-ment.

In the Graph example in the preceding section, one of the break statements isused to finish execution of the entire body of the outermost

for loop. This breakcan be replaced by a
continue if the for loop itself is labeled:

class Graph {. . .

public Graph loseEdges(int i, int j) {

int n = edges.length;
int[][] newedges = new int[n][];

edgelists: for (int k = 0; k < n; ++k) {

int z;

search: {

if (k == i) {. . .

} else if (k == j) {. . .
}
newedges[k] = edges[k];
continue edgelists;
} // search. . .

} // edgelists
return new Graph(newedges);
}
}

Which to use, if either, is largely a matter of programming style.

BLOCKS AND STATEMENTS The return Statement 14.16

301DRAFT
14.16 The return Statement
A return statement returns control to the invoker of a method ($8.4, $15.12) orconstructor ($8.8, $15.9).

ReturnStatement:

return Expressionopt ;

A return statement with no Expression must be contained in the body of amethod that is declared, using the keyword

void, not to return any value ($8.4), orin the body of a constructor ($8.8). A compile-time error occurs if a

return state-ment appears within an instance initializer or a static initializer ($8.7). A

returnstatement with no Expression attempts to transfer control to the invoker of the

method or constructor that contains it.To be precise, a

return statement with no Expression always completesabruptly, the reason being a

return with no value.A
return statement with an Expression must be contained in a method decla-ration that is declared to return a value ($8.4) or a compile-time error occurs. The

Expression must denote a variable or value of some type T, or a compile-timeerror occurs. The type

T must be assignable ($5.2) to the declared result type ofthe method, or a compile-time error occurs.

A return statement with an Expression attempts to transfer control to theinvoker of the method that contains it; the value of the Expression becomes the
value of the method invocation. More precisely, execution of such a return state-ment first evaluates the Expression. If the evaluation of the Expression completes
abruptly for some reason, then the return statement completes abruptly for thatreason. If evaluation of the Expression completes normally, producing a value

V,then the
return statement completes abruptly, the reason being a return withvalue
V. If the expression is of type float and is not FP-strict ($15.4), then thevalue may be an element of either the float value set or the float-extended-exponent value set ($4.2.3). If the expression is of type double and is not FP-strict,then the value may be an element of either the double value set or the doubleextended-exponent value set.It can be seen, then, that a

return statement always completes abruptly.The preceding descriptions say "attempts to transfer control" rather than just

"transfers control" because if there are any try statements ($14.19) within themethod or constructor whose

try blocks contain the return statement, then any
finally clauses of those try statements will be executed, in order, innermost tooutermost, before control is transferred to the invoker of the method or construc14.17 The throw Statement BLOCKS AND STATEMENTS
302 DRAFT

tor. Abrupt completion of a finally clause can disrupt the transfer of control ini-tiated by a

return statement.

14.17 The throw Statement
A throw statement causes an exception ($11) to be thrown. The result is an imme-diate transfer of control ($11.3) that may exit multiple statements and multiple
constructor, instance initializer, static initializer and field initializer evaluations,and method invocations until a

try statement ($14.19) is found that catches thethrown value. If no such
try statement is found, then execution of the thread($17) that executed the
throw is terminated ($11.3) after invocation of the
uncaughtException method for the thread group to which the thread belongs.

ThrowStatement:

throw Expression ;

The Expression in a throw statement must denote a variable or value of a ref-erence type which is assignable ($5.2) to the type

Throwable, or a compile-timeerror occurs. Moreover, at least one of the following three conditions must be true,

or a compile-time error occurs:

* The exception is not a checked exception ($11.2)--specifically, one of the fol-lowing situations is true:

u The type of the Expression is the class RuntimeException or a subclass of

RuntimeException.

u The type of the Expression is the class Error or a subclass of Error.

* The throw statement is contained in the try block of a try statement($14.19) and the type of the Expression is assignable ($5.2) to the type of the

parameter of at least one catch clause of the try statement. (In this case wesay the thrown value is caught by the

try statement.)

* The throw statement is contained in a method or constructor declaration andthe type of the Expression is assignable ($5.2) to at least one type listed in the

throws clause ($8.4.4, $8.8.4) of the declaration.
A throw statement first evaluates the Expression. If the evaluation of theExpression completes abruptly for some reason, then the

throw completesabruptly for that reason. If evaluation of the Expression completes normally, producing a non-null value V, then the throw statement completes abruptly, the rea-son being a

throw with value V. If evaluation of the Expression completesnormally, producing a

null value, then an instance V' of class NullPointerExBLOCKS AND STATEMENTS The synchronized Statement 14.18

303DRAFT
ception is created and thrown instead of null. The throw statement then com-pletes abruptly, the reason being a

throw with value V'.It can be seen, then, that a
throw statement always completes abruptly.If there are any enclosing
try statements ($14.19) whose try blocks containthe
throw statement, then any finally clauses of those try statements are exe-cuted as control is transferred outward, until the thrown value is caught. Note that

abrupt completion of a finally clause can disrupt the transfer of control initiatedby a

throw statement.If a

throw statement is contained in a method declaration, but its value is notcaught by some

try statement that contains it, then the invocation of the methodcompletes abruptly because of the

throw.If a
throw statement is contained in a constructor declaration, but its value isnot caught by some

try statement that contains it, then the class instance creationexpression that invoked the constructor will complete abruptly because of the

throw.If a

throw statement is contained in a static initializer ($8.7), then a compile-time check ensures that either its value is always an unchecked exception or its

value is always caught by some try statement that contains it. If at run-time,despite this check, the value is not caught by some

try statement that contains the
throw statement, then the value is rethrown if it is an instance of class Error orone of its subclasses; otherwise, it is wrapped in an

ExceptionInInitializerError object, which is then thrown ($12.4.2).If a

throw statement is contained in an instance initializer ($8.6), then a com-pile-time check ensures that either its value is always an unchecked exception or

its value is always caught by some try statement that contains it, or the type of thethrown exception (or one of its superclasses) occurs in the

throws clause of everyconstructor of the class.

By convention, user-declared throwable types should usually be declared tobe subclasses of class

Exception, which is a subclass of class Throwable($11.5).

14.18   The synchronized Statement
A synchronized statement acquires a mutual-exclusion lock ($17.13) on behalfof the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.

SynchronizedStatement:

synchronized ( Expression ) Block

The type of Expression must be a reference type, or a compile-time error occurs.

14.19 The try statement BLOCKS AND STATEMENTS
304 DRAFT

A synchronized statement is executed by first evaluating the Expression.If evaluation of the Expression completes abruptly for some reason, then the
synchronized statement completes abruptly for the same reason.Otherwise, if the value of the Expression is

null, a NullPointerExceptionis thrown.

Otherwise, let the non-null value of the Expression be V. The executingthread locks the lock associated with

V. Then the Block is executed. If executionof the Block completes normally, then the lock is unlocked and the

synchronizedstatement completes normally. If execution of the Block completes abruptly for

any reason, then the lock is unlocked and the synchronized statement then com-pletes abruptly for the same reason.

Acquiring the lock associated with an object does not of itself prevent otherthreads from accessing fields of the object or invoking unsynchronized methods
on the object. Other threads can also use synchronized methods or the
synchronized statement in a conventional manner to achieve mutual exclusion.The locks acquired by

synchronized statements are the same as the locksthat are acquired implicitly by

synchronized methods; see $8.4.3.6. A singlethread may hold a lock more than once.

The example:
class Test {

public static void main(String[] args) {

Test t = new Test();
synchronized(t) {

synchronized(t) {

System.out.println("made it!");
}
}
}
}

prints:

made it!
This example would deadlock if a single thread were not permitted to lock a lockmore than once.

14.19 The try statement
A try statement executes a block. If a value is thrown and the try statement hasone or more

catch clauses that can catch it, then control will be transferred to thefirst such
catch clause. If the try statement has a finally clause, then another

BLOCKS AND STATEMENTS The try statement 14.19

305DRAFT
block of code is executed, no matter whether the try block completes normally orabruptly, and no matter whether a

catch clause is first given control.

TryStatement:

try Block Catches
try Block Catchesopt Finally

Catches:CatchClause

Catches CatchClause
CatchClause:

catch ( FormalParameter ) Block

Finally:

finally Block

The following is repeated from $8.4.1 to make the presentation here clearer:

FormalParameter:

finalopt Type VariableDeclaratorId

The following is repeated from $8.3 to make the presentation here clearer:

VariableDeclaratorId:Identifier

VariableDeclaratorId [ ]
The Block immediately after the keyword try is called the try block of the
try statement. The Block immediately after the keyword finally is called the
finally block of the try statement.A

try statement may have catch clauses (also called exception handlers).A
catch clause must have exactly one parameter (which is called an exceptionparameter); the declared type of the exception parameter must be the class

Throwable or a subclass of Throwable, or a compile-time error occurs. Thescope of the parameter variable is the Block of the

catch clause.An exception parameter of a catch clause must not have the same name as a

local variable or parameter of the method or initializer block immediately enclos-ing the catch clause, or a compile-time error occurs.

The scope of a parameter of an exception handler that is declared in a catchclause of a

try statement ($14.19) is the entire block associated with the catch.Within the Block of the

catch clause, the name of the parameter may not be rede-clared as a local variable of the directly enclosing method or initializer block, nor

may it be redeclared as an exception parameter of a catch clause in a try statementof the directly enclosing method or initializer block, or a compile-time error

14.19.1 Execution of try-catch BLOCKS AND STATEMENTS
306 DRAFT

occurs. However, an exception parameter may be shadowed ($6.3.1) anywhereinside a class declaration nested within the Block of the

catch clause.It is a compile-time error if an exception parameter that is declared

final isassigned to within the body of the catch clause.

Exception parameters cannot be referred to using qualified names ($6.6), onlyby simple names.
Exception handlers are considered in left-to-right order: the earliest possible
catch clause accepts the exception, receiving as its actual argument the thrownexception object.

A finally clause ensures that the finally block is executed after the tryblock and any

catch block that might be executed, no matter how control leavesthe
try block or catch block.Handling of the

finally block is rather complex, so the two cases of a trystatement with and without a

finally block are described separately.

14.19.1   Execution of try-catch
A try statement without a finally block is executed by first executing the tryblock. Then there is a choice:

* If execution of the try block completes normally, then no further action istaken and the

try statement completes normally.

* If execution of the try block completes abruptly because of a throw of avalue

V, then there is a choice:

u If the run-time type of V is assignable ($5.2) to the Parameter of any catchclause of the

try statement, then the first (leftmost) such catch clause isselected. The value

V is assigned to the parameter of the selected catchclause, and the Block of that

catch clause is executed. If that block com-pletes normally, then the
try statement completes normally; if that blockcompletes abruptly for any reason, then the

try statement completesabruptly for the same reason.

u If the run-time type of V is not assignable to the parameter of any catchclause of the

try statement, then the try statement completes abruptlybecause of a
throw of the value V.

* If execution of the try block completes abruptly for any other reason, thenthe

try statement completes abruptly for the same reason.

In the example:
class BlewIt extends Exception {

BLOCKS AND STATEMENTS Execution of try-catch-finally 14.19.2

307DRAFT
BlewIt() { }
BlewIt(String s) { super(s); }
}
class Test {

static void blowUp() throws BlewIt { throw new BlewIt(); }
public static void main(String[] args) {

try {

blowUp();
} catch (RuntimeException r) {

System.out.println("RuntimeException:" + r);
} catch (BlewIt b) {

System.out.println("BlewIt");
}
}

}
the exception BlewIt is thrown by the method blowUp. The try-catch statementin the body of

main has two catch clauses. The run-time type of the exception is
BlewIt which is not assignable to a variable of type RuntimeException, but isassignable to a variable of type

BlewIt, so the output of the example is:

BlewIt

14.19.2 Execution of try-catch-finally
A try statement with a finally block is executed by first executing the tryblock. Then there is a choice:

* If execution of the try block completes normally, then the finally block isexecuted, and then there is a choice:

u If the finally block completes normally, then the try statement completesnormally.
u If the finally block completes abruptly for reason S, then the try state-ment completes abruptly for reason

S.

* If execution of the try block completes abruptly because of a throw of avalue

V, then there is a choice:

u If the run-time type of V is assignable to the parameter of any catch clauseof the

try statement, then the first (leftmost) such catch clause is selected.

14.19.2 Execution of try-catch-finally BLOCKS AND STATEMENTS

308 DRAFT

The value V is assigned to the parameter of the selected catch clause, andthe Block of that

catch clause is executed. Then there is a choice:

v If the catch block completes normally, then the finally block is exe-cuted. Then there is a choice:

C If the finally block completes normally, then the try statement com-pletes normally.
C If the finally block completes abruptly for any reason, then the trystatement completes abruptly for the same reason.
v If the catch block completes abruptly for reason R, then the finallyblock is executed. Then there is a choice:

C If the finally block completes normally, then the try statement com-pletes abruptly for reason

R.

C If the finally block completes abruptly for reason S, then the trystatement completes abruptly for reason

S (and reason R is discarded).

u If the run-time type of V is not assignable to the parameter of any catchclause of the

try statement, then the finally block is executed. Then thereis a choice:

v If the finally block completes normally, then the try statement com-pletes abruptly because of a

throw of the value V.

v If the finally block completes abruptly for reason S, then the try state-ment completes abruptly for reason

S (and the throw of value V is dis-carded and forgotten).

* If execution of the try block completes abruptly for any other reason R, thenthe

finally block is executed. Then there is a choice:

u If the finally block completes normally, then the try statement completesabruptly for reason

R.

u If the finally block completes abruptly for reason S, then the try state-ment completes abruptly for reason

S (and reason R is discarded).

The example:
class BlewIt extends Exception {

BlewIt() { }
BlewIt(String s) { super(s); }
}

BLOCKS AND STATEMENTS Unreachable Statements 14.20

309DRAFT
class Test {

static void blowUp() throws BlewIt {

throw new NullPointerException();
}

public static void main(String[] args) {

try {

blowUp();
} catch (BlewIt b) {

System.out.println("BlewIt");
} finally {

System.out.println("Uncaught Exception");
}
}

}
produces the output:

Uncaught Exception
java.lang.NullPointerException

at Test.blowUp(Test.java:7)
at Test.main(Test.java:11)

The NullPointerException (which is a kind of RuntimeException) that isthrown by method

blowUp is not caught by the try statement in main, because a
NullPointerException is not assignable to a variable of type BlewIt. Thiscauses the

finally clause to execute, after which the thread executing main,which is the only thread of the test program, terminates because of an uncaught

exception, which typically results in printing the exception name and a simplebacktrace.

14.20 Unreachable Statements
It is a compile-time error if a statement cannot be executed because it is unreach-able. Every Java compiler must carry out the conservative flow analysis specified
here to make sure all statements are reachable.This section is devoted to a precise explanation of the word "reachable." The
idea is that there must be some possible execution path from the beginning of theconstructor, method, instance initializer or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of state-ments. Except for the special treatment of

while, do, and for statements whosecondition expression has the constant value

true, the values of expressions arenot taken into account in the flow analysis.

For example, a Java compiler will accept the code:

14.20 Unreachable Statements BLOCKS AND STATEMENTS
310 DRAFT

{

int n = 5;
while (n > 7) k = 2;
}

even though the value of n is known at compile time and in principle it can beknown at compile time that the assignment to

k can never be executed.A Java compiler must operate according to the rules laid out in this section.

The rules in this section define two technical terms:

* whether a statement is reachable

* whether a statement can complete normally

The definitions here allow a statement to complete normally only if it is reachable.To shorten the description of the rules, the customary abbreviation "iff" is
used to mean "if and only if."The rules are as follows:

* The block that is the body of a constructor, method, instance initializer orstatic initializer is reachable.

* An empty block that is not a switch block can complete normally iff it isreachable. A nonempty block that is not a switch block can complete normally iff the last statement in it can complete normally. The first statement ina nonempty block that is not a switch block is reachable iff the block is reachable. Every other statement S in a nonempty block that is not a switch block isreachable iff the statement preceding

S can complete normally.

* A local class declaration statement can complete normally iff it is reachable.

* A local variable declaration statement can complete normally iff it is reach-able.

* An empty statement can complete normally iff it is reachable.

* A labeled statement can complete normally if at least one of the following istrue:

u The contained statement can complete normally.
u There is a reachable break statement that exits the labeled statement.
The contained statement is reachable iff the labeled statement is reachable.

* An expression statement can complete normally iff it is reachable.

* The if statement, whether or not it has an else part, is handled in an unusualmanner. For this reason, it is discussed separately at the end of this section.

BLOCKS AND STATEMENTS Unreachable Statements 14.20

311DRAFT

* A switch statement can complete normally iff at least one of the following istrue:

u The last statement in the switch block can complete normally.
u The switch block is empty or contains only switch labels.
u There is at least one switch label after the last switch block statement group.
u The switch block does not contain a default label.
u There is a reachable break statement that exits the switch statement.

* A switch block is reachable iff its switch statement is reachable.

* A statement in a switch block is reachable iff its switch statement is reach-able and at least one of the following is true:

u It bears a case or default label.
u There is a statement preceding it in the switch block and that precedingstatement can complete normally.

* A while statement can complete normally iff at least one of the following istrue:

u The while statement is reachable and the condition expression is not a con-stant expression with value

true.

u There is a reachable break statement that exits the while statement.
The contained statement is reachable iff the while statement is reachable andthe condition expression is not a constant expression whose value is

false.

* A do statement can complete normally iff at least one of the following is true:

u The contained statement can complete normally and the condition expres-sion is not a constant expression with value

true.

u The do statement contains a reachable continue statement with no label,and the

do statement is the innermost while, do, or for statement that con-tains that

continue statement, and the condition expression is not a con-stant expression with value

true.

u The do statement contains a reachable continue statement with a label L,and the

do statement has label L, and the condition expression is not a con-stant expression with value

true.

u There is a reachable break statement that exits the do statement.
The contained statement is reachable iff the do statement is reachable.

14.20 Unreachable Statements BLOCKS AND STATEMENTS
312 DRAFT

* A for statement can complete normally iff at least one of the following istrue:

u The for statement is reachable, there is a condition expression, and the con-dition expression is not a constant expression with value

true.

u There is a reachable break statement that exits the for statement.
The contained statement is reachable iff the for statement is reachable andthe condition expression is not a constant expression whose value is

false.

* A break, continue, return, or throw statement cannot complete normally.

* A synchronized statement can complete normally iff the contained state-ment can complete normally. The contained statement is reachable iff the

synchronized statement is reachable.

* A try statement can complete normally iff both of the following are true:

u The try block can complete normally or any catch block can complete

normally.

u If the try statement has a finally block, then the finally block can com-plete normally.

* The try block is reachable iff the try statement is reachable.

* A catch block C is reachable iff both of the following are true:

u Some expression or throw statement in the try block is reachable and canthrow an exception whose type is assignable to the parameter of the

catchclause
C. (An expression is considered reachable iff the innermost statementcontaining it is reachable.)

u There is no earlier catch block A in the try statement such that the type of

C's parameter is the same as or a subclass of the type of A's parameter.

* If a finally block is present, it is reachable iff the try statement is reach-able.

One might expect the if statement to be handled in the following manner, butthese are not the rules that the Java programming language actually uses:

* HYPOTHETICAL: An if-then statement can complete normally iff at leastone of the following is

true:

u The if-then statement is reachable and the condition expression is not aconstant expression whose value is

true.

u The then-statement can complete normally.

BLOCKS AND STATEMENTS Unreachable Statements 14.20

313DRAFT
The then-statement is reachable iff the if-then statement is reachable andthe condition expression is not a constant expression whose value is

false.

* HYPOTHETICAL: An if-then-else statement can complete normally iffthe

then-statement can complete normally or the else-statement can com-plete normally. The

then-statement is reachable iff the if-then-else state-ment is reachable and the condition expression is not a constant expression

whose value is false. The else statement is reachable iff the if-then-elsestatement is reachable and the condition expression is not a constant expression whose value is true.
This approach would be consistent with the treatment of other control struc-tures. However, in order to allow the if statement to be used conveniently for
"conditional compilation" purposes, the actual rules differ.The actual rules for the if statement are as follows:

* ACTUAL: An if-then statement can complete normally iff it is reachable.The

then-statement is reachable iff the if-then statement is reachable.

* ACTUAL: An if-then-else statement can complete normally iff the then-statement can complete normally or the

else-statement can complete nor-mally. The
then-statement is reachable iff the if-then-else statement isreachable. The

else-statement is reachable iff the if-then-else statementis reachable.

As an example, the following statement results in a compile-time error:
while (false) { x=3; }
because the statement x=3; is not reachable; but the superficially similar case:

if (false) { x=3; }
does not result in a compile-time error. An optimizing compiler may realize thatthe statement

x=3; will never be executed and may choose to omit the code forthat statement from the generated

class file, but the statement x=3; is notregarded as "unreachable" in the technical sense specified here.

The rationale for this differing treatment is to allow programmers to define"flag variables" such as:

static final boolean DEBUG = false;
and then write code such as:

if (DEBUG) { x=3; }

14.20 Unreachable Statements BLOCKS AND STATEMENTS

314 DRAFT

The idea is that it should be possible to change the value of DEBUG from false to
true or from true to false and then compile the code correctly with no otherchanges to the program text.

This ability to "conditionally compile" has a significant impact on, and rela-tionship to, binary compatibility ($13). If a set of classes that use such a "flag"
variable are compiled and conditional code is omitted, it does not suffice later todistribute just a new version of the class or interface that contains the definition of
the flag. A change to the value of a flag is, therefore, not binary compatible withpreexisting binaries ($13.4.8). (There are other reasons for such incompatibility as
well, such as the use of constants in case labels in switch statements; see$13.4.8.)

BLOCKS AND STATEMENTS Unreachable Statements 14.20

315DRAFT317DRAFT
C H A P T E R 15
Expressions

MUCH of the work in a program is done by evaluating expressions, either fortheir side effects, such as assignments to variables, or for their values, which can
be used as arguments or operands in larger expressions, or to affect the executionsequence in statements, or both.

This chapter specifies the meanings of expressions and the rules for their eval-uation.

15.1   Evaluation, Denotation, and Result
When an expression in a program is evaluated (executed), the result denotes oneof three things:

* A variable ($4.5) (in C, this would be called an lvalue)

* A value ($4.2, $4.3)

* Nothing (the expression is said to be void)

Evaluation of an expression can also produce side effects, because expres-sions may contain embedded assignments, increment operators, decrement operators, and method invocations.An expression denotes nothing if and only if it is a method invocation
($15.12) that invokes a method that does not return a value, that is, a methoddeclared

void ($8.4). Such an expression can be used only as an expression state-ment ($14.8), because every other context in which an expression can appear

requires the expression to denote something. An expression statement that is amethod invocation may also invoke a method that produces a result; in this case
the value returned by the method is quietly discarded.Value set conversion ($5.1.8) is applied to the result of every expression that
produces a value.

15.2 Variables as Values EXPRESSIONS

318 DRAFT

Each expression occurs in the declaration of some (class or interface) typethat is being declared: in a field initializer, in a static initializer, in a constructor
declaration, or in the code for a method.

15.2   Variables as Values
If an expression denotes a variable, and a value is required for use in further eval-uation, then the value of that variable is used. In this context, if the expression
denotes a variable or a value, we may speak simply of the value of the expression.If the value of a variable of type

float or double is used in this manner, thenvalue set conversion ($5.1.8) is applied to the value of the variable.

15.3   Type of an Expression
If an expression denotes a variable or a value, then the expression has a typeknown at compile time. The rules for determining the type of an expression are
explained separately below for each kind of expression.The value of an expression is always assignment compatible ($5.2) with the
type of the expression, just as the value stored in a variable is always compatiblewith the type of the variable.

In other words, the value of an expression whose type is T is always suitablefor assignment to a variable of type

T.Note that an expression whose type is a class type

F that is declared final isguaranteed to have a value that is either a null reference or an object whose class

is F itself, because final types have no subclasses.

15.4 FP-strict Expressions
If the type of an expression is float or double, then there is a question as to whatvalue set ($4.2.3) the value of the expression is drawn from. This is governed by
the rules of value set conversion ($5.1.8); these rules in turn depend on whether ornot the expression is FP-strict.

Every compile-time constant expression ($15.28) is FP-strict. If an expression
is not a compile-time constant expression, then consider all the class declarations,
interface declarations, and method declarations that contain the expression. If any
such declaration bears the strictfp modifier, then the expression is FP-strict.

EXPRESSIONS Expressions and Run-Time Checks 15.5

319DRAFT
If a class, interface, or method, X, is declared strictfp, then X and any class,
interface, method, constructor, instance initializer, static initializer or variable initializer within X is said to be FP-strict.

It follows that an expression is not FP-strict if and only if it is not a compiletime constant expression and it does not appear within any declaration that has the
strictfp modifier.

Within an FP-strict expression, all intermediate values must be elements of
the float value set or the double value set, implying that the results of all FP-strict
expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats. Within an expression that is not FP-strict,
some leeway is granted for an implementation to use an extended exponent range
to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the
float value set or double value set might result in overflow or underflow.

15.5   Expressions and Run-Time Checks
If the type of an expression is a primitive type, then the value of the expression isof that same primitive type. But if the type of an expression is a reference type,
then the class of the referenced object, or even whether the value is a reference toan object rather than

null, is not necessarily known at compile time. There are afew places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced fromthe type of the expression. They are as follows:

* Method invocation ($15.12). The particular method used for an invocation

o.m(...) is chosen based on the methods that are part of the class or interfacethat is the type of

o. For instance methods, the class of the object referencedby the run-time value of

o participates because a subclass may override a spe-cific method already declared in a parent class so that this overriding method

is invoked. (The overriding method may or may not choose to further invokethe original overridden

m method.)

* The instanceof operator ($15.20.2). An expression whose type is a refer-ence type may be tested using

instanceof to find out whether the class of theobject referenced by the run-time value of the expression is assignment compatible ($5.2) with some other reference type.

* Casting ($5.5, $15.16). The class of the object referenced by the run-timevalue of the operand expression might not be compatible with the type specified by the cast. For reference types, this may require a run-time check that

15.6 Normal and Abrupt Completion of Evaluation EXPRESSIONS
320 DRAFT

throws an exception if the class of the referenced object, as determined at runtime, is not assignment compatible ($5.2) with the target type.

* Assignment to an array component of reference type ($10.10, $15.13,$15.26.1). The type-checking rules allow the array type

S[] to be treated as asubtype of
T[] if S is a subtype of T, but this requires a run-time check forassignment to an array component, similar to the check performed for a cast.

* Exception handling ($14.19). An exception is caught by a catch clause onlyif the class of the thrown exception object is an

instanceof the type of theformal parameter of the
catch clause.

The first two of the cases just listed ought never to result in detecting a type error.Thus, a run-time type error can occur only in these situations:

* In a cast, when the actual class of the object referenced by the value of theoperand expression is not compatible with the target type specified by the cast

operator ($5.5, $15.16); in this case a ClassCastException is thrown.

* In an assignment to an array component of reference type, when the actualclass of the object referenced by the value to be assigned is not compatible

with the actual run-time component type of the array ($10.10, $15.13,$15.26.1); in this case an

ArrayStoreException is thrown.

* When an exception is not caught by any catch handler ($11.3); in this casethe thread of control that encountered the exception first invokes the method

uncaughtException  for its thread group and then terminates.

15.6   Normal and Abrupt Completion of Evaluation
Every expression has a normal mode of evaluation in which certain computationalsteps are carried out. The following sections describe the normal mode of evaluation for each kind of expression. If all the steps are carried out without an excep-tion being thrown, the expression is said to complete normally.

If, however, evaluation of an expression throws an exception, then the expres-sion is said to complete abruptly. An abrupt completion always has an associated
reason, which is always a throw with a given value.Run-time exceptions are thrown by the predefined operators as follows:

* A class instance creation expression ($15.9), array creation expression($15.10), or string concatenation operatior expression ($15.18.1) throws an

OutOfMemoryError if there is insufficient memory available.

EXPRESSIONS Normal and Abrupt Completion of Evaluation 15.6

321DRAFT

* An array creation expression throws a NegativeArraySizeException if thevalue of any dimension expression is less than zero ($15.10).

* A field access ($15.11) throws a NullPointerException if the value of theobject reference expression is

null.

* A method invocation expression ($15.12) that invokes an instance methodthrows a

NullPointerException if the target reference is null.

* An array access ($15.13) throws a NullPointerException if the value ofthe array reference expression is

null.

* An array access ($15.13) throws an ArrayIndexOutOfBoundsException ifthe value of the array index expression is negative or greater than or equal to

the length of the array.

* A cast ($15.16) throws a ClassCastException if a cast is found to be imper-missible at run time.

* An integer division ($15.17.2) or integer remainder ($15.17.3) operatorthrows an

ArithmeticException if the value of the right-hand operandexpression is zero.

* An assignment to an array component of reference type ($15.26.1) throws an

ArrayStoreException when the value to be assigned is not compatible withthe component type of the array.

A method invocation expression can also result in an exception being thrown if anexception occurs that causes execution of the method body to complete abruptly.
A class instance creation expression can also result in an exception being thrownif an exception occurs that causes execution of the constructor to complete
abruptly. Various linkage and virtual machine errors may also occur during theevaluation of an expression. By their nature, such errors are difficult to predict and
difficult to handle.If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; suchexpressions are said to complete abruptly. The terms "complete normally"
and "complete abruptly" are also applied to the execution of statements ($14.1).A statement may complete abruptly for a variety of reasons, not just because an
exception is thrown.If evaluation of an expression requires evaluation of a subexpression, abrupt
completion of the subexpression always causes the immediate abrupt completionof the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.

15.7 Evaluation Order EXPRESSIONS
322 DRAFT

15.7   Evaluation Order
The Java programming language guarantees that the operands of operators appearto be evaluated in a specific evaluation order, namely, from left to right.

It is recommended that code not rely crucially on this specification. Code isusually clearer when each expression contains at most one side effect, as its
outermost operation, and when code does not depend on exactly which exceptionarises as a consequence of the left-to-right evaluation of expressions.

15.7.1 Evaluate Left-Hand Operand First
The left-hand operand of a binary operator appears to be fully evaluated beforeany part of the right-hand operand is evaluated. For example, if the left-hand operand contains an assignment to a variable and the right-hand operand contains areference to that same variable, then the value produced by the reference will
reflect the fact that the assignment occurred first.Thus:

class Test {

public static void main(String[] args) {

int i = 2;
int j = (i=3) * i;
System.out.println(j);
}
}

prints:

9
It is not permitted for it to print 6 instead of 9.If the operator is a compound-assignment operator ($15.26.2), then evaluation

of the left-hand operand includes both remembering the variable that the left-handoperand denotes and fetching and saving that variable's value for use in the
implied combining operation. So, for example, the test program:

class Test {

public static void main(String[] args) {

int a = 9;
a += (a = 3); // first example
System.out.println(a);
int b = 9;
b = b + (b = 3); // second example
System.out.println(b);

EXPRESSIONS Evaluate Operands before Operation 15.7.2

323DRAFT
}
}

prints:

12
12

because the two assignment statements both fetch and remember the value of theleft-hand operand, which is

9, before the right-hand operand of the addition isevaluated, thereby setting the variable to

3. It is not permitted for either exampleto produce the result
6. Note that both of these examples have unspecified behav-ior in C, according to the ANSI/ISO standard.

If evaluation of the left-hand operand of a binary operator completes abruptly,no part of the right-hand operand appears to have been evaluated.
Thus, the test program:
class Test {

public static void main(String[] args) {

int j = 1;
try {

int i = forgetIt() / (j = 2);
} catch (Exception e) {

System.out.println(e);
System.out.println("Now j = " + j);
}
}

static int forgetIt() throws Exception {

throw new Exception("I'm outta here!");
}

}
prints:

java.lang.Exception: I'm outta here!
Now j = 1

That is, the left-hand operand forgetIt() of the operator / throws an excep-tion before the right-hand operand is evaluated and its embedded assignment of

2to
j occurs.

15.7.2 Evaluate Operands before Operation
The Java programming language also guarantees that every operand of an operator(except the conditional operators

&&, ||, and ? :) appears to be fully evaluatedbefore any part of the operation itself is performed.

15.7.3 Evaluation Respects Parentheses and Precedence EXPRESSIONS
324 DRAFT

If the binary operator is an integer division / ($15.17.2) or integer remainder
% ($15.17.3), then its execution may raise an ArithmeticException, but thisexception is thrown only after both operands of the binary operator have been

evaluated and only if these evaluations completed normally.So, for example, the program:

class Test {

public static void main(String[] args) {

int divisor = 0;
try {

int i = 1 / (divisor * loseBig());
} catch (Exception e) {

System.out.println(e);
}
}

static int loseBig() throws Exception {

throw new Exception("Shuffle off to Buffalo!");
}

}

always prints:

java.lang.Exception: Shuffle off to Buffalo!
and not:

java.lang.ArithmeticException: / by zero
since no part of the division operation, including signaling of a divide-by-zeroexception, may appear to occur before the invocation of

loseBig completes, eventhough the implementation may be able to detect or infer that the division operation would certainly result in a divide-by-zero exception.

15.7.3 Evaluation Respects Parentheses and Precedence
Java programming language implementations must respect the order of evaluationas indicated explicitly by parentheses and implicitly by operator precedence. An

implementation may not take advantage of algebraic identities such as the associa-tive law to rewrite expressions into a more convenient computational order unless
it can be proven that the replacement expression is equivalent in value and in itsobservable side effects, even in the presence of multiple threads of execution
(using the thread execution model in $17), for all possible computational valuesthat might be involved.

In the case of floating-point calculations, this rule applies also for infinity andnot-a-number (NaN) values. For example,

!(x<y) may not be rewritten as x>=y,

EXPRESSIONS Argument Lists are Evaluated Left-to-Right 15.7.4

325DRAFT
because these expressions have different values if either x or y is NaN or both areNaN.

Specifically, floating-point calculations that appear to be mathematically asso-ciative are unlikely to be computationally associative. Such computations must
not be naively reordered.For example, it is not correct for a Java compiler to rewrite

4.0*x*0.5 as
2.0*x; while roundoff happens not to be an issue here, there are large values of xfor which the first expression produces infinity (because of overflow) but the second expression produces a finite result.So, for example, the test program:

strictfp class Test {

public static void main(String[] args) {

double d = 8e+307;
System.out.println(4.0 * d * 0.5);
System.out.println(2.0 * d);
}
}

prints:

Infinity
1.6e+308

because the first expression overflows and the second does not.In contrast, integer addition and multiplication are provably associative in the

Java programming language.For example

a+b+c, where a, b, and c are local variables (this simplifyingassumption avoids issues involving multiple threads and

volatile variables),will always produce the same answer whether evaluated as
(a+b)+c or a+(b+c);if the expression
b+c occurs nearby in the code, a smart compiler may be able touse this common subexpression.

15.7.4 Argument Lists are Evaluated Left-to-Right
In a method or constructor invocation or class instance creation expression, argu-ment expressions may appear within the parentheses, separated by commas. Each

argument expression appears to be fully evaluated before any part of any argumentexpression to its right.

Thus:
class Test {

public static void main(String[] args) {

String s = "going, ";

15.7.5 Evaluation Order for Other Expressions EXPRESSIONS
326 DRAFT

print3(s, s, s = "gone");
}

static void print3(String a, String b, String c) {

System.out.println(a + b + c);
}

}
always prints:

going, going, gone
because the assignment of the string "gone" to s occurs after the first two argu-ments to

print3 have been evaluated.If evaluation of an argument expression completes abruptly, no part of any

argument expression to its right appears to have been evaluated.Thus, the example:

class Test {

static int id;

public static void main(String[] args) {

try {

test(id = 1, oops(), id = 3);
} catch (Exception e) {

System.out.println(e + ", id=" + id);
}
}

static int oops() throws Exception {

throw new Exception("oops");
}

static int test(int a, int b, int c) {

return a + b + c;
}

}
prints:

java.lang.Exception: oops, id=1
because the assignment of 3 to id is not executed.

15.7.5 Evaluation Order for Other Expressions
The order of evaluation for some expressions is not completely covered by thesegeneral rules, because these expressions may raise exceptional conditions at times

EXPRESSIONS Lexical Literals 15.8.1

327DRAFT
that must be specified. See, specifically, the detailed explanations of evaluationorder for the following kinds of expressions:

* class instance creation expressions ($15.9.4)

* array creation expressions ($15.10.1)

* method invocation expressions ($15.12.4)

* array access expressions ($15.13.1)

* assignments involving array components ($15.26)

15.8   Primary Expressions
Primary expressions include most of the simplest kinds of expressions, fromwhich all others are constructed: literals, class literals, field accesses, method
invocations, and array accesses. A parenthesized expression is also treated syntac-tically as a primary expression.

Primary:PrimaryNoNewArray

ArrayCreationExpression
PrimaryNoNewArray:Literal

Type . class
void . class
thisClassName

.this
( Expression )ClassInstanceCreationExpression

FieldAccessMethodInvocation
ArrayAccess

15.8.1   Lexical Literals
A literal ($3.10) denotes a fixed, unchanging value.The following production from $3.10 is repeated here for convenience:

15.8.2 Class Literals EXPRESSIONS

328 DRAFT

Literal:IntegerLiteral

FloatingPointLiteralBooleanLiteral
CharacterLiteralStringLiteral
NullLiteral
The type of a literal is determined as follows:

* The type of an integer literal that ends with L or l is long; the type of anyother integer literal is

int.

* The type of a floating-point literal that ends with F or f is float and its valuemust be an element of the float value set ($4.2.3). The type of any other floating-point literal is double and its value must be an element of the doublevalue set.

* The type of a boolean literal is boolean.

* The type of a character literal is char.

* The type of a string literal is String.

* The type of the null literal null is the null type; its value is the null reference.

Evaluation of a lexical literal always completes normally.

15.8.2   Class Literals
A class literal is an expression consisting of the name of a class, interface, array,or primitive type followed by a `.' and the token

class. The type of a class literalis
Class. It evaluates to the Class object for the named type (or for void) asdefined by the defining class loader of the class of the current instance.

15.8.3 this
The keyword this may be used only in the body of an instance method, instanceinitializer or constructor, or in the initializer of an instance variable of a class. If it

appears anywhere else, a compile-time error occurs.When used as a primary expression, the keyword

this denotes a value, that isa reference to the object for which the instance method was invoked ($15.12), or

to the object being constructed. The type of this is the class C within which thekeyword

this occurs. At run time, the class of the actual object referred to maybe the class

C or any subclass of C.

EXPRESSIONS Parenthesized Expressions 15.8.5

329DRAFT
In the example:
class IntVector {

int[] v;

boolean equals(IntVector other) {

if (this == other)

return true;
if (v.length != other.v.length)

return false;
for (int i = 0; i < v.length; i++)

if (v[i] != other.v[i])

return false;
return true;
}

}
the class IntVector implements a method equals, which compares two vectors.If the

other vector is the same vector object as the one for which the equalsmethod was invoked, then the check can skip the length and value comparisons.

The equals method implements this check by comparing the reference to the
other object to this.The keyword

this is also used in a special explicit constructor invocationstatement, which can appear at the beginning of a constructor body ($8.8.5).

15.8.4   Qualified this
Any lexically enclosing instance can be referred to by explicitly qualifying thekeyword

this.Let
C be the class denoted by ClassName. Let n be an integer such that C is thenth lexically enclosing class of the class in which the qualified

this expressionappears. The value of an expression of the form ClassName.
this is the nth lexi-cally enclosing instance of
this ($8.1.2). The type of the expression is C. It is acompile-time error if the current class is not an inner class of class

C or C itself.

15.8.5   Parenthesized Expressions
A parenthesized expression is a primary expression whose type is the type of thecontained expression and whose value at run time is the value of the contained

expression. If the contained expression denotes a variable then the parenthesizedexpression also denotes that variable.

Parentheses do not affect in any way the choice of value set ($4.2.3) for thevalue of an expression of type

float or double.

15.9 Class Instance Creation Expressions EXPRESSIONS
330 DRAFT

15.9   Class Instance Creation Expressions
A class instance creation expression is used to create new objects that areinstances of classes.

ClassInstanceCreationExpression:

new ClassOrInterfaceType ( ArgumentListopt ) ClassBodyoptPrimary.

new Identifier ( ArgumentListopt ) ClassBodyopt

ArgumentList:Expression

ArgumentList , Expression
Class instance creation expressions have two forms:

* Unqualified class instance creation expressions begin with the keyword new.An unqualified class instance creation expression may be used to create an

instance of a class, regardless of whether the class is a top-level ($7.6), mem-ber ($8.5, $9.5), local ($14.3) or anonymous class ($15.9.5).

* Qualified class instance creation expressions begin with a Primary. A quali-fied class instance creation expression enables the creation of instances of

inner member classes and their anonymous subclasses.
Both unqualified and qualified class instance creation expressions mayoptionally end with a class body. Such a class instance creation expression
declares an anonymous class ($15.9.5) and creates an instance of it.We say that a class is instantiated when an instance of the class is created by a
class instance creation expression. Class instantiation involves determining whatclass is to be instantiated, what the enclosing instances (if any) of the newly created instance are, what constructor should be invoked to create the new instanceand what arguments should be passed to that constructor.

15.9.1   Determining the Class being InstantiatedIf

the class instance creation expression ends in a class body, then the classbeing instantiated is an anonymous class. Then:

* If the class instance creation expression is an unqualified class instance cre-ation expression, then let

T be the ClassOrInterfaceType after the new token. Itis a compile-time error if the class or interface named by

T is not accessible($6.6). If
T is the name of a class, then an anonymous direct subclass of theclass named by

T is declared. It is a compile-time error if the class named by Tis a
final class. If T is the name of an interface then an anonymous direct

EXPRESSIONS Determining Enclosing Instances 15.9.2

331DRAFT
subclass of Object that implements the interface named by T is declared. Ineither case, the body of the subclass is the ClassBody given in the class
instance creation expression. The class being instantiated is the anonymoussubclass.

* Otherwise, the class instance creation expression is a qualified class instancecreation expression. Let

T be the name of the Identifier after the new token. Itis a compile-time error if

T is not the simple name ($6.2) of an accessible($6.6) nonfinal inner class ($8.1.2) that is a member of the compile-timetype of the Primary. It is also a compile-time error if

T is ambiguous ($8.5).An anonymous direct subclass of the class named by
T is declared. The bodyof the subclass is the ClassBody given in the class instance creation expression. The class being instantiated is the anonymous subclass.
If a class instance creation expression does not declare an anonymous class,then:

* If the class instance creation expression is an unqualified class instance cre-ation expression, then the ClassOrInterfaceType must name a class that is

accessible ($6.6) and not abstract, or a compile-time error occurs. In thiscase, the class being instantiated is the class denoted by ClassOrInterfaceType.

* Otherwise, the class instance creation expression is a qualified class instancecreation expression. It is a compile-time error if Identifier is not the simple

name ($6.2) of an accessible ($6.6) non-abstract inner class ($8.1.2) T thatis a member of the compile-time type of the Primary. It is also a compile-time
error if Identifier is ambiguous ($8.5). The class being instantiated is the classdenoted by Identifier.

The type of the class instance creation expression is the class type beinginstantiated.

15.9.2   Determining Enclosing Instances
Let C be the class being instantiated, and let i the instance being created. If C is aninner class then

i may have an immediately enclosing instance. The immediatelyenclosing instance of

i ($8.1.2) is determined as follows:

* If C is an anonymous class, then:

u If the class instance creation expression occurs in a static context ($8.1.2),then

i has no immediately enclosing instance.

u Otherwise, the immediately enclosing instance of i is this.

15.9.2 Determining Enclosing Instances EXPRESSIONS
332 DRAFT

* If C is a local class ($14.3), C must be declared in a method declared in a lexi-cally enclosing class

O. Let n be an integer such that O is the nth lexicallyenclosing class of the class in which the class instance creation expression

appears. Then:
u If C occurs in a static context, then i has no immediately enclosing instance.
u Otherwise, if the class instance creation expression occurs in a static con-text, then a compile-time error occurs.

u Otherwise, the immediately enclosing instance of i is the nth lexicallyenclosing instance of

this ($8.1.2).

* Otherwise, C is an inner member class ($8.5).

u If the class instance creation expression is an unqualified class instance cre-ation expression, then:

v If the class instance creation expression occurs in a static context, then acompile-time error occurs.
v Otherwise, if C is a member of an enclosing class then let O be the inner-most lexically enclosing class of which

C is a member, and let n be aninteger such that
O is the nth lexically enclosing class of the class in whichthe class instance creation expression appears. The immediately enclosing

instance of i is the nth lexically enclosing instance of this.
v Otherwise, a compile-time error occurs.
u Otherwise, the class instance creation expression is a qualified classinstance creation expression. The immediately enclosing instance of

i is theobject that is the value of the Primary expression.

In addition, if C is an anonymous class, and the direct superclass of C, S, is aninner class then

i may have an immediately enclosing instance with respect to Swhich is determined as follows:

* If S is a local class ($14.3), then S must be declared in a method declared in alexically enclosing class

O. Let n be an integer such that O is the nth lexicallyenclosing class of the class in which the class instance creation expression

appears. Then:
u If S occurs within a static context, then i has no immediately enclosinginstance with respect to

S.

u Otherwise, if the class instance creation expression occurs in a static con-text, then a compile-time error occurs.

EXPRESSIONS Choosing the Constructor and its Arguments 15.9.3

333DRAFT
u Otherwise, the immediately enclosing instance of i with respect to S is thenth lexically enclosing instance of

this.

* Otherwise, S is an inner member class ($8.5).

u If the class instance creation expression is an unqualified class instance cre-ation expression, then:

v If the class instance creation expression occurs in a static context, then acompile-time error occurs.
v Otherwise, if S is a member of an enclosing class then let O be the inner-most lexically enclosing class of which

S is a member, and let n be aninteger such that
O is the nth lexically enclosing class of the class in whichthe class instance creation expression appears. The immediately enclosing

instance of i with respect to S is the nth lexically enclosing instance of
this.

v Otherwise, a compile-time error occurs.
u Otherwise, the class instance creation expression is a qualified classinstance creation expression. The immediately enclosing instance of

i withrespect to
S is the object that is the value of the Primary expression.

15.9.3   Choosing the Constructor and its Arguments
Let C be the class type being instantiated. To create an instance of C, i, a construc-tor of

C is chosen at compile-time by the following rules:

* First, the actual arguments to the constructor invocation are determined.

u If C is an anonymous class, and the direct superclass of C, S, is an innerclass, then:

v If the S is a local class and S occurs in a static context, then the argumentsin the argument list, if any, are the arguments to the constructor, in the

order they appear in the expression.
v Otherwise, the immediately enclosing instance of i with respect to S isthe first argument to the constructor, followed by the arguments in the

argument list of the class instance creation expression, if any, in the orderthey appear in the expression.

u Otherwise the arguments in the argument list, if any, are the arguments tothe constructor, in the order they appear in the expression.

15.9.4 Run-time Evaluation of Class Instance Creation Expressions EXPRESSIONS

334 DRAFT

* Once the actual arguments have been determined, they are used to select aconstructor of

C, using the same rules as for method invocations ($15.12). Asin method invocations, a compile-time method matching error results if there

is no unique most-specific constructor that is both applicable and accessible.
Note that the type of the class instance creation expression may be an anony-mous class type, in which case the constructor being invoked is an anonymous
constructor.

15.9.4   Run-time Evaluation of Class Instance Creation Expressions
At run time, evaluation of a class instance creation expression is as follows.First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifyingexpression evaluates to

null, a NullPointerException is raised, and the classinstance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for thesame reason.

Next, space is allocated for the new class instance. If there is insufficientspace to allocate the object, evaluation of the class instance creation expression
completes abruptly by throwing an OutOfMemoryError ($15.9.6).The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it isinitialized to its default value ($4.5.5).

Next, the actual arguments to the constructor are evaluated, left-to-right. Ifany of the argument evaluations completes abruptly, any argument expressions to
its right are not evaluated, and the class instance creation expression completesabruptly for the same reason.

Next, the selected constructor of the specified class type is invoked. Thisresults in invoking at least one constructor for each superclass of the class type.
This process can be directed by explicit constructor invocation statements ($8.8)and is described in detail in $12.5.

The value of a class instance creation expression is a reference to the newlycreated object of the specified class. Every time the expression is evaluated, a
fresh object is created.

15.9.5   Anonymous Class Declarations
An anonymous class declaration is automatically derived from a class instancecreation expression by the compiler.

EXPRESSIONS Anonymous Class Declarations 15.9.5

335DRAFT
An anonymous class is never abstract ($8.1.1.1). An anonymous class isalways an inner class ($8.1.2); it is never

static ($8.1.1, $8.5.2). An anonymousclass is always implicitly
final ($8.1.1.2).

15.9.5.1 Anonymous Constructors
An anonymous class cannot have an explicitly declared constructor. Instead, thecompiler must automatically provide an anonymous constructor for the anonymous class. The form of the anonymous constructor of an anonymous class C withdirect superclass

S is as follows:

* If S is not an inner class, or if S is a local class that occurs in a static context,then the anonymous constructor has one formal parameter for each actual

argument to the class instance creation expression in which C is declared. Theactual arguments to the class instance creation expression are used to determine a constructor cs of S, using the same rules as for method invocations($15.12). The type of each formal parameter of the anonymous constructor
must be identical to the corresponding formal parameter of cs.
The body of the constructor consists of an explicit constructor invocation($8.8.5.1) of the form

super(...), where the actual arguments are the formalparameters of the constructor, in the order they were declared.

* Otherwise, the first formal parameter of the constructor of C represents thevalue of the immediately enclosing instance of

i with respect to S. The type ofthis parameter is the class type that immediately encloses the declaration of

S.The constructor has an additional formal parameter for each actual argument

to the class instance creation expression that declared the anonymous class.The

nth formal parameter e corresponds to the st actual argument. Theactual arguments to the class instance creation expression are used to determine a constructor cs of S, using the same rules as for method invocations($15.12). The type of each formal parameter of the anonymous constructor
must be identical to the corresponding formal parameter of cs. The body ofthe constructor consists of an explicit constructor invocation ($8.8.5.1) of the
form o.super(...), where o is the first formal parameter of the constructor, andthe actual arguments are the subsequent formal parameters of the constructor,
in the order they were declared.
In all cases, the throws clause of an anonymous constructor must list all thechecked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptionsthrown by any instance initializers or instance variable initializers of the anonymous class.

n 1-

15.9.6 Example: Evaluation Order and Out-of-Memory Detection EXPRESSIONS

336 DRAFT

Note that it is possible for the signature of the anonymous constructor to referto an inaccessible type (for example, if such a type occurred in the signature of the
superclass constructor cs). This does not, in itself, cause any errors at either com-pile time or run time.

15.9.6   Example: Evaluation Order and Out-of-Memory Detection
If evaluation of a class instance creation expression finds there is insufficientmemory to perform the creation operation, then an

OutOfMemoryError is thrown.This check occurs before any argument expressions are evaluated.

So, for example, the test program:
class List {

int value;
List next;
static List head = new List(0);
List(int n) { value = n; next = head; head = this; }
}

class Test {

public static void main(String[] args) {

int id = 0, oldid = 0;
try {

for (;;) {

++id;
new List(oldid = id);
}
} catch (Error e) {

System.out.println(e + ", " + (oldid==id));
}
}
}

prints:

java.lang.OutOfMemoryError: List, false
because the out-or-memory condition is detected before the argument expression
oldid = id is evaluated.Compare this to the treatment of array creation expressions ($15.10), for

which the out-of-memory condition is detected after evaluation of the dimensionexpressions ($15.10.3).

EXPRESSIONS Array Creation Expressions 15.10

337DRAFT
15.10 Array Creation Expressions
An array instance creation expression is used to create new arrays ($10).

ArrayCreationExpression:

new PrimitiveType DimExprs Dimsopt
new TypeName DimExprs Dimsopt
new PrimitiveType Dims ArrayInitializer
new TypeName Dims ArrayInitializer

DimExprs:DimExpr

DimExprs DimExpr
DimExpr:

[ Expression ]

Dims:

[ ]Dims

 [ ]

An array creation expression creates an object that is a new array whose ele-ments are of the type specified by the PrimitiveType or TypeName. The TypeName
may name any named reference type, even an abstract class type ($8.1.1.1) oran interface type ($9).

The type of the creation expression is an array type that can denoted by a copyof the creation expression from which the

new keyword and every DimExprexpression and array initializer have been deleted.

For example, the type of the creation expression:
new double[3][3][]
is:

double[][][]
The type of each dimension expression within a DimExpr must be an integraltype, or a compile-time error occurs. Each expression undergoes unary numeric

promotion ($5.6.1). The promoted type must be int, or a compile-time erroroccurs; this means, specifically, that the type of a dimension expression must not
be long.If an array initializer is provided, the newly allocated array will be initialized
with the values provided by the array initializer as described in $10.6.

15.10.1 Run-time Evaluation of Array Creation Expressions EXPRESSIONS
338 DRAFT

15.10.1   Run-time Evaluation of Array Creation Expressions
At run time, evaluation of an array creation expression behaves as follows. If thereare no dimension expressions, then there must be an array initializer. The value of

the array initializer is the value of the array creation expression. Otherwise:First, the dimension expressions are evaluated, left-to-right. If any of the
expression evaluations completes abruptly, the expressions to the right of it are notevaluated.

Next, the values of the dimension expressions are checked. If the value of anyDimExpr expression is less than zero, then an

NegativeArraySizeException isthrown.

Next, space is allocated for the new array. If there is insufficient space to allo-cate the array, evaluation of the array creation expression completes abruptly by
throwing an OutOfMemoryError.Then, if a single DimExpr appears, a single-dimensional array is created of
the specified length, and each component of the array is initialized to its defaultvalue ($4.5.5).

If an array creation expression contains N DimExpr expressions, then it effec-tively executes a set of nested loops of depth to create the implied arrays of
arrays.For example, the declaration:

float[][] matrix = new float[3][3];
is equivalent in behavior to:

float[][] matrix = new float[3][];
for (int d = 0; d < matrix.length; d++)

matrix[d] = new float[3];

and:

Age[][][][][] Aquarius = new Age[6][10][8][12][];
is equivalent to:

Age[][][][][] Aquarius = new Age[6][][][][];
for (int d1 = 0; d1 < Aquarius.length; d1++) {

Aquarius[d1] = new Age[10][][][];
for (int d2 = 0; d2 < Aquarius[d1].length; d2++) {

Aquarius[d1][d2] = new Age[8][][];
for (int d3 = 0; d3 < Aquarius[d1][d2].length; d3++) {

Aquarius[d1][d2][d3] = new Age[12][];
}
}
}

N 1-
EXPRESSIONS Example: Array Creation Evaluation Order 15.10.2

339DRAFT
with d, d1, d2 and d3 replaced by names that are not already locally declared.Thus, a single

new expression actually creates one array of length 6, 6 arrays oflength 10, arrays of length 8, and arrays of length

12. This example leaves the fifth dimension, which would be arrays containing theactual array elements (references to

Age objects), initialized only to null refer-ences. These arrays can be filled in later by other code, such as:

Age[] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius[1][9][6][9] = Hair;

A multidimensional array need not have arrays of the same length at eachlevel.

Thus, a triangular matrix may be created by:
float triang[][] = new float[100][];
for (int i = 0; i < triang.length; i++)

triang[i] = new float[i+1];

15.10.2 Example: Array Creation Evaluation Order
In an array creation expression ($15.10), there may be one or more dimensionexpressions, each within brackets. Each dimension expression is fully evaluated

before any part of any dimension expression to its right.Thus:

class Test {

public static void main(String[] args) {

int i = 4;
int ia[][] = new int[i][i=3];
System.out.println(

"[" + ia.length + "," + ia[0].length + "]");
}
}

prints:

[4,3]
because the first dimension is calculated as 4 before the second dimension expres-sion sets

i to 3.If evaluation of a dimension expression completes abruptly, no part of any

dimension expression to its right will appear to have been evaluated. Thus, theexample:

class Test {

public static void main(String[] args) {

int[][] a = { { 00, 01 }, { 10, 11 } };
int i = 99;

6 10* 60= 6 10 8** 480=
15.10.3 Example: Array Creation and Out-of-Memory Detection EXPRESSIONS

340 DRAFT

try {

a[val()][i = 1]++;
} catch (Exception e) {

System.out.println(e + ", i=" + i);
}
}

static int val() throws Exception {

throw new Exception("unimplemented");
}

}

prints:

java.lang.Exception: unimplemented, i=99
because the embedded assignment that sets i to 1 is never executed.

15.10.3   Example: Array Creation and Out-of-Memory Detection
If evaluation of an array creation expression finds there is insufficient memory toperform the creation operation, then an

OutOfMemoryError is thrown. This checkoccurs only after evaluation of all dimension expressions has completed normally.

So, for example, the test program:
class Test {

public static void main(String[] args) {

int len = 0, oldlen = 0;
Object[] a = new Object[0];
try {

for (;;) {

++len;
Object[] temp = new Object[oldlen = len];
temp[0] = a;
a = temp;
}
} catch (Error e) {

System.out.println(e + ", " + (oldlen==len));
}
}
}

prints:

java.lang.OutOfMemoryError, true
because the out-of-memory condition is detected after the dimension expression
oldlen = len is evaluated.

EXPRESSIONS Field Access Using a Primary 15.11.1

341DRAFT
Compare this to class instance creation expressions ($15.9), which detect theout-of-memory condition before evaluating argument expressions ($15.9.6).
15.11 Field Access Expressions
A field access expression may access a field of an object or array, a reference towhich is the value of either an expression or the special keyword

super. (It is alsopossible to refer to a field of the current instance or current class by using a simple

name; see $6.5.6.)

FieldAccess:Primary

 . Identifier
super . IdentifierClassName

 .super . Identifier

The meaning of a field access expression is determined using the same rulesas for qualified names ($6.6), but limited by the fact that an expression cannot

denote a package, class type, or interface type.

15.11.1   Field Access Using a Primary
The type of the Primary must be a reference type T, or a compile-time erroroccurs. The meaning of the field access expression is determined as follows:

* If the identifier names several accessible member fields of type T, then thefield access is ambiguous and a compile-time error occurs.

* If the identifier does not name an accessible member field of type T, then thefield access is undefined and a compile-time error occurs.

* Otherwise, the identifier names a single accessible member field of type T andthe type of the field access expression is the declared type of the field. At run

time, the result of the field access expression is computed as follows:
u If the field is static:

v If the field is final, then the result is the value of the specified class vari-able in the class or interface that is the type of the Primary expression.

v If the field is not final, then the result is a variable, namely, the specifiedclass variable in the class that is the type of the Primary expression.
u If the field is not static:

15.11.1 Field Access Using a Primary EXPRESSIONS
342 DRAFT

v If the value of the Primary is null, then a NullPointerException isthrown.
v If the field is final, then the result is the value of the specified instancevariable in the object referenced by the value of the Primary.
v If the field is not final, then the result is a variable, namely, the specifiedinstance variable in the object referenced by the value of the Primary.

Note, specifically, that only the type of the Primary expression, not the class of theactual object referred to at run time, is used in determining which field to use.

Thus, the example:
class S { int x = 0; }
class T extends S { int x = 1; }
class Test {

public static void main(String[] args) {

T t = new T();
System.out.println("t.x=" + t.x + when("t", t));

S s = new S();
System.out.println("s.x=" + s.x + when("s", s));

s = t;
System.out.println("s.x=" + s.x + when("s", s));

}
static String when(String name, Object t) {

return " when " + name + " holds a "

+ t.getClass() + " at run time.";
}

}
produces the output:

t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class S at run time.
s.x=0 when s holds a class T at run time.

The last line shows that, indeed, the field that is accessed does not depend on therun-time class of the referenced object; even if

s holds a reference to an object ofclass
T, the expression s.x refers to the x field of class S, because the type of theexpression

s is S. Objects of class T contain two fields named x, one for class Tand one for its superclass

S.This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations. The power of late binding and overEXPRESSIONS Field Access Using a Primary 15.11.1

343DRAFT
riding is available in, but only when instance methods are used. Consider the sameexample using instance methods to access the fields:

class S { int x = 0; int z() { return x; } }
class T extends S { int x = 1; int z() { return x; } }
class Test {

public static void main(String[] args) {

T t = new T();
System.out.println("t.z()=" + t.z() + when("t", t));
S s = new S();
System.out.println("s.z()=" + s.z() + when("s", s));
s = t;
System.out.println("s.z()=" + s.z() + when("s", s));
}

static String when(String name, Object t) {

return " when " + name + " holds a "

+ t.getClass() + " at run time.";
}

}
Now the output is:

t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class S at run time.
s.z()=1 when s holds a class T at run time.

The last line shows that, indeed, the method that is accessed does depend on therun-time class of referenced object; when

s holds a reference to an object of class
T, the expression s.z() refers to the z method of class T, despite the fact that thetype of the expression

s is S. Method z of class T overrides method z of class S.The following example demonstrates that a null reference may be used to

access a class (static) variable without causing an exception:

class Test {

static String mountain = "Chocorua";

static Test favorite(){

System.out.print("Mount ");
return null;
}

public static void main(String[] args) {

System.out.println(favorite().mountain);
}

}

15.11.2 Accessing Superclass Members using super EXPRESSIONS
344 DRAFT

It compiles, executes, and prints:

Mount Chocorua
Even though the result of favorite() is null, a NullPointerException isnot thrown. That "

Mount " is printed demonstrates that the Primary expression isindeed fully evaluated at run time, despite the fact that only its type, not its value,

is used to determine which field to access (because the field mountain is static).

15.11.2 Accessing Superclass Members using super
The special forms using the keyword super are valid only in an instance method,instance initializer or constructor, or in the initializer of an instance variable of a

class; these are exactly the same situations in which the keyword this may beused ($15.8.3). The forms involving

super may not be used anywhere in the class
Object, since Object has no superclass; if super appears in class Object, then acompile-time error results.

Suppose that a field access expression super.name appears within class C,and the immediate superclass of

C is class S. Then super.name is treated exactlyas if it had been the expression

((S)this).name; thus, it refers to the fieldnamed
name of the current object, but with the current object viewed as aninstance of the superclass. Thus it can access the field named

name that is visiblein class
S , even if that field is hidden by a declaration of a field named name inclass
C.The use of

super is demonstrated by the following example:

interface I { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1 { int x = 2; }
class T3 extends T2 {

int x = 3;
void test() {

System.out.println("x=\t\t"+x);
System.out.println("super.x=\t\t"+super.x);
System.out.println("((T2)this).x=\t"+((T2)this).x);
System.out.println("((T1)this).x=\t"+((T1)this).x);
System.out.println("((I)this).x=\t"+((I)this).x);
}
}
class Test {

public static void main(String[] args) {

new T3().test();
}
}

which produces the output:

EXPRESSIONS Method Invocation Expressions 15.12

345DRAFT
x= 3
super.x= 2
((T2)this).x= 2
((T1)this).x= 1
((I)this).x= 0

Within class T3, the expression super.x is treated exactly as if it were:

((T2)this).x
Suppose that a field access expression T.super.name appears within class C,and the immediate superclass of the class denoted by

T is a class whose fully qual-ified name is
S. Then T.super.name is treated exactly as if it had been theexpression
((S)T.this).name.Thus the expression

T.super.name can access the field named name that isvisible in the class named by

S , even if that field is hidden by a declaration of afield named
name in the class named by T.It is a compile-time error if the class denoted by

T is not a lexically enclosingclass of the current class.

15.12   Method Invocation Expressions
A method invocation expression is used to invoke a class or instance method.

MethodInvocation:MethodName

 ( ArgumentListopt )Primary
 . Identifier ( ArgumentListopt )
super . Identifier ( ArgumentListopt )ClassName

 . super . Identifier ( ArgumentListopt )

The definition of ArgumentList from $15.9 is repeated here for convenience:

ArgumentList:Expression

ArgumentList , Expression
Resolving a method name at compile time is more complicated than resolvinga field name because of the possibility of method overloading. Invoking a method

at run time is also more complicated than accessing a field because of the possibil-ity of instance method overriding.

Determining the method that will be invoked by a method invocation expres-sion involves several steps. The following three sections describe the compiletime processing of a method invocation; the determination of the type of themethod invocation expression is described in $15.12.3.

15.12.1 Compile-Time Step 1: Determine Class or Interface to Search EXPRESSIONS
346 DRAFT

15.12.1   Compile-Time Step 1: Determine Class or Interface to Search
The first step in processing a method invocation at compile time is to figure outthe name of the method to be invoked and which class or interface to check for

definitions of methods of that name. There are several cases to consider, depend-ing on the form that precedes the left parenthesis, as follows:

* If the form is MethodName, then there are three subcases:

u If it is a simple name, that is, just an Identifier, then the name of the methodis the Identifier. If the Identifier appears within the scope ($6.3) of a visible

method declaration with that name, then there must be an enclosing typedeclaration of which that method is a member. Let

T be the innermost suchtype declaration. The class or interface to search is
T.

u If it is a qualified name of the form TypeName . Identifier, then the name ofthe method is the Identifier and the class to search is the one named by the

TypeName. If TypeName is the name of an interface rather than a class, thena compile-time error occurs, because this form can invoke only

staticmethods and interfaces have no
static methods.

u In all other cases, the qualified name has the form FieldName . Identifier;then the name of the method is the Identifier and the class or interface to

search is the declared type of the field named by the FieldName.

* If the form is Primary . Identifier, then the name of the method is theIdentifier and the class or interface to be searched is the type of the Primary

expression.

* If the form is super . Identifier, then the name of the method is the Identifierand the class to be searched is the superclass of the class whose declaration

contains the method invocation. Let T be the type declaration immediatelyenclosing the method invocation. It is a compile-time error if any of the following situations occur:
u T is the class Object.
u T is an interface.

* If the form is ClassName.super . Identifier, then the name of the method isthe Identifier and the class to be searched is the superclass of the class

Cdenoted by ClassName. It is a compile-time error if
C is not a lexically enclos-ing class of the current class. It is a compile-time error if

C is the class
Object. Let T be the type declaration immediately enclosing the method invo-cation. It is a compile-time error if any of the following situations occur:

u T is the class Object.

EXPRESSIONS Compile-Time Step 2: Determine Method Signature 15.12.2

347DRAFT
u T is an interface.
15.12.2 Compile-Time Step 2: Determine Method Signature
The second step searches the class or interface determined in the previous step formethod declarations. This step uses the name of the method and the types of the
argument expressions to locate method declarations that are both applicable andaccessible, that is, declarations that can be correctly invoked on the given arguments. There may be more than one such method declaration, in which case themost specific one is chosen. The descriptor (signature plus return type) of the most
specific method declaration is one used at run time to do the method dispatch.

15.12.2.1 Find Methods that are Applicable and Accessible
A method declaration is applicable to a method invocation if and only if both ofthe following are true:

* The number of parameters in the method declaration equals the number ofargument expressions in the method invocation.

* The type of each actual argument can be converted by method invocation con-version ($5.3) to the type of the corresponding parameter. Method invocation

conversion is the same as assignment conversion ($5.2), except that constantsof type

int are never implicitly narrowed to byte, short, or char.

The class or interface determined by the process described in $15.12.1 issearched for all method declarations applicable to this method invocation; method
definitions inherited from superclasses and superinterfaces are included in thissearch.

Whether a method declaration is accessible ($6.6) at a method invocationdepends on the access modifier (

public, none, protected, or private) in themethod declaration and on where the method invocation appears.

If the class or interface has no method declaration that is both applicable andaccessible, then a compile-time error occurs.
In the example program:
public class Doubler {

static int two() { return two(1); }

private static int two(int i) { return 2*i; }
}

15.12.2 Compile-Time Step 2: Determine Method Signature EXPRESSIONS
348 DRAFT

class Test extends Doubler {

public static long two(long j) {return j+j; }

public static void main(String[] args) {

System.out.println(two(3));
System.out.println(Doubler.two(3)); // compile-time error
}

}
for the method invocation two(1) within class Doubler, there are two accessiblemethods named

two, but only the second one is applicable, and so that is the oneinvoked at run time. For the method invocation

two(3) within class Test, thereare two applicable methods, but only the one in class

Test is accessible, and sothat is the one to be invoked at run time (the argument

3 is converted to type
long). For the method invocation Doubler.two(3), the class Doubler, not class
Test, is searched for methods named two; the only applicable method is notaccessible, and so this method invocation causes a compile-time error.

Another example is:
class ColoredPoint {

int x, y;
byte color;
void setColor(byte color) { this.color = color; }
}

class Test {

public static void main(String[] args) {

ColoredPoint cp = new ColoredPoint();
byte color = 37;
cp.setColor(color);
cp.setColor(37); // compile-time error
}
}

Here, a compile-time error occurs for the second invocation of setColor, becauseno applicable method can be found at compile time. The type of the literal

37 is
int, and int cannot be converted to byte by method invocation conversion.Assignment conversion, which is used in the initialization of the variable

color,performs an implicit conversion of the constant from type
int to byte, which ispermitted because the value
37 is small enough to be represented in type byte; butsuch a conversion is not allowed for method invocation conversion.

If the method setColor had, however, been declared to take an int instead ofa
byte, then both method invocations would be correct; the first invocation wouldbe allowed because method invocation conversion does permit a widening conversion from byte to int. However, a narrowing cast would then be required in thebody of

setColor:

EXPRESSIONS Compile-Time Step 2: Determine Method Signature 15.12.2

349DRAFT
void setColor(int color) { this.color = (byte)color; }
15.12.2.2 Choose the Most Specific Method
If more than one method declaration is both accessible and applicable to a methodinvocation, it is necessary to choose one to provide the descriptor for the run-time

method dispatch. The Java programming language uses the rule that the most spe-cific method is chosen.

The informal intuition is that one method declaration is more specific thananother if any invocation handled by the first method could be passed on to the
other one without a compile-time type error.The precise definition is as follows. Let

m be a name and suppose that thereare two declarations of methods named
m , each having n parameters. Suppose thatone declaration appears within a class or interface

T and that the types of theparameters are
T1, . . . , Tn; suppose moreover that the other declaration appearswithin a class or interface

U and that the types of the parameters are U1, . . . , Un.Then the method
m declared in T is more specific than the method m declared in Uif and only if both of the following are true:

* T  can be converted to U  by method invocation conversion.

* Tj can be converted to Uj by method invocation conversion, for all j from 1to

n.

A method is said to be maximally specific for a method invocation if it isapplicable and accessible and there is no other applicable and accessible method
that is more specific.If there is exactly one maximally specific method, then it is in fact the most
specific method; it is necessarily more specific than any other method that is appli-cable and accessible. It is then subjected to some further compile-time checks as
described in $15.12.3.It is possible that no method is the most specific, because there are two or
more maximally specific methods. In this case:

* If all the maximally specific methods have the same signature, then:

u If one of the maximally specific methods is not declared abstract, it is themost specific method.

u Otherwise, all the maximally specific methods are necessarily declared

abstract. The most specific method is chosen arbitrarily among the maxi-mally specific methods. However, the most specific method is considered to

throw a checked exception if and only if that exception is declared in the
throws clauses of each of the maximally specific methods.

15.12.2 Compile-Time Step 2: Determine Method Signature EXPRESSIONS
350 DRAFT

* Otherwise, we say that the method invocation is ambiguous, and a compile-time error occurs.
15.12.2.3 Example: Overloading Ambiguity
Consider the example:

class Point { int x, y; }
class ColoredPoint extends Point { int color; }

class Test {

static void test(ColoredPoint p, Point q) {

System.out.println("(ColoredPoint, Point)");
}

static void test(Point p, ColoredPoint q) {

System.out.println("(Point, ColoredPoint)");
}

public static void main(String[] args) {

ColoredPoint cp = new ColoredPoint();
test(cp, cp); // compile-time error
}

}
This example produces an error at compile time. The problem is that there are twodeclarations of

test that are applicable and accessible, and neither is more spe-cific than the other. Therefore, the method invocation is ambiguous.

If a third definition of test were added:

static void test(ColoredPoint p, ColoredPoint q) {

System.out.println("(ColoredPoint, ColoredPoint)");
}

then it would be more specific than the other two, and the method invocationwould no longer be ambiguous.

15.12.2.4 Example: Return Type Not Considered
As another example, consider:

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {

EXPRESSIONS Compile-Time Step 2: Determine Method Signature 15.12.2

351DRAFT
static int test(ColoredPoint p) {

return p.color;
}

static String test(Point p) {

return "Point";
}

public static void main(String[] args) {

ColoredPoint cp = new ColoredPoint();
String s = test(cp); // compile-time error
}

}
Here the most specific declaration of method test is the one taking a parameterof type

ColoredPoint. Because the result type of the method is int, a compile-time error occurs because an

int cannot be converted to a String by assignmentconversion. This example shows that the result types of methods do not participate

in resolving overloaded methods, so that the second test method, which returns a
String, is not chosen, even though it has a result type that would allow the exam-ple program to compile without error.

15.12.2.5 Example: Compile-Time Resolution
The most applicable method is chosen at compile time; its descriptor determineswhat method is actually executed at run time. If a new method is added to a class,

then source code that was compiled with the old definition of the class might notuse the new method, even if a recompilation would cause this method to be chosen.So, for example, consider two compilation units, one for class

Point:

package points;
public class Point {

public int x, y;

public Point(int x, int y) { this.x = x; this.y = y; }
public String toString() { return toString(""); }
public String toString(String s) {

return "(" + x + "," + y + s + ")";
}

}
and one for class ColoredPoint:

15.12.2 Compile-Time Step 2: Determine Method Signature EXPRESSIONS
352 DRAFT

package points;
public class ColoredPoint extends Point {

public static final int

RED = 0, GREEN = 1, BLUE = 2;

public static String[] COLORS =

{ "red", "green", "blue" };

public byte color;
public ColoredPoint(int x, int y, int color) {

super(x, y); this.color = (byte)color;
}

/** Copy all relevant fields of the argument intothis

ColoredPoint object. */
public void adopt(Point p) { x = p.x; y = p.y; }

public String toString() {

String s = "," + COLORS[color];
return super.toString(s);
}

}
Now consider a third compilation unit that uses ColoredPoint:

import points.*;
class Test {

public static void main(String[] args) {

ColoredPoint cp =

new ColoredPoint(6, 6, ColoredPoint.RED);
ColoredPoint cp2 =

new ColoredPoint(3, 3, ColoredPoint.GREEN);
cp.adopt(cp2);
System.out.println("cp: " + cp);
}
}

The output is:

cp: (3,3,red)
The application programmer who coded class Test has expected to see theword

green, because the actual argument, a ColoredPoint, has a color field,and
color would seem to be a "relevant field" (of course, the documentation forthe package

Points ought to have been much more precise!).Notice, by the way, that the most specific method (indeed, the only applicable

method) for the method invocation of adopt has a signature that indicates a

EXPRESSIONS Compile-Time Step 2: Determine Method Signature 15.12.2

353DRAFT
method of one parameter, and the parameter is of type Point. This signaturebecomes part of the binary representation of class

Test produced by the compilerand is used by the method invocation at run time.

Suppose the programmer reported this software error and the maintainer ofthe

points package decided, after due deliberation, to correct it by adding amethod to class

ColoredPoint:

public void adopt(ColoredPoint p) {

adopt((Point)p); color = p.color;
}

If the application programmer then runs the old binary file for Test with thenew binary file for

ColoredPoint, the output is still:

cp: (3,3,red)
because the old binary file for Test still has the descriptor "one parameter, whosetype is

Point; void" associated with the method call cp.adopt(cp2). If thesource code for

Test is recompiled, the compiler will then discover that there arenow two applicable

adopt methods, and that the signature for the more specificone is "one parameter, whose type is

ColoredPoint; void"; running the programwill then produce the desired output:

cp: (3,3,green)
With forethought about such problems, the maintainer of the points packagecould fix the

ColoredPoint class to work with both newly compiled and oldcode, by adding defensive code to the old

adopt method for the sake of old codethat still invokes it on
ColoredPoint arguments:

public void adopt(Point p) {

if (p instanceof ColoredPoint)

color = ((ColoredPoint)p).color;
x = p.x; y = p.y;
}

Ideally, source code should be recompiled whenever code that it depends on ischanged. However, in an environment where different classes are maintained by

different organizations, this is not always feasible. Defensive programming withcareful attention to the problems of class evolution can make upgraded code much
more robust. See $13 for a detailed discussion of binary compatibility and typeevolution.

15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate? EXPRESSIONS

354 DRAFT

15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?
If there is a most specific method declaration for a method invocation, it is calledthe compile-time declaration for the method invocation. Three further checks

must be made on the compile-time declaration:

* If the method invocation has, before the left parenthesis, a MethodName ofthe form Identifier, and the method is an instance method, then:

u If the invocation appears within a static context ($8.1.2), then a compile-time error occurs. (The reason is that a method invocation of this form cannot be used to invoke an instance method in places where this ($15.8.3) isnot defined.)

u Otherwise, let C be the innermost enclosing class of which the method is amember. If the invocation is not directly enclosed by

C or an inner class of
C, then a compile-time error occurs

* If the method invocation has, before the left parenthesis, a MethodName ofthe form TypeName

. Identifier, then the compile-time declaration should be
static. If the compile-time declaration for the method invocation is for aninstance method, then a compile-time error occurs. (The reason is that a

method invocation of this form does not specify a reference to an object thatcan serve as

this within the instance method.)

* If the method invocation has, before the left parenthesis, a MethodName of theform

super . Identifier, then:

u If the method is abstract, a compile-time error occurs
u If the method invocation occurs in a static context, a compile-time erroroccurs

* If the method invocation has, before the left parenthesis, a MethodName of theform ClassName

.super . Identifier, then:

u If the method is abstract, a compile-time error occurs
u If the method invocation occurs in a static context, a compile-time erroroccurs

u Otherwise, let C be the class denoted by ClassName. If the invocation is notdirectly enclosed by

C or an inner class of C, then a compile-time erroroccurs

* If the compile-time declaration for the method invocation is void, then themethod invocation must be a top-level expression, that is, the Expression in an

EXPRESSIONS Runtime Evaluation of Method Invocation 15.12.4

355DRAFT
expression statement ($14.8) or in the ForInit or ForUpdate part of a forstatement ($14.13), or a compile-time error occurs. (The reason is that such a
method invocation produces no value and so must be used only in a situationwhere a value is not needed.)

The following compile-time information is then associated with the methodinvocation for use at run time:

* The name of the method.

* The qualifying type of the method invocation ($13.1).

* The number of parameters and the types of the parameters, in order.

* The result type, or void, as declared in the compile-time declaration.

* The invocation mode, computed as follows:

u If the compile-time declaration has the static modifier, then the invocationmode is

static.

u Otherwise, if the compile-time declaration has the private modifier, thenthe invocation mode is

nonvirtual.

u Otherwise, if the part of the method invocation before the left parenthesis isof the form

super . Identifier or of the form ClassName.super.Identifierthen the invocation mode is

super.

u Otherwise, if the compile-time declaration is in an interface, then the invo-cation mode is

interface.

u Otherwise, the invocation mode is virtual.
If the compile-time declaration for the method invocation is not void, thenthe type of the method invocation expression is the result type specified in the

compile-time declaration.

15.12.4   Runtime Evaluation of Method Invocation
At run time, method invocation requires five steps. First, a target reference may becomputed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the methodto be executed is located. Fifth, a new activation frame is created, synchronization
is performed if necessary, and control is transferred to the method code.

15.12.4 Runtime Evaluation of Method Invocation EXPRESSIONS

356 DRAFT

15.12.4.1 Compute Target Reference (If Necessary)
There are several cases to consider, depending on which of the four productionsfor MethodInvocation ($15.12) is involved:

* If the first production for MethodInvocation, which includes a MethodName,is involved, then there are three subcases:

u If the MethodName is a simple name, that is, just an Identifier, then there aretwo subcases:

v If the invocation mode is static, then there is no target reference.
v Otherwise, let T be the enclosing type declaration of which the method isa member, and let n be an integer such that

T is the nth lexically enclosingtype declaration ($8.1.2) of the class whose declaration immediately contains the method invocation. Then the target reference is the nth lexicallyenclosing instance ($8.1.2) of

this. It is a compile-time error if the nthlexically enclosing instance ($8.1.2) of

this does not exist.

u If the MethodName is a qualified name of the form TypeName . Identifier,then there is no target reference.

u If the MethodName is a qualified name of the form FieldName . Identifier,then there are two subcases:

v If the invocation mode is static, then there is no target reference.
v Otherwise, the target reference is the value of the expression FieldName.

* If the second production for MethodInvocation, which includes a Primary, isinvolved, then there are two subcases:

u If the invocation mode is static, then there is no target reference. Theexpression Primary is evaluated, but the result is then discarded.
u Otherwise, the expression Primary is evaluated and the result is used as thetarget reference.
In either case, if the evaluation of the Primary expression completes abruptly,then no part of any argument expression appears to have been evaluated, and
the method invocation completes abruptly for the same reason.

* If the third production for MethodInvocation, which includes the keyword

super, is involved, then the target reference is the value of this.

* If the fourth production for MethodInvocation, ClassName.super, is involved,then the target reference is the value of ClassName.

this.

EXPRESSIONS Runtime Evaluation of Method Invocation 15.12.4

357DRAFT
15.12.4.2 Evaluate Arguments
The argument expressions are evaluated in order, from left to right. If the evalua-tion of any argument expression completes abruptly, then no part of any argument

expression to its right appears to have been evaluated, and the method invocationcompletes abruptly for the same reason.

15.12.4.3 Check Accessibility of Type and Method
Let C be the class containing the method invocation, and let T be the qualifyingtype of the method invocation ($13.1), and

m be the name of the method, as deter-mined at compile time ($15.12.3). An implementation of the Java programming

language must insure, as part of linkage, that the method m still exists in the type
T. If this is not true, then a NoSuchMethodError (which is a subclass of IncompatibleClassChangeError) occurs. If the invocation mode is interface, thenthe implementation must also check that the target reference type still implements

the specified interface. If the target reference type does not still implement theinterface, then an

IncompatibleClassChangeError occurs.The implementation must also insure, during linkage, that the type

T and themethod
m are accessible. For the type T:

* If T is in the same package as C, then T is accessible.

* If T is in a different package than C, and T is public, then T is accessible.

* If T is in a different package than C, and T is protected, then T is accessibleif and only if

C is a subclass of T.

For the method m:

* If m is public, then m is accessible. (All members of interfaces are public($9.2)).

* If m is protected, then m is accessible if and only if either T is in the samepackage as

C, or C is T or a subclass of T.

* If m has default (package) access, then m is accessible if and only if T is in thesame package as

C.

* If m is private, then m is accessible if and only if C is T, or C encloses T, or Tencloses

C, or T and C are both enclosed by a third class.

If either T or m is not accessible, then an IllegalAccessError occurs ($12.3).

15.12.4 Runtime Evaluation of Method Invocation EXPRESSIONS

358 DRAFT

15.12.4.4 Locate Method to Invoke
The strategy for method lookup depends on the invocation mode.If the invocation mode is

static, no target reference is needed and overridingis not allowed. Method
m of class T is the one to be invoked.Otherwise, an instance method is to be invoked and there is a target reference.

If the target reference is null, a NullPointerException is thrown at this point.Otherwise, the target reference is said to refer to a target object and will be used as
the value of the keyword this in the invoked method. The other four possibilitiesfor the invocation mode are then considered.

If the invocation mode is nonvirtual, overriding is not allowed. Method m ofclass

T is the one to be invoked.Otherwise, the invocation mode is

interface, virtual, or super, and over-riding may occur. A dynamic method lookup is used. The dynamic lookup process

starts from a class S, determined as follows:

* If the invocation mode is interface or virtual, then S is initially the actualrun-time class

R of the target object. This is true even if the target object is anarray instance. (Note that for invocation mode

interface, R necessarilyimplements
T; for invocation mode virtual, R is necessarily either T or asubclass of
T.)

* If the invocation mode is super, then S is initially the qualifying type ($13.1)of the method invocation.

The dynamic method lookup uses the following procedure to search class S, andthen the superclasses of class

S, as necessary, for method m.Let
X be the compile-time type of the target reference of the method invoca-tion.

1. If class S contains a declaration for a non-abstract method named m with thesame descriptor (same number of parameters, the same parameter types, and

the same return type) required by the method invocation as determined at com-pile time ($15.12.3), then:

u If the invocation mode is super or interface, then this is the method to beinvoked, and the procedure terminates.
u If the invocation mode is virtual, and the declaration in S overrides($8.4.6.1)

X.m, then the method declared in S is the method to be invoked,and the procedure terminates.

2. Otherwise, if S has a superclass, this same lookup procedure is performedrecursively using the direct superclass of

S in place of S; the method to beinvoked is the result of the recursive invocation of this lookup procedure.

EXPRESSIONS Runtime Evaluation of Method Invocation 15.12.4

359DRAFT
The above procedure will always find a non-abstract, accessible method toinvoke, provided that all classes and interfaces in the program have been consistently compiled. However, if this is not the case, then various errors may occur.The specification of the behavior of a Java virtual machine under these circumstances is given by The Java Virtual Machine Specification, Second Edition.We note that the dynamic lookup process, while described here explicitly, will
often be implemented implicitly, for example as a side-effect of the constructionand use of per-class method dispatch tables, or the construction of other per-class
structures used for efficient dispatch.
15.12.4.5 Create Frame, Synchronize, Transfer Control
A method m in some class S has been identified as the one to be invoked.Now a new activation frame is created, containing the target reference (if any)

and the argument values (if any), as well as enough space for the local variablesand stack for the method to be invoked and any other bookkeeping information
that may be required by the implementation (stack pointer, program counter, refer-ence to previous activation frame, and the like). If there is not sufficient memory
available to create such an activation frame, an OutOfMemoryError is thrown.The newly created activation frame becomes the current activation frame. The
effect of this is to assign the argument values to corresponding freshly createdparameter variables of the method, and to make the target reference available as
this, if there is a target reference. Before each argument value is assigned to itscorresponding parameter variable, it is subjected to method invocation conversion
($5.3), which includes any required value set conversion ($5.1.8).If the method

m is a native method but the necessary native, implementation-dependent binary code has not been loaded or otherwise cannot be dynamically

linked, then an UnsatisfiedLinkError is thrown.If the method

m is not synchronized, control is transferred to the body of themethod
m to be invoked.If the method

m is synchronized, then an object must be locked before thetransfer of control. No further progress can be made until the current thread can

obtain the lock. If there is a target reference, then the target must be locked; other-wise the

Class object for class S, the class of the method m, must be locked. Con-trol is then transferred to the body of the method

m to be invoked. The object isautomatically unlocked when execution of the body of the method has completed,

whether normally or abruptly. The locking and unlocking behavior is exactly as ifthe body of the method were embedded in a

synchronized statement ($14.18).

15.12.4 Runtime Evaluation of Method Invocation EXPRESSIONS

360 DRAFT

15.12.4.6 Example: Target Reference and Static Methods
When a target reference is computed and then discarded because the invocationmode is

static, the reference is not examined to see whether it is null:

class Test {

static void mountain() {

System.out.println("Monadnock");
}

static Test favorite(){

System.out.print("Mount ");
return null;
}

public static void main(String[] args) {

favorite().mountain();
}

}
which prints:

Mount Monadnock
Here favorite returns null, yet no NullPointerException is thrown.

15.12.4.7 Example: Evaluation Order
As part of an instance method invocation ($15.12), there is an expression thatdenotes the object to be invoked. This expression appears to be fully evaluated

before any part of any argument expression to the method invocation is evaluated.So, for example, in:

class Test {

public static void main(String[] args) {

String s = "one";
if (s.startsWith(s = "two"))

System.out.println("oops");
}
}

the occurrence of s before ".startsWith" is evaluated first, before the argumentexpression

s="two". Therefore, a reference to the string "one" is remembered asthe target reference before the local variable

s is changed to refer to the string
"two". As a result, the startsWith method is invoked for target object "one"with argument

"two", so the result of the invocation is false, as the string "one"does not start with

"two". It follows that the test program does not print "oops".

EXPRESSIONS Runtime Evaluation of Method Invocation 15.12.4

361DRAFT
15.12.4.8 Example: Overriding
In the example:

class Point {

final int EDGE = 20;
int x, y;

void move(int dx, int dy) {

x += dx; y += dy;
if (Math.abs(x) >= EDGE || Math.abs(y) >= EDGE)

clear();
}

void clear() {

System.out.println("\tPoint clear");
x = 0; y = 0;
}

}
class ColoredPoint extends Point {

int color;

void clear() {

System.out.println("\tColoredPoint clear");
super.clear();
color = 0;
}

}
the subclass ColoredPoint extends the clear abstraction defined by its super-class

Point. It does so by overriding the clear method with its own method,which invokes the

clear method of its superclass, using the form super.clear.This method is then invoked whenever the target object for an invocation of

clear is a ColoredPoint. Even the method move in Point invokes the clearmethod of class

ColoredPoint when the class of this is ColoredPoint, asshown by the output of this test program:

class Test {

public static void main(String[] args) {

Point p = new Point();
System.out.println("p.move(20,20):");
p.move(20, 20);
ColoredPoint cp = new ColoredPoint();
System.out.println("cp.move(20,20):");
cp.move(20, 20);
p = new ColoredPoint();
System.out.println("p.move(20,20), p colored:");

15.12.4 Runtime Evaluation of Method Invocation EXPRESSIONS
362 DRAFT

p.move(20, 20);
}
}

which is:

p.move(20,20):

Point clear
cp.move(20,20):

ColoredPoint clear
Point clear
p.move(20,20), p colored:

ColoredPoint clear
Point clear

Overriding is sometimes called "late-bound self-reference"; in this example itmeans that the reference to

clear in the body of Point.move (which is reallysyntactic shorthand for
this.clear) invokes a method chosen "late" (at run time,based on the run-time class of the object referenced by

this) rather than a methodchosen "early" (at compile time, based only on the type of

this). This providesthe programmer a powerful way of extending abstractions and is a key idea in

object-oriented programming.
15.12.4.9 Example: Method Invocation using super
An overridden instance method of a superclass may be accessed by using the key-word

super to access the members of the immediate superclass, bypassing anyoverriding declaration in the class that contains the method invocation.

When accessing an instance variable, super means the same as a cast of this($15.11.2), but this equivalence does not hold true for method invocation. This is
demonstrated by the example:

class T1 {

String s() { return "1"; }
}

class T2 extends T1 {

String s() { return "2"; }
}

class T3 extends T2 {

String s() { return "3"; }

void test() {

System.out.println("s()=\t\t"+s());
System.out.println("super.s()=\t"+super.s());
System.out.print("((T2)this).s()=\t");

System.out.println(((T2)this).s());

EXPRESSIONS Array Access Expressions 15.13

363DRAFT
System.out.print("((T1)this).s()=\t");

System.out.println(((T1)this).s());
}

}
class Test {

public static void main(String[] args) {

T3 t3 = new T3();
t3.test();
}
}

which produces the output:

s()= 3
super.s()= 2
((T2)this).s()= 3
((T1)this).s()= 3

The casts to types T1 and T2 do not change the method that is invoked,because the instance method to be invoked is chosen according to the run-time

class of the object referred to be this. A cast does not change the class of anobject; it only checks that the class is compatible with the specified type.

15.13 Array Access Expressions
An array access expression refers to a variable that is a component of an array.

ArrayAccess:ExpressionName

 [ Expression ]PrimaryNoNewArray

 [ Expression ]

An array access expression contains two subexpressions, the array referenceexpression (before the left bracket) and the index expression (within the brackets).

Note that the array reference expression may be a name or any primary expressionthat is not an array creation expression ($15.10).

The type of the array reference expression must be an array type (call it T[],an array whose components are of type

T ) or a compile-time error results. Thenthe type of the array access expression is

T.The index expression undergoes unary numeric promotion ($5.6.1); the promoted type must be int.The result of an array reference is a variable of type

T, namely the variablewithin the array selected by the value of the index expression. This resulting variable, which is a component of the array, is never considered final, even if thearray reference was obtained from a

final variable.

15.13.1 Runtime Evaluation of Array Access EXPRESSIONS
364 DRAFT

15.13.1   Runtime Evaluation of Array Access
An array access expression is evaluated using the following procedure:

* First, the array reference expression is evaluated. If this evaluation completesabruptly, then the array access completes abruptly for the same reason and the

index expression is not evaluated.

* Otherwise, the index expression is evaluated. If this evaluation completesabruptly, then the array access completes abruptly for the same reason.

* Otherwise, if the value of the array reference expression is null, then a

NullPointerException is thrown.

* Otherwise, the value of the array reference expression indeed refers to anarray. If the value of the index expression is less than zero, or greater than or

equal to the array's length, then an ArrayIndexOutOfBoundsException isthrown.

* Otherwise, the result of the array access is the variable of type T, within thearray, selected by the value of the index expression. (Note that this resulting

variable, which is a component of the array, is never considered final, evenif the array reference expression is a

final variable.)

15.13.2 Examples: Array Access Evaluation Order
In an array access, the expression to the left of the brackets appears to be fullyevaluated before any part of the expression within the brackets is evaluated. For

example, in the (admittedly monstrous) expression a[(a=b)[3]], the expression
a is fully evaluated before the expression (a=b)[3]; this means that the originalvalue of

a is fetched and remembered while the expression (a=b)[3] is evalu-ated. This array referenced by the original value of

a is then subscripted by a valuethat is element
3 of another array (possibly the same array) that was referenced by
b and is now also referenced by a.Thus, the example:

class Test {

public static void main(String[] args) {

int[] a = { 11, 12, 13, 14 };
int[] b = { 0, 1, 2, 3 };
System.out.println(a[(a=b)[3]]);
}
}

prints:

14

EXPRESSIONS Examples: Array Access Evaluation Order 15.13.2

365DRAFT
because the monstrous expression's value is equivalent to a[b[3]] or a[3] or 14.If evaluation of the expression to the left of the brackets completes abruptly,
no part of the expression within the brackets will appear to have been evaluated.Thus, the example:

class Test {

public static void main(String[] args) {

int index = 1;
try {

skedaddle()[index=2]++;
} catch (Exception e) {

System.out.println(e + ", index=" + index);
}
}
static int[] skedaddle() throws Exception {

throw new Exception("Ciao");
}
}

prints:

java.lang.Exception: Ciao, index=1
because the embedded assignment of 2 to index never occurs.If the array reference expression produces

null instead of a reference to anarray, then a
NullPointerException is thrown at run time, but only after allparts of the array access expression have been evaluated and only if these evaluations completed normally. Thus, the example:

class Test {

public static void main(String[] args) {

int index = 1;
try {

nada()[index=2]++;
} catch (Exception e) {

System.out.println(e + ", index=" + index);
}
}

static int[] nada() { return null; }
}
prints:

java.lang.NullPointerException, index=2
because the embedded assignment of 2 to index occurs before the check for a nullpointer. As a related example, the program:

15.14 Postfix Expressions EXPRESSIONS

366 DRAFT

class Test {

public static void main(String[] args) {

int[] a = null;
try {

int i = a[vamoose()];
System.out.println(i);
} catch (Exception e) {

System.out.println(e);
}
}

static int vamoose() throws Exception {

throw new Exception("Twenty-three skidoo!");
}

}
always prints:

java.lang.Exception: Twenty-three skidoo!
A NullPointerException never occurs, because the index expression mustbe completely evaluated before any part of the indexing operation occurs, and that

includes the check as to whether the value of the left-hand operand is null.

15.14 Postfix Expressions
Postfix expressions include uses of the postfix ++ and -- operators. Also, as dis-cussed in $15.8, names are not considered to be primary expressions, but are handled separately in the grammar to avoid certain ambiguities. They becomeinterchangeable only here, at the level of precedence of postfix expressions.

PostfixExpression:Primary

ExpressionNamePostIncrementExpression
PostDecrementExpression

15.14.1   Postfix Increment Operator ++

PostIncrementExpression:PostfixExpression

 ++

A postfix expression followed by a ++ operator is a postfix increment expres-sion. The result of the postfix expression must be a variable of a numeric type, or a

EXPRESSIONS Postfix Decrement Operator -- 15.14.2

367DRAFT
compile-time error occurs. The type of the postfix increment expression is thetype of the variable. The result of the postfix increment expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then
the postfix increment expression completes abruptly for the same reason and noincrementation occurs. Otherwise, the value

1 is added to the value of the variableand the sum is stored back into the variable. Before the addition, binary numeric

promotion ($5.6.2) is performed on the value 1 and the value of the variable. Ifnecessary, the sum is narrowed by a narrowing primitive conversion ($5.1.3) to
the type of the variable before it is stored. The value of the postfix incrementexpression is the value of the variable before the new value is stored.

Note that the binary numeric promotion mentioned above may include valueset conversion ($5.1.8). If necessary, value set conversion is applied to the sum
prior to its being stored in the variable.A variable that is declared

final cannot be incremented, because when anaccess of a
final variable is used as an expression, the result is a value, not avariable. Thus, it cannot be used as the operand of a postfix increment operator.

15.14.2   Postfix Decrement Operator --

PostDecrementExpression:PostfixExpression

 --

A postfix expression followed by a -- operator is a postfix decrement expres-sion. The result of the postfix expression must be a variable of a numeric type, or a

compile-time error occurs. The type of the postfix decrement expression is thetype of the variable. The result of the postfix decrement expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then
the postfix decrement expression completes abruptly for the same reason and nodecrementation occurs. Otherwise, the value

1 is subtracted from the value of thevariable and the difference is stored back into the variable. Before the subtraction,

binary numeric promotion ($5.6.2) is performed on the value 1 and the value ofthe variable. If necessary, the difference is narrowed by a narrowing primitive conversion ($5.1.3) to the type of the variable before it is stored. The value of thepostfix decrement expression is the value of the variable before the new value is
stored.Note that the binary numeric promotion mentioned above may include value
set conversion ($5.1.8). If necessary, value set conversion is applied to the differ-ence prior to its being stored in the variable.

15.15 Unary Operators EXPRESSIONS

368 DRAFT

A variable that is declared final cannot be decremented, because when anaccess of a

final variable is used as an expression, the result is a value, not avariable. Thus, it cannot be used as the operand of a postfix decrement operator.

15.15   Unary Operators
The unary operators include +, -, ++, --, ~, !, and cast operators. Expressionswith unary operators group right-to-left, so that

-~x means the same as -(~x).

UnaryExpression:PreIncrementExpression

PreDecrementExpression
+ UnaryExpression
- UnaryExpressionUnaryExpressionNotPlusMinus

PreIncrementExpression:

++ UnaryExpression

PreDecrementExpression:

-- UnaryExpression

UnaryExpressionNotPlusMinus:PostfixExpression

~ UnaryExpression
! UnaryExpressionCastExpression

The following productions from $15.16 are repeated here for convenience:

CastExpression:

( PrimitiveType ) UnaryExpression
( ReferenceType ) UnaryExpressionNotPlusMinus

15.15.1   Prefix Increment Operator ++
A unary expression preceded by a ++ operator is a prefix increment expression.The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix increment expression is the type ofthe variable. The result of the prefix increment expression is not a variable, but a
value.At run time, if evaluation of the operand expression completes abruptly, then
the prefix increment expression completes abruptly for the same reason and no

EXPRESSIONS Unary Plus Operator + 15.15.3

369DRAFT
incrementation occurs. Otherwise, the value 1 is added to the value of the variableand the sum is stored back into the variable. Before the addition, binary numeric
promotion ($5.6.2) is performed on the value 1 and the value of the variable. Ifnecessary, the sum is narrowed by a narrowing primitive conversion ($5.1.3) to
the type of the variable before it is stored. The value of the prefix incrementexpression is the value of the variable after the new value is stored.

Note that the binary numeric promotion mentioned above may include valueset conversion ($5.1.8). If necessary, value set conversion is applied to the sum
prior to its being stored in the variable.A variable that is declared

final cannot be incremented, because when anaccess of a
final variable is used as an expression, the result is a value, not avariable. Thus, it cannot be used as the operand of a prefix increment operator.

15.15.2   Prefix Decrement Operator --
A unary expression preceded by a -- operator is a prefix decrement expression.The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix decrement expression is the type ofthe variable. The result of the prefix decrement expression is not a variable, but a
value.At run time, if evaluation of the operand expression completes abruptly, then
the prefix decrement expression completes abruptly for the same reason and nodecrementation occurs. Otherwise, the value

1 is subtracted from the value of thevariable and the difference is stored back into the variable. Before the subtraction,

binary numeric promotion ($5.6.2) is performed on the value 1 and the value ofthe variable. If necessary, the difference is narrowed by a narrowing primitive conversion ($5.1.3) to the type of the variable before it is stored. The value of the pre-fix decrement expression is the value of the variable after the new value is stored.

Note that the binary numeric promotion mentioned above may include valueset conversion ($5.1.8). If necessary, format conversion is applied to the difference
prior to its being stored in the variable.A variable that is declared

final cannot be decremented, because when anaccess of a
final variable is used as an expression, the result is a value, not avariable. Thus, it cannot be used as the operand of a prefix decrement operator.

15.15.3   Unary Plus Operator +
The type of the operand expression of the unary + operator must be a primitivenumeric type, or a compile-time error occurs. Unary numeric promotion ($5.6.1)

is performed on the operand. The type of the unary plus expression is the pro15.15.4 Unary Minus Operator - EXPRESSIONS
370 DRAFT

moted type of the operand. The result of the unary plus expression is not a vari-able, but a value, even if the result of the operand expression is a variable.

At run time, the value of the unary plus expression is the promoted value ofthe operand.

15.15.4   Unary Minus Operator The type of the operand expression of the unary - operator must be a primitivenumeric type, or a compile-time error occurs. Unary numeric promotion ($5.6.1)

is performed on the operand. The type of the unary minus expression is the pro-moted type of the operand.

Note that unary numeric promotion performs value set conversion ($5.1.8).Whatever value set the promoted operand value is drawn from, the unary negation
operation is carried out and the result is drawn from that same value set. Thatresult is then subject to further value set conversion.

At run time, the value of the unary minus expression is the arithmetic negationof the promoted value of the operand.
For integer values, negation is the same as subtraction from zero. The Javaprogramming language uses two's-complement representation for integers, and
the range of two's-complement values is not symmetric, so negation of the maxi-mum negative

int or long results in that same maximum negative number. Over-flow occurs in this case, but no exception is thrown. For all integer values

x, -xequals
(~x)+1.For floating-point values, negation is not the same as subtraction from zero,

because if x is +0.0, then 0.0-x is +0.0, but -x is -0.0. Unary minus merelyinverts the sign of a floating-point number. Special cases of interest:

* If the operand is NaN, the result is NaN (recall that NaN has no sign).

* If the operand is an infinity, the result is the infinity of opposite sign.

* If the operand is a zero, the result is the zero of opposite sign.

15.15.5   Bitwise Complement Operator ~
The type of the operand expression of the unary ~ operator must be a primitiveintegral type, or a compile-time error occurs. Unary numeric promotion ($5.6.1) is

performed on the operand. The type of the unary bitwise complement expressionis the promoted type of the operand.

At run time, the value of the unary bitwise complement expression is the bit-wise complement of the promoted value of the operand; note that, in all cases,
~x equals (-x)-1.

EXPRESSIONS Cast Expressions 15.16

371DRAFT
15.15.6   Logical Complement Operator !
The type of the operand expression of the unary ! operator must be boolean, or acompile-time error occurs. The type of the unary logical complement expression

is boolean.At run time, the value of the unary logical complement expression is

true ifthe operand value is
false and false if the operand value is true.

15.16   Cast Expressions
A cast expression converts, at run time, a value of one numeric type to a similarvalue of another numeric type; or confirms, at compile time, that the type of an
expression is boolean; or checks, at run time, that a reference value refers to anobject whose class is compatible with a specified reference type.

CastExpression:

( PrimitiveType Dimsopt ) UnaryExpression
( ReferenceType ) UnaryExpressionNotPlusMinus

See $15.15 for a discussion of the distinction between UnaryExpression andUnaryExpressionNotPlusMinus.

The type of a cast expression is the type whose name appears within theparentheses. (The parentheses and the type they contain are sometimes called the
cast operator.) The result of a cast expression is not a variable, but a value, even ifthe result of the operand expression is a variable.

A cast operator has no effect on the choice of value set ($4.2.3) for a value oftype

float or type double. Consequently, a cast to type float within an expres-sion that is not FP-strict ($15.4) does not necessarily cause its value to be converted

to an element of the float value set, and a cast to type double within an expressionthat is not FP-strict does not necessarily cause its value to be converted to an element of the double value set.At run time, the operand value is converted by casting conversion ($5.5) to the
type specified by the cast operator.Not all casts are permitted by the language. Some casts result in an error at
compile time. For example, a primitive value may not be cast to a reference type.Some casts can be proven, at compile time, always to be correct at run time. For
example, it is always correct to convert a value of a class type to the type of itssuperclass; such a cast should require no special action at run time. Finally, some
casts cannot be proven to be either always correct or always incorrect at compiletime. Such casts require a test at run time.

15.17 Multiplicative Operators EXPRESSIONS

372 DRAFT

A ClassCastException is thrown if a cast is found at run time to be imper-missible.
15.17   Multiplicative Operators
The operators *, /, and % are called the multiplicative operators. They have thesame precedence and are syntactically left-associative (they group left-to-right).

MultiplicativeExpression:UnaryExpression

MultiplicativeExpression * UnaryExpressionMultiplicativeExpression

 / UnaryExpressionMultiplicativeExpression
 % UnaryExpression

The type of each of the operands of a multiplicative operator must be a primi-tive numeric type, or a compile-time error occurs. Binary numeric promotion is

performed on the operands ($5.6.2). The type of a multiplicative expression is thepromoted type of its operands. If this promoted type is

int or long, then integerarithmetic is performed; if this promoted type is
float or double, then floating-point arithmetic is performed.

Note that binary numeric promotion performs value set conversion ($5.1.8).

15.17.1   Multiplication Operator *
The binary * operator performs multiplication, producing the product of its oper-ands. Multiplication is a commutative operation if the operand expressions have

no side effects. While integer multiplication is associative when the operands areall of the same type, floating-point multiplication is not associative.

If an integer multiplication overflows, then the result is the low-order bits ofthe mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not bethe same as the sign of the mathematical product of the two operand values.

The result of a floating-point multiplication is governed by the rules of IEEE754 arithmetic:

* If either operand is NaN, the result is NaN.

* If the result is not NaN, the sign of the result is positive if both operands havethe same sign, and negative if the operands have different signs.

* Multiplication of an infinity by a zero results in NaN.

EXPRESSIONS Division Operator / 15.17.2

373DRAFT

* Multiplication of an infinity by a finite value results in a signed infinity. Thesign is determined by the rule stated above.

* In the remaining cases, where neither an infinity nor NaN is involved, theexact mathematical product is computed. A floating-point value set is then

chosen:
u If the multiplication expression is FP-strict ($15.4):

v If the type of the multiplication expression is float, then the float valueset must be chosen.

v If the type of the multiplication expression is double, then the doublevalue set must be chosen.

u If the multiplication expression is not FP-strict:

v If the type of the multiplication expression is float, then either the floatvalue set or the float-extended-exponent value set may be chosen, at the

whim of the implementation.
v If the type of the multiplication expression is double, then either the dou-ble value set or the double-extended-exponent value set may be chosen, at

the whim of the implementation.
Next, a value must be chosen from the chosen value set to represent the prod-uct. If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. Otherwise,the product is rounded to the nearest value in the chosen value set using IEEE
754 round-to-nearest mode. The Java programming language requires supportof gradual underflow as defined by IEEE 754 ($4.2.4).

Despite the fact that overflow, underflow, or loss of information may occur,evaluation of a multiplication operator

* never throws a run-time exception.

15.17.2   Division Operator /
The binary / operator performs division, producing the quotient of its operands.The left-hand operand is the dividend and the right-hand operand is the divisor.

Integer division rounds toward 0. That is, the quotient produced for operandsn and d that are integers after binary numeric promotion ($5.6.2) is an integer
value q whose magnitude is as large as possible while satisfying ;moreover, q is positive when and n and d have the same sign, but q is negative when and n and d have opposite signs. There is one special case thatdoes not satisfy this rule: if the dividend is the negative integer of largest possible

d qOE n<=n d>=
n d>=

15.17.2 Division Operator / EXPRESSIONS
374 DRAFT

magnitude for its type, and the divisor is -1, then integer overflow occurs and theresult is equal to the dividend. Despite the overflow, no exception is thrown in this
case. On the other hand, if the value of the divisor in an integer division is 0, thenan

ArithmeticException is thrown.The result of a floating-point division is determined by the specification of

IEEE arithmetic:

* If either operand is NaN, the result is NaN.

* If the result is not NaN, the sign of the result is positive if both operands havethe same sign, negative if the operands have different signs.

* Division of an infinity by an infinity results in NaN.

* Division of an infinity by a finite value results in a signed infinity. The sign isdetermined by the rule stated above.

* Division of a finite value by an infinity results in a signed zero. The sign isdetermined by the rule stated above.

* Division of a zero by a zero results in NaN; division of zero by any other finitevalue results in a signed zero. The sign is determined by the rule stated above.

* Division of a nonzero finite value by a zero results in a signed infinity. Thesign is determined by the rule stated above.

* In the remaining cases, where neither an infinity nor NaN is involved, theexact mathematical quotient is computed. A floating-point value set is then

chosen:
u If the division expression is FP-strict ($15.4):

v If the type of the division expression is float, then the float value setmust be chosen.

v If the type of the division expression is double, then the double value setmust be chosen.

u If the division expression is not FP-strict:

v If the type of the division expression is float, then either the float valueset or the float-extended-exponent value set may be chosen, at the whim

of the implementation.
v If the type of the division expression is double, then either the doublevalue set or the double-extended-exponent value set may be chosen, at the

whim of the implementation.

EXPRESSIONS Remainder Operator % 15.17.3

375DRAFT
Next, a value must be chosen from the chosen value set to represent the quo-tient. If the magnitude of the quotient is too large to represent, we say the
operation overflows; the result is then an infinity of appropriate sign. Other-wise, the quotient is rounded to the nearest value in the chosen value set using
IEEE 754 round-to-nearest mode. The Java programming language requiressupport of gradual underflow as defined by IEEE 754 ($4.2.4).

Despite the fact that overflow, underflow, division by zero, or loss of informa-tion may occur, evaluation of a floating-point division operator

/ never throws arun-time exception

15.17.3   Remainder Operator %
The binary % operator is said to yield the remainder of its operands from animplied division; the left-hand operand is the dividend and the right-hand operand

is the divisor.In C and C++, the remainder operator accepts only integral operands, but in
the Java programming language, it also accepts floating-point operands.The remainder operation for operands that are integers after binary numeric
promotion ($5.6.2) produces a result value such that (a/b)*b+(a%b) is equal to
a. This identity holds even in the special case that the dividend is the negativeinteger of largest possible magnitude for its type and the divisor is

-1 (the remain-der is
0). It follows from this rule that the result of the remainder operation can benegative only if the dividend is negative, and can be positive only if the dividend is

positive; moreover, the magnitude of the result is always less than the magnitudeof the divisor. If the value of the divisor for an integer remainder operator is

0,then an
ArithmeticException is thrown.Examples:

5%3 produces 2 (note that 5/3 produces 1)
5%(-3) produces 2 (note that 5/(-3) produces -1)
(-5)%3 produces -2 (note that (-5)/3 produces -1)
(-5)%(-3) produces -2 (note that (-5)/(-3) produces 1)

The result of a floating-point remainder operation as computed by the % oper-ator is not the same as that produced by the remainder operation defined by IEEE

754. The IEEE 754 remainder operation computes the remainder from a roundingdivision, not a truncating division, and so its behavior is not analogous to that of
the usual integer remainder operator. Instead, the Java programming languagedefines

% on floating-point operations to behave in a manner analogous to that ofthe integer remainder operator; this may be compared with the C library function

fmod. The IEEE 754 remainder operation may be computed by the library routine
Math.IEEEremainder.

15.18 Additive Operators EXPRESSIONS
376 DRAFT

The result of a floating-point remainder operation is determined by the rulesof IEEE arithmetic:

* If either operand is NaN, the result is NaN.

* If the result is not NaN, the sign of the result equals the sign of the dividend.

* If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.

* If the dividend is finite and the divisor is an infinity, the result equals the divi-dend.

* If the dividend is a zero and the divisor is finite, the result equals the dividend.

* In the remaining cases, where neither an infinity, nor a zero, nor NaN isinvolved, the floating-point remainder r from the division of a dividend n by a

divisor d is defined by the mathematical relation where q is aninteger that is negative only if is negative and positive only if is
positive, and whose magnitude is as large as possible without exceeding themagnitude of the true mathematical quotient of n and d.

Evaluation of a floating-point remainder operator % never throws a run-timeexception, even if the right-hand operand is zero. Overflow, underflow, or loss of
precision cannot occur.Examples:

5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0

15.18   Additive Operators
The operators + and - are called the additive operators. They have the same pre-cedence and are syntactically left-associative (they group left-to-right).

AdditiveExpression:MultiplicativeExpression

AdditiveExpression + MultiplicativeExpressionAdditiveExpression

 - MultiplicativeExpression

If the type of either operand of a + operator is String, then the operation isstring concatenation.

Otherwise, the type of each of the operands of the + operator must be a primi-tive numeric type, or a compile-time error occurs.

r n d qOE( )-=n d/ n d/
EXPRESSIONS String Concatenation Operator + 15.18.1

377DRAFT
In every case, the type of each of the operands of the binary - operator mustbe a primitive numeric type, or a compile-time error occurs.
15.18.1   String Concatenation Operator +
If only one operand expression is of type String, then string conversion is per-formed on the other operand to produce a string at run time. The result is a reference to a newly created String object that is the concatenation of the twooperand strings. The characters of the left-hand operand precede the characters of
the right-hand operand in the newly created string.
15.18.1.1 String Conversion
Any type may be converted to type String by string conversion.A value

x of primitive type T is first converted to a reference value as if bygiving it as an argument to an appropriate class instance creation expression:

* If T is boolean, then use new Boolean(x).

* If T is char, then use new Character(x).

* If T is byte, short, or int, then use new Integer(x).

* If T is long, then use new Long(x).

* If T is float, then use new Float(x).

* If T is double, then use new Double(x).

This reference value is then converted to type String by string conversion.Now only reference values need to be considered. If the reference is

null, it isconverted to the string "
null" (four ASCII characters n, u, l, l). Otherwise, theconversion is performed as if by an invocation of the

toString method of the ref-erenced object with no arguments; but if the result of invoking the

toStringmethod is
null, then the string "null" is used instead.The
toString method is defined by the primordial class Object; manyclasses override it, notably

Boolean, Character, Integer, Long, Float, Double, and String.

15.18.1.2 Optimization of String Concatenation
An implementation may choose to perform conversion and concatenation in onestep to avoid creating and then discarding an intermediate

String object. Toincrease the performance of repeated string concatenation, a Java compiler may

15.18.1 String Concatenation Operator + EXPRESSIONS

378 DRAFT

use the StringBuffer class or a similar technique to reduce the number of inter-mediate

String objects that are created by evaluation of an expression.For primitive types, an implementation may also optimize away the creation

of a wrapper object by converting directly from a primitive type to a string.
15.18.1.3 Examples of String Concatenation
The example expression:

"The square root of 2 is " + Math.sqrt(2)
produces the result:

"The square root of 2 is 1.4142135623730952"
The + operator is syntactically left-associative, no matter whether it is laterdetermined by type analysis to represent string concatenation or addition. In some

cases care is required to get the desired result. For example, the expression:

a + b + c
is always regarded as meaning:

(a + b) + c
Therefore the result of the expression:

1 + 2 + " fiddlers"
is:

"3 fiddlers"
but the result of:

"fiddlers " + 1 + 2
is:

"fiddlers 12"
In this jocular little example:
class Bottles {

static void printSong(Object stuff, int n) {

String plural = (n == 1) ? "" : "s";
loop: while (true) {

System.out.println(n + " bottle" + plural

+ " of " + stuff + " on the wall,");
System.out.println(n + " bottle" + plural

+ " of " + stuff + ";");
System.out.println("You take one down "

+ "and pass it around:");

EXPRESSIONS Additive Operators (+ and -) for Numeric Types 15.18.2

379DRAFT
--n;
plural = (n == 1) ? "" : "s";
if (n == 0)

break loop;
System.out.println(n + " bottle" + plural

+ " of " + stuff + " on the wall!");
System.out.println();
}
System.out.println("No bottles of " +

stuff + " on the wall!");
}

}
the method printSong will print a version of a children's song. Popular valuesfor stuff include

"pop" and "beer"; the most popular value for n is 100. Here isthe output that results from

Bottles.printSong("slime", 3):

3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!

In the code, note the careful conditional generation of the singular "bottle"when appropriate rather than the plural "

bottles"; note also how the string con-catenation operator was used to break the long constant string:

"You take one down and pass it around:"
into two pieces to avoid an inconveniently long line in the source code.

15.18.2 Additive Operators (+ and -) for Numeric Types
The binary + operator performs addition when applied to two operands of numerictype, producing the sum of the operands. The binary

- operator performs subtrac-tion, producing the difference of two numeric operands.

15.18.2 Additive Operators (+ and -) for Numeric Types EXPRESSIONS

380 DRAFT

Binary numeric promotion is performed on the operands ($5.6.2). The type ofan additive expression on numeric operands is the promoted type of its operands.
If this promoted type is int or long, then integer arithmetic is performed; if thispromoted type is

float or double, then floating-point arithmetic is performed.Note that binary numeric promotion performs value set conversion ($5.1.8).

Addition is a commutative operation if the operand expressions have no sideeffects. Integer addition is associative when the operands are all of the same type,
but floating-point addition is not associative.If an integer addition overflows, then the result is the low-order bits of the
mathematical sum as represented in some sufficiently large two's-complementformat. If overflow occurs, then the sign of the result is not the same as the sign of
the mathematical sum of the two operand values.The result of a floating-point addition is determined using the following rules
of IEEE arithmetic:

* If either operand is NaN, the result is NaN.

* The sum of two infinities of opposite sign is NaN.

* The sum of two infinities of the same sign is the infinity of that sign.

* The sum of an infinity and a finite value is equal to the infinite operand.

* The sum of two zeros of opposite sign is positive zero.

* The sum of two zeros of the same sign is the zero of that sign.

* The sum of a zero and a nonzero finite value is equal to the nonzero operand.

* The sum of two nonzero finite values of the same magnitude and oppositesign is positive zero.

* In the remaining cases, where neither an infinity, nor a zero, nor NaN isinvolved, and the operands have the same sign or have different magnitudes,

the exact mathematical sum is computed. A floating-point value set is thenchosen:

u If the addition expression is FP-strict ($15.4):

v If the type of the addition expression is float, then the float value setmust be chosen.

v If the type of the addition expression is double, then the double value setmust be chosen.

u If the addition expression is not FP-strict:

EXPRESSIONS Shift Operators 15.19

381DRAFT
v If the type of the addition expression is float, then either the float valueset or the float-extended-exponent value set may be chosen, at the whim

of the implementation.
v If the type of the addition expression is double, then either the doublevalue set or the double-extended-exponent value set may be chosen, at the

whim of the implementation.
Next, a value must be chosen from the chosen value set to represent the sum.If the magnitude of the sum is too large to represent, we say the operation
overflows; the result is then an infinity of appropriate sign. Otherwise, the sumis rounded to the nearest value in the chosen value set using IEEE 754 roundto-nearest mode. The Java programming language requires support of gradualunderflow as defined by IEEE 754 ($4.2.4).

The binary - operator performs subtraction when applied to two operands ofnumeric type producing the difference of its operands; the left-hand operand is the
minuend and the right-hand operand is the subtrahend. For both integer and float-ing-point subtraction, it is always the case that

a-b produces the same result as
a+(-b).Note that, for integer values, subtraction from zero is the same as negation.

However, for floating-point operands, subtraction from zero is not the same asnegation, because if

x is +0.0, then 0.0-x is +0.0, but -x is -0.0.Despite the fact that overflow, underflow, or loss of information may occur,

evaluation of a numeric additive operator never throws a run-time exception.

15.19   Shift Operators

The shift operators include left shift <<, signed right shift >>, and unsigned rightshift

>>>; they are syntactically left-associative (they group left-to-right). The left-hand operand of a shift operator is the value to be shifted; the right-hand operand

specifies the shift distance.

ShiftExpression:AdditiveExpression

ShiftExpression << AdditiveExpressionShiftExpression

 >> AdditiveExpressionShiftExpression
 >>> AdditiveExpression

15.20 Relational Operators EXPRESSIONS
382 DRAFT

The type of each of the operands of a shift operator must be a primitive inte-gral type, or a compile-time error occurs. Binary numeric promotion ($5.6.2) is
not performed on the operands; rather, unary numeric promotion ($5.6.1) is per-formed on each operand separately. The type of the shift expression is the promoted type of the left-hand operand.If the promoted type of the left-hand operand is

int, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the

right-hand operand were subjected to a bitwise logical AND operator & ($15.22.1)with the mask value

0x1f. The shift distance actually used is therefore always inthe range 0 to 31, inclusive.

If the promoted type of the left-hand operand is long, then only the six low-est-order bits of the right-hand operand are used as the shift distance. It is as if the
right-hand operand were subjected to a bitwise logical AND operator & ($15.22.1)with the mask value

0x3f. The shift distance actually used is therefore always inthe range 0 to 63, inclusive.

At run time, shift operations are performed on the two's complement integerrepresentation of the value of the left operand.
The value of n<<s is n left-shifted s bit positions; this is equivalent (even ifoverflow occurs) to multiplication by two to the power

s.The value of
n>>s is n right-shifted s bit positions with sign-extension. Theresulting value is . For nonnegative values of

n, this is equivalent to trun-cating integer division, as computed by the integer division operator

/, by two tothe power
s.The value of

n>>>s is n right-shifted s bit positions with zero-extension. If nis positive, then the result is the same as that of

n>>s; if n is negative, the result isequal to that of the expression
(n>>s)+(2<<~s) if the type of the left-hand oper-and is
int, and to the result of the expression (n>>s)+(2L<<~s) if the type of theleft-hand operand is

long. The added term (2<<~s) or (2L<<~s) cancels out thepropagated sign bit. (Note that, because of the implicit masking of the right-hand

operand of a shift operator, ~s as a shift distance is equivalent to 31-s when shift-ing an

int value and to 63-s when shifting a long value.)

15.20   Relational Operators
The relational operators are syntactically left-associative (they group left-to-right), but this fact is not useful; for example,

a<b<c parses as (a<b)<c, which isalways a compile-time error, because the type of

a<b is always boolean and < isnot an operator on
boolean values.

n 2s/

EXPRESSIONS Numerical Comparison Operators <, <=, >, and >= 15.20.1

383DRAFT
RelationalExpression:ShiftExpression

RelationalExpression < ShiftExpressionRelationalExpression

 > ShiftExpressionRelationalExpression
 <= ShiftExpressionRelationalExpression
 >= ShiftExpressionRelationalExpression
 instanceof ReferenceType

The type of a relational expression is always boolean.

15.20.1   Numerical Comparison Operators <, <=, >, and >=
The type of each of the operands of a numerical comparison operator must be aprimitive numeric type, or a compile-time error occurs. Binary numeric promotion

is performed on the operands ($5.6.2). If the promoted type of the operands is intor

long, then signed integer comparison is performed; if this promoted type is
float or double, then floating-point comparison is performed.Note that binary numeric promotion performs value set conversion ($5.1.8).

Comparison is carried out accurately on floating-point values, no matter whatvalue sets their representing values were drawn from.

The result of a floating-point comparison, as determined by the specificationof the IEEE 754 standard, is:

* If either operand is NaN, then the result is false.

* All values other than NaN are ordered, with negative infinity less than allfinite values, and positive infinity greater than all finite values.

* Positive zero and negative zero are considered equal. Therefore, -0.0<0.0 is

false, for example, but -0.0<=0.0 is true. (Note, however, that the meth-ods

Math.min and Math.max treat negative zero as being strictly smaller thanpositive zero.)

Subject to these considerations for floating-point numbers, the following rulesthen hold for integer operands or for floating-point operands other than NaN:

* The value produced by the < operator is true if the value of the left-handoperand is less than the value of the right-hand operand, and otherwise is

false.

* The value produced by the <= operator is true if the value of the left-handoperand is less than or equal to the value of the right-hand operand, and otherwise is false.

15.20.2 Type Comparison Operator instanceof EXPRESSIONS
384 DRAFT

* The value produced by the > operator is true if the value of the left-handoperand is greater than the value of the right-hand operand, and otherwise is

false.

* The value produced by the >= operator is true if the value of the left-handoperand is greater than or equal to the value of the right-hand operand, and

otherwise is false.

15.20.2   Type Comparison Operator instanceof
The type of a RelationalExpression operand of the instanceof operator must bea reference type or the null type; otherwise, a compile-time error occurs. The ReferenceType mentioned after the instanceof operator must denote a referencetype; otherwise, a compile-time error occurs.

At run time, the result of the instanceof operator is true if the value of theRelationalExpression is not

null and the reference could be cast ($15.16) to theReferenceType without raising a

ClassCastException. Otherwise the result is
false.If a cast of the RelationalExpression to the ReferenceType would be rejected

as a compile-time error, then the instanceof relational expression likewise pro-duces a compile-time error. In such a situation, the result of the

instanceofexpression could never be
true.Consider the example program:

class Point { int x, y; }
class Element { int atomicNumber; }
class Test {

public static void main(String[] args) {

Point p = new Point();
Element e = new Element();
if (e instanceof Point) { // compile-time error

System.out.println("I get your point!");
p = (Point)e; // compile-time error
}
}
}

This example results in two compile-time errors. The cast (Point)e is incorrectbecause no instance of

Element or any of its possible subclasses (none are shownhere) could possibly be an instance of any subclass of

Point. The instanceofexpression is incorrect for exactly the same reason. If, on the other hand, the class

Point were a subclass of Element (an admittedly strange notion in this example):

class Point extends Element { int x, y; }

EXPRESSIONS Numerical Equality Operators == and != 15.21.1

385DRAFT
then the cast would be possible, though it would require a run-time check, and the
instanceof expression would then be sensible and valid. The cast (Point)ewould never raise an exception because it would not be executed if the value of

ecould not correctly be cast to type
Point.

15.21 Equality Operators
The equality operators are syntactically left-associative (they group left-to-right),but this fact is essentially never useful; for example,

a==b==c parses as
(a==b)==c. The result type of a==b is always boolean, and c must therefore beof type

boolean or a compile-time error occurs. Thus, a==b==c does not test tosee whether

a, b, and c are all equal.

EqualityExpression:RelationalExpression

EqualityExpression == RelationalExpressionEqualityExpression

 != RelationalExpression

The == (equal to) and the!= (not equal to) operators are analogous to the rela-tional operators except for their lower precedence. Thus,

a<b==c<d is true when-ever
a<b and c<d have the same truth value.The equality operators may be used to compare two operands of numeric

type, or two operands of type boolean, or two operands that are each of either ref-erence type or the null type. All other cases result in a compile-time error. The
type of an equality expression is always boolean.In all cases,

a!=b produces the same result as !(a==b). The equality opera-tors are commutative if the operand expressions have no side effects.

15.21.1   Numerical Equality Operators == and !=
If the operands of an equality operator are both of primitive numeric type, binarynumeric promotion is performed on the operands ($5.6.2). If the promoted type of

the operands is int or long, then an integer equality test is performed; if the pro-moted type is

float or double, then a floating-point equality test is performed.Note that binary numeric promotion performs value set conversion ($5.1.8).

Comparison is carried out accurately on floating-point values, no matter whatvalue sets their representing values were drawn from.

Floating-point equality testing is performed in accordance with the rules ofthe IEEE 754 standard:

15.21.2 Boolean Equality Operators == and != EXPRESSIONS

386 DRAFT

* If either operand is NaN, then the result of == is false but the result of != is

true. Indeed, the test x!=x is true if and only if the value of x is NaN. (Themethods

Float.isNaN and Double.isNaN may also be used to test whether avalue is NaN.)

* Positive zero and negative zero are considered equal. Therefore, -0.0==0.0 is

true, for example.

* Otherwise, two distinct floating-point values are considered unequal by theequality operators. In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only toitself, and each compares unequal to all other values.

Subject to these considerations for floating-point numbers, the following rulesthen hold for integer operands or for floating-point operands other than NaN:

* The value produced by the == operator is true if the value of the left-handoperand is equal to the value of the right-hand operand; otherwise, the result is

false.

* The value produced by the != operator is true if the value of the left-handoperand is not equal to the value of the right-hand operand; otherwise, the

result is false.

15.21.2   Boolean Equality Operators == and !=
If the operands of an equality operator are both of type boolean, then the opera-tion is boolean equality. The

boolean equality operators are associative.The result of
== is true if the operands are both true or both false; other-wise, the result is

false.The result of
!= is false if the operands are both true or both false; other-wise, the result is

true. Thus != behaves the same as ^ ($15.22.2) when appliedto boolean operands.

15.21.3   Reference Equality Operators == and !=
If the operands of an equality operator are both of either reference type or the nulltype, then the operation is object equality.

A compile-time error occurs if it is impossible to convert the type of eitheroperand to the type of the other by a casting conversion ($5.5). The run-time values of the two operands would necessarily be unequal.At run time, the result of

== is true if the operand values are both null orboth refer to the same object or array; otherwise, the result is

false.

EXPRESSIONS Integer Bitwise Operators &, ^, and | 15.22.1

387DRAFT
The result of != is false if the operand values are both null or both refer tothe same object or array; otherwise, the result is

true.While
== may be used to compare references of type String, such an equal-ity test determines whether or not the two operands refer to the same

Stringobject. The result is
false if the operands are distinct String objects, even ifthey contain the same sequence of characters. The contents of two strings

s and tcan be tested for equality by the method invocation
s.equals(t). See also$3.10.5.

15.22 Bitwise and Logical Operators
The bitwise operators and logical operators include the AND operator &, exclu-sive OR operator

^, and inclusive OR operator |. These operators have differentprecedence, with
& having the highest precedence and | the lowest precedence.Each of these operators is syntactically left-associative (each groups left-to-right).

Each operator is commutative if the operand expressions have no side effects.Each operator is associative.

AndExpression:EqualityExpression

AndExpression & EqualityExpression
ExclusiveOrExpression:AndExpression

ExclusiveOrExpression ^ AndExpression
InclusiveOrExpression:ExclusiveOrExpression

InclusiveOrExpression | ExclusiveOrExpression
The bitwise and logical operators may be used to compare two operands ofnumeric type or two operands of type

boolean. All other cases result in a com-pile-time error.

15.22.1   Integer Bitwise Operators &, ^, and |
When both operands of an operator &, ^, or | are of primitive integral type, binarynumeric promotion is first performed on the operands ($5.6.2). The type of the bitwise operator expression is the promoted type of the operands.For

&, the result value is the bitwise AND of the operand values.For
^, the result value is the bitwise exclusive OR of the operand values.For
|, the result value is the bitwise inclusive OR of the operand values.

15.22.2 Boolean Logical Operators &, ^, and | EXPRESSIONS
388 DRAFT

For example, the result of the expression 0xff00 & 0xf0f0 is 0xf000. Theresult of

0xff00 ^ 0xf0f0 is 0x0ff0.The result of 0xff00 | 0xf0f0 is 0xfff0.

15.22.2 Boolean Logical Operators &, ^, and |
When both operands of a &, ^, or | operator are of type boolean, then the type ofthe bitwise operator expression is

boolean.For
&, the result value is true if both operand values are true; otherwise, theresult is

false.For
^, the result value is true if the operand values are different; otherwise,the result is

false.For
|, the result value is false if both operand values are false; otherwise,the result is

true.

15.23   Conditional-And Operator &&
The && operator is like & ($15.22.2), but evaluates its right-hand operand only ifthe value of its left-hand operand is

true. It is syntactically left-associative (itgroups left-to-right). It is fully associative with respect to both side effects and

result value; that is, for any expressions a, b, and c, evaluation of the expression
((a)&&(b))&&(c) produces the same result, with the same side effects occur-ring in the same order, as evaluation of the expression

(a)&&((b)&&(c)).

ConditionalAndExpression:InclusiveOrExpression

ConditionalAndExpression && InclusiveOrExpression
Each operand of && must be of type boolean, or a compile-time error occurs.The type of a conditional-and expression is always

boolean.At run time, the left-hand operand expression is evaluated first; if its value is

false, the value of the conditional-and expression is false and the right-handoperand expression is not evaluated. If the value of the left-hand operand is

true,then the right-hand expression is evaluated and its value becomes the value of the

conditional-and expression. Thus, && computes the same result as & on booleanoperands. It differs only in that the right-hand operand expression is evaluated
conditionally rather than always.

EXPRESSIONS Conditional Operator ? : 15.25

389DRAFT
15.24   Conditional-Or Operator ||
The || operator is like | ($15.22.2), but evaluates its right-hand operand only ifthe value of its left-hand operand is

false. It is syntactically left-associative (itgroups left-to-right). It is fully associative with respect to both side effects and

result value; that is, for any expressions a, b, and c, evaluation of the expression
((a)||(b))||(c) produces the same result, with the same side effects occur-ring in the same order, as evaluation of the expression

(a)||((b)||(c)).

ConditionalOrExpression:ConditionalAndExpression

ConditionalOrExpression || ConditionalAndExpression
Each operand of || must be of type boolean, or a compile-time error occurs.The type of a conditional-or expression is always

boolean.At run time, the left-hand operand expression is evaluated first; if its value is

true, the value of the conditional-or expression is true and the right-hand oper-and expression is not evaluated. If the value of the left-hand operand is

false,then the right-hand expression is evaluated and its value becomes the value of the

conditional-or expression.Thus,

|| computes the same result as | on boolean operands. It differs onlyin that the right-hand operand expression is evaluated conditionally rather than

always.

15.25   Conditional Operator ? :
The conditional operator ? : uses the boolean value of one expression to decidewhich of two other expressions should be evaluated.

The conditional operator is syntactically right-associative (it groups right-to-left), so that

a?b:c?d:e?f:g means the same as a?b:(c?d:(e?f:g)).

ConditionalExpression:ConditionalOrExpression

ConditionalOrExpression ? Expression : ConditionalExpression
The conditional operator has three operand expressions; ? appears betweenthe first and second expressions, and

: appears between the second and thirdexpressions.

The first expression must be of type boolean, or a compile-time error occurs.The conditional operator may be used to choose between second and third
operands of numeric type, or second and third operands of type boolean, or sec15.25 Conditional Operator ? : EXPRESSIONS
390 DRAFT

ond and third operands that are each of either reference type or the null type. Allother cases result in a compile-time error.

Note that it is not permitted for either the second or the third operand expres-sion to be an invocation of a

void method. In fact, it is not permitted for a condi-tional expression to appear in any context where an invocation of a

void methodcould appear ($14.8).

The type of a conditional expression is determined as follows:

* If the second and third operands have the same type (which may be the nulltype), then that is the type of the conditional expression.

* Otherwise, if the second and third operands have numeric type, then there areseveral cases:

u If one of the operands is of type byte and the other is of type short, thenthe type of the conditional expression is

short.

u If one of the operands is of type T where T is byte, short, or char, and theother operand is a constant expression of type

int whose value is represent-able in type
T, then the type of the conditional expression is T.

u Otherwise, binary numeric promotion ($5.6.2) is applied to the operandtypes, and the type of the conditional expression is the promoted type of the

second and third operands. Note that binary numeric promotion performsvalue set conversion ($5.1.8).

* If one of the second and third operands is of the null type and the type of theother is a reference type, then the type of the conditional expression is that

reference type.

* If the second and third operands are of different reference types, then it mustbe possible to convert one of the types to the other type (call this latter type

T)by assignment conversion ($5.2); the type of the conditional expression is

T.It is a compile-time error if neither type is assignment compatible with the

other type.
At run time, the first operand expression of the conditional expression is eval-uated first; its

boolean value is then used to choose either the second or the thirdoperand expression:

* If the value of the first operand is true, then the second operand expression ischosen.

* If the value of the first operand is false, then the third operand expression ischosen.

EXPRESSIONS Assignment Operators 15.26

391DRAFT
The chosen operand expression is then evaluated and the resulting value is con-verted to the type of the conditional expression as determined by the rules stated
above. The operand expression not chosen is not evaluated for that particular eval-uation of the conditional expression.

15.26   Assignment Operators
There are 12 assignment operators; all are syntactically right-associative (theygroup right-to-left). Thus,

a=b=c means a=(b=c), which assigns the value of c to
b and then assigns the value of b to a.

AssignmentExpression:ConditionalExpression

Assignment
Assignment:LeftHandSide AssignmentOperator AssignmentExpression

LeftHandSide:ExpressionName

FieldAccessArrayAccess

AssignmentOperator: one of

= *= /= %= += -= <<= >>= >>>= &= ^= |=

The result of the first operand of an assignment operator must be a variable, ora compile-time error occurs. This operand may be a named variable, such as a

local variable or a field of the current object or class, or it may be a computed vari-able, as can result from a field access ($15.11) or an array access ($15.13). The
type of the assignment expression is the type of the variable.At run time, the result of the assignment expression is the value of the variable
after the assignment has occurred. The result of an assignment expression is notitself a variable.

A variable that is declared final cannot be assigned to (unless it is a blankfinal variable ($4.5.4)), because when an access of a

final variable is used as anexpression, the result is a value, not a variable, and so it cannot be used as the first

operand of an assignment operator.

15.26.1 Simple Assignment Operator = EXPRESSIONS

392 DRAFT

15.26.1   Simple Assignment Operator =
A compile-time error occurs if the type of the right-hand operand cannot be con-verted to the type of the variable by assignment conversion ($5.2).

At run time, the expression is evaluated in one of two ways. If the left-handoperand expression is not an array access expression, then three steps are
required:

* First, the left-hand operand is evaluated to produce a variable. If this evalua-tion completes abruptly, then the assignment expression completes abruptly

for the same reason; the right-hand operand is not evaluated and no assign-ment occurs.

* Otherwise, the right-hand operand is evaluated. If this evaluation completesabruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.

* Otherwise, the value of the right-hand operand is converted to the type of theleft-hand variable, is subjected to value set conversion ($5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the resultof the conversion is stored into the variable.

If the left-hand operand expression is an array access expression ($15.13), thenmany steps are required:

* First, the array reference subexpression of the left-hand operand array accessexpression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpres-sion (of the left-hand operand array access expression) and the right-hand
operand are not evaluated and no assignment occurs.

* Otherwise, the index subexpression of the left-hand operand array accessexpression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-handoperand is not evaluated and no assignment occurs.

* Otherwise, the right-hand operand is evaluated. If this evaluation completesabruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.

* Otherwise, if the value of the array reference subexpression is null, then noassignment occurs and a

NullPointerException is thrown.

* Otherwise, the value of the array reference subexpression indeed refers to anarray. If the value of the index subexpression is less than zero, or greater

EXPRESSIONS Simple Assignment Operator = 15.26.1

393DRAFT
than or equal to the length of the array, then no assignment occurs and an
ArrayIndexOutOfBoundsException is thrown.

* Otherwise, the value of the index subexpression is used to select a componentof the array referred to by the value of the array reference subexpression. This

component is a variable; call its type SC. Also, let TC be the type of the left-hand operand of the assignment operator as determined at compile time.

u If TC is a primitive type, then SC is necessarily the same as TC. The value ofthe right-hand operand is converted to the type of the selected array component, is subjected to value set conversion ($5.1.8) to the appropriate stan-dard value set (not an extended-exponent value set), and the result of the
conversion is stored into the array component.
u If TC is a reference type, then SC may not be the same as TC, but rather atype that extends or implements

TC. Let RC be the class of the objectreferred to by the value of the right-hand operand at run time.

The compiler may be able to prove at compile time that the array compo-nent will be of type

TC exactly (for example, TC might be final). But if thecompiler cannot prove at compile time that the array component will be of

type TC exactly, then a check must be performed at run time to ensure thatthe class

RC is assignment compatible ($5.2) with the actual type SC of thearray component. This check is similar to a narrowing cast ($5.5, $15.16),

except that if the check fails, an ArrayStoreException is thrown ratherthan a

ClassCastException. Therefore:

v If class RC is not assignable to type SC, then no assignment occurs and an

ArrayStoreException is thrown.

Otherwise, the reference value of the right-hand operand is stored into theselected array component.

The rules for assignment to an array component are illustrated by the follow-ing example program:

class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateSimpleArrayAssignment {

static Object[] objects = { new Object(), new Object() };
static Thread[] threads = { new Thread(), new Thread() };

15.26.1 Simple Assignment Operator = EXPRESSIONS

394 DRAFT

static Object[] arrayThrow() {

throw new ArrayReferenceThrow();
}

static int indexThrow() { throw new IndexThrow(); }
static Thread rightThrow() {

throw new RightHandSideThrow();
}

static String name(Object q) {

String sq = q.getClass().getName();
int k = sq.lastIndexOf('.');
return (k < 0) ? sq : sq.substring(k+1);
}

static void testFour(Object[] x, int j, Object y) {

String sx = x == null ? "null" : name(x[0]) + "s";
String sy = name(y);
System.out.println();
try {

System.out.print(sx + "[throw]=throw => ");
x[indexThrow()] = rightThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sx + "[throw]=" + sy + " => ");
x[indexThrow()] = y;
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sx + "[" + j + "]=throw => ");
x[j] = rightThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sx + "[" + j + "]=" + sy + " => ");
x[j] = y;
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
}

public static void main(String[] args) {

try {

System.out.print("throw[throw]=throw => ");
arrayThrow()[indexThrow()] = rightThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[throw]=Thread => ");
arrayThrow()[indexThrow()] = new Thread();

EXPRESSIONS Simple Assignment Operator = 15.26.1

395DRAFT
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]=throw => ");
arrayThrow()[1] = rightThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]=Thread => ");
arrayThrow()[1] = new Thread();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }

testFour(null, 1, new StringBuffer());
testFour(null, 1, new StringBuffer());
testFour(null, 9, new Thread());
testFour(null, 9, new Thread());
testFour(objects, 1, new StringBuffer());
testFour(objects, 1, new Thread());
testFour(objects, 9, new StringBuffer());
testFour(objects, 9, new Thread());
testFour(threads, 1, new StringBuffer());
testFour(threads, 1, new Thread());
testFour(threads, 9, new StringBuffer());
testFour(threads, 9, new Thread());
}

}
This program prints:

throw[throw]=throw => ArrayReferenceThrow
throw[throw]=Thread => ArrayReferenceThrow
throw[1]=throw => ArrayReferenceThrow
throw[1]=Thread => ArrayReferenceThrow

null[throw]=throw => IndexThrow
null[throw]=StringBuffer => IndexThrow
null[1]=throw => RightHandSideThrow
null[1]=StringBuffer => NullPointerException

null[throw]=throw => IndexThrow
null[throw]=StringBuffer => IndexThrow
null[1]=throw => RightHandSideThrow
null[1]=StringBuffer => NullPointerException

null[throw]=throw => IndexThrow
null[throw]=Thread => IndexThrow
null[9]=throw => RightHandSideThrow
null[9]=Thread => NullPointerException

15.26.1 Simple Assignment Operator = EXPRESSIONS
396 DRAFT

null[throw]=throw => IndexThrow
null[throw]=Thread => IndexThrow
null[9]=throw => RightHandSideThrow
null[9]=Thread => NullPointerException

Objects[throw]=throw => IndexThrow
Objects[throw]=StringBuffer => IndexThrow
Objects[1]=throw => RightHandSideThrow
Objects[1]=StringBuffer => Okay!

Objects[throw]=throw => IndexThrow
Objects[throw]=Thread => IndexThrow
Objects[1]=throw => RightHandSideThrow
Objects[1]=Thread => Okay!

Objects[throw]=throw => IndexThrow
Objects[throw]=StringBuffer => IndexThrow
Objects[9]=throw => RightHandSideThrow
Objects[9]=StringBuffer => ArrayIndexOutOfBoundsException

Objects[throw]=throw => IndexThrow
Objects[throw]=Thread => IndexThrow
Objects[9]=throw => RightHandSideThrow
Objects[9]=Thread => ArrayIndexOutOfBoundsException

Threads[throw]=throw => IndexThrow
Threads[throw]=StringBuffer => IndexThrow
Threads[1]=throw => RightHandSideThrow
Threads[1]=StringBuffer => ArrayStoreException

Threads[throw]=throw => IndexThrow
Threads[throw]=Thread => IndexThrow
Threads[1]=throw => RightHandSideThrow
Threads[1]=Thread => Okay!

Threads[throw]=throw => IndexThrow
Threads[throw]=StringBuffer => IndexThrow
Threads[9]=throw => RightHandSideThrow
Threads[9]=StringBuffer => ArrayIndexOutOfBoundsException

Threads[throw]=throw => IndexThrow
Threads[throw]=Thread => IndexThrow
Threads[9]=throw => RightHandSideThrow
Threads[9]=Thread => ArrayIndexOutOfBoundsException

The most interesting case of the lot is the one thirteenth from the end:

Threads[1]=StringBuffer => ArrayStoreException
which indicates that the attempt to store a reference to a StringBuffer into anarray whose components are of type

Thread throws an ArrayStoreException.The code is type-correct at compile time: the assignment has a left-hand side of

type Object[] and a right-hand side of type Object. At run time, the first actual

EXPRESSIONS Compound Assignment Operators 15.26.2

397DRAFT
argument to method testFour is a reference to an instance of "array of Thread"and the third actual argument is a reference to an instance of class

StringBuffer.

15.26.2 Compound Assignment Operators
All compound assignment operators require both operands to be of primitive type,except for

+=, which allows the right-hand operand to be of any type if the left-hand operand is of type

String.A compound assignment expression of the form

E1 op = E2 is equivalent to
E1 = (T )((E1) op (E2)), where T is the type of E1, except that E1 is evaluatedonly once. Note that the implied cast to type

T may be either an identity conver-sion ($5.1.1) or a narrowing primitive conversion ($5.1.3). For example, the following code is correct:

short x = 3;x += 4.6;

and results in x having the value 7 because it is equivalent to:

short x = 3;x = (short)(x + 4.6);

At run time, the expression is evaluated in one of two ways. If the left-handoperand expression is not an array access expression, then four steps are required:

* First, the left-hand operand is evaluated to produce a variable. If this evalua-tion completes abruptly, then the assignment expression completes abruptly

for the same reason; the right-hand operand is not evaluated and no assign-ment occurs.

* Otherwise, the value of the left-hand operand is saved and then the right-handoperand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignmentoccurs.

* Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the onlypossibility is an integer division by zero--see $15.17.2), then the assignment
expression completes abruptly for the same reason and no assignment occurs.

* Otherwise, the result of the binary operation is converted to the type of theleft-hand variable, subjected to value set conversion ($5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result ofthe conversion is stored into the variable.

15.26.2 Compound Assignment Operators EXPRESSIONS
398 DRAFT

If the left-hand operand expression is an array access expression ($15.13), thenmany steps are required:

* First, the array reference subexpression of the left-hand operand array accessexpression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpres-sion (of the left-hand operand array access expression) and the right-hand
operand are not evaluated and no assignment occurs.

* Otherwise, the index subexpression of the left-hand operand array accessexpression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-handoperand is not evaluated and no assignment occurs.

* Otherwise, if the value of the array reference subexpression is null, then noassignment occurs and a

NullPointerException is thrown.

* Otherwise, the value of the array reference subexpression indeed refers to anarray. If the value of the index subexpression is less than zero, or greater

than or equal to the length of the array, then no assignment occurs and an
ArrayIndexOutOfBoundsException is thrown.

* Otherwise, the value of the index subexpression is used to select a componentof the array referred to by the value of the array reference subexpression. The

value of this component is saved and then the right-hand operand is evaluated.If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. (For a simpleassignment operator, the evaluation of the right-hand operand occurs before
the checks of the array reference subexpression and the index subexpression,but for a compound assignment operator, the evaluation of the right-hand
operand occurs after these checks.)

* Otherwise, consider the array component selected in the previous step, whosevalue was saved. This component is a variable; call its type

S. Also, let T bethe type of the left-hand operand of the assignment operator as determined at

compile time.
u If T is a primitive type, then S is necessarily the same as T.

v The saved value of the array component and the value of the right-handoperand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the onlypossibility is an integer division by zero--see $15.17.2), then the assignment expression completes abruptly for the same reason and no assign-ment occurs.

EXPRESSIONS Compound Assignment Operators 15.26.2

399DRAFT
v Otherwise, the result of the binary operation is converted to the type of theselected array component, subjected to value set conversion ($5.1.8) to

the appropriate standard value set (not an extended-exponent value set),and the result of the conversion is stored into the array component.

u If T is a reference type, then it must be String. Because class String is a

final class, S must also be String. Therefore the run-time check that issometimes required for the simple assignment operator is never required for

a compound assignment operator.
v The saved value of the array component and the value of the right-handoperand are used to perform the binary operation (string concatenation)

indicated by the compound assignment operator (which is necessarily
+=). If this operation completes abruptly, then the assignment expressioncompletes abruptly for the same reason and no assignment occurs.

Otherwise, the String result of the binary operation is stored into the arraycomponent.
The rules for compound assignment to an array component are illustrated bythe following example program:

class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow extends RuntimeException { }
class RightHandSideThrow extends RuntimeException { }
class IllustrateCompoundArrayAssignment {

static String[] strings = { "Simon", "Garfunkel" };
static double[] doubles = { Math.E, Math.PI };
static String[] stringsThrow() {

throw new ArrayReferenceThrow();
}

static double[] doublesThrow() {

throw new ArrayReferenceThrow();
}

static int indexThrow() { throw new IndexThrow(); }
static String stringThrow() {

throw new RightHandSideThrow();
}

static double doubleThrow() {

throw new RightHandSideThrow();
}

15.26.2 Compound Assignment Operators EXPRESSIONS
400 DRAFT

static String name(Object q) {

String sq = q.getClass().getName();
int k = sq.lastIndexOf('.');
return (k < 0) ? sq : sq.substring(k+1);
}

static void testEight(String[] x, double[] z, int j) {

String sx = (x == null) ? "null" : "Strings";
String sz = (z == null) ? "null" : "doubles";
System.out.println();
try {

System.out.print(sx + "[throw]+=throw => ");
x[indexThrow()] += stringThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sz + "[throw]+=throw => ");
z[indexThrow()] += doubleThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }

try {

System.out.print(sx + "[throw]+=\"heh\" => ");
x[indexThrow()] += "heh";
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sz + "[throw]+=12345 => ");
z[indexThrow()] += 12345;
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sx + "[" + j + "]+=throw => ");
x[j] += stringThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sz + "[" + j + "]+=throw => ");
z[j] += doubleThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sx + "[" + j + "]+=\"heh\" => ");
x[j] += "heh";
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print(sz + "[" + j + "]+=12345 => ");
z[j] += 12345;

EXPRESSIONS Compound Assignment Operators 15.26.2

401DRAFT
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
}

public static void main(String[] args) {

try {

System.out.print("throw[throw]+=throw => ");
stringsThrow()[indexThrow()] += stringThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[throw]+=throw => ");
doublesThrow()[indexThrow()] += doubleThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[throw]+=\"heh\" => ");
stringsThrow()[indexThrow()] += "heh";
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }

try {

System.out.print("throw[throw]+=12345 => ");
doublesThrow()[indexThrow()] += 12345;
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]+=throw => ");
stringsThrow()[1] += stringThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]+=throw => ");
doublesThrow()[1] += doubleThrow();
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]+=\"heh\" => ");
stringsThrow()[1] += "heh";
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }
try {

System.out.print("throw[1]+=12345 => ");
doublesThrow()[1] += 12345;
System.out.println("Okay!");
} catch (Throwable e) { System.out.println(name(e)); }

testEight(null, null, 1);
testEight(null, null, 9);
testEight(strings, doubles, 1);

15.26.2 Compound Assignment Operators EXPRESSIONS
402 DRAFT

testEight(strings, doubles, 9);
}

}
This program prints:

throw[throw]+=throw => ArrayReferenceThrow
throw[throw]+=throw => ArrayReferenceThrow
throw[throw]+="heh" => ArrayReferenceThrow
throw[throw]+=12345 => ArrayReferenceThrow
throw[1]+=throw => ArrayReferenceThrow
throw[1]+=throw => ArrayReferenceThrow
throw[1]+="heh" => ArrayReferenceThrow
throw[1]+=12345 => ArrayReferenceThrow

null[throw]+=throw => IndexThrow
null[throw]+=throw => IndexThrow
null[throw]+="heh" => IndexThrow
null[throw]+=12345 => IndexThrow
null[1]+=throw => NullPointerException
null[1]+=throw => NullPointerException
null[1]+="heh" => NullPointerException
null[1]+=12345 => NullPointerException

null[throw]+=throw => IndexThrow
null[throw]+=throw => IndexThrow
null[throw]+="heh" => IndexThrow
null[throw]+=12345 => IndexThrow
null[9]+=throw => NullPointerException
null[9]+=throw => NullPointerException
null[9]+="heh" => NullPointerException
null[9]+=12345 => NullPointerException

Strings[throw]+=throw => IndexThrow
doubles[throw]+=throw => IndexThrow
Strings[throw]+="heh" => IndexThrow
doubles[throw]+=12345 => IndexThrow
Strings[1]+=throw => RightHandSideThrow
doubles[1]+=throw => RightHandSideThrow
Strings[1]+="heh" => Okay!
doubles[1]+=12345 => Okay!

Strings[throw]+=throw => IndexThrow
doubles[throw]+=throw => IndexThrow
Strings[throw]+="heh" => IndexThrow
doubles[throw]+=12345 => IndexThrow
Strings[9]+=throw => ArrayIndexOutOfBoundsException
doubles[9]+=throw => ArrayIndexOutOfBoundsException
Strings[9]+="heh" => ArrayIndexOutOfBoundsException
doubles[9]+=12345 => ArrayIndexOutOfBoundsException

EXPRESSIONS Expression 15.27

403DRAFT
The most interesting cases of the lot are tenth and eleventh from the end:

Strings[1]+=throw => RightHandSideThrow
doubles[1]+=throw => RightHandSideThrow

They are the cases where a right-hand side that throws an exception actually getsto throw the exception; moreover, they are the only such cases in the lot. This

demonstrates that the evaluation of the right-hand operand indeed occurs after thechecks for a null array reference value and an out-of-bounds index value.

The following program illustrates the fact that the value of the left-hand sideof a compound assignment is saved before the right-hand side is evaluated:

class Test {

public static void main(String[] args) {

int k = 1;
int[] a = { 1 };
k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);
System.out.println("k==" + k + " and a[0]==" + a[0]);
}
}

This program prints:

k==25 and a[0]==25
The value 1 of k is saved by the compound assignment operator += before itsright-hand operand

(k = 4) * (k + 2) is evaluated. Evaluation of this right-handoperand then assigns

4 to k, calculates the value 6 for k + 2, and then multiplies
4 by 6 to get 24. This is added to the saved value 1 to get 25, which is then storedinto

k by the += operator. An identical analysis applies to the case that uses a[0].In short, the statements

k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);

behave in exactly the same manner as the statements:

k = k + (k = 4) * (k + 2);
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);

15.27 Expression
An Expression is any assignment expression:

Expression:AssignmentExpression

Unlike C and C++, the Java programming language has no comma operator.

15.28 Constant Expression EXPRESSIONS
404 DRAFT

15.28   Constant Expression

ConstantExpression:Expression

A compile-time constant expression is an expression denoting a value ofprimitive type or a

String that is composed using only the following:

* Literals of primitive type and literals of type String

* Casts to primitive types and casts to type String

* The unary operators +, -, ~, and ! (but not ++ or --)

* The multiplicative operators *, /, and %

* The additive operators + and * The shift operators <<, >>, and >>>

* The relational operators <, <=, >, and >= (but not instanceof)

* The equality operators == and !=

* The bitwise and logical operators &, ^, and |

* The conditional-and operator && and the conditional-or operator ||

* The ternary conditional operator ? :

* Simple names that refer to final variables whose initializers are constantexpressions

* Qualified names of the form TypeName . Identifier that refer to final vari-ables whose initializers are constant expressions

Compile-time constant expressions are used in case labels in switch statements($14.10) and have a special significance for assignment conversion ($5.2).

A compile-time constant expression is always treated as FP-strict ($15.4),even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.Examples of constant expressions:

true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI

EXPRESSIONS Constant Expression 15.28

405DRAFT
"The integer " + Long.MAX_VALUE + " is mighty big."
15.28 Constant Expression EXPRESSIONS

406 DRAFT407DRAFT

C H A P T E R 16
Definite Assignment

EACH local variable ($14.4) and every blank final ($4.5.4) field ($8.3.1.2)must have a definitely assigned value when any access of its value occurs. A Java
compiler must carry out a specific conservative flow analysis to make sure that,for every access of a local variable or blank

final field f, f is definitely assignedbefore the access; otherwise a compile-time error must occur.

Similarly, every blank final variable must be assigned at most once; it mustbe definitely unassigned when an assignment to it occurs. A Java compiler must
carry out a specific conservative flow analysis to make sure that, for every assign-ment to a blank

final variable, the variable is definitely unassigned before theassignment; otherwise a compile-time error must occur.

The remainder of this chapter is devoted to a precise explanation of the words"definitely assigned before" and "definitely unassigned before".
The idea behind definite assignment is that an assignment to the local variableor blank

final field must occur on every possible execution path to the access.Similarly, the idea behind definite unassignment is that no other assignment to the

blank final variable is permitted to occur on any possible execution path to anassignment. The analysis takes into account the structure of statements and
expressions; it also provides a special treatment of the expression operators !, &&,
||, and ? :, and of boolean-valued constant expressions.For example, a Java compiler recognizes that

k is definitely assigned beforeits access (as an argument of a method invocation) in the code:

{

int k;
if (v > 0 && (k = System.in.read()) >= 0)

System.out.println(k);
}

because the access occurs only if the value of the expression:

v > 0 && (k = System.in.read()) >= 0
is true, and the value can be true only if the assignment to k is executed (moreproperly, evaluated).

Similarly, a Java compiler will recognize that in the code:

16 Definite Assignment DEFINITE ASSIGNMENT
408 DRAFT

{

int k;
while (true) {

k = n;
if (k >= 5) break;
n = 6;
}
System.out.println(k);
}

the variable k is definitely assigned by the while statement because the conditionexpression

true never has the value false, so only the break statement cancause the
while statement to complete normally, and k is definitely assignedbefore the
break statement.On the other hand, the code

{

int k;
while (n < 4) {

k = n;
if (k >= 5) break;
n = 6;
}
System.out.println(k);// k is not "definitely assigned" before this
}

must be rejected by a Java compiler, because in this case the while statement isnot guaranteed to execute its body as far as the rules of definite assignment are

concerned.Except for the special treatment of the conditional boolean operators

&&, ||,and
? : and of boolean-valued constant expressions, the values of expressionsare not taken into account in the flow analysis.

For example, a Java compiler must produce a compile-time error for the code:
{

int k;
int n = 5;
if (n > 2)

k = 3;
System.out.println(k); // k is not "definitely assigned" before this
}

even though the value of n is known at compile time, and in principle it can beknown at compile time that the assignment to

k will always be executed (moreproperly, evaluated). A Java compiler must operate according to the rules laid out

in this section. The rules recognize only constant expressions; in this example, theexpression

n > 2 is not a constant expression as defined in $15.28.

DEFINITE ASSIGNMENT Definite Assignment 16

409DRAFT
As another example, a Java compiler will accept the code:
void flow(boolean flag) {

int k;
if (flag)

k = 3;
else

k = 4;
System.out.println(k);
}

as far as definite assignment of k is concerned, because the rules outlined in thissection allow it to tell that

k is assigned no matter whether the flag is true or
false. But the rules do not accept the variation:

void flow(boolean flag) {

int k;
if (flag)

k = 3;
if (!flag)

k = 4;
System.out.println(k); // k is not "definitely assigned" before here
}

and so compiling this program must cause a compile-time error to occur.A related example illustrates rules of definite unassignment. A Java compiler

will accept the code:

void unflow(boolean flag) {

final int k;
if (flag) {

k = 3;
System.out.println(k);
}
else {

k = 4;
System.out.println(k);
}
}

as far as definite unassignment of k is concerned, because the rules outlined in thissection allow it to tell that

k is assigned at most once (indeed, exactly once) nomatter whether the flag is
true or false. But the rules do not accept the variation:

void unflow(boolean flag) {

final int k;
if (flag) {

k = 3;
System.out.println(k);

16 Definite Assignment DEFINITE ASSIGNMENT
410 DRAFT

}
if (!flag) {

k = 4; // k is not "definitely unassigned" before here
System.out.println(k);
}
}

and so compiling this program must cause a compile-time error to occur.In order to precisely specify all the cases of definite assignment, the rules in

this section define several technical terms:

* whether a variable is definitely assigned before a statement or expression;

* whether a variable is definitely unassigned before a statement or expression;

* whether a variable is definitely assigned after a statement or expression; and

* whether a variable is definitely unassigned after a statement or expression.

For boolean-valued expressions, the last two are refined into four cases:

* whether a variable is definitely assigned after the expression when true;

* whether a variable is definitely unassigned after the expression when true;

* whether a variable is definitely assigned after the expression when false; and

* whether a variable is definitely unassigned after the expression when false.

Here when true and when false refer to the value of the expression.For example, the local variable k is definitely assigned a value after evaluation
of the expression

a && ((k=m) > 5)
when the expression is true but not when the expression is false (because if a is
false, then the assignment to k is not necessarily executed (more properly, evalu-ated)).

The phrase "V is definitely assigned after X " (where V is a local variable and Xis a statement or expression) means "

V is definitely assigned after X if X completesnormally". If
X completes abruptly, the assignment need not have occurred, andthe rules stated here take this into account. A peculiar consequence of this definition is that "V is definitely assigned after break;" is always true! Because a
break statement never completes normally, it is vacuously true that V has beenassigned a value if the

break statement completes normally.Similarly, the statement "

V is definitely unassigned after X " (where V is a vari-able and
X is a statement or expression) means "V is definitely unassigned after Xif
X completes normally". An even more peculiar consequence of this definition is

DEFINITE ASSIGNMENT Definite Assignment 16

411DRAFT
that "V is definitely unassigned after break;" is always true! Because a breakstatement never completes normally, it is vacuously true that

V has not beenassigned a value if the
break statement completes normally. (For that matter, it isalso vacuously true that the moon is made of green cheese if the

break statementcompletes normally.)

In all, there are four possibilities for a variable V after a statement or expres-sion has been executed:

* V is definitely assigned and is not definitely unassigned.(The flow analysis rules prove that an assignment to

V has occurred.)

* V is definitely unassigned and is not definitely assigned.(The flow analysis rules prove that an assignment to

V has not occurred.)

* V is not definitely assigned and is not definitely unassigned.(The rules cannot prove whether or not an assignment to

V has occurred.)

* V is definitely assigned and is definitely unassigned.(It is impossible for the statement or expression to complete normally.)

To shorten the rules, the customary abbreviation "iff" is used to mean "if andonly if". We also use an abbreviation convention: if a rule contains one or more
occurrences of "[un]assigned" then it stands for two rules, one with every occur-rence of "[un]assigned" replaced by "definitely assigned" and one with every
occurrence of "[un]assigned" replaced by "definitely unassigned".For example:

* V is [un]assigned after an empty statement iff it is [un]assigned before theempty statement.

should be understood to stand for two rules:

* V is definitely assigned after an empty statement iff it is definitely assignedbefore the empty statement.

* V is definitely unassigned after an empty statement iff it is definitely unas-signed before the empty statement.

The definite unassignment analysis of loop statements raises a special prob-lem. Consider the statement

while (e) S. In order to determine whether V is defi-nitely unassigned within some subexpression of e, we need to determine whether

V is definitely unassigned before e. One might argue, by analogy with the rule fordefinite assignment ($16.2.9), that

V is definitely unassigned before e iff it is defi-nitely unassigned before the
while statement. However, such a rule is inadequatefor our purposes. If e evaluates to true, the statement

S will be executed. Later, if V

16.1 Definite Assignment and Expressions DEFINITE ASSIGNMENT
412 DRAFT

is assigned by S, then in the following iteration(s) V will have already beenassigned when e is evaluated. Under the rule suggested above, it would be possible to assign V multiple times, which is exactly what we have sought to avoid byintroducing these rules.

A revised rule would be: "V is definitely unassigned before e iff it is definitelyunassigned before the while statement and definitely unassigned after

S". How-ever, when we formulate the rule for
S, we find: "V is definitely unassigned before
S iff it is definitely unassigned after e when true". This leads to a circularity. Ineffect,

V is definitely unassigned before the loop condition e only if it is unas-signed after the loop as a whole!

We break this vicious circle using a hypothetical analysis of the loop condi-tion and body. For example, if we assume that

V is definitely unassigned before e(regardless of whether
V really is definitely unassigned before e), and can thenprove that
V was definitely unassigned after e then we know that e does not assign
V. This is stated more formally as:Assuming

V is definitely unassigned before e, V is definitely unassigned aftere
. Variations on the above analysis are used to define well founded definite unassignment rules for all loop statements in the language.Throughout the rest of this chapter, we will, unless explicitly stated otherwise,
write V to represent a local variable or a blank final field (for rules of definiteassignment) or a blank

final variable (for rules of definite unassignment). Like-wise, we will use a, b, c, and e to represent expressions, and

S and T to representstatements.

16.1   Definite Assignment and Expressions
16.1.1   Boolean Constant Expressions

* V is [un]assigned after any constant expression whose value is true whenfalse.

* V is [un]assigned after any constant expression whose value is false whentrue.

Because a constant expression whose value is true never has the value false,and a constant expression whose value is

false never has the value true, the twopreceding rules are vacuously satisfied. They are helpful in analyzing expressions

involving the operators && ($16.1.2), || ($16.1.3), ! ($16.1.4), and ? : ($16.1.5).

DEFINITE ASSIGNMENT The Boolean Operator ! 16.1.4

413DRAFT

* V is [un]assigned after any constant expression whose value is true when trueiff

V is [un]assigned before the constant expression.

* V is [un]assigned after any constant expression whose value is false whenfalse iff

V is [un]assigned before the constant expression.

* V is [un]assigned after a boolean-valued constant expression e iff V is[un]assigned after e when true and

V is [un]assigned after e when false. (Thisis equivalent to saying that
V is [un]assigned after e iff V is [un]assignedbefore e.)

16.1.2   The Boolean Operator &&

* V is [un]assigned after a && b when true iff V is [un]assigned after b whentrue.

* V is [un]assigned after a && b when false iff V is [un]assigned after a whenfalse and

V is [un]assigned after b when false.

* V is [un]assigned before a iff V is [un]assigned before a && b.

* V is [un]assigned before b iff V is [un]assigned after a when true.

* V is [un]assigned after a && b iff V is [un]assigned after a && b when true and

V is [un]assigned after a && b when false.

16.1.3   The Boolean Operator ||

* V is [un]assigned after a || b when true iff V is [un]assigned after a when trueand

V is [un]assigned after b when true.

* V is [un]assigned after a || b when false iff V is [un]assigned after b whenfalse.

* V is [un]assigned before a iff V is [un]assigned before a || b.

* V is [un]assigned before b iff V is [un]assigned after a when false.

* V is [un]assigned after a || b iff V is [un]assigned after a || b when true and

V is [un]assigned after a || b when false.

16.1.4   The Boolean Operator !

* V is [un]assigned after !a when true iff V is [un]assigned after a when false.

* V is [un]assigned after !a when false iff V is [un]assigned after a when true.

16.1.5 The Boolean Operator ? : DEFINITE ASSIGNMENT
414 DRAFT

* V is [un]assigned before a iff V is [un]assigned before !a.

* V is [un]assigned after !a iff V is [un]assigned after !a when true and V is[un]assigned after

!a when false. (This is equivalent to saying that V is[un]assigned after
!a iff V is [un]assigned after a.)

16.1.5   The Boolean Operator ? :
Suppose that b and c are boolean-valued expressions.

* V is [un]assigned after a ? b : c when true iff V is [un]assigned after b whentrue and

V is [un]assigned after c when true.

* V is [un]assigned after a ? b : c when false iff V is [un]assigned after b whenfalse and

V is [un]assigned after c when false.

* V is [un]assigned before a iff V is [un]assigned before a ? b : c.

* V is [un]assigned before b iff V is [un]assigned after a when true.

* V is [un]assigned before c iff V is [un]assigned after a when false.

* V is [un]assigned after a ? b : c iff V is [un]assigned after a ? b : c when trueand

V is [un]assigned after a ? b : c when false.

16.1.6   The Conditional Operator ? :
Suppose that b and c are expressions that are not boolean-valued.

* V is [un]assigned after a ? b : c iff V is [un]assigned after b and V is[un]assigned after c.

* V is [un]assigned before a iff V is [un]assigned before a ? b : c.

* V is [un]assigned before b iff V is [un]assigned after a when true.

* V is [un]assigned before c iff V is [un]assigned after a when false.

16.1.7   Assignment Expressions
Consider an assignment expression a = b, a += b, a -= b, a *= b, a /= b, a %= b, a
<<= b, a >>= b, a >>>= b, a &= b, a |= b, or a ^= b.

DEFINITE ASSIGNMENT Other Expressions 16.1.9

415DRAFT

* V is definitely assigned after the assignment expression iff either a is V or V isdefinitely assigned after b.

* V is definitely unassigned after the assignment expression iff a is not V and Vis definitely unassigned after b.

* V is [un]assigned before a iff V is [un]assigned before the assignment expres-sion.

* V is [un]assigned before b iff V is [un]assigned after a.

Note that if a is V and V is not definitely assigned before a compound assign-ment such as a

&= b, then a compile-time error will necessarily occur. The firstrule for definite assignment stated above includes the disjunct "a is

V " even forcompound assignment expressions, not just simple assignments, so that

V will beconsidered to have been definitely assigned at later points in the code. Including

the disjunct "a is V " does not affect the binary decision as to whether a program isacceptable or will result in a compile-time error, but it affects how many different
points in the code may be regarded as erroneous, and so in practice it can improvethe quality of error reporting. A similar remark applies to the inclusion of the conjunct "a is not V " in the first rule for definite unassignment stated above.If the assignment expression is boolean-valued, then these rules also apply:

* V is [un]assigned after the assignment expression when true iff V is[un]assigned after the assignment expression.

* V is [un]assigned after the assignment expression when false iff V is[un]assigned after the assignment expression.

16.1.8   Operators ++ and --

* V is definitely assigned after ++a, --a, a++, or a-- iff either a is V or V is def-initely assigned after the operand expression.

* V is definitely unassigned after ++a, --a, a++, or a-- iff a is not V and V isdefinitely unassigned after the operand expression.

* V is [un]assigned before a iff V is [un]assigned before ++a, --a, a++, or a--.
16.1.9   Other Expressions
If an expression is not a boolean constant expression, and is not a preincrementexpression

++a, predecrement expression --a, postincrement expression a++,postdecrement expression a

--, logical complement expression !a, conditional16.1.9 Other Expressions DEFINITE ASSIGNMENT
416 DRAFT

and expression a && b, conditional-or expression a || b, conditional expression a
? b : c, or assignment expression, then the following rules apply:

* If the expression has no subexpressions, V is [un]assigned after the expressioniff

V is [un]assigned before the expression. This case applies to literals,names,

this (both qualified and unqualified), unqualified class instance cre-ation expressions with no arguments, initialized array creation expressions

whose initializers contain no expressions, unqualified superclass field accessexpressions, named method invocations with no arguments, and unqualified
superclass method invocations with no arguments.

* If the expression has subexpressions, V is [un]assigned after the expression iff

V is [un]assigned after its rightmost immediate subexpression.

There is a piece of subtle reasoning behind the assertion that a variable V canbe known to be definitely unassigned after a method invocation. Taken by itself, at
face value and without qualification, such an assertion is not always true, becausean invoked method can perform assignments. But it must be remembered that, for
the purposes of the Java programming language, the concept of definite unassign-ment is applied only to blank

final variables. If V is a blank final local variable,then only the method to which its declaration belongs can perform assignments to

V. If V is a blank final field, then only a constructor or an initializer for the classcontaining the declaration for

V can perform assignments to V; no method can per-form assignments to
V. Finally, explicit constructor invocations ($8.8.5) are han-dled specially ($16.8); although they are syntactically similar to expression

statements containing method invocations, they are not expression statements andtherefore the rules of this section do not apply to explicit constructor invocations.

For any immediate subexpression y of an expression x, V is [un]assignedbefore y iff one of the following situations is true:

* y is the leftmost immediate subexpression of x and V is [un]assigned before x.

* y is the right-hand operand of a binary operator and V is [un]assigned after theleft-hand operand.

* x is an array access, y is the subexpression within the brackets, and V is[un]assigned after the subexpression before the brackets.

* x is a primary method invocation expression, y is the first argument expressionin the method invocation expression, and

V is [un]assigned after the primaryexpression that computes the target object.

DEFINITE ASSIGNMENT Blocks 16.2.2

417DRAFT

* x is a method invocation expression or a class instance creation expression; yis an argument expression, but not the first; and

V is [un]assigned after theargument expression to the left of y.

* x is a qualified class instance creation expression, y is the first argumentexpression in the class instance creation expression, and

V is [un]assignedafter the primary expression that computes the qualifying object.

* x is an array instance creation expression; y is a dimension expression, but notthe first; and

V is [un]assigned after the dimension expression to the left of y.

* x is an array instance creation expression initialized via an array initializer; yis the array initializer in x; and V is [un]assigned after the dimension expression to the left of y.

16.2   Definite Assignment and Statements
16.2.1   Empty Statements

* V is [un]assigned after an empty statement iff it is [un]assigned before theempty statement.

16.2.2   Blocks

* A blank final member field V is definitely assigned (and moreover is not defi-nitely unassigned) before the block that is the body of any method in the

scope of V.

* A local variable V is definitely unassigned (and moreover is not definitelyassigned) before the block that is the body of the constructor, method,

instance initializer or static initializer that declares V.

* Let C be a class declared within the scope of V. Then:

u V is definitely assigned before the block that is the body of any constructor,method, instance initializer or static initializer declared in

C iff V is defi-nitely assigned before the declaration of
C.

Note that there are no rules that would allow us to conclude that V is definitelyunassigned before the block that is the body of any constructor, method,

instance initializer or static initializer declared in C. We can informally con-clude that

V is not definitely unassigned before the block that is the body of

16.2.3 Local Class Declaration Statements DEFINITE ASSIGNMENT
418 DRAFT

any constructor, method, instance initializer or static initializer declared in C,but there is no need for such a rule to be stated explicitly.

* V is [un]assigned after an empty block iff it is [un]assigned before the emptyblock.

* V is [un]assigned after a nonempty block iff it is [un]assigned after the laststatement in the block.

* V is [un]assigned before the first statement of the block iff it is [un]assignedbefore the block.

* V is [un]assigned before any other statement S of the block iff it is[un]assigned after the statement immediately preceding

S in the block.

16.2.3   Local Class Declaration Statements

* V is [un]assigned after a local class declaration statement iff it is [un]assignedbefore the local class declaration statement.

16.2.4   Local Variable Declaration Statements

* V is [un]assigned after a local variable declaration statement that contains novariable initializers iff it is [un]assigned before the local variable declaration

statement.

* V is definitely assigned after a local variable declaration statement that con-tains at least one variable initializer iff either it is definitely assigned after the

last variable initializer in the local variable declaration statement or the lastvariable initializer in the declaration is in the declarator that declares

V.

* V is definitely unassigned after a local variable declaration statement that con-tains at least one variable initializer iff it is definitely unassigned after the last

variable initializer in the local variable declaration statement and the last vari-able initializer in the declaration is not in the declarator that declares

V.

* V is [un]assigned before the first variable initializer iff it is [un]assignedbefore the local variable declaration statement.

* V is definitely assigned before any variable initializer e other than the first onein the local variable declaration statement iff either

V is definitely assignedafter the variable initializer to the left of e or the initializer expression to the

left of e is in the declarator that declares V.

* V is definitely unassigned before any variable initializer e other than the firstone in the local variable declaration statement iff

V is definitely unassigned

DEFINITE ASSIGNMENT switch Statements 16.2.8

419DRAFT
after the variable initializer to the left of e and the initializer expression to theleft of e is not in the declarator that declares

V.

16.2.5   Labeled Statements

* V is [un]assigned after a labeled statement L:S (where L is a label) iff V is[un]assigned after

S and V is [un]assigned before every break statement thatmay exit the labeled statement

L:S.

* V is [un]assigned before S iff V is [un]assigned before L:S.

16.2.6   Expression Statements

* V is [un]assigned after an expression statement e; iff it is [un]assigned after e.

* V is [un]assigned before e iff it is [un]assigned before e;.

16.2.7 if Statements
The following rules apply to a statement if (e) S:

* V is [un]assigned after if (e) S iff V is [un]assigned after S and V is[un]assigned after e when false.

* V is [un]assigned before e iff V is [un]assigned before if (e) S.

* V is [un]assigned before S iff V is [un]assigned after e when true.

The following rules apply to a statement if (e) S else T:

* V is [un]assigned after if (e) S else T iff V is [un]assigned after S and V is[un]assigned after

T.

* V is [un]assigned before e iff V is [un]assigned before if (e) S else T.

* V is [un]assigned before S iff V is [un]assigned after e when true.

* V is [un]assigned before T iff V is [un]assigned after e when false.

16.2.8 switch Statements

* V is [un]assigned after a switch statement iff all of the following are true:

u Either there is a default label in the switch block or V is [un]assignedafter the switch expression.

16.2.9 while Statements DEFINITE ASSIGNMENT

420 DRAFT

u Either there are no switch labels in the switch block that do not begin ablock-statement-group (that is, there are no switch labels immediately

before the "}" that ends the switch block) or V is [un]assigned after theswitch expression.

u Either the switch block contains no block-statement-groups or V is[un]assigned after the last block-statement of the last block-statementgroup.
u V is [un]assigned before every break statement that may exit the switchstatement.

* V is [un]assigned before the switch expression iff V is [un]assigned before the

switch statement.

If a switch block contains at least one block-statement-group, then the followingrules also apply:

* V is [un]assigned before the first block-statement of the first block-statement-group in the switch block iff

V is [un]assigned after the switch expression.

* V is [un]assigned before the first block-statement of any block-statement-group other than the first iff

V is [un]assigned after the switch expression and
V is [un]assigned after the last block-statement of the preceding block-state-ment-group.

* V is [un]assigned before any block-statement other than the first of any block-statement-group in the switch block iff

V is [un]assigned after the last block-statement of the preceding block-statement-group.

16.2.9 while Statements

* V is [un]assigned after while (e) S iff V is [un]assigned after e when falseand

V is [un]assigned before every break statement for which the whilestatement is the break target.

* V is definitely assigned before e iff V is definitely assigned before the whilestatement.

* V is definitely unassigned before e iff all of the following conditions hold:

u V is definitely unassigned before the while statement.
u Assuming V is definitely unassigned before e, V is definitely unassignedafter

S.

DEFINITE ASSIGNMENT for Statements 16.2.11

421DRAFT
u Assuming V is definitely unassigned before e, V is definitely unassignedbefore every

continue statement for which the while statement is the con-tinue target.

* V is [un]assigned before S iff V is [un]assigned after e when true.
16.2.10 do Statements

* V is [un]assigned after do S while (e); iff V is [un]assigned after e whenfalse and

V is [un]assigned before every break statement for which the dostatement is the break target.

* V is definitely assigned before S iff V is definitely assigned before the dostatement.

* V is definitely unassigned before S iff all of the following conditions hold:

u V is definitely unassigned before the do statement.
u Assuming V is definitely unassigned before S, V is definitely unassignedafter e when true.

* V is [un]assigned before e iff V is [un]assigned after S and V is [un]assignedbefore every

continue statement for which the do statement is the continuetarget.

16.2.11 for Statements

* V is [un]assigned after a for statement iff both of the following are true:

u Either a condition expression is not present or V is [un]assigned after thecondition expression when false.

u V is [un]assigned before every break statement for which the for statementis the break target.

* V is [un]assigned before the initialization part of the for statement iff V is[un]assigned before the

for statement.

* V is definitely assigned before the condition part of the for statement iff V isdefinitely assigned after the initialization part of the

for statement.

* V is definitely unassigned before the condition part of the for statement iff allof the following conditions hold:

u V is definitely unassigned after the initialization part of the for statement.

16.2.11 for Statements DEFINITE ASSIGNMENT
422 DRAFT

u Assuming V is definitely unassigned before the condition part of the forstatement,

V is definitely unassigned after the contained statement.

u Assuming V is definitely unassigned before the contained statement, V isdefinitely unassigned before every

continue statement for which the forstatement is the continue target.

* V is [un]assigned before the contained statement iff either of the following istrue:

u A condition expression is present and V is [un]assigned after the conditionexpression when true.
u No condition expression is present and V is [un]assigned after the initializa-tion part of the

for statement.

* V is [un]assigned before the incrementation part of the for statement iff V is[un]assigned after the contained statement and

V is [un]assigned before every
continue statement for which the for statement is the continue target.

16.2.11.1 Initialization Part

* If the initialization part of the for statement is a local variable declarationstatement, the rules of $16.2.4 apply.

* Otherwise, if the initialization part is empty, then V is [un]assigned after theinitialization part iff

V is [un]assigned before the initialization part.

* Otherwise, three rules apply:

u V is [un]assigned after the initialization part iff V is [un]assigned after thelast expression statement in the initialization part.

u V is [un]assigned before the first expression statement in the initializationpart iff

V is [un]assigned before the initialization part.

u V is [un]assigned before an expression statement E other than the first in theinitialization part iff

V is [un]assigned after the expression statement imme-diately preceding
E.

16.2.11.2 Incrementation Part

* If the incrementation part of the for statement is empty, then V is[un]assigned after the incrementation part iff

V is [un]assigned before theincrementation part.

* Otherwise, three rules apply:

DEFINITE ASSIGNMENT try Statements 16.2.14

423DRAFT
u V is [un]assigned after the incrementation part iff V is [un]assigned after thelast expression statement in the incrementation part.
u V is [un]assigned before the first expression statement in the incrementationpart iff

V is [un]assigned before the incrementation part.

u V is [un]assigned before an expression statement E other than the first in theincrementation part iff

V is [un]assigned after the expression statementimmediately preceding
E.

16.2.12 break, continue, return, and throw Statements

* By convention, we say that V is [un]assigned after any break, continue,

return, or throw statement. The notion that a variable is "[un]assigned after"a statement or expression really means "is [un]assigned after the statement or

expression completes normally". Because a break, continue, return, or
throw statement never completes normally, it vacuously satisfies this notion.

* In a return statement with an expression e or a throw statement with anexpression e,

V is [un]assigned before e iff V is [un]assigned before the
return or throw statement.

16.2.13 synchronized Statements

* V is [un]assigned after synchronized (e) S iff V is [un]assigned after S.

* V is [un]assigned before e iff V is [un]assigned before the statement synchronized (e) S.

* V is [un]assigned before S iff V is [un]assigned after e.

16.2.14 try Statements
These rules apply to every try statement, whether or not it has a finally block:

* V is [un]assigned before the try block iff V is [un]assigned before the trystatement.

* V is definitely assigned before a catch block iff V is definitely assignedbefore the

try block.

* V is definitely unassigned before a catch block iff V is definitely unassignedafter the

try block and V is definitely unassigned before every return state-ment that belongs to the

try block, every throw statement that belongs to the
try block, every break statement that belongs to the try block and whose

16.3 Definite Assignment and Parameters DEFINITE ASSIGNMENT
424 DRAFT

break target contains (or is) the try statement, and every continue statementthat belongs to the

try block and whose continue target contains the trystatement.

If a try statement does not have a finally block, then this rule also applies:

* V is [un]assigned after the try statement iff V is [un]assigned after the tryblock and

V is [un]assigned after every catch block in the try statement.

If a try statement does have a finally block, then these rules also apply:

* V is definitely assigned after the try statement iff at least one of the followingis true:

u V is definitely assigned after the try block and V is definitely assigned afterevery

catch block in the try statement.

u V is definitely assigned after the finally block.
u V is definitely unassigned after a try statement iff V is definitely unassignedafter the

finally block.

* V is definitely assigned before the finally block iff V is definitely assignedbefore the

try statement.

* V is definitely unassigned before the finally block iff V is definitely unas-signed after the

try block and V is definitely unassigned before every returnstatement that belongs to the

try block, every throw statement that belongsto the
try block, every break statement that belongs to the try block andwhose break target contains (or is) the

try statement, and every continuestatement that belongs to the
try block and whose continue target containsthe
try statement and V is definitely unassigned after every catch block ofthe
try statement.

16.3   Definite Assignment and Parameters

* A formal parameter V of a method or constructor is definitely assigned (andmoreover is not definitely unassigned) before the body of the method or constructor.

* An exception parameter V of a catch clause is definitely assigned (and more-over is not definitely unassigned) before the body of the

catch clause.

DEFINITE ASSIGNMENT Definite Assignment and Static Initializers 16.7

425DRAFT
16.4   Definite Assignment and Array Initializers

* V is [un]assigned after an empty array initializer iff it is [un]assigned beforethe empty array initializer.

* V is [un]assigned after a nonempty array initializer iff it is [un]assigned afterthe last variable initializer in the array initializer.

* V is [un]assigned before the first variable initializer of the array initializer iff itis [un]assigned before the array initializer.

* V is [un]assigned before any other variable initializer I of the array initializeriff it is [un]assigned after the variable initializer to the left of

I in the arrayinitializer.

16.5   Definite Assignment and Anonymous Classes

* V is definitely assigned before an anonymous class declaration ($15.9.5) thatis declared within the scope of

V iff V is definitely assigned after the classinstance creation expression that declares the anonymous class.

16.6 Definite Assignment and Member Types
Let C be a class declared within the scope of V. Then:

* V is definitely assigned before a member type ($8.5, $9.5) declaration of C iff

V is definitely assigned before the declaration of C.

16.7   Definite Assignment and Static Initializers
Let C be a class declared within the scope of V. Then:

* V is definitely assigned before a static variable initializer of C iff V is definitelyassigned before the declaration of

C.

Note that there are no rules that would allow us to conclude that V is definitelyunassigned before a static variable initializer. We can informally conclude that

V isnot definitely unassigned before any static variable initializer of
C, but there is noneed for such a rule to be stated explicitly.

16.8 Definite Assignment, Constructors, and Instance Initializers DEFINITE ASSIGNMENT

426 DRAFT

Let C be a class, and let V be a blank final static member field of C,declared in

C. Then:

* V is definitely unassigned (and moreover is not definitely assigned) before theleftmost

static initializer or static variable initializer of C.

* V is [un]assigned before a static initializer or static variable initializer of

C other than the leftmost iff V is [un]assigned after the preceding static ini-tializer or

static variable initializer of C.

Let C be a class, and let V be a blank final static member field of C,declared in a superclass of

C. Then:

* V is definitely assigned (and moreover is not definitely unassigned) before theblock that is the body of a static initializer of

C.

* V is definitely assigned (and moreover is not definitely unassigned) beforeevery static variable initializer of

C.

16.8 Definite Assignment, Constructors, and Instance Initializers
Let C be a class declared within the scope of V. Then:

* V is definitely assigned before an instance variable initializer of C iff V is defi-nitely assigned before the declaration of

C.

Note that there are no rules that would allow us to conclude that V is definitelyunassigned before an instance variable initializer. We can informally conclude that
V is not definitely unassigned before any instance variable initializer of C, butthere is no need for such a rule to be stated explicitly.

Let C be a class, and let V be a blank final non-static member field of C,declared in

C. Then:

* V is definitely unassigned (and moreover is not definitely assigned) before theleftmost instance initializer or instance variable initializer of

C.

* V is [un]assigned before an instance initializer or instance variable initializerof

C other than the leftmost iff V is [un]assigned after the preceding instanceinitializer or instance variable initializer of

C.

The following rules hold within the constructors of class C:

DEFINITE ASSIGNMENT Definite Assignment, Constructors, and Instance Initializers 16.8

427DRAFT

* V is definitely assigned (and moreover is not definitely unassigned) after analternate constructor invocation.

* V is definitely unassigned (and moreover is not definitely assigned) before anexplicit or implicit superclass constructor invocation.

* If C has no instance initializers or instance variable initializers, then V is notdefinitely assigned (and moreover is definitely unassigned) after an explicit or

implicit superclass constructor invocation.

* If C has at least one instance initializer or instance variable initializer then V is[un]assigned after an explicit or implicit superclass constructor invocation iff

V is [un]assigned after the rightmost instance initializer or instance variableinitializer of

C.

Let C be a class, and let V be a blank final member field of C, declared in a super-class of

C. Then:

* V is definitely assigned (and moreover is not definitely unassigned) before theblock that is the body of a constructor, or instance initializer of

C.

* V is definitely assigned (and moreover is not definitely unassigned) beforeevery instance variable initializer of

C.

16.8 Definite Assignment, Constructors, and Instance Initializers DEFINITE ASSIGNMENT

428 DRAFT429DRAFT

C H A P T E R 17
Threads and Locks

WHILE most of the discussion in the preceding chapters is concerned only withthe behavior of code as executed a single statement or expression at a time, that is,
by a single thread, each Java virtual machine can support many threads of execu-tion at once. These threads independently execute code that operates on values
and objects residing in a shared main memory. Threads may be supported by hav-ing many hardware processors, by time-slicing a single hardware processor, or by
time-slicing many hardware processors.The Java programming language supports the coding of programs that, though
concurrent, still exhibit deterministic behavior, by providing mechanisms for syn-chronizing the concurrent activity of threads. To synchronize threads, the Java
programming language uses monitors, which are a high-level mechanism forallowing only one thread at a time to execute a region of code protected by the
monitor. The behavior of monitors is explained in terms of locks; there is a lockassociated with each object.

The synchronized statement ($14.18) performs two special actions relevantonly to multithreaded operation: (1) after computing a reference to an object but
before executing its body, it locks a lock associated with the object, and (2) afterexecution of the body has completed, either normally or abruptly, it unlocks that
same lock. As a convenience, a method may be declared synchronized; such amethod behaves as if its body were contained in a

synchronized statement.The methods
wait, notify, and notifyAll of class Object support an effi-cient transfer of control from one thread to another. Rather than simply "spinning"

(repeatedly locking and unlocking an object to see whether some internal state haschanged), which consumes computational effort, a thread can suspend itself using
wait until such time as another thread awakens it using notify. This is especiallyappropriate in situations where threads have a producer-consumer relationship
(actively cooperating on a common goal) rather than a mutual exclusion relation-ship (trying to avoid conflicts while sharing a common resource).

As a thread executes code, it carries out a sequence of actions. A thread mayuse the value of a variable or assign it a new value. (Other actions include arithmetic operations, conditional tests, and method invocations, but these do not

17.1 Terminology and Framework THREADS AND LOCKS
430 DRAFT

involve variables directly.) If two or more concurrent threads act on a shared vari-able, there is a possibility that the actions on the variable will produce timingdependent results. This dependence on timing is inherent in concurrent program-ming, producing one of the few places in the language where the result of executing a program is not determined solely by this specification.Each thread has a working memory, in which it may keep copies of the values
of variables from the main memory that is shared between all threads. To access ashared variable, a thread usually first obtains a lock and flushes its working memory. This guarantees that shared values will thereafter be loaded from the sharedmain memory to the threads working memory. When a thread unlocks a lock it
guarantees the values it holds in its working memory will be written back to themain memory.

This chapter explains the interaction of threads with the main memory, andthus with each other, in terms of certain low-level actions. There are rules about
the order in which these actions may occur. These rules impose constraints on anyimplementation of the Java programming language, and a programmer may rely
on the rules to predict the possible behaviors of a concurrent program. The rulesdo, however, intentionally give the implementor certain freedoms; the intent is to
permit certain standard hardware and software techniques that can greatlyimprove the speed and efficiency of concurrent code.

Briefly put, these are the important consequences of the rules:

* Proper use of synchronization constructs will allow reliable transmission ofvalues or sets of values from one thread to another through shared variables.

* When a thread uses the value of a variable, the value it obtains is in fact avalue stored into the variable by that thread or by some other thread. This is

true even if the program does not contain code for proper synchronization. Forexample, if two threads store references to different objects into the same reference value, the variable will subsequently contain a reference to one objector the other, not a reference to some other object or a corrupted reference
value. (There is a special exception for long and double values; see $17.4.)

* In the absence of explicit synchronization, an implementation is free to updatethe main memory in an order that may be surprising. Therefore the programmer who prefers to avoid surprises should use explicit synchronization.

17.1   Terminology and Framework
A variable is any location within a program that may be stored into. This includesnot only class variables and instance variables but also components of arrays.
Variables are kept in a main memory that is shared by all threads. Because it is

THREADS AND LOCKS Terminology and Framework 17.1

431DRAFT
impossible for one thread to access parameters or local variables of anotherthread, it doesn't matter whether parameters and local variables are thought of as
residing in the shared main memory or in the working memory of the thread thatowns them.

Every thread has a working memory in which it keeps its own working copy ofvariables that it must use or assign. As the thread executes a program, it operates
on these working copies. The main memory contains the master copy of everyvariable. There are rules about when a thread is permitted or required to transfer
the contents of its working copy of a variable into the master copy or vice versa.The main memory also contains locks; there is one lock associated with each
object. Threads may compete to acquire a lock.For the purposes of this chapter, the verbs use, assign, load, store, lock, and
unlock name actions that a thread can perform. The verbs read, write, lock, andunlock name actions that the main memory subsystem can perform. Each of these
actions is atomic (indivisible).A use or assign action is a tightly coupled interaction between a thread's execution engine and the thread's working memory. A lock or unlock action is atightly coupled interaction between a thread's execution engine and the main
memory. But the transfer of data between the main memory and a thread's work-ing memory is loosely coupled. When data is copied from the main memory to a
working memory, two actions must occur: a read action performed by the mainmemory followed some time later by a corresponding load action performed by
the working memory. When data is copied from a working memory to the mainmemory, two actions must occur: a store action performed by the working memory followed some time later by a corresponding write action performed by themain memory. There may be some transit time between main memory and a
working memory, and the transit time may be different for each transaction; thusactions initiated by a thread on different variables may viewed by another thread
as occurring in a different order. For each variable, however, the actions in mainmemory on behalf of any one thread are performed in the same order as the corresponding actions by that thread. (This is explained in greater detail below.)A single thread issues a stream of use, assign, lock, and unlock actions as dictated by the semantics of the program it is executing. The underlying implementa-tion is then required additionally to perform appropriate load, store, read, and
write actions so as to obey a certain set of constraints, explained below. If theimplementation correctly follows these rules and the application programmer follows certain other rules of programming, then data can be reliably transferredbetween threads through shared variables. The rules are designed to be "tight"
enough to make this possible but "loose" enough to allow hardware and software

17.2 Execution Order THREADS AND LOCKS
432 DRAFT

designers considerable freedom to improve speed and throughput through suchmechanisms as registers, queues, and caches.

Here are the detailed definitions of each of the actions:

* A use action (by a thread) transfers the contents of the thread's working copyof a variable to the thread's execution engine. This action is performed whenever a thread executes a virtual machine instruction that uses the value of avariable.

* An assign action (by a thread) transfers a value from the thread's executionengine into the thread's working copy of a variable. This action is performed

whenever a thread executes a virtual machine instruction that assigns to avariable.

* A read action (by the main memory) transmits the contents of the master copyof a variable to a thread's working memory for use by a later load action.

* A load action (by a thread) puts a value transmitted from main memory by aread action into the thread's working copy of a variable.

* A store action (by a thread) transmits the contents of the thread's workingcopy of a variable to main memory for use by a later write action.

* A write action (by the main memory) puts a value transmitted from thethread's working memory by a store action into the master copy of a variable

in main memory.

* A lock action (by a thread tightly synchronized with main memory) causes athread to acquire one claim on a particular lock.

* An unlock action (by a thread tightly synchronized with main memory) causesa thread to release one claim on a particular lock.

Thus the interaction of a thread with a variable over time consists of asequence of use, assign, load, and store actions. Main memory performs a read
action for every load and a write action for every store. A thread's interactionswith a lock over time consists of a sequence of lock and unlock actions. All the
globally visible behavior of a thread thus comprises all the thread's actions onvariables and locks.

17.2   Execution Order
The rules of execution order constrain the order in which certain events mayoccur. There are four general constraints on the relationships among actions:

THREADS AND LOCKS Execution Order 17.2

433DRAFT

* The actions performed by any one thread are totally ordered; that is, for anytwo actions performed by a thread, one action precedes the other.

* The actions performed by the main memory for any one variable are totallyordered; that is, for any two actions performed by the main memory on the

same variable, one action precedes the other.

* The actions performed by the main memory for any one lock are totallyordered; that is, for any two actions performed by the main memory on the

same lock, one action precedes the other.

* It is not permitted for an action to follow itself.

The last rule may seem trivial, but it does need to be stated separately and explic-itly for completeness. Without it, it would be possible to propose a set of actions
by two or more threads and precedence relationships among the actions thatwould satisfy all the other rules but would require an action to follow itself.

Threads do not interact directly; they communicate only through the sharedmain memory. The relationships between the actions of a thread and the actions of
main memory are constrained in three ways:

* Each lock or unlock action is performed jointly by some thread and the mainmemory.

* Each load action by a thread is uniquely paired with a read action by the mainmemory such that the load action follows the read action.

* Each store action by a thread is uniquely paired with a write action by themain memory such that the write action follows the store action.

Most of the rules in the following sections further constrain the order in whichcertain actions take place. A rule may state that one action must precede or follow
some other action. Note that this relationship is transitive: if action A must precedeaction

B, and B must precede C, then A must precede C. The programmer mustremember that these rules are the only constraints on the ordering of actions; if no

rule or combination of rules implies that action A must precede action B, then animplementation is free to perform action

B before action A, or to perform action Bconcurrently with action
A. This freedom can be the key to good performance.Conversely, an implementation is not required to take advantage of all the freedoms given it.In the rules that follow, the phrasing "

B must intervene between A and C"means that action
B must follow action A and precede action C.

17.3 Rules about Variables THREADS AND LOCKS

434 DRAFT

17.3   Rules about Variables
Let T be a thread and V be a variable. There are certain constraints on the actionsperformed by

T with respect to V:

* An use or assign by T of V is permitted only when dictated by execution by Tof the program according to the Java programming language's execution

model. For example, an occurrence of V as an operand of the + operatorrequires that a single use action occur on

V; an occurrence of V as the left-hand operand of the assignment operator
= requires that a single assign actionoccur. All use and assign actions by a given thread must occur in the order

specified by the program being executed by the thread. If the following rulesforbid

T to perform a required use as its next action, it may be necessary for Tto perform a load first in order to make progress.

* A store action by T on V must intervene between an assign by T of V and asubsequent load by

T of V. (Less formally: a thread is not permitted to lose itsmost recent assign.)

* An assign action by T on V must intervene between a load or store by T of Vand a subsequent store by

T of V. (Less formally: a thread is not permitted towrite data from its working memory back to main memory for no reason.)

* After a thread is created, it must perform an assign or load action on a vari-able before performing a use or store action on that variable. (Less formally: a

new thread starts with an empty working memory.)

* After a variable is created, every thread must perform an assign or load actionon that variable before performing a use or store action on that variable. (Less

formally: a new variable is created only in main memory and is not initially inany thread's working memory.)

Provided that all the constraints above and below are obeyed, a load or storeaction may be issued at any time by any thread on any variable, at the whim of the
implementation.There are also certain constraints on the read and write actions performed by
main memory:

* For every load action performed by any thread T on its working copy of avariable

V, there must be a corresponding preceding read action by the mainmemory on the master copy of

V, and the load action must put into the work-ing copy the data transmitted by the corresponding read action.

* For every store action performed by any thread T on its working copy of avariable

V, there must be a corresponding following write action by the main

THREADS AND LOCKS Nonatomic Treatment of double and long 17.4

435DRAFT
memory on the master copy of V, and the write action must put into the mastercopy the data transmitted by the corresponding store action.

* Let action A be a load or store by thread T on variable V, and let action P bethe corresponding read or write by the main memory on variable

V. Similarly,let action
B be some other load or store by thread T on that same variable V,and let action

Q be the corresponding read or write by the main memory onvariable
V. If A precedes B, then P must precede Q. (Less formally: actions onthe master copy of any given variable on behalf of a thread are performed by

the main memory in exactly the order that the thread requested.)
Note that this last rule applies only to actions by a thread on the same variable.However, there is a more stringent rule for

volatile variables ($17.7).

17.4   Nonatomic Treatment of double and long
If a double or long variable is not declared volatile, then for the purposes ofload, store, read, and write actions they are treated as if they were two variables of
32 bits each: wherever the rules require one of these actions, two such actions areperformed, one for each 32-bit half. The manner in which the 64 bits of a

doubleor
long variable are encoded into two 32-bit quantities is implementation-depen-dent. The load, store, read, and write actions on

volatile variables are atomic,even if the type of the variable is
double or long.This matters only because a read or write of a

double or long variable maybe handled by an actual main memory as two 32-bit read or write actions that may

be separated in time, with other actions coming between them. Consequently, iftwo threads concurrently assign distinct values to the same shared nonvolatile
double or long variable, a subsequent use of that variable may obtain a value thatis not equal to either of the assigned values, but some implementation-dependent

mixture of the two values.An implementation is free to implement load, store, read, and write actions
for double and long values as atomic 64-bit actions; in fact, this is stronglyencouraged. The model divides them into 32-bit halves for the sake of several currently popular microprocessors that fail to provide efficient atomic memory trans-actions on 64-bit quantities. It would have been simpler to define all memory
transactions on single variables as atomic; this more complex definition is a prag-matic concession to current hardware practice. In the future this concession may
be eliminated. Meanwhile, programmers are cautioned always to explicitly syn-chronize access to shared

double and long variables.

17.5 Rules about Locks THREADS AND LOCKS
436 DRAFT

17.5   Rules about Locks
Let T be a thread and L be a lock. There are certain constraints on the actions per-formed by

T with respect to L:

* A lock action by T on L may occur only if, for every thread S other than T, thenumber of preceding unlock actions by

S on L equals the number of precedinglock actions by
S on L. (Less formally: only one thread at a time is permittedto lay claim to a lock, and moreover a thread may acquire the same lock multiple times and doesn't relinquish ownership of it until a matching number ofunlock actions have been performed.)

* An unlock action by thread T on lock L may occur only if the number of pre-ceding unlock actions by

T on L is strictly less than the number of precedinglock actions by
T on L. (Less formally: a thread is not permitted to unlock alock it doesn't own.)

With respect to a lock, the lock and unlock actions performed by all thethreads are performed in some total sequential order. This total order must be consistent with the total order on the actions of each thread.

17.6   Rules about the Interaction of Locks and Variables
Let T be any thread, let V be any variable, and let L be any lock. There are certainconstraints on the actions performed by

T with respect to V and L:

* Between an assign action by T on V and a subsequent unlock action by T on L,a store action by

T on V must intervene; moreover, the write action corre-sponding to that store must precede the unlock action, as seen by main memory. (Less formally: if a thread is to perform an unlock action on any lock, itmust first copy all assigned values in its working memory back out to main
memory.)

* Between a lock action by T on L and a subsequent use or store action by T ona variable

V, an assign or load action on V must intervene; moreover, if it is aload action, then the read action corresponding to that load must follow the

lock action, as seen by main memory. (Less formally: a lock action acts as if itflushes all variables from the thread's working memory; before use they must
be assigned or loaded from main memory.)

THREADS AND LOCKS Prescient Store Actions 17.8

437DRAFT
17.7   Rules for Volatile Variables
If a variable is declared volatile, then additional constraints apply to the actionsof each thread.

Let T be a thread and let V and W be volatile variables.

* A use action by T on V is permitted only if the previous action by T on V wasload, and a load action by

T on V is permitted only if the next action by T on Vis use. The use action is said to be "associated" with the read action that corresponds to the load.

* A store action by T on V is permitted only if the previous action by T on V wasassign, and an assign action by

T on V is permitted only if the next action by Ton
V is store. The assign action is said to be "associated" with the write actionthat corresponds to the store.

* Let action A be a use or assign by thread T on variable V, let action F be theload or store associated with

A, and let action P be the read or write of V thatcorresponds to
F. Similarly, let action B be a use or assign by thread T onvariable
W, let action G be the load or store associated with B, and let action Qbe the read or write of

W that corresponds to G. If A precedes B, then P mustprecede
Q. (Less formally: actions on the master copies of volatile variableson behalf of a thread are performed by the main memory in exactly the order

that the thread requested.)
The load, store, read, and write actions on volatile variables are atomic,even if the type of the variable is

double or long.

17.8   Prescient Store Actions
If a variable is not declared volatile, then the rules in the previous sections arerelaxed slightly to allow store actions to occur earlier than would otherwise be
permitted. The purpose of this relaxation is to allow optimizing Java compilers toperform certain kinds of code rearrangement that preserve the semantics of properly synchronized programs but might be caught in the act of performing memoryactions out of order by programs that are not properly synchronized.

Suppose that a store by T of V would follow a particular assign by T of Vaccording to the rules of the previous sections, with no intervening load or assign
by T of V. Then that store action would send to the main memory the value thatthe assign action put into the working memory of thread

T. The special ruleallows the store action to instead occur before the assign action, if the following

restrictions are obeyed:

17.9 Discussion THREADS AND LOCKS
438 DRAFT

* If the store action occurs, the assign is bound to occur. (Remember, these arerestrictions on what actually happens, not on what a thread plans to do. No

fair performing a store and then throwing an exception before the assignoccurs!)

* No lock action intervenes between the relocated store and the assign.

* No load of V intervenes between the relocated store and the assign.

* No other store of V intervenes between the relocated store and the assign.

* The store action sends to the main memory the value that the assign actionwill put into the working memory of thread

T.

This last property inspires us to call such an early store action prescient: it has toknow ahead of time, somehow, what value will be stored by the assign that it
should have followed. In practice, optimized compiled code will compute suchvalues early (which is permitted if, for example, the computation has no side
effects and throws no exceptions), store them early (before entering a loop, forexample), and keep them in working registers for later use within the loop.

17.9 Discussion
Any association between locks and variables is purely conventional. Locking anylock conceptually flushes all variables from a thread's working memory, and
unlocking any lock forces the writing out to main memory of all variables that thethread has assigned. That a lock may be associated with a particular object or a
class is purely a convention. In some applications, it may be appropriate always tolock an object before accessing any of its instance variables, for example; synchronized methods are a convenient way to follow this convention. In other appli-cations, it may suffice to use a single lock to synchronize access to a large
collection of objects.If a thread uses a particular shared variable only after locking a particular lock
and before the corresponding unlocking of that same lock, then the thread willread the shared value of that variable from main memory after the lock action, if
necessary, and will copy back to main memory the value most recently assigned tothat variable before the unlock action. This, in conjunction with the mutual exclusion rules for locks, suffices to guarantee that values are correctly transmittedfrom one thread to another through shared variables.

The rules for volatile variables effectively require that main memory betouched exactly once for each use or assign of a

volatile variable by a thread,and that main memory be touched in exactly the order dictated by the thread exeTHREADS AND LOCKS Example: Possible Swap 17.10

439DRAFT
cution semantics. However, such memory actions are not ordered with respect toread and write actions on nonvolatile variables.
17.10   Example: Possible Swap
Consider a class that has class variables a and b and methods hither and yon:

class Sample {

int a = 1, b = 2;
void hither() {

a = b;
}
void yon() {

b = a;
}
}

Now suppose that two threads are created, and that one thread calls hither whilethe other thread calls

yon. What is the required set of actions and what are theordering constraints?

Let us consider the thread that calls hither. According to the rules, thisthread must perform an use of

b followed by an assign of a. That is the bare mini-mum required to execute a call to the method

hither.Now, the first action on variable
b by the thread cannot be use. But it may beassign or load. An assign to
b cannot occur because the program text does not callfor such an assign action, so a load of

b is required. This load action by the threadin turn requires a preceding read action for

b by the main memory.The thread may optionally store the value of

a after the assign has occurred. Ifit does, then the store action in turn requires a following write action for

a by themain memory.

The situation for the thread that calls yon is similar, but with the roles of a and
b exchanged.

17.10 Example: Possible Swap THREADS AND LOCKS

440 DRAFT

The total set of actions may be pictured as follows:
Here an arrow from action A to action B indicates that A must precede B.In what order may the actions by the main memory occur? The only constraint
is that it is not possible both for the write of a to precede the read of a and for thewrite of

b to precede the read of b, because the causality arrows in the diagramwould form a loop so that an action would have to precede itself, which is not

allowed. Assuming that the optional store and write actions are to occur, there arethree possible orderings in which the main memory might legitimately perform its
actions. Let ha and hb be the working copies of a and b for the hither thread, let
ya and yb be the working copies for the yon thread, and let ma and mb be the mas-ter copies in main memory. Initially

ma=1 and mb=2. Then the three possibleorderings of actions and the resulting states are as follows:

* write ao""read a, read bo""write b (then ha=2, hb=2, ma=2, mb=2, ya=2, yb=2)

* read ao""write a, write bo""read b (then ha=1, hb=1, ma=1, mb=1, ya=1, yb=1)

* read ao""write a, read bo""write b (then ha=2, hb=2, ma=2, mb=1, ya=1, yb=1)

Thus the net result might be that, in main memory, b is copied into a, a is copiedinto

b, or the values of a and b are swapped; moreover, the working copies of the

load b

use b
assign a
[store a]

read b

[write a]

load a

use a
assign b
[store b]

read a

[write b]

hither thread main memory yon thread
THREADS AND LOCKS Example: Possible Swap 17.10

441DRAFT
variables might or might not agree. It would be incorrect, of course, to assume thatany one of these outcomes is more likely than another. This is one place in which
the behavior of a program is necessarily timing-dependent.Of course, an implementation might also choose not to perform the store and
write actions, or only one of the two pairs, leading to yet other possible results.Now suppose that we modify the example to use

synchronized methods:

class SynchSample {

int a = 1, b = 2;
synchronized void hither() {

a = b;
}
synchronized void yon() {

b = a;
}
}

Let us again consider the thread that calls hither. According to the rules, thisthread must perform a lock action (on the instance of class

SynchSample onwhich the
hither method is being called) before the body of method hither isexecuted. This is followed by a use of

b and then an assign of a. Finally, an unlockaction on that same instance of
SynchSample must be performed after the body ofmethod
hither completes. That is the bare minimum required to execute a call tothe method

hither.As before, a load of

b is required, which in turn requires a preceding readaction for
b by the main memory. Because the load follows the lock action, thecorresponding read must also follow the lock action.

Because an unlock action follows the assign of a, a store action on a is man-datory, which in turn requires a following write action for

a by the main memory.The write must precede the unlock action.

The situation for the thread that calls yon is similar, but with the roles of a and
b exchanged.

17.10 Example: Possible Swap THREADS AND LOCKS

442 DRAFT

The total set of actions may be pictured as follows:
The lock and unlock actions provide further constraints on the order of actionsby the main memory; the lock action by one thread cannot occur between the lock
and unlock actions of the other thread. Moreover, the unlock actions require thatthe store and write actions occur. It follows that only two sequences are possible:

* write ao""read a, read bo""write b (then ha=2, hb=2, ma=2, mb=2, ya=2, yb=2)

* read ao""write a, write bo""read b (then ha=1, hb=1, ma=1, mb=1, ya=1, yb=1)

While the resulting state is timing-dependent, it can be seen that the two threadswill necessarily agree on the values of

a and b.

load b

use b
assign a

store a

read b

write a

load a

use a
assign b

store b

read a

write b

hither thread main memory yon thread

lock class SynchSample lock class SynchSample

unlock class SynchSample unlock class SynchSample

THREADS AND LOCKS Example: Out-of-Order Writes 17.11

443DRAFT
17.11   Example: Out-of-Order Writes
This example is similar to that in the preceding section, except that one methodassigns to both variables and the other method reads both variables. Consider a
class that has class variables a and b and methods to and fro:

class Simple {

int a = 1, b = 2;
void to() {

a = 3;
b = 4;
}
void fro() {

System.out.println("a= " + a + ", b=" + b);
}
}

Now suppose that two threads are created, and that one thread calls to while theother thread calls

fro. What is the required set of actions and what are the order-ing constraints?

Let us consider the thread that calls to. According to the rules, this threadmust perform an assign of

a followed by an assign of b. That is the bare minimumrequired to execute a call to the method

to. Because there is no synchronization, itis at the option of the implementation whether or not to store the assigned values

back to main memory! Therefore the thread that calls fro may obtain either 1 or 3for the value of

a, and independently may obtain either 2 or 4 for the value of b.Now suppose that

to is synchronized but fro is not:

class SynchSimple {

int a = 1, b = 2;
synchronized void to() {

a = 3;
b = 4;
}
void fro() {

System.out.println("a= " + a + ", b=" + b);
}
}

In this case the method to will be forced to store the assigned values back to mainmemory before the unlock action at the end of the method. The method

fro must,of course, use
a and b (in that order) and so must load values for a and b frommain memory.

17.11 Example: Out-of-Order Writes THREADS AND LOCKS

444 DRAFT

The total set of actions may be pictured as follows:
Here an arrow from action A to action B indicates that A must precede B.In what order may the actions by the main memory occur? Note that the rules
do not require that write a occur before write b; neither do they require that read aoccur before read

b. Also, even though method to is synchronized, method frois not
synchronized, so there is nothing to prevent the read actions from occur-ring between the lock and unlock actions. (The point is that declaring one method

synchronized does not of itself make that method behave as if it were atomic.)As a result, the method

fro could still obtain either 1 or 3 for the value of a,and independently could obtain either

2 or 4 for the value of b. In particular, fromight observe the value
1 for a and 4 for b. Thus, even though to does an assignto
a and then an assign to b, the write actions to main memory may be observedby another thread to occur as if in the opposite order.

assign a
assign b

store b

read a

write a

load a

use a
use b
printing

read b

write b

to thread main memory fro thread

load block class SynchSimple

unlock class SynchSimple
store a

THREADS AND LOCKS Locks and Synchronization 17.13

445DRAFT
Finally, suppose that to and fro are both synchronized:
class SynchSynchSimple {

int a = 1, b = 2;
synchronized void to() {

a = 3;
b = 4;
}
synchronized void fro() {

System.out.println("a= " + a + ", b=" + b);
}
}

In this case, the actions of method fro cannot be interleaved with the actionsof method

to, and so fro will print either "a=1, b=2" or "a=3, b=4".

17.12 Threads
Threads are created and managed by the built-in classes Thread and ThreadGroup. Creating a Thread object creates a thread and that is the only way to cre-ate a thread. When the thread is created, it is not yet active; it begins to run when

its start method is called.Every thread has a priority. When there is competition for processing
resources, threads with higher priority are generally executed in preference tothreads with lower priority. Such preference is not, however, a guarantee that the
highest priority thread will always be running, and thread priorities cannot be usedto reliably implement mutual exclusion.

17.13   Locks and Synchronization
There is a lock associated with every object. The Java programming languagedoes not provide a way to perform separate lock and unlock actions; instead, they
are implicitly performed by high-level constructs that arrange always to pair suchactions correctly.

Note, however, that the Java virtual machine provides separate monitorenterand monitorexit instructions that implement the lock and unlock actions.
The synchronized statement ($14.18) computes a reference to an object; itthen attempts to perform a lock action on that object and does not proceed further
until the lock action has successfully completed. (A lock action may be delayedbecause the rules about locks can prevent the main memory from participating
until some other thread is ready to perform one or more unlock actions.) After thelock action has been performed, the body of the

synchronized statement is exe17.14 Wait Sets and Notification THREADS AND LOCKS
446 DRAFT

cuted. If execution of the body is ever completed, either normally or abruptly, anunlock action is automatically performed on that same lock.

A synchronized method ($8.4.3.6) automatically performs a lock actionwhen it is invoked; its body is not executed until the lock action has successfully
completed. If the method is an instance method, it locks the lock associated withthe instance for which it was invoked (that is, the object that will be known as
this during execution of the body of the method). If the method is static, itlocks the lock associated with the

Class object that represents the class in whichthe method is defined. If execution of the method's body is ever completed, either

normally or abruptly, an unlock action is automatically performed on that samelock.

Best practice is that if a variable is ever to be assigned by one thread and usedor assigned by another, then all accesses to that variable should be enclosed in
synchronized methods or synchronized statements.The Java programming language does not prevent, nor require detection of,
deadlock conditions. Programs where threads hold (directly or indirectly) locks onmultiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that don't deadlock, if necessary.

17.14 Wait Sets and Notification
Every object, in addition to having an associated lock, has an associated wait set,which is a set of threads. When an object is first created, its wait set is empty.

Wait sets are used by the methods wait, notify, and notifyAll of class
Object. These methods also interact with the scheduling mechanism for threads.The method

wait should be called for an object only when the current thread(call it
T) has already locked the object's lock. Suppose that thread T has in factperformed N lock actions that have not been matched by unlock actions. The

waitmethod then adds the current thread to the wait set for the object, disables the current thread for thread scheduling purposes, and performs N unlock actions to relin-quish the lock. The thread

T then lies dormant until one of three things happens:

* Some other thread invokes the notify method for that object and thread Thappens to be the one arbitrarily chosen as the one to notify.

* Some other thread invokes the notifyAll method for that object.

* If the call by thread T to the wait method specified a timeout interval, thespecified amount of real time has elapsed.

The thread T is then removed from the wait set and re-enabled for thread schedul-ing. It then locks the object again (which may involve competing in the usual

THREADS AND LOCKS Wait Sets and Notification 17.14

447DRAFT
manner with other threads); once it has gained control of the lock, it performsadditional lock actions and then returns from the invocation of the

waitmethod. Thus, on return from the
wait method, the state of the object's lock isexactly as it was when the
wait method was invoked.The
notify method should be called for an object only when the currentthread has already locked the object's lock. If the wait set for the object is not

empty, then some arbitrarily chosen thread is removed from the wait set and re-enabled for thread scheduling. (Of course, that thread will not be able to proceed
until the current thread relinquishes the object's lock.)The

notifyAll method should be called for an object only when the currentthread has already locked the object's lock. Every thread in the wait set for the

object is removed from the wait set and re-enabled for thread scheduling. (Ofcourse, those threads will not be able to proceed until the current thread relinquishes the object's lock.)

N 1-

449DRAFT
C H A P T E R 18

 Syntax

THIS chapter presents a grammar for the Java programming language.The grammar presented piecemeal in the preceding chapters is much better
for exposition, but it is not ideally suited as a basis for a parser. The grammar pre-sented in this chapter is the basis for the reference implementation.

The grammar below uses the following BNF-style conventions:

* [x] denotes zero or one occurrences of x.

* {x} denotes zero or more occurrences of x.

* x | y means one of either x or y.

18.1   The Grammar of the Java Programming Language

Identifier:IDENTIFIER

QualifiedIdentifier:Identifier {

. Identifier }

Literal:IntegerLiteral

FloatingPointLiteralCharacterLiteral
StringLiteralBooleanLiteral
NullLiteral
Expression:Expression1 [AssignmentOperator Expression1]]

18.1 The Grammar of the Java Programming Language SYNTAX

450 DRAFT

AssignmentOperator:=

+=-=
*=/=
&=|=
^=%=
<<=>>=
>>>=
Type:Identifier {

.   Identifier } BracketsOptBasicType

StatementExpression:Expression
ConstantExpression:Expression
Expression1:Expression2 [Expression1Rest]
Expression1Rest:[

?   Expression :   Expression1]

Expression2 :Expression3 [Expression2Rest]

Expression2Rest:{Infixop Expression3}

Expression3 instanceof Type
Infixop:

||
&&
|^

&
==
!=

SYNTAX The Grammar of the Java Programming Language 18.1

451DRAFT
<
>
<=
>=
<<
>>
>>>
+
-
*
/
%

Expression3:PrefixOp Expression3

(   Expr | Type )   Expression3Primary {Selector} {PostfixOp}

Primary:

( Expression )
this [Arguments]
super SuperSuffixLiteral

new CreatorIdentifier {

. Identifier }[ IdentifierSuffix]BasicType BracketsOpt

.class
void.class

IdentifierSuffix:

[ ( ] BracketsOpt   . class | Expression ])Arguments

.   ( class | this | super Arguments | new InnerCreator )
PrefixOp:

++
--
!
~
+
-

PostfixOp:

++
--

18.1 The Grammar of the Java Programming Language SYNTAX
452 DRAFT

Selector:

. Identifier [Arguments]
. this
. super SuperSuffix
. new InnerCreator
[ Expression ]

SuperSuffix:Arguments

. Identifier [Arguments]
BasicType:

byte
short
char
int
long
float
double
boolean

ArgumentsOpt:[ Arguments ]

Arguments:

( [Expression { , Expression }] )

BracketsOpt:{

[]}

Creator:QualifiedIdentifier ( ArrayCreatorRest  | ClassCreatorRest )

InnerCreator:Identifier ClassCreatorRest
ArrayCreatorRest:

[ ( ] BracketsOpt ArrayInitializer | Expression ] {[ Expression ]}BracketsOpt )

ClassCreatorRest:Arguments [ClassBody]
ArrayInitializer:

{ [VariableInitializer {, VariableInitializer} [,]] }

SYNTAX The Grammar of the Java Programming Language 18.1

453DRAFT
VariableInitializer:ArrayInitializer

Expression
ParExpression:

( Expression )

Block:

{ BlockStatements }

BlockStatements:{ BlockStatement }

BlockStatement :LocalVariableDeclarationStatement

ClassOrInterfaceDeclaration[Identifier

:] Statement

LocalVariableDeclarationStatement:[

final] Type VariableDeclarators ;

Statement:Block

if ParExpression Statement [else Statement]
for ( ForInitOpt ;   [Expression] ;   ForUpdateOpt ) Statement
while ParExpression Statement
do Statement while ParExpression ;
try Block ( Catches | [Catches] finally Block )
switch ParExpression { SwitchBlockStatementGroups }
synchronized ParExpression Block
return [Expression] ;
throw Expression ;
break [Identifier]
continue [Identifier]
;ExpressionStatement

Identifier :   Statement
Catches:CatchClause {CatchClause}

CatchClause:

catch ( FormalParameter ) Block

SwitchBlockStatementGroups:{ SwitchBlockStatementGroup }

18.1 The Grammar of the Java Programming Language SYNTAX
454 DRAFT

SwitchBlockStatementGroup:SwitchLabel BlockStatements
SwitchLabel:

case ConstantExpression :
default :

MoreStatementExpressions:{

, StatementExpression }

ForInit:StatementExpression MoreStatementExpressions

[final] Type VariableDeclarators
ForUpdate:StatementExpression MoreStatementExpressions

ModifiersOpt:{ Modifier }
Modifier:

public
protected
private
static
abstract
final
native
synchronized
transient
volatile
strictfp

VariableDeclarators:VariableDeclarator {

,   VariableDeclarator }

VariableDeclaratorsRest:VariableDeclaratorRest {

,   VariableDeclarator }

ConstantDeclaratorsRest:ConstantDeclaratorRest {

,   ConstantDeclarator }

VariableDeclarator:Identifier VariableDeclaratorRest

ConstantDeclarator:Identifier ConstantDeclaratorRest

SYNTAX The Grammar of the Java Programming Language 18.1

455DRAFT
VariableDeclaratorRest:BracketsOpt [

=   VariableInitializer]

ConstantDeclaratorRest:BracketsOpt

=   VariableInitializer

VariableDeclaratorId:Identifier BracketsOpt

CompilationUnit:[

package QualifiedIdentifier ;  ] {ImportDeclaration}{TypeDeclaration}

ImportDeclaration:

import Identifier { .   Identifier } [   . *   ] ;

TypeDeclaration:ClassOrInterfaceDeclaration

;
ClassOrInterfaceDeclaration:ModifiersOpt (ClassDeclaration | InterfaceDeclaration)

ClassDeclaration:

class Identifier [extends Type] [implements TypeList] ClassBody

InterfaceDeclaration:

interface Identifier [extends TypeList] InterfaceBody

TypeList:Type {

,   Type}

ClassBody:

{ {ClassBodyDeclaration} }

InterfaceBody:

{ {InterfaceBodyDeclaration} }

ClassBodyDeclaration:

;[

static] BlockModifiersOpt MemberDecl

MemberDecl:MethodOrFieldDecl

void Identifier MethodDeclaratorRestIdentifier ConstructorDeclaratorRest
ClassOrInterfaceDeclaration

18.1 The Grammar of the Java Programming Language SYNTAX
456 DRAFT

MethodOrFieldDecl:Type Identifier MethodOrFieldRest
MethodOrFieldRest:VariableDeclaratorRest

MethodDeclaratorRest
InterfaceBodyDeclaration:

;ModifiersOpt InterfaceMemberDecl

InterfaceMemberDecl:InterfaceMethodOrFieldDecl

void Identifier VoidInterfaceMethodDeclaratorRestClassOrInterfaceDeclaration

InterfaceMethodOrFieldDecl:Type Identifier InterfaceMethodOrFieldRest
InterfaceMethodOrFieldRest:ConstantDeclaratorsRest

;InterfaceMethodDeclaratorRest

MethodDeclaratorRest:FormalParameters BracketsOpt [

throws QualifiedIdentifierList] (MethodBody |
;  )

VoidMethodDeclaratorRest:FormalParameters [

throws QualifiedIdentifierList] ( MethodBody | ;  )

InterfaceMethodDeclaratorRest:FormalParameters BracketsOpt [

throws QualifiedIdentifierList] ;

VoidInterfaceMethodDeclaratorRest:FormalParameters [

throws QualifiedIdentifierList] ;

ConstructorDeclaratorRest:FormalParameters [

throws QualifiedIdentifierList] MethodBody

QualifiedIdentifierList:QualifiedIdentifier {

,   QualifiedIdentifier}

FormalParameters:

( [FormalParameter { , FormalParameter}] )

FormalParameter:[

final] Type VariableDeclaratorId

MethodBody:Block

457

 Index
DRAFT
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

A
abrupt completion

See completion, abrupt
abstract modifier

See also declarations; modifiers
classes

anonymous are never, 335
binary compatibility considerations, 257
declaration of, 135
definition and characteristics, 135
direct superinterface

relationship to, 142
methods

binary compatibility considerations, 268
classes, 170
declaration examples, 167, 205
interfaces, 205
overloading, 207, 208
overriding, 207
semicolon as body of, 176
and super method invocation, 355access

See also scope
accessibility

determining, 105
term definition, 104
array, 211

expression evaluation order, 365
constructor, binary compatibility

considerations, 261
of fields, expression evaluation, 341
inheritance of class members, example

default, 149
private, 151
protected, 150
public, 150
interface member names, 202

access (continued)

method, binary compatibility

considerations, 267
non-public class instances, through

public superclasses and
superinterfaces, 151
overridden methods, using super

keyword, 178
qualified

See also field access expressions; method

invocation expressions
term definition, 104access control

See also security
classes, example, 107
constructors

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
fields

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
methods

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
package names, limited significance

of, 120
protected, details of, 105
and qualified names, 104
term definition, 104accessible

default for top-level types, 129
package, term definition, 105

Index

INDEX

DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

458

accessible (continued)

single-type import must name

a type that is, 126
type or package may not be named by

type-import-on-demand if not, 127
types, members and constructors, term

definition, 104actions

See also methods
main memory subsystem

lock, 431
read, 431
unlock, 431
write, 431
prescient store, with threads, 438
thread

assign, 431
load, 431
lock, 431
store, 431
unlock, 431
use, 431
threads, constraints on relationships

among, 433algebraic identities

See also expressions; mathematical

functions
limits on use of, 325alphabet

See also syntax
components

See characters
data types

See primitive types
term definition, 9ambiguity

See also names, ambiguous; scope
avoiding, in fields with multiple

inheritance, 166
avoiding, in types with multiple

inheritance, 188, 208anonymous class

, 135
See also inner class
and checked exceptions in initializers, 221
definite assignment before, 426
determining immediately enclosing

instance when instantiating, 332
example(s), 161, 194

anonymous class (continued)

exceptions in instance initializer, 189
in an explicit constructor invocation, 194
interaction with shadowing of parameter

names, 168
in an interface variable initializer, 204
protected accessibility of superclass

constructor, 106
supertypes classified as type names, 95
term definition, 330argument

See also parameters
lists, evaluation order, 326
values, method invocation conversion

context, 71arithmetic

See also floating point; integers; numbers;

operators; primitive types
integer division,

ArithmeticException, 321
operators, numeric promotion,

specification, 77arrays

See also classes; data structures
(chapter), 209
access, 211

expression evaluation order, 364
assignment, expression evaluation

order, 394
character, distinguished from strings, 215
Class

objects, 215
obtaining, example, 53
Cloneable interface implemented by, 214
components

See also variables
assignment, run-time testing, 216, 320,

395, 400
default values, 51
initialization, 213
as a kind of variable, 48
type declaration, 213
creation, 42, 211

expression evaluation, 338

order, 338
out-of-memory detection,

example, 340
example, 210

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 459

arrays (continued)

exceptions, ArrayStoreException, 217
indexing of, 211
initialization, 211, 212
members, 92, 213
names, fully qualified, 111
Object as superclass of, 215
origin, 211
variables

declaration, 210
initialization, 210ASCII characters

See also characters; Unicode

character set
Unicode character set relationship to, 14assignment

See also fields; initialization
array, expression evaluation order, 394,

399
assignable to, term definition, 66
compatible, term definition, 66
compound

evaluation order, 323
operators, evaluation, 398
conversion context, specification, 56, 66
definite, (chapter), 407
expressions

boolean, definite assignment, 412
definite assignment, 412
as statements, 287
operation, to change value of primitive

value, 33
simple operators, evaluation, 393

B
backslash (\)

escape sequence, 28
Unicode escape use, 15backspace

escape sequence, 29Bartleby
Project (Columbia University), xxiibase
See also numbers
permitted in integer literals, 21

Beta, 3, 7biblical quotations

I Corinthians 14:40, 322
John 3:30, 369
Matthew 6:29, 209bibliographic references

Dynamic Class Loading in the Java

Virtual Machine, 232
Polling Efficiently on Stock

Hardware, 224
Release-to-Release Binary Compatibility

in SOM, 251binary

compatibility

See also code generation; compile-time

errors; exceptions
(chapter), 251
changes that do not break, 252
compatible with, term definition, 256
contrasted with source

compatibility, 257
file format, required properties, 253
name

See name, binary
numeric promotion, specification, 79
representation, verification of classes

and interfaces, 232blank final

field

class variable must be assigned

by static initializer, 156
definite [un]assignment of, 418
definite assignment of, 407
instance variable must be assigned

by every constructor, 156
notation for definite assignment, 412
restrictions in an inner class, 141
variable

definite unassignment of, 407
notation for definite unassignment, 412blocks

See also control flow; statements
(chapter), 275
definite assignment, 418
enclosing, 141
in scope of exception handler

parameters, 86, 306
in scope of local class, 86, 278

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

460

blocks (continued)

in scope of local variable, 85, 280
specification and execution of, 277Bobrow, Daniel G.

, 6body

See also declarations
class

declarations in, 147
term definition, 147
constructor, 192

binary compatibility considerations, 270
interface, declarations, 202
method, 176

binary compatibility considerations, 270boolean

See also numbers
literals, term definition

and specification, 25
operators, 40
types and values, term definition

and specification, 40bootstrap loader

See class loaders, bootstrapbrackets (

[])
array type declaration, 41, 209, 280
break statement

See also control flow
definite assignment, 423
as reason for abrupt completion, 276
specification, 297Burke, Edmund

, 275Burroughs, Edgar Rice

, 301Burton, Robert
, xxiiibut not phrase

grammar notation use, 12
byte type

See also integral types; numbers;

primitive types
value range, 33

C
C, 1, 2, 7C++

, 1, 2, 6Caesar, Julius

, 374caller

of a statement, term definition, 222

carriage return (CR)

escape sequence, 29
handling in a

character literal, 26
string literal, 27
as a line terminator, not input character, 16casting

See also conversion
boolean, 41
conversion context, 56

specification, 72
floating-point types, 38
integral types, 34
reference types, 73
run-time testing, 320
to void, not permitted, 287
catch clause, 303

See also control flow; try statement
exception handling role of, 219
exception idiom defined with, 226
scope of parameters, 86, 306Cervantes, Migel de

, 72characters

See also numbers; primitive types; strings
array of, distinguished from strings, 215
char type, 31

See also integral types; numbers;

primitive types
value range, 33
line terminators, 27
literals

escape sequences for, 28
term definition and specification, 26
Unicode character set

composite, contrasted with the Unicode

decomposed characters, 20
handling in package names, 122
lexical grammar use as terminal

symbols, 9
relationship to ASCII, 14Chase, Lincoln

, 118checking

See also exceptions, checked; throw
for exception handlers, at compiletime, 221Christie, Agatha

, 276, 288, 347circular declaration

of a class

compile-time error caused by, 144

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 461

circular declaration (continued)

of a class (continued)

example involving a local class, 278
link-time error caused by, 144
of an interface, compile-time error

caused by, 201
of types, in different compilation units,

legality of, 123class literal

, 95
class or interface name in a, 82
is a primary expression, 327
term definition, 328class loaders

bootstrap, 248
and class unloading, 248class(es)

See also fields; inheritance; interfaces;

methods; packages; subclasses;
superclasses; superinterfaces
(chapter), 135
abstract, 137

as array component types, 210
binary compatibility considerations, 257
overriding abstract methods in, 170
uses, 139
accessibility, 105
anonymous

See anonymous class
binary compatibility considerations, 257
binary representation

binary file format requirements, 256
verification of, 230
body

declarations, binary compatibility

considerations, 259
term definition and declarations in, 147
.class suffix, as name for compiled

files, 122
Class objects, associated with arrays, 215
constructors, binary compatibility

considerations, 267
declarations, 136

specifying direct superclasses in, 142
specifying direct superinterfaces in, 144
term definition, 136
as declared entity, 81
exceptions

ClassCastException, 75

class(es) (continued)

exceptions (continued)

Error, 221, 226
Exception, 226
RuntimeException, 222, 226
Throwable, 219, 221, 226
final

binary compatibility considerations, 258
declaration of, 139
finalization of, 258
FP-strict, 319
inaccessible, accessing members of, 151

example, 151
initialization, 236

detailed procedure, 239
example, 231
instances

See instance(s)
instantiation, preventing, 190
linking

initialization, 227, 230, 239
preparation, 227, 234, 239
process description, 234
resolution, 230
at virtual machine startup, 230
loading, 232

errors

ClassCircularityError, 233
ClassFormatError, 233
NoClassDefFoundError, 233
process description, 233
at virtual machine startup, 230
local

See local class
member

See member class
members, 90

declarations, 147

binary compatibility

considerations, 259
methods

class, 171
interface, 205
non-static, 172
static, 171
named, 135

and checked exceptions in

initializers, 221

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

462

class(es) (continued)

names, fully qualified, 111
naming conventions, 114
nested

See nested classes
non-public, in example of qualified names

and access control, 107
preparation, 234

at virtual machine startup, 230
preventing instantiation of, 139
public

access control in, 105
binary compatibility considerations, 258
in example of qualified names

and access control, 107
references to, binary file format

requirements, 253
resolution

exceptions

IllegalAccessError, 235
IncompatibleClassChangeError,

235
InstantiationError, 235
NoSuchFieldError, 236
NoSuchMethodError, 236
process description, 235
at virtual machine startup, 230
scope of, 85, 125
in scope of an imported type, 85, 125
static initializers, 189

binary compatibility considerations, 271
that depend on themselves

See circular declaration, of a class
that directly depend on a reference type

See circular declaration, of a class
top-level

See top-level class
type declarations, as members of

packages, 129
unloading of, 248
variables

default values, 51
specification, 48, 155
verification, at virtual machine

startup, 230classification

reclassification of contextually ambiguous

names, 96

classification (continued)

syntactic, of a name according to

context, 94code generation

See also binary, compatibility;

compile-time errors; exceptions;
optimization
asynchronous exceptions,

implications for, 224
initialization, implications for, 241
symbolic reference resolution,

implications of, 235comments

term definition and specification, 18Common Lisp

, 6compatibility

See binary, compatibilitycompilation
See also compile-time errors; exceptions;

virtual machine
CompilationUnit goal symbol, syntactic

grammar use, 10
conditional

binary compatibility considerations, 265
if statement reachability handling to

support, 314
exception handlers checked for

during, 221
unit

components, package declarations, 124
and default accessibility of top-level

types, 129
implicitly starts with import

java.lang.*, 128
importing types into, 125
and meaning of a simple type name, 99
and name of top-level type, 129
overview, 119
and package membership, 89, 119
and package observability, 125
and scope of an import declaration, 85,

125
term definition and characteristics, 123compile-time constant

See constantscompile-time errors
See binary, compatibility; errors;

exceptions

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 463

completion, 276

See also control flow, exceptions
abrupt

break statement, 297
continue statement, 299
disallowed for static initializers, 189
during expression evaluation, 320
for statement, 295
labeled statements, 286
reasons for, 276, 321
return statement, 301
synchronized statement, 304
throw statement, 302
try statement, 305
try-catch statement, 307
try-catch-finally statement, 308
normal

during expression evaluation, 320
during statement execution, 276
required for instance initializers, 189
required for static initializers, 189component(s)

See also arrays, components
type, arrays, 210conflicts

name

See also hiding; obscuring; scope;

shadowing
avoiding through use of syntactic

context, 94Conner, Michael

, 251constants

See also fields; class; final; fields,

interface; literals
are always FP-strict, 319
characteristics and binary compatibility

considerations, 264
compile-time narrowing of

by assignment conversion,

implications, 66
not permitted by method invocation

conversion, 71
expressions, 405
field, term specification, 264
may be declared in inner class, 140
named

See fields; class; final

constructors

See also class(es); execution; initialization;

interfaces; methods
access, 105

binary compatibility considerations, 261
control

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
hidden fields, this keyword use for, 283
accessibility, 105
allow field access through super, 344
anonymous

term definition, 335
anonymous class

cannot have explicitly declared, 335
has anonymous constructor, 335
are not members, 148
body, 192

binary compatibility considerations, 270
as components of a class body, 147
declarations, 190

binary compatibility considerations, 267
default, 195
definite assignment and unassignment

within, 427
definite assignment of variables

before, 418
deleting, binary compatibility

considerations, 267
determining arguments to, 334
each must declare exceptions

from instance initializers, 188
explicit invocation statements, 193
explicit invocations, 105
FP-strict, 319
invocation, during instance creation, 242
modifiers, 191
must assign all blank final instance

variables, 156
must assign blank final fields, 156
names of, 83, 190
as non-members of a class, 90
overloading, 195

binary compatibility considerations, 270
parameters, 191

See also arguments

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

464

constructors (continued)

parameters (continued)

assignment during instance

creation, 242
binary compatibility considerations, 267
definite [un]assignment of, 425
must not be assigned if final, 168
shadowing, 86, 168
specification, 51, 191
private, preventing instantiation

with, 139, 197
protected, accessibility of, 105, 106
signature, 191

binary file format requirements, 255
throws clause, binary compatibility

considerations, 270
and unreachable statements, 310
when reachable, 311context(s)

See also inheritance; scope
conversion, 56

assignment, specification, 66
casting, specification, 72
method invocation, specification, 71
reclassification of contextually ambiguous

names, 96
role in determining the meaning of a

name, 81, 93
static

See static context
syntactic classification of a name according

to, 94context-free grammars

See grammars, context-free
continue statement

See also control flow
definite assignment, 423
as reason for abrupt completion, 276
specification, 299contract

See also binary, compatibility
term definition, 256control flow

See also completion; definite assignment;

exceptions; expressions;
statements; statements,
unreachable; threads
boolean expressions use for, 40

control flow (continued)

break statement, specification, 297
continue statement, specification, 299
deadlock avoidance, multiple lock

use for, 305
do statement, specification, 293
for statement, specification, 295
if statement, dangling else

handling, 284
if-then statement, specification, 288
if-then-else statement,

specification, 288
local variable declaration and switch

statement, 49
return statement, specification, 301
switch statement, specification, 288
synchronized statement,

specification, 304
throw statement, specification, 302
try statement, specification, 305
try-catch statement, specification, 307
try-catch-finally statement,

specification, 308
while statement, specification, 292conventions

naming, 113

impact on obscuring of names, 89conversion

See also casting; numbers; promotion
(chapter), 55
casting, 72
contexts

assignment, specification, 66
casting, specification, 72
method invocation, specification, 71
forbidden, specification, 64
identity

in assignment conversion context, 66
in casting conversion context, 72
in method invocation conversion

context, 71
specification, 58
kinds of, 58
in method invocations, 71
narrowing

primitive

in assignment conversion context, 66
in casting conversion context, 72

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 465

conversion (continued)

narrowing (continued)

primitive (continued)

not allowed in method invocation

conversion context, reasons for, 71
reference, in casting conversion

context, 72
reference

narrowing, 63
widening, 62
string, 72

specification, 64
term definition, 55
value set

in assignment conversion, 66
in binary numeric promotion, 79
in casting conversion, 72
in method invocation conversion, 71
in overview, 56
term definition, 65
in unary numeric promotion, 78
widening

primitive

in assignment conversion context, 66
in binary numeric promotion

context, 79
in casting conversion context, 72
in method invocation conversion

context, 71
in unary numeric promotion

context, 78
reference, 62

in assignment conversion context, 66
in casting conversion context, 72
in method invocation conversion

context, 71
term specification, 62creation

See also declaration; initialization
array, 42, 211

expression evaluation

example, 339
order, 338
out-of-memory detection,

example, 340
instance, 42

expression evaluation order, 334
expressions as statements, 286

creation (continued)

instance (continued)

invocation of initializers for instance

variables during, 244
method dispatching during, 244
specification and procedure, 241
object, 42
threads, 445Creatore, Luigi

, 30

D
Danforth, Scott, 251dangling

else
See also control flow
handling of, 284data

See also constants; fields; variables
structures

See arrays; classes; interfaces;

primitive types; vectors
types

See types
values

See valuesdatabase

storing packages in, 119deadlock
avoidance, multiple lock use for, 305decimal
See also numbers
base, permitted in integer literals, 21
numerals, specification, 21declarations

See also body; execution; methods;

parameters; statements
class

(chapter), 135
body, 147
member, 147
term definition and specification, 135
constructor, 190
field(s), 153

constants in interfaces, 203
examples of, 162
interface, examples, 204

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

466

declarations (continued)

identifiers in, kept separate from those

in labeled statements, 84
import

example, 128
single-type, 126
term definition, 125
type-import-on-demand, 127
instance variable, 48
interface, 200

(chapter), 199
body, 202
members, 202
local variable, definite assignment, 419
method(s), 167

examples of, 180
interface, abstract, 205
modifiers

See

abstract modifier; final modifier;

native modifier; private
modifier; protected modifier;
public modifier; static modifier;
synchronized modifier;
transient modifier; volatile
modifier
overriding, example, 180
package, in compilation units, 123
scope of, 85
shadowed, term definition, 86
shadowing, 86
subclass, 142
superclass, 142
superinterface, 144, 201
term definition, 82
type

as members of packages, 129
need not appear before use

of the type, 86
usage in, 46
variable

array, 210
local, 279

execution of, 283declarator

in scope of local variable, 85, 86, 280, 296definite assignment
See also exceptions; execution; scope

definite assignment (continued)

(chapter), 407
and anonymous classes, 426
of blank final class variables, 156
of instance variables, 156
and local classes, 418
of member types, 426
and parameters, 425
and qualified class instance creation, 417
requirement for locals and parameters

before an inner class, 141
and static initializers, 426
of variables with respect

to nested classes, 418definite unassignment

, 407
See also definite assignment
hypothetical analysis of, 412
and local classes, 418
and qualified class instance creation, 417
and static initializers, 426DeMichiel, Linda G.

, 6denormalized

IEEE 754 standard, support

required for, 38digits

Java, term definition, 19directly depends
class, term definition, 144division
See also arithmetic; numbers
integer divide by zero, indicated by

ArithmeticException, 34, 375
do statement

See also control flow
definite assignment, 421
specification, 293double quote

escape sequence, 29
in string literals, 27
double type

floating-point literal specification, 24Duff's device

, 289Dylan
, 6

E
Eco, Umberto, 118

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 467

Eisenhower, Dwight D., 388element type

arrays, term definition, 210Ellis, Margaret A.

, 6Ellison, Shirley
, 118entity

declared, list of, 82Epictetus

, 203errors

class variable initializers may not

refer to instance variables, 159
Error class, unchecked exceptions

as subclass of, 176
linking, 227, 234

resolution, 235
verification, 234
loading, 227, 233
reasons for, 220
semantic, exceptions as mechanism

for signaling, 219
types, run-time, 320
unchecked, reasons for, 221
virtual machine, 227escapes

sequences, for character and string

literals, 28
Unicode, specification, 14evaluation

See also execution; initialization; scope
evaluated, term definition, 317
expressions

additive operators, 377
additive operators for numeric

types, 381
array access, 364
array assignment, 393
array creation, 338
assignment operators, 392
bitwise binary operators, 388
bitwise complement, 371
boolean equality operators, 388
boolean logical operators, 389
cast, 372
compound assignment operators, 398
conditional operator, 391
conditional-and operator, 390
conditional-or operators, 390
division, 374

evaluation (continued)

expressions (continued)

equality operators, 386
field access, 341
instance creation, 334
integer bitwise operators, 389
logical binary operators, 388
logical complement, 371
method invocation, 345
method invocation, order of, 356
multiplication, 373
multiplicative operators, 373
numeric comparison, 384
numeric equality operators, 387
parenthesized, 330
postfix, 368
pre-decrement, 369
pre-increment, 369
primary, 327
reference equality operators, 388
relational operators, 384
remainder, 376
shift operators, 383
simple assignment operator, 393
string concatenation, 378
superclass access, 344
type comparison, 385
unary minus, 370
unary operators, 368
unary plus, 370
literals, 328
order

arguments left-to-right, 326
binary operators, 322
compound assignment, 323
left-hand operand first, 322
left-to-right, 322
operands evaluated before

operations, 324
parentheses and precedence

respected, 325
result of, term definition, 317events

See also methods
execution order of, constraints

on relationships among, 433evolution

See also binary, compatibility; reuse

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

468

evolution (continued)

of classes, binary compatibility

considerations, 257
of interface, binary compatibility

considerations, 271
of packages, binary compatibility

considerations, 257examples

access control, 106

fields, methods, and constructors

default, 108
private, 111
protected, 110
public, 109
arrays, 212
classes, public and non-public, 107
declarations

fields, 162
import, 128
methods, 180
default-access methods, constructors,

and fields, 108
exceptions, 224
fields

interface, ambiguous inherited, 204
interface, multiply inherited, 205
multiply inherited, 165
re-inheritance of, 166
hiding, 181

vs. overriding, 182
of variables

class, 162
instance, 163
inheritance

accessing members of inaccessible

classes, 152
class members, 149

default access, 149
public, protected, and private

access, 150
multiple, with superinterfaces, 146
with default access, 149
with private access, 151
with protected access, 150
with public access, 150
methods

abstract declarations, 207
invocation of hidden class, 184

examples (continued)

methods (continued)

private, 111
protected, 110
public, 109
overloading, 181
overriding, 180

vs. hiding, 182
incorrect, 181

because of throws, 186
large example, 185exceptions

See also binary, compatibility;

compile-time errors; errors;
(chapter), 219
asynchronous, causes and handling of, 224
caller, determination of, 222
causes of, 220
checked

constructors, declaring with throws

clause in method declarations, 175
defining new exception classes as, 226
Exception, 226
in an instance initializer, 188
methods, declaring with throws clause

in method declarations, 175
in a static initializer, 189
UnsatisfiedLinkException, 236
classes

Error, 221
Exception, 226
RuntimeException, 222

unchecked exceptions found in, 176
Throwable, 219, 221
errors

AbstractMethodError, 268
ClassCircularityError, 144, 258

meaning, 233
ClassFormatError, meaning, 233
Error, 226
ExceptionInInitializerError, 241,

304
IllegalAccessError, 258, 272, 358

meaning, 235
IncompatibleClassChangeError, 26

4, 269, 272, 357
meaning, 235
InstantiationError, meaning, 235

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 469

exceptions (continued)

errors (continued)

LinkageError, 233, 234
loading and linkage, 227
NoClassDefFoundError, 240

meaning, 233
NoSuchFieldError, 264

meaning, 236
NoSuchMethodError, 267, 273, 357

meaning, 236
OutOfMemoryError, 176, 233, 241,

242, 321, 334, 338, 340, 360
UnsatisifedLinkError

meaning, 236
VerifyError, 269, 272

meaning, 234
VirtualMachineError, 227
example, 224
handlers

compile-time checking, 221
how established, 219
in try statements, 306
handling of, 222

asynchronous, 224
run-time testing, 320
hierarchy, 226
integer divide by zero, 34
NegativeArraySizeException, 321,

338
never thrown for

assignment conversions, 66
information loss due to narrowing

primitive conversions, 61
information loss sue to widening

primitive conversions, 59
widening reference conversions, 63
NullPointerException, 194
parameters

See also variables
declaration, 306
description, 49
initial value, 51
scope, 86, 306
precise, 223
RuntimeException, 395
synchronization integrated with

mechanism for handling, 220

exceptions (continued)

thrown for, narrowing reference

conversions, 63
uncaughtException method,

when invoked, 220
unchecked, 226
unchecked runtime

ArithmeticException, 324, 376
ArrayIndexOutOfBoundsException,

394, 399
ArrayStoreException, 217, 320, 395,

398
ClassCastException, 320, 372, 395

casting conversion requirements

that can result in, 75
IndexOutOfBoundsException, 212,

321, 364
NullPointerException, 213, 222,

321, 358, 361, 364, 366, 394, 399
RuntimeException, 226, 395execution

See also declarations; evaluation;

initialization; linking; loading
(chapter), 229
order, thread rules, 433
of statements for their effect, 275exit

virtual machine, criteria for, 249exponent
See value setexpressions
See also fields; methods; statements
(chapter), 317
abrupt completion of, as reason for

abrupt statement completion, 277
additive operators

evaluation, 377
for numeric types, evaluation, 381
array

access, evaluation, 364
assignment, evaluation, 394, 399
creation, evaluation of, 337
assignment

conversion, 66
definite assignment, 407, 412
operators, evaluation, 392
as statements, 287

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

470

expressions (continued)

bitwise

binary operators, evaluation, 388
complement, evaluation, 371
boolean

operators

!, definite assignment, 414
&&, definite assignment, 413
?, definite assignment, 414
||, definite assignment, 413
assignment, definite assignment, 415
constant, definite assignment, 412
equality, evaluation, 388
logical, evaluation, 389
cast, evaluation, 372
compound, assignment operators,

evaluation, 398
conditional

and operator &&, evaluation, 390
operator ? :

definite assignment, 414
evaluation, 391
or operator ||, evaluation, 390
definite assignment and, 412
division, evaluation, 374
equality operators, evaluation, 386
field access, evaluation, 341
instance creation

evaluation of, 330
as statements, 286
integer bitwise operators, evaluation, 389
logical

comparison operators, evaluation, 388
complement !, evaluation, 371
method invocation

evaluation, 345
evaluation order, 356
as statements, 287
multiplication *, evaluation, 373
multiplicative operators *, /, %,

evaluation, 373
names

context in which a name is classified

as, 95
qualified, meaning of, 102
simple, meaning of, 101
numeric

comparison, evaluation, 384

expressions (continued)

numeric (continued)

equality operators, evaluation, 387
operators

++, definite assignment, 416
--, definite assignment, 416
precedence, evaluation, 325
parenthesized

evaluation of, 330
evaluation of, precedence effect of, 325
post-decrement --

evaluation of, 368
as statements, 287
postfix, evaluation, 367
post-increment ++

evaluation of, 367
as statements, 287
pre-decrement --

evaluation of, 369
as statements, 287
pre-increment ++

evaluation of, 369
as statements, 287
primary, evaluation of, 327

See also

arrays, access expressions;
arrays, creation;
expressions, parenthesized;
fields, access expressions;
instance, creation;
literals;
methods, invocations;
this keyword
reference equality operators ==, !=,

evaluation, 388
relational operators <, >, <=, >=,

evaluation, 384
remainder operator %, evaluation, 376
run-time checks of, 319
semantics and evaluation rules,

(chapter), 317
shift operators <<, >>, >>>,

evaluation, 383
simple assignment operator =,

evaluation, 393
statements

definite assignment, 417
specification, 284

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 471

expressions (continued)

string concatenation +, evaluation, 378
superclass access, evaluation, 344
type

vs. class of object, 52
comparison instanceof,

evaluation, 385
how determined, 52
usage in, 46
unary

minus -, evaluation, 370
operators, evaluation, 368
plus +, evaluation, 370
values, variable as, 318
extends clause

See also classes; implements; objectoriented concepts
in class declaration, specifying direct

superclasses with, 142
in interface declaration, 201

F
Feeley, Mark, 224fields

access control

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
access expressions, evaluation, 341
of an array, 92, 214
of a class

binary compatibility considerations, 262
declarations, 153

examples of, 162
final, 156

binary compatibility

considerations, 264
volatile declaration not

permitted for, 158
multiply inherited, example of, 165
non-static

default values, 51
explicit constructors not

permitted to use, 193
hiding example, 163

fields (continued)

of a class (continued)

non-static (continued)

initializers for, 159
initialization of, 158
invocation of initializers during

instance creation, 242
specification, 48
re-inheritance of, example, 166
static

binary compatibility

considerations, 266, 271
and final, binary compatibility

considerations, 264
hiding of, example, 163
initialization of, 158, 189
initialization of, during the preparation

phase of linking, 234
specification, 48
term definition and declaration, 155
transient, 156

binary compatibility

considerations, 266
volatile, 156
declarations

binary compatibility considerations, 273
as declared entity, 81
hidden

accessing with

super keyword, 344, 345
this keyword, 283
of an interface

ambiguous inherited, example, 204
binary compatibility considerations, 273
declarations, 203

examples, 204
initialization, 204

during the preparation phase

of linking, 234
multiply inherited example, 205
public by default, 203
names, naming conventions, 115
public, by default in interface

declaration, 202
references to, binary file format

requirements, 253
references, active use, 238
shadowing, 86

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

472

fifth dimension, 339files

binary, format, 252
systems, storing packages in, 119Finagle's Law

, 219
final modifier

See also declarations; modifiers
anonymous class is always implicitly, 335
classes

binary compatibility considerations, 258
declaration of, 139
exception parameter, may not be

assigned, 306
fields

binary compatibility considerations, 264
declaration and use, 156, 203
final by default in, interface

declaration, 203
not allowed with volatile, 158
formal parameters, 168
methods

binary compatibility considerations, 268
declaration and use, 172
not permitted in interface method

declarations, 206
reasons why constructors cannot be, 191finalization

See also exceptions; linking
finalizable, as object attribute, 246
finalize method, as member

of Object class, 45
finalized, as object attribute, 246
finalizer method calls,

unordered nature of, 247
finalizer-reachable, as object attribute, 246
finally clause, exception

handling use, 223
implementing, 246
of instances, 245

implementation procedures, 246
float type, 35

See also floating-pointfloating-point

See also arithmetic; numbers; types
algebraic identities, limits on use of, 325
float type, floating-point literal

specification, 24, 33

floating-point (continued)

literals

largest and smallest, 24
term definition and specification, 24
operations, 37
required behavior, 38
types and values, term definition

and specification, 35flow analysis

See also security
conservative, required for definite

assignment of local variables, 407Foote, Samuel

, 305
for statement

definite assignment, 422
ForInit part

initialization by, 295
scope of local variable declared in, 86
header, local variable declaration in, 281
in scope of a local variable, 86, 296
specification, 295form feed

escape sequence, 29Forman, Ira

, 251forward reference

compile-time error in

initializers, 160forward references

to types allowed before declaration, 86FP-strict
actual arguments, 169
and addition, 382
and casts, 372
classes, 139
classes, interfaces, methods,

constructors and initializers, 319
compile-time constant is always, 406
constructors, 191
and division, 375
expression

term definition, 318
interfaces, 200
methods, 173

overriding, 178
and multiplication, 374
and return statement, 302
value set conversion within, 65

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 473

Franklin, Benjamin, 229Frost, Robert

, 199, 310, 315, 445

G
Gabriel, Richard P., 6Geisel, Theodore

, 132Gilbert, W. S.
, 197goal symbols

CompilationUnit, 123

syntactic grammar use, 10
Input, lexical grammar use, 9Goldberg, Adele

, 6
goto statement

See labeled statementsgradual underflow

See also exceptions; floating-point;

IEEE 754 standard; numbers
support required for, 38grammars

See also languages; lexical; semantics
(chapter), 9
context-free, term definition, 9
difficulties with, as given in body of Java

Language Specification, 449
if statement, dangling else handling, 284
lexical

(chapter), 13
term definition, 9
notation, 10
syntactic, term definition, 10

H
Hammerstein, Oscar, II, 133Harbison, Samuel

, 6Harding, Warren G.

, 307hexadecimal

See also numbers
base, permitted in integer literals, 21
numerals, specification, 22hiding

See also scope
by class methods, 178
of field declarations, in superclasses

and superinterfaces, 154

hiding (continued)

of fields, 136

bypassing using super, 345
term definition, 154
hidden class methods, invocation of,

example, 184
of interface field declarations, in

superinterfaces, 203
of interface fields, term definition, 203
of interface member type declarations, 208
of interface member types, term

definition, 208
of interfaces, 199
of member types, term definition, 187
method

example, 181
impact on checked exceptions, 176
requirements, 178
of methods, 136
vs. overriding, example, 182
of types, by member types, 136
of variables

class, example of, 162
instance, example of, 163hierarchy

exception, 226Higginson, Thomas Wentworth

, 203Hoare, C. A. R.
, 1, 6horizontal tab

escape sequence, 29host
and creation, storage and observability

of packages and compilation
units, 120
may not restrict packages

in a database, 130
and observable compilation units, 123
optional restriction on packages

in a file system, 129hypothetical analysis

of definite unassignment, 412

I
identifiers

See also fields; names; scope;

variables

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

474

identifiers (continued)

those that are not names, 83
in labeled statements, distinguished from

those in declarations, 84
term definition and specification, 19identity

conversion

in assignment conversion context, 66
in casting conversion context, 72
in method invocation conversion

context, 71
specification, 58IEEE 754 standard

, 6
See also numbers
floating-point

conversion of numbers to, 24
types conformance to, 35
if statements

See also statements
dangling else, handling of, 285
definite assignment, 420
if-then statement, specification, 288
if-then-else statement,

specification, 288
specification, 287implement

See also classes; extends clause;

interfaces
implements clause, 201

class declaration, specifying direct

superinterfaces with, 144
term definition, 91, 145import

See also packages; scope
automatic, 128
declarations

example, 128
single-type, 126
term definition, 125
type-import-on-demand, 127
imported types

as declared entity, 82
scope of, 85
as part of a compilation unit, 123
single-type

may not declare top-level type

in same compilation unit, 130
and meaning of a simple type name, 99

import (continued)

single-type (continued)

scope, 85, 125
and shadowing, 87, 126
type-import-on-demand, 96

and meaning of a simple type name, 100
scope, 85, 125
and shadowing, 87, 127indexing

of arrays, 211inexact results
See also numbers
rounding behavior, 38infinity

See also numbers
representation of, 25
signed, produced by floating-point

overflow, 39inheritance

See also object-oriented concepts; scope
in class

examples of, 149
of members, 148
of members, with public,

protected, and private access,
examples, 150
with default access, example, 149
of fields

in class declarations

multiply inherited from interfaces,

example of, 165
reinheritance of, example of, 166
in interface declarations

ambiguous inherited, example, 204
multiply inherited, example, 205
of members, 90
of methods

in class declarations, 177

with the same signatures, 179
in interface declarations, 206
multiple

See also superinterfaces
example, 146
term definition, 90initialization

See also control flow; linking
of arrays

in creation, to default value, 338, 48

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 475

initialization (continued)

of arrays (continued)

using array initializers, 212
of classes, 236

detailed procedure, 239
of classes and interfaces, when

it occurs, 236
detailed procedure, 239
of fields

in classes, 159
in interfaces, 204
of for statement, 295
of interfaces, 236

detailed procedure, 239
for variables, array, 212initializers

See also creation; execution
array

in array creation expression, 338
arrays, 211
executing, in Test class example

initialization, 231
for fields

in class, 159
in interface, 204
instance

See instance initializer
FP-strict, 319
instance variable, 195
lacking in a blank final, 50
local variable

in scope of a local variable, 86, 296
static, 158, 189

binary compatibility considerations, 271
static

FP-strict, 319
variable

FP-strict, 319
in scope of local variable, 85, 280
for variables

class, 158

during class or interface

initialization, 159
instance, 159

during instance creation, 242inner class

See also nested class
anonymous class is always, 335

inner class (continued)

of another class, 140
direct, 140
every local class is an, 277
in a qualified class instance creation

expression, 331
and qualified super method

invocation, 355
qualified superclass constructor

invocation of, 193
as superclass of an anonymous class, 334
term definition, 140input

See also files
elements, term definition, 16
Input goal symbol, lexical grammar use, 9
tokens, 16instance initializer

, 135
allows field access through super, 344
anonymous class, 336
and checked exceptions, 221
as components of a class body, 147
containing a throw statement, 304
definite assignment of variables

before, 418
execution during constructor

invocation, 195
is not a member, 148
may not contain a return statement, 301
must be able to complete normally, 189
overview, 136
term definition, 188
and unreachable statements, 310
when reachable, 311instance(s)

See also classes; interfaces; object-oriented

concepts
creation, 42, 241

constructor

invocation by creation

expressions, 190
parameter assignment during, 242
use in, 190
expression evaluation, 330

order, 334
expressions as statements, 287
invocation of initializers for instance

variables during, 242

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

476

instance(s) (continued)

creation (continued)

method dispatching during, 244
enclosing

determining immediate, 332

with respect to superclass, 194
with respect to superclass of

an anonymous class, 333
immediate as first argument

to constructor, 334
immediately, 141

with respect to a class, 141
nth lexical used when evaluating

method invocation, 356
nth lexically, 141
restrictions on references to, 194
finalization of, 245

implementation procedures, 246
initializer

See instance initializer
instanceof operator

testing expression types with, 320
testing expressions with, 320
instantiation

preventing, with private

constructors, 139, 197
methods

See methods, non-static
variables

See fields, class, non-static
instanceof operator

testing expression types with, 320instantiation

term definition, 330integers
See also arithmetic; integral types;

numbers
converting to boolean values, 41
literals

longest permitted, 23
term definition and specification, 21
operations, 33integral types

See also arithmetic; numbers; types
byte type, 33
char type, 33
int type, 33
long type, 33

integral types (continued)

short type, 33
values and operations, 33interfaces

See also class(es); fields; methods; packages; subclasses; superclasses;
superinterfaces
(chapter), 199
abstract methods, 205
accessibility, 105
as array element types, 210
binary compatibility considerations, 271
binary representation

binary file format requirements, 252
verification, 234
body, declarations, 202
and checked exceptions in initializers, 221
Cloneable, implemented by arrays, 214
declarations, 200
as declared entity, 81
dependent on a reference type

term definition, 201
directly dependent on a reference type

term definition, 201
fields

declarations, 203

examples, 204
inheritance

ambiguous, 204
multiply, 205
initialization, 204
FP-strict, 319
initialization, 236

detailed procedure, 239
java.io.Serializable, implemented

by arrays, 214
linking, process description, 233
loading, 232

process description, 233
members, 91

binary compatibility considerations, 272
declarations, 202
inheritance from superinterfaces, 91,

202
names, access to, 202
methods

declarations, 207

examples, 207

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 477

interfaces (continued)

methods (continued)

overloading, 207

example, 208
overriding, 206

example, 207
names

fully qualified, 111
naming conventions, 113
preparation of, 234
public

binary compatibility considerations, 272
declaration, 200
references to, binary file format

requirements, 255
in scope of imported type, 85, 125
Serializable, implemented by

arrays, 214
superinterfaces

binary compatibility considerations, 258
of a class, 144
declaration of, 144
that depend on themselves, 201
unloading of, 248invocation

alternate constructor, 193
constructor

determining arguments to, 334
expression evaluation, 335
expression evaluation, order, 336
language constructs that result in, 190
of hidden class methods, example, 184
method

conversion, 71
expression evaluation, 345

order, 356
how chosen, 319
superclass constructor, 193iteration

See also control structures
continue statement, specification, 299
do statement, specification, 293
for statement, specification, 295
while statement, specification, 292

J

Java

digits, term definition, 19
.java suffix, as name for source files, 122
java package is always in scope, 125
java.lang

example, 121
may be named in a type-importon-demand, 127
public type names automatically

imported from, 119, 123
java.lang package

public type names automatically

imported from, 128
public types defined in, list of, 128
letters, term definition, 19Java programming language

See also grammars; languages; lexical;

semantics; syntaxJohnson, Samuel

, 13

K
Keats, John, 217Keene, Sonya E.

, 6Kelvin, Lord (William Thompson)

, 317Kernighan, Brian W.
, 7keywords

list of, 20
as token, 10Kiczales, Gregor

, 6

L
label

shadowing, 87labeled statements

identifiers in, kept separate from

those in declarations, 84
specification, 286language

See also grammars; lexical; semantics;

syntax
Beta, 3, 7
C, 1, 2, 7
C++, 1, 2, 7
Common Lisp, 6

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

478

language (continued)

Dylan, 6
Mesa, 5, 7
Modula-3, 3, 6
Smalltalk-80, 6Lao-Tsu

, 81left-hand side

term definition, 9length
of array, 213

not part of type, 210letters

See also Unicode character set
Java, term definition, 19lexical

See also semantics; syntax
grammar, term definition, 9
structure (chapter), 13
translations, steps involved in, 14Liang, Sheng

, 233life cycle

See also objects
of objects, 246line terminators, term definition

, 16linefeed (
LF)
escape sequence, 29
handling in a

character literal, 26
string literal, 27
as a line terminator, not input character, 27linking

, 233
See also exceptions; execution;

initialization; loading; run-time
classes, process description, 233
errors, 227
interfaces, process description, 233
in Test class example,

at virtual machine startup, 230literals

See also constants; fields; variables
boolean, term definition and

specification, 25
character

escape sequences for, 28
term definition and specification, 26
evaluation of, 328
floating-point

largest and smallest permitted, 24

literals (continued)

floating-point (continued)

term definition and specification, 24
integer

largest and smallest permitted, 23
term definition and specification, 21
null, term definition and specification, 29
string

escape sequences for, 28
term definition and specification, 27
term definition and specification, 21
as token, 10loading

See also ClassLoader class; execution;

linking
classes, 232
errors, 227
interfaces, 232
process, 233
in Test class example, at virtual machine

startup, 230local class

, 115, 135
declaration is part of a block, 277
and definite [un]assignment, 418
determining immediately enclosing

instance when instantiating, 332
example(s), 141, 278
interaction with shadowing

of parameters, 168
and meaning of a simple type name, 99
requirements for normal completion, 311
scope, 86, 278
as superclass of anonymous class

being instantiated, 333
term definition, 277local variables

See also scope; variables
declarations

definite assignment, 419
statements, 279
declarators and types, 279
definite assignment, required for, 407
initial value, 51
naming conventions, 116
restrictions on use in an inner class, 141
scope, 85, 280
shadowing, 86
specification, 49

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 479

locks

See also monitors; synchronization;

threads
(chapter), 429
acquisition and release

by synchronized networks, 174
by synchronized statement, 304
interaction with variables, rules about, 436
rules about, 436
synchronization and, 445
long type, 33

See also integral types; numbers
integer literal specification, 23
value range, 33lvalue

See variables, value of expression

M
Madsen, Ole Lehrmann, 7magnitude

loss of information about, possibility

of in narrowing primitive
conversion, 60Marx, Chico

, 415, 423Marx, Groucho

, 148, 227, 415, 416, 417mathematical functions

See arithmetic; numbersMatthew, St.

, 209Maybury, William

, 7member
, 187member class

, 82, 113, 135, 136
See also member type
can have same name as a method, 167
canonical name of, 113
determining immediately enclosing

instance when instantiating, 332
example(s), 140, 142, 194, 196, 278
fully qualified name of, 112
and public modifier, 137
as superclass of anonymous class

being instantiated, 333
term definition, 187member interface

, 82, 111, 113, 135, 136,
187
See also member type
can have same name as a method, 167

member interface (continued)

canonical name of, 113
example(s), 140
fully qualified name of, 112
implicitly static, 188
implicitly static, 140
inner class may not declare, 140
term definition, 187member type

, 97, 99, 187, 199
See also nested type
binary name of, 253
and definite assignment, 426
in interfaces, 208
inherited by interfaces, 201
and the meaning of a qualified

type name, 100
and the meaning of a simple

type name, 99members

See also class(es); fields; interfaces;

methods
accessibility, 105
arrays, 92, 213
classes, 90, 148

binary compatibility considerations, 259
declarations, 147
inaccessible, accessing, example, 151
inheritance, examples, 149
private, inheritance examples, 151
inheritance and, 90
interfaces, 91, 202

binary compatibility considerations, 272
declarations, 202
inheritance, 91, 202
names, access to, 202
Object class, 45
of a package, 89, 119
packages, 89, 119
protected accessibility of, 105
reference type, as declared entity, 81
static, restricted in inner classes, 140
of superclasses, accessing with super, 344
term definition, 89memory

exceptions

OutOfMemoryError, 241, 242
main, term definition, 431
master, of variables, term definition, 431

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

480

memory (continued)

OutOfMemoryError, 176
working, term definition, 431Mesa

, 5, 7method(s)

, 167
abstract

binary compatibility considerations, 268
in classes, 170
in interfaces

overloading, 207
access control

default, example, 108
private, example, 111
protected, example, 110
public, example, 109
access, binary compatibility

considerations, 261
accessible, and method invocation, 347
of array, 92, 214
body, 176

binary compatibility considerations, 270
class

See methods, static
classes, 167

abstract, 170
binary compatibility considerations, 267
body

declarations, 176
with no executable code, 176
constructors compared with, 190
declarations, 167

examples of, 180
final, 172
hidden, invocation of, 184
hiding by, 178
modifiers, 169
native

declarations, 173
semicolon as body of, 177
private, as implicitly final, 172
signature, 169
strictfp, declaration, 173
synchronized, declaration, 174
void, expression return statement

not permitted in, 177
with same signature, inheriting, 179
declarations, 167, 200

binary compatibility considerations, 267

method(s) (continued)

as declared entity, 81
definite [un]assignment of blank final

fields before, 418
definite assignment of variables

before, 418
descriptor, 347
dispatching during instance creation, 244
equals, as member of Object class, 45
final, 172

binary compatibility considerations, 268
finalize, as member of Object class, 45
FP-strict, 319
getClass, as member of Object class, 45
hashCode, as member of Object class, 45
hiding of, 178
inheritance

in arrays, 92, 214
in classes, 177
in interfaces, 91, 202
instance

See method(s), non-static
of interfaces

declarations, 205, 207
overloading, 207, 208
overriding, 206, 207
semicolon as body of, 176
invocation

See also access control
conversion, 71
expression evaluation, 345

order, 346
expressions as statements, 287
how chosen, 319
qualifying type of

See qualifying type, of a method

invocation
as members of a class, 90
method table creation during preparation

phase of linking, 230
names

context in which a name

is classified as, 94
naming conventions, 115
qualified, meaning of, 104
simple, meaning of, 104
native, 173

binary compatibility considerations, 269

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 481

method(s) (continued)

non-static

instance method as name for, 172
overriding by, 177
notify, as member of Object class, 45
notifyAll, as member of Object

class, 45
overloading, 180

binary compatibility considerations, 270
example, 181
overriding, 178

binary compatibility considerations, 271
examples, 180, 181, 182, 185, 207
parameters

See also arguments; variables
binary compatibility considerations, 267
definite [un]assignment of, 425
description, 48
initial value, 51
is assigned when final, 168
must not be assigned if final, 168
shadowing, 86, 168
specification of, 168
private, in example of qualified names

and access control, 111
public, interfaces, declarations, 205
references to, binary file format

requirements, 254
result type, binary compatibility

considerations, 268
scope of formal parameters, 85, 168
shadowing, 87
signatures, 169
static, binary compatibility

considerations, 269
stop, as asynchronous exception

cause, 220
synchronized, 174

binary compatibility considerations, 270
throws clause, binary compatibility

considerations, 270
toString, as member of Object class, 45
uncaughtException

exception handling use, 223
when invoked, 220
and unreachable statements, 310
wait, as member of Object class, 45
when reachable, 311

Mitchell, James G., 7modifiers

See also declarations
class, 137
constructor, 191
declaration

See abstract modifier; final modifier;

private modifier; protected
modifier; public modifier; static
modifier; strictfp modifier;
synchronized modifier;
transient modifier
field, 154
interface, 200
method, 169Modula-3

, 3, 6Molie`re
, 9Mo/ller-Pedersen, Birger

, 7monitors

See also locks; synchronization
term definition, 429Montaigne, Michael de

, 167Moon, David A.
, 6Morlay, Bernard de

, 118

N
named class

exceptions in instance initializer, 188named type

, 200names

See also identifiers; scope; Unicode

character set
(chapter), 81
ambiguous

handling of, 93, 96
reclassification of, 96
binary

implementation keeps track

of types using, 129
term definition, 253
canonical, 82

is binary name of top-level type, 253
and single-type imports, 126
term definition, 113
and type-import-on-demand, 127
class, naming conventions, 114

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

482

names (continued)

conflicts

See also hiding
avoiding

in fields with multiple

inheritance, 165
through context use, 94
through naming conventions, 113
constants, naming conventions, 116
conventions, 113

impact on name obscuring, 89
expression

context in which a name

is classified as, 97
qualified, meaning of, 102
simple, meaning of, 101
fields, naming conventions, 115
fully qualified, of a top-level type, 129
interface

member, access to, 202
naming conventions, 114
meaning of, determining, 93
method, 167

context in which a name

is classified as, 96
naming conventions, 115
qualified, meaning of, 104
simple, meaning of, 104
package

in compilation units, 123
context in which a name

is classified as, 97
limited significance for access

control, 120
naming conventions, 113
qualified, meaning of, 98
scope, 125
simple, meaning of, 98
unique, 132

importance of, 132
parameters, naming conventions, 116
qualified

access control and, 104
fully, 111
term definition, 81
resolving references to, during

resolution phase of linking, 230
restrictions, types and subpackages, 120

names (continued)

rules on being the same

class members, 90
fields, 90
interface fields, 92
simple, 253

class cannot have same

as enclosing class, 137
interface cannot have same

as enclosing class, 200
term definition, 83
as subset of identifiers, 83
syntactic

categories, 93
classification of according to context, 94
term definition, 83
type

context in which a name

is classified as, 96
qualified, meaning of, 100
simple, meaning of, 99
variables, local, naming conventions, 116NaN (Not-a-Number)

See also numbers
and addition, 381
comparison results, 39
and division, 375
and multiplication, 373
predefined constants representing, 25
preventing use of algebraic identities

in expression evaluation, 325
term definition and specification, 35narrowing

See also conversion; numbers
primitive conversions

in assignment conversion context, 66
in casting conversion context, 72
not allowed in method invocation

conversion context, reasons for, 71
reference conversions, specification, 63
native modifier

See also declarations; modifiers
methods

binary compatibility considerations, 269
declaration, 173
semicolon as body of, 177
reasons why constructors cannot be, 191nested class

, 135, 136

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 483

nested class (continued)

See also nested type
and definite [un]assignment of

variables, 418
inner class is a, 140
interaction with shadowing of

parameters, 168
local class is a, 277
may declare static members

if non-inner, 140
name hides same name

in enclosing scopes, 148
term definition, 135nested interface

, 135, 136, 199
See also nested type, 135
term definition, 199nested type

binary name of, 253
declaration

in scope of a class member, 85, 147
declarations

included in scope

of interface members, 85, 202
in scope of an interface member, 85, 202Newton, Sir Isaac

, 1nonpublic
classes, in example of qualified names

and access control, 107nonterminal symbols

See also grammars
definition of, notation for, 10
term definition, 9notation

See also names, naming conventions
grammar, 10notification

wait sets and, 446null
literal, term definition and

specification, 29
qualifying a superclass constructor

invocation, 194
type

literal as source code representation

of the value of, 20
term definition and specification, 32numbers

See also arithmetic; precision; types

numbers (continued)

conversions of and to

See conversions
errors in handling

See exceptions
manipulating

See arithmetic operators
numeric promotion

binary, 79
specification, 77
term definition, 56
unary, 78
primitive types

See byte type; char type; double type;

float type; floating-point; int
type; integers; integral type; long
type; short type
related types

See boolean; characters; stringsNygaard, Kristen

, 7

O
object-oriented concepts

See class(es); encapsulation; fields;

inheritance; method(s); objectsobjects

See also arrays; classes; instances;

interfaces; types
Class, array, 215
fields that reference, final modifier

effect on changes to, 50, 156
finalization attributes, 246
life cycle, 246
Object class, 44, 215
operations on references to, 43
reachable, finalization implication, 246
reference

See references
state

impact of changes, 43
transient fields not part of, 156
term definition and specification, 42
unreachable, finalization implications, 246obscured

declaration, term definition, 89
label, 85

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

484

obscured (continued)

by labels, 286
of labels, 286observable

all compilation units in java

and java.lang are, 123
compilation unit

determined by host, 120
term definition, 123
package

and meaning of qualified

package name, 98
term definition, 125Occam, William of

, 373octal

See also numbers
base, permitted in integer literals, 21
numerals, specification, 22one of phrase

grammar notation use, 12operators
See also constructors; expressions;

initialization; methods; numbers
arithmetic, numeric promotion,

specification, 77
assignment, as only way to change the

value of a primitive variable, 33
binary, evaluation order, 322
boolean, 40
compound assignment, evaluation

order, 323
floating-point, 37

signed infinity produced by overflow, 39
signed zero produced by underflow, 39
integer

divide, divide by zero exception

thrown by, 34
overflow not indicated by, 34
underflow not indicated by, 34
integral, 33
list of, 30
operands evaluated before, 324
precedence, in expression evaluation, 325
on reference types, 43
remainder, divide by zero exception

thrown by, 34
string concatenation

constructor invocation by, 190

operators (continued)

string concatenation (continued)

creating new instances with, 42
thread, term definition, 431opt subscript

grammar notation use, 10optimization
during

preparation phase of linking, 235
resolution phase of linking, 235
final method inlining, 172
finalization, 245

reachable objects reduction, 246
linking

initialization phase of, 240
resolution strategies, 234optional symbol

term definition, 10order
evaluation

argument lists left-to-right, 326
binary operators, 322
compound assignment, 323
left-hand operand first, 322
operands evaluated before

operations, 324
of other expressions, 327
parentheses and precedence

respected, 325
execution, thread rules, 433
field initialization, at run-time, 204
finalizer invocations, implications

of no ordering imposition, 247
of floating-point values, 37
of occurrence, initialization of types, 236
thread interaction, consequences of, 430origin

of arrays, 211output
See filesoverflow
See also arithmetic; exceptions; numbers
floating-point operators,

signed infinity produced by, 39
not indicated by integer operators, 34overloading

See also object-oriented concepts;

inheritance; methods

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 485

overloading (continued)

of abstract interface methods

declarations, 207
example, 208
of constructors, 195

binary compatibility considerations, 270
of methods, 180

binary compatibility considerations, 270
example, 181
term definition, 91, 180overriding

See also object-oriented concepts; scope
examples, 181, 182, 185, 207

incorrect, 181
incorrect because of throws,

example, 186
large example, 185
methods

abstract

in abstract classes, 170
of non-abstract instance

methods, 171
binary compatibility considerations, 271
in interfaces, 206

example, 207
instance, 177
requirements in, 178
term definition, 91

P
packages

(chapter), 119
binary compatibility considerations, 257
canonical name of, 113
declarations

in compilation units, 124
shadowing, 125
as declared entity, 81
host support for, 120
importing all public types from a, 127
members of, 89, 119
named, in compilation units, 124
names

context in which a name

is classified as, 94
fully qualified, 111

packages (continued)

names (continued)

naming conventions, 113
qualified, meaning of, 98
simple, meaning of, 98
unique, importance of, 132
observable, 125
scope of, 85
shadowing, 87
storing in a

database, 122
file system, 121
term definition, 119
unnamed

compilation units belonging to, 123
in compilation units,

uses and cautions, 124
and fully qualified name

of top-level type, 129Paine, Thomas

, 305parameters

See also modifiers; variable
constructor, 191

assignment during instance

creation, 242
binary compatibility considerations, 267
description, 49
initial value, 51
as declared entity, 81
definite [un]assignment of, 425
exception

description, 49
initial value, 51
scope, 86, 306
method

binary compatibility considerations, 267
description, 48
initial value, 51
specification of, 168
must not be assigned if final, 168
names, naming conventions, 116
scope, 85, 168
shadowing, 86, 168Partridge, Eric

, 135Peirce, Charles

, 407Peretti, Hugo E.

, 30performance

See optimization

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

486

platform-dependent

native methods are, 173pointers

See referencespolling
for asynchronous exceptions, 224precedence
See also expressions
of operators, in expression

evaluation, 325precise

term definition, 223precision
See also numbers
possible loss of

in narrowing primitive conversions, 60
in widening primitive conversions, 58preparation

of classes, 234
of interfaces, 234
in Test class example,

at virtual machine startup, 230prescient store

actions, with threads, 438preventing
instantiation, 197

with private constructors, 139primitive

See also numbers
conversion

narrowing

in assignment conversion context, 66
in casting conversion context, 72
not allowed in method invocation

conversion context, reasons for, 71
widening

in assignment conversion context, 66
in binary numeric promotion

context, 79
in casting conversion context, 72
in method invocation conversion

context, 71
in unary numeric promotion

context, 78
types

as array element types, 210
changing value of variables, 33
fully qualified name for, 111

primitive (continued)

types (continued)

literal as source code representation

of the value of, 21
term definition and specification, 32
variables of, specification, 48priority

thread, 445
private modifier

See also declarations; modifiers
access

determining, 105
inheritance of class members,

example, 151
cannot be used for local classes, 278
class, pertains only to member, 137
constructors

access control, example, 111
preventing instantiation with, 139
fields, access control, example, 111
inheritance with, example, 151
and interfaces, 200
members not inherited, 148
methods

abstract not permitted with, 170
access control, example, 111
in example of qualified names

and access control, 111
as implicitly final, 172
overriding and hiding

not possible with, 179
preventing instantiation

by declaring constructors as, 197
top-level type may not use, 131productions

term definition, 9promotion
See also numbers
(chapter), 55
numeric, 77

binary, 79

specification, 79
specification, 77
term definition, 56
unary, 78

specification, 78
protected modifier

See also declarations; modifiers

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 487

protected modifier (continued)

access, 105
cannot be use for local classes, 278
class, pertains only to member, 137
constructors, access control, example, 110
fields, access control, example, 110
inheritance with, example, 150
and interfaces, 200
methods, access control, example, 110
top-level type may not use, 131
public modifier

See also declarations; modifiers
access, 105

inheritance of class members,

example, 150
cannot be used for local classes, 278
classes

access control in, 105
binary compatibility considerations, 258
in example of qualified names

and access control, 107
pertains only to top-level and

member, 137
constructors, access control, example, 109
fields

access control, example, 109
interface, implicit in declaration, 203
implicit for interface member types, 208
inheritance with, example, 150
interfaces

binary compatibility considerations, 272
declarations, 200
methods

access control, example, 109
in interfaces, implicit in declaration, 205
superclasses, accessing instances of nonpublic subclasses through, 151
superinterfaces, accessing instances of

non-public subclasses through, 151

Q
qualified

See also access; scope
access, term definition, 104
class instance creation, 330

and definite [un]assignment, 417

qualified (continued)

class instance creation expression, 84

protected accessibility of

constructor, 106
protected accessibility

of superclass constructor, 106
names

access control and, 104
expression, meaning of, 102
fully, 111
method, meaning of, 104
not permitted with parameters, 168
package, meaning of, 98
term definition, 81
type, meaning of, 100
super, 193
superclass constructor invocation, 193

and protected accessibility, 106qualifying type

of a constructor invocation

term definition, 255
of a field reference, term definition, 253
of a method invocation

as compile-time information stored

for use at run-time, 355
term definition, 254Quayle, J. Danforth

, 220

R
Raper, Larry, 251reachable

See also scope
objects

finalization implications, 246
term definition, 246recursive

term definition, 10references
See also expressions; types
conversions

narrowing, 63
widening, 62

in assignment conversion context, 66
in casting conversion context, 72
in method invocation conversion

context, 71

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

488

references (continued)

to fields, active use, 238
forward

permitted in

class type usage, 131
interface type usage, 199
object, value of array variables as, 210
operations, 43
symbolic

binary file format requirements, 253
resolution, 235
term definition, 42
types

array, 210
class

See class
criteria for determining when two

are the same, 45
interface

See interface
member name, scope of, 85
member, as declared entity, 81
specification, 41

in class declaration, 136
in interface declaration, 199
variables, specification, 48release-to-release compatibility

See binary, compatibilityrepresentation
binary, classes and interfaces,

verification of, 234resolution

late, in class and interface linking, 234
lazy, 231
name conflicts

avoiding with multiply inherited

fields, 165
avoiding with multiply inherited

types, 188, 208
context use in avoiding, 94
static, in class and interface linking, 234
symbolic references, 235
in Test class example, at virtual

machine startup, 230
return statement

definite assignment, 423
instance initializer, 189
as reason for abrupt completion, 276

return statement (continued)

specification, 301reuse, software

See binary, compatibilityright-hand side
term definition, 9Ritchie, Dennis M.

, 7Robson, David
, 6rounding

IEEE 754 standard default mode,

support required for, 38
round to nearest, term definition, 38
round toward zero, term definition, 38run-time

checks of expressions, 319
errors

See exceptions
RuntimeException class

unchecked exceptions found in, 176
state, linking binary objects into, 233
type, 52
validity checks, casting conversion

requirements, 74

S
scope

See also declarations; inheritance; names;

object-oriented concepts
of declarations, 85

formal parameter, 168
of formal parameters, 85, 168
of labels, 85, 286
of a local class, 86, 278
of local variable declared

by for statement, 86, 295
member, 85, 147, 202
overview, 81
package, 125
parameters

formal, 168
shadowing rules, 86
of a top-level type, 85, 129
types declared by an import

declaration, 85, 125
exception parameters, 306
in, term definition, 85

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 489

scope (continued)

initializer execution relative

to issues of, 159, 160, 189
of a local class, 278
in method invocation expressions, 346
of names

of exception handler parameters, 86,

306
local variables, 49, 85, 280
parameters, formal, 85, 168
nested classes, variables and definite

[un]assignment, 418
term definition, 85
type initialization order restrictions, 237Sebastian, John

, 288security

See also access control; exceptions; types;

virtual machine
internal symbolic reference table,

role in maintaining, 232
type systems, verification importance

to, 259semantics

See also grammars; lexical; syntax
errors in, exceptions as mechanism for

signaling at run-time, 219
expressions, (chapter), 317
names

context role, 94
determining, 93
expressions, 100
methods, 104
package, 98
types, 99
verifying during linking process, 234semicolon (

;)
as method body, 176separators

list of, 29
as token, 10sequences

escape, for character and string literals, 28Seuss, Dr.

, 132shadowing

absence of by statement labels, 286
of declarations, 86

by package declarations, 125
of exception parameters, 306

shadowing (continued)

of labels, 87, 286
of local classes, 278
by local variables, 283
of local variables, 280
and the meaning of a simple expression

name, 101
and the meaning of a simple type name, 99
by member types, 187
of members by local variables, 282
of methods, 87
by a nested class, 148
package, 125
of packages, 87
parameters, 168
by single-type import, 87, 126
by type-import-on-demand, 87, 127
of types, 86
of variables, 86Shakespeare, William

, 30, 55, 118, 249,
436Shelley, Percy Bysshe

, 376
short type

See also integral types; numbers
value range, 33side effects

See also expressions
from expression evaluation,

reasons for, 317signature

of constructors, 191
of methods, 169
methods with same, inheriting, 179simple names

See also identifiers; names
expression, meaning of, 101
method, meaning of, 104
package, meaning of, 98
term definition, 83
type, meaning of, 99single quote(')

escape sequence, 29Smalltalk-80

, 6sorting

Unicode, reference for details on, 20source code
compatibility, compared with

binary compatibility, 257

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

490

source code (continued)

transformations that preserve

binary compatibility, 253Southey, Robert

, 372square brackets (

[])
in array

type declaration, 210
variable declaration, 211startup

virtual machine, 229state
not shared by primitive values, 33
object

impact of changes, 43
transient fields not part

of persistent, 156statements

See also constructors; control flow;

expressions; initializers; methods
(chapter), 275
break

definite assignment, 423
specification, 297
completion of

abrupt, reasons for, 276
normal, reasons for, 276
continue

definite assignment, 423
specification, 299
definite assignment, 417
do

definite assignment, 421
specification, 293
empty

definite assignment, 418
specification, 285
expression

definite assignment, 419
specification, 286
for

definite assignment, 422
specification, 295
general specification, 284
if

dangling else handling, 285
definite assignment, 420
if-then, specification, 288
if-then-else, specification, 288

statements (continued)

labeled

definite assignment, 419
scope of, 85, 286
specification, 286
local variable declarations

execution of, 283
specification, 279
return

definite assignment, 423
specification, 301
switch

definite assignment, 420
specification, 288
synchronized

definite assignment, 424
specification, 304
throw

definite assignment, 423
specification, 302
try

definite assignment, 424
try-catch, specification, 307
try-catch-finally, specification, 308
unreachable, conservative flow

analysis detection of, 310
while

definite assignment, 421
specification, 292static

restrictions in inner classes, 140static context

, 140
and method invocation, 355
and qualified superclass constructor

invocation, 194static initializer

definite [un]assignment within, 426
definite assignment of variables

before, 418
inner class may not declare, 140
may not contain a return statement, 301
must assign all blank final class

variables, 156
and unreachable statements, 310
when reachable, 311static initializers

are not members, 148
and checked exceptions, 221

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 491

static initializers (continued)

overview, 136
static modifier

for fields

binary compatibility considerations, 266
creating during the preparation phase

of linking, 234
default initialization of during the

preparation phase of linking, 234
static modifier

for fields

initializers

as components of a class body, 147
for, 189
static modifier

See also declarations; modifiers
anonymous class is never, 335
cannot be used for local classes, 278
class, pertains only to member, 137
for fields, 155

declaring class variables using, 155
initialization of, 158
implicit in interface member

declarations, 203
initialization of, 189
for methods

declaring class methods with, 171
hiding by, 178
not permitted in interface

method declarations, 206
implicit for interface member types, 208
and interfaces, 200
reason why constructors do not use, 191
top-level type may not use, 131Stein, Gertrude

, 118, 370, 449store

array, exception, 216storing
packages

in a database, 122
in a file system, 121
strictfp modifier

constructors cannot be declared, 191
example(s), 325
for classes, 137

semantics, 139
and FP-strict expressions, 319
has no effect on method override, 178

strictfp modifier (continued)

interfaces, 200

methods may not be, 206
semantics, 200
methods, 169

semantics, 173
and widening conversion, 58string(s)

See also characters; numbers;

primitive types
character arrays are not the same as, 215
concatenation operator (+)

constructor invocation by, 190
creating new instances with, 42
conversion

context specification, 72
specification, 64
literals

escape sequences for, 28
interning of, 27
term definition and specification, 27
String class

creating instances, with string

concatenation operator, 43
literal as source code representation

of the value of, 21
specification, 45
string literal as reference

to an instance of, 27Stroustrup, Bjarne

, 6subclasses

See also class(es); interfaces; superclasses;

superinterfaces
declaration, 143
direct, extending classes with, 142
relationship to direct subclass, 143subpackage

as package member, 89, 119
and package observability, 125
super keyword

accessing

overridden methods with, 178
superclass members with, in expression

evaluation, 344
binary compatibility considerations, 258
not permitted in

class variable initialization, 159
explicit constructor invocation, 192

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

492

super keyword (continued)

not permitted in (continued)

interface field declarations, 204
permitted

in instance initializers, 189
permitted in instance variable

initialization, 160superclass(es)

See also classes; fields; interfaces;

methods; packages; subclasses;
superinterfaces
accessing fields with super, expression

evaluation, 344
of array is Object, 215
binary compatibility considerations, 258
direct

declaration, with extends clause, 142
term definition, 142
extending classes with, 142
public, accessing instances of non-public

subclasses through, 151superinterface(s)

See also classes; fields; interfaces;

methods; packages; subclasses
binary compatibility considerations, 258,

272
direct

declaration, with implements

clause, 144
term definition, 145
of interface, declaration, 201
public, accessing instances of non-public

subclasses through, 151
term definition, 144swapping

threads example, 439Sweet, Richard

, 7switch

block, term definition, 289
switch statement

See also statements
definite assignment, 420
local variable declaration specification,

impact on, 49
specification, 288symbolic references

binary file format requirements, 253
resolution, 235

symbols

See also identifiers; name; variables
goal

CompilationUnit, 10
Input, 9
term definition, 9
nonterminal

notation for definition of, 10
term definition, 9
optional, term definition, 10
terminal, term definition, 9synchronization

See also locks; threads
exception mechanism

integration with, 220
initialization implications of, 239
locks, 445

use by synchronized methods, 174
use by synchronized statement, 304
synchronized modifier

See also modifiers
in method declarations, 174
methods, binary compatibility

considerations, 270
reason why constructors do not use, 191
specification, 446
synchronized statement

definite assignment, 424
operations, 446
specification, 304
term definition, 429
volatile fields used for,

with threads, 156syntactic

See also lexical; semantics
classification, of a name according

to context, 94

T
term definition

abrupt completion, 276, 322
access, 81

accessible, 104
control, 104
qualified, 104
action, 431

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 493

term definition (continued)

action (continued)

by main memory

lock, 431, 432
read, 431, 432
unlock, 431, 432
write, 431, 432
by thread

assign, 431, 432
load, 432
lock, 432
store, 431, 432
unlock, 431
use, 431
activation frame, 359
alphabet, 9
ambiguous member, 204
anonymous class, 330
applicable, 347
array, 209

components, 48, 209

element type, 209
type, 209
element, 209
empty, 209
initializer, 212
length of, 209
type, 209
assign, as thread action, 432
assignable to, 66
assignment, 66, 395

compatible with, 66
associated labels, 289
atomic, 431
binary

compatibility, 256
numeric promotion, 79
blank final, 50
block, 277

enclosing, 141
body

of class, 147
of constructor, 192
of interface, 202
of method, 176
break binary compatibility with, 256
break target, 298
caller, 222

term definition (continued)

can complete normally, 311
cast operator, 72, 368
catch clause, 219, 305
caught, 219, 302
checked exceptions, 221
class(es), 135, 136

abstract, 137
body, 147
declaration, 136
depends on a reference type, 144
direct inner, 140
directly depends on

a reference type, 144
error, 221
exception, 222
final, 139
initialization, 236
inner, 140
inner of another class, 140
local, 277
modifiers, 137
of object, 52
runtime exception, 222
same, 46
strictfp, 139
unloading, 248
variables, 155
comments, 18

end-of-line, 18
traditional, 18
compatibility, binary, 256
compilation unit, 123

observable, 123
compile-time

declaration, 354
type, 47
compile-time type(s)

same, 45
complete

abruptly, 276, 321
normally, 276, 311, 321
component, 209

of array, 48, 209
type of array, 209
constant

expression

compile-time, 405

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

494

term definition (continued)

constructor(s), 190

anonymous, 335
default, 195
parameter, 49, 191
contain, 275

immediately, 275
context

static, 140
context of conversion, 56
continue target, 300
contract, 256
control

access, 104
conversion(s), 55

assignment, 66
casting, 72
contexts, 56
identity, 58
method invocation, 71
primitive

narrowing, 59
widening, 58
reference

narrowing, 63
widening, 62
string, 378
value set, 65
declaration(s), 82

array variable, 210
class, 135

variable, 48
compile-time, 354
constructor, 190
field, 153, 203
import, 125
instance variable, 48
interface, 202
local variable, 49

statement, 279
method, 167
package, 124
parameter

exception, 49
method, 48
shadowed, 86
single-type import, 126
top-level type, 128

term definition (continued)

declaration(s) (continued)

type-import-on-demand, 127
declarator, 279
default

constructor, 195
value, 51
definite assignment, 407
definitely assigned

after, 410

when false, 410
when true, 410
before, 410
definitely unassigned

after, 410

when false, 410
when true, 410
before, 410
direct

extension, 199
subclass, 142
superclass, 142
superinterface, 144, 201
directly implement, 199
dynamic method lookup, 358
dynamically enclosed, 222
element, 209

type, 209
empty

array, 209
statement, 285
enclosed, dynamically, 222
error classes, 221
escape

sequence, character and string, 28
Unicode, 14
evaluation

evaluated, 317
expression, result of, 317
order, 322
exception

caller of, 222
caught, 219
checked, 221
classes, 221

checked, 221
runtime, 222
unchecked, 221

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 495

term definition (continued)

exception (continued)

handler, 306

parameter, 49
polling for, 224
precise, 223
thrown, 219
unchecked, 221
executed, 317
exit of virtual machine, 249
expression, 317

constant, 405
statement, 287
extension, direct, 199
field, 153, 203

declaration, 153
final, 156, 203
non-static, 155
static, 155, 203
transient, 156
volatile, 156
finalizable, 246
finalization, object, 245
finalized, 246
finalizer, 245
finalize-reachable, 246
formal parameter, 168, 191
FP-strict expression, 318
frame activation, 359
goal symbol, 9
gradual underflow, 38
grammar

context-free, 9
lexical, 9
handler of exception, 306
handles, 223
hide, 178

a field, 154
an interface field, 203
an interface member type, 208
a member type, 187
identifier, 19
immediately contain, 275
implement, 91, 145, 177

directly, 199
implemented, 164
import

on demand, 127

term definition (continued)

import (continued)

single type, 126
in scope, 85
inexact, 38
infinities, 35
inherited, 90, 164
inherits, 177
initializer

array, 212
static, 189
variable, 158
input elements, 16
instance

of class, 42
immediately enclosing, 141
immediately enclosing with respect to a

class, 141
initializer, 188
lexically enclosing, 141
method, 172
variables, 155
instantiation, 330
interface(s)

abstract, 200
body, 202
initialization, 236
same, 46
strictfp, 200
top-level, 199
invocation

alternate constructor, 193
superclass constructor, 193
iteration statements, 300
Java

digits, 19
letters, 19
keyword, 20
label, 286

associated, 289
language, 9
left of, to the, 17
left-hand side, 9
length of array, 209
line terminator, 16
linking, 233
literal, 21

boolean, 25

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

496

term definition (continued)

literal (continued)

character, 26
floating-point, 24
integer, 21
null, 29
string, 27
load action by thread, 432
loading, 232
local variable, 49

declaration statement, 279
locks, 431

lock action

by main memory subsystem, 432
by thread, 432
unlock action

by main memory subsystem, 432
by thread, 432
lookup

dynamic method, 358
loss of precision, 59
main memory, 431
master copy, 431
maximally specific, 350
member class, 187
member interface, 187
members, 89

ambiguous, 204
dynamic lookup, 358
memory

main, 431
working, 431
method(s), 167

abstract, 170, 205
applicable, 347
body, 176
class, 171
final, 172
hidden, 178
instance, 172
interface, 205
lookup, dynamic, 358
maximally specific, 350
more specific, 350
most specific, 347, 349, 350
native, 173
non-static, 172
overloaded, 180

term definition (continued)

method(s) (continued)

parameter, 48
signature, 169, 191
static, 171
synchronized, 174
modifiers

class, 137
constructor, 191
field, 155
interface, 200
method, 169
monitors, 429
more specific, 350
most specific, 349, 350
name(s), 83

ambiguous, 93
canonical, 113
contextually ambiguous, 96
expression, 96
method, 96
package, 96
qualified, 83
simple, 83
type, 96
unique package, 132
NaN (Not-a-Number), 35
narrowing

primitive conversion, 59
reference conversion, 63
nested class, 135
non-static

field, 155
method, 172
nonterminal, 9
normal completion, 276, 321, 322
notification, 446
numeric promotion, 77
object(s), 42

class of, 52
target, 358
obscured declaration, 89
observable

package, 125
operators, 30

additive, 377
assignment, 392
bitwise, 388

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 497

term definition (continued)

operators (continued)

cast, 372
equality, 386
logical, 388
multiplicative, 373
relational, 384
shift, 383
unary, 368
order of evaluation, 322
ordered, 37
overload, 180, 207
override, 206
package(s)

accessible, 105
unique names, 132
parameter, 168

constructor, 49, 191
exception handler, 49, 306
formal, 168, 191
method, 48, 168
pointer, 42
polling for exceptions, 224
precise exception, 223
precision, loss of, 59
preparation, 234
prescient store, 438
primitive conversion

narrowing, 59
widening, 58
priority, threads, 445
productions, 9
promotion

numeric, 77

binary, 79
unary, 78
qualified

access, 104
name, 83
qualifying type

of a field, 253
of a method invocation, 254
reachable, 246, 275, 311
read action

by main memory, 432
reason, 220, 276, 321
recursive, 10
reference, 42

term definition (continued)

reference (continued)

conversion

narrowing, 63
widening, 62
target, 356
types, 41
resolution, 235

late, 234
lazy, 234
result, 317
right of, to the, 17
right-hand side, 9
round

to nearest, 38
toward zero, 38
runtime exception classes, 222
run-time type(s)

same, 46
same

class, 45
compile-time type, 45
interface, 45
run-time class, 46
run-time interface, 46
run-time type, 46
scope, 85
separator, 29
signature, 169, 191
simple name, 83
specific

maximally, 350
more, 350
most, 349, 350
statements, 275

empty, 285
expression, 286
iteration, 300
labeled, 286
local variable declaration, 279
unreachable, 310
static

field, 155
initializers, 189
method, 171
resolution, 234
store

action by thread, 432

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

498

term definition (continued)

store (continued)

prescient, 438
strongly typed, 31
subclass, 143

direct, 142
subinterface, 202
superclass, 143

direct, 142
superinterfaces, 145, 201

direct, 144, 201
symbol

goal, 9
nonterminal, 9
optional, 10
terminal, 9
synchronizing, 429
target

break, 298
continue, 300
object, 358
reference, 356
terminal symbol, 9
thread, 429
thrown, 219, 220
throws clause, 175
token, 9, 16
top-level class, 135
type(s), 32, 52

boolean, 33
compile-time, 47
floating-point, 33, 35
import

on demand, 127
single, 125
integral, 33
null, 32
numeric, 33
primitive, 32
reference, 41
typed

strongly, 31
unary numeric promotion, 78
unchecked exception, 221

classes, 221
underflow

gradual, 38
unfinalized, 246

term definition (continued)

Unicode escapes, 14
unique package name, 132
unloading of classes, 248
unlock, 429

action

by main memory, 432
by thread, 432
unordered, 37
unreachable, 310
unreachable object, 246
use

action by thread, 432
value

default, 51
of expression, 318
value set

double, 35
double-extended-exponent, 35
float, 35
float-extended-exponent, 35
variable(s), 47, 431

class, 48, 155
final, 50
instance, 48, 155
local, 49
verification, 234
virtual machine exit, 249
visible, 87
wait set, 446
white space, 17
widening

primitive conversion, 58
reference conversions, 62
working

copy, 431
memory, 431
write action

by main memory, 432terminal symbol

term definition, 9terminators
line

carriage return and linefeed characters

as, 27
term definition, 27
Test

program, how to run, 5

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 499

this keyword

accessing hidden fields with, 283
evaluation of, 328, 329

during instance creation, 242
not permitted

in class variable initialization, 159
in explicit constructor calls, 192
in interface field declarations, 204
permitted

in instance initializers, 189
in instance variable initialization, 160
qualified, 82Thompson, William (Lord Kelvin)

, 317threads

See also synchronization
(chapter), 429
constraints on relationships

among actions of, 433
creation, 445
initialization implications of multiple, 239
interaction order, consequences of, 430
locks acquisition and release,

by synchronized statement, 304
out-of-order writes example, 443
swapping example, 439
synchronized modifier, methods,

declaration, 174
termination and virtual machine exit, 249
volatile fields use with, 156throw

See also control flow; exceptions
throw statement

definite assignment, 423
as reason for abrupt completion, 276
specification, 302
throws clause, 189

of an anonymous constructor, 336
checked exception classes named in, 221
constructors, 192

binary compatibility considerations, 270
incorrect overriding because of,

example, 186
methods, 175

binary compatibility considerations, 270
relation to instance initializers, 188tokens

See also grammars
term definition, 9, 16

top-level class, 96, 111, 113

accessibility of, 105
and binary names, 253
canonical name of, 113
as package member, 89, 119
and private access, 105
and public modifier, 137
term definition, 135top-level interface

, 111
canonical name of, 113
as package member, 89, 119
term definition, 199top-level type

binary name of, 253
fully qualified name of, 129
as part of a compilation unit, 123
scope, 85, 129
transient modifier

See also declarations; modifiers
fields, 156

binary compatibility considerations, 266translations

lexical, steps involved in, 14
try statements

See also control flow; exceptions;

statements
definite assignment, 424
exception handling role of, 222
scope of parameters to exception

handlers, 86, 306
specification, 305
try-catch statement, specification, 307
try-catch-finally statement,

specification, 308types

See also arrays; classes; interfaces; primitive, types
(chapter), 31
argument values, method invocation conversion context, 71
array

canonical name of, 113
members of, 92
syntax and specification, 210
binary compatibility considerations, 256
boolean

Boolean literal specification, 25
term definition and specification, 40

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

500

types (continued)

char

character literal specification, 26
class

members of, 90
naming conventions, 114
compile-time, 52
data values relation to, 32
declaration of, as members of

packages, 128
double, floating-point literal

specification, 24
elements, of array, 209
errors, run-time testing, 320
expression

assignment conversion, 66
how determined, 52
of expressions, 318
float, floating-point literal

specification, 24
floating-point, term definition

and specification, 35
imported

as declared entity, 82
scope of, 85, 125
importing, compilation units, 123
int, integer literal specification, 21
integral, 33
interface

implications for variables

and expressions, 52
members of, 91
naming conventions, 114
local variables, declaration of, 279
long, integer literal specification, 21
name(s)

context in which a name

is classified as, 96
qualified, meaning of, 100
simple, meaning of, 99
named, 125
null, term definition and specification, 32
parameter, method invocation

conversion context, 71
primitive

as array element types, 210
do not share state, 33
fully qualified name, 111

types (continued)

primitive (continued)

term definition and specification, 32
variables, specification, 48
qualifying

See qualifying type
reference

as array element types, 210
criteria for determining when two

are the same, 45
member, as declared entity, 81
specifying with

class declaration, 135
interface declaration, 200
term definition and specification, 41
variables, specification, 48
run-time, 52
term definition, 52
term definition and specification, 32
usage, 46

in declarations and expressions, 47
of variable, how determined, 52
where used, 46

U
unary

numeric promotion, specification, 78unassignment

definite

See definite unassignment, 407unchecked

exceptions, 226underflow
floating-point operators, signed zero

produced by, 38
integer operators, not indicated by, 34unfinalized

as object attribute, 246
term definition, 246Unicode character set

See also characters
character sequences, represented

by instances of class String, 45
composite characters, contrasted

with the Unicode decomposed
characters, 20

INDEX

DRAFT
DRAFT FOR REVIEW PURPOSES ONLY.  DO NOT COPY WITHOUT WRITTEN P 501

Unicode character set (continued)

escapes, 14

specification for handling, 14
term definition, 14
use when suitable font not available, 15
handling in package names, 122
lexical grammar use in terminal

symbols, 9
sorting, reference for details on, 20
writing any character in, using

ASCII characters in escapes, 15unloading

See also linking; loading
of classes and interfaces, 248
of interfaces, 248unqualified

class instance creation

and definite [un]assignment, 416
class instance creation expression, 95unreachable

See also exceptions
objects

finalization implications, 246
term definition, 246
statements, conservative flow analysis

detection of, 310
term definition, 246

V
value

return, specifying method with no, 167value set

and contents of local variables, 280
conversion

See conversion, value set, 65
double, term definition, 35
double-extended-exponent, term

definition, 35
float, term definition, 35
float-extended-exponent, term

definition, 35
and FP-strict expressions, 318
and return statement, 302values

See also assignment; initialization;

primitive, types; variable

values (continued)

(chapter), 31
boolean, term definition and

specification, 40
data, relation to types, 32
expressions, variables as, 318
floating-point, term definition and

specification, 35
integral, term definition and

specification, 33
primitive, term definition and

specification, 32
reference

See references
relation to types, 32
variables, initial and default, 50variables

See also data structures; fields;

identifiers; scope
(chapter), 31
assignment conversion, 66
double, nonatomic treatment

of memory operations on, 435
interaction with locks, rules about, 436
kinds of

array

See arrays, components
constructor parameters

See  parameters, constructor
exception-handling parameters

See exceptions, parameters
instance

See fields, class, non-static
local

See variables, local
method parameters

See parameters, method
local, 279

declaration statements, 279
as declared entity, 81
definite assignment, declarations, 419
description, 49
naming conventions, 116
scope of, 86, 296
shadowing of names by, 283
long, nonatomic treatment of,

memory operations on, 435

INDEX
DRAFT FOR REVIEW PURPOSES ONLY. DO NOT COPY WITHOUT WRITTEN PERMISSION FROM SUN MICROSYSTEMS, INC.

502

variables (continued)

primitive type

changing value of, 33
specification, 48
reference type, specification, 48
term definition and specification, 47
thread use constraints, 434
type of, how determined, 52
values

of expressions, 318
held by different types, summary of, 31
initial and default, 50
volatile, rules about, 437verification

See also security
of binary representation, of classes

and interfaces, 234
type safety dependence on existence

and use of, 259virtual machine

See also exceptions; optimization
class file format specified in, 252, 253
errors, 227
exception handling by, 219
exit, criteria for, 249
object life cycle in, 246
startup, 229visible

, 85
method, and meaning

of method invocation, 346
term definition, 87
void keyword

See also methods
casting to, not permitted, 287
methods

expression return statement

not permitted in, 177
no return value specified by, 167
volatile modifier

See also declarations; modifiers
fields, 156

used for synchronization by threads, 157
final declaration not permitted for, 158
variables, rules about, 437

W
wait

See also synchronization
wait sets, notification and, 446Webb, Jim

, 358Weiss, George David

, 30
while statement

See also control flow
definite assignment, 421
specification, 292white space

term definition, 17Whitman, Walt

, 31, 80, 190, 273, 308widening

See also conversions
primitive conversion

in assignment conversion context, 66
in binary numeric promotion context, 79
in casting conversion context, 72
in method invocation conversion

context, 71
in unary numeric promotion context, 78
reference conversion, 62

in assignment conversion context, 66
in casting conversion context, 72
in method invocation conversion

context, 71Wordsworth, William

, 54, 208, 320, 429

Z
zero

See also exceptions; numbers
divide by, exceptions thrown by integer

divide and remainder operators, 34

503DRAFT

Credits
THE following organizations and copyright holders granted permission for quo-tations used in this book.
Time after Time. Words and Music by Cyndi Lauper and Rob Hyman (C) 1983 Rellla MusicCo. and Dub Notes. All Rights Administered by Sony/ATV Music Publishing, 8 Music
Square West, Nashville, TN 37203. International Copyright Secured. All Rights Reserved.
The Lion Sleeps Tonight. New lyric and revised music by George David Weiss, HugoPeretti and Luigi Creatore. (C) 1961 Folkways Music Publishers, Inc. (C) Renewed 1989 by

George David Weiss, Luigi Creatore and June Peretti. (C) Assigned to Abilene Music, Inc.All Rights Reserved. Used by Permission. WARNER BROS. PUBLICATIONS U.S. INC.,
Miami, FL 33014.
Lyric excerpt of "My Favorite Things" by Richard Rodgers and Oscar Hammerstein II.Copyright (C) 1959 by Richard Rodgers and Oscar Hammerstein II. Copyright Renewed.

WILLIAMSON MUSIC owner of publication and allied rights throughout the world.International Copyright Secured. All Rights Reserved.

Up, Up and Away. Words and Music by Jimmy Webb. Copyright (C) 1967 (Renewed 1995)CHARLES KOPPELMAN MUSIC, MARTIN BANDIER MUSIC and JONATHAN
THREE MUSIC CO. International Copyright Secured. All Rights Reserved.
Did You Ever Have to Make Up Your Mind? Words and Music by John Sebastian. Copy-right (C) 1965, 1966 (Copyrights Renewed) by Alley Music and Trio Music, Inc. All rights

administered by Hudson Bay Music, Inc. International Copyright Secured. All RightsReserved. Used by Permission. WARNER BROS. PUBLICATIONS U.S. INC., Miami,
FL 33014.
Way Down Yonder in New Orleans. Words and Music by Henry Creamer and J. TurnerLayton. Copyright (C) 1922 Shapiro, Bernstein & Co., Inc., New York. Copyright

Renewed. International Copyright Secured. All Rights Reserved. Used by Permission.
Lyric excerpt of "Space Oddity" by David Bowie. Used by Permission. (C) 1969 DavidBowie.

"From Arthur a Grammar", HOW TO WRITE, Gertrude Stein, 1931. Republished byDover Publications, 1975. Reprinted with permission.
A NIGHT AT THE OPERA, Groucho Marx 1935. (C) 1935 Turner Entertainment Co. Allrights reserved.

CREDITS

504 DRAFT

Here Inside my Paper Cup, Everything is Looking Up. PAPER CUP. Words and Music byJim Webb. (C) 1970 CHARLES KOPPELMAN MUSIC, MARTIN BANDIER MUSIC and
JONATHAN THREE MUSIC CO. All Rights Reserved. International Copyright Secured.Used by Permission.

From Ira Forman, Michael Connor, Scott Danforth, and Larry Raper, RELEASE-TO-RELEASE BINARY COMPATIBILITY IN SOM, OOPSLA `95 Conference Proceedings,
Austin, October 1995. Reprinted with permission.

505

Colophon
CAMERA-READY electronic copy for this book was prepared by the authorsusing FrameMaker (release 5.5.6) on Sun workstations.

The body type is Times, set 11 on 13. Chapter titles, section titles, quotations,and running heads are also in Times, in various sizes, weights, and styles. The
index is set 9 on 10.Some of the bullets used in bulleted lists are taken from Zapf Dingbats. Greek
and mathematical symbols are taken from the Symbol typeface.The monospace typeface used for program code in both displays and running
text is Lucida Sans Typewriter; for code fragments in chapter titles, section titles,and first-level index entries, Lucida Sans Typewriter Bold is used. In every case it
is set at 85% of the nominal size of the surrounding Times text; for example, in thebody it is 85% of 11 point.