

Syntactic Type Abstraction
DAN GROSSMAN, GREG MORRISETT, and STEVE ZDANCEWIC
Cornell University

Software developers often structure programs in such a way that different pieces of code constitute
distinct principals. Types help define the protocol by which these principals interact. In particular,
abstract types allow a principal to make strong assumptions about how well-typed clients use
the facilities that it provides. We show how the notions of principals and type abstraction can
be formalized within a language. Different principals can know the implementation of different
abstract types. We use additional syntax to track the flow of values with abstract types during
the evaluation of a program and demonstrate how this framework supports syntactic proofs (in
the style of subject reduction) for type-abstraction properties. Such properties have traditionally
required semantic arguments; using syntax avoids the need to build a model for the language. We
present various typed lambda calculi with principals, including versions that have mutable state
and recursive types.

Categories and Subject Descriptors: D.2.11 [Software Engineering]: Software Architectures--
Information Hiding; Languages; D.3.1 [Programming Languages]: Formal Definitions and
Theory--Syntax ; Semantics; D.3.3 [Programming Languages]: Language Constructs and Fea-
tures--Abstract data types; F.3.2 [Logics and Meanings of Programs]: Semantics of Program-
ming Languages--Operational Semantics; F.3.3 [Logics and Meanings of Programs]: Studies
of Program Constructs--Type Structure

General Terms: Languages, Security, Theory, Verification
Additional Key Words and Phrases: Operational semantics, parametricity, proof techniques, syn-
tactic proofs, type abstraction

1. INTRODUCTION
Programmers often use a notion of principal when designing the structure of aprogram. Examples of principals include modules of a large system, a host and

its clients, and separate functions. Dividing code into such agents is useful forcomposing programs. Moreover, with the increasing use of extensible systems, such
as Web browsers, databases, and operating systems, this notion of principal becomescritical for reasoning about untrusted clients that interact with host-provided code.

In this paper, we incorporate the idea of principal into various typed lambdacalculi. Doing so allows us to formulate security policies and checkthat the type
system enforces them. An example of a useful policy is, "clients can gain access to
This material is based on work supported in part by the AFOSR grant F49620-97-1-0013,
ARPA/RADC grant F30602-1-0317, and National Science Foundation Graduate Fellowships. Any
opinions, findings, and conclusions or recommendations expressed in this publication are those of
the authors and do not reflect the views of these agencies.
Authors' address: Department of Computer Science, 4130 Upson Hall, Cornell University, Ithaca,
NY, 14853; email: {danieljg, jgm, zdance}@cs.cornell.edu.
Permission to make digital/hard copy of all or part of this material without fee for personal
or classroom use provided that the copies are not made or distributed for profit or commercial
advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and
notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish,
to post on servers, or to redistribute to lists requires prior specific permission and/or a fee.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year, Pages 1-44.

2 * Dan Grossman et al.

(* File handle implemented as int *)
abstype fh
open : string \Lambda  fh
read : fh \Lambda  char

Fig. 1. Abstract interface for file handles.

a file handle only through the open procedure."

Consider a host-provided interface for an abstract type of file handles, fh, thatincludes operations to create and use them (Figure 1). The principals in this sce-

nario are the host implementation of the interface and its clients. Each principal's"view of the world" corresponds to its knowledge regarding

fh. In particular, thehost knows that
fh = int, whereas clients do not.The conventional wisdom is that the use of abstract data types in a type-safe

language prevents clients from directly accessing host data. Instead, a client maymanipulate such data only via a host-provided interface. To formali-e this wisdom,
it is necessary to prove theorems that say, "client code cannot violate type abstrac-tions provided by the host." For instance, a client should not be able to treat an
object of type fh as an integer, even though the host implements it that way.How do we prove such properties? One way of phrasing the result is to say
that the client behaves parametrically with respect to the type fh. Using thisobservation, we can encode the agent program in a language like Girard's System
F [Girard et al. 1989], the polymorphic lambda calculus [Reynolds 1974]. The type
fh is held abstract by encoding the client as a polymorphic function:

\Lambda fh.\Pi host : {open : string \Theta  fh, read : fh \Theta  char}.client code
We can then appeal to Reynolds' parametricity results [Reynolds 1983] to concludethat the client respects the host's interface.

Unfortunately, these representation-independence results are proven using seman-tic arguments based on a model of the language (see the workof Mitchell [1991], for
example). We are unaware of any similar results for languages including multiplefeatures of modern languages, such as references, recursive types, objects, threads,
and control operators.Our calculus circumvents this problem by syntactically distinguishing agents with
different type information. By "coloring" host code and client code differently, wecan trackhow these colors intermingle during evaluation. By using different seman-
tics for each principal, we force the client to respect the abstract types providedby the host. This separation of principals provides hooks that enable us to prove
some type-abstraction properties syntactically.

To see why these new mechanisms are useful, consider the evaluation of the clientcode when linked against a host implementation. Figure 2 shows the standard en-

coding of linking as application. In one step of the standard operational semantics,the host type is substituted throughout the client code. It is impossible to talk
about the type fh remaining abstract within the client because fh is replaced by
int. After a second step, host code is substituted throughout client code, and alldistinctions between principals are lost.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 3
\Omega  = {open : string \Lambda  fh, read : fh \Lambda  char}
(\Lambda fh.flhost : \Omega .client code) int host code\Xi \Pi \Lambda 

(flhost : {int/fh}\Omega .{int/fh}client code) host code\Xi \Pi \Lambda  {

host code/host}{int/fh}client code

Fig. 2. Standard encoding for "linking" client and host code.
In the next section, we describe a two-agent setting sufficient for proving inter-esting properties about the file-handle example. It introduces the general approach
of distinguishing principals1 during evaluation. Section 3 introduces a multiagentcalculus that provides for multiple agents, multiple abstract types, and an arbi-
trary assignment of what types are known to what agents. We prove several safetyand abstraction theorems for this calculus; the safety properties for the two-agent
calculus follow as corollaries. The next two sections sketch extensions to our sys-tem that we believe are more difficult in a less syntactic framework. Section 4
adds references and state; the presentation emphasi-es the subtle ways that naivetreatments of state can breaktype abstraction. Section 5 adds recursive types and
polymorphism; here we emphasi-e that these features can be treated as orthogo-nal to principals or that these features can be encoded using principals. Section 6
surveys related work; this work includes approaches to proving type abstraction,approaches to using syntactic proof techniques, and approaches to putting a notion
of principal in a programming language.This workextends our previously published paper [Zdancewic et al. 1999] by
providing a more complete presentation of the two-agent and multiagent calculiand extensions that incorporate state, recursive types, and polymorphism.

2. THE TWO-AGENT CALCULUS
2.1 Syntax
This section describes a variant of the simply typed lambda calculus with twoprincipals, a client and a host. The language maintains a syntactic distinction

between host and client code throughout evaluation. The host exports one abstracttype,

t, implemented as concrete type jh.Figure 3 gives the syntax for the two-agent calculus. Types,

j, include a basetype,
b, the host's abstract type, t, and function types. The terms of the languageare client terms,

C, client values, ^C, host terms, H, and host values, ^H. Themetavariable
xc ranges over client variables, which are disjoint from host variables,ranged over by

xh.The metavariables

bc and bh range over values of base type. We assume thatthe host and client use the same underlying representation for values of base type.

These values are thus the fundamental medium of information exchange betweenagents. For example, the client value 3

c corresponds to the host value 3h. It wouldbe possible to relax this assumption; conversion between host and client values

would then require computation (for instance to change the byte-order of integer
1Throughout this paper, we use the words "principal," "agent," and "color" interchangeably.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

4 * Dan Grossman et al.

\Omega  ::= t | b | \Omega  \Lambda  \Omega \Delta 
C ::= xc | bc | flxc :\Omega . C | C C\Delta  | pxHqy\Theta h

^C ::= bc | flxc :\Omega . C | px ^Hqyth

H ::= xh | bh | flxh :\Omega . H | H H\Delta  | pxCqy\Theta c

^H ::= bh | flxh : \Omega . H

e ::= C | H

^e ::= ^C | ^H

Fig. 3. Two-agent syntax.
values). One of the advantages of distinguishing principals is that places wheresuch marshalling and unmarshalling is needed are made explicit in the program.

It is helpful to thinkof terms generated by C and H as having different colors(indicated by the subscripts

c and h respectively) that indicate to which principaleach belongs. As observed in the introduction, client and host terms mix during

evaluation. To keep track of this intermingling, agent terms contain embedded hostterms of the form \Delta \Theta 

H\Lambda \Xi \Lambda h. Intuitively, the brackets delimit a piece of h-colored code,where
H is exported to the agent at type j. Dually, host terms may containembedded clients.

The type annotations on the embeddings keep track of values of type t duringexecution. In particular, a host term of type

jh may be embedded in a client term.If the annotation is
t, then the client has no information about the form of theterm inside the embedding. Thus, an embedding with annotation

t and containinga host value is a client value.

A good intuition for the semantics is to imagine two copies of the simply typedlambda calculus augmented with a new type

t. In the client copy, t is abstract,whereas in the host copy,
t is jh. Because the host has more knowledge, there is anasymmetry in the language. In the semantics, this asymmetry manifests itself in

rules in which the host refines t to jh. It also means the notion of value depends onthe principal and the type information: an embedding with annotation

t is a clientvalue. An embedding is never a host value because the annotation is never a type

that is abstract to the host.
2.2 Notation
Before describing the semantics, we define some convenient notions. Let e rangeover both client and host terms, and let ^

e range over both client and host values.The color of
e is c if e is a C term; otherwise, e's color is h. Note that both termsin a syntactically well-formed application are the same color. Because the host and

client terms share some semantic rules, we use polychromatic rules to range overboth kinds of terms. The intention is that all terms mentioned in a polychromatic
rule have the same color; the rule is short-hand for two analogous rules, one foreach color.

We write {e\Delta /x}e for the capture-avoiding substitution of e\Delta  for x in e. Termsare equal up to alpha conversion, where substituted variables are of the same color.
We also define substitution on types, written {j\Delta /t}j. Intuitively, we use the sub-
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 5
Polychromatic Steps -P1] e e\Delta  \Xi \Pi \Lambda  e\Delta \Delta  e\Delta  if e \Xi \Pi \Lambda  e\Delta \Delta 

-P2] ^e e\Delta  \Xi \Pi \Lambda  ^e e\Delta \Delta  if e\Delta  \Xi \Pi \Lambda  e\Delta \Delta 
-P3] (flx: \Omega . e) ^e \Xi \Pi \Lambda  {^e/x}e
Client Steps -C1] pxHqy\Theta h \Xi \Pi \Lambda  pxH\Delta qy\Theta h if H \Xi \Pi \Lambda  H\Delta 

-C2] pxbhqybh \Xi \Pi \Lambda  bc
-C3] pxflxh :\Omega . Hqy\Theta \Delta \Theta \Theta \Delta \Delta h \Xi \Pi \Lambda  flxc :\Omega \Delta . px{pxxcqy\Theta c /xh}Hqy\Theta \Delta \Delta h
Host Steps -H1] pxCqy\Theta c \Xi \Pi \Lambda  pxC\Delta qy\Theta c if C \Xi \Pi \Lambda  C\Delta 

-H2] pxbcqybc \Xi \Pi \Lambda  bh
-H3] pxflxc : \Omega . Cqy\Theta \Delta \Theta \Theta \Delta \Delta c \Xi \Pi \Lambda  flxh : {\Omega h/t}\Omega \Delta . px{pxxhqy\Theta h/xc}Cqy\Theta \Delta \Delta c
-H4] pxpx ^Hqythqy\Theta hc \Xi \Pi \Lambda  ^H

Fig. 4. Two-agent dynamic semantics.
stitution {jh/t}j to produce the host's view of j.We say a client term is host-free if it contains no embeddings (and similarly for
client-free host terms).
2.3 Dynamic Semantics
Figure 4 describes a small-step operational semantics for the two-agent calculus.The polychromatic rules are the same as for the simply typed call-by-value lambda

calculus. The other rules handle embeddings.Rules [C1 ] and [H1 ] allow evaluation to proceed within embeddings. Inside
embeddings, the rules for the other color apply. These "context switches" ensurethat terms evaluate with the appropriate rules for their color. If an embedded
value is exported to the outer principal at type b, the outer agent can strip awaythe embedding and use that value (see rules [C2 ] and [H2 ]). It is at this point that
conversion between data representations would take place.Rules [C3 ] and [H3 ] maintain the distinction between client and host code. For
example, suppose the client contains a host function that is being exported at type
j\Delta  \Theta  j\Delta \Delta . In this case, the client does know that the embedding contains a function,so the client can apply it to an argument of a suitable type. If instead the function

had been exported at type t, the client would not have been able to apply it. Thesubtlety is that the host type of the function may be more specific than the client
type, such as when j\Delta  = t.Thus, [C3 ] converts an embedded host function to a client function with an
argument of type j\Delta . The body of the client version of the function is an embeddingof the host code, except that, as the argument now comes from the client, every
occurrence of the original argument variable, xh, is replaced by an embedding of theclient's argument variable, \Delta \Theta 

xc\Lambda \Xi \Lambda c . This embedding is exported to the host at type j,the type the host originally expected for the function argument. The rule for hosts,

[H3 ], is symmetric, except that, because the host may use t as jh, occurrences of tin the host function's type annotation are replaced by

jh.The final rule, [H4 ], allows the host to "open up" a client value that is an

embedded host value. This rule allows the host to recover a value that has been

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

6 * Dan Grossman et al.

(flopenc :string \Lambda  fh. openc "myfile"c) pxflsh : string. ho shqystring\Theta fhh
(1) (flopenc :string \Lambda  fh. openc "myfile"c) (flsc : string. pxho pxscqystringc qyfhh )
(2) (flsc :string. pxho pxscqystringc qyfhh ) "myfile"c
(3) pxho px"myfile"cqystringc qyfhh
(4) pxho "myfile"hqyfhh

...

(n) px3hqyfhh

Fig. 5. Client calling open.
embedded abstractly in the client. The restricted form of this rule ensures thatthe term inside the embedding is a value and is itself an embedding. (Specifically,
if the annotation is not t, then the term is not a value.) Therefore, no other ruleapplies. This restriction keeps our system deterministic, a property that we find
convenient, but that is probably not necessary.The crucial point is that any attempt by the client to treat a value of type

t as afunction leads to a stuckconfiguration (no rule applies). More generally, we ensure

that any configuration in which an abstract value appears in an "active position"is stuck. This fact, along with the stuck configurations of the simply typed lambda
calculus, allows us to prove the safety properties of Section 2.6.
2.4 Examples
We now give two examples of program evaluation in the two-agent calculus. Re-turning to our example of file handles, let

t = fh and jh = int.Figure 5 shows the client obtaining a file handle through a host interface. For

simplicity, only the host's open function is provided to the client. The host imple-mentation,

ho, takes in a string and produces an integer representing a file handle.This code is embedded inside the client at the more abstract type

string \Theta  fh.Step (1) uses [C3 ] to convert the embedded host function to a client function.

Note that the new variable, sc, is embedded in the host as a client term. Step (2)is a standard

*-reduction. Together, these two reduction steps correspond to thelinking of host and client code, but, unlike the example in Figure 2, there is no

type information about fh given to the client code. Step (3) is another *-reduction,passing in the client string "myfile." Step (4) uses [H2 ] to extract the string from
the embedding. At this point, the host function ho is applied to a host value.Repeated use of [C1 ] allows the host function to proceed. We assume that

horeturns 3 when applied to "myfile." This result, embedded within the client code

at type fh, is a client value.The second example (Figure 6) illustrates the client calling the host's

read func-

tion, passing in the file handle \Delta \Theta 3h\Lambda \Xi fhh . We assume the host code for read is alreadyembedded in the client and exported at the type

fh \Theta  char. The body of the hostfunction is
hr, a host term taking an integer representing a file handle and returninga character read from that file.

In step (1), the client extracts the host function via rule [C3 ]. The type of theargument

handlec is abstract in the client, so the type annotation is changed to

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 7
pxflhandleh : int. hr handlehqyfh\Theta charh px3hqyfhh
(1) (flhandlec : fh. pxhr pxhandlecqyintc qycharh ) px3hqyfhh
(2) pxhr pxpx3hqyfhh qyintc qycharh
(3) pxhr 3hqycharh

...

(n) px\Delta A\Delta hqycharh
(n + 1) \Delta A\Delta c

Fig. 6. Client calling read.

Polychromatic Rules
-var] O \Upsilon  x : O(x) [const] O \Upsilon  b : b [app]

O \Upsilon  e : \Omega \Delta  \Lambda  \Omega  O \Upsilon  e\Delta  : \Omega \Delta 

O \Upsilon  e e\Delta  : \Omega 

Client Rules

-Cfn]

O[xc : \Omega \Delta ] \Upsilon  C : \Omega 
O \Upsilon  flxc : \Omega \Delta . C : \Omega \Delta  \Lambda  \Omega  -HinC ]

O \Upsilon  H : {\Omega h/t}\Omega 

O \Upsilon  pxHqy\Theta h : \Omega 

Host Rules
-Hfn]

O[xh : \Omega \Delta ] \Upsilon  H : \Omega 
O \Upsilon  flxh :\Omega \Delta . H : \Omega \Delta  \Lambda  \Omega  t \Phi \Psi  \Omega \Delta  -CinH ]

O \Upsilon  C : \Omega 
O \Upsilon  pxCqy\Theta c : {\Omega h/t}\Omega 

Fig. 7. Two-agent static semantics.
fh. The second step is a *-reduction. At this point, evaluation continues via [H4 ],which in step (3) allows the embedded host code to extract the integer 3, held
abstract by the client, as a host value. The application (hr 3h) proceeds as usualuntil the host computes the character read from the file. At last, because this
embedded character is exported to the client at type char, rule [C2 ] produces thevalue \Delta 

A\Delta c.

2.5 Static Semantics
Figure 7 describes the static semantics for the two-agent calculus. The typingcontext, K, maps variables (of either color) to types. The polychromatic rules are

standard, as is the introduction rule for client functions. For host functions, theonly difference is that

t is not allowed to appear in the annotation for the argumentto a function. Because the host knows that

t = jh, this restriction does not limitexpressiveness. The convenient effect of this side condition and rule [CinH ] is that

types of host terms never contain t. The presence of t in host-function types wouldcomplicate other rules, such as [var ] and [app], because we would often need to
refine a type j to {jh/t}j in order for types to be preserved under evaluation.The interesting typing rules are those for embeddings. Rule [HinC ] says that
an embedded host term, H, exported to the client at type j (which may containoccurrences of

t) has type j if the host is able to show that the "actual" type of His {
jh/t}j. In other words, the host may hide type information from the client byreplacing some occurrences of

jh with t in the exported type. The rule for clientsembedded inside of host terms, [CinH ], is dual in that the host refines the types

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

8 * Dan Grossman et al.

erase(xi) = x

erase(b) = b
erase(flx: \Omega . e) = flx:{\Omega h/t}\Omega . erase(e)

erase(e e\Delta ) = erase(e) erase(e\Delta )
erase(pxeqy\Theta i ) = erase(e)

Fig. 8. Two-agent erase translation.
provided by the client.
2.6 Safety Properties
In this section, we explore properties of the two-agent calculus including soundnessand some type-abstraction theorems. We defer the proofs because they are corol-

laries to the corresponding theorems in Sections 3.7 and 3.8. These properties arenot intended to be as general as possible. Rather, they convey the flavor of some
statements that are provable using syntactic arguments.The following lemmas establish type soundness:

Lemma 2.1 (Canonical Forms). Assuming \Pi  \Sigma  ^e : j ,
-- if j = b, then ^e = b for some b.
-- if j = j\Delta  \Theta  j\Delta \Delta , then ^e = \Pi x: j\Delta . e\Delta  for some x and e\Delta .
-- if j = t, then ^e = \Delta \Theta  ^H\Lambda \Xi th for some ^H of type jh.

Lemma 2.2 (Preservation). If \Pi  \Sigma  e : j and e \Upsilon \Phi \Theta  e\Delta  then \Pi  \Sigma  e\Delta  : j .
Lemma 2.3 (Progress). If \Pi  \Sigma  e : j , then either e is a value or there exists an
e\Delta  such that e \Upsilon \Phi \Theta  e\Delta .

Definition 2.4. A term e is stuck if it is not a value and there is no e\Delta  such that
e \Upsilon \Phi \Theta  e\Delta .

Theorem 2.5 (Type Soundness). If \Pi  \Sigma  e : j , then there is no stuck e\Delta  suchthat

e \Upsilon \Phi \Theta * e\Delta .

Given a term, if we ignore the colors, erase the embeddings, and replace t with
jh, then we have a well-typed term of the simply typed lambda calculus. Formally,Figure 8 defines the erasure of a two-agent term. (All rules are polychromatic.)

The following lemma states that erasure commutes with evaluation.

Lemma 2.6 (Erasure). Let e be any two-agent term such that \Pi  \Sigma  e : j. Then
e \Upsilon \Phi \Theta * ^e if and only if erase(e) \Upsilon \Phi \Theta * erase(^e).

The interesting fact is that the erasure of rule [C3 ] is basically \Pi x : j. e \Upsilon \Phi \Theta 
\Pi x\Delta  : j. {x\Delta /x}e; the substitution of jh for t in the erasure process ensures that thetypes of the bound variables on either side of the transition are the same. Because

\Pi x : j. e is alpha equivalent to \Pi x\Delta  : j. {x\Delta /x}e, the transition [C3 ] corresponds tothe identity transition (zero steps) in the erased language.

With soundness and erasure established, we reexamine the abstraction propertiesof the introduction. Because the host is always capable of providing information to
the client, we are particularly interested in evaluations where we assume the host
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 9
does not do so. Recall that we say host-free to describe a client term that has nohost terms embedded in it.

One desirable property of the file handle interface is that the client never breaksthe type abstraction for file handles. For example, if

C is host-free, \Pi  \Sigma  handle : fh,and \Pi  \Sigma 
\Pi fc : fh. C : j , then (\Pi fc : fh. C) handle never evaluates to a term in which
handle is treated as an integer. This property is a corollary of type soundnessbecause within the client code the type

fh is not equal to int (and hence, forexample, the expression
fc + 3 is not well-typed).A stronger property is that the client is oblivious to the particular choice of

integer that the host uses to represent a given file handle. More formally:

Theorem 2.7 (Independence of Evaluation). If \Delta \Theta  ^H\Lambda \Xi fhh and \Delta \Theta  ^H\Delta \Lambda \Xi fhh are
well-typed, C is host-free, and \Pi  \Sigma  \Pi fc : fh. C : fh \Theta  b, then (\Pi fc :fh. C) \Delta \Theta  ^H\Lambda \Xi fhh \Upsilon \Phi \Theta *
bc if and only if (\Pi fc :fh. C) \Delta \Theta  ^H\Delta \Lambda \Xi fhh \Upsilon \Phi \Theta * bc.

The proof strengthens the claim to a step-by-step evaluation correspondencewhen using ^

H and ^H\Delta :

Lemma 2.8 (Value Abstraction). Let ^H and ^H\Delta  be host values of type jh. If
C is host-free, [xc : fh] \Sigma  C : j, and {\Delta \Theta  ^H\Lambda \Xi fhh /xc}C is not a value, then there existsa host-free term

C\Delta  such that:

-- [xc : fh] \Sigma  C\Delta  : j
-- {\Delta \Theta  ^H\Lambda \Xi fhh /xc}C \Upsilon \Phi \Theta  {\Delta \Theta  ^H\Lambda \Xi fhh /xc}C\Delta 
-- {\Delta \Theta  ^H\Delta \Lambda \Xi fhh /xc}C \Upsilon \Phi \Theta  {\Delta \Theta  ^H\Delta \Lambda \Xi fhh /xc}C\Delta 

The embeddings also enable us to trackexpressions of the abstract type duringevaluation, thus allowing us to formali-e a third property: The client must have
called open to obtain a file handle.

Theorem 2.9 (File Handles Come from open). Suppose C is host-free, hois client-free, and

\Pi openc : string \Theta  fh. C is well-typed. If (\Pi openc : string \Theta  fh. C)

applied to \Delta \Theta \Pi sh :string. ho sh\Lambda \Xi string\Lambda fhh steps to some term C\Delta  containing \Delta \Theta  ^H\Lambda \Xi fhh
as a subterm, then ^H was derived from a sequence of the form (ho ^H\Delta ) \Upsilon \Phi \Theta * ^H.

The proof shows that (after one step) every host embedding has as its embeddedterm either an application of

ho or an intermediate result of such an application.

3. THE MULTIAGENT CALCULUS
So far, we have described a simple two-agent setting in which the host has strictlymore information than the client. We can model many interesting cases in this

fashion, but there are times when both principals wish to hide information or inwhich there are more than two agents involved. For example, we need a multiagent
setting to prove safety properties about nested abstract data types.Another natural generali-ation is to allow an agent to export multiple abstract
types. Once that facility exists, agents should be able to share type information.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

10 * Dan Grossman et al.

(agents) i, j \Psi  {1, . . . , n}

(lists) , ::= i | i,
(types) \Omega  ::= t | b | \Omega  \Lambda  \Omega \Delta 
(i-terms) ei ::= xi | bi | flxi : \Omega . ei | ei e\Delta i | fix fi(xi:\Omega ).ei | pxejqy\Theta fi
(i-primvals) ^vi ::= bi | flxi : \Omega . ei

(i-values) vi ::= ^vi | px^vjqytfi (t \Phi \Psi  Dom(oei))

Fig. 9. Multiagent syntax.
3.1 Syntax
Figure 9 shows the syntax for the multiagent language. The types include a basetype,

b, function types, and type variables ranged over by t. In what follows, wealso use

u and s to range over type variables.Rather than just two colors of terms, we now assume that there are

n agents,where
n is fixed. We use the metavariables i, j, and k to range over the set ofagents {1

, . . . , n}.Every nonembedding term has exactly one color, as indicated by the subscript.

Embeddings also have a color that is determined by context--the grammar allows
ei and ej to produce syntactically identical embedding terms. We explicitly statethe color of the term when it is ambiguous or particularly relevant to the discussion.

Functions and applications are always constructed from subterms of the same color.The terms for agent

i include variables, xi, constants, bi, nonrecursive functions,
\Pi xi : j. ei, recursive functions, fix fi(xi:j).ei, function applications, ei e\Delta i, and em-beddings, \Delta \Theta 

ej\Lambda \Xi \Lambda ff . We include both recursive and nonrecursive functions to simplifythe dynamic semantics (see rule [4 ] in Figure 10).

An embedding containing a j-term is labeled with a list of agents, o/, for reasonsexplained in Section 3.3. We write simply

j for the singleton list containing theagent
j, and we use juxtaposition to denote appending two lists (o/o/\Delta  is the concate-nation of lists

o/ and o/\Delta ). The static semantics requires that the list for an embedded
j-term begins with j, so in fact o/ = jo/\Delta  for the term \Delta \Theta ej\Lambda \Xi \Lambda ff ; but we write just o/ whenthe

j is unimportant. We use rev(o/) to mean the list-reversal of o/.

3.2 Type Information
The goal is a language in which each agent has limited knowledge of type informa-tion. Thus, we must somehow represent what an agent "knows" and ensure that

agents sharing information do so consistently. For example, agent i might knowthat

fh = int. Agent j may or may not have this piece of information, but if j doesknow the reali-ation of

fh, that knowledge must be compatible with what i knows.(It should not be the case that

j thinks fh = string.)To capture this information, we assume each agent

i has a finite partial mapfrom type variables to types called
AEi. To maintain consistency of knowledge amongagents, we require that all agents that know the implementation of an abstract type

t know the same implementation. We further restrict the AEi maps so that for each
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 11
type variable, t, there is a unique, most concrete interpretation of t. For example,we do not allow

AEi(t) = t \Theta  t, or the more subtle AEi(t) = s \Theta  s, AEj(s) = t, becausethese examples do not admit a well-defined notion of most-concrete type for

t.The need for consistency among agents motivates the first part of the following

definition; the need for most concrete interpretations of a type motivates the secondpart.

Definition 3.1. A set {AE1, . . . , AEn} of finite partial maps from type variables totypes is compatible if:
--For every i, j \Psi  {1, . . . , n} if t \Psi  Dom(AEi) \Omega  Dom(AEj), then AEi(t) = AEj(t).
--The collection of type variables can be totally ordered such that for every agent,

i, and type variable, t, all variables in AEi(t) precede t.

Each AEi extends naturally to a total function, \Delta i from types to types:

\Delta i(b) = b

\Delta i(t) = \Delta  t t ff\Psi  Dom(AEi)AE

i(t) t \Psi  Dom(AEi)\Delta 

i(j \Theta  j\Delta ) = \Delta i(j) \Theta  \Delta i(j\Delta )

Applying \Delta i to a type j either yields j (if i has no information about the typevariables appearing in

j) or a more concrete version of j. For example, \Delta h(fh \Theta 
fh) = int \Theta  int. We say that \Delta i(j) refines j, and we write fii for the reflexive,transitive closure of \Delta 

i viewed as a relation on types. Thus, fh \Theta  fh fih int \Theta  int.The second condition in the definition of compatibility, and the fact that each

agent has a finite amount of type information, guarantees that the process of anagent refining a type halts. That is, the sequence

j fii \Delta i(j) fii \Delta i(\Delta i(j)) fii . . .reaches a fixpoint, which we write _\Delta 

i(j). This fixpoint is the most concrete viewof
j that agent i is able to determine from its knowledge.Even if all of the agents pool their information about type variables, the notion of

a most concrete view of j is still valid. We write \Phi  for the union of the compatible \Delta imaps. It contains the composite knowledge of every agent in the system. Let fi be
the reflexive, transitive closure of the relation \Phi . As above, the process of refining
j using \Phi  also terminates: j fi \Phi (j) fi \Phi (\Phi (j)) fi . . . reaches a fixpoint. Thenotation _\Phi (

j) indicates this fixpoint, which is the most concrete type compatiblewith
j.In practice, the compatibility constraints guarantee two things. First, no set of

agents can conspire to show that incompatible types are equal (and thus effectivelycast an integer to a function, for example). Second, there is a well-defined notion
of most concrete type for each agent. The first criterion is clearly necessary forsoundness of the system. The second criterion greatly simplifies the static seman-
tics. There may be other notions of compatibility that relax one or both of theseconditions while still admitting a sound type system and a well behaved semantics.

3.3 Embeddings
The set of i-terms that are values depends on i's available type information. Inaddition to the usual notion of values, given by

i-primvals, a j-primval embeddedin agent
i is a value if i cannot determine any more type information about thevalue. That is, \Delta \Theta ^

vj\Lambda \Xi tff is an i-value if t ff\Psi  Dom(AEi).

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

12 * Dan Grossman et al.

Because an embedding is not an i-primval, a nested embedding (for example,\Delta \Theta \Delta \Theta 

\Pi xj : j. xj\Lambda \Xi tj\Lambda \Xi si ) is never an i-value. We could have made such terms values, butthe result would significantly complicate the dynamic semantics: if our example

nested embedding were passed to an agent that was able to refine s to an arrow type,then we would need to cross two embedding boundaries to find the function that
the agent expects. Instead, our dynamic semantics collapses the two embeddingsinto one, in this case \Delta \Theta 

\Pi xj : j. xj\Lambda \Xi sji. As a result, values never cross more than oneembedding at a time, but the embeddings are now annotated with a list of agents.

Why is this somewhat complicated mechanism necessary? There must be someway of relating the type of a term inside an embedding to the type annotation on
the embedding; otherwise, an agent could export an integer as a function. Thelist of agents allows us to maintain exactly the information needed to establish
the connection between the type of the term inside an embedding and the typeannotating the embedding. If we forget any agents, inconsistencies may arise. For
example, consider three agents, i, j, and k, such that AEi(t) = int, AEj(s) = t, and
AEk = \Pi . Then collapsing the k-term \Delta \Theta \Delta \Theta 3i\Lambda \Xi ti\Lambda \Xi sj to either \Delta \Theta 3i\Lambda \Xi si or \Delta \Theta 3j\Lambda \Xi sj violates thetype-abstraction properties because neither

i nor j knows that s abstracts an int.If we use sets of agents instead of (ordered) lists, the reasonable rules become too

permissive because we lose the information that agent i must have exported theinteger at type

t before j could export it at type s. As we explain in Section 3.6, thetype system admits the nested-embedding term and the collapsed version, \Delta \Theta 3

i\Lambda \Xi sij,but not the others.

In summary, the lists of agents on embeddings let us remember a particularorder of principals, which is necessary for type checking, without treating nested
embeddings as values.
3.4 Dynamic Semantics
Figure 10 shows the operational semantics for agent i in the multiagent language.That is, several of the rules depend on the color of the term being reduced, and the

rules use i to denote this color.Rules [1 ], [2 ], [4 ], and [5 ] establish a typical call-by-value semantics.

2 Rule [3 ]

allows evaluation inside embeddings. Rule [6 ] lets agent i pull a constant out of anembedding, provided that the constant is exported at type

b. This rule correspondsto rules [C2 ] and [H2 ] of the two-agent scenario.

As in the two-agent case, in which the host had more type information than theclient, an agent can use its knowledge to refine the type of an embedded term. Pre-
viously, the substitution {jh/t} in rule [H3 ] served this purpose. Now, \Delta i capturesthe type-refinement information available to agent

i. Correspondingly, rule [7 ] al-lows
i to refine the type of an embedded value. The side condition on this rule (inconjunction with the conditions on [8 ] and [9 ]) ensures that evaluation is determin-

istic. This determinism of the type-refinement rules is not critical to the system,but it makes many of the proofs easier because there is only one applicable rule
for each evaluation step. The choice of when the operational semantics refines typeinformation interacts with where we must apply the \Delta 

i maps in the static seman-tics; we chose to maintain the invariants that the static semantics always derives

2We believe the language can easily be adapted to a call-by-name setting.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 13
-1]

ei \Xi \Pi \Lambda  e\Delta \Delta i
ei e\Delta i \Xi \Pi \Lambda  e\Delta \Delta i e\Delta i -2]

e\Delta i \Xi \Pi \Lambda  e\Delta \Delta i
vi e\Delta i \Xi \Pi \Lambda  vi e\Delta \Delta i -3]

ej \Xi \Pi \Lambda  e\Delta j
pxejqy\Theta fi \Xi \Pi \Lambda  pxe\Delta jqy\Theta fi

-4] fix fi(xi:\Omega ).ei \Xi \Pi \Lambda  flxi : \Omega . {fix fi(xi:\Omega ).ei/fi}ei
-5] (flxi : \Omega . ei) vi \Xi \Pi \Lambda  {vi/xi}ei
-6] pxbjqybfi \Xi \Pi \Lambda  bi
-7] px^vjqy\Theta fi \Xi \Pi \Lambda  px^vjqy _\Delta i(\Theta )fi (\Omega  \Phi = _\Delta i(\Omega ))
[8] pxpx^vjqyufi qy\Theta kfi\Delta  \Xi \Pi \Lambda  px^vjqy\Theta fikfi\Delta  (u \Phi \Psi  Dom(oek), \Omega  = _\Delta i(\Omega ))
[9] pxflxj :\Omega . ejqy\Theta \Delta \Theta \Theta \Delta \Delta jfi \Xi \Pi \Lambda  flxi : \Omega \Delta . px{pxxiqy\Theta irev(fi)/xj}ejqy\Theta \Delta \Delta jfi (xi fresh, \Omega \Delta  \Lambda  \Omega \Delta \Delta  = _\Delta i(\Omega \Delta  \Lambda  \Omega \Delta \Delta ))

Fig. 10. Multiagent dynamic semantics: e \Xi \Pi \Lambda  e\Delta  where color(e) = i.
the most concrete type for any term, and that types explicitly mentioned in thelambda-abstraction syntax are most concrete. It would be possible to reformulate
the calculus so that these conditions are relaxed (by allowing a nondeterministictype-refinement rule in the static semantics), but doing so would require additional
proof-normali-ation arguments.Rule [8 ] is the multiagent generali-ation of rule [H4 ]. Both rules allow progress
when we have nested embeddings, and the inner embedding cannot be reduced be-cause the inner agent considers it a value. In the two-agent case, this situation can
occur only when the outer agent is the host. Because we are not concerned withtracking what values the host manipulates, rule [H4 ] strips away both embeddings.
However, in the more symmetric multiagent setting, naively stripping away em-beddings loses information about which agents could have contributed information
about the type of a term.Rule [8 ] says that if there are nested embeddings, \Delta \Theta \Delta \Theta ^

vj\Lambda \Xi uff \Lambda \Xi \Lambda kff\Delta , and the innerembedding, \Delta \Theta ^
vj\Lambda \Xi uff , is a k-value (that is, u ff\Psi  Dom(AEk)), then the two embeddingscan be collapsed into one, \Delta \Theta ^

vj\Lambda \Xi \Lambda ffkff\Delta . Because we append the two lists, we lose noinformation about which agents have participated in the evaluation of the term.

The most interesting rule is [9 ], which is really what tracks the principals. Theembedded function is lifted to the outside. Its argument now belongs to the outer
agent, i, instead of the inside agent, j. As such, it must be given the type that
i thinks the argument should have. The body of the function is still a j-termembedded in an

i-term, so any occurrence of the new formal argument xi must beembedded as an

i-term inside a j-term. The corresponding type annotation mustbe the type that

j expects the argument to have. Hence the function body is stillabstract to
i, and, when the function is applied, the actual argument will be heldabstract from

j. The only remaining issue is the agent list on the formal-argumentembeddings. Because the "inside type" and "outside type" have reversed roles, the

list must be in reverse order. Intuitively, the agents that successively provided thefunction-argument type to

i must undo their workin the body of the function. Theside condition ensuring that the embedding's type is most concrete with respect to

the outer agent preserves the determinism of the semantics and ensures that the

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

14 * Dan Grossman et al.

Assume oeh(fh) = int and fh \Phi \Psi  Dom(oec)

(flyh :int \Lambda  int. yh 3h) pxflxc : fh. xcqyfh\Theta fhc
-7] (flyh :int \Lambda  int. yh 3h) pxflxc : fh. xcqyint\Theta intc
-9] (flyh :int \Lambda  int. yh 3h) (flx\Delta h : int. pxpxx\Delta hqyfhh qyintc )
[5] (flx\Delta h :int. pxpxx\Delta hqyfhh qyintc ) 3h
-5] pxpx3hqyfhh qyintc
-8] px3hqyinthc
-6] 3h

Fig. 11. Multiagent evaluation example.
explicit type for xi is most concrete.
3.5 Example
As an example, we encode our two-agent calculus by letting AEh map fh to int andletting

AEc be undefined everywhere. An evaluation that uses all of the novel rulesappears in Figure 11. The host program invokes a client function defined in terms of

the abstract type fh. (For simplicity, it is just the identity function.) The evaluationtakes place in a host context, enabling the host to apply the function to the value 3
even though the client function expects an argument of type fh. Within the body ofthe client code, however, the host value 3 is wrapped in an embedding and must be
treated abstractly. Even so, the host code is able to recover the value 3 returned bythe client. The numbers in the figure are the reduction rules used to take the step.
Note that under this simple system, rules [7 ] and [9 ] encode what was previously"hard-wired" into rule [H3 ]. Similarly, rules [8 ] and [6 ] do the work of [H4 ].

3.6 Static Semantics
Figure 12 shows the multiagent static semantics. Note that the rules depend on thecolor of the term and the value of the maps

AE1, . . . , AEn. The rules use i to denote thecolor of the term. The values of the maps do not change, so we leave them implicit.

Therefore, the judgment K \Sigma  ei : j should be read as, "Under maps AE1, . . . , AEn incontext K, agent

i can show that ei has type j."
All of the rules except [embed] are essentially standard. The rules [abs] and[fix ] have additional conditions that force an agent to use the most concrete type

available for functions internal to the agent; they are analogous to the side conditionon [Hfn] in the two-agent case. Similarly, the use of _\Delta 

i in the conclusion of [embed]guarantees that an embedded term is viewed by agent

i at the most concrete typepossible. Formally, the convenient invariant we are maintaining is that K \Sigma 

ei : jimplies \Delta 

i(j) = j.The issue of consistency among agents arises during type checking. For instance,

we do not want a principal to export an int as a function. Likewise, we do not wantan agent, or collection of agents, to violate the type abstractions represented by the
AEi maps. Thus, we need to relate the type of the expression inside the embeddingto the type annotation on the embedding.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 15
-const] O \Upsilon  bi : b [var] O \Upsilon  xi : O(xi) [app]

O \Upsilon  ei : \Omega \Delta  \Lambda  \Omega  O \Upsilon  e\Delta i : \Omega \Delta 

O \Upsilon  ei e\Delta i : \Omega 

-abs]

O[xi : \Omega \Delta ] \Upsilon  e\Delta i : \Omega  \Delta i(\Omega \Delta ) = \Omega \Delta 

O \Upsilon  flxi :\Omega \Delta . e\Delta i : \Omega \Delta  \Lambda  \Omega  (xi \Phi \Psi  Dom(O))

[fix]

O[fi : \Omega \Delta  \Lambda  \Omega ][xi : \Omega \Delta ] \Upsilon  e\Delta i : \Omega  \Delta i(\Omega \Delta  \Lambda  \Omega ) = \Omega \Delta  \Lambda  \Omega 

O \Upsilon  fix fi(xi:\Omega \Delta ).e\Delta i : \Omega \Delta  \Lambda  \Omega  (fi, xi \Phi \Psi  Dom(O), fi \Phi = xi)

[embed]

O \Upsilon  ej : \Omega \Delta  \Upsilon  \Omega \Delta  .jfii \Omega 

O \Upsilon  pxejqy\Theta jfi : _\Delta i(\Omega )

Fig. 12. Multiagent static semantics: O \Upsilon  ei : \Omega .

[eq]

_\Delta i(\Omega ) = _\Delta i(\Omega \Delta )

\Upsilon  \Omega  .i \Omega \Delta  -trans] \Upsilon 

\Omega  .fi \Omega \Delta \Delta  \Upsilon  \Omega \Delta \Delta  .fi\Delta  \Omega \Delta \Upsilon 

\Omega  .fifi\Delta  \Omega \Delta 

Fig. 13. Type relations: \Upsilon  \Omega  .fi \Omega \Delta .
We establish an agent-list indexed family of relations on types, j \Pi ff j\Delta . Judg-ments of the form \Sigma 

j \Pi ff j\Delta , showing when two types may be related by the list o/,are given in Figure 13.

3 These rules say that j0 \Pi i1i2...i

m jm if there exist typesj1, . . . , jm\Xi 1 such that agent i

k is able to show that jk\Xi 1 = jk for k \Psi  {1, . . . , m}.Informally, the agents are able to chain together their knowledge of type information

to show that j0 = jm.The [embed] rule uses the \Pi 

jffi relation to ensure that the type inside the embed-ding matches up with the annotation on the embedding. The agent

i is appendedto the list because, as the outermost agent,

i is implicitly involved in evaluation ofthe term.

3.7 Safety Properties
This section illustrates some of the standard safety theorems of typed programminglanguages and then presents an embedding-erasure transformation that commutes

with evaluation.The following standard lemmas help establish type soundness. The proofs are
straightforward.

Lemma 3.2 (Canonical Forms). Assuming \Pi  \Sigma  vi : j,
-- if j = b, then vi = bi for some b.
-- if j = j\Delta  \Theta  j\Delta \Delta , then vi = \Pi xi :j\Delta . e\Delta i for some xi and e\Delta i.
-- if j = t, then t ff\Psi  Dom(AEi) and vi = \Delta \Theta ^vj\Lambda \Xi tjff for some ^vj and o/.

3We give a nondeterministic rule for -trans] because we are not concerned with an algorithmic
presentation of type checking. This formulation lets us slightly simplify the proofs of the Type-
Relations Properties, but is not essential to their correctness.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

16 * Dan Grossman et al.

Lemma 3.3 (Substitution). Suppose K[xj : j\Delta ] \Sigma  ei : j and K \Sigma  ej : j\Delta . ThenK \Sigma  {

ej/xj}ei : j.

We also need several properties about the \Pi  relations.
Lemma 3.4 (Type-Relation Properties).
Idempotence: \Sigma  j \Pi ffiiff\Delta  j\Delta  if and only if \Sigma  j \Pi ffiff\Delta  j\Delta .
Reversal: If \Sigma  j \Pi ff j\Delta , then \Sigma  j\Delta  \Pi rev(ff) j.
Arrow: If \Sigma  j1 \Theta  j2 \Pi ff j3 \Theta  j4, then \Sigma  j1 \Pi ff j3 and \Sigma  j2 \Pi ff j4.

Proofs of the first two properties are simple arguments by induction on the deriva-tion of the type relation. Our proof of the last property requires a tedious normal-

i-ation argument showing that if \Sigma  j1 \Theta  j2 \Pi ff j3 \Theta  j4, then there is a derivationthat relates only types whose top-level constructors are arrows. We give a brief
sketch of the argument: the proof is by induction on the length of the list o/. Thebase case, when

o/ is of length one, follows from the compatibility of the AEi relations.The inductive case is straightforward if the types in the chain are all arrows, so

we suppose that in a chain of types showing \Sigma  j1 \Theta  j2 \Pi ff j3 \Theta  j4 the first typevariable encountered is

t. Then the type before t must be some j5 \Theta  j6. Aftersome number of type variables in the chain, we must again have some arrow type.

From the consistency conditions on the AEi maps, this next arrow type must be
j5 \Theta  j6. Hence we did not need the occurrence of t in the chain, and can simplyreplace it with

j5 \Theta  j6. In other words, any occurrences of type variables provideno additional information, so we can remove them, reducing the problem to a chain

consisting only of arrow types.We now have the results we need to prove the two main lemmas.

Lemma 3.5 (Preservation). If \Pi  \Sigma  ei : j and ei \Upsilon \Phi \Theta  e\Delta i, then \Pi  \Sigma  e\Delta i : j.
Proof. By induction on the derivation that ei \Upsilon \Phi \Theta  e\Delta i. We proceed by cases onthe last step of the derivation. Cases [1 ], [2 ], and [3 ] follow from induction. Cases

[4 ] and [5 ] follow immediately from the Substitution Lemma. Case [6 ] is trivial toprove. We consider the remaining cases individually:

[7 ] We have a typing derivation as follows:

\Pi  \Sigma  ^vj : j\Delta \Delta  \Sigma  j\Delta \Delta  \Pi jffi j\Delta \Pi  \Sigma 

\Delta \Theta ^vj\Lambda \Xi \Lambda \Delta jff : _\Delta i(j\Delta )

Because _\Delta i(j\Delta ) equals _\Delta i( _\Delta i(j\Delta )), by [eq] we have that \Sigma  j\Delta  \Pi i _\Delta i(j\Delta ). Thusby [trans] we have that \Sigma 

j\Delta \Delta  \Pi jffii _\Delta i(j\Delta ), and we can remove the second i byIdempotence. We can now derive:

\Pi  \Sigma  ^vj : j\Delta \Delta  \Sigma  j\Delta \Delta  \Pi jffi _\Delta i(j\Delta )

\Pi  \Sigma  \Delta \Theta ^vj\Lambda \Xi  _\Delta i(\Lambda \Delta )jff : _\Delta i(j\Delta )

The conclusion is the desired result.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 17
[8 ] We have a typing derivation as follows:

\Pi  \Sigma  ^vj : j\Delta \Delta  \Sigma  j\Delta \Delta  \Pi jffk u\Pi  \Sigma 

\Delta \Theta ^vj\Lambda \Xi ujff : _\Delta k(u) \Sigma  _\Delta k(u) \Pi kff\Delta i j\Delta 

\Pi  \Sigma  \Delta \Theta \Delta \Theta ^vj\Lambda \Xi ujff\Lambda \Xi \Lambda \Delta kff\Delta  : _\Delta i(j\Delta )
The fact that the inner embedding is labeled with a list starting with j followsfrom the Canonical Forms Lemma. Furthermore,

u ff\Psi  \Delta k, so _\Delta k(u) = u. Thusby [trans] and the premises, we have \Sigma 
j\Delta \Delta  \Pi jffkkff\Delta i j\Delta . So Idempotence proves that\Sigma 
j\Delta \Delta  \Pi jffkff\Delta i j\Delta . We can now derive:

\Pi  \Sigma  ^vj : j\Delta \Delta  \Sigma  j\Delta \Delta  \Pi jffkff\Delta i j\Delta \Pi  \Sigma 

\Delta \Theta ^vj\Lambda \Xi \Lambda \Delta jffkff\Delta  : _\Delta i(j\Delta )

The conclusion is the desired result.

[9 ] We have a typing derivation as follows:

[xj : j0] \Sigma  ej : j3 \Delta j(j0) = j0\Pi  \Sigma 

\Pi xj : j0. ej : j0 \Theta  j3 \Sigma  j0 \Theta  j3 \Pi jffi j1 \Theta  j2\Pi  \Sigma 

\Delta \Theta \Pi xj : j0. ej\Lambda \Xi \Lambda 

1\Lambda \Lambda 2

jff : _\Delta i(j1 \Theta  j2)

Furthermore, the concreteness side condition on rule [9 ] implies that \Delta i(j1 \Theta 
j2) = j1 \Theta  j2. So by the definition of \Delta i, we know that \Delta i(j1) = j1 and\Delta 

i(j2) = j2. From the Arrow Lemma and the right-hand premise of the bottomstep, we conclude that \Sigma 

j0 \Pi jffi j1 and \Sigma  j3 \Pi jffi j2. The reverse of jo/i is irev(o/)j,so by the Reversal Lemma, \Sigma 

j1 \Pi irev(ff)j j0. Thus we can derive:

[xi : j1] \Sigma  xi : j1 \Sigma  j1 \Pi irev(ff)j j0

[xi : j1] \Sigma  \Delta \Theta xi\Lambda \Xi \Lambda 

0

irev(ff) : _\Delta j(j0)

Because the original derivation provides \Delta j(j0) = j0, we conclude [xi : j1] \Sigma \Delta \Theta 

xi\Lambda \Xi \Lambda 

0

irev(ff) : j0. It also provides [xj : j0] \Sigma  ej : j3. Because xi is fresh, wemay weaken this claim to [

xi : j1][xj : j0] \Sigma  ej : j3. Hence by Substitution,

[xi : j1] \Sigma  {\Delta \Theta xi\Lambda \Xi \Lambda 

0

irev(ff)/xj}ej : j3. So we can derive:

[xi : j1] \Sigma  {\Delta \Theta xi\Lambda \Xi \Lambda 

0

irev(ff)/xj}ej : j3 \Sigma  j3 \Pi jffi j2

[xi : j1] \Sigma  \Delta \Theta {\Delta \Theta xi\Lambda \Xi \Lambda 

0

irev(ff)/xj}ej\Lambda \Xi \Lambda 

2
jff : _\Delta i(j2) \Delta i(j1) = j1\Pi  \Sigma 

\Pi xi :j1. \Delta \Theta {\Delta \Theta xi\Lambda \Xi \Lambda 

0

irev(ff)/xj}ej\Lambda \Xi \Lambda 

2
jff : j1 \Theta  _\Delta i(j2)

Because _\Delta i(j2) = j2, the conclusion is the desired result.

Lemma 3.6 (Progress). If e is well-typed, then either e is a value or thereexists an

e\Delta  such that e \Upsilon \Phi \Theta  e\Delta .

Proof Sketch. The proof is a straightforward inductive argument on the struc-ture of

e. The interesting case is when e = ei = \Delta \Theta vj\Lambda \Xi \Lambda ff . If \Delta i(j) ff= j, then rule [7 ]applies. Else, if

vj is an embedding, then rule [8 ] applies. Otherwise, we proceed

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

18 * Dan Grossman et al.

erase(xi) = x

erase(bi) = b
erase(flxi :\Omega . ei) = flx: _\Phi (\Omega ). erase(ei)
erase(fix fi(xi:\Omega ).ei) = fix f(x: _\Phi (\Omega )).erase(ei)

erase(ei e\Delta i) = erase(ei) erase(e\Delta i)
erase(pxejqy\Theta fi ) = erase(ej)

where \Phi  = Si \Delta i

Fig. 14. Multiagent erase translation.
by cases on the form of j. If j = b, rule [6 ] applies. If j = j\Delta  \Theta  j\Delta \Delta , rule [9 ] applies.Else

ei is a value.

Given the previous two lemmas, we conclude type safety:
Theorem 3.7 (Type Safety). If \Pi  \Sigma  e : j, then there is no stuck e\Delta  such that
e \Upsilon \Phi \Theta * e\Delta .

The cost of including embeddings is the addition of several dynamic rules. Worseyet, with recursion and multiple agents, the lists annotating embeddings might

grow arbitrarily large. The erasure property stated below essentially shows thatthese syntactic tricks are only a proof technique.

For erasure to a typed language, it is necessary to combine the type informationof all the agents. The multiagent definition of

erase is given in Figure 14, wherewe recall that \Phi  is the map obtained by taking the union of the compatible \Delta 

imaps. _\Phi (
j) is the most concrete type for j that can be found using all n agents'knowledge.

The target language has one agent and no embeddings.
Lemma 3.8 (Erasure). If ei is well-typed then either both ei and erase(ei)diverge or

ei \Upsilon \Phi \Theta * vi and erase(ei) \Upsilon \Phi \Theta * erase(vi).

Proof Sketch. By induction on the number of steps in the source deriva-tion. For one step, show that if

ei \Upsilon \Phi \Theta  e\Delta i, then either erase(ei) = erase(e\Delta i) or
erase(ei) \Upsilon \Phi \Theta  erase(e\Delta i). That is, the erased version takes either -ero steps (if thesource step uses one of rules [6 ] through [9 ]) or one step (if the source step uses

rule [4 ] or [5 ]). For divergence, show the contrapositive--any term erasing to anondiverging term is nondiverging. The essence of the argument is that the source
derivation can take only a finite number of steps before using rules [4 ] or [5 ].
3.8 Type-Abstraction Properties
In this section, we use subject-reduction arguments to prove type-abstraction prop-erties that generali-e those of the two-agent case.

Definition 3.9. Let Agents(ei) be the set of colors appearing in ei. (The setnecessarily includes

i as well as any agents appearing in lists annotating embeddingsubterms of
ei.)

Definition 3.10. A set of agents, S, is oblivious to type t if for all i \Psi  S, t ff\Psi Dom(

AEi).

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 19
Theorem 3.11 (Independence of Evaluation). Let ei be a term such thatAgents(

ei) are oblivious to t and \Pi  \Sigma  \Pi xi :t. ei : t \Theta  b. Let ^vj and ^v\Delta j be closed,
well-typed terms with type _\Delta j (t). Then (\Pi xi : t. ei) \Delta \Theta ^vj\Lambda \Xi tj \Upsilon \Phi \Theta * bi if and only if(

\Pi xi :t. ei) \Delta \Theta ^v\Delta j\Lambda \Xi tj \Upsilon \Phi \Theta * bi.

First note that ^vj and ^v\Delta j are primitive values. Hence \Delta \Theta ^vj\Lambda \Xi tj and \Delta \Theta ^v\Delta j\Lambda \Xi tj are values.Also, we know

j ff\Psi  Agents(ei): because ^vj is a constant or a function and \Delta \Theta ^vj\Lambda \Xi tjis well-typed, [embed ] ensures that

t \Psi  Dom(AEj). Agents(ei) are oblivious to t, so
j ff\Psi  Agents(ei).The proof of the theorem strengthens the claim to a step-by-step evaluation

correspondence when using ^vj and ^v\Delta j. We give the intuition before presentingthe formal lemma: we maintain that the intermediate terms in the two evaluation
sequences are always exactly the same except that every occurrence of ^vj in one isreplaced with ^

v\Delta j in the other. To ensure this correspondence, we show that everyoccurrence of ^
vj is safely within an embedding with a type that agents other than
j can relate to t. These agents are oblivious to t, so the embedding's type must beat least as abstract as

t. We also maintain that there are no j-terms other than theones we are abstracting and that

j appears nowhere in an embedding list exceptas the first element. These conditions suffice to argue that

j never helps the otheragents breakthe type abstraction.

More specifically, properties (1) and (2) of ! (defined in the lemma) suffice toshow that Agents(

ei) \ {j} cannot distinguish values of type t without the help ofagent
j; properties (3), (4), and (5) suffice to show that j does not provide suchhelp.

Lemma 3.12 (Value Abstraction). Let ^vj and ^v\Delta j have type _\Delta j(t). Let !(ei)mean:
(1 ) [xj : _\Delta j(t)] \Sigma  ei : j for some j.
(2 ) Agents(ei) \ {j} are oblivious to t.
(3 ) The only j-term in ei is xj. (It may appear zero, one, or more times.)
(4 ) If \Delta \Theta xj\Lambda \Xi \Lambda jff is a k-term in ei, then \Sigma  t \Pi ffk j.
(5 ) j never appears in an embedding list within ei except as the first element.

Then if !(ei) and {^vj/xj}ei \Upsilon \Phi \Theta  e1i , then there exists an e2i such that:
(a) !(e2i )
(b) {^vj/xj}e2i =i e1i
(c) {^v\Delta j/xj}ei \Upsilon \Phi \Theta  {^v\Delta j/xj}e2i

Proof Sketch. By induction on the derivation of {^vj/xj}ei \Upsilon \Phi \Theta  e1i , proceedingby cases on the last rule used in the derivation.

Rules [1 ], [2 ], and [3 ] essentially follow from induction and the definition ofsubstitution. Note that for [3 ], the embedded term is not a

j-term because theonly
j-term, ^vj, is a value.Rules [4 ] and [5 ] follow from the definition of substitution and the fact that the

variable for which we substitute a term must be distinct from xj because the termand

xj are different colors. Furthermore, ^vj is closed, so the substitution has noeffect on it.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

20 * Dan Grossman et al.

Rule [6 ] is trivial except that we must prove the term inside the embedding isnot ^

vj (otherwise e1i = ^vi, so property (c) will not hold). Assume for contradictionthe term inside is ^

vj. Then by property (3), before the substitution this term was
xj. Then by properties (4) and (5), a j-free list of agents, o/, can show \Sigma  t \Pi ff b. Asimple proof by induction on the rules for \Pi 

ff shows that this conclusion contradictsproperty (2).

Rules [7 ] and [8 ] are straightforward to verify. Note that in [8 ] the outer agentlist cannot contain

j because of properties (3) and (5).Rule [9 ] requires an analogous argument to the one we used in [6 ] to show that

the term inside the embedding cannot be xj. Hence the agent list on the embeddingdoes not contain

j, so property (5) is preserved even though the agent list is reversed.The substitution in the body of the function is unproblematic because ^

vj is closedand therefore unaffected.

This lemma suffices to prove Independence of Evaluation because, given the as-sumptions of the theorem,

!((\Pi xi : t. ei) \Delta \Theta xj\Lambda \Xi tj). By induction on the length of theevaluation, property (b) holds for

bi, where bi is the result of the evaluation with ^vj.This implies that the same
bi must be the result of the evaluation with ^v\Delta j becausethe two results are alpha equivalent.

The generali-ation of Theorem 2.9 is the following theorem. It effectively saysthat a client containing a value of abstract type

fh must have obtained that valuevia a host-provided function.

Theorem 3.13 (Host-Provided Values). Suppose prog is a closed and welltyped term of the form (\Pi openi : b \Theta  fh. client)\Delta \Theta \Pi xh : b. ho\Lambda \Xi b\Lambda fhh . Further sup-pose Agents(

client) are oblivious to fh, h knows fh, ho is embedding-free, and
prog \Upsilon \Phi \Theta * ei. Then any subterm of ei that is a closed value of type fh has the form\Delta \Theta 

^vh\Lambda \Xi fhhff, and there exists an eh such that {eh/xh}ho \Upsilon \Phi \Theta * ^vh and erase(eh) = b forsome base value

b.

Note that it is not necessarily the case that {bh/xh}ho \Upsilon \Phi \Theta * ^vh because _\Delta h(fh)could be a function type and because the dynamic semantics does not evaluate
under functions. Also note that we make no restrictions on the agents in clientand their type abstractions except that none of them know the implementation of
fh. For example, one agent could export fh more abstractly to another agent.

The proof consists of an intricate subject-reduction argument, so we first presentthe general idea. Intuitively, the only

h terms are ho and the result of applying ho toan argument. Because only
h knows fh, all values of type fh come from applying ho.The main complication is tracking all the functions that are essentially

\Pi xh : b. hoexcept that they differ in color and embeddings: The first step of
prog uses [9 ] to

convert \Delta \Theta \Pi xh : b. ho\Lambda \Xi b\Lambda fhh to \Pi xi : b. \Delta \Theta {\Delta \Theta xi\Lambda \Xi bi /xh}ho\Lambda \Xi fhh , so we must consider thelatter term a legitimate producer of file handles. Agent

i could pass this term toanother agent using [9 ] again, and that result must also be legitimate.

Due to these complications, we carefully state a property that evaluation of awell-typed term preserves: Figure 15 presents two relations,

!(e) and "(e), whereas usual, we mean the least relations closed under the appropriate inference rules.

In the rules, we assume the color of e does not know fh; we use colors j and k to
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 21
[A] OE(b) [B] OE(x)
[C ]

OE(e) OE(e\Delta )

OE(e e\Delta ) [D]

OE(e)
OE(flx:\Omega . e) [E]

OE(e)
OE(fix f(x:\Omega ).e) [F]

OE(e) h \Phi \Psi  ,

OE(pxeqy\Theta fi )

[G] {

eh/xh}ho \Xi \Pi \Lambda * e\Delta h erase(eh) = b \Omega  \Upsilon  eh : b \Upsilon  fh .fi\Delta  \Omega  h \Phi \Psi  ,,\Delta 

OE(pxe\Delta hqy\Theta hfi)

[H ]

O/(e)

OE(e) [I ] O/(flxj : b. px{pxxjqybj /xh}hoqyfhh )

[J]

O/(flyk : \Omega 1. pxeqy\Theta 2fi ) \Upsilon  \Omega 3 .jrev(fi\Delta ) \Omega 1 h \Phi \Psi  ,\Delta 

O/(flxj : \Omega 3. pxpx{pxxjqy\Theta 1jrev(fi\Delta )/yk}eqy\Theta 2fi qy\Theta 4kfi\Delta )

[K ] O/(pxflxh :b. hoqyb\Theta fhh )
Fig. 15. Host-Provided Values preservation property.
range over any such color. We implicitly assume the context of the Host-ProvidedValues Theorem, so

\Pi xh : b. ho is closed, well-typed, and embedding-free.Rules [A] through [F ] are just structural rules; we use them to "find the important

terms," namely the functions that are essentially \Pi xh : b. ho and the results ofapplying such functions. No other

h-terms are allowed.Rule [G] accepts terms that are the (intermediate) results of applying such func-

tions. Because such functions differ from ho in terms of embeddings, [G] does notrequire that

e = \Delta \Theta e\Delta h\Lambda \Xi \Lambda hl where there exists a vh such that {vh/xh}ho \Upsilon \Phi \Theta * e\Delta h.Rather,
vh may be a nonvalue eh so long as its erasure is a value.Rule [H ] accepts the terms that are essentially

\Pi xh : b. ho by using the auxiliaryrelation
". Rule [I ] accepts the function we have after one step of prog. For eachtime that the function is passed to another agent via rule [9 ], we use the rule [J ]

to conclude that the resulting function is still acceptable. We include rule [K ] sothat

!(prog) holds. It is easy to show that "(e) implies e is closed and well-typed.It is straightforward to prove that if

!(e) is preserved under evaluation then theHost-Provided Values Theorem is true: first verify that

!(prog). Therefore, !(ei)for any
ei such that prog \Upsilon \Phi \Theta * ei. A simple induction on the derivation of !(ei),appealing to the canonical forms of values as necessary, suffices to prove that for

any subterm v that is a closed value of type fh, it must be that !(v). Rule [G]is necessary to derive

!(v), and the antecedents of this rule are strong enough toprove the theorem. (A separate inductive argument shows that if

"(e), then nosubterm of
e is a closed value of type fh.)

We now proceed with the rigorous proof that ! is preserved. As usual, thesubject-reduction argument relies on a substitution lemma that we prove before

presenting the main lemma.

Lemma 3.14 (Host-Provided Substitution). If !(e), !(e\Delta ) and color(e\Delta ) =
color(x), then !({e\Delta /x}e).

Proof. The proof is by induction on the derivation of !(e), proceeding by cases

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

22 * Dan Grossman et al.
on the last rule in the derivation. Cases [A] and [B] are trivial. Cases [C ], [D ],[E ], [F ] follow from straightforward inductive arguments. Case [G] follows because
{eh/xh}ho is closed and evaluation preserves this property. Case [H ] follows because
"(e) implies that e is closed (as shown by induction on the derivation of "(e)).

Lemma 3.15 (Host-Provided Preservation). If !(e), \Pi  \Sigma  e : j, and e \Upsilon \Phi \Theta 
e\Delta , then !(e\Delta ).

Proof. The proof is by induction on the derivation of e \Upsilon \Phi \Theta  e\Delta , proceeding bycases on the last rule in the derivation.

[1 ] Follows from the induction hypothesis and [C ].
[2 ] Follows from the induction hypothesis and [C ].
[3 ] The derivation of !(e) ends with [F ] or [G]. (Note that [H ] is impossiblebecause

"(e) holds only for values or embeddings of values, which do not fit theconditions of [3 ].) If [F ], then the result follows from the induction hypothesis

and [F ]. If [G], then we know e = \Delta \Theta e\Delta h\Lambda \Xi \Lambda hff and {eh/xh}ho \Upsilon \Phi \Theta n e\Delta h for some n andappropriate

eh. Therefore, we know that {eh/xh}ho \Upsilon \Phi \Theta n+1 e\Delta \Delta h and e\Delta  = \Delta \Theta e\Delta \Delta h\Lambda \Xi \Lambda hff.So we can use [G] to derive

!(e\Delta ).

[4 ] Follows from the induction hypothesis, [E ], Host-Provided Substitution, and[D].

[5 ] Then e = (\Pi xj : j\Delta . e\Delta \Delta ) vj, vj has type j\Delta , and the derivation ends with [C ].Therefore,

!(vj ) and !(\Pi xj : j\Delta . e\Delta \Delta ); the derivation of the latter ends in [D] or[H ]. If [D], then the result follows from the induction hypothesis, [D], and Host-

Provided Substitution. If [H ], then "(\Pi xj : j\Delta . e\Delta \Delta ), the derivation ending in [I ] or
[J ]. Therefore, e\Delta \Delta  has the form \Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff . It suffices to show that !({vj/xj}\Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff ).
To prove this fact, we prove that "(\Pi xj : j\Delta . \Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff ), !(vj), and vj has type j\Delta implies two stronger facts:

--erase(vj) = b for some b--For any

ej of type j\Delta , if there is a b such that !(ej) and erase(ej) = b, then
!({ej/xj}\Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff ).

It is clear that this strengthened claim suffices. We prove it by induction on thederivation of

"(\Pi x :j\Delta . \Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff ), proceeding by cases on the last rule used.
For case [I ], j\Delta  = b, so the first fact follows from the Canonical Forms Lemma and

the well-typedness of e. For the second fact, {ej/xj}\Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff = \Delta \Theta {\Delta \Theta ej\Lambda \Xi bj /xh}ho\Lambda \Xi fhh .

So [G] applies by letting eh = \Delta \Theta ej\Lambda \Xi bj and e\Delta h = {eh/xh}ho.

For case [J ], we have \Pi xj : j\Delta . \Delta \Theta e\Delta \Delta \Delta \Lambda \Xi \Lambda \Delta \Delta ff = \Pi xj : j3. \Delta \Theta \Delta \Theta {\Delta \Theta xj\Lambda \Xi \Lambda 

1

jrev(ff\Delta )/yk}e1\Lambda \Xi \Lambda 

2
ff \Lambda \Xi \Lambda 

4
jff\Delta .

Furthermore, we have from the derivation that "(\Pi yk : j1. \Delta \Theta e1\Lambda \Xi \Lambda 

2

ff ) and \Sigma  j3 \Pi jrev(ff\Delta )j1. From the induction hypothesis, we conclude that if some v

k has type j1 and
!(vk), then erase(vk) = b for some b. Because \Sigma  j3 \Pi jrev(ff\Delta ) j1, we can use theCanonical Forms Lemma to conclude that if

vj has type j3, then erase(vj) = b,which is our first obligation. From the induction hypothesis, we know that for any

ek of type j1 such that !(ek) and erase(ek) = b, we k now!({ek/yk}\Delta \Theta e1\Lambda \Xi \Lambda 

2

ff ). So forarbitrary

ej such that !(ej) and erase(ej) = b, we let ek = \Delta \Theta ej\Lambda \Xi \Lambda 

1

jrev(ff\Delta ) to conclude

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 23
that !({\Delta \Theta ej\Lambda \Xi \Lambda 

1

jrev(ff\Delta )/yk}\Delta \Theta e1\Lambda \Xi \Lambda 

2
ff ). Therefore, from the definition of substitution, we

have !(\Delta \Theta {ej/xj}{\Delta \Theta xj\Lambda \Xi \Lambda 

1

jrev(ff\Delta )/yk}e1\Lambda \Xi \Lambda 

2
ff ). Finally, because h ff\Psi  o/\Delta , we can use rule [F ]

and the definition of substitution to derive !({ej/xj}\Delta \Theta \Delta \Theta {\Delta \Theta xj\Lambda \Xi \Lambda 

1

jrev(ff\Delta )/yk}e1\Lambda \Xi \Lambda 

2
ff \Lambda \Xi \Lambda 

4
jff\Delta ,which is our second obligation.

[6 ] Immediate because !(b).
[7 ] Then the derivation of !(e) ends with [F ] or [G]. (Note that [H ] is impossiblebecause that derivation would have to end with [K ], but no nonhost agent can refine

b \Theta  fh.) For either [F ] or [G], inspection of the antecedents reveals that the samerule applies after the step.

[8 ] Then each of the last two steps of the derivation of !(e) are [F ] or [G]. (Notethat [H ] is impossible because [K ] is not a nested embedding and

b \Theta  fh is not atype variable.) If both are [F ], then the induction hypothesis and one use of [F ] let

us conclude !(e\Delta ). If the last step is [F ] and the second-to-last step is [G], then theinduction hypothesis and one use of [G] let us conclude

!(e\Delta ). Note that the well-typedness of
e suffices to satisfy the requirement that the type on the annotationbe more abstract than

fh. The remaining cases have [G] as the last step; we showby contradiction this situation is impossible. Suppose the derivation of

!(e) endsin [G]. Then the
e\Delta h in the consequent of the rule is an h-value of the form \Delta \Theta ^vj\Lambda \Xi uffand
u ff\Psi  AEh. But ho is embedding-free and \Pi  \Sigma  eh : b, so it is easy to show that{
eh/xh}ho cannot evaluate to a value that is an embedding.

[9 ] Then the derivation of !(e) ends in [H ] or [F ]. (Note that [G] is impossiblebecause Agents(

client) are oblivious to fh, so j must be at least as abstract as

fh.) If the derivation ends in [H ], we know e = \Delta \Theta \Pi xh : b. ho\Lambda \Xi b\Lambda fhh and therefore
e\Delta  = \Pi xi : b. \Delta \Theta {\Delta \Theta xi\Lambda \Xi bi /xh}ho\Lambda \Xi fhh , so [I ] lets us conclude !(e\Delta ). If the derivationends with [F ], we know the second-to-last step is [D] or [H ]. If [D], then the

result follows from Host-Provided Substitution, [F ], and [D]. If [H ], then we know
"(\Pi y : j1. \Delta \Theta e\Delta \Delta \Lambda \Xi \Lambda 

2

ff\Delta  ) where e = \Delta \Theta \Pi y : j1. \Delta \Theta e\Delta \Delta \Lambda \Xi \Lambda 

2
ff\Delta  \Lambda \Xi \Lambda 

3\Lambda \Lambda 4
ff . (Either [I ] or [J ] could be thelast rule used to derive this result; e has this form in both cases.) Therefore, we

can use [J ] and [H ] to derive !(e\Delta ). Note that the well-typedness of e and the factthat

h ff\Psi  o/ suffice to satisfy the antecedents of [J ].

It is worth considering how we could generali-e this proof and proof technique.Generali-ing the means by which clients obtain file handles is straightforward. The
function ho is just an example of a constructor; it is an expression that is exportedat a type in which

fh appears in a positive position. By tracking these constructors,we can show that all abstract values originate from them. More generally, using

syntax and subject reduction to trackthe flow of values requires that we can always"find" the interesting terms, which is the purpose of rules [A] through [F ]. Rule [G]
describes the property of interest (in this case that the term came from an invocationof the host implementation of open). The auxiliary predicate

" describes how thehost term can appear after being exported to any number of agents--embeddings

can pile up, but only in a uniform way which does not change the underlying code,only the interface at which the code is available.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

24 * Dan Grossman et al.
4. REFERENCES AND STATE
In this section, we augment the program states of the preceding development witha mutable store and appropriate expressions for manipulating the store. The goal

is to extend our type-abstraction results to a stateful setting without being undulyrestrictive.

The next section is a brief overview of our formali-ation of state, ignoring is-sues regarding agents and type abstraction. The point is simply to establish basic
notation for the discussion that follows. Our workfollows closely the standardtreatment of references in a subject-reduction setting, e.g., see the workof Wright
and Felleisen [1994] or Harper [1994]. We then give an informal description of theissues that make the store a particularly interesting addition to our framework.
Then we formally augment our calculus with state and discuss the reasons for par-ticular design decisions. Finally, we augment the proofs of type soundness and
safety properties appropriately.
4.1 Notation
Ignoring types and agents, a store, M , is a partial map from labels to values. Thecollection of labels is an infinite set; we use

l to range over its members. A programstate is a pair of a store and a closed expression, and the dynamic semantics operates

on program states. Three new expression forms allow a program to manipulate thestore. Reference creation,

ref v, evaluates to a fresh label, l, and extends the storeto map
l to v. Dereference, !l evaluates to M (l) where M is the current store.Update,

l := v, evaluates to v and changes the current store to map l to v.So that we may give appropriate types to labels, we add a unary type constructor

ref. Under store M , the values of type ref j are those l such that M (l) has type j.The static semantics ensures that well-formed program states refer only to labels
defined in the store. This restriction applies to the store itself, not just to the closedexpression. Hence, stores and expressions are well-formed relative what labels are
in the store and what types these labels have. Store types, ranged over by \Psi ,formali-e these assumptions as a partial map from labels to types.

Figure 16 summari-es the preceding considerations by presenting the syntax andsemantics for a lambda calculus with state. Note that the rule for store well-
formedness permits the store to contain cycles.
4.2 Problems with State
Although the semantics associated with our stateful calculus is well understood,discussing type abstraction between principals in such a setting is considerably

more complicated. Here we present examples of the difficulties.The first difficulty is that the expressions that a program may use in its eval-
uation are not syntactically captured by the subterms of an expression. That is,we previously described some client expression,

C, as host-free, but now we mustaccount for
C obtaining host code from the store. For example, in the expression(!
l \Delta \Theta v\Lambda \Xi th), whether or not the evaluation is independent of the value of v dependson the value of

M (l) where M is the current store. An obvious solution is to define"host-free" over the entire program state (

M, C), but this solution is unnecessarilyrestrictive. Instead, our safety theorems use a notion of expressions reachable from

C in (M, C).
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 25
Syntax

\Omega  ::= b | \Omega  \Lambda  \Omega \Delta  | ref \Omega 

e ::= v | x | e e\Delta  | fix f(x:\Omega ).e | ref e | e := e\Delta  | !e
v ::= b | l | flx:\Omega . e

Dynamic Semantics

(M , e1) \Xi \Pi \Lambda  (M\Delta , e\Delta 1)
(M , e1 e2) \Xi \Pi \Lambda  (M\Delta , e\Delta 1 e2)

(M , e2) \Xi \Pi \Lambda  (M\Delta , e\Delta 2)
(M , v1 e2) \Xi \Pi \Lambda  (M\Delta , v1 e\Delta 2)

(M , e1) \Xi \Pi \Lambda  (M\Delta , e\Delta 1)
(M , e1 := e2) \Xi \Pi \Lambda  (M\Delta , e\Delta 1 := e2)

(M , e2) \Xi \Pi \Lambda  (M\Delta , e\Delta 2)
(M , v1 := e2) \Xi \Pi \Lambda  (M\Delta , v1 := e\Delta 2)

(M , e) \Xi \Pi \Lambda  (M\Delta , e\Delta )
(M, !e) \Xi \Pi \Lambda  (M\Delta , !e\Delta )

(M , e) \Xi \Pi \Lambda  (M\Delta , e\Delta )
(M, ref e) \Xi \Pi \Lambda  (M\Delta , ref e\Delta )

(M, (flx: \Omega . e) v) \Xi \Pi \Lambda  (M, {v/x}e) (M, !l) \Xi \Pi \Lambda  (M , M(l))
(M, ref v) \Xi \Pi \Lambda  (M-l \Xi \Lambda  v], l) l fresh (M , l := v) \Xi \Pi \Lambda  (M-l \Xi \Lambda  v], v)

(M, fix f(x:\Omega ).e) \Xi \Pi \Lambda  (M , flx:\Omega . {fix f(x:\Omega ).e/f}e)
Static Semantics\Upsilon 

M : \Psi  \Psi ; \Omega  \Upsilon  e : \Omega \Upsilon 

(M , e) : \Omega 

Dom(M) = Dom(\Psi ) ffl \Psi  Dom(M). \Psi ; \Omega  \Upsilon  M(l) : \Psi (l)\Upsilon 

M : \Psi 

\Psi ; O \Upsilon  x : O(x) \Psi ; O \Upsilon  b : b \Psi ; O \Upsilon  l : ref \Psi (l)
\Psi ; O \Upsilon  e : \Omega \Delta  \Lambda  \Omega  \Psi ; O \Upsilon  e\Delta  : \Omega \Delta 

\Psi ; O \Upsilon  e e\Delta  : \Omega 

\Psi ; O[x : \Omega \Delta ] \Upsilon  e : \Omega 
\Psi ; O \Upsilon  flx: \Omega \Delta . e : \Omega \Delta  \Lambda  \Omega  x \Phi \Psi  Dom(O)

\Psi ; O[f : \Omega \Delta  \Lambda  \Omega ][x : \Omega \Delta ] \Upsilon  e : \Omega 

\Psi ; O \Upsilon  fix f(x:\Omega \Delta ).e : \Omega \Delta  \Lambda  \Omega  f, x \Phi \Psi  Dom(O), f \Phi = x

\Psi ; O \Upsilon  e : ref \Omega 

\Psi ; O \Upsilon ! e : \Omega 

\Psi ; O \Upsilon  e : ref \Omega  \Psi ; O \Upsilon  e\Delta  : \Omega 

\Psi ; O \Upsilon  e := e\Delta  : \Omega 

\Psi ; O \Upsilon  e : \Omega 
\Psi ; O \Upsilon  ref e : ref \Omega 

Fig. 16. Lambda calculus with state.

The second difficulty is that the store provides a new medium for interagentcommunication. For example, the client could assign to a shared reference that the
host then dereferences. Suppose that l is a shared reference and that the programevaluates the client program state (

M, l := \Delta \Theta v\Lambda \Xi th). If we interpret this program
to mean that M (l) is now \Delta \Theta v\Lambda \Xi th, then, from the host's perspective, the store now
contains a client term. If we mean M (l) is now \Delta \Theta \Delta \Theta v\Lambda \Xi th\Lambda \Xi \Lambda hc , then the store nowcontains a nonvalue. The dual case is also a potential problem: if the host assigns

v of type jh to l and then the client dereferences l, the result must be a clientexpression that preserves the type abstraction.

In general, when a reference is assigned, we do not know which agents will deref-erence the value. Despite this lackof knowledge, the semantics must create the

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

26 * Dan Grossman et al.
correct embeddings to allow a syntactic account of type abstraction. Fortunately,because all expressions are colored, we do know which agent last assigned to a
reference.The third difficulty is that the host should not provide the client the same refer-
ence as a ref t and a ref jh. Using a let notation as syntactic sugar for functionapplication, an expression that violates this requirement could have the form

let rh = ref v
let client = \Delta \Theta \Pi xc :ref t. \Pi yc : ref jh. e\Lambda \Xi ref \Lambda h\Lambda ref \Lambda h\Lambda \Lambda c
client rh rh

To see the problem, consider what the values of !xc and !yc should be in thebody of the client function,

e, after the application client rh rh. An answer thatpreserves the types of the expressions is !

xc = \Delta \Theta v\Lambda \Xi th and !yc = \Delta \Theta v\Lambda \Xi \Lambda hh respectively,but this answer requires that the dynamic semantics depends on the types of

xcand
yc. This dependence is undesirable in the substitution-based semantics we use.This approach is even less sensible if we consider a code fragment within

e such as:

let = yc := (v\Delta  : jh)!

xc

Because the agent knows jh, it can construct a value v\Delta  of this type and assignit to the shared reference. The ensuing dereference cannot preserve the type of !

xcunless it is something like \Delta \Theta 
v\Delta \Lambda \Xi th, but v\Delta  is not a host-provided term.
Even if we could somehow resolve the subject-reduction issues exemplified above,the resulting system can still breaktype abstraction. The example we give below is

well-known in the context of the ML programming language; the same device worksin that setting [Pierce and Sangiorgi 1999]. If the client term

e can determine thatvalues of types
ref t and ref jh are the same value, then it can correctly concludethat
t = jh. The following client fragment makes such a determination usingaliasing information. We assume only that the client can distinguish two values of

type jh, call them v1 and v2.

let = yc := v1let

abs1 =!xc
let = yc := v2let =

xc := abs1
if !yc == v1
then"aha, t = jh"

Given these problems, the challenge is to prohibit an agent from viewing thecontents of the same reference at two different levels of abstraction. In so doing,
we should not otherwise restrict the language's expressiveness.
4.3 The Revised Calculus
Before presenting the formal calculus, we summari-e how we solve the problemsjust outlined.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 27
The definition of host-free is straightforward: an expression e\Delta  is reachable from(
M, e) if e\Delta  is a subterm of e or l is a subterm of e and e\Delta  is reachable from(
M, M (l)).4 (M, e) is host-free if all terms reachable from (M, e) are client terms.To correctly handle interagent communication through the store, we make the se-

mantics of the dereference operator depend on the color of the expression currentlystored in the reference. For example, if

M (l) = vc, then (M, !lh) \Upsilon \Phi \Theta  (M, \Delta \Theta vc\Lambda \Xi \Lambda c ) be-cause
lh and vc are different colors. (To know what type j to put on the embedding,we annotate labels with types--see below.) Conversely, (

M, !lc) \Upsilon \Phi \Theta  (M, vc). Thistechnique requires only that every expression (even an embedding) has one color

and that we can determine this color at run time. Intuitively, a value is embeddedprecisely when it is received by a different agent.

Alternatively, we could have made all dereference operations return embeddings.Allowing

i-embeddings in i code is perfectly reasonable--in fact, our multiagentcalculus does not prevent it. We choose not to take this approach because we

prefer to introduce embeddings precisely when interagent communication occurs.Although our theorems do not rely on the fact that intraagent evaluation does
not introduce embeddings, we find this fact aesthetically pleasing. (If crossing anembedding boundary requires computation to change data representation, avoiding
these redundant embeddings reduces computational overhead.)Finally, we prevent an agent from exporting a reference at different levels of
abstraction. To enforce this restriction syntactically, we associate a type expressionwith each label,

l\Lambda i , and reference creation expression, ref\Lambda  e. Such expressionshave type ref
j and must be exported at precisely ref j, or at a fully abstracttype, such as
t. So the host must decide when creating a reference at what levelof abstraction it will expose the contents of the reference. To prevent exposing a

reference at a different level of abstraction, the rules for relating the type on anembedding annotation to the type of the embedded value do not substitute for any
types under the ref constructor.Of course, the host could allow the client to access a reference of type

ref t by

also providing functions get = \Delta \Theta \Pi xh : ref t. !xh\Lambda \Xi ref t\Lambda \Lambda hh and set = \Delta \Theta \Pi xh : jh. \Pi yh :
ref t. yh := xh\Lambda \Xi t\Lambda ref t\Lambda th . It might appear, then, that the client could use get and
set to encode the aliasing example above that breaks type abstraction. However,because we assume that the client does not know the function bodies associated with

get and set, the client cannot ever conclude for sure that two references of differenttypes are aliases. After all,

get could perform other computation that happenedto evaluate to the contents of the supposedly aliased value. In other words, the

correctness of the aliasing device relies on the atomic, completely specified behaviorof the assignment and dereference operators.

Having given some intuition for our design decisions, we now present the aug-mented calculus. We extend the multiagent calculus because the symmetry of this
calculus actually simplifies much of the presentation, but we explain the system interms of the familiar host and client example.

First, recall that AEi is a finite partial map from type variables to types; it encodeswhat type variables agent

i knows. (So in the two-agent case, AEh maps t to jh and

4Because we are generally concerned with stores of finite size, we interpret this definition induc-
tively; otherwise, a coinductive interpretation is warranted.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

28 * Dan Grossman et al.

[!1] (M, ref\Theta  vi) \Xi \Pi \Lambda  (M-l\Theta  \Xi \Lambda  vi], l\Theta i ) l

\Theta  fresh -!2] (M , l\Theta 

i := vi) \Xi \Pi \Lambda  (M-l\Theta  \Xi \Lambda  vi], vi)

[!3]

color(M(l\Theta  )) = i
(M, !l\Theta i ) \Xi \Pi \Lambda  (M , M(l\Theta  )) [!4]

color(M(l\Theta  )) = j \Phi = i
(M, !l\Theta i ) \Xi \Pi \Lambda  (M, pxM(l\Theta  )qy\Theta j )

[!5]

(M , ej) \Xi \Pi \Lambda  (M , e\Delta j)
(M, pxejqy\Theta fi ) \Xi \Pi \Lambda  (M, pxe\Delta jqy\Theta fi ) [!6] (M, pxl\Theta j qyref \Theta fi ) \Xi \Pi \Lambda  (M , l\Theta i )

Fig. 17. Dynamic semantics with state (partial): (M , e) \Xi \Pi \Lambda  (M\Delta , e\Delta ) where color(e) = i.
AEc is the empty map.) We extend AEi to a function \Delta i on types that does not operateunder the

ref constructor:

\Delta i(b) = b

\Delta i(t) = \Delta  t t ff\Psi  Dom(AEi)AE

i(t) t \Psi  Dom(AEi)\Delta 

i(j \Theta  j\Delta ) = \Delta i(j) \Theta  \Delta i(j\Delta )\Delta 

i(ref j) = ref j

Hence a value of type ref j is exported either abstractly or as ref j, but not at
ref j\Delta  for j\Delta  ff= j.In the two-agent case, we previously wrote \Delta 

h as {jh/t}j and \Delta c as the identityfunction. Using syntax that suggests substitution is now misleading because sub-

stitution does not occur under ref. As before, _\Delta i(j) = \Theta n>=0 \Delta ni (j), which in theone-abstract-type case is just \Delta 

i.The dynamic semantics is a straightforward combination of the multiagent se-

mantics presented in Figure 10 and the stateful semantics presented in Figure 16.Specifically, the system is defined by

--Rules [4 ]-[9 ] in Figure 10, suitably extended so that they operate on programstates and do not modify the store.
--The top six rules in Figure 16, which allow evaluation to proceed in subexpres-sions of applications and state operations.
--Rules for evaluating the state operations and allowing evaluation within an em-bedding, as shown in Figure 17.

Rules [!3 ] and [!4 ] enforce our decision to introduce embeddings when the heapfacilitates interagent communication. Rule [!6 ] allows an agent to extract a label
from an embedding when the agent has sufficient type information to know thatthe embedding contains a label. Note that the type on the label is

j, and the typeon the embedding is ref
j; this equality is consistent with our definition of \Delta i.The interesting additions to the static semantics appear in Figure 18. To ob-

tain the full semantics, include the rules presented in Figures 12 and 13 with themodification that all typing judgments include the store type \Psi  in the context.

Store contents are typechecked according to their color. Hence a reference mayhold a value of any color. In the two-agent setting, this policy means that if

ltcontains a host value, then that value must have type
jh under the host's staticsemantics; but if the reference contains an agent value, then the value must have

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 29
-heap1 ] \Upsilon 

M : \Psi  \Psi ; \Omega  \Upsilon  ei : \Omega \Upsilon 

(M , e) : \Omega 

-heap2 ]

Dom(M) = Dom(\Psi )ff

l\Theta  \Psi  Dom(M). (\Psi ; \Omega  \Upsilon  M(l\Theta  ) : \Omega \Delta  _\Delta i(\Omega ) = \Omega \Delta  color(M(l\Theta  )) = i)\Upsilon 

M : \Psi 

[label]

l\Theta  \Psi  Dom(\Psi )
\Psi ; O \Upsilon  l\Theta i : ref \Omega  -ref ]

\Psi ; O \Upsilon  ei : \Omega \Delta  _\Delta i(\Omega ) = \Omega \Delta 

\Psi ; O \Upsilon  ref\Theta  ei : ref \Omega 

-assign]

\Psi ; O \Upsilon  ei : ref \Omega  \Psi ; O \Upsilon  e\Delta i : \Omega \Delta  _\Delta i(\Omega ) = \Omega \Delta 

\Psi ; O \Upsilon  ei := e\Delta i : \Omega \Delta  -deref ]

\Psi ; O \Upsilon  ei : ref \Omega 
\Psi ; O \Upsilon !ei : _\Delta i(\Omega )

Fig. 18. Static semantics with state (partial).
type t under the agent's static semantics. Note this treatment requires that we candetermine the color of

M (l\Lambda  ).
We maintain the convenient invariant that \Psi ; K \Sigma  vi : j implies j = \Delta i(j).Because references have the type with which they are annotated, this invariant

means the type of the dereference operation must explicitly be _\Delta i(j) where thereference has type

ref j. The rules for reference creation and assignment requirethe subexpression that evaluates to the reference's eventual contents to have type

_\Delta i(j). In other words, i must know that j is a legitimate abstraction of j\Delta , which
by our invariant is most concrete.5 For example, in our two-agent system, considerref

t v where v has type jh. This expression is well-formed if it is a host term, butnot if it is an agent term.

The rule for relating the type on an embedding to the type of the embeddedexpression prevents a

ref j from being exported at any reference type other thanref
j even if ref j is a constituent of another type. This important fact followsfrom the definition of the \Pi 

ff relation, which is defined in terms of the \Delta i maps. Inthe two-agent case, the right antecedent of rule [embed] is simply \Delta 

h(j) = j\Delta  forhost terms and
j = j\Delta  for agent terms.

4.4 Safety Properties
The type soundness and erasure results that we established for the calculi withoutstate extend naturally to the stateful calculus. Therefore, we only present the

aspects of the theorems and proofs that pertain to the additional rules.The Canonical Forms Lemma now describes the form of

vi based on j, assumingthat \Psi ; \Pi  \Sigma 
vi : j. The addition is that if j = ref j\Delta , then vi has the form l\Lambda \Delta i .For the sake of type soundness, the Substitution Lemma still need describe only

substitution over expressions, as opposed to program states. This simplicity isbecause the dynamic semantics substitutes through only expressions. As we will see,
however, the Independence of Evaluation Lemma needs definitions for substitutionthrough program states and well-formedness of open stores (that is, stores that may
contain values with free variables).

5An equivalent antecedent is \Upsilon  \Omega  .i \Omega \Delta ; it is equivalent because \Omega \Delta  = \Delta i(\Omega \Delta ).

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

30 * Dan Grossman et al.

The Preservation Lemma now expresses that evaluation extends the store con-sistently. Together with a Store Weakening Lemma, stating that store extensions
cannot change the type of an expression, the induction hypothesis is strong enough.

Lemma 4.1 (Store Weakening). If \Psi \Delta  is an extension of \Psi  and \Psi ; K \Sigma  e : j,then \Psi \Delta ; K \Sigma 

e : j.

Lemma 4.2 (Preservation). If \Sigma  M : \Psi , \Psi ; \Pi  \Sigma  e : j, and (M, e) \Upsilon \Phi \Theta  (M \Delta , e\Delta ),then there exists a \Psi \Delta  such that \Psi \Delta  extends \Psi , \Sigma 

M \Delta  : \Psi \Delta , and \Psi \Delta ; \Pi  \Sigma  e\Delta  : j.

Note that this strengthening of Preservation is precisely what is needed to extendthe lambda calculus with state; principals add no complications. As for the proof,

the careful use of _\Delta i in the static semantics makes it routine. Recall that the proofis by induction on the derivation that (

M, e) \Upsilon \Phi \Theta  (M \Delta , e\Delta ). We show only the casesfor the rules in Figure 17. The other cases are either simple restatements of the

analogous cases from the proof without state or trivial inductive arguments usingthe Store Weakening Lemma.

Proof.
[!1 ] By assumption, there must be a derivation of the form

\Psi ; \Pi  \Sigma  vi : j\Delta  _\Delta i(j) = j\Delta 

\Psi ; \Pi  \Sigma  ref\Lambda  vi : ref j .

Letting M \Delta  = M [l\Lambda  \Upsilon \Theta  vi] and \Psi \Delta  = \Psi [l\Lambda  \Upsilon \Theta  j], we have \Psi \Delta  extends \Psi . Becausewe know \Sigma 

M : \Psi , to prove \Sigma  M \Delta  : \Psi \Delta , it suffices to prove \Psi \Delta ; \Pi  \Sigma  vi : j\Delta  and_\Delta 

i(j) = j\Delta . These facts follow from the antecedents of the static derivation andthe Store Weakening Lemma. Our final obligation, \Psi \Delta ; \Pi  \Sigma 

l\Lambda i : ref j, follows fromthe definition of \Psi \Delta  and the static semantics.

[!2 ] By assumption, there must be a derivation of the form

\Psi ; \Pi  \Sigma  l\Lambda i : ref j \Psi ; \Pi  \Sigma  vi : j\Delta  _\Delta i(j) = j\Delta 

\Psi ; \Pi  \Sigma  l\Lambda i := vi : j .

Letting M \Delta  = M [l\Lambda  \Upsilon \Theta  vi] and \Psi \Delta  = \Psi  we have that M \Delta  and \Psi \Delta  are extensionsof

M and \Psi  respectively. We have from the hypothesis of the derivation that\Psi ; \Pi  \Sigma 

vi : j\Delta , so we have to show only that \Sigma  M \Delta  : \Psi . Because we already know\Sigma 
M : \Psi , this conclusion follows from \Psi ; \Pi  \Sigma  vi : j\Delta  and _\Delta i(j) = j\Delta .

[!3 ] and [!4 ] By assumption, there must be a derivation of the form

\Psi ; \Pi  \Sigma  l\Lambda i : ref j
\Psi ; \Pi  \Sigma !l\Lambda i : _\Delta i(j).

Letting M \Delta  = M and \Psi \Delta  = \Psi , we need to show only that \Psi ; \Pi  \Sigma  vi : _\Delta i(j).There are two cases: color(

M (l\Lambda )) = i or not. First assume color(M (l\Lambda )) = i.Then
vi = M (l\Lambda  ). It follows from the hypotheses needed to prove \Sigma  M : \Psi  that\Psi ; \Pi  \Sigma 

vi : j\Delta  and _\Delta i(j) = j\Delta  from which the conclusion is immediate. Now assume
M (l\Lambda  ) is a different color. Then vi = \Delta \Theta M (l\Lambda  )\Lambda \Xi \Lambda j . By the argument given for the
other case, we know \Psi ; \Pi  \Sigma  M (l\Lambda  ) : j\Delta  and _\Delta j(j) = j\Delta . Hence by [eq] we conclude
j\Delta  \Pi j j. Hence [embed] applies, and its conclusion is the desired result.

[!5 ] By induction.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 31
[!6 ] By assumption, there must be a derivation of the form

l\Lambda  \Psi  Dom(\Psi )
\Psi ; \Pi  \Sigma  l\Lambda j : ref j \Sigma  ref j \Pi ffi ref j

\Psi ; \Pi  \Sigma  \Delta \Theta l\Lambda j \Lambda \Xi ref \Lambda ff : _\Delta i(ref j) .
Because _\Delta i(ref j) = ref j and from hypothesis we have l\Lambda  \Psi  Dom(\Psi ), we canderive \Psi ; \Pi  \Sigma 

l\Lambda i : ref j using [label ]. Letting M \Delta  = M and \Psi \Delta  = \Psi , we are done.

The statement of the Progress Lemma remains unchanged other than to useprogram states instead of expressions. The additions to the proof are entirely

straightforward. In the case of (M, \Delta \Theta ^vj\Lambda \Xi \Lambda ff ), there is one additional case because jcould have the form

ref j\Delta . In this case, Canonical Forms guarantees that ^vj has
the form l\Lambda \Delta j , so we can tak e a step using [!6 ].Defining erasure from this stateful language with embeddings to the calculus in

Figure 16 such that erasure commutes with evaluation is straightforward, so we omitthe details. Note that the target of this transformation does not include explicit
types on labels; these explicit types have no real dynamic effect.Extending the Value Abstraction Lemma (to which the Independence of Evalu-
ation Theorem is a corollary) to our stateful calculus is straightforward except forsome technical distractions. First, we must use the notion of reachable expressions,
which includes expressions in the store, instead of the simpler notion of subterms.Second, the Value Abstraction Lemma uses substitution (such as {^

vj/xj}ei) to es-tablish a correspondence between two evaluations. To use this technique, we extend

the definition of substitution to workon stores in a pointwise fashion. Otherwisethe Lemma would not apply if an agent stored \Delta \Theta ^

vj\Lambda \Xi \Lambda jff in the store and, hence,would not be strong enough to prove the Independence of Evaluation Theorem.

Substituting through a store requires that we define a well-formed open store withrespect to a context K, so that K \Sigma 

M : \Psi  makes sense. The correct definition isthe obvious generali-ation: K \Sigma 
M : \Psi  if for all l\Lambda  \Psi  Dom(M ), \Psi ; K \Sigma  M (l\Lambda  ) : j\Delta and _\Delta 

i(j) = j\Delta , where M (l\Lambda  ) is a possibly-open i-value.Extending the Host-Provided Values Theorem to our stateful calculus is also

straightforward. Essentially, the preservation property needs to be inductively de-fined to include all terms that are reachable from the current program state without
considering the trusted ho term. That is, ho can maintain private state withoutinvalidating the theorem.

5. POLYMORPHISM AND RECURSIVE TYPES
In this section, we explore the extension of the multiagent language of Section 3 toinclude recursive types and polymorphism. Both of these mechanisms define type

variables: the type u&.j(&) establishes the equation & = j(&). Instantiation of apolymorphic value,

e : ffi&.j, at type j\Delta  establishes a context in which & = j\Delta  and ehas type
j (that is, {j\Delta /&}j).Because the

AEi maps of the multiagent calculus already provide a way of express-ing equalities of the form

& = j, we may try to encode recursive or polymorphictypes using them. The current multiagent language is not sufficient to encode either

of them. The following sections discuss the consequences of adding the necessarymechanisms.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

32 * Dan Grossman et al.

(types) \Omega  ::= . . . | ! | u!.\Omega 
(i-terms) ei ::= . . . | rollui.\Theta  ei | unroll ei
(i-primvals) ^vi ::= . . . | rollui.\Theta  vi

-u1]

ei \Xi \Pi \Lambda  e\Delta i
rollui.\Theta  ei \Xi \Pi \Lambda  rollui.\Theta  e\Delta i -u2 ]

ei \Xi \Pi \Lambda  e\Delta i
unroll ei \Xi \Pi \Lambda  unroll e\Delta i

-u3] unroll rollui.\Theta  vi \Xi \Pi \Lambda  vi

-u4] pxrollui.\Theta  ^vjqyui.\Theta \Delta jfi \Xi \Pi \Lambda  rollui.\Theta \Delta  px^vjqy{ui.\Theta \Delta /i}\Theta \Delta jfi (u!.\Omega \Delta  = _\Delta i(u!.\Omega \Delta ))

[roll]

O \Upsilon  ei : {u!.\Omega /!}\Omega 
O \Upsilon  rollui.\Theta  ei : u!.\Omega  -unroll]

O \Upsilon  ei : u!.\Omega 
O \Upsilon  unroll ei : {u!.\Omega /!}\Omega 

Fig. 19. Recursive types as an orthogonal extension.
5.1 Recursive Types
There are two general approaches for adding recursive types to the multiagentlanguage. The first way is straightforward, and it interacts well with the previous

results about the language. The idea is to treat u-bound type variables as separateentities from the type variables that are used for abstraction (they could be drawn
from the same syntactic class, but separating them makes for cleaner presentation).Figure 19 contains the necessary additions to the language.

The new types include recursive type variables, ranged over by &, and the re-cursive types themselves,

u&.j. Terms roll and unroll mediate the isomorphismbetween
u&.j and {u&.j /&}j. If vi is an i-value, then rollui.\Lambda  vi is an i-primval.The typing judgments for the new forms are standard.

6 The operational rules [u1 ],

[u2 ], and [u3 ] are also standard--they allow progress under a roll or unroll andestablish that composing

unroll with roll is the identity.The new rule, [
u4 ], propagates the embedding on a roll expression that is ex-ported at a concrete type. It is similar to rule [9 ] used for embedded functions

in that the outer agent may have different information about the nature of therecursive type. For instance, the outer agent may know that the value is of type
u&.1 + t * &, the type of t-lists, whereas the inner agent, for whom AEj(t) = int viewsthe value as an

int-list.7 The side condition on [u4 ] ensures that the dynamic se-mantics are deterministic--rule [7 ] applies to a disjoint collection of terms.

The only remaining change needed to establish the soundness of this system isto extend the definition of \Delta 

i in terms of AEi.

\Delta i(u&.j) = u&.\Delta i(j)\Delta 

i(&) = &

6As in the case for fl-abstractions, types annotating roll terms are required to be the most concrete
possible, but we do not need to apply \Delta i because the concreteness of the type in the antecedent
implies the concreteness of the type on the roll.
7We did not formally add product and sum types to our framework, but doing so is straightforward.

For example, pxinleft\Theta 0+\Theta 1ejqy\Theta 

2+\Theta 3

fi \Xi \Pi \Lambda  inleft\Theta 2+\Theta 3pxejqy\Theta 

2
fi when \Omega 2 and \Omega 3 are most concrete.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 33
Because the u-bound type variables are syntactically distinct from the abstractiontype variables, it makes no sense for

& to be in the domain of AEi. To avoid problemswith capture, we prohibit free occurrences of

& in the range of AEi.Having made these additions to the language, it is straightforward to establish

type soundness. To establish Preservation for the case of [u4 ], we need a type-relations lemma that is analogous to the Arrow Lemma used in the case of [9 ]:

Lemma 5.1 (u Type Relations). If \Sigma  u&.j \Pi ff u&.j\Delta , then \Sigma  {u&.j /&}j \Pi ff{
u&.j\Delta /&}j\Delta 

The most interesting case of the proof of preservation is when the last rule of thedynamic derivation is [

u4 ]:

Proof. By assumption, we have a derivation of the form\Pi  \Sigma 

ej : {u&.j /&}j\Pi  \Sigma 
rollui.\Lambda  ej : u&.j \Sigma  u&.j \Pi jffi u&.j\Delta 

\Pi  \Sigma  \Delta \Theta rollui.\Lambda  ej\Lambda \Xi ui.\Lambda \Delta jff : _\Delta i(u&.j\Delta ) .
Using the right antecedent and Lemma 5.1, we conclude that \Sigma  {u&.j /&}j \Pi jffi{

u&.j\Delta /&}j\Delta . So using the top antecedent, we can derive

\Pi  \Sigma  ej : {u&.j/&}j \Sigma  {u&.j /&}j \Pi jffi {u&.j\Delta /&}j\Delta 

\Pi  \Sigma  \Delta \Theta ej\Lambda \Xi {ui.\Lambda \Delta /i}\Lambda \Delta jff : _\Delta i({u&.j\Delta /&}j\Delta ) .

By assumption, we have the side condition _\Delta i(u&.j\Delta ) = u&.j\Delta . From this condition,it is easy to show that _\Delta 

i({u&.j\Delta /&}j\Delta ) = { _\Delta i(u&.j\Delta )/&} _\Delta i(j\Delta ) = {u&.j\Delta /&}j\Delta . Sowe can derive

\Pi  \Sigma  \Delta \Theta ej\Lambda \Xi {ui.\Lambda \Delta /i}\Lambda \Delta jff : {u&.j\Delta /&}j\Delta 
\Pi  \Sigma  rollui.\Lambda \Delta  \Delta \Theta ej\Lambda \Xi {ui.\Lambda \Delta /i}\Lambda \Delta jff : u&.j\Delta .

The Progress Lemma is routine; it uses an extension of the Canonical Forms Lemmathat asserts that

i-values of type u&.j have the form rollui.\Lambda  vi.This way of dealing with recursive types has the advantage of simplicity: because

the presence of recursive types is orthogonal to the kind of type abstraction allowedby embeddings, all of the proofs of safety properties in Section 3 require minimal
changes to account for the new constructs.Another approach to incorporating recursive types into this system requires us
to change the notion of compatibility of the \Delta i maps to account for cycles. Givena recursive type

u&.j, observe that the rolled values behave essentially abstractly.There is only one destructor for the term roll

ui.\Lambda  vi, namely, unroll. This obser-vation suggests that we can encode recursive types like so: Let

r and u be freshtype variables. Create a special agent,

r, whose sole function is to provide the rolland
unroll operations for a recursive type. From the type perspective, r knowsthat

r = {u/&}j, i.e., AEr(r) = {u/&}j, and AEr is otherwise undefined. For any clientagent,

i, who wishes to use values of type u&.j, let AEi(u) = r. The terms encoding
rollui.\Lambda  x and unroll x are

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

34 * Dan Grossman et al.

rollui.\Lambda  i \Delta \Theta \Pi xr : {u/&}j. xr\Lambda \Xi {u/i}\Lambda \Lambda rr

unroll i \Delta \Theta \Pi xr : {u/&}j. xr\Lambda \Xi r\Lambda {u/i}\Lambda r

The type variable r acts like the type u&.j. As expected, the agent r providesidentity functions that outwardly appear to clients as having the types appropriate

to roll and unroll: {r/&}j \Theta  r and r \Theta  {r/&}j, respectively.Although this approach is initially appealing, it requires substantial changes to
the language. The essential difficulty is that there may not be a most concrete formfor a given type variable, due to the possibly cyclic nature of the type information.

Two reasonable alternatives are (1) move to an operational semantics in whichtypes are refined nondeterministically, or (2) require that each agent's type infor-
mation be acyclic, even if there are cycles globally. Neither of these options issatisfactory. The first makes reasoning about the behavior of programs unduly
complicated. The second choice means that giving more type information to anagent can destroy a system's compatibility. Both suffer from the problem that
erasure (to a typed language) is harder to establish.There may be merit in further considering this approach, particularly if the agents
are module-level constructs and if the concern is mutually recursive data types thatcross module boundaries. For a core language, however, the simplicity of the first
approach and its compatibility with our previous proofs make it more valuable.
5.2 Polymorphism
The primary difference between polymorphism and the type abstraction alreadypresent in the multiagent calculus is one of scope: the abstract types present in the

multiagent calculus are global and static, whereas a polymorphic instantiation islocal to part of the program. That is, the application (\Lambda 

&. e) j introduces the typeequality
& = j within the scope of the expression e. A second difference betweentype abstraction and polymorphism is that, in the latter, the same type variable

may be instantiated at different types, for example,

\Pi x:ffi&.& \Theta  &. (. . . (x [int]) . . . (x [bool]) . . .).
It appears that & = int holds for part of the term whereas & = bool holds for adifferent part of the term.

This second difference is superficial, however. Because the & in x's type is boundin ffi

&.& \Theta  &, we are free to rename it for each occurrence of x in the body. Wecan thinkof the term (

x [int]) as establishing the equation & = int whereas in thesecond term we choose the type of

x to be (the equivalent type) ffi*.* \Theta  *, andthus (
x [bool]) defines * = bool. In this way, each type application can establishthe concrete form of a distinct type variable.

The true distinction, then, between our type-abstraction mechanism and poly-morphism is local scoping. As with our first approach to recursive types, we could
include both features separately. Instead, we investigate how to extend our frame-workto unify type abstraction and polymorphism via a single mechanism. Bridging
the gap between the two features amounts to allowing the definitions of the AEi mapsto change during evaluation. We use the notation {\Delta } to mean a set of type maps
{\Delta 1, . . . , \Delta n}; it captures the type knowledge each agent has at a particular point
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 35
(types) \Omega  ::= . . . | ff!.\Omega 
(i-terms) ei ::= . . . | \Lambda !. ei | ei -\Omega ]
(i-primvals) ^vi ::= . . . | \Lambda !. ei

Dom{\Delta } = [

i

Dom(oei)

[ff1] fi{\Delta }, (\Lambda !. ei) [\Omega ]fl \Xi \Pi \Lambda  fi{\Delta } ffii {! = \Omega }, {\Omega /!}ieifl
-ff2] fi{\Delta }, px\Lambda !. ejqy\Sigma i.\Theta fi fl \Xi \Pi \Lambda  fi{\Delta }, \Lambda !. pxejqy\Theta fi fl

-ffintro]

\Theta , !; {\Delta }; O \Upsilon  ei : \Omega 
\Theta ; {\Delta }; O \Upsilon  \Lambda !. ei : ff!.\Omega  (! \Phi \Psi  \Theta  ffl Dom{\Delta })

[ffelim]

\Theta ; {\Delta }; O \Upsilon  ei : ff!.\Omega  \Delta i(\Omega \Delta ) = \Omega \Delta 

\Theta ; {\Delta }; O \Upsilon  ei -\Omega \Delta ] : {\Omega \Delta /!}\Omega  (! \Phi \Psi  Dom{\Delta })

Fig. 20. Polymorphism.
in the program evaluation. We can then integrate traditional polymorphic termsby extending our notion of evaluation from

ei \Upsilon \Phi \Theta  e\Delta i to j{\Delta }, ei` \Upsilon \Phi \Theta  j{\Delta \Delta }, e\Delta i`.This approach is similar to the allocation-based, explicit type-passing semantics for

polymorphism found in the dissertation of Morrisett [1995].Figure 20 contains the necessary adjustments to the language. Note that we
have only one form of type variable. In keeping with convention with respect topolymorphism, we allow

& and * to range over type variables in addition to t, s,and
u. Types are extended with the form ffi&.j. We add terms of the form \Lambda &. ei,in which

& is abstract in ei.Instantiation of a type variable is represented by

ei [j]. Operationally (see rule[ffi1 ]), this application corresponds to extending
AEi to include & = j. We use thenotation \Delta 

i ' {& = j} to mean the mapping from types to types obtained from
AEi[& \Upsilon \Theta  j]. The notation {\Delta } 'i {& = j} represents

{\Delta 1, . . . , \Delta i\Xi 1, \Delta i ' {& = j}, \Delta i+1, . . . , \Delta n}.
This extension is valid only if it preserves the compatibility of the \Delta  maps. Let-ting Dom{\Delta } mean \Lambda 

i Dom(AEi), it is easy to show that if {\Delta } is compatible and& ff\Psi  Dom{\Delta }, then {\Delta } '

i {& = j} is compatible. As a notational convenience,whenever we use {\Delta } '

i {& = j}, we implicitly assume that & ff\Psi  Dom{\Delta }.We need to specify the behavior of \Delta 

i on types of the form ffi&.j. Assuming
& ff\Psi  Dom(AEi), which is always possible via alpha-conversion of ffi&.j, we have

\Delta i(ffi&.j) = ffi&.\Delta i(j).
The original multiagent calculus maintains the invariant that any types appearingas part of the syntax of an

i-term are most concrete from agent i's perspective. Thisinvariant is enforced in the typing rules; for example, the [abs] rule requires that

\Delta i(j\Delta ) = j\Delta . Unfortunately, this invariant is harder to maintain now that an agentmay "learn" information about a type variable at runtime. To do so, we introduce
a special substitution operator, {j/&}i, to perform the substitution of j for & onlyin terms colored

i, including i-subterms of any j-colored subexpressions. We can

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

36 * Dan Grossman et al.
extend the operator to contexts in a pointwise manner because variables in thecontext have a color.

We can now understand the operational behavior of the new constructs. Poly-morphic expressions are values. Rule [ffi1 ] performs type instantiation. Agent

i'stype map is extended with the new binding for
&, and we substitute j for & inthe
i-colored terms of the body. Most importantly, no other agents knows &. Thatway, if the body of the polymorphic expression is a different color, then we will be

able to use our techniques to argue that (under sufficient conditions) it evaluatesindependently of certain values it is passed. Rule [ffi2 ] describes the transition step
for an embedded polymorphic value being exported as such. In this case, the typemaps do not change; the outer embedding is simply moved inside the \Lambda .

The static semantics are derived from the regular polymorphic lambda calculuswith a few twists to account for our different style of tracking type information.
First, because {\Delta } changes during the course of evaluation, we must parameteri-eour typing judgments by the current definition of {\Delta }. We also need to track
the lexical scoping of \Lambda -bound type variables. We do so by adding a set, \Theta , oftype variables currently in scope. The new form of typing judgments is therefore
\Theta ; {\Delta }; K \Sigma  ei : j.With these additions, the static rules of the original multiagent calculus carry
over to the new setting, with the understanding that occurrences of \Delta i in thosejudgments now refer to the \Delta 

i found in the {\Delta } parameter to the rule. (\Theta  is unusedby the new version of the old rules.) The typing rules for the new constructs are

[ffiintro] and [ffielim]. The former lets us conclude that a polymorphic term has typeffi

&.j if, when we add & to the variables in scope, the body has type j. The sidecondition ensures that

& is distinct from all other variables in scope and distinctfrom those variables that are defined in any

AE map. (We can always satisfy thiscondition by suitable alpha conversion.) Note that this condition means \Delta 

i(&) = &for any agent
i, and hence j may mention &.The rule [ffielim] shows how to type polymorphic instantiation. Because agent

i is performing the instantiation, we require that the instantiation type is mostconcrete from the perspective of agent

i. The last antecedent requires that such anupdate preserves compatibility.

One might expect that the static scoping of type variables regulated by \Theta  andthe dynamic information encapsulated in {\Delta } are closely related. The following
lemma, which we need to prove preservation, establishes the relation.

Lemma 5.2. Suppose \Theta , &; {\Delta }; K \Sigma  ej : j\Delta  and & ff\Psi  Dom{\Delta }. Let {\Delta \Delta } ={\Delta } '

i {& = j}. Then

(i) If i = j then \Theta ; {\Delta \Delta }; {j/&}iK \Sigma  {j/&}iej : {j/&}j\Delta 
(ii) If i ff= j then \Theta ; {\Delta \Delta }; {j/&}iK \Sigma  {j/&}iej : j\Delta .

Proof Sketch. By simultaneous induction of parts (i) and (ii) on the derivationthat \Theta 

, &; {\Delta }; K \Sigma  ej : j\Delta .

As usual, when we add a new type constructor to the language, we need a TypeRelations Lemma to relate subcomponents of related types. In this case, we have

the following:
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 37
Lemma 5.3 (ffi Type Relations). If {\Delta } \Sigma  ffi&.j \Pi ff ffi&.j\Delta , then {\Delta } \Sigma  j \Pi ff
j\Delta .

We alter the statement of preservation to account for the difference in programconfigurations. As usual for an allocation-style semantics, we must show that the

program does not lose type information during the course of evaluation. Thus, wemake the following definition:

Definition 5.4. Let {\Delta } <= {\Delta \Delta } mean {\Delta \Delta } = {\Delta } 'i {& = j} for some agent
i, type j, and type variable & such that & ff\Psi  Dom{\Delta }. Let <=* be the reflexive,transitive closure of <=. We say that {\Delta \Delta } refines {\Delta } whenever {\Delta } <=* {\Delta \Delta }.

Lemma 5.5 (Preservation). If \Pi ; {\Delta }; \Pi  \Sigma  ei : j and j{\Delta }, ei` \Upsilon \Phi \Theta  j{\Delta \Delta }, e\Delta i`,then {\Delta \Delta }; \Pi  \Sigma 

e\Delta i : j. Furthermore, {\Delta \Delta } is compatible and refines {\Delta }.

Proof. The cases for terms not involving the new constructs are similar to thosecases presented earlier, so we omit them. The new cases are:

[ffi1 ] By assumption, there is a derivation of the form

&; {\Delta }; \Pi  \Sigma  ei : j\Delta \Delta \Pi 
; {\Delta }; \Pi  \Sigma  \Lambda &. ei : ffi&.j\Delta \Delta  \Delta i(j) = j\Pi 

; {\Delta }; \Pi  \Sigma  (\Lambda &. ei) [j] : {j/&}j\Delta \Delta  (& ff\Psi  Dom{\Delta }).

Let {\Delta \Delta } = {\Delta }'i{& = j} and \Delta \Delta i = \Delta i'i{& = j}. We can apply Lemma 5.2 to theantecedent to obtain \Pi ; {\Delta \Delta }; \Pi  \Sigma  {

j/&}iei : {j/&}j\Delta \Delta . Clearly {\Delta \Delta } is compatibleand refines {\Delta } .

[ffi2 ] By assumption, there is a derivation of the form

&; {\Delta }; \Pi  \Sigma  ej : j1\Pi 
; {\Delta }; \Pi  \Sigma  \Lambda &. ej : ffi&.j1 {\Delta } \Sigma  ffi&.j1 \Pi jffi ffi&.j\Pi 

; {\Delta }; \Pi  \Sigma  \Delta \Theta \Lambda &. ej\Lambda \Xi \Phi i.\Lambda jff : _\Delta i(ffi&.j) .
The side conditions ensure that & ff\Psi  Dom{\Delta }, so we are able to conclude that_\Delta 

i(ffi&.j) = ffi&. _\Delta i(j). We need to construct a derivation for

&; {\Delta }; \Pi  \Sigma  ej : j1 {\Delta } \Sigma  j1 \Pi jffi j

&; {\Delta }; \Pi  \Sigma  \Delta \Theta ej\Lambda \Xi \Lambda jff : _\Delta i(j)\Pi 
; {\Delta }; \Pi  \Sigma  \Lambda &. \Delta \Theta ej\Lambda \Xi \Lambda jff : ffi&. _\Delta i(j) .
We have the first antecedent from the original typing derivation. The Type Re-lations Lemma (5.3) says that {\Delta } \Sigma  ffi

&.j1 \Pi jffi ffi&.j implies {\Delta } \Sigma  j1 \Pi jffi j.The side condition on [ffiintro] has already been observed above. Because {\Delta } is

compatible and refines itself, we are done.

Because the {\Delta } context changes during evaluation, and the definition of when\Delta \Theta ^
vj\Lambda \Xi tjff is an i-value depends on whether \Delta i(t) = t, the notion of value is also

dynamic. We write {\Delta } \Sigma  ei : Value when either ei is an i-primval or ei = \Delta \Theta ^vj\Lambda \Xi tffand

t ff\Psi  Dom{\Delta }.Progress, proved as usual by induction on the structure of

ei, then becomes:

Lemma 5.6 (Progress). If \Pi ; {\Delta }; \Pi  \Sigma  ei : j then either {\Delta } \Sigma  ei : Value orthere exists an

e\Delta i and {\Delta \Delta } such that j{\Delta }, ei` \Upsilon \Phi \Theta  j{\Delta \Delta }, e\Delta i`

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

38 * Dan Grossman et al.

\Omega  ::= ! | \Omega  \Lambda  \Omega  | ff!.\Omega 

e ::= x | flx: \Omega . e | (e e) | \Lambda !. e | (e -\Omega ])

O \Upsilon  x : O(x)
O[x: \Omega ] \Upsilon  e : \Omega \Delta 
O \Upsilon  flx:\Omega . e : \Omega  \Lambda  \Omega \Delta  (x \Phi \Psi  Dom(O))

O \Upsilon  e : \Omega \Delta  \Lambda  \Omega  O \Upsilon  e\Delta  : \Omega \Delta 

O \Upsilon  (e e\Delta ) : \Omega 

O \Upsilon  e : \Omega 
O \Upsilon  \Lambda !. e : ff!.\Omega  (! \Phi \Psi  F T V (O))

O \Upsilon  e : ff!.\Omega \Delta 
O \Upsilon  (e -\Omega ]) : {\Omega /!}\Omega \Delta 

Fig. 21. Polymorphic lambda calculus.
5.3 Translation from the Polymorphic Lambda Calculus
The net effect of our design decisions is that we can faithfully embed the poly-morphic lambda calculus (shown in Figure 21) into this new language by simply

decorating the term with a single color. In this case, the operational semantics de-generates to those of the regular polymorphic lambda calculus; in particular, type
application still substitutes a type for a type variable. Using such a naive transla-tion, our system will provide no more opportunity to use syntactic proofs of type
abstraction than before.Instead, we show that a smarter translation, which essentially colors the code in
such a way as to make agents with different type information explicit, allows us torecover some type-abstraction proofs in a syntactic manner.

We formulate the translation as a type-directed transformation C[[K \Sigma  e : j]]. Thetranslation takes two additional parameters:

i, an agent indicating the desired colorof the result term, and
', a map from source variables to target variables (includingcolor information). We maintain the invariant that, when compiling the judgment

C[[K \Sigma  e : j]]i', we have Dom(') = Dom(K). The result of the translation is an
i-term.The translation is given in Figure 22. Most of the rules are straightforward--they

recursively translate the subterms of the expression and combine the results intothe corresponding construct. The two interesting cases are [Tvar ] and [Ttypeabs].

The rule for translating the variable x simply looks up x in the map '. If theresulting variable has the same color as the desired color of the term, no further
action is needed. Otherwise, the translation produces an embedding of the variableto yield a term of the appropriate color. Because the type K(

x) may mention typevariables that are currently in scope, the embedding may be abstract.

The idea for translating a polymorphic term is to "spawn" a new agent withwhich to color the body of the type abstraction. By recursively translating the
body to a term of this new color, [Ttypeabs] explicitly marks the boundaries wheretype information changes.

As examples, we have the following translations:

C[[\Pi  \Sigma  \Lambda &. \Pi x :&. x : ffi&.& \Theta  &]]i\Pi  = \Lambda &. \Delta \Theta \Pi xj :&. xj \Lambda \Xi i\Lambda ij

C[[\Pi  \Sigma  \Pi x:b. \Lambda &. x : b \Theta  ffi&.b]]i\Pi  = \Pi xi :b. \Lambda &. \Delta \Theta \Delta \Theta xi\Lambda \Xi bi \Lambda \Xi bj
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 39
-Tvar] C-[O \Upsilon  x : O(x)]]i& = ( &(x) if color(&(x)) = ipx&(x)qy,(x)

j if color(&(x)) = j \Phi = i

-Tabs] C

-[O[x: \Omega ] \Upsilon  e : \Omega \Delta ]]i(&[x \Xi \Lambda  xi]) = eiC
-[O \Upsilon  flx: \Omega . e : \Omega  \Lambda  \Omega \Delta ]]i& = flxi : \Omega . ei

-Tapp] C

-[O \Upsilon  e : \Omega \Delta  \Lambda  \Omega ]]i& = ei C-[O \Upsilon  e\Delta  : \Omega \Delta ]]i& = e\Delta iC

-[O \Upsilon  (e e\Delta ) : \Omega ]]i& = (ei e\Delta i)

[Ttypeabs] C

-[O \Upsilon  e : \Omega ]]j& = ejC
-[O \Upsilon  \Lambda !. e : ff!.\Omega ]]i& = \Lambda !. pxejqy\Theta j (j fresh)

[Ttypeapp] C

-[O \Upsilon  e : ff!.\Omega ]]i& = eiC
-[O \Upsilon  (e -\Omega \Delta ]) : {\Omega \Delta /!}\Omega ]]i& = (ei -\Omega \Delta ])

Fig. 22. Translation of the polymorphic lambda calculus.
The translation is type-preserving, as formali-ed in the following lemma, where
'K is the pointwise application of ' to the variables in K.

Lemma 5.7. Suppose K \Sigma  e : j in the polymorphic lambda calculus and ' is amap from source variables to target variables where Dom(

') = Dom(K). Supposefurther that C[[K \Sigma 
e : j]]i' = ei. Let {\Delta } = {\Delta k | k \Psi  Agents(ei), AEk = \Pi }, andlet \Theta  =
F T V (K), the free type variables appearing in K. Then \Theta ; {\Delta }; 'K \Sigma  ei : j.

Proof Sketch. By induction on the derivation that K \Sigma  e : j in the sourcelanguage. The base case is handled by the definition of

'. It uses the fact thatfor any {\Delta } and nonempty
o/, {\Delta } \Sigma  j \Pi ff j. The same idea is used to show thatthe embedding introduced in the translation of a polymorphic term is well-typed.

To show that a translated type application is well-formed, we need to show that
& ff\Psi  Dom{\Delta } and that \Delta i(j\Delta ) = j\Delta , but these follow from the fact that each AEk isthe empty map. The remainder of the cases follow by straightforward induction.

We can erase this extended multiagent calculus (excluding fix) to the polymor-phic lambda calculus by extending our definition of erasure to include the new
terms. Also, the definition of \Phi  (the composite type information) depends on thecurrent {\Delta }, so we treat {\Delta }as an input to

erase.

erase({\Delta }, \Lambda &. \Delta \Theta ej\Lambda \Xi \Lambda jff) = \Lambda &. erase({\Delta }, ej)

erase({\Delta }, ei [j]) = erase({\Delta }, ei) [ _\Phi (j)]

Using the same techniques as before, we prove the following lemma:
Lemma 5.8 (Erasure). If ei is well-typed and j{\Delta }, ei` \Upsilon \Phi \Theta * j{\Delta \Delta }, e\Delta i`, then
erase({\Delta }, ei) \Upsilon \Phi \Theta * erase({\Delta \Delta }, e\Delta i).

This lemma lets us establish a correspondence between the polymorphic lambdacalculus and its translation into our multiagent setting.

Lemma 5.9 (Translation). If \Pi  \Sigma  e : j in the polymorphic lambda calculus,then

erase(C[[\Pi  \Sigma  e : j]]i\Pi ) = e.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

40 * Dan Grossman et al.

Proof Sketch. By induction on the derivation that e is well-typed. The in-variant must be strengthened to include open terms.

Putting the previous two lemmas together yields the following theorem, whichestablishes the correctness of our translation:
Theorem 5.10 (Correctness of Translation). Suppose \Pi  \Sigma  e : j is a termof the polymorphic lambda calculus,

e \Upsilon \Phi \Theta * v, and C[[\Pi  \Sigma  e : j]]i\Pi  = ei. Further-more, let {\Delta } = {\Delta 

k | k \Psi  Agents(ei), AEk = \Pi }. Then there exists a vi such thatj{\Delta }
, ei` \Upsilon \Phi \Theta * j{\Delta \Delta }, vi` and erase({\Delta \Delta }, vi) = v.

Finally, if we return to the file-handle example from the introduction, letting
jc = string \Theta  fh, we see that

C[[(\Lambda fh. \Pi host :jc. client code) int host code]]h\Pi =

(\Lambda fh. \Delta \Theta \Pi hostc : jc. client codec\Lambda \Xi \Lambda c\Lambda \Lambda c ) int host codeh.
If we assume that host codeh is a value, the Canonical Forms lemma tells us thatit is a function,

\Pi xh : string. host. Let jh be string \Theta  int, the host's view of jc.Let {\Delta } be {
AEh = \Pi , AEc = \Pi } and {\Delta \Delta } be {AEh = [fh \Upsilon \Theta  int], AEc = \Pi }. Then the firstseveral steps of the operational semantics are

j{\Delta }, (\Lambda fh. \Delta \Theta \Pi hostc :jc. client codec\Lambda \Xi \Lambda c\Lambda \Lambda c ) int host codeh`\Upsilon \Phi \Theta  j{\Delta \Delta }

, \Delta \Theta \Pi hostc :jc. client codec\Lambda \Xi \Lambda h\Lambda \Lambda c host codeh`\Upsilon \Phi \Theta  j{\Delta \Delta }
, (\Pi hosth :jh. \Delta \Theta {\Delta \Theta hosth\Lambda \Xi \Lambda ch /hostc}client codec\Lambda \Xi \Lambda c ) host codeh`\Upsilon \Phi \Theta  j{\Delta \Delta }
, \Delta \Theta {\Delta \Theta host codeh\Lambda \Xi \Lambda ch /hostc}client codec\Lambda \Xi \Lambda c `.

The evaluation from this point on is via rule [3 ]. We can use the invariant ! pre-sented for the Host-Provided Preservation Lemma: if we assume that

client codeis host-free, it is easy to establish that
!(client code). By rule [H ], we have
!(\Delta \Theta host code\Lambda \Xi \Lambda hh ). Thus, by Host-Provided Substitution we are able to conclude
!({\Delta \Theta host codeh\Lambda \Xi \Lambda ah /hostc}client codec). We conclude that any closed value of type
fh appearing in the client code during evaluation was obtained through the hostinterface. (Technically, we should require that the bodies of the client and host do

not themselves contain polymorphic terms, because the proof in Section 3 does notaccount for the new extensions to the language. We expect that this requirement
is actually not necessary.)
6. RELATED WORK
There has been much workon representation independence and parametric poly-morphism, as pioneered by Strachey [1967] and Reynolds [1983], and more recently

by Ma and Reynolds [1992]. Such notions have been incorporated into programminglanguages such as SML [Milner et al. 1997] and Haskell [Peyton Jones et al. 1999]
and studied extensively in Girard's System F [1989]. The connection between typeabstraction and existential types has been studied by Mitchell and Plotkin [1988].

Model-theoretic approaches to studying polymorphism have also enjoyed a richhistory, although incorporating notions of recursion have proven to be difficult: see
MacQueen et al. [1986], the workof Coquand et al. [1987; 1989], and Abadi andPlotkin [1990]. Pitts [1996] has studied relational properties on recursively defined

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 41
domains and investigated parametricity in extensions of the polymorphic lambdacalculus that include fixpoint recursion [Pitts 2000].

Wright and Felleisen [1994] populari-ed the use of syntactic techniques for provingtype safety. We can view our workas extending theirs to prove stronger properties
by adding innocuous syntax to a language. Given the right syntactic additions,the resulting proofs follow precisely the subject-reduction form that Wright and
Felleisen advocate.Abadi et al. [1993] have taken a syntactic approach to parametricity by formali--
ing the logical relations arguments used in such proofs. More recently, Crary [1999]has proposed the use of singleton types as a means of proving parametricity results
without resorting to the construction of models.None of the above workexplicitly involves the notion of principal. Our syntactic
separation of agents is similar to Nielson and Nielson's two-level lambda calculus[Nielson and Nielson 1992]. There they are concerned with binding-time analysis,
so the two principals' code is inherently not mixed during evaluation. A notionof principal also arises in the study of language-based security, where privileged
agents may not leakinformation to unprivileged ones. See, for example, Hein-eand Riecke's workon the SLam calculus [1998], Volpano and Smith's workon type-
based security [1997], and the language JFlow [Myers 1999].Pierce and Sangiorgi [1999] prove parametricity results for a polymorphic pi cal-
culus in an operational setting. Rather than add principals to the term language,they use external substitutions to reason about bisimilarity of polymorphic pro-
cesses in which there are both abstract and concrete views of data values. Sewelland Vitek[1999] have also used the idea of coloring in a variant of the pi calculus
to prove properties about causal relationships in a security setting.Perhaps the closest workto ours is Leroy and Rouaix's investigation into the
safety properties of typed applets [Leroy and Rouaix 1998]. They use a lambdacalculus augmented with state in order to prove theorems similar to our two-agent
theorems. They too distinguish between execution-environment code and appletcode, similar to our use of principals, but they consider only the two-agent case
and take a less syntactic approach.
7. SUMMARY AND CONCLUSIONS
Abstract types are an invaluable tool to software designers. They aid programmersin reasoning about interfaces between different pieces of code.

Despite this utility, it is very hard to prove that the informal reasoning aboutabstract types, such as, "all file handles are obtained from the

open system call," iscorrect. One approach is to encode different principals in the well-understood poly-

morphic lambda calculus and appeal to results on parametricity. This approachis not always feasible, such as when the language includes state, threads, recur-
sive types, or other expressive features. The syntactic proofs of type-abstractionproperties presented in this paper are tedious, but conceptually straightforward. In
contrast, building a model is conceptually difficult but can yield elegant proofs.We have presented a syntactic approach to proving some type-abstraction prop-
erties. The main idea is "color" the different principals in the language, each ofwhich has access to different type information. We show how we can trackthese
principals throughout evaluation. This extra syntactic structure gives us a frame-

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

42 * Dan Grossman et al.
workin which we can prove properties about where certain values came from (thefile-handle example), as well as how abstraction is preserved by evaluation. The
arguments take the form of subject-reduction proofs, which show that a desiredproperty is invariant with respect to evaluation, so the hope is that they will scale
more easily than model-theoretic techniques. As evidence supporting this hope, wehave shown how to extend these results to include mutable references, recursive
types, and parametric polymorphism.

There are a number of open questions about our approach. Parametric polymor-phism offers the strong notion of representation independence, which can be used

to reason about the equivalence of abstract data types. As long as two implemen-tations are equivalent in an appropriate sense, it does not matter which implemen-
tation a program uses--they produce equivalent results. We have avoided buildingsuch logical relations, but it remains to be seen exactly what formal connections
can be drawn between those results and the ones presented here.

We also have not investigated the connections between the multiagent calculusand process-based calculi or object-oriented calculi where the notion of principal

(that is, threads or objects) arises naturally. Our method of tracking principalsduring evaluation should adapt to these domains, but we may also learn more
about the multiagent calculus by viewing each agent as a thread and the embeddingannotations as points at which synchroni-ation occurs during execution. There is
also a similarity between our use (in Section 5.2) of global alpha conversion andthe restriction operator,

+, of the pi calculus to generate a "fresh" type variable atruntime.

Another addition to our approach would be an integration of traditional subtyp-ing. That is, we have not considered how we would need to adapt the framework
to permit a primitive subtyping relation between (multiple) base types and itsstandard extension to other type constructors. Our multiagent calculus does allow
a principal to reveal partial information about a type. (For example, by letting
t1 = t2 \Theta  t3, t2 = int, and t3 = int, an agent can export a function of type
int \Theta  int at four different types.) Perhaps there is some connection between thissort of partial information and the partial information of knowing that

j is somesubtype of
j\Delta , but it seems our approach is closer to polymorphism than subtyping.

The kinds of properties we have proven in the multiagent language are limited bythe granularity of types. The system does not let us prove that an agent does not

misuse file handles, for instance by duplicating them or confusing two different filehandles obtained from separate calls to

open. The reason is that we trackembed-dings at the granularity of their types--the theorems do not distinguish particular

instances of type fh. We could imagine tracking such fine-grained details, but thenecessary invariants for subject-reduction proofs may become more complex.

Finally, the notion of principal could prove useful for results other than abstrac-tion. For example, we could easily give different operational semantics to different
principals and then reason about interlanguage interoperability. Lifting constantsand values out of embeddings could require wrapper code or data conversions.
Similarly, we could imagine that embeddings represent a form of remote commu-nication. In this case, putting values in embeddings and taking values out would
require marshalling and unmarshalling.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

Syntactic Type Abstraction * 43
REFERENCES
Abadi, M., Cardelli, L., and Curien, P.-L. 1993. Formal parametric polymorphism. In 20th

ACM Symposium on Principles of Programming Languages. ACM Press, New York, NY, 157-
167.

Abadi, M. and Plotkin, G. D. 1990. A PER model of polymorphism. In 5th Annual Symposium

on Logic in Computer Science. IEEE Computer Society Press, Los Alamitos, CA, 355-365.

Coquand, T., Gunter, C. A., and Winskel, G. 1987. DI-domains as a model of polymorphism.

In Mathematical Foundations of Programming Language Semantics, M. Main, A. Melton,
M. Mislove, and D. A. Schmidt, Eds. Lecture Notes in Computer Science, vol. 298. Springer-
Verlag, New York, NY, 344-363.

Coquand, T., Gunter, C. A., and Winskel, G. 1989. Domain theoretic models of polymorphism.

Inf. Comput. 81, 2 (May), 123-167.

Crary, K. 1999. A simple proof technique for certain parametricity results. In 4th ACM International Conference on Functional Programming. ACM Press, New York, NY, 82-89.

Girard, J.-Y., Lafont, Y., and Taylor, P. 1989. Proofs and Types. Cambridge University

Press, Cambridge, UK.

Harper, R. 1994. A simplified account of polymorphic references. Information Processing Letters 51, 4 (August), 201-206.

Heintze, N. and Riecke, J. G. 1998. The SLam calculus: programming with secrecy and integrity.

In 25th ACM Symposium on Principles of Programming Languages. ACM Press, New York,
NY, 365-377.

Leroy, X. and Rouaix, F. 1998. Security properties of typed applets. In 25th ACM Symposium

on Principles of Programming Languages. ACM Press, New York, NY, 391-403.

Ma, Q. and Reynolds, J. 1992. Types, abstraction, and parametric polymorphism: Part 2. In

Proceedings of the 1991 Mathematical Foundations of Programming Semantics, S. Brookes,
M. Main, A. Melton, M. Mislove, and D. A. Schmidt, Eds. Number 598 in Lecture Notes in
Computer Science. Springer-Verlag, New York, NY, 1-40.

MacQueen, D., Plotkin, G. D., and Sethi, R. 1986. An ideal model for recursive polymorphism.

Information and Control 71, 1/2 (October/November), 95-130.

Milner, R., Tofte, M., Harper, R., and MacQueen, D. 1997. The Definition of Standard ML

(Revised). The MIT Press, Cambridge, MA.

Mitchell, J. 1991. On the equivalence of data representations. In Artificial Intelligence and

Mathematical Theory of Computation: Papers in Honor of John McCarthy, V. Lifschitz , Ed.
Academic Press, San Diego, CA, 305-330.

Mitchell, J. C. and Plotkin, G. D. 1988. Abstract types have existential type. ACM Transactions on Programming Languages and Systems 10, 3 (July), 470-502.

Morrisett, G. 1995. Compiling with types. Ph.D. thesis, Carnegie Mellon University. Published

as CMU Tech Report number CMU-CS-95-226.

Myers, A. C. 1999. JFlow: Practical mostly-static information flow control. In 26th ACM

Symposium on Principles of Programming Languages. ACM Press, New York, NY, 228-241.

Nielson, F. and Nielson, H. R. 1992. Two-Level Functional Languages. Number 34 in Cambridge

Tracts in Theoretical Computer Science. Cambridge University Press, Cambridge, UK.

Peyton Jones, S., Hughes, J., Augustsson, L., Barton, D., Boutel, B., Fasel, J., Hammond,

K., Hinze, R., Hudak, P., Johnsson, T., Jones, M., Launchbury, J., Meijer, E., Peterson,
J., Reid, A., Runciman, C., and Wadler, P. 1999. Haskell 98: A non-strict, purely functional
language. http://www.haskell.org/onlinereport/.

Pierce, B. C. and Sangiorgi, D. 1999. Behavioral equivalence in the polymorphic pi-calculus.

Tech. Rep. MS-CIS-99-10, University of Pennsylvania. Apr. (Summary in 24th ACM Sympo-
sium on Principles of Programming Languages).

Pitts, A. M. 1996. Relational properties of domains. Inf. Comput. 127, 66-90.
Pitts, A. M. 2000. Parametric polymorphism and operational equivalence. Mathematical Structures in Computer Science 10, 1-39.

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.

44 * Dan Grossman et al.
Reynolds, J. C. 1974. Towards a theory of type structure. In Programming Symposium. Lecture

Notes in Computer Science, vol. 19. Springer-Verlag, New York, NY, 408-425.
Reynolds, J. C. 1983. Types, abstraction and parametric polymorphism. In Information Processing 83, R. E. A. Mason, Ed. Elsevier Science Publishers B. V. (North-Holland), Amsterdam,
513-523.
Sewell, P. and Vitek, J. 1999. Secure composition of untrusted code with wrappers and causality

types. Work in Progress http://www.cs.purdue.edu/homes/jv/publist.html.
Strachey, C. 1967. Fundamental concepts in programming languages. Unpublished Lecture

Notes, Summer School in Computer Programming.
Volpano, D. and Smith, G. 1997. A type-based approach to program security. In TAPSOFT'97,

Theory and Practice of Software Development. Lecture Notes in Computer Science, vol. 1214.
Springer-Verlag, New York, NY.
Wright, A. K. and Felleisen, M. 1994. A syntactic approach to type soundness. Inf. Comput. 115, 1, 38-94. Preliminary version in Rice Tech. Rep. 91-160.
Zdancewic, S., Grossman, D., and Morrisett, G. 1999. Principals in programming languages: A

syntactic proof technique. In 4th ACM International Conference on Functional Programming.
ACM Press, New York, NY, 197-207.

Received February 2000; revised September 2000; accepted November 2000

ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.