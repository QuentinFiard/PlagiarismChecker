

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Math. Struct. in Comp. Science (1998), vol. 8, pp. 559-591. Printed in the United Kingdom

cfl 1998 Cambridge University Press

Abstract B "ohm trees
P I E R R E - L O U I S C U R I E N
CNRS-ENS, LIENS, 45 Rue d'Ulm, 75230 Paris Cedex 05, France
Email: curien@dmi.ens.fr

Received 11 December 1996; revised 16 December 1997

We present a formalism of trees with pointers, called abstract B"ohm trees, that provide a
suitable abstract framework in which various cut-free proofs or normal terms of several
*-calculus based languages (including Pcf and Parigot's *u-calculus) can be faithfully
encoded. A simple abstract machine called the View Abstract Machine (VAM) allows us to
compute over abstract B"ohm trees. The VAM is closely related to Coquand's interaction
sequences and debates. The VAM execution over finite abstract B"ohm trees always
terminates. We next introduce an abstract notion of type that fits the purpose of
guaranteeing that the VAM cannot go into deadlock, i.e., that it always reaches a satisfactory
final state. Typed abstract B"ohm trees can be turned into a category - more naturally a
`multi-category' where the domains of arrows are sets of named objects or records. We then
go from the abstract to the concrete by giving examples. Our sets of abstract (typed) B"ohm
trees are relative to an alphabet and a set of types. By instantiating these two parameter sets
appropriately, we recover, successively: (j-long) typed B"ohm trees; Pcf trees as considered
in the game models of Hyland-Ong or of Abramsky-Jagadeesan-Malacaria; a notion of
classical B"ohm tree due to Herbelin that provides a classical version of Pcf trees in the style
of *u-calculus; and, finally, cut-free proofs in Novikov's infinitary propositional logic as
investigated by Coquand. In a companion paper, we investigate the operational aspects of
(untyped) B"ohm trees in more depth.

1. Introduction
The origin of this work lies in a convergence between two lines of research:
-- one originating from Lorenz-Lorenzen's game-theoretic interpretations of logical provability (Felscher 1986; Coquand 1995; Herbelin 1995),
-- the other from the more recent game models of Pcf (Hyland and Ong 1994; Abramsky

et al. 1995; Nickau 1996), which provide syntax-free accounts of an interesting infinite
term model for Scott's language Pcf (Milner 1977; Plotkin 1977).

It turns out that cut-free proofs of various sequent calculi on the one hand, and Hyland
and Ong's innocent strategies on the other, can all be expressed as trees with pointers, just
as *-terms (or more precisely B"ohm trees). In Section 2, we develop a framework of abstract
B"ohm trees that can be instantiated to different calculi and languages, including those
just mentioned. We introduce an abstract machine, called the View Abstract Machine,
or VAM, that performs computations over abstract B"ohm trees. It is an adaptation to

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 560
our general framework of Coquand's debates (Coquand 1995). Coquand has proved a
`no infinite chatting' property, which in our framework is a termination property: when
executed on finite abstract B"ohm trees, the VAM terminates. But the machine may stop
without reaching a satisfactory final state. A typical example is provided by the execution
of the (abstract B"ohm tree version of) \Delta \Delta  (where \Delta  = *x.xx).

In Section 3, we define a notion of abstract type, and we show that correctly typed
abstract B"ohm trees are executed without deadlock, in other words that for such trees
the VAM stops in a satisfactory final state that abstracts the *-calculus notion of `having
reached a head normal form'. We define a strong reduction machine, by which we mean, in
the terminology of the *-calculus, reduction to full normal form, as opposed to reduction
to head normal form. In the terminology of games, we mean computing the composition
of two strategies, as opposed to computing the first player's move of the composition
only.

In Section 4, we illustrate the wide coverage of abstract B"ohm trees. We treat, successively, B"ohm trees, Pcf trees, classical B"ohm trees and proofs in Novikov's infinitary
propositional logic.

2. Untyped abstract B"ohm trees
Throughout this paper, we assume a fixed set X whose elements are called abstract
variable names. We want to define an abstract notion of tree with pointers, described as
a set of branches, or positions.

Definition 2.1. (Position) We assume an alphabet A, and a special symbol *. We assume
that A, {*} and X are disjoint. We define opponent's moves, player's moves and positions
as follows:

-- An initial opponent's move is an element of {*} [ X (see Definitions 2.2 and 2.3,

respectively). An opponent's move is an element of A [ {*} [ X. We let a range over
A [ {*} [ X; if a 2 A, then a is called a non-initial opponent's move.

-- A player's move is either a pair [a,

i-] where a 2 A and i 2 ! (the set of natural

numbers), or an element of X, written [x, -]. We let ff range over A [ X and ^ range
over ! [ { }.
-- An even position is a non-empty alternating sequence r of opponent's moves and

player's moves, of the form:

a1[ff2,

^1-] * * * a

2n-1[ff2n,

^n-]

where a1 2 {*} [ X and a2l-1 2 A for all l > 1 (whence the terminology of initial and
non-inital opponent's moves). If ^l = , we say that [ff2l,

^l-] occurs free. For every l

such that 1 6 l 6 n and ^l 6= , we make the following assumption:

^l < l. (1)
We say that [ff2l,

^l-] is bound to a

2(l-^l)-1. An odd position q = a1[a2,

^1-] * * * a

2n-1 is

defined in the same way. We use p to denote an even position, an odd position or a

suffix of a position.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 561

Thus, as in de Bruijn's notation for *-terms (Abadi et al. 1991), pointers are represented
by numbers that count the number of opponent's moves between the pointing player's
move and the pointed at opponent's move.

Definition 2.1 presents the kit out of which actual data can be constructed, much as
cliques can be constructed out of coherence spaces, configurations out of event structures,
and so on (Amadio and Curien 1997). Here the data are called strategies, or abstract
B"ohm trees.

Definition 2.2. (Strategy) A strategy, or abstract B"ohm tree, is a tree consisting of a
non-empty set OE of even positions of the form *p satisfying the following properties:

(a) OE is closed under even non-empty prefixes, and
(b) q[ff1,

^1-], q[ff

2,

^2-] 2 OE implies [ff

1,

^1-] = [ff

2,

^2-].

Since OE is non-empty, it contains a unique position of the form *[ff,

^-], and [ff, ^-] is

called the abstract head variable of OE. If we do not insist on having Condition 2.1 (1), we
say that OE is a pseudo-strategy. A (pseudo-) strategy is called name-free if it contains no
occurrence of a player's move of the form [x, -].

Condition (b) says that, in a strategy, a `query' (that is, a position of odd length), if
answered, is uniquely so. Another way to put this is to say that OE is a tree of positions
such that branching is only allowed under player's moves. By Condition (b), any strategy
can be unambiguously presented as a partial function, also written OE, from odd positions
to player's moves [ff,

^-]. We also need the related notion of multi-strategy.

Definition 2.3. (Multi-strategy) We define a renaming operation on strategies as follows:

[x  OE] = {xr | *r 2 OE}
where x 2 X. A multi-strategy  is a union [x1  OE1] [ * * * [ [xn  OEn] of renamed
strategies (with all the xi distinct). We write  more suggestively as

 = [x1  OE1, . . . , xn  OEn].
We also write OEi = xi , for all i.
Remark 1. In the presentation of a strategy OE as a partial function q 7! OE(q), the player's
moves of q are actually irrelevant. The same remark applies to multi-strategies. We call
views sequences of opponent's moves (starting with *, or with x)#. Hence a strategy or a
multi-strategy can be presented as a partial function from views to player's moves. We
shall use this presentation below in the definition of the View Abstract Machine.

In Section 4 we shall see examples showing that abstract B"ohm trees allow us to
represent terms or proofs of various concrete calculi. This suggests that abstract B"ohm
trees in general are computational objects. We next show how to compute with abstract
B"ohm trees, or how to compose them. In Section 3, we shall present abstract typed B"ohm
trees as morphisms in a suitable (multi-) category. But just as the dynamics of *-calculus
is best understood in a type-free setting, our computation engine, called the View Abstract

# This terminology will become clear later in this section (see, in particular, Definition 2.5).

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 562
Machine, or VAM #, is best presented in an untyped setting. The VAM is the reformulation
in our framework of Coquand's debate machinery (Coquand 1995).

The goal of a VAM execution is to compute the abstract head variable of a composition
OE ffi  of

-- a strategy OE whose free player's moves are [x1, -], . . . , [xn, -] with
-- a multi-strategy  = [x1  x1, . . . , xn  xn].

(Think of a substitution M[~x  ~N] in the *-calculus.) The VAM execution consists of
playing opponent's moves in OE and  alternately, keeping pointers that serve to reconstruct
the positions in OE and  under which these moves actually take place. Formally, each
machine step consists of rewriting such a sequence \Gamma  of (pointing) moves, called a history,
to a history that extends \Gamma  by one move.

Definition 2.4. (History) A pointing opponent's move is a pair ha, mi, where a 2 A and
m ? 1 is a natural number. Initial opponent's moves do not carry pointers, but we call
them pointing moves also for uniformity.
A non-terminated history is a sequence of pointing opponent's moves. More precisely,
non-terminated histories are defined by the following syntax:

\Gamma  ::= * \Gamma  x \Gamma  ha, mi .

Terminated histories are sequences of the form \Gamma [x, -] or \Gamma [a,

0-], where \Gamma  is a nonterminated history. In the following, we let \Gamma  range over histories, i.e., over non-terminated
and terminated histories. We denote the successive elements of a history \Gamma  by \Gamma *1, \Gamma *2, . . . ,
\Gamma *n.

In a VAM execution, a terminated history corresponds to a final state of execution. The
analysis of final states will be carried out in Section 3 (see Definition 3.5).

We next define two useful functions on histories.

Definition 2.5. (Jump,view) Let \Gamma  be a non-terminated history.
1 We define a partial function jump\Gamma  from numbers to numbers by setting:

jump\Gamma (n) = m - 1 iff \Gamma *n = ha, mi.
2 The related function view \Gamma  takes a number n as argument and returns a sequence of

opponent's moves:

view \Gamma (1) = *

\Gamma *(2n) = x
view \Gamma (2n) = x

\Gamma *n = ha, mi
view \Gamma (n) = view \Gamma (m - 1) a

Recall (cf. Remark 1) that we have called sequences of opponent's moves views, and that
a strategy can be defined as a partial function from views to player's moves. Definition 2.5
offers a dynamic account of views: the function view \Gamma  allows us to reconstruct views in
OE and  from a history. Consider OE and  as strategies for two players and call them
Player and Opponent, respectively. Opponent plays opponent's moves in  while Player

# In a companion paper, Curien and Herbelin (1997), we present different variations of the VAM, including the

Strategic Abstract Machine, or SAM, which is a stack-free and abstract version of Krivine's abstract machine
(Curien 1991).

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 563

(1)v -! *

(2n)vb OE(view

\Gamma (2n - 1)) = [a,

i-] jumpi

\Gamma (2n - 1) = 2m - 1 > 1

\Gamma  -! \Gamma ha, 2m - 1i

(2n + 1)vb (view

\Gamma (2n)) = [a,

i-] jumpi

\Gamma (2n) = 2m

\Gamma  -! \Gamma ha, 2mi

(2n)vf

OE(view\Gamma (2n - 1)) = [x, -]

\Gamma  -! \Gamma  x

(2n + 1)v!

(view\Gamma (2n)) = [x, -]

\Gamma  -! \Gamma  [x, -]

(2n)v!

OE(view\Gamma (2n - 1)) = [a,

i-] jumpi

\Gamma (2n - 1) = 1

\Gamma  -! \Gamma [a,

0-]

Fig. 1. The View Abstract Machine
plays opponent's moves in OE. Each player in turn uses his view view \Gamma (n) (where n is the
length of the current history) to determine his next move, in a way that is explained
below in detail. The notion of view was first defined in Hyland and Ong (1994). Hyland
and Ong emphasise the idea of view by building it into the definition of strategy itself.
In our terms, they define strategies as functions from histories to player's moves that are
neither history-free nor completely history-sensitive, by which we mean that Player (or
Opponent) is allowed to use only part of the history - his view, whence the terminology
- to determine his next move. We refer the reader to Hyland and Ong (1994) for more
intuition on the notion of view.

The rules of the VAM are given in Figure 1. We consider it implicit that

-- the execution is relative to a fixed pair of a strategy OE and of a multi-strategy , and
-- there is a counter recording the current machine step number n. The succession of the

steps is: 1, 2, 3, 4, . . . , corresponding to alternating opponent's moves in OE and :

1 initial opponent's move in OE
2 opponent's move in 
3 opponent's move in OE* * *

Here is an informal explanation of the rules of the VAM. Rule (1)v initiates the
computation: the top move of OE may be considered as an initial query. Suppose that the
machine has just performed 2n - 1 steps, for some n, the last step consisting of a move

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 564
in OE. Then the next move will be played in . The machine computes the view at step
2n - 1, and then reads the value [ff,

^-] of OE for this view. At this stage, we already know

that ff is the move played at step 2n. There are two cases:
1 If ff = x (and thus ^ = ), the computation proceeds by playing the initial move x of

. This can be considered as the communication of OE and  along the channel x.
2 If ff = a and ^ = i, the iteration of the function jump\Gamma  allows us to transform the static

information i into the dynamic information 2m - 1. There are again two cases.

(a) If 2m - 1 = 1, then a points to the initial move of the history, which constitutes an

answer to the initial query, and terminates the execution.
(b) If 2m - 1 > 1, the dialogue is not terminated: at step 2m - 2, a (pointing) move had

been played in , and the move a should be played in  right under that move:
this is what the pointing information ha, 2m - 1i in the conclusion of rule (2n)vb is
taking care of#.
Now consider the situation after an even number of steps. One similarly computes a view,
and the value [ff,

^-] of  for this view. We revisit the above cases as follows:

1 If ff = x (and thus ^ = ), a `free variable' of  has been reached, and this provides an

answer to the initial query.
2 If ff = a and ^ = i, the computation proceeds as in subcase 2(b) above. There is no

counterpart for the subcase 2(a), because if a is dynamically bound to the (copy of
the) initial move x of  visited at step 2m, the dialogue should be continued, because
this step 2m had been performed in reaction to a step 2m - 1 played in OE.

Notice that the VAM stops after a step (n)v!: since we have not defined the view of a
terminated history, there is no way to match the assumption of any rule labelled with
n + 1 (see Section 3 for a stronger framework where the machine can proceed further).

Remark 2. The following two kinds of interaction, corresponding to the two parts a and
i in the player's move [a,

i-] present in the assumption of the rules (n)b

v, respectively, are

combined in the VAM.

-- Tree interaction The determinism of the strategy and of the multi-strategy allows us

to resolve the non-determinism of the choice of the next opponent's move in the
multi-strategy.
-- Pointer interaction The pointer structure allows us to determine the location of the

next move to play.

Hence the two interactions correspond to the respective questions: `which is the next move
to play?', and `where is this move to be played?'. They form the heart of the computational
engine of the VAM.

Coquand has proved, in his terminology, that all debates between finite strategies
terminate. In the present framework, his result implies that the VAM execution relative
to finite OE and  terminates. For completeness, we include a proof of Coquand's result

# The move a in  can be understood as `fetching the value of the bound variable' [a, i-]. We refer to Curien

and Herbelin (1997) for precise connections between the VAM and environment abstract machines.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 565
(Theorem 2.15), which is directly adapted from (a preliminary version of) Coquand (1995):
the present proof is classical, while the proof published in Coquand (1995) is constructive.
The proof is purely combinatorial, and only uses the pointer structure of the growing
history (forgetting about the alphabet A) and the boundedness of views.

The following definition is taken from Coquand (1995), up to some change of notation.

Definition 2.6. (Interaction sequence) Let N be a natural number ? 2, or infinite. An
interaction sequence over the interval [1, N] of ! is a pair (V , f) where

-- f is a partial function from [1, N] to itself, and where
-- V is a function from [1, N] to P (!),

satisfying

V (n) = ae {n} [ V (f(n) - 1) if f(n) is defined{n} otherwiseae

f(1) is undefined
(f(n + 1) defined ) f(n + 1) 2 V (n)) .

Lemma 2.7. If (V , f) is an interaction sequence, then, for all n
1 (f(n) defined ) f(n) < n),
2 V (n) ` {1, . . . , n}.

Proof. We write 1(n) to mean that Property 1 holds for n, and similarly for 2. We prove
successively that

-- 2(1): This is obvious since V (1) = {1}.
-- 2(n) ) 1(n + 1): Since f(n + 1) 2 V (n), we have f(n + 1) 2 {1, . . . , n}, and hence

f(n + 1) < n + 1.
-- 1(n) ) 2(n): If V (n) = {n}, then a fortiori V (n) ` {1, . . . , n}. If V (n) = {n} [ V (f(n) - 1),

we conclude by induction since f(n) < n implies a fortiori f(n) - 1 < n.

In an interaction sequence (V , f), V is entirely determined by f, as the following lemma
shows.

Lemma 2.8. Let V and f be of the types indicated in Definition 2.6. Let g be defined by

g(n) = ae f(n) - 1 if f(n) is definedundefined otherwise.
Then (V , f) forms an interaction sequence if and only if, for all n ? 1

V (n) = {gi(n) | i ? 0 and gi(n) defined}
(f(n + 1) defined ) f(n + 1) = gi(n) for some i ? 0) .

Proof. Let (V , f) be an interaction sequence. By Lemma 2.7, we have g(n) < n for any
n. Hence, given n, there exists an i such that gi(n) is defined and g(i+1) is not defined. By
unfolding we get

V (n) = {n} [ V (g(n)) = {n, g(n)} [ V (g2(n)) = * * *

= {n, g(n), . . . , gi-1(n)} [ V (gi(n)) = {n, g(n), . . . , gi(n)} .

The converse direction is straightforward.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 566
Definition 2.9. (Combinatorial view) Let \Gamma  be a non-terminated history. We define two
functions f\Gamma  and V\Gamma  as follows:

f\Gamma (n) = m , \Gamma *n = ha, mi

V\Gamma (1) = {1}

\Gamma *(2n) = x
V\Gamma (2n) = {2n}

\Gamma *n = ha, mi
V\Gamma (n) = {n} [ V\Gamma (m - 1)

We call the V\Gamma (n)'s the combinatorial views associated with \Gamma . (Clearly, for all n, the
length of view \Gamma (n) is the cardinal of V\Gamma (n).)

Lemma 2.10. The pair (V\Gamma  , f\Gamma  ) of Definition 2.9 forms an interaction sequence.

Proof. The two rules of the VAM adding a pointing move ha, mi to the history are
(2n)bv and (2n + 1)bv. By considering the assumptions of these rules, we obtain, for all k ? 1
(even or odd),

f\Gamma (k) = jumpi\Gamma (k - 1) for some i ? 0.
Hence the condition of Lemma 2.8 is satisfied.

Coquand's argument by contradiction consists in proving that if an execution does not
terminate, there must exist an infinitely growing (combinatorial) view.

Definition 2.11. We write m OE n if n < m and n - 1 2 V (m - 1).
By Lemmas 2.8 and 2.7, an alternative definition of OE is

m OE n , n - 1 2 g(V (m - 1)) , n 2 f(V (m - 1)) . (2)
Lemma 2.12. If f(f(n)) is defined, n OE f(f(n)).

Proof. We use the alternative definition (2) of OE: we have f(n) 2 V (n - 1), and hence
f(f(n)) 2 f(V (n - 1)).

For the next lemma, we adjust the definition of interaction sequence in order to be able
to manipulate extracted interaction sequences. Replacing [1, N] by a sequence n1, . . . , nk
such that n1 < n2 < * * * < nk, we now define

g(np) = nq-1 if f(np) = nq

V (np) = ae {np} [ V (g(np)) if f(np) is defined{n

p} otherwise

and the condition to satisfy is now

(f(np+1) defined ) f(np+1) 2 V (np)).
If this condition is satisfied, we say that (V , f) is an interaction sequence on n1, . . . , nk. We
likewise define an infinite interaction sequence on a sequence (np)p?0. A sensitive point
here is that V now depends both on f and on (np)p?0. We call V the combinatorial view
function associated with f and (np)p?0.

Definition 2.13. Suppose that (V , f) is an infinite interaction sequence on (np)p?0, and let
(n0p)p?0 be an infinite subsequence of (np)p?0. We say that (V , f) induces an interaction
subsequence on (n0p)p?0 if the following conditions hold:

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 567
1 (n0p)p?0 is stable under f, that is,8

p (f(n0p) defined ) 9 q (f(n0p) = n0q)).
2 For all p, V 0(np) ` V (np), where V 0 is the combinatorial view function associated with

f and (n0p)p?0.

Remark 3. Condition 2 of Definition 2.13 has the following consequence: if we have m OE n
relatively to V 0, we also have m OE n relatively to V .

We can now state the key lemma.
Lemma 2.14. Let (V , f) be an infinite interaction sequence on (np)p?0. One of the following
properties hold:

1 either for all q there exists r > q such that nq = f(nr),
2 or there exists a subsequence (n0p)p?0 of the form

n1, n2, . . . , np-1, mp, mp+1, . . .
such that mp OE np and on which (V , f) induces an interaction subsequence.
Proof. Suppose that Property 1 does not hold, and let q be such that nq 62 f((np)p?0).
Let np = f(nq) (the case where f(nq) is undefined is treated similarly), and consider the
sequence

(n0p)p?0 = n1, n2, . . . , np-1, nq+1, nq+2, . . . .
We first show nq+1 OE np, that is, np 2 f(V (nq)). This is obvious from np = f(nq) and
nq 2 V (nq). We next show that the subsequence (n0p)p?0 is stable under f, that is, that
f(nr) 62 {np, np+1, . . . , nq}, for all r > q. We call this property P (r) and prove it together
with the following related property, for any r ? q, which we call Q(r):

V (nr) " {np, np+1, . . . , nq-1} = 6 .
We prove successively:
-- Q(q): This is obvious by Lemma 2.7, since V (nq) = {nq} [ V (np-1).
-- Q(r - 1) ) P (r): Since f(nr) 2 V (nr-1), we have f(nr) 62 {np, np+1, . . . , nq-1} by Q(r - 1).

We also have f(nr) 6= nq by assumption, so P (r) holds.
-- (P (r), Q(q), . . . Q(r - 1)) ) Q(r) (r > q): We have V (nr) = {nr} [ V (ns-1), where

ns = f(nr). Clearly, nr 62 {np, np+1, . . . , nq-1}. We know by P (r) that ns 62 {np, np+1, . . . , nq}.
There are two cases: if s < p, then a fortiori s - 1 < p, which ensures V (ns-1) "{

np, np+1, . . . , nq-1} = 6; if s > q, then s - 1 ? q, so we can conclude using Q(s - 1).

Finally, we have to check Condition 2 of Definition 2.13. Let g0 be the function defined
by g0(n0p) = n0q-1 if f(n0p) = n0q. The only possibilty giving g0(nr) 6= g(nr) is f(nr) = nq+1.
Then g(nr) = nq, while g0(nr) = np-1 = g(np) = g(g(nr)). Condition 2 then follows from
Lemma 2.8.

Theorem 2.15. Let (V , f) be an infinite interaction sequence. The following properties
hold:

1 The relation OE is not well-founded.
2 The set {](V (n)) | n ? 1} (where ](V (n)) denotes the cardinal of V (n)) has no upper

bound.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 568

Proof. Suppose that OE is well-founded. We can construct a sequence (mp)p?0 as
follows. For each p, we choose mp+1 OE-minimal among the set of all m's for which f
induces an interaction on an infinite subsequence starting with m1, m2, . . . , mp, m. (This set
is maintained non-empty by the induction.) By construction and Lemma 2.14, we can
extract from (mp)p?0 an infinite sequence (np)p?0 such that np = f(np+1) for all p. This
implies n2p = f(f(n2(p+1))), and hence n2(p+1) OE n2p by Lemma 2.12, and contradicts the
well-foundedness assumption. Notice the implicit use of Remark 3 in the above argument:
as the construction proceeds, successive subsequences are extracted, and the OE-minimality
is meant relative to each of the successive subsequences; Condition 2 of Definition 2.13
allows us to inherit the well-foundedness of OE along the construction.

We next prove that views are unbounded. Since OE is not well-founded, there exists a
subsequence (ln)n?0 such that ln+1 OE ln, for all n. If we set kn = ln - 1, this can be rephrased
as (kn < kn+1 and kn 2 V (kn+1)). In particular, all the kn's are distinct. We observe, as an
immediate consequence of the characterisation of V given in Lemma 2.8, that, say,

(kn-1 2 V (kn) and kn 2 V (kn+1)) ) kn-1 2 V (kn+1).
It follows that {k1, . . . , kn} ` V (kn+1), and hence the conclusion follows.
Proposition 2.16. If OE and  are a finite strategy and a finite multi-strategy, respectively,
then the VAM execution relative to OE and  terminates.

Proof. Suppose that the VAM does not terminate, and let \Delta  be the infinite history
whose finite prefixes are the histories \Gamma  such that -!? \Gamma . Let (V\Delta , f\Delta ) be the associated
infinite interaction sequence (cf. Lemma 2.10). We observe that

-- the combinatorial views have an unbounded length, by Theorem 2.15, while
-- the views have a bounded length, being in the domain of definition of OE or .

This yields a contradiction, since the lengths of the views are the cardinals of their
underlying combinatorial views.

In order to illustrate the VAM, we anticipate Subsection 4.1 and describe a compilation
of (untyped) * normal forms, or finite B"ohm trees, as defined by the following syntax:

M ::= *~x.W W ::= yM1 * * * Mn (n ? 0) .
We take as alphabet A = !. We perform the following transformation on the tree
representation of a normal form M:

*~x.yz ""-- -
M1 * * * Mn

The node `*~x.y' is split into two moves: `*~x ' is associated to the opponent's move * and `y'
to a player's move y. When y is free, y is [y, -]. Otherwise, y is [n,

i-] such that the binder

is found 2i + 1 moves above, and n denotes the position of y in the multiple abstraction
*y1 * * * ym that binds it, that is, y = yn. In the terminology of Danos and Regnier, n is
called the rank and i is called the lift. The pairs (n, i), which we call B"ohm indices, also
appear in Huet (1993). Finally, if OEi is the translation of Mi for all i, the head opponent's

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 569

(*~x.yM1 * * * Mn)L = {*yL,~x} [

i=1***n{*

yL,~xir | *r 2 (Mi)L,~x}

where

xnil = [x, -]

x = xi ~x = x1 * * * xk

xL,~x = [i,

0-]

xL = [i,

j-]

xL,~y = [i,

j+1-]

xL = [x, -]

xL,~y = [x, -]

Fig. 2. Compilation of untyped * normal forms
move * of OEi is replaced by i. In this way, we record that Mi is the i-th argument of y. To
summarise, the translation of M = (*~x.yM1 * * * Mn) is the following tree:

*yz ""-- -
[1  OE1] * * * [n  OEn]
Formally, we define in Figure 2 a translation function involving a function that takes a
list L of vectors of variables and a term M, and returns a strategy ML. The compilation
of a term M is defined as Mnil . We adapt this compilation to a typed setting in Section 3,
and show that it defines a bijective transformation to a suitable set of typed strategies.

Example 2.17. We display the computation of (u(*x.u(*y.x)))nil ffi [u  (*r.r(r(z)))nil ]. The
boxed comments give the correspondence with the source terms.

-- Strategy for (u(*x.u(*y.x))):

(*

[u, -] 8!:

(*x

1 [u, -] ( (*y1

x

[1,

1-]

-- Multi-strategy for [u  (*r.r(r(z)))]:

(*r

u

r
[1,

0-] 8!: (

1

r
[1,

1-] ae (

1 [z, -]

The execution of this example by the VAM is as follows (the step numbers are placed
below the successive moves, as a help to the reader):*

u h1, 2i u h1, 4i h1, 3i h1, 2i u h1, 8i h1, 7i [z, -]
1 2 3 4 5 6 7 8 9 10 11

The successive views are as follows:

view \Gamma (1) = * view \Gamma (2) = u view \Gamma (3) = *1
view \Gamma (4) = u view \Gamma (5) = *11 view \Gamma (6) = u1
view \Gamma (7) = *1 view \Gamma (8) = u view \Gamma (9) = *11
view \Gamma (10) = u11

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 570
3. Typed abstract B"ohm trees
We introduce a set of abstract types and revisit the definitions of Section 2, imposing type
constraints.

Definition 3.1. (Typed position) In addition to the alphabet A, we assume a set T of
abstract types, or types for short, together with a partial function ( ) from T * A to T ,
written (oe, a) 7! oea. A typed position is a position all of whose moves are decorated with
a type superscript as follows:

aoe11 [ff2,

^1-]oe2 * * * aoe2n-1

2n-1[ff2n,

^n-]oe2n.

We say that a1[ff2,

^1-] * * * a

2n-1[ff2n,

^n-] is the underlying (untyped) position.

Definition 3.2. (Typed strategy) A typed strategy, or typed abstract B"ohm tree, is a set OE
of typed positions whose underlying set of positions forms a strategy and that satisfies
the following two properties:

(1) If q[ff,

^-]oe 2 OE, then, for any o/ 2 T and b 2 A

(q[ff,

^-]oebo/ is answered in OE) , (oe

b is defined and oeb = o/).

(2) If q[a,

i-]oe 2 OE and if [a, i-] is bound to bo/ in q, then oe = o/

a.

Moreover, we require that all occurrences of a free player's move [x, -] bear the same
type. The type decorating * is called the type of OE.

For economy of notation, we shall freely omit the type decorations on moves when
they are not relevant to the discussion. But the reader should keep in mind that they are
implicitly carried through the constructions in the obvious way.

We now give a typed version of pseudo-strategies, relative to a list \Sigma  of types.

Definition 3.3. Let OE be a set of typed positions whose underlying set of positions forms
a pseudo-strategy, and let \Sigma  be a list of types. Let r = q[a,

i-]oe 2 OE of length 2l such

that [a,

i-] is not bound in OE. We write r\Sigma  for the (i - l + 1)-th type in the sequence \Sigma .

We assume therefore that \Sigma  has length at least i - l + 1 for all r = q[a,

i-]oe 2 OE such

that [a,

i-] violates Condition 2.1 (1). We call OE a typed pseudo-strategy relative to \Sigma  if it

satisfies the conditions listed in Definition 3.2 plus the following one:
(3) If r = q[a,

i-]oe 2 OE, and if [a, i-] is not bound in OE, then oe = (r\Sigma )

a.

As for strategies, the type decorating * is called the type of OE.

In order to establish precise correspondences between concrete syntaxes of terms or
proofs and abstract B"ohm trees relative to appropriate A, T , and ( ), we shall rely on the
following simple decomposition property for typed pseudo-strategies.

Lemma 3.4. Let OE and \Sigma  be such that OE is a typed pseudo-strategy relative to \Sigma . We can
write uniquely

OE = {*o/[ff,

^-]oe} [ ( [

{a|oea is defined}{*

[ff,

^-]ap | *p 2 OE

a}).

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 571
Moreover, all OEa's are pseudo-strategies relative to \Sigma , o/. We use the following synthetic
notation for the decomposition:

OE ; *o/[ff,

^-]oe, {OE

a | oea is defined}.

or, if {a | oea is defined} = {a1, . . . , an}:

OE ; *o/[ff,

^-]oe, OE

a1, . . . , OEan.

Proof. The underlying untyped positions of OEa inherit the closure properties of the
corresponding underlying untyped positions of OE, and hence form a pseudo-strategy.
Condition (1), which is entirely local, is also clearly inherited from Condition (1) for OE.

For Conditions (2) and (3), there are three cases. Let r = *q[b,

i-]oe 2 OE

a.

-- If [b,

i-] is bound in r, then it is a fortiori bound in *[ff, ^-]aq[b, i-], and Condition (2)

follows from Condition (2) for OE.
-- By contraposing this implication, if [b,

i-] is not bound in *[ff, ^-]aq[b, i-], then

Condition (3) follows from Condition (3) for OE.
-- If [b,

i-] is bound in *o/[ff, ^-]aq[b, i-] but not in r, it is bound to *o/ in OE, so

Condition (3) relative to \Sigma , o/ follows from Condition (2) for OE.
We now show that typed strategies and pseudo-strategies are deadlock-free. We first
define the legal final states of the VAM.

Definition 3.5. (Legal final state) We say that the VAM is in a final (F) state when it has
reached a step (2n + 1)v! , and that it is in a final (B) state when it has reached a step (2n)v! .
(F and B stand for `free' and `bound', respectively.) A state is called legal if it is either (F)
final or (B) final.

At an (F) final state, the computation terminates because a free variable of  has been
met. This is what happens in Example 2.17. We can interpret this as a demand to the

input multi-strategy. A simple example of (B) final state is obtained by composing *[1,

0-]

(corresponding to (*x.x)) with an arbitrary multi-strategy: the execution results in the
terminated history *[1,

0-]. See Section 4.2 for another flavour of (B) final state.

In both cases (F) and (B), the machine stops because a `head normal form' has been
reached. More precisely, for * normal forms, the two cases of termination correspond to
the following partition of head normal forms:

(*~x.y ~M) (y free) (F)
(*~x.x ~M) (x bound) (B) .

In Figure 3, we present a typed version of the VAM. The rules are those of the VAM,
with the addition that the type decorations indicated by OE and  are faithfully recorded.
The typed VAM executes the composition of

-- a strategy OE whose free player's moves are [x1, -]oe1, . . . , [xn, -]oen with
-- a multi-strategy  = [x1  x1, . . . , xn  xn] whose initial moves xi are decorated

with the respective types oei. In other words, xi and xi (bound to xi) must have the
same type.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 572

(1)v

OE has type oe

-! *oe

(2n)vb OE(view

\Gamma (2n - 1)) = [a,

i-]oe jumpi

\Gamma (2n - 1) = 2m - 1 > 1

\Gamma  -! \Gamma ha, 2m - 1ioe

(2n + 1)vb (view

\Gamma (2n)) = [a,

i-]oe jumpi

\Gamma (2n) = 2m

\Gamma  -! \Gamma ha, 2mioe

(2n)vf

OE(view\Gamma (2n - 1)) = [x, -]oe

\Gamma  -! \Gamma  xoe

(2n + 1)v!

(view\Gamma (2n)) = [x, -]oe

\Gamma  -! \Gamma  [x, -]oe

(2n)v!

OE(view\Gamma (2n - 1)) = [a,

i-]oe jumpi

\Gamma (2n - 1) = 1

\Gamma  -! \Gamma [a,

0-]oe

Fig. 3. The typed VAM

Proposition 3.6. The execution of a typed strategy composed with a typed multi-strategy
by the typed VAM can only terminate in a legal final state.

Proof. The proposition is proved by induction on the length of the execution. Let \Gamma  be
a non-terminated history resulting from the n first steps of execution. We have to show
that nothing prevents the next step being executed. We claim that O/(view \Gamma (n)) is defined,
where O/ is OE or  depending on the parity of n. We first show how to conclude from the
claim. The statement follows immediately from the claim for rules (2n)vf and (2n + 1)v! .

For all the other rules, we have to show that if O/(view \Gamma (n)) = [a,

i-], then jumpi

\Gamma (n) is

defined. By Condition 2.1 (1), view \Gamma  is long enough to have a suffix ai * * * a0. Unfolding

the recursive definition of view \Gamma , we have

view \Gamma (n) = view \Gamma (jump\Gamma (n))a0 = view \Gamma (jumpi\Gamma (n))ai-1 * * * a0 . (3)
Hence jumpi\Gamma (n) is defined, and the next step can be performed.

We are left with the proof of the claim. If \Gamma *n = *, the claim follows from the nonemptyness of OE. If \Gamma *n = x, the claim follows similarly from the non-emptyness of .
If \Gamma *n = ha, mi, the last rule applied is (n)vb. Suppose, say, that n is even. Reading the
assumptions, and using Equation (3) above as well as Condition (2) of Definition 3.2, we
get that m = jumpi\Gamma (n) for some i and that oe = o/a, where o/ is the type decoration of \Gamma *m.
By the definition of the typed VAM, o/ is also the type decoration of (view \Gamma (m - 1)). Since
view \Gamma (n) = view \Gamma (m - 1) a, we conclude using Condition (1) of Definition 3.2.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 573

In order to appreciate the previous proposition, we should see how it fails for nontypable strategies. We show how the VAM executes \Delta \Delta  = (*x.xx)(*x.xx), or in compiled
form {*

[x, -], *[x, -]1[x, -]}[x  {x[1,

0-], x[1, 0-]1[1, 1-]}].

The execution by the VAM results in the following history:

* x h1, 2i x h1, 4i
1 2 3 4 5

with the following associated views:

view \Gamma (1) = * view \Gamma (2) = x view \Gamma (3) = *1 view \Gamma (4) = x view \Gamma (5) = *11 .
The VAM stops after step (5)vb without having reached a legal final state.
Remark 4. The VAM could have computed a bit further if the strategy had been `jexpanded': the compilation of *x.x(*y.xy) answers the view *11 with the compilation of
y. In the companion paper, Curien and Herbelin (1997), we show how the VAM can
be adapted to mimic j-expansions dynamically, yielding a non-terminating computation
(involving unbounded views, cf. Proposition 2.16).

We now formulate a strong version of the VAM, called Strong VAM, which can compute
full normal forms. The machine works on demand. Given a strategy OE and a multi-strategy
, it builds any position of the composition OEffi, provided it is asked by an external agent,
called the user, to progressively do so. We signal the user's demands and the answers to
the user by underlining. The user raises an initial query, call it * in first approximation.
The VAM is started, and runs until it reaches a legal final state that produces a player's
move [ff,

^-] answering the initial query. We then know that *[ff, ^-] 2 OE ffi . The user

may raise a new query *[ff,

^-]b. A new run of the VAM is started, until a new `final' state

is reached. If the final player's move is bound, should we bind it to * or to b? To keep
a proper scoping, we use a mechanism of names. This leads to the following notion of
strong history and the following extension of the function view. We do not include type
decorations to avoid overloading the notation.

Definition 3.7. (Strong history) The syntax of strong histories is as follows:

\Gamma  ::= ** \Gamma a* \Gamma x \Gamma ha, mi \Gamma [a,

*-] \Gamma [x, -]

where * ranges over an infinite set N of names. The underlined moves correspond to
the progressive formation of the positions of the composition (see Definition 3.9 and
Proposition 3.11).

Definition 3.8. (Strong view) The strong views associated with a strong history are defined
by the rules of Definition 2.5 plus the following one:

\Gamma *n = a*
view \Gamma (n) = view \Gamma (n - 2) a

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 574

(1)s?

* new

-! (** ?)

(2n)sb OE(view

\Gamma (2n - 1)) = [a,

i-] jumpi

\Gamma (2n - 1) = 2m - 1 \Gamma *(2m - 1) 6= b*

(\Gamma  ?) -! (\Gamma ha, 2m - 1i ?)

(2n + 1)sb (view

\Gamma (2n)) = [a,

i-] jumpi

\Gamma (2n) = 2m \Gamma *2m 6= b*

(\Gamma  ?) -! (\Gamma ha, 2mi ?)

(2n)sf

OE(view\Gamma (2n - 1)) = [x, -]

(\Gamma  ?) -! (\Gamma x ?)

(2n)s! OE(view

\Gamma (2n - 1)) = [a,

i-] jumpi

\Gamma (2n - 1) = 2m - 1 \Gamma *(2m - 1) = b*

(\Gamma  ?) -! (\Gamma [a,

*-] !)

(2n + 1)s!

(view\Gamma (2n)) = [a,

i-] jumpi

\Gamma (2n) = 2m \Gamma *2m = b*

(\Gamma  ?) -! (\Gamma [a,

*-] !)

(2n)s?

(view\Gamma (2n - 1)a) defined * new

(\Gamma  !) -! (\Gamma a* ?)

(2n + 1)s?

OE(view\Gamma (2n)a) defined * new

(\Gamma  !) -! (\Gamma a* ?)

Fig. 4. The Strong VAM

The rules of the Strong VAM are displayed in Figure 4. The rules are
-- those of the VAM (up to some change of notation), plus
-- two new rules that formalise the user's new demands.

The execution proceeds by progressively extending a strong history, which is flagged with
a sign ? or !, where

? indicates that the machine is engaged in an internal dialogue whose goal is to answer

a user's query,
! indicates that the last user's query has just been answered.

Hence the flag ! stays for one step exactly.
Remark 5. While the VAM is deterministic, the transition relation of the Strong VAM is
non-deterministic: at steps ns?, the choice of the move a is free, as long as the extended
view is in the domain of OE or . If the user knows which view he wants to explore, the

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 575
evaluation is deterministic with respect to that goal. We say that the execution is guided
by the user.

Finally, we need to read back the positions of the composition, i.e., to strip off the
moves that correspond to the internal dialogue of the machine. This is formalised in the
following definition, which also takes care of installing the nameless notation for bindings.

Definition 3.9. (Readback) The following function readback takes as argument a suffix of
a strong history and an auxiliary list L of names, and returns a position.

readbacknil (**\Gamma ) = * readback*(\Gamma )
readbackL(a*\Gamma ) = a readback**L(\Gamma )
readbackL(x\Gamma ) = readback L(\Gamma )
readbackL(ha, mi\Gamma )) = readback L(\Gamma )

readbackL([a,

*-]\Gamma ) = [a, *L-] readback L(\Gamma )

readbackL([x, -]\Gamma ) = [x, -] readbackL(\Gamma )
where

*u*L = ae 0 if u = **

L + 1 if u 6= *.

For a strong history we set readback(\Gamma ) = readback nil (\Gamma ).

We now have all the material to define a `category' of typed abstract B"ohm trees. We
first define a notion of named multi-category that is well adapted to our purposes.

Definition 3.10. (Named multi-category) A named multi-category consists of a collection
of objects and a collection of morphisms; each morphism f has a target object B, and
has a source consisting of a context of objects, that is, a list \Gamma  = x1 : A1, . . . , xn : An
of named objects, with x1, . . . , xn all distinct. One writes f : \Gamma  ! B. For each context
\Gamma  = x1 : A1, . . . , xn : An and each i 6 n, there exists a projection arrow ssi from \Gamma  to Ai.
Moreover, there exists a composition operation: if \Gamma  = x1 : A1, . . . , xn : An and \Delta  are
contexts, and if g1 : \Delta  ! A1, . . . , gn : \Delta  ! An, f : \Gamma  ! B are morphisms, then there is a
composition written f ffi [x1  g1, . . . , xn  gn] from \Delta  to B. The usual monoid laws are
required:

(f ffi [x1  g1, . . . , xn  gn]) ffi [~y  ~h] = f ffi [x1  g1 ffi [~y  ~h], . . . , xn  gn ffi [~y  ~h]]
f ffi [x1  ss1, . . . , xn  ssn] = f
ssi ffi [x1  g1, . . . , xn  gn] = gi.

Proposition 3.11. Let A, T , and be fixed. Typed abstract B"ohm trees form a named
multi-category. The objects are the elements of T , and a morphism from \Gamma  to oe is a typed
abstract B"ohm tree OE such that all the occurrences of moves of the form [x, -]oe in OE are
such that x : oe is in \Gamma . The projection morphisms are ssi = *[xi, -], and the composition
is given by

OE ffi  = {readback (\Gamma ) | -!? (\Gamma  !)}.
The right-hand side of this definition does not mention OE,  explicitly, but one should
keep in mind that the transition relation -! is parametrised by OE and .

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 576

M ::= *~x : ~oe.W W ::= yM1 * * * Mn (n ? 0) .

\Gamma *y = oe1 ! * * * ! oen ! C \Gamma  ` M1 : oe1 * * * \Gamma  ` Mn : oen

\Gamma  ` yM1 * * * Mn : C

\Gamma ,~x : ~oe ` W : C
\Gamma  ` *~x : ~oe.W : ~oe ! C

Fig. 5. Typing rules for finite B"ohm trees

Proof. We first check that OE ffi  is a strategy. It is non-empty by Propositions 2.16 and
3.6. If readback (\Gamma ) 2 OE ffi , then for each even prefix r of readback (\Gamma ), there exists a prefix
\Delta  of \Gamma  such that -!

? (\Delta  !) -!? (\Gamma  !).

Hence OE ffi  is closed under prefixes. The last condition (no branching at an opponent's
move) follows from the observations made in Remark 5. The proof of associativity
is tedious, but conceptually easy. Both sides (OE ffi [x1  x1, . . . , xn  xn]) ffi O/ and
OE ffi [x1  x1 ffi O/, . . . , xn  xn ffi O/] of the associativity equation are equal to the result of
the three-ary composition OE ffi [x1  x1, . . . , xn  xn] ffi O/, which can be computed by a
strong VAM parametrised by OE, , and O/.

4. Some examples of abstract B"ohm trees
4.1. j-long B"ohm trees
We revisit the translation of finite B"ohm trees given in Section 2 in a typed setting. We
restrict our attention to j-long normal forms, as defined by the following typing system.
We assume a collection of basic types C, C1, C0, . . . . The simple types are then generated
by the following syntax:

oe ::= C oe ! o/.
The j-long normal forms, or finite j-long typed B"ohm trees, or finite typed B"ohm trees for
short, are defined via typing judgements \Gamma  ` M : oe, where \Gamma  is a context consisting of a
list of non-empty vectors ~x : ~oe of typed variables. In each of these vectors ~x = x1 * * * xn,
the variables x1, . . . , xn are supposed distinct. The following auxiliary function allows us
to retrieve the type \Gamma *y of a free variable y from the context \Gamma :

(\Gamma ,~x : ~oe)*y = ae \Gamma *y if y does not appear in ~xoe

i if y = xi.

If ~oe = oe1, . . . , oen, we adopt the abbreviation ~oe ! ^ for oe1 ! * * * ! oen ! ^. If n = 0, we
then just mean ^. The typing rules are given in Figure 5. Notice that the bodies W are
forced to have a basic type, that is, variables must be fully applied and terms of function
types must be fully abstracted according to their type. The j-long format is essential to
guarantee the completeness of the VAM execution (cf. Remark 4).

For the other end, as anticipated in Section 2, we take A = ! as alphabet, and the above
set of simple types as set T of abstract types. We shall define the translation of closed finite
typed B"ohm trees. As with the untyped case, the translation function involves a function

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 577

y\Gamma ,~x:~oe = [i,

j-]o/1!***o/n!C

(*~x : ~oe.y ~M)\Gamma  = {*~oe!Cy\Gamma ,~x:~oe} Sk=1***n{*~oe!Cy\Gamma ,~x:~oeko/k r | *o/k r 2 (Mk)\Gamma ,~x:~oe}
where

x = xi ~x = x1 * * * xk

x\Gamma ,~x:~oe = [i,

0-]oei

x\Gamma  = [i,

j-]o/ and x does not appear in ~y

x\Gamma ,~y:~oe = [i,

j+1-]o/

Fig. 6. Compilation of typed B"ohm trees
that takes a context \Gamma  and a term M, and returns a strategy M\Gamma . This function itself
uses an auxiliary function that takes a context \Gamma  and a variable x and returns a player's
move decorated with a type. These functions are defined in Figure 6. The compilation of
a closed finite typed B"ohm tree M is defined as Mnil . A type decoration oe in Mnil should
be read as follows:

(player's move) oe = type of the corresponding variable
(opponent's move) oe = type of the corresponding subterm.

Remark 6. We indicate briefly how the compilation can be extended to open typed B"ohm
trees. Suppose we want to compile M such that \Gamma  ` M : oe. As a first try, we might define
the compilation by M\Gamma , but then the free variable occurrences x are not transformed into

[x, -], but in those `hybrid' player's moves [i,

j-] that are bound in a companion list

(cf. Definition 3.3). In order to produce moves of the form [x, -], which serve to hook
up strategies for composition, one may adapt the compilation of Figure 6 as follows: we
should compile M as Mnil\Gamma  , where \Gamma  is carried out everywhere in a dummy way except
when xnil\Gamma  is met, which has to be compiled to [x, -]\Gamma *x.

The set of finite typed B"ohm trees is in bijection with a subset of finite typed strategies
for A, T , and a suitable function ( ). Furthermore, in order to characterise this subset,
we have to impose a discipline for basic types.

Definition 4.1. Let A = ! and let T be the set of types built as terms over the signature
consisting of basic type symbols C, C1, . . . and of ! of arity 2. If oe = o/1 ! * * * ! o/n ! C,
we set

oei = ae o/i if 1 6 i 6 nundefined otherwise.

We define the following additional operation ( )? from types to basic types: (~oe ! ^)? = ^.
A typed * strategy is a typed strategy OE relative to A and T that, moreover, satisfies the
following condition:

(0) If raoe[ff,

^-]o/ 2 OE, then oe? = o/?.

A typed * pseudo-strategy is defined likewise as a typed pseudo-strategy satisfying Condition (0).

We next define a compilation from finite name-free typed * strategies (cf. Definition 2.2
and Remark 6) to finite closed typed B"ohm trees. The translation involves a function that

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 578

OE ; *~oe!C[i,

j-], OE

1, . . . , OEn \Gamma ~oe!C = \Gamma ,~x : ~oe

OE\Gamma  = *~x : ~oe.[i,

j-]\Gamma ~oe!C OE\Gamma ~oe!C

1 * * * OE\Gamma 

~oe!C
n * * *

where

\Gamma ~oe!C = \Gamma ,~x : ~oe, with x1, . . . , xn distinct and new
[i,

0-]\Gamma ,~x:~oe = x

i [i,

j+1-]\Gamma ,~x:~oe = [i, j-]\Gamma 

Fig. 7. Compilation of typed * strategies

takes a name-free pseudo-strategy of type oe and a context \Gamma  and yields an (open) finite
typed B"ohm tree. The translation is given in Figure 7.

Definition 4.2. We say that a context \Gamma  agrees with a list of types \Sigma  if \Gamma  and \Sigma  have the
same length, and if for each vector ~x : ~o/ of \Gamma  the corresponding type in the list \Sigma  has the
form ~o/ ! C for some C.

Proposition 4.3. The following properties hold:
1 If ` M : oe, then Mnil is a finite name-free typed * strategy.
2 If OE is a finite name-free typed * strategy of type oe, then OEnil is a finite typed B"ohm

tree and ` OEnil : oe.
3 Moreover, these two transformations are inverse to each other.

Proof. (hint)
(1) We show a stronger result: if P is a subterm of M and \Gamma  ` P : oe, then P \Gamma  is a
pseudo-strategy relative to a list \Sigma  that agrees with \Gamma . We prove this by induction on the
size of P , and the list \Sigma  is constructed along the induction. Let

(*~x : ~oe.y ~M)\Gamma  = {*~oe!Cy\Gamma ,~x:~oe} [

k=1***n{*

~oe!Cy\Gamma ,~x:~oeko/k r | *o/k r 2 (Mk)\Gamma ,~x:~oe}.

Then, if \Sigma  is associated with \Gamma , we associate \Sigma ,~oe ! C with \Gamma ,~x : ~oe, and the agreement
is obvious by induction and by definition. Conditions (0) and (1) are immediate by
construction and by the typing rules. We sketch the argument for Conditions (2) and (3).

If [i,

j-] occurs in (*~x : ~oe.y ~M)\Gamma , then it occurs either as the abstract head variable or in

(Mi)\Gamma ,~x:~oe for some i. Suppose the latter holds (the head variable case is similar). There are
three cases (cf. the proof of Lemma 3.4):

(a) [i,

j-] occurs bound in (M

i)\Gamma ,~x:~oe. Then it occurs a fortiori bound in (*~x : ~oe.y ~M)\Gamma , and

Condition (2) follows from Condition (2) at Mi.

(b) [i,

j-] does not occur bound (*~x : ~oe.y ~M)\Gamma . Then, contraposing from the previous case,

Condition (3) follows from Condition (3) at Mi.
(c) [i,

j-] occurs bound in (*~x : ~oe.y ~M)\Gamma  and does not occur bound in (M

i)\Gamma ,~x:~oe. Then

[i,

j-] is bound to the head type \Sigma ,~oe ! C in (M

i)\Gamma ,~x:~oe and is bound to *~oe!C in

(*~x : ~oe.y ~M)\Gamma , so Condition (2) follows from Condition (3) at Mi.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 579
(2) One shows that if OE is a typed * pseudo-strategy of type oe relative to \Sigma  and if \Gamma  agrees
with \Sigma , then \Gamma  ` OE\Gamma  : oe. This is proved by induction on the size of OE. Conditions (0)-(3)
ensure the well-typing of OE\Gamma .

(3) Let us consider OE\Gamma  arising in the recursive computation of some nil . We shall prove
(OE\Gamma )\Gamma  = OE for all such OE's, and hence a fortiori (nil )nil = . Suppose that

OE ; *~oe!C[i,

j-], OE

1, . . . , OEn

and that \Gamma ~oe!C = \Gamma ,~x : ~oe. Then by construction,

OE\Gamma  = *~x : ~oe.[i,

j-]\Gamma ,~x:~oeOE\Gamma ~oe!C

1 * * * OE\Gamma 

~oe!C
n * * * .

If we now analyse the construction of (OE\Gamma )\Gamma , we recover:
-- *~oe!C thanks to Condition (0),
-- the correct type decoration for [i,

j-] thanks to Conditions (2) and (3), and

-- OE1, . . . , OEn by induction.
The other direction (M\Gamma )\Gamma  can be handled similarly, choosing names according to the
concrete syntax of M in the context extension operations.

4.2. Pcf trees
In this section, we adapt the syntax of Section 4.1 in order to cope with constants of basic
type and case statements, and we show how to encode this extension into abstract B"ohm
trees, without any need to extend the target language (except for the alphabet of moves).
The types are the same as in Section 4.1, and the typing judgements have the same form.
The terms are called finite Pcf B"ohm trees, or simply Pcf trees, because they arise as the
compact elements in a term model of the language Pcf (Hyland and Ong 1994; Abramsky
et al. 1995). The syntax and the typing rules of Pcf trees are given in Figure 8, which uses
the notation \Gamma *y defined in Section 4.1. In the first rule, v1, . . . , vk : C should be read as:
`v1, . . . , vk are all the constants of type C'.

Remark 7. We make the simplifying assumption that there are only finitely many constants
at any given basic type. This allows us to keep our representations finite. There is no
difficulty in extending the results of this section to the case of infinite basic types, like the
natural numbers: one then needs to consider terms that may be horizontally infinite, that
is, that may have infinite branching (at player's moves). The induction arguments on the
size of terms must then be replaced by arguments on the length of a maximal branch.

We compile Pcf trees much like finite typed B"ohm trees.
Definition 4.4. We set

A = {v | v : C} [ {v1 | v1 : C1} [ * * * .
Hence the moves are either natural numbers or constants, called questions and answers,
respectively. We suppose that {v | v : C} " {v1 | v1 : C1} = 6, for any distinct basic types

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 580

M ::= *~x : ~oe.W W ::= v case yM1 * * * Mn [v1 ! W1, . . . , vk ! Wk] .

v : C
\Gamma  ` v : C

\Gamma *y = oe1 ! * * * ! oen ! C v1, . . . , vk : C
\Gamma  ` M1 : oe1 * * * \Gamma  ` Mn : oen \Gamma  ` W1 : C1 * * * \Gamma  ` Wk : C1

\Gamma  ` case yM1 * * * Mn [v1 ! W1, . . . , vk ! Wk] : C1

\Gamma ,~x : ~oe ` W : C
\Gamma  ` *~x : ~oe.W : ~oe ! C

Fig. 8. Typing rules for finite Pcf trees

C and C1. Let T be as in Definition 4.1. If oe = o/1 ! * * * ! o/n ! C, we set

oea = 8!:

o/i if a = i and 1 6 i 6 n
C if a = v and v : C
undefined otherwise.

A Pcf strategy is a typed strategy OE relative to A, T , and ( ) that, moreover, satisfies the
following conditions:

(Q) If q[v,

i-]oe 2 OE, where v is an answer, and if [v, i-] is bound to bo/ in q, then b is a

question.
(S) Moreover, all the opponent's moves between the binding move b and the answer must
be answers.

Conditions (Q) and (S) are called the question-answer discipline and the stack discipline,
respectively. A Pcf pseudo-strategy is defined likewise as a typed pseudo-strategy satisfying
Conditions (Q) and (S).

Remark 8. Conditions (1), (2) and (Q), together with the definition of oev, ensure that
opponent's moves of the form v, that is, opponent's questions, are never pointed to.
Suppose this is not the case, and consider a player's move that points to v. It cannot be

an answer by condition (Q). Hence it is a question [i,

j-]. By Condition (2), v should then

be decorated with a type oe such that oei is defined. But by Condition (1), oe = o/v for some
o/, which by definition of o/v implies oe = C. Hence oei is undefined, which is a contradiction.
Since questions are not pointed to, it is safe to omit them in the count of opponent's
moves from a player's move to its binder. Therefore, in the setting of Pcf strategies (and
of classical strategies), we shall modify the encoding of the pointers accordingly. When

writing [a,

i-], we mean that there are i opponent's questions between [a, i-] and its

binder. As a consequence, due to condition (S), all occurrences of player's answers have
the form [v,

0-].

The compilation of closed Pcf trees is given via a function M\Gamma  whose definition is
given in Figure 9. The following are more informal explanations. We adopt the following

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 581

W has type C
(*~x : ~oe.W )\Gamma  = {*~oe!Cr | r 2 W \Gamma ,~x:~oe}

v : C
v\Gamma  = {[v,

0-]C}

v1, . . . , vk : C
(case yM1 * * * Mn [v1 ! W1 * * * vk ! Wk])\Gamma  = {y\Gamma } Si=1***n {y\Gamma io/i r | *o/ir 2 M\Gamma i }S

j=1***k {y

\Gamma vCj r | r 2 W \Gamma j }

where y\Gamma  is as in Figure 6.
Fig. 9. Compilation of Pcf trees

tree representation for a Pcf term M:

*~x. case yz ""-- -
M1 * * * Mn v1 ! W1 * * * vk ! Wk

We call M1, . . . , Mn the argument branches, and v1 ! W1, . . . , vk ! Wk the case branches.
The node `*~x. case y' is split into the opponent's move * followed by a player's move y as

in Section 2. An occurrence of a basic constant v is compiled as [v,

0-] (cf. Remark 8).

Finally, we replace the head opponent's moves * in the translations OEi and OE0j of Mi and
Wj by i and vj, respectively: *

yz ""-- -

[1  OE1] * * * [n  OEn] [v1  OE01] * * * [vk  OE0k]
In Figure 9, the assumption `W has type C' can be read in either of the following two
ways. We may understand the compilation as translating typing judgements, in which
case the information C is immediately available, or we may retrieve C through a simple
recursive exploration: we have C = W ?, where

(case y ~M [v1 ! W1 * * * vk ! Wk])? = W ?j
for an arbitrary choice of j, and where v? = C if v : C. The compilation of a term M is
defined as Mnil .

Example 4.5. We compile the following term:

(case f(tt) [ff ! tt]) [f  (*x.case x [tt ! ff, ff ! tt])]
where we take a basic type of Booleans and the two constant tt and ff of this type.
-- Strategy for case f(tt ) [ff ! tt ]:

(* case

[f, -] 8?!?:

(
1 [tt,

0-]

ff[tt,

0-]

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 582
-- Multi-strategy for [f  (*x.case x [tt ! ff, ff ! tt])]:

(*x

f

case x
[1,

0-] 8!: tt[ff, 0-]

ff[tt,

0-]

The execution of this example by the VAM is as follows:

* f h1, 2i htt, 3i hff, 2i [tt,

0-]

1 2 3 4 5 6
The successive views are as follows:

view \Gamma (1) = * view \Gamma (2) = f view \Gamma (3) = *1
view \Gamma (4) = f tt view \Gamma (5) = *ff

The displayed terminated history corresponds to a (B) final state, which can be seen as
providing an answer to the following query: what is the value returned by the application
of the functional *f.case f(tt) [ff ! tt] to the negation function?

For Pcf trees, the correspondence between final states and `head normal forms' is as
follows:

(*~x. case y ~M [~v ! ~W ]) (y free) (F)
(*~x. case x ~M [~v ! ~W ]) (x bound) (B)
(*~x.v) (B) .

Proposition 4.6. The compilation function of Figure 9 maps finite closed Pcf trees to
name-free Pcf strategies bijectively.

Proof. (hint)
The proof is similar to the proof of Proposition 4.3. It goes via the definition of an inverse
compilation. We do not give the details, which are rather straightforward. We just remark
that the counterpart of the stack condition (S) in the type system is to be found in the
typing rule for case, where the common type C1 of the Wj's is `passed' to the conclusion.

4.3. Classical B"ohm trees
Classical B"ohm trees have been introduced in Herbelin (1997). They provide a classical
version of Pcf trees, using the ideas of the *u-calculus. We refer to Parigot (1992) and
Ong (1996) for an introduction to the *u-calculus (see also the comments at the end of the
section). In comparison with B"ohm trees and Pcf trees, classical B"ohm trees incorporate
two new constructs: the u abstraction, and the naming operation [ff]. They correspond
to a logical treatment of the classical absurdity, and involve a discipline of continuation
variables separate from the discipline of ordinary variables. The syntax and the typing
rules for classical B"ohm trees are given in Figure 10. The typing judgements are of the
form \Gamma ; \Delta  ` M : oe, where \Gamma  is a context of typed variables as usual, and \Delta  is a context of
typed continuation variables. In classical B"ohm trees, all the continuation variables have

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 583

M ::= *~x : ~oe.uff.W W ::= [ff]v case yM1 * * * Mn [v1 ! W1, . . . , vk ! Wk] .

\Delta *ff = C v : C

\Gamma ; \Delta  ` [ff]v : ?

\Gamma *y = oe1 ! * * * ! oen ! C v1, . . . , vk : C
\Gamma ; \Delta  ` M1 : oe1 * * * \Gamma  ` Mn : oen \Gamma ; \Delta  ` W1 : ? * * * \Gamma ; \Delta  ` Wk : ?

\Gamma ; \Delta  ` case yM1 * * * Mn [v1 ! W1, . . . , vk ! Wk] : ?

\Gamma ,~x : ~oe; \Delta , ff : C ` W : ?
\Gamma  ` *~x : ~oe.uff.W : ~oe ! C

Fig. 10. Typing rules for classical B"ohm trees

(*~x : ~oe.uff : C.W )\Gamma ;\Delta  = {*~oe!Cr | r 2 W \Gamma ,~x:~oe; \Delta , ff : C}

v : C

([ff]v)\Gamma ;\Delta  = {[v,

ff\Delta -]C}

where ff\Delta ,fi:C = ae ff

\Delta  + 1 if ff 6= fi

0 if ff = fi

y\Gamma ,~x:~oe = [i,

j-]o/1!***o/n!C v

1, . . . , vk : C

(case y ~M [v1 ! W1 * * * vk ! Wk])\Gamma  = {y\Gamma ,~x:~oe} Si=1***n {y\Gamma ,~x:~oeio/ir | *o/ir 2 M\Gamma ,~x:~oei }S

j=1***k {y

\Gamma ,~x:~oevCj r | r 2 W (\Gamma ,~x:~oe

j }

where y\Gamma  is as in Figure 6.

Fig. 11. Compilation of classical B"ohm trees

a basic type. In the figure, the notation \Delta *ff is similar to the notation \Gamma *y, and is defined
by

(\Delta , fi : C)*ff = ae \Delta *ff if ff 6= fiC if ff = fi .
One should read v1, . . . , vk : C as `v1, . . . , vk are all the constants of type C' (cf. Figure 8).
All the bodies W receive a special type ?, which stands for absurdity.

Definition 4.7. Let A, T , and ( ), be as in Definition 4.4. A classical strategy is a typed
strategy OE relative to A and T that, moreover, satisfies the question-answer discipline
(Condition (Q) of Definition 4.4).

In other words, classical strategies are the same as Pcf strategies, except that the stack
condition (S) has been removed.

Proposition 4.8. The compilation function of Figure 11 maps bijectively finite closed
classical B"ohm trees to finite name-free classical strategies.

We can summarise the transition from B"ohm trees to classical B"ohm trees through Pcf
trees as follows:

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 584
-- In order to characterise typed B"ohm trees, we have to impose an explicit basic type

discipline (Condition (0) of Definition 4.1). This condition becomes implied as soon
as values, or answers are introduced (both in Pcf trees and classical B"ohm trees).
Answers allow us to encode the continuations of the computations using pointers:
they are bound, just as variables are.

-- In order to characterise Pcf B"ohm trees, we have to impose a discipline for answers:

1 Answers are bound to questions.
2 Moreover, this binding forces us to answer the last pending question (stack discipline).

-- If the stack discipline is removed, we have the classical B"ohm trees.
From this analysis we conclude that classical B"ohm trees provide the best fit for our abstract computational setting of abstract B"ohm trees. Condition (0) is an ad hoc condition.
The stack discipline is certainly not ad hoc, since it sets the boundary between intuitionistic
and classical. But from the computational point of view, it makes no difference whether
we have it or not.

In the rest of this section, we substantiate rather informally the claim that classical
B"ohm trees are to `*u+Pcf' what Pcf trees are to Pcf. We first briefly describe the version
of Parigot's *u-calculus (Parigot 1992) given by Hofmann and Streicher (Hofmann and
Streicher 1997) (which is itself closely inspired by Ong's version (Ong 1996)). Let T be the
collection of types considered so far, the basic types being now looked at as propositional
atoms. There is also a special type ?, which Hofmann and Streicher allow in T (that is,
for example, oe ! ? 2 T ), but we shall leave it apart. The terms of the *u-calculus are
given by the following syntax:

M ::= x MN *x : oe.M uff : A.M [ff]M.
where x ranges over term variables as usual, and where ff ranges over a disjoint set of
continuation variables. Typing judgements have the form \Gamma ; \Delta  ` M : oe, where \Delta  is a list
of typed continuation variables ff : oe, with oe 6= ?. The judgements are derived by the
following rules:

x : oe in \Gamma 
\Gamma ; \Delta  ` x : oe

\Gamma , x : oe; \Delta  ` M : o/
\Gamma ; \Delta  ` *x : oe.M : oe ! o/

\Gamma ; \Delta  ` M : oe ! o/ \Gamma ; \Delta  ` N : oe

\Gamma ; \Delta  ` MN : o/

\Gamma ; \Delta , ff : oe ` M : ?
\Gamma ; \Delta  ` uff : oe.M : oe

\Gamma ; \Delta  ` M : oe ff : oe in \Delta 

\Gamma ; \Delta  ` [ff]M : ?

In order to understand these rules, one should read ff : oe as an assumption that the
negation oe? of oe holds. Then the typing rules for u-abstractions uff : oe.M and for named
terms [ff]M read as absurdity introduction and elimination rules. The rewriting rules of

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 585
the *u-calculus are the following #:

(fi) (*x : oe.M)N = M[N/x]
(u - i) uff : oe ! o/. M = *x : oe. ufi : o/. M[x :: fi/ff]
(u - fi) [ff](ufi : oe.M) = M[ff/fi].

In these rules, three substitution operations are involved. The first is the ordinary
substitution in the *-calculus. The third is the substitution of (all free occurrences of) the
continuation variable fi by ff. The second consists of spotting all subterms of the form
[ff]N of M and replacing them by [fi](Nx).

In addition to these rules, we consider an expansion rule for a term M of type oe 6= ?:

(u - j) M ! uff : oe. [ff]M
where ff is new. It is easy to see that this rule, together with the other rules, implies the
j-rule N = *x : oe. Nx for any term N of a non-basic type oe ! o/. The following properties
are easy to check:

1 There cannot be a well-typed term of the form uff : oe.ufi : o/.M nor of the form [ff][fi]M.

For example, ufi : o/. M has type o/ 6= ?, but should have type ? if uff : oe. ufi : o/. M
were it to be well typed.
2 Under the assumption ? 62 T , a term of type ? can only be of the form [fi]M.
3 In a normal form, all the continuation variables have a basic type, thanks to the rule

(u - i).

Let us analyse informally an expanded *u normal form M, by which we mean the *u
version of j-long finite B"ohm trees. Making use, if needed, of the expansion rule (u - j)
followed by the rule (u - i), we see that M has the form *~x : ~oe.M1, where M1 is of a
basic type, which is 6= ?, since we assume ? 62 T here. Possibly using the expansion rule,
we have M1 = uff : C.M2 for some ff and C. By Property (2) above, M2 must be of the
form [fi]M3, where by Property (3), M3 is of basic type. The first symbol of M3 cannot
be a [fl] by Property (1), nor a * because of the type, nor a ufl, as otherwise there would
be a (u - fi) redex. It is thus either a variable x or an aplication M4M5; since M4 has
a non-basic type, by Property (3) it cannot start with a ufl, nor with a *, as otherwise
there would be a fi-redex, nor with a [fl], because of the type. Continuing in this way,
we see that M3 has the form xMn * * * M5. Summarising, the expanded normal forms have
(recursively) the form

*~x : ~oe. uff : C. [fi](x ~M)
where fi has a basic type.

If we now incorporate the basic constants and the case construct, we arrive at the
classical B"ohm trees of Figure 10, thanks to the following additional rule that allows to
distribute the naming operator [ff] all the way down to the constants:

[ff](case y ~M [v1 ! W1, . . . , vk ! Wk]) ! (case y ~M [v1 ! [ff]W1, . . . , vk ! [ff]Wk]).

# The rule (u - i) in the case B = ? is slightly different, since continuation variables of type ? are not allowed,

see Hofmann and Streicher (1997).

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 586
Remark 9. The bijective correspondences stated in Propositions 4.3, 4.6 and 4.8 can be
extended without difficulty to order-isomorphisms by allowing a special player's move
[\Omega , -]. We indicate briefly how this works. When we compile a partial term, we should
include explicit player's moves [\Omega , -] corresponding to each of the occurrences of \Omega .

For example, (*x.x\Omega (y\Omega ))nil contains *[1,

0-]1[\Omega , -] and *[1, 0-]2[y, -]1[\Omega , -]. Here is

how we justify that the composition operation is monotonic (and hence Scott-continuous,
being defined by means of finitary rules). First, we need a minor adjustment in the setting
of the VAM. The special `free player's move' [\Omega , -] is allowed to occur in OE, without
being bound in . Hence we allow for (F) final states in OE that correspond to having
reached an \Omega  of OE. Next, we define the order relation between strategies (and similarly
between multi-strategies) as follows: OE 6 OE0 if each position of OE0 is either in OE, or has
a query prefix q such that q[\Omega , -] 2 OE. Suppose now that OE 6 OE0 and  6 0, and that
r 2 OE0 ffi 0. The corresponding computation of the strong VAM has explored parts of OE0
and 0. If those parts are also present in OE and , then r is also in OE ffi . Otherwise, we
run two executions of the strong VAM in parallel, the first for OE and , the second for OE0
and 0, both executions being guided by r (cf. Remark 5). The machines have the same
history up to some step at which the view q in OE0 and 0 is answered by \Omega  in OE or , and
by something else in OE0 or 0. The first execution then returns an answer \Omega  to the current
query, which is a prefix of r. Hence OE ffi  6 OE0 ffi 0.

4.4. Novikov's logic
In this section, we present examples taken from Novikov's classical infinitary propositional
logic. The basic formulas of this logic are of the form 9 x P (or 9~x P ), where P is a
predicate over natural numbers, like x 6 y or f(x) 6 f(y) (where f is a function from
natural numbers to natural numbers whose definition is given as an oracle outside the
logic). The (existential) formulas are then built by the following rule:

If A is a formula, then 9 x 8 y A is a formula.
In this logic, one proves disjunctions of formulas, represented as sequences \Gamma  = A1, . . . ,
An+1. Proofs are formulated as strategies. At the beginning, the opponent objects the
whole disjunction. Then the player chooses to justify one of the disjuncts, say An+1 =9

x 8 y A(x, y). To materialise his justification, the player also chooses a particular x0.
Then the proof of the formula amounts to proving each of the following disjunctions:

A1, . . . , An, An+1, A(x0, i)
for i = 0, 1, 2, . . . . Notice that we have kept An+1, because, in classical reasoning, it might
be the case that the player discovers that he was wrong in his choice of x0, and that
another choice would have been wiser.

A proof of a universal quantification 8 z A(z) is represented as an infinite multi-strategy
[. . . , m  A(m), . . .]. All such proofs can be formulated as trees with pointers, and the
(Strong) VAM can be used for cut-elimination. More precisely, in the examples presented
below,

-- the strategy proves a disjunction (9 x 8 y A(x, y)), \Gamma ,

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 587
-- the multi-strategy provides proofs of 9 y ~A(m, y) for all m, and
-- the cut-elimination, or composition, yields a (cut-free) proof of \Gamma .

The alphabet for Novikov's calculus is A = !. The set T of abstract types is defined as
follows (in first approximation):

T = {A | A is a formula} [ {8 y A | A is a formula}.
We set

(8 y A)i = A(i) (9 x B)j = B(j) .
We shall not give a formal statement that characterises the proofs of Novikov's logic as
typed strategies relative to A, T and ( ), but it should be clear that such a bijection exists
(see also remark 10). We shall just present two examples, taken from Coquand (1995) and
from Berardi et al. (1994), respectively. In Example 4.9, given a function f from natural
numbers to natural numbers, we show how to construct three numbers u1, u2, u3 such that
f(u1) 6 f(u2) 6 f(u3), relying on a lemma that asserts the existence of relative minima
(the formula K(x) below). In Example 4.10, we show a dialogue interpretation of the
Axiom of Choice: given a predicate P (x, y) and a multi-strategy witnessing (9 x P (m, x))
for all m, we show how the interaction with the axiom of choice results in the progressive
construction of f such that P (n, f(n)) (for all n in the domain of definition of f).

Example 4.9.
-- Strategy for

L = (9 x 8 y ? x 9 z ? x f(y) > f(z)) , (9 u1 < u2 < u3 f(u1) 6 f(u2) 6 f(u3)) :

* 9

x
[0, -]

8??????????
!???????
???:

y1 9

x
[y1 + 1, -]

8??????????
!???????
???:

f(y1) > f(y2)

y2

9z
[y2,

1-]

f(y1) 6 f(y2)

y2 9

x
[y2 + 1, -] 8????!????:

f(y2) > f(y3)

y3

9z
[y3,

1-]

f(y2) 6 f(y3)

y3

9u1 < u2 < u3
[y1, y2, y3,

3-]

-- Multi-strategy for K(x) = 9 y ? x 8 z ? x f(y) 6 f(z):

x

9y
[x,

0-] f(x) > f(z1)z

1

9y
[z1,

1-] f(z1) > f(z2)z

2

9y
[z2,

2-] * * *

We explain briefly how to read the strategy for L. The player chooses to justify the
first disjunct of L, with x = 0. This is just to let the opponent pick a value y1 ? 0 for y.
Next the player retries the first disjunct, but now with x = y1 + 1. The opponent must
then choose y2 > y1. The player has access to the oracle defining f. If f(y1) > f(y2),
the player plays z = y2, and he has justified the first disjunct. Otherwise, he retries the
first disjunct from the very beginning, with x = y2 + 1. The opponent chooses y3 > y2.
If f(y2) > f(y3), the player can justify the first disjunct by playing z = y3. Otherwise,
we have f(y1) 6 f(y2) 6 f(y3), and the player justifies the second disjunct by playing

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 588
u1, u2, u3 = y1, y2, y3. We have omitted the type decorations in the above strategy and
multi-strategy. Here are the typed positions corresponding to the first branch and to the
third branch of the proof of L:*

9 u1<u2<u3 f(u1)6f(u2)6f(u3) [0, -]8 y?0 9 z?0 f(y)>f(z)

y9 z?0 f(y1)>f(z)1 [y1 + 1, -]8 y?y1+1 9 z?y1+1 f(y)>f(z)
y9 z?y1+1 f(y2)>f(z)2 [y2,

1-]f(y1)>f(y2)

*9 u1<u2<u3 f(u1)6f(u2)6f(u3) [0, -]8 y?0 9 z?0 f(y)>f(z)
y9 z?0 f(y1)>f(z)1 [y1 + 1, -]8 y?y1+1 9 z?y1+1 f(y)>f(z)
y9 z?y1+1 f(y2)>f(z)2 [y2 + 1, -]8 y?y2+1 9 z?y2+1 f(y)>f(z)

y9 z?y2+1 f(y3)>f(z)3 [y1, y2, y3,

3-]f(y1)6f(y2)6f(y3)

For K, we give only a typed position of length 4 (with x = 0, z1 = 1):

09 y?0 8 z?0 f(y)6f(z) [0,

0-]8 z?0 f(0)6f(z)

1f(0)6f(1) [1,

1-]8 z?0 f(1)6f(z)

Given f such that

f(0) = 10, f(1) = 5, f(2) = 3, f(3) = 7, f(4) = 4, f(5) = 11, f(6) = 29,
the history of the proof of 9 u1 < u2 < u3 f(u1) 6 f(u2) 6 f(u3) by cut-elimination
performed by the VAM is as follows.*

0 h0, 2i 1 h1, 4i h1, 3i h1, 2i 2 h2, 8i h2, 7i
1 2 3 4 5 6 7 8 9 10

h2, 2i 3 h3, 12i 4 h4, 14i h4, 13i h4, 12i 5 h5, 18i [2, 4, 5,

0-]

11 12 13 14 15 16 17 18 19 20
The successive views are as follows:

view \Gamma (1) = * view \Gamma (2) = 0 view \Gamma (3) = *0
view \Gamma (4) = 1 view \Gamma (5) = *01 view \Gamma (6) = 01
view \Gamma (7) = *1 view \Gamma (8) = 2 view \Gamma (9) = *12
view \Gamma (10) = 012 view \Gamma (11) = *2 view \Gamma (12) = 3
view \Gamma (13) = *23 view \Gamma (14) = 4 view \Gamma (15) = *234
view \Gamma (16) = 34 view \Gamma (17) = *24 view \Gamma (18) = 5
view \Gamma (19) = *245

Remark 10. The above type decorations do not fit exactly with the framework of the
typed VAM: if OE is the strategy associated to L, then OE(*) = [0, -]8 y?0 9 z?0 f(y)>f(z), while
the first move played in the multi-strategy is 09 y?0 8 z?0 f(y)6f(z). What we need to do to
repair this mismatch is to take as the set of abstract types a quotient of the set of formulas
by de Morgan duality.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 589
Example 4.10.
-- Strategy for AC = (9 m 8 x P (m, x)) , (9 f 8 n P (n, f(n))):

*

9f
[?,

0-] 8??!??: n0 9m[n0, -] 8??!??:

x0

9f
[` x

0

n0 ' ,

2-] 8?!?: n1 9m[n1, -] 8?!?:

x1

9f
[` x

0 x1

n0 n1 ' ,

4-] . . .

where ` x

0

n0 ', `

x0 x1
n0 n1 ' , . . . are the (partial) functions defined by:`

x0
n0 ' (n

0) = x0`

x0 x1
n0 n1 ' (n

0) = x0 ` x0 x1

n0 n1 ' (n

1) = x1

...

-- Multi-strategy for (9 x P (m, x)): 8???!

???:

...
m[xm,

0-]

...

This example requires strong reduction: the demand for more values of f must come
from the user. Thus we describe the execution in the framework of the Strong VAM. The
first 10 steps of (generic) execution are as follows:

** [?,

*-] n0

*0 n

0 hxn0, 4i

1 2 3 4 5

[` xn

0

n0 ' ,

*-] n1

*1 n

1 hxn1, 8i [` xn0 xn1

n0 n1 ' ,

*-]

6 7 8 9 10
with the following successive views:

view \Gamma (1) = * view \Gamma (3) = *n0
view \Gamma (4) = n0 view \Gamma (5) = *n0xn0
view \Gamma (7) = *n0xn0n1 view \Gamma (8) = n1 view \Gamma (9) = *n0xn0n1xn1

5. Conclusion
Abstract B"ohm trees seem to provide an adequate level of abstraction for the description
of abstract machines for functional languages (and some of their extensions, such as those
with control operators) and for cut-elimination in a range of logical proof systems. They
embody just as much structure as is needed to describe two sorts of interaction: tree

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

P.-L. Curien 590
interaction and pointer interaction (cf. Remark 2). These two forms of interaction are
not only present in calculi such as those presented as examples in Section 4, they also
suffice to account for the whole evaluation mechanism (restricted to j-long terms) of these
calculi.

Developing a theory at this level of abstraction allows us to direct more efforts towards
compilation than towards execution. For example, by compiling Pcf trees or classical
B"ohm trees in the language of abstract B"ohm trees, we have freed ourselves from the
need to design extensions of the execution model: the same abstract machine is prepared
to handle any kind of abstract B"ohm trees.

Here we have only presented one abstract machine (and its strong extension). It turns
out that several abstract machines in the literature (including a call-by-name environment
machine in the style of Landin's SECD machine) can be expressed at this level of
abstraction (Curien and Herbelin 1997), and can be inter-translated, yielding step-to-step
correspondences. Hence the framework of abstract B"ohm trees can contribute to the
expression of what these abstract machines have in common, and how they differ (in data
representation, or in memory management).

We would like to stress that the role played by types in this study is more typical
of concurrency theory than of type theory. We have seen in Section 2 that the abstract
machine always terminates. We do not use types to prevent non-termination, but to
ensure that the termination is satisfactory (no dead-lock). The non-termination, say, of
the untyped *-calculus, is then explained by the fact that untyped reduction infinitely
expands the original term behind the scenes (cf. Remark 4). We formulate the following
question:

Is there a characterisation (for example, by some type system in the style of Coppo-
Dezani's intersection types) of the untyped *-terms for which the VAM execution succeeds,
that is, ends in a legal final state? More informally, among the terms possessing a head
normal form, which ones can reach it without implicit j-expansions?

It would also be interesting to extend our approach to cover more sophisticated
type systems such as second-order types. This is certainly possible, at the price of a
sophistication of the basic abstract machine presented here, that seems inherently linked
with simple types.

References
Abadi, M., Cardelli, L., Curien, P.-L. and L'evy, J. J. (1991) Explicit substitutions. Journal of

Functional Programming 1 (4) 375-416.
Abramsky, S., Jagadeesan, R. and Malacaria, P. (1995) Full abstraction for PCF (available by ftp

at theory.doc.ic.ac.uk/papers).
Amadio, R. and Curien, P.-L. (1997) Domains and Lambda-calculi (to appear).
Berardi, S., Bezem, M. A. and Coquand, T. (1994) On the computational content of the axiom of

choice, Technical Report of Utrecht University.
Coquand, T. (1995) A semantics of evidence for classical arithmetic, revised version. Journal of

Symbolic Logic 60 325-337.

http://journals.cambridge.org Downloaded: 10 Sep 2009 IP address: 192.93.2.32

Abstract B"ohm trees 591
Curien, P.-L. (1991) An abstract framework for environment machines. Theoretical Computer Science

82 389-402.
Curien, P.-L. and Herbelin, H. (1997) Computing with Abstract B"ohm trees (submitted).
Danos, V., Herbelin, H. and Regnier, L. (1996) Game semantics and abstract machines. Proc. LICS

96.
Danos, V. and Regnier, L. (1990) Machina ex deo, ou encore quelque chose `a dire sur la machine

de Krivine (unpublished).
Felscher, W. (1986) Dialogues as a foundation of intuitionistic logic. Handbook of Philosophical

Logic 3 341-372.
Herbelin, H. (1995) S'equents qu'on calcule, Th`ese de Doctorat, Universit'e Paris VII.
Herbelin, H. (1997) Games and weak head reduction for classical Pcf. Proc. TLCA 96.
Huet, G. (1993) An analysis of B"ohm's theorem. Theoretical Computer Science 121 145-167.
Hofmann, M. and Streicher, T. (1997) Continuation models are universal for *u-calculus (submitted).
Hyland, M., Ong, L. (1994) On full abstraction for PCF (available by ftp at

ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong).
Milner, R. (1977) Fully abstract models of typed lambda-calculi. Theoretical Computer Science 4.
Nickau, H. (1996) Hereditary sequential functionals: a game-theoretic approach to sequentiality, Dissertation, Universit"at GH Siegen, Shaker-Verlag.
Ong, L. (1996) A semantic view of classical proofs: type-theoretic, categorical, and denotational

characterisations. Proc. LICS 96.
Parigot, M. (1992) *u-calculus, an algorithmic interpretation of classical natural deduction. In Proc.

LPAR 92. Springer-Verlag Lecture Notes in Computer Science 624.
Plotkin, G. (1977) LCF as a programming Language. Theoretical Computer Science 5.