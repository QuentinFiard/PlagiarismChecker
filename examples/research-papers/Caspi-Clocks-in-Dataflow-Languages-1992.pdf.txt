

Theoretical  Computer  Science  94  (1992)  125-140 

Elsevier 

I25 

Clocks  in  dataflow  languages* 
Paul  Caspi 
Lahorutoire  de  Gnie  Irfwmntique,  UA  CNRS  398.  INPG,  46  .4r.  F>lix-Viallrl,  38031  Grenoble C<>dc.v 

,  Frunw 

Communicated  by  Nivat 

Received  January  1989 
Revised  January  1990 

Ahsrrnct 
Caspi,  P.,  Clocks  in  dataflow  languages,  Theoretical  Computer  Science  94  (1992)  1255140. 
This  paper  addresses  the  problem  of  using  a  dataflow  language  in  "real-time"  continuously 
operating  systems.  It  shows  that  this  raises  a  problem  of  bounded  memory  which  can  be  character- 
ized  in  terms  of  multiple  input&output  sequential  machines,  and  proposes  a  generalization  of  the 
Ginsburg-Rose  theorem  in  this  case.  Finally,  it  shows  how  these  concepts  have  been  applied  in  the 
clock  calculus  of  the  synchronous  datafow  language  Lustre. 

Introduction 

The  dataflow  paradigm  of  programming  languages  has  evolved,  since  its  introduc- 
tion  in  the  early  seventies  [6],  according  to  a  large  variety  of circumstances  and  needs. 

First,  it  has  appeared  as  a  practical  means  for  expressing  and  exploiting  the 
parallelism  of  computations  within  the  context  of  parallel  supercomputing  [16]. 

It  has  also  been  used  as  a  basic  semantical  concept  for  expressing  both  communica- 
tion  and  synchronization  in  parallel  processing  without  shared  variables.  In  this  sense, 
it  can  be  seen  as  an  alternative  to  the  concept  of  rendez-vous,  which  shares  the  same 
objective.  However,  some  difficulties  have  been  found  when  dealing  with  nondeter- 
ministic  computations  [3].  Though  some  solutions  have  been  brought  to  these 
problems  [2,  121,  best  results  have  been  obtained  by  considering  only  deterministic 
computations.  Thus,  only  deterministic  dataflow  will  be  considered  here.  Processes 
are  then  seen  as  functions  over  sequences  of  data,  and  networks  of  processes  as 

systems  of  equations,  and  the  behaviour  of  a  network  is  interpreted  as  the  least 
solution  of  its  system  of  equations.  LUCID  [17]  considers  the  Scott  order  of  partial 
functions  (sequences  being  functions  from  integers  to  data),  while  Kahn  [ 1 l]  considers 

*This  work  has  been  partially  supported  by  the  PRCC"  of  the  French  CNRS. 
0304-3975/92,%05.00  :?  1992  mmElsevier  Science  Publishers  B.V.  All  rights  reserved 

the  prefix  order  of  finite  and  infinite  sequences.  Despite  LUCID  at;thors  claim,  we 

bclie.~c  that  only  tbc  latter  approach  meets  the  usual  operational  views  of  dataflow, 
which  considers  dntaflow  systems  as  causal  ones,  in  the  sense  that  the  future  of  inputs 

may  ncot influence  the  past  of  outputs. 

Finally,  synchronous  dataflow  has  appeared  as  a  high-level  concept  for  specifying 
and  programming  real-time  automatic  control  and  signal  processing  applications. 
This  i:  the  point  of  view  adopted  in  tht:  1. ustrc  [S]  and  Signal  [IO]  projects,  as  well  as 

in  [ 131.  This  field  of  applications  dithers  from  classical  programming  according  to 
sy\eral  uspcctr:  firsf.. the  time  at  which  computations  take  place  is  il  relevant  question 
whic:ll  has  to  be  specified  and  controllz-d,  and  second. this  fkld  considers  continuously 
operating  systems,  wi:ich  reccivr  unboundt:d  flows  of  inputs  and  deliver  unbounded 

tl~w~  (9ol:lputa.  Then,  11 is  advocated  that  synchronous  dataflow  may  cope  with  both 
fcutlure:;:  it  ;~llow~  the  control  of  the  time  at  which  computations  take  place,  and  it 
aliows  bounded  memories,  efficient  implementations  of  such  continuously  operating 
"4 sti.`nis. 

`LOG.  svn;hro1i;:.1s  dataflow  21ppe:+rs as  a  restriction  of  ordin,u-y  dataflow,  in  the 
sense  that  some  network  constructions  are  forbidden,  and  restrictions  are  set  over  the 

allo\ved  inputs  of  a  network.  The  set  of  rules  and  calculations  that  define  those 
restrictions  are  sometimes  referred  to  as  a  "clock  calculus". 

In  this  paper,  WC try  to  investigate  the  rationale  for  such  clock  calculi.  First,  we 
2dtlrecl;  the  problem  of  hc>unded  memory-  (Section  2j,  and  show  that  it  is  related  to  the 
t:.~n~c:~t  i,f  gt:nrr,.tli~.ed  szql.Lential  lnachine  (gsm):  whe11  multiple  input  and  output 
~j;r:l~  ;ire  itllowctl,  nettiorks  of  gsms  may  not  be  gsms.  and  the  purpose  of  a  clock 

*  1 L`illcLlldS  IS  ;ti  eilsllie  d-d  prescr:;ation  of  the  gsm  property.  Then.  we  show  how  these 

cvncepts  hale  been  applied  in  the  synchronous  datafow  Idnguage  Lustre  (Section  3). 

`Th,:se  qncstiocs  are  Illustrated  on  a  very  simple  dataflow  language.  whose  syntax  and 
.~n;rniic~  are  given  in  Section  1. 

1.  A  simple  dataflow  language 

\Vc  consider  here  a  simple  static  and  deterministic  dataflow  language.  We  may, 
t hcrefore,  give  it  a  purely  functional  syntax,  and  as  we  consider  only  static  networks, 

VT  may  xvoid  the  use  of  either  i-calculus  or  general  purpose  combinators. 

L.et  F  be  a  set  of  primitive  functions  /;  and  two  positive  integer  functions  i  (input 
arit;,;j  `md  o  (output  arity)  defined  over  F.  First.  it  is  assumed  that  F  contains  the 
followirig  routing  functions: 
-  !~d,,,,,  with  I' <  i,  and  such  that  i(h~~f,,  !,J = I  and  o(h~d~,,,)  =  I'. It  transmits  only 

ttir  first  I' arguments  of  its  input  list. 

Clocks  in  dataflow  languages  127 
-  coml.ls7  such  that  i(com,,,C)=l-t  1'  and  ofcorn  i.l  )=1+1'.  It  commutes  the  first  f  at-.. 

guments  with  the  last  I' ones. 
Then  networks  can  be  built  according  to  the  syntax: 

r  : :-  ,f  /  r,  r'  /  r'  r'  /  Yv  (  (r), 
with 
~  i(r,  r')=i(r),  provided  i(r)=  i(r')  and  o(r,  r')=o(r)+o(r').  It  consists  in  putting  in 

parallel  both  networks. 
_  i(rar')=i(r')  and  n(r  >r')=o(r),  provided  o(r))=  i(r).  This  is  the  functional 

composition. 
_  i( Yr) =  i(r)  -- o(r)  and  o(  Yr) =  o(r),  provided  I'(r} >  e(r).  It  feeds  back  the  ouiptiis  111 to 

the  first  input  lines. 
Clearly.  this  syntax  would  lead  to  quite  cumbersome  programming  (thollgh  one 
might  argue  that  it  allows  structured  network  programmingi.  and  that  1s  ;+hy 

LIUCID-like  syntaxes  h:l\:e  heel  adopted  irl  !  ustre  and  Signrrl.  Rut  it  is simple  r:;lr:!.;fi 
for  our  purpose. 

Following  [l  i].  we  consider  the  set  of  finite  and  infinite  sequences  of  elements  of 
a  set  D: 

d  =  D*  u  1)". 

Then,  the  semantic  function  [  ]  is  defined  by  assuming  that  [I /]  belongs  to ~il/)+~oC.f  )* with: 
-  Cheali,,i'](X,,  , -Yi)=-Y1, .  , Xi', 

[COm;,i,](.X,.  . . . . X;+j  )".Y,+~r`..rXi+r',~~....,.Yi. 
and  stating: 
~~ [r,  r'](.Yl,  , .~~cl,)=[r](.Y~,  . Xi(r)), [r'](u,,  . . . , .Yjcrj), 

-  [rc;J](.Y,.  . . . . .);-icr',i=[r](Cr'](.~  ,,....  +,)j. 

It  remains  to  give  sense  to  [Yr].  This  is  obtained  by: 
-  first,  considering  a  partial  order  <  over  A  such  that  (A,  6)  is  a  complete  partial 

order  (cpo).  Then  (A,  G)'  is  also  a  cpo. 
~  then,  assuming  that  every  [,f']  is  a  total  continuous  function. 

c Yrl tx 1.  , .Yi(r)_O(I)) is  then  deli ne  as  the  least  solution  of  the  equation d 

Jt  can  then  be  shown  that  all  [r]  are  total  continuous  functions. 

Following  [ 111, we  are  led  to  consider  <  as  the  prefix  order  of  sequences:  s  6~.  ilT 
there  exists  z such  that  JJ =  x.z,  where  is the  concatenation  operator.  Equivalently,  we 
shall  say  also  that  .Y divides  .v. that  x--'  y  exists,  and  that  J' is  a  future  of  x. 

12x  P.  Cnspi 

In  what  follows,  we  shall  frequently  omit  the  [  ]  notation,  whenever  discrimina- 
tion  between  syntax  and  semantics  is  allowed  by  the  context. 

A  continuous  functionf`over  a  cpo  is  order  preservmg,  i.e. 

x d  4' implies  .f'(x) <<.f`( v). 
This  can  be  interpreted  as  causality:  if I' is a future  of x,  thenf(y)  is a  future  off(x).  This 
explains  why  the  prefix  order  satisfactorily  meets  the  operational  requirements  of 
dataflow.  However,  we  would  like  to  stress  here  that  continuity  does  not  imply  any 

notion  of  length  preservation. 

Taking  1  1 as  the  usual  length  function  over  sequences,  and  lettingf  be  a  single- 
input,  single-output  continuous  function,  we  might  have: 
-  1 f(x)  / <  ( x / (undersampling), 
~  I.f`(x)I =  1.x  (length  preservation), 
-  I,f`(x) I >  1 x I (oversampling). 

Oversampling  has  been  thoroughly  studied  by  Signal's  authors  [lo],  and  they  have 

stressed  its  role  for  programming  signal  processing  systems. 

2.  The  bounded  memory  problem 
2.1.  Prohh  stutenmt 

Let  us  consider  the  network  toto  in  Fig.  1. 

toto  is  defined  by 

toto  =,f'  `2 (2, /dad,,  1 ), where 
~  2  is  the  function  which  duplicates  each  element  of  its  input  sequence: 

2(E)=&,  where  E denotes  the  neutral  element  of  any  monoid,  and 
2(d.s)  =  d.d.2(s),  where  d  belongs  to  D,  and  E, s  to  D*, 

+-ii-~!. 

I  I 
Fig.  1. 

Clocks  in darajbw fanyuages  129 
~  f'  applies  pointwisely  a  given  functionf:  D  x D+D  over  elements  of  same  index  of 

its  two  input  sequences: 

f(&,  s)=~)(s,  E)=E  and  f'(d.s,  d'.s')=f(d,  d').f'(s,  s'). 
Obviously,  each  of the  components  of  toto  is  a  total  continuous  function  and,  yet,  one 
cannot  find  a  "real-time"  implementation  of  this  network,  as  the  file  associated  with 

the  link  between  2  andf'  may  not  be  bounded;  if  the  network  is  to  operate  contin- 

uously,  this  file  will  certainly  overflow! 

This  effect  is  clearly  linked  with  length  considerations:  it  may  not  occur  if  all 
component  functions  were  length  preserving.  But  it  is  not  specific  to  the  use  of  the 

oversampling  function  2.  Using  the  undersampling  function  l/2,  which  erases  all 
elements  of  even  index  of  its  input  sequence,  would  yield  the  same  effect. 

Finally,  it  does  not  depend  on  whether  D  is  finite.  We  may,  therefore,  study  this 
problem  within  the  context  of  finite  data  sets,  and  use  generalized  sequential  machine 
(gsm)  as  an  operational  model  for  bounded  memory  dataflow. 

2.2.  Generulized  sequentiul  muchines,  and  the  Ginsburg-Rose  theorem 

According  to  [7]  we  have  the  following  definitions: 

A  generulized  sequentiul  machine  (gsm)  M  =  (Q,  A,  B,  qO,  T)  is  a  finite-state  automa- 
ton  over  the  product  monoid  A*  x  B*,  where  A  and  B  are  finite  input  and  output 
alphabets,  and  such  that: 
_  there  is  a  unique  initial  state  qO. 

_  all  states  (elements  of  Q)  are  terminal, 
_  transitions  (elements  of  T)  are  of  type  q-u;  b-+q',  where  q,  q'  are  states,  a  belongs 

to  A,  and  b  to  B*,  and  for  each  q,  a,  there  is  at  most  one  transition  with  initial  state 
q  and  input  character  a. 

A  gsm  mapping  1 M  1 is  the  partial  function  from  A*  to  B*  defined  by  1 M  ((x) = x'  iff 
there  exists  q'  such  that  q,  -x  ; x'-+*q',  (which  we  abbreviate  as  q0  -x  ; x'+*),  where 

-+*  denotes  the  generalized  transition  relation. 

A  partial  function  ,f  from  A*  to  I?*  is  initial  segment  preserving  iff,  when  f(y)  is 
defined,  then  f(x)  is  defined  for  all  x d  y,  and  f(x)  <f(  y). 

An  initial  segment  preserving  functionfis  Lipschitz  iff  there  exists  an  integer  k>O 
such  that,  for  ally  withf(y)  defined  and  for  all  xdy,  If(y)\-_lf(x)l<k(lyI-1x1)  holds. 

A  partial  functionffrom  A*  to  B*  is  rutionul  iff its  graph  #fis  a  rational  subset  of 
A*  x  B*. 

Given  these  definitions,  the  Ginsburg-Rose  theorem  [9]  provides  a  nice  character- 
ization  of  gsm  mappings: 

A  partial  function  f from  A*  to  B*  is  a  gsm  mapping  iff  it  is  rational,  initial 
segment  preserving,  Lipschitz,  and  f(&)  =  E. 

130  P.  Caspi 

As  a  corollary,  we  have: 

The  functional  composition  of  gsm  mappings  is  a  gsm  mapping. 
This  is  due  to  the  fact  that  the  composition  of  rational  transducers  (over  free 
monoids)  is  rational  [S,  141,  and  that  composition  trivially  preserves  the  other 
properties  required  for  a  partial  function  to  be  a  gsm  mapping. 

Thus,  the  theory  of  bounded  memory  dataflow  networks  made  up  of  single-input, 
single-output  functions  is very  simple:  it  requires  only  that  all  component  functions  be 
gsm  mappings.  But  it  concerns  only  very  poor  networks,  since  the  only  available 
constructor  is  functional  composition! 

2.3.  Multiple  input-output  gsms 

Taking  into  account  more  general  networks  thus  requires  some  generalization  of 
the  gsm  definition  to  the  tnultiple  input--output  case.  We  may  propose  the  following 
definition. 

A  multiple  gsm  (mgsm),  M  =(Q,  D, i, o,  qO, T),  is  a  finite-state  automaton 

over  the  product  monoid  (D*)i+O, where  D is  a finite  alphabet,  and  such  that: 
_  there  is  a  unique  initial  state  qO. 

~  all  states  are  terminal, 

_  transitions  (elements  of  the  finite  set  T)  are  of  type  q-x;y+q',  where 

x  belongs  to  (D*)`-{E},  and  y  to  (D*)". 
Note  that  the  input  domain  is  no  longer  a  free  monoid,  and  we  cannot  require  that 
the  input  element  of  a  transition  be  a  character.  Up  to  now,  this  definition  lacks 
certain  important  properties,  and  we  are  led  to  add  several  additional  conditions. 

First,  mappings  should  be  deterministic.  So,  we  add: 

(a)  ifqO-x;y+*  and  qO-x;  y'-+*,  then  y=y'. 
Next,  mappings  should  preserve  order: 

(b)  $qO--x;y+*,  qO-x';y'+*  am1  x<xx',  then  ydy'. 

Note  that  (b)  implies  (a).  Finally,  we  would  like  to  keep  that  property  of gsms,  that, 
having  constructed  the  output  ~1 of a  given  sequence  x, if a  future  x' of x  has  an  output, 

one  can  proceed  to  construct  that  output: 

(c)  tfqO-.x;y+*q,  qO-x';y'+*q'  and  x<x',  then  q-x-`x';y-`y'+*q'. 

This  is  a  generalization  of  the  gsm  definition,  as  one  can  easily  check  that  the  gsm 
(Q, D, D,q,,  T)  is  equivalent  to  the  mgsm  (Q,  D,  1,  1, qo,  T).  Now,  A  mysm  mapping 

( M(  is  the  partial  function  from  (D*)'  to  (D* )" defined  by  (MI(x)  = x'  iff q.  -  x ; x'+*. 

Remark.  This  definition  does  not  yield  initial  segment  preserving  mappings.  The 

reason  why  we  may  not  choose  a  definition  ensuring  this  property  will  appear  in  the 
next  section. 

Clocks  in  datajlow  languages  131 
2.4.  Application  to  the  example 

Let  us  come  back  to  the  example  of  Section  2.1,  and  specialize  it  by  taking  D  as 
B=  {true,fulse},  andfas  the  logical  function  and.  Then,  at  least  one  reason  that  could 
stand  for  toto  not  being  a  gsm  mapping,  arises  from  the  following  fact: 

(*)  The  and'  function,  defined  over  (B*)2,  is  not  a  mgsm  mapping. 

Proof.  Assume  and'  to  be  a  mgsm  mapping.  Then  the  family  of  states  {q.},  defined  by 
q.  -  true", E ; E-+*  qn, for  n integer,  should  be  finite,  and  one  could  find  qn = q,,,, for,  say, 
m < n.  But  truemfalse"-"`,  true"  is  a  future  of  true"`, E, and  there  exists  q  such  that 

q.  -  true*,falsen-",  true";  true"fulse"-"+*  q. 
Then,  by  condition  (c), 

q.-false"-",  true";  truemfalse"-m+*q. 
But  then,  we  should  have  the  transition: 

q,  -  truenfalse"-  m, true";  truemfalsen-"+*q, 
which  contradicts  the  and'  definition. 

But  we  also  have: 
(a)  and'  is  initial  segment  preserving,  as  a  total,  order  preserving  function, 

(b)  and'  is  rational,  as  shown  from  the  rational  expression: 

(CU, v, u  and  ~)*((C~,E,E)*+(ZE,  c,E)*), 
where  u  and  t' range  over  B, 

(c)  and'(v,  E) = E. 

Let  us  now  generalize  the  length  function  over  a  product  (D*)i  of  free  monoids  by: 

IIX l,...rXill=  C  I-"jl. 

j=  I,i 

Then, 

(d)  and'  is  Lipschitz,  as: 
land'(x,  y)l =in.f(Ixl,  Iyl),  and,  for  x~x',  JJ<~`,  one  can  easily  check  that 
Iand'(x',y')l-land'(x,y)l~lx'I+Iy'J-lxl-IyI. 

In  our  sense,  (*),  and  (a),  (b),  (c)  and  (d)  clearly  indicate  that  the  Ginsburg-Rose 
theorem  does  not  generalize  immediately. 

Remark.  It  is  easy  to  see  that  the  restriction  of  and'  to  the  domain 
Xn  =  (x,  y I / Ix I -  I y I I d  n}  is  a  mgsm  mapping,  and  it  is  not  initial  segment  preserving. 

2.5.  A  generalization  of  the  Ginsburg-Rose  theorem 

Section  2.4  seems  to  indicate  that  rationality  is  not  strong  enough  to  ensure  mgsm 
mapping.  One  may  think  of  a  stronger  concept,  such  as  recognizability,  but  this,  in 

132  P. cusp; 
turn,  is  too  strong:  for  instance,  the  very  simple  gsm:  qO--u;a-+q,  does  not  yield 
a  recognizable  mapping  (at  least  over  {u)*  x  {a)*). 

Let  us  propose  here  two  concepts,  such  that  each  one  neither  implies,  nor  is  implied 
by  rationality,  and  such  that  their  combination  is  stronger  than  rationality: 

(a)  A  subset  X  of  a  product  M  of  free  monoids  is  nearly  prejx  closed  (npc)  iff 
E belongs  to  X,  and  there  exists  an  integer  k  such  that,  for  any  x  and  x'#.*-  in  X,  with 

x d  x',  there  is  an  x" #  x'  in  X,  with  x 6  x" <  x'  and  )I x'  II-  I/ x"  /I d  k. 

(b)  A  subset  X  of  a  product  M  of  free  monoids  is  quasi-recognizable  (qr)  iff  the 
family  (.Y  ' X  1 x  in  X}  is  finite. 

For  instance,  {a"b"}  is  not  rational,  and  yet  qr,  as: 
(unbn)-l{umbm}=ifn=O  then  (umbm),  else  Jo}.  Conversely,  #and'  is  rational  but  not 
qr.  Note  also  that  recognizability  would  require  x  to  range  over  all  M  in  the  above 
definition. 

Both  definitions  (a)  and  (b)  can  be  combined  in: 
(c)  A  subset  X  of  a  product  M  of  free  monoids  is  sequential  iff it  is  both  npc  and  qr. 

We  may  then  state  the  following  theorem: 

A  partial  function  f ,fiom  (D*)i  to  (D*)"  is  a  mysm  mapping  if  it  is  order 
preserving,  its  domain  is  npc,  its  graph  is  qr,  and  f  (t.) =  c. 

Proof.  (only  if part):  Let  f  be  a  mgsm  mapping.  Take  k =  sup  (  11 x  /I 1 q-x  ; y+q'  in  T}; 

k  is  finite,  as  T  is  finite,  and  then  domf  is  npc.  For  any  q  in  Q,  take 
X,={x,ylq-x;y+*  }.  Then,  from  condition  2.3(c),  it  follows  that,  for  any  x,  y  such 
that  qO-x;y+*q,  X,=(x,  y)-l  #f:  Since  Q  is  finite,  #.f  is  qr. 

(if  part):  Let  f  be  order  preserving  with  donlf  npc  and  #,f  qr.  Then,  take 
Q=  {x-'  #.fI  x  in  #f)  and  q,  =  #f:  From  the  qr  property,  Q  is  finite,  and  from  the 
npc  property,  q0  belongs  to  Q.  Now,  consider  the  set  of  transitions  (x,  y)-r 

#f_x-`x';J'-l  y'-+(x',  y')-'  #f;  for  all  (.x, y),  (.x', y')  in  #.f;  with  s,  y<x',  y'  and 

I/x'  )I-  I/x  I( dk..  Since  the  number  of  elements  of  bounded  length  in  (D*)'  is  finite,  and 
y=f(x)  and  y'=f(x'),  and  since  there  cannot  be  two  ~1" associated  with  the  same 
x"=x-lx',  in  (x,  y-'  #f(otherwisefwould  not  be  a  function),  there  is  only  a  finite 

number  of  transitions.  Now,  we  should  check  that  we  have  built  a  mgsm,  whose 
mapping  equals  f:  From  the  transition  definition,  it  follows  that 

qO-x;y+*q  only  if  q=(x,  y)-l  #f  and  x,  y  belongs  to  #.f: 
Conversely,  from  the  npc  property,  if  _`c, y  belongs  to  #,fi  there  is  a  finite  sequence 

x1 ,...,  X,=X  in  domf,  with  xi<xi+l,  and  11 Xi+ 1 /I -  /I Xi 11 <k.  This  ensures  that 
qO-x;y+*.  Thus,  both  mappings  are  equal. 

As f  is  order  preserving,  condition  2.3 (b)  holds. 
Finally,  2.3(c)  holds,  as,  from  the  npc  property,  for  any  (x', y') and  (x,  y) <(x',  y') in  #  j; 
there  exists  a  finite  sequence  x=x1,  , x,=x'  in  dom,f;  with  .xi <xi+  I)  and 

II xi + 1 II -  II xi II G k. 

Clocks  in  datajbw  languages  133 
As  immediate  corollaries.  we  have: 

(1)  A  sequential  subset  is  rational. 
The  proof  follows  the  machine  construction  of  the  if  part  of  the  theorem. 

(2)  The  domain  of  an  mgsm  mapping  is  sequential. 

We  already  know  that  dom  f  is npc.  Now  dom  f  qr  follows  from  #f  qr,  and  x divides 
x'  in  dom  f  if  and  only  if  (x, f(x))  divides  (x',f(x'))  in  #f: 

2.6.  An  abstract  clock  calculus 

A clock  calculus  intends  to  answer  the  following  question:  Given  a  network  r  in  the 
sense  of  Section  1, considered  as  a  total  function  from  (D*)i  to  (D*)",  is  there  a  subset 
X  of (D*)' such  that  r is a  mgsm  mapping  over  X?  (which  we  abbreviate  as  X  : r). When 
trying  to  answer  this  question,  we  first  meet  the  following  two  problems: 

(Pl)  The  composition  of  mgsm  mappings  may  not  be  a  mgsm  mapping 

Proof.  Consider  the  two  mgsms  Mf  and  Mg: 

Mf:  go-a;a,E+q,  q-a;&,  E-9,  q-b;&,  a-+q, 
Mg:  go-e,  a;a-+q,  q-a,  &;a+q,  where  a,  b  are  characters. 
Then  dom  gcf=c  +a+ba*,  which  is not  npc.  By  the  theorem  in  Section  2.5  gof  is  not 
a  mgsm  mapping. 

(P2)  The  predicate  X  : r  may  not  be  continuous  with  respect  to  X. 

Proof.  Consider  the  sequence  of  subsets  Xn=  {x,  x'l  x,x'  in  B*2  and  IIx'I -_Ix/I  <n}. 
Then  Xn:and'  holds  for  any  n,  but  sup{Xn}  =B*2  and  B*`:and'  does  not  hold. 

This  shows  first  that,  even  if all  components  of a  network  were  mgsm  mappings,  the 
network  might  not  be  a  mgsm  mapping,  and  second  that  we  cannot  program 
a  network,  and  then  look  for  the  largest  input  subset  over  which  the  network  is 
a  mgsm  mapping  (clocks  synthesis).  The  only  sensible  thing  we  can  do  (and  this  is  the 
point  of view  adopted  in  Lustre)  consists  in  considering  programs  made  up  of a couple 
(network  r,  input  subset  declaration  Xr),  and  the  clock  calculus  consists  in  checking 

that  the  predicate  Xr:r  holds. 

Such  a  clock  calculus  can  be  based  on  the  following  inference  rules: 

(IRa)  If  Y  is  sequential  included  in  X  and  X  : r  holds,  then  Y:  r  holds. 
(IRb)  Zf  Y  is  sequential  included  in  X  n  X',  and  X  : r  and  X'  : r'  hold,  then  Y:  (r, r') 

holds. 
(IRc)  If  X  : r  and  X'  : r'  hold,  and  r'(X')  is  included  in  X,  then  X'  : ror'  holds. 
(IRd)  If  Y  is  sequential,  and  X  : r  holds,  and  { Yr(x),  x  I x  in  Y}  is  included  in  X,  then 

Y:  Yr  holds. 

Let  us  prove  (IRd),  which  is  the  more  complex  case. 

134  P.  Cuspi 
Proof  of  (IRd).  Let  X.r  denote  the  restriction  of  r  to  X.  We  know  from  Section  2.2 
that  Y. Yr  is  order  preserving,  and  from  d)  that  dom  Y. Yr =  Y  is  npc.  Thus,  it  remains 
to  show  that  #  Y.r  is  qr.  The  proof  uses  the  three  following  general  purpose  lemmas: 

(Ll)  (D*)i  is  qr. 
(L2)  The  qr  property  is  closed  with  respect  to  Cartesian  product. 
(L3)  The  qr  property  is  closed  with  respect  to  intersection. 

Lemma  (L3)  follows  from  x-`(Xn  Y)=(x-`X)n(xp'  Y). 

Proof  of  (IRd)  (conclusion).  Let  i( Yr) =  i,  and  o( Yr) =  o. Y  is  qr  and,  by  (Ll)  and  (L2), 

Y x (D*)"  is  qr.  Then,  obviously,  U =  (x,  y, x 1 y  in  Y and  x  in  (II*)"  > is qr.  Since  #  X.r  is 
qr,  by  (L3),  V=  #  X.rn  U  is  qr. 
Now,  let  H  be  the  set  function  defined  for  W  included  in  (D*)"  x (D*)'  x (D*)"  by 

H(W)=  {x,  y,  x  /x,  y, x  in  W,  and  ,for  uny  x'.  y, x'  in  W,  x,  y, x  <x',  y,  x'}. 
Then,  from  { Yr(x),  x  1 x  in  Y}  included  in  X, 

H(U={Yr(y),y,  Yr(y)ly  in  Y}, 
and  it  is  easy  to  check  that,  for  any  x  in  H(V),  x -  ' H(V)  =  H(x-  '  V).  This  shows  that 
H(V)  is  qr,  and  by  the  same  argument  as  in  Corollary  (2)  in  Section  2.5,  #  Y.r  is  qr. 

Alternative  proofs  of  the  inference  rules  would  have  consisted  in  constructing 
resulting  mgsms  from  component  mgsms.  This  indicates  the  possibility  of  a  composi- 
tional  compilation  of  bounded  memory  dataflow  programs.  Instead  of  using  this 
technique,  the  Lustre  compiler  [15]  uses  a  global  mgsm  synthesis  technique,  bor- 

rowed  from  the  Esterel  project  [l]. 

3.  The  clock  calculus  of  Lustre 

In  practice,  the  above  clock  calculus  would  be  very  difficult  to  implement.  Let  us 
show  here  how  the  problem  has  been  solved  in  Lustre.  The  solution  is  based  on  length 
arguments. 

3.1.  Length  and  domain  qf  primitive  functions 

First,  all  routing  functions  are  taken  total,  and  obviously,  they  are  mgsm  mappings. 
Then  a  domain  Xf  has  been  chosen  for  each  other  primitive  function  f;  such  that 

Xf:f  holds.  There  are  four  types  of  functions: 

(a)  Single-output,  length-preserving  functions:  These  functions  (such  as  and')  verify 

If(x  ~,...,Xi)l=i~f{I.~~I,...,IXil}.  Then  taking  Xf={x1,...,x1(Ix11=/x2/= 

. ..=Jxil).yields  IXf.f(x,,...,  .~i)l=Ix,I=IX2l=...=IXil.Wesaythatboththeinputs 

and  the  output  share  the  same  clock. 

Clocks  in  datqflow  languages  135 
(b)  Thefby  (followed  by)  function  defined  by: 

fby  (E, 4  =  6,  and  fby(d.s,  s') =  d.second(s,  s'), 
where 

second(s,  s') =  second(s,  E) = E,  and  second(d.s,  d's')  = d'.second(s,  s'), 
(This  is  the  "followed  by"  function  of Lucid.)  Then,  it  is easy  to  show  that  1 fby(x,  y) l = 

~~f(I~l,IyI+1}.  Taking  W~Y={~,YI~~I=IY~),  yields  IXfby.fby(x,y)I=lxl=lyl. 
Here  also,  both  inputs  should  have  the  same  clock,  which  is  the  clock  of  the 

output. 

(c)  Single-output  (over)sampling  functions,  such  as  mux  whose  first  input  is  a  se- 
quence  of  bounded  integers.  For  any  d,  element  of  the  first  input,  it  replicates  d  times 

the  element  of  same  index  of  the  second  input. 

mux(e,  s) = mux(s,  E) = E,  and  mux(d.s,  d'.s') = dd.mux(s,  s'), 
where  s is  a  sequence  of  bounded  integers.  Then,  defining  the  integer  function  count(s) 
as: 

count(&)(n)  =count(s)(O)=O,  and  count(d.s)(n)=d+count(s)(n-  l), 

provides 

Imu-+, ~)/=count(x)(inf(IxI,  Ivl)). 

We  choose  Xmux=(x,yIIxI=lyl},  and  then: 

IXmux.mux(x,  y)/=count(x)(IxI)=count(x)(IyI). 
We  say  that  both  inputs  of  mux  should  have  the  same  clock,  and  that  the  clock  of  the 
output  is  the  first  input. 

(d)  Single  output  blocking  functions,  such  as  lust  which  inverts  mux: 

last(s,  s') =  llast(ni1,  s, s'),  where  nil  is  an  "undefined"  universal  character, 
llasr(d,  E, s) = E, 

llast(d,  n.s,  E)  =  fn=O  then  d else  E, 
llast(d,  n.s,  d'.s')  =  ijn>  1  then  llast(d',  (n-  l).s,  s') 

else  if  n =  1 then  d'. llast(d',  s, s') 

else  d.llast(d,  s, d'.s'), 

where  s  is  a  sequence  of  bounded  integers.  Then,  1 last(x,  y)l = sup(n  I n <  1x1,  and 
count(x)(n)d/yl}. 

A  more  suitable  way  of  expressing  this  result  consists  in  considering  the  pseudo- 
inverse  function  rank(x)  of  the  sup-distributive  function  count(x),  in  the  sense  of 
Galois  representations  [4]: 

rank(x)(n)=sup{mI  count(x)(m)<n} 

136  P.  Cusp; 
Then, 

It  can  then  be  shown  that  last  is  a  mgsm  mapping  over 

Xlast={x,y~/y~=count(.u)(lx~)},  and  IXlust.last(x,y)l=lxl. 
This  is  due  to  the  classical  property  of  representations: 

(Pl)  For  any  n,  ami  any  x,  runk(x)(couwt(x)(n))~  n. 

We  then  say  that  the  second  input  of  lust  should  have  the  first  input  as  clock,  and 
then,  the  output  has  the  same  clock  as  the  first  input.  We  also  say  that  lust inverts  mux, 
as,  for  any  x,  J', and  1~1 =count(x)(  Irul),  nzuv(x,  last(x,  y))=y. 

3.2.  Network  domain  definition 

Finally,  the  input  declaration  of  a  network  consists,  besides  type  declarations,  in 
specifying  the  clocks  of  the  inputs:  the  clock  of  input  i is  either  the  "basic  clock",  or 
input  j,  provided  the  "clock  of"  function  be  acyclic. 

More  formally,  a  Clocks  list  c  of  i  integers  defines  the  subset  cX  of  D*' 

cX={xl,...,xi  1 fc(j)=c(k)  then  IxjI=JxLI 

and  [ff~(j)#O  then  /.~jJ=COZ(nt(X,(j))(IX,,j)I)}. 

It  follows  from  the  acyclic  character  of  the  "clock  of"  function  that  a  Clocks  list 
should  contain  at  least  one  0.  Furthermore,  elements  of  a  Clocks  list  of  i  elements 
should  be  smaller  than  or  equal  to  i.  Finally,  cX  subsets  are  clearly  sequential. 

3.3.  The  cuse  of  acyclic  netrvorks 

We  consider  here  networks  obtained  without  using  the  Y constructor.  It  follows 
from  the  semantics  given  in  Section  1.2,  that  [(r,  Y') - r"]  =[ror",  r'zr"].  Using  the 
corresponding  syntactic  equality  allows  such  networks  to  be  expressed  into  a  canon- 
ical  form,  corresponding  to  the  syntax: 

r  ::=  f  1 far  /  r, r'  /  (r). 
Furthermore,  we  may  restrict  ourselves  to  considering  only  single-output  networks. 
We  may  then  define  the  clock  abstraction  C(r)  of  a  network  r  as  a  function  from 

Clocks""  to  Clocks,  where 

Clocks  =  Integers  u  Single-output  networks  u  {error}, 
with: 

(a)  iff  is  of type  a  and  b  then  C(,fi  (r, r',  T r"))(c)  =  if C(r)(c)  =  C(r')(c) 

=  . . =  C(r")(c) 

then  C(r)(c), 
else  error. 

Clocks  in  datqflow  languages  137 
(b)  {fff`is  ef  type  c  then  C(fo(r,  r'))(c)  =  tf  C(r)(c)  =  C(r')(c)  then  r  else  error, 

(c)  ifff  is  of  type  d  then  C(fo(r,  r'))(c)  =  if  C(r')(c)  =  r  then  C(r)(c)  else  error, 
(d)  the  clock  abstraction  qf routing  functions  operates  as  usual. 

From  Section  3.1,  it  is  quite  easy  to  check  that  if  C(r)(c)  can  be  evaluated  without 
yielding  error  in  the  course  of evaluation,  then  CX : r holds.  It  should  be  noted  that  this 
is  a  syntactic  clock  calculus  (SCC),  that  can  be  implemented  at  compile  time.  A  deeper 

clock  calculus  could  result  from  a  semantical  analysis,  for  instance  by  replacing,  in 
the  above  rules,  conditions  like  C(r')(c)  =r  by  their  semantical  counterparts: 

[C(r')(c)]  =  [r].  But  this  is  clearly  much  more  difficult. 

3.4.  Feedback  networks,  the  general  case 

Here  also,  results  from  single-output  networks  extend  easily  to  more  general  ones. 
The  first  step  towards  the  analysis  of  such  networks  consists  in  extending  SCC  to 

recurrent  equations.  This  is  achieved  by  adding  to  Clocks  an  undefined  element,  which 
can  be  replaced  by  any  suitable  element  in  the  conditions  given  in  Section  3.3.  Then, 

Clocks  can  be  seen  as  a  flat  complete  lattice,  with  minimum  element  undefined,  and 
maximum  element  error.  We  shall  then  define  C(Yr)(c)  as  the  least  solution  of  the 
equation  x =  C(r)(.x,  c). 

But  this  is  not  sufficient  for  applying  inference  rule  (IRd).  The  right  argument 
follows  from  the  following  theorem: 

If  C( Yr)(c)  is  neither  error  nor  undejned,  and  for  any  x,  y  in  D*  x  cX, 

Ir(x,  ~)I=@f`{Nxl),  h(y)},  h w  ere  1 is  such  that,  .for  any  n,  l(n)  >  n,  and  h(y) 
does  not  depend  on  x,  then  CX  : Yr  holds. 

Proof.  First,  we  assimilate  Clocks  elements,  other  than  error  and  undefined,  to  net- 
works:  an  integer  i#O  corresponds  to  the  network  that  outputs  its  ith  input,  and 
0  outputs  a  sequence  of  1, whose  length  is  the  length  of  any  input  whose  clock  is  0. 

Now,  CX  is  sequential,  as  noted  in  Section  3.2.  Then,  any  solution  of  x=r(x,  y) 
verifies  IxI=Ir(x,y)I=inf{l(lxI),  h(y)},  and  l(lxl)>lxl  implies  Ixl=h(y).  This  shows 
that  there  is  only  one  solution  and  I cX.  Yr(y)l  =  h( y). 

Let  u=C(Yr)(c)(x,y).  It  is  easy  to  check  that  h(y)=count(u)(Iu().  We  have  then 
shown  that  { Yr(y),  y I y  in  cX}  is  included  in  (C(  Yr)(c),  c)X,  over  which  r  is  a  mgsm 
mapping.  By  inference  rule  (IRd),  cX:  Yr  holds. 

When  using  this  theorem,  we  have  to  propagate  length  equations  through  the 
network  but,  as,  now  x  is free,  we  may  not  always  use  the  domain  restricted  equations 

but  the  general  ones.  The  general  form  of  Ir(x,  y)I  is  a  formal  expression,  which  can  be 
defined  by  the  syntax 

exp::=lxl  I Iyj/  I inf{exp,  exp'}  l coWr'k  y))(w) I ranW(x, y))(d  I exp + 1, 
where  yj  represents  the  jth  component  of  y,  and  r'  is  any  subnetwork  of  r. 

138  P.  Cdspi 

These  expressions  can  be  transformed  by  first,  noting  that  count(u)  and  rank(u) 
functions  are  order  preserving  functions  over  the  totally  ordered  set  of  integers  and, 
therefore,  distribute  over  inf  and,  then,  that  inf  is  associative  and  commutative. 

Properties  such  as  (Pl)  may  then  be  used,  in  order  to  simplify  these  length  expressions. 
However,  an  automatic  application  of  the  theorem  in  Section  3.4  is  rather  difficult  to 
implement. 

3.5.  Feedback  networks  ivithout  ooersampling 

Quite  surprisingly,  the  situation  becomes  much  simpler  when  oversampling  is  not 
allowed,  i.e.  when  first  inputs  of MUX and  last  functions  are  restricted  to  sequences  over 

(0,  1).  This  is  the  case  in  Lustre,  where  the  corresponding  functions  when  and  current 
admit  only  boolean  sequences  as  first  inputs.  We  now  have  the  following  theorem: 

Zf C( Yr)(c)  is  neither  error,  nor  undejned,  and,  ifany  path  from  thejrst  input 
to  the  output  goes  through  the  second  input  of  at  least  one  fby,  then  cX:  Yr 
holds. 

Proof.  We  have  two  cases: 

(1)  C( Yr)(c)(x,  y)=c'(y)  does  not  depend  on  x.  We  introduce  the  auxiliary  network 
r'  such  that  r'(z,  y)=last(c'(y),  r(mux(c'(y),  z),  y)).  Then  Yr(y)=mux(c'(y),  Yr'(y)),  and 
the  problem  amounts  to  verifying  cX:  Yr'.  Let  us  show  that,  for  y  in  cX,  we  can 
express  Ir'(z,  y)I  as  inf  {l(  Izl),  h(y)},  and  apply  the  theorem  in  Section  3.4: 

First,  it  is  easy  to  check  that  h(y)=  lc'(y)l,  which  does  not  depend  on  z. Now,  as  the 
syntactic  clock  calculus  has  not  yielded  error,  I( 1~1) is  an  inf  of  a  list  of  expressions 
exp(  1~1) of  the  form 

exp::=  id  1 +l  I rank(u)`?expocount(u)  / e.xpoexp', 
where  id  denotes  the  identity  function,  +  1 the  increment  function  brought  by  thefby 
trasversal,  and  tl  any  expression  of  the  form  r'(z,  y).  From  the  assumption,  there  is  at 

least  one  +l  in  each  expression.  . 

From  property  (Pl)  and  the  property 

(P2)  If  x  is  a  sequence  over  {0,  l},  then  for  any  n,  rank(x)(count(x)(n)+  l)>n, 
we  may  assert  that,  for  any  n,  e.xp(n)  >  n  and  I(n)  >  n.  The  application  of  the  theorem 
follows  immediately. 

(2)  We  assume  now  that  C( Yr)(x,  y)=c'(x,  y)  depends  on  x,  but  Cc'(x,  y)=c"(y)  is 
independent  of  x  (if this  were  not  the  case,  we  could  apply  step  2  again,  until  it  works, 

as  there  is  a  finite  number  of  clocks  in  a  network,  and  a  circular  "clock  of"  relation 
would  produce  an  error  in  the  clock  calculus).  We  consider  the  auxiliary  network  r' 
such  that  r'(cx,  z,  y) =  c'(mux(cx,  z),  y);  r' verifies  the  assumptions  of step  1, in  the  sense 
that  Cr'(c",  c",  c) =  c",  and  the  condition  on  the  fby  holds,  as  r(x,  y)  depends  on  its 
clock  c'(x,  y).  Thus,  (c", c)X  : Yr'  holds. 

Clocks  in dataflow languages  139 
We  now  consider  the  network  r"  such  that 
r"(z,  y) =  last(  Yr'(z, y),  r(mux(  Yr'(z,  y),  z), y)).  This  too  obeys  the  step  1 conditions  as, 
by  assumption,  C( YY")(z, y) =  c"(y)  is  independent  of  z.  Thus,  CX : Yr"  holds.  Finally, 

Yr(y)  =mux(  Yr'(  Yr"(y),  y),  Yr"(y)),  and,  by  Section  3.3,  CX : Yr  holds. 

3.6.  The  oversampling  case 

We  may  now  understand  why  the  oversampling  case  is  more  complex:  the  reason  is 
that  property  (P2)  does  not  hold  when  x  has  elements  larger  than  1. We  could  prove 
the  corresponding  property: 

(P3)  Ifx  is a sequence  of k-bounded  integers,for  any  n,  rank(x)(count(x)(n)  +  k) >  n, 
but  the  corresponding  theorem  would  be  more  difficult  to  state,  as  the  mgsm  property 
depends  now  on  the  position  of  thefbys,  along  the  cycles  of  the  network,  with  respect 

to  the  position  of  corresponding  lasts  and  muxs. 

3.7.  The  next  case 

In  Lucid,  the  two  fundamental  sequence  operators  are  fby  and  next,  whose  defini- 
tion  is:  next(&)=&,  and  next(d.s)=s. 

Clearly,  next  is  continuous,  but  we  have 

Inext(x)j=sup{O,  1x1-1). 
This  shows  that  the  use  of  next  would  have  brought  important  difficulties  in  the 
theory  exposed  in  this  section:  Primitive  function  domains  would  have  been  more 
complex,  and  the  theorem  in  Section  3.5  would  not  apply,  yielding  a  clock  calculus  as 
complex  as  in  the  oversampling  case.  This  is  why  Lustre  uses,  instead  of  next,  the 

-+  operator  whose  definition  is 

+  (xv Y) =fb(x,  next(y)). 
Then  I-(x,y)I=inS(lxl,l~l},  and  -+  is  simply  a  type  (a)  function  (cf.  Section  3.1). 

Conclusion 

This  work  was  intended  to  show  the  interest  in  a  clock  calculus,  when  using 
a  dataflow  language  in  continuously  operating  systems,  and  the  soundness  of  the 

Lustre  clock  calculus,  in  the  case  of static  deterministic  dataflow  networks.  This  raises 
the  question  of how  this  generalizes  in  the  case  of either  dynamic,  or  nondeterministic, 
or  both  type  of  networks.  Another  question  concerns  the  applications  to  the  design 
and  programming  of  dataflow  machines.  We  hope  this  work  would  provide  some 
elements  for  answering  these  questions. 

140  P.  Caspi 
Acknowledgment 

The  author  gratefully  acknowledges  his  colleagues  N.  Halbwachs,  J.A.  Plaice 
and  D.  Pilaud  of  the  Lustre  team  for  their  numerous  contributions  to  the  paper,  and 

Ph.  Darondeau  of  INRIA/IRISA  for  having  suggested  to  look  for  an  algebraic 
characterization  of  mgsm  mappings. 

References 

[I]  G.  Berry  and  R.  Sethi.  From  regular  expression  to  deterministic  automata,  T/leoret.  Comput.  Sci.  48 

(1987)  117-126. 
[Z]  F.  Boussinot,  Proposition  de  stmantique  d&otationnelle  pour  des  rtseaux  de  processus  avec  mtlange 

Cquitable,  Theoret.  Comput.  Sb.  18 (1982)  173-206. 
[3]  J.D.  Brock,  and  W.B.  Ackerman,  Scenarios.  a  mode1  of  non  determinate  computation,  in:  Proc.  Conf: 

ON Forml  d$nirion  ~~~pro~~ram~niny cmcepts,  Lecture  Notes  in  Computer  Science,  Vol.  107  (Springer, 
Berlin.  1981)  252-259. 
[4]  P.  Caspi  and  N.  Halbwachs,  A functional  model  for  describing  and  reasoning  about  time  behaviour  of 

computing  systems.  Acru  I@m  22  (1986)  595-627. 
[5]  P.  Caspi,  N.  Halbwachs  et  al.,  Lustre:  a  declarative  language  for  programming  synchronous  systems, 

in:  14th ACM  Swap.  on  Priwiples  qf'Pro,yrLmrmin~  Lmgu(rxe.s,  Munchen,  BRD  (1987). 
[6]  J.B.  Dennis,  First  version  of  a  data  flow  procedure  language,  in:  Lecture  Notes  in  Computer  Science, 

Vol.  19  (Springer.  Berlin,  1974)  362-376. 
[7]  S.  Eilenberg,  Automuttr,  lunyuuges  and  machinrs,  Vol.  A  (Academic  Press.  New  York,  1974). 
[S]  C.C.  Elgott  and  G.  Mezei.  On  relations  defined  by  generalized  finite  automata,  IBM  J.  Res.  Detelop. 

9  (1965)  47-65. 
[9]  S.  Ginsburg  and  G.F.  Rose,  A  characterization  of  machine  mappings,  Canud.  J.  Math.  18  (1966) 

38 l-388. 
[lo]  P.  Le.  Guernic,  A.  Benveniste  et  al.,  Signal:  a  data  flow  oriented  language  for  signal  processing,  IEEE 

Truns.  Acoust.  Speech  Signal  Process  34  (2)  (1986)  362-374. 
[ll]  G.  Kahn,  The  semantics  of  a  simple  language  for  parallel  programming,  in:  Proc.  IFIP'74  Congr. 

(North-Holland,  Amsterdam,  1974) 
1121  J.N.  Kok,  A  fully  abstract  semantics  for  data  flow  nets.  Report  CS-RH724,  Centre  for  Mathematics 

and  Computer  Science,  Amsterdam,  The  Netherlands,  1987. 
1131  E.A.  Lee,  and  D.G.  Messerchmidt,  Synchronous  data  flow.  Proc.  IEEE  75  (1987)  1235-1245. 

[l4]  M.  Nivat,  Transductions  des  langages  de  Chomsky,  Ann.  Inst. Fourier  (Grenoble)  18 (1968)  339455. 
[15]  J.A.  Plaice,  Skmantique  et  compilation  de  Lustre,  un  langage  dkclaratif  synchrone,  Doctoral  Thesis, 

lnstitut  National  Polytechnique  de  Grenoble.  1988. 
[16]  V.P.  Srini,  An  architectural  comparison  of  dataflow  systems,  IEEE  Trans.  Compur.  (1986)  68-88. 
1171  W.W.  Wadge  and  E.A.  Ashcroft,  Lucid.  the  Dargflon  Programminy  Languaye  (Academic  Press, 

New  York,  19X5). 