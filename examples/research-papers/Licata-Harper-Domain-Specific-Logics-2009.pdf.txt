

Submitted to POPL '09
Dependently Typed Programming with Domain-Specific Logics

Daniel R. Licata Robert Harper

Carnegie Mellon University{

drl,rwh}@cs.cmu.edu

Abstract
We define a dependent programming language in which program-mers can define and compute with domain-specific logics, such as

an access-control logic that statically prevents unauthorized accessto controlled resources. Our language permits programmers to define logics using the LF logical framework, whose notion of bind-ing and scope facilitates the representation of the consequence relation of a logic, and to compute with logics by writing functionalprograms over LF terms. These functional programs can be used to
compute values at run-time, and also to compute types at compile-time. In previous work, we studied a simply-typed framework for
representing and computing with variable binding [LICS 2008]. Inthis paper, we generalize our previous type theory to account for dependently typed inference rules, which are necessary to adequatelyrepresent domain-specific logics, and we present examples of using
our type theory for certified software and mechanized metatheory.
1. Introduction
In this paper, we describe a functional language for program-ming with domain-specific logical systems--i.e., new programming languages and logics relevant to a particular programmingtask. Applications of domain-specific logics include both mechanized metatheory, where studying a logical system is itself the goal,and certified software, where a domain-specific logic is used to establish properties of run-time code. Examples of the latter include:

* Cryptol [22], a language for implementing cryptographic pro-tocols, tracks the lengths of vectors statically, in the style of

DML [60].*
Security-typed programming languages such as Aura [30] andPCML5 [4] employ authorization logics to statically prevent

unauthorized access to controlled resources.*
Ynot [41], an implementation of Hoare Type Theory [39], pro-vides a separation logic for reasoning about imperative code.

These languages' type systems are domain-specific logics for rea-soning about a particular programming style or application domain.
Some logics may admit effective decision procedure (e.g., lineararithmetic), while others require non-trivial proofs (e.g., separation
logic). The goal of the present work is to give a single host languagein which domain-specific logics like these may be embedded, so
that programmers may easily define domain-specific logics, reason

[Copyright notice will appear here once 'preprint' option is removed.]

about them, and use them to reason about code. With such a hostlanguage, new logics may be implemented as libraries, not new languages.To achieve this goal, a host language must provide the means
to represent and compute with logical systems. Both of these taskscan be accomplished in a dependently typed functional programming language: dependent types are sufficiently rich to adequatelyrepresent the deductive apparatus of logical systems, and functional
programs allow computation by structural recursion on syntax andderivations. Indeed, dependent types have already proved quite useful for these tasks--e.g., for mechanizing metatheory in Coq [13],or for embedding typed domain-specific languages in Agda [43].

However, it is our thesis that significant applications of domain-specific logics require good support for representing and computing with binding and scope--i.e., bound variables, ff-conversion,and substitution at the level of syntax, and hypothetical judgements,
such as the consequence relation of a logic, at the level of proofs.Whereas languages such as Agda and Coq provide no intrinsic support for binding and scope, the LF logical framework [27], itselfa dependently typed

*-calculus, supports facile representations ofbinding using the LF function space. While LF functions are suitable for representing variable binding, they provide no account ofcomputation with logical systems, as is provided by the function
space of Agda and Coq or ML and Haskell. Consequently, it isnecessary to combine LF with some further mechanism for computation, such as the separate computational languages of Twelf [45],Delphin [48], and Beluga [46]. In previous work [34], we investigated an alternative approach, using the logical notions of polar-ity [25] and focusing [2] to integrate representational and computational functions as two types in a single, simply-typed, log-ical framework. This integrated approach permits inference rules
that mix iterated inductive definitions [36] and hypothetical judge-ments. However, adequately representing domain-specific logics
necessitates a dependently typed framework, and we do not wishto pursue dependency on computation at this time. Thus, we adopt
a stratified approach here, taking LF as a separate representationlanguage, and leaving richer dependency to future work.

In this paper, we adapt our previous techniques for computingwith binding and scope to a dependently typed framework, yielding
a language suitable for programming with domain-specific logics:

1. We define and study a type theory in which programmers maydefine domain-specific languages and logics using LF, compute

with LF terms via pattern-matching functional programs, anddefine types by recursion on LF terms. Type-level computation
is not provided by any previous computational language for LF.
2. We demonstrate the expressiveness of this framework by givingexamples of certified software and mechanized metatheory:

we embed a security-typed language in the style of Aura andPCML5, and we show the role of type-level computation in
formalizing a logical relations argument.

1 2008/7/16

Our type theory is organized around the logical notions of po-larity [25] and focused proofs [2], exploiting the Curry-Howard
correspondence between focused proofs and pattern-matchingfunctional programs. As in our previous joint work, we follow
Zeilberger's higher-order formulation of focusing [34, 62, 63]:

* The syntax of programs reflects the interplay of focus (choos-ing patterns) and

inversion (pattern matching), with individualtypes defined by their pattern typing rules.

* The syntax of types is polarized, distinguishing positive data

(introduced by focus, eliminated by inversion) from negativecomputation (introduced by inversion, eliminated by focus).

* Pattern matching is represented abstractly by meta-functions--

functions in the ambient mathematical system in which our typetheory itself is defined--from patterns to expressions (hence

higher-order focusing), and the syntax and typing rules of ourtype theory are defined by iterated inductive definitions [36].

While this style of presentation may be unfamiliar to some read-ers, it has several advantages: First, polarized types provides a natural framework for integrating representations of logics (as posi-tive types) and computation with them (as negative types). Second,
the use of meta-functions to represent pattern-matching allows ourtype theory to be computationally open-ended (cf. Howe [29]) with
respect to the meaning of pattern-matching: any method of trans-forming every pattern for

A into an expression of type B countsas a pattern-match from
A to B. Abstracting the syntax for pat-tern matching out of the core type theory affords the freedom to

use several different notations for pattern matching in a single pro-gram, and to import functions from other languages and systems.
For example, as we show below, we may import all existing Twelffunctions as inhabitants of certain types in our language. Third, focused proofs emphasize pattern matching as the means of comput-ing with positive data; this naturally extends to the definition of
types by pattern-matching on positive data.In addition to polarity and focusing, our type theory makes
essential use of contextual types, inspired by Contextual ModalType Theory [40] and FO

*\Delta r [38], to manage the scoping ofLF variables. We take a pronominal approach to variables: every

variable occurrence is a reference to a binding site, either in aterm or in a context. This is different than approaches based on
nominal logic [54], where names exist independently of a scope;consequently, we avoid stateful name generation and can easily
scale to dependency on syntax with binding. However, there aretechnical differences between our treatment of contextual types and
those in previous work, as we discuss further below.
Organization We describe our type theory in Section 2, examplesin Section 3, and related work in Section 4.

2. A Type Theory for Domain-Specific Logics
Our type theory consists of:

* A representational language, the LF logical framework.

* A computational language based on polarized intuitionisticlogic. The computational language is specified by:

Defining its types (Figure 1) and patterns (Figure 2).
A focusing framework (Figure 3) and its operational seman-tics (Figure 4)

We discuss LF in Section 2.1, types and patterns in Section 2.2, andthe focusing framework in Section 2.3.

2.1 LF
We briefly review the LF methodology for representing languagesand logics [27]: LF generalizes the ML datatype mechanism with

(1) dependent types and (2) support for binding and scope. Thejudgements of a domain-specific logic (DSL) are represented as LF
types, where dependency is used to ensure adequacy. Derivations ina DSL are represented as canonical (

fi-normal, j-long) LF terms.LF function types are used to represent binding and scope, including the bound variables of DSL syntax and the contexts of DSLhypothetical judgements. Structural induction over canonical LF
terms corresponds to induction over DSL syntax and derivations:inductive proofs about a DSL can be recast as proofs by induction
on the the LF representation.We use a presentation of LF with with syntax for canonical
forms only [58]:

LF kind K ::= type | \Pi  u:A. KLF type

A ::= a M1 . . . Mn | \Pi  u:A1 . A2LF term
M ::= u M1 . . . Mn | * u. MLF signature

\Sigma  ::= * | \Sigma , a : K | \Sigma , u : ALF context
\Psi  ::= * | \Psi , u : ALF world W ::= {

\Psi 1, . . .}

All LF judgements are tacitly parametrized by a fixed signature \Sigma .In the following, we will make use of the judgements:

* \Psi  `LF A type The type A is a well-formed in \Psi 

* \Psi  `LF M : A The term M is a canonical form of type A in \Psi 

* \Psi  ` \Psi 0 2 W The context \Psi 0 is in the world (set of contexts)W. This judgement also ensures that `

LF \Psi , \Psi 0 ctx, i.e., that thecontext \Psi , \Psi 0 is well-formed.

We refer the reader to the literature for the definitions of thesejudgements: Watkins et al. [58] discuss type formation and typing;
one possible definition of worlds W is the regular worlds notationof Twelf [45].

2.2 Types and Patterns
Natural deduction is organized around introduction and elimina-tion: For example, the disjoint sum type

A \Phi  B is introducedby constructors
inl and inr and eliminated by pattern-matching;the computational function type

A ! B is introduced by pattern-matching on the argument
A and eliminated by application. Po-larized logic [2, 24, 31, 33, 62] partitions types into two classes,

called positive (notated A+) and negative (notated A-). Positivetypes, such as \Phi , are introduced by choice and eliminated by
pattern-matching, whereas negative types, such as !, are intro-duced by pattern-matching and eliminated by choice. More specifically, positive types are constructor-oriented: they are introducedby choosing a constructor, and eliminated by pattern matching
against constructors, like datatypes in ML. Negative types aredestructor-oriented: they are eliminated by choosing an an observation, and introduced by pattern-matching against all possibleobservations (

A ! B is observed by supplying a value of type A,and therefore defined by matching against such values). Choice

corresponds to Andreoli's notion of focus, and pattern-matchingcorresponds to inversion. These distinctions can be summarized as
follows:

introduce A eliminate A
A is positive by focus by inversion
A is negative by inversion by focus

In higher-order focusing [34, 62, 63], types are specified by pat-terns, which are used in both focus and inversion: focus phases
choose a pattern, whereas inversion phases pattern-match. In

2 2008/7/16

Pos. type A+ ::= #A- | 1 | A+ \Omega  B+ | 0 | A+ \Phi  B+| 9

A(o/+) | \Psi  ) A+ | @A+ | 9W (+)where o/+ ::= { M 7! A+ | . . . }

+ ::= { \Psi  7! A+ | . . . }Neg. type
A- ::= "A+ | A+ ! B- | ? | A-NB-| 8

A(o/-) | \Psi  f A- | \Pi A- | 8W(-)where o/- ::= { M 7! A- | . . . }

- ::= { \Psi  7! A- | . . . }CPT
C+ ::= h\Psi i A+CNT

C- ::= h\Psi i Ah\Psi i A+ type

h\Psi i A- typeh

\Psi i #A- type h\Psi i 1 type h

\Psi i A+ type h\Psi i B+ typeh

\Psi i A+ \Omega  B+ type

h\Psi i 0 type h

\Psi i A+ type h\Psi i B+ typeh

\Psi i A+ \Phi  B+ type

\Psi  `LF A type (\Psi  `LF M : A -! h\Psi i o/+(M ) type)h

\Psi i 9A(o/+) type h*i

A+ typeh
\Psi i @A+ type

`LF \Psi , \Psi 0 ctxh

\Psi , \Psi 0i A+ typeh

\Psi i \Psi  ) A+ type

(\Psi  ` \Psi 0 2 W -! h\Psi i +(\Psi 0) type)h

\Psi i 9W (+) type

h\Psi i A- type

h\Psi i A+ typeh

\Psi i "A+ type h

\Psi i A+ type h\Psi i B- typeh

\Psi i A+ ! B- type

h\Psi i ? type h

\Psi i A- type h\Psi i B- typeh

\Psi i A-NB- type

\Psi  `LF A type (\Psi  `LF M : A -! h\Psi i o/-(M ) type)h

\Psi i 8A(o/-) type h*i

A- typeh
\Psi i \Pi A- type

`LF \Psi , \Psi 0 ctxh

\Psi , \Psi 0i A- typeh

\Psi i \Psi 0 f A- type

(\Psi  ` \Psi 0 2 W -! h\Psi i -(\Psi 0) type)h

\Psi i 8W (-) type

We write h\Psi i A+ ok iff `LF \Psi  ctx and h\Psi i A+ type, and similarly forh

\Psi i A- ok. We write \Delta  ok iff h\Psi i A- ok for all x : h\Psi i A- in \Delta .

Figure 1. Type formation

this section, we define the types and patterns of our language--constructor patterns for positive types, and destructor patterns for
negative types. Note that patterns must be defined prior to the fo-cusing framework presented in Section 2.3, which uses an iterated
inductive definition quantifying over them to specify inversion.
2.2.1 Types
We present the rules for type formation in Figure 1. The judgementsh

\Psi i A+ type and h\Psi i A- type define the well-formed types, whichare considered relative to an LF context

\Psi . The basic positivetypes of polarized type theory are products (

A+ \Omega  B+ and 1), sums(
A+ \Phi  B+ and 0), and shift (#A-), the inclusion of negative typesinto positive types. The formation rules for these types carry the

LF context \Psi  through unchanged.The remaining positive types are for programming with LF
terms. The most basic of these is existential quantification of anLF term, written 9

A(o/+), where A is an LF type, and o/+ is a meta-function from LF terms M of type A to positive types. We notate

meta-functions o/+ by their graphs--i.e., by a possibly infinite set

Con. pattern p ::= x | () | (p1 , p2 ) | inl p | inr p|

(M , p) | *\Psi .p | box p | (\Psi , p)Dest. pattern
n ::= ffl | p ; n | fst; n | snd; n|

M ; n | unpack \Psi .n | undia; n | \Psi ; n
Context. con. pat. c ::= \Psi .p
Context. dest. pat. d ::= \Psi .nContext

\Delta  ::= * | \Delta , x : C \Delta  ; \Psi  fl p :: A+

x : h\Psi i A- ; \Psi  fl x :: #A* ; \Psi  fl () :: 1

\Delta 1 ; \Psi  fl p1 :: A+ \Delta 2 ; \Psi  fl p2 :: B+

\Delta 1, \Delta 2 ; \Psi  fl (p1 , p2 ) :: A+ \Omega  B+

(no rule for 0)
\Delta  ; \Psi  fl p :: A+
\Delta  ; \Psi  fl inl p :: A+ \Phi  B+

\Delta  ; \Psi  fl p :: B+
\Delta  ; \Psi  fl inr p :: A+ \Phi  B+

\Psi  `LF M : A \Delta  ; \Psi  fl p :: o/+(M)

\Delta  ; \Psi  fl (M , p) :: 9A(o/+)

\Delta  ; * fl p :: A+
\Delta  ; \Psi  fl box p :: @A+

\Delta  ; \Psi , \Psi 0 fl p :: A+
\Delta  ; \Psi  fl *\Psi 0.p :: \Psi 0 ) A+

\Psi  ` \Psi 0 2 W \Delta  ; \Psi  fl p :: +(\Psi 0)

\Delta  ; \Psi  fl (\Psi 0, p) :: 9W(+)

\Delta  ; \Psi  fl n :: A- > C+

* ; \Psi  fl ffl :: "A+ > h\Psi i A+
\Delta 1 ; \Psi  fl p :: A+ \Delta 2 ; \Psi  fl n :: B- > C+

\Delta 1, \Delta 2 ; \Psi  fl p ; n :: A+ ! B- > C+

(no rule for ?)
\Delta  ; \Psi  fl n :: A- > C+
\Delta  ; \Psi  fl fst; n :: A-NB- > C+

\Delta  ; \Psi  fl n :: B- > C+
\Delta  ; \Psi  fl snd; n :: A-NB- > C+

\Psi  `LF M : A \Delta  ; \Psi  fl n :: o/-(M) > C+

\Delta  ; \Psi  fl M ; n :: 8A(o/-) > C+

\Delta  ; \Psi , \Psi 0 fl n :: A- > C+
\Delta  ; \Psi  fl unpack \Psi 0.n :: \Psi 0 f A- > C+

\Delta  ; * fl n :: A- > C+
\Delta  ; \Psi  fl undia; n :: \Pi A- > C+

\Psi  ` \Psi 0 2 W \Delta  ; \Psi  fl n :: -(\Psi 0) > C+

\Delta  ; \Psi  fl \Psi 0; n :: 8W(-) > C+

\Delta  fl c :: h\Psi i A+ and \Delta  fl d :: h\Psi i A- > C+

\Delta  ; \Psi  fl p :: A+
\Delta  fl \Psi .p :: h\Psi i A+

\Delta  ; \Psi  fl n :: A- > C+
\Delta  fl \Psi .n :: h\Psi i A- > C+

Figure 2. Constructor and destructor patterns

of non-overlapping pattern branches of the form M 7! A+. Theformation rule for h

\Psi i 9A(o/+) requires that A be an LF type in \Psi ,and that
o/+ deliver a positive type in \Psi  for every LF term in \Psi : wenotate iterated inductive definitions by inference rule premises of

the form (J1 -! J2). By convention, we tacitly universallyquantify over meta-variables that appear first in the premise of

3 2008/7/16

an iterated inductive definition, so the second premise of the rulemeans "for all

m, if \Psi  `LF M : A then h\Psi i o/+(M ) type".The body of the existential type 9

A(o/+) may be computedfrom the existentially-quantified LF term in interesting ways. For

example, if we define an LF type nat of natural numbers withconstructors

zero and succ, then we can define a positive type oflists as follows (we may also define it in more traditional ways):

list (A+) = 9nat(o/list)where
o/list zero = 1
o/list (succ zero) = A+
o/list (succ (succ zero)) = A+ \Omega  A+
o/list (succ (succ (succ zero))) = A+ \Omega  (A+ \Omega  A+).

..

That is, for every nat n, o/list(n) is the tuple type (A+)n. Animplementation of our type theory would provide a traditional
finitary notation for presenting meta-functions o/+, e.g., allowing
o/list to be defined by recursion.There are three additional positive types for programming with

LF. The types \Psi  ) A+ and @A+ allow for computational languagevalues that manipulate the LF context; their formation rules manipulate the LF context in the same way as their patterns do (seebelow). Finally, the type 9

W() allows existential quantificationover the LF contexts in a world W. As with 9

A(o/+), the body ofthe existential is specified by an abstract pattern-match, this time on

LF contexts. This allows types to be defined by computation withLF contexts.

The type formation rules for negative types are analogous. Wesometimes abbreviate h

\Psi i A+ by writing C+ and similarly for C-.Operationally, the type formation rules are syntax-directed and

well-moded (none of the meta-variables appearing in the judge-ments need to be guessed), with both

\Psi  and A as inputs. The rulesfor h
\Psi i A assume and maintain the invariant that `LF \Psi  ctx.

2.2.2 Patterns
We present the rules for pattern formation in Figure 2.

Constructor Patterns Positive types are specified by the judge-ment

\Delta  ; \Psi  fl p :: A+, which types constructor patterns. Thisjudgement means that

p is a constructor pattern for A+, usingthe LF variables in
\Psi , and binding negative contextual variables
x : h\Psi 0i A-0 in \Delta  for all subterms of negative types. The LF vari-ables in

\Psi  are free in p and A+ but not \Delta : negative assumptions in
\Delta  have no free LF variables, because the free variables of A- arebound by the context

\Psi . Like datatype constructors in ML, con-structor patterns are used both to build values and to pattern match.

Logically, constructor patterns correspond to using linear right-rules to show

A+ from \Delta ; linearity ensures that a pattern binds avariable exactly once.

The patterns for products and sums are standard. The onlypattern for #

A- is a variable x bound in \Delta : one may not pattern-match on negative types such as computational functions. Note that

x is bound with a contextual type h\Psi i A- capturing the currentcontext

\Psi : this contextual type binds the free LF variables of
A+, and ensures that the free LF variables of a term are properlytracked by its type. Moreover, #

A- is the only type at which patternvariables are allowed: patterns may not bind variables at positive

types.Next, we consider the patterns for computing with LF terms.
The pattern for 9A(o/+) is a pair whose first component is an LFterm

M of type A, and whose second component is a pattern for thepositive type

o/+(M )--the type of the second component is com-puted by applying the meta-function

o/+ to M . For example, return-ing to the above example of lists defined as 9

nat(o/list), we have the

pattern (zero, ()) representing "nil", because o/list(zero) = 1. Thepatterns for

\Psi  ) A+ and @A+ manipulate the LF context: *\Psi .pbinds LF variables (we write

\Psi  for the bare variables of \Psi , withoutany types), whereas
box p wraps a pattern that is independent of theLF context. The pattern for 9

W(+) pairs an LF context \Psi  with apattern for the type (\Psi ), analogously to 9

A(o/+).

Destructor Patterns Negative connectives are specified by thejudgement

\Delta  ; \Psi  fl n :: A- > C+, which types destructor pat-terns. A destructor pattern describes the shape of an observation

that one can make about a negative type: the judgement means that
n observes the negative type A- to reach the positive conclusion
C +, using the LF variables in \Psi  and binding the pattern variablesin

\Delta . The context \Psi  scopes over n and A- but not \Delta  and C +--like assumptions, the conclusion

C+, which abbreviates h\Psi 0i A+0 ,is modally encapsulated, potentially in a different context than

\Psi .Logically, destructor patterns correspond to using linear left-rules

to decompose A- to C+. Because we are defining an intuitionistic,rather than classical, type theory, destructor patterns are not quite
dual to constructor patterns: constructor patterns have no conclu-sions, whereas destructor patterns have exactly one.

The destructor patterns for the basic types are explained as fol-lows: a negative pair

A-NB- can be observed by observing itsfirst component or its second component; negative pairs are lazy

pairs whose components are expressions, whereas positive pairs
A+ \Omega  B+ are eager pairs of values. A function A+ ! B- can be ob-served by applying it to an argument, represented here by the constructor pattern p, and then observing the result. As a base case, wehave shifted positive types "

A+, which represent suspended expres-sions computing values of type

A+. A suspension can be observedby forcing it, written
ffl, which runs the suspended expression downto a value; the LF context

\Psi  is encapsulated in the conclusion ofthe force. The destructor patterns for the remaining types are analogous to their positive counterparts: universal quantification overLF terms 8

A(o/-) is eliminated by choosing an LF term M to ap-ply to, and observing the result; and similarly for universal context

quantification. Finally, \Psi  f A- and \Pi A- manipulate the LF contextof a negative type.

Contextual Patterns In the focusing framework below, we willrequire contextually encapsulated patterns with no free LF variables. Contextual constructor patterns c have the form \Psi .p; theyare well-typed when

p is well-typed in \Psi . Contextual destructorpatterns are similar. In contextual patterns

\Psi .p and contextual typesh
\Psi i A, the context \Psi  is considered a binding occurrence for all itsvariables, which may be freely

ff-converted.

Mode and Regularity The pattern typing rules in Figure 2 aresyntax-directed and well-moded: the assumptions

\Delta  and conclu-sion
C + of destructor pattern typing, and the assumptions \Delta  ofconstructor pattern typing, are outputs (synthesized), whereas all

other components of the judgements are inputs. The judgementsassume that their inputs are well-formed and guarantee that their
outputs are well-formed:
Proposition 1 (Pattern Regularity).

* If C+ ok and \Delta  fl c :: C+ then \Delta  ok.*

If C-0 ok and \Delta  fl d :: C-0 > C+ then C+ ok and \Delta  ok.

2.3 Focusing Framework
We present our focusing framework for polarized intuitionistictype theory in Figure 3, which is essentially unchanged from our

previous work [34]: the extension with dependent types is localizedto the types and their constructor and destructor patterns. In these
rules, \Gamma  stands for a sequence of pattern contexts \Delta , but \Gamma  itself istreated in an unrestricted manner (i.e., variables are bound once

4 2008/7/16

Context \Gamma  ::= * | \Gamma , \Delta 
Pos. Value v+ ::= c [oe]Pos. Cont.

k+ ::= ffl | cont+(OE+) | ffl | k+1 thenC+ k+2where

OE+ ::= {c 7! e | * * * }Expression
e ::= v+ | x * k- | v- *C- k- | casevC+ v+ of k+ | caseC+ e of k+

Neg. Cont. k- ::= d[oe]; k+ | k- thenC+ k+Neg. Value

v- ::= x | val-(OE-) | x | fix(x.v-)where

OE- ::= {d 7! e | * * * }Substitution
oe ::= * | oe, v-/x | id | oe1, oe2

\Gamma  ` v+ :: C +

\Delta  fl c :: C+ \Gamma  ` oe : \Delta 

\Gamma  ` c [oe] :: C +

\Gamma  ` k+ : C +0 > C +

(\Delta  fl c :: C+0 -! \Gamma , \Delta  ` OE+(c) : C +)

\Gamma  ` cont+(OE+) : C +0 > C +

C +0 = C +
\Gamma  ` ffl : C +0 > C +

C+1 ok \Gamma  ` k+0 : C +0 > C +1 \Gamma  ` k+1 : C +1 > C +

\Gamma  ` k+0 thenC+1 k+1 : C +0 > C +

\Gamma  ` k- :: C - > C +

\Delta  fl d :: C- > C+0 \Gamma  ` oe : \Delta  \Gamma  ` k+ : C +0 > C +

\Gamma  ` d[oe]; k+ :: C - > C +

C+0 ok \Gamma  ` k- :: C - > C +0 \Gamma  ` k+ : C +0 > C +

\Gamma  ` k- thenC+0 k+ :: C - > C +

\Gamma  ` v- : C (\Delta  fl d :: C- > C+ -! \Gamma , \Delta  ` OE-(d) : C +)

\Gamma  ` val-(OE-) : C x : C -0 2 \Gamma  C - = C -0

\Gamma  ` x : C \Gamma , x : C - ` v- : C \Gamma  ` fix(x.v-) : C \Gamma  ` e : C +

\Gamma  ` v+ :: C +

\Gamma  ` v+ : C +

x : C - 2 \Gamma  \Gamma  ` k- :: C - > C +

\Gamma  ` x * k- : C +

C- ok \Gamma  ` v- : C - \Gamma  ` k- :: C - > C +

\Gamma  ` v- *C- k- : C +

C+0 ok \Gamma  ` v+ :: C +0 \Gamma  ` k+ : C +0 > C +

\Gamma  ` casevC+0 v+ of k+ : C +

C+0 ok \Gamma  ` e : C +0 \Gamma  ` k+ : C +0 > C +

\Gamma  ` caseC+0 e of k+ : C +

\Gamma  ` oe : \Delta 

\Gamma  ` * : *

\Gamma  ` oe : \Delta  \Gamma  ` v- : C \Gamma  ` oe, v-/x : \Delta , x : C \Delta  ` \Gamma 
\Gamma  ` id : \Delta 

\Gamma  ` oe1 : \Delta 1 \Gamma  ` oe2 : \Delta 2

\Gamma  ` oe1 , oe2 : \Delta 1, \Delta 2

identity principles cut principles convenient principles

Figure 3. Focusing rules

in a pattern, but may be used any number of times within thepattern's scope). As a matter of notation, we regard the diacritic
marks on metavariables such as C+ and C- as part of the name ofthe metavariable, not as a modifier, so

C+ and C- are two unrelatedtypes. The focusing rules are syntax-directed and well-moded, with

all pieces of the judgement as inputs.
Canonical Terms First, we discuss canonical terms, which aretyped by the unboxed rules in Figure 3. The first two judgements
define focusing and inversion for positive types. The judgement
\Gamma  ` v+ :: C + defines positive values (right focus): a positive valueis a constructor pattern under a substitution for its free variables.

The judgement \Gamma  ` k+ : C +0 > C + defines positive continuations(left inversion): a positive continuation is a case-analysis, specified
by a meta-function OE+ from patterns to expressions. The premise ofthe rule asserts that for all constructor patterns

c for C0 , OE+(c) isan expression of the appropriate type using the variables bound by

c (by our above convention about iterated inductive definitions, \Delta and

c are universally quantified here).The next two judgements define focusing and inversion for the

negative types. The judgement \Gamma  ` k- :: C - > C + defines negativecontinuations (left focus): a negative continuation is a destructor
pattern under a substitution for its free variables followed by apositive continuation consuming the result of the destructor. The
destructor pattern, filled in by the substitution, decomposes C - tosome positive type

C+0. The positive continuation reflects the factthat it may take further case-analysis of

C+0 to reach the desiredconclusion
C+. The judgement \Gamma  ` v- : C - defines negative values(right inversion): a negative value is specified by a meta-function

that gives an expression responding to every possible destructor.The judgement

\Gamma  ` e : C +, types expressions, which are neutralstates: from an expression, one can right-focus and introduce a

value, or left-focus on an assumption in \Gamma  and apply a negative

5 2008/7/16

continuation to it. Finally, a substitution \Gamma  ` oe : \Delta  provides anegative value for each hypothesis.

At this point, the reader may wish to work through some in-stances of these rules (using the above pattern rules) to see that
they give the expected typings for familiar types. First, the type
("A+1 )N("A+2 ) is inhabited by a lazy pair of expressions:

\Gamma  ` e1 : h\Psi i A+1 \Gamma  ` e2 : h\Psi i A+2
\Gamma  ` val-((\Psi .(fst; ffl)) 7! e1 | (\Psi .(snd; ffl)) 7! e2 ) : h\Psi i ("A+1 )N("A+2 )

Second, a function (#A-1 ) \Phi  (#A-2 ) ! "B+ is defined by twocases:

\Gamma , x : h\Psi i A-1 ` e1 : h\Psi i B+ \Gamma , y : h\Psi i A-2 ` e2 : h\Psi i B+
\Gamma  ` val-((\Psi .inl x) 7! e1 | (\Psi .inr y) 7! e2 ) : h\Psi i (#A-1 ) \Phi  (#A-2 ) ! "B+

In both of these examples, the bindings \Psi  in the contextualpatterns are unused, because there are no LF types mentioned before shifts. As an example where the contextual bindings are rel-evant, consider an LF type

exp representing terms of the untyped
*-calculus. A function from exp to exp is represented by the fol-lowing negative value:

\Gamma  ` e1 : h\Psi i 9exp( 7! 1) . . .
\Gamma  ` val-((\Psi .M1 ; ffl) 7! e1 , . . .) : h\Psi i 8exp( 7! "(9exp( 7! 1)))

In a more familiar notation, the type of this term is written8

: exp.9 : exp.1; we assume the meta-functions o/ allow constantfunctions, notated by a catch-all case . A negative value of this

type is given by a meta-function whose domain is destructor pat-terns for h

\Psi i 8exp( 7! "(9exp( 7! 1))). All destructor patterns forthis type have the form

\Psi .(Mi ; ffl) where \Psi  `LF M : exp becausethe only destructor pattern for 8 is application to an LF term, and

the only destructor pattern for " is ffl. Thus, a negative value of thistype is specified by an

!-rule with one case for each *-term in
\Psi , and the term M in each pattern is in the scope of the variablesbound by

\Psi .

Non-canonical Terms To make a convenient programming lan-guage, we add non-canonical forms and general recursion in the

boxed rules in Figure 3. The first class of non-canonical formsare internalizations of the cut principles for this presentation of
intuitionistic logic; these terms create opportunities for reduction.The most fundamental cuts,

v- *C- k- and casevC+ v+ of k+, puta value up against a continuation. The three remaining cut principles, caseC+ e of k+ and k- thenC+ k+ and k+0 thenC+ k+1 , allowcontinuations to be composed: the first composes a continuation
with an expression, the second composes a negative continuationwith a positive one, and the third composes two positive continuations. The second class of non-canonical forms are internalizationsof the identity principles, which say that terms need not be fully
j-expanded. Negative identity (x ) allows a variable to be used asa value, whereas positive identity (

ffl) is the identity case-analysis.The identity substitution (
id) maps negative identity across eachassumption in
\Delta . Finally, we allow substitutions to be appended(
oe1, oe2) so that the identity substitution can be combined withother substitutions, and we allow general-recursive negative values

(fix(x .v-)).Canonical terms (the unboxed rules in Figure 3) contain no type
annotations, and can be checked against a single type annotationprovided at the outside. However, non-canonical terms have either
too little type information or too much. Cuts have too little type in-formation because they do not obey the subformula property, so we
annotate them with the mediating type. On the other hand, identities

e ; e0

\Delta  fl c :: C+ OE+(c) defined
casevC+ c [oe] of cont+(OE+) ; OE+(c) [oe : \Delta ] pr

casevC+0 v+ of (k+0 thenC+1 k+1 ) ; caseC+1 (casevC+0 v+ of k+0 ) of k+1

casevC+ v+ of ffl ; v+ idk

+

\Delta  fl d :: C-0 > C+ OE-(d) defined
val-(OE-) *C-0 (d[oe]; k+) ; caseC+ (OE-(d) [oe : \Delta ]) of k+ nr

v- *C-0 (k-0 thenC+1 k+1 ) ; caseC+1 (v- *C-0 k-) of k+ k-k

+

fix(x.v-) *C-0 k- ; v- [(fix(x .v-)/x) : (x : C -0 )] *C-0 k- fix

e ; e0
caseC+ e of k+ ; caseC+ e0 of k+ k

+ee

caseC+ v+ of k+ ; casevC+ v+ of k+ k

+ev

Figure 4. Operational Semantics
have too much type information: for example, when x is used as avalue, both the type in the context and a type to check against are
given. Consequently, type checking identity terms requires com-paring two types for equality. Moreover, the identity terms

x and
ffl are the only terms that force two arbitrary types to be comparedfor equality, because

j-expansion pushes the type equality checkdown to base type. (For other instances of this phenomenon, see

LFR [35], where subtyping at higher types is characterized by anidentity coercion, and OTT [1], where an

j-expanded identity co-ercion is induced by proofs of type equality). In the rules, we write

C1 = C2 for "syntactic" equality of types, which is a straightfor-ward congruence with meta-functions compared extensionally--
i.e., two meta-functions are equal if they agree on all inputs.
Operational Semantics The operational semantics of our lan-guage, defined by the judgement

e ; e0 in Figure 4, are quitesimple and essentially unchanged from our previous work [34].

Reduction happens when a focus term is put up against the corre-sponding inversion term. E.g., in the rule

pr, a positive value c [oe]is being scrutinized by a positive continuation

cont+(OE+); this isreduced by applying the meta-function
OE+(c), which performs thepattern matching, and then applying the substitution

oe to the result.Though the types of terms are computationally irrelevant, the operational semantics maintain the annotations on cuts in the interest ofa simple type safety result. We elide the definition of substitution
(e [oe : \Delta ], and similarly for the other syntactic categories), whichis standard, except that it carries the types of the substituted terms
so that the substitution into x * k- can be defined to be v- *C- k-when

v-/x 2 oe and x : C - 2 \Delta .Type safety is proved by the usual simple structural induction:

Theorem 1 (Type safety).Progress: If

C+ ok and * ` e : C + then e = v+ or e ; e0.Preserv.: If
C+ ok and * ` e : C + and e ; e0 then * ` e0 : C +.

Decidability of Type Checking Because all of the judgementsof our type theory are syntax-directed and well-moded, a simple

induction reduces their decidability to decidability of meta-functiontyping and equality:

6 2008/7/16

Theorem 2 (Decidability). Realize meta-functions o/,  with an im-plementation that admits decidable type checking and equality, and
realize meta-functions OE with an implementation that admits decid-able type checking. Then all type formation, pattern formation, and
focusing framework judgements are decidable.

It is reasonable to assume an effective procedure for typechecking an implementation of meta-functions--e.g., if the metafunctions are presented by a finite set of branches with positivepattern variables standing for unexplored parts of a pattern, then
one need only type check a finite number of cases. However, ex-tensional equality of the meta-functions appearing in types (

o/, )will not in general be decidable. Nonetheless, decidability can be

restored in various ways: One option is to restrict o/ and  to a classof meta-functions whose equality is decidable. E.g. if only finite
branching without recursion, and not arbitrary type-level compu-tation, is allowed, then equality may be decidable. Alternatively,
we may implement a sound but conservative approximation to typeequality

C0 = C for use in type checking. When this tactic failsto prove a true equality, the programmer can prove the equality by

manually j-expanding the identity coercion (the identity rules areadmissible given the other rules of the system). As a practical matter, it may be more convenient to prove equalities explicitly, ratherthan by

j-expanded identity coercions, in which case we could per-mit explicit equality proofs as part of the identity terms, perhaps by

internalizing proofs of type equality as a type in the language. Weplan to explore these options in future work.

2.4 Discussion
Now that we have given a technical presentation of our type the-ory, we call attention to some subtle aspects of our treatment of

computation with LF terms.
ff-equivalence Positive continuations k+ and negative values v-are defined using meta-functions

OE on patterns, which contain LFterms. We ensure that these meta-functions respect

ff-equivalenceof LF terms by defining them on
ff-equivalence classes of patterns,where the definition of
ff-equivalence for patterns is a straightfor-ward extension of the definition of

ff-equivalence for LF: The con-text
\Psi  in the judgements \Delta  ; \Psi  fl p :: A+ and \Delta  ; \Psi  fl n :: A- >
C+ binds LF variables, as do the binding forms \Psi .p, \Psi .n, *\Psi .p,and

unpack \Psi .d, and the contexts \Psi  in contextual assumptions andconclusions h

\Psi i A+ and h\Psi i A-. All of these binders can be inde-pendently
ff-renamed.

Scoping We support a variety of types that manipulate the LFcontext ()/f,@/\Pi ) by associating an LF context with each assumption and conclusion in a sequent C-1, . . . , C-n ` e : C +. This resultsin many different LF contexts scoping over different parts of a computation. For example, a positive continuation k+ is typed by twoLF contexts, one for the input to the continuation (giving the LF
variables that may be used in patterns), and another for the output(giving the LF variables that may be used in the result)--a continuation may consume terms in one context and produce termsin another. A positive value

v+ has one LF context determiningthe variables in scope in the pattern, and other, potentially different, LF contexts for each negative value in the substitution, al-lowing for patterns that bind LF variables in a negative subterm.
The type annotations on cuts also cause a context switch. E.g., in
casevh\Psi iA+ v+ of k+, the value v+ and the patterns of the continua-tion

k+ are in the LF context \Psi , but the conclusion of k+ may be ina different context.

Adequacy The LF methodology relies on bijections between thesyntax and derivations of a DSL and the LF terms of particular
types. We may import these adequacy results into our languagebecause the positive values of type 9

A( 7! 1) are essentially the

LF terms of type A (if we canonized substitutions oe by treating idand

oe1, oe2 as derived forms, then this would be a bijection):

Proposition 2 (Adequacy).

* If \Psi  `LF M : A then \Gamma  ` (\Psi .(M , ())) [*] :: h\Psi i 9A( 7! 1).*

If \Gamma  ` v+ :: h\Psi i 9A( 7! 1), then v+ is (\Psi .(M , ())) [oe] where
\Gamma  ` oe : * and \Psi  `LF M : A.

Thus, by type safety, we know that any closed expression of typeh

\Psi i 9A( 7! 1) either is an LF term of type A or steps towards one.

Dependent Pattern Matching Our rules for pattern-matching de-compose LF terms and contexts with an infinitary rule, giving

one case for each LF term of the appropriate type (e.g., nat ispattern-matched with the

!-rule). Consequently, the patterns pre-sented above do not include a number of features found in other

pattern languages for LF [45, 46, 48]: unification variables for LFterms, non-linear patterns, unification variables over LF variables,
and context variables. These features may play a role in the imple-mentation of meta-functions

OE, , and o/, which we do not specify.For example, we illustrate how meta-functions give an abstract

account of dependent pattern matching. Consider the nat type de-fined by

zero and succ, with an identity type defined in LF as fol-lows:

id : nat -> nat -> type.
refl : {n : nat} id n n.

What are the patterns of type 9nat(n 7! 9nat(m 7! id n m))? InTwelf, one would write

(X , (X , refl X)), where the unifica-tion variable
X must be used non-linearly for the pattern to be well-typed. In our formalism, one is required to enumerate all closed

instances of this pattern:

(zero, (zero, refl zero))
(succ zero, (succ zero, refl (succ zero))).

..

Because we allow dependency only on LF terms, dependency can-not force negative variables from

\Delta  to be used non-linearly (thoughdependency on computation would do so).

3. Examples
3.1 Security-Typed Programming
Security-typed languages, such as Aura [30] and PCML5 [4], usean authorization logic to control access to resources. The basic

ingredients of an authorization logic are:

* Resources, such as files and database entries, and principals

such as users and programs.*

Atomic propositions describing permissions--e.g., a proposi-tion

K mayread F for a principal K and file resource F.*

A modality K says A meaning that principal K affirms the truthof proposition

A. The says modality permits access controlpolicies to be specified as the aggregation of statements by

many different principals, which is important when differentprincipals have jurisdiction over different resources.

Beyond these simple ingredients, there are many choices: Is thelogic first-order or higher-order, intuitionistic or classical? What
laws should the says modality satisfy? How are principals and re-sources represented? How are principals' statements authenticated?
Unlike Aura [30] and PCML5 [4], which provide fixed answers tothese questions, our type theory allows programmers to program
many different authorization logics, and to combine code writtenusing different logics in a single program.

7 2008/7/16

sort : type.
princ : sort.
res : sort.

term : sort -> type.
self : term princ.

aprop : type.
prop : type.
atom : aprop -> prop.
implies : prop -> prop -> prop.
says : term princ -> prop -> prop. %infix says.
all : (term S -> prop) -> prop.

hyp : prop -> type. %postfix hyp.
conc : type.
true : prop -> conc. %postfix true.
affirms : term princ -> prop -> conc. %infix affirms.

|- : conc -> type.
init : (atom X) hyp -> |- (atom X) true.
aff : |- K affirms A

<- |- A true.
impr : |- (implies A B) true

<- (A hyp -> |- B true).
impl : ((implies A B) hyp -> |- J)

<- |- A true
<- (B hyp -> |- J).
saysr : |- (K says A) true

<- |- K affirms A.
saysl : ((K says A) hyp -> |- K affirms C)

<- (A hyp -> |- K affirms C).
allr : |- (all ([c] A c)) true

<- {c : term S} |- (A c) true.
alll : ((all A) hyp -> |- J)

<- ((A T) hyp -> |- J).
cut : |- J

<- |- A true
<- (A hyp -> |- J).

%% a policy for file access:
dan : term princ.
/home/dan/plan : term res.

owns : term princ -> term res -> aprop. %infix owns.
mayrd : term princ -> term res -> aprop. %infix mayrd.

ownsplan : (atom (dan owns /home/dan/plan)) hyp.
danplan : (dan says

(all [p] atom (p mayrd /home/dan/plan))) hyp.
grantrd : all ([p] (all ([q] (all [r]

implies (atom (p owns r))
(implies (p says atom (q mayrd r))

(atom (q mayrd r))))))) hyp.

Figure 5. LF Signature for Authorization Logic
An Authorization Logic In this section, we define a first-order,intuitionistic authorization logic, where

says is an indexed laxmodality (indexed monad), following Garg and Pfenning [23]. For

simplicity, we consider only a fixed collection of principals andresources, represented in LF, and a fixed access control policy. We
present an LF encoding of this logic in Figure 5. There are two sortsof terms,

principals and resources, with a distinguished principal
self on behalf of whom the programs runs. Propositions includeatomic propositions (classified by LF type

aprop), implication,universal quantification over terms, and the says modality

K says
A. The logic is defined as a sequent calculus with one kind of

hypothesis (A hyp) and two kinds of conclusions: A true, and K
affirms A--the judgement on which the says modality is based.We mix prefix, infix, and postfix notation to match the standard

syntax for these judgements; note that |- binds more loosely than
true and affirms, so |- A true is |- (A true). The rulesfor atomic propositions, implication, and universal quantification

are standard, and the rules aff, saysr, and saysl give the returnand bind operations for the lax modality. We include

cut as anexplicit rule, for reasons discussed below. This LF encoding uses

higher-order abstract syntax to represent the syntax of propositions(e.g.,

all) and to manage the assumptions of the sequent calculus(e.g., all left rules as well as

allr and impr add assumptions tothe context; the
alll rule uses LF function application to performsubstitution). Using LF to define logics saves programmers the

bureaucracy of implementing variable binding concretely.Next, we define principals and resources specific to an application, along with an access control policy for them. As a very simpleexample, we may control reads to files on a file system. To do so,
we define principals for file owners (in this case, dan), resources forfiles (

/home/dan/plan) and two atomic propositions, stating thata principal owns a resource (written

K owns R) and that a principalmay read a resource (
K mayrd R). The access-control policy is de-fined by loading the LF context with certain initial hypotheses; in

this case, that Dan owns his plan file (ownsplan), that Dan says thatall principals may read his plan (

danplan), and that if the owner ofa resource says that some principal can read it, then that principal

can read it (grantrd). This last axiom provides a controlled way ofescaping from the affirmation monad back to truth. Programmers
can prove propositions in the logic by constructing LF terms rep-resenting derivations; for example, it is simple to show that

selfmay read the file
/home/dan/plan by constructing a derivation of
|- (atom (self mayrd /home/dan/plan)) true. The deriva-tion uses

danplan, ownsplan, and grantrd, as well as logicalrules.

Access-Controlled Operations Now that we have a logic forspecifying authorization, we may use it to give rich types to functions that interact with resources, such as a function for reading thecontents of a file:
read : h * i 8r:term res.8

:|- (atom (self mayrd r)) true."

string

To write this type, we use an informal concrete syntax for meta-functions, allowing ourselves to write 8

X : A.B+ for the type8
A(X 7! B+) when the meta-function can be defined uniformlywith only one pattern branch binding a meta-variable X . To remain in the formalism presented above, we define string as
(9 : lstring.1), where lstring as an LF type representing lists ofcharacters.

To call this function, a programmer must provide a file resource
r as well as a proof that the program may read r. The resource ris used as the file name, and the function returns the contents of

the file. The intended invariant of this DSL is that a proof of self
mayrd F implies that the file F exists and that the program has theappropriate file system permissions to read it; if this invariant is

violated (i.e. the DSL itself is incorrect), then read will abort, e.g.by looping or raising an exception. If a client program uses this
interface for all reads, then all reads are authorized by the accesscontrol policy. It is important that

read is typed in the empty LFcontext (i.e., that its contextual type is h*i

A-): otherwise, clientscould simply bind new LF variables standing for proofs and use

them to justify a call to read.How is

read implemented? One option is to simply ignore theproof, map the resource to a string, and call a primitive read function (we did not include I/O effects in the above presentation of ourtype theory, but they are simple to add). In this case, dependency

8 2008/7/16

is used only to enforce an invariant, with no bearing on the actualrun-time behavior. Alternatively, following Vaughan et al. [57], we
may wish read to log the provided proofs for later audit. Adminis-trators can use such logs to diagnose unexpected consequences of
an access-control policy. Logging requires a function
tostring : h * i 8J:conc. 8 :(|- J). "string
which can be implemented by induction on LF terms.

Policy Analysis We can use computation with LF terms to in-vestigate the properties of the stated access control policy. As a

very simple example, we may wish to know that the only ownerof

/home/dan/plan is dan. We can encode this theorem with anegative value of the following type. Because we included general

recursion in the language, a term with this type is not necessarily aproof, but we do not use

fix to write this particular term.

onlydan : h*i 8P : term princ.8

: (atom (P owns /home/dan/plan)) hyp."9

: id P dan. 1

This theorem says: for any principal P that owns /home/dan/plan,
P is dan, where id is an LF type family representing equality:

id : term S -> term S -> type.
refl : id T T.

We implement onlydan with a meta-function on destructors:

onlydan = val-(dan ; ownsplan ; ffl 7! (refl, ()) [*])

A meta-function OE implementing onlydan is well-typed when:

(\Delta  fl d :: h*i A- > C+ -! * ` OE(d) : C +)
where A- is the type ascribed to onlydan above. In this LF sig-nature and context, the only destructor pattern of this type is

dan ; ownsplan ; ffl, in which case \Delta  is empty and C + is the contex-tual type h*i "9

: id dan dan.1--the result type is refined by thecase analysis. The positive value

(refl, ()) [*] inhabits this type.

Auditing and Cut Elimination We have deliberately included
cut as a rule in our authorization logic because the time and spacecosts of normalizing proofs can be large, and proofs using cut

suffice as justifications for read. Moreover, logging cut-full proofsmay provide clues to auditors [57]. On the other hand, proofs with
cut may contain irrelevant detours that make it difficult to see whoto blame for unexpected consequences of a policy, whereas the
corresponding cut-free proof expresses the direct evidence used togrant access. Thus, it is important to be able to eliminate cuts from
log entries during auditing. Fortunately, Garg and Pfenning [23]give a Twelf proof of cut admissibility for their logic, and exploiting
open-endedness, we can import their Twelf code as a function inour language.

Let W stand for LF contexts of the form

x1:term S1, x2:term S2, . . . , p1:A1 hyp, p1:A2 hyp, . . .
for some Si and Aj (in Twelf, these contexts are described by aregular worlds declaration [45]). The key lemma in cut elimination

is cut admissibility, which is stated as follows:

8 * ` \Psi  2 W

\Psi  `LF A : prop
\Psi  `LF C : prop
\Psi  `LF D : |-cf A true
\Psi  `LF D0 : \Pi  :A hyp. |-cf C true :9
\Psi  `LF D00 : |-cf C true

We write |-cf for the cut-free version of |-, which is specifiedby all the rules for this judgement in Figure 5 except for

cut. Cut

admissibility proves that one can substitute cut-free evidence for Afor a hypothesis of

A and obtain a cut-free result.The proof of this theorem is a meta-function which can be used

to implement a negative value of the following type:h*i 8

W. 8A : prop.8C :

prop.8

D : |-cf A true.8
D0 : (\Pi  :A hyp. |-cf C true)."
(9D00 : |-cf C true.1)

Here we write 8W.A- for 8W(\Psi  7! \Psi  f A-); this type quantifiesover all contexts in the world W and then immediately binds the

context in A-. A value of this type is implemented as follows:

val-(\Psi ; unpack \Psi .A ; C ; D ; D0 ; ffl 7! (gp(\Psi , A, C , D, D0), ()) [*])

Inverting the possible destructors for this type yields exactly thepremises of the Twelf theorem. To construct a result, we use the
notation gp to call Garg and Pfenning's Twelf code to compute anLF term. Twelf is a logic programming language for programming
with LF terms, so their proof is not a function but a total relation,which may associate more than one output with each input. We can
resolve this non-determinism by simply choosing to return the firstresult produced by Twelf's proof search.

Discussion We hope to have suggested with the above examplethat our type theory has an appropriate type structure for embedding a security-typed language. However, the above security-typedlanguage is quite limited in several ways: it relies on a static collection of principals, resources, and policies; atomic propositionssuch as

mayrd can only refer to LF terms; it only allows executionon behalf of one principal (

self). We plan to consider embeddingmore-extensive security-typed languages in future work.

3.2 Logical relations for G"odel's T
Twelf's computational language for proving metatheorems aboutlanguages and logics represented in LF permits only 89-statements

over LF types. Moving to a higher-order functional programminglanguage like Delphin [48], Belgua [46], and our type theory has a
number of advantages. For example, when proving decidability ofa judgement J in Twelf, one must inductively axiomatize its negation ~J and prove non-contradiction (J ^ ~J ) ! 0 explicitly.With more quantifier complexity, one can define ~J as J !

0,so non-contradiction is implemented by function application, and

prove decidability (J . (J ! 0)).Additionally, because Twelf allows only 89-statements over LF
types, it is not possible to formalize a logical relations argumentby interpreting the types of an object language as the types of the
Twelf computational language.1 While Delphin and Beluga havesufficient quantifiers to interpret object-language types, they do not
permit the definition of a type by induction on an LF term, whichseems necessary to define a logical relation by induction on objectlanguage types. Because our type theory provides type-level com-putation, we can conduct such logical relations arguments directly,
using the quantifiers of our computational language. It is of coursepossible to formalize this style of argument in a dependent type
theory such as Coq or Agda which similarly provides large elimi-nations; the advantage of our approach is that the programmer can
carry out a logical relations argument while using LF to representthe language's binding structure.

1 It is possible to formalize logical relations arguments in Twelf by interpreting types as quantifiers in a specification logic encoded in LF [50], butthis requires independent verification of the consistency of the specification

logic, which is often tantamount to the theorem one is trying to prove.

9 2008/7/16

tp : type.
nat : tp.
arr : tp -> tp -> tp.

tm : tp -> type.
z : tm nat.
s : tm nat -> tm nat.
iter : tm nat -> tm C -> (tm C -> tm C) -> tm C.
lam : (tm A -> tm B) -> tm (arr A B).
app : tm (arr A B) -> tm A -> tm B.

eval : tm A -> tm A -> type.
eval/z : eval z z.
eval/s : eval (s E) (s E).
eval/lam : eval (lam E) (lam E).
eval/iterz : eval (iter E Ez Es) Ez'

<- eval E z
<- eval Ez Ez'.
eval/iters : eval (iter E Ez Es) Es'

<- eval E (s E')
<- eval (Es (iter E' Ez Es)) Es'.
eval/app : eval (app E1 E2) E'

<- eval E1 (lam E)
<- eval (E E2) E'.

Figure 6. LF Representation of G"odel's T
As an example, we show how type-level computation with LFterms can be used to type a logical relations argument for the termination of G"odel's T (simply-typed *-calculus with iteration overnatural numbers). For simplicity, we index terms with their types so
that only well-typed terms are representable, and we give a call-by-name evaluation relation on closed terms where successor is treated
lazily. Binders lam and iter are represented using higher-orderabstract syntax, and the evaluation relation uses LF application to
perform substitution.The ultimate theorem we would like to prove is:

h*i 8A:tp.8E:tm A.9E':tm A.9D:eval E E'.1
The logical relations proof of this theorem works by constructinga closed term model, interpreting the types of G"odel's T as the

types of the programming language. The logical relation is definedby induction on object-language types. In our calculus, this is
represented by a meta-function ht from LF terms to positive types:

(* `LF A : tp and * `LF E : tm A -! h*i ht(A, E) type)
ht nat E = 9 : htnat E.1
ht (arr A1 A2) E = 9((* u.E'):\Pi  :tm A1. tm A2).9

D:eval E (lam (*u.E')).
(8E1:tm A1.ht(A1, E1) ! "ht(A2, [E1/u]E')

Here we use one-level pattern-matching and inductive calls to no-tate the meta-function

ht, which maps every G"odel's T type andclosed term to a positive type. The case for

arr says that E evalu-ates to a lambda, and moreover, for every hereditarily terminating

argument, the substitution into the body of the lambda is hereditar-ily terminating. We write

[E1/u]E2 for LF substitution, which isdefined as a meta-function on LF terms. The base case refers to an

auxiliary relation htnat which is defined as follows:
htnat : tm nat -> type.
htnat/z : htnat E

<- eval E z.
htnat/s : htnat E

<- eval E (s E')
<- htnat E'.

The fundamental lemma of logical relations states that all well-typed terms are in the relation. One difficultly is that the relation

is defined only for closed terms, but for the sake of the proof, the

theorem must be generalized to consider open terms. The standardmaneuver is to interpret open terms under a grounding substitution
of hereditarily terminating terms. To do this, we need a type repre-senting substitutions, which we may define in LF as follows:

tplist : type.
tnil : tplist.
tcons : tp -> tplist -> tplist.

subst : tplist -> type.
snil : subst tnil.
scons : tm A -> subst As -> subst (tcons A As).

The type tplist codes an LF context (u : tm, d : of u A, . . .) bythe list (

tcons A . . . tnil). The indexed list (subst As) con-tains one

tm of type A for each A in As.We also need a type expressing that a substitution contains

hereditarily terminating terms:

(* `LF As : tplist and * `LF Es : subst As -! h*i hts(As, Es) type)
hts tnil snil = 1
hts (tcons A A2) (scons E Es) = ht(A, E) \Omega  hts(As, Es)

Then the fundamental lemma is stated as follows, where W containLF contexts (

u : tm, d : of u A, . . .).h*i 8

W(\Psi  7! \Psi  f 8A : tp.8E : tm A.\Pi (8

Es : subst(tps\Psi ).hts(Es, (tps\Psi )) ! "ht(A, E [Es]))))

For any \Psi  in W, given an E of type A in \Psi , along with a closedhereditarily terminating substitution

Es for each of the free vari-ables of
E, we produce a proof that the simultaneous substitution
E [Es] is hereditarily terminating. The type \Pi  is used to expressthe fact that the substitution consists of closed terms. The metaoperation tps\Psi , codes a context \Psi  as a tplist; it is defined byinduction on

\Psi . The meta-function E [Es] implements simulta-neous substitution for LF terms. This meta-function need not be

implemented directly for this instance: it can be derived from ageneric simultaneous substitution theorem for LF.

We implement this type by induction on E, using standard lem-mas (closure under head expansion, and an inductive lemma showing that the iterator is in the relation). The proof uses several exten-sional type equalities involving properties of simultaneous substitution. These equalities are true (e.g., they were proved by Harperand Pfenning [26] in the course of studying LF using logical relations), and because we treat equality extensionally, they are notreflected in the proof term. We plan to study a concrete language
for type equality proofs in future work.

4. Related Work
There has been a great deal of work on integrating various formsof dependent types into practical programming languages and their

implementations [3, 7, 9, 10, 11, 15, 19, 20, 37, 39, 42, 44, 52,53, 55, 59, 60, 61, 64], building on dependently typed proof assistants such as NuPRL [12] and Coq [6]. However, none of theselanguages provide built-in support for representing variable binding and hypothetical judgements, which are essential ingredientsof domain-specific logics.

In contrast, our language builds on a wide range of experiencerepresenting logical systems in LF [27] and computing with them
in Twelf [45], and thus is most closely related to the functionallanguages LF/ML [49], Delphin [48], and Beluga [46]. LF/ML allows run-time datatypes dependent on LF terms, which permits e.g.writing a type checker that returns an LF certificate that a program
is well-typed. However, LF/ML does not allow pattern-matchingcomputation with LF terms themselves, either at the type level or
at the value level. Relative to Delphin and Beluga, our contribu-tion is to provide an account of type-level computation with LF

10 2008/7/16

terms, and to investigate a different formalism for integrating openLF terms into a computational language. For example, in Delphin,
all types are interpreted relative to one ambient LF context, as inTwelf. With this type structure, it is unclear how one would express
functions that take different arguments in different contexts; e.g.,the type of the fundamental lemma in Section 3.2 uses our connective \Pi  to express a substitution containing only closed terms.On the other hand, in Beluga, every individual LF type is explicitly contextual--the inclusion of LF types into the computationallanguage is the contextual modality--and there is no notion of a
computational-language type in an LF context. Consequently, onemust write types with the LF contexts distributed to the leaves, i.e.,
(\Psi  ) A) \Phi  (\Psi  ) B) instead of \Psi  ) (A \Phi  B). Types of the lat-ter form can be more syntactically convenient (as in Delphin, a single context scopes over many LF types), but this is a minor differ-ence, as these two types are isomorphic in our language [34]. A
more significant difference is that our contextual modality h\Psi i A isdifferent than that of contextual modal type theory [40] and Beluga,
where contextual variables are eliminated by substitution. In previ-ous work, we studied a framework [34] that allows inference rules
with side conditions, expressed as computational functions, whichplace restrictions on the ambient contexts in which the rule may be
applied. The presence of such side conditions can invalidate struc-tural properties such as weakening and substitution, and thus the
type theory must not commit to these properties by building theminto the meaning of contextual types. Instead of eliminating contextual types by substitution, we allow pattern matching on contextualtypes, and view substitution as an admissible property, defined in
the meta-function language. Consequently, the type theory we havepresented in this paper is compatible with a future extension to a
framework integrating binding and computation.There are many techniques for representing variable binding
besides LF, ranging from concrete representation techniques [5]to other theories of binding, such as nominal logic [8, 47, 56];
our previous work includes a detailed comparison with these ap-proaches [34]. There have also been semantic studies of variable
binding, both for the nominal approach [21] and for the pronom-inal approach where variables are projections from a context (see
Fiore et al. [18] and Hofmann [28]).Polarized intuitionistic logic has the same basic type structure
(!,N,?,",\Omega ,1,\Phi ,0,#) as call-by-push-value [32], but the programsof our calculus are different than those of CBPV, which are not fully
focalized. Though our type theory exhibits the usual asymmetriesof intuitionistic logic, the treatment of positive types via constructors and negative types via destructors was inspired by the dualitybetween proofs and refutations in computational interpretations of
classical logic (see, for example, Curien and Herbelin [14], Filinski[17], Selinger [51], Zeilberger [62]).

5. Conclusion
In this paper, we have generalized our previous work on comput-ing with binding to a simple form of dependent data, yielding a

language for programming with domain-specific logics. However,there are still many interesting avenues for future work:

Computation in Representation We have chosen to take LF "offthe shelf" in this paper, and thus our type theory does not account
for embedding computation in data (e.g., a datatype with a compu-tational function as a component). We plan to lift this restriction in
two stages: First, we can consider allowing run-time datatypes thatmix binding and computation, while still restricting dependency to
purely positive types (those with no shifts), which restricts depen-dency to LF-like data. More ambitiously, we may consider fullspectrum dependency on negative types as well. Full-spectrum de-pendency is more difficult because it imposes constraints on runtime features such as effects, but it would allow a fully integratedtreatment of dependent binding and computation.
Meta-functions In this paper, we have demonstrated that our lan-guage has a suitable type structure for programming with domainspecific logics, but the examples are necessarily abstract, as wehave not formally defined a finitary syntax for meta-functions
o/, , OE. We are now free to consider different implementationsof meta-functions without disturbing the meta-theoretic properties
of our language. For example, a simple language of meta-functionscould consist of two ingredients: First, we would define a syntax
of meta-patterns, extending the grammar for constructor patterns
c with meta-variables ranging over patterns. A meta-function canthen be specified by a finite list of meta-pattern/expression pairs,

where the expression is allowed to use meta-variables bound bythe pattern to construct values. Type checking these meta-functions
will require determining exhaustiveness of patterns (Dunfield andPientka [16] describe some recent work addressing this problem).
Second, we would give a fixed collection of datatype-generic pro-grams witnessing the structural properties of LF (weakening, exchange, contraction, substitution, subordination-based strengthen-ing). This language of meta-functions would allow pattern matching up to a finite depth, which is sufficient for the value level,because we have general recursion in the language. For expressive
type-level computation, we may also include recursively definedmeta-functions with named auxiliary functions.

Effects, Polymorphism, and Modules In scaling the calculus pre-sented here to a full-scale programming language, we intend to investigate whether polarity and focusing offer any new insights onfeatures such as effects, polymorphism, and modularity. In particular, we plan to consider indexing the shift types "A+ and #A- tomore precisely track what effects are permitted--e.g., distinguishing #impure A-, at which general recursion is allowed, from #pure A-,which classifies total programs. We may be able to permit programmers to reason about effectful code using domain-specific logics(e.g., coding up Ynot's separation logic [39] as a library) by indexing shifts with propositions defined in a DSL.

Acknowledgements
We thank Noam Zeilberger, Karl Crary, and Rob Simmons fordiscussions about this work.

References

[1] T. Altenkirch, C. McBride, and W. Swierstra. Observational equality,now! In Programming Languages meets Program Verification Workshop, 2007.
[2] J.-M. Andreoli. Logic programming with focusing proofs in linearlogic. Journal of Logic and Computation, 2(3):297-347, 1992.

[3] L. Augustsson. Cayenne - a language with dependent types. InInternational Conference on Functional Programming, 1998.
[4] K. Avijit and R. Harper. A language for access control. TechnicalReport CMU-CS-07-140, Carnegie Mellon University, Computer Science Department, 2007.
[5] B. Aydemir, A. Chargu'eraud, B. C. Pierce, R. Pollack, and S. Weirich.Engineering formal metatheory. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 3-15, 2008.
[6] Y. Bertot and P. Cast'eran. Interactive Theorem Proving and Pro-gram Development: Coq'Art: The Calculus of Inductive Constructions. Texts in Theoretical Computer Science. Springer, 2004.
[7] C. Chen and H. Xi. Combining programming with theorem proving.In International Conference on Functional Programming, 2005.

[8] J. Cheney. Simple nominal type theory. In International Workshopon Logical Frameworks and Meta-Languages: Theory and Practice,

2008.[9] J. Cheney and R. Hinze. Phantom types. Technical Report CUCIS

TR20003-1901, Cornell University, 2003.
[10] B. Chin, S. Markstrum, and T. Millstein. Semantic type qualifiers. InProgramming Language Design and Implementation, 2005.

11 2008/7/16

[11] J. Condit, M. Harren, Z. Anderson, D. Gay, and G. C. Necula. Depen-dent types for low-level programming. In European Symposium on

Programming, 2007.
[12] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F.Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler,

P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing Mathemat-ics with the NuPRL Proof Development System. Prentice Hall, 1986.

[13] Coq Development Team. The Coq Proof Assistant Reference Manual.INRIA, 2007. Available from

http://coq.inria.fr/.

[14] P.-L. Curien and H. Herbelin. The duality of computation. InACM SIGPLAN International Conference on Functional Programming, pages 233-243, 2000.
[15] J. Dunfield and F. Pfenning. Tridirectional typechecking. In ACMSIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2004.
[16] J. Dunfield and B. Pientka. Case analysis on higher-orderdata. Draft:

http://www.cs.mcgill.ca/~complogic/beluga/,February 2008.

[17] A. Filinski. Declarative continuations and categorical duality. Mas-ter's thesis, University of Copenhagen, 1989. Computer Science Department.
[18] M. Fiore, G. Plotkin, and D. Turi. Abstract syntax and variablebinding. In IEEE Symposium on Logic in Computer Science, 1999.

[19] C. Flanagan. Hybrid type checking. In ACM SIGPLAN-SIGACTSymposium on Principles of Programming Languages, pages 245-

256, 2006.[20] S. Fogarty, E. Pasalic, J. Siek, and W. Taha. Concoqtion: indexed

types now! In ACM SIGPLAN symposium on Partial evaluation andsemantics-based program manipulation, pages 112-121, New York,
NY, USA, 2007. ACM Press. ISBN 978-1-59593-620-2.[21] M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax

involving binders. In IEEE Symposium on Logic in Computer Science,pages 214-224. IEEE Press, 1999.
[22] I. Galois. Cryptol reference manual, 2002.
[23] D. Garg and F. Pfenning. Non-interference in constructive authoriza-tion logic. In Proceedings of the 19th IEEE Computer Security Foundations Workshop (CSFW 19), 2006.
[24] J.-Y. Girard. Locus solum: From the rules of logic to the logic of rules.Mathematical Structures in Computer Science, 11(3):301-506, 2001.

[25] J.-Y. Girard. On the unity of logic. Annals of pure and applied logic,59(3):201-217, 1993.
[26] R. Harper and F. Pfenning. On equivalence and canonical forms inthe LF type theory. ACM Transactions on Computational Logic, 6:

61-101, 2005.[27] R. Harper, F. Honsell, and G. Plotkin. A framework for defining logics.

Journal of the Association for Computing Machinery, 40(1), 1993.
[28] M. Hofmann. Semantical analysis of higher-order abstract syntax. InIEEE Symposium on Logic in Computer Science, 1999.

[29] D. J. Howe. On computational open-endedness in Martin-L"of's typetheory. In IEEE Symposium on Logic in Computer Science, pages

162-172. IEEE Computer Society, 1991.
[30] L. Jia, J. A. Vaughan, K. Mazurak, J. Zhao, L. Zarko, J. Schorr, ,and S. Zdancewic. Aura: A programming language for authorization

and audit. In ACM SIGPLAN International Conference on FunctionalProgramming, 2008.

[31] O. Laurent. Etude de la polarisation en logique. Th`ese de doctorat,Universit'e Aix-Marseille II, Mar. 2002.
[32] P. B. Levy. Call-by-push-value. PhD thesis, Queen Mary, Universityof London, 2001.
[33] C. Liang and D. Miller. Focusing and polarization in intuitionisticlogic. In J. Duparc and T. A. Henzinger, editors, CSL 2007: Computer Science Logic, volume 4646 of LNCS, pages 451-465. Springer-Verlag, 2007.

[34] D. R. Licata, N. Zeilberger, and R. Harper. Focusing on binding andcomputation. In IEEE Symposium on Logic in Computer Science,

2008.[35] W. Lovas and F. Pfenning. A bidirectional refinement type system for

LF. Electronic Notes in Theoretical Computer Science, 196:113-128,2008.
[36] P. Martin-L"of. Hauptsatz for the intuitionistic theory of iterated in-ductive definitions. In J. E. Fenstad, editor, Proceedings of the Second

Scandinavian Logic Symposium, pages 179-216, Amsterdam, 1971.North Holland.

[37] C. McBride and J. McKinna. The view from the left. Journal ofFunctional Programming, 15(1), 2004.
[38] D. Miller and A. F. Tiu. A proof theory for generic judgments: Anextended abstract. In IEEE Symposium on Logic in Computer Science,

pages 118-127, 2003.
[39] A. Nanevski, G. Morrisett, and L. Birkedal. Polymorphism and sep-aration in Hoare Type Theory. In ACM SIGPLAN International Conference on Functional Programming, pages 62-73, Portland, Oregon,2006.

[40] A. Nanevski, F. Pfenning, and B. Pientka. Contextual modal typetheory. Transactions on Computational Logic, 2007. To appear.
[41] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal.Ynot: Reasoning with the awkward squad. In ACM SIGPLAN International Conference on Functional Programming, 2008.
[42] U. Norell. Towards a practical programming language based on de-pendent type theory. PhD thesis, Chalmers University of Technology,

2007.[43] N. Oury and W. Swierstra. The power of pi. In ACM SIGPLAN

International Conference on Functional Programming, 2008.
[44] S. Peyton Jones, D. Vytiniotis, S. Weirich, and G. Washburn. Sim-ple unification-based type inference for GADTs. In ACM SIGPLAN

International Conference on Functional Programming, 2006.
[45] F. Pfenning and C. Sch"urmann. System description: Twelf - a meta-logical framework for deductive systems. In H. Ganzinger, editor,

International Conference on Automated Deduction, pages 202-206,1999.

[46] B. Pientka. A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions. In ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, pages371-382, 2008.

[47] A. M. Pitts. Nominal logic, a first order theory of names and binding.Information and Computation, 186:165-193, 2003.
[48] A. Poswolsky and C. Sch"urmann. Practical programming with higher-order encodings and dependent types. In European Symposium on

Programming, 2008.
[49] S. Sarkar. A cost-effective foundational certified code system. ThesisProposal, Carenegie Mellon University, 2005.

[50] J. Sarnat and C. Sch"urmann. Structural logical relations. In IEEESymposium on Logic in Computer Science, 2008.
[51] P. Selinger. Control categories and duality: on the categorical seman-tics of the lambda-mu calculus. Mathematical Structures in Computer

Science, 11(2):207-260, 2001.
[52] Z. Shao, V. Trifonov, B. Saha, and N. Papaspyrou. A type system forcertified binaries. ACM Transactions on Programming Languages and

Systems, 27(1):1-45, 2005.
[53] T. Sheard. Languages of the future. In Conference on Object-OrientedProgramming, Systems, Languages, and Applications, 2004.

[54] M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Program-ming with binders made simple. In ACM SIGPLAN International Conference on Functional Programming, pages 263-274, August 2003.
[55] M. Sozeau. PROGRAM-ing finger trees in Coq. In ACM SIGPLANInternational Conference on Functional Programming. Association

for Computing Machinery, 2007.
[56] C. Urban. Nominal techniques in Isabelle/HOL. Journal of AutomaticReasoning, 2008. To appear.

[57] J. A. Vaughan, L. Jia, K. Mazurak, and S. Zdancewic. Evidence-basedaudit. In Proceedings of the 21st IEEE Computer Security Foundations

Symposium, Pittsburgh, PA, USA, June 2008.
[58] K. Watkins, I. Cervesato, F. Pfenning, and D. Walker. A concurrentlogical framework I: Judgments and properties. Technical Report

CMU-CS-02-101, Department of Computer Science, Carnegie MellonUniversity, 2002. Revised May 2003.

[59] E. Westbrook, A. Stump, and I. Wehrman. A language-based approachto functionally correct imperative programming. In International

Conference on Functional Programming, 2005.
[60] H. Xi and F. Pfenning. Eliminating array bound checking throughdependent types. In Conference on Programming Language Design

and Implementation, 1998.
[61] H. Xi, C. Chen, and G. Chen. Guarded recursive datatype construc-tors. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2003.
[62] N. Zeilberger. On the unity of duality. Annals of Pure and AppliedLogic, 153(1-3), 2008. Special issue on "Classical Logic and Computation".[63] N. Zeilberger. Focusing and higher-order abstract syntax. In ACM

SIGPLAN-SIGACT Symposium on Principles of Programming Lan-guages, pages 359-369, 2008.
[64] C. Zenger. Indizierte Typen. PhD thesis, Universit at Karlsruhe, 1998.

12 2008/7/16