

The  Generation  of  Optimal  Code  for 
Arithmetic  Expressions 

RAVI  SETHI*  AND  J.  D.  ULLMAN* 
Bell  Telephone Laboratories, Inc., Murray Hill, New Jersey 
ABSTRACT.  The problem of evaluating arithmetic expressions on a machine with N  >  1 general 

purpose  registers  is  considered.  It  is  initially  assumed  that  no  algebraic  laws  apply  to  the operators and operands in the expression. An algorithm for evaluation of expressions under this 

assumption is proposed, and it is shown to take  the  shortest  possible number of instructions. It is then assumed that  certain operators are commutative or both commutative and associa- 
tive.  In this  case a  procedure is given for finding  an expression equivalent to a given one and having the shortest  possible evaluation sequence.  It  is  then  shown  that  the  algorithms  pre- 
sented here also minimize the number of storage references in the evaluation.  ' 

KEY  WORDS  AND  PHRASES:  arithmetic expressions, associativity, code  generation,  commuta- tivity,  compilers,  object-code optimization,  register  assignment,  trees 

CR CATEGORIES: 4.12, 5.24,  5.32 \ 

1.  Introduction 
N a k a t a   [1]  and  Meyers  [2]  consider  the  problem  of  minimizing  the  nu m b er   of gen- 
eral  registers  required  to  evaluate  an  arithmetic  expression.  When  only  commuta- 
tive  operators  like  +  and  *  are  considered,  Redziejowski  [3] shows  that   N ak a t a ' s  

algorithm  does  give  the  minimum  number  of registers. 

We  consider  the  somewhat  more  general  problem  of  minimizing  the  number  of 
program  steps  and/or  the  num ber  of  storage  references  in  the  evaluation  of  an  ex- 
pression,  given  a  fixed  number  of  general  registers.  The  algorithms  we  present  ex- 

ploit  the  commutative  and  associative  properties  of operators,  and  are  at  the  same 

time able to cope with noncommutative operators. We assume throughout  this paper 
that   there  are  no nontrivial  relations between  operators  and  elements.  For example, 
we  assume  t hat   all  elements  are  distinct,  and  th at   laws  such  as  a  *  b  +  a  *  c 

=  a  *  (b ~  c)  are  not  applicable.  Under  the  above  assumption,  the  algorithms pre- 
sented  generate  optimal sequences  of evaluation. 

In practice,  the  associative and  commutative  laws need  not  and  in most cases do 
not  hold,  as machines  carry information  of finite  precision.  I t  is conceivable that   the 
order  in  which  the  operators  and  elements  are  specified  leads  to  clever  use  of  the 
available facilities.  In  such  cases, reordering  the  computation  may  lead  to  overflows 
or  underflows.  However,  most  computations  are  not  critically  dependent  on  the 
order  of evaluation--especially  as compilers are  fairly  arbitrary in producing  execu- 
table  code.  In  these  cases,  an  optimal  sequence  of  evaluation  can  be  arrived  at  by 
permuting the specified order of operations, without  adversely affecting the  accuracy 

of the  result. 

In  showing  t hat  the  sequence  generated  is optimal under  the  assumed  conditions, 
we  show  that  the  algorithms  minimize,  independently,  the  number  of  "clear  and 

*  Present  address:  Department  of  Electrical  Engineering,  Princeton  University,  Princeton, 
N.J. 

Journal  of the Association  for Computing Machinery, Vol.  17,  No.  4,  October  1970, pp.  715-728. 

716  R.  SETHI  AND  J.  D.  ULLMAN 

adds" into registers and the number of "stores." The number of binary operations 
cannot be reduced, as the associative and commutative transformations do not change the number of operators in an expression. Later we show that minimizing the num- 

ber  of program  steps  also  minimizes the  number  of storage  references. 

In  Section 6  we  briefly consider the  timing requirements  of the  algorithms. We 
indicate,  without  proof,  that  the  time  taken  is  proportional  to  n,  the  number  of 
nodes in the  tree for the expression. The  algorithms are  designed for  a  machine  with  unlimited storage  and  N  >  1 

general registers. The  commands permitted are of the  following kinds: 

1.  C (storage)  --~ C (register) 
2.  C (register)  ~  C (storage) 
3.  OP[C (register),C (storage)]  ~  C (register) 
4.  OP[C (register),C (register)]  --~ C (register) Commands of types 1 and 2 transfer the contents of a storage location to the con- 

teats  of a  register,  and vice versa.  This  makes them  the  equivalents of the  CLear and Add  (CLA) and STOre  (STO)  commands respectively. Type 3 commands per- 
form an operation on two operands, the first in a register and the second in storage. 
It  is important to note that  commands of the type 

OP[C (storage),C (register)]  ~  C (register) 
are  not permitted.  This restriction is in keeping with the  instruction sets  of many 
present-day  machines.  For  example,  in  a  divide  operation,  the  dividend  is  con- 
strained to be in a register. Permitting commands  of this type would have the same 

effect as making all operators commutative. Commands of type 4 apply an operator 
to  the  contents of two  registers,  leaving the  result  in  a  third  (not necessarily dis- 

tinct)  register. 

An  expression  is  a  sequence  of binary  operations  on  arguments.  Arguments are either 

initial  (defined externally)  or  intermediate  (defined  by  operations  on  other 
arguments)  values.  Such  expressions  may  be  represented  by  binary  trees.  Initial 
values  correspond  to  leaves and  intermediate  values  to  interior  nodes  of the  tree. 

Every interior node represents a binary operation on  the elements corresponding to its descendants. The value associated with a  node can only be computed by apply- 

ing the corresponding operator to the values of its two descendant subtrees taken in 

the proper order. Due to commands of type 3, the order in which the descendants axe 
taken is important. Left descendants will be taken to  correspond to the first operand and right descendants to the second operand in all commands.  Two nodes in a tree 

are twins if they have the  same ancestor. 

A  program  is a sequence of operations which evaluate an expression when given the 
initial values in specified storage locations. The program terminates with the value of 
the entire expression in a  register. The  cost of a  computation  is the number of pro- 

gram  steps required  for the  computation on the  machine described. Adopting an idea of Nakata  [1], and Meyers [2], 1 we shall 

label each node with a 
number that  turns out to  be the  minimal number of registers required  to evaluate 

the  node  without  stores.  Given  a  tree,  the  algorithm  defined later  in  this  paper suitably labels it  and  uses these labels  to  define a  minimal sequence  of operations 

for the  machine described. In  the  first  part  of this  paper,  all  operations  are  taken  to  be  noncommutative. 

This  restriction  is  later  relaxed  to  allow  associative  and  commutative operations. 
1 Our  labels differ from  these  in  order  to  handle  noncommutat ivity  correctly. 

Journal of the Association for Computing Machinery,  Vol. 17, No. 4, October  1970 

The  Generation  of  Optimal  Code  for  Arithmetic  Expressions  717 
2.  The  Basic  Algorithm 
To  each   no de  ~ is  assigned  a  label  L  (v),  f ro m  t he   b o tt o m   up.  I t  should  be  n o te d  t h at  

for  th e  t i me   be ing  all  op erators   are  a s s u m ed   n o n co m m u ta t iv e :  

L1.  I f  n  is  a  leaf  and  the  left  d es ce n d an t   of  its  ancestor,  t h en   L  (~)  =  1;  if  v  is 
the  right  d e s c e n d an t   t h en   L  (y)  =  0; 

L2.  I f  ~  has  d e s c e n d an t s   w i t h   labels  l~  and  /~,  t h e n   for  l~  ~  /2,  L ( ~ )   = 
m a x   (11,/~),  and  for  11  =  /2,  L ( v )   =  ll  -t-  1. 

W e   n o w   give  an  al go r ith m   for  t he   ev a lu a t io n   of  ar i t h me t ic   expressions  using  at 
mo s t  N  registers.  T h i s   al g o r i th m   is,  in  fact,  the  "o b v i o u s "   to p - d o w n   algorithm. 
Significantly,  we  p r o v e  its  o p t im a li t y   u n d er   the  as s u mp ti on s   p r ev io u s l y  men - 

tioned. 

A LGO RITH M  1 
After  generating  the  tree  and  labeling  the  nodes: (1)  Apply  (2)  to the  root  with  registers  bl,  b2,  -..,  bN available.  Routine  (2)  will evaluate  the 

expression represented  by the subtree  extending from the node  to  which  it  is  applied.  The result  will appear  in  the  lowest  numbered  register  available. 

(2)  Let  ~ be  a  node,  L(~)  =  l  and  l  >  0.  Suppose  registers  b,~,  b~+l,  -.-  ,  b;v are  available, l_~  m . ~   N. 
We  first  treat  the  case  l  =  1. 

(A)  If n  is  a  leaf  it  must  be  a  left  descendant.  Enter  the  value  of 7,  which  is  an  initial  value, into  bm. 

(B)  If ~ is not  a  leaf its  right  descendant  must  be a  leaf, else ~'s label  would be  at  least  2.  Ap- ply  (2)  to  its  left  descendant  with  registers  bm,  b,n+l  ,  -.-  , b~  available.  The  result  will 

appear  in  b,n. We then  evaluate  ~ in  one  step.  The  value  of  the  left  descendant  is  in  bm, the  right  in  storage.  Return  the  value  in  bm . 

Now  suppose  l  >  1.  Let  the  descendants  of  ~ have  labels  11,  l:  . 

(C)  If  Ii , 12 _> N  apply  (2)  to  the right  descendant  with  registers  b,~ , b,~+~ ,  . * *  , b~ available. Store  the  value  of  the  right  descendant.  Apply  (2)  to  the  left  descendant  with  registers 

b,~,  b,,+~,  .--  ,  b~  available,  leaving  the  result  in  b~.  Evaluate  ~ using  the  value  in  b,~ and  the value of the  right  descendant  in storage.  Leave the  result  in b~. 

(D)  If  II  ~  /~,  and  at  least  one  of  ll,  12 is  less  than  N,  apply  (2)  to  the  descendant  with  the higher  label,  with  registers  bm,  b,,+~,  ...  ,  bN  available.  Leave  the  result  in  bm.  Apply 

(2)  to  the  other  descendant  with  registers  b,,+l  , bm+2 ,  ...  , b~ available.  The  result  will appear  in  bm+~ . Evaluate  ~ using  the  values  in  b,~ and  bm+~,  and  leave  the  result  in  b,,  . 
Exception:  If  the  smaller  label  is  0,  do  not  apply  (2),  but  rather  evaluate  ~  using  the value  in  b,~ and  the  value  of ~'s right  descendant,  which  must  be  a  leaf, in storage. 

(E)  If  l~  =  l~  <  N,  treat  the left descendant  as  the  node  with  the  higher  label  and  proceed  as above. 

E xa m p le   1.  C o ns i d er   the  expression  a /( b   +  c)  -  d . ( e   +  f ),   whose  tree  is: 

1  2 

b  c  e  f 
Journal of the Association for Computing Machinery, Vol. 17, No. 4, October 1970 

718  R.  SETHI  AND  J.  D.  ULLMAN 

The  integers  at  each  node  are  the  labels  assigned  by  the  labeling  algorithm. 
Algorithm  1  produces  the  following  code,  if  N  =  2. 1.  d--~  regl 

2.  e--,  reg2 
3.  reg2  +  f  ~  reg2 4.  regl,reg2  --~ regl 

5.  regl  ~  T 
6.  a--~  regl 7.  b --~ reg2 

8.  reg2  +  c ~  reg2 
9.  regl/reg2  ~  regl 

10.  regl  --  T - ~ r e g l  
In  the  above  computation instructions  1, 2, 6, and 7  are  CLA's. Instruction 5 is a 
store.  The  rest  are binary arithmetic operations.  It is possible to  evaluate the  given expression  using only 8 instructions if * is assumed  commutative. Example  2  shows 

this. Several papers  have  dealt with the  compilation of code for arithmetic expressions 

and  Algorithm  1  can  be  considered  a  generalization  of  some  of  those  ideas.  Floyd [4]  suggested that  the  right  argument  of a  noncommutative operation be  computed 
first.  Anderson  [5]  gives  an  algorithm  which  starts  with  an  expression,  constructs 

a binary tree,  and then produces code for a  machine with one register.  Given such a machine, the  code produced by the  algorithm in this paper is essentially the same as 

the  tree  code  in  [5]. Nakata  [1]  and  Meyers  [2]  have  essentially similar results.  As  mentioned in Sec- 

tion 1, the algorithms in this paper are generalizations of these. In  [2] a cost criterion 
is defined to be distributive with respect to a given computer if  and only if each program 

for  that  computer  which  evaluates  an  expression  in  an  optimal  way  (according to 
the  criterion)  also  evaluates  all  subexpressions  of  that  expression  in  optimal  ways 

(according to  the  same  criterion).  The  cost  of computation  defined in Section  1 is distributive  with respect  to  our  machine. When  more  than  one register is involved, 

distributivity is  not  obvious,  because  different numbers  of registers  may be  avail- 
able  to  different  nodes.  The  following  sequence  of  lemmas,  in  effect,  proves  the 
distributivity. We now show that Algorithm 1 produces a  minimal cost program when all opera- 

tors  are  noncommutative. LEMMA 1. 

Let Algorithm  1 be started with N  registers  available. Let r  be the number 
of  registers  available  when  routine  (2)  of  Algorithm  1  is  applied  to  a  node  7.  Then: 
r  =  N i f L ( ~ )   >  N ; N   >  r  >  L ( ~ ) i f L ( ~ )   <  N. PROOF.  We  shall prove  this lemma by  induction on  the  number  of applications 

of  routine  (2).  The  first  time  routine  (2)  is  applied,  it  is  for  the  root  and  all  N 
registers  are  available. Let the lemma hold for the  first ]c calls, and let the  (k  +  1 )-th  call be  for node vl 

with r  registers available. Let ~l's twin node be v~ and its ancestor 7.  Let their labels 
be  11,  /~  and  l  respectively. Case 1.  ll >_ N.  Since ll >_ N, we have I >  N. As the lemma holds for the appli- 

cation  of routine  (2)  to  7,  N  registers  were  available  then.  From  (2C),  if 12 ~_  N, 
then  when  routine  (2)  is  applied  to  ~1,  N  registers  are  available  and  the  lemma holds.  If  l:  <  N,  then  N  registers  are  available  for ~1,  by  (2D). 

Case  2.  l~  <  12 and  ll <  N.  Then from  the  labeling  rules,  l~ =  1 and  l, <  1. The 

Journal of the Association  for Computing Machinery, VoL 17, No. 4, October 1970 

The  Generation  of Optimal  Code for  Arithmetic  Expressions  719 
call for  v2 was  before  the  (k  +  1)-th  and  r  registers  were  available,  r  >  /~  =  l. 
By  (2D),  the  (k  W  1)-th  call  occurs  with  r  --  1  registers.  Since  lI  <  I  _<  r,  we 
have  ll  _<  r  --  1,  and  the  lemma  holds. 

Case 3.  /2  <  ll  ~  N.  Then  l~  =  1. The  call for v occurred  before the  (k  W  1)-th 
call.  Therefore  r  ~_  L (7)  =  l.  By  (2B)  or  (2D),  the  (k  +  1 )-th  call  occurs  with  r 
registers  and  the  l em ma  holds. 

Case 4.  ll  =  /~  ~  N.  In  this  case,  from the  labeling rules  11  =  12 =  l  --  1. Since 
routine  (2)  was called  for ~ before it was called for v~,  r  ~  l registers were available. 
By  (2E),  routine  (2)  is called  for ~1 with  r  or r  -  1 registers  depending  on whether 
v~ is the  left  or the  right  descendant  of 77 respectively. Since  r  >  l, we have r  -  1  ~_ 

l  --  1,  and  the  l emm a  holds. 

LEMMA 2.  Al~7orithm  1 evaluates  a  tree with no  stores when  as many  registers as  the 
label  of the root  are  available. 

PROOF.  Each  interior  node  represents  an  operation.  To  evaluate  a  node,  the 
algorithm  evaluates  both  its  descendants,  then  apphes  the  operator.  Since this  is 
true  for all interior  nodes in the  tree, Algorithm  1 correctly evaluates the  expression. 
With  L e m m a   1, a  simple induction  on max im um path length  of a  tree  shows that  no 
stores  occur. 

LEMMA 3.  For trees with root labels up  to 2,  the  label  of the root is a  lower bound  on 
the  mi nimum  number  of registers  required  to  evaluate  the  tree  without  any  stores, 

PROOF.  Let I be the label of the  root. Then  from the  labeling rules l is the  highest 
label  in  the  tree.  The  lemma  is  trivial  for  l  =  1. 

Consider  a  tree  in  which  only  the  root  has  a  label  2: 

For  this  tree,  at  least  two  registers  are  required.  This  is  because  no  matter  how 
evaluation  proceeds,  even  if  T~ is  a  leaf,  its  value  must  be  in  a  register  when  the  * 

operation  is  performed.  Since  T~ is  not  a  leaf,  but  the  result  of  a  computation,  its 
value  can  only  appear in  a  register,  as  no  stores  occur.  Therefore  at  least  two  regis- 
ters  are  required. 

Any  other  ease  of a  tree  with  a  root  labeled  2  must  contain  a  subtree  of the  type 
just  considered,  proving  the  lemma. 

LEMMA 4.  The  label  of a node is a  lower bound  on the minimum  number  of registers 
required  to  evaluate  the  node  without  any  stores. 2 

PROOF.  From  L e m m a  3  this  lemma holds  for  all labels  up  to  and  including  2. 

Let  T  be  a  smallest  tree  for  which  a  violation  of  the  hypothesis  occurs, t h e n  T 
can  be  represented  by  

T 

s This   result  was  proven  in  [3]  using a  similar  but  not  identical  labeling s cheme  and  a  different 
compu te r  model.  Our  proof  is more  concise  and   carries  over  to  the  model  of  [3]. 

Journal of the Association  for Computing Machinery,  Vol. 17, No. 4, October  1970 

720  R.  SETHI  AND  J.  D.  ULLMAN 
where  the  l's are  labels.  There  are  three  possibilities  for ll and/2. 

1  l  (l 
2  (l  1 
3  l--1  l--1 

For  case  1 (2)  the  lemma  holds,  otherwise  the  left  (right)  descendant  will  be  a 
smaller violating  tree. 

For  case  3,  when  the  first  command  is executed,  the  value  brought  into  a  register 
is  either  for  tree  T1  or  for  tree  T2.  Since  we  have  assumed  that  there  are  no  non- 

trivial  relations  among  operators  and  elements,  the  contents  of  a  register  at  any 
time  can  be  identified  with  a  partial  value  in  at  most  one  of  the  subtrees,  unless 
it  is the  value  of the  entire  tree.  If the  initial  register used is for tree  T1,  there  must 
be at least one register used for a  partial value  of tree  T1 until  the  final computation. 
Thus tree  T~ is evaluated using at most l  --  2 registers, providing a  contradiction.  An 
analogous  argument  holds  if the  first  register  used  is  for tree  T2. 

THEOREM  1.  I f   we  assume  no nontrivial  relations  between  operators  and  elements, 
Algorithm  1  uses  the  minimum  number  of registers for  the  evaluation,  with  no  stores, 
of an expression. 

PROOF,  Immediate  from  Lem mas  2  and  4. 
Definitions.  Given  a  number  of  registers  N,  we  say  a  node  is  tact]or  if  both  its 
descendants  have  labels  at  least  as  great  as N.  We  say  a  node  is minor  if it  is  a  leaf 

and  the  left  descendant  of  its  ancestor. 

LEMMA 5.  The  minimum  number  of stores  used  in  the  evaluation  of  an  arithmetic 
expression  with  no  nontrivial  relations  among  operators  and  elements  is  equal  to  or 
greater  than  the number  of major  nodes  in  the  tree for  that expression. 

PlVOOF.  We  shall  prove  this  lemm a  by  induction  on  the  num ber  of  nodes.  For 
the  smallest  nontrivial  tree, 

the  lemma is true  as  there  are  no  major nodes,  and  no  stores  are  required. 

Suppose  N  registers  are  available.  Let  the  lemma  hold  for  trees  of  up  to  k  -  1 
nodes.  The  label  of  a  major  node  must  be  at  least  N  -t-  1.  If  the  major  node  could 
be  evaluated  without  any  stores,  then  a  contradiction  of  L e m m a   4  would  occur. 
Therefore, there  must  be at least  one store in  a  program that  evaluates  a  tree  with 

a  major  node. 

Consider  a  minimum  store program P  for a  tree  T  with/c  nodes  and  M  >  I  major 
nodes.  When  the  first store  occurs  (and we have just  shown  that  there  must  be one) 
the  value  of a  subtree  S  of  T  is stored  in  a  temporary.  Replace  S  by  a  leaf to  form a 
new  tree  T p. Revise  P  to  evaluate  T t,  by  deleting  those  instructions  whieh  were  a 

part  of  the  computation  of  S  and  treating  the  t emporary  as  the  value  of  the  new 
leaf.  Call  the  new  program  PP. 

Without  loss  of  generality,  we  can  assume  that  at  least  one  operation  was  per- 
formed  before  the  store  occurred.  T h a t   is,  given  any  program  that  causes  a  store 

Journal of the Association for Computing Machinery, Vol. 17, No. 4, October 1970 

The  Generation  of Optimal  Code for  Arithmetic  Expressions  72 t 
before  any  operation  is  performed,  there  exists  a  program  that  performs  t h e  same 

computation with fewer stores. Thus,  T ~ has fewer than  k nodes,  and the number  of 
stores  required  for  T t  is  equal  to  or  greater  than  the  number  of  its  major nodes. 
P  evidently has  one store more  than  P~. 

We will now show that  the  number  of major nodes  of T' is at  least M  --  1. In  T, 
consider  the  first  major  node  ~  preceding  S.  (If  there  is  none,  we  are  done  as  no 
node  of S  can  be  major.)  Let  the  descendant  of ~  that  precedes  S  (if any)  be  tel. 
Otherwise, the  root of S  is ill.  Let node ~s be  the twin  of #1.  Since ~ is major L (t~l), 
L ( ~ )   ~_  N.  Let  L' (-)  give the labels  in  T'. 

All  nodes  preceding  S  in  T  have  their  labels  reduced  by  some  amount  in  T'.  It 
is true that ~ may  no longer be major, but ~s is not affected, so L' (~)  =  L(u2)  ~  N . 
Since  L'( ~)  _~  L ' ( ~ ) ,   we  have  L'( ~)  ~  N.  Hence  nodes  preceding  ~  have  labels 
equal  to  or  greater  than  N  in  T'.  Since  ~  precedes  no  major  node,  if  M  was  the 
number  of major nodes in  T,  there  axe at  least M  -  1 major nodes in  T'. 

B y   the  inductive  hypothesis,  the  number  of stores  required  to  evaluate  T '   is  at 
least  M  --  1.  Therefore, P '   has  at  least  M  --  1 stores  and  P  has  at  least  M  stores. 

LEMMA 6.  I f  M  is the number  of major nodes in  a  tree,  then the number  of stores  in 
its  evaluation  by  Algorithm  1  is  equal  to  M. 

PROOF.  Routine  (2C)  is the  only one of  (2 A) -(2 E)   which  causes a  store,  and  it 
causes exactly one store with each application. When  (2) is applied to a node, routine 

(2C)  is  used  if  and  only if the  node  is  major. 

LEMMA 7,  The number  of CLA 's in  the evaluation of a  tree is at least the  number  of 
minor  nodes in  the tree. 

PROOF.  We  shall prove this ]emma by induction on the number  of minor nodes. 
For trees with  only one minor node, the lemma is easily seen to hold, as at least one 
CLA  is  necessary  before  evaluation  can  begin. 

Let the  lemma hold for trees with  up  to  ]z -  1 minor nodes,  and  consider the  fol- 
lowing  tree  with  k  minor  nodes: 

P I 
/ t 

I 

~1 is a leaf; L (nt)  =  1, and n2 is the  root of a  subtree with k  -  I  minor nodes, 

To  evaluate  node  7,  the  value  of n~ must  be  in  a  register  as  it  is  a  left  operand. 
(Note  that  we  are  still  assuming  that  all  operations  are  noncommutative.)  There- 
fore, a CLA must occur for the value of nl. Since the value of nl is not used in evaluat- 
ing  n2,  a  program  for  the  total  tree  which  had  fewer than  k  CLA's  would  yield  a 
program  to  evaluate  n2 using fewer than  k  -  1 CLA's,  contrary to  hypothesis. 

LEMMA  8.  Algorithm  1  evaluates  a  tree  with  as  many  CLA's  as  there  are  minor 
nodes  in  the  tree. 

PROOF.  Only routine  (2A)  is applied to leaves,  and  only to minor nodes  at  that. 
Each  application  causes  a  CLA. 

THEOREM  2.  For  expressions  with  noncommutative  operators  and  no  nontrivial 
relations  between  operators and elements, Algorithm  1 produces  a minimal  cost program 
for  the  machine  we  have  described. 

Journal of the Association for Computing Machinery, Vol. 17, No. 4, October 1970 

722  R.  SETHI  AND  J.  D.  ULLMAN 

PROOF.  From Lemmas  5  and  6, the  number of stores is minimal.  From Lemmas 
7  and 8,  the  number  of  CLA's  is  minimal.  Each  binary  operation  specified is  per- 
formed  once.  Hence,  the  number  of program  steps  is  minimal. 

3.  Commutative  Operators 
We have now derived a property of trees, the sum of the number of major and minor 
nodes, which  measures  the  speed with  which its value can be computed.  The results 
of Section 2 prove our measure to be correct. When certain algebraic transformations 
are  permitted,  we  are  not  required  to  evaluate  a  given  tree,  but  may evaluate  any 
one  of! its  equivalent  trees,  obtained  by  applying  the  allowed  transformations.  In 
this section and Section 4, we establish  procedures for finding a  best  equivalent tree 

when the  commutative  and  associative transformations  are permitted.  Other  trans- 
formations may  make  the  problem  of  finding  best  trees  much  harder  than  in  the 
commutative  and  associative  case. 

When  commutative operators are  present,  there is a  family of trees that  compute 
the  same value.  Members  of this  family are  derived from each other by interchang- 
ing or "flipping" the descendants of commutative nodes. We will select that  member 
of the  family of trees that  minimizes the  highest label in the  tree and  the  number of major  and  minor nodes. 

Looking  back,  it  becomes  evident  that  the  only  trees  for  which  flipping  will 
help  are  trees  with  minor  nodes  which  correspond  to  commutative  operators  and 
have  nonleaf right  descendants.  In  such  cases,  flipping  the  leaf from the  left to  the 

right  will reduce  its label  from  1 to  0,  reduce  the  number  of minor nodes,  and  pos- 
sibly lead  to  a  reduction in  the  highest  label  and/or  number  of major nodes. 

Algorithm  1  may  easily  be  modified  to  perform  the  flipping. 

ALGORITHM 2 
1.  Generate labels. 
2.  For all nodes ~ such that L (~) >  1, its left descendant is a leaf, and the operator correspond- ing to ~ is commutative, flip the descendants so that  the leaf is the right descendant  (the 

restriction L(~)  ~> 1 guards against flipping when both nodes  are leaves). 
3.  Proceed as for Algorithm 1. 

Example  2.  If Algorithm  2  is used  for the  expression of Example  1,  the  expres- 
sion  actually evaluated is a/  (b  ~  c)  -  (e  --{- f ) ,d,   whose tree is: 

'  2  2 

. . . .   1 

b  c  e  f 
The  code for this  tree  is 

1.  a--~  regl 
2.  b--~ reg2 

Journal Of the Association for Computing  Machinery, Vol. 17, No. 4, October 1970 

The Generation of Optimal  Code for Arithmetic Expressions  723 

3.  reg2  +  c--~ reg2 
4.  regl/reg2  --~ regl 

5.  e --~ reg2 
6.  reg2  +  f ~   reg2 
7.  reg2.d  --~ reg2 

8.  regl  --  reg2  --~ regl 
Definitions.  Node  71 in  tree  Ti and  node 72 in  tree  T2 are  corresponding nodes  if 
neither  is  a  leaf,  and  the  expressions  represented  by  the  subtrees  with  roots  71 

and  v2 may  be  obtained  from  each  other  by  the  commutative  transformation.  Let 

T,  represent  a  tree with  root  a,  and  let 7 ( T , ,   T~)  represent  a  tree with  root 7  and 
left  (right)  descendant  subtrees  T~ (T~).  If ./is  a  leaf,  we  identify .y with  T~. 

LEMM+- 9.  Of  the family  of trees that  compute  the same  result  as  a  given tree, the tree~T generated by  Algorithm  2  has  the minimum  number  of major  nodes, the mini- 

mum number  of minor nodes, and  the label of every nonleaf node in  tree T is  less than or[equal to the label of the correspondinq node of any other tree in the family .......  ! 

PROOF.  We  shall  prove  this  lemma  by  induction  on  the  maximum  path: length 
P  in  a  tree.  For a  maximum  path  length  of 1,  the  lemma is easily seen  to hold. 

Let  it  hold  for P  <  k  --  1,  and  consider  a  tree  generated  by  Algorithm  2  with 
P  =  k  and  a  commutative  operator  at  the root.  The  tree  may  be represented  by 7 ( T : ,   T~).  . . . .  

Case  1:  ~ is a  nonleaf.  T hen  the  other trees in the family may be of either of the 
following  types---~l(T:l,  To1 )  o r   72(T~$,  T~i),  H e r e  a~  and  as  correspond  to  a, 

fh  and  Bs to  ~,  and  71 to  vs to  7 . . . .   : 

A s   the  lemma  holds  for P  _~  k  -  1, we  have L(a)  ~  L(al),  L(as)  and~L(fl)  _< 
L(f~l),  L(f~s). Therefore, L(7)  _<  L(71),  L(Ts).  If 7 is  major  then  71 and72  are  also major.  Thus,  the  lemma  holds  in  this  case. 

Case  2:  f~ is  a  leaf.  Then ~ the  other  trees in  the  family are  of either  of the  fol- 
lowing t y p e s - - ~  (6~,  Tel ) or 7s (T::,/~2). The notation here is the same as for case  1. 
Since  f~ is  not  a  minor  node,  the  number  of  minor  nodes  in  the  generated.tree  is minimal.  ::  : 

As fl is a  leaf, L(~)  =  0.  However, L(t~i)  =  1  and  L(B2)  = 0 .   T h e r e f o r e : L ( f l ) <  L(~i),  L ( ~ ) .   As  the  lemma  holds for P  <  k  -  1,  we  have  L ( a )   .<  L(a~);  L(as). 
Therefore, j us t as  for case  1,  the  lemma  holds.  . 

THEOREM 3.  Algorithm  2  produces  an  optimal  sequence: of  evaluation.for: an  ex- 
pression~  on  the  assumption  that  there are  only  commutative  and  noncommutative 
operators  in  the  expression  and  that  there are  no  other nontrivial  relations  bet~veen operators and  elements in  the expression.  . . . .  

PUOOF.  The  operations  performed  axe  STO's,  CLA's,  and  binary  opexations. 
By Lemmas 5-9  the number of STO's and  CLA's is minimal,  Each  binary  operation 
specified  is  performed  once,  Hence  the  number  of  operations  is  minimal  and  the sequence of evaluation  is  optimal.  , :  : . 

4.  Associative  Operations  . . . .  

Exploiting  the  associative  and  commutative  properties  of  some  operat ors, we 
achieve reductions in the  register requirements  and  the time  o f a  computation, :The 
example  shown  in  Figure  1,  in  which  both  associativity  and  commutat!vity: hold, illustrates  these  reductions. 

Journal of the Association for Computing Machinery, Vol. 17, No. 4, 0etober 1970 

724  R.  SETHI  AND  J.  D.  ULLMAN 

4 

(a)  (b) 

FzG.  1 

3 
3  3 

(c) 
The  algorithm  presented  in  this  section  would  produce  the  tree  in  Figure  1 (c) 
when started  out with  either of the  other trees in Figure  1. 

It  should  be noted  that  the  only associative  operators we  consider are  those  that 
are  both  associative  and  commutative  (a-c).  In  practice,  most  operators  that  are 
associative  are  also  commutative  on  integers,  reals,  etc. ~ 

Definitions.  An  operator is an  a-c operator  if it is both  associative and  commuta- 
tive.  A  cluster  is  a  set  of nodes  in  a  tree,  such  that 

(1)  each  node  in  the  set  is  associated  with  the  same  operator, 
(2)  the  branches  between  nodes  in  the  set  form  a  tree,  and 
(3)  if the  operator  associated  with  the  set  of  nodes  is  not  an  a-e  operator  the 
set  contains  only one element. 

The  root of a  cluster  is the  node in  the  cluster that  precedes all other nodes in the 
cluster. The ancestor of a cluster is the  ancestor of the  root of the  cluster. The  descen- 

dants of a cluster are  the descendants  of the leaves in the  cluster. The  descendant sub- 
trees  of  a  cluster  are  the  subtrees  preceded  by  the  descendants  of  the  cluster.  A 
maximal  cluster  is a  cluster which is not  a  proper subset  of any  other cluster. 

Given  a  binary  tree,  identify the  maximal  clusters.  It  should  be  clear that  these 
can  be  found  uniquely.  Let  a  maximal  cluster  C  have  descendants  81,  82,  . . . ,   8, 
and let the  root of C be a  descendant  of maximal  cluster A.  81,82,  * * *,  8~ are  roots 
of  clusters  D1,  Ds,  . . - ,   D~.  Generate  a  tree  with  node  ~  in  place  of  cluster  C. 
Let  ~  have  descendants  81,  82,  * * *,  8m.  Proceed  from  the  top  down  generating  a 
tree  with  one node  per  maximal  cluster.  In  the  new  tree,  there  is  a  single  node  for 
each  maximal  cluster in  the  binary  tree.  The  new  tree  is  called  an  associative  tree. 

The above definitions have the following motivation. Let T  be a binary tree and A 
its  corresponding associative  tree.  Let  T'  be  derived from  T  by  a  single  associative 

or  commutative  transformation.  Then  the  associative  tree  A'  corresponding  to  T' 
can be obtained  from A  by permuting the  descendants  of one node of A.  T ha t  node 
corresponds  to  the  maximal  cluster  of  T  in  which  the  transformation  took  place. 

Conversely, any permutation  of descendants  of a  node of A  can be  mirrored by the 
application  of  a  sequence  of  a-c  transformations  on  one  cluster  of  T. 

Let F  be the family of trees derivable from T by a-c transformations. The problem 
of finding the member of F  yielding the best program by Algorithm  1 is thus broken 
into  t wo  parts.  First,  using  permutations  of  descendants  of  the  associative  nodes, 
we  find  the  "best"  ordering  for  descendants.  Then,  from  the  resulting  associative 

a D. M. Ritchie pointed out that the FORTRAN operation SIGN(a, b) is associative but not com- 
mutative. 

Journal of the Association for Computing Machinery, Vol. 17, No. 4, October 1970 

The  Generation of Optimal Code for Arithmetic Expressions  725 
tree,  we  construct  t h a t   one  of the  corresponding  b i n ar y   trees  which  yields the  mini- 
mal  cost  prog ram. 

T h e  labeling  rules  for  associative  trees  are: 
LA1.  If  77 is  a  leaf  an d  the  leftmost  d es cen da nt   of its  ancestor,  th en  L ( 7 )   =  1. 
F o r   all o th er leaves, L  (7)  =  0. 

LA2.  If  7  has  d es cend an ts  with  labels  l l , / ~ ,   * ..  ,/,~,  ll  ~_  /~  >  * * *  >  /,~  th en 
L ( 7 )   = l l i f l l > / ~ , L ( 7 )   = l l + l i f l 1 =   /2. 

ALGORITHM  3 
1.  Generate a  binary tree for the expression. Convert  the binary tree to  an associative tree. 2.  Label  the  nodes  according to  the  labeling rules  for  associative trees,  and  do steps 3  and  4 

from the  bottom  up. 3.  At every  associative node 7,  order the  descendants  by label. Let  the  new order  be 80, ~ ,  

* .-  , ~,, such that  L(S0) _> L(~i)  >_  .-.  _> L ( ~ ) .  If possible, let 80 not be a leaf. Replace  the associative node y by m nodes ~ ,   1 <  i  <  m, such that g~l is the ancestor of ~ ,   1 <  i  <  m. 
The  left  descendant  of  n~+1 is yl and  the  right  descendant is  ~,   1  <  i  <  m. The  left  and right descendants of y~ are ~0 and ~1 respectively. The ancestor of y is now the  ancestor of ,~. 
4.  If the node g is not associative, proceed as for Algorithm 2. 

LEMMA  10.  Let N  be the number  of available registers. Given a binary  tree contain- 
ing  a  cluster with m  descendant subtrees, r  of which  have roots with labels greater than or equal to N, the cluster contains  at least r  --  i  major nodes. 

PROOF.  W e   shah  p ro ve  this l e m m a   b y  indu ction  on  the  m a x i m u m   p a t h   length  P 
of  the  su btree  d o m i n a t e d   b y   the  d u s t e r   (i.e.  the  tree  formed  b y   considering  the 
cluster  and   its  d escen d ant  subtrees  only). 

F o r  P  =  1, the  l e m m a   holds trivially. L e t  the l e m m a   hold for P  <  k, and  consider 
a  tree  with   P  =  k,  say  ~ (T,~,  T ~ ) .  

If ~1 and   7~ are  n o t   in  the  cluster  for v  the  l e m m a   holds  trivially. If  only  one  of 71 
and   w  is  in  the  cluster,  the  indu ctio n  is  el emen tary . 

W h e n   b o t h   71  and   72  are  in  the  d u s t e r   th ere  are  three  possible  cases.  L e t  the 
nodes  of the  cluster in subtrees  T,1  and  T,2  hav e  rl and  r2 d escen dant   subtrees  whose 
roots  h ave  labels  greater  t h a n   or  equal  to  N.  T h e  three  eases  are: 

1.  r l - -   r:  =  0; 
2.  one  of r l ,   r2 is  0; 
3.  r l , r 2   >  0. 
Case  1.  E l e m en ta r y . 
Case  2.  W i t h o u t   loss  of  generality,  let  r2  =  0  and   rl  =  r.  By   the  in ductive 
hypothesis,  th e  portion   of the  cluster in subtree  T,, has r  --  I  m ajo r nodes. 

Case  3.  T h e  l e m m a   holds  for the  portions  of the  cluster d o m i n at ed   b y   71 and   7~. 
Hence  t h ey   h ave  rl  --  1  and  r2  --  1  m a j o r   nodes  respectively.  Since  r l ,   r~  >  0, 
L(71),  L(72)  >_  N.  Hence  7  is  major,  an d  the  n u m b e r   of  m aj o r  nodes  in  t h e   tree  is 
rl  ~  r~  -  1.  As  rl  -F  r2  =  r,  the  l e m m a   holds. 

LEMMA  11.  Of the family F  of binary trees that compute  the same result as a given 
tree, Algorithm  3 generates that tree T,  that has  the minimum  register requirements for 
evaluation  without stores and  the minimum  number  of major  nodes of all  trees in  F. 

PROOF.  W e   shall  p rov e  this  l e m m a   b y   induction  on  the  m a x i m u m   p a t h   length 
P  in  th e  tree  T  generated  b y   Algo rithm   3.  * 

F o r   P  =  0  or  1 the  l e m m a   holds  trivially. 

Journal of the Association  for Computing Machinery, Vol.  17, No. 4, October 1970 

726  R.  SETHI  AND  J.  D.  ULLMAN 

Let  the  theorem hold  for P  <  k,  and  consider a  tree with p  =  k: 

/  \ /  \ 
/  T  \ ,'  / A k \  

[ *  //  \ /  \ 

//  :  :  \ //  \\ 

* ~  1/  \\ 

C0~isid~dr the maximal  cluster C defined by the  root r  of the  tree T.  The  cluster C 
h a s m   +  1 descendants  ~9,81,  * * * , ~=.  The  lemma  holds  for each  descendant  sub- 
tree of the  cluster so L (~),  0  <  i  <  m  are  minimal  and  the number  of major nodes in. each  subtree  is  minimal. 

From Lemma  1, if r  of the L (~),  0  <  i  <  m  are greater than  or equal to N  there 
are  at  least  r -   1  major  nodes  in  the  cluster  C.  The  reader  can  show  that  in  A1- 
gorithin 3, the  cluster produced from C has  only r  -  1 major nodes. The number of major  nodes  in  tree  T  is  therefore  minimal. 

As for the register requirements, from Algorithm 3, we can assume L (~i)  >_ L (~/1), 
0  < i < m .   .. 

Case  1.  L(~o)  >  L(fil).  Since  r  precedes  ~o,  L ( r )   >  L(~o).  As  in  tree  T, L ( r )   :-~  L($o),  the  label  of  r  is  minimal. 

Case  2:  L(~o)  =  L(~i).  As  L(~o)  =  L(~1),  a  node  preceding  both  8o and  ~1 
must  have  a  label  at  least  one greater than  L (~o). In  tree  T, L (r)  L (~o) +  1, so 
the  label :of ~" is minimal.  Any other tree in  the  family F  with  the  same  descendant 

subtrees  must  have  at  least  as  many  major  nodes  and  require  at  least  as  many 
registers  as  T.  From  the  inductive  hypothesis,  the  same  is  true  of  the  descendant 

subtrees  themselves.  Hence  the  lemma  holds. 

THEOREM 4.  Algorithm  3  produces  an  optimal  sequence  of  evaluation  for  an  ex- 
pression  on  the  assumption  that  there  are  only  commutative,  noncommutative,  and  a-c 

operators  in  the  expression  and  that  there  are  no  other  nontrivial  relations  between operators  and  elements  in  the  expression. 

PROOF.  From  Lemma  11,  the  number  of STO's  is  minimized.  As Algorithm  2 is 
applied  to  the  binary  tree  generated,  and  hence  to  the  nodes  with  commutative 
but  not  a-c  operators,  no  descendant  of  a  cluster  is  made  a  minor  node  unless  all 
descendants  are leaves. The number of CLA's is therefore minimized by Theorem 3. 

The! number  of binary  operations  performed  is  equal  to  the  number  specified in 
the expression.  (Note that  the  associative and  commutative transformations do not 
change  this number.)  Hence, the  sequence  of evaluation is optimal: 

5.  Storaye  References 
Every time  a  piece of information is  obtained  from or placed in  storage,  a  "storage 
reference"  occursl  Th e   information  referred  to  may  be  an  instruction,  an  initial 
value,  or  a  piece  of  temporary  storage. 

The  cost  structure  we  have  used  so  far  is  not  based  on  the  number  of  storage 
references during  evaluation.  However,  it  is  shown  in  this  section  that  Algorithms 

1, 2, and 3 minimize the number of storage references as well as the number of opera- 
tions. 

Journal  oi  the Association  for Computing  Machinery,  Vol.  17, No.  4, October  1970 

The Generation  of Optimal  Code for Arithmetic Expressions  727 

L EMMA. 12.  Let E  be an expression  whose tree T  has n nodes. Let c be the minimum 
number  .of CL A  instructions  in any program evaluating E  and s the minimum number  of 

STO's  in  any  program  evaluating  E.  Then  the  number  of  storage references in  any program evaluating E  is at least c ~  n  ~  3s. 

PROOF.  Let  no be  the  number  of nonleaves  in  T  and  nz  the  number  of leaves; 
no ~  nz  =  n. Any program for E  has at least c ~  no T  s steps,  since no is the number 

of b ~ a r y   operations  to  be  performed. At  least  one reference to  each initial  value in 
storage ~nust  occur, else  there  would  be  an  identity  of the form  E'  =  E,  where  E' 
was  missing  at least  one of the  variables of E.  There are nz initial values. Each  time 

a partial'value is stored, a storage reference occurs, and at least s of the values stored 
are  referenced later.  (For  a  value  not  subsequently  referenced need  not  be  stored, :  j.  .. 

and  s  is  a  presumed  lower  bound  on  the  number  of  storages.)  Thus  there  are  at 
least  r~z ~  2s  storage  references  involving  data.  The  minimum  number  of  storage 
references is thus  (e W no ~  s)  ~  (nz  W  2s)  =  c  W n  W  3s. 

THEOREM 5.  Algorithms  1,  2,  and  3 minimize  the number  of storage references in the  evaluation  of  a  given  expression. 

PROOF.  The  programs  produced  by  these  algorithms  have  both  the  minimum 
number of CLA's and the minimum number of STO's under their respective assump- 

tions.  It  is easy to verify that  the number  of storage  references is equal to the lower 
bound  of Lemma  12. 

6.  Discussion 

For  any  algorithm  to  be  of practical  utility,  it  must  evaluate  its  object in  a  reason- 
able  number  of steps.  The  adjective reasonable is not  precisely defined,  and  we  will 
not  attempt  to  do  so.  We  merely  state  that  once  the  tree  has  been  set  up,  the 
algorithms  presented  in  this  paper  require  a  number  of  steps  linearly  proportional 
to  the  number  of nodes in  the  tree. 

For Algorithms  1 and  2, the  first time  each node is visited  is when  the  labeling is 
done.  The  second  and  third  visits  occur when  we  travel  down  from the  root  to  the 
leaves  to  determine  the  order  of evaluation,  and  backtrack,  producing  the  evalua- 

tion  sequence  as  we  go. 

For Algorithm  3,  two  extra passes  occur when the  associative tree is constructed, 
then  remade  into  a  binary  tree.  Further  overhead  is  introduced  by  the  need  to  re- 

order  the  descendants  of  the  associative  nodes.  A  careful  look  at  the  algorithm 
reveals that  it is not necessary to  order all the  descendants by label.  All we need to 

find is the  descendant  with  the  maximum  label if it is unique,  and  two  descendants 
with  maximal  labels  if  there  is  no  unique  maximum  label.  This  operation  can  be 

done  in  time  proportional  to  the  number  of  nodes  involved.  The  associative  node 

can  then  be  split  into  binary  nodes  in  linear  time.  Thus,  a  slight  modification  of 
Algorithm  3  can  be done in linear time. 

It  is  easy  to  modify the  algorithms  to  take  into  account  operations  that  call  for 
extra registers. An example of such  an  operation is function invocations which need 

extra  registers  for linkages.  Labeling  rule  L2  of Section  2  has  then  to  be  modified. 

It  can be  shown  that  rule L2 at  node ~ with  descendants  ~  and  f~ is equivalent  to 
L(~)  =  min  {max [L(o~),  L(~)  -'b  1],  max [L(/~),  L(a )  +  1]}. 

If  the  operation  at  node  n  requires  R  registers  then  rule  L2  may  be  replaced  by 
L(~)  =  max [R,  min  {max [L(a),  L(f~)  +  1],  max [L(f~), L ( a )   +  1]}]. 

Journal of the Association for Computing Machinery,  Vol.  17,  No.  4, October  1970 

728  R.  SETHI  AND  J.  D.  UIJLMAN 
ACKNOWLEDGMENTS.  The authors are indebted to A. V. Aho, R. H. CanadaY, L. A. 

Dimino,  B.  W.  Kernighan,  M.  D.  McIlroy,  and  D.  M.  Ritchie for helpful discus- 

sions  and  comments. 

R E F E R E N C E S  
1.  NAKATA, IKUO.  On  compiling  algorithms  for  arithmetic  expressions.  Comm.  AC M   10,  8 

(Aug.  1967),  492-494. 2.  MEYERS,  W . J .   Optimization  of  computer  code.  Unpublished  memorandum,  G.  E.  Re- 

search  Center,  Schenectady,  N.  Y.,  1965  (12  pp.). 3.  REDZIEJOWSKI, R . R .   On arithmetic  expressions  and  trees.  Comm.  A CM   12, 2  (Feb.  1969), 
81-84. 4.  FLOYD,  R . W.   An  algorithm  for  coding  efficient  arithmetic  operations.  Comm.  ACM  ~, 

1  (Jan.  1961),  42-51. 5.  ANDERSON, J . P .   A  note  on  some  compiling  algorithms.  Comm.  AC M   7,  3  (March  1964), 
149-150. 
RECEIVED  OCTOBER,  1969; REVISED  APRIL,  1970 

Journal of the Association for Computing Machinery, Vol. 17, No. 4, October 1970 