

IMPLEMENTING PERMISSION ANALYSIS

by
William S Retert

A Dissertation Submitted in

Partial Fulfillment of the
Requirements for the degree of

Doctor of Philosophy

in
Engineering

at
The University of Wisconsin-Milwaukee

May 2009

IMPLEMENTING PERMISSION ANALYSIS

by
William S Retert

A Dissertation Submitted in

Partial Fulfillment of the
Requirements for the degree of

Doctor of Philosophy

in
Engineering

at
The University of Wisconsin-Milwaukee

May 2009

John Boyland Date
Graduate School Approval Date

ii

IMPLEMENTING PERMISSION ANALYSIS

By
William S Retert

The University of Wisconsin-Milwaukee, 2009
Under the Supervision of Professor John Boyland

ABSTRACT
Annotations allow programmers to express design intent. A system of quasi-linear
fractional permissions can support a wide range of program annotations; however,
checking the fractional permissions is nontrivial. Permission checking can be approximated, with formal rules and a fully implemented control flow analysis, well enough
to accurately check uniqueness and effects annotations.

John Boyland Date

iiiiv

cfl Copyright 2009

by
William S Retert

iv

Contents
1 Annotations and Intent 1

1.1 Why Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.1.1 Analysis and Assurance . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Some Proposed Annotations . . . . . . . . . . . . . . . . . . . 5
1.2 Uniqueness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.2.1 Effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.2.2 Annotation Regimens . . . . . . . . . . . . . . . . . . . . . . . 10
1.2.3 Linear Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.3 A combined system . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

1.3.1 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2 Permissions 21

2.1 Permissions Described . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.1.1 Permission Syntax . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2 Fractional heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.2.1 Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.2.2 Permission Semantics . . . . . . . . . . . . . . . . . . . . . . . 32
2.3 Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.4 Representing Annotations with Permissions . . . . . . . . . . . . . . 36

v

2.4.1 Field annotations, Class Invariants, and Inheritance . . . . . . 37
2.4.2 Raw and Cooked . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.4.3 Pointer Annotations . . . . . . . . . . . . . . . . . . . . . . . 41
2.4.4 Maybe-null and Non-null . . . . . . . . . . . . . . . . . . . . . 45
2.4.5 Complete Annotation Translation . . . . . . . . . . . . . . . . 45
2.4.6 Effects and Method Annotations . . . . . . . . . . . . . . . . 46
2.5 A simple language . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

2.5.1 Type System . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.5.2 Operational Semantics . . . . . . . . . . . . . . . . . . . . . . 53
2.6 Semantics of Annotations . . . . . . . . . . . . . . . . . . . . . . . . 55

2.6.1 Permission Semantics of unique . . . . . . . . . . . . . . . . 56
2.6.2 A More Detailed Example . . . . . . . . . . . . . . . . . . . . 58
2.6.3 Effects and Uniqueness . . . . . . . . . . . . . . . . . . . . . . 62
2.6.4 The Null-ness Modifier . . . . . . . . . . . . . . . . . . . . . . 66
2.6.5 Ownership . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.6.6 Fractions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

3 Design of Approximating Analysis 77

3.1 Algorithmic Transformation . . . . . . . . . . . . . . . . . . . . . . . 78

3.1.1 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
3.1.2 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
3.2 Abstracting Fractions . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

3.2.1 Lack of Recovery . . . . . . . . . . . . . . . . . . . . . . . . . 93

4 Implementation Issues 96

4.1 Flow analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

4.1.1 Lattice Structure for Permission Analysis . . . . . . . . . . . . 97

vi

4.1.2 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.1.3 Drop-sea . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
4.1.4 UI for Permission Assurance . . . . . . . . . . . . . . . . . . . 105
4.2 Integrating CFG-Analysis, Drop-Sea . . . . . . . . . . . . . . . . . . 107

4.2.1 Post-pass Assurance . . . . . . . . . . . . . . . . . . . . . . . 107
4.2.2 Example Revisited . . . . . . . . . . . . . . . . . . . . . . . . 108
4.2.3 Poisoned Lattices . . . . . . . . . . . . . . . . . . . . . . . . . 109
4.2.4 Side Effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
4.2.5 Control-flow Analysis Asea . . . . . . . . . . . . . . . . . . . . 111
4.2.6 Example Re-Revisited . . . . . . . . . . . . . . . . . . . . . . 112
4.3 Fluid Decisions in Permission Lattice . . . . . . . . . . . . . . . . . . 116

4.3.1 Assertions and Claims . . . . . . . . . . . . . . . . . . . . . . 117
4.3.2 A Word on Null-ness . . . . . . . . . . . . . . . . . . . . . . . 119
4.3.3 Putting It All Together . . . . . . . . . . . . . . . . . . . . . . 120

5 Experimental Evaluation 123

5.1 Small Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
5.2 jEdit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126

6 Conclusion 128

6.1 Further Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

6.1.1 Additional Annotations . . . . . . . . . . . . . . . . . . . . . . 129
6.1.2 Concurrency . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.1.3 Efficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
6.2 In Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

Bibliography 132

vii

List of Figures

1.1 A simple example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.2 Simple use of unique . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.3 `Breaking' uniqueness? . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.4 Ownership in a List . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.1 Permission Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.2 Permission Equivalence (helper relation). . . . . . . . . . . . . . . . . 31
2.3 Evaluation rules for boolean formulae: A; N ` \Gamma  + b . . . . . . . . . 33
2.4 Semantics of Fractional Permissions with Nesting . . . . . . . . . . . 34
2.5 Translation of Rawness Annotation (ra ! \Gamma ra,r) . . . . . . . . . . . . 40
2.6 Translation of Pointer Annotations (pa ! \Pi pa,r) . . . . . . . . . . . . 40
2.7 Translation of Nullity Annotation (na ! \Gamma na,r) . . . . . . . . . . . . 45
2.8 High-Level Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.9 Permission Type Rules (Part 1) . . . . . . . . . . . . . . . . . . . . . 51
2.10 Permission Type Rules (Part 2) . . . . . . . . . . . . . . . . . . . . . 52
2.11 Operational Semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.12 Approximate Permission Typing of send . . . . . . . . . . . . . . . . 60
2.13 A Simple Example Using Fractions . . . . . . . . . . . . . . . . . . . 68
2.14 A Surprising Use of Fractional Permissions . . . . . . . . . . . . . . . 70
3.1 Algorithmic Type Rules for Carving . . . . . . . . . . . . . . . . . . . 78

viii

3.2 Algorithmic Lookup Rules . . . . . . . . . . . . . . . . . . . . . . . . 79
3.3 Comparing Base Permissions . . . . . . . . . . . . . . . . . . . . . . . 80
3.4 Finding Base Permissions . . . . . . . . . . . . . . . . . . . . . . . . 81
3.5 Pass-through rules for linear implications . . . . . . . . . . . . . . . . 82
3.6 Syntax of Abstract Fractions . . . . . . . . . . . . . . . . . . . . . . . 91
3.7 Rules for Abstracting Fractions . . . . . . . . . . . . . . . . . . . . . 92
3.8 Adding and Scaling Abstract Fractions . . . . . . . . . . . . . . . . . 93
4.1 Standard loop for linked-lists . . . . . . . . . . . . . . . . . . . . . . . 101
4.2 Now with fields! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
4.3 Now with @NonNull! . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.1 Actual "Bad" Uniqueness Example . . . . . . . . . . . . . . . . . . . 125

ix

1
Chapter 1
Annotations and Intent
One of the largest areas of concern in computer science is the tendency of software
to not behave as intended, both on the large scale and the small. Software engineering features a panoply of techniques to verify--even partially--the correctness of
programs. Much of this effort is spent on empirical verification in the form of testing, or informal verification in the form of manual review of source code. However,
it is also possible to attempt automated formal verification of program; often these
prove the correctness of secondary annotations, ensuring the absence of particular
errors. An example of this is the type system, which obviates type errors. Herein
I detail one particular implementation of one particular formalism for checking the
accuracy a particular regimen of annotations. Ultimately, being able to demonstrate
that programs are correctly annotated will tend to increase their correctness.

2
1.1 Why Annotations
According to C.A.R. Hoare [Hoa69], "The most important property of a program is
whether it accomplishes the intentions of its user." To this end, program verification attempts to prove programmer-provided assertions. Such assertions are typically
couched in formal logic, and added as annotations to code [LBR99, KMJ02]. Unfortunately, the intentions of the user for an entire program can be complex. Additionally,
the logic language used to encode the desired behavior must employ low-level descriptions of machine state for (semi-)automated verification to be practicable. Thus the
resulting annotations tend to be complex and difficult to understand; this forms a
strong barrier to adoption.

Conversely, simpler annotation schemes [CBS98] involving intuitively grasped concepts present less work to the programmer. Such annotations lack full expressive
power and therefore cannot be used to fully verify programs, as they are insufficient
to describe the intentions of the user. However, they can express some portion of the
programs design intent. That is, they allow programmers to relate high level design
intuitions, and an automated annotation-checking tool can assure that the code satisfies the model used for its design. Programmers must still show that the program as
designed will satisfy the needs of the user, but are assured that the code will perform
according to that design.

Additionally, as the annotations for design intent generally involve particular properties, full logical reasoning can be replaced with program analysis. When using logical predicates to describe program state, the predicates may at any time be replaced
with a logically equivalent or logically consequent set; this is embodied by the rules of
consequence in Hoare logic. At worst, this requires an (in general) undecidable proof

3
to produce intermediate steps. Program analysis (in particular, control-flow analysis and abstract interpretation) approximates program states using lattices (partial
orderings). Well-developed theory [NNH99a] shows that if the partial ordering is
complete and obeys the ascending chain condition, and if the program changes state
monotonically, a simple worklist algorithm can find a safe fixed-point approximation
of the program state. Thus, properties, such as some forms of design intent, may be
checked automatically.

One area where this approach seems particularly applicable is in verifying programs with aliasing. Programs containing a large number of pointers are difficult to
reason about. Moreover, by their nature, object-oriented programs contain a large
number of pointers (consider Java). This has led to recent efforts to hybridize verification with pointer analysis [LARSW00] or to use more complex logics [IO01] which are
aware of aliasing. Additionally, over the last decade, many proposals have been made
concerning annotations of design intent for pointer usage. Common proposals include
various forms of ownership, read-only references, and unique references. Mostly, these
proposals extend object-oriented programs to better represent the encapsulation of
an object's state.

1.1.1 Analysis and Assurance
The Fluid project contains divergent functionalities generally intended to assist the
fluid evolution of code over time by maintaining consistency between the evolving
program and the relatively consistent intent of the programmer(s) as expressed by
annotations on the program. Among these are the underlying versioning infrastructure (the Fluid IR), support for control-flow analysis, a mechanism (double-checker)
for assurance of code, and a system (Drop-Sea) for maintaining the connection between code and intent. A natural way to extend the system is by adding a new

4
assurance and also, adding a new analysis to support this assurance.

An assurance is the feedback a programmer receives documenting that the program does or does not meet its design intent as stated by annotations on the program.
Commonly the assurance is equally referred to as an analysis; for this writing, I will
make a distinction. Here, an analysis is a static tool which approximates the runtime
state of the program. In particular, a control-flow analysis uses lattice values, iteratively propagated to a fixed point, as its approximations. For convenience, this paper
will use analysis and control-flow analysis interchangeably; in practice most analyses
used in Fluid are not control-flow analyses.

An assurance is usually implemented using an analysis. The analysis approximates
the behavior of the program (including some behaviors assumed from specification vi'a
annotation1). The assurance can prove that certain annotations accurately describe
the program by comparing the program behavior as approximated by the analysis
with the behavior as specified by the annotations being checked. These comparisons
are nontrivial in control-flow analyses because the analysis' truth is computed by
iteration; assurance is only meaningful on the final result, not interim lattice states.

Consider a simple NonNull control-flow analysis that passes around an intersection
lattice representing the set of local variables which are known not to be null. One
may desire to use this analysis to implement an assurance that a given flow unit
cannot throw a NullPointerException. For example, given the code in Figure 1.1,
the analysis could use the if test to determine that x is not null and the assurance
can use the fact that x is not null to argue that calling somefun() will not generate
a NullPointerException.

1Generally, this is not the annotation currently being checked.

5
@noNPE
void foo(SomeClass x){

if(x != null) x.somefun();
}

Figure 1.1: A simple example
1.1.2 Some Proposed Annotations
For many years now, researchers have proposed various annotations indicating design
intent on pointers.

In ownership types [BLR02, BSBR03, Cla01, CNP01, CPN98, MPH00, AC04],
each object "owns" its representation. Objects are not allowed to see, use or store
pointers into another object's representation.2 Programmers communicate desired
ownership relationships by annotating each object by a symbolic ownership domain.
By limiting domains to those passed from above and one representing the current object one eliminates the possibility of a pointer into a separate object's representation.
In addition to ownership types, there are comparable ways to prevent aliasing into
encapsulated representation, such as confined types [BV99, ZPV03, ZPV06].

Alternately, one could annotate certain references as read-only [MPH00, BE04a,
BE04b, ETT05]. The object pointed-to could be read through this pointer, but not
written. Read-only pointers may be transitive; some systems provide casts to and
from read-only. Objects may encapsulate state by forcing pointers from "outside" the
encapsulated boundary to be read-only. However, as Boyland [Boy05] argues, readonliness is not an ideal model because it does not prevent inappropriate information
flow. It only prevents changes to encapsulated state, and not even those if the readonly gets cast away. In a similar vein, Haack [HPSS07] uses an ownership system to

2This is different than private modifiers in that privacy protects names on a per-class basis and
ownership protects objects on a per-object basis.

6
support immutable classes.

Another model for access control is uniqueness, which will be the focus for much of
the remainder of this paper. A unique pointer is, conceptually, the only reference to
a particular object. This allows for objects to be de facto owned and encapsulated by
placing them in unique fields. There have been many proposed implementations, with
differing semantics. Most systems include several other kinds of pointers. Non-unique
(shared) pointers should be allowed; not every object should have only one pointer to
it. Under certain circumstances (e.g. within a method) it should be possible to violate
uniqueness constraints; otherwise unique references are nigh unusable. Temporarily
aliasing unique pointers is generally called "borrowing".

1.2 Uniqueness
Uniqueness is not a new concept. On the one hand, it can be traced back to linear
type systems [Wad90]. A value with linear type may only be used once. As such it
is de facto unique. Linear types may coexist with nonlinear (normal) types, but the
two cannot intermix. Additionally, the use-once property that assures uniqueness can
affect ease of expression, making linear values difficult to work with using nonlinear
paradigms for programming. Linearity can be eased in a syntactically limited space
using the let! construct.

Early systems for unique fields featured this difficulty; therefore a series of proposals [Hog91, Min96, AKC02, Boy01a] began featuring what have become known
as "borrowed" parameters. A borrowed parameter provided a temporary alias to a
unique value. The difficulty sets in when deciding exactly what constitutes unique
and what constitutes temporary.

7
Another approach involves assuring uniqueness dynamically. External Uniqueness [CW03] contains both uniqueness and ownership types. Externally unique objects allow only one reference into their representation. In permission semantics, one
can implement this similarly to uniqueness, by attaching permission for the representation to the externally unique pointer. The proposed system, however, is supported
using destructive reads which are equivalent to linear semantics: reading a unique
pointer destroys or nullifies it. This ensures that there is only one reference to the
unique object, as any attempt to make a copy destroys the original. External uniqueness causes borrowing reads to nullify the unique value for a syntactically limited
time (thus keeping borrowed references off the heap). Remote consumers are given
the safe, null, value. In general this has the effect of replacing uniqueness errors with
NullPointerExceptions. In addition, directly implementing dynamic reads requires
a drastic overhaul of the runtime system.

Thus, one finds static analyses that attempt to prove that a program adheres to
the semantics of destructive reads without actually implementing them. For example,
the getItem method in Figure 1.2 performs the equivalent of a destructive read when
it nullifies item prior to returning its value. In its original form, AliasJava [AKC02]
used a liveness analysis on local variables to ensure the correct use of these `manual'
destructive reads.

But this may not actually correspond to one's intuitive notion of uniqueness.
Persistent aliases of unique objects are banned; however aliases defined as temporary
may in practice persist after the unique object has been handed off to somewhere else.
The code in Figure 1.3 gives an example of this. Although the ListItem appears
to have the only reference to its item, one can, as in send, affect the ListItem's
unique item from outside the ListItem. As it is accessed outside the ListNode, the
uniqueness of the item cannot also represent encapsulation; more generally, no class

8
class ListItem{

unique Object item;
unique ListItem next;
ListItem(unique Object o, unique ListItem n) {

item = o; next = n;
}
unique Object getItem() {

Object temp = item;
item = null;
return temp;
}
...
}

Figure 1.2: Simple use of unique

class Bad{

unique ListItem a;
unique Object b;
Bad(unique Object o, unique ListItem n){

a = new ListItem(o,n); b = null;
}
unique ListItem getList(){

ListItem temp = a;
a = null;
return temp;
}
unique ListItem send(){

ListItem bad = a;
ListItem ret = new ListItem(getList(),null);
b = bad.getItem();
return ret;
}
}

Figure 1.3: `Breaking' uniqueness?

9
can be certain that it encapsulates any unique object which it is passed. But, if a
unique object is passed to a class, it should be encapsulated, as there are "no" other
references.

1.2.1 Effects
The semantics for uniqueness thus depends on what constitutes a "temporary" alias.
If methods affecting the unique field may be called while it has been borrowed, the
borrowed reference can break the implied encapsulation provided by uniqueness. However, if a uniqueness analysis can track all the fields accessed by a method, it can
determine whether a borrowed reference may be safely maintained across a call to
that method. For example, knowing that the call to getList changes a allows us,
when analyzing send to mark the temporary alias bad as untenable after the call to
getList. This is the insight behind Alias Burying [Boy01a].

Tracking the fields accessed across a method call requires an effects analysis [GB99,
LPHZ02]. Each method is annotated with a list of which fields it reads and which
fields it writes. Information hiding can be supported with data groups (also called
regions). A data group is an abstraction grouping several fields together. Effects on
the fields can be expressed in annotations as effects on the data groups containing the
fields. For example, a class representing a circle on the Euclidean plane could have
separate data groups for the Size and Location of the circle. A function to move the
circle would declare an effect on the Location data group, whether the location was
represented by x and y coordinates or a point object--provided the corresponding
fields were declared to be in the Location group.

An effects analysis can similarly utilize uniqueness information to transfer the
effects on the uniquely referenced object to the unique field. What effects should be
on the send method in Figure 1.3? It writes the field b directly, and it writes the field

10
a by calling getList. It also writes the field a.item when it calls bad.getItem().
But a is a unique field. Thus, the only way to access a.item is through a; declaring
that we write a.list is redundant with declaring we write a. That is, we map effects
on fields solely accessible through a as effects on a.

Mapping effects relies, of course, on sole access through a field, which means that
we map effects onto unique fields. (This is not restricted to uniqueness; one can map
effects on owned objects onto their owner.) Unfortunately, this means that we cannot
analyze or even precisely define uniqueness and effects separately [Boy01b]. What is
needed is a common semantics for both effects and uniqueness (and, ideally, many
other useful annotations).

1.2.2 Annotation Regimens
One of the running problems with many proposed annotations is that they have been
proposed in isolation. Each proposal includes rules proscribing the use of annotated
values; however, the exact semantics of the annotation are murky. Especially murky
are the semantics of using more than one proposed annotation at the same time. If
pointers can be read-only and unique , then is it possible to have a field that is
both unique and read-only? Can one store a unique parameter in a read-only field,
or pass a unique field as a read-only parameter? Blindly following the rule for each
annotation will only work if they are independent; if being read-only has no effect on
being unique.

But even without worrying about interactions between annotations (yet), a wellfounded semantic definition is vital. If a unique pointer is one that follows arbitrary
rule set R, does "uniqueness" have a meaning beyond "follows the rules in R"? Or is
there some property defining uniqueness which R preserves?

The Spec# program verifier [BRLS04] is similar to the linear permission system

11
described here in that it provides a common semantics to a wide range of program
annotations, including non-null, ownership, immutable, and effects annotations. It is
implemented by transforming the annotations into logical predicates which are then
verified by a general program prover [ByECD+06]. Using full program verification
to check annotations has the advantage that program verification is well-established;
however, it is also an intrinsically harder problem than annotation checking.

1.2.3 Linear Logics
A particularly active area in recent research has been in quasi-linear logics for reasoning about program behavior. The advantage these logics provide to automated
reasoning is the same as the advantage they provide to our annotations: they enable
reasoning to be local to some subset of the heap without complex frame properties
describing what the procedure being analyzed does not do to the rest of the heap.

Adoption and Focus
The immediate progenitor of Boyland-style permissions is adoption and focus [FD02].
Vault [DF01], a language using linear types to enforce protocol (ordering) constraints,
uses adoption and focus to mix linear and non-linear types. Here the linear pointer
type is split into the singleton alias type [SWM00] and the capability (permission)
to access it. Adoption is the permanent incorporation of one object's state into a
pointer of another object (the guard). The guarded reference is sharable, while the
original pointer is not. The Vault system supports this at runtime by keeping back
pointers from guards to guarded objects. Focus allows access to the linear guarded
state. The guard is unusable for the duration of the focus; in particular, multiple
copies of the guard may not be focused on simultaneously.

12
There are some immediate differences between adoption and focus and the permission system of Chapter 2. Permissions allow smaller granularity; individual fields
may adopt and be adopted. This is used to allow field keys to double as effects; for
uniqueness, an object's state is treated as a whole. Finer granularity requires that
each adopted field should only be "carved out" (focused on) once, but the adopting field may have multiple fields carved out simultaneously. Fields only require the
return (unfocusing?) of adoptees when required by the annotation system (e.g. to
return an effect to the caller).

Other differences stem less from the formal permission system than the planned
usage. Adoption and focus are expressions and as such are evaluated at runtime.
We perform similar operation using permission transformation. As the type system
is sound, the adoption operation is a no-op at runtime. For the Java annotation
checker, adoption occurs instantaneously on object creation and is never revisited.
Thus adoption need not be expressly implemented in either the static or dynamic
semantics of the annotation checker.

Separation Logic
Although the immediate inspiration for this permission system was adoption and
focus, the final result closely resembles separation logic [Rey02]. Separation logic
allows reasoning about heap properties by reasoning about partial heaps. The core
predicate is the contents of one heap cell (akin to the alias type for a single permission).
Two partial heaps are declared disjoint using the star ? connector (akin to ,). The
magic wand ( -? ) operator lets the contents of one partial heap encompass another
(akin to the linear implication used to represent carved-out permissions). Indeed,
fractional permissions may be just as easily grafted into separation logic [BCOP05].
These similarities in form and function conceal fundamental differences.

13
The most obvious difference is the lack of adoption in separation logic. Equally
straightforward is the difference in intent. One reasons about program properties in
separation logic; one does not define extra properties (design intent), then use the
mechanics of the logic to assure it.

However, the limited syntax for permissions (predicates) conceals another, more
fundamental distinction. Permission forms are limited syntactically to allow a mechanical flattening process to determine whether they are consistent with memory.
All transformations of permission states (e.g. carving out a permission) are safe because the result is consistent in any memory in which the progenitor is consistent.
That is, changes in permission state never break consistency with memory. On the
other hand, separation logic is founded on the logic of bunched implications [OP99].
Transformations of predicate state are allowed when they are sound according to this
logic.

Smallfoot [BCO05] provides (some) automatic verification for concurrent programs
using separation logic. It uses a system of symbolic execution which resembles the
permission type system mentioned herein. However, it has differences too, both in
intent--the system verifies low-level predicates specifying data structures--and in
technical detail. Evaluation reduces to entailments in separation logic; neither fractions nor adoption are present.

Separation logic can also be used to verify particular usage patterns. For example, there are several ways [Bie06, Kri06] to associate separation logic predicates
with Java iterators to avoid their misuse. This differs from from in that from is a
general-purpose annotation which can be used to help assure correct iterator behavior; however, it is not specific to iterators. The observer pattern can be similarly
checked [KAB07].

14
1.3 A combined system
Fractional permissions provide a common semantics for a wide variety of annotations,
not just uniqueness and effects. I here describe a regimen of annotations on a simplified Java-like language. Each of these annotations can be defined using fractional
permissions; however the actual analysis, as implemented, does not check all of them.

Every method is annotated with its effects. An effect may be on shared (the
"world") or on fields or groups of this or a parameter. Groups are abstractions
of fields; each field and group is nested in its declared group (All if a group is not
explicitly given). Each class inherits two special data groups, All and Owned, from
Object; the latter holds the state of objects owned by the current object.

Fields, parameters, receivers, and return values are annotated with exactly one of
the following pointer annotations (local variables have their annotation inferred by
the type checker):

* An "ordinary" pointer, with no strict restrictions on (aliasing) the referenced

object, is annotated shared .

* Ownership describes an object's representation beyond the object itself. The

ListNodes (Figure 1.4) help represent the list, although they are not stored
inside the list object in the heap. References to these nodes are annotated with
their owner (either this in the List or the class' ownership parameter in the
ListNodes). We use a weak form of ownership which does not forbid references
across ownership boundaries.

* A unique pointer represents the only access to the pointed-to object. As such

it can represent a transferable form of ownership.

15

* A borrowed pointer temporarily aliases another (unique) pointer. The borrowing lasts until the unique reference is again required, as determined by effects annotations. Only method parameters and receivers may be annotated
borrowed.

* The annotation from effect, as discussed in previous work [BRZ07], represents a return value that "borrows" from the named effect. For example, the
iterator() function in Figure 1.4 returns a read iterator that borrows the effect of reading the list. When the list is written, this borrowed effect must be
returned.

* A readonly pointer cannot be used to write the object it references or the

objects owned or uniquely referenced by that object. The object may be written
through other pointers. State that a readonly-owner reference refers to may
be read but not written by the designated owner.

* A unique-write reference can be used to write the object it references, and it

knows no one else can write that object. Any aliases must be read-only.

* An immutable object may never be written; an immutable reference points to

an immutable object. Thus it is possible to pass an immutable reference where
a read-only reference is expected but the reverse is illegal.

Each field (parameter, receiver, or return value) is annotated with its class, one
of the above pointer annotations, and two modifiers. A reference may be annotated
non-null, which helps our type system ensure the absence of null-pointer exceptions.
Of course, a nonnull field cannot actually be non-null upon entry to the class constructor; it is only non-null thereafter. In general, the invariants representing field
annotations are not established until the constructor has finished execution. Thus,

16
if this is passed as a parameter or receiver from within the constructor, the called
method cannot assume the field annotations are accurate. Following F"ahndrich and
Leino [FL03], we term an object "raw" if it has not necessarily established its field
annotations and "cooked" if it has. Each class' constructor establishes the field invariants for that class, but not for its descendants. A raw [C] object has its fields initialized through class C but not necessarily further; raw is a shorthand for raw [Object].
In general, cooked objects can be passed as raw [C], and raw [C] objects may be
passed as raw [C0] if C _ C0. In our examples, a reference without an explicit nullness
modifier may be null, one without a rawness modifier is cooked.

Each class takes one ownership parameter which is passed in at construction, and
may only be passed on or used in ownership annotations. (Our system can be easily
generalized to any bounded number of parameters.) Unlike with some ownership
systems, ownership is not mandatory--the ownership parameter may be ignored.
The super constructor call implicitly passes the same ownership parameter on.

The ownership parameter may itself bear a pointer annotation describing the
"owning" object; the absence of an annotation on the ownership parameter is syntactic sugar for borrowed. The annotations unique , unique-write , and from are not
allowed on ownership parameters. The owner parameter may be null or raw. Ownership annotations are restricted to either this or the class' ownership parameter.
Having the null owner is equivalent to being shared. In our examples, we elide an
ownership parameter that is never used.

1.3.1 Example
The List class, its accompanying ListNode, and a read ListIterator are depicted
in Figure 1.4. Together they define a simple doubly-linked list and, incidentally,
illustrate many of the annotations whose semantics can be given using fractional

17
class ListNode<owner>{

owner ListNode next;
owner ListNode prev;
shared Object datum;

ListNode(shared Object d, owner Node n, owner Node p)

{ super(); datum = d; next = n; prev = p;}
}
class List{

this ListNode head;

List(){ super(); head = null; }
reads All

shared Object first() borrowed

{ return head == null ? null : head.datum; }
writes All

borrowed Object insert(shared Object datum) borrowed

{ return (head = new ListNode<this>(datum, head,null);

head.next == null ? null :(head.next.prev = head; null)) }
reads All

from(All) ListIterator iterator() borrowed

{ return new ListIterator<this>(head); }
}
class ListIterator<readonly-this list> extends Iterator{

list ListNode cursor;

ListIterator(list ListNode head) { super(); cursor = head; }
reads All

borrowed Object hasNext() borrowed { return cursor; }
writes All

shared Object next() borrowed

{ return (cursor == null) ? null : let temp = cursor.datum in

(cursor = cursor.next; temp); }
}

Figure 1.4: Ownership in a List

18
permissions. The formal syntax used in this example is that described in Figure 2.8.

The ListNode accepts a single ownership parameter which will refer to its owner;
the next and previous ListNodes that it links to must be owned by the same object.
With permissions, one needs permission to access the owning List to access the
fields of the next and previous ListNodes. In contrast, the data object stored in the
node is annotated shared , which corresponds to ownership by the global context:
anyone with permission to access the global context may access the state of any
shared object. The ListNode constructor initializes all three fields from identicallyannotated parameters.

The List has a single field, a reference to a ListNode which is owned by the
List. The constructor initializes this field to null. The first() method has several
annotations. It is annotated with the effect that it may read any field of the List;
in particular it reads the head. This is represented by the first() method being
passed permissions for all of the fields of the List whenever it is called, including
that of head. The first() method also has an annotation of borrowed at the end
of the line; this annotation applies to the receiver of first(). A borrowed reference
is a temporary alias; the fields of the receiver can only be accessed as described in the
effects annotation. A reference to a shared object is returned from first because
datum is annotated shared .

The writes All effect on the insert() method is similar to the effect on first()
except that it represents a write effect, and thus a requirement of a write permission.
Here writes of objects owned by the List are mapped to an effect on the List itself.
When the new ListNode is created, it is passed the List as its owner. The shared
annotation on the parameter and the borrowed annotation on the receiver mean
the same as before. The borrowed annotation on the method return indicates that
the returned reference may only be used in pointer identity tests; no one may read

19
or write its fields. Given the uninteresting nature of the value returned from the
function, this is appropriate.

The iterator() method returns an iterator over the List. The read effect and
the borrowed receiver are exactly as described above. The from(All) annotation
on the method return allows the returned iterator to temporarily use anything in the
reads All effect of the list. As discussed elsewhere [BRZ07], once the iterator is no
longer needed, it can be discarded and the permission recovered, after which the list
may again be mutated.

The iterator uses its borrowed permission to take ownership of the list. In this
example, the ownership parameter does not own the object to which it is passed;
the opposite is in fact the case. The readonly-this annotation on the iterator's
ownership parameter indicates that the ListIterator actually owns the List, but
only for reading. The ListIterator features a reference to a ListNode owned by
the List, which it, thus, indirectly owns. This indirect ownership is used in the
next() method to map the effect of reading the fields of the cursor from the effect of
writing the ListIterator. The other annotations in the ListIterator class behave
as described above.

Most of the annotations used in this example interact heavily with one another.
The receiver is made borrowed , forcing all permissions to be handled as effects. The
write effect on the insert() method interacts with the ownership of the ListNodes,
enabling insert() to manipulate them without declaring a representation-exposing
effect. Both the ownership of the ListNodes by the List and of the List itself by the
ListIterator interact in a similar way with the write effect on next(). Further, the
ownership of the List by its iterator would not be possible without the from(All)
annotation, which in turn directly interacts with the effect which it "borrows." These
interactions all express themselves naturally once all the annotations are given a

20
semantics using fractional permissions.

21

Chapter 2
Permissions
It is possible to provide a single semantics for many of the proposed pointer annotations using a system of fractional permissions with adoption. The particular
system of fractional permissions described in this chapter is joint work of John Boyland, Yang Zhao, and myself. The chapter is largely a compendium of our joint
work [Boy03, BR05, BRZ, Boy07, BRZ07]. It contains a formal review of permissions, their syntax and semantics, how they provide a semantics for annotations, and
how they may be type-checked non-algorithmically.

2.1 Permissions Described
A permission represents the right to access some portion of state. "State" here refers
to the values of the fields of the objects in memory; for pointer fields, these values
are the memory locations of the pointed-to objects. In particular, the state referred
to is the value of a single field; this granularity is necessary to express field-level
annotations. Accessing state means either reading or writing the value of some field.
As access is restricted to possessors of the associated permission, controlling the

22
distribution of permissions is equivalent to controlling access, which is the essential
goal of the pointer annotations.

Permissions are linear. Every field has exactly one permission associated with
it. To write state, one must possess this permission; possession of this permission
conversely entails that no one else could possibly write the same state. However,
while it is generally advantageous to prevent multiple writers of the same field, one
may wish to enable multiple readers. To this end, a permission may be split in two.
Possession of a partial permission allows one to read but not write the corresponding
field. Partial permissions may be further divided or re-combined. If all the partial
permissions are rejoined, one may once again use it to write state. Determining
that all pieces have been reassembled requires some accounting; therefore when a
permission is divided, each piece is assigned a fraction of the divided permission.
A "fraction" of 1 denotes write permission; a "fraction" of 0 denotes absence of
accessibility. (In practice zero is not allowed as a fraction; absence of access equates
to absence of permission entirely.)

Permissions cannot be duplicated. This ensures the uniqueness of a field's write
permission, but it poses a problem when trying to share access to or even information
about a field. We therefore allow the adoption (or nesting) of one permission (the
nested permission) into another (the nester permission). Then anyone who has the
nester permission (and only someone with the nester permission) also has the nested
permission. The fact that this nesting has taken place does not represent any permission itself; it merely indicates that the nested permission is available if one has
the nester permission. Since the fact of the adoption is not itself a permission, it may
be duplicated. By analogy: I put my life savings in a piggy bank. Telling people
"I put my life savings in a piggy bank" does not double my money, nor does it give
them access to my money. To access my life savings, one first needs access to the

23
piggy bank, after which the money can be removed. The process of removing a nested
permission from its nester is referred to as "carving-out." (F"andrich and DeLine use
the term "focus.") This carving-out leaves a hole in the nester that must be replaced
before the nester permission may be used again.

Adoption is used for abstraction and convenience. Related fields may be adopted
into the same data group (or region), allowing the data group permission to stand
in for all the fields. The entire state of an object can (and for our purposes is)
adopted into one such group, providing an easy handle for the complete state of the
object. Further, adoption facts provide a sharable way of expressing field annotations,
and forcing the carved-out holes to be filled enforces the presence of the adopted
permissions and therefore the correctness of the annotation.

2.1.1 Permission Syntax
On some level, permissions are essentially syntactic entities. A permission is defined
by its structure. The semantics of fractional permissions, described intuitively above,
is given formally in Section 2.2.2. The separation of syntax and semantics enables
us to provide an analysis that operates solely on syntactic fractions, yet is provably
correct relative to the semantics. Figure 2.1 gives a (partial) context-free-grammar
defining the syntax of fractional permissions.

A formula \Gamma  represents a fact whose truth (if known) is preserved throughout
execution. Facts can be treated "nonlinearly"; they can be duplicated freely. As
well as basic predicate logic (true, conjunction, negation, existentials and named
predicates), we have reference equality tests, nesting facts and object type assertions
that state that the object at ae is of class C (or a subclass).

A permission (\Pi ) may take on many forms. There is exactly one unit permission
associated with every field in the heap. If ae refers to some object on the heap, f

24
ae ::= o | r literal reference, variable
k ::= ae.f key (field instance)

, ::= fraction:

q literal (0 < q <= 1)
z fraction variable

\Gamma  ::= formula:

true true
\Gamma ^\Gamma  conjunction~

\Gamma  negation9
ffi * \Gamma  existential
p(ae) named predicate
ae = ae reference equality
\Pi  OE k nesting
ae 2 C object typing

\Gamma  =) \Gamma 0 \Delta = ~(\Gamma  ^ ~\Gamma 0)

\Pi  ::= permission:

\Gamma  formula
k!ae unit permission
v permission variable;

no permissions
\Pi  + \Pi  combination
,\Pi  fraction scaling
\Gamma  ? \Pi  : \Pi  conditional9

r * ae.f !r + \Pi  existential
\Pi -+\Pi  implication

P ::= {. . . , p(ae) = \Gamma , . . .} predicate defns
ffi ::= r | z | v any variable
\Delta  ::= {. . . , ffi, . . .} variables
E ::= \Delta ;\Pi  environment
ff ::= 8\Delta ; \Pi  -! 9\Delta ; \Pi  procedure type
oe ::= {r 7! ae, z 7! ,, v 7! \Pi , . . .} substitution

Figure 2.1: Permission Syntax.

25
is a field and ae0 is the contents of that field, then we can give the syntax of a unit
permission as one kind of permission:

\Pi  ::= ae.f !ae0 | . . .
The unit permission gives the right to access the state, reading or writing the field.
If the field is written, the unit permission changes to reflect the new value stored in
the field.

Permissions can be combined in a number of different ways:

\Pi  ::= \Pi  + \Pi  | 9r * \Pi  | \Gamma  ? \Pi  : \Pi  | . . .
A compound permission \Pi  + \Pi 0 gives one all the rights associated with both of the
permissions being compounded. The identity of the compounding operator ("+") is
the trivial permission ; which gives no rights to any state. An existential permission
represents a permission where a location r is unspecified. In a conditional permission
\Gamma  ? \Pi 1 : \Pi 2, \Gamma  is a boolean formula (not a permission). If the formula evaluates to
true, one has the first permission; if false, then the second permission.

A permission may be scaled by a fraction ,:

\Pi  ::= . . . | ,\Pi  | . . .
Here , represents a positive fraction (rational number) usually less than 1. It may
be a fraction variable, but will never be zero. Fractions give a way to get multiple
permissions for a single state; a permission may be split in two:

\Pi  j 12 \Pi  + 12 \Pi  j 12 \Pi  + 14 \Pi  + 14 \Pi  j 34 \Pi  + 14 \Pi  j ...

26
Scaling distributes through compounds, conditionals and existentials. A scaled unit
permission gives read access to the field thus referred to.

One last kind of permission is a form of linear implication:

\Pi  ::= . . . | \Pi -+\Pi 
A linear implication \Pi 1-+\Pi 2 means that one has the rights of the consequent \Pi 2,
except for the ones of the antecedent \Pi 1. The rights implicit in a linear implication
cannot be used until it is combined with its antecedent using a linear form of modus
ponens:

\Pi 1 + (\Pi 1-+\Pi 2) ) \Pi 2

Here the ) symbol is meta-implication: the permissions on the left may be transformed into the right form as needed during type checking.

A permission may be nested in a unit permission, or more precise, in the field
itself. This means that anyone who has the unit permission (the nester ) also has the
nested permission. We represent the information that \Pi  is nested in ae.f by a formula

\Gamma  ::= . . . | \Pi  OE ae.f | . . .
The formula does not represent any permission itself; it merely indicates that the
nested permission \Pi  is available if one has the nester permission ae.f !ae0.

The picture here shows the composition of two permissions being put together
(;) by nesting the darker permission \Pi  in the lighter one k, after which the darker

+ ; )

\Pi  + k!ae0 k!ae0 34 k . . . + 14 k . . .

\Pi  OE k \Pi  OE k

27
permission is no longer (directly) accessible, but a new nesting fact \Pi  OE k is known.
Then this nester permission is split into two pieces, thus implicitly splitting the nested
permission. Here k is a meta-variable referring to a field of some object k j ae.f . The
nesting fact \Pi  OE k is immutable and thus need not be scaled.

The hole left from carving out a nested permission is represented by linear implication (nested -+ nester). The nester permission will not be considered complete
until the nested permission is "replaced."

) + )
3
4 k!ae0 \Gamma 

3
4 \Pi  -+ (

3
4 k!ae0)\Delta  +

3
4 \Pi 

3
4 k!ae0

\Pi  OE k \Pi  OE k \Pi  OE k

As seen in the picture, permission carving handles fractions transitively: if one has
only a fraction of the nesting permission, one can only get a fraction of the nested
permission. Notationally, we have:

(\Pi  OE k) + (,k!ae) ) (\Pi  OE k) + ,\Pi  + (,\Pi -+(,k!ae))
When one is done with the nested permission, it can be replaced using the linear
modus ponens rule explained above.

A permission may include a permission variable v used to refer to an unknown
permission treated parametrically by a method. Also a formula \Gamma  may be treated as
a permission with no rights, as long as the formula is true. We restrict existentials to
increase their precision by forcing the variable (r) to be stored in a known field ae.f
(we do not permit ae = r). This reduces the expressiveness of existentials, but also
prevents certain degenerate cases.

28
Permissions share inspiration with separation logic [Rey02] and there are several
parallels. The combination operator (+) is the equivalent of ? in separation logic,
while ; is equivalent to "emp." We do not use separation logic's syntax because the
metaphor is wrong ("?" would be addition for fractions) and to avoid confusion in
how we treat non-linear terms: "true" corresponds to emp, not to true. We also
use a semantics for -+ that is more restricted than for -? .

The environment E = (\Delta ; \Pi ) in which a term is permission checked (see Section 2.5.1) has two parts: a type context \Delta  which is a set of variables drawn from R
(reference variables), Z (fraction variables), and V (permission variables); and a bag
of permissions \Pi . For an environment E = (\Delta ; \Pi ), we normally require that all free
variables in \Pi  are in \Delta . For brevity purposes, this restriction is left implicit.

A procedure type 8\Delta ;\Pi  -! 9\Delta 0;\Pi 0 is polymorphic over variables in \Delta . It accepts
the permission \Pi  and returns the permission \Pi 0, using perhaps some new variables
\Delta 0 (as well as the existing variables \Delta ).

Substitutions (oe) of variables map each kind of variable to the appropriate kind.
Substitutions are made total (being the identity on variables not in the original domain) and are lifted to apply to all syntactic entities in the normal manner.

2.2 Fractional heaps
This section describes the use of fractional heap in providing a semantics for fractional
permissions. It is quoted from Boyland [Boy07].

Separation logic is given semantics using heaps [IO01]; fractional permissions with
"fractional heaps." To handle fractions, the heap is not simply either defined or
undefined for each location, but rather if defined, is defined to a fractional extent
between 0 exclusive and 1 inclusive. The heaps of separation logic can then be seen

29
as a special case where every fraction is one.

Formally, a (fractional) heap h is a finite (partial) map of locations to pairs of a
positive fraction and a value (for us, an object reference from the countably infinite
set O):

h : L * (Q+ * O)

Here L is the (countably infinite) set of locations in the heap. We use ^; to refer to
the empty heap that is defined nowhere. A fractional heap where every fraction is 1
is called a memory (written u).

We apply our permission types to object-oriented languages and thus for us locations are fields of objects (L = O * F , where F is a finite set of field names);
every object's field has its own individual permission since fields of (mutable) objects
can be updated independently. The fraction represents the permission to access the
heap at that location (field); it does not grant access to the object whose reference
is stored in the heap at that location (field). We say that one heap is included in
another h1 <= h2 if for every fraction in the first, it matches the second with at most
that fraction:

h1 <= h2 = 8(q1,o)=h1(l) q1 <= q2 where (q2, o) = h2(l)
Heaps can be combined by adding together the corresponding fractions, but only
if the values match: If there is a location l such that hi(l) = (qi, oi) and o1 6= o2 then
h1 ^+ h2 is undefined. Otherwise it is defined as follows:

(h1 ^+ h2)(l) = 8????!????:

h1(l) if h2(l) is undefined
h2(l) if h1(l) is undefined
(q1 + q2, o) where (qi, o) = hi(l)

30
It is clearly the case that h ^+ ^; = ^; ^+ h = h for all h.

Two fractional heaps that can be added are called compatible. Because we permit
fractions to exceed 1, a fractional heap is always compatible with itself.

Heaps can be scaled by any fraction q > 0:

(qh)l = (qq0, o) where hl = (q0, o)
The ability to scale heaps (and also permissions) is required because of nesting, as
explained above.

Ambiguity in the semantics comes from having multiple heaps that model the
same permission. Unrestricted ambiguity can make the fundamental fraction intuition

1
2 \Pi  +

1
2 \Pi  j \Pi  unsound since the two occurrences of \Pi  could refer to different heaps.

Most desirable would be if a permission were "precise." We adopt the concept

of "precision" from separation logic: A permission is precise if any two compatible
fractional heaps h1 and h2 that model \Pi  must be equal. Unfortunately however, there
are some permissions, such as the first example of an implication \Pi 2 -+ \Pi 1 that are
imprecise, as will be shown in Section 2.2.2.

2.2.1 Equivalence
Figure 2.2 defines a relation V on permissions used to define equivalence:

Definition 2.2.1 The j relation is the transitive, symmetric and reflexive closure of
the V relation. We write \Pi  >= \Pi 0 if and only if there exists \Pi 00 where \Pi  j \Pi 0 + \Pi 00.

The equivalence relation induces a partition on permissions. We choose a particular representative as "canonical."

31
Q-Identity
\Pi  + ; V \Pi 

Q-Commute
\Pi  + \Pi 0 V \Pi 0 + \Pi 

Q-Associate
\Pi  + (\Pi 0 + \Pi 00) V (\Pi  + \Pi 0) + \Pi 00

Q-Combine

\Pi 1 V \Pi 01 \Pi 2 V \Pi 02

\Pi 1 + \Pi 2 V \Pi 01 + \Pi 02

Q-Zero
q; V ;

Q-One
1\Pi  V \Pi 

Q-Distribute
q(\Pi  + \Pi 0) V q\Pi  + q\Pi 0

Q-Multiply

q, q0 > 0 qq0 = q00

q(q0\Pi ) V q00\Pi 

Q-Add

q, q0 > 0 q + q0 = q00

q\Pi  + q0\Pi  V q00\Pi 

Figure 2.2: Permission Equivalence (helper relation).
Definition 2.2.2 Given an arbitrary total ordering < on permissions, a permission \Pi 
is in canonical form, if it is in the form

(q1ss1 + (q2ss2 + . . . (qnssn + ;) . . .))
for n >= 0, where for every 0 < i < j <= n, we have ssi < ssj using this arbitrary order,
and each ss (called a "unit" permission) has the form

ss ::= \Gamma  | o.f !o | \Gamma  ? \Pi  : \Pi  | 9r * \Pi  | \Pi  -+ \Pi 
Boyland [Boy07] has proven the following using machine-checked proofs and the
Twelf theorem checker.

Lemma 2.2.3 The following rule is "admissible"

Q-Scale

\Pi  V \Pi 0

q\Pi  V q\Pi 0

32
In other words, adding it would not change the definition of equivalence.
Theorem 2.2.4 For every \Pi , there exists exactly one canonical \Psi  such that \Pi  j \Psi .

2.2.2 Permission Semantics
This section defines the semantics of fractional permissions in terms of fractional
heaps. The semantics depends on the current nesting situation N , a complete map
on locations to the permissions nested in that location:

N : L ! {\Pi }
We require that this map yields the empty permission ; except for a finite number of
locations.

Permissions are used to analyze stateful programs. At the beginning, we start
with the empty nesting situation: N0(l) = ;. While the program is running, new
permissions may be nested in locations; thus N may grow (but never shrink). We
define the <= operation on nesting situations N1 <= N2:

8l * N1(l) <= N2(l)
where <= on permissions is defined using equivalence (see Defn. 2.2.1).
Formula Evaluation
For the semantics of permissions, we need an evaluation of formula to boolean values
written A; N ` \Gamma  + b where b 2 {true, false}. The A set is a set of assumptions
used for simulated coinduction. It starts off empty. Formula evaluation need not be
defined for all formulae, but it must be deterministic: a formula cannot evaluate to

33
B-True
A; N ` ? + true

B-Neg

A; N ` \Gamma  + b

A; N ` ~\Gamma  + ~b

B-AndFalse1

A; N ` \Gamma 1 + false

A; N ` \Gamma 1^\Gamma 2 + false

B-AndFalse2

A; N ` \Gamma 2 + false

A; N ` \Gamma 1^\Gamma 2 + false

B-AndTrue

A; N ` \Gamma 1 + true A ` \Gamma 2 + true

A; N ` \Gamma 1^\Gamma 2 + true

B-Equal
A; N ` o=o0 + (o = o0)

B-Nest

N (l) >= \Psi 

A; N ` \Psi  OE l + true

B-Exist

A; N ` [ffi 7! X]\Gamma  + true

A; N ` 9ffi.\Gamma  + true

B-Axiom

\Gamma  2 A

A; N ` \Gamma  + true

B-Pred

A [ {p(o)} ; N ` [r ! o]P (p) + true

A; N ` p(o) + true

Figure 2.3: Evaluation rules for boolean formulae: A; N ` \Gamma  + b
both true and false in the same context, and it must be stable:

N1 <= N2 ^ (A; N1 ` \Gamma  + b) ) (A; N2 ` \Gamma  + b)
In other words, a formula cannot change its value during execution. This permits
non-linear reasoning even in the face of state changes: once true, always true; once
false, always false.

Figure 2.3 defines evaluation rules for the formulae forms defined in Figure 2.1.
Of some interest is the fact that conjunction can avoid evaluating a sub-formula,
which may be necessary because a formula may be undefined in the current nesting
situation. For instance, B-Nest shows that a nesting fact can only be true, never
false. Since nestings increase monotonically, we can never depend on a nesting not
being true.

A similar situation applies to existential formulae and recursive predicates. An

34
S-Implication

h; \Psi  + \Psi 0 |=CN \Pi 

h; \Psi  |=CN \Psi 0 -+ \Pi 

S-Obligation^;

; \Psi  |=CN \Psi 

S-Formula;

; N ` \Gamma  + true

^;; ; |=CN \Gamma 

S-Cond;

; N ` \Gamma  + b h; \Psi  |=CN \Pi b

h; \Psi  |=CN \Gamma -+\Pi true\Pi false

S-Exist

h; \Psi  |=CN [ffi 7! X]\Pi 

h; \Psi  |=CN 9ffi.\Pi 

S-Fraction

h; \Psi  |=CN \Pi 

qh; q\Psi  |=CN q\Pi 

S-Combine

h1; \Psi 1 |=CN \Pi 1 h2; \Psi 2 |=CN \Pi 2

h1 ^+ h2; \Psi 1 + \Psi 2 |=CN \Pi 1 + \Pi 2

S-Equiv

\Psi  j \Psi 0 \Pi  j \Pi 0 h; \Psi 0 |=CN \Pi 0

h; \Psi  |=CN \Pi 

S-Field

h; \Psi  |=C[{(h;\Psi )OEl}N N (l)

u = [l 7! (1, o)]

h ^+ u; \Psi  |=CN l!o

S-Field-Co

(h; \Psi ) OE l 2 C

u = [l 7! (1, o)]

h ^+ u; \Psi  |=CN l!o

Figure 2.4: Semantics of Fractional Permissions with Nesting
existential or predicate call can only be evaluated as true. We assume that P (p) gives
the definition of predicate p and that we never call a predicate with the wrong number
of arguments. Reflecting standard practice, we use an overline to represent multiple
formals r and actuals o. The form [r ! o]P (p) means to substitute the actuals for
the formals in the body of the predicate. Rules B-Pred and B-Axiom together
implement coinduction: while evaluating the body of the predicate, we assume the
result will be true. If we permitted both true and false assumptions, a recursive
formula could evaluate to both true and false, violating determinism.

Theorem 2.2.5 Boolean evaluation is deterministic.
Theorem 2.2.6 Boolean evaluation is stable.

35
Permissions
Figure 2.4 shows the relation that defines when a heap models a permission h; \Psi  |=CN
\Pi . We have already discussed the N qualification. We now discuss the presence of \Psi 
on the left-side of the relation. The C qualification is explained below.

The \Psi  on the left of the modeling relation is an "obligation." The obligation
starts empty. Recall that \Pi 1 -+ \Pi 2 means "everything permitted by \Pi 2 except
that permitted by \Pi 1." This intuition is expressed in making \Pi 1 an obligation that
must be discharged symbolically while expanding \Pi 2. This can be seen in the rules
S-Implication and S-Obligation in Fig. 2.4. Thus in S-Obligation, if we are
looking for heap to model a permission that exactly matches the obligation, the
obligation is discharged, and thus the empty heap fits. New obligations are added in
a sub-goal in S-Implication.

The rules S-Field and S-Field-Co deal with field permissions. In the first rule,
the nesting situation N is used to determine the current nesting for the location. The
resulting heap is added to a unit permission for the field. The C set is used to get
a co-inductive effect of the first rule by permitting it to help establish itself. The
elements of the C set are triples written (h; \Psi ) OE l. The rule S-Field-Co uses the
C set to avoid recursively looking at the nested permissions.

2.3 Transformation
Once we have a semantic basis for permissions, we can define the transformation relation, which enables us to convert permissions from one form to another. Ultimately,
this will be used by the type system to produce the exact permission needed when
checking reads, writes, and method annotations.

36
There are two forms of transformation, transformation by implication, and transformation by nesting. These can be written

Tr-Implies

E ) E0

E ; E0

Tr-Nest
\Delta ; \Pi  + \Pi 0 ; \Delta ; \Pi  + (\Pi 0 OE k)

The nesting rule says that one may give up any permission and receive in its place a
"nesting fact." The place of nesting is arbitrary.

With implication, one permission can be transformed into another if, for every
fractional heap consistent with a memory that models the former permission, there is
a second fractional heap, consistent with the first, that models the latter permission.

8h, \Psi , N, u h <= u =) \Gamma h; \Psi  |=;N oe\Pi  ) 9h0 <= h, oe0 ' oe such that h0; \Psi  |=;N oe0\Pi 0\Delta 

\Pi  =) \Pi 0

This rule is sufficient to ensure that implication is safe. That is, no one can use transformation with implication to gain access to something to which they had previously
lacked permission. In fact, the rule is written to allow any safe implication.

2.4 Representing Annotations with Permissions
The permissions detailed in Section 2.1 provide a powerful system for highly granular
control over users' access to fields. The detail is useful for its expressive power but also
provides a bar to the system's utility. It is not reasonable to expect programmers
to provide annotations in fully detailed semantics. As stated initially, the aim is
to provide programmers with intuitive annotations and the machinery necessary to
assure them. Permissions are useful because their expressive power is sufficient to

37
provide a semantic basis for many common pointer annotations.

It seems counterintuitive to use permissions to define pointers given that permissions reflect the right to access a piece of state (that of the pointed-to object).
However, permissions are convenient for defining pointer annotations precisely because they uniquely control access to the pointed-to object. Semantics which, like
capabilities [BNR], define pointer annotations by qualities of the pointers themselves
cannot be localized because the pointer property itself is not local. A unique pointer
is not unique because of any quality it possesses; it is unique because no other pointer
refers to the same object. This is a global property of the system, as is allowing other
pointers to the same object (shared). Permissions, by being local to the pointed-to
object, implicitly make these global claims; if one holds both a "unique" pointer and
permission to all fields of the pointed-to object, no other useful pointer in the system
can reference the same object. Pointers with no permission are still allowed.

2.4.1 Field annotations, Class Invariants, and Inheritance
The conditions that the annotations impose on fields are called "unary field invariants" because they are object instance invariants that involve one field at a time.
We handle unary field invariants through nesting. A field is always nested using a
particular permission. This permission expresses the possible nullness, the enclosed
permissions (if any) as well as the ownership of the state of the object pointed to.
Thus when the field's permission is nested in its data group, it must meet all the
required conditions. If one knows of the nesting and has the permission to the data
group, one knows that its unary field invariants (expressed through annotations) are
valid. We express all the fields' invariants as a named predicate whose body consists
of a conjunction of nesting facts. This is the class invariant.

A "data group" is modeled by a field with an uninteresting type; in this paper,

38
a group declaration is converted into a field that is always null. Thus permission to
the All data group of object r is written r.All!0. The direct children (fields or other
data groups) of this data group have their permission nested within the data group.
Therefore, when a data group is used for an effect, the exact nature of what fields are
used is rightfully hidden from the caller, which only must provide the permission for
the group which includes the permission for any fields. In addition to the All and
Owned data groups in Object, there are two global data groups (groups on the null
pointer), one for immutable state and one for state owned by the "world1."

The class invariant must be established by the constructor. The constructor is
modeled by a method that takes the permissions for each field individually and returns
the permission for the "All" data group after establishing the class invariant for its
own and all superclasses. The permission to "All" and the class invariant jointly
imply that all fields are consistent with their types.

Once the invariant is established in the constructor, it can be broken by carving
the field out of its data group and assigning it a value that does not fit. But then the
data group permission cannot be restored until the required unary field invariant is
restored. Boogie uses a similar semantics for invariants [BDF+04]. In JML [LBR99],
all invariants of fully-constructed objects must be valid in every method, except that
a "helper" method may be called on an object whose invariant is currently broken.
With permissions, one has a looser semantics: the only objects whose invariants must
be true when the method starts are those whose state can be observed using the
permissions passed into the method.

1For simplicity, we use the Owned data group of the null pointer.

39
2.4.2 Raw and Cooked
When a method call (dynamic dispatch) is invoked on the object under construction--
either directly from the constructor, or indirectly through a method called with the
under-construction object as a parameter--that call may be passed a reference whose
class invariant is not yet established. For example, no field is non-null on entry to the
constructor. This can lead to unsoundness if one assumes that invariants are always
true. On the other hand, if the requirement on the invariant is an explicit part of
the method signature, then the method cannot be overridden in a subclass wanting
a stronger invariant.

We solve this conundrum through the use of raw types (borrowed from F"ahndrich
and Leino [FL03]). Instead of treating "raw" as a primitive, we express it (or rather
its inverse, "cooked") using permissions. A "cooked" pointer is one for which the
invariant is true for every dynamic type that the object possesses:

cooked(r, o) = (r 2 C1 =) C1(r, o))

^ . . . ^ (r 2 Cn =) Cn(r, o))

Here r 2 C states the object at location r is of class C or one of its descendants, and
C(r, o) is the class invariant for class C (where o is the ownership parameter). The
body of the cooked predicate ranges over all classes in the system. Thus a method
can require that its receiver be "cooked" and permit an overriding method to use the
same predicate to provide a stronger invariant. A reference with a raw[C] annotation
only guarantees those from C up the class hierarchy.

Every field permission includes a predicate (\Gamma ra,r) for the pointed-to object stored
in r, which indicates how much of the class invariant is known to be established. The
form this predicate takes for each possible rawness annotation is shown in Figure 2.5.

40
Rawness Annotation (ra) Facts (\Gamma ra,r)

raw[C] C(r, rowner)

cooked cooked (r, rowner)

Figure 2.5: Translation of Rawness Annotation (ra ! \Gamma ra,r)

Pointer Annotation (pa) Permissions (\Pi pa,r)

unique r.All!0
shared r.All OE 0.Owned
immutable 9z.zr.All OE 0.Immutable

readonly 9z.zr.All OE 0.Owned

unique-write

1
2 r.All!0+1

2 r.All OE 0.Ownedowner r.All OE r

owner.Owned
readonly-owner 9z.zr.All OE rowner.Owned

borrowed

from(x.f ) r.All!0+r.All!0-+,r

x.f + v

readonly-from(x.f )

1
2 ,r.All!0+1

2 ,r.All!0-+,rx.f + v

Figure 2.6: Translation of Pointer Annotations (pa ! \Pi pa,r)

41
2.4.3 Pointer Annotations
Field annotations are represented in the class annotation by nesting the existentiallyquantified permission to the field in the appropriate data group. The various pointer
annotations are given semantics by the permissions included in the existential closure
along with the field permission. These are summarized in Figure 2.6. As before,
r represents the object to which the field points. The last four annotations in the
diagram may annotate method parameters or return values, but not fields.

Uniqueness
A pointer is unique if permission to all of the pointed-to object's state is stored in
its existential closure. This is accomplished using permission to the All data group
(r.All). Because there is exactly `one' permission for each location and because every
permission for an object is ultimately nested within its All data group the unique
field has the only permission allowing access to the object to which it refers. Thus
no one has permission to access the uniquely pointed-to object except through the
unique field.

If we have a linked list of unique nodes,

class Node{

* * *
unique Node n;
}

the class annotation would then be in part

Node(rt, ro) = . . . 9r * 0B@ r

t.n!r + r.All!0

+ cooked (r, 0) + r 2 Node 1CA OE

rt.All . . .

42
Therefore, one can carve out the permission for the next Node from the current Node,
but must restore it before reasserting the class invariant. The provided annotation is
inaccurate in that it ignores possible nullity (see below).

Ownership
Ownership is expressed by nesting the "All" group of the owned object in the "Owned"
group of the owning object (r.All!0 OE rowner.Owned). Thus, the class invariant for
the List (in Figure 1.4), would be in part

List(rt, ro) = . . . 9r * 0B@ r

t.head!r + r.All!0 OE rt.Owned

+ cooked (r, rt) + r 2 ListNode 1CA OE

rt.All . . .

Ownership works similarly in the ListNode, however the owning object changes.

ListNode(rt, ro) = . . . 9r * 0B@ r

t.prev!r + r.All!0 OE ro.Owned

+ cooked (r, ro) + r 2 ListNode 1CA OE

rt.All . . .

Carving out the nested permission for the ListNodes from the permission for the
List is what allows us to map effects on the nodes to effects on the List itself.
The permanence of nesting fits well with most ownership type systems in which the
owner of an object is fixed. Unlike some ownership systems, we do not fix an owner
upon creation; an object is created unique. Optionally, it may receive ownership at
a later time. And if the owner is discarded, the object may be considered unique
again, or given a new owner. In the example, the List becomes unowned once the
ListIterator is no longer in use.

Permission nesting only models the hierarchical structure of the ownership graph.
Most ownership systems also enforce an ownership policy. The most common of these

43
is owners-as-dominators which forces all access to an owned object to go through
its owning object; that is, an owned object may only be referenced by its owner or
objects directly or indirectly owned by the same owning object. By default, fractional
permissions represent a policy of owners-as-effectors, where effects of owned objects
must map to their owners. This implies that permission to access its owner is required
to be able to access an owned object. However, this permission may exist outside of
the owning object itself.

Shared
A shared pointer is one whose object's state is owned by the "world," represented here
by the (fictive) null object. More precisely, the "All" data group of the pointed-to
object is nested in the "Owned" group of the null pointer. (r.All!0 OE 0.Owned).
If a method wishes to read or write the state of shared objects, it must declare
an effect on shared (null.Owned). This suffices for single-threaded programs, but
shared state is problematic in concurrent programs.

Immutability
All immutable state has a fraction that is nested into a special globally known "immutable" group (9z.zr.All!0 OE 0.Immutable). Implicitly, every time a method is
called, it passed permission for a (small) fraction of this field. Thus, we do not need
to declare method effects for reading immutable state. "Final" fields can be modeled
by nesting the field permission in the immutable group.

Read-Only
With fractional permissions, we can nest a fraction of a permission in a data group
instead of the whole thing. A read-only pointer refers to state made globally readable

44
by having some fraction of it owned by the "world" (9z.zr.All OE 0.Owned). The
pointer to an object can be broadcast widely together with the knowledge that its state
is read-only. In this case, readonly is not precisely transitive, since any state nested or
existentially closed within the read-only state is not technically readonly: no fraction
of its permission is necessarily directly owned by the "world." But the transitivity
of fractions over permission nesting achieves the same effect: the subordinate state
cannot be mutated using this reference.

Unique-Write
The difference between readonly and immutable is a difference in convention between
the shared state and the "immutable" state: a method will never be given the whole
permission to the special "immutable" field. On the other hand, a class may "know"
(as part of its invariant), that half of the permission to some object is stored in the field
pointing to it and the other half belongs to the "world" ( 12 r.All!0, 12 r.All OE 0.Owned).
In this case, a method in the class can request the whole "world" permission with
the annotation "writes shared," and then combine the obtained permission with the
permission in the field to get a whole permission, with which it can write referredto the object. This is what we call unique-write: any method with access to the
shared state can read the state, but some privileged methods (inside the class with
the unique-write field) have the ability to write it as well. Requiring the privileged
methods to declare an effect on the shared state ensures that interference cannot
escape notice.

The distinction between a unique-write and a unique variable is clear from its
definition: a unique variable can be mutated without reference to the shared state,
but a unique-write variable needs to ensure that no one else is in the process of
reading the variable and thus must access the shared state.

45
Non-null Annotation (na) Precondition (\Gamma na,r)

nonnull true
maybenull ~(r = 0)

Figure 2.7: Translation of Nullity Annotation (na ! \Gamma na,r)

2.4.4 Maybe-null and Non-null
Forming an existential closure with permission to access the state of the pointed-to
object only makes sense when there is a pointed-to object; that is, when the pointer
is not null. This can be established in two ways. First, the pointer can be declared
not to be null, which avoids the problem. Alternately, the enclosed permissions can
be made conditional on whether the pointer is null. These correspond to nonnull
and maybenull annotations respectively. For simplicity, we always represent nullity
as a precondition, using true as the precondition when the field is nonnull, as shown
in Figure 2.7.

2.4.5 Complete Annotation Translation
In general, the full permission for any annotated field (ra na pa C f ) is:

\Gamma na,r ? (\Pi pa,r, \Gamma ra,r, r 2 C) : ;
This shows up in the class invariant existentially quantified for r and nested in the
appropriate data group.

Our unique linked list node then becomes

Node(rt, ro) = . . . 9r * ~(r = 0) ? 0B@ r

t.n!r + r.All!0

+ cooked (r, 0) + r 2 Node 1CA

: ; OE rt.All

46
Now if we carve out permission for the next node, the invariant may be restored
either by restoring that permission (as before) or by pointing to null. The full class
invariant for the List class in Figure 1.4 is

List(rt,ro) = rt.Owned!0 OE rt.All^

9r * ~(r = 0) ? 0B@ r

t.head!r + r.All!0 OE rt.Owned

+ cooked (r, rt) + r 2 ListNode 1CA

: ; OE rt.All

2.4.6 Effects and Method Annotations
A method is passed permissions to enable it to access state. Thus an effects annotation
on a method can translate directly as the permission to access the location described
in the effect. This permission must be passed in when the function is called and must
be returned to the caller after it returns. A write effect is passed (and returns) the full
permission to access the field. A read effect is similar, except it requires any non-zero
fraction of permission (e.g. z9r.rthis.x!r) that the caller can spare during execution.
The same fraction is returned when the method returns. The variable rthis refers to
the object which is the receiver, rx to parameter x, while the variable rret stores the
return value.

Unlike previous systems with method effects (notably that of Greenhouse and
Boyland [GB99]), a method effect for us is given a linear semantics: it precludes the
existence of an incompatible effect elsewhere. Thus while a method possesses the
permission passed in as a read-effect, the state referred to is immutable. Thus we
get the semantics of Pechtchanski's "context immutability" [PS02] (without needing
a whole-program analysis or run-time checking). In other words, the read effect
prevents dangerous aliasing with read-write state. This does not overly strengthen
the semantics, because allowing such aliasing should be considered an error. Such

47
situations are called "erroneous" in Ada; they are deemed bad, but the Ada compiler
does not prevent them, statically or dynamically.

Pointer Annotations and Methods
Pointer annotations on parameters and method returns are handled differently than
effects: the appropriate permissions are passed into the function for a parameter and
out of the function for a return value. These permissions are the same as used with
fields, but lacking the existential closure. Thus, the method annotation for the first
method in the List in Figure 1.4 would be

8z; zrthis.All!0 + cooked (rthis) + rthis 2 List -! 9;; zrthis.All!0

+ ~(rret = 0) ? rret.All!0 OE 0.Owned + cooked (rret) + rret 2 Object : ;

The same fraction of the permission for the All data group is returned from the
method as was passed in.

(As shorthand, I will hereafter adopt some conventions in permission examples.
An omitted fraction on a permission is equivalent to a fraction of 1. A data group--
which always points to null--may have its pointer information elided. Thus, rthis.All
is equivalent to 1rthis.All!0.)

Returning Permissions From Effects
The effects of a method are the permissions that a method needs to operate; they
are returned when the method returns. In some cases, the return value may be
annotated as having acquired permissions "from" some of the method effects. When
this happens the permissions are actually carved out from the effects, and thus the
method effects are not returned until the return value is no longer needed.

48
The ListIterator in Figure 1.4 borrows permission to read the List from the
read effect on the iterator method. The method returns (among other things) a
linear implication showing that permission to the Iterator has been carved out of
the permission representing the effect. The method annotation for Iterator is

8z; zrthis.All!0 + cooked (rthis) + rthis 2 List -! 9;;

rret.All!0 + cooked (rthis) + rthis 2 ListIterator+

(rret.All!0-+zrthis.All!0 + cooked (rthis) + rthis 2 List + v)

The v represents the "rest" of the iterator, beyond what it borrowed from the List.
We can statically infer when to restore the permission to the list, but doing so consumes the iterator permission, rendering the iterator useless [BRZ07].

The annotation borrowed represents a pointer with no permissions associated
with the location to which it refers. Thus, this location is not existentially quantified. Borrowed annotations are placed on method parameters, receivers, and returns;
any permission for the referred-to object will be passed separately using the method
effects.

2.5 A simple language
Figure 2.8 describes a simple object-oriented language with several pointer annotations. However, we do not actually check permissions in this language. Instead, as

49
D ::= class C<pa x>extends C0 {F K M } class definition
F ::= field declaration:

t f [in G];
group G [in G0];

K ::= fx C(t x) {super(e);e;} constructor definition
M ::= fx t m(t x) a {return e;} method definition
fx ::= writes g reads g effects
g ::= e.f target

shared \Delta = null.Owned
t ::= a C annotated type

a ::= ra na pa annotations

pa ::= pointer annotations:

unique | shared
borrowed
readonly | unique-write
immutable
owner | readonly-owner (this or ownership parameter)
from(e) | readonly-from(e) (only on return types)na ::= nullity modifier:

nonnull
maybenull
ra ::= raw modifier:

cooked invariant fully established
raw[C] invariant through C

raw \Delta = raw[Object]
e ::= terms:

x variable
null null location
e;e sequencing
e==e ? e : e conditional
e instanceof C ? e : e instanceof
let x=e in e local
e.f field read
e.f =e field write
(C)e downcast
new C allocation
e.m(e) method dispatch
e.C#m(e) method call
new C<x>(e) \Delta = new C.C#C(x,e)

super.m(e) \Delta = this.C0#m(e)

Figure 2.8: High-Level Syntax.

50
noted above, we provide permission annotations for each method, and define a predicate for each class. The type system in Figures 2.9 and 2.10 uses these, and ignores
the high-level annotations.

2.5.1 Type System
Figures 2.9 and 2.10 shows the formal type rules used for permission-checking programs in our simple language. We include brief explanations of some of the lessobvious rules.

For If, after evaluating e1 and e2 respectively, the type system makes the equality
or inequality being tested available in the corresponding branch. At the end of it, we
create a fresh pointer variable r to be the type for the result. The output environment
will have r equal to different actual types depending on the result of the condition.
We use conditional permissions to come up with a single output permission. This
permission may need to be simplified/restructured by Trans (q.v.) before it can be
useful. The rule IfInstanceof is similar.

The Cast rule checks that the reference has the correct type before permitting
the cast; if necessary, the programmer will have to insert an explicit instanceof
check around the cast.

For Read, we require that at least we should have partial permission to access
the field of an object, which will be represented as ,ae.f !aef . But for Write, we
require the whole permission ae1.f !aef for the field that will be updated.

In Dispatch, when we try to type check a method invocation, we don't know
which method will be picked until figuring out the type for the receiver. The type
rule will pick some type that the system knows for the receiver and check using that.
For most precision, one would pick the "best" static type, but safety requires only a
possible type. The rule for methods checks overriding to ensure that picking a less

51
Variable

rx 2 \Delta 

\Delta ; \Pi  ` x + rx a \Delta ; \Pi 

ObjLoc
E ` o + o a E

Seq

E ` e1 + ae1 a E0 ` e2 + ae2 a E00

E ` e1; e2 + ae2 a E00

If

E ` e1 + ae1 a E0 ` e2 + ae2 a E00 E00 + ae1 = ae2 ` e3 + ae3 a \Delta 1; \Pi 1

E00 + ~(ae1 = ae2) ` e4 + ae4 a \Delta 2; \Pi 2 r 62 \Delta 1 [ \Delta 2

E ` e1==e2 ? e3:e4 + r a \Delta 1 [ \Delta 2 [ {r} ; ae1 = ae2 ? (\Pi 1 + (r = ae3)) : (\Pi 2 + (r = ae4))

IfInstanceof

E ` e + ae a E0

E0 + ae 2 C ` e1 + ae1 a \Delta 1; \Pi 1 E0 + ~(ae 2 C) ` e2 + ae2 a \Delta 2; \Pi 2

r 62 \Delta 1 [ \Delta 2 \Pi 01 = (\Pi 1 + (r = ae1)) \Pi 02 = (\Pi 2 + (r = ae2))

E ` e instanceof C ? e1:e2 + r a \Delta 1 [ \Delta 2 [ {r} ; ae 2 C ? \Pi 01 : \Pi 02

Local

E ` e1 + ae1 a \Delta 1; \Pi 1 rx /2 \Delta  \Delta 1 [ {rx} ; \Pi 1 + (ae1 = rx) ` e2 + ae2 a \Delta 2; \Pi 2

E ` let x=e1 in e2 + [rx 7! ae1]ae2 a \Delta 2\ {rx} ; [rx 7! ae1]\Pi 2

Cast

E ` e + ae a E0 E0 = (\Delta 0; \Pi 0 + ae 2 C)

E ` (C)e + ae a E0

Read

E ` e + ae a E0 E0 = \Delta 0; \Pi 0 + ,ae.f !aef

E ` e.f + aef a E0

Write

E ` e1 + ae1 a E0 ` e2 + ae2 a E00 E00 = \Delta 00; \Pi 00 + ae1.f !aef

E ` e1.f =e2 + ae2 a \Delta 00; \Pi 00 + ae1.f !ae2

New

r 62 \Delta  \Pi 0 = \Pi  + r 2 C + r.f !0 | f 2 fields(C) + ~(r 2 C0) | C 6_ C0

\Delta ; \Pi  ` new C + r a \Delta  [ {r} ; \Pi 0

Dispatch

E ` e0 + ae0 a E0 E0 = (\Delta ; \Pi 0 + ae0 2 C) E ` e0.C#m(e) + r a E0

E ` e0.m(e) + r a E0

Figure 2.9: Permission Type Rules (Part 1)

52
Trans

E1 ; E2 ` e + ae a E3 ; E4

E1 ` e + ae a E4

Call |

e| = n E ` e0 + ae0 a E0 ` e1 + ae1 a . . . ` en + aen a En

E0 = (\Delta ; \Pi 0 + ae0 2 C) mbody(C, m) = (x, e, (8\Delta 0; \Pi 0 -! 9\Delta 00; \Pi 00))|
x| = n \Delta 000 " \Delta  = ; oe : \Delta 0 ! \Delta  oe00 : \Delta 000 ! \Delta 00 En = \Delta ; \Pi  + oe\Pi 0

\Pi 00 = oe00\Pi 000 8ioe(rxi) = aei oe(rthis) = ae0 r 2 \Delta 000 oe00(r) = rret

E ` e0.C#m(e) + r a \Delta  [ \Delta 000; \Pi  + oe\Pi 000

Method

\Delta 1; \Pi 1 + rthis 2 C ` e + ae a \Delta 0; oe\Pi 2{

rx, rthis} ` \Delta 1 \Delta 0 " \Delta 2 = ; oe : \Delta 2 ! \Delta 0 rret 2 \Delta 2
oe(rret) = ae 8C_C0 mbody(m, C0) = (x0, e0, (8\Delta 01; \Pi 01 -! 9\Delta 02; \Pi 02)) )|

x0| = |x| ^ [x0 7! x]\Pi 01 *; \Pi 1 ^ \Pi 2 *; [x0 7! x]\Pi 02

` 8\Delta 1; \Pi 1 -! 9\Delta 2; \Pi 2 m(x):=e is defined in class C

Figure 2.10: Permission Type Rules (Part 2)
precise type does not subvert the permission type system. Then Dispatch delegates
to Call.

In Call, after we check the type for the receiver, we use it to fetch the procedure type ff = 8\Delta 0; \Pi 0 -! 9\Delta 00; \Pi 00. Once we have checked each actual parameter,
we can form a substitution oe to substitute the procedure variables. The permissions
after evaluating all arguments are split into two parts: one which matches the substituted input permissions oe\Pi 0 and one which contains the remaining permissions. The
latter are combined with the substituted output permissions to create the resulting
environment.

On the other side of the method call boundary, Method type checks the body
of the method in the input environment of the method type, with the additional
fact that the receiver has the type of the class. At the end of the method body,

53
the output permissions must match a substitution of the output environment. In
addition, if the method overrides another method, it should satisfy the standard
covariant/contravariant condition, specified using environment transformation.

2.5.2 Operational Semantics
The operational semantics is given in Figure 2.11 in terms of a small-step evaluation.
Term evaluation is defined by a relation of the form (u, e) ! (u0, e0) where u is a
store which partially maps locations (object address and field name pairs) to other
addresses in memory:

u : (O * F ) * O

The evaluation rules are straightforward. The rules that simply move the evaluation
to a subterm are collected into a single rule E-Common using an evaluation context
T[*]. T[*] shows which subterm will experience evaluation next.

We suppose the (allocated and unallocated) object space is partitioned by class
such that class(o) always gives the precise object type for any object reference o. We
also assume an unlimited supply of objects of any type. Thus the only possible errors
(causing evaluation to get stuck) are

* A failed cast;

* Attempting to access (read or write) non-existing state;

* Calling an undefined method;

* Calling a method with the wrong number of parameters.
The well known error of "dereferencing a null pointer" is subsumed by the error of
accessing non-existent state.

54
T[*] ::= *; e | *==e ? e : e | o==* ? e : e | * instanceof C ? e : e | let x=* in e |*

.f | *.f = e | o.f = * | (C) * | *.m(e) | o.m(o,*,e)

E-Common

(u; e) ! (u0; e0)

(u; T[e]) ! (u0; T[e0])

E-Seq
(u; o;e2) ! (u; e2)

E-IfTrue

o1 = o2

(u; o1==o2?e3:e4) ! (u; e3)

E-IfFalse

o1 6= o2

(u; o1==o2?e3:e4) ! (u; e4)

E-IfInstanofTrue

class(o1) _ C

(u; o1 instanceof C?e2:e3) ! (u; e2)

E-IfInstanofFalse

class(o1) 6_ C

(u; o1 instanceof C?e2:e3) ! (u; e3)

E-Let
(u; let x=o1 in e2) ! (u; [x 7! o1]e2)

E-Read

u(o, f ) = o0

(u; o.f ) ! (u; o0)

E-Write

u(o, f ) = o0 u0 = u[(o1, f ) 7! o2]

(u; o1.f =o2) ! (u0; o2)

E-Cast

class(o) _ C

(u; (C)o) ! (u; o)

E-New 8

f (o, f ) /2 Dom(u)

(u; new C) ! (u[(o, f ) 7! 0 | f 2 fields(C)]; o)

E-Call

mbody(m, class(o0)) = (x, t, ff)

(u; o0.m(o)) ! (u; [rthis 7! o0, x 7! o]e)

Figure 2.11: Operational Semantics.

55
Michael Welch is currently attempting, in separate but closely related work, to
prove, using Twelf [PS], that the above type system is sound with respect to this
operational semantics.

2.6 Semantics of Annotations
Having described how we can define sundry annotations using fractional permissions,
it is worth pausing to examine how well these semantics correspond to our intuitive
notions of the annotations.

The essential property of fractional permissions is that they are linear. There
is exactly one permission for each piece of state (field or data group). Thus, if a
method possesses a full write permission to a field, say by declaring a write effect on
the field, we know that no one else could possibly have any permission to access the
field. The write effect cannot interfere with any other effect. Similarly, possession
of a read permission ensures that, while others may simultaneously read the field
with a separate fraction of the same permission, no one could write the field. Again,
interference is obviated if the permissions type-check. This is enforced in the type
system using the rules for reading and writing fields, and also in passing permissions
corresponding to the effects to each methods.

That permissions represent effects is unsurprising given that they are duals [BR05].
The more interesting question is how they support annotations traditionally associated with heap state, such as uniqueness. However, the underlying intent behind
pointer annotations is to preserve restrictions on accessing state. Thus the traditional model, which does not restrict use of any pointer, instead controls access by
permitting or not permitting the existence of certain references. With permissions,
the locus of control is shifted: all references are allowed, but not all may be used.

56
2.6.1 Permission Semantics of unique
Let us examine what this shift means for unique pointers. The "standard" definition
for a uniqueness is that the unique reference is the only persistent (that is, stored
in the heap) pointer to the object in question. With permissions, the permission for
the unique field encloses the permission for the object. On the surface, these two
definitions are incompatible, but they express nearly the same intuition. We think
of a (non-null) unique pointer as `the only pointer that points to that location in
memory.' A ban on the existence of other pointers accomplishes this intent, but can be
difficult to enforce while allowing flexible usage. Only restricting persistent pointers
alleviates usability constraints, but can somewhat weaken the meaning of uniqueness.
With permissions, we alter the semantics slightly to make a unique pointer `the only
usable pointer that points to that location in memory.' That is, other references
can exist, but (permission for) the unique pointer is required to actually access that
location.

Further, the requirement that effects be returned, combined with the requirement
that all fields be given some annotation, means that in practice, programs that create
persistent aliases will generally fail to type-check when using permissions.

class UniqueDemo{

nonnull unique Object o1;
nonnull unique Object o2;
UniqueDemo(){ o1 = new Object(); o2 = new Object(); }

writes this.o1, this.o2
void bad1(){

o1 = o2;

57
}
}

This violates uniqueness because the object, initially pointed-to by only o1 has two
fields pointing to it after bad1 is called. Here bad1 will fail to type-check because
the linear permission for the Object to which o2 points cannot be attached to both
fields. Even were the effect on o2 a read effect, returning the effects from this method
would require more than 1 permission to the shared object.

The requirement that permissions corresponding to the effects be returned from
the method forces both fields to enclose the (single) permission. That is, the effects
on the method translate into the permission annotation:

8rthis * 0B@ 9r * r

this.o1!r + r.All!0

+9r * rthis.o2!r + r.All!01CA -! 9

rret * 0B@ 9r * r

this.o1!r + r.All!0

+9r * rthis.o2!r + r.All!01CA

(Recall that rret refers to the return value, and is unused in a void function.) Performing the assignment will require us to unpack the first existential to write o1 and
to unpack the second to read o2. Before the assignment, then, the type system should
possess permissions equivalent to

rthis.o1!r1 + r1.All!0 + rthis.o2!r2 + r2.All!0
After the assignment, we get

rthis.o1!r2 + r1.All!0 + rthis.o2!r2 + r2.All!0
From these permissions we can form the existential 9r * rthis.o1!r + r.All!0 or the
existential 9r * rthis.o1!r + r.All!0 but not both, as each requires the single linear

58
permission r2!.All.

(The permissions shown here are somewhat simplified. We ignore for the moment
class information, raw and cooked. Also, the fields are nonnull . Thus, the full
input permission for, say, o1 should be 9r * rthis.o1!r + true ? r.All!0 + cooked (r) +
r 2 Object : ; but this is equivalent--ignoring classes--to the stated permission
9r * rthis.o1!r + r.All!0.)

This example also highlights why most persistent aliases will show up as type
errors. Pointers in the heap are generally fields; fields have some pointer annotation
dictating the disposal of the permission for the pointed-to state. The permission for
state uniquely pointed-to cannot be put anywhere else; if the unique field encloses
the permission, no other annotation can be satisfied using that permission. That is,
wherever o2 is assigned, r2.All!0 cannot be packed up with o2 and also packed with
some other pointer or adopted into some other data group.

2.6.2 A More Detailed Example
Because permissions underlie both uniqueness and effects, they model the interactions
between the two. In the example in Figure 1.3, we saw how a temporarily borrowed
reference could affect a unique field after the object had been handed off. What
does this look like when using permissions? First, the method send would gain
write effects for a and b, while getList writes only a. Once more ignoring class

59
types, we get annotations of

8rthis * 0B@ 9r * r

this.a!r + r 6= 0 ? r.All!0 : ;

+9r * rthis.b!r + r 6= 0 ? r.All!0 : ;1CA -! 9

rret*0

BBBBB@ 9r * rthis.a!r + r 6= 0 ? r.All!0 : ;

+9r * rthis.b!r + r 6= 0 ? r.All!0 : ;

+rret 6= 0 ? rret.All!0 : ;

1CCCC
CA

for send and

8rthis * ` 9r * rthis.a!r + r 6= 0 ? r.All!0 : ; ' -! 9rret*0B

@ 9

r * rthis.a!r + r 6= 0 ? r.All!0 : ;

+rret 6= 0 ? rret.All!0 : ; 1CA

for getList. Then, we can examine what the permission environment looks like when
type-checking send.

Figure 2.12 shows an approximation of the permission typing for the send method.
(As before we ignore class types.) Before each line of code there are two permissions.
The first is the permission that resulted from the previous line of code, while the
second is a transformation of the first into a form that can be used to check the
following line.

Initially we start with the two input permissions, derived from the effects declaration on the method. Immediately, we transform these permissions to unpack that
of a prior to assigning it to the local variable bad. After this assignment, we gain the
additional permission fact that bad refers to the same location as the unpacked field
a.

60
writes a, b
nonnull unique ListItem send(){

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)!

; 0BB@

rthis.a!ra

+ra 6= 0 ? ra.All!0 : ;
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCA

ListItem bad = a;0BB

BBB@

rthis.a!ra
+ra 6= 0 ? ra.All!0 : ;
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CA ; 0BB@

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCA

ListItem t = getList();0B

BBBB@ 9

r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)

+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)
+rt 6= 0 ? rt.All!0 : ;

1CCCC
CA ;

0BBBB
BBBB@

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)
+rt 6= 0 ? rt.All!0 : ;
+0 6= 0 ? 0.All!0 : ;

1CCCC
CCCCA

ListItem ret = new ListItem(t,null);0B

BBBB@ 9

r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)

+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)
+rret.All!0

1CCCC
CA ;

0BBBB
BBBB@

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+rbad = ra
+rthis.b!rb
+rb 6= 0 ? rb.All!0 : ;
+rret.All!0

1CCCC
CCCCA

b = bad.getItem(); // WE CANNOT MAKE THIS CALL--no permission for bad.item0BB

BBBBBB@

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+rbad = ra
+rthis.b!r?
+r? 6= 0 ? r?.All!0 : ;
+rret.All!0

1CCCC
CCCCA ; 0BBBBB@

9r * (rthis.a!r + r 6= 0 ? r.All!0 : ;)
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)
+rret 6= 0 ? rret.All!0 : ;

1CCCC
CA

return ret;
}

Figure 2.12: Approximate Permission Typing of send

61
Next we need to call the method getList. To satisfy the effects declaration on this
method, we must pass it the (existentially packed) permission for the field a. Thus we
immediately transform our permission to re-pack a. (In the original example, this call
was nested as a parameter to the constructor. A separate local variable is used here to
clarify the steps involved, which only change in the naming of the permission variable
used for the temporary return value.) After the call, t is assigned the unique return
value. (In theory, t and the returned value have separate location variable which
happen to be equal; the same variable is used for both for simplicity.)

After this, the temporary unique value and null are sent to the constructor as
unique parameters. Sending null as a maybenull unique value is possible because
the condition of the conditional permission is counterfactual. The constructor call
returns a new item of which we possess the All permission. It is possible to also
receive the fact that the newly created object is not null; however, this fact can be
derived from the possession of the permission--we cannot have the All permission of
null. (We have again conflated the location variable for the returned object with
that of the local variable storing it.)

Then we can unpack the field b in anticipation of assigning it a value. But then
we run into a problem calling the getItem method of bad. This method writes the
item field of its host; the caller must pass it a write permission for this field. We
cannot transform our permission to obtain a write permission for bad.item! Were
a still unpacked, we could carve the permission for ra.item out of the permission
ra.All!0, which suffices as rbad = ra. But it is not unpacked. If we unpack this
permission again, we will not get the same location variable as a may not, and in fact
does not, refer to the same location as before. This highlights the general pattern
for borrowing: a unique pointer may be indiscriminately aliased until some event
requiring its associated permissions, such as passing it as a parameter or closing the

62
existential to pass it as an effect, after which lingering aliases lack all permission to
access the object.

Once we cannot make the method call, we are in some sense done: send does not
type-check. For purposes of explanation, however, we can look at what would have
happened if the call had succeeded. (In practice, the analysis will also continue after
reporting an error, in the hopes of identifying further problems.) The getItem method
returns a unique return value (here named r?) and the nonexistent (and therefore
ignored) permission to write bad.item. The uniqueness of the returned value ensures
we have sufficient permissions to pack the existential permission for b. As we know
rret is non-null, we can transform rret.All!0 to the syntactically appropriate form for
a unique return value. (Here we conflate rret the location stored in the local variable
ret with rret the location of the return value of the method. While in general these
may be separate locations, in this example ret is the returned value.) In this final
form, we can drop the superfluous (once bad leaves scope) equality fact and have
precisely the permissions we need to return from the method.

2.6.3 Effects and Uniqueness
The example in the previous section illustrates how expressing both effects and
uniqueness with linear permissions requires them to interact as desired. This occurs most obviously in the inability to call getItem. The immediate point is that the
type system detects the uniqueness error when it cannot satisfy the effects annotation. The reason it cannot is that a previous effect effectively killed the (utility of
the) borrowed local variable bad. The mere act of checking both effects and uniqueness with permissions naturally expressed the interaction by which effects writing the
unique field kill its aliases.

There is another interaction between effects and uniqueness attempted, if not

63
accomplished, here. To see it, let's look at a `corrected' version of the method:

writes this.a, this.b
unique ListITem send(){

ListItem bad = a;
b = bad.getItem();
ListItem t = getList();
ListITem ret = new ListItem(t,null);
return t;
}

This method uses uniqueness correctly in that it modifies the ListItem in a through
its alias prior to handing it off to the returned ListItem. In this version. the permissions present prior to calling getItem resemble0

BBBBBBB
B@

rthis.a!ra
+ra 6= 0 ? ra.All!0 : ;
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCA

To call getItem, we need permission to write the field bad.item. Where can we get
this permission? Since rbad = ra we can transform the previous permission int0

BBBBBBB
B@

rthis.a!ra
+rbad 6= 0 ? rbad.All!0 : ;
+rbad = ra
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCA

64
Furthermore, once the method call has begun, we can infer that bad is non-null: were
bad null, the call would fail with a NullPointerException before we would need to
pass any permissions. This allows the following transformations:0

BBBBBBB
BBBBB@

rthis.a!ra
+rbad 6= 0 ? rbad.All!0 : ;
+rbad = ra
+rbad 6= 0
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCCCC
CA

;

0BBBB
BBBBBBB
B@

rthis.a!ra
+rbad.All!0
+rbad = ra
+rbad 6= 0
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCCCC
CA

We now have permission for rbad.All, but not rbad.item. However, we know from the
class annotation for the ListItem class (elided here for simplicity, as with all other

65
class information) that 9r * (rbad.item!r + r 6= 0 ? r.All!0 : ;) OE rbad.All. This enables us to carve the permission for bad.item out of the permission for bad.All.0

BBBBBBB
BBBBBBB
BB@

rthis.a!ra
+rbad.All!0
+9r * (rbad.item!r + r 6= 0 ? r.All!0 : ;) OE rbad.All
+rbad = ra
+rbad 6= 0
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCCCC
CCCCCA

;

0BBBB
BBBBBBB
BBBBBBB
BB@

rthis.a!ra
+9r * (rbad.item!r + r 6= 0 ? r.All!0 : ;)
+9r * (rbad.item!r + r 6= 0 ? r.All!0 : ;) -+rbad.All!0
+9r * (rbad.item!r + r 6= 0 ? r.All!0 : ;) OE rbad.All
+rbad = ra
+rbad 6= 0
+9r * (rthis.b!r + r 6= 0 ? r.All!0 : ;)

1CCCC
CCCCCCC
CCCCCCC
CCA

Now we have the necessary permissions to call getItem. The process can be reversed
upon method return.

The above transformations enable us to call a method (getItem) which has a write
effect on bad.item (that is, a.item) from within the send method without declaring a
write effect on a.item on send. Carving permission for bad.item from the permission
a.All corresponds directly with mapping the effects of a uniquely pointed-to object
onto the unique field. Indeed, it works because the permission for a, as a unique
field, encloses the permission for a.All, from which any field permissions may be

66
carved. Thus permissions encompass mapping effects onto unique fields as well as
burying aliases to a unique field after writes detected by effects.

2.6.4 The Null-ness Modifier
The example also highlights the functionality of maybenull . When given a pointer
that may be null, the permissions associated with that pointer's annotation are
conditional on the pointer not being null. In the example, this is the unpacked
permission ra 6= 0 ? ra.All!0 : ;. We can only get the permission ra.All!0 from this
if we can prove that ra 6= 0, as we do not have that permission for the null pointer.

ra 6= 0 ? ra.All!0 : ; 6; ra.All!0
ra 6= 0 ? ra.All!0 : ; + ra 6= 0 ; ra.All!0

(In the previous section our not throwing a NullPointerException when calling a
function `proved' bad was non-null.) However, we can form the conditional permission
from either a null reference or one for which we have the appropriate permission:

ra = 0 ; ra 6= 0 ? ra.All!0 : ;
ra.All!0 ; ra 6= 0 ? ra.All!0 : ;

This is even simpler for nonnull , as \Pi  , true ? \Pi  : ;. Thus we can always get the
associated permission for a nonnull pointer, and only form a nonnull conditional
if we have that permission (which in turn implies that the pointer cannot be null).

67
2.6.5 Ownership
Ownership systems create spheres of control for objects. Other objects may be within
the sphere of their owner and thus may only be accessed by their owner. For example,
a linked list class may be established as the owner of the node objects making up the
list. The purpose of the ownership system is to prevent use of the nodes outside of the
list. Traditional ownership system do this by forbidding persistent references from
outside the objects to those objects it owns.

With permissions we represent ownership slightly differently. As with uniqueness
we permit the existence of references that cross ownership barriers, but limit access
using those references. In particular, owned objects can only be accessed if we have
permission to access their owner. This is slightly weaker than standard ownership
as it still allows access from outside the owner. In particular, owned state may be
borrowed in the same manner as unique state, passing permission to the owner as
an effect. As with unique state, kept references to owned state will become useless
once the effect is returned, making ownership using permissions the same as standard
ownership in practice.

2.6.6 Fractions
Fractions are used to distinguish reads and writes. Writing a field requires the entire
base permission for that field. Reading a field only requires some fraction. The primary advantage of using fractional permissions to distinguish reads and writes is that,
after one splits the write permission into several read permissions (allowing read-read
parallelism), one can combine them again to recreate the original write permission, as
long as one can account for all fractions. Having the whole permission for the write
ensures that writing the field cannot interfere with any other access, as no other access

68
class EZ{

nonnull unique Object f;

EZ(nonnull unique Object x){

f = x;
}

writes f
void foo(nonnull unique Object x){

bar();
f = x;
}

reads f
void bar(){

System.out.println(f);
}
}

Figure 2.13: A Simple Example Using Fractions
is permitted. Previous systems, such as the calculus of capabilities [CWM], allowed
the distribution of a write permission into several reads, but had no way to recover
the original write permission once it was divided.

The foo method in Figure 2.13 demonstrates this use of fractional permissions.
The annotation for foo (again simplified to ignore class types) is

8rthis, rx; 9r * (rthis.f !r + r.All!0) + rx.All!0 -! 9; 9r * (rthis.f !r + r.All!0)
while that of bar is

8rthis, z; z9r * (rthis.f !r + r.All!0) -! 9; z9r * (rthis.f !r + r.All!0) .
(On the right-hand side of both procedure types, there is an 9; after the arrow; this

69
represents the empty list of existentially-quantified permission and variables used in
the method. It may be omitted for brevity.) Therefore when permission-checking
foo, we start with the permission

9r * (rthis.f !r + r.All!0) + rx.All!0
and, to call bar at the first statement, transform it into

1
2 9r * (rthis.f !r + r.All!0) +

1
2 9r * (rthis.f !r + r.All!0) + rx.All!0

One half of the permission for f can then passed to bar as a effect, and subsequently
returned, resulting in the same permission as before the call. The subsequent write
of f requires the entire permission. Fortunately, this transformation is possible; we
can combine the two halves to get

9r * (rthis.f !r + r.All!0) + rx.All!0
and then unpack the existential

rthis.f !rf + rf .All!0 + rx.All!0
We can now perform the assignment, resulting in permissions

rthis.f !rx + rf .All!0 + rx.All!0
These can be existentially repackaged to return at the end of the method, together

70
class Split{

nonnull unique Object o1;
nonnull unique Object o2;

Split(){

o1 = new Object();
o2 = new Object();
}

reads this.All
void test(){

if(o1 == o2){

throw SomeError("Aliased unique values!! Panic!");
}
}

writes this.All
void evil(){

o1 = o2;
test();
o2 = new Object();
}
}

Figure 2.14: A Surprising Use of Fractional Permissions
with an extra permission for rf , which is discarded:

9r * (rthis.f !r + r.All!0) + rf .All!0
Thus the method returns safely. The write permission for f was divided into two read
permissions, then recombined into the write permission again allowing the field to be
written. The recombination was possible because adding 12 + 12 = 1 ensured we had
the entire write permission restored.

71
Sometimes, fractional permissions can result in surprising situations, as in Figure 2.14. Initially, it appears that the test function will never be able to throw its
exception--the two nonnull unique fields could never point to the same object as
that object would not be unique . However, careful examination of the evil method
shows how it could be done. The annotation for test is (approximate modulo class
predicates)

8z, rthis; zrthis.All!0+

(9r * (rthis.o1!r + r.All!0) OE rthis.All^9r * (rthis.o1!r + r.All!0) OE rthis.All)

-! 9; zrthis; rthis.All!0

The annotation for evil is similar:

8rthis; rthis.All!0+

(9r * (rthis.o1!r + r.All!0) OE rthis.All^9r * (rthis.o1!r + r.All!0) OE rthis.All)

-! 9; rthis; rthis.All!0

We now examine the permission-checking of the method evil. Given the initial
permissions from the procedure annotation, we transform them to enable the assignment between the two nested fields. First the field permissions are carved from the
data group, then the existentials are unpacked to allow the assignment to occur.

; 0BBBBB@

rthis.All!0
+9r * (rthis.o1!r + r.All!0) OE rthis.All!0
+9r * (rthis.o2!r + r.All!0) OE rthis.All!0

1CCCC
CA

72
; 0BBBBB@

(9r * (rthis.o1!r + r.All!0) + 9r * (rthis.o2!r + r.All!0)) -+rthis.All!0
+9r * (rthis.o1!r + r.All!0)
+9r * (rthis.o2!r + r.All!0)

1CCCC
CA

;

0BBBB
BBBBBBB
B@

(9r * (rthis.o1!r + r.All!0) + 9r * (rthis.o2!r + r.All!0)) -+rthis.All!0
+rthis.o1!r1
+r1.All!0
+rthis.o1!r2
+r2.All!0

1CCCC
CCCCCCC
CA
After the assignment, the permissions are almost identical, except that both fields are
now referencing the same object. This is legal, but the evil method will not be able to
return when the permissions are in this state, as both cannot be replaced. However,
we can split both the carved-out field permissions and the linear implications to
produce a fraction of the All permission for the receiver. This fraction is sufficient to
call the test method.0B

BBBBBBB
BBBBBBB
B@

0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!0

+rthis.o1!r2
+r1.All!0
+rthis.o1!r2
+r2.All!0

1CCCC
CCCCCCC
CCCCCA

73
;

0BBBB
BBBBBBB
BBBBBBB
BBBBBB@

1
2 0B@0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 0B@0B@ 9r * (r

this.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 rthis.o1!r2 + 12 rthis.o1!r2
+r1.All!0
+ 12 rthis.o1!r2 + 12 rthis.o1!r2
+ 12 r2.All!0 + 12 r2.All!0

1CCCC
CCCCCCC
CCCCCCC
CCCCCCA

;

0BBBB
BBBBBBB
BBBBBBB
BBBBBBB
BBB@

1
2 0B@0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 0B@ 9r * (r

this.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+ 12 rthis.All!0

+r1.All!0
+ 12 rthis.o1!r2 + 12 r2.All!0
+ 12 rthis.o1!r2
+ 12 rthis.o2!r2 + 12 r2.All!0
+ 12 rthis.o2!r2

1CCCC
CCCCCCC
CCCCCCC
CCCCCCC
CCCA

74
;

0BBBB
BBBBBBB
BBBBBBB
BBBBBBB
BBB@

1
2 0B@0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 0B@ 9r * (r

this.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+ 12 rthis.All!0

+r1.All!0
+ 12 9r * (rthis.o1!r + r.All!0)
+ 12 rthis.o1!r2
+ 12 9r * (rthis.o2!r + r.All!0)
+ 12 rthis.o2!r2

1CCCC
CCCCCCC
CCCCCCC
CCCCCCC
CCCA

;

0BBBB
BBBBBBB
BBBBBB@

1
2 0B@0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 rthis.All!0
+r1.All!0
+ 12 rthis.o1!r2
+ 12 rthis.o2!r2

1CCCC
CCCCCCC
CCCCCCA

75
Once the fractional permission is returned for the field, this sequence of transformations can be reversed:0B

BBBBBBB
BBBBBBB
BB@

1
2 0B@0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!01CA

+ 12 rthis.All!0
+r1.All!0
+ 12 rthis.o1!r2
+ 12 rthis.o2!r2

1CCCC
CCCCCCC
CCCCCCA

;

0BBBB
BBBBBBB
BBBBB@

0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!0

+rthis.o1!r2
+r1.All!0
+rthis.o2!r2
+r2.All!0

1CCCC
CCCCCCC
CCCCCA

Then, to enable the safe return from the evil method, the two unique fields must
be made to refer to different objects once more. This is done easily by assigning one

76
a newly allocated object.0B

BBBBBBB
BBBBBBB
BBBBB@

0B@ 9

r * (rthis.o1!r + r.All!0)

+9r * (rthis.o2!r + r.All!0)1CA -

+rthis.All!0

+rthis.o1!r2
+r1.All!0
+rthis.o2!rnew
+rnew.All!0
+r2.All!0

1CCCC
CCCCCCC
CCCCCCC
CCA

It is now possible to re-pack the existential permissions, replace them where they had
been carved from, and return with no errors.

77
Chapter 3
Design of Approximating Analysis
The previous chapter explains how we can rewrite pointer annotations in terms of
permissions and statically type-check the resulting permission annotations such that
errors in checking the permissions correspond directly to disagreement between the
stated design intent from the code annotations and the actual behavior of the program. Unfortunately, the type system provided relies on the purely semantic rule
for transformation, which allows any safe transformation without providing an algorithm for selecting the transformations actually needed. Any implemented analysis
will therefore need an algorithmic transformation operation.

In this chapter, rules describing one such algorithmic type system are described.
These rules form an intermediate system, caught between the formal semantics of
permissions and the actual implemented behavior of the control-flow analysis checking
permissions. The latter is described in Chapter 4.

78
ATR-Direct

U ; \Gamma ; \Pi 0 AE\Pi  h\Pi 1 | \Gamma 0; \Pi 2i

h\Pi 1 | \Gamma 0; \Pi 2i o/\Pi  U ; \Gamma ; \Pi 0

ATR-Carve

U ; \Gamma 0; \Pi  AE,k!ae h,0k!ae0 | \Gamma 00; \Pi 0i ,0 < ,8

k0 * \Gamma  |= ,1k!ae0 OE k0 h,2k0!ae2 | \Gamma 0; \Pi 1i o/k0!ae1 U ; \Gamma ; \Pi  ,0 + (,1,2) >= ,

h,k!ae0 | \Gamma 00; \Pi 1 + (, - (,0 + ,1,2))k!ae0 + ,2(,1k!ae0-+k0!ae0)i o/,k!ae U ; \Gamma ; \Pi 

ATR-Carve-Existential

U ; \Gamma 0; \Pi  AE,k!ae h,0k!ae0 | \Gamma 00; \Pi 0i ,0 < , 8k0 * \Gamma  |= 9r * k!ae0 + \Gamma 2; \Pi 2 OE k0h

,2k0!ae2 | \Gamma 0; \Pi 1i o/k0!ae1 U ; \Gamma ; \Pi  ,0 + (,2) >= ,

h,k!ae0 | \Gamma 00; \Pi 1 + (, - (,0 + ,2))k!ae0 + ,2(k!ae0-+k0!ae0) + \Pi 2i o/,k!ae U ; \Gamma ; \Pi 

Figure 3.1: Algorithmic Type Rules for Carving
3.1 Algorithmic Transformation
Algorithmic transformation of permissions uses several forms of one simple relation.
In the relation U ; \Gamma ; \Pi 1 AE\Pi  h\Pi 0 | \Gamma 0; \Pi 2i, we are attempting to produce the permission
\Pi  from the permission \Pi 1, given facts \Gamma . Two permissions are "returned" as results
(of the transformation); the \Pi 0 is our current best approximation of the requested
permission while \Gamma 0; \Pi 2 contains the facts known after searching for the requested
permission and the permissions unrelated to the requested permission. The set U is
explained below.

The analysis proceeds over several layers. The outermost layer is presented in
Figure 3.1. It uses the relation AlgF rom\Pi U ; \Gamma ; \Pi 1h\Pi 0 | \Gamma 0; \Pi 2i. The reversed order is used to distinguish operations on this level from those on other levels. Here
we attempt to find a permission first by running the algorithm from the next layer
(Figure 3.2), as shown in the rule ATR-Direct. If the permission cannot be obtained in this manner, we see if it has been nested--whereupon it could be carved

79
ATR-Fact

\Gamma  |= \Gamma 0

U ; \Gamma ; \Pi  AE\Gamma 0 h; | \Gamma ; \Pi i

ATR-Adopt

\Gamma  6|= \Pi 1 OE \Pi 2 U ; \Gamma ; \Pi  AE\Pi 1 h\Pi 1 | \Gamma 0; \Pi 0i

U ; \Gamma ; \Pi  AE\Pi 1OE\Pi 2 h; | \Gamma 0^\Pi 1 OE \Pi 2; \Pi 0i

ATR-Nothing

U ; \Gamma ; \Pi  AE; h; | \Gamma ; \Pi i

ATR-Base-ND

U ; h\Gamma ; \Pi  | \Pi i AEk!ae h,k!ae | \Gamma 0; \Pi 0i; S h,0k!ae | \Gamma 00; \Pi 00i 2 S [ {h,k!ae | \Gamma 0; \Pi 0i}

where ,0 = max({,1 | h,1k!ae | \Gamma 00; \Pi 00i 2 S [ {h,k!ae | \Gamma 0; \Pi 0i}})

U ; \Gamma ; \Pi  AEk!ae h,0k!ae | \Gamma 00; \Pi 00i

ATR-Plus

U ; \Gamma ; \Pi  AE\Pi 1 h\Pi 1 | \Gamma 0; \Pi 0i U ; \Gamma ; \Pi 0 AE\Pi 2 h\Pi 2 | \Gamma 00; \Pi 00i

U ; \Gamma ; \Pi  AE\Pi 1+\Pi 2 h\Pi 1 + \Pi 2 | \Gamma 00; \Pi 00i

ATR-IfThen

U ; \Gamma ^\Gamma 0; \Pi  AE\Pi 1 h\Pi 1 | \Gamma 1; \Pi 01i U ; \Gamma ^~\Gamma 0; \Pi  AE\Pi 2 h\Pi 2 | \Gamma 2; \Pi 02i

U ; \Gamma ; \Pi  AE\Gamma 0 ? \Pi 1:\Pi 2 h\Gamma 0 ? \Pi 1 : \Pi 2 | \Gamma 0 ? \Gamma 1 : \Gamma 2; \Gamma 0 ? \Pi 01 : \Pi 02i

ATR-Existential

U ; \Gamma ; \Pi  AEk!ae hk!ae0 | \Gamma 2; \Pi 2i

U ; \Gamma 2; \Pi 2 AE[r7!ae0]\Pi 0 h[r 7! ae0]\Pi 0 | \Gamma 2; \Pi 3i \Gamma 3 |= [r 7! ae0]\Gamma 0

U ; \Gamma ; \Pi  AE9r*k!ae+\Gamma 0;\Pi 0 h9r * k!ae + \Gamma 0; \Pi 0 | \Gamma 3; \Pi 3i

ATR-Scale

U ; \Gamma ; \Pi  AE\Pi 1 h,0\Pi 1 | \Gamma 0; \Pi 0i ,0 >= ,

U ; \Gamma ; \Pi  AE,\Pi 1 h,\Pi 1 | \Gamma 0; (,0 - ,)\Pi 1 + \Pi 0i

Figure 3.2: Algorithmic Lookup Rules

80
ATR-Base-Found

\Gamma  |= ae1 = ae2

U ; h\Gamma ; \Pi  | ae2.f !ae0i AEae1.f!ae hae1.f !ae0 | ;i ; ;

ATR-Base-NotEqual

\Gamma  6|= ae1 = ae2

U ; h\Gamma ; \Pi  | ae2.f !ae0i AEae1.f!ae h0ae1.f !ae | ae2.f !ae0i ; ;

ATR-Base-WrongField

U ; h\Gamma ; \Pi  | ae2.g!ae0i AEae1.f!ae h0ae1.f !ae | \Gamma ; ae2.g!ae0i ; ;

ATR-Base-Existential-Match

\Gamma  |= ae1 = ae2 ae0 fresh

U ; h\Gamma ; \Pi  | 9r * ae2.f !r + \Gamma 0; \Pi 0i AEae1.f!ae hae1.f !ae0 | \Gamma ^[r 7! ae0]\Gamma 0; [r 7! ae0]\Pi 0i ; ;

ATR-Base-Existential-NotEqual

\Gamma  6|= ae1 = ae2

U ; h\Gamma ; \Pi  | 9r * ae2.f !r + \Gamma 0; \Pi 0i AEae1.f!ae h0ae1.f !ae | \Gamma ; 9r * ae2.f !r + \Gamma 0; \Pi 0i; ;

ATR-Base-Existential-WrongField

U ; h\Gamma ; \Pi  | 9r * ae2.g!r + \Gamma 0; \Pi 0i AEae1.f!ae h0ae1.f !ae | \Gamma ; 9r * ae2.g!r + \Gamma 0; \Pi 0i; ;

Figure 3.3: Comparing Base Permissions

81
ATR-Base-Empty

U ; h\Gamma ; \Pi  | ;i AEk!ae h0k!ae | \Gamma ; ;i ; ;

ATR-Base-Plus

U ; h\Gamma ; \Pi  | \Pi 1i AEk!ae \Omega ,0k!ae1 | \Gamma 1; \Pi 01ff ; S1 U ; h\Gamma ; \Pi  | \Pi 2i AEk!ae \Omega ,00k!ae2 | \Gamma 2; \Pi 02ff ; S2

U ; h\Gamma ; \Pi  | \Pi 1 + \Pi 2i AEk!ae \Omega (,0 + ,00)k!ae | \Gamma 1^\Gamma 2^ae1 = ae2; \Pi 01 + \Pi 02ff ; S1 [ S2

ATR-Base-Scale

U ; \Omega \Gamma ; \Pi  | \Pi 0ff AEk!ae \Omega ,0k!ae | \Gamma 0; \Pi 00ff ; S

U ; \Omega \Gamma ; \Pi  | ,\Pi 0ff AE,k!ae \Omega ,,0k!ae | \Gamma 0; ,\Pi 00ff ; ,S

ATR-Base-Cond-True\Gamma  |= \Gamma 0

U ; h\Gamma , \Pi  | \Pi 1i AEk!ae \Omega ,0k!ae | \Gamma 00; \Pi 0ff ; S

U ; \Omega \Gamma ; \Pi  | \Gamma 0 ? \Pi 1 : \Pi 2ff AEk!ae \Omega ,0k!ae | \Gamma 00; \Pi 0ff ; S

ATR-Base-Cond-False\Gamma  |= ~\Gamma 0

U ; h\Gamma , \Pi  | \Pi 2i AEk!ae \Omega ,0k!ae | \Gamma 00; \Pi 0ff ; S

U ; \Omega \Gamma ; \Pi  | \Gamma 0 ? \Pi 1 : \Pi 2ff AEk!ae \Omega ,0k!ae | \Gamma 00; \Pi 0ff ; S

ATR-Base-Cond-Unknown-Match\Gamma  6|= \Gamma 0 \Gamma  6|= ~\Gamma 0

U ; h\Gamma , \Pi  | \Pi 2i AEk!ae \Omega ,2k!ae2 | \Gamma 2; \Pi 02ff ; S2

U ; h\Gamma , \Pi  | \Pi 1i AEk!ae \Omega ,1k!ae1 | \Gamma 1; \Pi 01ff ; S1 \Gamma  |= ae1 = ae2

U ; \Omega \Gamma ; \Pi  | \Gamma 0 ? \Pi 1 : \Pi 2ff AEk!ae \Omega min(,1, ,2)k!ae1 | \Gamma 0 ? \Gamma 1 : \Gamma 2; \Gamma 0 ? \Pi 01 : \Pi 02ff ; ;

ATR-Base-Cond-Unknown-NoMatch\Gamma  6|= \Gamma 0 \Gamma  6|= ~\Gamma 0

U ; h\Gamma , \Pi  | \Pi 2i AEk!ae \Omega ,2k!ae2 | \Gamma 2; \Pi 02ff ; S2

U ; h\Gamma , \Pi  | \Pi 1i AEk!ae \Omega ,1k!ae1 | \Gamma 1; \Pi 01ff ; S1 \Gamma  6|= ae1 = ae2

U ; \Omega \Gamma ; \Pi  | \Gamma 0 ? \Pi 1 : \Pi 2ff AEk!ae \Omega 0k!ae0 | \Gamma ; \Gamma 0 ? \Pi 1 : \Pi 2ff ; ;

ATR-Base-Hypothesize-Match

U [ {\Pi 1} ; \Gamma ; \Pi  AE\Pi 1 \Omega \Pi 01 | \Gamma 1; \Pi 0ff; S

\Pi 01 6= 0\Pi 1 U [ {\Pi 1} ; \Omega \Gamma 1; \Pi 0 | \Pi 2ff AEk!ae \Omega ,0k!ae | \Gamma 2; \Pi 02ff ; S0 \Pi 1 62 U

U ; h\Gamma ; \Pi  | \Pi 1-+\Pi 2i AEk!ae h0k!ae | \Gamma ; \Pi 1-+\Pi 2i ; \Phi \Omega ,0k!ae | \Gamma 2\Pi 02ff\Psi  [ S0

ATR-Base-Hypothesize-NoMatch

U [ {\Pi 1} ; \Gamma ; \Pi  AE\Pi 1 \Omega 0\Pi 1 | \Pi 0ff; S \Pi 1 62 U

U ; h\Gamma ; \Pi  | \Pi 1-+\Pi 2i AEk!ae h0k!ae | \Gamma ; \Pi 1-+\Pi 2i ; ;

ATR-Base-HypothesizeAlready\Pi 

1 2 U

U ; h\Gamma ; \Pi  | \Pi 1-+\Pi 2i AEk!ae h0k!ae | \Gamma ; \Pi 1-+\Pi 2i ; ;

Figure 3.4: Finding Base Permissions

82
ATR-Impl-Found

U ; \Gamma ; \Pi 1-+\Pi 2 o\Pi 1-+\Pi 0 h\Pi 1-+\Pi 0 | ;i

ATR-Impl-Plus-Left

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00i

U ; \Gamma ; \Pi  + \Pi 0 o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00 + \Pi 0i

ATR-Impl-Plus-Right

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h; | \Pi i U ; \Gamma ; \Pi 0 o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00i

U ; \Gamma ; \Pi  + \Pi 0 o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi  + \Pi 00i

ATR-Impl-Skip

\Pi  6= \Pi 0 + \Pi 00 \Pi  6= \Pi 1-+\Pi 000

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h; | \Pi i

ATR-Impl-Match

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00i

U ; \Gamma ; \Pi  AE\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00i

ATR-Impl-Match-withCarve

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h\Pi 1-+\Pi 3 | \Pi 00i U ; \Gamma ; \Pi  AE\Pi 3-+\Pi 2 h\Pi 3-+\Pi 2 | \Pi 00i

U ; \Gamma ; \Pi  AE\Pi 1-+\Pi 2 h\Pi 1-+\Pi 2 | \Pi 00i

ATR-Impl-NoMatch

U ; \Gamma ; \Pi  o\Pi 1-+\Pi 2 h; | \Pi 00i

U ; \Gamma ; \Pi  AE\Pi 1-+\Pi 2 h; | \Pi 00i

Figure 3.5: Pass-through rules for linear implications

83
out. The rules ATR-Carve and ATR-Carve-Existential provide for carving
out data groups and field permissions respectively. We assume that only data groups
or field permissions would be carved out, and then only from a data group. These
are the sole nestings required by the annotation system; while the formal semantics
allow for arbitrary nesting, only these will be actually required/useful. These rules
would be non-algorithmic were we to arbitrarily select an adoption. Thus the universal quantification across all adoption facts. In practice, of course, we need only
test adoption facts until we find one that `works,' that is, which gives us sufficient
permission.

The rules in Figure 3.2 describe a recursion on the structure of the requested
permission. Rather than attempt to immediately find a compound permission, we
find low-level components (generally base permissions) and assemble the compound.
Thus ATR-Plus searches separately for the two permissions being combined and
returns the joint permission. ATR-IfThen attempts to find both branches (true and
false) and forms the appropriate permission. The rule ATR-Existential returns
an existential if it can find the instantiated permissions, while ATR-Scale searches
for at least the required permission, then trims it to fit.

The other three rules deal with what to do after recursing to a permission which
is not compound. For facts, ATR-Fact `finds' and returns the fact if it can be
proven from the facts currently known. Additionally, ATR-Adopt allows spontaneous adoption, provided the adopted permission may be found. An empty permission is trivially located. The interesting case is the base permission; to find a base
permission we switch over to the rules in Figure 3.4.

To search a base permission (k!ae), we recurse on the structure of the permission
we are searching for the requested permission. The relation, from Figure 3.4, is
somewhat different; it is now written: U ; h\Gamma ; \Pi  | \Pi 1i AEk!ae h,k!ae0 | \Gamma 0; \Pi 2i Most

84
parts of the relation have the same meaning as before; the change of the first part
of the returned permission to ,k!ae0 follows as only a (fraction of a) base permission
serves as an approximation to a base permission. The value of the reference and the
returned fraction are approximate because we do not know where the field points
prior to finding the appropriate permission. Thus, the requested permission points
to a free location variable.

The major additions to the relation itself when searching a base permission are
the set S which is also returned, and splitting the permission being searched into two
parts (h\Gamma ; \Pi  | \Pi 1i). The first part is a preserved copy of the original permission being
searched; the second is the actual permission to which we have currently recursed.
Both these changes and the set U are used to handle linear modus ponens. The idea
is that rather than guess (spontaneously or heuristically or what-have-you) whether
we need to apply linear modus ponens to get the permission we seek, we try to
find the permission both ways; finding the antecedent from the full permission and
storing the result in our set S of possible output pairs. Each element in S is then
the result of applying some particular combination of linear implications. If two such
implications have mutually exclusive antecedents (for example, both require the same
permission with fraction 1), they are tried in parallel as separate elements of S. The
set U meanwhile tracks which antecedents we have already found, to prevent infinite
regress.

Most of the rules are straightforward recursion on the structure of the searched
permission. The first three rules form the base case of the recursion, testing a base
permission to see if it is a match (ATR-Base-Found) or if it has the wrong key.
The keys won't match if it is a different host object (ATR-Base-NotEqual) or
a different field (ATR-Base-WrongField). As with base permissions, existential permissions break down into three cases: the enclosed permission matches the

85
permission we are searching for, and we instantiate the existential to get it (ATRBase-Existential-Match), the enclosed permission does not match because it
has the wrong field name (ATR-Base-Existential-WrongField), or it does not
match because the host object is different (ATR-Base-Existential-NotEqual).
We need not search the additional permissions enclosed in the existential with the
base permission; the only permissions inside will be relative to the existential variable
and so cannot match the permission we are trying to find. In the event that we are
trying to access fields of the object pointed-to in the existential, the existential will
already be unpacked to access the object itself, as the receiver.

Recursing to the empty permission (ATR-Base-Empty) results in no permission being returned. The rules ATR-Base-Plus and ATR-Base-Scale recursively
search over permission combination and permission scaling, respectively. Conditional
permissions can easily be recursed into if we can determine whether the conditional
is true (ATR-Base-Cond-True or ATR-Base-Cond-False). If we cannot determine the truth of the precondition (ATR-Base-Cond-Unknown), we can in theory
derive the maximum permission that is on both sides; a empty permission will always
be safe. (In practice when conditionals are created, any permission that could be on
both sides is kept aside initially. Thus the empty permission suffices.)

The ATR-Base-Hypothesize- rules handle linear modus ponens for linear implications. If it is possible to use the full set of permissions to derive the antecedent of
a linear implication, the rule ATR-Base-Hypothesize-Match performs the modus
ponens and stores the result of this operation separately, in the set S, while adding
nothing to the current result. This operation is skipped if the antecedent cannot be
found (ATR-Base-Hypothesize-NoMatch) or if we have already tested filling it
(ATR-Base-HypothesizeAlready). The list of already hypothesized linear implications is tracked using U . All possible combinations of filled linear implications

86
will be tried; and ultimately stored in S--except the case of not filling any, which will
be the "normal" return value. Unfortunately, this approach leads to a minor moment
of non-algorithmic tension when selecting which of several valid possible outputs to
use in ATR-Base. Any actual selection mechanism is allowable here as long as it
maximizes the fraction of the sought-after base permission. For simplicity, we will
select the first occurrence of the maximum output fraction using some arbitrary ordering of the set (as with, say, a Java iterator). (In practice this corresponds to testing
combinations of implications until one reveals sufficient permission. The choice often
will be simpler yet because the consequent of most linear implications either leads
to the sought permission entirely or not at all. Thus, only filling that particular
implication is sufficient.)

When no permission is returned, it is represented an the base permission with
a fraction of 0. This vastly simplifies the rules combining fractional parts of the
returned permission, but requires extending the definition of fractions to include 0
and syntactic polynomials.

, ::= fraction:

q literal (0 < q <= 1)
z fraction variable
0 no permission
, + , sum
, * , product

These polynomial fractions are used here in the formal rules but not in the actual
implementation. Section 3.2 discusses how we approximate them using abstract fractions. We also alter permission syntax by extracting all facts that are in the permission and keeping them separately, as the pair \Gamma ; \Pi  instead of embedding the \Gamma  in the

87
permission. This is purely a move toward economy; this extraction could as easily be
accomplished on demand.

Permissions constructed with a linear implication form a special case. The only
time a permission including a linear implication will be demanded is when attempting
to match a from annotation. In other cases, implications may be created as byproducts of carving, but not as part of the permission actively being sought. Even with
from , the permission being carved is also explicitly demanded; searching for this first
may also produce the implication as a byproduct. However, in some cases, the linear
implication in the from does not correspond to a by-the-numbers adoption and carve.
Here, we can be smarter in choosing which permissions to demand, and perform a
`safe' transformation into the form required by the from offstage; that is, as part of
checking the from , rather than part of the transformation rules.

However, the carving occasionally predates the from . This happens often when
the carved item is being passed through from another function. (A common example
is an object returning an iterator over an owned container as an iterator over the
owner.) Here, then, we need rules to find a linear implication which already exists
within our known permission. This is provided for using the rules in Figure 3.5. The
rule ATR-Impl-Found represents finding a matching antecedent, where matching
implies that the same permission has been carved from it. The two ATR-ImplPlus- rules perform a short-circuited evaluation across combining operators. Any
other permission is ignored, as indicated in the rule ATR-Impl-Skip. In the end,
the `returned' permission must meet one of three cases.

1. No implication is found (ATR-Impl-NoMatch). Then, the empty permission

is returned.

2. The exact implication is found (ATR-Impl-Match). This permission is then

88
returned.
3. A implication in which the same permission has been carved from somewhere

else is found (ATR-Impl-Match-withCarve). Here, we assume the permission is carved indirectly; this corresponds to the case described above, where
we return an iterator to an owned list as our own. Permission for the iterator
is carved from the list, permission for the list is carved from an effect on the
owner. Upon finding the linear implication carving the iterator from the list,
we can seek out the permission carving the list from its owner, and eventually
combine them. This will fail if the extra carving occurs for other reasons.

Here, though, we are treating linear implications as a unit; no rule exists that performs
a carving solely to produce the appropriate implication.

3.1.1 Soundness
The algorithmic type rules are sound with respect to transformation. That is, they
will produce no permission which could not also be produced by transformation. We
can see this if we look at each rule using some particular fractional heap: at no point
does a rule `return' permissions that are incompatible with a heap with which the
searched permission is compatible.

Lemma 3.1.1 Suppose we have permissions \Pi  and \Pi 0, facts \Gamma , memory u, fractional
heap h <= u, obligations \Psi , nesting assumptions N (\Gamma  |= N ) and a substitution oe such
that h; \Psi  |=;N oe(\Pi  + \Gamma ). Then, if

* h\Pi 1 | \Gamma 0; \Pi 2i o/\Pi 0 U ; \Gamma ; \Pi ,

* U ; \Gamma ; \Pi  AE\Pi 0 h\Pi 1 | \Gamma 0; \Pi 2i,

* U ; h\Gamma ; \Pi  | \Pi 00i AE\Pi 0 h\Pi 1 | \Gamma 0; \Pi 2i ; S (where \Gamma  + \Pi  ; \Pi 00), or

89

* U ; \Gamma ; \Pi  o\Pi 0 h\Pi 1 | \Gamma 0; \Pi 2i
there exist h0 <= h and oe0 ' oe such that h0; \Psi  |=;N oe0(\Pi 1 + \Pi 2 + \Gamma ).

Proof Straightforward structural induction. 2

Once each rule maintains compatibility within an individual heap, it is relatively
straightforward to extend compatibility across all possible heaps (and thus transformation in general).

Theorem 3.1.2 Suppose we have permissions \Pi  and \Pi 0 and facts \Gamma ; then, if there
exist permissions \Pi 1, \Pi 2, and facts \Gamma 0 such that h\Pi 1 | \Gamma 0; \Pi 2i o/\Pi 0 ;; \Gamma ; \Pi ,

1. \Pi  + \Gamma  ; \Pi 1 + \Pi 2 + \Gamma 0, and
2. 9oe such that \Pi 1 = oe(\Pi 0).

Proof The first conclusion follows immediately from Lemma 3.1.1. The second
follows from straightforward structural induction. 2

The second point is merely an assurance that the demand mechanics work as advertised; searching for a particular permission will return a similar permission (or
nothing).

3.1.2 Completeness
This algorithm for permission type checking is not complete. Figure 2.14 lists a
simple counterexample to its completeness; the method evil can be type-checked
using standard typing (as described in Section 2.6.6), but cannot be checked using
the algorithmic rules provided in this section. The key difference is that the algorithm

90
here attempts to fill the carved-out permissions for the linear implication and only
then split off the fractional read permission for the call to test. Successful permissionchecking of the method requires using identical fractional splits for both the linear
implications and existential permissions needed as their antecedents.

In practice, however, this particular form of example is not common. As indicated
in Chapter 5, for most common programming idioms using these annotations, the
direct approach embodied in these algorithmic type rules suffices. This follows largely
because the permissions generated by annotations are highly restricted in form. The
transformations needed for checking them likewise tend to form a fairly restricted
set. The algorithmic type rules presented here were selected in part because they
encompass the vast majority of the transformations necessary, for all that a few
rare corner cases remain. When testing the analysis implementation, we found no
examples in which the incompleteness was a factor.

3.2 Abstracting Fractions
How often do we need the exact value of a fraction? When checking for read permission, the exact value does not matter, just that it is non-zero. When passing a
permission for a read effect on a method, the exact value passed does not matter.
When returning a permission from a method, the exact value matters only in as far
as whether it is the same fraction as was passed in for the effect; what the numerical
value of the fraction is is immaterial. Thus the only place where the numerical value
of fractions is central is when forming those annotations which mention an explicit
number.

Figure 3.6 defines an abstract representation for fractions. Figures 3.7 and 3.8
describe the connection between fraction polynomials and these abstract fractions.

91
\Xi  ::= abstract fraction:

0 no permission
s smaller read
r read
w write
E error

Figure 3.6: Syntax of Abstract Fractions
The abstraction is reasonable because we generally do not need exact fraction values.
Thus, it is enough to know that we have some read permission--the precise fraction is
immaterial. This in some ways resembles the handling of read and write capabilities
in the calculus of capabilities [CWM].

A major addition to that theory, however, is the inclusion of the smaller permission. "Smaller" read are required to help abstract our ability to split permissions;
they can best be understood in relation to ordinary read permissions. The primary
genesis is from effects. With effects, we care that the same fraction is returned from
a method as was passed into the method initially. A "read" abstract fraction means
that the fraction is of exactly the value passed into the method (or carved out of a
permission that was actually passed in). A "smaller" abstract fraction indicates that
there still is some read permission, but not as much as was initially passed in.

The fraction passed in will differ on exit only when it is split somewhere in the
method. Checking use when accessing fields would never require us to actually split
a permission. This has no effect on permissions passed as effects to method calls
because we know that the returned effect will be the same; thus we can split off the
fraction, pass it to the method, return it from the method, and add it back together
offstage. As long as we can infer when it is possible to safely perform these operations,
we do not need to actually carry them out.

92
q < 1

q . r

q = 1

q . w z . r 0 . 0

,1 . \Xi 1 ,2 . \Xi 2

,1 + ,2 . \Xi 1 ^+\Xi 2

,1 . \Xi 1 ,2 . \Xi 2

,1 * ,2 . \Xi 1 ^*\Xi 2

Figure 3.7: Rules for Abstracting Fractions
A read (or write) permission is noticeably split when it is passed into a method
and not returned. Given that the permissions passed into and out of a method call
are determined by the annotations on the method, we can identify the cases where
this occurs.

1. An actual parameter is passed as immutable which had not previously been

immutable. This forces the permanent adoption of a fraction of the permission into the Immutable data group. It is now impossible to return the same
fractional permission for the effect. This may still type check if the permission
for the field mentioned in the effect is restored by some other means (say by
assigning a null value or a different object).

2. An actual parameter is passed as read-only or unique-write, which was not

previously read-only. This is essentially the same case as before, only involving
a different data group.

3. The return value is readonly-from a passed-in effect. In this case, we can

split the read effect, as before. Here, after it is returned from the method, it
cannot be immediately merged again, because some other permission has been
carved out of it. While this carving endures, we cannot restore the original read
permission.

In each of these cases we now have a smaller permission than previously, and mark
this with the smaller read abstract fraction.

93
^+ 0 s r w E
0 0 s r w E

s s s r E E
r r r r E E
w w E E E E
E E E E E E

^* 0 s r w E
0 0 0 0 0 0
s 0 s s s E
r 0 s s r E
w 0 s r w E
E 0 E E E E

Figure 3.8: Adding and Scaling Abstract Fractions

3.2.1 Lack of Recovery
Using abstract fractions in place of actual fraction values simplifies permission analysis
immensely, as one can now analyze a method without mathematical computations.
(Using full fractions with the particular algorithmic analysis detailed above is even
more problematic as it entails symbolically solving polynomials over Q.) However,
they represent a step backwards in representational power.

The major advantage given by using fractions to represent read (vs. write) permissions is that the sole write permission can be divided into several read permissions,
which can merged back into the write permission as long as all are present. We cannot
do this directly using the abstract fractions. While it is still safe to divide an abstract
write permission into any number of abstract read permissions, no number of abstract
read permissions can ever be combined to get the abstract write back. Permission
accounting fails when no one keeps the books in sufficient detail.

The inability to re-combine read permissions to restore the write permission does
not destroy the ability to analyze programs featuring annotations with permission
semantics. This is partially true because the vast majority of the time, splitting a
fraction occurs either in a situation, such as passing a fraction of a field permission
as an effect, in which the permission can be restored `immediately' and always (the
effect always returns the same fraction), or in situations, such as passing a permission
into, but not out of a function, where the permission will never be made whole

94
regardless. In the first case, where we `know' the fractions will add up, we can
perform the addition without checking the math. In the second case, the exact
fraction is immaterial: it is only necessary to enable the restoration of the original
write permission. If we are not restoring the original write permission, we need not
know the exact fraction.

The problematic cases, then, are those where a permission is split for a noticeable
duration (several statements in the program), and then restored. One such example
is a readonly-from iterator. Suppose we have a List class with the method

reads this.All
readonly-from( this.All) Iterator iterator();

This method has (highly approximated) permission annotation

8rthis, z; zrthis.All!0 -! 9rret; rret.All!0 + rret.All!0-+zrthis.All!0 + v
Thus, if we call it while possessing a full write permission to the list (rlist.All!0),
this permission is split prior to the call, and after the call we have

1
2 rlist.All!0 + riter.All!0 + riter.All!0-+

1
2 rlist.All!0 + v

When the iterator finishes, the linear implication can be satisfied, and the two halves
of the list permission rejoined. However, using abstract fractions, the result is

r rlist.All!0 + riter.All!0 + riter.All!0-+r rlist.All!0 + v
The disadvantage here, of course, is that even after the iterator permission is restored,
the write permission for the list cannot be restored.

95
This particular situation can be resolved, however, by extending the linear implication for the from to handle the permission math. If the resulting permission (after
the call to iterator) is

r rlist.All!0 + riter.All!0 + (riter.All!0 + r rlist.All!0) -+w rlist.All!0 + v
the write permission can again be recreated when the iterator is complete. This
change is easily implemented as an adaptation of the procedure for checking from
annotations. I am unaware of other situations which similarly require fractional parts
of a write permission to be separated for some duration within the same procedure;
any other cases, however, will be amenable to a similar solution.

96
Chapter 4
Implementation Issues
A type checker using the algorithmic transformation rules of the previous section is
not how the permission checker is implemented. The actual implementation is as a
control-flow analysis in the Fluid analysis framework. This necessarily results in both
a different representation for permissions and a different algorithm for checking that
they are used correctly. Some of these differences are due to the requirements of a
flow analysis, some to the particular requirements of both flow analyses and result
reporting imposed within Fluid, and some are idiosyncratic design decisions intended
to simplify the coding and/or execution of the analysis.

4.1 Flow analysis
Following Nielson, Nielson, and Hankin [NNH99b],

a Monotone Framework [for intraprocedural data flow analysis] consists
of:

* a complete lattice, L, that satisfies the Ascending Chain Condition,

and we write t for the least upper bound operator; and

97

* a set F of monotone functions from L to L that contains the identity

function and that is closed under function composition.

In addition, we need a representation of the control flow unit which we are analyzing
(e.g. a Control-Flow Graph), an initial lattice value for analysis entries, and a means
of associating transfer functions with particular transitions in the flow unit (edges in
the CFG).

The infrastructure provided by Fluid simplifies this task; to specify a flow analysis,
one must define the lattice representation and all non-identity transfer functions. The
lattice must be functional: the analysis cannot mutate a lattice object. Methods
are defined to represent transfer functions over a standardized set of control flow
operations representing the Java programming language. (They correspond to lowerlevel operations than the source, generally mimicking stepwise execution.) These may
be overridden to perform non-identity transfer functions; the choice of overridden
method associates the transfer function with the appropriate edges.

4.1.1 Lattice Structure for Permission Analysis
The control flow analysis for permission analysis builds its lattice structure by aggregating several smaller, special-purpose lattices. At the bottom level, there are two
basic lattices; one for locations (location variables) and one for abstract fractions. The
lattice for abstract fractions is a straightforward chain lattice; the lattice features a
finite enumeration of values in a total order

u v w v r v s
where the lattice value u represents 0. The lattice element u functions as the bottom
element of the lattice, while s is ?.

98
The other basic building block of the lattice structure is the SimpleLocation.
These lattice objects represent locations in memory, or sets of locations in memory.
There are three dedicated values: the null location and top and bottom values for
the lattice. Other values can be created for any expression. In practice, this is
used to assign incoming parameters, field values, method returns, and other values
as they `enter' the method under analysis for the first time. Lattice values are also
lazily created when an otherwise undefined join operation is performed. In theory,
this lattice is unbounded; however, for any analyzed method, some finite number of
lattice elements will be created.

One way other lattice structures are built atop these building block is with a map
lattice, which represents an infinite mapping of all possible objects to some lattice.
The join operation is defined as (f t g)(x) = f (x) t g(x). More realistically, we look
at only the sub-lattice where all but a finite number of objects map to either the
top or bottom element of the lattice (but not a mixture of the two). This enables
us to track only `interesting' entries. In particular base permissions are implemented
as mappings; the base permission ,k!ae is represented as entries in two distinct
mappings. The first maps the key to the SimpleLocation representing the pointedto location, the second maps the key to the appropriate abstract fraction. Thus a
pair of map lattices represent the collection of all base permissions.

Similarly, linear implications can be represented as a mapping from the consequent
to the set of all keys for permissions carved from it. Here, the set lattice needs to
be defined with the join operation representing set union. Thus, if a permission is
carved out in only one branch, it remains carved out after joining the branch with
one that did not perform that carving.

One consequence of simulating Java evaluation at a low level is that the transfer
functions need to simulate stack operations. This requires the use of a StackLattice;

99
a lattice comprised of a stack of elements of some other lattice. The join operation
is only defined between stacks of the same height, which join corresponding elements. (In formal theory, joining stacks of unequal height should result in the top
element ? of the StackLattice. In practice, a well-formed analysis will never do
this, so we throw an exception.) The elements of the stack, being evaluated terms,
are SimpleLocations.

The last part of the lattice is the collection of known facts. Facts have three
varieties: that two locations are equal, that two locations are not equal, or that some
key is nested in another key. (In the formal system, the permission type of the nested
key needs to be maintained as part of the nesting fact. This is not necessary here
because the permission type of the field is determined by its static type, and field
binding information is maintained separately by Fluid.) These facts are kept in a set
representing a conjunction. Here the join operation is intersection. This allows for
facts to be lost on merging; thus for an if, the condition can be kept as a fact in the
true branch, its negation as a fact in the false branch, and both are dropped when
the branches join.

However, the lattice is made more complex to allow for greater precision. In
addition to the main conjunction, there is a collection (disjunction) of other sets
(conjunctions) of facts or-ed together. The result resembles V {f } ^ (W {(V {f })}).
This structure enables the maintenance of additional information when joining lattices
together--at the expense of a more complex join function for the full lattice. The
join operation must first examine what happens when the stack and the location map
join; in particular, we note which locations change as a result of the join and use
these to generate two sets of `substitutions,' one for the left hand operand of the join,
and one for the right. These two are added as extra disjunctive equality facts in all
possible cases. For a vastly simplified example, consider a lattice with just a location

100
map and a set of facts:

L1.f!L2 ffi {L1.f OE L1.All} t L1.f!L3 ffi {L1.f OE L1.All}

= L1.f!L4 ffi {L1.f OE L1.All ^ {{L2 = L4} . {L3 = L4}}}

This has the advantage of greater precision as we know that L4 must be either equal to
L3 or L2. we may now, for instance, more accurately answer some aliasing questions.

More than a complicated join function, the downside of this approach is worse
algorithmic efficiency. If we join as follows:

L1.f!L4 ffi {L1.f OE L1.All ^ {{L2 = L4} . {L3 = L4}}} t L1.f!L5 ffi {L1.f OE L1.All}

= L1.f!L6 ffi {L1.f OE L1.All ^ 8?????!?????:

{L2 = L4 ^ L4 = L6}
. {L3 = L4 ^ L4 = L6}
. {L5 = L6}

9?????=
?????;}

we see that the number of disjoined elements will be linear in the number of merges.
After the join, there are as many elements in the disjunction as the on both sides
previously (or possibly one more if there had been none previously.) The size of each
grows relative to the product of the number of join points on the path it represents and
the number of locations that differed at each. In programs with complex control flow,
this can grow somewhat large, which affects how quickly we can test the appropriate
lattice element to see if we have the permissions required for some operation (described
below).

This structure leaves out some of the existing permission forms; notably, we are
missing existential closures and conditional permissions. Existential closures are left
out by design; the transfer functions are set up such that they are considered to be

101
Node n = head;
while(n != null){

// do something with node n
n = n.next;
}

Figure 4.1: Standard loop for linked-lists
open (unpacked) always. When one needs to be closed, say to pass as an effect, the result of the packing and the subsequent unpacking after return are interpreted directly,
without explicitly representing the intermediate form containing the existential.

Most uses of conditional permissions are subsumed by the generalized join operation (that is, \Gamma  ? \Pi 1 : \Pi 2 is imprecisely represented as \Pi 1 t \Pi 2). The exception to this
approach is when forming maybenull closures. Here, we first attempt to prove the
enclosed location is equal to null. If this fails, we attempt to find the appropriate
permissions. This choice is hard-coded into the act of forming the existential; as with
existential permissions, the conditional permission which results is never explicitly
represented.

4.1.2 Loops
One omission in the earlier permission-based type system (Figures 2.92.10) is loops.
Permission-typing loops is non-trivial. Even the simple loop in Figure 4.1 will cause
difficulties for the step-by-step approach. Assuming the head and next pointers are
unique, we will unpack an existential upon each iteration of the loop, with permission
to an additional Node for each. The process does not automatically reach a fixedpoint.

Recursive functions are easier to formalize than loops because they are annotated.
That is, there is an explicit, user-provided statement generalizing the state of the

102
permissions on each recursive call. The equivalent for a loop is the loop invariant--a
predicate which is true on each pass of the loop. In the example, a possible invariant
is to existentially qualify n:

9rn * rn = 0 ? ; : rn.All!0
Each pass of the loop, n will refer to some possibly-null unique node. This is accurate as far as it goes, but will render it impossible to restore the original linked
list. Indeed, we need to both indicate that the list as exists is incomplete (some node
permissions are carved out) and that restoring these existentially-quantified permissions will restore the list. This requires additional permissions to accomplish (here,
rthis.head!rh).

9rn * 0B@ (r

n = 0 ? ; : rn.All!0)

+ ((9r * r = 0 ? ; : r.All!0) -+rh.All!0)1CA

This approach cannot be followed directly in the control-flow analysis as it lacks
both general existential quantification and user-supplied invariants. Existentiallyquantified permissions can be handled with renaming, as previously; for the other,
the analysis must iteratively reach a fixed-point invariant rather than be given it. To
this end, we can rename those variables which are modified in the execution of the
loop as part of the loop merge. In the example, the (partial) analysis state after the
initial assignment of n from head would be

L1.head!L2; 0.n!L2
ffiL1.head : w ; L2.All : w .

103
This makes explicit the separation between the map for locations and permissions
(abstract fractions); each is on its own line (ffi is used as a separator). We also refer
to the local variable n as a field of the null pointer, rather than its own variable. At
the first loop merge, we meet this lattice value with top, which results in the non-top
value. At the end of the loop, we have a different lattice value.

L1.head!L2; 0.n!L3; L2.next!L3
ffiL1.head : w ; L2.All : w (L3.All); L3.All : w
ffiL2 6= 0

The notation L2.All : w (L3.All) indicates that the permission for L3.All was carved
out of that for L2.All. In the next pass the control flow analysis joins the two values
shown previously.

L1.head!L2; 0.n!L2
ffiL1.head : w ; L2.All : w . t

L1.head!L2; 0.n!L3; L2.next!L3
ffiL1.head : w ; L2.All : w (L3.All); L3.All : w
ffiL2 6= 0

=

L1.head!L2; 0.n!L4; L2.next!L3
ffiL1.head : w ; L2.All : w (L3.All); L3.All : w
ffiL4 = L2 . L4 = L3

Because n points to two different values, a new location is generated, which must have
one or the other of these values. The two sets of permissions entering the join are
logically but not syntactically equal; the latter syntax is selected by the join operation
as more precise. The control flow analysis will continue iterating until it reaches a
fixed point. Because this example is so small, the fixed point is quickly reached;

104
indeed, it is the result of the first join operation.

This lattice value corresponds closely with the desired invariant, with L4 filling
the role of rn. This is unsettling in that L4 is treated as a concrete location within the
loop and an existential outside. However, within the control flow analysis, these two
contexts never collide: L4 is used for both the abstract and concrete variables, but
never both at the same time. It is as if the existential variable L4 were always being
unpacked as the location L4. Additionally, the issue has yet to present a problem in
practice.

4.1.3 Drop-sea
Results in Fluid are not reported as simple messages. Rather, to better coordinate
the interactions of diverse assurance results, the results are entered as drops in the
Drop-Sea truth management system. A Drop is a particular piece of information
which can be either true or false. In practice, there are two essential kinds of drops:
promise drops, which record those facts resulting from user annotations (e.g. "This
field is unshared"), and result drops which record those facts arising from assurances
(e.g. "This method preserves the unshared character of that field"). A Sea in DropSea is a collection of Drops, which are implicitly added to the sea when they are
instantiated.

Drops exhibit several relationships. Promise drops support result drops by providing information used to generate that result. More precisely they provide facts to
the analysis which the assurance uses to generate the result drops. Similarly, result
drops support the promise drops they are assuring. Additionally, a drop may depend
on any other drop; this means the fact represented by the former is a consequent of
the fact represented by the latter. Negating the latter will negate the former.

105
Drop-Sea mediates the relations between assurances by making explicit the dependencies between assurances. That is, if one assurance relies on certain promises that
cannot be verified (or worse are provably inconsistent) by a second assurance, this
uncertainty is propagated to the results of the first analysis. By using the Sea as the
primary instrument to display assurance result, these dependencies are explicated for
the user. Drop-Sea adds the burden of connecting assurance results to annotations
used and verified to the assurance itself.

4.1.4 UI for Permission Assurance
The interface for the permission assurance, then can be described in terms of which
promise drops it supports with which result drops. The general assurance mechanism
for the double-checker package ties user-selected assurances to the act of building
a package; that is, building the package will cause the selected assurances to be run
on the package. The assurances are responsible for providing support for the promise
drops in the annotated code. The permission assurance can support the following
types of promises:

* promises that a field will be unshared or that a parameter, receiver or return

value will be unique ,

* promises that a value has been borrowed , and

* promises describing the effects of a method.
Notice that there is no promise that a value is shared ; this owes to shared -ness
being the default assumption for values without annotation. This is handled by
creating promise drops for shared fields/parameters/receivers/return values that are
not associated with any actual annotation, but are tied to the appropriate declaration.
Promises for owned , readonly , immutable and from are not yet supported.

106
The following drops are generated by the analysis to support various annotations.

* Drops representing reading a field that support the effects of the method containing the read. If a read is attempted without finding read permission for
the field, the drop shows up as an error; the effect annotation is not supported.
The corresponding messages are "Read permission for field ?? present"
and "Read permission for field ?? absent," where ?? is the name of the
field.

* Drops representing writing a field; these behave like reads. The possible messages are "Write permission for field ?? present" if the write permission for the field is and "Write permission for field ?? absent if it is
not."

* Drops for passing permissions to called methods as effects; these behave as

the drops for reading or writing in the calling method. The messages are
"Annotated ?? permission for field ?? present" and "Annotated ??
permission for field ?? absent." Here, the first ?? is either read or write,
as appropriate.

* Drops for checking that a value really is unique. These are generated at any

boundary and involve showing that (for maybenull unique) the value is either
null or the appropriate All permission is present. Failure to satisfy one of these
conditions results in an error. The drops support the unique or unshared
promise for the appropriate value. The messages are "?? is unique" and
"Cannot make ?? be unique." Again, the ?? is the field name.

* Drops for checking that a value is shared . These behave as those for unique

107
values, except they support the artificial shared drops, as opposed to drops actually attached to annotations. The messages are "?? is shared" and "Cannot
make ?? be shared."

* Drops that always support borrowed . As borrowed is always correct, each

borrowed annotation is given a (always) correct result drop proclaiming that
fact. The only possible message is that "borrowed requires no assurance."

Next, we discuss how these messages are generated by the control-flow analysis,
first in the general case, and then in ways specific to the permission analysis.

4.2 Integrating CFG-Analysis, Drop-Sea
These drops are generated as part of assuring that the program annotations describe
its behavior accurately. The control-flow analysis merely uses them to decide what
the approximate state of the program is at any given point. For permission analysis,
this involves deciding which, if any, permissions are available, carved out, fractional,
etc. at any given point of execution. This is, to some extent, separate from deciding
whether the permissions which are present indicate that the pointer annotations on
the program are correct. Thus, we need to consider how to generate assurance (that
is, the result drops described above) from the control-flow analysis. In general, there
are several possible approaches to consider.

4.2.1 Post-pass Assurance
One may, of course, separate assurance from analysis. A control-flow analysis can
be run to completion over the code, and then the assurance may make a second
pass, probably as a tree-walk, querying analysis results on appropriate edges. The

108
assurance would be solely responsible for reporting evidence that the program did
or did not meet its specification. There are to my knowledge no assurances in fluid
currently using this approach.

One advantage of such an approach is that it can be easier to frame an analysis
without worrying about resulting assurances. Also, error reporting from tree walks
is simpler; in particular, the CFG analysis will have already iterated to a fixed point
before any assertions are made. However, this requires two separate, yet linked,
code analyses. Coordinating the information gathered with that needed for reporting
results is nontrivial.

4.2.2 Example Revisited
The NonNull analysis/noNPE assurance pair naturally expresses itself as a post-pass
analysis. The CFG analysis can determine a set of local variables which are not null,
and, more generally, a general formula for determining whether an expression is not
null. Then, an assurance can perform a tree walk in which, if it is not currently within
a try block which catches NullPointerExceptions, checks all receiver expressions
against the analysis to see whether they must be non-null. If a receiver outside
such a try could be null, this is reported as a negative assurance for the @noNPE
annotation. That is, first a fixed point of non-nullness information is computed, then
a separate tree walk assures that this information supports the annotation (or not).
This approach seems reasonable for this assurance because the necessary tests for
being in a try that catches NullPointerExceptions are easily integrated into a tree
walker, but add noticeable complexity to the lattice of non-null local variables.

109
4.2.3 Poisoned Lattices
It is tempting to consolidate the analysis of the program and the provision of assurance into one pass over the code by performing assertions while iteratively calculating
analysis results. This runs the risk of generating false results when asserting against
incomplete analysis results. In particular, a premature positive assurance of code
is unsound. The easy way to avoid this is to incorporate the assertion results into
the lattice computation. Only if the final result lattice is "good" will positive assurance be provided. Any assurance failure will lead to an inescapable "bad" state
(a poisoned lattice), resulting in negative assurance. UniqueAnalysis in fluid uses
poisoned lattices.

The advantage of poisoning lattices is that it allows assurance to be performed
concurrently with analysis in a semantically sound manner. Unfortunately, because
assurance is not determined until after iteration is complete, all the final result tells
one is whether the assurance was successful overall or not. If the code does not
assure, the nature of the problem is known, but not exactly where it occurs. In
order to give useful feedback to the user, a separate analysis is needed anyway, to
climb the syntax tree and find the point where the analysis went "bad" to report the
problem to the user with any precision. For UniqueAnalysis, this task is performed
by UniqueAssurance. Additionally, the analysis is only capable of pinpointing one
error per flow path, because once in the bad state, further errors cannot be detected.

4.2.4 Side Effects
These problems would not occur if assertion failures that occurred while analyzing
a flow unit reported results as they occur without altering the analysis lattice. For
convenience, we will assume that analysis results are simple messages (strings) for

110
now. Similarly, good results can be reported from passed assertions. All results, good
and bad, can be cached in a repository for later reporting. The repository can link the
message resulting from the assertion with the node being analyzed when the assertion
is made to provide useful error messages. PermissionAnalysis in fluid attempts to
follow this model; it originally used the AssuranceLogger as its repository.

The problem with a side-effecting analysis, of course, is that side effects (messages)
can be generated when the analysis is in an incomplete state. The AssuranceLogger
is configured as a map from the IRNodes at which assurances are made to the `good' or
`bad' messages resulting from these assurances. This should be sound but is imprecise.
Additionally, it requires that every positive assurance have a dual, negating negative
assurance.

A better approach is to only generate side effect after a fixed point has been
reached, but still from within the analysis. Thus the analysis would consist of two
passes: a work pass which iterates to a fixed point in the lattice, and a rework pass
which revisits each node exactly once. Side effects should only be generated when
rework ing the analysis; after the fixed point is reached. One way to ensure this is to
always generate side-effects, but to attach a big switch to the repository of assurance
results (side effects). The repository only records results when the switch is on.
Analysis results can be compiled by

1. turning the switch off

2. working the analysis to get a fixed point
3. turning the switch on
4. reworking the analysis to get recorded side effects
This procedure is apparently similar to the separate post-pass; however, the assurance results are still being calculated within the analysis, allowing tight coordination.

111
Also, reworking is currently supported by the flow-analysis infrastructure; post-pass
assurances are ad-hoc, based on the particulars of the analysis/assurance.

4.2.5 Control-flow Analysis Asea
How can we connect control-flow analysis results to Drop-Sea? If using a post-pass
assurance, either explicitly or to decipher poison lattice results, the separate treewalking assurance makes the appropriate connections; this is equivalent to generating
results for a tree-walking analysis and is out of the scope of this discussion. Drops are
generated within the control-flow analysis itself only when performing a side-effecting
control-flow analysis.

The obvious design is to use the Sea as the side-effect repository. Side effects show
up as instantiated result Drops instead of posted messages. Because the Sea lacks a
switch to disable reporting until a fixed-point is reached, the switch must be added
separately. A mediator must be placed between the analysis and the Sea to handle
the switching semantics. Drops are not generated within the analysis proper, rather
it directs the mediator to produce drops; the mediator is equipped with a switch
enabling it to only generate effects when reworking.

This approach suffices for generating isolated result drops; however, for the Sea to
be effective, the result drops must be associated with the (drops associated with the)
promises they support and the (drops associated with the) promises they rely on for
information. The former connections are straightforward to make because assertions
are only made, and thus results are only generated, where necessary to support some
promise. The result can be immediately known to support the associated promise.

Determining which promises are used to produce results is trickier because the
connection is non-local. Promise information is given the analysis at method entry
and possibly at other points throughout the control-flow analysis. It is used at points

112
important to the supported promises, which are not in general where the supporting
promise information is found. Fortunately, within a version, and an analysis is always
run within a single version, promises and promise drops are constant. Therefore, the
promise drops used to generate particular pieces of analysis information may be added
to the appropriate lattice values. Merging flows complicate the process; a lattice value
that is the result of a merge may contain information from two possible sources. This
translates to a union lattice of promise drops which support an associated lattice
value.

So what happens at an assertion? The assertion is associated with some promise
which it helps support. The assertion is made against the current state of the CFG
lattice. Some information in the lattice value representing the analysis' approximation
of the execution of the flow unit causes the assertion to (for instance) pass. Both the
supported promise drop and the set of supporting promise drops are passed with a
message to the mediator instructing it to generate the result drop associated with
passing the current assertion.1 If and only if the mediator is set to report (that is, if
the analysis is reworking) it then generates the appropriate result drop and connects
it to the passed-in promise drops for view in the reporting framework.

4.2.6 Example Re-Revisited
Indeed, even the simple analysis/assurance combination in Section 4.2.2 runs into this
problem with non-locality of information source. In Figure 1.1, the @noNPE assurance
can generate a result drop when checking that the receiver of the method call is nonnull (as our NonNull analysis informs us) which supports the @noNPE promise drop.
But what supports our analysis result? The analysis reaches its conclusion because

1In practice, other information needs to be passed in. For example, the IRNode at which the
assertion is made gets passed in so the result drop can accurately report where in the program theresult was generated.

113
@noNPE
void foo(SomeClass x, SomeClass y){

if(x != null && y != null && x.f != null){

y.f = null;
x.f.somefun();
}
}

Figure 4.2: Now with fields!
when control flow follows the true branching from the x != null test, x can be added
to the set of local variables know to be non-null. This can be simulated in Drop-Sea
by adding a (pseudo?) promise drop associated with the node for the test, and using
that drop to source the assurance of the method call. To get the pseudo-promise
drop from the part of the AST where it comes into being as part of the CFG analysis
to where it is used requires the drop be passed along with x in the set of non-null
local variables. This makes the CFG lattice something other than (strictly) a set
of non-null local variables. In practice, some kind of map lattice mapping all local
variables to a set (lattice) of non-null-supporting "promise" drops, with an empty set
representing possible null-ness, will likely be necessary.

Unfortunately the simple NonNull analysis of Section 4.2.2 runs into trouble when
dealing with fields. Consider the code in Figure 4.2. At first, this seems to be a
straightforward extension of the first example. However, if x and y reference the
same location the code will in fact throw a NullPointerException. The code in
Figure 4.2 cannot be assured with the information present in the simple NonNull
analysis.

There appear to be two obvious ways to extend NonNull analysis to include fields.
First, a may-alias analysis could be run, either separately or as part of a more complex non-null analysis, to produce slightly less conservative aliasing results. Using a

114
class SomeClass{

@nonNull SomeClass f;
. . .
@noNPE
void bar(@nonNull SomeClass x, @nonNull SomeClass y){

y.f = null;
x.f.somefun();
}
}

Figure 4.3: Now with @NonNull!
permission analysis as a backbone for a non-null assurance is one example of this.
The other extension is the addition of extra annotations (e.g. @nonNull) on fields
(and parameters and method returns and so on2). This results in something like
Figure 4.3.

In this example, there are three places where the @noNPE tree walker provides
assurance based on analysis results. The first two are on dereferencing fields of the
@nonNull parameters x and y. These will have been added to the set of non-null
locals at method entry, by mapping them promise drops reflecting their annotations.
Similarly, x.f will not generate a NullPointerException when used as a receiver
because the field is annotated as being @nonNull. 3 Because the receiver is not a
local variable, this result comes directly from the field annotation: the inference chain
can be calculated locally.

The addition of a new annotation necessitates the creation of a corresponding
2Indeed, the CFG analysis can be obviated by forcing @nonNull annotations onto local variables
and enforcing a strict doctrine on assignments.

3The @nonNull annotation has differing meanings when applied to parameters and fields. A

@nonNull parameter is not null at method entry; after that its status is determined by analysis, notspecification. A

@nonNull field can never hold a null value after the class constructor has successfullyexecuted.

115
assurance. That is, now that we have @nonNull annotations, we must assure them.
For the code in Figure 4.3 this assurance fails because a @nonNull field is given a
(very possibly) null value. How should this new assurance be accomplished? The tree
walker performing the @noNPE assurance could be extended with additional checks at
field assignments, method invocation and method returns to assure the @nonNull
assurances at these locations. However, this presumes that @nonNull assurance will
solely be conducted in the context of the @noNPE assurance; this assumption is likely
unwarranted.

The combined @nonNull assurance/nonNull analysis can consist of three parts.4
The analysis has two parts: the analysis entry point class and the associated class
of transfer functions. The former contains methods to instantiate and initialize a
new flow analysis for a given flow unit, and to report on the potential null-ness of
a given expression. The transfer functions will both iterate to a fixed point on the
lattice which is mapping from non-null local variables to the promises (and pseudopromises) proving them as such and, as a side-effect, check potential null-ness of field
assignments, method returns and parameters to method calls.5 These checks will
pass the drop for the @nonNull promise being checked, the boolean determination
of whether the annotation has been met, and the set of promise drops supporting
that conclusion6 to the mediator, which will generate appropriate result drops on the
rework pass only. Six different results drops are possible: @nonNull parameters, field
assignments and returns can each be provably non-null or not. The mediator is also
responsible for correctly attaching the drop to the passed in promises and to the node
where the check took place. As a courtesy, the overall non-null checking function in

4Four really, but the lattice can be an off-the-shelf instantiation of the existing
PartialMapLattice class

5This check is against the local lattice value and not in general, as with the superficially similar

check in the main class.

6Expressions which are not local variables must be able to spontaneously locate promises or

generate pseudo-promises locally supporting or denying their non-nullness.

116
the entry point should return false if any @nonNull assurance checks fail.

4.3 Fluid Decisions in Permission Lattice
The permission analysis is implemented as a side-effecting control-flow analysis. All
assurances are generated in the PermissionDropMediator object, which is attached
to the analysis as a whole. Result drops are generated from assertions against the
lattice representing the current state of permissions. A boolean value representing
the success of the assertion is passed to a method generating the appropriate result
drop; the value of the boolean determines whether the drop is positive or negative
feedback; the message is assigned accordingly. It is also the responsibility of the
mediator to only actually create drops when the analysis has reached its fixed point.
Thus, assurance becomes relatively straightforward: for each method or constructor
being checked, reporting is disabled, the analysis iterates to a fixed point, reporting
is activated, and every transition is reworked exactly once, producing the appropriate
drops. The interesting questions are where and how one makes the assertions.

Where assertions are made depend on which assertion is being made. Assertions
for successful reading and writing of fields are made at the uses and assignments
of those fields, respectively. All other checks are made only at the boundaries of
the method--what permissions exist make no difference until someone outside the
method examines them. Thus method calls must make a variety of checks. First,
they require read or write permissions, as appropriate, for their read or write effects;
further, each of those fields (and/or each field nested in the named data groups)
must be checked for its appropriate annotation (currently only unshared and the
implicit shared , but true for other added annotations). Further, any annotations
of unique or shared (implicitly annotated) on parameters or the receiver must be

117
checked. Permission used for unique is removed as it is sent to the method. As the
effects are checked, they must also be removed from the permission set, to avoid using
the same permission twice. For read effects, we reduce the contributing permission
to a smaller permission, enabling read parallelism. After all checks are complete,
the permissions removed to satisfy the effects are restored; excepting that unique
permissions are renamed (given a new location and a new All permission) to simulate
packing and then unpacking the existential closure. The other important locale for
checks is the end of the method body. Here, effects annotations on the method itself
need to be checked, as the effects are returned when the method finishes. Again we
need permission for the effects, their annotations, and the annotations on fields nested
in the effects. (Nesting of fields in data groups will always be of some finite depth.)
In addition, we must check that the annotation on the return value can be satisfied
by the value left atop the execution stack at return.

4.3.1 Assertions and Claims
Checking for required permissions appears trivial, especially in the case of checking a
base permission. We could just look up the key in question in the set of fractions and
see if sufficient permission exists. Unfortunately, this ignores possible effects from
equality facts. That is, the (simplified) permission lattice

{L1.f 7! r }
gives us read permission for the field L1.f, but so does

{L2.f 7! r ffi {L1 = L2}}

118
and, for that matter, so does

{L3.f 7! r ; L4.f 7! w } ffi {L1 = L2 ^ {{L2 = L3} . {L2 = L4}}} .
Searches through the space of equality facts are handled using claims. Basically, a
claim is a unary predicate that can be asserted about some SimpleLocation. In this
case, the claim is that the current set of permissions contains at least read permission
for the f field of the location. (Also necessary is that nothing has been carved from
this field.) This claim is tested first on the required location L1--remember we are
looking for permission to read L1.f . In the first lattice, this test suffices. If that claim
fails (returns false), we generate the set of all locations, from the main conjunction in
the fact lattice, that are equal to L1 ({L1, L2} in the second example) and test them
until one succeeds or all fail. In the second case, the claim would succeed for L2.f and
therefore succeed in general. If the test is still unsuccessful, we test all branches of
the disjunction (together with the standard shared conjunction) and if each succeeds,
the claim succeeds. Thus, for the third example, we would try {L1, L2, L3} (which
succeeds for L3.f ) and {L1, L2, L4}, which succeed because we can write L4.f . As
both branches succeed, there is always sufficient permission to read f .

Nesting complicates things further. The permission lattice

{L3.f 7! r ; L4.g 7! w } ffi {L1 = L2 ^ L4.f OE L4.g ^ {{L2 = L3} . {L2 = L4}}} .
should also succeed. Thus some claims, like those for permissions are permitted
to extend `upward' on nesting facts as well. Here, after the test for the f field of
{L1, L2, L4} fails, it extends to the g field of each of {L1, L2, L3}. and eventually
succeeds.

119
Additional complications ensue because some checks need to remove the permissions. For example, once a permission is used for a check when passing an effect,
we want to remove it from use (or make it smaller for read effects) Thus, the claim
object needs to track which actual keys were used to pass the check, so that they can
be updated as appropriate. Of course, this is unnecessary when checking permission
to read a field locally; thus the two checks have different claims, different assertions,
and even different result drops.

The success of an assertion thus depends on the success of one or more attempts at
its associated claim. Which result drop is generated, in turn, depends on the success
or failure of the assertion. Assertions for uniqueness and shared feature their own
claims, separate from those used for permission reads and writes. The mechanism
is general enough, however, to be usable for other purposes; for example, aliasing
questions can be rephrased as claims.

4.3.2 A Word on Null-ness
Although the formalism allows for, and even requires, modifier for nullness on fields,
there is not (to my knowledge) actual support for nonnull and maybenull promises
in Fluid. This means that we cannot directly oblige the standard handling of nullness.

One solution would be to annotate all references as maybenull by default. This
approach is safe; no reference is given too strong a condition. It becomes untenable
because of a drawback in the design of the lattice: we do not explicitly represent
conditional permissions. As such, we cannot represent permissions conditioned on the
inequality of a reference to null, which is how maybenull permissions are represented.
Representing all fields as nonnull is feasible in the analysis, but unsound--some fields
really are null.

120
The current implementation is an uncomfortable compromise. When a field is
unpacked, it is assumed to be nonnull : all associated facts and permissions are
immediately added. When it is packed, it is treated as maybenull : the value is
tested for null-ness and the associated permissions are only requisitioned if it is nonnull.

It is clear that, absent nonnull annotations, treating fields as maybenull when
packing them is safe. Less clear is whether treating all fields initially as nonnull
is safe. So when is treating a maybenull field as nonnull unsafe? The danger is
in gaining access rights via an included permission when the reference is or could
be null. However, any access rights given to a null reference will only be usable on
fields of that reference: attempts to access them on a null pointer will fail from a
NullPointerException. Passing the permission to another function is acceptable,
as that use is also maybenull . Thus, this approach, while not entirely sound, will
not result in any permission errors, which suffices.

4.3.3 Putting It All Together
What all, exactly, happens when running the analysis? The process follows several
stages, complicated somewhat by design issues touched on herein.

* The PermissionAssurance is the upper-level entry point for the analysis. The

Fluid double-checker works as a builder in Eclipse, so that whenever a project
(for which Fluid assurance is enabled) is built, user-selected assurances are also
run on the project. PermissionAssurance is one such. When given a compilation unit by the infrastructure, PermissionAssurance traverses the abstract
syntax tree until it reaches a unit of control flow, generally a method, constructor, or static initializer. At this point, the assurance creates an instance of the
control-flow analysis and runs it on the method.

121

* The analysis first disables error reporting, then iteratively applies the transfer

functions to find a fixed-point for permission lattice values. The initial lattice is
set based on the effects and other method annotations passed in. Most transfer
functions directly mirror their evaluation functionality using location lattice
objects in the place of references.

* Checks are made against the lattice at function calls, field accesses, and at

function return to see if requisite permissions are present. As error reporting is
off, this may appear fruitless; however, the internal analysis state may be tied
to the results of the checks. For example, passing a unique parameter requires
both finding and removing the associated All permission.

* Most checks involve creating the appropriate Claim object and testing that

claim on several locations, depending on the known facts.

* These facts are sometimes created on object instantiation, establishing its field

nestings; sometimes after a method call, for both the returned value and any
returned effects; and from the control flow itself. For example, conditional
expression will be true or false at the appropriate exit port.

* Once a fixed point is reached, error (and success) reported is enabled, and the

analysis is re-worked; each edge of the control-flow graph is revisited in order.
Because a fixed point has been reached, the lattice values will not change.
However, revisiting them will enable all of the permission checks to be made
again; this time creating drops for the results in Drop-Sea.

* At this point, the analysis is done. The PermissionAssurance continues and

may itself be invoked again on other compilation units. Eventually, when all
assurances have been run on all appropriate compilation units, all drops become

122
available for view. They are structured by the type of annotation being assured,
as a tree, with positive or negative reports about an annotation as children of
that annotation.

The control flow analysis described in this paper uses a limited representation of
permission. The intent is to provide sufficient representation to check annotations
and no more. Not all possible permissions can be directly represented. Similarly,
low-level permission transformation operations, even at the level described by the
algorithmic type rules, are not always practical. Instead, the results of those particular
transformations demanded by joining and/or asserting permissions are interpreted on
the limited lattice representation. The result is an analysis that determines whether
a permission analysis would work rather than immediately applying that permission
analysis itself.

123
Chapter 5
Experimental Evaluation
As permission analysis has been implemented as a control-flow analysis, it is now
both possible and desirable to actually run the analysis on sample code. We can
compare the results with those of the preexisting (separate) analyses for effects and
uniqueness and with our expectation from hand evaluation of the existing permission
formalism. Then, there are two kinds of sample programs on which we should test
the analysis: small examples that are simple enough to type-check by hand using the
formal permission system and large complex systems, preferably consisting of actual
production code. The latter are useful both in presenting the analysis with a wide
range of idioms, not all of which were anticipated by the author and in providing
evidence of the scalability of the analysis.

5.1 Small Examples
A small example consisting of several short functions is useful for evaluation for two
principal reasons. The first is the ability to compute expected results for the analysis
by hand; this permits precise determination of correctness. The second is that with

124
a small enough example we can "open the hood" and look not just at the final but at
the evolving state of the analysis; this ability is vital for debugging. As such there are
two classes of small examples on which the analysis has run: demonstration files to
verify the correctness of the analysis, and isolated functionality from larger examples,
introduced for the purpose of debugging. This discussion will be restricted to the
former.

The first such example predates the creation of the analysis. It is a variation on
the example in Figure 1.3, which is useful for demonstrating both that the analysis
can detect the particular misuse of uniqueness highlighted in that example and that
it can positively assure a simple linked-list implementation. The full text for the
example is in Figure 5.1. Running this example through the analysis leads to all positive assurance with three exceptions: the write of m.next on line 41 cannot happen
because we no longer have permission for the field, and uniqueness produces errors for
n and head at the end because we cannot recreate the existential closures needed for
to return the unique effects. The latter error seems somewhat unnecessary; however,
it cascades from the effect error--commenting out line 38 fixes all problems.

Most of the other smaller examples were added to test specific pieces of functionality as they were implemented. Test cases exist for effects on regions (data groups)
covering the fields inside the groups, proper handling of the array element region,
static fields and methods, and the use of facts to handle aliasing across merges. The
tests on statics field do not behave correctly, because of an annotation error on my
part, but excepting those, all of these small test cases produce their expected results.

125
1 class Node{
2
3 @InRegion("Instance")
4 @Unique Node next;
5
6 Node(){}
7 }
8
9 class List{
10
11 @Unique Node head;
12
13 @RegionEffects("writes head")
14 void mostly_clear(){
15 head.next = null;
16 }
17 @RegionEffects("writes head")
18 void prepend(@Unique Node n){
19 n.next = head;
20 head = n;
21 }
22 }
23
24 public class BB {
25
26 @Unique Node n;
27
28 @RegionEffects("writes n,l:head")
29 void add(List l){
30 l.prepend(n);
31 n = null;
32 }
33 @RegionEffects("writes n,l:head")
34 void bad(List l){
35 Node m = n;
36 m.next = null;
37 add(l);
38 m.next = null;
39 }
40 }

Figure 5.1: Actual "Bad" Uniqueness Example

126
5.2 jEdit
jEdit is a Java-based open source text editor. Version 4.1 was used as a case study
for Fluid assurances, primarily lock analysis and thread-coloring. As such, it forms
a relatively large ( 15kB of source code) sample of annotated Java code on which
to run the analysis. Because of its size, I could not calculate expected results for
the permission analysis by hand, and instead compared it to the results from the
pre-existing effects and uniqueness analyses.

In many ways, jEdit is not a good choice for evaluating a permission analysis.
While it has been annotated, most of those annotations are for thread and lock
analyses. Six fields have been annotated as unique; the protection provided by a lock
is extended to uniquely referenced state, using the implicit ownership provided by
uniqueness. With one exception, these unique annotations are known not to assure;
they exist to be trusted by the lock analysis. The one exception also annotates a
method return as unique to support the uniqueness of the field. No methods are
explicitly annotated with method effects.

However, the methods are then treated as if annotated to write everything. As
such, the permission analysis runs on each of these and assures that all writes are
legal--in particular that no permissions are lost when analyzing each method. Both
the large number of methods and the existence of many methods with particularly
convoluted control flow give the analysis many opportunities to actively demonstrate
that code without problems has no problems. That is, the analysis is actually tested
in a wide range of situations.1

The other advantage to testing the analysis on a large code base is to investigate
the scalability of the analysis and in this regard testing was less successful. On
methods with particularly convoluted control-flow, analysis finishes in a noticeable

1Several analysis bugs were discovered in this manner.

127
amount of time (10-30 minutes). Worse, the cumulative memory requirements have
been large enough, even with a maximum of 2 gigabytes of space, to stall out running
the analysis with threshing when run on the complete jEdit project. To combat these
problems, the analysis has been run on all methods individually, but not collectively.

This approach is satisfactory for testing purposes, but inadequate for deployment.
Engineering solutions may help. A more optimized implementation would universally reduce the degree of the problem. Additionally, the assurance mechanism can
be optimized to only run the control flow analysis on methods which are explicitly
annotated. A more theoretical solution is to produce a hierarchy of permission analysis of varying efficiency, and only running the less efficient analyses when the faster
analyses could not determine a result. This would not speed up the analysis per se,
but would run it on fewer methods.

On the whole, the results from both forms of analysis are equivalent. There are
many more results overall for the permission analysis, if only because it is running
on all of the unannotated methods. In contrast, the existing analyses are optimized
to only run where annotations explicitly exist. As such, there are relatively few
commonly checked annotations; most of them fields which were labelled unique to
assist the locking analysis. For these fields both analyses either support or fail to
support the result. That is, they have the same precision.

128
Chapter 6
Conclusion
The intention of this work was to produce an annotation checker for effects and
uniqueness annotations using semantics based on fractional permissions. On the
whole, this has been accomplished.

6.1 Further Work
The work described in this paper is a very small thread in a very large tapestry.
Fractional permissions are a powerful tool and more can be done with them than is
described here. Additions and improvements are possible to the analysis presented
here; some of them principally issues of engineering, while others will require revisiting
the design and possibly even the theory of the analysis. Also, more work can be done
with fractional permissions outside the context of the particulars of implementing this
analysis.

129
6.1.1 Additional Annotations
The permission formalism describes the semantics of more annotations than are
currently assured. For some of these annotations, notably ownership, readonly ,
immutable and nonnull , the analysis as implemented should be powerful enough to
check them also. However, there is no annotation infrastructure for them. Given the
annotation objects, promise drops for the annotations, and revisions in the parser to
handle these annotations, the analysis itself would only need cosmetic modification to
also assure them. The principle additions would be at method boundaries, where the
new annotations would need to be checked and/or accounted-for in the analysis state;
in the creation of new claims specific to those annotations, and in the interface to
Drop-Sea, for reporting purposes. Ideally from annotations could be added similarly,
but the machinery needed to generate the correct lattice state for from is sufficiently
complex that I cannot be certain.

The trickiest to add will likely be raw annotations. The current analysis relies
on a separate binder (which links uses to definitions) to look up annotations directly,
rather than passing them as additional predicates. Thus adding a full raw ness analysis would require adding named predicates for classes and cooked. A conservative
approximation of a rawness analysis could be done by adding checks against `leaky'
constructors, which hand out raw objects.

6.1.2 Concurrency
The analysis and even the permission formalism is presented here entirely in the context of single-threaded programs. However, fractional permissions also can provide
semantics across multiple threads. In fact, their linearity enables them to support

130
race-free parallel programs. It remains, however, to extend the analysis infrastructure to support annotations describing the design intent of parallelism. Already,
annotations exist in Fluid describing locking regimens; they should be checkable using a permission-based analysis. Yang Zhao ?? has designed one such. Similarly, one
should be able to create a permission semantics for atomicity.

6.1.3 Efficiency
As mentioned in the previous chapter, one could improve the efficiency of the assurance mechanism noticeably by altering the assurance mechanism to only perform
control-flow analysis on methods that are "interesting" to assure. Methods with no
annotations, no declared design intent, can be safely ignored. This requires a small
secondary analysis to determine whether the method is interesting to assure or not.

Along similar lines, one can build both faster, less precise analyses and more direct
theorem-prover based analyses. The assurance mechanism could then start with the
light, fast, analysis, and only run the more complex analyses when the less complex
ones are insufficient. It also opens the door to experimental determination of how
heavyweight an analysis needs to be to handle most or all programs.

6.2 In Summary
Fractional permissions provide a powerful basis for describing and constraining interactions among the states of objects in object-oriented programs. They are extremely
low-level, to the extent that they are impractical to use directly. Rather, we use them
to support programmer-level annotations of design intent, notably effects and uniqueness annotations. Additionally, we require tool support to check these annotations.
Implementing this tool required a series of approximations, from algorithmic type

131
rules that approximate transformation to lattice operations in a control-flow analysis
that approximate the algorithmic type rules. However, the annotations themselves
only use permissions in a stylized manner. For the purpose of checking annotations,
the approximation provided by the control flow analysis appears sufficient.

132
Bibliography
[AC04] Jonathan Aldrich and Craig Chambers. Ownership domains: Separating aliasing policy from mechanism. In In ECOOP, pages 1-25.
Springer-Verlag, 2004.

[AKC02] Jonathan Aldrich, Valentin Kostadinov, and Craig Chambers. Alias

annotations for program understanding. In OOPSLA'02 Conference
Proceedings--Object-Oriented Programming Systems, Languages and
Applications, volume 37, pages 311-330, New York, November 2002.
ACM Press.

[BCO05] Josh Berdine, Cristiano Calcagno, and Peter W. Ohearn. Smallfoot:

Modular automatic assertion checking with separation logic. In In Proceedings of FMCO05, volume 4111 of LNCS, pages 115-137. Springer,
2005.

[BCOP05] Richard Bornat, Cristiano Calcagno, Peter O'Hearn, and Matthew

Parkinson. Permission accounting in separation logic. In POPL '05:
Proceedings of the 32nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 259-270, New York, NY, USA,
2005. ACM Press.

[BDF+04] Mike Barnett, Robert DeLine, Manuel F"ahndrich, K. Ru stan M. Leino,

and Wolfram Schulte. Verification of object-oriented programs with
invariants. J. Object Technology, 3:27-56, 2004.

[BE04a] Adrian Birka and Michael D. Ernst. A practical type system and language for reference immutability. In OOPSLA '04: Proceedings of the
19th annual ACM SIGPLAN Conference on Object-oriented programming, systems, languages, and applications, pages 35-49, New York,
NY, USA, 2004. ACM Press.

[BE04b] Adrian Birka and Michael D. Ernst. A practical type system and language for reference immutability. In In OOPSLA, pages 35-49. ACM
Press, 2004.

133
[Bie06] Kevin Bierhoff. Iterator specification with typestates. In SAVCBS '06:

Proceedings of the 2006 conference on Specification and verification of
component-based systems, pages 79-82, New York, 2006. ACM Press.

[BLR02] Chandrasekhar Boyapati, Robert Lee, and Martin Rinard. Ownership types for safe programming: preventing data races and deadlocks. In OOPSLA'02 Conference Proceedings--Object-Oriented Programming Systems, Languages and Applications, volume 37, pages 211-
230, New York, November 2002. ACM Press.

[BNR] John Boyland, James Noble, and William Retert. Capabilities for sharing: A generalization of uniqueness and read-only. pages 2-27.

[Boy01a] John Boyland. Alias burying: Unique variables without destructive

reads. Software Practice and Experience, 31(6):533-553, May 2001.

[Boy01b] John Boyland. The interdependence of effects and uniqueness. Paper

from Workshop on Formal Techniques for Java Programs, 2001, June
2001.

[Boy03] John Boyland. Checking interference with fractional permissions. In

R. Cousot, editor, Static Analysis: 10th International Symposium, volume 2694 of Lecture Notes in Computer Science, pages 55-72, Berlin,
Heidelberg, New York, 2003. Springer.

[Boy05] John Boyland. Why we should not add "read-only" to Java (yet). In

Informal Proceedings of "Workshop on Formal Techniques for Java-like
Programs", June 2005.

[Boy07] John Boyland. Semantics of fractional permissions with nesting. Technical report, University of Wisconsin-Milwaukee, 2007.

[BR05] John Tang Boyland and William Retert. Connecting effects and

uniqueness with adoption. In POPL '05: Proceedings of the 32nd
ACM SIGPLAN-SIGACT symposium on Principles of programming
languages, pages 283-295, New York, NY, USA, 2005. ACM Press.

[BRLS04] Mike Barnett, K. Rustan, M. Leino, and Wolfram Schulte. The Spec#

programming system: An overview. pages 49-69. Springer, 2004.

[BRZ] John Boyland, William Retert, and Yang Zhao. Comprehending annotations on object-oriented programs using fractional permissions. In
preparation for OOPSLA 2009.

134
[BRZ07] John Boyland, William Retert, and Yang Zhou. Iterators can be independent "from" their collections. In ECOOP 2007 Workshop on Aliasing, Confinement and Ownership in object-oriented programming, July
2007.

[BSBR03] Chandrasekhar Boyapati, Alexandru Salcianu, William Beebee, and

Martin Rinard. Ownership types for safe region-based memory management in real-time java. In Proceedings of the ACM SIGPLAN '03
Conference on Programming Language Design and Implementation, volume 38, pages 324-337, New York, May 2003. ACM Press.

[BV99] Boris Bokowski and Jan Vitek. Confined types. In OOPSLA'99 Conference Proceedings--Object-Oriented Programming Systems, Languages
and Applications, volume 34, pages 82-96, New York, October 1999.
ACM Press.

[ByECD+06] Mike Barnett, Bor yuh Evan Chang, Robert Deline, Bart Jacobs, and

K. Rustanm. Leino. Boogie: A modular reusable verifier for objectoriented programs. In In FMCO 2005, volume 4111 of LNCS, pages
364-387. Springer, 2006.

[CBS98] Edwin C. Chan, John T. Boyland, and William L. Scherlis. Promises:

Limited specifications for analysis and manipulation. In Proceedings
of the IEEE International Conference on Software Engineering(ICSE
'98), pages 167-176, Los Alamitos, California, 1998. IEEE Computer
Society.

[Cla01] David Clarke. Object Ownership and Containment. PhD thesis, University of New South Wales, Sydney, Australia, 2001.

[CNP01] David G. Clarke, James Noble, and John M. Potter. Simple ownership

types for object containment. In Jo/rgen Lindskov Knudsen, editor,
ECOOP'01 -- Object-Oriented Programming, 15th European Conference, volume 2072 of Lecture Notes in Computer Science, pages 53-76,
Berlin, Heidelberg, New York, 2001. Springer.

[CPN98] David G. Clarke, John M. Potter, and James Noble. Ownership types

for flexible alias protection. In OOPSLA'98 Conference Proceedings--
Object-Oriented Programming Systems, Languages and Applications,
volume 33, pages 48-64, New York, October 1998. ACM Press.

[CW03] David Clarke and Tobias Wrigstad. External uniqueness. In Benjamin C. Pierce, editor, Informal Proceedings of International Workshop on Foundations of Object-Oriented Languages 2003 (FOOL 10).
January 2003.

135
[CWM] Karl Crary, David Walker, and Greg Morrisett. Typed memory management in a calculus of capabilities. pages 262-275.

[DF01] Robert DeLine and Manuel F"ahndrich. Enforcing high-level protocols

in low-level software. In Proceedings of the ACM SIGPLAN'01 Conference on Programming Language Design and Implementation, volume 36, pages 59-69, New York, May 2001. ACM Press.

[ETT05] D. Ernst, Matthew S. Tschantz, and Matthew S. Tschantz. Javari:

Adding reference immutability to java. In In OOPSLA, pages 211-230.
ACM Press, 2005.

[FD02] Manuel F"ahndrich and Robert DeLine. Adoption and focus: Practial

linear types for imperative programming. In Proceedings of the ACM
SIGPLAN'02Conference on Programming Language Design and Implementation, volume 37, pages 13-24, New York, May 2002. ACM Press.

[FL03] Manuel F"ahndrich and K. Rustan M. Leino. Declaring and checking

non-null types in an object-oriented language. In OOPSLA '03, 2003.

[GB99] Aaron Greenhouse and John Boyland. An object-oriented effects system. In Rachid Guerraoui, editor, ECOOP'99 -- Object-Oriented Programming, 13th European Conference, volume 1628 of Lecture Notes in
Computer Science, pages 205-229, Berlin, Heidelberg, New York, 1999.
Springer.

[Hoa69] C. A. R. Hoare. An axiomatic basis for computer programming. Commun. ACM, 12(10):576-580, 1969.

[Hog91] John Hogg. Islands: Aliasing protection in object-oriented languages.

In OOPSLA'91Conference Proceedings--Object-Oriented Programming
Systems, Languages and Applications, volume 26, pages 271-285, New
York, November 1991. ACM Press.

[HPSS07] C. Haack, E. Poll, J. Schfer, and A. Schubert. Immutable objects for

a java-like language. Technical report, European Symposium on Programming, volume 4421 of LNCS, 2007.

[IO01] Samin S. Ishtiaq and Peter W. O'Hearn. BI as an assertion language

for mutable data structures. In Conference Record of the Twenty-eighth
Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, pages 14-26, New York, 2001. ACM Press.

[KAB07] Neelakantan R. Krishnaswami, Jonathan Aldrich, and Lars Birkedal.

Modular verification of the subject-observer pattern via higher-order
separation logic. In In Proceedings of FTfJP, 2007.

136
[KMJ02] Sarfraz Khurshid, Darko Marinov, and Daniel Jackson. An analyzable

annotation language. In OOPSLA '02: Proceedings of the 17th ACM
SIGPLAN conference on Object-oriented programming, systems, languages, and applications, pages 231-245, New York, NY, USA, 2002.
ACM Press.

[Kri06] Neelakantan R. Krishnaswami. Reasoning about iterators with separation logic. In SAVCBS '06: Proceedings of the 2006 conference on
Specification and verification of component-based systems, pages 83-86,
New York, 2006. ACM Press.

[LARSW00] Tal Lev-Ami, Thomas Reps, Mooly Sagiv, and Reinhard Wilhelm.

Putting static analysis to work for verification: A case study. In ISSTA
'00: Proceedings of the 2000 ACM SIGSOFT international symposium
on Software testing and analysis, pages 26-38, New York, NY, USA,
2000. ACM Press.

[LBR99] Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation

for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems,
pages 175-188. Kluwer Academic Publishers, Boston,Massachussetts,
USA, 1999.

[LPHZ02] K. Rustan M. Leino, Arnd Poetzsch-Heffter, and Yunhong Zhou. Using

data groups to specify and check side effects. In Proceedings of the
ACM SIGPLAN'02Conference on Programming Language Design and
Implementation, volume 37, pages 246-257, New York, May 2002. ACM
Press.

[Min96] Naftaly Minsky. Towards alias-free pointers. In Pierre Cointe, editor,

ECOOP'96 -- Object-Oriented Programming, 10th European Conference, volume 1098 of Lecture Notes in Computer Science, pages 189-
209, Berlin, Heidelberg, New York, July 1996. Springer.

[MPH00] Peter M"uller and Arnd Poetzsch-Heffter. A type system for controlling

representation exposure in Java. In Sophia Drossopolou, Susan Eisenbach, Bart Jacobs, Gary T. Leavens, Peter M"uller, and Arnd PoetzschHeffter, editors, 2nd ECOOP Workshop on Formal Techniques for Java
Programs, 2000.

[NNH99a] Flemming Nielson, Hanne Riis Nielson, and Chris Hankin. Principles

of Program Analysis. Springer, Berlin, Heidelberg, New York, 1999.

[NNH99b] Flemming Nielson, Hanne Riis Nielson, and Chris Hankin. Principles

of Program Analysis. Springer, Berlin, Heidelberg, New York, 1999.

137
[OP99] P.W. O'Hearn and D.J. Pym. The logic of bunched implications. Bulletin of Symbolic Logic, 5(2):215-244, 1999.

[PS] Frank Pfenning and Carsten Sch"urmann. The twelf project.
[PS02] I. Pechtchanski and V. Sarkar. Immutability specification and its applications. In Joint ACM-ISCOPE Java Grande Conference, 2002.

[Rey02] John Reynolds. Separation logic: a logic for shared mutable data structures. In Logic in Computer Science, pages 55-74, Los Alamitos, California, July22-25 2002. IEEE Computer Society.

[SWM00] Frederick Smith, David Walker, and J. Gregory Morrisett. Alias types.

In Gert Smolka, editor, ESOP'00 -- Programming Languages and Systems, 9th European Symposium on Programming, volume 1782 of Lecture Notes in Computer Science, pages 366-381, Berlin, Heidelberg,
New York, 2000. Springer.

[Wad90] Philip Wadler. Linear types can change the world! In M. Broy and

C. B. Jones, editors, Programming Concepts and Methods. Elsevier,
North-Holland, 1990.

[ZPV03] Tian Zhao, Jens Palsber, and Jan Vitek. Lightweight confinement for

Featherweight Java. In OOPSLA '03: Proceedings of the 18th annual
ACM SIGPLAN conference on Object-oriented programing, systems,
languages, and applications, pages 135-148, New York, NY, USA, 2003.
ACM Press.

[ZPV06] Tian Zhao, Jens Palsber, and Jan Vitek. Type based confinement.

Journal of Functional Programming, 2006.

138
VITA
Title of Dissertation

IMPLEMENTING PERMISSION ANALYSIS

Full Name

William S Retert

Place and Date of Birth

Milwaukee, Wisconsin May 10, 1975

Colleges and Universities, Years attended and degrees

University of Wisconsin-Milwaukee, 1998-2000, M.S. Computer Science

University of Wisconsin-Madison, 1993-1997, B.S. Mathematics

Memberships in Learned or Honorary Societies

Association for Computing Machinery

Publications

John Boyland, William Retert, Yang Zhao. Comprehending Annotations on
Object-Oriented Programs using Fractional Permissions. Submitted to IWACO
2009. July 2009

John Boyland, William Retert, Yang Zhao. Iterators can be Independent "from"
Their Collections. ECOOP 2007 Workshop on Aliasing, Confinement and Ownership in object-oriented programming. July 2007.

John Boyland and William Retert. Connecting Effects and Uniqueness with
Adoption. Principles of Programming Languages, 283-295, January, 2005.

William Retert and John Boyland. Interprocedural Analysis for JVML Verification Workshop on Formal Techniques for Java-like Programs, June 2002.

139
John Boyland, James Noble and William Retert. Capabilities for Aliasing.
In ECOOP'01 -- Object-Oriented Programming, 15th European Conference,
pages 2-27. Volume 2072 of Lecture Notes in Computer Science, Springer,
Berlin, Heidelberg, New York, 2001.

Classes Taught

CS153 Introduction to Scientific Programming in C++
CS201 Introductory Computer Programming
CS251 Intermediate Computer Programming
CS351 Programming Data Structures (Lab)
CS417 Introduction to the Theory of Computation
CS536 Introduction to Software Engineering
CS654 Introduction to Compilers (Discussion)
CS657 Software Testing and Quality Assurance

Major Department

Computer Science

Minor

Mathematics

Professor John Boyland Date