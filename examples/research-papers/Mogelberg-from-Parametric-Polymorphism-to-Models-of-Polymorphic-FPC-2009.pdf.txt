

Under consideration for publication in Math. Struct. in Comp. Science
From parametric polymorphism to models of
polymorphic FPC

Rasmus Ejlers Mo/gelberg #
IT University of Copenhagen
Rued Langgaards Vej 7
2300 Copenhagen S
Denmark
Email: mogel@itu.dk

Received January 2009

This paper shows how PILLY (Polymorphic Intuitionistic / Linear Lambda calculus
with a fixed point combinator Y ) with parametric polymorphism can be used as a
metalanguage for domain theory, as originally suggested by Plotkin more than a decade
ago. Using Plotkin's encodings of recursive types in PILLY we show how parametric
models of PILLY give rise to models of FPC, a simply typed lambda calculus with
recursive types and an operational call-by-value semantics, reflecting a classical result
from domain theory. Essentially, this interpretation is an interpretation of intuitionistic
logic into linear logic first discovered by Girard, which in this paper is extended to deal
with recursive types.
Of particular interest is a model based on "admissible" pers over a reflexive domain, the
theory of which can be seen as a domain theory for (impredicative) polymorphism. We
show how this model gives rise to a parametric and computationally adequate model of
PolyFPC, an extension of FPC with impredicative polymorphism. This is to the author's
knowledge the first denotational model of a non-linear language with parametric
polymorphism and recursive types.

1. Introduction
Parametric polymorphism is an important reasoning principle for several reasons. One is
that it provides proofs of modularity principles (Reynolds, 1983) and other results based
on "information hiding" such as security principles (see for example (Tse and Zdancewic,
2004)). Another is that it can be used to make simple type theories surprisingly expressive by encoding inductive and coinductive types using polymorphism. If in addition
parametric polymorphism is combined with fixed points on the term level, inductive and
coinductive types coincide, and Freyd's theory of algebraically compact categories (Freyd,
1990b; Freyd, 1990a; Freyd, 1991) provides solutions to general type equations. However,

# The work work reported here was conducted while the author was associated with Universit`a di

Genova, Italy and was sponsored by Danish Research Agency stipend no. 272-05-0031

R. E. Mo/gelberg 2
when introducing fixed points the parametricity principle must be weakened for the theory to be consistent. Plotkin (Plotkin, 1993a; Plotkin, 1993b) suggested using the calculus
PILLY (Polymorphic dual Intuitionistic / Linear Lambda calculus with a fixed point combinator Y ), which in combination with parametricity would have recursive types in the
linear part of the calculus. This theory was worked out in details, along with a category
theoretic treatment by Birkedal, Mo/gelberg and Petersen (Birkedal et al., 2006a; Birkedal
et al., 2008; Birkedal et al., 2006b) see also (Mo/gelberg, 2005). In (Birkedal et al., 2007) a
concrete model of PILLY is constructed using "admissible" partial equivalence relations
(pers) over a reflexive domain. The theory of admissible pers can be seen as a domain
theory for (impredicative) polymorphism.

Plotkin suggested using PILLY with parametric polymorphism as an axiomatic setup
for domain theory. However, as mentioned, the solutions to recursive type equations that
PILLY provides are in a linear calculus, whereas, as is well known, domain theory also
provides models of non-linear lambda calculi with recursive types, such as FPC -- a simply typed lambda calculus with general recursive types, equipped with an operational
call-by-value semantics. In this paper we test Plotkin's thesis by showing that the solutions to recursive type equations in the linear type theory PILLY can be used to model
FPC. The resulting translation of FPC into PILLY is an extension of Girard's interpretation of intuitionistic logic into linear logic presented in (Girard, 1987) and developed
on term level in (Maraist et al., 1999). In this paper we treat this translation semantically using a category of coalgebras, and our first main result shows that the solutions
to recursive domain equations from PILLY can be given a coalgebra structure satisfying
universal conditions as in Freyd's work on algebraically compact categories. Using this
result we can extend the Girard translation to recursive types.

The example of the model of admissible pers is particularly interesting for two reasons: here the interpretation of FPC can be extended to an interpretation of PolyFPC,
an extension of FPC with polymorphism, and this model can be shown to be computationally adequate. The model is to the author's knowledge the first denotational model
of the combination of parametric polymorphism, recursive terms and recursive types for
a non-linear language. For many readers the construction of this model may be the main
result of the paper, but the earlier abstract analysis is needed to show that it models
recursive types. The computational adequacy result of the admissible per model also
implies computational adequacy for the interpretation of FPC into PILLY .

The adequate model of PolyFPC may be used to derive consequences of parametricity,
such as modularity proofs, up to ground contextual equivalence along the lines of the
proofs of (Pitts, 2005), but using denotational methods. The model is also interesting
because of the mix of parametricity and partiality, a combination which, as earlier research has shown, requires an alternative formulation of parametricity, such as the one
suggested in (Johann and Voigtl"ander, 2004). This paper describes the resulting parametricity principle derivable from the model, and sketches how the parametric reasoning
in the model can be lifted to a logic for parametricity for PolyFPC.

The research presented in this paper also reveals what appears to be a limitation of
PILLY as a meta language for domain theory and parametric polymorphism, as I have
not been able to extend the interpretation of FPC into PILLY to PolyFPC, but only

From polymorphism to models of polymorphic FPC 3
given the interpretation of full PolyFPC in the specific case of the per-model. If such
an extension does not exist, that would be an unfortunate setback as one would expect
such a meta language to be able to express most constructions of domain theory plus
polymorphism.

A related paper is (Abadi and Plotkin, 1990), in which a model of polymorphism and
recursion is constructed using admissible pers (as here) satisfying a uniformity property
as well as various other properties ensuring that recursive types may be constructed
as in domain theory. The main differences between loc. cit. and this paper is that the
present model is parametric, and in our model the recursive types are constructed using
parametricity.

The paper is organised as follows. Section 2 recalls the language PILLY and the theory of models for it, in particular the per-model. The language PolyFPC is defined in
Section 3. Section 4 first recalls recursive domain equations and Freyd's theory of algebraically compact categories, since we need to introduce vocabulary and recall results
needed for later developments. Using the introduced vocabulary, we present a general
notion of FPC model suitable for our purposes and prove soundness of the interpretation
of FPC in these. Section 5 introduces the general construction of models of FPC from
models of PILLY . Precisely, if C with the comonad ! is a parametric PILLY -model we
prove that the co-Eilenberg-Moore category is an FPC model. In fact, what we prove
is more general, namely we show how an algebraic compactness property for a category
C with a given comonad induces an algebraic compactness result for a certain collection of recursive domain equations in the Kleisli category for the derived monad on the
co-Eilenberg-Moore category.

The brief Section 6 sketches the resulting interpretation of FPC into PILLY , and in
Section 7 the specific case of the per-model is treated. Here the two main results are, as
mentioned, that the model extends to PolyFPC and that this model is computationally
adequate. In Section 7 the interpretation of PolyFPC into the per-model is presented in
elementary terms, and it is the hope of the author that even readers skipping the abstract
categorical treatment of Section 5 understand the interpretation and the following proof
of its adequacy.

In Section 8 a simple example of proving modularity principles in PolyFPC using the
per-model is provided and a sketch of the parametricity principle for PolyFPC derivable
from the model is presented as advertised. Finally Section 9 concludes and discusses
the limitations of PILLY as a meta language for domain theory and polymorphism as
mentioned above.

Acknowledgements. The paper contains ideas and creative input from the following
people: Lars Birkedal, Eugenio Moggi, Rasmus Lerchedahl Petersen, Pino Rosolini and
Alex Simpson. Suggestions from the anonymous referee led to great improvements of the
text.

2. Polymorphic intuitionistic / linear lambda calculus
The calculus PILLY is a Polymorphic dual Intuitionistic / Linear Lambda calculus with
a fixed point combinator denoted Y . In other words it is the calculus DILL of (Barber,

R. E. Mo/gelberg 4
1997) extended with polymorphism and fixed points for terms. This section sketches the
calculus, but the reader is referred to (Birkedal et al., 2006a; Mo/gelberg, 2005) for full
details.

Types of PILLY are given by the grammar

oe, o/ ::= ff | I | oe \Omega  o/ | oe ( o/ | !oe | Q ff. oe,
and we use the notation ff1, . . . , ffn ` oe : Type to mean that oe is a well-formed type with
free type variables among ff1, . . . , ffn. The grammar for terms is

t ::= x | ? | Y | *ffix : oe.t | t t0 | t \Omega  t0 |!t | \Lambda ff : Type. t | t(oe) |

let x : oe \Omega  y : o/ be t in t0 | let !x : oe be t in t0 | let ? be t in t0.

Terms have two contexts of term variables -- a context of linear variables and a context of intuitionistic variables. The variables of these contexts can occur linearly (as in
Girard's linear logic (Girard, 1987)) and intuitionistically (as in simply typed lambda
calculus) in terms respectively. We refer the reader to loc. cit. for the term formation
rules of the calculus and the equality theory for terms. The term constructor *ffix : oe.t
constructs terms of type oe ( o/ by abstracting linear term variables. Using the Girard
encodings one can define oe ! o/ to be !oe ( o/ , and there is a corresponding definable *-
abstraction for intuitionistic term variables. Under this convention, the type of the fixed
point combinator is Y : Q ff. (ff ! ff) ! ff. We refer to the subset of PILLY without the
fixed point combinator Y as PILL.

One should think of PILLY as a type theory for domain theory in combination with
polymorphism. Types can be thought of as cpos (complete partial orders) with least
elements (also called pointed cpos), interpreting \Omega  as the smash product, I is Sierpinski
space, ( as the domain of continuous bottom preserving (or strict) maps, and ! as lifting.
The encoding of ! using lifting introduces the collection of non-strict continuous maps,
and so we think of PILLY as axiomatizing the adjunction

Cppo? 22? Cppoqq
between the categories of pointed cpos with, respectively, strict continuous maps (on the
left hand side), and all continuous maps. In the adjunction the left adjoint is lifting and
the right adjoint is the inclusion. Unfortunately, this interpretation does not immediately
extend to polymorphism, and so for a model of full PILLY , we need to consider admissible
pers as in Section 2.2 below, but still the intuition from domain theory is good to keep
in mind.

When Plotkin introduced PILLY and suggested it as a type theory for domain theory
and polymorphism, he also showed how to encode recursive types using parametric polymorphism. In (Birkedal et al., 2006a) the logic LAPL (Linear Abadi & Plotkin Logic) was
introduced. In this logic the parametricity principle for PILLY can be formulated and
Plotkin's encodings of recursive types can be verified as consequences of parametricity.

From polymorphism to models of polymorphic FPC 5
2.1. PILLY -models
The most general formulation of models of PILLY uses fibred category theory, but here we
will just consider a large class of PILLY -models, which includes most important models
except syntactic ones, since the theory of the next sections is much simpler in this case.
We treat syntactic models in Section 6.

A linear category (Benton et al., 1992) is a symmetric monoidal closed category C
with a symmetric monoidal comonad ! and a given commutative comonoid structure on
each object of the form !A, such that the maps of the comonoid structure eA : !A ( I,
dA : !A (!A\Omega !A are maps of coalgebras from the free coalgebra structure on A to natural
structures on I and !A\Omega !A. We refer to loc. cit. or the more recent (Maneggia, 2004;
Mo/gelberg, 2005) for the details of the definition. As we have already done above, we
shall write f : oe ( o/ for morphisms in C. We say that C models polymorphism if any
functor F : |C|n+1 ! C, where |C| denotes the objects of C considered as a discrete
category, has a right Kan extension (see (Mac Lane, 1971)) RKss(F ) along the projection
ss : |C|n+1 ! |C|n, satisfying the Beck-Chevalley condtion: if G : |C|m ! |C|n then the
canonical natural transformation

RKss(F ) ffi G ! RKss(F ffi (G * id |C|))
(constructed as in (Jacobs, 1999, Sec. 1.9)) is an isomorphism. This notion of model of
polymorphism was used in (Robinson and Rosolini, 1994) and further details can also be
found in (Birkedal and Mo/gelberg, 2005).

A model of PILL is a linear category which models polymorphism, and a model of
PILLY (or a PILLY -model) is a model of PILL with a term modelling the fixed point
combinator Y . Given a PILLY model (C, !) types of PILLY with n free type variables
are modelled as functors |C|n ! C (or equivalently maps |C|n ! |C|) by modelling

~ff ` ffi as the i'th projection, \Omega , I, ( using the symmetric monoidal structure, ! using
the comonad and polymorphism using the Kan extensions.

By a parametric model of PILLY we shall mean a PILLY -model which extends to a
parametric LAPL-structure in the sense of (Birkedal et al., 2008). Parametric LAPLstructures are models of the logic LAPL in which the parametricity principle holds, and
in loc. cit. it is shown how to solve recursive domain equations in parametric PILLY
models. Section 4.1 recalls this result in more detail.

2.2. A per-model
This section recalls the parametric PILLY -model constructed in (Birkedal et al., 2007),
to which we refer for details. The model is a variant of the parametric per-model for
second order lambda calculus, restricted to a notion of admissible pers to encompass
fixed points.

A reflexive domain is a pointed !-complete partial order D such that the domain
[D ! D] of continuous maps from D to D is a retract of D in the sense that there exist

R. E. Mo/gelberg 6
continuous maps

[D ! D]

\Psi  44 D

\Phi pp

such that \Phi  ffi \Psi  is the identity. We consider \Phi , \Psi  as part of the given structure. Reflexive
domains were first studied by Scott as models of the untyped lambda calculus (Scott,
1970; Scott, 1976). A reflexive domain D has a combinatory algebra structure with application x * y defined by applying the function corresponding to x under the reflection to y, i.e. x * y = \Phi (x)(y). We shall also need a strict continuous pairing functionh-

, -i : D * D ! D with continuous projections ss, ss0 : D ! D such that ss(hx, yi) = x
and ss0(hx, yi) = y. These are definable from the given data using standard constructions
as described in (van Oosten, 2008). A partial equivalence relation, or a per, on D is a
symmetric transitive (but not necessarily reflexive) relation. A per R defines an equivalence relation on its domain |R| = {x 2 D | R(x, x)}, and we can consider the equivalence
classes for this equivalence relation [x]R = {y 2 D | R(x, y)}, and collect these in the set

D/R = {[x]R | x 2 |R|}.
We shall often denote a per by its set of equivalence classes. A map of pers from R to S
is a map f : D/R ! D/S such that there exists an element e 2 D tracking f in the sense
that f([x]R) = [e * x]S. This forms a category of pers denoted Per(D). The reader may
find the following intuition useful: The equivalence classes of the per can be thought of as
the elements of a datatype, and elements of equivalence classes as different representatives
of the same data element. A function f of pers is then a map of data elements which is
computable in the sense that there exists a computable function tracking f on the level
of representatives.

An admissible per is a partial equivalence relation R on D which relates ? to itself
and is chain complete in the sense that if (xn)n2N and (yn)n2N are increasing chains
of elements in D such that R(xn, yn) for all n, then also R(F xn, F yn). We define the
category AP to be the full subcategory of Per(D) on admissible pers on D, and we
define the subcategory AP? to be the category of admissible pers with strict maps of
pers, i.e., maps satisfying f([?]) = [?]. We write f : R ( S to indicate that f is a strict
map of admissible pers.

The category AP? has products

R * S = {(hx, yi, hx0, y0i) | R(x, x0) ^ S(y, y0)}
and also a symmetric monoidal closed structure with tensor product defined as a quotient
of the product such that strict maps from R \Omega  S correspond bijectively to bistrict maps
out of R * S. The closed structure is defined as

R ( S = {(d, e) | d * ? = e * ? = ? ^ 8x, y 2 D. R(x, y) oe S(d * x, e * y)}.
Finally, there is a symmetric monoidal comonad ! on AP? defined as mapping R to

{(?, ?)} [ {(h', xi, h', yi) | R(x, y)}

From polymorphism to models of polymorphic FPC 7
where ' = \Psi (id D). This data defines a linear category structure on AP?. The coKleisli
category for ! is isomorphic to AP.

Following the intuition for pers given above, a relation on pers R, S is a subset of
D/R * D/S. An admissible relation on admissible pers is a subset A of D/R * D/S
containing ([?]R, [?]S) and chain complete in the sense that if (xn)n2N and (yn)n2N are
increasing chains of elements in D such that R(xn, xn) and S(yn, yn) for all n then if
for all n ([xn]R, [yn]S) 2 A also ([F xn]R, [F yn]S) 2 A. Admissible relations correspond
bijectively to regular subobjects of R * S in AP?. We write A : AdmRelAP?(R, S) to
indicate that A is an admissible relation from R to S.

The collection of all admissible relations on admissible pers form a category AdmRelAP?
whose morphisms from A : AdmRelAP?(R, S) to B : AdmRelAP?(R0, S0) are pairs of
morphisms (f : R ( R0, g : S ( S0) in AP? mapping related elements to related elements, i.e., if ([x]R, [y]S) 2 A then (f ([x]R), g([y]S)) 2 A0. The linear category structure
on AP? can be extended to AdmRelAP?. For example, if A : AdmRelAP?(R, S) then
A : AdmRelAP?(!R, !S) is the relation relating [?]R to [?]S and relating [h', xi]!R to
[h', xi]!S iff A([x]R, [y]S)). There is a reflexive graph of categories

AdmRelAP? //// AP?oo (1)
where the two functors from left to right map a relation to its domain and codomain
respectively, and the last functor maps a per to the identity relation on the per. The
functors in (1) commute with the linear category structure.

The parametric variant of the per-model, models an open type oe with n free type
variables as a pair ([[oe]]r, [[oe]]p), where [[oe]]p : |AP|n ! |AP| is a map and [[oe]]r is a map
taking an n-vector of admissible relations (Ai : AdmRelAP?(Ri, Si))i<=n and producing
an admissible relation

[[oe]]r( ~A) : AdmRelAP?([[oe]]p( ~R), [[oe]]p(~S)),
satisfying [[oe]]r(eqR1, . . . , eqRn) = eq[[oe]]p( ~R). Most PILLY type constructors are interpreted
using the structure described above. For example, ! is interpreted using the comonads
defined as above on admissible relations and admissible pers

[[!oe]]p( ~R) = ![[oe]]p( ~R)

[[!oe]]r( ~A) = ![[oe]]r( ~A) .

Polymorphism is modelled using intersections of pers and relations

[[Q ff. oe]]p( ~R) = {(x, y) | 8S : |AP?|. [[oe]]p( ~R, S)(x, y)^8

S, S0 : |AP|. 8A: AdmRelAP?(S, S0). [[oe]]r(~eq ~R, A)([x], [y])}
[[Q ff. oe]]r( ~A) = {([x], [y]) | 8S, S0 : |AP?|. 8A : AdmRelAP?(S, S0). [[oe]]r( ~A, A)([x], [y])}

For further details, see (Birkedal et al., 2007; Mo/gelberg, 2005).

To see the parametric per-model as an instance of the definition of Section 2.1 one
must view this definition as interpreted in a realizability topos as we now briefly describe.
Since D with the application defined as above is a combinatory algebra, one can form
the realizability topos RT(D) as in (Hyland et al., 1980). The categories AP and AP?

R. E. Mo/gelberg 8
are the externalisations of internal categories in RT(D), by which we mean precisely that
there exist internal categories in RT(D) (see e.g. (Jacobs, 1999, Chapter 7) for a textbook
exposition of the theory of internal categories), such that AP and AP? are isomorphic
to the categories obtained by applying the global sections functor \Gamma  : RT(D) ! Set
to the internal categories. The construction of these internal categories is similar to
the construction of the category of pers over N as an internal category in the effective
topos (Hyland, 1988)(see also (Jacobs, 1999, Example 7.1.3)). Likewise AdmRelAP?
is the externalisation of an internal category in RT(D). We shall write AP, AP? and
AdmRelAP? also for the internal categories, relying on context to identify which is
referred to of the internal and external categories.

In the theory of internal categories one can talk about internal functors and internal
natural transformations and use this to formulate notions such as internal linear category. All the structure on the categories mentioned above is externalisation of internal
structure, in the sense that there exist, for example, internal linear category structures on
AP? and AdmRelAP? such that the linear category structures described above arise
by applying the global sections functor to the internal structure. So there exists, for example, an internal functor such that the lifting comonad ! on AP? described above is the
global sections functor applied to the internal functor. Also the functors of diagram (1)
are externalisations of internal functors.

The reason that the viewpoint of AP? and AdmRelAP? as internal categories in
RT(D) is important is that these categories do not model polymorphism when seen as
categories in the usual sense (there are simply too many functors and natural transformations in this world), but they do if one restricts to internal functors and internal
natural transformations. One can either do that by simply reading the definition as if it
speaks of internal functors and internal natural transformations, or one can use the fact
that RT(D) is a topos to interpret the whole definition of PILLY -model in the internal
logic of RT(D) (see e.g. (Jacobs, 1999; Lambek and Scott, 1986; Johnstone, 2002) for
the internal logic of a topos). In both of these senses AP? and AdmRelAP? model
polymorphism.

Consider the category RT(D)G of reflexive graphs over RT(D), i.e., the category which
has as objects reflexive graphs in RT(D) and as morphisms pairs of morphisms making the
obvious diagrams commute. It is a well known fact (used e.g. in (Robinson and Rosolini,
1994)) that internal categories in RT(D)G correspond to diagrams of internal categories
in RT(D), and similarly for functors and natural transformations. As a consequence, the
diagram (1) describes an internal linear category in RT(D)G. The diagram (1) is a model
of PILLY in the sense of Section 2.1 when this definition is interpreted in the internal
logic of RT(D)G, and in fact this model is parametric (as proved in (Birkedal et al.,
2007)).

Note that even though the definition of PILLY -model had to be understood in an
internal sense the interpretation of PILLY that we obtain from this model (as sketched
above) is an interpretation in the usual (external) sense.

From polymorphism to models of polymorphic FPC 9
3. Polymorphic FPC
In this section we present the language PolyFPC, an extension of the language FPC,
first defined by Plotkin (Plotkin, 1985) (see also (Fiore, 1996)), with full impredicative
polymorphism. Note that there are several ways of constructing such an extension, as in
the definition of the operational semantics one has to choose what to do when a polymorphic lambda abstraction \Lambda ff. t is met, as one can either stop evaluation or continue
evaluating t. For this paper we only consider the first form of polymorphism.

In later sections we will show how to interpret FPC into any parametric PILLY -model
of the form of Section 2.1 and how to interpret PolyFPC into the per-model sketched in
Section 2.2.

The language PolyFPC has polymorphism and general (nested) recursive types, and
therefore types in the languages may have free type variables (as in PILLY ). Types are
formed using the grammar

oe, o/ ::= ff | 1 | oe + o/ | oe * o/ | oe ! o/ | rec ff. oe | Q ff. oe
As usual, the constructions Q ff. oe and rec ff. oe bind the type variable ff, and as in PILLY
we use the notation ~ff ` oe to mean that oe is a well formed type with free type variables
among ~ff. The grammar for PolyFPC terms is

t ::= x | ? | inl t | inr t | case t of inl x. t0 of inr x. t00 | ht, t0i |

ss1(t) | ss2(t) | *x : oe. t | t(t0) | intro t | elim t | \Lambda ff. t | t(o/ ).

The typing rules for PolyFPC are listed in Figure 1.

In the following we shall use the terminology programs, to mean closed typable terms
of closed type. The language PolyFPC is equipped with a call-by-value operational semantics. Formally, the operational semantics is a relation + relating programs to values,
by which we mean programs following the grammar

v ::= ? | inl v | inr v | hv, v0i | *x : oe. t | \Lambda ff. t | intro v.
The operational semantics is given by the rules listed in Figure 2.

The sublanguage FPC is the part of PolyFPC not mentioning polymorphism, i.e., the
grammar for types is as the grammar for PolyFPC except for Q ff. oe, the grammar for
FPC terms does not include the \Lambda ff. t and t(o/ ) and the formation rules for FPC are as
in Figure 1 except for the last two rules. Likewise the operational semantics for FPC is
defined by the obvious restriction.

Remark 3.1. The languages FPC and PolyFPC could easily be extended with recursion
on the level of terms. For example, one could add the term formation rule

~ff | ~x : ~oe, f : o/ ! o/0, x : o/ ` t : o/ 0 ~ff | ~x : ~oe ` t0 : o/

~ff | ~x : ~oe ` letrec f x = t in f t0 : o/ 0
and add the rule

e0 + v0 e[*x : o/. letrec f x0 = e in f x/f, v0/x0] + v

letrec fx0 = e in f e0 + v

R. E. Mo/gelberg 10

~ff | x1 : oe1, . . . , xn : oen ` xi : oei ~ff | ~x: ~oe ` ?: 1

~ff | ~x : oe ` t : o/

~ff | ~x : oe ` inl t : o/ + o/0

~ff | ~x: oe ` t: o/0
~ff | ~x : oe ` inr t: o/ + o/0

~ff | ~x : ~oe ` t : o/ + o/0 ~ff | ~x : ~oe, x : o/ ` t0 : ! ~ff | ~x: ~oe, x : o/0 ` t00 : !

~ff | ~x : ~oe ` case t of inl x. t0 of inr x. t00 : !

~ff | ~x: ~oe ` t : o/ ~ff | ~x: ~oe ` t0 : o/0

~ff | ~x: ~oe ` ht, t0i: o/ * o/0

~ff | ~x: ~oe ` t: o/ * o/0

~ff | ~x: ~oe ` ss1(t) : o/

~ff | ~x : ~oe ` t: o/ * o/0
~ff | ~x : ~oe ` ss2(t): o/0

~ff | ~x : ~oe, x: o/ ` t : o/0
~ff | ~x: ~oe ` *x: o/. t : o/ ! o/0

~ff | ~x : ~oe ` t : o/ ! o/0 ~ff | ~x : ~oe ` t0 : o/

~ff | ~x : ~oe ` t(t0): o/0

~ff | ~x: ~oe ` t : o/[rec fi. o//fi]
~ff | ~x : ~oe ` intro t : rec fi. o/

~ff | ~x : ~oe ` t: rec fi. o/
~ff | ~x: ~oe ` elim t: o/[rec fi. o//fi]

~ff, fi | ~x : ~oe ` t : o/ ~ff ` ~oe
~ff | ~x: ~oe ` \Lambda fi. t: Q fi. o/

~ff | ~x : ~oe ` t : Q fi. o/ ~ff ` o/0

~ff | ~x : ~oe ` t(o/0): o/[o/0/fi]

Fig. 1. Typing rules for PolyFPC

v + v e + v

inl e + inl v

e + v
inr e + inr v

e + inl v e0[v/x] + v0
case e of inl x. e0 of inr x. e00 + v0

e + inr v e00[v/x] + v0
case e of inl x. e0 of inr x. e00 + v0
e + v e0 + v0

he, e0i + hv, v0i

e + hv, v0i

ss1(e) + v

e + hv, v0i
ss2(e) + v0

e + *x. e00 e0 + v e00[v/x] + v0

e(e0) + v0
e + intro v

elim e + v

e + v
intro e + intro v

t + \Lambda ff. t0 t0[o//ff] + v

t(o/) + v

Fig. 2. Operational semantics for PolyFPC

From polymorphism to models of polymorphic FPC 11
to the operational semantics. However, it is standard that recursion on the level of terms
can be encoded using recursion on the level of types, by defining for each type oe a
fixed point combinator fixoe : (oe ! oe) ! oe as *f : oe ! oe. k(intro (k)) where k =
*x : rec ff. (ff ! oe). f(elim (x)(x)), satisfying f(fixoef ) + v iff fixoef + v for all programs
f and values v.

4. Recursive domain equations
This section recalls Freyd's theory of algebraically compact categories (Freyd, 1990b;
Freyd, 1990a; Freyd, 1991) and introduces vocabulary that we will need in the paper. In
the following C denotes a category, which is usually assumed to be cartesian closed or
symmetric monoidal closed such that basic type constructors such as * or \Omega  and ! or(

exists giving us an interesting collection of domain equations.
Syntactically, a recursive type equation is given by a type expression oe with a free
variable ff and a solution is a type o/ such that oe[o/ /ff] ,= o/. Usually, one is not just
interested in any solution, but rather a solution satisfying a universal condition. For the
formulation of such a universal condition one considers positive and negative occurrences
of a variable in a type expression: ff occurs positively in the type expression ff and the
introduction of an arrow ! reverses parity on the left of the arrow and preserves it on the
right. For example, ff occurs only positively in the types oe = ff + 1 and oe = (ff ! o/ ) ! o/
if o/ is a closed type, but it occurs negatively in (o/ ! ff) ! o/ . If ff occurs only positively
in oe the interpretation of oe induces a functor C ! C and we can ask for initial algebras
or final coalgebras for this functor.

For the more general case of both positive and negative occurrences of ff in oe (such
as oe = (ff ! ff) + 1), one can split the occurrences of ff in oe into positive and negative
and obtain a type ff, fi ` oe where ff occurs only negatively and fi only positively. The
interpretation of such a type induces a functor F : Cop * C ! C. We cannot talk about
initial algebras or final coalgebras for F as it is not an endofunctor, but we can symmetrize
F to the functor *F : Cop * C ! Cop * C defined as

*F (X, Y ) = (F (Y, X), F (X, Y )).

and consider initial algebras and final coalgebras for *F . Writing out the category of algebras for *F we arrive at the category of dialgebras for F : a dialgebra for F is a quadruple
(X, X0, f, f0) where X, X0 are objects of C and f : F (X0, X) ! X and f 0 : X0 ! F (X, X0)
are morphisms. A morphism of dialgebras from (X, X0, f, f0) to (Y, Y 0, g, g0) is a pair of
maps h : X ! Y and h0 : Y 0 ! X0 such that the diagrams

F (X0, X)
F(h0,h) fflffl

f // X

h
fflfflF (Y 0, Y ) g // Y

and Y 0 g

0 //

h0 fflffl

F (Y, Y 0)

F(h,h0)fflffl

X0

f0 // F (X, X0)

commute. An initial dialgebra is an initial object in the category of dialgebras.

Initial dialgebras generalise initial algebras and final coalgebras because, given a functor F : C ! C, we can consider the composition of F with the projection Cop * C ! C,

R. E. Mo/gelberg 12
and (X, X0, f, f 0) is an initial dialgebra for this functor iff f is an initial algebra for F
and f0 is a final coalgebra for F . Freyd has shown in (Freyd, 1990b; Freyd, 1990a; Freyd,
1991) that if a category C is algebraically compact, i.e., all endofunctors have initial
algebras and coalgebras and moreover these coincide in the sense that the inverse of an
initial algebra is a final coalgebra, then initial dialgebras exist on the diagonal, i.e., there
exists initial dialgebras of the form (X, X, f, f -1) for some isomorphism f. For a precise
formulation of this result see Theorem 4.5 below.

To solve general nested recursive type equations, we need to consider type equations with variables. Syntactically these are given by types ~ff, fi ` oe(~ff, fi), and a solution is a type ~ff ` o/ such that oe(~ff, o/ ) ,= o/ . The type equations induce functors
F : (Cop*C)n+1 ! C, which can be symmetrized to *F : (Cop*C)n+1 ! Cop*C defined
by *F (A1, B1, . . . An+1, Bn+1) = (F (B1, A1, . . . Bn+1, An+1), F (A1, B1, . . . An+1, Bn+1)).
Below we shall also use the notation F "" : (Cop * C)n+1 ! Cop for the functor that
maps (A1, B1, . . . An+1, Bn+1) to F (B1, A1, . . . Bn+1, An+1), e.g., *F = hF "", F i. Likewise, if F, F 0 : (Cop * C)n+1 ! C are functors and h is a natural transformation from F
to F 0 then we use the notation h"" for the natural transformation from F 0"" to F "" given
by the components

h""(A1,B1,...An+1,Bn+1) = h(B1,A1,...Bn+1,An+1).
The next definition states what we mean by a being able to solve recursive domain
equations in a category. The definition is given with respect to a class functors F which
we think of as our class of domain equations.

Definition 4.1. A class F of functors of the form F : (Cop * C)n+1 ! C is a collection
of recursive type equations if it contains all projections and is closed under composition
in the sense that if F : (Cop * C)n ! C is in F and likewise Gi : (Cop * C)m ! C and
G0i : (Cop * C)m ! C for i = 1, . . . n then also F ffi hhG01"", G1i, . . . , hG0n"", Gnii is in F.

We say that C has solutions to the collection of recursive domain equations F if for
any functor F : (Cop * C)n+1 ! C in F there exists a functor FixF : (Cop * C)n ! C
in F such that

F ffi hid (Cop*C)n, *FixF i ,= FixF
and further FixF satisfies the initial dialgebra condition: For any pair of functors

G, G0 : (Cop * C)n ! C
in F and natural transformations g : F ffihid , hG0"", Gii ! G and g0 : G0 ! F ffihid, hG"", G0ii
there exists unique natural transformations h : FixF ! G, h0 : G0 ! FixF making the
diagrams

F ffi hid, *FixF i
F(id,h0"",h) fflffl

,= // FixF

h
fflffl
F ffi hid , hG0"", Gii

g // G

and G0 g

0 //

h0

fflffl

F ffi hid, hG"", G0ii

F (id,h"",h0)fflffl
FixF ,= // F ffi hid , *FixF i
commute. The functor FixF is called the solution to the domain equation given by F .

From polymorphism to models of polymorphic FPC 13

The most famous example of a category with solutions to recursive domain equations
is the category of pointed cpos and strict continuous functions where the collection of
equations is given by the locally continuous functors.

We now recall two well known results from the theory of recursive types. Proofs of
Lemma 4.2 and Lemma 4.4 can be found in e.g. Fiore's thesis (Fiore, 1996).

Lemma 4.2. Taking fixed points commutes with reindexing, i.e., if F : (Cop * C)n+1 ! C
and Gi : (Cop * C)m ! C for i = 1, . . . n then

Fix(F ffi (h *G1, . . . , *Gni * id((C)op*C))) ,= (Fix F ) ffi h *G1, . . . , *Gni
Definition 4.3. A collection of recursive domain equations has a strict choice of solutions, if it comes equipped with a choice of solutions for each equation, such that the
isomorphisms of Lemma 4.2 are identities.

Lemma 4.4. Suppose F : D * C ! C is a functor such that for each object X in D, the
functor F (X, -) : C ! C has an initial algebra inX : F (X, uY. F (X, Y )) ! uY. F (X, Y ),
then the assignment X 7! uY. F (X, Y ) extends to a functor uY. F (-, Y ) : D ! C mapping f : X ! X0 in D to the unique map uY. F (f, Y ) making

F (X, uY. F (X, Y ))
F(idX,uY.F (f,Y )) fflffl

inX // uY. F (X, Y )

uY.F (f,Y )fflffl
F (X, uY. F (X0, Y ))

F(f,id)// F (X0, uY. F (X0, Y )) inY 0 // uY. F (X0, Y )

commute.

Finally we formulate Freyd's theorem in the language of this section. In the theorem
when we refer to functors of the form F : (Cop*C)n*C ! C in F where F is a collection
of recursive domain equations, we shall mean functors F such that F ffiss : (Cop *C)n+1 !
C is in F, where ss is the projection (Cop * C)n+1 ! (Cop * C)n * C.

Theorem 4.5. A category C has solutions to a class of domain equations F if and only
if each F : C ! C in F has an initial algebra whose inverse is a final coalgebra and
further, for each F : (Cop * C)n * C ! C in F the functor uX. F : (Cop * C)n ! C
obtained by taking pointwise initial algebras as in Lemma 4.4 is in F.

4.1. Recursive domain equations in PILLY
This subsection reviews the results about solutions to recursive domain equations in models of PILLY , and presents them in the language of Definition 4.1. Thus, in the following
C denotes a model of PILLY in the sense of Section 2.1. Following the convention of
PILLY , we write ( for maps in C and reserve ! for maps in the co-Kleisli category,
i.e., f : oe ! o/ is shorthand for f : !oe ( o/ .

Any PILLY type ff ` oe in which ff occurs only positively induces a functor C ! C,
or more generally, any type ff1, . . . , ffn ` oe induces after a splitting of occurrences
of variables into positive and negative a functor (Cop * C)n ! C. More precisely,

R. E. Mo/gelberg 14
in (Birkedal et al., 2006a) a term

Moe : Q ~ff, ~fi, ~ff0, ~fi0 : Type. (~ff0 ( ~ff) ! (~fi ( ~fi0) ! oe(~ff, ~fi) ( oe(~ff0, ~fi0)
is defined for each type oe by induction over the structure of oe, such that when writing
oe( ~f , ~g) for

Moe~ff ~fi ~ff0 ~fi0 (! ~f) (!~g)
oe( ~id , ~id ) = id and oe( ~f ffi ~f 0, ~g0 ffi ~g) = oe( ~f0, ~g0) ffi oe( ~f , ~g). This term induces the functorial
action of oe. In general, we shall call a functor F : (Cop * C)n ! C strong if there exists
a term in the model inducing it. For example, all constant functors are strong because
for any object X in the model, the constant map to the identity on X is a term in the
model. For further detail we refer to (Birkedal et al., 2008; Mo/gelberg, 2005).

Theorem 4.6. If C is a parametric PILLY model then it has solutions to the class of
recursive domain equations given by strong functors.

Theorem 4.6 is due to Plotkin who showed how to encode initial algebras and final
coalgebras in PILLY . Because of the fixed point combinator in PILLY , initial algebras and
final coalgebras coincide and so Freyd's theory of algebraically compact categories applies
and gives solutions to recursive domain equations. Syntactically the solutions to recursive
type equations produces for any type oe a type rec ff. oe satisfying oe[rec ff. oe/ff] ,= rec ff. oe.
This syntactic construction commutes with reindexing in the sense that rec ff. (oe[~o/ /~fi]) =
(rec ff. oe)[~o/ /~fi]. In PILLY models that are strict in the sense that it is given with a
choice of Kan extensions such that the maps of the Beck - Chevalley condition all are an
identities, substitution in types is interpreted as composition in the sense that

[[~fi ` oe[~o/ /~ff]]] = [[~ff ` oe]] ffi h[[~fi ` o/1]], . . ., [[~fi ` o/n]]i,
and so these PILLY models come equipped with a strict choice of solutions to the recursive domain equiations given by strong functors. For a detailed proof of Theorem 4.6
see (Birkedal et al., 2006a; Birkedal et al., 2008).

4.2. Models of FPC
This section defines the notions of FPC model and PolyFPC model that will be used
in this paper. In axiomatic domain theory FPC is usually interpreted in a category C
where a given collection of subobjects gives rise to a category of partial maps in which
the original category C forms a full-on-objects subcategory of total maps (see Fiore's
thesis (Fiore, 1996)). In these models terms of FPC are interpreted as partial maps but
the category of total maps still plays a key role as the values of FPC are interpreted as
total maps, a fact used in establishing soundness.

In many cases there exists a monad L on C such that the category of partial maps
is isomorphic to the Kleisli category CL. The main example that the reader may know,
and should keep in mind, is that of the category Cpo of complete partial orders and
continuous maps with the lifting monad L. Therefore, the notion of FPC model given

From polymorphism to models of polymorphic FPC 15
below may be seen as an axiomatization of properties of the Kleisli adjunction

Cpo 22? CpoLrr .
Note that CpoL is isomorphic to the category of pointed cpos with strict maps Cppo?,
and so one often sees FPC interpreted in the latter category.

Our definition of FPC model differs from that of Fiore by taking the notion of lifting
monad as primitive rather than the notion of partiality. This definition is chosen because
we want to construct FPC models from PILLY models and in the definition of PILLY
model the comonad is taken as primitive and could a priori be any comonad. The comonad
can be used to construct categories with monads. On the other hand there is no natural
notion of partiality around in the definition of PILLY model, and so we prefer monads
for the definition of FPC models.

In the following, if C is a category and L is a monad on C, we denote by i : C ! CL
the left adjoint of the usual adjunction and use the notation f : X ! Y for maps of C
and f : X * Y for maps of the Kleisli category CL. Even though L can be any monad it
is still a useful intuition that CL is a category of partial maps and following this intuition
we say that a map f : X * Y in CL is total if it is in the image of i.

Recall that if C is cartesian and L is commutative, the product on C induces a symmetric monoidal structure on the Kleisli category CL: on objects, the tensor product
is given by the cartesian product on C and for morphisms f : X * Y, g : X0 * Y 0 the
tensor product f \Omega  g : X \Omega  Y * X0 \Omega  Y 0 is given by the composition

X * Y

f*g // LX0 * LY 0 dst // L(X0 * Y 0)

where dst is the double strength (see (Jacobs, 1994) for further details).
Definition 4.7. A cartesian category C with coproducts and a commutative monad L
is

-- an FPC-model if

- The Kleisli category CL has Kleisli exponentials, i.e., for every object X of C the

composite

C

X*(-)// C i // C

L

has a right adjoint X * (-) : (C)L ! C.
- There exists a class of recursive domain equations F on CL containing Kleisli

exponentials (see Lemma 4.8 below) and the \Omega  induced by the product on C,
such that F has solutions. Moreover, all components of the isomorphisms

F ffi hid (Cop*C)n, *FixF i ,= FixF
must be total, i.e., in the image of i.
-- a PolyFPC model if

- it is an FPC-model
- models Kleisli polymorphism in the sense that for any map o/ : |C|n+1 ! |C|

(where |C| denotes the collection of objects of C) the composite L ffi o/ : |C|n+1 ! C

R. E. Mo/gelberg 16

considered as a functor from the discrete category on |C|n+1 has a right Kan
extension (see (Mac Lane, 1971)) RKss(L ffi o/ ) : |C|n ! C along the projection
ss : |C|n+1 ! |C|n. The Kan extensions must satisfy the Beck-Chevalley condition:
if o/ : |C|n+1 ! |C| and oe : |C|m ! |C|n the canonical natural transformation

RKss(L ffi o/) ffi oe ! RKss(L ffi o/ ffi (oe * id |C|))
(constructed as in (Jacobs, 1999, Sec. 1.9)) is an isomorphism.
- The class of domain equations for which we can solve recursive domain equations

is closed under Kleisli polymorphism, i.e., if F : (CLop * CL)n+1 ! CL is in F
then so is i ffi ~QF : (CLop * CL)n ! CL where ~QF is the induced functor defined
as in Lemma 4.12 below.

-- An FPC model is strict if the class of domain equations comes equipped with a

strict choice of solutions. A PolyFPC model is strict if it is strict as an FPC model
and it comes equipped with a canonical choice of Kan extensions modelling Kleisli
polymorphism such that the isomorphisms of the Beck - Chevalley condition are
identities.

Lemma 4.8. The Kleisli function space induces a functor

(-) * (=) : CLop * CL ! C
Lemma 4.8 is proved by a standard verification.
Lemma 4.9. The correspondence between maps X\Omega Y * Z in CL and maps X ! [Y * Z]
in C is natural in X for total maps.

Lemma 4.9 follows from (-) \Omega  Y being adjoint to Y * (-).
Lemma 4.10. If (C, L) is an FPC model then CL has coproducts and the tensor product
distributes over coproducts, i.e., X \Omega  (Y + Z) ,= X \Omega  Y + X \Omega  Z. This isomorphism is
natural in Y and Z for total maps and in X for partial maps.

Proof. Since X * (-) : C ! CL has a right adjoint X * (-) it preserves coproducts,
and since coproducts in C and CL agree we get the desired isomorphism.

In the following, given categories A, B we shall write [A, B] for the category of functors from A to B with natural transformations as morphisms. We shall also write
Nat[A,B](F, G) for the collection of natural transformations from F to G when both
F, G are functors A ! B. Finally, we shall use the notation |C| both for the collection
of objects for C and for the discrete category on |C|. Observe that maps |C| ! |C| are
the same as functors |C| ! C which are the same as functors |C| ! CL.

Lemma 4.11. Suppose (C, L) is a PolyFPC model. The mapping (o/ : |C|n+1 ! |C|) 7!
(RKss(L ffi o/ ) : |C|n ! |C|) extends to a functor [|C|n+1, CL] ! [|C|n, C], which is right
adjoint to the functor mapping oe : |C|n ! C to i ffi oe ffi ss, where ss : |C|n+1 ! |C|n is the
projection. In other words, if oe : |C|n ! |C| and o/ : |C|n+1 ! |C| are maps, then there
exists a bijective correspondence

Nat[|C|n+1,CL](oe ffi ss, o/) ,= Nat[|C|n,C](oe, RKss(L ffi o/))

From polymorphism to models of polymorphic FPC 17
which is natural in transformations of total maps in oe and natural transformations of
partial maps in o/ .

Proof. From the theory of Kan extensions (see (Mac Lane, 1971, X.3)) we get the
bijective correspondence

Nat[|C|n+1,C](oe ffi ss, L ffi o/ ) ,= Nat[|C|n,C](oe, RKss(L ffi o/ ))
which is natural in oe and L ffi o/. The lemma follows from composing this with the isomorphism

Nat[|C|n+1,CL](i ffi oe ffi ss, o/ ) ,= Nat[|C|n+1,C](oe ffi ss, L ffi o/ )
natural in oe and o/ .

Lemma 4.12. Suppose (C, L) is a PolyFPC model and F : (CLop * CL)n+1 ! CL is a
functor. Define | ~QF | : |C|2n ! |C| to be

RKss(L ffi |F | ffi (id |C|2n * \Delta |C|)),
where \Delta |C| : |C| ! |C|2 is the diagonal, and define for ~f : ~X0 ! ~X and ~g : ~Y ! ~Y 0

~QF1(f1, g1, . . . , fn, gn) : | ~QF |(X1, Y1, . . . , Xn, Yn) ! | ~QF |(X01, Y 01 , . . . , X0n, Y 0n)

to be the total map corresponding to the family
(| ~QF |(X1, Y1, . . . , Xn, Yn) * F (X1, Y1, . . . , Xn, Yn, X, X) * F (X01, Y 01, . . . , X0n, Y 0n, X, X))X2|C|
where the first arrow is the counit of the adjunction of Lemma 4.11 and the second is
F (f1, g1, . . . , fn, gn, id X , id X ). Then (| ~QF |, ~QF1) defines a functor

~QF : (CLop * CL)n ! C

Theorem 4.13. FPC can be modelled soundly in any strict FPC-model, and PolyFPC
can be modelled soundly in any strict PolyFPC-model.

By soundness of the interpretation we mean that if t + v then [[t]] = [[v]].
In the following we describe the interpretation of PolyFPC into a PolyFPC model, and
prove this sound. The interpretation of FPC into FPC models is the restriction of the
interpretation of PolyFPC to FPC, which will make sense in any strict FPC model.

The interpretation is defined as follows. Open types will be interpreted as maps|
CL|n ! |CL| or equivalently functors |CL|n ! CL. However, for the interpretation
of recursive types, we first define an auxiliary interpretation of open types as functors
([~ff ` oe]) : (CLop * CL)n ! CL as in Figure 3. In the figure \Omega  refers to the tensor product
induced on CL by the product on C (on objects this is just the product) and + refers
to the coproduct inherited from C. The ~Q refers to the definition in Lemma 4.12.

We can now define for any open type ~ff ` oe with n free variables the interpretation
[[~ff ` oe]]: |CL|n ! |CL| as advertised to be

[[~ff ` oe]]( ~X) = ([~ff ` oe])(X1, X1, . . . , Xn, Xn).
In particular we get

[[~ff ` Q fi. oe]] = RKss(L ffi [[~ff, fi ` oe]]) (2)

R. E. Mo/gelberg 18

([~ff ` ffi])(X1, Y1, . . . , Xn, Yn) = Yi

([~ff ` 1])(X1, Y1, . . . , Xn, Yn) = 1
([~ff ` oe * o/])(X1, Y1, . . . , Xn, Yn) = ([~ff ` oe])(X1, Y1, . . . , Xn, Yn) \Omega  ([~ff ` o/])(X1, Y1, . . . , Xn, Yn)
([~ff ` oe + o/])(X1, Y1, . . . , Xn, Yn) = ([~ff ` oe])(X1, Y1, . . . , Xn, Yn) + ([~ff ` o/])(X1, Y1, . . . , Xn, Yn)
([~ff ` oe ! o/])(X1, Y1, . . . , Xn, Yn) = ([~ff ` oe])(Y1, X1, . . . , Yn, Xn) * ([~ff ` o/])(X1, Y1, . . . , Xn, Yn)

([~ff ` Q fi. oe]) = i ffi ~Q([~ff, fi ` oe])
([~ff ` rec fi. oe]) = Fix([~ff, fi ` oe])

Fig. 3. Auxiliary interpretation of types as functors.

[[~ff | ~x : ~oe ` xi : oei]] ~X = ssn,iL

[[~ff | ~x : ~oe ` ? : I]] ~X = i(?)
[[~ff | ~x : ~oe ` inl t : o/ + o/0]] ~X = inl[[~ff`o/]],[[~ff`o/0]] ffi [[~ff | ~x ` t : o/]] ~X
[[~ff | ~x : ~oe ` inr t : o/ + o/0]] ~X = inr[[~ff`o/]],[[~ff`o/0]] ffi [[~ff | ~x ` t: o/0]] ~X
[[~ff | ~x: ~oe ` case t of inl x. t0 of inr x. t00 : !]] ~X = [[[~ff | ~x : ~oe, x: o/ ` t0 : !]] ~X, [[~ff | ~x : ~oe, x: o/0 ` t00 : !]] ~X]ffi

d ffi hidNi[[~ff`oei]]( ~X), [[~ff | ~x: ~oe ` t]] ~XiL

[[~ff | ~x : ~oe ` ht, t0i: o/ * o/0]] ~X = h[[~ff | ~x : ~oe ` t: o/]] ~X, [[~ff | ~x : ~oe ` t0 : o/0]] ~XiL

[[~ff | ~x : ~oe ` ss1(t): o/]] ~X = ss2,1L ffi [[~ff | ~x : ~oe ` t: o/ * o/0]] ~X
[[~ff | ~x: ~oe ` ss2(t): o/0]] ~X = ss2,2L ffi [[~ff | ~x : ~oe ` t: o/ * o/0]] ~X

[[~ff | ~x: ~oe ` *y : oe0. t: oe0 ! o/]] ~X = i([[~ff | ~x: ~oe, y : oe0 ` t : o/]] ~X#)

[[~ff | ~x: ~oe ` t(t0): o/0]] ~X = ev[[~ff`oe]]( ~X),[[~ff`o/]]( ~X) ffi h[[~ff | ~x: ~oe ` t]] ~X, [[~ff | ~x : ~oe ` t0]] ~XiL

[[~ff | ~x : ~oe ` intro t : rec fi. o/]] ~X = fold ffi [[~ff | ~x : ~oe ` t: o/[rec fi. o//fi]]] ~X
[[~ff | ~x: ~oe ` elim t: o/[rec fi. o//fi]]] ~X = unfold ffi [[~ff | ~x: ~oe ` t: rec fi. o/]] ~X

[[~ff | ~x: ~oe ` \Lambda fi. t : Q fi. o/]] ~X = i([[~ff, fi | ~x: ~oe ` t: o/]]#~X)
[[~ff | ~x : ~oe ` t(o/0): o/[o/0/fi]]] ~X = ev[[~ff`o/0]]( ~X) ffi [[~ff | ~x: ~oe ` t: Q fi. o/]] ~X

Fig. 4. Interpretation of PolyFPC terms.

An open term ~ff | ~x : ~oe ` t : o/ will be interpreted as an indexed family of maps

([[~ff | ~x : ~oe ` t : o/ ]] ~X : O

i [[

~ff ` oei]]( ~X) * [[~ff ` o/ ]]( ~X)) ~X2|CL|n

in CL. The interpretation is defined by induction over the structure of the term, and
is presented in Figure 4, where typings as in Figure 1 are assumed. In the following we
explain the notation used in Figure 4.

Notice first, that since the \Omega  is given on objects by the product from C and I the
neutral object for \Omega  is given by the terminal object in C, we have projections out of
tensor products ssn,iL = i(ssn,i) : Nj<=n Xj * Xi (for ssn,i the i'th projection in C), we
have for any object X a map i(?) : X * I given by ? the unique map in C to the terminal

From polymorphism to models of polymorphic FPC 19
object, and we have a diagonal i(\Delta X ) : X ! X \Omega  X in CL, where \Delta X is the diagonal
in C. The latter can be used to define a pairing hf, giL : X * Y \Omega  Z of maps in CL as
f \Omega  g ffi i(\Delta X), but we need to keep in mind that all this in general does not define a
product structure on CL.

In the interpretation of the introduction rules for coproducts, inl and inr refer to the
coprojections. In the interpretation of case, the notation d refers to the isomorphismN

i[[~ff ` oei]]( ~X) \Omega  [[o/ + o/ 0]]( ~X) ,

= // N

i[[~ff ` oei]]( ~X) \Omega  [[o/ ]]( ~X) + Ni[[~ff ` oei]]( ~X) \Omega  [[o/ 0]]( ~X)

(Lemma 4.10) and [-, -] refers to copairing.

Given

([[~ff | ~x : ~oe, y : oe0 ` t : o/ ]] ~X : O

i [[

~ff ` oei]]( ~X) \Omega  [[~ff ` oe0]]( ~X) * [[~ff ` o/ ]]( ~X)) ~X2|CL|n

the interpretation of *y : oe0. t is defined using the family of corresponding total maps

([[~ff | ~x : ~oe, y : oe0 ` t : o/ ]] ~X # : O

i [[

~ff ` oei]]( ~X) ! h[[~ff ` oe0]]( ~X) * [[~ff ` o/ ]]( ~X)i) ~X2|CL|n

The interpretation of function application refers to the evaluation map

evX,Y : [X * Y ] \Omega  X * Y
which is the counit of the adjunction X \Omega  (-) a X * (-). In the interpretation of the
introduction and elimination rules for recursive types the terms fold and unfold refer to
the components of the isomorphisms for recursive domain equations as in Definition 4.1.
This typechecks by Lemma 4.14 below.

For the interpretation of polymorphic lambda abstraction, suppose

([[~ff, fi | ~x : ~oe ` t : o/ ]] ~X,Y : O

i [[

~ff, fi ` oei]]( ~X, Y ) * [[~ff, fi ` o/ ]]( ~X, Y ))( ~X,Y )2|C|n+1.

In the typing rule for \Lambda ff. t it is assumed that fi does not occur free in the oei's, and so,
by Lemma 4.14 below, Ni[[~ff, fi ` oei]]( ~X, Y ) = Ni[[~ff ` oei]]( ~X). By (2) and Lemma 4.11
the family [[~ff, fi | ~x : ~oe ` t : o/ ]] ~X,Y corresponds to a family of total maps

([[~ff, fi | ~x : ~oe ` t : o/ ]]#~X : O

i [[

~ff ` oei]]( ~X) ! [[~ff ` Q fi. o/ ]]( ~X))( ~X)2|C|n

and we define [[~ff `| ~x : ~oe ` \Lambda ff. t : o/]] ~X = [[~ff, fi | ~x : ~oe ` t : o/ ]]#~X . Type application of polymorphic terms: t(o/ ) is interpreted as composition of the interpretation of t and the
component

ev[[~ff`o/0]]( ~X) : [[~ff ` Q fi. oe]]( ~X) * [[~ff, fi ` oe]]( ~X, [[~ff ` o/ ]]( ~X))
of the counit of the adjunction of Lemma 4.11. This type checks by Lemma 4.14 below.
Lemma 4.14. If ~ff ` oe then [[~ff, fi ` oe]] = [[~ff ` oe]] ffi ss, where ss is the projection
ss : |C|n+1 ! |C|n. For ~ff, fi ` oe and ~ff ` o/ types of PolyFPC,

[[~ff ` oe[o//fi]]] = [[~ff, fi ` oe]] ffi hid |C|n, [[~ff ` o/ ]]i

R. E. Mo/gelberg 20
and if ~ff, fi | ~x : ~oe ` t : !, then

[[~ff | ~x : ~oe[o//fi] ` t[o/ /fi]: ![o//fi]]] ~X = [[~ff, fi | ~x : ~oe ` t : !]]( ~X,[[~ff`o/]]( ~X))
Proof. This is an easy induction on o/ and t respectively. The case of recursive types in
the first induction follows up to isomorphism from Lemma 4.2, which we have assumed to
be an identity. The case of polymorphic types follows from the Beck-Chevalley condition
in the usual way, and again to get equality in the lemma, we use our assumption that
the isomorphism of the Beck-Chevalley condition is an identity.

By construction, terms in general are interpreted in CL, but values are interpreted in
C:

Lemma 4.15. For any value v of any closed type oe of PolyFPC, the interpretation [[v]]
considered as a map from 1 to [[oe]] is total.

Proof. Easy induction on v.
Lemma 4.16. Suppose ~ff | ~x : ~oe, x : oe0 ` t : o/ is an PolyFPC term and v : oe0 is a value.
Then

[[~ff | ~x : ~oe ` t[v/x]]] = [[~ff | ~x : ~oe, x : oe0 ` t]] ffi hid \Omega i[[oei]], [[~ff | ~x : ~oe ` v]]iL.

Proof. This is again by an easy structural induction on t, but we do the case of lambda
abstractions since it shows why the reindexing only holds for values.

Suppose given ~ff | ~x : ~oe, x : oe0, y : oe00 ` t : o/ and v : oe0 is a value. By induction hypothesis

[[~ff | ~x : ~oe, y : oe00 ` t[v/x] : o/]] = [[~ff | ~x : ~oe, x : oe0, y : oe00 ` t : o/ ]]ffi(hid \Omega i[[~ff`oei]], [[v]]iL*id [[~ff`oe00]])
The map corresponding to the left hand side under the adjunction for Kleisli function
space is the interpretation of *y : oe00. t[v/x]. Using Lemma 4.9 the right hand side corresponds to

[[~ff | ~x : ~oe, x : oe0 ` *y : oe00. t : o/ ]] ffi hid \Omega i[[~ff`oei]], [[v]]iL
since by Lemma 4.15 hid \Omega i[[~ff`oei]], [[v]]iL is a total map.

Finally, we sketch the proof of Theorem 4.13.
Proof of Theorem 4.13 We need to show that if t + v, then [[t]] = [[v]]. The proof is by
induction on the derivation of t + v. Most cases are easy, and we just mention a few.

Consider the rule

e + hv, v0i

ss1(e) + v .
By induction hypothesis [[e]] = h[[v]], [[v0]]iL, and by Lemma 4.15, [[v]] and [[v0]] are total
maps. Since for total maps pairing and projections are inverses, [[ss1(e)]] = [[v]].

For the rule

e + *x. e00 e0 + v e00[v/x] + v0

e(e0) + v0 ,

From polymorphism to models of polymorphic FPC 21
we compute

[[e(e0)]] = ev ffi h[[*x : e00]], [[v]]iL

= [[e00]] ffi [[v]]
= [[e00[v/x]]].

The first equation follows from the induction hypothesis, the second from general arguments about adjunctions, and the last from Lemma 4.16.

To prove soundness of the rule

t + \Lambda ff. t0 t0[o/ /ff] + v

t(o/ ) + v
notice that [[(\Lambda ff. t0)(o/ )]] = [[ff | - ` t0]][[o/]], which by Lemma 4.14 is [[t0[o/ /ff]]].

5. Modeling FPC in categories of coalgebras
In this section we address the problem of interpreting the intuitionistic calculus FPC
into parametric models of the linear calculus PILLY . Before presenting our solution we
discuss the domain theoretic intuition.

As mentioned in Section 2, the domain theoretic intuition for the PILLY is that the
types are pointed cpos, and indeed the notion of PILLY model axiomatizes properties
of the category Cppo? of these with strict continuous maps and the lifting comonad on
Cppo?.

On the other hand the notion of FPC model axiomatizes properties of the category Cpo
of complete partial orders that do not necessarily have a least element, and continuous
maps between them. The problem in constructing FPC models from parametric PILLY
models is that in PILLY there is no way of talking of cpos that are not pointed.

Thinking of domain theory this may not seem like such a big problem. After all,
one can go from pointed cpos to cpos via an unlifting operation inverse to the lifting
operation. But such unlifting operations do not exist for general PILLY models. Consider
for example the admissible per given by the equivalence classes {{?, b}, {a}} for some
elements a, b such that ? < a < b. This per is not isomorphic to the lift of any other per.

Our solution is to construct the category corresponding to Cpo from a PILLY model as
the co-Eilenberg-Moore category for the lifting comonad. Recall that the co-EilenbergMoore category for a comonad ! on a category C is the category whose objects are
coalgebras for the comonad (maps , : X !!X satisfying ffl ffi , = id and (!,) ffi , = ffi ffi ,,
for ffl, ffi are counit and comultiplication) and whose morphisms are the C morphisms that
commute with the coalgebra structure. If , : X !!X is a coalgebra then X is called
the carrier of the monad. We write C! for the co-Eilenberg-Moore category for ! on C.
The domain theoretic intuition for why constructing the category of predomains as the
co-Eilenberg-Moore category is right, is that (Cppo?)! is isomorphic to Cpo, and later
we shall prove a similar theorem in the theory of admissible pers (Proposition 7.2 and
Theorem 7.4).

We now aim to prove that if (C, !) is a parametric PILLY -model then (C!, L) is an
FPC model. First we need the following lemma.

R. E. Mo/gelberg 22
Lemma 5.1. Let ! be a comonad on a category C. Denoting by L the monad induced by
! on the co-Eilenberg-Moore category C!, the Kleisli category (C!)L for L is isomorphic
to the category that has the same objects as C! but as morphisms from , : X !!X to
O/ : Y !!Y all morphisms of C from X to Y , and composition and identity as in C.

Proof. By definition (C!)L has the same objects as C! and as morphisms from , : X !!X
to O/ : Y !!Y coalgebra morphisms from , to ffiY : !Y !!!Y . Since ffi is the cofree coalgebra
on Y , such maps correspond to morphisms from X to Y in C as desired. It is a simple
exercise to show that this correspondence preserves composition and identity.

Lemma 5.2. Suppose (C, !) is a linear category. Then the induced monad L on C! is
strong and commutative and the category C! is cartesian and has finite coproducts. The
category (C!)L has Kleisli exponentials in the sense of Definition 4.7.

Proof. In this proof, since C is a linear category, we write f : X ( Y for morphisms
in C and reserve X ! Y as a shorthand for !X ( Y .

In the definition of the notion of linear category ! is a symmetric monoidal comonad
on C, so L becomes a symmetric monoidal monad on the symmetric monoidal category
C!. A theorem by Kock (Kock, 1972) now shows that it is commutative.

The product and coproduct structure is well known, the proof can be found in for
example (Benton, 1995, Lemma 9), we just show the constructions. Given , : X (!X
and ,0 : X0 (!X0 the product of , and ,0 is

X \Omega  Y

,\Omega ,0 ffi!X\Omega !Y m ffi!(X \Omega  Y )

where m is the comparison map, part of the structure of a symmetric monoidal comonad.
The terminal object is the coalgebra mI : I (!I, also part of the structure of a symmetric
monoidal comonad.

The coproduct is

X + Y

,+,0 ffi!X+!Y [!inl,!inr] ffi!(X + Y ) .

The functorial actions of the product and coproduct are simply given by the tensor and
coproduct from C respectively.

For , : X (!X a coalgebra, the functor , * (-) maps O/ : Y (!Y to the cofree
coalgebra ffi : !(X ( Y ) (!!(X ( Y ). This satisfies the required universal property as
can be seen from the following isomorphisms of homsets

C!(,0, , * O/) ,= C(X0, X ( Y ) ,= C(X0 \Omega  X, Y ) ,= (C!)L(,0 * ,, O/)
which hold for any coalgebra ,0 : X0 (!X0.

Lemma 5.2 is the first step towards showing that (C!, L) is an FPC model when (C, !)
is a PILLY model. The next step is to identify a collection of recursive domain equations
on (C!)L that can be solved.

Definition 5.3. A functor Fcoalg : ((C!)op *C!)n ! C! is a lift of F : ((C)op *C)n ! C

From polymorphism to models of polymorphic FPC 23
to coalgebras if the diagram

((C!)op * C!)n

Fcoalg //

fflffl

C!

fflffl(Cop * C)n F // C
commutes, where the vertical functors are the obvious forgetful functors. Likewise we say
that Fcoalg : C! ! C! is a lift of F : C ! C to coalgebras if U ffi Fcoalg = F ffi U for U the
forgetful functor.

Notice that Fcoalg is a lift of F then F determines Fcoalg on carriers in the sense that
if ,, ,0 are coalgebras with the same carrier, then Fcoalg(,) and Fcoalg(,0) also have
the same carrier. But F can also be seen as an extension of Fcoalg to maps that are
not necessarily maps of coalgebras. The latter means that if Fcoalg is a lift of F then

Fcoalg extends to a functor (Fcoalg, F ) : (((C!)L)op * (C!)L)n ! (C!)L, whose action on
morphisms is given by F (by Lemma 5.1).

We show that for a parametric PILLY model (C, !) the collection of recursive domain
equations on (C!)L given by pairs (Fcoalg, F ) where Fcoalg lifts F to coalgebras and F is
a strong functor as in Section 4.1 can be solved. For the proof we will apply Theorem 4.5,
and so we start by considering initial algebras.

Proposition 5.4. Suppose C is a category and ! is a comonad on C, and suppose that
Fcoalg : C! ! C! is a lift of F : C ! C to coalgebras. If F has an initial algebra, then
so does Fcoalg. Moreover, the image of the initial algebra for Fcoalg under the forgetful
functor U : C! ! C is the initial algebra for F .

Proof. In this proof, whenever we write Fcoalg(,) we mean the functor Fcoalg applied
to a coalgebra considered as an object of C!. The action of Fcoalg on morphisms of
coalgebras is always denoted F , as F and Fcoalg agree on morphisms. The maps ffl, ffi
denote counit and comultiplication for the comonad !.

Suppose in : F (uX. F (X)) ! uX. F (X) is an initial algebra for F . We will show that
, : uX. F (X) !!uX. F (X) defined as the unique map making the diagram

F (uX. F (X)) in //

F(,) fflffl

uX. F (X)

,fflffl
F (!uX. F (X))

Fcoalg(ffi)// !

F (!uX. F (X))

!F (ffl) // !F (uX. F (X)) !in // !uX. F (X)

commute, is the carrier of an initial algebra for Fcoalg. First one must show that , in fact
defines an object of C!, i.e., that ffl ffi , is the identity and that ffi ffi , =!, ffi ,. The algebra
is given by in, and one must show that this actually defines a map in C!, i.e., that the

R. E. Mo/gelberg 24
diagram

F (uX. F (X))
Fcoalg(,)

fflffl

in // uX. F (X)

,fflffl
!(F (uX. F (X))) !in // !uX. F (X)

(3)

commutes. Finally, to show that this is an initial algebra, we should show that given any
other algebra, i.e., a commutative diagram of the form

F (X)
Fcoalg(O/)

fflffl

f // X

O/
fflffl!F (X) !f // !X

(4)

there exists a unique map g : uX. F (X) ! X making the diagram

F (uX. F (X))

Fcoalg(,)

fflffl

in //
F (g)

''OOOO
OOOOO
OO uX. F (X)

,

g

$$III
IIII
III

F (X)

Fcoalg(O/)
fflffl

f // X

O/
fflffl
!(F (uX. F (X))) !in

!F (g) ''OOOOOO

OOOOO

!uX. F (X)

!g

$$IIII
IIIII
I

!F (X) !f // !X

(5)

commute. Of course, by in being an initial algebra for F , there exists a unique map
g making the top square (5) commute, and we just need to show that the rest of the
diagram commutes with g being this map. Showing all this is an easy diagram chase,
which can be found in Appendix A.

Theorem 5.5. Suppose C is a category and ! is a comonad on C and let L denote the
monad on C! induced by !. Suppose C has solutions to recursive domain equations as
given by the collection of functors F and suppose F : (Cop * C)n+1 ! C is in F. If F
has a lift to coalgebras Fcoalg, then FixF also has a lift Fix(Fcoalg). Moreover, for any

2n vector ~, of coalgebras with carriers denoted ~X, the isomorphism

F ffi hid , *FixF i( ~X) ,= FixF ( ~X)
is an isomorphism of coalgebras

Fcoalg ffi hid , *Fix(Fcoalg)i(~,) ,= Fix(Fcoalg)(~,).
Proof. The first half of the theorem states that the class of domain equations F0 ` F
consisting of functors with lifts to coalgebras has solutions, and we will use Theorem 4.5
to prove this. By assumption all functors F : C ! C in F have initial algebras whose

From polymorphism to models of polymorphic FPC 25
inverses are final coalgebras, so the same condition holds for all F in F0. It remains to
verify that if F : (Cop * C)n * C ! C is in F0, so is uX. F (-, X) : (Cop * C)n ! C
formed using Lemma 4.4. So suppose Fcoalg : (C!op * C!)n * C! ! C! is a lift of F to

coalgebras. By Proposition 5.4 each Fcoalg(~,, ~,0, -) : C! ! C! has an initial algebra, and
so we can form u,. Fcoalg(-, ,) : (C!op * C!)n ! C! using Lemma 4.4. We claim that

((C!)op * C!)n

u,.Fcoalg(-,,)//

fflffl

C!

fflffl(Cop * C)n uX.F (-,X) // C

commutes, verifying uX. F (-, X) 2 F0. The diagram commutes on objects by the last
statement of Proposition 5.4. Inspection of the proof of Proposition 5.4 shows that the
unique maps out of the initial algebras given by u,. Fcoalg(-, ,) are computed as for
uX. F (-, X), and so since the morphism parts of u,. Fcoalg(-, ,) and uX. F (-, X) are
computed using these, the diagram commutes for morphisms as well.

To prove the last statement of the theorem we need to have a closer look at the construction in the proof of Theorem 4.5. Since the construction is pointwise, we will just consider
the case of domain equations with no variables. So suppose Fcoalg : C!op*C! ! C! is a lift
of F : Cop*C ! C to coalgebras. Consider the functor G = uX. F (-, X) : Cop ! C. Define the object X0 of C as uY. F (G(Y ), Y ) and define X = G(X0). Since these are obtained
as initial algebras, we get maps h : F (X0, X) ! X and h0 : F (X, X0) ! X0 in C and one
can show that (X, X0, h, (h0)-1) as well as (X0, X, h0, h-1) are initial dialgebras for F .
This implies that there exists an isomorphism of dialgebras (k, k0) : (X0, X, h0, h-1) !
(X, X0, h, (h0)-1). Now, the solution to the recursive domain equation given by F is X
with isomorphism h ffi F (k, id ) : F (X, X) ! X.

By Proposition 5.4 we know that X and X0 have coalgebra structures for ! and so
F (X, X0) and F (X0, X) also get coalgebra structures by application of Fcoalg. We also
know that h and h0 preserve these coalgebra structures, and what we need to prove is
that so does h ffi F (k, id ). In fact, for this it suffices to show that k preserves coalgebra
structures, because in this case the map Fcoalg(k, id) = F (k, id ) preserves coalgebra
structures.

The construction of k is as follows: denote by out : G(X) ! F (X, G(X)) the final
coalgebra for F (X, -) and construct a: X0 ! G(X) as the unique map making the
diagram

X0
a fflffl

(h0)-1 // F (X, X0)

F(id,a)fflffl
G(X) out // F (X, G(X))

(6)

R. E. Mo/gelberg 26
commute. Now, k is defined as the unique map making the diagram

F (X, X0) h0 //
F(G(k),k) fflffl

X0

k
fflfflF (G(X), X) F (a,id)// F (X0, X) h // X

(7)

commute. The map k0 is defined as G(k) ffia, but one can prove that k = k0. Since (k, k) is
an isomorphism of dialgebras, also k is an isomorphism implying that a is an isomorphism
since k = G(k) ffi a.

We first prove that a is a map of coalgebras. Since both vertical maps in (6) are invertible, we can use initiality of out-1 to construct a map b : G(X) ! X0 satisfying a ffi b = id ,
which implies that b is the inverse of the isomorphism a. By Proposition 5.4 since the
vertical maps of (6) preserve coalgebras, so does b, and so does a. This implies that both
vertical maps in (7) preserve coalgebra structure, and so again by Proposition 5.4, k
preserves coalgebra structures, which concludes the proof.

Corollary 5.6. If (C, !) is a parametric PILLY model, then (C!, L) is an FPC model.

Proof. Using Lemma 5.2 all that remains to be proved is that there exists a rich
class of recursive domain equations on (C!)L that can be solved. For this we consider
the collection G of functors induced by pairs (F, Fcoalg) where Fcoalg is a lift of F to
coalgebras and F is strong. By Theorem 4.6 and the first half of Theorem 5.5, for any
pair (F, Fcoalg) we get a pair (FixF, Fix(Fcoalg)) providing a fixed point of the functor
(F, Fcoalg) up to an isomorphism. Moreover, the isomorphism consists of total maps, i.e.,
maps of coalgebras. For the universal condition, since the morphisms of (C!)L are simply
those of C, and the morphism part of (F, Fcoalg) is given by F , the universal condition
of (FixF, Fix(Fcoalg)) reduces to that of FixF , which is satisfied by assumption.

Finally we must show G is closed under products, coproducts and Kleisli exponentials.
This can be seen from the constructions in the proof of Lemma 5.2. For example, for the
case of Kleisli exponentials the functor obtained by Lemma 4.8 is induced by the pair
(F, Fcoalg) defined as

Fcoalg(, : X (!X, ,0 : Y (!Y ) = ffi(X(Y )

F (X, Y ) = !(X ( Y ) .

Unfortunately the FPC model obtained from a PILLY model (C, !) needs not be strict
even if we have a strict choice of solutions to recursive domain equations on C. The
problem is that a functor on (C!)L which can be represented by a pair (F, Fcoalg) need
not have a unique such representation, and so the solution to a recursive domain equation
given by (F, Fcoalg) as constructed in the proofs above can depend on the representation.
In the following we present a slight variant of the interpretation of Section 4.2 which gives
a sound interpretation of FPC into any PILLY model.

We first give an auxiliary interpretation of each FPC type ff1, . . . , ffn ` oe as a pair of

From polymorphism to models of polymorphic FPC 27
functors

([~ff ` oe]) : (Cop * C)n ! C
([~ff ` oe])coalg : (C!op * C!)n ! C!

with the property that ([~ff ` oe])coalg lifts ([~ff ` oe]). This interpretation is given in Figure 5,
where in the definition of ([~ff ` oe])coalg, the symbols 1, +, * refers to the terminal object,
coproducts and products of C!, the notation ffiZ is used for the cofree coalgebra on Z and
U denotes the forgetful functor C! ! C.

([~ff ` ffi])(X1, Y1, . . . , Xn, Yn) = Yi

([~ff ` 1])(X1, Y1, . . . , Xn, Yn) = I
([~ff ` oe + o/])(X1, Y1, . . . , Xn, Yn) = ([~ff ` o/])(X1, Y1, . . . , Xn, Yn) + ([~ff ` o/])(X1, Y1, . . . , Xn, Yn)

([~ff ` oe * o/])(X1, Y1, . . . , Xn, yn) = ([~ff ` o/])(X1, Y1, . . . , Xn, Yn) \Omega  ([~ff ` o/])(X1, Y1, . . . , Xn, Yn)
([~ff ` oe ! o/])(X1, Y1, . . . , Xn, yn) = !(([~ff ` oe])(Y1, X1, . . . , Yn, Xn) (!([~ff ` o/])(X1, Y1, . . . , Xn, Yn))

([~ff ` rec fi. oe]) = Fix([~ff, fi ` oe])

([~ff ` ffi])coalg(,1, ,01, . . . , ,n, ,0n) = ,0i

([~ff ` 1])coalg(,1, ,01, . . . , ,n, ,0n) = mI
([~ff ` oe + o/])coalg(,1, ,01, . . . , ,n, ,0n) = ([~ff ` oe])coalg(,1, ,01, . . . , ,n, ,0n) + ([~ff ` o/])coalg(,1, ,01, . . . , ,n, ,0n)
([~ff ` oe * o/])coalg(,1, ,01, . . . , ,n, ,0n) = ([~ff ` oe])coalg(,1, ,01, . . . , ,n, ,0n) * ([~ff ` o/])coalg(,1, ,01, . . . , ,n, ,0n)
([~ff ` oe ! o/])coalg(,1, ,01, . . . , ,n, ,0n) = ffi([~ff`oe])(U(,01),U(,1),...,U(,0n),U(,n))(!([~ff`o/])(U(,1),U(,01),...,U(,n),U(,0n))

([~ff ` rec fi. oe])coalg = Fix([~ff, fi ` oe])coalg

Fig. 5. Auxiliary interpretation of FPC types in PILLY models

Using the auxiliary interpretation of types as pairs of functors, we define

[[~ff ` oe]] : |(C!)L|n ! |(C!)L|
as [[~ff ` oe]](~,) = ([~ff ` oe])coalg(,1, ,1, . . . , ,n, ,n). The interpretation of terms is exactly as
in Section 4.2.

6. Interpreting FPC into PILLY
In this short section we show how the theory of Section 5 gives rise to an interpretation
of FPC into PILLY .

Denote by PILLY the category whose objects are the closed types of PILLY and whose
morphisms from oe to o/ are equivalence classes of closed PILLY terms of type oe ( o/
under the equivalence relation relating terms if they are provably equal in LAPL using
parametricity. This category is symmetric monoidal closed and the type constructor !
induces a symmetric monoidal comonad on it, such that in fact (PILLY , !) is a linear

R. E. Mo/gelberg 28
category. As above, we will use PILL!Y to denote the co-Eilenberg-Moore category and
L to denote the induced monad on PILL!Y .

Theorem 6.1. The category (PILL!Y , L) is an FPC-model.
Theorem 6.1 follows from Lemma 5.2 and Proposition 4.6 together with Theorem 5.5.
The collection of domain equations is in this case given by the functors

F : (PILL!Y op * PILL!Y )n ! PILL!Y
for which there exists a PILLY type ff1, . . . , ffn, fi1, . . . , fin ` oe in which the ff's occur only negatively and the fi's only positively, such that when (,i : o/i (!o/i)i<=n and
(O/i : !i (!!i)i<=n are vectors of coalgebras then the carrier of F (,1, O/1, . . . , ,n, O/n) is
oe[~o/ /~ff, ~!/~fi], and such that the action of F on morphisms of coalgebras is given by the
term Moe as in Section 4.1.

Theorem 6.1 gives an interpretation of FPC into PILLY interpreting a closed FPC type
oe as closed PILLY type oe* and an FPC program t : oe as a closed PILLY term t* : oe*. The
interpretation is sound in the sense that t + v implies t* is provably equal to v* in LAPL
using parametricity. Later we shall prove that this interpretation is computationally
adequate (Corollary 7.9).

A priori the interpretation does not interpret open FPC types and terms as PILLY
types and terms. Instead open FPC types are interpreted as maps |PILL!Y |n ! |PILL!Y |.
But the interpretation can also be presented more syntactically by interpreting an open
FPC type ~ff ` oe as a pair

(~ff ` oe*, oe*coalg : Q ~ff. (ff1 (!ff1) ! . . . ! (ffn (!ffn) ! oe* (!oe*)
where the first component is a PILLY type with n free variables, and oe*coalg is a closed
PILLY -term such that the statement: if for all i, fi : ffi (!ffi is a coalgebra then so
is oe*coalg~ff(! ~f), is provable in LAPL. An open FPC term, say, ~ff | x : oe ` t : o/ is then
interpreted as a term

t* : Q ~ff. (ff1 (!ff1) ! . . . ! (ffn (!ffn) ! oe* ( o/ *.

7. Polymorphic FPC in the per-model
As a special case, the abstract analysis of Section 5 shows that our main example --
the per-model -- models FPC. This particular model is interesting for three reasons: the
interpretation of FPC extends to an interpretation of full PolyFPC, the concrete model
has a simple presentation, and we can show that this model of PolyFPC is computationally adequate. Here we first give the more concrete presentation of the model, and show
that it also models full PolyFPC. In Section 7.1 we present the resulting PolyFPC model
in elementary terms and computational adequacy is proved in Section 7.2.

Recall that to see the per-model as an example of the notion of PILLY -model of Section 2.1 one must interpret this definition in the internal logic of RT(D)G. Since RT(D)G
is a topos, its internal language is an expressive intuitionistic type theory in which one
can interpret most constructions known from set theory (again we refer to (Jacobs, 1999;

From polymorphism to models of polymorphic FPC 29
Lambek and Scott, 1986; Johnstone, 2002) for details). This means, for example, that one
can form the co-Eilenberg-Moore category for an internal comonad on an internal category RT(D)G as an internal category. Moreover, since the arguments of Section 5 were
all constructive, we can interpret all this theory in the internal logic of the topos RT(D)G
and this gives us an FPC model. As was the case of the PILLY model, the results in the
internal logic of RT(D)G give rise to an interpretation of FPC in the usual (external)
sense. Readers only interested in the elementary description of the model should skip to
Section 7.1.

To understand the model, let us first give a concrete description of the co-EilenbergMoore category. To be precise, since we interpret the constructions of Section 5 inside
RT(D)G, the category we are interested in is the externalisation of a co-Eilenberg-Moore
category as formed in the internal logic of RT(D)G. Fortunately, there is no difference
between considering the externalisation of the co-Eilenberg-Moore category as formed
internally, and the co-Eilenberg-Moore category as formed in the usual sense from the
external data, as the next lemma states. Because of this we shall not in the following
specify which of the two is meant in statements of theorems.

Lemma 7.1. Suppose E is a topos, C is an internal category in E and ! is an internal
comonad on C. Then the externalisation of the co-Eilenberg-Moore category as formed
internally in E is isomorphic to the co-Eilenberg-Moore category as formed in the usual
sense from the externalisation of C and !.

Proof. An object of the externalisation of the co-Eilenberg-Moore category as formed
internally is a global element of the object of objects of C and a global element of
the object of morphisms of C satisfying equations stating that the latter is a coalgebra
structure on the former. This is precisely what is needed to specify an object of the coEilenberg-Moore category as formed in the external sense. We leave it to the interested
reader to write out the isomorphisms in detail.

We start by considering the co-Eilenberg-Moore category for ! on AP?. The first result
states that this is equivalent to CCP, the full subcategory of Per(D) on chain complete
pers. This is a nice result as CCP seems a natural choice of a category of predomains
in the theory of admissible pers, and so as mentioned, this can be seen as parallel to
the isomorphism (Cppo?)L ,= Cpo from classical domain theory. Similarly to the other
categories of pers in this paper, CCP is the externalisation of an internal category of
RT(D) and this equivalence of categories is also true in the stronger internal sense.

Proposition 7.2. The co-Eilenberg-Moore category AP!? for the lifting comonad ! on
AP? is equivalent to CCP. Moreover, the category AP!? as formed in the internal
logic of RT(D) is equivalent to the internal category CCP in the usual sense of internal
categories of RT(D), i.e., there exist internal functors F : CCP ! AP!? and G : AP!? !
CCP and invertible internal natural transformations ff : G ffi F ! id CCP, fi : F ffi G !
id AP!?.

Proof. We show that AP!? is isomorphic to the category of admissible pers R for
which the equivalence class [?] is a downward closed subset of the domain of R -- i.e., if

R. E. Mo/gelberg 30
R(x, x), x <= y and R(y, ?), then R(x, ?) -- and maps that preserve and reflect [?]. This
category is equivalent to CCP, with one map of the equivalence lifting a chain complete
per, and the other discarding the equivalence class [?] from an admissible per.

Recall from Section 2.2 that the comonad ! on AP? maps an admissible per R to{
(?, ?)} [ {(h', xi, h', yi) | R(x, y)} where ' = \Psi (id D). Suppose , is a coalgebra on an
admissible per R, e tracks , and R(x, x), x <= y and R(y, ?). Since [?]!R = {?} and since
, is a strict map, e * y = ?, and so by monotonicity e * x = ?. Since ffl ffi , is the identity,
where ffl is the counit, R(x, ?). On the other hand, if [?] is a downward closed subset of
the domain of R then one may easily check that the tracker

e(x) = ae ? if y >= x, R(y, ?) for some yh', xi else
defines a unique coalgebra structure on R. Continuity of e follows from admissibility of
R.

Suppose f : R ( S is a map between such pers with coalgebra structures denoted
,R, ,S respectively and that f preserves coalgebra structure. Since f is strict it must
preserve the equivalence class of ?. To see that it also reflects it, suppose f ([x]R) = [?]S.
Then also !(f )(,R([x])) = [?]!S implying that ,R([x]) = [?]!R. Clearly, then R(x, ?).

We omit the straightforward verification of the second statement of the theorem.

We note that the composition CCP ! AP!? ! AP? of the equivalence and the
forgetful functor is the lifting functor, as can be seen by inspection of the above proof.

Proposition 7.2 also holds on the level of relations as we now show. As admissible relations on chain complete pers R and S we shall consider subsets A ` D/R*D/S such that
if (xn)n2N and (yn)n2N are increasing chains, such that for all n, R(xn, xn) and S(yn, yn)
and ([xn]R, [yn]S) 2 A then also ([Fn xn]R, [Fn yn]S) 2 A. Admissible relations on chain
complete pers form a category AdmRelCCP where maps are pairs of maps mapping
related elements to related elements as in Section 2.2. We write A : AdmRelCCP(R, S) to
indicate that A is an admissible relation between chain complete pers R, S. Similarly to
AdmRelAP? the category AdmRelCCP is the externalisation of an internal category
of RT(D).

Proposition 7.3. The co-Eilenberg-Moore category for ! on AdmRelAP? is equivalent
to AdmRelCCP. The equivalence is an externalisation of an internal equivalence of
categories in RT(D).

Proof. Again we just show the first part of the proposition. Suppose R, S are admissible pers and (,, ,0) defines coalgebra structure on A: AdmRelAP?(R, S). Then ,, ,0
define coalgebra structures on R, S respectively, and so the analysis from the proof of
Proposition 7.2 applies. We show that A is a lifted relation in the sense that A([?], [?])
and if A([x], [?]) then [x] = [?] and similarly A([?], [x]) implies [x] = [?]. The first follows from admissibility. For the second suppose A([?]R, [x]S). Then !A([?]!R, ,0([x]S)),
implying ,0([x]) = [?]!S, and so [x]S = [?]S. So we can extend the equivalence of categories defined above, to map A : AdmRelCCP to !A, and map A 2 AdmRel!AP? to
A \ {([?], [?])}.

From polymorphism to models of polymorphic FPC 31

Now, recall that we wanted to apply the theory of Section 5 to the diagram

AdmRelAP? //// AP?oo (8)

considered as an internal category in the category RT(D)G of reflexive graphs over
the realizability topos over D. So we were interested in a concrete description of the
co-Eilenberg-Moore category for the lifting comonad on (8). Fortunately, co-EilenbergMoore categories in RT(D)G are constructed pointwise # and so Propositions 7.2 and 7.3
imply the following theorem.

Theorem 7.4. The co-Eilenberg-Moore category for the lifting comonad on

AdmRelAP? //// AP?oo

in the category RT(D)G is equivalent to

AdmRelCCP //// CCPoo (9)
The maps of diagram (9) are the usual domain, codomain and identity relation maps,
which one can show define internal functors.

Theorem 7.5. Diagram (9) considered as an internal category in RT(D)G models polymorphism. As a consequence, the per model of FPC models full PolyFPC.

Proof. In this proof we shall use the notation C for the internal category in RT(D)G
given by the diagram (8) and D for the one given by (9). A map from |D|n to |D| inside
RT(D)G is a pair of maps (fp, fr) where f p is a map |CCP|n ! |CCP| and fr is a map
taking an n-vector of admissible relations (Ai : AdmRel(Ri, Si)) (admissible in the sense
of objects of AdmRelCCP) on objects of CCP and produces an admissible relation

f r( ~A): AdmRel(f p( ~R), fp(~S))
satisfying f r(eq ~R) = eqfp( ~R), and a natural transformation from (f p, fr) to (gp, gr)
is a family of maps (t ~R : fp( ~R) ! gp( ~R)) ~R2|CCP|n with a common tracker, which
respects relations in the sense that for all vectors ~R, ~S, (Ai : AdmRel(Ri, Si))i, if
([x]fp( ~R), [y]fp(~S)) 2 f r( ~A) then (t ~R([x]fp( ~R)), t~S([y]fp(~S))) 2 gr( ~A).

We show that any such functor (fp, f r) : |D|n+1 ! |D| has a right Kan extension along
the projection ss : |D|n+1 ! |D|n of the n first coordinates. The Kan extension is given
by

(RKss(f p, f r))p( ~R) = {(x, y) | 8S : |CCP|. fp( ~R, S)(x, y)^8

S, S0 : |CCP|. 8A : AdmRelCCP(S, S0). fr( ~eq~R, A)([x], [y])}

(RKss(f p, fr))r( ~A) = {([x], [y]) | 8S, S0 : |CCP|. 8A0 : AdmRelCCP(S, S0). fr( ~A, A0)([x], [y])}

and that this works is quite standard (see e.g. (Jacobs, 1999, Ch 8) or (Birkedal and

# Technically, constructing the co-Eilenberg-Moore category in the internal logic amounts to a limit

construction, and limits in presheaf categories such as RT(D)G are computed pointwise. Similar
arguments are used in (Robinson and Rosolini, 1994).

R. E. Mo/gelberg 32
Mo/gelberg, 2005)). Since Definition 4.7 only calls for the existence of Kan extensions
of functors obtained by composing with lifting, this constructions gives us all the Kan
extensions we need. For the Beck - Chevalley condition, suppose (gp, gr): |D|m ! |D|n,
then clearly RKss((f p, fr) ffi ((gp, gr) * id |D|)) = RKss((fp, fr)) ffi (gp, gr) and the map of
the Beck - Chevalley condition, which is required to be an isomorphism, is in fact an
identity.

To show that the per-model models full PolyFPC we need to show that the collection of solvable recursive domain equations is closed under Kleisli polymorphism.
In (Birkedal et al., 2007) it is shown that the class of solvable recursive domain equations in the PILLY model C is exactly the collection of internal functors in RT(D)G.
This means that the collection of solvable recursive domain equations in the FPC model
(C, L) is the collection of functors (CLop * CL)n+1 ! CL induced by internal functors
(fp, fr) : (Cop * C)n+1 ! C and (gp, gr) : (Dop * D)n+1 ! D such that (gp, gr) lifts
(fp, fr). The latter means that the diagrams

(CCPop * CCP)n+1
(Lop*L)n+1 fflffl

fp // CCP

Lfflffl
(AP?op * AP?)n+1

gp // AP?

(AdmRelCCPop * AdmRelCCP)n+1

(Lop*L)n+1 fflffl

fr // AdmRel

CCP

Lfflffl

(AdmRelAP?op * AdmRelAP?)n+1

gr // AdmRelAP?

commute. (Using that the composition of the equivalence CCP ! APL? and the forgetful
functor APL? : AP? is lifting, as noted earlier). Consider ~Qf = (( ~Qf)p, ( ~Qf )r) and~Q

g = (( ~Qg)p, ( ~Qg)r) defined as follows.

( ~Qf)p( ~R) = L{(x, y) | 8S : |CCP|. f p( ~R, S, S)(x, y)^8

S, S0 : |CCP|. 8A : AdmRelCCP(S, S0). f r(~eq ~R, A, A)([x], [y])}
~Qf r( ~A) = L{([x], [y]) | 8S, S0 : |CCP|. 8A0 : AdmRelCCP(S, S0). gr( ~A, A0, A0)([x], [y])}

~Qgp( ~R) = L{(x, y) | 8S : |CCP|. gp( ~R, LS, LS)(x, y)^

8S, S0 : |CCP|. 8A : AdmRelCCP(S, S0). gr(~eq ~R, LA, LA)([x], [y])}
~Qgr( ~A) = L{([x], [y]) | 8S, S0 : |CCP|. 8A0 : AdmRelCCP(S, S0). gr( ~A, LA0, LA0)([x], [y])}.

One can verify that ~Qg lifts ~Qf, and that the functor ( ~Qf, ~Qg) : (CLop * CL)n ! CL
induced by the two is the one constructed from the Kan extension using Lemma 4.12.
This shows that the class of solvable recursive domain equations is closed under Kleisli
polymorphism as needed.

From polymorphism to models of polymorphic FPC 33
7.1. The per-model of PolyFPC
We now describe the resulting interpretation of PolyFPC in the per-model. Types of
PolyFPC are modelled as pairs ([[~ff ` oe]]p, [[~ff ` oe]]r), where [[~ff ` oe]]p is a map |CCP|n !|

CCP| and [[~ff ` oe]]r is a map taking an n-vector (Ai : AdmRel(Ri, Si)) of admissible
relations (admissible in the sense of objects of AdmRelCCP) on objects of CCP and
produces an admissible relation

[[~ff ` oe]]r( ~A) : AdmRel([[~ff ` oe]]p( ~R), [[~ff ` oe]]p(~S))
satisfying [[~ff ` oe]]r(eq ~R) = eq[[~ff`oe]]p( ~R).

Figure 6 shows the interpretation of PolyFPC types in the per-model, except for the
recursive types. These recursive types are determined uniquely up to isomorphism by their
universal properties (as initial dialgebras), a property shown to be useful in (Pitts, 1996),
and we shall not present a more concrete description of them in this model. In the figureh*

, *i denotes the pairing function D * D ! D definable using the combinatory algebra
structure on D, and the symbols 1, 2 denote incomparable elements of D (explicitely these
could be h', ?i and h?, 'i respectively, where ' denotes a code for the identity function
on D).

The monad induced by the comonad on AP? and AdmRelAP? is denoted L. Explicitly, this monad maps a chain complete per R to {(?, ?)} [ {(h', xi, h', yi) | R(x, y)},
and an admissible relation A on chain complete pers R, S is mapped to the relation on
LR, LS that relates [?] to [?] and [h', xi] to [h', yi] if A([x], [y]).

Terms of PolyFPC are modelled in the Kleisli category for L. To be more precise, a
term ~ff | ~x : ~oe ` t : o/ is modelled as an indexed family of maps

([[t]] ~R : Qi[[~ff ` oei]]p( ~R) ! L[[~ff ` o/]]p( ~R)) ~R
where the product refers to the product in CCP. Such a family must have a common
tracker, and must preserve relations, which means that if ~A : AdmRel( ~R, ~S), and for
each i, ([xi], [yi]) 2 [[~ff ` oei]]r( ~A), then

([[t]]~R([x1], . . . , [xm]), [[t]]~S([y1], . . . , [ym])) 2 L[[~ff ` o/ ]]r( ~A).
Theorem 7.6. The interpretation of PolyFPC types defined in Figure 6 extends to a
sound interpretation of PolyFPC.

7.2. Computational adequacy
A o/ -oe context of PolyFPC for types oe, o/ , where oe is closed, is an expression C[-] containing a place holder - such that whenever an expression t of type o/ is substituted for
the place holder such that the result C[t] is a closed term, it has type oe. Two terms
t, t0 : o/ of PolyFPC of the same type are called contextually equivalent (written t j t0),
if for any type oe, and any o/-oe context C[-],

C[t] + iff C[t0] +
where t + means: there exists a v such that t + v.

R. E. Mo/gelberg 34

[[~ff ` ffi]]p( ~R) = Ri
[[~ff ` oe * o/]]p( ~R) = {(hx, yi, hx0, y0i | [[~ff ` oe]]p( ~R)(x, x0) ^ [[~ff ` o/]]p( ~R)(y, y0)}
[[~ff ` oe + o/]]p( ~R) = {(h1, xi, h1, x0i) | [[~ff ` oe]]p( ~R)(x, x0)}[

{(h2, yi, h2, y0i) | [[~ff ` o/]]p( ~R)(y, y0)}
[[~ff ` oe ! o/]]p( ~R) = {(e, f) | 8x, y 2 D. [[~ff ` oe]]p( ~R)(x, y) oe L[[~ff ` o/]]p( ~R)(e * x, f * y)}

[[~ff ` 1]]p( ~R) = {(?, ?)}
[[~ff ` Q ff. oe]]p( ~R) = {(x, y) | 8S : |CCP|. L[[~ff, ff ` oe]]p( ~R, S)(x, y)^8

S, S0 : |CCP|. 8A: AdmRelCCP(S, S0). L[[~ff, ff ` oe]]r(~eq~R, A)([x], [y])}

[[~ff ` ffi]]r( ~A) = Ai
[[~ff ` oe * o/]]r( ~A) = {([hx, yi], [hx0, y0i]) | [[~ff ` oe]]r( ~A)([x], [x0]) ^ [[~ff ` o/]]r( ~A)([y], [y0])}
[[~ff ` oe + o/]]r( ~A) = {([h1, xi], [h1, x0i]) | [[~ff ` oe]]r( ~A)([x], [x0])}[

{([h2, yi], [h2, y0i]) | [[~ff ` o/]]r( ~A)([y], [y0])}
[[~ff ` oe ! o/]]r( ~A) = {([e], [f]) | 8([x], [y]) 2 [[~ff ` oe]]r( ~A). ([e * x], [f * y]) 2 L[[~ff ` o/]]r( ~A)}

[[~ff ` 1]]r( ~A) = {([?], [?])}
[[~ff ` Q ff. oe]]r( ~A) = {([x], [y]) | 8S, S0 : |CCP|. 8A : AdmRelCCP(S, S0). L[[~ff, ff ` oe]]r( ~A, A)([x], [y])}

Fig. 6. Interpretation of PolyFPC in per-model

Theorem 7.7 (Adequacy). For any program t of PolyFPC, [[t]] 6= [?] in the per-model
iff t +.

From Theorem 7.7 the following corollary giving a tight connection between the operational and denotational semantics is easily provable.

Corollary 7.8. Suppose t, t0 are two PolyFPC terms of the same type. If [[t]] = [[t0]] then
t j t0.

Proof. Since the interpretation of terms is defined by structural induction, one may
easily prove that for any o/ -oe context C[-], and terms t, t0 of type o/ , if [[t]] = [[t0]] then
[[C[t]]] = [[C[t0]]]. So, if [[t]] = [[t0]] then for any context C[-]

C[t] + () [[C[t]]] 6= [?] () [[C[t0]]] 6= [?] () C[t0] +
proving the corollary.

One can define a contextual equivalence relation on FPC as the one for PolyFPC
by restricting to the contexts of FPC. Since this equivalence relation is obtained by
quantifying over fewer contexts it is weaker than the contextual equivalence relation
inherited from PolyFPC by restriction. Corollary 7.8 now gives a computational adequacy
result of the interpretation of FPC into PILLY with respect to this contextual equivalence
relation.

From polymorphism to models of polymorphic FPC 35
Corollary 7.9. The interpretation (-)* of FPC into PILLY of Section 6 is computationally adequate in the sense that for two FPC programs t, t0 of the same type, if
t* is provably equal to t0* in LAPL using parametricity then t and t0 are contextually
equivalent.

Proof. The restriction to FPC of the interpretation of PolyFPC into the per model
can be factorised as (-)* followed by the interpretation of PILLY into the per-model.
This means that if t* is provably equal to t0* then by soundness of the per-model interpretation of Linear Abadi & Plotkin Logic, [[t]] = [[t0]], and so the corollary follows from
Corollary 7.8.

We now proceed to prove Theorem 7.7.
In the following, we shall refer to admissible relations between chain complete pers R
and sets Y , writing AdmRelCCP(R, Y ) for the collection of all such. By this we mean
subsets A of (D/R) * Y , such that for each y 2 Y , the collection {[x]R | ([x]R, y) 2 A}
defines a chain complete per.

For the proof of Theorem 7.7 we construct for each open type of PolyFPC an approximation relation 4oe, which for each vector of closed PolyFPC-types ~o/ and vector of
admissible relations (aei : AdmRelCCP([[o/i]]p, Valo/i))i gives an admissible relation

4(~o/,~ae)oe : AdmRelCCP([[oe]]p([[~o/ ]]p), Valoe[~o//~ff]),
where Valo/ denotes the set of values of PolyFPC of type o/ .

In the following, when we use notation such as x : [[oe]]p or x : R for pers R or x 4(~o/,~ae)oe v,
the variable x ranges over the collection of equivalence classes for the per in question.
This follows the intuition mentioned above of equivalence classes being the elements of a
per. If x : [[oe ! o/ ]]p and d : [[oe]]p we shall use the notation x(d): L[[o/ ]]p, for the equivalence
class obtained by applying any representative of x to any representative of d. This is
welldefined by definition of [[oe ! o/ ]]p. Likewise if x : [[Q ff. oe]]p and R is any chain complete
per, we shall write x(R) : L([[ff ` oe]]p(R)) for the equivalence class represented by any
representative of x. If x : LR we write x # for x 6= [?]LR. Finally, we shall write Type for
the set of closed PolyFPC types.

Lemma 7.10. The approximation relations indexed over PolyFPC types can be defined
such that

-- x 4(~o/,~ae)ffi v () xaeiv
-- x 4(~o/,~ae)1 * () ?
-- x 4(~o/,~ae)oe*o/ hv, v0i () ss1x 4(~o/,~ae)oe v ^ ss2x 4(~o/,~ae)o/ v0
-- x 4(~o/,~ae)oe+o/ inl v () 9x0. x = inl (x0) ^ x0 4(~o/,~ae)oe v
-- x 4(~o/,~ae)oe+o/ inr v () 9x0. x = inr (x0) ^ x0 4(~o/,~ae)o/ v
-- x 4(~o/,~ae)oe!o/ *y : oe. t () 8d, v0. (d 4(~o/,~ae)oe v0 ^ x(d) #) oe 9v00. t[v0/y] + v00 ^ x(d) 4(~o/,~ae)o/ v00
-- x 4(~o/,~ae)Q ff.oe \Lambda ff. t () 8o/ : Type. 8ae : AdmRelCCP([[o/ ]]p, Valo/ ). x([[o/ ]]p) #oe 9v0. t[o/ /ff] +

v0 ^ x([[o/ ]]p) 4(~o/,o/,~ae,ae)oe v0.
-- x 4(~o/,~ae)rec ff.oe intro v () unfold(x) 4(~o/,rec ff.oe[~o//~ff],~ae,4

(~o/,~ae)rec ff.oe)

oe v

R. E. Mo/gelberg 36
where inl, inr denote respectively the left and the right inclusions into the coproduct,
and in the last condition unfold is the isomorphism [[rec ff. oe]]p ! [[oe[rec ff. oe/ff]]]p (i.e.,
the interpretation of elim).

Lemma 7.10 may at first appear as a definition of 4oe, but since the case of recursive
types involves the relation being defined on the right hand side of the equation, the proof
of the lemma below involves finding a fixed point for a certain map of predicates as in
(Pitts, 1996).

Lemma 7.11. For any term

~ff | ~x :~oe ` t : o/
of PolyFPC, for all vectors of closed types ~o/ and all vectors of relations

(aei : AdmRelCCP([[o/i]]p, Valo/i))i
and all (di : [[oei[~o/ /~ff]]]p))i, (vi : Valoei[~o//~ff])i, if for all i

di 4(~o/,~ae)oei vi
then [[t]][[~o/]]p(~d) # implies

9v : Val. t[~o/ /~ff][~v/~x] + v ^ [[t]][[~o/]]p(~d) 4(~o/,~ae)o/ v
Assuming Lemma 7.10 and Lemma 7.11 are correct (proofs follow below), Theorem 7.7
is now easy.

Proof of Theorem 7.7. The "only if" direction is the special case of Lemma 7.11 for
closed terms. For the "if" direction, suppose t : o/ and t + v. By soundness [[t]] = [[v]], and
by Lemma 4.15, [[v]] considered as a map from 1 to [[o/ ]] is a map of coalgebras, meaning
in this case that it is total, i.e., [[v]] 6= ?.

We now proceed to prove first Lemma 7.10 and then Lemma 7.11. Recall that each
PolyFPC type oe(ff, fi) in which ff occurs only negatively and fi only positively induces a
functor oe : CCPLop * CCPL ! CCPL. In the following, for R, S chain complete pers,
A, B admissible predicates on R, S respectively in the usual sense, and f : R * S in
CCPL, the notation f : A * B means for all x 2 A, f (x) # implies f(x) 2 B. In fact,
A * B defines an admissible predicate on the chain complete per R * S.

The next lemma is a consequence of a more general induction / coinduction principle
for recursive types as in (Pitts, 1996).

Lemma 7.12. Suppose oe(ff, fi) is a PolyFPC type in which ff occurs only negatively
and fi only positively, and A, B are admissible predicates on [[rec ff. oe(ff, ff)]]p in the
usual sense. Suppose further that for all maps e : [[rec ff. oe(ff, ff)]]p * [[rec ff. oe(ff, ff)]]p in
CCPL, if e : A * B then fold ffi oe(e, e) ffi unfold : A * B, where

unfold : [[rec ff. oe(ff, ff)]]p ! [[oe(rec ff. oe(ff, ff), rec ff. oe(ff, ff))]]p
is the isomorphism and fold = unfold-1. Then A ` B.

From polymorphism to models of polymorphic FPC 37

Proof. Consider the map
e 7! fold ffi oe(e, e) ffi unfold : (10)

([[rec ff. oe(ff, ff)]]p * [[rec ff. oe(ff, ff)]]p) ! ([[rec ff. oe(ff, ff)]]p * [[rec ff. oe(ff, ff)]]p)

since CCPL is equivalent to a subcategory of AP? (namely the full subcategory of
objects of the form L(R) for R a chain complete per) this map must have a fixed point,
since all endomaps in AP? have fixed points. Moreover, since A * B is an admissible
predicate it corresponds to an admissible predicate on the corresponding object in AP?,
and so by fixed point induction in AP?, the fixed point of (10) satisfies A * B.

Now, dinaturality of the solutions to recursive domain equations implies that the identity is the only fixed point of (10), and so A ` B as desired.

Lemma 7.10 will be proved by synchronous induction on the structure of oe with the
following Lemma.

Lemma 7.13. Suppose oe(~ff, ff, fi) is a type of PolyFPC in which ff occurs only negatively
and fi only positively. Suppose further we are given closed types ~o/ , o/-, o/+ and relations

~ae : AdmRelCCP([[~o/ ]]p, Val~o/ ),
ae-, ae0- : AdmRelCCP([[o/-]]p, Valo/-),

ae+, ae0+ : AdmRelCCP([[o/+]]p, Valo/+),

and maps e- : [[o/-]]p * [[o/-]]p, e+ : [[o/+]]p * [[o/+]]p in the model . If e- : ae0- * ae- and
e+ : ae+ * ae0+ in the sense that

8x, v. (x, v) 2 ae0- ^ e-(x) #oe (e-(x), v) 2 ae-8

x, v. (x, v) 2 ae+ ^ e+(x) #oe (e+(x), v) 2 ae0+

then

oe(~o/ , e-, e+) : 4~o/,o/-,o/+,~ae,ae-,ae+oe *4~o/,o/-,o/+,~ae,ae

0-,ae0+

oe

in the same sense

Proof of Lemma 7.10 and 7.13. As said, these are proved by synchronous structural
induction over oe.

We start with Lemma 7.10. The conditions listed in the lemma basically gives an
inductive definition, except for the case of recursive types. For this case we adapt the
proof from (Pitts, 1996).

We will assume that we have split the occurrences of ff in oe into positive and negative,
i.e., that we are working with a type oe(~ff, ff, fi) where ff occurs only negatively and fi
only positively. By rec ff. oe we shall mean ~ff ` rec ff. oe(~ff, ff, ff). For readability of the
next lines, we will write A for

AdmRelCCP([[rec ff. oe]]p([[~o/ ]]p), Valrec ff.oe[~o//~ff]).
Consider the map \Psi  : A * A ! A defined to map (ae-, ae+) to

(x, intro v). unfold(x) 4(~o/,rec ff.oe[~o//~ff],rec ff.oe[~o//~ff],~ae,ae-,ae+)oe v
By Lemma 7.13 (or one may say: the Lemma 7.13 part of the induction hypothesis) this

R. E. Mo/gelberg 38
is actually a functor

\Psi  : Aop * A ! A
with respect to the ordering on relations.

We need to construct a \Delta  such that \Psi (\Delta , \Delta ) = \Delta . Define \Phi  : Aop * A ! Aop * A
by \Phi (ae-, ae+) = (\Psi (ae+, ae-), \Psi (ae-, ae+)). Since A is closed under intersections, it is a
complete lattice, and so also Aop * A is a complete lattice. This means that since \Phi 
preserves the ordering, the Tarski-Knaster theorem states that there exists a least fixed
point (\Delta -, \Delta +) for \Phi . We aim to show that \Delta - = \Delta +.

By the symmetry of the definition of \Phi  we have \Phi (\Delta +, \Delta -) = (\Delta +, \Delta -) which implies
(\Delta -, \Delta +) <= (\Delta +, \Delta -), meaning \Delta + <= \Delta -, since (\Delta -, \Delta +) is the least fixed point.

Finally it remains to show that \Delta - <= \Delta +. By Lemma 7.12, it suffices to show that if
e : \Delta - * \Delta +, then also fold ffi oe(e, e) ffi unfold : \Delta - * \Delta +. So suppose e : \Delta - * \Delta + and
(x, intro v) 2 \Delta -. Since \Delta - = \Psi (\Delta +, \Delta -), this means that

unfold(x) 4(~o/,rec ff.oe[~o//~ff],rec ff.oe[~o//~ff],~ae,\Delta +,\Delta -)oe v
By Lemma 7.13, if oe(e, e) ffi unfold(x) #, then

oe(e, e) ffi unfold(x) 4(~o/,rec ff.oe[~o//~ff],rec ff.oe[~o//~ff],~ae,\Delta -,\Delta +)oe v
which since \Delta + = \Psi (\Delta -, \Delta +) implies \Delta +(fold ffi oe(e, e) ffi unfold(x), intro v).

Now for the proof of Lemma 7.13. As said, the proof is by induction on oe, but we
just prove the cases of the type constructors ! and recursive types. For the case of
oe ! oe0, suppose x 4(~o/,o/-,o/+,ae-,ae+)oe!oe0 *y. t. If (oe ! oe0)(id~o/ , e-, e+)(x) # we must show that

(oe ! oe0)(id~o/ , e-, e+)(x) 4(~o/,o/-,o/+,ae

0-,ae0+)

oe!oe0 *y. t. By definition (oe ! oe0)(id~o/ , e-, e+)(x) =
oe(id~o/ , e-, e+)ffixffioe0(id~o/ , e+, e-). Assume further given d, v such that d 4(~o/,o/+,o/-,ae

0+,ae0-)

oe v(where we have swapped appearances of + and - since (

oe ! oe0)(~o/, o/-, o/+) = oe(~o/ , o/+, o/-) !

oe0(~o/ , o/-, o/+)), and (oe ! oe0)(id~o/ , e-, e+)(x)(d) #. By the induction hypothesis on oe0,
oe0(id~o/ , e+, e-)(d) 4(~o/,o/+,o/-,ae+,ae-)oe0 v and so since x(oe0(id~o/ , e+, e-)(d)) #, there exists a v0
such that t[v/y] + v0 and x(oe0(id~o/ , e+, e-)(d)) 4(~o/,o/-,o/+,ae-,ae+)oe v0, and now the rest of
the proof follows from the induction hypothesis for oe.

For the recursive types, the pairs (ae-, ae+) and (ae-, ae+) respectively define functors \Phi ,
\Phi 0 of which 4(~o/,o/-,o/+,ae,ae-,ae+)rec ff.oe and 4(~o/,o/-,o/+,ae,ae-,ae+)rec ff.oe respectively are defined to be least
fixed points. By induction hypothesis rec ff. oe(e-, e+) defines a natural transformation
between the two, and so also a map between the fixed points.

Lemma 7.14. For any pair of PolyFPC types ~ff, ff ` oe and ~ff ` !, any ~o/ , ~ae,

4(~o/,![~o//~ff],~ae,4

~o/,~ae! )

oe () 4~o/,~aeoe[!/ff] .

As a consequence

x 4(~o/,~ae)rec ff.oe intro (v) () unfold(x) 4(~o/,~ae)oe[rec ff.oe/ff] v
Proof. Easy induction on oe.
Proof of Lemma 7.11 The proof is by induction on the structure of the term t.

From polymorphism to models of polymorphic FPC 39
t = xi. This case is trivial.
t = inl (t0). Here o/ = o/ 0 + o/00. Suppose [[t]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) #, and so by

induction there exists v such that t0[~o/ /~ff] + v and [[t0]][[~o/]]p(~d) 4(~o/,~ae)o/0 v. This implies
that t[~o/ /~ff] + inl v and [[t]][[~o/]]p(~d) 4(~o/,~ae)o/0+o/00 inl (v).
t = case t0 of inl x. t00 of inr x. t000. Let us say the whole expression has type o/, and t0

has type o/ 0 + o/ 00. Suppose [[t]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) # and so by induction
hypothesis there exists a v0 such that t0[~o//~ff][~v/~x] evaluates to either inl v0 or inr v0.
Let us say it evaluates to inl v0. Then further by induction hypothesis

[[t0]][[~o/]]p(~d) 4(~o/,~ae)o/0+o/00 inl v0.

This means that there exists an s such that [[t0]][[~o/]]p(~d) = inl s and s 4(~o/,~ae)o/0 v0. Since
[[t00]][[~o/]]p(~d, s) = [[t]][[~o/]]p(~d) #, the induction hypothesis on t00 tells us that there exists a
v such that t00[~o/ /~ff][~v/~x, v0/x] + v and

[[t00]][[~o/]]p(~d, s) 4(~o/,~ae)o/ v.
This implies t[~o/ /~ff][~v/~x] + v and [[t]][[~o/]]p(~d) 4(~o/,~ae)o/ v as desired.
t = ht0, t00i. Easy analysis as above.
t = ss1(t0). Easy analysis as above.
t = ?. Trivial.
t = *x : oe. t0. Suppose [[t]][[~o/]]p(~d) #. By Lemma 7.10, we must show that if given further v, d such that d 4(~o/,~ae)oe v and [[t]][[~o/]]p(~d)(d) #, then there exists a v0 such that
t0[~o/ /~ff][~v/~x, v/x] + v0 and [[t]][[~o/]]p(~d)(d) 4(~o/,~ae)o/ v0. But since [[t]][[~o/]]p(~d)(d) = [[t0]][[~o/]]p(~d, d),
this is just the induction hypothesis on t0.
t = t0(t00). Suppose [[t]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) # and [[t00]][[~o/]]p(~d) # and so by induction hypothesis there exists v, e such that t00[~o/ /~ff][~v/~x] + v, [[t00]][[~o/]]p(~d) 4(~o/,~ae)o/0 v and
t0[~o/ /~ff][~v/~x] + *x : o/ 0. e and [[t0]][[~o/]]p(~d) 4(~o/,~ae)o/0!o/ *x : o/ 0. e. This means, that since

[[t0]][[~o/]]p(~d)([[t00]][[~o/]]p(~d)) = [[t]][[~o/]]p(~d) #
there exists a v0 such that e[v/x] + v0, implying that t[~o/ /~ff][~v/~x] + v0 and

[[t]][[~o/]]p(~d) 4(~o/,~ae)o/ v0.
t = elim (t0). Suppose [[t]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) #, and by induction hypothesis

there exists a v0 such that t0[~o//~ff][~v/~x] + v0 and [[t0]][[~o/]]p(~d) 4(~o/,~ae)rec ff.oe v0. Since t0 is of
recursive type v0 = intro (v) for some v, which means that t[~o/ /~ff][~v/~x] + v and by
Lemma 7.14

[[t]][[~o/]]p(~d) 4(~o/,~ae)oe[rec ff.oe/ff] v

t = intro (t0). Suppose [[t]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) #, and by induction hypothesis

there exists a v0 such that t0[~o/ /~ff][~v/~x] + v0 and [[t0]][[~o/]]p(~d) 4(~o/,~ae)oe[rec ff.oe/ff] v0. This implies

t[~o/ /~ff][~v/~x] + intro v0 and by Lemma 7.14, [[t]][[~o/]]p(~d) 4(~o/,~ae)rec ff.oe intro v0.
t = t0(o/). In this case ~ff ` o/ and t0 is of polymorphic type, lets say t0 : Q ff. oe. Suppose

[[t0(o/ )]][[~o/]]p(~d) #. Then also [[t0]][[~o/]]p(~d) # and so the induction hypothesis tells us that

R. E. Mo/gelberg 40

there exists a t00 such that t0[~o/ /~ff][~v/~x] + \Lambda ff. t00 and [[t0]][[~o/]]p(~d) 4(~o/,~ae)Q ff.oe \Lambda ff. t00. By
Lemma 7.10, since [[t0]][[~o/]]p(~d)([[o/ [~o//~ff]]]) = [[t0(o/ )]][[~o/]]p(~d) # there exists a v such that

t00[o/[~o/ /~ff]/ff] + v
and

[[t0(o/ )]][[~o/]]p(~d) 4(~o/,o/[~o//~ff],~ae,4

(~o/,~ae)o/ )

oe v.

But t00[o/ [~o/ /~ff]/ff] + v implies t0(o/)[~o/ /~ff] + v, and since by Lemma 7.14

4(~o/,o/[~o//~ff],~ae,4

(~o/,~ae)o/ )

oe () 4(~o/,~ae)oe[o//ff]

we have proved that there exists a v such that

t0(o/ )[~o/ /~ff] + v
and

[[t0(o/ )]][[~o/]]p(~d) 4(~o/,~ae)oe[o//ff] v
as desired.
t = \Lambda ff. t0. Since t is a value, it is clear that [[t]][[~o/]]p(~d) # and t[~o/ /~ff][~v/~x] +. What we need

to show is that if we are given closed a type o/ 0 such that [[t]][[~o/]]p(~d)([[o/0]]p) # and an
admissible relation ae then there exist v such that

t0[~o/ /~ff][~v/~x][o/ 0/ff] + v
and

[[t]][[~o/]]p(~d)([[o/ 0]]p) 4(~o/,o/0,~ae,ae)oe v.
But since

[[t]][[~o/]]p(~d)([[o/ 0]]p) = [[t0]][[~o/]]p,[[o/0]]p(~d)
and

t0[~o/ /~ff][~v/~x][o/ 0/ff] = t0[~o/ /~ff, o/ 0/ff][~v/~x]
this is just the induction hypothesis for t0.

8. Reasoning using the model
The per-model of PolyFPC is parametric by construction, since the interpretations of
types have a built-in relational interpretation ([[~ff ` oe]]r) satisfying identity extension
([[~ff ` oe]]r(eq~R) = eq[[~ff`oe]]p( ~R)). This means that the model can be used to verify parametricity arguments about PolyFPC programs, as the next example shows.

Example 8.1. This is an adaptation of a standard argument for showing data abstraction results using parametricity. We will use a type for natural numbers, which can be
defined to be the recursive type nat = rec ff. ff + 1. Using standard arguments, one can
define terms representing the usual arithmetic operations on this type. In (Birkedal et al.,
2007; Birkedal et al., 2006b) it is shown that the type nat considered as a PILLY type

From polymorphism to models of polymorphic FPC 41
is interpreted as the admissible per {(?, ?)} [ {(n, n) | n 2 N}, for n a family of distinct
incomparable elements of D. This means that in the PolyFPC model [[nat]]p is the chain
complete per {(n, n) | n 2 N}.

Suppose we are writing an FPC program P computing a natural number, using an
abstract data type Counter with operations New : Counter, Increment : Counter !
Counter and Read : Counter ! nat. We could write P as a polymorphic program of
type Q

Counter. Counter ! (Counter ! Counter) ! (Counter ! nat) ! nat
which can later be instantiated with a concrete implementation of the type Counter. We
aim to show that the result of running P on the obvious implementation of Counter as
nat with New = 0, Increment being the successor function, and Read being the identity
is the same as running P on the intuitively equivalent implementation of Counter in
which Increment adds two to the counter, and Read is division by two (rounded up to
an integer). More precisely, we show that the programs

P nat 0 (*x : nat. x + 1) (*x : nat. x) (11)
P nat 0 (*x : nat. x + 2) (*x : nat. Div(x, 2)) (12)

are contextually equivalent, which in this case means that one terminates if the other
does and if they do terminate they return the same number. Here Div denotes an implementation of division.

Consider the relation A : AdmRelCCP([[nat]]p, [[nat]]p) given by the set {([n], [2n]) | n 2N}

. Clearly ([[0]], [[0]]) 2 A, and the pair ([[*x : nat. x + 1]], [[*x : nat. x + 2]]) maps elements
related in A to elements related in LA. Likewise the pair ([[*x : nat. x]], [[*x : nat. Div(x, 2)]])
maps elements related in A to elements related in L(eq[[nat]]p). We know that in the model
[[P ]] is related to itself in

L([[Q Counter. Counter ! (Counter ! Counter) ! (Counter ! nat) ! nat]]r)
This together with the above observations implies that the pair

([[P nat 0 (*x : nat. x + 1) (*x : nat. x)]], [[P nat 0 (*x : nat. x + 2) (*x : nat. Div(x, 2))]])
is in L[[nat]]r. Since nat is a closed type [[nat]]r is simply equality on [[nat]]p and so the
programs (11) and (12) have equal denotation and thus by adequacy (Corollary 7.8) are
contextually equivalent.

The use of parametricity in this model is unusual, because of the mix of parametricity and partiality. Very often, when reasoning with parametricity, one instantiates the
parametricity principle with graphs of functions, but since only total functions between
chain complete pers by their graphs give rise to well defined relations between the pers,
when reasoning about the graph of a PolyFPC-term, we must first prove that it is total.
Example 8.2 shows how the reasoning fails when we use graphs of partial functions.

Example 8.2. Consider the PolyFPC program P = \Lambda ff. *x : ff. (*y : ff. *)x, which has
type Q ff. ff ! 1. By parametricity one would expect that for any pair of types ff, fi, and
any relation R between them, if R(x, y) then P (ff)(x) = P (fi)(y). But consider for the

R. E. Mo/gelberg 42
relation R the graph of the function *x : 1. \Omega 1 : 1 ! 1, where \Omega 1 denotes an nonterminating program of type 1. Then R(?, \Omega 1), but P (1)(?) terminates, whereas P (1)(\Omega 1) does
not.

In future work, it will be interesting to lift the parametricity principle of the model to
a logic on PolyFPC. Corollary 7.8 should verify the logic in the sense that two terms that
are provably equal in the logic should be ground contextually equivalent. Since the logic
reasons about partial functions, it needs to include a termination predicate (-) #. The
mix of parametricity and partiality will have the following consequences on the logic.

-- Only total functions will have graphs that can be used to instantiate the parametricity

principle.
-- The relational interpretation of the ! type constructor will relate f to g in R ! S for

relations R and S iff f # () g #, and further for all (x, y) 2 R, f (x) # () g(y) #
and f (x) # implies S(f(x), g(y)).
-- The parametricity principle in the logic will say that two terms e, f of, say closed

type Q ff. oe, are ground contextually equivalent iff e # () f # and further, for all
pairs of types o/, o/ 0 and any relation R between them e(o/ ) # () f (o/ 0) # and e(o/ ) #
implies (e(o/), f (o/ 0)) 2 oe[R].

Besides the parametricity principle the logic should also include reasoning principles for
recursive types as in Pitts work (Pitts, 1996). These are verified by the model because,
as we have proved, the recursive types in the model are initial dialgebras.

Related recent work by Johann and Voigtl"ander (Voigtl"ander and Johann, 2006) develops similar parametricity principles using operational methods, but in a setting without
general recursive types as here.

Remark 8.3. The recursive types of PolyFPC were modelled here using encodings in
PILLY . In particular they were not encoded in PolyFPC using parametricity principles.
In fact, the usual encodings of inductive and coinductive types using parametricity known
from second order lambda calculus can not be used to encode recursive types in PolyFPC.
For example, the type Q ff. ff ! ff which in second order lambda calculus is a unit type,
is interpreted in our model as the three point per

{{?}, {h', ?i}, {h', 'i}}
Syntactically, this corresponds to the three observationally different terminating programs of this type:

\Lambda ff. \Omega ff!ff, \Lambda ff. *x : ff. \Omega ff, \Lambda ff. *x : ff. x.
where \Omega oe denotes the nonterminating program of type oe.

9. Conclusions
By showing that the solutions to recursive domain equations in the linear part of the
calculus PILLY can be used to interpret recursive types in languages with no linearity,
we have shown that PILLY with parametric polymorphism is a useful axiomatic setup

From polymorphism to models of polymorphic FPC 43
for domain theory. However, since PILLY is a type theory with polymorphism it would
be reasonable to expect that the constructed interpretation of FPC into PILLY could
be extended to PolyFPC, and indeed this would help justify the theory as a theory for
domain theory and polymorphism as this would be something that could not be done
in classical domain theory. Unfortunately the I see no way of doing so in general. The
problem seems to be that there is no way of quantifying over all coalgebras in PILLY .
The polymorphic types give a way of quantifying over all types and the type constructors
give a way of talking about all maps of type ff (!ff for a given type ff but there is no
way to quantify over all coalgebra maps on a given type in PILLY .

As we have seen, in the special case of the admissible per model the interpretation
of FPC does extend to full PolyFPC. This particular model is interesting for two other
reasons: the obtained PolyFPC model has a particularly simple presentation in this case
and it is computationally adequate. The latter result gives a strong connection between
the syntax and semantics of PolyFPC similar to that known for FPC in classical domain
theory, and it means that the reasoning principles for parametricity and recursive types
present in the model can be lifted to a logic for PolyFPC. The parametricity principle
in the model can be used to prove modularity principles for PolyFPC along the lines
of (Pitts, 2005).

As mentioned in the introduction, other models of languages with recursive types have
been suggested using pers over reflexive domains (Abadi and Plotkin, 1990). The models
mentioned in loc. cit. are based on a different category of pers namely admissible pers
satisfying a uniformity condition among other axioms, which makes an adaptation of
the solution of recursive domain equations from domain theory to the category of pers
in question possible. The definition of the category of pers used in the model presented
here is surprisingly simple in comparison because we use parametricity to solve recursive
domain equations. But the real difference between the two models is that this paper
presents a parametric model of PolyFPC.

References
Abadi, M. and Plotkin, G. (1990). A per model of polymorphism and recursive types. In 5th

Annual IEEE Symposium on Logic in Computer Science, pages 355-365. IEEE Computer
Society Press. 1, 9
Amadio, R. M. (1993). On the adequacy of per models. In Borzyszkowski, A. M. and Sokolowski,

S., editors, Mathematical Foundations of Computer Science 1993, 18th International Symposium, volume 711 of lncs, pages 222-231. Springer.
Barber, A. (1997). Linear Type Theories, Semantics and Action Calculi. PhD thesis, Edinburgh

University. 2
Benton, N., Bierman, G., de Paiva, V., and Hyland, M. (1992). Term assignment for intuitionistic

linear logic. Technical Report 262, Computer Laboratory, University of Cambridge. 2.1
Benton, P. (1995). A mixed linear and non-linear logic: Proofs, terms and models (preliminary

report). Technical report, University of Cambridge. 5
Birkedal, L. and Mo/gelberg, R. E. (2005). Categorical models of Abadi-Plotkin's logic for

parametricity. Mathematical Structures in Computer Science, 15(4):709-772. 2.1, 7
Birkedal, L., Mo/gelberg, R. E., and Petersen, R. L. (2006a). Linear Abadi & Plotkin logic.

Logical Methods in Computer Science, 2. 1, 2, 4.1, 4.1

R. E. Mo/gelberg 44
Birkedal, L., Mo/gelberg, R. E., and Petersen, R. L. (2006b). Parametric domain-theoretic models

of polymorphic intuitionistic / linear lambda calculus. Electr. Notes Theor. Comput. Sci,
155:191-217. 1, 8.1
Birkedal, L., Mo/gelberg, R. E., and Petersen, R. L. (2007). Domain theoretic models of parametric polymorphism. Theoretical Computer Science, 388. 1, 2.2, 2.2, 7, 8.1
Birkedal, L., Mo/gelberg, R. E., and Petersen, R. L. (2008). Category theoretic models of linear

Abadi & Plotkin logic. Theory and Application of Categories, 20:No. 7, 116-151, 2008. 1, 2.1,
4.1, 4.1
Fiore, M. (1996). Axiomatic Domain Theory in Categories of Partial Maps. Distinguished

Dissertations in Computer Science. Cambridge University Press. 3, 4, 4.2
Freyd, P. (1990a). Algebraically complete categories. In Carboni, A., Pedicchio, M. C., and

Rosolini, G., editors, Category Theory. Proceedings, Como 1990, volume 1488 of Lecture Notes
in Mathematics, pages 95-104. Springer-Verlag. 1, 4
Freyd, P. (1990b). Recursive types reduced to inductive types. In Proceedings of the fifth IEEE

Conference on Logic in Computer Science, pages 498-507. 1, 4
Freyd, P. (1991). Remarks on algebraically compact categories. In Fourman, M. P., Johnstone,

P., and Pitts, A. M., editors, Applications of Categories in Computer Science. Proceedings
of the LMS Symposium, Durham 1991, volume 177 of London Mathematical Society Lecture
Note Series, pages 95-106. Cambridge University Press. 1, 4
Girard, J.-Y. (1987). Linear logic. Theoretical Computer Science, 50:1-102. 1, 2
Hyland, J. (1988). A small complete category. Annals of Pure and Applied Logic, 40(2):135-165.

2.2
Hyland, J., Johnstone, P., and Pitts, A. (1980). Tripos theory. Mathematical Proceedings of the

Cambridge Philosophical Society 88. 2.2
Jacobs, B. (1994). Semantics of weakening and contraction. Annals of Pure and Applied Logic,

69:73-106. 4.2
Jacobs, B. (1999). Categorical Logic and Type Theory, volume 141 of Studies in Logic and the

Foundations of Mathematics. Elsevier Science Publishers B.V. 2.1, 2.2, 4.7, 7, 7
Johann, P. and Voigtl"ander, J. (2004). Free theorems in the presence of seq. In Proc. of 31st ACM

SIGPLAN-SIGACT Symp. on Principles of Programming Languages, POPL 2004, Venice,
Italy, 14-16 Jan. 2004, pages 99-110. ACM Press, New York. 1
Johnstone, P. T. (2002). Sketches of an elephant: a topos theory compendium. Vol. 2, volume 44

of Oxford Logic Guides. The Clarendon Press Oxford University Press, Oxford. 2.2, 7
Kock, A. (1970). Monads on symmetric monoidal closed categories. Archiv der Mathematik,

21:1-10.
Kock, A. (1972). Strong functors and monoidal monads. Archiv der Mathematik, XXIII:113-120.

5
Lambek, J. and Scott, P. (1986). Introduction to higher order categorical logic. Cambridge

University Press. 2.2, 7
Mac Lane, S. (1971). Categories for the Working Mathematician. Springer-Verlag. 2.1, 4.7, 4.2
Maneggia, P. (2004). Models of Linear Polymorphism. PhD thesis, University of Birmingham.

2.1
Maraist, J., Odersky, M., Turner, D. N., and Wadler, P. (1999). Call-by-name, call-by-value,

call-by-need and the linear lambda calculus. Theoretical Computer Science, 228(1-2):175-210.
1
Mo/gelberg, R. E. (2005). Categorical and domain theoretic models of parametric polymorphism.

PhD thesis, IT University of Copenhagen. 1, 2, 2.1, 2.2, 4.1

From polymorphism to models of polymorphic FPC 45
Pitts, A. (1996). Relational properties of domains. Information and Computation, 127:66-90.

7.1, 7.2, 7.2, 7.2, 8
Pitts, A. M. (2005). Typed operational reasoning. In Pierce, B. C., editor, Advanced Topics in

Types and Programming Languages, chapter 7, pages 245-289. The MIT Press. 1, 9
Plotkin, G. (1985). Lectures on predomains and partial functions. Notes for a course given at

the Center for the Study of Language and Information, Stanford. 3
Plotkin, G. (1993a). Second order type theory and recursion. Notes for a talk at the Scott Fest.

1
Plotkin, G. and Abadi, M. (1993). A logic for parametric polymorphism. In Typed lambda

calculi and applications (Utrecht, 1993), volume 664 of Lecture Notes in Comput. Sci., pages
361-375. Springer, Berlin.
Plotkin, G. D. (1993b). Type theory and recursion (extended abstract). In Proceedings, Eighth

Annual IEEE Symposium on Logic in Computer Science, page 374, Montreal, Canada. IEEE
Computer Society Press. 1
Reynolds, J. (1983). Types, abstraction, and parametric polymorphism. Information Processing,

83:513-523. 1
Robinson, E. and Rosolini, G. (1994). Reflexive graphs and parametric polymorphism. In

Abramsky, S., editor, Proc. 9th Symposium in Logic in Computer Science, pages 364-371,
Paris. I.E.E.E. Computer Society. 2.1, 2.2, #
Scott, D. (1970). Outline of a mathematical theory of computation. In 4th Annual Princeton

Conference on Information Sciences and Systems, pages 169-176. 2.2
Scott, D. (1976). Data types as lattices. SIAM Journal of Computing, 5(3):522-587. 2.2
Tse, S. and Zdancewic, S. (2004). Translating dependency into parametricity. j-SIGPLAN,

39(9):115-125. 1
van Oosten, J. (2008). Realizability; An Introduction to its Categorical Side, volume 152 of

Studies in Logic and the Foundations of Mathematics. Elsevier. 2.2
Voigtl"ander, J. and Johann, P. (2006). Selective strictness and parametricity in structural

operational semantics. Technical Report TUD-FI06-02, Technische Universit"at Dresden. 8

Appendix A. Proof of Proposition 5.4
We remind the reader that the action of Fcoalg on morphisms of coalgebras is denoted F
as these functors agree on morphisms, and so whenever we write Fcoalg(,) in this proof
we mean Fcoalg applied to a coalgebra , considered as an object in C!.

We first show that , is a coalgebra for the comonad. Notice first that ffl is a map of
F -algebras in the sense that

F (!uX. F (X))

Fcoalg(ffi)//

F(ffl) fflffl

!F (!uX. F (X))

!F (ffl) // !F (uX. F (X)) !in // !uX. F (X)

fflfflffl
F (uX. F (X)) in // uX. F (X)
commutes, since

in ffi F (ffl) = in ffi F (ffl) ffi ffl ffi Fcoalg(ffi)

= in ffi fflffi!F (ffl) ffi Fcoalg(ffi)
= fflffi!inffi!F (ffl) ffi Fcoalg(ffi).

R. E. Mo/gelberg 46
So ffl ffi , is a map of algebras from in to itself, which means that it is the identity since in
is the initial algebra.

To show the second equation !, ffi , = ffi ffi ,, we first show that ffi is a map of F -algebras
in the sense that the outer diagram in

F (!uX. F (X))

Fcoalg(ffi)//

F(ffi) fflffl

!F (!uX. F (X))

!F(ffi)fflffl

!F(ffl) // !F (uX. F (X)) !in // !uX. F (X)

ffifflffl
F (!!uX. F (X))

Fcoalg(ffi)// !

F (!!uX. F (X))

!!inffi!!F(ffl)ffi!Fcoalg(ffi)ffi!F(ffl) // !!

uX. F (X)

(13)

commutes. The inner diagram on the left commutes since ffiuX.F (X) is a morphism of
coalgebras from ffiuX.F (X) to ffi!uX.F (X), and so since Fcoalg is a functor, F (ffiuX.F(X)) is a
morphism of coalgebras from Fcoalg(ffiuX.F(X)) to Fcoalg(ffi!uX.F (X)). The outer diagram
commutes by the following computation

ffiffi!inffi!F (ffl) ffi Fcoalg(ffi) = !!inffi!!F (ffl) ffi ffi ffi Fcoalg(ffi)

= !!inffi!!F (ffl)ffi!Fcoalg(ffi) ffi Fcoalg(ffi)
= !!inffi!!F (ffl)ffi!Fcoalg(ffi)ffi!F (ffl)ffi!F (ffi) ffi Fcoalg(ffi)
= !!inffi!!F (ffl)ffi!Fcoalg(ffi)ffi!F (ffl) ffi Fcoalg(ffi) ffi F (ffi) .

(in the step from the first to the second line we have used that Fcoalg(ffi) is a coalgebra for
the comonad). Likewise we show that !, is a map of F -algebras, i.e., make the diagram

F (!uX. F (X))

Fcoalg(ffi)//

F(!,) fflffl

!F (!uX. F (X))

!F(!,)fflffl

!F(ffl) // !F (uX. F (X)) !in //

!F(,)fflffl

!uX. F (X)

!,fflffl
F (!!uX. F (X))

Fcoalg(ffi)// !

F (!!uX. F (X))

!F(ffl) // !F (!uX. F (X)) !!inffi!!F (ffl)ffi!Fcoalg(ffi) // !!uX. F (X)

(14)
commute. The inner diagram on the right is just ! of the defining diagram for , and
so commutes. The inner diagram in the middle is commutative by ffl being a natural
transformation. Finally, the inner diagram on the left is commutative as !, is a map of
coalgebras from ffiuX.F (X) to ffi!uX.F (X) (this is just naturality of ffi) and so F (!,) must be
a map of coalgebras from Fcoalg(ffiuX.F (X)) to Fcoalg(ffi!uX.F(X)).

From (13) and (14) we see that ffi ffi , and !, ffi , both are maps of F -algebras from in
to the same algebra, and so by initiality of in must be equal. We conclude that , is a
coalgebra for the comonad ! and thus an object of C! as desired.

To see that (3) commutes, notice first that since , is a map of coalgebras from , to
ffiuX.F (X) the diagram

F (uX. F (X))

F(,) //

Fcoalg(,)

fflffl

F (!uX. F (X))

Fcoalg(ffi)
fflffl!
F (uX. F (X))

!F(,) // !F (!uX. F (X))

From polymorphism to models of polymorphic FPC 47
commutes. Now,

!in ffi Fcoalg(,) = !inffi!F (ffl)ffi!F (,) ffi Fcoalg(,)

= !inffi!F (ffl) ffi Fcoalg(ffi) ffi F (,)
= , ffi in

(the last equation by the defining diagram for ,) proving commutativity of (3).

Finally, we must prove commutativity of (5) in the case where g is the unique map
making the top square commute. The bottom square is just ! applied to the top square
and so commutes. We show that the right hand side of the cube commutes, which shows
that g is a map of coalgebras from , to O/. From this it follows that F (g) is a map of
coalgebras from Fcoalg(,) to Fcoalg(ffi), i.e., commutativity of the left hand side of the
cube, since Fcoalg is a functor.

We prove equality of O/ ffi g and !g ffi , by showing that they are both F -algebra maps
from in to

F (!X)

Fcoalg(ffiX) // !

F (!X)

!F(ffl) // !F (X) !f // !X

and appealing to initiality of in. To see that !g ffi , is a map of algebras concider the
diagram

F (uX. F (X))

F(,) //

in

fflffl

F (!uX. F (X))

F(!g) //

Fcoalg(ffi)

fflffl

F (!X)

Fcoalg(ffiX)
fflffl!
F (!uX. F (X))

!F(!g) //

!F(ffl) fflffl

!F (!X)

!F(ffl)fflffl
!F (uX. F (X))

!F (g) //

!in fflffl

!F (X)

!f
fflffluX. F (X) , // !uX. F (X) !g // !X.

The outer diagram is the one we should prove commutes. The inner diagram on the left
is the defining diagram for ,, the topmost inner diagram to the right is the functor Fcoalg
applied to the coalgebra map !g from ffiuX.F (X) to ffiX (it is a coalgebra map by naturality
of ffi), and the two other inner diagrams on the right are !F (-) applied to the naturality
diagram for ffl and ! applied to the defining diagram for g respectively.

R. E. Mo/gelberg 48

To see that O/ ffi g is a map of F -algebras, concider the diagram

F (uX. F (X))

F (g) //

in

fflffl

F (X)

F(O/) //

Fcoalg(O/)

$$HHH
HHHH
HH

f
fflffl

F (!X)

Fcoalg(ffiX)
fflffl!
F (X)

IIII
IIII
I

IIII
IIII
I

!F (O/) // !F (!X)

!F(ffl)fflffl
!F (X)

!f
fflffluX. F (X) g // X O/ // !X

We need to show that the outer diagram commutes. The inner diagram on the left is the
defining diagram for g. The lower inner diagram on the right is the assumption that f is
a map of coalgebras (i.e., diagram (4)) and the topmost diagram is just Fcoalg applied
to the map of coalgebras O/ from O/ to ffi (which is a map of coalgebras since ffi ffi O/ =!O/ ffi O/
holds since O/ is assumed to be a coalgebra for the comonad).

As promised, we have shown that O/ ffi g and !g ffi , are both F -algebra maps from in to
the same F -algebra and thus by initiality of in must be equal. This concludes the proof
of Proposition 5.4.