

Colle`ge doctoral

No attribue' par la bibliothe`que

|_|_|_|_|_|_|_|_|_|_|

T H E` S E
pour obtenir le grade deDocteur de l'E'cole des Mines de Paris
Spe'cialite' << Informatique Temps Re'el, Robotique et Automatique >>

pre'sente'e et soutenue publiquement parAlexandre FREY

le 18 juin 2004
APPROCHE ALGE'BRIQUE DU TYPAGE D'UN LANGAGE A` LA MLAVEC OBJETS, SOUS-TYPAGE ET MULTI-ME'THODES

Directeur de the`se : Didier RE'MY

Jury
M. Thomas JENSEN Pre'sident
M. Didier RE'MY DirecteurM. Giuseppe CASTAGNA Rapporteur

M. Franc,ois FAGES RapporteurM. Dominique BOLIGNANO Examinateur
M. Guy COUSINEAU Examinateur

2

Copyright cr^ 2004, Alexandre Frey.

3
Remerciements

Je remercie Thomas Jensen de me faire l'honneur de pre'sider le jury de cette the`se.
Je tiens a` remercier tout particulie`rement Didier Re'my d'avoir accepte' de me guider pendant la
phase de re'daction de cette the`se. Tout en me laissant une totale liberte' sur le plan scientifique, il a su
me donner des conseils efficaces pour recentrer ce me'moire de the`se sur un sujet cohe'rent et de taille
raisonnable. De plus, sa relecture du manuscrit a e'te' extre^mement pre'cise.

Je remercie Ge'rard Berry et Franc,ois Bourdoncle pour m'avoir encadre' a` l'E'cole des Mines etJean Vuillemin

pour sa participation stimulante a` la partie expe'rimentale de ce travail (langage Jazz).
Ensemble, ils m'ont fait de'couvrir un vaste sujet, allant de la se'mantique des circuits synchrones au
typage des multi-me'thodes, et dont une petite partie seulement est repre'sente'e dans ce me'moire.

Je suis reconnaissant a` Giuseppe Castagna et Franc,ois Fages d'avoir bien voulu e^tre rapporteurs de cette the`se. Leurs remarques nombreuses et pe'ne'trantes m'ont ouvert les yeux sur certaines
subtilite's du syste`me de types pre'sente' ici et m'ont permis d'en ame'liorer la pre'sentation.

Guy Cousineau a bien voulu faire partie du jury. Je le remercie de l'inte're^t qu'il porte a` mon
travail.

Je remercie particulie`rement Dominique Bolignano pour ses encouragements constants et pour
m'avoir aide' a` concilier la re'daction de cette the`se et mon travail a` Trusted Logic. Je suis heureux
qu'il ait accepte' de faire partie de mon jury.

Je remercie Xavier Leroy, Franc,ois Pottier et Eduardo Gime'nez qui, a` diffe'rents stades de la
re'daction, ont relu le manuscrit, ce qui m'a permis de l'ame'liorer conside'rablement.

Je remercie tous les amis, colle`gues et membres de ma famille qui m'ont aide', soutenu et encourage' pendant ce travail.

Il est e'vident que je n'aurais pas pu terminer cette the`se sans l'appui inde'fectible de mon e'pouseMaria Vonica-Frey

. Je l'en remercie ici du fond du coeur.

4 5
Table des matie`res

Introduction 9
Notations 15
1 Syntaxe 19

1.1 Noyau ML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.2 Classes et objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.3 Constantes et primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.4 Me'thodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.5 Re'capitulatif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

2 Se'mantique 29

2.1 Noyau ML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2 Objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.3 Primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.4 Me'thodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

2.4.1 Filtrage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.4.2 L'ordre de pre'cision sur les motifs . . . . . . . . . . . . . . . . . . . . . . . 31
2.4.3 Projection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.4.4 Dispatch dynamique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.4.5 La re`gle d'e'valuation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.5 Contextes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.6 Erreurs de type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
2.7 Re'capitulatif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3 Typage alge'brique 45

3.1 Principe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.2 Types monomorphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.3 Types polymorphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.4 Environnements de typage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.5 Typage de let et de fix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.6 Sous-typage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.7 Typage des fonctions et de l'application . . . . . . . . . . . . . . . . . . . . . . . . 49
3.8 Typage des objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

3.8.1 L'abstraction d'une classe . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3.8.2 L'abstraction des champs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.8.3 Re`gles de typage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

6 TABLE DES MATIE`RES

3.9 Typage des primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.10 Se'paration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
3.11 Typage des me'thodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

3.11.1 Test de couverture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
3.11.2 Typage des cas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
3.11.3 Un dernier axiome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.12 Re'capitulatif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

4 Su^rete' du typage alge'brique 65

4.1 E'nonce' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.2 Pre'liminaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

4.2.1 Subsomption ge'ne'ralise'e . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.2.2 Simplification des de'rivations . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.2.3 Type des valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.3 Lemme de progression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.4 Lemme de substitution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.5 Lemme de pre'servation du typage . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.6 A` propos de l'induction sur les de'rivations infinies . . . . . . . . . . . . . . . . . . . 74

5 Annotations et ve'rification de types 77

5.1 Langage de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
5.2 Mode`les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
5.3 Le langage annote' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

5.3.1 Syntaxe des expressions annote'es . . . . . . . . . . . . . . . . . . . . . . . 81
5.3.2 Se'mantique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
5.4 Ve'rification de types semi-alge'brique . . . . . . . . . . . . . . . . . . . . . . . . . 83
5.5 Su^rete' du syste`me de ve'rification semi-alge'brique . . . . . . . . . . . . . . . . . . . 84
5.6 Re'capitulatif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

6 De la ve'rification de types aux contraintes 87

6.1 Repre'sentation et mode`le d'une repre'sentation . . . . . . . . . . . . . . . . . . . . . 88

6.1.1 Type des constantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
6.1.2 Type des primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.1.3 Type des motifs primitifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.1.4 Type des classes et des champs . . . . . . . . . . . . . . . . . . . . . . . . . 90
6.2 Proble`mes de typage e'le'mentaires . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

6.2.1 Implication de contraintes . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
6.2.2 Test de couverture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
6.3 E'nonce' du the'ore`me . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
6.4 Quelques de'finitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92

6.4.1 Relations de sous-typage ge'ne'ralise'es . . . . . . . . . . . . . . . . . . . . . 92
6.4.2 Abre'viations de contraintes . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
6.4.3 Contextes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
6.4.4 Proble`mes sous contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
6.5 Syste`me de types syntaxique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
6.6 Correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
6.7 Comple'tude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

TABLE DES MATIE`RES 7

6.8 Traitement des masquages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
6.9 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

7 Discussion 109

7.1 Mise en oeuvre de la formalisation . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
7.2 Monde ouvert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
7.3 Infe'rence de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
7.4 Travaux apparente's . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

Conclusions 119
Bibliographie 121

8 TABLE DES MATIE`RES9
Introduction

La plupart des langages de programmation modernes de'finissent une notion de typage : l'association d'un type a` chaque donne'e manipule'e par le programme permet de ve'rifier si une ope'ration
est bien de'finie sur les donne'es auxquelles elle est applique'e. On e'vite ainsi toute une classe d'erreurs de programmation, comme par exemple l'addition d'une chai^ne de caracte`res a` un entier, ou
bien la concate'nation deux entiers. Ces ope'rations incorrectes peuvent compromettre des proprie'te's
essentielles attendues du programme : correction, portabilite', stabilite' ou se'curite'. Le typage contribue
donc a` ame'liorer la qualite' du logiciel.

Le typage est dit statique quand il est re'alise' avant me^me l'exe'cution du programme, lors de
la compilation, de l'e'dition de lien ou bien lors de l'activation du programme. Quand le typage est
statique, les erreurs peuvent e^tre de'tecte'es inde'pendamment du chemin d'exe'cution effectivement emprunte' par le programme, ce qui offre un niveau de su^rete' supe'rieur au typage dynamique. Cela permet
aussi de re'aliser des gains de performance en temps et en espace par rapport au typage dynamique ou`
l'exe'cution de chaque ope'ration doit ve'rifier le type des arguments et ou` la repre'sentation en me'moire
de chaque objet manipule' doit transporter une information de type.

En contrepartie de ces avantages, le typage statique est ge'ne'ralement complexe a` mettre en oeuvre :
il faut en effet proce'der a` une analyse abstraite du programme suivant un ensemble de re`gles logiques
appele' syste`me de types qui aboutit a` accepter ou rejeter un programme. L'une des proprie'te's essentielles d'un syste`me de types est sa correction : aucun programme ne doit e^tre accepte' s'il peut mener a`
une ope'ration invalide, c'est-a`-dire non de'finie. Cependant, les contraintes d'imple'mentation (de'cidabilite', performances) ame`nent souvent a` rejeter des programmes en fait corrects, mais trop complexes
pour e^tre analyse's comme tel. Cette limitation conduit a` rechercher des syste`me de types toujours plus
expressifs, c'est-a`-dire qui rejettent de moins en moins de programmes qu'on juge utile de pouvoir
exprimer.

Dans cette recherche d'expressivite', le polymorphisme parame'trique [Str67, Str00, Hin69, Mil78]
a marque' une e'tape importante en autorisant l'e'criture de fonctions ge'ne'riques ope'rant sur des donne'es de diffe'rents types. Une fonction polymorphe peut ainsi manipuler certaines donne'es comme des
boi^tes noires seulement susceptibles d'e^tre transfe're'es d'une structure de donne'es a` une autre (tuple,
liste, arbre) ou bien d'e^tre passe'es en argument a` d'autres fonctions. On peut alors donner a` une telle
fonction un sche'ma de types incluant des parame`tres, chaque parame`tres pouvant varier inde'pendamment dans l'ensemble de tous les types possibles. Par exemple, un algorithme de tri, e'crit une fois pour
toute, peut s'appliquer a` une liste de n'importe quel type pourvu qu'une fonction de comparaison soit
fournie. Le polymorphisme parame'trique s'adapte ainsi particulie`rement bien aux langages ou` les
fonctions sont des donne'es comme les autres, c'est-a`-dire les langages applicatifs d'ordre supe'rieur,
notamment de la famille de ML.

10 INTRODUCTION

Il existe cependant d'autres formes de polymorphisme. Le polymorphisme dit << ad hoc >> permet
a` une me^me fonction d'e^tre de'finie sur plusieurs types tout en ayant un comportement diffe'rent sur
chaque type. Un exemple typique concerne les ope'rateurs arithme'tiques. Selon la nature des ope'randes
(entiers, flottants), l'ope'rateur d'addition par exemple s'exe'cute ainsi : si ses deux arguments sont deux
entiers, on calcule l'addition entie`re ; pour deux flottants, on calcule l'addition flottante ; enfin, si l'un
des argument est entier et l'autre flottant, on doit convertir l'argument entier en flottant puis retourner
la somme flottante avec l'autre argument.

Un autre genre de polymorphisme est pre'sent dans les langages de programmation centre's sur la
notion d'<< objet >>, comme C++ [Str91], Eiffel [Mey92] ou Java [GJSB00]. Dans la tradition impe'rative de ces langages, on conside`re qu'un objet est une sorte d'automate, dote' d'un e'tat interne (les
<< champs >>) et de fonctions de transition modifiant cet e'tat (les << me'thodes >>). Un objet est construit
sur le mode`le d'une << classe >> spe'cifiant le nom des champs et le corps des me'thodes. L'une des
grandes forces des langages a` objets est qu'ils permettent aux classes d'e^tre de'finies par he'ritage,
c'est-a`-dire en e'tendant d'autres classes e'crites pre'ce'demment et en en rede'finissant certaines de leurs
me'thodes. On peut ainsi e'crire du code ge'ne'rique qui manipule des objets sans connai^tre leur type
pre'cis, mais en sachant qu'ils de'rivent d'une classe donne'e et savent re'pondre aux me'thodes de cette
classe. Cette forme de polymorphisme est particulie`rement utile dans les syste`mes logiciels construits
incre'mentalement a` partir d'un noyau ge'ne'rique et soumis a` des changements fre'quents. On pense par
exemple aux interfaces graphiques ou` les diffe'rents objets graphiques (menus, fene^tres, boutons, etc.)
peuvent tous de'river d'une classe de base de'finissant un petit nombre de me'thodes (retourner la taille,
se re'afficher sur une portion de l'e'cran, etc.), ce qui permet de coder une fois pour toute la gestion de
l'affichage tout en autorisant l'ajout ulte'rieur d'objets graphiques varie's. Plus ge'ne'ralement, l'expe'rience montre que tout gros syste`me logiciel subit ne'cessairement des changements constants et qu'il
est important de pouvoir s'appuyer sur des classes ge'ne'riques et re'utilisables, ce qui explique que les
objets se sont impose's comme un outil incontournable de ge'nie logiciel.

Pour refle'ter les polymorphismes ad-hoc et d'he'ritage, un syste`me de types statique doit disposer
d'une notion de sous-typage. Partout ou` un objet d'un certain type est attendu, on autorise ainsi la
substitution par un objet d'un sous-type. Compare's au typage des langages comme ML, les syste`mes
de types des langages a` objets sont ge'ne'ralement assez frustres (pas d'infe'rence, ordre 1). Parfois, ils
ne sont me^me pas corrects et supposent que des ve'rifications dynamiques ont lieu a` l'exe'cution. Mais
ils inte`grent tous cette notion de sous-typage.

Combiner a` la fois les polymorphismes parame'triques et ad-hoc, le sous-typage, les objets et
les fonctions dans un me^me syste`me supe'rieurement expressif a motive' de nombreux travaux de recherche [Mit84, FM88, FM89, AC93, Re'm94, Pot98]. La plupart de ces travaux e'tudient les objets en
les codant sous la forme d'enregistrements extensibles, les me'thodes e'tant contenues dans ces enregistrements sous la forme de fonction ordinaires prenant en argument l'objet lui-me^me. Les syste`mes
de types re'sultant pre'sentent souvent une grande complexite' technique (types re'cursifs ou d'ordre
supe'rieur, contraintes de sous-typage, etc.). De plus, il ne parviennent qu'imparfaitement a` traiter un
proble`me parfois tre`s important : les me'thodes binaires [BCCC95].

Le proble`me des me'thodes binaires, ou plus ge'ne'ralement des multi-me'thodes, provient d'une
limitation intrinse`que de la vision traditionnelle des objets et par conse'quent de la mode'lisation par
enregistrements extensibles : quand une me'thode est appele'e sur un objet, le code effectivement exe'cute' de'pend de la classe de l'objet, ce qui permet la ge'ne'ricite' et l'extensivite' du programme. Ce
qui est parfois trop restrictif est qu'il de'pend uniquement de cette classe, ce qui ne permet pas, par
exemple, d'e'crire ses propres ope'rateurs arithme'tiques dont l'exe'cution de'pend simultane'ment des

INTRODUCTION 11
types de tous ses arguments.

Certains langages autorisent le programmeur a` e'crire de telles << multi-me'thodes >> sur ses propres
hie'rarchies d'objets extensibles, ce qui de'multiplie la souplesse et l'extensibilite' du langage. Parmi
ces langages, on peut citer CLOS [Ste90, Pae93], Cecil [Ct02, CL95] et Dylan [Sha96]. L'e'tude des
syste`mes de types statiques adapte's aux langages avec objets et multi-me'thodes (parfois appele'es
<< fonctions surcharge'es >>) a donne' lieu a` moins de travaux que l'approche avec enregistrements extensibles [WB89, CGL92, BM96, BM97].

L'origine de cette the`se : circuits, nombres et multi-me'thodes

Dans cette the`se, nous nous inte'ressons particulie`rement au syste`me ML6 de'crit dans [BM96].
Voici quelques caracte'ristiques de ce syste`me : ML6 est revendique' comme une extension naturelle de
ML avec objets et multi-me'thodes car les de'clarations de classes et les de'finitions de multi-me'thodes
sont vues comme une extension des types concrets et du filtrage de ML. Les sche'mas de types font
apparai^tre des contraintes de sous-typage sur les parame`tres de type et il n'y a pas besoin de types
re'cursifs.

Notre inte're^t pour les multi-me'thodes et le syste`me ML6 est issu de l'objectif initial de ce travail
de the`se : la rede'finition du langage 2Z [BVB94]. Ce langage d'expe'rimentation et d'enseignement est
spe'cialise' dans la description et la synthe`se de circuits synchrones arithme'tiques. Ses fonctionnalite's
sont similaires a` celles de VHDL [VHD93] ou Verilog [Ver01]. Sa particularite' est d'inte'grer des
types arithme'tiques comme les nombres 2-adiques [Vui94]. Le polymorphisme ad-hoc des ope'rateurs
arithme'tiques sur ces types est conside're' comme une caracte'ristique essentielle du langage car il
permet l'e'criture de fonctions ge'ne'riques qui soit provoque la synthe`se d'un circuit, soit la ve'rification
statique de ce circuit, selon le type des arguments passe's a` la fonction.

Dans sa version initiale, le langage 2Z disposait d'un syste`me de types ad-hoc, mal spe'cifie' et
qui ne permettait pas la de'finition de types utilisateur. L'un des objectifs principaux de la rede'finition
du langage e'tait d'ajouter les objets et de disposer d'un syste`me de types plus riche et mieux connu.
E'tant donne'e l'importance du polymorphisme des ope'rateurs arithme'tiques dans ce langage, on s'est
naturellement tourne' vers les multi-me'thodes et le syste`me ML6 a e'te' de'veloppe' a` cet effet. Le re'sultat de ce travail de re'imple'mentation et d'inte'gration du nouveau syste`me de types est le langage
Jazz [FBBC].

A` l'occasion de l'imple'mentation de Jazz, l'inte'gration de ML6 dans un vrai langage a pose' des
proble`mes pratiques et the'oriques. En effet, le syste`me de types s'est rapidement re've'le' trop rigide
pour le besoin du langage car les seules contraintes exprimables dans le syste`me sont des ine'galite's
de sous-typage et leur conjonction, ce qui les force a` ope'rer sur des hie'rarchies de classes connexes.
En pratique, il est tre`s vite apparu ne'cessaire de pouvoir exprimer des fonctions polymorphes sur
des hie'rarchies de classes se'pare'es. Par exemple, les ope'rateurs boole'ens devait pouvoir s'appliquer
a` tout e'le'ment d'une << alge`bre boole'enne >>, comme les nombres binaires ou les BDDs, alors que les
types de ces deux genres d'alge`bres ne sont pas en relation de sous-typage. Il fallait donc e'tendre les
contraintes exprimables avec des pre'dicats plus ge'ne'raux que le sous-typage.

Une autre faiblesse de ML6 est que son mode`le d'interpre'tation des contraintes est trop limite'. Il
pre'sente certes une simplicite' et des caracte'ristiques de'sirables. Par exemple, les types sont des termes
finis, contrairement aux approches des objets par enregistrements extensibles, ce qui se rapproche
beaucoup du mode`le initial de ML. Ensuite, la hie'rarchie de classes spe'cifie'e par le programmeur

12 INTRODUCTION
n'est pas fige'e : si un programme est bien type', alors il reste bien type' dans toutes les extensions de
la hie'rarchie courante, une proprie'te' essentielle pour capturer l'extensibilite' des syste`mes a` objets. En
pratique cependant, le mode`le de ML6 a des rigidite's ge^nantes. Le sous-typage est ne'cessairement
structurel, c'est-a`-dire que deux types ne peuvent e^tre compare's que s'ils ont le me^me squelette. Par
exemple, Listhinti est comparable a` Listhfloati (et en est un sous-type). Mais, Listhinti ne peut jamais
avoir un sous-type non parame'tre' de la forme ListInt. Par ailleurs, l'extensibilite' du monde introduite
dans ML6 est en fait trop ge'ne'rale. Elle conside`re que toute hie'rarchie de classe qui contient la
hie'rarchie au moment du typage en est une extension, alors que le langage Jazz ne permet l'extension
que par le bas (de'finition de sous-classes) et l'he'ritage simple. Du coup certains programmes sont
rejete' car ils sont incorrects dans une extension du monde qui n'est pas exprimable dans le langage,
ce qui est trop restrictif.

Certains de ces proble`mes ont e'te' traite's dans Jazz et dans des travaux connexes [Bon02b]. L'inte'gration dans la pre'sentation initiale de ML6 s'est alors re've'le'e difficile. En particulier, la preuve
de correction donne'e dans [BM96] repose sur une pre'sentation non standard de la se'mantique ope'rationnelle, qui est type'e et couple'e de fac,on complique'e avec le syste`me de types. C'est ge^nant car
l'exe'cutif de Jazz repose sur une machine virtuelle non type'e, tre`s similaire a` ce qu'on peut faire en
ML. Finalement, la complexite' intrinse`que du typage des multi-me'thodes en monde ouvert et le caracte`re ferme' et rigide de ML6 faisait qu'il e'tait souvent de'licat de se convaincre, me^me informellement,
de la correction de certaines extensions apporte'es a` Jazz.

Objectifs

Pour assurer une base saine au typage de Jazz, il nous apparai^t ne'cessaire de donner une nouvelle
pre'sentation du syste`me de types ML6, ce qui est l'objet de cette the`se.

A` cet effet, nous nous fixons les objectifs suivants :
1. donner une pre'sentation standard d'un calcul avec objets et multi-me'thodes proche du langage

Jazz afin de faciliter la compre'hension du syste`me et la comparaison avec des calculs existants ;

2. donner une formalisation souple et ouverte du syste`me de types capable d'inte'grer avec un minimum d'effort des extensions varie'es. En particulier, nous voulons que la preuve de correction,
partie la plus critique de la formalisation, puisse e^tre re'utilise'e facilement.

Contribution de cette the`se

Cette the`se apporte trois contributions principales.
Premie`rement, nous de'finissons une extension de ML avec objets et multi-me'thodes et nous lui
donnons une se'mantique ope'rationnelle non type'e et par re'duction, selon une approche e'prouve'e.
Dans ce langage, nous approfondissons l'analogie entre multi-me'thode et filtrage : gra^ce a` des motifs
autorisant le filtrage d'objets, les deux notions sont en fait pratiquement unifie'es.

Deuxie`mement, nous introduisons un syste`me de types ge'ne'rique pour ce langage. Ce syste`me utilise des alge`bres de types dont nous donnons une de'finition axiomatique. Cela nous permet de montrer
la correction du syste`me par une preuve elle-me^me ge'ne'rique et qui ne de'pend que des axiomes pose's
sur les alge`bres de types. La formalisation du syste`me de types met en oeuvre un traitement original

INTRODUCTION 13
du polymorphisme, base' sur une approche extensionnelle, les types polymorphes e'tant de simples
ensembles de types monomorphes. La preuve elle-me^me utilise cependant des techniques standard
(re'duction du sujet).

Troisie`mement, nous montrons comment re'duire un syste`me de ve'rification de types a` la re'solution de proble`mes simples (des contraintes) exprime's dans un langage logique du premier ordre.
La syntaxe et l'interpre'tation de cette syntaxe sont laisse'es ouvertes et doivent simplement respecter
quelques proprie'te's de base. Nous utilisons le cadre standard de la the'orie des mode`les pour re'aliser
cette re'duction.

Dans cette the`se, nous n'abordons pas la re'solution des proble`mes e'le'mentaires de typage, e'tape
indispensable pour obtenir un syste`me en pratique. Nous nous focalisons simplement sur la correction du typage et la re'duction du typage d'un programme a` la re'solution de proble`mes e'le'mentaires
logiques. Le traitement des contraintes (re'solution, implication, simplification) est en effet un the`me
de'ja` largement aborde' ailleurs [FM88, FM89, Tiu92, AC93, TS96, Fre97, Pot98, Sim03, KR03] alors
que le typage des multi-me'thodes est un sujet moins de'veloppe' et qui pre'sente des difficulte's spe'cifiques. Nous soutenons qu'une approche alge'brique peut permettre de re'utiliser les re'sultats existants
concernant les contraintes.

Finalement, l'approche alge'brique du typage des multi-me'thodes a` la ML6 en pre'sence d'un
monde ouvert sugge`re e'galement de nouvelles formulations de proble`mes de contraintes qui me'riteraient d'e^tre approfondies.

Plan de l'ouvrage

Le reste de cette the`se est organise'e comme suit. Dans le chapitre 1, nous donnons la syntaxe
du langage. Dans le chapitre 2, nous en donnons la se'mantique ope'rationnelle. Dans le chapitre 3,
nous introduisons les alge`bres de types et les re`gles d'un syste`me de types ge'ne'rique avec approche
extensionnelle du polymorphisme. Dans le chapitre 4, nous montrons la correction de ce syste`me de
types alge'brique vis-a`-vis de la se'mantique ope'rationnelle. Remarquant que ce syste`me alge'brique
n'est pas directement utilisable en pratique sans annotation du programmeur, nous introduisons a`
cet effet au chapitre 5 une notion tre`s ge'ne'rale de langage de types, ce qui nous permet d'e'crire les
annotations de type. Nous de'finissons ensuite un mode`le de typage comme une interpre'tation d'un
langage de types dans une alge`bre, ce qui nous permet de donner une spe'cification d'un syste`me
de ve'rification de types ope'rant sur des expressions annote'es par le programmeur. La correction du
syste`me est prouve'e par effacement des annotations et en utilisant le syste`me du chapitre 3. Dans un
dernier de'veloppement formel au chapitre 6, nous montrons comment la ve'rification de types peut e^tre
re'duite inde'pendamment du mode`le choisie en un ensemble de proble`mes e'le'mentaires (implications
de contraintes, tests de couvertures). Au chapitre 7, nous discutons plus informellement des proble`mes
et perspectives souleve's par ce travail. Nous abordons en particulier l'hypothe`se d'un monde ouvert
ainsi que l'infe'rence de type. Dans ce chapitre, nous comparons e'galement cette the`se avec d'autres
travaux apparente's.

14 INTRODUCTION15
Notations

Voici quelques notations utilise'es tout au long du document.

E kD E0 signifie que les ensembles E et E0 sont disjoints, c'est-a`-dire que E " E0 D ?. La notation
E1 kD * * * kD En signifie que les ensembles Ei sont disjoints deux-a`-deux.

Le domaine de de'finition d'une fonction f est note' dom. f /.
La notation a 7! b de'signe la fonction f de domaine {a} telle que f .a/ D b.
La restriction d'une fonction f a` un ensemble E est note'e f z' E.
Pour deux fonctions f et g, f l^ g est la fonction de domaine dom. f / [ dom.g/ telle que :

. f l^ g/.x/ D (g.x/ si x 2 dom.g/f .x / si x 62 dom.g/ et x 2 dom. f /

Les autres notations et de'finitions seront introduites au cours du texte en PETITES CAPITALES. On
en trouvera ci-dessous un index. Pour certains chapitres, constitue's d'une pre'sentation progressive des
notions suivie d'un re'capitulatif formel des de'finitions, le renvoi a` la de'finition formelle est marque'
en gras dans l'index.

e Expression non type'e . . . . . . . . . . . . . . . . . . . . . . . . . . 17,25
ij Motif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17,25
Vars Ensemble des identificateurs de variables . . . . . . . . . . . . . . . . 17,24
C Symbole de classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
C {`1 D e1I . . . I `n D en} Objet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
Classes Ensemble de toutes les classes . . . . . . . . . . . . . . . . . . . . . . 18,24
v Relation de sous-classement . . . . . . . . . . . . . . . . . . . . . . . 18,24
E'tiquettes Ensemble de toutes les e'tiquettes (noms des champs) . . . . . . . . . . 18,24
ChampsC Ensemble des champs d'une classe . . . . . . . . . . . . . . . . . . . 18,24
C *` Accesseur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
ClassesConcre`tes Ensemble des classes concre`tes . . . . . . . . . . . . . . . . . . . . . 19,24
Tuplen Classe des n-uples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
he1; . . . ; eni Tuple d'expressions (abre'viation) . . . . . . . . . . . . . . . . . . . . . . 20

16 NOTATIONS
a Symbole de constante (valeur primitive) . . . . . . . . . . . . . . . . . 21,24
PrimVals Ensemble des valeurs primitives . . . . . . . . . . . . . . . . . . . . . 21,24

f Symbole d'ope'rateur primitif . . . . . . . . . . . . . . . . . . . . . . 21,24
PrimOps Ensemble des ope'rateurs primitifs . . . . . . . . . . . . . . . . . . . . 21,24
| f | Arite' de l'ope'rateur f . . . . . . . . . . . . . . . . . . . . . . . . . . 21,24
meth {ij1 ) e1I . . . I ijk ) ek} Me'thode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
ij j ) e j Cas d'une me'thode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
_ Motif universel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22,25
$ Motif primitif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22,24
C {`1 D ij1I . . . I `n D ijn} Motif de sous-classe . . . . . . . . . . . . . . . . . . . . . . . 22,25
#C {`1 D ij1I . . . I `n D ijn} Motif de classe exacte . . . . . . . . . . . . . . . . . . . . . . 22,25
ij as x Motif lieur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22,25
PrimOpsn Ensemble des ope'rateurs primitifs n-aires . . . . . . . . . . . . . . . . . . 24
PrimMotifs Ensemble des motifs primitifs . . . . . . . . . . . . . . . . . . . . . . . . 24
C Structure de classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
fv.ij / Variables libres d'un motif . . . . . . . . . . . . . . . . . . . . . . . . . . 25
Motifs Ensemble de tous les motifs . . . . . . . . . . . . . . . . . . . . . . . . . 25
Exprs Ensemble de toutes les expressions . . . . . . . . . . . . . . . . . . . . . 25
fv.e/ Variables libres d'une expression . . . . . . . . . . . . . . . . . . . . . . 26
e -! e0 Se'mantique ope'rationnelle . . . . . . . . . . . . . . . . . . . . . . . . 27,40
[x 7! e2]e1 Substitution simple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
filtre.e; ij / Relation de filtrage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28,36

V Valeur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28,36
te^te.V / Noeud de te^te d'une valeur . . . . . . . . . . . . . . . . . . . . . . . . 28,36
6 Ordre de pre'cision sur les motifs . . . . . . . . . . . . . . . . . . . . . 30,37
e # ij Projection d'une expression sur un motif . . . . . . . . . . . . . . . . 31,37
dispatch.eI ij1I . . . I ijk/ Dispatch dynamique . . . . . . . . . . . . . . . . . . . . . . . . . 31,38
[S]e Substitution multiple . . . . . . . . . . . . . . . . . . . . . . . . . . . 32,38

E Contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32,39
[] Trou d'un contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
e -! erreur Erreur de type ope'rationnelle imme'diate . . . . . . . . . . . . . . . . . 35,40
e -!? erreur Erreur de type ope'rationnelle . . . . . . . . . . . . . . . . . . . . . . . . 35

NOTATIONS 17

S Substitution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

R Renommage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
R.X1; X2/ Ge'ne'rateur de renommage . . . . . . . . . . . . . . . . . . . . . . . . . . 38
A Alge`bre de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44,58
t; u; . . . Monotypes alge'briques . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

G ` e : T Jugement de typage alge'brique . . . . . . . . . . . . . . . . . . . . . 44,59

T; U; . . . Polytypes alge'briques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
G Environnement de typage alge'brique . . . . . . . . . . . . . . . . . . . . . 46
6 Relation de sous-typage alge'brique . . . . . . . . . . . . . . . . . . . 47,58
t ! u Type fonctionnel alge'brique . . . . . . . . . . . . . . . . . . . . . . . 47,58
#C Abstraction alge'brique d'une classe . . . . . . . . . . . . . . . . . . . 48,58
C *` Abstraction alge'brique d'un champ . . . . . . . . . . . . . . . . . . . 49,58
a Abstraction alge'brique d'une constante a . . . . . . . . . . . . . . . . 51,58
A0 Alge`bre primitive . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51,58
t0 Type primitif (e'le'ment de A0) . . . . . . . . . . . . . . . . . . . . . . . . 51
t0 De'notation d'un type primitif t0 . . . . . . . . . . . . . . . . . . . . . 51,58
6? Pre'dicat de se'paration . . . . . . . . . . . . . . . . . . . . . . . . . . 52,58
fun Ensemble des types alge'briques fonctionnels . . . . . . . . . . . . . . 52,58
Classes Ensemble des types alge'briques d'objets . . . . . . . . . . . . . . . . . 52,58
t ! t0 FG ij1I . . . I ijk Test de couverture alge'brique . . . . . . . . . . . . . . . . . . . . . . . 54
etest Expression de test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

G ` ij ) e : t ! t0 Jugement de typage alge'brique d'un cas . . . . . . . . . . . . . . . . 54,59
t ` ij : t00I G0 Jugement de typage alge'brique d'un motif . . . . . . . . . . . . . . . . 55,60
"X Clotu^re d'un ensemble de monotypes par le haut . . . . . . . . . . . . . . 58
#X Clotu^re d'un ensemble de monotypes par le bas . . . . . . . . . . . . . . . 58
" Expression annote'e . . . . . . . . . . . . . . . . . . . . . . . . . . . 59,80
6] Pre'-ordre de sous-typage ge'ne'ralise' . . . . . . . . . . . . . . . . . . . . . 63

G `0 e : T Jugement de typage simple . . . . . . . . . . . . . . . . . . . . . . . . . 64
VarsType Ensemble des variables de types . . . . . . . . . . . . . . . . . . . . . . . 76
o""; r'; . . . Variables de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
L Langage de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
c; c0; . . . Symboles de constructeurs de types syntaxiques . . . . . . . . . . . . . . . 76

18 NOTATIONS

p; p0; . . . Symboles de pre'dicats de types syntaxiques . . . . . . . . . . . . . . . . . 76
|c|, | p| Arite' d'un constructeur ou pre'dicat syntaxique . . . . . . . . . . . . . . . 76
#; # 0; . . . Monotypes syntaxiques . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
u* Contrainte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
V Ensemble fini de variables de types . . . . . . . . . . . . . . . . . . . . . 76
? D 8V : u* . # Sche'ma de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
ftv.# /; ftv.u*/; ftv.? / Ensemble des variables de types libres . . . . . . . . . . . . . . . . . . . 77
M Mode`le d'un langage de types . . . . . . . . . . . . . . . . . . . . . . . . 78

^!; !; . . . Valuations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
!J*KM Interpre'tations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
L"M Effacement des annotations de type . . . . . . . . . . . . . . . . . . . . . 81

^!I G ` " : T Jugement de typage semi-alge'brique . . . . . . . . . . . . . . . . . . . 81,82e
a Repre'sentation syntaxique du type de la constante a . . . . . . . . . . . . . 86e

f Repre'sentation syntaxique du type de la primitive f . . . . . . . . . . . . . 86e
$ Repre'sentation syntaxique du type du motif primitif $ . . . . . . . . . . . 86f
#C Repre'sentation syntaxique de la classe C . . . . . . . . . . . . . . . . . . 86g
C *` Repre'sentation syntaxique du champ C *` . . . . . . . . . . . . . . . . . . 86
M |H 8V . u*1 ? u*2 Proble`me d'implication de contrainte . . . . . . . . . . . . . . . . . . . . 89
M |H ? FG ij1I . . . I ijk Proble`me de test de couverture . . . . . . . . . . . . . . . . . . . . . . 89

19
Chapitre 1
Syntaxe

Ce chapitre a pour objectif de pre'senter la syntaxe du langage e'tudie' et sa se'mantique ope'rationnelle intuitive.

Le langage est forme' d'EXPRESSIONS engendre'es par la grammaire suivante :

Expressions e ::D x Identificateur

| e e Application
| fun x ) e Fonction
| let x D e in e De'finition locale
| fix x ) e De'finition re'cursive
| a Constante
| f Ope'ration primitive
| C {` D eI . . . I ` D e} Objet
| C *` Accesseur de champs
| meth {ij ) eI . . . I ij ) e} Multi-me'thode de'finie cas par cas
Motifs ij ::D _ Motif universel

| $ Motif primitif
| C {` D ij I . . . I ` D ij } Motif de sous-classe
| #C {` D ij I . . . I ` D ij } Motif de classe exacte
| ij as x Motif lieur

1.1 Noyau ML

Dans cette grammaire, x de'signe un IDENTIFICATEUR de variable, pris dans un ensemble Vars
suppose' infini. Les quatre premie`res productions (identificateur, application, fun et let) de'finissent
le noyau ML habituel. La strate'gie d'e'valuation n'est pas fixe'e car les re'sultats de cette the`se en sont
inde'pendants. Elle peut e^tre en appel par nom ou en appel par valeur.

L'expression fix x ) e de'finit re'cursivement une valeur e'gale a` l'expression e dans laquelle
l'identificateur x est conside're' lie' a` la valeur en train d'e^tre de'finie. Par exemple, la fonction factorielle

20 CHAPITRE 1. SYNTAXE
peut s'e'crire ainsi :

fix Fact ) fun n ) if .n 6 0/ then 1 else .n * .Fact .n - 1///

Par souci de simplification, nous avons se'pare' la de'finition d'une valeur re'cursive de son utilisation. La construction let rec est donc une simple abre'viation :

let rec x D e1 in e2 t^ let x D .fix x ) e1/ in e2

Si la se'mantique est en appel par nom, la construction fix n'est pas limite'e a` la de'finition de
fonctions re'cursives. On peut aussi s'en servir pour construire des structures infinies re'cursives. Par
exemple, la liste infinie compose'e du seul e'le'ment 1 peut s'e'crire comme suit :

fix l ) 1 :: l
De me^me, la liste infinie des nombres entiers peut se coder ainsi :

.fix seq ) fun i ) i :: seq .i C 1// 0

1.2 Classes et objets

L'expression C {`1 D e1I . . . I `n D en} repre'sente un OBJET construit avec la classe C.
L'ensemble des CLASSES doit e^tre spe'cifie' par le programmeur d'une fac,on non pre'cise'e ici. Nous
supposerons simplement donne' l'ensemble des classes, note' Classes. Cet ensemble est organise' en
hie'rarchie, c'est-a`-dire qu'il est muni d'un ordre partiel v de SOUS-CLASSEMENT1. Quand C0 v C,
on dit que C0 est une SOUS-CLASSE de C ou bien que C est une SUPER-CLASSE de C0.

Chaque classe C contient un ensemble fini e'ventuellement vide de CHAMPS. Ceux-ci sont identifie's par leur nom, tire' d'un ensemble infini d'e'tiquettes fixe' une fois pour toutes et note' E'tiquettes.
L'ensemble des champs d'une classe C est note' ChampsC . Les classes ne comprennent que des
champs, a` l'exclusion des me'thodes qui sont de'finies en dehors des classes (voir section 1.4).

Quand on construit un objet, la valeur de tous les champs de cette classe doit e^tre donne'e. Pour que
l'expression C {`1 D e1I . . . I `n D en} soit bien forme'e, on demande donc que les labels `1; . . . ; `n
repre'sentent exactement l'ensemble ChampsC et qu'ils soient distincts deux a` deux. L'ordre d'apparition des champs dans un objet n'est pas important. On conside'rera par exemple que les deux
expressions suivantes sont identiques :

Point {x D 1I y D 2} et Point {y D 2I x D 1}

L'acce`s aux champs d'un objet se fait avec l'expression fonctionnelle C *` qui prend en argument
un objet construit avec une sous-classe quelconque C0 de C et qui renvoie la valeur du champ de
cet objet nomme' `. On voit donc qu'on peut acce'der a` un objet sans connai^tre sa classe pre'cise, a`
condition d'en connai^tre une super-classe. C'est une proprie'te' cle' des langages a` objets qui permet
l'e'criture de fonction ge'ne'rique sur les objets. Pour que cette proprie'te' soit bien fonde'e, il faut bien su^r

1Tous les re'sultats de cette the`se restent corrects si la relation de sous-classement est simplement un pre'ordre, c'est-a`-dire
n'est pas suppose'e antisyme'trique.

1.2. CLASSES ET OBJETS 21
que les champs soit he'rite's d'une classe a` une sous-classe. Nous posons donc en axiome la proprie'te'
suivante :

C0 v C ) ChampsC t, ChampsC0

Exemple. Voici un exemple de hie'rarchie de classes qui illustre l'he'ritage des champs (ceux-ci sont
repre'sente's a` co^te' des classes) :

ObjetColore'{c} Point{x; y}

PointColore'{x; y; c} Point3D{x; y; z}

Point3DColore'{x; y; z; c}

e^

Remarque. Contrairement a` la plupart des formalisations de langages a` objets, notons bien que l'acce`s
a` un champ ne peut se faire sans mentionner une super-classe de l'objet attendu. En d'autres termes,
il n'est pas possible d'acce'der a` un champ simplement en e'crivant e*`, inde'pendamment de la classe
de e.

Ce choix, he'rite' de ML6, se justifie d'abord par des conside'rations sur la conception d'un langage
de programmation. Imaginons par exemple qu'en plus de la hie'rarchie ci-dessus, le programmeur ait
de'fini la classe Cercle contenant les champs c et r, de'signant respectivement le centre du cercle (unPoint

) et son rayon. Si elle e'tait autorise'e, l'expression e*c pre'senterait alors un polymorphisme trop
ge'ne'ral pour ne pas e^tre ge^nant. En effet, on ne voudra certainement jamais acce'der par une expression
unique a` des choses aussi diffe'rentes que la couleur d'un objet ou le centre d'un cercle. La syntaxe que
nous pre'sentons ici limite de'libe're'ment l'expressivite' du langage pour e'viter ce genre de situations et
force le programmeur a` pre'ciser explicitement son intention.

Notons aussi que cette restriction n'est pas de'finitive. Nous pensons qu'il est souvent possible
de conside'rer le langage de ce chapitre comme un langage primitif dans lequel on re'e'crit un langage
source donne' disposant de l'acce`s inconditionnel aux champs. Par exemple, conside'rons un langage
source ou` le programmeur ne de'clare aucune classe mais repose sur un syste`me d'enregistrements
extensibles. On peut implicitement de'clarer une classe pour chaque ensemble possible de champs
les hie'rarchiser en suivant l'ordre d'extension des enregistrements (C0 v C ssi C t, C0). L'acce`s
inconditionnel au champ ` peut alors s'e'crire en utilisant l'accesseur explicite {`}*`. On voit donc
que le langage source peut dans ce cas facilement se coder dans notre langage. Dans d'autres cas, on
peut e'galement utiliser les me'thodes (voir section 1.4) qui fournissent entre autres un moyen de mixer
arbitrairement dans une me^me fonction des acce`s a` des champs quelconques. e^

Il est utile d'interdire l'utilisation de certaines classes pour la construction d'objets et de limiter
leur utilisation pour l'acce`s aux champs. Une telle classe est dite ABSTRAITE et une classe effectivement autorise'e a` construire un objet est dite CONCRE`TE. L'ensemble de toutes les classes concre`tes
est note' ClassesConcre`tes t, Classes et sa de'finition est laisse' a` l'initiative du programmeur qui
pourra par exemple utiliser le mot cle' abstract pour de'signer une classe abstraite lors de sa de'claration.

Exemple. Pour de'finir le type concret des listes chai^ne'es, le programmeur peut typiquement introduire

22 CHAPITRE 1. SYNTAXE
la hie'rarchie suivante, ou` List est une classe abstraite et Cons et Nil sont deux classes concre`tes :

List{}

Cons{head; tail} Nil{}
La liste [1; 2; 3] s'e'crit alors de la fac,on suivante :

Cons l^head D 1I tail D Cons l^head D 2I tail D Cons {head D 3I tail D Nil {}}l/l/

Pour alle'ger les notations, on se permettra les abre'viations classiques suivantes :

e1 :: e2 t^ Cons {head D e1I tail D e2}

[] t^ Nil {}
[e1; . . . ;en] t^ e1 :: .e2 :: .. . . :: .en :: []/ . . . // e^

Pour tout entier n ? 0, on suppose qu'il existe une classe concre`te Tuplen dont l'ensemble
des champs est {1; . . . ; n}. Cette classe permet de manipuler des tuples d'expressions en utilisant
l'abre'viation suivante :

he1; . . . ; eni t^ Tuplen {1 D e1I . . . I n D en}
Les classes de tuples sont utiles pour pouvoir e'crire des de'finitions multiples ou des fonctions ou
me'thodes a` plusieurs arguments. Par exemple, voici une fac,on d'e'crire des de'finitions mutuellement
re'cursives :

let rec

x1 D e1 and

...

xn D en
in

e

9?????????=
?????????; t^

8??????????
????????????!

?????????????
?????????:

let x D

fix x )

let x1 D .Tuplen *1 x/ in

...

let xn D .Tuplen *n x/ in

he1; . . . ; eni
in

let x1 D .Tuplen *1 x/ in

...

let xn D .Tuplen *n x/ in

e

De me^me, les fonctions a` plusieurs arguments seront note'es de pre'fe'rence :

fun hx1; . . . ; xni ) e t^ fun x ) 0BBBB@

let x1 D .Tuplen *1 x/ in

...

let xn D .Tuplen *n x/ in

e

1CCCC
A

1.3. CONSTANTES ET PRIMITIVES 23

Nous voyons ici quelques codages inte'ressants qui utilisent les classes de tuple. Ces classes seront
aussi utilise'es pour les arguments des primitives et pour les multi-me'thodes. Pour assurer la validite' de
ces codages, il est important que les classes de tuple soient minimales dans l'ordre de sous-classement,
de sorte que l'accesseur Tuplen *i ne puisse e^tre applique' qu'a` un tuple de taille n et a` aucun autre
objet. Nous faisons de cette proprie'te' essentielle un axiome de toute structure de classes2 :

8C 2 Classes; C v Tuplen ) C D Tuplen

Remarque. Une limitation importante du langage est l'absence d'effets de bord : il n'y a pas d'ope'rateur de remplacement d'un champ. La nature e'quationnelle et en appel par nom du langage Jazz
justifie cette limitation. La pre'sence d'effets de bord seraient toutefois une extension inte'ressante a`
conside'rer, notamment pour ses conse'quences sur le syste`me de types. e^

1.3 Constantes et primitives

Les constantes, de'signe'es par la lettre a, sont prises dans un ensemble PrimVals de valeurs primitives fixe' a` l'avance. Les ope'rations primitives sont note'es avec la lettre f et sont prises dans un
ensemble PrimOps de fonctions partielles qui ope`rent sur l'ensemble des valeurs primitives. On note
| f | l'arite' de l'ope'rateur f , c'est-a`-dire le nombre d'arguments qu'il accepte.

Exemple. Pour fixer les ide'es, on peut supposer que les valeurs primitives comprennent les entiers
rationnels et les boole'ens : PrimVals D Q [ {true; false}. Les rationnels pourront e^tre repre'sente's
par un couple d'entiers relatifs n/d irre'ductibles.

Les ope'rations primitives pourront e^tre l'addition C, la multiplication * et les tests de comparaison 6 et D toutes d'arite' 2 et de domaine Q.

On se permettra d'utiliser une notation infixe pour certaines ope'rations. Par exemple, e1 C e2 sera
une abre'viation pour C he1; e2i. e^

Contexte. Notons que les ope'rations primitives ne sont pas currifie'es, c'est-a`-dire que l'addition de
deux expression e1 et e2 s'e'crit C he1; e2i et non pas .C e1/ e2. Les pre'sentations traditionnelles des
petits langages fonctionnels utilisent ge'ne'ralement la forme currifie'e pour toutes les fonctions, ce qui
permet de se passer des constructeurs de tuple ou de fonction n-aires natives sans perdre en expressivite'. En contrepartie, la de'finition de la se'mantique est le'ge`rement plus complique'e : il faut attendre
qu'une ope'ration primitive soit applique'e au bon nombre d'argument pour pouvoir re'duire l'application et il faut tenir compte du fait qu'une primitive partiellement applique'e est une valeur fonctionnelle. D'un autre co^te', dans la section suivante, nous allons conside'rer les multi-me'thodes comme
des me'thodes a` un argument qui peuvent utiliser des motifs tuple pour extraire plusieurs expressions
de leur argument. On utilise donc naturellement les tuples pour repre'senter les multiples arguments
d'une multi-me'thode. Par re'gularite', nous avons donc privile'gie' les fonctions n-aires, suivant en cela
l'exemple du langage SML/NJ [MTHM97] pluto^t que d'OCAML [LDGC03]. e^

2En Java, on dirait que la classe Tuplen est << finale >>.

24 CHAPITRE 1. SYNTAXE
1.4 Me'thodes

L'expression meth {ij1 ) e1I . . . I ijk ) ek} est une ME'THODE. C'est une expression fonctionnelle qui est de'finie par une liste de CAS de la forme ij j ) e j . Chaque cas d'une me'thode est conditionne' par un MOTIF ij j qui sert a` FILTRER l'argument passe' a` la me'thode et a` lier des identificateurs
avec certaines sous-expressions de l'argument de la me'thode.

Le MOTIF UNIVERSEL _ accepte toute valeur (wildcard). Un MOTIF PRIMITIF $ filtre les valeurs
primitives. Nous supposons donne' une fois pour toutes pour chaque motif primitif l'ensemble des
constantes accepte'es par ce motif.

Le motif C {`1 D ij1I . . . I `n D ijn} accepte les objets construits avec la classe C ou l'une de ses
sous-classes. Les e'tiquettes {`1; . . . ; `n} doivent repre'senter les champs de la classe C et les motifs
ij1; . . . ; ijn servent a` contraindre la valeur des champs de l'objet. Si on ne veut pas poser de contrainte
particulie`re sur un champ `i , il suffit d'utiliser _ pour le motif iji . Le motif #C {`1 D ij1I . . . I `n D ijn}
accepte uniquement les objets de la classe C et pas de ses sous-classes.

Enfin le motif ij as x permet de lier l'identificateur x avec la valeur filtre'e par ij a` l'exe'cution.
On ne conside`re que des motifs LINE'AIRES, c'est-a`-dire ou` les variables lie'es n'apparaissent qu'une
fois au plus.

Exemple. Si PrimVals contient les entiers rationnels et les boole'ens, on peut supposer que les motifs
primitifs suivants sont disponibles :

- le motif a qui accepte exactement la valeur a ;
- le motif rat qui accepte tous les nombres rationnels (y compris les nombres entiers) ;
- le motif int qui accepte tous les nombres entiers relatifs (sous-ensemble Z de Q) ;
- le motif bool qui accepte les deux boole'ens true et false. e^

L'exe'cution d'une me'thode consiste a` choisir le cas le plus pre'cis parmi tous les motifs ij j qui
filtrent l'argument de la me'thode (strate'gie << best match >>). La me'thode toute entie`re est alors e'quivalente a` l'expression e j ou` on remplace les variables lie'es dans ij j par les sous-expressions correspondantes de l'argument de la me'thode. Cette ope'ration est appele'e DISPATCH DYNAMIQUE. Elle
suppose donc qu'on de'finisse une relation de comparaison de pre'cision entre motifs. Cette relation est
telle que plus un motif contraint les valeurs filtre'es, plus il est pre'cis. Par exemple, le motif universel
qui ne pose aucune contrainte est le moins pre'cis de tous les motifs. Le motif #C {. . .} est plus pre'cis
que C {. . .} car il n'accepte que les objets exactement construits avec la classe C, alors que C {. . .}
accepte aussi les sous-classes.

Exemple. Voici par exemple la me'thode qui renvoie le carre' de la norme d'un point :

meth {

Point {x D _ as xI y D _ as y} ) x * x C y * yI
Point3D {x D _ as x I y D _ as yI z D _ as z} ) x * x C y * y C z * z}

Pour alle'ger l'e'criture, il est utile d'introduire un peu de sucre syntaxique. Dans un motif filtrant
les objets, on se permettra d'omettre les champs non contraints. Par exemple :

Point {x D int} t^ Point {x D intI y D _}

Point t^ Point {x D _I y D _}

1.4. ME'THODES 25
On utilisera aussi les notations suivantes pour les classes de base Tuplen et les classes de liste :

hij1; . . . ; ijni t^ #Tuplen {1 D ij1I . . . I n D ijn}

ij1 :: ij2 t^ #Cons {head D ij1I tail D ij2}

[] t^ #Nil {}
[ij1; . . . ;ijn] t^ ij1 :: .ij2 :: .. . . :: .ijn :: []/ . . . //

Dans l'exemple de la me'thode qui renvoie la norme d'un point, l'imple'mentation sur la classe
Point est automatiquement he'rite'e dans toutes les sous-classes de Point sauf celles ou` l'imple'mentation pour Point3D est plus pre'cise. On obtient donc automatiquement une imple'mentation correcte
sur les classes comme PointColore'. Il arrive que cet he'ritage de l'imple'mentation d'une me'thode ne
soit pas approprie'. Par exemple, si l'on veut de'finir le pre'dicat d'e'galite' sur les points, on veut prendre
en compte tous les champs et on souhaite donc interdire que l'imple'mentation de la me'thode sur lesPoint

s soit he'rite'e par me'garde dans les sous-classes. Dans ce cas, il est plus judicieux d'utiliser les
motifs de la forme #C :

meth {

h#Point {x D _ as x1I y D _ as y1}

#Point {x D _ as x2I y D _ as y2}i )

x1 D x2 and y1 D y2I
h#Point3D {x D _ as x1I y D _ as y1I z D _ as z1}

#Point3D {x D _ as x2I y D _ as y2I z D _ as z2}i )

x1 D x2 and y1 D y2 and z1 D z2I
...I

}
En effet, le code qui teste l'e'galite' sur la classe Point n'est typiquement pas valide pour les sousclasses des points colore's comme PointColore' car il faudrait aussi prendre en compte l'e'galite' des
couleurs. En utilisant le motif #Point dans ce cas, on e'vite qu'une l'imple'mentation invalide soit
he'rite'e. Ceci est particulie`rement inte'ressant si la me'thode est forme'e en agre'geant des cas e'crits dans
diffe'rents modules.

Pour terminer, voici quelques autres exemples :

fix append ) meth {

h[]; _ as l2i ) l2I
h_ as h :: _ as t; _ as l2i ) h :: append ht; l2i}

ifthenelse D meth {

htrue; _ as then; _i ) thenI
hfalse; _; _ as elsei ) else}

e^

26 CHAPITRE 1. SYNTAXE
1.5 Re'capitulatif

Dans cette section, nous rappelons les de'finitions introduites dans le chapitre et nous fixons comple`tement les notations utilise'es par la suite

Pre'suppose's

On suppose donne's une fois pour toutes :
- un ensemble infini Vars d'IDENTIFICATEURS ;
- un ensemble infini E'tiquettes de symboles de LABELS dont on suppose qu'il contient notamment les nombres entiers 1; 2; . . . ; n.

Structure primitive

On suppose fixe'e une fois pour toutes une structure primitive C0 qui consiste en :
- un ensemble PrimVals de VALEURS PRIMITIVES ;
- pour chaque entier n non-nul, un ensemble PrimOpsn, e'ventuellement vide, de fonctions partielles f 2 PrimValsn -7! PrimVals, appele's OPE'RATEURS PRIMITIFS n-AIRES. La re'union
de tous les ensembles PrimOpsn est note'e simplement PrimOps, ensemble de tous les OPE'RATEURS PRIMITIFS. L'ARITE' | f | d'un ope'rateur f est l'indice n de l'ensemble PrimOpsn
auquel il appartient ;
- un ensemble PrimMotifs de MOTIFS PRIMITIFS. Chaque motif primitif $ est un sous-ensemble

des valeurs primitives : $ t, PrimVals.

Structure de classes

Une STRUCTURE DE CLASSE C est la donne'e des e'le'ments suivants :
- un ensemble Classes de CLASSES ;
- un sous-ensemble ClassesConcre`tes t, Classes de CLASSES CONCRE`TES ;
- pour chaque classe C 2 Classes, un ensemble fini de labels ChampsC t, E'tiquettes, appele's

CHAMPS de C ;
- une relation .v/ 2 Classes * Classes appele'e SOUS-CLASSEMENT et qui doit e^tre une relation d'ordre partiel.
Les axiomes suivants doivent e^tre respecte's par toute structure de classes :

8C1; C2 2 Classes; C1 v C2 ) ChampsC2 t, ChampsC1(HE'RITAGE)
8n 2 N; Tuplen 2 ClassesConcre`tes ^ ChampsTuplen D {1; . . . ; n}(Tuplen)

8n 2 N; 8C 2 Classes; C v Tuplen ) C D Tuplen(Tuplen -MINIMAL)

1.5. RE'CAPITULATIF 27
Motifs

Les motifs sont les termes engendre's par la grammaire suivante ou` les conditions syntaxiques de
bonne formation figure sur la droite :

ij ::D _

| $ $ 2 PrimMotifs
| C {`1 D ij1I . . . I `n D ijn} C 2 Classes; fv.ij1/ kD . . . kD fv.ijn/ (1)
| #C {`1 D ij1I . . . I `n D ijn} C 2 ClassesConcre`tes; fv.ij1/ kD . . . kD fv.ijn/ (1)
| ij as x x 2 Vars; x 62 fv.ij /

Notes :

(1) Dans ces motifs les labels `1; . . . ; `n doivent e^tre deux-a`-deux distincts, ils doivent repre'senter

exactement l'ensemble ChampsC et leur ordre d'apparition est indiffe'rent.

L'ensemble des variables apparaissant dans un motif ij est note' fv.ij /.
L'ensemble des motifs est note' Motifs.

Expressions

Les expressions sont les termes engendre's par la grammaire suivante :

e ::D x x 2 Vars

| e1 e2
| fun x ) e x 2 Vars
| let x D e1 in e2 x 2 Vars
| fix x ) e x 2 Vars
| a a 2 PrimVals
| f f 2 PrimOps
| C {`1 D e1I . . . I `n D en} C 2 ClassesConcre`tes; ChampsC D {`1; . . . ; `n} (1)
| C *` C 2 Classes; ` 2 ChampsC
| meth {ij1 ) e1I . . . I ijk ) ek} (2)

Notes :

(1) Les labels doivent e^tre distincts deux a` deux et leur ordre d'apparition n'est pas signifiant ;
(2) L'ordre d'apparition des cas n'est pas signifiant.

L'ensemble des expressions est note' Exprs.

28 CHAPITRE 1. SYNTAXE
Variables libres

L'ensemble (fini) des variables libres fv.e/ d'une expression e est de'fini par induction sur e :

fv.x / , {x}
fv.e1 e2/ , fv.e1/ [ fv.e2/
fv.fun x ) e1/ , fv.e1/ \ {x}
fv.let x D e1 in e2/ , fv.e1/ [ .fv.e2/ \ {x}/

fv.fix x ) e/ , fv.e/ \ {x }
fv.C {`1 D e1I . . . I `n D en}/ , fv.e1/ [ * * * [ fv.en/

fv.C *`/ , ?

fv. f / , ?

fv.a/ , ?
fv.ij ) e/ , fv.e/ \ fv.ij /
fv.meth {ij1 ) e1I . . . I ijk ) ek}/ , fv.ij1 ) e1/ [ . . . [ fv.ijn ) en/

Notations

Si l'on veut expliciter la structure de classes C utilise'e, on e'crira les diffe'rents ensembles de'finis
ci-dessus de la fac,on suivante : ClassesC, ClassesConcre`tesC, ChampsCC , vC, MotifsC et ExprsC.

29
Chapitre 2
Se'mantique

Nous allons maintenant donner un sens formel aux expressions du langage. Le style de se'mantique
adopte' consiste a` donner des re`gles d'e'valuation qui permettent de re'duire peu a` peu une expression
en un re'sultat (se'mantique par re'e'criture a` << petits pas >>). L'objectif de ce chapitre est donc de de'finir
un pre'dicat e -! e0 qu'il faut lire << l'expression e0 peut se de'duire a` partir de e en faisant un pas de
calcul >>.

2.1 Noyau ML

La premie`re re`gle d'e'valuation concerne l'application d'une fonction et correspond a` la re`gle .r'/
du y"-calcul (voir par exemple [Bar84]) :

.fun x ) e1/ e2 -! [x 7! e2]e1(BETA)

Dans cette re`gle, [x 7! e2]e1 est obtenue a` partir de e1 en substituant les occurrences libres de la
variable x par e2. L'ope'ration de substitution est techniquement de'licate a` de'finir car il faut faire tre`s
attention a` e'viter les captures de variables. La de'finition se trouve a` la fin de ce chapitre (section 2.7,
page 40).

L'e'valuation des expressions let et fix se de'finit de fac,on similaire a` celle de l'application a`
l'aide des substitutions :

let x D e1 in e2 -! [x 7! e1]e2(BETA-LET)
.fix x ) e/ -! [x 7! .fix x ) e/]e(BETA-FIX)

2.2 Objets

La se'mantique de l'acce`s aux objets est re'sume'e par la re`gle suivante :

C *`i .C0 {`1 D e1I . . . I `i D ei I . . . I `n D en}/ -! ei(BETA-OBJ)

Dans cette re`gle, on ne suppose pas que C0 est une sous-classe de C. C'est en effet l'un des
objectifs du syste`me de types d'assurer cette proprie'te', de telle sorte que l'interpre`te n'ait pas besoin
de la ve'rifier dynamiquement.

30 CHAPITRE 2. SE'MANTIQUE

Quand on a effectivement C0 v C, notons que `i est force'ment dans l'ensemble des champs de
C pour que l'expression C *`i soit bien forme'e. Par l'axiome (HE'RITAGE), il s'en suit qu'il est aussi
force'ment un champ de C0, de sorte que la re`gle de re'duction est toujours possible dans ce cas.

2.3 Primitives

L'e'valuation d'une ope'ration primitive f suppose qu'elle soit applique'e a` un tuple de valeurs
primitives dont le nombre d'arguments correspond a` l'arite' de l'ope'ration. On re'e'crit alors simplement
cette application en la valeur calcule'e par la fonction f :

f 2 PrimOpsn a0 D f .a1; . . . ; an/

f ha1; . . . ; ani -! a0(BETA-PRIM)

Notons que cette re`gle ne s'applique que si .a1; . . . ; an/ est bien dans le domaine de f .

2.4 Me'thodes
2.4.1 Filtrage

La relation de filtrage relie une expression et un motif. Cette relation est complique'e par le fait
que la se'mantique du langage peut e^tre en appel par nom. L'expression peut donc n'e^tre pas encore
assez re'duite pour que l'on puisse de'cider si le filtrage est vrai ou faux. C'est pourquoi, nous en ferons
une relation dans une logique a` trois valeurs : filtre.e; ij / peut valoir : vrai s'il est e'tabli que e est bien
filtre'e ou accepte'e par ij ; faux s'il est de'finitivement e'tabli que e est rejete'e ; ou bien le symbole ? si
e n'est pas assez re'duite pour de'cider si elle est filtre'e ou rejete'e par ij .

Pour de'finir la relation de filtrage, nous introduisons maintenant les valeurs. Une VALEUR ou
FORME NORMALE DE TE^TE est une expression close suffisamment re'duite pour qu'on puisse de'cider
sa te^te. Les valeurs sont engendre'es par la grammaire suivante ou` on fait figurer le symbole de te^te de
la valeur sur la droite :

V ::D a ) a

| C {`1 D e1I . . . I `n D en} ) C
| f ) fun
| C *` ) fun
| fun x ) e ) fun
| meth {ij1 ) e1I . . . I ijk ) ek} ) fun

La te^te d'une valeur V est note'e te^te.V /. Notons qu'un objet peut e^tre une valeur me^me si ses champs
ne le sont pas. Cela est particulie`rement utile dans une se'mantique en appel par nom. Par exemple, la
liste 1 :: .fix l ) 1 :: l/ est une valeur.

Nous pouvons maintenant donner la de'finition de la relation de filtrage (voir section 2.7, page 38
pour une version comple`tement formelle). Celle-ci proce`de par induction sur la structure du motif
filtrant, un motif lieur ij as x e'tant conside're' e'quivalent pour le filtrage avec ij .

2.4. ME'THODES 31

Tout d'abord, toute expression e, quel que soit son niveau de re'duction, est filtre'e par le motif
universel _ : on a donc filtre.e; _/ D vrai pour tout e, me^me si ce n'est pas une valeur. Nous supposons
maintenant que le motif filtrant n'est pas le motif universel.

Dans tous les autres cas, le filtrage n'est de'termine' que si l'expression filtre'e est suffisamment
re'duite pour qu'on puisse en de'terminer la te^te, c'est-a`-dire qu'elle doit e^tre une valeur. Si e n'est pas
une valeur, alors le filtrage est inde'fini et on note filtre.e; ij / D ?. Si e est une valeur, alors filtre.e; ij /
vaut vrai ou faux selon les re`gles qui suivent.

Le filtrage par un motif primitif $ re'ussit si et seulement si la valeur e est une constante e'le'ment
de l'ensemble $ . Il e'choue si la valeur n'est pas une constante, par exemple si c'est un objet ou une
fonction, ou bien si c'est bien une constante, mais qu'elle n'est pas dans $ .

Si le motif filtrant ij est de la forme #C {`i D iji }, alors le filtrage re'ussit si et seulement si la
valeur e est un objet construit avec la classe C, c'est-a`-dire de la forme C {`i D ei }, et le filtrage de
chacun des champs ei par le motif iji re'ussit. Le filtrage de e par ij e'choue si e n'est pas un objet ou
bien si c'est un objet construit avec une classe diffe'rente de C ou bien si c'est bien un objet construit
avec la classe C, mais si un de ses champs ei n'est pas filtre' par le motif correspondant iji , c'est-a`-dire
si filtre.ei ; iji / D faux pour un certain i . Enfin, le filtrage est inde'fini dans tous les autres cas, c'esta`-dire quand e est bien un objet construit avec C, qu'aucun des sous-filtrages filtre.ei ; iji / n'e'choue,
mais qu'un au moins d'entre eux est inde'fini. Notons que si e est bien un objet construit avec la
classe C, on peut reformuler la de'finition de la valeur du filtrage filtre.e; ij / comme la conjonctionfiltre

.e1; ij1/ ^ * * * ^ filtre.en; ijn/ ou` l'ope'ration ^ de'signe la conjonction la plus << paresseuse >> (et
paralle`le).

Il reste le cas ou` le motif filtrant ij est de la forme C {`i D iji }. Dans ce cas, la valeur e doit e^tre
un objet de la forme C0 {`1 D e1I . . . I `n D enI . . . I `n0 D en0} construit avec une sous-classe C0 de C.
La valeur du filtrage filtre.e; ij / vaut alors la conjonction filtre.e1; ij1/ ^ * * * ^ filtre.en; ijn/. Notons
que les champs enC1; . . . ; en0 n'interviennent pas dans la de'finition du filtrage.

Exemple. Conside'rons l'expression e suivante :

e D [Point {x D 1I y D .fun x ) x C 1/ 2} ;e2]
Voici quelques exemples de filtrage :

ij filtre.e; ij /
Point {x D 1} :: _ vrai
Point {x D 2} :: _ faux
Point {y D int} :: _ ?

e^

2.4.2 L'ordre de pre'cision sur les motifs

Un motif est d'autant plus pre'cis qu'il accepte moins de valeurs. Parmi deux motifs acceptant
exactement les me^mes valeurs, on peut toutefois distinguer un motif plus pre'cis. Par exemple, le motif
#C est conside're' comme strictement plus pre'cis que C, me^me si C n'a pas de sous-classe diffe'rente
de C.

32 CHAPITRE 2. SE'MANTIQUE

La relation de comparaison de pre'cision est note'e 6, l'assertion ij 6 ij 0 se lisant << ij est plus
pre'cis que ij 0 >>. C'est une relation de pre'-ordre (re'flexive et transitive) de'finie par induction sur la
structure des deux motifs ij et ij 0 :

- le motif universel est moins pre'cis que tout autre motif : ij 6 _ ;
- la pre'sence d'un lieur ne change pas la comparaison de pre'cision : ij as x est e'quivalent a` ij ;
- un motif primitif est d'autant plus pre'cis qu'il filtre moins de valeurs primitives, c'est a` dire que

$1 est plus pre'cis que $2 si et seulement si $1 t, $2 (rappelons que les motifs primitifs sont
de'finis comme l'ensemble des constantes qu'ils filtrent) ;
- l'ordre de pre'cision se transmet dans les champs : C l^`i D ij 0i l/ est plus pre'cis que C {`i D iji } si

chacun des ij 0i est plus pre'cis que iji . De me^me, #C l^`i D ij 0i l/ est plus pre'cis que #C {`i D iji }
dans les me^me conditions.
- a` motifs de champs e'gaux, les motifs qui filtrent les objets sont d'autant plus pre'cis qu'ils

mentionnent des classes plus pre'cises ; quand C0 v C, on a donc :

C0 {`1 D ij1I . . . I `n D ijnI . . . I `n0 D ijn0} 6 C {`1 D ij1I . . . I `n D ijn} I
- le motif #C {`i D iji } est plus pre'cis que C {`i D iji } ;
Exemple. Voici un extrait de l'ordre de pre'cision pour quelques motifs :

Point {x D _I y D _}
#Point {x D _I y D _} PointColore' {x D _I y D _I c D _}

Point {x D intI y D int} #PointColore' {x D _I y D _I c D _}
#Point {x D intI y D int} PointColore' {x D intI y D intI c D _}

Point {x D 1I y D 2} #PointColore' {x D intI y D intI c D _}
#Point {x D 1I y D 2} PointColore' {x D 1I y D 2I c D _}

#PointColore' {x D 1I y D 2I c D _}

Notons que quand C0 v C, un motif de la forme #C0 {. . .} n'est pas plus pre'cis que #C {. . .}. En
effet, ces deux motifs acceptent des ensembles de valeurs disjoints. e^

2.4.3 Projection

Quand une expression e est filtre'e par le motif ij , on peut extraire de e les sous-expressions correspondant aux lieurs dans ij . Cette ope'ration est appele'e PROJECTION et est note'e e # ij . Son re'sultat
est une fonction associant une sous-expression de e a` toutes les variables libres de ij . La projection se

2.4. ME'THODES 33
de'finit aise'ment par induction sur le motif :

e # _ , ?
e # $ , ?
e #.ij as x/ , e # ij l^ [x 7! e]
.C0 {`1 D e1I . . . I `n D enI . . .}/ #.C {`1 D ij1I . . . I `n D ijn}/ , e1 # ij1 l^ * * * l^ en # ijn

.C {`1 D e1I . . . I `n D en}/ #.#C {`1 D ij1I . . . I `n D ijn}/ , e1 # ij1 l^ * * * l^ en # ijn

Exemple. Conside'rons le motif et l'expression suivants :

ij D .Point {x D int as x} as p/ :: ._ as tail/
e D [PointColore' {x D 1I y D 2I c D 3} ;Point {x D 1I y D 2}]

On ve'rifie qu'on a bien filtre.e; ij / D vrai. La projection de e selon ij est alors la fonction suivante :

e # ij D [x 7! 1I p 7! PointColore' {x D 1I y D 2I c D 3} I tail 7! [Point {x D 1I y D 2}]] e^

Remarque. Notons que le domaine de la fonction filtre.e; ij / est ne'cessairement l'ensemble des variables apparaissant dans ij , c'est-a`-dire fv.ij /. Par ailleurs, remarquons que la condition syntaxique
de bonne formation d'un motif objet, c'est-a`-dire fv.ij1/ kD * * * kD fv.ijn/, nous permet, dans la de'finition
de la projection sur un tel motif, de conside'rer les sous-motifs dans un ordre quelconque. e^

2.4.4 Dispatch dynamique

E'tant donne'e une liste ij1; . . . ; ijk de motifs et une expression e, l'ope'ration de DISPATCH DYNAMIQUE consiste a` de'terminer le motif le plus pre'cis qui filtre l'expression e. Si le dispatch re'ussit, il
produit un indice j entre 1 et k tel que e est filtre'e par ij j et que ij j est plus pre'cis que tout motif
ij j0 qui filtre e. Le dispatch e'choue si aucun motif ne filtre e (non-exhaustivite') ou bien si plusieurs
motifs conviennent, mais qu'aucun d'eux n'est plus pre'cis que tous les autres (ambigui"te'). Enfin, il
faut pre'voir le cas ou` le dispatch est inde'termine' parce que l'expression e n'est pas assez re'duite. Pour
traiter cette difficulte', on demande que le filtrage de e par chacun des motif ij j soit de'termine' avant de
pouvoir de'cider si le filtrage re'ussit ou non.

Plus pre'cise'ment, le dispatch dynamique est donc une fonction note'e dispatch.eI ij1I . . . I ijk/ qui
prend sa valeur dans l'ensemble {?; 1; . . . ; k; erreur} et qui est de'finie par les proprie'te' suivante :

- s'il existe un indice j tel que filtre.e; ij j / D ?, alors dispatch.eI ij1I . . . I ijk/ D ? (dispatch

inde'termine') ;
- sinon, s'il existe un unique indice j tel que filtre.e; ij j / D vrai et tel que filtre.e; ij j0/ D vrai

implique ij j 6 ij j0, alors dispatch.eI ij1I . . . I ijk/ D j ;
- sinon, le dispatch e'choue et on note dispatch.eI ij1I . . . I ijk/ D erreur.

Remarque. Notons que nous exigeons que le filtrage de l'argument avec tous les motifs soit de'termine' avant de pouvoir re'duire l'application d'une me'thode. Ceci est le'ge`rement trop restrictif dans
certains cas. Par exemple, si la me'thode ne comporte qu'une unique branche ij ) e, alors on pourrait
directement utiliser cette branche sans re'duire l'argument. Cependant, ge'ne'raliser cette remarque aux

34 CHAPITRE 2. SE'MANTIQUE
cas ou` il y a plusieurs branches ne parai^te pas facile. De plus, si la me'thode est forme'e en agre'geant
des branches provenant de diffe'rents modules, la se'mantique de l'application risquerait de changer
quand on rajoute une branche, ce qui pourrait e^tre surprenant pour le programmeur. C'est pourquoi,
nou savons pre'fe're' adopter de`s le de'part une se'mantique simple et stable, quitte a` restreindre un peu
le niveau de << paresse >>. e^

2.4.5 La re`gle d'e'valuation

L'e'valuation de l'application d'une me'thode consiste a` se'lectionner un cas de la me'thode par dispatch dynamique de l'argument de la me'thode sur la liste ses motifs. On extrait ensuite de l'argument
une sous-expression pour chacune des variables apparaissant dans le motif se'lectionne'. On substitue
enfin dans le corps de la me'thode chacune de ces variables par la sous-expressions correspondante.
La re`gle d'e'valuation prend donc la forme suivante :

j D dispatch.eI ij1I . . . I ijk/
.meth {ij1 ) e1I . . . I ijk ) ek}/ e -! [e # ij j ]e j(BETA-METH)

Dans cette re`gle, la notation [e # ij j ]e j de'signe la substitution simultane'e de toutes les variables
libres de e j qui sont aussi libres dans ij j par la sous-expression de e de'termine'e par l'ope'ration de
projection. La de'finition de la substitution simultane'e est donne'e a` la fin de ce chapitre (section 2.7,
page 40).

2.5 Contextes

La de'finition de l'e'valuation ne serait pas comple`te si on ne de'finissait pas les contextes d'e'valuation. Ceux-ci indiquent les sites possibles d'application des re`gles de re'duction dans une expression.
Un site de re'duction est de'note' par le symbole [] et les contextes sont engendre's par la grammaire
suivante :

E ::D [] e

| e []
| let x D [] in e
| C {`1 D e1I . . . I `i D []I . . . I `n D en}

L'application d'un contexte a` une expression est note'e E[e] et consiste a` placer e a` la place du symbole
[] dans E. Le re'sultat est donc une expression. Le fait que [] de'note un site de re'duction est exprime'e
par la re`gle d'e'valuation suivante :

e -! e0
E[e] -! E[e0](CONTEXTE)

Remarque. Notons que la pre'misse de cette re`gle peut tre`s bien e^tre de'duite par (CONTEXTE) elleme^me. La forme ge'ne'rale d'une re'duction est donc la suivante : si e se re'duit en e0 par une re`gle
diffe'rente de (CONTEXTE), alors on a aussi, pour toute liste finie de contextes :

E1[E2[. . . En[e]]] -! E1[E2[. . . En[e0]]].

2.5. CONTEXTES 35
En ge'ne'ral, les se'mantiques a` petits pas des langages a` la ML utilisent des contextes eux-me^me re'cursifs, c'est-a`-dire dont la grammaire est de la forme E ::D [] | E[e] | e[E] | . . . . Dans notre pre'sentation,
les contextes sont de hauteur 1. La relation de re'duction qui en re'sulte est identique mais cette de'finition pre'sente un avantage technique car, dans les preuves, on e'vite une double induction sur les
contextes et les de'rivations. e^

Contexte. La re`gle (CONTEXTE) est la dernie`re de notre se'mantique. Notons que cette se'mantique est
non-de'terministe. Une expression donne'e peut pre'senter plusieurs sites de re'duction possibles, c'esta`-dire qu'elle peut e^tre de la forme E1[E2[. . . En[e]]] pour plusieurs listes de contextes possibles. Par
exemple, dans l'expression e1 e2, on peut re'duire la partie gauche de l'application ou bien la partie
droite. Par ailleurs, la re`gle (CONTEXTE) peut parfois e^tre applicable en me^me temps que d'autres
re`gles. Par exemple, dans l'expression .fun x ) . . . / e, on peut ou bien re'duire l'argument de la
fonction en utilisant la re`gle (CONTEXTE) ou bien appliquer la re`gle (BETA).

Traditionnellement, la pre'sentation de la se'mantique a` petits pas des langages a` la ML restreint les
pre'misses des re`gles d'e'valuation et la de'finition des contextes afin d'imposer une strate'gie d'e'valuation de'terministe. Cela permet de mode'liser fide`lement le comportement effectivement mis en oeuvre
dans une imple'mentation concre`te de l'e'valuation. Par exemple, si l'on de'sire mode'liser une strate'gie
en appel par valeur (call-by-value), il convient de restreindre l'application de la re`gle (BETA) au cas
ou` l'argument de la fonction applique'e est une valeur. Si l'on veut de plus imposer l'ordre d'e'valuation gauche-droite, il suffit de restreindre les contextes de la forme e E au cas ou` e est une valeur
(fonction ou primitive). Ainsi, l'interpre`te devra force'ment commencer par re'duire la partie gauche
d'une application jusqu'a` obtenir une fonction puis re'duire la partie droite jusqu'a` obtenir une valeur
pour enfin appliquer la re`gle (BETA). En revanche, si on souhaite mode'liser une strate'gie en appel par
valeur (call-by-name), il suffit d'interdire les contextes de la forme e E, de sorte que l'argument d'une
application ne soit jamais e'value'.

Nous avons pre'fe're' de'finir une relation d'e'valuation non-de'terministe pour plusieurs raisons.
D'abord la strate'gie d'e'valuation n'est pas tre`s importante du point de vue du syste`me de types. Si
celui-ci nous permet d'affirmer statiquement qu'aucune e'valuation d'une expression ne conduit a` une
erreur de type, ce re'sultat est inde'pendant de la strate'gie d'e'valuation choisie, qui consiste simplement a` restreindre les e'valuations possibles. Un me^me syste`me de types s'appliquera donc a` toutes les
strate'gies possibles, en particulier aux strate'gies d'appel par valeur et d'appel par nom.

Une deuxie`me raison est que la pre'sence des me'thodes rend la de'finition d'une strate'gie de'terministe d'appel par nom non-triviale. En effet, s'il est bien connu que le y"-calcul est essentiellement se'quentiel, les multi-me'thode introduit un certain degre' de paralle'lisme dans notre se'mantique. Concre`tement, il ne suffit pas, comme dans le y"-calcul, de re'duire syste'matiquement le redex le plus a` gauche
pour obtenir une strate'gie comple`te. L'application d'une me'thode ne'cessite en effet de re'duire suffisamment son argument pour de'terminer le filtrage avec tous les motifs de la me'thode, mais il n'existe
pas d'ordre d'e'valuation simple des diffe'rentes parties de l'argument. Conside'rons par exemple la me'thode meth l^hfalse; falsei ) falseI _ ) truel/. Appliquons cette me'thode a` un argument he1; e2i.
La strate'gie qui consiste a` e'valuer e1 et e2 en se'quence, de gauche a` droite, n'est pas comple`te, car
elle boucle sur l'argument h?; truei ou` ? de'signe une expression qui ne termine pas, par exemplefix

x ) x. Or, la se'mantique ope'rationnelle permettrait dans ce cas de brancher directement dans
le cas _ ) . . . , parce que le filtrage avec les deux motifs est de'ja` de'termine'. Inversement, si on essaye
d'e'valuer les arguments dans l'ordre droite-gauche, cette strate'gie e'choue sur l'entre'e htrue; ?i. De
manie`re ge'ne'rale, cette me'thode n'est pas compilable dans le langage sans dispatch, car sa se'mantique
(ou paralle`le) n'est pas une fonction stable [Ber78].

36 CHAPITRE 2. SE'MANTIQUE

Pour e'valuer cette me'thode, il est ne'cessaire d'utiliser un e'valuateur paralle`le. Essentiellement, il
faut lancer deux ta^ches inde'pendantes pour e'valuer chacun des arguments. Si l'une des ta^ches termine
en de'terminant que l'argument calcule' est diffe'rent de false, alors on doit interrompre l'autre ta^che
et continuer le calcul dans l'alternative _ ) true. Si les deux ta^ches terminent avec le re'sultat false,
alors on peut continuer dans hfalse; falsei ) false. E'crire une strate'gie d'e'valuation comple`te et
de'terministe revient alors a` e'crire un se'quenceur multi-ta^ches et a` expliciter l'algorithme utilise' pour
le se'quencement, celui-ci devant e^tre suffisamment e'quitable pour que la strate'gie soit bien comple`te.
Cela repre'sente une << infrastructure >> lourde, ce qui explique qu'une strate'gie comple`te pour filtrage
paralle`le a rarement e'te' envisage'e en pratique. On peut toutefois mentionner une e'tude dans le cadre de
Concurrent Haskell [WM02] et remarquer que le langage Jazz, naturellement multi-ta^ches, pourrait
se pre^ter a` une telle imple'mentation comple`te. Il convient aussi de citer ici les travaux relatifs a` la
compilation du filtrage paresseux vers un langage se'quentiel (voir par exemple [Mar94]) qui constitue
une forme particulie`re de strate'gie incomple`te.

Il apparai^t donc clairement que le de'tail de la strate'gie d'e'valuation de'terministe doit rester au
niveau de l'imple'mentation. C'est pourquoi nous e'tudierons le syste`me de types en conside'rant une
relation de re'duction non-de'terministe, ce qui permet d'appliquer les re'sultats obtenus a` toutes les
strate'gies possibles, comple`tes ou non. e^

2.6 Erreurs de type

L'e'valuation d'une expression peut aboutir a` une situation manifestement errone'e comme l'application de l'addition a` des boole'ens ou l'utilisation d'un entier en position de fonction. De telles
expressions sont les ERREURS DE TYPE. Plus pre'cise'ment, sont conside're'es comme des erreurs de
type les situations suivantes :

Erreur de type Exemple
application d'une primitive a` une valeur non
construite avec la classe Tuplen ou` n est l'arite'
de la primitive

C .fun x ) x/ ou C h1i

application d'une primitive a` un tuple de valeurs
qui ne sont pas toutes des constantes

1 C .fun x ) x/

application d'une primitive a` un tuple de
constantes hors du domaine de la primitive

1 C true

application d'une valeur qui n'est n'est pas fonctionnelle, c'est-a`-dire ni une fonction, ni une me'thode, ni une primitive

1 .2/

application d'un accesseur de champs a` une valeur qui n'est pas un objet Point

*x .fun x ) x/

application d'un accesseur de champs a` un objet
qui n'est pas de la bonne classe

PointColore'*c .Point {. . .}/

2.6. ERREURS DE TYPE 37

application d'une me'thode a` un argument filtre'
par aucun motif (non-couverture)

.meth

hPoint; PointColore'i ) . . .
hPointColore'; Pointi ) . . . /

hPoint {. . .} ; Point {. . .}i
application d'une me'thode a` un argument filtre'
par plusieurs motifs (ambigui"te')

.meth

hPoint; PointColore'i ) . . .
hPointColore'; Pointi ) . . . /

hPointColore' {. . .} ; PointColore' {. . .}i

En outre, chaque fois qu'une erreur de type apparai^t dans une expression a` l'emplacement d'un site
de re'duction possible, on conside`re que l'expression toute entie`re est aussi une erreur de type. En
d'autres termes, si e est une erreur de type, alors E[e] est aussi une erreur.

Nous noterons e -! erreur quand l'expression e est une erreur de type et e -!? erreur quand
e se re'duit en un nombre fini d'e'tapes en e0 qui est une erreur de type. Ce dernier pre'dicat se'pare les
expressions en deux cate'gories : si e -!? erreur, on dit que e est OPE'RATIONNELLEMENT MAL

TYPE'E, sinon qu'elle est OPE'RATIONNELLEMENT BIEN TYPE'E. L'un des ro^les d'un syste`me de types
est d'e'liminer statiquement toutes les expressions ope'rationnellement mal type'es sans e'liminer trop
d'expressions bien type'es.

Remarque. En pre'sence d'un syste`me de types, un interpre`te peut donc conside'rer que l'expression
a` calculer ne sera jamais une erreur de type, ce qui permet en ge'ne'ral d'optimiser l'imple'mentation.
Le comportement d'un interpre`te ainsi optimise' peut alors e^tre arbitraire en pre'sence d'une erreur de
type : corruption me'moire, plantage, etc. C'est pourquoi, le syste`me de types est essentiel de`s lors que
l'interpre`te n'est pas de'fensif.

Notons que dans une se'mantique de'terministe, la de'finition des erreurs de type est souvent pre'sente'e d'une fac,on implicite. Les valeurs repre'sentant les re'sultats irre'ductibles des calculs et, a` chaque
instant, une seule re'duction e'tant possible, les expressions irre'ductibles qui ne sont pas des valeurs
de'notent un proble`me grave d'exe'cution et sont conside're'es comme des erreurs de type.

Cette de'finition pre'sente l'inconve'nient de ne pas expliciter exactement les proprie'te's qu'on peut
utiliser pour optimiser l'interpre`te. Plus grave, elle ne s'e'tend pas commode'mment a` une se'mantique
non-de'terministe. En effet, il se peut tre`s bien qu'une expression contenant deux sites de re'duction
possibles soit re'ductible sur le premier site et pre'sente une erreur de type faisant planter l'interpre`te
sur le second. Dans ce cas, l'expression est re'ductible mais il est important de conside'rer que c'est
une erreur de type puisqu'elle provoque un proble`me dans l'interpre`te. e^

38 CHAPITRE 2. SE'MANTIQUE
2.7 Re'capitulatif

Nous donnons ici la de'finition formelle du pre'dicat d'e'valuation et de toutes les relations ne'cessaires a` sa de'finition.

Valeurs

L'ensemble des valeurs, note' Valeurs, est engendre' par la grammaire suivante :

V ::D a

| C {`1 D e1I . . . I `n D en}
| fun x ) e
| meth {ij1 ) e1I . . . I ijk ) ek}
| f
| C *`

De plus, toute valeur V doit e^tre telle que fv.V / D ?.

Noeud de te^te d'une valeur

te^te.a/ , a
te^te.C {`1 D e1I . . . I `n D en}/ , C

te^te.fun x ) e/ , fun
te^te.meth {ij1 ) e1I . . . I ijk ) ek}/ , fun

te^te. f / , fun
te^te.C *`/ , fun

Filtrage

filtre.e; _/ , vrai
filtre.e; ij as x/ , filtre.e; ij /

filtre.e; ij / , ? si 8?!?:

e 62 Valeurs
ij 6D _
ij 6D ij 0 as x
filtre.a; $ / , vrai si a 2 $
filtre.C {`1 D e1I . . . I `n D en} ;

#C {`1 D ij1I . . . I `n D ijn}/ , filtre.e1; ij1/ ^ * * * ^ filtre.en; ijn/

2.7. RE'CAPITULATIF 39

filtre.C0 {`1 D e1I . . . I `n D enI . . .} ;

C {`1 D ij1I . . . I `n D ijn}/ , filtre.e1; ij1/ ^ * * * ^ filtre.en; ijn/ si C0 v C

filtre.e; ij / , faux dans tous les autres cas

Dans ces de'finitions, ^ de'signe la conjonction paralle`le qui vaut vrai si tous les arguments valentvrai

, faux si l'un des argument vaut faux et ? dans les autres cas.

Pre'-ordre de pre'cision

Il est de'fini par les re`gles d'infe'rence suivantes.

ij 6 ij

ij 6 ij 0 ij 0 6 ij 00

ij 6 ij 00 ij 6 .ij as x/ .ij as x/ 6 ij

ij 6 _
$1 t, $2
$1 6 $2

C0 v C
C0 {`1 D ij1I . . . I `n D ijnI . . . I `n0 D ijn0} 6 C {`1 D ij1I . . . I `n D ijn}

#C {`1 D ij1I . . . I `n D ijn} 6 C {`1 D ij1I . . . I `n D ijn}

ij 01 6 ij1 . . . ij 0n 6 ijn
C l^`1 D ij 01I . . . I `n D ij 0nl/ 6 C {`1 D ij1I . . . I `n D ijn}

ij 01 6 ij1 . . . ij 0n 6 ijn
#C l^`1 D ij 01I . . . I `n D ij 0nl/ 6 #C {`1 D ij1I . . . I `n D ijn}

Projection

e # _ , ?
e # $ , ?
e #.ij as x/ , e # ij l^ [x 7! e]
.C0 {`1 D e1I . . . I `n D enI . . .}/ #.C {`1 D ij1I . . . I `n D ijn}/ , e1 # ij1 l^ * * * l^ en # ijn (*)

.C {`1 D e1I . . . I `n D en}/ #.#C {`1 D ij1I . . . I `n D ijn}/ , e1 # ij1 l^ * * * l^ en # ijn

(*) de'fini uniquement si C0 v C.

40 CHAPITRE 2. SE'MANTIQUE
Fonction de dispatch

dispatch.eI ij1I . . . I ijk/ ,

8?????????!

?????????:

? ssi 9 j 2 [1; k]; filtre.e; ij j / D ?

j ssi 8????!????:

filtre.e; ij j / D vrai
8l 2 [1; k];filtre

.e; ijl / 6D ? ^
filtre.e; ijl / D vrai ) ij j 6 ijl ^a,filtre

.e; ijl / D vrai ^ ijl 6 ij j c' ) l D j

erreur sinon

Substitutions

Une SUBSTITUTION S est une fonction partielle a` domaine fini des variables dans les expressions.
Un RENOMMAGE R est une substitution dont le codomaine est compose' uniquement de variables.
Pour tous ensembles finis de variables X1 et X2 on suppose donne' un renommage R.X1; X2/ tel que :

- R.X1; X2/ est injective ;
- X1 est le domaine de R.X1; X2/ ;
- le codomaine de R.X1; X2/ est disjoint de X2 ;
- pour toute variable x 2 X1 \ X2, R.X1; X2/.x/ D x.
Cette fonction existe bien car l'ensemble Vars est suppose' infini.

Une substitution est e'tendue a` l'ensemble des expressions de la fac,on suivante :

[S]x , (S.x/ si x 2 dom.S/x sinon
[S].e e0/ , .[S]e/ a,[S]e0c'
[S].fun x ) e/ , fun [R]x ) [S l^ R]e .1/
[S].let x D e0 in e/ , let [R]x D [S]e0 in [S l^ R]e .1/

[S].fix x ) e/ , fix [R]x ) [S l^ R]e .1/

[S]C *` , C *`
[S]C {`1 D e1I . . . I `n D en} , C {`1 D [S]e1I . . . I `n D [S]en}

[S] f , f

[S]a , a
[S].meth {ij1 ) e1I . . . I ijk ) ek}/ , meth {[S].ij1 ) e1/I . . . I [S].ijk ) ek/}

ou` :

[S].ij ) e/ , [R]ij ) [S0]e .2/

2.7. RE'CAPITULATIF 41
et :

[R]_ , _
[R]$ , $
[R].ij as x/ , [R]ij as [R]x
[R]C {`1 D ij1I . . . I `n D ijn} , C {`1 D [R]ij1I . . . I `n D [R]ijn}
[R]#C {`1 D ij1I . . . I `n D ijn} , #C {`1 D [R]ij1I . . . I `n D [R]ijn}

Note :

.1/ R D R.{x}; fv.S z' V / [ V / ou` V D fv.e/ \ {x } ;
.2/ R D R.fv.ij /; fv.S z' V / [ V / ou` V D fv.ij ) e/ ;
avec, pour toute substitution S :

fv.S/ , [

x2dom.S/

fv.S.x//

Remarque. On montre facilement que l'ope'ration de substitution pre'serve la bonne formation syntaxique des expressions.

Exemple. Soit e l'expression suivante :

e D meth {h_ as x ; _ as yi ) x C y C z C t}
et S la substitution :

S D [x 7! u; z 7! x C u; t 7! u]
L'expression [S]e vaut alors :

meth l^h_ as x 0; _ as yi ) x0 C y C .x C u/ C ul/
avec x0 D R.{x; y}; {x; u}/.x/. e^

Contextes
Grammaire :

E ::D [] e

| e []
| let x D [] in e
| C {`1 D e1I . . . I `i D []I . . . I `n D en} C 2 ClassesConcre`tes (1)

Notes :
(1) Les labels `1; . . . ; `n doivent e^tre distincts deux a` deux, repre'senter les champs de la classe C

et leur ordre d'apparition n'est pas signifiant ;

42 CHAPITRE 2. SE'MANTIQUE
Application d'un contexte a` une expression :

.[] e/[e0] , e0 e
.e []/[e0] , e e0
.let x D [] in e/[e0] , let x D e0 in e
.C {`1 D e1I . . . I `i D []I . . . I `n D en}/[e0] , C {`1 D e1I . . . I `i D e0I . . . I `n D en}

Notons que la contrainte de bonne formation sur les contextes d'objets font que l'application E[e]
est toujours une expression syntaxiquement bien forme' de`s que e est aussi bien forme'e.

Re`gles d'e'valuation

e -! e0
E[e] -! E[e0](CONTEXTE)

.fun x ) e1/ e2 -! [x 7! e2]e1(BETA)
let x D e1 in e2 -! [x 7! e1]e2(BETA-LET)
.fix x ) e/ -! [x 7! .fix x ) e/]e(BETA-FIX)

C *`i .C0 {`1 D e1I . . . I `n D en}/ -! ei(BETA-OBJ)

f 2 PrimOpsn a0 D f .a1; . . . ; an/

f ha1; . . . ; ani -! a0(BETA-PRIM)

j D dispatch.eI ij1I . . . I ijk/
.meth {ij1 ) e1I . . . I ijk ) ek}/ e -! [e # ij j ]e j(BETA-METH)

Erreurs de type

f 2 PrimOpsn te^te.V / 6D Tuplen

f V -! erreur(ERREUR-PRIM-1)

Vi 62 PrimVals
f hV1; . . . ; Vni -! erreur(ERREUR-PRIM-2)

2.7. RE'CAPITULATIF 43

.V1; . . . ; Vn/ 62 dom. f /
f hV1; . . . ; Vni -! erreur(ERREUR-PRIM-3)
te^te.V / 6D fun
V e -! erreur(ERREUR-FUN)

te^te.V / 62 ClassesConcre`tes

C *` V -! erreur(ERREUR-GET-1)
C0 D te^te.V / C0 6v C

C *` V -! erreur(ERREUR-GET-2)

dispatch.eI ij1I . . . I ijk/ D erreur
.meth {ij1 ) e1I . . . I ijk ) ek}/ e -! erreur(ERREUR-ME'THODE)

e -! erreur
E[e] -! erreur(ERREUR-CONTEXTE)

44 CHAPITRE 2. SE'MANTIQUE45
Chapitre 3
Typage alge'brique

Nous allons maintenant introduire un syste`me de types pour le langage du chapitre 1. C'est-a`dire que nous allons se'parer les expressions en deux cate'gories : celles qui sont << bien type'es >> et
celles qui ne le sont pas. La proprie'te' fondamentale qu'un syste`me de types doit garantir est que
l'e'valuation d'une expression bien type'e ne provoque aucune des erreurs de types mentionne'es en
2.6. En rejetant les expressions mal type'es, on peut ainsi attraper avant l'exe'cution toute une classe
d'erreurs de programmation. C'est l'inte're^t majeur d'un syste`me de type.

Dans ce chapitre, nous nous attachons a` fournir un syste`me qui soit suffisamment expressif (il
accepte assez de programmes) et correct (il rejette bien les erreurs de type). En revanche, nous ne
nous occupons pas des autres aspects. L'inte're^t de ce syste`me de types est de fournir une << boi^te a`
outils >> pour montrer la correction de syste`mes plus pratiques qui seront introduits plus loin.

L'objectif e'tant simplement de montrer la correction, nous ne pre'ciserons pas comple`tement ce
qu'est un type dans ce syste`me, mais nous nous contenterons d'en axiomatiser les proprie'te's requises
pour assurer la correction. C'est pourquoi, le syste`me de types pre'sente' dans ce chapitre est qualifie'
de << alge'brique >> et la structure mathe'matique ainsi axiomatise'e sera appele'e alge`bre de types.

3.1 Principe

Un syste`me de types consiste en une de'finition d'un pre'dicat, appele' JUGEMENT DE TYPAGE qui
relie une expression a` un type. Comme cette expression peut contenir des variables libres, le jugement
de typage fait aussi intervenir un environnement de typage qui liste les hypothe`ses qu'on fait sur ces
variables libres. Le jugement de typage s'e'crit donc G ` e : T et se lit << dans l'environnement G,
l'expression e posse`de le type T >>.

S'il existe un type T tel que G ` e : T , alors l'expression e est dite BIEN TYPE'E dans l'environnement G. Elle est MAL TYPE'E dans le cas contraire.

La correction du syste`me de types provient de deux ingre'dients :
1. D'abord, une expression bien type'e est ope'rationnellement bien type'e. Ainsi, le syste`me de

types e'limine les erreurs de type imme'diates ;

2. Ensuite, une expression bien type'e reste bien type'e quand on la re'duit par un pas de calcul. On

e'limine ainsi les erreurs de type qui peuvent survenir plus loin dans le calcul.

46 CHAPITRE 3. TYPAGE ALGE'BRIQUE
3.2 Types monomorphes

On suppose donne' un ensemble A de TYPES MONOMORPHES ou MONOTYPES. Les e'le'ments
de cet ensemble sont note's avec les lettres t ou u (e'ventuellement avec un prime ou un indice). Le
contenu pre'cis de cet ensemble est laisse' ouvert car ce qui nous inte'resse, ce sont simplement certaines
proprie'te's sur les ope'rations de'finies sur A que nous allons axiomatiser dans cette section. L'approche
est donc alge'brique et l'ensemble A avec ses ope'rations est appele' ALGE`BRE DE TYPES.

Exemple. La raison pour laquelle nous ne fixons pas l'alge`bre de types est que diverses alge`bres sont
envisageables. Il est cependant utile d'introduire de`s maintenant un exemple concret d'alge`bre pour
illustrer ses axiomes et les re`gles de typage.

Pour fixer les ide'es, nous conside'rerons un exemple simple. Les monotypes de cette alge`bre sont
les termes finis et clos (sans variables) construits sur l'alphabet constitue' des noms de classes, du
symbole ! et des types primitifs int, rat et bool :

t ::D int | rat | bool

| t ! t
| ObjetColore' | Point | PointColore' | Point3D | Point3DColore' | . . .
| Listhti | Conshti | Nilhti | . . .

Voici quelques exemples de monotypes dans cette alge`bre :

bool Point
ConshPointi Listhbooli

Point ! int
bool ! Listhbooli ! Conshbooli

...

Ainsi, a` chaque classe C est associe' un monotype ou un constructeur de types si la classe est conside're'e comme parame'tre'e. Par exemple, les classes Point ou PointColore' ne sont pas des classes
parame'tre'es et constituent donc directement des monotypes. En revanche, les classes List, Cons etNil

sont parame'tre'es par le type des e'le'ments de la liste et sont donc des constructeurs qui prennent
un type en parame`tre. Les types des valeurs primitives (entiers, boole'ens) sont des constantes non
parame'tre'es (int, bool, etc.). Enfin, la fle^che ! est un ope'rateur de types qui ne correspond pas a` une
classe. e^

3.3 Types polymorphes

Dans les syste`mes de type a` la ML, le polymorphisme est traditionnellement exprime' a` l'aide
de sche'mas de types, un sche'ma de types e'tant une description en compre'hension d'un ensemble de
types monomorphes. Typiquement, un sche'ma de types en ML est forme' d'un terme contenant des
variables libres et de'crit l'ensemble des instances que peut prendre ce terme quand les variables sont
substitue'es par n'importe quel terme clos.

3.3. TYPES POLYMORPHES 47

Dans ce chapitre, nous nous inte'ressons seulement a` la correction du syste`me, sans vouloir effectivement calculer sur les types. Le polymorphisme peut alors e^tre sans syntaxe particulie`re : un
type polymorphe est simplement un ensemble de monotypes donne' en extension, sans qu'il soit de'crit
par un terme avec variables. L'avantage de cette approche est qu'on se'pare bien ce qui est ne'cessaire
pour assurer la correction du typage de l'aspect calcul sur les sche'mas de types, qui fera l'objet des
chapitres suivants.

Un TYPE POLYMORPHE, encore appele' POLYTYPE, est donc de'fini comme un ensemble quelconque non vide de monotypes. On utilisera la lettre T pour de'signer les polytypes. Un polytype
singleton de la forme {t} est identifie' au monotype t.

Exemple. Voici quelques exemples de polytypes dans l'alge`bre ferme'e simple :

{Point ! int; PointColore' ! int; Point3D ! int; Point3DColore' ! int}

{Conshti ! t | t 2 A}

...

e^
Cette de'finition des types polymorphes est e'troitement lie'e aux deux re`gles de typage concernant
le polymorphisme : l'instantiation et la ge'ne'ralisation :

G ` e : T t 2 T

G ` e : t(INST)
8t 2 T; G ` e : t

G ` e : T(GEN)

La de'finition de la ge'ne'ralisation est extensionnelle : pour pouvoir donner un type polymorphe T
a` une expression e, il suffit qu'on puisse lui donner chacun des e'le'ments monomorphes de T .

Remarquons que le traitement du polymorphisme peut e^tre fait inde'pendamment de toutes les
autres re`gles de typage. En ce sens, ce polymorphisme est superficiel : on se contente de plaquer la
ge'ne'ralisation et l'instantiation par-dessus les << vraies >> re`gles qui sont monomorphes. Cela correspond au fait que les quantificateurs sont en te^te des sche'mas de types.

Remarque. La re`gle (GEN) pose un proble`me technique car elle contient un nombre infini de pre'misses si l'ensemble T est infini. La pre'sentation du syste`me de types et les preuves associe'es doivent
donc faire appel a` une the'orie mathe'matique plus e'labore'e que celle des arbres finis et des nombres naturels. En particulier, on a besoin d'un moyen de raisonner par induction sur les de'rivations de typage.
Pour re'soudre ce proble`me de fondements, plusieurs solutions sont possibles. On peut se placer dans le
cadre de la the'orie des ensembles et utiliser la re'cursion transfinie, c'est-a`-dire conside'rer que la taille
d'une de'rivation est un nombre ordinal pluto^t qu'un nombre entier. On peut aussi se placer dans le
cadre de la the'orie des constructions inductives pour profiter de ses sche'mas d'induction ge'ne'ralise's.
Le re'sultat de toutes ces the'ories est de permettre les raisonnement par induction sur les de'rivations
de typage exactement comme si elles e'taient finies. C'est pourquoi, la the'orie choisie importe peu et
nous conside`rerons les inductions possibles << comme d'habitude >> (cf. section 4.6, page 74 pour plus
de pre'cisions the'oriques).

48 CHAPITRE 3. TYPAGE ALGE'BRIQUE
3.4 Environnements de typage

Un ENVIRONNEMENT DE TYPAGE est une fonction partielle a` domaine fini des variables dans les
polytypes. C'est une liste d'assertions de la forme x : T qu'on note :

G ::D [x1: T1; . . . ; xn: Tn]
L'environnement vide est note' ?. L'extension d'un environnement G par une assertion de la forme

x : T est note'e G[x : T ] et vaut G l^ x 7! T .

Pour typer une variable, il suffit d'extraire l'assertion correspondante dans l'environnement. D'ou`
la re`gle de typage :

G ` x : G.x/(VAR)

3.5 Typage de let et de fix

Le typage des expressions let est assure' par la re`gle suivante :

G ` e1 : T1 G[x : T1] ` e2 : T2

G ` let x D e1 in e2 : T2(LET)

La correction vis-a`-vis de la re`gle d'e'valuation de'coule du fait que la relation ` satisfait au lemme
de substitution (voir de'monstration section 4.4, page 69) : si e2 a le type T2 dans l'environnement G
et si e1 a le type T1 dans l'environnement e'tendu G[x : T2], alors la substitution [x 7! e1]e2 a aussi le
type T1 dans l'environnement G.

Ce lemme est caracte'ristique des syste`mes de typage compositionnels ou`, pour typer une expression complexe forme'e de plusieurs sous-expressions, la seule information requise concernant ces
sous-expressions est leur type. Par exemple, pour typer e2 dans l'expression let x D e1 in e2, il
n'est pas ne'cessaire de connai^tre exactement e1, mais seulement son type.

La re`gle de typage des expressions fix ressemble beaucoup a` celle du let :

G[x : T ] ` e : T
G ` fix x ) e : T(FIX)

Remarquons que cette re`gle autorise la re'cursion polymorphe.

3.6 Sous-typage

Pour refle'ter le sous-classement au niveau des types, toute alge`bre A doit venir avec une relation
d'ordre qui permet de comparer l'information qu'apportent deux types. Cette relation, note'e 6, est
appele'e SOUS-TYPAGE.

3.7. TYPAGE DES FONCTIONS ET DE L'APPLICATION 49

AXIOME (SOUS-TYPAGE-ORDRE).
La relation binaire 6 est un ordre partiel sur A, c'est-a`-dire qu'elle est re'flexive, transitive et antisyme'trique1

Quand t 6 t0, on dit que t est un SOUS-TYPE de t 0, c'est-a`-dire que t apporte plus d'information
que t0. On dit aussi que t0 est un SUPER-TYPE de t ou qu'il est moins pre'cis que t .

La re`gle de typage suivante, dite de << subsomption >>, indique qu'on peut toujours accepter de
perdre de l'information sur le typage d'une expression :

G ` e : t t 6 t0

G ` e : t0(SUB)

Exemple. Dans notre exemple simple d'alge`bre, la relation de sous-typage entre deux monotypes est
de'finie par comparaison structurelle des deux termes. Les types primitifs sont ordonne's selon les valeurs qu'ils contiennent. Par exemple, on a int 6 rat. Pour les classes non-parame'tre'es, comme Point,
la relation de sous-typage se confond avec celle de sous-classement : on a C 6 C0 chaque fois que
C v C0. Par exemple, on a PointColore' 6 Point. Pour les classes parame'tre'es, la comparaison de fait
sur le constructeur de type, mais aussi sur les parame`tres. Par exemple, on a : ConshPointColore'i 6List

hPointColore'i parce que Cons v List. On a aussi ListhPointColore'i 6 ListhPointi parce que
PointColore' 6 Point. On voit donc que List se comporte comme un ope'rateur covariant (monotone). D'autres variances sont ne'cessaires. Par exemple, l'ope'rateur ! qui admet deux parame`tres de
type, doit e^tre contravariant relativement au premier parame`tre et covariant relativement au deuxie`me.
Ainsi, on a les relations de sous-typage suivantes :

PointColore' ! Point
Point ! Point PointColore' ! PointColore'

Point ! PointColore'
La raison de cette variance de la fle`che est plus ge'ne'rale que notre exemple d'alge`bre. Cette contrainte
s'applique en fait a` toutes les alge`bres de types. Elle est ne'cessaire pour assurer la su^rete' du typage de
l'application, comme nous allons maintenant l'expliquer. e^

3.7 Typage des fonctions et de l'application

Toute structure A doit venir avec un ope'rateur binaire ! pour construire les types fonctionnels. Le
type d'une fonction acceptant un argument de type t et renvoyant un re'sultat de type u est repre'sente'
par l'e'le'ment t ! u.

1En fait, tous les re'sultats de cette the`se sont pre'serve' si la relation de sous-typage n'est qu'un pre'odre, c'est-a`-dire si
elle n'est pas suppose'e antisyme'trique. Il ne nous a cependant pas paru utile d'introduire ce degre' de ge'ne'ralite'.

50 CHAPITRE 3. TYPAGE ALGE'BRIQUE

Les re`gles de typage des fonctions et de l'application de fonction sont les suivantes :

G[x : t0] ` e : t
G ` fun x ) e : t0 ! t(FUN)
G ` e1 : t2 ! t G ` e2 : t2

G ` e1 e2 : t(APP)

L'interpre'tation de la relation de sous-typage en terme de quantite' d'information disponible induit
imme'diatement des contraintes sur le sous-typage des types fonctionnels :

- si u 6 u0, alors on connai^t plus d'information sur le re'sultat des fonctions de type t ! u que

sur les fonctions de type t ! u0. Donc t ! u est plus pre'cis que t ! u0 ;
- si t0 6 t, toute fonction de type t ! u doit accepter au moins les arguments de type t0, c'est-a`dire e^tre de type t0 ! u, donc t ! u est un sous-type de t0 ! u.
Notons que ces deux proprie'te's ne sont pas absolument ne'cessaires a` la correction du typage. Elles
sont simplement utiles pour e^tre cohe'rent avec l'interpre'tation << sous-typage = quantite' d'information >> et elles sont respecte'es par toutes les alge`bres de types connues.

En revanche, les proprie'te's re'ciproques sont re'ellement indispensables pour la correction. Supposons que t ! u 6 t0 ! u0. Par la re`gle de subsomption, toute fonction de type t ! u peut e^tre
conside're'e comme ayant le type t0 ! u0. On peut donc lui passer un argument de type t0 et celui-ci
doit pouvoir e^tre traite' comme ayant le type t a l'inte'rieur de la fonction. Pour e^tre su^r que cela ne
pose pas de proble`me, on demande que t0 soit un sous-type de t. Par ailleurs, le re'sultat de la fonction
est de type u, mais il peut e^tre utilise' avec le type u0, ce qui n'est su^r que si u est un sous-type de u0.

Au final, nous demandons que toute alge`bre de types ve'rifie l'axiome suivant :
AXIOME (FLE`CHE-VARIANCE).

8tt0uu0; t ! u 6 t0 ! u0 () t0 6 t ^ u 6 u0
Remarque. Les re`gles de typage des fonctions et de l'application sont monomorphes. Gra^ce a` la re`gle
de ge'ne'ralisation (GEN), une application donne'e peut bien e^tre associe'e a` un type polymorphe, mais
pour chacune de ses instances monomorphes, il faut qu'on puisse appliquer la re`gle monomorphe
(APP). Cela implique qu'une fonction peut bien e^tre polymorphe, c'est-a`-dire e^tre applique'e a` toutes
sortes d'arguments, mais une fois qu'elle est applique'e, son argument est monomorphe.

Cette restriction est due au traitement superficiel et pre'dicatif du polymorphisme. Pour avoir des
arguments polymorphes, il faudrait disposer d'un ope'rateur fle`che qui travaille lui-me^me sur des types
polymorphes. Au niveau des sche'mas de types, on aurait alors des quantificateurs sous la fle`che.

3.8 Typage des objets
3.8.1 L'abstraction d'une classe

Le typage des objets requiert une abstraction des classes dans les types. On supposera que dans
toute alge`bre de types, chaque classe C est associe'e a` un ensemble de monotypes note' #C qui est
l'ensemble des types possibles des objets de cette classe. Pour assurer la su^rete' du typage, il faut
imposer l'axiome suivant :

3.8. TYPAGE DES OBJETS 51

AXIOME (CLASSES COVARIANTES).
Soient C et C0 deux classes. Soient t et t0 deux monotypes tels que t 2 #C et t 0 2 #C0. Si t0 6 t, alors
C0 v C.

Exemple. Dans l'alge`bre simple, #C est simplement l'ensemble des termes construits avec C. Par
exemple, #List est l'ensemble des types de la forme Listhti, #Point vaut {Point}, etc. e^

L'axiome (CLASSES-COVARIANTES) est indispensable pour assurer la su^rete' du typage. En effet,
si le type t0 d'un objet e construit avec la classe C0 est un sous-type de t construit avec C, cela signifie
que, par la re`gle de subsomption, on peut acce'der a` e avec un accesseur de la classe C. Pour e'viter
l'erreur de type (ERREUR-GET-2), il faut donc imposer que C0 soit une sous-classe de C.

3.8.2 L'abstraction des champs

Pour chaque classe C et chaque champs ` 2 ChampsC , on supposera donne'e une abstraction de
l'acce`s au champs ` de la classe C. Cette abstraction, note'e C *`, est une fonction de l'ensemble #C
vers les monotypes.

Pour assurer la su^rete' du typage, il est ne'cessaire de supposer que cette fonction est monotone.
Conside'rons en effet un objet e de classe C0 et de type t0 2 #C0. Supposons e'galement que t0 soit un
sous-type de t e'le'ment de #C. Par l'axiome (CLASSES-COVARIANTES), on sait que C0 est une sousclasse de C. Fixons maintenant un champ `i de la classe C et notons ei le champ correspondant dans
l'objet e. En utilisant l'accesseur C0 *`i , on donne le type t0i D C0 *`.t0/ a` ei . Cependant, on utilisant
l'accesseur de la super-classe C *`, on trouve aussi le type ti D C *`.t / pour ce me^me champ. Donc,
le syste`me de types va permettre d'appliquer a` ei toute ope'ration qui attend le type ti . Il faut donc que
ei , de type t0i accepte toute ces ope'rations. En conse'quence, il faut que t0i soit un sous-type de ti .

Cette proprie'te' de monotonie est impose'e par l'axiome suivant :
AXIOME (CHAMPS-COVARIANTS).
Soit C0 une sous-classe de C et ` un champs de C. Si t0 est dans l'ensemble #C0 et si t est dans #C,
alors t0 6 t implique C0 *`.t 0/ 6 C *`.t/.

Exemple. Dans notre alge`bre simple, les fonctions C *` peuvent e^tre engendre'es automatiquement des
de'clarations entre'es par le programmeur. dans le tableau suivant, on a fait figurer dans la colonne de
gauche ces de'clarations dans une syntaxe hypothe'tique et dans la colonne de droite les abstractions
engendre'es :

abstract class ObjetColore' {

c : CouleurI
}

ObjetColore'*c : ObjetColore' 7! Couleur

class Point {

x : intI
y : intI
}

Point*x : Point 7! int
Point*y : Point 7! int

52 CHAPITRE 3. TYPAGE ALGE'BRIQUE

class PointColore' v Point; ObjetColore' {} PointColore'*x : PointColore' 7! int

PointColore'*y : PointColore' 7! int
PointColore'*c : PointColore' 7! Couleur
class Listho""l^i {}
class Consho""l^i v List {

head : o""I
tail : Listho""iI
}

8t; Cons*head : Conshti 7! t
8t; Cons*tail : Consht i 7! Listhti

class Nilho""l^i v List {}
Remarquons que l'abstraction Point*x n'est pas directement applicable a` un type dans #PointColore' :
il faut d'abord convertir le type du point colore' en un point normal avant de pouvoir extraire le champ
x par l'accesseur Point*x.

Notons e'galement comment l'abstraction Cons*head traite le polymorphisme : cette fonction est
capable d'extraire le type de la te^te d'une liste pour tous les types t possibles. Il est inte'ressant de remarquer que l'axiome (CHAMPS-COVARIANTS) ne permet pas d'e'crire n'importe quel type pour les
champs. Par exemple, le constructeur Cons e'tant covariant, on a l'ine'galite' Conshinti 6 Conshrati.
Par l'axiome (CHAMPS-COVARIANTS), on doit donc avoir int 6 rat, ce qui est bien le cas. En revanche, si le type du champ head avait e'te' o"" ! o"", cela aurait conduit a` une contradiction. L'axiome
impose donc que les parame`tres de type d'une de'claration de classe apparaissent dans les types des
champs avec une variance compatible avec leur variance de'clare'e et qui de'termine l'ordre de soustypage.

D'une fac,on e'galement inte'ressante, l'axiome permet aussi une rede'finition covariante du type des
champs dans les sous-classes. Par exemple, on peut e'crire :

class Segment {

p1; p2 : PointI
}

class SegmentColore' v Segment {

p1; p2 : PointColore'I
}

En revanche, la de'claration suivante est interdite :

class Ille'gale v Segment {

p1; p2 : boolI
}

e^
Remarque. En pre'sence d'effets de bord (champs modifiables), l'axiome de covariance des champs
engendrerait un syste`me de types incorrect. En effet, un objet de la classe SegmentColore' pourrait
e^tre conside're' comme un Segment, de sorte qu'on pourrait en remplacer le champ p1 par un Point,
ce qui est incompatible avec la de'claration de la classe SegmentColore'. Pour pre'server la correction,
il convient que les champs modifiables soient invariants, et non pas simplement covariants. e^

3.9. TYPAGE DES PRIMITIVES 53
3.8.3 Re`gles de typage

Munis des abstractions des classes et des champs, nous pouvons maintenant e'crire les re`gles de
typage des objets et des accesseurs :

t 2 #C G ` e1 : C *`1.t/ . . . G ` en : C *`n.t/

G ` C {`1 D e1I . . . I `n D en} : t(OBJET)

G ` C *` : t ! C *`.t/(GET)
3.9 Typage des primitives

Toute alge`bre de types doit de'finir, pour chaque valeur primitive a une abstraction de cette valeur
qui est un monotype a. Un tel monotype est appele' TYPE PRIMITIF et l'ensemble des types primitifs
est appele' ALGE`BRE PRIMITIVE et est note' A0.

La re`gle de typage des constantes est alors tout naturellement la suivante :

G ` a : a(CST)
Conside'rons maintenant une ope'ration primitive f . On peut lui donner le type ht01 ; . . . ; t0n i ! t0
si elle accepte toutes les valeurs primitives de type t0i ou d'un sous-type et donne un re'sultat de type
t0 ou d'un sous-type.

Pour exprimer cette re`gle, il est utile de de'finir pour tout type type primitif t0 l'ensemble des
valeurs primitives qui peuvent prendre le type t0. Cet ensemble est note' t0 et on a :

t0 , {a 2 PrimVals | a 6 t0}
Pour e'crire la re`gle de typage, une dernie`re difficulte' technique surgit car on ne dispose pas du
constructeur des types de tuples dans l'alge`bre. Ce constructeur e'tant connu indirectement par les
proprie'te's de ses champs a` travers les fonctions Tuplen *i , cela complique le'ge`rement l'e'criture de la
re`gle :

8a1 2 t01 ; . . . ; an 2 t0n ; f .a1; . . . ; an/ 2 t0 8i; Tuplen *i .t/ D t0i

G ` f : t ! t0(PRIM)

Exemple. Voici une abstraction possible des valeurs primitives dans notre exemple simple d'alge`bre :

a 2 Z ) a D int
a 2 Q \ Z ) a D rat
a 2 {true; false} ) a D bool

54 CHAPITRE 3. TYPAGE ALGE'BRIQUE
La re`gle (PRIM) peut alors donner les types suivants aux ope'rations primitives : l'addition et la multiplication peuvent recevoir l'ensemble des types hint; inti ! int, hrat; rati ! int et hrat; rati ! rat.
Par la re`gle (GEN), on peut leur donner le type polymorphe qui contient ces trois monotypes. Ce type
polymorphe est e'quivalent par rapport a` un ordre de sous-typage ge'ne'ralise' au polytype contenant
l'ensemble des monotypes de la forme ht; ti ! t pour tout t 2 {int; rat}.

De me^me, l'ope'ration de comparaison peut recevoir un polytype e'quivalent a` hrat; rati ! bool.
Notons que l'ope'ration de division pose un petit proble`me technique : comme elle n'est pas de'finie
quand le de'nominateur est nul, la re`gle (PRIM) ne peut lui donner aucun type correct car tous nos types
arithme'tiques contient la valeur 0. Pour traiter ce proble`me, il y a plusieurs solutions. On peut e'tendre
l'ensemble des valeurs primitives avec des valeurs supple'mentaires (C1, -1, C0, -0, NaN) afin
de rendre les ope'ration totales. On peut aussi e'tendre le'ge`rement la se'mantique ope'rationnelle et la
re`gle (BETA-PRIM) pour autoriser le calcul a e^tre bloque' sans que cela ne soit une erreur de type. On
peut aussi pre'voir un me'canisme d'exceptions pour cela. e^

3.10 Se'paration

Un ingre'dient essentiel de la correction du syste`me de types est que les types des fonctions, des
objets et des valeurs primitives soient bien se'pare's. Par exemple, il ne faut pas qu'un type d'objet soit
un sous-type d'un type de fonction, sinon on pourrait e^tre amene' a` accepter l'utilisation de l'objet
comme une fonction, ce qui constitue une erreur de type.

Deux ensembles de monotypes sont dits SE'PARE'S s'ils n'ont pas d'e'le'ments directement comparables :

X 6? Y ssi 8t 2 X; 8u 2 Y; t 66 u ^ u 66 t

AXIOME (SE'PARATION).
On pose les notations suivantes pour de'signer respectivement les ensembles de types de fonctions,
d'objets et de valeurs primitives :

fun , {t ! t0 | t; t0 2 A} Types des fonctions
Classes , [

C2Classes

#C Types des objets

A0 , [

a2PrimVals

a Types des valeurs primitives

Les ensembles fun, Classes et A0 sont deux-a`-deux se'pare's.
3.11 Typage des me'thodes

Conside'rons une me'thode de la forme meth {ij1 ) e1I . . . I ijk ) ek}. Le typage de cette me'thode doit re'soudre trois proble`mes potentiels :

3.11. TYPAGE DES ME'THODES 55

1. D'abord, il faut en interdire toute utilisation en dehors d'un contexte ou` une fonction est attendue. Gra^ce a` l'axiome de se'paration, il suffit pour cela de donner a` la me'thode un type
fonctionnel de la forme t ! t0 ;

2. Ensuite, il faut qu'aucun argument ne fasse e'chouer le dispatch dynamique. Naturellement, on

peut restreindre cette exigence au cas ou` l'application de la me'thode est bien type'e, c'est-a`dire quand l'argument a le type t. On dira alors que le type t ! t0 est couvert par les motifs
ij1; . . . ; ijk, ce que l'on notera t ! t0 FG ij1I . . . I ijk (voir section 3.11.1) ;

3. Enfin, il faut ve'rifier qu'on peut donner le type t ! t0 a` chaque cas ij j ) e j de de'finition de la

me'thode. A` cet effet, on de'finit un jugement de typage auxiliaire note' G ` .ij j ) e j / : t ! t 0
(voir section 3.11.2). Ce jugement doit se lire : << pour tout argument e de type t filtre' par le
motif ij j , l'expression re'duite [e # ij j ]e j est de type t0 >>.

En re'sume', nous proposons donc d'e'crire la re`gle de typage des me'thodes de la fac,on suivante :

t ! t0 FG ij1I . . . I ijk 8 j; G ` ij j ) e j : t ! t 0

G ` meth {ij1 ) e1I . . . I ijk ) ek} : t ! t0(METH)

Remarque. Notons que cette re`gle de typage peut e^tre utilise'e en conjonction avec la re`gle de ge'ne'ralisation pour fournir un type polymorphe a` une me'thode. Par exemple, conside'rons la me'thode
suivante (ope'ration de re'flexion de points selon l'axe y) en supposant que seules les classes Point et
PointColore' soient de'finies :

meth {

#Point {x D _ as xI y D _ as y} ) Point {x D -xI y D y} I
#PointColore' {x D _ as xI y D _ as yI c D _ as c} ) PointColore' {x D -xI y D yI c D c}}

Par la re`gle (METH), on peut donner le type Point ! Point a` cette me'thode. En effet, ce type autorise
l'application de la me'thode a` des objets de classe Point et PointColore'. Si l'argument est un Point,
c'est la premie`re branche qui est choisie et le re'sultat de l'application est alors un Point. Si l'argument
est un PointColore', la deuxie`me branche est exe'cute'e et le re'sultat est un PointColore'. Dans tous les
cas, le type du re'sultat est un sous-type de Point et la me'thode est donc bien type'e.

Par ailleurs, on peut e'galement donner le type PointColore' ! PointColore' a` la me'thode. Notons
que dans ce cas-la`, il n'y a pas d'expression qui soit filtre'e par le motif de la premie`re branche et qui
soit un sous-type de PointColore'. C'est pourquoi, la premie`re branche est << morte >> et ne peut donc
pas poser de proble`me de typage. Seule la deuxie`me branche est possible et elle produit bien une
expression de type PointColore'.

Gra^ce a` la re`gle (GEN), il est alors possible d'unir ces deux types pour donner a` la me'thode le
type polymorphe {Point ! Point; PointColore' ! PointColore'}.

Notons e'galement que chaque cas de la me'thode est type' inde'pendamment, c'est-a`-dire qu'il n'y
a pas de transmission horizontale d'information de type. Un cas ij j ) e j est type' en sachant qu'il
rec,oit un argument filtre' par le motif ij j , mais pas en sachant que c'est le motif le plus pre'cis parmi
ij1; . . . ; ijk ayant cette proprie'te'. Cette restriction est intentionnelle : cela permet d'une part au syste`me
de types d'e^tre inde'pendant de la strate'gie de dispatch utilise'e (best-match, first-match, ...), et d'autre
part, cela autorise le typage se'pare' de cas e'crits dans des modules diffe'rents.

Ainsi, le syste`me de types est fondamentalement conc,u pour qu'on puisse (et qu'on doive) typer se'pare'ment chaque cas d'une me'thode. Ce choix de conception a certaines conse'quences parfois de'routantes. Par exemple, modifions la me'thode ci-dessus pour que le premier cas utilise un

56 CHAPITRE 3. TYPAGE ALGE'BRIQUE
motif de sous-classe de la forme Point {. . .} pluto^t que #Point {. . .}. Dans ce cas, il n'est pas possible de donner le type PointColore' ! PointColore' a` la me'thode. En effet, un objet de classePointColore'

est maintenant filtre' par le motif de la premie`re branche. Si la me'thode avait le type
PointColore' ! PointColore', alors il faudrait que la premie`re branche produise un objet de typePointColore'

, ce qui n'est pas le cas, puisqu'elle retourne un Point. Ce qui est de'routant, c'est que le
PointColore' sera en fait toujours passe' a` la deuxie`me branche et donc ne posera jamais de proble`me
dans la premie`re. Le syste`me de types n'est donc pas aussi pre'cis qu'il pourrait l'e^tre en the'orie, mais
c'est le prix a` payer pour qu'on puisse faire le typage de chaque cas se'pare'ment. e^

Le reste de cette section est consacre' a` la de'finition du test de couverture (3.11.1) et du typage des
cas (3.11.2).

3.11.1 Test de couverture

Le test de couverture est un pre'dicat note' t ! t0 FG ij1I . . . I ijk. S'il est vrai, il doit assurer
qu'aucune valeur passe'e a` une me'thode de type t ! t0 ne fait e'chouer le dispatch avec les motifs
ij1; . . . ; ijk. Notons que le type t0 n'intervient pas du tout dans cette de'finition. Il est cependant commode de le faire apparai^tre dans la notation, notamment quand le test de couverture sera e'tendu aux
ensembles de monotypes.

Nous allons donner une de'finition tre`s extensive du test de couverture. Si aucune expression de
type t ne fait e'chouer le dispatch, alors, on conside`re que le test de couverture re'ussit. Cette de'finition
simple est cependant infonde'e car elle utilise le syste`me de types qu'on est en train de de'finir. En
particulier, l'une des expressions e pourrait e^tre la me'thode me^me qu'on est en train de typer. En fait,
ceci n'est pas vraiment un proble`me : du point de vue du filtrage, toutes les fonctions et toutes les
me'thodes sont e'quivalentes et sont repre'sente'es par le symbole fun. C'est pourquoi, il suffit de tester
le dispatch uniquement sur un ensemble plus restreint d'expressions, dites EXPRESSIONS DE TESTS :

etest ::D a

| ?fun ou` ?fun t^ fun x ) fix y ) y
| C l^`1 D etest1 I . . . I `n D etestn l/

Dans cette grammaire, ?fun est choisie car elle repre'sente la fonction avec le type le plus ge'ne'ral
possible puisqu'elle prend n'importe quel argument et ne retourne jamais. Notons aussi que toutes les
expressions de test sont sans variable libre.

Le typage des expressions de test ne de'pend maintenant que des re`gles de typage e'nonce'es jusqu'a`
pre'sent car aucune expression de test n'est une me'thode. On peut donc donner la de'finition bien fonde'e
suivante du TEST DE COUVERTURE :

8etest; a,? ` etest : tc' ) dispatch.etestI ij1I . . . I ijk/ 6D erreur

t ! t0 FG ij1I . . . I ijk

3.11.2 Typage des cas

Dans la re`gle de typage, le pre'dicat G ` ij ) e : t ! t0 exprime que pour tous les arguments
possibles de type t, l'expression e prend le type t0 quand on y remplace les variables libres de ij

3.11. TYPAGE DES ME'THODES 57
par les sous-expressions correspondantes de l'argument. Le typage de l'expression e a lieu dans G
e'tendu avec un environnement G0 qui de'crit le type des variables libres de ij . Pour typer e, nous
allons utiliser non seulement l'information que l'argument a le type t, mais aussi le fait qu'il est filtre'
dynamiquement par ij .

Par exemple, conside'rons une me'thode de type Point ! Point et un cas de cette me'thode utilisant
le motif ObjetColore'. L'information dont on dispose pour typer le corps de ce cas est alors non
seulement que l'argument a le type Point, mais aussi qu'il est d'une sous-classe de ObjetColore'.

Pour ce faire, nous introduisons un jugement auxiliaire de typage des motifs, note' t ` ij : t00I G0.
Le << contrat >> intuitif que ce jugement doit satisfaire est le suivant : pour tout argument e de type t tel
que e est filtre' par le motif ij , il doit exister un type t00 plus pre'cis que t et un environnement G0 tels
que t ` ij : t 00I G0. En outre, e doit alors avoir le type t00, ce qui refle`te l'information supple'mentaire
qu'on a de'duit du fait que qu'il est filtre' par ij . Enfin, la projection de e sur le motif ij doit avoir le
type G0.

Supposons que ce jugement interme'diaire soit de'ja` de'fini et qu'il remplisse bien ce contrat. On
peut alors l'exploiter pour formuler la re`gle de typage des cas : pour atteindre l'objectif de typer le
corps e en exploitant au maximum l'information de type statique et dynamique, nous demandons de
typer e dans tous les environnements G0 possibles, ce qui s'e'crit de la fac,on suivante :

8t00G0; .t ` ij : t00I G0/ ) .G l^ G0 ` e : t0/

G ` ij ) e : t ! t0(CAS)

Remarque. Notons que cette re`gle de typage peut avoir une infinite' de pre'misses, ce qui la fait ressembler a` la re`gle de ge'ne'ralisation (GEN). Il peut parai^tre e'trange que le typage fin des cas exige de
typer e dans une infinite' d'environnements. En fait, cela peut tre`s bien repre'senter une exigence de
typage plus faible qu'un environnement unique, car chacun peut donner type pre'cis aux arguments,
alors qu'un environnement unique pourrait repre'senter une approximation grossie`re.

Pour illustrer ce phe'nome`ne, reprenons notre exemple ci-dessus de la me'thode de type Point !Point

et ayant un cas de'fini avec le motif ij D ObjetColore'. Il est tout-a`-fait correct de poser le jugement interme'diaire Point ` ij : PointI ? car on ve'rifie facilement qu'il remplit bien le contrat exprime'
plus haut. Cependant, ce jugement engendrerait un syste`me d'une pre'cision me'diocre, puisqu'on ne
pourrait me^me pas utiliser le fait que l'argument est bien un ObjetColore'. C'est pourquoi, on cherche
pluto^t a` de'finir le typage des motifs de telle sorte qu'on ait Point ` ij : t00I ? pour tous les types t00
qui sont simultane'ment sous-types de Point et de ObjetColore'. Cela revient, dans la re`gle (CAS), a`
exiger de typer le corps du cas successivement pour tous les tels types t00.

Dans certaines alge`bres particulie`res, l'ensemble des types t00 a` utiliser pour typer le corps du
cas peut admettre une borne supe'rieure, par exemple PointColore' dans notre exemple. Notons toutefois que dans le cas ge'ne'ral, cette borne supe'rieure n'a aucune raison d'exister, car aucune structure
particulie`re n'est impose' a` l'ordre partiel des monotypes.

Pour finir avec la re`gle (CAS), remarquons que seul l'environnement G0 est utilise'e dans le typage
de e, mais pas le type t00. La raison en est que t00 ne sert que lors de la de'finition du jugement t `
ij : t00I G0 pour traiter les lieurs, comme nous allons maintenant le voir. e^

Le jugement t ` ij : t0I G est de'fini a` partir de re`gles d'infe'rences que nous allons maintenant
pre'senter une a` une.

58 CHAPITRE 3. TYPAGE ALGE'BRIQUE

Le type de sortie t0 ge'ne're' par le jugement de typage d'un motif est a priori un type plus pre'cis
que le type d'entre'e t. Quand le motif est un lieur pour la variable x, on peut donc ajouter ce type dans
l'environnement ge'ne're', d'ou` la re`gle suivante :

t ` ij : t0I G
t ` ij as x : t0I G[x : t 0](
ij -LIEUR)

Le motif universel n'ayant pas de variable libre ge'ne`re un environnement vide. Il accepte n'importe quel type en entre'e et produit le me^me type en sortie puisqu'il ne pose aucune contrainte sur son
argument :

t ` _ : tI ?(
ij -UNIVERSEL)

Pour qu'il existe un argument de type t accepte' par un motif primitif $ , il suffit que t soit le type
d'une constante accepte'e par $ :

a 2 $
a ` $ : aI ?(
ij -PRIM)

Les types des objets filtre's par les motifs #C {. . .} doivent e^tre dans #C et le type de chacun des
champs doit e^tre compatible avec les motifs des champs :2

t 2 #C 8i; C *`i .t/ ` iji : t0i I Gi
t ` #C {`1 D ij1I . . . I `n D ijn} : tI G1 l^ * * * l^ Gn(
ij -CLASSE)

Cette dernie`re re`gle pose cependant un le'ger proble`me : le type des motifs portant sur les champs de
l'objet peut tre`s bien e^tre strictement plus pre'cis que le type du champ obtenu par C *`i . Par exemple,
si on conside`re le motif #Cons l^tail D #Consl/, on constate que le motif sur le champ tail contraint
celui-ci a` e^tre un Cons, ce qui est plus pre'cis que le type ge'ne'ral du champ, qui est une List. En
conse'quence, il est ne'cessaire de rajouter la re`gle de subsomption suivante :

t ` ij : t0I G t 6 u

u ` ij : t0I G(
ij -SUB)

Cette re`gle se comprend intuitivement dela fac,on suivante : si ij peut accepter un argument de type t,
alors par la re`gle (SUB), celui-ci peut aussi e^tre conside're' avec type u.

Remarque. Dans la re`gle (ij -CLASSE), on remarque que le type t 0i pre'sent dans la pre'misse n'est pas
du tout utilise' dans la conclusion de la re`gle. Concre`tement, cela signifie que l'information supple'mentaire qu'on a de'duit sur le type de chacun des champs de l'objet filtre' est perdue.

Par exemple, conside'rons a` nouveau le motif #Cons l^tail D #Consl/ et le type t D Listhinti. Si
une expression e est filtre'e par ce motif, on sait que e est un objet construit avec la classe Cons et

2Rappelons que les re`gles de bonnes formations syntaxiques imposent que les domaines des Gi soient disjoints deux a`
deux.

3.11. TYPAGE DES ME'THODES 59
on sait aussi que son champ tail est e'galement construit avec la classe Cons. Cependant, le choix de
notre alge`bre de types ne nous donne aucun moyen d'exprimer ces proprie'te's dans un type unique.
Le mieux qu'on puisse faire est de demander de typer le corps du cas en faisant l'hypothe`se que
l'argument de la me'thode est de type Conshinti. Le proble`me, c'est que si on applique l'accesseurCons

*tail a` l'argument, alors le re'sultat sera de type Listhinti, un type moins pre'cis que l'information
dont on dispose.

On peut noter que le programmeur peut toujours utiliser un lieur pour obtenir le typage le plus
pre'cis. Par exemple, au lieu d'utiliser l'accesseur Cons*tail, il pourrait commencer par e'crire le motif
#Cons l^tail D #Cons as tl/. De cette fac,on, la variable t a bien le type pre'cis Conshinti. Ce me'canisme peut e^tre utilise' pour l'acce`s a` tous les champs profonds et re`gle essentiellement le proble`me.

Si on ne disposait pas des lieurs, il faudrait alors garder trace de toutes les contraintes sur le type
des champs lors d'un filtrage profond. Cela constituerait une extension conside'rable des environnements de typage dont les conse'quences ne sont pas claires. Remarquons finalement que, intrinse`quement, le proble`me ne vient pas du filtrage, mais du fait que, dans notre exemple, la classe Cons n'a
qu'un seul parame`tre de type. Comme c'est le programmeur qui de'clare les classes, on peut conside'rer que c'un choix de'libe're' de sa part de perdre de l'information au profit de la lisibilite' des types.
En effet, dans une alge`bre de types approprie'e, contenant notamment des types re'cursifs, on pourrait
tre`s bien imaginer que la classe Cons ait deux parame`tres de type (un pour chaque champ), ce qui
permettrait de ne jamais perdre d'information sur le type des champs. Un tel syste`me tend cependant a`
produire des types difficile a` lire et a` manipuler. C'est pourquoi, perdre de l'information de`s la de'claration de classe est parfois un bon compromis qui se paie par un pouvoir expressif le'ge`rement moins
grand. e^

Finalement, la dernie`re re`gle que nous introduisons concerne les motifs ouverts acceptant des
objets d'une classe ou d'une sous-classe :

t 0 6 t t ` #C {`1 D ij1I . . . I `n D ijn} : tI G

t0 ` C {`1 D ij1I . . . I `n D ijn} : t0I G(
ij -SOUS-CLASSE)

3.11.3 Un dernier axiome

La correction du typage des motifs de la forme C {`1 D ij1I . . . I `n D ijn} exige un dernier axiome
sur les alge`bres de type. En effet, un argument accepte' par ce motif est un objet construit avec une
classe C0 sous-classe de C. On lui donne donc un type e'le'ment de #C0. Cependant, la re`gle de typage
du motif implique qu'on ve'rifie le corps du cas uniquement dans l'hypothe`se ou` l'argument a un
sous-type quelconque d'un e'le'ment de #C. Pour assurer la correction, on doit donc supposer que tout
e'le'ment de #C0 est toujours approximable par un e'le'ment de #C :

AXIOME (APPROXIMATION).
Si C0 v C et si t0 2 #C0, alors il existe t 2 #C tel que t0 6 t.

60 CHAPITRE 3. TYPAGE ALGE'BRIQUE
3.12 Re'capitulatif

Cette section reprend succinctement toutes les de'finitions donne'es dans ce chapitre.

Pre'-alge`bres de types

Une pre'-alge`bre de types est la donne'e des e'le'ments suivants :
- un ensemble A de MONOTYPES ;
- une relation binaire 6! A * A ;
- un ope'rateur binaire !2 A * A ! A ;
- pour chaque classe C 2 Classes, un ensemble #C t, A ;
- pour chaque classe C 2 Classes et chaque e'tiquette ` 2 ChampsC , une fonction totale C *` 2

#C ! A ;
- pour chaque valeur primitive a 2 PrimVals, un monotype a 2 A.
Quand on voudra expliciter l'alge`bre de types utilise'e, on utilisera les notations suivantes pour

chacun des e'le'ments de l'alge`bre : 6A, !A, #C

A, C *`A et aA.

De'finitions auxiliaires

Les ensembles suivants sont de'finis :

fun , {t ! t0 | t; t0 2 A}
Classes , [

C2Classes

#C

A0 , [

a2PrimVals

a

t0 , {a 2 PrimVals | a 6 t0} .t0 2 A0/
ainsi que les notations :

X 6? Y ssi 8x 2 X; y 2 Y; x 66 y ^ y 66 x

"X , {y | 9x 2 X; x 6 y}
#X , {y | 9x 2 X; y 6 x}

Les lettres T; T 0 de'signent des ensembles non-vides de monotypes. Les lettres t0; u0; . . . des
e'le'ments de l'ensemble A0.

Axiomes

Une alge`bre de types est une pre'-alge`bre qui ve'rifie les axiomes suivants :

3.12. RE'CAPITULATIF 618

?!?: 8t 2 A; t 6 t

8tt 0t00 2 A; t 6 t0 ^ t0 6 t00 ) t 6 t00
8tt 0 2 A; t 6 t0 ^ t0 6 t ) t D t0
(SOUS-TYPAGE-ORDRE)

8tt0uu0 2 A; t ! u 6 t0 ! u0 () t0 6 t ^ u 6 u0(FLE`CHE-VARIANCE)

8CC0 2 Classes; 8t 2 #C; 8t 0 2 #C0; t0 6 t ) C0 v C(CLASSES-COVARIANTES)

8CC0 2 Classes; 8` 2 ChampsC ; 8t 2 #C; t 0 2 #C0; C0 v C ^ t0 6 t ) C0 *`.t0/ 6 C *`.t/
(CHAMPS-COVARIANTS)

fun 6? Classes ^ fun 6? A0 ^ Classes 6? A0(SE'PARATION)

8CC0 2 Classes; C0 v C ) #C0 t, ?y#C(APPROXIMATION)

Expressions de test

etest ::D a

| ?fun ou` ?fun t^ fun x ) fix y ) y
| C l^`1 D etest1 I . . . I `n D etestn l/

Re`gles de typage

G ` x : G.x/(VAR)
G ` e1 : t2 ! t G ` e2 : t2

G ` e1 e2 : t(APP)
G[x : t] ` e : t0
G ` fun x ) e : t ! t 0(FUN)
t 2 #C G ` e1 : C *`1.t/ . . . G ` en : C *`n.t/

G ` C {`1 D e1I . . . I `n D en} : t(OBJET)

t0 D C *`.t/
G ` C *` : t ! t0(GET)

62 CHAPITRE 3. TYPAGE ALGE'BRIQUE

G ` a : a(CST)
8a1 2 t01 ; . . . ; an 2 t0n ; f .a1; . . . ; an/ 2 t0 8i; Tuplen *i .t/ D t0i

G ` f : t ! t0(PRIM)
G ` e : T t 2 T

G ` e : t(INST)
T 6D ? pour tout t 2 T , G ` e : t

G ` e : T(GEN)
G ` e : t t 6 t0

G ` e : t0(SUB)
G ` e1 : T1 G[x : T1] ` e2 : T2

G ` let x D e1 in e2 : T2(LET)

G[x : T ] ` e : T
G ` fix x ) e : T(FIX)
t ! t0 FG ij1I . . . I ijk 8 j; G ` ij j ) e j : t ! t 0

G ` meth {ij1 ) e1I . . . I ijk ) ek} : t ! t0(METH)

8t00G0.t ` ij : t00I G0/ ) G l^ G0 ` e : t0

G ` ij ) e : t ! t0(CAS)

a 2 $
a ` $ : aI ?(
ij -PRIM)

t ` _ : tI ?(
ij -UNIVERSEL)

t ` ij : t 0I G
t ` .ij as x/ : t0I G[x : t0](
ij -LIEUR)

t ` ij : t0I G t 6 u

u ` ij : t0I G(
ij -SUB)

t 2 #C 8i; C *`i .t/ ` iji : t0i I Gi
t ` #C {`1 D ij1I . . . I `n D ijn} : tI G1 l^ * * * l^ Gn(
ij -CLASSE)

3.12. RE'CAPITULATIF 63

t0 6 t t ` #C {`1 D ij1I . . . I `n D ijn} : tI G

t0 ` C {`1 D ij1I . . . I `n D ijn} : t0I G(
ij -SOUS-CLASSE)

et enfin :

8etest; a,? ` etest : t c' ) dispatch.etestI ij1I . . . I ijk/ 6D erreur

t ! t0 FG ij1I . . . I ijk(COUVERTURE)

64 CHAPITRE 3. TYPAGE ALGE'BRIQUE65
Chapitre 4
Su^rete' du typage alge'brique

L'objectif de ce chapitre est de montrer le the'ore`me de correction du typage alge'brique vis-a`-vis
de la se'mantique ope'rationnelle.

4.1 E'nonce'

THE'ORE`ME 1 (SU^RETE' DU TYPAGE). S'il existe T tel que ? ` e : T , alors e 6-!? erreur.

La preuve de ce the'ore`me de'coule de deux lemmes. Le lemme de progression (lemme 4.7, page 67)
montre qu'une expression bien type'e ne provoque pas d'erreur de type a` l'exe'cution. Le lemme de
pre'servation du typage (lemme 4.12, page 72) montre que le typage est pre'serve' quand on e'value une
expression. Le reste de ce chapitre est consacre' a` la de'monstration de ces deux lemmes.

4.2 Pre'liminaires
4.2.1 Subsomption ge'ne'ralise'e

Soit T et T 0 deux polytypes. La relation binaire 6] est de'finie comme suit :

T 6] T 0 ssi 8t0 2 T 0; 9t 2 T; t 6 t0
Cette relation est un pre'ordre qui e'tend la relation 6 aux polytypes. En particuler, quand on identifie
t et {t}, on a {t} 6] {u} chaque fois que t 6 u. Notons aussi qu'on a T 6] t chaque fois que t 2 T .

LEMME 4.1 (SUBSOMPTION GE'NE'RALISE'E). La re`gle suivante de SUBSOMPTION GE'NE'RALISE'E
est admissible :

G ` e : T T 6] T 0

G ` e : T 0(SUB
])

De'monstration. Soit t0 2 T 0. Par de'finition de T 6] T 0, il existe t 2 T tel que t 6 t0. On de'duit

G ` e : t par la re`gle (INST) puis G ` e : t0 par (SUB). On a donc prouve' ce dernier jugement pour
tout t 2 T 0. On peut donc appliquer la re`gle (GEN) pour conclure. e^

66 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
4.2.2 Simplification des de'rivations

Une de'rivation de typage est dite SIMPLE si elle ne se termine ni par (SUB), ni par (INST), ni
par (GEN). Quand un jugement G ` e : T admet une de'rivation simple, on e'crit G `0 e : T . L'inte're^t de cette notion est que la dernie`re re`gle d'une de'rivation simple est de'termine'e par la forme de
l'expression, ce qui est tre`s utile pour les preuves par induction sur la structure de l'expression.

LEMME 4.2. Pour toute de'rivation de G ` e : T et tout e'le'ment t 2 T , il existe une de'rivation simple
G `0 e : T 0 pour un certain T 0 6] t.

De'monstration. On proce`de par induction sur la de'rivation de G ` e : T (1) (voir section 4.6, page 74
pour les proble`mes de fondements).

Si la de'rivation de (1) termine par (SUB), nous savons que t D T et qu'il existe t0 tel que t0 6 t (2)
et G ` e : t0 (3). De l'hypothe`se d'induction applique'e a` (3), on de'duit qu'il existe T 0 tel que T 0 6]
t0 (4) et G `0 e : T 0. En appliquant la transitivite' de 6] a` (2) et (4), on conclut que T 0 6] t.

Si la de'rivation de (1) termine par (INST), alors T est force'ment un monotype et on a t D T . De
plus, il existe T 00 tel que t 2 T 00 (5) et G ` e : T 00 (6). En appliquant l'hypothe`se d'induction a` (5)
et (6), on voit qu'il existe T 0 tel que T 0 6] t et G `0 e : T 0.

Si la de'rivation de (1) termine par (GEN), alors l'une des pre'misses de la re`gle est G ` e : t (7)
(car t 2 T ). En appliquant l'hypothe`se d'induction a` (7), on trouve T 0 tel que T 0 6] t et G `0 e : T 0.

Sinon, la de'rivation de (1) est de'ja` simple. On conclut en prenant T 0 D T , car on a bien T 6] t
puisque t 2 T . e^

4.2.3 Type des valeurs

LEMME 4.3. Si G ` e1 e2 : t, alors il existe t2 tel que G ` e1 : t2 ! t et G ` e2 : t2.

De'monstration. Appliquons le lemme 4.2 a` G ` e1 e2 : t. Il vient qu'il existe t 0 6 t (1) et G `0
e1 e2 : t0 (2). Comme l'expression e1 e2 est une application et que la de'rivation (2) est simple, elle ne
peut donc se terminer que par la re`gle (APP). On a donc G ` e2 : t2 et G ` e1 : t2 ! t 0 (3). Par
l'axiome (FLE`CHE-VARIANCE) applique' a` (1), il vient t2 ! t0 6 t2 ! t (4) et, en appliquant (SUB)
a` (3) et (4), on conclut G ` e1 : t2 ! t . e^

Un e'le'ment de l'ensemble Classes [ PrimVals [ {fun} est appele' NOEUD et note' avec les lettre
N , N 0, etc. Pour tout noeud N , N est de'fini comme l'ensemble #C si N vaut C, a s'il vaut a et fun
s'il vaut fun.

LEMME 4.4. Soit V une valeur telle que G ` V : t et N D te^te.V /. Alors, t 2 x?N .

De'monstration. Par le lemme de simplification 4.2, conside'rons une de'rivation simple de G ` V : t.
On a donc T 6] t (1) et G `0 V : T (2). On conside`re ensuite tous les cas possibles de valeur.

s^ Si V D a, on a te^te.V / D a. La la de'rivation (2) se terminant force'ment par (CST), T D a et donc
a 6 t.

s^ Si V D C {. . .}, on a te^te.V / D C. La de'rivation (2) se terminant ne'cessairement par (OBJET), on a

T est un monotype dans #C et donc t 2 x?#C .

4.3. LEMME DE PROGRESSION 67
s^ Si V D fun x ) . . . ou V D C *` ou V D f , on a te^te.V / D fun. La de'rivation de (2) se
terminant ne'cessairement par (FUN), (GET) ou (PRIM), T est force'ment un type fonctionnel e'le'ment
de fun donc de x?fun .

s^ Si V D meth {. . .}, on a te^te.V / D fun et, la de'rivation de (2) se terminant force'ment par (METH),

T est un monotype fonctionnel. Donc t 2 x?fun . e^

4.3 Lemme de progression

LEMME 4.5. Si G ` E[e] : t, alors il existe t 0 tel que G ` e : t 0.
De'monstration. Par le lemme de simplification 4.2, conside'rons un typage simple de E[e]. Si E est
de la forme [] e0 ou e0 [], alors la de'rivation termine force'ment par la re`gle (APP), l'une des pre'misses
de cette re`gle est un typage de e. Si E vaut let x D [] in e0, alors le typage simple termine
par la re`gle (LET) et fournit un typage de e. En appliquant la re`gle (INST), on en obtient un typage
monomorphe. Enfin, si E est de la forme C {` D []I . . .}, alors la dernie`re re`gle applique'e dans le
typage simple est force'ment (OBJET) et une des pre'misses fournit un typage monomorphe de e. e^

LEMME 4.6. Soit e une expression quelconque. Il existe une expression de test etest telle que :

- pour tout type t et tout environnement G, si G ` e : t, alors G ` etest : t ;
- pour tout motif ij , filtre.e; ij / D filtre.etest; ij /.

De'monstration. On obtient etest en remplac,ant dans e toute occurrence d'une expression dont la te^te
est fun par ?fun. Une induction simple sur la de'rivation de G ` e : t permet d'obtenir les re'sultats
espe're's. Cette preuve est fastidieuse mais sans difficulte'. e^

LEMME 4.7 (PROGRESSION). Si G ` e : t alors e 6-! erreur.

De'monstration. Par l'absurde, supposons que e -! erreur et proce'dons par induction sur la de'rivation de cette assertion. On conside`re donc la dernie`re re`gle applique'e R dans cette de'rivation.

s^ Si R est (ERREUR-CONTEXTE), alors on a e D E[e0] et e0 -! erreur. Par le lemme 4.5, on sait
que G ` e0 : t0 pour un certain t0. En appliquant l'hypothe`se d'induction, on voit que e0 6-! erreur,
ce qui est absurde.

Dans tous les autres cas, on constate que dans toutes les re`gles de de'duction d'une erreur, e est
force'ment l'application d'une valeur, appelons la V , notons N D te^te.V / et e'crivons e D V e0. En
appliquant le lemme 4.3, il vient G ` V : t0 ! t (1) et G ` e0 : t0 (2). En appliquant le lemme 4.4
a` (1), il vient que t0 ! t 2 x?N . Par l'axiome (SE'PARATION), on de'duit que N est force'ment e'gal a`fun

. R ne peut donc pas e^tre (ERREUR-FUN) et V0 est donc une valeur fonctionnelle, c'est-a`-dire une
fonction, une me'thode, une primitive ou un accesseur. Examinons maintenant ces diffe'rents cas.

s^ V D f . Dans les diffe'rentes re`gles R applicables dans ce cas, observons que e0 est toujours une
valeur, notons la V 0 et posons N 0 D te^te.V 0/. Conside'rons maintenant une de'rivation simple de (1).
Celle-ci se termine force'ment par la re`gle (PRIM) et on a G `0 f : u0 ! u0 (3), u0 ! u0 6 t0 !
t (4) et, pour tout i 2 [1; n], Tuplen *i .u0/ D u0i (5) et u0i 2 A0 (6) et enfin u01 * * * * * u0n t,

dom. f / (7). Comme Tuplen *i a pour domaine #Tuplen, on sait que u0 2 #Tuplen (8). Par
l'axiome (FLE`CHE-VARIANCE) applique' a` (4), il vient t0 6 u0 (9). En appliquant le lemme 4.4 a` la

68 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
de'rivation (2) et sachant que V 0 D e0, on peut e'crire t0 2 x?N 0 (10). Par transitivite' de 6 applique' a` (9)
et (10), on a donc u0 2 x?N 0 (11). Par l'axiome (SE'PARATION) applique' a` (8) et (11), on en de'duit que
le noeud N 0 est une classe. Notons cette classe C0. Par l'axiome (CLASSES-COVARIANTES), on de'duit
ensuite que C0 v Tuplen et enfin, par l'axiome (Tuplen -MINIMAL) que C0 D Tuplen. La re`gle

R applique'e pour de'duire l'erreur de type ope'rationnelle ne peut donc e^tre (ERREUR-PRIM-1) et V 0
est ne'cessairement un tuple de la forme he01; . . . ; e0ni. Conside'rons alors une de'rivation simple de (2).
Celle-ci se termine force'ment par la re`gle (OBJET) et on a G ` he01; . . . ; e0ni : v0 (12), v0 6 t0 (13) et,
pour tout i 2 [1; n], G ` e0i : v0i (14) et Tuplen *i .v0/ D v0i (15). Par transitivite' de 6 applique'e a` (13)
et (9), on a aussi v0 6 u0 (16). Puis, en appliquant l'axiome (CHAMPS-COVARIANTS) a` cette dernie`re
ine'galite', il vient Tuplen *i .v0/ 6 Tuplen *i.u0/, c'est-a`-dire v0i 6 u0i (17). On peut donc appliquer
la re`gle (SUB) a` (14) et (17) et de'duire G ` e0i : u0i (18).

Supposons maintenant que l'une des expressions e0i soit une valeur V 0i . Notons N 0i sa te^te et supposons qu'elle ne soit pas une valeur primitive, c'est-a`-dire que V 0i 62 PrimVals. Par le lemme 4.4 applique' a` (18), on sait que u0i 2 x??N 0i . Par ailleurs, par (6), on sait que u0i 2 A0. L'axiome (SE'PARATION)
nous permet alors de de'duire que N 0i 2 PrimVals. L'hypothe`se V 0i 62 PrimVals est donc absurde et R
ne peut e^tre (ERREUR-PRIM-2).

Supposons maintenant que toutes les expressions e0i soient des valeurs. Celles-ci sont donc toutes
des constantes que nous notons ai et on a u0i 2 "ai . Par de'finition de u0i , cela signifie que la constante
ai est dans l'ensemble u0i et par (7) que .a1; . . . ; an/ 2 dom. f /. Donc la re`gle (ERREUR-PRIM-3) est
inapplicable pour de'duire que e est une erreur de type.

On a donc montre' qu'une application bien type'e d'une primitive ne peut jamais e^tre une erreur de
type ope'rationnelle.

s^ V D C *`. Dans les diffe'rentes re`gles R applicables dans ce cas, observons que e0 est toujours une
valeur, notons la V 0 et posons N 0 D te^te.V 0/. Conside'rons maintenant une de'rivation simple de V .
Celle-ci se termine force'ment par la re`gle (GET) et il existe donc u et u0 tels que C *`.u0/ D u (19)
et u0 ! u 6 t0 ! t (20). Par la contravariance de la fle`che applique'e a` cette dernie`re ine'galite', il
vient que t 0 6 u0. Or u0 e'tant dans le domaine de C *`, il est aussi dans #C. Par ailleurs, le lemme 4.4
applique' a` (2) nous donne t0 2 x?N 0 . L'axiome de se'paration nous impose donc N 0 2 Classes et celui
de covariance des classes N 0 v C. En fin de compte, on a donc montre' qu'une application bien type'e
de l'accesseur C *` ne peut jamais e^tre une erreur de type ope'rationnelle.

s^ V D meth {ij1 ) e1I . . . I ijk ) ek} Nous allons montrer dans ce cas que le dispatch ne peut
e'chouer. Conside'rons un typage simple de V , celui-ci se termine ne'cessairement par la re`gle (METH)
et il existe donc u et u0 tels que u0 ! u 6 t0 ! t (21) et u0 ! u FG ij1I . . . I ijk. Par la variance
de la fle`che applique'e a` (21), on sait que t0 6 u0 (22) et on a donc G ` e0 : u0 par la re`gle (SUB)
applique'e a` (2) et (22). En appliquant le lemme 4.6 a` e0 on peut trouver une expression de test etest
telle que G ` etest : u0. Par de'finition du test de couverture (re`gle (COUVERTURE)), on en de'duit que
dispatch.etestI ij1I . . . I ijk/ 6D erreur. Comme, par ailleurs, e0 et etest sont filtre'es par exactement les
me^mes motifs, on a donc dispatch.etestI ij1I . . . I ijk/ D dispatch.e0I ij1I . . . I ijk/. On conclut qu'on ne
peut de'duire que e est une erreur de type ope'rationnelle par la re`gle (ERREUR-ME'THODE).

En fin de compte, on a montre' que dans tous les cas, si e est bien type'e, alors aucune re`gle ne permet de conclure que c'est une erreur de type ope'rationnelle. C'est donc que e est ope'rationnellement
bien type'e. e^

4.4. LEMME DE SUBSTITUTION 69
4.4 Lemme de substitution

LEMME 4.8. Soit R un renommage de variables du programme, G un environment, ij un motif et t un
monotype. Le jugement t ` [R]ij : t0I G est e'quivalent a` t ` ij : t0I G s' R.

De'monstration. Par induction triviale sur le motif ij . e^

Par la suite, on utilise la notation G ` S : G0 si dom.S/ D dom.G0/ et pour tout x 2 dom.S/,
G ` S.x / : G0.x/.

LEMME 4.9 (LEMME DE SUBSTITUTION). Si G l^ G0 ` e : T et G ` S : G0, alors G ` [S]e : T .

De'monstration. L'ide'e de la preuve est tre`s simple : il s'agit de remplacer dans la de'rivation de G l^

G0 ` e : T toutes les occurrences de la re`gle (VAR) qui portent sur une variable x dans le domaine
de S par la de'rivation de G ` S.x/ : G0.x/. La de'monstration est rendue complique'e car il faut tenir
compte des renommage ne'cessaires pour e'viter les captures lors de substitutions. Du coup, elle est
assez longue et technique, mais ne contient rien de plus que l'ide'e de base.

Nous allons montrer une proprie'te' plus ge'ne'rale : dans les hypothe`ses suivante :

dom.G0/ D dom.S/(1)

G l^ G0 ` e : T(2)
8x 2 fv.e/; x 62 dom.S/ ) .G l^ G00/.x/ D .G l^ G0/.x/(3)

8x 2 fv.e/; x 2 dom.S/ ) G l^ G00 ` S.x/ : G0.x/(4)

on a le re'sultat G l^ G00 ` [S]e : T (5).

On proce`de par induction sur la de'rivation de (2), en conside'rant la dernie`re re`gle R applique'e.
s^ Si R est (CST), (PRIM), (GET), le re'sultat est trivial : e n'a pas de variable libre et [S]e D e a le type

T quel que soit l'environnement de typage.

s^ Si R est (APP), (OBJET), (GEN), (INST) ou (SUB), le re'sultat de'coule imme'diatement de l'hypothe`se
d'induction applique'e aux pre'misses de la re`gle.

s^ Si R est (VAR), alors e est une variable x et T D .G l^ G0/.x/.

- Si x 62 dom.S/, alors [S]x D x. On a, par l'hypothe`se (3) : .G l^ G00/.x/ D .G l^ G0/.x/. Donc

.G l^ G0/.x / D T et, en appliquant la re`gle (VAR), il vient G l^ G00 ` x : T . On conclut en
remarquant x D [S]x ;
- Si x 2 dom.S/, alors [S]x D S.x/, x 2 dom.G0/ et donc .G l^ G0/.x/ D G0.x /. On conclut

en e'crivant l'hypothe`se (4) G l^ G00 ` S.x / : G0.x / et en remarquant que S.x/ D [S]x et

G0.x / D T .
s^ Il reste le cas de'licat ou` la re`gle R concerne une expression e qui contient un lieur. Conside'rons le
cas le plus complique', c'est-a`-dire quand R D (METH). Dans ce cas, nous avons T D t ! t0 et :

e D meth {ij1 ) e1I . . . I ijk ) ek}

t ! t0 FG ij1I . . . I ijk
8 j; G l^ G0 ` ij j ) e j : t ! t0(6)

La de'finition de la substitution sur les cas est alors la suivante : [S].ij j ) e j / D [R j ]ij j ) [S l^ R j ]e j
ou` R j D R.fv.ij j /; fv.S z' Vj / [ Vj / et Vj D fv.e j / \ fv.ij j /. Prenons maintenant G j et t00j quelconques

70 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
tels que t ` [R j ]ij j : t00j I G j (7). Par le lemme 4.8, on de'duit de (7) que t ` ij j : t00j I G j s' R j . Une
des pre'misses de (6) nous permet alors d'e'crire G l^ G0 l^ .G j s' R j / ` e j : t0 (8) et cette dernie`re
de'rivation est une sous-de'rivation de (2), sur laquelle on peut donc appliquer l'hypothe`se d'induction.
Posons maintenant G0j D G0 l^ .G j s' R j /, Sj D S l^ R j et G00j D G00 l^ G j et montrons que e j , t0, G0j ,

Sj et G00j conviennent pour appliquer l'hypothe`se d'induction.

On a dom.Sj / D dom.S/ [ dom.R j / et dom.G0j / D dom.G0/ [ dom.R j /. On a donc bien
dom.S j / D dom.G0j / (hypothe`se (1)). Le jugement (8) peut s'e'crire G l^ G0j ` e j : t0 (hypothe`se (2)).
Conside'rons maintenant x 2 fv.e j / tel que x 62 dom.Sj /. On a donc x 62 fv.ij j / et x 62 dom.S/.
Du coup, x 2 Vj et donc x 62 codom.R j /. On a donc .G l^ G00j /.x/ D .G l^ G00/.x/ En appliquant
l'hypothe`se (3), il vient .G l^ G00/.x / D .G l^ G0/.x/ et finalement .G l^ G0i /.x/ car x 62 fv.ij / j .
L'hypothe`se (3) est donc satisfaite par les candidats a` l'application de l'hypothe`se d'induction.

Conside'rons finalement x 2 fv.e j / tel que x 2 dom.S j /. Nous avons deux cas selon que x 2
fv.ij j / ou non :

- si x 2 fv.ij j /, dans ce cas, Sj .x/ D R j .x /, G0j .x/ D G j .R j .x// et G00j .R j .x// D G j .R j .x//.

On peut donc appliquer la re`gle (VAR) pour de'duire G l^ G00j ` Sj .x/ : G0j .x/ ;
- si x 62 fv.ij j /. On a alors : Sj .x/ D S.x/ et G0j .x/ D G0.x/. En appliquant l'hypothe`se (4),

on a donc G l^ G00 ` S j .x/ : G0j .x/. On conclut en remarquant que fv.Sj .x// kD codom.R j / D
dom.G j /, ce qui nous permet d'e'crire .G l^ G00/ l^ G j ` S j .x/ : G0j .x/ et l'environnement
.G l^ G00/ l^ G j est par de'finition e'gal a` G l^ G00j .
Dans tous les cas, l'hypothe`se (4) est donc respecte'e.

Nous pouvons donc appliquer l'hypothe`se d'induction et il vient G l^ G00j ` [Sj ]e j : t 0. On a
donc montre' que pour tout G j et t 00j tels que G j ` [R j ]ij j : t ! t00j , on a aussi .G l^ G00/ l^ G j `
[Sj ]e j : t0. Donc, toutes les hypothe`ses sont respecte'es pour pouvoir re'appliquer la re`gle (CAS) et
de'duire G l^ G00 ` [R j ]ij j ) [S j ]e j : t ! t0. Il suffit alors d'appliquer la re`gle (METH) pour
conclure.

s^ Les cas ou` R est (FUN), (LET) ou (FIX) sont similaires. e^

4.5 Lemme de pre'servation du typage

On de'finit la relation binaire z' sur les expressions par la proprie'te' suivante :

e z' e0 ssi 8G; 8t; .G ` e : t/ ) a,G ` e0 : t c'
LEMME 4.10. Pour tout contexte E, si e z' e0, alors E[e] z' E[e0].

De'monstration. On examine tous les cas possibles pour le contexte E.
s^ Si E D [] e0, alors E[e] D e e0. Prenons G et t quelconques tels que : G ` e e0 : t (1). Par le
lemme 4.3 applique' a` cette dernie`re de'rivation, il existe t0 tel que G ` e : t0 ! t (2) et G ` e0 : t0 (3).
Par l'hypothe`se e z' e0 applique'e a` (1), on sait que G ` e0 : t0 ! t (4). On de'duit en appliquant la
re`gle (APP) a` (3) et (4) que G ` e0 e0 : t et on conclut en remarquant que e0 e0 D E[e0].

s^ Si E D e0 [], la preuve est presque identique au cas [] e0.
s^ Si E D let x D [] in e0, alors E[e] D let x D e in e0. Prenons G et t quelconques tels que

G ` let x D e in e0 : t (5). Par le lemme 4.2, on peut trouver une de'rivation simple de (5). Celle-ci
termine force'ment par la re`gle (LET) et on a G ` e : T0 (6), G[x : T0] ` e0 : T (7) et T 6] t (8).

4.5. LEMME DE PRE'SERVATION DU TYPAGE 71
Prenons maintenant un e'le'ment t0 quelconque de T0. Par la re`gle (INST) applique'e a` (6) on a G `
e : t0 (9). On peut appliquer l'hypothe`se e z' e0 a` (9) pour de'duire G ` e0 : t0. Comme on a montre' ce
dernier jugement pour tout t0 2 T0, on peut appliquer la re`gle (GEN) pour trouver G ` e0 : T0 (10). On
peut alors re'appliquer la re`gle (LET) a` (10) et (7), de sorte que G ` let x D e0 in e0 : T , c'est-a`-dire

G ` E[e0] : T (11). On conclut en appliquant la re`gle (SUB]) a` (11) et (8).

s^ Si E D C {`1 D e1I . . . I `i D []I . . . I `n D en}. Prenons G et t quelconques tels que :

G ` C {`1 D e1I . . . I `i D eI . . . I `n D en}-- -z ""

E[e]

: t(12)

Par le lemme de simplification 4.2, on peut trouver une de'rivation simple de ce jugement. Celle-ci se
termine force'ment par la re`gle (OBJET) et il existe t0 tel que t0 6 t, t0 2 #C, G ` e : C *`i .t0/ (13) et

G ` e j : C *` j .t0/ pour tout j 6D i. En appliquant l'hypothe`se e z' e0 a` (13), il vient G ` e0 : C *`i .t0/.
On peut alors re'appliquer les re`gles (OBJET) puis (SUB) pour conclure :

G ` C l^`1 D e1I . . . I `i D e0I . . . I `n D enl/-- -z ""

E[e0]

: t

e^
LEMME 4.11 (PROJECTION). Si G ` e : t et filtre.e; ij / D vrai, alors il existe G0 et t0 tels que
t ` ij : t0I G0, t0 6 t, G ` e : t0 et G ` e # ij : G0

De'monstration. E'crivons G ` e : t (1) et filtre.e; ij / D vrai (2) et proce'dons par induction sur la
structure du motif ij .

s^ Si ij D _, il suffit de prendre t0 D t et G0 D ?.
s^ Si ij D $ , alors, par de'finition du filtrage, on a e D a (3) et a 2 $ (4). Prenons t0 D a et

G0 D ?. Par le lemme 4.4, on sait que t0 6 t. Par la re`gle (ij -PRIM), on a aussi t0 ` ij : t 0I ? et par la
re`gle (ij -SUB) t ` ij : t 0I ?. Enfin e # ij e'tant vide, l'environnement vide ? en est un typage correct.

s^ ij D ij0 as x. Par de'finition du filtrage et de la projection, on a filtre.e; ij0/ D vrai (5) et e # ij D
e # ij0 l^ [x 7! e] (6). Appliquons l'hypothe`se d'induction a` (5) et (1). On peut donc trouver t0 et G00
tels que t0 6 t (7), t ` ij0 : t0I G00 (8), G ` e # ij0 : G00 (9) et G ` e : t0. Posons alors G0 D G00[x : t0].
Par la re`gle (ij -LIEUR) applique'e a` (8), on a t0 ` ij : t0I G0. Par ailleurs, par (6) et (9), on a aussi

G ` e # ij : G0.

s^ Si ij D #C {`1 D ij1I . . . I `n D ijn}, alors, par de'finition du filtrage, e est force'ment un objet de
classe C, c'est-a`-dire de la forme e D C {`1 D e1I . . . I `n D en} (10). De plus, pour tout i 2 [1; n],
on afiltre.ei ; iji / D vrai (11). Par le lemme de simplification 4.2, on peut conside'rer une de'rivation
simple de (1). Vu la nature de e, celle-ci se termine force'ment par la re`gle (OBJET) et il existe t0 tel que
t0 6 t (12), t0 2 #C (13), G ` e : t 0 (14) et G ` ei : C *`i .t0/ (15). Appliquons l'hypothe`se d'induction
a` (11) et (15) pour chaque i 2 [1; n]. Il existe donc t0i et G0i tels que t0i 6 C *`i .t0/ (16), G ` ei : t0i (17),
C *`i .t0/ ` iji : t0i I G0i (18) et G ` ei # iji : G0i (19). Les e'quations (13) et (18) constituent les pre'misses
de la re`gle (ij -CLASSE), ce qui permet de de'duire t0 ` ij : t0I G01 l^ * * * l^ G0n. Posons finalement

G0 D G01 l^ * * * l^ G0n. Il reste a` montrer que G ` e # ij : G0. Prenons x 2 fv.ij /. Comme l'ensemble
des variables libres de chacun des sous-motifs iji sont deux-a`-deux disjoints, il existe un unique i tel
que x 2 fv.iji / et on a alors .e # ij /.x/ D .ei # iji /.x/. On conclut en appliquant (19) et en remarquant
que les autres G0i ne peuvent masquer la variable x.

72 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
s^ ij D C {`1 D ij1I . . . I `n D ijn}. Par de'finition du filtrage, on a pour une certaine classe C0 v C :
e D C0 {`1 D e1I . . . I `n D enI . . . I `n0 D en0} (20) et pour tout i 2 [1; n], filtre.ei ; iji / D vrai (21).
Par le lemme de simplification 4.2, on peut conside'rer une de'rivation simple de (1). E'tant donne'e la forme de e, cette de'rivation se termine force'ment par la re`gle (OBJET) et il existe t0 tel que
t0 6 t (22), t0 2 #C0 (23), G ` e : t0 (24) et, pour tout i 2 [1; n], G ` ei : C0 *`i .t0/ (25).
L'axiome (APPROXIMATION) applique' a` (23) nous dit qu'il existe t00 2 #C tel que t0 6 t00. En
appliquant l'axiome (CHAMPS-COVARIANTS) a` cette dernie`re ine'galite' et sachant C0 v C, il vient
C0 *`i .t0/ 6 C *`i .t00/ (26). Par la re`gle (SUB) applique'e a` (25) et (26), on a G ` ei : C *`i .t00/ (27).
Appliquons maintenant l'hypothe`se d'induction a` (21) et (27) pour chaque i 2 [1; n]. Il existe donc t 0i
et G0i tels que t0i 6 C *`i .t 00/ (28), G ` ei : t0i (29), C *`i .t00/ ` iji : t0i I G0i (30) et G ` ei # iji : G0i (31).
Le jugement (30) et le fait que t00 2 #C constituent les pre'misses de la re`gle (ij -CLASSE), ce qui
permet de de'duire :

t00 ` #C {`1 D ij1I . . . I `n D ijn} : t00I G01 l^ * * * l^ G0n(32)
Finalement, cette dernie`re e'quation plus l'ine'galite' t0 6 t00 sont les pre'misses de (ij -SOUS-CLASSE)
et on conclut t0 ` ij : t 0I G01 l^ * * * l^ G0n.

Le typage de la substitution e # ij est identique au cas pre'ce'dent. e^

LEMME 4.12 (PRE'SERVATION DU TYPAGE). Si e -! e0, alors e z' e0.

De'monstration. Par induction sur la de'rivation de e -! e0.

Si la dernie`re re`gle applique'e est (CONTEXTE), alors il existe E, e0 et e00 tels que e D E[e0],
e0 D E[e00] et e0 -! e00 (1). En appliquant l'hypothe`se d'induction a` (1), il vient e0 z' e00 (2). On
conclut en appliquant le lemme 4.10 a` (2).

s^ Si la dernie`re re`gle applique'e dans la de'rivation de e -! e0 est diffe'rente de (CONTEXTE), conside'rons une de'rivation quelconque de G ` e : t. Par le lemme de simplification 4.2, il existe un polytype

T 6] t et une de'rivation simple de G `0 e : T . Supposons qu'on puisse en de'duire que G ` e0 : T .
Dans ce cas, on sait, par de'finition de 6], qu'il existe un certain t0 2 T tel que t0 6 t. Par application
de la re`gle (INST) suivie de la re`gle (SUB), il vient que G ` e0 : t.

Pour montrer e z' e0, il suffit donc de prouver que G `0 e : T (3) implique G ` e0 : T . Pour cela,
nous conside'rons les diffe'rents cas possibles pour la re`gle R utilise'e dans la de'rivation e -! e0.

s^ Si R D (BETA), alors e D .fun x ) e1/ e2 et e0 D [x 7! e2]e1. La de'rivation de (3) e'tant
simple, on a T D t1, G ` e2 : t2 (4) et G ` fun x ) e1 : t2 ! t1. Par le lemme de simplification 4.2, il existe t01 et t02 tels que t02 ! t01 6 t2 ! t1 (5) et G `0 .fun x ) e1/ : t02 ! t01 (6).
La de'rivation de (6) se terminant ne'cessairement par (FUN), on a G[x : t 02] ` e1 : t01 (7). En appliquant l'axiome (FLE`CHE-VARIANCE) a` (5), il vient t2 6 t02 (8) et t01 6 t1 (9). En appliquant la
re`gle (SUB) a` (4) et (8), on a G ` e2 : t02 (10). Par le lemme de substitution 4.9 applique' a` (7) et (10),
on sait que G ` [x 7! e2]e1 : t01 (11). Enfin, par la re`gle (SUB) applique'e a` (9) et (11), on conclut

G ` [x 7! e2]e1 : t1, c'est-a`-dire G ` e0 : T .

s^ Si R D (BETA-LET), alors on a e D .let x D e1 in e2/ et e0 D [x 7! e1]e2. La de'rivation du
jugement (3) e'tant simple, elle se termine force'ment par (LET) et on a G ` e1 : T1 (12) et G[x : T1] `
e2 : T (13). Par le lemme de substitution 4.9 applique' a` (12) et (13), on conclut G ` [x 7! e1]e2 : T ,
c'est-a`-dire G ` e0 : T .

4.5. LEMME DE PRE'SERVATION DU TYPAGE 73
s^ Si R D (BETA-FIX), alors on a e D fix x ) e0 et e0 D [x 7! e]e0. La de'rivation simple
du jugement (3) se terminant force'ment par (FIX), on a G[x : T ] ` e0 : T (14). Par le lemme de
substitution 4.9 applique' a` (3) et (14), on conclut G ` [x 7! e]e0 : T , c'est-a`-dire G ` e0 : T .

s^ Si R D (BETA-OBJ), on a, l'indice i e'tant fixe', e D C *`i .C0 {`1 D e1I . . . I `n D en}/ et e0 D ei . La
de'rivation simple de (3) se terminant ne'cessairement par (APP), on a T D ti , G ` C *`i : t ! ti (15)
et G ` C0 {`1 D e1I . . . I `n D en} : t (16). En appliquant le lemme de simplification 4.2 a` (15), on
voit qu'il existe t00 et t00i tels que t 00 ! t00i 6 t ! ti (17) et G `0 C *`i : t00 ! t00i (18). Cette
dernie`re de'rivation e'tant simple, elle termine force'ment par la re`gle (GET) dont une des pre'misses
est C *`i .t00/ D t00i (19) dont on de'duit aussi t00 2 #C (20). Par ailleurs, en appliquant une nouvelle fois le lemme de simplification 4.2 cette fois a` (16), on trouve t000 tel que t000 6 t (21) et

G `0 C0 {`1 D e1I . . . I `n D en} : t000 (22). Cette dernie`re de'rivation, e'tant simple, se termine force'ment par la re`gle (OBJET) dont on de'duit G ` ei : t000i (23) et C0 *`i .t000/ D t000i (24), d'ou` e'galement t000 2 #C0 (25). En appliquant l'axiome (FLE`CHE-VARIANCE) a` (17), on de'duit t 6 t 00 (26)
et t00i 6 ti (27). Par transitivite' de 6 applique'e a` (21) et (26), on sait donc que t000 6 t00 (28). Par
l'axiome (CLASSES-COVARIANTES) applique' a` (25), (20) et (28), on de'duit que C0 v C (29). Puis,
par l'axiome (CHAMPS-COVARIANTS) applique' a` (29) et (28), on de'duit C0 *`i .t000/ 6 C *`i .t00/ (30).
En tenant compte des e'galite's (19) et (24), (30) peut se re'e'crire t000i 6 t00i (31). En appliquant la transitivite' de 6 a` (31) et (27), il vient alors t 000i 6 ti (32). Par la re`gle (SUB) applique'e a` (23) et (32), on
conclut G ` ei : ti , c'est-a`-dire G ` e0 : T .

s^ Si, R D (BETA-PRIM), on a alors e D f ha1; . . . ; ani (33), a0 D f .a1; . . . ; an/ (34) et e0 D
a0 (35). La de'rivation simple de (3) se terminant ne'cessairement par (APP), on a T D t0 (36), G `

f : t ! t0 (37) et G ` ha1; . . . ; ani : t (38). En appliquant le lemme 4.2 a` (37), on trouve t0 et t00
tels que G `0 f : t0 ! t00 (39) et t0 ! t00 6 t ! t0 (40). La de'rivation de (39) se terminant
ne'cessairement par la re`gle (PRIM), on de'duit, l'indice i prenant toutes les valeurs entre 1 et n, t00 2
A0 (41), Tuplen *i .t0/ D t0i (42) et 8a1 2 t01 ; . . . ; an 2 t0n ; f .a1; . . . ; an/ 2 t 00 (43). Par ailleurs,

re'-appliquons le lemme de simplification 4.2 a` (38) : il existe donc u tel que u 6 t (44) et G `0
ha1; . . . ; ani : u (45). La de'rivation de (45) se terminant force'ment par (OBJET), on de'duit que G `
ai : ui (46) et Tuplen *i .u/ D ui (47) ou` l'indice i prend toutes les valeurs entre 1 et n. Appliquons
maintenant l'axiome (FLE`CHE-VARIANCE) a` (40). On de'duit t 6 t0 (48) et t00 6 t0 (49). Par transitivite'
de 6 applique'e a` (44) et (48), on sait u 6 t0 (50). Par l'axiome (CHAMPS-COVARIANTS) applique'
a` (50) et a` la classe Tuplen, il vient Tuplen *i .u/ 6 Tuplen *i .t0/ (51). En tenant compte des
e'galite's (42) et (47), (51) peut se re'e'crire ui 6 t0i (52). Par le lemme de typage des valeurs 4.4 applique'
a` (46), on sait que ai 6 ui (53). Par transitivite' de 6 applique'e a` (53) et (52), il vient ai 6 t0i (54). Par
de'finition de t0i , il vient alors ai 2 t0i (55). L'une des pre'misse de (43) applique'e a` (55) nous permet de

de'duire f .a1; . . . ; an/ 2 t00, c'est-a`-dire a0 2 t00 (56). Par de'finition de t00, on sait alors que a0 6 t00 (57).
Par transitivite' de 6 applique'e a` (57) et (49), on a a0 6 t0 (58). Par (CST), on sait G ` a0 : a0 (59) et
on conclut enfin par (SUB) applique'e a` (59) et (58) que G ` a0 : t0, c'est-a`-dire G ` e0 : T .

s^ Si R D (BETA-METH), alors e est de la forme e D .meth {ij1 ) e1I . . . I ijk ) ek}/ e0 (60)
et il existe un indice j tel que filtre.e0; ij j / D vrai (61) et e0 D [e0 # ij j ]e j (62). La de'rivation
simple de (3) se terminant ne'cessairement par (APP), on a T D t1 (63), G ` e0 : t0 (64) et G `meth

{ij1 ) e1I . . . I ijk ) ek} : t0 ! t1 (65). On peut re'appliquer le lemme de simplification 4.2
a` ce dernier jugement pour en trouver une de'rivation simple. Celle-ci se termine force'ment par la
re`gle METH et il existe t00 et t 01 tels que t00 ! t01 6 t0 ! t1 (66) et G ` ij j ) e j : t00 ! t01 (67).
Par la variance de la fle`che applique' a` (66), on sait que t0 6 t00 (68) et t01 6 t1 (69). En appliquant la
re`gle (SUB) applique'e a` (64) et (68), on sait que G ` e0 : t00 (70). Appliquons maintenant le lemme

74 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
de projection 4.11 a` ce dernier jugement en sachant que filtre.e0; ij j / D vrai. On trouve qu'il existe
t000 et G0 tels que t00 ` ij j : t000 I G0 (71) et G ` e0 # ij j : G0 (72). Or, dans les pre'misses de la de'rivation
de (67), on a, entre autres a,t00 ` ij j : t000 I G0c' ) a,G l^ G0 ` e j : t01c'. On en de'duit donc la partie droite
de cette implication, c'est-a`-dire G l^ G0 ` e j : t01. On peut alors appliquer le lemme de substitution 4.9
a` ce jugement et a` (72) pour de'duire G ` [e0 # ij j ]e j : t01 (73). On conclut en appliquant la re`gle (SUB)
a` (73) et (69) que G ` [e0 # ij j ]e j : t1, c'est-a`-dire que G ` e0 : T . e^

4.6 A` propos de l'induction sur les de'rivations infinies

Dans toutes les preuves de ce chapitre, nous nous sommes permis de faire des inductions sur des
de'rivations potentiellement infinies. Le langage mathe'matique du discours que nous manipulons informellement a donc potentiellement un proble`me de fondement qui pourrait remettre en question tous
nos re'sultats. En re'alite', il n'en est rien et pour s'en convaincre comple`tement, nous allons expliciter
dans le cadre du calcul des constructions inductives [CP90] un petit fragment du syste`me de types et
de la preuve de correction. La mode'lisation est faite dans l'assistant de preuve CoQ [CDT01].

Le fragment conside're' contient en particulier la re`gle de typage (GEN), qui quantifie sur tousles e'le'ments d'un ensemble e'ventuellement infini. On prouve formellement le lemme de simplification 4.2 :

(* On suppose donne'e une alge`bre de types *)
Parameter monotype: Set.
(* Voici sa relation de sous-typage *)
Parameter leq: monotype -> monotype -> Prop.

(* Voici les axiomes ne'cessaires pour ce fragment *)
Axiom leq_refl: (t: monotype) (leq t t).
Axiom leq_trans: (t,u,v: monotype) (leq t u) -> (leq u v) -> (leq t v).

(* L'ensemble des expression est laisse' ouvert:

on ne s'inte'resse ici qu'au polymorphisme *)
Parameter expr: Set.

(* Cette relation contient toutes les re`gles de typage monomorphes:

(App), (Fun), etc. *)
Parameter well_typed_0: expr -> monotype -> Prop.

(* Un polytype est un ensemble quelconque de monotypes. On ne dit qu'il

est non-vide que dans la re`gle (Gen) ci-dessous *)
Definition polytype := monotype -> Prop.

(* Cette fonction construit le polytype singleton a` partir d'un

monotype *)
Definition Singleton: monotype -> polytype :=

[t: monotype][u: monotype] t=u.

(* Definition du syste`me de types (sans environnement pour simplifier) *)
Inductive well_typed: expr -> polytype -> Prop :=

(* Toute les re`gles "monomorphes" *)
Other: (e: expr; t: monotype)

4.6. A` PROPOS DE L'INDUCTION SUR LES DE'RIVATIONS INFINIES 75

(well_typed_0 e t) ->
(well_typed e (Singleton t))

| (* Re`gle d'instantiation *)

Inst: (e: expr; T: polytype; t: monotype)

(well_typed e T) ->
(T t) ->
(well_typed e (Singleton t))

| (* Re`gle de subsomption *)

Sub: (e: expr; t1, t2: monotype)

(well_typed e (Singleton t2)) ->
(leq t2 t1) ->
(well_typed e (Singleton t1))

| (* Re`gle de ge'ne'ralisation *)

Gen: (e: expr; T: polytype)

(* T est non-vide *)
(EX t: monotype | (T t)) ->
((t: monotype) (T t)->(well_typed e (Singleton t))) ->
(well_typed e T)
.

(* Lemme de simplification~\eqref{S.lemma.simple} *)
Lemma Simpl: (e: expr; T: polytype)(well_typed e T) ->

(t: monotype)(T t) ->
(EX t0: monotype | (well_typed_0 e t0) /\ (leq t0 t)).
Proof.
Intros e T Derivation.
NewInduction Derivation.

(* Re`gle Other *)
Intros. Red in H0; Rewrite <- H0. Split with t.
Split. Trivial. Apply leq_refl.

(* Re`gle Inst *)
Intros. Red in H0; Rewrite <- H0. Apply IHDerivation. Trivial.

(* Re`gle Sub *)
Intros u1 H1. Red in H1. Rewrite <- H1.
Cut (EX t0:monotype | (well_typed_0 e t0) /\ (leq t0 t2)).
Intro. Elim H0. Intros. Split with x. Split. Tauto.
Apply leq_trans with u:=t2. Tauto. Trivial.
Apply IHDerivation. Red; Trivial.

(* Re`gle Gen *)
Intros. Trivial. Apply (H1 t H2 t). Red. Trivial.
Qed.

La preuve du the'ore`me peut alors e^tre ve'rifie'e dans l'outil CoQ (ici dans sa version 7.2) :
Welcome to Coq 7.2 (December 2001)

76 CHAPITRE 4. SU^RETE' DU TYPAGE ALGE'BRIQUE
Coq < Load preuve.
Coq < Check Simpl.
Simpl

: (e:expr; T:polytype)

(well_typed e T)
->(t:monotype)

(T t)->(EX t0:monotype | (well_typed_0 e t0)/\(leq t0 t))

77
Chapitre 5
Annotations et ve'rification de types

Sauf cas particulier, le syste`me de types pre'sente' au chapitre 3 est inde'cidable. D'abord a` cause
de la re'cursion (expression fix) dont la re`gle de typage est polymorphe. Cela est connu pour e^tre
une source d'inde'cidabilite' dans le typage de ML[KTU93] : en pre'sence de re'cursion polymorphe, le
typage de ML est e'quivalent a` un proble`me de semi-unification inde'cidable pluto^t qu'a` un proble`me
simple d'unification. Ensuite parce que le typage des me'thodes est probablement aussi difficile. Inde'pendamment de la de'cidabilite', il n'est de toute fac,on pas souhaitable d'infe'rer le type d'une me'thode
si les cas de de'finition sont e'crits dans des modules diffe'rents, ce qui est l'un des objectifs des me'thodes. Par ailleurs, une me'thode est souvent naturellement re'cursive et la re'cursion polymorphe est
inte'ressante dans certains cas. Par exemple, pour de'finir une me'thode ge'ne'rale d'impression d'objet,
le cas de de'finition sur les couples donnera naturellement lieu a` un appel re'cursif par composante du
couple, c'est-a`-dire deux invocations sur des types a priori non relie's.

C'est pourquoi, il est ne'cessaire de demander au programmeur d'annoter le programme pour
guider le typage et exprimer son intention, par exemple concernant le type des me'thodes. Dans ce
chapitre, nous de'finissons le langage utilise' pour e'crire les annotations de type et nous donnons la
syntaxe des expressions annote'es. Nous introduisons ensuite un syste`me de types pour ces expression. Ce syste`me fonctionne en restreignant certaines des re`gles du syste`me alge'brique a` des types
exprimables dans le langage des annotations. Nous nous limitons au cas de la ve'rification de types,
c'est-a`-dire que le programmeur doit donner le type des me'thodes et des de'finitions re'cursives, mais
aussi le type complet des fonctions. La raison de cette limitation est que l'infe'rence de types est strictement plus complexe que la ve'rification et nous ne ferons que l'aborder dans la conclusion de cette
the`se.

Voici comment est organise' ce chapitre : dans la section 5.1, nous de'finissons le langage de types
utilise' pour e'crire les annotations. Celui-ci est un langage du premier ordre standard. Dans la section 5.2, nous en donnons la se'mantique en utilisant un mode`le du langage du premier ordre dans l'alge`bre de types utilise' pour le typage. Dans la section 5.3, nous introduisons et justifions la syntaxe des
expressions annote'es. Nous en donnons une se'mantique par effacement des annotations. Section 5.4,
nous donnons les re`gles de typage des expressions annote'es et nous en montrons la correction par
rapport au typage alge'brique.

78 CHAPITRE 5. ANNOTATIONS ET VE'RIFICATION DE TYPES
5.1 Langage de types

On suppose donne' une fois pour toutes un ensemble infini VarsType de VARIABLES DE TYPE.
On utilisera les lettres o""; r', etc. pour de'signer les variables de types.

Un LANGAGE DE TYPES L est un langage logique du premier ordre, forme' donc d'un ensemble
de symboles de constructeurs de termes et d'un ensemble de symboles de pre'dicats. Les symboles
constructeurs de termes sont aussi appele's CONSTRUCTEURS DE TYPES et sont note's avec les lettres
c, c0, etc. Les symboles de pre'dicat ou PRE'DICATS DE TYPES sont note's avec les lettres p, p0, etc.
L'ensemble de tous les symboles d'un langage sera suppose' de'nombrable ou fini.

Chaque constructeur de types et chaque pre'dicat de types vient avec son arite', note'e |c| et | p|.
L'arite' d'un constructeur de types est le nombre de sous-termes auquel il peut e^tre applique' pour
former un terme. Cette arite' peut e^tre nulle, auquel cas le constructeur est un symbole de constante.
L'arite' d'un pre'dicat de types est le nombre de termes auquel il peut e^tre applique' pour former une
contrainte atomique.

Les termes construits sur l'alphabet des constructeurs de types sont appele's MONOTYPES SYNTAXIQUES. On supposera pre'de'fini le constructeur de types fonctionnels !. L'ensemble des monotypes syntaxiques est donc engendre' par la grammaire suivante :

# ::D o"" Variable de types

| # ! # Type fonctionnel
| ch#; . . . ; #-- -z ""

|c| termes

i Type construit

Une CONTRAINTE est une conjonction finie de contraintes atomiques forme'es avec un symbole
de pre'dicat du langage ou bien le pre'dicat pre'de'fini de sous-typage 6. La contrainte vide est note'evrai

. On se donne e'galement la possibilite' de masquer certaines variables d'une contrainte en utilisant
le connecteur logique 9. L'ensemble des contraintes est donc engendre' par la grammaire suivante :

u* ::D vrai Contrainte vide

| # 6 # Contrainte de sous-typage
| ph#; . . . ; #-- -z ""

|p| termes

i Application d'un pre'dicat du langage

| u* ^ u* Conjonction
| 9V : u* Contrainte existentielle

Dans cette dernie`re production, V de'signe un ensemble fini de variables de type, notation que nous
utiliserons constamment par la suite.

Remarque. Les contraintes de la forme 9V : u* sont tre`s utiles pour ge'rer les variables frai^ches introduites quand on fabrique des contraintes dans un algorithme de typage. Elles peuvent e'galement
se re've'ler inte'ressantes pour le programmeur pour exprimer des contraintes incluant des variables
<< anonymes >>, comme par exemple l'existence d'un super-type commun a` deux types. e^

Enfin, un POLYTYPE SYNTAXIQUE ou SCHE'MA DE TYPE est de la forme suivante :

? ::D 8V : u* . #

5.1. LANGAGE DE TYPES 79
Intuitivement, un sche'ma de type repre'sente un polytype alge'brique contenant toutes les instances de
# quand les variables V prennent des valeurs satisfaisant a` la contrainte u*. En ge'ne'ral, les variables
V apparaissent dans la contrainte u* ou dans le monotype # , mais on peut aussi y trouver d'autres
variables, qui sont alors conside're'es comme libres.

Exemple. Un langage de types possible est de'rive' des de'clarations de classes entre'es par le programmeur. Pour chaque classe C parame'tre'e par n types, on peut supposer qu'il correspond un constructeur de type e'galement note' C et d'arite' n. Par ailleurs, on peut supposer qu'il existe un symbole de
constante (un constructeur d'arite' 0) pour chaque type primitif. Dans ces conditions, voici quelques
exemples de monotypes syntaxiques : Consho""i, o"" ! int, int ! int, etc. de contraintes : o"" 6 rat,Cons

ho""i 6 o"", etc. et de sche'mas de types : 8o"" : vrai . o"" ! o"", 8o"" : o"" 6 rat . Tuple2ho""; o""i ! o"", etc.

On se permettra en ge'ne'ral d'omettre d'e'crire la contrainte d'un sche'ma si elle est e'gale a` vrai,
comme dans 8o"" . o"" ! o"". On identifiera e'galement un sche'ma ou` l'ensemble des variables et la
contrainte sont vides avec son monotype, chaque fois qu'il n'y a pas d'ambigui"te'. Par exemple, on
identifiera le sche'ma 8? : vrai . int et le monotype int.

Un langage de types n'est pas force'ment limite' a` ces constructeurs de types. Par exemple, on peut
imaginer qu'un certain langage de'finisse un ope'rateur t sur les types, de sorte qu'on puisse former le
monotype #1 t #2. On peut e'galement trouver dans un langage des pre'dicats, par exemple un pre'dicat
Imprimable d'arite' 1, avec lequel on puisse former le type 8o"" : Imprimableho""i . o"" ! string.

Notons que, pour l'instant, nous ne de'finissons que la syntaxe des types, pas leur se'mantique.
C'est pourquoi, l'ope'rateur t et le pre'dicat Imprimable n'ont pas de signification particulie`re. e^

Variables de types libres

L'ensemble des variables de type libres d'un monotype # est note' ftv.# /. Cet ensemble est de'fini
comme suit :

ftv.o""/ , {o""}
ftv.#1 ! #2/ , ftv.#1/ [ ftv.#2/
ftv.ch#1; . . . ; #ni/ , ftv.#1/ [ * * * [ ftv.#n/

De me^me, les variables libres d'une contrainte sont :

ftv.vrai/ , ?
ftv.#1 6 #2/ , ftv.#1/ [ ftv.#2/
ftv. ph#1; . . . ; #ni/ , ftv.#1/ [ * * * [ ftv.#n/

ftv.u*1 ^ u*2/ , ftv.u*1/ [ ftv.u*2/

ftv.9V : u*/ , ftv.u*/ \ V

Et celles d'un sche'ma de type :

ftv.8V : u* . # / , .ftv.# / [ ftv.u*// \ V

80 CHAPITRE 5. ANNOTATIONS ET VE'RIFICATION DE TYPES
5.2 Mode`les

Un mode`le d'un langage de types fournit une interpre'tation de chaque e'le'ment du langage dans
une alge`bre de types, domaine d'interpre'tation. Formellement, un mode`le M d'un langage L est la
donne'e des e'le'ments suivants :

- une alge`bre de types domaine d'interpre'tation, note'e JMK ;
- pour chaque symbole de constructeur c d'arite' n, une fonction n-aire totale JcK ope'rant dans

JMK, c'est-a`-dire un e'le'ment de JMKn ! JMK ;
- pour chaque symbole de pre'dicat p d'arite' n, un pre'dicat n-aire JcK ope'rant dans JMK, c'est-a`dire un sous-ensemble de JMKn.
Une fois donne'es les interpre'tations des e'le'ments de base du langage, on peut e'tendre ces interpre'tations a` tous les autres constructions syntaxiques introduites dans la section pre'ce'dente. Comme
celles-ci peuvent contenir des variables de types libres, il faut d'abord en donner la valeur. Pour cela,
on appelle VALUATION une fonction partielle a` domaine finie des variables de types VarsType vers
l'alge`bre A. On utilise les lettres !, !0, ^!, etc.1 pour de'signer les valuations.

L'interpre'tation d'un monotype syntaxique # dans une valuation ^! dont le domaine contient au
moins les variables de type libres de # est un monotype de l'alge`bre JMK note' ^!J# K.2 Cette interpre'tation est de'finie par les e'quations suivantes :

^!Jo""K , ^!.o""/ (on a force'ment o"" 2 dom. ^!/)
^!J#1 ! #2K , ^!J#1K ! ^!J#2K
^!Jch#1; . . . ; #niK , JcK. ^!J#1K; . . . ; ^!J#nK/

L'interpre'tation d'une contrainte est une valeur de ve'rite' de'finie par les e'quivalences suivantes :

^!JvraiK est vrai
^!J#1 6 #2K ssi ^!J#1K 6 ^!J#2K
^!J ph#1; . . . ; #niK ssi . ^!J#1K; . . . ; ^!J#nK/ 2 J pK

^!Ju*1 ^ u*2K ssi ^!Ju*1K et ^!Ju*2K sont vrais

^!J9V : u*K ssi il existe ! tel que dom.!/ D V et ^!l^!Ju*K est vrai

Remarque. Dans cette dernie`re e'quation, notons que dom. ^!/ n'est pas force'ment disjoint de dom.!/,
ce qui signifie que certaines variables de V peuvent masquer celles de'finies par ^!. Nous aurions pu
supposer que les variables de type sont syste'matiquement renomme'es pour e'viter les masquages.
Une telle hypothe`se est une simplification commode, mais risque d'introduire un certain manque de
rigueur. Nous avons donc pre'fe're' traiter comple`tement le proble`me des masquages, sans supposer une
o""-conversion implicite. e^

L'interpre'tation d'un sche'ma de types 8V : u*.# est l'ensemble, e'ventuellement vide, de monotypes
alge'briques que de'crit l'interpre'tation de # quand V varie dans les solutions de u* :

^!J8V : u* . # K , l^ ^!l^!J# K | dom.!/ D V et ^!l^!Ju*Kl/
1La notation ^! forme un tout, le chapeau e'tant utilise' au me^me titre qu'un prime ou un indice.
2La notation utilise'e ici est l'inverse de la notation habituelle J# K ^!. Notre notation est le'ge`rement plus pratique car elle

s'associe bien avec l'ope'rateur de composition s' sur les valuations. La notation ^!J#K doit en fait se lire << ^! applique' a` # >>.

5.3. LE LANGAGE ANNOTE' 81
Notons que pour que l'interpre'tation d'un sche'ma de types soit non-vide, c'est-a`-dire constitue un
polytype valide pour le syste`me de types alge'brique, il faut et il suffit que la contrainte 9V : u* soit
vraie dans la valuation ^!. Dans ce cas, on dit que le sche'ma de type est SATISFIABLE.

Notations

Quand le mode`le M utilise' pour interpre'ter un e'le'ment syntaxique n'est pas implicitement connu,
on utilisera la notation ^!J*KM a` la place de ^!J*K. De me^me, si la valuation ^! est de domaine vide, c'esta`-dire ne de'finit aucune variable de type, on se permettra d'omettre de l'e'crire et on notera simplement

J*K ou bien J*KM si on veut expliciter le mode`le utilise'.

Exemple. Voici un exemple de mode`le. Conside'rons le langage de types de'rive' des de'clarations du
programmeur et tel qu'a` chaque classe C correspond un constructeur de type C.

Un mode`le possible pour ce langage est celui constitue' de tous les termes finis construits avec
l'alphabet des constructeurs et avec la fle^che et ordonne' par la relation de sous-typage structurelle
engendre'e par les variances de'clare'es par le programmeur (alge`bre structurelle simple). L'alge`bre
structurelle simple n'est bien su^r pas le seul mode`le possible pour ce langage : on peut aussi conside'rer
le mode`le des types infinis ou bien le plus petit treillis contenant l'ordre structurel. Dans le mode`le
treillis, l'ope'rateur supple'mentaire t peut e^tre interpre'te' comme l'ope'rateur de borne supe'rieure.

Si le langage contenu le pre'dicat Imprimable, celui-ci peut e^tre interpre'te' par le pre'dicat alge'brique
de'fini comme suit : Imprimablehti est vrai pour tout les types primitifs t. ImprimablehChtii est vrai si
et seulement si C vaut Cons, Nil ou List et t est lui-me^me imprimable.

Nous voyons donc que notre cadre autorise une grande souplesse dans le choix de la syntaxe
des types comme dans celui de son interpre'tation et tous les re'sultats de cette the`se (correction du
typage, re'duction a` des proble`mes de contraintes) en sont inde'pendants, ce qui e'tait l'un des objectifs
recherche's. e^

5.3 Le langage annote'

Dans cette section, nous introduisons un nouveau langage d'expressions. Il de'rive du langage
non-type' pre'sente' au chapitre 1 par le fait qu'il contient des annotations de types explicites sur les
de'finitions re'cursives, les me'thodes et l'argument des fonctions. L'introduction de ce nouveau langage
permet au programmeur de guider le typage des expressions re'cursives polymorphes et d'exprimer son
intention concernant le type des me'thodes, ce qui est ne'cessaire pour aboutir a` un syste`me de types
de'cidables.

5.3.1 Syntaxe des expressions annote'es

Les expressions annote'es sont note'es avec la lettre " et leur grammaire coi"ncide avec celle des expressions non-type'es sauf sur certaines production. Elles sont engendre'es par la grammaire suivante :

82 CHAPITRE 5. ANNOTATIONS ET VE'RIFICATION DE TYPES

" ::D x

| "1 "2
| fun x : # ) "
| let x D "1 in "2
| fix x : ? ) "
| C {`1 D "1I . . . I `n D "n}
| C *`
| a
| f
| meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k}
| 8V : u* . " (Introduction de variables de types)

Les de'finitions re'cursives polymorphes sont annote'es avec un sche'ma de types qui repre'sente le
type polymorphe de l'expression attendu ou devine' par le programmeur. Celui-ci peut e^tre correct ou
non, ce que nous devrons ve'rifier lors du typage.

L'expression 8V : u* . " introduit les variables de types V contraintes par u* et qui peuvent e^tre
utilise'es par les annotations de ". La raison de cette construction est qu'il est souvent ne'cessaire
d'e'crire des annotations qui contiennent des variables libres. Par exemple, la me'thode qui renverse
les e'le'ments d'une liste posse`de naturellement le type 8o"" . Listho""i ! Listho""i, mais l'imple'mentation
efficace habituelle en temps line'aire utilise en interne une fonction a` deux arguments (un accumulateur
et la liste), donc d'un type devant ne'cessairement utiliser o"".

L'expression fun x : # ) " est une fonction dont le programmeur spe'cifie que le type de l'argument est e'gal a` # . Ce monotype peut contenir des variables de types, de sorte qu'on peut e'crire
par exemple l'identite' polymorphe comme : 8o"" : vrai . fun x : o"" ) x. Notons dans cette dernie`re
expression que le corps de la fonction doit accepter un argument x de tout type. L'annotation n'est pas
une simple contrainte pose'e sur le type de l'argument, mais est une spe'cification comple`te du domaine
de la fonction. Par exemple, la fonction 8o"" : vrai . fun x : o"" ) x C 1 sera mal type'e, car son corps
n'accepte pas un argument boole'en, alors qu'on a spe'cifie' que le type bool appartient au domaine de
la fonction. Pour qu'elle soit bien type'e, le programmeur devra raffiner les annotations et e'crire par
exemple 8o"" : o"" 6 rat . fun x : o"" ) x C 1. C'est en ce sens que nous ne parlerons dans ce chapitre
que de la ve'rification de types et pas de l'infe'rence.

L'expression meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k} est une me'thode dont on a spe'cifie' explicitement le type. Par simplification, nous restreignons l'annotation de type a` e^tre syntaxiquement un
type fonctionnel. De me^me, nous nous limitons a` une annotation monomorphe, e'tant donne' qu'on
peut toujours e'crire 8V : u* . meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k} pour donner le type polymorphe
8V : u* . # ! # 0 a` la me'thode.

Variables de type libres

L'ensemble des variables de type libres d'une expression annote'e est de'fini comme suit :

ftv.x/ , ?

5.4. VE'RIFICATION DE TYPES SEMI-ALGE'BRIQUE 83

ftv."1 "2/ , ftv."1/ [ ftv."2/
ftv.fun x : # ) "/ , ftv.# / [ ftv."/
ftv.let x D "1 in "2/ , ftv."1/ [ ftv."2/

ftv.fix x : ? ) "/ , ftv.? / [ ftv."/
ftv.C {`1 D "1I . . . I `n D "n}/ , ftv."1/ [ * * * [ ftv."n/

ftv.C *`/ , ?

ftv.a/ , ?
ftv. f / , ?
ftv.meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k}/ , ftv.# / [ ftv.# 0/ [ ftv."1/ [ * * * [ ftv."k/

ftv.8V : u* . "/ , .ftv."/ [ ftv.u*// \ V

5.3.2 Se'mantique

La se'mantique d'une expression annote'e " est celle de l'expression non annote'e obtenue en effac,ant toutes les annotations dans ". Cette expression non-type'e est note'e L"M. Cette ope'ration rend bien
compte du fait que les annotations de type ne servent que pour le typage mais ne sont pas utilise'es a`
l'exe'cution.

5.4 Ve'rification de types semi-alge'brique

Nous introduisons maintenant un syste`me de types semi-alge'brique pour les expressions annote'es. Le syste`me est essentiellement alge'brique, mais il utilise un mode`le du langage de types pour
interpre'ter les annotations et diriger le syste`me de types alge'brique du chapitre 3.

Dans cette section, nous supposons donne' un mode`le M.
Le jugement de typage s'e'crit ^!I G ` " : T et se lit << en utilisant la valuation ^! pour interpre'ter
les annotations de types de ", et dans l'environnement de typage G, " a pour type T >>. On impose que
le domaine de ^! contienne au moins les variables de types libres de ".

Examinons les re`gles de ce syste`me. La re`gle de typage des expressions re'cursives est similaire
a` (FIX) excepte' que le polytype utilise' doit correspondre a` l'annotation donne'e par le programmeur.
L'interpre'tation de celle ci doit donc e^tre non-vide et on e'crit :

^!J? K 6D ? ^!I G[x : ^!J? K] ` " : ^!J? K

^!I G ` .fix x : ? ) "/ : ^!J? K(FIXA)

La re`gle de typage des fonctions contraint le type de l'argument de la fonction a` e^tre celui spe'cifie' par
le programmeur :

^!I G[x : ^!J# K] ` " : t0
^!I G ` fun x : # ) " : ^!J# K ! t 0(FUNA)

84 CHAPITRE 5. ANNOTATIONS ET VE'RIFICATION DE TYPES
De me^me, celle concernant les me'thodes s'e'crit naturellement :

^!J# ! # 0K FG ij1I . . . I ijk ^!I G ` iji ) "i : ^!J# ! # 0K
^!I G ` meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k} : ^!J# ! # 0K(METHA)

Dans cette re`gle, le typage des cas se fait exactement comme dans le syste`me alge'brique, excepte'
qu'on transmet la valuation ^! pour le typage des corps des cas.

Examinons finalement la re`gle pour le typage de l'introduction de variables. Conside'rons une
expression de la forme 8V : u* . ". On demande tout d'abord que 9V : u* soit satisfiable dans ^!. Dans
le cas contraire, on conside`re que l'annotation est tout simplement mal type'e. Ensuite, on proce`de
au typage de l'expression ", ce qui produit un polytype T!, force'ment non-vide. On donne alors a`
l'expression annote'e toute entie`re le type union de tous les T!, ce qui est une forme particulie`re de
ge'ne'ralisation :

^!J9V : u*K 8!; a,dom.!/ D V ^ ^!l^!Ju*Kc' ) ^! l^ !I G ` " : T!

^!I G ` 8V : u* . " : [

dom.!/DV

^!l^!Ju*K

T!(INTROA)

Remarque. Dans cette re`gle, il peut tre`s bien y avoir un ensemble infini de solutions ! et donc un
infinite' de polytypes TV al dont il faut prendre l'union. Cette infinite' de pre'misses ne pose pas plus de
proble`me que pour la re`gle alge'brique (GEN). e^

Les autres re`gles sont formellement identiques a` celles du syste`me alge'brique. Pour une pre'sentation comple`te de toutes les re`gles, voir en section 5.6, page 84.

5.5 Su^rete' du syste`me de ve'rification semi-alge'brique

THE'ORE`ME 2 (SU^RETE' DU TYPAGE SEMI-ALGE'BRIQUE). Si ^!I G ` " : T , alors G ` L"M : T .
De'monstration. Chacune des nouvelles re`gles de typage semi-alge'brique est une spe'cialisation des
re`gles de typage alge'briques, excepte' (INTROA) qui est une instance de (GEN) pre'ce'de'e de (INST). e^

5.6 Re'capitulatif

Voici la liste comple`te des re`gles du syste`me de ve'rification de types semi-alge'brique ope'rant sur
les expressions annote'es :

^!J? K 6D ? ^!I G[x : ^!J? K] ` " : ^!J? K

^!I G ` fix x : ? ) " : ^!J? K(FIX A)

^!I G[x : ^!J# K] ` " : t0
^!I G ` fun x : # ) " : ^!J# K ! t 0(FUN A)

5.6. RE'CAPITULATIF 85

^!J# ! # 0K FG ij1I . . . I ijk ^!I G ` iji ) "i : ^!J# ! # 0K
^!I G ` meth : # ! # 0 {ij1 ) "1I . . . I ijk ) "k} : ^!J# ! # 0K(METHA)

^!J9V : u*K 8!; a,dom.!/ D V ^ ^!l^!Ju*Kc' ) ^! l^ !I G ` " : T!

^!I G ` 8V : u* . " : [

dom.!/DV

^!l^!Ju*K

T!(INTROA)

^!I G ` x : G.x/(VAR A)
^!I G ` "1 : t2 ! t ^!I G ` "2 : t2

^!I G ` e1 e2 : t(APPA)
t 2 #C ^!I G ` "1 : C *`1.t/ . . . ^!I G ` "n : C *`n.t/

^!I G ` C {`1 D "1I . . . I `n D "n} : t(OBJETA)

t0 D C *`.t/
^!I G ` C *` : t ! t0(GETA)

^!I G ` a : a(CONSTANTEA)
8a1 2 t 01 ; . . . ; an 2 t0n ; f .a1; . . . ; an/ 2 t0 8i; Tuplen *i .t / D t0i

^!I G ` f : t ! t0(PRIMITIVE A)
^!I G ` " : T t 2 T

^!I G ` " : t(INST)
T 6D ? pour tout t 2 T , ^!I G ` " : t

^!I G ` " : T(GENA)
^!I G ` " : t t 6 t0

^!I G ` " : t0(SUB A)
^!I G ` "1 : T1 ^!I G[x : T1] ` "2 : T2

^!I G ` let x D "1 in "2 : T2(LETA)
8t00G0.t ` ij : t00I G0/ ) ^!I G l^ G0 ` " : t0

^!I G ` ij ) " : t ! t0(CASA)

86 CHAPITRE 5. ANNOTATIONS ET VE'RIFICATION DE TYPES87
Chapitre 6
De la ve'rification de types aux contraintes

Re'capitulons notre parcours jusqu'a` pre'sent. Nous avons introduit un langage et sa se'mantique non
type'e (chapitres 1 et 2). Puis, nous avons donne' un syste`me de types travaillant sur des monotypes
pris dans une alge`bre et ve'rifiant un petit nombre d'axiomes (chapitre 3). Nous avons ensuite montre'
la correction de ce syste`me de types vis-a`-vis de la se'mantique ope'rationnelle a` l'aide d'une preuve
ge'ne'rique (chapitre 4). Ce syste`me de types n'est pas directement utilisable en pratique, ne serait-ce
que parce que certaines constructions du langage, comme la re'cursion polymorphe, ne peuvent e^tre
de'cidablement type'es. En revanche, sa preuve de correction ge'ne'rique en fait un outil pour montrer la
correction d'autres syste`mes plus pratiques. Au chapitre 5, nous avons introduit un nouveau langage
dont les expressions sont munies d'annotations de types exprime'es dans un langage de types et dont
la se'mantique ope'rationnelle est obtenue par effacement des annotations. Nous en avons e'galement
donne' un syste`me de types dont nous avons prouve' la correction par re'e'criture dans le syste`me alge'brique. Ce syste`me, que nous avons appele' semi-alge'brique, est un syste`me de ve'rification de types
car le programmeur doit spe'cifier comple`tement le type des arguments des fonctions. Il se rapproche
du syste`me alge'brique car il n'est pas dirige' par la syntaxe, le polymorphisme y est extensionnel et
les de'rivations peuvent e^tre infinies. A` partir de maintenant, nous allons conside'rer le syste`me semialge'brique comme la spe'cification d'un jugement de typage et nous allons e'tudier comment en donner
une imple'mentation.

Dans ce chapitre, nous re'alisons une partie du chemin dans cette voie. Le proble`me que nous
traitons est de la forme << l'expression " est-elle bien type'e ou non ? >>. Nous montrons qu'on peut
le re'duire a` une se'rie de proble`mes plus simples, exprime's uniquement dans le langage de types et
interpre'te's dans le mode`le. Ces proble`mes e'le'mentaires ne font plus du tout re'fe'rence au langage,
mais sont des proble`mes uniquement alge'briques. Moyennant quelques hypothe`ses de repre'sentabilite' des e'le'ments de base du langage, cette re'duction peut avoir lieu inde'pendamment du mode`le et
de l'alge`bre, c'est-a`-dire de fac,on purement syntaxique. En d'autre termes, nous allons donner un algorithme qui parcourt l'expression a` traiter et qui accumule des proble`mes exprime's dans le langage
de types (contraintes, implications de contraintes, tests de couverture), sans chercher a` les re'soudre
et donc inde'pendamment du mode`le. Ensuite, nous allons prouver que cet algorithme ge'ne`re bien un
ensemble de proble`mes dont l'interpre'tation est e'quivalente au proble`me initial de typage.

Le fait d'e^tre inde'pendant du mode`le est particulie`rement important pour traiter un monde qui
peut e^tre e'tendu (monde ouvert). Ce the`me sera de'veloppe' au prochain chapitre.

Le reste du chapitre est organise' comme suit : dans la section 6.1, nous de'crivons les hypothe`ses

88 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
de repre'sentabilite' ne'cessaires ; dans la section 6.2, nous introduisons les proble`mes de typage alge'briques e'le'mentaires ; en section 6.3, nous donnons l'e'nonce' du the'ore`me et le reste du chapitre est
consacre' a` la preuve.

6.1 Repre'sentation et mode`le d'une repre'sentation

Un mode`le permet de manipuler des monotypes et des polytypes alge'briques en utilisant la syntaxe
d'un langage de types. En ge'ne'ral, le langage ne permet pas de les repre'senter tous. En particulier,
un polytype alge'brique est un ensemble quelconque de monotypes de'fini en extension, alors qu'un
sche'ma de types de'crit un ensemble de fac,on intensionnelle a` l'aide d'une contrainte syntaxique. Un
simple argument de cardinalite' montre que, sauf cas trivial, de nombreux polytypes alge'briques ne
sont pas repre'sentables par un sche'ma de types, car l'ensemble des sche'mas de types est toujours
de'nombrable alors que celui des polytypes alge'briques est au moins continu de`s que l'alge`bre est
infinie.

Pour pouvoir re'duire le typage a` des proble`mes exprime's dans le langage de types, il est donc
ne'cessaire de pouvoir y exprimer le type des e'le'ments de base du langage d'expressions. De plus, pour
que la re'duction soit inde'pendante du mode`le, il est ne'cessaire que la repre'sentation des e'le'ments de
base en soit aussi inde'pendante.

Supposons donne's une structure primitive C0 et une structure de classes C, c'est-a`-dire tout ce
qu'il faut pour e'crire des programmes non-type's e : noms de classe et de champs et valeurs et ope'rations primitives. Fixons e'galement un langage de types L ; nous avons maintenant de quoi e'crire
une expression annote'e ". Pour typer " de manie`re purement syntaxique, il nous manque encore une
repre'sentation syntaxique du type des e'le'ments de base du langage.

On appelle REPRE'SENTATION des structures C0 et C dans le langage de types L la donne'e des
e'le'ments suivants :

- pour chaque constante a, un monotype syntaxique ea ;
- pour chaque primitive f , un sche'ma de types ef ;
- pour chaque motif primitif $ , un monotype syntaxique e$
- pour chaque classe C, un sche'ma de types f#C ;
- enfin, pour chaque classe C et chaque champ ` de C, un sche'ma de types gC *`.
Notons que la notion de repre'sentation est purement syntaxique. Elle e'tablit simplement un lien
syntaxique entre structures de base du langage d'expression et du langage de types.

Conside'rons maintenant un mode`le M du langage L. On dit que M est un MODE`LE DE LA REPRE'SENTATION si l'interpre'tation des repre'sentations syntaxiques est compatible avec les e'le'ments
alge'briques correspondants dans l'alge`bre sous-jacente au mode`le. Nous allons maintenant de'finir
plus formellement cette notion.

6.1.1 Type des constantes

Pour toute constante a, l'interpre'tation du type syntaxique ea de la repre'sentation doit e^tre e'gal au
type alge'brique associe' a` la constante, ce que l'on a note' a :1

1Petits rappel de notation pour de'coder cette e'galite' : JeaKM de'signe l'interpre'tation du symbole ea dans le mode`le M.
C'est donc un e'le'ment de l'alge`bre JMK support du mode`le. Par ailleurs, la notation aJMK de'signe l'abstraction de la

6.1. REPRE'SENTATION ET MODE`LE D'UNE REPRE'SENTATION 89

8M 2 Mode`les; JeaKM D aJMK(HYP-ea)
Exemple. Le plus simple pour repre'senter le type des constantes est qu'a` chaque type primitif corresponde dans le langage de types une constante de type, c'est-a`-dire un constructeur d'arite' 0. On
pourra ainsi supposer que le langage de types de'finit les constantes int, rat, bool, etc. e^

6.1.2 Type des primitives

Conside'rons une ope'ration primitive f . Pour exprimer la condition de compatibilite' concernant le
type syntaxique ef , nous notons f l'ensemble des types possibles que la re`gle alge'brique (PRIM) peut
donner a` la primitive f . Si celle-ci est d'arite' n, on a donc :

t ! t0 2 f ssi 9t01 ; . . . ; t0N 2 A0; ( 8i; Tuplen *i .t / D t

0i

8a1 2 t01 ; . . . ; an 2 t0n ; f .a1; . . . ; an/ 2 t0(6.1)

Muni de cette de'finition, nous pouvons formuler la condition que le polytype d'une primitive f
est repre'sentable par un sche'ma de types, note' ef . L'interpre'tation de ce sche'ma de types doit e^tre
e'quivalente au polytype f elle doit e^tre non-vide, c'est-a`-dire que la primitive doit e^tre bien type'e
dans le mode`le conside're' :

8M 2 Mode`les; x??J ef KM D x?? f J

MK 6D ?(HYP- ef )

Notons qu'on fait porter l'e'galite' sur la clo^ture supe'rieure des polytypes alge'briques pluto^t que sur
les polytypes eux-me^mes. Comme deux polytypes e'quivalents par cette relation sont interchangeables
par la re`gle (SUB]), la puissance de l'hypothe`se est donc identique, mais cela donne un peu plus de
liberte' pour choisir le sche'ma ef .

Exemple. Le sche'ma de types de l'addition sera par exemple 8o"" : o"" 6 rat . ho""; o""i ! o"". Celui de la
comparaison peut e^tre indiffe'remment 8o"" : o"" 6 rat . ho""; o""i ! bool ou 8? . hrat; rati ! bool qui
sont e'quivalents. e^

6.1.3 Type des motifs primitifs

Pour chaque motif primitif $ , de'finissons donc l'ensemble des types des constantes accepte'es par
$ de la fac,on suivante :

$ A , naA | a 2 $ o(6.2)

Pour que M soit un mode`le de la repre'sentation, on exige alors l'e'galite' suivante :
constante a dans l'alge`bre JMK.

90 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES

8M 2 Mode`les; J e$ KM D $ JMK(HYP- e$ )
Exemple. Si $ est le motif primitif rat, e$ peut e^tre choisi e'gal a` 8o"" : o"" 6 rat.o"". L'interpre'tation de
ce sche'ma correspond en effet au type de toutes les constantes accepte'es par $ , c'est-a`-dire {rat; int}.

e^

6.1.4 Type des classes et des champs

Pour que M soit un mode`le de la repre'sentation, nous exigeons la proprie'te' suivante :

8M 2 Mode`les; Jf#CKM D #CJ

MK 6D ?(HYP- f#C)

Notons l'emploi de l'e'galite' ici : le type d'une classe est en effet utilise' a` la fois dans des contextes
covariants (construction d'un objet) et contravariants (filtrage).

Finalement, l'interpre'tation de gC *` doit repre'senter tous les types possibles de l'accesseur C *`
obtenus par la re`gle de typage alge'brique (GET). On demande donc :

8M 2 Mode`les; J gC *`KM D nt !JMK t 0 | t0 D C *`J

MK.t/o(HYP- gC *`)

Notons que l'hypothe`se #C 6D ? implique que J gC *`K est e'galement non-vide, car #C est suppose'
e^tre le domaine de C *`.

Exemple. Quand l'alge`bre est une alge`bre de termes engendre's a` partir des de'clarations de classes
du programmeur, les sche'mas f#C et gC *` peuvent e^tre extraits automatiquement des de'clarations. Par
exemple :

class Consho""l^i {

head : o""I
tail : Listho""iI
}

e^ 8???!???:

^#Cons D 8o"" . Consho""i
^Cons*head D 8o"" . Consho""i ! o""

^Cons*tail D 8o"" . Consho""i ! Listho""i

e^

6.2 Proble`mes de typage e'le'mentaires

Nous allons conside'rer deux types de proble`mes que nous appelerons PROBLE`MES DE TYPAGE
E'LE'MENTAIRES. Il s'agit des proble`mes d'implications de contraintes et des proble`mes de test de
couverture.

Nous supposons fixe' un langage de types L.

6.3. E'NONCE' DU THE'ORE`ME 91
6.2.1 Implication de contraintes

Soit u*1 et u*2 deux contraintes dont toutes les variables libres sont contenues dans l'ensemble V.
On dit que u*1 IMPLIQUE u*2 dans un certain mode`le M si et seulement si, pour toute valuation ! de
domaine V, le fait que !Ju*1K soit vrai implique !Ju*2K. On note alors M |H 8V . u*1 ? u*2 ou simplement
8V . u*1 ? u*2 si le mode`le est implicitement connu. On a donc formellement :

M |H 8V . u*1 ? u*2 ssi 8! 2 a,V ! JMKc' ; !Ju*1KM ) !Ju*2KM(6.3)
Notons que rien ne force la contrainte 9V : u*1 a` e^tre satisfiable. Si elle ne l'est pas, alors l'implication 8V . u*1 ? u*2 est vraie inde'pendamment de u*2.

6.2.2 Test de couverture

Soit ij1; . . . ; ijk une liste de motifs et ? un sche'ma de type clos (sans variable libre). On dit que
? est COUVERT par la liste de motifs si et seulement si tout monotype alge'brique e'le'ment de J? K
est couvert au sens alge'brique par les motifs. On note alors M |H ? FG ij1I . . . I ijk ou simplement
? FG ij1I . . . I ijk si le mode`le est implicitement connu. Formellement, on a donc :

M |H ? FG ij1I . . . I ijk ssi 8t 2 J? KM; t FGJMK ij1I . . . I ijk(6.4)

Remarque. On force donc tous les e'le'ments de ? a` e^tre des types fonctionnels car la de'finition de
t FGJMK . . . impose que t soit un type fonctionnel. e^

6.3 E'nonce' du the'ore`me

THE'ORE`ME 3. Soient C0 une structure primitive, C une structure de classe, et L un langage de types.
On fixe une repre'sentation des structures C0 et C dans le langage L.

Pour toute expression annote'e " e'crite dans la syntaxe de'finie par C0, C et L, on peut calculer
une liste de proble`mes de typage e'le'mentaires (implications de contrainte et tests de couverture)

P1; . . . ; PN et un sche'ma de types ? tels que, pour tout M mode`le de la repre'sentation conside're'e,
on ait les proprie'te's suivantes :

- si pour tout i , M |H Pi , alors M |H ?I ? ` " : J? KM ;
- s'il existe T tel que M |H ?I ? ` " : T , alors, J? KM 6] T et pour tout i , M |H Pi .

Le reste de ce chapitre est consacre' a` la de'monstration de ce the'ore`me.

92 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
Plan de la preuve

Le principe de la preuve consiste a` introduire un nouveau syste`me de types, dirige' par la syntaxe
et ope'rant sur des types syntaxiques. Les re`gles de ce syste`me utilisent les proble`mes de typage pour
assurer que l'interpre'tation des types qu'elles manipulent ve'rifient certaines proprie'te's alge'briques.
On ve'rifie ensuite que ces proprie'te's assurent la su^rete' du typage en interpre'tant chaque re`gle dans
le syste`me semi-alge'brique (lemme de correction). Inversement, on montre que les proble`mes de
typage engendre's par les re`gles syntaxiques sont juste suffisants pour assurer cette su^rete' (lemme de
comple'tude). On en conclut que le typage d'une expression annote'e par le syste`me alge'brique est
e'quivalent a` la re'solution des proble`mes de typage engendre's par le syste`me syntaxique. On ve'rifie
enfin qu'on peut bien engendrer ces proble`mes me'caniquement et inde'pendamment du mode`le choisi
pour les interpre'ter.

Voici comme est organise'e la suite du chapitre : dans la section 6.4, on introduit des abre'viations
et de'finitions commodes pour exprimer le syste`me de types syntaxique. Les re`gles du syste`me sont
introduites a` la section 6.5. On en montre la correction a` la section 6.6 puis la comple'tude en 6.7. La
comple'tude ayant e'te' obtenue pour une forme simplifie'e des expressions (sans masquage de variables
de type), on montre en section 6.8 comment lever cette hypothe`se en renommant convenablement les
variables de type. Enfin, on conclut en section 6.9.

6.4 Quelques de'finitions

Cette section regroupe les diffe'rentes de'finitions utiles pour e'crire le syste`me de types syntaxique
de la section suivante.

6.4.1 Relations de sous-typage ge'ne'ralise'es

Rappelons la de'finition de 6], relation qui ope`re sur les ensembles quelconques de monotypes :

T 6] U ssi 8u 2 U; 9t 2 T; t 6 u
On de'finit de me^me la relation 6[ comme suit :

T 6[ U ssi 8t 2 T; 9u 2 U; t 6 u
Ces deux relations sont transitives et re'flexives et e'tendent 6 si on identifie un monotype t au singleton
{t} : les propositions {t} 6] {u}, {t} 6[ {u} et t 6 u sont e'quivalentes. Les relations d'e'quivalence
associe'es aux pre'ordres 6] et 6[ sont note'es respectivement ij] et ij[ :

T ij] U ssi T 6] U et U 6] T

T ij[ U ssi T 6[ U et U 6[ T

Il est commode de de'finir aussi la relation de compatibilite' 69 :

T 69 U ssi 9t 2 T; 9u 2 U; t 6 u

6.4. QUELQUES DE'FINITIONS 93
Attention : 69 n'est pas transitive. Mais, on a la proprie'te' de transitivite' avec 6] a` gauche et 6[ a`
droite :

T 0 6] T ^ T 69 U ^ U 6[ U 0 ) T 0 69 U 0

6.4.2 Abre'viations de contraintes

Soient ?1 D 8V1 : u*1 . #1 et ?2 D 8V2 : u*2 . #2 deux sche'mas de types (V1 et V2 ne sont pas
force'ment disjoints). La contrainte ?1 69 ?2 est de'finie comme l'abre'viation suivante ou` on choisit
o"" 62 ftv.?1/ [ V1 [ ftv.?2/ [ V2 :

?1 69 ?2 t^ 9o"" : .9V1 : u*1 ^ #1 6 o""/ ^ .9V2 : u*2 ^ o"" 6 #2/(6.5)
L'e'quivalence suivante est re'alise'e dans tous les mode`les du langage et pour toute valuation ^! de'finie
sur au moins les variables libres de ?1 et ?2 :

^!J?1 69 ?2K () ^!J?1K 69 ^!J?2K(6.6)
De'monstration. Supposons que ^!J?1 69 ?2K soit vrai. Il existe donc ! de domaine {o""}, !1 de domaine
V1 et !2 de domaine V2 telles que ^!l^!l^!1Ju*1 ^ #1 6 o""K et ^!l^!l^!2Ju*2 ^ o"" 6 #2K. Posons t D !.o""/ et
t1 D ^!l^!l^!1J#1K. Observons que ^! l^ ! l^ !1 coi"ncide avec ^! l^ !1 sur les variables libres de u*1 et #1
car celles-ci sont ou bien dans V1, domaine de !1, ou bien dans les variables libres de ?1, c'est-a`-dire
diffe'rentes de o"", domaine de !. Par ailleurs, remarquons que ^! l^ ! l^ !1.o""/ D t car o"" n'est pas dans
V1, domaine de !1. On a donc ^!l^!1Ju*1K, ^!l^!1J#1K D t1 et t1 6 t . Le monotype t1 est donc un e'le'ment
de ^!J?1K. On montre de fac,on syme'trique qu'il existe t2 2 ^!J?2K tel que t 6 t2.

Inversement, si ^!J?1K 69 ^!J?2K, il existe ti 2 ^!J?i K tels que t1 6 t2. Il existe donc !i tel que
^!l^!i Ju*i K et ti D ^!l^!i J#i K. En posant ! D [o"" 7! t1], il est clairement possible de remonter leraisonnement ci-dessus pour conclure

^!l^!l^!1Ju*1 ^ #1 6 o""K et ^!l^!l^!2Ju*2 ^ o"" 6 #2K, c'est-a`-dire
^!J?1 69 ?2K. e^

Si #1 est un monotype et ?2 D 8V2 : u*2 . #2 un sche'ma de type. La contrainte #1 2 ?2 est de'finie
comme l'abre'viation suivante ou` o"" 62 ftv.#1/ [ ftv.?2/ [ V2 :

#1 2 ?2 t^ 9o"" : #1 6 o"" ^ o"" 6 #1 ^ .9V2 : u*2 ^ #2 6 o"" ^ o"" 6 #2/(6.7)
Par un raisonnement similaire a` celui de'veloppe' ci-dessus et en tenant compte du fait que o"" est choisie
<< frai^che >>, on a la caracte'risation suivante :

^!J#1 2 ?2K () ^!J#1K 2 ^!J?2K(6.8)

6.4.3 Contextes

On appelle CONTEXTE la donne'e d'un ensemble de variables de type et d'une contrainte :

1 ::D {V : u*}

94 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
L'ensemble des variables libres d'un contexte {V : u*} est e'gal a` ftv.u*/ \ V. L'interpre'tation d'un
contexte dans un mode`le M et une valuation ^! de'finissant au moins les variables libres du contexte
est l'ensemble des valuations ! de domaine V qui satisfont la contrainte u* :

^!J{V : u*}K

M , l^! 2 a,V ! JMKc' | ^!l^!Ju*Kl/(6.9)

Le DOMAINE d'un contexte 1 D {V : u*} est l'ensemble de variables V et est note' dom.1/.

Si 11 est un contexte clos et 12 un contexte dont toutes les variables libres sont dans le domaine
de 11, alors le PRODUIT du contexte 11 par le contexte 12 est de'fini comme l'abre'viation suivante :

{V1 : u*1} ng {V2 : u*2} t^ {V1; V2 : .9.V1 " V2/ : u*1/ ^ u*2} 0B@

conditions :

ftv.u*1/ t, V1
ftv.u*2/ t, V1 [ V2

1CA
(6.10)

Le produit de contextes est caracte'rise' par la proprie'te' suivante :

J11 ng 12K D l^!1 l^ !2 | !1 2 J11K ^ !2 2 !1J12Kl/(6.11)

De'monstration. Posons 11 D {V1 : u*1}, 12 D {V2 : u*2} et V0 D V1 " V2.
s^ .t,/ : soit ! 2 J11 ng 12K. On a !Ju*2K et !J9V0 : u*1K. Il existe donc !0 de domaine V0 tel que !l^!0Ju*1K
est vrai. Posons alors !1 D .! l^ !0/ z' V1 et !2 D ! z' V2. On a bien ! D !1 l^ !2 car !0 porte sur des
variables masque'es par !2. Comme ! l^ !0 coi"ncide avec !1 sur V1, ensemble qui contient toutes les
variables libres de u*1, 11 e'tant clos, !l^!1Ju*1K e'quivaut a` !1Ju*1K. On a donc bien !1 2 J11K.

s^ .u""/ : soit !1 2 J11K et !2 2 !1J12K. Posons ! D !1 l^ !2. On sait de'ja` que !Ju*2K. On montre
!J9V0 : u*1K en ve'rifiant que ! et !1 coi"ncident sur les variables libres de 9V0 : u*1. En effet, si o"" 2ftv

.9V0 : u*1/, alors o"" 2 V1 et o"" 62 V0. e^

On note 1 ng u* le produit 1 ng {? : u*}. Le produit n'est donc de'fini que si ftv.1/ D ? et ftv.u*/ t,
dom.1/.

6.4.4 Proble`mes sous contexte
Satisfiabilite'

Soit ^1 D { ^V : ^u*} un contexte clos. Soit u* une contrainte dont toutes les variables libres sont dans
^V. Le proble`me de la satisfiabilite' de u* dans le contexte ^1 est le proble`me d'implication e'le'mentaire

de'fini par l'abre'viation suivante :

^1 ` u* t^ 8 ^V . ^u* ? u*(6.12)

Le proble`me de satisfiabilite' sous contrainte est caracte'rise' par la proprie'te' suivante :

M |H ^1 ` u* () 8 ^! 2 J ^1KM; ^!Ju*KM(6.13)

6.5. SYSTE`ME DE TYPES SYNTAXIQUE 95
Implication de contraintes

Soit ^1 D { ^V : ^u*} un contexte clos. Soit V un ensemble de variables de type et u*1 et u*2 deux
contraintes dont les variables libres sont toutes dans ^V [ V. Un proble`me d'implication de contraintes
sous contexte est de'fini comme l'abre'viation suivante :

^1 ` 8V . u*1 ? u*2 t^ ^1 ng {V : u*1} ` u*2(6.14)

L'implication de contraintes sous contexte est caracte'rise'e par la proprie'te' suivante :

M |H ^1 ` 8V . u*1 ? u*2 () 8 ^! 2 J ^1KJMK; 8! 2 a,V ! JMKc' ; ^!l^!Ju*1KM ) ^!l^!Ju*2KM(6.15)

Sous-typage

Soit ^1 D { ^V : ^u*} un contexte clos. Soient ?1 et ?2 deux sche'mas de types dont toutes les variables
libres sont dans ^V. Le proble`me de sous-typage de sche'mas est de'fini par l'abre'viation suivante :

^1 ` ?1 6] ?2 t^ ^1 ` 8o"" . ?2 69 o"" ? ?1 69 o"" (on choisit o"" 62 ^V)(6.16)

Le sous-typage sous contexte est caracte'rise' par la proprie'te' suivante :

M |H ^1 ` ?1 6] ?2 () 8 ^! 2 J ^1KM; ^!J?1KM 6] ^!J?2KM(6.17)

6.5 Syste`me de types syntaxique

On de'finit le jugement ^1I 0 ` " : ? et les jugements auxiliaires ^1I 0 ` ij ) " : # ! # 0 et
` ij : # I ^1I 0. Le jugement ^1I 0 ` ": ? n'est valable que si ftv."/ t, dom. ^1/.

dom. ^1/ kD V kD o"" ^1 ` 9V : u* ^1 ng {V : u*}I 0 ` ": ?

^1I 0 ` .8V : u* . "/: 8V; o"" : u* ^ ? 69 o"" . o""(INTROV )

^1I 0 ` x: 0.x/(VARV )

^1I 0 ` a: ea(CSTV )
^1I 0 ` f : ef(PRIMV )

96 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES

^1I 0 ` "1: ?1 ^1I 0 ` "2: ?2
? D 8o""r' : ?1 69 o"" ! r' ^ ?2 69 o"" . r' o"" kD r' kD dom. ^1/

^1 ` ?

^1I 0 ` "1 "2: ?(APPV )

^1I 0[x : # ] ` ": ? o"" kD dom. ^1/
^1I 0 ` fun x : # ) ": 8o"" : ? 69 o"" . # ! o""(FUNV )

^1I 0 ` C *`: gC *`(ACCE`SV )
^1I 0 ` "1: ?1 . . . ^1I 0 ` "n: ?n
? D 8o"" : o"" 2 f#C ^ VniD1 9r' : .?i 69 r' ^ o"" ! r' 69 gC *`/ . o"" o"" kD r' kD dom. ^1/

^1 ` ?

^1I 0 ` C {`1 D "1I . . . I `n D "n}: ?(OBJETV )

^1I 0 ` "1: ?1 ^1I 0[x : ?1] ` "2: ?2

^1I 0 ` let x D "1 in "2: ?2(LETV )

^1 ` ? ^1I 0[x : ? ] ` ": ? 0 ^1 ` ? 0 6] ?

^1I 0 ` .fix x : ? ) "/: ?(FIXV )

^1 ` # ! # 0 FG ij1I . . . I ijk
pour tout j , ^1I 0 ` ij j ) " j: # ! # 0
^1I 0 ` a,meth : # ! # 0 l^ij j ) " j I . . . I ij j ) " j l/c': # ! # 0(METHV )

dom. ^1/ kD dom.1 j / ` ij j : # j I 1 j I 0 j

^1 ng 1 j ng # j 6 # I 0 l^ 0 j ` " j: ? j

^1 ng 1 j ng # j 6 # ` ? j 6] # 0

^1I 0 ` ij j ) " j: # ! # 0(CASV )

` _ : o""I {o"" : vrai}I [](
ij -UNIVERSELV )

` $ : o""I {o"" : o"" 2 e$ }I [](
ij -PRIMV )

6.6. CORRECTION 97

` ij : # I 1I 0
` ij as x : # I 1I 0[x : # ](
ij -LIEURV )

dom.11/ kD . . . dom.1n/ kD o""
` ij1 : #1I 11I 01 . . . ` ijn : #nI 1nI 0n

` #C {`1 D ij1I . . . I `n D ijn} : o""I 11 ng * * * ^ 1n ng {o"" : o"" 2 f#C ^ VniD1 o"" ! #i 69 gC *`i }I 01 l^ * * * l^ 0n

(ij -CLASSEV )

` #C {`1 D ij1I . . . I `n D ijn} : # I 1I 0 o""kD 2 dom.1/

` C {`1 D ij1I . . . I `n D ijn} : o""I 1 ng {o"" : o"" 6 # }I 0(
ij -SOUS-CLASSEV )

6.6 Correction

Pour tous environnements de typage alge'briques G et G0, on e'crit G 6] G0 si dom.G/ D dom.G0/
et G.x/ 6] G0.x/ pour tout x 2 dom.G/.

Pour tout environnement de typage syntaxique 0, on e'crit ^1 ` 0 quand ^1 ` 0.x/ pour tout
x 2 dom.0/. Pour tout ^! 2 J ^1K, on note alors ^!J0K l'environnement de typage alge'brique de me^me
domaine que 0 qui envoie la variable x sur le polytype alge'brique ^!J0.x /K. Ce dernier ensemble est
bien non-vide quand ^1 ` 0 est vrai.

LEMME 6.1. Si ^!I G ` " : T et si G0 6] G, alors ^!I G0 ` " : T

De'monstration. Il suffit d'inse'rer une instance de la re`gle (SUBA) apre`s chaque occurrence de (VAR A)
dans la de'rivation de ^!I G ` " : T . e^

LEMME 6.2. Si ` ij : # I 1I 0 (1) et si t ` ij : t0I G (2), alors il existe ! 2 J1K tel que G 6] !J0K (3)
et t0 6 !J# K 6 t (4).

De'monstration. Par induction sur la de'rivation de (2). On conside`re la dernie`re re`gle R applique'e.
s^ Si R D (ij -UNIVERSEL), ij est le motif universel _. 1 est alors un contexte de la forme {o"" : vrai},
0 est l'environnement vide et # vaut o"". Du co^te' alge'brique, G est l'environnement vide, t est un
monotype quelconque et t0 D t . Il suffit donc de prendre ! D [o"" 7! t]. Cette valuation est bien dans
l'interpre'tation de 1 et on a t D !J# K.

s^ Si R D (ij -PRIM), ij est un motif primitif $ , alors le contexte 1 est de la forme {o"" : o"" 2 e$ },
l'environnement 0 est vide et # est e'gal a` o"". Par ailleurs G est vide et t est un monotype de la forme
a pour une certaine constante a 2 $ et t0 D t. On sait donc que t 2 $ et par l'hypothe`se (HYP- e$ )
que t 2 J e$ K. En prenant ! D [o"" 7! t], on voit que !Jo"" 2 e$ K donc que ! 2 J1K.

s^ Si R D (ij -SUB), on a alors t00 ` ij : t0I G (5) pour un certain t00 6 t . On peut appliquer l'hypothe`se
d'induction a` (5) pour de'duire qu'il existe ! 2 J1K telle que G 6] !J0K et t0 6 !J# K 6 t 00. On conclut
par transitivite' de 6.

s^ Si R D (ij -LIEUR), ij est alors de la forme ij 0 as x. On a G D G0[x : t0] et t ` ij 0 : t0I G0 (6).
Du co^te' syntaxique, on a ` ij 0 : # I 10I 00 et 0 D 00[x : # ]. On peut appliquer l'hypothe`se d'induction

98 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
a` (6) pour de'duire qu'il existe ! 2 J1K telle que G0 6] !J00K et t0 6 !J# K 6 t00. On conclut par la
transitivite' de 6 que t 0 6 !J# K 6 t. D'autre part, on a t0 6 !J# K donc G 6] !J0K.

s^ Si R D (ij -CLASSE), ij est alors de la forme #C {`1 D ij1I . . . I `n D ijn} et on a t D t0 2 #C,
C *`i .t/ ` iji : t0i I Gi (7) et G D G1 l^ * * * l^ Gn. Du co^te' syntaxique, on a pour chaque i , `
iji : #i I 1i I 0i (8) avec dom.11/ kD . . . dom.1n/ kD o"" et 1 D 11 ng * * * ng 1n ng {o"" : u*} avec u* D o"" 2f
#C ^ VniD1 o"" ! #i 69 gC *`i . Appliquons l'hypothe`se d'induction sur les jugements (7) et (8) pour
chaque i entre 1 et n. Il existe donc !i 2 J1i K telle que Gi 6] !i J0i K (9) et t0i 6 !i J#i K 6 C *`i .t/ (10).
Posons ! D !1 l^ * * * l^ !n l^ [o"" 7! t]. Comme les contextes 1i sont suppose's porter sur des ensembles
de variables de type disjoints, et que o"" est encore une variable diffe'rente, ! coi"ncide avec chacune
des !i et avec [o"" 7! t] sur leur domaine respectif. Les e'quations (9) et (10) restent donc valables
quand on remplace !i par !. On a donc : Gi 6] !J0K et donc G 6] !J0K. Montrons maintenant que
! est dans l'interpre'tation de 1. On a bien t 2 #C, donc, par l'hypothe`se (HYP- f#C) !Jo"" 2 f#CK est
vrai. Pour chaque i , on sait, par la variance de la fle`che applique'e a` (10) que !J#i K 6 C *`i .t/ et donc
t ! !i J#i K 6 t ! C *`i .t/. Par l'hypothe`se (HYP- gC *`), le membre de droit de cette dernie`re ine'galite'
est un e'le'ment de J gC *`K et on a donc !Jo"" ! #i 69 gC *`K. On a donc montre' que ! 2 J1K. On conclut
en notant que t D t0 D !J# K.

s^ Si R D (ij -SOUS-CLASSE), alors ij est de la forme C {`1 D ij1I . . . I `n D ijn}, t0 D t et il existe t1 tel
que t 6 t1 et t1 ` #ij : t1I G. Du co^te' syntaxique, on a : ` #ij : # 0I 10I 0, # D o"", 1 D 10 ng {o"" : o"" 6
# 0} et o"" kD dom.10/. En appliquant l'hypothe`se d'induction, on trouve qu'il existe !0 2 J10K telle
que G 6] !0J0K et t1 6 !J# 0K 6 #1, c'est-a`-dire t1 D !J# 0K. Posons alors ! D !0 l^ [o"" 7! t].
Comme o"" kD dom.10/, ! et !0 coi"ncident sur dom.!0/. Donc G 6] !J0K et !J# 0K D !0J# 0K. On a aussi
t D !Jo""K 6 t1 6 !J# 0K. Donc ! 2 J1K et on conclut en observant que t D t0 D !J# K. e^

LEMME 6.3 (CORRECTION). Si ^1I 0 ` ": ? et si ^1 ` 0 alors, pour tout ^! 2 J ^1K, on a ^!I ^!J0K `
" : ^!J? K.

De'monstration. Par induction sur la structure de l'expression ". Conside'rons une de'rivation du jugement ^1I 0 ` " : ? (1). Celle-ci se termine force'ment par la re`gle unique qui correspond a` " car le
syste`me de typage syntaxique est dirige' par la syntaxe.

s^ Si " est une variable, le re'sultat est trivial.
s^ Si " est une constante a, il de'coule de l'hypothe`se (HYP-ea) : JeaK D a.
s^ Si " est une primitive f , soit n l'arite' de f . Fixons une valuation quelconque ^! 2 J ^1K. Conside'rons
un e'le'ment quelconque t0 2 J ef K. Par l'hypothe`se (HYP- ef ), il existe t; t0; t01 ; . . . ; t 0n tels que t ! t0 6
t0 (2), pour tout i, Tuplen *i .t/ D t0i (3) et pour tous a1 2 t01 ; . . . ; an 2 t0n , f .a1; . . . ; an/ 2 t 0 (4). Les
e'quations (4) et (3) constituent les pre'misses de la re`gle (PRIMITIVEA), dont on de'duit le jugement

^!I ^!J0K ` f : t ! t0 (5). On peut appliquer la re`gle (SUB A) a` (5) et (2) et de'duire ^!I ^!J0K ` f : t0.
On a montre' ce dernier jugement pour tout t0 2 J ef K. Comme l'hypothe`se (HYP- ef ) nous impose que

J ef K soit non-vide, on peut appliquer la re`gle (GEN A) pour conclure.

s^ Si " est un accesseur C *`, alors le jugement (1) est ne'cessairement de la forme ^1I 0 ` " : gC *`.
Le sche'ma ? D gC *` est suppose' clos et par l'hypothe`se (HYP- f#C), on a J? K 6D ?. Ensuite, l'hypothe`se (HYP- gC *`) nous permet d'e'crire J? K D l^t ! C *`.t/l/. Fixons une valuation quelconque

^! 2 J ^1K et conside'rons un e'le'ment t ! C *`.t/ 2 J? K. Par la re`gle (GET A), on a ^!I ^!J0K ` " :
t ! C *`.t/. On a montre' ce dernier jugement pour tout e'le'ment de l'ensemble non-vide J? K. On
peut donc appliquer la re`gle (GENA) pour conclure ^!I ^!J0K ` " : J? K. On conclut en remarquant que
? e'tant clos, J? K D ^!J? K.

6.6. CORRECTION 99
s^ Si " est un objet de la forme C {`i D "i }, alors la re`gle applique'e pour de'duire le jugement (1) est
force'ment (OBJETV ). Les pre'misses de cette re`gle nous assurent que pour tout i , ^1I 0 ` "i : ?i (6),
qu'il existe deux variables o"" kD r' kD dom. ^1/ telles que ? puisse s'ecrire :

? D 8o"" : o"" 2 f#C ^

n^

iD1

9r' : .?i 69 r' ^ o"" ! r' 69 gC *`i / . o""(7)

et que ^1 ` ? (8). Fixons ^! 2 J ^1K. Par de'finition de (8), on sait que ^!J? K 6D ?. Par ailleurs, on
peut appliquer l'hypothe`se d'induction a` chacune des sous-expressions "i sachant (6). On de'duit que

^!I ^!J0K ` "i : ^!J?i K (9). Conside'rons maintenant un e'le'ment quelconque t 2 ^!J? K. D'apre`s la
de'finition de ? et le choix des variables o"" et r', on sait que t 2 Jf#CK (10) et que pour tout i , il existe
ti tel que ^!J?i K 69 ti (11) et t ! ti 69 J gC *`i K (12). Appliquons la re`gle (SUB]) a` (9) et (11). Il
vient ^!I ^!J0K ` "i : ti (13). Par (12), on sait par ailleurs qu'il existe un e'le'ment de J gC *`i K surtype
de t ! ti . Par l'hypothe`se (HYP- gC *`), on sait qu'il est ne'cessairement de la forme ui ! C *`i .ui /,
de sorte qu'on a t ! ti 6 ui ! C *`i .ui / (14). L'axiome (FLE`CHE-VARIANCE) applique' a` (14)
nous permet de de'duire que ti 6 C *`i .ui / (15) et ui 6 t (16). Par l'hypothe`se (HYP- f#C) et en
conside'rant (10), on sait que t 2 #C (17). t est donc dans le domaine de C *`i . Sachant (16) et par
l'axiome (CHAMPS-COVARIANTS), on de'duit que C *`i .ui / 6 C *`i .t/ (18). Par deux applications
de la re`gle (SUB A) a` (13) et (15), puis a` (18), on de'duit que ^!I ^!J0K ` "i : C *`i .t / (19). On peut
maintenant appliquer la re`gle (OBJET A) a` (17) et (19). Il vient donc ^!I ^!J0K ` " : t. On a montre'
ce dernier jugement pour tout t 2 ^!J? K, ensemble non-vide. On peut donc appliquer la re`gle (GENA)
pour conclure.

s^ Si " est une application de la forme "1 "2, la re`gle applique'e pour typer " est (APPV ). Voici ses
pre'misses : pour chaque i D 1; 2, on a ^1I 0 ` "i : ?i (20), le sche'ma ? vaut 8o""r' : ?1 69 o"" ! r' ^
?2 69 o"" . r' (21) avec o"" kD r' kD dom. ^1/ et ^1 ` ? (22). Fixons-nous une valuation quelconque ^! 2 J ^1K.
En appliquant l'hypothe`se d'induction a` "i et sachant (20), il vient ^!I ^!J0K ` "i : ^!J?i K (23). Par
de'finition de (22), on sait par ailleurs que ^!J? K 6D ?. Conside'rons alors un e'le'ment quelconque
t0 2 ^!J? K. La de'finition de ? et le choix des variables o"" et r' nous assurent qu'il existe t, interpre'tation
de o"", tel que ^!J?1K 69 t ! t0 (24) et ^!J?2K 69 t (25). En appliquant la re`gle (SUB]) a` (23) pour
i D 1 et (24), il vient ^!I ^!J0K ` "1 : t ! t0 (26). De me^me sur (23) pour i D 2 et (25), on a

^!I ^!J0K ` "2 : t (27). On peut donc appliquer (APP) a` (26) et (27) et de'duire ^!I ^!J0K ` "1 "2 : t0.
On a montre' ce dernier jugement pour tout monotype t 2 ^!J? K, ensemble non-vide. On peut donc
appliquer la re`gle (GENA) pour conclure.

s^ Si " est une fonction de la forme fun x : # ) "0, la re`gle applique'e pour de'duire (1) est force'ment (FUNV ) et on a ^1I 0[x : # ] ` "0: ? 0 (28) et ? D 8o"" : ? 0 69 o"" . # ! o"" avec o"" kD dom. ^1/. Conside'rons une valuation ^! 2 J ^1K. Comme 0[x : # ] est toujours satisfiable dans ^1, on peut appliquer
l'hypothe`se d'induction sur "0 et (28). On sait donc que ^!I ^!J0K[x : ^!J# K] ` "0 : ^!J? 0K (29). Conside'rons maintenant un e'le'ment quelconque t 2 ^!J? K. Comme o"" est convenablement choisie pour e'viter
les captures, il existe donc t0 (la valeur de o"") tel que ^!J? 0K 69 t0 (30) et t D ^!J# ! o""K, c'est-a`-dire
t D ^!J# K ! t0 (31). En appliquant la re`gle (SUB]) a` (29) et (30), il vient ^!I ^!J0K[x : ^!J# K] ` "0 : t0.
On peut alors appliquer la re`gle (FUN A) a` ce dernier jugement et de'duire ^!I ^!J0K ` " : ^!J# K ! t0,
c'est-a`-dire, en utilisant l'e'galite' (31), ^!I ^!J0K ` " : t (32). Par de'finition du syste`me semi-alge'brique,
le jugement (29) ne peut e^tre valable que si ^!J? 0K 6D ?. La de'finition de ? implique clairement que

^!J? K 6D ?. Comme on a montre' le jugement (32) pour tout e'le'ment t de ^!J? K, ensemble non-vide, onpeut appliquer la re`gle (G

ENA) pour conclure.

s^ Si " est de la forme let x D "1 in "2, la re`gle applique'e pour de'duire le jugement (1) est

100 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
force'ment (LETV ) et on a ^1I 0 ` "1 : ?1 (33) et ^1I 0[x : ?1] ` "2 : ? (34). On peut appliquer
l'hypothe`se d'induction a` "1 sachant (33). On en de'duit que pour toute valuation ^! 2 J ^1K, on a

^!J0KI "1 ` ^!JT t1K : (35). Ce jugement implique ne'cessairement que ^!J?1K est non-vide, ce qu'ona montre' pour tout

^! 2 J ^1K. Par de'finition, on a donc ^1 ` ?1 et donc ^1 ` 0[x : ?1] (36). Fixons

maintenant une valuation ^! 2 J ^1K. On peut appliquer l'hypothe`se d'induction a` "2 sachant (34)
et (36). On en de'duit que ^!I ^!J0[x : ?1]K ` "2 : ^!J? K, c'est-a`-dire ^!I ^!J0K[x : ^!J?1K] ` "2 : ^!J? K. On
conclut, en appliquant la re`gle (LETA), que ^!I ^!J0K ` " : ^!J? K.

s^ Si " est de la forme fix x : ? ) "0, la re`gle applique'e pour de'duire le jugement (1) est force'ment (FIXV ) et on a : ^1 ` ? (37), ^1I 0[x : ? ] ` "0 : ? 0 (38) et ^1 ` ? 0 6] ? (39). Par (37) et
comme on a de'ja` ^1 ` 0, on peut e'crire ^1 ` 0[x : ? ]. On peut donc appliquer l'hypothe`se d'induction sur "0. Pour toute valuation ^! 2 J ^1K, on de'duit que ^!I ^!J0[x : ? ]K ` "0 : ^!J? 0K, c'est-a`-dire

^!I ^!J0K[x : ^!J? K] ` "0 : ^!J? 0K (40). Par de'finition de (39), on sait que ^!J? 0K 6] ^!J? K (41). On peut
alors appliquer la re`gle (SUB]) a` (40) et (41) pour de'duire ^!I ^!J0K[x : ^!J? K] ` "0 : ^!J? K. On conclut
en appliquant (FIXA).

s^ Si " est de la forme 8V : u* ."0, alors la re`gle applique'e pour de'duire (1) est ne'cessairement (INTROV ).
Les pre'misses de cette re`gle sont ^1 ` 9V : u* (42), ^1 ng {V : u*}I 0 ` "0 : ? 0 (43), ^V kD V et ? D
8V; o"" : u* ^ ? 0 69 o"" . o"" (44) avec o"" kD dom. ^1/ [ V. Fixons nous une valuation ^! 2 J ^1K et conside'rons
un e'le'ment quelconque t ^!J? K. Par la proprie'te' (44) et compte-tenu du choix de la variable o"", on sait
qu'il existe ! 2 ^!J{V : u*}K telle que ^!l^!J? 0K 69 t (45). Par la caracte'risation du produit des contextes

^1 et {V : u*}, on a d'autre part ^! l^ ! 2 J ^1 ng {V : u*}K. Par ailleurs, ^!l^!J0K D ^!J0K car ^V kD V. On

a donc toujours ^1 ng {V : u*} ` 0. On peut donc appliquer l'hypothe`se d'induction a` "0 sachant (43).
Il vient ^! l^ !I ^!J0K ` "0 : ^!l^!J? 0K (46). En appliquant la re`gle (SUB]) a` (46) et (45), on sait que

^! l^ !I ^!J0K ` "0 : t (47). Par de'finition de (42), on sait d'autre part que ^!J9V : u*K est vrai. On peut
alors appliquer la re`gle (INTRO A) a` (46) et tous les jugements (47) pour de'duire ^!I ^!J0K ` " : t.
On a montre' ce dernier jugement pour tout t 2 ^!J? K. Enfin, la condition (42) assurant que ^!J? K est
non-vide, on peut appliquer la re`gle (GEN A) pour conclure.

s^ Si " est une me'thode meth : # ! # 0 l^ij j ) " j l/, c'est la re`gle (METHV ) qui a e'te' applique'e pour
de'duire le jugement (1). Ses pre'misses sont ^1 ` # ! # 0 FG ij1I . . . I ijk (48) et, pour tout j 2 [1; k],

^1I 0 ` ij j ) " j : # ! # 0 (49). Ce dernier jugement est ne'cessairement obtenu par la re`gle (CASV )

et on a les pre'misses suivantes : ` ij j : # j I 1 j I 0 j , dom. ^1/ kD dom.1 j /, ^1 j D ^1 ng 1 j ng # j 6 # ,

^1 j I 0 l^ 0 j ` " j: ? j (50) et ^1 j ` ? j 6] # 0 (51). Fixons nous une valuation ^! 2 J ^1K et conside'rons

un jugement quelconque de ^!J# K ` ij j : t00I G j (52). Par le lemme 6.2, on sait qu'il existe ! j 2 J1 j K
telle que G j 6] !j J0 j K (53) et t00 6 !j J# j K 6 ^!J# K. Posons maintenant ^! j D ^! l^ ! j . Comme

dom. ^1/ kD dom.1 j /, ^! j coi"ncide avec ^! sur ^V et avec ! j sur V j . On a donc ^!j J# j K 6 ^!j J# K et
comme ^! 2 J ^1K et ! j 2 J1 j K, on a finalement ^! j 2 J ^1 j K. Par le me^me argument, ^!j J0K D

^!J0K, ce qui est en fait valable pour toute ^! j 2 J ^1 j K, ce qui signifie que ^1 j ` 0. Comme parailleurs,

0 j est uniquement compose' de monotype, on a aussi ^1 j ` 0 l^ 0 j (54). On peut maintenant

appliquer l'hypothe`se d'induction a` " j sachant (50) et (54). Il vient ^! j I ^!j J0 l^ 0 j K ` " j : ^!j J? j K (55).
L'environnement de typage ^!j J0 l^ 0 j K vaut ^!j J0K l^ ^!j J0 j K. Compte-tenu du choix des variables, il
vaut aussi ^!J0K l^ !j J0 j K. De (53), on de'duit alors ^!J0K l^ G j 6] ^!J0K l^ !j J0 j K (56). Par le lemme 6.1
(subsomption sur les environnements de typage) applique' a` (55) et (56), on sait ^! j I ^!J0K l^ G j `
" j : ^!j J? j K (57). D'apre`s la de'finition de (51), on sait que ^!j J? j K 6] ^! j J# 0K (58). On peut alors
appliquer (SUB]) a` (57) et (58) pour de'duire ^! j I ^!J0K l^ G j ` " j : ^!j J# 0K (59). Pour e^tre valable,

le jugement (1) ne'cessite que ftv."/ t, dom. ^1/. Donc # 0 ne peut contenir que des variables de ^1
et comme ^! j coi"ncide avec ^! sur ^V, on a ^!j J# 0K D ^!J# 0K. Par ailleurs, ftv." j / t, ftv."/, donc le

6.7. COMPLE'TUDE 101
jugement (59) est aussi valable dans la valuation ^!. On a finalement ^!I ^!J0K l^ G j ` " j : ^!J# 0K. On
a montre' ce dernier jugement pour toute instance du jugement (52), ce qui nous permet d'appliquer
la re`gle (CASA) et de'duire ^!I ^!J0K ` ij j ) " j : ^!J# K ! ^!J# 0K (60). Par ailleurs, la de'finition
de (48) implique ^!J# K ! ^!J# 0K FG ij1I . . . I ijk (61). Les jugements (60) et la proprie'te' (61) permettent
finalement de conclure ^!I ^!J0K ` " : ^!J# ! # 0K. e^

6.7 Comple'tude

LEMME 6.4. Pour tout motif ij et tout ensemble de variables ^V, on peut calculer un monotype # , un
contexte 1 et un environnement 0 tels que ` ij : # I 1I 0 et ^V kD dom.1/

De'monstration. Aucun test alge'brique n'intervient dans les re`gles de typage syntaxique des motifs. Il
suffit donc de parcourir me'caniquement la structure du motif ij , en choisissant toujours les variables
de type << frai^ches >>, c'est-a`-dire hors de ^V et du domaine de tous les contextes 1 engendre's jusqu'au
moment ou` on choisit la variable. e^

LEMME 6.5. Si ` ij : # I 1I 0, alors, pour tout ! 2 J1K, !J# K ` ij : !J# KI !J0K.

De'monstration. Par induction sur la de'rivation de ` ij : # I 1I 0. Conside'rons la dernie`re re`gle R
applique'e :

s^ Si R D (ij -UNIVERSELV ), alors ij est le motif universel _ et 0 D ?. On peut appliquer directement
la re`gle (ij -UNIVERSEL) pour de'duire directement !J# K ` ij : !J# KI ?.

s^ Si R D (ij -PRIMV ), alors ij est un motif primitif $ , on a 1 D {o"" : o"" 2 e$ }, # D o"" et 0 D ?. Toute
valuation ! 2 J1K est donc de la forme [o"" 7! t] avec t 2 J e$ K. Par l'hypothe`se (HYP- e$ ), on sait
donc que t 2 $ . Par de'finition de ce dernier ensemble, il existe donc une constante a 2 $ (1) telle
que t D a. En appliquant la re`gle (ij -PRIM) a` (1), on obtient a ` $ : aI ?, c'est-a`-dire t ` $ : tI ?.
Par ailleurs, comme # D o"", on remarque que t D !J# K et on a donc bien !J# K ` $ : !J# KI ?.

s^ Si R D (ij -LIEURV ), alors ij est de la forme ij 0 as x et on a 0 D 00[x : # ] avec ` ij 0 : # I 1I 00.
Conside'rons alors une valuation quelconque ! 2 J1K. Par l'hypothe`se d'induction, on a !J# K `
ij 0 : !J# KI !J00K. En appliquant la re`gle (ij -LIEUR) a` ce dernier jugement, on en de'duit que !J# K `
ij : !J# KI !J00K[x : !J# K]. On conclut en remarquant que !J00K[x : !J# K] D !J0K.

s^ Si R D (ij -CLASSEV ), alors ij est de la forme #C {`i D iji }. Pour tout i , on a ` iji : #i I 1i I 0i (2),
le monotype # est une variable o"", le contexte 1 vaut 1 D 11 ng * * * ng 1n ng {o"" : u*} (3) avec
u* D o"" 2 f#C ^ VniD1 o"" ! #i 69 gC *`i et on a finalement la condition dom.11/ kD . . . dom.1n/ kD o"" (4).
Conside'rons une valuation quelconque ! 2 J1K. La de'finition (3) et la caracte'risation des produits
de contextes impose que cette valuation soit de la forme ! D !1 l^ * * * l^ !n l^ [o"" 7! t] avec chacune des !i dans J1i K et t satisfaisant la contrainte u*, c'est-a`-dire !Ju*K (5). Appliquons maintenant l'hypothe`se d'induction a` chacune des de'rivations (2) et des valuations !i . Pour chaque i , on
obtient : !i J#i K ` iji : !i J#i KI !i J0i K. Gra^ce a` la condition (4), on constate que la valuation ! coi"ncide avec chaque !i sur le domaine de celle-ci. On a donc aussi !J#i K ` iji : !i J#i KI !J0i K (6). Par
ailleurs, le fait que u* est vraie (interpre'tation (5)) signifie que t 2 !Jf#CK (7) et que pour chaque i ,
t ! !i J#i K 69 J gC *`i K (8). L'hypothe`se (HYP- f#C) applique'e a` (7) nous dit que t 2 #C (9). Par ailleurs,
l'hypothe`se (HYP- gC *`) applique' a` (8) nous dit que pour chaque i , il existe un monotype alge'brique
ui tel que t ! !i J#i K 6 ui ! C *`i .ui / (10). En appliquant l'axiome (FLE`CHE-VARIANCE) a` (10),

102 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
il vient !i Jti K 6 C *`i .ui / (11) et ui 6 t (12). D'autre part, par (9), on sait que t est dans #C, qui est
le domaine de C *`i . Donc C *`i .t/ est bien de'fini. En appliquant l'axiome (CHAMPS-COVARIANTS)
a` (12), il vient alors C *`i .ui / 6 C *`i .t/ (13). Par transitivite' de la relation de sous-typage applique'e
a` (11) et (13), on obtient !i Jti K 6 C *`i .t/ (14). On peut alors appliquer la re`gle (ij -SUB) a` (6) et (14)
pour de'duire C *`i .t / ` iji : !i J#i KI !J0i K (15). Enfin, en appliquant (ij -CLASSE) a` (9) et a` chacun des
jugements (15), on de'duit t ` ij : tI !J01K l^ * * * l^ !J0nK. On conclut en remarquant que t vaut !J# K
et que !J01K l^ * * * l^ !J0nK D !J0K.

s^ Si R D (ij -SOUS-CLASSEV ), alors ij est de la forme #ij 0 ou` ij 0 est un motif de la forme C {. . .}.
Les pre'misses de la re`gle nous disent que le monotype # est une variable o"", qu'il existe un contexte
10 tel que o"" kD dom.10/, ` ij 0 : # I 10I 0 (16) et 1 D 10 ng {o"" : o"" 6 # }. Conside'rons une valuation
! 2 J1K. Par caracte'risation du produit des contextes, ! est ne'cessairement de la forme !0 l^ [o"" 7! t ]
ou` !0 2 J10K et t 6 !0 J# K (17). Appliquons l'hypothe`se d'induction a` (16) et a` la valuation !0. Il
vient !0J# K ` ij 0 : !0 J# KI !0J0K. Comme ! et !0 coi"ncident sur le domaine de !0, on a aussi !J# K `
ij 0 : !J# KI !J0K (18). Appliquons alors la re`gle (ij -SOUS-CLASSE) a` (17) et (18) pour de'duire t `
ij 0 : tI !J0K. On conclut en remarquant que t D !J# K. e^

On dit que " est ^V-NORMALE si quand " est une expression de la forme 8V : u* . "0, on a ^V kD V et "0
est ^V [ V-normale et dans les autres cas toutes les sous-expressions de " sont e'galement ^V-normale.
Intuitivement, une expression " est ^V-normale s'il n'y a pas de masquage de variables de types dans "
et si toutes les variables introduites sont en dehors de ^V.

LEMME 6.6 (COMPLE'TUDE). Soit ^1 D { ^V : ^u*} un contexte et " une expression ^V-normale. Si pour
tout ^! 2 J ^1K, il existe un polytype alge'brique T ^! tel que ^!I ^!J0K ` " : T ^! (1), alors il existe un
sche'ma de type ? tel que ^1I 0 ` ": ? et pour tout ^!, ^!J? K 6] T ^!.

De'monstration. Notons que l'ensemble J ^1K peut tre`s bien e^tre vide. On proce`de par induction sur la
structure de ". Remarquons d'abord qu'on peut se limiter au cas ou` chacun jugement (1) admet une
de'rivation simple. Si ce n'est pas le cas, on peut en effet appliquer le lemme de simplification 4.2 et
trouver, pour chaque ^!, une de'rivation simple de ^!I ^!J0K `0 " : T 0^! telle que T 0^! 6] T ^!. En supposant

qu'on puisse en de'duire qu'il existe ? tel que ^1I 0 ` ": ? et ^!J? K 6] T 0^!, alors on a aussi ^!J? K 6] T ^!,
par transitivite' de 6].

Supposons donc que tous les jugements (1) admettent une de'rivation simple note'e ^!I ^!J0K `0 " :
T ^! (2). La dernie`re re`gle applique'e dans ces de'rivations est alors de'termine'e par la nature de l'expression " et est donc identique pour toutes les valuations ^!. On examine alors tous les cas possibles pour
".

s^ Si " est de la forme 8V : u* . "0, l'hypothe`se que " est ^V-normale signifie que ^V kD V et que "0
est ^V [ V-normale. Les de'rivations simples (2) terminent force'ment toutes par la re`gle (INTROA) et
donc, pour tout ^! 2 J ^1K, on a ^!J{V : u*}K 6D ? (3). Pour tout ! 2 ^!J{V : u*}K, il existe de plus un
polytype alge'brique T 0^!;! tel que ^! l^ !I ^!J0K ` "0 : T 0^!;! (4) et l'ensemble de tous les T 0^!;! est tel que

T ^! D S!2 ^!J{V: u*}K T 0^!;! (5). Conside'rons maintenant le contexte ^10 D ^1ng{V : u*}. Par la caracte'risation
des produits de contextes, tout e'le'ment ^!0 2 J ^10K est de la forme ^!l^! avec ^! 2 J ^1K et ! 2 ^!J{V : u*}K.
Comme ^! et ^!0 coi"ncident sur ^V, on a d'autre part ^!J0K D ^!0J0K. On peut donc re'e'crire le jugement (4)
sous la forme ^!0I ^!0J0K ` " : T 0^!;!. Ce dernier jugement a e'te' montre' quel que soit ^!0 2 J ^10K. On peut
donc appliquer l'hypothe`se d'induction a` "0 et de'duire qu'il existe un sche'ma de type ? 0 tel que

^10I 0 ` "0: ? 0 (6) et tel que, pour toute ^! l^ ! 2 J ^10K, on ait ^!l^!J? 0K 6] T ^!;! (7). D'autre part, la

6.7. COMPLE'TUDE 103
proprie'te' (3) signifie, par de'finition, ^1 ` 9V : u* (8). Appliquons maintenant la re`gle (INTROV ) a` (8)
et (6). On de'duit ^1I 0 ` ": ? avec ? D 8V; o"" : u* ^ ? 0 69 o"" . o"" ou` o"" est choisie telle que o"" 62 ^V [ V.
Conside'rons maintenant un e'le'ment quelconque t 2 T ^!. Par de'finition de T ^! (e'quation (5)), on sait
qu'il existe ! 2 ^!J{V : u*}K telle que t 2 T 0^!;!. Par (7), il s'en suit qu'il existe t0 2 ^!l^!J? 0K tel que

t0 6 t, c'est-a`-dire que ^!l^!J? 0K 69 t (9). Posons maintenant !00 D ! l^ [o"" 7! t]. On a t D ^!l^!00Jo""K,
l'ine'galite' (9) signifie que ^!l^!00J? 0 69 o""K est vrai et enfin, ^!l^!00Ju*K est vrai car ! 2 ^!J{V : u*}K. En fin
de compte, on a donc t 2 ^!J? K. On a donc prouve' que T ^! t, ^!J? K, ce qui implique ^!J? K 6] T ^!, ce
qu'il fallait de'montrer.

s^ Si " est une application de la forme "1 "2, alors toutes les de'rivations simples de (2) terminent
force'ment par la re`gle (APPA). Le polytype T ^! est alors un monotype T ^! D t0^! (10) et on a les jugements

^!I ^!J0K ` "1 : t ^! ! t0^! (11) et ^!I ^!J0K ` "2 : t ^! (12). Ces deux derniers jugements e'tant valables quel

que soit ^! 2 J ^1K, on peut appliquer l'hypothe`se d'induction a` "1 et "2. D'une part, il existe donc un
sche'ma de type ?1 tel que ^1I 0 ` "1: ?1 (13) et pour tout ^! 2 J ^1K, ^!J?1K 6] t ^! ! t0^! (14). D'autre

part, il existe ?2 tel que ^1I 0 ` "2: ?2 (15) et pour tout ^!, ^!J?2K 6] t ^! (16). Choisissons maintenant
deux variables de type o"" et r' frai^ches , c'est-a`-dire telles que o""kDr' kD ^V. Posons ! D [o"" 7! t ^!I r' 7! t0^!].
Les ine'quations (14) et (16) montrent que l'interpre'tation ^!l^!J?1 69 o"" ! r' ^?2 69 o""K (17) est vraie.
Posons ? D 8o""r' : ?1 69 o"" ! r' ^?2 69 o"".r'. D'apre`s (17), on sait que t0^! 2 ^!J? K, ce qu'on peut aussi

e'crire ^!J? K 6] t0^! (18). L'interpre'tation du sche'ma ? dans ^! est donc non-vide (19). En appliquant la
re`gle (APPV ) a` (13), (15) et (19), on conclut ^1I 0 ` "1 "2: ? .

s^ Si " est une fonction de la forme fun x : # ) "0, alors la dernie`re re`gle applique'e dans toutes
les de'rivation de (2) est force'ment (FUN A). Pour toute ^! 2 J ^1K, le polytype T ^! est donc de la forme

^!J# K ! t ^! (20) et on a ^!I G[x : ^!J# K] ` "0 : t ^! (21). On peut appliquer l'hypothe`se d'induction a` "0et a` (21) et de'duire qu'il existe un sche'ma de type

? 0 tel que ^1I 0[x : # ] ` "0: ? 0 (22) et tel que pour

toute ^! 2 J ^1K, on ait ^!J? 0K 6] t ^! (23). Choisissons une variable de type o"" frai^che, c'est-a`-dire telle
que o"" kD ^V. En appliquant la re`gle (FUNV ) a` (22) et en posant ? D 8o"" : ? 0 69 o"" . # ! o"", il vient

^1I 0 ` " : ? (24). Prenons maintenant une valuation quelconque ^! 2 J ^1K. (23) peut aussi s'e'crire

^!J? 0K 69 t ^! (25). En utilisant la valuation ! D [o"" 7! t ^!], on constate que t ^! 2 ^!J? K, c'est-a`-dire que
^!J? K 6] T ^!.

s^ Si " est une variable, le re'sultat est trivial.

s^ Si " est un accesseur de la forme C *`, alors on a toujours la de'rivation syntaxique ^1I 0 ` C *`: gC *`.
Par ailleurs, la dernie`re re`gle applique'e dans toutes les de'rivations (2) e'tant force'ment (GET A), on a

T ^! D t ! C *`.t/ pour un certain monotype t. Par l'hypothe`se (HYP- gC *`), on a alors T ^! 2 J? K et
donc ^!J? K 6] T ^!.

s^ Si " est de la forme let x D "1 in "2, alors les de'rivations simples de (2) terminent force'ment
par (LET A). Pour toute valuation ^! 2 J ^1K, il existe donc T 1^! tel que ^!I ^!J0K ` "1 : T 1^! (26) et

^!I ^!J0K[x : T 1^! ] ` "2 : T ^!. Appliquons l'hypothe`se d'induction a` "1 et a` (26). On peut donc trouver un
sche'ma ?1 tel que ^1I 0 ` "1: ?1 (27) et ^!J?1K 6] T 1^! (28). De cette dernie`re ine'galite', on de'duit que

^!J0[x : ?1]K 6] ^!J0K[x : T 1^! ] (29). On peut alors appliquer le lemme 6.1 a` (27) et (29), ce qui nousdonne

^!I ^!J0[x : ?1]K ` "2 : T ^! (30). Appliquons maintenant l'hypothe`se d'induction a` "2 et (30).

On peut donc trouver un sche'ma ?2 tel que ^1I 0[x : ?1] ` "2: ?2 (31) et tel que pour toute ^!, on ait

^!J?2K 6] T ^!. On conclut finalement en appliquant la re`gle (LETV ) a` (27) et (31).

s^ Si " est une expression re'cursive de la forme fix x : ? ) "0, alors toutes les de'rivations (2) se
terminent force'ment par la re`gle (FIX A). On a donc ^!I ^!J0[x : ? ]K ` "0 : ^!J? K (32). Appliquons

104 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES
l'hypothe`se d'induction a` "0 et a` (32). Il existe donc un sche'ma ? 0 tel que ^1I 0[x : ? ] ` "0: ? 0 (33)
et ^!J? 0K 6] ^!J? K (34). Du jugement (32), on de'duit que ^!J? K n'est jamais vide. On a donc ^1 `
? (35). D'autre part, la conjonction de toutes les ine'quations (34) est par de'finition e'quivalente a`

^1 ` ? 0 6] ? (36). On peut finalement appliquer la re`gle (FIXV ) a` (33), (35) et (36) pour conclure

^1I 0[x : ? ] ` ": ? .

s^ Si " est un objet de la forme C {`i D "i }, alors toutes les de'rivations simples (2) se terminent force'ment par la re`gle (OBJET A). Pour toute valuation ^! 2 J ^1K, le polytype T ^! est un monotype t ^! 2 #C
et pour tout i, on a ^!I ^!J0K ` "i : C *`i .t ^!/ (37). Appliquons l'hypothe`se d'induction a` chacune des
sous-expressions "i et a` (37). Il existe donc pour chaque i un sche'ma ?i tel que ^1I 0 ` "i : ?i (38)
et ^!J?i K 6] C *`i .t ^!/. Choisissons deux variables o"" et r' frai^ches, c'est-a`-dire telles que o"" kD r' kD ^V et
conside'rons le sche'ma suivant :

? D 8o"" : o"" 2 f#C ^

n^

iD1

9r' : .?i 69 r' ^ o"" ! r' 69 gC *`/ . o""(39)

En posant ! D [o"" 7! t ^!], on a clairement ^!l^!Jo"" 2 f#CK et, pour chaque i, t ^! ! C *`i .t ^!/ est
par l'hypothe`se (HYP- gC *`) dans J gC *`i K. La valuation !0 D [r' 7! C *`i .t ^!/] nous montre donc que
l'interpre'tation ^!J?1 69 r' ^ o"" ! r' 69 gC *`i K est vraie. En fin de compte, on a donc montre' que
t ^! 2 ^!J? K et donc que ^!J? K 6] t ^! (40). Cela prouve que ? est bien non-vide dans toute valuation ^!,
c'est-a`-dire que ^1 ` ? (41). En appliquant la re`gle (OBJETV ) a` (38) et (41), on conclut ^1I 0 ` ": ? .

s^ Si " est une constante a, les de'rivations simples de (2) terminent force'ment par (CONSTANTE A)
et on a T ^! D a. Par ailleurs, on a toujours ^1I 0 ` " : ea, par la re`gle (CSTV ). On peut conclure en
remarquant que, par l'hypothe`se (HYP-ea), JeaK D a.

s^ Si " est une primitive f , les de'rivations simples de (2) terminent force'ment par (PRIMITIVEA). T ^!
est donc un monotype e'le'ment de f . Par ailleurs on a toujours ^1I 0 ` ": ef , par la re`gle (PRIMV ). Par
l'hypothe`se (HYP- ef ), on conclut que J ef K 6] T ^!.

s^ Il reste le cas ou` " est une me'thode de la forme meth : # ! # 0 l^ij j ) " j I . . . l/. Les de'rivations
simples de (2) se terminent force'ment par la re`gle (METHA). Pour toute ^! 2 J ^1K, le polytype T ^! est
donc e'gal au monotype ^!J# K ! ^!J# 0K (42), on a le test de couverture ^!J# ! # 0K FG ij1I . . . I ijk (43)
et pour tout j , on a ^!I ^!J0K ` .ij j ) " j / : ^!J# K ! ^!J# 0K (44) Fixons maintenant un indice j . Par la
re`gle (CASA), le jugement (44) est vrai si et seulement si :

8t0j ; G j ; . ^!J# K ` ij j : t0j I G j / ) . ^!I ^!J0K l^ G j ` " j : ^!J# 0K/(45)
Par le lemme 6.4, on sait qu'il existe # j , 1 j et 0 j tels que 1 j kD ^1 (46) et ` ij j : # j I 1 j I 0 j (47). Posons

^1 j D ^1 ng 1 j ng # j 6 # et conside'rons une valuation ^! j quelconque dans J ^1 j K. Par la caracte'risation

des produits, ^! j est ne'cessairement de la forme ^! l^ ! j avec ^! 2 J ^1K, ! j 2 J1 j K et !j J# j K 6

^!J# K (48). Appliquons maintenant le lemme 6.5 a` la valuation ! j 2 J1 j K et au jugement (47). Onobtient

!j J# j K ` ij j : !j J# j KI !j J0 j K (49). En appliquant la re`gle (ij -SUB) a` (48) et a` (49), il vient
^!J# K ` ij j : !j J# j KI !j J0 j K (50). L'implication (45) applique'e a` (50) nous permet alors de de'duire

^!I ^!J0K l^!j J0 j K ` " j : ^!J# 0K (51) Comme ^! kD! j , l'environnement dans ce dernier jugement est e'gal a`

^!j J0l^0 j K. Par ailleurs, le jugement (51) est e'galement valide dans la valuation ^! j car celle-ci coi"ncideavec

^! sur le domaine de ^!. Finalement, on peut donc e'crire ^! j I ^!j J0 l^ 0 j K ` " j : ^! j J# 0K (52). Le

jugement (52) a e'te' montre' pour toute valuation ^! j 2 J ^1 j K. On peut appliquer l'hypothe`se d'induction
a` " j et a` (52). Il existe donc un sche'ma de type ? j tel que ^1 j I 0 l^ 0 j ` " j : ? j (53) et tel que pour
toute valuation ^! j 2 J ^1 j K, on ait ^!j J? j K 6] ^!j J# 0K (54). Les ine'galite's (54) e'tant valables pour

6.8. TRAITEMENT DES MASQUAGES 105
toute valuation ^! j , on a par de'finition ^! j ` ? j 6] # 0 (55). On peut maintenant appliquer la re`gle
syntaxique (CASV ) a` (46), (47), (53) et (55) pour de'duire ^1I 0 ` ij j ) " j: # ! # 0 (56). Par ailleurs,
le test de couverture (43) e'tant valable pour toute les valuations ^! 2 J ^1K, on a donc par de'finition

^1 ` # ! # 0 FG ij1I . . . I ijk (57). En appliquant la re`gle (METHV ) a` (57) et a` tous les jugements (56),

on conclut ^1I 0 ` ": ? . e^

6.8 Traitement des masquages

Dans le lemme de comple'tude 6.5, on a suppose' que l'expression " est ^V-normale, ce qui permet de traiter commode'mment l'introduction de variables de type. Nous allons maintenant montrer
comment toute expression peut e^tre normalise'e sans que cela change son typage dans le syste`me semialge'brique. L'ide'e de la preuve consiste simplement a` parcourir l'expression en renommant toutes les
variables introduites de fac,on a` ce qu'un me^me nom de variable ne soit jamais utilise' pour re'fe'rencer
deux variables diffe'rentes. Un compilateur effectuerait naturellement cette ope'ration dans une premie`re passe d'analyse syntaxique, quand il remplace les identificateurs dans la syntaxe concre`te par
des re'fe'rences vers des structures internes diffe'rentes pour chaque variable dans la syntaxe abstraite.
Il convient simplement de ve'rifier que cette ope'ration ne change rien au typage, ce qui est fastidieux,
mais sans aucune difficulte'.

Dans cette section, on appelera E'LE'MENT SYNTAXIQUE DE TYPAGE, qu'on notera t, , un monotype syntaxique, une contrainte, un sche'ma de types ou une expression annote'e. Il est commode de
de'finir l'interpre'tation d'une expression annote'e " relativement a` une certaine valuation ^! comme
l'ensemble des couples .G; T / tels que " ait le type ? dans l'environnement G et la valuation ^! :

^!J"K D l^.G; T / | ^!I G ` " : T l/(6.18)
On appelle RENOMMAGE DE VARIABLES DE TYPES une fonction partielle injective a` domaine
finie de VarsType vers VarsType. Si V1 est le domaine d'un renommage R et V2 son codomaine,
alors R-1 est un renommage de domaine V2 et de codomaine V1. Si V1 et V2 sont deux ensembles
finis de variables de types, alors il existe un renommage de domaine V1 et de codomaine disjoint de
V2, car VarsType est suppose' infini. On peut de plus imposer que ce renommage laisse inchange'es
les variables qui sont dans V1 \ V2. Un de ces renommage est choisi arbitrairement et note' R.V1; V2/.
On a donc :

dom.R.V1; V2// D V1
codom.R.V1; V2// kD V2

R.V1; V2/.o""/ D o"" si o"" 2 V1 et o"" 62 V2

Un renommage s'applique a` tout e'le'ment de typage. Pour simplifier, on supposera quand on applique le renommage R a` l'e'le'ment t, qu'on a toujours ftv.t,/ t, dom.R/. L'application du renommage

106 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES

R a` l'e'le'ment t, est note'e [R]t, et est de'finie par les e'quations suivantes :

[ ^R]o"" , ^R.o""/
[ ^R].# ! # 0/ , [ ^R]# ! [ ^R]# 0
[ ^R].ch#1; . . . ; #ni/ , ch[ ^R]#1; . . . ; [ ^R]#ni

[ ^R]vrai , vrai
[ ^R].# 6 # 0/ , [ ^R]# 6 [ ^R]# 0
[ ^R]. ph#1; . . . ; #ni/ , ph[ ^R]#1; . . . ; [ ^R]#ni

[ ^R].u* ^ u*0/ , [ ^R]u* ^ [ ^R]u*0

[ ^R].9V : u*/ , 9R.V/ : [ ^R l^ R]u* ou` R D R.V; codom. ^R//
[ ^R].8V : u* . # / , 8R.V/ : [ ^R l^ R]u* . [ ^R l^ R]# ou` R D R.V; codom. ^R//

[ ^R]x , x
[ ^R]."1 "2/ , [R]"1 [ ^R]"2
[ ^R].fun x : # ) "/ , fun x : [ ^R]# ) [ ^R]"
[ ^R].let x D "1 in "2/ , let x D [ ^R]"1 in [ ^R]"2

[ ^R].fix x : ? ) "/ , fix x : [ ^R]? ) [ ^R]"

[ ^R].C {`i D "i }/ , C n`i D [ ^R]"i o

[ ^R]C *` , C *`

[ ^R]a , a
[ ^R] f , f

[ ^R].meth : # ! # 0 l^ij j ) " j l// , meth : [ ^R]# ! [ ^R]# 0 nij j ) [ ^R]" j o

[ ^R].8V : u* . "/ , 8R.V/ : [ ^R l^ R]u* . [ ^R l^ R]" ou` R D R.V; codom. ^R//

Les lemme suivant expriment la proprie'te' d'invariance attendue de l'application d'un renommage :
LEMME 6.7. Pour tout e'le'ment de typage t, , tout renommage R tel que ftv.t, / t, dom.R/, et toute
valuation ! telle que codom.R/ t, dom.!/, alors !s'RJt, K et !J[R]t, K sont tous les deux bien de'finis et
e'gaux.

De'monstration. Si t, est un monotype, la preuve se fait par induction sur sa structure. Dans le cas ou`
c'est une variable o"", on ve'rifie simplement que, d'apre`s les hypothe`ses, !.R.o""// est bien de'fini et est
e'gal aux deux interpre'tations qu'on veut comparer. Les autres cas sont triviaux.

Si t, est une contrainte, on proce`de de me^me par induction sur sa structure. Le seul cas non-trivial
est celui ou` la contrainte vaut 9V : u*. Notons alors ^R D R.V; codom.R//. Prenons une valuation
quelconque ^! de domaine ^V D ^R.V/. On ve'rifie facilement que ftv.u*/ t, dom.R l^ ^R/ et que
codom.R l^ ^R/ t, dom.! l^ ^!/. Par l'hypothe`se d'induction, !l^ ^!J[R l^ ^R]u*K est donc e'quivalent
a` .!l^ ^!/s'.Rl^ ^R/Ju*K. Montrons maintenant que la valuation !1 D .! l^ ^!/ s' .R l^ ^R/ coi"ncide avec

6.8. TRAITEMENT DES MASQUAGES 107
!2 D .! s' R/ l^ . ^! s' ^R/ sur toutes les variables o"" 2 ftv.u*/. En effet, si o"" 2 V, alors o"" est dans le domaine de ^R, ^R.o""/ dans celui de ^! et !1 et !2 envoient toutes deux o"" sur ^!. ^R.o""//. Si en revanche o"" 6 V,
alors o"" n'est pas dans le domaine de ^R, mais o"" 2 ftv.9V : u*/. Par hypothe`se, on a donc o"" 2 dom.R/ et

R.o""/ 2 dom.!/. !2.o""/ vaut donc !. ^R.o""//. Par ailleurs R.o""/ ne peut e^tre dans dom. ^!/ car ce dernier
ensemble est aussi le codomaine de ^R et celui-ci est suppose' disjoint de codom.R/. Donc !1.o""/ vaut
e'galement !. ^R.o""//. Les valuations !1 et !2 coi"ncidant sur les variables libres de u*, on sait que !1Ju*K
est e'quivalent a` !2Ju*K. On a donc montre' que pour toute valuation ^! de domaine ^V, la valeur de ve'rite'
de !l^ ^!J[R l^ ^R]u*K (1) est e'quivalente a` celle de .!s'R/l^. ^!s' ^R/Ju*K (2). Maintenant, si !J[R].9V : u*/K est

vrai, alors il existe ^! qui ve'rifie (1), donc qui ve'rifie aussi (2). Alors, ^! s' ^R est une solution qui montre
que !s'RJ9V : u*K est vrai. Re'ciproquement, si !s'RJ9V : u*K est vrai, il existe !0 de domaine V tel que

.!s'R/l^!0Ju*K est vrai. En posant ^! D !0 s' ^R-1, on obtient (2), donc (1) et donc !J[R].9V : u*/K est vrai.

Si t, est un sche'ma de types, on utilise le me^me argument que pour les contraintes de la forme
9V : u*.

Si t, est une expression annote'e, il s'agit de montrer que pour tout G et T , le jugement !I G `
[R]" : T est e'quivalent au jugement ! s' RI G ` " : T . Montrons d'abord qu'on peut se contenter
de ve'rifier l'e'quivalence pour les de'rivations simples de ces jugements. En effet, si on conside`re une
de'rivation quelconque du premier jugement, alors il existe une de'rivation simple de la forme !I G `
[R]" : T 0 avec T 0 6] T . En supposant que cela nous permette de de'duire ! s' RI G ` " : T 0, il s'en
suit alors le jugement ! s' RI G ` " : T . La re'ciproque est clairement vraie e'galement. On proce`de
ensuite par induction sur la structure de l'expression " et on montre l'e'quivalence des deux jugements
pour pour toute valuation ! et tout .G; T /. Quand " ne contient pas d'annotation de type, la re'cursion
est triviale. Quand " contient une annotation de type, on peut utiliser les re'sultats prouve's plus haut
pour conclure. Le seul cas non-e'vident qui reste est donc quand l'expression est de la forme 8V : u* . ".
Posons alors ^R D R.V; codom.R// et ^V D ^R.V/. Par un argument identique a` celui utilise' pour le
traitement de la contrainte 9V : u*, les deux jugements suivants sont toujours e'quivalents si ^! est une
valuation de domaine ^V :

! l^ ^!I G ` [R l^ ^R]" : T ^! () .! s' R/ l^ . ^! s' ^R/I G ` " : T ^!(3)
De me^me, pour toute telle valuation ^!, on a aussi :

^! 2 !J{ ^V : [R l^ ^R]u*}K () ^! s' ^R 2 !s'RJ{V : u*}K(4)
Supposons maintenant que le jugement !I G ` [R].8V : u* . "/ : T soit vrai et qu'il admette une
de'rivation simple. Cette de'rivation termine force'ment par la re`gle (INTRO A) et on a :

!J{ ^V : [R l^ ^R]u*}K 6D ?(5)
8 ^! 2 !J{ ^V : [R l^ ^R]u*}K; ! l^ ^!I G ` [R l^ ^R]" : T ^!(6)

T D [ T ^!(7)

Par (4), on sait que l'ensemble !s'RJ{V : u*}K n'est pas vide car il contient ^! s' ^R. Par ailleurs, tout
e'le'ment !00 2 !s'RJ{V : u*}K peut s'e'crire sous la forme ^! s' ^R en posant ^! D !00 s' ^R-1. Donc, pour toute
telle !00, on a, d'apre`s (6) et (3), .! s' R/ l^ !00I G ` " : T!00s' ^R-1. En appliquant la re`gle (INTRO A), il
vient que !s'I G ` 8V : u* . " : T . La re'ciproque se traite de la me^me fac,on. e^

Comme son nom l'indique, un renommage a pour effet de renommer les variables libres d'un
e'le'ment syntaxique, mais, applique' a` une expression annote'e, il peut e'galement servir a` normaliser
l'expression :

108 CHAPITRE 6. DE LA VE'RIFICATION DE TYPES AUX CONTRAINTES

LEMME 6.8. Si ^R est un renommage de domaine ^V et ftv."/ t, ^V, alors [R]" est une expression
codom. ^R/-normale.

De'monstration. De'coule de la de'finition de l'application de ^R a` une expression de la forme 8V : u* . ".
Celle-ci est transforme'e en 8R.V/ : [ ^R l^ R]u* . [ ^R l^ R]" et le codomaine R.V/ est suppose' disjoint
de codom. ^R/. Pour une preuve comple`te, il suffit de proce'der par induction sur la structure de ". e^

6.9 Conclusion
De'monstration du the'ore`me 3. Nous composons maintenant l'ensemble des lemmes pour prouver le
the'ore`me et de'crire l'algorithme de re'duction.

E'tant donne'e une expression " close (sans variable ni variable de type libre), on commence par
calculer l'expression "0 D []" (l'application du renommage vide a` "). Les de'finitions du renommage
montrent que cette ope'ration est bien calculable et le lemme 6.8 que "0 est ?-normale.

On peut ensuite parcourir la structure de "0 et collecter des proble`mes de typage en consultant pour
chaque noeud de "0 la re`gle du syste`me de types syntaxique correspondante. Par exemple, si "0 est de la
forme "1 "2, on ajoute ^1 ` 8o""r' : ?1 69 o"" ! r' ^ ?2 69 o"" . r' dans la liste des proble`mes a` re'soudre.
Durant cette phase, on maintient un environnement forme' d'un contexte ^1 et d'un environnement
syntaxique 0. On se contente de maintenir cette environnement et de ge'ne'rer les proble`mes me'caniquement sans chercher a` les interpre'ter et inde'pendamment d'un mode`le. Dans la re`gle (INTROV ),
l'exigence dom. ^1/ kD V est toujours re'alise'e car "0 est normale. Quand on doit traiter un motif, on
utilise le lemme 6.4 pour assurer que les variables de type choisies comme domaine du contexte 1 j
ne posent pas de proble`mes, par exemple en demandant qu'elles soient en dehors de l'ensemble de
toutes les variables (libres ou lie'es) de "0. Finalement, on se convainc donc aise'ment qu'il est possible
de calculer a` partir de "0 de fac,on comple`tement me'canique et syntaxique une liste de proble`mes de
typage P1; . . . ; PN et un sche'ma de type ? tels que pour tout M, mode`le de la repre'sentation, la satisfiabilite' de tous ces proble`mes est e'quivalente au jugement M |H ?I ? ` "0: ? . Notons que cette
ope'ration est peut e^tre exponentielle par rapport a` la profondeur d'imbrication des let.

On montre ensuite l'e'quivalence se'mantique attendue : si dans un certain mode`le M, tous les
proble`mes PI sont satisfaits, c'est-a`-dire que M |H PI pour tout I , alors on a M |H ?I ? ` "0: ? ,
comme explique' ci-dessus. On peut donc appliquer le lemme de correction 6.3 et de'duire que ?I ? `
"0 : J? K. Puis, par le lemme 6.7 on trouve que ?I ? ` " : J? K. Inversement, si dans le mode`le M, il
existe T tel que ?I ? ` " : ? , alors par ce me^me lemme 6.7, on sait que ?I ? ` "0 : ? . L'expression
"0 e'tant normale, on peut appliquer le lemme de comple'tude 6.6 pour de'duire que ?I ? ` "0 : ? et

J? K 6] T . Dans l'application de ce lemme, on prend soin de proce'der aux me^mes choix de variables
que lors de la phase de ge'ne'ration des proble`mes, ce qui assure que le sche'ma de types produit par le
lemme est bien ? et que tous les proble`mes PI sont bien satisfaits dans M. e^

109
Chapitre 7
Discussion

Dans les chapitres pre'ce'dents, nous avons de'veloppe' une formalisation du typage polymorphe
d'un langage avec multi-me'thodes. Successivement, nous avons de'fini le langage (chapitre 1), sa se'mantique (chapitre 2), un syste`me de types purement alge'brique (chapitre 3) et la preuve de correction
associe'e (chapitre 4), un langage d'annotation de types et la spe'cification du typage des expressions
annote'es (chapitre 5) et enfin, nous avons montre' que le typage des expressions annote'es est re'ductible
a` des proble`mes de contraintes (chapitre 6).

Pour utiliser cette formalisation dans un vrai langage de programmation, de nombreux aspects du
typage devraient encore e^tre traite's. Il faudrait fixer une alge`bre particulie`re, e'tudier la re'solution des
proble`mes de contraintes, en fournir des imple'mentations efficaces, s'occuper de la simplification des
types et de l'affichage compre'hensible des erreurs de typage, etc. Cela de'passerait largement le cadre
de cette the`se et des objectifs plus modestes que nous lui avons fixe's.

Dans ce chapitre, nous allons discuter d'une manie`re plus informelle quelques uns des proble`mes
pose's par la mise en oeuvre pratique du typage. Nous montrerons e'galement comment la pre'sentation
de certains aspects essentiels du typage d'un langage a` objets profite avantageusement de l'approche
alge'brique adopte'e dans cette the`se. Nous nous inte'resserons particulie`rement au typage en << monde
ouvert >>, c'est-a`-dire quand un module est type'e inde'pendamment de l'alge`bre de types dans laquelle
l'exe'cution finit par avoir lieu.

Ce chapitre sera organise' comme suit : a` la section 7.1, nous montrerons comment la formalisation
peut e^tre mise en oeuvre concre`tement dans un langage de programmation spe'cifique. En section 7.2,
nous aborderons le proble`me du monde ouvert. En section 7.3, nous dirons quelques mots de l'infe'rence de types et des difficulte's supple'mentaires qu'elle pose par rapport a` la simple ve'rification de
types envisage'e jusqu'a` pre'sent.

Ce chapitre se terminera par la comparaison de cette the`se avec des travaux apparente's (section 7.4).

7.1 Mise en oeuvre de la formalisation

Dans chacun des chapitres pre'ce'dents, nous avons introduit des structures laisse'es ouvertes et qui
sont autant de parame`tres de la formalisation. Le tableau suivant re'capitule ces diffe'rents parame`tres :

110 CHAPITRE 7. DISCUSSION

Aspect ou syste`me Parame`tres
Syntaxe des expressions - Symboles des constantes, ope'rations et motifs primitifs
- Symboles des classes et ensemble des champs

d'une classe

Se'mantique ope'rationnelle - Valeurs des ope'rations primitives et motifs primitifs
- Relation de sous-classement

Syste`me de types alge'brique Alge`bre de types
Syntaxe des expressions annote'es Langage de types
Typage des expressions annote'es (syste`me semi-alge'brique)

Mode`le du langage de types dans l'alge`bre de types

Re'duction du typage a` des proble`mes
de contraintes

Repre'sentation syntaxique des e'le'ments de base du
typage

L'inte're^t de ces multiples parame'trages est de mettre en e'vidence, a` chaque e'tape de la formalisation, ce qui est strictement ne'cessaire. En pratique, dans un vrai langage de programmation, la de'finition du langage lui-me^me ne fixe typiquement que les parame`tres primitifs (types de base, ope'rations
primitives, etc.). Le reste des parame`tres est de'rive' des de'clarations du programmeur. La puissance
d'expression de ces de'clarations ainsi que la fac,on dont on en de'rive les parame`tres de typage de'pendent entie`rement du langage de programmation conside're' et rele`vent uniquement de la conception
de langage. Nous allons maintenant en donner un exemple simple qui montre de'ja` la grande varie'te'
de conceptions possibles et la fac,on dont notre approche peut les mode'liser. En reprenant la syntaxe
illustrative de'ja` utilise'e dans les chapitres pre'ce'dents, voici quelques exemples de de'clarations de
classes :

abstract class Couleur {

r; g; b : intI
}
abstract class ObjetColore' {

c : CouleurI
}
class Point {

x; y : intI
}
class PointColore' v Point; ObjetColore' {}

class Listho""l^i {}
class Consho""l^i v List {

head : o""I
tail : Listho""iI
}
class Nilho""l^i v List {}
class Pre'dicatho""l/i {

test : o"" ! boolI
}

L'ensemble des informations contenues dans les de'clarations de classes d'un programme sera
collectivement appele' HIE'RARCHIE DE CLASSES.

A` partir d'une hie'rarchie H, on peut de'river de fac,on e'vidente une structure de classes C, c'est-a`dire un ensemble de symboles de classes, une relation de sous-classement et un ensemble de champs

7.2. MONDE OUVERT 111
pour chaque classe. On peut e'galement de'river naturellement un langage de types L : chaque symbole
de classe C joue le ro^le d'un constructeur de type d'arite' e'gale au nombre de variables de types
qui parame`trent la classe. Par exemple List est un constructeur d'arite' 1 car cette classe accepte une
variable de type o"".

Il y a beaucoup plus de choix pour de'river l'alge`bre de types utilise'e A. Comme mentionne' au
chapitre 3, on peut choisir de travailler avec des termes finis ordonne's structurellement, avec des
termes infinis, ou bien rationnels. On peut saturer l'ordre partiel obtenu pour en faire un treillis, ou un
demi-treillis, ou bien garder l'ordre partiel arbitraire, etc.

Apre`s avoir choisir l'alge`bre de types a` utiliser, il convient de ve'rifier qu'elle permet bien de
construire un mode`le de L et des repre'sentations syntaxiques des e'le'ments de base. En pratique ce
n'est pas un proble`me car toutes ces alge`bres sont des alge`bres de termes.

Le choix de l'alge`bre de types est donc l'e'le'ment crucial. Il est important de comprendre que
chacune de ces alge`bres aboutit a` un syste`me de types a priori diffe'rent, c'est-a`-dire qu'il va rejeter
plus ou moins de programmes. Par exemple, dans l'alge`bre des termes finis structurels, la contrainte
9o"" : o"" 6 o"" ! o"" n'est pas satisfiable. En revanche, elle est satisfiable dans l'alge`bre structurelle avec
termes infinis ou re'cursifs. Elle est aussi satisfiable si l'alge`bre est un treillis (prendre o"" D ?). Par
ailleurs, les syste`mes de type issus d'alge`bres diffe'rentes auront e'galement une complexite' a priori
diffe'rente. Par exemple, conside'rons simplement le proble`me de satisfiabilite' d'une contrainte 9o"" : u*.
Dans une alge`bre treillis, ce proble`me est typiquement traitable en temps polynomial O.n3/ [Pal95].
En revanche, dans l'alge`bre des termes finis ordonne's structurellement, le proble`me est PSPACEcomplet [Tiu92, Fre97].

Au final, on se rend compte que l'un des avantages de notre approche alge'brique est qu'elle permet
de bien se'parer trois aspects du syste`mes de type : la correction, l'imple'mentation et la conception du
langage. En particulier, il est possible de faire varier l'alge`bre de types et de prouver tre`s facilement
la correction du syste`me qui en re'sulte. Cela permet de se concentrer sur la conception du langage
(quelles de'clarations offrir ? quelles programmes rejeter ?) et sur l'imple'mentation du typage (quelles
algorithmes pour re'soudre les contraintes ?).

7.2 Monde ouvert

Jusqu'a` pre'sent, nous avons fait comme si le langage e'tait un tout ferme' : une fois fixe' un ensemble
de de'clarations de classes, on peut e'crire, typer et exe'cuter une expression. En re'alite', un langage a`
objets re'aliste est ouvert, c'est-a`-dire qu'il permet d'e'crire des modules re'utilisables. En pratique, cela
signifie qu'un module peut e^tre type' et compile' dans une certaine hie'rarchie de classes, mais qu'il est
finalement exe'cute' dans une autre hie'rarchie.

Prenons l'exemple d'un module M spe'cialise' dans le traitement des points. Il est typiquement
compile' dans une hie'rarchie H1 de'finissant les classes Point et Point3D. Cependant, au moment
ou` le module est exe'cute', le programmeur a pu ajouter les classes ObjetColore', PointColore' etPoint3DColore'

pour former la hie'rarchie H2 qui est de ce fait une EXTENSION de H1.

Notons que les expressions dans le module M, les de'finitions de me'thodes par exemple, sont
syntaxiquement bien forme'es dans la structure de classes de'rive'e de la hie'rarchie H2 car celle-ci
se contente de rajouter des classes a` H1 et ne modifie pas les champs des classes existantes. Si ces
expressions sont annote'es, remarquons de me^me que les annotations restent syntaxiquement bien

112 CHAPITRE 7. DISCUSSION
forme'es quand on passe de H1 a` H2 car on a simplement de nouveaux constructeurs de type et on ne
touche pas a` l'arite' des constructeurs existants.

Du point de vue de l'exe'cution, on remarque que la se'mantique ope'rationnelle de ces expressions
est plus ge'ne'rale dans H2 que dans H1 car elles peuvent traiter des objets construits avec des classes
inconnues de H1, ce qui est bien le but recherche' du << polymorphisme a` objets >>.

Qu'en est-il du typage ? Si M est bien type' dans H1, il est en ge'ne'ral faux qu'il soit e'galement
bien type' dans H2. Par exemple, plac,ons-nous dans l'alge`bre des termes finis structurels et supposons
que le typage de M selon l'algorithme du chapitre 6 produise entre autres le proble`me d'implication
suivant :

8o"" . o"" 6 Point3D ? Point3D 6 o""
Dans le mode`le M1 de'rive' de H1, cette implication de contrainte est vraie, parce que Point3D n'a
pas de sous-type strict et donc la seule solution de la contrainte de gauche est o"" 7! Point3D. En
revanche, dans le mode`le M2 de'rive' de H2, l'implication n'est plus vraie car o"" peut prendre la valeurPoint3DColore'

qui est bien un sous-type de Point3D mais n'en est pas un super-type.

Il semble donc qu'il ne soit pas possible de typer le module M sans savoir dans quelle hie'rarchie il
va e^tre exe'cute'. Cela va a` l'encontre d'un principe de la programmation modulaire et de la compilation
se'pare'e qui voudrait qu'on puisse toujours typer un module inde'pendamment de son utilisation.

Pour traiter ce << typage ouvert >> ou typage en << monde ouvert >>, remarquons d'abord que notre
approche alge'brique fournit un moyen tre`s simple pour exprimer le re'sultat attendu. Pour typer un
module M e'crit dans une hie'rarchie H1, on commence par extraire une liste de proble`mes de typage

P1; . . . ; PN selon l'algorithme du chapitre 6. Il suffit alors de re'soudre les proble`mes Pi simultane'ment
dans toutes les extensions de H1.

Pre'cisons maintenant ce qu'on entend exactement par extension. Pour que H2 e'tende H1, un
certain nombre de conditions sont ne'cessaires : H2 peut ajouter des classes, mais ne doit pas modifier
le caracte`re concret ou abstrait d'une classe existant. Elle ne doit pas non plus modifier les relations
de sous-classement existantes. Elle ne peut ajouter des champs a` des classes existantes, ni modifier
leur type.

En pratique, ces conditions sont ne'cessaires mais elles sont souvent trop ge'ne'rales pour mode'liser
les extensions qui sont effectivement exprimables dans un langage de programmation donne'. Les
extensions exprimables peuvent e^tre limite'es par la forme syntaxique des de'clarations de classes. Par
exemple, dans la syntaxe sugge're'e ci-dessus, on peut rajouter des classes uniquement par le bas.
C'est-a`-dire qu'une nouvelle classe ne peut e^tre rajoute'e comme super-classe d'une classe existante.
Dans d'autres syntaxes et donc dans d'autres langages, l'extension par le haut peut e^tre autorise'e. Par
exemple, si on introduit la classe abstraite Copiable des objets copiables, c'est-a`-dire qui peuvent
e^tre passe's a` une me'thode copy, alors on peut vouloir autoriser apre`s coup la classe Point a` e^tre une
sous-classe de Copiable.1

De la me^me fac,on que le choix de l'alge`bre de types conditionne le syste`me de typage ferme'
obtenu, on peut remarquer que le choix de la notion d'extension de hie'rarchie de'termine e'galement la
puissance du syste`me ouvert qu'on peut en de'river. Par exemple, conside'rons le proble`me d'implica1Un langage qui autoriserait cette possibilite' devrait probablement pre'voir de la restreindre aux classes comme Copiable
qui n'ont pas de champs.

7.3. INFE'RENCE DE TYPES 113
tion suivant :

8o"" . Point 6 o"" ? o"" 6 Point
Ce proble`me est faux quand la relation d'extension de hie'rarchie n'est pas limite'e. En effet, il suffit de
conside'rer une hie'rarchie H2 qui ajoute une super-classe a` Point, par exemple la classe Objet. Dans
H2, il est bien clair que Point n'est plus une classe maximale de sorte que que l'implication n'est
pas vrai dans toutes les hie'rarchies qui e'tendent H1. Le syste`me de typage ouvert va donc rejeter un
module qui ge'ne`rerait cette implication. Cependant, si le langage de programmation restreint la forme
des de'clarations de classe et n'autorise que les extensions par le bas, alors H2 n'est pas une extension
de H1. De plus, il est clair qu'une extension par le bas va toujours pre'server la maximalite' de Point,
de sorte que, dans un tel langage, l'implication est en fait vraie dans toutes les extensions. Ainsi, il
convient d'accepter un programme qui ge'ne`re cette implication.

Au final, l'approche alge'brique fournit donc un outil pour la formalisation fine du monde ouvert
mais n'impose rien quant au choix pre'cis de la relation d'extension, de la me^me fac,on que l'alge`bre
de types n'est pas impose'e. Encore une fois, ces choix rele`vent de la conception du langage de programmation et de l'e'quilibre entre la puissance du syste`me de typage et son caracte`re pratique.

7.3 Infe'rence de types

Dans cette the`se, nous avons seulement aborde' le typage du point de vue de la ve'rification de
types (<< type-checking >>), c'est-a`-dire quand le programmeur doit indiquer au compilateur le type des
variables et des parame`tres des fonctions.

Dans les langages fonctionnels comme ML, certaines de ces de'clarations peuvent e^tre omises par
le programmeur et le syste`me se charger d'infe'rer le type des variables (<< type inference >>). Notons
toutefois que certaines de'clarations de type doivent toujours e^tre entre'es par le programmeur comme
par exemple le type des e'le'ments publics d'un module (sa << signature >>) ou bien le contenu des
alternatives d'un type concret.

Dans un langage avec sous-typage et ordre supe'rieur, les types des variables peuvent devenir particulie`rement complique's a` exprimer. Il semble donc indispensable de fournir une forme d'infe'rence,
au moins pour les variables locales. Voyons comment l'infe'rence pourrait e^tre inte'gre'e a` notre formalisation et les proble`mes que cela pose.

Conforme'ment a` notre de'marche, nous allons se'parer la spe'cification de l'infe'rence de types de
son imple'mentation avec des contraintes. Nous proposons d'ajouter la production suivante dans la
grammaire des expressions annote'es :

" ::D . . .

| 9V : u* . " (Introduction de variables infe're'es)

Dans cette expression, V repre'sente un ensemble de variables dont le syste`me de types doit trouver
une valeur compatible avec la contrainte u* et avec l'expression ". La re`gle de typage associe'e est
simplement :

dom.!/ D V ^!l^!Ju*K ^! l^ !I G ` " : T

^!I G ` .9V : u* . "/ : T

114 CHAPITRE 7. DISCUSSION

Par exemple, la fonction 9o"" : vrai . .fun x : o"" ) x C 1/ est bien type'e car on peut prendre
o"" D float ou o"" D int. Par contraste, notons que 8o"" : vrai . .fun x : o"" ) x C 1/ n'est pas bien
type'e car il n'est pas vrai que fun x : o"" ) x C 1 soit bien type'e pour tout o"" (contrexemple :
o"" D Point). Le programmeur donc est force' d'expliciter les valeurs possibles de o"" par exemple en
e'crivant 8o"" : o"" 6 float . .fun x : o"" ) x C 1/.

La spe'cification de l'infe'rence ne pose donc pas de proble`me particulier et s'inte`gre bien dans
notre formalisation. En revanche, la re'duction de l'infe'rence aux contraintes est proble'matique. La
difficulte' provient de la pre'sence d'une alternance entre des quantificateurs universels (annotations
polymorphes sur les de'finitions re'cursives et sur les me'thodes) et existentiels (infe'rence de type des
parame`tres de fonction). Dans le cas ge'ne'ral, nous allons maintenant montrer qu'il est ne'cessaire
d'avoir un langage de contraintes plus riche, autorisant des quantificateurs universels. Les proble`mes
de contraintes obtenus sont alors plus complexes (formules .89/* pluto^t que 89).

Pour faire comprendre la ne'cessite' de contraintes riches, examinons un exemple d'infe'rence ou` le
type principal d'une expression ne peut pas e^tre exprime' avec les contraintes simples. Plac,ons-nous
par exemple dans une structure contenant les classes A et B et conside'rons l'expression suivante :

" D 9o"" : vrai.fun x : o"" ) .fix y : ? ) x// ou` ? D 8r' : A 6 r' ^ B 6 r' . r'
La de'finition re'cursive a ici pour effet d'imposer une contrainte polymorphe sur la variable a` infe'rer
o"". Dans le cas ge'ne'ral, ceci n'est pas exprimable par une contrainte simple. Conside'rons en effet une
alge`bre structurelle atomique construite sur un ordre partiel de base ou` A et B posse`de deux supertypes communs incomparables c et d :

c d
A B
Notons bien que c et d sont des monotypes alge'briques qui ne sont pas directement repre'sentables par
un monotype syntaxique. Cette situation peut typiquement survenir quand on se place dans un monde
ouvert et si c et d sont des classes de'finies dans une extension de la hie'rarchie courante.

Dans cette alge`bre, remarquons d'abord que l'expression " est bien type'e. Le polytype ? de'note
en effet l'ensemble des super-types communs a` A et B, c'est-a`-dire l'ensemble {c; d}. Les monotypes
qui sont des sous-types de ? sont donc uniquement A et B. On ve'rifie alors que [o"" 7! A] et [o"" 7! B]
sont bien les solutions possibles pour le typage de " et les types de " en re'sultant sont donc l'ensemble
des t ! u ou` t vaut A ou B et u vaut c ou d. Nous allons maintenant montrer qu'il n'existe pas de
sche'ma de types de'crivant exactement cet ensemble.

De'monstration. Supposons qu'il existe un sche'ma tel que :

J8V : u* . # K D {t ! u | t 2 {A; B}; u 2 {c; d}}
Conside'rons alors le contexte 1 D {V; o""; r' : u* ^# D o"" ! r'}. On constate que l'ensemble des monotypes !.o""/ quand ! parcourt l'interpre'tation J1K est exactement e'gal a` {A; B}. Montrons maintenant
que cela est impossible quel que soit le contexte 1.

Conside'rons donc un contexte quelconque 1 D {o""1; . . . ; o""n : u*}. Sans perte de ge'ne'ralite', nous
supposons que u* ne contient pas de quantificateur existentiel, ce qui est toujours possible en faissant
passer les variables en te^te. Enfin, nous supposons que u* ne contient que des contraintes entre termes
atomiques, c'est-a`-dire entre une variable o""i et les deux constantes A et B. Comme nous travaillons

7.3. INFE'RENCE DE TYPES 115
dans une alge`bre structurelle atomique, cela est toujours possible en de'composant les contraintes entre
termes.

Conside'rons maintenant l'ope'rateur binaire . de'fini sur l'alge`bre comme suit :

A . A D A
B . B D B

t . u D c dans tous les autres cas

Notons que l'ope'rateur . satisfait a` la proprie'te' suivante :

t 6 u ^ t0 6 u0 ) t . t0 6 u . u0
Par induction sur la structure de u*, on en de'duit que pour toute paire de solutions !; !0 2 J1K, on a
aussi ! . !0 2 J1K.

S'il existe une solution de ! telle que !.o""i / D A et une autre telle que !0.o""i / D B, alors ! . !0
est aussi une solution dans J1K. Mais, comme ! . !0.o""i / D A . B D c. il est donc impossible que
!.o""i / parcoure exactement l'ensemble {A; B}. e^

Les contraintes du chapitre 5 sont donc trop faibles pour traiter l'infe'rence de type et exprimer le
type principal d'une expression. Pour traiter l'infe'rence dans toute sa ge'ne'ralite', il faudrait essentiellement pouvoir exprimer des ine'galite's entre sche'mas dans les contraintes. Le type principal infe're'
pour " serait alors de la forme :

8o""; r' : {o"" 6 .8r' : A 6 r' ^ B 6 r' . r'/ ^ A 6 r' ^ B 6 r'} . o"" ! r'
Nous pensons qu'en utilisant ce genre de contraintes e'tendues, il doit e^tre possible de transposer
assez facilement la preuve du chapitre 6 pour re'duire l'infe'rence de types, et non plus seulement la
ve'rification, aux contraintes.

Toutefois, la re'solution des contraintes e'tendues est a priori plus difficile que celle des contraintes
simples. Notons cependant que les contraintes les plus ge'ne'rales ne sont ne'cessaires que si on autorise une de'finition re'cursive polymorphe ou une me'thode a` figurer sous un fun. Pour simplifier le
proble`me, on peut donc e'galement envisager de n'autoriser ces expressions polymorphes qu'au niveau le plus haut du programme. On est alors ramene' a` des proble`mes d'implications de contraintes
simples. Enfin, si on interdit comple`tement les de'finitions re'cursives polymorphes et les me'thodes, on
peut alors ve'rifier que les proble`mes qu'on obtient sont uniquement des proble`mes de satisfiabilite'.
Cette situation correspond au langage ML de base (core-ML) avec sous-typage et on retrouve alors
le re'sultat bien connu que le typage de ce langage est simplement e'quivalent a` la satisfiabilite' d'une
contrainte de sous-typage.

Pour terminer, le tableau suivant re'sume la complexite' logique des proble`mes de typage obtenus
pour les diffe'rents sous-langages envisage's :

Langage Typage Proble`mes a` re'soudre Complexite' logique
core-ML infe'rence satisfiabilite' 9
me'thodes et fix a` toplevel infe'rence implications 89
me'thodes et fix profonds ve'rification implications 89
me'thodes et fix profonds infe'rence formules quelconques .89/*

116 CHAPITRE 7. DISCUSSION
7.4 Travaux apparente's

Ce travail de the`se simplifie et ge'ne'ralise le syste`me ML6 [BM96, BM97]. La simplification porte
d'abord sur la se'mantique ope'rationnelle qui est type'e et tre`s non-standard dans [BM96], alors qu'elle
est non-type'e et par re'duction chez nous. Nous introduisons e'galement le filtrage profond a` la ML et
non pas seulement le dispatch superficiel. Notre pre'sentation du typage est syste'matique, modulaire
et conc,ue pour e^tre extensible alors que celle de [BM96] s'est re've'le'e fige'e et ses preuves difficiles
a` lire et a` e'tendre. L'implication de contrainte dans [BM96] est base'e sur une desription de nature
algorithmique (axiomatisation comple`te), alors que notre approche alge'brique permet de bien se'parer
la correction du typage de la re'solution des contraintes. En revanche, notre travail n'aborde pas du tout
la question de la re'solution des proble`mes de typage pour lesquels [BM96] fournit des algorithmes.

Bonniot [Bon02a] a e'galement utilise' une approche alge'brique et modulaire pour typer ML6,
ce qui lui permet de se'parer la preuve de correction et son instantiation sur une alge`bre concre`te.
Le langage utilise' est moins riche : le filtrage profond, les me'thodes imbrique'es ou les e'le'ments
primitifs ne sont pas traite's. Par ailleurs, la notion d'alge`bre dans [Bon02a] est tre`s proche du langage
source. Une alge`bre doit notamment de'finir une ope'ration de substitution qui est une abstraction de la
substitution ope'rationnelle et qui fait intervenir les variables du programme. La preuve de correction
du typage s'en trouve simplifie'e mais, en plac,ant le niveau d'abstraction aussi haut, une grande partie
du typage doit e^tre traite' au coup par coup dans les alge`bres spe'cifiques. Notre formalisation est un
peu moins ge'ne'rale, mais a l'avantage de traiter de fac,on ge'ne'rique une plus grande partie du typage,
les contraintes par exemple. La forme #C des motifs a e'te' introduite dans [Bon02a].

Dans un autre article, Bonniot [Bon02b] a e'galement de'crit une extension de ML6 avec des
<< kinds >> qui permettent d'e'crire des contraintes particulie`rement expressives pour traiter des me'thodes partiellement polymorphes. Nous pensons que cette extension devrait s'inte'grer parfaitement
dans le cadre de cette the`se. En particulier, les kinds pourraient e^tre code'es en utilisant les pre'dicats
du langage de types. De manie`re ge'ne'rale, toutes les extensions du typage de ML base'es sur des types
contraints avec des pre'dicats (par exemple les type classes [WB89]) devraient pouvoir utiliser notre
pre'sentation tre`s facilement.

Le syste`me HM(X) introduit par Sulzmann et al. [SOW96, Sul00] est actuellement le << standard >> en matie`re de typage modulaire. La pre'sntation du typage y est parame'tre'e par un syste`me de
contraintes X, qui correspond grosso modo dans notre formalisation a` la donne'e d'un langage de type
et d'un mode`le. Moyennant quelques hypothe`ses sur X, la preuve de correction de typage peut e^tre
rendue ge'ne'rique. Notre travail se distingue de HM(X) par plusieurs aspects. D'abord, nous traitons
un langage conside'rablement plus riche, avec des multi-me'thodes, des de'finitions re'cursives polymorphes ainsi que des e'le'ments primitifs. Ensuite, la pre'sentation de HM(X) reste tre`s syntaxique :
les re`gles de typage correspondent essentiellement a` l'algorithme utilise' au chapitre 6. Notre pre'sentation a l'avantage de permettre l'e'criture d'une spe'cification du typage qui n'utilise pas les contraintes.
Les re`gles de typage alge'briques (chapitre 3) ou semi-alge'brique dans le cas ou` les expressions sont
annote'es (chapitre 5) sont alors bien plus simples a` lire et la preuve de correction s'en trouve facilite'e. Les contraintes ne sont introduites que lors de l'imple'mentation de la spe'cification et le syste`me
qui en re'sulte (chapitre 6) n'apparai^t que comme un interme'diaire de preuve. Les re`gles de ce syste`me ne sont pas choisies arbitrairement mais construites pour que le syste`me syntaxique corresponde
exactement a` la spe'cification.

L'utilisation d'un syste`me purement alge'brique pour prouver la correction d'un syste`me syntaxique a` base de contraintes a e'te' esquisse'e par Pottier [Pot01] dans un travail qui s'inspire d'une

7.4. TRAVAUX APPARENTE'S 117
version pre'liminaire de cette the`se. Cependant, ce passage n'est utilise' que comme une technique
facilitant la preuve de correction du syste`me syntaxique HM(X) en le re'e'crivant dans un syste`me
purement alge'brique. Dans notre the`se, cette technique est conside'rablement e'tendue de sorte que le
syste`me alge'brique (plus pre'cise'ment semi-alge'brique) forme une spe'cification du typage et que le
syste`me syntaxique en constitue une imple'mentation correcte et comple`te et pas seulement correcte.
Ainsi, l'approche alge'brique peut permettre de guider la construction du syste`me syntaxique.

Pottier et Simonet [SP03] ont e'tudie' le filtrage profond dans un langage a` la ML avec sous-typage
et ont remarque' que les contraintes simples sont insuffisantes. Leurs contraintes << garde'es >> sont
similaires aux contraintes e'tendues que nous avons de'crites a` la section 7.3.

Castagna, Ghelli et Longo [CGL92, Cas97] ont e'tudie' une extension du y"-calcul simplement
type' avec des multi-me'thodes ou` les me'thodes sont des fonctions de premie`re classe composables
avec un ope'rateur &. Ce travail a inaugure' une approche nouvelle des objets qui se de'marquait de
la vision << objets=enregistrements extensibles >>. Plus re'cemment, le langage CDuce [BCF03] s'est
inspire' de ce y"&-calcul pour autoriser les fonctions surcharge'es. Le typage de celles-ci demandent au
programmeur de comple`tement spe'cifier le type de la fonction sous la forme d'un ensemble explicite
de types fonctionnels syntaxiques, c'est-a`-dire en extension. Un avantage de ML6, et donc aussi du
syste`me que nous pre'sentons dans cette the`se, est qu'on peut donner le type d'une fonction surcharge'e
en compre'hension, c'est-a`-dire sous la forme d'une sche'ma de types contraint, ce qui permet de passer
plus commode'ment a` un monde ouvert.

Le langage Cecil [Ct02, CL95] est un langage de recherche avec multi-me'thodes suffisamment
stable pour permettre d'e'crire son propre compilateur. Cecil fournit un syste`me de ve'rification de type
monomorphe de'cidable [CL95] et un autre syste`me polymorphe avec infe'rence [Lit98] base' sur le
syste`me F et dont la de'cidabilite' est inconnue. Dans l'ensemble, ces syste`mes de type s'e'loignent du
typage a` la Hindley-Milner auquel nous nous re'fe'rons dans cette the`se.

Finalement, on ne peut pas ne pas mentionner le langage OCAML [LDGC03], seule extension de
ML avec objets actuellement re'ellement de'ploye'e. L'infe'rence des types y est tre`s efficace car elle
est base'e sur de l'unification et les variables de range'e. Certaines coercions de sous-typage doivent
alors e^tre exprime'es explicitement par le programmeur. En pratique, ce compromis donne de tre`s
bons re'sultats. Cependant, OCAML souffre des inconve'nients du mode`le a` enregistrements (me'thodes
binaires notamment). Par ailleurs, le langage OCAML ne fournit pas de sous-typage primitif, commeint

6 float, ce qui oblige d'avoir deux jeux d'ope'rateurs mathe'matiques et limite le polymorphisme
des fonctions arithme'tiques. Il serait inte'ressant d'e'tudier l'inte'gration d'un syste`me avec sous-typage
utilisant les techniques de cette the`se avec le syste`me a` objets de OCAML.

118 CHAPITRE 7. DISCUSSION119
Conclusions

Ce travail est issu de l'imple'mentation dans le langage Jazz du syste`me de types ML6. Celui-ci
pre'sentait des limitations ge^nantes : absence d'infe'rence, langage de contraintes rigide, pre'sentation
non-standard et peu extensible. Lors de la phase de conception de Jazz et plus encore lorsque le langage commenc,a a` e^tre utilise', de nombreuses ide'es d'extension surgirent, mais il manquait clairement
un outil the'orique permettant de les valider rapidement.

Dans cette the`se, nous avons pre'sente' une formalisation ge'ne'rique du typage. A` la manie`re de
HM(X), le syste`me de types y est parame'tre' par une alge`bre de types, et, moyennant des hypothe`ses
minimales sur cette alge`bre, la correction du typage peut e^tre prouve'e une fois pour toutes. Cette
ge'ne'ralite' n'est pas gratuite : notre expe'rience de Jazz nous a convaincu qu'une telle approche ge'ne'rique est indispensable pour un langage en de'veloppement, particulie`rement quand le typage est riche
(polymorphisme, sous-typage) et le langage complexe (multi-me'thodes, objets).

Un aspect original de la formalisation est le traitement extensionnel du polymorphisme : dans
la spe'cification du typage, un type polymorphe est simplement un ensemble quelconque de types
monomorphes. Les sche'mas de type et les contraintes ne sont introduits que lors de l'imple'mentation,
celle-ci consistant en une re'duction du typage a` des proble`mes de contraintes. La correction globale
du typage de'coule alors de deux preuves inde'pendantes : 1) correction de la spe'cification par rapport
a` la se'mantique ope'rationnelle et 2) correction de l'imple'mentation par rapport a` la spe'cification.

Cette se'paration est d'autant plus utile que l'imple'mentation est e'galement prouve'e comple`te par
rapport a` la spe'cification. On peut donc conside'rer que seule la spe'cification de'finit vraiment le syste`me de types. Contrairement aux pre'sentations habituelles des syste`mes de type avec contraintes, les
re`gles syntaxiques ne constituent pas la de'finition du syste`me, mais sont un simple interme'diaire dans
son imple'mentation. Or ces re`gles sont bien plus complique'es que la spe'cification car elles travaillent
exclusivement au niveau de la syntaxe sur les contraintes, variables de types et sche'mas et doivent
donc prendre en compte de nombreux de'tails syntaxiques. Notre approche contribue donc a` simplifier
conside'rablement la preuve de correction du typage et assure que les re`gles syntaxiques ne sont pas
par me'garde arbitrairement restrictives, ce qui repre'sente une << se'curite' the'orique >> appre'ciable pour
un langage aussi riche et complexe.

Dans cette the`se, nous n'avons pas du tout aborde' la re'solution concre`te des proble`mes de contraintes obtenus. Celle-ci de'pend en effet du domaine d'interpre'tation et de la forme des contraintes,
deux parame`tres spe'cifiques qui de'finissent le syste`me de types. De plus, il existe aujourd'hui une
vaste litte'rature sur la re'solution des contraintes de typage.

Cependant, nous avons esquisse' une mode'lisation originale du monde ouvert selon laquelle pour
typer un programme dans un monde ouvert, il suffit d'extraire les proble`mes de contraintes associe's
et de les re'soudre simultane'ment dans toutes les extensions futures du monde pre'sent. Au me^me titre

120 CONCLUSIONS
que l'alge`bre de types, la notion d'extension est ici elle-me^me un parame`tre du syste`me de types qui
de'pend du langage de programmation concret conside're'.

En soi, cette mode'lisation du monde ouvert ne permet naturellement pas de progresser dans la
re'solution du typage mais elle fournit une formulation simple et claire du proble`me. Alors que de tre`s
nombreux travaux ont e'te' consacre's aux contraintes de typage, on s'aperc,oit que, sauf exception, il
s'agit toujours de la re'solution de certaines formes de contraintes dans une structure d'interpre'tation
fixe'e. Il serait donc inte'ressant de reconside'rer ce corpus de re'sultats quand on doit traiter un proble`me
de contraintes simultane'ment dans tous les mode`les d'interpre'tation issus d'une relation d'extension
donne'e.

121
Bibliographie
[AC93] Roberto M. AMADIO et Luca CARDELLI : Subtyping recursive types. ACM Transactions

on Programming Languages and Systems, 15(4):575-631, septembre 1993.

[Bar84] Hendrik Pieter BARENDREGT : The Lambda Calculus - Its Syntax and Semantics, volume 103 de Studies in Logic and the Foundations of Mathematics. North-Holland, 1984.

[BCCC95] Kim B. BRUCE, Luca CARDELLI, Giuseppe CASTAGNA, Jonathan EIFRIG, Scott F.

SMITH, Valery TRIFONOV, Gary T. LEAVENS et Benjamin C. PIERCE : On binary
methods. Theory and Practice of Object Systems, 1(3):221-242, 1995.

[BCF03] Ve'ronique BENZAKEN, Giuseppe CASTAGNA et Alain FRISCH : Cduce : an xml-centric

general-purpose language. Dans Proceedings of the eighth ACM SIGPLAN international
conference on Functional programming, pages 51-63. ACM Press, 2003.

[Ber78] G. BERRY : Stable models of typed lambda-calculi. Automata, Languages and Programming, Fifth Colloquium, Udine, pages 72-89, 1978. Lecture Notes in Computer Science
62.

[BM96] Franc,ois BOURDONCLE et Stephan MERZ : On the integration of functional programming, class-based object-oriented programming, and multi-methods. Research Report 26, Centre de Mathe'matiques Applique'es, Ecole des Mines de Paris, Paris, mars
1996.

[BM97] Franc,ois BOURDONCLE et Stephan MERZ : Type checking higher-order polymorphic

multi-methods. Dans Conference Record of the 24th Annual ACM Symposium on Principles of Programming Languages, pages 302-315, Paris, janvier 1997. ACM.

[Bon02a] Daniel BONNIOT : Type-checking multi-methods in ML (a modular approach). Dans The

Ninth International Workshop on Foundations of Object-Oriented Languages, FOOL 9,
Portland, Oregon, USA, janvier 2002.

[Bon02b] Daniel BONNIOT : Using kinds to type partially polymorphic multi-methods. Dans

Workshop on Types in Programming (TIP'02), Dagstuhl, Germany, juillet 2002.

[BVB94] Franc,ois BOURDONCLE, Jean VUILLEMIN et Ge'rard BERRY : The 2z reference manual,

1994.

[Cas97] Giuseppe CASTAGNA : Object-Oriented Programming : A Unified Foundation. Progress

in Theoretical Computer Science Series. Birka"user, Boston, 1997.

[CDT01] The Coq Development TEAM : The Coq Proof Assistant Reference Manual Version 7.2.

INRIA-Rocquencourt, December 2001.
http ://coq.inria.fr/doc-eng.html.

[CGL92] Giuseppe CASTAGNA, Giorgio GHELLI et Giuseppe LONGO : A calculus for overloaded functions with subtyping. Dans Proceedings of the ACM Conference on Lisp and
Functional Programming, volume 5, pages 182-192, 1992.

122 BIBLIOGRAPHIE
[CL95] Craig CHAMBERS et Gary T. LEAVENS : Typechecking and modules for multimethods.

ACM Transactions on Programming Languages and Systems, 17(6):805-843, novembre
1995.

[CP90] T. COQUAND et C. PAULIN : Inductively defined types. Dans Proceedings of the international conference on Computer logic, pages 50-66. Springer-Verlag New York, Inc.,
1990.

[Ct02] Craig CHAMBERS et THE CECIL GROUP : The cecil language : Specification & rationale, version 3.1, 2002.

[FBBC] Alexandre FREY, Ge'rard BERRY, Patrice BERTIN, Franc,ois BOURDONCLE et Jean

VUILLEMIN : The jazz home page. http://www.exalead.com/jazz/.

[FM88] You-Chin FUH et Prateek MISHRA : Type inference with subtypes. Dans H. GANZINGER, e'diteur : Proceedings of the European Symposium on Programming, volume 300
de Lecture Notes in Computer Science, pages 94-114. Springer Verlag, 1988.

[FM89] You-Chin FUH et Prateek MISHRA : Polymorphic subtype inference : Closing the

theory-practice gap. Dans J. DI'AZ et F. OREJAS, e'diteurs : Proceedings of the International Joint Conference on Theory and Practice of Software Development : Vol. 2,
pages 167-183. LNCS 352. Springer, mars 1989.

[Fre97] Alexandre FREY : Satisfying subtype inequalities in polynomial space. Dans Pascal Van

HENTENRYCK, e'diteur : Proceedings of the Forth International Symposium on Static
Analysis (SAS'97), nume'ro 1302 dans Lecture Notes in Computer Science, pages 265-
277, Paris, France, septembre 1997. Springer Verlag.

[GJSB00] James GOSLING, Bill JOY, Guy STEELE et Gilad BRACHA : The Java Language Specification Second Edition. Addison-Wesley, Boston, Mass., 2000.

[Hin69] J. R. HINDLEY : The principal type-scheme of an object in combinatory logic. Trans.

American Math. Soc, 146:29-60, 1969.

[KR03] Viktor KUNCAK et Martin RINARD : On the theory of structural subtyping. Rapport

technique 879, MIT Laboratory for Computer Science, janvier 2003.

[KTU93] A. J. KFOURY, J. TIURYN et P. URZYCZYN : Type reconstruction in the presence of

polymorphic recursion. ACM Transactions on Programming Languages and Systems,
15(2):290-311, avril 1993.

[LDGC03] Xavier LEROY, Damien DOLIGEZ, Jacques GARRIGUE, Didier RE'MY et Je'ro^me

VOUILLON : The Objective Caml system, release 3.07. INRIA, September 2003.

[Lit98] Vassily LITVINOV : Contraint-based polymorphism in cecil : towards a practical and

static type system. Dans Proceedings of the 13th ACM SIGPLAN conference on Objectoriented programming, systems, languages, and applications, pages 388-411. ACM
Press, 1998.

[Mar94] Luc MARANGET : Two techniques for compiling lazy pattern matching. Rapport technique 2385, INRIA, 1994.

[Mey92] Bertrand MEYER : Eiffel : the language. Prentice-Hall, Inc., 1992.
[Mil78] Robin MILNER : A theory of type polymorphism in programming. Journal of Computer

and System Sciences, 17(3):348-375, de'cembre 1978.

[Mit84] J. MITCHELL : Coercion and type inference (summary). Dans Conference Record of

the Eleventh Annual ACM Symposium on Principles of Programming Languages, pages
175-185. ACM, ACM, janvier 1984.

BIBLIOGRAPHIE 123
[MTHM97] Robin MILNER, Mads TOFTE, Robert HARPER et David MACQUEEN : The Definition

of Standard ML (Revised). MIT Press, 1997.

[Pae93] Andreas PAEPCKE, e'diteur. Object-Oriented Programming : The CLOS Perspective.

MIT Press, 1993.

[Pal95] Jens PALSBERG : Efficient inference of object types. Information and Computation,

123(2):198-209, 1995.

[Pot98] Francois POTTIER : Synthe`se de types en pre'sence de sous-typage : de la the'orie a` la

pratique. The`se de doctorat, Universite' Paris VII, juillet 1998.

[Pot01] Franc,ois POTTIER : A semi-syntactic soundness proof for HM.X/. Research Report

4150, INRIA, mars 2001.

[Re'm94] Didier RE'MY : Programming objects with ML-ART : An extension to ML with abstract

and record types. Dans International Symposium on Theoretical Aspects of Computer
Software (TACS), pages 321-346. Springer Verlag, avril 1994.

[Sha96] Andrew SHALIT : The Dylan reference manual : the definitive guide to the new objectoriented dynamic language. Addison Wesley Longman Publishing Co., Inc., 1996.

[Sim03] Vincent SIMONET : Type inference with structural subtyping : A faithful formalization of an efficient constraint solver. Dans Atsushi OHORI, e'diteur : Proceedings of the
Asian Symposium on Programming Languages and Systems (APLAS'03), volume 2895
de Lecture Notes in Computer Science, pages 283-302, Beijing, China, novembre 2003.
Springer-Verlag. cr^Springer-Verlag.

[SOW96] Martin SULZMANN, Martin ODERSKY et Martin WEHR : Type inference with

constrained types. Technical Report iratr-1996-28, Universita"t Karlsruhe, Institut fu"r
Programmstrukturen und Datenorganisation, 1996.

[SP03] Vincent SIMONET et Franc,ois POTTIER : Constraint-based type inference for guarded

algebraic data types. Submitted for publication, juillet 2003.

[Ste90] Guy L. STEELE JR. : Common Lisp : The Language (second edition). Digital Press,

1990.

[Str67] Christopher STRACHEY : Fundamental Concepts in Programming Languages. Dans Lecture Notes for International Summer School in Computer Programming. Copenhague,
August 1967.

[Str91] B. STROUSTRUP : The C++ Programming Language. Addison-Wesley, Reading, Massachusetts, USA, 1991.

[Str00] Christopher STRACHEY : Fundamental concepts in programming languages. HigherOrder and Symbolic Computation, 13(1-2):11-49, 2000. First print of an unpublished
manuscript written 1967.

[Sul00] Martin SULZMANN : A General Framework for Hindley/Milner Type Systems with

Constraints. The`se de doctorat, Yale University, Department of Computer Science, May
2000.

[Tiu92] Jerzy TIURYN : Subtype inequalities. Dans Proceedings, Seventh Annual IEEE Symposium on Logic in Computer Science, pages 308-315, Santa Cruz, California, 22-25 juin
1992. IEEE Computer Society Press.

[TS96] Valery TRIFONOV et Scott SMITH : Subtyping constrained types. Dans Static Analysis

Symposium (SAS), volume 1145 de Lecture Notes in Computer Science, pages 349-365.
Springer Verlag, septembre 1996.

124 BIBLIOGRAPHIE
[Ver01] IEEE 1364 Verilog Language Reference Manual (LRM). 2001.
[VHD93] IEEE 1164 Standard VHDL Langage Reference Manual. 1993.
[Vui94] Jean E. VUILLEMIN : On circuits and numbers. IEEE Transactions on Computers,

43(8):868-879, Aug 1994.

[WB89] P. WADLER et S. BLOTT : How to make ad-hoc polymorphism less ad-hoc. Dans

Conference Record of the 16th Annual ACM Symposium on Principles of Programming
Languages, pages 60-76. ACM, janvier 1989.

[WM02] Lyndon WHILE et Greg MILDENHALL : An implementation of parallel pattern-matching

via concurrent haskell. Dans Michael J. OUDSHOORN, e'diteur : Twenty-Fifth Australasian Computer Science Conference (ACSC2002), Melbourne, Australia, 2002. ACS.

Re'sume'

Les langages a` objets offrent une forme particulie`re de polymorphisme en permettant l'e'criture de
<< me'thodes >> dont l'exe'cution de'pend du type dynamique des arguments. Ce << dispatch dynamique >>
ne prend ge'ne'ralement en compte qu'un argument unique. Certains langages permettent le dispatch
simultane' sur tous les arguments et on parle alors de << multi-me'thodes >>.

Cette the`se s'inte'resse a` la de'finition et au typage d'un langage de'rivant de ML avec multime'thodes. Celles-ci sont introduites comme un cas particulier de filtrage sur les objets.

La pre'sentation du syste`me de types utilise une approche alge'brique. Pluto^t que de figer l'ensemble des types, on en axiomatise les proprie'te's ne'cessaires pour la correction du syste`me. Cela
permet d'e'crire des preuves ge'ne'riques qui ne de'pendent pas du choix de l'alge`bre. On montre ainsi
comment re'duire la ve'rification automatique du typage a` la re'solution de proble`mes simples du premier ordre (contraintes). La re'solution des proble`mes de contraintes peut alors re'utiliser le corpus de
re'sultats disponibles dans la litte'rature.

L'avantage de cette approche alge'brique est qu'elle permet de traiter d'un coup toute une classe
de langages possibles se distinguant par la nature de l'alge`bre de types, du langage d'expression des
contraintes et du mode`le d'interpre'tation de ces contraintes. Elle offre e'galement un outil inte'ressant
pour e'tudier le typage dans un contexte ou` le monde d'interpre'tation est ouvert, c'est-a`-dire quand on
souhaite que le typage d'un module apporte une garantie pour toutes les utilisations possibles de ce
module.

Mots-cle's

Syste`me de types, multi-me'thodes, sous-typage, objets, ML, contraintes, alge`bre, monde ouvert.

Abstract

Object-oriented langages enjoy a particular form of polymorphism by providing "methods" whose
execution depends on the dynamic type of its arguments. Generally, this "dynamic dispatch" only
takes into account a single argument. However, some langages feature a simultaneous dispatch on
every arguments ("multi-methods").

This thesis is about the definition and the typing of a langage derived from ML with multimethods. Multi-methods are introduced as a particular form of pattern matching on objects.The presentation of the type system uses an algebraic approach. The set of types is not predetermined but the
properties necessary for the soundness of the system are axiomatised. This approach allows generic
proofs independent of the choice of the algebra. It is shown how automatic type verification can be
reduced to the resolution of simple first-order problems (constraints). The resolution of the constraint
problems can then reuse all the results available in the litterature.

The advantage of this algebraic approach is that it can handle a large class of langages at once,
where the type algebra, the constraint langage, and the interpretation model of these constraints vary.
This approach also provides an interesting way to study typing in a context where the interpretation
world is open, i.e., when typing a module should provide a guarantee for all possible use of this
module.

Keywords

Type system, multi-methods, subtyping, objects, ML, constraints, algebra, open world.