

Under consideration for publication in J. Functional Programming 1

Mechanizing Metatheory in a Logical Framework

Robert Harper and Daniel R. Licata

Carnegie Mellon University
(e-mail: {rwh,drl}@cs.cmu.edu)

Abstract
The LF logical framework codifies a methodology for representing deductive systems,
such as programming languages and logics, within a dependently typed *-calculus. In
this methodology, the syntactic and deductive apparatus of a system is encoded as the
canonical forms of associated LF types; an encoding is correct (adequate) if and only if it
defines a compositional bijection between the apparatus of the deductive system and the
associated canonical forms. Given an adequate encoding, one may establish metatheoretic
properties of a deductive system by reasoning about the associated LF representation.
The Twelf implementation of the LF logical framework is a convenient and powerful tool
for putting this methodology into practice. Twelf supports both the representation of a
deductive system and the mechanical verification of proofs of metatheorems about it.

The purpose of this paper is to provide an up-to-date overview of the LF *-calculus, the
LF methodology for adequate representation, and the Twelf methodology for mechanizing
metatheory. We begin by defining a variant of the original LF language, called Canonical
LF, in which only canonical forms (long fij-normal forms) are permitted. This variant
is parameterized by a subordination relation, which enables modular reasoning about LF
representations. We then give an adequate representation of a simply typed *-calculus in
Canonical LF, both to illustrate adequacy and to serve as an object of analysis. Using this
representation, we formalize and verify the proofs of some metatheoretic results, including
preservation, determinacy, and strengthening. Each example illustrates a significant aspect
of using LF and Twelf for formalized metatheory.

1 Introduction
A formal definition of a programming language provides a precise specification for
programmers, ensures compatibility among compilers, and enables rigorous analysis of its properties. However, a language definition is an intricate artifact, and
the proofs of its properties are often complex and subtle. Consequently, it can be
difficult to define a language correctly and prove the appropriate theorems about
it, let alone to maintain the definition and associated proofs as a language evolves.
Fortunately, some of this burden can be alleviated by mechanizing the definition
and metatheory of a language.

In this article, we present a technical introduction to mechanizing languages using
LF (Harper et al., 1993) and Twelf (Pfenning & Sch"urmann, 1999). The literature
on formalizing and verifying languages in LF and Twelf is dispersed among numerous research papers, dissertations, course notes, and on-line repositories. The

2 Robert Harper and Daniel R. Licata
goal of this paper is to consolidate these ideas and make them more accessible to
a broader audience. We present an up-to-date overview of the LF *-calculus, the
LF methodology for representing languages, and the Twelf methodology for mechanically verifying the metatheory of a language. We hope to suggest that this
methodology for mechanizing languages is effective and feasible; however, the successful Twelf mechanization efforts, some of which are listed in Section 5, support
this claim better than this article can.

Mechanizing Definitions in LF. Language formalization efforts frequently start
from an informal, on-paper definition of the language to be mechanized--in, for
example, a textbook or a research paper. What does it mean to correctly represent
such a language definition in a formal framework? In the methodology of the the
LF logical framework (Harper et al., 1993), an LF representation of a language is
adequate iff it is isomorphic to the informal definition of the language. Adequacy
is a useful correctness criterion because any reasoning in or about an adequate
LF representation applies equally well to the informal definition, and vice versa.
For example, metatheoretic proofs about an adequate LF representation establish
properties of the original definition as well.

LF is a minimal dependent type theory. The syntax and judgements of an object
language (the object of study) are represented in LF as as the canonical forms
(essentially long fij-normal forms) of associated LF types. These canonical forms
are specified by an LF signature, which declares type and term constants, and
by a world, which specifies the LF contexts under consideration. A representation
is adequate iff there is an isomorphism between the informal presentation of the
object language and the associated canonical forms. The LF methodology has been
successfully used to derive representations of a wide variety of logical systems, often
leading to new insights about their structure.

One can often use variable binding in LF to represent object-language binding forms and hypothetical judgements. With such higher-order representations
of syntax and judgements, LF binding provides object-language operations such
as ff-conversion and capture-avoiding substitution and object-language judgement
properties such as weakening and substitution. Because binding and substitution
are present in both the informal presentation of a language and its LF representation, an isomorphism between the two must respect this structure. Thus, we say
that a higher-order LF representation is adequate iff there is a compositional bijection between the informal presentation of the language and the associated canonical
forms, where a bijection is compositional iff it commutes with substitution. This
property ensures that the object language's variables and hypothetical judgements
are correctly modeled.

Establishing the adequacy of a representation requires two main technical tools.
First, adequacy proofs proceed by induction on the canonical forms of LF. The
representation of an object language is not an inductive definition inside the LF
type theory; indeed, higher-order encodings rely on negative occurrences of types.
However, externally, the representation of a language as the canonical forms of parMechanizing Metatheory in a Logical Framework 3
ticular types in a particular world is an inductive definition because the canonical
forms of LF are inductively defined.

Second, modular adequacy proofs require subordination-based transport of adequacy. To modularly encode languages in LF, it is necessary to consider each
fragment of the object language in only the LF signature and contexts relevant to
its encoding. Combining these fragments requires understanding whether an encoding that is adequate in one signature and world remains adequate in another. To
understand when adequacy may be transported, it suffices to consider conditions
under which the canonical forms of a type remain invariant when transported from
one signature and world to another. The judgements of LF are parametrized by
a subordination relation (Virga, 1999), which determines whether canonical forms
of one type can appear in canonical forms of another. Using subordination, it is
possible to establish general conditions under which the canonical forms of a type,
and therefore the adequacy theorems proved about them, remain invariant when
transported from one signature and world to another.

Though adequacy underlies the LF methodology, it is not an obstacle to mechanization in practice. Experienced users of LF often define a language solely by
its LF representation, never even stating an informal description. However, even
such a definition will rely on an understanding of how to represent a language as
the canonical forms of particular LF types in contexts of particular forms, which
is exactly what an adequacy proof clarifies. Thus, we claim that all users of LF
should understand adequacy, even if they do not carry out a proof for every object
language.

Mechanizing Metatheory in Twelf. One application of adequate LF encodings is the
formalization and verification of a language's metatheory. Since the entire deductive
apparatus of a language is represented by certain canonical forms in LF, it is possible
to reason about its properties by reasoning about the associated canonical forms.
Specifically, an informal proof by induction on the structure of derivations can be
re-cast, via an adequate encoding, as a structural induction on the canonical forms
of the associated types.

This capability is exploited by the Twelf implementation of LF (Pfenning &
Sch"urmann, 1999), which supports the mechanized proofs of 89-propositions over
the canonical forms of specified types. This is sufficient to capture many useful properties of programming languages and logics. The Twelf methodology has proved
to be very robust: it has been used to develop the metatheory of a wide variety
of systems, including Mini-ML (Michaylov & Pfenning, 1991), the typed assembly language TALT (Crary, 2003), the POPLmark Challenge problem (Aydemir
et al., 2005), and the Harper-Stone internal language for Standard ML (Lee et al.,
2007). The same technical tools required for adequacy proofs are necessary for Twelf
metatheory: Twelf proofs proceed by induction on the canonical forms of LF, and
modular Twelf proofs require subordination-based transport of canonical forms.

Outline. In Section 2, we give a presentation of the LF type theory. Our presentation, called Canonical LF, follows Watkins et al. (2002, 2004a) in defining the

4 Robert Harper and Daniel R. Licata
type theory so that only canonical forms are permitted, giving a direct inductive
definition of the canonical forms. Additionally, we follow Virga (1999) in supporting subordination in the type theory. Next, we use a simply typed *-calculus as a
running example of mechanizing a language and its metatheory in LF and Twelf.
In Section 3, we give an adequate LF encoding of the syntax and semantics of
the simply typed *-calculus. In Section 4, we show how to mechanize some of the
metatheory of the simply typed *-calculus in Twelf. We give mechanized proofs of
several of its properties, including type preservation, determinacy of the operational
semantics, and strengthening.

An electronic copy of the Twelf code presented in this article is available as
supplementary material from the Journal of Functional Programming Web site
(http://www.cambridge.org/jfp/).

2 Canonical LF
As we stated above, the LF methodology consists of representing object languages
as canonical forms in a dependent type theory. In a dependent type theory, terms
of the type theory are allowed to appear in types. In LF, dependency arises from
considering families of types indexed by LF terms; these type families are used to
represent object-language judgements, as we discuss in Section 3. In the presence
of dependency, it is necessary to generalize the simple function type A1 ! A2 to a
dependent function type \Pi  x:A1. A2. In such a type, the variable x, which stands for
the argument to the function, may appear in the result type A2; this permits the
result type of the function to vary with the argument provided to it.

The canonical forms of LF are the long fij-normal forms: a term is a canonical
form iff it is not fi-reducible and it is j-expanded as much as possible without introducing fi-redices. Traditional presentations of LF (Harper et al., 1993; Salvesen,
1990; Geuvers, 1992; Harper & Pfenning, 2005) first define the type theory so that
both canonical and non-canonical forms are well-typed and then give an inductive characterization of which terms are canonical forms. However, because the LF
representation methodology requires only canonical forms, the non-canonical terms
can be seen as a technical device, rather than as an essential part of the type theory.
Technically, the reason to admit non-canonical forms is that they arise from the
substitution of one canonical form into another--i.e., canonical forms are not closed
under substitution. Such a substitution occurs in the typing rule for the application
of a dependent function to an argument:

M1 : \Pi  x:A2. A M2 : A2

M1 M2 : [M2/x]A

Even if M2 and all the terms embedded in the type \Pi  x:A2. A are in canonical form,
the substitution [M2/x]A may introduce non-canonical forms if A2 is itself a function
type. To equate non-canonical terms with an associated canonical form, traditional
presentations of LF consider terms modulo fi- or fij-equivalence.

Canonical LF, which is a fragment of Concurrent LF (Watkins et al., 2002, 2004a),
is a presentation of LF in which only the canonical forms are well-typed. The key

Mechanizing Metatheory in a Logical Framework 5
Kinds K ::= type | \Pi  x:A. K
Canonical Type Families A ::= P | \Pi  x:A2. A
Atomic Type Families P ::= a | P M

Canonical Terms M ::= R | * x. M
Atomic Terms R ::= x | c | R M

Signatures \Sigma  ::= * | \Sigma , c : A | \Sigma , a : K
Contexts \Gamma  ::= * | \Gamma , x : A

Fig. 1. LF Syntax

technical contribution of the canonical-forms approach is a notion of hereditary substitution, which directly computes the canonical form of the result of an ordinary
substitution. In Canonical LF's application typing rule, hereditary substitution is
used to directly compute the canonical form resulting from an ordinary substitution
[M2/x]A; the intermediate non-canonical form is never considered. When a traditional
substitution would result in a redex (* x. M1) M2, the corresponding hereditary substitution continues by hereditarily substituting M2 for x in M1. The key insight made
in Watkins et al. (2004a), which enables this approach, is that hereditary substitution can be defined in a structurally recursive manner, using the same algorithm
as structural cut elimination (Pfenning, 1994). The corresponding structural induction principle is used to establish the metatheoretic properties of Canonical LF.
Consequently, the metatheory of Canonical LF is simpler than presentations that
admit non-canonical forms--there is no need to consider fij-equality.

Following Virga (1999), the judgements of Canonical LF are parametrized by a
subordination relation, which determines when canonical forms of one type are relevant to canonical forms of another. Under appropriate subordination conditions,
the canonical forms of a type remain invariant when considered in a different signature and world. Specifically, the addition or removal of canonical forms of types
that are not subordinate to a given type does not change the canonical forms of
that type.

In Sections 2.1, 2.2, and 2.3, we overview the syntax, judgements, and properties
of Canonical LF. In Section 2.4, we give a formal definition of subordination and
prove the transport of canonical forms theorem.

2.1 Syntax
In Figure 1, we present the syntax of LF. The term level includes functions, application, variables x (which are bound in contexts \Gamma ), and constants c (which are
declared in signatures \Sigma ). Functions are given dependent function types \Pi  x:A2. A;
we write A2 ! A as an abbreviation when x is not free in A. The base types are
family-level constants a and their applications to terms. The original presentation of
LF (Harper et al., 1993) included family-level *-abstractions; because these cannot

6 Robert Harper and Daniel R. Licata

`_ \Sigma  sig

`_ * sig sig empty `

_ \Sigma  sig * `\Sigma ,_ A type c#\Sigma `

_ \Sigma , c : A sig sig term

`_ \Sigma  sig * `\Sigma ,_ K kind a#\Sigma `

_ \Sigma , a : K sig sig fam

`\Sigma ,_ \Gamma  ctx

`\Sigma ,_ * ctx ctx empty `

\Sigma ,_ \Gamma  ctx \Gamma  `\Sigma ,_ A type x#\Gamma `

\Sigma ,_ \Gamma , x : A ctx ctx term

Fig. 2. LF Signature and Context Formation

appear in canonical types, we omit them from the current presentation. The kind
type classifies types; the inhabitants of dependent function kinds are family-level
constants and their applications to terms.

To admit only canonical forms, the syntax of terms is stratified into two categories, the canonical terms M and the atomic terms R; this syntactically precludes
fi-redices. For example, the term (* x. x) c is not syntactically correct, let alone welltyped, because the *-abstraction is not an atomic term R. The type family level is
similarly stratified into A and P to differentiate between \Pi -types and base types; this
stratification will be used in the formation rules to ensure that well-typed terms
are j-long.

We implicitly consider all expressions M, R, A, P, and K up to ff-equivalence. By
convention, when we write a binding form (* x. M, \Pi  x:A2. A, or \Pi  x:A. K), the bound
variable is chosen to be fresh.

2.2 Judgements
The judgements defining LF are presented in Figures 2, 3, 4, and 5. For each
judgement, we first identify the judgement form in a box, (e.g., \Sigma  sig ), and then
we give the inference rules defining that judgement.

Parameters to the Formation Judgements. The signature formation judgement is
parametrized by a subordination relation _, which is a binary relation between
type families. The context, kind, type family, and term formation judgements are
parametrized by a signature \Sigma  and a subordination relation _. Subordination is
discussed in detail in Section 2.4. Taking _ to be the complete relation imposes
no restrictions on which judgements are derivable, recovering a presentation of
Canonical LF without subordination as a special case.

Signature and Context Formation. The judgements in Figure 2 define signature
and context formation. These judgements ensure that all variables or constants

Mechanizing Metatheory in a Logical Framework 7
\Gamma  `\Sigma ,_ K kind

\Gamma  `\Sigma ,_ type kind canon kind type
\Gamma  `\Sigma ,_ A type \Gamma , x : A `\Sigma ,_ K kind

\Gamma  `\Sigma ,_ \Pi  x:A. K kind canon kind pi

\Gamma  `\Sigma ,_ A type

\Gamma  `\Sigma ,_ P ) type

\Gamma  `\Sigma ,_ P type canon fam atom

\Gamma  `\Sigma ,_ A2 type \Gamma , x : A2 `\Sigma ,_ A type A2 _ A

\Gamma  `\Sigma ,_ \Pi  x:A2. A type canon fam pi

\Gamma  `\Sigma ,_ P ) K

a : K in \Sigma 
\Gamma  `\Sigma ,_ a ) K atom fam const

\Gamma  `\Sigma ,_ P1 ) \Pi  x:A2. K1 \Gamma  `\Sigma ,_ M2 ( A2 [M2/x]kA2 K1 = K

\Gamma  `\Sigma ,_ P1 M2 ) K atom fam app

\Gamma  `\Sigma ,_ M ( A

\Gamma  `\Sigma ,_ R ) P
\Gamma  `\Sigma ,_ R ( P canon term atom

\Gamma , x : A2 `\Sigma ,_ M ( A
\Gamma  `\Sigma ,_ * x. M ( \Pi  x:A2. A canon term lam

\Gamma  `\Sigma ,_ R ) A

x : A in \Gamma 
\Gamma  `\Sigma ,_ x ) A atom term var

c : A in \Sigma 
\Gamma  `\Sigma ,_ c ) A atom term const

\Gamma  `\Sigma ,_ R1 ) \Pi  x:A2. A1 \Gamma  `\Sigma ,_ M2 ( A2 [M2/x]aA2 A1 = A

\Gamma  `\Sigma ,_ R1 M2 ) A atom term app

Fig. 3. LF Formation Judgements

Simple Types ff ::= a | ff1 ! ff2
(A)- = ff

(a)- = a

(P)- = ff
(P M)- = ff

(A2)- = ff2 (A)- = ff

(\Pi  x:A2. A)- = ff2 ! ff

Fig. 4. Erasure to Simple Types

8 Robert Harper and Daniel R. Licata

[M0/x0]kff0 K = K0

[M0/x0]kff0type = type subst k type

[M0/x0]aff0 A = A0 [M0/x0]kff0K = K0

[M0/x0]kff0 \Pi  x:A. K = \Pi  x:A0. K0 subst k pi

[M0/x0]aff0 A = A0

[M0/x0]pff0 P = P0
[M0/x0]aff0 P = P0 subst a p

[M0/x0]aff0 A2 = A02 [M0/x0]aff0 A = A0

[M0/x0]aff0 \Pi  x:A2. A = \Pi  x:A02. A0 subst a pi

[M0/x0]pff0 P = P0

[M0/x0]pff0a = a subst p const

[M0/x0]pff0P = P0 [M0/x0]mff0M = M0

[M0/x0]pff0 P M = P0 M0 subst p app

[M0/x0]mff0 M = M0

[M0/x0]rff0R = M0 : ff0

[M0/x0]mff0 R = M0 subst m rh

[M0/x0]rff0R = R0
[M0/x0]mff0R = R0 subst m r

[M0/x0]mff0M = M0
[M0/x0]mff0* x. M = * x. M0 subst m lam

[M0/x0]rff0 R = M0 : ff

[M0/x0]rff0x0 = M0 : ff0 subst rh var
[M0/x0]rff0R1 = * x. M01 : ff2 ! ff [M0/x0]mff0M2 = M02 [M02/x]mff2 M01 = M0

[M0/x0]rff0R1 M2 = M0 : ff subst rh app

[M0/x0]rff0 R = R0

x#x0
[M0/x0]rff0 x = x subst r var [M0/x0]rff0 c = c subst r const

[M0/x0]rff0 R1 = R01 [M0/x0]mff0M2 = M02

[M0/x0]rff0 R1 M2 = R01 M02 subst r app

[M0/x0]cff0 \Gamma  = \Gamma 0

[M0/x0]cff0 * = * subst c empty
x0#x x#M0 [M0/x0]cff0 \Gamma  = \Gamma 0 [M0/x0]aff0A = A0

[M0/x0]cff0 \Gamma , x : A = \Gamma 0, x : A0 subst c term

Fig. 5. LF Hereditary Substitution

Mechanizing Metatheory in a Logical Framework 9
declared in a context or signature are distinct and that all classifiers are wellformed in the preceding declarations. The judgements x#\Gamma , c#\Sigma , and a#\Sigma  assert
that the variable or constant is not declared in the context or signature; we omit
their inductive definitions. Note that the context formation judgement presupposes
that the signature is well-formed, rather than checking signature formation at the
leaves.

We use the term world to refer to a set of well-formed contexts:

Definition 2.1 (World)
Given \Sigma  and _ such that `_ \Sigma  sig, a world W is a set containing contexts \Gamma  for
which the judgement `\Sigma ,_ \Gamma  ctx is derivable.

Kind, Family, and Term Formation. The judgements in Figure 3 define the formation of kinds, type families, and terms. We now call attention to several aspects of
these rules:

* All of the formation judgements presuppose that `_ \Sigma  sig and `\Sigma ,_ \Gamma  ctx.

In the rules for binding forms, the presuppositions of the judgements and the
premises of the rules always entail that the extended context in the premise
of the rule is well-formed.*
The judgement \Gamma  ` M ( A presupposes that the type A is well-formed in
\Gamma . In contrast, the judgement \Gamma  ` R ) A ensures that the type A is wellformed. These modes correspond to a bidirectional operational interpretation:
a canonical term is checked against a type, whereas a type is synthesized from
an atomic term. The atomic type family judgement also synthesizes its kind,
while the remaining judgements check that a type or kind is well-formed.
The direction of the arrow in the judgement form serves as a mnemonic for
the flow of information: in M ( A, information in the type is used to check
the term; in R ) A, information in the term is used to synthesize the type.
Because *-abstractions are always checked against a known type, they do not
require a type annotation for the bound variable.*
Variables and constants must be declared in the context or signature to be
well-formed. As the variable rule atom term var explicates, the notation
x : A in contexts \Gamma  stands for hypothetical assumptions of `\Sigma ,_ x ) A. Consequently, the usual substitution principle for the hypothetical judgement
permits the substitution of a derivation of R ) A for an assumption x ) A. In
contrast, it requires further justification to substitute a derivation of M ( A for
an assumption x ) A; this justification is provided by hereditary substitution.
Note that we do not consider substitutions for constants.*
The subordination relation parameter to the judgements is used only in the
premise of the rule canon fam pi; this premise ensures that for any wellformed type \Pi  x:A2. A, the relation A2 _ A holds. When _ is taken to be the
complete relation, this premise is always satisfiable. The rationale for this
premise is described in Section 2.4.*
The rules atom term app and atom fam app have hereditary substitution
premises that compute the result type and kind of an application.

10 Robert Harper and Daniel R. Licata

* In the rule canon term atom, the syntactic restriction of the classifier to a

P, rather than any A, ensures that canonical forms are j-long. For example,
the judgement f : (a ! a) ` f ( (a ! a) is not derivable: (a ! a) is a
\Pi -type, so canon term atom cannot be applied, and the variable f is not
a *-abstraction, so neither can canon term lam. However, in a signature
containing the declaration a : type, the canonicity of the j-expansion of f can
be derived as follows (let \Gamma  abbreviate the context f : (a ! a), x : a):

\Gamma  ` f ) (a ! a)

\Gamma  ` x ) a
\Gamma  ` x ( a cta

...
[x/ ]aa a = a
\Gamma  ` f x ) a
\Gamma  ` f x ( a cta
f : (a ! a) ` * x. f x ( (a ! a) .

Both inferences labeled cta for canon term atom occur at base type, as
required.

These formation judgements give a direct inductive definition of the canonical
forms of LF. Consequently, rule induction for these judgements may be used to
reason about canonical forms.

Hereditary Substitution. Next, we define hereditary substitution, which computes
the canonical result of substituting one canonical form into another. The hereditary
substitution judgements are defined in Figure 5. Hereditary substitution is defined
on ff-equivalence classes of expressions; by our notational convention, a bound variable x is always distinct from both the variable being substituted for and the term
being substituted for it (x0 and M0 in the rules). Written in this relational style,
a standard substitution judgement [M0/x]M = M0 would have four parameters: the
term being substituted (M0), the variable being substituted for (x), the term being
substituted into (M), and the result of the substitution (M0). The hereditary substitution judgement [M0/x]mff0 M = M0 adds an extra parameter ff0, which is the simple
type of the substituted term M0 (the superscript m is simply notation for differentiating the judgements for the various syntactic classes from one another). The
syntax of simple types ff is defined in Figure 4. The simple type guides the process
of hereditary substitution: because of the simple type parameter to the judgement,
it is decidable whether or not a hereditary substitution exists even when the terms
involved are ill-formed (see Theorem 2.4 below).

The key hereditary substitution judgement is [M0/x]rff0 R = M0 : ff0. This judgement
computes the canonical result of substituting a canonical form M0 into an atomic
term R whose head is the variable x; it computes a new canonical term M0 and
its simple type ff0. The key rule is subst rh app: when the substitution into the
function position of an application yields a *-abstraction, this rule continues by
hereditarily substituting the argument M02 into the body of the function. This is the
rule where the simple type is used to guide the process of hereditary substitution:
the simple type resulting from the first premise must have the form ff2 ! ff, and
the simple-type input to the third premise is ff2 (which, on well-typed terms, is

Mechanizing Metatheory in a Logical Framework 11
the simple type of M02) rather than ff0. We prove below that the simple type ff2 in
this final premise is always smaller than the input simple type ff0; this fact is used
to establish decidability of hereditary substitution and to prove that hereditary
substitutions exist under the appropriate typing premises.

The other hereditary substitution judgement on atomic terms, [M0/x]rff0R = R0, is
derivable only when the variable x is not the head variable of R; it computes another
atomic term compositionally. The remaining hereditary substitution judgements are
defined compositionally as well. Because there is no single scope in which a variable
declared in \Gamma  can be renamed, the premises of the rule subst c term, which defines
hereditary substitution into a context, insist that the variable in the context does
not interfere with the substitution. The auxiliary judgement x#M holds when x is
not free in the term M; we elide its standard inductive definition. Intuitively, the
premises of this rule ensure that the hereditary substitution into a context \Gamma  is not
defined when either the variable x0 is declared in \Gamma  or when a free variable in M0
would be captured by a declaration in \Gamma .

The judgement (A)- = ff in Figure 4 defines an erasure relation that computes
a simple type ff from a dependent type A. Observe (by induction on the structure
of type families) that for all A, there exists a unique ff such that (A)- = ff; this
justifies using function notation for (A)-. As a convenience, we write [M0/x]mA0 M = M0
to mean [M0/x]mff0M = M0 where (A0)- = ff0; we adopt the analogous convention for
the other syntactic categories. This notational convention is used by the hereditary
substitution premises of the formation rules.

Notation. In the remainder of this article, we adopt several additional notational
conveniences. We elide the signature \Sigma  and the subordination relation _ parameters
to the formation judgements when they are clear from context, as they are invariant
throughout a derivation. To make the default instantiation of the parameters clear
in a particular context, we will say that we work in LF[\Sigma , _]. Also, we abbreviate a
hypothetical judgement in the empty context by eliding the turnstile, writing, for
example, R ) A for * ` R ) A.

2.3 Metatheory of Canonical LF
In this section, we prove two major theorems about Canonical LF. First, we prove
decidability results for hereditary substitution and type checking. Next, we prove
that hereditary substitutions exist and preserve types when the terms involved are
well-formed and the types align in the appropriate way. Watkins et al. (2002) discuss
these theorems and their proofs in more detail.

The remainder of this article does not require understanding the proofs of these
two theorems about Canonical LF, so we provide proof sketches only as a reference
for interested readers. However, the adequacy proofs below do make use of these
results. A reader who is not interested in the metatheoretic development of LF
may skip this section on first reading and refer back to the theorem statements as
necessary to understand the subsequent adequacy proofs.

As a notational convenience in the following theorem statements, we use the word

12 Robert Harper and Daniel R. Licata
"expression" to refer generically to any of the syntactic classes of Canonical LF. We
also write E as a general metavariable for any syntactic category K, A, P, M, R, \Gamma , and
we use e in {k, a, p, m, r, c} for the corresponding tag on the hereditary substitution
judgement. We write x#E to mean that the variable x does not occur free in the
expression E.

The staging of lemmas leading up to the main results is somewhat intricate, and
in some cases it is desirable to strengthen a theorem statement so that it holds
even when certain subjects are not well-formed. In particular, we will state some
theorems about formation judgements whose contexts are not known to be wellformed. However, even in these cases, we tacitly assume that all expressions have
correct variable scoping. Specifically, when we write a context x1 : A1, . . . , xn : An,
we assume that all variables xi are distinct and that the free variables of Ai are
a subset of {x1, . . . , xi-1}. Additionally, we only write a judgement form such as
\Gamma  ` M ( A when all free variables of M and A are declared in \Gamma . Observe that, given
a hereditary substitution [M0/x0]eA0E = E0, the free variables of E0, written F V (E0),
are (F V (E) - {x0}) [ F V (M0).

In the following theorem statements, when we leave the signature and subordination relation parameters to a theorem statement implicit, we tacitly assume a
subordination relation _ and signature \Sigma  such that `_ \Sigma  sig.

2.3.1 Decidability
Lemma 2.2 (Head Substitution Size)
If [M0/x0]rff0R = M0 : ff then ff is a subexpression of ff0.

Proof
By induction on the derivation of [M0/x0]rff0R = M0 : ff. In the case for subst rh var,
ff0 and ff are identical. In the case for subst rh app, the inductive hypothesis gives
that ff2 ! ff is a subexpression of ff0, so ff is as well.

Lemma 2.3 (Uniqueness of Substitution and Synthesis)

1. If [M0/x0]rff0R = R0 and [M0/x0]rff0R = M0 : ff0 then false.
2. For any E in {K, A, P, M, R}, if [M0/x0]eff0E = E0 and [M0/x0]eff0 E = E00 then E0 = E00.
3. If \Gamma  ` R ) A and \Gamma  ` R ) A0 then A = A0.
4. If \Gamma  ` P ) K and \Gamma  ` P ) K0 then K = K0.

Because we develop the metatheory of Canonical LF in an informal constructive
logic, the following statements of decidability are sensible.

Theorem 2.4 (Decidability of Substitution)

1. For any E in {K, A, P, M, \Gamma }, given M0, ff0, x0, either there exists an E0 such that

[M0/x0]eff0E = E0 or there is no such E0.
2. Given M0, ff0, x0, and R, either there exists an R0 such that [M0/x0]rff0R = R0 or

there exist M0 and ff0 such that [M0/x0]rff0R = M0 : ff0 or there are no such R0 and
M0.

Proof

Mechanizing Metatheory in a Logical Framework 13
First, we prove part 2 and the clause of part 1 for canonical terms M by mutual
lexicographic induction on (A0)-, the terms M and R being substituted into, and
an order permitting inductive calls to the clause for atomic terms from the clause
for canonical terms on the same simple type and term (to account for the silent
injection from R to M). Then, we prove the clauses of part 1 for P, A, K, and \Gamma  in
that order, each by induction on the expression being substituted into, and each
using the previous parts.

Theorem 2.5 (Decidability of Formation)
Assume that the subordination relation A _ B is decidable.

1. For all \Sigma  and _, either `_ \Sigma  sig or not.

Assume _ and \Sigma  such that that `_ \Sigma  sig.

2. For all \Gamma  and K, either \Gamma  ` K kind or not.
3. For all \Gamma  and A, either \Gamma  ` A type or not.
4. For all \Gamma  and P, either there exists a K such that \Gamma  ` P ) K or there is no

such K.
5. For all \Gamma , M, and A, either \Gamma  ` M ( A or not.
6. For all \Gamma  and R, either there exists an A such that \Gamma  ` R ) A or there is no

such A.
7. For all \Gamma , either \Gamma  ctx or not.

Proof
First, we prove parts 5 and 6 by mutual lexicographic induction on first the term
and second an order permitting inductive calls to the clause for atomic terms from
the clause for canonical terms on the same term. Then, we prove parts 4, 3, 2, 7,
and 1, each by induction on the expression being judged well-formed.

2.3.2 Substitution Theorem
We now prove that under the appropriate typing conditions hereditary substitutions exist and preserve types. We write \Gamma  ` \Gamma 0 iff \Gamma  can be obtained from \Gamma 0
by removing zero or more declarations; we use the notation \Sigma  ` \Sigma 0 analogously.
Viewing subordination relations as sets of pairs of types, we write _ ` _0 for the
usual subset order.

Lemma 2.6 (Weakening of Signature and Context)
Assume \Gamma  ` \Gamma 0, \Sigma  ` \Sigma 0 and _ ` _0.

1. For all five formation judgements J , if \Gamma  `\Sigma ,_ J then \Gamma 0 `\Sigma 0,_0 J .
2. If `\Sigma ,_ \Gamma  ctx then `\Sigma 0,_0 \Gamma  ctx.
3. If `_ \Sigma  sig then `_0 \Sigma  sig.

Lemma 2.7 (Exchange)
For all five formation judgements, if \Gamma , x : A, y : B, \Gamma 0 ` J then \Gamma , y : B, x : A, \Gamma 0 ` J .

Exchange for the signature \Sigma  also holds, but we do not require it in this article.

14 Robert Harper and Daniel R. Licata
Lemma 2.8 (Vacuous Substitutions)
For all M0, x0, A0, and E among {K, A, P, M, R}, if x0#E then [M0/x0]eA0E = E.

Lemma 2.9 (Erasure is Invariant Under Substitution)
For all E in {A, P}, if [M0/x0]eff0E = E0 then (E)- = (E0)-.

Ordinary substitutions enjoy the following composition property:

[e0/x0][e2/x]e1 = [[e0/x0]e2/x][e0/x0]e1
assuming that x#x0 and x#e0. The following lemma establishes an analogous property for hereditary substitutions. In addition to showing that the results of the two
substitutions are equal, it shows that the outer two substitutions are defined if the
inner three are.

Lemma 2.10 (Composition of Substitution)
Assume x#x0 and x#M0.

1. For all E in {K, A, P, M, R}, if [M0/x0]mff0 M2 = M02 and [M2/x]eff2E1 = E and

[M0/x0]eff0E1 = E01 then there exists an E0 such that [M0/x0]eff0E = E0 and
[M02/x]eff2E01 = E0.
2. If [M0/x0]mff0M2 = M02 and [M2/x]rff2 R1 = M : ff and [M0/x0]rff0 R1 = R01 then there

exists an M0 such that [M0/x0]mff0 M = M0 and [M02/x]rff2R01 = M0 : ff.
3. If [M0/x0]mff0M2 = M02 and [M2/x]rff2 R1 = R and [M0/x0]rff0 R1 = M01 : ff then there

exists an M0 such that [M0/x0]rff0 R = M0 : ff and [M02/x]mff2M01 = M0.

The additional two composition properties for atomic terms R apply when the head
variable of R is x or x0.

Proof
Define size(a) = 1 and size(ff1 ! ff2) = 1 + size(ff1) + size(ff2). The proof is by
mutual lexicographic induction on first size(ff0) + size(ff2) and then the derivation
of the substitution of M2. The size metric is necessary to justify an inductive call in
which ff0 and ff2 are swapped.

Theorem 2.11 (Substitution)
Assume \Sigma  and _ such that `_ \Sigma sig. Assume \Gamma L, x0 : A0, \Gamma R ctx and \Gamma L ` M0 ( A0.
Further, assume that subordination relationships A _ B are preserved by hereditary
substitution into A and B. Then:

1. There exists a \Gamma 0R such that [M0/x0]cA0\Gamma R = \Gamma 0R and \Gamma L, \Gamma 0R ctx.
2. If \Gamma L, x0 : A0, \Gamma R ` K kind then there exists a K0 such that [M0/x0]kA0K = K0 and

\Gamma L, \Gamma 0R ` K0 kind.
3. If \Gamma L, x0 : A0, \Gamma R ` A type then there exists an A0 such that [M0/x0]aA0A = A0

and \Gamma L, \Gamma 0R ` A0 type.
4. If \Gamma L, x0 : A0, \Gamma R ` A type and \Gamma L, x0 : A0, \Gamma R ` M ( A then there exist A0 and

M0 such that [M0/x0]aA0 A = A0 and [M0/x0]mA0 M = M0 and \Gamma L, \Gamma 0R ` M0 ( A0.

Proof

Mechanizing Metatheory in a Logical Framework 15
To prove this substitution theorem, we strengthen the theorem statements so that
they work over contexts and types that are not necessarily well-formed. By strengthening the theorem in this way, we may prove the clause for terms without yet knowing that substitutions into type families preserve well-formedness. For conciseness,
in the following theorem statements we leave implicit the existential quantification
of the results of hereditary substitution. We first prove the following two clauses:

* If \Gamma L, x0 : A0, \Gamma R ` M ( A and \Gamma L ` M0 ( A0 and [M0/x0]cA0\Gamma R = \Gamma 0R and

[M0/x0]aA0 A = A0 then [M0/x0]mA0 M = M0 and \Gamma L, \Gamma 0R ` M0 ( A0.*
If \Gamma L, x0 : A0, \Gamma R ` R ) A and \Gamma L ` M0 ( A0 and [M0/x0]cA0\Gamma R = \Gamma 0R then
[M0/x0]aA0 A = A0 and either [M0/x0]rA0 R = R0 and \Gamma L, \Gamma 0R ` R0 ) A0 or
[M0/x0]rA0 R = M0 : (A0)- and \Gamma L, \Gamma 0R ` M0 ( A0.

The proof is by mutual lexicographic induction on first the simple type (A0)- and
then the derivations of \Gamma L, x0 : A0, \Gamma R ` M ( A and \Gamma L, x0 : A0, \Gamma R ` R ) A.

Next, we prove the analogous statements for the remaining syntactic categories:

* If \Gamma L, x0 : A0, \Gamma R ` P ) K and \Gamma L ` M0 ( A0 and [M0/x0]cA0\Gamma R = \Gamma 0R then

[M0/x0]kA0 K = K0 and [M0/x0]pA0P = P0 and \Gamma L, \Gamma 0R ` P0 ) K0.*
If \Gamma L, x0 : A0, \Gamma R ` A type and \Gamma L ` M0 ( A0 and [M0/x0]cA0 \Gamma R = \Gamma 0R then
[M0/x0]aA0 A = A0 and \Gamma L, \Gamma 0R ` A0 type.*
If \Gamma L, x0 : A0, \Gamma R ` K kind and \Gamma L ` M0 ( A0 and [M0/x0]cA0\Gamma R = \Gamma 0R then
[M0/x0]kA0 K = K0 and \Gamma L, \Gamma 0R ` K0 kind.*
If \Gamma L, x0 : A0, \Gamma Rctx and \Gamma L ` M0 ( A0 then [M0/x0]cA0 \Gamma R = \Gamma 0R and \Gamma L, \Gamma 0Rctx.

Each part is proved in sequence by induction on the derivation of the expression
being substituted into, using the previous parts. Then the clauses of the main
theorem may be obtained as simple corollaries.

Lemma 2.12 (Regularity)

1. If \Gamma  ctx and \Gamma  ` P ) K then \Gamma  ` K kind.
2. If \Gamma  ctx and \Gamma  ` R ) A then \Gamma  ` A type.

This final lemma will be convenient in the adequacy proofs below; it asserts an nary hereditary substitution inversion principle for iterated \Pi -types and applications.

Lemma 2.13 (Iterated Hereditary Substitution Inversion)

1. If [M/x]aA B = \Pi  x1:A1. . . . \Pi  xn:An. An+1 then there exist A01, . . . , A0n+1 such that B

= \Pi  x1:A01. . . . \Pi  xn:A0n. A0n+1 and [M/x]aA A0i = Ai for 1 <= i <= n + 1.
2. If [M/x]aA \Pi  x1:A1. . . . \Pi  xn:An. An+1 = B then there exist A01, . . . , A0n+1 such that B

= \Pi  x1:A01. . . . \Pi  xn:A0n. A0n+1 where [M/x]aA Ai = A0i for 1 <= i <= n + 1.
3. If [M/x]aA B = (a M1 . . . Mn) then there exist M01, . . . , M0n such that B = a M01 . . . M0n

where [M/x]mA M0i = Mi for 1 <= i <= n.
4. If [M/x]aA (a M1 . . . Mn) = B then there exist M01, . . . , M0n such that B = a M01 . . . M0n

where [M/x]mA Mi = M0i for 1 <= i <= n.

The complete metatheory of Canonical LF includes an additional theorem witnessing that a variable x : A can be j-expanded into a canonical form of type A.

16 Robert Harper and Daniel R. Licata
Whereas hereditary substitution corresponds to cut admissibility for a sequent calculus, this theorem corresponds to an identity principle (i.e., that A ` A for any
A). Because we do not require the identity theorem in this article, we refer the
interested reader to Watkins et al. (2002) for details.

2.4 Subordination
Intuitively, a type family a is subordinate to a type family b if terms of type a can
appear in either terms of type b or indices of the type family b (Virga, 1999). The
definition of subordination requires an auxiliary judgement identifying the head
constant of a type family A.

|A| = a

|a| = a |

P| = a|
P M| = a |

A| = a|
\Pi  x:A2. A| = a

This judgement identifies the family-level constant at the head of the base type to
which terms of type A contribute, where a term of base type contributes to that
base type and a term of function type contributes to the base type that results
from fully applying it to arguments. Observe (by induction over the structure of
type families) that for all A there exists a unique family-level constant a such that|

A| = a; this justifies using |A| in a functional notation.

We now define the conditions under which a subordination relation is well-formed.

Definition 2.14 (Subordination Relation)
A subordination relation for a signature \Sigma  is a binary relation _ between familylevel constants declared in \Sigma , presented as a list of tuples, that satisfies the following
properties:

1. Well-formedness: The judgement `_ \Sigma  sig is derivable.
2. Index subordination: For all declarations a : \Pi  x1:A1. . . . \Pi  xn:An. type in \Sigma ,|

Ai| _ a for all 1 <= i <= n.
3. Reflexivity: For all a declared in \Sigma , a _ a.
4. Transitivity: if a1 _ a2 and a2 _ a3 then a1 _ a3.

The first condition, `_ \Sigma  sig, implies that the subordination relation is permissive
enough that the signature itself is well-formed. The second condition ensures that
the types of the indices to a type family are subordinate to that family. The third
and fourth ensure that subordination is a pre-order.

We tacitly extend the notation for subordination from constants to arbitrary
type families by writing A1 _ A2 to mean |A1| _ |A2|. We write a1 6_ a2 to mean
that a1 is not subordinate to a2; we extend this notation to A1 6_ A2 analogously
to subordination. We also write K _ A, where K = \Pi  x1:A1. . . . \Pi  xn:An. type, to mean
Ai _ A for all 1 <= i <= n.

Theorem 2.5 assumes that the subordination relation A _ B is decidable. This
assumption is true of any subordination relation: |A| maps every type family A to
a unique constant a; and subordination on constants a _ b is decidable because

Mechanizing Metatheory in a Logical Framework 17
we require a subordination relation to be presented as a list of pairs. Theorem 2.11
assumes that A _ B is preserved by substitution into A and B. This assumption is
true of any subordination relation by the following lemma:

Lemma 2.15 (Head is Invariant Under Substitution)
For all M0, x0, ff0, and E in {A, P}, if [M0/x0]eff0E = E0 then |E| = |E0|.

2.4.1 Transport of Canonical Forms
In this section, we show that the canonical forms of a type are unchanged by adding
or removing canonical forms of other types that are not subordinate to it. We begin
by defining the restriction of a context, signature, or subordination relation to a
type, which removes all declarations or relationships that are not subordinate to
that type.

Definition 2.16 (Context, Signature, and Subordination Relation Restriction)

\Gamma |_a = \Gamma 0

*|_a = *

\Gamma |_a = \Gamma 0 A2 _ a
(\Gamma , x : A2)|_a = \Gamma 0, x : A2

\Gamma |_a = \Gamma 0 A2 6_ a

(\Gamma , x : A2)|_a = \Gamma 0

\Sigma |_a = \Sigma 0

*|_a = *

\Sigma |_a = \Sigma 0 A2 _ a
(\Sigma , c : A2)|_a = \Sigma 0, c : A2

\Sigma |_a = \Sigma 0 A2 6_ a

(\Sigma , c : A2)|_a = \Sigma 0

\Sigma |_a = \Sigma 0 a0 _ a
(\Sigma , a0 : K)|_a = \Sigma 0, a0 : K

\Sigma |_a = \Sigma 0 a0 6_ a

(\Sigma , a0 : K)|_a = \Sigma 0

Given a subordination relation _, we define its restriction to a constant c, written_ |

c, by

a _ |c b iff a _ b and b _ c.
Observe by induction on the structure of \Gamma  that for all \Gamma , _, a, there exists a unique
\Gamma 0 such that \Gamma |_a = \Gamma 0; this justifies using \Gamma |_a in function notation. A similar result
holds for signature restriction. As a convenience, we write \Gamma |_A for \Gamma |_a where |A| = a;
we adopt the analogous convention for signature restriction \Sigma |_A and subordination
restriction _ |A.

We now prove that canonical forms are invariant under subordination-based context, signature, and subordination relation restriction and extension:

Theorem 2.17 (Transport of Canonical Forms)
Assume that _ is a subordination relation for \Sigma .

1. For all A, if _ |A =_0 and \Sigma |_A = \Sigma 0 then `_0 \Sigma 0 sig.
Assume a type B and let \Sigma |_B = \Sigma 0 and _ |B =_0.

18 Robert Harper and Daniel R. Licata

2. If A _ B and `\Sigma ,_ \Gamma  ctx and \Gamma  `\Sigma ,_ A type and \Gamma |_B = \Gamma 0 then \Gamma  `\Sigma ,_ M ( A

iff \Gamma 0 `\Sigma 0,_0 M ( A. The analogous statement for \Gamma  `\Sigma ,_ R ) A also holds.
3. If A _ B and `\Sigma ,_ \Gamma ctx and \Gamma |_B = \Gamma 0 then \Gamma  `\Sigma ,_ Atype iff \Gamma 0 `\Sigma 0,_0 Atype.

The analogous statement for \Gamma  `\Sigma ,_ P ) K also holds.
4. If K _ B and `\Sigma ,_ \Gamma ctx and \Gamma |_B = \Gamma 0 then \Gamma  `\Sigma ,_ Kkind iff \Gamma 0 `\Sigma 0,_0 Kkind.
5. If `\Sigma ,_ \Gamma  ctx and \Gamma |_B = \Gamma 0 then `\Sigma 0,_0 \Gamma 0 ctx.

Proof
The "if" directions of parts 2, 3, and 4 are consequences of weakening (Lemma 2.6).
This leaves the "only if" directions for each of these three parts. The two clauses
in part 2 can be proved by mutual induction on the derivations of \Gamma  `\Sigma ,_ M ( A
and \Gamma  `\Sigma ,_ R ) A. Then, to prove part 3, we prove the clause for atomic families
by induction on the derivation of \Gamma  `\Sigma ,_ P ) K, and then we prove the clause
for types by induction on the derivation of \Gamma  `\Sigma ,_ A type. Next, we prove part 4
by induction on the derivation of \Gamma  `\Sigma ,_ K kind. The proofs of these parts use
Lemma 2.12 and Lemma 2.15. These parts also require the following lemma: if _
is a subordination relation for \Sigma  and \Gamma  `\Sigma ,_ P ) K then K _ P; this lemma can be
proved by induction on the formation derivation for P.

Next, we prove part 5 by induction on the derivation of `\Sigma ,_ \Gamma  ctx. For part 1,
we prove that if _ is a subordination relation for \Sigma  and \Sigma |_A = \Sigma 0 and _ |A =_0
then `_0 \Sigma 0 sig. The proof is by induction on the restriction derivation; it requires
a lemma stating that a subordination relation for a signature (\Sigma , c : A) is also a
subordination relation for \Sigma  (and similarly for \Sigma , a : K).

The proof of this theorem uses the fact that the relationship A2 _ A holds whenever a type \Pi  x:A2. A is well-formed. Moreover, it is possible to construct a counterexample to this transport theorem using a type that does not satisfy this condition.

2.4.2 Strongest Subordination Relation
We define the strongest subordination relation for a signature \Sigma , written _\Sigma , to be
the intersection of all subordination relations for \Sigma . If a signature \Sigma  is well-formed
without regard to subordination (i.e., it is well-formed in the complete relation),
then there exists a unique strongest subordination relation for \Sigma . Intuitively, the
strongest subordination relation establishes as few subordination relationships as
possible, subject to the constraint that the signature itself be well-formed. Working
with any subordination relation other than the strongest one causes Theorem 2.17 to
produce overapproximate results: extra subordination relationships prevent context
and signature restriction from dropping assumptions that are, in fact, irrelevant.
For example, if this theorem is applied with the complete subordination relation,
the restrictions are the identity and the theorem yields no information.

In the remainder of this paper, we consider only the strongest subordination
relation for each signature. By convention, when we instantiate a judgement with
an LF signature \Sigma , we also implicitly take the subordination relation parameter
to be _\Sigma . For example, we will write LF[\Sigma ] to mean LF[\Sigma , _\Sigma ]. Additionally, we
write \Sigma |A to mean \Sigma |_\Sigma A for the strongest subordination relation _\Sigma . We will also

Mechanizing Metatheory in a Logical Framework 19

o/ ::= unit | o/1 ! o/2

e ::= x | hi | * x:o/. e | e1 e2

X ` e term

X , x, X 0 ` x term term var X ` hi term term empty
X , x ` e termX `

* x:o/. e term term lam X `

e1 term X ` e2 termX `

e1 e2 term term app

[e0/x]e = e0

[e0/x]x = e0 subst var match

y # x
[e0/x]y = y subst var mismatch

[e0/x]hi = hi subst empty

[e0/x]e1 = e01 [e0/x]e2 = e02

[e0/x]e1 e2 = e01 e02 subst app

x # y y # e0 [e0/x]e = e0

[e0/x]* y:o/. e = * y:o/. e0 subst lam

Fig. 6. Syntax of the STLC

write \Gamma |A when the signature and its strongest subordination relation are clear from
context.

All of the signatures \Sigma  we consider in this article have the property that

(_\Sigma )|a =_\Sigma 0 where \Sigma |_\Sigma a = \Sigma 0.
for any family a declared in the signatures. That is, the restriction to a type of the
strongest subordination relation for the signature is the strongest subordination
relation for the restriction of the signature. We sometimes tacitly pass between
these two subordination relations.

3 Mechanizing the Definition of the STLC in LF

3.1 Encoding of Syntax
We now begin mechanizing the simply typed *-calculus (STLC) in LF. In this
section, we encode the language's syntax. For reference, in Figure 6, we present the
syntax of the STLC in informal mathematical notation. The metavariable X ranges
over comma-separated lists of distinct variables, which stand for assumptions of
x term; the hypothetical judgement X ` e term is derivable when the free variables
of the term e are contained in X . This judgement will be used to state the adequacy
theorems below. The judgement [e0/x]e = e0 defines the standard notion of captureavoiding substitution; we omit the standard definition of x # e.

The LF signature defined in Figure 7 represents the syntax of the STLC. It

20 Robert Harper and Daniel R. Licata

tp : type
arrow : tp ! tp ! tp

unit : tp

tm : type
empty : tm

app : tm ! tm ! tm
lam : tp ! (tm ! tm) ! tm

Fig. 7. LF Signature for the STLC Syntax

o/ type AE M ( tp

unit type AE unit ( tp enc tp unit
o/1 type AE M1 ( tp o/2 type AE M2 ( tp

o/1 ! o/2 type AE arrow M1 M2 ( tp enc tp arrow

X terms AE \Gamma  ctx

* terms AE * ctx enc terms nil X

terms AE \Gamma  ctxX
, x terms AE \Gamma , x : tm ctx enc terms term

X ` e term AE \Gamma  ` M ( tm

X , x, X 0 ` x term AE \Gamma , x : tm, \Gamma 0 ` x ( tm enc tm var

X ` hi term AE \Gamma  ` empty ( tm enc tm empty
o/ type AE Mt ( tp X , x ` e term AE \Gamma , x : tm ` Me ( tmX `

(* x:o/. e) term AE \Gamma  ` lam Mt (* x. Me) ( tm enc tm lam

X ` e1 term AE \Gamma  ` M1 ( tm X ` e2 term AE \Gamma  ` M2 ( tmX `

e1 e2 term AE \Gamma  ` app M1 M2 ( tm enc tm app

Fig. 8. Encoding of STLC Syntax

declares an LF type for each syntactic category (tp for o/ and tm for e) along with
constants inhabiting those types with the representations of the language's types
and terms. The informal syntax unit has no subexpressions in the informal grammar,
so it is represented by an LF constant unit of type tp; the informal syntax o/1 ! o/2
has two type subexpressions, so it is represented by an LF constant arrow of type
tp ! tp ! tp. The representation of terms uses a technique called higher-order
abstract syntax : object-language variables are represented by LF variables; with
this representation, the framework provides ff-conversion and substitution for the
object language. To build intuition, consider the following expressions and their
intended representations:

Mechanizing Metatheory in a Logical Framework 21

Expression LF Representation
unit ! unit AE (arrow unit unit)
x y AE (app x y)
* x:unit. x AE (lam unit (* x. x))

The second and third examples illustrate higher-order abstract syntax. In the second
example, object-language variables are translated to LF variables. The third example illustrates the representation of binding forms: in the informal syntax * x:o/. e,
the variable x is bound in the body e; in the LF representation, the body is represented by an LF function of type (tm ! tm) that binds the equivalent variable.
This representation strategy is the reason for the higher-order type of the constant
lam.

The judgements in Figure 8 formally define the encoding of the STLC into LF.
We consider both object-language terms and LF terms up to ff-equivalence, and
by convention all bound variables are chosen fresh. The intended reading of these
judgements is as follows:

* o/ type AE M ( tp Encode an object-language type o/ to an LF term M of LF

type tp in the empty context.* X

terms AE \Gamma  ctx Encode an object-language list of variables X to an LF
context declaring each of those variables to have type tm.* X `

e term AE \Gamma  ` M ( tm Assuming X terms AE \Gamma  ctx, encode
an object-language term e with free variables in X to an LF term M of type
tm in LF context \Gamma . This judgement has four parameters (e, X , M, and \Gamma ).
The notation is meant to suggest the intended invariant that whenever the
judgement X ` e term AE \Gamma  ` M ( tm is derivable, so are X ` e term and
\Gamma  ` M ( tm. This invariant is verified in the adequacy proof below.

The term encoding rule enc tm lam illustrates higher-order abstract syntax: the
encoding of the object language term e with free variables (X , x) is an LF term Me
with free variables in the context (\Gamma , x : tm); the variable x is then bound in * x. Me,
which creates an LF term of type tm ! tm.

These encoding judgements clarify the fact that the LF representation of the
object-language syntax is specified not just by the LF signature, but also by the
LF contexts in which that signature is considered. For example, to know that tm
adequately represents object-language terms with free variables, it is necessary to
know not just that the constants inhabiting tm are empty, app, and lam, but also
that contexts containing LF variables of type tm are considered.

The strongest subordination relation for the signature \Sigma  in Figure 7, written _\Sigma ,
is {tp _ tp, tp _ tm, tm _ tm}. Intuitively, STLC types appear in the syntax of
STLC terms, but STLC terms do not appear in the syntax of STLC types.

3.2 Adequacy of Syntax Encodings
Adequacy is the correctness criterion for an encoding judgement; it establishes that
the encoding is an isomorphism between the informal object-language entities and

22 Robert Harper and Daniel R. Licata
their LF representation. We break the statement of adequacy into four parts: First,
we show that the subjects of the encoding judgement are well-formed, which establishes that the encoding relates the stated object-language entities to LF terms of
the appropriate type. Second, we show that the encoding judgement relates every
informal entity to a unique LF term; third, we show that the encoding judgement
relates every canonical form of the appropriate LF type to a unique informal entity.
Because the single encoding judgement is functional in both directions, these functions are mutually inverse, yielding a bijection. Finally, we show that the encoding
commutes with substitution, establishing compositionality.

For the remainder of this section, we work in LF[\Sigma ], where \Sigma  stands for the LF
signature defined in Figure 7.

3.2.1 Types
For parallelism with later adequacy statements, we use the notation o/ type to mean
that o/ is a syntactically well-formed type. The adequacy theorem for types is degenerate: because types do not involve binding, no compositionality condition is
necessary.

Theorem 3.1 (Adequacy for Types)
The encoding relation o/ type AE M ( tp defines a bijection between the types o/
and the LF terms M such that M ( tp:

1. If o/ type AE M ( tp then o/ type and M ( tp.
2. If o/ type, there exists a unique LF term M such that o/ type AE M ( tp.
3. If M ( tp then there exists a unique o/ such that o/ type AE M ( tp.

The third part of this theorem is proved by induction on canonical forms, using a
specialized inversion principle for the canonical forms of type tp in the empty LF
context:

Lemma 3.2 (Inversion of Canonical Forms of Type tp)
If D derives M ( tp then either

* M = unit, or*

M = arrow M1 M2, and M1 ( tp and M2 ( tp were derived as strict subderivations of D.

This lemma permits a proof by induction on the derivation of M ( tp to consider
only these two cases and to appeal to induction on the strict subderivations--it is
equivalent to a specialized induction principle for the canonical forms of type tp in
the empty context.

Proof
Characterizing the canonical forms of type tp requires first characterizing the
canonical forms of certain higher types:

1. There is no R such that R ) \Pi  x1:A1. . . . \Pi  xn:An. tp for n >= 3.
2. If R ) \Pi  x1:A1. \Pi  x2:A2. tp then A1 = A2 = tp and R = arrow.

Mechanizing Metatheory in a Logical Framework 23
3. If R ) \Pi  x:A2. tp then A2 = tp, R = arrow M1, and M1 ( tp was derived as a

strict subderivation.

To prove the first part, assume there is such a term and then obtain a contradiction
by induction on the given derivation. The proofs of the next two parts proceed
by case analysis on the derivation, each using the previous part. Each proof uses
Lemma 2.13. Then the overall lemma is proved by inverting the derivation of
M ( tp and showing, in each case, that M has the required form. The proof uses
Lemma 2.13 and part 3 above.

Using this lemma, we prove adequacy:
Proof of Theorem 3.1

1. To show: If o/ type AE M ( tp then o/ type and M ( tp. We show one case.

In the case for enc tp arrow, assume as the inductive hypothesis that
o/1 type, o/2 type, M1 ( tp, and M2 ( tp. Then o/1 ! o/2 type and the judgement
arrow M1 M2 ( tp can be derived using the inductive hypotheses and the following rules: atom term app, atom term const, subst a pi, subst a p,
subst p const, and canon term atom.
2. To show: For all o/ , there exists a unique term M such that o/ type AE M ( tp.

The proof is by structural induction on o/ . We show one case.
In the case for o/1 ! o/2, we assume that there exist unique M1 and M2 such that
o/1 type AE M1 ( tp and o/2 type AE M2 ( tp. We must show that there exists a
unique M such that o/1 ! o/2type AE M ( tp. To establish existence, take M to be
arrow M1 M2. Then using enc tp arrow on the inductive hypotheses proves
that o/1 ! o/2 type AE M ( tp. To show uniqueness, assume some other M0 such
that o/1 ! o/2type AE M0 ( tp. By inversion, the only rule that can have applied
to o/1 ! o/2 is enc tp arrow, so M0 = arrow M01 M02 where o/1 type AE M01 ( tp
and o/2 type AE M02 ( tp. But then the inductive hypotheses that M1 and M2 are
unique show that M1 = M01 and M2 = M02. Therefore arrow M01 M02 = arrow M1 M2,
establishing uniqueness.
3. To show: For all M such that M ( tp, there exists a unique o/ such that

o/ type AE M ( tp. The proof is by induction on the derivation of M ( tp.
Lemma 3.2 gives two cases to consider; we show the case for M = arrow M1 M2,
where M1 ( tp and M2 ( tp were derived as strict subderivations. To show:
there exists a unique o/ such that o/ type AE arrow M1 M2 ( tp. By the inductive
hypothesis applied to the subderivations, there exist unique o/1 and o/2 such
that o/1 type AE M1 ( tp and o/2 type AE M2 ( tp. To establish existence,
take o/ = o/1 ! o/2; then enc tp arrow applied to the derivations from the
inductive hypothesis shows that o/ type AE arrow M1 M2 ( tp. To establish
uniqueness, assume some other o/ 0 such that o/ 0 type AE arrow M1 M2 ( tp. By
inversion, only the rule enc tp arrow could have applied, so o/0 = o/ 01 ! o/ 02
where o/ 01 type AE M1 ( tp and o/ 02 type AE M2 ( tp. The inductive hypothesis
that o/1 and o/2 are unique shows that o/1 = o/ 01 and o/2 = o/ 02, so o/1 ! o/2 =
o/ 01 ! o/ 02, as we needed to show.

24 Robert Harper and Daniel R. Licata

3.2.2 Terms
The following lemma, analogous to the one for tp above, gives an inversion principle
for the canonical forms of type tm:

Lemma 3.3 (Inversion of Canonical Forms of Type tm)
If X terms AE \Gamma  ctx and \Gamma  ` M ( tm then one of the following holds:*

M = x and \Gamma  = \Gamma 1, x : tm, \Gamma 2.*
M = empty.*
M = lam Mt * x. Me, where \Gamma  ` Mt ( tp and \Gamma , x : tm ` Me ( tm were derived
as strict subderivations.*
M = app M1 M2, where and \Gamma  ` M1 ( tm and \Gamma  ` M2 ( tm were derived as
strict subderivations.

This lemma states that an LF term of type tm in a context containing variables of
type tm is either a variable or a constant applied to arguments which may contain
those variables--i.e., it states that the LF term is parametric in the variables in the
context. If, hypothetically, LF had an unrestricted case-analysis construct for analyzing terms of type tm, this lemma would not be true: a case-analysis of a variable
would be an "exotic" canonical form of type tm, violating adequacy. Extensions of
LF with other types must take care to preserve this property; in Concurrent LF,
certain connectives are confined to a monad so that they do not interfere with this
style of higher-order representation (Watkins et al., 2002).

Because types appear in the syntax of terms, adequacy for terms requires adequacy for types. However, types are adequately represented in the empty LF context, whereas the judgements in Figure 8 encode terms in LF contexts of the form
x1 : tm, . . . , xn : tm. Thus, Theorem 3.1 as stated in the previous section is not strong
enough, as adequacy for terms requires that types remain adequate in these extended contexts. This requirement could fail--for example, if term contexts were
of the form x : tm, . . . , u : tp, . . ., these contexts would induce additional canonical
forms of type tp that have no informal counterpart. Consequently, it is necessary
to prove a lemma showing that types remain adequate in the contexts \Gamma  such thatX

terms AE \Gamma  ctx. This lemma is our first application of the transport of canonical
forms theorem, Theorem 2.17.

Lemma 3.4 (Transport of Adequacy for Terms)

1. If X terms AE \Gamma  ctx then \Gamma  ctx.2. If X

terms AE \Gamma  ctx then * ` Mt ( tp iff \Gamma  ` Mt ( tp.

ProofThe proof of the first part is a straightforward induction on the premise. The second

part uses transport of canonical forms (Theorem 2.17). First, one application of
Theorem 2.17 shows that * `\Sigma  M ( tp iff * `\Sigma |tp M ( tp. Next, because tm 6_ tp, a

simple induction shows that if X terms AE \Gamma  ctx then \Gamma |_\Sigma tp = *. Then the proof is
direct using Theorem 2.17 and the first part.

We now prove the main adequacy result. The judgement X ` e term is used here
to state the invariant on the encoding. When we claim uniqueness for an objectlanguage or LF entity that involves binding, we mean uniqueness up to ff-conversion.

Mechanizing Metatheory in a Logical Framework 25
Theorem 3.5 (Adequacy for Terms)

1. If X terms AE \Gamma  ctx and X ` e term AE \Gamma  ` M ( tm then X ` e term and

\Gamma  ` M ( tm.
2. If X ` e term and X terms AE \Gamma  ctx then there exists a unique LF term M

such that X ` e term AE \Gamma  ` M ( tm.
3. If \Gamma  ` M ( tm and X terms AE \Gamma  ctx then there exists a unique e such thatX `

e term AE \Gamma  ` M ( tm.

Proof

1. By rule induction on the second premise. The case for enc tm lam is the only

one in which the conclusion does not follow immediately from the inductive
hypotheses. In this case, by the inductive hypothesis, X , x ` e term and
\Gamma , x : tm ` Me ( tm. Then the first conclusion is immediate by term lam.
To derive the second conclusion, we also need to know that \Gamma  ` Mt ( tp. By
Theorem 3.1 applied to the premise of the rule, * ` Mt ( tp. Then by Lemma
3.4, \Gamma  ` Mt ( tp.
2. By rule induction on X ` e term, we show that if X terms AE \Gamma  ctx then

there exists a unique M such that X ` e term AE \Gamma  ` M ( tm. We give the
cases that involve binding:*

Case for term var. To show: if X1, x, X2 terms AE \Gamma  ctx then there exists
a unique LF term M such that X ` x term AE \Gamma  ` M ( tm. By inversion, \Gamma 
must have the form \Gamma 1, x : tm, \Gamma 2. To establish existence, use enc tm var
to derive X1, x, X2 ` x term AE \Gamma  ` x ( tm. To establish uniqueness,
assume some other M0 such that X1, x, X2 ` x term AE \Gamma  ` M0 ( tm;
inversion on this derivation gives the result because only enc tm var
can have applied.*
Case for term lam. Assume a derivation of X terms AE \Gamma  ctx. Using the
rule enc terms term, we can derive (X , x) terms AE (\Gamma , x : tm) ctx. Then
we can appeal to the inductive hypothesis to conclude that there exists a
unique canonical form Me such that X , x ` e term AE \Gamma , x : tm ` Me ( tm.
By Theorem 3.1, there exists a unique Mt such that o/ type AE Mt ( tp. To
show existence, take M to be lam Mt * x. Me; then we can derive the desired
property by applying enc tm lam to the above encoding derivations.
Uniqueness is immediate by inversion and the results above.

3. By induction on the derivation of \Gamma  ` M ( tm. Lemma 3.3 gives four cases;

we show those involving binding:*

M = x and \Gamma  = (\Gamma 1, x : tm, \Gamma 2).
By inversion on the derivation of X terms AE (\Gamma 1, x : tm, \Gamma 2) ctx, X isX

1, x, X2. Thus, we can take e to be x, which has the desired property by
enc tm var. Uniqueness is immediate by inversion.*

M = lam Mt * x. Me, where \Gamma  ` Mt ( tp and \Gamma , x : tm ` Me ( tm were
derived as subderivations.
We would like to appeal to Theorem 3.1 on the derivation of \Gamma  ` Mt ( tp
to conclude that there exists a unique o/ such that o/ type AE Mt ( tp.
Unfortunately, Theorem 3.1 is only stated for typing derivations in the

26 Robert Harper and Daniel R. Licata

empty context. Thus, we first apply Lemma 3.4 to conclude * ` Mt ( tp;
then we can appeal to Theorem 3.1.
Next, using the assumed derivation of X terms AE \Gamma  ctx, we can create a
derivation of (X , x) terms AE (\Gamma , x : tm) ctx by enc terms term. Then,
by the inductive hypothesis on the second subderivation, there exists a
unique e0 such that X , x ` e0 term AE \Gamma , x : tm ` M0e ( tm. To show
existence, we take e to be * x:o/. e0; enc tm lam applied to the derivations
produced above shows that X ` * x:o/. e0 term AE \Gamma  ` lam Mt * x. M0e ( tm.
Uniqueness is immediate by inversion and the uniqueness of e0 and o/ .

Next, we prove compositionality. The proof requires a lemma stating that a property similar to weakening holds for the encoding:

Lemma 3.6 (Weakening of the Encoding)
Assume X , X 0 terms AE \Gamma , \Gamma 0 ctx and X , x, X 0 terms AE \Gamma , x : tm, \Gamma 0 ctx. Then ifX

, X 0 ` e term AE \Gamma , \Gamma 0 ` M ( tm then X , x, X 0 ` e term AE \Gamma , x : tm, \Gamma 0 ` M ( tm.

Exchange and contraction also hold, but we do not require them in this development. Compositionality is essentially a substitution principle:

Theorem 3.7 (Compositionality for Terms)
Assume X terms AE \Gamma  ctx and X ` e2 term AE \Gamma  ` M2 ( tm.
If X , x, X 0 terms AE \Gamma , x : tm, \Gamma 0 ctx and X , x, X 0 ` e term AE \Gamma , x : tm, \Gamma 0 ` M ( tm
and [e2/x]e = e0 and [M2/x]mtmM = M0 then X , X 0 ` e0 term AE \Gamma , \Gamma 0 ` M0 ( tm.

Proof
Using Lemma 3.6, Theorem 3.1, and Lemma 2.8, we prove this theorem by induction
on the derivation of X , x, X 0 ` e term AE \Gamma , x : tm, \Gamma 0 ` M ( tm. This theorem
assumes the hereditary substitution [M2/x]mtmM = M0 only to make the inductive
argument more convenient; applying Lemma 3.4, Theorem 3.5, and Theorem 2.11
to the other assumptions shows that the substitution must exist.

3.2.3 Discussion
Transport of adequacy lemmas like Lemma 3.4 demonstrate the convenience of the
general subordination-based transport of canonical forms theorem (Theorem 2.17).
Absent this general theorem, we could prove each individual transport of adequacy
lemma inductively. Alternatively, we could state and prove every adequacy theorem
for the largest context necessary for the encoding of the entire language. Fortunately,
subordination saves us from the tedium of the first alternative and the inherent nonmodularity of the second, which requires knowing, in advance, all future uses of any
piece of the object language.

3.3 Encoding of Judgements
The judgements in Figure 9 define the static and dynamic semantics of the STLC in
informal notation. In the type system, we use fl to notate object-language contexts

Mechanizing Metatheory in a Logical Framework 27
fl ` e : o/

fl ` hi : unit of empty fl, x : o/, fl0 ` x : o/ of var
fl, x : o/2 ` e : o/
fl ` * x:o/2. e : o/2 ! o/ of lam

fl ` e1 : o/2 ! o/ fl ` e2 : o/2

fl ` e1 e2 : o/ of app

e value

hi value value empty * x:o/. e value value lam

e 7! e0

e1 7! e01
e1 e2 7! e01 e2 step app 1

e1 value e2 7! e02

e1 e2 7! e1 e02 step app 2

e2 value [e2/x]e = e0

(* x:o/2. e) e2 7! e0 step app beta

Fig. 9. Semantics of the STLC

containing assumptions of the form xi : o/i; such a context is well-formed when all
variables in it are distinct. Whenever we write fl, we tacitly presuppose that this
context is well-formed. The dynamic semantics are a standard call-by-value structural operational semantics on closed terms. The following property of the STLC
is necessary for the adequacy proofs below:

Lemma 3.8 (Uniqueness of Substitution Derivations)
If D and D0 both derive [e2/x]e = e0 then D = D0.

The LF signature in Figure 10 extends the signature from Figure 7 to represent
these judgements. The representation of the static and dynamic semantics is guided
by the judgements-as-types principle: an object-language judgement is represented
by a family of LF types indexed by the subjects of the judgement; derivations of a
judgement are represented as LF terms inhabiting this type. Such a representation
is adequate iff there is an isomorphism between the informal derivations of the
judgement and the canonical forms of the associated type family.

For instance, the operational semantics judgement e 7! e0, whose subject is two
terms, is represented by the LF type family step : tm ! tm ! type. Each constant
with head step corresponds to the object-language inference rule with the same
name. A derivation of the judgement e 7! e0 is represented by an LF term of type
step Me M0e, where Me and M0e are the encodings of e and e0. For example, assuming
terms M1, M2, and M01 of LF type tm and an LF term M ( step M1 M01, the LF term
(step app 1 M1 M2 M01 M) represents a derivation of step (app M1 M2) (app M01 M2).

The object-language hypothetical judgement fl ` e : o/ is represented by the LF
type family of, which is indexed by the LF types tm and tp. One might expect
the family to also be indexed by the encoding of a context fl. However, rather

28 Robert Harper and Daniel R. Licata

of : tm ! tp ! type
of empty : of empty unit

of app : \Pi  E1, E2:tm. \Pi  T2, T:tp.

(of E1 (arrow T2 T)) ! (of E2 T2) ! of (app E1 E2) T
of lam : \Pi  T2, T:tp. \Pi  E:tm ! tm.

(\Pi  x:tm. (of x T2) ! (of (E x) T)) ! of (lam T2 * x. E x) (arrow T2 T)

value : tm ! type
value empty : value empty

value lam : \Pi  T:tp. \Pi  E:tm ! tm. value (lam T * x. E x)

step : tm ! tm ! type
step app 1 : \Pi  E1, E2, E01:tm. (step E1 E01) ! step (app E1 E2) (app E01 E2)
step app 2 : \Pi  E1, E2, E02:tm.

(value E1) ! (step E2 E02) ! step (app E1 E2) (app E1 E02)
step app beta : \Pi  E2:tm. \Pi  E:tm ! tm. \Pi  T2:tp.

(value E2) ! step (app (lam T2 * x. E x) E2) (E E2)

Fig. 10. LF Signature for the STLC Judgements
than representing the context as an explicit argument, we represent the objectlanguage hypotheses as LF hypotheses, identifying the object-language hypothetical
judgement with a hypothetical judgement in LF. Specifically, an object-language
context

x1 : o/1, . . . , xn : o/n
is represented by an LF context

x1 : tm, dx1 : of x1 T1, . . . , xn : tm, dxn : of xn Tn
where each dxi is a fresh variable that is distinct from all xi and from the other dxj.
Each object-language hypothesis xi : o/i is represented by an LF variable dxi. Correspondingly, context extension is represented by LF terms of higher type. Consider
the object-language rule of lam:

fl, x : o/2 ` e : o/
fl ` * x:o/2. e : o/2 ! o/ of lam

In the premise of the rule, the context is extended with the assumption x : o/2 for a
fresh variable x. This rule is represented by the LF constant of lam. The premise
of of lam is represented by an LF term of type of the following dependent function
type:

\Pi  x:tm. (of x T2) ! (of (E x) T).

Mechanizing Metatheory in a Logical Framework 29
vars
flX

vars

**

vars
flX

vars
(fl,
x:
o/)

(X
,x)

flctx
AE
\Gamma ctx

*ctx
AE*
ctx
enc
ctx
em
pty

flctx
AE
\Gamma ctx

o/t
yp
eAE

Mt(
tp

fl,
x:
o/ctx

AE
\Gamma ,
x:
tm
,dx

:of
xM

tctx

enc
ctx
cons

D::
fl`

e:
o/AE

\Gamma `
M(
of
Me
Mt

fl,
x:
o/,fl

0 `

x:
o/AE

\Gamma ,
x:
tm
,dx

:of
xM

t,\Gamma 

0 `

dx(

of
xM

tenc

of
va
r

fl`
empt

y:
unit

AE
\Gamma `

of
empty

(
of
emp

ty
unit

enc
of
em
pty

D

1::

fl`

e1
:o/

2!

o/AE

\Gamma `
M1(

of
Me1

(arrow

Mt2
Mt)

D

2::

fl`

e2
:o/

2AE

\Gamma `
M2(

of
Me2

Mt2

D

1::

fl`

e1
:o/

2!

o/D

2::
fl`

e2
:o/

2

fl`
e1
e2
:o/

AE
\Gamma `

of
app

Me1
Me2
Mt2
Mt
M1
M2(

of
(app

Me1
Me2
)M

t

enc
of
app

o/2
typ

eAE

Mt2(

tp
D

1::

fl,
x:
o/2`

e:
o/AE

\Gamma ,
x:
tm
,dx

:of
xM

t2`

M2(

of
Me
Mt

D

1::

fl,
x:
o/2`

e:
o/

fl`
*x
:o/

2.e

:o/

2!

o/AE

\Gamma `
of
lam

Mt2
Mt
(*
x.
Me)

(*
x.*

dx
.M

2)(

of
(lam

Mt
(*
x.
Me))

(arrow

Mt2
Mt)

enc

of
la
m

Fig.
11.
Enco

ding
of
STL

C
Stati

cSem

an
tics

30 Robert Harper and Daniel R. Licata D

::e
value

AE
M(

value

Me

hi
value

AE
value

empty
(
value

empty

enc
va
lue

emp
ty

*`
(*
x:o/
.e)

term

AE*
`
lam

Mt
(*
x.
Me)(

tm

*x
:o/.
evalue

AE
value

lam
Mt
(*
x.
Me)

(
value

(lam
Mt
(*
x.
Me))

enc
va
lu
ela

m

D::
e7!

e0AE

M(
step
Me
M0e*`

e2
term

AE*
`
Me2(

tm
D
1::

e17!

e01AE

M1(
step
Me1
M0e1

D
1::

e17!

e01

e1
e27!

e01
e2AE

step
app
1M
e1

Me2

M0e1
M1(

step
(app
Me1
Me2
)(
app

M0e1
Me2
) enc

step
app
1

D
1::

e1
value

AE
M1(

value
Me1
D
2::

e27!

e02AE

M(
step
Me2
M0e2

D
1::

e1
value

D
2::

e27!

e02

e1
e27!

e1
e02

AE
step

app
2M
e1

Me2

M0e2
M1
M2(

step
(app
Me1
Me2
)(
app

Me1
M0e2
) enc

step
app
2

*`
(*
x:o/
2.e

)term

AE*
`
lam

Mt2
(*
x.
Me)(

tm
D
2::

e2
value

AE
M2(

value
Me2
[M
e2/

x]

mtmM

e=

M0e

D
2::

e2
value

[e
2/x

]e
=
e0

(*
x:o/
2.e

)e
27!

e0

AE
step

app
beta

Me2
(*
x.
Me)

Mt2
M2(

step
(app
(lam
Mt2
(*
x.
Me))

Me2
)M0
e

enc

step

app
bet
a

Fig.
12.
Enco

ding
of
STL

C
Dy

nam

ic
Seman

tic
s

Mechanizing Metatheory in a Logical Framework 31
The canonical forms of this type are terms * x. * dx. M, where M has LF type of (E x) T
in an LF context including x : tm, dx : of x T2. These LF assumptions correspond exactly to a derivation under the hypothesis x : o/2 for a fresh variable x. This higherorder representation of hypotheses is natural and advantageous: there is no need
to explicitly represent contexts and operations on them, and, moreover, LF provides structural properties such as weakening and substitution when hypothetical
judgements are represented in such a fashion.

The correspondence between object-language derivations and their LF representations is made precise by the judgements in Figures 11 and 12. The intended
reading of these judgements is as follows:

* fl ctx AE \Gamma  ctx Encode an object-language context fl to an LF context \Gamma .* D

:: fl ` e : o/ AE \Gamma  ` M ( of Me Mt Assuming fl ctx AE \Gamma  ctx, encode an
object-language derivation D of fl ` e : o/ to an LF term M of type of Me Mt in
\Gamma . The notation D :: fl ` e : o/ is simply linear notation forD

fl ` e : o/ .

* D :: e value AE M ( value Me Encode an object-language derivation D of

e value for a closed term e to an LF term M of type value Me in the empty LF
context.* D

:: e 7! e0 AE M ( step Me M0e Encode an object-language derivation D
of e 7! e0 for closed terms e and e0 to an LF term M of type step Me M0e in the
empty LF context.

The rule enc of lam expresses the higher-order representation strategy described
above. The rule enc step app beta includes a hereditary substitution premise
because the right-hand term of the informal rule step app beta is [e2/x]e; compositionality of the encoding (Theorem 3.7) shows that this substitution can be
represented by writing (E E2) as the right-hand term in step app beta.

These encoding judgements clarify the fact that the LF representation of the
object language judgements is specified not just by the LF signature, but also
by the LF contexts in which that signature is considered. For example, the object
language operational semantics judgement e 7! e0 presupposes that the terms e and
e0 are closed. In the LF representation, this presupposition is reflected in the fact
that we consider only the inhabitants of step in the empty LF context. Note that
the same LF signature for step, considered in other LF contexts, could adequately
represent an object-language transition system that does not presuppose closed
terms.

3.4 Adequacy of the Judgement Encodings
Let \Sigma  stand for the signature in Figure 10. When proving adequacy, we consider
each judgement of the object language in the fragment of \Sigma  relevant to it. (This is in
contrast to Section 3.2, where for simplicity we considered adequacy of both types
and terms in the full signature.) Observe by the definition of signature restriction
that

32 Robert Harper and Daniel R. Licata

* \Sigma |tp contains the family declaration tp and the constants unit and arrow.*

\Sigma |tm contains the family declarations tp, tm and their associated constants.*
\Sigma |of contains the family declarations tp, tm, of and their associated constants.*
\Sigma |value contains the family declarations tp, tm, value and their associated
constants.*
\Sigma |step contains the family declarations tp, tm, value, step and their associated constants.

The strongest subordination relation _\Sigma  is the reflexive-transitive closure of the
following relation: tp _ tm, tm _ of, tp _ of, tm _ value, tp _ value, tm _ step,
tp _ step, and value _ step. Additionally, for each a of these type families,_

\Sigma  |a =_\Sigma |a . Thus, Theorem 2.17 shows that each of these signature restrictions iswell-formed in the strongest subordination relation for it. Our previous adequacy

theorems show that the encodings of terms and types are adequate in \Sigma |tm. An easy
application of Theorem 2.17 shows that adequacy for STLC types, Theorem 3.1,
holds in \Sigma |tp as well.

3.4.1 Static Semantics
In this section, we work in LF[\Sigma |of]. Just as it was necessary to ensure that the
encoding of types remained adequate in the signature and contexts for terms, it is
now necessary to show that the encodings of both types and terms remain adequate
in the signature and contexts we consider for typing derivations:

Lemma 3.9 (Transport of Adequacy for Typing)

1. (\Sigma |of)|tp = \Sigma |tp and (\Sigma |of)|tm = \Sigma |tm.
2. If fl ctx AE \Gamma  ctx then \Gamma  ctx.
3. If fl ctx AE \Gamma  ctx then \Gamma |tp = *.
4. If fl ctx AE \Gamma  ctx, vars fl X , and \Gamma |tm = \Gamma 0 then X terms AE \Gamma 0 ctx
5. If fl ctx AE \Gamma  ctx then \Gamma  `\Sigma |of Mt ( tp iff * `\Sigma |tp Mt ( tp.
6. If fl ctx AE \Gamma  ctx then \Gamma  `\Sigma |of Me ( tm iff \Gamma |tm `\Sigma |tm Me ( tm.

Next, we state the inversion lemma:
Lemma 3.10 (Inversion of Canonical Forms of Type of)
If fl ctx AE \Gamma  ctx and \Gamma  ` M ( of Me Mt then one of the following hold:

* M = dx, Me = x, and \Gamma  = \Gamma 1, x : tm, dx : of x Mt, \Gamma 2 for some variables dx and x.*

M = of empty, Me = empty, and Mt = unit.*
M = of app Me1 Me2 Mt2 Mt M1 M2, Me = (app Me1 Me2), and the following were
derived as strict subderivations: \Gamma  ` Me1 ( tm and \Gamma  ` Me2 ( tm and
\Gamma  ` Mt2 ( tp and \Gamma  ` Mt ( tp and \Gamma  ` M1 ( of Me1 (arrow Mt2 Mt) and
\Gamma  ` M2 ( of Me2 Mt2.*
M = of lam Mt2 M0t (* x. M0e) (* x. * dx. M2), Me = (lam Mt (* x. M0e)),
Mt = (arrow Mt2 M0t), and the following were derived as strict subderivations:
\Gamma  ` Mt2 ( tp and \Gamma  ` M0t ( tp and \Gamma , x : tm ` M0e ( tm and
\Gamma , x : tm, dx : of x Mt2 ` M2 ( of M0e M0t.

Mechanizing Metatheory in a Logical Framework 33
In the statement and proof of adequacy, it will be convenient to abuse notation
by writing fl ` e term AE \Gamma  ` Me ( tm to mean the following: varsfl X and \Gamma |tm = \Gamma 0
and X ` e term AE \Gamma 0 ` Me ( tm. In Definition 2.16, we observed that given \Gamma  and
A, there exists a unique \Gamma 0 such that \Gamma |A = \Gamma 0. Observe (by induction on fl) that
given a well-formed context fl, there exists a unique X such that vars fl X . Thus,
both X and \Gamma 0 are uniquely determined when we write fl ` e term AE \Gamma  ` Me ( tm.

We can now prove adequacy. The first condition states not only that the subjects
are well-formed, as above, but also that the indices to the judgement are encoded
in the appropriate manner.

Theorem 3.11 (Adequacy for Typing Derivations)

1. If fl ctx AE \Gamma  ctx and D :: fl ` e : o/ AE \Gamma  ` M ( of Me Mt then*

o/ type AE Mt ( tp and fl ` e term AE \Gamma  ` Me ( tm,* D

derives fl ` e : o/ , and*
\Gamma  ` M ( of Me Mt.

2. If fl ctx AE \Gamma  ctx and D derives fl ` e : o/ then there exist unique Me, Mt and M

such that D :: fl ` e : o/ AE \Gamma  ` M ( of Me Mt.
3. If fl ctx AE \Gamma  ctx and \Gamma  ` M ( of Me Mt then there exist unique o/ , e, and D

such that D :: fl ` e : o/ AE \Gamma  ` M ( of Me Mt.

Proof
The proof follows the same general pattern as adequacy for syntax. It uses Lemma
3.9, Theorem 3.5, Theorem 3.1, Lemma 2.12, and Lemma 3.10.

In informal descriptions of programming languages, we do not usually consider
the operation of substituting one typing derivation into another (i.e., the computational content of the proof of the substitution theorem). However, it is possible to
define such an operation and then prove a compositionality theorem, analogous to
Theorem 3.7, for the judgement D :: fl ` e : o/ AE \Gamma  ` M ( of Me Mt. However, because this compositionality result is not necessary for the remainder of this article,
we elide the details.

3.4.2 Dynamic Semantics
The adequacy proof for the value judgement is simple; we elide the transport of
adequacy lemma and the canonical forms inversion lemma, which are analogous to
those given above.

Theorem 3.12 (Adequacy for Values)

1. If D :: e value AE M ( value Me then* * `

e term AE * ` Me ( tm,* D
derives e value, and* * `

\Sigma |value M ( value Me.
2. If * ` e term and D :: e value then there exist unique Me and M such thatD

:: e value AE M ( value Me.

34 Robert Harper and Daniel R. Licata

3. If * `\Sigma |value M ( value Me then there exist unique e and D such thatD

:: e value AE M ( value Me.

In the remainder of this section, we work in LF[\Sigma |step].
Lemma 3.13 (Transport of Adequacy for Operational Semantics)

1. For a 2 {tm, tp, value}, (\Sigma |step)|a = \Sigma |a.
2. * `\Sigma |step Me ( tm iff * `\Sigma |tm Me ( tm.
3. * `\Sigma |step Mt ( tp iff * `\Sigma |tp Mt ( tp.
4. * `\Sigma |step M ( value Me iff * `\Sigma |value M ( value Me.

Next, we state the inversion principle:
Lemma 3.14 (Inversion of Canonical Forms of Type step)
If M ( step Me M0e then one of the following hold:

* M = step app 1 Me1 Me2 M0e1 M1, Me = (app Me1 Me2), M0e = (app M0e1 Me2), and the

following were derived as strict subderivations: Me1 ( tm and Me2 ( tm and
M0e1 ( tm and M1 ( step Me1 M0e1.*
M = step app 2 Me1 Me2 M0e2 M1 M2, Me = (app Me1 Me2), M0e = (app Me1 M0e2), and
the following were derived as strict subderivations: Me1 ( tm and Me2 ( tm
and M0e2 ( tm and M1 ( value Me1 and M2 ( step Me2 M0e2.*
M = step app beta Me2 (* x. Mb) Mt2 M2, Me = (app (lam Mt2 (* x. Mb)) Me2), and
the following were derived as strict subderivations: Me2 ( tm and
x : tm ` Mb ( tm and Mt2 ( tp and M2 ( value Me2 and [Me2/x]mtmMb = M0e.

Finally, we state adequacy.
Theorem 3.15 (Adequacy for Operational Semantics)

1. If D :: e 7! e0 AE M ( step Me M0e then* * `

e term AE * ` Me ( tm and * ` e0 term AE * ` M0e ( tm,* D
derives e 7! e0, and*
M ( step Me M0e.

2. If * ` e term and * ` e0 term and D derives e 7! e0 then there exist unique

Me, M0e and M such that D :: e 7! e0 AE M ( step Me M0e.
3. If M ( step Me M0e then there exist unique e, e0, and D such thatD

:: e 7! e0 AE M ( step Me M0e.

Proof
An object-language derivation using the rule step app beta contains a subderivation deriving [e2/x]e. However, because substitution in the object-language is represented as substitution in LF, this substitution derivation is not encoded as an
explicit LF object. Consequently, it is necessary to show that there is at most
one object-language substitution derivation; Lemma 3.8 establishes this fact. Other
than this complication, the proof is similar to adequacy of typing. The proof uses
Theorem 2.11, Theorem 3.5, Theorem 3.7, Theorem 3.12, Lemma 3.13, and Lemma
3.14.

Mechanizing Metatheory in a Logical Framework 35
4 Mechanizing the Metatheory of the STLC
A metatheorem is a statement about an object language. The Twelf implementation
of LF (Pfenning & Sch"urmann, 1999) permits the mechanization of metatheorems
about languages encoded in LF.

Type Families as Relations. In describing the metatheoretic capabilities of Twelf, it
is useful to regard an LF type family as defining a relation on the family's indices,
where indices are related iff their instance of the type family is inhabited. In the
simplest case, when a type family's kind is not dependent and when only closed LF
terms are considered, a type family defines a single relation on the family's indices,
where indices are related iff the corresponding type is inhabited. For example, the
type family step : tm ! tm ! type defines a relation between two LF terms of type
tm, where E and E0 are related iff there exists an LF term D of type step E1 E2. More
formally, we say that a type family a : A1 ! . . . ! An ! type defines a relation R
on terms * ` M1 ( A1, . . . , * ` Mn ( An, where R(M1, . . . , Mn) iff there exists an LF
term D such that D ( a M1 . . . Mn.

This simple case generalizes in two ways. First, when LF terms in non-empty
contexts are considered, a type family constitutes a simultaneous definition of a
context-indexed family of relations on the type family's indices, where indices are
related by the relation for a particular context iff their instance of the family is
inhabited in that context. For example, the type family of : tm ! tp ! type defines
a context-indexed family of relations R, where each relation R\Gamma  relates terms E and
T such that \Gamma  ` E ( tm and \Gamma  ` T ( tp, and R\Gamma (E, T) holds iff there exists
an LF term D such that \Gamma  ` D ( of E T. Note that the type family constitutes
a simultaneous inductive definition of all the relations R\Gamma , as the definition of
R\Gamma  refers to other relations R\Gamma 0 (e.g., when the premise of of lam extends the
LF context). More formally, we say that a type family a : A1 ! . . . ! An ! type
defines a context-indexed family of relations R, where each R\Gamma  is a relation on terms
\Gamma  ` M1 ( A1, . . . , \Gamma  ` Mn ( An and R\Gamma (M1, . . . , Mn) iff there exists a canonical form
D such that \Gamma  ` D ( a M1 . . . Mn.

Second, the kind of a type family may in general be a dependent kind of the
form \Pi  x1:A1. . . . \Pi  xn:An. type, in which case the type family defines a dependent
relation--the types of the related terms may vary with the other indices to the
relation. In full generality, a type family a : \Pi  x1:A1. . . . \Pi  xn:An. type defines a contextindexed family of relations R, where R\Gamma  relates terms M1 such that \Gamma  ` M1 ( A1, M2
such that [M1/x1]aA1 A2 = A02 and \Gamma  ` M2 ( A02, M3 such that [M2/x2]aA2[M1/x1]aA1 A3 = A03,
and so on, and R\Gamma (M1, . . . , Mn) iff there exists a canonical form D such that \Gamma  ` D (
a M1 . . . Mn. Though we have not used any dependent kinds in the previous sections
of this article, we discuss many examples of them below.

Totality Assertions. Twelf has the ability to mechanically verify totality assertions
about LF type families. To a first approximation, a totality assertion for a type
family corresponds with the standard notion of totality for the relation defined
by the type family: a totality assertion is specified by designating some indices as

36 Robert Harper and Daniel R. Licata
inputs and the remaining indices as outputs; then the totality assertion asserts that
for all inputs, there exist outputs that stand in the relation. However, because a
type family defines a family of relations R\Gamma , the specification of a totality assertion
must also clarify for which contexts \Gamma  the relations R\Gamma  are asserted to be total. In
general, we may wish to state a totality assertion only for contexts of a particular
form--because, for example, the totality assertion may be true for contexts of one
form but false for contexts of another. To allow this, we parametrize the specification
of a totality assertion by a world (set of contexts) W, and the totality assertion
asserts that for all contexts \Gamma  2 W, the relation R\Gamma  is total.

Thus, the specification of a totality assertion for a given type family consists of
two declarations: a mode declaration, which identifies some of the family's indices
as inputs (we notate these Ai) and the others as outputs (we notate these Bj),
and a world declaration, which restricts the totality assertion to LF contexts in
a particular world W. Given these declarations, the totality assertion for a type
family is defined as follows.

Definition 4.1 (Totality Assertions)
The totality assertion for a type family a : \Pi  x1:A1. . . . \Pi  y1:B1. . . . type with inputs
A1, . . . , Am and outputs B1, . . . , Bn in world W is the proposition

For all \Gamma  2 W, for all M1 such that \Gamma  ` M1 ( A01, . . . , and Mm such that
\Gamma  ` Mm ( A0m, there exist N1 such that \Gamma  ` N1 ( B01, . . . , and Nn such that

\Gamma  ` Nn ( B0n, and D such that \Gamma  ` D ( a M1 . . . Mm N1 . . . Nn.

where we write A0i and B0j for the appropriate substitutions into Ai and Bj to account
for the dependent nature of the relation:

[Mi-1/xi-1]Ai-1 . . . [M1/x1]A1 Ai = A0i
[Nj-1/yj-1]Bj-1 . . . [N1/y1]B1 [Mm/xm]Am . . . [M1/x1]A1Bj = B0j.

For example, we may specify a totality assertion for the type family step E E0 by
declaring E an input and E0 an output and by restricting consideration to the empty
LF context. These declarations specify the following totality assertion: for all E such
that E ( tm, there exist E0 and D such that E0 ( tm and D ( step E E0. Of course,
this totality assertion for the STLC is false, as there are terms that cannot take a
step. Other judgements of an object language, such as a compiler transformation,
might in fact define total relations.

The Twelf implementation permits a totality assertion to be specified by a mode
declaration and a regular worlds declaration, which defines a world W by a regular
expression over contexts. Moreover, Twelf provides a totality declaration which
instructs Twelf to (attempt to) prove a totality assertion using a specified induction
metric. Twelf proves a totality assertion for a type family by interpreting the type
family as a higher-order logic program and proving that the logic program is total;
see Sch"urmann & Pfenning (2003) for details. As with any theorem prover for
sufficiently rich statements, there are many true totality assertions that Twelf is
unable to prove. In the remainder of this section, we present many examples of type

Mechanizing Metatheory in a Logical Framework 37
families that Twelf can prove total, and we discuss how totality assertions are used
in mechanizing metatheory.

Mechanizing Metatheory. The machinery of totality assertions can be deployed in
a particular way to permit the mechanical verification of a much wider class of
metatheorems than totality assertions themselves. General 89-statements of the
form

For all \Gamma  2 W, for all M1 such that \Gamma  ` M1 ( A1, . . . , and Mm such that
\Gamma  ` Mm ( Am, there exist N1 such that \Gamma  ` N1 ( B1, . . . , and Nn such that

\Gamma  ` Nn ( Bn.

can be mechanized in Twelf. A proof of a 89-statement consists of a transformation
from the universally quantified terms (inputs) into the existentially quantified terms
(outputs), typically defined by induction on the inputs. One way of presenting
such a transformation is as a total relation. Consequently, a 89-statement and its
inductive proof can be represented as an LF type family and verified by Twelf's
totality checker. Specifically, a statement of this form can be translated into the
type family, mode, and worlds declarations specifying the totality of a type family
a : \Pi  x1:A1. . . . \Pi  yn:Bn. type. An inductive proof of such a statement can be translated
into LF constants that inductively define the type family a in such a way that
Twelf can verify the its totality. The original 89-statement is a corollary of the
totality assertion for this particular relation. That is, we deploy Twelf's ability
to prove totality assertions in order to check proofs of general 89-statements by
representing these proofs explicitly as LF terms. A successful proof constitutes a
sufficiently detailed definition of a relation that Twelf can verify its totality.

This methodology is useful because a wide class of metatheorems can expressed
as 89-statements about the canonical forms of LF. Because of the judgements-astypes representation strategy, the quantifiers of 89-statements range over not just
the representations of object-language individuals such as terms and types but also
the representations of derivations of object-language judgements. For example, the
standard informal statement of preservation is the following:

Theorem 4.2 (Informal Statement of Preservation)
For all types o/ and all closed terms e and e0, if e 7! e0 and * ` e : o/ then * ` e0 : o/ .

By adequacy (Theorem 3.1, Theorem 3.5, Theorem 3.11, and Theorem 3.15), this
statement can be recast as the following 89-statement:

Theorem 4.3 (Statement of Preservation via the Encoding)
For all E such that E ( tm, E0 such that E0 ( tm, T such that T ( tp, Dstep such
that Dstep ( step E E0, and Dof such that Dof ( of E T, there exists a D0of such that
D0of ( of E0 T.

To prove this statement in Twelf, we recast the informal proof of preservation as
constants inhabiting an LF type family

preserv : \Pi  E:tm. \Pi  E0:tm. \Pi  T:tp. step E E0 ! of E T ! of E0 T ! type.

38 Robert Harper and Daniel R. Licata
The type family preserv has a dependent kind, accounting for the occurrences
of the metavariables in the theorem statement. Then, we ask Twelf to verify the
appropriate totality assertion:

Theorem 4.4 (Totality of Preservation)
For all E such that E ( tm, E0 such that E0 ( tm, T such that T ( tp, Dstep such
that Dstep ( step E E0, and Dof such that Dof ( of E T, there exist D0of such that
D0of ( of E0 T and D such that D ( preserv E E0 T Dof Dstep D0of.

To state and prove preservation, it suffices to consider a 89-statement for the
world containing only the empty LF context. In general, 89-statements about nonempty LF contexts are useful for stating properties of object languages encoded
using higher-order representations. For example, we may recast a statement about
STLC typing derivations in non-empty contexts fl as a statement about LF terms
of type of in contexts \Gamma  such that fl ctx AE \Gamma  ctx. We prove such a statement
in Twelf by verifying the totality assertion for a corresponding type family in an
appropriate world.

In summary, proving an informal 89-statement about an object language in Twelf
requires four steps. First, via adequacy, recast the metatheorem as a 89-statement
about canonical forms of particular types in a particular world. Second, define a
corresponding LF type family r and annotate it with mode and worlds declarations
specifying the corresponding totality assertion. Third, extend the LF signature with
constants inhabiting r for all canonical inputs. Fourth, ask Twelf to verify that r
satisfies the totality assertion by executing a totality declaration. In the remainder
of this section, we show several examples of this methodology for mechanizing
metatheorems in Twelf.

Twelf Concrete Syntax. In this section, we will use Twelf's concrete syntax for LF.
The type \Pi  x:A2. A is written as {x:A2} A, the kind \Pi  x:A2. K is written as {x:A2} K,
and the term * x. M is written as [x] M. Parentheses are used for grouping, and the
usual *-calculus associativities and precedences apply: application associates to the
left; ! associates to the right; the scope of a binder extends as far to the right
as possible. Twelf's concrete syntax also includes several conveniences that we will
exploit:*

When declaring a constant in a signature, if an identifier beginning with a
lower-case letter is not bound, Twelf reports an error. If an identifier beginning
with an upper-case letter is not bound, Twelf implicitly binds it in a \Pi  at the
front of the constant's type or kind. The application of a constant to these
implicit arguments is then inferred.*
Twelf allows a programmer to write an arrow type A -> B with a backward
arrow--B <- A. This makes it easier to see the head family of a constant.*
Twelf allows arbitrary type annotations by writing M : A in place of any M.*
Twelf permits non-canonical forms, which are treated as syntactic sugar for
the corresponding canonical form.

In Figure 13, we present an example of the first two conveniences: we show Twelf
concrete syntax for the signature from Figure 10 defining the static and dynamic

Mechanizing Metatheory in a Logical Framework 39
of : tm -> tp -> type.
of_empty : of empty unit.
of_lam : of (lam T2 ([x] E x)) (arrow T2 T)

<- ({x:tm} (of x T2) -> (of (E x) T)).
of_app : of (app E1 E2) T

<- of E2 T2
<- of E1 (arrow T2 T).

value : tm -> type.
value_empty : value empty.
value_lam : value (lam T2 ([x] E x)).

step : tm -> tm -> type.
step_app_1 : step (app E1 E2) (app E1' E2)

<- step E1 E1'.
step_app_2 : step (app E1 E2) (app E1 E2')

<- step E2 E2'
<- value E1.
step_app_beta : step (app (lam T2 ([x] E x)) E2) (E E2)

<- value E2.

Fig. 13. Static and Dynamic Semantics for the STLC in Twelf Concrete Syntax

semantics of the STLC. In idiomatic Twelf, it is common to reverse the order of the
premises so that they read, from top to bottom, in the same order as they would
read from left to right in an inference rule; however, to keep the order of arguments
consistent with the signature in Figure 10, we have not done this here.

4.1 Type Preservation
Type preservation is our first example of a Twelf metatheorem.

4.1.1 Twelf Proof
Figure 14 contains a complete Twelf proof of preservation for the STLC. The type
family preserv defines a relation among the appropriate types. The %mode and
%worlds declarations state the appropriate totality assertion: the mode declaration
declares that the first two indices of preserv are universally quantified (+), whereas
the last one is existentially quantified (-). Implicitly quantified variables are universally quantified if they appear in any inputs and existentially quantified if they
appear only in outputs, so in this case E, E0, and T are all inputs. The %worlds
declaration declares that these quantifiers range over canonical forms in the world
containing only the empty LF context.

The term-level constants preserv app 1, preserv app 2, and preserv app beta
constitute an inductive definition of the preserv type family, codifying the cases of
the proof of the 89-theorem. We prove preservation by induction on the operational
semantics, writing one LF constant (i.e., case of the proof) for each operational semantics rule. For example, consider preserv app 1. The intuitive reading of this

40 Robert Harper and Daniel R. Licata
preserv : step E E' -> of E T -> of E' T -> type.
%mode preserv +Dstep +Dof -Dof'.

preserv_app_1 : preserv

(step_app_1 (DstepE1 : step E1 E1'))
(of_app (DofE1 : of E1 (arrow T2 T))

(DofE2 : of E2 T2))
(of_app DofE1' DofE2)
<- preserv DstepE1 DofE1 (DofE1' : of E1' (arrow T2 T)).

preserv_app_2 : preserv

(step_app_2 (DvalE1 : value E1) (DstepE2 : step E2 E2'))
(of_app (DofE1 : of E1 (arrow T2 T))

(DofE2 : of E2 T2))
(of_app DofE1 DofE2')
<- preserv DstepE2 DofE2 (DofE2' : of E2' T2).

preserv_app_beta : preserv

(step_app_beta (Dval : value E2))
(of_app (of_lam (([x] [dx] DofE x dx)

: {x : tm} (of x T2) -> (of (E x) T)))
(DofE2 : of E2 T2))
(DofE E2 DofE2).

%worlds () (preserv _ _ _).
%total D (preserv D _ _).

Fig. 14. Twelf Proof of Preservation for the STLC

case is as follows: in the case for step app 1, we invert the typing derivation because of app is the only rule that could have applied, yielding typing derivations
for E1 and E2; we then appeal inductively to preserv on the smaller step derivation
DstepE1 and the typing derivation DofE1 for E1, which yields a typing derivation
DofE10 for E10; then we apply the rule of app to this derivation and the derivation for E2 to obtain the result. More formally, preserv app 1 is an LF constant
inhabiting the family

preserv (step app 1 Dstep1) (of app DofE1 DofE2) (of app DofE10 DofE2)
as long as the family preserv Dstep1 DofE1 DofE2 is inhabited. This extends the
canonical forms that are related by preserv. The fact that the premise of the
constant is on a smaller step derivation Dstep1 is used in showing the totality of
preserv. The constant preserv app 2 is similar. In preserv app beta, the intuitive reading is that we invert twice based on the syntactic form of the term on the
left-hand side of the step derivation; then we apply the hypothetical typing derivation for the body of the function DofE to the argument E2 and its typing derivation
DofE2--because of the higher-order encoding, there is no need for a substitution
lemma. Of course, preserv app beta is in fact just an LF constant inhabiting the
type preserv for particular indices. The type annotations on each constant are

Mechanizing Metatheory in a Logical Framework 41
included only for readability; if we omitted their types, Twelf would infer them.
The %total declaration asks Twelf to verify, by induction on the first argument D,
that preserv satisfies the totality assertion in Theorem 4.4.

4.1.2 Correctness of the Statement of Preservation
In the introduction to this section, we stated the equivalence of the informal statement of preservation (Theorem 4.2) and the statement via the encoding (Theorem
4.3). We discuss the proof of this equivalence in more detail here. The quantifiers
and their types clearly correspond, so adequacy should imply the equivalence of
these two statements. However, there are two ways in which the previous adequacy
statements could fail to give the necessary result:

1. Though we did not make this explicit in the introduction to this section,

the Twelf proof proves Theorem 4.3 in a different signature than the one
in which the relevant types are adequate: the type family preserv and the
terms inhabiting it extend the LF signature. It is necessary to check that the
previous adequacy results can be transfered to this extended signature.
2. The %worlds declaration specifies the class of LF contexts for the metatheorem. It is necessary to check that the previous adequacy results give the
desired correspondence in these contexts.

To address the first concern, let \Sigma  be the original signature in Figure 10, and call
the extension of this signature with preserv and its constants \Sigma 0. The strongest
subordination relation _\Sigma 0 extends _\Sigma  with the conditions that a _\Sigma 0 preserv for
all a declared in \Sigma , but in _\Sigma 0 no additional families are subordinate to any family
declared in \Sigma . With this subordination relation, we can calculate that \Sigma 0|of = \Sigma |of
and \Sigma 0|step = \Sigma |step. Therefore, Theorem 2.17 immediately implies the following
lemma:

Lemma 4.5 (Transport of Adequacy for Preservation)

1. * `\Sigma 0 M ( of Me Mt iff * `\Sigma |of M ( of Me Mt.
2. * `\Sigma 0 M ( step Me M0e iff * `\Sigma |step M ( step Me M0e.

To address the second concern, observe that the %worlds declaration asserts the
theorem only for canonical forms in the empty LF context. The previous adequacy
results (Theorem 3.1, Theorem 3.5, Theorem 3.11, and Theorem 3.15) show that
the empty LF context adequately represents types, closed terms, typing derivations
in the empty object-language context, and operational semantics derivations.

4.1.3 Correctness of the Proof of Preservation
In processing the %total declaration, Twelf automatically verifies that preserv
satisfies the totality specification in Theorem 4.4. However, we can also prove the
totality of this relation by hand.

Proof of Theorem 4.4

42 Robert Harper and Daniel R. Licata
%% identity (alpha-equivalence) of terms
id : tm -> tm -> type.
refl : id E E.

%% application congruence lemma for identity
id_app_cong : id E1 E1'

-> id E2 E2'
-> id (app E1 E2) (app E1' E2')
-> type.
%mode id_app_cong +X1 +X2 -X3.

- : id_app_cong refl refl refl.
%worlds () (id_app_cong _ _ _).
%total {} (id_app_cong _ _ _).

%% determinacy of evaluation
det : step E E' -> step E E'' -> id E' E'' -> type.
%mode det +X1 +X2 -X3.

det-1 : det (step_app_1 DstepE1') (step_app_1 DstepE1'') DidApp

<- det DstepE1' DstepE1'' DidE1
<- id_app_cong DidE1 refl DidApp.

det-2 : det (step_app_2 _ DstepE2') (step_app_2 _ DstepE2'') DidApp

<- det DstepE2' DstepE2'' DidE2
<- id_app_cong refl DidE2 DidApp.

det-b : det (step_app_beta _) (step_app_beta _) refl.
%worlds () (det _ _ _).
%total D (det D _ _).

Fig. 15. Twelf Proof of Determinacy of the STLC Operational Semantics

In what follows, we work in LF[\Sigma 0]. Take \Gamma  to be *. Lemma 4.5 above justifies
appealing to Lemma 3.10 and Lemma 3.14 on derivations of * `\Sigma 0 M ( of Me Mt and* `

\Sigma 0 M ( step Me M0e. Because preservation is proved by induction on the dynamicsemantics derivation, we can use Lemma 3.14 on

Dstep. This gives three cases to

consider. In each case, we use Lemma 3.10 to invert Dof. In the case for step app 1,
the inductive hypothesis gives an inhabitant of the premise of preserv app 1. The
case for step app 2 is similar. In the case for step app beta, we use Theorem 2.11
to instantiate the hypothetical typing derivation for the body of the function--
because of the higher-order encoding, substitution for LF is used where one would
expect to use substitution for the object language.

Mechanizing Metatheory in a Logical Framework 43

4.2 Determinacy
Next, we show that the STLC's operational semantics are deterministic. This example illustrates several additional aspects of Twelf metatheory: we show how to
give a simple representation of object-language ff-equivalence as an LF type family;
we show how to use a lemma in a Twelf proof; and we illustrate a circumstance in
which Twelf's metatheorem checker allows vacuously-true proof cases to be elided.
Determinacy is stated as follows:

Theorem 4.6 (Informal Statement of Determinacy)
For closed terms e, e0, and e00, if e 7! e0 and e 7! e00 then e0 =ff e00.

Translating this informal statement into Twelf requires representing ff-equivalence
of STLC terms as an LF type family. Because of our higher-order representation
strategy, ff-equivalence is an intrinsic property of the representation: two objectlanguage terms are ff-equivalent iff their representations are ff-equivalent canonical
forms in LF (by Theorem 3.5). Consequently, we can represent object-language
ff-equivalence by internalizing ff-equivalence of LF terms as a type family. The
type family id at the top of Figure 15 does just this. For each E of type tm, there
is one canonical form inhabiting id, refl E, expressing reflexivity (recall Twelf's
convention that the variable E in the type of refl is implicitly quantified). With
this definition, id E E0 is inhabited exactly when the canonical forms E and E0 are ffequivalent in LF. There is no need to give an inductive definition of ff-equivalence,
as one would give for raw abstract syntax trees.

Using id, the informal statement of determinacy can be rephrased as follows:

Theorem 4.7 (Statement of Determinacy via the Encoding)
For all E, E0, E00 such that E, E0, E00 ( tm, D0 such that D0 ( step E E0, and D00 such
that D00 ( step E E00, there exists a D such that D ( id E0 E00.

Adequacy (Theorem 3.5, Theorem 3.15, and the fact that id corresponds to objectlanguage ff-equivalence) implies that this theorem statement is equivalent to the
informal statement in Theorem 4.6.

Figure 15 contains a complete Twelf proof of determinacy. The theorem statement
in Theorem 4.7 is represented by the type family det and its mode and world
declarations in Figure 15, which state the corresponding totality assertion for the
relation defined by the constants in the figure.

This proof uses a lemma, represented by the type family id app cong, its mode
and world declarations, and its inhabitants. This lemma states a congruence property of ff-equivalence: two applications are identical if their subterms are identical.
The proof of this lemma has exactly one case, in which the two subterm equalities
were both derived using reflexivity; in this case, the applications are identical, so
reflexivity gives the result. (In the Twelf concrete syntax, the application of refl
to its implicit term argument is suppressed, so all three derivations are written
simply as refl.) The %total declaration for id app cong uses the empty lexicographic termination metric {} because the proof is not inductive. The totality of
this lemma justifies using it as a premise in any future proof to produce a derivation

44 Robert Harper and Daniel R. Licata
of id (app E1 E2) (app E1' E2') from two input derivations of the appropriate
type.

The three constants with head det, named det-1, det-2, and det-b, define the
relation that proves determinacy. In each of these three cases, the two step derivations conclude with the same final rule. In the case labeled det-1 for step app 1, we
are given a derivation of the judgement step (app E1 E2) (app E01 E2) and a derivation
of step (app E1 E2) (app E001 E2) with subderivations of step E1 E01 and step E1 E001 .
The det premise represents an appeal to the inductive hypothesis on the two
subderivations, concluding that id E01 E001 . The id app cong premise appeals to the
lemma on this identity derivation to conclude that the applications are equal. The
case det-2 is similar. When a step derivation ends with step app beta, the lefthand term completely determines the right-hand term, so in the case det-b the
result is immediate by reflexivity. The %total declaration instructs Twelf to check
that this type family represents a total relation by induction on the first step
derivation--though, because of the symmetry, using the second derivation would
also suffice. The totality of id_app_cong is used as a lemma in showing the totality of det--for example, it is used to show the existence of an inhabitant of
id_app_cong DidE1 refl DidApp for some DidApp given DidE1 and refl.

Twelf successfully proves the totality of det, even though the relation contains
only cases where the final rule used in both step derivations is the same. This
is because the off-diagonal cases are all vacuously true--and moreover, Twelf's
metatheorem checker rules out these contradictory cases automatically. For example, if one derivation concluded with step app 1 and the other with step app 2,
then there would be subderivations concluding both value E1 and step E1 E01. These
two types can never be simultaneously inhabited: step is only inhabited when E1 is
an application, and there is no rule inhabiting value for an application. Similarly,
if one derivation concluded with step app 1 and the other with step app beta,
subderivations would give a step derivation whose left-hand side is a lam, which
cannot exist. The other off-diagonal cases can be contradicted in a similar manner.
Twelf's coverage checker rules out cases like these where the inputs to a metatheorem result in an uninhabited instance of some type family (Sch"urmann & Pfenning,
2003). This feature both eases the development of Twelf proofs and keeps these
details from cluttering the final product. As another example, in the companion
Twelf code, we give a proof of progress for the STLC that exploits this feature to
avoid an explicit canonical forms lemma.

4.3 Strengthening
The strengthening property of the STLC is stated as follows:
Theorem 4.8 (Informal Statement of Strengthening)
If fl, y : o/0 ` e : o/ and y # e then fl ` e : o/ .

Strengthening is easy to prove if all types are inhabited (simply substitute any
term of the appropriate type for y), but the proof we give in this section handles
uninhabited types as well. This theorem might, na"ively, seem difficult to prove for

Mechanizing Metatheory in a Logical Framework 45
our higher-order representation of the object language, as it requires a detailed
statement about variables that would seem to require their representation as data.
In this section, we give a simple Twelf proof of this property without sacrificing the
higher-order representation. Strengthening illustrates three additional features of
Twelf metatheory: it is a theorem stated for a non-trivial world; its proof appeals
to induction in an extended LF context; and its proof illustrates a common Twelf
device for handling the variable case of a theorem.

To formalize the statement of strengthening in Twelf, we will need to capture
the condition y # e, that the variable y is not free in the term e. However, under
the representation strategy defined in Figure 8, the variable y is free in the term
e exactly when the LF variable y is free in the term Me representing e. Therefore,
adequacy (Theorem 3.1, Theorem 3.5, Theorem 3.11) implies that this informal
statement of strengthening is equivalent to the following, where we let Wof consist
of all contexts \Gamma  such that fl ctx AE \Gamma  ctx and we work in LF[\Sigma ], where \Sigma  is the
signature for the STLC in Section 3.

Theorem 4.9 (Statement of Strengthening via the Encoding)
For all \Gamma  2 Wof, for all E such that \Gamma  ` E ( tm, T and T0 such that \Gamma  ` T, T0 ( tp,
and D such that \Gamma , y : tm, dy : of y T0 ` D ( of E T, there exists a D0 such that
\Gamma  ` D0 ( of E T.

Unlike preservation, which was stated for the world {*}, this theorem is stated
for a world Wof containing the representations of object-language typing hypotheses. The world declaration is critical for equivalence with the informal statement in
Theorem 4.8--for example, if this theorem were stated for the world {*} like preservation, the LF statement would only adequately correspond to a weaker theorem
about object-language typing derivations in the empty context. Moreover, the proof
we give below requires the more general inductive hypothesis, so it would not suffice
to prove the weaker theorem, even if that were the informal theorem of interest.

The statement of Theorem 4.9 is almost in the form supported by Twelf, but the
condition \Gamma , y : tm, dy : of y T0 ` D ( of E T is in a context other than \Gamma , which is
not permitted. However, it is simple to put it in the correct form by abstracting
over the extra variables y and dy, premising the theorem on a term of higher LF
type. The revised theorem is as follows:

Theorem 4.10 (Revised Statement of Strengthening)
For all \Gamma  2 Wof, for all E such that \Gamma  ` E ( tm, T and T0 such that \Gamma  ` T, T0 (
tp, and D such that \Gamma  ` D ( \Pi  y:tm. of y T0 ! of E T , there exists a D0 such that
\Gamma  ` D0 ( of E T.

4.3.1 Twelf Proof
This 89-statement is translated into the Twelf type family, mode, and worlds declaration in Figure 16. The only subtlety in the type family and mode declarations is
that T0, E, and T are tacitly universally quantified at the outside by Twelf's implicit

46 Robert Harper and Daniel R. Licata
strengthen : ({y : tm} of y T0 -> of E T)

-> of E T
-> type.
%mode strengthen +X1 -X2.

str-e : strengthen

([y] [dy : of y T0] of_empty)
of_empty.

str-a : strengthen

([y] [dy : of y T0]

(of_app

((Dof1 : {y} of y T0 -> of E1 (arrow T2 T)) y dy)
((Dof2 : {y} of y T0 -> of E2 T2) y dy)))
(of_app Dof1' Dof2')
<- strengthen Dof1 (Dof1' : of E1 (arrow T2 T))
<- strengthen Dof2 (Dof2' : of E2 T2).

str-l : strengthen

([y] [dy : of y T0]

(of_lam ([x] [dx : of x T2]

(Dof : {y} of y T0 -> {x} of x T2 -> of (E x) T)
y dy x dx)))
(of_lam Dof')
<- ({x} {dx : of x T2}

strengthen ([y] [dy : of y T0] Dof y dy x dx)

((Dof' : {x} of x T2 -> of (E x) T) x dx)).

%block ofblock : some {T : tp} block {x : tm} {dx : of x T}.
%worlds (ofblock) (strengthen _ _).
%total D (strengthen D _).

Fig. 16. Incomplete First Attempt to Prove Strengthening for the STLC

arguments convention. The %block and %worlds declaration are Twelf's concrete
syntax for defining the world Wof. The block declaration defines a context block
called ofblock containing the declarations x : tm, dx : of x T for some term T ( tp.
The %worlds declaration states strengthen for the world of LF contexts containing any number of ofblocks. This set of contexts corresponds exactly to those for
which the judgement fl ctx AE \Gamma  ctx is derivable.

Figure 16 contains an incomplete first proof attempt; it is instructive to see
where this proof fails, and the modification necessary to correct the proof is small.
The constants str-e, str-a, and str-l give an inductive definition of the relation
strengthen. The case str-e is simple: when the open typing derivation was derived
by the rule of_empty, the conclusion can be derived by of_empty because this
constant does not mention the variables (this corresponds to the fact that the onpaper rule of empty is stated for an arbitrary context fl). The case str-a applies
when the open derivation was constructed with the rule of_app, in which case the
subderivations Dof1 and Dof2 can potentially mention y and dy. However, because

Mechanizing Metatheory in a Logical Framework 47
y is not free in (app E1 E2), it is not free in the subterms, so by induction on each
subderivation (two strengthen premises to the constant), we can create derivations
of the same facts that do not mention y and dy; then reapplying the constant of_app
gives the result.

The case str-l is slightly more involved because it passes under a binder. It
is helpful to first consider how this case would proceed on paper. The input is a
derivation of

fl, y : o/0, x : o/2 ` e : o/
fl, y : o/0 ` * x:o/2. e : o/2 ! o/ of lam

where y # * x:o/2. e. Under this condition, y # e as well, so we can use exchange for
the object language typing judgement to permute the assumptions y : o/0 and x : o/2
and then appeal to the inductive hypothesis on a derivation in the extended context
\Gamma , x : o/2, y : o/0 to give a derivation of fl, x : o/2 ` e : o/ . Then reapplying of lam gives
the result.

The Twelf case is precisely analogous. When the last rule applied was of lam, the
subderivation Dof in an extended context is represented by an LF term of function
type {y} of y T0 -> {x} of x T2 -> of (E x) T. Observe that the arguments
to the function are the encoding of the assumptions (other than fl) in the premise of
of lam. Because the term lam ([x] E x) is well-formed without y in the context,
E can only mention the free variable x. The inductive call to strengthen takes place in
a context extended with x : tm, dx : of x T2; this is represented by giving the constant
str-l a higher-order premise that abstracts over these two variables. Observe that
this context extension stays in Wof; if this were not the case, Twelf would report
an error, signaling that the inductive hypothesis of the totality assertion for this
relation, which is stated only for contexts in Wof, would not apply. The use of
exchange is implicit in the fact that the strengthening variables for the inductive
call are bound inside this dependent function type. The inductive call outputs a
derivation Dof' that can mention only the bound variables x and dx, and then
applying the constant of_lam gives the result.

Though each of these three cases is correct, they do not satisfy the totality
assertion defined by the mode and worlds declarations. Specifically, this relation
does not cover the typing derivation given by a variable dx in the context--there
is no inhabitant of the type strengthen ([y] [dy] dx) D for variables dx. In an
informal proof, this is the case for of var: assume y # x and fl, y : o/0 ` x : o/ , then
the variable x must be bound in fl, so of var derives the conclusion.

It may not be immediately obvious how to formalize a case for a variable--where
can one even mention an arbitrary LF variable dx from the context? In Twelf, such
cases can be covered by putting the case for theorem in the context itself. Proofs of
metatheorems are simply constants of particular types, so the standard apparatus of
hypotheses can be deployed to cover cases for variables. For this theorem, whenever
we assume a typing derivation dx, we also assume a case of strengthen for it.
Instead of proving the theorem for contexts in Wof, we prove it for a world Wstr,
which contains contexts of the form

x : tm, dx : of x T2, dstr : \Pi  T0:tp. strengthen (* y. * dy. dx) dx, . . .

48 Robert Harper and Daniel R. Licata
strengthen : ({y : tm} of y T0 -> of E T)

-> of E T
-> type.
%mode strengthen +X1 -X2.

%% str-e and str-a are unchanged
str-l : strengthen

([y] [dy] (of_lam ([x] [dx] Dof x dx y dy)))
(of_lam Dof')
<- ({x} {dx : of x T2}

{_ : {T0:tp} strengthen ([y] [dy : of y T0] dx) dx}
strengthen ([y] [dy] Dof x dx y dy) (Dof' x dx)).

%block strblock : some {T : tp}

block {x : tm} {dx : of x T}
{_ : {T0:tp} strengthen ([y] [dy : of y T0] dx) dx}.

%worlds (strblock) (strengthen _ _).
%total D (strengthen D _).

Fig. 17. Completed Proof of Strengthening for the STLC

As in the informal proof, the variable typing derivation dx is the necessary output in
this case. Another way to understand these contexts is to recall that an LF variable
stands for all possible substitution instances--by insisting that contexts have this
particular form, we are restricting the substitution instances for x and dx to those
for which strengthening holds.

Figure 17 contains the completed proof. The theorem statement has changed
according to the above discussion: the block strblock declares blocks of the above
form, and the worlds declaration states the theorem for the world generated by
this block. The theorem case in the block defines the relation strengthen for the
canonical forms that were not covered in the previous attempt. Only one other
change to the previous proof is necessary: the inductive call in str-l adds the
strengthen case to the context to stay in the world for which the theorem is
stated.

4.3.2 Correctness of the Statement of Strengthening
Let \Sigma 0 stand for the extension of the signature \Sigma  from Section 3 with the constants for strengthen. The above Twelf proof implies the following statement of
strengthening, which is stated in LF[\Sigma 0].

Theorem 4.11 (Statement of Strengthening in Wstr)
For all \Gamma  2 Wstr, for all E such that \Gamma  ` E ( tm, T and T0 such that \Gamma  ` T, T0 ( tp,
and D such that \Gamma  ` D ( \Pi  y:tm. of y T0 ! of E T, there exists a D0 such that
\Gamma  ` D0 ( of E T.

Mechanizing Metatheory in a Logical Framework 49
weaken : {T0} of E T -> ({x} (of x T0) -> of E T) -> type.
%mode weaken +X1 +X2 -X3.

- : weaken T0 D ([x] [dx] D).
%worlds (ofblock) (weaken _ _ _).
%total {} (weaken _ _ _).

Fig. 18. Direct Twelf Proof of Weakening for the STLC

This theorem differs from our desired theorem statement (Theorem 4.10) in two
ways: it is stated for an extended signature \Sigma 0 and for a different world Wstr.
Thus, it is possible that we successfully proved the wrong theorem. For example,
Theorem 4.11 might not cover all object-language typing derivations, or it might
assume some additional typing derivations that have no informal counterpart. To
assuage these concerns, we should check that Theorem 4.11 implies Theorem 4.10.
Because the only differences between these two theorems are the LF signature and
world, it should not be surprising that the content of this theorem is a transport of
adequacy result:

Lemma 4.12 (Transport of Adequacy for strengthen)

1. \Sigma 0|of = \Sigma |of.
2. For all \Gamma 0 2 Wof, there exists a \Gamma  2 Wstr such that \Gamma |_\Sigma 0of = \Gamma 0.

Proof
Observe that _\Sigma 0 adds the edges tm _\Sigma 0 strengthen, tp _\Sigma 0 strengthen, and
of _\Sigma 0 strengthen to _\Sigma . The first part is true by calculation. The second part
can be proved by a simple induction on the number of blocks in \Gamma . For any ofblock
of the form x : tm, dx : of x T there is a strblock

x : tm, dx : of x T, strx : \Pi  T0:tp. strengthen (* y. * dy. dx) dx
because the indices to the theorem case for strengthen mention only terms bound
in the ofblock; the restriction of this block to of is the original block.

Using this lemma and Theorem 2.17, the proof that Theorem 4.11 implies Theorem 4.10 is direct. Thus, the Twelf proof does indeed prove the informal statement
that we wanted to show.

4.3.3 Contrasting Strengthening with Weakening
Whereas strengthening requires an inductive proof, weakening can be proved directly, as we show in Figure 18. The type argument T0 is made explicit so that it
can be universally quantified; otherwise, it would be existentially quantified because
it would appear only in an output. The proof of weaken includes only one case, in
which, given a derivation of of E T, we introduce functions to create a derivation
that is abstracted over x and dx. The fact that this LF constant is well-typed

50 Robert Harper and Daniel R. Licata
%% previously proved congruence lemma for identity
id_app_cong : id E1 E1'

-> id E2 E2'
-> id (app E1 E2) (app E1' E2')
-> type.
%mode id_app_cong +X1 +X2 -X3.
%worlds () (id_app_cong _ _ _).

%% all free variables of a well-typed term must have a typing assumption
%% in the context
all_declared : ({y : tm} of (E y) T)

-> ({y : tm} id (E y) E')
-> type.
%mode all_declared +X1 -X2.

- : all_declared ([y] of_app (D1 y) (D2 y)) DidApp

<- all_declared D1 (Did1 : {y:tm} id (E1 y) E1')
<- all_declared D2 (Did2 : {y:tm} id (E2 y) E2')
<- ({y : tm} id_app_cong (Did1 y) (Did2 y) (DidApp y)).

...
%worlds (ofblock) (all_declared _ _).
%total D (all_declared D _).

Fig. 19. Excerpt of Twelf Proof of Motivating Example for World Subsumption

corresponds with weakening being admissible in LF: the use of the variable D is
insensitive to which other variables are in the LF context, so we may derive

. . . , D : of E T, x : tm, dx : of x T0 ` D ) of E T
by atom term var, and then use canon term atom and canon term lam to
introduce the functions.

It may at first seem curious that there is such a direct proof of weakening but
not of strengthening--why does strengthening for LF not give the result? In this
instance, strengthening for LF would prove the following:
If \Gamma , y : tm, dy : of y T0 ` D ( of E T and neither y nor dy are free in E or D, then
\Gamma  ` D ( of E T.
That is, strengthening in LF only allows the variables to be dropped when they
are known not to be free in the derivation D. In the statement of strengthening
in Theorem 4.9, the variable y is not free in the term E, but both variables may
appear in the derivation D. This stronger statement of strengthening requires an
inductive proof even when the weaker version does not; indeed, one can imagine
object languages where the weaker statement is true but the stronger one is not.

Mechanizing Metatheory in a Logical Framework 51

4.4 World Subsumption

4.4.1 Motivating Example
When proving theorems that are stated for a non-trivial LF world, it is common to
want to use a lemma that is stated for one world in the proof of a theorem stated
for another. We illustrate this with the following (somewhat contrived) theorem:

Theorem 4.13
If fl ` e : o/ , where X , y, X 0 ` e term but y is not in fl, then y # e.

That is, all free variables in a well-typed term must be declared in the context.

Figure 19 contains an excerpt of a Twelf proof of this theorem (see the companion Twelf code for the remaining cases, which are simple but not necessary for
the discussion in this section). The premise that fl ` e : o/ , where y is potentially
free in e but is not declared in fl, is represented by the input LF term of type
({y : tm} of (E y) T)--the term E may potentially mention the variable y, but
there is no typing derivation for y given as a hypothesis. The conclusion, that y # e
is represented by the output LF term of type ({y : tm} id (E y) E')--the term
E, which may mention the variable y, is ff-equivalent to a term E0 in which y does
not occur (recall the definition of id in Section 4.2). To adequately represent the
informal statement, which is stated for arbitrary object-language contexts fl, the
Twelf statement is stated for the world consisting of ofblocks.

The excerpt of the proof shows the case when the typing derivation was derived
using of app . Appealing to the inductive hypothesis on the two subderivations
shows that y is not free in either E1 (with evidence Did1) or E2 (with evidence
Did2), and we must use these facts to show that it is not free in app E1 E2. To do
so, the case appeals to the congruence lemma id app cong proved in Figure 15 (for
reference, the statement of this lemma is reiterated at the top of Figure 19). This
call is in an extended context binding the variable y.

Should this call be allowed? The current theorem, all declared, is stated for
the world Wof, whereas the lemma, id app cong, was proved in the world {*}.
Unfortunately, a lemma proved for one world may not be true in another, and, in
this case, there is indeed a problem. The world Wof contains additional canonical
forms of type tm that are not present in {*}, so it is possible that there are input
derivations of id E E0 in Wof that id app cong is not prepared to handle. More
formally, the totality assertion for id_app_cong is the following:

For all \Gamma  2 {*}, if \Gamma  ` D1 ( id E1 E10 and \Gamma  ` D2 ( id E2 E20 then there exist D3
and D such that \Gamma  ` D3 ( id (app E1 E2) (app E10 E20) and
\Gamma  ` D ( id app cong D1 D2 D3.

Appealing to this theorem from Wof instantiates \Gamma  with a context other than *. This
is impermissible, absent some additional reasoning justifying that the theorem still
holds in the extended world.

To solve this problem, we can prove id app cong in the larger world. Intuitively,
we need to show that the application congruence rule for id is admissible not
just on closed terms, but also on open terms. Fortunately, our original proof does

52 Robert Harper and Daniel R. Licata
id_app_cong : id E1 E1'

-> id E2 E2'
-> id (app E1 E2) (app E1' E2')
-> type.
%mode id_app_cong +X1 +X2 -X3.

- : id_app_cong refl refl refl.
%worlds (ofblock) (id_app_cong _ _ _).
%total {} (id_app_cong _ _ _).

Fig. 20. Twelf Proof of Lemma id app cong in Wof

indeed prove the stronger theorem--in Section 4.2 we were concerned only with
closed terms, so we did not consider the extended theorem statement. This can be
expressed with the Twelf code in Figure 20. The only difference from the proof in
Figure 15 is the worlds declaration, which states the theorem for Wof. The proof
goes through as before.

Unfortunately, this revised theorem is still insufficient for two reasons. The first
is that the call to it from the proof of all declared is not in Wof, as the extended
context contains a variable y but no typing derivation. This problem can be solved
by revising the case of the theorem to add an unused typing hypothesis for y to the
context. The more serious issue is one of modularity: the statement and proof of
id app cong have nothing to do with typing derivations, but yet the lemma needed
to be stated for a world containing typing derivations to support its later use. This
issue is analogous to modularity issues we encountered with adequacy proofs, and
we can deploy the same machinery to solve it.

4.4.2 Definition of World Subsumption
Calling a lemma stated for a world W from a theorem stated for a world W0 is not
always permissible: it is possible that W0 contains additional canonical forms that
the lemma is not prepared to handle (as in the above example), or that the lemma
outputs canonical forms in W that do not exist in W0. In either case, the lemma
proved in W may no longer be true in W0. Fortunately, the same techniques that we
used to transfer adequacy from one world to another can be used to transfer proofs
of metatheorems from one world to another--the key issue in both cases is the
characterization of the relevant canonical forms. In particular, we define an order
on worlds as follows, where the relation \Gamma  , \Gamma 0 is identity modulo permutation of
independent hypotheses:

Definition 4.14 (World Subsumption)W .

a W0 iff for all \Gamma 0 2 W0, there exists a \Gamma  2 W such that \Gamma |a , \Gamma 0|a.

Because the proof that one world subsumes another may be non-trivial, Twelf
implements a conservative but useful approximation of the relation W .a W0.

Mechanizing Metatheory in a Logical Framework 53
The intuitive justification for choosing this orientation of the relation .a is that
world subsumption is a sufficient condition for weakening the world of a totality
assertion (i.e., for transporting a theorem proved in a smaller world to a larger one):

Theorem 4.15 (Totality Assertions Remain True in Larger Worlds)
Assume an LF constant a ) \Pi  x1:A1. . . .\Pi  y1:B1. . . . type that satisfies the following
totality assertion:

For all \Gamma  2 W, for all M1 such that \Gamma  ` M1 ( A01, . . . , and Mm such that
\Gamma  ` Mm ( A0m, there exist N1 such that \Gamma  ` N1 ( B01, . . . , and Nn such that

\Gamma  ` Nn ( B0n, and D such that \Gamma  ` D ( a M1 . . . Mm N1 . . . Nn.

where

[Mi-1/xi-1]Ai-1 . . . [M1/x1]A1 Ai = A0i
[Nj-1/yj-1]Bj-1 . . . [N1/y1]B1 [Mm/xm]Am . . . [M1/x1]A1Bj = B0j.

Then for all W0 such that W .thm W0, the totality assertion for W0 is also true.

Proof
The proof is direct using Theorem 2.17, Theorem 2.11, and two additional lemmas:

1. If \Gamma  , \Gamma 0 then \Gamma |a , \Gamma 0|a.
2. If \Gamma  ` M ( A and \Gamma  , \Gamma 0 then \Gamma 0 ` M ( A.

The proof of the second part uses exchange (Lemma 2.7).

Intuitively, the condition W .a W0 ensures that all canonical forms of type a
in W0 also exist in W. This condition is necessary to use a lemma proved for W
from a theorem stated for W0, as it ensures that W0 does not add additional inputs
that the lemma is not prepared to handle. However, the condition W .a W0 does
not imply that all of the canonical forms of type a in W exist in W0. This may
intuitively seem problematic for the above theorem--what if the lemma returns a
canonical form in W that does not exist in W0? The lemma cannot return such a
derivation because totality assertions quantify over the context \Gamma  at the outside:
when the lemma is given canonical inputs in a particular \Gamma , it returns canonical
outputs in the same \Gamma .

To understand Theorem 4.15, it may be helpful to consider an example in which
it does not apply. Recall the transport of adequacy theorem for strengthening,
Lemma 4.12 above. The second part of this lemma is equivalent to stating thatW

str .of Wof. Moreover, the proof that the statement of strengthening in Wstr(Theorem 4.11) implies the statement of strengthening in W

of (Theorem 4.10) issimilar to the proof of Theorem 4.15. However, we cannot use Theorem 4.15 to give

an alternate proof of this theorem. Lemma 4.12 proves Wstr .of Wof, but it does
not prove Wstr .strengthen Wof, which would be necessary to satisfy the premise of
Theorem 4.15 (in fact, it is not true that Wstr .strengthen Wof). In this example,
the 89-statement of strengthening transfers from Wstr to Wof, as we proved above,
but the totality assertion for strengthen does not--precisely because the contexts
in Wstr contribute proof cases to strengthen.

54 Robert Harper and Daniel R. Licata
id_app_cong : id E1 E1'

-> id E2 E2'
-> id (app E1 E2) (app E1' E2')
-> type.
%mode id_app_cong +X1 +X2 -X3.

- : id_app_cong refl refl refl.
%block tmblock : block {x : tm}.
%worlds (tmblock) (id_app_cong _ _ _).
%total {} (id_app_cong _ _ _).

Fig. 21. Twelf Proof of Lemma id app cong in Wtm

4.4.3 Using World Subsumption
The proof of all declared at the beginning of this section required a lemma asserting that identity is a congruence on open terms. The correct statement and proof
of this lemma is presented in Figure 21. The theorem must be stated for the world
containing term variables (call this world Wtm) to account for open terms. However,
unlike the previous statement, this theorem does not mention typing derivations,
which are irrelevant to this particular lemma and its proof. It is easy to show
that Wtm .id app cong Wof: of 6_ id app cong, so for any context \Gamma  of the form
x : tm, dx : of x T, . . ., it is true that \Gamma |id app cong 2 Wtm. Thus, Theorem 4.15 implies
that id app cong holds in Wof as well. This authorizes the call from the proof of
all declared in Figure 19.

Observe that {*} 6.id app cong Wof because tm _ id app cong, so Theorem 4.15
does not permit the theorem to call the weaker version of the lemma, which was
stated only for the empty context. Of course, had we anticipated needing the openterm congruence lemma, we could have proved that lemma in the first place, as
it includes closed terms as a special case. It is worth noting that, though these
examples have to do with worlds, the general principle has nothing to do with
Twelf: in a paper proof, one might choose to prove a weaker version of a lemma for
use at one point in a proof, and then, later in the proof, discover that a stronger
version is necessary.

The world subordination criterion emphasizes that transport of canonical forms
is important not just for modular adequacy proofs, but also for modular Twelf
proofs.

4.5 Discussion
Though Twelf proofs are mechanically checked, a programmer still must verify that
a Twelf theorem statement corresponds to the informal statement of the theorem
he wants to prove. As we have seen in this section, the adequacy methodology
permits a precise account of the correspondence between informal and mechanized
theorem statements. That said, a Twelf programmer does not need to make this
correspondence for every theorem he proves. In a large Twelf proof, there are usually

Mechanizing Metatheory in a Logical Framework 55
a few top-level theorems stating the major results about a system (e.g., progress
and preservation for a language) that are proved using many lemmas. In this case,
it is necessary only to verify that the top-level theorem statements correspond to
the desired informal theorems; there is no need to consider the informal analogues
of lemmas that are not of independent interest.

5 Related Work
A reader who is interested in learning more about Twelf should visit the Twelf
Wiki (http://twelf.plparty.org/), which contains numerous tutorials and case
studies.

LF and Twelf. Harper et al. (1993) introduce the LF type theory and representation methodology. The canonical-forms presentation of LF in this article is due
to the treatment of Concurrent LF by Watkins et al. (2002, 2004a); it has since
been applied to several other type theories (for example, see Nanevski et al. (2007);
Nanevski & Morrisett (2006); Lee et al. (2007)). The general method of defining a
type theory algorithmically goes back to the AUTOMATH languages (de Bruijn,
1993; van Daalen, 1980). Previous treatments of the metatheory of LF include the
following: Harper et al. (1993) discuss the metatheory of LF with fi-conversion but
not j-conversion. Salvesen (1990), Geuvers (1992), and Goguen (1999) discuss the
extension to fij-conversion. Coquand (1991) gives a shape-directed equality algorithm for LF. Harper & Pfenning (2005) present a type-directed equality algorithm.
Felty (1991) presents LF with formation judgements that admit only canonical
forms, but defines equality using fi-reduction on non-canonical forms.

Several logical frameworks extend LF with additional features. Linear LF (LLF)
extends LF with linear connectives (Cervesato & Pfenning, 2002). Concurrent LF
(CLF) extends LLF with more linear connectives and with an intrinsic notion of
concurrency (Watkins et al., 2002, 2004b; Cervesato et al., 2002). These extensions ease the representation of language features for which LF provides no native
support--e.g., a language with state can conveniently be represented using the
linear connectives in LLF.

The Twelf User's Guide (Pfenning & Sch"urmann, 2002) describes the features of
Twelf. The metatheory of Twelf is discussed in several sources. Pfenning (1991) introduces the logic-programming operational semantics for LF. Pfenning & Rohwedder (1992) give an early overview of the Twelf methodology. Rohwedder & Pfenning
(1996) discuss mode and termination checking. Pientka & Pfenning (2000) discuss
an extended termination checker. Sch"urmann (2000) and Sch"urmann & Pfenning
(2003) discuss coverage and world checking.

Several extensions of Twelf have been studied but not yet fully implemented.
Sch"urmann & Pfenning (1998) discuss a metatheorem prover. Anderson & Pfenning (2004) discuss uniqueness checking. Sch"urmann et al. (2005) describe an extended metatheorem language that would permit more general theorems than 89-
statements. Reed (2006) describes an approach to extending the metatheoretic capabilities of Twelf to Linear LF.

56 Robert Harper and Daniel R. Licata
Applications of LF and Twelf. Several papers discuss applications of LF and Twelf.
Lee et al. (2007) discuss a Twelf proof of type safety for the Harper-Stone internal language for Standard ML. Avron et al. (1989) discuss LF representation
and present several examples. Michaylov & Pfenning (1991) present some of the
metatheory of Mini-ML. Pfenning (1992) gives a proof of the Church-Rosser theorem for the simply typed *-calculus. Pfenning (1994) gives a proof of cut elimination
for intuitionistic logic. Sch"urmann et al. (2001) present some of the metatheory of
F !. Sch"urmann & Stehr (2005) present a formalization of Howe's embedding of
HOL into NuPRL. Appel (2001) presents a foundational proof-carrying code system. Appel & Felty (2002) use Twelf to implement tactical theorem provers. Crary
& Sarkar (2003) present a typed assembly language and applications to proofcarrying code. Simmons (2005) presents the metatheory of a functional language
with references. Pfenning (1999) surveys various methods of representing deductive
systems in logical frameworks. The examples directory of the Twelf distribution
contains additional examples of deductive systems and their metatheory.

Though they do not focus on mechanization, several additional papers are accompanied by Twelf appendices mechanizing the metatheory of the presented languages. Crary (2003) formalizes a foundational typed assembly language. Murphy
VII et al. (2004) and Murphy VII et al. (2005) formalize modal type systems for
distributed computing. Licata & Harper (2005) formalize a language extending ML
with a form of dependent types. Garg & Pfenning (2006) formalize an authorization
logic. Acar et al. (2007) prove consistency and correctness of a semantics for selfadjusting computation. Fluet et al. (2006) formalize a substructural type system
for region-based memory management.

Other Mechanization Tools. The LF logical framework is similar in spirit to the
AUTOMATH languages (Nederpelt et al., 1994)--both provide frameworks for
representing machine-checkable mathematical arguments, while neither make any
foundational commitment about what logics can be represented.

Other proof assistants that have been used to formalize mathematics and computer science include Coq (Coq Development Team, 2007; Bertot & Cast'eran,
2004), Isabelle/HOL (Nipkow et al., 2002), NuPRL (Constable et al., 1986), HOL
Light (Harrison, 1996), and ACL2 (Kaufmann et al., 2000). Many of these proof
assistants have been applied to the domain of programming languages and logics.
For example, Miculan (1997) shows how to encode several logical systems in Coq;
Leroy (2006) reports on implementing a certified compiler in Coq. Klein & Nipkow
(2006) formalize a semantics for a Java-like language in Isabelle/HOL.

Twelf, Coq, Isabelle/HOL, and other proof assistants differ significantly in the
representation techniques they support, the classes of metatheorems that can be
proved, the style in which proofs are written, and the degree of automation they
provide. A detailed analysis of the trade-offs between these tools is beyond the
scope of this article. In the literature, several efforts have been made to compare
and contrast proofs of the same theorem formalized in different proof assistants.
For example, the POPLmark Challenge (Aydemir et al., 2005) is one benchmark
on which proof assistants can be compared; solutions have been presented in Twelf,

Mechanizing Metatheory in a Logical Framework 57
Coq, Isabelle/HOL, and other systems. Appel & Leroy (2006) compare Coq and
Twelf proofs of a first-order list-machine benchmark.

6 Conclusion
In this article, we have surveyed the LF *-calculus, the LF methodology for representing languages, and the Twelf methodology for mechanizing metatheory. Following Watkins et al. (2002), we have shown how LF, a minimal dependent type
theory, can be defined so that only canonical forms are well-typed, giving a direct
inductive definition of the canonical forms. We have shown how the minimality
of LF enables higher-order representations of syntax and judgements, whereby an
object language inherits ff-equivalence, capture-avoiding substitution, and properties of hypothetical judgements from the logical framework. We have shown how
these representations are proved adequate by simple structural inductions on the
informal object-language entities and on the canonical forms of LF; and we have
shown how subordination-based transport of adequacy facilitates modular adequacy
proofs. Finally, we have shown how the proofs of 89-statements over LF types can
be represented relationally within LF and mechanically verified by Twelf, again
using subordination and induction on canonical forms.

There are several important and useful features of Twelf that we have not discussed in this article. Chiefly, Twelf implements a logic-programming operational
semantics for LF (Pfenning, 1991). Using this operational semantics, one can run
the LF specification of a programming language directly. For example, the type
family step defined in Figure 13 can be run as an interpreter for the STLC, and
the type family of can be run as a type checker. The interested reader should consult the Twelf User's Guide (Pfenning & Sch"urmann, 2002) or the Twelf Wiki to
learn about the additional features of Twelf.

In future work, we expect that the methodologies that we have surveyed in this
paper will be scaled to richer logical frameworks, to tools that provide more automated theorem proving, and to more-general metatheorem languages. Research on
Linear LF and Concurrent LF has shown how how these frameworks permit facile
representations of systems that are cumbersome to represent in LF (Cervesato &
Pfenning, 2002; Cervesato et al., 2002). The LF methodology for adequate representations scales to these richer frameworks; the programmer simply has a richer collection of types available for generating canonical forms. The extension of Twelf's logicprogramming operational semantics and totality checker to these logical frameworks
is current and future work (Reed, 2006).

At present, Twelf is most often used as a metatheorem checker rather than as a
metatheorem prover, in the sense that most often a proof of a 89-statement is represented explicitly as an LF type family and then verified by a totality assertion.
A metatheorem prover (i.e., an extension of Twelf with the ability to automatically generate an LF type family satisfying a given totality assertion) has been
studied and implemented in a previous release of Twelf (Sch"urmann & Pfenning,
1998). However, the current Twelf implementation of this metatheorem prover does
not output the LF type family that it discovers, limiting the feature's utility. This

58 Robert Harper and Daniel R. Licata
metatheorem prover's implementation may eventually be completed, and the development of more-sophisticated metatheorem provers is a subject of active research.

Because Twelf metatheorems are proved using totality assertions about LF type
families, the class of metatheorems that can be mechanized is restricted to 89-
statements over LF types. On the one hand, as the successful Twelf formalizations
cited in Section 5 demonstrate, these 89-statements have proved to be sufficient for
formalizing a wide variety of metatheorems about programming languages and logics. On the other hand, we have no way to quantify when metatheorems of this form
will be sufficient, and there are some well-known examples of proofs that cannot
be formalized directly using Twelf's metatheorem language. For example, proofs by
logical relations often require more quantifier complexity than 89-statements afford.
In future work, we expect that this restriction may be lifted by moving to a different metatheorem language that permits more general statements (see Sch"urmann
et al. (2005) for some preliminary work). Though such a metatheorem language is
a departure from the specific methodology outlined in this paper, it is in essence
just a different way of expressing proofs by induction on the canonical forms of LF.

In summary, we believe that the LF and Twelf methodology for mechanizing
languages and their metatheory is both useful in practice today and the foundation
of interesting future research. We hope that the interested reader will use LF and
Twelf and assess their utility himself.

Acknoweldgements. We thank Todd Wilson, Rob Simmons, Steve Brookes, William
Lovas, Tom Murphy, Jason Reed, Ruy Ley-Wild, Daniel Lee, Daniel Spoonhower,
Akiva Leffert, Neel Krishnaswami, Jake Donham, Sean McLaughlin, Karl Crary,
and Frank Pfenning for discussions about, and feedback on, previous drafts of this
article. We thank the anonymous referees for their helpful feedback on previous
drafts.

References
Acar, Umut A., Blume, Matthias, & Donham, Jacob. (2007). A consistent semantics

of self-adjusting computation. European Symposium on Programming. SpringerVerlag.
Anderson, Penny, & Pfenning, Frank. (2004). Verifying uniqueness in a logical

framework. Pages 18-33 of: Slind, K., Bunker, A., & Gopalakrishnan, G. (eds),
International Conference on Theorem Proving in Higher-Order Logics. Lecture
Notes in Computer Science, vol. 3223. Springer.
Appel, Andrew, & Leroy, Xavier. (2006). A list-machine benchmark for mechanized metatheory. International Workshop on Logical Frameworks and MetaLanguages: Theory and Practice. Electronic Notes in Theoretical Computer Science.
Appel, Andrew W. (2001). Foundational proof-carrying code. Page 247 of: IEEE

Symposium on Logic in Computer Science. IEEE Computer Society.
Appel, Andrew W., & Felty, Amy P. (2002). Dependent types ensure partial correctness of theorem provers. Journal of Functional Programming, 14(1), 3-19.

Mechanizing Metatheory in a Logical Framework 59
Avron, Arnon, Honsell, Furio, & Mason, Ian A. (1989). An overview of the Edinburgh Logical Framework. Birtwistle, Graham, & Subrahmanyam, P.A. (eds),
Current trends in hardware verification. Springer Verlag.
Aydemir, Brian E., Bohannon, Aaron, Fairbairn, Matthew, Foster, J. Nathan,

Pierce, Benjamin C., Sewell, Peter, Vytiniotis, Dimitrios, Washburn, Geoffrey,
Weirich, Stephanie, & Zdancewic, Steve. (2005). Mechanized metatheory for the
masses: The POPLmark challenge. International Conference on Theorem Proving in Higher-Order Logics. Springer-Verlag.
Bertot, Yves, & Cast'eran, Pierre. (2004). Interactive theorem proving and program development: Coq'art: The calculus of inductive constructions. Texts in
Theoretical Computer Science. Springer.
Cervesato, Iliano, & Pfenning, Frank. (2002). A linear logical framework. Information and Computation, 179(1), 19-75.
Cervesato, Iliano, Pfenning, Frank, Walker, David, & Watkins, Kevin. (2002). A

concurrent logical framework II: Examples and applications. Tech. rept. CMU-CS02-102. Department of Computer Science, Carnegie Mellon University. Revised
May 2003.
Constable, Robert L., Allen, Stuart F., Bromley, H. M., Cleaveland, W. R., Cremer,

J. F., Harper, R. W., Howe, Douglas J., Knoblock, T. B., Mendler, N. P., Panangaden, P., Sasaki, James T., & Smith, Scott F. (1986). Implementing mathematics
with the NuPRL proof development system. Prentice Hall.
Coq Development Team. (2007). The Coq proof assistant reference manual. INRIA.

Available from http://coq.inria.fr/.
Coquand, Thierry. (1991). An algorithm for testing conversion in type theory. Pages

255-279 of: Huet, G'erard, & Plotkin, Gordon D. (eds), Logical frameworks. New
York, NY, USA: Cambridge University Press.
Crary, Karl. (2003). Toward a foundational typed assembly language. Pages 198-

212 of: ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM Press.
Crary, Karl, & Sarkar, Susmit. (2003). Foundational certified code in a metalogical

framework. Pages 106-120 of: International Conference on Automated Deduction. Springer-Verlag.
de Bruijn, Nicolaas Govert. (1993). Algorithmic definition of lambda-typed lambda

calculus. Pages 131-145 of: Huet, G'erard, & Plotkin, Gordon D. (eds), Logical
environment. Cambridge University Press.
Felty, Amy. (1991). Encoding dependent types in an intuitionistic logic. Pages 214-

251 of: Huet, G'erard, & Plotkin, Gordon D. (eds), Logical frameworks. Cambridge
University Press.
Fluet, Matthew, Morrisett, Greg, & Ahmed, Amal. (2006). Linear regions are all

you need. Pages 7-21 of: European Symposium on Programming. Springer-Verlag.
Garg, Deepak, & Pfenning, Frank. (2006). Non-interference in constructive authorization logic. Pages 183-293 of: Computer security foundations workshop.
Geuvers, Herman. (1992). The Church-Rosser property for fij-reduction in typed

*-calculi. Pages 453-460 of: Scedrov, A. (ed), IEEE Symposium on Logic in
Computer Science. IEEE Press.

60 Robert Harper and Daniel R. Licata
Goguen, Healfdene. (1999). Soundness of the logical framework for its typed operational semantics. International Conference on Typed Lambda Calculi and
Applications. Lecture Notes in Computer Science, vol. 1581. Springer-Verlag.
Harper, Robert, & Pfenning, Frank. (2005). On equivalence and canonical forms in

the LF type theory. ACM Transactions on Computational Logic, 6, 61-101.
Harper, Robert, Honsell, Furio, & Plotkin, Gordon. (1993). A framework for defining logics. Journal of the Association for Computing Machinery, 40(1).
Harrison, John. (1996). HOL Light: A tutorial introduction. Pages 265-269 of:

Formal Methods in Computer-Aided Design. Lecture Notes in Computer Science,
vol. 1166. Springer-Verlag.
Kaufmann, Matt, Manolios, Panagiotis, & Moore, J Strother. (2000). Computeraided reasoning: An approach. Kluwer Academic Publishers.
Klein, Gerwin, & Nipkow, Tobias. (2006). A machine-checked model for a Java-like

language, virtual machine and compiler. ACM Transactions on Programming
Languages and Systems, 28(4), 619-695.
Lee, Daniel K., Crary, Karl, & Harper, Robert. (2007). Towards a mechanized

metatheory of Standard ML. ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages. ACM Press.
Leroy, Xavier. (2006). Formal certification of a compiler back-end, or: programming

a compiler with a proof assistant. Pages 42-54 of: ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages. ACM Press.
Licata, Daniel R., & Harper, Robert. (2005). A formulation of Dependent ML with

explicit equality proofs. Tech. rept. CMU-CS-05-178. Department of Computer
Science, Carnegie Mellon University.
Michaylov, Spiro, & Pfenning, Frank. (1991). Natural semantics and some of its

meta-theory in Elf. Pages 299-344 of: Eriksson, L.H., Halln"as, L., & SchroederHeister, P. (eds), International Workshop on Extensions of Logic Programming.
Lecture Notes in Artificial Intelligence, vol. 596. Springer-Verlag.
Miculan, Marino. (1997). Encoding logical theories of programs. Ph.D. thesis, Dipartimento di Informatica, Universita di Pisa.
Murphy VII, Tom, Crary, Karl, Harper, Robert, & Pfenning, Frank. (2004). A

symmetric modal lambda calculus for distributed computing. Pages 286-295
of: Ganzinger, H. (ed), IEEE Symposium on Logic in Computer Science. IEEE
Press.
Murphy VII, Tom, Crary, Karl, & Harper, Robert. (2005). Distributed control flow

with classical modal logic. Pages 51-69 of: Computer Science Logic. Lecture
Notes in Computer Science, vol. 3634. Springer-Verlag.
Nanevski, Aleksandar, & Morrisett, Greg. (2006). Dependent type theory of stateful

higher-order functions. Tech. rept. TR-24-05. Harvard Computer Science.
Nanevski, Aleksandar, Pfenning, Frank, & Pientka, Brigitte. (2007). Contextual

modal type theory. ACM Transactions on Computational Logic. To appear.
Nederpelt, R.P., Geuvers, J.H., & de Vrijer, R.C. (eds). (1994). Selected papers on

AUTOMATH. Studies in Logic and the Foundations of Mathematics, vol. 133.
North-Holland.
Nipkow, Tobias, Paulson, Lawrence C., & Wenzel, Markus. (2002). Isabelle/HOL

Mechanizing Metatheory in a Logical Framework 61
-- a proof assistant for higher-order logic. Lecture Notes in Computer Science,
vol. 2283. Springer-Verlag.Pfenning, Frank. (1991). Logic programming in the LF logical framework. Pages

149-181 of: Huet, G'erard, & Plotkin, Gordon D. (eds), Logical frameworks. Cambridge University Press.
Pfenning, Frank. (1992). A proof of the Church-Rosser theorem and its representation in a logical framework. Tech. rept. CMU-CS-92-186. Department of
Computer Science, Carnegie Mellon University.Pfenning, Frank. (1994). A structural proof of cut elimination and its representation

in a logical framework. Tech. rept. CMU-CS-94-218. Department of Computer
Science, Carnegie Mellon University.Pfenning, Frank. (1999). Logical Frameworks. Robinson, Alan, & Voronkov, Andrei

(eds), Handbook of Automated Reasoning. Elsevier Science and MIT Press.Pfenning, Frank, & Rohwedder, Ekkehard. (1992). Implementing the meta-theory
of deductive systems. Pages 537-551 of: Kapur, D. (ed), International Conference on Automated Deduction. Lecture Notes in Artificial Intelligence, vol. 607.
Springer-Verlag.Pfenning, Frank, & Sch"urmann, Carsten. (1999). System description: Twelf - a

meta-logical framework for deductive systems. Pages 202-206 of: Ganzinger,
Harald (ed), International Conference on Automated Deduction.
Pfenning, Frank, & Sch"urmann, Carsten. (2002). Twelf user's guide, version 1.4.Pientka, Brigitte, & Pfenning, Frank. (2000). Termination and reduction checking

in the logical framework. Sch"urmann, Carsten (ed), Workshop on Automation of
Proofs by Mathematical Induction.
Reed, Jason. (2006). Hybridizing a logical framework. International workshop on

hybrid logic. Electronic Notes in Theoeretical Computer Science. Elsevier.
Rohwedder, Ekkehard, & Pfenning, Frank. (1996). Mode and termination checking

for higher-order logic programs. Pages 296-310 of: Nielson, Hanne Riis (ed),
European Symposium on Programming. Lecture Notes in Computer Science, vol.
1058. Springer-Verlag.
Salvesen, Anne. (1990). The Church-Rosser theorem for LF with fij-reduction.

Unpublished notes to a talk given at the First Workshop on Logical Frameworks.Sch"urmann, Carsten. (2000). Automating the meta-theory of deductive systems.

Ph.D. thesis, Carnegie Mellon University.Sch"urmann, Carsten, & Pfenning, Frank. (1998). Automated theorem proving in
a simple meta-logic for LF. Pages 286-300 of: Kirchner, Claude, & Kirchner,
H'el`ene (eds), International Conference on Automated Deduction. Lecture Notes
in Computer Science, vol. 1421. Springer-Verlag.Sch"urmann, Carsten, & Pfenning, Frank. (2003). A coverage checking algorithm

for LF. International Conference on Theorem Proving in Higher-Order Logics.
Springer-Verlag.
Sch"urmann, Carsten, & Stehr, Mark-Oliver. (2005). An executable formalization

of the HOL/NuPRL connection in Twelf. International conference on logic for
programming artificial intelligence and reasoning. Springer-Verlag.Sch"urmann, Carsten, Yu, Dachuan, & Ni, Zhaozhong. (2001). A representation of

F! in LF. Electronic notes in Theoretical Computer Science, 58(1).

62 Robert Harper and Daniel R. Licata
Sch"urmann, Carsten, Poswolsky, Adam, & Sarnat, Jeffrey. (2005). The r-calculus:

Functional programming with higher-order encodings. International Conference
on Typed Lambda Calculi and Applications. Springer-Verlag.
Simmons, Robert. (2005). Twelf as a unified framework for language formalization

and implementation. Tech. rept. Princeton University. Undergraduate Senior
Thesis 18679.
van Daalen, D. T. (1980). The language theory of AUTOMATH. Ph.D. thesis,

Technical University of Eindhoven, Eindhoven, Netherlands.
Virga, Roberto. (1999). Higher-order rewriting with dependent types. Ph.D. thesis,

Carnegie Mellon University.
Watkins, Kevin, Cervesato, Iliano, Pfenning, Frank, & Walker, David. (2002). A

concurrent logical framework I: Judgments and properties. Tech. rept. CMU-CS02-101. Department of Computer Science, Carnegie Mellon University. Revised
May 2003.
Watkins, Kevin, Cervesato, Iliano, Pfenning, Frank, , & Walker, David. (2004a).

A concurrent logical framework: the propositional fragment. Pages 355-377 of:
Berardi, S., Coppo, M., & Damiani, F. (eds), Types for proofs and programs.
Lecture Notes in Computer Science, vol. 3085. Springer-Verlag.
Watkins, Kevin, Cervesato, Iliano, Pfenning, Frank, & Walker, David. (2004b).

Specifying properties of concurrent computations in CLF. Sch"urmann, Carsten
(ed), International workshop on logical frameworks and meta-languages.