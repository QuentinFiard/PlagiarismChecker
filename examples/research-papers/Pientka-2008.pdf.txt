

A Type-theoretic Foundation for Programming withHigher-order Abstract Syntax and First-class Substitutions

Brigitte Pientka
McGill University, Canada

bpientka@cs.mcgill.ca

Abstract
Higher-order abstract syntax (HOAS) is a simple, powerful tech-nique for implementing object languages, since it directly supports common and tricky routines dealing with variables, such ascapture-avoiding substitution and renaming. This is achieved by
representing binders in the object-language via binders in the meta-language. However, enriching functional programming languages
with direct support for HOAS has been a major challenge, be-cause recursion over HOAS encodings requires one to traverse

*-abstractions and necessitates programming with open objects.

We present a novel type-theoretic foundation based on contex-tual modal types which allows us to recursively analyze open terms
via higher-order pattern matching. By design, variables occurringin open terms can never escape their scope. Using several examples,
we demonstrate that our framework provides a name-safe foun-dation to operations typically found in nominal systems. In contrast to nominal systems however, we also support capture-avoidingsubstitution operations and even provide first-class substitutions to
the programmer. The main contribution of this paper is a syntax-directed bi-directional type system where we distinguish between
the data language and the computation language together with theprogress and preservation proof for our language.

Categories and Subject Descriptors D.3.1 [Programming Lan-guages]: Formal Definitions and Theory
General Terms Theory, Languages
Keywords Type theory, logical frameworks

1. Introduction
Typed functional programming languages are particularly suitedfor analyzing and manipulating syntactic structures and are pervasively used for implementing object languages. Although manyobject languages include binding constructs, it is striking that typed
functional languages still lack direct support for binders and com-mon tricky operations such as renaming, capture-avoiding substitution, and fresh name generation. The most common approach inpractice is to implement binders via de Bruijn indices, which at
least provides for ff-renaming. While this leads to an efficient im-plementation, analyzing and especially manipulating data can be

Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.
POPL'08, January 7-12, 2008, San Francisco, California, USA.Copyright cfl 2008 ACM 978-1-59593-689-9/08/0001.. . $5.00

cumbersome and error-prone. Capture-avoiding substitution mustbe implemented separately. Nominal approaches (Gabbay and Pitts
1999) as found in FreshML (Shinwell et al. 2003) provide first-class names and

ff-renaming. This approach is appealing becauseit gives us direct access to names of bound variables. The generation of a new name and binding names are separate operations andfresh name generation is an observable side effect. Unfortunately,
this means that it is possible to generate data which contains acci-dentally unbound names. To address this problem, Pottier (2007)
recently proposed pure FreshML where one can reason about theset of names occurring in an expression via a Hoare-style proof system. This static analysis approach is quite expressive since the lan-guage of constraints includes subset relations, equality, and intersection. Nevertheless, the programmer needs to implement capture-avoiding substitution manually.

In higher-order abstract syntax (HOAS) we represent bindersin the object-language via binders in our meta-language (i.e. functional programming language). One of the key benefits is that wenot only get support for renaming and fresh name generation, but
also for capture-avoiding substitution. Consequently, it is typicallyeasier to ensure correctness and reason about HOAS representations, since tedious lemmas about substitutions and fresh names donot need to be proven. The strengths of HOAS have been impressively demonstrated within the logical framework LF (Harper et al.1993) and its implementation in the Twelf system (Pfenning and
Sch"urmann 1999) over the past decade. However, HOAS has rarelybeen considered in real programming languages (example include
Washburn and Weirich (2006); Guillemette and Monnier (2006)).To illustrate the difficulty, we define a small language with letexpressions and arithmetic operations. The let-expression is definedvia higher-order abstract syntax, i.e. the binder in the let-expression
is represented via a binder in our meta-language. We distinguishbetween natural numbers and expressions, and variables in expressions represent only values.

exp: type .
Nat: nat ! exp.
Add: exp ! exp ! exp.
Let: exp ! (nat ! exp) ! exp.

nat: type .
z: nat.
suc: nat ! nat.

The expression let val x = 1 in Add(0, x) end is repre-sented as

Let (Nat(suc z)) (*x.Add (Nat z) (Nat x)) inour meta-language. When we recursively analyze the body of the

let-expression, we must analyze Add (Nat z) (Nat x) whichcontains a free variable

x and hence is an open term. Moreover,we often also want to manipulate the variable

x and compare it toother variables. However, HOAS encodings do typically not allow

us to directly access, manipulate and compare bound variables.The message of this paper is that we can recursively analyze and
manipulate open data, which is defined via HOAS and may contain

variables, and safely add this functionality to typed functional pro-gramming. In particular, we can support operations such as analyzing and comparing bound variables. By design, variables occurringin open data can never escape their scope thereby avoiding a problem prevalent in previous attempts. Our framework therefore maybe seen as a name-safe alternative foundation for the operations
typically supported in nominal systems. However, in addition tosupporting binders and

ff-renaming, we provide capture-avoidingsubstitution operation together with first-class substitution.

Building on ideas by Nanevski et al. (2006), we design a type-theoretic foundation for programming with HOAS and substitutions based on contextual modal types. The contextual modal type
A[\Psi ] classifies open data M where M has type A in the context \Psi .Consequently, the object

M may refer to the variables declared inthe context
\Psi , but M is closed with respect to the context \Psi . Thedata-object
Add (Nat (suc z)) (Nat x) from the previous ex-ample has type

exp in the context x:nat.Generalizing ideas from Despeyroux et al. (1997), data of type

A[\Psi ] may be injected into the computation level and analyzed viapattern matching via the box-construct thereby separating data from
computations. Since we want to allow recursion over open data ob-jects and the local context

\Psi  which is associated with the type Amay grow, our foundation supports context variables and abstraction over contexts. Consequently, different arguments to a compu-tation may have different local contexts and we can distinguish between data of type A[*], which is closed, and open data of type
A[\Psi ]. This gives us fine-grained control and allows us to specifystrong invariants. Our type-theoretic foundation based on contextual modal types is substantially different from previous propos-als to marry HOAS with functional programming as proposed by
Sch"urmann et al. (2005). In Sch"urmann et al. (2005), the necessitymodality \Lambda 

o/ describes computation of type o/ which can be exe-cuted in every world where we have at least one context extension.

The context containing binding occurrences is hence left implicitand associated with a computation. As a consequence, every argument of the computation must share one global context. WhileSch"urmann's work does provide for capture-avoiding substitution
via fi-reduction, it lacks the support to construct substitutions asfirst-class objects. The type of a substitution in our framework will
be \Psi [\Phi ] where \Psi  describes the domain and \Phi  the range. In otherwords, the substitution of type

\Psi [\Phi ] maps bound variables declaredin the context
\Psi  to objects which may refer to the bound variablesdeclared in
\Phi . We believe this foundation provides general insightsinto how open data-objects can be understood type-theoretically

and incorporated as first-class into programming languages. Themain contribution of this paper are:

* We present a syntax-directed decidable bi-directional type system for open data and substitutions based on contextual types.By design, variables occurring in open data objects cannot escape their scope, and no separate reasoning about scope is re-quired (Section 3). Following a recent presentation technique
for logical frameworks due to Watkins et al. (2002) our syntaxonly allows for objects which are in canonical form since only
these are meaningful for representing object-languages. Conse-quently, exotic terms that do not represent legal objects from
our object-language are prevented.*
Extending our previous work (Pientka and Pfennning 2003), wepresent a linear higher-order pattern matching algorithm for

open data and substitutions together with its correctness proof(Section 3.4). We also discuss the trade-offs and costs of considering the full pattern fragment as defined by Miller (1991)versus linear higher-order patterns (Section 2 and Section 3.4).

* Using several examples (Section 2), we show that our framework may be seen as a name-safe foundation to operations typically found in nominal systems while at the same time alsoproviding for capture-avoiding substitutions together with firstclass substitutions.*
We present a syntax-directed decidable bi-directional type sys-tem for computation which allows recursion and pattern matching on open data and substitutions (Section 4) together with asmall-step operational semantics (Section 5). Open data is injected into computation via the box-construct. The driving forcebehind the operational semantics is the higher-order matching
algorithm described in Section 3.4. The key to a clean and el-egant meta-theory is our distinction between bound variables
in data, contextual variables which may be instantiated via pat-tern matching with data, context variables, and bound variables
in computations. Each of these variables gives rise to their ownsubstitution definition and they play a central role in defining
our operational semantics. Building on different substitutionproperties, we prove type preservation and progress.

We believe our calculus is an important step towards under-standing syntactic structures with binders, and how one can provide direct support for binders in the setting of typed functionalprogramming. More generally, it provides a type-theoretic foundation for open data-objects which play an important role in manyareas of computer science beyond programming with higher-order
abstract syntax, such as explaining linking of code, or staged com-putation (see for example (Kim et al. 2006)).

2. Motivation
In this section we briefly discuss four small examples to illustratethe main ideas behind our approach. The examples are purposely

simple to emphasize the key features of our work and we keep thenotation as close as possible to the theoretical foundation. In all our
examples, we consider a small language with let-expressions andarithmetic operations which we introduced earlier.

Counting occurrences of a variable In the first example, weshow how to count the occurrences of a particular variable in a
given data-object. We exploit the power of higher-order patterns toaccomplish this. The function

cntV takes in a context  of naturalnumbers, and a data-object
e of type exp[,x:nat], i.e. an ex-pression which may refer to the bound variables listed in the context (,x:nat), and returns as a result an integer. Just as typesclassify data-objects and kinds classify types, we introduce context schemas to classify contexts. In the type declaration for thefunction

cntV we state that the context variable  has the contextschema
(nat)*. In other words  stands for a data-level contextof the form

x1:nat, . . ., xn:nat. We represent contextual vari-ables which are instantiated via higher-order pattern matching with

capital letters.
rec cntV : \Pi  :(nat)*.exp[,x:nat] ! int =
\Lambda   ) fn e ) case e ofbox

(,x. Nat U[id]) ) 0
| box (,x. Nat U[x]) ) 1
| box (,x. Let U[id,x] (*y.W[id,x,y])) )

cntV de box(,x. U[id,x]) +
cntV d,y:nat e box(,y,x. W[id,x,y])
| box (,x. Add U[id,x] W[id,x]) )

cntV de box(,x. U[id,x])
+ cntV de box(,x. W[id,x])

The function cntV is built by a context abstraction \Lambda   whichintroduces the context variable

 and binds every occurrence of in the body of the function. Next, we introduce the computationlevel variable e which has type exp[,x:nat] by function-abstraction. In the body of the function

cntV we analyze objects

of type exp[,x:nat] by case-analysis. As mentioned earlier, weseparate data from computations via the box-construct.

"Holes" in the pattern which are instantiated via higher-orderpattern matching are characterized by a closure

U[oe] consisting ofa contextual variable
U and a postponed substitution oe. As soon aswe know what the contextual variable stands for, we apply the substitution oe. In the example, the postponed substitution associatedwith

U is the identity substitution which essentially corresponds to
ff-renaming. We write id for the identity substitution with domain
. Intuitively, one may think of the substitution associated withcontextual variables which occur in patterns as a list of variables

which may occur in the hole. In U[id], for example, the contex-tual variable

U can be instantiated with any natural number whicheither is closed, i.e. it does not refer to any bound variable listed in

the context  or it contains a bound variable from the context .To recursively analyze expressions we have to consider different
cases. The first case box (,x. Nat U[id]) captures the ideathat if we encounter a natural number which does not contain
occurrences of the bound variable x then we return 0. In the secondcase box

(,x. Nat (U[x])) we pattern match against a "hole"which may refer to the bound variable

x. The only time this casenow succeeds, is for a natural number which actually refers to

xsince this is the only case not already covered by the first case. In

the third case box (,x.Let U[id,x] (*y.W[id,x,y]))weanalyze the let-expression. To count the occurrences of the variable
x, we first count the occurrences in U[id,x], and then count theoccurrences in the body of the let-expression. To accomplish this,
we must extend the context with the declaration y:nat and pass theextended context

(,y:nat) to the recursive call of cntV. Contextapplication is described by

cntV d,y:nate.The box-construct binds occurrences of data-level variables

only. For example in box (,y,x.U[id,x,y]), the variables xand

y are bound and subject to ff-renaming. However we empha-size that the context variable

 is not bound by the box-constructin the branch of a case-expression, but bound by the context abstraction \Lambda   ) . . . . In particular,  is not instantiated via patternmatching. One may think that listing the bound variables explicitly
in the box-construct is not necessary because they are determinedby the type

exp[,x:nat]. However to support ff-renaming ofdata-level variables, we explicitly list the names of the bound variables, and enforce that this list can be obtained by erasing all typesfrom the context

,x:nat. In an implementation of our languagebased on de Bruijn indices this complication can be eliminated.

Extracting variables Next, we show how to compute the vari-ables occurring in a data-object. We will write a function which accepts a natural number of type nat[] which may refer to boundvariables listed in the context

, and returns a data-object of type
nat[] option. If a bound variable occurs in the natural numberthen we return it, otherwise we return

NONE.

rec FVnat:\Pi  :(nat)*.nat[] ! (nat[]) option =
\Lambda   ) fn e ) case e ofbox

(.z) ) NONE
| box (.p[id]) ) SOME box(.p[id])

| box (.suc U[id]) ) FVnat de box(. U[id])

The key question is how do we detect and pattern match againsta data-level variable? - To accomplish this, we use the parameter

variable p. A parameter variable represents a bound variable andcan only be instantiated with a variable from the object level.
Similar to meta-variables they are treated as closures. In contrastto meta-variables which can be instantiated with an arbitrary object
and are represented by capital letters, we will use small letters forparameter variables. Parameter variables allow us to write explicitly
a case for matching against variables and allow us to collect them,

and even compare them. Given the function FVnat, it should beobvious how to write a function which collects all the free variables
occurring in a let-expression.
Closed value So far our examples only utilized one context anddidn't exploit the power that we are able to distinguish between

different contexts. For example, we may want to write a simplefunction which tests whether a given natural number is closed, and
hence constitutes a value. It may be in fact important in the laterpart of the program that we know that we have a closed value. This
can be achieved by the function isVal which not only tests whethera given natural number is closed but also strengthens the result.

val isVal:\Pi  :(nat)*. nat[] ! (nat[.]) option =
\Lambda   ) fn e ) case e ofbox

(.U[.]) ) SOME box(U[.])
| box (.U[id]) ) NONE

In the first case we test whether the input is closed, and if it iswe return it in a strengthened context. While in other approaches

we can recursively analyze objects and thereby check whether theyare a closed value, the property of being closed is usually harder to
capture in current type systems.
Environment-based interpreter Finally, we give an examplewhich uses first-class substitutions and substitution variables which

our foundation provides. The task is to write a simple environment-based interpreter for the language we have defined earlier, where
we take in a context  of natural numbers, an expression e of type
exp[] and an environment r which maps variables declared inthe context

 to closed values. The environment is represented asa substitution with domain

 and range empty and has the type
[.]. The result of the interpreter is a closed value. Similar tothe box-construct which injects open data-objects into the computation, we use the sbox-construct to inject data-level substitutionsinto the computation. We will use capital letters

S to describe sub-stitution variables which may occur in patterns, and similar to other

contextual variables we think of substitution variables as closures,providing a built-in operation for composing substitutions.

rec eval:\Pi  :(nat)*. exp[] ! [.] ! nat[.] =
\Lambda   ) fn e ) fn r ) let sbox (S[.]) = r incase

e ofbox
(.Nat U[id]) ) box(U[S[.]])
| box (.Add U1[id] U2[id]) )let val

a = eval de box(.U1[id]) r
val b = eval de box(.U2[id]) rin
add(a, b) end
| box (.Let W[id] (*x. U[id, x])) )let

box V[.] = eval de box(.W[id]) rin
eval d,x:natebox

(,x. U[id,x]) sbox(S[.], V[.])end

end

When we encounter a natural number as in the first case, wecan simply apply the substitution

S[.] to the object U. Since thesubstitution
S[.] has domain  and range empty, applying it tothe meta-variable

U yields a closed object. Because we apply S[.]as soon as we know what

U stands for, the variable occurring inthe instantiation for
U will now be replaced by its correct corre-sponding value. Closures thereby provide us with built-in support

for substitutions. The type system guarantees that the environment
r provides closed instantiations for every variable in the local con-text

, and applying the substitution S[.] to the contextual variable
U must yield a closed natural number.

When evaluating box (.Let W[id] (*x.U[id,x])), weevaluate the expression box

(.W[id]) in the environment r tosome closed value
V, and then evaluate box (,x.W[id,x]) inthe extended environment where we associate the binder

x with thevalue
V. Since we think of substitutions by position, we do not maketheir domain explicit and simply write sbox

(S[.], V[.])In traditional approaches where names are first-class, as in

FreshML, or where variables are represented by strings or de Bruijnindices, environments are usually implemented as a list of pairs
consisting of variable name and their corresponding value. How-ever, the type system cannot easily guarantee that the environment
indeed provides closed values for all free variables occurring inthe expression. Moreover, one needs to write a lookup-function for
retrieving a value from the environment and a substitution func-tion for replacing the occurrence of the free variable with its corresponding value. In contrast, our foundation enforces a stronginvariant about the relationship between the expression we are analyzing and the environment.
Remark: Higher-order pattern matching and its trade-offs
We would like to emphasize that our interest is in designing atype-theoretic foundation for programming with HOAS and the

code snippets presented are intended to model our theory closelyto provide an intuition. It is not necessarily intended as the source
language which a programmer would use.As mentioned earlier, we treat contextual variables uniformly
as closures and allow full higher-order pattern matching to instan-tiate contextual variables. In higher-order patterns (Miller 1991),
the substitution associated with contextual variables must consistof some distinct bound variables, and pattern matching must enforce checks on bound variables. The cost of checking for variabledependencies is hidden from the user (see for example the function cntV or isVal). Linear higher-order patterns (Pientka andPfennning 2003) restrict higher-order patterns such that every contextual variable must be applied to all the bound variables in whosescope it occurs. In this case no bound variable dependency checks
are necessary (see Section 3.4) yielding an efficient matching al-gorithm closely resembling first-order matching. Our foundation
leaves implementors a choice of whether to enforce linear higher-order patterns dynamically or statically. To enforce them dynamically, one translates every pattern into a linear one with potentiallyadditional constraints (see (Pientka and Pfennning 2003)). Consequently, only if bound variable checks are necessary, they will bedone. Alternatively, if we enforce it statically, then all contextual
variables must be applied to all the bound variables. In this case,contextual variables occurring in patterns can be simply described
by U or p and not as closure U[id] and p[id]. To check whetheran object depends on a bound variable we can write a separate function. To illustrate, we present a function for counting occurrencesof a variable

x in a natural number.

rec cntVN : \Pi  :(nat)*.nat[] ! nat[] ! int =
\Lambda   ) fn e ) fn e' ) let box (. p'[id]) = e' incase

e ofbox
(. z) ) 0
| box (. p[id]) )if box

(.p'[id]) = box(. p[id]) then 1 else 0

| box (. suc U[id]) ) cntVN de box(. U[id]) e'end

If we elide the identity substitutions associated with the con-textual variables, we obtain a program which closely resembles
the one we write in a nominal style1. Closures however provideus with direct built-in substitution operation. As shown in the

1 There are two remaining differences: First, our foundation makes the
context (= set of names) explicit. This is necessary if we want to reason

environment-based interpreter, the closure of meta-variable andsubstitution allows us to retrieve a value. Similarly, when implementing a substitution-based interpreter, we can use closuresto propagate instantiation. Providing not only direct support for
binders but also substitution, is the essence in higher-order abstractsyntax. However, this discussion seems to suggest that basic operations provided by nominal systems can be explained by imposingspecial restrictions on our foundation.

Summary of key ideas
We summarize here the four key ideas underlying our work: First,we separate the data from the computation via the modality box.

Second, every data-object is closed with respect to a local con-text. For example, box

(x1,x2.Add (Nat(suc x1)) (Nat x2)
) denotes a data-object of type exp[x1:nat,x2:nat]. The box-construct introduces the bound variables

x1 and x2. Third, we al-low context variables
 and abstract over them on the computationlevel. This is necessary since the concrete bound variables occurring in a data-object are only exposed once we recursively traversea binder, and the context describing these variables may grow. Context abstraction via \Lambda  binds every occurrence of  in the expression
e. Fourth, we provide closures consisting of a contextual variableand a postponed substitution. When replacing the contextual variable with a concrete object, we apply the substitution thereby pro-viding built-in support for substitutions. We support three kinds of
contextual variables, meta-variables which can be instantiated withan arbitrary object, parameter variables which can be instantiated
with bound variables only, and substitution variables which repre-sent first-class substitutions. While meta-variables allow us to deconstruct arbitrary objects with binders, parameter variables allowsus to manipulate names of bound variables directly in computation.

3. Data-level terms, substitutions, contexts
In this section, we concentrate on the formal definition and typesystem for data-objects. The definition of computation-level expressions which allow recursion and pattern matching on data-objects is discussed later in Section 4.

Our theoretical development is closely based on contextualmodal type theory by Nanevski et al. (2006) which we extend
with pairs and projections and more importantly with parametervariables and substitution variables as well as context variables.
For simplicity, we also restrict our data-objects to the simply-typedfragment, however the ideas can be extended to the dependently
typed setting (see Nanevski et al. (2006) for more details).

Types A, B ::= P | A ! B | A * BNormal Terms

M, N ::= *x. M | (M, N) | RNeutral Terms
R ::= c | x | u[oe] | p[oe] | R N | projiRSubstitutions
oe, ae ::= * | oe ; M | oe , R | s[oe] | id

Context Schema W ::= A | (W )* | W1 + W2Contexts

\Psi , \Phi  ::= * |  | \Psi , x:AMeta-contexts
\Delta  ::= * | \Delta , u::A[\Psi ] | \Delta , p::A[\Psi ] |

\Delta , s::\Psi [\Phi ]Context Schema

context \Omega  ::= * | \Omega , ::W

Following a recent presentation technique for logical frame-works due to Watkins et al. (2002) our syntax only allows for objects which are in canonical form since only these are meaningful

about the closedness of an object, and is also done for example in pureFreshML by Pottier (2007). Since context schemas classify contexts, we
naturally can distinguish between different sets of names. Second, unlikenominal type systems which have a special type

atom for names, our typesystem does not distinguish between a type for names and objects.

for representing object-languages. This is achieved by distinguish-ing between normal terms

M and neutral terms R. While the syntaxonly guarantees that terms

N contain no fi-redices, the typing ruleswill also guarantee that all well-typed terms are fully

j-expanded.We distinguish between four different kinds of variables in our

theory: Ordinary bound variables are used to represent data-levelbinders and are bound by

*-abstraction. Contextual variables standfor open objects and they include meta-variables

u which repre-sent general open objects and parameter variables

p which canonly be instantiated with an ordinary bound variable, and substitution variables s which represent a mapping from one context toanother. Contextual variables are introduced in case-expressions on
the computation level, and can be instantiated via pattern matching.They are associated with a postponed substitution

oe thereby repre-senting a closure. Our intention is to apply
oe as soon as we knowwhich term the contextual variable should stand for. The domain of

oe therefore describes the free variables which can possibly occurin the object which represents the contextual variable, and our type
system will ensure statically that this is indeed the case.Substitutions

oe are built of either normal terms (in oe ; M) oratomic terms (in

oe , R). We do not make the domain of the sub-stitutions explicit. This will simplify the theoretical development

and avoid having to rename the domain of a given substitution oe.Similar to meta-variables, substitution variables are closures with a
postponed substitution. We also require a first-class notion of iden-tity substitution

id. Our convention is that substitutions, as definedoperations on data-level terms, are written in prefix notation

[oe]Nfor a data-level substitution. Contextual variables such as the metavariables u, parameter variables p, and substitution variables s aredeclared in the meta-context

\Delta , while ordinary bound variables aredeclared in the context
\Psi .Finally, our foundation supports context variables

 which al-low us to reason abstractly with contexts. Abstracting over contexts is an interesting and essential next step to allow recursionover higher-order abstract syntax. Context variables are declared in
the context \Omega . Unlike previous uses of context variables for exam-ple in (McCreight and Sch"urmann 2004), a context may at most
contain one context variable. In the same way as types classifyobjects, and kinds classify types, we will introduce the notion of
a context schema W which classifies contexts \Psi . We will say acontext

\Psi  belongs to context schema W or a context \Psi  is an el-ement of the context schema

W , if it consists of declarations x:Awhere
A occurs in W . Context schemas are described by a sub-set of regular expressions. For example, a context schema

A + Bdescribes any context which contains declarations of the form

x:Aor
y:B. Concept schemas resemble the notion of worlds describedin (Sch"urmann 2000), however while similar in spirit, we simplify

matters by drawing on the power of pairs and cross-products to ex-press the relationship between multiple objects in a context.

We assume that type constants and object constants are declaredin a signature

\Sigma  which we typically suppress since it never changesduring a typing derivation. However, we will keep in mind that all

typing judgments have access to a well-formed signature.
3.1 Data-level typing
Next, we present a bi-directional type system for data-level terms.Typing is defined via the following judgments:

\Omega ; \Delta ; \Psi  ` M ( A Check normal object M against A
\Omega ; \Delta ; \Psi  ` R ) A Synthesize A for neutral object R
\Omega ; \Delta ; \Phi  ` oe ( \Psi  Check oe against context \Psi 
\Omega  ` \Psi  ( W Context \Psi  checks against schema W

For better readability, we omit \Omega  in the subsequent develop-ment since it is constant and assume that context

\Delta  and \Psi  are

well-formed. First, the typing rules for objects. We will tacitly re-name bound variables, and maintain that contexts and substitutions
declare no variable more than once. Note that substitutions oe aredefined only on ordinary variables

x and not contextual variables.Moreover, we require the usual conditions on bound variables. For

example in the rule for *-abstraction the bound variable x must benew and cannot already occur in the context

\Psi . This can be alwaysachieved via
ff-renaming. We are also explicit about ff-renaming in

the rule for substitution variables where ff= describes equality be-tween two contexts up to renaming.

Data-level normal terms

\Delta ; \Psi , x:A ` M ( B
\Delta ; \Psi  ` *x. M ( A ! B

\Delta ; \Psi  ` R ) P 0 P 0 = P

\Delta ; \Psi  ` R ( P

\Delta ; \Psi  ` M1 ( A1 \Delta ; \Psi  ` M2 ( A2

\Delta ; \Psi  ` (M1, M2) ( A1 * A2

Data-level neutral terms

x:A 2 \Psi 
\Delta ; \Psi  ` x ) A

c:A 2 \Sigma 
\Delta ; \Psi  ` c ) A

\Delta ; \Psi  ` R ) A1 * A2

\Delta ; \Psi  ` projiR ) Ai

u::A[\Phi ] 2 \Delta  \Delta ; \Psi  ` oe ( \Phi 

\Delta ; \Psi  ` u[oe] ) A

p::A[\Phi ] 2 \Delta  \Delta ; \Psi  ` oe ( \Phi 

\Delta ; \Psi  ` p[oe] ) A

\Delta ; \Psi  ` R ) A ! B \Delta ; \Psi  ` N ( A

\Delta ; \Psi  ` R N ) B

Data-level substitutions

\Delta ; \Psi  ` * ( * \Delta ; , \Psi  ` id ( 
s::\Phi 1[\Phi 2] 2 \Delta  \Delta ; \Psi  ` ae ( \Phi 2 \Phi  ff= \Phi 1

\Delta ; \Psi  ` (s[ae]) ( \Phi 

\Delta ; \Psi  ` oe ( \Phi  \Delta ; \Psi  ` R ) A0 A = A0

\Delta ; \Psi  ` (oe , R) ( (\Phi , x:A)

\Delta ; \Psi  ` oe ( \Phi  \Delta ; \Psi  ` M ( A

\Delta ; \Psi  ` (oe ; M) ( (\Phi , x:A)

In the simultaneous substitutions oe, we do not make its domainexplicit. Rather we think of a substitution as a list of normal and

neutral terms, and if oe has domain \Psi  the i-th element in oe corre-sponds to the i-th declaration in

\Psi . We can turn any substitution
oe which does not make its domain \Psi  explicit into one which doesby

oe/\Psi . We distinguish between substituting a normal term Mand a neutral term

R. This is justified by the nature of hypotheti-cal judgments, since an assumption

x:A represents x ) A so wecan substitute
R for x if R ) A. This distinction between normaland neutral terms is necessary since we can extend a given simultaneous substitution oe with x and obtain (oe , x) when traversing abinding operator in a type-free way. We could not extend the simultaneous substitutions with (oe ; x), since x is not a canonical termunless it is of atomic type. Identity substitutions can now have the
form (x1 , . . . , xn). The typing rules for substitutions also makeclear that the identity substitution

id is necessary once we intro-duce context variables. Without the identity substitution

id, wewouldn't be able to construct substitutions where the domain is described abstractly by the context variable . Finally, we presentcontext schema checking.

Context \Psi  checks against a context schema W
A 2 W \Omega  ` \Psi  ( W

\Omega  ` \Psi , x : A ( W

::W 2 \Omega 
\Omega  `  ( W \Omega  ` * ( W

Essentially a context is well-formed, if every declaration xi:Aiis declared in the context schema

W = A1 + A2 + . . . + An.
A 2 W succeeds if W = (A1 + . . . + An)* and there exists an Ais.t.

A = Ai.

Theorem 3.1. [Decidability of Type Checking]All judgments in the contextual modal type theory are decidable.

3.2 Substitution
Since we have different kinds of variables, context variables , or-dinary variables

x, and contextual variables, this gives rise to differ-ent substitution operations. These different substitution operations

are key to the elegant and simple preservation and progress proof.
Substitution for context variables
We begin by considering the substitution operation for contextvariables. The most interesting cases are where actual substitution

happens. If we encounter a context variables , then we simplyreplace it with the context

\Psi . When we apply the substitution
[[\Psi /]] to the context \Phi , x:A, we apply the substitution to thecontext

\Phi  to yield some new context \Phi 0. However, we must checkwhether

x occurs in the variables declared in \Phi 0, i.e. x 62 V(\Phi 0),to avoid name clashes. This side condition can always be met by

appropriately renaming bound variable occurrences.

Data-level context
[[\Psi /]](*) = *
[[\Psi /]](\Phi , x:A) = (\Phi 0, x:A) if x 62 V(\Phi 0) and [[\Psi /]]\Phi  = \Phi 0
[[\Psi /]]() = \Psi 
[[\Psi /]](OE) = OE

The remaining definition is mostly straightforward. Since, con-text variables occur in the identity substitution

id, we must applythe context substitution to objects and in particular to substitutions.

When we replace  with \Psi  in id, we unfold the identity sub-stitution. Expansion of the identity substitution is defined by the
operation id(\Psi ) for valid contexts \Psi  as follows:

id(*) = *
id(\Psi , x:A) = id(\Psi ) , x
id() = id

Lemma 3.1. [Unfolding identity substitution]If

id(\Psi ) = oe then \Delta ; \Psi , \Psi 0 ` oe ( \Psi .

Theorem 3.2. [Substitution for context variables]If

\Omega , ::W, \Omega 0; \Delta ; \Phi  ` J and \Omega  ` \Psi  ( Wthen

\Omega , \Omega 0; [[\Psi /]]\Delta ; [[\Psi /]](\Phi ) ` [[\Psi /]]J.

Ordinary substitution
In the definition for ordinary data-level substitutions, we need tobe a little bit careful because the only meaningful data-level terms

are those which are in canonical forms. To ensure that substitutionpreserves canonical forms, we will employ a technique pioneered
by Watkins et. al. (Watkins et al. 2002) and described in detail in(Nanevski et al. 2006). The idea is to define hereditary substitution as a primitive recursive functional which will always return acanonical object. In places where the ordinary substitution would
construct a redex (*y. M) N we must continue, substituting N for
y in M. Since this could again create a redex, we must continueand hereditarily substitute and eliminate potential redices. We define the hereditary substitution operations for normal object, neutralobjects and substitutions next.

[M/x]nA(N) = N0 Hereditary substitution into N
[M/x]rA(R) = R0 or M0 : A0 Hereditary substitution into R
[M/x]sA(oe) = oe0 Hereditary substitution into oe

Each of these hereditary substitution operations will be definedby nested induction, first on the structure of the type

A and secondon the structure of the objects
N, R, and oe. In other words, weeither go to a smaller type, in which case the objects themselves

can become larger, or the type remains the same and the objectsbecome smaller. We write

A <= B and A < B if A occurs in
B (as a proper subexpression in the latter case). For an in depthdiscussion, we refer the reader to (Nanevski et al. 2006).

Data-level normal terms
[M/x]nA(*y. N) = *y. N0 where N0 = [M/x]nA(N)choosing

y 62 FV(M), and y 6= x

[M/x]nA(M1, M2) = (N1, N2) if [M/x]nA(M1) = N1 and

[M/x]nA(M2) = N2

[M/x]nA(R) = M0 if [M/x]rA(R) = M0 : A0
[M/x]nA(R) = R0 if [M/x]rA(R) = R0
[M/x]nA(N) fails otherwise

Data-level neutral terms
[M/x]rA(x) = M : A
[M/x]rA(y) = y if y 6= x
[M/x]rA(u[oe]) = u[oe0] where oe0 = [M/x]sA(oe)
[M/x]rA(p[oe]) = p[oe0] where oe0 = [M/x]sA(oe)
[M/x]rA(R N) = R0 N0 where R0 = [M/x]rA(R) and

N0 = [M/x]nA(N)

[M/x]rA(R N) = M00 : Bif

[M/x]rA(R) = *y. M0 :A1 ! B where
A1 ! B <= A and N0 = [M/x]nA(N)and

M00 = [N0/y]nA1(M0)

[M/x]rA(proji R) = Ni : Aiif

[M/x]rA(R) = (N1, N2):A1 * A2

[M/x]rA(proji R) = proji R0 if [M/x]rA(R) = R0
[M/x]rA(R) fails otherwise

Data-level substitution
[M/x]sA(*) = *
[M/x]sA(oe ; N) = (oe0 ; N0) where oe0 = [M/x]sA(oe)and

N0 = [M/x]nA(N)

[M/x]sA(oe , R) = (oe0 , R0) if [M/x]rA(R) = R0and

oe0 = [M/x]sA(oe)

[M/x]sA(oe , R) = (oe0 ; M0) if [M/x]rA(R) = M0 : A0and

oe0 = [M/x]sA(oe)

[M/x]sA(s[oe]) = s[oe0] where oe0 = [M/x]sA(oe)
[M/x]sA(id) = id
[M/x]sA(oe) fails otherwise

If the original term is not well-typed, a hereditary substitution,though terminating, cannot always return a meaningful term. We

formalize this as failure to return a result. However, on well-typedterms, hereditary substitution will always return well-typed terms.

Theorem 3.3. [Termination]

1. If [M/x]rA(R) = M0 : A0 then A0 <= A
2. [M/x]*A( ) terminates, either by returning a result or failingafter a finite number of steps.

Theorem 3.4. [Hereditary Substitution Principles]If

\Delta ; \Psi  ` M ( A and \Delta ; \Psi , x:A, \Psi 0 ` J then
\Delta ; \Psi , \Psi 0 ` [M/x]*A(J) where * = {n, r, s}.

Building on the discussed ideas and extending (Nanevski et al.2006), we can define also simultaneous substitution

[oe]n\Psi (M)(
[oe]r\Psi (R), [oe]s\Psi (oe) resp.).

Contextual substitution for contextual variables
Substitutions for contextual variables are a little more difficult. Wediscuss next the three kinds of contextual variables, meta-variables

u, parameter-variables p, and substitution variables s.
Contextual substitution for meta-variables We can think of u[oe]as a closure where, as soon as we know which term

u should standfor, we can apply
oe to it. The typing will ensure that the type of
M and the type of u agree, i.e. we can replace u which has type
A[\Psi ] with a normal term M if M has type A in the context \Psi .Because of

ff-conversion, the variables that are substituted at dif-ferent occurrences of

u may be different, and we write the contextual substitution as [[ ^\Psi .M/u]]nA[\Psi ](N), [[ ^\Psi .M/u]]rA[\Psi ](R), and

[[ ^\Psi .M/u]]sA[\Psi ](oe), where ^\Psi  binds all free variables in M. Thiscomplication can be eliminated in an implementation of our calculus based on de Bruijn indexes. The typing annotation A[\Psi ] isnecessary since we apply the substitution

oe hereditarily once weknow which term
u represents, and hereditary substitution requiresthis information to ensure termination. In defining the substitution

we must pay attention that normal forms are preserved. We showcontextual substitution into data-level terms next. For better readability, we will write a as an abbreviation for the type A[\Psi ].

Data-level normal terms
[[ ^\Psi .M/u]]na (*y. N) = *y. N0 where [[ ^\Psi .M/u]]na N = N0
[[ ^\Psi .M/u]]na (N1, N2) = (N01, N02) where [[ ^\Psi .M/u]]na (N1) = N01

and [[ ^\Psi .M/u]]na (N2) = N02

[[ ^\Psi .M/u]]na (R) = R0 where [[ ^\Psi .M/u]]ra(R) = R0
[[ ^\Psi .M/u]]na (R) = M0 where [[ ^\Psi .M/u]]ra(R) = M0 : A
[[ ^\Psi .M/u]]na (N) fails otherwise

Data-level neutral terms
[[ ^\Psi .M/u]]ra(x) = x
[[ ^\Psi .M/u]]ra(c) = c
[[ ^\Psi .M/u]]ra(u[oe]) = N : A where [[ ^\Psi .M/u]]saoe = oe0

and [oe0/\Psi ]n\Psi M = N
[[ ^\Psi .M/u]]ra(u0[oe]) = u0[oe0] where [[ ^\Psi .M/u]]saoe = oe0choosing

u0 6= u

[[ ^\Psi .M/u]]ra(p[oe]) = p[oe0] where [[ ^\Psi .M/u]]saoe = oe0
[[ ^\Psi .M/u]]ra(R N) = (R0 N0) where [[ ^\Psi .M/u]]raR = R0

and [[ ^\Psi .M/u]]na (N) = N0

[[ ^\Psi .M/u]]ra(R N) = M0 : A2

if [[ ^\Psi .M/u]]raR = *x. M0 : A1 ! A2 for A1 ! A2 <= A[\Psi ]

and [[ ^\Psi .M/u]]na (N) = N0 and [N0/x]nA1(M0) = M0

[[ ^\Psi .M/u]]ra(projiR) = projiR0 if [[ ^\Psi .M/u]]ra(R) = R0

[[ ^\Psi .M/u]]ra(projiR) = Mi : Ai

if [[ ^\Psi .M/u]]ra(R) = (M1, M2) : A1 * A2

[[ ^\Psi .M/u]]ra(R) fails otherwise

Applying [[ ^\Psi .M/u]]rA[\Psi ] to the closure u[oe] first obtains the simultaneous substitution oe0 = [[ ^\Psi .M/u]]sA[\Psi ]oe, but instead of returning M[oe0], it proceeds to eagerly apply oe0 to M. Howeverbefore we apply

oe0 to M we recover its domain by [oe0/\Psi ]. Toenforce that we always return a normal object as a result of contextual substitution, we carry the type of the meta-variable u whichwill be replaced. In the case where we would possibly obtain a
non-normal object, we resort to ordinary hereditary substitution inorder to guarantee that the final result of contextual substitution is
in normal form.

Contextual substitution for parameter variables Contextual sub-stitution for parameter variables follows similar principles, but it
substitutes an ordinary variable for a parameter variable. This couldnot be achieved with the previous definition of contextual substitution for meta-variables since it only allows us to substitute a nor-mal term for a meta-variable and

x is only a normal term if it is ofatomic type. In the case where we encounter a parameter variable

p[oe], we replace p with the ordinary variable x and apply the substitution [[ ^\Psi .x/p]] to oe. This may yield a normal term, and hencewe must again ensure that our contextual substitution for parameter variables preserves normal forms. We only show here the casewhere substitution actually happens and again write

a as an abbre-viation for
A[\Psi ].

[[ ^\Psi .x/p]]ra(p[oe]) = M : A if [[ ^\Psi .x/p]]saoe = oe0 and

[oe0/\Psi ]r\Psi x = M : A

[[ ^\Psi .x/p]]ra(p[oe]) = R if [[ ^\Psi .x/p]]saoe = oe0 and [oe0/\Psi ]r\Psi x = R
[[ ^\Psi .x/p]]ra(p0[oe]) = p0[oe0] where [[ ^\Psi .x/p]]saoe = oe0

The distinction between parameter variables and meta-variablesis mainly interesting from an operational point of view.

Substitution for substitution variables in data-level terms Fi-nally, we give a brief definition for substituting for substitution
variables. To ensure it works correctly with the previously definedsubstitution operations, we also annotate it with the type of the substitution variable. We will abbreviate \Phi [\Psi ] as c, and concentrate onthe case for substitution.

[[ ^\Psi .oe/s]]sc(*) = *
[[ ^\Psi .oe/s]]sc(ae ; N) = (ae0 ; N0) if [[ ^\Psi .oe/s]]scae = ae0

and [[ ^\Psi .oe/s]]nc N = N0

[[ ^\Psi .oe/s]]sc(ae , R) = (ae0 , R0) if [[ ^\Psi .oe/s]]scae = ae0

and [[ ^\Psi .oe/s]]rcR = R0

[[ ^\Psi .oe/s]]sc(s[ae]) = oe0 if ([[ ^\Psi .oe/s]]scae) = ae0and

[ae0/\Psi ]s\Psi oe = oe0 and c = \Phi [\Psi ]

[[ ^\Psi .oe/s]]sc(s0[ae]) = s0[ae0] if [[ ^\Psi .oe/s]]scae = ae0
[[ ^\Psi .oe/s]]sc(idOE) = idOE
[[ ^\Psi .oe/s]]sc(ae) fails otherwise

Applying [[ ^\Psi .oe/s]]s\Phi [\Psi ] to the closure s[ae] first obtains the simultaneous substitution ae0 = [[ ^\Psi .oe/s]]s\Phi [\Psi ]ae, but instead of returning oe[ae0], it proceeds to eagerly apply ae0 to oe.

Theorem 3.5. [Termination] [[ ^\Psi .M/u]]*A[\Phi ]( ), [[ ^\Psi .x/p]]*A[\Phi ]( )
and [[ ^\Psi .oe]]*\Phi [\Psi ]( ) terminate, either by returning a result or failingafter a finite number of steps.

Theorem 3.6. [Contextual Substitution Principles]

1. If \Delta 1; \Phi  ` M ( A and \Delta 1, u::A[\Phi ], \Delta 2; \Psi  ` J

then \Delta 1, \Delta 2; \Psi  ` [[^\Phi .M/u]]*A[\Phi ]J where * = {n, r, s}.

2. If \Delta 1; \Phi  ` x ) A and \Delta 1, p::A[\Phi ], \Delta 2; \Psi  ` J

then \Delta 1, \Delta 2; \Psi  ` [[^\Phi .x/p]]*A[\Phi ]J where * = {n, r, s}.
3. If \Delta ; \Phi  ` oe ( \Psi 1 and \Delta 1, s::\Psi 1[\Phi ], \Delta 2; \Psi  ` J

then \Delta 1, \Delta 2; \Psi  ` [[^\Phi .oe/s]]*\Psi 1[\Phi ]J where * = {n, r, s}.

3.3 Simultaneous contextual substitution
Often it is convenient to allow simultaneous contextual substitu-tion

`. Typing rules for simultaneous contextual substitutions canbe defined via the judgment

\Delta 0 ` ` ( \Delta , where \Delta  denotes thedomain of the contextual substitution

` and \Delta 0 describes its range.

Just as we annotate the contextual substitution [[ ^\Psi .M/u]]*A[\Psi ] with

the type of the meta-variable u, we annotate the simultaneous con-textual substitution

` with its domain \Delta . This is necessary because

when applying the substitution ` = (`1, ^\Psi .M/u, `2) to a closure
u[oe], we instantiate u with a term M and then apply to it the substi-tution

[[`]]oe. Since the ordinary simultaneous substitution operationis annotated with its domain, we annotate also the simultaneous

contextual substitution with its domain.

\Delta 0 ` * ( *

\Delta 0 ` ` ( \Delta  \Delta 0; \Psi  ` M ( A
\Delta 0 ` (`, ^\Psi .M/u) ( \Delta , u::A[\Psi ]

\Delta 0 ` ` ( \Delta  x:A 2 \Psi 
\Delta 0 ` (`, ^\Psi .x/p) ( \Delta , p::A[\Psi ]

\Delta 0 ` ` ( \Delta  \Delta 0; \Psi  ` oe ( \Phi 
\Delta 0 ` (`, ^\Psi .oe/s) ( \Delta , s::\Phi [\Psi ]

Definition of the simultaneous contextual substitution is astraightforward extension of the previous substitution operation.

Theorem 3.7. [Simultaneous contextual substitution]If

\Delta 0 ` ` ( \Delta  and \Delta ; \Psi  ` J then \Delta 0; \Psi  ` [[`]]*\Delta J where*
= {n, r, s}.

3.4 Linear higher-order pattern matching
Data-level terms represent our data which we analyze via patternmatching in computations. In this section, we describe a pattern

matching algorithm for linear higher-order patterns. Linear higher-order patterns (Pientka and Pfennning 2003) are data-level terms
where we impose the following two restrictions on contextual vari-ables: First, contextual variables must occur uniquely. Second, they
are applied to all bound variables in whose scope they occur. In oursetting, this means the postponed substitution

oe associated with acontextual variable must be a substitution which maps all variables

to distinct variables. We will write ss for the substitution whichhas domain and range

\Psi . The identity substitution is the simplestform of
ss, but in general we can allow permutations of variables.As mentioned earlier, linear higher-order patterns refine the notion

of higher-order patterns as identified by Miller (Miller 1991), andeliminate expensive checks for bound variable dependencies. For
the theoretical development, we enforce that every meta-variablemust be of base type. This can always be achieved by lowering.
Pattern matching for data-level terms is then defined as follows:

\Delta ; ^\Psi  ` M1 .= M2/` Ground term M2 matches M1
\Delta ; ^\Psi  ` R1 + R2/` Ground term R2 matches R1
\Delta ; ^\Psi  ` oe1 .= oe2/` Ground substitution oe1 matches oe2

In the judgments describing matching we will keep a context^
\Psi  which describes the ordinary variables occurring in M1 and M2and

R1 and R2 respectively. Let \Delta  describe the meta-variables,parameter variables and substitution variables. Only

M1, R1, and
oe1 may contain contextual variables which we will instantiate viamatching. The result of matching

M2 against M1 will be a contex-tual simultaneous substitution
` for all the contextual variables in
M1, s.t. [[`]]n\Delta M1 = M2 and [[`]]r\Delta R1 = R2.

Matching normal objects

\Delta ; ^\Psi , x ` M .= N/`
\Delta ; ^\Psi  ` *x. M .= *x. N/`

\Delta ; ^\Psi  ` R + R0/`
\Delta ; ^\Psi  ` R .= R0/`

\Delta 1; ^\Psi  ` M1 .= M2/`1 \Delta 2; ^\Psi  ` N1 .= N2/`2
\Delta 1, \Delta 2; ^\Psi  ` (M1 , N1) .= (M2 , N2)/(`1, `2))

Matching neutral objects

*; ^\Psi  ` x + x/* *; ^\Psi  ` c + c/*
u::P [\Psi 0]; ^\Psi  ` u[ss] + R/( ^\Psi 0.[ss]-1R/u)
p::A[\Psi 0]; ^\Psi  ` p[ss] + x/( ^\Psi 0.[ss]-1x/p)

\Delta ; ^\Psi  ` R + R0/`
\Delta ; ^\Psi  ` projiR + projiR0/`

\Delta 1; ^\Psi  ` R1 + R2/`1 \Delta 2; ^\Psi  ` N1 .= N2/`2

\Delta 1, \Delta 2; ^\Psi  ` R1 N1 + R2 N2/(`1, `2)
This matching algorithm extends ideas on higher-order patternunification (Pientka and Pfennning 2003; Pientka 2003) to handle

parameter variables and substitution variables. Note that we willonly match a term against another if both have the same type. The
interesting cases are when we match a neutral term R against acontextual modal variable

u[ss], a substitution oe against a substi-tution variable
s[ss], and a parameter x against a parameter vari-able
p[ss]. We first consider matching a neutral term R against themeta-variable

u[ss]. Since we require that all meta-variables u areapplied to all bound variables whose scope they occur in, we can

simply apply the inverse substitution [ss]-1 to the object R. If ss is
a substitution with domain \Psi 0 and range \Psi  then [ss]-1 is the substi-tution with domain

\Psi  and range \Psi 0. Since we require that \Psi 0 is a

permutation of \Psi , applying the inverse substitution [ss]-1 to R willonly rename variables and must always succeed since all variables

possibly occurring in R are in the range of ss. If ss is the identity
substitution then we have [ss]-1R = R. We note that the algorithmabove is strikingly similar to first-order matching algorithms. If one

would like to allow the full pattern fragment where meta-variablesare only required to be applied to some bound variables, then we
must check whether applying the inverse substitution to the object
R does in fact exist. This requires a traversal of R. For a more de-tailed discussion we refer the reader to (Pientka 2003).

The rules for matching against substitutions are straightforward.We note that we do not consider the case of matching against the
identity substitution id since our operational semantics will en-force that all context variables have been instantiated and therefore
all identity substitutions have been unrolled.

Matching substitutions

*; ^\Psi  ` * .= */* s::\Phi [\Psi ]; ^\Psi  ` s[ss] .= ae/ ^\Psi .[ss]-1ae/s
\Delta 1; ^\Psi  ` oe .= ae/`1 \Delta 2; ^\Psi  ` M .= N/`2

\Delta 1, \Delta 2; ^\Psi  ` (oe ; M) .= (ae ; N)/(`1, `2)

\Delta 1; ^\Psi  ` oe .= ae/`1 \Delta 2; ^\Psi  ` R .= R0/`2

\Delta 1, \Delta 2; ^\Psi  ` (oe , R) .= (ae , R0)/(`1, `2)

Soundness of linear higher-order pattern matching ensuresthat if an object

N pattern matches against an object M then
[[`]]n\Delta (M) = N. We require that M is indeed well-typed and isa linear higher-order pattern, i.e. all contextual variables occur

uniquely and are applied to all bound variables whose scope theyoccur in, which is described by the judgment

\Delta ; \Psi  `l J.

Theorem 3.8. [Soundness of linear higher-order pattern matching]

1. If \Delta ; \Psi  `l M ( A and *; \Psi  ` N ( A and \Delta ; ^\Psi  ` M .= N/`then * `

` ( \Delta  and [[`]]n\Delta M = N.

2. If \Delta ; \Psi  `l R ) A and *; \Psi  ` R0 ) A0 and A = A0,

\Delta ; ^\Psi  ` R + R0/` then * ` ` ( \Delta  and [[`]]r\Delta R = R0.

3. If \Delta ; \Psi  `l oe ( \Phi  and *; \Psi  ` ae ( \Phi  and \Delta ; ^\Psi  ` oe .= ae/`then * `

` ( \Delta  and [[`]]s\Delta oe = ae.

Proof. By structural induction on the matching judgment.
Theorem 3.9. [Completeness of higher-order pattern matching]

1. If \Delta ; \Psi  `l M ( A and *; \Psi  ` N ( A and [[`]]nffi M = N and* `

` ( \Delta  then \Delta ; ^\Psi  ` M .= N/`.
2. If \Delta ; \Psi  `l R ) A and *; \Psi  ` R0 ) A0, and A = A0, and* `

` ( \Delta  and [[`]]rffiR = R0, then \Delta ; ^\Psi  ` R + R0/`.
3. If \Delta ; \Psi  ` oe ( \Phi  and *; \Psi  ` ae ( \Phi  and * ` ` ( \Delta  and

[[`]]sffioe = ae then \Delta ; ^\Psi  ` oe .= ae/`.

Proof. Induction on M, R and oe respectively.
4. Computation-level expressions
Our goal is to cleanly separate the object level and the computationlevel. While the object level describes data, the computation level

describes the programs which operate on data. Computation-leveltypes may refer to data-level types via the contextual type

A[\Psi ]which denotes an object of type
A which may contain the variablesspecified in
\Psi . To allow quantification over context variables , weintroduce a dependent type

\Pi :W.o/ where W denotes a contextschema and context abstraction via

\Lambda .e. We overload the !which is used to denote function types at the object level as well

as the computation level. However, it should be obvious from theusage which one we mean.

Types o/ ::= A[\Psi ] | \Phi [\Psi ] | o/1 ! o/2 | \Pi ::W.o/Expressions

e ::= y | rec f.e | fn y.e | \Lambda .e | e1 e2 |

box( ^\Psi . M) | sbox( ^\Psi . oe) | e d\Psi e |
(e : o/) | (case e of b1 | . . . | bn )

Branch b ::= box( ^\Psi . M) 7! e | sbox( ^\Psi . oe) 7! e |

\Pi p::A[\Psi ].b | \Pi u::P [\Psi ].b | \Pi s::\Phi [\Psi ].bContexts
\Gamma  ::= * | \Gamma , y:o/

Data can be injected into programs via the box-construct
box( ^\Psi . M). Sine we do not need types inside objects, we write^
\Psi  for a list of variables x1, . . . , xn which we think of as a context
\Psi  without types. Here M denotes an data-level term which has type

A in the context \Psi . Annotating the box-construct with ^\Psi , i.e. thelist of variables occurring in

M, is necessary due to ff-conversion,and some renaming of bound variables may be necessary to bring

the variables in A[\Psi ] in accordance with the variables in ^\Psi .M. Wekeep

\Psi  as a proper context since in the dependent type case A maydepend on it. It is worth pointing out that in an implementation

with de Bruijn indices this complication can be eliminated.

Similarly, we can inject substitutions sbox(^\Phi . oe) which are oftype

\Psi [\Phi ] where \Psi  is the domain of the substitution oe and \Phi  is itsrange. Due to

ff-conversion issues we list the variables occurringin the range of the substitution. Since substitutions can be viewed

as pairs between variables and data-level terms, this facility essen-tially allows us to model explicit environments. Finally, we allow
pattern matching on data-level terms via case-expression. In ourcase-expression, we explicitly abstract over contextual variables
which occur in the pattern using the \Pi -quantifier, however thisprefix can always be reconstructed. This will simplify our metatheoretic development.

4.1 Typing rules for computation level
Next, we present bi-directional typing rules for programs whichwill minimize the amount of typing annotations. We distinguish

here between typing of expressions and branches. In the typingjudgment, we will distinguish between the context

\Omega  for contextvariables, the context for contextual variables
\Delta , and the con-text
\Gamma  which includes declarations of computation-level variables.Context variables will be introduced via context abstraction. The

contextual variables in \Delta  are introduced in the branch of a case-expression, and computation-level variables in

\Gamma  are introduced byrecursion or functions.

\Omega ; \Delta ; \Gamma  ` e ( o/ check an expression e against o/
\Omega ; \Delta ; \Gamma  ` e ) o/ synthesize o/ for expression e
\Omega ; \Delta ; \Gamma  ` b : o/0 ( o/ branch b checks against o/0 ( o/

Branches b are of the form \Pi \Delta 0.box( ^\Psi . M) 7! e, where
\Delta 0 contains all the contextual variables occurring in box( ^\Psi . M).The judgment for checking branches then stipulates that the guard

box( ^\Psi . M) checks against o/0 and the expression e checks againstthe type

o/. The typing rules for expressions are next.

Expressions

\Omega , :W ; \Delta ; \Gamma  ` e ( o/
\Omega ; \Delta ; \Gamma  ` \Lambda .e ( \Pi :W.o/

\Omega ; \Delta ; \Gamma , f:o/ ` e ( o/
\Omega ; \Delta ; \Gamma  ` rec f.e ( o/

\Omega ; \Delta ; \Gamma , y:o/1 ` e ( o/2
\Omega ; \Delta ; \Gamma  ` fn y.e ( o/1 ! o/2

\Omega ; \Delta ; \Psi  ` M ( A
\Omega ; \Delta ; \Gamma  ` box( ^\Psi . M) ( A[\Psi ]

\Omega ; \Delta ; \Psi  ` oe ( \Phi 
\Omega ; \Delta ; \Gamma  ` sbox( ^\Psi . oe) ( \Phi [\Psi ]
\Omega ; \Delta ; \Gamma  ` e ) A[\Psi ] for all i \Omega ; \Delta ; \Gamma  ` bi : A[\Psi ] ( o/

\Omega ; \Delta ; \Gamma  ` case e of b1 | . . . | bn ( o/

\Omega ; \Delta ; \Gamma  ` e ) \Phi [\Psi ] for all i \Omega ; \Delta ; \Gamma  ` bi : \Phi [\Psi ] ( o/

\Omega ; \Delta ; \Gamma  ` case e of b1 | . . . | bn ( o/

\Omega ; \Delta ; \Gamma  ` e ) o/0 o/0 = o/

\Omega ; \Delta ; \Gamma  ` e ( o/

\Omega ; \Delta ; \Gamma  ` e ( o/
\Omega ; \Delta ; \Gamma  ` (e : o/) ) o/

y:o/ 2 \Gamma 
\Omega ; \Delta ; \Gamma  ` y ) o/

\Omega ; \Delta ; \Gamma  ` e ) \Pi :W.o/ \Omega  ` \Psi  ( W

\Omega ; \Delta ; \Gamma  ` e d\Psi e ) [[\Psi /]]o/
\Omega ; \Delta ; \Gamma  ` e1 ) o/2 ! o/ \Omega ; \Delta ; \Gamma  ` e2 ( o/2

\Omega ; \Delta ; \Gamma  ` e1 e2 ) o/

Branches

\Omega ; \Delta 0; \Psi  `l M ( A \Omega ; (\Delta , \Delta 0); \Gamma  ` e ( o/

\Omega ; \Delta ; \Gamma  ` \Pi \Delta 0.box( ^\Psi . M) 7! e : A[\Psi ] ( o/

\Omega ; \Delta 0; \Psi  `l oe ( \Phi  \Omega ; (\Delta , \Delta 0); \Gamma  ` e ( o/
\Omega ; \Delta ; \Gamma  ` \Pi \Delta 0.sbox( ^\Psi . oe) 7! e : \Phi [\Psi ] ( o/

We observe the usual bound variable renaming conditions inthe rule for function abstraction, recursion, and context abstraction. Context variables are explicitly quantified and bound by \Lambda .e.There are a few interesting issues which deserve attention: First the
typing rule for box( ^\Psi . M). M denotes a data-level term whose freevariables are defined in the context

\Psi , i.e. it is closed with respect to
a context \Psi . To type box( ^\Psi . M) we switch to data-level typing, andforget about the previous context

\Gamma  which only describes assump-tions on the computation level. Our typing rules will ensure that all

variables occurring in M must have been declared in the context
\Psi . Similar reasoning holds for the typing rule for sbox( ^\Psi . oe). In

both cases, some renaming may be necessary to apply the typingrule to bring the variables in

A[\Psi ] in accordance with the variables

in ^\Psi .M. To access data, we provide a case-expression with patternmatching. The intention is to match against the contextual modal

variables occurring in the pattern. When type-checking a branch,we appeal to a linear typing judgment

\Omega ; \Delta 0; \Psi  `l M ( A, whichensures that all contextual variables occur linearly and are higherorder patterns.
Theorem 4.1. [Decidability of Type Checking]Type-checking computation-level expressions is decidable.

Proof. The typing judgments are syntax-directed and thereforeclearly decidable.

Due to space constraints, we omit here the substitution defi-nitions

[e/x]e0 and extensions of previous substitution operationssuch as

[[\Psi /]](e) and [[`]]\Delta (e). The definitions are mostly straight-forward.

5. Operational semantics
In this section, we describe a small-step operational semanticsfor the presented language. During execution type annotations are

unnecessary, and we define evaluation only on expressions whereall type annotations have been erased. First, we define the values in
this language.

Value v ::= fn y.e | \Lambda .e | box( ^\Psi . M) | sbox( ^\Psi . oe)
Next, we define a small-step evaluation judgment:

e -! e0 e evaluates in one step to e0.
(box( ^\Psi . M) .= b) -! e0 Branch b matches box( ^\Psi . M)and steps to

e0

(sbox( ^\Psi . oe) .= b) -! e0 Branch b matches sbox( ^\Psi . oe)and steps to

e0

Evaluation relies on pattern matching and evaluating branches.The case for function application is straightforward. Values for program variables are propagated by computation-level substitution.Instantiations for context variables are propagated by applying a
concrete context \Psi  to a context abstraction \Lambda .e.

rec f.e -! [rec f.e/f]e (fn y.e) v -! [v/y]e

e1 -! e01
(e1 e2) -! (e01 e2)

e2 -! e02
(v e2) -! (v e02)

e -! e0
e d\Psi e -! e0 d\Psi e (\Lambda .e) [\Psi ] -! [[\Psi /]]e

e -! e0
(case e of b1 | . . . | bn ) -! (case e0 of b1 | . . . | bn )

* ` box( ^\Psi . M) .= bi -! e0
(case (box( ^\Psi . M)) of b1 | . . . | bn ) -! e0

* ` sbox( ^\Psi . oe) .= bi -! e0
(case (sbox( ^\Psi . oe)) of b1 | . . . | bn ) -! e0
Evaluation in branches relies on higher-order pattern matchingagainst data-level terms to instantiate the contextual variables occurring in a branch and data-level instantiations are propagated via
contextual simultaneous substitution. We assume that box( ^\Psi . M)does not contain any meta-variables, i.e. it is closed.

\Delta ; ^\Psi  ` M0 .= M/`
(box( ^\Psi . M) .= \Pi \Delta .box( ^\Psi . M0) 7! e) -! [[`]]\Delta e

\Delta ; ^\Psi  ` oe0 .= oe/`
(sbox( ^\Psi . oe) .= \Pi \Delta .sbox( ^\Psi . oe0) 7! e) -! [[`]]\Delta e
Given the current setup, we can prove type safety for our pro-posed functional language with higher-order abstract syntax and

explicit substitutions. We assume that patterns cover all cases here,but coverage checking can be incorporated by following ideas described in (Sch"urmann and Pfenning 2003). First we state and provethe necessary canonical forms lemma where |

e| denotes the expres-sion
e where typing annotations in e : o/ are erased.

Lemma 5.1. [Canonical forms]

1. If |e| is a value and *; *; * ` e ) A[\Psi ]

then |e| = box( ^\Psi . M) and *; *; * ` box( ^\Psi . M) ( A[\Psi ]
2. If |e| is a value and *; *; * ` e ) \Phi [\Psi ]

then |e| = sbox( ^\Psi . oe) and *; *; * ` sbox( ^\Psi . oe) ( \Phi [\Psi ]
3. If |e| is a value and *; *; * ` e ) o/1 ! o/2then |

e| = fn y.e0 and *; *; * ` fn y.e0 ( o/1 ! o/2

4. If |e| is a value and *; *; * ` e ) \Pi ::W.o/then |

e| = \Lambda .e0 and *; *; * ` \Lambda .e0 ( \Pi ::W.o/

Proof. By induction on the typing judgment and case analysis.
Theorem 5.1. [Preservation and Progress]

1. If *; *; * ` e ) o/ and e coverage checks then either |e| isa value or there exists an expression

e0 s.t. |e| -! |e0| and*
; *; * ` e0 ) o/.
2. If *; *; * ` e ( o/ and e coverage checks then either |e| isa value or there exists an expression

e0 s.t. |e| -! |e0| and*
; *; * ` e0 ( o/.

Proof. By structural induction on the first derivation using canoni-cal forms lemma, correctness of higher-order pattern matching, and
various substitution properties we proved earlier.

6. Related Work
One of the first proposals for functional programming with sup-port for binders and higher-order abstract syntax was presented by

Miller (1990). Later, Despeyroux et al. (1997) developed a type-theoretic foundation for programming which supports primitive recursion. To separate data from computation, they introduce modaltypes \Lambda 

A which can be injected into computation. However, datain their work must always be closed and can only be analyzed via a

primitive recursive iterator. Our work essentially continues the pathset out in (Despeyroux et al. 1997), and generalizes their work to
allow for open data-objects and first-class substitutions.Closely related to our approach is the work by Sch"urmann et al.
(2005) where the authors present the r-calculus which provides afoundation for programming with higher-order abstract syntax as
found in the simply typed Elphin language. In Sch"urmann et al.(2005) the necessity modality \Lambda 

o/ describes computation of type
o/ which can be executed in every world where we have at leastone context extension. The context containing binding occurrences

is hence left implicit and associated with a computation. Whena new context extension is introduced, the computation moves
from the present world to a world where the context is extended.To return the computation to the present world again where the
context extension is not present, the programmer has to explicitlyuse a pop-operation which removes the introduced binding. The

fact that binders can never escape their scope during executionis a meta-theoretic property which is proven. Since \Lambda 

o/ describescomputation which may be executed in every world where we

have at least one context extension, the whole function and all itsarguments must be well-typed in this extended context.

This is in stark contrast to our work based on contextual modaltype, where

A[\Psi ] denotes some object of type A which is well-typed in every world where we have a context

\Psi  and hence everydata-object carries its own local context. Therefore we can for example return an object which is closed and distinguish it from anobject which is not closed. The fact that local binders can never escape their scope is an inherent property of contextual types A[\Psi ].
\Psi  denotes exactly the bound variables which are allowed to occurin an object of type

A[\Psi ], and the type system will detect if thisis violated. Elphin seems a special case of our foundation where

there is only one context variable which all arguments depend on.Because we can distinguish between different contexts, we believe
our foundation is more expressive and is likely to scale better whenwe compose different computations, since it provides more finegrained control. Finally, we propose to extend the framework withfirst-class substitutions, which seem interesting on their own and
are absent from Elphin. Although their full impact still needs to beexplored, explicit substitutions have been used to model records,
closures, modules, classes and abstract data types with one singleversatile and powerful construct. The lack of first-class substitutions generally forces the inclusion of several different name-spacemechanisms.

Most recently, Poswolsky and Sch"urmann (2007) proposed adependently typed language for programming with higher-order
encodings. While substantially different from Elphin, it also doesnot provide fine-grained control to distinguish between multiple
different contexts and does not support first-class substitutions.A different more pragmatic approach to allow manipulation of
binding structures is pursued in nominal type systems which serveas a foundation of FreshML (Shinwell et al. 2003). In this approach
names and ff-renaming are supported but implementing substitu-tion is left to the user. The type system distinguishes at the typelevel between expressions and names, and provides a special type
atom which is inhabited by all names. The distinction between dif-ferent categories of names is usually more difficult. Generation of a

new name and binding names are separate operations which meansit is possible to generate data which contains accidentally unbound
names since fresh name generation is an observable side effect. Toaddress this problem, Pottier (2007) describes pure FreshML where
we can reason about the set of names occurring in an expression viaa Hoare-style proof system. The system relies on assertions written by the programmer to reason about the scope of names. Thisstatic-analysis approach is quite expressive since the language of
constraints includes subset relations, equality, intersection etc. Incontrast, our work aims to provide a type-theoretic understanding
of open data, binders, and substitutions. This has various benefits:For example, it should be possible to provide precise error messages on where names escape their scope. In contrast to nominalsystems, our foundation also leaves flexibility as to how data-level
bound variables are implemented and in fact lends itself to an im-plementation based on de Bruijn indices. While the exact relationship between nominal types, static analysis of names and contextualtypes still needs to be investigated, we believe the presented work
is a start towards comparing both approaches.From a more theoretical perspective, various

*-calculi support-ing contexts as a primitive programming construct have been considered (Sato et al. 2001, 2002; Nishizaki 2000; Mason 1999;Hashimoto and Ohori 2001). Nishizaki (2000) for example extends
a lambda-calculus with explicit substitutions in the spirit of the ex-plicit substitution calculus proposed by Abadi et al. (1990). However, unlike Abadi's work, the author proposes a polymorphic cal-culus where we can quantify over explicit substitutions. This work
crucially relies on de Bruijn indices. Although the use of de Bruijnindices is useful in an implementation, nameless representation of
variables via de Bruijn indices are usually hard to read and criticalprinciples are obfuscated by the technical notation.

Sato et al. (2002) introduce a simply typed *-calculus whichhas both contexts and environments (=substitutions) as first-class
values, called *^,ffl-calculus. There are many distinctions, however,between their work and the contextual modal type theory we propose as a foundation. Most of these differences arise because theformer is not based on modal logic. For example, they do not allow
ff-conversion on open objects and they do not require open objectsto be well-formed with respect to a local context. Moreover, they do
not cleanly distinguish between meta-variables and ordinary vari-ables. All these restrictions together make their system quite heavy,
and requires fancy substitution operations and levels attached to or-dinary variables to maintain decidability and confluence. None of
these approaches allows for pattern matching and recursion on opendata-objects.

7. Conclusion
We have presented a type-theoretic foundation for programmingwith higher-order abstract syntax and first-class substitutions based

on contextual modal types together with its type preservation andprogress proof. We support recursion over data defined in HOASstyle, and allow pattern matching against open data and variables.By design bound variables in data cannot escape their scope. This
is to our knowledge the first type-theoretic proposal to achieve this.This work also provides interesting insights into the relationship
between nominal systems and higher-order abstract syntax. In thefuture we plan to address the following questions:

Existential quantification over context variables In some exam-ples, we would like to be able to write a function which returns
an open object of type exp['] for some context '. This is forexample necessary if we want to write a small-step environment
based interpreter, or even if we want to translate a name-based rep-resentation of terms into a higher-order representation. Adding existential quantification for context variables is in fact possible andstraightforward.

Types o/ ::= . . . | \Sigma ::W.o/Expressions

e ::= pack(\Psi , e) | let pack(, x) = e in e0 end

The typing and evaluation rules are then straightforward.

Typing rules
\Omega ; \Delta ; \Gamma  ` e ( [[\Psi /]]o/ \Omega  ` \Psi  ( W

\Omega ; \Delta ; \Gamma  ` pack(\Psi , e) ( \Sigma ::W.o/

\Omega ; \Delta ; \Gamma  ` e ) \Sigma ::W.o/ \Omega , ::W ; \Delta ; \Gamma , x : o/ ` e0 ) o/0

\Omega ; \Delta ; \Gamma  ` let pack(, x) = e in e0 end ) o/0
Evaluation rules

let pack(, x) = pack(\Psi , e) in e0 end -! [e/x][[\Psi /]]e0

e1 -! e2
let pack(, x) = e1 in e0 end -! let pack(, x) = e2 in e0 end

The full impact of existential types in practice however stillneeds to be addressed.

Mixing data with computations At the moment our foundationfor programming with HOAS and substitutions is pure, i.e. we

never mix data and computation. However, there may be good rea-sons to allow some form of computation inside of data-definitions.
For example, consider the definition of arithmetic expressions. Wedefined natural numbers inductively, and then included them in the
expressions via the coercion Nat. However, clearly we may wantto use the integer-type given by our functional language when we
define the language of arithmetic expressions, and thereby be ableto rely on the built-in arithmetic operations instead of redefining
them. How to mix data and computation and retain all our goodproperties is an important question we plan to address in the future.
Also the interaction with other features realistic programming lan-guages provide such as mutable state, exceptions, etc. needs to be
investigated.
Reconstruction of context variables In the presented foundationwe explicitly abstract over context variables and pass them explicitly. An interesting question in practice is whether we can recon-struct some of these context variables and keep contexts implicit.
This also leads to the question whether we should support patternmatching against contextual variables. At the moment, context variables will be instantiated to some concrete context via context ap-plication before we use pattern matching to decide which branch to
pick in a case-expression. This in fact is important to achieve el-egant meta-theoretic properties. In the future, we plan to consider
in more detail how to reconstruct context variables and how to addmatching for context variables.

Acknowledgments
I would like to thank Frank Pfenning, Aleks Nanevski, and AdamPoswolsky for many insightful discussion regarding this topic.

Moreover, this work benefited from comments and suggestions byDerek Dreyer, Stefan Monnier, and Franc,ois Pottier. Special thanks
go to Joshua Dunfield for helping to typeset the code.

References
Mart'in Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques L`evy.Explicit substitutions. In Conference Record of the Seventeenth Annual

ACM Symposium on Principles of Programming Languages, San Fran-cisco, California, pages 31-46. ACM, 1990.

Jo"elle Despeyroux, Frank Pfenning, and Carsten Sch"urmann. Primitive re-cursion for higher-order abstract syntax. In R. Hindley, editor, Proceedings of the Third International Conference on Typed Lambda Calculusand Applications (TLCA'97), pages 147-163, Nancy, France, Lecture
Notes in Computer Science (LNCS) 1210, Springer-Verlag, 1997.
Murdoch Gabbay and Andrew Pitts. A new approach to abstract syntaxinvolving binders. In G. Longo, editor, Proceedings of the 14th Annual

Symposium on Logic in Computer Science (LICS'99), pages 214-224,Trento, Italy, IEEE Computer Society Press, 1999.

Louis-Julien Guillemette and Stefan Monnier. Statically verified type-preserving code transformations in Haskell. In Programming Languages

meets Program Verification (PLPV), Seattle, USA, Electronic Notes inTheoretical Computer Science (ENTCS). Elsevier, 2006.

Robert Harper, Furio Honsell, and Gordon Plotkin. A framework fordefining logics. Journal of the Association for Computing Machinery,

40(1):143-184, January 1993.
Masatomo Hashimoto and Atsushi Ohori. A typed context calculus. Theo-retical Computer Science, 266(1-2):249-272, 2001.

Ik-Soon Kim, Kwangkeun Yi, and Cristiano Calcagno. A polymorphicmodal type system for Lisp-like multi-staged languages. In 33rd ACM

SIGPLAN-SIGACT Symposium on Principles of Programming Lan-guages(POPL '06), pages 257-268, New York, NY, USA, ACM Press,
2006.
Ian A. Mason. Computing with contexts. Higher-Order and SymbolicComputation, 12(2):171-201, 1999.

Andrew McCreight and Carsten Sch"urmann. A meta-linear logical frame-work. In Carsten Sch"urmann, editor, 4th International Workshop on Logical Frameworks and Meta-Languages (LFM'04), 2004.
Dale Miller. Unification of simply typed lambda-terms as logic program-ming. In Eighth International Logic Programming Conference, pages

255-269, Paris, France, MIT Press, 1991.
Dale Miller. An extension to ML to handle bound variables in data struc-tures. In G. Huet and G. Plotkin, editors, Proceedings of the First Workshop on Logical Frameworks, pages 323-335, 1990.
Aleksandar Nanevski, Frank Pfenning, and Brigitte Pientka. A contextualmodal type theory. ACM Transactions on Computational Logic (accepted, to appear in 2008), page 56 pages, 2006.
Shin-Ya Nishizaki. A polymorphic environment calculus and its type-inference algorithm. Higher Order Symbol. Comput., 13(3):239-278,

2000.
Frank Pfenning and Carsten Sch"urmann. System description: Twelf --a meta-logical framework for deductive systems. In H. Ganzinger,

editor, Proceedings of the 16th International Conference on AutomatedDeduction (CADE-16), pages 202-206, Trento, Italy, Lecture Notes in
Artificial Intelligence (LNAI) 1632, Springer-Verlag, 1999.
Brigitte Pientka. Tabled higher-order logic programming. PhD thesis,Department of Computer Sciences, Carnegie Mellon University, 2003.

CMU-CS-03-185.
Brigitte Pientka and Frank Pfennning. Optimizing higher-order patternunification. In F. Baader, editor, 19th International Conference on

Automated Deduction, pages 473-487, Miami, USA, Lecture Notes inArtificial Intelligence (LNAI) 2741, Springer-Verlag, 2003.

Adam Poswolsky and Carsten Sch"urmann. Programming with higher-order encodings and dependent types. Technical Report YALEU/DCS/TR1375, Department of Computer Science, Yale University, July2007.

Franc,ois Pottier. Static name control for FreshML. In Twenty-SecondAnnual IEEE Symposium on Logic in Computer Science (LICS'07),

pages 356-365, Wroclaw, Poland, IEEE Computer Society, 2007.
Masahiko Sato, Takafumi Sakurai, and Rod Burstall. Explicit environments.Fundamenta Informaticae, 45(1-2):79-115, 2001.

Masahiko Sato, Takafumi Sakurai, and Yukiyoshi Kameyama. A simplytyped context calculus with first-class environments. Journal of Functional and Logic Programming, 2002(4), March 2002.
Carsten Sch"urmann. Automating the meta theory of deductive systems. PhDthesis, Department of Computer Sciences, Carnegie Mellon University,

Available as Technical Report CMU-CS-00-146, 2000.
Carsten Sch"urmann and Frank Pfenning. A coverage checking algorithmfor LF. In D. Basin and B. Wolff, editors, Proceedings of the 16th

International Conference on Theorem Proving in Higher Order Logics(TPHOLs 2003), pages 120-135, Rome, Italy, Lecture Notes in Computer Science (LNCS) 2758, Springer-Verlag, 2003.
Carsten Sch"urmann, Adam Poswolsky, and Jeffrey Sarnat. The r-calculus.functional programming with higher-order encodings. In Pawel Urzyczyn, editor, Proceedings of the 7th International Conference on TypedLambda Calculi and Applications(TLCA'05), pages 339-353, Nara,
Japan, Lecture Notes in Computer Science (LNCS) 3461, Springer,2005.

Mark R. Shinwell, Andrew M. Pitts, and Murdoch J. Gabbay. FreshML:programming with binders made simple. In Eighth ACM SIGPLAN

International Conference on Functional Programming (ICFP'03), pages263-274, New York, NY, USA, 2003. ACM Press.

Geoff Washburn and Stephanie Weirich. Boxes go bananas: Encodinghigher-order abstract syntax with parametric polymorphism. Journal of

Functional Programming, 2007 (to appear).
Kevin Watkins, Iliano Cervesato, Frank Pfenning, and David Walker. Aconcurrent logical framework I: Judgments and properties. Technical

Report CMU-CS-02-101, Department of Computer Science, CarnegieMellon University, 2002.