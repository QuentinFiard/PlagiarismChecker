

Global  Data  Flow  Analysis  and  Iterative  Algorithms 
JOHN  B.  KAM  AND  JEFFREY  D.  ULLMAN 
Princeton  University,  Princeton, New Jersey 

ABSTRACT  Kildall has developed  data  propagation algorithms  for code optimization m  a general lattice theoretic  framework.  In another directmn, Hecht and Ullman gave a strong upper bound on 
the number of iterations required  for propagation  algorithms  when the data  is represented  by bit vectors  and depth-first  ordering  of the flow graph is used  The present paper combines the ideas of 
these  two papers  by considering conditions under whmh the bound of Hecht and Ullman applies  to the depth-first veremn of Klldall's general data propagation algorithm. It is shown that the following 
condition is  necessary and sufficient  Let f  and g be any two functions which could  be  associated with blocks of a flow graph,  let x be an arbitrary lattice element, and let 0 be the lattice zero  Then 

(*)  (Vf,g,x)  [fg(0) >  g(0)A f(x)  /~  x]  Then it is shown that several  of the  particular  instances of the techniques Kildall found useful do not meet condition (*) 

KEy WORDS ANn PnaASES. code optimization,  data  flow analysis,  reducible  flow graph,  semilat- rice, depth-first  search,  constant propagation, available expressmns 
CR CATEGORIES* 4.12, 5.24, 5.25 

1.  lntroductio~ 
Pecforming compile time optimization involves solving a  class of problems each of which 

can  be  dealt  with  in  essentially the  same  manner.  These  problems,  called  "global  data 
flow  analysis  problems,"  involve determination and  collection  of  information  which  is 

distributed throughout  the  program. 

The  interval approach  [1-4,  9,  12]  has  been used to  solve this  class of problems when 
the  flow graph  of the  program  has  a  property  called  "reducibility." A  second  approach, 

using iteration of a data propagation step, has recently appeared in the literature [10,  13]. 

Its origins go back to at least  1961,  when it was used by Vyssotsky m  a  Fortran compiler 
[14].  Developments  regarding  this  approach,  which  we  shall  term  the  "iterative  ap- 
proach,"  have  taken  two  directions.  First,  Klldall  [10] expresses  the  class  of  problems 
which can be solved using the lterative approach in a  very general lattice theoretic frame- 
work.  The  bit-vector representation of data  used  in previous work  on  data  propagation 
is  a special case of the  techniques described in [10]. 

The second direction which research into iterative methods has taken is typified by [5]. 
There,  considering only bit-vector represented data,  it  was shown that  depth-first search 

provided an  efficient ordering of the  nodes of a  flow graph,  and in fact  d  -.p  2  iterations 
were sufficient for the  usual kinds of data flow problems, where d, the  loop Interconnected- 
hess  parameter  of a  flow graph,  is the  maximum number of back  edges  (according to  any 
depth-first spanning tree)  in a  cycle-free path.  In practice,  d is often 3 or less [11]. 

In  the  present  paper  we  provide  a  necessary  and  sufficient condition for  the  bound 
of  [5] 1 to apply  to  Kildall's lattice theoretic  formulation  of flow analysis problems when 

Copyright (C)  1976, Association  for  Computing Machinery,  Inc  General permission  to  republish, but not for profit,  all or part  of  this material is granted provided  that  ACM's  copyright  notice is 

given and that reference is made to the publication, to its date of issue, and to the fact that reprinting privileges were granted by permission of the Association for Computing Machinery 

This work was supported by the National Science Foundation under Grant GJ-1052. 
Authors' address: Department of Electrical Engineering, Princeton University, Princeton, NJ 08540 

Actually, for technical  reasons,  we use the bound d --p 3 instead of d +  2. 

Journal of the Aa~oclatlon for Computing Machinery, Vol  23, ~o.  1, January  1976, pp  158-171 

Global  Data  Flow Analysis  and  Iteratwe Algorithms  159 
depth-first  ordering  of  the  nodes  is  used.  We  then  see  th at   the  applications  of  his  al- 
gorithm  suggested  by  Kildall  do  not  m eet   the  criterion.  It  is  possible,  however,  t ha t  or- 

derings  other  th an   depth-first  ma y  ma ke   iteration  efficient  in  these  cases,  and  we  do  not 
wish  to  imply  th at   Kildall's  techniques  are  inefficient  under  all  possible  circumstances 

2.  Background 
A  flow graph  is  a  triple  G  =  (N,E,no),  where: 

(1)  N  is  a  finite set  of  nodes. 
(2)  E  is  a  subset  of  N  X  N  called  the  edges.  T h e  edge  (x,y)  enters node  Y  and  leaves 
node  x.  We  say  t ha t  x  is  a  predecessor of  y,  and  y  is  a  successor of  x. 

(3)  no in  N  is  the  initial  ~ode.  T h ere  is  a  path 2 from  no to  every  node. 
A  depth-first  spanning  tree 3 (D F ST )   of  a  flow  graph  is  a  tree  with   order  on  t he   sons 
of  any  node  (ordered  tree)  grown  by  Algorithm  D  [7]. 

ALGORITHM  D:  DFST  of  a  flow graph G Input.  Flow  graph  G with n  nodes. 
Output.  (1)  A  DFST  for  G,  (2)  a  numbering rPostorder  of  the  nodes  from  1  to  n  indicating  the reverse of the order in which each node was last vmited. 
Method. [DI]  The root of the DFST  is the initial node of G.  Let this node be the node m whmh m vmlted in 

step D2  ~ will be used to number nodes in rPostorder  Initially, ~ ~-- n. [D21  [visit  node m]  If  node  m  has  a  successor  x  not  already  on  the  DFST,  make  x  the  rightmost 
son of m  so far  placed  in  the  spanmng  tree,  adding  edge  (re,x)  to  the  tree.  If  such  an  x  is found, it becomes the node m to be visited next by repeating step D2 on x.  If there is no such 

x,  go to step  D3. [D3]  Let m  be  the  node  being visited, 
rPostorder  (m) ~-- i, ~ ~-.-~-  1; 
if  m  is  the  root  then halt else execute step  D2 on the  father  of m 

Let  G  =  (N,E, no)  be  a  flow  gr aph   and  let  T  =  (N,E')  be  a  DF S T   for  G.  T h e  edges 
in  E  fall  into  three  classes: 

(1)  Edges  which  r u n  from  a  node  to  a  proper  descendant  are  called forward edges. 4 
(2)  Edges  which  run  from  a  node  to  an  ancestor  (including  itself)  are  called  back 
edges. 

(3)  Edges  which  ru n  between  nodes  unrelated  by  the  ancestor-descendant  relation 
are  called  cross-edges. 

Observatwn  1.  Let  G  =  (N,E,no)  be  a  flow  graph  and  let  T  be  a  D FS T   of  G.  Let  a 
and  b be nodes  in  G. T h en   (b,a)  in  E  is a  back  edge  if  and  only  if r P os t o r der ( b )  .>  rPost- 
o rder (a).  

Observation  2.  Let  G  =  (N,E,no)  be  a  flow  graph  and  T  be  a  D FS T   of  G.  T h en   every 
cycle  of  G  contains  at  least  one  back  edge. 

Defin~twn.  Let  G  =  (N,E,~o)  be  a  flow  graph  and  T  =  (N,E ')  be  a  DF S T   of  G 
We  define  d( G,T),  the  loop  connectedness  of G  with  respect to  T,  to  be  the  largest  n um be r  
of  back  edges  found  in  any  cycle-free  pa th   of  G.  Often,  when  T  is  understood,  we  shall 
write  d(G)  for  d(G,T).  For  the  wide  class  of  flow  graphs  known  as  "reducible"  flow 
graphs  [3],  it  has  been  shown  [6]  th at   d(G,T)  is  in  fact  independent  of  which  DF S T   T 

is chosen 

Apath  f r om nl t on ~m as e qu en ceo f no des n ~ ,n ~,   ..  , n~ s u ch th at   (n,, n,+~) is  in E  for  1 <  ~ < k- -  1. The path  length ls k  --  1  Ifn~  =  n~andk  >  1, t he pat h ls   acycle. 
For  a qmck  definition, a tree m a flow graph such that no node has more  than one predecessor  The terin root of a  tree m a synonym for initial node, son IS used for successor,  and father for predecessor. 
Ancestor and descendant are  terms used for the reflexive and  transitive closure of  the father and son relations, respecttvely. 
4 Some authors call  edges in E' tree edges,  reserving "forward"  for edges  not in E 

160  J.B.  KAM  AND  J.D.  ULLMAN 

Having  introduced  the  terminology  needed  for  flow  graphs,  we  now  proceed  to  the 
second  area in which  a  series of definitions are necessary, namely lattice algebra.  A  semi- 
lattice  is a  set  L  with  a  binary meet operation /~  such  that  for all a,  b,  and  c in L: 

a / ~   a  =  a  (idempotent),  a / ~   b  =  b  A  a  (commutative), 

a / ~   (b  A  c)  =  (a  A  b)  /~  c  (associative). 

Given a  semilattice L  and elements a, b  E  L, we say that  a  _> b if and  only if a  A  b  = 
b, a  ~  b if and  only if a  _>  b and  a  ~  b. We also extend  the  notation  of the  meet  opera- 
tion  by  saying ^~<,<~x,  --  x~/~  x2  A  -'"  A  x~. 

A  semilattice L  is said  to  have  a  zero  element  0  if for  all x  E  L,  0  A  x  =  0.  L  is said 
have  a  one  element  1,  if for  all x  E  L,  1  A  x  =  x.  We  assume  from  here  on  that  every 

semilattice has  a  zero element,  but  not  necessarily a  one  element. 

Given  a  semilattice L,  a  sequence  x,, x2,  * * * , x~  of elements of  L  is  said  to  be a chain 
if for  1  _<  i  <  n w e h a v e x ,   >  x,+,.  L i s s a i d   to  be  bounded  if  for  e ach x   E  L  there 
is a  constant  b, such  that  any  chain  beginning with x  has  length  at  most  b,. 

If L  is bounded,  then  we can take meets over countably infinite sets if we define ^,es x, 
where  S  =  {x,, x~,  .-.  },  to  be  lim~.,  ^,<,<~  x,.  The  fact  that  L  is  bounded  assures  us 
that  the  limit does exist. 

3.  Global Data Flow Problems 

Following [10],  we  treat  data  flow analysis problems  as  follows.  We  choose  a  semilattice 
L  and  attach  to  its  elements  a  "meaning,"  normally data  which  could  reach  a  point  in 
a  flow  graph.  We  associate  with  each  node  of  the  flow  graph  a  function f  from  L  to  L 
which  intuitively  represents  how  data  is  transformed  when  control  passes  through  the 
block of code represented  by  that  node. 

In  what  follows we  find it necessary to  consider the  set  of all functions  which could  be 
associated  with  some  node  of a  flow graph.  That  is,  having  selected a  semilattice L  and 

an intended meaning  for lattice elements,  the  admissible functions  ate those which reflect 
the  action  of  straight-line  blocks  of  code  on  elements  of  L.  We  abstract  the  notion  of 
such  a  set  of functions  in the  following definition. 

Given  a  bounded  semilattice  L,  a  set  of  functions  F  on  L  is  said  to  be  an  admissible 
set  of functions for L  if and  only if the  following conditions  are  satisfied: 

IF1]  E a c h ]   E  F  distributes over A ,  i.e. for any x  and y in L,  f ( x   A  y)  =  f( x )  A  f (y ). 
[F2]  There  exists  an  identity  function  e  in  F  such  that  for  all  x  E  L,  e(x)  =  x. 
[F3]  F  is closed under composition, i.e. f  and g in F  impliesfg  E  F, where for  all x  E  L, 
[fgl(x)  --  :(g(x)). [F4]  For  each  x  E  L,  there  exists a  finite subset  H  c  F  such  that  x  =  ^serif(0). 

Conditions  [F2]  and  [F3|  reflect  obvious  properties  of  straight-line  blocks  of  code. 
That  is,  [F3]  comes  from  the  fact  that  the  concatenation  of  two  blocks  is  a  block,  and 

[F2] comes from  the  reasonable assumption that  a  block can  be empty.  [F1], on  the  other 
hand,  is not  universally true.  It  is  used  in  [10]  to  prove  the  uniqueness  of the  output  to 

Kildall's algorithm.  The  justification for  condition  [F4] is the  following lemma. 

Observatwn  3,  Let  L  be  a  bounded  semilattice  and  let  F  be  a  set  of  functions  on  L 
such  that  F  satisfies [F1] with respect to  L.  Then  for any  finite subset  J  ~  L, 

f  (  ^ x)  =  ^  f(x). zEJ  =EJ 
Gwen a  bounded  sem~lattzce L  and  F  a  set  of functions  on  L  satisfying  [F1]- LEMMA  1. 
[F3],  ~f we let 

L'  =  {xl3fx,  . . . , f ~   E  F  and  x  --  ^  f,(0)l, 

then F  is an admissible set of funchons for L'. 

PROOF.  Since  any  subset  of  L,  which  is  closed  under  A,  satisfies  the  idempotent, 

Global  Data  Flow Analysis  and  Iterative  Algorithms  161 
commutative,  and  associative  properties  with  respect  to  A  and  hence  is  a  semilattice, 
it suffices to show that  F  satisfies [F1]-[F3] with respect to L p if F  satisfies [F1]-[F3] with 
respect to  L. 

[F1]  and  [F2]  are  trivially satisfied  by  F  with  respect  to  L p,  because L'  is  a  subset of 
L.  Assume F  does not satisfy [F3] with respect to L', i.e. there exists x  E  L'  and f,  g  E  F 
such thatfg(x)  E  L  -  L'. Wewant todrawa contradiction, x  E  L' implies x  =  ^h~, h(0) 

for some finite H  c  F.  Thus 

fg(x)  =  fg(  ^  h(0))  =  ^  fgh(O)  (by Observation 3). hEH  hEH 

Hence fg(x)  should have been included in L'  by definition.  [] 

Some  additional useful observations are the  following. 
Observation  4.  Given  bounded  semilattiee  L  and  associated  F,  for  all  f  E  F  and 
x,  y  E  L,  x  >  y  impliesf(x)  ~  f(y). Observatwn 

5.  For  any  bounded  semi]attice  L  and  any  countable  J  ~  L,  if  for  all 
x  E  J w e h a v e x   >  y, then^~e~x  >  y. 

We  now  introduce  the  basic  formalism  for  our  expression  of  data  flow  problems.  A 
data flow  analysis framework  is  a  triple D  =  (L,A ,F )  where  L  is  a  bounded semilattice 
with meet  A,  and F  is an admissible set  of functions for L.  A  partzcular  instance  of D  = 

( L , A , F )   is a  pair I  =  (G,M)  where  (1)  G  =  (N,E,no)  is a  flow graph  and  (2)  M : N   -~ 
F  is  a  function which maps  each  node in N  to  a  function in  F. 

Convention.  Given a  particular  instance I  =  (G,M)  of  D  =  ( L , A, F ) ,   if the  nodes 
of  G are  labeled by  rPostorder  with  respect  to  a  DFST  of  G,  we  associate  the  nodes  of 
G  with  their  labels.  We  let f,  denote  M(i),  the  function in  F  which  is  associated  with 
node  ~.  Let  P  =  11,  i2,  .. .  ,  i~,  im+l  be  a  path  in  G.  Then  we  may  use  f~(.)  for 
f,~  (f,~_~  (  ..-f,~  ( .)  . ..  )).  Note  thatf,~+~  is  not in  the  composition.  If  m  =  0,  then 
fe  =  e,  the  identity function. 

4.  The Depth-First  Version of Kildall's  Algomthm 
We  now give an iterative algorithm to  find what  is essentially the  maximum solution to 
the equations implied by an instance of a data flow problem. It is essentially the algorithm 
of  [10] but  with  the  important difference that  the  nodes are  visited in turn in the  rPost- 
order  sequence.  The  following definitions are  essential: 

PRED(3)  =  {q ] q is a  predecessor  of j}. 
PRED *(j)  =  {q i  q  E  PRED(3)  and q  <  j  in reostorder,  i.e.  (q,3)  is not  a  back  edge}. 

ALGORITHM  K Input.  A partmular instance I  =  (G,M) of data flow analysis framework D  =  (L,F), where G  = 

(N,E,no)  is a flow graph  with k nodes. Take N  to be  I1, 2,  ...  , kl,  and assume  the nodes 
are  numbered by rPostorder  Execute the program of Figure 1 

Conventwn.  We say that  n iterations of Algorithm K  have been applied, where n  >  1, 
if the for  loop  beginning at  step  1 has  been  executed  once  and  the  for  loop  beginning 

at  step  2 has  been executed n  -  1 times. 

THEOaEM  1  [10].  Given  a  particular  instance  I  =  (G,M)  of  D  =  ( L , A , F )   as  input, 
Algorithm  K  will  eventually  halt.  At  the completion  of Algorithm  K, 

A[i]  --  ^  r e ( o ) ,   1  <  i <   k, PEPATH($) 

where P A T H ( I )   =  {P  I P  ~s a  path  in  G from  node  1 to node ~}.  [] 

LEMMA 2.  Given instance  I  =  ( G,M)  of data flow analyszs framework D  =  ( L , A , F ) ,  
and  T  a D F S T  for  G, after the n-th iteration of Algorithm  K, 

A[i]  =  ^  re(o),  1  <  I  <  k, PEPATH(n)($) 

102  J.B.  KAM  AND  J.D.  ULLMAN 

begin temp  element of L, 

A  array  [1  k] of elements of L, j  integer,  change  Boolean; 
A[I]  =  O, Step  1.  for j  =  2 until k do 

A[j]  =  ^~,VR~O*(,)Jq(A[q]);. change  =  true 

while change do begin 

change  =  false, Step2 
for  2  =  2  until  k  do begin 

temp  =  %,va~vc~)fq(A[q]), if temp  ~  A[j] then 

begin change  =  true, 

A[3]  =  temp end 
end end 
end 

FIo.  1.  Program  for  Algomthm K 

where  PATH(^)(i)  =  { P I P   E  P A T H ( z )   and  P  contains  at  most  n  --  1  back  edges 
according  to  the  rPostorder  z~duced  by  T}. 

PROOF.  The  proof  is  by  induction  on  n,  the  number  of  iterations  of  Algorithm  K 
already  completed. 

Basis  (n  =  1).  We  proceed  by induction  on  the  rPostorder 2 of the  nodes  of G. 

Baszs  (2  =  1).  It  is  obvious that  the  trivial  path  is  the  only  element  in  PATH(Z)(1) 
because  any  edge entering  node  1 has to  be a  back  edge.  Thus,  A[1] should  equal  e(0)  = 
0.  As  we  assign  A[1]  :=  0  in  the  first  iteration,  the  basis  is  done. 

Inductwn  step  (j  >  1).  By Observation  1, all and  only the  back-edge-free paths  from 1  to 3 can  be written  as  (P,3}, ~ where  P  is  a  path  from  1  to  q  E  PRED*(j).  By  the  in- 

duction  hypothesis,  A[q]  =  hpCp.~Tt~(l)(q)fp(0)  for  each  q  E  PRED*(j).  Step  1  of Al- 
gorithm  K  assures 

A[j]  =  ^  fq(A[q])  =  ^  A  f(p,,>(O)  =  ^  f0(O). q6 PRED*(J)  qE PROD* (./)  P6PAT/~(I) (q)  QEPATH(I)(y) 

This  completes  the  induction  on .7 for the  case  n  =  1. 

Induction  step  (n  >  1).  We  proceed  by  induction  onff  again. 
Basis  (2  =  1).  It  is  obvious  that  0  =  ^pepAT~(')(z)fP(0)  __>  ^  ~ePAT~(,)(1)fP(O). Thus  ^PCeAT~(-)u)fP(0)  =  0.  After  n  iterations  of Algorithm  K,  A[1]  is  still  assigned 

0,  so  A[1]  --  ^PePATH(')(1)f~,(0)  after  the  nth  iteration. lnductzon  step  (3  >  1).  Every  path  Q  in  PATH(')(3)  is  of  the  form  (P,q)  where 

either: (i)  q  E  PRED* (j)  and  P  E  PATH(')(q),  or 

(ii)  q  E  P R E D ( j )   -  PRED*(j)  and  P  E  PATH(~-~)(q). That  is,  (ii)  represents  the case  where edge  (q,y)  is a  back  edge,  i.e.  q  _> 2,  and  (i)  repre- 
sents  the  opposite  case,  where  q  <  .7. When  in  Algorithm  K  temp  is  computed  for j  in the  nth  pass, 

A[q]  will  be 
(a)  ap#pATH(a)(q) fe(0)  if q  <  j,  i.e.  case  (i)  applies  to  q,  and 
(b)  ^P~eATn(--X)(q)fp(0)  if q  >  3,  i.e.  case  (ii)  applies. Note  that  part  (a)  follows  by  the  inductive  hypothesis  for j  and  (b)  follows  by  the 

inductive  hypothesis  for n. From the above it is immediate  that  on the nth pass temp is set equal  to 

^~eexvH(-)o)  f~(0),  and  thus  A[.7] is  given  this  value  if it  does  not  already  have  it.  [] 

We use  (P, 3)  to  denote  a  path  consisting of the  nodes of path  P  followed  by 3.  Similar,  hopefully 
transparent  notation  will  be  used  throughout. 

Global  Data  Flow Analysis  and  Iteratwe Algomthms  163 

LEMMA 3.  Gwen  dnstance  I  =  (G,M)  of framework  D  =  ( L , A , F ) ,   and  a fixed rPost- 
order for G,  Algomthra  K  will halt after  no  more then n  iteratwns if and  only if for each node 
j  C  N,  and  for  each  path  P  E  P A T H (g )  there  exist  Px,  " "   ,P~,  each  in  P A T H   (~-1)  (j), 

and fp(O)  >  ^l_<j<~fp,(0). 

PROOF.  (if).  In  this  case  by  Observation 5  we  have 

^  fQ(0)  =  ^  f~(0), QEPATH(n) ($)  QEPATH(n-1) (3) 

so  temp  =  A[3]  will  always  hold  on  the  nth  pass  of  Algorithm  K,  and  change  will  be 

false  at  the  end of that  pass. 

(only  if).  Suppose  that  Algorithm K  halts  after  the  ruth  pass,  m  <  n. Then  for  ar- 
bitrary  node 3  and  P  E  PATH(3)  we  must  have  fp(0)  >_  ^QeeATrI(~--~)(j)fQ (0).  We 
must show that  there is a  finite subset S  of  PATH"-~(j)  such  that  fp(0)  >  ^QesfQ(O). 
Enumerate PATH(m-X)(3 )  as  Q~, Q~,  .-.  in  any  order,  and  let  x,  =  ^L<~<_,f~,(O). Surely 
x,  >  x,+~ for  all  ~.  By  the  boundedness condition there  can  on]y  be  a  finite number of 

d's  for  which  x,  >  x,+~. Let  d0  be  the  last  and  let  S  =  {Q~, Q:,  . . - ,   Q,0}.  Then 
^~e~*TH(,~-~)(~) f~(0)  =  ^~esf~(0),  SO S  ~s the  desired  finite subset. 

5.  The  Mare  Result 
We  are  now ready  to  characterize those  data  flow analysis frameworks for which depth- 
first  search  yields  "rapid"  convergence of  Kildall's algorithm. 

THEORE.~I 2.  Let  D  =  ( L , A , F )   be  a  data  flow  analyses  framework.  The~  Algomthm 
K  halts  after  at  most  d(G)  +  3  dteratw~s 6 for  every  instance  I  =  (G,M)  of  D  and  every 
rPostorder definable for  G  =  ( N,E,t~),  ~f and  o~dy  ,f  D  satisfies condition  (*) : 

(VL g ~  F)(Vx  ~  L)[f.q(0)  >  g(0)  A f(x)  A  x].  (, )  
Formally, the  theorem  can be stated: 
(VD){[(VI  =  (G,M)  an instance of D)(Algorithm K 

halts  after  at  most  d(G)  +  3  iterations)]  ~  (.)} 

PROOF.  ($f).  By  Lemma  3,  it  suffices  to  show  that  for  each  3  E  N  and  each  path 
P  E  PATH(?),  there  exist  paths  P1,  " '   ,Pro  in  PATH(n+2)(2 )  such  that  fe(0)  _> 

a~<,_<mfp,(0).  We  want  to  prove  the  above  by  induction  on  k,  the  number  of  back 
edges  contained in P  =  /1, v~,  -..  , ~r, where  dt  =  1 and ir  =  2. 

Basds(O  <  k  <  d +   1).  This case is trlvial; lust let m  =  l a n d P ~   =  P. 
Inductwn  step  (k  >  d  +  1).  Since P  contains more than d  +  1 back edges, it cannot 
be  cycle free  by  definition of  d.  Let  us  pick  the  highest  number a  such  that  ~  =  ~b for 
some b  >  a.  We clmm that  the path P~  =  ~,  * *.  , ia must contain at least oneback edge, 

for  the  path  i,+x,  --.  , ~r is  cycle  free  and  thus  has  at  most  d  back  edges.  (in,  in+l)  may 
be  a  back  edge,  but  P  is  assumed  to  have  more  than  d  +  1  back  edges,  so  the  claim 
follows.  The  path  P2  =  d~,  *  , db contains  at  least  one  back  edge  by  Observation  2. 
We  let  P3  =  ib,  -..  , dr,  and  let  P4  be  a  back-edge-free  path  from  node  1  to  node  i,  as 
shown  in  Figure  2.  It  is  a  property  of  DFST's  that  P4  exists,  since  P4  may  follow  the 
tree. 

Now  we let x  =  fp,(O). 

fp(O)  =  fp~ (fe~ (fP, (0)) )  by definition 

>_  fP3(fe~(O)  A  fP2(X)  A  x)  by  assumption 

=  f~(fp~(O)  Afp 2(fp,(O))  A f p , ( O ) )  
=  fpj~,~(o)  A f p ~ f ~ f ~ , ( o )   A f~,f~,(0) 

=  fp,(O)  A  fP,(O)  A  fp"(O), 

6 Recall that d(G) stands for d(G,T)  where T is the DFST defining the rPostorder  m question 

164  3.B.  KAM  AND  J.D.  ULLMAN 

PI 

FzG  2.  Decomposition of psth  P 
G=  T=  I  ~ 

n+l  2 

_ ~ L~. . /" '~  * 
n+2  f 

o) FLOWGRAPH OF  G  b)  A  DFST FOR G SHOWING r POSTORDER NUMBERING 

Fie  3  Counterexsmple withj~(x)  ~  f(x)  A  x 

/ / f   n+l 
/  T  .- 

iN,r--, 
a) FLOW GRAPH OF G  b) A DFST FOR G SHOWING r POSTORDER NUMBERING 

FZG  4.  Counterexample  wzth *(x)  _> f(x)  /k  x 
where  P'  =  il,  .. .  , ia,~b+l,  "'"  ,i,,  P "  =  (P4,~a+l,  ""   , ~b, ib+l,  "'"  , i,},  P"   =  {P4, 
~b+1,  " " " , ~,}. P',  P",  and  P "   are  each  paths  in  G and  contain  at  most  k  --  1  back  edges. 

The  induction  step  follows  immediately. 

(only  zf).  Suppose  the  condition  (*)  is  not  satisfied,  i.e. 

(3 x  E  L)(3 ],  g  E  F)[fg(O)  >  g(O)  A/(x )  A  x]. 

Global Data Flow Analysis and Iterative  Algorithms  165 
By  condition  [F4]  of  F  being admissible for  L,  there  exist  hi,  h2,  .."  h~  E  F  such  that 
x  =  ^1<,_<~ h,  (0).  We have two cases to consider. 

Case  1.  fi(x)  ~  f(x)  A  x.  The  particular instance I  =  (G,M)  as  shown  in Figure 
3  will  do  the  job,  where  d(G)  =  0.  After  the  third  iteration  of  Algorithm  K  we  have 
A[~  +  2]  =  x  A  f(x)  A  if(x),  while A[n  +  2]  =  x  A  f(x)  after the second iteration. 
Hence  Algorithm K  will take  at  least  4  >  (0  +  3)  iterations. 

Case 2.  fi(x)  >_ f(x)  A  x.  The  particular instance I  =  (G,M)  with  the  DFST  of 
G grown as shown in Figure 4  will do.  We see d(G,T)  =  2. 

After the  first iteration: 
A[n  +  2l  =  x 

A[n  +  3]  =  x 
A In  +  4]  =  x 
A In  +  5]  =  x 
A In  +  6]  =  0 

After the  second iteration: 
A In  +  2]  =  x 

A[n  +  31  =  x  A  f(x) 
A [ n + 4 ]   =  x A f ( x )  

A [ n +   5]  =  x A g ( 0 )  
A[n  +  6]  =  0 

After the  third iteration: 
A[n  + 

A[n  + 

A[n  + 
A[n  + 

2]  =  g(0)  A  f(x)  A  x 

3]  =  g(0)  A  f(x)  A  x  A  #(x) 

(by  assumption) =  g(O)  A  f(x)  A  x 

41  =  g(0)  A  f(x)  A  x 
5]  =  g(0)  A  f(x)  A  x 
afn  +  6]  =  0 

After the  fourth iteration: 

A[n  +  2]  =  g(0)  A  ](x)  A  x 

A[n  +  31  =  q(0)  A  f(x)  A  x  A  fg(O) 
A[n  +  4]  =  g(0)  A  f(x)  A  x  A  fg(O) 
A[n  +  5]  =  g(0)  A  f(x)  A  x 
A[n  +  6]  =  0 
After the fifth iteration: 

A[n  +  2]  =  g(0)  A  f(x)  A  x  A  fg(O) 

A[n  +  a]  --  g(O)  A  f(x)  A  x  m  fg(O)  A  fig(O) 
A[n  +  4]  =  g(0)  A  f(x)  A  x  A  fg(O)  A  fig(O) 

=  g(O)  A  ](x)  A  x  A  fg(O)  (by assumption) 
Ain  +  5]  =  g(0)  A  f(x)  A  x  A  fg(O) 

A[n  +  6]  =  0 
A[n  +  2]  =  g(0)  A  f(x)  A  x  after  the  fourth  iteration  and  A[n  +  2]  =  g(0)  A f(x)  A  x  A  fg(O) 

after  the  fifth  iteration.  By  the  hypothesis  that  ( . )   does  not  hold 
for f,  g, and x,  we have g(0)  A  f(x)  A  x  ~  g(O)  A  f(x)  A  x  A  fg(O).  Thus Algorithm 
K  will take at least 6  >  (d(G) + 3 )   =  5 iterations, and in fact, it does halt after six itera- 
tions. 

In  general,  any I  =  (G,M)  with  T'  grown as  shown in Figure  5  will take  Algorithm 
K  at  least  2d  +  2  iterations  before  it  halts.  [] 

We have completed the proof of Theorem 2. Let us remind the reader that  Theorem 2 
does not  make the  (false)  claim that  unless  (, )  is satisfied for framework D,  there is no 
instance I  =  (G,M)  of  D  for  which  Algorithm  K  takes  at  most  d(G)  +  3  iterations. 
Formally, the false statement is: 

(V D ) (V   instances I  =  (G,M)  of D) 

[Algorithm K  converges in d(G)  W  3 iterations  ~  (,)]. 

It  is  also  worth  noting a  few  statements about  a  framework  D  =  (L,A ,F ) which are 
equivalent to  (*)  and a  few that  are not. We leave the  proofs  to the reader. 

166  J,B.  KAM  AND  J.D.  ULLMAN 

f /  n+l 
/ / 

/  n+2 i Ift  (..~ 

I I  ~  d+n+4 

f I  i 
I I  f /  

~ n + 2  

Fi~.  5. 

xn+3 

*  ~ 

" ~   d+.+l 

d+n+2 
DSFT  T'  generalizing  1Figure 4(b) 

Observatwn 6.  ( , )   is equivalent  to 

(Vf  E F)(Vx, y  E L)[f(y)  >  y  A  f(x)  A  x] 
and  to 

(Vf, g'E  F)(Vx, y  E L)~fg(y)  _> g(y)  / kf (x)   /~  x], 

and  if L  has  a  one  element  1,  to 

(Vf, g E F)[fg(O)  >_ g(O)  A  f(1)] 
and  to 

(Vf  E F)(Vx  E L)~(z)  >_ x  A  f(1)]. 

Observahon  7.  ( , )   Is implied by 

( W   E F)(Vx  E L)[f(x)  _> x] 
and  implies 

(Vf  E  F)(Vx  E L)[ff(x)  ~  f(x)  A  x], 

but  is  equivalent  to  neitheP  of  these  statements. 

6.  Some Specific Data Flow Analysis  Frameworks 
In  his  paper  [10],  Kildall  handles  constant  propagation  by  a  global  data  flow  analysis 
fi'amework  CP  =  (L,A,F),  where  V  =  {X1,  X2,  "..  } for  some  infinite  set  of  variable 

names;  C  is equal  to  the  set  of all values  assumed  by variables;  L  is the  set  of functions 
from  finite subsets  of  V  to  C;  0  E  L  is  the  function  which  is  undefined  for  all X,.  The % 

meet  operation  /k  on  L  is set intersection3  Intuitively, z  E  L  stands  for  the  information 
about  variables  which  we  may  assume  at  certain  points  of  the  program  flow  graph. (v,c)  E z 

implies the variable v has value c. 
We define a notation for functions in F  based on the sequence of assignment statements 
whose effect they  are to  model. 

(1)  For  each  assignment  statement  X  :=  ~(Y1,  "  ",  Y,~), m  ~  1,  for  X  and  Yi,  "" ", 

Recall  that  a  function f-  V  -~ C  is  a  set  of pairs  (v,c)  with  v  E  V  and  c  E  C.  We shall  henceforth 
treat  members  of L  as subsets  of  V  X  C. 

Global  Data  Flow Analysis  and  Iterative  Algorithms  167 

Y,~ in  V,  there  is a  function f  in  F  such  that  for z  E  L,  f(z)  =  z'  is defined by: 

(i)  For  U  ~  X,  z'(U)  =  z( U)   if z(U)  is  defined,  and  z'(U)  is undefined  otherwise. 
(ii)  z '( X )   is  the  value ~(cl,  ..  * , e~)  if z(Y,)  =  c, for  1  <  ,  <  m,  and  z '( X)   is un- 
defined  otherwise. 

We  denote  this  function  by  (X  :=  ~(Y1,  "  ",  ym)). 

(2)  For  each  assignment  statement  X  :=  c,  where  c  E  C  is  a  constant,  the  function 
f  in  F  is defined  as in  (1),  but  (ii)  reads: 

(ii)' z ' ( X)   =  e. 
We  denote  this  function  by  (X  :=  e). 

(3)  For  each  assignment  statement  X  :=  Y,  where  X  and  Y  are  in  V,  the  function 
f i n   F  is defined as  in  (1),  but  (ii)  reads: (ii)"  z'(X)  =  z(F). 

We  denote  this  function  by  (X  :=  Y). 

(4)  e  E  F,  where  e(z)  =  z  for  all z  E  L. 
(5)  If f,  g  E  F,  thenfg  E  F. It  happens  that  the  framework  CP  is not  distributive under  the  normal  interpretation 

of  "values"  [8]. We  shall show  here  that  CP  does not  satisfy  (, ) .   Then  we shall give an 
interpretation  of values for  which  CP  is distributive and  show  that  ( . )   still is not  satis- 
fied. 

THEOREM  3.  CP,  w*th  the  usual  amthmetic  ~nterpretat~on  of  "values,"  does  not  sat- 
isfy  (.) . PROOF.  Let  x  be  {(A,3),  (B,1),  (C,2)}  and  let g be  the  composition of the  functions 

associated  with  the  assignment  statements:  D  :=  1,  E  :=  2,  A  :=  D  +  E,  s  i.e.  g  = 

(A  :=  D  +  E)  o  (E  :=  2)  o  (D  :=  1 ) . L e t f b e t h e f u n c t i o n ( A   :=  B  -4-  C).  Then 
f( x)   =  x,  g(O)  =  {(A,3),  (D,1),  (E,2)},  and  fg(O)  =  {(D,1),  (W,2)}.  Then  fg(0) 

g(0)  A f ( x )   A z   =  {(A,3)}.  [] In  order  that  CP  be  distributive it  is necessary that  operator  symbols be  given  a  free 

interpretation  (see  [8]).  That  is,  values  are  formulas  involving integers  or  reals  and  the 

operator  symbols. The  effect  of  applying m-ary  operator  <# to  formulas  Fi,  F2,  - * * , F,, 
is the  formula ~o(F1, F2,  * - *  , Fro). 

THEOREM  4.  CP  under  a free ~nterpretatwn  of operators  does  not  satisfy  ( , ) .  
PROOF.  The  same  proof  as  that  for  Theorem  3  goes  through  if  we  replace  (A,3)  in 
x b y ( A ,   1  + 2 ) .   [] 

We should  observe  that  only Theorem  4  is  significant, since the  effect on  nondistribu- 
tive  frameworks  of  ( . )   not  holding  has  not  been  investigated.  Also,  the  same  remarks 
as  we  made  here  for  the  framework  CP  apply  to  the  "structured  partition"  lattice  of 

[10l. Now  let  us  consider  a  case  where  (. )   does  hold.  The  usual  bit  vector  common  sub- 

expression  detection  strategy  can  be  expressed  as  the  data  flow  analysis  framework 
CSE  =  ( L , A , F ) ,   where  L  is  the  set  of  bit  vectors  of length  n.  For  x,  y  E  L,  x  A  y  is 
the  bitwise product  (logical AND).  The  0  element  in  L  is  the  word  of  all O's.  Further- 

more,  L  has  a  one  element  1,  namely  the  vector  of  all  l's. 

F  consists  of functions f  which  may  be denoted  (KILL,  GEN>,  where Gl e n   and  KI L L  
are  each  n-bit  vectors,  with  GE N  A  K I L L   =  0.  For  z  C  L,  we  define  f(z)  = 

(z  A  ~ K I L L )   V  GE N;  the  symbols  A,  V,  and-~  stand  for  AND   (bitwise product), 
OR  (bitwise sum),  and  NOT   (bitwise complement),  respectively. 

We  see  that  F  is  closed  under  composition,  because  given  g  =  (KILL~,GEN~),  f  = 
(KIL~,GEN2),  then fg  =  (KILL ',GEN'), where  K IL L '   =  [KILL~ A  ~ G E N d   V  KILLs, 
and  G E N '   =  [GEN1  A  m KILL2]  V  GEN2. 

(0,0)  is the  identity,  and  we leave distributivity for  the  reader  to  check. 
Finally, given  x  E  /~ we  have  x  =  (0,x)  (0),  so  condition  [F4] is satisfied. 
THEOREM  5.  The global  opt,m,zation  problem  CSE  satisfies  condition  ( . ) . 

8 The use of infix rather than postfix notation should not confuse  the reader 

168 

Step 1 

J,B.  KAM  AND  J.D.  ULLMAN 
begin 

temp- element  of L; A  array [1 .  k] of elements  of L, 

3  integer; change  Boolean, 

Ahl  =  0, for 3  =  2 until  /c do  A[ 3]  :=  i, 

change  :=  true, while change do 

begin change  =  :false, 

for.]  =  2 until k do begin 

temp  ~  ^~.r~v~,)f~(A[q]); if temp  ~  A[3] then 

begin change "~  true, 

A[?] .=  temp end 
end end 
end 

FIG.  6  Program for Algorithm MK 

PROOF.  By  Observation  6,  it  suffices  to  show  that  if  the  /th  bit  of  the  word 
g(0)  A  f(1)  is equal to 1, then the ith bit of the wordfg(0)  is also equal to  1,  where  g  = 

(KILLi,GEN~)  and  f  =  (KILI.~,GEN2~. 

The  ith  bit  of g(0)  /~ f(1)  is equal  to  1 iff  (1)  the  ith  bit  of  GENi  =  1,  and  (2)  the 
~th bit of KILLs  =  0.  N o wf g   =  (K ILL ' ,GE N'),   where G E N '   =  ( G E N   A ~ K I L I a )   V 
GEN2.  Since  1 in  a  bit  of GEN2  implies 0  in  the  corresponding bit of KILLs,  by  (1)  and 

(2)  either GEN~  A ~ K I L L 2   has the ,th  bit equal to  1 or GEN2 has the ~th bit eq ualto 1. 
Hence  the  word fg(O)  has  the  ith  bit equal to  1.  [] 

7.  A  Particular  Case:  When  L  Contains  a  1  Element 
If  L  contains  a  1  element,  we  can  apply  a  slightly modified version  of Algorithm  K  to 
achieve  a  better  time  bound. 

ALGORITHM  MK Input:  A particular instanceJ  =  (G,M) of D  =  (L,A,F), where G  =  (N,E,no)  is a flow graph with 

k nodes and L contains a 1 element. Take N  to be  {1, 2,  ...  , kl  and assume the nodes are numbered by rPostorder  Execute the program of Figure 6. 

Convention.  We  say  that  n  iterations  of  Algorithm  M K   have  been  applied,  where 
n  >_  1, if the  loop beginning at  step  1 has  been  applied n  times. 

L:EMMA 4.  Given instance  J  =  (G,M)  of data flow analysis framework  D  =  ( L , A , F ) ,  
where L  contains  a  one  element  1,  and  given an  rPostorder for  G,  after  the  n-th  Iteration  of 
Algorithm  M K ,  

A[j]  =  (  ^  fQ(0))  A  (  ^  f~(1)) QE PATB(n)(3)  QEXPATtI(n)($) 

fl~r  1  <  j  ~  k,  where  X P A T H(~ )(j )  =  {P  I P  is  a  path  in  G from  an  arbitrary  node  to 

node 3,  P  contains n  back edges,  and the first edge in path P  is a back edge}.  I f  X P A   TH (~) (j) 

=:  ~ ,   we let 

^  fq(1)  =  1. Q6XPATH(~)($) 

PROOF.  The  proof  is  similar to  that  of  Lemma  2,  and  we  omit  it.  [] 
THEOREM  6.  Given a  particular  instance  J  =  ( G,M)  of framework  D  =  ( L , A , F )   as 

Global  Data  Flow Analysis  and  Iterative  Algorithms  169 
input,  where L  contains  a  one  element  1,  Algorithm  M K   will  eventually  halt.  At  the comple- 

tion  of Algorithm  M K ,  

A[j]  =  ^  f~(O),  1  < 2   g  k. OEPATTU(3) 

PaOOF.  A  direct consequence  of Lemma  4  and  Theorem  1.  [:J 

LEMMA 5.  Gwen  J  =  ( G,M)  of D  =  ( L , / \ , F ) ,   where L  contains  a  one element  1,  and 
qiven  an  rPostorder  for  G,  Algorithm  M K   will  halt  after  no  more  than  a  ~terations  iff for 
each  node  q  in  N  and for  each path  P  from  node  1  to  node  q,  there  exist 

(1)  paths  P1,  * "  , Pro,  each  going  from  node  1  to  node  q  and  containing  no  more  than 
n  --  2  back  edges,  and 

(2)  paths  Qi,  * * *  ,  Ql,  each  of whwh  zs  a  path  from  an  arbitrary  node  to  node  q,  such 
that each path  contains  n  -  1  back  edges  and  the first  edge  in  the path is  a back edge  satisfy- 
ing  the condition 

re(o)  =  ^  fp,(O)A  ^  fq,(1). l<*<m  l~,<z 

PROOF.  (,f).  Let 

We  must  show  that 

^  f~(0)  A  ^  f~(1). Q ~P/~.TK(n--1) (3)  Q E XPAT~i(n-- 1 ) ($) 

^  fQ(o)  A  ^  f~(1)  =  x. Q E PATH (n) (j)  Q E XPATH (n) (3) 
By  hypothesis,  for  every  Q  C  PATH(n~(j)  we  have fo(0)  >  x.  For  Q  in  XPATH(~)(3), 
consider  Q'  formed  by  prefixing to  Q  a  path  from  the  initial  node  along  the  D F S T   on 
which the  given rPostorder  is based. Surely fq(1)  >  fo' (0).  But fq, (0)  >  x  is given. 

(only  if).  This  part  is analogous  to  Lemma  3  and  we  omit  it.  [] 
THEOREM  7.  Let  D  =  ( L , A , F )   be a  data flow  analysis framework,  where L  contains  a 
one element  1.  Then Algorithm  M K   halts after at most  d( G)  -~  2  iterations for  every instance 

J  =  (G,M)  of D  and  every rPostorder definable for  G  =  (N,E,no),  if and  only i f D  satisfies 
condition  (**) : 

(Vf, g  E  F)(Yx  ~  L)~g(0)  >  g(0) A f(1)]?  (**) 
Formally the  theorem  can  be stated: 
( V D )  { [VJ  =  (G,M)  an  instance  of D) (Algorithm M K  

halts  after  d(G)  -4- 2  iterations)]  ~  (**)}. 

PROOF.  (if).  B~y  Lemma  5,  it  suffices  to  show  that  for  each  node  j  E  N  and  each 
path P  E  P A T H ( j ) ,   there exist paths P1,  * * * , P~  in PATH(d+1)(3 )  and  paths Q1,  * * ", Qt 
in  XPATH(d+I)(j),  where  d  =  d(G),  such  that 

re(o) >  ^  :p,(O) A  ^  :~,(1). l_<,_<m  ,<,<z 

We want  to prove the above by induction on k, the number  of back edges contained in P. 

Basis(O_<  k  <  d).  This  case is trivial; just  l et m   =  1,  l  =  0,  and P1   =  P. 

Induction  step  (k  >  d).  Since  P  contains  more  than  d  back  edges,  the  path  P  = 
il,  ...  , in must  contain  a  cycle.  Let  us  pick  the  highest  number  a  such  that  i,  =  ib  for 
some  b  >  a. 

Case  1  (The  path  i,,i,+l,  . . .   ,  ib-1,  ib,  "."  ,  i,  contains  at  most  d  back edges.)  The 
proof goes exactly as Theorem  2. 

Case  2(a)  (The  path  in, L+i,  "  " , in-l,  ib,  "'"  ,  in  contains  d  +  1  back  edges  and 
b  ~  r.)  Note  that  (i,,  *,+1) must  be  a  back  edge,  because i~+~, * * * , i~ is cycle free. 

* Note  that  (**) m equivalent  to  (*)  when L  has  a  unit,  by  Observation  6. 

170  J.B.  KAM  AND  J.D.  ULLMAN 

We  let  (note  that  both  i~+l  and  ib+l  are  successors  of  i ,):  P1  =  il,  . . .   ,  Q,  ib+l; 
P2  =  a  back-edge-free  path  from  node  1  to  node  /~+1; P3  =  i~+,,  . . . ,   ib+l;  P4  = 
ib+~,  ...,/~;  x  =  fp~(0). 

/ . ( 0 )   =  f . j eJ . l ( o )   1o 

_> fe,(fe~(o)  A  f~s (l))  (by  assumption) 
>_ f. .(f ., (o )  A  f.~(x))  =  f . j . ~ ( o )   A  f . j . j . ~ ( o )   =  f~,(o)  A  f..(o), 

where  P'  =  ~1,  * * ,  ~,  ib+l,  ..  * ,  ,,  and  P"  =  P2,  ~+2,  ""  *  ,  *b,  ib+l,  "  ""  ,  $r).  P'  and 
P"  are  each  seen  to  be  from  1  to  3  =  i,  with  fewer  than  k  back  edges.  The  induction 
follows in  this  ease. 

Case  2(b)  (The  path  i~,  i~+1,  ..  *  , ib,  ""  *  , i~ contains  d  +  1  back  edges  and  b  =  r, 
i.e.  ~a  =  ~b =  ~  =  3")  Again we see that  (~,  to+l)  must  be  a  back  edge. 

Let  P~  =  i~,  ...   ,  i~,  P2  =  i~,  . - - ,   *b.  Then  fp  =  fade1(0)  _~  re,(0)  A  re, (1 ),  by 
assumption.  Since  P~ is  a  path  in  G  with  fewer than  k  back  edges  and  P~  is  a  path  in  G 
with  d  +  1 back  edges,  and  the  first edge in  P~ is a  back  edge,  the  induction  follows. 

(only  ,f).  This  direction  follows  from  Theorem  2.  [] 

8.  Conncluswns 

We  have  examined  Kildall's  lattice-theoretic  formulation  of  global  data  flow  analysis 
problems  with  an  eye  toward  when  depth-first  ordering  (rPostorder)  yields an  efficient 
iterative algorithm.  The  condition 

(Vf,  g  E  F ) ( V x  E  L)[fg(O)  >  g(0)  A f( x )   Ax ]   (*) 
for  a  data  flow  analysis  framework  D  =  ( L , A , F )   was  shown  necessary  and  sufficient 
for  the  depth-first  version  of  Kildall's  algorithm  to  converge  after  d(G)  +  3  passes 

on  an  arbitrary instance  ( G ,M )  of D. 

In  the  case  where  the  semilattice has  a  one  element,  condition  ( , )   is  equivalent  to 

(Vf,  g  E  F)[fg(O)  _>  g(O)  A  f( l )].   (**) 
K~ldall's  algorithm,  using  depth-first  ordering  and  taking  advantage  of  the  presence 
of  the  one  element,  works  in  d(G)  +  2  passes  iff condition  (**)  is  satisfied. 

Combining  the  result  of  [5],  which  shows  that  the  loop  connectedness  of  a  reducible 
flow  graph  never  exceeds  its  interval  depth,  together  with  the  empirical  results  of  [11], 

which  indicates  that  the  interval  depth  averages  2.75,  we  may  expect  that  five  or  six 
passes wi]l be sufficient most  of the time if the data flow analysis framework meets  condi- 
tion  ( . )  and  depth-first ordering is used  in  Kildall's algorithm. 

It  was seen that  the  data flow analysis frameworks used by Kildall for constant  propa- 
gation and  common subexpression elimination do not  meet  condition  (.),  while the  usual 

bit  vector frameworks  of,  e g.  [1,  4,  5,  9,  12,  13],  have  a  one  element  and  meet  condition 

(**).  Thus,  while  Kildall's methods  enable  us  to  detect  certain  instances  of  constant 
propagation  or  common  subexpressions that  are  not  detectable  by  the  bit  vector  meth- 

ods,  it  is possible that  too  high  a  price  (in  terms  of  computation  time)  must  be  paid  for 
the  extra  information  gathered  by  this  framework. 

ACKNOWLEDGMENT.  The  authors  would  like  to  thank  both  referees  for  their  careful 
reading of the manuscript  and  for a  number  of improvements  which  they suggested. 

REFERENCES 

1.  AHO, A V.,  ANn ULL~AN, J.D  The  Theory  of  Parsing,  Translation  and  Compiling,  Vol.  II" Compiling.  Prentice-Hall, Englewood Cliffs,  N J.,  1973 

10 Note  that re1 is the composition of the functions associated with nodes  ,1,  .'.  , *~ but  not *b+~. S~nilarly, re, does not include the effect of *b+t  Thus fp  Is the composition of fe~, ffe,, and fP4, even 

though P  is not the concatenation of paths Pi, Pa, and P4. 

Global  Data  Flow  Analysis  and  Iterative  Algorithms  171 

2.  ALLEN, F.E.  Program  optnnizatlon.  Annual  Review  m  Automatic  Programming,  Vol.  5,  Per- gamon Press,  New  York,  1969, 239-307. 
3.  ALLEN, F.E.  Control flow analysm  SIGPLAN Notices 5, 7  (July  1970),  1-19. 4.  Co c~ ,  J  Global  common  subexpression  elnnination  SIGPLAN  Notices  5,  7  (July  1970), 

20-24. 5.  HECHT, M.S.,  AND ULLMAN, J.D.  Analysis of a snnple algorithm for global flow problems. Proc. 
ACM Conf,  on Principles of Programming Languages,  Oct.  1973, pp.  207-217. 6  HECHT, M  S.,  AND UL~AN,  J  D  Characterizations  of  reducible  flow  graphs.  J.  ACM  21,  3 

(July  1974),  367-375. 7.  HOPCROFT, J .E,  AND TARJAN, R.E.  Algorithm 447--Efficmnt algortthms for  graph  mampula- 
tion. Comm  ACM  16, 6  (June  1973), 372-378. 8.  KAM, J.B.,  AND ULL~AN,  J  D  Monotone  data  flow  analysis  frameworks  TR-169,  Dep.  of 
Elec.  Eng.,  Computer Sciences Lab.,  Princeton U.,  Princeton, N  J ,   Jan  1975 9  KENNEDY, K  A global flow analysis algorithm  Int  J  Computer  Math.  3,  1  (Dec  1971), 5-15. 
10  KILDALL, G A  Global  expression  optnnization  during  compilation.  TR  724)6-02,  Computer Scl  Group,  U.  of Washington,  Seattle,  Wash  , June  1972. See  also  Proc.  ACM  Conf.  on  Prin- 

ciples of Programming Languages,  Oct.  1973, pp  194-206 11.  KNUTH, D.E.  An  empirmal  study  of  FORTRAN  programs.  Software  Pratt  and  Exper.  l,  2 

(April  1971),  105-134 12.  SCHAEFER, M.  A  Mathematical  Theory  o]  Global  Flow  Analysis  Prentice-Hall,  Englewood 
Chffs,  N  J.,  1973. 13.  ULLMAN, J  D  Fast algorithms for the elimination of common subexpressions  Aeta Informatzea 
Z, 3  (Dec.  1973),  191-213 14.  VYSSOTSKY, V.A.  Private  communication to  M.S.  Hecht,  June  1973 

RECEIVED MARCH 1974;  REVISED JANUARY 1975 

Journal of the Association for Computing Machinery, Vol 23, No  1, January 1970 