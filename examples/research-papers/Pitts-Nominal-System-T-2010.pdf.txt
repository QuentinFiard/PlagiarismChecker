

Nominal System T

Andrew M. Pitts \Theta 
University of Cambridge Computer Laboratory, Cambridge, UK

\Theta \Lambda \Xi \Pi \Sigma \Upsilon \Phi \Psi \Omega fffffiflffiffl\Phi ffiij\Phi iffi\Phi `'

Abstract
This paper introduces a new recursion principle for inductive datamodulo

\Theta -equivalence of bound names. It makes use of Odersky-style local names when recursing over bound names. It is formulated in an extension of G"odel's System T with names that can betested for equality, explicitly swapped in expressions and restricted
to a lexical scope. The new recursion principle is motivated bythe nominal sets notion of "

\Theta -structural recursion", whose use ofnames and associated freshness side-conditions in recursive definitions formalizes common practice with binders. The new Nom-inal System T presented here provides a calculus of total functions that is shown to adequately represent \Theta -structural recursionwhile avoiding the need to verify freshness side-conditions in definitions and computations. Adequacy is proved via a normalization-by-evaluation argument that makes use of a new semantics of local
names in Gabbay-Pitts nominal sets.
Categories and Subject Descriptors D.3.1 [Programming Lan-guages]: Formal Definitions and Theory--Syntax; D.3.3 [Programming Languages]: Language Constructs and Features--Re-cursion; F.4.1 [Mathematical Logic and Formal Languages]:
Mathematical Logic--Lambda calculus and related systems
General Terms Languages, Theory, Verification
Keywords binders, alpha-equivalence, recursion, types

1. Introduction
When developing mathematical semantics for programming lan-guages, it is commonplace to ignore concrete syntax and work at

the level of abstract syntax trees. Indeed, if the language involvesbinding constructs (as most do), one usually raises the level of
abstraction even further by implicitly quotienting abstract syntaxtrees by an appropriate notion of

\Theta -equivalence. Working modulo
\Theta -equivalence affects how one defines functions by structural re-cursion and proves properties of them by structural induction--the

fundamental tools of programming language semantics. For ex-ample, the parameters of a recursively defined function can have
their bound names changed as necessary, but one is obliged toprove that the value of the defined function is independent of such
changes. Such proofs of well-definedness up to \Theta -equivalence are
\Theta  Research supported by UK EPSRC grant EP/D000459/1

Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.
POPL'10, January 17-23, 2010, Madrid, Spain.Copyright c\Theta  2010 ACM 978-1-60558-479-9/10/01. . . $10.00

often omitted as obvious. This paper presents a calculus of (to-tal, higher-order) functions with structural recursion modulo

\Theta -equivalence for which such proofs of well-definedness really are

obvious, indeed are entirely automatic, being subsumed by a com-pletely conventional and decidable type system. This is achieved
without giving up on the practically convenient "nominal" treat-ment of binding in which bound names are first-class citizens that
can be tested for equality, passed to functions as arguments and re-turned as results. We call the calculus presented in this paper Nominal System T since it takes G"odel's System T for primitive recursivefunctions of higher type [13] (formulated as a typed

\Lambda -calculus, fol-lowing Tait [34]) and generalizes from numbers to inductive data

modulo \Theta -equivalence of bound names. To bring out the ideas un-derlying our approach without too much syntactic clutter, we use
the familiar and simple example of such data, the terms of the un-typed

\Lambda -calculus [2]

\Theta  \Theta  \Theta \Xi  \Lambda \Lambda \Xi  \Pi  \Lambda  \Xi  \Xi  \Lambda  \Lambda \Pi \Sigma  \Xi \Xi  (1)
where \Pi  ranges over an infinite set \Theta  of variables and where termsare identified up to the usual notion of

\Theta -equivalence (\Pi \Theta ) for \Lambda -bound variables.

When making a structurally recursive definition of a function
\Upsilon  \Lambda  \Theta  \Sigma  \Phi  in terms of functions \Upsilon \Theta  \Lambda  \Theta  \Sigma  \Phi , \Upsilon \Lambda  \Lambda  \Theta  \Sigma  \Theta  \Sigma  \Phi  \Sigma 
\Phi  \Sigma  \Phi  and \Upsilon \Xi  \Lambda  \Theta  \Sigma  \Theta  \Sigma  \Phi  \Sigma  \Phi , one can take advantage of theidentification of terms up to \Pi 

\Theta  by restricting the applicability ofthe recursion equation for
\Lambda -binders:

\Upsilon  \Pi  \Xi  \Upsilon \Theta  \Pi 
\Upsilon \Pi \Xi  \Xi \Lambda \Sigma  \Xi  \Upsilon \Lambda  \Xi  \Xi \Lambda  \Pi \Upsilon  \Xi \Sigma  \Pi \Upsilon  \Xi \Lambda \Sigma 
\Pi  \Psi \Upsilon  \Pi  \Phi  \Upsilon \Pi \Lambda \Pi \Sigma  \Xi \Sigma  \Xi  \Upsilon \Xi  \Pi  \Xi  \Pi \Upsilon  \Xi \Sigma \Sigma  \Theta \Lambda \Xi  (2)

Thus in the third clause we restrict the recursion equation to ap-ply only for bound variables

\Pi  that avoid some finite set \Pi  ofvariables--typically the ones that are involved in the definition

of the functions \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi . For example, the function \Upsilon \Pi \Psi \Sigma  \Xi 
\Pi \Psi \Sigma \Upsilon \Xi \Lambda \Psi \Pi \Lambda \Phi  \Lambda  \Theta  \Sigma  \Theta  for capture-avoiding substitution of \Xi \Lambda  \Upsilon  \Theta 

for \Pi \Lambda  \Upsilon  \Theta  is given by taking \Upsilon \Theta  \Pi  \Theta  \Theta \Lambda  \Pi  \Xi  \Pi \Lambda  \Xi \Pi \Sigma \Upsilon  \Xi \Lambda  \Sigma \Phi \Psi \Sigma  \Pi ,
\Upsilon \Lambda  \Xi  \Xi \Lambda  ff ff\Lambda  \Theta  ff ff\Lambda , \Upsilon \Xi  \Pi  \Xi  ff \Theta  \Lambda \Pi \Sigma  ff and \Pi  to be the finite set con-sisting of

\Pi \Lambda  and the free variables of \Xi \Lambda .Of course, for (2) to specify a well-defined function on

\Theta -equivalence classes, the function
\Upsilon \Xi  in general has to satisfy a con-dition ensuring independence of the definiens in the third clause

from choice of the bound variable \Pi  used to represent the \Lambda -abstraction

\Lambda \Pi \Sigma  \Xi  in the definiendum. What kind of condition shouldwe impose on

\Upsilon \Xi  to ensure this? The notion of \Theta -structural re-cursion gives an answer to this question in terms of the nominal

sets [11, 25]. We briefly recall what is involved; see Pitts [26] forthe full story.

The main idea is to take account of name-permutations, whichmeans for the example we are using, finite permutations

fi of theset \Theta . A nominal set is a set
\Phi  equipped with an action of suchpermutations (written
fi\Omega  ff \Omega \Sigma  fi ff ff) for which every ff \Upsilon  \Phi  isfinitely supported. This means that given

ff, there is a finite subset

\Pi  fi \Theta  such that for any \Pi \Omega  \Pi \Lambda  \Upsilon  \Theta  \Psi  \Pi , the permutation \Pi \Pi  \Pi \Lambda \Sigma  thatswaps

\Pi  and \Pi \Lambda  leaves ff invariant: \Pi \Pi  \Pi \Lambda \Sigma  ff ff \Xi  ff. Complementaryto finite support is the notion of freshness: we say "

\Pi  is fresh for ff"and write
\Pi  \Psi  ff if ff is supported by some finite set not containing
\Pi . For example, permutations act on elements of \Theta  by applicationand this makes \Theta  into a nominal set with the relation of freshness

being "not equal". More generally, \Theta  equipped with the obviouspermutation action is a nominal set and freshness is the "not a
free variable of" relation. The fun begins at higher types. Givennominal sets

\Phi  and fl , the nominal set \Phi  \Theta \Pi \Sigma  fl consists not ofall functions

\Upsilon  from \Phi  to fl , but just the ones that are finitelysupported with respect to the usual permutation action on functions;

that \Upsilon  is supported by finite \Pi  fi \Theta  amounts to requiring for any
\Pi \Omega  \Pi \Lambda  \Upsilon  \Theta  \Psi  \Pi  and ff \Upsilon  \Phi  that \Upsilon \Pi \Pi \Pi  \Pi \Lambda \Sigma  ff ff\Sigma  \Xi  \Pi \Pi  \Pi \Lambda \Sigma  ff \Pi \Upsilon  ff\Sigma . Usingthese concepts Pitts [26, Remark 4.4] proves:

\Theta -Structural Recursion Principle for \Theta . Given finitely sup-ported functions

\Upsilon \Theta  \Upsilon  \Theta  \Theta \Pi \Sigma  \Phi , \Upsilon \Lambda  \Upsilon  \Theta  \Theta \Pi \Sigma  \Theta  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi and
\Upsilon \Xi  \Upsilon  \Theta  \Theta \Pi \Sigma  \Theta  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi , supported by \Pi  fi \Theta  say, suppose
\Upsilon \Xi  satisfies the following "freshness condition for binders": 1fl

\Pi  \Upsilon  \Theta  \Psi  \Pi \Sigma fl\Xi  \Upsilon  \Theta \Sigma flff \Upsilon  \Phi \Sigma  \Pi  \Psi  \Upsilon \Xi  \Pi  \Xi  ff\Sigma  (FCB)
Then there is a unique function \Upsilon  \Upsilon  \Theta  \Theta \Pi \Sigma  \Phi  satisfying the scheme(2), necessarily also finitely supported by

\Pi .

For the example of capture-avoiding substitution mentionedabove, (FCB) holds because

\Upsilon \Xi  \Pi  \Xi  ff \Xi  \Lambda \Pi \Sigma  ff and \Pi  \Psi  \Lambda \Pi \Sigma  ff sincefor any
\Lambda -term ff \Upsilon  \Theta , \Pi  is not free in \Lambda \Pi \Sigma  ff.The Nominal package of Urban and Berghofer [35] for the Isabelle proof assistant implements \Theta -structural recursion (and more)within Isabelle/HOL. Growing experience with Nominal Isabelle
suggests that, despite the need to prove lemmas about freshness,this is a convenient formalization within higher-order logic of structural recursion in the presence of binders. However, those freshnessside-conditions mean that

\Theta -structural recursion is not a convenientbasis for a calculus, as opposed to a logic, of "recursive functions

modulo \Theta ". We will show how to modify it so that given \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi ,there is always a well-defined

\Upsilon  with good computational proper-ties without the need to prove (FCB).

FreshML [31, 33] achieves this within the context of an impurefunctional programming language; freshness conditions get automatically satisfied by dynamically allocating fresh names at run-time. Stateful operational semantics do not give rise to equational
calculi with good logical properties. Indeed, even such an appar-ently simple computational effect as dynamic allocation of names
is known to interact in complicated ways with higher-order func-tions [27]; for example, function expressions can fail to behave extensionally [28, Example 1.2]. Instead of trying to tame dynamicallocation in this context [30], here we propose to avoid it altogether by using (a typed version of) the pure functional theory oflocal names of Odersky [21]. We give this a denotational semantics using nominal sets, which in turn suggests adding an explicitname-swapping operation to Odersky's calculus. Odersky's theory
of local names may seem too simple: compared with the ffi-calculusof Pitts and Stark [27] there is no scope extrusion of local names
from function arguments and no sharing of local names betweencomponents of a tuple. Nevertheless, with the addition of nameswapping it allows us to formulate a new calculus of higher orderrecursive functions over

\Theta  that we prove adequately represents \Theta -structural recursion.

Contributions of this paper. We give a new (and simple) seman-tics for Odersky-style local names based upon the notion of a namerestriction operator in the Gabbay and Pitts [11] model of names
1 (FCB) is equivalent to the apparently weaker condition that there is some
\Theta  \Lambda \Lambda  \Theta  satisfying \Xi \Xi  \Lambda  \Theta \Pi \Xi \Sigma  \Lambda  \Upsilon \Pi  \Theta  \Lambda  \Phi \Xi  \Theta  \Xi  \Sigma .

and binding (Definition 1). This model suggests an extension ofG"odel's system T with local names that can be tested for equality
and explicitly swapped in expressions. The resulting Nominal Sys-tem T contains a ground type

\Theta \Lambda \Xi  whose terms represent \Lambda -termsmodulo
\Theta -equivalence of bound names; it also contains a recursioncombinator that makes use of local names when recursing over data

representing \Lambda -abstractions (see \Pi ffl\Pi \Sigma  in Fig. 3). We consider gen-eralizations to other data with binders besides

\Lambda -terms in Sect. 7;the generalization relies upon the new observation for nominal sets

that concretion of atom-abstractions can be made a total functionin the presence of name-restriction (Theorem 22).

We identify a notion of i-long j-normal form for the well-typedexpressions of Nominal System T and prove that every well-typed
expression is convertible to such a normal form, unique up to a sim-ple structural congruence (Theorem 10). The proof of this is via a
version of the "normalization by evaluation" technique encompass-ing structural congruence of normal forms (Definition 15). Armed
with this normalization property, we show that functions definedby the

\Theta -Structural Recursion Principle for \Theta  described above, canbe faithfully represented in Nominal System T (Theorem 21). In

this way we achieve the aim of producing an expressive calculusof higher-order recursive total functions that avoids the need for
freshness conditions when defining and computing. Indeed, Nom-inal System T has a completely conventional type system and all
freshness conditions associated with \Theta -equivalence are elevated tothe meta-level.

2. Syntax and Semantics
The types and expressions of Nominal System T are given in Fig 1.The part below the dotted lines is what is being added to G"odel's

System T. There are two new ground types: \Sigma \Upsilon \Xi  classifies namesof object-level variables, and

\Theta \Lambda \Xi  classifies terms of the object-language, which we take to be the untyped

\Lambda -calculus. Expressionsmay involve two different kinds of identifier: variables

ff \Upsilon  \Lambda ,standing for unknown expressions, and atomic names
\Pi  \Upsilon  \Theta , stand-ing for unknown object-level variables. Both kinds of identifier may

be bound: the binding forms are function abstraction \Lambda ff\Sigma  \Pi \Psi \Sigma , namerestriction

ffi\Pi \Sigma  \Pi \Psi \Sigma  and object-level \Lambda -abstraction \Pi \Pi \Sigma  \Pi \Psi \Sigma . As dis-cussed in the Introduction, following the usual informal practice expressions are implicitly identified up to \Theta -equivalence of thesebound identifiers.

To simplify the presentation of the syntax we use "Church-style" explicitly-typed variables.2 Thus we assume the countably
infinite set \Lambda  is partitioned into disjoint, countably infinite subsets\Lambda 

\Pi ` \Sigma  as ` ranges over types; the elements of \Lambda \Pi ` \Sigma  are the vari-ables of type

` . Figure 2 gives the inductive definition of the set
\Omega fffi\Pi ` \Sigma  of well-typed expressions for each type ` \Upsilon  flffifi. As be-fore, the typing rules below the dotted line are what is being added

to G"odel's System T. There should be no surprises for the reader inthe new rules: name restriction and name-swapping do not change
the type of the expression acted upon; we have made name-equalitytake a polymorphic boolean type in order not to introduce a separate ground type for booleans; and the arguments for \Theta \Lambda \Xi -recursion,
\Upsilon \Lambda \Phi \Psi , have types as discussed in the Introduction.The intended model of Nominal System T is in terms of nominal sets [11, 25], the definition of which was recalled in the In-troduction. In other words, expressions denote mathematical objects that are finitely supported with respect to the action of permu-tations of atomic names. Finite permutations can be decomposed
into compositions of transpositions; and name-swapping expres-sions

\Omega '\Theta  '\Lambda ffffi ' denote the action of such transpositions. What doexpressions of the form

ffi\Pi \Sigma  ' denote? To answer this question we

2 "Curry-style", with variables assigned types by environments, is possible
and would be desirable for dependently-typed extensions of the system.

` \Upsilon  flffifi \Lambda \Lambda \Xi  ` fifl ` function type\Lambda 

^ ground type
^ \Lambda \Lambda \Xi  ffiffl\Upsilon  type of numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\Lambda 

\Sigma \Upsilon \Xi  type of names\Lambda 
\Theta \Lambda \Xi  type of object-level \Lambda -termsmodulo

\Theta -equivalence

' \Upsilon  \Omega fffi \Lambda \Lambda \Xi  ff variable (ff \Upsilon  \Lambda )\Lambda 

i zero\Lambda 
j ' successor\Lambda 
`\Lambda \Phi \Psi  ' ' ' ffiffl\Upsilon  recursion\Lambda 
\Lambda ff\Sigma  ' function abstraction\Lambda 
' ' function application. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\Lambda 

\Pi  atomic name (\Pi  \Upsilon  \Theta )\Lambda 
ffi\Pi \Sigma  ' name restriction\Lambda 
\Pi ' ' '\Sigma \Lambda  name equality\Lambda 
\Omega ' 'ffffi ' name swapping\Lambda 
^ ' object-level variable\Lambda 
\Sigma  ' ' application term\Lambda 
\Pi \Pi \Sigma  ' \Lambda -abstraction term\Lambda 
\Upsilon \Lambda \Phi \Psi  ' ' ' ' \Theta \Lambda \Xi  recursion

Some defined expressions (where \Pi  \Upsilon  \Theta  and ff\Omega  ff\Lambda  \Upsilon  \Lambda \Pi ` \Sigma ):

`\Phi * \Theta  ffi\Pi \Sigma  \Pi 
\Upsilon \Lambda _\Phi \Lambda  \Theta  \Lambda ff\Sigma  \Lambda ff\Lambda \Sigma  ff
*ffl,ss\Phi \Lambda  \Theta  \Lambda ff\Sigma  \Lambda ff\Lambda \Sigma  ff\Lambda 

\Pi \Pi '\Omega  '\Lambda \Sigma  \Theta  \Pi \Pi \Sigma  \Omega \Pi  'ffffi '\Lambda  where \Pi  is not free in ' or '\Lambda 

Figure 1. Types ` and expressions '

ff \Upsilon  \Lambda \Pi ` \Sigma 
ff \Upsilon  \Omega fffi\Pi ` \Sigma  i \Upsilon  \Omega fffi\Pi ffiffl\Upsilon \Sigma 

' \Upsilon  \Omega fffi\Pi ffiffl\Upsilon \Sigma 
j ' \Upsilon  \Omega fffi\Pi ffiffl\Upsilon \Sigma 

'\Theta  \Upsilon  \Omega fffi\Pi ` \Sigma  '\Lambda  \Upsilon  \Omega fffi\Pi ffiffl\Upsilon  fifl ` fifl ` \Sigma  ' \Upsilon  \Omega fffi\Pi ffiffl\Upsilon \Sigma 

`\Lambda \Phi \Psi  '\Theta  '\Lambda  ' \Upsilon  \Omega fffi\Pi ` \Sigma 

ff \Upsilon  \Lambda \Pi ` \Sigma  ' \Upsilon  \Omega fffi\Pi ` \Lambda \Sigma 

\Lambda ff\Sigma  ' \Upsilon  \Omega fffi\Pi ` fifl ` \Lambda \Sigma 

' \Upsilon  \Omega fffi\Pi ` \Lambda  fifl ` \Sigma 

'\Lambda  \Upsilon  \Omega fffi\Pi ` \Lambda \Sigma 

' '\Lambda  \Upsilon  \Omega fffi\Pi ` \Sigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

\Pi  \Upsilon  \Theta 
\Pi  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi \Sigma 

\Pi  \Upsilon  \Theta  ' \Upsilon  \Omega fffi\Pi ` \Sigma 

ffi\Pi \Sigma  ' \Upsilon  \Omega fffi\Pi ` \Sigma 

'\Theta \Omega  '\Lambda  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi \Sigma 

` \Upsilon  flffifi

\Pi '\Theta  ' '\Lambda \Sigma \Lambda  \Upsilon  \Omega fffi\Pi ` fifl ` fifl ` \Sigma 

'\Theta \Omega  '\Lambda  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi \Sigma 

' \Upsilon  \Omega fffi\Pi ` \Sigma 

\Omega '\Theta  '\Lambda ffffi ' \Upsilon  \Omega fffi\Pi ` \Sigma 

' \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi \Sigma 
^ ' \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 

'\Omega  '\Lambda  \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 
\Sigma  ' '\Lambda  \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 

\Pi  \Upsilon  \Theta 
' \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 

\Pi \Pi \Sigma  ' \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 

'\Theta  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi  fifl ` \Sigma  '\Lambda  \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` fifl ` \Sigma 

'\Xi  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` \Sigma  ' \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma 

\Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  ' \Upsilon  \Omega fffi\Pi ` \Sigma 

Figure 2. Well-typed expressions ' \Upsilon  \Omega fffi\Pi ` \Sigma  \Upsilon ` \Upsilon  flffifi\Phi 

consider nominal sets * equipped with the following extra struc-ture.
Definition 1 (name-restriction operations). A name-restrictionoperation on a nominal set

* is function \Theta  ffl * \Sigma  *, written
\Pi \Pi \Omega  _\Sigma  \Omega \Sigma  \Pi ffi\Pi \Sigma _, that satisfies (3)-(6). \Lambda 

fi ff \Pi ffi\Pi \Sigma _ \Xi  \Pi ffi fi\Pi \Pi \Sigma \Sigma \Pi fi ff _\Sigma  (3)

\Pi  \Psi  \Pi ffi\Pi \Sigma _ (4)
\Pi  \Psi  _ \Phi  \Pi ffi\Pi \Sigma _ \Xi  _ (5)

\Pi ffi\Pi \Sigma \Pi ffi\Pi \Lambda \Sigma _ \Xi  \Pi ffi\Pi \Lambda \Sigma \Pi ffi\Pi \Sigma _\Sigma  (6)
Property (3) says the function preserves the action of permutations
fi. In general this property is called equivariance (and implies thatthe function is supported by the empty set of atoms).

In the presence of (3), property (4) is the nominal sets way ofmodelling the

\Theta -equivalence that we have built in to the syntax ofthe term-former

ffi\Pi \Sigma  \Pi \Psi \Sigma . For if \Pi \Lambda  \Psi  \Pi \Pi \Omega  _\Sigma , then by a standardargument, equivariance implies

\Pi \Lambda  \Psi  \Pi ffi\Pi \Sigma _. Hence neither \Pi \Lambda ,nor
\Pi  by (4), are in the support of \Pi ffi\Pi \Sigma _. Therefore \Pi ffi\Pi \Sigma _ \Xi 
\Pi \Pi  \Pi \Lambda \Sigma  ff \Pi ffi\Pi \Sigma _ \Xi  \Pi ffi\Pi \Lambda \Sigma \Pi \Pi \Pi  \Pi \Lambda \Sigma  ff _\Sigma , by equivariance again. Thus
\Pi ffi\Pi \Sigma _ is invariant under renaming \Pi  with a fresh atomic name \Pi \Lambda .The other two properties (5) and (6) correspond to basic "structural" properties of a notion of name restriction. Structural con-gruence for name-restriction first arose in connection with the reduction semantics of the fi-calculus [18], where it involves "scopeextrusion" properties in addition to (4)-(6). More recently, Gacek
et al. [12, Sect. 2.3] call property (5) strengthening and (6) ex-change and use these structural properties in connection with locally scoped eigenvariables and generic judgements in inductiveproofs.

We can get a name-restriction operation for a nominal set of
\Lambda -terms by adjoining a constant ffl\Sigma i to the grammar in (1)

\Theta \Upsilon ffl\Sigma i \Phi  \Theta  \Theta \Xi  \Lambda \Lambda \Xi  \Pi  \Lambda  \Xi  \Xi  \Lambda  \Lambda \Pi \Sigma  \Xi  \Lambda  ffl\Sigma i \Xi  (7)
and defining \Pi ffi\Pi \Sigma \Xi  to be \Xi \Upsilon ffl\Sigma i\Psi \Pi \Phi . The ground type \Theta \Lambda \Xi  stands forthis nominal-set-with-restriction-operation,

\Theta \Upsilon ffl\Sigma i \Phi . The ground
type \Sigma \Upsilon \Xi  stands for a substructure of this, namely \Theta \Upsilon ffl\Sigma i \Phi  \Theta \Theta  i \Theta 

ffl\Sigma i \Xi ; and the ground type ffiffl\Upsilon  stands for the usual set ofnatural numbers \Xi 

\Xi  \Theta \Omega \Omega  ff\Omega  fi\Omega  \Sigma  \Sigma  \Sigma \Xi  with trivial permutation action(
fi ff * \Xi  *) and trivial name-restriction operation (\Pi ffi\Pi \Sigma * \Xi  *).For higher types we make use of the following new result about

nominal sets.
Theorem 2 (name-restriction on functions). Suppose that \Phi  and
* are nominal sets and that * is equipped with a name-restrictionoperation

ffi\Xi . Then there is a name-restriction operation ffi on thenominal set

\Phi  \Theta \Pi \Sigma  * of finitely supported functions satisfying

\Pi  \Psi  ff \Phi  \Pi \Pi ffi\Pi \Sigma \Upsilon \Sigma ff \Xi  \Pi ffi\Xi \Pi \Sigma \Pi \Upsilon  ff\Sigma  (8)
for all \Pi  \Upsilon  \Theta , ff \Upsilon  \Phi  and \Upsilon  \Upsilon  \Phi  \Theta \Pi \Sigma  *.

Proof. Given \Pi  \Upsilon  \Theta  and \Upsilon  \Upsilon  \Phi  \Theta \Pi \Sigma  *, we define \Pi ffi\Pi \Sigma \Upsilon  \Upsilon  \Phi  \Theta \Pi \Sigma  *by mapping each

ff \Upsilon  \Phi  to

\Pi \Pi ffi\Pi \Sigma \Upsilon \Sigma  ff \Theta  \Pi ffi\Xi \Pi \Lambda \Sigma \Pi \Pi \Pi \Pi  \Pi \Lambda \Sigma  ff \Upsilon \Sigma  ff\Sigma  where \Pi \Lambda  \Psi  \Pi \Pi \Omega  \Upsilon \Omega  ff\Sigma . (9)
It is not hard to see that the right-hand side is independent of thechoice of

\Pi \Lambda ; that the resulting function \Pi ffi\Pi \Sigma \Upsilon  is finitely supported(by
\Pi  \Psi  \Theta \Pi \Xi , if \Pi  supports \Upsilon ); and that \Pi \Pi \Omega  \Upsilon \Sigma  \Omega \Sigma  \Pi ffi\Pi \Sigma \Upsilon  satisfies(3)-(6) and (8).

In view of this theorem, if we interpret the ground types ffiffl\Upsilon ,
\Sigma \Upsilon \Xi  and \Theta \Lambda \Xi  as \Xi , \Theta \Upsilon ffl\Sigma i \Phi  and \Theta \Upsilon ffl\Sigma i \Phi  respectively, and interpretfunction types using exponentiation

\Pi \Psi \Sigma  \Theta \Pi \Sigma  \Pi \Psi \Sigma  in jj`, thenevery type of Nominal System T denotes a nominal set equipped

with a restriction operation. These restriction operations are used

\Pi \Lambda ff\Sigma  '\Sigma  '\Lambda  ` '\Upsilon '\Lambda \Psi ff\Phi  \Pi j\Sigma 

' ` \Lambda ff\Sigma \Pi ' ff\Sigma  if ff \Psi  ' \Pi i\Sigma 

when \Upsilon  \Theta  `\Lambda \Phi \Psi  '\Theta  '\Lambda :

\Upsilon  i ` '\Theta  \Pi ffli\Sigma 
\Upsilon  \Pi j '\Sigma  ` '\Lambda  ' \Pi \Upsilon  '\Sigma  \Pi fflj\Sigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ffi\Pi \Sigma  ' ` ' if \Pi  \Psi  ' \Pi ffi\Psi \Sigma 
ffi\Pi \Sigma  ffi\Pi \Lambda \Sigma  ' ` ffi\Pi \Lambda \Sigma  ffi\Pi \Sigma  ' \Pi ffiffi\Sigma 

when ,\Omega  ,\Lambda  \Upsilon  \Theta  i \Theta `\Phi *\Xi :

\Pi , ' ,\Lambda \Sigma \Lambda  ` \Upsilon \Lambda _\Phi \Lambda  if , \Xi  ,\Lambda  \Pi '\Xi \Sigma 
\Pi , ' ,\Lambda \Sigma \Lambda  ` *ffl,ss\Phi \Lambda  if , '\Xi  ,\Lambda  \Pi '\Upsilon \Sigma 

when ae \Xi  i\Omega  j\Omega  ^\Omega  \Sigma :

ffi\Pi \Sigma  ae ss' ` ae ffi\Pi \Sigma  ss' \Pi ffiae\Sigma 
\Omega '\Theta  '\Lambda ffffi \Pi ae ss'\Sigma  ` ae \Pi \Omega '\Theta  '\Lambda ffffi ss'\Sigma  \Pi fiae\Sigma 

ffi\Pi \Sigma  \Pi \Pi \Lambda \Sigma  ' ` \Pi \Pi \Lambda \Sigma  ffi\Pi \Sigma  ' if \Pi  '\Xi  \Pi \Lambda  \Pi ffi\Pi \Sigma 
\Omega '\Theta  '\Lambda ffffi \Pi \Pi \Sigma  ' ` \Pi \Pi \Sigma  \Omega '\Theta  '\Lambda ffffi ' if \Pi  \Psi  \Pi '\Theta \Omega  '\Lambda \Sigma  \Pi fi\Pi \Sigma 

ffi\Pi \Sigma  \Lambda ff\Sigma  ' ` \Lambda ff\Sigma  ffi\Pi \Sigma  ' \Pi ffi\Lambda \Sigma 
\Omega '\Theta  '\Lambda ffffi \Lambda ff\Sigma  ' ` \Lambda ff\Sigma  \Omega '\Theta  '\Lambda ffffi \Pi '\Upsilon \Omega '\Theta  '\Lambda ffffi ff \Psi  ff\Phi \Sigma if

ff \Psi  \Pi '\Theta \Omega  '\Lambda \Sigma  \Pi fi\Lambda \Sigma 
\Omega '\Theta  '\Lambda ffffi \Pi  ` \Pi '\Theta  ' \Pi \Sigma \Theta \Lambda \Xi  '\Lambda  \Pi \Pi '\Lambda  ' \Pi \Sigma \Theta \Lambda \Xi  '\Theta  \Pi \Sigma  \Pi fi\Pi \Sigma 
\Omega '\Theta  '\Lambda ffffi `\Phi * ` `\Phi * \Pi fi`\Phi *\Sigma 

when \Upsilon  \Theta  \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi :

\Upsilon  \Pi ^ '\Sigma  ` '\Theta  ' \Pi ffl^\Sigma 
\Upsilon  \Pi \Sigma  ' '\Lambda \Sigma  ` '\Lambda  ' '\Lambda  \Pi \Upsilon  '\Sigma  \Pi \Upsilon  '\Lambda \Sigma  \Pi ffl\Sigma \Sigma 

\Upsilon  \Pi \Pi \Pi \Sigma  '\Sigma  ` ffi\Pi \Sigma  '\Xi  \Pi  ' \Pi \Upsilon  '\Sigma  if \Pi  \Psi  \Pi '\Theta \Omega  '\Lambda \Omega  '\Xi \Sigma  \Pi ffl\Pi \Sigma `

is the congruence generated by these conversions

Figure 3. Conversion ` fi \Omega fffi\Pi ` \Sigma  ffl \Omega fffi\Pi ` \Sigma  \Upsilon ` \Upsilon  flffifi\Phi 

to interpret name-restriction expressions ffi\Pi \Sigma  ' of each type. Finally,
ffiffl\Upsilon -recursion expressions `\Lambda \Phi \Psi  '\Theta  '\Lambda  ' and \Theta \Lambda \Xi -recursion expres-sions

\Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  ' are interpreted using primitive recursion fornumbers and

\Theta -structural recursion [26] for \Lambda -terms (extended witha constant
ffl\Sigma i) respectively. We leave the formal details of thisdenotational semantics of Nominal System T to the full version of

this paper and pass on to computational issues.

3. Conversion
Figure 3 gives the notion of expression equality that we usefor Nominal System T: conversion,

' ` '\Lambda \Upsilon ` \Upsilon  flffifi\Omega  '\Omega  '\Lambda  \Upsilon 
\Omega fffi\Pi ` \Sigma \Phi . Rather than giving a notion of rewriting between ex-pressions and proving canonicity (interesting though that might

be), we prefer to go directly to a notion of equality and prove de-cidability via a normalization function (given in Sect. 5). For one
thing, our conversion relation contains reductions, expansions anda "structural" conversion

\Pi ffiffi\Sigma  that has no preferred orientation;so considering conversion rather than reduction seems to make

more sense. Figure 3 uses the notation '\Upsilon '\Lambda \Psi ff\Phi  for the capture-avoiding substitution of

'\Lambda  for all free occurrences of ff in '. Italso uses the notation
ff \Psi  ' (respectively, \Pi  \Psi  ') to indicatethat
ff is not a free variable (respectively, \Pi  is not a free atomicname) of

'. (This coincides with the freshness relation when weregard
\Omega fffi\Pi ` \Sigma  as a nominal set in Sect. 5.) Finally, the figurealso uses some notation in connection with sequences of expressions: if ss' \Xi  '\Theta \Sigma \Sigma '\Pi , then ffi\Pi \Sigma ss' \Theta  \Pi ffi\Pi \Sigma  '\Theta \Sigma \Sigma \Sigma \Pi ffi\Pi \Sigma  '\Pi \Sigma  and
\Omega ' '\Lambda ffffi ss' \Theta  \Pi \Omega ' '\Lambda ffffi '\Theta \Sigma \Sigma \Sigma \Pi \Omega ' '\Lambda ffffi '\Pi \Sigma . The conversions be-low the dotted line in Fig. 3 are what is being added to G"odel's

System T. Although we omit the proof in this extended abstract, itis not hard to show:

Theorem 3 (soundness). Conversion is sound for equality in thenominal sets model sketched in the previous section.

After the fact, and rather pleasingly, the conversions in Fig. 3 for
ffi\Pi \Sigma  \Pi \Psi \Sigma  turn out to agree with the functional theory of local namesgiven by Odersky [21]; conversion

\Pi ffi\Lambda \Sigma  corresponds to his ffi\Sigma reduction, and
\Pi ffiae\Sigma  to his ffi\Upsilon  reduction. The structural conversions
\Pi ffi\Psi \Sigma  and \Pi ffiffi\Sigma  are not explicit in Odersky's system, but are validup to contextual equivalence. However, Nominal System T takes a

rather more "logical" view of name-equality: in Odersky's system
ffi\Pi \Sigma  \Pi  is not a value (canonical form) and ffi\Pi \Sigma  \Pi  \Xi \Xi  ffi\Pi \Sigma  \Pi  is a stuckexpression that does not reduce; whereas here

ffi\Pi \Sigma  \Pi  is a normalform (denoting the constant
ffl\Sigma i in our nominal sets model) and
\Pi ffi\Pi \Sigma  \Pi  ' ffi\Pi \Sigma  \Pi \Sigma \Lambda  is convertible to \Upsilon \Lambda _\Phi \Lambda  by the conversion \Pi '\Xi \Sigma .Note that in general

ffi\Pi \Sigma \Pi ' ' '\Lambda \Sigma \Lambda  '` \Pi \Pi ffi\Pi \Sigma  '\Sigma  ' \Pi ffi\Pi \Sigma  '\Lambda \Sigma \Sigma \Lambda  ; forexample, if
\Pi  '\Xi  \Pi \Lambda , then using \Pi '\Upsilon \Sigma  and \Pi ffi\Psi \Sigma  we have

ffi\Pi \Sigma ffi\Pi \Lambda \Sigma \Pi \Pi  ' \Pi \Lambda \Sigma \Lambda  ` ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  *ffl,ss\Phi \Lambda  ` *ffl,ss\Phi \Lambda  (10)
whereas, using \Pi ffi\Psi \Sigma  and \Pi '\Xi \Sigma , we have

\Pi \Pi ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  \Pi \Sigma  ' \Pi ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  \Pi \Lambda \Sigma \Sigma \Lambda  ` \Pi `\Phi * ' `\Phi *\Sigma \Lambda  ` \Upsilon \Lambda _\Phi \Lambda  (11)
and it is a corollary of Theorem 3 that \Upsilon \Lambda _\Phi \Lambda  '` *ffl,ss\Phi \Lambda  . Note alsothat although

\Pi ffi\Pi \Sigma '\Sigma '\Lambda  ` ffi\Pi \Sigma  \Pi ' '\Lambda \Sigma  if \Pi  \Psi  '\Lambda  (12)
is provable from the conversions \Pi j\Sigma , \Pi i\Sigma  and \Pi ffi\Lambda \Sigma  in Fig. 3, ingeneral

' \Pi ffi\Pi \Sigma  '\Lambda \Sigma  '` ffi\Pi \Sigma  \Pi ' '\Lambda \Sigma . Evidently Odersky's is a differentnotion of "local name" from the more common one (in Scheme,

ML, Haskell, . . . ) based on dynamic allocation of globally freshnames. It has better logical properties (for example, it does not
disturb function extensionality) and is in a sense more general thandynamic allocation, because the latter can be encoded in it via a
continuation monad; cf. Shinwell and Pitts [32].The conversions in Fig. 3 for

\Omega '\Theta  '\Lambda ffffi \Pi \Psi \Sigma  correspond to thedefining properties, at each type, of the permutation action in the

nominal sets model. In particular, the rather complicated lookingconversion

\Pi fi\Lambda \Sigma  just reflects the usual definition of the action ofpermutations on functions (see Pitts [26, Sect. 3.2], for example).

The last three conversions in Figure 3, \Pi ffl^\Sigma -\Pi ffl\Pi \Sigma , give thenew "recursion modulo

\Theta " scheme which in Sect. 6 is shown toadequately represent the

\Theta -structural recursion of Pitts [26]. Wegive some examples of its use.

Example 4 (substitution, non-capturing and capturing). Con-sider

\Theta \Lambda \Xi  \Theta  \Lambda ff\Sigma  \Lambda ae\Sigma \Lambda oe\Sigma  \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  oe\Upsilon 

\Omega fffi\Pi \Sigma \Upsilon \Xi  fifl \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi \Sigma \Omega  where

'\Theta  \Theta  \Lambda ff\Lambda \Sigma  \Pi ff ' ff\Lambda \Sigma \Pi \Sigma \Xi  ae \Pi ^ ff\Lambda \Sigma \Omega 
'\Lambda  \Theta  \Lambda ae\Sigma  \Lambda ae\Lambda \Sigma  \Lambda oe\Sigma  \Lambda oe\Lambda \Sigma  \Sigma  oe oe\Lambda \Omega 
'\Xi  \Theta  \Lambda ff\Sigma  \Lambda ae\Sigma  \Lambda oe\Sigma  \Pi \Pi ff\Omega  oe\Sigma 
and where \Pi \Pi ff\Omega  oe\Sigma  \Theta  \Pi \Pi \Sigma  \Omega \Pi  ffffffi oe is an instance of the def-inition given at the bottom of Fig. 1. It is a non-binding binary operation for object-level \Lambda -abstraction (the analogue of theatom-abstraction operation

'\Omega  '\Lambda  \Omega \Sigma  oe'fl'\Lambda  in FreshML [33]). If
'\Omega  '\Lambda  \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi \Sigma , then we claim that \Theta \Lambda \Xi  \Pi \Lambda  '\Lambda  ' represents thecapture-avoiding substitution of (the

\Lambda -term represented by) '\Lambda  for
^ \Pi \Lambda  in (the \Lambda -term represented by) '. For example, \Pi \Pi \Sigma  ^ \Pi \Lambda  repre-sents the

\Lambda -term \Lambda \Pi \Sigma  \Pi \Lambda ; so, assuming \Pi  and \Pi \Lambda  are distinct atomicnames,
\Theta \Lambda \Xi  \Pi \Lambda  \Pi ^ \Pi \Sigma  \Pi \Pi \Pi \Sigma  ^ \Pi \Lambda \Sigma  should represent \Pi \Lambda \Pi \Sigma  \Pi \Lambda \Sigma \Upsilon \Pi \Psi \Pi \Lambda \Phi , thatis,
\Lambda \Pi \Lambda \Lambda \Sigma  \Pi  where \Pi \Lambda \Lambda  '\Xi  \Pi . Indeed, one can use the conversion equations in Fig. 3 to calculate that

\Theta \Lambda \Xi  \Pi \Lambda  \Pi ^ \Pi \Sigma  \Pi \Pi \Pi \Sigma  ^ \Pi \Lambda \Sigma 

\Xi  \Theta \Lambda \Xi  \Pi \Lambda  \Pi ^ \Pi \Sigma  \Pi \Pi \Pi \Lambda \Lambda \Sigma  ^ \Pi \Lambda \Sigma  where \Pi \Lambda \Lambda  '\Xi  \Pi \Omega  \Pi \Lambda `

\Upsilon \Lambda \Phi \Psi  '\Theta \Upsilon \Pi \Lambda \Psi ff\Omega  ^ \Pi \Psi ae\Phi  '\Lambda  '\Xi  \Pi \Pi \Pi \Lambda \Lambda \Sigma  ^ \Pi \Lambda \Sigma `
ffi\Pi \Lambda \Lambda \Sigma  '\Xi  \Pi \Lambda \Lambda  \Pi ^ \Pi \Lambda \Sigma  \Pi \Upsilon \Lambda \Phi \Psi  '\Theta \Upsilon \Pi \Lambda \Psi ff\Omega  ^ \Pi \Psi ae\Phi  '\Lambda  '\Xi  \Pi ^ \Pi \Lambda \Sigma \Sigma `
ffi\Pi \Lambda \Lambda \Sigma  \Pi \Pi \Pi \Lambda \Lambda \Omega  ^ \Pi \Sigma 
\Theta  ffi\Pi \Lambda \Lambda \Sigma  \Pi \Pi \Lambda \Lambda \Lambda \Sigma \Omega \Pi \Lambda \Lambda \Lambda  \Pi \Lambda \Lambda ffffi \Pi ^ \Pi \Sigma  where \Pi \Lambda \Lambda \Lambda  '\Xi  \Pi \Omega  \Pi \Lambda \Omega  \Pi \Lambda \Lambda `

ffi\Pi \Lambda \Lambda \Sigma  \Pi \Pi \Lambda \Lambda \Lambda \Sigma ^ \Pi `
\Pi \Pi \Lambda \Lambda \Lambda \Sigma  ^ \Pi 
bearing in mind that we identify expressions up to \Theta -equivalenceof bound atomic names. Doing so has the consequence that the

object-level capture-avoidance property of \Theta \Lambda \Xi  is delegated to theproperties of meta-level

\Theta -equivalence. This is an idea familiarfrom higher-order abstract syntax [23], except that here we are

"baking in" to the meta-language just object-level \Theta -equivalencerather than object-level

\Theta ji-equivalence (in order to keep hold ofa very simple yet expressive recursion principle). The claim that

\Theta \Lambda \Xi  correctly represents capture-avoiding substitution is substan-tiated in Sect. 6. It is worth noting that we can also represent the
kind of capturing substitution that may occur when a \Lambda -term con-text has its hole filled. Holes are represented by variables

ff; andhole-filling by substitution of expressions for variables,
'\Upsilon '\Lambda \Psi ff\Phi .For example the context
\Lambda \Pi \Sigma \Upsilon \Psi \Phi  can be represented by the openexpression
\Pi \Pi \Pi \Omega  ff\Sigma  \Xi  \Pi \Pi \Lambda \Sigma  \Omega \Pi \Lambda  \Pi ffffi ff. Filling the hole in \Lambda \Pi \Sigma \Upsilon \Psi \Phi with
\Pi  gives \Lambda \Pi \Sigma  \Pi ; and correspondingly, the substituted expression
\Pi \Pi \Pi \Omega  ff\Sigma \Upsilon ^ \Pi  \Psi  ff\Phi  is indeed convertible to \Pi \Pi \Sigma  ^ \Pi  (cf. Lemma 19(ii)).

Example 5 (length of a \Lambda -term). Consider the function \Lambda \Psi \Lambda  \Lambda 
\Theta  \Sigma  \Xi  satisfying \Lambda \Pi \Lambda  \Xi  ff, \Lambda \Xi  \Xi \Lambda \Lambda  \Xi  \Lambda \Xi \Lambda  fl \Lambda \Xi \Lambda \Lambda  and \Lambda \Lambda \Pi \Sigma  \Xi \Lambda  \Xi  \Lambda \Xi \Lambda  fl ff.What could be simpler? And yet formal recursion schemes for

\Lambda -terms have found it tricky: see Gordon and Melham [14, Sect. 3.3]

and Norrish [20, Sect. 3]. We can represent this function in NominalSystem T more or less directly by

\Pi \Sigma \Upsilon  \Theta  \Lambda ff\Sigma  \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  ff \Upsilon  \Omega fffi\Pi \Theta \Lambda \Xi  fifl ffiffl\Upsilon \Sigma \Omega  where

'\Theta  \Theta  \Lambda ff\Sigma  j i
'\Lambda  \Theta  \Lambda ff\Omega  ff\Lambda \Omega  ae\Omega  ae\Lambda \Sigma  \Phi \Pi \Lambda \Theta  ae ae\Lambda 
'\Xi  \Theta  \Lambda ff\Omega  ae\Omega  oe\Sigma  j oe
and where \Phi \Pi \Lambda \Theta  \Theta  \Lambda ff\Omega  ae\Sigma  `\Lambda \Phi \Psi  ff \Pi \Lambda ff\Lambda \Omega  ae\Lambda \Sigma  j ae\Lambda \Sigma  ae is the usualprimitive recursive definition of addition. For example \Lambda 

\Lambda \Pi \Sigma  \Pi \Lambda  \Xi  fiand

\Pi \Sigma \Upsilon  \Pi \Pi \Pi \Sigma  ^ \Pi \Sigma  ` \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  \Pi \Pi \Pi \Sigma  ^ \Pi \Sigma `

ffi\Pi \Sigma  '\Xi  \Pi  \Pi ^ \Pi \Sigma  \Pi \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  \Pi ^ \Pi \Sigma \Sigma `
ffi\Pi \Sigma  j\Pi '\Theta  \Pi \Sigma `
ffi\Pi \Sigma  j\Pi j i\Sigma `
j\Pi j i\Sigma 

where the last step is the "strengthening" conversion \Pi ffi\Psi \Sigma .
Example 6 (computing with bound variables). The nominaltreatment of binders allows us to compute with bound names. What

if we try to do something with them that would break object-level

\Theta -equivalence?--such as trying to compute a list of boundvariables in a

\Lambda -term:

\Xi \Psi  \Pi ^ '\Sigma  ` \Upsilon \Omega \Pi 
\Xi \Psi  \Pi \Sigma  ' '\Lambda \Sigma  ` ff\Phi \Phi \Sigma \Upsilon fi \Pi \Xi \Psi  '\Sigma  \Pi \Xi \Psi  '\Lambda \Sigma 

\Xi \Psi  \Pi \Pi \Pi \Sigma  '\Sigma  ` ffi\Pi \Sigma  flffi\Upsilon \Theta  \Pi  \Pi \Xi \Psi  '\Sigma 

where we encode lists of atomic names as certain expressions oftype

\Theta \Lambda \Xi  and \Upsilon \Omega \Pi  , flffi\Upsilon \Theta  and ff\Phi \Phi \Sigma \Upsilon fi are suitable encodings ofnil, cons and append operations for such lists. Clearly we can get

the above conversions by defining \Xi \Psi  \Theta  \Lambda ff\Sigma  \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  fffor suitable choices of expression

'\Theta , '\Lambda  and '\Xi . However, allthat
\Xi \Psi  computes is a list of `\Phi *'s whose length is the numberof occurrences of bound variables in the

\Lambda -term. For example
\Xi \Psi  \Pi \Pi \Pi \Sigma \Pi \Pi \Lambda \Sigma  ^ \Pi \Sigma  ` flffi\Upsilon \Theta  `\Phi * \Pi flffi\Upsilon \Theta  `\Phi * \Upsilon \Omega \Pi  \Sigma . Compare this withthe Fresh Objective Caml function

,o/ss\Upsilon AEOEffl\Lambda ss of Shinwell andPitts [31, p. 15].

Remark 7 (`\Phi * versus ffi\Pi \Sigma  \Pi \Psi \Sigma ). Can the binder ffi\Pi \Sigma  \Pi \Psi \Sigma  be elimi-nated in favour of a constant

`\Phi *? In the ffi-calculus [27], `\Phi * com-putes a dynamically allocated fresh name and the corresponding

local name binder ffiff\Sigma  ' can be defined as \Pi \Lambda ff\Sigma  '\Sigma  `\Phi *. This doesnot work for Nominal System T; for example,

ffi\Pi \Sigma  \Pi \Pi  ' `\Phi *\Sigma \Lambda  `
*ffl,ss\Phi \Lambda  whereas \Pi \Lambda ff\Sigma  \Pi ff ' `\Phi *\Sigma \Lambda  \Sigma  `\Phi * ` \Upsilon \Lambda _\Phi \Lambda  . On the otherhand in the nominal sets model that was sketched in Section 2,

name-restriction for the types of Nominal System T is ultimatelydefined in terms of a constant

ffl\Sigma i . So it may be possible, if incon-venient, to reformulate the system with a constant

`\Phi * rather thana binder
ffi\Pi \Sigma  \Pi \Psi \Sigma .

Remark 8 (incompleteness). We remarked above (Theorem 3)that conversion is a sound axiomatization of properties of equality

in the nominal sets model of Nominal System T. It is not a com-plete axiomatization for the usual recursion-theoretic reasons. In
fact the definition of conversion was chosen to be as weak as possi-ble subject to the criteria that it be decidable, have relatively simple
normal forms (see Sect. 4) and adequately represent \Theta -structuralrecursion when restricted to closed expressions (see Sect. 6). Even
if we restrict to the "finite" part of the system, there are non-convertible expressions that are identified in the model. For example, \Lambda ff\Sigma  \Omega \Pi  \Pi ffffi ff denotes the identity function in the model, but isnot convertible to

\Lambda ff\Sigma  ff. It would certainly be interesting to investi-gate stronger, but still sound and decidable, notions of conversion.

4. Normal Forms
Figure 4 gives a notion of i-long j-normal form for NominalSystem T. We call elements

, of the subset ffl\Lambda  \Pi ` \Sigma  fi \Omega fffi\Pi ` \Sigma normal forms of type
` ; and elements o/ of the subset ffl\Sigma '\Pi ` \Sigma  fi
\Omega fffi\Pi ` \Sigma  neutral forms of type ` . Note that in the figure, ^ \Upsilon \Theta 

ffiffl\Upsilon \Omega  \Sigma \Upsilon \Xi \Omega  \Theta \Lambda \Xi \Xi  is a ground type; so, as usual for simply typed
\Lambda -calculus, only neutral forms of ground type are normal forms.In addition, note that name-restriction

ffi\Pi \Sigma  \Pi \Psi \Sigma  only occurs in thenormal form
`\Phi * (recall that `\Phi * is ffi\Pi \Sigma  \Pi  by definition) and appliedto neutral forms of ground type; similarly, name-swapping is only

applied to neutral forms of ground type.If

o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma  and \Pi  does not occur free in o/, then o/ and
ffi\Pi \Sigma  o/ are different elements of ffl\Lambda  \Pi ^\Sigma  even though o/ ` ffi\Pi \Sigma  o/ by
\Pi ffi\Psi \Sigma . Similarly, ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  o/ and ffi\Pi \Lambda \Sigma ffi\Pi \Sigma  o/ are different elements of
ffl\Lambda  \Pi ^\Sigma  (so long as \Pi  '\Xi  \Pi \Lambda ) even though ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  o/ ` ffi\Pi \Lambda \Sigma ffi\Pi \Sigma  o/by

\Pi ffiffi\Sigma . However, these are essentially the only instances whereconversion between normal forms does not coincide with syntactic

identity (modulo \Theta -equivalence, of course). More precisely, it is aconsequence of the Normalization Theorem below that conversion
restricted to normal forms coincides with the following simplenotion of structural congruence.

Definition 9 (structural congruence). The relations of structuralcongruence

, \Pi  ,\Lambda  \Upsilon ` \Upsilon  flffifi\Omega  ,\Omega  ,\Lambda  \Upsilon  ffl\Lambda  \Pi ` \Sigma \Phi 

o/ \Pi  o/\Lambda  \Upsilon ` \Upsilon  flffifi\Omega  o/\Omega  o/\Lambda  \Upsilon  ffl\Sigma '\Pi ` \Sigma \Phi 
comprise the congruence on normal and neutral forms generated by

ffi\Pi \Sigma  o/ \Pi  o/ if \Pi  \Psi  o/ (13)
ffi\Pi \Sigma ffi\Pi \Lambda \Sigma  o/ \Pi  ffi\Pi \Lambda \Sigma ffi\Pi \Sigma  o/ (14)
for all o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma  and ^ \Upsilon  \Theta ffiffl\Upsilon \Omega  \Sigma \Upsilon \Xi \Omega  \Theta \Lambda \Xi \Xi . \Lambda 

i \Upsilon  ffl\Lambda  \Pi ffiffl\Upsilon \Sigma 

, \Upsilon  ffl\Lambda  \Pi ffiffl\Upsilon \Sigma 
j , \Upsilon  ffl\Lambda  \Pi ffiffl\Upsilon \Sigma 

ff \Upsilon  \Lambda \Pi ` \Sigma  , \Upsilon  ffl\Lambda  \Pi ` \Lambda \Sigma 

\Lambda ff\Sigma  , \Upsilon  ffl\Lambda  \Pi ` fifl ` \Lambda \Sigma 

o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma 

o/ \Upsilon  ffl\Lambda  \Pi ^\Sigma 

ff \Upsilon  \Lambda \Pi ` \Sigma 
ff \Upsilon  ffl\Sigma '\Pi ` \Sigma 

,\Theta  \Upsilon  ffl\Lambda  \Pi ` \Sigma 
,\Lambda  \Upsilon  ffl\Lambda  \Pi ffiffl\Upsilon  fifl ` fifl ` \Sigma 

o/ \Upsilon  ffl\Sigma '\Pi ffiffl\Upsilon \Sigma 

`\Lambda \Phi \Psi  ,\Theta  ,\Lambda  o/ \Upsilon  ffl\Sigma '\Pi ` \Sigma 

o/ \Upsilon  ffl\Sigma '\Pi ` fifl ` \Lambda \Sigma 

, \Upsilon  ffl\Lambda  \Pi ` \Sigma 

o/ , \Upsilon  ffl\Sigma '\Pi ` \Lambda \Sigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

\Pi  \Upsilon  \Theta 
\Pi  \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma  `\Phi * \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma 

, \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma 
^ , \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma 

,\Omega  ,\Lambda  \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma 
\Sigma  , ,\Lambda  \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma 

\Pi  \Upsilon  \Theta  , \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma 

\Pi \Pi \Sigma  , \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma 

o/ \Upsilon  ffl\Sigma '\Pi \Sigma \Upsilon \Xi \Sigma  , \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma 
\Pi o/ ' ,\Sigma \Lambda  \Omega  \Pi , ' o/\Sigma \Lambda  \Upsilon  ffl\Sigma '\Pi ` fifl ` fifl ` \Sigma 

\Pi  \Upsilon  \Theta  o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma 

ffi\Pi \Sigma  o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma 

,\Omega  ,\Lambda  \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma  o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma 

\Omega , ,\Lambda ffffi o/ \Upsilon  ffl\Sigma '\Pi ^\Sigma 

,\Theta  \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi  fifl ` \Sigma  ,\Lambda  \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` fifl ` \Sigma 

,\Xi  \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` \Sigma  o/ \Upsilon  ffl\Sigma '\Pi \Theta \Lambda \Xi \Sigma 

\Upsilon \Lambda \Phi \Psi  ,\Theta  ,\Lambda  ,\Xi  o/ \Upsilon  ffl\Sigma '\Pi ` \Sigma 

(N.B. ^ ranges over the ground types ffiffl\Upsilon , \Sigma \Upsilon \Xi  and \Theta \Lambda \Xi .)

Figure 4. Normal forms , and neutral forms o/

Properties (13) and (14) correspond to the second two definingproperties, (5) and (6) respectively, of the semantic notion of namerestriction that we introduced in the previous section. (We notedthere that the first two defining properties (3) and (4) correspond to
\Theta -equivalence.)
Theorem 10 (normalization theorem). Each typeable expressionis convertible to a normal form, which is unique up to structural

congruence. More precisely, for each ` \Upsilon  flffifi there is a function
\Upsilon \Lambda \Lambda  \Lambda  \Omega fffi\Pi ` \Sigma  \Sigma  ffl\Lambda  \Pi ` \Sigma  satisfying:fl

' \Upsilon  \Omega fffi\Pi ` \Sigma \Sigma  ' ` \Upsilon \Lambda \Lambda  ' (15)fl
' \Upsilon  \Omega fffi\Pi ` \Sigma \Sigma fl, \Upsilon  ffl\Lambda  \Pi ` \Sigma \Sigma  ' ` , \Phi  \Upsilon \Lambda \Lambda  ' \Pi  , (16)

and hence also

fl'\Omega  '\Lambda  \Upsilon  \Omega fffi\Pi ` \Sigma \Sigma  ' ` '\Lambda  \Phi  \Upsilon \Lambda \Lambda  ' \Pi  \Upsilon \Lambda \Lambda  '\Lambda \Sigma  (17)
The proof of the theorem is sketched in the next section. It isa corollary of the proof that the normalization functions

\Upsilon \Lambda \Lambda  arecomputable. Since structural congruence \Pi  is evidently a decidable

relation, it follows that conversion is decidable too.

5. Normalization by Evaluation
We prove Theorem 10 using a version of "normalization by evalu-ation" (NbE). Since its introduction by Berger and Schwichtenberg

[4], NbE has been applied to a number of applied \Lambda -calculi, bothtyped and untyped, including ones encompassing G"odel's System T
[3, 8]. In each case the terms of the calculus are evaluated in a suit-able model that characteristically mixes syntax (variables, at least)
with semantics (extensional functions, usually). "Suitable model"means one for which a reification function (an "inverse of evalua^\Lambda  \Lambda  \Lambda ` \Xi  \Sigma  ffl\Lambda  \Pi ` \Sigma :

^\Phi  , \Theta  ,^
\Lambda \Upsilon \Phi \Lambda \Theta  \Upsilon  \Theta  \Lambda ff\Sigma  ^\Lambda \Theta  \Pi \Upsilon \Pi *\Lambda  ff\Sigma \Sigma 

where ff \Upsilon  \Lambda \Pi ` \Sigma  and ff \Psi  \Upsilon *

\Lambda  \Lambda  ffl\Sigma '\Pi ` \Sigma  \Sigma  \Lambda ` \Xi :*

\Phi  o/ \Theta  o/*
\Lambda \Upsilon \Phi \Lambda \Theta  o/ \Theta  \Lambda AE \Upsilon  \Lambda ` \Xi \Sigma  *\Lambda \Theta  \Pi o/ \Pi ^\Lambda  AE\Sigma \Sigma 

Figure 5. Reification ^\Lambda  and reflection *\Lambda 

tion") can be defined from the model back to the terms; composingreification with evaluation yields the normalization function. The
reification function usually involves the need to find syntactic vari-ables that are "fresh with respect to semantic objects". As explained
by Pitts [26, Sect. 6], the theory of nominal sets provides a conve-nient way of making sense of this kind of freshness and it is the way
we adopt here. However, this use of nominal sets in NbE is orthog-onal to the use we made of them in Section 2 to provide a standard
model of Nominal System T; and it should also be stressed thatthere are other ways of dealing with the kind of freshness required
by reification, or indeed of avoiding it in some circumstances: seeAbel et al. [1, Sect. 1].

The model in which we evaluate the expressions of NominalSystem T uses nominal sets based on permutations not just of
atomic names \Pi  \Upsilon  \Theta , but also of variables ff \Upsilon  \Lambda \Pi ` \Sigma  (for eachtype

` \Upsilon  flffifi). In other words we use the "many-atom-sorted"version of nominal sets described by Pitts [26, Sect. 3] with finite

permutations of \Theta  i \Lambda  that map atomic names to atomic namesand variables to variables, preserving their types. Letting such
permutations act on expressions in the obvious way, each \Omega fffi\Pi ` \Sigma is a nominal set with the support of

' \Upsilon  \Omega fffi\Pi ` \Sigma  being the finiteset of free atomic names and free variables of

'. Thus \Pi  \Psi  '(respectively
ff \Psi  ') holds if and only if \Pi  (respectively ff) does notoccur free in

'. The permutation action fi\Omega  ' \Omega \Sigma  fi ff ' preserves theproperty of being normal or neutral, so that

ffl\Lambda  \Pi ` \Sigma  and ffl\Sigma '\Pi ` \Sigma are nominal subsets of
\Omega fffi\Pi ` \Sigma . Using the nominal sets ffl\Lambda  \Pi ^\Sigma of normal forms at ground types

^ and taking finitely supportedfunctions (
\Phi  \Theta \Pi \Sigma  fl ) at higher types we get:

Definition 11 (interpretation of types). For each type ` \Upsilon  flffifiwe define a nominal set \Lambda 

` \Xi  as follows:\Lambda 

^\Xi  \Theta  ffl\Lambda  \Pi ^\Sigma  \Pi ^ \Xi  ffiffl\Upsilon \Omega  \Sigma \Upsilon \Xi \Omega  \Theta \Lambda \Xi \Sigma \Lambda 
` fifl ` \Lambda \Xi  \Theta  \Lambda ` \Xi  \Theta \Pi \Sigma  \Lambda ` \Lambda \Xi \Sigma  \Lambda 
Figure 5 defines equivariant functions of reification ^\Lambda  \Lambda  \Lambda ` \Xi  \Sigma 
ffl\Lambda  \Pi ` \Sigma  and reflection *\Lambda  \Lambda  ffl\Sigma '\Pi ` \Sigma  \Sigma  \Lambda ` \Xi  simultaneously by re-cursion on the structure of types

` \Upsilon  flffifi. As mentioned above,we take advantage of the nominal sets notion of freshness (

\Psi )in the clause for ^

\Lambda \Upsilon \Phi \Lambda \Theta : since \Upsilon  is finitely supported we can al-ways find an ff \Upsilon  \Lambda \Pi ` \Sigma  satisfying ff \Psi  \Upsilon  and the normal form

\Lambda ff\Sigma  ^\Lambda \Theta  \Pi \Upsilon \Pi *\Lambda  ff\Sigma \Sigma  is independent of which one we use. Apart fromthis use of nominal sets, the definitions of \Lambda 

` \Xi , ^\Lambda  and *\Lambda  are quitestandard, that is, they do not depend upon the new features that we

have added to the simply typed \Lambda -calculus. It is when we come tothe definition of evaluation, \Lambda 

'\Xi OE, whose properties are specified inFig. 6, that these new features have to be taken into account. The

figure makes use of some auxiliary functions, defined in Fig. 7,which in turn make use of ^

\Lambda  and *\Lambda  . (This was why we gave thedefinition of reification and reflection before defining evaluation.)

Evaluation takes place in the presence of environments of the fol-lowing kind.

\Lambda ff\Xi OE \Xi  OE\Pi ff\Sigma \Lambda 
\Lambda ff\Sigma  '\Xi OE \Xi  \Lambda AE \Upsilon  \Lambda ` \Xi \Sigma  \Lambda '\Xi \Pi OE\Upsilon ff\Xi \Pi AE\Phi \Sigma \Lambda 

' '\Lambda \Xi OE \Xi  \Lambda '\Xi OE \Pi \Lambda '\Lambda \Xi OE\Sigma \Lambda 

ae ss'\Xi OE \Xi  ae\Pi \Lambda ss'\Xi OE\Sigma  for ae \Xi  i\Omega  j\Omega  ^\Omega  \Sigma \Lambda 
\Pi \Pi \Sigma  '\Xi OE \Xi  \Pi \Pi \Sigma  \Pi \Lambda '\Xi OE\Sigma  if \Pi  \Psi  OE\Lambda 

\Pi \Xi OE \Xi  \Pi \Lambda 
ffi\Pi \Sigma  '\Xi OE \Xi  \Pi ffi\Pi \Sigma \Pi \Lambda '\Xi OE\Sigma  if \Pi  \Psi  OE\Lambda 
\Pi ' ' '\Lambda \Sigma \Lambda  \Xi OE \Xi  \Sigma ^\Lambda  \Pi \Lambda '\Xi OE\Omega  \Lambda '\Xi OE\Sigma \Lambda 
\Omega '\Theta  '\Lambda ffffi '\Xi OE \Xi  \Pi \Lambda '\Theta \Xi OE \Lambda '\Lambda \Xi OE\Sigma _ \Lambda '\Xi OE\Lambda 
`\Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi OE \Xi  \Upsilon *\Sigma _\Lambda  \Pi \Lambda '\Theta \Xi OE\Omega  \Lambda '\Lambda \Xi OE\Omega  \Lambda '\Xi OE\Sigma \Lambda 
\Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  '\Xi OE \Xi  \Xi *\Sigma _\Lambda  \Pi \Lambda '\Theta \Xi OE\Omega  \Lambda '\Lambda \Xi OE\Omega  \Lambda '\Xi \Xi OE\Omega  \Lambda '\Xi OE\Sigma 

Figure 6. Evaluation \Lambda '\Xi OE \Upsilon  \Lambda ` \Xi  \Upsilon ' \Upsilon  \Omega fffi\Pi ` \Sigma \Omega  OE \Upsilon  \Omega \Upsilon *\Phi 

Definition 12 (environments). The nominal set \Omega \Upsilon * \Theta  \Pi ` \Upsilon 
flffifi\Sigma  \Theta \Pi \Sigma  \Lambda \Pi ` \Sigma  \Theta \Pi \Sigma  \Lambda ` \Xi  of environments consists of all finitelysupported functions mapping, for each type

` \Upsilon  flffifi, variables
ff \Upsilon  \Lambda \Pi ` \Sigma  to elements OE\Pi ff\Sigma  \Upsilon  \Lambda ` \Xi . The initial environment
OE\Upsilon  \Upsilon  \Omega \Upsilon * is given by:

OE\Upsilon  ff \Theta  *\Lambda  ff \Upsilon ` \Upsilon  flffifi\Omega  ff \Upsilon  \Lambda \Pi ` \Sigma \Phi  (18)
(relying upon the fact that \Lambda \Pi ` \Sigma  fi ffl\Sigma '\Pi ` \Sigma ). If OE \Upsilon  \Omega \Upsilon * , ff \Upsilon \Lambda 

\Pi ` \Sigma  and AE \Upsilon  \Lambda ` \Xi , then OE\Upsilon ff\Xi \Pi AE\Phi  denotes the updated environmentmapping

ff to AE and otherwise acting like OE. \Lambda 

The fact that environments are finitely supported objects is usedin Fig. 6 in the clauses for

\Lambda -abstraction terms \Pi \Pi \Sigma  ' and name-restriction expressions
ffi\Pi \Sigma  '. Indeed, Fig. 6 constitutes a definitionof \Lambda 
'\Xi OE by \Theta -structural recursion [26] over expressions ', for allenvironments

OE simultaneously; and this requires the following"freshness conditions on binders" to be verified:

ff \Psi  \Lambda AE \Upsilon  \Lambda ` \Xi \Sigma  \Lambda '\Xi \Pi OE\Upsilon ff\Xi \Pi AE\Phi \Sigma  (19)

\Pi  \Psi  \Pi \Pi \Sigma  \Pi \Lambda '\Xi OE\Sigma  (20)
\Pi  \Psi  \Pi ffi\Pi \Sigma \Pi \Lambda '\Xi OE\Sigma \Sigma  (21)
The first follows from standard properties of the environmentalsemantics of

\Lambda -abstraction: see the discussion following equation(101) in Pitts [26]; property (20) is trivial, since

\Pi  is never freein
\Pi \Pi \Sigma  , for any , \Upsilon  ffl\Lambda  \Pi \Theta \Lambda \Xi \Sigma ; and property (21) can be provedby induction on the type of

'. Further applications of \Theta -structuralrecursion are needed in the definitions of

\Pi ffi\Pi \Sigma \Pi \Psi \Sigma , \Pi ,\Theta  ,\Lambda \Sigma _ \Psi and
\Xi *\Sigma _\Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Omega  \Psi \Sigma  in Fig. 7.The following lemma shows that for normal forms, reification

provides a left inverse for evaluation in the initial environment (18),modulo structural congruence; it is proved by induction on the
(height of the) derivations of , \Upsilon  ffl\Lambda  \Pi ` \Sigma  and o/ \Upsilon  ffl\Sigma '\Pi ` \Sigma  fromthe rules in Fig. 4.

Lemma 13. (i) fl, \Upsilon  ffl\Lambda  \Pi ` \Sigma \Sigma  ^\Lambda  \Pi \Lambda ,\Xi OE\Upsilon \Sigma  \Pi  ,.
(ii) flo/ \Upsilon  ffl\Sigma '\Pi ` \Sigma \Sigma  \Lambda o/\Xi OE\Upsilon  \Xi  *\Lambda  o/.

Definition 14 (normalization function). For each ` \Upsilon  flffifi wedefine

\Upsilon \Lambda \Lambda  \Lambda  \Omega fffi\Pi ` \Sigma  \Sigma  ffl\Lambda  \Pi ` \Sigma  to map ' \Upsilon  \Omega fffi\Pi ` \Sigma  to

\Upsilon \Lambda \Lambda  ' \Theta  ^\Lambda  \Pi \Lambda '\Xi OE\Upsilon \Sigma 
where OE\Upsilon  \Upsilon  \Omega \Upsilon * is the initial environment given in (18). \Lambda 

To prove that \Upsilon \Lambda \Lambda  has the desired properties (15) and (16) wecontinue to follow the standard pattern of a NbE proof and introduce a suitable logical relation between semantics and syntax.However, the presence of structural congruence \Pi  in Theorem 10

\Pi ffi\Pi \Sigma AE \Upsilon  \Lambda ` \Xi  \Upsilon ` \Upsilon  flffifi\Omega  \Pi  \Upsilon  \Theta \Omega  AE \Upsilon  \Lambda ` \Xi \Phi :

\Pi ffi\Pi \Sigma \Pi ae ss,\Sigma  \Theta  ae \Pi ffi\Pi \Sigma ss, where ae \Xi  i\Omega  j\Omega  ^\Omega  \Sigma 
\Pi ffi\Pi \Sigma \Pi \Pi \Pi \Lambda \Sigma  ,\Sigma  \Theta  \Pi \Pi \Lambda \Sigma  \Pi ffi\Pi \Sigma , if \Pi  '\Xi  \Pi \Lambda 

\Pi ffi\Pi \Sigma \Pi \Lambda  \Theta  \Pi `\Phi * if \Pi  \Xi  \Pi \Lambda \Pi \Lambda  if \Pi  '\Xi  \Pi \Lambda 
\Pi ffi\Pi \Sigma `\Phi * \Theta  `\Phi *

\Pi ffi\Pi \Sigma o/ \Theta  ffi\Pi \Sigma  o/
\Pi \Pi ffi\Pi \Sigma \Upsilon \Sigma  AE \Theta  \Pi ffi\Pi \Lambda \Sigma \Pi \Pi \Pi \Pi  \Pi \Lambda \Sigma  ff \Upsilon \Sigma  AE\Sigma  where \Pi \Lambda  \Psi  \Pi \Pi \Omega  \Upsilon \Omega  AE\Sigma 

\Sigma ^\Lambda  \Pi ,\Omega  ,\Lambda \Sigma  \Upsilon  \Lambda ` fifl ` fifl ` \Xi  \Upsilon ` \Upsilon  flffifi\Omega  ,\Omega  ,\Lambda  \Upsilon  \Lambda \Sigma \Upsilon \Xi \Xi \Phi :

\Sigma ^\Lambda  \Pi ,\Omega  ,\Lambda \Sigma  \Theta  \Pi \Lambda AE\Omega  AE\Lambda  \Upsilon  \Lambda ` \Xi \Sigma  AE if , \Xi  ,\Lambda  \Upsilon  \Theta  i \Theta `\Phi *\Xi \Lambda AE\Omega  AE\Lambda  \Upsilon  \Lambda ` \Xi \Sigma  AE\Lambda  if , '\Xi  ,\Lambda  \Upsilon  \Theta  i \Theta `\Phi *\Xi 

\Sigma ^\Lambda  \Pi o/\Omega  ,\Sigma  \Theta  *\Lambda \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda  \Pi o/ ' ,\Sigma \Lambda 
\Sigma ^\Lambda  \Pi ,\Omega  o/\Sigma  \Theta  *\Lambda \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda  \Pi , ' o/\Sigma \Lambda 

\Pi ,\Theta  ,\Lambda \Sigma _ AE \Upsilon  \Lambda ` \Xi  \Upsilon ` \Upsilon  flffifi\Omega  ,\Theta \Omega  ,\Lambda  \Upsilon  \Lambda \Sigma \Upsilon \Xi \Xi \Omega  AE \Upsilon  \Lambda ` \Xi \Phi :

\Pi ,\Theta  ,\Lambda \Sigma _ \Pi ae ss,\Sigma  \Theta  ae \Pi ,\Theta  ,\Lambda \Sigma _ ss, where ae \Xi  i\Omega  j\Omega  ^\Omega  \Sigma 
\Pi ,\Theta  ,\Lambda \Sigma _ \Pi \Pi \Sigma  , \Theta  \Pi \Pi \Sigma  \Pi ,\Theta  ,\Lambda \Sigma _ , if \Pi  \Psi  \Pi ,\Theta \Omega  ,\Lambda \Sigma 

\Pi ,\Theta  ,\Lambda \Sigma _ \Pi  \Theta  \Sigma ^\Pi ,\Theta \Omega  \Pi \Sigma \Theta \Lambda \Xi  ,\Lambda  \Pi \Sigma ^\Pi ,\Lambda \Omega  \Pi \Sigma \Theta \Lambda \Xi  ,\Theta  \Pi \Sigma 
\Pi ,\Theta  ,\Lambda \Sigma _ `\Phi * \Theta  `\Phi *

\Pi ,\Theta  ,\Lambda \Sigma _ o/ \Theta  \Omega ,\Theta  ,\Lambda ffffi o/
\Pi ,\Theta  ,\Lambda \Sigma _ \Upsilon  \Theta  \Lambda AE \Upsilon  \Lambda ` \Xi \Sigma  \Pi ,\Theta  ,\Lambda \Sigma _ \Pi \Upsilon \Pi \Pi ,\Theta  ,\Lambda \Sigma _ AE\Sigma \Sigma 

\Upsilon *\Sigma _\Lambda  \Pi AE\Omega  \Upsilon \Omega  ,\Sigma  \Upsilon  \Lambda ` \Xi  \Upsilon ` \Upsilon  flffifi\Omega  AE \Upsilon  \Lambda ` \Xi \Omega  \Upsilon  \Upsilon  \Lambda ffiffl\Upsilon  fifl ` fifl
` \Xi \Omega  , \Upsilon  \Lambda ffiffl\Upsilon \Xi \Phi is defined by primitive recursion and a direct definition on neutral

forms:

\Upsilon *\Sigma _\Lambda  \Pi AE\Omega  \Upsilon \Omega  i\Sigma  \Xi  AE
\Upsilon *\Sigma _\Lambda  \Pi AE\Omega  \Upsilon \Omega  j ,\Sigma  \Xi  \Upsilon  , \Pi \Upsilon *\Sigma _\Lambda  \Pi AE\Omega  \Upsilon \Omega  ,\Sigma \Sigma 

\Upsilon *\Sigma _\Lambda  \Pi AE\Omega  \Upsilon \Omega  o/\Sigma  \Xi  *\Lambda  \Pi `\Lambda \Phi \Psi \Pi ^\Lambda  AE\Sigma \Pi ^\Psi \Omega \Lambda \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda  \Upsilon \Sigma  o/\Sigma 

\Xi *\Sigma _\Lambda  \Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Omega  ,\Sigma  \Upsilon  \Lambda ` \Xi  \Upsilon ` \Upsilon  flffifi\Omega  \Upsilon \Theta  \Upsilon  \Lambda \Sigma \Upsilon \Xi  fifl ` \Xi \Omega  \Upsilon \Lambda  \Upsilon \Lambda 

\Theta \Lambda \Xi fifl\Theta \Lambda \Xi fifl` fifl` fifl` \Xi \Omega  \Upsilon \Xi  \Upsilon  \Lambda \Sigma \Upsilon \Xi fifl\Theta \Lambda \Xi fifl` fifl` \Xi \Omega  , \Upsilon  \Lambda \Theta \Lambda \Xi \Xi \Phi is defined by

\Theta -structural recursion and a direct definition on neu-tral forms:

\Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  ^ ,\Sigma  \Xi  \Upsilon \Theta  ,
\Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  \Sigma  , ,\Lambda \Sigma  \Xi  \Upsilon \Lambda  , ,\Lambda  \Pi \Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  ,\Sigma \Sigma  \Pi \Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  ,\Lambda \Sigma \Sigma 
\Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  \Pi \Pi \Sigma  ,\Sigma \Sigma  \Xi  \Pi ffi\Pi \Sigma \Pi \Upsilon \Xi  \Pi  , \Pi \Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  ,\Sigma \Sigma \Sigma  if \Pi  \Psi  \Pi  ss\Upsilon \Sigma 

\Xi *\Sigma _\Lambda  \Pi  ss\Upsilon \Omega  o/\Sigma  \Xi  *\Lambda  \Pi \Upsilon \Lambda \Phi \Psi \Pi ^\Theta \Lambda \Xi \Upsilon \Phi \Pi \Sigma \Xi  \Upsilon \Theta \Sigma \Pi ^\Pi \Sigma \Xi \Upsilon \Phi \Pi \Sigma \Xi \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda  \Upsilon \Lambda \Sigma 

\Pi ^\Theta \Lambda \Xi \Upsilon \Phi \Pi \Sigma \Xi \Upsilon \Phi \Lambda \Upsilon \Phi \Lambda  \Upsilon \Xi \Sigma  o/\Sigma 

Figure 7. Auxiliary functions used in Fig. 6

complicates matters. We could have dealt with it by quotientingout in the model and using

ffl\Lambda  \Pi ^\Sigma \Psi \Pi  at ground types and finitelysupported functions over those nominal sets at higher types. However, with an eye to formalizations of the proof of normalizationin system such as Coq [

\Psi O/!o/`\Lambda o/ffl!*\Lambda ] or Agda [*o/"o/!#O/\Lambda \Upsilon ffl,!
\Psi $ffl,\Xi \Phi \Lambda ss!ss\Phi %ffl&'ffl], we prefer the more intensional model wehave given. As a result we use the following ternary logical relation, rather than a binary one.
Definition 15 (logical relation). The nominal subsets *\Lambda  fi\Lambda 

` \Xi  ffl \Lambda ` \Xi  ffl \Omega fffi\Pi ` \Sigma  are defined by recursion on the structureof

` \Upsilon  flffifi:

\Pi ,\Theta \Omega  ,\Lambda \Omega  '\Sigma  \Upsilon  *\Phi  , ,\Theta  \Pi  ,\Lambda  ` '

\Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  '\Sigma  \Upsilon  *\Lambda \Theta \Upsilon \Phi \Lambda  ,fl

\Pi AE\Theta \Omega  AE\Lambda \Omega  '\Lambda \Sigma  \Upsilon  *\Lambda \Theta  \Sigma  \Pi \Upsilon \Theta  AE\Theta \Omega  \Upsilon \Lambda  AE\Lambda \Omega  ' '\Lambda \Sigma  \Upsilon  *\Lambda  \Sigma 

\Lambda 
Lemma 16. (i) fl\Pi AE\Theta \Omega  AE\Lambda \Omega  '\Sigma  \Upsilon  *\Lambda  \Sigma  ^\Lambda  AE\Theta  \Pi  ^\Lambda  AE\Lambda  ` '.
(ii) flo/\Theta \Omega  o/\Lambda  \Upsilon  ffl\Sigma '\Pi ` \Sigma \Omega  ' \Upsilon  \Omega fffi\Pi ` \Sigma \Sigma  o/\Theta  \Pi  o/\Lambda  ` ' \Phi 

\Pi *\Lambda  o/\Theta \Omega  *\Lambda  o/\Lambda \Omega  '\Sigma  \Upsilon  *\Lambda  \Sigma 

Proof. Both properties are proved simultaneously by induction onthe structure of

` , using the easily verified fact that if \Pi AE\Theta \Omega  AE\Lambda \Omega  '\Sigma  \Upsilon *

\Lambda  and ' ` '\Lambda , then \Pi AE\Theta \Omega  AE\Lambda \Omega  '\Lambda \Sigma  \Upsilon  *\Lambda  .

Although we do not give the details in this extended abstract,one can prove the following properties of *.

\Pi  "Fundamental property" for the logical relation: * is respectedby all the syntactical constructions of Nominal System T.
\Pi  \Pi \Lambda '\Xi OE\Upsilon \Omega  \Lambda '\Lambda \Xi OE\Upsilon \Omega  '\Lambda \Sigma  \Upsilon  *\Lambda  holds for each pair of convertibleexpressions

' and '\Lambda  in Fig. 3 (` being the type of ' and '\Lambda ).\Pi  \Theta 

\Pi AE\Theta \Omega  AE\Lambda \Sigma  \Lambda  \Pi AE\Theta \Omega  AE\Lambda \Omega  '\Sigma  \Upsilon  *\Lambda  \Xi  is a partial equivalence relationon \Lambda 

` \Xi  (for each ' \Upsilon  \Omega fffi\Pi ` \Sigma ).

From these properties it follows that:fl

'\Omega  '\Lambda  \Upsilon  \Omega fffi\Pi ` \Sigma \Sigma  ' ` '\Lambda  \Phi  \Pi \Lambda '\Xi OE\Upsilon \Omega  \Lambda '\Lambda \Xi OE\Upsilon \Omega  '\Lambda \Sigma  \Upsilon  *\Lambda  \Sigma  (22)
This allows us to complete the proof of the normalization theorem:

Proof of Theorem 10. If ' \Upsilon  \Omega fffi\Pi ` \Sigma , then by (22) and reflexivityof `, we have

\Pi \Lambda '\Xi OE\Upsilon \Omega  \Lambda '\Xi OE\Upsilon \Omega  '\Sigma  \Upsilon  *\Lambda  ; and hence by Lemma 16(i),
\Upsilon \Lambda \Lambda  ' \Theta  ^\Lambda  \Pi \Lambda '\Xi OE\Upsilon \Sigma  ` ', which is property (15). If ' ` , \Upsilon 
ffl\Lambda  \Pi ` \Sigma , then by (22) again we have \Pi \Lambda '\Xi OE\Upsilon \Omega  \Lambda ,\Xi OE\Upsilon \Omega  ,\Sigma  \Upsilon  *\Lambda 
and hence by Lemmas 13(i) and 16(i), \Upsilon \Lambda \Lambda  ' \Theta  ^\Lambda  \Pi \Lambda '\Xi OE\Upsilon \Sigma  \Pi ^

\Lambda  \Pi \Lambda ,\Xi OE\Upsilon \Sigma  \Pi  ,, which is property (16).

It should be evident from the definitions in Figs 5-7 that \Upsilon \Lambda \Lambda is computable. A prototype implementation using Fresh Objective

Caml [31] is available from the author's web pages. The facili-ties that language provides for computing with binders allows the
implementation to stick quite closely to the definitions in the fig-ures, except that the dependently typed family \Lambda 

` \Xi  \Upsilon ` \Upsilon  flffifi\Phi has to be implemented by a single, reflexive data type. A language

with dependent types, such as Agda [*o/"o/!#O/\Lambda \Upsilon ffl,!\Psi $ffl,\Xi \Phi \Lambda ss!
ss\Phi %ffl&'ffl] or Coq [\Psi O/!o/`\Lambda o/ffl!*\Lambda ], would allow an even closerfit--were those languages to have the "nominal" features of Fresh

Objective Caml, or better, of Nominal System T itself. As it is,for Agda or Coq implementations, the definitions in the figures
would have to be adapted to deal with our informal treatment of \Theta -conversion in the syntax of Nominal System T, for example by using well-scoped de Bruijn indexes. It would be nice to have "nom-inal" versions of these dependently typed systems that provide the
kind of facilities for computing with name-abstraction and name-restriction that we are considering here and which would make possible a more or less direct encoding of the definitions in Figs 5-7.

6. Representational Adequacy
In this section we will show that functions defined by the \Theta -structural recursion principle for

\Theta  described in the Introductioncan be faithfully represented in Nominal System T. To do so, we

restrict attention to closed expressions, by which we mean oneswith no free variables.

Definition 17 (closed expressions and normal forms). For each
` \Upsilon  flffifi, let ,\Sigma fffi\Pi ` \Sigma  denote the subset of \Omega fffi\Pi ` \Sigma  consistingof well-typed expressions of type

` that have no free variables;and let
,\Upsilon \Lambda  \Pi ` \Sigma  denote the subset of normal forms with no freevariables. \Lambda 

Closed expressions may still have free atomic names, the lat-ter being normal forms representing object-level free variables. For
example, if \Pi  '\Xi  \Pi \Lambda  are distinct atomic names, then \Pi \Pi \Sigma  ^ \Pi \Lambda  \Upsilon 
,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma  is a closed normal form representing the open \Lambda -term
\Lambda \Pi \Sigma  \Pi \Lambda  \Upsilon  \Theta . More generally, every open \Lambda -term is faithfully repre-sented in

,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma . To see this, note that it follows from the rulesof formation in Fig. 4 and Definition 9 that neutral forms always

contain at least one free variable; and hence:

\Pi  ,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma  is in bijection with the set \Theta \Upsilon ffl\Sigma i \Phi  defined in (7),that is, the

\Lambda -terms (modulo \Theta -equivalence, of course) over aconstant
ffl\Sigma i ; ,\Upsilon \Lambda  \Pi \Theta \Sigma  is in bijection with \Theta  i \Theta ffl\Sigma i \Xi ; and
,\Upsilon \Lambda  \Pi ffiffl\Upsilon \Sigma  is in bijection with \Xi .\Pi 

Structural congruence at ground types (ffiffl\Upsilon , \Sigma \Upsilon \Xi , \Theta \Lambda \Xi ) is theidentity relation.

So we get a simple form of "representational adequacy" [22] resultfor the object language

\Theta  (defined in (1)) within Nominal SystemT: the map \Xi \Psi \Pi 
\Lambda  \Theta  \Sigma  ,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma  satisfying

\Xi \Pi \Pi  \Xi  ^ \Pi \Xi 
\Xi  \Xi \Lambda \Pi  \Xi  \Sigma  \Xi \Xi \Pi  \Xi \Xi \Lambda \Pi \Xi 
\Lambda \Pi \Sigma  \Xi \Pi  \Xi  \Pi \Pi \Sigma  \Xi \Xi \Pi  \Theta \Lambda \Xi  (23)

(well-defined by \Theta -structural recursion for \Theta !) gives a bijection be-tween

\Theta  and the subset of ,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma  of closed normal forms not in-volving

`\Phi * (and hence not involving any use of name-restriction).The fact that the representation (23) is so trivial is good; the "coding gap" between object- and meta-language is very small--we justhave to take care with the extra normal form

`\Phi * when manipulat-ing the object-language from within Nominal System T.

Turning next to the representation in Nominal System T offunctions on

\Theta , first note that normalization preserves the propertyof being closed. For it is easy to see from the form of its definition

that the normalization function is equivariant; that is, if we permutethe atomic names and variables of an expression, the atomic names
and variables of its normal form are correspondingly permuted:

\Upsilon \Lambda \Lambda  \Pi fi ff '\Sigma  \Xi  fi ff \Pi \Upsilon \Lambda \Lambda  '\Sigma \Sigma  (24)
So like all equivariant functions, \Upsilon \Lambda \Lambda  \Lambda  \Omega fffi\Pi ` \Sigma  \Sigma  ffl\Lambda  \Pi ` \Sigma  has theproperty that the support of

\Upsilon \Lambda \Lambda  ' is contained in the support of '.Thus we have:

Lemma 18. For each well-typed expression ' \Upsilon  \Omega fffi\Pi ` \Sigma , thefree variables and free atomic names of its normal form

\Upsilon \Lambda \Lambda  ' arecontained in those of
'. In particular \Upsilon \Lambda \Lambda  restricts to an equivariantfunction
\Upsilon \Lambda \Lambda  \Lambda  ,\Sigma fffi\Pi ` \Sigma  \Sigma  ,\Upsilon \Lambda  \Pi ` \Sigma .

Lemma 19. (i) If ^ is a ground type, ' \Upsilon  ,\Sigma fffi\Pi ^\Sigma  and \Pi \Omega  \Pi \Lambda  \Upsilon \Theta , then

\Omega \Pi  \Pi \Lambda ffffi ' ` \Pi \Pi  \Pi \Lambda \Sigma  ff ', the result of swapping \Pi  and \Pi \Lambda in
'.

(ii) If ' \Upsilon  ,\Sigma fffi\Pi \Theta \Lambda \Xi \Sigma  and \Pi  \Upsilon  \Theta , then \Pi \Pi \Sigma  ' ` \Pi \Pi \Pi \Omega  '\Sigma , as definedat the bottom of Fig. 1.

Definition 20 (representable functions). Given ` \Upsilon  flffifi, let
\Phi  denote the quotient nominal set ,\Sigma fffi\Pi ` \Sigma \Psi \Pi  of closed normal

forms of type ` modulo structural congruence. (We write \Upsilon ,\Phi  forthe equivalence class of

, \Upsilon  ,\Upsilon \Lambda  \Pi ` \Sigma .) Suppose that the functions
\Upsilon \Theta  \Upsilon  \Theta  \Theta \Pi \Sigma  \Phi , \Upsilon \Lambda  \Upsilon  \Theta  \Theta \Pi \Sigma  \Theta  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi  and \Upsilon \Xi  \Upsilon \Theta  \Theta 

\Pi \Sigma  \Theta  \Theta \Pi \Sigma  \Phi  \Theta \Pi \Sigma  \Phi  are supported by the finite subset \Pi  fi \Theta .We say that \Pi \Upsilon 

\Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Sigma  is representable by the closed expressions'
\Theta  \Upsilon  ,\Sigma fffi\Pi \Sigma \Upsilon \Xi  fifl ` \Sigma , '\Lambda  \Upsilon  ,\Sigma fffi\Pi \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` fifl ` \Sigma and '

\Xi  \Upsilon  ,\Sigma fffi\Pi \Sigma \Upsilon \Xi  fifl \Theta \Lambda \Xi  fifl ` fifl ` \Sigma  if the free atomic names of\Pi '
\Theta \Omega  '\Lambda \Omega  '\Xi \Sigma  are in \Pi  and

\Upsilon \Theta  \Pi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Theta  \Pi \Sigma \Phi  (25)
\Upsilon \Lambda  \Xi  \Xi \Lambda  \Upsilon ,\Phi  \Upsilon ,\Lambda \Phi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Lambda  \Xi \Xi \Pi  \Xi \Xi \Lambda \Pi  , ,\Lambda \Sigma \Phi  (26)
\Pi  \Psi \Upsilon  \Pi  \Phi  \Upsilon \Xi  \Pi  \Xi  \Upsilon ,\Phi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi  ,\Sigma \Phi  (27)

for all \Pi  \Upsilon  \Theta , \Xi \Omega  \Xi \Lambda  \Upsilon  \Theta  and ,\Omega  ,\Lambda  \Upsilon  ,\Upsilon \Lambda  \Pi \Theta \Lambda \Xi \Sigma . (The right-handsides of these equations are in

\Phi  because of Lemma 18.) \Lambda 

Recalling the "freshness condition on binders" (FCB) from theIntroduction, we have:

Theorem 21 (representation of \Theta -structural recursion). Let
\Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Sigma  be as in the above definition and suppose \Upsilon \Xi  satis-fies (FCB). Let

\Upsilon  \Upsilon  \Theta  \Theta \Pi \Sigma  \Phi  be the function defined from thesefunctions by
\Theta -structural recursion, that is, the unique functionsatisfying (2). If

\Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Sigma  is representable by \Pi '\Theta \Omega  '\Lambda \Omega  '\Xi \Sigma , then \Upsilon is represented by

' \Theta  \Lambda ff\Sigma  \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  ff \Upsilon  ,\Sigma fffi\Pi \Theta \Lambda \Xi  fifl ` \Sigma  (28)
in the sense that for all \Xi  \Upsilon  \Theta 

\Upsilon  \Xi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Xi \Xi \Pi \Sigma \Phi \Sigma  (29)

Proof. By the uniqueness part of \Theta -structural recursion, to prove(29) it suffices to show that

\Lambda \Xi  \Upsilon  \Theta \Sigma  \Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Xi \Xi \Pi \Sigma \Phi  satisfies therecursion scheme (2) that defines

\Upsilon . For first clause in (2) we have
'\Pi ^ \Pi \Sigma  ` \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi \Pi ^ \Pi \Sigma  ` '\Theta  \Pi  by (28), \Pi j\Sigma  and \Pi ffl^\Sigma ; henceby (23), (17) and (25),

\Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Xi \Pi \Pi \Sigma \Phi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Pi ^ \Pi \Sigma \Sigma \Phi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Theta  \Pi \Sigma \Phi  \Xi  \Upsilon \Theta \Pi \Pi \Sigma 
as required. The argument for the second clause in (2) is similar.For the third clause, if

\Pi  \Psi \Upsilon  \Pi  then for any \Xi  \Upsilon  \Theta 

\Pi  \Psi  \Upsilon \Xi  \Pi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Xi \Xi \Pi \Sigma \Phi  by (FCB)

\Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi  \Pi \Upsilon \Lambda \Lambda  \Pi ' \Xi \Xi \Pi \Sigma \Sigma \Sigma \Phi  by (27)
\Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma \Phi  by (15) and (17).

Structurally congruent normal forms have equal sets of free atomicnames; and hence the support of an equivalence class

\Upsilon ,\Phi  \Upsilon  \Phi  isthe same as the support of any of its representatives
,. Thereforewe have
\Pi  \Psi  \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma  and so by \Pi ffi\Psi \Sigma 

\Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma  ` ffi\Pi \Sigma  \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma \Sigma  (30)
Therefore

' \Pi \Pi \Pi \Sigma  \Xi \Xi \Pi \Sigma `

\Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  \Pi \Pi \Pi \Sigma  \Xi \Xi \Pi \Sigma  by (28) and \Pi j\Sigma `
ffi\Pi \Sigma  '\Xi  \Pi  \Xi \Xi \Pi  \Pi \Upsilon \Lambda \Phi \Psi  '\Theta  '\Lambda  '\Xi  \Xi \Xi \Pi \Sigma  by \Pi ffl\Pi \Sigma ,

since \Pi  \Psi  \Pi '\Theta \Omega  '\Lambda \Omega  '\Xi \Sigma `
ffi\Pi \Sigma  '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma  by (28) and \Pi j\Sigma `
ffi\Pi \Sigma  \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma  by (15)`
\Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma  by (30).

Hence by (16) and from above we have

\Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Pi \Pi \Pi \Sigma  \Xi \Xi \Pi \Sigma \Sigma \Phi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi '\Xi  \Pi  \Xi \Xi \Pi \Pi ' \Xi \Xi \Pi \Sigma \Sigma \Phi  \Xi  \Upsilon \Xi  \Pi  \Xi  \Upsilon \Upsilon \Lambda \Lambda  \Pi ' \Xi \Xi \Pi \Sigma \Phi 
as required.

Example 2, continued. Let us use Theorem 21 to prove thatthe expression

ss_( defined in Example 4 does indeed representcapture-avoiding substitution on

\Lambda -terms, in the sense that

ss_( \Pi \Lambda  \Xi \Xi \Lambda \Pi  \Xi \Xi \Pi  ` \Xi \Xi \Upsilon \Xi \Lambda \Psi \Pi \Lambda \Phi \Pi  (31)
holds for all \Pi \Lambda  \Upsilon  \Theta  and \Xi \Omega  \Xi \Lambda  \Upsilon  \Theta . Fixing \Pi \Lambda  and \Xi \Lambda , in the theoremtake

` \Xi  \Theta \Lambda \Xi  and the functions \Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Sigma  to be

\Upsilon \Theta  \Pi  \Theta  \Theta \Lambda  \Pi  \Xi  \Pi \Lambda  \Xi \Pi \Sigma \Upsilon  \Upsilon \Xi \Xi \Lambda \Pi \Phi  \Sigma \Phi \Psi \Sigma  \Upsilon \Xi \Pi \Pi \Phi 
\Upsilon \Lambda  \Xi \Theta  \Xi \Lambda  \Upsilon ,\Theta \Phi  \Upsilon ,\Lambda \Phi  \Theta  \Upsilon \Sigma  ,\Theta  ,\Lambda \Phi 

\Upsilon \Xi  \Pi  \Xi \Theta  \Upsilon ,\Theta \Phi  \Theta  \Upsilon \Pi \Pi \Sigma  ,\Theta \Phi \Sigma 

They are supported by the finite set \Pi  consisting of \Pi \Lambda  and the freeatomic names of

\Xi \Lambda ; and \Upsilon \Xi  satisfies (FCB). Let \Upsilon  by the functiondefined from them by

\Theta -structural recursion. An easy proof by \Theta -structural induction [26] shows that for all

\Xi  \Upsilon  \Theta 

\Upsilon  \Xi  \Xi  \Upsilon \Xi \Xi \Upsilon \Xi \Lambda \Psi \Pi \Lambda \Phi \Pi \Phi \Sigma  (32)
It is not hard to see that \Pi \Upsilon \Theta \Omega  \Upsilon \Lambda \Omega  \Upsilon \Xi \Sigma  is representable (in the senseof Definition 20) by

\Pi '\Theta \Upsilon \Pi \Lambda \Psi ff\Omega  \Xi \Xi \Lambda \Pi \Psi ae\Phi \Omega  '\Lambda \Omega  '\Xi \Sigma , where '\Theta , '\Lambda  and '\Xi are as in Example 4 (using Lemma 19(ii) to verify (27) for this particular '\Xi ). So by definition of ss_( and by the theorem we have
\Upsilon  \Xi  \Xi  \Upsilon \Upsilon \Lambda \Pi \Sigma \Xi \Pi ss_( \Pi \Lambda  \Xi \Xi \Lambda \Pi  \Xi \Xi \Pi \Sigma \Phi . Combining this with (32) yields
\Upsilon \Xi \Xi \Upsilon \Xi \Lambda \Psi \Pi \Lambda \Phi \Pi \Phi  \Xi  \Upsilon \Upsilon \Lambda \Pi \Sigma \Xi \Pi ss_( \Pi \Lambda  \Xi \Xi \Lambda \Pi  \Xi \Xi \Pi \Sigma \Phi ; and so by the Normaliza-tion Theorem 10 we do indeed have (31).

Example 3, continued. The bijection \Xi \Psi \Pi  \Lambda  \Xi  ss\Xi  ,\Upsilon \Lambda  \Pi ffiffl\Upsilon \Sigma between natural numbers

* and closed normal forms of type ffiffl\Upsilon is given by

\Xi \Omega \Pi  \Xi  i\Xi 
* fl ff\Pi  \Xi  j \Xi *\Pi \Sigma  \Sigma  (33)

As in the previous example, one can apply Theorem 21 to thedefinitions in Example 5 to show that

,\Phi ` \Xi \Xi \Pi  ` \Xi \Lambda \Xi \Lambda \Pi  (34)
holds for all \Xi  \Upsilon  \Theta . Thus the expression ,\Phi ` does indeed correctlyrepresent the length function \Lambda \Psi \Lambda  on

\Lambda -terms.

7. Atom-Abstraction Types
Pitts [26] develops the \Theta -structural recursion principle for a wideclass of languages involving binding operations, namely those that

can be specified via a nominal signature [36, Definition 2.1]. Inthis paper so far, for sake of simplicity we have restricted attention
to a single such language, the untyped \Lambda -calculus, \Theta . To extendTheorem 21 to the full range of "nominal data types", one first
needs to extend Nominal System T with syntax for product typesand atom-abstraction types. The latter correspond to the atomabstraction construction on nominal sets of Gabbay and Pitts [11,Sect. 5]. This sends a nominal set

\Phi  to the quotient nominalset
\Upsilon \Theta \Phi \Phi  \Theta  \Pi \Theta  ffl \Phi \Sigma \Psi ss, where ss captures the essence of \Theta -equivalence:

\Pi \Pi \Omega  ff\Sigma  ss \Pi \Pi \Lambda \Omega  ff\Lambda \Sigma  , \Pi \Pi  \Pi \Lambda \Lambda \Sigma  ff ff \Xi  \Pi \Pi \Lambda  \Pi \Lambda \Lambda \Sigma  ff ff\Lambda for some (indeed, any)

\Pi \Lambda \Lambda  such that \Pi \Lambda \Lambda  \Psi  \Pi \Pi \Omega  ff\Omega  \Pi \Lambda \Omega  ff\Lambda \Sigma . We writethe equivalence class of

\Pi \Pi \Omega  ff\Sigma  in \Upsilon \Theta \Phi \Phi  as ae\Pi oeff.Ever since the introduction of this construct it has been known

that the elements of \Upsilon \Theta \Phi \Phi  have a dual nature. On one hand theyare "abstractions-as-pairs", with the identity of the atomic name

\Pi in the pair
\Pi \Pi \Omega  ff\Sigma  anonymized via permutations when we pass tothe equivalence class ae

\Pi oeff. On the other hand they also represent"abstractions-as-partial-functions", since

\Upsilon \Theta \Phi \Phi  is isomorphic to thenominal set of those partial functions
\Upsilon  from \Theta  to \Phi  whose domainof definition is \Theta 
\Pi  \Lambda  \Pi  \Psi  \Upsilon \Xi . This bijection is mediated by thepartial operation of concretion; if

\Pi  \Psi  O/ \Upsilon  \Upsilon \Theta \Phi \Phi , there is a uniqueelement
O/ \Phi  \Pi  \Upsilon  \Phi  satisfying O/ \Xi  ae\Pi oe\Pi O/ \Phi  \Pi \Sigma  and called the

\Pi  A new type-former )\Sigma \Upsilon \Xi *` for atom-abstraction types.
\Pi  New forms of expression \Theta \Pi \Sigma  ' and ' + '\Lambda , where \Theta \Pi \Sigma  \Pi \Psi \Sigma  is abinder (like

\Pi \Pi \Sigma  \Pi \Psi \Sigma ) and the typing rules are:

\Pi  \Upsilon  \Theta 
' \Upsilon  \Omega fffi\Pi ` \Sigma 

\Theta \Pi \Sigma  ' \Upsilon  \Omega fffi\Pi )\Sigma \Upsilon \Xi *` \Sigma 

' \Upsilon  \Omega fffi\Pi )\Sigma \Upsilon \Xi *` \Sigma 

'\Lambda  \Upsilon  \Omega fffi\Pi \Sigma \Upsilon \Xi \Sigma 

' + '\Lambda  \Upsilon  \Omega fffi\Pi ` \Sigma 

\Pi  New conversions:

\Pi \Theta \Pi \Sigma  '\Sigma  + '\Lambda  ` ffi\Pi \Sigma  \Omega \Pi  '\Lambda ffffi ' if \Pi  \Psi  '\Lambda  \Pi \Theta j\Sigma 

' ` \Theta \Pi \Sigma  \Pi ' + \Pi \Sigma  if \Pi  \Psi  ' \Pi \Theta i\Sigma 
ffi\Pi \Sigma  \Theta \Pi \Lambda \Sigma  ' ` \Theta \Pi \Lambda \Sigma  ffi\Pi \Sigma  ' if \Pi  '\Xi  \Pi \Lambda  \Pi ffi\Theta \Sigma 
\Omega '\Theta  '\Lambda ffffi \Theta \Pi \Sigma  ' ` \Theta \Pi \Sigma  \Omega '\Theta  '\Lambda ffffi ' if \Pi  \Psi  \Pi '\Theta \Omega  '\Lambda \Sigma  \Pi fi\Theta \Sigma 

\Pi  New normal and neutral forms:

\Pi  \Upsilon  \Theta 
, \Upsilon  ffl\Lambda  \Pi ` \Sigma 

\Theta \Pi \Sigma  , \Upsilon  ffl\Lambda  \Pi )\Sigma \Upsilon \Xi *` \Sigma 

o/ \Upsilon  ffl\Sigma '\Pi )\Sigma \Upsilon \Xi *` \Sigma 

, \Upsilon  ffl\Lambda  \Pi \Sigma \Upsilon \Xi \Sigma 

o/ + , \Upsilon  ffl\Sigma '\Pi ` \Sigma 

Figure 8. Extension with atom-abstraction

concretion of O/ at \Pi :

\Pi ae\Pi \Lambda oeff\Sigma  \Phi  \Pi  \Theta  \Upsilon \Phi \Psi \Phi \Omega 

ff if \Pi  \Xi  \Pi \Lambda 
\Pi \Pi \Lambda  \Pi \Sigma  ff ff if \Pi  '\Xi  \Pi \Lambda  and \Pi  \Psi  ff
undefined otherwise.

(35)

The undefinedness in the third clause is forced by the necessity ofmaking the right-hand side independent of the choice of representative \Pi \Pi \Lambda \Omega  ff\Sigma  for the equivalence class ae\Pi \Lambda oeff. The fact that concretionis a partial operation creates the same problem as does the freshness
condition on binders (FCB) for \Theta -structural recursion; calculatingwith concretions involves proving freshness conditions (

\Pi  \Psi  O/).We have seen that name-restriction operations (Definition 1) provide a simple solution for the "FCB problem". They also provideone for the "concretion problem", as the following result shows.

Theorem 22 (atom-abstractions as total functions). If * is anominal set equipped with a name-restriction operation

ffi\Xi , thenthere is a name-restriction operation
ffi on the nominal set \Upsilon \Theta \Phi * ofatom-abstractions satisfying

\Pi  '\Xi  \Pi \Lambda  \Phi  \Pi ffi\Pi \Sigma \Pi ae\Pi \Lambda oe_\Sigma  \Xi  ae\Pi \Lambda oe\Pi \Pi ffi\Xi \Pi \Sigma _\Sigma  (36)
for all \Pi \Omega  \Pi \Lambda  \Upsilon  \Theta  and _ \Upsilon  *. In this case there are equivariantfunctions preserving name restriction

\Upsilon \Theta \Phi *

\Psi \Sigma  \Pi \Theta  \Theta 

\Pi \Sigma  *\Sigma 

\Upsilon \Upsilon  \Upsilon \Theta \Phi *

whose composition is the identity on \Upsilon \Theta \Phi *. Furthermore, the partialoperation of concretion extends to a total function

\Pi \Psi \Sigma  \Phi  \Pi \Psi \Sigma  \Lambda 
\Upsilon \Theta \Phi * ffl \Theta  \Sigma  * that corresponds to function application under theinclusion

 \Lambda  \Upsilon \Theta \Phi * \Sigma  \Pi \Theta  \Theta \Pi \Sigma  *\Sigma .

The proof of this result, which we omit in this extended abstract,shows that the extended concretion function

\Pi \Psi \Sigma  \Phi  \Pi \Psi \Sigma  \Lambda  \Upsilon \Theta \Phi * ffl\Theta  \Sigma 
* satisfies

\Pi ae\Pi \Lambda oe_\Sigma  \Phi  \Pi  \Xi  \Pi _ if \Pi  \Xi  \Pi \Lambda \Pi ffi\Pi \Lambda \Sigma \Pi \Pi \Pi \Lambda  \Pi \Sigma  ff _\Sigma  if \Pi  '\Xi  \Pi \Lambda . (37)
This suggests extending Nominal System T as in Fig. 8. The newform of

j-conversion for atom-abstraction, \Pi \Theta j\Sigma , is particularlypleasing, since it combines in one equation all the main players:

atom-abstraction \Theta \Pi \Sigma  \Pi \Psi \Sigma , concretion \Pi \Psi \Sigma +', locally scoped names
ffi\Pi \Sigma  \Pi \Psi \Sigma , and explicit swapping \Omega '\Theta  '\Lambda ffffi \Pi \Psi \Sigma .

We leave to future work investigating whether Theorem 10can be extended to encompass these features (plus appropriate
ones for product types ` ffl ` \Lambda ). To extend Theorem 21 to thefull generality of Pitts [26] one would then consider ground types
equipped with a nominal signature of constructors and a suitablerecursion combinator. For example,

\Theta \Lambda \Xi  would have constructors
^ \Lambda  \Sigma \Upsilon \Xi  fifl \Theta \Lambda \Xi , \Sigma  \Lambda  \Theta \Lambda \Xi  ffl \Theta \Lambda \Xi  fifl \Theta \Lambda \Xi  and \Pi  \Lambda  )\Sigma \Upsilon \Xi *\Theta \Lambda \Xi  fifl \Theta \Lambda \Xi (with

\Pi \Pi \Theta \Pi \Sigma  '\Sigma  replacing the \Pi \Pi \Sigma  ' construct). This is probably bestdone as part of an investigation of Martin-L"of's constructive type

theory extended with atom-abstraction/concretion, locally scopedatoms, atom-equality tests and explicit swapping.

8. Context
SNTT. The "simple nominal type theory" (SNTT) of Cheney [6]is the work most closely related to the results presented in this paper. The motivation behind both works is the same: to produce acalculus combining simple type theory3 with some of the distinctive features of the nominal sets model of names and binders, par-ticularly atom-abstraction/concretion and the good recursive properties of the associated nominal data types. Moreover, both aimto avoid the need for freshness side-conditions while defining and
computing in the calculus. Although SNTT achieves most of theseaims, it is at the expense of a non-trivial type system and a lack of
expressiveness. We consider each point in turn.As far as the type system goes, SNTT uses bunched contexts
containing information about object-level freshness. So the aimof avoiding freshness conditions is only partially met: terms are
only meaningful in context and concretion is still partial, its well-definedness mediated by freshness conditions in the context. By
contrast, Nominal System T has a completely conventional typesystem and all freshness conditions associated with

\Theta -equivalencehave been elevated to the meta-level (in much the same way as for

systems based on higher-order abstract syntax [23]).As far as expressiveness goes, SNTT lacks name-restriction
ffi\Pi \Sigma  ' and name-swapping \Omega '\Theta  '\Lambda ffffi '. Cheney [6, Sect. 4] discussesthe limitations caused by lack of a

ffi\Pi \Sigma  \Pi \Psi \Sigma  construct. (See alsoFig. 5 of that paper.) Name-restriction is an important feature of

the informal meta-theory of programming languages and logics,one that demands a formalization--and of course we claim to be
providing a pleasant one here. The fact that explicit name-swapping(and more generally name-permutation) is also very important for
meta-theory is gradually gaining currency. One might think thatname-swapping only occurs in the dynamics of nominal metalanguages and not in the semantic specifications written in thosemeta-language. However, note that with explicit name-swapping
we can use a meta-level binder like \Pi \Pi \Sigma  \Pi \Psi \Sigma  to express the binaryoperation

\Pi \Pi \Psi \Omega  \Psi \Sigma  taking an expression ' that computes an object-level variable and an expression

'\Lambda  that computes a piece of object-level syntax and combining them to compute an object-level binder:

\Pi \Pi '\Omega  '\Lambda \Sigma  \Xi  \Pi \Pi \Sigma  \Omega \Pi  'ffffi '\Lambda  (where \Pi  is any atomic name not free ineither

' or '\Lambda ). Example 4 provided an example of this operation inuse. If we extend Nominal System T as in Sect. 7, we can define

the general form of this non-binding operation for atom-abstractionwhich is a characteristic feature of FreshML [33]4:

oe'fl'\Lambda  \Theta  \Theta \Pi \Sigma  \Omega \Pi  'ffffi '\Lambda  where \Pi  \Psi  \Pi '\Omega  '\Lambda \Sigma . (38)
For example, using this we can form the expression

\Lambda \Upsilon \Sigma  \Theta \Pi \Sigma  \Lambda ff\Sigma  \Upsilon \Pi oe\Pi flff\Sigma  + \Pi  (39)
of type \Pi )\Sigma \Upsilon \Xi *` fifl )\Sigma \Upsilon \Xi *` \Lambda \Sigma  fifl )\Sigma \Upsilon \Xi *\Pi ` fifl ` \Lambda \Sigma  whose denotationin the nominal sets model is the "shocking" [16, Sect. 2.5] isomor3 initially, and dependent type theory in the long run
4 Be warned, Cheney [6] uses the notation \Sigma \Theta \Upsilon \Xi \Phi \Pi  for the binding operation
that is denoted here by \Psi \Theta \Pi  \Xi \Phi \Pi .

phism

\Upsilon \Theta \Phi * \Theta \Pi \Sigma  \Upsilon \Theta \Phi *\Lambda  ss\Xi  \Upsilon \Theta \Phi \Pi * \Theta \Pi \Sigma  *\Lambda \Sigma  (40)
noted by Gabbay [10, Corollary 9.6.9]. This is not expressible inSNTT: see Cheney [6, Fig. 5].

Nevertheless, SNTT is a very interesting system whose meta-theory is even simpler than the one presented here. It would be
interesting to investigate translating it into Nominal System T (ex-tended as in Sect. 7); perhaps the translation of its bunched contexts
might provide useful conditions in a conditional-equational calcu-lus more expressive than the simple equational notion of conversion
we have given here.Westbrook et al. [37] use some of the ideas behind SNTT to
design an extension of the calculus of inductive constructions, thetype theory underlying Coq. This is certainly the right direction
in which to go. However, we believe that the use of Odersky-style locally-scoped names will play just as important role for
expressivity in "nominal" versions of dependently typed systemsas it does here for the simply typed Nominal System T.

Focusing on binding and computation. It has become very com-mon to use typed

\Lambda -calculus as a uniform method of representingsyntax involving binding [23]. The pros and cons of this method

compared with "nominal" techniques have been vigorously de-bated [5, 7]. In comparing systems that employ them, one should
bear in mind the purpose for which they are designed: is it rep-resentation plus proof (classical or constructive), or representation
plus computation (functional or logical), or both? Here the primaryfocus is on functional computation with representations and the
analyses of Poswolsky and Sch"urmann [29] and Licata et al. [16]are pertinent: most previous uses of typed

\Lambda -calculus representa-tions identify "functions-as-data" with "functions-as-computation"

(Miller [17] is an early exception) and this leads to complicationssuch as modalities [24] when trying to develop recursion and induction for higher-order abstract syntax. These authors advocateseparating the two notions of function, leading to forms of locally scoped symbols in [15, 16, 29, 37] similar to the notion ofatom-abstraction (

\Theta -binding) considered in the extended systemof Sect. 7. This should not be confused with the notion of namerestriction (ffi-binding).5 For one thing the latter does not changethe type of expressions, whereas the former does. The nominal sets
model makes the difference between the two notions clear. Inciden-tally, Theorem 22 provides an interesting semantical insight: in the
presence of name-restriction, it seems that it is consistent to regardtypes of "functions-as-data" as subtypes of types of "functions-ascomputation".Harper has coined the term "pronominal" for the use of locally
scoped symbols as "pronouns referring to a designated bindingsite", contrasting it with the nominal approach to symbols as nouns
with independent existence. Leaving aside the important fact that,unlike in [16, 29], here we have a boolean-valued equality test on
names, is Nominal System T nominal or pronominal? The answeris not so clear. We are used to the idea of free variables in

\Lambda -calculus being implicitly
\Lambda -bound; in other words their "designatedbinding site" is an implicit top-level. In Nominal System T we can

definitely think of free atomic names as having an implicit top-leveldesignated binding site as well; but they are

ffi-bound rather than
\Lambda -bound. What makes this possible is the fact that in our system,like Odersky's,

ffi-binding commutes with \Lambda -abstraction and tupling(see the
\Pi ffi\Lambda \Sigma  and \Pi ffiae\Sigma  conversions in Fig. 3).A characteristic of using typed

\Lambda -calculus to represent bindingis that one gets substitution and
j-equality "for free" in addition torenaming and
\Theta -equality. This is often seen [24] as a strength ofthe approach, but I am not so sure. There are very many different

5 Unfortunately "\Omega " is used to indicate abstraction rather than restriction in
[29, 37].

forms of substitution; and many forms of name-binding that havenothing to do with substitution whatsoever. The approach here is to
strive for the simplest possible system providing an expressive andfamiliar form of recursion modulo renaming; one that makes it easy
for the user to deal with the many different kinds of object-languagesubstitution on a case-by-case basis. So compared with [15, 29],
here some things are not automatic. Similarly, Licata and Harper[15] incorporate types classifying closed object-level expressions,
whereas I would prefer to let the user make inductive definitionsof such types in the yet-to-be-explored dependently-typed version
of Nominal System T. On the other hand the use of locally-scopedsymbols of any data type, rather than just at name types like

\Sigma \Upsilon \Xi  ashere, seems an interesting feature of [16, 17, 29].

Nominal versus presheaf representations. The nominal setsmodel of names and binding has close connections with the use of
certain presheaf categories to model binding [9]. Indeed the cate-gory j

j` of nominal sets and equivariant functions is a sheaf sub-category of the presheaf category o/

\Sigma \Xi \Theta  of functors to the categoryof sets from the category \Pi  of finite sets and injective functions. The

use of name-restriction operations on nominal sets (Definition 1)brings the connection even closer. Let *

\Sigma \Psi  denote the categorywhose objects are nominal sets
* equipped with a name-restrictionoperation and whose morphisms

\Upsilon  \Lambda  * \Sigma  *\Lambda  are equivariant func-tions that preserve name-restriction (

\Upsilon \Pi \Pi ffi\Pi \Sigma _\Sigma  \Xi  \Pi ffi\Pi \Sigma \Pi \Upsilon  _\Sigma ). Sta-ton [private communication] has observed the remarkable fact that

*\Sigma \Psi  is equivalent to the presheaf category o/\Sigma \Xi \Upsilon \Theta , where !\Pi  is thecategory of finite sets and injective partial functions.

9. Conclusion
Apart from the technical contributions of this paper, the main mes-sages I want to convey are that name-restriction is just as important

as name-abstraction when computing with binders; and that name-restriction need not involve a computational effect. The second is
the same point as made by Odersky [21]. The new results aboutnominal sets (Theorems 2 and 22) lead to a very simple semantics
for this form of local name. This in turn suggests combining thecharacteristic feature of nominal sets--name-permutations--with
Odersky-style name-restriction. It might seem that the commuta-tion of this form of local scoping with function abstraction and tupling make it too simple to be useful--I certainly thought so formany years and have vigorously pursued applications of the more
common, generative kind of local name. However, as we have seen,the combination of this simple and "pure" form of locally scoped
name with name-swapping is very expressive. This paper has usedtheir combination to develop a new form of structural recursion
modulo \Theta -equivalence for total functions which has all the expres-sive convenience of

\Theta -structural recursion without the computa-tionally inconvenient freshness conditions on binders. Continuing

with total functions, the next obvious step is to try to extend Nomi-nal System T with dependent types. Historically speaking, G"odel's
System T was a stepping-stone on the way to Martin L"of's muchmore expressive treatment of recursion and induction [19]. G"odel's
System T is the simply typed kernel of Martin L"of's constructivetype theory. It would be interesting to investigate whether the approach introduced here extends to a "nominal Martin-L"of type the-ory" with Odersky-style local names and name-swapping. The motivation is the search for a logical framework [22] that admits fa-miliar forms of "nominal" specification and formalizes the informal uses of recursion and induction "modulo \Theta " that are commonin the practice of programming language semantics.

Acknowledgments
I am very grateful for stimulating conversations on the ideas under-lying this paper with James Cheney, Johan Glimming, Bob Harper,

Paul Blain Levy, and Sam Staton. Andreas Abel and Peter Dybjergave me good advice about normalization-by-evaluation.
References

[1] A. Abel, T. Coquand, and M. Pagano. A modular type-checkingalgorithm for type theory with singleton types and proof irrelevance.

In P.-L. Curien, editor, Typed Lambda Calculi and Applications, 9thInternational Conference, TLCA 2009, Brasilia, Brazil, July 1-3, 2009,
Proceedings, volume 5608 of Lecture Notes in Computer Science,pages 5-19. Springer-Verlag, 2009.

[2] H. P. Barendregt. The Lambda Calculus: Its Syntax and Semantics.North-Holland, revised edition, 1984.
[3] U. Berger, M. Eberl, and H. Schwichtenberg. Term rewriting fornormalization by evaluation. Information and Computation, 183:19-

42, 2003.
[4] U. Berger and H. Schwichtenberg. An inverse of the evaluationfunctional for typed

ff-calculus. In 6th Annual Symposium on Logicin Computer Science, pages 203-211. IEEE Computer Society Press,

Washington, 1991.
[5] J. Cheney. Nominal logic and abstract syntax. ACM SIGACT News,Logic Column, 36(4):47-69, Dec. 2005.

[6] J. Cheney. A simple nominal type theory. In Proceedings of theInternational Workshop on Logical Frameworks and Metalanguages:

Theory and Practice (LFMTP 2008), volume 228 of Electronic Notesin Theoretical Computer Science, pages 37-52. Elsevier B. V., Jan.
2009.
[7] K. Crary and R. Harper. Higher-order abstract syntax: Setting therecord straight. ACM SIGACT News, Logic Column, 37(3):93-96,

Sept. 2006.
[8] P. Dybjer and A. Filinski. Normalization and partial evaluation. InG. Barthe, P. Dybjer, and J. Saraiva, editors, Applied Semantics, Advanced Lectures, volume 2395 of Lecture Notes in Computer Science,Tutorial, pages 137-192. Springer-Verlag, 2002. ISBN 3-540-44044-
5. International Summer School, APPSEM 2000, Caminha, Portugal,September 9-15, 2000.

[9] M. P. Fiore, G. D. Plotkin, and D. Turi. Abstract syntax and variablebinding. In 14th Annual Symposium on Logic in Computer Science,

pages 193-202. IEEE Computer Society Press, Washington, 1999.
[10] M. J. Gabbay. A Theory of Inductive Definitions with \Psi -Equivalence:Semantics, Implementation, Programming Language. PhD thesis,

University of Cambridge, 2000.
[11] M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax withvariable binding. Formal Aspects of Computing, 13:341-363, 2002.

[12] A. Gacek, D. Miller, and G. Nadathur. Combining generic judgmentswith recursive definitions. In 23rd IEEE Symposium on Logic in

Computer Science (LICS 2008), pages 33-44. IEEE Computer SocietyPress, June 2008.

[13] K. G"odel. "Uber eine bisher noch nicht ben"utze Erweiterung des finitenStandpunktes. Dialectica, 12:280-287, 1958.
[14] A. D. Gordon and T. Melham. Five axioms of alpha-conversion. InTheorem Proving in Higher Order Logics, 9th International Conference, volume 1125 of Lecture Notes in Computer Science, pages 173-191. Springer-Verlag, 1996.

[15] D. R. Licata and R. Harper. A universe of binding and computation. InProceedings of the 14th ACM SIGPLAN International Conference on

Functional Programming (ICFP 2009), pages 123-134. ACM Press,2009.

[16] D. R. Licata, N. Zeilberger, and R. Harper. Focusing on bindingand computation. In Proceedings of the Twenty-Third Annual IEEE

Symposium on Logic in Computer Science, LICS 2008, 24-27 June2008, Pittsburgh, PA, USA, pages 241-252. IEEE Computer Society,
2008.
[17] D. A. Miller. An extension to ML to handle bound variables in datastructures, in the proceedings of the logical frameworks bra workshop.

Technical Report MS-CIS-90-59, University of Pennsylvania, May1990.

[18] R. Milner. Functions as processes. Mathematical Structures in Com-puter Science, 2(02):119-141, June 1992.
[19] B. Nordstr"om, K. Petersson, and J. M. Smith. Programming in Martin-L"of's Type Theory. Oxford University Press, 1990.
[20] M. Norrish. Recursive function definition for types with binders. InTheorem Proving in Higher Order Logics, 17th International Conference, volume 3223 of Lecture Notes in Computer Science, pages 241-256. Springer-Verlag, 2004.

[21] M. Odersky. A functional theory of local names. In Conference Recordof the 21st Annual ACM Symposium on Principles of Programming

Languages, pages 48-59. ACM Press, 1994.
[22] F. Pfenning. Logical frameworks. In A. Robinson and A. Voronkov,editors, Handbook of Automated Reasoning, chapter 17, pages 1063-

1147. Elsevier Science and MIT Press, 2001.
[23] F. Pfenning and C. Elliott. Higher-order abstract syntax. In Proc.ACM-SIGPLAN Conference on Programming Language Design and

Implementation, pages 199-208. ACM Press, 1988.
[24] B. Pientka. A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions. In 35th Annual

ACM SIGPLAN-SIGACT Symposium on Principles of ProgrammingLanguages (POPL'08), pages 371-382. ACM Press, 2008.

[25] A. M. Pitts. Nominal logic, a first order theory of names and binding.Information and Computation, 186:165-193, 2003.
[26] A. M. Pitts. Alpha-structural recursion and induction. Journal of theACM, 53:459-506, 2006.
[27] A. M. Pitts and I. D. B. Stark. Observable properties of higherorder functions that dynamically create local names, or: What's new?

In Mathematical Foundations of Computer Science, Proc. 18th Int.Symp., Gda'nsk, 1993, volume 711 of Lecture Notes in Computer
Science, pages 122-141. Springer-Verlag, Berlin, 1993.
[28] A. M. Pitts and I. D. B. Stark. Operational reasoning for functions withlocal state. In A. D. Gordon and A. M. Pitts, editors, Higher Order

Operational Techniques in Semantics, Publications of the NewtonInstitute, pages 227-273. Cambridge University Press, 1998.

[29] A. Poswolsky and C. Sch"urmann. Practical programming with higher-order encodings and dependent types. In European Symposium on

Programming (ESOP 2008), volume 4960 of Lecture Notes in Com-puter Science, pages 93-107. Springer-Verlag, 2008.

[30] F. Pottier. Static name control for FreshML. In Twenty-Second AnnualIEEE Symposium on Logic In Computer Science (LICS'07), pages

356-365, Wroclaw, Poland, July 2007. IEEE Computer Society Press.
[31] M. R. Shinwell and A. M. Pitts. Fresh Objective Caml user manual.Technical Report UCAM-CL-TR-621, University of Cambridge Computer Laboratory, Feb. 2005.
[32] M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness.Theoretical Computer Science, 342:28-55, 2005.

[33] M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Program-ming with binders made simple. In Eighth ACM SIGPLAN International Conference on Functional Programming (ICFP 2003), Up-psala, Sweden, pages 263-274. ACM Press, Aug. 2003.

[34] W. W. Tait. Intensional interpretation of functionals of finite type, I.Journal of Symbolic Logic, 32(2):198-212, 1967.
[35] C. Urban and S. Berghofer. A recursion combinator for nominaldatatypes implemented in Isabelle/HOL. In 3rd International Joint

Conference on Automated Reasoning (IJCAR 2006), Seattle, USA,volume 4130 of Lecture Notes in Computer Science, pages 498-512.
Springer-Verlag, 2006.
[36] C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal unification. Theo-retical Computer Science, 323:473-497, 2004.

[37] E. Westbrook, A. Stump, and E. Austin. The calculus of nominalinductive constructions: an intensional approach to encoding namebindings. In Proceedings of the Fourth International Workshopon Logical Frameworks and Meta-languages: Theory and Practice
(LFMTP 2009), Montreal, Canada, ACM International ConferenceProceeding Series, pages 74-83. ACM Press, Aug. 2009.