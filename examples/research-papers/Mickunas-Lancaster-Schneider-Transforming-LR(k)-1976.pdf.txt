

Transforming LR(k) Grammars to LR(1), SLR(1),  and (1,1) Bounded  Right-Context  Grammars 

M.  D.  MICKUNAS 

University  of Ilhnozs  at  Urbana-Champalgn,  Urbana,  llhnois 
R.  L.  LANCASTER 
Bowhng Green State  University,  Bowhng Green, Ohio 

AND 
V.  B.  SCHNEIDER 

Purdue  University,  West Lafayette,  lnd~ana 

ABSTRACT.  A method  is  presented  for  directly transforming an  arbitrary  LR(k)  grammar  to  an equivalent LR(1) grammar.  It is further shown that the method  transforms an arbitrary prefix-free 

LR(k) grammar to an equivalent LR(0) grammar.  It is argued that the method is efficient and offers some advantages over tradltmnal "look-ahead" parsing methods.  Finally, it is demonstrated that 
the method  can be used to transform an LR(1)  grammar  to an equivalent SLR(1)  grammar,  which in turn can be easdy transformed  to an equivalent (1, 1) bounded right-context grammar. 

HEY  WORDS  AND  PHRASES:  parsing,  context-free  grammars,  LR(k)  grammars,  grammatical  trans- formations 
CR CATEGORIES: 4.12, 5 22, 5.23 

1.  Introduction 
Whenever a parsing technique is discussed in the literature, the author usually generalizes 
the  method  to  permit  "look-ahead"  calculations  (i.e.  the  parser,  when  visualized as  a 
pushdown  automaton,  is  permitted  to  look  beyond  the  current  symbol of  its  input,  in 

order  to  determine  its  next  move).  Thus  an  LR(1)  method  [16] is  usually  augmented 
by including the  calculation of  "k-symbol input sets"  (on  an exception basis)  instead of 

only  "l-symbol input  sets,"  whence  the  method  is  generalized to  LR(k)  [3,  4,  16,  17]. 
A  precedence  method  [25] is  usually  augmented  by  permitting  duplicate  right-parts 
in production rules.  The  grammar remains precedence detectable  [11] but  the  reduction 
phase  of  the  precedence  parser  must include a  "k-symbol look-ahead"  ability  (again on 

an  exception  basis)  to  choose  properly  between  duplicate  right-parts  of  rules.  Prece- 
dence methods  may thus  be  extended to  handle  (1,  k)  bounded right-context grammars 

Copyright  (C)  1976, Association  for  Computing Machinery,  Inc.  General  permission  to  republish, but not for profit,  all or  part  of this material is granted provided  that  ACM's copyright  notice 

is given and that reference is made to the publication, to its date of issue, and to the fact that reprinting 

privileges were granted by permission of the Association for Computing Machinery. 
This work was supported,  in part,  by National Science Foundation Grant GJ-851 to Purdue Uni- versity and National Science Foundation Grant DCR 72-03740 A01 to the University of Illinois at 

Urbana-Champaign. 
Authors' addresses  M.D.  Mmkunas, Department of Computer  Science, Digital Computer  Labora- tory, Univermty of  Illinois at  Urbana-Champaign, Urbana,  IL  61801; R.L  Lancaster, Computer 

Science Department, Bowling Green State University, Bowling Green,  OH  43402; V.B.  Schneider, Department  of  Computer  Scmnces,  Mathematical  Sciences  Building,  Purdue  University,  West 
Lafayette,  IN 47907. 

Journal of the Assoclatlon  for Computing  Machinery,  Vol  23, No  3, July  1976, pp  511-533 

512  M.D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 
[1, 6,  9,  11].  The  fact  that  look-ahead is performed on only an  exception basis is a  conse- 
quence  of two  disadvantages of the  technique:  (1)  look-ahead sets  are  difficult to  calcu- 
late,  and  (2)  provision of k-symbol look-ahead sets for those  portions of the  parser that 
don't  need  it consumes  an  enormous  amount  of memory  space. 

In  principle, the technique  of transforming a  grammar  to  LR(1)  overcomes the  above 
two  disadvantages.  Moreover,  since there  are fewer parsing actions to be performed,  the 
parser lends  itself to  simpler  analyses of its space/time  requirements.  But  there  are  two 

major  objections to  the  policy of transforming  a  grammar  to  L R( 1 ):   (1)  the  structure 
imposed  by  the  original  grammar  is  generally  not  preserved,  and  (2)  the  transforma- 
tion  may  exhorbitantly  (sometimes  exponentially)  increase  the  number  of  production 

rules. 

From  a  compiler-writer's  point  of  view,  the  first  objection  is  often  academic.  The 
practitioner is  concerned  not  with  the  changes  in  the  grammatical  structure  per  se,  but 

with how those  changes  affect the  code-generating  (semantic)  properties of the  compiler. 
The  transformation  techniques  presented  in  this  paper  permit  a  compiler's semantics  to 

adjust to  such  changes  in  grammatical  structure  in  three ways.  To  illustrate these  meth- 
ods, consider the following stylized subset of an Algol-like grammar: 

~rl :  (statement)  --~ (assignment) 

* "2 :  (statement)  ~  (label)  : (statement) 
~-~ :  (label) ~  identifier 

* "4 :  (assignment)  --~ (variable)  :  =  (expression) 
~r5 :  (variable) ---, identzfier 

The  above  grammar  is  LR(2).  The  semantics  of  ~r3  would  attribute  the  meaning  of 

"label"  to  an  identifier,  whereas  the  semantics  of  lr5  would  attribute  the  meaning  of 

"variable"  to  it.  In  each  case,  the  identifier  (or  its  encoding)  is  located  by  the  code- 
generating routine as the last symbol which was scanned by the parser. 

A  non-LR(1)  problem  arises  with  the  rules  zr3  and  7r5. To  reduce  an  identifier,  an 
LR(2)  parser will apply ~'5 whenever the identifier  is followed by  :  = ,   and it will apply lr3 
whenever the  zdent~fier  is followed by  : identifier.  For example, identifier  :identifier  :  .... 

should be parsed by applying the rules ~'3, ~rs,  * * *  , 7r4,7rl,  lr2 yielding 

(label)  :identifier:  .... 
then  (label)  : (variable)  :  . . . .  : 

then  (label)  : (assignment)  *  * 
then  (label)  : (statement)  .. .  
then  (statement)  * * * 

The  transformations we will present would transform the above grammar to the LR(1 ) 
grammar: 

~'l'  :  (statment)  --~ (assignment) ! 
7r2  :  (statement)  --~ (labeler)  (statement) ! 
7ra  :  (labeler) --~ identifier  : 

I ~'4  :  (assignment)  --~ (left-part)  =  (expression) 

! v5  :  (left-part) --~ identifier  : 

If  the  original  grammar  contained  code-generating  subroutines  associated  with  rules 
7r, or  ~r5, then  some  alteration  of these  subroutines  may  be  necessary  to  work  correctly 
with rules  ~-a t and  7rj of the  altered grammar.  The  semantics of ~r3  (~'s)  must still supply 
the  "label"  ("variable")  meaning  to  the  identifier.  However,  the  identifier  (or  its  en- 
coding)  is now  located by  the  code-generating routine  as  the  next-to-last symbol which 
was  scanned  by  the  parser.  A  second  technique  allows  the  semantics  to  remain  un- 
changed.  The  transformed  grammar  is  used  to  parse  the  program  "internally"  and,  as 
the  internal parse proceeds, an  "external"  parse via the  original grammar  is induced.  As 

Transforming  LR(k )  Grammars  513 
this  external parse  proceeds,  the  original semantics can  be  applied.  This  technique was 
first  suggested  by  Gray  and  Harrison  [11] and  arises  from  the  notion of  "grammatical 
covers," originally due to Reynolds and Haskell [23]. In order to accomplish the internal/ 
external  linkage,  we  map  the  new  rules  onto  the  old  rules  by  a  function,  ~b, which  in 
this  example simply maps  each  ~-/to  ~-,. While we will not present  a  formal proof that 

this  technique works,  we  will nonetheless have  further  detailed remarks  to  make  about 
it.  Schematically, the  internal/external parses proceed  as follows: 

internally  externally 

identifier  :identifier  :  ....  

t apply  ~r8 

(labeler) identifier  :  .. .. 

apply  ~'j 
(labeler)  (left-part)  . . . .  

apply  ~r4' 
(labeler)  (assignment)  ..- 

apply  ~'1' 
(labeler)  (statement)  .. . 

apply  7r~ 
(statement)  . .. 

identifier  : identifier  :  ....  

apply  c(Tra')  =  ~', 
(label)  : identifier  :  ....  

apply  th(lrj)  --  lrs 
(label)  : (variable)  :  . . . .  

apply  4~(m')  =  m 
(label)  : (assignment) . . .  

apply  ~b(~rl')  =  ~'1 
(label)  : (statement)  ..- 

apply  ~b(~r2') =  ~r2 
(statement)  .. . 

A third way of adapting the grammar to its semantics in this case is to force the lexical 
scanner  (which  supplies  an  encoded  form  of  the  input  to  the  parser)  to  recognize  the 
sequence  of  symbols :  =  as  a  s~ngle  input  symbol  ( : = ) .   Thus,  the  grammar  may  be 

changed to 

7rl :  (statement) ~  (assignment) 
7r2 :  (statement) --,  (label)  : (statement) 
m  :  (label) ~  identifier 
m  :  (assignment) --~ (variable)  :=  (expression) 
m  :  (variable) --~ identifier 

The  parser  can now decide to  apply  ~ra if the next input symbol is  : and apply  ~'5 if it  is 

: =.  This is a standard technique that is usually applied in an ad hoc fashion. 

In  our  experience,  the  transformation to  LR(1)  does  not  exhorbitantly increase  the 
size of the  grammar, so long us the  language  in question is well suited to  LR(1)  parsing. 

We have  found that,  even if the  original grammar  is badly written,  the  transformation 
will produce  a  grammar  of  reasonable size.  Even  for  pathological languages, the  trans- 
formation  produces  LR(1)  grammars  which  are  competitive  with  handwritten  LR(1) 

grammars for the  same language.  In  the  remainder of this section we present basic defi- 
nitions and notation.  Most  of what  follows is standard,  and we have patterned much of 

the  format  after that  of Gray and Harrison [11]. 

Definition.  A  (context-free)  grammar  (CFG)  is a  four-tuple, G  =  (V,Z ,P,S )  where 

(a)  V is a  finite nonempty set of symbols  (vocabulary)  ; 
(b)  ~  c  V  (terminal  vocabulary)  ; 
(e)  h r  =  V  -  Z  ( nonterminal  vocabulary)  ; 

(d)  S  E  N  (goal  symbol)  ; and 
(e)  P  is a  finite subset 1 of N  X  V*  (productions). 
We  will  denote  an  element  (A,v)  of  P  as  A  ~  v,  and  we  will  often  ascribe  indices to 
productions: ~r,  =  A  ~  v.  For  any rule, A  ~  v,  A  is called the  left-part  and v the  right- 
part  of the  rule.  Any rule having left-part A  is called an A-rule. 

1From [11] Let Xand  Y be sets of words  We writeXY  =  {xy  IxEX ,  YEY}  where xy is the con- eatenatlon of x and y  Define X o =  {A} where A is the null word. For each i  >  0 define X '+1  =  X' X 

and X*  =  tJ,_~0 X'  Let X + =  X*X  and let ~  denote the empty set. 

514  M.D.  MMICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

We find it convenient to  employ binary relations on sets  of words. 
Definition  (from  [11]).  Let p  be a  binary  relation  on  a  set  X,  i.e.  p  C  X  X  X.  Define 0  ~ 
p  =  {(a,a)  [ a E X } , a n d f o r e a c h 2 z   ~_  O,  p~+l _-  p,p.  Last,  p*  U,_~0p" and  p +  p*p. 
For  a  bi nary  relation  p  on  X,  p*  is  the  refiexive-transitwe  closure  of  p  while  p+  is  the 
transitive  closure  of  p.  For  a  E  X  we  will  write  ap  to  denote  { b E X   [ apb}  and  similarly 
pa  to  denote  { b E X   [ bpa}.  For  H  _C  X  we  write  Hp  to  denote  { b E X   [ (there  exist  a E H )  

[apb]}  and  similarly  pH  to  denote  {bEX  [ (there  exist  aEH)[bpa]}.  We  will  also  write 
al  , a2 , ".   , a, pH instead  of al  , as ,  " "   , a~  E  pH or {ax , as ,  . . .   , a~}  ~  pH. 

We  employ  the  usual  binary  relation  ~  C_  V*  X  V*,  writing  u  ~  v  instead  of (u,  v)  E 

~. 
Definition.  Let  G  =  ( V , Z , P , S )  (N  =  V  -  ~ )  be  a  CF G   and  let  u,  v  E  V*.  Define 
u  ~  v if there  exist  z, w  E  V*;  y  E  Z*;  A  E  N  for which u  =  xAy,  v  -~  xwy,  and A  --* w 

is in P.  Furthermore,  we  write  the  reflexive-transitive elosure of ~  as  ~ * .   If  we  wish  to 

make clear that  the grammar  G is being used, we will write ~ o .  

Note  By thin definition we have immediately restricted our attention to mghtmost,  or canonical  derivations 

Definition.  The  set  of  (canonzeal)  sentential  forms  for  a  CFG,  G  =  ( V , Z , P , S ) ,  
is  denoted  b y  CSF(G)  and  is  defined  as  CSF(G)  =  {xE V * I S ~ * x } .   The  language 
generated by G is denoted b y  L(G)  and is defined as L(G)  =  2;*NCSF(G). 

Definztion.  L e t G   =  ( V , ~ , P , S )   b e a C F G   and  let  x , E   V*,  (0  <  i  <  r).  If  x, 
x,+x  b y  applying  the  production  lr,  E  P,  then  we  say  t hat   x,  d~rectly  derwes  x~+l via  lr,. 
If  x0 ~  x,  ~  . . .   ~  x,  where  x,  directly  derives  x,+l  via  7r,  (0  _<  i  <  r),  then  we  say r--1  r--1 

(Tr,),-o  is  a that  xo  ( eanomcally)  derwes  x,  via  ( ~r,),_o  and  that  (canonical)  derivation  of 
x, from  xo . 

Defimtion.  A  CF G  G  is  said  to  be  unambiguous  if  and  only  if  every  x  E  L(G)  has 
exactly  one  canonical  derivation.  A  CF G   which  is  not   unambiguous  is  said  to  be  am- 

biguous. 

Definition.  Let  G  =  (V , X , P , S )  ( N- ~ V -   ~ )  b e a   C F G   and  let  u  E  V*,  A  E  N, 
w  E  2;*  such  t hat   u A w   E  CSF(G).  Let  7r  =  A  ~  v  in  P.  T hen  uvw  E  CS F (G )   is  said 
to  have 3 handle  (Tr,  [uvI). By  convention, S  E  C S F ( G )   has  handle 4 (A,  1). 

Definition.  Let  k  be  a  nonnegative  integer.  A  CFG,   G  =  ( V , Z , P , S ),   is  said  to  be 7r t 
LR( k)  if  and  only  if 5  for  all  x E   V*;  y,  y'  E  2~*; 7r,  E  PA  if  x y E   C SF(G )  has 
handle  (Tr,  Ix[)  and  xy'  E  CSF(G)  has  handle  (7r',3)  and  Ck)y  =  ~k~y, then 6 (Tr,  Ix])  = 

(7r', 3).  Otherwise  G is said to  be n o n - LR (k ) ,   and in that  case  any rule,  7r, which violates 
the  above  conditions is  said  to  be  no n-L R(k).   It  is  well known  that  an  L R(k)   grammar 
is  unambiguous. 

Definition.  A  CFG,  G  =  ( V , ~ , P , S )   ( N = V - - Z ) ,   is  said  to  be 

(a)  A-free i f P C N *   V +, 
(b)  A-isolated if either  (i)  G is A-free, or  (ii)  P  C  (N X  ( V -   I S} ) +  U  { S--,A}, 
(c)  reduced  if  for  each  A  E  V -   {S},  (i)  there  exist  x , y   E  V*  for  which 
g a y   E  CSF( G),  (ii)  there  exists  z  E  2~* for  which  A  ~ *   z. 

2 From  [11]. The  operation is  a  compos~tzon of relatmns which is defined as follows, if p  ~  X  X  Y and a ~  Y X  Z, define pa  =  [ (x,z)  [ (x,y) E p and  (y,z) E ~ for some yE Y}. Observe that  pa ~  X, X  Z. 

3 Let x  = alas  . * * a,~ E  V* for some n  >  0 (where each a,  E  V and where, if n  =  0, x  =  A).  The  length of  xls  denoted  by  Ix[ and is defined as  Ix]  =  n  Forz  < n ,   ~'~x =  a i . . .   a, andx(')  =  a~_,+~  ..  a~. 
For  ~  ~  n~  (~)x  ~  x (~)  ~  x * h  is  also used  to  denote  the  null production 

If  X  is a set,  then X~  =  X  U {A}. * Notice that  as a  result  of our conventmn that  S  E  CSF(G)  has  handle  (A, 1), we avoid  the  "am- 
biguous LR(0) grammar" anomaly cited by Harrison [12] Our definition is equivalent to that  of the "Augmented LR(k)"  grammars  of  Geller  and  Harrison  [7]. Thus,  for  example,  the  grammar  with 
productmns S  --~ Sa  [ a  is  not LR(O)  by  our  definition since S  E CSF(G)  has  handle  (A, 1),  Sa  E CSF(G)  has  handle  (S--~Sa,2),  and  the  handles are not the same 

Transforming LR(k)  Grammars  515 
There are some additional useful relations which we shall employ. Defimtion. 

Let G  =  (V,X,P,S)  ( N =   V - X )   be a  CFG,  and let X,  Y  E  V. 
(a)  XhY  (X left-derives Y)  if and only if there exists u  E  V* for which X--~Yu is in P. 
(b)  XpY  (X  right-derives  Y)  if  and  only  if  there  exists  u  E  V*  for  which  X---~uY 
is in  P. 

(c)  XvY  (X left-derives terminal  Y)  if and  only if Xh*Y and  Y  E  2L 
(Thus  Xk*Y  is  an  abbreviation  for  "(there  exists  uE  V*)  [X~*Yu]"  and  Xp*Y  for 
"(there  exists uE  V*)  [X~*uY]."  We  will  often  be  presented  with  a  set  H  ~  V  and 
will  wish  to  identify  an  element,  A,  of  {XE V  ] (there  exist  YEH,uE V*)  [X~*uY]}. 
Using  the  relation  p,  we  will  constrain  such  an  element  by  simply  specifying  Ap*H.) 

2.  Preliminary Remarks 
The  main  idea  behind  conversion  from  L R(k )  to  LR(1)  can  be  illustrated  as  follows: 
Suppose a  rule,  A  --~ w,  participates  in  an  LR(2)  (non-LR(1))  portion  of  a  grammar. 
The  decision of whether  to  apply the  reduction  A  --~ w  can be  made  on  the basis of two 
symbols  of  look-ahead.  If  A  --~ w  is  indeed  the  correct  reduction  for  a  sentential  form 

* -.u  w t v  .--  then  the  next  input  symbol,  t,  must  eventually fit into  the  parse,  perhaps 
via a  structure  like 

/ \ / \  
...u  wt  v.., 
The  conversion scheme  must  alter the offending rule A  ~  w  so that  the  decision to  apply 
it  is  not  forced  until  after  the  symbol  t  has  been  scanned.  The  technique  we  use  is  to 

"extract"  the  right-context  first: 

..u  w  t  v... 
and  then  to  merge  the  extracted  branch  with  its  left  neighbor  so  as  to  force  a  prema- 

ture scanning of the extracted symbol 

[Ct]  [t/O] 
...u  w  t  v... 
The  algorithm  that  we will develop  performs  such  extraction upon  all right-contexts  for 
the  symbol A  of the  offending rule A  ~  w  and  performs  a  premature  scan  merger  on  all 
such right-contexts for all C for which Cp*A. We consider a  few more examples. 

The  LR  (2)  grammar 

S  ~  Abb ] Bbc A  --~aAia 

B  --~aBla 

516  M.D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 
with  offending rules  A  --~ a  and  B  --~ a  requires  no  right-context  extraction,  and  is  con- 
verted  via premature  scanning  to  the  LR(1)  grammar 

S  ~  [Ab]bl  [Bb]c [Ab]  -~  a[Ab]  l ab 

[Bb]  --~ a[Bb]  l ab 
The  LR(2)  grammar 

S  ~  Abb  I Bbc A  ---~Aala 

B  --~ a 
with  offending rules  A  --~ a  and  B  --,  a  requires  no  right-context  extraction,  and  is  con- 
verted  via premature  scanning  to  the  LR(1)  grammar 

S  ~  [Ab]bt[Bb]c 
[Aa]  ~  [Aa]a  I aa [Ab]  ~  [Aa]b  l ab 

[Bb]  ~  ab 
Finally,  the  LR(2)  grammar 

S  ~ b S S [ a   taac 
has  the  offending rule  S  --, a,  whose right  contexts  are  generated  by  the  second  S  in  the 
right-part  of S  ~  bSS;  those right-contexts  are a  and  b; 

I A \  
a  b  S  S 

and 

and 

S b /! \s  

I  I o  o 

I / 1 \  a  0  0  C 
The grammar is converted first  (under right-context extraction)  to 

S  ~  bSa[a/S]  t bSb[b/S]  1 a  laac 
[a/S]  ~  h  I ac [b/S]  ~  Sa[a/S]  l Sb[b/S]. 

The right-contexts  (whether  a  or b)  for S  ~  u  have thus been extracted  in all situations: 

Transforming  LR(k)  Grammars  517 

(x  =  a  or  b)  and 

and 
Moreover, 
extracted. 

grammar 

S 
o  o  A 

0  0  o  C 
the  new rule,  [a/S]  --~ A,  which  is  also non-LR(1),  has  had  its  right-contexts 
Finally,  the  grammar  is converted  (under  premature  scanning)  to  the  LR(1) 

S [Sa] 
[Sb] [a/S] 
[[a/ S]a] [[a/S]b] 

[b/S] [[b/S]a] 
[[b/S]b] 

b[Sa][a/S]  l b[Sb][b/S]  I a  I aac b[Sa][[a/S]a]  I b[Sb][[b/S]a]  I aa  I aaca 
b[Sa][[a/S]b]  ] b[Sb][[b/S]b]  Iab  I aacb -----~ A  l ac 
a  I aca ----~ b  I acb 
[Sa][a/S]  I [Sb][b/S] [Sa][[a/S]a]  l [Sb][[b/S]a] 
[Sa][[a/S]b]  I [Sb][[b/S]b ] 
This  transformation  can  be  optimized  to  prematurely  scan  only  the  conflicting  right- 
contexts  for the  offending rule.  In  this  case,  although  both  a  and  b have  been  extracted, 
only  a  is  a  conflicting right-context.  Thus,  after  right-context  extraction,  we  can  obtain 
instead  the  following LR(1)  grammar: 

S  ~  b[Sa][a/S]  I bSb[S/S]  I a  I aac [Sa]  --~ b[Sa][[a/S]a]  l bSb[[b/S]a]  I aa  [ aaca 

[a/S]  ~  A  lac [[a/S]a]  ~  a  I aca 
[b/S]  -~  [Sa][a/S]  l Sb[b/S] [[b/S]a]  ~  [Sa][[a/S]a]  l Sb[[b/S]a] 

This  grammar  contains  16  rules.  So  far  as  we  can  tell,  every  LR(1)  grammar  for  this 
language  must  contain  at  least  12  rules.  Thus,  Mthough  the  size  of  the  grammar  has increased  dramatically,  the  increase  is  due  to  the  language  involved,  and  is  not  ascrib- 

able to any wholesale inefficiencies in the  transformations. 
3.  Main  Results 
We  now  turn  to  the  development  oi  our  primary  result,  a  procedure  for reducing  look- ahead.  The  procedure  is  presented  as  an  iterative  application  of  a  succession  of  trans- 

formations  on  grammars.  Besides  the  Right-Context  Extraction  and  Premature  Scan- 
ning  transformations,  we  use  three  utility  transformations  which  serve,  for  the  most 
part,  to  simplify  operations.  The  first  of  these  utility  transformations  is  the  Right- Stratification  Transformation,  which  simply  breaks  a  single  production  rule,  A  ~  uv, 

into  two  rules,  A  ~  u[v]  and  [v] --~ v. Right-Stratification  Transformation.  Let  G  =  (V, Z , P , S)   be  a  CFG.  To  right-stratify 
a  rule  A  ---~ uv  in  P  at  the u,  v interface,  we define 

P1  =  {A.-mv},  P2  =  P  --  PI.  

518  M.D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 
We  then  define  a  new  grammar,  G,"  which  differs  from G in  its  nonterininal  vocabulary 
and  its  set  of productions. 

PI"  =  {A---nt[v] J A---~v is in PI},  P"  =  PI"  13 P~"  IJ P3", 
P2"  =  {[v]---*v [ A--*uv is in  P1},  V"  =  V  U  {[v]}. P a n - ' P 2 ,  

LEMMX 1.  Let  G"  =  (V",Z,P",8)  (N"  =  V"  -  Z)  be obtained  from  G  ffi  (V,Z,P,8) ( N  = V -   Z ) by means of the Right-Stratification  Transformation.  Then 

(a)  L(G")  --  L(G) ; and (b)  there is  a  surjectwn, 7 4~, from  PA"  onto  PA such  that  zf  lr  E  PA"  is 

not  LR( j)   then 
4J(Tr)  E  PA is not  LR( j). PROOF.  Right-stratification  is  a  common transformation  and  is used  by both  McAfee 

and  Presser  [18]  and  Graham  [9]. McAfee  and  Presser  present  an  informal  proof  that L(G")  =  L(G). 

Graham  gives  a  complete  proof  that  L(G")  =  L(G)  as  wen  as  a  proof 
that  the  right-context  bound  is  preserved.  By  defining  4)  as  the  identity  on  P3"  (thus 

mapping  P3'~ onto  P2A) and  as  a  function  from  the  singleton  set  Pi"  onto  P~  and 
from  the  singleton  set P2" onto Pa,  we  obtain  the  desired  surjection.  Embedding  this  in 

Graham's proof yields part  (b)  of the lemma.  [] 

The  Look-Ahead  Reduction  Procedure  that  we  develop  initially  determines  which rules  of a  grammar  require  right-context  extraction  and  subsequent  premature  scanning 

of those  right-contexts.  This  information  is  then  transmitted  in  the  set,  H,  of left-parts 
of the  selected  rules.  The  transformation  we are  about  to present  accomplishes the  right- context extraction portion  of the Look-Ahead Reduction Procedure. 

It  is  necessary  for  the  Right-Context  Extraction  Transformation  to  extract  terminal symbols  whenever  they  can  occur  as  right  contexts  for  one  of  the  selected  rules,  i.e.  if 
C  --~ v is  a  selected  rule,  and  if  some  symbol,  A,  right-derives  C,  then  whenever  A  ap- 
pears in the right-part  of a rule,  it should either be rightmost or be followed by a  terminal symbol.  We  formalize that  objective by   the  following. 

Definition.  Let  G  =  (V,Z,P,S)  (N  =  V - Z )   be  a  CFG  and  let  H  ~  N.  G  is  said to  be  in H-right-context-extracted  form  if  and  only if for every nonterminal  A  in  p*H  and 
for  every  rule  B-+uAy  in  P,  either  (a)  y  --  A,  or  (b)  y  E  ZV*.  Notice  that  this  defi- 
nition  reduces  to  that  of an  operator  form  grammar  [5,  11] in  case  H  =  N  and  G  is  re- 

duced. Notation.  Let  ~r  =  C -+ v be  a  C-rule of P.  If C is in H  then  zr is also  called  an  H-rule 

of P. 

Right-Context  Extraction  Transformation.  To  extract  the  right-contexts  for a  reduced 
A-isolated grammar G  =  (V,Z,P,8)  (N  =  V  -  ~)  (given H  ~  N)  we first  (iteratively) 
locate  each  rule 

lr  =  B  --~ uCvDEw  (E  E N;  u,v,w  E  V*) 
for  which  C, Dp*H,  and  right-stratify  ~r at  the  v,D  interface  (to  obtain  B  ~  uCv[DEw] and  [DEw]  ~  DEw).  Although  we  might  present  the  Right-Context  Extraction  Trans- 

formation  without  such  stratification,  the  transformation  would be  not  only  more  com- 
plex,  but  also less efficient  (in  general).  This  is because  the  transformation,  given such  a ~r, will accomplish an  extraction  of the right-contexts  for both  C-rules  and  D-rules  (since 

C,  Dp*H).  These  contexts  will  then  appear  in  modifications  of  7r.  In  the  unstratified 
case, the  modifications must  account for all possible pairs of such right-contexts,  whereas 
with  stratification,  combinations  of  right-contexts  are  handled  in  series.  For  example, if  v  =  Fx  (whence  ~r --  B--~  uCFxDEw)  and  a,  b  are  in  Fv,  e,  d,  e  are  in  E~',  then  lr 

7 LetX  and Y be sets, and 4, a  mapping of X  into  Y. If each element of Y is the  image  of  at  least  one 
element  of  X,  then  4~ is  a  surjection from X  onto Y. 

Transforming  LR(k )  Grammars  519 
would  yield 

lrl  =  B  --~ uCa[a/F]xDc[c/E]w 
~r~ =  B  ~  uCa[a/F]xDd[d/E]w 

7r~  =  B  --~ uCa[a/F]xDe[e/E]w 

However,  by  stratifying  ~- as 

* -  =  B  ~  uCFx[DEw] 
we  obtain 

lrt  =  B  --~ uCa[a/F]x[DEw] 

* "~  =  B  ~  uCb[b/F]x[DEw] 

t ~r~  =  [DEw]  --~ Dc[c/E]w 

~r4  =  B  ~  uCb[b/F]xDc[c/E]w 
lr5  =  B  --~ uCb[b/F]xDd[d/E]w 

* "6  =  B  ~  uCb[b/F]xDe[e/E]w 

t  =  [DEw]  --~ D Ew  

! lr2  =  [DEw]  --~ Dd[d/E]w 
, * "3  =  [DEw]  ~  De[e/E]w 

for i  E  {2,3,4,5}, 
and  for 

P:" ( C) 

Pj'(c) P4" (c) 

P j ' (C )  
and  define 

Pi"  =  UC~M' P('(C) P~"  =  Pe', 

every  CE M': 

=  {[a/D]--~[a/E]wb[b/G]xlE,GEN';  Era;  G~b;  D--~EwGx  is  in  P~'(C)  where Ewwp*N'}, 

=  {[a/D]---~[a/E]w  I E E N ' ;   El'a;  D---~Ew is in  P3'(C)}, 
=  {[a/D]--~wEb[b/F]x  I a E ~ ,   F E N ' ;   Frb;  D--~awEFx  is in P4'(C)  where  Ep*H'}, 
=  {[a/D]-~w  I aE Z ;  D--~aw  is in  P~'(C)}, 

Note  that  it  is sometimes  necessary  to  stratify  a  rule  more  than  once.  For  example, 

~"  =  B  ~  xFuCvDEw  (E  E  N ) ,  
where  F,  C,  Dp*H,  must  be  stratified  as 

Pt ~r  =  B  ~  xFu[CvDEw]  ~"  =  [DEw]  --~ DE w 

! * "  =  [CvDEw]  --~ Cv[DEw] 

Upon  performing  right-stratification,  we  have  a  (reduced  A-isolated)  grammar,  G'  = 

(V ' ,Z ,P ' , S)   (N'  =  V'  --  Z).  We  compute  H'  c  N '   such  that  for  qr in  P',  if  ~b(~')  in P  is  an  H-rule,  then  ~" is  an  H'-rule.  (We  can  actually  compute  H '   more  carefully  to 

yield  a  possibly  smaller  subset  of  N r,  but  the  calculation  given  here  will  do.)  To  con- tinue  with  the  transformation,  we  then  define 

Pi'  =  {A---~uBCv  in  P'  I C E N ' ;   Bp*H'} 
(Notice  that  as a  result  of stratification,  C of such rules is uniquely  determined.) 

=  *  '  M' L e t M '   { C E N ' l A - - ~ u B C v i s i n P l ' w h e r e B   p  H  }. Fo r eac h C   E  define 

O'(C)  =  {D--~Ew  in  P ' I E E N ' ;   CX*D},  P j ( C )   =  Q'(C)  -  P~'(C). 
R' (C)  =  {D--~aw in  P'  I aE ~;   C~*D},  P4' (C)  =  R' (C)  n  Pi', 
P2'(C)  =  Q'(C)  O Pt'  Ps'(C)  =  R '(C)   -  P4'(C), 

and  define 

P ( =   Uce~"  P,' (C)  ( f o r i E   {2,3,4,51), P6'  =  P -   Pi'. 

We  then  define  a  new  grammar,  G",  which  differs  from G' in  its  nonterminal  vocabulary and  its  set  of productions. 

Pi"  =  {A---~uBa[a/C]v  I CE N';  C~-a; A---~uBCv  is  in  Pi'  where  Bp*H'} 

520  M.D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

P"  ffi PI"  13 P~"  O P~"  O P4"  0  P~"  13 P~", 

V"  =  V  13  W";  N "   =  V"  -  Z,  where  W"  =  {[a/A]  I aEZ;  A E N ' ;   there  is  an [a/A]-rule  in P"}. 

Also define H"  =  H'  13 {[a/A]E  W"  I AEH '}. This transformation is quite  similar  to that  presented by  Gray  and  Harrison  [11] for 
obtaining  an  operator  form  grammar.  It  should  be  noted  that  the  transformation  as shown can operate in general on only A-isolated grammars. 

The  following example  illustrates  the  methods  of  the  transformation.  Consider  the LR(2)  grammar with productions 

7rt  =  S--~Ad 7r2 ,  7r~ ,  lr4  =  A--~aAB  ] b ] bbc 
m  =  B--~A 
The  Look-Ahead  Reduction  Procedure  will  find  that  ~'a  is  not  LR(1),  and  thus  will specify its left-part as H  =  {A}. No  stratification is required,  so G'  =  G and  H'  =  H. 

Thus Pi'  is found to be 
Pi'  =  {1r2 =  A--~aAB},  and  M'  =  {B f.  (Right-contexts for A-rules are  generated  by 

Q'(B)  =  { ~rs} 
Rt (B)  =  l~':,~'*,~'+} 

p2 t  ~ 
PJ   =  {~5} 
P~'  =  {~'~t 

~'1,  which  needs  no  extraction,  and  by  Ir2. Right-contexts  for  A-rules  obtained  through 
~'~ must  be  ultimately  extracted through  the symbol B.) 

(In  ~r~, right-contexts  for  A-rules  are  gene- rated  by  the  symbol  B.  lrs  is  a  rule  which 
does  not  originate  terminal  fight-contexts, but  lr5 does  generate  them.  Thus  extraction 
must proceed through  1r5 . ) (In  7r2, right-contexts  for  A-rules  are  gen- 
erated  by  the  symbol  B,  and  since  BX*A, they  are  also  generated  by  the  symbol  A. 
The right-contexts which are  generated by A originate  in the rules  Ir~,  xs,  and  ~r4.) 

(~r~ is  a  rule  in  which  the  right-contexts  for A-rules  are  both  generated  and  originated.) 
P~'  =  { ~,~4} P6'  =  { 7rl,~r3,m,m}. 

Thus, the one-symbol right-contexts for A-rules originate in  7r~, lr3,  ~r4 and  are a  and b. The transformation yields: 
Pi"  =  {A-mAa[a/B],  A--~aAb[b/B]}  (ultimateextractionof right-contexts for A-rules), P ( ' =   ~ ,  
P3"  =  { [a/B]-~[a/A],  [b/B]--+[b/A]J  (propagation of right-contexts through rules of P3'), P4"  =  {[a/A]-+Aa[a/B],  [a/A]-+Ab[b/B]}  (origination  of the  right-context a  and  also 

ultimate  extraction  of  right-context  for A-rules), 
Ps"  =  {[b/A]-~A,  [b/A]-+bc}  (origination of the right-context b), P6"  --  {S-~Ad,  A-+b,  A-+bbc,  B--+A}  (rules  which  do not  receive ultimate  extraction 

of the right-contexts for A-rules). 
Note that  the rule B  ~  A,  although included in P",  is useless.  This poses no problem for these  formalizations, but  a  practical  implementation  of  the  Right-Context  Extrac- 

tion Transformation concludes by reducing G". 

Transforming  LR(k)  Grammars  521 

LEMM/~. 2.  Let G  =  (V,Z,P,S)  ( N  =  V  -  ~)  be a reduced A-isolated L R ( k )   grammar, 
and  let H  ~  N.  Let G"  =  (V",Z,P",S)  (N"  =  V"  -  Z)  and H"  ~  N"  be obtained from 
G and H  by means of the Right-Context Extraction  Transformation.  Then 

(a)  L(G")  =  / ( G ) ;  
(b)  there ,s  a  surjection,  c~, from  Pa"  onto  PA such  that  if  v  E  PA"  ~s not  L R ( j ) ,   then 
4~(Ir)  E  PA is  not  L R ( j ) ;   and 

(c)  G"  is  in  H"-right-context-extracted  form  where for  each  7r E  P",  if  4~(lr)  E  P  is  an 
H-rule  then  ~r is  an H"-rule. 

The  relationship  between  G'  of  the  transformation  and  G  is  given  by  Lemma  1.  We 
establish  some  claims  relating  G"  to  G'. 

CLAIM 1.  Let a  E  Z,  A  E  N',  v  E  Z*.  A  ~*~'  av  if  and  only  if  A  ~ . a ,   av.  Moreover, 
if  [a/A]  is  in  N",  then A  ~ .o '   av if  and  only  if  [a/Al  ~ , a .   v. 

PROOF.  The proof is by induction on the length of the derivations. 
Basis.  Suppose  A  ~ '   av.  This  occurs  if  and  only  if  ~r  =  A  ~  av is  in  P'.  Thus,  ~- 
is in P~'. This occurs if and  only if A  ~  av is in P~", which occurs if  and  only if A  ~ o ,   av. 

Moreover,  [a/A]  is  in  N"  if  and  only  if  ~- is  in  Pa'  ( ~   Pt').  This  occurs  if  and  only if 

[a/A]  ~  v is in  Pa",  which  occurs if and  only if  [a/A]  ~ "   v. 

Inductwn step.  Suppose that  the  claim holds  for derivations  of length  k  (1  <  k  _<  n) and  consider  a  derivation  of length  n  -4-  1.  Thus 

A  ~+o,  av  (n  -t-  1 steps).  This  may 
be  written 

A  ~ o '   u,  u  ~+o,  av  (n steps).  (1) 

(1)  occurs  if  and  only  if  r  =  A  --~ u  is  in  P'  and  u  contains  a  nonterminal  symbol. We have  six cases to  consider,  depending  on  whether  ~" is in P,',  P,~, Psi, Par, P4', or P j .  

Case  1.  ~" is in P~'.  Then  there  exist  C  E  N' ;  B  in  p*H'  for which  ~r =  A  ~  wBCx. 
Also, v  =  vlv2bv3v4 (b  E  Z,)  where 

w  ~.o,  avl,  (2) B  ~,o,  v~,  (3) 

C  ~.a,  bvs,  (4) X  ~. o ,  v~.  (5) 

Such  a  lr  is  in  PI'  if and  only if A  --~ wBb[b/C]x  is  in  Pi".  By  the  inductive  assumption, 

(3)  and  (4)  hold  if  and  only  if  B  ~ . o .   v2  and  [b/C]  ~*~'  v3.  Applying  the  inductive 
assumption  to  the  successive  nonterminals  of  w  and  x,  we  find  that  (2)  and  (5)  hold 
if  and  only  if  w  ~.a.  avl  and  x  ~ . o .   v4 .]  Combining  these  results,  we  have  A  ~ o -  
wBb[b/C]x  ~*G"  avlv~bv3v4 =  av.  Moreover,  [a/A]  is in  N"  if  and  only if 7r is in P~  I.J P4' 

( ~   Pi'),  so one of cases 3 or 5 applies. Case  2.  ~" is  in  P6'.  This  occurs if  and  only  if  7r  =  A  --~ u  is  in  P6 r'.  Applying  the 

inductive  assumption  to  the  successive nonterminals  of u,  we find  that  (1)  holds  if  and only if 

u  ~ . a .   av.  Thus  we have A  ~(~" u  ~ . o -   av.  Moreover,  [a/A]  is  in  N"  if  and  only 
if  7r is in  P3'  (J  P J   ( ~   Ps'),  so one  of cases 4  or 6  applies. Case  3.  7r is in P2'.  Then  there  exist B, D  E  N' ;  w,  x  E  V*; 

Bw (1) in p*H for which 
v  =  A  --~ BwDx.  Also v may be written  v  =  VlbV2v3 (b  E  Z)  where 

Bw  ~ . w   avx ,  (6) 

D  ~.a,  bv2,  (7) x  ~ ' o ' v 3 .   (8) 

Such  a  lr is  in P2' if and  only if  [a/A]  ~  [a/B]wb[b/D]x  is  in  P2".  As  in  case  1,  we  apply 
the  inductive  assumption  to  (6),  (7),  and  (8),  and  combine  to  obtain  [a/A] ~ "   [a/B]wb[b/D]x ~ . a .   vlbv~v3 =  v. Moreover, P2'  ___ Pi',  so  ease  1  applies  and  A  ~*~" 

av. Case  4.  ~r is  in  PJ.  Then  there  exist  B  E  N t for which  7r  =  A  --* Bw.  Also,  v may 
be  written  v  --  vlv2 where  B  ~.o ,   avl  and  w  ~. o ,  v2.  Such  a  ~r is  in  P,'  if  and  only  if 

522  M.  D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

[a/A]  ~  [a/B]w  is in P3". Again,  as in case  1 we  obtain  [a/A]  ~G,  [a/B]w  ~ . o ,   vlv2 =  v. Moreover, P3'  _C P6',  so case 2  applies and  A  ~ . a ,   av. 

Case  5.  ~ r i s i n P 4 ' .   Then  there  exist  a E   ~;  C E N ' ;   B i n   p*H'  for  which  lr  = A  ~  awBCx.  Also, v may be  written v  =  vlbv2v~ (b  E  Z)  where  wB 7  *o" vl,  C ~*~'  bye, 
and  x ~**'  v,.  Such  a  ~r is in  P4'  if and  only if  [a/A]  ---~ wBb[b/C]x  is in  P4".  Again,  as in  case  1  we  obtain  [a/A]  ~ o ,   wBb[b/C]x  ~ . a ,   vlbv2v3  =  v.  Moreover,  P4'  c  Pi',  so 
case  1 applies and  A  ~ . o ,   av. Case  6.  zr is  in  Ps'.  Then  7r  ~  A  ~  ax,  where  x ~.o,  v.  Such  a  ~r is  in  Ps'  if  and 
only if [a/A]  ~  x  is in Ps".  Again,  as in case 1 we  obtain  [a/A]  ~ a ,   x  ~ . o ,   v.  Moreover, p j   _c  P6', so case 2 applies and A  ~ . o ,   av. 

These six cases complete the inductive extension, and Claim 1 is proved.  O CLAIM 

2.  Every  x  E  CSF(G")  can  be uniquely  written  x  =  xlx2...xny  (n  ~_  0,  where 
if  n  =  O,  x  =  y)  where  z,  E  V'*{a[a/A]  [ a E Z ; A E N ' ; [ a / A ] E N   '~}  (for  i  E  {1,2,...,n}) and  where y  E  V ~*. 

PROOF.  By inspection of P"  we see that  every occurrence of [a/A]  (a  E  Z;  A  E  N ')  in  the  right-parts  of  productions  is  either  preceded  by  an  a  or  occurs  as  the  leftmost 
symbol in the right-part.  In the latter  case, the left-part of the production  is of the  form 

[a/B]  (B  E  N';  same  a  E  ~).  Taking  this  observation  into  account,  the  claim  is  easily proved by induction.  We shall leave the details to the reader.  [] 

Our  next  result  requires  the  following.  Let  x  E  CSF(G")  have the  unique  decomposi- tion of Claim 2, 

x  =  xlal[al/Allx2a~[a~/A~]..,  x,~a,,[a,/A,~]y  (z, E V'* ;a, E ~ ;A, E N p ;[a,/A,] E N p' for  iE{1,2,-.  ",nl;yE  V'*). 
Define a  as 

or(x)  =  a ( xlal[al/ A1]x2a~[a~/ A~] . . . x,a~[a,/ A,]y ) 

=  xlAxx~A~...xnAny. 

Clearly for x, y  E  CSF(G"),  if x  -~  y  then  a(x)  =  a(y).  We  further  define  ~,  a  surjec- tion from P Z   onto  P~', by 

t i   --~ a(u)  if lr  =  A  ~  u  is in  P1 ~  (J  P~,  P~" ch(~rEP~")  =  ---~a(au)  i [ r =   [ a /A ] - - ~ui si n P ~"U P a"t J  kiPs"  ( a E   ~), 

otherwise. 
(The  fact  that  4~ is  a  surjection  follows  easily  by  construction  and  the  fact  that  G'  is reduced. ) 

CLAIM 3.  Let  u  E  V"*;  y  E  2~*;  r  E  P~".  I f  uz  E  CSF(G")  has  handle  (~r,iu]) then  a(uz)  E  CSF(G')  has  handle  (~b(zr),[a(u)I). 
PROOF.  The proof is by induction  on the  length  of the  G"  derivation. Basis.  S  E  CSF(G")  has  handle  (A,1)  and  a(S)  =  S  E  CSF(G')  has handle  (A,1) 
=  (4,(A),I~(S)I). Induction  step.  Suppose  that  the  claim  holds  for  G"-derivations  of  length  k 
(0  _< k  <  n)  and  consider a  derivation of length  n  +  1.  Then ~r =  X  --~ y  with u  =  xy and  S  ~ . o ,   xXz  ~ "   xyz  with handle  (r,[xyl).  By the  inductive  assumption, 

S  ~.o,  a(~X)z.  (1) 
We have two  cases to  consider. Case  1;  ~? =  A  ~  y  is in  P~"  [J P~".  Then  4~(~r)  --  A  ~  a(y)  is in  P~'  [J Po' and 

~r(xA)  a( x) A.  Thus  by  (1)  S  ~.a,  a ( x ) A z   a, =  ~ ( , ~ )   a ( x ) a ( y ) z a n d   c ( x) a ( y) z  = 
a(zyz)  E  CSF(G')  has handle  (~(~r),  la(zy)l). Case 2.  ~r  --  [ a / A ] ~ y i s i n P H   UPa~'  O P ~   [JPj~.  Then  ~(~')  =  A  ~ a ( a y )  

is in  P~  (J  P~  (J P~'  (J  P~  and,  by Claim 2,  x X   =  x[a/A]  --  wa[a/A].  Thus,  a ( x X )   -- a(wa[a/A])  --  a( w ) A   and  by  (1)  S  ~.o,  a( w ) A z  ~(,,)o,  a( w)a(a y)z  and  a(w)a( ay) z 

--  a(way)z  --  a(xyz)  E  CSF(G')  has handle  (~(~r),  ]a(xy)]).  [] 

Transforming  LR(k)  Grammars  523 

Pl' 
and let M' = 

Q'(B) R' (B) 

P~' ( B) 
and  define 

PROOF OF LEMMA 2.  Claim  1 establishes  that  L(G")  =  L(G').  By inspection of P" we see that  for  ~',  ~" E  P";  ~"  X  ~  y,  ~-'=  X'  '  lr' 

=  ~  y,  if lr  ~  and  ~b(~r)  =  q~(~-'), then y(J~' D r~  y'  (i.e. by  symmetry, neither right-part  is a  suffix  of the other).  Suppose 

that  ~" E  Pa" is not LR(j).  Then there exist x,x'  E  V"*;  z,z'  E  Z*;  lr'  E  P"  for which 

zz  E  CSF(G")  has handle  (~',[z[), x'z'  E  CSF(G")  has handle  (It',Ix'l) ,  (1) 

(lxI+~)XZ  ~  (Izl+3)XtZt,  and 

By Claim 3,  a(x)z  E  CSF(G')  has handle  (~b(Tr),ta(x)l), a(z')z'  E  CSF(G')  has handle (c(~'),l~(x')l). 

~P Case  1.  Izl  =  Iz'l.  Then  by  (1)  z  =  whence  a(z)  =  a(~').  Also  U~z =  o~z'. 
Thus  ct'c~l+~c(zz)  =  cl'c~l+~c(x'z').  Also  by  (1),  Ir  ~  ~-'. Now  it  cannot  be  that c(7r)  =  q~(lr')  since then  x  ~  x'  (by our observation that  neither right-part  is  a  suffix 

of the  other).  So  c(~')  c  4~(~r'). Consequently  (~(~),l~(x)l)  c  (~(~'), l~(J)l )  and q~(~')  E  PA' is not LR(j). 

Case 2.  Izl  <  ]z'l.  Then  by  (1)  there  exist  z~ E  Z+,  z~ E  ~*  for  which  z  ~-  z~z~ and  zz~ =  z',  whence  ~(z)z~  =  v(z').  Since  Iz~l >  0  it  follows that  I~(x)l  <  I~(z')l. 
Thus  (~(~r),l~r(x)l)  c  (~b(~-'),la(x')l).  Also by  (1)  and  the  fact  that  c  preserves  any terminal  suffix  of  z',  ~l'c~t+~a(zz)  =  cl'c~t+%-(z'z').  Consequently  q~(~r) E  P~'  is  not 

LR(j). Case 3.  Iz I >  Iz' I.  As in case 2, we find that ~(~r)  E  P' is not LR(~). 

By  composition  of  the  surjection  obtained  here  and  the  one  obtained  in  the  Right- Stratification  Transformation  (Lemma  1),  we  obtain  a  new  surjection  (which  we now 
rename  c)  from P Z   onto P s.  Also, by the  construction of P"  we see that  G" is in H"- right-context-extracted form where, for  ~- E  P",  if ~b(~r) E  P  is an H-rule, then  ~" is an 
H"-rule. This completes the proof of Lemma 2.  [] Having obtained a grammar G" in H"-right-context-extracted form, we are now ready 
to  develop  a  transformation  to  effect the  premature  scanning  of those  extracted right- contexts.  That  is,  given  some  H"-rule  (A~-~  z)  and  a  "path"  of  p+H"-rules 

( Ao ~  x~A ~,. . . ,A,_~ ~  z,A~)  leading from an extracted right-context (a in A  ~  zAoay ), we wish to "merge" that right-context (beginning with A  ~  x[Aoa]y)  with the p*H"-rules 
(obtaining  [A0a] --~  z~[A~a],... ,[A~_~a] ~  x~[A,a]  and  terminating  with  lama]  --~  za). However, in order to simplify the proof for that  Premature Scanning Transformation, it 
is convenient to perform a  so-called "state-splitting" transformation, isolating the p*H"- rules by distinguishing their left-parts. This is accomplished by the following. 

Path  Isolation  Transformation.  Let  G  =  (V,Z,P,S)  (h r  =  V  --  ~)  be  a  reduced A-isolated  CFG  and  H  ~  N.  Apply  the  Right-Context  Extraction  Transformation  Vo 
G and H  obtaining G' =  (V',~,P',S)  (N'  =  V'  -  ~)  in H'-right-context-extraeted form where H'  c  N'  and H'-rules map onto H'-rules.  Define 

=  {A--~uBav  is in P'  I aE2~;Bp*H'} 
{BEN'  ] A---~uBav is in P~' where Bp*H'}.  For each B  E  M' define 

=  {C.--rwD  in P'  I D E N   ;Bp  C},  Pa'(B)  =  Q'(B)  -  P~'(B), =  {C--~wb in  P'  I bE~;Bp*C},  P~'(B)  =-  R' (B)  13 P,', 

=  Q'(B)13  P~',  P~'(B)  =  R ' ( B ) -   P~'(B), 

P 6'=  P '- -  P~'. 
We then define a new grammar,  G", which differs from G' in its nonterminal vocabulary and its set of productions. 

Pi"  =  { A--mB'av  ] aE~;  A - m B a v   is in  PI'  where Bp*H'} 

524  M.  D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

and for each B  E  M' 

P2"(B)  =  { C'-~uE'cwD'  [DEN';  e e l ;   C--mEcwD  is in P2'(B)  where Ep*H'} , Pa" (B)  =  {C'--~wD'  [DEN';  C--~wD is in P3'(B)}, 

P4"(B)  =  { C'--~uE'cwb  l E E N';  c,bE Z ; C--~uEcwb is in P4'(B)  where Ep*H'} , PJ' (B)  =  {C'--~wb [ bEZ;  C--ywb is in P6'(B)}, 

and  define 

P,"  =  U  P,"(B)  (for i  E  [2,3,4,5}), BEM" 

P,"=  P6', P" 

=  PI"  U P2"  U P3"  U P4" U P~"  U P6", V ~' =  V'  U W"  where W" =  {A' [ A E N '   and  there exist an  A'-rule in P"}. 

Also define 

H"  =  {A 'EW"  I AEHI. 
LEMMA 3.  Let G =  ( V,X,P,S)  (N  =  V  -  ~ ) be a reduced A-isolated  LR(k ) grammar and let H  ~  N.  Let G" =  (V",Z,P'r,S)  (N"  =  V"  -  ~)  and H"  c  N"  be obtained from 

G and H  by means of the Path Isolation  Transformation.  Then (a)  L(G")= 

L(G); (b)  there is  a  surjection,  ~, from  P Z   onto  PA such  that  if  7r E  P Z   is  not  L R(j)  then 

c~(~r)  E PA is not LR (j) ;  and (c)  G"  is  in  H"-right-context-extracted  from  where  for  each  ~r 6  P",  if  4~(v)  E  P  is 
an H-rule then either 7r is an U"-rule or Ir is LR( 1 ) with respect to all rules of G. PROOF.  Path  isolation is  a  particular  instance  of the  "factorization" transformation 
of Graham  [9]. Graham  proves that  such  a  transformation  preserves both  the  language and  the  right-context  bound.  A  slight  addition  to  Graham's  proofs  yield  the  needed 

surjection from PA"  onto  PA'  which,  when  composed with  the  surjection from PA'  onto P~t obtained in right-context extraction  (Lemma 2),  yields the desired surjection  (which 
we now rename  ~b) from P Z   onto  PA.  To  prove part  (c),  suppose  ~- =  A  ~  v in  P" is  not an  H"-rule, but  that  ~b(Tr) is  an  H-rule.  Since by  construction G"  is in  H"-right- 

context-extracted form, it  follows that  ~r can  occur only in  derivations  like  S  ~ .a ,   uA ~ "   uv.  Clearly,  under  such  conditions,  if  lr  is  not  LR(1),  then  lr,  and  by  part  (b), 

~b(x),  are  not  LR(k)  for  any  integer  k,  which  contradicts  the  hypothesis  that Gis  LR(k).  [] 

We now present the transformation  which is the nucleus of the Look-Ahead Reduction Procedure. Following the transformation, some examples are presented. 
Premature  Scanning  Transformatwn.  Let  G  =  (V,~,P,S)  (N  =  V  -  ~)  be  a  re- duced  A-isolated  CFG  and  let  H  ~  N.  Apply  the  Path  Isolation Transformation to  G 
and  H,  obtaining  G'  =  (V',2;,P',S)  (N'  =  V'  -  2;)  in  H'-right-context-extracted form,  where H'  ~  N'  with  H'-rules  mapping  onto  H-rules.  Define  T'  =  {A--~uBav  in 
P t l a E ~ ;   Bp*H'}  and  let  M'  =  {Ba in  N'2~ I A--~uBav is in  T'  where Bp*H}.  For  each B  E N' for which there exists a  E  Z such that Ba is in M', define 

Q'(B)  =  {C-+wD  in P'  I DEN';  Bp*C},  P~'(B)  =  Q'(B)  -  P~'(B), R'(B)  =  {C--~wb in P'  I bEZ;  Bp*C},  P4'(B)  =  R'(B)  N  T', 
P2'(B)  =  Q'(B)  N  T',  P J ( B )   =  R'(B)  -  P4'(B), 
and define 

P ;   =  U  P,'(B)  (for i  E  {2, 3, 4, 5}), BaE M' 
P , ' =   T ' - -   (P,'OP,'), P6' 

=  P'  -  (T'UP3'UP ,' 

Transforming  LR(k)  Grammars  525 

(Note  that  P ;   n  P3' =  $2~ for z  ~  3;  i,j  E  11, 2, 3, 4,  5, 6} ).  We then  define a new  gram- mar  G"  which  differs  from  G  in  its  nonterminal  vocabulary  and  its  set  of  productions. 
For  each  Ba  E  M',  define 

P2" ( Ba )  =  { [Ca]--~u[Ec]w[Da]  I c E Z ; D E N ' ;   C--~uEcwD  is in  P2' ( B )  where Ep*H'}, 
P3" (Ba)  =  {[Ca]--~w[Da]  I D E N ' ;   C---~wD is in  PJ(B)}, P4"(Ba)  =  {[Ca]--~u[Ec]walcE~;  E E N ' ;   C-~uEcw  is  in  P4'(B)  where  Ep*H'}, 

P j   (Ba)  =  {[Ca]---~wa ] C---~w is in  P j( B) }, 
and  define 

P , " =   U  P,"(Ba)  ( f o r z E   {2,3,4,5}), BaE M' 
PI"  =  {A---~u[Ba]v  [ a  E  ~;  A  ~  uBa~  is in  Pi' where  Bp*H'}, Pe " =   Pe', 

P"  =  Pi"  U P2"  U Pj '  U P4" UPs" U Pe", 

V"  =  V  U  W"  whereW"  =  {[Aa]  [ A  E N';  aE Z;  thereexistan  [Aa]-rule inP"}. 

Before  embarking  on proofs for the  Premature  Scanning  Transformation,  let us illustrate the  methods  used  by the  transformation.  Consider  the  LR(2)  grammar with  productions 

lrl,  7r2 : S  --~ Ab  I aBbc  ~'5 : B  ~  C 

7r3 ,  m  : A  -~  aAbA  [ b  m ,   ~'~ : C  ~  b  [ Cbd 

The  rules  ~'4  and  ~'e  are  not  LR(1).  Tlius  the  Look-Ahead  Reduction  Procedure  will calculate  H  =  {A,  C}.  Path  isolation  has  no  useful  effect  on  this  grammar,  yielding 

G' =  G and H '  =  H.  The Premature  Scanning Transformation  yields 

T'  =  { ~'1,7r2,~'3,~'~}  (rules in which right-contexts  for H'-rules originate) 
with M'  =  {Ab,Bb,Cb}, 

Q'(A)  =  {~-3} Q'(B)  =  {~-~} Q'(C)  =  ~  (rules  through  which  right-contexts  for  H'- rules  must  be  propagated), 

R ' ( A )   =  {m}  R ' ( B ) =   {m,~'~} R ' ( C ) =   {Tre, TrT}  (rules  atwhieh  propagation  of right- contexts  will  terminate), 

P2'  =  {~'3}  (rules  which  both  originate  right-contexts  for  H'-rules  and  also  through which  such  contexts  must  be  propagated), 
Re'  =  { ~}, P4'  =  {~7} 

Then 

(rules  which  both  originate  right-contexts  for  H'-rules  and  also  which will  terminate  propagation  of such  right-contexts), 

Ps'  =  {Ir4,  rre}, 
Pi'  =  { ~'x,  ~'2}, Re'  =  ~. 

P2"  =  P2"(Ab)  =  {[Ab]-~a[Ab][Ab]}, Pe"  =  P3" (Bb)  =  {[Bb]---~[Cb]}, 

P4"  =  P4" (Bb)  =  P4" (eb)  =  {[Cb]-,[eb]db}, 
P j   (Ab )  =  {[Ab]---~bb} 

The  resulting  grammar  is  LR(1). 

Pj"  =  PJ'(Ab)  U  P j'(Cb) , Pi"  --  { S~[Ab],  S--~a[Bblc}, 
Pe"  =  2~. Re" (Cb)  =  {[Cb]--~bb}, 

It  is  illustrative  to  note  the  effect that  path  isolation  has  on  the  Premature  Scanning Transformation.  I t  is  only  as  a  result  of  path  isolation  that  we  can  specify  Pa r  =  P'  

526  M.  D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

--  (T 'U P a'U P j ) .   Consequently the P,'  are pairwise disjoint.  Without  path isolation, we would have to specify P6'  P '  '  '  '  ' 

=  -  P~,  and P6  could then  overlap P2'  U P~  U P [   U P5, making  the  following  proofs  much  more  difficult.  As  an  example,  consider  the  LR(2) 

grammar with productions 

7rl ,  ~r2 : S  --+ Bb  { D  lr~ ,  ~ro : A  --+ a  l ab 
~r~ ,  ~r4 : B  -+  A  I D  ~r~ : D  -+  c 

The rule  m  is not  LR(1) ; thus  H  =  {A}. The Right-Context Extraction Transformation does not alter the grammar, but the Path Isolation Transformation yields 

~r~ ,  ~r2 : S  -+  B'b  [ D  7rs ,  ~r9 : B  --+ A  I D 

~ra ,  r4  : B'  -+  A'  I D'  ~rlo ,  ~rn  : A  --~  a  l ab 
m,  m  : A'  ~  a  I ab  7r~2 : D  -+  c 

~r7  : D v ~c  

and  H'  =  {A'}.  Proceeding with premature scanning, 

T'  =  {Tr,}, 
M ' =   {fib}, P : ' =   / ,  

p:'  =  {~,  ~41, 
and  then 
p 2 H  ~  J~, 

Ps"  =  {[B'b]~[A'b],  [B'b]-->[D'b]}, p['  --  ;~, 

The resulting  grammar is now  LR(1). 

P j   =  {~rs,  m ,   Ir71, P [   =  { ~-~} , 
P~'  =  {~'2,  ~'s,  ~r9,  ~'lo,  lrn,  7r~}, 

Ps"  =  {[A'b]-~ab,  [A'bl-+abb,  [D'bl-+cb}, 

P ,"  =  { S---~[B'b]}, 
P6"  =  { S-+D,  B--+A,  B-+D,  A-+a,  A-+ab,  D--De}. 

Now consider the alteration P6'  =  P'  -  Pi'  and  apply the altered Premature Scanning Transformation  to  the  original  grammar  (without  applying  the  Path  Isolation  Trans- 
formation)  with H'  =  H  =  {A}. 

T'  =  {71"1} 
M '=   {Bb}, P2'=  ~, 

P~'= {~.,  ~r4}, 
(indeed  P6'  N  P3'  ~  ~ ,   P6'  N  P j  
and  then 
P2"  =  ~ ,  
P3"  =  {[Bb]-~[Ab],  [Bb]-+[Db]}, 
P4"  --  ~ ,  

p 4 1  ~  ~, P~'  =  {7r5, lr6,  ~'7}, 

P [=   { ~',}, 
P6'  =  {~'2,  ~'a,  m,  r~,  m,  lr7} 

~ ) ,  

P j '  =  {[Ab]-+ab,  [Ab]-~abb,  [Dbl---~cb}, 
Pi"  =  { S--+[Bb]}, 
P6"  =  { S---,D,  B--~A,  B-+D,  A-+a,  A--+ab,  D-+c}. 

Except  for  renaming  of  nonterminals,  this  grammar  is  the  same  as  that  obtained  by performing  path  isolation  followed  by  premature  scanning.  Thus,  the  Path  Isolation 

Transformation  is  merely  a  convenience,  needed  to  simplify  the  following  proofs.  The simplification  lies  in  noticing  that  premature  scanning  causes  a  nonterminal  symbol 
to be bracketed  in some rule  of P"  (in  either  the  left-part or  the  right-part  of the  rule) if and  only if that  symbol was primed by the Path  Isolation Transformation.  Moreover, 
all  instances  of  primed  symbols  in  rules  of  P'  become bracketed  in  the  corresponding rules of P".  Thus we know that for every A  E N,  a rule of 

P"  can contain some bracketed symbol, 
[Aa],  only if no  rule  of P"  contains  the  symbol A,  and  contrapositively,  A  can appear only if no 

[Aa]  appears. LEMM*  4. 
Let  G  =  (V,2~,P,S)  ( N  =  V  -  ~ )  be a  reduced  A-isolated  L R   ( k )  grammar 
and'let  H  ~  N.  Let  G"  =  (V " , ~ , P " , S )  (N"   =  V"  -  ~)  be  obtained  from  G  and  H  by 

Transforming  LR(k )  Grammars  527 
means  of the Premature  Scanning  Transformation.  Then (a)  L(G")  =  L(G); 

(b)  there is a  surjection,  ~, from  P Z   onto PA such  that if  ~- E  PA" zs not L R ( j )   (3  >  O) then 
(i)  ch(Tr)  E  P  is  not  L R ( j   +  1)  if  ~r E  P2"  U  Pj"  U  P4"  O  P j', (ii)  ~(~r)  E  PA is not L R ( j )   otherwise;  and 

( c )  for each lr  E  P",  if c( ~" )  E  P  is an H-rule,  then either ~r is in P('  O Pj '  O P4"  O Ps" or  Ir is LR(1)  with  respect to  all rules  of G. 
The  relationship  between  G'  of the  transformation  and  G is  given  by  Lemma  3.  We first prove some claims relating G"  to G r. Let a  (mapping V"  into V  U V ~) be defined by 

o'(XEV")  =  { ~a  otherwise,ifX =  [Aa]  is in  W", 
and  extend a  to a  homomorphism from V"* to  V* by 

~r(xy)  =  ~( x) a( y)  for x, y  E  V"*,  c(A)  --  A 
and let  ~,  a  surjection from PA" onto PA, be defined by 

~A--~  a(u)  if a t =   [Aa]--~uais  in P4"O  P j '   (aE2~), )A 

--~ a ( u ) B   if  r  =  [Aa]  ~  u[Ba]  is in P  "  " ~b(~rEPA")  =  2  0  P3  (aEZ), ]A   ---~ a(u)  if ~r =  A  --~ u  is in P , " U   P ,', 

(A  otherwise. 
(The fact that  ~b is a  surjection follows easily by construction.) CLXlM 4.  L(G')  _C L(G"). 

PROOF.  Consider  the  context-sensitive  grammar  obtained  by  deleting  the  brackets from the rules of G". As a result, the equivalent of G' is obtained.  O 
CLAIM 5.  Let  u  E  V"*;  zE  Z*;~-  E  P".  I f   uz  E  CSF(G")  has  handle  ( r,  lut)  then a ( uz )  E  C SF  ( G' )  has  handle  ( ~ ( v ) , p ) , where 

~[o'(u)[  --  1  if  ~" E  P ('  U  P,"  U  P4 t'  O  PJ', P  =  (la(u)] *  otherwise. 
PROOF.  The proof is by induction on the length of the G"-derivation. Basis.  S  E CSF(G")  has  handle  (A,  1)  and  a( S)   =  S  E  CSF(G')  has handle (A,1) 
=  (c( A ), I~ (S )I ) . Induction  step.  Suppose  that  the  claim  holds  for  G"-derivations  of  length  k  (0  _< 
k  <  n)  and consider a derivation of length n  +  1. Then  ~r =  X  --, y with u  =  xy  where X  E  N";  x,y  E  V"*;  and  S  ~ . o ,   xXz  ~  xyz  with  handle  (~,lxyl).  By  the  inductive 

assumption  we have 

S  ~ .o,   c( xXz )   =  o'(xX)z.  (1) 
We have three cases to consider. Casel. 

~r =  A  --~ y  is in  P~"  U  P6".  Then~b(~')  =  A  --~ a(y)  is in P (   U  P6'.  Then (1)  yields  S  ~ , o '   a ( z A ) z   a( x) A z   o" 

~ , ( ~)   a(x) a(y) z  =  a(xy)z.  Thus  a(zyz)  -- a(xy)z  E  CSF(G')  has handle  (cb(lr),  la(xy)I). 

Case  2.  ~- =  [Aa]  ~  w[Ba]  is in  P~"  0  Pa"  (a  E  Z).  Then  $(Ir)  --  A  --~ a ( w) B   is in  P (   U  P3'.  Then  (1)  yields  S  ~ . o ,   a(x[Aa])z  =  a(x) Aaz  ~,(,)o"  a( x)* (w) B az  = 
a(xw)Baz.  Thus  a(xyz)  =  a(xy)z  =  a(xw[Ba])z  =  a(xw)Baz  E  CSF(G')  has  handle 

(c(~-),Ia(xw)B])  =  ( c ( ~ - ) , I a ( x w ) B a l - 1 ) =   ($(~-),la(xy)l-1).' Case  3.  ~-=  [ A a ] ~ w a i s i n P ~ "   U Ps"  ( a E   Z).  Then  eh(~r) =  A  ~ a ( w )   is in 

P~'  U P~'. Then  (1)  yields S  ~*o'  a(x[Aa])z  --  a( x)Aaz  o"  a( x)a(w)az  =  a(xw)az. ~ ( ~ )  Thus  a(xyz)  =  a(xy)z  =  a(xwa)z  --  ~(xw)az  E  CSF(G')  has  handle  (ch(r),la(xw)[) 

=  ( c ( ~ ' ) , l c ( x w ) a l - 1 ) =   (~b(~r),lo'(xy)l-1). 

528  M.  D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

PROOF  OF  LEMM~.  4.  By  Claim  5  applied  to  elements  of L(G")  we have  L(G") L(G'),  and with Claim 4 this yields L(G')  =  L(G").  To prove part  (b)  we use the re- 
sults  of  Claim  5.  Suppose  that  ~" E PA"  is  not  LR(j).  Then there exist x,x'  E  V"*; z,z'  E  ~*;  v'  E P"  for which 

xz  E  CSF(G")  has handle  (~,1~1),  (1) x'z ~ E  CSF(G ~)  has handle  (Ir',{x'I),  (2) 

(i~l+~)XZ ----  (i~l+~)XtZ~,  (3) (~,lxl)  ~  (~',lx'l),  (4) 

As in the  proof of Lemma 2,  we see that  for  7r,  lr'  E  P";  ~"  =  X  ~  y,  ~"  =  X'  ~  y'; if  7r  ~  7r' and  6(~r)  =  ~(~"),  then  y(l~'D ~  y,  (i.e.  neither right-part  is a  suffix of the 

other).  The proof now breaks into cases. Case  1.  7r,  ~-'  E Pi"  Y  Pc"  U  {A}.  By  Claim  5,  a(xz)  E CSF(G')  has  handle 

(4~(Tr),l~(x)I)  and  a(x'z')  E CSF(6')  has  handle  (4,(Tr'),ict(x')I).  Exactly  as  in  the proof of Lemma 2 we find that  ~b(~r) E  Pi'  U P6'  U {A} is not LR(j). 

Case  2.  ~',  7r'  E  P2"  U  P3"  LI  P4"  UPs".  By  Claim4  and  (1),  (2),  a(xz)  = a(x)z  E  CSF(G')  has  handle  (~(Tr),]a(x)]-l)  and  a(x'z')  =  a(x')z'  E  CSF(G')  has 
handle  (~(Tr'),la(x')l-  1). Case 2(a).  Ixl  =  Ix't.  Then  by  (3),  x  =  x'  whence c(x)  --  a(x')  and  (~)z =  (~)z'. 

Thus  ((l'c~)l-~)+~+~)a(xz) =  ((l~(~)H)+l+o)a(x'z'). By  (4),  7r ~  7P'. Now it cannot be that c(~r)  =  c(7r')  since then x  c  x'  (by our observation that neither right-part  is a suffix 
of the  other).  So  ~b(~r) ~  ~b(lr').  Consequently  (6 (Tr),l a(x )i -1)~ (ch (lr'),l a(x ')]-I) and  c(w)  E P~'  U P3'  U P4'  U P j   is not LR(3+I). 

Case 2(b).  Ixl  ~  ]x't.  Just  as case 2(a)  was handled very much like case  1 in  the proof of Lemma 2,  so too,  Case 2(b)  is handled much like cases  2 and 3 in the proof of 
Lemma 2, and we find that  4~(lr)  E P2'  O PJ  U P4'  UPs'  is not L R ( j + I ) .  Case 3.  ~'E  P~"  UPs"  U{A};  ~r'E  P2"  U P J '   U P 4 " U P j .   By Cla im5 and   (1) 
and  (2),  a(xz)  =  a(x)z  E  CSF(G')  has  handle  (~b(Tr),l~r(x)I)  and  a(x'z')  = a(x')z'  E  CSF(G ~) has handle  (~b(~r~),la(x')[-1).  By  (3)  and the fact that  a  preserves 
any terminal suffix of x', we have  (l~c~)l+~)a(xz) =  (l'(~)l+~)a(x'z').  Now it  must be  that ~b(Tr)  ~  6(7r'),  since  P~"  U  P~"-rules  have  unbraeketed  left-parts,  whereas  P~"  U  Pa" 

U P4"  U Pjf-rules have bracketed left-parts. If it were that ~b(~r) =  ~b(~r') then  ~" would be  of the  form A  -~  y  and  7r' of the  form [Aa] --~ y';  but  as  a  result  of Path  Isolation, 
nonterminal symbols cannot be both  bracketed  and unbracketed  in N".  Thus  ~b(Tr) ~(~")  and  (4~(~r),la(x)l)  ~  (~b(~r'),la(x')I-1)  and  ~(~r)  E Pi'  U  P~'  U  {A}  is  not 
LR(2). Case 4.  ~- E P~"  U P~"'U  P4"  U P j' ;  ~-' E P,"  U P~"  U  {A}.  By Claim 5  and  (1) 
and  (2),  c(xz)  =  c(x)z  E  CSF(G')  has  handle  (~b(~'),lc(x)l-1)  and  c(x'z')  -- a(x')z'  E CSF(G')  has  handle  (c(~r'),lz(x')l).  By  (3)  and  the  fact  that  ~  preserves 
any terminal suffix of x', we have ((~(~)l-')+~+~)~(xz) =  (('~(~)l-1)+~+~)(~(x'z'). As in case 3, ~b(Tr)  ~  ~b(~r') whence  (4,(~r),la(z)l--1)  ~  (~(~'),1~(~')1)  and  ~b(~r) E  P~'  U  P~'  0 
P4'  U P~' is not  L R ( j +  I). Part  (c)  of Lemma 4  follows by  construction, part  (e)  of Lemma 3,  and part  (b)  of 

Lemma 4. This completes the proof of Lemma 4.  [] Although we are now ready to describe an LR(k)  to L R ( k - 1 )   algorithm for reduced, 
A-isolated  grammars,  we  cannot  yet  describe  the  LR(k)  to  LR(1)  algorithm.  While such-an  algorithm is  simply  an  iterative  version  of  LR(k)  to  LR(k--1),  it  must  also 
account for the possibility that, between iterations, the Right-Context Extraction Trans- formation  may introduce new  A-rules,  destroying the  A-isolation property.  Thus,  it  is 
necessary to  perform yet  another transformation, removing A-rules,  to  recover  a  A-iso- lated grammar.  The standard  A-elimination algorithm for CFGs  (cf. Hopcroft and Ull- 

man  [14, pp.  62,  63])  may be  used.  The  transformation  (which  we  call  a  "A-Isolation 

Transforming  LR ( k )  Grammars  529 
Transformation")  preserves both  the language  (modulo  A)  and the right-context bound (ef.  Graham  [10, Cor.  4.4]). 

Finally,  we  can  present  the  procedure  for  reducing  the  right-context  bound  of  an LR(k)  grammar.  We  have  parameterized  the  algorithm  by  specifying  that  it  should 
hMt  after having  obtained  an  LR(p)  grammar. 

Look-Ahead  Reduction  Procedure.  Given an  LR(k)  grammar, G  =  ( V,Z,P,S), 

f o r i : =   k- -   l d o w n t o p  (1)  Apply  the  A-Isolation  Transformation  to  G,  obtaining  G ' =   (V',~,P',S') 

( N ' =   V'  -  Z). (2)  Compute H'  = 

{ A E N '   ] some A-rule of P'  is not  LR(,)}. (3)  Apply  the  Premature  Scanning  Transformation  to  G'  and  H',  obtaining  a  new 

grammar, G  =  (V,~,P,S). ha l t 

THEOREM 1.  Let  G  =  (V,Z,P,S)  be a  CFG.  I f   G  is LR ( k )   for  some  k,  then  the Look- 
Ahead  Reduction  Procedure  halts  for  p  >_  1,  yielding  an  L R ( p )   grammar  G"  for  whwh L(G")  =  L(G). 

PROOF.  The  fact  that  L(G")  =  L(G)  is  clear  from  Lemma  4.  Thus,  to  prove  the theorem, it is sufficient to show that the  ( k - j ) - t h   iteration of the Look-Ahead Reduction 
Algorithm  effectively  converts  an  L R ( j + I )   grammar,  G,  to  an  LR(.7)  grammar,  G". The  ( k- 3)- t h  iteration  certainly halts  since the  transformations each involve only finite 

computations  on  finite  grammars.  Moreover,  the  A-Isolation  Transformation  preserves the  right-context  bound.  Suppose  that  after  applying  the  Premature  Scanning  Trans- 
formation,  G"  is  not  LR(j)  (j  >  1).  Then  there  is  some  rule,  cr E  Ptf,  which  is  not LR(3).  Consider  the  partitioning  of P",  (Pi ~,  P2",  P3",  P4",  PJ',  P6 '~)  accomplished by 
premature  scanning.  It  cannot  be  that  ~r  =  A  since  then  (by  Lemma  4),  c(Ir)  =  A is not  LR(j)  (j  >  1)  whence  G'  and  G are not  LR(k)  for  affy k,  contradicting  the  hy- 
pothesis that  G is LR(k). It  cannot  be  that  7r E  P2"  U  P3"  U  P4"  (J  P J   since  then  (by  Lemma 4)  ~b(~')  E  P' 
is  not  L R ( j + I ) ,   contradicting  the  hypothesis  that  G  and  G'  are  L R ( 3 + I ) .  Thus,  7r E  Pi"  I.J P6".  But  then  (by Lemma 4),  ~b(Ir)  E  P'  is not  LR(j),  and by step 2 
of  the  Look-Ahead  Reduction  Procedure,  4~(~r)  is  an  H'-rule.  Then  (by  Lemma  4), either  7r is  LR(1)  with  respect  to  all  rules  of G"  or  ~r E  P2"  lJ  P j '   U P j '   O PJ',  each 

of which again leads to a contradiction.  Thus it must be that  after the  ( k - 3 ) - t h  iteration, each rule  lr of P"  is LR(j)  with  respect to  all rules  of G f   [] 

It   is natural  to  ask under  what  conditions  the  Look-Ahead Reduction  Procedure  will halt  for  p  =  0,  yielding  an  LR(0)  grammar.  Clearly  this  would  follow  if  part  (c)  of 
Lemma 4  were to read: ( c)  for each ~r E  P",  if oh(7r)  E  P  is an H-rule,  then either  7r is in P2"  U P3"  U P4"  UPs" 

or  Ir is  LR(0)  with  respect  to all  rules  of G. This in  turn  would  follow if part  (c)  of Lemma 3  were to  read: 
(c)  G"  is  in  H"-right-context-extracted  form  where for  each  ~r E  P",  if  c( ~r)  E  P  ~s an H-rule,  then either  ~r is an H"-rule  or ~r is LR(0)  with respect to all rules of G. 
There is a  quite simple language constraint  which is sufficient to yield these strengthened conclusions. 

THEOREM 2.  Let  G  =  (V,Z,P,S)  be  a  CFG.  I f   G  ~s LR ( k)   for  some  I~ and  L(G)   ~s prefix-free, s then  the  Look-Ahead  Reduction  Procedure  halts for  p  ~_  O,  y,eldmg  an  L R ( p )  
grammar,  G", for  which  L( G")  =  L( G). PROOF.  In view of the proofs of Lemma 4 and Theorem 1, it is necessary to show that 
the prefix-free condition  on L(G)  is sufficient to yield the cited modification to Lemma 3. 
s A language, L CZ*, is said to be prefix-free  [13] if and only if x  E L and xy  E L  implies y  =  A. 

530  M.D.  MICKUNAS,  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 
Suppose  (within  the  hypotheses  of Lemma 3  and  the  prefix-free hypothesis)  that  ~r  -- A  --~ v in P"  is not an//"-rule,  but  that  c(7r)  is an//-rule.  As in  the proof of Lemma 3, 
since  by  construction  G"  is  in  H"-right-context-extracted  form,  it  follows  that  ~r can occur only in derivations like 

S  =**o. uA  ~ o .   uv with  handle  (Tr,[uv[).  (1) 
Suppose that  lr is not LR(0).  Then there exist w  E  Z* and  7r'  E  P"  for which 

uvw  E  CSF(G")  has handle  (Tr', j)  (2) 
and 

(~-,luvl)  c  (Ir',3).  (3) 
Since  G"  is  reduced,  it  follows  that  there  exists  y  E  2"  for  which  uv  ~. a,   Y.  Then  by (1)  and  (2),  y  E L(G")  and  yw  E L(G").  Since L(G)  =  L(G")  is prefix-free it  follows 

that  w  =  A.  But  then,  by  (1),  (2),  and  (3),  we  find  that  ~- is  not  LR(k)  for  any k. Thus,  by part  (b)  of Lemma 3,  we are led  to  the  contradiction  that  c,(7r)  is not  LR(k) 

for any k.  [] 
4.  Concluding Remarks 

We have presented  a number of the preceding transformations separately for the  sake of proving  them  correct.  However,  in  practice,  some  economization  is  possible.  We  have 

already  remarked  that  the  Path  Isolation  Transformation  followed  by  the  Premature Scannnig  Transformation  can  be  combined  into  a  single  modification  of  the  Premature 
Scanning  Transformation  in  which  we  define  P~'  =  P'  -  Pl'  instead  of  P~'  =  P'  -- (T'  U P3'  U P j ) .   However, it is more difficult to prove that  the  modified version works 

correctly.  Another  simplification  is  possible  in  the  Look-Ahead  Reduction  Procedure. The  modified procedure is: 

Given  an  LR(k)  grammar, G, 
while  G is not  LR(p) (1)  Apply  the  A-Isolation  Transformation  to  G,  yielding  G '=   (V',~,P',S') 

(N'  =  V ' - ~ ) .  (2)  C om p u t e / / '  as  some  (arbitrary,  but  nonempty)  subset  of  {AEN'  ] some  A-rule 
of P'  is not  LR(p)}. (3)  Apply  the  Premature  Scanning  Transformation  to  G'  and  H',  yielding  a  new 
grammar, G  =  (V,Z,P,S) hal t 

It is a very difficult task to prove that  this modified Look-Ahead Reduction  Procedure halts  (and  we  have  not  tried  to  do  so).  However,  we  think  that  this  version  is  compu- 
tationally  more  efficient  than  the  original  algorithm  (if  for  no  other  reason  than  the simplified  need  to  detect  only  non-LR(p)  (p  =  0  or  1)  instead  cf  non-LR(~)  rules). 
In  our  implementation  [19-22,  24]  we  stop  at  the  first  encountered  non-LR(p)  rule, A  --~ u,  and  set H  =  [A]. 

In  our  preliminary  remarks,  we  noted  that  it  is  not  necessary  to  apply  premature scanning  to  all  extracted  right-contexts,  but  only  to  those  which  are  involved  in  non- 
LR(p)  conflicts.  The  modification  that  is  needed  in  the  Premature  Scanning  Transfor- mation is to change  the  definition  of the  set  T'  to 

T'  =  {A--~uBav  [ a E ~; Bp*H';  and a  is a  conflicting right-context for some H'-rule}. 
Theorem  2  asserts that  if L(G)  is prefix-free  (and  G is  LR(k))  then  the  Look-Ahead Reduction  Procedure is capable of producing  an equivalent  LR(0)  grammar.  We remind 

the  reader  that  any  language  can  be  made  prefix-free by  the  concatenation  of  an  end- 

Transforming  LR(k)  Grammars  531 
marker  to  each  sentence  of the  language.  Formally,  let  G  =  ( V , Z, P , S)  be  a  CFG  and let  S'  and  $  be  symbols  not  in  V.  Then  for 

G '=   (VU{S',S},~U{$},PU{S'--~S$1,S'), 
L(G')  is prefix-free. Geller and  Harrison  [7]  call  such  a  grammar,  G', the  "S-augmented grammar of G."  In  practice,  virtually  all programming languages have such  endmarkers 

(e.g.  "end-of-record mark"). 

An  interesting  side  effect  of  the  Look-Ahead  Reduction  Procedure  is  that  it  can  be modified  to  yield  a  grammar  in  DeRemer's  "simple"  LR(1)  (SLR(1))  form  [3,  4]. 

The  modified procedure is: Given  an  LR(k)  grammar,  G, 

while  G is not  SLR(1) (1)  Apply  the  A-Isolation  Transformation  to  G,  yielding 

G'=   (V ', X , P' , S') 
( N' =  V '-   ~).  (2)  Compute 

H'  as  some  (arbitrary,  but  nonempty)  subset  of  {A EN'  t some A-rule of 
P'  is not  SLR(1)}. (3)  Apply  the  Premature  Scanning  Transformation  to 

G'  and  H',  yielding  a  new grammar, 
G  =  (V , Z, P , S ).  halt  

Although  this procedure  will  often halt  for an  arbitrary  LR(k)  grammar, G, halting is guaranteed  only if 

L (G )  is prefix-free. That  is, in  some cases,  an  LR(0),  hence  SLR(0) (see  [3, 4]),  hence  SLR(1)  grammar is the  best  that  can be obtained.  As  an  example of 

conversion  to  SLR(1),  consider  the  LR(1)  grammar  with  the  following  productions. This  grammar is not  SLR(k)  for any integer,  k. 

* "1,  ~r2,  ~'~  :  S-~ aA a l aB b l bB a  Ir4 ,  ~'5 : 

A -- -~ c l c A  
~r6 ,1r~  :  B  --~ c  I cB 

Rules  ~-4 and  ~'6 are not  SLR(1).  Suppose  that  we  compute H  =  {B}. No  right-context extraction is required.  After premature scanning of the  conflicting right-contexts  (merely 

the rightmost a  of ~'3), we obtain the grammar with productions 

! * "1',  Ir2;  Ir3."  S  ~  aAa  I aBb  I b[Ba],  7r6, ~'7':,  B  ~  c IcB 

m,   ~r5 :  A  --~  c  l cA  ~'s ,  ~r9 :  [Ba]  ~  ca[  c[Ba] 
which is SLR(1). In  our  implementation,  we  require  a  (1,  1)  bounded  right-context  (BRC)  grammar, 

which is obtained from an LR(k)  grammar by  (1)  transforming to SLR(1)  via the above algorithm,  and  then  (2)  transforming  to  (1,  1)  BRC  by  a  scheme that  is much  like the 
one presented by Graham [9]. Consider once again the grammar with productions 7rl,  * * * , lr7  above.  Using  Graham's  original  scheme  [9], "state  splitting"  is  used  to  obtain  the 
SLR(1)  grammar with  productions 

S  ~  aAa  l aBb  l bB'a  B  ~  c  l cB 
A  ~  c  l cA  B'  --~ c  I cB' 

and subsequently,  one obtains the  (1,  1 ) BRC grammar with productions 

S  ~  aAa  I aBb  I bB'a  B'  ~  c  I CB' 
A  --~ c  l c A  C  ---~ c 
B - -~ c [   cB 

In  her  more recent  work  [10], Graham  shows how  to  directly  obtain  (1,  1)  BRC  from LR(1),  but  to obtain  a  grammar of reasonable size requires  considerable optimization of 

the  transformation. With  our  implementation  we  first  obtain  the  SLR(1)  grammar  with  productions 

532  M.  D.  MICKUNAS~  R.  L.  LANCASTER,  AND  V.  B.  SCHNEIDER 

* ",',  . . .   , ~rg' above, and subsequently the  (1,  1) BRC grammar with productions 

S  --~ aAa  I aBb  I b[Ba]  [Ba]  --~ ca I C[Ba] 
A  -*  c  l c A  C  --~ c 
B - - ~ c l c B  

Our final observation concerns the  relation of  these  transformations to  the  notion of 
grammatical  covers  (originally due  to  Reynolds  and  Haskell  [23]).  Gray  and Harrison 

[11] present  a  definition of cover which is similar to  the  following. 

Let  G  =  (V ,Z ,P ,S)  and  G" =  (V ",Z,P ",S)  be  CFGs  and  let  ~/, be  a  mapping from 
P"  to  PA.  Extend  ~b to  a  homomorphism from  P ' *   to  P*  by  requiring ~b(A)  =  A  and 
for  x,y  E  P",  ~b(xy)  =  ~b(x)~b(y).  G"  is said to  completely cover  G  under  c  if and only if 

(a)  L(G")  =  L(G);  and 
(b)  for  each  x  E  L(G),  (i)  if  S  ~ , ) ; , ~   x then there  exist  (Tr,'~)~_, in p~,m (m  >  n) 

*  *G w  I!  m  n  *G #  *o forwhmhS ~ ( ' , ' ) 5 ~   x and ~b ((lr,),-1)  =  (~r,),-1,  (it) if S ~(',')7-~ x then S ~((,,,)~,_,)  x. 

Gray  and  H arrison actually present  a  more  general notion within which  a  G'-deriva- 
tion  may  induce  (via  ~)  only  a  portion  of  the  corresponding  G-derivation.  In  their 
terminology, "sparse"  G-derivations are  covered. 

We  note  that,  with  the  exception  of  A-Isolation, each  transformation presented  here 
produces  as  output  a  grammar  G"  which  completely covers  the  input  grammar,  G.  In 

each  case,  a  simple  modification  of  the  associated  surjection,  ~,  provides  the  cover 
mapping,  ~b from  P"  to  PA.  For  the  A-Isolation Transformation,  a  sparse  covering  is 
accomplished.  The  only  portions  of  input  grammar  derivations  which  are  not  covered 
are  subderivations which lead  to  A.  We have  found that,  in practice,  it  is quite  easy to 
relocate any semantic actions that  may have been associated with such neglected A-sub- 
derivations. 

REFERENCES 
(Note.  References  [2, 8, 15] are  not cited  m  the text ) 

1.  AHO, A V , DENNING, P J., AND ULLMAN, J.D  Weak and mixed strategy precedence parsing. J  ACM  19, 2  (April 1972), 225-243. 

2  AHo, A.V ,  AND  ULLMAN,  J.D.  The  Theory  of Parszng,  Translatwn,  and  Comp~hng,  Vol. Prentice-Hall, Englewood Cliffs, N.J,  1973. 
3  D~R~MER, F L.  Practical translators for LR(k) languages  Doctoral DiNs , M I T  , Cambridge, Mass,  Sept.  1969 
4  DEREM~R, F.L  S:mple LR(k)  grammars. Comm. ACM 14, 7 (July 1971), 453---460. 5.  FLOYD, R W  Syntactic analysis and operator  precedence  J.  ACM 10, 3 (July 1963), 316-333 

6.  FLOYD, R.W.  Bounded-context  syntactic analysis  Comm. ACM 7, 2 (Feb  1964), 62-67 7.  GELLER, M.M,  AND HARRISON, M A  Characterizations of  LR(0)  languages  (extended  ab- 

stract)  Proc.  of  the  14th Ann  Symp  on Switching  and Automata Theory,  Iowa  City,  Ia, Oct.  1973, pp.  103-108 (sponsored by IEEE, New York) 

GINSBURG, S , AND GREIBACH, S A.  Deterministic context-free  languages.  Inform.  and  Contr. 9 (1966), 620-648. 
GRAHAM, S.L.  Precedence  languages  and  bounded right  context languages  Doctoral  DiNs , Stanford U,  Stanford, Calif.,  July 1971 
GRAHAM, S L.  On bounded right context languages and grammars.  SIAM  J.  Comput.  ~ (1974), 224-254. 
GRAY, J N  , AND HARRISON, M.A  On the  covering  and reduction problems  for  context-free grammars,  J. ACM  19, 4  (Oct. 1972), 675-698 
HARRISON, M.A.  On  the  parsing  of  deterministic  languages.  Inv:ted  presentation,  ACM Comput.  Sci. Conf, Columbus, Ohio, 1973 (oral presentatmn) 
HARRISON, M.A, AND H~VEL, I.M.  Strict determmmtlc  grammars  J  Comput  and Syst. Scls. 7 (1973), 237-277 
HOPCROFT, J.E.,  AND ULLMAN, J  D.  Formal Languages  and  Their Relatzon to Automata  Addi- son-Wesley, Reading,  Mass.,  1969 

8 
9. 
10. 
11 
12 
13. 
14. 

Transforming  LR( k )  Grammars  533 
15  ICHBIAH, J.D  ,  AND MORSE,  S P  A  technique  for  generating  almost  optimal  Floyd-Evans productions for precedence grammars. Comm ACM 13, 8  (Aug. 1970), 501-508. 

16.  KNUTH, D.E  On the translation of languages from left to right. Inform.  and Contr. 8 (1965), 

607-639. 17.  LA.LONDE, W R  An  efficmnt LALR  parser  generator  Tech.  Rep  CSRG-2,  U  of  Toronto, 

Toronto, Ont  , Canada,  1971 18.  McAFEE, 

J.,  AND PRESSER,  L.  An  algorithm for  the  design of simple precedence grammars J  ACM 19, 3  (July  1972), 385-395. 

19  MICKUNAS, M.D  User's manual for the PUCSD parser generating system. Tech  Rep, Purdue 

U., West Lafayette,  Ind., Aug.  1973. 20  MICKUNAS, M.D  Techmques  for  compressing  bounded-context  aceeptors.  Doctoral  DiNs., 

Purdue U  , West Lafayette, Ind  , May  1973. 21.  MICKUNAS, M D., AND SCHNEIDER, V.B.  On the ability to cover LR(k)  grammars with  LR(1), 
SLR(1), and  (1, 1) bounded-context grammars  Proc  of the 14th Ann  Symp. on  Switching and Automata  Theory,  Iowa  City,  Ia,  Oct  1973, pp.  109-121  (sponsored  by  IEEE,  New  York). 
22.  MICKUNAS, M  D ,   XND  SCHNEIDER,  V.B.  A  parser-generating system  for  constructing com- pressed compilers  Comm ACM i6, 11  (Nov. 1973), 669-676 
23  REYNOLDS, J.C.,  AND HASKELL, R.  Grammatical  coverings  Unpublished manuscript,  1970 24  SCHNEIDER, V.B.  A system for designing fast programminglanguage translators  Proc.AFIPS 

1969 SJCC,  Vol. 34, AFIPS Press, Montvale, N  J.,  pp. 777-792. 25  WIRTH, N  , 

AND WEBER,  H.  EULER:  a  generalization of ALGOL  and  its  formal  defimtlon: Parts I, II. Comm. ACM 9, 1, 2 (Jan  , Feb. 1966), 13-23, 25, 89-99 

RECEIVED MAY  1973; REVISED NOVEMBER 1975 

Journal of the Asscemtlon for Computing Machinery, Vol 23, No 3, July 1976 