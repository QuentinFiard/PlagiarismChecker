

Proceedings of the IEEE Symposium on Security and Privacy, May 1998, Oakland, California
Complete, Safe Information Flow with Decentralized Labels

Andrew C. Myers Barbara Liskov

MIT Laboratory for Computer Science545 Technology Square, Cambridge, MA 02139

fandru,liskovg@lcs.mit.edu

Abstract

The growing use of mobile code in downloaded appli-cations and servlets has increased interest in robust mechanisms for ensuring privacy and secrecy. Information flowcontrol is intended to directly address privacy and secrecy
concerns, but most information flow models are too restric-tive to be widely used. The

decentralized label model is anew information flow model that extends traditional models

with per-principal information flow policies and also per-mits a safe form of declassification. This paper extends this
new model further, making it more flexible and expressive.We define a new formal semantics for decentralized labels
and a corresponding new rule for relabeling data that is bothsound and complete. We also show that these extensions
preserve the ability to statically check information flow.
1 Introduction

The growing use of mobile code in downloaded appli-cations and servlets has increased interest in robust mechanisms for ensuring privacy and secrecy. A key problemis that information must be shared with downloaded code,
while preventing that code from leaking the information. In-formation flow control is intended to address these privacy
and secrecy concerns, but most information flow models aretoo restrictive to be widely used. This paper increases the
power of a promising new model, the decentralized label
model [ML97], making it more practical and useful.Our goal is to check information flow by a straightforward static analysis of annotated program code. The ideais for a node to share information with a downloaded applet
or uploaded servlet, yet prevent the mobile code from leak-ing the information; additionally, the applet or servlet could
be protected from leaking its private information to other
This research is supported by DARPA Contract F30602-96-C-0303, mon-itored by USAF Rome Laboratory. Andrew Myers is also supported by an
Intel fellowship.Web page: www.pmg.lcs.mit.edu
Copyright 1998 IEEE. Published in the Proceedings of S&P'98, 3-6 May1998 in Oakland, California.

programs running on the same node.The decentralized label model makes a good basis for
information flow control because it improves on earlier mod-els in several ways:

ffl It allows individual principals to attach flow policies topieces of data. The flow policies of all principals are

reflected in the label of the data, and the system guaranteesthat all the policies are obeyed simultaneously. Therefore,
the model works even when the principals do not trust eachother.

ffl The model allows individual principals to declassify labelsby modifying their own flow policies. Arbitrary declassification is not possible because flow policies of otherprincipals are still maintained. Declassification permits
the programmer to remove restrictions when appropriate;for example, the programmer might determine that the
amount of information being leaked is inconsequential.Previous work on information flow did not allow any declassifications within the model.
ffl It is compatible with static checking of information flow.Static analysis is required to prevent leakage of information through implicit flows, and to provide practical fine-grained control over information flow [DD77]. However,
unless care is taken, static checking will be so restrictive asto make the model unusable. Our previous work [ML97]
makes static analysis more expressive by supporting la-bel polymorphism and safe run-time label checking. We
have also demonstrated that label inference can be usedto reduce the burden of adding static information flow
annotations to a program.

This paper extends our previous work on decentralizedlabels to make the label system more flexible, while retaining the advantages we have just described. We make thefollowing contributions here:

ffl We extend the model to allow safe relabelings that theprevious work does not permit.
ffl We provide a formal definition of the model that allowsus to define exactly what relabelings are legal. Our model

1

differs from earlier models [Den76, MMN90] becauseearlier approaches cannot deal with some safe relabelings
that rely on relationships between different principals.
ffl We define a rule for static checking and prove that the ruleis both sound and complete: it allows only safe relabelings, and it allows all safe relabelings.
ffl We also show that label checking and label inference canbe done easily and efficiently using the new rule.

The rest of this paper is organized as follows. In Sec-tion 2, we briefly review the decentralized label model and
show that it does not allow certain useful, intuitively saferelabelings. Section 3 provides a formal model for labels;
it explains how a label can be interpreted as a set of flowsand uses this to define legal relabelings. Section 4 sketches
programming language annotations that permit static flowchecking, presents the static relabeling rule and proves that
it is both sound and complete, and shows that the relabelingrule can be used to statically analyze code with the annotations described. Related work is discussed in Section 5,and we conclude in Section 6.

2 Decentralized labels

This section provides a brief summary of the decen-tralized label model [ML97]. It also explains why its rules
are too restrictive and what kinds of less restrictive rules aredesirable.

2.1 Model

The decentralized label model is based on a notion oflabels that allow individual owners of information to express
their own policies. Owners are principals: identifiers repre-senting users and other authority entities such as groups or
roles. Some principals are authorized to act for other princi-pals; this information is maintained in a

principal hierarchydatabase. We assume that the principal hierarchy changes

over time but that revocations occur infrequently. Also, atany moment, a process has the authority to act on behalf of
some (possibly empty) set of principals.Every value used or computed in a program execution
has an associated label. A label L contains a set of own-ers, owners

(L); these are the principals whose data wasobserved in order to obtain that value. In addition, for each

owner O, the label contains a set of readers, readers(L; O);these are the principals that

O allows to observe the value.Observations happen when values are written to

outputchannels. Each output channel
C has an associated set ofreaders; these are the principals who will be able to observe

information written to that channel (e.g., the people that haveaccess to a printer). A value can be written to a channel only

if each reader of the channel has the authority to act for somereader in the

effective readers set of the value's label. Theeffective readers set is the intersection of all the reader sets

in the label. Restricting writing to channels like this ensuresthat each owner's policy is obeyed.

For example, for the label L = fo1: r1; r2; o2: r2; r3gwe have:

owners(L) = fo1; o2g
readers(L; o1) = fr1; r2g
readers(L; o2) = fr2; r3g
effectiveReaders(L) = fr2g

and a value labeled by L can be written to channel C pro-vided all of

C's readers can act for r2.In this model, every variable and input channel has a

label. When a value is read from a variable or input channel,it acquires its label. When a value is written to a variable,
the value's current label is forgotten; instead, it acquiresthe label of that variable. Therefore, assignment effectively
creates a new copy of a value with a different label; to avoidinformation leaks, our rule requires that the new label must
be the same as or more restrictive than the old one. (Changesin who can use information in a variable are accomplished
by modifying the principal hierarchy.)Assignment causes a

relabeling of the value that isassigned. This kind of relabeling is termed a restriction. A

relabeling is a restriction if the new label contains all theowners of the original, and the same or fewer readers for
each owner. A restriction can be performed by any process,no matter what its authority. The expression

L1 v L2 meansthat
L1 is less restrictive than or equal to L2, and that valuescan be relabeled from label

L1 to label L2.Values may also be relabeled by

declassification, whichreduces restrictiveness by removing an owner or adding a

reader for an owner. Declassification can be performed onlyby a process with the authority to act for the owner whose
policy is being changed; it requires a run-time check for theproper authority. The important point is that declassification
cannot affect the policies of owners the process does notact for; since reading only occurs by the consensus of all
owners, this limited declassification is safe.Computations (such as multiplying two numbers) cause
joining (t) of labels; the label of the result is the leastrestrictive label that reflects the policies in the labels of the
values used in the computation:

owners(L1 t L2) = owners(L1) [ owners(L2)
readers(L1 t L2; O) = readers(L1; O) " readers(L2; O)

These rules follow from the definition of v. Label inferencealso requires that the

meet (u) of two labels be determinable;
A u B is the most restrictive label that can be be relabeledto both

A and B. Its definition is dual to that of join.

2

patient record
{ patient_A: patient_A, doctors }

{ patient_A: patient_A }
{ HMO_records: HMO }

HMO confidential

patient confidential

general information

authorizeddeclassification
procedurepatient_A

doctor_B

authorization

display device

{doctor_B}

doctor's reportto HMO
{ patient_A: patient_A;     HMO_records: doctor_B }

HMO Auditing report

{patient_A: patient_A}

HMOlogs

{HMO_records: HMO}

patient_A: patient_A, doctor_B

HMO_records: HMO, doctor_B

edited copy of patient record

patient_A: patient_A, doctors

Figure 1: The patient/doctor example
doctors
doctor_A doctor_B

HMO
HMO_records
patient_A patient_B

acts for

Figure 2: The patient/doctor principal hierarchy
2.2 Example

This section gives an example to illustrate the model.In the example, there are three parties with privacy concerns: a patient obtaining medical services, a doctor pro-viding the services, and an HMO that serves as an intermediary. There are principals in the system for patients,e.g.,

patient A, and doctors, e.g., doctor B; all doctors canadditionally act for

doctors, which stands for the group ofdoctors within the HMO. Also, there are two HMO principals: HMO, representing maximum authority within theHMO, and

HMO records, representing authority over therecord-keeping functions of the HMO;

HMO can act for

HMO records, and HMO records can act for patients: eachpatient must trust the HMO to keep track of its records. The
resulting principal hierarchy is shown in Figure 2.Figure 1 shows the system. The HMO maintains the
patient's medical history; the example tracks informationflow as the patient receives medical services. The patient
record has three parts: general information about the patient,which is controlled by the patient but is readable by any
doctor, private information (such as the medical history),which is normally not readable by doctors, and confidential
information that the HMO does not release to patients.The first step in a patient/doctor interaction is for the
doctor to obtain a copy of the patient's record. The recordis declassified so that the doctor can read it; this can only
happen with the authorization of the patient. The patientmakes an authenticated request to an existing program running with the authority of HMO records; this program usesthe patient's authority to provide the doctor with an edited
version of patient's private information and of the HMOconfidential information.

To read the information, the doctor requires an outputchannel to a display device with the single reader,

doctor B.

3

All information in the edited patient record can be writtento such a channel, since

doctor B can act for doctors. Thechannel is created by code that authenticates

doctor B. Notethat the patient information cannot be written to a channel

that has any readers other than doctor B, and that there isno way the doctor can declassify the patient information.

Eventually, the doctor sends a report to the HMO ofservices rendered. The report reflects all three components
of the patient's record, so it acquires a joint label reflectingall these sources. Note that the joint label prevents the
doctor from reading his own report, because the generalpatient information does not explicitly permit

doctor B as areader. This is an example of unnecessary restrictiveness in

the model.The audit program runs with the authority of the
HMO records principal and thus can store the informationwith the appropriate labels in the log and the patient record
database. It can also send a report to the patient; the de-signer of the audit program must use mechanisms outside
the scope of information flow control to determine eitherthat no HMO-confidential information is leaked or that the
leak is acceptably small.
2.3 Limitations of the model

The rule for restrictions described earlier is not as gen-eral as we would like; it prevents us from doing valid relabelings that would simplify the example just presented.There are two kinds of such relabelings, both based on the
existence of an acts-for relationship between principals.
ffl Adding readers. We should be able to add a reader rfor some owner

o if o already allows some reader r0 that
r acts for. This rule makes sense because allowing r0 toread allows all principals that act for

r0 to read.

ffl Replacing owners. We should be able to replace an owner

o0 with some principal o that can act for o0. This rulemakes sense because the new label only allows a process

that acts for o to declassify it, while the original labelallowed processes with weaker authority to declassify it.

If we allow adding readers, the doctor in the exampleis able to view his own report. The confidential patient
information has the label fpatient A: patient A,doctorsg,which allows any doctor to view the data item, and therefore we ought to be able to relabel the item to explicitlyallow a particular doctor to view it,

e.g., fpatient A: patient A,doctor Bg. Since doctor B is then a reader forevery component of the joint label, he can view the report.

If we allow replacing owners, it has the advantage thatthe special rule of Section 2 is not needed for output channels; they can be treated as ordinary variables. Using theauthority of the HMO, the display device can be assigned

the label fHMO: doctor Bg. This labeling will allow allthe information in the patient's record to be transmitted to
the display device. The label fHMO: doctor Bg means thatthe HMO has certified that

doctor B is the only reader onthis channel. There is no global notion of the readers of

the channel; data owned by an owner o can only be writtento this channel if

o trusts the HMO (that is, HMO can actfor
o). The original trusted channels are easily modeled byassigning them the owner

root (i.e., a high-level principal).Relabelings that add readers or replace owners can be

done already, but only by a process with sufficient authority,using the declassification mechanism. Since the relabelings
are restrictions, they ought not to require authority (althoughthey do require a run-time check to determine whether a
principal can act for another principal). We can use theserelabelings to write useful procedures that run with minimal
authority, observing the principle of least privilege [Sal74].Providing these extensions also makes it easier to model
desirable security policies. For example, suppose that a userwants to define security classes in a multi-level fashion: his
own personal unclassified, classified, and secret classes forprotecting his data. With these extensions, these three security classes can be represented as principals in the system,where the

secret principal can act for classified, and classified for unclassified. The user can then assign securityclasses to other principals in the system by allowing them

to act for one of these three principals; he correspondinglymarks each data item as readable by the appropriate security
class principal.It is not trivial to extend the relabeling rule to permit
these relabelings, because we want to preserve the abil-ity to statically analyze information flow. As pointed out
by Denning and Denning [DD77], information flow shouldbe checked statically (

e.g., at compile time) to avoid leaksthrough implicit flows. The new relabelings above depend

on the principal hierarchy as it exists at run time, and thisstructure cannot be known at compile time. So we need to be
sure that any assumptions about the hierarchy that are usedduring compile time checking are valid for

all hierarchiesthat might be encountered at run time.

We solve this problem in two steps. In Section 3 wegive a formal model for labels that allows us to define legal
relabelings. Then in Section 4 we define the rules for staticchecking and show that they are both sound and complete.

3 Extending and interpreting labels

The new relabelings depend on the existence of certainacts-for relationships, and therefore we need a rule that
takes the principal hierarchy into account. In this section,we formalize the notions of labels and principal hierarchies
and then define an intuitive condition for judging whether arelabeling rule is correct.

4

3.1 Generalizing labels

We will generalize the label model slightly, to allow anowner to be repeated within a label. (In Section 2, a label
was characterized by an owner set in which each owningprincipal could only appear once, with its associated reader
set.) As we will see later, allowing duplicate owners isimportant for maintaining the lattice structure of labels.

A label is a set of components, each of which expressesa
policy for a single owner. The policy specifies a set ofreaders that are permitted by the owner to read the data.

Different components of the label may have the same owner.The intuitive meaning of a label is that every component
must be obeyed. If a component K is part of the label L
(K 2 L), then we will use the notation oK to denote theowner of that component, and the notation

RK to denote the
set of readers specified by that component. In the equationsin this paper, the letters

I, J, K will always denote labelcomponents.

3.2 Principal hierarchy

The principal hierarchy is defined by the acts-for re-lations between principals in the system. If

x can act for
y, we will denote this fact by the expression x * y. Thebinary relation

* is reflexive and transitive, but not anti-symmetric: two distinct principals may act for each other,

in which case we say that the principals are equivalent. Weuse the notation

P ` x * y to indicate that in the principalhierarchy
P , the principal x can act for the principal y.A principal hierarchy is a binary relation on principals,

and can therefore be treated as a set of ordered pairs ofprincipals that specifies all relations that exist. With this
interpretation, P ` x * y is equivalent to (x; y) 2 P .When one principal hierarchy

P 0 contains more acts-forrelations than another,
P , we will say that P 0 extends P ,which we will write as
P 0 ' P .This model of principals is easily generalized. One

obvious extension is to divide acts-for into more finely-grained (but transitive) authorizations. For example, all
individual doctors might be able to read information forwhich

doctors is an allowed reader, but they might not allbe able to declassify information owned by that principal.

This would help control the information if a doctor wereejected from the

doctors group. Similarly, the ability to actfor a principal
p does not imply the ability to change whomay act for
p. We do not explore these extensions here forlack of space.

3.3 Interpreting labels

Intuitively, a relabeling is allowed if it does not createnew ways for the relabeled information to flow. However,

to specify this rule precisely, we need a simple way to interpret a label: that is, to decide what information flows aredescribed by a label.

It is useful to think of a label as describing a set of
flows, where a flow is an (owner, reader) pair. If a label Lhas a component

K with owner oK, then it describes flows
(oK ; r) for every reader r in the set RK. If a principal o0 isnot an owner in the label,

L describes flows (o0; r) for everyprincipal
r. Intuitively, this means that o0 has not expresseda flow policy for the labeled data, so it permits flows to any

principal.Under the interpretation of labels as sets of flows, the
earlier relabeling rules described in Section 2 can be ex-pressed quite simply. Relabeling is permitted from

L1 to
L2 (i.e., L1 v L2) exactly when L1 ' L2 -- when L2 is atleast as restrictive as

L1. In other words, the partial order onlabels is exactly the partial order on sets of flows. For this

reason, we call the relabeling rule of Section 2 the subsetrelabeling rule. Similarly, the join of two labels,

L1 t L2, issimply their intersection,
L1 " L2. The meet of two labels,
L1 u L2, is the same as the union of the labels, L1 [ L2.

3.4 Flow set constraints

The subset relabeling rule is too restrictive because itdoes not take the principal hierarchy into account. By thinking about the label as a set of flows, we will observe thatthere are two constraints that a set of flows ought to satisfy
in a particular principal hierarchy -- one constraint on read-ers, and one on owners. We will use these constraints to
construct a less restrictive relabeling rule.The reader constraint is as follows. If a set of flows
contains a flow (o; r), and r0 is a principal that can actfor

r, then the set must also contain the flow (o; r0). Forexample, the label

fpatient A: doctorsg is equivalent to thelabel
fpatient A: doctors, doctor Bg, since the principal
doctor B can act for the principal doctors.The idea here is that although a label explicitly states

some set of flows, the actual flows denoted by the label de-pend on the principal hierarchy. We call the set of denoted
flows the label's interpretation in the principal hierarchy.We will define a function X that maps a label to its interpretation. Using the definition of X, all of the intuitively soundrelabelings described in Section 2 are easily described. The
function X takes the current principal hierarchy as a (fornow) implicit argument. Thus, the label X

L represents theinterpretation of label
L in the current principal hierarchy.The reader constraint just described can be stated more formally as follows:

r0 * r & (o; r) 2 XL ! (o; r0) 2 XL
However, the reader constraint is not sufficient, be-cause we also want to allow relabelings that change the

5

label's owners. Consider the relabeling from fpatient A:
doctor Bg to fHMO records: doctor Bg. This relabel-ing effectively transfers the responsibility of controlling the

flow of the data from the principal patient A to the prin-cipal

HMO records. This transfer restricts the data's flow,since

HMO records can act for patient A. The key insightto allowing this kind of relabeling is an

owner constraint:

o0 * o & (o; r) 2 XL ! (o0; r) 2 XL
The symmetry of this rule to the reader constraint mightseem incorrectly to imply that the inferior principal

o candictate the addition of readers to the reader set of
o0. Theinterpretation is different: when a superior owner states

that a flow must not occur, this flow is removed from thereader sets of all inferior owners. However, if a superior
owner does not try to prevent a flow, inferior owners maystill prevent it. Thus, the inferior owner's policy must be
at least as restrictive as the superior owner's policy. Theowner constraint can be written in an equivalent, negative
form that captures this intention more directly:

o0 * o & (o0; r) 62 XL ! (o; r) 62 XL
Using this constraint, the label fHMO records: doctor Bg is seen to be equivalent to the label fHMO records:
doctor B; patient A: doctor Bg, in the principal hierarchyof Figure 2. While the first label would seem to allow flows

from patient A to all readers, the owner constraint preventsthe reader set of

patient A from being larger than that of
HMO records.

3.5 Label functions

To help construct the label interpretation function X,we define two functions that establish the reader and owner
constraints. First, we define a function R that expands a setof readers to include the implicitly allowed readers described
by the reader constraint. It adds to the readers RI of acomponent

I to produce an expanded reader set RRI :

RRI = fr j 9r02RI : r * r0g
We also define a function O that converts a label intoa set of flows by restricting it so that it obeys the owner

constraint. Its form is roughly dual to that of R:

OL = f(o; r) j 8I2L : oI * o ! r 2 RI g
As we would expect, both R and O are monotonic inthe set or label they manipulate, in the sense that if

R1 ' R2,then
RR1 ' RR2 and if L1 ' L2, then OL1 ' OL2. How-ever, the two functions differ in their behavior as the principal hierarchy changes. Making the principal hierarchy P anexplicit argument to the functions, we have the following:

if the principal hierarchy P 0 is an extension of P (P 0 ' P ),then

R(R; P 0) ' R(R; P ), but O(L; P 0) ` O(L; P ): Ois anti-monotonic in the

P argument.By composing the R and O functions, we obtain the

label interpretation function X, which maps a label to a setof flows, given a particular principal hierarchy:

XL = f(o; r) j 8I2L : oI * o ! r 2 RRIg
The result of XL satisfies both the reader and owner con-straints, since O preserves the reader constraint established

in each component by R. Intuitively, the effect of applyingboth R and O is the following: a flow

(o; r) is implied by alabel
L if every owner who can act for o permits the flow --either explicitly, by allowing

r to read it, or implicitly, byallowing some principal that
r can act for to read it.Using the function X, we can now write the

correctnesscondition for relabeling in the presence of an arbitrary principal hierarchy. The relabeling from L1 to L2 in principalhierarchy

P is valid as long as no new flows are added.Making the principal hierarchy an explicit argument to X,

the correctness condition is the following:

X(L1; P ) ' X(L2; P )
We can apply this rule to show that the relabeling from
L1 = fpatient A: doctorsg to L2 = fHMO records: doctor Bg is valid. Applying X to L2 gives us a set containingthe flow (

HMO records, doctor B) and the flows (p, doctor B) for every patient p (since HMO acts for all patients),as well as other flows (

o, r) for unrelated owners o and allreaders
r. Applying X to L1 gives us a set containing allthese pairs and more: (

HMO records, r) for every r, forexample. Because X
L1 ' XL2, the relabeling from L1 to
L2 is legal.Because the function X is a composition of R and O, it

is monotonic with respect to L, but neither monotonic noranti-monotonic with respect to

P . It also has some otherinteresting properties. We can interpret the set produced by

applying X to a label as a label itself (although one that isprobably too large to write down!); this is the label in which
every flow is mentioned explicitly. With this interpretation,we can see that like O and R, the function X is idempotent;
that is, XL = XXL.The function X can also be thought of as a closure
operator that converts a label to a closed set of flows. In ac-cordance with this interpretation, the set of labels produced
by X is closed under intersection and union of labels.
4 Checking relabeling statically

We wish to support static checking of programs con-taining label annotations, because static checking allows
precise, fine-grained analysis of information flows, and can

6

capture implicit flows properly [DD77], whereas dynamiclabel checks create information channels that must be controlled through additional static checking [ML97]. How-ever, the correctness condition (X

L1 ' XL2) derived inSection 3 cannot be used directly in static checking since

it depends on the principal hierarchy at the time that therelabeling takes place, while static checking is done earlier,
perhaps as part of compilation. The principal hierarchy mayhave changed between checking and execution, so the full
run-time principal hierarchy is not available when relabel-ing is checked. Therefore, relabeling must be checked using
only partial information about the principal hierarchy.In this section, we develop a general rule for checking relabelings statically using partial information about theprincipal hierarchy. We begin by giving a sketch of how
programs are annotated. Then we define the relabeling ruleand show that it is both sound and complete. Then we discuss the practicality of the system, arguing that both labelchecking and label inference are practical.

4.1 Annotations

We assume that programs are statically annotated withinformation about the labels of data that they manipulate,
and that programs are checked by a static label checker thatstatically analyzes information flows to determine whether
the program follows the information flow rules.In [ML97], a set of language annotations is described
that permits static information-flow checking. Here we sum-marize the important features to give an idea of the framework, and describe new annotations needed to support theextended relabeling rule.

ffl All variables, arguments, and procedure return values havelabeled types. For example, a labeled integer variable

might be declared as intfpatient A: doctorsg x;. Thelabel may be omitted from a local variable, causing it to
be inferred automatically. If the label is omitted from aprocedure argument, it is an implicit parameter, and the
procedure is generic with respect to it.
ffl The actsFor statement allows a run-time test of whetherthe process running the code can act for a principal. In

actsfor (p) S, the statement S is executed only if the pro-cess can act for principal

p; the label checker will allowdeclassifications on behalf of

p within S.

ffl The expression declassify(e, L) relabels the value e withthe label L. The label L may add readers to the label of

e for some owners oi, or remove some owners oi; thestatement is legal only if a containing

actsFor statementhas established that the process can act for each of the

oi.

ffl Procedures are assigned a principal when they are com-piled; this principal derives from the user who is running

the compilation. When a procedure is called it alwaysruns under this authority. Callers can additionally grant
the called procedure the authority to act for principals theyact for (recall that a process may act on behalf of several
principals), but this must be done explicitly.
ffl Variables and arguments may be declared to have the spe-cial base type

label, which permits run-time label check-ing. Variables of type

label and argument-label param-eters may be used to label variables that are mentioned

within the procedure body. They also may be used in
declassify expressions.

ffl A labelcase statement can be used to determine the run-time label of a value, and a special type

protected conve-niently encapsulates a value along with its run-time label.

The following extensions to this previous frameworkenable static reasoning about the principal hierarchy:
ffl Variables of the special type principal may also be used inlabels and in

actsFor statements. Also, when a procedureis granted the authority of some principal by its caller, the

identity of the principal is placed in an argument of type
principal.

ffl A second kind of actsFor statement: In actsFor(p1; p2) S,the statement

S is executed only if a run-time test deter-mines that principal

p1 can act for principal p2. Thelabel checker then uses the knowledge that

p1 * p2 whenchecking relabelings that occur within
S.

For example, using the actsFor extension, in

intfpatient: doctorsg x;
intfpatient: doctor Bg y;
actsFor (doctor B, doctors) y = x;

the assignment is legal because within the body of the
actsFor statement the checker knows that doctor B can actfor

doctors.For each program statement that the label checker verifies, some acts-for relations can be determined to exist,based on the lexical nesting of the

actsFor statements. Theserelations form a subset of the true principal hierarchy that

exists at run time; all that is known statically is that the trueprincipal hierarchy contains the explicitly stated acts-for relations.Using this fairly general model for programming with
static information flow annotations,the challenge is to definea sound (conservative) rule for checking relabelings. In the
next section, we show that defining such a rule is not assimple as one might expect. We then present a rule that is
not only sound but also complete, in that it permits everyrelabeling that cannot be used to leak information.

7

4.2 Static correctness condition

When a program assigns a value to a variable, it relabelsthe data being assigned, since the value's label is changed to
be the same as the label on the variable. This relabeling issound as long as it does not create new ways for the assigned
data to flow. One example of a sound relabeling rule is theoriginal subset relabeling rule; if

L1 ' L2 (L1 is the value'slabel and
L2 is the variable's label), the monotonicity of Xguarantees that the correctness condition holds, regardless

of the principal hierarchy. However, the subset relabelingrule, as we've seen, is excessively restrictive. We would like
a rule that recognizes the principal hierarchy.Let

P be a principal hierarchy that contains only theacts-for relations that are statically known based on the containing actsFor statements. We will refer to this principalhierarchy as the

static principal hierarchy. The actual prin-cipal hierarchy at run time is an extension of

P ; it mustcontain all of the acts-for relations in
P , plus possibly ad-ditional relations. If
P 0 is the actual principal hierarchy,we have
P 0 ' P . Using this notation, and introducing theprincipal hierarchy as an explicit argument to the function

X, we can express the static correctness condition: it is safeto relabel from

L1 to L2 in P if the following holds:

8P 0'P : X(L1; P 0) ' X(L2; P 0)
One might expect that to check whether a relabeling isvalid, we should check whether X

(L1; P ) ' X(L2; P ), i.e.apply the correctness condition for the principal hierarchy

P . By construction, this rule allows all valid relabelings totake place; if a relabeling is not allowed by this rule, then
it creates new flows in the principal hierarchy P . However,the following example will show that this rule is not sound.

Consider the following (bad) relabeling from L1 to L2
L1 = f doctors: patient A; doctor B: patient A, patient B g
L2 = f doctors: doctors, patient A ;

doctor B: patient A, patient B g

Now, consider what happens when we apply X to both ofthese labels while assuming that the principal hierarchy

P 0contains the single relation
doctor B * doctors:

XL1 = f doctors: patient A; doctor B: patient A, patient B gX

L2 = f doctors: patient A; doctor B: patient A, patient B g

Note that XL2 does not contain the flow (doctors, doctors)because the superior owner

doctor B rules it out. Sincethese two label interpretations are equal, it would seem that

the relabeling is correct. However, if we learn that patient Bis also a doctor (

patient B * doctors), applying X to bothlabels leads to a quite different conclusion:

XL1 = f doctors: patient A; doctor B: patient A, patient B gX

L2 = f doctors: patient B, patient A;

doctor B: patient A, patient B g

The relabeling is invalid under the principal hierarchy P 0,because it adds the flow (

doctors, patient B). This exam-ple shows that the correctness condition cannot be applied

directly as a relabeling rule.
4.3 A sound and complete relabeling rule

The correct rule for checking a relabeling from label L1to label

L2 is intuitive: for every component I in L1, theremust be a corresponding component

J in L2 that is at leastas restrictive as
I. The component J is at least as restrictiveas
I if oJ * oI and RJ ` RRI . If L1 can be relabeled to L2under principal hierarchy

P , we will write P ` L1 v L2.This condition is defined formally as follows:

8I2L19J2L2 \Theta P ` oJ * oI & RJ ` R(RI ; P )\Lambda 
Expanding the definition of R, we obtain the followingequivalent and more symmetrical formulation:

8I2L19J2L2 \Theta P ` oJ * oI & 8rj2RJ 9ri2RI : P ` rj * ri\Lambda 

The binary relation v is defined for any principal hi-erarchy

P . The relation is a pre-order: it is transitive andreflexive, but not anti-symmetric, since two labels may be

equivalent without being equal. If A and B are equivalent,we write

A ss B to mean A v B & B v A. For example,with the hierarchy of Figure 2, the labels

fHMO: doctorsgand
fHMO: doctors, doctor Ag are equivalent. Every prin-cipal hierarchy generates a pre-order on labels, defining the

legal relabelings.The nature of the relabeling rule can be understood by
considering the incremental relabelings that it permits. It al-lows an arbitrary sequence of any of the following four kinds
of relabelings, each of which is clearly sound individually:
ffl A reader may be dropped from some owner's reader set.
ffl A new owner may be added to the label, with an arbitraryreader set.

ffl A reader may be added as long as it can act for somemember of the reader set.
ffl An owner may be replaced by an owner that acts for it.

Interestingly, these incremental relabelings also capture
all of the sound relabelings. That is, the rule for v, which wewill call the

complete relabeling rule, is both sound and com-plete. When we say that the rule is complete, we mean that

it exactly captures the set of valid relabelings, with respectto the static correctness condition defined in Section 4.2,
and using our assumptions about the static checking envi-ronment. We now provide sketches of our formal proofs for
these claims. (The rule has also been checked for soundnessusing Nitpick, a counterexample generator [JD96].)

8

Soundness. We must show that if the relabeling ruleholds for some principal hierarchy

P , the correctness con-dition holds for all possible extensions

P 0:

(P ` L1 v L2) ! [8P 0'P : X(L1; P 0) ' X(L2; P 0)]

Suppose that L1 can be relabeled to L2, P 0 ' P , andX
(L1; P 0) does not contain some flow (o; r). We will showthat

(o; r) cannot be in X(L2; P 0) either. If (o; r) is not inX
(L1; P 0), there must be some owner oI in L1 that sup-presses it (

i.e., r 62 R(RI ; P 0) and P 0 ` oI * o). Since
P ` L1 v L2, there is a corresponding owner oJ in L2such that

RJ ` R(RI; P ) and P ` oJ * oI . Since
P ` oJ * oI, we have P 0 ` oJ * oI, and transitively
P 0 ` oJ * o. We now show that this oJ prevents (o; r)from appearing in

X(L2; P 0).Let
r0 be an arbitrary reader such that P 0 ` r * r0.We know that

r0 62 RJ . (If r0 2 RJ , we would have acontradiction:

r0 2 R(RI ; P ), so r0 2 R(RI ; P 0), andtherefore
r 2 R(RI; P 0).) Since for all such r0, r0 62 RJ ,we have
r 62 R(RJ ; P 0). Since we also know P 0 ` oJ * o,this means

(o; r) 62 X(L2; P 0). Since this was true forarbitrary
o and r, any flow not in X(L1; P 0) is also not inX
(L2; P 0). Therefore, the relabeling rule is sound.

Completeness. We must show the converse:
\Theta 8

P 0'P : X(L1; P 0) ' X(L2; P 0)\Lambda  ! (P ` L1 v L2)

We prove this statement by contradiction: if a relabeling isrejected by the rule (

L1 6v L2), we can find a P 0 such that
P 0 ' P but X(L1; P 0) 6' X(L2; P 0). In other words, if arelabeling is rejected, it might result in a leak.

If :(P ` L1 v L2), there must be some owner oI in
L1 such that for every component J in L2 where oJ * oI,
RJ 6` RRI. Consider an arbitrary such component J in
L2 (if there is no such J, the relabeling leaks even in P ).The component

J must have a reader rj where rj 2 RJ but
rj 62 RRI. We will now use the readers rj of every such
J to construct a principal hierarchy P 0 that extends P andresults in a leak.

Consider a principal hierarchy P 0 that is exactly like
P , except that there is an additional principal r that in P isunrelated to any of the owners or readers in

L1 and L2. Weform
P 0 by adding a relation (r; rj) for each rj and takingthe transitive closure:

P 0 = P [ f(r; r0) j 9rj : (rj ; r0) 2 P g
Using this definition, we find that (oI ; r) 2 X(L2; P 0) but
(oI ; r) 62 X(L1; P 0), which shows that the relabeling causesa leak in

P 0. Therefore, the relabeling rule is complete.This completeness result can be strengthened further:

our rule is complete even in the presence of negative in-formation about the principal hierarchy. We could imagine

acquiring negative information by allowing an else clausein the

actsFor statement. Since actsFor tests whether oneprincipal can act for another, in the body of the

else clausewe would be able to determine statically that the specified

principal relationship does not exist. This static informationcould be used to establish an upper bound on the dynamic
principal hierarchy. However, an upper bound is not use-ful in checking relabelings: the proof for completeness still
holds in the presence of an upper bound on P 0, since wecan simply choose an arbitrary

r that is not mentioned inthe upper bound.

4.4 Static checking

Now we consider what is involved in doing static check-ing. We have already explained how to check assignments:
we use the complete relabeling rule. But the labels beingcompared may be the results of joins (to account for computations), and meets (if the checker is doing label inference).Therefore, we need to define join and meet.

Labels form a pre-order rather than a lattice or evena partial order, because two labels can be equivalent without being equal. However, labels do preserve the importantproperties of a lattice that make static reasoning about information flow feasible: any pair of elements possesses leastupper bounds and greatest lower bounds, which are unique
to within an equivalence class. In addition, the join andmeet operations distribute over each other.

Below we define join and meet. Our definitions havethe desirable properties that they are easy to evaluate and
that the resulting labels are easy to deal with when applyingthe complete relabeling rule.

4.4.1 Join. The join, or least upper bound, is useful inassigning a label to the result of an operation that combines
several values, such as adding two numbers. The resultof adding two numbers ought in general to be restricted
at least as much as the numbers being added. However,we would also like not to restrict the sum unnecessarily;
therefore, it is assigned the least restrictive label that is noless restrictive than both input labels. In a lattice, there is
a unique least label; however, uniqueness is not importantfor our purposes. Any label within an equivalence class is
acceptable as long as it can be relabeled to every label thatis at least as restrictive as the input labels.

The join of two label expressions can be defined quitesimply: it is the concatenation of all their components. The
following are examples of join expressions, where A, B,and

C are principals unrelated by the acts-for relation:

fA : Bg t fB : Cg = fA : B; B : Cg (1)
fA : Bg t fA : B; Cg = fA : Bg (2)

fA : Bg t fA : Cg = fA : B; A : Cg (3)

9

After doing a join, the compiler can sometimes simplifythe label expression by removing redundant components, so
that future checking steps run more efficiently. This sim-plification has been performed in the second example. A
component is redundant if the relabeling rules behave iden-tically for the label regardless of whether the component is
present. One component oI : RI makes another component
oJ : RJ redundant if oI * oJ and RI ` RRJ . In allpossible relabelings involving such a label, the presence of

component J will not affect the validity of a relabeling.The third example illustrates the difference between this
join operator and the earlier one defined in Section 2, basedon the subset relabeling rule. The earlier join definition
results in the label fA : ;g, since reader sets for the sameowner are intersected. The difference between the two join
results may seem inconsequential; however, if C * B; thenthe label

fA: B; A: Cg can be relabeled to the label fA: Cg,but
fA: ;g cannot. Therefore, the difference in the rules issignificant.

We can now see why it is important that owners berepeatable in labels: it completes the lattice of equivalence
classes. If repeated owners were not allowed, there wouldbe no least upper bound for many pairs of labels. Consider
the third example again, but disallowing repeated owners. If
A0 is another principal with A0 * A, then the least restrictivelabels that both

fA: Bg and fA: Cg could be relabeled towould include
fA: ;g, fA: B; A0: Cg, and fA0: B; A: Cg,none of which can be relabeled to any other. There would

be no least upper bound for these two labels.The join operation just described produces the least
upper bound of two labels. This can be seen by interpretinga join result as a set of flows, in an extended principal
hierarchy P 0. It follows directly from the definition of Xthat for all such hierarchies

P 0,

X(A t B; P 0) = X(A; P 0) " X(B; P 0)
This equation means that there is no label less restrictive than
A t B that both A and B can be relabeled to. Therefore,the join operator produces the least upper bound of the two

labels, to within an equivalence class.
4.4.2 Reasoning about joins. Components of a joincan be independently relabeled or declassified. The property is important because it allows checking of code that isgeneric with respect to some of the labels that appear in it.
In the case of declassification, there are no surprises for thedeclassifying principal: the set of flows that are added by
declassifying a join is always a subset of the set of flowsthat would be added by declassifying the individual components. There are no interactions between the two parts ofthe join that create new, unexpected flows.

For example, if label L1 can be relabeled to L2, then
L1 t L3 can be relabeled to L2 t L3, regardless of what

L3 is. L3 may be an opaque label, or even a label that isdetermined at run time, without invalidating the relabeling.
Similarly, if L1 can be declassified to L2, then L1 t L3 canbe safely declassified to

L2 t L3. These relabelings anddeclassifications work because the join guarantees that all

components in L3 will be respected.
4.4.3 Meet. The meet or greatest lower bound of twolabels is the most restrictive label that can be relabeled to
both of them. The meet of two labels is not produced bycomputations during the program's execution, but it is useful
in defining algorithms for automatic label inference [DD77,ML97]. The meet is useful to automatically infer labels for
inputs, just as the join is useful to produce labels for outputs.For example, in the following code, the most restrictive label
x could have can be expressed by using a meet:

int x;
intfAg y;
intfBg z;
y = x;
z = x;

In this example, the variables y and z have labels of A and
B respectively. The variable x can be assigned any label Cso long as it can be relabeled to both

A and B. Therefore,
A u B is an upper bound on the label for x. The simplealgorithm for inferring variable labels that we have described

elsewhere [ML97] uses a succession of meet operations inthis fashion to refine unknown variable labels downward
until either all variables have consistent assignments, or acontradiction is reached.

To construct the meet of two labels, let us first con-sider the meet of two components

J and K. If there is nostatically known relation between the owners of these components, the meet is fg. This is the result obtained wheneither

J or K is uninterpreted (e.g., is a label parameter), orwhen both have known owners but there is no static relationship established between them (by some containing actsForstatement). Otherwise, suppose that

J = fo : r1 : : : rngand
K = fo0 : r01 : : : r0ng. if o0 can act for o (which includesthe case where they are equal), then the meet of the two

components is fo : r1 : : : rn; r01 : : : r0ng.Now, consider the meet of two arbitrary labels. Since
a label containing several components is really the join ofthese components, the meet can be computed by distributing
the meet over both joins. The result of the meet is the joinof all pairwise meets of components, using one component
from each label. Some of these pairwise meets may producethe label

fg, which of course can be dropped from the join.As with the formula for join, the validity of this formula for meet can be seen by using the label interpretationfunction. If

P 0 is some extension of the principal hierarchyused to compute the meet of labels

A and B, then

10

X(A u B; P 0) ' X(A; P 0) [ X(B; P 0)
The formula for meet is sound, but unlike the formulafor join, it does not always produce the most restrictive

label for all possible extensions P 0. This happens becausethe rule for joining two components must return

fg whenthe owners are not known to have a relationship, though

in the real hierarchy, a relationship may exist. The resultis that label inference must be conservative in some cases,
which does not seem to be a significant problem since evenexplicit label declarations do not work in those cases.

It can also be shown straightforwardly that join andmeet distribute over each other in the expected way, producing equivalent labels:

A t (B u C) ss (A t B) u (A t C)
A u (B t C) ss (A u B) t (A u C)

This means that a static checker doing label inference asdescribed elsewhere [ML97] can rely on the properties of

meet and join to simplify label expressions.
5 Related work

There has been much work on information flow controland on the static analysis of security guarantees. The lattice
model of information flow comes from the early work ofBell and LaPadula[BL75] and Denning [Den76].

The decentralized label model has several similarities tothe ORAC model [MMN90]: both models provide some approximation of the "originator-controlled release" labelingused by the U.S. DoD/Intelligence community. Both also
support the joining of labels as computation occurs, thoughthe ORAC model lacks some important lattice properties.
Unlike our model, ORAC is intended to be dynamicallychecked. Dynamic checks result in storage and run-time
overhead, and data can become more and more stringentlylabeled as it is used. Further, the label checks themselves
can become a covert channel. We have shown that staticchecking can be used to control this channel [ML97]. Interestingly, ORAC does allow owners to be replaced in labelcomponents (based on ACL checks that are analogous to
actsFor checks); however, it does not support declassifica-tion or the new relabelings described in this paper.

Other work on information flow policies has exam-ined complex aggregation policies for commercial applications [CW87, BN89, Fol91]. We have not addressed poli-cies that capture conflicts of interest, though our fine-grained
tracking of ownership information seems applicable. Manyof these information control models are not designed to
be checked statically. IX [MR92] is a good example of areal-world information flow control system that used dynamic checking. Recent work by Ferrari et. al [FSBJ97]

introduces a form of dynamically-checked declassificationthrough special

waivers to strict flow checking. Some ofthe need for declassification in their framework would be

avoided with fine-grained static analysis. Because waiversare applied dynamically and mention specific data objects,
they seem likely to have administrative and run-time over-heads.

Static analysis of security guarantees also has a long his-tory. It has been applied to information flow [DD77, AR80]
and to access control [JL78, RSC92]. There has recentlybeen more interest in provably-secure programming languages, treating information flow checks in the domainof type checking. Some of this work has focused on
formally characterizing existing information flow and in-tegrity models [PO95, VSI96, Vol97]. Smith and Volpano have recently examined the difficulty of staticallychecking information flow in a multithreaded environment [SV98]; we have not addressed this problem. Heintzeand Riecke [HR98] have shown that information-flow-like
labels can be used in a simple functional language to stat-ically check an integrated model of access control, information flow control, and integrity. Their model does not,however, allow declassification of information flows or runtime flow checking. Also, Abadi [Aba97] has examinedthe problem of achieving secrecy in security protocols, also
using typing rules, and has shown that encryption can betreated as a form of safe declassification through a primitive
encryption operator.
6 Conclusions

The decentralized label model is a promising approachfor making information flow a practical way to guarantee
secrecy and privacy. It provides considerable flexibility byallowing individual principals to attach flow policies to individual values manipulated by a program. These moreflexible labels then permit values to be declassified by an
owner of the value. This declassification is safe becauseit does not affect the secrecy guarantees to other principals
who have an interest in the secrecy of the data. This sup-port for multiple principals makes the label model ideal for
mutually distrusting principals.However, while the original model contained a principal
hierarchy, the hierarchy was not fully integrated into therelabeling rules, making the rules unnecessarily restrictive.
This paper has defined a complete relabeling rule for thedecentralized label model. The new rule precisely captures
all the legal relabelings that are allowed when knowledgeabout the principal hierarchy is available statically. We
have shown that the rule is both sound and complete, andfurthermore that it is easy to apply. We have formalized
the relabeling rule as a pre-order relation with distributivelattice properties: join and meet operators can be defined on

11

these labels, which means that a compiler or static checkercan use them to check information flow statically, to support
label polymorphism, and to do label inference.The new rules for relabeling, join, and meet make the
decentralized label model more practical and more usable.They make it easier to model common security paradigms,
allowing control of information flow in a system with groupor role principals. They also allow individual principals to
model their own multilevel security classes conveniently.
Acknowledgments

The authors would like to acknowledge the many help-ful comments they have received about this work, including
suggestions from Mart'in Abadi, Kavita Bala, Phillip Bogle,Chandrasekhar Boyapati, Miguel Castro, Stephen Garland,
Jason Hunter, and the reviewers. We would also like tothank Daniel Jackson for his help with Nitpick.

References
[Aba97] Mart'in Abadi. Secrecy by typing in security protocols.

In Proc. Theoretical Aspects of Computer Software:
Third International Conference, September 1997.

[AR80] Gregory R. Andrews and Richard P. Reitman. An axiomatic approach to information flow in programs.
ACM Transactions on Programming Languages and
Systems, 2(1):56-76, 1980.

[BL75] D. E. Bell and L. J. LaPadula. Secure computer

system: Unified exposition and Multics interpretation. Technical Report ESD-TR-75-306, MITRE Corp.
MTR-2997, Bedford, MA, 1975. Available as NTIS
AD-A023 588.

[BN89] D. F. Brewer and J. Nash. The Chinese wall security

policy. In Proc. IEEE Symposium on Security and
Privacy, pages 206-258, May 1989.

[CW87] David Clark and David R. Wilson. A comparison of

commerical and military computer security policies.
In Proc. IEEE Symposium on Security and Privacy,
pages 184-194, 1987.

[DD77] Dorothy E. Denning and Peter J. Denning. Certification of programs for secure information flow. Comm.
of the ACM, 20(7):504-513, 1977.

[Den76] Dorothy E. Denning. A lattice model of secure information flow. Comm. of the ACM, 19(5):236-243,
1976.

[Fol91] Simon N. Foley. A taxonomy for information flow

policies and models. In Proc. IEEE Symposium on
Security and Privacy, pages 98-108, 1991.

[FSBJ97] Elena Ferrari, Pierangela Samarati, Elisa Bertino, and

Sushil Jajodia. Providing flexibility in information
flow control for object-oriented systems. In Proc. IEEE
Symposium on Security and Privacy, pages 130-140,
Oakland, CA, USA, May 1997.

[HR98] Nevin Heintze and Jon G. Riecke. The SLam calculus: Programming with secrecy and integrity. In Proc.
ACM Symp. on Principles of Programming Languages
(POPL), San Diego, California, January 1998.

[JD96] Daniel Jackson and Craig A. Damon. Elements of

style: Analyzing a software design feature with a counterexample detector. IEEE Transactions on Software
Engineering, 22(7):484-495, July 1996.

[JL78] Anita K. Jones and Barbara Liskov. A language extension for expressing constraints on data access. Comm.
of the ACM, 21(5):358-367, May 1978.

[ML97] Andrew C. Myers and Barbara Liskov. A decentralized

model for information flow control. In Proc. 17th ACM
Symp. on Operating System Principles (SOSP), pages
129-142, Saint-Malo, France, 1997.

[MMN90] Catherine J. McCollum, Judith R. Messing, and

LouAnna Notargiacomo. Beyond the pale of MAC
and DAC -- defining new forms of access control. In
Proc. IEEE Symposium on Security and Privacy, pages
190-200, 1990.

[MR92] M. D. McIlroy and J. A. Reeds. Multilevel security in

the UNIX tradition. Software--Practice and Experience, 22(8):673-694, August 1992.

[PO95] Jens Palsberg and Peter O/rbaek. Trust in the *-calculus.

In Proc. 2nd International Symposium on Static Analysis, number 983 in Lecture Notes in Computer Science,
pages 314-329. Springer, September 1995.

[RSC92] Joel Richardson, Peter Schwarz, and Luis-Felipe Cabrera. CACL: Efficient fine-grained protection for objects. In Proceedings of the 1992 ACM Conference on
Object-Oriented Programming Systems, Languages,
and Applications, pages 154-165, Vancouver, BC,
Canada, October 1992.

[Sal74] J. H. Saltzer. Protection and the control of information

sharing in Multics. Comm. of the ACM, 17(7):388-402,
July 1974.

[SV98] Geoffrey Smith and Dennis Volpano. Secure information flow in a multi-threaded imperative language. In
Proc. ACM Symp. on Principles of Programming Languages (POPL), San Diego, California, January 1998.

[Vol97] Dennis Volpano. Provably-secure programming languages for remote evaluation. ACM SIGPLAN Notices,
32(1):117-119, January 1997.

[VSI96] Dennis Volpano, Geoffrey Smith, and Cynthia Irvine.

A sound type system for secure flow analysis. Journal
of Computer Security, 4(3):167-187, 1996.

12