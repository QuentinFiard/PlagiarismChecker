

Inclusion Constraints over

Non-empty Sets of Trees?

Martin M"uller1, Joachim Niehren1 and Andreas Podelski2

1 Programming System Lab,
Universit"at des Saarlandes, 66041 Saarbr"ucken, Germany

fmmueller,niehreng@ps.uni-sb.de
2 Max-Planck-Institut f"ur Informatik,

Im Stadtwald, 66123 Saarbr"ucken, Germany

podelski@mpi-sb.mpg.de

Abstract. We present a new constraint system called INES. Its constraints are conjunctions of inclusions t1`t2 between first-order terms
(without set operators) which are interpreted over non-empty sets of
trees. The existing systems of set constraints can express INES constraints only if they include negation. Their satisfiability problem is
NEXPTIME-complete. We present an incremental algorithm that solves
the satisfiability problem of INES constraints in cubic time. We intend
to apply INES constraints for type analysis for a concurrent constraint
programming language.

1 Introduction
We propose a new constraint system called INES (Inclusions over Non-Empty
Sets) and present an incremental algorithm to decide the satisfiability of INES
constraints in time O(n3). INES constraints are conjunctions of inclusions t1`t2
between first-order terms (without set operators) which are interpreted over the
domain of non-empty sets of trees. In this paper we focus on sets of possibly
infinite trees. All given results can be easily adapted to finite trees.

An INES-constraint t1`t2 is satisfiable over non-empty sets if and only if
t16`; ^ t1`t2 is satisfiable over arbitrary sets. Note that the constraint t6`;
cannot be expressed by positive set constraints only [16]. The expressiveness of
INES constraints is subsumed by that of set constraints with negation [9, 16]. In
the case of finite trees, the satisfiability problem of set constraints with negation
is known to be decidable [1, 13]; it is complete for nondeterministic exponential
time [9, 10]. This result implies that the satisfiability problem of INES constraints
over sets of finite trees is decidable. The corresponding problem for infinite trees
has not been considered before.

We characterize the satisfiability of INES constraints by a set of axioms such that
an INES constraint is satisfiable over non-empty sets if and only if it is satisfiable

? A summary has appeared in: Max Dauchet, ed., Proc. of CAAP'97 as part of

TAPSOFT'97, Theory and Practice of Software Development. April 1997, Lille, France.

in some model of these axioms. These axioms define a fixpoint algorithm that
closes a given input constraint under its consequences with respect to the axioms.
We prove that a constraint ' is satisfiable if and only if the algorithm with
input ' does not derive ? as a consequence of '. All axioms (for infinite trees)
will be discussed later in this introduction.

Sets versus Trees. The satisfiability problems of several classes of first-order
formulae interpreted over trees and over non-empty sets of trees are closely
related. The following two instances of this observation have inspired our choice
of axioms or underly our proofs.

Equality constraints are conjunctions of equations t1=t2 between first-order
terms. Over sets, they can be expressed by inclusion constraints due to antisymmetry of set inclusion (t1=t2 $ t1`t2 ^ t2`t1). Actually, even the firstorder theories of equality constraints over trees and of equality constraints over
non-empty sets of trees coincide. This follows from the complete axiomatization
of the first-order theory of equality constraints over trees [18, 19, 12] since its
axioms also hold over non-empty sets of trees (but don't over possibly empty
sets).

There exists a natural interpretation of INES-constraint over tree like structures
that we call tree prefixes. In a different context [6] tree prefixes are called B"ohm
trees (without *-binders). Tree prefixes come with a natural ordering relation
where the empty tree prefix is the greatest element. We prove that an INES
constraint is satisfiable over non-empty sets of trees if and only if it is satisfiable
over tree prefixes (where the inclusion symbol is interpreted as the inverse of the
prefix ordering on tree prefixes).

Axioms. The first two axioms we need postulate the reflexivity and transitivity
of the inclusion relation. We also assume the following decomposition axiom (here
formulated for a binary function symbol f ).

f (x; y)`f (x0; y0) ! x`x0 ^ y`y0
This axiom holds over non-empty sets of trees but not over possibly empty sets,
since every variable assignment ff with ff(x) = ; or ff(y) = ; is a solution of
f (x; y)`f (x0; y0) but not necessarily of x`x0 ^ y`y0. An analogous statement
holds for the following clash axiom.

f (x; y)`g(x0; y0) ! ? for f 6= g
These axioms do not suffice to characterize the satisfiability of INES constraints.
For instance, the unsatisfiability of the constraint ' given by x`g(x) ^ x`g(y) ^
y`z ^ z`a is not derivable with these axioms alone. We need further axioms
that use non-disjointness constraints t16 jj t2 defined as t1"t26`;. For the nondisjointness relation we require reflexivity and symmetry and a decomposition axiom as for the inclusion relation.

f (y; z)6 jj f (y0; z0) ! y6 jj y0 ^ z6 jj z0

2

Finally, we assume a clash axiom similar to the one for inclusion and require
nondisjointness to be compatible with inclusion in the following sense.

x6 jj z ^ x`y ! y6 jj z
Now reconsider the constraint ' given above and observe that we can derive
x6 jj x by reflexivity, then x6 jj y by decomposition, and x6 jj z by compatibility. This
yields a clash with x`g(x) ^ z`a.

Algorithm and Complexity. The above axioms yield an algorithm that adds
constraints of the form x`y, x6 jj y to a given input constraint ' until ' is closed
under all axioms or implies ?. The INES constraint x`t1 ^ : : : ^ x`tn expresses
the n sets denoted by the terms t1; : : : ; tn have a non-empty intersection. Fortunately, it is not necessary to add k-ary non-disjointness constraints of the form
x1" : : : "xk6`; (which can be expressed by the formula 9y(y`x1 ^ : : : ^ y`xk))
of which there are exponentially many. Instead, our algorithm adds at most
O(n2) constraints to the input constraint ', where n is the number of variables
in '. The addition of a single constraint can be implemented such that it costs
time O(n). This yields an implementation of our algorithm with time complexity
O(n3). This implementation can be organized incrementally.

Type Analysis. One application for INES constraints which we are investigating in [23] is type analysis for concurrent constraint programming [17, 27], in
particular Oz [28]. As formal foundations we intend to use the calculi in [24, 25].
There, INES constraints are used to approximate the set of run-time values for
program variables. Since values in Oz include infinite trees, it is important that
INES allows an interpretation over sets of possibly infinite trees. It is considered
an error if the set of possible run-time values is empty for some variable. This
fact was our initial motivation for the choice of non-empty sets of trees as the
interpretation domain for INES constraints.

Plan of the Paper. In Section 2, we discuss relate work. In Section 3, we
define the syntax and semantics of INES constraints and in Section 4, we present
the axioms and the algorithm. In Section 5, we prove the completeness of our
algorithm. In Section 6, we compare the interpretations of INES constraints over
tree prefixes and over non-empty sets of trees. Due to space limitations, we omit
the details of the proofs in the conference version of the paper.

Appendix A gives an example illustrating program analysis for Oz with INES
constraints. Appendix B contains the omitted proofs. Appendix C details how
to implement the algorithm with incremental O(n3) complexity. In Appendix D,
we adapt the algorithm to the finite-tree case, and in Appendix E to a subclass
of standard set constraints (interpreted over possibly empty sets of finite trees)
with explicit non-emptiness constraints x6`;. We also prove that satisfiability
of atomic set constraints (standard set constraints without set operators and
negation) is invariant with respect to the choice of finite or infinite trees.

3

2 Related Work
Standard Set Constraints. Set constraints as in [2, 5, 10, 15] are inclusions
between first-order terms with set operators interpreted over sets of finite trees.
Our algorithm can be adapted such that it solves a subclass of set constraints
without set operators in cubic time (see Appendix E). The general case is nondeterministically exponential time complete as proved in [1, 13]. The subclass
that we can solve in cubic time syntactically extends the INES constraints with
explicit non-emptiness constraint x6`; (see Appendix E). Note that the satisfiability of these set constraints depends on the choice of finite or infinite trees
(consider x`f (x)^x6`;), which is in contrast to standard set constraints without
negation. Our algorithm accounts for finiteness through the occur check.

Atomic Set Constraints. Heintze and Jaffar consider so-called atomic set
constraints [15] which syntactically coincide with INES constraints but are interpreted over possibly empty sets of finite trees. The satisfiability problem for
atomic set constraints is also O(n3). This result is implicit in the combined
results of [14] and [15]. An explicit proof is given in Appendix E of this paper.

Set Constraints for Type Analysis. Aiken et al. [3, 4] use constraints
over specific sets of trees called "types" for the type analysis of FL. There is a
minimal type 0 which - in terms of constraint solving - behaves just like the
empty set in standard set constraints (although it is not an empty set from the
types point of view but contains a value denoting non-termination). In contrast
to the constraints of this paper, their set constraints provide for union and
intersection. One of the optimizations used by Aiken et al. is to strengthen the
following constraint simplification rule by dropping the disjuncts in brackets [4].

f (x; y)`f (x0; y0) ! x`x0 ^ y`y0 [ .x`0 . y`0 ]
As stated in [4], this optimization does not preserve soundness (f (a; 0)`f (b; 0)
holds but a`b ^ 0`0 does not). It might be possible to justify it by using nonempty sets as interpretation domain. This is left to further research.

Entailment and Independence for Ines Constraints. Charatonik and
Podelski [11] give an algorithm which decides the entailment problem between
INES constraints when interpreted over sets of finite trees. They also decide the
satisfiability of INES constraints with negation in the finite tree case. The results
in [11] do not include any of the results presented here since they use as an
explicit prerequisite the fact that satisfiability of INES constraints is decidable.

Tarskian Set Constraints. MacAllester and Givan [21] give a cubic algorithm
which decides satisfiability for a class of Tarskian set constraints [22], and which
also contains a non-disjointness constraint. Apart from this syntactic similarity,
the two satisfiability problems are rather different problems since Tarskian set
constraints are not interpreted over the domain of trees (this is also observed
in [22]). A related open question is whether our axioms define a local theory [20,
8], which would also proof the cubic complexity bound of our algorithm.

4

3 Syntax and Semantics of Ines Constraints
We assume a set of variables ranged over by x; y; z and a signature \Sigma  that defines
a set of function symbols f; g and their respective arity n * 0. Constants (i.e.
function symbols of arity 0) are denoted with a and b.

Trees. We base the definition of trees on the notion of paths since we wish to
include infinite trees. Paths will turn out central for our proofs in Section 5. A
path p is a sequence of positive integers ranged over by i; j; n; m. The empty path
is denoted by ". We write the free-monoid concatenation of paths p and q as pq;
we have "p = p" = p. Given paths p and q, q is called a prefix of p if p = qp0 for
some path p0.

Let o/ be a set of pairs (p; f ) of paths p and function symbols f . We say that o/
is prefix closed, if (p; f ) 2 o/ and q is a prefix of p implies that there is a g such
that (q; g) 2 o/ . It is path consistent, if (p; f ) 2 o/ and (p; g) 2 o/ implies f =g.
We call o/ arity consistent, if (p; f ) 2 o/ , (pi; g) 2 o/ implies that i 2 f1; : : : ; ng
provided the arity of f is n. Finally, o/ is called arity complete, if (p; f ) 2 o/ ,
where the arity of f is n, implies for all i 2 f1; : : : ; ng the existence of a g with
(pi; g) 2 o/ .

A (possibly infinite) tree o/ is a set of pairs (p; f ) that is non-empty, prefix closed,
arity complete, path consistent, and arity consistent. The set of all (possibly
infinite) trees over \Sigma  is denoted by Tree and the set of all non-empty sets of
trees by P+(Tree).

Ines Constraints. An INES constraint t1`t01 ^ : : : ^ tn`t0n is a conjunction of
inclusions between first-order terms t defined by the following abstract syntax.

t ::= x j f (t)
Here and throughout the paper, t stands for a sequence of terms and we assume
implicitly that the length of t coincides with the arity of f . We interpret INES
constraints over the structure P+(Tree) of non-empty sets of trees. In this structure, a function symbol f of \Sigma  is interpreted as elementwise tree constructor
and the relation symbol ` as subset relation. We call a first-order formula over
INES constraint satisfiable if it is satisfiable in the structure P+(Tree). Two firstorder formulae over INES constraints are called equivalent if they are equivalently
interpreted in P+(Tree).

Flat Ines Constraints. For algorithmic reasons, we use an alternative constraint syntax in the sequel. First, we restrict ourselves to flat terms f(x) and x
instead of possibly deep terms t. Second, we use equalities x=f (y) rather than
inclusions x`f (y) and f (y)`x (this is a matter of taste). And third, we need
binary non-disjointness constraints x6 jj y. Their semantics is given by the equivalence to the formula x"y6`; over sets of trees. Over non-empty sets of trees, x6 jj y

5

is equivalent to 9z(z`x ^ z`y). Crucially, however, nondisjointness constraints
x6 jj y avoid explicit existential quantification in our algorithm.

These three steps lead us to flat INES constraints ' defined as follows.

' ::= '1 ^ '2 j x`y j x=f (y) j x6 jj y
We identify flat INES constraints ' up to associativity and commutativity of conjunction, i.e., we consider ' as a multiset of inclusions x`y, equalities x=f (y),
and non-disjointness constraints x6 jj y.

From now on, we will consider only flat INES constraints and call them constraints for short. This is justified by the following Proposition. Let the size
of a constraint ' be the number of function symbol occurrences plus variable
occurrences in '.

Proposition 1. The satisfiability problems of INES constraints and of flat INES
constraints have the same time complexity up to a linear transformation.

4 Axioms and Algorithm
We present a set of axioms valid for INES-constraints interpreted over non-empty
sets of trees. In a second step, we interpret these axioms as an algorithm that
solves the satisfiability problem of INES constraints. The correctness and the
complexity of this algorithm will be proved in Section 5.

A1. x`x and x`y ^ y`z ! x`z
A2. x=f(y) ^ x`x

0 ^ x0=f(z) ! y`z

A3. x`y ! x6 jj y and x`y ^ x6 jj z ! y6 jj z and x6 jj y ! y6 jj x
A4. x=f(y) ^ x6 jj x

0 ^ x0=g(z) ! ? for f 6= g

A5. x=f(y) ^ x6 jj x

0 ^ x0=f(z) ! y6 jj z

Table 1. Axioms of INES constraints over non-empty sets of infinite trees
Table 1 contains five rules A1-A5 representing sets of axioms.1 The union of
these sets is denoted by A. For instance, a rule x`x represents the infinite set

1 Note that these axioms differ from the ones given in the introduction. The constraints

used there are not flat and the variable-variable case x`y and x6 jj y are omitted.
Indeed, the axioms in the introduction are semantically complete, although this is
non-trivial to see and depends on the correctness of the algorithm presented here.

6

of axioms that is obtained by instantiation of the meta variable x with concrete
variables. Note that an axiom is either a constraint ', an implication between
constraints ' ! , or an implication ' ! ?.

Proposition 2. The structure P+(Tree) is a model of the axioms in A.
Proof. By a routine check. We note that the non-emptiness assumption of
P+(Tree) is essential for axioms A2 and A3:1. 2

The Algorithm. The set of axioms A can be considered as a (na"ive) fixed
point algorithm A that, given an input constraint ', iteratively adds logical
consequences of A[f'g to '. More precisely, in every step A inputs a constraint '
and either terminates with ? or outputs a constraint ' ^ . Termination with
? takes place if there exists 0 2 ' such that 0 ! ? 2 A. Output of ' ^  is
possible if  2 A or there exists 0 in ' with 0 !  2 A.

Example 1. A first type of inconsistency depends on the transitivity of set inclusion. Here is a typical example:

x=a ^ x`y ^ y`z ^ z=b ! ? for a 6= b
Algorithm A may add x`z by A1:2, then x6 jj z with A3:1, and then terminate
with ? by A4.

Example 2. A second type of inconsistency comes with implicit or explicit nondisjointness requirements. For illustration, we consider:

x=a ^ z`x ^ z`y ^ y=b ! ? for for a 6= b
Algorithm A may add z6 jj x by A3:1, then x6 jj z via A3:3, then x6 jj y with A3:2, and
finally terminate with ? via A4.

Example 3. Inconsistencies of the above two types may be detected by structural
reasoning with A2. Consider:

x=f (x) ^ x=f (z) ^ z=a ! ?
Algorithm A may add x`x by A1:1, then x`z with A2, then x6 jj z by A3:1, and
finally terminate with ? with A4.

Example 4. We need another structural argument based on A5 for deriving the
unsatisfiability of the following constraint.

x=f (x) ^ z`x ^ z`y ^ y=f (x0) ^ x0=a ! ?
Algorithm A may add x6 jj y after several steps as shown in Example 2. Then it
may proceed with x6 jj x0 via A5 and terminate with ? via A4.

7

Termination. Algorithm A can be organized in a terminating manner by
adding a simple control. Given an input constraint ', we add only such constraints x6 jj y and x`y to ' which are not contained in '. We also restrict reflexivity of inclusion x`x to such variables x occurring in '. Given a subset S
of A, a constraint ' is called A0-closed, if algorithm A under the given control
and restricted to the axioms in A0 cannot proceed. (Note that constraints do
not contain ? by definition.) This defines the notion of A-closedness but also of
A1-closedness, A2-closedness, etc., which will be needed later on.

Example 5. Our control takes care of termination in presence of cycles like
x=f (x). For instance, the following constraint is A-closed.

x=f (x) ^ x`y ^ y=f (x) ^ x`x ^ y`y ^ x6 jj x ^ y6 jj y ^ x6 jj y ^ y6 jj x
In particular, A2 and A5 do not loop through the cycle x=f (x) infinitely often.

Proposition 3. If ' is a constraint with m variables then algorithm A with
input ' terminates under the above control in at most 2 \Delta  m2 steps. 2

Proof. Since A does not introduce new variables, it may add at most m2 nondisjointness constraints x6 jj y and m2 inclusions x`y. 2

Proposition 4. Every A-closed constraint ' is satisfiable over P+(Tree).
The proof of this statement is the subject of Section 5. There, we construct the
greatest solution for a satisfiable constraint (Lemma 9). Note that constraints in
general do not have a smallest solution (consider x`f (x y)).

Theorem 5. The satisfiability of INES constraints can be decided in time O(n3)
(offline and online) where n is the constraint size.

Proof. Proposition 2 shows that ' is unsatisfiable if A started with ' terminates
with ?. Proposition 4 proves that ' is satisfiable if A started with ' terminates
with a constraint. Since A terminates for all input constraints under the above
control (Proposition 3), this yields a effective decision procedure. The complexity statement is proved in Proposition 14. The main idea is that every step of
algorithm A can be implemented in time O(n) and that there are O(n2) steps
(Proposition 3). 2 In the proof of Proposition 14, we present an incremental
implementation of algorithm A. It exploits that algorithm A leaves the order
unspecified in which axioms in A are applied. 2

There is a class of constraints on which algorithm A indeed takes cubic time,
namely the inclusions cycles x1`x2 ^ : : : ^ xn\Gamma 1`xn ^ xn`x1 where n * 1. The
closure under A is the full transitive closure Vfxi`xj j i; j 2 f1 : : : ngg plus the
corresponding non-disjointness constraints.

2 Every step of algorithm A costs time O(n) only with respect to an amortized time

analysis, which we do not make explicit in our complexity proof.

8

5 Completeness
The goal of this Section is to prove the completeness of our algorithm as stated
in Proposition 4. We have to construct a solution for every A-closed constraint.
The idea is to construct solution in a substructure of P+(Tree) the structure of
tree prefixes.

Tree Prefixes. A tree prefix o/ is a set of pairs (p; f ) that is prefix closed, path
consistent, and arity consistent. Note that every tree is a tree prefix. The set of
all tree prefixes is denoted by Prefix. We can naturally interpret INES constraints
over tree prefixes such that Prefix becomes a structure. Function symbols f 2 \Sigma 
are interpreted as tree prefix constructors (generalizing tree constructors). The
inclusion symbol ` is interpreted as the inverted subset relation on tree prefixes
that we denote with ^ (i.e., o/1 ^ o/2 iff o/1 ' o/2). The relation o/16 jj o/2 holds over
Prefix iff o/1 [ o/2 is path consistent (and hence a tree prefix).

Proposition 6. Prefix is a substructure of P+(Tree) with respect to the embedding Trees : Prefix ! P+(Tree) given by:

Trees(o/) = fo/ 0 j o/ 0 is a tree such that o/ 0 ^ o/ g

Proof. The mapping Trees is a homomorphism with respect to function symbols f 2 \Sigma  and the relation symbols ` and 6 jj . 2

Corollary 7. If a constraint is satisfiable over Prefix then it is satisfiable over
P+(Tree).

Proof. For constraints x`y, x=f (y), and x6 jj y, this follows from Proposition 6.
A conjunction of such constraints is satisfiable if all conjuncts are satisfiable. 2

Path Reachability. We introduce the path reachability relations ';p and
the notion of path consistency with respect to constraints. For all paths p and
constraint ', we define a binary relation ';p, where x ';p y reads as "y is
reachable from x over path p in '":

x ';" y if x`y in '
x ';i yi if x=f (y1 : : : yi : : : yn) in ';
x ';pq y if x ';p u and u ';q y:

We define relations x ';p f meaning "f can be reached from x via path p in '":

x ';p f if x ';p y and y=f (_u) in ';
For example, if ' is the constraint x`y ^ y=f (u; z) ^ z=g(x) then the following
reachability from x relationships hold: x ';" y, x ';2 z, x ';21 x, x ';21 y, etc.,
as well as x ';" f , x ';2 g, x ';21 f , etc.

9

Definition 8 Path Consistency. We call a constraint ' path consistent if the
following two conditions hold for all x, y, p, f , and g.

1. If x ';p g, x`x, and x ';p f then f = g.
2. If x ';p g, x6 jj y, and y ';p f then f = g.

Lemma 9. Every A1-A2-closed and path consistent constraint is satisfiable over
Prefix.

Lemma 10. Every A3-A5-closed constraint is path consistent.
Proof of Proposition 4. We have to show that every A-closed constraint ' is
satisfiable. ' is path consistent by Lemma 10, satisfiable in Prefix by Lemma 9,
and hence satisfiable in P+(Tree) by Corollary 7. 2

6 Non-Empty Sets versus Trees
We discuss interpretations of INES constraints over tree prefixes and over nonempty sets of trees. For the fragment of equality constraints we also consider an
interpretation over trees.

Theorem 11. Given an INES constraints ', the following three statements are
equivalent:

1. ' is satisfiable (over P+(Tree)).

2. ' is satisfiable over Prefix.
3. ' is satisfiable in some model of the axioms in A.

Proof. 1) to 3). If ' is satisfiable over P+(Tree), then it is satisfiable in some

model of A, since P+(Tree) is a model of A by Proposition 2.

3) to 2). Let ' be satisfiable in some model of A. Algorithm A terminates when

started with ' by Proposition 3. It outputs a constraint  (and not ?) that
is equivalent to ' in all models of A.  is A-closed and hence satisfiable over
Prefix by Lemmata 9 and 10.

2) to 1). If ' is satisfiable over Prefix then it is satisfiable by Corollary 7. 2

An equality constraint is a conjunction of equalities x=y and x=f (y). Over
P+(Tree), equalities can be expressed by inclusions since the inclusion ordering is antisymmetric (x=y $ x`y ^ y`x).

Theorem 12. The three first-order theories of equality constraints over nonempty sets of trees, over tree prefixes, and over trees coincide (i.e., of the structures P+(Tree), Prefix and Tree).3

3 Independently, A. Colmerauer observed this for P+(Tree) and Tree (pers. comm.).

10

Proof. This follows from the fact that all axioms of the complete axiomatization
of trees [18, 19, 12] are valid for non-empty sets of trees. This holds for the axioms
of the form 8y9!x(x1=f1(x y) ^ : : : ^ xn=fn(x y)). Validity of the other axioms
is immediate since they are already contained in A with inclusion replaced for
equality. 2

In contrast, first-order formulae over inclusion constraints can distinguish the
structures P+(Tree) and Prefix. A formula that holds over Prefix but not over
P+(Tree) is given by

8x(a`x ^ b`x ! 8y(y`x))

where a 6= b. Another formula distinguishing both structures comes with a
constraint-based reformulation of the coherence property (defined for complete
partial orders in [6]).

We say that an ordering relation satisfies the coherence property if it satisfies the
following formulae for all finite sets I (where inclusion symbol is interpreted as
the given ordering).

V

i;j2I 9z (z`xi ^ z`xj) ! 9z(

V

i2I z`xi)

This formula states that for all variable assignment ff the elements from the
finite set fff(xi) j i 2 Ig have a common lower bound if every two of its elements
ff(xi); ff(xj ) have (i; j; 2 f1; : : : ; ng). For inclusion over non-empty sets this
property does not hold. There it states the non-emptiness of an n-intersection
t1" : : : "tn if all pairwise intersections ti"tj are non-empty (i; j 2 f1 : : : ng),
which is refuted by the example I = f1; 2; 3g and ff(x1) = fa; bg, ff(x2) = fa; cg,
ff(x3) = fb; cg for distinct constants a; b; c.

Proposition 13. The tree prefix ordering ^ satisfies the coherence property.
Proof. For some finite index set J ` I and variable assignment ff into Prefix,
note that ff is a solution of 9z (Vi2J z`xi) iff Si2J ff(xi) is path consistent. If ff
is a solution of all 9z(z`xi ^ z`xj ) then all pairwise unions ff(xi) [ ff(xj ) are
path consistent such that the union Si2I ff(xi) is path consistent. Hence ff is a
solution of 9z(Vi2I z`xi). 2

Acknowledgements. We would like to thank David Basin, Denys Duchier, Witold
Charatonik, Harald Ganzinger, Gert Smolka, Ralf Treinen and Uwe Waldmann, as well
as the anonymous referees for valuable comments on drafts of this paper. The research
reported in this paper has been supported by the the Esprit Working Group CCL II
(EP 22457) and the Deutsche Forschungsgemeinschaft through the Graduiertenkolleg
Kognitionswissenschaft and the SFB 378 at the Universit"at des Saarlandes.

References

1. A. Aiken, D. Kozen, and E. Wimmers. Decidability of Systems of Set Constraints

with Negative Constraints. Information and Computation, 1995.

11

2. A. Aiken and E. Wimmers. Solving Systems of Set Constraints. In Proc. 7th LICS,

pp. 329-340. IEEE, 1992.
3. A. Aiken and E. Wimmers. Type Inclusion Constraints and Type Inference. In

Proc. 6th FPCA, pp. 31-41. 1993.
4. A. Aiken, E. Wimmers, and T. Lakshman. Soft Typing with Conditional Types.

In Proc. 21st POPL. ACM, 1994.
5. L. Bachmair, H. Ganzinger, and U. Waldmann. Set Constraints are the Monadic

Class. In Proc. 8th LICS, pp. 75-83. IEEE, 1993.
6. H. P. Barendregt. The Type Free Lambda Calculus. In Barwise [7], 1977.
7. J. Barwise, ed. Handbook of Mathematical Logic. Number 90 in Studies in Logic.

North-Holland, 1977.
8. D. Basin and H. Ganzinger. Automated Complexity Analysis Based on Ordered

Resolution. In 11th LICS. IEEE, 1996.
9. W. Charatonik and L. Pacholski. Negative set constraints with equality. In

Proc. 9th LICS, pp. 128-136. 1994.
10. W. Charatonik and L. Pacholski. Set constraints with projections are in NEXPTIME. In Proc. 35th FOCS, pp. 642-653. 1994.
11. W. Charatonik and A. Podelski. The Independence Property of a Class of Set

Constraints. In Proc. 2nd CP. LNCS 1118, Springer, 1996.
12. H. Comon and P. Lescanne. Equational problems and disunification. Journal of

Symbolic Computation, 7:371-425. 1989.
13. R. Gilleron, S. Tison, and M. Tommasi. Solving Systems of Set Constraints with

Negated Subset Relationships. In Proc. 34nd FOCS, pp. 372-380. 1993.
14. N. Heintze. Set Based Analysis of ML Programs. Technical Report CMU-CS-93-

193, School of Computer Science, Carnegie Mellon University. July 1993.
15. N. Heintze and J. Jaffar. A Decision Procedure for a Class of Set Constraints

(Extended Abstract). In Proc. 5th LICS, pp. 42-51. IEEE, 1990.
16. D. Kozen. Logical aspects of set constraints. In Proc. CSL, pp. 175-188. 1993.
17. M. J. Maher. Logic semantics for a class of committed-choice programs. In J.-L.

Lassez, ed., Proc. 4th ICLP, pp. 858-876. The MIT Press, 1987.
18. M. J. Maher. Complete Axiomatizations of the Algebras of Finite, Rational and

Infinite Trees. In Proc. 3rd LICS, pp. 348-457. IEEE, 1988.
19. A. I. Malc'ev. Axiomatizable Classes of Locally Free Algebras of Various Type.

In The Metamathematics of Algebraic Systens: Collected Papers 1936-1967, ch. 23,
pp. 262-281. North-Holland, 1971.
20. D. McAllester. Automatic Recognition of Tractability in Inference Relations.

Journal of the ACM, 40(2), Apr. 1993.
21. D. McAllester and R. Givan. Taxonomic Syntax for First-Order Inference. Journal

of the ACM, 40(2), Apr. 1993.
22. D. McAllester, R. Givan, D. Kozen, and C. Witty. Tarskian Set Constraints. In

Proc. 11th LICS. IEEE, 1996.
23. M. M"uller. Type Analysis for a Higher-Order Concurrent Constraint Language.

Doctoral Dissertation. Universit"at des Saarlandes, Technische Fakult"at, 66041
Saarbr"ucken, Germany. In preparation.
24. J. Niehren. Functional Computation as Concurrent Computation. In 23rd POPL,

pp. 333-343. ACM, 1996.
25. J. Niehren and M. M"uller. Constraints for Free in Concurrent Computation. In

Proc. 1st ASIAN, LNCS 1023, pp. 171-186. Springer, 1995.
26. The Oz Programming System. Programming Systems Lab, Universit"at des Saarlandes. Available at http://www.ps.uni-sb.de/www/oz/.

12

27. V. A. Saraswat. Concurrent Constraint Programming. The MIT Press, 1993.
28. G. Smolka. The Oz Programming Model. In J. van Leeuwen, ed., Computer Science Today, LNCS 1000, pp. 324-343. Springer, 1995.

A Ines-Constraints for Program Analysis
We are investigating the application of INES constraints for program analysis.
More specifically, we intend to construct a type analysis system for concurrent
constraint programming languages [17, 27] such as Oz [28] (see [24, 25] for formal foundations of Oz). During the execution of programs in these languages,
the possible values of program variables are approximated by constraints. For
programs without search (backtracking), it is considered a programming error if
the set of possible values is empty for some program variable.

For illustration, consider the following Oz program with its constraint-based
analysis added in comments (using the special function symbol proc).4

proc -P X"" X=a end % 9x(p=proc(x) ^ x=a) ^
proc -Q Y"" Y=b end % 9y(q=proc(y) ^ y=b) ^
-P Z"" -Q Z"" % proc(z)`p ^ proc(z)`q

The program contains the definition of two procedures P and Q with formal
arguments X and Y, respectively, as well as two procedure applications with the
same actual argument Z. On execution of these applications, the constraints Z=a
and Z=b will be emitted which are inconsistent with each other.

A program analysis in terms of INES-constraints can detect this error as follows.
The program variables P, Q, X, Y, and Z are mapped to constraint variables p,
q, x, y, and z, and the program subexpressions are mapped to constraints as
indicated in the comments. The conjunction of these constraints is checked for
satisfiability and the program is rejected if this test fails. The above program is
rejected since its analysis implies z`a ^ z`b which is unsatisfiable.

We have implemented a type analysis system based on INES-constraints and
use it experimentally for Oz programs. The full description of the type analysis
system is out of the scope of this paper and will be reported in [23].

B Omitted Proofs
Proposition 1. The satisfiability problems of INES constraints and of flat INES
constraints have the the same time complexity up to a linear transformation.

4 This example also appeared in the follow-up paper [11] with the explicit statement

that it is borrowed from here.

13

Proof. With respect to the structure P+(Tree), every flat INES constraint is
equivalent to a first-order formula over INES constraints.

x=f (y) $ x`f (y) ^ f (y)`x x6 jj y $ 9z (z`x ^ z`y):
Conversely, every INES constraint is equivalent to a first-order formula over flat
INES constraints.

x`f (t) $ 9y9z (x`y ^ y=f (z) ^ z`t) t`t0 $ 9x(t`x ^ x`t0)
f (t)`x $ 9y9z (t`z ^ f (z)=y ^ y`x)

These equivalences can be interpreted as constraint transformers from INES constraints into flat INES constraints and vice versa. Hence, for every INES constraint
there exists a satisfaction equivalent constraint and vice versa. It is easy to organize the transformations such that they preserve the size of constraints up to a
factor of 2. Hence, the complexity of the satisfiability problems is preserved. ut

Lemma 9. Every A1-A2-closed and path consistent constraint is satisfiable over
Prefix.

Proof. Let ' be A1-A2-closed and path consistent. We define a variable assignment prefix' into Prefix as follows:

prefix'(x) = f(p; f ) j x ';p f g
The path consistency of ' (condition 1) implies the path consistency of
prefix'(x). Thus prefix'(x) is a tree prefix (one can show this by induction over
p). We now verify that prefix' is a solution of '.

- Let x`y in '. If y ';p g then x ';p g by the definition of path reachability.

Thus, prefix'(y) ` prefix'(x).

- Consider x=f (y1 : : : yn) in '. If i 2 f1 : : : ng and yi ';p g then x ';ip g.

Thus, f (prefix'(y1) : : : prefix'(yn)) ` prefix'(x). For the converse inclusion,
we first show that ' satisfies the following two properties for all g and i:

P1 if x ';" g then f = g.
P2 if i 2 f1 : : : ng and x ';ip g then yi ';p g.

For proving P1 we assume x ';" g. Since x=f (_u) in ' we have x`x in ' by
A1:1-closedness. Thus x ';" f which implies f = g since ' is path consistent
(condition 1) and A1:1-closed, i.e. P1 holds.

For proving P2, we assume i 2 f1 : : : ng and x ';ip g. By definition of path
reachability there exists x0, f 0, and _v such that

x ';" x0; x0=f 0(y01 : : : y0i : : : y0n); y0i ';p g:

14

The A1:2-closedness of ' and x ';" x0 imply x`x0 in '. The path consistency
of ' (condition 1) and the A1:1-closedness of ' implies f = f 0. Hence, A2-

closedness ensures yi`y0i in ' such that yi ';p g holds. This proves P2.

We finally show prefix'(x) ` f (prefix'(y1) : : : prefix'(yn)). Given (p; g) 2
prefix'(x), we distinguish two cases. If p=", then x ';" g such that P1 implies
f = g and hence ("; g) 2 f (prefix'(y1) : : : prefix'(yn)). If p = iq then x ';iq g
such that P2 yields yi ';q g and hence (p; g) 2 f (prefix'(y1) : : : prefix'(yn)).
- Let x6 jj y in '. We have to show that the set prefix'(x) [ prefix'(y) is path

consistent. If (p; g) 2 prefix'(x) and (p; f ) 2 prefix'(y) then x ';p g and
y ';p f . The path consistency of ' (condition 2) implies f = g. 2

Lemma 10. Every A3-A5-closed constraint is path consistent.
Proof. Let ' be A3\Gamma A5-closed. Condition 1 of Definition 8 follows from condition
2 of Definition 8 and A3:1-closedness. The proof of condition 2 in Definition 8 is
by induction on paths p. We assume x, y, f , and g such that x ';p f , x6 jj y in ',
and x ';p g.

If p = ", then there exist n; m * 0, x1; : : : ; xn, y1; : : : ym, _u, and _v such that:

x`x1 ^ : : : ^ xn\Gamma 1`xn ^ xn=f (x0) in ' ;
y`y1 ^ : : : ^ ym\Gamma 1`ym ^ ym=g(y0) in ' :

A3-closedness implies that xn6 jj ym in ' (A3:2 yields x6 jj y1 in ', : : :, x6 jj ym in '.
Thus ym6 jj x in ' by A3:3-closedness such that A3:2-closedness yields
ym6 jj x1 in ', : : :, ym6 jj xn in '). Hence, A4-closedness implies f = g. If p = iq,
then there exist f 0, g0, x0, y0, _u, _v with:

x ';" x0; x0=f 0(x01 : : : x0i : : : x0n) in ' ; x0i ';p f ;
y ';" y0; y0=g0(y01 : : : y0i : : : y0n) in ' ; y0i ';p g :

Since x6 jj x0 in ', we have x06 jj y0 in ' by A3-closedness (this has been proved for
the case p = "). Thus, A4-closedness yields f 0 = g0 such that A5-closedness
implies x0i6 jj y0i in ', and hence f = g holds by induction assumption. 2

C Complexity
We elaborate the proof of the complexity and incrementality statement in Theorem 5 by presenting an implementation of algorithm A.

Proposition 14. Algorithm A can be implemented (online and offline) such that
it terminates in time O(n3) where n is the size of the input constraint.

15

Proof. We organize algorithm A as a reduction relation on pairs ('; ) or ?,
where ' is called pool and  store. The store and the pool are either constraints
or empty multisets represented by ?. Initially, the pool ' is the input constraint
called '0 (which may be inputed incrementally in the online case) and the store
 is empty.

Reduction preserves the invariant that ' ^  contains all one-step consequences
of  with respect to algorithm A (and restricted to variables occuring in '0). If
a pair ('; ) reduces to ? then ' ^  is equivalent to ?. If ('; ) reduces to
('0; 0) then ' ^  is equivalent to '0 ^ 0. Reduction either terminates with ?
or with an empty pool. In the latter case, the above invariants ensure that the
final store is A-closed and equivalent to the initial constraint '0.

Let a basic constraint be of the form x`y, x6 jj y, or x=f (y). Reduction can be
implemented by recursively executing the following sequence of instructions:

1. Select a basic constraint '0 from the pool. If '0 is contained in the store

delete if from the pool and finish.

2. Else, for all axioms in A of the form '0 ^ 0 ! '00 with 0 in the pool add

'00 to the pool. If there exists an axiom of the form '0 ^ 0 ! ? in A with
0 in the pool then reduce to ?. If '0 contains a variable x such that x`x
is not contained in the store then add it to the store.

3. Add '0 to the store and delete it from the pool.

We first discuss the necessary data structures for implementing the reduction in
a restricted case. In a second step we show that these restrictions can be omitted.

R1 The algorithm is offline, i.e. the input constraint '0 is statically known.
R2 The arity of constructors in '0 is bounded by a constant, say k.
R3 '0 contains at most one equality per variable.

Let m be the number of variables in '0. The pool can be implemented such that
it provides for the following operations (for instance as a queue).

- select and delete a basic constraint from the pool in O(1).
- add a basic constraint to the pool in O(1).

The store can be implemented as an array of size m for the equalities x=f (y) (at
most one per variable) and a table of size 2\Lambda m2 for the constraints x`y and x6 jj y
for all occuring variables. The store can support the the following operations:

- test the presence of an equality for x in O(1).
- test the membership x`y 2  and x6 jj y 2  in time O(1).
- given a variable x with x=f (y) 2 ', retrieve the function symbol f and the

sequence y in time O(1).

16

- add a basic constraint in time O(1).
- given a variable x, retrieve the set of all y such that x`y 2 ' in time O(m)

(analogously for x6 jj y).

As shown in the next paragraph, the reduction relation can be implemented such
that all operations on the store and the pool are invoked ad most O(m2) times.
Since every operation costs at most O(m) time and m ^ n, this yields an O(n3)
implementation.

There are at most O(m2) distinct basic constraints that may be added to the
store and every basic constraint may be added at most once. Hence there are at
most O(m2) add operations on the store. Constraints are added to the pool only
if some basic constraint is added to the store. In this case, at most O(k) basic
constraints are added to the pool by R2. Hence, there are at most O(k \Lambda  m2) add
operations on the pool.

We finally discuss how to get rid of the above restrictions.

R2 If the arity of constructors is unbounded then we still know that every operation cost at most O(n) where n is the size of '0. The only problem is
that the number of basic constraints that may be added to the pool is no
more bounded by O(n2). This can be circumvented by adding constraints
to the pool at most once, i.e. by remembering those constraints that have
been added to pool (and possibly deleted) before. This can be done with a
quadratic table as for the store.

R3 If we replace all equalities x=f (y) in '0 by x`x0 ^ x0`x ^ x0=f (y) where x0

is a fresh variable respectively then the resulting constraint does not contain
two equations for the same variable.

R1 For an online algorithm, we can add the input constraint '0 incrementally

to the pool. The problem is that the number of variables in '0 is not known
statically. We have to replace our static tables and arrays by dynamic hash
tables such that new variables can be inserted. 2

D Finite Trees
The satisfiability of INES constraints depends on the interpretation over sets of
finite or infinite trees.

Example 6. For instance, the constraint x`f (x) is satisfiable over sets of infinite
trees by x 7! ff (f (f (: : :)))g, but non-satisfiable over sets of finite trees.

The results of Section C carry over to the finite tree case when we add the
"occurs-check" axiom A6 from Table 2 to axiom set A. In particular, Lemma 9
and Theorem 5 can be adapted. Call Treefin the set of finite trees.

17

A6. ' ! ? if x ';p x for some path p 6= "

Table 2. The occurs check axiom
Lemma 15. A path consistent constraint ' closed under A1-A3 and A6 is satisfiable in P+(Treefin).

Proof. To show a A1-A3 and A6-closed and path consistent constraint ' satisfiable in P+(Tree) we have defined the prefix prefix'(x) = f(p; f ) j x ';p f g. Since
' is finite and the assumption about axiom A6 excludes cyclic paths, prefix'(x)
must be a finite prefix for all x. Hence, ' is satisfiable in P+(Treefin). 2

Theorem 16. The satisfiability of INES constraints over non-empty sets of finite
trees can be decided (offline or online) in time O(n3).

Proof. The offline version of our algorithm may perform the occurs-check upon
termination. This is linear in the size of the final constraint and cubic in the size
of the start constraint. The online version must schedule the occurs-check after
every step. This is constant if the closure of the reachability relation between
variables is (just like `) implemented by a table of size quadratic in the number
of variables. 2

E Standard Set Constraints
In this section, we take a alternative approach to achieve the expressiveness of
INES constraints. We consider a class of standard set constraints by interpreting
INES constraints over possibly empty sets of trees and allowing for explicit nonemptiness constraints x6`; ("x denotes a non-empty set"). We show that the
cubic algorithm for INES constraints can be adapted to this fragment of standard
set constraints at the cost of additional axioms.

We extend our constraint syntax with explicit non-emptiness constraints as follows.

' ::= '1 ^ '2 j x=f (y) j x`y j x6 jj y j x6`; (1)

We interprete these constraint either in the structure of sets of trees P(Tree)
or in the structure of sets of finite trees P(Treefin). Due to the constraint x6`;,
satisfiability of set constraints differs depending on the choice of finite or infinite
trees. This is not the case without x6`; as we will show below (Corollary 20).
Example 6 adapts as follows.

Example 7. The constraint x6`; ^ x`f (x) is satisfiable over sets of infinite trees
by the variable assignment x 7! ff (f (f (: : :)))g, but non-satisfiable over sets of
finite trees.

18

A1. x`x and x`y ^ y`z ! x`z
A2'. x6`; ^ x=f(y) ^ x`x

0 ^ x0=f(z) ! y`z

A3'. x6`; ^ x`y ! x6 jj y and x`y ^ x6 jj z ! y6 jj z and x6 jj y ! y6 jj x
A4. f(y)`x ^ x6 jj x

0 ^ x0`g(z) ! ? for f 6= g

A5. x=f(y) ^ x6 jj x

0 ^ x0=f(z) ! y6 jj z

A6'. x6`; ^ ' ! ? if x

'
;p x for some path p 6= "

B7. x6`; ^ x=f(y) ! y6`; and y6`; ^ x=f(y) ! x6`;
B8. x6 jj y ! y6`;

Table 3. Axioms for inclusion constraints over (possibly empty) sets of finite trees

In Table 3, we present the set of axioms B, which adapts the set A for the new
constraints. The axiom sets A20, A30, and A60 are changed to make implicit nonemptiness premises explicit, and B7 and B8 have been added. B7 propagates nonemptiness through terms. For every constant symbol a 2 \Sigma , B7:2 postulates that
x=a ! x6`;. B8 states that variables involved in a non-disjointness constraint
must have a non-empty denotation themselves. It is easily checked that all these
axioms are valid in P(Treefin) and that all axioms apart from A6 are valid in
P(Tree).

Proposition 17. Every B-closed constraint is satisfiable over P(Treefin). Every
constraint that is B-closed apart from the occurs-check axiom A6' is satisfiable
over P(Tree).

Proof. Given a B-closed constraint ', we define the set of variables in ' which
are constrained to be non-empty.

Var'6`; def= fx j x6`; in 'g
The part  of ' containing only variables Var'6`; and no non-emptiness constraints is a closed INES constraint.

For the finite tree case, assume ' to be B-closed. By Proposition 15 there exists
a variable assignment ff into P+(Treefin) which satisfies  in P(Treefin).

Define the variable assignment fi by fi(x) = ; for x 62 Var'6`; and fi(x) = ff(x)
elsewhere. We show that fi satisfies '. Let x 62 Var'6`;. We consider the inclusions
in ' containing x.

19

- Constraints x`y are trivially satisfied by fi.
- If y=f (: : : x : : :) in ', then y6`; cannot be in ' due to B7:2. Hence fi(y) =

; ` fi(f (: : : x : : :)).

- If x=f (y1 : : : yn) in ', then yi6`; cannot be in ' for some yi due to B7:1.

Hence fi(x) = ; = fi(f (: : : yi : : :)).

- If y`x in ', then y6`; cannot be in ' due to A30 and B8. Hence fi(y) =

;`fi(x).

For the infinite tree case assume ' to be B-closed with the exception of A6'. Then
by Lemma 9, there exists a satisfying variable assignment ff into P+(Tree). Apart
from that, the above argument is unchanged. 2

Theorem 18. The satisfiability of conjunctions of inclusion constraints and
non-emptiness constraints over sets of finite trees can be tested in O(n3).

Proof. The axioms in Table 3 again induce a fixed point algorithm for the satisfiability test. By carrying over the techniques for the complexity results from
Section C, we obtain the same complexity bound. 2

Atomic Set Constraints. INES constraints interpreted over all sets of finite
trees P(Treefin) are also called atomic set constraints [15]. Theorem 18 implies
time complexity O(n3) for their satisfiability problem. Furthermore, we show
that the occurs check axiom A60 is not needed to decide satisfiability of atomic
set constraints.

Lemma 19. Let the constraint ' be B-closed with the exception of A60. Then '
does not imply ? according to axiom A60.

Proof. If x ';p x for some p 6= ", then also x ';pn x for every path pn = pp : : : p
(n-fold concatenation). Thus, for every prefix q of such a path pn, there exists a

non-constant function symbol f 2 \Sigma  and a term f (y) such that x ';q f (y).

If x6`; 2 ' then ' contains a conjunction expressing that t`x for some
ground term t.

(2)

But then there exist n * 1 and a prefix q of pn leading to a leaf in t. Thus,
(q; a) 2 t for some constant symbol a 2 \Sigma . If x ';q f (y), we can show by
induction over q that there exist z; z0 such that z=a, z`z0, and z0=f (y) in '.
From B7:2, and A30 we obtain z6 jj z0 and hence, ? is a consequence of Axiom A4
which contradicts the assumption. 2

From Lemma 19 and Theorem 18 we have the following Corollary[. Note that
this is in contrast to Examples 6 and 7.

Corollary 20. The satisfiability of atomic set constraints is invariant with respect to the interpretation over sets of finite or infinite trees.

20