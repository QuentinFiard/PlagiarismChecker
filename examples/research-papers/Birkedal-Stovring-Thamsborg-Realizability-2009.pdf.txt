

Realizability Semantics of
Parametric Polymorphism, General References,

and Recursive Types

Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg

IT University of Copenhagen?

Abstract. We present a realizability model for a call-by-value, higherorder programming language with parametric polymorphism, general
first-class references, and recursive types. The main novelty is a relational
interpretation of open types (as needed for parametricity reasoning) that
include general reference types. The interpretation uses a new approach
to modeling references.
The universe of semantic types consists of world-indexed families of logical relations over a universal predomain. In order to model general reference types, worlds are finite maps from locations to semantic types: this
introduces a circularity between semantic types and worlds that precludes a direct definition of either. Our solution is to solve a recursive
equation in an appropriate category of metric spaces. In effect, types are
interpreted using a Kripke logical relation over a recursively defined set
of worlds.
We illustrate how the model can be used to prove simple equivalences
between different implementations of imperative abstract data types.

1 Introduction
In this article we develop a semantic model of a call-by-value programminglanguage with impredicative and parametric polymorphism, general first-class
references, and recursive types. Motivations for conducting this study include:

- Extending the approach to reasoning about abstract data types via relationalparametricity from pure languages to more realistic languages with effects,

here general references. We discussed this point of view extensively earlier [8].- Investigating what semantic structures are needed in general models for effects. Indeed, we see the present work as a pilot study for studying generaltype theories and models of effects (e.g., [12, 19]), in which we identify key
ingredients needed for semantic modeling of general first-class references.- Paving the way for developing models of separation logic for ML-like languages with reference types. Earlier such models of separation logic [16] onlytreat so-called strong references, where the type on the contents of a reference cell can vary: therefore proof rules cannot take advantage of the stronginvariants provided by ML-style reference types.
? Rued Langgaards Vej 7, 2300 Copenhagen S, Denmark

2 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg

We now give an overview of the conceptual development of the paper. Thedevelopment is centered around three recursively defined structures, defined in
three stages. In slogan form, there is one recursively defined structure for eachof the type constructors 8,

ref, and u alluded to in the title.First, since the language involves impredicative polymorphism, the semantic

model is based on a realizability interpretation [4] over a certain recursively de-fined predomain

V . Using this predomain we can give a denotational semanticsof an untyped version of the language. This part is mostly standard, except for

the fact that we model locations as pairs (l, n), with l a natural number corre-sponding to a standard location and

n 2 N [ {1} indicating the "approximationstage" of the location [8]. These pairs, called semantic locations, are needed for

modeling reference types in stage three.1Second, to account for dynamic allocation of typed reference cells, we follow
earlier work on modeling simple integer references [7] and use a Kripke-stylepossible worlds model. Here, however, the set of worlds needs to be recursively
defined since we treat general references. Semantically, a world maps locationsto semantic types, which, following the general realizability idea, are certain
world-indexed families of relations on V : this introduces a circularity betweensemantic types and worlds that precludes a direct definition of either. Thus we
need to solve recursive equations of approximately the following form

W = N0 *fin TT

= W ! CURel (V )

even in order to define the space in which types will be modeled. We formallydefine the recursive equations in certain ultrametric spaces and show how to solve
them using known results from metric-space based semantics. The employedmetric on relations on

V is well-known from work on interpreting recursive typesand impredicative polymorphism [1, 4, 5, 10, 13]; here we extend its use to

reference types (combined with these two other features).Third, having now defined the space in which types should be modeled, the
actual semantics of types can be defined. For recursive types, that also involvesa recursive definition. Since the space T of semantic types is a metric space
we can employ Banach's fixed point theorem to find a solution as the fixedpoint of a contractive operator on T .

2 This involves interpreting the various

type constructors of the language as non-expansive operators. For most typeconstructors doing so is straightforward, but for the reference-type constructor

1 Intuitively, the problem with modeling locations using a flat cpo of natural numbers

is that such "flat" locations contain no approximation information that can be used
to define relations by induction. (See page 12.)
2 We remark that the fixed point could also be found using the technique of Pitts [18];

the proof techniques are very similar because of the particular way the requisite metrics are defined. In this article we do in any case need the metric-space formulation,
but not the extra separation of positive and negative arguments in recursive definitions of relations, and hence we define the meaning of recursive types via Banach's
fixed point theorem.

Parametric Polymorphism, General References, and Recursive Types 3
it is not. That is the reason for introducing the semantic locations mentionedabove: using these, we can define a semantic reference-type operator (and show
that it is non-expansive).Finally, having now defined semantics of types using a family of world-indexed
logical relations, we define the typed meaning of terms by proving the funda-mental theorem of logical relations wrt. the untyped semantics of terms.

In this article we do not consider operational semantics but focus on present-ing the model outlined above. We have earlier shown a computational-adequacy
result for a semantics similar to the untyped semantics defined in stage one [8]: weexpect that result to carry over to the present setup. Also, the model does not validate standard equivalences involving local state,3 although we expect that it canbe extended to do so (see Section 6). Here we rather aim to present the fundamental ideas behind Kripke logical relations over recursively defined sets of worlds.The remainder of the article is organized as follows. Section 2 sketches the
language we consider. In Section 3 we present the untyped semantics, corre-sponding to stage one in the outline above. In Section 4 we present the typed
semantics, corresponding to the last two stages. In Section 5 we present a fewexamples of reasoning using the model. Related work is discussed in Section 6.

Because of space limitations, some definitions and most proofs have beenomitted from this article. They can be found in the long version, available from
the authors' web pages.4

2 Language
We consider a standard call-by-value language with universal types, iso-recursivetypes, ML-style reference types, and a ground type of integers. The language is
sketched in Figure 1. Terms are not intrinsically typed; this allows us to give adenotational semantics of untyped terms. The typing rules are standard [17]. In
the figure, \Xi  and \Gamma  range over contexts of type variables and term variables,respectively. As we do not consider operational semantics in this article, there is
no need for location constants, and hence no need for store typings.

3 Untyped Semantics
We now give a denotational semantics for the untyped term language above. Asusual for models of untyped languages, the semantics is given by means of a
"universal" complete partial order (cpo) in which one can inject integers, pairs,functions, etc. This universal cpo is obtained by solving a recursive predomain
equation. The only non-standard aspect of the semantics is the treatment ofstore locations: locations are modeled as elements of the cpo Loc = N

0 * !where
! is the "vertical natural numbers" cpo: 1 @ 2 @ * * * @ n @ * * * @ 1. (Fornotational reasons it is convenient to call the least element 1 rather than 0.) The

3 The model can only equate computations that allocate references "in lockstep".
4 Currently: http://www.itu.dk/people/kss/papers/poly-ref-rec.pdf

4 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg

Types: o/ ::= int | 1 | o/1 * o/2 | o/1 + o/2 | o/1 ! o/2 | uff.o/ | 8ff.o/ | ff | ref o/
Terms: t ::= x | n | ifz t0 t1 t2 | t1 + t2 | t1 - t2 | () | (t1, t2) | fst t | snd t|

inl t | inr t | case t0 x1.t1 x2.t2 | *x.t | fix f.*x.t | t1 t2|
fold t | unfold t | \Lambda ff.t | t [o/] | ref t | !t | t1 := t2

Sample typing rules:

\Xi  | \Gamma  ` t : o/[uff.o//ff]

\Xi  | \Gamma  ` fold t : uff.o/

\Xi  | \Gamma  ` t : uff.o/
\Xi  | \Gamma  ` unfold t : o/[uff.o//ff]

\Xi , ff | \Gamma  ` t : o/
\Xi  | \Gamma  ` \Lambda ff.t : 8ff.o/ (\Xi  ` \Gamma  )

\Xi  | \Gamma  ` t : 8ff.o/0
\Xi  | \Gamma  ` t [o/1] : o/0[o/1/ff] (\Xi  ` o/

1)

\Xi  | \Gamma  ` t : o/
\Xi  | \Gamma  ` ref t : ref o/

\Xi  | \Gamma  ` t : ref o/

\Xi  | \Gamma  ` !t : o/

\Xi  | \Gamma  ` t1 : ref o/ \Xi  | \Gamma  ` t2 : o/

\Xi  | \Gamma  ` t1 := t2 : 1

Fig. 1. Programming language

intuitive idea is that locations can be approximated: the element (l, 1) 2 Loc isthe "ideal" location numbered

l, while the elements of the form (l, n) for n 6= 1are its approximations. It is essential for the construction of the typed semantics

(in the next section) that these "approximate locations" (l, n) are included.Let in the following

Cpo be the category of !-cpos and !-continuous func-tions. We use the standard notation for products, sums, lifting, and function

spaces in Cpo. Injections into binary sums are written '1 and '2. For any set Mand any cpo

A, the cpo M *fin A has maps from finite subsets of M to A aselements, and is ordered as follows:

f v f0 if and only if f and f0 has the samedomain
M0 and f (m) v f 0(m) for all m 2 M0. The Kleisli composition g ffi f oftwo continuous functions

f : A ! B? and g : B ! C? is given by (gffif)(a) = g bif
f a = bbc for some b, and (g ffi f)(a) = ? otherwise. A complete, pointed par-tial order (cppo) is a cpo containing a least element. The least fixed-point of a

continuous function f : D ! D from a cppo D to itself is written fix f.The semantics below is presented in monadic style [15], i.e., structured using
a monad that models the effects of the language. It is most convenient to definethis monad by means of a Kleisli triple: for every cpo

S and every cppo Ans, thecontinuation-and-state monad
TS,Ans : Cpo ! Cpo over S and Ans is given by
TS,Ans A = (A ! S ! Ans) ! S ! Ans, jA a = *k.*s. k a s, and c ?A,B f =
*k.*s. c (*a.*s0.f a k s0) s (with jA : A ! TS,AnsA and ?A,B : TS,AnsA ! (A !
TS,Ans B) ! TS,AnsB.) In the following we omit the type subscripts on j and ?.5

5 Continuations are included for a technical reason, namely to ensure chaincompleteness of the relations that will be used to model computations.

Parametric Polymorphism, General References, and Recursive Types 5
The standard methods for solving recursive (pre)domain equations give so-lutions that satisfy certain induction principles [18, 21]. One aspect of these
induction principles is that, loosely speaking, one obtains as a solution not onlya cpo

A, but also a family of "projection" functions $n on A (one function foreach
n 2 !) such that each element a of A is the limit of its projections $0(a),
$1(a), etc. These functions therefore provide a handle for proving propertiesabout

A by induction on n.

Definition 1. A uniform cpo (A, ($n)n2!) is a cpo A together with a family(

$n)n2! of continuous functions from A to A?, satisfying

$0 = *e. ?
$0 v $1 v * * * v $n v . . .G

n2!

$n = *a.bac

$m ffi $n = $n ffi $m = $min(m,n) .
We are now ready to construct a uniform cpo (V, (ssn)n2!) such that V isa suitable "universal" cpo. The functions

ssn will be used in the definition ofthe untyped semantics. Intuitively, if one for example looks up the approximate

location (l, n+1) in a store s, one only obtains the approximate element ssn(s(l))as a result.

Proposition 2. There exists a uniform cpo (V, (ssn)n2!) satisfying the followingtwo properties:

1. The following isomorphism holds in Cpo:

V ,= Z + Loc + 1 + (V * V ) + (V + V ) + (V ! TS,AnsV )

+ V + TS,Ans V (1)

where TS,AnsV = (V ! S ! Ans) ! S ! Ans, S = N0 *fin V , Ans =(Z + Err)

?, Loc = N0 * !, and Err = 1.2. Abbreviate

T V = TS,Ans V and K = V ! S ! Ans. Define the followinginjection functions corresponding to the summands on the right-hand side of

the isomorphism (1):

inZ : Z ! V in+ : V + V ! V
inLoc : Loc ! V in! : (V ! T V ) ! V

in1 : 1 ! V inu : V ! V
in* : V * V ! V in8 : T V ! V

With that notation, the functions ssn : V ! V? satisfy (and are determinedby) the equations shown in Figure 2.

These two properties determine V uniquely, up to isomorphism in Cpo.

6 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg

ss0 = *v.?
ssn+1(inZ(m)) = binZ(m)c

ssn+1(in1(*)) = bin1(*)c
ssn+1(inLoc(l, 1)) = binLoc(l, n + 1)c

ssn+1(inLoc(l, m)) = binLoc(l, min(n + 1, m))c

ssn+1(in*(v1, v2)) = ae bin*(v01, v02)c if ssn v1 = bv01c and ssn v2 = bv02c? otherwise

ssn+1(in+('i v)) = ae bin+('i v0)c if ssn v = bv0c? otherwise (i = 1, 2)

ssn+1(inu v) = ae binu v0c if ssnv = bv0c? otherwise

ssn+1(in8 c) = bin8(ssTn+1 c)c
ssn+1(in! f) = _in! `*v. ae ss

Tn+1 (f v0) if ssn v = bv0c?

otherwise '*

Here the functions ssSn : S ! S? and ssKn : K ! K and ssTn : T V ! T V are defined as
follows:

ssS0 = *s.? ssK0 = *k.? ssT0 = *c.?

ssSn+1(s) = ae bs0c if ssn ffi s = *l.bs0(l)c? otherwise

ssKn+1(k) = *v.*s. ae k v0 s0 if ssn v = bv0c and ss

Sn+1 s = bs0c?

otherwise

ssTn+1(c) = *k.*s. ae c (ss

Kn+1 k) s0 if ssSn+1 s = bs0c?

otherwise .

Fig. 2. Characterization of the projection functions ssn : V ! V?.

Proof (sketch). By modifying the usual projection functions, obtained from aminimal-invariant solution of (1), on arguments corresponding to locations. ut

From here on, let V and (ssn)n2! be as in the proposition above. We fur-thermore use the abbreviations, notation for injections, etc. introduced in the
proposition; in particular, T V = (V ! S ! Ans) ! S ! Ans. Additionally,abbreviate

*l = inLoc(l, 1) and *nl = inLoc(l, n). Let errorAns = b'2*c 2 Ansbe the "error answer" and let error =

*k.*s. errorAns 2 T V be the "error com-putation".

In order to model the three operations of the untyped language that involvereferences, we define the three functions alloc :

V ! T V , lookup : V ! T V ,and assign :
V ! V ! T V . The first two of these functions are shown inthe lower part of Figure 3. The third function, assign, is similar to lookup:

the idea is that when one assigns a value to an approximate location, only anapproximate value is inserted in the store. Notice that it would not suffice to

Parametric Polymorphism, General References, and Recursive Types 7
For every t with FV(t) ` X, define the continuous JtKX : V X ! T V by induction on t:J

xKX ae = j(ae(x))J
*x.tKX ae = j(in!(*v. JtKX,x (ae[x 7! v])))J

t1 t2KX ae = Jt1KX ae ? *v1. Jt2KX ae ? *v2. ae f v2 if v1 = in! ferror otherwiseJ
\Lambda ff.tKX ae = j(in8 (JtKX ae))J

t [o/]KX ae = JtKX ae ? *v. ae c if v = in8 cerror otherwiseJ
ref tKX ae = JtKX ae ? *v. alloc vJ

!tKX ae = JtKX ae ? *v. lookup vJ
t1 := t2KX ae = Jt1KX ae ? *v1. Jt2KX ae ? *v2. assign v1 v2. . .

alloc v = *k *s. k (*free(s)) (s[free(s) 7! v])

(where free(s) = min{n 2 N0 | n /2 dom(s)})

lookup v = *k *s. 8??!??:

k s(l) s if v = *l and l 2 dom(s)
k v0 s if v = *n+1l , l 2 dom(s), and ssn(s(l)) = bv0c?

Ans if v = *n+1l , l 2 dom(s), and ssn(s(l)) = ?
errorAns otherwise

Fig. 3. Untyped semantics of terms (sample cases).

define, e.g., lookup(*n+1l )(k)(s) = ? for l 2 dom(s), and hence avoid mentioningthe projection functions: lookup would then not be continuous.

We are now ready to define the untyped semantics.
Definition 3. Let t be a term and let X be a set of term variables such thatFV(

t) ` X. The untyped semantics of t with respect to X is the continuousfunction J

tKX : V X ! T V defined by induction on t in Figure 3.

The semantics of a complete program is defined by supplying an initial con-tinuation and the empty store:

Definition 4. Let t be a term with no free term variables or type variables. Theprogram semantics of

t is the element JtKp of Ans defined by JtKp = JtK; ; kinit sinitwhere
sinit 2 S is the empty store and

kinit = *v.*s. ae b'1 mc if v = inZ(m)error

Ans otherwise.

We emphasize that even though the above semantics is slightly non-standardbecause of the use of the projection functions in lookup and assignment, we can
still use it to reason about operational behaviour: as mentioned in the Introduc-tion an earlier adequacy proof [8] should carry over to the present setting.

8 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg
4 Typed Semantics
In this section we present a "typed semantics", i.e., an interpretation of typesand typed terms. As described in the introduction, types will be interpreted as

world-indexed families of binary relations on the universal cpo V . Since worldsdepend on semantic types, the space of semantic types is obtained by solving
a recursive metric-space equation, i.e., by finding a fixed-point of a functor onmetric spaces.

4.1 Ultrametric Spaces
Recall that a metric space (X, d) is 1-bounded if d(x, y) <= 1 for all x and yin

X. Let CBUlt be the category with complete, 1-bounded ultrametric spacesas objects and non-expansive (i.e., non-distance-increasing) functions as morphisms [6]. This category is cartesian closed [22]; here one needs the ultrametricinequality. The exponential (

X1, d1) ! (X2, d2) has the set of non-expansivefunctions from (
X1, d1) to (X2, d2) as the underlying set, and the "sup"-metric
dX1!X2 as distance function: dX1!X2(f, g) = sup{d2(f (x), g(x)) | x 2 X1}.For a given non-empty, complete metric space, consider the function fix that

maps every contractive operator to its unique fixed-point (which exists by Ba-nach's fixed-point theorem). On complete ultrametric spaces, fix is non-expansive
in the following sense.
Proposition 5. Let (X, d) 2 CBUlt be non-empty. For all contractive functions
f and g from (X, d) to itself, d(fix f, fix g) <= d(f, g).

4.2 The Space of Semantic Types
We now turn to constructing the space of semantic types. First, some standarddefinitions. For every cpo

A, let Rel (A) be the set of binary relations R ` A * Aon
A. A relation R 2 Rel(A) is complete if for all chains (an)n2! and (a0n)n2!such that (

an, a0n) 2 R for all n, also (tn2!an, tn2!a0n) 2 R. Let CRel (A) be theset of complete relations on

A. For every cpo A and every relation R 2 Rel (A),define the relation
R? 2 Rel(A?) by R? = { (?, ?) }[{ (bac, ba0c) | (a, a0) 2 R }.For
R 2 Rel (A) and S 2 Rel (B), let R ! S be the set of continuous functions
f from A to B satisfying that for all (a, a0) 2 R, (f a, f a0) 2 S.On uniform cpos, we furthermore define uniform binary relations [1, 4]:

Definition 6. Let (A, ($n)n2!) be a uniform cpo. A relation R 2 Rel(A) is uni-form with respect to (

$n)n2! if $n 2 R ! R? for all n. Let CURel (A, ($n)n2!)be the set of binary relations on

A that are complete and uniform with respectto (
$n)n2!.

Below we define a number of metric spaces that will be used in the interpre-tation of types. After defining one of these metric spaces (

X, d), the "distancefunction"
d will be fixed, so we usually omit it and call X itself a metric space.Let in the following (

A, ($n)n2!) be a uniform cpo and let CURel (A) =CURel(
A, ($n)n2!). First, as in Amadio [4], we obtain:

Parametric Polymorphism, General References, and Recursive Types 9
Proposition 7. The set CURel (A) is a complete, 1-bounded ultrametric spacewith the distance function given by

d(R, S) = ae 2 -

max{ n2! | $n2R!S? ^ $n2S!R? } if R 6= S

0 if R = S.

We also need metrics on "worlds" and monotone functions from worlds:
Proposition 8. Let (X, d) 2 CBUlt. The set N0 *fin X of finite maps fromnatural numbers to elements of

X is a complete, 1-bounded ultrametric spacewith the distance function given by

d0(\Delta , \Delta 0) = ae max {d(\Delta (l), \Delta 0(l)) | l 2 dom(\Delta )} if dom(\Delta ) = dom(\Delta 0)1 otherwise.
Definition 9. For every (X, d) 2 CBUlt, define an "extension" ordering <= onN

0 *fin X by \Delta  <= \Delta 0 () dom(\Delta ) ` dom(\Delta 0) ^ 8l 2 dom(\Delta ). \Delta (l) = \Delta 0(l).

Proposition 10. Let (X, d) 2 CBUlt, and let (N0 *fin X) !mon CURel (A) bethe set of functions

* from N0 *fin X to CURel (A) that are both non-expansiveand monotone in the sense that

\Delta  <= \Delta 0 implies *(\Delta ) ` *(\Delta 0). This set is acomplete, 1-bounded ultrametric space with the "sup"-metric, given by

d0(*, *0) = sup {d(*(\Delta ), *0(\Delta )) | \Delta  2 N0 *fin X} .
Proof (sketch). It suffices to show that the set of monotone and non-expansivefunctions is a closed subset of the (complete) metric space of all non-expansive

functions. To that end, one needs the following property: if R, S 2 CURel (A)satisfy that

$n 2 R ! S? for all n, then R ` S. ut

In the rest of this section we do not need the extra generality of uniform cpos:recall that

V is the cpo obtained from Proposition 2 and abbreviate CURel (V ) =CURel(
V, (ssn)n2!).

Proposition 11. The operation mapping each (X, d) 2 CBUlt to the metricspace (N

0 *fin X) !mon CURel(V ) (as given by the previous proposition) canbe extended to a functor

F : CBUltop ! CBUlt in the natural way.

Given (X, d) 2 CBUlt and 0 < ffi < 1 one defines ffi * (X, d) 2 CBUlt with thesame underlying set

X but with all distances multiplied by ffi.

Theorem 12. There exists a unique (up to isomorphism) complete, 1-bounded
ultrametric space bT such that the following isomorphism holds in CBUlt:b

T ,= 12 ((N0 *fin bT ) !mon CURel (V )) . (2)
Proof (sketch). By a well-known adaptation of the inverse-limit method [6, 20,22] one can show that so-called locally contractive mixed-variance functors on

CBUlt have unique fixed-points up to isomorphism. The functor F defined inthe previous proposition is only locally non-expansive (i.e., non-expansive as a
function on each hom-set) so we use the standard method of multiplying F withthe "shrinking factor"

ffi = 1/2, thus obtaining a locally contractive functor. ut

10 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg
4.3 Interpretation of Types
Let in the following bT be a complete, 1-bounded ultrametric space satisfying (2),
and let App : bT ! 12 ((N0 *fin bT ) !mon CURel (V )) be an isomorphism. Forconvenience, we use the following abbreviations (where the names W and T are

intended to indicate "worlds" and "types", respectively):

W = N0 *fin bTT

= W !mon CURel(V ) .

With that notation, (2) expresses that bT is isomorphic to 12 T . We choose T asour space of semantic types.

We additionally define families of relations on "states" (elements of S),"continuations" (elements of

K = V ! S ! Ans), and "computations" (el-ements of
T V ). First, (S, (ssSn )n2!) is a uniform cpo; abbreviate CURel (S) =CURel(
S, (ssSn )n2!). We then define

TS = W ! CURel (S)
as the element of CBUlt obtained from Proposition 7 and the exponential in
CBUlt. (The elements of TS are non-expansive but not necessarily monotone func-tions.) As for continuations and computations, one observes that (

K, (ssKn )n2!)and (
T V, (ssTn )n2!) are "uniform cppos", i.e., satisfy conditions similar to thosein Definition 1, but in the category of cppos and strict continuous functions (see

the long version of this article for the details). Using analogues of Definition 6and Propositions 7 and 10 we obtain CURel(

K) = CURel(K, (ssKn )n2!) andCURel(
T V ) = CURel(T V, (ssTn )n2!) in CBUlt and define

TK = W !mon CURel (K)T

T = W !mon CURel (T V ) .

In all the ultrametric spaces we consider here, all non-zero distances have theform 2-

m for some m. For such ultrametric spaces, there is a useful notion of

n-approximated equality of elements: the notation x =n y means that d(x, y) <=2-

n. The ultrametric inequality then amounts to the fact that each relation =n

is transitive, and therefore an equivalence relation. The factor 1/2 in (2) impliesthat worlds that are "(

n + 1)-equal" only contain "n-equal" semantic types.To interpret types of the language as elements of T , it remains to define a

number of operators on T (and TT and TK) that will be used to interpret thevarious type constructors of the language; these operators are shown in Figure 4.
Notice that the operator ref is defined in terms of n-approximated equality =n onCURel(

V ). In order to interpret the fragment of the language without recursivetypes, it suffices to verify that these operators are well-defined (e.g., ref actually

maps elements of T into T .) In order to interpret recursive types, however, wefurthermore need to verify that the operators are non-expansive.

Lemma 13. The operators *, +, ref , !, cont, and comp shown in the lowerpart of Figure 4 are well-defined and non-expansive.

Parametric Polymorphism, General References, and Recursive Types 11
For every \Xi  ` o/, define the non-expansive Jo/K\Xi  : T \Xi  ! T by induction on o/:J

ffK\Xi  ' = '(ff)J
intK\Xi  ' = *\Delta . { (inZ m, inZ m) | m 2 Z }J

1K\Xi  ' = *\Delta . { (in1 *, in1 *) }J
o/1 * o/2K\Xi  ' = Jo/1K\Xi  ' * Jo/2K\Xi  'J
o/1 + o/2K\Xi  ' = Jo/1K\Xi  ' + Jo/2K\Xi  'J

ref o/K\Xi  ' = ref (Jo/K\Xi  ')J8

ff.o/K\Xi  ' = *\Delta . { (in8 c, in8 c0) | 8* 2 T . (c, c0) 2 comp(Jo/K\Xi ,ff '[ff 7! *])(\Delta ) }J

uff.o/K\Xi  ' = fix i**. *\Delta . { (inu v, inu v0) | (v, v0) 2 Jo/K\Xi ,ff '[ff 7! *](\Delta ) }j (see Def. 14)J
o/1 ! o/2K\Xi  ' = (Jo/1K\Xi  ') ! (comp(Jo/2K\Xi  '))

The following operators and elements are used above:

* : T * T ! T comp : T ! TT
+ : T * T ! T cont : T ! TK
ref : T ! T states 2 TS!

: T * TT ! T RAns 2 CRel(Ans)

(*1 * *2)(\Delta ) = { (in*(v1, v2), in*(v01, v02)) | (v1, v01) 2 *1(\Delta ) ^ (v2, v02) 2 *2(\Delta ) }
(*1 + *2)(\Delta ) = { (in+('1 v1), in+('1 v01)) | (v1, v01) 2 *1(\Delta ) }[ {

(in+('2 v2), in+('2 v02)) | (v2, v02) 2 *2(\Delta ) }

ref (*)(\Delta ) = { (*l, *l) | l 2 dom(\Delta ) ^ 8\Delta 1 >= \Delta . App (\Delta (l)) (\Delta 1) = *(\Delta 1) }[ {

(*n+1l , *n+1l ) | l 2 dom(\Delta ) ^ 8\Delta 1 >= \Delta . App (\Delta (l)) (\Delta 1) =n *(\Delta 1) }

(* ! ,)(\Delta ) = { (in! f, in! f0) | 8\Delta 1 >= \Delta . 8(v, v0) 2 *(\Delta 1) .(f v, f0 v0) 2 ,(\Delta 1) }

cont(*)(\Delta ) = { (k, k0) | 8\Delta 1 >= \Delta . 8(v, v0) 2 *(\Delta 1). 8(s, s0) 2 states(\Delta 1). (k v s, k0 v0 s0) 2 RAns }
comp(*)(\Delta ) = { (c, c0) | 8\Delta 1 >= \Delta . 8(k, k0) 2 cont(*)(\Delta 1).8

(s, s0) 2 states(\Delta 1). (c k s, c0 k0 s0) 2 RAns }

states(\Delta ) = { (s, s0) | dom(s) = dom(s0) = dom(\Delta )^ 8

l 2 dom(\Delta ). (s(l), s0(l)) 2 App (\Delta (l)) (\Delta ) }

RAns = { (?, ?) } [ { (b'1 mc, b'1 mc) | m 2 Z }

Fig. 4. Interpretation of types.

12 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg

It is here, in order to show that ref is well-defined (and non-expansive), thatwe need the approximate locations

*nl . Suppose for the sake of argument thatlocations were modeled simply using a flat cpo of natural numbers, i.e., suppose

that Loc = N0 and that ss1(inLoc l) = binLoc lc for all l 2 N0. The definition of refwould then have the form ref (

*)(\Delta ) = {(inLoc l, inLoc l) | l 2 dom(\Delta )^ . . . }. Thefunction ref (
*) from worlds to relations must be non-expansive. But assume thenthat
\Delta  =1 \Delta 0; then ref (*)(\Delta ) =1 ref (*)(\Delta 0) by non-expansiveness, and henceref (
*)(\Delta ) = ref (*)(\Delta 0) since ss1 is the (lifted) identity on locations. In otherwords, ref (

*) would only depend on the "first approximation" of its argumentworld
\Delta : this can never be right, no matter what the particular definition ofref is.
6 This observation generalizes to variants where ssn(inLoc l) = binLoc lc)

for some arbitrary finite n.For any finite set

\Xi  of type variables, the set T \Xi  of functions from \Xi  to T is ametric space with the product metric:

d0(', '0) = max{ d('(ff), '0(ff)) | ff 2 \Xi  }.

Definition 14. Let o/ be a type and let \Xi  be a type environment such that \Xi  ` o/.The relational interpretation of

o/ with respect to \Xi  is the non-expansive functionJ
o/ K\Xi  : T \Xi  ! T defined by induction on o/ in Figure 4. The interpretation ofrecursive types is by appeal to Banach's fixed-point theorem (see below).

In more detail, the use of Banach's fixed point theorem in the interpretationof recursive types means that well-definedness of J

o/ K\Xi  must be argued togetherwith non-expansiveness, by induction on
o/ .7 This is similar to the more familiarsituation with the untyped semantics of terms presented in Section 3: there,

well-definedness must be argued together with continuity because of the use ofKleene's fixed-point theorem in the interpretation of

fix f.*x.t. The proof thatJ
uff.o/ K\Xi  is non-expansive uses Proposition 5.We need the following substitution lemma, easily proved by induction on

o/ :

Lemma 15. Let o/ and o/ 0 be types such that \Xi , ff ` o/ and \Xi  ` o/ 0. For all
' 2 T \Xi , Jo/[o/ 0/ff]K\Xi  ' = qo/ y\Xi ,ff ('[ff 7! Jo/ 0K\Xi  ']) .

Corollary 16. Juff.o/ K\Xi  ' = *\Delta . { (inu v, inu v0) | (v, v0) 2 Jo/ [uff.o/ /ff]K\Xi  ' \Delta  }.

4.4 Interpretation of Terms
As for the interpretation of terms, we must show that the untyped meaning of atyped term is related to itself at the appropriate type. We first show that comp

respects the operations of the monad T .
Definition 17. For * 2 T and , 2 TT and \Delta  2 W, let * \Delta ! , be the binaryrelation on functions

V ! T V defined by

* \Delta ! , = { (f, f 0) | 8\Delta 1 >= \Delta .8(v, v0) 2 *(\Delta 1). (f v, f 0 v0) 2 ,(\Delta 1) } .
6 In particular, the obvious definition of ref as ref (*)(\Delta ) = {(inLoc l, inLoc l) | l 2

dom(\Delta ) ^ 8\Delta 1 >= \Delta . App (\Delta (l)) (\Delta 1) = *(\Delta 1)} would not be well-defined, since it
would not be non-expansive in \Delta .
7 Non-expansiveness of Jo/K

\Xi ,ff implies contractiveness of **. *\Delta . { (inu v, inu v0) |

(v, v0) 2 Jo/K\Xi ,ff '[ff 7! *] (\Delta ) }, as needed in the definition of Juff.o/ K\Xi  '.

Parametric Polymorphism, General References, and Recursive Types 13
Proposition 18. Let *, *1, *2 2 T and \Delta  2 W. (1) If (v, v0) 2 *(\Delta ), then
(j v, j v0) 2 comp(*)(\Delta ). (2) If (c, c0) 2 comp(*1)(\Delta ) and (f, f0) 2 *1 \Delta !comp(

*2), then (c ? f, c0 ? f 0) 2 comp(*2)(\Delta ).

Definition 19. For every term environment \Xi  ` \Gamma  , every ' 2 T \Xi , and every
\Delta  2 W, let J\Gamma  K\Xi  ' \Delta  be the binary relation on V dom(\Gamma  ) defined byJ

\Gamma  K\Xi  ' \Delta  = { (ae, ae0) | 8x 2 dom(\Gamma  ). (ae(x), ae0(x)) 2 J\Gamma  (x)K\Xi  ' \Delta  } .
Definition 20. Two typed terms \Xi  | \Gamma  ` t : o/ and \Xi  | \Gamma  ` t0 : o/ of the sametype are semantically related, written

\Xi  | \Gamma  |= t , t0 : o/ , if for all ' 2 T \Xi , all
\Delta  2 W, and all (ae, ae0) 2 J\Gamma  K\Xi  ' \Delta ,iq

tydom(\Gamma  ) ae, Jt0Kdom(\Gamma  ) ae0j 2 comp(qo/ y\Xi  ')(\Delta ) .
Theorem 21 (Fundamental Theorem). Every typed term is semanticallyrelated to itself: if

\Xi  | \Gamma  ` t : o/ , then \Xi  | \Gamma  |= t , t : o/ .

Proof (sketch). By showing the stronger property that semantic relatedness ispreserved by all the term constructs. The proof uses Proposition 18. ut

Corollary 22 (Type soundness).

1. If ; | ; ` t : o/ is a closed term of type o/, then JtK; ; 6= error.2. If ; | ; `

t : int is a closed term of type int, then JtKp 6= errorAns .

5 Examples
The model can be used to prove the equivalences in Section 5 of our earlierwork [8]. More specifically, one can use the model to prove that some equivalences

between different functional implementations of abstract data types are still validin the presence of general references, and also prove some simple equivalences
involving imperative abstract data types. (See Section 6 for more about extendingthe model to account properly for local state.) Here we only sketch one of these
examples, as well as a "non-example": an equivalence that cannot be shownbecause of the existence of approximated locations in the model.

Example 23. We use the usual encoding of existential types by means of uni-versal types [11]: 9

ff.o/ = 8fi.(8ff. o/ ! fi) ! fi. The type o/m = 9ff. (1 ! ff) *(
ff ! 1) * (ff ! int) can then be used to model imperative counter modules:the idea as that a value of type

o/m consists of some hidden type ff, used to repre-sent imperative counters, as well as three operations for creating a new counter,

incrementing a counter, and reading the value of a counter, respectively.Consider the following two module implementations, i.e., closed terms of
type o/m: J = \Lambda fi.*c. c[ref int]I and J0 = \Lambda fi.*c. c[ref int]I0 where

I = (*x. ref(0), *x. x := !x + 1, *x. !x)
I0 = (*x. ref(0), *x. x := !x - 1, *x. -(!x)) .

By parametricity reasoning, i.e., by exploiting the universal quantification in theinterpretation of universal types, one can show that ; | ; |=

J , J0 : o/m.

14 Lars Birkedal, Kristian Sto/vring, and Jacob Thamsborg
Example 24. Abbreviate 0 = uff.ff. One can show that 0 is an empty type: thereare no closed values of type 0 and furthermore J0K

\Xi  ' = *\Delta .;. Consider nowthe two terms K = *x.2 and K0 = *x.3 of type ref 0 ! int. Given a standard

operational semantics for the language, a simple bisimulation-style argumentshould suffice to show that

K and K0 are contextually equivalent: no referencecell can ever contain a value of type 0, and therefore neither function can ever

be applied. However, the equivalence ; | ; |= K , K0 : ref 0 ! int does not hold.Briefly, the reason is the existence of approximated locations in the model.

6 Related Work
As already mentioned, the metric-space structure on uniform relations over uni-versal domains is well-known [1, 4, 5, 10, 13]. The inverse-limit method for solving recursive domain equations was first adapted to metric spaces by Americaand Rutten [6]; see also Rutten [20]. For a unified account covering both domains and metric spaces, see Wagner [22]. Kripke logical relations are coveredin Mitchell [14, Section 8.6] and in the references there.

Semantic (or "approximated") locations were first introduced in our earlierwork [8]. That work contains an adequacy proof with respect to an operational
semantics and an entirely different, quasi-syntactic interpretation of open types.Here we instead present an in some ways more natural interpretation that results
from solving a recursive metric-space equation, thus obtaining a proper universeof semantic types. Open types are then interpreted in the expected way, i.e., as
maps from environments of semantic types to semantic types.

The fundamental circularity between worlds and types in realizability-stylepossible-worlds models of polymorphism and general references was observed by

Ahmed [2, p. 62] in the setting of operational semantics (and for unary relations).Rather than solve a recursive equation, her solution is to stratify worlds and types
into different levels, represented by natural numbers. So-called step-indexing isused in the definition to ensure that a stratified variant of the fundamental
theorem holds. These stratified worlds and types are somewhat analogous to theapproximants of recursive-equation solutions that are employed in the inverselimit method. The main advantage in "going to the limit" of the approximationsand working with an actual solution (as we do here) is that approximation
information is then not ubiquitous in definitions and proofs; by analogy, the only"approximation information" in our model is in the interpretation of references
and in the requirement that user-supplied relations are uniform.8

Ahmed et al. [3] have recently (and independently) proposed a step-indexedmodel of a language very similar to ours, but in which worlds are defined in a

more complicated way: this allows for proofs of much more advanced equivalencesinvolving local state. We believe that our approach extends to this style of worlds
and plan to investigate this further in future work: one potential advantage wouldbe the removal of "approximation information" in definitions and equivalence

8 In future work we plan to perform a more formal comparison.

Parametric Polymorphism, General References, and Recursive Types 15
proofs. We also plan to investigate local-state parameters [9]. In this article,we instead hope to have presented the fundamental ideas behind Kripke logical
relations over recursively defined sets of worlds as needed for semantic modelingof parametric polymorphism, recursive types, and general references.

References

[1] M. Abadi and G. D. Plotkin. A per model of polymorphism and recursive types.

In Proceedings of LICS, pages 355-365, 1990.
[2] A. Ahmed. Semantics of Types for Mutable State. PhD thesis, Princeton University, 2004.
[3] A. Ahmed, D. Dreyer, and A. Rossberg. State-dependent representation independence. In Proceedings of POPL, 2009. To appear.
[4] R. M. Amadio. Recursion over realizability structures. Information and Computation, 91(1):55-85, 1991.
[5] R. M. Amadio and P.-L. Curien. Domains and Lambda-Calculi. Cambridge University Press, 1998.
[6] P. America and J. J. M. M. Rutten. Solving reflexive domain equations in a

category of complete metric spaces. J. Comput. Syst. Sci., 39(3):343-375, 1989.
[7] N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for

storage. In Proceedings of TLCA, number 3461 in LNCS, pages 86-101, 2005.
[8] L. Birkedal, K. Sto/vring, and J. Thamsborg. Relational parametricity for references and recursive types. In Proceedings of TLDI, 2009. To appear.
[9] N. Bohr and L. Birkedal. Relational reasoning for recursive types and references.

In Proceedings of APLAS, number 4279 in LNCS, pages 79-96, 2006.
[10] F. Cardone. Relational semantics for recursive types and bounded quantification.

In Proceedings of ICALP, number 372 in LNCS, pages 164-178, 1989.
[11] K. Crary and R. Harper. Syntactic logical relations for polymorphic and recursive

types. Electronic Notes in Theoretical Computer Science, 172:259-299, 2007.
[12] P. B. Levy. Call-by-push-value: Decomposing call-by-value and call-by-name.

Higher-Order and Symbolic Computation, 19(4):377-414, 2006.
[13] D. B. MacQueen, G. D. Plotkin, and R. Sethi. An ideal model for recursive

polymorphic types. Information and Control, 71(1/2):95-130, 1986.
[14] J. C. Mitchell. Foundations for Programming Languages. The MIT Press, 1996.
[15] E. Moggi. Notions of computation and monads. Information and Computation,

93:55-92, 1991.
[16] R. L. Petersen, L. Birkedal, A. Nanevski, and G. Morrisett. A realizability model

for impredicative Hoare type theory. In Proceedings of ESOP, number 4960 in
LNCS, pages 337-352, 2008.
[17] B. C. Pierce. Types and Programming Languages. The MIT Press, 2002.
[18] A. M. Pitts. Relational properties of domains. Information and Computation,

127:66-90, 1996.
[19] G. D. Plotkin and J. Power. Computational effects and operations: An overview.

Electronic Notes in Theoretical Computer Science, 73:149-163, 2004.
[20] J. J. M. M. Rutten. Elements of generalized ultrametric domain theory. Theoretical Computer Science, 170(1-2):349-381, 1996.
[21] M. B. Smyth and G. D. Plotkin. The category-theoretic solution of recursive

domain equations. SIAM Journal on Computing, 11(4):761-783, 1982.
[22] K. R. Wagner. Solving Recursive Domain Equations with Enriched Categories.

PhD thesis, Carnegie Mellon University, 1994.