

DOI 10.1007/s00165-006-0020-5BCS (C) 2006
Formal Aspects of Computing (2007) 19: 205-224 Formal Aspectsof Computing

On assertion-based encapsulation for object
invariants and simulations1
David A. Naumann
Department of Computer Science, Stevens Institute of Technology, Castle Point on Hudson, Hoboken, NJ 07030, USA
E-mail: naumann@cs.stevens.edu

Abstract. In object-oriented programming, reentrant method invocations and shared references make it difS,cultto achieve adequate encapsulation for sound modular reasoning. This tutorial paper surveys recent progress
using auxiliary state (ghost S,elds) to describe and achieve encapsulation. It also compares this technique withencapsulation in the forms provided by separation logic. Encapsulation is assessed in terms of modular reasoning
about invariants and simulations.
Keywords: Object invariants; Encapsulation and abstraction; Separation and alias control

1. Introduction
Reentrant callbacks and sharing of mutable objects are ubiquitous in object-oriented programs and both causeproblems in reasoning. This paper presents an approach to modular reasoning based on the addition of ghost
("S,ctitious", auxiliary) S,elds with which intended structural relationships can be expressed--in particular, depen-dency relationships. The approach facilitates reasoning about object invariants and simulation relations. Object
invariants are essential for modular proof of correctness and simulations are essential for modular proof ofequivalence or reS,nement of class implementations. The approach offers interdependent solutions to the two
problems. It was developed initially by Barnett et al. [BDF+04] and has been extended by Leino, M "uller, andothers [LM04, BN04, NB06, PCdB05].

Besides giving a tutorial introduction to the approach, we compare it with other approaches and suggest pos-sible extensions and opportunities for future work. M "uller et al. [MPHL04] and Jacobs et al. [JKW03] give good
introductions to the problems and other solution approaches. The book by Szyperski et al. [SGM02] illustratesthe reentrant callback problem using more realistic examples than can S,t in a research paper. We assume the
reader has minimal familiarity with Java-like languages; some familiarity with design patterns [GHJV95] may behelpful. The problems addressed are related to issues in frame speciS,cations, but that is not the focus here. Nor
do we address concurrency, though there are important connections (see, e.g., [Jon96, JLS04]).
Outline. Section 2 sketches the problems. Section 3 addresses invariants and reentrant callbacks in detail and howthey are handled in the ghost variable approach. Section 4 addresses invariants and object sharing using a notion
of ownership. Section 5 discusses additional issues concerning ownership-based invariants and Sect. 6 shows howthe approach can be used for simulations. Section 7 considers an extension of the approach to invariants that

Correspondence and offprint requests to: David A. Naumann, E-mail: naumann@cs.stevens.edu1

Supported in part by the US National Science Foundation, under grants CCR-0208984 and CCF-0429894, and by Microsoft Research.

206 D. A. Naumann
depend on non-owned objects--a sort of rely-guarantee discipline for friendly cooperation. Section 8 revisits theapproach from the perspectives of separation logic and another recent proposal. Section 9 discusses prospects
and challenges for further extensions.

2. How shared objects and reentrant callbacks violate encapsulation
Several constructs in Java and similar programming languages are intended to provide encapsulation. A packagecollects interrelated classes and serves as a unit of scope. Each instance of a class provides some abstraction, as
simple as a complex number or as complex as a database server. A method speciS,cation describes an operationin terms of the abstraction.2 A method implementation uses other abstractions and is veriS,ed, for the sake of
modularity, with respect to their speciS,cations.Less frequently, a class itself provides some abstraction, represented using static S,elds.3 More frequently,
instances of multiple classes collectively provide an abstraction of interest, e.g., a collection and its iterators. Inthis paper we focus on the case of an abstraction provided by a single instance or small group of instances.

To show that a method implementation satisS,es its speciS,cation it is often essential to reason in terms ofan object invariant4 for the target or receiver object self. An object's invariant involves consistency conditions
on internal data structures--its representation, made up of so-called rep objects--and the connection with theabstraction they represent. To a S,rst approximation, an object's invariant is an implicit precondition and postcondition for every method of its class, as described in Hoare's early work on abstract data types [Hoa72]. Theinvariant should not be explicit in a method's public speciS,cation, since it involves the representation. To maintain
the invariant, it should sufS,ce for the methods of the class to maintain it since, owing to encapsulation, it is notsusceptible to interference by client code.

These notions are clear and effective in situations where abstractions are composed by hierarchical layering.However, both reentrant callbacks and object sharing can violate simple hierarchical structure.

Reentrant callbacks. Consider some kind of sensor playing the role of Subject in the Observer design pat-tern [GHJV95]. The sensor maintains a set of registered Views: when the sensor value reaches the threshhold,
v .thresh, of a given view v, the sensor invokes method v.notify() and removes v from the set. This description isin terms of a set, part of the abstraction offered by the Subject; the implementation might store views in an array
ordered by thresh values. The pattern cannot be seen simply as a client layered upon an abstraction: notify isan upcall, to the client. The difS,culty is that v

.notify may make a reentrant callback to the sensors. Consider thefollowing sequence of invocations, where s is a sensor: A client or asynchronous event invokes s

.update() whichchanges the value of the sensor. Before returning, update invokes v
.notify() where v is a view registered with s.Now v maintains a reference, v
.sensor , to s and in order for notify to do its job it invokes v .sensor .getval ()to determine the current sensor value. Because v

.sensor \Theta  s, this invocation of getval is known as a reentrantcallback: control returns to s while another method invocation (here update) is already in progress.

It is common that reentrant callbacks are intended. In the example, getval might simply read a S,eld and causeno problem. However, trouble is likely if v invokes on s a method enum that enumerates the current set of views
of s, since enum likely depends on the invariant that the array of views is in a consistent state--is v still in the setof registered views? In terms of the array, is v in fact in the array?

According to our S,rst approximation, the invariant is required as a precondition for method update and mustbe reestablished by it, but need not hold at the intermediate point where s

.update invokes v.notify. Nor, accordingto the S,rst approximation, should notify be responsible for establishing the invariant. The S,rst approximation

needs to be reS,ned in regard to both when invariants hold and which code is responsible.This example involves cyclic linking s \Lambda  v \Lambda  s of heap objects. We consider next a different problem due to
shared references.

2 The term "method" is used in the sense of object-oriented programming, i.e., of procedures dispatched on the basis of the target object's
allocated type.3

Associated with a class rather than with each instance.4
In a class-based language it is natural to include in a class the declaration of an invariant, with the interpretation that each instance satisS,esthe invariant. To emphasize the instance-oriented nature of such invariants, we use the term object invariant although some authors prefer

"class invariant".

Assertion-based encapsulation 207

item

where

Solver NS Ilist

Clist F

T
T

F
F

Client

y<=w
f(x)<=z

Fig. 1. Some of the objects in a data structure. Labels indicate names of some pointer S,elds

Shared mutable objects. An illustration of the challenging invariants found in object-oriented programs is thestructure of objects and references in Fig. 1. This depicts the data structures used in a constraint solving algorithm [RM99]. Several structural invariants must be maintained by Solver for correctness and efS,ciency of thealgorithm. For example, the objects in the vertical column on the far right form a doubly linked list rooted at NS
and their item S,elds point to elements of the list rooted at Ilist. Moreover, each of those items is in the rangeof the array of arrays Clist. And there is cross-linking between Ilist and NS . These examples can be written as
follows:5

(NS \Theta  null \Xi  NS .prev \Theta  null)\Pi  ( \Sigma  p \Upsilon  NS

.next* -- (p.next \Theta  null \Xi  p.next.prev \Theta  p)\Pi  p

.item \Upsilon  Ilist.next* \Pi  ( \Psi  x , j -- Clist[x ][j ] \Theta  p.item) \Pi  p.item.where \Theta  p)

The client program is intended to have a reference to the Solver object. The data structure includes pointers toclient objects that represent constraints (e.g., "y<=w "). The latter pointers go against a strict hierarchical layering

of abstractions (clients using solvers), but this is not necessarily a problem. But there is no reason for clientsto have references to the objects within the dashed boundary; these are intended to comprise the encapsulated
representation of the solver. A reference to one of these rep objects would be problematic because the client couldupdate the object and falsify the invariant of Solver , contrary to the expectation of encapsulation.

Suppose for simplicity that class Solver has no proper subclasses, nor superclasses other than Object (whichis reasonable in this example since the class basically provides a single algorithm). Fields NS , Ilist, and Clist
can be given private scope so no code of other classes can update them. We can reason in a modular way aboutinvariants that depend only on these S,elds, e.g., Clist ff\Theta  null. If such an invariant is established by the constructor
then--absent reentrant callbacks--we can assume it as a precondition of every method of Solver so long as it isestablished as a postcondition of every method of Solver .

The formula displayed above, however, depends on S,elds of other objects besides the Solver ; scope-basedencapsulation does not protect them from interference by client code. For example, if the client held a reference
o to the S,rst node in NS , i.e., o \Theta  NS with NS ff\Theta  null, then it could set o.prev :\Theta  o, violating the S,rst line of theinvariant which enforces acyclicity. If a method of Solver is then invoked, it is not sound to assume the invariant
as a precondition.Scope alone is inadequate, and it would seem that heap encapsulation needs to be expressed somehow in
terms of state. A notion of heap encapsulation that S,ts this situation is ownership. The idea has three parts.First, the objects comprising the representation of an instance of Solver are considered to be owned by it--the
encapsulation boundary encloses exactly the owned objects. Second, the invariant is only allowed to depend onowned objects. Third, invariant-falsifying updates are prevented by some means. The most common means is to
disallow references to owned objects from outsiders. This is the dominator property [Cla01]: every path to a repof Solver s from an object that is not a rep of s must go through s. Ownership is the topic of Sect. 4.

5 Here * denotes reT^exive transitive closure of S,eld dereferences. We use a Java-like notation with implicit dereferencing: p.next is the value
of S,eld next in the object pointed to by p.

208 D. A. Naumann

Fig. 2. Simple example of reentrant callback (Occurrence of a S,eld name like x without qualiS,er abbreviates self.x.)
3. Reentrance and object invariants
In this section we set aside ownership and present a discipline for invariants in the presence of reentrant callbacks.For clarity we use the contrived example in Fig. 2. In class Subject, the object invariant x

< y is establishedby initialization x
, y :\Theta  0, 1. Method f relies on the invariant (to avoid division by 0); it maintains the invariantbecause it does no updates. At S,rst glance, the invariant is also maintained by m since it increments x and y by the

same amount. Because x and y are local, they are not susceptible to update in code outside of class Subject--andthis is what we need for modular reasoning about Subject. But there is the possibility of a reentrant callback. For
object s of type Subject, an invocation of s.m results in the invocation s.view .notify in a state where the declaredinvariant does not hold for s. Now s

.view .notify in turn invokes z .f , so if s.view .z \Theta  s then an error occurs. Ifinstead notify invoked z
.m then the program would diverge due to nonterminating recursion.

Possible solutions. One reaction to the example is to disallow any reentrant callbacks. This could be done usingstatic analysis for control T^ow. It is not straightforward, because cycles in a pure calling graph are very common,
e.g., owing to recursion over tree-like data structures as well as various design patterns. To avoid rejecting toomany programs, the analysis needs to take aliasing into account. Such analyses are usually not modular, however.
A speciS,cation of allowed calling patterns might also be required, since for example if f simply returned x thenthe callback m \Lambda  notify \Lambda  f is harmless and possibly desirable.

The problem is similar to interference found in concurrent programs and one might try to solve it using locks.But here we are concerned with a single thread of control; if a lock was taken by the initial call to m and that lock
prevented a reentrant call then deadlock would result. (In Java, a lock held by a given thread does not prevent thatthread from reentering the object, precisely to avoid deadlock.) A related solution is to introduce a boolean S,eld
inm to represent that a call of m is in progress and to use n^inm as precondition of m and f . This has similaritiesto the approach advocated later in this paper.

Another approach to the problem is to require the invariant to hold prior to any method call, lest that calllead to a reentrant callback. This has been advocated in the literature [LG86, Mey97] and is sometimes called
visible state semantics [MPHL04]. Our example can be revised to S,t this discipline, by changing the body of m tothis:

x :\Theta  x + 1; y :\Theta  y + 1; view .notify(); (1)
Note that ISubject holds after the second assignment so it is sound for view .notify to rely on it, e.g., by makingreentrant calls. But this approach does not scale to more complicated programs, where the invariant may involve

several data structures, update of which is done by method calls. Most method calls do not lead to reentrantcallbacks and we already noted that some reentrant callbacks are harmless, even desirable.

Another alternative would be to state the invariant as an explicit precondition for those methods that dependon it. Then notify in the example would be rejected because it could not establish the precondition for its call z

.f ().This alternative must be rejected on grounds of information hiding: the predicate ISubject depends on internals

that should be encapsulated within class Subject and not visible to View .Various techniques have been proposed to hide information about an invariant while expressing in the speciS,cation whether it is in force. One alternative is to introduce a typestate [DF01] to stand for "the invariant is inforce". Another approach is to treat its name as opaque with respect to its deS,nition [BP05]; this is pursued in
Sect. 8. Another way to treat the invariant as an opaque predicate, which to the author's knowledge has not beenexplored, is to use a pure method [LCC+03] to represent the invariant. This could be of practical use in runtime
veriS,cation and hiding of internals could be achieved using visibility rules of the programming language.

Assertion-based encapsulation 209

Fig. 3. Variation on Fig. 2 (incomplete)
The Boogie approach. The best features of the preceding alternatives are combined in the so-called Boogiemethodology Barnett et al. [BDF+04]. The idea is to make explicit in preconditions not the invariant predicate,
e.g., ISubject , but rather a boolean abstraction of it (similar to the typestate approach). For reasons that willbecome clear, we use the term inv/own discipline for the Boogie approach.

To a S,rst approximation, the discipline uses a ghost (auxiliary) S,eld inv of type boolean so that o.inv repre-sents the condition that "the invariant I[o

/self] is in force". The idea is that the implication o.inv fi I[o/self]can be made to hold in every state, while I[o

/self] itself is violated from time to time for S,eld updates. The ideacan be used with an ordinary S,eld, but here we use a ghost S,eld that has no runtime signiS,cance but rather is

used only for reasoning. Field inv is considered to be public and declared in the root class Object, so inv canappear as a precondition of any method that depends on the invariant. For our running example, both methods
f and m would have precondition self.inv .The discipline imposes several proof obligations in order to ensure that the following is a program invariant
(i.e., it holds in any state reachable in any computation):

( \Sigma  o -- o.inv fi I[o/self]) (2)
(We let o range over references to all allocated object references.) Consider a method m with (at least) preconditionself

.inv . To reason about correctness of an implementation of m, within the scope where I is visible, the con-junction of (2) and self

.inv yield I as a precondition. On the other hand, outside the scope a reasoner sees onlythe precondition self
.inv .To emphasize that inv is a ghost variable used only for reasoning, the discipline uses special commands pack

and unpack to set inv true and false, respectively. Key proof obligations are imposed on these. The obligationsare most easily understood in terms of allowed proof outlines. In particular, certain preconditions are stipulated
for the special commands and for S,eld updates. The two most important obligations are as follows:

* The precondition for pack E is n^E .inv \Pi  I[E /self]. Clearly I[E /self] is necessary to maintain (2), since packsets E

.inv to true. The S,rst conjunct prevents reentrance to this region of code.*

The precondition for a S,eld update E .f :\Theta  E fl is n^E .inv . This ensures that the update does not falsify (2) forthe object E .

Consider the code in Fig. 3, a variation on Fig. 2. Here the Subject passes self as an argument to notify andan incomplete annotation is sketched. The update x :\Theta  x + 1, which abbreviates self

.x :\Theta  self.x + 1, is subject toprecondition n^self
.inv . As the precondition of m is self.inv , the special command unpack self is needed to setinv false. Now we consider some options in reasoning about notify.

One possibility is for z .inv to be a precondition for notify. Then the implementation of notify is correct:according to the speciS,cation of m, the call z

.m() has precondition z .inv . The implementation of Subject.m isthus forced to establish self
.inv preceding the call to notify.Setting self
.inv true is the effect of the special command pack self, but the stipulated precondition for pack selfis I and this assertion would not hold immediately following the update x :\Theta  x + 1. The situation can be repaired

as in the following possible implementation of m, where, as in (1), the assignment y :\Theta  y + 1 precedes invocationof notify so that the implementation of m can be veriS,ed.

unpack self; assert n^self.inv ; x :\Theta  x + 1; y :\Theta  y + 1; assert ISubject ; pack self; view .notify(self);

210 D. A. Naumann

Fig. 4. Invariant dependent on rep objects
This seems satisfactory for the example but in general it is impractical to impose the visible state semantics forinvariants. The example does show that the discipline can handle this pattern of reasoning.

Another possibility is to retain the implementation of m, so that inv is only restored at the end, as in thefollowing:

unpack self; assert n^self.inv ; x :\Theta  x + 1; view .notify(self); y :\Theta  y + 1; assert ISubject ; pack self;
For the call to notify to be correct, notify cannot have precondition z .inv . But then the implementation of notifyis not correct, because it has no way to establish z

.inv which is the precondition for z .m. On the other hand,notify is free to invoke on z any method that does not require z

.inv . And this is the most typical scenario for thispattern.

In summary, the discipline uses ghost S,eld inv in such a way that harmful reentrant callbacks can be preventedwhile allowing some callbacks. There is a clear intuition, that z

.inv stands for "z is in a consistent state" (it ispacked, for short). Yet the internal representation of Subject is not exposed to View ; there is no need for predicate

ISubject to be visible outside Subject. Invariants of the form inv fi I are made to hold in every state, in particularas precondition for every method call.

4. Sharing and object invariants
Let us set aside the issue of reentrance and turn attention to shared references, while retaining the inv idea.Consider the toy example in Fig. 4. The initialization of Subject2 establishes ISubject2. The annotation of m is
correct: The S,rst assertion follows from precondition self.inv and program invariant (2). The second assertionfollows from the S,rst by straightforward reasoning about incr . Method leak does no updates and thus maintains
ISubject2.Unfortunately, main uses leak to falsify (2). In a state where s

.inv is true, and thus ISubject2[s/self] holds by(2), main uses s
.leak() to obtain a (shared) reference i to s.x . The invocation i.incr () then updates the val S,eld,falsifying s
.x .val < s.y.val and thus falsifying s.inv fi ISubject2[s/self].One diagnosis is that the invariant of Subject2 should not be allowed to depend on S,elds of objects other than

self. Indeed, some proposals in the literature on invariants for object-oriented programs are only sound underthis restriction [LW94]. But for many classes this is highly impractical, for example, the Solver in Section 2.

The name "leak " indicates our diagnosis: just as S,eld x is private, so too the object referenced by x belongswithin class Subject2 in some sense. More precisely, it is a rep object --part of the representation of an abstraction
provided by an instance of Subject2. A rep belongs to its owner and this licenses its owner's invariant to dependon it. Thus the programming discipline must prevent updates of reps by code outside Subject2.

Ownership. As mentioned in Sect. 2, some ownership systems prevent harmful updates by preventing the exis-tence of references from client to rep (the dominator property that all paths to a rep go through its owner). It is

Assertion-based encapsulation 211
easy to violate the dominator property: a method could return a rep pointer, pass it as an argument to a clientmethod, or store it in a global variable.

The dominator property can be enforced using a type system such as the Universe system [M "ul02] and varia-tions on Ownership Types [CNP01, BLS03, BLR02, AC04]. These systems do not directly enforce the dominator
property, which is expressed in terms of paths. Rather, they constrain references, disallowing any object outsidean ownership domain from having a pointer to inside the domain. This means that from the point of view of a
particular object s, the heap can be partitioned into three blocks:*

the singleton containing just s*
the objects owned by s (which, together with s, are called an island)*
all other objects

In these terms, the invariant for s is only allowed to depend on S,elds of objects in the island of s. The dashed boxin Fig. 1 depicts an island. (The idea and the term are both due to Hogg [Hog91].)

The name "leak" suggests that what has gone wrong in the example of Fig. 4 is the very existence of a sharedreference. Ownership type systems prevent harmful updates by alias control: static rules would designate that x is
owned and would reject method leak. This approach has attractive features but it has proved difS,cult to S,nd anownership type system that admits common design patterns and also enforces sufS,ciently strong encapsulation
for modular reasoning about object invariants. In particular, many examples call for the transfer of ownership(see Sect. 5) which does not sit well with type-based systems. Moreover ownership typing involves rather special
program annotations (decorating declarations with ownership information).The alternative presented below controls uses of references and represents ownership restrictions with assertions.6
Ownership using ghost S,elds. The S,rst step is quite direct. Each object has ghost S,eld own to point to its owner.If an object o currently has no owner (as is the case when initially constructed), o

.own \Theta  null. An object encap-sulates the objects it transitively owns. Transitive ownership is a relation on references, deS,ned inductively as

follows: o ffi p iff either o \Theta  p.own or o ffi p.own. Note that ffi is state-dependent. The invariant, IC , for a classC is considered admissible just if whenever IC depends on p

.f for some object p then either self \Theta  p or self ffi p.By representing the ownership relation by a ghost pointer to the owner, we have imposed the invariant that an

object has at most one owner. Transitive ownership thus imposes a hierarchical structure on the heap--thoughone that is mutable.

Rather than preventing aliases to encapsulated reps from clients, the inv/own discipline prevents updatesthat falsify the invariant. For invariants that depend only on S,elds of self, this was achieved by imposing on
every update E .f :\Theta  E fl the precondition n^E .inv . It would be sound, but hardly practical, to impose now theprecondition

n^E .inv \Pi  ( \Sigma  o -- o ffi E fi n^o.inv)
so that no object with an invariant dependent on E .f is packed. One reason this precondition is impractical is thatthe code performing the update of E would have to have ensured that many objects are unpacked, which hardly

seems modular. Another reason is that if o owns p it makes no sense to unpack p unless o is already unpacked,since when it is packed o's invariant depends on p. Finally, the transitive ownership relation, ffi , is not attractive
for direct use in reasoning and that turns out to be unnecessary.The idea with precondition n^E

.inv for an update E .f :\Theta  E fl is that E should get unpacked before updatesare performed on it. Unpacking manifests that control is crossing the encapsulation boundary for E . The discipline uses one more ghost S,eld, com : bool, in order to impose a discipline whereby the T^ow of control acrossencapsulation boundaries respects the current ownership hierarchy. The name stands for "committed": o

.comimplies o
.inv but says in addition that o is committed to its owner and can only be unpacked after its owner getsunpacked. This idea is embodied in two additional program invariants:

( \Sigma  o, p -- o.inv \Pi  p.own \Theta  o fi p.com) (3)

( \Sigma  o -- o.com fi o.inv) (4)

The key consequence of these invariants is the transitive ownership lemma: If o ffi p and n^p.inv then n^o.inv . Itis now possible to maintain program invariant (2) simply by stipulating for every S,eld update E

.f :\Theta  E fl the

6 Skalka and Smith [SS05] also study use-based object conS,nement, for different purposes.

212 D. A. Naumann
precondition n^E .inv . If the update is made in a state where for some object o we have that I[o/self] depends onE

.f then o ffi E by admissibility of I. And by the transitive ownership lemma, n^E .inv implies n^o.inv .In summary, the inv /own discipline prevents interference neither by alias control nor by syntactic conditions

but rather by a precondition, expressed in terms of auxiliary state that encodes dependency and hierarchy.Typically, the precondition of a method that performs updates is self

.inv \Pi  n^self.com. If it performs updateson a parameter x , an additional precondition will be x
.inv \Pi  n^x .com. Manipulation of the com S,eld is part ofwhat it means to pack and unpack an object. For unpack E , the stipulated precondition is now E

.inv \Pi  n^E .comand the effect7is

E .inv :\Theta  false; foreach o such that o.own \Theta  E do o.com :\Theta  false;
For pack E , the stipulated precondition isn^

E .inv \Pi  IC [E /self] \Pi  ( \Sigma  o -- o.own \Theta  E fi o.inv \Pi  n^o.com)
where C is the type of E . The effect is

E .inv :\Theta  true; foreach o such that o.own \Theta  E do o.com :\Theta  true;

5. Additional aspects of the inv/own discipline
The ingredients of the discipline are*

Assertions.*
Ghost S,elds.8*
Updates to ghost S,elds, including update of an unbounded number of objects (in pack E , for example, thecom S,eld of every object owned by E is updated).

This is quite limited machinery and thus the discipline is suitable for use in a variety of settings. It could be for-malized within an ordinary program logic, most attractively a proof outline logic [PdB05b]. It is being explored
in the context of Spec#, a tool based directly on a system of veriS,cation conditions, and in a tool developed byde Boer and Pierik [dBP02] (www.cs.uu.nl/groups/IS/vft/). In both cases the assertion language is (roughly) S,rst
order plus reachability but that is not essential.Rather than relying entirely on annotations, practical use of the discipline can be streamlined through some
simple abbreviations [BDF+04, LM04]. A marked S,eld declaration rep f : T is syntactic sugar for the invariantself

.f .own \Theta  self and peer f : T is syntactic sugar for self.f .own \Theta  self.own.The discipline supports an attractive extension to frame conditions: without mention in a "modiS,es" clause,

a method can update committed objects. For details see [BDF+04].
QuantiS,cation in invariants. We have formalized the program invariants (2-4) using quantiS,cations that rangeover all allocated objects. However, within declared invariants (those we name with I) such quantiS,cation is
problematic. First, if quantiS,cation ranges over currently allocated objects then a quantiS,ed formula can befalsiS,ed by garbage collection, e.g., ( \Psi  o -- P(o)) is falsiS,ed if the only object with property P gets collected.
Garbage sensitivity has been studied in depth by Calcagno et al. [COB03]. A workable solution--and the one weadopt--is to ignore garbage collection in program logic, so quantiS,cations range over all objects that have been
allocated.This still leaves the possibility of falsiS,cation by allocation of a new object. Pierik, de Boer, and Clarke [PCdB05]
have explored, for example, the Singleton pattern [GHJV95] where one might want the invariant of Singleton tobe

( \Sigma  p -- type(p)<=Singleton fi p \Theta  Singleton.it) (5)
where it is a static S,eld of class Singleton and <= denotes subtype. (We write type(p) for the allocated type ofan object p.) This problem can be prevented by including as an admissibility condition that an invariant is not

7 The "foreach" part of the effect can be expressed using a speciS,cation statement: modiS,es com, ensures ( \Sigma  o -- (o.own \Theta  E \Pi  n^o.com) \Xi 
(o.own ff\Theta  E \Pi  o.own \Theta  old(o.own))).8

With inv, own ranging over values that include class names, i.e., slightly beyond ordinary program data types. Similar use of class namesis available in the JML speciS,cation language via the type operator [LCC+03].

Assertion-based encapsulation 213
be falsiS,able by construction of new objects. The authors of the Boogie papers [BDF+04, LM04] intend thatinvariants use quantiS,cation only over owned objects, which achieves this effect. Barnett and Naumann [NB04]
impose it explicitly in their deS,nition of admissibility.An alternative is for predicates like (5) to be considered admissible and to stipulate a suitable precondition
for object construction (new). This alternative has been worked out by Pierik et al. [PCdB05] based on a notionof update guard adapted from that discussed in Sect. 7.

Ownership transfer. A useful feature of the inv/own discipline is that, while it imposes hierarchical structure onthe heap, that structure is mutable. Field own is initially null; a fresh object has no owner. The S,eld is updated by
special command set-owner E to E fl, the effect of which is simply E .own :\Theta  E fl. As with ordinary S,eld update,it is subject to precondition n^E

.inv . Moreover, in the case that E fl ff\Theta  null the command adds to the objectsowned by E fl--and it adds to those transitively owned by the transitive owners of E fl. Their invariants depend

on their owned objects so we require them to be unpacked. The stipulated precondition for set-owner E to E flis n^E

.inv \Pi  (E fl \Theta  null \Xi  n^E fl.inv ). Thus the ownership structure can change dynamically when the relevantinvariants are not in force.9

Change in ownership structure is difS,cult or impossible with ownership type systems, in part because thetype system imposes the ownership conditions as a program invariant, i.e., true in every state. Transfer has been
found to be useful in a number of situations. The most common seems to be initialization by the client of anabstraction that then becomes owned by another; this was pointed out by Leino and Nelson [DLN98] with the
example of a lexer that owns an input stream but that stream is provided initially by the client. Transfer betweenpeer owners is appropriate, for example, with several queues of tasks that are moved between queues for load
balancing. The trickiest form of transfer is when an encapsulated rep is released to clients; this form has beenhighlighted by O'Hearn in the example of a memory allocator, considering that the allocator owns elements of
the free list [OYR04]. Other examples can be found in [LM04, BN05b].Transfer of ownership is important but infrequent. The Spec# project [BLS05] is exploring inference to determine where the set-owner, pack , and unpack commands are needed, in order to lighten the annotation burden.Integration with ownership types merits investigation for this purpose.

Taking subclasses into account. If C is a subclass of D then an instance of C has S,elds of D and of C . Moreover,it should maintain the invariant, ID , of D but C may impose an additional invariant IC . Instead of using a
boolean to track whether "the" invariant is in effect, the general form of the inv/own discipline lets inv rangeover classnames, with the interpretation that o

.inv <=C means that o is packed with respect to the invariant of Cand of any superclasses of C . This works smoothly if we assume IObject is true.

Owned objects are now owned at a particular class, i.e., S,eld own ranges over null and pairs (C , o) withtype(o)<=C indicating that the object is owned by o at class C and is part of the representation on which IC (and
invariants in subclasses) depends.The pack and unpack commands are revised to mention the class involved. For unpack E from C , the stipulated
precondition is now E .inv \Theta  C \Pi  n^E .com and the effect is

E .inv :\Theta  super (C ); foreach o such that o.own \Theta  (E , C ) do o.com :\Theta  false;
For pack E to C , the stipulated precondition is

E .inv \Theta  super (C ) \Pi  IC [E /self] \Pi  ( \Sigma  o -- o.own \Theta  E fi o.inv \Pi  n^o.com)
and the effect is

E .inv :\Theta  C ; foreach o such that o.own \Theta  (E , C ) do o.com :\Theta  true;
The program invariants are also adapted slightly, as follows.

( \Sigma  o, C -- o.inv <=C fi IC [o/self])
( \Sigma  o, p, C -- o.inv <=C \Pi  p.own \Theta  (o, C ) fi p.com)

( \Sigma  o -- o.com fi o.inv <=type(o))

9 Because S,eld own is mutable, it is possible to create a cycle of owners. But owing to the stipulated preconditions of the discipline, objects
in a cycle cannot be packed.

214 D. A. Naumann

Fig. 5. Revised Subject2
Methods are dynamically dispatched, which raises the question how to express the precondition that beforewas just inv \Theta  true. Now an implementation in class C needs precondition inv \Theta  C . The Boogie paper [BDF+04]
introduces notation which at a method call site means E .inv \Theta  type(E ) but in the method implementation meansthat self

.inv equals the static type. This is worked out by treating method inheritance as an abbreviation for astub method with appropriate unpack and pack; this generates a proof obligation on the inherited method: it

must preserve any invariant that is introduced in the subclass.
Soundness and completeness. Soundness of the discipline is taken to mean that the three displayed conditionshold in every reachable state of a properly annotated program, i.e., one in which every S,eld update and every
instance of a special command pack, unpack, or set-owner is preceded by an assertion that implies the stipulatedprecondition.

For sequential programs in a Java-like language, soundness is sketched in the original Boogie paper [BDF+04]and more rigorously in [NB06]; see also [LM04]. Extension of the discipline to concurrent programs has also
been investigated [JLS04].Completeness is another matter. It is not clear to this author how to formulate an interesting notion of completeness. Clearly it has to be relative to completeness of an underlying proof system. The discipline hinges onhaving every object invariant expressed in the form inv fi I with I admissible. Does completeness say that
every predicate of this form that is in fact invariant can be shown so in a proof outline following the discipline?There are related questions: Which admissible predicates are expressible as formulas? Which formulas denote
admissible predicates? A convincing notion of completeness would be especially useful if it could be adapted toother disciplines like the one discussed in Sect. 7.

In what sense are invariants necessary at all? One could perhaps simply conjoin (2), (3), and (4) to precon-ditions and postconditions throughout the program. But this raises another expressiveness question. And for
modularity it might require abstraction from internals, e.g., using model S,elds. Notions of completeness that takemodularity into account have recently been studied by Pierik and de Boer [PdB05a].

Static invariants. We have focused on object invariants that depend on instance S,elds. It is also sensible for anobject invariant to depend on static S,elds, e.g., the Singleton invariant (5). There is also the possibility of a static
invariant for a class. Examples are given by Leino and M "uller [LM05] and by Pierik et al. [PCdB05]. The basicidea is to use a static S,eld in the same way as inv , to represent whether the invariant of a class is in force. There
are intricacies due to the way in which classes are initialized in Java.

6. Coupling invariants and simulation
This section describes, without much detail, how the inv/own discipline has been adapted to reasoning aboutsimulations.

Figure 5 shows an alternate implementation of class Subject2 from Fig. 4. In this section, we assume thatSubject2 in Fig. 4 has been corrected by deleting method leak . The behavior of the two versions is the same, at the
level of abstraction of the programming language, e.g., ignoring speed and size of object code. (More formally, thetwo versions give rise to equivalent behavior in any well formed context of usage.) This would still be true if, e.g.,
a method is added to read the current integer value of x . The standard way to prove behavioral equivalence oftwo modular units such as classes is by means of a coupling relation that has the simulation property. A coupling
relates states for one implementation with states for the other. For an instance s of Subject2 in the S,rst version(Fig. 4) and sfl for the second version (Fig. 5), a suitable coupling is

s.x .val \Theta  sfl.x .val \Pi  s.y.val L/ s.x .val \Theta  sfl.z
Such a relation is a simulation provided that it is preserved by corresponding method implementations--as itis by the two versions of m in the example. (The same technique is also used to prove reS,nement: in case one

Assertion-based encapsulation 215
implementation diverges less often or is less nondeterministic, the notion of preservation is adapted slightly.Another use is to justify "observationally pure" method calls in assertions [BNSS06, Nau06b].) The technique is
practical because the simulation property only needs to be proved for the re-implemented methods: For arbitraryprogram contexts, simulation should follow from simulation for the revised class, by a general representation
independence property of the language.The simulation technique was articulated by Hoare [Hoa72] drawing on work of Milner [Mil71] and has
seen much development for use with purely functional programs [Plo73, Mit86, Pit00] as well as S,rst orderimperative and concurrent programs [LV95]. For S,rst order imperative programs the topic is thoroughly surveyed in the textbook by de Roever et al. [dRE98]. Object oriented programs have features in common withhigher order imperative programs, for which representation independence is nontrivial owing to semantic difS,-
culties [OT95, Pit97, Nau02]. Two sources of complication in object oriented programs are inheritance and theubiquitous use of recursive classes; these were addressed by Cavalcanti and the author [CN02]--under the drastic
simpliS,cation that copying is used instead of sharing. Their results have been used to validate laws of programrefactoring [BSC03, BSCC04].

The representation independence property, i.e., the possibility of reasoning in a modular way using simula-tions, is a measure of the encapsulation facilities of a language. We have seen how reentrant callbacks and heap
sharing pose a challenge for encapsulation in object oriented programs. Using a static analysis for alias controlin order to impose an ownership structure just for the class under revision, Banerjee and Naumann [BN05a]
prove representation independence for a rich imperative fragment of Java with class-based visibility, inheritanceand dynamic binding, type casts and tests, recursive types, etc. A key feature of that work is the notion of local
coupling which is a binary relation not on complete program states but just on a fragment of the heap consistingof a single instance of the class under revision together with its reps. That is, a local coupling relates pairs of
islands. This induces a coupling relation for the entire program state.There are two main shortcomings to the early work of Banerjee and Naumann [BN05a]. First, ownership
transfer is disallowed by their conS,nement rules. Second, the result is inadequate for programs with callbacksbecause it is in terms of the standard notion of simulation: for method m to preserve the coupling means that
if two states are initially coupled, then running the two versions of the implementation of m leads to coupledstates. Recall that representation independence says, with A the class for which two versions are considered, that
if all methods m of class A have the simulation property then the relation is preserved when those methods areused in arbitrary program contexts. In fact the proof obligation is not simply that m preserves the coupling, but
rather that it preserves the coupling under the hypothesis that any method m invokes preserves the coupling.10 Thisassumption can be useful in establishing the simulation property for m, but only if the two implementations make
the same method call and from a state where the coupling holds. But at intermediate steps in paired invocationsof (the two versions of) m, the coupling relation need not hold--essentially for the same reason as invariants need
not hold during updates of local state. The hypothesis is of no help if a client method is invoked at an intermediatestep where the coupling does not hold; so the result is sound and even useful but the applications in the cited
work rely on ad hoc reasoning to establish the simulation property.It turns out that the inv /own discipline, which is concerned with preservation of invariants, can be adapted
to simulations, i.e., preservation of coupling relations; see [BN05b]. The intuition is that a coupling is just aninvariant over two copies of program state. Moreover, S,eld inv is observable (by speciS,cations), so both versions
of a method m of A have the same unpack/pack structure. Thus the coupling can take the form of an implicationwith antecedent inv . This form of coupling can then hold at intermediate points in m, in particular at method
calls--so the hypothesis is now of use.The adaptation is not trivial because the inv /own discipline only controls updates. Stronger encapsulation is
needed for representation independence than for invariants. Recall the example leak in Sect. 4. If we revise it asfollows, so that the leaked reference is only read, then the program is compatible with the inv /own discipline.

class Main -s : Subject2 :\Theta  new Subject2;method main() - i : Integer :\Theta  s

.leak(); Print(i.val); """"

For invariants, it is only a problem if i is updated. But for simulations, we need independence from reps--noteven dependence by reading--as otherwise a client's behavior can be affected and the representation is not fully

encapsulated. This can be achieved by stipulating additional preconditions for S,eld access [BN05b] (which inpractice can usually be discharged trivially in virtue of standard visibility rules).

10 The reason this is sound is similar to the justiS,cation for proof rules for recursive procedures: it is essentially the induction step for a proof
by induction on the maximum depth of the method call stack.

216 D. A. Naumann

Subject3

List

Listen

Cache

View

Listen

owner
pointer

dependent

Fig. 6. Observer pattern using separate listeners
Informal considerations of information hiding suggests that clients should not read S,elds of reps, and this isconS,rmed by the analysis of representation independence. In this light, it seems that the main advantage of the
inv /own discipline over ownership types is the ability to temporarily violate the ownership property in order totransfer objects between owners.

7. Beyond single-object invariants
At the beginning of Sect. 2 we focused attention on situations where each instance of a class is intended to providesome cohesive abstraction such as a collection. Such examples are ubiquitous, but so too are situations where
several objects cooperate to provide some abstraction. This section sketches an extension of the inv/own disciplineto one form of cooperation.

One example is iterators. To equip a Collection with the possibility of enumerating its elements, a separateobject is instantiated for each enumeration. These Iterator objects need access to the internal data structure of
the Collection, to get elements of the Collection and to track whether the Collection has changed in a way thatmakes the Iterator inconsistent and unusable.

One can imagine formulating a single invariant that pertains to the collective state of a Collection and itsIterators, but it is not clear with what program structure this invariant would be associated. Perhaps the iterator
and Collection classes could be put in a single module, but associating the invariant with the module does notreT^ect that the natural unit is a single Collection instance together with its iterators.

An alternative using more familiar notions is to express the conditions in the object invariant for an Iterator.But it is not feasible for an Iterator to own the Collection on which it depends, since Iterators serve as part
of the interface to clients. Aldrich and Chambers [AC04] explore a T^exible notion of ownership type where thedominator property is not necessarily imposed, but absent this property it is not clear what modular reasoning
is supported.The need for object invariants to depend on non-owned objects arises in quite simple situations. In Sect. 2 we
considered the Solver invariant that involves doubly-linked list conditions p.next \Theta  null \Xi  p.next.prev \Theta  p forall p in NS

.next*. It is possible to associate the entire invariant with class Solver , but at the cost of a quantiS,erand reasoning about reachability. A less centralized formulation would push some of the conditions into object

invariants for the rep objects, e.g., each node could maintain the invariant next \Theta  null \Xi  next.prev \Theta  self. Butfor this to be admissible, a node would need to own its successor. Such an ownership structure is workable for
acyclic doubly-linked lists but not for cyclic ones (and it is awkward if iteration is used instead of recursion).As a more elaborate example, consider the variation on the Observer pattern depicted in Fig. 6, where a
separate Listener object is the target of the notify callback. The dashed and dotted arrows are explained in duecourse. Dashed rectangles are used as before to indicate ownership encapsulation. In this arrangement it would
seem that both the Listener and the View need to read and update their shared Cache object. The situation issimilar to that for Collections/Iterators. We return to this point later. The next point to consider is that we aim
to specify that notiS,cations are required: the Subject has a version number that is incremented each time it is

Assertion-based encapsulation 217
updated, and notify brings the View back in sync. For simplicity we treat the state of the Subject as an integer,val. The View maintains a copy of the state of the sensor, with its version number, in its Cache object. View also
maintains the invariant that this version is not more than one step behind. We assume it is untenable for the Viewto own its Subject sbj . So this invariant is inadmissible according to the previous deS,nition, because it depends
on S,elds val and vsn of sbj .A prerequisite for this dependence is of course that those S,elds are visible in View . Rather than giving them
public visibility, let us suppose that Subject3 includes an explicit declaration

friend View reads vsn, val ;
to extend the scope of visibility. The intention is not only to broaden the scope (as little as possible) but also tolicense dependence of IView on these S,elds. It is thereby also signalled to Subject3 that it has a proof obligation:

if s has type Subject3 then updates to s.val and s.vsn must not falsify the invariant of any object v of type Viewthat is dependent on s.

Visibility based invariants. M"uller and others [M "ul02, LM04, MPHL04] have worked out sound rules for rea-soning about invariants in this sort of peer relationship. They use the term visibility based invariant, in contrast
to ownership based invariants. For our example, the idea would be that Subject3 is responsible to maintain anyinvariants visible to it. In some examples this is quite manageable, but in general there is a problem. The visibility
based approach works at the level of classes. In reasoning about an update of a given instance s of Subject, onemust consider the invariant of any instance v of View since the invariant of View depends on S,elds of Subject.
The question is how the reasoner gets a handle on those objects, given that there can be many instances of View ,dependent on many different instances of Subject3.

In the example at hand, s.listeners is intended to hold references to all listeners for views dependent on s, sothat they can be notiS,ed of updates. Suppose that listeners have a S,eld myview so that the views dependent on s
are those in s.listeners.next*.myview . Then it sufS,ces to prove that updating s.val or s.vsn does not falsify theinvariant of those views. Thus the precondition for s

.val :\Theta  . . . would say that the dependent views are unpacked:

self.inv > Subject \Pi  ( \Sigma  v -- v in s.listeners.next*.myview fi v.inv > View) (6)
It is certainly possible to establish this precondition. In order to update S,elds declared in Subject, s must beunpacked from Subject, so s is not committed. If the views have the same owner, they also are not committed

and thus they can be unpacked if they are not already. But must they have the same owner?Packing and unpacking are designed to embody hierarchical encapsulation. The example involves peers that
are in some sense within the same encapsulation boundary. Moreover, to repack a view v , the Subject would needto justify that IView [v

/self] holds--but why should IView [v/self] be visible in Subject?The preceding challenges are not insurmountable using just standard proof rules and the visibility assumptions. But by using a ghost S,eld to track the relevant dependencies, more localized reasoning can be achieved.
The friendship discipline. We posited temporarily that an instance s of Subject3 has access to its dependent viewsvia listener and myview , but in fact Listener has no such S,eld--so Subject3 only has references to the Listener s
on which it is supposed to invoke notify. For another example of such a situation, a long-lived Collection mighthave many associated Iterators. The Iterators could depend on a timestamp S,eld in the collection, in order that
an Iterator can be considered invalid if the collection gets updated. But there may be no reason for the Collectionto maintain a list of its iterators. Instead of incurring a performance cost to maintain the list merely for the sake
of reasoning, it can be stored in a ghost S,eld.The friendship discipline [BN04] extends the inv

/own discipline by adding a ghost S,eld deps to hold referencesto dependents (the dashed arrows in Fig. 6). As before, consider a declaration "friend View reads vsn

, val; " inSubject3. We use the terminology granter for class Subject3 and friend for the class View to which access is

granted. Here access means that the admissibility condition is relaxed to allow the invariant of class View todepend on vsn and val in Subject3. Moreover each instance v of View is required to maintain the following
invariant:

If in the current state IView [v /self] depends on s then v \Upsilon  s.deps.
One can now adapt the precondition (6) for S,eld update to quantify over just s.deps. Special commands attachand detach are used to manipulate deps, much like pack and unpack [BN04, NB06].

The friendship discipline also rectiS,es another T^aw of (6). Instead of requiring that all dependent views areunpacked, we account for the possibility that the update is not going to falsify the invariant of a packed view.

218 D. A. Naumann
For example, suppose that we dropped the requirement, sbj .vsn L/ 1<=st.vsn, that a View not lag too far behind,keeping as invariant only this:

st.vsn<=sbj .vsn \Pi  (st.vsn \Theta  sbj .vsn fi st.val \Theta  sbj .val ) (7)
Then an update of the form vsn, val :\Theta  vsn + 1, . . . never falsiS,es the invariant of a view.More generally, we allow View to declare conditions --visible to the granting class Subject3-- under which

its invariant is not falsiS,ed. The declaration

guard sbj .vsn :\Theta  \Theta  by U where U \Theta df \Theta  L/ 1<=self.st.vsn<=\Theta 
protects the original invariant IView including condition sbj .vsn L/ 1<=st.vsn. (Here \Theta  is a fresh variable to beinstantiated as needed.) This is because the proof obligation imposed on View for U is satisS,ed:

IView \Pi  U fi wp(self.sbj .vsn :\Theta  \Theta )(IView )
Owing to this we can now weaken the precondition (6) for S,eld update, since under condition U the invariant ofa packed view cannot be falsiS,ed. For update vsn :\Theta  vsn + 1 in code of Subject3, the precondition is11

inv > Subject3 \Pi  ( \Sigma  v -- v in deps fi v.inv > View \Xi  U [self/sbj , v/self, (vsn + 1)/\Theta ]) (8)
Just as, for any object o, the S,eld o.inv serves as a publicly visible abstraction of I[o/self], here U serves toabstract from wp(self

.sbj .vsn :\Theta  \Theta )(IView ) in a way suitable to be visible in Subject, without fully revealingIView . The substitutions adapt the update guard from the nomenclature of View to that of Subject3 and to the

particular update vsn :\Theta  vsn + 1.
History constraints. For the invariant (7), an alternative to the friendship discipline is to use history con-straints [LW94]. A history constraint is a two-state predicate on an object, interpreted as a constraint on any two
successive visible states of the object (e.g., states at method call or return). Let us use primes on S,eld names todesignate the "after" state, to give an example history constraint that is satisS,ed by Subject3:

vsn<=vsnfl
That is, vsn increases monotonically. Invariant (7) cannot be falsiS,ed by any update of vsn that satisS,es theconstraint.

In general, if the granter declares a history constraint and the friend's invariant is not falsiS,able by updatessatisfying the constraint then no precondition concerning the friend needs to be imposed on updates by the
granter. To the author's knowledge, history constraints have only been studied in the case where they depend onthe object's own S,elds, not on S,elds of reps [LW94]. It could be valuable to study constraints that depend on S,elds
of reps (just as our example update guard depends on S,elds of the Cache of View ).A shortcoming of history constraints is that their meaning depends on a notion of visible state, just like the
visible state semantics of invariants. The inv/own discipline dodges this by using S,eld inv to maintain programinvariants which are true "at every semicolon". Perhaps there is a comparable notion of history constraint.

It is not clear how to use a history constraint if IView includes the condition sbj .vsn L/ 1<=st.vsn which weuse to force notiS,cations. It is true that the vsn S,eld of a Subject is incremented by one in each atomic update,
but the strongest history constraint is that it is nondecreasing, since at some computation steps it is unchangedand after sufS,ciently many steps it can change by more than one.

An advantage of history constraints is that they handle a sequence of multiple updates to Subject whereas theupdate guard is formulated in terms of an atomic update. In fact this can also be achieved by slightly extending
the friendship discipline; this has been worked out and applied to the iterator pattern [NB06]. The key change(from [BN04]) is to allow a friend's invariant to depend on the inv S,eld of the granter. An invariant of the form
sbj .inv fi . . . is not falsiS,ed by unpacking sbj , which is needed anyway in order to perform updates. Then thefriend's update guard for inv imposes a proof obligation only when the granter is re-packed.

Update/yielding. How can a granter establish the U case in precondition (8)? To reason that a given view satisS,esU , in the context of Subject, it might be possible to use speciS,cations of methods of View . In particular, U could
be given as postcondition of notify.

11 For clarity we use substitution notation but a precise formulation must handle aliasing in some way, e.g., [AO97].

Assertion-based encapsulation 219

A history constraint is something like a pre/post speciS,cation that applies not to a particular method orcommand but to arbitrary pairs of observations. One can see an update guard as a precondition for arbitrary
steps; what about a postcondition thereof (in addition to the invariant)? Under precondition U , increment ofsbj

.vsn by one yields a state where the view's version lags exactly one step behind. This can be declared as apostcondition in the guard declaration; the idea is worked out in [BN04].

Friendship for coupling. There is a practical problem with the use of simulation to prove equivalence and reS,ne-ments: Few tools exist for proving the simulation property for two versions of a method implementation in a
language like Java. There is, however, a technique sometimes called Reynolds' method for converting a simula-tion property into an ordinary correctness property [Rey81, dRE98, Gri93]. A disjoint copy of the state space is
introduced and the two method bodies to be related, say S0 and S1, are composed into the single command S0; S fl1where S fl

1 is the same as S1 but acting on the copy. Making a disjoint copy is easy in the case of ordinary variables,where suitably named fresh variables can be used. For example, if both programs act on a client variable x then

S fl1 is changed to act on x fl and a suitable coupling includes the condition x \Theta  x fl. The author has extended thismethod to programs acting on mutable heap objects (a special case is presented in [Nau06a]). Whereas primitives

can be related as in x \Theta  x fl, heap objects are duplicated and corresponding pairs must be tracked [BN05a, BN05b].Two heaps are encoded in a single heap using a boolean ghost S,eld dashed to distinguish objects in one heap
from those in the other. A pointer-valued ghost S,eld, mate, is used so that a coupling can require correspondingobjects to be related by x

.mate \Theta  x fl and x \Theta  x fl.mate.Since a coupling is but an invariant over a doubled state space, one would hope to express encoded couplings

using extant techniques for invariants. The condition x .mate \Theta  x fl and x \Theta  x fl.mate is not admissible as anownership-based invariant but it is admissible using friendship.

8. Making footprints explicit
This section contrasts the inv/own discipline with two alternative approaches that rely on more powerful logicsfor assertions. The theme in these approaches is to make the "footprint" of an invariant more explicit; they
require and facilitate reasoning about the footprint of client programs and its disjointness from the footprints ofinvariants.

The inv/own discipline requires clients to establish an object's invariant before invoking methods on it, butthis is made easy because the invariant effectively has the form inv fi I. Although I is typically not visible
to clients, they can establish n^inv by unpacking the object or maintain inv by relying on postconditions of theobject's methods. Hiding of I is not an intrinsic part of the approach; rather the approach is designed to facilitate
hiding.Kassios [Kas06b, Kas06a] makes more explicit use of visibility. An object invariant is treated as a model
S,eld [LCC+03] of boolean type. The S,eld name is public and can be used in method speciS,cations, but its deS,-nition (in terms of encapsulated state) is only visible within the object's class. This achieves some of the effect of
inv . Similarly, Parkinson [BP05, Par05] gives a logic in which an invariant can be treated as a named predicate,with the name visible for use in public method speciS,cations but the deS,nition only visible within the class.
(Such method speciS,cations can be seen as using an existentially quantiS,ed predicate, witnessed by a deS,nitioninside the class [BTS05].) In both approaches, clients are responsible for establishing an object's invariant before
invoking methods on it.Clients are also responsible for not falsifying the invariant of an object, in between invocation of its methods.
The inv/own discipline uses ownership to encode the "footprint" of an invariant, i.e., the locations on which itcurrently depends. (The term "location" is used here deliberately; the footprint is a set of individual S,eld locations,
i.e., object references paired with S,eld names.) The rule for S,eld update ensures that client does not step on thefootprint when the invariant is in force.

In addition to using a model S,eld to represent an invariant, Kassios uses a model S,eld to represent the foot-print, called a dynamic frame, of the invariant. (The technique can be used with other model S,elds as well.) The
condition that S,eld F contains all locations on which I depends is expressed by a second order predicate "Fframes I" (deS,ned by quantifying over all global states). Together with other special expressions, this provides
for elegant speciS,cations that allow clients to reason about disjointness of their updates from the footprint ofan invariant, even though neither the invariant nor the contents of the dynamic frame are exposed outside their
appropriate scope.

220 D. A. Naumann

The technique of Kassios is quite T^exible and has been applied to multi-object invariants including a generalform of the Iterator pattern [Kas06b].
Parkinson [Par05] treats a fragment of Java using the opaque ("abstract") predicates of Bierman and Parkinson[BP05] for a version of separation logic. The special predicate o

.f ffl\Lambda  v expresses that o is an allocated objectand the value of its S,eld f is v. The separated conjunction P * Q of predicates expresses that the heap can be

partitioned into some locations that support the truth of P (e.g., o.f supports the truth of o.f ffl\Lambda  v ), some disjointones that support Q and possibly others.12 Footprints are S,rst-class entities in the work of Kassios; in separation
logic the notion of footprint is implicit but transparent. The typical form for a method precondition is Inv * Pwhere Inv is the (name of) the object invariant and P is a predicate on some objects provided by the client.

A key feature of separation logic is the frame rule which infers -P * R""S -Q * R"" from -P""S -Q"". In particular,if S is a client program that can be proved to satisfy -P""S -Q"" and R is an invariant with footprint disjoint from P
then S does not falsify it. For single-instance modules, the fact that an invariant is disjoint from objects accessedby a client, and not visible to the client, can be expressed by a higher order frame rule [OYR04]. This does not
work for dynamically allocated objects but Parkinson achieves a similar effect using opaque predicates.The frame rule is sound in virtue of the frame property of programs acting on the heap (emphasized by
O'Hearn and Yang [YO02]). First, any terminating computation of a command S reads and writes some S,nitesubset of the initially-existing locations (as well as new ones it allocates). Moreover, if the initial heap decomposes
as a disjoint union h i hfl where h contains all the locations on which S acts, then the S,nal heap decomposes asa disjoint union hflfl i hfl--that is, hfl is untouched. Soundness of the frame rule relies on the "tight interpretation"
of correctness statements used in separation logic: -P""S -Q"" means that the footprint of P covers all (initiallyallocated) locations on which S acts. Thus, by the frame property of S , -P""S -Q"" implies -P * R""S -Q * R"" for any
R, because the precondition means that the footprint of predicate R is disjoint from the footprint of command S .The frame property can be made more explicit using notation that treats the correctness statement as a type
for S :

S : -P"" L/ -Q"" (9)
(For S to have the type -P"" L/ -Q"" just means the triple -P""S -Q"" is valid.) Birkedal et al. [BTSY05] give a typesystem in this style, treating -P * R"" L/ -Q * R"" as a subtype of -P"" L/ -Q"". Their system comes close to making

explicit that (9) amounts to the following, using a quantiS,ed type.

S : ( \Sigma  R -- -P * R"" L/ -Q * R"") (10)
If a client program S can be proved to satisfy some correctness statement -P""S -Q"", which perhaps mentionssome opaque predicates that name invariants of objects of interest to S , the displayed property tells us that S

cannot falsify invariants of objects not in its footprint.With this in mind, the inv

/own discipline can be described as follows. If S is properly annotated then it hasthe property

S : ( \Sigma  I -- -I "" L/ -I "") (11)
where I ranges only over predicates with footprint explicitly encoded by ownership. (The papers on inv/own onlyshow the property with I ranging over explicitly declared invariants.) Note that this is much weaker than (10)

which says S preserves all predicates disjoint from the footprint of S . On the other hand, (10) comes at the costof requiring a sufS,ciently strong speciS,cation -P"" L/ -Q"" to capture the footprint of S . Without that, nothing can
be said about what invariants are preserved by S . By contrast, (11) requires only proper annotation, which canbe far less than full functional speciS,cations.

Another difference between the inv/own discipline and separation logic is that in the latter, the frame property(10) is a consequence of a pre-post property -P""S -Q"" whereas (11) depends on proper annotation of S at intermediate points. The former is purely a property of the pre-post semantics of S whereas the latter involves more.Although there is no technical notion of ownership in separation logic, some speciS,cations lend themselves
to an informal reading in terms of ownership; the slogan is that "ownership is in the eye of the asserter" [O'H05].A complication in Parkinson's approach is that to deal with subclassing, the abstract predicates actually need
to be predicate families, indexed by type. Another shortcoming is due to the fact that the separating conjunction,*, expresses complete disjointness. Parkinson notes that this prevents handling common idioms like the iterator

12 In some versions of separation logic there are no others [Rey02], but because Java is garbage collected the "intuitionistic" version is needed,
in which o.f ffl\Lambda  v means that the heap contains at least o.f but possibly other locations.

Assertion-based encapsulation 221
pattern where controlled sharing is needed. To address this shortcoming, Bornat et al. [BCOP05] devise variationsthat allow overlapping heaps with read and write "permissions"; the idea is extended to Java by Parkinson [Par05].
But this idea is at an early stage of development and seems rather complicated for what is achieved.A relatively minor difference is that Kassios and Parkinson both deal with framing at the level of the individual location, i.e., S,eld of an object. The inv/own discipline treats footprints at the granularity of object referencesonly. An additional mechanism like data groups [LPHZ02, LCC+03] is needed for separating the update of S,elds
within an object.Concerning simulation, the dissertation of Kassios encompasses reS,nement of class implementations but
focuses on framing as a technique. The formalization does not lend itself to general results like representationindependence or refactoring laws. But in light of the results discussed in Sect. 6 it seems likely that a useful
simulation theory could be based on the approach. There has also been work on simulation in separation logic,for simple imperative programs. There are difS,culties with forward simulation, because the standard semantics
relies on allocation being unboundedly nondeterministic in order to validate the frame rule [MTSO04, MY05].The approaches of Kassios and Parkinson both pay a price in going beyond a S,rst-order assertion language.
Far fewer tools can be used off the shelf and in particular less automation may be feasible. In the case of sepa-ration logic, for lack of a complete proof system new notations and results may be needed for new applications
(though this shortcoming can be addressed by moving to higher order separation logic [BTSY05, BBTS05]).Although both Kassios and Parkinson apply their theories to a few interesting examples, neither approach has
been explored thoroughly. Both have very interesting features and deserve to be implemented in prototype toolsto facilitate more extensive experimentation.

9. Challenges for future work
We have not exhausted the issues brought up by the last example in Sect. 7. The guard U depends on ownedobjects (the Cache) of View, exposing some of the internal state of a view to its Subject3. Moreover the Listener
could well update the cache; indeed one could imagine that Listener maintains an invariant similar to IView . InFig. 6 we draw common ownership arrows from the cache to hint that, as in the case of a Collection/Iterators,
the situation seems to be one where multiple objects comprise the public interface for an abstraction and haveshared access to the reps.

Such elaborate patterns have motivated proposals for increasingly complicated ownership type systems andmay well necessitate more complicated versions of the inv

/own and friendship disciplines. We mention one wayin which the friendship discipline, as currently formulated [BN04, NB06], is inadequate. Consider a variation on

Subject3 where its state is not just the integer, val , but rather some data structure; then IView would depend not onsbj

.val, but on locations reached by paths sbj .f .g . . . into that data structure. With ownership, the admissibilitycondition requires that each of sbj , sbj

.f , sbj .f .g etc. is owned. Friendship instead imposes mutual obligations;intricate conditions are apparently needed to extend friendship to handle longer paths, owing to the various

possibilities of sharing.While incremental extensions can be made to address this inadequacy of the friendship discipline, what really
seems to be needed is a general setup for such disciplines. While ownership is widely applicable and provides astrong form of encapsulation at fairly low cost, attempts to extend it to multiple owners or cooperating peers
seem more specialized. For example, friendship caters to the situation where one instance of the granter class isdepended on by multiple instances of a single other class, the friend. What about situations where several objects
of the same class, or of several different classes, are interdependent and collectively provide some abstraction?Packages are not the answer because a package is a collection of classes and does nothing to describe the
conS,gurations in which instances are intended to be deployed. What we seek is a notation in which a designand reasoning pattern can be expressed. A design pattern typically involves a conS,guration of instances (e.g.,
subject and view, collection and iterators) with certain operations and protocol. A pattern-speciS,c discipline forreasoning could be based on a single invariant for the pattern's object conS,guration, expressed with the help of
ghost S,elds to encode the conS,guration13 and its protocol; or perhaps the invariant can be decentralized intointerdependent object invariants.

Pattern-speciS,c rules would need to be given--stipulated annotations for critical operations including updatesof ghost variables to track the structure of interest. VeriS,cation of the pattern would involve establishing designated program invariants as a consequence of the stipulated annotations. The hope is that design patterns can be

13 The Aldrich-Chambers system might help here [AC04].

222 D. A. Naumann
endowed with reasoning disciplines embodied by S,rst order conditions amenable to automated theorem proving,with axioms like (2-4) that facilitate local reasoning. JustiS,cation of such a discipline likely requires interactive
proof and higher order logic since it involves all programs that S,t the pattern.About the friendship discipline, Tony Hoare asked "Would it not be better to deS,ne a general facility for
the user to introduce ghost variables and assertions, rather like aspects in aspect-oriented programming?"14Separation logic offers notation that can transparently depict groups of objects and their interrelation. But in
separation logic, quantiS,cation over predicates is needed for interesting speciS,cations, in part because patterns ofheap structure are expressed using separation at the level of predicates. Why not expressions describing regions?
Pattern matching for such expressions has been given a semantic foundation [Nau01a, Nau01b] but not thor-oughly investigated. Kassios [Kas06a] takes a step in this direction by using ghost S,elds in a general way to hold
sets of objects/locations.A less speculative question to be investigated concerns the requirement, in separation logic, that invariants be
precise predicates, i.e., supported by a deS,nite region of the heap [OYR04]. In simple cases, invariants are precisein virtue of being formulated by reachability in some data structure. Ghost structure may offer a scalable and
precise shadow of encapsulation.

Acknowledgments
This paper is based on one that appeared in the proceedings of FMCO 2005 [Nau05a]. A number of changeshave been made; the major difference is the addition of Sect. 8. This version reT^ects feedback from the FMCO
meeting and anonymous reviewers for the proceedings, from participants in the Verifying Software grand chal-lenge especially at the Z "urich meeting in October 2005, and from anonymous reviewers for Formal Aspects of
Computing. Discussions with Anindya Banerjee, Mike Barnett, Frank de Boer, Ioannis Kassios, Peter M "uller,Peter O'Hearn, and Cees Pierik were particularly helpful.

References
[AC04] Aldrich J, Chambers C (2004) Ownership domains: separating aliasing policy from mechanism. In: European conference onobject-oriented programming (ECOOP), pp 1-25
[AO97] Apt KR, Olderog E-R (1997) VeriS,cation of sequential and concurrent Programs. 2nd ed. Springer, Berlin HeidelbergNew York
[BBTS05] Biering B, Birkedal L, Torp-Smith N (2005) BI hyperdoctrines and higher-order separation logic. In: European symposium onprogramming (ESOP), vol. 3444 of LNCS, pp 233-247
[BCOP05] Bornat R, Calcagno C, O'Hearn PW, Parkinson MJ (2005) Permission accounting in separation logic. In: ACM symposiumon principles of programming languages (POPL), pp 259-270
[BDF+04] Barnett M, DeLine R, F"ahndrich M, Leino KRM, Schulte W (2004) VeriS,cation of object-oriented programs with invariants.J Object Technol 3(6):27-56 Special issue: ECOOP 2003 workshop on formal techniques for Java-like Programs
[BLR02] Boyapati C, Lee R, Rinard M (2002) Ownership types for safe programming: preventing data races and deadlocks. In:Object-oriented programming, systems, languages, and applications (OOPSLA), pp 211-230
[BLS03] Boyapati C, Liskov B, Shrira L (2003) Ownership types for object encapsulation. In: ACM symposium on principles of pro-gramming languages (POPL), pp 213-223
[BLS05] Barnett M, Leino KRM, Schulte W (2005) The Spec# programming system: an overview. In: Barthe G, Burdy L, Huisman M,Lanet JL, Muntean T (eds) Construction and analysis of safe, secure, and interoperable smart devices, international workshop

(CASSIS 2004), revised selected papers, Vol. 3362, of LNCS, pp 49-69[BN02] Banerjee A, Naumann DA (2002) Representation independence, conS,nement and access control. In: ACM symposium on
principles of programming languages (POPL), pp 166-177[BN04] Barnett M, Naumann DA (2004) Friends need a bit more: maintaining invariants over shared state. In: Kozen D, Shankland C,
(eds) Mathematics of program construction, Vol. 3125 of LNCS, pp 54-84[BN05a] Banerjee A, Naumann DA (2005) Ownership conS,nement ensures representation independence for object-oriented programs.
J ACM, 52(6):894-960 Extended version of [BN02].[BN05b] Banerjee A, Naumann DA (2005) State based ownership, reentrance, and encapsulation. In: European conference on objectoriented programming (ECOOP), pp 387-411[BNSS04] Barnett M, Naumann DA, Schulte W, Sun Q 99.44% pure: useful abstractions in speciS,cations. In: ECOOP workshop on
formal techniques for Java-like programs (FTfJP), 2004. Technical Report NIII-R0426, University of Nijmegen[BNSS06] Barnett M, Naumann DA, Schulte W, Sun Q (2006) Allowing state changes in speciS,cations. In: International conference
on emerging trends in information and communication security (ETRICS), Vol. 3995 of LNCS, M"uller G, (ed) pp 321-336.Springer, Berlin Heidelberg New York Extended version of [BNSS04]

14 Personal communication, April 2004.

Assertion-based encapsulation 223
[BP05] Bierman GM, Parkinson MJ (2005) Separation logic and abstraction. In: ACM symposium on principles of programminglanguages (POPL), pp. 247-258
[BSC03] Borba PHM, Sampaio ACA, Corn'elio ML (2003) A reS,nement algebra for object-oriented programming. In: Cardelli L (ed)European conference on object-oriented programming (ECOOP), Vol. 2743 in LNCS, pp 457-482
[BSCC04] Borba PHM, Sampaio A, Cavalcanti A, Corn'elio M (2004) Algebraic reasoning for object-oriented programming. Sci ComputProgram 52(1-3):53-100
[BTS05] Birkedal L, Torp-Smith N (2005) Higher order separation logic and abstraction (submitted)[BTSY05] Birkedal L, Torp-Smith N, Yang H (2005) Semantics of separation-logic typing and higher-order frame rules. In: IEEE symposium on logic in computer science (LICS), pp 260-269[Cla01] Clarke D (2001) Object ownership and containment. Dissertation, Computer Science and Engineering, University of New
South Wales[CN02] Cavalcanti ALC, Naumann DA (2002) Forward simulation for data reS,nement of classes. In: Eriksson L, Lindsay PA (eds)
Formal Methods Europe, Vol. 2391 of LNCS, pp 471-490[CNP01] Clarke DG, Noble J, Potter JM (2001) Simple ownership types for object containment. In: Knudsen JL (ed) ECOOP 2001--
object oriented programming, pp 53-76[COB03] Calcagno C, O'Hearn PW, Bornat R (2003) Program logic and equivalence in the presence of garbage collection. Theoret
Comput Sci 298(3):557-581[dBP02] de Boer FS, Pierik C (2002) Computer-aided speciS,cation and veriS,cation of annotated object-oriented programs. In: Jacobs
B, Rensink A (eds) Formal methods for open object-based distributed systems, pp 163-177[DF01] DeLine R, F"ahndrich M (2001) Enforcing high-level protocols in low-level software. In: ACM Conference on Programing
Languages on Design and implementation (PLDI), pp 59-69[DLN98] Detlefs DL, Leino KRM, Nelson G (1998) Wrestling with rep exposure. Research 156, DEC Systems Research Center
[dRE98] de Roever W-P, Engelhardt K (1998) Data reS,nement: model-oriented proof methods and their comparison. Cambridge Uni-versity Press
[GHJV95] Gamma E, Helm R, Johnson R, Vlissides J (1995) Design patterns: elements of reusable object-oriented software.Addison-Wesley
[Gri93] Gries D (1993) Data reS,nement and the tranform. In: Broy M (ed) Program design calculi. International Summer School atMarktoberdorf. Springer, Berlin Heidelberg New York
[Hoa72] Hoare CAR (1972) Proofs of correctness of data representations. Acta Inf 1:271-281[Hog91] Hogg J (1991) Islands: aliasing protection in object-oriented languages. In: OOPSLA '91 conference proceedings, Vol. 26(11)

of SIGPLAN, ACM[JKW03] Jacobs B, Kiniry J, Warnier M (2003) Java program veriS,cation challenges. In: de Boer F, Bonsangue M, Graf S, de Roever
W-P (eds) Formal methods for components and objects (FMCO 2002), Vol. 2852 of LNCS, pp 202-219[JLS04] Jacobs B, Leino KRM, Schulte W (2004) Multithreaded object-oriented programs with invariants. In: SAVCBS
[Jon96] Jones CB (1996) Accomodating interference in the formal design of concurrent object-based programs. Formal Methods SystDes 8(2):105-122
[Kas06a] Kassios IT (2006) Dynamic framing: Support for framing, dependencies and sharing without restriction: Formal Methods, vol4085 in LNCS, pp 268-283
[Kas06b] Kassios IT (2006) A theory of object oriented reS,nement. PhD dissertation, University of Toronto[LCC+03] Leavens GT, Cheon Y, Clifton C, Ruby C, Cok DR (2003) How the design of JML accommodates both runtime assertion checking and formal veriS,cation. In: de Boer FS, Bonsangue MM Grafs, de Roever WP (eds) Formal Methods for Components andObjects (FMCO 2002), Vol. 2852 of LNCS, pp 262-284. Springer, Berlin Heidelberg New York
[LG86] Liskov B, Guttag J (1986) Abstraction and speciS,cation in program development. MIT Press, Cambridge[LM04] Leino KRM, M"uller P (2004) Object invariants in dynamic contexts. In: European conference on object-oriented programming

(ECOOP), pp 491-516[LM05] Leino KRM, M"uller P (2005) Modular veriS,cation of static class invariants. In: Proceedings, formal methods, Vol. 3582 of
LNCS, pp 26-42[LPHZ02] Leino KRM, Poetzsch-Heffter A, Zhou Y (2002) Using data groups to specify and check side effects. In: ACM Conference on
Programming Language Design and Implementation (PLDI), pp 246-257[LV95] Lynch N, Vaandrager F (1995) Forward and backward simulations part I: untimed systems. Inf Comput 121(2):214-233
[LW94] Liskov BH, Wing JM (1994) A behavioral notion of subtyping. ACM Trans Program Lang Syst 16(6):254-280[Mey97] Meyer B (1997) Object-oriented software construction, 2nd edn. Prentice Hall, New York
[Mil71] Milner R (1971) An algebraic deS,nition of simulation between programs. In: Proceedings of 2nd International Joint Conferenceon ArtiS,cial Intelligence, pp 481-489
[Mit86] Mitchell JC (1986) Representation independence and data abstraction. In: ACM symposium on principles of programminglanguages (POPL), pp 263-276
[MPHL04] M"uller P, Poetzsch-Heffter A, Leavens GT (2004) Modular invariants for layered object structures. Technical Report 424,Department of Computer Science, ETH Zurich
[MTSO04] Mijajlovic I, Torp-Smith N, O'Hearn PW (2004) ReS,nement and separation contexts. In: Foundations of Software Technologyand Theoretical Computer Science (FST&TCS)
[M"ul02] M"uller P (2002) Modular speciS,cation and veriS,cation of object-oriented programs, Vol. 2262 of LNCS. Springer, BerlinHeidelberg New York
[MY05] Mijajlovi'c I, Yang H (2005) Data reS,nement with low-level pointer operations. In: Asian symposium on programming languagesand systems (APLAS), pp 19-36
[Nau01a] Naumann DA (2001) Ideal models for pointwise relational and state-free imperative programming. In: Sondergaard H (ed)ACM international conference on principles and practice of declarative programming, pp 4-15
[Nau01b] Naumann DA (2001) Patterns and lax lambda laws for relational and imperative programming. Technical Report 2001-2,Computer Science, Stevens Institute of Technology

224 D. A. Naumann
[Nau02] Naumann DA (2002) Soundness of data reS,nement for a higher order imperative language. Theoret Comput Sci 278(1-2):271-301
[Nau05a] Naumann DA (2005) Assertion-based encapsulation, object invariants and simulations. In: de Boer FS, Bonsangue MM, GrafS, de Roever WP (eds) Post-proceedings, formal methods for components and objects (FMCO 2004), Vol. 3657 of LNCS, pp

251-273[Nau05b] Naumann DA (2005) Observational purity and encapsulation. In: Fundamental aspects of software engineering (FASE),
pp 190-204. Best Software Science Paper by the European Association of Software Sciences and Technology at the EuropeanJoint Conferences on Theory and Practice of Software (ETAPS)
[Nau06a] Naumann DA (2006) From coupling relations to mated invariants for secure information T^ow. In: European symposium onresearch in computer security (ESORICS), Vol. 4189 in LNCS, pp 279-296
[Nau06b] Naumann DA (2006) Observational purity and encapsulation. Theoret Comput Sci (to appear) Extended version of [Nau05b][NB04] Naumann DA, Barnett M (2004) Towards imperative modules: Reasoning about invariants and sharing of mutable state

(extended abstract). In: IEEE symposium on logic in computer science (LICS), pp 313-323[NB06] Naumann DA, Barnett M (2006) Towards imperative modules: reasoning about invariants and sharing of mutable state. Theoret
Comput Sci 365:143-168, Extended version of [NB04][O'H05] O'Hearn PW (2005) Scalable speciS,cation and reasoning: technical challenges for program logic. In: Meyer B, Woodcock JCP
(eds) VeriS,ed software: theories, tools, and experiments (VSTTE), Post-proceedings, (to appear)[OT95] O'Hearn PW, Tennent RD (1995) Parametricity and local variables. J ACM 42(3):658-709
[OYR04] O'Hearn PW, Yang H, Reynolds JC (2004) Separation and information hiding. In: ACM symposium on principles of program-ming languages (POPL), pp 268-280
[Par05] Parkinson MJ Local reasoning for Java. Technical Report 654. Dissertation,University of Cambridge Computer Laboratory[PCdB05] Pierik C, Clarke D, de Boer FS (2005) Controlling object allocation using creation guards. In: Proceedings, formal methods,

Vol. 3582 of LNCS, pp 59-74[PdB05a] Pierik C, de Boer FS (2005) On behavioral subtyping and completeness. In: J. Vitek, F. Logozzo (eds) ECOOP workshop on
formal techniques for Java-like programs (to appear)[PdB05b] Pierik C, de Boer FS (2005) A proof outline logic for object-oriented programming. Theoret Comput Sci 343:413-442
[Pit97] Pitts AM (1996) Reasoning about local variables with operationally-based logical relations. In: O'Hearn PW, Tennent RD(eds) Algol-like languages, Vol. 2, chap 17, pp 173-193. Birkhauser, 1997. In: Reprinted from proceedings 11th annual IEEE

symposium on logic in computer science, Brunswick, 1996, pp 152-163[Pit00] Pitts AM (2000) Parametric polymorphism and operational equivalence. Math Struct Comput Sci 10:321-359
[Plo73] Plotkin G (1973) Lambda deS,nability and logical relations. Technical Report SAI-RM-4, University of Edinburgh, School ofArtiS,cial Intelligence
[Rey81] Reynolds JC (1981) The craft of programming. Prentice-Hall, Englewood Cliffs[Rey02] Reynolds JC (2002) Separation logic: a logic for shared mutable data structures. In: LICS, pp 55-74
[RM99] Rehof J, Mogensen T (1999) Tractable constraints in S,nite semilattices. Sci Comput Program 35(2-3):191-221[SGM02] Szyperski C, Gruntz D, Murer S (2002) Component software: beyond object-oriented programming, 2nd edn. ACM Press and

Addison-Wesley, New York[SS05] Skalka C, Smith S (2005) Static use-based object conS,nement. Springer Int J Inf Sec 4(1-2)
[YO02] Yang H, O'Hearn PW (2002) A semantic basis for local reasoning. In: Proceedings, FOSSACS
Received 16 August 2006
Revised 15 September 2006
Accepted 31 October 2006 by C. B. Jones
Published online 16 December 2006