

THE ART OF
COMPUTER PROGRAMMING
PRE-FASCICLE 2A

A DRAFT OF SECTION 7.2.1.1:
GENERATING ALL n -TUPLES

DONALD E. KNUTH Stanford University
ADDISON-WESLEY

6
77

An Imprint of Addison Wesley Longman, Inc.

-1

Internet page http://www-cs-faculty.stanford.edu/~knuth/taocp.html contains
current information about this book and related books.

See also http://www-cs-faculty.stanford.edu/~knuth/sgb.html for information
about The Stanford GraphBase, including downloadable software for dealing with the
graphs used in many of the examples in Chapter 7.

Copyright cfl 2001 by Addison Wesley Longman
All rights reserved. No part of this publication may be reproduced, stored in a retrieval
system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher, except
that the official electronic file may be used to print single copies for personal (not
commercial) use.

Zeroth printing (revision 3), 17 September 2001

-2

PREFACE
I am grateful to all my friends,
and record here and now my most especial appreciation

to those friends who, after a decent interval,
stopped asking me, "How's the book coming?"

-- PETER J. GOMES (1996)

This booklet contains draft material that I'm circulating to experts in the
field, in hopes that they can help remove its most egregious errors before too
many other people see it. I am also, however, posting it on the Internet for
courageous and/or random readers who don't mind the risk of reading a few
pages that have not yet reached a very mature state. Beware: This material has
not yet been proofread as thoroughly as the manuscripts of Volumes 1, 2, and 3
were at the time of their first printings. Those volumes, alas, were subsequently
found to contain thousands of mistakes.

Given this caveat, I hope that my errors this time will not be so numerous
and/or obtrusive that you will be discouraged from reading the material carefully.
I did try to make it both interesting and authoritative, as far as it goes. But the
field is so vast, I cannot hope to have surrounded it enough to corral it completely.
Therefore I beg you to let me know about any deficiencies you discover.

To put the material in context, this is Section 7.2.1.1 of a long, long chapter
on combinatorial algorithms. Chapter 7 will eventually fill three volumes (namely
Volumes 4A, 4B, and 4C), assuming that I'm able to remain healthy. It will
begin with a short review of graph theory, with emphasis on some highlights
of significant graphs in The Stanford GraphBase (from which I will be drawing
many examples). Then comes Section 7.1, which deals with the topic of bitwise
manipulations. (I drafted about 60 pages about that subject in 1977, but those
pages need extensive revision; meanwhile I've decided to work for awhile on the
material that follows it, so that I can get a better feel for how much to cut.)
Section 7.2 is about generating all possibilities, and it begins with Section 7.2.1:
Generating Basic Combinatorial Patterns. That sets the stage for the main
contents of this booklet, Section 7.2.1.1, where I get the ball rolling at last by
dealing with the generation of n-tuples. Then will come Section 7.2.1.2 (about
permutations), Section 7.2.1.3 (about combinations), etc. Section 7.2.2 will deal
with backtracking in general. And so it will go on, if all goes well; an outline of
the entire Chapter 7 as currently envisaged appears on the taocp webpage that
is cited on page ii.

iii

-3

iv PREFACE

Even the apparently lowly topic of n-tuple generation turns out to be surprisingly rich, with ties to Sections 1.2.4, 1.3.3, 2.3.1, 2.3.4.2, 3.2.2, 3.5, 4.1,
4.3.1, 4.5.2, 4.5.3, 4.6.1, 4.6.2, 4.6.4, 5.2.1, and 6.3 of the first three volumes.
I strongly believe in building up a firm foundation, so I have discussed this topic
much more thoroughly than I will be able to do with material that is newer or
less basic. To my surprise, I came up with 111 exercises, a new record, even
though -- believe it or not -- I had to eliminate quite a bit of the interesting
material that appears in my files.

Some of the material is new, to the best of my knowledge, although I will not
be at all surprised to learn that my own little "discoveries" have been discovered
before. Please look, for example, at the exercises that I've classed as research
problems (rated with difficulty level 46 or higher), namely exercises 43, 46, 47, 53,
55, 62, 66, and 82. Are these problems still open? The questions in exercises 53
and 82 might not have been posed previously, but they seem to deserve attention.
Please let me know if you know of a solution to any of these intriguing problems.
And of course if no solution is known today but you do make progress on any of
these in the future, I hope you'll let me know.

I urgently need your help also with respect to some exercises that I made
up as I was preparing this material. I certainly don't like to get credit for things
that have already been published by others, and most of these results are quite
natural "fruits" that were just waiting to be "plucked." Therefore please tell
me if you know who I should have credited, with respect to the ideas found in
exercises 15, 16, 30, 31, 37, 38, 69, 73, 76, 85, 86, 88, 89, and/or 108.

I shall happily pay a finder's fee of $2.56 for each error in this draft when it is
first reported to me, whether that error be typographical, technical, or historical.
The same reward holds for items that I forgot to put in the index. And valuable
suggestions for improvements to the text are worth 32/c each. (Furthermore, if
you find a better solution to an exercise, I'll actually reward you with immortal
glory instead of mere money, by publishing your name in the eventual book:\Gamma )

Happy reading!

Stanford, California D. E. K.
August 2001 (revised, September 2001)

-4

7.2.1.1 GENERATING ALL n-TUPLES 1
7.2. GENERATING ALL POSSIBILITIES

All present or accounted for, sir.
-- Traditional American military saying

All present and correct, sir.
-- Traditional British military saying

7.2.1. Generating Basic Combinatorial Patterns
Our goal in this section is to study methods for running through all of the
possibilities in some combinatorial universe, because we often face problems
in which an exhaustive examination of all cases is necessary or desirable. For
example, we might want to look at all permutations of a given set.

Some authors call this the task of enumerating all of the possibilities; but
that's not quite the right word, because "enumeration" most often means that
we merely want to count the total number of cases, not that we actually want
to look at them all. If somebody asks you to enumerate the permutations of
f1; 2; 3g, you are quite justified in replying that the answer is 3! = 6; you needn't
give the more complete answer f123; 132; 213; 231; 312; 321g.

Other authors speak of listing all the possibilities; but that's not such a great
word either. No sensible person would want to make a list of the 10! = 3;628;800
permutations of f0; 1; 2; 3; 4; 5; 6; 7; 8; 9g by printing them out on thousands of
sheets of paper, nor even by writing them all in a computer file. All we really
want is to have them present momentarily in some data structure, so that a
program can examine each permutation one at a time.

So we will speak of generating all of the combinatorial objects that we need,
and visiting each object in turn. Just as we studied algorithms for tree traversal
in Section 2.3.1, where the goal was to visit every node of a tree, we turn now
to algorithms that systematically traverse a combinatorial space of possibilities.

He's got 'em on the list--

he's got 'em on the list;
And they'll none of 'em be missed--

they'll none of 'em be missed.

-- WILLIAM S. GILBERT, The Mikado (1885)

7.2.1.1. Generating all n-tuples. Let's start small, by considering how to
run through all 2n strings that consist of n binary digits. Equivalently, we want
to visit all n-tuples (a1; : : : ; an) where each aj is either 0 or 1. This task is
also, in essence, equivalent to examining all subsets of a given set fx1; : : : ; xng,
because we can say that xj is in the subset if and only if aj = 1.

Of course such a problem has an absurdly simple solution. All we need to
do is start with the binary number (0 : : : 00)2 = 0 and repeatedly add 1 until
we reach (1 : : : 11)2 = 2n\Gamma  1. We will see, however, that even this utterly trivial
problem has astonishing points of interest when we look into it more deeply. And
our study of n-tuples will pay off later when we turn to the generation of more
difficult kinds of patterns.

1

2 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

In the first place, we can see that the binary-notation trick extends to other
kinds of n-tuples. If we want, for example, to generate all (a1; : : : ; an) in which
each aj is one of the decimal digits f0; 1; 2; 3; 4; 5; 6; 7; 8; 9g, we can simply count
from (0 : : : 00)10 = 0 to (9 : : : 99)10 = 10n \Gamma  1 in the decimal number system.
And if we want more generally to run through all cases in which

0 ^ aj ! mj for 1 ^ j ^ n; (1)
where the upper limits mj might be different in different components of the
vector (a1; : : : ; an), the task is essentially the same as repeatedly adding unity
to the number h

a1;

m1;

a2;
m2;

: : : ;
: : : ;

an
mn

i

(2)

in a mixed-radix number system; see Eq. 4.1-(9) and exercise 4.3.1-9.

We might as well pause to describe the process more formally:

Algorithm M (Mixed-radix generation). This algorithm visits all n-tuples
that satisfy (1), by repeatedly adding 1 to the mixed-radix number in (2) until
overflow occurs. Auxiliary variables a0 and m0 are introduced for convenience.

M1. [Initialize.] Set aj  0 for 0 ^ j ^ n, and set m0  2.
M2. [Visit.] Visit the n-tuple (a1; : : : ; an). (The program that wants to examine

all n-tuples now does its thing.)

M3. [Prepare to add one.] Set j  n.
M4. [Carry if necessary.] If aj = mj \Gamma  1, set aj  0, j  j \Gamma  1, and repeat this

step.

M5. [Increase, unless done.] If j = 0, terminate the algorithm. Otherwise set

aj  aj + 1 and go back to step M2.

Algorithm M is simple and straightforward, but we shouldn't forget that
nested loops are even simpler, when n is a fairly small constant. When n = 4,
we could for example write out the following instructions:

For a1 = 0, 1, : : : , m1 \Gamma  1 (in this order) do the following:

For a2 = 0, 1, : : : , m2 \Gamma  1 (in this order) do the following:

For a3 = 0, 1, : : : , m3 \Gamma  1 (in this order) do the following:

For a4 = 0, 1, : : : , m4 \Gamma  1 (in this order) do the following:

Visit (a1; a2; a3; a4):

(3)

These instructions are equivalent to Algorithm M, and they are easily expressed
in any programming language.

Gray binary code. Algorithm M runs through all (a1; : : : ; an) in lexicographic
order, as in a dictionary. But there are many situations in which we prefer to visit
those n-tuples in some other order. The most famous alternative arrangement is
the so-called Gray binary code, which lists all 2n strings of n bits in such a way

2

7.2.1.1 GENERATING ALL n-TUPLES 3

Fig. 10.

000

0

000

\Lambda 

0001

00\Lambda \Lambda 
0010
001\Lambda 
001

10\Lambda 
\Lambda \Lambda 01

00010

\Lambda 

01

01
01

\Lambda \Lambda 

01
10

01
1\Lambda 

01
11

\Lambda \Lambda 
\Lambda \Lambda 

100
0

100
\Lambda 

1001
10\Lambda \Lambda 

1010

101\Lambda 

101
1 1\Lambda 

\Lambda \Lambda  11

00 110

\Lambda 

11
01

11
\Lambda \Lambda 

11

10

11

1\Lambda 

11

11

\Lambda \Lambda 

\Lambda \Lambda 

(a) Lexicographic binary code.

000

0

000

\Lambda 

0001

00\Lambda 1
0011
001\Lambda 
001

00\Lambda 
1001

10011

\Lambda 

01

11
01

\Lambda 1

01
01

01
0\Lambda 

01
00

\Lambda 1
00

110
0

110
\Lambda 

1101
11\Lambda 1

1111

111\Lambda 

111
0 1\Lambda 

10 10

10 101

\Lambda 

10
11

10
\Lambda 1

10

01

10

0\Lambda 

10

00

\Lambda 0

00

(b) Gray binary code.
that only one bit changes each time, in a simple and regular way. For example,
the Gray binary code for n = 4 is

0000; 0001; 0011; 0010; 0110; 0111; 0101; 0100;

1100; 1101; 1111; 1110; 1010; 1011; 1001; 1000: (4)

Such codes are especially important in applications where analog information
is being converted to digital or vice versa. For example, suppose we want to
identify our current position on a rotating disk that has been divided into 16
sectors, using four sensors that each distinguish black from white. If we use
lexicographic order to mark the tracks from 0000 to 1111, as in Fig. 10(a), wildly
inaccurate measurements can occur at the boundaries between sectors; but the
code in Fig. 10(b) never gives a bad reading.

Gray binary code can be defined in many equivalent ways. For example,
if \Gamma n stands for the Gray binary sequence of n-bit strings, we can define \Gamma n
recursively by the two rules

\Gamma 0 = ffl;
\Gamma n+1 = 0\Gamma n; 1\Gamma Rn :

(5)

Here ffl denotes the empty string, 0\Gamma n denotes the sequence \Gamma n with 0 prefixed to
each string, and 1\Gamma Rn denotes the sequence \Gamma n in reverse order with 1 prefixed
to each string. Since the last string of \Gamma n equals the first string of \Gamma Rn , it is clear
from (5) that exactly one bit changes in every step of \Gamma n+1 if \Gamma n enjoys the same
property.

Another way to define the sequence \Gamma n = g(0), g(1), : : : , g(2n\Gamma  1) is to give
an explicit formula for its individual elements g(k). Indeed, since \Gamma n+1 begins
with 0\Gamma n, the infinite sequence

\Gamma 1 = g(0); g(1); g(2); g(3); g(4); : : :

= (0)2; (1)2; (11)2; (10)2; (110)2; : : :

(6)

is a permutation of all the nonnegative integers, if we regard each string of 0s and
1s as a binary integer with leading 0s suppressed. Then \Gamma n consists of the first
2n elements of (6), converted to n-bit strings by means of leading 0s if needed.

3

4 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

When k = 2n + r, where 0 ^ r ! 2n, relation (5) tells us that g(k) is equal
to 2n + g(2n\Gamma  1 \Gamma  r). Therefore we can prove by induction on n that the integer
k whose binary representation is (: : : b2b1b0)2 has a Gray binary equivalent g(k)
with the representation (: : : a2a1a0)2, where

aj = bj \Phi  bj+1; for j * 0. (7)
(See exercise 6.) For example, g

\Gamma 

(111001000011)2

\Delta 

= (100101100010)2. Conversely, if g(k) = (: : : a2a1a0)2 is given, we can find k = (: : : b2b1b0)2 by inverting
the system of equations (7), obtaining

bj = aj \Phi  aj+1 \Phi  aj+2 \Phi  \Delta  \Delta  \Delta  ; for j * 0; (8)
this infinite sum is really finite because aj+t = 0 for all large t.

One of the many pleasant consequences of Eq. (7) is that g(k) can be computed very easily with bitwise arithmetic:

g(k) = k \Phi  bk=2c: (9)
Similarly, the inverse function in (8) satisfies

g[\Gamma 1](l) = l \Phi  bl=2c \Phi  bl=4c \Phi  \Delta  \Delta  \Delta  ; (10)
this function, however, requires more computation (see exercise 7.1-00). We can
also deduce from (7) that, if k and k0 are any nonnegative integers,

g(k \Phi  k0) = g(k) \Phi  g(k0): (11)
Yet another consequence is that the (n + 1)-bit Gray binary code can be written

\Gamma n+1 = 0\Gamma n; 1(\Gamma n\Phi 10 : : : 0);
this pattern is evident, for example, in (4). Comparing with (5), we see that
reversing the order of Gray binary code is equivalent to complementing the first
bit:

\Gamma Rn = \Gamma n \Phi  10 : : : 0: (12)

The exercises below show that the function g(k) defined in (7), and its inverse
g[\Gamma 1] defined in (8), have many further properties and applications of interest.
Sometimes we think of these as functions taking binary strings to binary strings;
at other times we regard them as functions from integers to integers, via binary
notation, with leading zeros irrelevant.

Gray binary code is named after Frank Gray, a physicist who became famous for helping to devise the method long used for compatible color television
broadcasting [Bell System Tech. J. 13 (1934), 464-515]. He invented \Gamma n for
applications to pulse code modulation, a method for analog transmission of digital signals [see Bell System Tech. J. 30 (1951), 38-40; U.S. Patent 2632058 (17
March 1953); W. R. Bennett, Introduction to Signal Transmission (1971), 238-
240]. But the idea of "Gray binary code" was known long before he worked on it;
for example, it appeared in U.S. Patent 2307868 by George Stibitz (12 January
1943). More significantly, \Gamma 5 was used in a telegraph machine demonstrated
in 1878 by 'Emile Baudot, after whom the term "baud" was later named. At

4

7.2.1.1 GENERATING ALL n-TUPLES 5
about the same time, a similar but less systematic code for telegraphy was
independently devised by Otto Sch"affler [see Journal T'el'egraphique 4 (1878),
252-253; Annales T'el'egraphiques 6 (1879), 361, 382-383].*

In fact, Gray binary code is implicitly present in a classic toy that has
fascinated people for centuries, now generally known as the "Chinese ring puzzle"
in English, although Englishmen used to call it the "tiring irons." Fig. 11 shows
a seven-ring example. The challenge is to remove the rings from the bar, and
the rings are interlocked in such a way that only two basic types of move are
possible (although this may not be immediately apparent from the illustration):

a) The rightmost ring can be removed or replaced at any time;
b) Any other ring can be removed or replaced if and only if the ring to its right

is on the bar and all rings to the right of that one are off.

We can represent the current state of the puzzle in binary notation, writing 1
if a ring is on the bar and 0 if it is off; thus Fig. 11 shows the rings in state
1011000. (The second ring from the left is encoded as 0, because it lies entirely
above the bar.)

Fig. 11.
The Chinese ring puzzle.

A French magistrate named Louis Gros demonstrated an explicit connection
between Chinese rings and binary numbers, in a booklet called Th'eorie du
Baguenodier [sic] (Lyon: Aim'e Vingtrinier, 1872) that was published anonymously. If the rings are in state an\Gamma 1 : : : a0, and if we define the binary number
k = (bn\Gamma 1 : : : b0)2 by Eq. (8), he showed that exactly k more steps are necessary
and sufficient to solve the puzzle. Thus Gros is the true inventor of Gray binary
code.

Certainly no home should be without
this fascinating, historic, and instructive puzzle.

-- HENRY E. DUDENEY (1901)

When the rings are in any state other than 00 : : : 0 or 10 : : : 0, exactly two
moves are possible, one of type (a) and one of type (b). Only one of these moves
advances toward the desired goal; the other is a step backward that will need to
be undone. A type (a) move changes k to k \Phi  1; thus we want to do it when k
is odd, since this will decrease k. A type (b) move from a position that ends in
(10j\Gamma 1)2 for 1 ^ j ! n changes k to k \Phi  (1j+1)2 = k \Phi  (2j+1 \Gamma  1). When k is

* Some authors have asserted that Gray code was invented by Elisha Gray, who developed a
printing telegraph machine at the same time as Baudot and Sch"affler. Such claims are untrue,
although Elisha did get a raw deal with respect to priority for inventing the telephone [see
L. W. Taylor, Amer. Physics Teacher 5 (1937), 243-251].

5

6 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
even, we want to decrease k by 1, which means that k must be a multiple of 2j
but not a multiple of 2j+1; in other words,

j = ae(k); (13)
where ae is the "ruler function" of Eq. 7.1-(00). Therefore the rings follow a nice
pattern when the puzzle is solved properly: If we number them 0, 1, : : : , n \Gamma  1
(starting at the free end), the sequence of ring moves on or off the bar is the
sequence of numbers that ends with : : : , ae(4), ae(3), ae(2), ae(1).

Going backwards, successively putting rings on or off until we reach the
ultimate state 10 : : : 0 (which, as John Wallis observed in 1693, is more difficult to
reach than the supposedly harder state 11 : : : 1), yields an algorithm for counting
in Gray binary code:

Algorithm G (Gray binary generation). This algorithm visits all binary ntuples (an\Gamma 1; : : : ; a1; a0) by starting with (0; : : : ; 0; 0) and changing only one bit
at a time, also maintaining a parity bit a1 such that

a1 = an\Gamma 1 \Phi  \Delta  \Delta  \Delta  \Phi  a1 \Phi  a0: (14)
It successively complements bits ae(1), ae(2), ae(3), : : : , ae(2n \Gamma  1) and then stops.
G1. [Initialize.] Set aj  0 for 0 ^ j ! n; also set a1  0.
G2. [Visit.] Visit the n-tuple (an\Gamma 1; : : : ; a1; a0).
G3. [Change parity.] Set a1  1 \Gamma  a1.
G4. [Choose j.] If a1 = 1, set j  0. Otherwise let j * 1 be minimum such

that aj\Gamma 1 = 1. (After the kth time we have performed this step, j = ae(k).)

G5. [Complement coordinate j.] Terminate if j = n; otherwise set aj  1 \Gamma  aj

and return to G2.

The parity bit a1 comes in handy if we are computing a sum like

X000 \Gamma  X100 \Gamma  X010 + X110 \Gamma  X001 + X101 + X011 \Gamma  X111
or

X; \Gamma  Xa \Gamma  Xb + Xab \Gamma  Xc + Xac + Xbc \Gamma  Xabc;

where the sign depends on the parity of a binary string or the number of elements
in a subset. Such sums arise frequently in "inclusion-exclusion" formulas such
as Eq. 1.3.3-(29). The parity bit is also necessary, for efficiency: Without it we
could not easily choose between the two ways of determining j, which correspond
to performing a type (a) or type (b) move in the Chinese ring puzzle. But the
most important feature of Algorithm G is that step G5 makes only a single
coordinate change, so that only a simple change is usually needed to the terms
X that we are summing or to whatever other structures we are concerned with
as we visit each n-tuple.

It is impossible, of course, to remove all ambiguity in the lowest-order digit

except by a scheme like one the Irish railways are said to have used

of removing the last car of every train
because it is too susceptible to collision damage.

-- G. R. STIBITZ and J. A. LARRIVEE, Mathematics and Computers (1957)

6

7.2.1.1 GENERATING ALL n-TUPLES 7

Fig. 12. Walsh functions wk(x) for
0 ^ k ! 8, with the analogous trigonometric functions

p

2 cos kssx shown

in gray for comparison.

w (x)0
w (x)1
w (x)2
w (x)3
w (x)4
w (x)5
w (x)6
w (x)7

x = 0 x = 14 x = 12 x = 34 x = 1

Another key property of Gray binary code was discovered by J. L. Walsh
in connection with an important sequence of functions now known as Walsh
functions [see Amer. J. Math. 45 (1923), 5-24]. Let w0(x) = 1 for all real
numbers x, and

wk(x) = (\Gamma 1)b2xcdk=2e wbk=2c(2x); for k ? 0. (15)
For example, w1(x) = (\Gamma 1)b2xc changes sign whenever x is an integer or an
integer plus 12 . It follows that wk(x) = wk(x + 1) for all k, and that wk(x) = \Sigma 1
for all x. More significantly, wk(0) = 1 and wk(x) has exactly k sign changes in
the interval (0 : : 1), so that it approaches (\Gamma 1)k as x approaches 1 from the left.
Therefore wk(x) behaves rather like a trigonometric function cos kssx or sin kssx,
and we can represent other functions as a linear combination of Walsh functions
in much the same way as they are traditionally represented as Fourier series. This
fact, together with the simple discrete nature of wk(x), makes Walsh functions
extremely useful in computer calculations related to information transmission,
image processing, and many other applications.

Fig. 12 shows the first eight Walsh functions together with their trigonometric cousins. Engineers commonly call wk(x) the Walsh function of sequency k,
by analogy with the fact that cos kssx and sin kssx have frequency k=2. [See, for
example, the book Sequency Theory: Foundations and Applications (New York:
Academic Press, 1977), by H. F. Harmuth.]

7

8 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

Although Eq. (15) may look formidable at first glance, it actually provides an
easy way to see by induction why wk(x) has exactly k sign changes as claimed. If
k is even, say k = 2l, we have w2l(x) = wl(2x) for 0 ^ x ! 12 ; the effect is simply
to compress the function wl(x) into half the space, so w2l(x) has accumulated
l sign changes so far. Then w2l(x) = (\Gamma 1)lwl(2x) = (\Gamma 1)lwl(2x \Gamma  1) in the
range 12 ^ x ! 1; this concatenates another copy of wl(2x), flipping the sign if
necessary to avoid a sign change at x = 12 . The function w2l+1(x) is similar, but
it forces a sign change when x = 12 .

What does this have to do with Gray binary code? Walsh discovered that
his functions could all be expressed neatly in terms of simpler functions called
Rademacher functions [Hans Rademacher, Math. Annalen 87 (1922), 112-138],

rk(x) = (\Gamma 1)b2

kxc

; (16)

which take the value (\Gamma 1)c\Gamma k when (: : : c2c1c0:c\Gamma 1c\Gamma 2 : : : )2 is the binary representation of x. Indeed, we have w1(x) = r1(x), w2(x) = r1(x)r2(x), w3(x) = r2(x),
and in general

wk(x) =

Y

j*0

rj+1(x)bj\Phi bj+1 when k = (bn\Gamma 1 : : : b1b0)2. (17)

(See exercise 33.) Thus the exponent of rj+1(x) in wk(x) is the jth bit of the
Gray binary number g(k), according to (7), and we have

wk(x) = rae(k)+1(x) wk\Gamma 1(x); for k ? 0. (18)
Equation (17) implies the handy formula

wk(x)wk0(x) = wk\Phi k0(x); (19)
which is much simpler than the corresponding product formulas for sines and
cosines. This identity follows easily because rj(x)2 = 1 for all j and x, hence
rj(x)a\Phi b = rj(x)a+b. It implies in particular that wk(x) is orthogonal to wk0(x)
when k 6= k0, in the sense that the average value of wk(x)wk0(x) is zero. We also
can use (17) to define wk(x) for fractional values of k like 1=2 or 13=8.

The Walsh transform of 2n numbers (X0; : : : ; X2n\Gamma 1) is the vector defined by
the equation (x0; : : : ; x2n\Gamma 1)T = Wn(X0; : : : ; X2n\Gamma 1)T , where Wn is the 2n \Theta  2n
matrix having wj(k=2n) in row j and column k, for 0 ^ j; k ! 2n. For example,
Fig. 12 tells us that the Walsh transform when n = 3 is

0

B
B
B
B
B
B
B
B
B
@

x000
x001
x010
x011
x100
x101
x110
x111

1
C
C
C
C
C
C
C
C
C
A

=

0
B
B
B
B
B
B
B
B
B
@

1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1

1
C
C
C
C
C
C
C
C
C
A

0
B
B
B
B
B
B
B
B
B
@

X000
X001
X010
X011
X100
X101
X110
X111

1
C
C
C
C
C
C
C
C
C
A

: (20)

8

7.2.1.1 GENERATING ALL n-TUPLES 9
(Here 1 stands for \Gamma 1, and the subscripts are conveniently regarded as binary
strings 000-111 instead of as the integers 0-7.) The Hadamard transform is
defined similarly, but with the matrix Hn in place of Wn, where Hn has (\Gamma 1)j\Delta k
in row j and column k; here `j \Delta  k' denotes the dot product an\Gamma 1bn\Gamma 1 + \Delta  \Delta  \Delta  + a0b0
of the binary representations j = (an\Gamma 1 : : : a0)2 and k = (bn\Gamma 1 : : : b0)2. For
example, the Hadamard transform for n = 3 is

0

B
B
B
B
B
B
B
B
B
@

x0000
x0001
x0010
x0011
x0100
x0101
x0110
x0111

1
C
C
C
C
C
C
C
C
C
A

=

0
B
B
B
B
B
B
B
B
B
@

1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1

1
C
C
C
C
C
C
C
C
C
A

0
B
B
B
B
B
B
B
B
B
@

X000
X001
X010
X011
X100
X101
X110
X111

1
C
C
C
C
C
C
C
C
C
A

: (21)

This is the same as the discrete Fourier transform on an n-dimensional cube,
Eq. 4.6.4-(38), and we can evaluate it quickly "in place" by adapting the method
of Yates discussed in Section 4.6.4:

Given First step Second step Third step
X000 X000+X001 X000+X001+X010+X011 X000+X001+X010+X011+X100+X101+X110+X111
X001 X000\Gamma X001 X000\Gamma X001+X010\Gamma X011 X000\Gamma X001+X010\Gamma X011+X100\Gamma X101+X110\Gamma X111
X010 X010+X011 X000+X001\Gamma X010\Gamma X011 X000+X001\Gamma X010\Gamma X011+X100+X101\Gamma X110\Gamma X111
X011 X010\Gamma X011 X000\Gamma X001\Gamma X010+X011 X000\Gamma X001\Gamma X010+X011+X100\Gamma X101\Gamma X110+X111
X100 X100+X101 X100+X101+X110+X111 X000+X001+X010+X011\Gamma X100\Gamma X101\Gamma X110\Gamma X111
X101 X100\Gamma X101 X100\Gamma X101+X110\Gamma X111 X000\Gamma X001+X010\Gamma X011\Gamma X100+X101\Gamma X110+X111
X110 X110+X111 X100+X101\Gamma X110\Gamma X111 X000+X001\Gamma X010\Gamma X011\Gamma X100\Gamma X101+X110+X111
X111 X110\Gamma X111 X100\Gamma X101\Gamma X110+X111 X000\Gamma X001\Gamma X010+X011\Gamma X100+X101+X110\Gamma X111

Notice that the rows of H3 are a permutation of the rows of W3. This is true in
general, so we can obtain the Walsh transform by permuting the elements of the
Hadamard transform. Exercise 36 discusses the details.

Going faster. When we're running through 2n possibilities, we usually want
to reduce the computation time as much as possible. Algorithm G needs to
complement only one bit aj per visit to (an\Gamma 1; : : : ; a0), but it loops in step G4
while choosing an appropriate value of j. Another approach has been suggested
by Gideon Ehrlich [JACM 20 (1973), 500-513], who introduced the notion of
loopless combinatorial generation: With a loopless algorithm, the number of
operations performed between successive visits is required to be bounded in
advance, so there never is a long wait before a new pattern has been generated.

We learned some tricks in Section 7.1 about quick ways to determine the
number of leading or trailing 0s in a binary number. Those methods could be
used in step G4 to make Algorithm G loopless, assuming that n isn't unreasonably large. But Ehrlich's method is quite different, and much more versatile,
so it provides us with a new weapon in our arsenal of techniques for efficient
computation. Here is how his approach can be used to generate binary n-tuples.

9

10 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
Algorithm L (Loopless Gray binary generation). This algorithm, like Algorithm G, visits all binary n-tuples (an\Gamma 1; : : : ; a0) by starting with (0; : : : ; 0) and
changing only one bit at a time. But instead of maintaining a parity bit, it uses
an array of "focus pointers" (fn; : : : ; f0), whose significance is discussed below.

L1. [Initialize.] Set aj  0 and fj  j for 0 ^ j ! n; also set fn  n. (A

loopless algorithm is allowed to have loops in its initialization step, as long
as the initial setup is reasonably efficient; after all, every program needs to
be loaded and launched.)

L2. [Visit.] Visit the n-tuple (an\Gamma 1; : : : ; a1; a0).
L3. [Choose j.] Set j  f0, f0  0, fj  fj+1, and fj+1  j + 1. (If this is the

kth time we are performing this step, j now equals ae(k).)

L4. [Complement coordinate j.] Terminate if j = n; otherwise set aj  1 \Gamma  aj

and return to L2.

For example, the computation proceeds as follows when n = 4. Elements aj have
been underlined in this table if the corresponding bit bj is 1 in the binary string
b3b2b1b0 such that a3a2a1a0 = g(b3b2b1b0):

a3 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
a2 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0
a1 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0
a0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0

f3 3 3 3 3 3 3 3 3 4 4 4 4 3 3 3 3
f2 2 2 2 2 3 3 2 2 2 2 2 2 4 4 2 2
f1 1 1 2 1 1 1 3 1 1 1 2 1 1 1 4 1
f0 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0 4

Although the binary number k = (bn\Gamma 1 : : : b0)2 never appears explicitly in Algorithm L, the focus pointers fj represent it implicitly in a clever way, so that
we can repeatedly form g(k) = (an\Gamma 1 : : : a0)2 by complementing bit aae(k) as we
should. Let's say that aj is passive when it is underlined, active otherwise. Then
the focus pointers satisfy the following invariant relations:

1) If aj is passive and aj\Gamma 1 is active, then fj is the smallest index j0 ? j such

that aj0 is active. (Bits a\Gamma 1 and an are considered to be active for purposes
of this rule, although they aren't really present in the algorithm.)
2) Otherwise fj = j.

Thus, the rightmost element aj of a block of passive elements ai\Gamma 1 : : : aj+1aj has
a focus fj that points to the element ai just to the left of that block. All other
elements aj have fj pointing to themselves.

In these terms, the first two operations `j  f0, f0  0' in step L3 are
equivalent to saying, "Set j to the index of the rightmost active element, and
activate all elements to the right of aj." Notice that if f0 = 0, the operation
f0  0 is redundant; but it doesn't do any harm. The other two operations of L3,
`fj  fj+1, fj+1  j + 1', are equivalent to saying, "Make aj passive," because
we know that aj and aj\Gamma 1 are both active at this point in the computation.

10

7.2.1.1 GENERATING ALL n-TUPLES 11
(Again the operation fj+1  j + 1 might be harmlessly redundant.) The net
effect of activation and passivation is therefore equivalent to counting in binary
notation, as in Algorithm M, with 1-bits passive and 0-bits active.

Algorithm L is almost blindingly fast, because it does only five assignment
operations and one test for termination between each visit to a generated n-tuple.
But we can do even better. In order to see how, let's consider an application
to recreational linguistics: Rudolph Castown, in Word Ways 1 (1968), 165-
169, noted that all 16 of the ways to intermix the letters of sins with the
corresponding letters of fate produce words that are found in a sufficiently large
dictionary of English: sine, sits, site, etc.; and all but three of these words
(namely fane, fite, and sats) are sufficiently common as to be unquestionably
part of standard English. Therefore it is natural to ask the analogous question
for five-letter words: What two strings of five letters will produce the maximum
number of words in the Stanford GraphBase, when letters in corresponding
positions are swapped in all 32 possible ways?

To answer this question, we need not examine all

\Gamma 26

2

\Delta 5

= 3;625;908;203;125

essentially different pairs of strings; it suffices to look at all

\Gamma 5757

2

\Delta 

= 16;568;646

pairs of words in the GraphBase, provided that at least one of those pairs
produces at least 17 words, because every set of 17 or more five-letter words
obtainable from two five-letter strings must contain two that are "antipodal"
(with no corresponding letters in common). For every such pair, we want to
determine as rapidly as possible whether the 32 possible subset-swaps produce
a significant number of English words.

Every 5-letter word can be represented as a 25-bit number using 5 bits per
letter, from "a" = 00000 to "z" = 11001. A table of 225 bits or bytes will then
determine quickly whether a given five-letter string is a word. So the problem
is reduced to generating the 32 bit patterns of the potential words obtainable
by mixing the letters of two given words, and looking those patterns up in the
table. We can proceed as follows, for each pair of 25-bit words w and w0:

W1. [Check the difference.] Set z  w \Phi  w0. Reject the word pair (w; w0) if\Gamma 

(z \Gamma m)\Phi z \Phi m

\Delta 

^m0 6= 0, where m = 220 +215 +210 +25 +1 and m0 = 25m;

this test eliminates cases where w and w0 have a common letter in some
position. (See 7.1-(00); it turns out that 10,614,085 of the 16,568,646 word
pairs have no such common letters.)

W2. [Form individual masks.] Set m0  z ^ (25 \Gamma  1), m1  z ^ (210 \Gamma  25),

m2  z ^ (215 \Gamma  210), m3  z ^ (220 \Gamma  215), and m4  z ^ (225 \Gamma  220), in
preparation for the next step.

W3. [Count words.] Set l  1 and A0  w; variable l will count the number of

words we have found so far, starting with w. Then perform the operations
swap(4) defined below.

W4. [Print a record-setting solution.] If l exceeds or equals the current maximum, print Aj for 0 ^ j ! l.

The heart of this high-speed method is the sequence of operations swap(4), which
should be expanded inline (for example with a macro-processor) to eliminate all

11

12 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
unnecessary overhead. It is defined in terms of the basic operation

sw (j): Set w  w \Phi  mj. Then if w is a word, set Al  w and l  l + 1.
Given sw (j), which flips the letters in position j, we define

swap(0) = sw (0);
swap(1) = swap(0); sw (1); swap(0);
swap(2) = swap(1); sw (2); swap(1);
swap(3) = swap(2); sw (3); swap(2);
swap(4) = swap(3); sw (4); swap(3):

(22)

Thus swap(4) expands into a sequence of 31 steps sw (0), sw (1), sw(0), sw (2),
: : : , sw (0) = sw (ae(1)), sw (ae(2)), : : : , sw (ae(31)); these steps will be used 10
million times. We clearly gain speed by embedding the ruler function values
ae(k) directly into our program, instead of recomputing them repeatedly for each
word pair via Algorithm M, G, or L.

The winning pair of words generates a set of 21, namely

ducks ducky duces dunes dunks dinks dinky
dines dices dicey dicky dicks picks picky
pines piney pinky pinks punks punky pucks

(23)

If, for example, w = ducks and w0 = piney, then m0 = s \Phi  y, so the first
operation sw (0) changes ducks to ducky, which is seen to be a word. The next
operation sw(1) applies m1, which is k \Phi  e in the next-to-last letter position, so
it produces the nonword ducey. Another application of sw (0) changes ducey to
duces (a legal term generally followed by the word tecum). And so on. All word
pairs can be processed by this method in at most a few seconds.

Further streamlining is also possible. For example, once we have found
a pair that yields k words, we can reject later pairs as soon as they generate
33 \Gamma  k nonwords. But the method we've discussed is already quite fast, and it
demonstrates the fact that even the loopless Algorithm L can be beaten.

Fans of Algorithm L may, of course, complain that we have speeded up
the process only in the small special case n = 5, while Algorithm L solves the
generation problem for n in general. A similar idea does, however, work also
for general values of n ? 5: We can expand out a program so that it rapidly
generates all 32 settings of the rightmost bits a4a3a2a1a0, as above; then we can
apply Algorithm L after every 32 steps, using it to generate successive changes
to the other bits an\Gamma 1 : : : a5. This approach reduces the amount of work done
by Algorithm L by nearly a factor of 32.

Other binary Gray codes. The Gray binary code g(0), g(1), : : : , g(2n\Gamma  1) is
only one of many ways to traverse all possible n-bit strings while changing only
a single bit at each step. Let us say that, in general, a "Gray code" on binary
n-tuples is any cycle (v0; v1; : : : ; v2n\Gamma 1) that includes every n-tuple and has the
property that vk differs from v(k+1) mod 2n in just one bit position. Thus, in the

12

7.2.1.1 GENERATING ALL n-TUPLES 13

Fig. 13.

000

0

000

\Lambda 

0001

00\Lambda 1
0011
001\Lambda 
001

00\Lambda 
1001

1001\Lambda 

0

01

00
01
0\Lambda 

01
01

01
\Lambda 1

01
11

\Lambda 1
11

111
1

111
\Lambda 

1110
11\Lambda 0

1100

110\Lambda 

110
1 1\Lambda 

01 10

01 10\Lambda 

1

10
11

10
1\Lambda 

10

10

10

\Lambda 0

10

00

\Lambda 0

00

(a) Complementary Gray code.

000

0

000

\Lambda 

0001

00\Lambda 1
0011
001\Lambda 
001

00\Lambda 
1001

10011

\Lambda 

01

11
\Lambda 1
11

11
11

1\Lambda 
11

10
11

10
\Lambda 1

100
1

1\Lambda 01
1101
\Lambda 101

0101

010\Lambda 

010
0 \Lambda 1

00 11

00 11\Lambda 

0

11
10

1\Lambda 
10

10

10

10

\Lambda 0

10

00

\Lambda 0

00

(b) Balanced Gray code.
terminology of graph theory, a Gray code is an oriented Hamiltonian circuit on
the n-cube. We can assume that subscripts have been chosen so that v0 = 0 : : : 0.

If we think of the v's as binary numbers, there are integers ffi0 : : : ffi2n\Gamma 1 such
that

v(k+1) mod 2n = vk \Phi  2ffik ; for 0 ^ k ! 2n; (24)

this so-called "delta sequence" is another way to describe a Gray code. For
example, the delta sequence for standard Gray binary when n = 3 is 01020102;
it is essentially the ruler function ffik = ae(k + 1) of (13), but the final value ffi2n\Gamma 1
is n \Gamma  1 instead of n, so that the cycle closes. The individual elements ffik always
lie in the range 0 ^ ffik ! n, and they are called "coordinates."

Let d(n) be the number of different delta sequences that define an n-bit
Gray code, and let c(n) be the number of "canonical" delta sequences in which
each coordinate k appears before the first appearance of k + 1. Then d(n) =
n! c(n), because every permutation of the coordinate numbers in a delta sequence
obviously produces another delta sequence. The only possible canonical delta
sequences for n ^ 3 are easily seen to be

00; 0101; 01020102 and 01210121: (25)
Therefore c(1) = c(2) = 1, c(3) = 2; d(1) = 1, d(2) = 2, and d(3) = 12. A
straightforward computer calculation, using techniques for the enumeration of
Hamiltonian circuits that we will study later, establishes the next values,

c(4) = 112;
c(5) = 15;109;096;

d(4) = 2688;
d(5) = 1;813;091;520:

(26)

No simple pattern is evident, and the numbers grow quite rapidly (see exercise 45); therefore it's a fairly safe bet that nobody will ever know the exact
values of c(8) and d(8).

Since the number of possibilities is so huge, people have often attempted to
find Gray codes that have additional useful properties. For example, Fig. 13(a)
shows a 4-bit Gray code in which every string a3a2a1a0 is diametrically opposite
to its complement a3a2a1a0. Such codes are possible whenever the number of
bits is even (see exercise 49).

13

14 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

An even more interesting Gray code, found by G. C. Tootill [Proc. IEE 103,
Part B Supplement (1956), 435] is shown in Fig. 13(b). This one has the same
number of changes in each of the four coordinate tracks, hence all coordinates
share equally in the activities. Gray codes that are balanced in a similar way can
in fact be constructed for all larger values of n, by using the following versatile
method to extend a code from n bits to n + 2 bits:

Theorem D. Let ff1 j1 ff2 j2 : : : ffl jl be a delta sequence for an n-bit Gray code,
where each jk is a single coordinate, each ffk is a possibly empty sequence of
coordinates, and l is odd. Then

ff1(n+1)ffR1 nff1

j1ff2nffR2 (n+1)ff2 j2ff3(n+1)ffR3 nff3 : : : jl\Gamma 1ffl(n+1)ffRl nffl

(n+1)ffRl jl\Gamma 1 ffRl\Gamma 1 : : : ffR2 j1ffR1 n

(27)

is the delta sequence of an (n + 2)-bit Gray code.
For example, if we start with the sequence 0 1 02 0 1 02 for n = 3 and let the three
underlined elements be j1, j2, j3, the new sequence (27) for a 5-bit code is

01410301020131024201043401020103: (28)
Proof. Let ffk have length mk and let vkt be the vertex reached if we start at
0 : : : 0 and apply the coordinate changes ff1 j1 : : : ffj\Gamma 1jk\Gamma 1 and the first t of ffk.
We need to prove that all vertices 00vkt, 01vkt, 10vkt, and 11vkt occur when (27)
is used, for 1 ^ k ^ l and 0 ^ t ^ mk. (The leftmost coordinate is n+1.)

Starting with 000 : : : 0 = 00v10, we proceed to obtain the vertices

00v11; : : : ; 00v1m1; 10v1m1; : : : ; 10v10; 11v10; : : : ; 11v1m1;
then j1 yields 11v20, which is followed by

11v21; : : : ; 11v2m2; 10v2m2; : : : ; 10v20; 00v20; : : : ; 00v2m2;
then comes 00v30, etc., and we eventually reach 11vlml. The glorious finale then
uses the third line of (27) to generate all the missing vertices 01vlml, : : : , 01v10
and take us back to 000 : : : 0.

The transition counts (c0; : : : ; cn\Gamma 1) of a delta sequence are defined by letting
cj be the number of times ffik = j. For example, (28) has transition counts
(12; 8; 4; 4; 4), and it arose from a sequence with transition counts (4; 2; 2). If we
choose the original delta sequence carefully and underline appropriate elements
jk, we can obtain transition counts that are as equal as possible:

Corollary B. For all n * 4, there is an n-bit Gray code with transition counts
(c0; c1; : : : ; cn\Gamma 1) that satisfy the condition

jcj \Gamma  ck j ^ 2 for 0 ^ j ! k ! n. (29)
(This is the best possible balance condition, because each cj must be an even
number, and we must have c0 + c1 + \Delta  \Delta  \Delta  + cn\Gamma 1 = 2n. Indeed, condition (29)

14

7.2.1.1 GENERATING ALL n-TUPLES 15
holds if and only if n \Gamma  r of the counts are equal to 2q and r are equal to 2q + 2,
where q = b2n\Gamma 1=nc and r = 2n\Gamma 1 mod n.)

Proof. Given a delta sequence for an n-bit Gray code with transition counts
(c0; : : : ; cn\Gamma 1), the counts for code (27) are obtained by starting with the values
(c00; : : : ; c0n\Gamma 1; c0n; c0n+1) = (4c0; : : : ; 4cn\Gamma 1; l+1; l+1), then subtracting 2 from c0jk
for 1 ^ k ! l and subtracting 4 from c0jl. For example, when n = 3 we can obtain
a balanced 5-bit Gray code having transition counts (8 \Gamma  2; 16 \Gamma  10; 8; 6; 6) =
(6; 6; 8; 6; 6) if we apply Theorem D to the delta sequence 01210121. Exercise 51
works out the details for other values of n.

Another important class of n-bit Gray codes in which each of the coordinate
tracks has equal responsibility arises when we consider run lengths, namely the
distances between consecutive appearances of the same ffi value. Standard Gray
binary code has run length 2 in the least significant position, and this can lead to
a loss of accuracy when precise measurements need to be made [see, for example,
the discussion by G. M. Lawrence and W. E. McClintock, Proc. SPIE 2831
(1996), 104-111]. But all runs have length 4 or more in the remarkable 5-bit
Gray code whose delta sequence is

(0123042103210423)2: (30)
Let r(n) be the maximum value r such that an n-bit Gray code can be
found in which all runs have length * r. Clearly r(1) = 1, and r(2) = r(3) =
r(4) = 2; and it is easy to see that r(n) must be less than n when n ? 2, hence
(30) proves that r(5) = 4. Exhaustive computer searches establish the values
r(6) = 4 and r(7) = 5. Indeed, a fairly straightforward backtrack calculation
for the case n = 7 needs a tree of only about 60 million nodes to determine
that r(7) ! 6, and exercise 61(a) constructs a 7-bit code with no run shorter
than 5. The exact values of r(n) are unknown for n * 8; but r(10) is almost
certainly 8, and interesting constructions are known by which we can prove that
r(n) = n \Gamma  O(log n) as n ! 1. (See exercises 60-64.)

*Binary Gray paths. We have defined an n-bit Gray code as a periodic sequence

v0, v1, : : : , in which vk is adjacent to vk+1 in the n-cube for all k * 0, each binary
n-tuple occurs in (v0; v1; : : : ; v2n\Gamma 1), and vk+2n = vk. The periodic property
is nice, but not always essential; and sometimes we can do better without it.
Therefore we say that an n-bit Gray path is any ordering v0, v1, : : : , v2n\Gamma 1 of the
2n possible n-tuples in such a way that vk is adjacent to vk+1 for 0 ^ k ! 2n \Gamma  1.
In other words, a Gray code is a Hamiltonian circuit on the vertices of the
n-cube, but a Gray path is simply a Hamiltonian path on that graph.

The most important binary Gray paths that are not also Gray codes are
n-bit paths v0, v1, : : : , v2n\Gamma 1 that are monotonic, in the sense that

*(vk) ^ *(vk+2) for 0 ^ k ! 2n \Gamma  2. (31)
(Here, as elsewhere, we use * to denote the "weight" or the "sideways sum" of a
binary string, namely the number of 1s that it has.) Trial and error shows that

15

16 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

(a) (b) (c) (d) (e) (f) (g)

Fig. 14. Examples of
8-bit Gray paths:

a) standard;
b) balanced;

c) complementary;
d) long-run;

e) nonlocal;

f) monotonic;
g) trend-free.

16

7.2.1.1 GENERATING ALL n-TUPLES 17
there are essentially only two monotonic n-bit Gray paths for each n ^ 4, one
starting with 0n and the other starting with 0n\Gamma 11. The two for n = 3 are

000; 001; 011; 010; 110; 100; 101; 111; (32)
001; 000; 010; 110; 100; 101; 111; 011: (33)

The two for n = 4 are slightly less obvious, but not really difficult to discover.

Since *(vk+1) = *(vk) \Sigma  1 whenever vk is adjacent to vk+1, we obviously
can't strengthen (31) to the requirement that all n-tuples be strictly sorted by
weight. But relation (31) is strong enough to determine the weight of each vk,
given k and the weight of v0, because we know that exactly

\Gamma n

j

\Delta 

of the n-tuples

have weight j.

Fig. 14 summarizes our discussions so far, by illustrating seven of the zillions
of Gray codes and Gray paths that make a grand tour through all 256 of the
possible 8-bit bytes. Black squares represent ones and white squares represent
zeros. Fig. 14(a) is the standard Gray binary code, while Fig. 14(b) is balanced
with exactly 256=8 = 32 transitions in each coordinate position. Fig. 14(c)
is a Gray code analogous to Fig. 13(a), in which the bottom 128 codes are
complements of the top 128. In Fig. 14(d), the transitions in each coordinate
position never occur closer than five steps apart; in other words, all run lengths
are at least 5. The code in Fig. 14(e) is nonlocal in the sense of exercise 59.
Fig. 14(f) shows a monotonic path for n = 8; notice how black it gets near the
bottom. Finally, Fig. 14(g) illustrates a Gray path that is totally nonmonotonic,
in the sense that the center of gravity of the black squares lies exactly at the
halfway point. Standard Gray binary code has this property in seven of the
coordinate positions, but Fig. 14(g) achieves perfect black-white weight balance
in all eight. Such paths are called trend-free; they are important in the design
of agricultural and other experiments (see exercises 75 and 76).

Carla Savage and Peter Winkler [J. Combinatorial Theory A70 (1995),
230-248] found an elegant way to construct monotonic binary Gray paths for
all n ? 0. Such paths are necessarily built from subpaths Pnj in which all
transitions are between n-tuples of weights j and j + 1. Savage and Winkler
defined suitable subpaths recursively by letting P10 = 0; 1 and, for all n ? 0,

P(n+1)j = 1P ssnn(j\Gamma 1); 0Pnj; (34)

Pnj = ; if j ! 0 or j * n. (35)

Here ssn is a permutation of the coordinates that we will specify later, and the
notation P ss means that every element an\Gamma 1 : : : a1a0 of the sequence P is replaced
by bn\Gamma 1 : : : b1b0, where bjss = aj. (We don't define P ss by letting bj = ajss,
because we want (2j)ss to be 2jss.) It follows, for example, that

P20 = 0P10 = 00; 01 (36)
because P1(\Gamma 1) is vacuous; also

P21 = 1P ss110 = 10; 11 (37)

17

18 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
because P11 is vacuous and ss1 must be the identity permutation. In general,
Pnj is a sequence of n-bit strings containing exactly

\Gamma n\Gamma 1

j

\Delta 

strings of weight j

interleaved with

\Gamma n\Gamma 1

j

\Delta 

strings of weight j + 1.

Let ffnj and !nj be the first and last elements of Pnj. Then we easily find

!nj = 0n\Gamma j\Gamma 11j+1, for 0 ^ j ! n; (38)
ffn0 = 0n, for n ? 0; (39)

ffnj = 1ff

ssn\Gamma 1

(n\Gamma 1)(j\Gamma 1), for 1 ^ j ! n. (40)

In particular, ffnj always has weight j, and !nj always has weight j + 1. We will
define permutations ssn of f0; 1; : : : ; n \Gamma  1g so that both of the sequences

Pn0; P Rn1; Pn2; P Rn3; : : : (41)
and P Rn0; Pn1; P Rn2; Pn3; : : : (42)

are monotonic binary Gray paths for n = 1, 2, 3, : : : . In fact, the monotonicity
is clear, so only the Grayness is in doubt; and the sequences (41), (42) link up
nicely because the adjacencies

ffn0 \Gamma \Gamma \Gamma ffn1 \Gamma \Gamma \Gamma  \Delta  \Delta  \Delta  \Gamma \Gamma \Gamma ffn(n\Gamma 1); !n0 \Gamma \Gamma \Gamma !n1 \Gamma \Gamma \Gamma \Delta  \Delta  \Delta  \Gamma \Gamma \Gamma !n(n\Gamma 1) (43)
follow immediately from (34), regardless of the permutations ssn. Thus the
crucial point is the transition at the comma in formula (34), which makes P(n+1)j
a Gray subpath if and only if

!ssnn(j\Gamma 1) = ffnj for 0 ! j ! n. (44)
For example, when n = 2 and j = 1 we need (01)ss2 = ff21 = 10, by (38)-
(40); hence ss2 must transpose coordinates 0 and 1. The general formula (see
exercise 71) turns out to be

ssn = oen ss2n\Gamma 1; (45)

where oen is the n-cycle (n\Gamma 1 : : : 1 0). The first few cases are therefore

ss1 = (0);
ss2 = (0 1);
ss3 = (0 2 1);

ss4 = (0 3);
ss5 = (0 4 3 2 1);
ss6 = (0 5 2 4 1 3);

no simple "closed form" for the magic permutations ssn is apparent. Exercise 73
shows that the Savage-Winkler paths can be generated efficiently.

Nonbinary Gray codes. We have studied the case of binary n-tuples in
great detail, because it is the simplest, most classical, most applicable, and
most thoroughly explored part of the subject. But of course there are numerous
applications in which we want to generate (a1; : : : ; an) with coordinates in the
more general ranges 0 ^ aj ! mj, as in Algorithm M. Gray codes and Gray
paths apply to this case as well.

Consider, for example, decimal digits, where we want 0 ^ aj ! 10 for
each j. Is there a decimal way to count that is analogous to the Gray binary
code, changing only one digit at a time? Yes; in fact, two natural schemes are

18

7.2.1.1 GENERATING ALL n-TUPLES 19
available. In the first, called reflected Gray decimal, the sequence for counting
up to a thousand with 3-digit strings has the form

000; 001; : : : ; 009; 019; 018; : : : ; 011; 010; 020; 021; : : : ; 091; 090; 190; 191; : : : ; 900;
with each coordinate moving alternately from 0 up to 9 and then back down from
9 to 0. In the second, called modular Gray decimal, the digits always increase
by 1 mod 10, therefore they "wrap around" from 9 to 0:

000; 001; : : : ; 009; 019; 010; : : : ; 017; 018; 028; 029; : : : ; 099; 090; 190; 191; : : : ; 900:
In both cases the digit that changes on step k is determined by the radix-ten
ruler function ae10(k), the largest power of 10 that divides k. Therefore each
n-tuple of digits occurs exactly once: We generate 10j different settings of the
rightmost j digits before changing any of the others, for 1 ^ j ^ n.

In general, the reflected Gray code in any mixed-radix system can be regarded as a permutation of the nonnegative integers, a function that maps an
ordinary mixed-radix number

k =

h

bn\Gamma 1;

mn\Gamma 1;

: : : ;
: : : ;

b1;
m1;

b0
m0

i

= bn\Gamma 1mn\Gamma 2 : : : m1m0 + \Delta  \Delta  \Delta  + b1m0 + b0 (46)

into its reflected-Gray equivalent

rg(k) =

h

an\Gamma 1;

mn\Gamma 1;

: : : ;
: : : ;

a1;
m1;

a0
m0

i

= an\Gamma 1mn\Gamma 2 : : : m1m0 + \Delta  \Delta  \Delta  + a1m0 + a0; (47)

just as (7) does this in the special case of binary numbers. Let

Aj =

h

an\Gamma 1;

mn\Gamma 1;

: : : ;
: : : ;

aj
mj

i

; Bj =

h

bn\Gamma 1;

mn\Gamma 1;

: : : ;
: : : ;

bj
mj

i

; (48)

so that

Aj = mjAj+1 + aj and Bj = mjBj+1 + bj: (49)

The rule connecting the a's and b's is not difficult to derive by induction:

aj =

ae

bj; if Bj+1 is even;

mj \Gamma  1 \Gamma  bj; if Bj+1 is odd.

(50)

(Here we are numbering the coordinates of the n-tuples (an\Gamma 1; : : : ; a1; a0) and
(bn\Gamma 1; : : : ; b1; b0) from right to left, for consistency with (7) and the conventions of mixed-radix notation in Eq. 4.1-(9). Readers who prefer notations like
(a1; : : : ; an) can change j to n \Gamma  j in all the formulas if they wish.) Going the
other way, we have

bj =

ae

aj; if aj+1 + aj+2 + \Delta  \Delta  \Delta  is even;

mj \Gamma  1 \Gamma  aj; if aj+1 + aj+2 + \Delta  \Delta  \Delta  is odd.

(51)

Curiously, rule (50) and its inverse in (51) are exactly the same when all of the
radices mj are odd. In Gray ternary code, for example, when m0 = m1 = \Delta  \Delta  \Delta  = 3,
we have rg

\Gamma 

(10010211012)3

\Delta 

= (12210211010)3 and also rg

\Gamma 

(12210211010)3

\Delta 

=

(10010211012)3. Exercise 78 proves (50) and (51), and discusses similar formulas

19

20 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
that hold in the modular case. People often call these sequences "Gray codes,"
although strictly speaking they might only be Gray paths (see exercise 79).

We can in fact generate such Gray sequences looplessly, generalizing Algorithms M and L:

Algorithm H (Loopless reflected mixed-radix Gray generation). This algorithm
visits all n-tuples (an\Gamma 1; : : : ; a0) such that 0 ^ aj ! mj for 0 ^ j ! n, changing
only one coordinate by \Sigma 1 at each step. It maintains an array of focus pointers
(fn; : : : ; f0) to control the actions as in Algorithm L, together with an array
of directions (dn\Gamma 1; : : : ; d0) and an array of sentinel values (sn\Gamma 1; : : : ; s0). We
assume that each radix mj is * 2.

H1. [Initialize.] Set aj  0, fj  j, dj  1, and sj  mj \Gamma  1, for 0 ^ j ! n;

also set fn  n.

H2. [Visit.] Visit the n-tuple (an\Gamma 1; : : : ; a1; a0).
H3. [Choose j.] Set j  f0 and f0  0. (As in Algorithm L, j was the rightmost

active coordinate; all elements to its right have now been activated.)

H4. [Change coordinate j.] Terminate if j = n; otherwise set aj  aj + dj.
H5. [Reflect?] If aj = sj, set dj  \Gamma dj, sj  mj \Gamma  1 \Gamma  sj, fj  fj+1, and

fj+1  j + 1. (Coordinate j has thus become passive.) Return to H2.

A similar algorithm, somewhat simpler, generates the modular variation (see
exercise 77).

*Subforests. An interesting and instructive generalization of Algorithm H,

discovered by Y. Koda and F. Ruskey [J. Algorithms 15 (1993), 324-340], sheds
further light on the subject of Gray codes and loopless generation. Suppose we
have a forest of n nodes, and we want to visit all of its "principal subforests,"
namely all subsets of nodes S such that if x is in S and x is not a root, the
parent of x is also in S. For example, the 7-node forest has 33 such subsets,
corresponding to the black nodes in the following 33 diagrams:

(52)
Notice that if we read the top row from left to right, the middle row from right
to left, and the bottom row from left to right, the status of exactly one node
changes at each step.

If the given forest consists of degenerate nonbranching trees, the principal
subforests are equivalent to mixed-radix numbers. For example, a forest like

has 3 \Theta  2 \Theta  4 \Theta  2 principal subforests, corresponding to 4-tuples (x1; x2; x3; x4)
such that 0 ^ x1 ! 3, 0 ^ x2 ! 2, 0 ^ x3 ! 4, and 0 ^ x4 ! 2; the value of xj

20

7.2.1.1 GENERATING ALL n-TUPLES 21
is the number of nodes selected in the jth forest. When the algorithm of Koda
and Ruskey is applied to such a forest, it will visit the subforests in the same
order as the reflected Gray code on radices (3; 2; 4; 2).

Algorithm K (Loopless reflected subforest generation). Given a forest whose
nodes are (1; : : : ; n) when arranged in postorder, this algorithm visits all binary
n-tuples (a1; : : : ; an) such that ap * aq whenever p is a parent of q. (Thus,
ap = 1 means that p is a node in the current subforest.) Exactly one bit aj
changes between one visit and the next. Focus pointers (f0; f1; : : : ; fn) analogous
to those of Algorithm L are used together with additional arrays of pointers
(l0; l1; : : : ; ln) and (r0; r1; : : : ; rn), which represent a doubly linked list called the
"current fringe." The current fringe contains all nodes of the current subforest
and their children; r0 points to its leftmost node and l0 to its rightmost.

An auxiliary array (c0; c1; : : : ; cn) defines the forest as follows: If p has no
children, cp = 0; otherwise cp is the leftmost (smallest) child of p. Also c0 is the
leftmost root of the forest itself. When the algorithm begins, we assume that
rp = q and lq = p whenever p and q are consecutive children of the same family.
Thus, for example, the forest in (52) has the postorder numbering

1
2

3

4 5

6
7

;

therefore we should have (c0; : : : ; c7) = (2; 0; 1; 0; 0; 0; 4; 3) and r2 = 7, l7 = 2,
r3 = 6, l6 = 3, r4 = 5, and l5 = 4 at the beginning of step K1 in this case.

K1. [Initialize.] Set aj  0 and fj  j for 1 ^ j ^ n, thereby making the initial

subforest empty and all nodes active. Set f0  0, l0  n, rn  0, r0  c0,
and lc0  0, thereby putting all roots into the current fringe.

K2. [Visit.] Visit the subforest defined by (a1; : : : ; an).
K3. [Choose p.] Set q  l0, p  fq. (Now p is the rightmost active node of the

fringe.) Also set fq  q (thereby activating all nodes to p's right).

K4. [Check ap.] Terminate the algorithm if p = 0. Otherwise go to K6 if ap = 1.
K5. [Insert p's children.] Set ap  1. Then, if cp 6= 0, set q  rp, lq  p \Gamma  1,

rp\Gamma 1  q, rp  cp, lcp  p (thereby putting p's children to the right of p
in the fringe). Go to K7.

K6. [Delete p's children.] Set ap  0. Then, if cp 6= 0, set q  rp\Gamma 1, rp  q,

lq  p (thereby removing p's children from the fringe).

K7. [Make p passive.] (At this point we know that p is active.) Set fp  flp

and flp  lp. Return to K2.

The reader is encouraged to play through this algorithm on examples like (52),
in order to understand the beautiful mechanism by which the fringe grows and
shrinks at just the right times.

21

22 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
*Shift register sequences. A completely different way to generate all n-tuples of

m-ary digits is also possible: We can generate one digit at a time, and repeatedly
work with the n most recently generated digits, thus passing from one n-tuple
(x0; x1; : : : ; xn\Gamma 1) to another one (x1; : : : ; xn\Gamma 1; xn) by shifting an appropriate
new digit in at the right. For example, Fig. 15 shows how all 5-bit numbers can
be obtained as blocks of 5 consecutive bits in a certain cyclic pattern of length 32.
This general idea has already been discussed in some of the exercises of Sections
2.3.4.2 and 3.2.2, and we now are ready to explore it further.

Fig. 15.
A de Bruijn cycle
for 5-bit numbers.

000

00

0000

1

00010

00100
01000
1000

100
01100

11

0
01

10

0

11

00

1

10

01

0

00
10
1

01
01
0

10
10
0

01
00
1

10
01
1

001
11

0111
0

11101
11010

10101

0101
1 10

110 01

10
1

11
01
1

10
11
1

01
11
1

11
11
1

11

11

0

11

10

0

11

00

0

10

00

0

Algorithm S (Generic shift register generation). This algorithm visits all ntuples (a1; : : : ; an) such that 0 ^ aj ! m for 1 ^ j ^ n, provided that a suitable
function f is used in step S3.

S1. [Initialize.] Set aj  0 for \Gamma n ! j ^ 0 and k  1.
S2. [Visit.] Visit the n-tuple (ak\Gamma n; : : : ; ak\Gamma 1). Terminate if k = mn.
S3. [Advance.] Set ak  f (ak\Gamma n; : : : ; ak\Gamma 1), k  k + 1, and return to S2.

Every function f that makes Algorithm S valid corresponds to a cycle of
mn radix-m digits such that every combination of n digits occurs consecutively
in the cycle. For example, the case m = 2 and n = 5 illustrated in Fig. 15
corresponds to the binary cycle

00000100011001010011101011011111; (53)
and the first m2 digits of the infinite sequence

0011021220313233041424344 : : : (54)
yield an appropriate cycle for n = 2 and arbitrary m. Such cycles are commonly
called m-ary de Bruijn cycles, because N. G. de Bruijn treated the binary case
for arbitrary n in Indagationes Mathematicae 8 (1946), 461-467.

Exercise 2.3.4.2-23 proves that exactly m!m

n\Gamma 1

=mn functions f have the

required properties. That's a huge number, but only a few of those functions are
known to be efficiently computable. We will discuss three kinds of f that appear
to be the most useful.

22

7.2.1.1 GENERATING ALL n-TUPLES 23

Table 1
PARAMETERS FOR ALGORITHM A

3 : 1 8 : 1; 5 13 : 1; 3 18 : 7 23 : 5 28 : 3
4 : 1 9 : 4 14 : 1; 11 19 : 1; 5 24 : 1; 3 29 : 2
5 : 2 10 : 3 15 : 1 20 : 3 25 : 3 30 : 1; 15
6 : 1 11 : 2 16 : 2; 3 21 : 2 26 : 1; 7 31 : 3
7 : 1 12 : 3; 4 17 : 3 22 : 1; 7 27 : 1; 7 32 : 1; 27

The entries `n : s' or `n : s; t' mean that the polynomials xn + xs + 1 or xn + (xs + 1)(xt + 1)
are primitive modulo 2. Additional values up to n = 168 have been tabulated by W. Stahnke,
Math. Comp. 27 (1973), 977-980.

The first important case occurs when m is a prime number, and f is the
almost-linear recurrence

f(x1; : : : ; xn) =

8
?!

?:

c1; if (x1; x2; : : : ; xn) = (0; 0; : : : ; 0);
0; if (x1; x2; : : : ; xn) = (1; 0; : : : ; 0);
(c1x1 + c2x2 + \Delta  \Delta  \Delta  + cnxn) mod m; otherwise.

(55)

Here the coefficients (c1; : : : ; cn) must be such that

xn \Gamma  cnxn\Gamma 1 \Gamma  \Delta  \Delta  \Delta  \Gamma  c2x \Gamma  c1 (56)
is a primitive polynomial modulo m, in the sense discussed following Eq. 3.2.2-
(9). The number of such polynomials is '(mn \Gamma  1)=n, large enough to allow us
to find one in which only a few of the c's are nonzero. [This construction goes
back to a pioneering paper of Willem Mantel, Nieuw Archief voor Wiskunde (2)
1 (1897), 172-184.]

For example, suppose m = 2. We can generate binary n-tuples with a very
simple loopless procedure:

Algorithm A (Almost-linear bit-shift generation). This algorithm visits all nbit vectors, by using either a special offset s [Case 1] or two special offsets s and t
[Case 2], as found in Table 1.

A1. [Initialize.] Set (x0; x1; : : : ; xn\Gamma 1)  (1; 0; : : : ; 0) and k  0, j  s. In

Case 2, also set i  t and h  s + t.

A2. [Visit.] Visit the n-tuple (xk\Gamma 1; : : : ; x0; xn\Gamma 1; : : : ; xk+1; xk).
A3. [Test for end.] If xk 6= 0, set r  0; otherwise set r  r + 1, and go to A6

if r = n \Gamma  1. (We have just seen r consecutive zeros.)

A4. [Shift.] Set k  (k \Gamma  1) mod n and j  (j \Gamma  1) mod n. In Case 2 also set

i  (i \Gamma  1) mod n and h  (h \Gamma  1) mod n.

A5. [Compute a new bit.] Set xk  xk \Phi  xj [Case 1] or xk  xk \Phi  xj \Phi  xi \Phi  xh

[Case 2]. Return to A2.

A6. [Finish.] Visit (0; : : : ; 0) and terminate.

Appropriate offset parameters s and possibly t almost certainly exist for all n,
because primitive polynomials are so abundant; for example, eight different
choices of (s; t) would work when n = 32, and Table 1 merely lists the smallest.

23

24 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
However, a rigorous proof of existence in all cases lies well beyond the present
state of mathematical knowledge.

Our first construction of de Bruijn cycles, in (55), was algebraic, relying for
its validity on the theory of finite fields. A similar method that works when m
is not a prime number appears in exercise 3.2.2-21. Our next construction, by
contrast, will be purely combinatorial. In fact, it is strongly related to the idea
of modular Gray m-ary codes.

Algorithm R (Recursive de Bruijn cycle generation). Suppose f () is a coroutine
that will output the successive digits of an m-ary de Bruijn cycle of length mn,
beginning with n zeros, when it is invoked repeatedly. This algorithm is a similar
coroutine that outputs a cycle of length mn+1, provided that n * 2. It maintains
three private variables x, y, and t; variable x should initially be zero.

R1. [Output.] Output x. Go to R3 if t * n and x 6= 0.
R2. [Invoke f.] Set y  f ().
R3. [Count ones.] If y = 1, set t  t + 1; otherwise set t  0.
R4. [Skip one?] If t = n and x 6= 0, go back to R2.
R5. [Adjust x.] Set x  (x + y) mod m and return to R1.

For example, let m = 3 and n = 2. If f() produces the infinite 9-cycle

001102122 001102122 0 : : : ; (57)
then Algorithm R will produce the following infinite 27-cycle at step R1:

y = 001021220011110212200102122 001 : : :

t = 001001000012340010000100100 001 : : :
x = 000110102220120020211122121 0001 : : :

The proof that Algorithm R works correctly is interesting and instructive (see
exercise 92). And the proof of the next algorithm, which doubles the window
size n, is even more so (see exercise 94).

Algorithm D (Doubly recursive de Bruijn cycle generation). Suppose f () and
g() are coroutines that each will output the successive digits of m-ary de Bruijn
cycles of length mn when invoked repeatedly, beginning with n zeros. (The two
cycles might be identical, but they must be generated by independent coroutines
because we will consume their values at different rates of speed.) This algorithm
is a similar coroutine that outputs a cycle of length m2n. It maintains six private
variables x, y, t, x0, y0, and t0; variables x and x0 should initially be m.

The special parameter r must be set to a constant value such that

0 ^ r ^ m and gcd(mn \Gamma  r; mn + r) = 2: (58)
The best choice is usually r = 1 when m is odd and r = 2 when m is even.
D1. [Possibly invoke f.] If t 6= n or x * r, set y  f ().
D2. [Count repeats.] If x 6= y, set x  y and t  1. Otherwise set t  t + 1.
D3. [Output from f.] Output the current value of x.

24

7.2.1.1 GENERATING ALL n-TUPLES 25
D4. [Invoke g.] Set y0  g().
D5. [Count repeats.] If x0 6= y0, set x0  y0 and t0  1. Otherwise set t0  t0 +1.
D6. [Possibly reject g.] If t0 = n and x0 ! r and either t ! n or x0 ! x, go to

D4. If t0 = n and x0 ! r and x0 = x, go to D3.

D7. [Output from g.] Output the current value of x0. Return to D3 if t0 = n

and x0 ! r; otherwise return to D1.

The basic idea of Algorithm D is to output from f() and g() alternately, making
special adjustments when either sequence generates n consecutive x's for x ! r.
For example, when f() and g() produce the 9-cycle (57), we take r = 1 and get

t in step D2: 12 31211112 12312111 12123121 11121231 21111212 : : :
x in step D3: 00001102122 00011021 22000110 21220001 102122000 : : :
t0 in step D6: 121211112121211112121211112121211112121211112121 : : :
x0 in step D7: 0 11021220 11021220 11021220 11021220 11021220 1 : : : ;

so the 81-cycle produced in steps D3 and D7 is 00001011012 : : : 2222 00001: : : .

The case m = 2 of Algorithm R was discovered by Abraham Lempel [IEEE
Trans. C-19 (1970), 1204-1209]; Algorithm D was not discovered until more than
25 years later [C. J. Mitchell, T. Etzion, and K. G. Paterson, IEEE Trans. IT42 (1996), 1472-1478]. By using them together, starting with simple coroutines
for n = 2 based on (54), we can build up an interesting family of cooperating
coroutines that will generate a de Bruijn cycle of length mn for any desired m * 2
and n * 2, using only O(log n) simple computations for each digit of output.
(See exercise 95.) Furthermore, in the simplest case m = 2, this combination
"R&D method" has the property that its kth output can be computed directly,
as a function of k, by doing O(n log n) simple operations on n-bit numbers.
Conversely, given any n-bit pattern fi, the position of fi in the cycle can also be
computed in O(n log n) steps. (See exercises 96-98.) No other family of de Bruijn
cycles is presently known to have the latter property.

Our third construction of de Bruijn cycles is based on the theory of prime
strings, which will be of great importance to us when we study pattern matching
in Chapter 9. Suppose fl = fffi is the concatenation of two strings; we say that
ff is a prefix of fl and fi is a suffix. A prefix or suffix of fl is called proper if its
length is positive but less than the length of fl. Thus fi is a proper suffix of fffi
if and only if ff 6= ffl and fi 6= ffl.

Definition P. A string is prime if it is nonempty and (lexicographically) less
than all of its proper suffixes.

For example, 01101 is not prime, because it is greater than 01; but 01102 is
prime. (We assume that strings are composed of letters, digits, or other symbols
from a linearly ordered alphabet. Lexicographic or dictionary order is the normal
way to compare strings, so we write ff ! fi and say that ff is less than fi when
ff is lexicographically less than fi. In particular, we always have ff ^ fffi, and
ff ! fffi if and only if fi 6= ffl.)

25

26 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

Prime strings have often been called Lyndon words, because they were
introduced by R. C. Lyndon [Trans. Amer. Math. Soc. 77 (1954), 202-215];
Lyndon called them "standard sequences." The simpler term "prime" is justified
because of the fundamental factorization theorem in exercise 102. We will,
however, continue to pay respect to Lyndon implicitly by often using the letter *
to denote strings that are prime.

Several of the most important properties of prime strings were derived by
Chen, Fox, and Lyndon in an important paper on group theory [Annals of Math.
68 (1958), 81-95], including the following easy but basic result:

Theorem P. A nonempty string that is less than all its cyclic shifts is prime.
(The cyclic shifts of a1 : : : an are a2 : : : ana1, a3 : : : ana1a2, : : : , ana1 : : : an\Gamma 1.)
Proof. Suppose fl = fffi is not prime, because ff 6= ffl and fl * fi 6= ffl; but suppose
fl is also less than its cyclic shift fiff. Then the conditions fi ^ fl ! fiff imply
that fl = fi` for some string ` ! ff. Therefore, if fl is also less than its cyclic
shift `fi, we have ` ! ff ! fffi ! `fi. But that is impossible, because ff and `
have the same length.

Let Lm(n) be the number of m-ary primes of length n. Every string a1 : : : an,
together with its cyclic shifts, yields d distinct strings for some divisor d of n,
corresponding to exactly one prime of length d. For example, from 010010 we
get also 100100 and 001001 by cyclic shifting, and the smallest of the periodic
parts f010; 100; 001g is the prime 001. Therefore we must have

X

dnn

dLm(d) = mn; for all m; n * 1. (59)

This family of equations can be solved for Lm(n) using exercise 4.5.3-28(a), and
we obtain

Lm(n) =

1

n

X

dnn

_(d)mn=d: (60)

During the 1970s, Harold Fredricksen and James Maiorana discovered a
beautifully simple way to generate all of the m-ary primes of length n or less,
in increasing order [Discrete Math. 23 (1978), 207-210]. Before we are ready to
understand their algorithm, we need to consider the n-extension of a nonempty
string *, namely the first n characters of the infinite string *** : : : . For example,
the 10-extension of 123 is 1231231231. In general if j*j = k, its n-extension is
*bn=kc*0, where *0 is the prefix of * whose length is n mod k.

Definition Q. A string is preprime if it is a nonempty prefix of a prime.
Theorem Q. A string of length n ? 0 is preprime if and only if it is the nextension of a prime string * of length k ^ n. This prime string is uniquely
determined.

Proof. See exercise 104.

26

7.2.1.1 GENERATING ALL n-TUPLES 27
Theorem Q states, in essence, that there is a one-to-one correspondence between
primes of length ^ n and preprimes of length n. The following algorithm
generates all of the m-ary ones, in increasing order.

Algorithm F (Prime and preprime string generation). This algorithm visits
all m-ary n-tuples (a1; : : : ; an) such that the string a1 : : : an is preprime. It also
identifies the index j such that a1 : : : an is the n-extension of the prime a1 : : : aj.

F1. [Initialize.] Set a0  \Gamma 1, a1  \Delta  \Delta  \Delta   an  0, and j  1.
F2. [Visit.] Visit (a1; : : : ; an) with index j.
F3. [Prepare to increase.] Set j  n. Then if aj = m \Gamma  1, decrease j until

finding aj ! m \Gamma  1.

F4. [Add one.] Terminate if j = 0. Otherwise set aj  aj + 1. (Now a1 : : : aj is

prime, by exercise 104(a).)

F5. [Make n-extension.] For k  j + 1, : : : , n (in this order) set ak  ak\Gamma j.

Return to F2.

For example, Algorithm F visits 32 ternary preprimes when m = 3 and n = 4:

0^000 0011^ 0022^ 0111^ 0122^ 0212^ 1^111 12^12
0001^ 0012^ 01^01 0112^ 02^02 022^0 1112^ 122^1
0002^ 002^0 0102^ 012^0 021^0 0221^ 112^1 1222^
001^0 0021^ 011^0 0121^ 0211^ 0222^ 1122^ 2^222

(61)

(The digits preceding `^' are the prime strings 0, 0001, 0002, 001, 0011, : : : , 2.)
Theorem Q explains why this algorithm is correct, because steps F3 and F4
obviously find the smallest m-ary prime of length ^ n that exceeds the previous
preprime a1 : : : an. Notice that after a1 increases from 0 to 1, the algorithm
proceeds to visit all the (m \Gamma  1)-ary primes and preprimes, increased by 1 : : : 1.

Algorithm F is quite beautiful, but what does it have to do with de Bruijn
cycles? Here now comes the punch line: If we output the digits a1, : : : , aj in
step F2 whenever j is a divisor of n, the sequence of all such digits forms a de
Bruijn cycle! For example, in the case m = 3 and n = 4, the following 81 digits
are output:

0 0001 0002 0011 0012 0021 0022 01 0102 0111 0112

0121 0122 02 0211 0212 0221 0222 1 1112 1122 12 1222 2: (62)

(We omit the primes 001, 002, 011, : : : , 122 of (61) because their length does
not divide 4.) The reasons underlying this almost magical property are explored
in exercise 107. Notice that the cycle has the correct length, by (59).

There is a sense in which the outputs of this procedure are actually equivalent to the "granddaddy" of all de Bruijn cycle constructions that work for all m
and n, namely the construction first published by M. H. Martin in Bull. Amer.
Math. Soc. 40 (1934), 859-864: Martin's original cycle for m = 3 and n = 4
was 2222122202211 : : : 10000, the twos' complement of (62). In fact, Fredricksen
and Maiorana discovered Algorithm F almost by accident while looking for a

27

28 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
simple way to generate Martin's sequence; the explicit connection between their
algorithm and preprime strings was not noticed until many years later, when
Ruskey, Savage, and Wang carried out a careful analysis of the running time
[J. Algorithms 13 (1992), 414-430]. The principal results of that analysis appear
in exercise 106, namely

i) The average value of n \Gamma  j in steps F3 and F5 is approximately m=(m \Gamma  1)2.
ii) The total running time to produce a de Bruijn cycle like (62) is O(mn).

EXERCISES

1. [10 ] Explain how to generate all n-tuples (a1; : : : ; an) in which lj ^ aj ^ uj, given
lower bounds lj and upper bounds uj for each coordinate. (Assume that lj ^ uj.)

2. [15 ] What is the 1000000th n-tuple visited by Algorithm M if n = 10 and mj = j
for 1 ^ j ^ n? Hint: [ 0;1; 0;2; 1;3; 2;4; 3;5; 0;6; 2;7; 7;8; 1;9; 010 ] = 1000000.

x 3. [M20 ] How many times does Algorithm M perform step M4?
x 4. [18 ] On most computers it is faster to count down to 0 rather than up to m.

Revise Algorithm M so that it visits all n-tuples in the opposite order, starting with
(m1 \Gamma  1; : : : ; mn \Gamma  1) and finishing with (0; : : : ; 0).

x 5. [20 ] Algorithms such as the "fast Fourier transform" (exercise 4.6.4-14) often

end with an array of answers in bit-reflected order, having A[(b0 : : : bn\Gamma 1)2] in the place
where A[(bn\Gamma 1 : : : b0)2] is desired. What is a good way to rearrange the answers into
proper order? [Hint: Reflect Algorithm M.]

6. [M17 ] Prove (7), the basic formula for Gray binary code.
7. [20 ] Fig. 10(b) shows the Gray binary code for a disk that is divided into 16
sectors. What would be a good Gray-like code to use if the number of sectors were 12
or 60 (for hours or minutes on a clock), or 360 (for degrees in a circle)?

8. [15 ] What's an easy way to run through all n-bit strings of even parity, changing
only two bits at each step?

9. [16 ] What move should follow Fig. 11, when solving the Chinese ring puzzle?
x 10. [M21 ] Find a simple formula for the total number of steps An or Bn in which a

ring is (a) removed or (b) replaced, in the shortest procedure for removing n Chinese
rings. For example, A3 = 4 and B3 = 1.

11. [M22 ] (H. J. Purkiss, 1865.) The two smallest rings of the Chinese ring puzzle
can actually be taken on or off the bar simultaneously. How many steps does the puzzle
require when such accelerated moves are permitted?

x 12. [23 ] The compositions of n are the sequences of positive integers that sum to n.

For example, the compositions of 4 are 1111, 112, 121, 13, 211, 22, 31, and 4. An integer
n has exactly 2n\Gamma 1 compositions, corresponding to all subsets of the points f1; : : : ; n\Gamma 1g
that might be used to break the interval (0 : : n) into integer-sized subintervals.

a) Design a loopless algorithm to generate all compositions of n, representing each

composition as a sequential array of integers s1s2 : : : sj.
b) Similarly, design a loopless algorithm that represents the compositions implicitly

in an array of pointers p0p1 : : : pn\Gamma 1, where the elements of the composition are
(q1 \Gamma  q0)(q2 \Gamma  q1) : : : (qj \Gamma  qj\Gamma 1) if we let q0 = 0, ql+1 = pql, and qj = n. For
example, the composition 211 would be represented under this scheme by the
pointers p0 = 2, p2 = 3, p3 = 4, and with p1 set to any convenient value.

28

7.2.1.1 GENERATING ALL n-TUPLES 29

13. [21 ] Continuing the previous exercise, compute also the multinomial coefficient
C =

\Gamma  n

s1;:::;sj

\Delta 

for use as the composition s1 : : : sj is being visited.

14. [20 ] Design an algorithm to generate all strings a1 : : : aj such that 0 ^ j ^ n and
0 ^ ai ! mi for 1 ^ i ^ j, in lexicographic order. For example, if m1 = m2 = n = 2,
your algorithm should successively visit ffl, 0, 00, 01, 1, 10, 11.

x 15. [25 ] Design a loopless algorithm to generate the strings of the previous exercise.

All strings of the same length should be visited in lexicographic order as before, but
strings of different lengths can be intermixed in any convenient way. For example,
0, 00, 01, ffl, 10, 11, 1 is an acceptable order when m1 = m2 = n = 2.

x 16. [23 ] A loopless algorithm obviously cannot generate all binary vectors (a1; : : : ; an)

in lexicographic order, because the number of coordinates aj that need to change
between successive visits is not bounded. Show, however, that loopless lexicographic
generation does become possible if a linked representation is used instead of a sequential
one: Suppose there are 2n nodes f1:0; 1:1; 2:0; 2:1; : : : ; n:0; n:1g, each containing a DIGIT
field and a LINK field, where DIGIT(j:b) = b for 1 ^ j ^ n and 0 ^ b ^ 1. An n-tuple
like (0; 1; 0) is represented by

LINK(0:0) = 1:0; LINK(1:0) = 2:1; LINK(2:1) = 3:0; LINK(3:0) = \Lambda ;
where 0:0 is a special header node; the other LINK fields can have any convenient values.

17. [20 ] A well-known construction called the Karnaugh map [M. Karnaugh, Amer.
Inst. Elect. Eng. Trans. 72, part I (1953), 593-599] uses Gray binary code in two
dimensions to display all 4-bit numbers in a 4 \Theta  4 torus:

0000 0001 0011 0010
0100 0101 0111 0110
1100 1101 1111 1110
1000 1001 1011 1010

(The entries of a torus "wrap around" at the left and right and also at the top and
bottom -- just as if they were tiles, replicated infinitely often in a plane.) Show that,
similarly, all 6-bit numbers can be arranged in an 8\Theta 8 torus so that only one coordinate
changes when we move north, south, east, or west from any point.

x 18. [20 ] The Lee weight of a vector u = (u1; : : : ; un), where each component satisfies

0 ^ uj ! mj, is defined to be

*L(u) =

nX

j=1

min(uj; mj \Gamma  uj);

and the Lee distance between two such vectors u and v is

dL(u; v) = *L(u \Gamma  v); where u \Gamma  v = ((u1 \Gamma  v1) mod m1; : : : ; (un \Gamma  vn) mod mn):
(This is the minimum number of steps needed to change u to v if we adjust some
component uj by \Sigma 1 (modulo mj) in each step.)

A quaternary vector has mj = 4 for 1 ^ j ^ n, and a binary vector has all mj = 2.
Find a simple one-to-one correspondence between quaternary vectors u = (u1; : : : ; un)
and binary vectors u0 = (u01; : : : ; u02n), with the property that *L(u) = *(u0) and
dL(u; v) = *(u0 \Phi  v0).

29

30 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
19. [21 ] (The octacode.) Let g(x) = x3 + 2x2 + x \Gamma  1.

a) Use one of the algorithms in this section to evaluate

P

zu0zu1zu2zu3zu4zu5zu6zu1,

summed over all 256 polynomials

(v0 + v1x + v2x2 + v3x3)g(x) mod 4 = u0 + u1x + u2x2 + u3x3 + u4x4 + u5x5 + u6x6
for 0 ^ v0; v1; v2; v3 ! 4, where u1 is chosen so that 0 ^ u1 ! 4 and (u0 + u1 +
u2 + u3 + u4 + u5 + u6 + u1) mod 4 = 0.
b) Construct a set of 256 16-bit numbers that differ from each other in at least six

different bit positions. (Such a set, first discovered by Nordstrom and Robinson
[Inf. and Control 11 (1967), 613-616], is essentially unique.)

20. [M36 ] The 16-bit codewords in the previous exercise can be used to transmit 8
bits of information, allowing transmission errors to be corrected if any one or two bits
are corrupted; furthermore, mistakes will be detected (but not necessarily correctable)
if any three bits are received incorrectly. Devise an algorithm that either finds the
nearest codeword to a given 16-bit number u0 or determines that at least three bits of
u0 are erroneous. How does your algorithm decode the number (1100100100001111)2?
[Hint: Use the facts that x7 j 1 (modulo g(x) and 4), and that every quaternary
polynomial of degree ! 3 is congruent to xj + 2xk (modulo g(x) and 4) for some
j; k 2 f0; 1; 2; 3; 4; 5; 6; 1g, where x1 = 0.]

21. [M30 ] A t-subcube of an n-cube can be represented by a string like \Lambda \Lambda 10\Lambda \Lambda 0\Lambda ,
containing t asterisks and n \Gamma  t specified bits. If all 2n binary n-tuples are written in
lexicographic order, the elements belonging to such a subcube appear in 2t0 clusters
of consecutive entries, where t0 is the number of asterisks that lie to the left of the
rightmost specified bit. (In the example given, n = 8, t = 5, and t0 = 4.) But if the
n-tuples are written in Gray binary order, the number of clusters might be reduced.
For example, the (n \Gamma  1)-subcubes \Lambda  : : : \Lambda 0 and \Lambda  : : : \Lambda 1 occur in only 2n\Gamma 2 + 1 and 2n\Gamma 2
clusters, respectively, when Gray binary order is used, not in 2n\Gamma 1 of them.

a) Explain how to compute C(ff), the number of Gray binary clusters of the subcube

defined by a given string ff of asterisks, 0s, and 1s. What is C(\Lambda \Lambda 10\Lambda \Lambda 0\Lambda )?
b) Prove that C(ff) always lies between 2t0\Gamma 1 and 2t0, inclusive.

c) What is the average value of C(ff), over all 2n\Gamma t

\Gamma n

t

\Delta 

possible t-subcubes?

x 22. [22 ] A "right subcube" is a subcube such as 0110\Lambda \Lambda  in which all the asterisks

appear after all the specified digits. Any binary trie (Section 6.3) can be regarded as a
way to partition a cube into disjoint right subcubes, as in Fig. 16(a). If we interchange
the left and right subtries of every right subtrie, proceeding downward from the root,
we obtain a Gray binary trie, as in Fig. 16(b).

Prove that if the "lieves" of a Gray binary trie are traversed in order, from left to
right, consecutive lieves correspond to adjacent subcubes. (Subcubes are adjacent if
they contain adjacent vertices. For example, 00\Lambda \Lambda  is adjacent to 011\Lambda  because the first
contains 0010 and the second contains 0110; but 011\Lambda  is not adjacent to 10\Lambda \Lambda .)

Fig. 16.

00\Lambda \Lambda 

010\Lambda  011\Lambda  100\Lambda 

1010 1011

11\Lambda \Lambda 

(a) Normal binary trie.

00\Lambda \Lambda 

010\Lambda 011\Lambda  100\Lambda 

1010 1011

11\Lambda \Lambda 

(b) Gray binary trie.

30

7.2.1.1 GENERATING ALL n-TUPLES 31

23. [20 ] Suppose g(k) \Phi  2j = g(l). What is a simple way to find l, given j and k?
24. [M21 ] Consider extending the Gray binary function g to all 2-adic integers (see
exercise 4.1-31). What is the corresponding inverse function g[\Gamma 1]?

x 25. [M25 ] Prove that if g(k) and g(l) differ in t ? 0 bits, and if 0 ^ k; l ! 2n, then

d2t=3e ^ jk \Gamma  lj ^ 2n \Gamma  d2t=3e.

26. [25 ] (Frank Ruskey.) For which integers N is it possible to generate all of the
nonnegative integers less than N in such a way that only one bit of the binary representation changes at each step?

x 27. [20 ] Let S0 = f1g and Sn+1 = 1=(2 + Sn) [ 1=(2 \Gamma  Sn); thus, for example,

S2 =

8
??
!

??
:

1

2 +

1

2 + 1

;

1

2 +

1

2 \Gamma  1

;

1

2 \Gamma 

1

2 + 1

;

1

2 \Gamma 

1

2 \Gamma  1

9
??
=

??
;

=

ae

3

7

;

1

3

;

3

5

; 1

oe

;

and Sn has 2n elements that lie between 13 and 1. Compute the 1010th smallest element
of S100.

28. [M26 ] A median of n-bit strings fff1; : : : ; fftg, where ffk has the binary representation ffk = ak(n\Gamma 1) : : : ak0, is a string ^ff = an\Gamma 1 : : : a0 whose bits aj for 0 ^ j ! n
agree with the majority of the bits akj for 1 ^ k ^ t. (If t is even and the bits
ffkj are half 0 and half 1, the median bit aj can be either 0 or 1.) For example, the
strings f0010; 0100; 0101; 1110g have two medians, 0100 and 0110, which we can denote
by 01\Lambda 0.

a) Find a simple way to describe the medians of Gt = fg(0); : : : ; g(t \Gamma  1)g, the first t

Gray binary strings, when 0 ! t ^ 2n.
b) Prove that if ff = an\Gamma 1 : : : a0 is such a median, and if ff0 = a0n\Gamma 1 : : : a00 is any

element of Gt with a0j 6= aj, then the string fi obtained from ff by changing aj to
a0j is also an element of Gt.

29. [M24 ] If integer values k are transmitted as n-bit Gray binary codes g(k) and
received with errors described by a bit pattern p = (pn\Gamma 1 : : : p0)2, the average numerical
error is

1
2n

2n\Gamma 1X

k=0

fi
fi
fi(g

[\Gamma 1](k) \Phi  p) \Gamma  k

fi
fi
fi;

assuming that all values of k are equally likely. Show that this sum is equal toP

2n\Gamma 1
k=0 j(k \Phi  p) \Gamma  kj=2

n, just as if Gray binary code were not used, and evaluate it

explicitly.
x 30. [M27 ] (Gray permutation.) Design a one-pass algorithm to replace the array

elements (X0; X1; X2; : : : ; X2n\Gamma 1) by (Xg(0); Xg(1); Xg(2); : : : ; Xg(2n\Gamma 1)), using only a
constant amount of auxiliary storage. Hint: Considering the function g(n) as a permutation of all nonnegative integers, show that the set

L = f0; 1; (10)2; (100)2; (100\Lambda )2; (100\Lambda 0)2; (100\Lambda 0\Lambda )2; : : : g
is the set of cycle leaders (the smallest elements of the cycles).

31. [HM35 ] (Gray fields.) Let fn(x) = g(rn(x)) denote the operation of reflecting
the bits of an n-bit binary string as in exercise 5 and then converting to Gray binary
code. For example, the operation f3(x) takes (001)2 7! (110)2 7! (010)2 7! (011)2 7!
(101)2 7! (111)2 7! (100)2 7! (001)2, hence all of the nonzero possibilities appear in

31

32 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
a single cycle. Therefore we can use f3 to define a field of 8 elements, with \Phi  as the
addition operator and with multiplication defined by the rule

f[j]3 (1) \Theta  f[k]3 (1) = f[j+k]3 (1) = f[j]3 (f[k]3 (1)):
The functions f2, f5, and f6 have the same nice property. But f4 does not, because
f4((1011)2) = (1011)2.

Find all n ^ 100 for which fn defines a field of 2n elements.

32. [M20 ] True or false: Walsh functions satisfy wk(\Gamma x) = (\Gamma 1)kwk(x).
x 33. [M20 ] Prove the Rademacher-to-Walsh law (17).

34. [M21 ] The Paley functions pk(x) are defined by

p0(x) = 1 and pk(x) = (\Gamma 1)b2xckpbk=2c(2x):
Show that pk(x) has a simple expression in terms of Rademacher functions, analogous
to (17), and relate Paley functions to Walsh functions.

35. [HM23 ] The 2n \Theta  2n Paley matrix Pn is obtained from Paley functions just as
the Walsh matrix Wn is obtained from Walsh functions. (See (20).) Find interesting
relations between Pn, Wn, and the Hadamard matrix Hn. Prove that all three matrices
are symmetric.

36. [21 ] Spell out the details of an efficient algorithm to compute the Walsh transform
(x0; : : : ; x2n\Gamma 1) of a given vector (X0; : : : ; X2n\Gamma 1).

37. [HM23 ] Let zkl be the location of the lth sign change in wk(x), for 1 ^ l ^ k and
0 ! zkl ! 1. Prove that jzkl \Gamma  l=(k + 1)j = O((log k)=k).

x 38. [M25 ] Devise a ternary generalization of Walsh functions.
x 39. [HM30 ] (J. J. Sylvester.) The rows of ( ab b\Gamma a) are orthogonal to each other and

have the same magnitude; therefore the matrix identity

( A B )

`

a2 + b2 0

0 a2 + b2

' `

A

B

'

=

( A B )

`

a b

b \Gamma a

' `

a b

b \Gamma a

' `

A

B

'

=

( Aa + Bb Ab \Gamma  Ba )

`

aA + bB

bA \Gamma  aB

'

implies the sum-of-two-squares identity (a2 + b2)(A2 + B2) = (aA + bB)2 + (bA \Gamma  aB)2.
Similarly, the matrix 0

B
B
@

a b c d

b \Gamma a d \Gamma c
d c \Gamma b \Gamma a

c \Gamma d \Gamma a b

1
C
C
A

leads to the sum-of-four-squares identity

(a2 +b2 +c2 +d2)(A2 +B2 +C2 +D2) = (aA+bB +cC +dD)2 +(bA\Gamma aB +dC \Gamma cD)2

+ (dA + cB \Gamma  bC \Gamma  aD)2 + (cA \Gamma  dB \Gamma  aC + bD)2:

a) Attach the signs of the matrix H3 in (21) to the symbols fa; b; c; d; e; f; g; hg,

obtaining a matrix with orthogonal rows and a sum-of-eight-squares identity.
b) Generalize to H4 and higher-order matrices.

x 40. [21 ] Would the text's five-letter word computation scheme produce correct answers also if the masks in step W2 were computed as mj = x ^ (25j \Gamma  1) for 0 ^ j ! 5?

32

7.2.1.1 GENERATING ALL n-TUPLES 33

41. [25 ] If we restrict the five-letter word problem to the most common 3000 words --
thereby eliminating ducky, duces, dunks, dinks, dinky, dices, dicey, dicky, dicks,
picky, pinky, punky, and pucks from (23) -- how many valid words can still be generated from a single pair?

42. [35 ] (M. L. Fredman.) Algorithm L uses \Theta (n log n) bits of auxiliary memory for
focus pointers as it decides what Gray binary bit aj should be complemented next.
On each step L3 it examines \Theta (log n) of the auxiliary bits, and it occasionally changes
\Omega (log n) of them.

Show that, from a theoretical standpoint, we can do better: The n-bit Gray binary
code can be generated by changing at most 2 auxiliary bits between visits. (We still
allow ourselves to examine O(log n) of the auxiliary bits on each step, so that we know
which of them should be changed.)

43. [47 ] Determine d(6), the number of 6-bit Gray codes.
44. [M35 ] How many of the delta sequences for n-bit Gray codes have the property
that exactly (a) one or (b) two of the coordinate names occur only twice? Express your
answers in terms of d(n \Gamma  1) and d(n \Gamma  2).

45. [M25 ] Show that the sequence d(n) has doubly exponential growth: There is a
constant A ? 1 such that d(n) = \Omega (A2n).

46. [HM48 ] Determine the asymptotic behavior of d(n)1=2

n

as n ! 1.

47. [M46 ] (Silverman, Vickers, and Sampson.) Let Sk = fg(0); : : : ; g(k \Gamma  1)g be
the first k elements of Gray binary code, and let H(k; v) be the number of Hamiltonian paths in Sk that begin with 0 and end with v. Prove or disprove: H(k; v) ^
H(k; g(k \Gamma  1)) for all v 2 Sk that are adjacent to g(k).

48. [36 ] Prove that d(n) ^ 4(n=2)2

n

if the conjecture in the previous exercise is true.

[Hint: Let d(n; k) be the number of n-bit Gray codes that begin with g(0) : : : g(k \Gamma  1);
the conjecture implies that d(n) ^ cn1 : : : cn(k\Gamma 1)d(n; k), where cnk is the number of
vertices adjacent to g(k \Gamma  1) in the n-cube but not in Sk.]

49. [20 ] Prove that for all n * 1 there is a 2n-bit Gray code in which vk+22n\Gamma 1 is the
complement of vk, for all k * 0.

x 50. [21 ] Find a construction like that of Theorem D but with l even.

51. [M24 ] Complete the proof of Corollary B to Theorem D.
52. [M20 ] Prove that if the transition counts of an n-bit Gray code satisfy c0 ^ c1 ^
\Delta  \Delta  \Delta  ^ cn\Gamma 1, we must have c0 + \Delta  \Delta  \Delta  + cj\Gamma 1 * 2j, with equality when j = n.

53. [M46 ] If the numbers (c0; : : : ; cn\Gamma 1) are even and satisfy the condition of the
previous exercise, is there always an n-bit Gray code with these transition counts?

54. [M20 ] (H. S. Shapiro, 1953.) Show that if a sequence of integers (a1; : : : ; a2n) contains only n distinct values, then there is a subsequence whose product ak+1ak+2 : : : al
is a perfect square, for some 0 ^ k ! l ^ 2n. However, this conclusion might not be
true if we disallow the case l = 2n.

55. [47 ] (F. Ruskey and C. Savage, 1993.) If (v0; : : : ; v2n\Gamma 1) is an n-bit Gray code,
the pairs f fv2k; v2k+1g j 0 ^ k ! 2n\Gamma 1 g form a perfect matching between the vertices
of even and odd parity in the n-cube. Conversely, does every such perfect matching
arise as "half" of some n-bit Gray code?

56. [M30 ] (E. N. Gilbert, 1958.) Say that two Gray codes are equivalent if their delta
sequences can be made equal by permuting the coordinate names, or by reversing the

33

34 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1
cycle and/or starting the cycle at a different place. Show that the 2688 different 4-bit
Gray codes fall into just 9 equivalence classes.

57. [32 ] Consider a graph whose vertices are the 2688 possible 4-bit Gray codes,
where two such Gray codes are adjacent if they are related by one of the following
simple transformations:

Before After Type 1 After Type 2 After Type 3 After Type 4
(Type 1 changes arise when the cycle can be broken into two parts and reassembled
with one part reversed. Types 2, 3, and 4 arise when the cycle can be broken into three
parts and reassembled after reversing 0, 1, or 2 of the parts. The parts need not have
equal size. Such transformations of Hamiltonian circuits are often possible.)

Write a program to discover which 4-bit Gray codes are transformable into each
other, by finding the connected components of the graph; restrict consideration to only
one of the four types at a time.

x 58. [21 ] Let ff be the delta sequence of an n-bit Gray code, and obtain fi from ff by

changing q occurrences of 0 to n, where q is odd. Prove that fifi is the delta sequence
of an (n + 1)-bit Gray code.

59. [22 ] The 5-bit Gray code of (30) is nonlocal in the sense that no 2t consecutive
elements belong to a single t-subcube, for 1 ! t ! n. Prove that nonlocal n-bit Gray
codes exist for all n * 5. [Hint: See the previous exercise.]

60. [20 ] Show that the run-length-bound function satisfies r(n + 1) * r(n).
61. [M30 ] Show that r(m + n) * r(m) + r(n) \Gamma  1 if (a) m = 2 and 2 ! r(n) ! 8; or
(b) m ^ n and r(n) ^ 2m\Gamma 3.

62. [46 ] Does r(8) = 6?
63. [30 ] (Luis Goddyn.) Prove that r(10) * 8.
x 64. [HM35 ] (L. Goddyn and P. Gvozdjak.) An n-bit Gray stream is a sequence of

permutations (oe0; oe1; : : : ; oel\Gamma 1) where each oek is a permutation of the vertices of the
n-cube, taking every vertex to one of its neighbors.

a) Suppose (u0; : : : ; u2m\Gamma 1) is an m-bit Gray code and (oe0; oe1; : : : ; oe2m\Gamma 1) is an n-bit

Gray stream. Let v0 = 0 : : : 0 and vk+1 = vkoek, where oek = oek mod 2m if k * 2m.
Under what conditions is the sequence

W = (u0v0; u0v1; u1v1; u1v2; : : : ; u2m+n\Gamma 1\Gamma 1v2m+n\Gamma 1\Gamma 1; u2m+n\Gamma 1\Gamma 1v2m+n\Gamma 1 )
an (m + n)-bit Gray code?
b) Show that if m is sufficiently large, there is an n-bit Gray stream satisfying the

conditions of (a) for which all run lengths of the sequence (v0; v1; : : : ) are * n \Gamma  2.
c) Apply these results to prove that r(n) * n \Gamma  O(log n).

65. [30 ] (Brett Stevens.) In Samuel Beckett's play Quad, the stage begins and ends
empty; n actors enter and exit one at a time, running through all 2n possible subsets,
and the actor who leaves is always the one whose previous entrance was earliest. When
n = 4, as in the actual play, some subsets are necessarily repeated. Show, however,
that there is a perfect pattern with exactly 2n entrances and exits when n = 5.

34

7.2.1.1 GENERATING ALL n-TUPLES 35

66. [46 ] Is there a perfect Beckett-Gray pattern for 8 actors?
67. [20 ] Sometimes it is desirable to run through all n-bit binary strings by changing
as many bits as possible from one step to the next, for example when testing a physical
circuit for reliable behavior in worst-case conditions. Explain how to traverse all binary
n-tuples in such a way that each step changes n or n \Gamma  1 bits, alternately.

68. [21 ] Peter Q. Perverse decided to construct an anti-Gray ternary code, in which
each n-trit number differs from its neighbors in every digit position. Is such a code
possible for all n?

x 69. [M25 ] Modify the definition of Gray binary code (7) by letting

h(k) = (: : : (b6 \Phi  b5)(b5 \Phi  b4)(b4 \Phi  b3 \Phi  b2 \Phi  b0)(b3 \Phi  b0)(b2 \Phi  b1 \Phi  b0)b1)2;
when k = (: : : b5b4b3b2b1b0)2.

a) Show that the sequence h(0), h(1), : : : , h(2n \Gamma  1) runs through all n-bit numbers

in such a way that exactly 3 bits change each time, when n ? 3.
b) Generalize this rule to obtain sequences in which exactly t bits change at each

step, when t is odd and n ? t.

70. [21 ] How many monotonic n-bit Gray paths exist for n = 5 and n = 6?
71. [M22 ] Derive (45), the recurrence that defines the Savage-Winkler permutations.
72. [20 ] What is the Savage-Winkler path from 00000 to 11111?
x 73. [32 ] Design an efficient algorithm to construct the delta sequence of an n-bit

monotonic Gray path.

74. [M25 ] (Savage and Winkler.) How far apart can adjacent vertices of the n-cube
be, in a monotonic Gray path?

75. [32 ] Find all 5-bit Gray paths v0, : : : , v31 that are trend-free, in the sense thatP

31
k=0 k(\Gamma 1)

vkj = 0 in each coordinate position j.

76. [M25 ] Prove that trend-free n-bit Gray paths exist for all n * 5.
77. [21 ] Modify Algorithm H in order to visit mixed-radix n-tuples in modular Gray
order.

78. [M26 ] Prove the conversion formulas (50) and (51) for reflected mixed-radix Gray
paths, and derive analogous formulas for the modular case.

x 79. [M22 ] When is the last n-tuple of the (a) reflected (b) modular mixed-radix Gray

path adjacent to the first?

80. [M21 ] Let (a0; b0), (a1; b1), : : : , (am2\Gamma 1; bm2\Gamma 1) be the 2-digit m-ary modular
Gray code. Show that, if m ? 2, every edge (x; y)\Gamma \Gamma \Gamma  (x; (y + 1) mod m) and (x; y) \Gamma \Gamma \Gamma 
((x + 1) mod m; y) occurs in one of the two cycles

(a0; b0)\Gamma \Gamma \Gamma  (a1; b1)\Gamma \Gamma \Gamma  \Delta  \Delta  \Delta \Gamma \Gamma \Gamma  (am2\Gamma 1; bm2\Gamma 1)\Gamma \Gamma \Gamma  (a0; b0);
(b0; a0)\Gamma \Gamma \Gamma  (b1; a1)\Gamma \Gamma \Gamma  \Delta  \Delta  \Delta \Gamma \Gamma \Gamma  (bm2\Gamma 1; am2\Gamma 1)\Gamma \Gamma \Gamma  (b0; a0):

x 81. [M25 ] (G. Ringel, 1956.) Use the previous exercise to deduce that there exist four

8-bit Gray codes that, together, cover all edges of the 8-cube.

82. [M46 ] Can four balanced 8-bit Gray codes cover all edges of the 8-cube?
x 83. [25 ] (Howard L. Dyckman.) Fig. 17 shows a fascinating puzzle called Loony Loop

or the Gordian Knot, in which the object is to remove a flexible cord from the rigid

35

36 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

Fig. 17. The Loony Loop puzzle.
loops that surround it. Show that the solution to this puzzle is inherently related to
the reflected Gray ternary path.

x 84. [M25 ] (Dana Richards.) If \Gamma  = (ff0; : : : ; fft\Gamma 1) is a sequence of t strings of length n

and \Gamma 0 = (ff00; : : : ; ff0t0\Gamma 1) is a sequence of t0 strings of length n0, the boustrophedon
product \Gamma \Theta \Gamma 0 is the sequence of tt0 strings of length n + n0 that begins

(ff0ff00; : : : ; ff0ff0t0\Gamma 1; ff1ff0t0\Gamma 1; : : : ; ff1ff00; ff2ff00; : : : ; ff2ff0t0\Gamma 1; ff3ff0t0\Gamma 1; : : : )
and ends with fft\Gamma 1ff00 if t is even, fft\Gamma 1ff0t0\Gamma 1 if t is odd. For example, the basic definition
of Gray binary code in (5) can be expressed in this notation as \Gamma n = (0; 1)\Theta \Gamma n\Gamma 1 when
n ? 0. Prove that the operation \Theta  is associative, hence \Gamma m+n = \Gamma m \Theta \Gamma n.

x 85. [26 ] Define an infinite Gray path that runs through all possible nonnegative

integer n-tuples (a1; : : : ; an) in such a way that max(a1; : : : ; an) ^ max(a01; : : : ; a0n)
when (a1; : : : ; an) is followed by (a01; : : : ; a0n).

86. [27 ] Continuing the previous exercise, define an infinite Gray path that runs
through all integer n-tuples (a1; : : : ; an), in such a way that max(ja1j; : : : ; janj) ^
max(ja01j; : : : ; ja0nj) when (a1; : : : ; an) is followed by (a01; : : : ; a0n).

x 87. [25 ] After Algorithm K has terminated in step K4, what would happen if we

immediately restarted it in step K2?

x 88. [25 ] (Gray code for Morse code.) The Morse code words of length n (exercise

4.5.3-32) are strings of dots and dashes, where n is the number of dots plus twice the
number of dashes.

a) Show that it is possible to generate all Morse code words of length n by successively

changing a dash to two dots or vice versa. For example, the path for n = 3 must
be q , q q q, q or its reverse.
b) What string follows q q q q q in your sequence for n = 15?

89. [26 ] For what values of n can the Morse code words be arranged in a cycle, under
the ground rules of exercise 88? [Hint: The number of code words is Fn+1.]

x 90. [34 ] Design a loopless algorithm to visit all binary n-tuples (a1; : : : ; an) such that

a1 ^ a2 * a3 ^ a4 * \Delta  \Delta  \Delta  . (The number of such n-tuples is Fn+2.)

91. [M30 ] Is there an infinite sequence \Phi n whose first mn elements form an m-ary de
Bruijn cycle, for all m? (The case n = 2 is solved in (54).)

x 92. [M28 ] Prove that Algorithm R outputs a de Bruijn cycle as advertised.

93. [22 ] What is the output of Algorithm D when m = 5, n = 1, r = 3, and both f()
and g() are the trivial cycles 01234 01234 01 : : :?

x 94. [M23 ] Suppose an infinite sequence a0 a1a2 : : : of period p is interleaved with an

infinite sequence b0b1b2 : : : of period q to form the infinite cyclic sequence

c0 c1c2 c3 c4 c5 : : : = a0 b0a1b1a2 b2 : : : :

36

7.2.1.1 GENERATING ALL n-TUPLES 37

a) Under what circumstances does c0 c1c2 : : : have period pq? (The "period" of a

sequence a0 a1a2 : : : , for the purposes of this exercise, is the smallest integer p ? 0
such that ak = ak+p for all k * 0.)
b) Which 2n-tuples would occur as consecutive outputs of Algorithm D if step D6

were changed to say simply "If t0 = n and x0 ! r, go to D4"?
c) Prove that Algorithm D outputs a de Bruijn cycle as advertised.

x 95. [M23 ] Suppose a family of coroutines has been set up to generate a de Bruijn

cycle of length mn using Algorithms R and D, based recursively on simple coroutines
for the base case n = 2.

a) How many coroutines of each type will there be?
b) What is the maximum number of coroutine activations needed to get one top-level

digit of output?

96. [M29 ] The purpose of this exercise is to analyze the de Bruijn cycles constructed
by Algorithms R and D in the important special case m = 2. Let fn(k) be the (k + 1)st
bit of the 2n-cycle, so that fn(k) = 0 for 0 ^ k ! n. Also let jn be the index such that
0 ^ jn ! 2n and fn(k) = 1 for jn ^ k ! jn + n.

a) Write out the cycles (fn(0) : : : fn(2n \Gamma  1)) for n = 2, 3, 4, and 5.
b) Prove that, for all even values of n, there is a number ffin = \Sigma 1 such that we have

fn+1(k) j

ae

\Sigma fn(k); if 0 ! k ^ jn or 2n + jn ! k ^ 2n+1,

1 + \Sigma fn(k + ffin); if jn ! k ^ 2n+ jn,

where the congruence is modulo 2. (In this formula \Sigma f stands for the summation
function \Sigma f(k) =

Pk\Gamma 1

j=0 f(j).) Hence jn+1 = 2

n\Gamma  ffin when n is even.

c) Let (cn(0)cn(1) : : : cn(22n\Gamma  5)) be the cycle produced when the simplified version

of Algorithm D in exercise 94(b) is applied to fn(). Where do the (2n \Gamma  1)-tuples
12n\Gamma 1 and (01)n\Gamma 10 occur in this cycle?
d) Use the results of (c) to express f2n(k) in terms of fn().

e) Find a (somewhat) simple formula for jn as a function of n.

97. [M34 ] Continuing the previous exercise, design an efficient algorithm to compute
fn(k), given n * 2 and k * 0.

x 98. [M23 ] Exploit the technology of the previous exercises to design an efficient

algorithm that locates any given n-bit string in the cycle (fn(0)fn(1) : : : fn(2n\Gamma  1)).

99. [40 ] Do the de Bruijn cycles of exercise 96 provide a useful source of pseudorandom
bits when n is large?

100. [M20 ] Use Eq. (59) to prove Fermat's theorem that mp j m (modulo p).
101. [17 ] According to formula (60), about 1=n of all n-letter words are prime. How
many of the 5757 five-letter GraphBase words are prime? Which of them is the smallest
nonprime? The largest prime?

x 102. [M30 ] (Unique factorization of strings into nonincreasing primes.)

a) Prove that if * and *0 are prime, then **0 is prime if * ! *0.
b) Consequently every string ff can be written in the form

ff = *1*2 : : : *t; *1 * *2 * \Delta  \Delta  \Delta  * *t; where each *j is prime.
c) In fact, only one such factorization is possible. Hint: Show that *t must be the

lexicographically smallest nonempty suffix of ff.
d) True or false: *1 is the longest prime prefix of ff.

e) What are the prime factors of 3141592653589793238462643383279502884197?

37

38 COMBINATORIAL ALGORITHMS (F2A) 7.2.1.1

103. [HM28 ] Deduce the number of m-ary primes of length n from the unique factorization theorem in the previous exercise.

104. [M31 ] Let ff be a preprime of length n.

a) Show that if the final letter of ff is increased, the resulting string is prime.
b) If ff has been factored as in exercise 102, show that it is the n-extension of *1.

c) Furthermore ff cannot be the n-extension of two different primes.

x 105. [M30 ] By reverse-engineering Algorithm F, design an algorithm that visits all

m-ary primes and preprimes in decreasing order.

106. [HM30 ] Analyze the running time of Algorithm F.
107. [M35 ] Let *1 ! \Delta  \Delta  \Delta  ! *t be the m-ary prime strings whose lengths divide n, and
let a1 : : : an be any m-ary string. The object of this exercise is to prove that a1 : : : an
appears in *1 : : : *t*1*2; hence *1 : : : *t is a de Bruijn cycle (since it has length mn).
For convenience we may assume that m = 10 and that strings correspond to decimal
numbers; the same arguments will apply for arbitrary m * 2.

a) Show that if a1 : : : an = fffi is distinct from all its cyclic shifts, and if fiff = *k is

prime, then fffi is a substring of *k*k+1, unless ff = 9j for some j * 1.
b) Where does fffi appear in *1 : : : *t if fiff is prime and ff consists of all 9s? Hint:

Show that if an+1\Gamma j : : : an = 9l in step F2 for some l ? 0, and if j is not a divisor
of n, the previous step F2 had an\Gamma l : : : an = 9l+1.
c) Now consider n-tuples of the form (fffi)d, where d ? 1 is a divisor of n and

fiff = *k is prime.
d) Identify the positions of 899135, 997879, 913131, 090909, 909090, and 911911

when n = 6.

108. [M22 ] An m-ary de Bruijn torus of size m2 \Theta  m2 for 2 \Theta  2 windows is a matrix
of m-ary digits aij such that each of the m4 submatrices

`

aij ai(j+1)

a(i+1)j a(i+1)(j+1)

'

; 0 ^ i; j ! m2

is different, where subscripts wrap around modulo m2. Thus every possible m-ary 2\Theta 2
submatrix occurs exactly once; Ian Stewart [Game, Set, and Math (Oxford: Blackwell,
1989), Chapter 4] has therefore called it an m-ary ourotorus. For example,

0

B
B
@

0 0 1 0
0 0 0 1
0 1 1 1
1 0 1 1

1
C
C
A

is a binary ourotorus; indeed, it is essentially the only such matrix when m = 2, except
for shifting and/or transposition.

Consider the infinite matrix A whose entry in row i = (: : : a2a1a0)2 and column
j = (: : : b2b1b0)2 is aij = (: : : c2c1c0)2, where

c0 = (a0 \Phi  b0)(a1 \Phi  b1) \Phi  b1;
ck = (a2ka0 \Phi  b2k)b0 \Phi  (a2k+1a0 \Phi  b2k+1)(b0 \Phi  1); for k ? 0:

Show that the upper left 22n \Theta  22n submatrix of A is a 2n-ary ourotorus for all n * 0.

109. [M25 ] Continuing the previous exercise, construct m-ary ourotoruses for all m.

38

7.2.1.1 GENERATING ALL n-TUPLES 39

110. [20 ] We can obtain the number 100 in twelve ways by inserting + and \Gamma  signs
into the sequence 123456789; for example, 100 = 1 + 23 \Gamma  4 + 5 + 6 + 78 \Gamma  9 =
123 \Gamma  45 \Gamma  67 + 89 = \Gamma 1 + 2 \Gamma  3 + 4 + 5 + 6 + 78 + 9.

a) What is the smallest positive integer that cannot be represented in such a way?
b) Consider also inserting signs into the 10-digit sequence 9876543210.

x 111. [25 ] Continuing the previous exercise, how far can we go by inserting signs into

12345678987654321? For example, 100 = \Gamma 1234 \Gamma  5 \Gamma  6 + 7898 \Gamma  7 \Gamma  6543 \Gamma  2 \Gamma  1.

39
ANSWERS TO EXERCISES

All that heard him were astonished

at his understanding and answers.

-- Luke 2:47

SECTION 7.2.1.1

1. Let mj = uj \Gamma  lj + 1, and visit (a1 + l1; : : : ; an + ln) instead of visiting (a1; : : : ; an)
in Algorithm M. Or, change `aj  0' to `aj  lj' and `aj = mj \Gamma  1' to `aj = uj' in
that algorithm, and set l0  0, u0  1 in step M1.

2. (0; 0; 1; 2; 3; 0; 2; 7; 0; 9).
3. Step M4 is performed m1m2 : : : mk times when j = k; therefore the total isP

n
k=0

Qk

j=1 mj = m1 : : : mn(1 + 1=mn + 1=mnmn\Gamma 1 + \Delta  \Delta  \Delta  + 1=mn : : : m1). If all mj
are 2 or more, this is less than 2m1 : : : mn. [Thus, we should keep in mind that fancy

Gray-code methods, which change only one digit per visit, actually reduce the total
number of digit changes by at most a factor of 2.]

4. N1. [Initialize.] Set aj  mj \Gamma  1 for 0 ^ j ^ n, where m0 = 2.

N2. [Visit.] Visit the n-tuple (a1; : : : ; an).
N3. [Prepare to subtract one.] Set j  n.
N4. [Borrow if necessary.] If aj = 0, set aj  mj \Gamma  1, j  j \Gamma  1, and repeat this

step.

N5. [Decrease, unless done.] If j = 0, terminate the algorithm. Otherwise set

aj  aj \Gamma  1 and go back to step N2.

5. Bit reflection is easy on a machine like MMIX, but on other computers we can
proceed as follows:

R1. [Initialize.] Set j  k  0.
R2. [Swap.] Interchange A[j + 1] $ A[k + 2n\Gamma 1]. Also, if j ? k, interchange

A[j] $ A[k] and A[j + 2n\Gamma 1 + 1] $ A[k + 2n\Gamma 1 + 1].

R3. [Advance k.] Set k  k + 2, and terminate if k * 2n\Gamma 1.
R4. [Advance j.] Set h  2n\Gamma 2. If j * h, repeatedly set j  j \Gamma  h and h  h=2

until j ! h. Then set j  j + h. (Now j = (b0 : : : bn\Gamma 1)2 if k = (bn\Gamma 1 : : : b0)2.)
Return to R2.

6. If g((0bn\Gamma 1 : : : b1b0)2) = (0(bn\Gamma 1) : : : (b2 \Phi b1)(b1 \Phi b0))2 then g((1bn\Gamma 1 : : : b1b0)2) =
2n + g((0bn\Gamma 1 : : : b1b0)2) = (1(bn\Gamma 1) : : : (b2 \Phi  b1)(b1 \Phi  b0))2, where b = b \Phi  1.

40

40

7.2.1.1 ANSWERS TO EXERCISES 41

7. To accommodate 2r sectors one can use g(k) for 2n \Gamma  r ^ k ! 2n + r, where
n = dlg re, because g(2n \Gamma  r) \Phi  g(2n + r \Gamma  1) = 2n by (5). [G. C. Tootill, Proc. IEE
103, Part B Supplement (1956), 434.] See also exercise 26.

8. Use Algorithm G with n  n \Gamma  1 and include the parity bit a1. (This yields g(0),
g(2), g(4), : : : .)

9. Replace the rightmost ring, since *(1011000) is odd.
10. An + Bn = g[\Gamma 1](2n \Gamma  1) = b2n+1=3c and An = Bn + n. Hence An = b2n=3 + n=2c
and Bn = b2n=3 \Gamma  n=2c.

Historical notes: The early Japanese mathematician Yoriyuki Arima (1714-1783)
treated this problem in his Sh_uki Sanp_o (1769), Problem 44, observing that the nring puzzle reduces to an (n \Gamma  1)-ring puzzle after a certain number of steps. Let
Cn = An \Gamma  An\Gamma 1 = Bn \Gamma  Bn\Gamma 1 + 1 be the number of rings removed during this
reduction. Arima noticed that Cn = 2Cn\Gamma 1 \Gamma  [n even]; thus he could compute An =
C1 + C2 + \Delta  \Delta  \Delta  + Cn for n = 9 without actually knowing the formula Cn = d2n\Gamma 1=3e.

More than two centuries earlier, Cardano had already mentioned the "complicati
annuli" in his De Subtilitate Libri XXI (Nuremberg: 1550), Book 15. He wrote that
they are "useless yet admirably subtle," stating erroneously that 95 moves are needed
to remove seven rings and 95 more to put them back. John Wallis devoted seven
pages to this puzzle in the Latin edition of his Algebra 2 (Oxford: 1693), Chapter 111,
presenting detailed but nonoptimum methods for the nine-ring case. He included the
operation of sliding a ring through the bar as well as putting it on or off, and he hinted
that shortcuts were available, but he did not attempt to find a shortest solution.

11. The solution to Sn = Sn\Gamma 2 + 1 + Sn\Gamma 2 + Sn\Gamma 1 when S1 = S2 = 1 is Sn =
2n\Gamma 1 \Gamma  [n even]. [Math. Quest. Educational Times 3 (1865), 66-67.]

12. (a) The theory of n \Gamma  1 Chinese rings proves that Gray binary code yields the
compositions in a convenient order (4, 31, 211, 22, 112, 1111, 121, 13):

A1. [Initialize.] Set t  0, j  1, s1  n. (We assume that n ? 1.)
A2. [Visit.] Visit s1 : : : sj. Then set t  1 \Gamma  t, and go to A4 if t = 0.
A3. [Odd step.] If sj ? 1, set sj  sj \Gamma  1, sj+1  1, j  j + 1; otherwise set

j  j \Gamma  1 and sj  sj + 1. Return to A2.

A4. [Even step.] If sj\Gamma 1 ? 1, set sj\Gamma 1  sj\Gamma 1 \Gamma  1, sj+1  sj, sj  1, j  j + 1;

otherwise set j  j \Gamma  1, sj  sj+1, sj\Gamma 1  sj\Gamma 1 + 1 (but terminate if
j \Gamma  1 = 0). Return to A2.

(b) Now the order 4, 13, 112, 22, 211, 1111, 121, 31 is most convenient:
B1. [Initialize.] Set t  0, p0  n. (We assume that n ? 1.)
B2. [Visit.] Visit p0 : : : pn\Gamma 1. Then set t  1 \Gamma  t, and go to B4 if t = 0.
B3. [Odd step.] If p0 = 1, set p0  p1; otherwise set p1  p0 and p0  1. Return

to step B2.

B4. [Even step.] Set j  p0. If pj = j + 1, set pj  pj+1 (but terminate if

j = n \Gamma  1); otherwise set pj+1  pj, pj  j + 1. Return to B2.

These algorithms [see J. Misra, ACM Trans. Math. Software 1 (1975), 285] are loopless
even in their initialization steps.

13. In step A1, also set C  1. In step A3, set C  sjC if sj ? 1, otherwise
C  C=(sj\Gamma 1 +1). In step A4, set C  sj\Gamma 1C if sj\Gamma 1 ? 1, otherwise C  C=(sj\Gamma 2 +1).

41

42 ANSWERS TO EXERCISES 7.2.1.1
Similar modifications apply to steps B1, B3, B4. Sufficient precision is needed to
accommodate the value C = n! for the composition 1 : : : 1; we are stretching the
definition of looplessness by assuming that arithmetic operations take unit time.

14. S1. [Initialize.] Set j  0.

S2. [Visit.] Visit the string a1 : : : aj.
S3. [Lengthen.] If j ! n, set j  j + 1, aj  0, and return to S2.
S4. [Increase.] If aj ! mj \Gamma  1, set aj  aj + 1 and return to S2.
S5. [Shorten.] Set j  j \Gamma  1, and return to S4 if j ? 0.
15. T1. [Initialize.] Set j  0.

T2. [Even visit.] If j is even, visit the string a1 : : : aj.
T3. [Lengthen.] If j ! n, set j  j + 1, aj  0, and return to T2.
T4. [Odd visit.] If j is odd, visit the string a1 : : : aj.
T5. [Increase.] If aj ! mj \Gamma  1, set aj  aj + 1 and return to T2.
T6. [Shorten.] Set j  j \Gamma  1, and return to T4 if j ? 0.

This algorithm is loopless, although it may appear at first glance to contain loops,
because four steps separate consecutive visits. The basic idea is related to exercise
2.3.1-5 and to "prepostorder" traversal (exercise 7.2.1.3-00).

16. Suppose LINK(j\Gamma 1:b) = j:(b \Phi  aj) for 1 ^ j ^ n, and LINK(n:b) = \Lambda . These links
represent (b1; : : : ; bn) if and only if g(b1 : : : bn) = a1 : : : an, so we can use a loopless
Gray binary generator to achieve the desired result.

17. Put the concatenation of 3-bit codes (g(j); g(k)) in row j and column k, for 0 ^
j; k ! 8. [It is not difficult to prove that this is essentially the only solution, except
for permuting and/or complementing coordinates and/or rotating rows, because the
coordinate that changes when moving north or south depends only on the row, and a
similar statement applies to columns. Karnaugh's isomorphism between the 4-cube and
the 4 \Theta  4 torus can be traced back to The Design of Switching Circuits by W. Keister,
A. E. Ritchie, and S. H. Washburn (1951), page 174. Incidentally, Keister went on to
design an ingenious variant of Chinese rings called SpinOut, and a generalization called
The Hexadecimal Puzzle, U.S. Patents 3637215-3637216 (1972).]

18. Use 2-bit Gray code to represent the digits uj = (0; 1; 2; 3) respectively as the bit
pairs u02j\Gamma 1u02j = (00; 01; 11; 10). [C. Y. Lee introduced his metric in IEEE Trans. IT-4
(1958), 77-82. A similar m=2-bit encoding works for even values of m; for example,
when m = 8 we can represent (0; 1; 2; 3; 4; 5; 6; 7) by (0000; 0001; 0011; 0111; 1111; 1110;
1100; 1000). But such a scheme leaves out some of the binary patterns when m ? 4.]

19. (a) A modular Gray quaternary algorithm needs slightly less computation than
Algorithm M, but it doesn't matter because 256 is so small. The result is z80 + z81 +
z82 + z83 + 14(z40z42 + z41z43) + 56z0z1z2z3(z20 + z22)(z21 + z23).

(b) Replacing (z0; z1; z2; z3) by (1; z; z2; z) gives 1 + 112z6 + 30z8 + 112z10 + z16;
thus all of the nonzero Lee weights are * 6. Now use the construction in the previous
exercise to convert each (u0; u1; u2; u3; u4; u5; u6; u1) into a 16-bit number.

20. Recover the quaternary vector (u0; u1; u2; u3; u4; u5; u6; u1) from u0, and use Algorithm 4.6.1D to find the remainder of u0 + u1x + \Delta  \Delta  \Delta  + u6x6 divided by g(x), mod 4;
that algorithm can be used in spite of the fact that the coefficients do not belong to a
field, because g(x) is monic. Express the remainder as xj + 2xk (modulo g(x) and 4),
and let d = (k \Gamma  j) mod 4, s = (u0 + \Delta  \Delta  \Delta  + u6 + u1) mod 4.

42

7.2.1.1 ANSWERS TO EXERCISES 43

Case 1, s = 1: If k = 1, the error was xj (in other words, the correct vector has
uj  (uj \Gamma  1) mod 4); otherwise there were three or more errors.

Case 2, s = 3: If j = k the error was xj; otherwise * 3 errors occurred.
Case 3, s = 0: If j = k = 1, no errors were made; if j = 1 and k ! 1,
at least four errors were made. Otherwise the errors were xa \Gamma  xb, where a = (j +
(1; 3; 6; 1; 5; 4; 2; 0)) mod 7 according as d = (0; 1; 2; 3; 4; 5; 6; 1), and b = (j+2d) mod 7.

Case 4, s = 2: If j = 1 the errors were 2xk. Otherwise the errors were

xj + x1, if k = 1;
\Gamma xj \Gamma  x1, if d = 0;

xa + xb, if d 2 f1; 2; 4g; a = (j \Gamma  3d) mod 7; b = (j \Gamma  2d) mod 7;
\Gamma xa \Gamma  xb, if d 2 f3; 5; 6g; a = (j \Gamma  3d) mod 7; b = (j \Gamma  d) mod 7:

Given u0 = (1100100100001111)2, we have u = (2; 0; 3; 1; 0; 0; 2; 2) and 2 + 3x2 +
x3 + 2x6 j 1 + 3x + 3x2 j x5 + 2x6; also s = 2. Thus the errors are x2 + x3,
and the nearest errorfree codeword is (2; 0; 2; 0; 0; 0; 2; 2). Algorithm 4.6.1D tells us
that 2 + 2x2 + 2x6 j (2 + 2x + 2x3)g(x) (modulo 4); so the eight information bits are
(11110011)2, corresponding to (v0; v1; v2; v3) = (2; 2; 0; 2). [A more intelligent algorithm
would also say, "Aha: The first 16 bits of ss."]

For generalizations to other efficient coding schemes based on quaternary vectors,
see the classic paper by Hammons, Kumar, Calderbank, Sloane, and Sol'e, IEEE Trans.
IT-40 (1994), 301-319.

21. (a) C(ffl) = 1, C(0ff) = C(1ff) = C(ff), and C(\Lambda ff) = 2C(ff) \Gamma  [10 : : : 0 2 ff].
Iterating this recurrence gives C(ff) = 2t \Gamma  2t\Gamma 1et \Gamma  2t\Gamma 2et\Gamma 1 \Gamma  \Delta  \Delta  \Delta  \Gamma  20e1, where
ej = [10 : : : 0 2 ffj ] and ffj is the suffix of ff following the jth asterisk. In the example
we have ff1 = \Lambda 10\Lambda \Lambda 0\Lambda , ff2 = 10\Lambda \Lambda 0\Lambda , : : : , ff5 = ffl; thus e1 = 0, e2 = 1, e3 = 1, e4 = 0,
and e5 = 1 (by convention), hence C(\Lambda \Lambda 10\Lambda \Lambda 0\Lambda ) = 25 \Gamma  24 \Gamma  22 \Gamma  21 = 10.

(b) We may remove trailing asterisks so that t = t0. Then et = 1 implies et\Gamma 1 =
\Delta  \Delta  \Delta  = e1 = 0. [The case C(ff) = 2t0\Gamma 1 occurs if and only if ff ends in 10j\Lambda k.]

(c) To compute the sum of C(ff) over all t-subcubes, note that

\Gamma n

t

\Delta 

clusters begin at

the n-tuple 0 : : : 0, and

\Gamma n\Gamma 1

t

\Delta 

begin at each succeeding n-tuple (namely one cluster for

each t-subcube containing that n-tuple and specifying the bit that changed). Thus the
average is (

\Gamma n

t

\Delta 

+ (2n \Gamma  1)

\Gamma n\Gamma 1

t

\Delta 

)=2n\Gamma t

\Gamma n

t

\Delta 

= 2t(1 \Gamma  t=n) + 2t\Gamma n(t=n). [The formula in (c)

holds for any n-bit Gray path, but (a) and (b) are specific to the reflected Gray binary
code. These results are due to C. Faloutsos, IEEE Trans. SE-14 (1988), 1381-1393.]

22. Let ff\Lambda j and fi\Lambda k be consecutive lieves of a Gray binary trie, where ff and fi are
binary strings and j ^ k. Then the last k \Gamma  j bits of ff are a string ff0 such that ff
and fiff0 are consecutive elements of Gray binary code, hence adjacent. [Interesting
applications of this property to cube-connected message-passing concurrent computers
are discussed in A VLSI Architecture for Concurrent Data Structures by William J.
Dally (Kluwer, 1987), Chapter 3.]

23. 2j = g(k) \Phi  g(l) = g(k \Phi  l) implies that l = k \Phi  g[\Gamma 1](2j) = k \Phi  (2j+1 \Gamma  1). In
other words, if k = (bn\Gamma 1 : : : b0)2 we have l = (bn\Gamma 1 : : : bj+1bj : : : b0)2.

24. Defining g(k) = k \Phi  bk=2c as usual, we find g(k) = g(\Gamma 1 \Gamma  k); hence there are two
2-adic integers k such that g(k) has a given 2-adic value l. One of them is even, the
other is odd. We can conveniently define g[\Gamma 1] to be the solution that is even; then
(8) is replaced by bj = aj\Gamma 1 \Phi  \Delta  \Delta  \Delta  \Phi  a0, for j * 0. For example, g[\Gamma 1](1) = \Gamma 2 by this
definition; when l is a normal integer, the "sign" of g[\Gamma 1](l) is the parity of l.

43

44 ANSWERS TO EXERCISES 7.2.1.1
25. Let p = k \Phi  l; exercise 7.1-00 tells us that 2blg pc+1 \Gamma  p ^ jk \Gamma  lj ^ p. We
have *(g(p)) = *(g(k) \Phi  g(l)) = t if and only if there are positive integers j1, : : : , jt
such that p = (1j10j21j3 : : : (0 or 1)jt)2. The largest possible p ! 2n occurs when
j1 = n + 1 \Gamma  t and j2 = \Delta  \Delta  \Delta  = jt = 1, yielding p = 2n \Gamma  d2t=3e. The smallest possible
2blg pc+1 \Gamma  p = (1j20j3 : : : (1 or 0)jt)2 + 1 occurs when j2 = \Delta  \Delta  \Delta  = jt = 1, yielding
p = d2t=3e. [C. K. Yuen, IEEE Trans. IT-20 (1974), 668; S. R. Cavior, IEEE Trans.
IT-21 (1975), 596.]

26. Let N = 2nt + \Delta  \Delta  \Delta  + 2n1 where nt ? \Delta  \Delta  \Delta  ? n1 * 0; also, let \Gamma n be any Gray code
for f0; 1; : : : ; 2n\Gamma  1g that begins at 0 and ends at 1, except that \Gamma 0 is simply 0. Use

\Gamma Rnt; 2nt + \Gamma nt\Gamma 1; : : : ; 2nt +\Delta  \Delta  \Delta + 2n3 + \Gamma Rn2; 2nt + \Delta  \Delta  \Delta + 2n2 + \Gamma n1; if t is even;

\Gamma nt; 2nt + \Gamma Rnt\Gamma 1; : : : ; 2nt + \Delta  \Delta  \Delta +2n3 + \Gamma Rn2; 2nt + \Delta  \Delta  \Delta +2n2 + \Gamma n1; if t is odd.
27. In general, if k = (bn\Gamma 1 : : : b0)2, the (k + 1)st largest element of Sn is equal to

1/(2 \Gamma  (\Gamma 1)an\Gamma 1/(2 \Gamma  \Delta  \Delta  \Delta  =(2 \Gamma  (\Gamma 1)a1=(2 \Gamma  (\Gamma 1)a0 )) : : :));
corresponding to the sign pattern g(k) = (an\Gamma 1 : : : a0)2. Thus we can compute any element of Sn in O(n) steps, given its rank. Setting k = 2100 \Gamma 1010 and n = 100 yields the
answer 373065177=1113604409. [Whenever f(x) is a positive and monotonic function,
the 2n elements f(\Sigma f(: : : \Sigma f(\Sigma x) : : :)) are ordered according to Gray binary code, as
observed by H. E. Salzer, CACM 16 (1973), 180. In this particular case there is, however, another way to get the answer, because we also have Sn = ==2; \Sigma 2; : : : ; \Sigma 2; \Sigma 1==
using the notation of Section 4.5.3; continued fractions in this form are ordered by
complementing alternate bits of k.]

28. (a) As t = 1, 2, : : : , bit aj of median(Gt) runs through the periodic sequence

0; : : : ; 0; \Lambda ; 1; : : : ; 1; \Lambda ; 0; : : : ; 0; \Lambda ; : : :
with asterisks at every 21+jth step. Thus the strings that correspond to the binary
representations of b(t \Gamma  1)=2c and bt=2c are medians. And those strings are in fact
"extreme" cases, in the sense that all medians agree with the common bits of b(t\Gamma 1)=2c
and bt=2c, hence asterisks appear where they disagree. For example, when t = 100 =
(01100100)2 and n = 8, we have median(G100) = 001100\Lambda \Lambda .

(b) If ff is g(p) and fi is g(q) in Gray binary, we have p = (pn\Gamma 1 : : : p0)2 and
q = (pn\Gamma 1 : : : pj+1pj : : : p0)2, where pj+1 \Phi  pj = a0j 6= aj. By (a), either t or t \Gamma  1 lies
in (an\Gamma 1 : : : a0\Lambda )2. Now if pj = 1, clearly q ! p ! t. And if pj = 0 we have pj+1 = aj;
hence p ! t implies q ! t. [See A. J. Bernstein, K. Steiglitz, and J. E. Hopcroft, IEEE
Trans. IT-12 (1966), 425-430.]

29. Assuming that p 6= 0, let l = blg pc and Sa = fs j 2la ^ s ! 2l(a + 1)g for
0 ^ a ! 2n\Gamma l. Then (k \Phi  p) \Gamma  k has a constant sign for all k 2 Sa, and

X

k2Sa

fi
fi
fi(k \Phi  p) \Gamma  k

fi
fi
fi = 2

lkS

ak = 2

2l:

Also g[\Gamma 1](g(k) \Phi  p) = k \Phi  g[\Gamma 1](p), and blg g[\Gamma 1](p)c = blg pc. Therefore

1
2n

2n\Gamma 1X

k=0

fi
fi
fig

[\Gamma 1](g(k) \Phi  p) \Gamma  k

fi
fi
fi =

1

2n

2n\Gamma l\Gamma 1X

a=0

X
k2Sa

fi
fi
fi(k \Phi  g

[\Gamma 1](p)) \Gamma  k

fi
fi
fi =

1

2n

2n\Gamma l\Gamma 1X

a=0

22l = 2l:

[See Morgan M. Buchner, Jr., Bell System Tech. J. 48 (1969), 3113-3130.]

44

7.2.1.1 ANSWERS TO EXERCISES 45

30. The cycle containing k ? 1 has length 2blg lg kc+1, because it is easy to show from
Eq. (7) that if k = (bn\Gamma 1 : : : b0)2 we have

g[2

l]

(k) = (cn\Gamma 1 : : : c0)2; where cj = bj \Phi  bj+l+1.

To permute all elements k such that blg kc = t, there are two cases: If t is a power of 2,
the cycle containing 2bk=2c also contains 2bk=2c+1, so we must double the cycle leaders
for t \Gamma  1. Otherwise the cycle containing 2bk=2c is disjoint from the cycle containing
2bk=2c + 1, so Lt = (2Lt\Gamma 1) [ (2Lt\Gamma 1 + 1) = (Lt\Gamma 1\Lambda )2. This argument establishes the
hint and yields the following algorithm:

P1. [Initialize.] Set t  1, m  0. (We may assume that n * 2.)
P2. [Loop through leaders.] Set r  m. Perform Algorithm Q with k = 2t + r;

then if r ? 0, set r  (r \Gamma  1)^ m and repeat until r = 0. [See exercise 7.1-00.]

P3. [Increase lg k.] Set t  t + 1. Terminate if t is now equal to n; otherwise set

m  2m + [t ^ (t \Gamma  1) 6= 0] and return to P2.

Q1. [Begin a cycle.] Set s  Xk, l  k, j  l \Phi  bl=2c.
Q2. [Follow the cycle.] If j 6= k set Xl  Xj, l  j, j  l \Phi  bl=2c, and repeat

until j = k. Then set Xl  s.

31. We get a field from fn if and only if we get one from f[2]n , which takes (an\Gamma 1 : : : a0)2
to ((an\Gamma 1 \Phi  an\Gamma 2)(an\Gamma 1 \Phi  an\Gamma 3)(an\Gamma 2 \Phi  an\Gamma 4) : : : (a2 \Phi  a0)(a1))2. Let cn(x) be the
characteristic polynomial of the matrix A defining this transformation, mod 2; then
c1(x) = x + 1, c2(x) = x2 + x + 1, and cn+1(x) = xcn(x) + cn\Gamma 1(x). Since cn(A) is the
zero matrix, by the Cayley-Hamilton theorem, a field is obtained if and only if cn(x) is
a primitive polynomial, and this condition can be tested as in Section 3.2.2. The first
such values of n are 1, 2, 3, 5, 6, 9, 11, 14, 23, 29, 30, 33, 35, 39, 41, 51, 53, 65, 69, 74,
81, 83, 86, 89, 90, 95.

[Running the recurrence backwards shows that c\Gamma j\Gamma 2(x) = cj(x), hence cj(x)
divides c(2j+1)k+j(x); for example, c3k+1(x) is always a multiple of x+1. All numbers n
of the form 2jk + j + k are therefore excluded when j ? 0 and k ? 0. The polynomials
c18(x), c50(x), c98(x), and c99(x) are irreducible but not primitive.]

32. Mostly true, but false at the points where x changes sign. (Walsh originally
suggested that wk(x) should be zero at such points; but the convention adopted here
is better, because it makes simple formulas like (15)-(19) valid for all x.)

33. By induction on k, we have

wk(x) = wbk=2c(2x) = r1(2x)b1+b2r2(2x)b2+b3 : : : = r1(x)b0+b1r2(x)b1+b2r3(x)b2+b3 : : :
for 0 ^ x ! 12 , because rj(2x) = rj+1(x) and r1(x) = 1 in this range. And when

1
2 ^ x ! 1,

wk(x) = (\Gamma 1)dk=2ewbk=2c(2x \Gamma  1) = r1(x)b0+b1r1(2x \Gamma  1)b1+b2r2(2x \Gamma  1)b2+b3 : : :

= r1(x)b0+b1r2(x)b1+b2r3(x)b2+b3 : : :

because dk=2e j b0 + b1 (modulo 2) and rj(2x \Gamma  1) = rj+1(x \Gamma  12 ) = rj+1(x) for j * 1.

34. pk(x) =

Q

j*0 r

bj
j+1; hence wk(x) = pk(x)pbk=2c(x) = pg(k)(x). [R. E. A. C. Paley,

Proc. London Math. Soc. (2) 34 (1932), 241-279.]

45

46 ANSWERS TO EXERCISES 7.2.1.1
35. If j = (an\Gamma 1 : : : a0)2 and k = (bn\Gamma 1 : : : b0)2, the element in row j and column k is
(\Gamma 1)f(j;k), where f(j; k) is the sum of all arbs such that: r = s (Hadamard); r+s = n\Gamma 1
(Paley); r + s = n or n \Gamma  1 (Walsh).

Let Rn, Fn, and Gn be permutation matrices for the permutations that take
j = (an\Gamma 1 : : : a0)2 to k = (a0 : : : an\Gamma 1)2, k = 2n \Gamma  1 \Gamma  j = (an\Gamma 1 : : : a0)2, and k =
g[\Gamma 1](j) = ((an\Gamma 1) : : : (an\Gamma 1 \Phi  \Delta  \Delta  \Delta  \Phi  a0))2, respectively. Then, using the Kronecker
product of matrices, we have the recursive formulas

Rn+1 =

`

Rn \Omega  (1 0)

Rn \Omega  (0 1)

'

; Fn+1 = Fn \Omega 

`

0 1

1 0

'

; Gn+1 =

`

Gn 0

0 GnFn

'

;

Hn+1 = Hn \Omega 

`

1 1

1 1

'

; Pn+1 =

`

Pn \Omega  (1 1)

Pn \Omega  (1 1)

'

; Wn+1 =

`

Wn \Omega  (1 1)

FnWn \Omega  (1 1)

'

:

Thus Wn = GTn Pn = PnGn; Hn = PnRn = RnPn; and Pn = WnGTn = GnWn =
HnRn = RnHn.

36. W1. [Hadamard transform.] For k = 0, 1, : : : , n \Gamma  1, replace the pair (Xj; Xj+2k )

by (Xj + Xj+2k; Xj \Gamma  Xj+2k ) for all j with bj=2kc even, 0 ^ j ! 2n. (These
operations effectively set XT  HnXT.)

W2. [Bit reversal.] Apply the algorithm of exercise 5 to the vector X. (These

operations effectively set XT  RnXT, in the notation of exercise 35.)

W3. [Gray binary permutation.] Apply the algorithm of exercise 30 to the vector X. (These operations effectively set XT  GTn XT.)

If n has one of the special values in exercise 31, it may be faster to combine steps W2
and W3 into a single permutation step.

37. If k = 2e1 +\Delta  \Delta  \Delta +2et with e1 ? \Delta  \Delta  \Delta  ? et * 0, the sign changes occur at Se1 [\Delta  \Delta  \Delta [Set,
where

S0 =

n

1

2

o

; S1 =

n

1

4

;

3

4

o

; : : : ; Se =

n

2j + 1

2e

fi
fi
fi 0 ^ j ! 2

e

o

:

Therefore the number of sign changes in (0 : : x) is

Pt

j=1b2

ej x+ 1

2 c. Setting x = l=(k+1)

gives l+O(t) changes; so the lth is at a distance of at most O(*(k))=2blg kc from l=(k+1).

[This argument makes it plausible that infinitely many pairs (k; l) exist with
jzkl \Gamma  l=(k + 1)j = \Omega ((log k)=k). But no explicit construction of such "bad" pairs
is immediately apparent.]

38. Let t0(x) = 1 and tk(x) = !b3xcd2k=3etbk=3c(3x), where ! = e2ssi=3. Then tk(x)
winds around the origin 23 k times as x increases from 0 to 1. If sk(x) = !b3kxc is the
ternary analog of the Rademacher function rk(x), we have tk(x) =

Q

j*0 sj+1(x)

bj\Gamma bj+1

when k = (bn\Gamma 1 : : : b0)3, as in the modular ternary Gray code.
39. Let's call the symbols fx0; x1; : : : ; x7g instead of fa; b; c; d; e; f; g; hg. We want to
find a permutation p of f0; 1; : : : ; 7g such that the matrix with (\Gamma 1)j\Delta kxp(j)\Phi k in row j
and column k has orthogonal rows; this condition is equivalent to requiring that

(j + j0) \Delta  (p(j) + p(j0)) j 1 (modulo 2), for 0 ^ j ! j0 ! 8.
One solution is p(0) : : : p(7) = 0 1 7 2 5 6 3 4, yielding the identity (a2 + b2 + c2 + d2 +
e2 + f2 + g2 + h2)(A2 + B2 + C2 + D2 + E2 + F 2 + G2 + H2) = A2 + B2 + C2 + D2 +

46

7.2.1.1 ANSWERS TO EXERCISES 47
E2 + F2 + G2 + H2, where

0

B
B
B
B
B
B
B
B
B
@

A

B

C
D

E
F

G
H

1
C
C
C
C
C
C
C
C
C
A

=

0
B
B
B
B
B
B
B
B
B
@

a b c d e f g h

b \Gamma a d \Gamma c f \Gamma e h \Gamma g
h g \Gamma f \Gamma e d c \Gamma b \Gamma a

c \Gamma d \Gamma a b g \Gamma h \Gamma e f
f e h g \Gamma b \Gamma a \Gamma d \Gamma c

g \Gamma h e \Gamma f \Gamma c d \Gamma a b
d c \Gamma b \Gamma a \Gamma h \Gamma g f e

e \Gamma f \Gamma g h \Gamma a b c \Gamma d

1
C
C
C
C
C
C
C
C
C
A

0
B
B
B
B
B
B
B
B
B
@

A
B

C
D

E
F
G
H

1
C
C
C
C
C
C
C
C
C
A

:

(b) There is no 16 \Theta  16 solution. The closest one can come is

p(0) : : : p(15) = 0 1 11 2 14 15 13 4 9 10 7 12 5 6 3 8;
which fails if and only if j \Phi  j0 = 5. [See Philos. Mag. 34 (1867), 461-475. In x9, x10,
x11, and x13 of this paper, Sylvester stated and proved the basic results about what
has somehow come to be known as the Hadamard transform -- although Hadamard
himself gave credit to Sylvester [Bull. des Sciences Math'ematiques (2) 17 (1893), 240-
246]. Moreover, Sylvester introduced transforms of mn elements in x14, using mth
roots of unity.]

40. Yes; this change would in fact run through the swapped subsets in lexicographic
binary order rather than in Gray binary order. (Any 5 \Theta  5 matrix of 0s and 1s that
is nonsingular mod 2 will generate all 32 possibilities when we run through all linear
combinations of its rows.) The most important thing is the appearance of the ruler
function, or some other Gray code delta sequence, not the fact that only one aj changes
per step, in cases like this where any number of the aj can be changed simultaneously
at the same cost.

41. At most 16; for example, fired, fires, finds, fines, fined, fares, fared, wares,
wards, wands, wanes, waned, wines, winds, wires, wired. We also get 16 from paced/
links and paled/mints; perhaps also from a word mixed with an antipodal nonword.

42. Suppose n ^ 22

r

+ r + 1, and let s = 2r. We use an auxiliary table of 2r+s bits fjk

for 0 ^ j ! 2s and 0 ^ k ! s, representing focus pointers as in Algorithm L, together
with an auxiliary s-bit "register" j = (js\Gamma 1 : : : j0)2 and an (r+2)-bit "program counter"
p = (pr+1 : : : p0)2. At each step we examine the program counter and possibly the j
register and one of the f bits; then, based on the bits seen, we complement a bit of the
Gray code, complement a bit of the program counter, and possibly change a j or f bit,
thereby emulating step L3 with respect to the most significant n \Gamma  r \Gamma  2 bits.

For example, here is the construction when r = 1:

p2p1p0 Change Set

0 0 0 a0; p0 j0  f00
0 0 1 a1; p1 j1  f01

o

j  f0

0 1 1 a0; p0 f00  0
0 1 0 a2; p2 f01  0

o

f0  0

p2p1p0 Change Set

1 1 0 a0; p0 fj0  f(j+1)0
1 1 1 a1; p1 fj1  f(j+1)1

o

fj  fj+1

1 0 1 a0; p0 f(j+1)0  (j+1)0
1 0 0 aj+3; p2 f(j+1)1  (j+1)1

o

fj+1  j+1

The process stops when it attempts to change bit an.

[In fact, we need change only one auxiliary bit per step if we allow ourselves to
examine some Gray binary bits as well as the auxiliary bits, because pr : : : p0 = ar : : : a0,
and we can set f0  0 in a more clever way when j doesn't have its final value 2s \Gamma  1.
This construction, suggested by Fredman in 2001, improves on another that he had

47

48 ANSWERS TO EXERCISES 7.2.1.1
published in SICOMP 7 (1978), 134-146. With a more elaborate construction it is
possible to reduce the number of auxiliary bits to O(n).]

43. This number was estimated by Silverman, Vickers, and Sampson [IEEE Trans. IT29 (1983), 894-901] to be about 7 \Theta  1022. Exact calculation might be feasible because
every 6-bit Gray code has only five or fewer segments that lie in a 5-cube corresponding
to at least one of the six coordinates. (In unpublished work, Steve Winker had used a
similar idea to evaluate d(5) in less than 15 minutes on a "generic" computer in 1972.)

44. All (n + 1)-bit delta sequences with just two occurrences of the coordinate j are
produced by the following construction: Take n-bit delta sequences ffi0 : : : ffi2n\Gamma 1 and
"0 : : : "2n\Gamma 1 and find an index k with ffik = "0. Form the cycle

ffi0 : : : ffik\Gamma 1n"1 : : : "2n\Gamma 1 nffik+1 : : : ffi2n\Gamma 1
and then interchange n $ j.

All (n \Gamma  2)-bit delta sequences with just two occurrences of coordinates h and j
(with h before j) are, similarly, produced from four n-bit sequences ffi0 : : : ffi2n\Gamma 1, : : : ,
j0 : : : j2n\Gamma 1 and an index k with ffik = "0 = i0 = j0, by interchanging n $ h and
n + 1 $ j in

ffi0 : : : ffik\Gamma 1 n"1 : : : "2n\Gamma 1 (n+1)i1 : : : i2n\Gamma 1 nj1 : : : j2n\Gamma 1 (n+1)ffik+1 : : : ffi2n\Gamma 1:
Let a(n) and b(n) be the answers to (a) and (b), for n * 1. The first construction
shows that a(n + 1) + 2b(n + 1) = 2n(n + 1)d(n)2=n, because it produces the delta
sequences enumerated by b(n + 1) in two ways. The second construction shows that
b(n + 2) = 2n(n + 2)(n + 1)d(n)4=n3.

45. We have d(n + 1) * 2nd(n)2=n, because 2nd(n)2=n is the number of (n + 1)-bit
delta sequences with exactly two appearances of 0. Hence d(n) ? 532 22n for n * 5, by
induction on n.

Indeed, we can establish even faster growth by using the previous exercise, because
d(n + 1) * a(n + 1) + b(n + 1) and b(n + 1) ^ 2564 (n + 1)d(n)2=n for n * 5. Hence
d(n + 1) * (2n \Gamma  2564 )(n + 1)d(n)2=n for n * 5, and iteration of this relation shows that

lim
n!1

d(n)1=2

n

* d(5)1=32

1Y

n=5

i

2n \Gamma 

25

64

j1=2n+1 i

n + 1

n

j1=2n+1

ss 2:3606:

[See R. J. Douglas, Disc. Math. 17 (1977), 143-146; M. Mollard, European J. Comb.
9 (1988), 49-52.] But the true value of this limit is probably 1.

46. Leo Moser (unpublished) has conjectured that it is , n=e. So far only an upper
bound of about n=

p

2 has been established; see the references in the previous answer.

48. If d(n; k; v) of the codes begin with g(0) : : : g(k \Gamma  1)v, the conjecture implies that
d(n; k; v) ^ d(n; k; g(k)), because the reverse of a Gray code is a Gray code. Thus the
hint follows from d(n) = d(n; 1) and

d(n; k) =

X

v

f d(n; k; v) j v \Gamma \Gamma \Gamma g(k \Gamma  1); v =2 Sk g ^ cnkd(n; k; g(k)) = d(n; k + 1):

Finally, d(n; 2n) = 1, hence d(n) ^

Q2n\Gamma 1

k=1 cnk =

Qn

k=1 k

(nk) = n Qn\Gamma 1

k=1 (k(n\Gamma k))

(nk)=2 ^

n

Qn\Gamma 1

k=1 (n=2)

(nk) = n(n=2)2n\Gamma 2. [IEEE Trans. IT-29 (1983), 894-901.]

49. Take any Hamiltonian path P from 0 : : : 0 to 1 : : : 1 in the (2n \Gamma  1)-cube, such
as the Savage-Winkler path, and use 0P , 1P R. (All such codes are obtained by this
construction when n = 1 or n = 2, but many more possibilities exist when n ? 2.)

48

7.2.1.1 ANSWERS TO EXERCISES 49

50. ff1(n+1)ffR1 nff1 j1 ff2 nffR2 (n+1)ff2 : : : jl\Gamma 1fflnffRl (n+1)ffl nffRl jl\Gamma 1 : : : j1 ffR1 n.
51. We can assume that n ? 3 and that we have an n-bit Gray code with transition
counts cj = 2b(2n\Gamma 1 + j)=nc; we want to construct an (n + 2)-bit code with transition
counts c0j = 2b(2n+1 + j)=(n + 2)c. If 2n+1 mod (n + 2) * 2, we can use Theorem D
with l = 2b2n+1=(n + 2)c + 1, underlining bj copies of j where bj = 4b(2n\Gamma 1 + j)=nc \Gamma 
b(2n+1 +j)=(n+2)c\Gamma [j = 0] and putting an underlined 0 last. This is always easy to do
because jbj \Gamma 2n+2=n(n+ 2)j ! 5. A similar construction works if 2n+1 mod (n+2) ^ n,
with l = 2b2n+1=(n+2)c\Gamma 1 and bj = 4b(2n\Gamma 1 +j)=nc\Gamma b(2n+1 +j +2)=(n+2)c\Gamma [j = 0].
In fact, 2n+1 mod (n + 2) is always ^ n [see K. Kedlaya, Electronic J. Combinatorics 3
(1996), comment on #R25 (9 April 1997)]. The basic idea of this proof is due to J. P.
Robinson and M. Cohn [IEEE Trans. C-30 (1981), 17-23].

52. The number of different code patterns in the smallest j coordinate positions is at
most c0 + \Delta  \Delta  \Delta  + cj\Gamma 1.

53. Notice that Theorem D produces only codes with cj = cj+1 for some j, so it
cannot produce the counts (2; 4; 6; 8; 12). The extension in exercise 50 gives also
cj = cj+1 \Gamma  2, but it cannot produce (6; 10; 14; 18; 22; 26; 32). The sets of numbers
satisfying the conditions of exercise 52 are precisely those obtainable by starting with
f2; 2; 4; : : : ; 2n\Gamma 1g and repeatedly replacing some pair fcj; ckg for which cj ! ck by the
pair fcj + 2; ck \Gamma  2g.

54. Suppose the values are fp1; : : : ; png, and let xjk be the number of times pj occurs
in (a1; : : : ; ak). We must have (x1k; : : : ; xnk) j (x1l; : : : ; xnl) (modulo 2) for some k ! l.
But if the p's are prime numbers, varying as the delta sequence of an n-bit Gray code,
the only solution is k = 0 and l = 2n. [AMM 60 (1953), 418; 83 (1976), 54.]

56. [Bell System Tech. J. 37 (1958), 815-826.] The 112 canonical delta sequences yield

Class Example t

A 0102101302012023 2
B 0102303132101232 2
C 0102030130321013 2

Class Example t

D 0102013201020132 4
E 0102032021202302 4
F 0102013102010232 4

Class Example t

G 0102030201020302 8
H 0102101301021013 8
I 0102013121012132 1

Here B is the balanced code (Fig. 13(b)), G is standard Gray binary (Fig. 10(b)), and
H is the complementary code (Fig. 13(a)). Class H is also equivalent to the modular
(4; 4) Gray code under the correspondence of exercise 18. A class with t automorphisms
corresponds to 32 \Theta  24=t of the 2688 different delta sequences ffi0ffi1 : : : ffi15.

Similarly (see exercise 7.2.3-00), the 5-bit Gray codes fall into 237,675 different
equivalence classes.

57. With Type 1 only, 480 vertices are isolated, namely those of classes D, F , G in
the previous answer. With Type 2 only, the graph has 384 components, 288 of which
are isolated vertices of classes F and G. There are 64 components of size 9, each
containing 3 vertices from E and 6 from A; 16 components of size 30, each with 6
from H and 24 from C; and 16 components of size 84, each with 12 from D, 24 from B,
48 from I. With Type 3 (or Type 4) only, the entire graph is connected. [Similarly, all
91,392 of the 4-bit Gray paths are connected if path fffi is considered adjacent to path
ffRfi. Vickers and Silverman, IEEE Trans. C-29 (1980), 329-331, have conjectured
that Type 3 changes will suffice to connect the graph of n-bit Gray codes for all n * 3.]

58. If some nonempty substring of fifi involves each coordinate an even number of
times, that substring cannot have length jfij, so some cyclic shift of fi has a prefix fl

49

50 ANSWERS TO EXERCISES 7.2.1.1
with the same evenness property. But then ff doesn't define a Gray code, because we
could change each n of fl back to 0.

59. If ff is nonlocal in exercise 58, so is fifi, provided that q ? 1 and that 0 occurs
more than q + 1 times in ff. Therefore, starting with the ff of (30) but with 0 and 1
interchanged, we obtain nonlocal codes for n * 5 in which coordinate 0 changes exactly
6 times. [Mark Ramras, Discrete Math. 85 (1990), 329-331.] On the other hand, a
4-bit Gray code cannot be nonlocal because it always has a run of length 2; if ffik = ffik+2,
elements fvk\Gamma 1; vk; vk+1; vk+2g form a 2-subcube.

60. Use the construction of exercise 58 with q = 1.
61. The idea is to interleave an m-bit code U = (u0; u1; u2; : : : ) with an n-bit code
V = (v0; v1; v2; : : : ), by forming concatenations

W = (ui0vj0; ui1vj1; ui2vj2; : : : ); ik = a0 + \Delta  \Delta  \Delta  + ak\Gamma 1; jk = a0 + \Delta  \Delta  \Delta  + ak\Gamma 1;
where a0a1a2 : : : is a periodic string of control bits ffffff : : : ; we advance to the next
element of U when ak = 0, otherwise to the next element of V .

If ff is any string of length 2m ^ 2n, containing s bits that are 0 and t = 2m \Gamma  s
bits that are 1, W will be an (m + n)-bit Gray code if s and t are odd. For we have
ik+l j ik (modulo 2m) and jk+l j jk (modulo 2n) only if l is a multiple of 2m, since
ik + jk = k. Suppose l = 2mc; then jk+l = jk + tc, so c is a multiple of 2n.

(a) Let ff = 0111; then runs of length 8 occur in the left 2 bits and runs of length
* b 43 r(n)c occur in the right n bits.

(b) Let s be the largest odd number ^ 2mr(m)=(r(m) + r(n)). Also let t = 2m \Gamma  s
and ak = b(k + 1)t=2mc \Gamma  bkt=2mc, so that ik = dks=2me and jk = bkt=2mc. If
a run of length l occurs in the left m bits, we have ik+l+1 * ik + r(m) + 1, hence
l + 1 ? 2mr(m)=s * r(m) + r(n). And if it occurs in the right n bits we have jk+l+1 *
jk + r(n) + 1, hence

l + 1 ? 2mr(n)=t ? 2mr(n)=(2mr(n)=(r(m) + r(n)) + 2)

= r(m) + r(n) \Gamma 

2(r(m) + r(n))2

2mr(n) + 2(r(m) + r(n))

? r(m) + r(n) \Gamma  1

because r(m) ^ r(n).

The construction often works also in less restricted cases. See the paper that
introduced the study of Gray code runs: L. Goddyn, G. M. Lawrence, and E. Nemeth,
Utilitas Math. 34 (1988), 179-192.

63. Set ak  k mod 4 for 0 ^ k ! 210, except that ak = 4 when k mod 16 = 15 or
k mod 64 = 42 or k mod 256 = 133. Also set (j0; j1; j2; j3; j4)  (0; 2; 4; 6; 8). Then
for k = 0, 1, : : : , 1023, set ffik  jak and jak  1 + 4ak \Gamma  jak . (This construction
generalizes the method of exercise 61.)

64. (a) Each element uk appears together with fvk; vk+2m; : : : ; vk+2m(2n\Gamma 1\Gamma 1)g and
fvk+1; vk+1+2m; : : : ; vk+1+2m(2n\Gamma 1\Gamma 1)g. Thus the permutation oe0 : : : oe2m\Gamma 1 must be a
2n\Gamma 1-cycle containing the n-bit vertices of even parity, times an arbitrary permutation
of the other vertices. This condition is also sufficient.

(b) Let o/j be the permutation that takes v 7! v \Phi  2j, and let ssj(u; w) be the
permutation (uw)o/j. If u \Phi  w = 2i + 2j then ssj(u; w) takes u 7! u \Phi  2i and w 7! w \Phi  2i,
while v 7! v \Phi  2j for all other vertices v, so it takes each vertex to a neighbor.

If S is any set ` f0; : : : ; n \Gamma  1g, let oe(S) be the stream of all permutations o/j for
all j 2 f0; : : : ; n \Gamma  1g n S, in increasing order of j, repeated twice; for example, if n = 5

50

7.2.1.1 ANSWERS TO EXERCISES 51
we have oe(f1; 2g) = o/0o/3o/4o/0o/3o/4. Then the Gray stream

\Sigma (i; j; u) = oe(fi; jg)ssj(u; u\Phi 2i\Phi 2j)oe(fi; jg)o/j oe(fjg)
consists of 6n \Gamma  8 permutations whose product is the transposition (u u\Phi 2i\Phi 2j).
Moreover, when this stream is applied to any n-bit vertex v, its runs all have length
* n \Gamma  2.

We may assume that n * 5. Let ffi0 : : : ffi2n\Gamma 1 be the delta sequence for an n-bit
Gray code (v0; v1; : : : ; v2n\Gamma 1) with all runs of length 3 or more. Then the product of
all permutations in

\Sigma  =

2n\Gamma 1\Gamma 1Y

k=1

(\Sigma (ffi2k\Gamma 1; ffi2k; v2k\Gamma 1) \Sigma (ffi2k; ffi2k+1; v2k))

is (v1 v3)(v2 v4) : : : (v2n\Gamma 3 v2n\Gamma 1)(v2n\Gamma 2 v0) = (v2n\Gamma 1 : : : v1)(v2n\Gamma 2 : : : v0), so it satisfies
the cycle condition of (a).

Moreover, all powers (oe(;)\Sigma )t produce runs of length * n \Gamma  2 when applied to
any vertex v. By repeating individual factors oe(fi; jg) or oe(fjg) in \Sigma  as many times
as we wish, we can adjust the length of oe(;)\Sigma , obtaining 2n + (2n\Gamma 1 \Gamma  1)(12n \Gamma  16) +
2(n\Gamma  2)a + 2(n\Gamma  1)b for any integers a; b * 0; thus we can increase its length to exactly
2m, provided that 2m * 2n + (2n\Gamma 1\Gamma  1)(12n \Gamma  16) + 2(n2 \Gamma  5n + 6), by exercise 5.2.1-
21.

(c) The bound r(n) * n \Gamma  4 lg n + 8 can be proved for n * 5 as follows. First
we observe that it holds for 5 ^ n ! 33 by the methods of exercises 60-63. Then we
observe that every integer N * 33 can be written as N = m + n or N = m + n + 1, for
some m * 20, where

n = m \Gamma  b4 lg mc + 10:

If m * 20, 2m is sufficiently large for the construction in part (b) to be valid; so we
have

r(N) * r(m + n) * 2 min(r(m); n \Gamma  2) * 2(m \Gamma  b4 lg mc + 8)

= m + n + 1 \Gamma  b4 lg(m + n) \Gamma  1 + fflc + 8
* N \Gamma  4 lg N + 8

where ffl = 4 lg(2m=(m + n)) ! 1. [To appear.] Recursive use of (b) gives, in fact,
r(1024) * 1000.

65. A computer search reveals that eight essentially different patterns (and their
reverses) are possible. One of them has the delta sequence 01020314203024041234
214103234103, and it is close to two of the others.

67. Let v2k+1 = v2k and v2k = 0uk, where (u0; u1; : : : ; u2n\Gamma 1) is any (n \Gamma  1)-bit Gray
code. [See Robinson and Cohn, IEEE Trans. C-30 (1981), 17-23.]

68. Yes. The simplest way is probably to take (n \Gamma  1)-trit modular Gray ternary code
and add 0 : : : 0, 1 : : : 1, 2 : : : 2 to each string (modulo 3). For example, when n = 3 the
code is 000, 111, 222, 001, 112, 220, 002, 110, 221, 012, 120, 201, : : : , 020, 101, 212.

69. (a) We need only verify the change in h when bits bj\Gamma 1 : : : b0 are simultaneously
complemented, for j = 1, 2, : : : ; and these changes are respectively (1110)2, (1101)2,
(0111)2, (1011)2, (10011)2, (100011)2, : : : . To prove that every n-tuple occurs, note
that 0 ^ h(k) ! 2n when 0 ^ k ! 2n and n ? 3; also h[\Gamma 1]((an\Gamma 1 : : : a0)2) =

51

52 ANSWERS TO EXERCISES 7.2.1.1
(bn\Gamma 1 : : : b0)2, where b0 = a0 \Phi  a1 \Phi  a2 \Phi  \Delta  \Delta  \Delta  , b1 = a0, b2 = a2 \Phi  a3 \Phi  a4 \Phi  \Delta  \Delta  \Delta  ,
b3 = a0 \Phi  a1 \Phi  a3 \Phi  \Delta  \Delta  \Delta  , and bj = aj \Phi  aj+1 \Phi  \Delta  \Delta  \Delta  for j * 4.

(b) Let h(k) = (: : : a2a1a0)2 where aj = bj \Phi  bj+1 \Phi  b0[j ^ t] \Phi  bt\Gamma 1[t \Gamma  1 ^ j ^ t].

70. As in (32) and (33), we can remove a factor of n! by assuming that the strings of
weight 1 occur in order. Then there are 14 solutions for n = 5 starting with 00000, and
21 starting with 00001. When n = 6 there are 46,935 of each type (related by reversal
and complementation). When n = 7 the number is much, much larger, yet very small
by comparison with the total number of 7-bit Gray paths.

71. Suppose that ffn(j+1) differs from ffnj in coordinate tj, for 0 ^ j ! n \Gamma  1. Then
tj = jssn, by (44) and (38). Now Eq. (34) tells us that t0 = n \Gamma  1; and if 0 ! j ! n \Gamma  1
we have tj = ((j \Gamma  1)ssn\Gamma 1)ssn\Gamma 1 by (40). Thus tj = joenss2n\Gamma 1 for 0 ^ j ! n \Gamma  1, and
the value of (n \Gamma  1)ssn is whatever is left. (Notations for permutations are notoriously
confusing, so it is always wise to check a few small cases carefully.)

72. The delta sequence is 0102132430201234012313041021323.
73. Let Qnj = P Rnj and denote the sequences (41), (42) by Sn and Tn. Thus Sn =
Pn0Qn1Pn2 : : : and Tn = Qn0Pn1Qn2 : : : , if we omit the commas; and we have

Sn+1 = 0Pn0 0Qn1 1Qssn0 1P ssn1 0Pn2 0Qn3 1Qssn2 1P ssn3 0Pn4 : : : ;

Tn+1 = 0Qn0 1P ssn0 0Pn1 0Qn2 1Qssn1 1P ssn2 0Pn3 0Qn4 1Qssn3 : : : ;

where ss = ssn, revealing a reasonably simple joint recursion between the delta sequences
\Delta n and En of Sn and Tn. Namely, if we write

\Delta n = OE1 a1 OE2 a2 : : : OEn\Gamma 1 an\Gamma 1 OEn; En = 1 b1 2 b2 : : : n\Gamma 1 bn\Gamma 1 n;
where each OEj and j is a string of length 2

\Gamma n\Gamma 1

j\Gamma 1

\Delta 

\Gamma  1, the next sequences are

\Delta n+1 = OE1 a1 OE2 n 1ss b1ss 2ss n OE3 a3 OE4 n 3ss b3ss 4ss n : : :

En+1 = 1 n OE1ss n 2 b2 3 n OE2ss a2ss OE3ss n 4 b4 5 n OE4ss a4ss OE5ss n : : :

For example, we have \Delta 3 = 0 1 0 2 1 0 1 and E3 = 0 2 1 2 0 2 1, if we underline the a's
and b's to distinguish them from the OE's and 's; and

\Delta 4 = 0 1 0 2 1 3 0ss 2ss 1ss 2ss 0ss 3 1 3 1ss = 0 1 0 2 1 3 2 1 0 1 2 3 1 3 0;

E4 = 0 3 0ss 3 1 2 0 2 1 3 0ss 2ss 1ss 0ss 1ss = 0 3 2 3 1 2 0 2 1 3 2 1 0 2 0;

here a3OE4 and b34 are empty. Elements have been underlined for the next step.

Thus we can compute the delta sequences in memory as follows. Here p[j] = jssn
for 1 ^ j ! n; sk = ffik, tk = "k, and uk = [ffik and "k are underlined], for 0 ^ k ! 2n\Gamma 1.

R1. [Initialize.] Set n  1, p[0]  0, s0  t0  u0  0.
R2. [Advance n.] Perform Algorithm S below, which computes the arrays s0, t0,

and u0 for the next value of n; then set n  n + 1.

R3. [Ready?] If n is sufficiently large, the desired delta sequence \Delta n is in array s0;

terminate. Otherwise keep going.

R4. [Compute ssn.] Set p0[0] = n \Gamma  1, and p0[j] = p[p[j \Gamma  1]] for 1 ^ j ! n.
R5. [Prepare to advance.] Set p[j]  p0[j] for 0 ^ j ! n; set sk  s0k, tk  t0k,

and uk  u0k for 0 ^ k ! 2n\Gamma  1. Return to R2.

52

7.2.1.1 ANSWERS TO EXERCISES 53
In the following steps, "Transmit stuff(l; j) while uj = 0" is an abbreviation for "If
uj = 0, repeatedly stuff(l; j), l  l + 1, j  j + 1, until uj 6= 0."

S1. [Prepare to compute \Delta n+1.] Set j  k  l  0 and u2n\Gamma 1  \Gamma 1.
S2. [Advance j.] Transmit s0l  sj and u0l  0 while uj = 0. Then go to S5 if

uj ! 0.

S3. [Advance j and k.] Set s0l  sj, u0l  1, l  l + 1, j  j + 1. Then transmit

s0l  sj and u0l  0 while uj = 0. Then set s0l  n, u0l  0, l  l + 1. Then
transmit s0l  p[tk] and u0l  0 while uk = 0. Then set s0l  p[tk], u0l  1,
l  l + 1, k  k + 1. And once again transmit s0l  p[tk] and u0l  0 while
uk = 0.

S4. [Done with \Delta n+1?] If uk ! 0, go to S6. Otherwise set s0l  n, u0l  0,

l  l + 1, j  j + 1, k  k + 1, and return to S2.

S5. [Finish \Delta n+1.] Set s0l  n, u0l  1, l  l + 1. Then transmit s0l  p[t[k]] and

u0l  0 while uk = 0.

S6. [Prepare to compute En+1.] Set j  k  l  0. Transmit t0l  tk while

uk = 0. Then set t0l  n, l  l + 1.

S7. [Advance j.] Transmit t0l  p[sj] while uj = 0. Then terminate if uj ! 0;

otherwise set t0l  n, l  l + 1, j  j + 1, k  k + 1.

S8. [Advance k.] Transmit t0l  tk while uk = 0. Then go to S10 if uk ! 0.
S9. [Advance k and j.] Set t0l  tk, l  l + 1, k  k + 1. Then transmit t0l  tk

while uk = 0. Then set t0l  n, l  l + 1. Then transmit t0l  p[sj] while
uj = 0. Then set t0l  p[sj], l  l + 1, j  j + 1. Return to S7.

S10. [Finish En+1.] Set t0l  n, l  l+1. Then transmit t0l  p[sj] while uj = 0.

To generate the monotonic Savage-Winkler path for fairly large n, one can first generate
\Delta 10 and E10, say, or even \Delta 20 and E20. Using these tables, a suitable recursive procedure will then be able to reach higher values of n with very little computational
overhead per step, on the average.

74. If the monotonic path is v0, : : : , v2n\Gamma 1 and if vk has weight j, we have

2

X

t?0

i

n

j \Gamma  2t

j

+ ((j + *(v0)) mod 2) ^ k ^ 2

X

t*0

i

n

j \Gamma  2t

j

+ ((j + *(v0)) mod 2) \Gamma  2:

Therefore the maximum distance between vertices of respective weights j and j + 1
is 2(

\Gamma n\Gamma 1

j\Gamma 1

\Delta 

+

\Gamma n\Gamma 1

j

\Delta 

+

\Gamma n\Gamma 1

j+1

\Delta 

) \Gamma  1. The maximum value, approximately 3 \Delta  2n=

p

2ssn,

occurs when j is approximately n=2. [This is only about three times the smallest value
achievable in any ordering of the vertices, which is

Pn\Gamma 1

j=0

\Gamma  j

bj=2c

\Delta 

by exercise 7.10-00.]

75. There are only five essentially distinct solutions, all of which turn out in fact to
be Gray codes. The delta sequences are

0 1 2 3 0 1 2 4 2 1 0 3 2 1 0 1 2 1 0 3 2 1 0 4 0 1 2 3 0 1 2 (1)
0 1 2 3 0 1 2 4 2 1 0 3 2 1 0 1 3 0 1 2 3 0 1 4 1 0 3 2 1 0 3 (1)
0 1 2 3 0 1 2 4 2 1 0 3 2 1 0 2 0 3 2 1 0 3 2 4 2 3 0 1 2 3 0 (2)
0 1 2 3 0 1 2 4 2 3 0 1 2 3 0 2 0 1 2 3 0 1 2 4 2 3 0 1 2 3 0 (2)
0 1 2 3 4 1 0 1 2 1 0 3 0 1 4 3 2 1 0 3 0 1 4 1 0 1 2 3 4 1 0 (3)

53

54 ANSWERS TO EXERCISES 7.2.1.1
76. If v0, : : : , v2n\Gamma 1 is trend-free, so is the (n + 1)-bit code 0v0, 1v0, 1v1, 0v1, 0v2,
1v2, : : : , 1v2n\Gamma 1, 0v2n\Gamma 1. Fig. 14(g) shows a somewhat more interesting construction,
which generalizes the first solution of exercise 75 to an (n + 2)-bit code

00\Gamma 00R; 01\Gamma 0R; 11\Gamma 0; 10\Gamma 00; 10\Gamma ; 11\Gamma 000; 01\Gamma 000R; 00\Gamma R
where \Gamma  is the n-bit sequences g(1), : : : , g(2n\Gamma 1) and \Gamma 0 = \Gamma  \Phi  g(1), \Gamma 00 = \Gamma  \Phi  g(2n\Gamma 1),
\Gamma 000 = \Gamma  \Phi  g(2n\Gamma 1 + 1). [An n-bit trend-free design that is almost a Gray code, having
just four steps in which *(vk \Phi  vk+1) = 2, was found for all n * 3 by C. S. Cheng,
Proc. Berkeley Conf. Neyman and Kiefer 2 (Hayward, Calif.: Inst. of Math. Statistics,
1985), 619-633.]

77. Omit the array (dn\Gamma 1; : : : ; d0), and set aj  (aj +1) mod mj in step H4. If aj = sj
in step H5, set sj  (sj \Gamma  1) mod mj, fj  fj+1, fj+1  j + 1.

78. For (50), notice that Bj+1 is the number of times reflection has occurred in
coordinate j, because we bypass coordinate j on steps that are multiples of mj : : : m0.
Hence, if bj ! mj, an increase of bj by 1 causes aj to increase or decrease by 1 as
appropriate. Furthermore, if bi = mi \Gamma  1 for 0 ^ i ! j, changing all these bi to 0 when
incrementing bj will increase each of B0, : : : , Bj by 1, thereby leaving the values a0,
: : : , aj\Gamma 1 unchanged in (50).

For (51), note that Bj = mjBj+1 + bj j mjBj+1 + aj + (mj \Gamma  1)Bj+1 j aj + Bj+1
(modulo 2); hence Bj j aj + aj+1 + \Delta  \Delta  \Delta  , and (51) is obviously equivalent to (50).

In the modular Gray code for general radices (mn\Gamma 1; : : : ; m0), let

mg(k) =

h

an\Gamma 1;

mn\Gamma 1;

: : : ;
: : : ;

a2;
m2;

a1;
m1;

a0
m0

i

when k is given by (46). Then aj = (bj \Gamma  Bj+1) mod mj, because coordinate j has
increased modulo mj exactly Bj \Gamma  Bj+1 times if we start at (0; : : : ; 0). The inverse
function, which determines the b's from the modular Gray a's, is bj = (aj + aj+1 +
aj+2 + \Delta  \Delta  \Delta  ) mod mj in the special case that each mj is a divisor of mj+1 (for example,
if all mj are equal). But the inverse has no simple form in general; it can be computed
by using the recurrences bj = (aj + Bj+1) mod mj, Bj = mjBj+1 + bj for j = n \Gamma  1,
: : : , 0, starting with Bn = 0.

[Reflected Gray codes for radix m ? 2 were introduced by Ivan Flores in IRE
Trans. EC-5 (1956), 79-82; he derived (50) and (51) in the case that all mj are
equal. Modular Gray codes with general mixed radices were implicitly discussed by
Joseph Rosenbaum in AMM 45 (1938), 694-696, but without the conversion formulas;
conversion formulas when all mj have a common value m were published by Martin
Cohn, Info. and Control 6 (1963), 70-78.]

79. (a) The last n-tuple always has an\Gamma 1 = mn\Gamma 1 \Gamma  1, so it is one step from (0; : : : ; 0)
only if mn\Gamma 1 = 2. And this condition suffices to make the final n-tuple (1; 0; : : : ; 0).
[Similarly, the final subforest output by Algorithm K is adjacent to the initial one if
and only if the leftmost tree is an isolated vertex.]

(b) The last n-tuple is (mn\Gamma 1\Gamma 1; 0; : : : ; 0) if and only if mn\Gamma 1 : : : mj+1 mod mj = 0
for 0 ^ j ! n \Gamma  1, because bj = mj \Gamma  1 and Bj = mn\Gamma 1 : : : mj \Gamma  1.

80. The first cycle contains the edge from (x; y) to (x; (y + 1) mod m) if and only if
(x + y) mod m 6= m \Gamma  1 if and only if the second cycle contains the edge from (x; y) to
((x + 1) mod m; y).

81. There are two 4-bit Gray codes (u0; : : : ; u15) and (v0; : : : ; v15) that cover all edges of
the 4-cube. (Indeed, the non-edges of classes A, B, D, H, and I in exercise 56 form Gray

54

7.2.1.1 ANSWERS TO EXERCISES 55
codes, belonging to the same class as their complement.) Therefore with 16-ary modular
Gray code we can form the four desired cycles (u0u0; u0u1; : : : ; u0u15; u1u15; : : : ; u15u0),
(u0u0; u1u0; : : : ; u15u0; u15u1; : : : ; u0u15), (v0v0; : : : ; v15u0), (v0v0; : : : ; v0v15).

In a similar way we can show that n=2 edge-disjoint n-bit Gray codes exist when
n is 16, 32, 64, etc. [Abhandlungen Math. Sem. Hamburg 20 (1956), 13-16.] J. Aubert
and B. Schneider [Discrete Math. 38 (1982), 7-16] have proved that the same property
holds for all even values of n * 4, but no simple construction is known.

83. Calling the initial position (2; 2), the 8-step solution in Fig. A-1 shows how the
sequence progresses down to (0; 0). In the first move, for example, the front half of the
cord passes around and behind the right comb, then through the large right loop. The
middle line should be read from right to left. The generalization to n pairs of loops
would, similarly, take 3n \Gamma  1 steps.

Step 0: (2; 2) Step 1: (2; 1) Step 2: (2; 0)
Step 5: (1; 2) Step 4: (1; 1) Step 3: (1; 0)
Step 6: (0; 2) Step 7: (0; 1) Step 8: (0; 0)

Fig. A-1.

[The origin of this delightful puzzle is obscure. The Book of Ingenious & Diabolical
Puzzles by Jerry Slocum and Jack Botermans (1994) shows a 2-loop version carved from
horn, probably made in China about 1850 [page 101], and a modern 6-loop version
made in Malaysia about 1988 [page 93]. Slocum also owns a 4-loop version made from
bamboo in England about 1884. He has found it listed in Henry Novra's Catalogue of
Conjuring Tricks and Puzzles (1858 or 1859) and W. H. Cremer's Games, Amusements,
Pastimes and Magic (1867), as well as in Hamleys' catalog of 1895, under the name
"Marvelous Canoe Puzzle." Dyckman noted its connection to reflected Gray ternary
in a letter to Martin Gardner, dated 2 August 1972.]

84. By (50), element [ b;t; b

0

t0 ] of \Gamma \Theta \Gamma 

0 is ff

aff

0
a0 if rg([

b;

t;

b0

t0 ]) = [

a;

t;

a0

t0 ] in the reflected Gray

code for radices (t; t0). We can now show that element [ b;t; b

0;

t0;

b00

t00 ] of both (\Gamma \Theta \Gamma 

0) \Theta \Gamma 00

and \Gamma  \Theta  (\Gamma 0 \Theta  \Gamma 00) is ffa ff0a0ff00a00 if rg([ b;t; b

0;

t0;

b00

t00 ]) = [

a;

t;

a0;

t0;

a00

t00 ] in the reflected Gray code

55

56 ANSWERS TO EXERCISES 7.2.1.1
for radices (t; t0; t00). See exercise 4.1-10, and note also the mixed-radix law

m1 : : : mn \Gamma  1 \Gamma 

h

x1;

m1;

: : : ;
: : : ;

xn
mn

i

=

h

m1 \Gamma  1 \Gamma  x1;

m1;

: : : ;
: : : ;

mn \Gamma  1 \Gamma  xn

mn

i

:

In general, the reflected Gray code for radices (m1; : : : ; mn) is (0; : : : ; m1 \Gamma  1) \Theta  \Delta  \Delta  \Delta  \Theta 
(0; : : : ; mn \Gamma  1). [Information Processing Letters 22 (1986), 201-205.]

85. Let \Gamma mn be the reflected m-ary Gray path, which can be defined by \Gamma m0 = ffl and

\Gamma m(n+1) = (0; 1; : : : ; m \Gamma  1)\Theta \Gamma mn; n * 0:
This path runs from (0; 0; : : : ; 0) to (m\Gamma 1; 0; : : : ; 0) when m is even. Consider the Gray
path \Pi mn defined by \Pi m0 = ; and

\Pi m(n+1) =

(

(0; 1; : : : ; m \Gamma  1)\Theta \Pi mn; m\Gamma R(m+1)n; if m is odd;

(0; 1; : : : ; m)\Theta \Pi mn; m\Gamma Rmn; if m is even.

This path traverses all of the (m + 1)n \Gamma  mn nonnegative integer n-tuples for which
max(a1; : : : ; an) = m, starting with (0; : : : ; 0; m) and ending with (m; 0; : : : ; 0). The
desired infinite Gray path is \Pi 0n, \Pi R1n, \Pi 2n, \Pi R3n, : : : .

86. This is impossible when n is odd, because the n-tuples with max(ja1j; : : : ; janj) = 1
include 12 (3n + 1) with odd parity and 12 (3n \Gamma  3) with even parity. When n = 2
we can use a spiral \Sigma 0, \Sigma 1, \Sigma 2, : : : , where \Sigma m winds clockwise from (m; 1 \Gamma  m) to
(m; \Gamma m) when m ? 0. For even values of n * 2, if Tm is a path of n-tuples from
(m; 1 \Gamma  m; m \Gamma  1; 1 \Gamma  m; : : : ; m \Gamma  1; 1 \Gamma  m) to (m; \Gamma m; m; \Gamma m; : : : ; m; \Gamma m), we can use
\Sigma m \Theta  (T0; : : : ; Tm\Gamma 1); (\Sigma 0; : : : ; \Sigma m)R \Theta  Tm for (n + 2)-tuples with the same property,
where \Theta  is the dual operation

\Gamma \Theta \Gamma 0 = (ff0ff00; : : : ; fft\Gamma 1ff00; fft\Gamma 1ff01; : : : ; ff0ff01; ff0ff02; : : : ; fft\Gamma 1ff02; fft\Gamma 1ff03; : : : ):

[Infinite n-dimensional Gray paths without the magnitude constraint were first constructed by E. V'azsonyi, Acta Litterarum ac Scientiarum, sectio Scientiarum Mathematicarum 9 (Szeged: 1938), 163-173.]

87. It would visit all the subforests again, but in reverse order, ending with (0; : : : ; 0)
and returning to the state it had after the initialization step K1. (This reflection
principle is, in fact, the key to understanding how Algorithm K works.)

88. (a) Let M0 = ffl, M1 = q, and Mn+2 = q MRn+1; MRn . This construction works
because the last element of MRn+1 is the first element of Mn+1, namely a dot followed
by the first element of MRn .

(b) Given a string d1 : : : dl where each dj is q or , we can find its successor by
letting k = l \Gamma  [dl = q] and proceeding as follows: If k is odd and dk = q, change dkdk+1
to ; if k is even and dk = , change dk to q q; otherwise decrease k by 1 and repeat
until either making a change or reaching k = 0. The successor of the given word is

q q q q q q q.

89. A cycle can exist only when the number of code words is even, since the number
of dashes changes by \Sigma 1 at each step. Thus we must have n mod 3 = 2. The Gray
paths Mn of exercise 88 are not suitable; they begin with ( q )bn=3c qn mod 3 and end
with ( q)bn=3c q[n mod 3=1] [n mod 3=2]. But M3k+1 q, MR3k is a Hamiltonian circuit
in the Morse code graph when n = 3k + 2.

56

7.2.1.1 ANSWERS TO EXERCISES 57

90. Given a Morse code sequence d1 : : : dl of length n + 1, set a0  1, j  1, k  1,
and repeat the following until k ? l: If dk = q, set aj  1 \Gamma  aj\Gamma 1, k  k + 1, j  j + 1;
otherwise set aj  aj+1  aj\Gamma 1, j  j + 2, k  k + 1. (Then an+1 will have been set
to n mod 2.) Under this correspondence we can convert the path Mn+1 of exercise 88
into a procedure like Algorithm K, with the fringe containing the indices where each
dot or dash begins (except for a final dot).

Q1. [Initialize.] Set aj  b((j \Gamma  1) mod 6)=3c and fj  j for 1 ^ j ^ n. Also set

f0  0, r0  1, l1  0, rj  j + (j mod 3) and lj+(j mod 3)  j for 1 ^ j ^ n,
except if j +(j mod 3) ? n set rj  0 and l0  j. (The "fringe" now contains
1, 2, 4, 5, 7, 8, : : : .)

Q2. [Visit.] Visit the n-tuple (a1; : : : ; an).
Q3. [Choose p.] Set q  l0, p  fq, fq  q.
Q4. [Check ap.] Terminate the algorithm if p = 0. Otherwise set ap  1 \Gamma  ap and

go to Q6 if ap + p is now even.

Q5. [Insert p +1.] If p ! n, set q  rp, lq  p+1, rp+1  q, rp  p+ 1, lp+1  p.

Go to Q7.

Q6. [Delete p + 1.] If p ! n, set q  rp+1, rp  q, lq  p.
Q7. [Make p passive.] Set fp  flp and flp  lp. Return to Q2.

This algorithm can also be derived as a special case of a considerably more general
method due to Gang Li, Frank Ruskey, and D. E. Knuth, which extends Algorithm K
by allowing the user to specify either ap * aq or ap ^ aq for each (parent; child) pair
(p; q). [To appear.] A generalization in another direction, which produces all strings of
length n that do not contain certain substrings, has been discovered by M. B. Squire,
Electronic J. Combinatorics 3 (1996), #R17, 1-29.

91. Yes, because the digraph of all (n\Gamma 1)-tuples (x1; : : : ; xn\Gamma 1) with x1; : : : ; xn\Gamma 1 ^ m
and with arcs (x1; : : : ; xn\Gamma 1) ! (x2; : : : ; xn) whenever max(x1; : : : ; xn) = m is connected and balanced; see Theorem 2.3.4.2G. Indeed, we get such a sequence from
Algorithm F if we note that the final kn elements of the prime strings of length
dividing n, when subtracted from m \Gamma  1, are the same for all m * k. When n = 4, for
example, the first 81 digits of the sequence \Phi 4 are 2 \Gamma  ffR = 0 0001 01 0011 : : : , where
ff is the string (62). [There also are infinite m-ary sequences whose first mn elements
are de Bruijn cycles for all n, given any fixed m * 3. See L. J. Cummings and D.
Wiedemann, Cong. Numerantium 53 (1986), 155-160.]

92. The cycle generated by f() is a cyclic permutation of ff1, where ff has length mn\Gamma 1
and ends with 1n\Gamma 1. The cycle generated by Algorithm R is a cyclic permutation of
fl = c0 : : : cmn+1\Gamma 1, where ck = (c0 + b0 + \Delta  \Delta  \Delta  + bk\Gamma 1) mod m and b0 : : : bmn+1\Gamma 1 =
fi = ffm1m.

If x0 : : : xn occurs in fl, say xj = ck+j for 0 ^ j ^ n, then yj = bk+j for 0 ^ j ! n,
where yj = (xj+1 \Gamma  xj) mod m. [This is the connection with modular m-ary Gray code;
see exercise 78.] Now if y0 : : : yn\Gamma 1 = 1n we have mn+1 \Gamma  m \Gamma  n ! k ^ mn+1 \Gamma  n;
otherwise there is an index k0 such that \Gamma n ! k0 ! mn \Gamma  n and y0 : : : yn\Gamma 1 occurs in
fi at positions k = (k0 + r(mn \Gamma  1)) mod mn+1 for 0 ^ r ! m. In both cases the m
choices of k have different values of x0, because the sum of all elements in ff is m \Gamma  1
(modulo m) when n * 2. [Algorithm R is valid also for n = 1 if m mod 4 6= 2, because
m ?

P

ff in that case.]

57

58 ANSWERS TO EXERCISES 7.2.1.1
93. 0010203041121314223243344. (The underlined digits are effectively inserted
into the interleaving of 00112234 with 34. Algorithm D can be used in general when
n = 1 and r = m \Gamma  2 * 0; but it is pointless to do so, in view of (54).)

94. (a) Let c0 c1c2 : : : have period r. If r is odd we have p = q = r, so r = pq only in
the trivial case when p = q = 1 and a0 = b0. Otherwise r=2 = lcm(p; q) = pq=gcd(p; q)
by 4.5.2-(10), hence gcd(p; q) = 2. In the latter case the 2n-tuples cl cl+1 : : : cl+2n\Gamma 1
that occur are ajbk : : : aj+n\Gamma 1bk+n\Gamma 1 for 0 ^ j ! p, 0 ^ k ! q, j j k (modulo 2), and
bkaj : : : bk+n\Gamma 1aj+n\Gamma 1 for 0 ^ j ! p, 0 ^ k ! q, j 6j k (modulo 2).

(b) The output would interleave two sequences a0a1 : : : and b0b1 : : : whose periods
are respectively mn + r and mn \Gamma  r; the a's are the cycle of f() with xn changed to
xn+1 and the b's are the cycle of g() with xn changed to xn\Gamma 1, for 0 ^ x ! r. By
(58) and part (a), the period length is m2n \Gamma  r2, and every 2n-tuple occurs with the
exception of (xy)n for 0 ^ x; y ! r.

(c) The real step D6 alters the behavior of (b) by going to D3 when t * n and
0 ^ x0 = x ! r; this emits an extra x at the time when x2n\Gamma 1 has just been output and
b is about to be emitted, where b is the digit following xn in g's cycle. D6 also allows
control to pass to D7 and then D3 with t0 = n in the case that t * n and x ! x0 ! r;
this emits an extra x0x at the time when (xx0)n\Gamma 1x has just been output and b will be
next. These r2 extra bits provide the r2 missing 2n-tuples of (b).

95. (a) The recurrences S2 = 1, S2n+1 = S2n = 2Sn, R2 = 0, R2n+1 = 1 + R2n,
R2n = 2Rn, D2 = 0, D2n+1 = D2n = 1 + 2Dn have the solution Sn = 2blg nc\Gamma 1,
Rn = n \Gamma  2Sn, Dn = Sn \Gamma  1. Thus Sn + Rn + Dn = n \Gamma  1.

(b) Each top-level output usually involves blg nc \Gamma  1 D-activations and *(n) \Gamma  1
R-activations, plus one basic activation at the bottom level. But there are exceptions:
Algorithm R might invoke its f() twice, if the first activation completed a sequence 1n;
and sometimes Algorithm R doesn't need to invoke f() at all. Algorithm D might
invoke its g() twice, if the first activation completed a sequence (x0)n; but sometimes
Algorithm D doesn't need to invoke either f() or g().

Algorithm R completes a sequence xn+1 if and only if its child f() has just
completed a sequence 0n. Algorithm D completes a sequence x2n for x ! r if and
only if if has just jumped from D6 to D3 without invoking any child.

From these observations we can conclude that at most blg nc+ *(n)+ 1 activations
are possible per top-level output, if r ? 1; such a case happens when Algorithm D
for n = 6 goes from D6 to D4. But when r = 1 we can have as many as 2blg nc + 3
activations, for example when Algorithm R for n = 25 goes from R4 to R2.

96. (a) (0011), (00011101), (0000101001111011), and (00000110001011011111
001110101001). Thus j2 = 2, j3 = 3, j4 = 9, j5 = 15.

(b) We obviously have fn+1(k) = \Sigma fn(k) mod 2 for 0 ^ k ! jn + n. The next
value, fn+1(jn + n), depends on whether step R4 jumps to R2 after computing y =
fn(jn+n\Gamma 1). If it does (namely, if fn+1(jn+n\Gamma 1) 6= 0), we have fn+1(k) j 1+\Sigma (k+1)
for jn + n ^ k ! 2n + jn + n; otherwise we have fn+1(k) j 1 + \Sigma (k \Gamma  1) for those
values of k. In particular, fn+1(k) = 1 when 2n ^ k + ffin ^ 2n+ n. The stated formula,
which has simpler ranges for the index k, holds because 1 + \Sigma (k \Sigma  1) j \Sigma (k) when
jn ! k ! jn + n or 2n+ jn ! k ! 2n + jn + n.

(c) The interleaved cycle has cn(2k) = f+n (k) and cn(2k + 1) = f\Gamma n (k), where

f+n (k) =

ae

fn(k\Gamma 1); if 0 ! k ^ jn+1;

fn(k\Gamma 2); if jn +1 ! k ^ 2n+2;

f\Gamma n (k) =

ae

fn(k+1); if 0 ^ k ! jn;

fn(k+2); if jn ^ k ! 2n\Gamma 2;

58

7.2.1.1 ANSWERS TO EXERCISES 59
f+n (k) = f+n (k mod (2n + 2)), f\Gamma n (k) = f\Gamma n (k mod (2n \Gamma  2)). Therefore the subsequence
12n\Gamma 1 begins at position kn = (2n\Gamma 1 \Gamma  2)(2n + 2) + 2jn + 2 in the cn cycle; this will
make j2n odd. The subsequence (01)n\Gamma 10 begins at position ln = (2n\Gamma 1 + 1)(jn \Gamma  1) if
jn mod 4 = 1, at ln = (2n\Gamma 1 + 1)(2n + jn \Gamma  3) if jn mod 4 = 3. Also k2 = 6, l2 = 2.

(d) Algorithm D inserts four elements into the cn cycle; hence

when jn mod 4!3 (ln!kn):

f2n(k)=

8
!

:

cn(k\Gamma 1); if 0!k^ln+2;
cn(k\Gamma 3); if ln+2!k^kn+3;
cn(k\Gamma 4); if kn+3!k^22n;

when jn mod 4=3 (kn!ln):

=

8
!

:

cn(k\Gamma 1); if 0!k^kn +1;
cn(k\Gamma 2); if kn+1!k^ln+3;
cn(k\Gamma 4); if ln+3!k^22n.

(e) Consequently j2n = kn + 1 + 2[jn mod 4 ! 3]. Indeed, the elements preceding
12n consist of 2n\Gamma 2 \Gamma  1 complete periods of f+n () interleaved with 2n\Gamma 2 complete
periods of f\Gamma n (), with one 0 inserted and also with 10 inserted if ln ! kn, followed
by fn(1)fn(1)fn(2)fn(2) : : : fn(jn \Gamma  1)fn(jn \Gamma  1). The sum of all these elements is odd,
unless ln ! kn; therefore ffi2n = 1 \Gamma  2[jn mod 4 = 3].

Let n = 2tq, where q is odd and n ? 2. The recurrences imply that, if q = 1, we
have jn = 2n\Gamma 1+ bt where bt = 2t=3 \Gamma  (\Gamma 1)t=3. And if q ? 1 we have jn = 2n\Gamma 1\Sigma  bt+2,
where the + sign is chosen if and only if blg qc + [b4q=2blg qcc = 5] is even.

97. If f(k) = g(k) when k lies in a certain range, there's a constant C such that
\Sigma f(k) = C + \Sigma g(k) for k in that range. We can therefore continue almost mindlessly
to derive additional recurrences: If n ? 1 we have

\Sigma f2n(k); when jn mod 4 ! 3 (ln ! kn):

j

8
!

:

\Sigma cn(k\Gamma 1); if 0 ! k ^ ln+2;
1+\Sigma cn(k\Gamma 3); if ln+2 ! k ^ kn+3;
\Sigma cn(k\Gamma 4); if kn+3 ! k ^ 22n;

when jn mod 4 = 3 (kn ! ln):

j

8
!

:

\Sigma cn(k\Gamma 1); if 0 ! k ^ kn+1;
1+\Sigma cn(k\Gamma 2); if kn+1 ! k ^ ln+3;
\Sigma cn(k\Gamma 4); if ln+3 ! k ^ 22n.

\Sigma cn(k) j \Sigma f+n (dk=2e) + \Sigma f\Gamma n (bk=2c):

\Sigma f+n (k)j

ae

\Sigma fn(k\Gamma 1); if 0!k^jn +1;

1+\Sigma fn(k\Gamma 2); if jn +1!k^2n +2;

\Sigma f\Gamma n (k)j

ae

\Sigma fn(k+1); if 0^k!jn;

1+\Sigma fn(k+2); if jn^k!2n \Gamma 2;

\Sigma f\Sigma n (k) j bk=(2n \Sigma  2)c + \Sigma f\Sigma n (k mod (2n \Sigma  2)); \Sigma fn(k) = \Sigma fn(k mod 2n):

\Sigma f2n+1(k) j

ae

\Sigma \Sigma f2n(k); if 0 ! k ^ j2n or 22n + j2n ! k ^ 22n+1;

1 + k + \Sigma \Sigma f2n(k + ffi2n); if j2n ! k ^ 22n + j2n.

\Sigma \Sigma f2n(k); when jn mod 4!3 (ln!kn):

j

8
!

:

\Sigma \Sigma cn(k\Gamma 1); if 0!k^ln+2;
1+k+\Sigma \Sigma cn(k\Gamma 3); if ln+2!k^kn +3;
\Sigma \Sigma cn(k\Gamma 4); if kn+3!k^22n;

when jn mod 4=3 (kn!ln):

j

8
!

:

\Sigma \Sigma cn(k\Gamma 1); if 0!k^kn +1;
1+k+\Sigma cn(k\Gamma 2); if kn+1!k^ln+3;
1+\Sigma \Sigma cn(k\Gamma 4); if ln+3!k^22n.

\Sigma \Sigma f2n(k) j [jn mod 4 ! 3]bk=22nc + \Sigma \Sigma f2n(k mod 22n):
And then, aha, there is closure:

\Sigma \Sigma cn(2k) = \Sigma f+n (k); \Sigma \Sigma cn(2k + 1) = \Sigma f\Gamma n (k):
If n = 2t q where q is odd, the running time to evaluate fn(k) by this system of
recursive formulas is O(t + S(q)), where S(1) = 1, S(2k) = 1 + 2S(k), and S(2k + 1) =
1 + S(k). Clearly S(k) ! 2k, so the evaluations involve at most O(n) simple operations
on n-bit numbers. In fact, the method is often significantly faster: If we average S(k)

59

60 ANSWERS TO EXERCISES 7.2.1.1
over all k with blg kc = s we get (3s+1 \Gamma  2s+1)=2s, which is less than 3klg(3=2) ! 3k0:59.
(Incidentally, if k = 2s+1 \Gamma  1 \Gamma  (2s\Gamma e1 + 2s\Gamma e2 + \Delta  \Delta  \Delta  + 2s\Gamma et) we have S(k) = s + 1 +
et + 2et\Gamma 1 + 4et\Gamma 2 + \Delta  \Delta  \Delta  + 2te1.)

98. A string that starts at position k in fn() starts at position k+ = k + 1 + [k ? jn] in
f+n () and at position k\Gamma  = k \Gamma  1 \Gamma  [k ? jn] in f\Gamma n (), except that 0n and 1n occur twice
in f+n () but not at all in f\Gamma n ().

To find fl = a0b0 : : : an\Gamma 1bn\Gamma 1 in the cycle f2n(), let ff = a0 : : : an\Gamma 1 and fi =
b0 : : : bn\Gamma 1. Suppose ff starts at position j and fi at position k in fn(), and assume
that neither ff nor fi is 0n or 1n. If j+ j k+ (modulo 2), let l=2 be a solution to the
equation j+ + (2n+ 2)x = k\Gamma  + (2n\Gamma  2)y; we may take l=2 = k + (2n\Gamma  2)(2n\Gamma 3(j \Gamma  k)
mod (2n\Gamma 1 + 1)) if j * k, otherwise l=2 = j + (2n + 2)(2n\Gamma 3(k \Gamma  j) mod (2n\Gamma 1 \Gamma  1)).
Otherwise let (l \Gamma  1)=2 = k+ + (2n+ 2)x = j\Gamma  + (2n\Gamma  2)y. Then fl starts at position l
in the cycle cn(); hence it starts at position l + 1 + [l * kn ] + 2[l * ln ] in the cycle f2n().
Similar formulas hold when ff 2 f0n; 1ng or fi 2 f0n; 1ng (but not both). Finally,
02n, 12n, (01)n, and (10)n start respectively in positions 0, j2n, ln + 1 + [kn ! ln], and
ln + 2 + [kn ! ln].

To find fi = b0b1 : : : bn in fn+1() when n is even, suppose that the n-bit string
(b0 \Phi  b1) : : : (bn\Gamma 1 \Phi  bn) starts at position j in fn(). Then fi starts at position k =
j \Gamma  ffin[j * jn] + 2n[j = jn][ffin = 1] if fn+1(k) = b0, otherwise at position k + (2n \Gamma  ffin;
ffin; 2n + ffin) according as (j!jn; j=jn; j?jn).

The running time of this recursion satisfies T (n) = O(n) + 2T (bn=2c), so it is
O(n log n). [Exercises 96-98 are based on the work of J. Tuliani, who also has developed
methods for certain larger values of m; see Discrete Math. 226 (2001), 313-336.]

99. No obvious defects are apparent, but extensive testing should be done before any
sequence can be recommended. By contrast, the de Bruijn cycle produced implicitly
by Algorithm F is a terrible source of supposedly random bits, even though it is ndistributed in the sense of Definition 3.5D, because 0s predominate at the beginning.
Indeed, when n is prime, bits tn + 1 of that sequence are zero for 0 ^ t ! (2n \Gamma  2)=n.

100. When n = p is prime, (59) tells us that Lm(1) + pLm(p) = mp, and we also
have Lm(1) = m. [This combinatorial proof provides an interesting contrast to the
traditional algebraic proof of Theorem 1.2.4F.]

101. The 4483 nonprimes are abaca, agora, ahead, : : : ; the 1274 primes are : : : , rusts,
rusty, rutty. (Since prime isn't prime, we should perhaps call prime strings lowly.)

102. (a) Let fi be a proper suffix of **0 with fi ^ **0. Either fi is a suffix of *0, whence
* ! *0 ^ fi, or fi = ff*0 and we have * ! ff ! fi.

Now * ! fi ^ **0 implies that fi = *fl for some fl ^ *0. But fl is a suffix of fi with
1 ^ jflj = jfij \Gamma  j*j ! j*0j; hence fl is a proper suffix of *0, and *0 ! fl. Contradiction.

(b) Any string of length 1 is prime. Combine adjacent primes by (a), in any
order, until no further combination is possible. [See the more general results of M. P.
Sch"utzenberger, Proc. Amer. Math. Soc. 16 (1965), 21-24.]

(c) If t 6= 0, let * be the smallest suffix of *1 : : : *t. Then * is prime by definition,
and it has the form fifl where fi is a nonempty suffix of some *j. Therefore *t ^ *j ^
fi ^ fifl = * ^ *t, so we must have * = *t. Remove *t and repeat until t = 0.

(d) True. For if we had ff = *fi for some prime * with j*j ? j*1j, we could
append the factors of fi to obtain another factorization of ff.

(e) 3 \Delta  1415926535897932384626433832795 \Delta  02884197. (Knowing more digits of ss
would not change the first two factors. The infinite decimal expansion of any number

60

7.2.1.1 ANSWERS TO EXERCISES 61
that is "normal" in the sense of Borel (see Section 3.5) factors into primes of finite
length.)

103. We must have 1=(1 \Gamma  mz) = 1=

Q1

n=1(1 \Gamma  z

n)Lm(n). This implies (60) as in

exercise 4.6.2-4.

104. (a) Let ff0 be ff with its last letter increased, and suppose ff0 = fifl0 where ff = fifl
and fi 6= ffl, fl 6= ffl. Let ` be the prefix of ff with j`j = jflj. By hypothesis there is a string
! such that ff! is prime; hence ` ^ ff! ! fl!, so we must have ` ^ fl. Consequently
` ! fl0, and we have ff0 ! fl0.

(b) Let ff = *1fi = a1 : : : an where *1fi! is prime. The condition *1fi! ! fi!
implies that aj ^ aj+r for 1 ^ j ^ n\Gamma r, where r = j*1j. But we cannot have aj ! aj+r;
otherwise ff would begin with a prime longer than *1, contradicting exercise 102(d).

(c) If ff is the n-extension of both * and *0, where j*j ? j*0j, we must have
* = (*0)q` where ` is a proper prefix of *0. But then ` ! *0 ! * ! `.

105. B1. [Initialize.] Set a1  \Delta  \Delta  \Delta   an  m \Gamma  1, an+1  \Gamma 1, and j  1.

B2. [Visit.] Visit (a1; : : : ; an) with index j.
B3. [Subtract one.] Terminate if aj = 0. Otherwise set aj  aj \Gamma  1, and

ak  m \Gamma  1 for j ! k ^ n.

B4. [Prepare to factor.] (According to exercise 104(b), we now want to find the

first prime factor *1 of a1 : : : an.) Set j  1 and k  2.

B5. [Find the new j.] (Now a1 : : : ak\Gamma 1 is the (k \Gamma  1)-extension of the prime

a1 : : : aj.) If ak\Gamma j ? ak, return to B2. Otherwise, if ak\Gamma j ! ak, set j  k.
Then increase k by 1 and repeat this step.

The efficient factoring algorithm in steps B4 and B5 is due to J. P. Duval, J. Algorithms
4 (1983), 363-381. For further information, see Cattell, Ruskey, Sawada, Serra, and
Miers, J. Algorithms 37 (2000), 267-282.

106. The number of n-tuples visited is Pm(n) =

Pn

j=1 Lm(j). Since Lm(n) =

1
n m

n +

O(mn=2=n), we have Pm(n) = Q(m; n) + O(Q(

p

m; n)), where

Q(m; n) =

nX

k=1

mk

k

=

mn

n

R(m; n);

R(m; n) =

n\Gamma 1X

k=0

m\Gamma k
1 \Gamma  k=n

=

n=2X

k=0

m\Gamma k
1 \Gamma  k=n

+ O(nm\Gamma n=2)

=

m

m \Gamma  1

t\Gamma 1X

j=0

1
nj

X

l

D

j

l

E

ml

(m \Gamma  1)j

+ O(n\Gamma t):

The main contributions to the running time come from the loops in steps F3 and F5,
which cost n \Gamma  j for each prime of length j, hence a total of nP (n) \Gamma 

Pn

j=1 j Lm(j) =
mn+1=((m \Gamma  1)2n) + O(1=(mn2)). This is less than the time needed to output the mn

individual digits of the de Bruijn cycle.

107. (a) If ff 6= 9 : : : 9, we have *k+1 ^ fi9jffj, because the latter is prime.

(b) We can assume that fi is not all 0s, since 9j0n\Gamma j is a substring of *t\Gamma 1*t*1*2 =
89n0n1. Let k be maximal with fi ^ *k; then *k ^ fiff, so fi is a prefix of *k. Since
fi is a preprime, it is the jfij-extension of some prime fi0 ^ fi. The preprime visited by

61

62 ANSWERS TO EXERCISES 7.2.1.1
Algorithm F just before fi0 is (fi0 \Gamma  1)9n\Gamma jfi

0j

, by exercise 105, where fi0 \Gamma  1 denotes the

decimal number that is one less than fi0. Thus, if fi0 is not *k\Gamma 1, the hint (which also
follows from exercise 105) implies that *k\Gamma 1 ends with at least n \Gamma  jfi0j * n \Gamma  jfij 9s,
and ff is a suffix of *k\Gamma 1. On the other hand if fi0 = *k\Gamma 1, ff is a suffix of *k\Gamma 2, and fi
is a prefix of *k\Gamma 1*k.

(c) If ff 6= 9 : : : 9, we have *k+1 ^ (fiff)d\Gamma 1fi9jffj, because the latter is prime.
Otherwise *k\Gamma 1 ends with at least (d \Gamma  1)jfiffj 9s, and *k+1 ^ (fiff)d\Gamma 19jfiffj, so (fffi)d
is a substring of *k\Gamma 1*k*k+1.

(d) Within the primes 135899135914, 787899787979, 12999913131314, 09090911,
089999 09 090911, 089999 119 119122.

[In all cases, the position of a1 : : : an precedes the position of a1 : : : an\Gamma 1(an + 1),
if 0 ^ an ! 9 (and if we assume that strings like 9j0n\Gamma j occur at the beginning).
Furthermore 9j0n\Gamma j\Gamma 1 occurs only after 9j\Gamma 10n\Gamma ja has appeared for 1 ^ a ^ 9, so we
must not place 0 after 9j0n\Gamma j\Gamma 1. Therefore no m-ary de Bruijn cycle of length mn can
be lexicographically smaller than *1 : : : *t.]

108. Suppose we want to locate the submatrix

`

(wn\Gamma 1 : : : w1w0)2 (xn\Gamma 1 : : : x1x0)2

(yn\Gamma 1 : : : y1y0)2 (xn\Gamma 1 : : : z1z0)2

'

:

The binary case n = 1 is the given example, and if n ? 1 we can assume by induction
that we only need to determine the leading bits a2n\Gamma 1, a2n\Gamma 2, b2n\Gamma 1, and b2n\Gamma 2. The
case n = 3 is typical: We must solve

b5 = w2; b4 = x2; a5 \Phi  b5 = y2; a4 \Phi  b4 = z2; if a0 = 0, b0 = 0;
b4 = w2; b05 = x2; a4 \Phi  b4 = y2; a5 \Phi  b05 = z2; if a0 = 0, b0 = 1;
a5 \Phi  b5 = w2; a4 \Phi  b4 = x2; b5 = y2; b4 = z2; if a0 = 1, b0 = 0;
a4 \Phi  b4 = w2; a5 \Phi  b05 = x2; b4 = y2; b05 = z2; if a0 = 1, b0 = 1;

here b05 = b5 \Phi  b4b3b2b1 takes account of carrying when j becomes j + 1.

109. Let a0a1 : : : am2\Gamma 1 be an m-ary de Bruijn cycle, such as the first m2 elements of
(54). If m is odd, let aij = aj when i is even, aij = a(j+(i\Gamma 1)=2) mod m2 when i is odd.
[The first of many people to discover this construction seems to have been John C.
Cock, who also constructed de Bruijn toruses of other shapes and sizes in Discrete
Math. 70 (1988), 209-210.]

If m = m0m00 where m0 ? m00, we use the Chinese remainder theorem to define

aij j a0ij (modulo m0) and aij j a00ij (modulo m00)
in terms of matrices that solve the problem for m0 and m00. Thus the previous exercise
leads to a solution for arbitrary m.

Another interesting solution for even values of m was found by Zolt'an T'oth
[2nd Conf. Automata, Languages, and Programming Systems (1988), 165-172; see also
Hurlbert and Isaak, Contemp. Math. 178 (1994), 153-160]. The first m2 elements aj
of the infinite sequence

0011 021331203223 04152435534251405445 0617263746577564 : : : 07667 08 : : :
define a de Bruijn cycle with the property that the distance between the appearances
of ab and ba is always even. Then we can let aij = aj if i + j is even, aij = ai if i + j

62

7.2.1.1 ANSWERS TO EXERCISES 63
is odd. For example, when m = 4 we have

0

B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
@

0 0 1 0 0 2 1 2 2 0 3 0 2 2 3 2
0 0 0 1 0 2 0 3 2 0 2 1 2 2 2 3
0 1 1 1 0 3 1 3 2 1 3 1 2 3 3 3
1 0 1 1 1 2 1 3 3 0 3 1 3 2 3 3
0 0 1 0 0 2 1 2 2 0 3 0 2 2 3 2
0 2 0 3 0 0 0 1 2 2 2 3 2 0 2 1
0 1 1 1 0 3 1 3 2 1 3 1 2 3 3 3
1 2 1 3 1 0 1 1 3 2 3 3 3 0 3 1
0 0 1 0 0 2 1 2 2 0 3 0 2 2 3 2
2 0 2 1 2 2 2 3 0 0 0 1 0 2 0 3
0 1 1 1 0 3 1 3 2 1 3 1 2 3 3 3
3 0 3 1 3 2 3 3 1 0 1 1 1 2 1 3
0 0 1 0 0 2 1 2 2 0 3 0 2 2 3 2
2 2 2 3 2 0 2 1 0 2 0 3 0 0 0 1
0 1 1 1 0 3 1 3 2 1 3 1 2 3 3 3
3 2 3 3 3 0 3 1 1 2 1 3 1 0 1 1

1
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
A

(exercise 108);

0
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
@

0 0 1 0 0 0 1 0 3 0 2 0 3 0 2 0
0 0 0 1 0 2 0 3 0 1 0 0 0 2 0 3
0 1 1 1 0 1 1 1 3 1 2 1 3 1 2 1
1 0 1 1 1 2 1 3 1 1 1 0 1 2 1 3
0 0 1 0 0 0 1 0 3 0 2 0 3 0 2 0
2 0 2 1 2 2 2 3 2 1 2 0 2 2 2 3
0 1 1 1 0 1 1 1 3 1 2 1 3 1 2 1
3 0 3 1 3 2 3 3 3 1 3 0 3 2 3 3
0 3 1 3 0 3 1 3 3 3 2 3 3 3 2 3
1 0 1 1 1 2 1 3 1 1 1 0 1 2 1 3
0 2 1 2 0 2 1 2 3 2 2 2 3 2 2 2
0 0 0 1 0 2 0 3 0 1 0 0 0 2 0 3
0 3 1 3 0 3 1 3 3 3 2 3 3 3 2 3
2 0 2 1 2 2 2 3 2 1 2 0 2 2 2 3
0 2 1 2 0 2 1 2 3 2 2 2 3 2 2 2
3 0 3 1 3 2 3 3 3 1 3 0 3 2 3 3

1
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
A

(T'oth).

110. (a) Let dj = j and 0 ^ aj ! 3 for 1 ^ j ^ 9, a9 6= 0. Form sequences sj, tj by the
rules s1 = 0, t1 = d1; tj+1 = dj+1 + 10tj[aj = 0] for 1 ^ j ! 9; sj+1 = sj + (0; tj; \Gamma tj)
for aj = (0; 1; 2) and 1 ^ j ^ 9. Then s10 is a possible result; we need only remember
the smallish values that occur. More than half the work is saved by disallowing ak = 2
when sk = 0, then using js10j instead of s10. Since fewer than 38 = 6561 possibilities
need to be tried, brute force via the ternary version of Algorithm M works well; fewer
than 24,000 mems and 1600 multiplications are needed to deduce that all integers less
than 211 are representable, but 211 is not.

Another approach, using Gray code to vary the signs after breaking the digits
into blocks in 28 possible ways, reduces the number of multiplications to 255, but at
the cost of about 500 additional mems. Therefore Gray code is not advantageous in
this application.

(b) Now (with 73,000 mems and 4900 multiplications) we can reach all numbers
less than 240, but not 240. There are 46 ways to represent 100, including the remarkable
9 \Gamma  87 + 6 + 5 \Gamma  43 + 210.

[H. E. Dudeney introduced his "century" problem in The Weekly Dispatch (4 and
18 June 1899); see also The Numerology of Dr. Matrix by Martin Gardner, Chapter 6.]

111. The method of exercise 110 now needs more than 167 million mems and 10 million
multiplications, because 316 is so much larger than 38. We can do much better (10.4
million mems, 1100 mults) by first tabulating the possibilities obtainable from the first
k and last k digits, for 1 ^ k ! 9, then considering all blocks of digits that use the 9.
There are 60,318 ways to represent 100, and the first unreachable number is 16,040.

63

INDEX AND GLOSSARY
When an index entry refers to a page containing a relevant exercise, see also the answer to
that exercise for further information. An answer page is not indexed here unless it refers to a
topic not included in the statement of the exercise.

2-adic numbers, 31.
4-cube, 42, 54.
8-cube, 17, 35.
*(k), see Lee weight, Sideways sum.
ss (circle ratio), 43, 60.
ae(k), see Ruler function.

Almost-linear recurrence, 23.
Analog-to-digital conversion, 3-4, 15.
Anti-Gray code, 35.
Antipodal words, 11.
Arima, Yoriyuki ( ), 41.
Artificial intelligence, 43.
Aubert, Jacques, 54.
Automorphisms, 49.

Balanced Gray code, 14-17, 35, 49.
Bandwidth of n-cube, 35.
baud: One transmission unit (e.g., one

bit) per second, 4.
Baudot, Jean Maurice 'Emile, 4-5.
Beckett, Samuel Barclay, 34-35.
Bennett, William Ralph, 4.
Bernstein, Arthur Jay, 44.
Binary Gray codes, 12-17, 33-35.
Binary number system, 1, 4.
Binary recurrences, 43, 59.
Binary trie, 30.
Bit reversal, 28, 31.
Bitwise operations, 4, 11-12, 32, 45.
Borel, 'Emile F'elix 'Edouard Justin, 60.
Borrow, 40.
Botermans, Jacobus [= Jack] Petrus

Hermana, 55.
Boustrophedon product, 36, 56.
Bruijn, Nicolaas Govert de, 22.

cycles, 22-27, 36-38, 62.
toruses, 38.
Buchner, Morgan Mallory, Jr., 44.

Calderbank, Arthur Robert, 43.
Canoe puzzle, 55.
Canonical delta sequence, 13, 49.
Cardano, Girolamo (= Hieronymus

Cardanus), 41.
Carry, 2, 62.
Castown, Rudolph W., 11.
Cattell, Kevin Michael, 61.
Cavior, Stephan Robert, 44.
Cayley, Arthur, Hamilton theorem, 45.
Center of gravity, 17.
Characteristic polynomial, 45.
Chen, Kuo-Tsai ( ), 26.

Chinese remainder theorem, 62.
Chinese ring puzzle, 5-6, 28, 41-42.
Cheng, Ching-Shui ( ), 54.
Cock, John Crowle, 62.
Cohn, Martin, 49, 51, 54.
Complementary Gray codes, 13, 16-17,

33, 49.
Compositions, 28-29.
Concatenation, 25, 35, 49.
Concurrent computing, 43.
Connected components, 34.
Coordinates, 13.
Coroutines, recursive, 24-25.
Cremer, William Henry, Jr., 55.
Cube, see n-cube.
Cube-connected computers, 43.
Cummings, Larry Jean, 57.
Cycle leaders, 31.
Cyclic shifts, 26.

Dally, William James, 43.
de Bruijn, Nicolaas Govert, 22.

cycles, 22-27, 36-38, 62.
toruses, 38.
Decimal number system, 2, 18-19, 39.
Delta sequence, 13.
Dilation of embedded graph, 35.
Discrete Fourier transform, 9, 27, 47.
Doubly linked list, 21, 56-57.
Douglas, Robert James, 48.
Dual boustrophedon product, 56.
Dudeney, Henry Ernest, 5, 63.
Duval, Jean Pierre, 61.
Dyckman, Howard Lloyd, 35, 55.

Edge covering, 35.
Ehrlich, Gideon (JILX@ OERCB), 9.
Enumeration, 1.
Error-correcting codes, 30.
Etzion, Tuvi (OIVR IAEH, born XVLED IAEH), 25.
Extension, 26.

Factorization of strings, 37.

algorithm for, 61.
Faloutsos, Christos (FaloO^tsoc, Qra*stoc), 43.
Fast Fourier transform, 28.
Fast Walsh transform, 32.
Fermat, Pierre de, theorem, 37.
Fibonacci, Leonardo, of Pisa, numbers, 36.
Field, finite, 32.
Five-letter words, 11, 32-33, 37.
Flores, Ivan, 54.
Focus pointers, 10-11, 20-21, 56-57.
Forest, 20-21.

64

64

INDEX AND GLOSSARY 65
Fourier, Jean Baptiste Joseph,

series, 7.
transform, discrete, 9, 28, 47.
Fox, Ralph Hartzler, 26.
Fredman, Michael Lawrence, 33, 47.
Fredricksen, Harold Marvin, 26, 27.
Fringe, 21, 56-57.

Gardner, Martin, 55, 63.
Generation, 1.

constant amortized time, 40.
loopless, 9-12, 20, 29, 36, 42.
Gilbert, Edgar Nelson, 33.
Gilbert, William Schwenck, 1.
Goddyn de la Vega, Luis Armando, 34, 50.
Gomes, Peter John, iii.
Gordian Knot puzzle, 35.
Gray, Elisha, 5.
Gray, Frank, 4.
Gray binary code, 2-12, 16, 28-33, 36.

permutation, 3, 31.
Gray binary trie, 30.
Gray code: A cycle of adjacent objects,

12, 20.
Gray code for n-tuples, 12.

advantages of, 6, 11-12.
binary, see Gray binary code.
limitations of, 40, 63.
nonbinary, 18-20, 35-36.
Gray fields, 31.
Gray path: A sequence of adjacent

objects, 15, 20.
Gray stream, 34.
Gray ternary code, 19, 36.
Gros, Luc Agathon Louis, 5.
Gvozdjak, Pavol, 34.

Hadamard, Jacques Salomon, 47.

transform, 9, 46-47.
Hamilton, William Rowan, see Cayley.

circuit, 13, 34.
path, 15.
Hamley, William, and sons, 55.
Hammons, Arthur Roger, Jr., 43.
Harmuth, Henning Friedolf, 7.
Hexadecimal puzzle, 42.
Hopcroft, John Edward, 44.
Hurlbert, Glenn Howland, 60.

in situ permutation, 28, 31.
in situ transformation, 9.
Inclusion and exclusion principle, 6.
Inline expansion, 11-12.
Interleaving, 36-37, 50, 62.
Internet, ii, iii.
Inverse function, 4, 31.
Isaak, Garth Timothy, 62.
Isomorphic Gray codes, 33-34.
Iteration of functions, 32, 45.

Japanese mathematics, 41.

Karnaugh, Maurice, 29.
Kedlaya, Kiran Sridhara, 49.
Keister, William, 42.
Kiefer, Jack Carl, 54.
Knuth, Donald Ervin ( ), i, iv, 57.
Koda, Yasunori ( ), 20-21.
Kronecker, Leopold, product, 46.
Kumar, Panganamala Vijay

( A*aU*A*ZA,Z A*A,e i a~N T^f y" A*A,e T^g), 43.

Larrivee, Jules Alphonse, 6.
Lawrence, George Melvin, 15, 50.
Lee, Chester C. Y., 42.

distance, 29.
weight, 29.
Lempel, Abraham (LTNL MDXA@), 25.
Lexicographic order, 2-3, 25, 29, 47.
Li, Gang (= Kenny) ( ), 57.
Lieves, 30.
Linked allocation, 28.
Listing, 1.
Loony Loop, 35-36.
Loopless generation, 9-12, 20, 29, 36, 42.
Luke, Saint (S,Agioc LoukR^c a* EI^aggelista*c),

40.
Lyndon, Roger Conant, 26.

words, 26.

m-ary digit: An integer between 0 and

m \Gamma  1, inclusive, 2, 22.
Macro-processor, 11.
Maiorana, James Anthony, 26, 27.
Mantel, Willem, 23.
Martin, Monroe Harnish, 27-28.
Matching, 33.
Matrix (Bush), Irving Joshua, 63.
McClintock, William Edward, 15.
Median, 31.
Miers, Charles Robert, 61.
Military sayings, 1.
Misra, Jayadev (jYedb miS[), 41.
Mitchell, Christopher John, 25.
Mixed-radix number system, 2, 19-21,

35, 54, 55.
MMIX, 39.
Modular Gray codes, 19-20, 35, 54.

decimal, 19.
m-ary, 24, 54, 57.
quaternary, 42, 49.
ternary, 46, 51.
Mollard, Michel, 48.
Monic polynomial, 42.
Monotonic binary Gray path, 15-18, 35.
Morse, Samuel Finley Breese, code, 36.
Moser, Leo, 48.
Multinomial coefficient, 29.

65

66 INDEX AND GLOSSARY
n-cube: The graph of n-bit strings,

adjacent when they differ in only one
position, 13, 15, 33-34.
subcubes of, 30-31.
n-distributed sequence, 60.
n-extension, 26.
n-tuple: a sequence or string of

length n, 1-2.
Nemeth, Evelyn (= Evi) Hollister Pratt, 50.
Neyman, Jerzy, 54.
Nonbinary Gray codes, 18-20, 35-36.
Nonlocal Gray codes, 16-17, 34.
Nordstrom, Alan W., 30.
Normal numbers, 60.
Novra, Henry, 55.

Octacode, 30.
Orthogonal vectors, 8, 32.
Ourotoruses, 38.

Paley, Raymond Edward Alan Christopher,

45-46.
functions, 32.
Parity bit, 6, 28, 29.
Paterson, Kenneth Graham, 25.
Perverse, Peter Quentin, 35.
Pi (ss), 43, 60.
Prefix of a string, 25.
Prepostorder, 42.
Preprime string, 26-28, 37.
Prime string, 25-28, 37.

factorization, 37, 61.
Primitive polynomial modulo p, 23, 45.
Principal subforest, 20-21.
Proper prefix or suffix, 25.
Pseudorandom bits, 37.
Pulse code modulation, 4.
Purkiss, Henry John, 28.

Quaternary n-tuples, 29, 49.
R&D method, 25, 37.
Rademacher, Hans, 8.

functions, 8, 32, 46.
Ramras, Mark Bernard, 50.
Random number generation, 37.
Reflected Gray codes, 19-21, 35, 54, 55.

decimal, 19.
ternary, 36.
Richards, Dana Scott, 36.
Right subcube, 30.
Ringel, Gerhard, 35.
Ritchie, Alistair English, 42.
Robinson, John Paul, 30, 49, 51.
Rosenbaum, Joseph, 54.
Ruler function, 6, 8, 12, 13, 47.

decimal, 19.
Run lengths, 15-17, 34, 50.
Ruskey, Frank, 20, 21, 28, 31, 33, 57, 61.

Salzer, Herbert Ellis, 44.
Sampson, John Laurence, 33, 48.
Savage, Carla Diane, 17-18, 28, 33, 35, 48.
Sawada, Joseph James, 61.
Sch"affler, Otto, 5.
Schneider, Bernadette, 54.
Sch"utzenberger, Marcel Paul, 60.
Sequency, 7.
Serra, Micaela, 61.
Shapiro, Harold Seymour, 33.
Shift register sequences, 22-28, 36-38.
Sideways sum, 15, 44.
Silverman, Jerry, 33, 48, 49.
Sloane, Neil James Alexander, 43.
Slocum, Gerald Kenneth [= Jerry], 55.
Sol'e, Patrick, 43.
SpinOut puzzle, 42.
Squire, Matthew Blaze, 57.
Stahnke, Wayne Lee, 23.
Standard sequences, 26.
Stanford GraphBase, ii, iii, 11, 32-33, 37.
Steiglitz, Kenneth, 44.
Stevens, Brett, 34.
Stewart, Ian Nicholas, 38.
Stibitz, George Robert, 4, 6.
Subcubes, 30-31.
Subforests, 20-21, 36.
Subsets, 1, 6.
Suffix of a string, 25.
Sums of squares, 32.
Sylvester, James Joseph, 32, 47.

Tangle puzzle, see Loony Loop.
Taylor, Lloyd William, 5.
Telephone, 5.
Television, 4.
Ternary n-tuples, 19, 26-27, 34, 36,

45, 50, 63.
Tiring irons, 5.
Tootill, Geoffrey Colin, 14, 41.
Torture test, 35.
Torus, 29, 38, 42.
T'oth, Zolt'an, 62.
Transition counts, 14, 33.
Traversal, 1.
Trend-free Gray path, 16-17, 35.
Trie, 30.
Tuliani, Jonathan R., 60.
Tuple: A sequence containing a given

number of elements.

Up-down sequence, 36.
V'azsonyi, Endre, 56.
Vickers, Virgil Eugene, 33, 48, 49.
Visitation, 1.

66

INDEX AND GLOSSARY 67
Wallis, John, 6, 41.
Walsh, Joseph Leonard, 7, 8, 45-46.

functions, 7-9, 32.
transform, 8-9, 32.
Wang, Terry Min Yih ( ), 28.
Washburn, Seth Harwood, 42.
Weight enumeration, 42.

Wiedemann, Douglas Henry, 57.
Winker, Steven Karl, 48.
Winkler, Peter Mann, 17-18, 34, 48.
Wrapping around, 19, 29, 38.

Yates, Frank, 9.
Yuen, Chung Kwong ( ), 44.

67