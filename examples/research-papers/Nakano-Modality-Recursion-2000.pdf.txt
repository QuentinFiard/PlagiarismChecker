

A Modality for Recursion \Lambda 

Hiroshi Nakano
Ryukoku University, Seta, Otsu 520-2194, Japan

E-mail: nakano@math.ryukoku.ac.jp

Abstract
We propose a modal logic that enables us to handle
self-referential formulae, including ones with negative self-references, which on one hand, would introduce a logical contradiction, namely Russell's paradox, in the con-ventional setting, while on the other hand, are necessary
to capture a certain class of programs such as fixed point
combinators and objects with so-called binary methods inobject-oriented programming. Our logic provides a basis

for axiomatic semantics of such a wider range of programs
and a new framework for natural construction of recursiveprograms in the proofs-as-programs paradigm.

1. Introduction

Even though recursion, or self-reference, is an indispens-able concept in both programs and their specifications, it is
still far from obvious how to capture it in an axiomatic se-mantics such as the formulae-as-types notion of construction [17]. Only a rather restricted class of recursive pro-grams (and specifications) has been captured in this direction as (co)inductive proofs over the (co)inductive datastructures (see e.g., [9, 14, 23, 19, 26]), and, for example,
negative self-references, which would be necessary to han-dle a certain range of programs such as fixed point combinators and objects with so-called binary methods in object-oriented programming, still remain out of the scope.

In this paper, we propose a modal logic that providesa basis for capturing such a wider range of programs in
the proofs-as-programs paradigm. We give the logic as amodal typing system with recursive types for the purpose
of presentation, and show its soundness with respect to a re-alizability interpretation which implies the convergence of
well-typed programs according to their types.
Difficulty in binary-methods. Consider, for example, thespecification Nat

(n) of objects that represent a natural num\Lambda Research supported in part by 1999 Overseas Researcher Program of
Ryukoku University.

ber n with a method which returns an object of Nat(n+m)when one of Nat

(m) is given. It could be represented by aself-referential specification such as:

Nat(n) j ((n = 0) + (n ? 0 ^ Nat(n\Gamma 1))

\Theta  (8m: Nat(m) ! Nat(n+m)));

where we assume that n and m range over the set of naturalnumbers;

+, \Theta  and ! are type constructors for direct sums,direct products and function spaces, respectively;

^ and 8have standard logical (annotative) meanings. Although it

is not obvious whether this self-referential specification ismeaningful in a certain mathematical sense, it could be a
first approximation of the specification we want since thiscan be regarded as a refined version of recursive types which
have been widely adopted as a basis for object-oriented typesystems [1, 6]. At any rate, if we define an object 0 as:

0 j !i1 \Lambda ; *x: x?;
then it would satisfy Nat(0), where i1 is the injection intothe first summand of direct sums and

\Lambda  is a constant. We as-sume that any program satisfies annotative formulae such as

n = 0 whenever they are true. We can easily define a func-tion that satisfies

8n: 8m: Nat(n) ! Nat(m) ! Nat(n+m)as:

add x y j p2 x y;
or add

0 x y j p2 y x;

where p2 extracts second components, i.e., the method ofaddition in this particular case, from pairs. We could also
define the successor function as a recursive program as:

s x j !i2 x; *y: add x (s y)?
or s

0 x j !i2 x; *y: add0 x (s0 y)? :

In spite of the apparent symmetry between add and add0,which are both supposed to satisfy the same specification,
the computational behaviors of s and s0 are completely dif-ferent. We can observe that s works as expected, but s

0

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

does not. For example, p2 (s 0) 0 would be evaluated as:p

2 (s 0) 0 ! (*y: add 0 (s y)) 0 ! add 0 (s 0) !p
2 0 (s 0) ! (*x: x) (s 0) ! s 0, whereas p2 (s0 0) 0 !(*y:add0 0(s0 y))0 ! add0 0(s0 0) ! p

2 (s0 0)0 ! : : : , andmore generally, for any objects x and y of Nat(n) (for some

n), p2 (s0 x) y ! : : : ! p2 (s0 y) x ! : : : ! p2 (s0 x) y !
: : : .

It should be noted that this sort of divergence would alsobe quite common in (careless) recursive definitions of programs even if we did not have to handle object-orientedspecifications like Nat

(n). The peculiarity here is the factthat the divergence is caused by a program, add

0, which

is supposed to satisfy the same specification as add. Thisexample shows such a loss of the compositionality of programs with respect to the specifications that imply their ter-mination, or convergence. It also suggests that, to overcome
this difficulty, add and add0 should have different specifi-cations, and accordingly the definition of Nat

(n) should berevised in some way in order to force it.

*_ and its logical inconsistency. The typing system *_(see [4], and Section 2 of the present paper for a summary) is a simply-typed lambda calculus with recursivetypes, where any form of self-references, including negative
ones, is permitted. A non-trivial model for such unrestrictedrecursive types was developed by MacQueen, Plotkin and
Sethi [22], and has been widely adopted as a theoretical ba-sis for object-oriented type systems [1, 6].

On the other hand, it is well known that logical formu-lae with such unrestricted self-references would introduce a
contradiction (variant of Russell's paradox). Therefore, log-ical systems must have certain restrictions on the forms of
self-references (if ever allowed) in order to keep themselvessound; for example,

_-calculus [24, 20] does not allow neg-ative self-references (see also [13]).

Through the formulae-as-types notion, this paradox cor-responds to the fact that every type of

*_ is inhabited by adiverging program which does not produce any information;

for example, the *-term (*x:xx)(*x:xx) can be typed withevery type in

*_. Therefore, even with the model mentionedabove, types can be regarded only as partial specifications of

programs, and that is considered the reason why we lost thecompositionality of programs in the Nat

(n) case, where weregarded convergence of programs as a part of their specifications. This shows a contrast with the success of *_as a basis for type systems of object-oriented program languages, where the primary purpose of types, i.e., coarsespecifications, is to prevent run-time type errors, and termination of programs is out of the scope.

The logical inconsistency of *_ also implies that nomater how much types, or specifications, are refined, convergence of programs can not be expressed by them, andmust be handled by endowing the typing system with some

facilities for discussing computational properties of pro-grams. For example, Constable et al. adopted this approach in their pioneering works to incorporate recursivedefinitions and partial objects into constructive type theory
[10, 11]. However, in this paper, we will pursue another ap-proach such that types themselves can express convergence
of programs.

Towards the approximation modality. Suppose that wehave a recursive program

f defined by:

f j F (f );
and want to show that f satisfies a certain specification S.Since the denotational meaning of

f is given as the leastfixed point of
F , i.e., f = supn!! F n(?), a possible wayto do that would be to apply Scott's fixed point induction

[25] by showing that:

- ? satisfies S,
- F (x) satisfies S provided that x satisfies S, and
- S is chain closed.

However, this does not suffice for our purpose if S includessome requirement about the convergence of

f , because ob-viously
?, or even F n(?), could not satisfy the require-ment. So we need more refined approach. The failure of the

naive fixed point induction above suggests that the specifi-cation to be satisfied by each

F n(?) inherently depends on
n, and the requirement concerning its convergence must be-come stronger when

n increases. This leads us to a layeredversion of the fixed-point induction scheme as follows: in

order to show that f satisfies S, it suffices to find an infinitesequence

S0, S1, S2, : : : of properties, or (virtual) specifi-cations, such that:

(1) S = Tn!! Sn,
(2) Sn+1 ae Sn,
(3) ? satisfies S0,
(4) F (x) satisfies Sn+1 provided that x satisfies Sn, and
(5) Sn is chain closed.

For, since F n(?) 2 Sn for every n by (3) and (4), we get
F k(?) 2 Sn for every k * n by (2). This and (5) imply
f 2 Sn for every n, and consequently f 2 S by (1).In this scheme, the sequence

S0, S1, S2, : : : can be re-garded as a successive approximation of

S, and F a (higher-order) program which constructs a program that satisfies

Sn+1 from one that satisfies Sn. It should be also noted that
F works independently of n. This uniformity of F over
n leads us to consider a formalization of this scheme in amodal logic, where the set of possible worlds (in the sense

of Kripke semantics) consists of all non-negative integers,

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

and Sn in the induction scheme above corresponds to theinterpretation of

S in the world n. We now write x rk S todenote the fact that

x satisfies the interpretation of S in theworld
k, and define a modality, say ffl, as:

x rk fflS iff k = 0 or x rk\Gamma 1 S.
The condition (2) of the induction scheme says that x rk Simplies

x rl S for every l ^ k; in other words, the inter-pretation of specifications should be hereditary with respect

to the accessibility relation ?. In such a modal framework,the specification to be satisfied by

F can be represented by
fflS !S provided that the !-connective is interpreted in the
standard way in each world, and our induction scheme canbe rewritten as:

if ? r0 S and F rk fflS ! S for every k ? 0, then
f rk S for every k.

Furthermore, if we assume that S0 is a trivial specificationwhich is satisfiable by any program, then, shifting the possible worlds downwards by one, we can simplify this to:

(\Lambda ) if F rk fflS ! S for every k, then f rk S for every k.
Although this assumption about S0 somewhat restricts ourchoice of the sequence

S0, S1, S2, : : :, it could be thoughtrather reasonable because, at any rate,

S0 must be an almosttrivial specification that is even satisfiable by

?. Note that
Sn+1 occurring in the induction now corresponds to the in-terpretation of

S in the world n, and S0 corresponds to theinterpretation of

fflS in the world 0.
From this interpretation, we can extract some fundamen-tal properties concerning the

ffl-modality, which introduce a
subsumption, or subtyping, relation over specifications intoour modal framework. First, the hereditary interpretation of

specifications implies the following property:

- x rk S implies x rk fflS.
Second, this and the standard interpretations of ! imply thefollowing two properties:

- x rk S ! T implies x rk fflS ! fflT , and
- x rk fflS ! fflT implies x rk ffl(S ! T ).

Furthermore, if x rk ? ! ? for every x and k, where ?is the trivial specification which is satisfiable by any program, i.e., the universe of (meanings of) programs, then theconverse of the second one is also true, that is:

- x rk ffl(S ! T ) implies x rk fflS ! fflT .
Note that this is not always the case because we couldconsider non-extensional interpretations, e.g., F-semantics

[15], in which *x: ? rk ? ! ? holds, but ? rk ? ! ?does not.

Specification-level self-references. This modal frame-work introduced for program-level self-references also provides a basis for specification-level self-references. Sup-pose that we have a self-referential specification such as:

S = OE(S):
As we saw in the Nat(n) case, negative reference to S in
OE can introduce a contradiction in the conventional setting,and this is still true in our modal framework. However, in

the world n, we can now refer to the interpretation of S inany world

k ! n without worrying about the contradiction.That is, as long as

S occurs only in scopes of the modaloperator
ffl in OE, the interpretation of S is well-defined and
given as a fixed point of OE, which is actually shown to beunique. For example, if

S is defined as S = fflS ! T , then
S could be interpreted in each world as follows:

S0 = ? ! T0
S1 = S0 " ((? ! T0) ! T1)
S2 = S1 " ((S0 " ((? ! T0) ! T1)) ! T2).

..

Sn+1 = Sn " (Sn ! Tn+1).

..

where Sk and Tk are the interpretations of S and T in theworld

k, respectively, and the notations such as ? and ! areabused to denote their expected interpretations also. Note

that this kind of self-references provides us a method to de-fine the sequence

S0, S1, S2, : : : for the refined inductionscheme when we derive properties of recursive programs,

and the induction scheme would be useless if we did nothave such a method.

In the following sections, we will see that this formof specification-level self-references is quite powerful, and
captures a wide range of specifications including thosewhich are not representable in the conventional setting such
as ones for add and add0 in the Nat(n) case. Further-more, the modal version (

\Lambda ) of the induction scheme turnsout to be derivable from other properties of the

ffl-modality
and such self-referential specifications, where the derivationcorresponds to fixed point combinators, such as Curry's Y.

This also gives us a way to construct recursive programsbased on the proofs-as-programs notion.

2. A brief review of *_

To fix notation, we begin with a brief review of *_,which is a simply typed lambda calculus with recursive
types. We first assume a set Exp of untyped *-termspossibly containing individual constants (

c; d; : : :). Weuse
M; N; K; L; : : : to denote *-terms. Free and bound

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

\Gamma  [ fx : Ag `*_ x : A (var) \Gamma  `*_ c : o/ (c) (const)

\Gamma  `*_ M : A
\Gamma  `*_ M : A0

('*_) (A '*_ A

0)

\Gamma  [ fx : Ag `*_ M : B

\Gamma  `*_ *x: M : A ! B (

! I*_) \Gamma 

1 `*_ M : A ! B \Gamma 2 `*_ N : A

\Gamma 1 [ \Gamma 2 `*_ M N : B (

!E*_)

Figure 1. The typing system *_
occurrences of individual variables and the notion of ff-convertibility are defined in the standard manner. Hereafter, we identify *-terms by this ff-convertibility. We de-note the set of individual variables occurring freely in

M by
F V (M ), and use M [N1=x1; : : : ; Nn=xn] to denote the *-term obtained from a

*-term M by substituting N1; : : : ; Nnfor each free occurrence of individual variables

x1; : : : ; xn,respectively, with necessary
ff-conversion to avoid acciden-tal capture of free variables.

fi-reduction is also defined in the standard manner, andtreated as a binary relation

!fi over Exp. We denote the transitive and reflexive closure of !fi by \Lambda !fi , and the symmetricclosure of

!fi by $fi . We define the equivalence relation =fias the transitive and reflexive closure of

$fi . Our intendedsemantics for untyped
*-terms is summarized as the follow-ing, where we do not require extensionality with respect to

their interpretations.
Definition 1 (fi-model). A fi-model of Exp is a tuple !V;
\Delta ; oe; [[ ]]V? such that:

1. V : a non-empty set.
2. oe : Const ! V.
3. \Gamma  \Delta  \Gamma  : V \Theta  V ! V.
4. [[\Gamma ]]V\Gamma  : Exp ! (Var ! V) ! V.

5. [[x]]Vae = ae(x).
6. [[c]]Vae = oe(c).
7. [[M N]]Vae = [[M ]]Vae \Delta  [[N ]]Vae .
8. [[*x: M ]]Vae \Delta  v = [[M ]]Vae[v=x], where ae[v=x](x) = v and

ae[v=x](y) = ae(y) if y == x.

9. If M =fi N , then [[M ]]Vae = [[N ]]Vae .
Definition 2 (Type expressions of *_). The syntax of thetype expressions of

*_ is defined relatively to the followingtwo sets: TConst of type constants (

P; Q; R; : : :) and TVarof countably infinite
type variables (X; Y; Z; : : :). The set

TExp*_ of type expressions of *_ is defined as follows:

TExp*_ ::= TConst (type constants)

j TVar (type variables)
j TExp*_ ! TExp*_ (function types)
j _TVar: TExp*_ (recursive types):

We use A; B; C; D; : : : to denote type expressions of *_.We regard a type variable

X as bound in _X:A. We use
A[B1=X1; : : : ; Bn=Xn] to denote the type expression ob-tained from

A by substituting B1; : : : ; Bn for each free oc-currence of
X1; : : : ; Xn, respectively. We denote the set oftype variables occurring freely in

A by F T V (A). We re-gard
ff-convertible type expressions as identical; for exam-ple,
_X:X ! Y = _Z:Z ! Y . We define the equivalencerelation

'*_over TExp*_ considering two type expressionsof
*_ equivalent modulo '*_ if they have the same (possi-bly infinite) type expression obtained by unfolding recursive types _X:A occurring in them to A[_X:A=X] indef-initely. This equivalence relation is known to be decidable
(see [8] and [3]).
Definition 3 (Typing contexts). A typing context, or acontext for short, of

*_ is a finite mapping that assignsa type expression of
*_ to each individual variable of itsdomain. We use
\Gamma , \Gamma 0, : : : to denote contexts, and fx1 :
A1; : : : ; xm : Amg to denote a context that assigns Ai to xi(

i = 1; : : : ; m).

Definition 4 (*_). Let o/ be a mapping that assigns a typeconstant

o/ (c) to each individual constant c. The typing sys-tem
*_ is defined relatively to this o/ by the derivation rulesshown in Figure 1.

Definition 5 (Realizability models of *_). A realizabil-ity model of

*_ is a tuple !V; \Delta ; oe; [[ ]]V; T ; AE; [[ ]]T ? suchthat:

1. !V; \Delta ; oe; [[ ]]V ? is a fi-model of Exp.
2. T ae P(V) (= f S j S ae V g)
3. AE : TConst ! T
4. oe(c) 2 AE(o/ (c))

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

5. [[\Gamma ]]T\Gamma  : TExp*_ ! (TVar ! T ) ! T
6. [[X]]Tj = j(X)
7. [[P ]]Tj = AE(P )
8. [[A ! B]]Tj = f v j v \Delta  u 2 [[B]]Tj for every u 2 [[A]]Tj g
9. If A '*_ B, then [[A]]Tj = [[B]]Tj .
It is not straightforward to construct a non-trivial realizabil-ity model of

*_. The first non-trivial model was developedby MacQueen, Plotkin and Sethi [22], by constructing a

complete metric space of types and by interpreting recur-sive types as the fixed points of contractive type constructors (see also [2, 8]).
Proposition 1 (Soundness of *_). Let !V; \Delta ; oe; [[ ]]V; T ;
AE; [[ ]]T ? be a realizability model of *_. If fx1 : A1; : : : ;
xn : Ang `*_ M : B is derivable, then [[M ]]Vae 2 [[B]]Tj

for every j and ae provided ae(xi) 2 [[Ai]]Tj (i = 1; 2; : : : ;
n).

Nevertheless, as mentioned in Introduction, unrestrictedself-references allowed in

*_ cause a logical contradictionas follows (Curry's paradox):

Proposition 2. `*_ (*x: xx) (*x: xx) : A is derivable
for any type expression A.

Proof. Let C = _X:X ! A, and \Pi  as follows:

\Pi  =

x : C `*_ x : C
x : C `*_ x : C ! A (

'*_) x : C `

*_ x : C

x : C `*_ xx : A (

!E)

`*_ *x: xx : C ! A (

!I)

Then, we can derive it as follows:

... \Pi 
`*_ *x: xx : C ! A

... \Pi 
`*_ *x: xx : C ! A

`*_ *x: xx : C (

'*_)

`*_ (*x: xx) (*x: xx) : A (

!E)

ut

3. The typing system *ffl_

We now define a modal typing system, which is denotedby

*ffl_, based on the idea discussed in Introduction. First,as a preparation for introducing the syntax of type expressions, we give the one of pseudo type expressions, whichare obtained by adding a unary type constructor

ffl to the one
of TExp*_.

Definition 6. We define the set PTExp of pseudo type expressions as follows:

PTExp ::= TConst (type constants)

j TVar (type variables)
j PTExp ! PTExp (function types)
j fflPTExp (approximative types)
j _TVar:PTExp (recursive types):

We assume that ! associates to the right as usual, and each(pseudo) type constructor associates according to the following priority:

(Low) _X: ! ! ! ffl (High):
For example, ffl _X:fflX ! Y ! Z is the same as ffl(_X:
((fflX) ! (Y ! Z))). We use ? as an abbreviation for
_X:fflX and use fflnA to denote a (pseudo) type expression
ffl : : : ffl-- -z ""

n times

A, where n * 0.

Definition 7 (?-variants). A type expression A is a ?-
variant if and only if A = fflm0_X1:fflm1 _X2:fflm2 : : : _Xn:
fflmnXi for some n, m0, m1, m2, : : :, mn, X1, X2, : : :, Xn
and i such that 1 ^ i ^ n and mi + mi+1 + mi+2 + : : : +
mn * 1.

Definition 8 (Properness). A pseudo type expression A is
proper in X if and only if X occurs freely only (a) in scopesof the

ffl-operator in A, or (b) in a subexpression B ! C of
A with C being a ?-variant.

For example, P , fflX, ffl(X ! Y ), X ! ffl_Y:fflY and _Y :
ffl(X ! Y ) are proper in X, and neither X, X ! Y nor
_Y:_Z:X ! Y is proper in X.

Definition 9 (Type expressions of *ffl_). A type expression is a pseudo type expression such that A is proper in
X for any of its subexpressions in the form of _X:A. Wedenote the set of type expressions of

*ffl_ by TExp.

For example, P , X, X ! Y , _X:fflX ! Y , _X:X ! ?and

_X:ffl _Y :X ! Z are type expressions of *ffl_, and nei-ther

_X:X ! Y nor _X:_Y :X ! Y is a type expressionof
*ffl_. We also use A; B; C; D; : : : to denote type expres-sions of

*ffl_, and define other notations such as F T V (A)and
A[B1=X1; : : : ; Bn=Xn] similarly to the case of *_.

Definition 10. We define r(A), the rank of A, as follows:

r(P ) = r(X) = r(fflA) = 0
r(A ! B) = ae 0 (B is a ?-variant)max(r(A); r(B)) + 1 (otherwise)
r(_X:A) = r(A) + 1

Observe that r(A[B=X]) ! r(_X:A) for every B if A isproper in

X.

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

fl [ fX _ Y g ` X _ Y (

_-assump) fl ` A _ ? (_-?)

fl ` A _ A0

(_-reflex) (A ' A

0) fl1 ` A _ B fl2 ` B _ C

fl1 [ fl2 ` A _ C (

_-trans)

fl ` A _ B
fl ` fflA _ fflB (

_-ffl) fl

1 ` A0 _ A fl2 ` B _ B0

fl1 [ fl2 ` A ! B _ A0 ! B0 (

_-!)

fl ` A _ fflA (

_-approx) fl ` A ! B _ fflA ! fflB (_-!ffl) fl ` fflA ! fflB _ ffl(A ! B) (_-ffl!)

fl [ fX _ Y g ` A _ B

fl ` _X:A _ _Y:B (

_-_) `X =2 F T V (fl) [ F T V (B), Y =2 F T V (fl) [ F T V (A),and A and B are proper in X and Y , respectively '

Figure 2. The subtyping rules of *ffl_
Definition 11 ('). The equivalence relation ' over TExpis defined as the smallest binary relation that satisfies:

- A ' A.
- If A ' B, then B ' A.
- If A ' B and B ' C, then A ' C.
- If A ' B, then fflA ' fflB.
- If A ' C and B ' D, then A ! B ' C ! D.
- A ! ? ' B ! ?.
- _X:A ' A[_X:A=X].
- If A ' C[A=X] and C is proper in X, then A ' _X:C.

Two type expressions of *ffl_ are equivalent modulo ', iftheir (possibly infinite) type expression obtained by indefinite unfolding recursive types occurring in them are identi-cal modulo the rule

A ! ? ' B ! ?.

Proposition 3. A type expression A is a ?-variant if and
only if A ' ?.

Definition 12 (Canonical types). We define a set CTExpof

canonical type expressions as follows:

CTExp ::= ? j fflnTConst j fflnTVar

j ffln(TExp ! TExp);

where n is an arbitrary non-negative integer.
Proposition 4. There exists an effective procedure for cal-culating a canonical type expression

Ac such that Ac ' A
from a given type expression A of *ffl_.

Subtyping. As mentioned in Introduction, our intendedinterpretation of the

ffl-modality introduces a subtyping relation into TExp. We now define the subtyping relation bya set of inference rules as in [3].

Definition 13. A subtyping assumption is a finite set ofpairs of type variables such that any type variable appears
at most once in the set. We write fX1 _ Y1; X2 _
Y2; : : : ; Xn _ Yng to denote the subtyping assumption
f ! Xi; Yi? j i = 1; 2; : : : ; n g. We use fl, fl0, fl1, fl2,
: : : to denote subtyping assumptions, and F T V (fl) to de-note the set of type variables occurring in

fl.

Definition 14 (_). We define the derivability of subtyping
judgment fl ` A _ B by the derivation rules shown inFigure 2. Note that

fl [ fX _ Y g and fl1 [ fl2 in the rulesmust be (valid) subtyping assumptions, i.e., any type variable must not have more than one occurrence in them. Wealso define a binary relation

_ over TExp as: A _ B if andonly if
fg ` A _ B is derivable.

Most of the subtyping rules are standard. The rule (_-_)corresponds to the "Amber rule" [7]. The rules

(_-?),
(_-ffl), (_-approx), (_-!ffl) and (_-ffl!) reflect our in-tended meaning of the

ffl-modality discussed in Introduction.

Proposition 5 (Basic properties of _).

1. ? _ A if and only if A ' ?.
2. fflA _ fflB if and only if A _ B.
3. fflA =_ X, fflA =_ P , and fflA =_ B ! C.

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

\Gamma  [ fx : Ag ` x : A (var) \Gamma  ` c : o/ (c) (const)
\Gamma  ` M : ? (

?) ffl\Gamma  ` M : fflA\Gamma  ` M : A (ffl) \Gamma  ` M : A ` A _ B\Gamma  ` M : B (_)

\Gamma  [ fx : Ag ` M : B

\Gamma  ` *x: M : A ! B (

! I) \Gamma 

1 ` M : ffln(A ! B) \Gamma 2 ` N : fflnA

\Gamma 1 [ \Gamma 2 ` M N : fflnB (

!E)

Figure 3. The typing rules of *ffl_
The typing rules. We now define the typing rules of *ffl_.According to the intended meaning of

ffl, two new typing
rules, (ffl) and (_), are added and the (!E*_) rule is gener-alized to handle types with the

ffl-modality.

Definition 15 (Typing rules). Typing contexts for *ffl_ aredefined similarly to the case of

*_. Let o/ be a mappingthat assigns a type constant
o/ (c) to each individual constant
c. The typing system *ffl_ is defined relatively to o/ by thederivation rules shown in Figure 3, where

ffl \Gamma  denotes the
typing context fx1 : fflA1; x2 : fflA2; : : : ; xn : fflAng when
\Gamma  = f x1 : A1; x2 : A2; : : : ; xn : Ang.

The (ffl)-rule represents the fact that every possible world nhas its successor

n+1. Since the interpretation of \Gamma  ` M :
A in the world n is identical to the one of ffl\Gamma  ` M :
fflA in the world n+ 1, \Gamma  ` M : A is valid whenever so
is ffl\Gamma  ` M : fflA . The (!E)-rule allows us to derive

` *x: *y: xy : ffl(A ! B) ! fflA ! fflB for every A and B.Therefore,

ffl(A!B) and fflA!fflB are logically equivalent,
even though not equivalent as sets of *-terms. Note that
fflA ! fflB _ ffl(A ! B), but ffl(A ! B) =_ fflA ! fflB.

Example 1. We can derive Curry's fixed-point combinatorY in

*ffl_; more precisely, the following is derivable.

` *f: (*x: f (xx)) (*x: f (xx)) : (fflX ! X) ! X
Let a formula A = _Y:fflY ! X and a derivation \Pi  asfollows:

\Pi  =

f : fflX ! X ` f : fflX ! X (var)

x : fflA ` x : fflA (var)
x : fflA ` x : ffl(fflA ! X) (

') x : fflA ` x : fflA

(var)

x : fflA ` x : fflfflA (

_)

x : fflA ` xx : fflX..

....

.

(!E)

f : fflX ! X; x : fflA ` f (xx) : X (

!E)

f : fflX ! X ` *x: f (xx) : fflA ! X (

!I)

Then, let \Gamma  = ff : fflX ! Xg and L = *x: f (xx). We canderive Y as follows:

... \Pi 
\Gamma  ` L : fflA ! X

... \Pi 
\Gamma  ` L : fflA ! X

\Gamma  ` L : fflA (

_)

\Gamma  ` LL : X (

!E)

` *f: LL : (fflX ! X) ! X (

!I)

We can also observe that Turing's fixed point combinator
(*x:*f:f (xxf )) (*x: *f: f (xxf )) has the same type. Thetype

(fflX ! X) ! X gives a concise axiomatic meaning tothe fixed point combinators; it says that they can produce an

element of X with a given function that works as an infor-mation pump from

fflX to X; in other words, they provide
the induction scheme discussed in Introduction. The typethus enables us to construct recursive programs using the

fixed point combinators without analyzing their computa-tional behavior. We will see some examples of such recursive programs in Section 6.

Basic property of *ffl_. The typing system *ffl_ enjoyssome basic properties such as subject reduction property.

Lemma 1. Let \Gamma 1 and \Gamma 2 be typing contexts such that
Dom(\Gamma 1) " Dom(\Gamma 2) = fg. If \Gamma 1 [ \Gamma 2 ` M : A is
derivable, then so is ffl \Gamma 1 [ \Gamma 2 ` M : ffl A .

Lemma 2 (Substitution lemma). If \Gamma  [ fx : Ag `
M : B and \Gamma  ` N : A are derivable, then so is
\Gamma  ` M [N=x] : B .

Theorem 1 (Subject reduction). If \Gamma  ` M : A is deriv-able and

M !fi M 0, then \Gamma  ` M 0 : A is derivable.

Proof. By induction on the structure of M . Use Lemmas 1and 2.

ut

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

4. A realizability interpretation

In this section, we give a realizability interpretation of
*ffl_, and show soundness of *ffl_ with respect to the inter-pretation.

Definition 16. Let !T ; v ? be a partially ordered set. Wedefine a set

A(T ; v) of infinite sequences of elements of Tas follows:

A(T ; v) =

f !t0; t1; t2; : : : tk; : : : ? j tk+1 v tk for every k g

We denote the k-th element of t 2 A(T ; v) by tk. Notethat

t starts with its 0-th element t0.

Definition 17. A realizability interpretation of *ffl_ is a tu-ple

!V; \Delta ; oe; [[ ]]V; K; `? such that:

1. !V; \Delta ; oe; [[ ]]V? is a fi-model of Exp.
2. K ae V.
3. u \Delta  v 2 K for every u 2 K and v 2 V.
4. ` : TConst ! A( f S j K ae S ae V g; ae).
5. oe(c) 2 `(o/ (c))k for every c and k.

We call a mapping , : TVar ! A( f S j K ae S ae V g; ae)a type environment.

Definition 18 (Semantics of types). Let !V; \Delta ; oe; [[ ]]V;
K; `? be a realizability interpretation of *ffl_, , a type en-vironment. We assign an element

I(A), of A(f S j K ae
S ae V g; ae) to each type expression A as follows:

I(P ),k = `(P )k
I(X),k = ,(X)k
I(fflA),k = f u j u 2 I(A),l for every l ! k g
I(A ! B),k =8?????!

?????:u

fifififififi
fififififi

1. u 2 I(A ! B),l for every l ! k.
2. If B is not a ?-variant, then u \Delta  v 2

I(B),k for every v 2 I(A),k.

3. u 2 K or u = [[*x: M ]]Vae for some x,

ae and M .

9?????=
?????;
I(_X:A),k = I(A[_X:A=X]),k
Note that the I(A),k is defined by induction on the lexico-graphic ordering of

!k; r(A)?. We can easily check that

K ae I(A),k+1 ae I(A),k for every k. It should also be noted
that I(A),k = V whenever A is a ?-variant; and therefore,the conditional "if

B is not a ?-variant" is redundant forthe clause 2 of the definition of

I(A ! B). The set K takesa rather technical role (cf. [21]) in this semantics, and is

only used to show head normalizability of *-terms of cer-tain types in the proofs of (2) and (3) of Theorem 3. It can
usually be considered an empty set. The third condition for
u 2 I(A ! B),k implies that we distinguish *x: M x from
M unless M =fi *y: N for some y and N , even if M has a

function type. Note that I(ffl(A!B)),k = I(fflA!fflB),k for
every k ? 0, but I(ffl(A!B)),0 = V and I(fflA!fflB),0 == Vby this condition. Thus,

ffl(A ! B) ' fflA ! fflB is not valid
in this interpretation. We can also consider a variant sys-tem of

*ffl_ with this equality, where we have to drop thethird condition from

u 2 I(A ! B),k to get its soundness.However, we omit the details from this paper.

The typing system *ffl_ is sound with respect to this se-mantics.

Lemma 3. 1. If A ' B, then I(A), = I(B),.

2. If A _ B, then I(A),k ae I(B),k for every k.

Theorem 2 (Soundness). Let the tuple !V; \Delta ; oe; [[ ]]V; K;
`? be a realizability interpretation of *ffl_, and , a type
environment. If fx1 : A1; : : : ; xn : Ang ` M : B is
derivable in *ffl_, then [[M ]]Vae 2 I(B),k for every k, , and

ae provided ae(xi) 2 I(Ai),k for every i (i = 1; 2; : : : ; n).

Proof. By induction on the derivation and by cases of thelast rule used in the derivation. Most cases are straightforward. Use Lemma 3 for the case of (_). Prove it by induc-tion on

k in the case of (!I). ut

5. Convergence of well-typed terms

The soundness theorem assures the convergence of well-typed

*-terms according to their types. In this section wegive a summary of such results.

Definition 19. A *-term M is a weak head normal formif

M is either of the following forms: (1) c, (2) *x: N ,or (3)

x N1 N2 : : : Nn (n * 0), and is a head normal
form if M is either of the following forms: (1) c, or (2)
*x1: *x2: : : : *xm: y N1 N2 : : : Nn (m; n * 0).

We say that M has a (weak) head normal form, or is
(weakly) head normalizable, if M \Lambda !fi M 0 for some (weak)

head normal form M 0. Note that if M is (weakly) headnormalizable and

M =fi M 0, then M 0 is also (weakly) headnormalizable. We also define B"ohm trees of

*-terms in thestandard manner according to this definition of head normal

forms, in which *-terms without head normal forms are de-noted by

?. We say that a *-term is maximal if its B"ohmtree has no occurrence of

?.

Definition 20 (Tail finite types). A type expression A is
tail finite if and only if A ' fflm1(B1 ! fflm2 (B2 ! fflm3(B3

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

! : : : ! fflmn(Bn ! C) : : :))) for some n, m0, m1, m2,
: : :, mn, B1, B2, : : :, Bn and C such that C =' ? and
C =' fflk(D ! E) for every k, D and E.

Definition 21. Let A be a type expression. We define sets
ET V +(A) and ET V \Gamma (A) of type variables as follows:

ET V \Sigma (P ) = fg
ET V +(X) = fXg; ET V \Gamma (X) = fg
ET V \Sigma (fflA) = ET V \Sigma (A)

ET V \Sigma (A ! B)

= ( fg (B is a ?-variant)ET V \Upsilon (A) [ ET V \Sigma (B) (otherwise)

ET V \Sigma (_X:A) = (ET V \Sigma (A) \Gamma  fXg)

[ ( ET V

\Upsilon (A) \Gamma  fXg (X 2 ET V \Gamma (A))

fg (otherwise)

The set ET V +(A) (ET V \Gamma (A)) consists of the type vari-ables that have free positive (negative) occurrences in

A,where we ignore any subexpression
B ! C of A whenever
C is a ?-variant. Note also that ET V \Sigma (A) ae F T V (A).

Definition 22 (Positively and negatively finite types). Atype expression

A is positively (negatively) finite if and onlyif
C is tail finite whenever A ' B[C=X] for some B and
X such that X 2 ET V +(B) (X 2 ET V \Gamma (B)) and X =2
ET V \Gamma (B) (X =2 ET V +(B)).

Note that every positively finite type expression is tail finite.
Proposition 6. The following three properties of a given
type expression A are decidable.

(1) A ' ?.
(2) A is tail finite.
(3) A is positively (negatively) finite.

Proof (sketch). The decidability of (1) is straightforwardfrom Proposition 3. For the property (2), let

V be a setof type variables, and define TF
V as follows:

TFV ::= TConst j X (X 2 TVar \Gamma  V )

j ffl TFV j TExp ! TFV
j _X:TFV [fXg (X 2 TVar):

It suffices to show that A is tail finite if and only if A 2TF

fg. For (3), show that A is positively (negatively) finite

if and only if A 2 PF (NF), where PF and NF are definedas follows:

PF ::= TConst j TVar j ffl PF j NF ! PF

j _X:A ` _X:A 2 TF

fg; A 2 PF; and (a)

A 2 NF or (b) X =2 ET V \Gamma (A) ' :

NF ::= TConst j TVar j ffl NF j PF ! NF

j TExp ! A (A is a ?-variant)

j _X:A ` A 2 NF; and (a) _X:A 2 PFor (b) X =2 ET V \Gamma (A) ' :

ut

Theorem 3 (Convergence). Let \Gamma  ` M : A be a derivable typing judgment of *ffl_.

(1) If A =' ?, then M has a weak head normal form.
(2) If A is tail finite, then M has a head normal form.
(3) If A is positively finite and \Gamma (x) is negatively finite forevery

x 2 Dom(\Gamma ), then M is maximal.

Proof (sketch). We consider the following fi-model (termmodel)

!V; \Delta ; oe; [[ ]]V? of TExp:

- V = Exp==fi
- M \Delta  N = M N
- oe(c) = c
- [[x]]Vae = ae(x)

- [[c]]Vae = c
- [[M N]]Vae = [[M ]]Vae [[N ]]Vae
- [[*x: M]]Vae = *x: [[M ]]Vae[x=x]

Let K0 = f xN1N2 : : : Nn j x 2 Var; n * 0 and Ni 2
V (i = 1; 2; : : : ; n) g, and `(P )k = K0 [ f M j
M =fi c for some c 2 Const g for every k and P 2 TConst.

We can easily show that !V; \Delta ; oe; [[ ]]V; K0; `? is a realiz-ability interpretation of

*ffl_. Fixing ae and , as ae(x) = xfor every
x, and ,(X)k = K0 for every k and X, respectively, we get M 2 I(A),k for every k by Theorem 2 because [[M ]]Vae = M and ae(x) = x 2 K0 ae I(\Gamma (x)),k forevery

x 2 Dom(\Gamma ). We can easily show (1) by cases ofthe form of

A since we may assume that A is a canonicaltype expression. For (2), the proof proceeds by induction

on the structure of A. As for (3), by induction on the depthof the B"ohm tree nodes, in which we use the result of (2);
however, the proof also needs some technical lemmas. ut

6. *ffl_ as a basis for logic of programs

The typing system *ffl_ and its interpretation can be eas-ily extended to cover full propositional and second-order
types. For example, we can add the following rules forproduct types.

\Gamma  ` M : A1 \Gamma  ` N : A2

\Gamma  ` !M; N ? : A1 \Theta  A2 (

\Theta I)

\Gamma  ` M : ffln(A1 \Theta  A2)

\Gamma  ` pi M : fflnAi (

\Theta E) (i = 1; 2)

With the help of such extensions, *ffl_ can be a basis forlogic of a wide range of programs. In this section we give
some examples.

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

Streams. Streams, or infinite sequences, of data of a type
X are representable by the type _Y:X \Theta  fflY . Since thistype is positively finite, its elements are all maximal. We

can derive recursive programs over streams using fixedpoint combinators such as Y; for example, the program
*x: Y(*y: !x; y?), which generates a constant stream ofa given value of the type

X, has the type X ! A, and theprogram Y
(*f: *x: *y: !p1 x; f y(p2 x)?), which mergestwo streams, has type

A !A ! A, where A = _Y:X \Theta fflY .More complicated programs over streams such as the prime

number generator based on the sieve of Eratosthenes arealso derivable by extending our logic to a predicate logic
endowed with an arithmetic (powerful enough to handle,e.g., primitive recursive functions) for annotation, and by
allowing type expressions such as ffltA as well-formed typeexpressions, with

t being a numeric expression.

McCarthy's 91-function. Provided such an extension topredicate logic, we can construct a wide range of recursive
programs with fixed point combinators assuring their termi-nation. Consider the following recursive program, which
represents McCarthy's 91-function:

f x j if (x ? 100) then x \Gamma  10 else f (f (x + 11)):
We can show that f has a type, or satisfies a specification,
8n: nat(n) ! ffl101

:\Gamma nnat(g(n)), where n ranges over nonnegative integers, and nat(n) represents the implementationof the non-negative integer

n; :\Gamma  and g are primitive recur-sive functions defined in the arithmetic as:

x :\Gamma  y j ae x \Gamma  y (if x * y)0 (otherwise)

g(x) j ae x \Gamma  10 (if x ? 100)91 (otherwise)
and 8n: A(n) is interpreted as:

I(8n: A(n)),k = f u j u 2 I(A(n)),k for all n g:
Suppose that f : ffl 8n: nat(n) ! ffl101

:\Gamma nnat(g(n)) and x :

nat(n). The type of Y assures that it suffices to show:

if (x ? 100) then x \Gamma  10 else f (f (x + 11))

: 8n: nat(n) ! ffl101

:\Gamma nnat(g(n)):

We assume that \Gamma  and + satisfy 8m: 8n: nat(m) ! nat(n)
!nat(n :\Gamma m) and 8m: 8n: nat(m)!nat(n)!nat(n+m),respectively. First, we get:

f (x+11) : fflffl101

:\Gamma (n+11)nat(g(n+ 11)):

If n ^ 90, then we get f (x+11) : ffl91

:\Gamma n nat(91) by

the definitions of :\Gamma  and g; and therefore, f (f (x+11)) :
ffl91

:\Gamma nffl101 :\Gamma 91nat(g(91)), which is equivalent to ffl101 :\Gamma n

nat(91). On the other hand, if 90 ! n ^ 100, thenwe similarly get

f (x+11) : ffl nat(n+1); and therefore,
f (f (x+11)) : fflffl101

:\Gamma (n+1)nat(g(n+1)), which is also

equivalent to ffl101

:\Gamma nnat(91). Otherwise, i.e., if 100 ! n,

obviously x\Gamma 10 : nat(g(n)).In this derivation, the fixed point combinator worked as

the induction scheme discussed in Introduction with a se-quence

S0, S1, S2, : : :, Sn as follows:

S0 = V
Sk+1 = f f j 8n * 101 :\Gamma  k: f (n) = g(n) g:

Note also that if I(nat(n)),k does not depend on k, then the
interpretation of ` f : 8n: nat(n) ! ffl101

:\Gamma nnat(g(n))

implies f 2 I(8n: nat(n) ! nat(g(n))),k for every k.Therefore, the apparent complexity of the type expression is not essential, and it can be observed that ` f :
8n: nat(n) ! nat(g(n)) becomes formally derivable from

` f : 8n: nat(n) ! ffl101

:\Gamma nnat(g(n)) if we introduce another modality, say ut, which is interpreted as:

I(utA),k = f u j u 2 I(A),l for every l g;
and accordingly enjoys the following subtyping relationsand typing rules:

- A _ B implies utA _ utB
- ut(A ! B) _ utA ! utB
- utA _ A
- utA _ ututA
- utffltA _ utA
- nat(n) _ utnat(n)

\Gamma  ` M : A
ut\Gamma  ` M : utA (

ut) ut\Gamma 1 [ ffl\Gamma 2 ` M : fflAut\Gamma 

1 [ \Gamma 2 ` M : A (

ffl)

The (ffl)-rule supersedes the original one in Figure 3. Recur-sive type variables are not allowed to occur in scopes of the
ut-operator, and I(A),k is now defined by induction on thelexicographic ordering of

!b(A); k; r(A)?, where b(A) isthe depth of nesting occurrences of

ut in A.

The Nat(n)-example. We now reconsider the example ofobject-oriented natural numbers with an addition method.
We revise the definition of Nat(n) as follows:

Nat(n) j ((n = 0) + (n ? 0 ^ ffl Nat(n\Gamma 1))

\Theta  (8m: ffl Nat(m) ! ffl Nat(n+m))):

Then, the specifications of add and add0 are now differentas follows:

add : 8n: 8m: Nat(n) ! ffl Nat(m) ! ffl Nat(n+m)
add0 : 8n: 8m: ffl Nat(n) ! Nat(m) ! ffl Nat(n+m)

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

We can show s : 8n: Nat(n) ! Nat(n+ 1)by deriving
!i2 x; *y: add x (s y)? : Nat(n+1) from s : ffl 8n: Nat(n)
! Nat(n+1) and x : Nat(n). Obviously,

i2 x : (n+1 = 0) + (n+1 ? 0 ^ ffl Nat(n+1\Gamma 1)):
If y : ffl Nat(m), we get s y : ffl Nat(m+1), and conse-quently,

add x (s y) : fflNat(n+1+m):
We thus get !i2 x; *y: add x (s y)? : Nat(n+ 1). Notethat, on the other hand, under similar assumptions, we can

only get

add0 x (s0 y) : fflfflNat(n+1+m);
and fail to derive s0 : 8n: Nat(n) ! Nat(n+1).

7. Concluding Remarks

We have presented a modal typing system with recur-sive types and shown its soundness with respect to a realizability interpretation and the convergence of well-typedterms according to their types. The decidability questions
for type checking, typability and inhabitation of *ffl_ typesare still open. Although we presented it as a typing system, we do not intend to apply it directly to type systems ofprogramming languages. Since our framework asserts the
convergence of derived programs, typing general recursiveprograms naturally requires some (classical) arithmetics as
seen in the case of the 91-function, which would make me-chanical type checking impossible. Our goal is to capture a wider range of programs in the proofs-as-programsparadigm and give an axiomatic semantics to them preserving the compositionality of programs. We have seen that ourapproach is applicable to some interesting programs such as
fixed point combinators and objects with binary methods,which have not been captured in the conventional frameworks.

Similar results concerning the existence of fixed pointsof proper type expressions (Lemma 3.1 in our case) could

historically go back to the fixed point theorem of the logic ofprovability (see [5, 18]). The difference is that our logic is
intuitionistic, and fixed points are treated as sets of realizers.Interestingly, by applying

(_) to the type (fflX ! X) ! Xof the fixed point combinators, we can also derive

ffl(fflX !
X) ! fflX, i.e., L"ob's axiom schema ut(utOE ! OE) ! utOErepresenting the well-foundedness of the (classical) Kripke

frame. It should be observed that (utOE ! OE) ! OE is validbased on intuitionistic frames, where

OE ! utOE is valid, ifand only if the frame is well-founded.

Our intended semantics of *ffl_ suggests that our modallogic could be related to some temporal logic of discrete,
linear time with finite past and infinite future, where the

modal operator ffl corresponds to the "previous time", or"yesterday", modality. Gabbay and Hodkinson discussed
such a temporal logic and its fixed point operator [12, 16];however, the relationship with

*ffl_ is not obvious since theirtemporal logic is based on classical logic.

Acknowledgments

The author is greatly indebted to Professor Solomon Fe-ferman for the opportunity to develop the main part of this
research in a stimulating environment at Stanford Univer-sity. Thanks are also due to the anonymous referees for their
helpful comments on the preliminary version of the presentpaper.

References

[1] M. Abadi and L. Cardelli. A theory of objects. SpringerVerlag, 1996.
[2] R. M. Amadio. Recursion over realizability structure. Information and Computation, 91(1):55-85, 1991.
[3] R. M. Amadio and L. Cardelli. Subtyping recursive types.

ACM Transactions on Programming Languages and Systems, 15(4):575-631, 1993.
[4] H. P. Barendregt. Lambda calculi with types. In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, pages 118-
309. Oxford University Press, 1992.
[5] G. Boolos. The logic of provability. Cambridge University

Press, 1993.
[6] K. B. Bruce, L. Cardelli, and B. C. Pierce. Comparing object encodings. Information and Computation, 155:108-
133, 1999.
[7] L. Cardelli. Amber. In G. Cousineau, P.-L. Curien, and

B. Robinet, editors, Combinators and functional programming languages, volume 242 of Lecture Notes in Computer
Science, pages 21-47. Springer-Verlag, 1986.
[8] F. Cardone and M. Coppo. Type inference with recursive

types: syntax and semantics. Information and Computation,
92(1):48-80, 1991.
[9] R. L. Constable, S. Allen, H. Bromely, W. Cleveland, et al.

Implementing Mathematics with the Nuprl Proof Development System. Prentice-Hall, 1986.
[10] R. L. Constable and N. P. Mendler. Recursive definitions in

type theory. In Logics of Programs, volume 193 of Lecture
Notes in Computer Science, pages 61-78. Springer-Verlag,
1985.
[11] R. L. Constable and S. F. Smith. Partial objects in constructive type theory. In Proceedings of the 2nd IEEE Symposium
on Logic in Computer Science, pages 183-193. IEEE Computer Society Press, 1987.
[12] D. M. Gabbay. The declarative past and imperative future. In Temporal logic in specification, volume 398 of Lecture Notes in Computer Science, pages 409-448. SpringerVerlag, 1989.

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.

[13] Y. Gurevich and S. Shelah. Fixed-point extensions of firstorder logic. Annals of Pure and Applied Logic, 32(3):265-
280, 1986.[14] S. Hayashi and H. Nakano. PX: A Computational Logic.

The MIT Press, 1988.[15] R. Hindley. The completeness theorem for typing

*-terms.
Theoretical Computer Science, 22:1-17, 1983.[16] I. M. Hodkinson. On Gabbay's temporal fixed point operator. Theoretical Computer Science, 139:1-25, 1995.[17] W. A. Howard. The formulae-as-types notion of construction. In R. J. Hindley and J. P. Seldin, editors, To H.B. Curry:
Essays on Combinatory Logic, Lambda Calculus and Formalism, pages 480-490. Academic Press, 1980.[18] G. Japaridze and D. de Jongh. The logic of provability. In

Handbook of proof theory, pages 475-546. North Holland,
1998.[19] S. Kobayashi and M. Tatsuta. Realizability interpretation

of generalized inductive definitions. Theoretical Computer
Science, 131(1):121-138, 1994.[20] D. C. Kozen. Results on the propositional

_-calculus. Theoretical Computer Science, 27(3):333-354, 1983.[21] D. Leivant. Typing and computational properties of lambda

expressions. Theoretical Computer Science, 44(1):51-68,
1986.[22] D. B. MacQueen, G. D. Plotkin, and R. Sethi. An ideal

model for recursive polymorphic types. Information and
Computation, 71:95-130, 1986.[23] C. Paulin-Mohring. Extracting

F!'s programs from proofs
in the calculus of constructions. In Proceedings of the 16th
ACM Symposium on Principles of Programming Languages,
pages 89-104, 1989.[24] V. R. Pratt. A decidable

_-calculus (preliminary report). In
Proceedings of the 22nd IEEE Symposium on Foundation of
Computer Science, pages 421-427, 1981.[25] D. S. Scott. A type-theoretical alternative to ISWIM,

CUCH, OWHY. Theoretical Computer Science, 121:411-
440, 1993.[26] M. Tatsuta. Realizability interpretation of coinductive definitions and program synthesis with streams. Theoretical
Computer Science, 122:119-136, 1994.

0-7695-0725-5/00 $10.00\Delta 2000IEEE

Authorized licensed use limited to: UR Rocquencourt. Downloaded on May 28, 2009 at 07:58 from IEEE Xplore.  Restrictions apply.