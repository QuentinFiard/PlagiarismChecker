

Type Checking Higher-Order Polymorphic Multi-Methods

Fran,cois Bourdoncle Stephan Merz
Centre de Math'ematiques Appliqu'ees, Institut f"ur Informatik,

'Ecole des Mines de Paris Universit"at M"unchen

Francois.Bourdoncle@ensmp.fr merz@informatik.uni-muenchen.de

Abstract
We present a new predicative and decidable type system, called ML^, suitable for languages that integrate
functional programming and parametric polymorphism
in the tradition of ML [21, 28], and class-based objectoriented programming and higher-order multi-methods
in the tradition of CLOS [12]. Instead of using extensible records as a foundation for object-oriented extensions of functional languages, we propose to reinterpret ML datatype declarations as abstract and concrete class declarations, and to replace pattern matching on run-time values by dynamic dispatch on run-time
types. ML^ is based on universally quantified polymorphic constrained types. Constraints are conjunctions
of inequalities between monotypes built from type constructors organized into extensible and partially ordered
classes. We give type checking rules for a small, explicitly typed functional language `a la XML [20] with
multi-methods, show that the resulting system has decidable minimal types, and discuss subject reduction.
Finally, we propose a new object-oriented programming
language based on the ML^ type system.

1 Introduction
Designing object-oriented extensions of functional languages is a challenging problem which has received much
attention lately. Apart from special object-oriented calculi [2], which adopt the view that objects are more
primitive than functions, two major approaches have
been studied. In the first approach, objects are extensible records with single-dispatch methods attached to
them. The major advantage of this approach is that
data encapsulation and inheritance are modeled very

To appear in the 24th ACM Conf. on Principles of Prog.
Languages

naturally. However, type systems for extensible records
often rely on intricate higher-order formalisms and/or
recursive types [11, 33].

The second approach, which has received much less
attention both from language designers and type theorists, is to put the emphasis on methods, rather than
objects, and resort to module systems to provide scoping and data encapsulation. In this approach, first
proposed in CLOS [12], and also used in more recent
languages such as Cecil [10], methods are overloaded
functions dispatching on the type of all their input arguments simultaneously. Implementing binary operations, such as an addition operator over a hierarchy of
numeric classes, is a very natural and easy thing to do in
these languages. In contrast, such "multi-methods" are
notoriously hard to type and define in the objects-asrecords model [7]. Moreover, multi-methods defined by
cases look very similar to functions defined by pattern
matching, which makes them an obvious candidate for
extending functional languages like ML. Despite these
advantages, however, no satisfactory static type system
has been proposed so far for functional languages with
multi-methods.

In this paper, we present what we believe to be
the first practical and decidable type system, called
ML^, suitable for languages that integrate functional
programming, parametric polymorphism, class-based
object-oriented programming, and higher-order multimethods. In order to motivate our choices, the examples
of this paper are written in an explicitly typed ML-like
language, namely, a higher-order functional language
with implicit predicative polymorphism, but without
type inference. Our key ideas are to introduce subtyping via extensible hierarchies of type constructors, to
replace functions defined by pattern matching by methods performing dynamic dispatch on the type of their
input arguments, to clearly separate specification and
implementation, and to use a module system to provide separate compilation and encapsulation. As a consequence, we do not model implementation inheritance

Constructor class Point[ ] List[\Phi ]
Type constructors

bpol bcart cart

blinking cartesian

point

\Gamma \Gamma  @@ \Gamma \Gamma  @@

\Gamma \Gamma  @@

snil

slist

scons

nil
list

cons
\Gamma \Gamma  @@

\Gamma \Gamma  @@

Data types

cart[ ] = hh x: real ; y: real ii
bpol[ ] = hh r: real ; a: real ; f : int ii
bcart[ ] = hh x: real ; y: real ; f : int ii

nil[ff]; snil[ff] = hh ii

cons[ff] = hh h: ff ; t: list[ff] ii
scons[ff] = hh h: ff ; t: slist[ff] ; s: int ii

Figure 1: The Point and List constructor classes
in the type system itself, but provide this important
feature using syntactic sugar.

This extended abstract is organized as follows. In
section 2, we give an intuitive introduction to the system using simple examples, motivating our choices as we
go along. Section 3 gives a more formal introduction to
the system as well as major results (completeness, decidability, and minimal typing). For the sake of simplicity, we restrict ourselves to single-module languages. In
section 4, we propose a new modular object-oriented
programming language with multi-methods based on
the type system of section 3. We conclude in section 5
with a discussion of related work. A complete exposition of the system, including all proofs which had to be
omitted due to space restrictions, can be found in [4].

2 Overview
2.1 Constructor classes
Our guiding principle in the design of ML^ has been
to favor the generalization of well-understood concepts,
rather than introducing new and ad-hoc ones. To start
with, instead of defining objects as extensible records,
we take the view that objects are fixed tagged records,
exactly as in ML. For instance, the bottom part of
fig. 1 defines three records representing points in the
plane with Cartesian coordinates, and blinking points in
the plane with polar and Cartesian coordinates. These
records are tagged with cart, bpol, and bcart respectively. The same figure also defines records tagged with
nil and cons, representing empty and non-empty lists,
as well as records tagged with snil and scons, representing empty and non-empty sized lists with constant-time
access to their size.

We call cart, bpol, bcart, snil, nil, cons, and scons
data type constructors. The only run-time entities in

ML^ are functions, methods, and records tagged with
data type constructors. Note that the x fields of cart[ ]
and bcart[ ], for instance, are totally unrelated. In other
words, we do not model implementation inheritance.

One way to write multi-methods is to define them
for every possible combination of tags. However, it is
often desirable to define uniform behaviors over a group
of tags by a single definition. That is why we introduce
the notion of type constructor as a means of naming
groups of tags and allowing for the definition of methods
uniformly over these groups. Technically, we introduce
subtyping through user-defined extensible hierarchies of
type constructors like blinking, cartesian, point, slist, and
list. As opposed to ML, every data type constructor is
a valid type constructor and denotes the group that
consists of only that tag.

In order to prevent arbitrary overloading, we group
semantically related type constructors into extensible
and partially ordered constructor classes like Point and
List. Monotypes are built from type constructors in the
usual way. We identify zero-ary type constructors like
point with the monotype point[ ]. The intuition is that a
type like blinking denotes the set of all blinking points,
irrespective of their representation as data types. The
ordering between constructors reflects the inclusion of
the sets they denote. Similarly, the monotype cons[int]
denotes the type of non-empty lists of integers, whereas
8ff: nil[ff] is the type of the empty list. Consequently, extensible classes like List generalize closed algebraic ML
datatypes like

datatype list[ff] = nil j cons of (ff ? list[ff]);
Monotypes are partially ordered by a structural subtyping relation based on the variance of each class. The
variance of a class is a tuple of elements of f\Phi ; \Psi ; \Omega g
that specifies the arity of the type constructors of the
class as well as the variance of each type parameter.
For instance, class List is unary and covariant, since

2

we intend cons[int] to be a subtype of list[real] (assuming int is a subtype of real). However, the binary class
Arrow, which contains the arrow type constructor, is
contravariant in its first argument, and covariant in its
second argument, so that real ! int is a subtype of
int ! real. All data types of a given class must conform
to its variance. For instance, the record implementation of cons[ff] is valid because ff being covariant both
in the h field and in the t field, it is covariant in the
record. However, this record could not have an extra
field with type ff ! ff, in which ff is non-variant. This
variance specification allows us to reason about the type
constructors of a given class irrespective of the actual
contents of the class, which is clearly a prerequisite for
extensibility in the context of object-orientation.

The partial ordering of type constructors is arbitrary
and allows multiple inheritance of specifications (but
not of implementations). The only restriction is that
data type constructors be minimal, which, as we shall
see in section 2.5, is essential for typing polymorphic
methods. The declaration of a datatype like scons implicitly declares a constructor function scons with type

8ff: ff ! slist[ff] ! int ! scons[ff]
that builds a sized cons from an ff, a sized list of ff's,
and the size of the list, as well as three selector functions

scons:h : 8ff: scons[ff] ! ff
scons:t : 8ff: scons[ff] ! slist[ff]
scons:s : 8ff: scons[ff] ! int

which, in contrast with ML, are total over their domain.

2.2 Methods
Instead of referring to the notion of a self object, as
in the objects-as-records paradigm, we propose to define methods as overloaded functions dispatching on the
tags of all their arguments simultaneously, in pretty
much the same way that ML functions perform pattern
matching on the tags of their arguments.

In the simple system presented in this paper, the
only patterns allowed are " " (any), or a type constructor like slist, meaning that for the associated branch
to be selected, the tag of the actual argument must be
a subconstructor of slist. Strictly speaking, we do not
propose a generalization of pattern matching, since ML
patterns can be more complex than ours, but our system
could be enhanced to allow all ML patterns. In section
4, we show how both dynamic dispatch and pattern
matching could be integrated in a real programming
language.

For instance, method head of fig. 2 raises an exception by default, and returns the h field of conses and

vcons : 8ff: (ff; list[ff]) ! list[ff];
vcons (h: ; t: ) = cons h t;
vcons (h: ; t: snil) = scons h t 1 ;
vcons (h: ; t: scons) = scons h t (1 + (scons:s t));

head : 8ff: list[ff] ! ff;
head (x: ) = raise Empty;
head (x: cons) = cons:h x ;
head (x: scons) = scons:h x ;

map : 8ffList; fi; fl: (ffList[fi]; fi ! fl) ! ffList[fl];
map (l: nil; f : ) = nil;
map (l: snil; f : ) = snil ;
map (l: cons; f : ) =

cons (f (cons:h l )) (map (cons:t l ; f ));
map (l: scons; f : ) =

scons (f (scons:h l )) (map (scons:t l ; f )) (scons:s l );

Figure 2: Operations on lists

sized conses. As opposed to ML, the order in which the
alternatives of a method are defined is irrelevant, since
dynamic dispatch is based on a "best match" approach.
This choice is of course essential to ensure that alternatives of a given method (assumed to be specified by its
type in some interface) can be implemented in several
modules. We show in section 3.3 that by imposing that
the set of patterns of a method be a partition of the
domain of the method, it is possible to guarantee the
absence of "message not understood" or "match failure" run-time errors (exhaustivity), and to ensure the
existence of a best match (non-ambiguity).

Our methods are thus always total over their domain. For instance, method freq of fig. 3 is total over its
domain blinking, and, as opposed to head, this method
does not have a "catch-all" alternative to ensure exhaustivity. Such a method could not have been written
as it is in ML, where intermediate type constructors like
blinking cannot be defined.

More interesting, method vcons of fig. 2 is a "virtual
constructor" dispatching on the type of its second argument. This method by default builds a regular cons,
except when its second argument is a sized list, in which
case it builds a sized cons. Using this virtual constructor, a list built from a sized nil will only consist in sized
conses. For instance, the following expression

E1 = vcons (bpol 1 :0 0 :0 1 ;

vcons (bcart 1 :0 2 :0 3 ; snil ))

builds a non-empty heterogeneous sized list of polar and
Cartesian blinking points. Note that it is not possible to
build arbitrary heterogeneous lists in ML^, as opposed
to type systems based on dynamics [1, 26]. Also, note
that our methods allow a form of overloading that is

3

not possible in ML. For instance, it is possible to define
a fully polymorphic function like

shift : 8ff: ff ! ff;
shift (p: ) = p;
shift (p: cart) = cart ((cart:x p) + 1 :0 ) (cart:y p);

which is essentially the identity, except for non-blinking
Cartesian points. This function is well typed, because
cart being a minimal data type constructor in any extension of class Point, the run-time tag cart of

cart ((cart:x p) + 1 :0 ) (cart:y p)
is identical to the tag of p for any non-blinking Cartesian point p. Methods like shift can thus be used to
perform a weak form of typecase statement [1], and
can be used in particular to perform narrowing type
casts. The scheme we propose to define methods is
thus a mixture of what is traditionally called "parametric polymorphism" in the functional programming
community1, and "polymorphism", or "dynamic dispatch", in the object-oriented community.

2.3 Constrained types
The system we have described so far, in which functions
and methods are explicitly typed, can be made to work
only if every expression has a minimal type. To understand the problem, assume given a function twice with
type

8ff: (ff ! ff) ! (ff ! ff)

and a function trunc with type real ! int. The ML
scheme for typing the application of a polymorphic function like twice to an argument like trunc consists in applying the most specific monomorphic instance of twice
to the type of the argument. However, two instances of
the type of twice can be applied here, namely (int !
int) ! (int ! int) and (real ! real) ! (real ! real),
none of which is more specific than the other. We thus
propose to type the expression (twice trunc) as

8ff: (int ^ ff ^ ff ^ real): ff ! ff
The intuitive denotation of this polymorphic constrained type is, as in ML, a type which is below all
its ground instances, that is, all the ground substitutions of ff ! ff such that ff satisfies the constraint
int ^ ff ^ ff ^ real. In other words, an expression with
this type has both type int ! int and type real ! real,
and can be used in any context where one of these
monomorphic types is acceptable.

1There are generally very few functions with type 8ff: ff ! ff in
traditional models of parametric polymorphism, where methods like
shift cannot be defined.

freq : blinking ! int;
freq (p: bpol) = bpol :f p;
freq (p: bcart) = bcart:f p;

move : 8ff: ff ^ point: ff ! ff;
move (p: cart) = cart (\Gamma 1:2 \Theta  (cart:x p))

(\Gamma 1:2 \Theta  (cart:y p));
move (p: bcart) = bcart (\Gamma 1:2 \Theta  (cart:x p))

(\Gamma 1:2 \Theta  (cart:y p)) (freq p);
move (p: bpol) = bpol (1:2 \Theta  (bpol:r p))

(ss + (bpol :a p)) (freq p);

Figure 3: Operations on points

This example shows that polymorphic constrained
types (types for short) allow the minimal typing of term
application in the context of primitive subtyping. However, many syntactically different types can have the
same meaning. For instance, we certainly intend the
types (8 ;: int) and 8ff: (int ^ ff ^ ff ^ int): ff to have
the same meaning, since they have the same unique
ground instance int. However, not only are we interested in semantic equivalence between types, but we
find it useful to define a partial ordering between types,
for instance to check that the type of a function in a
module conforms to its specification in a recursive let
or in some interface. This idea of subtyping polytypes
is reminiscent of the subtyping rules of F^, and departs
from the tradition in predicative type systems to rely
on a non-deterministic instantiation rule for typing term
application.

In order to ensure that the ordering between types
is compatible with the ordering between monotypes, we
thus say that a polytype o/2 is a subtype of another
polytype o/1 if every ground instance of o/1 is above some
ground instance of o/2 w.r.t. the ordering on monotypes.
As usual, we say that two types are equivalent if they
are subtypes of one another. For instance, 8ff: int ^
ff: ff is a subtype of 8 ;: real, because there exists an ff
satisfying int ^ ff which is above real, namely ff = real.
As a matter of fact, the former type is equivalent to
int, and the above definition of subtyping is compatible
with the interpretation of the universal quantifier of a
type as a greatest lower bound operator.

2.4 Type application
The general typing rule for term application is the following. Suppose e1 has type o/1 = 8#1 : ^1: `1 ! `01,
where #1 is a list of variables, ^1 is a constraint, and `1
and `01 are monotypes with free variables in #1, and that
e2 has type o/2 = 8#2: ^2: `2, with #1 and #2 disjoint.
Then (e1 e2) has type

app(o/1; o/2) = 8#1; #2: ^1 ^ ^2 ^ `2 ^ `1: `01

4

provided the constraint ^1 ^^2 ^`2 ^ `1 is satisfiable, as
defined in section 3.1. The interpretation of this typing
rule is that (e1 e2) has any ground monotype `01 such
that `1 ! `01 is a ground instance of the type of e1
and `1 is above some ground instance `2 of the type of
e2, which is what is intuitively required to apply the
function. For instance, the type of (id 1:0), where id is
the identity with type 8ff: ff ! ff, has type 8ff: float ^
ff: ff, which is equivalent to 8 ;: float. Similarly, the
(static) type of expression E1 of section 2.2 is

o/1 = 8ff; fi; fl: (bpol ^ ff ^ list[fi] ^ list[ff] ^

bcart ^ fi ^ snil[fl] ^ list[fi]): list[ff]

which, thanks to the variance of List, is in fact formally
equivalent to

8ff: (bpol ^ ff ^ bcart ^ ff): list[ff]
which, in turn, is a subtype of o/2 = 8 ;: list[blinking].
An interesting question is whether or not o/2 is a subtype of o/1. In a closed world, the only solution of the
constraint of o/1 is ff = blinking, which is below blinking,
so we could be tempted to consider the two types equivalent. However, in an open world, it may be the case
that some module of the program extends class Point
and defines a strict subconstructor sblinking of blinking
above both bpol and bcart. Such an extension, called
an admissible extension, is allowed provided it does not
modify the ordering between existing type constructors.
In the context of the extended class, ff = sblinking is
thus a ground instance of o/1 but is not above the only
ground instance blinking of o/2. In section 3, we shall
define a complete and decidable axiomatization of subtyping based on a notion of constraint implication that
is invariant w.r.t. admissible extensions of classes.

In conclusion, the type of E1 is a strict subtype of
list[blinking], and can be read as the type of all lists
containing blinking points with polar and Cartesian coordinates, but nothing else, and in particular, no other
kind of blinking points. In other words, a type like
8ff: (bpol ^ ff^bcart ^ ff): ff can be read as "the smallest ff above bpol and bcart" and can be understood as
the set union of bpol and bcart.

2.5 Polymorphic multi-methods
In addition to ensuring minimal types, constrained polymorphic types also allow for a very precise typing of
methods. For instance, method move of fig. 3 has type

8ff: ff ^ point: ff ! ff
meaning that move returns an object with the same tag
as its argument of type point. The implementation of

neg zero pos
float int per

real 2adic
\Gamma \Gamma 

\Gamma \Gamma 

\Gamma \Gamma @@

@@

@@

Figure 4: The numeric class Num
move conforms to this specification since bpol, bcart,
and cart are minimal data type constructors. Moreover, we show in section 3 that the type of move is a
strict subtype of 8 ;: point ! point, which shows that
move can be used anywhere a function with the latter type is expected. More interesting, as opposed to
single-dispatch languages, method move is a first-class
function which can be passed as a parameter to other
functions, such as the higher-order polymorphic multimethod map of fig. 2. The type of map states that
given a list with type ffList[fi], where ffList is some type
constructor in List, and a function with type fi ! fl,
map returns a list with type ffList[fl], which shows in
particular that map applied to an empty list returns
an empty list. Note that this precise type ensures that
the recursive call of map in the fourth alternative of its
definition is a sized list and can thus be used to build a
sized cons. Similarly, it can be shown that the expression E2 = map (E1; move) has type

8ff: (bpol ^ ff ^ bcart ^ ff ^ ff ^ point): list[ff]
which shows that freq (head E2) is well-typed and has
type int. Methods like move can be specified in some
object-oriented languages with a specification like

abstract class point is

virtual method move(): like self
end

However, the advantage of our approach is that it
generalizes to multi-methods, and is also much more
expressive. For instance, the subtraction method sub of
fig. 5 has type 8ff: int ^ ff: (ff; ff) ! ff. The hierarchy
used in this example, shown in fig. 4, has positive, negative, and zero integers, as well as floating point numbers
and periodic 2-adic numbers2. The type of sub ensures
that per's and float's cannot be subtracted from one another (since the constraint int ^ ff ^ per ^ ff ^ float ^ ff
has no solution over the class shown in fig. 4) and also
ensures that the static type of a subtraction is always a
supertype of int. For instance, using the typing rule for
application, we can show that the type of sub (+1; \Gamma 2)
is 8ff: (int ^ ff ^ pos ^ ff ^ neg ^ ff): ff, which is equivalent to 8 ;: int. In other words, the type of sub is
polymorphic above int, and constant below int.

2This numeric hierarchy is used in the hardware description language 2z, which motivated this work [40].

5

It is interesting to compare our approach to similar
systems in the literature. The language presented by
Reppy and Riecke [35, 36] allows the definition of methods returning objects with the type selfty of the receiver, so that methods like move can be written. However, the restriction that selfty cannot occur in negative positions in the type of methods prevents methods
like sub to be given the precise type of our example.
The language of Bruce et al. [6] uses a similar notion of
MyType without the restriction on negative positions.
However, the interpretation of MyType in a method
type like MyType ! MyType and the interpretation of
the type variable ff in the type 8ff: int ^ ff: (ff; ff) ! ff
of the sub function are quite different: MyType refers to
the dynamic type of the receiver (i.e., the first argument
of the multi-method), whereas ff is the "minimum" type
which is above both arguments of the method. This interpretation of MyType thus prevents reals to be subtracted from integers. One possible remedy, for singleinheritance languages, could be to replace the notion
of selfty or MyType by the notion of alike, denoting the smallest supertype of all arguments with type
alike, including the receiver.

Type classes [19, 31, 41] and constructor classes [23]
have also been advocated as a means to provide some of
the functionality of methods in ML-like languages. In
essence, these systems allow the instantiation of overloaded specifications which consist in type templates
with a single type variable, such as the instantiation
of the template (ff; ff) ! ff for ff = int and ff = real. In
the absence of any subtyping relation between int and
real, such simple specifications cannot express complex
types such as the type of the sub method and, in particular, do not allow the typing of mixed operations
like sub(1:2; 3). Multi-parameter type classes, i.e., type
templates with more than one variable, have thus been
proposed to lift this restriction. The idea is to use a template like (ff; fi) ! fl and instantiate it with all possible
interesting combinations of ff, fi, and fl, for example
(int; int; int); (int; real; real). However, multi-parameter
type classes are not without problems: type-checking
is undecidable in general [15], it is possible to overload
functions with structurally different signatures, and the
overloading resolution algorithm can be quite tricky and
unintuitive, a mixture which has already proven very
dangerous in C++. This is why we believe that the
dispatching mechanism based on structural subtyping
that is used in ML^ is closer in spirit to that of classical object-oriented languages than the non-structural
overloading scheme used in languages like Haskell and
Gofer. Nonetheless, it may be interesting to add type
classes to ML^ to allow for overloaded functions like
print with type 8ff: Print(ff): ff ! unit where Print is
an inductively defined predicate on types.

toFloat : real ! float;
toPer : 2adic ! per;
subInt : (int; int) ! int;
subFloat : (float; float) ! float;
subPer : (per; per) ! per;

sub : 8ff: int ^ ff: (ff; ff) ! ff;
sub (x1: float; x2 : real) = subFloat (x1; toFloat x2);
sub (x1: per; x2 : 2adic) = subPer (x1; toPer x2);
sub (x1: int; x2: int) = subInt (x1; x2);
sub (x1: int; x2: float) = subFloat (toFloat x1; x2);
sub (x1: int; x2: per) = subPer (toPer x1; x2);

Figure 5: Subtraction

3 Type system
We now formally define our type system. A constructor
class C is given by a name, a finite and non-empty set
TC of type constructors tC, a subset DC ` TC of data
type constructors dC, a partial order vC on TC such
that data type constructors are minimal with respect
to vC, and a tuple of elements of the set f\Phi ; \Psi ; \Omega g
called the variance of the class. The arity of a class is
the length of its variance.

A type structure is a finite set T of constructor classes
with distinct names and pairwise disjoint sets of type
constructors. We assume that every type structure contains a (\Psi ; \Phi )-variant class Arrow with at least one
data type constructor !. In order to model objectorientation, we must provide for the extension of type
structures. Adding new classes is never a problem (assuming that there are no name clashes), because type
constructors of different classes are completely unrelated to each other. When new type constructors are
added to existing classes, one has to preserve the ordering on existing type constructors as well as the minimality of data type constructors. We thus formally define
T \Lambda  to be an admissible extension of T if for every class
C in T , there exists a class C\Lambda  in T \Lambda  with the same
name and variance such that TC\Lambda  is a superset of TC,
the intersection of TC and DC\Lambda  is equal to DC, and for
all type constructors t1; t2 2 TC, we have t1 vC\Lambda  t2
if and only if t1 vC t2. The overall requirement that
data type constructors are minimal in any class implies
that T \Lambda  cannot define a subconstructor of any data type
constructor defined in T .

We assume given countable and pairwise disjoint sets
of type variables v, v0, etc., and, for each class C, Cconstructor variables vC, v0C, etc. The set of monotypes
` over T is the least set containing type variables such
that when \Theta C is a list of monotypes whose length agrees
with the arity of C, and OEC is a C-constructor, i.e., a
C-type constructor tC in TC or a C-constructor variable

6

vC, then OEC[\Theta C] is a monotype. A variable-free monotype is said to be T -ground (or just ground, for short).
As usual, we write `1 ! `2 instead of ! [`1; `2].

The ordering ^ on ground monotypes is the least
relation such that tC vC t0C and \Theta C ^C \Theta 0C imply
tC[\Theta C] ^ t0C[\Theta 0C], where the relation ^C on lists of
ground monotypes is defined as the componentwise ordering induced by the variance of C. For instance,
`1; `2 ^Arrow `01; `02 if and only if `01 ^ `1 and `2 ^ `02.
We use # to denote a list of type or constructor variables, and #C to denote a list of distinct type variables
whose length agrees with the arity of C.

3.1 Constraints
A constraint ^ is a conjunction of inequalities OEC v OE0C
between C-constructors and inequalities ` ^ `0 between
monotypes. A variable-free constraint is said to be
ground. We treat constraints as sets of conjuncts, and
we write ^ f^0g to denote that ^0 is a subset of ^. We
denote by ` = `0 the constraint ` ^ `0 ^ `0 ^ `, and by
true the empty constraint.

Intuitively, we intend a constraint to be satisfiable
if it has a solution on ground monotypes. However, for
the subtyping relation between polytypes discussed in
section 2.3, we also need a notion of satisfiability of a
constraint w.r.t. some other. To this end, we define the
implication of constraint ^2 by constraint ^1 for all #
as the judgment 8#: ^1 j= ^2 axiomatized by the rules
of fig. 6 together with the transitivity rule

8#: ^1 j= ^2 8#: ^2 j= ^3 [Trans]

8#: ^1 j= ^3

In rule VElim, we write ` ' `0 to denote either
` ^ `0 or `0 ^ `. A #-substitution oe maps type variables to monotypes and C-constructor variables to Cconstructors, and is the identity over variables in #. We
denote by ^[oe] the application of oe to ^.

Rule VIntro introduces new variables on the righthand side by abstracting away certain subterms of the
left-hand side. For example, an instance of this rule is

8 ;: bpol ^ blinking ^ bcart ^ blinking
j= bpol ^ ff ^ bcart ^ ff

which reads "bpol ^ blinking and bcart ^ blinking implies the existence of some ff such that bpol ^ ff and
bcart ^ ff." In other words, the free variables of ^1 and
^2 that are not in # are existentially quantified.

Rules MIntro, MElim, and VElim reflect the fact
that the ordering on monotypes is purely structural,
that is, comparable types must have the same "shape".
Therefore, every solution for a variable v in constraint
v ' OEC [\Theta C] is of the form OE0C[\Theta 0C].

[Approx ] 8#: ^ f^0g j= ^0
[CRef ] 8#: ^ j= ^ ^ OEC v OEC
[CTrans] 8#: ^ fOEC v OE0C v OE00Cg j= ^ ^ OEC v OE00C
[CGnd ] 8#: ^ j= ^ ^ tC v t0C (if tC vC t0C)
[CMin] 8#: ^ fOEC v dCg j= ^ ^ dC v OEC
[MRef ] 8#: ^ j= ^ ^ ` ^ `
[MTrans] 8#: ^ f` ^ `0 ^ `00g j= ^ ^ ` ^ `00
[MIntro] 8#: ^ f\Theta C ^C \Theta 0C ^ OEC v OE0Cg

j= ^ ^ OEC[\Theta C] ^ OE0C [\Theta 0C]
[MElim] 8#: ^ fOEC[\Theta C] ^ OE0C[\Theta 0C]g

j= ^ ^ OEC v OE0C ^ \Theta C ^C \Theta 0C
[VIntro] 8#: ^[oe] j= ^ (if oe is a #-substitution)
[VElim] 8#: ^ fv ' OEC[\Theta C]g

j= ^ ^ v = vC[#C] (vC; #C fresh)

Figure 6: Constraint implication

We say that a constraint ^ is well-formed if and only
if the judgment 8;: true j= ^ is derivable. The following
theorems show that implication is decidable, and that
the axiomatization of fig. 6 is both sound and complete
w.r.t. the extensibility of constructor classes. In particular, it follows that well-formedness and satisfiability
coincide.

Theorem 1 If ^1 is a well-formed constraint, and ^2
is an arbitrary constraint, then it is decidable whether
8#: ^1 j= ^2 holds. In particular, well-formedness of
constraints is decidable.

Theorem 2 Let # be a list of variables, and ^1 and ^2
be two well-formed constraints. Then 8#: ^1 j= ^2 is
derivable if and only if for every admissible extension
T \Lambda  of T and every T \Lambda -ground substitution oe1 such that
^1[oe1] is satisfied in T \Lambda , there exists a T \Lambda -ground substitution oe2 that agrees with oe1 on the variables of #
such that ^2[oe2] is a ground constraint satisfied in T \Lambda .

The algorithm to determine the well-formedness of a
constraint ^ described in [4] first checks that ^ is wellkinded and then determines a representation of its solutions in the form of a most general substitution constrained by a set of independent base constraints on
type variables and C-constructors for each class C.

A constraint ^ is well-kinded if the set of equations
built from ^ by replacing C-constructors by the uninterpreted function symbol C and inequality symbols by
equalities is unifiable. Similar notions have been introduced in the literature [17, 29, 30].

Given a well-kinded constraint ^, the first step of
the decision procedure for well-formedness consists in

7

(N1) ^; (^0 ^ OEC[\Theta C] ^ OE0C[\Theta 0C]) \Gamma !

^; (^0 ^ OEC v OE0C ^ \Theta C ^C \Theta 0C)
(N2) ^; ^0 fv ' OEC[\Theta C]g \Gamma !

(^ ^ v = vC[#C]); ^0[vC[#C]=v]

Figure 7: Normalization of well-kinded constraints

rewriting (true; ^) by the two rules of fig. 7, where vC
and #C are assumed to be fresh. The well-kindedness of
^ ensures that this process eventually terminates, and
that the result (^=; ^^) is such that ^= represents a
"most general substitution", whereas ^^ is a conjunction of a constraint on type variables and constraints ^C
between C-constructors for each class C. The last step
for deciding well-formedness consists in checking that
each constraint ^C is satisfiable over the current type
structure, which is trivially decidable by finite enumeration. For instance, the solutions of the constraint

(ff ^ fi ! fl) ^ (fl ^ real)
are of the form ff = ff1 ! ff2[ ] and fl = fl1[ ] where
fi ^ ff1 and ff2 v fl1 ^ fl1 v real, which is satisfiable, for
instance, taking ff2 = int and fl1 = real.

The procedure for deciding 8#: ^1 j= ^2 consists in
applying the decision procedure for well-formedness to
compute the most general substitution ^=1 of ^1 and the

base constraints ^^1 as above. For the sake of simplicity,
we assume that ^1 and ^2 do not share variables except
for the ones in #. It can be shown that the free variables
of ^^1 , together with the partial ordering induced by ^^1 ,
define the "most general" admissible extension of the
current type structure satisfying ^1. Deciding the implication then amounts to deciding the well-formedness
of ^2 w.r.t. this extended type structure, thus considering the variables of ^1 as constants.

It is easy to see that rewriting may cause an exponential increase in the size of the constraints. Since satisfiability of a set of base constraints is NP-complete [27, 34],
our decision procedure for well-formedness is thus at
worst doubly exponential, but [38] shows that the problem is in fact in DEXPTIME. Finally, it follows from
[37] that deciding well-formedness is PSPACE-hard. A
fortiori, deciding implication is PSPACE-hard.

However, when type-checking real-life programs, we
believe that the rewriting step will not cause a blowup
in the number of variables, and the only costly part of
the decision procedure will be to test the satisfiability
of base constraints, which is NP-complete. Figure 8
gives a fixpoint-based algorithm C-SAT, inspired by an
incomplete algorithm by Fuh and Mishra [17], to decide
the satisfiability of a base constraint ^C. The initial
call C-SAT(^C; oeC ) must be performed with a valuation
function oeC mapping every C-constructor OEC to the set

procedure C-SAT(^C; oeC) is

let oe0C = T i * 0 \Phi iC(^C; oeC) in

if 9 vC: joe0C(vC)j = 0 then fail;
if 8 vC: joe0C(vC)j = 1 then succeed;
for each vC such that joe0C(vC)j ? 1 do

for each tC in oe0C(vC ) do

C-SAT(^C; oe0C[vC 7! ftCg])
end C-SAT

Figure 8: Satisfiability of base constraints

TC. The functional \Phi C is defined as follows

\Phi C(^C; oeC)(tC) = f tCg
\Phi C(^C; oeC)(vC) = T ^

C fOEC vvCg "C oeC(OEC )" T

^C fvC vOECg #C oeC(OEC )

where "C S (resp. #C S) denotes the upper (resp. lower)
ideal generated by the subset S of TC w.r.t. the partial
order (TC; vC). Our experience with a first implementation of this algorithm has been very encouraging.

3.2 Types and domains
Typing judgments in our system are always expressed
w.r.t. a constraint context \Delta  = (#: ^), which is used to
store type information for symbols defined in the context of the current declaration, and intuitively asserts
the existence of variables # satisfying ^. We say that a
type o/1 = 8#1: ^1: `1 is well-formed w.r.t. \Delta  if # and
#1 are disjoint and the free variables of ^1 and `1 are
either in # or in #1, and if ^ implies ^1 for all #. The
latter condition ensures that ^1 is well-formed for every solution of the "global" constraint ^. As a concrete
example, consider the function

fun fff j trueg (x: ff) ) let y = sub(x; 1) in (not x)
expressed in the language defined in section 3.3. If, in
the definition of well-formed types, we simply required
that ^ ^ ^1 be well-formed, instead of requiring that ^
imply ^1 for all #, then y would have type

8fi : (int ^ fi ^ ff ^ fi ^ pos ^ fi): fi
w.r.t. constraint context (ff: true), and (not x) would
have type 8;: ff ^ bool: bool, so that the function would
appear to be well-typed, with type 8ff: ff ^ bool: ff !
bool, but every application of that function would fail
at run-time.

For the sake of simplicity, we assume that the bound
variables of types can be freely ff-converted to names
that do not occur in the constraint context. In the light
of theorem 2 and of the discussion of section 2.3, we

8

say that o/2 = 8#2: ^2: `2 is a subtype of o/1 w.r.t. \Delta 
(assuming #1 and #2 disjoint), written \Delta  ` o/2 ^ o/1, if
and only if

8#; #1: ^ ^ ^1 j= ^2 ^ `2 ^ `1
This definition of subtyping can be seen as a generalization of the instance relation between well-typings
of Mitchell [29, 30]. We show in [4] that this rule is also
sound w.r.t. the three variants 8-orig, 8-top, and 8-Fun
of the subtyping rule of F^ considered in [9].

It follows immediately from theorem 1 that subtyping is decidable. As an example, let us prove that the
type

8ff: ff ^ point: ff ! ff

of method move is a strict subtype of 8 ;: point ! point
w.r.t. the empty context. We have to prove

8;: true j= ff ^ point ^ ff ! ff ^ point ! point
which follows by rule VIntro from

8;: true j= point ^ point ^

point ! point ^ point ! point

On the other hand, 8 ;: point ! point is not a subtype of 8ff: ff ^ point: ff ! ff, so the latter type is
a strict subtype of the former one. For otherwise, we
would have to show

8ff: ff ^ point j= point ! point ^ ff ! ff
which, by rule MElim, amounts to proving

8ff: ff ^ point j= ff = point
which is obviously not derivable.

One distinguishing feature of our system is that the
type application operator app is monotonic in both arguments w.r.t. the subtyping relation, which shows that
every functional type o/1 = 8#1: ^1: `1 ! `01 can be
identified with a monotonic type transformer, as opposed to F^ where type application is defined in terms
of syntactic substitution. Note that the downside of
this property is that type application in ML^ is approximated [4].

We formally define the domain dom(o/1) of the functional type o/1 as ffi1 = 9#1: ^1: `1. Intuitively, domains
denote downward closed sets of types. It can be shown
that dom is contravariant w.r.t. the subtyping relation.
We say that a domain ffi2 = 9#2 : ^2: `2 is a subdomain
of ffi1 w.r.t. \Delta  (assuming #1 and #2 disjoint), written
\Delta  ` ffi2 ^ ffi1, if and only if

8#; #2: ^ ^ ^2 j= ^1 ^ `2 ^ `1

and we say that a type o/2 = 8#2: ^2: `2 belongs to ffi1
w.r.t. \Delta , written \Delta  ` o/2 2 ffi1, if

8#: ^ j= ^1 ^ ^2 ^ `2 ^ `1
It can be shown that app(o/1; o/2) is well-formed w.r.t.
\Delta  if and only if o/2 belongs to dom(o/1) w.r.t. \Delta . Moreover, the subtyping and membership relations are transitive in the following sense

\Delta  ` o/1 ^ o/2 \Delta  ` o/2 2 ffi3

\Delta  ` o/1 2 ffi3

\Delta  ` o/1 2 ffi2 \Delta  ` ffi2 ^ ffi3

\Delta  ` o/1 2 ffi3

so that every subtype of a type in dom(o/1) also belongs
to dom(o/1), which agrees with the substitutivity principle of object-oriented languages and justifies the view
of domains as downward closed sets of types.

Finally, we show in [4] that types form a preorder,
and that two compatible types (i.e., types with a common upper bound) 8#1: ^1: `1 and 8#2: ^2: `2 have the
following least upper bound

8v; #1; #2 : (^1 ^ ^2 ^ `1 ^ v ^ `2 ^ v): v
where v is a fresh type variable, and #1 and #2 are assumed to be disjoint. Dually, two compatibles domains
ffi1 and ffi2 always have a greatest lower bound ffi1 ^ ffi2.

3.3 Type checking
Fig. 9 gives type checking rules for an explicitly typed
functional language `a la XML [20] with higher-order
multi-methods. Programs consist in a single expression
type checked w.r.t. a fixed type structure T that we
assume to be defined with some concrete syntax. A
well-formed typing context is a pair (\Delta ; \Gamma ) where \Delta  is a
well-formed constraint context, and \Gamma  is a list of bindings of the form x: o/ for expression variables, where each
o/ is well-formed w.r.t. \Delta . We assume that \Gamma  binds constructor and selector functions to their type, as defined
at the end of section 2.1. The domain ffi = 9#: ^: ` of a
function

fun f# j ^g (x: `) ) e

is given explicitly but, as opposed to methods, the return type of functions is inferred from their bodies by
rule Fun. A method m is an expression of the form3

meth f# j ^g (x: `): `0 ) [ss1 ) e1; : : : ; ssn ) en]
where each pattern ssi is a special kind of domain of the
form4 9#: (`1; : : : ; `n), where # is a list of type variables

3We used some syntactic sugar, explained in section 4, for the
examples of section 2.

4We assume that tuples are implicitly defined data types, with

appropriate constructor and selector functions.

9

\Delta ; \Gamma  fx: o/ g ` x: o/ [Var ]
\Delta ; \Gamma  ` e: o/ \Delta  ` o/ ^ o/ 0 [Sub]

\Delta ; \Gamma  ` e: o/ 0

\Delta ; \Gamma  ` e1 : o/1 \Delta ; \Gamma [x1: o/1] ` e0: o/0 [Let]

\Delta ; \Gamma  ` (let x1 = e1 in e0): o/0

\Delta ; \Gamma [x1 : o/1; : : : ; xn : o/n] ` ei: o/i (0 ^ i ^ n) [Letrec]
\Delta ; \Gamma  ` (letrec x1: o/1 = e1; : : : ; xn : o/n = en in e0): o/0

\Delta ; \Gamma  ` e: o/ \Delta ; \Gamma  ` e0 : o/ 0 \Delta  ` o/ 0 2 dom(fun(o/ )) [App]

\Delta ; \Gamma  ` (e e0): app(fun(o/ ); o/ 0)

\Delta [v; #: ^ ^ v ^ `]; \Gamma [x: 8 ;: v] ` e: (8#0 : ^0: `0) (v fresh) [Fun]
\Delta ; \Gamma  ` (fun f# j ^g (x: `) ) e): (8v; #; #0: ^ ^ ^0 ^ v ^ `: v ! `0)

ffi = 9#: ^: ` ssi = 9#i: `i ss1; : : : ; ssn is a partition of ffi w.r.t. \Delta 
\Delta [v; #; #i: ^ ^ v ^ ` ^ v ^ `i]; \Gamma [x: 8 ;: v] ` ei: (8 ;: `0) (1 ^ i ^ n; v fresh) [Meth]

\Delta ; \Gamma  ` (meth f# j ^g (x: `): `0 ) [ss1 ) e1; : : : ; ssn ) en]): (8#: ^: ` ! `0)

Figure 9: Typing rules

with at most one occurrence in (`1; : : : ; `n), and each
`i is either a single variable or tC[#C] for some type
constructor tC and variables #C.

We think of a method as a set of functions, one for
each pattern ssi, whose type is a subtype of the method
type, restricted to the domain ssi. In contrast to ML
patterns, which may be complex, the present definition
of ML^ patterns allows for dynamic dispatch according
to the outermost type constructor only. Rule Meth defines the type of method m as 8#: ^: ` ! `0, provided
that two conditions are met.

First, the set of patterns must be a partition of the
method's domain 9#: ^: `, to ensure the absence of
"method not understood" errors at run-time, as well
as the existence of a most specific pattern for every
type in the domain of the method. Technically, we
say that a set of patterns ss1; : : : ; ssn is a partition of
ffi = 9#: ^: (`1; : : : ; `k) if (1) every pattern is compatible with ffi w.r.t. \Delta , and (2) for all data type constructors dC1; : : : ; dCk in the current type structure such that
ffi[\Delta ] and

ss = 9#C1 ; : : : ; #Ck : (dC1[#C1 ]; : : : ; dCk [#Ck ])
are compatible, the set fssi j 9i 2 [1; n]: ss ^ ssig has
a minimum element. In the presence of a module system, this decidable condition must be checked at link
time, when all the data type constructors, and therefore, all the entities that can possibly exist at run-time,
are known. The closure ffi[\Delta ] of ffi w.r.t. \Delta  = (#0: ^0) is
defined by 9 #0; #: ^0 ^ ^: (`1; : : : ; `k)

Second, the body ei of each alternative must have
type 8 ;: `0 in the context where x is assumed to have

both monotype ` enforced by the domain of m and
monotype `i enforced by pattern ssi.

The remaining rules are straightforward. Rule Sub is
a subsumption rule reminiscent of F^. Rule App uses
the app and dom operators defined earlier, as well as
the upper-closure operator fun defined by

fun(8#: ^: `) = 8v; v0; #: (^ ^ ` ^ v ! v0): v ! v0

Assuming that e and e0 have minimal types, the covariance of fun and app, the contravariance of dom,
and the transitivity of the subtyping and the membership relations ensure that (e e0) has a minimal type.
This is the main argument in the proof of the following
theorem, which expresses that ML^ has minimal types
(but not minimal typings, since we are not concerned
about type inference in this paper).

Theorem 3 Let (\Delta ; \Gamma ) be a well-formed typing context.
It is decidable whether an expression e is well-typed in
the context (\Delta ; \Gamma ). If e is well-typed, it has a minimal
type and this minimal type can be effectively determined.

Having minimal types is an important property of
type systems. However, soundness is even more important. For lack of space, we omit the definition of
an operational semantics for ML^, and the proof of
soundness. A strict operational semantics, as well as
a subject-reduction theorem, can be found in the technical report [4]. This operational semantics tags every
run-time object with its minimal, closed type o/ , and
dynamic dispatch is performed by selecting the smallest pattern ss such that o/ belongs to ffi[\Delta ] ^ ss.

10

interface List is

// Covariant class of all list constructors
class List!covariant T?;

// Lists (declares list)
abstract list in List!T? is

// No field
with

// Constructors
vcons(h: T): cons!T?;
cons(h: T): #cons!T?;
scons(h: T): #scons!T?;

// Methods
head(): T;
tail(): list!T?;
size(): int;
reverse(): alike;
concat(l: alike): alike;
map(f: T -? U): L!U?

where alike = L!T? end
end;

// Empty list (declares nil and #nil)
concrete nil ! list in List!T? is

// No new field or method
end;

// Cons lists (declares cons and #cons)
concrete cons ! list in List!T? is

// Head and tail fields
h: T;
t: list!T?
end;

// Sized lists (declares slist)
abstract slist ! list in List!T? is

// No new field or method
end;

// Empty sized lists (declares snil and #snil)
concrete snil ! nil, slist in List!T? is

// No new field or method
end;

// Sized cons lists (declares scons and #scons)
concrete scons ! cons, slist in List!T? is

// Size field
s: int
end

end List;

module List is

open List;
// Constructors
list::vcons(h: .) = self.cons(h);
slist::vcons(h: .) = self.scons(h);
list::cons(h: .) =

#cons fh=h, t=selfg;
list::scons(h: .) =

#scons fh=h, t=self, s=1+self.size()g;

// Head of a list
nil::head() = raise Empty;
cons::head() = self.h;

// Tail of a list
nil::tail() = raise Empty;
cons::tail() = self.t;

// Size of a list
nil::size() = 0;
cons::size() = 1+self.t.size();
scons::size() = self.s;

// Reverse method and local auxiliary method rev
nil::reverse() = self;
#cons::reverse() =

rev(self.t, #nil.cons(self.h)g);
#scons::reverse() =

rev(self.t, #snil.scons(self.h)g);

rev(l: list!T?, r: L!T?): L!T?

where L !: cons end;
rev(l: nil, r: .) = r;
rev(l: cons fh, tg, r: #cons) =

rev(t, r.cons(h));
rev(l: cons fh, tg, r: #scons) =

rev(t, r.scons(h));

// Concatenation
nil::concat(l: .) = l;
#cons::concat(l: .) =

self.t.concat(l).cons(self.h);
#scons::concat(l: .) =

self.t.concat(l).scons(self.h);

// Map method
#nil::map(f: .) = #nil;
#snil::map(f: .) = #snil;
#cons::map(f: .) =

self.t.map(f).cons(f(self.h));
#scons::map(f: .) =

self.t.map(f).scons(f(self.h))

end List;

Figure 10: The List package

11

4 Towards a real programming language
We now sketch a new class-based object-oriented language with multi-methods, and show how its syntax can
be desugared into ML^. Instead of formally defining the
language, we exemplify its constructs at the hand of the
List package of fig. 10. Note that the type hierarchy of
this package, shown in fig. 11, is more refined than the
one of fig. 1.

First of all, we show how to add implementation inheritance. For the sake of simplicity, as for most classical object-oriented languages, we do not separate the
implementation inheritance hierarchy from the subtyping hierarchy, but doing so would be easy. A declaration
like abstract list declares a type constructor list
in constructor class List. This type constructor corresponds to an abstract parameterized class in OO parlance. A declaration like concrete cons declares both
a type constructor cons below list in class List and a
data type constructor #cons below cons in class List.
As always, cons can have subconstructors, but #cons
is minimal, and has its own constructor and selector
functions. The declaration of cons imposes that every data type constructor below cons, including #cons,
has two fields h of type T and t of type list!T?. The
syntax #cons fh=1, t=#nilg can be used to build a
#cons data object, and access, e.g., to the h field of a
cons object is performed via a method named List::h
implicitly defined as follows

List::h(self: cons!T?): T;
List::h(self: #cons) = #cons.h(self);
List::h(self: #scons) = #scons.h(self);

using the selector functions of each data type below
cons. Note the use of constructor classes to provide a
scope for field and method names. Also, note that the
above notation for defining methods by cases, which allows a method to be implemented in different modules,
is syntactic sugar for the following ML^ method

meth fff j trueg (self: cons[ff]): ff )
[ 9fi: #cons[fi] ) #cons:h self ;

9fl: #scons[fl] ) #scons:h self ]

If l is a list with a type in the domain of method
List::h, the dot notation l.h translates into the function call List::h(l). Such a disambiguation, based on
the class of the first argument, is always possible provided that l does not have the empty type 8ff: ff.

Class methods like map specify a regular method
List::map with two parameters: an implicit self parameter with type alike, and a parameter f with type
T -? U. The fact that map is defined in the scope of the
definition of list automatically enforces the constraint

list
nil slist cons
#nil snil scons #cons

#snil #scons

\Gamma \Gamma  @@
\Gamma \Gamma  AA \Delta \Delta  AA \Delta \Delta  @@

\Gamma \Gamma  @@

Figure 11: Type hierarchy of the List package
alike !: list!T?. The type of map is thus

8 T; U; LList; alike : alike ^ list[T ] ^ alike = LList[T ]:

(alike; T ! U ) ! LList[U ]

As explained in section 2.5, alike does not necessarily denote the minimum type of the self parameter,
in contrast to what selfty does in Object ML [35, 36].
For example, method concat has type

8 T; alike : alike ^ list[T ]: (alike; alike) ! alike
which shows, in particular, that the concatenation of
two empty lists is an empty list, a property not expressible in any language we are aware of. The dot
notation l.map(f) can be used as for fields to perform
the function call List::map(l, f).

A class method like head is implemented by defining
method List::head by cases, and the syntax

cons::head() = self.h
in the definition of head is syntactic sugar for

List::head(self: cons) = self.h
that makes the self parameter explicit. The latter style
of definition offers the possibility to perform pattern
matching on the self parameter as in

List::head(self: cons fhg) = h
where cons fhg is syntactic sugar for cons fh=hg.

Note the use of the local method rev to implement
reverse. This method accepts any list!T? as first argument, any L!T?, where L is a type constructor below
cons, as second argument, and returns a L!T?. Defining
methods independently from the type hierarchy allows
this kind of methods to be defined as required without the need to introduce a new subtype to hold the
method. Also, note how the fairly imprecise type of the
virtual constructor vcons prevents its use in methods
like map with very precise types. Finally, remark that
an interface defines a name space for the entities that it
declares. For instance, the qualified name of class List
is List.List, and the fully qualified name of method
map is List.List::map. The meaning of a program
with several modules and interfaces consists in a global
letrec containing all the declarations and implementations contained in these modules and interfaces.

12

5 Related work and conclusion
Our interest in this paper has been to enhance the standard Hindley-Milner type system [21, 28] for an explicitly typed version of ML so that it can be used for
higher-order object-oriented languages with polymorphic multi-methods. We believe that ML^ is a practical
and natural extension of the Hindley-Milner type system, and that constraint implication is a unifying concept for such extensions. In particular, it should not be
too difficult to add type classes [31, 41] to our framework
by refining the notion of constraint implication. We
conjecture that type inference for ML^ programs without methods could be easily adapted from techniques
developed in the literature [3, 16, 17, 18, 22, 30, 32].
We believe that inferring the type of methods will be
much more challenging.

The model developed in this paper is very similar
to that of the programming language Cecil [10], in particular by its distinction between concrete and abstract
classes, the distinction between subtyping and implementation inheritance, the use of method specifications,
and the use of modules to provide encapsulation. However, the type system proposed by Chambers and Leavens is only first-order and monomorphic, and the specification of methods by means of sets of monomorphic
signatures is less expressive and more ad-hoc than ours.
Nonetheless, many of the techniques developed in [10]
could be adapted to our system, in particular techniques for true separate compilation of multi-methods
and compilation of dynamic dispatch.

Castagna et al. [8] have defined an extension of F^
that allows function overloading in a higher-order setting with explicit polymorphism and primitive subtyping. Their model is quite powerful but technically rather
tricky, as all impredicative models. Moreover, methods
lack specifications, which can be a problem for modularity and scalability.

ML^ also has strong links with all systems derived
from the Hindley-Milner type system, in particular, systems of overloaded functions built around the notions of
type and constructor classes [23, 24, 41]. These systems
are incomparable to ML^ in terms of expressive power
(non-structural overloading vs. true methods) but we
find ML^ much closer in spirit to class-based objectoriented languages, and also easier to extend.

Duggan [13, 14], and then Odersky, Wadler, and
Wehr [31] have proposed the use of kinded types, which
are polymorphic constrained types with constraints on
available instances of the operations used by function
bodies. This approach can be made to work under the
"open world" assumption [13, 31], but types are rather
hard to read, since they mention program functions, and
lead to method specifications which are dependent on

the program's text, which may be a problem for modularity and scalability. On the other hand, type inference
is made easier by such an approach.

Kaes [25] has tackled the decidability of type inference in the context of overloading, subtyping, and recursive types, using polymorphic constrained types which
are more expressive than ours, and with a precise typing of arithmetic operators. Moreover, his notion of
"structural similarity" is fairly close to our notion of
constructor class. However, his paper does not address
the problem of defining methods and performing dynamic dispatch.

Mitchell [29, 30], Fuh and Mishra [17, 18], Aiken and
Wimmers [3], and Eifrig, Smith, and Trifonov [16], have
also addressed the problem of type inference in the presence of primitive subtyping. Our notion of constraint
implication can be seen as a generalization of the instance notion for well-typings. Smith et al. [16] propose
a record-based object-oriented language with polymorphic methods which are less expressive than ours, and
the use of recursive types leads to a complex and potentially undecidable subtyping relation with an incomplete, but decidable, axiomatization [39].

The model proposed by Reppy and Riecke [35, 36]
is record-based and single dispatch, and is powerful
enough to type a method like move, but not to type
a multi-method like sub. Moreover, their model lacks
parameterized classes. In contrast with our hypothesis
that data type constructors be minimal, the technique
used by Reppy and Riecke to implement methods like
move that return a new object with exactly the type
selfty of the receiver is to pass the constructor new of
the receiver as an argument.

Mitchell and Jategaonkar [22] propose to extend ML
pattern matching with flexible records and primitive
subtyping, in order to allow some form of object-oriented programming. Their system only has built-in operations with constrained types like that of method sub.
However, they informally show how to accommodate a
user-defined class hierarchy of points with methods like
move : 8 t ` point: t ! t with a unique implementation
defined in the root class.

Finally, we want to mention that a type checker for
ML^ has been implemented in Objective Caml. This
prototype type checks approximately 400 lines per second on a low-cost workstation. A system derived from
ML^ will be used in a forthcoming version of the hardware description language 2z developed in collaboration
with G'erard Berry and Jean Vuillemin [40].

References

[1] M. Abadi, L. Cardelli, B. Pierce, G. Plotkin. Dynamic Typing in a Statically-Typed Language. ACM Transactions on

13

Programming Languages and Systems, 13(2) (1991) 237-268
[2] M. Abadi, L. Cardelli. A Theory of Primitive Objects:

Second-Order Systems. Proc. of the European Symposium
on Programming, Springer-Verlag (1994) 1-25

[3] A. Aiken, E. Wimmers. Type Inclusion Constraints and

Type Inference. Proceedings FPCA'93 (1993) 31-41

[4] F. Bourdoncle, S. Merz. On the integration of functional programming, class-based object-oriented programming, and multi-methods. Technical Report 26, Centre des
Math'ematiques Appliqu'ees, 'Ecole des Mines de Paris (1996)
http://www.ensmp.fr/~bourdonc/

[5] F. Bourdoncle, S. Merz. Primitive subtyping ^ implicitpolymorphism j= object-orientation. Third International
Workshop on Foundations of Object-Oriented Languages
(1996) http://www4.informatik.tu-muenchen.de/~merz/

[6] K. B. Bruce, A. Schuett, R. van Gent. PolyTOIL: a type-safe

polymorphic object-oriented language (extended abstract).
Proc. of ECOOP'95, LNCS 952 (1995) 27-51

[7] K. B. Bruce, L. Cardelli, G. Castagna, The Hopkins Object

Group, G. T. Leavens, B. C. Pierce. On binary methods.
Technical report LIENS-95-14 (1995)

[8] G. Castagna, G. Ghelli, G. Longo. A calculus for overloaded

functions with subtyping. Information and Computation,
117(2) (1995) 115-135

[9] G. Castagna, B. C. Pierce. Corrigendum: Decidable Bounded Quantification. Proc. of the 22nd Symp. on Principles of
Programming Languages (1995) 408-408

[10] C. Chambers, G. Leavens. Typechecking and Modules for

Multi-Methods. Technical Report UW-CS TR 95-08-05,
University of Washington (1995)

[11] P. L. Curien, G. Ghelli. Coherence of subsumption, minimum typing and the type checking of F^. Mathematical
Structures in Computer Science 2(1) (1992)

[12] L. G. DeMichiel, R. P. Gabriel. Common lisp object system

overview. ECOOP'87, LNCS 276 (1987) 151-170

[13] D. Duggan, J. Ophel. Kinded Parametric Overloading.

Technical Report CS-94-35, University of Waterloo (1994)

[14] D. Duggan. Polymorphic Methods With Self Types for MLlike Languages. Technical Report CS-95-03, University of
Waterloo (1995)

[15] D. Duggan, J. Ophel. Multi-Parameter Parametric Overloading. Technical report, University of Waterloo (1995)
(submitted to publication)

[16] J. Eifrig, S. Smith, V. Trifonov. Sound Polymorphic Type

Inference for Objects. Proc. of OOPSLA'95 (1995) 169-184

[17] Y.-C. Fuh, P. Mishra. Type inference with Subtypes. 2nd

European Symp. on Programming, LNCS 300 (1988) 94-
114

[18] Y.-C. Fuh, P. Mishra. Polymorphic Subtype Inference: Closing the Theory-Practice Gap. TAPSOFT'89, LNCS 352
(1988) 167-183

[19] K. Hammond, editor. Report on the Programming Language Haskell, version 1.3 (1995)

[20] R. Harper, J. Mitchell. On the Type Structure of Standard

ML. TOPLAS 15(2) (1993) 211-252

[21] R. Hindley. The principal type-scheme of an object in combinatory logic. Trans. Amer. Math. Soc., 146 (1969) 29-60

[22] L. Jategaonkar, J. C. Mitchell. Type Inference with extended pattern matching and subtypes. Fundamenta Informaticae. 19 (1, 2) (1993) 127-166

[23] M. P. Jones. A system of constructor classes: overloading

and implicit higher-order polymorphism. FPCA'93 (1993)

[24] S. Kaes. Parametric Polymorphism. Proc. of 2nd European

Symp. on Programming, LNCS 300 (1988)

[25] S. Kaes. Type inference in the presence of overloading, subtyping and recursive types. Proc. of Conf. on Lisp and Functional Programming (1992) 193-204

[26] X. Leroy, M. Mauny. Dynamics in ML. Journal of Functional

Programming, 3(4) (1993) 109-122

[27] P. Lincoln, J. C. Mitchell, Algorithmic Aspects of Type Inference with Subtypes. Proc. of the 19th ACM Symp. on
Principles of Programming Languages (1991) 293-304.

[28] R. Milner. A theory of type polymorphism in programming.

Journal of Computer and System Sciences, vol. 17 (1978)
348-375

[29] J. C. Mitchell. Coercion and Type Inference (Summary).

Proc. of the 11th ACM Symp. on Principles of Programming
Languages (1984) 175-185

[30] J. C. Mitchell. Type inference with simple subtypes. Journal

of Functional Programming, 1(3) (1991) 245-285

[31] M. Odersky, P. Wadler, M. Wehr. A second look at overloading. Proc. of the 7th Conf. on Functional Programming
and Computer Architecture (1995) 135-146

[32] J. Palsberg. Efficient inference of object types. Proc. IEEE

Symp. Logic in Computer Science (1994) 186-195

[33] B. C. Pierce, D. N. Turner. Simple type-theoretic foundations for object-oriented programming. Journal of Functional Programming 4 (2) (1994) 207-247

[34] V. Pratt, J. Tiuryn. Satisfiability of Inequalities in a Poset.

Technical Report 95-15(215), Institute of Informatics, Warsaw University (1995)

[35] J. Reppy, J. Riecke. Simple objects for Standard ML. Proc.

of the 1996 SIGPLAN Conference on Programming Languages Design and Implementation (1996) 171-180

[36] J. Reppy, J. Riecke. Classes in Object ML via Modules. Presented at the Third International Workshop
on Foundations of Object-Oriented Languages (1996)
http://www.cs.williams.edu/~kim/FOOL/

[37] J. Tiuryn. Subtype Inequalities. Proceedings of the Seventh

Symposium on Logic in Computer Science (1992) 308-315

[38] J. Tiuryn, M. Wand, Type Reconstruction with Recursive

Types and Atomic Subtyping. 18th Colloquium on Trees in
Algebra and Programming (1993)

[39] V. Trifonov, S. Smith. Subtyping Constrained Types. Third

International Static Analysis Symposium. Lecture Notes in
Computer Science 1145 (1996) 349-365

[40] J. Vuillemin. On circuits and numbers. IEEE Trans. on

Computers, 43:8 (1994) 868-879

[41] P. Wadler, S. Blott. How to make ad-hoc polymorphism

less ad-hoc. Proc. of the 16th ACM Symp. on Principles of
Programming Languages (1989) 60-76

14