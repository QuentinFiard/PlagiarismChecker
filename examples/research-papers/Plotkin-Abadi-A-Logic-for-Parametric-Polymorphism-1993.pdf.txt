

A Logic for Parametric Polymorphism

Gordon Plotkin

\Lambda 

Mart'in Abadi

y

Abstract
In this paper we introduce a logic for parametric polymorphism. Just as LCF is a
logic for the simply-typed *-calculus with recursion and arithmetic, our logic is a logic for
System F. The logic permits the formal presentation and use of relational parametricity.
Parametricity yields--for example--encodings of initial algebras, final co-algebras and
abstract datatypes, with corresponding proof principles of induction, co-induction and
simulation.

1 Introduction
In this paper we introduce a logic for parametric polymorphism, in the binary relational
sense of Reynolds [Rey83]. Just as LCF is a first-order logic for the simply-typed *-calculus,
with recursion and arithmetic, so our logic is a second-order logic for System F. It is intended
as a step towards a general logic of polymorphically typed programs. The terms are those
of the second-order *-calculus, and the formulae are built from equations and relations by
propositional operators and quantifiers over elements of types, or over types, or over relations
between types. The logic permits the formal presentation and use of relational parametricity,
which is expressed by an axiom schema. Parametricity yields--for example--encodings of
initial algebras, final co-algebras and abstract datatypes, with corresponding proof principles
of induction, co-induction and simulation.

Our first goal is to provide a formal system for arguments that exploit relational parametricity. In all models of System F, standard constructions such as products and initial
algebras are available in a weak sense (see e.g. [B"oh85, Has90, RP90, Wra89]). If the
models are relationally parametric, then these constructions become universal constructions
in the usual sense of category theory. Bainbridge, Freyd, Scedrov, and Scott have given
such results for the parametric Per model [BFSS90], and Hasegawa and Wadler for classes
of models [Has90, Wad89]. Hasegawa [Has91] has shown that the second order minimal
model--arising from the maximal consistent theory of Moggi and Statman--is parametric.
By defining a formal logic, we hope to display the assumption of relational parametricity in
a clear way, and to be able to obtain simple, general arguments for the results.

Our second goal is to pursue the idea of LCF. In LCF, a logic is given over a simplytyped *-calculus with recursion and arithmetic. This *-calculus is suitable for denotational
semantics, and thus the corresponding logic acts as a rather powerful logic of programs.
However, the simply-typed *-calculus is inadequate for dealing with programming languages
with abstract or polymorphic types, and an extension of the kind considered here is needed.
The present work is but an intermediate step: it does not include recursion, at either

\Lambda 

Department of Computer Science, University of Edinburgh, King's Buildings, Edinburgh EH9 3JZ, UK.

Part of this work was completed while at Digital Equipment Corporation, Systems Research Center.

y

Digital Equipment Corporation, Systems Research Center. 130 Lytton Avenue, Palo Alto, California

94301, USA.

the level of values or the level of types. Moreover, one may also wish to consider richer
type systems (e.g., that of F

!

or even Constructions), richer logics (e.g., that of Topos

Theory), or more general notions of computation (e.g., as in Moggi's suggestions for the use
of monads). In yet another direction, we may consider a formal theory of subtypes, based,
say, on F

^

[CG91, CG92].

There has been some work along related lines. Abadi, Cardelli, and Curien gave a system
with very elementary judgments and few relations, and with a syntax as close as possible
to the basic typed *-calculus [ACC93]. Mairson used second-order logic over the untyped
*-calculus [Mai91]. He interpreted the types of System F as relations; as it happens his
interpretation of polymorphic types is not parametric, but it could easily be made so. The
second-order theory of subtypes of Cardelli, Martini, Mitchell and Scedrov embodies some
aspects of parametricity via an equational rule [CMMS91].

In Section 2 of this paper we present the logic. Apart from axioms giving the equational
theory of System F, the only non-logical principle is a schema for parametricity; further, only
intuitionistic reasoning is employed. Other axioms may well be possible: one would expect
that intuitionistic reasoning is (unsurprisingly) consistent with various choice principles. The
availability of these principles would be a miniature form of Pitts' result that polymorphism
can be considered as set-theoretic as long as one works constructively [Pit87]. A model can be
provided as in [BFSS90]; it remains to consider a more abstract notion and other examples.
We also compare other notions of polymorphism: we present a tentative formalisation of
Strachey's idea; we consider the dinatural approach of Bainbridge et al; and, finally, we
make the evident generalisation of Reynold's binary relations to relations of other degrees.
We conjecture that if two terms of System F are equal in all models parametric in Strachey's
sense then they are also equal in all models parametric in Reynold's sense. We prove that a
schema expressing dinaturality is a consequence of the schema expressing binary relational
parametricity. The relationship betweeen the various notions of relational parametricity is
unknown.

In Section 3 we consider a variety of constructions showing the availability of finite
products and sums, second-order existential types, initial algebras and final co-algebras.
The constructions are by now standard; the main point here is that we can derive their
properties within our logic. We also consider the logical properties of the constructions. For
example, we give a general induction principle for initial algebras and a general bisimulation
(or co-induction) principle for final co-algebras [AM89, Smy91, Pit92]. For second-order
existential types, parametricity becomes a "simulation principle", namely that if there is
a relation between two types respected by the two corresponding "implementations" then
the corresponding elements of the existential type (the abstract types) are equal. Thus we
also obtain a proof rule for abstract types, along the lines envisaged by Mitchell [Mit91].
Presumably one would obtain similar principles relative to relational parametricity of other
degrees, and, again, it would be interesting to know the relationships between these. In
both Sections 2 and 3, we generally omit proofs.

2 Basic Logic
In this section we present the basic logic. The types and terms are those of System F and
they are given by the grammar:

Types: A ::= X j A ! B j 8X: A
Terms: t ::= x j *x : A: t j u(t) j \Lambda X: t j t(A)

Here X ranges over type variables, x over ordinary variables; we use notations such as
A[X] to indicate possible occurrences of variables in expressions, and then may write for

example A[B] to represent the result of substituting B for X in A (avoiding capture of
bound variables).

Using these terms we build up formulae from equations and binary relations.

Formulae: OE ::= (t =

A

u) j R(t; u) j

OE oe  j 8x : A: OE j 8X: OE j 8RaeA \Theta  B: OE j
?j OE ^  j OE .  j 9x : A: OE j 9X: OE j 9RaeA \Theta  B: OE

Here R ranges over relation variables. The equality symbol is subscripted with a type, the
type of the terms being equated. In System F, this type is unique, in a given environment,
and so we often leave it implicit. The basic constructs are implication (oe) and three sorts
of universal quantifiers: over values; over types; and over relations between types (where
RaeA\Theta B is read as "R is a relation between A and B"). The other constructs are useful but
not altogether necessary. We make use of standard abbreviations when writing formulae,
terms and types.

Typing judgments are used to specify which terms have which types, and which formulae
are well-formed. A second-order environment E is a finite sequence of type variables X or
typings x : A in which no variable is introduced twice. The judgments E ` A Type and
E ` t : A are defined in the usual way. To specify the well-formed formulae, we also need
relation environments, which are finite sequences of relational typings RaeA \Theta  B in which
no variable is introduced twice. We define a judgment E ` G REnv to assert that G is a
well-formed relation environment given E, with the obvious rule that if RaeA \Theta  B appears in
G then A and B should be well-formed types given E. We define a judgment E; G ` OE Prop
to assert that OE is a well-formed formula given E; G. The rules for atomic formulae are:

E ` t : A E ` u : A E ` G REnv

E; G ` t =

A

u Prop

E ` t : A E ` u : B E ` G REnv RaeA \Theta  B in G

E; G ` R(t; u) Prop

Among the other rules we have, for example:

E; X; G ` OE Prop
E; G ` 8X: OE Prop

E; G; RaeA \Theta  B ` OE Prop
E; G ` 8RaeA \Theta  B: OE Prop

In order to define the consequence relation of the logic we need further logical apparatus. This concerns definable relations, their substitution for relation variables in formulae
(obtaining formulae) and for type variables in types (obtaining definable relations). Substitution in formulae is needed for the rules for relational quantification; substitution in types
is needed to state the parametricity schema. Definable relations are given by the grammar:

Definable relations: ae ::= (x : A; y : B): OE[x; y]
We say that such a ae is a definable relation between A and B, writing this as ae ae A \Theta  B.
We define a judgment E; G ` ae ae A \Theta  B to assert that ae is a well-formed definable relation
between A and B, given E; G. There is one rule for this judgment:

E; G; x : A; y : B ` OE Prop
E; G ` (x : A; y : B): OE ae A \Theta  B

For example, the expression (x : A; y : A): (x =

A

y) defines the equality relation eq

A

on

A, and hf i = (x : A; y : B): (y =

B

f (x)) defines the graph of a function f ; here if f

has type A ! B then hf i is a well-formed definable relation between A and B (given

appropriate E; G). We sometimes treat a relation variable R ae A \Theta  B as the definable
relation (y : A; z : B): R(y; z).

When ae is such a definable relation between A and B, we sometimes use the abbreviations
taeu or ae(t; u) for the corresponding OE[t; u]. A definable relation ae can be substituted for a
relation variable R in a formula [R], yielding [ae]. In particular when [R] is R(t; u), the
result of the substitution is ae(t; u).

To define the substitution of definable relations for type variables in types, we need first
to be able to combine relations by exponentiation and universal quantification. If ae ae A \Theta  B
and ae

0

ae A

0

\Theta  B

0

then

(ae ! ae

0

) ae (A ! A

0

) \Theta  (B ! B

0

)

is defined by:

f (ae ! ae

0

)g j 8x : A8x

0

: A

0

: (xaex

0

oe f (x)ae

0

g(x

0

))

If ae and ae

0

are well-formed given E; G then so is ae ! ae

0

.

For universal quantification, if ae ae A \Theta  B, then

8(Y; Z; RaeY \Theta  Z)ae ae (8Y: A) \Theta  (8Z: B)
is defined by:

y(8(Y; Z; RaeY \Theta  Z): ae)z j 8Y 8Z8RaeY \Theta  Z: ((yY )ae(zZ))
If ae is well-formed given E; Y; Z; G; (RaeY \Theta  Z) then 8(Y; Z; RaeY \Theta  Z)ae is well-formed given
E; G.

We can now define the substitution of definable relations for type variables in types. If
~
X = X

1

; : : :; X

n

,

~
B = B

1

; : : : ; B

n

,

~
C = C

1

; : : : ; C

n

, and ~ae = ae

1

; : : : ; ae

n

where ae

i

ae B

i

\Theta  C

i

,

then A[~ae] ae A[

~
B] \Theta  A[

~
C] is the result of substituting ~ae for

~
X in A[

~
X]. The definition of

A[~ae] is by cases:

ffl if A is X

i

then A[~ae] is ae

i

;

ffl if A is A

0

! A

00

then A[~ae] = A

0

[~ae] ! A

00

[~ae];

ffl if A is 8Y: A

0

[

~
X; Y ] then A[~ae] = 8(Y; Z; RaeY \Theta  Z): A

0

[~ae; R].

If each ae

i

is well-formed given E; G then so is A[~ae].

It remains to give axiom schemes and rules in order to define the consequence relation
of the logic. This relation is written as \Gamma  `

E;G

OE, where \Gamma  is a finite set of formulae, and all

formulae involved are well-formed given E; G. The proof system has three parts:

ffl standard rules for the connectives and quantifiers;
ffl axioms and rules for the equational part of System F;
ffl a schema to express relational parametricity.
Natural deduction rules for the connectives and quantifiers are given as usual for intuitionistic logic. For example the rules for implication and universal quantification over types and
relations are:

\Gamma ; OE `

E;G



\Gamma  `

E;G

OE oe 

\Gamma  `

E;G

OE oe  \Gamma  `

E;G

OE

\Gamma  `

E;G



\Gamma  `

E;X;G

OE[X]

\Gamma  `

E;G

8X: OE[X]

\Gamma  `

E;G

8X: OE[X] E ` A Type

\Gamma  `

E;G

OE[A]

\Gamma  `

E;G;RaeA\Theta B

OE[R]

\Gamma  `

E;G

8RaeA \Theta  B: OE[R]

\Gamma  `

E;G

8RaeA \Theta  B: OE[R] E; G ` ae ae A \Theta  B

\Gamma  `

E;G

OE[ae]

In the above rules the usual provisions are made that the variables being bound do not
appear in assumptions.

We now give that part of the logic that deals with equality. This consists of certain
axioms and axioma schemes. We adopt the convention that if an axiom OE is written, what
is meant is that all sequents of the form \Gamma  `

E;G

OE are asserted, where OE and all formulae in

\Gamma  are well-formed for some E; G. Reflexivity is the axiom

8X8x : X: (x =

X

x)

Substitution is the axiom

8X8Y 8RaeX \Theta  Y 8x : X8x

0

: X8y : Y 8y

0

: Y:

R(x; y) ^ x =

X

x

0

^ y =

Y

y

0

oe R(x

0

; y

0

)

We also use the congruence schemas

(8x : A: t =

B

u) oe (*x : A: t) =

A!B

(*x : A: u)

(8X: t =

B

u) oe (\Lambda X: t) =

8X: B

(\Lambda X: u)

Lastly there are fi equalities:

8x : A: ((*x : A: t)x =

B

t)

8X: ((\Lambda X: t)X =

B

t)

and j equalities:

8X8Y 8f : X ! Y: ((*x : X: f x) =

X!Y

f )

8f : 8X: B: ((\Lambda X: f X) =

8X: B

f )

We can now formulate the parametricity schema:

8Y

1

: : : 8Y

n

8u : (8X: A[X; Y

1

; : : : ; Y

n

]): u(8X: A[X; eq

Y

1

; : : : ; eq

Y

n

])u

where A has free type variables X; Y

1

; : : : ; Y

n

.

To understand this, it is convenient to ignore the parameters, Y

1

; : : :; Y

n

, and expand

the definition to obtain

8u : (8X: A[X]): 8Y 8Z8RaeY \Theta  Z: u(Y )A[R]u(Z)
This formula states that if one instantiates an element of a polymorphic type at two related types, then the two values obtained are themselves related; this statement expresses
Reynolds' idea of binary relational parametricity.

One way to interpret this logic is to follow Bainbridge et al. [BFSS90], taking types
to be pers over the natural numbers and with universal quantification being interpreted
parametrically with respect to the double-negation-closed relations. Formulae are interpreted classically, with type variables ranging over pers, ordinary variables ranging over
equivalence classes relative to the appropriate per, and relation variables ranging over the
double-negation closed relations. There are other evident possibilities of interpretation; for
example one could interpret the logic intutionistically via a realisability interpretation. It
would be good to have a general framework for interpreting the logic. Both Reynolds and
Ma [MR92] and Hasegawa [Has90, Has91] have considered frameworks for parametric interpretations of System F. Pitts has shown that every hyperdoctrine model of System F fully

embeds in a topos model [Pit87]. In this way the types of the model appear as "sets" in
the topos. Perhaps something similar can be done here, in such a way that the relations
of the model appear as relations in the topos, in the usual categorical sense. One would
hope for completeness results for the present logic. In this connection one can ask too
what is the most convenient language combining that of the present logic and the higherorder logic afforded by a topos; this question is apposite even without any consideration of
parametricity.

Lemma 1 (Identity Extension Lemma) For any A[

~
X] with free variables in

~
X it is

provable in the logic that

8

~
X8u : A; v : A: (uA[eq

~
X

]v j (u =

A

v))

Lemma 2 (Logical Relations Lemma) Let A

1

[

~
X], : : : , A

m

[

~
X], B[

~
X] have free type

variables in

~
X. Suppose t[x

1

; : : :; x

m

] : B given the environment

~
X; x

1

: A

1

; : : : ; x

m

: A

m

.

Then the following is provable in the logic without using the parametricity schema:

8

~
X8

~
Y 8

~
Rae

~
X \Theta 

~
Y

8x

1

: A

1

[

~
X]; : : :; x

m

: A

m

[

~
X]

8y

1

: A

1

[

~
Y ]; : : : ; y

m

: A

m

[

~
Y ]:

(x

1

A

1

[

~
R]y

1

^ : : : ^ x

m

A

m

[

~
R]y

m

) oe t[x

1

; : : :; x

m

] A[

~
R] t[y

1

; : : : ; y

m

]

2.1 Categorical Matters
The types form a category, in a formal sense, within our logic. The idea is to take the type
X ! X

0

as the "set" of morphisms from X to X

0

. Composition is given by the combinator

comp : 8X8X

0

8X

00

:(X

0

! X

00

) ! (X ! X

0

) ! (X ! X

00

), where:

comp = \Lambda X\Lambda X

0

\Lambda X

00

*g : X

0

! X

00

*f : X ! X

0

*x : X: g(f (x))

and the identity, id : 8X: (X ! X) by:

id = \Lambda X*x : X: x
We write t; u for comp(A)(A

0

)(A

00

)(u)(t) (where u and t have respective types A

0

! A

00

and

A ! A

0

, given E; G); we write id

A

for id(A). One can show that composition is associative,

in that it is provable in the logic (without using the parametricity schema) that:

8X; X

0

; X

00

; X

000

:8f : X ! X

0

; g : X

0

! X

00

; h : X

00

! X

000

: (f ; g); h = f ; (g; h)

and for the identity that:

8X; X

0

:8f : X ! X

0

: (id

X

; f = f ) ^ (f ; id

X

0

= f )

Now let A[

~
X;

~
Y ] be a type such that all type variables in

~
X have only negative occurrences, and all type variables in

~
Y have only positive occurrences. Then one may think of

A[

~
X;

~
Y ] as acting on types

~
X;

~
Y to produce a type. With an additional action on functions

one obtains an associated multivariant formal functor. This action is given by a term:

M

A

: 8

~
X;

~
Y : 8

~
X

0

;

~
Y

0

: (

~
X

0

!

~
X) ! (

~
Y !

~
Y

0

) ! (A[

~
X;

~
Y ] ! A[

~
X

0

;

~
Y

0

])

The term is given inductively on the structure of A.

M

Z

~
X

~
Y

~
X

0 ~

Y

0 ~

f~g =

8
?
!

?
:

f

i

(if Z is the ith entry in

~
X)

g

j

(if Z is the jth entry in

~
Y )

id

Z

(otherwise)

M

(B[

~
Y ;

~
X]!C[

~
X;

~
Y ])

~
X

~
Y

~
X

0 ~

Y

0 ~

f~g = *h : B[

~
Y ;

~
X] ! C[

~
X;

~
Y ]:

(M

B[

~
Y ;

~
X]

~
Y

0 ~

X

0

~

Y

~
X~g

~
f ); h; (M

C[

~
X;

~
Y ]

~
X

~
Y

~
X

0 ~

Y

0 ~

f~g)

M

8Z: B[

~
X;

~
Y ]

~
X

~
Y

~
X

0

~

Y

0

~

f~g = *z : (8Z: B[

~
X;

~
Y ])\Lambda Z: (B[

~
X;

~
Y ]

~
X

~
Y

~
X

0

~

Y

0

~

f~g(zZ))

Given

~

t,~u of types

~
B

0

!

~
B,

~
C !

~
C

0

, we write A[

~

t; ~u] for M

A

~
A

~
B

~
A

0 ~

B

0

~

t~u. One can show

that this yields a functor. That is, it is provable in the logic (without using the parametricity
schema) that:

8

~
X;

~
Y : (A[id

~
X

; id

~
Y

] = id

A[

~
X;

~
Y ]

)

and also:

8

~
X;

~
Y ;

~
X

0

;

~
Y

0

;

~
X

00

;

~
Y

00

: 8

~
f :

~
X

0

!

~
X: 8~g :

~
Y !

~
Y

0

: 8

~
f

0

:

~
X

00

!

~
X

0

: 8

~
g

0

:

~
Y

0

!

~
Y

00

:

(A[(

~
f

0

;

~
f); (~g;

~
g

0

)] = A[

~
f ; ~g]; A[

~
f

0

;

~
g

0

])

One can also show that the operations of applying functors and taking graphs commute.
The opposite of a relation ae ae A \Theta  B is defined by:

ae

op

= (y : B; x : A):xaey

Lemma 3 (Graph Lemma) Let A[

~
X;

~
Y ] be a type all of whose free variables appear in

the list

~
X;

~
Y and such that all type variables in

~
X have only negative occurrences, and all

type variables in

~
Y have only positive occurrences. Then it can be proved in the logic that:

8

~
X;

~
Y ;

~
X

0

;

~
Y

0

: 8

~
f :

~
X

0

!

~
X: 8~g :

~
Y !

~
Y

0

: (hA[

~
f; ~g]i = A[h

~
fi

op

; h~gi])

Here two relations are considered as equal if they coincide extensionally.

2.2 Other Notions of Parametricity
As well as Reynold's relational notion of parametricity, there are two others: an informal one
due to Strachey [Str67] and a categorical one due to Bainbridge et al. [BFSS90]. Strachey's
original idea was that a parametric polymorphic function behaves the same way for all types.
Let us essay a formalisation of this idea. In Per models, universal types can be modelled
as intersections of all their instances; so at any type a polymorphic function has the same
realisor as at any other. It seems reasonable, therefore, to claim that Strachey could accept
any Per model as being parametric. Now Mitchell has shown that two terms of the same
type are equal in a wide class of such models iff their erasures are fij-equivalent [Mit90].
Let us (informally) define two terms of System F to be Strachey equivalent iff they are equal
in all models of parametric polymorphism in Strachey's sense. Accepting Per models as
parametric, we are lead to assert that Strachey equivalence implies being of the same type
and having the same erasure. Conversely if two terms have the same type and erasure it
seems not unreasonable that they would denote the same element of any model parametric
in Strachey's sense. We therefore tentatively identify Strachey equivalence with having the
same type and the same erasure (up to fij-equivalence).

Along similar lines, one would informally define two terms of System F to be Reynold's
equivalent iff they are equal in all models of binary relational polymorphism in Reynold's

sense. Anticipating a completeness theorem for our logic relative to models of System F
which are polymorphic in the binary relational sense, we can identify Reynold's equivalence
with provable equality in our logic. Since there are many examples of terms provably
equal in the above theory which are not Strachey equivalent, Reynolds equivalence does not
imply Strachey equivalence. We conjecture the converse does hold, (A similar conjecture
appears in [ACC93].) Many positive instances encourage this conjecture. For example,
*x : (8X: X): x and *x : (8X: X): x(8X: X) have the same erasure and the same type
(8X: X) ! (8X: X), and they are provably equal; if X is not free in A then *x : (8X: A): xB
and *x : (8X: A): xC have the same erasure and the same type (8X: A) ! A, and they too
are provably equal.

According to Bainbridge et al. parametricity is provided by the notion of a dinatural
transformation: in certain models, all terms denote such transformations between types
[BFSS90]. One can express dinaturality by a schema. Let A[Y; X] be a type in which Y
occurs only negatively and X occurs only positively. Then:

8X; Y 8t : (8X:A[X; X] ! A[Y; Y )])8f : X ! Y:

A[f; id

X

]; t(X); B[id

X

; f ] = A[id

Y

; f ]; t(Y ); B[f; id

Y

]

We show now that this schema follows from that for (relational) parametricity. (This seems
to answer a question raised in [BFSS90].)

First, the schema can be recast in a simpler way, as:

8X; Y 8f : X ! Y: (\Delta )

X

; A[id

X

; f ] = (\Delta )

Y

; A[f; id

Y

]

where (again) A[Y; X] is a type in which Y occurs only negatively and X occurs only
positively and where, e.g., (\Delta )

X

is *u : (8X: A[X; X]): u(X). For the sake of notational

simplicity let us only consider the case where there are no parameters (i.e. free type variables
in A other than X or Y ). So let X and Y be types and suppose that f : X ! Y . Choose u
in (8X: A[X; X]). Appying the parametricity schema to hf i we obtain:

u(X)A[hf i; hf i]u(Y )
We have that A[h; g] : A[V; U ] ! A[V

0

; U

0

] given the U; V; U

0

; V

0

; g : U ! U

0

; h : V

0

! V .

We may therefore apply the Logical Relations Lemma, obtaining:

A[id

X

; f ](A[hf i; hf i] ! A[eq

X

; eq

Y

])A[f; id

Y

]

as f (hf i ! eq

Y

)id

Y

and id

X

(eq

X

! hf i)f . But now it follows that:

A[id

X

; f ](u(X))A[eq

X

; eq

Y

]A[f; id

Y

](u(Y ))

and by the Identity Extension Lemma this is just:

A[id

X

; f ](u(X)) =

A[X;Y ]

A[f; id

Y

](u(Y ))

as required.

There is an evident generalisation of relational parametricity to n-ary relational parametricity. One introduces n-ary definable relations (n * 0) by:

ae = (x

1

: A

1

; : : : ; x

n

: A

n

):OE[x

1

; : : : ; x

n

]

We write ae ae (A

1

\Theta : : :\Theta A

n

), and say ae is well-formed given E; G provided that OE[x

1

; : : : ; x

n

]

is well-formed given E; x

1

: A

1

; : : : ; x

n

: A

n

; G. We also write ae(t

1

; : : : ; t

n

) for OE[t

1

; : : : ; t

n

].

The place of the equality relation is taken by the diagonal \Delta 

n

A

where:

\Delta 

n

A

= (x

1

: A; : : : ; x

n

: A): (x

1

= x

2

) ^ : : : ^ (x

n\Gamma 1

= x

n

)

Exponentiation and universal quantification of n-ary relations is defined analogously to the
case of binary relations, and we may substitute definable n-ary relations in types to obtain
definable n-ary relations. The schema of n-ary relational parametricity is:

8Y

1

: : : 8Y

m

8u : (8X: A[X; Y

1

; : : : ; Y

m

]): (8X: A[X; \Delta 

n

Y

1

; : : : ; \Delta 

n

Y

m

])(u; : : :; u)

where A has free type variables X; Y

1

; : : : ; Y

n

. It is unknown what the relations between

these schemas are. We do not even know if the schema for binary relational parametricity
implies that for unary parametricity.

3 Parametricity and Datatypes
We now treat datatype constructors, comprising: finite products and sums, second-order
existential quantification; and initial algebras and final co-algebras. As well as categorical
properties, we derive logical properties of the constructs.

3.1 Products
For the empty product, let us define:

1 = 8X: X ! X
The term ? = \Lambda X*x : X: x inhabits 1. It is provable, using dinaturality, that:
Theorem 1 8u : 1: (u =

1

?)

Note that we have adopted an informal style, asserting formulae. What we intend is to
assert that the formulae are provable in the logic. The categorical statement

8X9!f : X ! 1: ?
of terminality follows at once from the theorem.

Turning to binary products, for any types A and B, set

A \Theta  B = 8Z: ((A ! B ! Z) ! Z)
where Z does not appear in A or B. This yields a weak product in System F, with combinators fst

A;B

: A \Theta  B ! A, snd

A;B

: A \Theta  B ! B, and pair

A;B

: A ! B ! A \Theta  B, given

by

fst

A;B

(z) = zAK

A;B

snd

A;B

(z) = zBK

0

A;B

(where K

A;B

= *x : A*y : B: x and K

0

A;B

= *x : A*y : B: y),and:

pair

A;B

(a)(b) = \Lambda Z*f : A ! B ! Z: f ab

Below we drop the subscripts A; B and also write ht; ui for pair (t)(u).

The formulae

8x : A8y : B: (fst(hx; yi) = x)

and

8x : A8y : B: (snd(hx; yi) = y)

are provable without using parametricity. Using dinaturality we obtain:

Theorem 2 8w : A \Theta  B: (hfst(w); snd(w)i =

A\Theta B

w)

The theorem yields the usual categorical characterization of binary products, namely:

8Z8f : Z ! A8g : Z ! B: 9!h : Z ! A \Theta  B: (f = h; fst ^ g = h; snd)
Lastly we consider the action of binary products on relations. Given ae ae A \Theta  A

0

and

oe ae B \Theta  B

0

we take (ae \Theta  oe) ae (A \Theta  B) \Theta  (A

0

\Theta  B

0

) to be 8Z: (ae ! (oe ! Z)) ! Z. This is

obtained by substituting ae and oe for X and Y in X \Theta  Y , which is 8Z: (X ! (Y ! Z)) ! Z.

Theorem 3

8u : A \Theta  A

0

8v : B \Theta  B

0

: u(ae \Theta  oe)v j (fst(u)ae fst(v) ^ snd(u)oe snd(v))

3.2 Sums
For the empty sum, define:

0 = 8X: X

Theorem 4 8u : 0: ?
It follows that 0 is initial in the categorical sense.

Turning to binary sums, for types A and B we take

A + B = 8Z: ((A ! Z) ! (B ! Z) ! Z)
where Z does not occur in A or B. The combinators inl

A;B

: A ! A+B, inr

A;B

: B ! A+B,

and cases

A;B

: 8Z: ((A ! Z) ! (B ! Z) ! (A + B) ! Z) are defined by:

inl

A;B

(a) = \Lambda Z*f : A ! Z*g : B ! Z: f (a)

inr

A;B

(b) = \Lambda Z*f : A ! Z*g : B ! Z: g(b)

and

cases

A;B

Cf gu = uCf g

We may drop the subscripts and may also write [t; u]

C

for cases(t; u).

It is provable without using parametricity that

8x : A8Z8f : A ! Z8g : B ! Z: ([f; g]

Z

(inl(x)) = f (x))

and

8y : B8Z8f : A ! Z8g : B ! Z: ([f; g]

Z

(inr(y)) = g(y))

With dinaturality we obtain:
Theorem 5 8Z8h : A + B ! Z: h = [inl; h; inr; h]

Z

from which the usual categorical characterisation of binary sums follows.

Next we consider the action of binary sums on relations. Given ae ae A\Theta A

0

and oe ae B\Theta B

0

we take (ae + oe) ae (A + B) \Theta  (A

0

+ B

0

) to be 8Z: ((ae ! Z) ! (oe ! Z) ! Z), following the

same pattern as for binary products.

Theorem 6

8u : A + B8u

0

: A

0

+ B

0

:

u(ae + oe)u

0

j
(9x : A9x

0

: A

0

: (u = inl(x) ^ u

0

= inl(x

0

) ^ xaex

0

)

.
9y : B9y

0

: B

0

: (u = inr(y) ^ u

0

= inr (y

0

) ^ yoey

0

))

By the Identity Extension Lemma, eq

A

+ eq

B

and eq

A+B

are equivalent. With this and

the above theorem we get that:

8u : A + B: (9x : A: u = inl(x)) . (9y : B: u = inr (y))

3.3 Existential Quantification
The existential quantification 9X: A[X] is taken to abbreviate

8Y: (8X: (A[X] ! Y ) ! Y )
where Y does not appear in A and is different from X.

One defines the combinator pack : 8X: (A[X] ! 9X: A[X]) and the combinator unpack :
(9X: A[X]) ! 8Y: (8X: (A[X] ! Y ) ! Y ) by:

pack (X)(x) = \Lambda Y *f : 8X: (A[X] ! Y ): f (X)(x)
and

unpack (u)(Y )(f ) = u(Y )(f )

and it is provable without using parametricity that

8X8x : A[X]8Y 8f : (8X: (A[X] ! Y ): (unpack(pack Xx)Y f =

Y

f Xx)

Let us see how existential quantification operates on relations. Let

~
Z be the type variables free in A[X;

~
Z], other than X, and let ~ae ae

~
B \Theta 

~
C be a vector of relations of the same

length. Then 9X: A[X; ~ae] is taken to be 8Y: (8X: (A[X; ~ae] ! Y ) ! Y ), following the usual
pattern. Using the parametricity schema, one can show:

Theorem 7

8u : (9X: A[X;

~
B]); v : (9X: A[X;

~
C]):

u(9X: A[X; ~ae])v

j
(9X; Y 9x : A[X;

~
B]; y : A[Y;

~
C]9SaeX \Theta  Y:

u = (pack Xx) ^ v = (pack Y y) ^ x(A[S; ~ae])y)

Applying the Identity Extension Lemma, we get:

8

~
Z8u; v : (9X: A[X;

~
Z]):

u = v

j
(9X; Y 9x : A[X;

~
Z]; y : A[Y;

~
Z]9SaeX \Theta  Y:

u = (packXx) ^ v = (packY y) ^ x(A[S; eq

~
Z

])y)

The implication from right to left can be viewed as stating that existentials are parametric (in a sense dual to that axiomatized for universals); it is a principle that enables one
to show that two abstract datatypes are equal, if one can demonstrate a simulation relation
between them. We view this as the proof principle requested by Mitchell in [Mit91].

Working from left to right, one obtains:

8

~
Z8u : (9X: A[X;

~
Z])9X9x : A[X;

~
Z]:(u = (packXx))

and one can then obtain a categorical characterization of existential quantification in the
form:

8Y 8f : (8X: (A[X] ! Y ))9!g : (9X: A[X] ! Y )8X: (f X =

Y

(packX); g)

3.4 Initial Algebras
Let A[Z] be a type where the variable Z occurs only positively. The initial A[Z] algebra is
given by

_Z: A[Z] = 8Z: ((A[Z] ! Z) ! Z)

and the combinators are

fold : 8Z: ((A[Z] ! Z) ! ((_Z: A[Z]) ! Z))
and

in : A[_Z: A[Z]] ! _Z: A[Z]

where:

fold(Z)(f ) = *z : _Z: A[Z]: z(Z)(f )

and

in(z) = \Lambda Z*f : A[Z] ! Z: f (A[foldZf ]z)

.

The structure h_Z: A[Z]; ini is a weakly initial A[Z] algebra:

8Z8f : A[Z] ! Z: (in; (foldZf ) = A[foldZf ]; f )
This can be shown without using parametricity (or any j-equalities). With parametricity
one has the following expression of the initiality of h_Z: A[Z]; ini:

Theorem 8 8Z8f : A[Z] ! Z9!h : _Z: A[Z] ! Z: (in; h = A[h]; f )

Turning to logical relations let

~
X be a list of the type variables free in A[Z;

~
X] apart

from Z and let ~ae ae

~
B \Theta 

~
C be a list of relations of the same length. Then the relation

_Z: A[Z; ~ae] ae _Z: A[Z;

~
B] \Theta  _Z: A[Z;

~
C] is taken to be 8Z: ((A[Z; ~ae] ! Z) ! Z), following

the usual pattern. Using parametricity one has:

Theorem 9

8x : (_Z: A[Z;

~
B])8y : (_Z: A[Z;

~
C]):

x(_Z: A[Z; ~ae])y

j
8Rae(_Z: A[Z;

~
B]) \Theta  (_Z: A[Z;

~
C]):

(8u : A[(_Z: A[Z;

~
B]);

~
B]8v : A[(_Z: A[Z;

~
C]);

~
C]:

uA[R; ~ae]v oe in(u)R in(v))
oe
xRy

Put more informally, this theorem states that _Z: A[Z; ~ae] is the least relation R such that
in(A[R; ~ae]) ae R.

Applying the Identity Extension Lemma to this theorem we obtain the following binary
induction principle for a relation ae ae _Z: A[Z;

~
X] \Theta  _Z: A[Z;

~
X]:

8u; v : A[_Z: A[Z; eq

~

X

]; eq

~

X

]:

(uA[ae; eq

~
X

]v oe in(u)ae in(v))

oe
8x; y : _Z: A[Z;

~
X]: xaey

This amounts to saying that, if in(A[ae; eq

~
X

]) ae ae then xaey holds for all x,y in _Z: A[Z;

~
X].

It is somewhat surprising that we do not obtain the expected unary induction principle,
that, for any property (i.e. unary relation) ss, if in(A[ss; \Delta 

1

~
X

]) ae ss then ss(x) holds for all x

in _Z: A[Z;

~
X]. It would be interesting to know the relation between the two, and also with

the corresponding principles of other degrees.

3.5 Final Co-algebras
Let A[Z] be a type where the variable Z occurs only positively. The final A[Z] co-algebra
is given by

*Z: A[Z] = 9Z: ((Z ! A[Z]) \Theta  Z)

and the combinators are

unfold : 8Z: ((Z ! A[Z]) ! (Z ! (*Z: A[Z])))
and

out : *Z: A[Z] ! A[*Z: A[Z]]

where

unfold (Z)(f )(z) = pack (Z)(hf; zi)

and

out (u) = unpack (u)(A[*Z: A[Z]])

(\Lambda Z*w : ((Z ! A[Z]) \Theta  Z): A[unfold Z(fst w)]((fst w)(snd w)))

The structure h*Z: A[Z]; outi is a weakly final co-algebra:

8Z8f : Z ! A[Z]: (unfold(Z)(f ); out = f ; A[unfold(Z)(f )])
This can be shown without using parametricity (or any j-equalities). With parametricity
one obtains a characterization of h*Z: A[Z]; outi as the final A[Z] co-algebra:

Theorem 10 8Z8f : Z ! A[Z]9!h : Z ! (*Z: A[Z]): (h; out = f ; A[h])

Turning to logical relations, let

~
X be a list of the type variables free in A[Z;

~
X] apart

from Z and let ~ae ae

~
B \Theta 

~
C be a list of relations of the same length. Then the relation

*Z: A[Z; ~ae] ae *Z: A[Z;

~
B] \Theta  *Z: A[Z;

~
C] is taken to be 9Z: ((Z ! A[Z; ~ae]) \Theta  Z), following

the usual pattern.

Theorem 11

8x : (*Z: A[Z;

~
B])8y : (*Z: A[Z;

~
C]):

x(*Z: A[Z; ~ae])y

j
9Rae(*Z: A[Z;

~
B]) \Theta  (*Z: A[Z;

~
C]):

xRy ^ 8x

0

: (*Z: A[Z;

~
B])8y

0

: (*Z: A[Z;

~
C]):

x

0

Ry

0

oe out (x

0

)A[R; ~ae]out(y

0

)

Put more informally,what this theorem states is that *Z: A[Z; ~ae] is the greatest relation R
such that out (R) ae A[R; ~ae].

?From this theorem and the Identity Extension Lemma one obtains the following principle of co-induction (or bisimulation) [AM89, Smy91, Pit92]:

8x; y : (*Z: A[Z]):

(9Rae(*Z: A[Z]) \Theta  (*Z: A[Z]):

xRy ^ 8x

0

; y

0

: (*Z: A[Z]): x

0

Ry

0

oe out (x

0

)A[R; eq

~
X

]out (y

0

))

oe
x = y

To put this in perhaps more familiar terms, say that R ae (*Z: A[Z]) \Theta  (*Z: A[Z]) is a
bisimulation relation if out (R) ae A[R; eq

~

X

]. Then the principle of co-induction states that

equality is the maximal bisimulation relation. From previous work a binary principle is
expected here. There are also evident principles of other degrees. The unary principle is
logically trivial. Ternary and higher degree principles seem pointless; however we do not
know if they are equivalent to the usual binary one.

Acknowledgments
We benefited from many conversations with Luca Cardelli, Pierre-Louis Curien and John
Mitchell.

References
[ACC93] Martin Abadi, Luca Cardelli and Pierre-Louis Curien. Formal parametric polymorphism. To Appear in proceedings of Principles of Prgramming Languages
'93.

[AM89] Peter Aczel and Nax Mendler. A final co-algebra theorem. In D. H. Pitt et

al., editors, Category Theory and Computer Science Lecture Notes in Computer
Science, 389:357-365 Berlin, 1989. Springer-Verlag.

[BFSS90] E. S. Bainbridge, Peter J. Freyd, Andre Scedrov, and Philip J. Scott. Functorial

polymorphism. Theoretical Computer Science, 70(1):35-64, January 15 1990.
Corrigendum in (3) 71, 10 April 1990, p. 431.

[B"oh85] Corrado B"ohm and A. Berarducci. Automatic synthesis of typed \Lambda -programs

on term algebras. Theoretical Computer Science, 39:85-114, 1985.

[CMMS91] Luca Cardelli, Simone Martini, John Mitchell, and Andre Scedrov. An extension

of system F with subtyping. In T. Ito and A. R. Meyer, editors, Theoretical Aspects of Computer Software, volume 526 of Lecture Notes in Computer Science,
pages 750-770, Berlin, 1991. Springer-Verlag.

[CG91] Pierre-Louis Curien and Giorgio Ghelli. Subtyping + extensionality: Confluence

of fijtop reduction in F

^

. In T. Ito and A. R. Meyer, editors, Theoretical Aspects

of Computer Software, volume 526 of Lecture Notes in Computer Science, pages
731-749, Berlin, 1991. Springer-Verlag.

[CG92] Pierre-Louis Curien and Giorgio Ghelli. Coherence of subsumption, minimum

typing and type-checking in F

^

. Mathematical Structures in Computer Science,

2(1):55-92, March 1992.

[Has90] Ryu Hasegawa. Categorical data types in parametric polymorphism. Mathematical Structures in Computer Science, 1990. To appear.

[Has91] Ryu Hasegawa. Parametricity of extensionally collapsed models of polymorphism and their categorical properties. In T. Ito and A. R. Meyer, editors, Theoretical Aspects of Computer Software, volume 526 of Lecture Notes in Computer
Science, pages 495-512, Berlin, 1991. Springer-Verlag.

[MR92] QingMing Ma and John C. Reynolds. Types, abstraction, and parametric

polymorphism, part 2. In S. Brookes, M. Main, A. Melton, M. Mislove, and
D. A. Schmidt, editors, Proceedings of the 1991 Mathematical Foundations
of Programming Semantics Conference, Lecture Notes in Computer Science,
Berlin, 1992. Springer-Verlag. To appear.

[Mai91] Harry Mairson. Outline of a proof theory of parametricity. In Proc. 5th International Symp. on Functional Programming Languages and Computer Architecture, Springer-Verlag, 1991.

[MP85] John C. Mitchell and Gordon D. Plotkin. Abstract types have existential type.

In Proceedings of the Twelfth Annual ACM Symposium on Principles of Programming Languages, pages 37-51, 1985.

[Mit90] John C. Mitchell. A type inference approach to reduction properties and semantics of polymorphic expressions (summary). In G. Huet, editor, Logical Foundations of Functional Programming, pages 195-212, Reading, 1990. AddisonWesley.

[Mit91] John C. Mitchell. On the equivalence of data representations. In V. Lifshitz,

editor, Artificial Intelligence and Mathematical Theory of Computation: Papers
in Honor of John McCarthy, Academic Press, pages 305-330, 1991.

[Pit87] Andrew M. Pitts. Polymorphism is set-theoretic, constructively. In D. H. Pitt et

al., editors, Category Theory and Computer Science Lecture Notes in Computer
Science, 283:12-39 Berlin, 1987. Springer-Verlag.

[Pit92] Andrew M. Pitts. A co-induction principle for recursively defined domains. To

appear in Theoretical Computer Science.

[Rey83] John C. Reynolds. Types, abstraction and parametric polymorphism. In R. E. A.

Mason, editor, Information Processing 83, pages 513-523, Amsterdam, 1983.
Elsevier Science Publishers B. V. (North-Holland).

[RP90] John C. Reynolds and Gordon D. Plotkin. On functors expressible in the polymorphic typed lambda calculus. In G. Huet, editor, Logical Foundations of
Functional Programming, pages 127-152, Reading, 1990. Addison-Wesley.

[Smy91] Michael B. Smyth. I-categories and duality. In M. P. Fourman, P. T. Johnstone

and A. M. Pitts, Applications of Categories in Computer Science London Mathematical Society Lecture Note Series, 177:270-287, Cambridge, 1991 Cambridge
University Press.

[Str67] Christopher Strachey. Fundamental concepts in programming languages. Lecture Notes, International Summer School in Programming Languages, Copenhagen, Unpublished, August 1967.

[Wad89] Philip Wadler. Recursive types in polymorphic second-order lambda-calculus

Draft, University of Glasgow 1990.

[Wra89] Gavin C. Wraith. A note on categorical datatypes. In A. M. Pitts and A. Poign'e,

editors, Category Theory and Computer Science Lecture Notes in Computer
Science, 39:118-127, Berlin, 1989, Springer-Verlag.