

J. Symbolic Computation (1992) 11, 1-??

Unification Under a Mixed Prefix

DALE MILLER
Department of Computer Science

University of Pennsylvania
Philadelphia, PA 19107-6389 USA

(Received 8 July 1992)

Unification problems are identified with conjunctions of equations between simply typed
*-terms where free variables in the equations can be universally or existentially quantified. Two schemes for simplifying quantifier alternation, called Skolemization and raising
(a dual of Skolemization), are presented. In this setting where variables of functional type
can be quantified and not all types contain closed terms, the naive generalization of firstorder Skolemization has several technical problems that are addressed. The method of
searching for pre-unifiers described by Huet is easily extended to the mixed prefix setting,
although solving flexible-flexible unification problems is undecidable since types may be
empty. Unification problems may have numerous incomparable unifiers. Occasionally,
unifiers share common factors and several of these are presented. Various optimizations
on the general unification search problem are as discussed.

1. Introduction
Most first-order unification algorithms are designed to solve existentially quantified
sets of equations such as

9x1 : : : 9xn[t1 = s1 ^ : : : ^ tm = sm]:
That is, the free variables of the terms t1; : : : ; tm; s1; : : : ; sm are interpreted as being
existentially quantified. Of course, if higher-order types are available, constants within
the equations can be universally quantified giving a 89 quantifier prefix. In this paper
we consider the more general situation where equations must be solved under a mixed
quantifier prefix. That is, we shall consider unification problems to be of the form

Q1x1 : : : Qnxn[t1 = s1 ^ : : : ^ tm = sm];
where Q1; : : : ; Qn are universal and existential quantifiers. Furthermore, we shall allow
the terms t1; : : : ; tm; s1; : : : ; sm to be simply typed *-terms and the variables x1; : : : ; xn
to be of primitive or functional type. Equality between closed *-terms will be identified
with fij-convertibility. Such quantified conjunctions of equations are called unification
problems and solutions for them are certain restricted substitutions for the existentially
quantified variables that yield closed equations valid in the fij theory of equality.

0747-7171/90/000000 + 00 $03.00/0 cfl 1992 Academic Press Limited

2 D. Miller

Below we list several reasons for studying fij-unification of simply typed *-terms in
this way.

Constants and variables are explicitly declared by a prefix. The quantifier prefix can
be seen as a declarations of how its bound variables are to be interpreted within the
equations. In particular, a universal quantifier declares that its bound variable is to be
interpreted as a constant within its scope while an existential quantifier declares that
its bound variable is to be interpreted as available for substitution. For example, the
prefix 8x9y8z9u will be used to declare that x and z are constants while y and u are
variables within a given unification problem. If the unification problem already contained
constants, say c and d, these could be explicitly declared by adding 8c8d to the front
of the prefix. In this way, it is generally possible to assume that the logic in which
these unification problems are considered contains no nonlogical constants: constants are
introduced explicitly by a prefix when they are needed.

Empty types can be studied and used. The explicit information of a prefix makes a
convenient setting to study the effect of empty types on unification. For example, checking
for the existence of unifiers in this case can be much more complex than in the usual case
when all types are assumed to be nonempty.

Substitution terms can range over different signatures. The alternation of quantifiers
in a prefix can make distinctions between existential variables that are not captured by
type distinctions. Consider again a unification problem with prefix 8c8d8x9y8z9u. Any
substitution term for y can contain c; d; and x, while a substitution term for u may
contain these as well as z. Thus, different existentially quantified variables can receive
substitution terms built from different signatures.

The intimate relation between *-abstractions and universal quantifiers can be exploited.
An equation between abstractions, say *xt = *xs, is provable if and only if the quantified
equation 8x:t = s is provable. Thus, the study of universal quantifiers in prefixes and
the study of *-abstractions in terms can be tied together closely. This connection will be
exploited several times in this paper.

Skolemization does not provide a simple solution method. When variables of functional
type can be existentially quantified, Skolemization does not provide a simple method of
reducing the quantifier alternation in a prefix. There are basically two problems with
Skolem functions. Types that were empty prior to introducing a Skolem function can
become nonempty afterwards. Furthermore, if *-abstractions are built without restriction
from Skolem functions, solutions to a Skolemized unification problem may be difficult to
relate back to solutions of the original problem. In order to deskolemize solutions and
make Skolemization sound (without using a choice axiom), a restriction on the formation
of *-abstractions over Skolem functions must be made.

When higher types are available, Skolemization has a dual. Skolemization can be seen
as taking a constant (a universally quantified variable) in a given unification problem
and replacing it with a new constant, the Skolem function, at a higher type. In doing so,
the alternation of quantifiers can be, in some sense, simplified. There is a dual operation
to this, called raising, that takes an existentially quantified variable and replaces it with
a new existential variable of higher type in such a way that quantifier alternation is again
simplified.

Various computation systems generate unification problems with mixed prefixes. The
unification problems considered in this paper are those that arise in the Isabelle theorem
prover (Paulson, 1989), in the type inference programs described in (Pfenning, 1988),
and in interpreters for the higher-order logic programming language *Prolog (Nadathur

Unification Under a Mixed Prefix 3
& Miller, 1988). In fact many of the definitions and motivation for parts of this paper
come directly from having implemented one such interpreter. For example, since many
programs in *Prolog rely only on second-order unification, the restrictions to secondorder used in Sections 11 and 12 have practical consequences. Also in *Prolog, the socalled flexible-flexible unification problems may need to be presented as part of an answer
substitution: as a result, it is important that the form of these unification problems be
simple and intelligible. The material on improper factors in Section 11 can be used to
simplify such unification problems.

This paper is organized as follows. In Section 2, unification problems are formalized
as certain prenex normal formulas and solvable unification problems are defined as those
that are provable in a simple proof system. An equivalent notion of solvability using
substitutions for existentially bound variables is presented in Section 3. Some of the
problems surrounding the use of Skolemization in this higher-order setting are presented
and solved in Section 4. Raising is described and proved sound and complete in Section
5. Section 6 illustrates how Skolemization and raising can be used to process unification
problems prior to submitting them to unification processes that do not address quantifier
alternation. Huet's pre-unification process for simply typed *-terms (Huet, 1975) is modified to deal directly with mixed prefixes in Section 7. Pre-unification carries unification
problems into a class of flexible-flexible problems and Section 8 addresses the solvability
of these unification problems. Section 9 describes some unification problems that do not
have solutions. A generalization to most general unifiers is presented in Section 10, and
Sections 11 and 12 use that generalization on some classes of unification problems. We
conclude by describing some related work in Section 13.

2. Unification Problems
Unification problems will be formalized in a logic that is essentially a small sublogic
of Church's Simple Theory of Types (Church, 1940). Type expressions in this logic are
all the closed first-order terms defined using certain primitive types and one binary infix
function symbol !. When reading type expressions, we associate the infix operator !
to the right. We shall assume that there is at least one primitive type symbol meta
that denotes the type of unification problems and as many other primitive types as we
find useful. There are no type variables. The symbols o/ and ffi will be used as syntactic
variables ranging over type expressions.

Definition 2.1. Let o/ be the type o/1 ! \Delta  \Delta  \Delta  ! o/n ! o/0 where o/0 is primitive and n * 0.
(By convention, if n = 0 then o/ is simply the type o/0.) The types o/1; : : : ; o/n are the
argument types of o/ while the type o/0 is the target type of o/. The order of o/ is defined
as follows: If o/ is primitive then o/ has order 0; otherwise, the order of o/ is one greater
than the maximum order of the argument types of o/ .

We shall assume that there is a denumerably infinite list of variables. Constants are
only the logical constants ?, ^, o/=, 8o/ , and 9o/ , where o/ ranges over type expressions
that do not contain the primitive type meta. The type annotations on =, 8, and 9 will
occasionally be dropped when its actual value is not important or can be inferred from
context. Untyped *-terms can be built up from these variables and constants by using
*-abstraction and application. When reading *-terms, we associate applications to the
left. The notions of subterm and free and bound occurrences of variables are defined as

4 D. Miller
usual. Two *-terms are considered identical if they differ only in an alphabetic change of
bound variables. The notation [N=x]M denotes the substitution of *-term N for all free
occurrences of x in M . Of course, bound variables of M must be systematically changed
via ff-conversion to avoid variable capture. A term is in fi-normal form if it contains no
occurrence of a fi-redex, that is, a formula of the form (*xM )N . Every term t can be
associated with a unique (up to ff-conversion) fi-normal term that is fi-convertible to t.
We shall assume that the reader is familiar with the basic definitions and properties of
fij-conversion (see, for example, Chapters 1 - 7 and 13 of (Hindley & Seldin, 1986)).

In this paper we shall use several forms of equality. As mentioned above, *-terms are
equal if they are alphabetic variants. We shall use no special symbol to represent this
equality relation, choosing instead to simply write phrases such as "t is equal to s". When
the unadorned symbol = is used, it is either the logical constant

o/= with its annotation

dropped or the mathematical symbol relating objects such as sets or lists: exactly which
relation is intended should always be clear from context.

Definition 2.2. A signature is a finite set \Gamma  of pairs, written as x: o/ , where x is a
variable and o/ is a type expression, and whenever x: o/ 2 \Gamma  and x: ffi 2 \Gamma , o/ and ffi are
the same type. Signatures are used to assign types to variables. The expression \Gamma  + x: o/
denotes the set \Gamma  \Gamma  fx: ffig [ fx: o/ g if \Gamma  assigns type ffi to x, or the set \Gamma  [ fx: o/ g otherwise.

We now define a provability relation for this logic.
Definition 2.3. Let ` be a provability relation between a signature on the left and either
a term or pair t: o/ where t is a term and o/ is a type expression. The symbol `\Lambda  is an
abbreviation: \Gamma  `\Lambda  P means \Gamma  ` P : meta and \Gamma  ` P . Below are the axioms and inference
rules for `.

(o/0) \Gamma  ` ?: meta, \Gamma  ` ^: meta ! meta ! meta, \Gamma  ` o/=: o/ ! o/ ! meta, \Gamma  `

8o/ : (o/ ! meta) ! meta, and \Gamma  ` 9o/ : (o/ ! meta) ! meta.
(o/1) If x: o/ 2 \Gamma  then \Gamma  ` x: o/ .
(o/2) If \Gamma  ` M : o/ ! ffi and \Gamma  ` N : o/ then \Gamma  ` M N : ffi.
(o/3) If \Gamma  + x: o/ ` M : ffi then \Gamma  ` *x M : o/ ! ffi.

(?) \Gamma  ` ?.
(=) If \Gamma  ` M : o/ , \Gamma  ` N : o/ , and M fij-converts to N then \Gamma  ` M

o/= N .

(,) If \Gamma  + x: o/ `\Lambda  N

ffi= M then \Gamma  ` *x N o/!ffi= *x M .

(^) If \Gamma  `\Lambda  P and \Gamma  `\Lambda  Q then \Gamma  ` P ^ Q.

(9) If \Gamma  `\Lambda  [N=x]P and \Gamma  ` N : o/ then \Gamma  ` 9o/ x P .
(8) If \Gamma  + x: o/ `\Lambda  P then \Gamma  ` 8o/ x P .
A proof of P from \Gamma  is a list of pairs h\Gamma 1; P1i; : : : ; h\Gamma n; Pni where n * 1 and (i) \Gamma n is
\Gamma  and P is Pn, (ii) for all i = 1; : : : ; n, \Gamma i ` Pi is either an axiom (an instance of (o/0),
(o/1), or (?)) or results from previous pairs by an inference rule. If \Gamma  is empty, we write
` P instead of \Gamma  ` P .

The axioms and rules (o/0); (o/1); (o/2); (o/3) are those necessary to impose the simple type
discipline on *-terms. The axiom (=) is, of course, a powerful axiom, capturing all of
fij-convertibility in one rule. This rule, however, is decidable for *-terms that have simple
types (Chapter 13, (Hindley & Seldin, 1986)).

Signatures only change in the inference rules (8) and (,). In essence, a constant is discharged during these rules: this is best compared to the discharging of an assumption in

Unification Under a Mixed Prefix 5
the proof of an implication in natural deduction. Signatures are often called type assignments elsewhere. We shall prefer the former term since we think of variables occurring
to the left of ` as actually playing the role of constants with respect to unification.

It is immediate to see that the conclusion of the six rules (?); (=); (,); (^); (9), and (8)
could all be written with `\Lambda  substituted for `. Hence, if \Gamma  ` P is provable, either P is of
the form t: o/ or it is ?, an equation, a conjunction, an existential, or a universal formula
such that \Gamma  ` P : meta. In either case, the free variables of P are assigned some type by
\Gamma .

The following two propositions are simple consequences of this definition of provability.

Proposition 2.4. Let \Gamma  ` t: o/ and \Gamma  ` s: o/ . \Gamma  ` t

o/= s if and only if t fij-converts to s.

Proof. In the reverse direction, this is simply the inference rule (=). The forward direction is not so immediate since there are two inference rules, namely (,) and (=), that
can prove an equation. If \Gamma  ` t

o/= s then there is a proof of this fact that is built first

of typing rules (o/0) - (o/3), a single instance of (=), and then some number n * 0 of (,)
rules. The conclusion of the (=) rule must be of the form

\Gamma  + x1: o/1 + : : : + xn: o/n ` t0

ffi= s0

where o/ is o/1 ! : : : o/n ! ffi and t and s are equal up to ff-conversion to *x1 : : : *xn:t0
and *x1 : : : *xn:s0, respectively. Since t0 and s0 are fij-convertible, so are the terms
*x1 : : : *xn:t0 and *x1 : : : *xn:s0. 2

Adding the inference rule (,), therefore, does not enrich the equations that can be
proved using fij-conversion. This rule is added so that the following proposition will
hold.

Proposition 2.5. Assume that x is not in \Gamma  and let \Gamma  ` N : o/ ! ffi and \Gamma  ` M : o/ ! ffi.
Then, \Gamma  ` 8o/ x:N x

ffi= M x if and only if \Gamma  ` N o/!ffi= M .

Proof. Assume \Gamma  ` 8o/ x:N x

ffi= M x. Then this is proved from \Gamma  + x: o/ ` N x ffi= M x,

from which we can conclude by (,) that \Gamma  ` *xN x

o/!ffi= *xM x. By Proposition 2.4 and jconversion, we have \Gamma  ` N

o/!ffi= M . If we assume \Gamma  ` N o/!ffi= M then \Gamma  + x: o/ ` N x ffi= M x

since fij-conversion is a congruence relation. Finally, by (8), we have \Gamma  ` 8o/ x:N x

ffi= M x.

2

The next proposition follows immediately from the fact that it is decidable to determine
if an untyped *-terms has a simple typing and to determine fij-convertibility for simply
typed *-terms.

Proposition 2.6. Let \Gamma  be a signature and let P be a *-term that does not contain any
occurrences of 9. It is decidable whether or not \Gamma  `\Lambda  P .

The following proposition lists several transformations of terms of type meta that are
useful for several later manipulations. We shall think of such transformation rules as
rewriting rules, and as we shall see, no significant property of unification problems are
changed by using these rewriting rules.

6 D. Miller
Proposition 2.7. Let \Gamma  be a signature and let P be a *-term such that \Gamma  ` P : meta.
Let P 0 be one of the following modifications of P .

(1) P 0 is an alphabetic variant of P .
(2) P 0 is the result of replacing a subterm of the form 8o/ x:N

ffi= M with one of the form

*xN

o/!ffi= *xM , or vice versa.

(3) P 0 is the result of replacing a subterm of the form 8o/ x:N with N , or vice versa,

provided N does not contain x free and does not contain any existential quantifiers.
(4) P 0 is the result of replacing a subterm of the form 8o/ x:N ^8o/ x:M with 8o/ x:(N ^M ),

or vice versa.
(5) P 0 is the result of replacing a subterm of the form M ^ ? or ? ^ M with M .
(6) P 0 is the result of replacing a subterm of the form 9o/ x9ffiyM with 9ffiy9o/ xM or a

subterm of the form 8o/ x8ffiyM with 8ffiy8o/ xM.
(7) P is the result of replacing a subterm of the form t = t with ?.

Then, \Gamma  ` P 0: meta, and \Gamma  ` P if and only if \Gamma  ` P 0.
Proof. Simple inductions on the length of proofs establish the correctness of all of these
rewriting rules. 2

Definition 2.8. A unification problem is a closed, fi-normal *-term P such that

(1) ` P : meta,
(2) P is in prenex normal form; that is, no occurrence of an existential or universal

quantifier is in the scope of a conjunction (given condition (1) and the restriction
on the types of logical constants, no logical constant can occur in the scope of an
equation),
(3) if P contains an occurrence of ^, it contains no occurrences of ? ( ? denotes an

empty conjunction), and
(4) equations in P are only between terms of primitive type.

Conditions (3) and (4) are not genuine restrictions; they are added only for convenience.
Given Proposition 2.7, any prefix normal term of type meta can be rewritten into a terms
satisfying these two conditions.

Example 2.9. Let i be a primitive type. Each of the following are provable:

9i!iX:X

i!i= X 8

iy9iX:X

i= X 8

iX:X

i= X:

The first term is proved by existentially generalizing over the equation *z z

i!i= *z z.

This term is not a unification problem although it can be rewritten into the unification
problem 9i!iX8iy:Xy

i= Xy.

The unification problem 9iX:X

i= X is not provable from the empty signature. This

shows that dropping vacuous universal quantifiers is not generally permitted. Similarly,
anti-prenexing rules are not generally valid. For example, while 8iy9iX[y

i= y ^ X i= X]

is provable, 8iy[y

i= y] ^ 9

ix[X

i= X] is not provable.

As this example shows, the nonprenex normal class of terms forms a class that is
interesting on its own right. We shall, however, consider only prenex normal formulas in

Unification Under a Mixed Prefix 7
this paper since they will simplify parts of our presentation. While most of the structure
of unification in simple types appears to be illustrated using only prenex normal formulas,
the problem of mixing logical inference with unification cannot be addressed only with
prenex normal formulas. See (Miller, 1991b) for an example of using nonprenex normal
formulas to encode that state of a theorem prover that performs both unification and
logical deductions.

Occasionally, we refer to a prefix as being of a form described by a sequence of 8's
and 9's. For example, an important class of prefixes are of the form 898. Such a prefix
has zero or more universal quantifiers, followed by zero or more existential quantifiers,
followed by zero or more universal quantifiers. Thus, a prefix that is of the form 98 is also
of the form 898. A 8-prefix is either empty or a sequence of just universal quantifiers.

Unification problems can easily be embedded into formulas of Church's Simple Theory
of Types (Church, 1940) in the following manner. Let P be a unification problem. While
P is technically an untyped *-term, given the fact that it is fi-normal and inferred to
have type meta, every subterm and bound variables of P can be given a unique type. Let
P \Lambda  be the simply typed *-term where all those types are attached to all bound variables.
Now let P be some particular unification problem and let o/1; : : : ; o/n (n * 1) be the
primitive types used to build types in the prefix of P . Let T be the formulation of the
simple theory of types over primitive types o/1; : : : ; o/n and where meta is identified with
Church's type o. Let `T be provability as in (Church, 1940) except that the axioms of
choice, description, and infinity are not assumed. The following theorem can be proved
by using the cut-elimination theorem for T (see (Andrews, 1971), for example).

Theorem 2.10. If x1; : : : ; xn are distinct variables, then x1: o/1 : : : ; xn: o/n ` P if and
only if `T P \Lambda .

The signature fx1: o/1 : : : ; xn: o/ng above is needed to assure that there exist terms of all
types. Given the characterization of `T using general models (Henkin, 1950; Andrews,
1972), we can conclude from this theorem that ` 8o/1x1 : : : 8o/nxnP if and only if P \Lambda  is
true in all general models.

In the next section we present a characterization of provable unification problems using
substitutions.

3. Prefix as Declaration
Besides declaring type information for constants and variables in a unification problem,
a prefix also indicates, by the relative positions of variables in the prefix, which constants
can appear in substitution terms for which variables. For example, the unification problem
8i!if 9ix8iw[(f w) = x], where i is a primitive type, has no solution: trying to instantiate
x with (f w) will fail to yield a valid equality since the rules of substitution require that
the bound variable w in the prefix be changed to some other variable to avoid variable
capture. Thus, the resulting equation would be between (f w) and (f w0) where w would
be a free variable and w0 would be a bound variable. Here, the prefix declares that any
substitution term for x may contain f free but may not contain w free. The following
definitions help to formalize this constraint on substitutions.

Definition 3.1. A quantifier prefix (prefix for short) is a finite list of distinct variables
quantified using typed versions of either universal or existential quantifiers. Let Q be a

8 D. Miller
prefix. The *-term t is a Q-term if t contains no constants other than the logical constants
and all the free variables of t are bound in Q. If t is a Q-term we will call the pair Qt a
prefixed term. Such a prefixed term is of type ffi if \Gamma  ` t: ffi, where \Gamma  is the set of pairs x: o/
where x is bound by either 8o/ or 9o/ in Q. Finally, the prefix term Qt is fi-normal if t is
fi-normal, and two prefixed terms Qt1 and Qt2 with the same prefix are fi-convertible if
t1 is fi-convertible to t2.

Given a prefix Q and an untyped *-term t, it is decidable whether t is a Q-term of a
given type. The type of t, however, is not uniquely determined, in general, from Q. For
example, the untyped *-term *w:w can be given the type o/ ! o/ for any type o/ with
respect to any prefix Q. However, the type of all subexpressions and bound variables of a
fi-normal prefixed term are uniquely determined from a type given for the prefixed term.
Finally, unification problems can be thought of as being prefixed terms: that is, if P is of
the form QD where Q is a string of quantifiers and D is a (possibly empty) conjunction
of equations, then QD is a fi-normal prefixed term of type meta.

Definition 3.2. Let Q be the prefix Q1QxQ2 for prefixes Q1 and Q2. If y is bound in
Q1 then y is to the left of x in Q. If y is bound in Q2 then y is to the right of x in
Q. Often reference to the prefix Q is dropped when it is obvious which prefix is being
considered.

Next we define what it means to substitute into a prefixed term.
Definition 3.3. Let Q be a prefix of the form Q19o/ xQ2. A term s is Q-closed for x if
the free variables of s are universally bound in Q1 and \Gamma  ` s: o/ where \Gamma  is the signature
that associates to universal variables in Q1 the type at which they are bound in Q1.

A finite set ` of pairs is a Q-substitution if, whenever (x; s) 2 `, x is existentially
quantified in Q and s is fi-normal and Q-closed for x. Also, ` must be functional; that
is, if (x; s1) and (x; s2) are members of `, then s1 and s2 are equal terms. Finally, if
(x; s) 2 ` then x is in the domain of ` and s is in its range.

A Q-substitution ` can be considered as the following function on Q-terms. If ` is
empty, then `(Qt) := Qt. Otherwise, let (x; s) 2 `, let Q be Q19xQ2, and let `0 :=
` \Gamma  f(x; s)g. Set `(Qt) := `0(Q1Q2[s=x]t). It is easy to show that since s does not contain
any free occurrences of variables in the domain of `, this definition is independent of the
choice of (x; s) from `. We shall generally write the substitution f(x1; s1); : : : ; (xn; sn)g
with the more suggestive notation [x1 7! s1; : : : ; xn 7! sn].

Two Q-substitutions are considered equal it they map the same existentially quantified
variable to terms that are j-convertible.

There are prefixes Q for which no Q-substitution exists.
Definition 3.4. Let Q be a prefix of the form Q19o/ xQ2. If there is no Q-closed term
for x then we say that this occurrence of 9o/ in Q is empty.

Clearly, a Q-substitution exists if and only if all existential variables of Q are nonempty.
Fortunately, determining whether or not there is a Q-substitution given Q is decidable
since it is equivalent to proving formulas in intuitionistic propositional logic. In particular,
a type, say o/ , can be thought of as denoting a formula in propositional logic defined by

Unification Under a Mixed Prefix 9
considering all its primitive types as propositional symbols and by considering the type
constructor ! as implication.

Definition 3.5. Let \Delta  be a finite set of types and let o/ be a type. The binary relation
\Delta  `I o/ defined by the three rules below determines intuitionistic provability for propositional implication logic.

(1) If o/ 2 \Delta  then \Delta  `I o/ .
(2) If fo/1g [ \Delta  `I o/2 then \Delta  `I o/1 ! o/2.
(3) If ffi1 ! ffi2 2 \Delta , \Delta  `I ffi1, and fffi2g [ \Delta  `I o/ then \Delta  `I o/ .

This relation is shown to be polynomial-space complete in (Statman, 1979).

The following proposition follows immediately from well known results (Hindley &
Seldin, 1986).

Proposition 3.6. Let Q be a prefix, let \Delta  be the set of types attributed to the bound
variables in Q, and let o/ be a type that does not contain the type symbol meta. \Delta  `I o/ if
and only if there is Q-term t of type o/ .

Definition 3.7. Let P be a unification problem with prefix Q. A Q-substitution ` is a
solution to P if its domain is the set of all existential variables of Q and ` `P . Since `P
contains no existential quantifiers, determining if `P is provable is decidable (Proposition
2.6).

Given these definitions, we can now use substitutions to characterize those unification
problems that are provable.

Theorem 3.8. If P is a unification problem, then ` P if and only if P has a solution.
Proof. The proof is a straightforward proof by induction on the length of the prefix of
P . 2

Thus, given a Q-substitution, it can be decided whether or not it is a solution to P . In
general, however, it is undecidable whether or not P has a solution. This was first shown
for third-order unification problems independently by Huet (1973a) and Lucchesi (1972)
and then later for second-order unification problems by Goldfarb (1981). A variation on
Goldfarb's result is presented in Section 8.

One final observation concludes this section. Its proof is simple and omitted.

Proposition 3.9. The set of solutions to a unification problem does not change when using the rewriting rules in Proposition 2.7. In the case of the first rule using ff-conversion,
the names of the variables in the corresponding substitutions must be changed to account
for the change of bound variables in the prefix.

The set of solutions for a given unification problem occasionally has a regular structure.
For example, a first-order 89-unification problem that has any solution can have all its
solutions described as closed instances of a most general unifier (mgu). Recognizing the

10 D. Miller
presence of mgu's is valuable for numerous theoretical and practical considerations. As is
well known, however, the unification problems we are considering here do not generally
have mgu's. The problem of finding a suitable replacement for mgu's as a characterization
of large sets of solutions is addressed in Section 10.

4. Skolemization
Consider the two propositions

8o/ x9ffiy P and 9o/!ffif 8o/ x [f x=y]P: (1)
If we consider validity in general models, then it is valid that the second formula implies
the first. A choice principle is needed to show that the first entails the second. If we
dualize the quantifiers in (1), we get the two formulas

9o/ x8ffiy P and 8o/!ffif 9o/ x [f x=y]P: (2):
In this case, the forward implication is valid while the reverse implication requires a
choice principle. We shall show in Section 5 that when restricted to just the setting of
unification problems, one of the formulas in (1) is provable if and only if the other formula
in (1) is provable (choice is not needed). A similar relationship holds for the two formulas
in (2) only if certain restrictions are made on unification problems. These restrictions are
investigated in this section.

The process of replacing the first formula in (2) with the second formula will be called
Skolemization. Notice that in the theorem proving literature, Skolemization is generally
defined with respect to the first pair of formulas above since that literature is often
involved with searching for refutations of the negation of proposed theorems. Since we
shall be looking for direct proofs and not refutations, Skolemization is properly presented
using the formulas in (2).

Skolemization can be described from the syntactic point of view as follows: the scoping
of quantifiers in 9o/ x8ffiy P prohibits the variable y from appearing in the substitution
term for x. Replacing the variable y in the first formula of (2) with the term f x will
successfully encode this restriction: if t is the substitution term for x, then t cannot
contain a subterm occurrence of f t.

For our purposes here, the usual presentation of Skolemization for first-order logic (see,
for example, (Andrews, 1986)) is problematic on at least four accounts. First, a formal
mechanism for forcing Skolem functions f to be new is generally achieved by enriching
the logic with a denumerably infinite collection of constants that are not permitted in
proposed theorems. These constants only enter the prover via Skolemization. As has
already been described, we have a simpler and more elegant method for guaranteeing
"newness" using prefixes: the Skolem function must be declared in the prefix of the unification problem and there, as all quantified variables, it must be different from any other
variable declared for that problem. This way of writing Skolemization is also appealing
since it can be viewed as a left rotation of a universal quantifier over an existential quantifier. This is particularly interesting since a dual operation, that is, a left rotation of an
existential quantified variables over a universal quantifier, will also interest us (Section
5).

A second and more serious problem is that Skolem functions should not be used in
abstractions as if they are genuine functions. Unrestricted uses of Skolem functions in
substitutions can only be justified if choice principles are permitted, but such are not

Unification Under a Mixed Prefix 11
available in the proof system presented in Section 2. Consider the following example. In
this section, we shall assume that a and b are two primitive types.

Example 4.1. The unification problem 8(a!b)!az9aX8by ? has no solution: since there
is no intuitionistic proof of a from (a ! b) ! a, there is no *-term of type a whose only
free variables are of type (a ! b) ! a. If we Skolemize this formula by moving the
bound variable y to the left, we get 8(a!b)!az8a!bf 9aX ?, which does have the solution
X 7! z(*w(f w)) (which is equal to the substitution X 7! zf ).

Here, the Skolem function f is used as a first class function and not as the simple
syntactic device motivated above. If Skolem terms are used only as such a device, then
whenever f has type o/ ! ffi and there are no Q-terms of type o/ , then there should be
no Q8o/!ffif -terms containing the function f . A restriction on Skolem functions will be
presented later in this section by the introduction of "ranked" universal quantifiers. The
aspect of unsoundness demonstrated by this example will be fixed by ranks.

A third problem with Skolemization arises when the solutions to unifications problems
before and after Skolemizing are compared. It is most desirable to have a bijection between solutions of a problem and its Skolemized form. Unfortunately, there appears to
be no such bijection. A "deskolemizing" mapping can be defined but it will not generally
convert all solutions to a Skolemized problem back to solutions of the original problem.
Furthermore, when deskolemizing can be used, it may be many-to-one, a fact that is
illustrated in the next example.

Example 4.2. The unification problem 8az9aX8ay ? has exactly one solution, namely
X 7! z. The Skolemized form of this problem, namely 8az8a!af 9aX ?, has an infinite number of different solutions, namely X 7! z, X 7! f z, X 7! f (f z), etc. The
deskolemization process described later will be able to collapse all of these solutions into
the solution above by identifying f with the constant-valued z function.

There seems no easy way to improve Skolemization in order to solve this many-to-one
correspondence of solutions. Skolemization adds redundancy to a unification problem.

Our final problem with the use of Skolem functions is the most serious and illustrates
an aspect of empty types that is not illustrated by Example 4.1.

Example 4.3. The unification problem 8az8b!ag9aX8by ? has exactly one solution,
namely X 7! z. Its Skolemized form, that is, 8az8b!ag8a!bf 9aX ? has an infinite
number of solutions; X 7! z, X 7! g(f z), X 7! g(f (g(f z))), etc. No simple interpretation
of the Skolem function f would seem to identify all of these substitution terms since there
is no 8az8b!ag-term of type b.

In this example, the prefix to the left of the existential variable X in the original
unification problem does not provide enough variables to build a term of type b. After
Skolemization, however, the prefix to the left of X can be used to build a term of type
b and that term can be use to build new terms of type a. There seems to be no way to
identify the new term of intermediate type b built using f with any term in the original
problem.

As we shall see in Theorem 4.11, if the type of the variable that gets Skolemized is
nonempty (with respect to the prefix to the left of the existential variable), then all

12 D. Miller
solutions to the Skolemized problem can be deskolemized to solutions of the original
unification problem.

As was mentioned above, part of the approach to making Skolem functions sound in
this setting is to restrict their occurrences within substitution terms. The notion of rank
must first be introduced.

Definition 4.4. The constants 8ro/ , where r * 0 and o/ is any type with r or more
argument types, are called ranked universal quantifiers. A variable bound by 8ro/ is said
to have rank r. The quantifier 80o/ is identified with 8o/ . The logical constant 8ro/ has the
same type as the logical constant 8o/ .

Ranked universal quantifiers will now be permitted in the prefixes of unification problems. Let 8ro/ quantify the variable x and let o/ be of the form o/1 ! \Delta  \Delta  \Delta  ! o/n ! o/0
with o/0 a primitive type and r ^ n. Then, n is the maximum number of arguments that
occurrences of x can have, while as we define below, r is the number of arguments that
occurrences x must have. Several of our definitions regarding prefixes must now be extended. The most fundamental extension is in the following definition: other extensions
are more immediate. The motivation for the following definition, however, has already
been presented: variables that have a positive rank play the role of Skolem functions:
they cannot be permitted to act as genuine functions.

Definition 4.5. Let Q be a prefix containing possibly positively ranked universal quantifiers. The *-term t is a Q-term if (i) t contains no nonlogical constants and all the free
variables of t are bound in Q, (ii) if t contains a free occurrence of r-ranked universally
bound variable then that occurrence must have at least r arguments, called its necessary
arguments, and (iii) if any variable has a free occurrence in any necessary argument then
that free occurrence is also free in t.

The aggregation of a ranked variable with its necessary arguments is intended to be
the name of a single, new object. The condition on free variable occurrences in necessary
arguments makes certain that an abstraction is not made into that name.

Example 4.6. Let Q be the prefix 81a!af 81a!ag9a!a!aA8ax. Then (f x); (f (gx)), and
*w(Aw(gx)) are all Q-terms. On the other hand, f , *w(f w), and *w(A(gx)(f w)) are
not Q-terms.

Notice that the complications mentioned in Examples 4.2 and 4.3 are not solved if
we add ranks to the Skolem functions in them and reinterpreted Q-terms using ranked
quantifiers. The proofs of Propositions 4.7 and 4.9 below can be found in (Miller, 1987).

Proposition 4.7. Let Q be a prefix and let t be a Q-term of type o/ . If t is j-convertible
to t0 then t0 is a Q-term of type o/ . If t fi-reduces to t0 then t0 is a Q-term of type o/ . In
particular, if Q = Q19ffixQ2 and s is a Q1-term of type ffi, then [s=x]t is a Q-term of type
o/ .

The converse of the statement regarding fi-reduction is not true: if t0 reduces to the
Q-term t then t0 is not necessarily a Q-term. For example, if Q is 8ay81a!au, then the
term y is a Q-term while (*w y)u is not.

Unification Under a Mixed Prefix 13
Definition 4.8. Let f be a variable, and let s, t, and A be *-terms. The deskolemizing
operation Dfts is defined as follows: Dfts A is the result of replacing all subterms of A that
are fij-convertible to f t by s. Of course, it may be necessary to change bound variable
names in A to avoid capturing free variables of s.

Given that we equate two terms if they are alphabetic variants of each other, the
operation Dfts is technically not well defined. For example, if Dfxy is applied to the
two equal terms *x:a(f x) and *z:a(f z), two different answers result, namely *x:ay and
*z:a(f z). Fortunately, this cannot happen if f is declared to have a positive rank. For
example, we have the following result.

Proposition 4.9. Let Q be the prefix Q18p+1o/!ffif 9o/ xQ2, let t be a Q1-term of type o/ , and
let A and B be Q-terms. Then all the following are true.

(1) Any occurrence of y in Dfty A will have at least p arguments and any free variables

in that occurrence's first p arguments are free in Dfty A.
(2) If A is fi-reducible to B then Dfty A is fi-reducible to Dfty B.
(3) If A is the fi-normal form of B, then Dfty A is the fi-normal form of Dfty B.
(4) If A is j-convertible to B then Dfty A is j-convertible to Dfty B.

The term Dfty A may not be a Q19x8pyQ2-term since it may contain occurrences of f .
We can, however, prove the following.

Lemma 4.10. Let Q be the prefix Q18p+1o/!ffif 9o/ xQ2, let t be a Q-term of type o/ , and let A
be a Q-term. Also assume that there exist Q1-terms of type ffi. Then A can be completely
"deskolemized" with respect to f in the following fashion. Let ft; u1; : : : ; umg (m * 0) be
a set of terms that contains all terms u such that f u is a subterm of A. Let d1; : : : ; dm
be a list of (not necessarily distinct) Q1-terms of type ffi. The term

A0 := Dfu1d1 (: : : (Dfu

m

dm (D

ft
y A)) : : :)

is a Q19x8pyQ2-term.

Proof. Clearly, A0 contains no occurrences of f . Consider an occurrence of the p-ranked
variable y in A0. Such an occurrence of y arises from removing an occurrence of f t,
which has at least p arguments. Hence, all the occurrences of y in A0 have at least p
arguments. Finally, applications of the D operator cannot introduce any new bound
variable dependencies. Therefore, A0 is a Q19x8pyQ2-term. 2

The following theorem establishes the completeness for Skolemization. Soundness is
only established in the case that the type of the variable being Skolemized is nonempty.

Theorem 4.11. Let D be a conjunction of equations such that

Q19o/ x8pffiyQ2D (\Lambda )
is a unification problem. If this problem has a solution, the unification problem

Q18p+1o/!ffif 9o/ xQ2[f x=y]D (\Lambda \Lambda )
has a solution. If there exists a Q1-term of the type ffi, the converse is true.

14 D. Miller
Proof. Let ` be a solution for (\Lambda ) and let t be `x. Let

`0 := f(z; [f t=y]s) j (z; s) 2 `g:
It is easy to verify that this substitution is a Q18p+1f 9xQ2-substitution. Furthermore, if
u and v are two terms such that `u and `v are fij-convertible, then [f t=y]`u and [f t=y]`v
are fij-convertible. These last two terms, however, are simply equal to `0([f x=y]u) and
`0([f x=y]v). Hence, `0 is a solution to (\Lambda \Lambda ).

Let ` be a Q18p+1f 9xQ2-substitution that is a solution to (\Lambda \Lambda ) and let t be `x. Let
ft; u1; : : : ; umg (m * 0) be a set of terms that contains all terms u such that f u is a
subterm of some term in the range of `. Let d1; : : : ; dm be a list of (not necessarily distinct)
fi-normal Q1-terms. Finally, let E be the operation Es := Dfu1d1 (: : : (Dfu

m

dm (D

fty s)) : : :),

and let `0 := f(z; Es) j (z; s) 2 `g. We now show that `0 is a solution to (\Lambda ).

Let (z; s) 2 `0. If z is in the prefix Q2 then s will contain no occurrences of f but may
contain occurrences of y. If z is x, then s is Et, which cannot contain any occurrences
of y since f t is not a subterm of t. If z is in the prefix Q1 then Es is the same as
s since s contains no occurrences of f . Thus, using Lemma 4.10, `0 is a Q19x8pyQ2-
substitution. Furthermore, let u and v be two terms such that `([f x=y]u) and `([f x=y]v)
are fij-convertible. These two terms are also equal to [f t=y]`u and [f t=y]`v, respectively.
By repeated use of Proposition 4.9, the two terms E([f t=y]`u) and E([f t=y]`v) are fijconvertible. But these terms are equal to E(`u) and E(`v), which are the terms `0u and
`0v. Hence, `0 is a solution to (\Lambda ). 2

Definition 4.12. If P is the unification problem (\Lambda ) and P 0 is the unification problem
(\Lambda \Lambda ) above, we say that P 0 is the result of Skolemizing P at 8pffiy.

Example 4.13. The unification problem

8a!af 8a!ag8au9aX8ay9Z[(f X(gy))

a= (f uZ)]

can be Skolemized to the unification problem

8a!af 8a!ag8au81a!ak9aX9aZ[f X(g(kX))

a= f uZ]:

This problem has the solution f(X; u); (Z; g(ku))g and it can be deskolemized to f(X; u);
(Z; gy)g.

For another example, consider the unification problem

8a!a!ag8ax9a!aF 8ay9aZ[F y

a= gyx ^ Z a= F y]:

This can be Skolemized to the unification problem

8a!a!ag8ax81(a!a)!ak9a!aF 9aZ[F (kF )

a= g(kF )x ^ Z a= F (kF )]:

Here, gx is a 8a!a!ag8ax-term of type a ! a. There is exactly one solution for this
unification problem, namely,

f(F; *w(gwx)); (Z; g(k(*w(gwx)))x)g:
If this solution is deskolemized, we get a solution for the original unification problem,
namely, f(F; *w(gwx)); (Z; gyx)g:

Example 4.14. If we return to Example 4.3 and make certain that the type of the

Unification Under a Mixed Prefix 15
Skolemized variable is nonempty, we notice that deskolemizing will work correctly. Consider the modified unification problem 8bw8az8b!ag9aX8by ? and its Skolemized form

8bw8az8b!ag81a!bf 9aX ?:
This latter unification problem now has solutions X 7! z, x 7! (gw), X 7! g(f z),
X 7! g(f (g(f z))), etc. We can now deskolemize any of these solutions by replacing
the subterms f z; f (g(f z)) etc. with w. All these solutions collapse down to just the two
solutions for the original problem, namely X 7! z and X 7! (gw).

The more general case of Skolemization for nonprenex normal formulas of a higherorder logic is studied in (Miller, 1987). In the next section, we present the dual to Skolemization mentioned earlier.

5. Raising
The dual operation of rotating an existential quantifiers to the left over a universal
quantifier will be called raising. In comparison to Skolemization, the metatheory of this
rewriting process is particularly simple. It requires no new declarations, such as ranked
quantifiers. Solutions before and after raising can be placed in one-to-one correspondence.
The following theorem is the main result of this section.

Theorem 5.1. Let D be a conjunction of equations so that

Q18o/ y9ffixQ2D (\Lambda )
is a unification problem. This problem has a solution if and only if the unification problem

Q19o/!ffih8o/ yQ2[hy=x]D (\Lambda \Lambda )
has a solution. Furthermore, a solution for either problem can be transformed in a oneto-one fashion to a solution of the other problem.

Proof. Let ` be a solution to (\Lambda ) and let t be `x. Set `0 := ` \Gamma  f(x; t)g and `00 :=
`0 [ f(h; *yt)g. Clearly, `00 is a Q19h8yQ2-substitution. Also, `00([hy=x]D) is equal to
[(*yt)y=x](`0D) which is nothing more than `D. Hence, `00 is a solution for (\Lambda \Lambda ).

For the converse, let ` be a solution for (\Lambda \Lambda ). Let t be the value of `h, and set `0 :=
`\Gamma f(h; t)g and `00 := `[f(x; ty)g. Clearly, `00 is a Q18y9xQ2-substitution. Now, `[hy=x]D
is equal to [ty=x]`0D which is the same as `00D. Hence, `00 is a solution to (\Lambda ).

The translations of solutions given in this proof put the solutions for (\Lambda ) in one-to-one
correspondence with the solutions for (\Lambda \Lambda ). 2

Definition 5.2. If P is the unification problem (\Lambda ) and P 0 is the unification problem
(\Lambda \Lambda ) above, we say that P 0 is the result of raising P at 9ffix.

Example 5.3. Let a be a primitive type. The unification problem

8a!a!af 8ay9a!aX8az[Xz

a= f zy]

can be raised twice to

9(a!a!a)!a!a!aH8a!a!af 8ay8az[Hf yz

a= f zy]:

16 D. Miller
Using Proposition 2.7, this is solvable if and only if

9(a!a!a)!a!a!aH[*f*y*z:Hf yz = *f*y*z:fzy]
is provable. Here the type on this last equation is (a ! a ! a) ! a ! a ! a. Since the
left-hand side of the equation is j-convertible to H, the only solution to this unification
problem is f(H; *f *y*z:f zy)g. By the proof Theorem 5.1, we know that the original
unification problem has exactly one solution, namely f(X; *z:fzy)g.

Raising is closely related to a translation used in (Statman, 1981) where several simplifications in the presentation of unification problems are made. First, a unification
problem with a 98-prefix of the form

9x1 : : : 9xn8y1 : : : 8yp[t1 = s1 ^ : : : ^ tm = sm] (\Lambda )
is encoded by the two *-terms

M1 := *x1 : : : *xn*y1 : : : *yp*z(zt1 : : : tm) and
M2 := *x1 : : : *xn*y1 : : : *yp*z(zs1 : : : sm):

The unification problem in (\Lambda ) has a solution if and only if there is a list of *-terms,
N1; : : : ; Nn such that for all i = 1; : : : ; n, Ni can be given the same type as xi is given in
the prefix and such that

M1N1 : : : Nn fij-converts to M2N1 : : : Nn: (\Lambda \Lambda )
A second simplification in (Statman, 1981) is that constants are not allowed in the
terms M1 and M2. Assume that the constants c1; : : : ; cq (q * 0) occurred in (\Lambda ) and
hence in the terms M1 and M2. Let z1; : : : ; zq be variables that have no occurrences in
(\Lambda ) and let ' be the mapping that when applied to a *-term, replaces the constant ci
with zi for all i = 1; : : : ; q. Instead of using M1 and M2 to denote the unification problem
(\Lambda ), Statman uses the following two constant-free terms:

M \Lambda 1 := *w1 : : : *wn*z1 : : : *zq(('M1)(w1z1 : : : zq) : : : (wnz1 : : : zq)) and
M \Lambda 2 := *w1 : : : *wn*z1 : : : *zq(('M2)(w1z1 : : : zq) : : : (wnz1 : : : zq)):

It is easy to show (\Lambda \Lambda ) is satisfied if and only if

M \Lambda 1 N \Lambda 1 : : : N \Lambda n fij-converts to M \Lambda 2 N \Lambda 1 : : : N \Lambda n;
where, for i = 1; : : : ; n, N \Lambda i is equal to *z1 : : : *zq'Ni: In this sense, it is always possible
to replace constants appearing in unification problems with abstracted variables.

The relationship of this translation of unification problems to raising is immediate. If
the unification problem (\Lambda ) contained the constants c1; : : : ; cq, we would have chosen to
declare them explicitly in the prefix of (\Lambda ); that is, we would have written the unification
problem as

8z1 : : : 8zq9x1 : : : 9xn8y1 : : : 8yp['t1 = 's1 ^ : : : ^ 'tm = 'sm]:
By repeatedly raising its existential variables, this problem could be written into the
form

9w1 : : : 9wn8z1 : : : 8zq8y1 : : : 8yp[aet1 = aes1 ^ : : : ^ aetm = aesm];

where, for i = 1; : : : ; n, wi is the result of raising xi by moving it left over 8z1 : : : 8zq, and
ae is the substitution that results in applying ' and then replacing xi with (wiz1 : : : zq)

Unification Under a Mixed Prefix 17
for i = 1; : : : ; n. This latter unification problem is represented by the pair of *-terms M \Lambda 1
and M \Lambda 2 .

The operation of 8-lifting in (Paulson, 1989) is also related to raising in the sense that
it can be presented as the backchaining inference rule followed by a sequence of raising
steps (see (Miller, 1991b)).

6. Simplifying the Prefix of a Unification Problem
Skolemization can be used to rewrite a unification problem into a problem with a 89-
prefix: repeatedly move universal quantifiers left over existential quantifiers increasing
their rank and their type as they move. Once a 89-prefix is constructed, all the universal
quantifiers can be replaced by "ranked" constants. The resulting unification problem is
purely existential and as such can be dealt with by conventional unification processes,
modified if necessary to handle such ranked constants. Since *-abstractions are not available in the first-order setting, first-order unification does not need to be so modified. We
show in the next section how the unification of *-terms must be modified to deal correctly
with ranked constants. Once a solution for the simplified unification problem is found, it
can be converted to a solution of the original problem by repeatedly deskolemizing the
solution, provided that all the types of Skolemized quantifiers are not empty.

In a similar manner, any prefix without positive ranked universal quantifiers can be
rewritten using raising until it is an 98-prefix. The resulting unification problem can
further be simplified by taking the universally quantified variables in the prefix and
*-abstracting them over the terms in all the equations of the problem. The resulting
unification problem again has only an existential prefix, with terms containing possibly
long binders and high orders. For each universal quantifier an existential quantifier is
moved over, the type of the variable being quantified is raised by giving it an additional
argument. Thus, a unification problem that is first-order, that is, in which the existentially
quantified variables are all of primitive type, would be converted to a unification problem
with functional variables. This may seem undesirable given that several useful properties
of first-order unification do not hold for unification involving functional variables. As
shown in Section 12, the complexity introduced by raising is particularly simple. A raised
first-order unification problem has a decidable unification problem and most general
unifiers.

The two rewriting processes, Skolemization and raising, can be used together in the
same prefix. Once a universal quantifier is moved left by Skolemization, no existential
variable can be move left past it since raising can only involve universal quantifiers of rank
zero. Prefixes of the form 898 represents a natural reduction class for unification problems: the outermost universal quantified variables denote the constants of the problem
while the inner most universal quantified variables denote the top-level *-abstractions.

Of course, it is should be possible to take existing unification algorithms and modify
them so that they can deal directly with general unification problems. This is the topic
of the next section.

7. Reducing Unification Problems
This section is an adaptation of part of (Huet, 1975) to our mixed prefix setting.
Several rewriting methods are presented that convert unification problems to, hopefully,
more solvable problems.

18 D. Miller

Following standard convention, equations occurring within unification problems will
also be called disagreement pairs. The following classification of prefixed terms and disagreement pairs is central to the unification process describe below.

Definition 7.1. Any fi-normal prefixed term Qt can be written uniquely as

Q*x1 : : : *xn(yt1 : : : tm)
where n * 0, m * 0, and y is a variable. The binder of this term is the list x1; : : : ; xn,
its head is the variable y, and its arguments are the terms t1; : : : ; tm.

If y is existentially quantified in Q, then Qt is flexible. Otherwise, y is either universally
bound in Q or a member of the binder of t: in either case Qt is rigid.

Let P be a unification problem with prefix Q and let t

o/= s be an equation of P . (Of

course, o/ is a primitive type.) This equation is rigid-rigid if both Qt and Qs are rigid, is
flexible-flexible if both Qt and Qs are flexible, and is flexible-rigid otherwise.

This classification is important because it captures the one invariance about substitution and fi-normalization that we will use repeatedly: if Qt is rigid, then any Qsubstitution instance of Qt is rigid and has the same head as Qt. This invariance justifies
the following simplification of rigid-rigid disagreement pairs. Let ht1 : : : tp = ks1 : : : sq be
a rigid-rigid disagreement pair in a unification problem with prefix Q. If these two terms
are to have instances that are *-convertible under some substitution, their heads must be
the same, p and q must be equal, and for i = 1; : : : ; p, ti and si must be simultaneously
unifiable under the prefix Q.

Example 7.2. Using these observations, we can rewrite the unification problem

8((i!i)!i)!i!if 8ia9iV 9i!iW 8ib[f (*x(xa))V

i= f (*y(yV ))(W b)]

into the term

8f 8a9V 9W 8b[*x(xa)

(i!i)!i= *y(yV ) ^ V i= W b]:

This is not a proper unification problem. Using Proposition 2.7, this term has the same
solutions as the unification problem

8f 8a9V 9W 8b8i!ix[xa

i= xV ^ V i= W b]:

This problem contains a rigid-rigid pair and can be rewritten as

8f 8a9V 9W 8b8x[a

i= V ^ V i= W b]:

This final unification problem contains no rigid-rigid disagreement pairs and cannot be
simplified in this manner any further. The first pair is flexible-rigid while the second is
flexible-flexible.

Definition 7.3. Let P be a unification problem that contains an equation of the form
kt1 : : : tn = ks1 : : : sn (n * 0). The process of rewriting P by replacing this equation with
the conjunction t1 = s1 ^ : : : ^ tn = sn and then using Proposition 2.7 repeatedly to
make the resulting term a unification problem is called the simplification rewriting step.
If n = 0 then ? replaces the equation k = k. A unification problem that contains no
rigid-rigid pairs with the same head is a simplified unification problem.

The following proposition follows immediately.

Unification Under a Mixed Prefix 19
Proposition 7.4. Using simplification and the rewriting rules (1), (2), (4), and (5) of
Proposition 2.7, a unification problem P can be rewritten to a unification problem, say
P 0, in which there are either no rigid-rigid disagreement pairs or where some rigid-rigid
disagreement pair is composed of terms with different heads. In either case, the solutions
to P 0 are exactly the same as the solutions to P . Furthermore, P 0 is unique modulo
ff-conversion and the ordering of the rightmost universal variables of the prefix.

Further analysis of disagreement pairs will require the use of substitutions for existentially quantified variables. These substitutions will not, in general, be Q-substitutions
(where Q is the prefix of the unification problem in question) since such substitutions
replace existential variables with essentially closed or completed terms. We shall need the
flexibility in building solutions incrementally by using substitution terms that are open,
that is, that contain subterms that must be determined later. To this end, we introduce
the following definitions.

Definition 7.5. Let Qt be a prefixed term where Q is of the form Q19o/ f Q2. A prefixed
term Q19H1 : : : 9Hns (n * 0) is Q-free for f if it is of type o/ . Here, we may assume that
the variables H1; : : : ; Hn are not bound in Q. The result of substituting s for f in Qt,
written as [f 7! s]Qt, is the prefixed term

Q19H1 : : : 9HnQ2([s=f ]t):
Similarly, if P is a unification problem, it can also be thought of as a prefixed term. Thus,
the term [f 7! s]P can be made into a unification problem by using fi-reduction and the
rewrites in Proposition 2.7.

If Q is of the form Q19o/ f Q2 and if Q19H1 : : : 9Hns is Q-free for f, the substitution
[f 7! s] is not generally a Q-substitution because s may contain existential variables of
Q1 or it may contain new existential variables (namely, H1; : : : ; Hn). We shall make use
of these kinds of substitutions, however, to build solutions for unification problems. The
substitutions of the form [f 7! s] used in this section will all be such that free variables
of s are either universal variables of Q1 or are new existential variables. It will not be
until Section 10 that such substitution terms will contain existential variables of Q1.

Definition 7.6. Let oe be a Q19H1 : : : 9HnQ2-substitution and let Q19H1 : : : 9Hns be
a prefixed term that is Q19o/ f Q2-free for f . The composition of [f 7! s] with oe, written
[f 7! s] ffi oe, is the Q19f Q2-substitution given by

f(f; s0)g [ f(v; oev) j v 2 dom(oe) and v =2 fH1; : : : ; Hngg;
where s0 is the term part of the prefixed term oeQ19H1 : : : 9Hns. Composition associates
to the right and satisfies the equation (f ffi g)x = g(f (x)).

We shall occasionally suppress stating the prefix of Q19H1 : : : 9Hns since it can be
constructed from Q by taking the free variables of s not bound to the left of f as
the variables H1; : : : ; Hn and then determining an appropriate type for those variables.
The following proposition shows that when s is Q-free for f , [f 7! s] can represent a
component of a final complete solution.

20 D. Miller
Proposition 7.7. Let P be a unification problem with prefix Q = Q19o/ f Q2. Let s be
Q-free for f . Then [f 7! s]P has solution oe if and only if P has solution [f 7! s] ffi oe.

Proof. Let Q19o/ f Q2t be a prefixed term and let Q19H1 : : : 9Hns be Q-free for f .
Let oe be a Q19H1 : : : 9HnQ2-substitution. The fi-normal form of the formulas oe([f 7!
s]Q19o/ f Q2t) and ([f 7! s] ffi oe)Q19o/ f Q2t are the same. Let P be a unification problem
with prefix Q19o/ f Q2. Since oe([f 7! s]Q19o/ f Q2t) and ([f 7! s] ffi oe)Q19o/ f Q2t are the
same, [f 7! s]P has solution oe if and only if P has solution [f 7! s] ffi oe. 2

We can now return to the construction of solutions to unification problems. Consider
the case where only one term of a disagreement pair is rigid; the other one being flexible.
For example, let f t1 : : : tp = ks1 : : : sq be a disagreement pair and assume that f is
existentially quantified while k is a universally quantified. For these to be unifiable, f
must be instantiated with a term that, after fi-normalization, puts k at the head of the
flexible term. There are two general ways to place k at the head since there are two
processes that are used to make these terms equal, namely, substitution and *-reduction.

Straightforward substitution can make the flexible term look like the rigid one if the
substitution term for f has head k. That is, the substitution term imitates the head of
the rigid term. However, *-reduction can also be performed on disagreement pairs after
a substitution. Thus the term substituted for f could be used to migrate subterms of
the flexible term that might contain k into the head position of the flexible term. This
method of placing k at the head of a the flexible term is indirect and, hence, will often
produce several possible substitution terms. Immediate subterms in the flexible term can
be accessed by a sequence of projections. For example, to place the ith argument ti of
the flexible term in the head position, a substitution term for f would be an abstraction
of the variables *w1 : : : *wp over a term with wi as its head. The result of substituting
such a term for f and then normalizing will leave a term whose head is equal to the
head of ti. If the head of ti is k then we have succeeded in our goal. If the head is a
universally quantified variable different than k, we have failed and need to backtrack to
other choices. If the head of ti is an existentially quantified variable, we could use such
a projection term again to access subterms of ti, or try to use imitation on the flexible
head of ti.

Let us now be more precise about both the imitation and projection schemes for
getting a flexible head to match a rigid head. Assume that we are given the flexiblerigid disagreement pair f t1 : : : tp = ks1 : : : sq where f is existentially quantified and k is
universally quantified.

If k is quantified to the right of f , the imitation scheme cannot be used since the
substitution term for f cannot contain k. If k is quantified to the left of where f is
quantified, then it is possible to make the head of the flexible term become k directly.
Let r be the rank of k. If r = 0 then the imitation term for f is a *-term of the form

*w1 : : : *wp (k(H1w1 : : : wp) : : : (Hqw1 : : : wp));
which has the same type as f . This term takes each of the p arguments of the flexible term and constructs a new term with k as the head and whose arguments depend
functionally on the arguments of the flexible term. Notice that this functional dependency is left unspecified; H1; : : : ; Hq are unspecified higher-order variables. Examining
just the surface structure of the rigid term does not provide any information on how

Unification Under a Mixed Prefix 21
these new variables should be instantiated. Their determination is attempted later after
simplification removes more of the surface structure.

Notice that if the rank r is positive then the substitution term suggested above is not
a valid Q-term. This is easily corrected, however, by restricting the first r arguments of
this substitution term to not be functionally dependent on the abstracted variables. In
particular, the correct substitution term would be

*w1 : : : *wp (kH1 : : : Hr(Hr+1w1 : : : wp) : : : (Hqw1 : : : wp)):
Since we have assumed that the terms in unification problems are Q-terms themselves,
r ^ q and this term is sensible.

In either case, the displayed term is called the imitation term for the given disagreement
pair. We shall require that the free variables H1; : : : ; Hq do not appear in the given
unification problem's prefix. Notice that an imitation term is unique up to the choice of
these free variables and the bound variables w1; : : : ; wp.

Finally, we need to consider the projection scheme for matching a flexible head to a
rigid head. In this case, we only try to rearrange the flexible term so that one of its
arguments is moved into the head position. In particular, consider all the terms of the
same type as f that are of the form

*w1 : : : *wp (wi(H1w1 : : : wp) : : : (Hmw1 : : : wp));
where m * 0, 1 ^ i ^ p, and H1; : : : ; Hm are variables that do not occur in the prefix
of the given unification problem. All such terms are Q-terms and are never of primitive
type. There are, of course, p or fewer such terms, if we do not count differences in the
names of their free and bound variables. Such a term instructs the flexible term to project
its ith argument to its head and to give it any additional arguments (the m arguments
in the term above) it might need for the entire term to be the same type of function as
f . A projection term for the given flexible-rigid disagreement pair is any of these terms.

Notice that all of the substitution terms above are designed to be functionally dependent on all p arguments of the flexible term. Such terms need not be functional on all
such arguments, but if j-conversion is available, then we only need to consider the terms
built here. If j-conversion is not available, as in the first part of (Huet, 1975), then more
imitation and projection terms need to be considered.

Definition 7.8. Let P be a unification problem with prefix Q = Q19o/ f Q2 and with a
flexible-rigid disagreement pair f t1 : : : tp = ks1 : : : sq. We shall write imit(f; o/; k; Q) to
be either the empty set if k is bound to the right of f or the set fQ19H1 : : : 9Hqtg where
t is the imitation term described above. Similarly, we write proj(f; o/; Q) to be the set of
all projection terms generated above for type o/ with the appropriate prefix added. Finally,
we define match(f; o/; k; Q) = imit(f; o/; k; Q) [ proj(f; o/; Q). Any term in this set is a
match term for the disagreement pair f t1 : : : tp = ks1 : : : sq. The values of imit, proj,
and match are unique up to alphabetic changes of bound variables. The argument Q is
used during building the imitation term to determine the rank of k and whether or not
k is to the right or left of f . It is also used to constrain the picking of the variables
H1; : : : ; Hn since these cannot appear in Q.

Example 7.9. Let i and a be primitive types. Let Q be 8k81l9F 8j where the variables
k; j all have type i ! i and l has the type i ! i ! i ! i. The following are some values of
imit. (The prefixes for the various match terms presented below are suppressed: they are

22 D. Miller
all of the form 8k81l9H1 : : : 9Hi where i * 0 is the number of new existential variables
free in the term.)

imit(F; i; k; Q) = fkH1g
imit(F; i ! i; k; Q) = f*w(k(H1w))g
imit(F; i ! a; k; Q) = fg

imit(F; i ! i; j; Q) = fg
imit(F; (i ! i) ! i ! i; l; Q) = f*w1*w2(lH1(H2w1w2)(H3w1w2))g

In this last imitation term, the types of w1 and w2 are i ! i and i, while the types of
H1; H2, and H3 are i; (i ! i) ! i ! i and (i ! i) ! i ! i, respectively. Below are some
values of proj.

proj(F; i ! i ! a; Q) = fg

proj(F; i ! i; Q) = f*w wg
proj(F; i ! i ! i; Q) = f*w1*w2 w1; *w1*w2 w2g
proj(F; (i ! i) ! i ! i; Q) = f*w1*w2 (w1(H1w1w2)); *w1*w2 w2g

In order to facilitate a completeness proof for this unification rewriting process, we
define the following complexity measures on terms and substitutions.

Definition 7.10. Let t be a fi-normal term. Let jtj denote the number of occurrences of
applications in t. That is,

j*x1 : : : *xn(ht1 : : : tm)j = m +

mX

i=1

jtij (n; m * 0).

Let oe be the substitution f(w1; t1); : : : ; (wn; tn)g where n * 0. Then joej is defined as

joej = n +

nX

i=1

jtij:

The following proposition is critical for establishing a completeness theorem later.
Proposition 7.11. Let P be a simplified unification problem that has solution oe. Also
assume that the prefix Q of P is of the form Q19o/ F Q2 and that P contains a flexiblerigid disagreement pair with F as the flexible head and k as the rigid head. Then there
exists a unique prefixed term Q19H1 : : : 9Hns in match(F; o/; k; Q) (n * 0) and a unique
Q19H1 : : : 9Hn-substitution ae with domain fH1; : : : ; Hng such that

(1) oeF fi-converts to aes.
Furthermore, let oe0 be the substitution ae [ (oe \Gamma  f(F; oeF )g). Then
(2) oe = [F 7! s] ffi oe0,
(3) oe0 is a solution to the unification problem [F 7! s]P , and
(4) joe0j ! joej.

Proof. Let t be the fi-normal form of oeF . Then t is of the form *w1 : : : *wn(ct1 : : : tm)
for some variables c; w1; : : : ; wn and terms t1; : : : ; tm (n; m * 0). Since t is Q-closed for F ,

Unification Under a Mixed Prefix 23
the variable c must be either universally bound in Q or a member of the list w1; : : : ; wm. In
the first case, the head of the flexible term will become c. Since the unification problem P
has a solution, c must be k. Let s be the imitation term for this flexible-rigid pair. If c is a
member of the list w1; : : : ; wm, then by the construction of match terms, there is a unique
term, say s 2 match(F; o/; k; Q), which projects the same member of the binder to its head.
In either case, let H1; : : : ; Hp be the new free variables of s, listed in the left-to-right order
they appear in s (p * 0). If we define ae = f(Hi; *w1 : : : *wmti) j i = 1; : : : pg, we see that
t is fi-convertible to aes (hence, showing (1) above). Notice also that jtj = m + Pmi=1 jtij.
Let oe0 be as defined in the theorem. Then (2) obviously holds. Since ([f 7! s] ffi oe0)P is
equal to the prefixed term oeP , oe0 is a solution to [x 7! s]P (showing (3)). Finally,

joe0j = joej \Gamma  jtj +

mX

i=1

jtij \Gamma  1 + m

which simplifies to joe0j = joej \Gamma  1 (conclusion (4) above). 2
Definition 7.12. A unification problem containing either no equations or only flexibleflexible equations is called a flexible-flexible unification problem.

In Section 8, we consider the general problem of determining when flexible-flexible
problems have solutions. Consider the following example of a flexible-flexible unification
problem that does not have a solution.

Example 7.13. Let a; b, and c be primitive types. Consider the following flexible-flexible
unification problem:

8a!by9a!bF 8c!bz9c!bG8au8cv [F u

b= Gv]:

Although all existentials in this prefix are nonempty, this unification problem has no
solution.

We can now organize the two rewriting rules of simplification and substitution with
matching terms into a search process for flexible-flexible unification problems. Such a
search is often referred to as pre-unification.

Definition 7.14. Let P and P 0 be unification problems. We shall write P F!s P 0 if all
the following conditions are true.

(1) P is in simplified form,
(2) F is an existentially quantified in P ,
(3) there is a flexible-rigid pair in P in which the flexible term has F as its head,
(4) s is a matching term for this pair, and finally,
(5) P 0 is the simplified form of [F 7! s]P .

These rewriting rules can be used to nondeterministically decompose unification problems with solutions to flexible-flexible unification problems with solutions.

24 D. Miller
Proposition 7.15. Let P be a simplified unification problem. P has a solution oe if and
only if there exists a sequence of rewrite steps

P F1!s

1 : : :

Fn!

sn P

0 (n * 0)

where P 0 is a flexible-flexible problem with solution ae and oe = [F1 7! s1]ffi\Delta  \Delta  \Delta ffi[Fn 7! sn]ffiae.
Proof. Let P be a simplified unification problem. If a sequence of unification problems
as above carries P to a flexible-flexible problem with solution ae, then by induction and
Propositions 7.4 and 7.7, P has the solution oe, defined in the theorem. Assume the
converse, however, that P has a solution, say oe. Then a sequence of such rewriting
steps must exist and its length is bounded by joej. The following simple nondeterministic
procedure will construct such a sequence. Let oe1 be oe, let P1 be P , and pick any flexiblerigid pair in P . Let F1 be the head of the flexible term. By Proposition 7.11, this pair
determines a nonempty set of matching terms that contains a unique term s1 such that
[F1 7! s1]P has a solution oe2 where joe2j ! joej and oe = [F1 7! s1] ffi oe2. Let P2 be a
simplified form of [F1 7! s1]P . If P2 is a flexible-flexible problem, then we are finished.
Otherwise, we repeat this selection of a flexible-rigid pair and a match term again on this
new unification problem. This process must terminate since each subsequent call to the
unification process will reduce the complexity of a solution the unification problem. 2

N.B. In the rest of this paper, we shall assume that unification problems will not contain
universal quantifiers of positive rank. This assumption is taken to simplify the presentation of various different technical definitions in the following sections. While most of these
definitions can be generalized to handle positively ranked universal quantifiers, doing so
complicates those definitions without adding to their content.

8. Solving Flexible-Flexible Problems
Flexible-flexible unification problems are considered "reduced" in the sense that the
principal invariant used in Section 7, that rigid terms preserve their heads under substitution, is not useful when examining flexible-flexible unification problems. We now
show that deciding whether or not a flexible-flexible unification problem has a solution
is undecidable. For the next three lemmas and one theorem, let i be a primitive type.
Proofs for the lemmas are straightforward and not given.

Lemma 8.1. Let t be a closed fi-normal term of type (i ! i) ! i ! i. Then t is jconvertible to a term of the form *f*x:f nx for some n * 0.

Closed *-terms of type (i ! i) ! i ! i are called Church numerals. For n * 0, we
write ^n to denote the nth Church numeral, that is, the term *f *x:f nx. For example,^
0 = *f *x:x, ^1 = *f*x:f x, and ^2 = *f *x:f(f x).

Lemma 8.2. The flexible-flexible unification problem

9(i!i)!i!iN 8i!if 8ix[N f (N f x)

i= (N f (f x))]

has the unique solution f(N; ^1)g.

Unification Under a Mixed Prefix 25
Lemma 8.3. Let the existential quantifiers below associate type (i ! i) ! i ! i to their
bound variables. The flexible-flexible unification problem

9M 9N 9P 8i!if 8ix[(N f )(M f )x

i= P f x]

has solution f(N; r); (M; s); (P; t)g if and only if for some n; m * 0, r is ^n, s is ^m, and
t is dn + m. The flexible-flexible unification problem

9M 9N 9P 8i!if 8ix[N (M f )x

i= P f x]

has solution f(N; r); (M; s); (P; t)g if and only if for some n; m * 0, r is ^n, s is ^m, and
t is dn \Theta  m.

The outline of the following proof is suggested by the main proof in (Goldfarb, 1981).
Theorem 8.4. The problem of determining if a given flexible-flexible unification problem
has a solution is recursively undecidable.

Proof. Using the preceding three lemmas, it is simple to encode any finite set of equation of the form x = 1; x+y = z, and x\Theta y = z into a flexible-flexible unification problem
such that the unification problem has a solution if and only if the set of equations has an
interpretation of its variables over nonnegative integers such that all the equations are
true. In this encoding, each variable in an equation would correspond to an existential
variable of type (i ! i) ! i ! i, and each equation would correspond to a flexible-flexible
disagreement pair. Since the problem of determining if such a set of equations can be
solved over the nonnegative integers is recursively unsolvable (Hilbert's Tenth Problem),
the problem of determining if flexible-flexible unification problems have solutions is recursively unsolvable. Notice that the unification problems needed for this encoding are
only second-order; that is, the highest order of any variables in these prefixes is 2. 2

There are many flexible-flexible unification problems for which it is easy to compute a
solution. The following proposition describes such a collection of flexible-flexible unification problems.

Proposition 8.5. Let P be a flexible-flexible unification problem with prefix Q. Let E
be the set of existential variables of Q, and let ss0 be the relation on E such that x ss0 y
if and only if x and y are the heads of a common disagreement pair of P . Let ss be the
equivalence closure of ss0. Let E be some ss-equivalence class, let o/ be the common target
type of the variables in E, and let Q0 be the prefix to the left of the leftmost variable in E.
Call the set E solvable if there is a Q0-term of type o/ . Finally, if all equivalence classes
of E are solvable, then P has a solution.

Proof. The following proof is a simple extension of a proof given in (Huet, 1975). Let
E be an equivalence class of existential variables of the prefix Q, let o/ be their common
target type, let Q0 be the prefix to the left of the leftmost variable in E, and let t be a
Q0-term of type o/ . For each variable x in E substitute the *-term *w1 : : : *wn:t, where n
is the unique nonnegative integer needed to make this term the same type as x and the
variables w1; : : : ; wn are not free in t. In this way, a substitution for all the existential
variables of Q can be built. It is immediate that this substitution is a solution for P . 2

26 D. Miller

In the event that a unification problem has a 89-prefix, then the above proposition
reduces to simply checking if each of the primitive types labeling equations in the unification problem are nonempty with respect to the purely universal part of the prefix.

When flexible-flexible unification problems have solutions, computing all solution can
be difficult. Although Proposition 8.5 can be used occasionally to produce some solutions
to some flexible-flexible unification problems, it provides no information on the nature
of other solutions available. Such unification problems may have an infinite number of
incomparable solutions and no nonredundant enumeration of a complete set of solutions
for general flexible-flexible unification problem is possible (Huet, 1975).

9. Some Unsolvable Unification Problems
We now identify some classes of unification problems that have no solutions.

Definition 9.1. A simple failure problem is a simplified unification problem containing
a disagreement pair that is either (i) rigid-rigid (thus, its terms have different heads), or
(ii) flexible-rigid and the set of matching terms for this pair is empty.

Theorem 9.2. If P is a simple failure node then it has no solutions.
Proof. Let P be a simple failure unification problem. There are two cases to consider.
If P contains a rigid-rigid disagreement pair with different heads, then no substitution
into these terms can make them equal and P can have no solution. From Proposition
7.11 it follows that if P has a solution, every flexible-rigid disagreement pair in P must
have a nonempty set of match terms. Thus, if P contains a flexible-rigid pair that has
an empty set of match terms, P could not have a solution. 2

The analysis required to recognize simple failure unification problems is inexpensive:
only the surface structure of the terms involved need to be examined. The remaining
failure cases presented in this section are more costly to determine. The following two
definitions generally require the examination of much of a term's structure.

Definition 9.3. Let Qt be a prefixed formula. The binary relation !!0 on prefixed terms
is defined by the following two rules. First, Q*xt !!0 Q8xt, provided x is not a member
of the prefix Q (otherwise change the name of x before moving it to the prefix). Second,
Q(ht1 : : : tn) !!0 Qti provided h is a universally quantified variable in Q and 1 ^ i ^ n.
Let !! be the transitive closure of !!0. A variable w of Q is said to have a permanent
occurrence in Qt if Qt !! Q0(wt1 : : : tn) for some prefix Q0, n * 0, and some terms
t1; : : : ; tn.

The proof of the following proposition is done by a simple induction on the structure
of terms: the proof is omitted.

Proposition 9.4. Let t be a fi-normal Q-term and let y be a universally quantified
variable of Q that has a permanent occurrence in Qt. If oe is a Q-substitution, then y
has a permanent occurrence in oeQt. If s is Q-free for f in Q, then y has a permanent
occurrence in [f 7! s]Qt.

Unification Under a Mixed Prefix 27
Definition 9.5. Let t be a fi-normal Q-term. A universally bound variable y of Q possibly occurs in Qt if y occurs free in t or y is to the left of some existential variable of
Q that occurs free in t.

The following proposition justifies this use of terminology.
Proposition 9.6. Let P be a unification problem with prefix Q and a disagreement pair
t = u. If there exists a universally quantified variable y in Q that does not have a possible
occurrence in t but does have a permanent occurrence in u, then P has no solution.

Proof. Assume that oe is a solution for P . By Proposition 9.4, y has an occurrence in
oeu. Since y does not occur in t and since the existential variables free in t are on the left
of y, oet does not contain an occurrence of y. Hence, oet and oeu are not equal and this
contradicts the assumption that oe is a solution to P . 2

Example 9.7. The unification problem

8i!iy9(i!i)!iH8i!ix[x(Hx)

i= Hy]

has no solution since x has a permanent occurrence in x(Hx) while it has no possible
occurrence in Hy.

Below we present a different class of unsolvable unification problems. They can be
recognized as such by noticing how a simple strategy of applying matching terms would
produce a cyclic pattern in the search for a solution.

Definition 9.8. Let prefix Q be of the form Q19xQ2. Consider an equation of the form
xs1 : : : sn = t where n * 0 and for every i = 1; : : : ; n, Qsi has a head that is bound
universally in Q2. Let Y be the set of heads of the terms s1; : : : ; sn. Finally, assume that
x has a permanent occurrence in t witnessed by the sequence of prefixed terms

Qt = Q1t1 !!0 : : : !!0 Qmtm = Q0(xe1 : : : en) (m * 2);
where for all i = 1; : : : ; m \Gamma  1; the head of ti is not in the set Y . Such an equation is a
simple divergent equation.

The following is a generalization of the occurrence-check found with in first-order
unification.

Proposition 9.9. If P is a unification problem with a simple divergent disagreement
pair, P has no solution.

Proof. We shall show that if P is a unification problem with a simple divergent disagreement pair and with a solution, say oe, then there is another unification problem P 0
with a simple divergent disagreement pair and a solution oe0 where joe0j ! joej. From this,
a contradiction quickly follows: if n = joej, use the above argument n + 1 times to reach
the conclusion that there is some unification problem whose solution has negative size.

Thus, let P contain a simple divergent disagreement pair xs1 : : : sn = t, and let Y be
as defined in Definition 9.8. Let t be kt1 : : : tp where p * 1 and let j 2 f1; : : : ; ng be
such that x has a permanent occurrence in the term tj satisfying the same condition

28 D. Miller
regarding the set Y . By assumption, k =2 Y . Since P has a solution, there is a match
term s for this equation such that P x!s P 0 where P 0 has a solution oe0 with joe0j ! joej and

oe = [x 7! s] ffi oe0. If s is a projection term, then P 0 contains a rigid-rigid disagreement
pair whose heads are k and the head of si for some i = 1; : : : ; m. Such a P 0 is a simple
failure problem since these heads are different: if k is in Q1 then k cannot equal the head
of si by assumption on si, and if k is in Q2, then k cannot be equal to the head of si
since it is a member of Y .

Thus s must be the imitation term and k is bound in Q1. Let the imitation term, s,
be written as

*y1 : : : *yn(k(H1y1 : : : yn) : : : (Hpy1 : : : yn)):

Thus, P 0 contains the fi-normal form of the equation Hjs1 : : : sn = [s=x]tj. Since tj
contained a permanent occurrence of x and the head of s is a universal variable not in
Y , this pair is then a simple divergent disagreement pair. This completes the proof. 2

Example 9.10. Consider the unification problem

8i!ia9i!iX8iu[Xu

i= a(Xu)]:

Since X occurs permanently in a(Xu) and that occurrence is not under u, this unification
problem has no solution. Another way to see this is to notice that the imitation term for
the disagreement pair in this unification problem is *w :a(Hw) for a new variable H
of the same type as X. Substituting this into the unification problem yields the problem
8a9H8u[Hu

i= a(Hu)], which is simply an alphabetic variant of the original problem.

Since this problem cannot be rewritten into a flexible-flexible problem, Proposition 9.1
implies that this problem has no solution.

On the other hand, consider the following unification problem taken from (Huet, 1975):

8ia9(i!i)!iX8i!iu[Xu

i= (u(X(*v v)))]:

Although X occurs rigidly in u(X(*v v)), this theorem does not apply to this problem
since X occurs under u. This unification problem actually does give rise to a flexibleflexible problem since substituting the projection term *w(w(Hw)) for X and simplifying
yields 8a9H8u[Hu = H(*v v)]. This has the solution, f(H; *z a)g, and the original
problem has the solution f(X; *w(wa)g.

To see why Proposition 9.9 provides a generalization of the occurrence-check in firstorder unification, assume that the equation x = s is first-order, x is different than s, and
that x occurs in s. Thus, x has a permanent occurrence in s and the restriction on the
permanent occurrence is vacuously true. As the proposition concludes, there is no unifier
for any unification problem containing this equation.

10. Factors of Unification Problems
In this section, we will capitalize on the fact that occasionally there are unification
problems whose solutions all share certain features. Recognizing such cases and features
permits a search strategy to commit to a particular approach to constructing an initial
portion of a solution without needing to consider backtracking. The common structure
of solutions, when they exist, will be called factors.

Unification Under a Mixed Prefix 29
Definition 10.1. Let P be a unification problem with prefix Q. Let P0 be P and Q0 be
Q. A list of quadruples

(f1; s1; Q1; P1); : : : ; (fn; sn; Qn; Pn) (n * 1)
is called a cascading substitution for P if for i = 1; : : : ; n, the term si is Qi\Gamma 1-free for
the variable fi and Pi is the simplified unification problem [fi 7! si]Pi\Gamma 1 and Qi is the
prefix of Pi. We shall denote by [f1 7! s1] ffi \Delta  \Delta  \Delta  ffi [fn 7! sn] the function that carries Qnsubstitutions oe to the Q-substitution [f1 7! s1] ffi \Delta  \Delta  \Delta  ffi [fn 7! sn] ffi oe. We shall frequently
refer to just the expression [f1 7! s1] ffi \Delta  \Delta  \Delta  ffi [fn 7! sn] as a cascading substitution.
The syntactic variable  will be used to denote cascading substitutions. If 0 denotes
the above cascading substitution and if 00 denotes a cascading substitution for Pn, then
their composition, written as 0 ffi 00, is the concatenation of their list of quadruples. The
interpretation of 0 ffi00 as a mapping on substitutions is given by composing the meaning
of the interpretation of both 0 and 00.

Definition 10.2. Let P be a unification problem. We say that a cascading substitution
[f1 7! s1] ffi \Delta  \Delta  \Delta  ffi [fn 7! sn] for P is a factor of P if for every solution oe of P there is a
solution oe0 for [fn 7! sn](\Delta  \Delta  \Delta  ([f1 7! s1]P ) \Delta  \Delta  \Delta ) such that oe = [f1 7! s1]ffi\Delta  \Delta  \Delta ffi[fn 7! sn]ffioe0.
This factor is a proper factor if whenever oe and oe0 exist as above, joe0j ! joej. Otherwise,
it is improper.

Notice that if P is an unsolvable unification problem, then every cascading substitution
for P is a factor for P .

Example 10.3. It is possible for an improper factor  to increase the size of a substitution; that is, for oe =  ffi oe0 and joe0j ? joej to hold. The unification problem 8ac9aF:F

a= c

has the single solution f(F; c)g. It also has the factor [F 7! (H1H2)] where

8ac9a!aH19aH2 (H1H2)
is 8ac9aF -free for F . Now

f(F; c)g = [F 7! (H1H2)] ffi f(H1; *w:w); (H2; c)g
but jf(H1; *w:w); (H2; c)gj = 2 and jf(F; c)gj = 1.

Without exception, we shall be interested only in improper factors that keep the size of
solutions constant. Such improper factors always exist for unification problems containing existential quantifiers in their prefix. For example, let x be existentially bound with
type o/1 ! : : : ! o/n ! o/0 where n * 0. If ss is a permutation of f1; : : : ; ng, the substitution [x 7! *w1 : : : *wn:Hwss1 : : : wssn] is an improper factor. This is a kind of renaming
operation: x is renamed to H with the possibilities that its arguments are permuted.
We shall find improper factor useful since it is possible that applying such a factor to a
unification problem yields a problem that is syntactically simplier although its solutions
are not "smaller".

Proposition 10.4. Let 0 be a factor of P and let 00 be a factor of 0P . Then 0 ffi 00
is a factor of P . Furthermore, if both 0 and 00 are proper factors then so is 0 ffi 00.

Proof. Let oe be a solution to P . Then there is a oe0 such that oe0 solves 0P and
oe = 0 ffi oe0. Since 00 is a factor of 0P , then there exists a solution oe00 of 00(0P ) such

30 D. Miller
that oe0 = 00 ffi oe00. Thus, oe = (0 ffi 00) ffi oe00 and oe00 solves (0 ffi 00)P . Hence, (0 ffi 00) is
a factor. If 0 and 00 are proper, then joe0j ! joej and joe00j ! joe0j, so joe00j ! joej and 0 ffi 00
is proper. 2

The following proposition shows that factors identified for a subset of the equations in
a unification problem are factors for the full unification problem.

Proposition 10.5. Let P and P 0 be two unification problems with the same prefixes
and be such that the disagreement pairs of P are all contained in P 0. It follows that any
factor of P must be a factor of P 0.

Proof. Let  be a factor of P and let oe be a solution of P 0. Thus, oe is a solution of P
and oe =  ffi oe0 for some oe0 where oe0 is a solution to P . Thus, oe0 is also a solution to
P 0. 2

We shall now present four different classes of factors: the first two classes are proper
and are presented in Propositions 10.6 and 10.8. The third and fourth classes, presented
in the next section, are improper factors that can be used to prune existential variables
of functional types; that is, such variables are replaced with existential variables of fewer
arguments. The first class of proper factors is provided as an immediate corollary of
Proposition 7.11.

Proposition 10.6. Let P be a unification problem that contains a flexible-rigid pair with
x as the flexible head. If the set of match terms for this disagreement pair is a singleton
set, say fsg, then [x 7! s] is a proper factor of P .

The second class of proper factors arises by generalizing on the usual definition of
variable-term disagreement pairs found in first-order unification.

Definition 10.7. Let P be a unification problem with prefix Q. A variable defining
disagreement pair is a pair of the form xy1 : : : yn = t where n * 0, x is an existentially
quantified in Q and does not occur free in t, the variables y1; : : : ; yn are distinct and
universally quantified to the right of x, and *y1 : : : *ynt is Q-free for x.

Notice that a variable defining disagreement pair could be flexible-rigid as well as
flexible-flexible.

Proposition 10.8. Let P be unification problem with the variable defining disagreement
pair xy1 : : : yn = t. The substitution [x 7! *y1 : : : *ynt] is a proper factor of P .

Proof. Let oe be a solution for P . Let s be oex and let oe0 := oe=f(x; s)g. Using fi and
j-conversion, we can assume that s is of the form *y1 : : : *yns0, where s0 is fij-convertible
to oet which is also equal to oe0t since x is not free in t. Hence, [x 7! *y1 : : : *ynt] ffi oe0 =
f(x; *y1 : : : *ynoe0t)g[oe0 = oe. Thus, [x 7! *y1 : : : *ynt] is a factor that is also proper since
joe0j = joej \Gamma  1 \Gamma  jsj. 2

Example 10.9. Consider the equation

*y1 : : : *yn:Xyss1 : : : yssn = t

Unification Under a Mixed Prefix 31
where ss is a permutation of f1; : : : ; ng, none of the variables X; y1; : : : ; yn are free in t,
and the prefix to this equation is of the form 89. Then the substitution

[X 7! *yss1 : : : *yssn:ty1 : : : yn]
is a factor.

The substitution provided in the above proposition is the first instance of a substitution
that replaces an existential variable with a term that may contain another existential
variable in the current unification problem. In all other substitutions so far, substitution
terms contained either universal variables or new existential variables.

11. Pruning Unification Problems
We now consider two classes of improper factors we collectively call pruning factors. In
each case, an existential variable, say x, of functional type is replaced by a new existential
variable, say h, of one fewer arguments. This is done using the substitution

 = [x 7! *w1 : : : *wn(hw1 : : : wi\Gamma 1wi+1 : : : wn)]
where n * 0 and 1 * i * n. If  is a factor, then it must be an improper factor:
let oe and oe0 be substitutions such that oe =  ffi oe0. There must be some term u and
some substitution oe00 that contains neither x nor h in its domain and is such that oe is
f(x; *w1 : : : *wn u)g [ oe00 and oe0 is f(h; *w1 : : : *wi\Gamma 1*wi+1 : : : *wn u)g [ oe00. Since the
only difference in these substitutions is in the number of abstractions in substitution
terms, and since these are not counted by j j, joej = joe0j.

Proposition 11.1. Let P be a unification problem with a disagreement pair xt1 : : : tn =
s, where x is existentially bound with type o/1 ! \Delta  \Delta  \Delta  ! o/n ! o/0 and where o/0; : : : ; o/n are
primitive types. If there is a universal variable y that has a permanent occurrence in ti,
for some i = 1; : : : ; n, and that does not have a possible occurrence in s, then

 = [x 7! *w1 : : : *wn(hw1 : : : wi\Gamma 1wi+1 : : : wn)]
is an improper factor for P .

Proof. Let xt1 : : : tn = s be as in the theorem, with the universal variable y occurring
permanently in ti but not having a possible occurrence in s. Let oe be a solution for P .
Since oes cannot contain y free, y cannot be free in oe(xt1 : : : tn). Since y occurs permanently in ti, it also occurs permanently in oeti. Now oex is j-convertible to a *-term of the
form *w1 : : : *wn u where the abstracted variables are of primitive type. If wi is free in
u then oe(xt1 : : : tn) would contain oeti as a subterm and y would be free in oe(xt1 : : : tn),
which is not possible. Thus, oe =  ffi oe0 where oe0 is

f(h; *w1 : : : *wi\Gamma 1*wi+1 : : : *wn u)g [ f(v; oe(v)) j v 2 dom(oe) and v 6= xg:
Hence,  is a factor. By the discussion above, it must be an improper factor. 2

Example 11.2. The unification problem

9i!iF 9i!iG8ix8iy[F x

i= Gy]

has [F 7! *w H1] as a pruning substitution. A pruned form of this unification problem
is therefore 9H19G8x8y[H1 = Gy]. This has [G 7! *w H2] as a pruning substitution.

32 D. Miller
A pruned form of this problem is then 9H19H28x8y[H1 = H2]. Thus, the compound
substitution, [F 7! *w H1] ffi [G 7! *w H2] is a factor of the original unification problem.

For another example, consider the unification problem

8i!i!ic9i!i!i9i!i!iG8ix8iy[G(cxy)(cyy)

i= F yy]:

This problem has a pruning substitution, namely [G 7! *w1*w2(Hw2)]. The resulting
unification problem is the simpler 8c9F 9H8x8y[H(cyy) = F yy].

The restriction on the type of the variable being prune is necessary as the unification
problem

8ia9(i!i)!i!iX8iy[X(*z:a)y

i= a]

shows. Here, y has a permanent occurrence in the second argument of X while it does not
have a possible occurrence in the term a. It is not the case, however, that the substitution
[X 7! *w1*w2(Hw1)] is a factor for this unification. In particular, the solution [X 7!
*z1*z2(z1z2)] is not in the image of that substitution.

The type information in a prefix can be used to suggest pruning substitutions. For
example, consider the prefix Q19ffi!o/ f Q2. A solution for a unification problem with this
prefix must provide f with a term of type ffi ! o/ whose free variables are all universally
quantified in Q1. As describe in Section 3, it is possible to use the type information in
Q1 to determine if there is a term of type ffi ! o/ . This same type information can be
used to determine more about the possible substitution terms for f . For example, it is
possible to determine whether there is a term, say *x:t, of type ffi ! o/ in which x is free
in t. If such a term does not exist, then the pruning substitution [f 7! *w:h] is a factor.

In order to determine this structural property given the type information in a prefix,
we modify the proof system in Definition 3.5 to enforce that a particular hypothesis is
used in a proof.

Definition 11.3. Let \Delta  be a finite set of types including the type ffi. The relation \Delta  `ffiI o/ ,
for type o/ , is defined by the following clauses.

(1) \Delta  `ffiI ffi.
(2) \Delta  `ffiI o/1 ! o/2 if fo/1g [ \Delta  `ffiI o/2.
(3) \Delta  `ffiI o/ if ffi is ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ and \Delta  `I ffi1; : : : ; \Delta  `I ffin (n * 0).
(4) \Delta  `ffiI o/ if ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ 2 \Delta  and \Delta  `I ffi1; : : : ; \Delta  `I ffin and for some

i = 1; : : : ; n, \Delta  `ffiI ffii (n * 1).

Proposition 11.4. The relationship \Delta  `ffiI o/ is decidable.
Proof. Provability of \Delta  `ffiI o/ can only depend on the provability of statements of the
form \Delta 0 `ffiI o/ 0 or \Delta 0 `I o/ 0 where o/ 0 is a subexpression of some type in fo/; ffig [ \Delta  and \Delta 0
is some finite set of similar types. In particular, there are only a finite number of such
values for \Delta 0 and o/ 0, so the length of any proof for \Delta  `ffiI o/ can be bounded prior to
looking for a proof. 2

Proposition 11.5. Let \Delta  be the set of types for quantified variables in the prefix Q.
There is a fi-normal Q-term *x:t of type ffi ! o/ such that x is free in t if and only if
\Delta  `ffiI o/ .

Unification Under a Mixed Prefix 33
Proof. Assume that \Delta  `ffiI o/ . We show by induction on the length of a proof of this
fact that if Q8ffix is a prefix whose quantifiers are typed by types in \Delta , then there is a
Q8ffix-term of type o/ that contains x free. If ffi is o/ then the required term is simply x.
Assume that o/ is o/1 ! o/2 and that fo/1g [ \Delta  `ffiI o/2. By the inductive hypothesis, there
is a Q8o/1y8ffix-term t0 of type o/2 such that x is free in t0. Thus, *y:t0 is the required
Q8ffix-term of type o/ which contains x free. Assume that ffi is ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ and
that \Delta  `I ffi1; : : : ; \Delta  `I ffin (n * 0). By Proposition 3.6, there are Q8ffix-terms, ti, of type
ffii for i = 1; : : : ; n. Thus, (xt1 : : : tn) is the required Q8ffix-term of type o/ which contains x
free. Finally, assume that ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ 2 \Delta  and \Delta  `I ffi1; : : : ; \Delta  `I ffin and for some
i = 1; : : : ; n, \Delta  `ffiI ffii (n * 0). Again, there are Q8ffix-terms, ti, of type ffii for i = 1; : : : ; n,
one of which contains x free. Thus, if c is bound in Q8ffix at type ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/
then (ct1 : : : tn) is the required Q8ffix-term of type o/ which contains x free.

Let *x:t be a fi-normal Q-term of type ffi ! o/ such that x is free in t. We show by
induction on the structure of t that if \Delta  is the set of types in Q, then \Delta  `ffiI o/ . If t is
a variable, then t is x, and we have \Delta  `ffiI ffi by rule (1). If t is *y:t0, then y is different
from x and o/ is o/1 ! o/2. Thus *x:t0 is a fi-normal Q8o/1y-term of type ffi ! o/2. The
inductive hypothesis, fo/1g [ \Delta  `ffiI o/2, and rule (2) completes this case. Finally, assume
that t is of the form (ct1 : : : tn) for c a variable and for some n ? 0. We now have two
cases: either c is x or x appears free in ti for some i = 1; : : : ; n. In the first case, ffi is of
the form ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ where ti is a Q-term of type ffii. By Proposition 3.6 and rule
(3), the conclusion follows. Finally, assume that c is not x. Thus x is free in ti for some
i = 1; : : : ; n and c is quantified in Q with type ffi1 ! \Delta  \Delta  \Delta  ! ffin ! o/ , and the type of ti
is ffii. This case is completed by the inductive hypothesis, Proposition 3.6, and rule (4)
above. 2

The following Proposition is now an immediate consequence.
Proposition 11.6. Let P be a unification problem with prefix Q19ffi!o/ f Q2 and let \Delta  be
the set of types that include ffi and all the types of quantified variables in Q1. If \Delta  `ffiI o/
is not provable then [f 7! *w:H] is a factor for P , where H is a variable not in Q.

Example 11.7. Let list; int; bool, and bt be four primitive types. Let Q be the prefix that
contains universal quantifiers for the following pairs of variables and types:

true, bool f alse, bool
zero, int succ, int ! int
node, int ! bt ! bt ! bt leaf, int ! bt
sign, int ! bool nil, list
bcons, bool ! list ! list icons, int ! list ! list

Notice that all primitive types and all types built using these primitive types are nonempty.
Let \Delta  be the set of types displayed above. The chart below describes when the relation
\Delta  `ffiI o/ holds given that o/ and ffi range over the primitive types above. There is a "Y " in
the row ffi and column o/ if \Delta  `ffiI o/ can be proved; otherwise there is an "N ".

list int bool bt
list Y N N N
int Y Y Y Y
bool Y N Y N
bt N N N Y

34 D. Miller
Thus, if a unification problem has the prefix Q9f Q0 where the type for f is list ! int !
bool ! bt, this chart can be used to infer that [f 7! *w1*w2*w3:hw2] is a factor.

12. A Subcase of Unification
As an illustration of using some of the technical devices defined in the previous sections,
we investigate a class of unification problems in which the search for a pre-unifier give rise
to no important choices. That is, if such unification problems have solutions, they have
factors that rewrite them into flexible-flexible unification problems. This class contains
all first-order unification problems: factors of such problems correspond to most general
unifiers. It also contains the class of raised first-order unification problems described in
Section 6.

In this section we shall assume that prefixes are restricted to have low orders. In
particular, prefixes are restricted so that the type of existentially quantified variables
are of order 1 or 0 and universally quantified variables to the right of some existential
variable are of primitive type.

Definition 12.1. A fi-normal prefixed term Qt of type o/ is an argument-restricted term
if the order of o/ is 0 or 1 and every subterm of t of the form xt1 : : : tn (n * 0) where
x is existentially quantified in Q is such that the terms t1; : : : ; tn have as heads distinct
variables that are either universally quantified in Q to the right of x or are internally
*-abstracted variables. A unification problem is argument-restricted if it is argumentrestricted as a prefixed term.

Notice that any unification problem comprised of only first-order terms is trivially an
argument-restricted unification problem. This set of unification problems also has useful
closure properties.

Proposition 12.2. Let P be an argument-restricted unification problem. Let P 0 be the
result of Skolemizing, raising, simplifying, pruning, or applying match terms to P . Then
P 0 is argument-restricted.

Proof. If P 0 results from Skolemizing P , P 0 is argument-restricted since Skolemization
only introduces new occurrences of existentially quantified variable occurrences which are
not applied to any arguments. Since simplifying does not introduce any occurrences of
existentially quantified variables, the result of simplifying an argument restricted prefixed
term is also argument restricted.

If P 0 results from raising P , then various subterms of P of the form xt1 : : : tn are
replaced with subterms of the form hyt1 : : : tn where y, which is to the left of x in P and
is not at the head of any term in t1; : : : ; tn, is to the right of h in P 0. The heads of the
terms y; t1; : : : ; tn are thus all distinct. Also since y is of primitive type, the type of h is
of order 1.

Since pruning has the effect of tossing out arguments to existentially quantified variables, if P 0 results from pruning P , then P 0 is clearly argument-restricted.

The case of verifying the application of match terms is slightly more involved. Let Qt
be an argument-restricted prefixed term where the prefix is of the form Q19zQ2 and let s
be a match term for z. We show by induction on jtj that the fi-normal form of [z 7! s]Qt
is a variable-restricted prefixed term. Let H1; : : : ; Hm be the free variables of s that are

Unification Under a Mixed Prefix 35
not bound in Q and let Q0 be the prefix Q19H1 : : : 9HmQ2. Thus [z 7! s]Qt is equal to
Q0[s=z]t. If jtj = 0 then t is a variable and [z 7! s]Qt is either Q0t or Q0s. In either case,
the result is argument-restricted.

Now assume that jtj ? 0. Thus, t is of the form *u1 : : : *up(ae1 : : : en) where p * 0,
n ? 0, a is a variable, and the variables u1; : : : ; up are not free in s. Let a0; e01; : : : ; e0n be
the fi-normal forms of [z 7! s]a; [z 7! s]e1; : : : ; [z 7! s]en, respectively. By the inductive
hypothesis, these terms are argument-restricted. If a is a variable other than z, then the
fi-normal form of [z 7! s]Qt is Q0*u1 : : : *up(ae01 : : : e0n), which is argument-restricted. If a
is the variable z then e01; : : : ; e0n all have distinct variable heads that are either universally
quantified in Q to the right of z, are in the set fu1; : : : ; upg, or are bound internally. If s
is the imitation term, which is of the form *w1 : : : *wn k(H1w1 : : : wn) : : : (Hmw1 : : : wn),
then the fi-normal form of [z 7! s]Qt is

Q0*u1 : : : *upk(H1e01 : : : e0n) : : : (Hme01 : : : e0n):
Since the terms e01 : : : e0n all have the necessary distinct heads, the term [z 7! s]Qt
must also be argument-restricted. If s is a projection term then it must have the form
*w1 : : : *wn wi for some i = 1; : : : ; n since the type of z is at most order 1. Thus,
[z 7! s]Qt reduces to Q0*u1 : : : *up:e0i, which is argument-restricted. 2

Example 12.3. The restrictions on the order of types in the definition of argumentrestricted are necessary to achieve closure under the substitution of projection terms. For
example, consider the prefixed term

Q9Y 9X8a8f:Y (*w(f (Xaw)))a;
where Q is some prefix and the types declared for Y; X; a; and f are (i ! i) ! i ! i; i !
i ! i; i; and i ! i, respectively. This prefixed term is not argument-restriction only
because the type of Y is of order 2. Applying the projection term *w1*w2:w1(Hw1w2)
for Y yields the prefixed term

Q9H9X8a8f:f (Xa(H(*w(f (Xaw)))a)));
which is not argument-restricted for the additional reason that the variable X has an
argument that has the existentially quantified variable H as its head.

Our main theorem about this class of unification problems follows from this lemma.
Lemma 12.4. Let P be a simplified, argument-restricted unification problem. If P is
neither a simple failure problem nor a flexible-flexible problem then there exists a proper
factor  such that P is an argument-restricted unification problem.

Proof. Since P is neither a simple failure problem nor a flexible-flexible problem, it
must contain a flexible-rigid pair, say xt1 : : : tn = ks1 : : : sm, with x being the existentially
quantified variable. Since P is not a simple failure, the set of match terms for this equation
is nonempty. Although this set may not be a singleton, at most one substitution term
in this set can lead to a solution. To see this, consider the variable k. If k is universally
bound to the left of x in Q, then the imitation term is the only match term that can
lead to a solution. If k is universally bound to the right of x in Q, then the only possible
match terms leading to a solution are the projection terms. Such projection terms would
move one of the arguments, say ti, into the head position. In this case, the head of ti

36 D. Miller
must be the same as k. By assumption, however, there is exactly one such term ti since
all the terms t1; : : : ; tn have distinct rigid heads. Thus, the projection term that maps
the ith argument of x to the head position must be a factor. In either case, let s be this
distinguished match term. The substitutions [x 7! s] is the desired factor. 2

Theorem 12.5. Let P be an argument-restricted unification problem that is not flexibleflexible. If a solution to P exists, there exists a proper factor  of P such that P is a
flexible-flexible unification problem.

Proof. Let P be a simplified, argument-restricted unification problem with solution oe.
Also assume that P is not flexible-flexible. Hence, P is not a simple failure problem. We
proceed by induction on joej. By Lemma 12.4, P has a proper factor, say , and P is an
argument-restricted unification problem. If P is a flexible-flexible unification problem
then we are finished. Otherwise, P has a solution oe0 such that oe =  ffi oe0 and joe0j ! joej.
By the inductive hypothesis, P has a factor 0 such that 0(P ) is a flexible-flexible
unification problem. The desired proper factor is  ffi 0. 2

The subset of argument-restricted unification problems in which existentially quantified
variables are applied to terms that are distinct variables bound either internally or to the
right of the existential variable is an interesting class of problems. This subset is called
L*-unification in (Miller, 1991b) and appears to be the weakest extension to first-order
unification that treats bound variables via the equations of fij-conversion. Unification in
L* is decidable and most general unifiers exist when unifiers exist. Unlike above where
unification needed to be restricted to essentially second-order, L* is !-ordered.

13. Related Work
For a summary of the early work done on the unification of simply typed *-terms, see
(Huet, 1975). Section 7 is largely a modification of the part of (Huet, 1975) that deals with
unification modulo fij-conversion. Snyder & Gallier (1989) present the material of (Huet,
1975) in terms of transformations on sets of equations and provide new completeness
proofs. Several abstract properties of unification problems are developed in (Statman,
1981). A declarative specification of simply typed *-term unification is given in (Miller,
1991a) using a logic programming language as the vehicle for specifying search and *-term
syntax.

The earliest applications of fij-unification were in automating some aspects of deduction in higher-order logic. Theorem proving procedures that incorporated such unification are described in (Andrews et al., 1984; Huet, 1973b; Jensen & Pietrzykowski, 1976;
Pietrzykowski, 1971; Pietrzykowski & Jensen, 1976). Also, certain problems regarding
the length of proofs can be formulated as unification problems (Farmer, 1984).

A higher-order extension to Horn clauses incorporating fij-unification of simply typed
*-terms is described in (Nadathur, 1987; Nadathur & Miller, 1990) and used as the
foundations for an extension of Prolog, called *Prolog (Nadathur & Miller, 1988). The
Elf logic programming language (Pfenning, 1991) employs fij-unification of dependenttyped *-terms (Elliott, 1989; Pym, 1990).

The unification of simply typed *-terms has occasionally been adopted as a component
of programs that must manipulate logical expressions or other programs. Huet and Lang

Unification Under a Mixed Prefix 37
(1978) demonstrated that second-order matching, a decidable subset of *-term unification, could be used to analysis and transform programs in a natural fashion. Their ideas
were enriched by moving their analysis into *Prolog (Hannan & Miller, 1988; Hannan
& Miller, 1989; Miller & Nadathur, 1987). In the domain of the manipulation of logical
expressions, *-term unification has been used to implement inference rules in the Isabelle
theorem prover (Paulson, 1986; 1989) and in theorem provers written in *Prolog (Felty
& Miller, 1988; Felty, 1989). Elliott and Pfenning (1988) further extended this notion and
refer to the use of *-terms and unification to analyze logical expressions and programs
as higher-order abstract syntax.
Acknowledgements. I am grateful to Peter Andrews, Masami Hagiya, Sunil Issar,
Gopalan Nadathur, Larry Paulson, Frank Pfenning, David Wolfram, and the anonymous
referees for useful comments on an earlier drafts of this paper. This work was supported
in part by the grants ONR N00014-88-K-0633, NSF CCR-87-05596, and DARPA N00014-
85-K-0018, and by a British Science and Engineering Research Council visiting fellowship
research grant.

References
Andrews, P. (1971). Resolution in Type Theory. Journal of Symbolic Logic 36, 414 - 432.
Andrews, P. (1972). General Models and Extensionality. Journal of Symbolic Logic 37, 395 - 397.
Andrews, P., Cohn, E., Miller, D., Pfenning, F. (1984). Automating higher order logic. In Automated

Theorem Proving: After 25 Years, eds. W. Bledsoe and D. Loveland, American Mathematical Society, Providence, RI, 169 - 192.
Andrews, P. (1986). An Introduction to Mathematical Logic and Type Theory. Academic Press, 1986.
Church, A. (1940). A formulation of the simple theory of types. Journal of Symbolic Logic 5, 56 - 68.
Elliott, C., Pfenning, F. (1988). Higher-Order Abstract Syntax. Proceedings of the ACM-SIGPLAN

Conference on Programming Language Design and Implementation, 199 - 208, ACM Press.
Elliott, C. (1989). Higher-Order Unification with Dependent Types. Rewriting Techniques and Applications, Springer-Verlag LNCS 355, 121 - 136.
Farmer. W. (1984). Length of Proofs and Unification Theory. PhD. dissertation, University of Wisconsin,

Madison.
Felty, A., Miller, D. (1988). Specifying Theorem Provers in a Higher-Order Logic Programming Language.

Proceedings of the Ninth International Conference on Automated Deduction, Argonne, IL, eds. E.
Lusk and R. Overbeek, Springer-Verlag LNCS 310, 61 - 80.
Felty, A. (1989). Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming

Language. PhD dissertation, University of Pennsylvania.
Goldfarb, W. (1981). The Undecidability of the Second-Order Unification Problem. Theoretical Computer

Science 13, 225 - 230.
Hannan, J., Miller, D. (1988). Uses of Higher-Order Unification for Implementing Program Transformers. Fifth International Conference and Symposium on Logic Programming, ed. K. Bowen and R.
Kowalski, MIT Press, 942 - 959.
Hannan, J., Miller, D. (1989). A Meta Language for Functional Programs. Meta-Programming in Logic

Programming, eds. H. Rogers and H. Abramson, MIT Press.
Henkin, L. (1950). Completeness in the theory of types. Journal of Symbolic Logic 15, 81 - 91.
Hindley, J., Seldin, J. (1986). Introduction to Combinators and *-calculus. Cambridge University Press.
Huet, G. (1973a). The Undecidability of Unification in Third Order Logic. Information and Control 22,

257 - 267.
Huet, G. (1973b). A Mechanization of Type Theory. Proceedings of the Third International Joint Conference on Artificial Intelligence, 139 - 146.
Huet, G. (1975). A Unification Algorithm for Typed *-Calculus. Theoretical Computer Science 1, 27 -

57.
Huet, G., Lang, B. (1978). Proving and Applying Program Transformations Expressed with SecondOrder Patterns. Acta Informatica 11, 31 - 55.
Jensen, D., Pietrzykowski, T. (1976). Mechanizing !-Order Type Theory Through Unification. Theoretical Computer Science 3, 123 - 171.
Lucchesi, C. (1972). The Undecidability of the Unification Problem for Third Order Languages. Report

CSRR 2059, Dept. of Applied Analysis and Computer Science, University of Waterloo.
Miller, D. (1987). A Compact Representation of Proofs. Studia Logica 46/4, 345 - 368.

38 D. Miller
Miller, D. (1991a). Unification of Simply Typed Lambda-Terms as Logic Programming. Eight International Logic Programming Conference, Paris, ed. K. Furukawa, MIT Press, 255 - 269.
Miller, D. (1991b). A Logic Programming Language with Lambda-Abstraction, Function Variables, and

Simple Unification. Journal of Logic and Computation 2/4, 497 - 536.
Miller, D., Nadathur, G. (1987). A Logic Programming Approach to Manipulating Formulas and Programs. Symposium on Logic Programming, San Franciso, ed. S. Haridi, IEEE Press, 379 - 388.
Nadathur, G. (1987). A Higher-Order Logic as the Basis for Logic Programming. PhD dissertation,

University of Pennsylvania.
Nadathur, G., Miller, D. (1988). An Overview of *Prolog. Fifth International Conference on Logic

Programming, MIT Press, 810 - 827.
Nadathur, G., Miller, D. (1990). Higher-order Horn Clauses. Journal of the ACM, 37/4, 777 - 814.
Paulson, L. (1986). Natural Deduction as Higher-Order Resolution. Journal of Logic Programming 3/3,

237 - 258.
Paulson, L. (1989). The Foundation of a Generic Theorem Prover. Journal of Automated Reasoning, 5,

363 - 397.
Pfenning, F. (1988). Partial Polymorphic Type Inference and Higher-Order Unification. Proceedings of

the 1988 ACM Conference on Lisp and Functional Programming.
Pfenning, F. (1991). Logic Programming in the LF Logical Framework. In Logical Frameworks, eds. G.

Huet and G. Plotkin, Cambridge University Press, 149 - 181.
Pietrzykowski, T. (1971). A Complete Mechanization of Second-Order Logic. Journal of the ACM 20/2,

333 - 364.
Pietrzykowski, T., Jensen, D. (1976). Mechanizing !-Order Type Theory Through Unification. Theoretical Computer Science 3, 123 - 171.
Pym, D. (1990). Proofs, Search and Computation in General Logic. PhD dissertation, University of

Edinburgh.
Snyder, W., Gallier, J. (1989). Higher Order Unification Revisited: Complete Sets of Transformations.

Journal of Symbolic Computation, 8/1 - 2, 101 - 140.
Statman, R. (1979). Intuitionistic Propositional Logic is Polynomial-Space Complete. Theoretical Computer Science 9, 67 - 72.
Statman, R. (1981). On the Existence of Closed Terms in the Typed *-Calculus II: Transformations of

Unification Problems. Theoretical Computer Science 15, 329 - 338.