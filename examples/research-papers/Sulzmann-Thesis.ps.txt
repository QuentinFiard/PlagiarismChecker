

A General Framework for Hindley/Milner Type Systems with

Constraints

A Dissertation
Presented to the Faculty of the Graduate School

of
Yale University
in Candidacy for the Degree of

Doctor of Philosophy

by
Martin Sulzmann

Date of Dissertation Defence: 3rd of November 1999
Date of Award of Degree: 22nd of May 2000
Dissertation Director: Prof. Paul Hudak
Dissertation Committee: Prof. Martin Odersky, Prof. Zhong Shao, Dr. John Peterson

ii

Abstract
In my dissertation, I introduce a general framework for Hindley/Milner systems
with constraints. The basic idea is to factor out the common core of previous extensions of the Hindley/Milner system. I present a Hindley/Milner system where the
constraint part is a parameter. Specific applications can be obtained by providing
specific constraint systems which capture the application in mind. For instance,
the Hindley/Milner system can be recovered by instantiating the constraint part
to the standard Herbrand constraint system. Type system instances of the general
framework are sound if the underlying constraint system is sound. Furthermore, I
give a generic type inference algorithm for the general framework, under sufficient
conditions on the specific constraint system type inference yields principal types.

iiiiv

Acknowledgments
Many people have provided help during my time at Yale University and at various
places all over the world. First and foremost, I would like to thank my supervisor
Paul Hudak, who provided the financial support to make this dissertation possible.
It was not only a challenge being in his research group but also a challenge being with
him on the ski slopes. I also have to thank my external advisor Martin Odersky.
From the early days at Karlsruhe as my Diploma supervisor, he was always an
inspiring resource. I would never have gotten this far without him. Thanks to all
the participants of the SPAM meeting group at Yale University. In particular, I
would like to thank the following people: Alastair Reid for challenging discussions,
Valery Trifonov, Stefan Monnier and Kevin Glynn for their careful remarks and
proof-reading parts of my dissertation. Several research visits also have allowed
me to meet other people. They have helped me to make significant improvements
to my dissertation. Among these, I would like to thank Martin M"uller for his
helpful comments and discussions; Christoph Zenger for being so particular about
proving things, proof-reading parts of my dissertation and his helpful comments;
John Maraist for making my second research visit to Australia possible. I would
also like to thank Martin Wehr for challenging discussions about type theory back
in Karlsruhe and introducing me to category theory.

In addition, thanks goes to the University of Saarbr"ucken, the University of
South Australia and Fachhochschule Furtwangen for their hospitality during various
research visits.

This work would not have been possible without the support of my family and
friends -- you know who are you -- thanks to all of you.

This work was supported in part by a Yale University Fellowship and DARPA
Grant F30602-96-2-0232.

vvi

Contents
1 Introduction 1

1.1 Dissertation Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

2 Background 5

2.1 Type Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.2 The Hindley/Milner System . . . . . . . . . . . . . . . . . . . . . . . 6

2.2.1 The Logical System . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.2 The Semantic Model . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.3 The Inference System . . . . . . . . . . . . . . . . . . . . . . . 9
2.2.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

3 The HM(X) framework 13

3.1 Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.1.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2 Logical System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.2.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Type Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3.1 A Denotational Approach . . . . . . . . . . . . . . . . . . . . 23
3.3.2 A Syntactic Approach . . . . . . . . . . . . . . . . . . . . . . 27
3.3.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

3.4.1 Instance Relation . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.4.2 Basic Definitions . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.4.3 Derived Typing Rules . . . . . . . . . . . . . . . . . . . . . . 31
3.4.4 Normalized Derivations . . . . . . . . . . . . . . . . . . . . . . 32
3.4.5 Nested Forall Quantifiers . . . . . . . . . . . . . . . . . . . . . 33
3.4.6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.5 Constrained Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . 35

3.5.1 A Comparison between Different Quantifier Introduction Rules 35
3.5.2 Open versus Closed World Systems . . . . . . . . . . . . . . . 39

vii

3.5.3 Odersky/Wadler/Wehr Overloading . . . . . . . . . . . . . . . 40
3.5.4 Ohori Records . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.5.5 Projection in Solved Form . . . . . . . . . . . . . . . . . . . . 47
3.5.6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.6 Terms versus Constraints . . . . . . . . . . . . . . . . . . . . . . . . . 48

3.6.1 A Motivating Example . . . . . . . . . . . . . . . . . . . . . . 48
3.6.2 Formalizing a Connection between Terms and Constraints . . 50
3.6.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.7 Logical System in Constraint Form . . . . . . . . . . . . . . . . . . . 52

3.7.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

4 Type Inference in HM(X) 55

4.1 A Problem when Inferring Principal Types . . . . . . . . . . . . . . . 56

4.1.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.1.2 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.2 Normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

4.2.1 Lifting of Normalization . . . . . . . . . . . . . . . . . . . . . 63
4.3 Inference in Term Form . . . . . . . . . . . . . . . . . . . . . . . . . . 64

4.3.1 Soundness and Completeness Results . . . . . . . . . . . . . . 66
4.3.2 Principal Types . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.4 Inference in Constraint Form . . . . . . . . . . . . . . . . . . . . . . . 69

4.4.1 Constraint Inference . . . . . . . . . . . . . . . . . . . . . . . 69
4.4.2 Term Inference . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.4.3 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

5 Applications 79

5.1 Ohori Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

5.1.1 Extensible Records . . . . . . . . . . . . . . . . . . . . . . . . 82
5.1.2 Record Concatenation . . . . . . . . . . . . . . . . . . . . . . 85
5.1.3 Polymorphic Field Labels . . . . . . . . . . . . . . . . . . . . 88
5.1.4 Records with Overloaded Field Labels . . . . . . . . . . . . . 91
5.1.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
5.2 Odersky/Wadler/Wehr Overloading . . . . . . . . . . . . . . . . . . . 93

5.2.1 Overloaded Curried Functions . . . . . . . . . . . . . . . . . . 96
5.2.2 Overloaded Identifiers as First-Class Values . . . . . . . . . . 98
5.2.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

6 Conclusion 100

6.1 Achievements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
6.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

viii

6.3 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
Bibliography 103
A Extensions 110

A.1 Extensible Records and Polymorphic Field Labels . . . . . . . . . . . 110
A.2 Symmetric Record Concatenation . . . . . . . . . . . . . . . . . . . . 110

B Miscellaneous 112

B.1 Satisfiability in RECl is NP-complete . . . . . . . . . . . . . . . . . . 112
B.2 A Motivating Example II . . . . . . . . . . . . . . . . . . . . . . . . . 112

C Proofs 114

C.1 Proofs of Section 3.3.1 . . . . . . . . . . . . . . . . . . . . . . . . . . 114
C.2 Proofs of Section 3.4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . 116
C.3 Proofs of Section 3.4.4 . . . . . . . . . . . . . . . . . . . . . . . . . . 118
C.4 Proofs of Section 3.6 . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
C.5 Proofs of Section 3.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
C.6 Proofs of Section 4.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
C.7 Proofs of Section 4.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
C.8 Proofs of Section 4.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
C.9 Proofs of Chapter 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142

D HM(X) in Haskell 145
E A Catalogue of Notation 159

ix

List of Figures

1.1 Outline of my dissertation . . . . . . . . . . . . . . . . . . . . . . . . 2
2.1 Hindley/Milner type system . . . . . . . . . . . . . . . . . . . . . . . 8
2.2 Hindley/Milner type inference . . . . . . . . . . . . . . . . . . . . . . 10
2.3 The Hindley/Milner system . . . . . . . . . . . . . . . . . . . . . . . 12

3.1 Logical system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.2 Normalized typing rules . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.3 Versions of the quantifier introduction rule . . . . . . . . . . . . . . . 36
3.4 Logical type system in constraint form . . . . . . . . . . . . . . . . . 53

4.1 Type inference in term form . . . . . . . . . . . . . . . . . . . . . . . 65
4.2 By need type inference in term form . . . . . . . . . . . . . . . . . . 67
4.3 Type inference in constraint form . . . . . . . . . . . . . . . . . . . . 70
4.4 Revised type inference in term form . . . . . . . . . . . . . . . . . . . 73
4.5 Revised type inference in term form II . . . . . . . . . . . . . . . . . 75
4.6 Type inference in term form . . . . . . . . . . . . . . . . . . . . . . . 77
4.7 Type inference in constraint form . . . . . . . . . . . . . . . . . . . . 78

5.1 Closure for extensible records . . . . . . . . . . . . . . . . . . . . . . 84
5.2 Closure for record concatenation . . . . . . . . . . . . . . . . . . . . . 87

C.1 Measure of expression size . . . . . . . . . . . . . . . . . . . . . . . . 115

x

Chapter 1
Introduction
The Hindley/Milner system has proven to be one of the most popular and widely
studied type systems. The Hindley/Milner system is not only of theoretical interest
but has also provided the basis of the type system for various programming languages
such as Haskell [PH97] and ML [MTHM97].

Traditionally, the Hindley/Milner [Mil78] system is split into three parts: the
logical system, the semantic model and the inference system. The logical system
describes the valid typing judgments, whereas the semantic model gives a semantic
meaning to typing judgments. The relationship between both is usually captured
by the phrase "well-typed programs do not go wrong". This means that any well-
typed program can safely be executed and will not cause any run-time errors. In this
context, I consider programs which do not contain type annotations. The inference
system on the other hand, allows to infer a type for a given untyped program. In
the case of the standard Hindley/Milner type system, the connection between the
inference and logical system is expressed by the principal types theorem [DM82].
A principal type represents the most general type for a given program. All other
types which can be given to the program are derivable from the principal type. The
inference system infers principal types if the program is typable at all.

In recent years, there have been quite a big number of extensions of the Hindley/Milner system. Many of these extensions deal with some form of constraints.
In order to establish the standard results almost the same steps/proofs have to be
repeated. What is missing is a general framework which makes it easier to develop
extensions of the Hindley/Milner system in a concise way.

In my dissertation, I introduce a general framework for Hindley/Milner systems
with constraints, henceforth referred to as HM(X) parameterized in the constraint
domain. Specific type system instances of HM(X) are obtained by providing a
constraint system X, which captures the properties in mind. The standard Hindley/Milner systems falls out by instantiating X with the standard Herbrand constraint system. HM(X) stays in the tradition of the standard Hindley/Milner sys1

2
Chapter 2: The Hindley/Milner system

fflffl
Chapter 3: The HM(X) framework

fflffl
Chapter 4: Type inference in HM(X)

fflffl
Chapter 5: HM(X) applications

fflffl
Chapter 6: Conclusion

Figure 1.1: Outline of my dissertation
tem. Type system instances of HM(X) are sound under a standard compositional
semantics. I present a type inference algorithm for HM(X) that is generic in the constraint domain X. Under sufficient conditions on X, type inference yields principal
types.

1.1 Dissertation Outline
Chapter 2 provides basic background about type systems and a general overview of
the Hindley/Milner system. In Chapter 3, I formally introduce the HM(X) framework. First, I define the constraint language used throughout my dissertation. Based
on the constraint language, I introduce the language of types. Once the constraint
and type language are defined, type system instances of HM(X) can be described.
I describe two possible presentations of HM(X) type system instances, one in term
form and the other in constraint form and compare their relationship. In addition,
I highlight the advantages of the novel formulation of the quantifier introduction
found in HM(X). Then, I undertake a discussion of two approaches to establish a
type soundness theorem. The first approach stays in the tradition of Milner's type
soundness result. I give a standard untyped compositional semantic based on the
ideal model. The second approach is based on a subject reduction property. Finally, I present the inference system in Chapter 4. I introduce the new concept of
normalization which can be seen as an extension of the well-known concept of unification. Under the assumption that most general normalizers exist, type inference

3
yields principal types. Chapter 5 presents applications of the HM(X) framework.
I describe Ohori's record calculus [Oho95] and overloading in the style of Odersky/Wadler/Wehr [OWW95] as instances of the HM(X) system. In addition, I give
several useful extensions of these systems. Chapter 6 concludes my dissertation.

Figure 1.1 highlights the general structure of my dissertation. Readers familiar
with type systems and the Hindley/Milner system in particular, can skip Chapter 2
and immediately move on to Chapter 3. Each chapter contains an overview of
the content of the chapter at the beginning. Each section contains a summary
section which allows for quick access to the content and overview of results. A
significant part of my dissertation deals with proofs. Most proofs can be found in
the appendix unless the proof is rather short. Some proofs are omitted if the proof
is straightforward. Appendix E contains a catalogue of notation.

1.2 Contributions
My dissertation evolved out of work started with Martin Odersky and Martin Wehr.
Preliminary results can be found in [SOW97, OSW99]. The main contributions my
dissertation makes to the field are listed below:

1. HM(X) claims to be a general framework for Hindley/Milner systems. To support this claim, I show how previous approaches can be seen as instances of the
HM(X) system. I consider specifically systems which deal with records [Oho95,
R'em89, Gas98] overloading [OWW95, NP95, Jon92] and subtyping [Kae92,
AW93, TS96]. Further instances are systems for program analysis such as
dimension analysis [Ken96]. Details can be found in in Section 3.2 and Chapter 5.

2. The HM(X) systems comes with a novel formulation of the quantifier introduction rule due to Martin Odersky which improves on previous formulations
(see Section 3.5).

3. HM(X) type system instances are sound under a standard compositional semantics. The catch-phrase"well-typed programs do not go wrong" can be extended to the HM(X) system provided that the constraint system X is sound.
See Section 3.3 for details. The adoption of Milner's type soundness approach
is an idea started by Martin Odersky.

4. Type descriptions usually consist of a term algebra which describes the valid

type terms. For instance, recursive types such as _ff:ff ! fi are represented
explicitly through the _ notation in the type language. Types could also be
represented in the constraint language as solutions for some variables. The
constraint (ff = ff ! fi) represents the above recursive type in the constraint

4
language. I give two presentations of the formal HM(X) system. One of
the presentations is in term form where complex terms might possibly appear explicitly in the syntactic domain of types. The other presentation is in
constraint form where all typing information is represented in the constraint
domain. The term representation is the more common one, but the constraint
representation allows for an abstraction from any syntactic considerations and
even an achievement of higher expressiveness. Section 3.6 discusses this topic
in more detail. This part of my dissertation resulted from discussions with
Martin M"uller and Christoph Zenger.

5. I introduce a generic inference system for HM(X). Typing problems are commonly transformed into constraint problems that require solutions. Constraints solving consists usually of a form of unification or only a satisfiability
check in the simplest case. I give a characterization of constraint solutions
which I call normalization. If the constraint system enjoys most general normalizers, type inference always yields principal types. I propose various styles
of type inference algorithms as well as soundness and completeness results. I
specifically solve the open problem of type inference in non-regular equational
theories [Ken96]. See Chapter 4 for details. The characterization of normalization results from work started with Martin Odersky and Martin Wehr.

6. In Appendix D, I give a specification of the HM(X) inference system in terms of

the functional language Haskell. The goal is to provide a rigorous specification
of the essential inference components rather than to provide an optimized
implementation.

7. Type inference has already been widely studied for several variations [R'em92b,

EST95b, Smi91] of the Hindley/Milner system. Therefore, quite a number of
constraint solvers [BS94] have already been developed. Previous constraint
solvers operate mostly on a more restrictive constraint language as compared
to the constraint language found in HM(X). I show how these constraint solvers
fit into HM(X) and can even be lifted to the more general constraint domain
found in HM(X). Details can be found in Section 4.2.

In summary, soundness and completeness of type inference are the main technical contributions of my dissertation, see Section 4.5 for an overview of the
achieved results. Furthermore, the HM(X) framework comes with a clean semantic definition of constraints. This allows for a formulation of the quantifier
introduction rule which is a significant improvement over previous formulations.

Chapter 2
Background
This chapter provides some basic background material. I start with an introduction
to the area of type systems. Specifically, I introduce the Hindley/Milner system.
This section owes much to [Car97].

2.1 Type Systems
Type systems are formal systems which ensure certain properties such as the prevention of run-time errors when executing a program. In typed languages like
Pascal [HW73], ML [MTHM97] and Haskell [PH97], program variables can be given
types. Type systems are used to distinguish between well-typed programs and
ill-typed ones. Typed languages enforce static checking. Whether a program is
well-typed or not is checked at compile-time. This is in contrast to untyped languages like Lisp. In untyped languages, dynamic checking is found. Whether a
program is well-typed or not is checked at run-time. Static checking allows to omit
run-time tests if the language is type sound. Typed languages often enjoy a type
soundness property. A language is type sound if any given well-typed program
does not case a run-time error. Hence, type sound languages do not need run-time
checks. Statically typed languages are also easier to debug. Program errors can be
detected at compile-time which would have been otherwise deferred to run-time. A
disadvantage of statically typed languages is that they are more restrictive than dynamically typed languages. Of course, there must be a trade-off between statically
and dynamically typed languages.

In general, one finds often a mix between static and dynamic checking. Languages like Haskell or ML are considered to be statically typed, but some dynamic
checks still remain, for example array-bounds check or division by zero check. It
has been noted that the type systems in Haskell and ML are simply not expressive
enough to capture properties such as array-bounds checking.

5

CHAPTER 2. BACKGROUND 6

Type systems enforce certain properties such as the prevention of run-time errors. In essence, a type system can be used in two orthogonal directions. It can
either extend the expressiveness of the language itself, or enforce stronger properties.
For instance, consider a system which allows for dimension checking. This sort of
system is able to distinguish between values representing different dimensions such
as mass and time. Adding a value of dimension time to a value of dimension mass
is then prohibited. In such a dimension system, more errors can already be detected
at compile-time. I refer to Section 3.2 for the technical presentation of this.

On the other hand, a more expressive type system allows the set of well-typed
programs to be extended. For instance, a polymorphic type system allows more
programs to be typed than a monomorphic type system. Strachey [Str67] was the
first to describe the concept of parametric polymorphism. 1 The identity function
is a standard example. Given any input value x the identity function returns x as an
output value. What would be a possible type for the identity function? Assuming
we have a monomorphic type system, then programs such as the identity function
are therefore only allowed to take values belonging to one specific type such as Int
or Bool. But then, it is no longer possible to apply integer or boolean values to the
identity function in the same context. In fact, the identity function behaves independent of any specific type. In a polymorphic type system, the identity function can
be given a polymorphic type. A polymorphic type represents a set of monomorphic
types. This allows integer and boolean values to be applied to the identity function
in the same context. Hence, a polymorphic type system allows more programs to
be typed than a monomorphic type system.

2.2 The Hindley/Milner System
I give a description of the Hindley/Milner type system following [Dam85, Mil78].

The Hindley/Milner system is divided into three parts. The logical system describes the valid type judgments, the semantic model gives a meaning to valid judgments, and finally the inference system which allows to infer a type for a given
untyped program. It should be noted that standard Hindley/Milner programs do
not contain type annotations, although extensions [OL96] with type annotations
have been explored. In the case of the standard Hindley/Milner type system, the
connection between the inference and logical system is expressed by the principal
types theorem [DM82]. A principal type represents the most general type for a given
program. All other types which can be given to the program are derivable from the
principal type. The inference system infers principal types if the program is typable
at all.

1Later in my dissertation, I introduce the concept of constrained polymorphism.

CHAPTER 2. BACKGROUND 7
2.2.1 The Logical System
Hindley/Milner programs are of the following form.

Values v ::= x j *x:e
Expressions e ::= v j e e j let x = e in e

There are variables, lambda-abstraction and function application. Furthermore,
there are let definitions. The Hindley/Milner approach has a polymorphic type
system where polymorphism is introduced through the let-statement. This kind of
polymorphism is also often referred to as let-polymorphism. The type language is
as follows.

Types o/ ::= ff j o/ ! o/
Type schemes oe ::= o/ j 8ff:C ) oe

The type language is divided into types (also referred to as monomorphic types)
and type schemes (also referred to as polymorphic types). Typical monomorphic
types are type variables and function types. Types such as Int or Bool are also
monomorphic types. Type schemes are universally quantified types where the type
variables are only allowed to range over monomorphic types. I refer to monomorphic
and polymorphic types simply as types if there are no ambiguities. It is a standard
convention to let o/ range monomorphic types and oe range over polymorphic types.

The set of well-typed Hindley/Milner programs is described by typing judgments. A typing judgment is of the form \Gamma  ` e : oe where \Gamma  contains the free
variables associated with its type, e is an expression and oe is a type scheme. A
typing judgment is valid if it can be derived by application of the typing rules. The
typing rules are given in Figure 2.1. Note, in rule (Abs) and (Let) the type environment \Gamma x denotes the type environment fy : oe j y : oe 2 \Gamma  y 6= xg. Extension of
a type environment is written as \Gamma x:x : oe.

2.2.2 The Semantic Model
The semantic model given in [Mil78] is based on an ideal semantics [MPS86].

The meaning of a term is a value in the CPO V, where V contains all continuous functions from V to V and an error element W, usually pronounced "wrong".
Depending on the concrete type system used, V might contain other elements as
well. I require that the values of additional type constructors are representable in
the CPO V. Then V is the least solution of the equation

V = W? + V ! V:
The meaning function on terms is as follows:

CHAPTER 2. BACKGROUND 8

(Var) \Gamma  ` x : oe (x : oe 2 \Gamma )
(Abs)

\Gamma x:x : o/ ` e : o/ 0

\Gamma x ` *x:e : o/ ! o/ 0

(App)

\Gamma  ` e1 : o/1 ! o/2 \Gamma  ` e2 : o/1

\Gamma  ` e1e2 : o/2

(Let)

\Gamma x ` e : oe \Gamma x:x : oe ` e0 : o/ 0

\Gamma x ` let x = e in e0 : o/ 0

(8 Intro)

\Gamma  ` e : o/ _ff 62 fv(\Gamma )

\Gamma  ` e : 8 _ff:o/

(8 Elim)

\Gamma  ` e : 8 _ff:o/ 0

\Gamma  ` e : [_o/ = _ff]o/ 0

Figure 2.1: Hindley/Milner type system

[[x]]j = j(x)
[[*u:e]]j = *v:[[e]]j[u := v]
[[e e0]]j = if [[e]]j 2 V ! V ^ [[e0]]j 6= W

then ([[e]]j) ([[e0]]j)
else W

[[let x = e in e0]]j = if [[e]]j 6= W

then [[e0]]j[x := [[e]]j]
else W

Note that I employ a call-by value semantics. It can be shown that the meaning
of a well-typed program is always different from "wrong".

A monotype is a type o/ with fv(o/ ) = ;. I let _ range over monotypes. Types
denote ideals, i.e. non-empty, downward-closed and limit-closed subsets of V. The
meaning function [[\Delta ]] maps closed types and type schemes to ideals.

CHAPTER 2. BACKGROUND 9

[[_1 ! _2]] =

ff 2 V ! V j v 2 [[_1]] ) f v 2 [[_2]]g
[[T _1 : : : _m]] =

f?g [S

fk [[_01]] : : : [[_0n]] j

\Gamma 0 ` k : _01 ! : : : ! _0n ! T _1 : : : _mg
[[8 _ff:o/ ]] =T

f[[[__= _ff]o/ ]]g

The following statements hold.
Lemma 1 Let oe be a closed type scheme. Then [[oe]] is an ideal and W 62 [[oe]].
Definition 1 A variable environment j models a closed typing environment \Gamma , written j j= \Gamma , if for all x : oe 2 \Gamma , j(x) 2 [[oe]].

Theorem 1 (Type Soundness) Let \Gamma  ` e : oe be a valid typing judgment. Let OE
be a substitution such that OE\Gamma  and OEoe are closed. Let j be a variable environment
such that j j= OE\Gamma . Then

(1) W 62 [[OEoe]]
(2) [[e]]j 2 [[OEoe]]

The type soundness result is commonly summarized through the catch-phrase
"well types programs do not go wrong".

2.2.3 The Inference System
It is common knowledge that the type inference problem in the Hindley/Milner system can be reduced to a unification problem. Robinson [Rob65] gives an algorithm
which computes the most general unifier of two types or otherwise reports failure.
I refer to Robinson's algorithm as a function unify. The interested reader should
refer to [LMM87, Rob65] for a more detailed exposition.

Given two types o/1 and o/2. Then o/1 and o/2 are unifiable iff there exists a substitution OE such that OEo/1 = OEo/2. In such a case, the substitution OE is called a unifier of
types o/1 and o/2. A substitution  is a most general unifier (commonly abbreviated
by mgu) of o/1 and o/2 iff o/1 = o/2 and given another unifier OE of o/1 and o/2, then
there exists a substitution ae such that OE = ae ffi .

Robinson could state the following result.

CHAPTER 2. BACKGROUND 10

(Var)

x : (8 _ff:o/ ) 2 \Gamma  _fi new

id; \Gamma  `W x : [ _fi= _ff]o/

(Abs)

; \Gamma x:x : ff `W e : o/ ff new

nfffg; \Gamma x `W *x:e : (ff) ! o/

(App)

1; \Gamma  `W e1 : o/1 2; \Gamma  `W e2 : o/2

3 = unify(o/1; o/2 ! ff) ff new

 = 1 t 2 t 3
jfv(\Gamma ); \Gamma  `W e1e2 :  ffi 0(ff)

(Let)

1; \Gamma x `W e : o/ oe = 8 _ff:o/ _ff = fv(o/ )nfv(\Gamma x)

2; \Gamma x:x : oe `W e0 : o/ 0

0 = 1 t 2
jfv(\Gamma x); \Gamma x `W let x = e in e0 : o/ 0

Figure 2.2: Hindley/Milner type inference
Theorem 2 (Robinson) Given two types o/1 and o/2. Then o/1 and o/2 are unifiable
and a most general unifier exists (and this most general unifier is unique up to
variable renaming), or o/1 and o/2 do not have any unifiers.

This allows to define the following well-defined unify function:

unify(o/1; o/2)
=  if  is a mgu of o/1 and o/2
= fail otherwise

The inference system can be found in Figure 2.2. In contrast to the original presentation [DM82], I present the inference system as a deduction system with clauses
of the form ; \Gamma  `W e : o/ with type environment \Gamma , expression e as input values and
substitution , type o/ as output values. For each syntactic construct of expressions
e there is one clause. The deduction rules can be interpreted operationally, as a logic
program that constructs a bottom-up derivation of `W clauses. The operator t in
rules (App) and (Let) builds the least upper bound of substitutions.

In the (Var) rule, an unqualified type o/ is represented as 8;:o/ . This avoids a
separate case of this rule for unqualified types. In rule (App), the typing problem

CHAPTER 2. BACKGROUND 11
is translated into a unification problem. Then, the three resulting substitutions are
combined with the t operator which computes the least upper bound by constructing
the mgu.

In [DM82] the following results were stated. Any judgment derivable by the
inference system is also derivable in the logical system.

Theorem 3 (Soundness of Inference) Given a term e and a type environment
\Gamma . If ; \Gamma  `W e : o/ then \Gamma  ` e : o/ and o/ = o/ .

Before I state the completeness result, I restate the definition of a generic instance. Given a type scheme oe = 8ff1; : : : ffn:o/ . Then oe0 = 8fi1; : : : ; fim:o/ 0 is a generic
instance of oe if o/ 0 = [o/i=fii]o/ for some types o/1; : : : ; o/n and fij are not free in oe. In
this case, I write oe ! oe0.

Furthermore, I define a generalization function gen. Given a type environment
\Gamma  and a type o/ . Then gen(\Gamma ; o/ ) = 8 _ff:o/ where _ff = fv(o/ )nfv(\Gamma ).

Theorem 4 (Completeness of Inference) Let OE\Gamma  ` e : oe be a typing judgment.
Then ; \Gamma  `W e : o/ for some substitutions , ae and type o/ such that aegen(\Gamma ; o/ ) !
oe.

The completeness theorem can be simplified for top-level programs to the following corollary, which states that the type inference algorithm computes principal
types. Given a type environment \Gamma  and an expression oe, then oe is a principal type
of e under \Gamma  iff \Gamma  ` e : oe and if \Gamma  ` e : oe0 for any other oe0 then oe ! oe0.

Corollary 1 (Principal Types) Let \Gamma  ` e : oe be a closed typing judgment. Then
id; \Gamma  `W e : o/ such that gen(\Gamma ; o/ ) ! oe.

2.2.4 Summary
The Hindley/Milner system consists of three components: the logical system which
describes the well-typed programs, the inference system which infers principal types
and the semantic model which ensures that well-typed programs do not go wrong.
Figure 2.3 exhibits the relationships among the three components. In the remaining part of my dissertation, I consider an extension of the Hindley/Milner system
with constraints which retains the two elementary properties of the standard Hindley/Milner system: the type soundness result and the principal types property.

CHAPTER 2. BACKGROUND 12

wvutpqrsLogical

system

Type Soundness"

"""

""""

""""

"""

""""

""""

""""

""""

Principal Types

???
????

????
???
?

????
????
????
???

wvutpqrsSemantic

model wvutpqrs

Inference

system

Figure 2.3: The Hindley/Milner system

Chapter 3
The HM(X) framework

This chapter starts with some basic terminology and results about constraints. It
follows the presentation of the logical part of the HM(X) system. Type system
instances of HM(X) are defined by a constraint system X (which describes the constraint language) and a term algebra T (which describes the type language). The
constraint language might be richer than the constraints which are allowed to actually appear in typing judgments. I refer to the set of constraints which are allowed to
appear in typing judgments as solved forms, denoted by S. For instance, the standard Hindley/Milner system is obtained by taking X to be the Herbrand constraint
system and S to consist only of fg which represents the true constraint.

One of the novel aspects in HM(X) is the use of a semantic notion of constraints.
This is reflected in the logical system which allows a formulation of the following
quantifier introduction rule:

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

where C and D are constraints, \Gamma  is a type environment, e is a program and oe is a
type scheme. The novelty is the existential quantifier 9ff which allows to bind free
type variables also in the constraint part.

I present two alternative approaches to achieve type soundness for HM(X) instances. The first approach stays in the tradition of Milner's original semantics. I
give a standard untyped compositional semantic based on the ideal model [MPS86].
I also provide a second approach which is along the lines of [WF91]. The key idea
is based upon an operational formulation of a language's semantics by rewriting.

Section 3.4 discusses properties of HM(X) type systems and introduces some
basic definitions used throughout my dissertation.

Section 3.5 relates HM(X) to previous approaches. I discuss specifically issues
regarding the different formulations of the quantifier introduction rule found in previous approaches [Jon92, AW93, Smi91, TS96]. I show how the HM(X) quantifier

13

CHAPTER 3. THE HM(X) FRAMEWORK 14
introduction rule relates to the open or closed world assumption found in overloading
systems [OWW95, Smi91]. In addition, I consider Ohori's record calculus [Oho95]
and the message passing system of Nishimura [Nis98]. I also point out the problems
in their systems which are related to their formulation of the quantifier introduction
rule.

In fact, I give two presentations of the logical system: one in term form, the
other in constraint form. Type descriptions are usually represented in term form.
For instance, recursive types such as _ff:ff ! fi are represented explicitly through
the _ notation in the type language. The following is a valid judgment in a variation
of the Hindley/Milner system with recursive types:

fx : _ff:ff ! fig ` xx : fi
Variable x is applied to itself, therefore it needs to be of recursive type. Recursive
types are represented by the _ notation in the syntactic domain of types. But recursive types can also be represented in the constraint language by equality constraints.
The above judgment can also be represented as

(ff = ff ! fi); fx : ffg ` xx : fi
where the constraint (ff = ff ! fi) contains all essential typing information. I refer
to the former presentation of judgments as the term presentation and to the latter
as the constraint presentation. Section 3.6 studies the two possible representation
forms. The idea of expressing all typing information in the constraint language is
further developed in Section 3.7.

3.1 Constraints
I present a characterization of constraint systems along the lines of Henkin [HMT71]
and Saraswat [Sar93]. Building on the standard notions of simple and cylindric
constraint systems, I introduce term constraint systems as constraint systems which
have a well-behaved notion of substitution. It must be noted that the notion of
constraints found here differs from the standard notion where constraint systems
are regarded as a kind of first-order theory. Conceptually, there would not be any
problems using the standard formulation of constraint systems, I prefer to follow
the notion of constraints found in [HMT71, Sar93]. The notion of cylindric algebras
captures the minimal requirements needed to describe the constraint part of the
HM(X) framework. The constraint system X will be the parameter which allows
the HM(X) framework to be customized to different application domains.

Definition 2 A simple constraint system is a structure (\Omega ; `e ) where \Omega  is a non-
empty set of tokens or (primitive) constraints. I also refer to such constraints as

CHAPTER 3. THE HM(X) FRAMEWORK 15
predicates. The relation `e ` p\Omega  \Theta  \Omega  is an entailment relation where p\Omega  is the set
of finite subsets of \Omega . I call C 2 p\Omega  a constraint set or simply a constraint.

A constraint system (\Omega ; `e ) must satisfy for all constraints C; D 2 p\Omega :

C1 C `e P whenever P 2 C and
C2 C `e Q whenever

C `e P for all P 2 D and D `e Q

I extend `e to be a relation on p\Omega  \Theta  p\Omega  by: C `e D iff C `e P for every P 2 D.
Furthermore, I define C =e D iff C `e D and D `e C. The term `e C is an
abbreviation for ; `e C and true = f P j ; `e P g represents the true element.

I give an example how to generate a simple constraint system based on a first-
order language L.

Example 1 For any first-order language L, and countably infinite set of variables Var, take \Omega  to be an arbitrary subset of open (L, Var)-formulas, and `e
to be the entailment relation with respect to some class \Delta  of L-structures. That
is, fP1; : : : ; Png `e Q iff for every structure M 2 \Delta , an M -valuation realizes Q
whenever it realizes each of P1; : : : ; Pn. Such a (\Omega ; `e ) is a simple constraint system.

The extension of a simple constraint system with a projection operator 9 _ff leads
to a cylindric constraint system.

Definition 3 A cylindric constraint system is a structure CCS = (\Omega ; `e ;Var; f9ff j ff 2
Varg) such that:

ffl (\Omega ; `e ) is a simple constraint system,
ffl Var is an infinite set of variables,
ffl For each variable ff 2 Var, 9ff : p\Omega  ! p\Omega 

is an operation satisfying:

E1 C `e 9ff:C
E2 C `e D implies 9ff:C `e 9ff:D
E3 9ff:(C ^ 9ff:D) =e (9ff:C) ^ (9ff:D)
E4 9ff:9fi:C =e 9fi:9ff:C

Remark 1 For simplicity, I omit set notation for constraints, and connect constraints by ^ instead of the union operator [ and generally do not enclose simple
constraints P in opening and closing braces. For instance, P ^ Q is an abbreviation
for fP g [ fQg. I assume that ^ binds tighter than 9 _ff. For instance, 9 _ff:C ^ D
stands for 9 _ff:(C ^ D). I write C =e D iff C `e D and D `e C.

CHAPTER 3. THE HM(X) FRAMEWORK 16
Example 2 Let the token set \Omega  consist of some subclass of (L,Var) formulas closed
under existential quantification of finite conjunctions. Each operator 9 _ff is then
interpreted by the function which maps each finite set fP1; : : : ; Png of tokens to the
set of tokens f9 _ff:P1 ^ : : : ^ Png. This way the four conditions above are satisfied.

The projection operator 9 _ff allows us to bind variables _ff in a constraint. If the
constraint system models a boolean algebra, projection corresponds to existential
quantification. Based on the projection operator, I define the free variables fv(C)
and satisfiability of a constraint C.

Definition 4 Let C be a constraint. Then fv(C) = fff j 9ff:C 6 =e Cg.
Definition 5 Let C be a constraint. Then C is satisfiable iff `e 9fv(C):C.
Lemma 2 Let C be a constraint. Then C is satisfiable iff 9ff:C is satisfiable.
Proof: I only consider the case where ff 2 fv(C). C is satisfiable iff `e 9fv(C):C
iff `e 9fv(C):9ff:C `e 9fv(9ff:C):9ff:C iff 9ff:C is satisfiable.

The final step in the modelling of constraint systems is the extension from cylindric constraint systems to term constraint systems. I assume a term algebra T with
signature \Sigma  = (Var, Cons) as given. Var is a set of variables and Cons is a set
of type constructors containing at least the function constructor ! of arity 2. In
examples below I will sometimes use a multi-sorted algebra, in which terms and constructors are partitioned into sorts. Always present will be the sort of types which
is ranged over by o/ .

Definition 6 A substitution OE is an idempotent mapping from the set of variables
Var to the term algebra Term(\Sigma ) which is the identity everywhere except on a finite
set of variables. Substitutions are extended homomorphically to types.

Definition 7 A term constraint system T CST = (\Omega ; `e ; Var; f9ff j ff 2 Varg) over
a term algebra T is a cylindric constraint system with predicates of the form

p(o/1; : : : ; o/n) (o/i 2 T )

CHAPTER 3. THE HM(X) FRAMEWORK 17
such that the following holds:

ffl For each pair of types o/; o/ 0 there is an equality

predicate (o/ = o/ 0) in T CST , which satisfies:

D1 `e (ff = ff)
D2 (ff = fi) `e (fi = ff)
D3 (ff = fi) ^ (fi = fl) `e (ff = fl)
D4 (ff = fi) ^ 9ff:(C ^ (ff = fi)) `e C
D5 (o/ = o/ 0) `e (T [o/ ] = T [o/ 0])

where T [] is an arbitrary term context
ffl For each predicate p(o/1; : : : ; o/n),

D6 [o/ =ff]p(o/1; : : : ; o/n) =e 9ff:(p(o/1; : : : ; o/n) ^ (ff = o/ ))

where ff 62 fv(o/ )

Remark 2 Conditions D1 - D4 are the conditions imposed on a cylindric constraint system with diagonal elements, which is usually taken as the foundation of
constraint programming languages. D4 says that equals can be substituted for equals;
it is in effect the Leibniz principle. D5 states that (=) is a congruence. D6 connects
the syntactic operation of a substitution over predicates 1 with the semantic concepts
of projection and equality. Substitution is extended to arbitrary constraints in the
canonical way:

[o/ =ff](P1 ^ : : : ^ Pn) = [o/ =ff]P1 ^ : : : ^ [o/ =ff]Pn:
Lemma 3 (Renaming) Let C be a constraint and fi a new type variable. Then
9ff:C =e 9fi:[fi=ff]C.

Proof: 9ff:C =e 9ff:9fi:((ff = fi) ^ C) =e 9fi:9ff:((ff = fi) ^ C) =e 9fi:[fi=ff]C.

Lemma 4 (Normal Form) Let C be a constraint and OE = [_o/ = _ff] be a substitution.
Then OEC =e 9 _ff:((ff1 = o/1) ^ : : : ^ (ffn = o/n) ^ C).

Proof: I assume OE = [o/1=ff1; o/2=ff2]. Remember that substitutions are idempotent
mappings, hence ff1 62 fv(o/2) and ff2 62 fv(o/1). Then OEC =e 9ff1:((ff1 = o/1) ^
(9ff2:(ff2 = o/2) ^ C)) =e 9ff1:9ff2:((ff1 = o/1) ^ (ff2 = o/2) ^ C). Note that in the last
proof step it was essential that ff2 62 (o/1).

Lemma 5 (Substitution) Let C; D be constraints such that C `e D and OE be a
substitution. Then OEC `e OED.

1Substitutions is only defined on types but is extended naturally to predicates;
[o/ =ff]p(o/1; : : : ; o/n) = p([o/=ff]o/1; : : : ; [o/ =ff]o/n).

CHAPTER 3. THE HM(X) FRAMEWORK 18
Proof: I assume OE = [_o/ = _ff]. Given C `e D. Then (C ^ ( _ff = _o/ )) `e (D ^ ( _ff = _o/ )).
The entailment relation is closed under projection. Then 9 _ff:(C ^ ( _ff = _o/ )) `e
9 _ff:(D ^ ( _ff = _o/ )).

Example 3 For any term algebra T let HERBRAND = (\Omega ; `e ; Var; f9ff j ff 2
Varg) be the minimal term constraint system where \Omega  contains only primitive constraints of the form (o/ = o/ 0) where o/ and o/ 0 are types from T . Equality in HERBRAND
is syntactic, i.e. T is a free algebra. Satisfiability can be checked by (first-order)
unification.

A more refined example of a term constraint system deals with physical dimension types in the style of Kennedy [Ken96]. The idea is to distinguish between values
representing different dimensions such as mass and time. To this purpose, the type
language is now divided into dimension types and the common types.

Example 4 Let T be the two-sorted term algebra consisting of dimensions and
types.

Dimensions d ::' ff j i(d) j prod(d; d) j 1 j m j s
Types o/ ::= ff j dim(d) j o/ ! o/

The dimension constructor i(\Delta ) corresponds to the inverse of a dimension and prod(\Delta ; \Delta )
to the product of two dimensions. Dimension constants are 1 for the unit measure,
m for meters and s for seconds. There might be other dimension constructors besides the mentioned ones, therefore the language of dimension types is left open. A
type is either a type variable, or a dimension, or a function type. DIM is then the
term constraint system which obeys the following additional conditions, which specify
that dimension types form an Abelian group.

DIM1 `e (prod(ff; fi) = prod(fi; ff))
DIM2 `e (prod(ff; prod(fi; fl)) = prod(prod(ff; fi); fl))
DIM3 `e (prod(ff; 1) = ff)
DIM4 `e (prod(ff; i(ff)) = 1)

A similar idea can be employed to encode a simple form of arithmetic.
Example 5 Let T be a two-sorted algebra consisting of indices and types.

Indices i ::= ff j + (i; i) j 0 j 1
Types o/ ::= ff j index(i) j o/ ! o/

The index constants 0 and 1 are constant type constructors and represent the
corresponding values. Constructor +(\Delta ; \Delta ) has the obvious meaning. The constructors

CHAPTER 3. THE HM(X) FRAMEWORK 19
obey the usual laws of arithmetic. This can be specified by constraint rules of the
form:

INDEX1 `e (+(1; 0) = 1)
INDEX2 `e (+(i1; i2) = +(i2; i1))
INDEX3 `e (+(+(i1; i2); i3) = +(i1; +(i2; i3)))

In the final example, I consider an extension of a term constraint system with
subtyping.

Example 6 A subtype constraint system over a term algebra T is a term constraint
system with a subtype predicate (o/ !: o/ 0) for each pair of types o/ and o/ 0 which satisfies
the following conditions.

SUB1 (ff = ff0) =e (ff !: ff0) ^ (ff0 !: ff)

SUB2

D `e (ff01 !: ff1) D `e (ff2 !: ff02)

D `e (ff1 ! ff2 !: ff01 ! ff02)

SUB3

D `e (ff1 !: ff2) D `e (ff2 !: ff3)

D `e (ff1 !: ff3)

Let SC be a subtype constraint system with primitive types Int and Float and record
types of the form fl1 : o/1; : : : ; ln : o/ng. Records are modelled by admitting constructors
of the form

l1 : : : ln : o/1 ! : : : ! o/n ! fl1 : o/1; : : : ; ln : o/ng

in the term algebra. I assume that record fields are ordered with respect to a given
ordering relation on field labels. The additional types obey the following rules.

SUB4 `e (Int !: Float)

SUB5 `e (fl1 : o/1; : : : ; ln : o/n; : : :g !: fl1 : o/1; : : : ; ln : o/ng)

SUB6

D `e (o/1 !: o/ 01) : : : D `e (o/n !: o/ 0n)

D `e (fl1 : o/1; : : : ; ln : o/ng !: fl1 : o/ 01; : : : ; ln : o/ 0ng)

3.1.1 Summary
Constraints are semantically described by adopting the notion of cylindric algebras
found in the constraint logic programming framework [JM94]. Cylindric algebras
come with a projection operator 9 _ff that binds some subset of variables _ff in the

CHAPTER 3. THE HM(X) FRAMEWORK 20
constraint. In the usual case where constraints are boolean algebras, projection
corresponds to existential quantification. The syntactic concept of substitutions can
be described semantically by projection and equality, i.e. [o/ =ff]C = 9ff:((ff = o/ )^C)
where C is a constraint. I introduced term constraint systems which have a well-
behaved notion of substitution. Term constraint systems will be the parameter which
allows the HM(X) framework to be customized to different application domains.
Commonly, I refer to term constraint systems as constraint systems.

3.2 Logical System
I assume given a term constraint system X over a term algebra T as the parameter.
The HM(X) system consists of the following syntactic domains:

Values v ::= x j c j *x:e
Expressions e ::= v j e e j let x = e in e
Types o/ ::' ff j o/ ! o/
Type schemes oe ::= o/ j 8ff:C ) oe

Compared to the standard Hindley/Milner system, types in HM(X) are now
members of an arbitrary term algebra which contains at least type variables and
function types. Hence, the type language is left open expressed by the symbol '.
Section 3.1 described more complex type languages such as dimension types. Type
schemes 8ff:C ) oe now include a constraint component C, which restricts the types
that can be substituted for the type variable ff. Constraint components appearing
in type schemes must always be satisfiable.

The language of terms is exactly as in [DM82], that is, I assume that any language
constructs that make use of type constraints are expressible as predefined values,
whose names and types are recorded in the initial type environment \Gamma 0.

The typing rules can be found in Figure 3.1. The most interesting rules in
Figure 3.1 are the (8 Intro) rule and the (8 Elim) rule. By rule (8 Intro) I quantify
some type variables. I often use vector notation for type variables in type schemes.
The term 8 _ff:D ) o/ is an abbreviation for 8ff1:true ) : : : 8ffn:D ) o/ and 9 _ff:D
is an abbreviation for 9ff1: : : : 9ffn:D. Constraints C appearing on the left-hand
side of the turnstile and in type schemes should be seen as the equivalence class

_C = fD j D =e Cg of all constraints which are semantically equivalent to C. It

must be noted that the set of free variables is independent of a specific representative
of the equivalence class. Given C =e D then fv(C) = fv(D) which is easy to verify.
In general, I omit the equivalence class notation.

Typing judgments are of the form C; \Gamma  ` e : oe where C is a constraint in X, \Gamma 
a type environment and oe a type scheme. A typing judgment is valid if it can be
derived by application of the typing rules and its constraint component is satisfiable.

CHAPTER 3. THE HM(X) FRAMEWORK 21

(Var) C; \Gamma  ` x : oe (x : oe 2 \Gamma )
(Sub)

C; \Gamma  ` e : o/ C `e (o/ _ o/ 0)

C; \Gamma  ` e : o/ 0

(Abs)

C; \Gamma x:x : o/ ` e : o/ 0

C; \Gamma x ` *x:e : o/ ! o/ 0

(App)

C; \Gamma  ` e1 : o/1 ! o/2 C; \Gamma  ` e2 : o/1

C; \Gamma  ` e1e2 : o/2

(Let)

C; \Gamma x ` e : oe C; \Gamma x:x : oe ` e0 : o/ 0

C; \Gamma x ` let x = e in e0 : o/ 0

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

(8 Elim)

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C `e [_o/ = _ff]D

C; \Gamma  ` e : [_o/ = _ff]o/ 0

Figure 3.1: Logical system
In some typing situations, it might be useful to further restrict the set of constraints allowed to appear in typing judgments and type schemes. I assume that the
set of constraints appearing in type schemes and on the left hand side of the turnstile
is restricted to so-called solved forms. The set of solved forms, denoted by S, is
always a subset of the satisfiable constraints in X. Given a constraint C appearing
on the left-hand side of the turnstile or in a type scheme, then there must be a
constraint D 2 S such that C =e D which states C; D are semantically equivalent.
The set S clearly affects the number of valid typing judgments for a given HM(X)
instance. For instance, take S to be the empty set. Then there would not be any
valid typing judgments at all. I elaborate more on such issues in Section 3.6.

Unlike in standard treatments of Hindley/Milner style systems, there is also a
subsumption rule (Sub), which allows to derive term e with type o/ 0 if one can derive
term e with type o/ and type o/ subsumes type o/ 0. The subsumption relation _

CHAPTER 3. THE HM(X) FRAMEWORK 22
is determined by the constraint system X, and is assumed to satisfy the standard
axioms for a partial ordering plus the contra-variance rule:

REFL (ff = ff0) `e (ff _ ff0) ^ (ff0 _ ff)

ASYM (ff _ ff0) ^ (ff0 _ ff) `e (ff = ff0)

TRANS

D `e (ff1 _ ff2) D `e (ff2 _ ff3)

D `e (ff1 _ ff3)

CONTRA

D `e (ff01 _ ff1) D `e (ff2 _ ff02)

D `e (ff1 ! ff2 _ ff01 ! ff02)

Except for these conditions, the choice of _ is arbitrary. Please note, that the
subsumption relation _ not necessarily equals the subtyping relation in subtype
systems such as the one considered in Example 6 in Section 3.1.

I maintain that the definition of an instance of the HM(X) system starts with
the definition of an appropriate term algebra T and a constraint system X, which
captures all desired properties and also defines the subsumption relation _. The
definition of the set S of solved forms describes the constraints, which are allowed
to appear in type schemes and typing judgments. It remains to define the set
of primitive functions and record them in the initial type environment \Gamma 0. An
instance of the HM(X) system is defined by the five-tuple (X; _; T ; S; \Gamma 0) to which
I commonly refer as HM(X) or only X for short.

Example 7 The Hindley/Milner system is an instance of the HM(X) type system
framework. Take X to be the Herbrand constraint system over the algebra of types o/ .
Take the set of solved forms to be the set consisting only of true, which is represented
by the empty token set. Take _ to be syntactic type equality. Then the only type
schemes arising in proof trees of valid typing judgments are of the form 8ff:fg ) oe,
which corresponds to Hindley/Milner type schemes 8ff:oe. The subsumption rule
becomes the trivial tautology which states that a judgment can be derived if it can
be derived. It is easy to convince oneself that a judgment \Gamma  ` e : oe is derivable in
Hindley/Milner if and only if fg; \Gamma  ` e : oe is derivable in HM(HERBRAND). It
must be noted that the judgment 2

(ff = fi); fx : ff; y : fig ` x = y : Bool
is not derivable in HM(HERBRAND) because the constraint (ff = fi) is not contained
in the set of solved forms.

2Given the primitive =: 8ff:ff ! ff ! Bool in the initial type environment \Gamma 0.

CHAPTER 3. THE HM(X) FRAMEWORK 23
Example 8 Let X be the constraint system DIM, let the set of solved forms be the
set consisting only of true, and let subsumption _ be the equality relation = in DIM.
Then Kennedy's system can be recovered simply by adding primitives to the initial
type environment \Gamma 0 that deal with dimensions. E.g. I assume that

div : 8d1; d2: dim(d1) ! dim(d2) ! dim(prod(d1; i(d2)))
is contained in \Gamma 0. Other basic connectives are treated analogously.
Example 9 Let X be the subtype constraint system SC and let the subsumption
relation _ be equal to the subtyping relation !:. Let the set of solved forms S be all
satisfiable constraints in SC. For every record fl1 : o/1; : : : ; ln : o/ng in a program, I
add a datatype constructor

l1 : : : ln : o/1 ! : : : ! o/n ! fl1 : o/1; : : : ; ln : o/ng
and for every field label l I add a function

( :l) : fl : o/ g ! o/
to the initial type environment \Gamma 0. The first corresponds to record creation, the
second to record selection. Other basic primitive functions are defined analogously.

The resulting system is related to the subtyping approach of the Hopkins Object
Group [EST95b]. The main difference is that I use logical rules for quantifier introduction and elimination, whereas the Hopkins Object Group use a syntactic approach
where quantifier introduction is coupled with let, and quantifier elimination is coupled
with variable use. They also consider updatable references and variants. If considering only programs involving record operations, then HM(SC) and the subtyping
approach of the Hopkins Object Group type the same set of programs.

3.2.1 Summary
HM(X) instances are described by the five-tuple (X; _; T ; S; \Gamma 0). The term algebra T describes the language of types and the term constraint X the language of
constraints. X furthermore defines the subsumption predicate _. The set of solved
forms S describes the constraints which are allowed to appear in type schemes and
typing judgments. Constraints in S have to be at least satisfiable. Primitive functions are recorded in the initial type environment \Gamma 0.

3.3 Type Soundness
3.3.1 A Denotational Approach
I give a type soundness theorem based on an ideal semantics [MPS86] for HM(X)
type systems. The result holds only for a restricted domain of types, e.g. recursive

CHAPTER 3. THE HM(X) FRAMEWORK 24
types are excluded. A more general result based on a syntactic approach can be
found in the next section.

I show that HM(X) type system instances are sound, provided the underlying
constraint system is sound and the subsumption predicate (_) satisfies a coherence
property. I state a constraint system is sound if every satisfiable constraint has
a monotype solution. Coherence of a constraint system means that if a type o/
subsumes a type o/ 0, then the denotation of o/ in the ideal model is a subset of the
denotation of o/ 0.

Definition 8 A monotype is a type o/ with fv(o/ ) = ;.

I let _ range over monotypes.
Definition 9 A constraint system X is sound if for all type variables _ff and constraints C 2 S, if `e 9 _ff:C then there are monotypes __ such that `e 9 _ff:(( _ff =

__) ^ C).

The soundness proof is based on an ideal semantics of types which is a direct
extension of the semantics in [Mil78].

The meaning of a term is a value in the CPO V, where V contains all continuous functions from V to V and an error element W, usually pronounced "wrong".
Depending on the concrete type system used, V might contain other elements as
well. I require that the values of additional type constructors are representable in
the CPO V. Then V is the least solution of the equation

V = W? + V ! V +

P

k2K (k V1 : : : Varity(k))?

where K is the set of values of an additional type constructor T .

The meaning function on terms is the same as in the original semantics of Hindley/Milner terms. I assume that any language constructs that make use of type
constraints are expressible as predefined values, whose names and types are recorded
in the initial type environment.

[[x]]j = j(x)

[[*u:e]]j = *v:[[e]]j[u := v]
[[e e0]]j = if [[e]]j 2 V ! V ^ [[e0]]j 6= W

then ([[e]]j) ([[e0]]j)
else W

[[let x = e in e0]]j = if [[e]]j 6= W

then [[e0]]j[x := [[e]]j]
else W

CHAPTER 3. THE HM(X) FRAMEWORK 25
I will show in the following that the meaning of a well-typed program is always
different from "wrong".

As a first step, I give a meaning to types. Following [Mil78], I let types denote
ideals, i.e. non-empty, downward-closed and limit-closed subsets of V. The meaning
function [[\Delta ]] maps closed types and type schemes to ideals. On function types and
type schemes it is defined as follows:

[[_1 ! _2]] =

ff 2 V ! V j v 2 [[_1]] ) f v 2 [[_2]]g
[[T _1 : : : _m]] =

f?g [S

fk [[_01]] : : : [[_0n]] j

true; \Gamma 0 ` k : _01 ! : : : ! _0n ! T _1 : : : _mg
[[8 _ff:C ) o/ ]] =T

f[[[__= _ff]o/ ]] j `e [__= _ff]Cg

The following lemma can be proven by a straightforward induction on the structure of oe.

Lemma 6 Let oe be a closed type scheme. Then [[oe]] is an ideal.

Furthermore, I conclude that in a sound constraint system the error element is
not contained in a closed type scheme.

Lemma 7 Given a sound constraint system X and a closed type scheme oe. Then
W 62 [[oe]].

Definition 10 A variable environment j models a closed typing environment \Gamma ,
written j j= \Gamma , if for all x : oe 2 \Gamma , j(x) 2 [[oe]].

Definition 11 The constraint system X is coherent if for all monotypes _ and _0,
if `e (_ _ _0) then [[_]] ` [[_0]].

Furthermore, I need to restrict the set of substitutions which are allowed to
be applied to typing judgments. I repeat the definition of consistency which can
be found in Section 3.4.2. A substitution OE is consistent with respect to a type
scheme oe = 8 _ff:D ) o/ if OED 2 S where I assume there are no name clashes
between _ff and OE. This extends naturally to type environments. Furthermore, a
substitution OE is consistent with respect to a constraint C if OEC 2 S.

Theorem 5 (Type Soundness) Let C; \Gamma  ` e : oe be a valid typing judgment in
HM(X), where X is a sound and coherent constraint system. Let OE be a substitution

CHAPTER 3. THE HM(X) FRAMEWORK 26
such that OE\Gamma  and OEoe are closed and such that `e OEC and OE is consistent in \Gamma . Let
j be a variable environment such that j j= OE\Gamma . Then

(1) W 62 [[OEoe]]
(2) [[e]]j 2 [[OEoe]]

The type soundness theorem can be simplified to top-level programs. As a
corollary, I find Milner's slogan "well types programs do not go wrong" carries over
to sound constraint extensions.

Corollary 2 Let X be a sound and coherent constraint system. Let true; \Gamma  ` e : oe
be a valid closed typing judgment in HM(X). If j j= \Gamma  then [[e]]j 6= W.

Proof: Immediate from (1) and (2) of Theorem 5.

I observe that HM(HERBRAND), HM(DIM) satisfy the requirements. Hence,
these applications are sound. HM(SC) does not satisfy the requirements because
there one finds recursive types. I left out to give an ideal semantics for recursive
types. In the next section, I present a syntactic type soundness result which includes
the treatment of recursive types.

The type soundness result does not seem to apply to systems which are in constraint form, i.e. the set S contains now all satisfiable constraints. As an example
consider a variation of HM(HERBRAND) where the set S contains all satisfiable
constraints. Then, the constraint 9ff:(ff = fi) is in solved form and `e 9ff:(ff = fi),
but there is no monotype _ such that `e (_ = fi). Hence, soundness of the constraint system does not hold anymore. I thank Christoph Zenger for highlighting
this point to me. The problem was that the semantic definition of free variables in a
constraint does not reflect the set of syntactically free type variables. For instance,
fv(9ff:(ff = fi)) = ; but the type variable fi appears syntactically free. But this did
not seem to be an actual problem in case of type soundness. The assumptions of
the type soundness result require it that there must be a substitution OE such that
`e OEC and OE\Gamma  and OEoe are closed. I conjecture that these invariants enforce that
syntactically free type variables in constraint, such as fi in 9ff:(ff = fi), become
always instantiated to monotypes.

To prevent such problems, I put stronger conditions on the constraint system. I
can restate the type soundness result for strongly sound constraint systems. It must
be noted that HM(HERBRAND) where the set S equals all satisfiable constraints
in HERBRAND satisfies the conditions put on a strongly sound constraint system.

Definition 12 A constraint system X is strongly sound iff for all constraints C 2 S
where C = 9 _ff:D where D is projection-free, `e 9fv(D):D then there exists type
variables _ff and monotypes __ such that `e [__= _ff]D.

CHAPTER 3. THE HM(X) FRAMEWORK 27

A constraint D is projection-free if D is a set of primitive predicates.
In fact, I need one further assumption. Projection is not allowed to appear in
syntactic form, i.e. the projection operator does not appear in syntactic form in
constraints which are in solved form. This assumption is rather technical and does
not restrict the result. As stated in Theorem 6 in Section 3.5.2, judgments can always
be transformed into projection-free judgments. Hence, the projection operator is not
necessary to appear in syntactic form to establish the type soundness result. Please
note, projection becomes important in case of type inference.

3.3.2 A Syntactic Approach
The previously described semantics is based on the ideal model [MPS86]. I only
gave a meaning for basic types but excluded for example recursive types. Here, I
give a syntactic type soundness result following the lines of [WF91] which includes
recursive types. Syntactic type soundness for a given instance of the HM(X) is
achieved if every satisfiable constraint has a monotype solution.

As mentioned earlier, the subtyping application HM(SC) relates to the subtyping
approach of the Hopkins Object Group [EST95b]. In [TS96], it is shown that the
regular tree model can be used to express solutions to subtype constraints. Hence,
syntactic type soundness of HM(SC) falls out by adopting the techniques mentioned
in [TS96]. Technically, the type language of HM(SC) needs to be extended with the
top, bottom type and the recursive type constructor _ff to express all constraint
solutions within the type language.

The syntactic soundness result is straightforward along the type soundness result
of functional ML described in detail in [WF91]. Hence, most of the ground-work is
already done. Therefore, I will only give a brief overview how to achieve syntactic
type soundness for HM(X).

The expressions of HM(X) are as follows:

Values v ::= x j c j *x:e
Expressions e ::= v j e e j let x = e in e

Reduction is defined in the standard way:

(ffi) c v \Gamma ! ffi(c; v) if ffi(c; v) is defined
(fiv) (*x:e)v \Gamma ! e[v=x]
(Let) let x = v in e \Gamma ! e[v=x]

I define \Gamma !\Lambda  as the transitive closure of \Gamma !. The partial function ffi allows to
abstract from the precise set of constants. I assume that a constant and a closed
value and yields a closed value. This is along the lines of [WF91].

CHAPTER 3. THE HM(X) FRAMEWORK 28
Definition 13 A constraint system X is strongly sound if for all constraints C 2 S
where C = 9 _ff:D where D is projection-free, `e 9fv(D):D then there exists type
variables _ff and monotypes __ such that `e [__= _ff]D.

Lemma 8 (Subject reduction) Let C; \Gamma  ` e : oe be a valid typing judgment in
HM(X), where X is a strongly sound constraint system. Let OE be a substitution such
that OE\Gamma  and OEoe are closed and such that `e OEC and OE is consistent 3 in \Gamma . Let be
an expression e0 such that e \Gamma !\Lambda  e0. Then true; OE\Gamma  ` e0 : OEoe.

One important observation is that the typing rules preserve satisfiability. This
means the constraints in the conclusion of a typing rule are satisfiable iff the constraints in the premise are satisfiable. This allows to adopt the inductive proof of
the subject reduction stated in [WF91]. Other proofs can be adopted in a similar
way.

In order to state the syntactic type soundness result, I restate the definitions of
faulty expressions and the evaluation function on expressions as stated in [WF91].

An expression e is faulty if there exists a subexpression (c; v) such that ffi(c; v) is
undefined. The evaluation function is defined as follows:

eval(e)
= W if e \Gamma !\Lambda  e0 and e0 is faulty
= v if e \Gamma !\Lambda  v

Conjecture 1 (Syntactic Type Soundness) Let C; \Gamma  ` e : oe be a valid typing
judgment in HM(X), where X is a sound constraint system. Let OE be a substitution
such that OE\Gamma  and OEoe are closed and such that `e OEC and OE is consistent 4 in \Gamma .
Then eval(e) 6= W.

The above result is only stated as a conjecture. I have not formally proven all
steps to establish the syntactic type soundness result. This seems a rather tedious
exercise. I believe that all results found in [WF91] can straightforwardly be adopted.

3.3.3 Summary
The syntactic approach improves over the denotational approach, that is, it gives
a semantic meaning to systems dealing with recursive types. In contrast, the
denotational approach is more abstract. As an example, consider the common
problem with division by zero. In the denotational approach, I can simply denote division by zero by the bottom element ? which is not possible to model in

3A definition can be found in Section 3.4.2.
4A definition can be found right before the semantic type soundness result in Section 3.3.1.

CHAPTER 3. THE HM(X) FRAMEWORK 29
the syntactic approach. None of two approaches provides an efficient compilation
method. Efficient compilation methods have already been studied in the context of
records [Oho97, Oho95, Gas98]. I believe it is rather difficult to develop an efficient
compilation method for general applications.

3.4 Properties
In the first part, I introduce a comparison relation between type schemes. Then,
I define basic definitions. I give some derived typing rules of the logical system
in Figure 3.1 and give normalized derivations. Finally, I talk about nested forall
quantifiers.

3.4.1 Instance Relation
I extend the subsumption predicate _ to type schemes. Subsumption on type
schemes is defined by a deduction system with clauses of the form C `i oe _ oe0,
which state that the type scheme oe is more general than the type scheme oe0 under
the constraint C. The deduction system is defined as follows:

(Sub)

C `e (o/ _ o/ 0)

C `i o/ _ o/ 0

(_ 8)

C ^ D `i oe _ oe0 _ff 62 tv(oe) [ tv(C)

C ^ 9 _ff:D `i oe _ (8 _ff:D ) oe0)

(8 _)

C `i [_o/ = _ff]oe _ oe0 C `e [_o/ = _ff]D [_o/ = _ff] consistent in oe

C `i (8 _ff:D ) oe) _ oe0

The side condition [_o/ = _ff] consistent in oe ensures that the constraints in the
resulting type scheme [_o/ = _ff]oe are still in solved form. See the next section for a
formal definition.

I write C `i oe j oe0 if C `i oe _ oe0 and C `i oe0 _ oe. I refer to the relation `i
as the instance or also as the comparison relation between type schemes.

Based on the ideal semantics described in Section 3.3.1, it is straightforward to
show that the instance relation is sound.

Lemma 9 Given a sound and coherent constraint system X. Given a constraint C,
type schemes oe; oe0 and a substitution OE such that OEoe; OEoe0 closed, OE consistent in oe; oe0,
C `i oe _ oe0 and `e OEC. Then [[OEoe]] ` [[OEoe0]].

CHAPTER 3. THE HM(X) FRAMEWORK 30
Lemma 10 The following inference rules are derivable.

(Ref-oe) C `i oe _ oe
(Weaken)

D `e C C `i oe _ oe0

D `i oe _ oe0

(Trans)

C `i oe1 _ oe2 C `i oe2 _ oe3

C `i oe1 _ oe3

Furthermore it is possible to normalize derivations C `i oe _ oe0 such that all
(8 _) steps are performed before (_ 8) steps. I introduce the following new relation
`i2 which enforces to perform first (8 _) steps and then (_ 8) steps. All rules are
the same except for the (8 _) rule:

(8 _2)

C `i2 [_o/ = _ff]oe _ o/ 0 C `e [_o/ = _ff]D [_o/ = _ff] consistent in oe

C `i2 (8 _ff:D ) oe) _ o/ 0

:

The relations `i and `i2 are equivalent.
Lemma 11 (Equivalence of `i and `i2 ) Let C be a constraint and oe; oe0 be type
schemes. Then C `i oe _ oe0 iff C `i2 oe _ oe0.

I extend the relation `i to type environments.
Definition 14 (Type Environment) Let C be a constraint and \Gamma  and \Gamma 0 be type
contexts such that \Gamma  = fe1 : oe1; : : : ; en : oeng and \Gamma 0 = fe1 : oe01; : : : ; en : oe0ng. Then
C `i \Gamma 0 _ \Gamma  iff C `i oe0i _ oei 8i 2 f1; : : : ; ng.

I introduce an ordering on pairs (C; \Gamma ) where C is a constraint and \Gamma  is a type
environment.

Definition 15 (Constrained Type Environment) Given constraints C and C0
and type environments \Gamma  and \Gamma 0. I refer to tuples (C; \Gamma ) as a constrained type
environment. Furthermore, (C; \Gamma ) ^ (C0; \Gamma 0) iff C `i \Gamma  _ \Gamma 0 and C `e C0.

3.4.2 Basic Definitions
Definition 16 (Realizable) Given a constraint C and a type scheme oe. Then oe
is realizable with respect to C iff there is a o/ such that C `i oe _ o/ .

The set S of solved forms is not necessarily closed under substitutions. The next
definition introduces the notion of consistency which ensures that all substitutions
applied to constraints preserve the property of being in solved form.

CHAPTER 3. THE HM(X) FRAMEWORK 31
Definition 17 (Consistent) Given an HM(X) instance, a constraint C, type scheme
oe and substitution OE. Then substitution OE is consistent with respect to a constraint C
iff OEC 2 S. Substitution OE is consistent with respect to type scheme oe = 8 _ff:D ) o/
iff OED 2 S where w.l.o.g. there are no name clashes between _ff and OE. This extends
naturally to type environments

3.4.3 Derived Typing Rules
The first lemma states that derivation ` is closed under substitution.

Lemma 12 (Substitution) Given C; \Gamma  ` e : oe and a substitution OE such that OE
is consistent with respect to C and \Gamma . Then OEC; OE\Gamma  ` e : OEoe.

Surprisingly, the following result does not hold in general.
Lemma 13 (Weakening) Given C; \Gamma  ` e : oe, a constraint C0 2 S and a type
environment \Gamma 0 such that (C0; \Gamma 0) ^ (C; \Gamma ). Then C; \Gamma 0 ` e : oe.

It states that given a judgment C; \Gamma  ` e : oe, expression e is still derivable with
type oe if a stronger constraint and a stronger type environment is used. Remember,
constraints in typing judgments need to be always in solved form. The problem
occurs in case of the (8 Intro) rule. I assume there is the following derivation:

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

Furthermore, I assume there is a constraint C0 in solved form such that C0 `e
C ^ 9 _ff:D. In order to deduce the judgment C0; \Gamma  ` e : 8 _ff:D ) o/ , I need to show
that C0 ^ D is in solved form. But this does not necessarily hold. Because there
might exist constraints C0; C and D such that D 2 S, C ^ D 2 S, C ^ 9 _ff:D 2 S,
C0 2 S, C0 `e C ^ 9 _ff:D but C0 ^ D 62 S.

There are two ways to fix this problem. I could either add the following additional
rule to the typing rules in Figure 3.1:

(Weakening)

C; \Gamma  ` e : oe C0 `e C C0 2 S

C0; \Gamma  ` e : oe

In fact, this rule needs then also to be added to the derivations in the next
section. The addition of the (Weakening) rule does not contradict any of the previous
results, nor yields any new surprising results. Another possibility would be to put
sufficient conditions on the set S. Given C0; C and D such that D 2 S, C ^ D 2 S,
C ^ 9 _ff:D 2 S, C0 2 S, C0 `e C ^ 9 _ff:D. Then C0 ^ D 2 S. The Weakening

CHAPTER 3. THE HM(X) FRAMEWORK 32
Lemma holds under this condition. All sensible definitions of solved forms satisfy
this condition. Henceforth, I assume that this condition either holds or there is the
additional (Weakening) rule present in the type system.

To establish soundness of the inference system in Chapter 4, I need the following
lemma which is a combination of the Substitution and Weakening Lemma.

Lemma 14 (Substitution and Weakening) Given C; \Gamma  ` e : oe, a constraint
C0 2 S and a substitution OE such that OE consistent in \Gamma  and oe and C0 `e OEC. Then
C0; OE\Gamma  ` e : OEoe.

I can make the same observations as in case of the Weakening Lemma. Therefore,
this lemma holds under the same conditions. I omit the straightforward proof.

3.4.4 Normalized Derivations
I introduce a derivation `n which is based on derivation ` in Figure 3.1. Instead
of rule (8 Elim) there is the following new rule:

(Inst) C; \Gamma  `n x : o/ (x : oe 2 \Gamma  C `i oe _ o/ )
All other rules stay unchanged. Derivation `n simply enforces (8 Elim) steps
as early as possible.

Next, I consider a syntax directed derivation `s . The (8 Intro) rule is combined
with the (Let) rule. Furthermore, the (Var) and (Inst) rules are combined in the
(Var-Inst) rule. The rules can be found in Figure 3.2. In the (Let) rule, I implicitly
require that the constraint C0^C00 is in solved form. Remember, the set of constraints
of solved forms is not necessarily closed under ^.

The next lemmas state how these derivations are connected.

Lemma 15 (Equivalence of ` and `n ) Given a type environment \Gamma , a constraint C, a term e and a type scheme oe. Then C; \Gamma  ` e : oe iff C; \Gamma  `n e : oe0
where `i oe j oe0.

Lemma 16 (Soundness of `s ) Given C; \Gamma  `s e : o/ . Then C; \Gamma  ` e : o/ .

Both lemmas can be proven by straightforward induction.
In the following lemma, it is essential that the type environment \Gamma 0 is realizable.
Recall, a type environment \Gamma 0 is realizable in a constraint C if for every x : oe 2 \Gamma 0
there is a o/ such that C `i oe _ o/ .

Furthermore, I introduce a generalization relation `gen . Given constraints C; Co 2
S, a type environment \Gamma  and types oe; oeo. Then C; \Gamma ; oe `gen (Co; oeo) iff Co =e
9 _ff:C =e C1^9 _ff:C2, oeo = 8 _ff:C2 ) oe, ff 62 fv(C1)[fv(\Gamma ) for some constraints C1; C2.

CHAPTER 3. THE HM(X) FRAMEWORK 33

(Var-Inst) C; \Gamma  `s x : o/ (x : oe 2 \Gamma  C `i oe _ o/ )

(Abs)

C; \Gamma x:x : o/ `s e : o/ 0

C; \Gamma x `s *x:e : o/ ! o/ 0

(App)

C; \Gamma  `s e1 : o/1 ! o/2 C; \Gamma  `s e2 : o/1

C; \Gamma  `s e1e2 : o/2

(Sub)

C; \Gamma  `s e : o/ C `e (o/ _ o/ 0)

C; \Gamma  `s e : o/ 0

(Let)

C; \Gamma x `s e : o/ C; \Gamma x; o/ `gen (C0; oe)

C00; \Gamma x:x : oe `s e0 : o/ 0
C0 ^ C00; \Gamma x `s let x = e in e0 : o/ 0

Figure 3.2: Normalized typing rules
Lemma 17 (Completeness of `s ) Given C0; \Gamma 0 `n e : oe0, C0 `i \Gamma  _ \Gamma 0 and \Gamma 0
is realizable in C0. Then

(a) oe0 = o/ : C; \Gamma  `s e : o/ C0 `e C
(b) otherwise : C; \Gamma  `s e : o/ C; \Gamma ; o/ `gen (oeo; Co)

C0 `e Co C0 `i oeo _ oe

Lemma 18 (Weakening) Given C; \Gamma  `s e : o/ and (C0; \Gamma 0) ^ (C; \Gamma ). Then
C0; \Gamma 0 `s e : o/ .

3.4.5 Nested Forall Quantifiers
The careful reader might have noticed that nested type schemes such as

8ff:(ff !: o/1) ) (8fi:(fi !: o/2) ) ff ! fi)
do not appear in the type system. Although, perfectly well-formed according to the
syntactic domain of type schemes as defined in Section 3.2, such type schemes with
nested forall quantifiers are ruled out. Please consult the typing rules in Figure 3.1.
Rules (8 Intro) and (8 Elim) assume that all type schemes are of the form 8 _ff:C )

CHAPTER 3. THE HM(X) FRAMEWORK 34
o/ , i.e. type schemes appearing in typing judgments do not contain nested forall
quantifiers. 5

The following formulation of quantifier introduction and elimination rule might
be logically more pleasing:

(8 Intro')

C ^ D; \Gamma  ` e : oe ff 62 fv(C) [ fv(\Gamma )

C ^ 9ff:D; \Gamma  ` e : 8ff:D ) oe

(8 Elim')

C; \Gamma  ` e : 8ff:D ) oe C `e [o/ =ff]D [o/ =ff] consistent in oe

C; \Gamma  ` e : [o/ =ff]oe

where [o/ =ff] consistent in oe ensures that all constraints in [o/ =ff]oe remain in solved
form.

Rules (8 Intro') and (8 Elim') allow step by step introduction and elimination of
quantifiers. I omit to formally prove that both styles of formulations are equivalent
and rather give some intuition that it is sufficient to deal only with type schemes of
the form 8 _ff:C ) o/ .

Consider the following derivation which involves two applications of the (8 Intro')
rule where ff and fi are not free in \Gamma  and expression e has type ff ! fi.

(ff !: fi); \Gamma  ` e : ff ! fi
9fi:(ff !: fi); \Gamma  ` e : 8fi:(ff !: fi) ) ff ! fi
true; \Gamma  ` e : 8ff:(9fi:(ff !: fi)) ) (8fi:(ff !: fi) ) ff ! fi)

Application of the (8 Intro) rule would yield:

(ff !: fi); \Gamma  ` e : ff ! fi
true; \Gamma  ` e : 8ff; fi:(ff !: fi) ) ff ! fi

Both type schemes in the final judgment are equivalent:
`i (8ff; fi:(ff !: fi) ) ff ! fi) j (8ff:(9fi:(ff !: fi)) ) (8fi:(ff !: fi) ) ff ! fi))

Similar observations hold for the quantifier elimination rule. Hence, it is sufficient
to deal only with type schemes of the form 8 _ff:C ) o/ .

3.4.6 Summary
I introduced an instance relation C `i oe _ oe0 which allows to compare type
schemes oe; oe0 with respect to a constraint C. I introduced the definitions of realizability and consistency. Furthermore, I discussed derived typing rules and normalized derivations. The normalized derivations will provide to be helpful for the

5Note, higher-order types such as (8ff:ff) ! (8fi:fi ! fi) are not permitted at all.

CHAPTER 3. THE HM(X) FRAMEWORK 35
completeness proof in Section 4.3. In addition, I discussed issues concerning nested
forall quantifiers.

3.5 Constrained Polymorphism
This section considers previous Hindley/Milner style systems that deal with constrained types. All such type systems extend the type judgments \Gamma  ` e : oe of the
original Hindley/Milner system with a constraint hypothesis on the left side of the
turnstile, written C; \Gamma  ` e : oe. Type schemes 8 _ff:o/ of the Hindley/Milner system
are extended with a constraint component; written 8 _ff:C ) o/ to express that the
constraint C restricts the types that can legally be substituted for the bound variables _ff. All type systems have essentially the same rule for eliminating quantifiers,
which is written as follows:

(8 Elim)

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C ` [_o/ = _ff]D

C; \Gamma  ` e : [_o/ = _ff]o/ 0

The rule is a refinement of the corresponding rule in the Hindley/Milner system.
It states that, when instantiating a type scheme 8 _ff:D ) o/ 0, the only valid instances
are those instances [_o/ = _ff]o/ 0 which satisfy the constraint part D of the type scheme.

3.5.1 A Comparison between Different Quantifier Introduction Rules

The HM(X) framework comes with a novel formulation of the quantifier introduction. Constraints are not only bound in type schemes but are additionally bound
by the projection operator in the constraint part of typing judgments:

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

This differs to previous formulations. Figure 3.3 shows four different rules that have
all been proposed in the literature.

I repeat the discussion about different formulations of the quantifier introduction
found in [OSW99]. In [OSW99], the examples are mainly due to Martin Odersky.
In my dissertation, I give further examples of typing situations where problems in
the context of constrained polymorphism might occur and discuss in further detail
the role of the projection operator.

Jones [Jon92] uses a general framework of qualified types for type qualification
with a rule equivalent to rule (8 Intro-Jones). Any constraint can be shifted from
the assumption on the left to the type scheme on the right of the turnstile; it

CHAPTER 3. THE HM(X) FRAMEWORK 36

(8 Intro-Jones)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C; \Gamma  ` e : 8 _ff:D ) o/

(8 Intro-Aiken/Wimmers)

C ^ D; \Gamma  ` e : o/ 9D _ff 62 fv(C) [ fv(\Gamma )

C; \Gamma  ` e : 8 _ff:D ) o/

(8 Intro-Smith)

C ^ D; \Gamma  ` e : o/ C ` [_o/ = _ff]D _ff 62 fv(C) [ fv(\Gamma )

C; \Gamma  ` e : 8 _ff:D ) o/

(8 Intro-HOG)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ D; \Gamma  ` e : 8 _ff:D ) o/

Figure 3.3: Versions of the quantifier introduction rule
is not checked whether the traded constraint is satisfiable. This might lead to
programs that are well-typed as a whole, even though some parts have unsatisfiable
constraints.

To give an example, assume that constraints are subtyping constraints (^) in
a type system with classes and a subtyping relation determined by programmer
declarations. I assume that there is a parametrized class List ff which is a subtype
of type Comparable (List ff), where Comparable is declared as follows:

type Comparable ff = fless : ff ! Boolg
I go on to assume that there is a value Nil of type 8ff:true ) List ff that represents
the empty list. Consider the following (nonsensical) program.

Example 10

let

f: 8ff:(List ff ^ Comparable Bool) ) List ff ! List ff
f x = if x.less(true) then x else Nil
in 1

I use a Haskell-style notation, adding type annotations for illustration purposes.
Using rule (8 Intro-1), the program in Figure 10 is well-typed, even though one
would not expect the constraint in function f's type scheme to have a solution, since
the function type List ff would not be a subtype of Comparable Bool.

CHAPTER 3. THE HM(X) FRAMEWORK 37

In the ideal semantics of types [MPS86] which represents universal quantification
by intersection, f 's type would be an empty intersection. This is equal to the
whole type universe including the error element wrong. However, the whole program
in Figure 10 is still sound because every application of f must provide a valid
instantiation of the constraint. Since the constraint is unsatisfiable, no application
is possible. In essence, Jones treats constraints as proof obligations that have to be
fulfilled by presenting "evidence" at the instantiation site. This scheme is clearly
inspired by Haskell's implementation of overloading by dictionary passing. It runs
into problems if one ever wants to compute a value of a constrained type without
any instantiation sites, as in the following slight variation of Example 10.

Example 11

let

y: 8ff:(List ff ^ Comparable ff) ) Bool
y = Nil.less(true)
in 1

Jones excludes this code on the grounds that y's type is ambiguous, but it is unclear
how to generalize this restriction to arbitrary constraint systems.

Nevertheless, it is possible to integrate Jones' approach into the HM(X) framework, thus giving it a semantic basis independent of dictionary passing. The essential
idea is to consider only constraint systems in which projections of solved constraints
are trivial, i.e `e 9ff:C, for all constraints C that can appear on the left hand side
of the turnstile, and for all type variables ff 2 fv(C). In this case, the (8 Intro) in
HM(X) simplifies to (8 Intro-Jones).

Note that trivial projections correspond well to Haskell's "open world" assumption, which states that the range of possible instance types for an overloaded operation is not fixed in advance. Therefore, one can never rule out that a given constraint
which still has free variables might have a solution.

In the type system of Aiken/Wimmers [AW93], moving a constraint from the
left hand side of the turnstile to the right-hand side is allowed only if the constraint
is satisfiable (i.e. has a solution). Hence, none of the previous examples would be
typable using rule (8 Intro-2), which they use. However, this example is typable.

Example 12

let

f: 8fi:fi ! Int
f x =

let y: 8ff:(List ff ^ Comparable fi) ) Bool

y = Nil.less(x)
in 1
in f true

CHAPTER 3. THE HM(X) FRAMEWORK 38
The constraint List ff ^ Comparable fi has a solution, namely fi = List ff. Therefore,
using rule (8 Intro-2) I can generalize y's type to

8ff:(List ff ^ Comparable fi) ) Bool:
On the other hand, if I substitute the actual parameter true in f's definition, I get
again Example 11 which is not typable under the system with (8 Intro-2). Hence,
the system with (8 Intro-2) does not enjoy the property of subject reduction, which
states that if a term is typable then its reduction instances are typable as well. In
a later version, they use rule (8 Intro-HOG) instead.

In contrast, G. Smith [Smi91] proposed rule (8 Intro-Smith). The traded constraint D must be solvable by instantiation of only the quantified variables _ff. Hence,
the previous mentioned problems would disappear under Smith's system. Smith's
formulation seems however overly restrictive. Consider the following example. I
assume that Comparable has precisely two instances:

Int ^ Comparable Int
Char ^ Comparable Char

Now consider the following program:

Example 13

let

f: 8fi:fi ! Int
f x =

let g y = y.less(x)
in 1
in 1

When typing the definition of g, Smith's system requires a solution of the constraint
o/ ^ Comparable fi, where o/ is y's type. But none of the two possible substitutions
o/ = Int or o/ = Char satisfy the constraint. This shows that Smith's formulation has
problems when typing definitions when no instantiation sites are present.

Another quantifier introduction rule has been suggested by the Hopkins Objects
Group [EST95b]. Constrained D is not only moved from the left-hand side of the
turnstile to the right-hand side, but a copy of D is kept on the left-hand side. This
seems to overcome all previously mentioned problems. However, rule (8 Intro-HOG)
seems strange in that its conclusion contains two copies of the constraint D: one
in which the type variables ff are bound and one in which they are free. Actually,
the Hopkins Objects Group uses a slightly different system in which generalization
is coupled with the let rule and one of the two constraints undergoes a variable

CHAPTER 3. THE HM(X) FRAMEWORK 39
renaming. Nevertheless, rule (8 Intro-HOG) does not seem to apply to systems
which follow the open world approach.

I observe that Jones's formulation of the quantifier introduction rule works well
in systems which follow the open world approach and which use a lazy semantics.
But this formulation has problems when dealing with a strict semantics. Hence,
Jones's formulation supports a "lazy" inference approach. Constraints need only to
be satisfied at instantiation sites. Aiken/Wimmers first formulation of the quantifier
introduction rule does not enjoy a subject reduction property. Smith's and the
Hopkins Object Group's formulation of the quantifier introduction rule follow the
closed world approach. Smith's formulation has problems when typing definitions
first, because then no knowledge about possible instantiation sites is available yet.
This can be seen as a "strict" inference approach, constraints need additionally
satisfied at definition sites. The (8 Intro) rule in HM(X) is capable of modeling all
approaches, simply by the way projection is defined on constraints in solved form.

In the next section, I will study the role of projection in case of an open and a
closed world approach in more detail. In addition, I will point out limitations of the
quantifier introduction rule in the overloading system [OWW95] and Ohori's record
calculus [Oho95]. I will also study the role of the projection operator in solved forms.

3.5.2 Open versus Closed World Systems
This decision between an open and a closed world approach is usually reflected in
the formulation of the quantifier introduction rule. In an open world approach,
one does not have full knowledge about the whole world. There might be some
facts which are not known yet. To be more specific, I consider Haskell style type
classes [VHJW96, Jon92, NP95]. There are constraints of the form C o/ which denotes
that o/ belongs to the class C. Haskell's type class system follows an open world
approach, i.e. even empty type classes are considered legal. Consider the following
typing judgment:

Eq ff; ; ` *x:*y:eq x y : ff ! ff ! Bool
where I assume the type class declaration for the class Eq ff defines an equality
function eq on type ff. I consider the type class approach in style of Nipkow/Prehofer [NP95]. Their quantifier introduction rule essentially reads as follows:

(8 Intro-Nipkow/Prehofer)

D ^ C ff; \Gamma  ` e : oe ff 62 fv(\Gamma ) [ fv(D)

D; \Gamma  ` e : 8ff:C ff ) oe

Then application of the quantifier introduction rule results in the typing judgment:

true; ; ` *x:*y:eq x y : 8ff:Eq ff ) ff ! ff ! Bool (3.1)

CHAPTER 3. THE HM(X) FRAMEWORK 40
I do not know yet whether there is an instance declaration for the type class Eq.
Therefore, the constraint Eq ff is simply traded from the left hand side of the turnstile
into the constraint component of the type scheme.

This is in contrast to a closed world approach. There, I need full knowledge
about the whole world at type checking time. In case of the the above example, I
need to provide an actual instance of class Eq in order to trade the constraint Eq ff
from the left hand side to the right hand side of the turnstile. Smith [Smi91] gave a
formulation of a quantifier introduction rule that models a closed world approach:

(8 Intro-Smith)

C ^ D; \Gamma  ` e : oe ff 62 fv(\Gamma ) C `e [o/ =ff]D

C; \Gamma  ` e : 8ff:D ) oe

The decision for an open or a closed world approach is fixed by the kind of quantifier introduction rule. Recall the (8 Intro-HM(X)) rule. The quantified constraint
is kept in projected form on the left hand side of the turnstile. For instance, in
the above example I keep the constraint 9ff:Eq ff. Depending on how projection
is defined on constraints, an open or a closed world approach is modeled. For instance, an open world approach can be modeled by a constraint rule of the form:
9ff:Eq ff =e true. In such a system, typing judgment 3.1 is derivable. A closed
world can also be modeled easily. I do not specify the above mentioned constraint
rule. But then the constraint 9ff:Eq ff is only satisfiable if there is an actual instance of class Eq ff. Remember, constraints appearing in typing judgments and
type schemes have to be at least satisfiable. Assume there is an instance of class
Eq defined on integers. This is reflected in the constraint system by a rule of the
form: true `e Eq Int. The conditions put on constraint systems in HM(X) yield
Eq Int `e 9ff:Eq ff. Then typing judgment 3.1 is derivable.

I observe that both approaches can easily be modeled within one framework.
Depending on how projection is defined, one or the other approach can be modeled.
Trivial projection leads to an open world approach, whereas non-trivial projection
leads to a closed world approach.

3.5.3 Odersky/Wadler/Wehr Overloading
I consider the overloading system [OWW95] of Odersky/Wadler/Wehr, henceforth
referred to as SystemO, which follows an open world approach. A formal treatment
of their system can be found in Section 5.2. Odersky/Wadler/Wehr consider overloading of functions where overloading is restricted to the argument type. Hence, it
is forbidden to overload numeric constants because the overloaded identifier always
has to be a function type and overloading is restricted to the first argument. Constraints of the form (o :: ff ! o/ ) restrict the possible instances of a type variable ff
for a given overloaded identifier o.

CHAPTER 3. THE HM(X) FRAMEWORK 41

The quantifier introduction rule in SystemO reads essentially as:

(8 Intro-SystemO)

C ^ ssff; \Gamma  ` e : oe ff 62 fv(\Gamma ) [ fv(C)

C; \Gamma  ` e : 8ff:ssff ) oe

and ssff stands for the constraint (o1 :: ff ! o/1)^: : :^(on :: ff ! o/n). Please note, this
rule allows step by step quantification which allows construction of type schemes of
the form

8ff:(o :: ff ! o/1) ) 8fi:(o :: fi ! o/2) ) o/

where fi 62 fv(o/1). The following formulation is equivalent where all free type variables are bound in one step.

(8 Intro-SystemO)

C ^ ss_ff; \Gamma  ` e : o/ _ff 62 fv(\Gamma ) [ fv(C)
there are no i; j 2 f1; : : : ; ng such that j ! i and ffi ! ffj

C; \Gamma  ` e : 8 _ff:ssff ) o/

where ss_ff stands for the constraint

(o11 :: ff1 ! o/11 ) ^ : : : ^ (o1m :: ff1 ! o/1m )^
..
.

(on1 :: ffn ! o/n1 ) ^ : : : ^ (onm :: ff ! o/nm )

where ffi ! ffj iff ffj 62 fv(o/i1 ; : : : ; o/im ) and ffi 6= ffj. The side conditions ensure that
both formulations are equivalent.

This rule can be seen equivalent to the (8 Intro) rule in HM(X). The HM(X)
formulation of SystemO contains constraint rules of the form

9ff:(o :: ff ! o/ ) =e true
which models the open world assumption of SystemO. If projection is not allowed
to appear in syntactic form in S, the formulations of the quantifier introduction rule
in SystemO and the corresponding HM(X) instance are equivalent.

Consider the following program where I assume that there is a function

eq : 8ff:ff ! ff ! Bool
in the initial type environment \Gamma 0.
Example 14

CHAPTER 3. THE HM(X) FRAMEWORK 42

f: 8fi:8ff:(o :: ff ! fi) ) ff ! Int
f x =

let g: fi ! Bool

g = * y. eq (o x) y
in 1

Function g can not be given a polymorphic type. Projection would not be trivial
if one quantifies first over the free type variable fi. In HM(X) projection needs not
necessarily to be trivial. I can then type Example 14 in the following way.

f: 8ff:9fi:(o :: ff ! fi) ) ff ! Int
f x =

let g: 8fi:(o :: ff ! fi) ) fi ! Bool

g = * y. eq (o x) y
in 1

Function g is now of polymorphic type but can not be applied to arguments with
different types. Every overloaded instance is uniquely determined by its argument
type. In the above example, this means that for every ff there can be only one fi such
that we can provide an overloaded instance of the form (o :: ff ! fi). In Section 5.2,
I state that the projection operator does not add any additional expressiveness to
the overloading system SystemO.

Projection becomes useful in an extension of SystemO with curried overloaded
functions. Such a calculus proves to be useful in dealing with printer functions
where one not only can specify the format but also the device. For instance, print :
HP-Printer ! Postscript ! () specifies a print function that supports the Postscript-
format for a specific printer. In the following example, function f takes a device as
a parameter and implements a local IO function.

Example 15

f x =

let g y = print x "Header Information"; print x y

in (g 1, g true)

where the sequencing operator ; is contained as a primitive in the initial type
environment \Gamma 0.

It is not possible to give function g a polymorphic type based on a system using
rule (8 Intro-SystemO), but it is now possible to apply g to arguments of different
type. In HM(X) this example can be typed as follows.

Example 16

f : 8ff:(print :: ff ! String ! ()) ^ (print :: ff ! Int ! ())^

CHAPTER 3. THE HM(X) FRAMEWORK 43

(print :: ff ! Bool ! ()) ) ff ! Int
f x =

let g : 8fi:(print :: ff ! fi ! ()) ) fi ! ()

g y = print x "Header Information"; print x y
in (g 1, g true)

In the next section, I make similar observations in case of Ohori-style records
and provide more details of how the typing judgments can be derived.

I maintain that the projection operator in HM(X) allows to give a semantic
explanation for the open world approach by constraint rules of the form

9ff:(o :: ff ! o/ ) =e true
This was already observed in the previous section. Projection is not necessarily trivial on all constraints in solved forms, for example consider 9fi:(print :: ff ! fi ! ())).
If projection has to be trivial when quantifying over free type variables, this imposes
an ordering relation on the free type variables, see the quantifier introduction rule
in SystemO. This can lead to some limitations. Because of the ordering relation imposed on the free type variables, less programs are typable. The HM(X) formulation
of the quantifier introduction rule overcomes such problems. Similar observations
can be made in case of Ohori-style records.

3.5.4 Ohori Records
I consider Ohori's record calculus [Oho95] 6 which deals with record types of the
form fl1 : o/1; : : : ; ln : o/ng. Polymorphic type variables are kinded, restricting the
possible instantiation types. Type schemes are of the form 8ff:(ff :: k) ) o/ where
type variable ff has kind k. A kind k is either the universal kind U denoting the set
of all types or a record kind ffl : o/ 0gg denoting the set of all record types that contain
a field with label l and type o/ 0. This allows to type various record operations in
a concise way. For instance, the type of the record selection operator is written as
follows:

( :l) : 8ff; fi:(fi :: U ) ^ (ff :: ffl : figg) ) ff ! fi

The function ( :l) takes as an argument any record that contains a field with label
l and extracts the field value associated to l.

Kinded record types have to fulfill some conditions. For instance, each field label
must have a unique type, see Section 5.1 for details.

Ohori's formulation of the quantifier introduction rule is written as follows:

(8 Intro-Ohori)

C ^ (ff :: k); \Gamma  ` e : oe ff 62 fv(\Gamma ) [ fv(C) ff 62 fv(k)

C; \Gamma  ` e : 8ff:(ff :: k) ) oe
6A technical presentation of his calculus can be found in Section 5.1.

CHAPTER 3. THE HM(X) FRAMEWORK 44
where the function fv computes the free variables. Ohori's formulation of the quantifier introduction rule is a close cousin to the formulation found in [OWW95]. Hence,
I can apply a similar reasoning.

Ohori records with overloaded field labels
Given a record calculus where one can overload field labels 7. Then one can deal
with record types of the form

fprint : Int ! (); print : Bool ! (); print : String ! ()g
where () represents the unit type. Each field represents a different implementation
of the print function on integers, booleans and strings. Such a record calculus
might be useful to group related functions into a record. Hence, a record type
can be seen now as the specification for a library. Record selection corresponds to
accessing a specific function supplied in a given library. The above record type could
represent the specification for a library that supplies IO-operations. The technical
presentation of such a calculus can be found in Section 5.1.4.

Consider now the following scenario. The IO-library is passed to a function which
implements a local IO function based on the given IO-library functions. Please
note, the following example is similar to Example 14. This is not surprising because
the record application with overloaded field labels can be encoded in terms of the
overloading application with curried overloaded functions.

Example 17

f x =

let g y = (x:print) "Header Information"; (x:print) y
in (g 1, g true)

where I assume that the pairing operator ( ; ) and the sequencing operator ; are
primitives contained in an initial type environment \Gamma 0. Function g has to be of
polymorphic type because one might want to apply function g to arguments with
different types in the let-body. In the above example, I apply g to an integer and a
boolean.

But such a program is not typable in a calculus based on the (8 Intro-Ohori)
rule. Consider an intermediate derivation. Typing judgments are now extended
with a constraint component on the left hand side of the turnstile.

(ff :: ffprint : fi ! ()gg) ^ (ff :: ffString ! ()gg) ^ (fi :: U );

\Gamma 0:x : ff

`
*y:(x:print) "Header Information"; (x:print) y : fi ! ()
7The technical presentation of such a calculus can be found in Section 5.1.4.

CHAPTER 3. THE HM(X) FRAMEWORK 45

In order to give function g a polymorphic type one has to quantify over type
variable fi. But the side conditions of the (8 Intro-Ohori) rule forbid to quantify
over fi because fi 2 fv((ff :: ffprint : fi ! ()gg)) (or expressed in terms of the constraint language, projection would not be trivial). Hence, Example 17 is not typable
in a system based on the (8 Intro-Ohori) rule.

Remember the quantifier introduction rule in HM(X):

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

In HM(X) it is now possible to quantify over fi. Quantification over fi results in
the constraint 8 9fi:((ff :: ffprint : fi ! ()gg) ^ (fi :: U )) which is kept on the left hand
side of the turnstile. In the let-body I apply function g to two arguments which
results in the constraint

C = (ff :: ffprint : String ! ()gg) ^ (ff :: ffprint : Int ! ()gg)^

(ff :: ffprint : Bool ! ()gg)

because the constraint in the type scheme of function g has to be fulfilled. In HM(X)
I can type Example 17 in the following way:

f : 8ff:C ) ff ! ((); ())
f x =

let g : 8fi:(ff :: ffprint : fi ! ()gg) ^ (fi :: U ) ) fi ! ()

g y = (x:print) "Header Information"; (x:print) y
in (g 1, g true)

Note, the constraint 9fi:((ff :: ffprint : fi ! ()gg) ^ (fi :: U )) disappears because
the constraint (9fi:((ff :: ffprint : fi ! ()gg) ^ (fi :: U )))^ C is semantically equivalent
to the constraint C.

I can conclude that the (8 Intro-Ohori) rule has some limitations, if Ohori's
record calculus is extended with some advanced features such as overloaded field
labels. There are programs where rule (8 Intro-Ohori) forbids quantification over a
type variable. Such programs are now typable within the HM(X) framework.

Nishimura message passing
Recently, there have been a proposal by Nishimura [Nis98] for a calculus where
method names can be passed around as arguments. Method names are treated
as field labels in a record. In a later section, I will show how to encode Ohori's

8Note, (ff :: ffprint : fi ! ()gg)^(fi :: U) corresponds to the constraint D in the above formulation
of rule (8 Intro).

CHAPTER 3. THE HM(X) FRAMEWORK 46
record calculus based on the overloading approach by Odersky et al. Furthermore,
I present an extension of Odersky et al.'s overloading approach with first class overloaded identifiers, i.e. overloaded identifier can now be passed around as arguments,
see Section 5.2.2. Nishimura's record calculus is based on Ohori's record calculus. More specifically, Nishimura's formulation of the quantifier introduction rule is
equivalent to Ohori's formulation. Hence, I can encode his calculus in terms of the
extended overloading application where overloaded identifiers are first class values.
The encoding is done along the lines as for Ohori's calculus.

In Nishimura's calculus, there are problems which are similar to ones discussed in
the previous section. Essentially, I give a recast of Example 17 in terms of a record
calculus with first class field labels. The following program is typable in HM(X) but
not in a calculus based on the (8 Intro-Ohori) rule. The reason is the same as in
Example 17. Projection always has to be trivial in the (8 Intro-Ohori) rule which
does not hold in the following example. Hence, this example would not be typable
in Nishimura's calculus.

Example 18

f : 8ff:(ff :: ffprint int : Int ! ()gg) ^ (ff :: ffprint bool : Bool ! ()gg) ) ff ! ((); ())
f x =

let g: 8print; fi:(ff :: ffprint : fi ! ()gg) ) print ! fi ! ()

g = * print, y . (x.print) y
in (g print int 1, g print bool true)

The function g takes as an additional parameter now an overloaded identifier.
Note, I distinguish between the term variable print and the type variable print (The
same holds for print int and print bool.). The term print has type print. The type
variable print ranges only over overloaded identifiers (Specifically, print ranges only
over field labels, but I assume that the record calculus with first class field labels
is encoded in terms of an overloading application with first class overloaded identifiers.). The constraint ( :: ff : gg) takes now three arguments, a record, a field
and the type of the field in the given record. I use sorts to ensure that the second
argument always has to be an overloaded identifier. This is reflected in the term
algebra which is now multi-sorted.

In fact, Nishimura's calculus is a little bit more restrictive. A method name
(which corresponds to a field label resp. an overloaded identifier) needs always
to be attached to its arguments. I could put stronger conditions on the extended
overloading application to enforce this. In the above example, a method name is
always passed with its argument, hence this example still applies to Nishimura's
calculus.

CHAPTER 3. THE HM(X) FRAMEWORK 47
3.5.5 Projection in Solved Form
I observe that the projection-operator does not need to be present in syntactic
form in case of let-realizable judgments. An expression e is let-realizable iff every variable x defined by a let-statement appears in a monomorphic context. A
judgment C; \Gamma  ` e : o/ is let-realizable iff expression e is let-realizable. A derivation C; \Gamma  ` e : oe is projection-free iff constraint C is projection-free and in all
sub-derivations C0; \Gamma 0 ` e0 : oe0 constraint C0 is projection-free as well.

Theorem 6 (Projection in Solved Form) Given a let-realizable judgment C; \Gamma  `
e : o/ where constraints appearing in \Gamma  are projection-free. Then one can derive
C0; \Gamma  ` e : o/ such that C0; \Gamma  ` e : o/ is projection-free and C0 =e C for some
constraint C0.

Proof: Building of type schemes becomes only important in case of the let-rule.
Given the expression let f = e1 in e2. Assume typing of e1 yields the type scheme
8 _ff:C ) o/ , then the (8 Intro) rule requires that at least the constraint 9 _ff:C must
be kept on the left-hand side of the turnstile. By assumption expression e is let-
realizable. This implies that the type scheme 8 _ff:C ) o/ needs to be instantiated to
type [_o/ = _ff]o/ for some _o/ . But then the constraint, let us refer to it as D, on the left-
hand side of the judgment entails the constraint [_o/ = _ff]C and the constraint 9 _ff:C. It
holds that [_o/ = _ff]C `e 9 _ff:C. Hence, the constraint 9 _ff:C is redundant. Constraints
on the left-hand side of the turnstile can be replaced by a semantically equivalent
constraint,see Lemma 13 in Section 3.4.3. Hence, the constraint 9 _ff:C needs not
to be present in syntactic form on the left-hand side of the typing judgment. This
implies projection needs not to appear in syntactic form. . This holds for all sub-
derivations.

Note that the above lemma crucially relies on the fact that we consider constraints in typing judgments and in type schemes as an equivalence class, i.e. we identify C; \Gamma  ` e : oe with the equivalence class fD; \Gamma  ` e : oe j 9C0 2 S:D =e C =e C0g
(see Section 3.2).

An important implication of the above theorem is summarized in the following
corollary. Projection does not influence typability.

Corollary 3 Given an instance X of the HM(X) framework where S denotes the
set of solved forms. We denote by S 9 the smallest superset of S that is closed under
projection. We consider a variation of X , denoted by X 9 where the set of solved
forms equals S9. Then X and X 9 type the same set of let-realizable programs.

Proof: We need to transform judgments in X 9 into judgments in X . This can be
achieved by applying the above theorem.

Note that the above statement does not imply that projection in syntactic form
can always be omitted. This might affect the expressiveness of the type system. I

CHAPTER 3. THE HM(X) FRAMEWORK 48
only can transform derivable judgments into projection-free judgments. The examples in Section 3.5.3 and 3.5.4 showed that projection appearing in syntactic form
is crucial in some typing situations.

Projection becomes also important when performing type inference. Definitions
commonly are typed first before possible instantiation sites. Hence, projection allows
to overcome problems as exemplified in Example 13 in Section 3.5.1.

3.5.6 Summary
The HM(X) formulation of the quantifier introduction rule improves over previous
formulations. This is achieved by the projection operator which allows to bind
type variables additionally in the constraint part. Previous syntactically formulated
versions of the quantifier introduction rule such as [OWW95, Oho95] gain from the
HM(X) formulation.

3.6 Terms versus Constraints
In this section, I elaborate on two possible representation forms of types. Types
in term form are represented in the language of types (specified by a term algebra) whereas types in constraint form are expressed in the language of constraints
(specified by a term constraint system).

3.6.1 A Motivating Example
I give a type system 9 which is close in spirit to the dimension system given in
Section 3.2. There are list data types which are parameterized in the length of the
list. Compared to other systems, the list constructor List takes as an additional
parameter the length of the list. For simplicity, I assume that all list elements are
of the same type, e.g. Int. Then, I write List i to denote an integer list of length i.
This is quite similar to the dimension type system. Instead of dimensions, there are
now indices.

Indices i ::= ff j + (i; i) j 0 j 1
Types o/ ::= ff j List i j o/ ! o/

The constant constructor 0 represents the zero, and 1 represents the one index.
The constructor +(\Delta ; \Delta ) allows to add indices and obeys the expected algebraic laws,
see Section 3.1 for details. Commonly, I abbreviate +(1; 1) by 2 and so forth.

Consider now the following initial type environment:
9The interested reader can find another example in the Appendix B.2.

CHAPTER 3. THE HM(X) FRAMEWORK 49

\Gamma  = fl1 : List 1;

l2 : List 2;
remove : 8n; m:List +(n; m) ! List n ! List m;

pair : 8t1; t2:t1 ! t2 ! (t1; t2)g

where l1 and l2 are some arbitrary lists of length one and two, remove is a primitive
operation which takes two lists and removes as many elements from the first list
as the second list contains and pair is the pairing operator. Consider the following
expression:

e = *x:let y = remove x in pair(y l1)(y l2)
I can not give function y a polymorphic type if the set S of solved forms consists
of only the true element. In an intermediate step, I find the following judgment:

\Gamma :x : List +(n; m) ` remove x : List n ! List m (3.2)
Indices n and m appear on the left-hand side of the turnstile which prohibits to
quantify over them. Let us assume that S consists now of all satisfiable constraints.
Then I can derive

(ff = +(n; m)); \Gamma :x : List ff ` remove x : List n ! List m
and it is now possible to quantify over indices m and n. Expression e is now typable:

(ff = +(n0; m0)) ^ (n0 = 1) ^ (m0 = fi)^
(ff = +(n00; m00)) ^ (n00 = 2) ^ (m00 = fl);

\Gamma  ` e : List ff ! (List fi; List fl)

Expression e is not typable if S consists only of the true element because the
lambda-variable x with type ff has to satisfy the constraint

(ff = +(n0; m0)) ^ (n0 = 1) ^ (m0 = fi)^
(ff = +(n00; m00)) ^ (n00 = 2) ^ (m00 = fl)

But there is no term representation for ff covering all solutions which are apparent
in the constraint representation. Therefore, I can not give function y a polymorphic type, hence e is not typable in a system where types are represented in term
form. The questions arises over which conditions both views, term respectively constraint form, are equivalent. It will turn out that unitary unification is the key to
establishing a one-to-one correspondence between both representation forms.

CHAPTER 3. THE HM(X) FRAMEWORK 50
3.6.2 Formalizing a Connection between Terms and Constraints

Given a constraint system X over a term algebra T . I define X c as the system
obtained from X where the set S consists of all satisfiable constraints. I refer to
such a system as a constraint-based system and say that the system (respectively
the types) is in constraint form/presentation. I define X t as obtained from X where
the set S might be possibly more restricted. I refer to such a system as a term-based
system and say that the system (respectively the types) is in term form/presentation.
I refer to `X c as the derivation in the constraint-based fragment X c and to `X t as
the derivation in the term-based fragment X t. Please note, both systems, X c and
X t, share the underlying constraint system. There is only a difference in the set S
of solved forms.

I can transform judgments in constraint form to judgments in term form, if there
is a minimal term solution to each satisfiable constraint. I refer to the process of
finding solutions to constraint problems as normalization. I repeat Definitions 23
and 25 found in Section 4.2.

Definition 23 Let X be a term constraint system over a term algebra T and S be
the set of solved constraints in X. Let C 2 S and D 2 X be constraints and let OE,
be substitutions such that (D; OE) is a constraint problem. Then (C; ) is a normal
form of (D; OE) iff OE ^OE0 , C `e OE0D and C = C.

(C; ) is principal if for all normal forms (C0; 0) of (D; OE) it holds that  ^OE0 0
and C0 `e OE0C.

Definition 25 Given a constraint system X over a term algebra T and a set of
solved constraints S in X. The constraint system X has the principal constraint
property if for every constraint problem (D; OE) in X, either (D; OE) does not have a
normal form or (D; OE) has a principal normal form.

The following definition approximates type schemes in constraint form by type
schemes in term form.

Definition 18 Given a type oe in X c and a type oe0 and a constraint C in X t. Then
C ` oe 7! oe0 iff the following two conditions hold

ffl `i oe _ oe0
ffl Given a type oe00 in X t such that C `i oe _ oe00. Then C `i oe0 _ oe00.
The judgment 7! extends to type environments in the usual way.

CHAPTER 3. THE HM(X) FRAMEWORK 51
Theorem 7 (Transformation) Given a constraint system X over a term algebra T and a set S of solved forms such that S is closed under projection and X t
enjoys the principal constraint property, a type environment \Gamma 0 in X t and a constraint C in X t where C ` \Gamma  7! \Gamma 0. Then the following holds.

ffl If C; \Gamma  `X c e : o/ then C; \Gamma 0 `X t e : o/ .
ffl If C; \Gamma  `X c e : oe where oe realizable in C then C; \Gamma 0 `X t e : oe0 where C `

oe 7! oe0.

An immediate consequence is the following corollary. Please note, a substitution
OE = [_o/ = _ff] can also be regarded as the constraint (ff1 = o/1) ^ : : : ^ (ffn = o/n).

Corollary 4 (Substitutions in Constraint Form) Given a constraint system X
over a term algebra T and a set S of solved forms such that S is closed under
projection and X t enjoys the principal constraint property, a type environment \Gamma 0 in
X tand a judgment D ^ OE; \Gamma  `X c e : ff such that (D; OE) is a principal normal form.
Then D; OE\Gamma  `X t e : OE(ff).

I am now in the position to state under which conditions there is a correspondence
between judgments in constraint and term form.

Theorem 8 (Full and Faithful) Given a constraint system X over a term algebra T . If X t satisfies the principal constraint property then every program typable
in X c is typable in X t and vice versa.

In the special case of equational theories, the principal constraint property corresponds to unitary unification. For instance, the motivating example does not satisfy
the principal constraint property. The constraint

(ff = +(n0; m0)) ^ (n0 = 1) ^ (m0 = fi)^
(ff = +(n00; m00)) ^ (n00 = 2) ^ (m00 = fl)

does not have a most general unifier. Remember, there is not a minus constructor
in the index theory. Adding the minus constructor to the theory would allow to
represent ff in term form. But this would only fix the problem for this specific
example. The index theory still does not satisfy the principal constraint property.

3.6.3 Summary
The constraint-based formulation of type systems is more expressive than the term-
based formulation. That means, typing information represented in constraint form
improves over the term presentation. Principal normal forms represent best solutions

CHAPTER 3. THE HM(X) FRAMEWORK 52
of constraint problems (D; OE). In the presence of best solutions (the principal constraint property holds), the constraint-based and term-based formulation of types
systems are equivalently expressive. Another observation is that given a derivation
D ^ OE; \Gamma  `X c e : ff in the constraint-based system where (D; OE) is a principal normal
form. Then also D; OE\Gamma  `X t e : OE(ff) is derivable in the term-based system.

3.7 Logical System in Constraint Form
I present a variation of the HM(X) framework where all typing information is represented in constraint form. The motivation is to give the cleanest possible presentation for such a system. I only highlight the main differences to the original
presentation. I commonly refer to the original presentation as the term presentation
and to the new presentation as the constraint presentation.

I work with the following syntactic domains.

Values v ::= x j c j *x:e
Expressions e ::= v j e e j let x = e in e
Types o/ ::= ff j o/ ! o/
Type schemes oe ::= o/ j 8ff:C ) oe

The set of values and expressions remains unchanged, whereas in the syntactic
domain of types I only admit type variables and function types. All other types
must be represented in the constraint language. I require that constraints on the
left-hand side of typing judgments and in type schemes must be satisfiable. Recall, a
constraint C is satisfiable if `e 9fv(C):C. This is the only requirement which I put
on constraints which differs to the term presentation. There, I could possibly further
restrict the set of constraints which appear in typing judgments and type schemes.
For instance, in order to model the Hindley/Milner only the empty constraint fg
(representing true) is allowed to appear in typing judgments. This was motivated
by the term representation of types in the Hindley/Milner system. Here, I prefer
a constraint presentation of types. This change implies the occurrence of explicit
equality constraints in the HM(X) system in constraint form, which were represented
as substitutions in the term presentation.

The typing rules can be found in Figure 3.4. I assume that type schemes are
equivalent up to renaming of bound type variables. Technically, I consider a type
scheme 8 _ff:C ) o/ as an equivalence class where the equivalence relation , is defined
as follows: (8 _ff:C1 ) o/1) , (8 _fi:C2 ) o/2) if [_fl= _ff]C1 =e [_fl= _fi]C2 and [_fl= _ff]o/1 =
[_fl= _fi]o/2 where _fl are fresh type variables and = stands for syntactic equality.

If not otherwise stated, most of the properties carry over from the HM(X) system
in term form to the HM(X) system in constraint form. For instance, judgments are
still closed under strengthening the constraint.

CHAPTER 3. THE HM(X) FRAMEWORK 53

(Var) C; \Gamma  ` x : oe (x : oe 2 \Gamma )
(Sub)

C; \Gamma  ` e : o/ C `e (o/ _ o/ 0)

C; \Gamma  ` e : o/ 0

(Abs)

C; \Gamma x:x : o/ ` e : o/ 0

C; \Gamma x ` *x:e : o/ ! o/ 0

(App)

C; \Gamma  ` e1 : o/1 ! o/2 C; \Gamma  ` e2 : o/1

C; \Gamma  ` e1e2 : o/2

(Let)

C; \Gamma x ` e : oe C; \Gamma x:x : oe ` e0 : o/ 0

C; \Gamma x ` let x = e in e0 : o/ 0

(8 Intro)

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

(8 Elim)

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C `e 9 _ff:D

C ^ D; \Gamma  ` e : o/ 0

(9 Intro)

C; \Gamma  ` e : oe _ff 62 fv(\Gamma ) [ fv(oe)

9 _ff:C; \Gamma  ` e : oe

Figure 3.4: Logical type system in constraint form
Lemma 19 (Weakening) Given a judgment C; \Gamma  ` e : oe and a satisfiable constraint D such that D `e C. Then D; \Gamma  ` e : oe.

I give a brief description of the typing rules and point out only the changes compared to the formulation in term form. Rules (Var) to (8 Intro) remain unchanged
whereas I reformulated rule (8 Elim) and introduced the new rule (9 Intro).

Rule (8 Elim) differs compared to the formulation in term form which was previously as follows:

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C `e [_o/ = _ff]D

C; \Gamma  ` e : [_o/ = _ff]o/ 0

CHAPTER 3. THE HM(X) FRAMEWORK 54

This rule exhibits the influence of the term-based approach. Type instances
are generated by substituting bound type variables. Here, I give up the concept of
substitutions (besides variable renaming). Satisfiability of the constraint part of the
constraint is ensured via the side condition C `e 9ff:D. It would be possible to
adopt the constraint-based formulation of the (8 Elim) rule to the original HM(X)
formulation, i.e. the HM(X) system in term form. Both formulations are essentially
equivalent as stated in the following lemma.

Lemma 20 (Equivalence of Quantifier Introduction Rules) Given an instance
of the HM(X) system in term form. If the judgment C; \Gamma  ` e : oe is derivable using the constraint-based (8 Elim) rule then C; \Gamma  ` e : oe is derivable using the
substitution-based formulation of the (8 Elim) rule instead. The reverse direction
holds, too.

Rule (9 Intro) is motivated by the following logical rule: 8ff:(P ! Q) = (9ff:P ) !
Q where ff 62 fv(Q). The outermost forall quantification of the free type variable ff
in the judgment C; \Gamma  ` e : oe can be moved to the constraint part, if ff does only
appear in the constraint part. This hides type variables which only appear in the
constraint part of typing judgments.

Rules (8 Elim) and (9 Intro) evolved out of a discussion with Martin M"uller.
Rules (Abs) and (App) require the presence of function types in the syntactic
domain of types. It would be possible to give a formulation of the typing rules where
only type variables appear in the syntactic domain of types. However, the current
formulation looks more aesthetic, I need to admit function types in the domain of
types. There is no difference in the logical properties of the two formulations. It is
only a matter of taste whether to allow additionally function types in the domain of
types or not. The following lemma shows that one can always put typing judgments
in canonical form.

Lemma 21 (Canonical Form) Given a constraint C, a type environment \Gamma , a
term e and a type o/ . Then C; \Gamma  ` e : o/ iff C ^ (ff = o/ ); \Gamma  ` e : ff where ff is a fresh
type variable.

3.7.1 Summary
I gave a logical presentation of the HM(X) system where all typing information is
represented in constraint form. The motivation was to give the cleanest possible
presentation for such a system.

Chapter 4
Type Inference in HM(X)

The task of the inference system is to infer a type for a given term e. I consider
an inference system in compositional style. Expressions are composed of smaller
subexpressions for which the inference system already inferred its types. As an
example, consider the function application e1e2 where e1 has the inferred type o/1
and e2 has the inferred type o/2. For the moment, let us consider the standard
Hindley/Milner system. The typing problem e1e2 is transformed into the constraint
problem (o/1 = o/2 ! ff). The fresh type variable ff corresponds to the yet unspecified result type of the application e1e2. Constraint solving in the standard
Hindley/Milner system corresponds to Herbrand unification. The situation is different in case of an extension of the Hindley/Milner system with subtypes. The typing
problem e1e2 is transformed into the constraint problem (o/1 !: o/2 ! ff). Then
solving a constraint problem means simply whether the constraint is satisfiable or
not.

In both cases, constraint generation remains similar. It involves accumulation
of either equality or subtype constraints. In general, constraint generation means
accumulation of subsumption constraints. But the form of constraint solving differs.
Depending on the structure of the set S of solved forms, constraint solving might
involve more sophisticated methods than Herbrand unification or a satisfiability test.
In the latter, I refer to constraint solving as constraint normalization.

Hence, type inference consists of two phases: constraint generation and constraint normalization. I provide a generic type inference algorithm which is parameterized in the constraint solver. A characterization of minimal constraint solutions is
given in Section 4.2. In such cases, I say the constraint system possess most general
normalizers. One would expect to infer principal types if the constraint solvers computes most general normalizers. But there is a subtlety first discovered by Andrew
Kennedy [Ken96] who gave the following example.

55

CHAPTER 4. TYPE INFERENCE IN HM(X) 56
4.1 A Problem when Inferring Principal Types
Kennedy introduces a Hindley/Milner style system that deals with physical dimensions. In addition to the usual types, there are dimension types. The term algebra
of dimension types is defined as follows:

Dimensions d ::' ff j i(d) j prod(d; d) j 1 j M j T
Types o/ ::= ff j dim(d) j o/ ! o/

The dimension constructor i(\Delta ) corresponds to the inverse of a dimension and
prod(\Delta ; \Delta ) to the product of two dimensions. Dimension constants are 1 for the unit
measure, M for the mass dimension and T for the time dimension. For specific
applications there might be further dimension constants. Please consult Section 3.1
and Section 3.2 for further description of the dimension type system.

Consider the following initial type environment:

\Gamma  = fkg : dim M;

s : dim T;
div : 8d1; d2: dim prod(d1; d2) !

dim d1 ! dim d2;
pair : 8t1; t2:t1 ! t2 ! (t1; t2)g

Here, kg and s are some basic dimensions, pair is the pairing operator and div is a
primitive operation on dimensions. Consider the following expression:

e = *x:let y = div x in pair(y kg)(y s)
Function y is applied to arguments of different type, hence needs to be of polymorphic type. The subexpression div x has the following type under type environment
\Gamma :x : dim prod(d1; d2) :

\Gamma :x : dim prod(d1; d2) ` div x : dim d1 ! dim d2 (4.1)
It is not possible to quantify over the type variables d1 and d2 because d1 and d2
also appear in the type environment. But I can derive another type for div x under
the same type environment:

\Gamma :x : dim prod(d1; d2)

`
div x : dim prod(d1; d3) ! dim prod(i(d3); d2)

(4.2)

Judgment 4.2 is obtained from 4.1 by instantiating d1 with prod(d1; d3) and
d2 with prod(i(d3); d2). Dimension types obey the laws of an abelian group. For
instance, it holds that

`e (prod(prod(d1; d3); prod(i(d3); d2)) = prod(d1; d2))

CHAPTER 4. TYPE INFERENCE IN HM(X) 57
Therefore, the type environment in 4.2 remains the same and now it is possible to
quantify over the free type variable d3. Then program e becomes typable.

\Gamma  ` e :
8d1; d2: dim prod(d1; d2) !
(dim prod(i(M); prod(d1; d2));
dim prod(i(T); prod(d1; d2)))

(4.3)

The theory of dimension types possesses most general unifiers. There is a decidable algorithm that computes the most general unifier, see [LBB84]. Hence, one
would expect that type inference yields principal types. Unfortunately, it turns out
that the standard type inference algorithm fails to infer principal types. In case of
dimension types, there are several different representation types for a given term
under the same type environment, see judgments (4.1) and (4.2). If one chooses a
wrong representation, it might not be possible to type the rest of the program. In the
above example, I first had to apply a substitution to reveal the free type variable d3.
It it crucial that this substitution leaves the type environment unchanged.

Consider now a variation of the dimension type system where dimension types
are allowed to appear in constraint form, i.e. the set S consists now of all satisfiable
constraints. Then, I find the following variation of typing judgment (4.2).

(ff = prod(d1; d2)); \Gamma :x : ff ` div x : dim d1 ! dim d2
If I would unify the constraint (ff = prod(d1; d2)), I would obtain judgment (4.2)
again. But I keep constraints in explicit form and then type variables d1 and d2
do not appear anymore in the type environment. I can quantify over these type
variables. The function y has now the desired polymorphic type

8d1; d2:(ff = prod(d1; d2)) ) dim d1 ! dim d2
The following typing judgment is a variation of judgment (4.3).

(ff = prod(d01; d02)) ^ (d01 = M) ^ (d02 = fi)^

(ff = prod(d001; d002)) ^ (d001 = T) ^ (d002 = fl);

\Gamma  ` e : dim ff ! (dim fi; dim fl)

For instance, the constraint

(ff = prod(d01; d02)) ^ (d01 = M) ^ (d02 = fi)
appears by applying the term y to kg.

In a system in constraint form, e has type dim ff ! (dim fi; dim fl) under the
constraint

(ff = prod(d01; d02)) ^ (d01 = M) ^ (d02 = fi)^

(ff = prod(d001; d002)) ^ (d001 = T) ^ (d002 = fl)

It must be noted that unification of the above constraint would yield judgment 4.3

CHAPTER 4. TYPE INFERENCE IN HM(X) 58
4.1.1 Summary
I observe that standard inference performs unification eagerly. After each inference
step the unification procedure is invoked. Then standard inference fails to infer
principal types even in the presence of most general unifiers. This is exemplified by
Kennedy's example. It turns out that this is only a problem for regular theories.
A theory is non-regular if there exists types o/ , o/ 0 such that `e (o/ = o/ 0) and fv(o/ ) 6=
fv(o/ 0). Dimension types form a non-regular theory. It holds that `e (prod(ff; i(ff)) =
1) but fv(1) = ;. The idea is now to present types in constraint form which overcomes
the above mentioned problems.

4.1.2 Outline
In Section 4.3, I consider an extension of the standard inference algorithm to more
general constraint domains. Instead of unification, inference is based on the concept
of normalization. Normalization is performed in each inference step. This implies
that type terms are constructed eagerly. I also call this form of inference term-
based inference respectively inference in term form. 1 Complete inference can then
only be achieved for regular theories. Section 4.4 considers inference in constraint
form. The constraint-based inference system leads to an adaption of the term-
based inference system. The basic idea is to represent types in constraint form in
intermediate inference step. The actual normalization step (that means, switching
from the constraint representation of types back to the term representation) happens
only at the end. This allows to infer principal types in term form even for non-regular
theories. The technical difficulty is then to show that type inference is still sound.

Preliminary results can already be found in [OSW99]. The main improvement is
the introduction of the purely constraint-based inference approach and the solution
of the inference problem for non-regular theories.

4.2 Normalization
I start with some preliminary definitions. The main novelty is the introduction of
the concept of normalization and most general normalizers to which I also refer as
principal normal forms.

Definition 19 (Equational Theory) An equational theory E over a term algebra
T is a constraint system where for each o/; o/ 0 2 T there is an equality predicate
(o/ = o/ 0) and (\Delta  = \Delta ) is a congruence relation. An equational theory E is regular iff
for each o/; o/ 0 2 T such that `e (o/ = o/ 0), then fv(o/ ) = fv(o/ 0).

1It would also be appropriate to refer to this kind of inference as substitution-based inference
because a type term o/ can always be seen as the substitution [o/ =ff] where ff is a fresh type variable.

CHAPTER 4. TYPE INFERENCE IN HM(X) 59

Please note, a term constraint system X implies an equational theory E. I refer
to E as the underlying equational theory of X.

Definition 20 (Substitutions) Given an equational theory E over a term algebra T . Given a substitution OE and a domain U of variables. Then dom(OE) =
fff j OE(ff) 6= ffg denotes the domain of OE and codom(OE) = ffi j 9ff 2 dom(OE):fi 2
fv(OE(ff))g denotes the codomain of OE. Let OEjU be the restriction of the substitution OE
to the domain U . That is, OEjU (x) = OE(x) iff x 2 U and OEjU (x) = x otherwise. For
substitutions OE and , I write  =U OE iff `e ((x) = OE(x)) for all x 2 U . I write
 ^OE

0

U OE iff OE0 ffi  =U OE. I write  ^U OE iff there exists OE0 such that  ^OE

0 OE.  =

U OE

iff  ^U OE and OE ^U . In general, I omit the set U .

It follows from [LMM87] that ^U is a complete lower semi-lattice where least
upper bounds, if they exist, correspond to unifications and greatest lower bounds
correspond to anti-unifications.

Definition 21 (Unitary unification) Given an equational theory E. Then E enjoys unitary unification iff for substitutions OE and , either their least upper bound
exists, or there is no upper bound at all. The least upper bound of OE and  is denoted
by OE t .

I also state that a constraint system X enjoys unitary unification if the underlying
equational theory in X enjoys unitary unification.

The Herbrand constraint system HERBRAND enjoys unitary unification as
shown by Robinson [Rob65]. Another example is the dimension system described
in Section 3.1. In [Ken94], Kennedy shows (based on work by [LBB84]) that the
dimension system enjoys unitary unification.

I extend the relation ^ on substitutions to constraint problems.

Definition 22 (Constraint Problems) Given a constraint system X over a term
algebra T . Given a constraint C in X and a substitution . The pair (C; ) is called
a constraint problem iff C = C. (D; OE) = (D1; OE1) t (D2; OE2) is the combination of
the constraint problems (D1; OE1) and (D2; OE2) iff OE = OE1 t OE2 and D = OE(D1 ^ D2).
(C; OE) ^ (C0; OE0) iff there exists a substitution  such that OE ^ OE0 and C0 `e C,
and (C; OE) = (C0; OE0) iff (C; OE) ^ (C0; OE0) and (C0; OE0) ^ (C; OE). This makes ^ a
partial ordering relation on constraint problems.

I refer to CP as the set of constraint problems in X.

Lemma 22 Given a constraint system X over a term algebra T such that X enjoys
unitary unification. Then (CP ; ^) is a complete lower semi-lattice where least upper
bounds exist.

CHAPTER 4. TYPE INFERENCE IN HM(X) 60

Normalization means then computation of a normal form of a constraint problem (C; ).

Definition 23 (Principal Normal Form) Let X be a term constraint system over
a term algebra T and S be the set of solved constraints in X. Let C 2 S and D 2 X
be constraints and let OE, be substitutions such that (D; OE) is a constraint problem.
Then (C; ) is a normal form of (D; OE) iff OE ^OE0 , C `e OE0D and C =e C, or
equivalently (D; OE) ^ (C; ).

(C; ) is principal if for all normal forms (C0; 0) of (D; OE) it holds that  ^OE0 0
and C0 `e OE0C, or equivalently (C; ) ^ (C0; 0).

The principal normal form represents the best solution of a constraint problem.
As an example, consider the constraint system HERBRAND. In it, a principal
normal form corresponds to a most general unifier and a normal form corresponds
to a unifier of a constraint problem.

Lemma 23 (Uniqueness) Given a constraint problem (D; OE) and two principal
normal forms (C; ) and (C0; 0) of (D; OE). Then (C; ) = (C0; 0).

The above lemma follows trivially. Please note, uniqueness only states uniqueness
modulo semantic equivalence. Hence, a principal normal form should be seen as
an equivalent class. Nevertheless, it is possible to define a well-defined function
normalize from constraint problems (D; OE) to normal forms:

normalize(D; OE)
= (C; ) if (C; ) principal normal form of (D; OE)
= fail otherwise

Principal normal forms are syntactically unique if the set of solved forms satisfies
the syntactic uniqueness property.

Definition 24 (Syntactic Uniqueness Property) Given a set S of solved forms.
Then S satisfies the syntactic uniqueness property if given C 2 S there is no other
constraint D 2 S such that C =e D.

Lemma 24 (Syntactic Uniqueness) Given a set S of solved forms such S satisfies the syntactic uniqueness property, a constraint problem (D; OE) and two principal
normal forms (C; ) and (C0; 0) of (D; OE). Then (C0; ) can be retrieved from (C; )
simply by variable renaming.

Please note, checking whether a set of solved forms satisfies the syntactic uniqueness property is a non-trivial task. It requires a decidable entailment test. For
instance, in case of subtyping, it is not know yet whether entailment is decidable or
not [Pot98].

The property of having a principal normal form extends to constraint systems.

CHAPTER 4. TYPE INFERENCE IN HM(X) 61
Definition 25 (Principal Constraint Property) Given a constraint system X
over a term algebra T and a set of solved constraints S in X. The constraint system
X has the principal constraint property if for every constraint problem (D; OE) in X,
either (D; OE) does not have a normal form or (D; OE) has a principal normal form.

I state that a constraint system possesses most general normalizers if the constraint system satisfies the principal constraint property. I also state that the HM(X)
type system has the principal constraint property if X has the principal constraint
property.

In Section 5.1, I discuss in detail a type system for Ohori-style records that
satisfies the principal constraint property. This example belongs to a class of constraint systems where constraint solving involves some form of unification. Further
examples of constraint systems of this kind are HERBRAND and DIM. In general,
there are already a wide range of unification procedures [BS94]. But mostly they
work on more restricted constraint domains, e.g. the projection operator does not
appear in the constraint language. In the next section, I show how these unification
procedures can be lifted to become normalization procedures in HM(X).

The situation is different in case of the constraint system SC. The set S of solved
forms consists of all satisfiable constraints. Given a constraint problem (D; OE) I
distinguish between two cases. If OED is unsatisfiable then (D; OE) does not have a
normal form. Assume OED is satisfiable then (OED; id) is the principal normal form of
(D; OE). Given another normal form (D0; OE0) of (D; OE). Then it holds that OE ^OE00 OE0
and D0 `e OE00D. But then it follows immediately that (OED; id) is principal. I
conclude that the constraint system SC satisfies the principal constraint property,
and that a normalize function can be defined as follows:

normalize(C; OE)
= (OEC; id) if OEC is satisfiable
= fail otherwise

The normalization function is computable since satisfiability in SC is decidable.
This follows easily by adapting techniques developed in [TS96].

I elaborate more on the algebraic properties of the computation of principal normal forms in case the principal constraint property holds and unification is unitary.
Systems where the set of solved forms is equation-free represent an important class
because they enable type inference based on unification.

Definition 26 (Equation-free) Given a constraint system X over a term algebra
T and a set S of solved forms. Then S is in equation-free iff for each C 2 S if
C `e (o/ = o/ 0) then `e (o/ = o/ 0). In such a situation, I refer to S as the set of
solved and equation-free forms.

CHAPTER 4. TYPE INFERENCE IN HM(X) 62
Lemma 25 Given a constraint system X over a term algebra T and a set S of
solved forms such that S is equation-free. Then X enjoys unitary unification.

The next lemmas lead to the conclusion that normalization can be performed in
arbitrary order.

Lemma 26 Given two constraint problems (D; OE) and (D0; OE0), a principal normal
form (C; ) of (D0; OE0) and a principal normal form (C0; 0) of (D; OE) such that
(C; ) is also a normal form of (D; OE) and (C0; 0) is also a normal form of (D0; OE0).
Then (C; ) is a principal normal form of (D; OE) and (C0; 0) is principal normal
form of (D0; OE0).

Lemma 27 Given a constraint system X over a term algebra T and a set of solved
constraints S in X such that X enjoys the principal constraint property and unitary
unification. Given constraint problems (D1; OE1) and (D2; OE2) such that dom(OE1) "
codom(OE2) = ;, dom(OE2) " codom(OE1) = ;, fv(D1) " dom(OE2) = ; and fv(D2) "
dom(OE1) = ;. Let (C; ) be the principal normal form of (D1; OE1) t (D2; OE2). Then
the principal normal form (C1; 1) of (D1; OE1) exists and (C; ) is a normal form
of (C1; 1) t (D2; OE2).

Lemma 28 Given a constraint system X over a term algebra T and a set of solved
constraints S in X such that X enjoys the principal constraint property and unitary
unification. Given constraint problems (D1; OE1) and (D2; OE2) such that dom(OE1) "
codom(OE2) = ;, dom(OE2) " codom(OE1) = ;, fv(D1) " dom(OE2) = ; and fv(D2) "
dom(OE1) = ;. Let (C1; 1) be the principal normal form of (D1; OE1) and (C; ) be
the principal normal form of (C1; 1) t (D2; OE2). Then (C; ) is a normal form of
(D1; OE1) t (D2; OE2).

Theorem 9 (Eager versus by Need Normalization) Given a constraint system X over a term algebra T and a set of solved constraints S in X such that X enjoys
the principal constraint property and unitary unification. Given constraint problems
(D; OE) and (D0; OE0) such that dom(OE1) " codom(OE2) = ;, dom(OE2) " codom(OE1) = ;,
fv(D1) " dom(OE2) = ; and fv(D2) " dom(OE1) = ;. Then

normalize((D; OE) t (D0; OE0))

=
normalize(normalize(D; OE) t D0; OE0)

Proof: The equation normalize((D; OE) t (D0; OE0)) = normalize(normalize(D; OE) t
D0; OE0) states that if the left-side holds the right-side follows and vice versa. Please
note, Lemma 26 allows to strengthen the result of Lemmas 27 and 28 to principal
normal forms.

CHAPTER 4. TYPE INFERENCE IN HM(X) 63
4.2.1 Lifting of Normalization
One of the improvement of the HM(X) framework is the projection operator which
allows for a binding of type variables in the constraint part. The normalization
procedure in HM(X) has to deal with projected constraints. whereas previously
normalization only had to deal with projection-free constraints.

Definition 27 (Projection-free) A constraint C is projection-free iff C considered as a set consists only of primitive predicates.

Normalization in the special case of equality constraints has already been widely
studied in the literature. There exits a wide range of results, I only mention [BS94].
In the following, I give a method on how to lift normalization procedures for projection-
free constraints to the general case. Lifting holds under some sufficient conditions.

Definition 28 (Lifting Property) Given a constraint system X over a term algebra T and a set S of solved forms. X satisfies the lifting property iff the following
conditions hold:

1. There exists a computable procedure normalize such that for each constraint

problem (D; OE) where D is projection-free, normalize(D; OE) = (C; ) and
(C; ) is the principal normal form of (D; OE), or normalize(D; OE) reports failure if (D; OE) does not have a normal form at all.

2. S is equation-free and this is the only condition imposed on S.
3. Given a constraint problem (D; OE) and a normal form (C; ) then C = D.
4. For each 9 _ff:C 2 S there exist _o/ and D 2 S such that [_o/ = _ff]C = D 2 S.
Remark 3 Condition (2.) states that the set of solved forms only property is being
equation-free (being satisfiable is always implicitly assumed). In case of the Hindley/Milner system, this would allow the constraint 9ff:(ff = fi) (which is equation-
free) being in solved form. Obviously, such constraints are redundant. Lifting still
applies if the set of solved forms satisfies the syntactic uniqueness property, see Definition 24.

The next two lemmas are the key lemmas to lift normalization procedures on
projection-free constraints to the general case.

Lemma 29 (Lifting of Normal Forms) Given a constraint system X over a term
algebra T and a set S of solved forms such that X satisfies the lifting property. Given
a constraint problem (9 _ff:D; OE). Then (9 _ff:D; OE) does have a normal form iff (D; OE)
does have a normal form.

CHAPTER 4. TYPE INFERENCE IN HM(X) 64
Lemma 30 (Lifting of Principal Normal Forms) Given a constraint system X
over a term algebra T and a set S of solved forms such that X satisfies the lifting
property. Given a constraint problem (9 _ff:D; OE). Let (C; ) be the principal normal
form of (D; OE). Then (9 _ff:(ss ffi n_ff)D; (ss ffi n_ff)) is the principal normal form of
(9 _ff:D; OE) where ss = [ _fi= _ff] and _fi are new.

Lemma 29 allows a reduction of the existence check of normal forms to the base
case of projection-free constraint problems. Lemma 30 allows a computation of
principal normal forms based on the normalization procedure for projection-free
constraints.

Theorem 10 (Lifting of Normalization) Given a constraint system X over a
term algebra T and a set S of solved forms such that X satisfies the lifting property.
Then X satisfies the principal constraint property.

The dimension system in Section 3.1 is an example of a system which satisfies
the lifting property. Further examples are discussed in Section 5.1.

4.3 Inference in Term Form
I connect the principal constraint property of a constraint system with the principal
types property of a type system. Figure 4.1 gives a generic type inference algorithm
that computes principal types, if the constraint system satisfies the principal constraint property and some additional restrictions. 2 The algorithm is formulated as
a deduction system over clauses of the form ; C; \Gamma  `W e : o/ with type environment
\Gamma , expression e as input values and substitution , constraint C, type o/ as output
values. For each syntactic construct of expressions e there is one clause. The deduction rules can be interpreted operationally, as a logic program that constructs a
bottom-up derivation of `W clauses.

In the (Var) rule, I assume that an unqualified type o/ can be represented as
8;:true ) o/ . This avoids a separate case of this rule for unqualified types. In
rules (App) and (Let) I combine the results of the premises and build the conclusion
if normalization succeeds. All three rules make use of the function normalize, specified in the last subsection. The deduction rules yield an algorithm only if normalize
is computable. In the following, I assume that the normalization functions is computable.

The type inference algorithm `W is a straightforward extension of algorithm W,
see [DM82]. The algorithm `W consists of the following three basic components:
constraint generation, constraint normalization and generalization of unbound type

2Here, I consider inference in term form which has some problems as pointed out earlier, see
Section 4.1

CHAPTER 4. TYPE INFERENCE IN HM(X) 65

(Var)

x : (8 _ff:D ) o/ ) 2 \Gamma  _fi new
(C; ) = normalize([ _fi= _ff]D; [ _fi= _ff])

jfv(\Gamma ); C; \Gamma  `W x : o/

(Abs)

; C; \Gamma x:x : ff `W e : o/ ff new

nfffg; C; \Gamma x `W *x:e : (ff) ! o/

(App)

1; C1; \Gamma  `W e1 : o/1 2; C2; \Gamma  `W e2 : o/2
(D; 0) = (C1; 1) t (C2; 2) t ((o/1 _ o/2 ! ff); id) ff new

(C; ) = normalize(D; 0)
jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)

(Let)

1; C1; \Gamma x `W e : o/ (C2; oe) = gen(C1; 1\Gamma ; o/ )

2; C3; \Gamma x:x : oe `W e0 : o/ 0
(D; 0) = (C2; 1) t (C3; 2)

(C; ) = normalize(D; 0)
jfv(\Gamma x); C; \Gamma x `W let x = e in e0 : o/ 0

Figure 4.1: Type inference in term form
variables. All three components can already be found in the original algorithm W but
are now extended to deal with constraints. I already discussed constraint generation
and normalization. In Section 3.4, I introduced a generalization relation. Given
constraints C; Co 2 S, a type environment \Gamma  and types oe; oeo. Then C; \Gamma ; oe `gen
(Co; oeo) iff Co =e 9 _ff:C =e C1 ^ 9 _ff:C2, oeo = 8 _ff:C2 ) oe, ff 62 fv(C1) [ fv(\Gamma ) for
some constraints C1; C2.

I make two observations. First, the set _ff of quantified type variables is only a
subset of the free type variables in (fv(oe) [ fv(C))nfv(\Gamma ). Remember, the set S of
solved forms is not necessarily closed under projection (in most cases the set S will
be closed under projection). Therefore, I have to ensure that the constraint 9 _ff:C
is in solved form. I only require that the set _ff is maximal such that 9 _ff:C is still
in solved form. In general, I do not know how to determine the maximal set of
variables _ff, nor whether there exist a least upper bound between all maximal sets
of variables _ff. Hence, `W yields an algorithm only if this property is decidable.
Second, generalization splits a constraint into two parts. Generalized variables can

CHAPTER 4. TYPE INFERENCE IN HM(X) 66
be free only in one of the two parts, C1, but not the other, C2. Only the C2 part ends
up as a constraint in the generalized type scheme. Note that the above requirement
can always be fulfilled by taking C1 to be true. However, depending on the actual
constraint system used, there might exist better strategies, which keep the constraint
in the generalized type scheme smaller.

The type inference algorithm interleaves constraint generation and normalization. Each inference rule combines the constraint problems of the premises and
performs then a normalization step. That means I perform eager normalization
during type inference. In essence, I only need to perform normalization right before
a (Let) rule (because the constraint in a type scheme needs to be in normal form)
or at the end. This corresponds to by need normalization. An example of a by need
formulation of type inference for the Hindley/Milner type system can already be
found in [Wan87]. Figure 4.2 contains a by need formulation of the type inference
algorithm in HM(X). If the constraint X enjoys the principal constraint property
and unitary unification then both formulations are equivalent. This is justified by
Theorem 9 in Section 4.2.

Theorem 11 (Eager versus by Need Inference) Given a constraint system X
over a term algebra T and a set S of solved forms such that X enjoys the principal
constraint property and unitary unification. Then ; C; \Gamma  `W e : o/ iff ; C; \Gamma  `Wbyneed
e : o/ .

4.3.1 Soundness and Completeness Results
The result triple of the type inference algorithm `W forms a typing configuration
(C; oe; ), which consists of a constraint C 2 S, a type scheme oe and a substitution
 such that C = C, oe = oe and  is consistent with respect to \Gamma . Recall, a
substitution OE is consistent with respect to a type scheme oe = 8 _ff:D ) o/ if D 2 S
where I assume there are no name clashes between _ff and . This extends naturally
to type environments. Given two typing configurations (C; oe; ) and (C0; oe0; 0), I
say (C; oe; ) is more general than (C0; oe0; 0) with respect to \Gamma  iff there exists a OE0
such that  ^OE

0

fv(\Gamma ) , C

0 `e OE0C and C0 `i OE0oe _ oe0. In such a situation I write

(C; oe; ) ^\Gamma  (C0; oe0; ).

Lemma 31 (Typing Configuration) Given a type environment \Gamma  and a term e.
If ; C; \Gamma  `W e : o/ then (C; o/; ) is a typing configuration.

Furthermore, this typing configuration always represents a valid typing of the
given term under the given type environment.

Theorem 12 (Soundness of Inference) Given a term e and a type environment \Gamma .
If ; C; \Gamma  `W e : o/ then C; \Gamma  ` e : o/ , C = C and o/ = o/ .

CHAPTER 4. TYPE INFERENCE IN HM(X) 67

(Var)

x : (8 _ff:D ) o/ ) 2 \Gamma  _fi new

[ _fi= _ff]; D; \Gamma  `W 0 x : o/

(Abs)

; C; \Gamma x:x : ff `W 0 e : o/ ff new

; C; \Gamma x `W 0 *x:e : ff ! o/

(App)

1; C1; \Gamma  `W 0 e1 : o/1 2; C2; \Gamma  `W 0 e2 : o/2 ff new

1 t 2; C1 ^ C2 ^ (o/1 _ o/2 ! ff); \Gamma  `W 0 e1e2 : ff

(Let)

1; C1; \Gamma x `Wbyneed e : o/ (C2; oe) = gen(C1; 1\Gamma x; o/ )

2; C3; \Gamma x:x : oe `W 0 e0 : o/ 0
1 t 2; C2 ^ C3; \Gamma x `W 0 let x = e in e0 : 0o/ 0

(Normalize)

OE; C; \Gamma  `W 0 e : o/ (D; ) = normalize(C; OE)

jfv(\Gamma ); D; \Gamma  `Wbyneed e : o/

Figure 4.2: By need type inference in term form
To achieve complete inference, I require that an HM(X) type system has to fulfill
the principal constraint property. But Kennedy's example shows that inference is
not complete even if the constraint system possesses most general normalizers. To
achieve complete inference in term form, I have to restrict the completeness results
to regular theories. Recall, an equational theory is regular if `e (o/ = o/ 0) implies
fv(o/ ) = fv(o/ 0). I say a constraint system X is regular if the underlying equational
theory is regular. An example of a non-regular theory is the dimension constraint
system DIM.

Type inference in term form also includes inference in constraint form (more
about this in the next section) as a special case if normalization is trivial, i.e. normalization represents only a satisfiability test. The following completeness results
holds for two classes of constraint systems. By X c I denote the class of constraint
systems where S equals to the set of all satisfiable constraints, hence normalization
only involves a satisfiability test. For the second class, denoted by X reg, I consider
only regular constraint systems.

To obtain a completeness result for type inference, I assume that there is an
HM(X) type system where X either belongs to X c or X reg. In both cases the
principal constraint property must hold. In case X belongs to X reg, X must in

CHAPTER 4. TYPE INFERENCE IN HM(X) 68
addition enjoy unitary unification. This is a technical assumption and is usually
fulfilled if the principal constraint property holds.

Furthermore, I consider only those typing judgments C; \Gamma  ` e : oe where the type
environment and the constraint on the left hand side of the turnstile are realizable,
i.e. have a type instance. Recall, a type environment \Gamma  is realizable in a constraint
C if for every x : oe 2 \Gamma  there is a o/ such that C `i oe _ o/ .

Another technical assumption is that the set S of solved forms is closed under
projection. In case of the (Let) rule, I first type the definition and then the body of
the let-statement. Therefore, projection becomes essential. As stated in Theorem 6
in Section 3.5.2 whether the set S is projection-closed or not, does not change the
set of typable programs. Hence, w.l.o.g. I can assume that the set S is closed under
projection.

Theorem 13 (Completeness of Inference) Let C0; OE\Gamma  ` e : oe0 be a typing judgment such that OE\Gamma  is realizable in C0. Then

; C; \Gamma  `W e : o/
for some substitution , constraints C; Co, types o/; oeo, such that

C; \Gamma ; o/ `gen (Co; oeo)
(Co; oeo; ) ^\Gamma  (C0; oe0; OE)

4.3.2 Principal Types
The completeness theorem can be simplified for top-level programs to the following
corollary, which states that type inference yields principal types.

Definition 29 (Principal types) Given an instance X of the HM(X) type system.
X satisfies the principal type property iff the following holds. Given a pair (\Gamma ; e)
such that C0; \Gamma  ` e : oe0 for some constraint C0 and type scheme oe0. Then there is a
constraint C and a type scheme oe such that

ffl C; \Gamma  ` e : oe

ffl If C0; \Gamma  ` e : oe0 then C0 `e C and C0 `i oe _ oe0.
The pair (C; oe) is called a principal type. Commonly, the constraint component
equals true.

Corollary 5 (Principal Types) Let true; \Gamma  ` e : oe be a closed typing judgment
such that \Gamma  is realizable in true. Then OE; C; \Gamma  `W e : o/ for some substitution OE,
constraint C, types o/; oeo such that

C; OE\Gamma ; o/ `gen (true; oeo)

`i oeo _ oe

CHAPTER 4. TYPE INFERENCE IN HM(X) 69

Please note, this is a straightforward extension of the notion of principal types
found in the Hindley/Milner system. In this system, principality states there is
one unique type (a principal type) from which all other types can be generated
(by building generic instances). In contrast, a principal type in HM(X) represents
rather a class of types which are semantically equivalent. As an example, consider
the program *x:x in a variation of the Hindley/Milner system where the set of
solved forms equals all satisfiable constraints. One obvious principal type would be
oe1 = 8ff:ff ! ff. But the type oe2 = 8ff; fi:(ff = fi) ) ff ! fi would be another
possible candidate. It holds that true; ; ` *x:x : oe1 and true; ; ` *x:x : oe2 and
`i oe1 _ oe2 but also `i oe2 _ oe1. This shows there is no unique principal type in
a variation of the Hindley/Milner type system where the set of solved forms equals
all satisfiable constraints.

I observe that uniqueness of principal types is usually lost in cases where set of
solved forms equals all satisfiable constraints. This is the approach usually taken
in subtyping systems. In subtyping systems, authors [AW93, TS96, Pot98] rather
prefer the term most general type than principal type. Nevertheless, I use the term
principal type bearing in mind that no unique principal type might exist. Unique
principal types possibly exist in case the set of solved form is further restricted, e.g.
equation-free. A unique principal type can be computed if principal normal forms
are syntactically unique, see Lemma 24 in Section 4.2.

4.4 Inference in Constraint Form
This section provides a inference system for the HM(X) system in constraint form.
To achieve complete inference, I only need a satisfiability check. Furthermore, I
present an adapted version of the inference system in term form which solves the
problem with non-regular theories.

4.4.1 Constraint Inference
The inference system, see Figure 4.3, is formulated as a deduction system with
clauses of the form C; \Gamma  `Wc e : ff where \Gamma  and e are input values and C and ff are
output values. Please note, the satisfiability check can be performed at any time
because all inference rules preserve satisfiability. Satisfiability must be decidable to
obtain a decidable inference algorithm.

Judgments in the inference system are kept in normalized form, only type variables appear on the right-hand side of `Wc . Unnecessary type variables are hidden
by the projection operator (this corresponds to the (9 Intro) rule in the logical
system). It holds the invariant, given C; \Gamma  `Wc e : ff then fv(C) ` fv(\Gamma ; ff) and
ff 62 fv(\Gamma ). This simplifies generalization in case of the (Let) rule. I immediately

CHAPTER 4. TYPE INFERENCE IN HM(X) 70

(Var)

x : (8 _ff:D ) o/ ) 2 \Gamma  fi new

9 _ff:((fi = o/ ) ^ D); \Gamma  `Wc x : fi

(Abs)

C; \Gamma x:x : ff `Wc e : fl fi new

9ff; fl:((fi = ff ! fl) ^ C); \Gamma x `Wc *x:e : fi

(App)

C1; \Gamma  `Wc e1 : ff1 C2; \Gamma  `Wc e2 : ff2 ff new

9ff1; ff2:(C1 ^ C2 ^ (ff1 _ ff2 ! ff)); \Gamma  `Wc e1e2 : ff

(Let)

C1; \Gamma x `Wc e : ff C3; \Gamma x:x : 8ff:C1 ) ff `Wc e0 : fi

(9ff:C1) ^ C3; \Gamma x `Wc let x = e in e0 : fi

(Equ)

C; \Gamma  `Wc e : ff C =e D

D; \Gamma  `Wc e : ff

Figure 4.3: Type inference in constraint form
can build the type scheme 8ff:C ) ff. However, depending on the actual constraint
system, there might be a way to split constraint C1 into two parts D1; D2 such that
C1 =e D1 ^ D2 and ff 62 fv(D2). Then, only D1 needs to be moved into the type
scheme. But whether or not such a splitting is possible depends on the specific
constraint system.

Rule (Equ) allows equivalent transformations of constraints in case one prefers
certain canonical/minimal representation of constraints. This rule can be applied
at any time, e.g. after each inference step or only at the end. I note that constraint
simplification is especially important in case of the (Let) rule. The careful reader
might notice that keeping types in constraint form might lead to a blow-up. Assume
I have the let-bound variable x with type 8 _ff:C ) o/ . Applying x to different
monomorphic arguments results 3 into the two constraints 9 _ff:((fi = o/ ) ^ C) and
9 _ff:((fi0 = o/ ) ^ C). I assume further that the constraint C contains a subpart which
is independent of the free variables _ff, i.e. C = C1 ^ C2 where _ff " fv(C1) = ;. Then,
the two constraints above are equivalent to

C1 ^ (9 _ff:((fi = o/ ) ^ C2)) ^ (9 _ff:((fi0 = o/ ) ^ C2))
Hence, not the whole constraint C gets duplicated. In general, there is a blow-up of

3Before I apply x I generate a generic instance of x, see the (Var) rule.

CHAPTER 4. TYPE INFERENCE IN HM(X) 71
subsumption constraints which leads to exponential complexity of the inference problem. This topic is well-studied for the special case of the standard Hindley/Milner
system, see [KMM91]. Constraint simplification is also important before generating
type schemes. Simplification in general fits naturally into the HM(X) framework.
The set S of solved forms equals all satisfiable constraints in the constraint-based
approach. Further restrictions of the set S leads to a term-based approach which
can be seen as a simplified representation of constraints. Another form of simplification would be to enforce the set of solved forms to be in syntactically unique
form (see Definition 24 in Section 4.2). Simplification strategies in the context of
subtyping were studied in [Pot98, EST95a].

I can state the following results. I omit to give proofs of the soundness and
completeness results. Both proofs are almost identical to the soundness and completeness results of the class X c in case of inference in term form.

Theorem 14 (Soundness of Inference) Given a term e and a type environment
\Gamma . If C; \Gamma  `Wc e : ff then C; \Gamma  ` e : ff.

For the completeness result, I only consider those typing judgments C; \Gamma  ` e : oe
where the type environment and the constraint on the left hand side of the turnstile
are realizable, i.e. have a type instance. Recall, a type environment \Gamma  is realizable
in a constraint C if for every x : oe 2 \Gamma  there is a o/ such that C `i oe _ o/ .

Theorem 15 (Completeness of Inference) Given a typing judgment C; \Gamma  ` e :
oe such that \Gamma  is realizable in C. Then C0; \Gamma  `Wc e : ff such that

C `e 9ff:C0
C `i 8ff:C0 ) ff _ oe:

I need the realizability condition to state the property about the constraint.
Otherwise, I could not state that C `e 9ff:C0.

The completeness result could be stated in a much more concise way than in the
term-based HM(X) system. To achieve principal types I only need satisfiability. A
decidable satisfiability test results into decidable type inference.

Corollary 6 (Principal Types) Let true; \Gamma  ` e : oe be a closed typing judgment
such that \Gamma  is realizable in true. Then C; \Gamma  `Wc e : ff such that

`e 9ff:C
`i 8ff:C ) ff _ oe:

CHAPTER 4. TYPE INFERENCE IN HM(X) 72
4.4.2 Term Inference
I turn my attention to the inference problem in the term-based system as described
in Section 3.2. Kennedy's example shows that the standard inference algorithm
does not infer principal types, even in the presence of unitary unification. The
standard inference algorithm performs unification eagerly, after each step. This can
be a problem in case of non-regular equational theories. An equational theory is
non-regular if there exists types o/ , o/ 0 such that (o/ = o/ 0) and fv(o/ ) 6= fv(o/ 0). For
instance, dimension types form a non-regular theory. It holds that (prod(ff; i(ff)) =
1) but fv(1) = ;. In Section 4.3, I could already show that regular theories always
have principal types under the assumption that the constraint system satisfies the
principal constraint property (which corresponds to unitary unification in case of an
equational theory). A similar result in the special case of regular equational theories
was also shown by R'emy [R'em92b].

Kennedy could give an adapted version of his inference algorithm which infers
principal types for non-regular theories. But he can only state principal types under
some additional conditions. I provide more details in the next section where I also
discuss another alternative approach given by Valery Trifonov [TS96].

In my dissertation, I present a revised term-based inference system which always infers principal types if the constraint system satisfies the principal constraint
property. The revised inference system can be found in Figure 4.4. It consists of
two parts. The purely constraint-based inference system introduced in Section 4.4.1
and a term reconstruction step. In the standard formulation of the inference system, term reconstruction is done in each step. In Section 4.3, I observed that term
reconstruction only needs to be done right before a let-rule. Because then the constraint is moved in the type scheme, and constraints in the logical system have to be
in solved form. But Kennedy's example shows that in the presence of non-regular
theories inference in term form is not necessarily complete. In the revised inference formulation, term reconstruction is postponed to the very end. Then complete
inference can be retained even for non-regular theories. The difficulty is now to
show that this yields a sound inference system, see the proofs of the soundness and
completeness results.

There is also the (Equ) rule which allows to transform constraints into a semantically equivalent but better suitable representation.

In the following two theorems, I assume that HM(X) instances are given as
described in Section 3.2.

Theorem 16 (Soundness of Inference) Given an instance of the HM(X) system
where X satisfies the principal constraint property and the set S is closed under
projection. Given a type environment \Gamma  and a term e. If ; C; \Gamma  `Wterm e : o/ then
C; \Gamma  ` e : o/ where C =e C and o/ = o/ .

CHAPTER 4. TYPE INFERENCE IN HM(X) 73

(Var)

x : (8 _ff:D ) o/ ) 2 \Gamma  fi new

9 _ff:((fi = o/ ) ^ D); \Gamma  `Wc x : fi

(Abs)

C; \Gamma x:x : ff `Wc e : fl fi new

9ff; fl:((fi = ff ! fl) ^ C); \Gamma x `Wc *x:e : fi

(App)

C1; \Gamma  `Wc e1 : ff1 C2; \Gamma  `Wc e2 : ff2 ff new

9ff1; ff2:(C1 ^ C2 ^ (ff1 _ ff2 ! ff)); \Gamma  `Wc e1e2 : ff

(Let)

C1; \Gamma x `Wc e : ff C3; \Gamma x:x : 8ff:C1 ) ff `Wc e0 : fi

(9ff:C1) ^ C3; \Gamma x `Wc let x = e in e0 : fi

(Equ)

C; \Gamma  `Wc e : ff C =e D

D; \Gamma  `Wc e : ff

(Term reconstruction)

C; \Gamma  `Wc e : ff (D; ) = normalize(C; id)

jfv(\Gamma ); D; \Gamma  `Wterm e : (ff)

Figure 4.4: Revised type inference in term form
Please note, compared to the original soundness result (see Theorem 12) I need
stronger assumptions; the principal constraint property and S is closed under projection. These assumptions are necessary to apply the Transformation Theorem 7
which transforms judgments in constraint form to judgments in term form.

The following completeness results extends the previous completeness result for
term-based HM(X) systems. Completeness can be achieved under the assumption
that the constraint system satisfies the principal constraint property. I do not need
to restrict the result to regular theories or require additional conditions as done
in [Ken96].

Theorem 17 (Completeness of Inference) Given an HM(X) instance where X
satisfies the principal constraint property. Given C; OE\Gamma  ` e : oe such that OE\Gamma  is
realizable in C. Then ; D; \Gamma  `Wterm e : o/ for some substitution , constraints
D; Co and types o/; oeo such that

D; \Gamma ; o/ `gen (oeo; Co)
 ^OE

0

fv(\Gamma ) OE C `

i OE0oeo _ oe C `e OE0Co:

CHAPTER 4. TYPE INFERENCE IN HM(X) 74

To achieve complete inference, I need less assumptions compared to the completeness result for the inference system `W (see Theorem 13). Unitary unification
is not necessary because during the actual inference process no substitutions are
computed.

I can furthermore simplify the completeness results to top-level programs which
states that the inference system computes principal types.

Corollary 7 (Principal types) Given an HM(X) instance where X satisfies the
principal constraint property. Given a closed typing judgment true; \Gamma  ` e : oe where
\Gamma  is realizable in true. Then ; D; \Gamma  `Wterm e : o/ for some substitution , constraint
D and types o/; oeo such that

D; \Gamma ; o/ `gen (oeo; true)

`i oeo _ oe:

The basic trick I apply lies in postponing the term reconstruction step to the
very end. In intermediate steps I always keep inference judgments in normalized
form C; \Gamma  `Wc e : ff. Then generalization is unproblematic. Term reconstruction is
only performed at the very end. This achieves sound and complete type inference.
The drawback is that constraints in intermediate steps might become big. In case of
the dimension type system, equality constraints are not resolved via unification but
only accumulated and checked whether they are satisfiable or not. Fortunately, for
a large class of systems it is even possible to perform normalization in intermediate
steps while retaining complete inference.

I consider a variation of the inference system `Wterm where normalization is
allowed to be performed in intermediate steps. Rule (Normalize) is added to the
inference system `Wterm .

(Normalize)

C; \Gamma  `Wc e : ff (D; OE) = normalize(C; id)

D ^ OE; \Gamma  `Wc e : ff

The idea is to represent normal forms in constraint form. The normalization procedure states that D `e OEC. It follows that D ^ OE `e C where the substitution
OE = [_o/ = _ff] is considered as the constraint (ff1 = o/1) ^ : : : ^ (ffn = o/n). Please note,
given C; \Gamma  `Wc e : ff the invariant fv(C) ` fv(\Gamma ; ff) and ff 62 fv(\Gamma ) still holds. The
substitution OE in the (Normalize) rule operates only on the free variables fv(\Gamma ; ff).

In inference system `Wnormalize (see Figure 4.5) the (Normalize) rule is applied
after each step. The addition of rule (Normalize) obviously retains soundness. If the
constraint system satisfies the lifting property (see Definition 28 in Section 4.2.1),
inference systems `Wterm and `Wnormalize are equivalent.

Theorem 18 (Equivalence of `Wterm and `Wnormalize ) Given an HM(X) instance
where X satisfies the lifting property. Then OE; D; \Gamma  `Wterm e : o/ iff OE; D; \Gamma  `Wnormalize
e : o/ .

CHAPTER 4. TYPE INFERENCE IN HM(X) 75

(Var)

x : (8 _ff:D ) o/ ) 2 \Gamma  fi new

9 _ff:((fi = o/ ) ^ D); \Gamma  `Wc2 x : fi

(Abs)

C; \Gamma x:x : ff `Wc e : fl fi new

9ff; fl:((fi = ff ! fl) ^ C); \Gamma x `Wc2 *x:e : fi

(App)

C1; \Gamma  `Wc e1 : ff1 C2; \Gamma  `Wc e2 : ff2 ff new

9ff1; ff2:(C1 ^ C2 ^ (ff1 _ ff2 ! ff)); \Gamma  `Wc2 e1e2 : ff

(Let)

C1; \Gamma x `Wc e : ff C3; \Gamma x:x : 8ff:C1 ) ff `Wc e0 : fi

(9ff:C1) ^ C3; \Gamma x `Wc2 let x = e in e0 : fi

(Normalize)

C; \Gamma  `Wc2 e : ff (D; OE) = normalize(C; id)

D ^ OE; \Gamma  `Wc e : ff

(Term reconstruction)

C; \Gamma  `Wc e : ff (D; ) = normalize(C; id)

jfv(\Gamma ); D; \Gamma  `Wnormalize e : (ff)

Figure 4.5: Revised type inference in term form II
Inference system `Wnormalize can be seen as a constraint-based formulation of
inference system `W . Specifically, it follows that `Wnormalize and `W have the
same complexity.

The dimension system DIM satisfies the lifting property. Hence, principal types
can be inferred by the inference system `Wnormalize as efficient as in the term-based
inference system `W . In addition, I note that the lifting property holds usually
for systems following a unification-based approach towards normalization, hence
covering a large class of systems.

4.4.3 Discussion
In [Ken96], Kennedy discovered the problem of performing type inference in non-
regular theories. The central problem seems that in non-regular theories there might
be some implicitly free type variables. Such type variables need to be revealed when
generalizing over free type variables before applying the let-rule. For instance, consider the motivating example at the beginning of this chapter. In it, I applied a

CHAPTER 4. TYPE INFERENCE IN HM(X) 76
substitution to the whole judgment which revealed an implicitly free type variable,
leaving the type environment unchanged. The question is whether such a treatment
is always possible. Kennedy gave a sufficient axiomatization under which such implicitly free type variables can always be revealed. But it is not known yet whether
there is a decidable algorithm which satisfies the axiomatization. For some specific
theories he could give algorithms which satisfy the axiomatization. If additional unification is unitary then a principal types theorem holds. In [Ken96], Kennedy posed
the question whether these extra assumptions are necessary. My revised term-based
inference algorithm always infers principal types giving unitary unification. There
are no further additional conditions necessary. Moreover, inference systems `W and
`Wnormalize have the same complexity.

Valery Trifonov [TS96] introduces what he calls *-lifting which also seems to
overcome Kennedy's problem. He writes judgments in the form

\Gamma 0 ` e : 8 _ff:\Gamma  ) o/ j C
The type environment \Gamma 0 contains only let-bound variables whereas all other free
variables are contained in \Gamma . Employing his notation would allow to type function
y in the example at the beginning of this chapter as follows:

; ` y : 8d1; d2:\Gamma :x : dim(prod(d1; d2)) ) dim(d1) ! dim(d2)
Now, y has the desired polymorphic type. His notation is quite different from the
standard notation. For details, see [TS96]. The *-lifting notation was also employed
by Francois Pottier [Pot98]. Both used *-lifting in the context of subtyping where
normalization corresponds only to a satisfiability test. The *-lifting notation allows
for certain simplification strategies which would not be able to perform with the
standard notation. But there seems to be no gain of the *-lifting notation in case
of unification-based approaches.

4.5 Summary
I sum up the results of this section. The following two figures reflect the structure
of the soundness/completeness proofs. Figure 4.6 presents the results of the term-
based inference system and shows the connections between the intermediate derivations to achieve the completeness result. Lemma 37 can be found in the appendix
(see Proofs of Section 4.3). The proof follows the standard technique to establish
the completeness result, though a proof in such a generality has not been found in
the literature yet. Figure 4.7 presents the results of the constraint-based inference
system and revised inference system in term form. I apply a new proof technique.
The straightforward completeness result of the constraint-based system is lifted to

CHAPTER 4. TYPE INFERENCE IN HM(X) 77

Completeness Theorem 13 AEo/oo

Completeness Lemma 17 AEo/oo

`s

fflffl

O/OE
fflffl

`nOO

Completeness Lemma 37 Equivalence Lemma 15 oo

`W

fflffl

O/OE

`
aeoe

OO

Soundness Theorem 12,ss //

`W oo

Principal constraint property

Unitary unification

// `Wbyneed

Figure 4.6: Type inference in term form
the term-based system by application of the Transformation Theorem. Inference
systems `Wterm and `Wnormalize are equivalent if the lifting property holds. The
inference system `Wnormalize is a constraint-based formulation of the term-based
inference system `Wterm . Furthermore, the results of Section 4.2.1 (lifting of normalization) allow to reuse a wide range of already existing constraint solvers to
perform type inference in HM(X).

In summary, type inference consists of the following three phases:

1. Constraint solving in its simplest form only involves a satisfiability test. This

ensures correctness of type inference.

2. Constraint simplification is relevant to ensure efficient type inference.
3. Term reconstruction is relevant for user interaction.

The above classification evolved out of fruitful and inspiring discussions with
Martin M"uller. Note that constraint solving might involve more sophisticated methods such as unification. Hence, we sometimes find a mix of the above described
inference phases.

CHAPTER 4. TYPE INFERENCE IN HM(X) 78

Completeness Theorem 17 AEo/oo
Completeness Theorem 15 AEo/oo

`Wc

O/OE
fflffl

`X c oo

`Wterm

O/OE
fflffl //

`Wc

fflffl

`

aeoe

OO//
Soundness Theorem 14 Transformation Theorem 7

aeoe

OO

O/OE

`X c,ss //
Soundness Theorem 16,ss //

`Wterm oo

Lifting property //

`Wnormalize

Figure 4.7: Type inference in constraint form

Chapter 5
Applications
This chapter of my dissertation considers applications of the HM(X) framework.
In the first part, I consider Ohori's record calculus [Oho95] as an instance of the
HM(X) system. The corresponding type system instance of HM(X) models Ohori's
calculus models fully and faithfully, i.e. exactly the same set of programs are typable
in both record calculi. Furthermore, I describe some useful extensions of Ohori's
calculus, such as extensible records, record concatenation, overloaded field labels
and a calculus where field labels become first-class values. The record calculus with
first-class labels turns out to be especially interesting and very expressive. This
calculus provides the basis to encode other features such as type case.

The second part considers extensions of Odersky/Wadler/Wehr's overloading
system [OWW95]. The development is similar to the previous part. I consider
extensions such as overloaded curried functions and overloaded identifiers as first-
class values.

5.1 Ohori Records
Following ideas of Ohori [Oho95], I give an instance of the HM(X) system which
deals with polymorphic records. Ohori's system, abbreviated Ohori in the following,
has besides type variables and function types also record types denoted by fl1 :
o/1; : : : ; ln : o/ng, where li is an element of an enumerable set of record labels. I
assume that there is an ordering relation between all field labels. All record fields
are ordered with respect to this ordering relation. Because there is a fixed ordering
of record fields, Herbrand unification applies to resolve equality constraints between
records, as shown by Ohori in [Oho95].

Type quantification in Ohori is kinded; in the type scheme 8ff:ff :: ^ ) oe the
type variable ff ranges only over kind ^. A kind is of the form ffl1 : o/1; : : : ; ln : o/ngg;
it comprises all records that contain at least fields l1; : : : ; ln with types o/1; : : : ; o/n.

Instead of a constraint on the left hand side of a typing judgment, Ohori uses

79

CHAPTER 5. APPLICATIONS 80
a kind assignment K which can be considered as a function that assigns each type
variable ff its kind k. He writes K ^ (ff :: k) for the disjoint extension of K with a
new type variable ff with kind k.

Here is an example of a program typed in Ohori.

Example 19

f: 8ff; fi:(ff :: ffl : figg) ) ff ! Int
f x =

let g: fi ! Bool

g = * y. eq y (x.l)
in 1

I use a Haskell-style notation, with type scheme annotations added for illustration
purposes. The program assumes that there is a function

eq : 8ff:ff ! ff ! Bool
in the initial type environment.

Type System
I now translate Ohori into the HM(X) framework. I add to the initial type environment \Gamma 0 primitive constructs that deal with record formation, selection and update.
I assume for every ordered sequence of record labels l1; : : : ; ln there exists an n-ary
parameterized data type Rl1;:::;ln. The record type fl1 : ff1; : : : ; ln : ffng is then represented as Rl1;:::;lno/1 : : : o/n. For simplicity, I will keep the record type notation as
a synonym for the data type notation. The initial environment contains data type
constructors

l1 : : : ln : ff1 ! : : : ffn ! fl1 : ff1; : : : ; ln : ffng

Then, l1 : : : ln e1 : : : en represents record formation fl1 = e1; : : : ; ln = eng. For each
field label l, I add to the initial type environment \Gamma 0 the two functions

( :l) : 8ff; fi:(ff :: ffl : figg) ) ff ! fi
modifyl : 8ff; fi:(ff :: ffl : figg) ) ff ! fi ! ff

The first function corresponds to record selection, the second to record update.

Kinded quantification in REC is modeled by primitive constraints of the form
(o/ :: k) where o/ is a type and k is a kind. Technically, this means, I add (o/ :: k) to the
set \Omega  of primitive constraints where (::) is a primitive predicate of arity 2. I define
REC as the smallest term constraint system that satisfies the following additional
rules:

CHAPTER 5. APPLICATIONS 81

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)

It must be noted that rules REC1 and REC2 specify a set of rules for each
record fl1 : o/1; : : : ln : o/ng and field label l. In a later variation of Ohori's record
calculus, field labels become first-class, hence the set of rules specified by rule REC2
can be described by only one rule.

The following are derived rules:

REC3 (f: : : ; l : o/1; : : :g :: ffl : o/2gg) `e (o/1 = o/2)
REC4 9ff:(ff :: k) =e true

where ff 62 fv(k)

Please note, these conditions rule out recursive records, since the type algebra
does not have recursive types. On the other hand, I do allow recursive constraints
between type variables in REC. For instance, the constraint (ff :: ffl : ff ! ffgg) is
well-formed. But that constraint is not satisfiable and therefore cannot appear as
a solved form. Also ruled out (by conditions REC2 and REC3) is overloading of
field labels.

The subsumption predicate (_) corresponds to syntactic equality and the set S
of solved forms in HM(REC) consists of all satisfiable constraints of the form

C ::= fg j (ff :: ffl : o/ gg) j C ^ C j 9 _ff:C
where I take the empty token set as a representation of true. Furthermore, I require
that the constraints in S are equation-free, i.e.C `e (o/ = o/ 0) must imply `e (o/ =
o/ 0). For instance,

(ff :: ffl : figg) ^ (ff :: ffl : fl ! flgg)

is not equation-free and is therefore excluded.

The type system HM(REC) is as given in Section 3.2, with subsumption (_)
being modeled by (=). As an example, here the annotated program from Example 19
re-formulated in HM(REC):

Example 20

f: 8ff:(9fi:(ff :: ffl : figg)) ) ff ! Int
f x =

let g : 8fi:(ff :: ffl : figg) )

fi ! Bool
g = * y. eq y (x.l)
in 1

CHAPTER 5. APPLICATIONS 82
In HM(REC), I quantify in the innermost let over type variable fi, leaving just ff
to be quantified in the top level function f. This is not possible in Ohori, since
ff's kind depends on fi. The question arises whether this makes HM(REC) a more
permissive type system than Ohori. Specifically, are there examples where I can use
function g polymorphically? The answer is no. Every instance of g has to satisfy
the constraint 9fi:(ff :: ffl1 : figg). But ff can only have one field entry with label l1.
Therefore, I can use g in the let-body only monomorphically. In general, I observe
that Ohori and HM(REC) type exactly the same programs, but the types are more
precise in HM(REC). I refer to Section 3.5 for an in-depth treatment of constrained
polymorphism.

Theorem 19 (Full and Faithful) Every program typable in Ohori is typable in
HM(REC) and vice versa.

Ohori's record calculus can be encoded in terms of the overloading application.
This was already observed by Odersky/Wadler/Wehr [OWW95]. The basic idea is
to consider a record constraint of the form (ff :: ffl : o/ gg) as an overloaded constraint
of the form (l :: ff ! o/ ) where the field label l becomes now an overloaded identifier.
Record creation corresponds to providing instance declarations and record selection
corresponds to applying an overloaded identifier (which corresponds to a field label)
to a record. For more details, I refer to [OWW95]. But then the above results
follows easily from the full- and faithfulness result of the overloading application in
Section 5.2.

Type Inference
Ohori already showed that unification is unitary in his system. Type inference in
HM(REC) can easily achieved by application of the lifting result in Section 4.2.1.

5.1.1 Extensible Records
The record calculus of Ohori lacks some important features such as extensible
records. I show now how to add record extension to HM(REC).

For each label l, I add primitive constraints of the form extendl(o/1; o/2; o/3) to the
set of primitive constraints \Omega . The predicate extendl(o/1; o/2; o/3) expresses adding a
field with label l and type o/2 to the record o/1 where o/3 is the resulting record. RECe
is the smallest term constraint system that fulfills the following rules:

CHAPTER 5. APPLICATIONS 83

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)
REC3 extendl(ff; fi; fl) `e (fl :: ffl : figg)
REC4 extendl(ff; fi; fl) ^ (ff :: ffl0 : o/ gg) `e

(fl :: ffl0 : o/ gg)
REC5 extendl(ff; fi; fl) ^ (fl :: ffl0 : o/ gg) `e (ff :: ffl0 : o/ gg)

where l 6= l0
REC6 `e extendli(fl1 : o/1; : : : ; li\Gamma 1 : o/i\Gamma 1; li+1 : o/i+1; : : : ; ln : o/ng; o/i;

fl1 : o/1; : : : ; ln : o/ng)

Remark 4 Conditions REC3 and REC4 state information about the extended
record given the original record. The opposite is done by condition REC5. Condition
REC6 represents the base case. Please note, the conditions put on extendl prohibit
extending a record with an already existing field. I also find the derived constraint
rules mentioned in the previous section.

Jones [Jon92] uses a predicate (ffnl) to express that record ff does not contain
a field label l. I can define (ffnl) as an abbreviation for 9fi; fl:extendl(ff; fi; fl). Furthermore, I can define removel(ff; fl) = 9fi:extendl(ff; fi; fl) which expresses removing
the field with label l from record fl resulting in record ff. Please note, the field label
l must be present in fl because record extension does not allow overriding of existing
fields.

For each field label l, I add

extendl : 8ff; fi; fl:extendl(ff; fi; fl) ) ff ! fi ! fl
to the initial type environment \Gamma 0. The construct

removel : 8ff; fl:9fi:extendl(ff; fi; fl) ) fl ! ff
handles removal of the field label l.

The set S of solved forms in HM(RECe) consists of all satisfiable and equation-
free constraints of the form

C ::= fg j (ff :: ffl : o/ gg) j extendl(o/1; o/2; o/3)

j C ^ C j 9 _ff:C

In addition, I consider type inference for this record application. The development is similar to type inference in HM(REC). The lifting property holds also in
this case, hence it is sufficient to consider normalization only for projection-free
constraints.

CHAPTER 5. APPLICATIONS 84

1. D ` Cl(D)
2 If (ff = fl1 : o/1; : : : ; ln : o/ng) 2 Cl(D)

then (ff :: ffl1 : o/1gg); : : : ; (ff :: ffln : o/ngg) 2 Cl(D)
3 If (ff :: ffl : o/1gg); (ff :: ffl : o/2gg) 2 Cl(D) then (o/1 = o/2) 2 Cl(D)
4. If extendl(ff1; ff2; ff3) 2 Cl(D) then (ff3 :: ffl : ff2gg) 2 Cl(D)
5. If extendl(ff1; ff2; ff3); (ff1 :: ffl0 : figg) 2 Cl(D) then (ff3 :: ffl0 : figg) 2 Cl(D)
6. If extendl(ff1; ff2; ff3); (ff3 :: ffl0 : figg) 2 Cl(D), l 6= l0 then Cl(D) 2 (ff1 :: ffl0 : figg)
7. If extendl(ff1; ff2; ff3) and (ff1 :: ffl : figg) 2 Cl(D) then ? 2 Cl(D)

Figure 5.1: Closure for extensible records

Given a projection-free constraint D. W.l.o.g., I assume all kind constraints are
of the form (ff :: ^) because (ff :: ^) =e 9ff:((ff = o/ ) ^ (ff :: ^)). I assume that the
set E1 contains all such predicates (ff = o/ ). The same assumptions can by made
about constraints extendl(ff1; ff2; ff3). Then the closure Cl(D) of a constraint D is
the smallest constraint which satisfies the conditions in Figure 5.1.

The ? element signals immediate failure. Remember, I do not allow overriding
of existing fields. The closure of D contains all predicates (o/ :: ffl : o/ 0gg) which might
cause any inconsistencies. Given all such predicates, I can generate all unification
problems (o/ = o/ 0) which have to be resolved. The following lemma states that I
really have generated all such predicates.

Lemma 32 Given a field label l and types o/; o/ 0. If 6 `e (o/ :: ffl : o/ 0gg) then (o/ ::
ffl : o/ 0gg) 2 Cl(D) iff D `e (o/ :: ffl : o/ 0gg). Furthermore, if 6 `e (o/ = o/ 0) then
(o/ = o/ 0) 2 Cl(D) iff D `e (o/ = o/ 0).

If ? 2 Cl(D) the constraint D does not have a normal form at all. Otherwise,
I assume that E2 contains all equality predicates in Cl(D). Then, I can apply
unification over Herbrand terms [Rob65] to resolve all equality predicates (=) in E1 [
E2. If no unifier exists then D does not have a normal form at all, otherwise Herbrand
unification yields a most general unifier OE of the E1 [ E2 and then (OED; OE) represents
the principal normal form of (D; id). Please note, I assume that constraints C 2 OED
where `e C are disregarded.

It follows that RECe satisfies the principal constraint property by application of
the lifting method.

Theorem 20 The constraint system RECe satisfies the principal constraint property.

CHAPTER 5. APPLICATIONS 85

The careful reader might ask whether constraints of the form

extendl2(ff; o/2; fl1 : o/1; l2 : o/2g)
are in S or not. I conjecture that

extendl2 (ff; o/2; fl1 : o/1; l2 : o/2g) `e (ff = fl1 : o/1g) (5.1)
does not hold in RECe. This would justify that extendl2(ff; o/2; fl1 : o/1; l2 : o/2g) belongs to S. I can prove that

extendl2(ff; o/2; fl1 : o/1; l2 : o/2g) `e (ff :: ffl1 : o/1gg)
and obviously the only satisfying instance of the constraint extendl2(ff; o/2; fl1 : o/1; l2 : o/2g)
instantiates ff to fl1 : o/1g. But I believe that 5.1 is not derivable with the logical
rules of RECe. However, I do not have a formal proof for this conjecture yet.

I redefine the set S of solved forms in HM(RECe) to consist of all satisfiable and
equation-free constraints of the form

C ::= fg j (ff :: ffl : o/ gg) j extendl(ff; o/; fi)

j C ^ C j 9 _ff:C

Please note, this excludes constraints of the form extendl2 (ff; o/2; fl1 : o/1; l2 : o/2g). Obviously, the principal constraint property still holds. After the above described normalization step, one simply needs to resolve predicates of the form extendl(f: : :g; o/; ff)
and extendl(ff; o/; f: : :g). That means, substituting type variable ff with the appropriate record.

5.1.2 Record Concatenation
I consider adding record concatenation to Ohori's record calculus. I add the predicate concat(ff; fi; fl) to the set of primitive constraints \Omega . This predicate states
concatenating records ff and fi results into the record fl. RECc is the smallest term
constraint system that fulfills the following rules:

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)
REC3 concat(ff; fi; fl) ^ (ff :: ffl : ffigg) `e (fl :: ffl : ffigg)
REC4 concat(ff; fi; fl) ^ (fi :: ffl : ffigg) ^ (ffnl) `e (fl :: ffl : ffigg)
REC5 concat(ff; fi; fl) ^ (fl :: ffl : ffigg) ^ (finl) `e (ff :: ffl : ffigg)
REC6 concat(ff; fi; fl) ^ (fl :: ffl : ffigg) ^ (ffnl) `e (fi :: ffl : ffigg)
REC7 `e concat(f_l : _o/ g; f_l0 : _o/ 0g; f_l00 : _o/ 00g)

where _l00 = (_ln_l0) [ _l0 and o/ 00i = typeof (l00i )
REC8 `e (fl1 : o/1; : : : ; ln : o/ngnl0)

where l0 6= li

CHAPTER 5. APPLICATIONS 86
Remark 5 I model asymmetric concatenation. If fields with the same label are
present in both input records, the first record takes precedence. This is enforced by
condition REC8 where (_ln_l0) [ _l0 builds the set of labels in the output record and
typeof (\Delta ) is a function from labels to its associated types. In fact, typeof (\Delta ) should
also be seen as parameterized in the record because the same label might possibly have
different types in different records. Therefore, the record should always be seen as
an implicit parameter for the typeof (\Delta ) function.

The primitive

concat : 8ff; fi; fl:concat(ff; fi; fl) ) ff ! fi ! fl
allows concatenation of records.

The set S of solved forms in HM(RECc) consists of all satisfiable and equation-
free constraints of the form

C ::= fg j (ff :: ffl : o/ gg) j concat(o/1; o/2; o/3) j C ^ C j 9 _ff:C
Type inference for HM(RECc) can be achieved in a similar way as for the
record application with extensible records in the previous section. I only consider
projection-free constraints and apply a closure algorithm, see Figure 5.2. In contrast
to the previous section, constraints of the form p(_o/ ) are not put into normal form,
i.e. transformed into 9ff:(( _ff = _o/ )^p(_o/ ). This would complicate closure rules such as
rule (10.). Furthermore, it is necessary to perform several iterations of building the
closure and unifying equality constraints. Unification problems resolved in one step
might lead to new unification problems in the next step. Consider the constraint

concat(fl1 : o/1g; fl2 : o/2g; fl) ^ concat(fl; fl3 : o/3g; fl1 : ff1; l2 : ff2; l3 : ff3g)
Building of the closure yields the unification problems

(fl = fl1 : o/1; l2 : o/2g) ^ (ff3 = o/3)
Computing the mgu and applying the mgu to the above constraint results in:

concat(fl1 : o/1g; fl2 : o/2g; fl1 : o/1; l2 : o/2g)^
concat(fl1 : o/1; l2 : o/2g; fl3 : o/3g; fl1 : ff1; l2 : ff2; l3 : o/3g)

But two further unification problems

(ff1 = o/1) ^ (ff2 = o/3)
need to be resolved until the whole constraint is in solved form.

CHAPTER 5. APPLICATIONS 87

1. D ` Cl(D)
2. If (f: : : ; l : o/1; : : :g :: ffl : o/2gg) 2 Cl(D) then (o/1 = o/2) 2 Cl(D)
3. If (ff :: ffl : o/1gg) and (ff :: ffl : o/2gg) 2 Cl(D) then (o/1 = o/2) 2 Cl(D)
4. If concat(ff; fi; fl); (ff :: ffl : ffigg) 2 Cl(D) then (fl :: ffl : ffigg) 2 Cl(D)
5. If concat(ff; fi; fl); (fi :: ffl : ffigg); (ffnl) 2 Cl(D) then (fl :: ffl : ffigg) 2 Cl(D)
6. If concat(ff; fi; fl); (fl :: ffl : ffigg); (finl) 2 Cl(D) then (ff :: ffl : ffigg) 2 Cl(D)
7. If concat(ff; fi; fl); (fl :: ffl : ffigg); (ffnl) then (fi :: ffl : ffigg)
8. If (ffnl); (ff :: ffl : o/ gg) 2 Cl(D) then ? 2 Cl(D)
9. If (f_l : _o/ gnl) 2 Cl(D), l 62 _l then ? 2 Cl(D)
10. If concat(f _l1 : _o/1g; f _l2 : _o/2g; fl) 2 Cl(D)

then _l3 = _l2n _l1, (fl = f _l1 : _o/1; _l3 : typeof ( _l3)g) 2 Cl(D)
11. If concat(f _l1 : _o/1g; fi; f _l2 : _o/2g) 2 Cl(D) and _l1 ` _l2

then (typeof ( _l1) = typeof ( _l2 " _l1)) 2 Cl(D)
12. If concat(f _l1 : _o/1g; fi; f _l2 : _o/2g) 2 Cl(D) and _l1 6` _l2 then ? 2 Cl(D)
13. If concat(ff; \Delta ; f_l : _o/ g); (ff :: ffl : o/ gg) 2 Cl(D) and l 2 _l

then (o/ = typeof (_l " flg)) 2 Cl(D)
14. If concat(ff; \Delta ; f_l : _o/ g); (ff :: ffl : o/ gg) 2 Cl(D) and l 62 _l then ? 2 Cl(D)
15. If concat(ff; f _l1 : _o/1g; f _l2 : _o/2g) 2 Cl(D) and _l1 6` _l2 then ? 2 Cl(D)
16. If concat(f_l : _o/ g; \Delta ; fl); (fl :: ffl : o/ gg) 2 Cl(D) and l 2 _l

then (o/ = typeof (_l " flg)) 2 Cl(D)
17. If concat(f _l1 : _o/1g; f _l2 : _o/2g; f _l3 : _o/3g) 2 Cl(D) and _l1 ` _l3; _l2 ` _l3

then (typeof ( _l1) = typeof ( _l3 " _l1)); (typeof ( _l2n _l1) = typeof ( _l3 " ( _l2n _l1))) 2 Cl(D)
18. If concat(f _l1 : _o/1g; f _l2 : _o/2g; f _l3 : _o/3g) 2 Cl(D) and ( _l1 6` _l3 or _l2 6` _l3)

then ? 2 Cl(D)

Figure 5.2: Closure for record concatenation

Therefore, computation of the principal normal forms performs several iterations
of building the closure and resolving all unification problems. Given a projection-
free constraint D. I set D1 = D; OE0 = id and Di+1 = OEiDi where OEi is the mgu of
all equality problems in Cl(Di) for i ? 0. The sequence of D1; D2; : : : has a fixed
point. Either all unification problems get resolved or the element ? appears at one
step. Therefore, the iteration process terminates at a step i. Then (OED; OE) where
OE = OEi ffi : : : ffi OE1 represents the principal normal form.

Please note, in rule (11.) the constraint concat(f _l1 : _o/1g; fi; f _l2 : _o/2g) does not
allow to determine the record fi because asymmetric record concatenation is modeled. Nevertheless, the equality problems (typeof ( _l1) = typeof ( _l2 " _l1)) ensure that
matching fields in the records f _l1 : _o/1g and f _l2 : _o/2g have the same type. Please

CHAPTER 5. APPLICATIONS 88
note, the side condition _l1 ` _l2 ensures that all fields of the former record are also
contained in the latter. Also, the constraint concat(ff; \Delta ; f_l : _o/ g) (\Delta  stands for a hole
which can either be filled up by a variable or record) in itself is in solved form.
Further information is needed (see rule (13.)) to generate unification problems.

Application of the lifting method allows to establish the principal constraint
property for RECc.

Theorem 21 The constraint system RECc satisfies the principal constraint property.

I conjecture that the set of solved forms satisfies the syntactic uniqueness property, hence type inference infers unique principal types.

5.1.3 Polymorphic Field Labels
In the previous application, field labels were considered as constants. I extend the
term algebra in REC. I distinguish now between labels and types:

Labels l ::= ff j l1 j : : :
Types o/ ::= ff j label(l) j fl1 : o/1; : : : ; ln : o/ng j o/ ! o/

I distinguish between label constants and label variables. Commonly, I refer to label
constants as li and assume that for each constant label li there is a primitive

li : label(li)
in the initial type environment. Primitives for record creation remain the same.
Please note, only constant labels appear in record types fl1 : o/1; : : : ; ln : o/ng.

The primitive constructs for field selection and record update are now polymorphic in the field labels. This means, there is no longer a special construct for each
label l needed.

( : ) : 8ff; fi; l:

(ff :: ffl : figg) )
ff ! label(l) ! fi

modify : 8ff; fi; l:

(ff :: ffl : figg) )
ff ! label(l) ! fi ! ff

The predicate (r :: ffl : o/ gg) takes now a record r, a label l and a type o/ as its
arguments. The conditions put on RECl are exactly the same found in REC. The
constraint system RECl fulfills is the smallest term constraint system satisfying the
following rules:

CHAPTER 5. APPLICATIONS 89

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)

The constraint system RECl is left under-specified. For instance, consider the
constraint

(fl1 : o/1; l2 : o/2g :: ffl : ffgg)

where l1 and l2 are constant field labels with types o/1 and o/2 but l is a field label
variable with type variable ff. There is not enough information given to determine
whether l equals to l1 or l2. This represents a form of indeterministic choice.

Satisfiability in RECl is decidable but NP-complete. A proof can be found in
Appendix B.1. This result is not new and can already be found in similar form
in [Tre93]. Complete and sound inference could then be achieved by taking the set
S to consist of all satisfiable constraints.

Compared to REC constraints of the form (f: : :g :: ffl : o/ gg) can no longer be
resolved anymore because label l might be a variable. Nevertheless, it is possible
to impose stronger conditions on the set S while retaining the principal constraint
property.

The set S of solved forms in HM(RECl) consists of all satisfiable and equation-
free constraints of the form

C ::= fg j (o/ :: ffl : o/ 0gg) j C ^ C j 9 _ff:C
In HM(RECl) constraints of the form (o/ :: ffl : o/ 0gg) where o/ is not necessarily a type
variable are allowed which are disallowed in HM(REC). Please note, it is crucial
that label variables are not allowed to appear within record types. This would
immediately prevent a resolution of equality predicates. For instance, consider the
constraint

(fl : ff; l0 : fig = fl1 : Int; l2 : Boolg)

No most general unifier exists to resolve such an equality constraint.

To establish the principal constraint property in HM(RECl), I follow the development in HM(RECe). Given a projection-free constraint D where all kind constraints
are of the form (ff :: ^). W.l.o.g. D is satisfiable, otherwise it follows immediately
that no normal form exists all. The closure Cl(D) of a constraint D is the smallest
constraint which fulfills the following conditions:

1. D ` Cl(D)
2. If (ff = fl1 : o/1; : : : ; ln : o/ng) 2 Cl(D)

then (ff :: ffl1 : o/1gg); : : : ; (ff :: ffln : o/ngg) 2 Cl(D)
3. If (ff :: ffl : o/1gg) and (ff :: ffl : o/2gg) 2 Cl(D)

then (o/1 = o/2) 2 Cl(D)

CHAPTER 5. APPLICATIONS 90

Herbrand unification resolves then all equality constraints in Cl(D). But this
does not immediately lead to a principal normal form of D. Consider the constraint

(fl1 : o/1; l2 : o/2g :: ffl : ffgg) ^ (label(l1) = label(l))
Then the above describe normalization procedure would yield the constraint

(fl1 : o/1; l2 : o/2g :: ffl1 : ffgg)
which is not in solved form yet. Hence, it is necessary to perform several iterations
until the principal normal form is achieved. This is similar to record concatenation
in the previous section.

Given D as described above. I set D1 = D; OE0 = id and Di+1 = OEiDi where OEi
is the mgu of all equality problems in Cl(Di) for i ? 0. It is easy to see that the
sequence of D1; D2; : : : has a fixed point. Therefore, the iteration process terminates
at a step i. Then (OED; OE) where OE = OEi ffi : : : ffi OE1 represents the principal normal
form.

The lifting method leads to the following theorem.

Theorem 22 The constraint system RECl satisfies the principal constraint property.

Encoding Type Case
I apply the record calculus with polymorphic field labels to encode a form of type
case. The type case rule is usually written as follows:

\Gamma  ` ei : o/ 0i for i = 1; : : : ; n
\Gamma  ` e : o/j for some j = 1; : : : ; n

\Gamma  `

typecase e of o/1 ) e1

..
.

o/n ) en : o/ 0j

Depending on e's type, the corresponding branch is chosen. The denotational
semantics of typecase contains no surprises:

[[typecase e of o/1 ) e1

..
.

o/n ) en]]j

= if [[e]]j 2 [[o/1]]then [[e1]]j

else if : : :
else if [[e]]j 2 [[o/n]]then [[en]]j
else W

CHAPTER 5. APPLICATIONS 91

I show now how to represent type case as a primitive function and not as a
typing rule. The exercise here is not to give applications of the type case statement.
Possible applications could involve system to model overloading respectively a form
of dynamic typing. I rather show how the type case rule can be neatly be represented
through a primitive function based on the record calculus with polymorphic field
labels.

I assume that there is additionally the following primitive in the initial type
environment \Gamma 0.

typecase : 8ff; fi; fl:9l:(ff :: ffl : fi ! flgg) ) fi ! ff ! fl
Furthermore, I assume that there are annotated function abstractions of the form
*x : o/:e which states that function parameter x has type o/ . Then, the type case
statement

typecase e of o/1 ) e1

..
.

o/n ) en

can be represented as

typecase e fl1 = *x : o/1:e1; : : : ; ln = *x : o/n:eng (5.2)
where fl1 = *x : o/1:e1; : : : ; ln = *x : o/n:eng is a record with distinct constant labels
l1; : : : ; ln and x is a fresh type variable.

Assume e has type o/ and

fl1 = *x : o/1:e1; : : : ; ln = *x : o/n:eng
has type

fl1 : o/1 ! o/ 01; : : : ; ln : o/n ! o/ 0ng

where field labels li have label type li and expression ei have type o/ 0i . Expression 5.2
is well-typed if the constraint

(fl1 : o/1 ! o/ 01; : : : ; ln : o/n ! o/ 0ng :: ffl : o/ ! flgg)
is fulfilled. The constraint rules enforce type o/ to match any of the types o/j's. This
automatically selects one of the branches and determines result type fl to be o/ 0j.

5.1.4 Records with Overloaded Field Labels
I have already noted that Ohori's record calculus can be encoded in terms of the
Odersky/Wadler/Wehr overloading system. In Section 5.2.1, I give an extension
of the Odersky/Wadler/Wehr overloading system which allows to encode Ohori's
system extended with overloaded field labels.

CHAPTER 5. APPLICATIONS 92
5.1.5 Summary
There is already lots of work done in the area of record calculi, see [HP91, Car84,
CM89, EST95b, R'em95a, Jon92, Oho95, Wan88, Wan89, R'em95b, R'em89]. In the
present work, I showed how to encode Ohori's record calculus as an HM(X) instance
and provided various useful extensions such as extensible records, record concatenation and first-class labels. The HM(X) system proved to be useful in designing such
extensions in a systematic way. In turn, I relate the HM(X) record applications to
some previous work.

Extensible records were already considered by [Gas98, HP90, R'em93]. In my dissertation, I show that Ohori's work can be extended to deal with extensible records.
Gaster's work [Gas98] improves compared to others in that he can provide an efficient
compilation method for extensible records. In [Dri93, DH95] efficient implementation methods for dynamic dispatch are studied in the context of object-oriented
languages with multiple inheritance. This suggests that the HM(X) applications
with extensible records and record concatenation can be implemented efficiently.

Record concatenation was studied in [Rem92a, Wan93, Ken96]. But only the
work by Kennedy [Ken96] achieves principal types with a unification-based approach. His form of record concatenation is limited to fields that must be of the
same type. The HM(X) application HM(RECc) provides record concatenation while
still retaining principal types. The crucial difference compared to previous applications lies in representing information by constraints of the form concat(ff; fi; fl)
rather than representing typing information in the language of types. For instance,
Wand [Wan93] can not give a principal type to the following expression:

f x y = (concat(x,y)).l + 1
This should be applicable to any pair of records x and y in which x has an integer
field l or in which y has an integer field l and field l is absent in x. The best type
Wand can give to the above expression is a disjunction of two types. Such problems
occur due to a term representation of typing information in Wand's system. In
contrast, the HM(X) application with record concatenation can give the following
principal type:

f : 8ff; fi; fl:(fl :: ffl : Intgg) ^ concat(ff; fi; fl) ) ff ! fi ! Int
Typing information is now represented in constraint form which allows an achievement of principal types while still following a unification-based approach.

A calculus similar to HM(RECl) where labels are first-class has already been
proposed by Gaster [Gas98] and Nishimura [Nis98]. In Section 3.5.4, I have already
pointed out the shortcomings of Nishimura's formulation of the quantifier introduction rule which can be solved by the HM(X) formulation. In Appendix B.2, I

CHAPTER 5. APPLICATIONS 93
give an example which shows limitations of Gaster's record calculus with first-class
labels. I give a program which is not typable in his system. This is due to the
fact that typing information about records is represented in the type language. For
instance, the type fl : ffjrg represents all values which contain at least a field with
label l and type ff. Such values are characterized by the type fi under the constraint (fi :: ffl : ffgg) in REC. In general, more programs are typable in HM(RECl)
than in Gaster's calculus.

Polymorphic field labels seem to be especially interesting. In Section 5.1.3, I
showed how to encode a type case construct in terms of a record calculus with
polymorphic field labels. Hence, records with first-class labels provide a form of
overloading. This suggests that there must a close relationship 1 between records
and overloading.

5.2 Odersky/Wadler/Wehr Overloading
I give a translation of the overloading approach by Odersky et al [OWW95] (to which
I refer as SystemO) in terms of an HM(X) application. Odersky et al. consider the
overloading of functions where overloading is restricted to the argument type. Hence,
it is forbidden to overload numeric constants because the overloaded identifier always
has to be a function type, and overloading is restricted to the first argument.

I define a constraint system OVER which captures the properties of the overloading system SystemO as described in [OWW95]. Essentially, there are two different
kinds of constraints. Constraints of the form (o :: ff ! o/ ) restrict the possible instances of a type variable ff for a given overloaded identifier o. For instance, consider
the following program:

f : 8ff; fi:(o :: ff ! fi) ) ff ! fi
f x = o x

The function f takes only arguments for which an instance declaration of an overloaded identifier o with the same argument type is given.

The other kind of constraints are of the form (o :: oeT ). Constraints of this
kind are used to describe instance declarations of overloaded identifiers. I use the
subscript T on the type scheme oeT to describe the head type constructor of that
type scheme. I put the following conditions on oeT :

oeT = T _ff ! o/ fv(o/ ) ` _ff

j 8ff:ssff ) oe0T fv(ssff) ` fv(oe0T )
1Note that Odersky et al. could show that their overloading system is able to express Ohori

style records.

CHAPTER 5. APPLICATIONS 94
where I assume that the constraint ssff only contains predicates of the form (o :: ff !
o/ ). Furthermore, I assume that oeT is a closed type scheme. Please note, as observed
in Section 3.4.5 and in Section 3.5.3 type schemes of the form

8ff1:ssff1 ) : : : 8ffn:ssffn ) o/
can be seen equivalent to

8ff1; : : : ; ffn:ssff1 ^ : : : ^ ssffn ) o/
Therefore, it is possible to see the first type scheme as an abbreviation for the other
type scheme.

Constraint system OVER is defined as follows:

OVER1 (o :: ff ! o/ ) ^ (o :: ff ! o/ 0) `e (o/ = o/ 0)

OVER2

(o :: T _o/1 ! o/1) ^ (o :: T _o/2 ! o/2)

`e
(_o/1 = _o/2) ^ (o/1 = o/2)

OVER3 C ^ (o :: 8 _ff:D ) o/ ) `e (o :: [_o/ = _ff]o/ )

if C `e [_o/ = _ff]D
OVER4 9ff:(o :: ff ! o/ ) =e true

Rules OVER1 and OVER2 enforce that the argument type uniquely determines
the result type. Rule OVER4 reflects the fact that I implement an open world
approach. This is similar to type classes.

The set S of solved forms in HM(OVER) consists of all satisfiable constraints of
the form

C ::= fg j (o :: ff ! o/ ) j C ^ C j 9 _ff:C
Furthermore, I put two additional conditions on the set S. First, I require that the
constraints in S are equation-free, i.e. C `e (o/ = o/ 0) must imply `e (o/ = o/ 0).

For instance,

(o :: ff ! fi) ^ (o :: ff ! fl ! fl)

is not equation-free because

(o :: ff ! fi) ^ (o :: ff ! fl ! fl) `e (fi = fl ! fl)
Finally, I impose an ordering relation on the type variables in a constraint in solved
form. For every C 2 S there is an ordering ! on the type variables in C such that
for all predicates (ff :: k) and fi 2 fv(k) with C `e (ff :: k) it holds that ff ! fi. For

CHAPTER 5. APPLICATIONS 95
instance, consider the constraint (o :: ff ! fi). which is in solved form. It holds that
ff ! fi. This condition prohibits cyclic dependencies between type variables that
appear in constraints.

For each overloaded identifier o, I now add primitives of the form

o : 8ff; fi:(o :: ff ! fi) ) ff ! fi
to the initial type environment \Gamma 0. Note, the overloaded identifier o appears as a
term variable but also in the constraint (o :: ff ! fi).

There are additionally instance declarations of the form inst o : oeT = e in p in
the term language. This the meaning of the identifier o with the function given by
e on all arguments that are constructed from the type constructor T . The extended
term language is as follows:

Declarations p ::= e j inst o : oeT = e in p
where the term e stands for an expression.

There is one additional typing rule for creation of new instance declarations.

(Inst)

X' = X [ `e (o :: oeT )

C; \Gamma ; X ` e : oeT C; \Gamma ; X' ` p : oe0

C; \Gamma ; X' ` inst o : oeT = e in p : oe0

The derivation ` is now additionally parameterized in the constraint system because
new facts are added with each instance declaration. Please note, assume there are
two instance declarations for an overloaded identifier o with the same head type
constructor. Then, there are two new constraint rules `e (o :: oe0T ) and `e (o :: oeT ).
The rules put on the constraint system OVER ensure that the two type schemes
oe0T and oeT have to be equivalent 2. But this does not ensure that the meaning of
the two instances are the same. Hence, I require that there is only one instance
declaration for overloaded identifier o with head type constructor T .

Another issue is the semantic meaning of such programs. I assume that first
all instance declarations are processed which allows the constraint system to be
fixed. In [OWW95] a denotational semantics for SystemO is given from which the
denotational semantics in HM(X) originated.

I establish now a connection between HM(OVER) and the original approach SystemO.
In Section 3.5.3, I already discussed differences between the formulation of the quantifier introduction rule in SystemO and HM(X). Please note, in HM(OVER) projection does not need to be trivial. This does not extend the expressiveness of the
language as stated in the following theorem. I refer to the appendix for a proof
sketch.

2See the subsection about ordering relations in Section 3.4

CHAPTER 5. APPLICATIONS 96
Theorem 23 (Full and Faithful) HM(OVER) models SystemO fully and faithfully.

5.2.1 Overloaded Curried Functions
I extend the overloading approach SystemO with curried overloaded functions. In
such an extension there are constraints of the form (o :: ff ! fi ! o/ ). The idea is
now that not only can the first argument be overloaded but also the second argument
as well.

Such a calculus proves to be useful in dealing with printer functions where one not
only can specify the format but also the device. For instance, print : HP-Printer !
Postscript ! () specifies a print function that supports the Postscript-format for a
specific printer. One could also think of print function that supports a specific file
format for a hard disk, specified by print : Harddisk ! Unix ! ().

Furthermore, it follows immediately that the record calculus with overloaded
field labels can be encoded in such an extended overloading application.

An overloaded identifier might now depend on two different type constructors.

oeT1T2 = T1 _ff ! T2 _fi ! o/ fv(o/ ) ` _ff [ _fi

j 8ff; fi:ssfffi ) oe0T1T2 fv(ssfffi) ` fv(oe0T1T2)

where I assume that the constraint ssfffi only contains predicates of the form (o ::
ff ! fi ! o/ ). Furthermore, I assume that oeT1T2 is a closed type scheme. The
other constraints are of the form (o :: ff ! fi ! o/ ). Compared to the original
overloading approach condition OVER2 is split into two conditions to deal with
curried overloaded functions.

CHAPTER 5. APPLICATIONS 97

OVER1

(o :: ff ! fi ! o/ ) ^ (o :: ff ! fi ! o/ 0)

`e
(o/ = o/ 0)

OVER2

(o :: T _o/1 ! S _o/ 01 ! o/1) ^ (o :: T _o/2 ! S _o/ 02 ! o/2)

`e
(_o/1 = _o/2) ^ (_o/ 01 = _o/ 02) ^ (o/1 = o/2)

OVER3

(o :: T _o/1 ! ff ! o/1) ^ (o :: T _o/2 ! ff ! o/2)

`e
(_o/1 = _o/2) ^ (o/1 = o/2)

OVER4

(o :: ff ! T _o/1 ! o/1) ^ (o :: ff ! T _o/2 ! o/2)

`e
(_o/1 = _o/2) ^ (o/1 = o/2)

OVER5 C ^ (o :: 8ff:D ) o/ ) `e (o :: [o/ =ff]o/ )

if C `e [o/ =ff]D
OVER6 9ff:(o :: ff ! fi ! o/ ) =e true

Note, condition OVER2 states that as soon as the head type constructors of the
two argument types are fixed, the result type is uniquely determined but not earlier.
Conditions OVER3 and OVER4 state that if one argument type is fixed and the
head type constructor of the other argument type is known, then the result type is
uniquely determined. Condition OVER1 covers the case if the two argument types
are type variables.

The set S of solved forms consists of all satisfiable and equation-free constraints
of the form

C ::= fg j (o :: ff ! fi ! o/ ) j C ^ C
Wehr [Weh97] also introduces curried overloaded functions. The idea is to encode
curried overloaded functions in terms of the basic overloading system. For instance,
consider two overloaded instances

o : 8 _ff:C ) T ! S ! o/1
o : 8 _fi:C0 ) T ! T ! o/2

where there are two constant type constructors T and S. Instead of these two
instances he introduces

o : 8ff; fi:(o0 :: ff ! fi) ) T ! ff ! fi

CHAPTER 5. APPLICATIONS 98
where for each argument type there are instance declarations

o0 : 8 _ff:C ) S ! o/1
o0 : 8 _fi:C0 ) T ! o/2

Further details can be found in [Weh97].

In Wehr's curried overloaded function approach [Weh97], it is not obvious how
to encode records with overloaded field labels. For instance, in his system it is not
possible to type the program 3 in Example 17 in Section 3.5.4.

5.2.2 Overloaded Identifiers as First-Class Values
In the previous applications, overloaded identifiers were considered as constants.
Now, overloaded identifiers become first class values that can be passed around as
arguments. This requires a couple of changes. In the term language, I distinguish
now between overloaded variables and constants. This is in contrast to the previous
applications which considered overloaded identifiers as primitives. This change requires to distinguish between overloaded constants and variables. The development
is similar to the record calculus with first-class labels.

Over o ::= ff j o1 j : : :
Types o/ ::= ff j over(o) j o/ ! o/

The constraint ( :: ) takes additionally an overloaded identifier type as a parameter. I assume that the signature of the predicate ( :: ) specifies that the first
argument always has to be an overloaded identifier.

The constraint rules are almost the same as in the original application. In the
following rules the term o stands for an overloaded type variable.

OVER1 (o :: ff ! o/ ) ^ (o :: ff ! o/ 0) `e (o/ = o/ 0)

OVER2

(o :: T _o/1 ! o/1) ^ (o :: T _o/2 ! o/2)

`e
(_o/1 = _o/2) ^ (o/1 = o/2)

OVER3 C ^ (o :: 8ff:D ) o/ ) `e (o :: [o/ =ff]o/ )

if C `e [o/ =ff]D
OVER4 9ff:(oi :: ff ! o/ ) =e true

The definition of solved forms is standard. The set S of solved forms consists of
all satisfiable and equation-free constraints of the form

3Remember, this example is based on the curried overloading application.

CHAPTER 5. APPLICATIONS 99

C ::= fg j (o :: ff ! o/ ) j C ^ C
I also do not need anymore primitives for each overloaded constants. There are
the following primitive in the initial type environment \Gamma 0:

@ : 8o; ff; fi:(o :: ff ! fi) ) over(o) ! ff ! fi
This primitive can be read as invoke overloaded identifier o at argument ff.
Instead of o x I write now @ o x. Furthermore, I require that instance declarations
are only allowed for overloaded constants.

Note, in order to model the Example 18 in Section 3.5.4, I actually need an
overloading application that models first class overloaded identifiers combined with
curried overloading. For instance, the record constraint (ff :: ffprint : fi ! ()gg) in
function g translates to the overloaded constraint (print :: ff ! fi ! ()) where print
is an overloaded type variable and I additionally overload the second argument type.
It is straightforward to combine the curried and first class overloading approach into
an overloading approach that combines these two features.

5.2.3 Summary
The overloading application does not fit as nicely as the record application into the
HM(X) system. An additional language construct must be declared which does not
seem to definable by a primitive. Further extensions have been proposed in [Weh97]
which might be worthwhile to express in terms of the HM(X) system.

Chapter 6
Conclusion

6.1 Achievements
One of the main goals of my dissertation was to come up with the cleanest possible
notation to achieve the most general results, following Einstein's principle: keep it
as simple as possible but not simpler.

I provided a general framework HM(X) to design Hindely/Milner style type systems in a concise way. The design of a new type system (or static analysis) starts
with the definition of the appropriate domain of types and constraints. Basic operations can then be added as primitive functions. For details see Section 3.2. Type
system instances of HM(X) are sound provided the underlying constraint system is
sound. See Section 3.3 for details. HM(X) can be seen as the proper logical framework to deal with constraints and Hindley/Milner style polymorphism. This issue
is studied in Section 3.5. Constraints improve over types as shown in Section 3.6.
For this purpose, I provided a purely constraint-based formulation of the HM(X)
framework in Section 3.7. Furthermore, I provided a generic inference system. Principal types can be inferred if the constraint system satisfies the principal constraint
property. I introduced various inference systems and proved soundness as well as
completeness results. For an overview of the achieved results see Section 4.5. The
main novelty is a constraint-based inference system which improves significantly
over previous formulations. Specifically, I solve the open problem of type inference for non-regular theories. In addition, I showed that several variations of the
Hindley/Milner type system can be seen as instances of the HM(X) framework. I
focused on applications which deal with records. One novelty is a record application
which allows concatenation of records and still achieves principal types based on
unification. See Chapter 5 for details.

100

CHAPTER 6. CONCLUSION 101
6.2 Implementation
In Appendix D, I give a specification of the generic HM(X) inference system in
terms of the functional language Haskell. The goal was rather to provide a rigorous
specification of the essential inference components than to provide an optimized
implementation. A similar goal was pursued in case of Haskell's type system [Jon99].
The applicability of the HM(X) systems was demonstrated in [PS99] and [Zen99b].
In the first paper, the authors demonstrated how some of the ideas presented in
my dissertation can be applied to other settings such as architecture description
languages [GMW97]. The other paper provides an implementation of the dimension
analysis in Pizza [OW97] which is an extension of the Java language [GJS96] with
polymorphism, higher-order types and algebraic data types.

An efficient implementation method for general HM(X) application is still missing. Efficient compilation methods are available for more specific applications such
as records [Oho95, Gas98]. I believe it is rather difficult to give an efficient compilation method for general HM(X) applications.

I believe that an efficient compilation method is less important in the light of
applying the HM(X) systems to perform static analyses such as dimension analysis.
Modelling static analyses in terms of the HM(X) system is a promising area for
future work.

6.3 Future Work
Recently, Foster, F"ahndrich and Aiken [FFA99] described a framework for adding
type qualifiers to a language. An example of a type qualifier form the C world is
the ANSI C qualifier const. Yet another example of type qualifiers comes from
binding-time analysis [DHM95]. There, qualifier static denotes values know at
compile-time whereas dynamic denotes run-time values. While Foster, F"ahndrich
and Aiken have not yet formalized their system in terms of the HM(X) system,
their inference system already borrows ideas from the HM(X) system. I believe
their whole framework can be readily described in terms of the HM(X) system.

Another interesting topic for future work is to look at systems which deal with
indexed data structures. I am most interested in systems which deal with indexed
data structures such as arrays and matrices. Previous approaches mostly rely on a
form of dependent types [XP98, Zen99a] to deal with indexed data structures. The
concept of dependent types allows a consideration of types which not only have type
parameters, but additionally have value parameters, examples being matrices and
arrays. It remains to be seen whether a constraint-based formulation in terms of
HM(X) has advantages.

It is also interesting to extend the HM(X) framework to richer type systems,
incorporating advanced features such as existential types and first-class polymorCHAPTER 6. CONCLUSION 102
phism. This seems to be especially necessary when modelling index systems [XP98,
Zen99a].

Bibliography
[AW93] Alexander Aiken and Edward L. Wimmers. Type inclusion constraints

and type inference. In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark,
pages 31-41, New York, June 1993. ACM Press.

[BS94] F. Baader and J.H. Siekmann. Unification theory. In D.M. Gabbay,

C.J. Hogger, and J.A. Robinson, editors, Handbook of Logic in Artificial
Intelligence and Logic Programming, pages 41-125. Oxford University
Press, Oxford, UK, 1994.

[Car84] Luca Cardelli. A semantics of multiple inheritance. In Gilles Kahn,

David B. MacQueen, and Gordon D. Plotkin, editors, Semantics of
Data Types, pages 51-67. Springer-Verlag, June 1984. Lecture Notes in
Computer Science 173.

[Car97] Cardelli. Type systems. In Jr. Allen B. Tucker, editor, The Computer

Science and Engineering Handbook. CRC Press, 1997.

[CM89] Luca Cardelli and John C. Mitchell. Operations on records. In M. Main,

A. Melton, M. Mislove, and David Schmidt, editors, Proceedings Mathematical Foundations of Programming Semantics, 5th International Conference, Tulane University, New Orleans, Louisiana, USA, pages 22-52.
Springer-Verlag, March/April 1989. Lecture Notes in Computer Science
442.

[Dam85] Luis Damas. Type Assignment in Programming Languages. PhD thesis,

Edinburgh University, 1985.

[DH95] K. Driesen and U. Hoelzle. Minimizing row displacement dispatch tables. ACM SIGPLAN Notices, 30(10):141-155, October 1995.

[DHM95] Dirk Dussart, Fritz Henglein, and Christian Mossin. Polymorphic

binding-time analysis in polynomial time. In Proceedings of SAS, pages
118-135. Springer Verlag, September 1995.

103

BIBLIOGRAPHY 104
[DM82] L. Damas and R. Milner. Principal type-schemes for functional programs. In Conference Record of the Ninth Annual ACM Symposium
on Principles of Programming Languages, pages 207-212. ACM, ACM,
January 1982.

[Dri93] Karel Driesen. Selector table indexing and sparse arrays. In Andreas

Paepcke, editor, Proceedings of the 8th Annual Conference on ObjectOriented Programming Systems, Languages and Applications, pages
259-270, Washington, DC, USA, September 26October -1 1993. ACM
Press.

[EST95a] J. Eifrig, S. Smith, and V. Trifonov. Sound polymorphic type inference

for objects. In OOPSLA '95 Conference Proceedings, volume 30(10) of
ACM SIGPLAN Notices, pages 169-184, 1995.

[EST95b] Jonathan Eifrig, Scott Smith, and Valery Trifonov. Type inference for

recursively constrained types and its application to object oriented programming. In Electronic Notes in Theoretical Computer Science, volume 1, 1995.

[FFA99] Jeffrey S. Foster, Manuel F"ahndrich, and Alexander Aiken. A theory

of type qualifiers. ACM SIGPLAN Notices, 34(5):192-203, May 1999.
Proceedings of the 1999 ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI).

[Gas98] Benedict R. Gaster. Records, variants, and qualified types. PhD thesis,

Computer Science, University of Nottingham, July 1998.

[GJS96] James Gosling, Bill Joy, and Guy Steele. The Java Language Specification. Java Series, Sun Microsystems, 1996. ISBN 0-201-63451-1.

[GMW97] David Garlan, Robert T. Monroe, and David Wile. ACME: An Architecture Description Interchange Language. In Proceedings of CASCON'97, pages 169-183, Toronto, Ontario, November 1997.

[HMT71] L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebra. North-Holland

Publishing Company, 1971.

[HP90] Robert W. Harper and Benjamin C. Pierce. Extensible records without

subsumption. Technical Report CMU-CS-90-102, School of Computer
Science, Carnegie Mellon University, Feburary 1990.

[HP91] Robert Harper and Benjamin Pierce. A record calculus based on symmetric concatenation. In Conference Record of the Eighteenth Annual

BIBLIOGRAPHY 105

ACM Symposium on Principles of Programming Languages, Orlando,
Florida, pages 131-142. ACM Press, January 1991.

[HW73] C. A. R. Hoare and Niklaus Wirth. An axiomatic definition of the

programming language Pascal. Acta Informatica, 2:335-355, 1973.

[JM94] Joxan Jaffar and Michael Maher. Constraint logic programming: A

survey. Journal of Logic Programming, 19(20):503-581, 1994.

[Jon92] Mark P. Jones. Qualified Types: Theory and Practice. D.phil. thesis,

Oxford University, September 1992.

[Jon99] Mark Jones. Typing Haskell in Haskell. In Haskell Workshop, September

1999.

[Kae92] S. Kaes. Type inference in the presence of overloading, subtyping and

recursive types. In Proceedings of the 1992 ACM Conference on LISP
and Functional Programming, pages 193-204, 1992.

[Ken94] Andrew Kennedy. Dimension types. In Donald Sannella, editor, Programming Languages and Systems--ESOP'94, 5th European Symposium on Programming, volume 788 of Lecture Notes in Computer Science, pages 348-362, Edinburgh, U.K., 11-13 April 1994. Springer.

[Ken96] Andrew J. Kennedy. Type inference and equational theories. Technical Report LIX/RR/96/09, LIX, Ecole Polytechnique, 91128 Palaiseau
Cedex, France, September 1996.

[KMM91] P.C. Kanellakis, H.G. Mairson, and J.C. Mitchell. Unification and ML

type reconstruction. In Computational Logic, Essays in Honor of Alan
Robinson, pages 444-478. MIT Press, 1991.

[LBB84] D. S. Lankford, G. Butler, and B. Brady. Abelian group unification algorithms for elementary terms. In W. Bledsoe and W. Loveland, editors,
Automated Theorem Proving: After 25 Years. AMS, 1984.

[LMM87] J. Lassez, M. Maher, and K. Marriott. Unification revisited. In

J. Minker, editor, Foundations of Deductive Databases and Logic Programming. Morgan Kauffman, 1987.

[Mil78] Robin Milner. A theory of type polymorphism in programming. Journal

of Computer and System Sciences, 17:348-375, Dec 1978.

[MPS86] D. MacQueen, G. Plotkin, and R. Sethi. An ideal model for recursive

polymorphic types. Information and Control, 71:95-130, 1986.

BIBLIOGRAPHY 106
[MTHM97] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The

Definition of Standard ML (Revised). The MIT Press, 1997.

[Nis98] Susumu Nishimura. Static Typing for Dynamic Messages. In Conference

Record of POPL '98: 25th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Diego, Calif. ACM,
January 1998.

[NP95] Tobias Nipkow and Christian Prehofer. Type reconstruction for type

classes. Journal of Functional Programming, 5(2):201-224, 1995.

[Oho95] Atsushi Ohori. A polymorphic record calculus and its compilation. ACM

TOPLAS, 6(6):805-843, November 1995.

[Oho97] A. Ohori. Type system for specializing polymorphism. Lecture Notes

in Computer Science, 1281:107-122, 1997.

[OL96] Martin Odersky and Konstantin L"aufer. Putting type annotations to

work. In Proc. 23rd ACM Symposium on Principles of Programming
Languages (POPL), pages 65-67, January 1996.

[OSW99] Martin Odersky, Martin Sulzmann, and Martin Wehr. Type inference

with constrained types. Theory and Practice of Object Systems, 5(1):35-
55, 1999.

[OW97] Martin Odersky and Philip Wadler. Pizza into Java: Translating theory into practice. In Conference Record of POPL '97: The 24th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 146-159, Paris, France, 15-17 January 1997.

[OWW95] Martin Odersky, Philip Wadler, and Martin Wehr. A second look

at overloading. In Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture (FPCA'95), pages 135-146, La Jolla, California, June 25-28, 1995.
ACM SIGPLAN/SIGARCH and IFIP WG2.8, ACM Press.

[PH97] John Peterson and Kevin Hammond. Report on the programming language Haskell: a non-strict, purely functional language, version 1.4.
Technical Report YALEU/DCS/RR-1106, Yale University Department
of Computer Science, March 1997.

[Pot98] Francois Pottier. A framework for type inference with subtyping. In

Proceedings of the third ACM SIGPLAN International Conference on
Functional Programming (ICFP '98), pages 228-238, September 1998.

BIBLIOGRAPHY 107
[PS99] John Peterson and Martin Sulzmann. Analysis of Architectures using

Constraint-Based Types. In WICSA1 First Working IFIP Conference
on Software Architecture, February 1999. position paper.

[R'em89] Didier R'emy. Typechecking records and variants in a natural extension

of ML. In Conference Record of POPL '89: The 16th ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, January
1989.

[Rem92a] D. Remy. Typing record concatenation for free. In ACM, editor, Conference record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages: papers presented at
the symposium, Albuquerque, New Mexico, January 19-22, 1992, pages
166-176, New York, NY, USA, 1992. ACM Press.

[R'em92b] Didier R'emy. Extending ML type system with a sorted equational theory. Technical Report 1766, INRIA, October 1992.

[R'em93] Didier R'emy. Type inference for records in a natural extension of ML.

In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects Of
Object-Oriented Programming. Types, Semantics and Language Design.
MIT Press, 1993.

[R'em95a] Didier R'emy. A case study of typechecking with constrained types:

Typing record concatenation. Presented at the workshop on advances
in types for computer science at the Newton Institute, Cambridge, UK.
Available electronically at http://pauillac.inria.fr/~remy, August
1995.

[R'em95b] Didier R'emy. Refined subtyping and row variables for record types.

Presented at the workshop on advances in types for computer science
at the Newton Institute, Cambridge, UK. Avaliable electronically at
html://pauillac.inria.fr/~remy, August 1995.

[Rob65] J. A. Robinson. A machine-oriented logic based on the resolution principle. Journal of the Association for Computing Machinery, 12:23-41,
1965.

[Sar93] Vijay A. Saraswat. Concurrent Constraint Programming. Logic Programming Series, ACM Doctoral Dissertation Award Series. MIT Press,
Cambridge, Massachusetts, 1993.

[Smi91] Geoffrey S. Smith. Polymorphic type inference for languages with overloading and subtyping. PhD thesis, Cornell University, Ithaca, NY, August 1991.

BIBLIOGRAPHY 108
[SOW97] Martin Sulzmann, Martin Odersky, and Martin Wehr. Type inference

with constrained types. In FOOL4: 4th. Int. Workshop on Foundations
of Object-oriented programming Languages, January 1997.

[Str67] Christopher Strachey. Fundamental concepts in programming languages. unpublished lecture notes, August 1967.

[Tre93] Ralf Treinen. Feature constraints with first-class features. In Andrzej M.

Borzyszkowski and Stefan Sokolowski, editors, Mathematical Foundations of Computer Science, Lecture Notes in Artificial Intelligence, vol.
711, pages 734-743, Gda'nsk, Poland, 30 August-3 September 1993.
Springer-Verlag.

[TS96] Valery Trifonov and Scott Smith. Subtyping Constrained Types. In

Proceedings of the Third Internationl Static Analysis Symposium, volume 1145 of LNCS, pages 349-365, 1996.

[VHJW96] Cordelia V.Hall, Kevin Hammond, Simon L. Peyton Jones, and

Philip L. Wadler. Type classes in Haskell. ACM TOPLAS, 18(2):109-
138, March 1996.

[Wan87] Mitchell Wand. A simple algorithm and proof for type inference. In

Fundamenta Informaticae X, pages 115-122. North-Holland, 1987.

[Wan88] Mitchell Wand. Corrigendum: Complete type inference for simple objects. In Proceedings of the IEEE Symposium on Logic in Computer
Science, page 132, 1988.

[Wan89] Mitchell Wand. Type inference for record concatenation and multiple

inheritance. In Proceedings of the IEEE Symposium on Logic in Computer Science, pages 92-97, June 1989.

[Wan93] Mitchell Wand. Type inference for record concatenation and multiple

inheritance. Information and Computation, pages 1-15, 93.

[Weh97] Martin Wehr. "Uberladung in Typsystemen. PhD thesis, Universit"at

Karlsruhe, October 1997.

[WF91] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type

soundness. Technical Report Rice COMP TR91-160, Rice University,
Houston, Texas, 1991.

[XP98] Hongwei Xi and Frank Pfenning. Eliminating Array Bound Cecking Trough Dependent Types. In Proceedings of the ACM SIGPLAN
'98 Conference on Programming Language Design and Implementation,
New York, June 1998. ACM Press.

BIBLIOGRAPHY 109
[Zen99a] Christoph Zenger. Indizierte Typen. PhD thesis, Universit"at Karlsruhe,

1999.

[Zen99b] Matthias Zenger. Implementing Equational Theories in Pizza, August

1999. personal communication.

Appendix A

Extensions

A.1 Extensible Records and Polymorphic Field

Labels

The predicate extend(\Delta ; \Delta ; \Delta ; \Delta ) takes now as an additional parameter a field label. The
constraint rules are as follows:

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)
REC3 extend(l; ff; fi; fl) `e (fl :: ffl : figg)
REC4 extend(l; ff; fi; fl) ^ (ff :: ffl0 : o/ gg) `e (fl :: ffl0 : o/ gg)
REC5 `e extend(ln+1; fl1 : o/1; : : : ; ln : o/ng; o/; fl1 : o/1; : : : ; ln : o/n; ln+1 : o/ g)

where l1; : : : ; ln+1 are distinct

The primitive functions for record extension is now written as follows:

extend : 8ff; fi; fl; l:extend(l; ff; fi; fl) ) label(l) ! ff ! fi ! fl
The set S of solved forms contains all satisfiable constraints. It is straightforward
to prove that satisfiability is decidable. I leave the question open whether more a
restricted set of solved forms still allows to retain principality of the constraint
system.

A.2 Symmetric Record Concatenation
I give a variation RECc

s

of RECc where record concatenation is symmetric. The

constraint rules are as follows:

110

APPENDIX A. EXTENSIONS 111

REC1 `e (fl1 : o/1; : : : ln : o/ng :: ffli : o/igg)

where l1; : : : ; ln are distinct
REC2 (o/ :: ffl : o/1gg) ^ (o/ :: ffl : o/2gg) `e (o/1 = o/2)
REC3 concat(ff; fi; fl) ^ (ff :: ffl : ffigg) ^ (finl) `e (fl :: ffl : ffigg)
REC4 concat(ff; fi; fl) ^ (fi :: ffl : ffigg) ^ (ffnl) `e (fl :: ffl : ffigg)
REC5 concat(ff; fi; fl) ^ (fl :: ffl : ffigg) ^ (finl) `e (ff :: ffl : ffigg)
REC6 concat(ff; fi; fl) ^ (fl :: ffl : ffigg) ^ (ffnl) `e (fi :: ffl : ffigg)
REC7 `e concat(f_l : _o/ g; f_l0 : _o/ 0g; f_l00 : _o/ 00g)

where _l00 = (_ln_l0) [ _l0 and o/ 00i = typeof (l00i )
REC8 `e (fl1 : o/1; : : : ; ln : o/ngnl0)

where l0 6= li

Please note the differences in rules REC3 and REC8 compared to the rules
given in Section 5.1.2. The principal constraint property can be established along
the lines of the asymmetric record concatenation application.

Appendix B
Miscellaneous

B.1 Satisfiability in RECl is NP-complete
To prove NP-completeness, I have to show that satisfiability in RECl is NP-time
and NP-hard. It is easy to see that satisfiability is NP-time. To prove NP-hardness,
I reduce the maximum-cover problem to satisfiability in RECl.

Definition 30 (Maximum-Cover Problem) Given n sets S1; : : : ; Sn such thatS

i Si = fx1; : : : ; xmg and a natural number k. Find a set I ` f1; : : : ; ng such that
jIj ^ k and

S

j2I Sj =

S

i Si.

I refer to the (n + 1)-tuple (S1; : : : ; Sn; k) as the maximum-cover problem.

I give a constraint C 2 RECl such that C is satisfiable iff (S1; : : : ; Sn; k) holds.
The reduction goes as follows. I represent an element xi as types xi and a set Si as
a record type fli1 : xi1 ; : : : ; lir : xir g. The record variable ffj represents a Sj; j 2 I
stated by Cj = (fl1 : S1; : : : ; ln : Sng :: fffij : ffjgg) where fij's are label variables.
Then D1 =

Sk

j=1 Cj states that there are k sets Sj.
Given an element xi. The constraint

C0i = 9l; ff:((ff :: ffl : xigg) ^ (9l0:(fl1 : ff1; : : : ; lk : ffkg :: ffl0 : ffgg)))
states each element xi belongs to at least one Sj.

Then (

Vm

i=1 C0i) ^ (

Vk

j=1 Cj) is satisfiable iff (S1; : : : ; Sn; k) holds.

B.2 A Motivating Example II
I give another example which points out problems when representing typing information in term form. I consider a record calculus with first-class field labels in style
of Gaster [Gas98]. There are record types of the form fl : ffjrg where l is a field
label with type ff and r is a row variable. The novelty is that field labels are now
first-class. Consider the following expression:

112

APPENDIX B. MISCELLANEOUS 113

f x =

let g = * y z . (x.y) z
in (g p1 1, g p2 true)

Function g takes as first argument a field label. It selects the field from the
given record and applies it to the second argument. In the let-body I apply g to
arguments of different types, therefore g must be of polymorphic type.

I consider now possible typings for the above program. Record selection can be
provided as a primitive operation which writes as follows:

(\Delta :\Delta ) : 8r; fi; l:l lacks r ) label(l) ! fl : fijrg ! fi
where the constraint l lacks r states that row r does not contain label l and the
constructor label(\Delta ) introduces the sub-language of label types. Note, because labels
are first-class I can pass label l as an argument to the record selection function.
Furthermore, the label primitives p1 and p2 are typed as follows:

p1 : label(ae1)
p2 : label(ae2)

where label(ae1) (resp label(ae2)) ensures that ae1 (resp ae2) is a label constant.

I consider a variation of Gaster's system where types are allowed to appear in
constraint form. The type () represents the unit type. Then, the above program is
typable in the following way:

f : 8ff; r0; r00: ae1 lacks r0 ^ ae2 lacks r00^

(ff = fae1 : Int ! ()jr0g) ^ (ff = fae2 : Bool ! ()jr00g)
) ff ! ((); ())
f x =

let g: 8ae; fi; r:ae lacks r ^ (ff = fae : fi ! ()jrg) ) label(ae) ! fi ! ()

g = * y z . (x.y) z
in (g p1 1, g p2 true)

In Gaster's original system explicit equality constraints are disallowed. Hence,
I need to resolve such constraints. But a problem occurs similar to the previous
example in Section 3.6.1. There is no term representation of type variable ff covering
all cases of the constraint representation. Hence, it is not possible to give function
g a type in Gaster's system.

Appendix C
Proofs
Quite often I apply induction on a given derivation. But in order to apply the induction hypothesis, I sometimes need to rewrite the premise. But this would break the
inductive proof. The trick is to first perform induction on the size of expressions and
then on the number of non-structural rules. In Figure C.1, I introduce a measure on
the size of expressions which is parameterized on a map w from identifiers to positive
integers. This method appears also in a technical report by Kennedy [Ken96]. He
mentions that the original idea is due to Tobias Nipkow.

Many proofs involves constraint reasoning. I will occasionally abbreviate constraint entailment `e with ` and constraint equality =e with =.

C.1 Proofs of Section 3.3.1
Lemma 7 Given a sound constraint system X and a closed type scheme oe. Then
W 62 [[oe]].
Proof: This is true for all monotypes _. Consider now a type scheme oe = (8 _ff:C )
o/ ). The type scheme oe is closed and all constraints have to be at least satisfiable,
hence `e 9 _ff:C. By assumption, the constraint system X is sound. Then I can
follow there are monotypes __ such that `e [__= _ff]C. Then the denotation of [[oe]] is
not an empty intersection. W is not contained in the denotation of any monotype,
thus W is not contained in [[oe]].

Theorem 5 (Type Soundness) Let C; \Gamma  ` e : oe be a valid typing judgment in
HM(X), where X is a sound and coherent constraint system. Let OE be a substitution
such that OE\Gamma  and OEoe are closed and such that `e OEC and OE is consistent in \Gamma . Let
j be a variable environment such that j j= OE\Gamma . Then

(1) W 62 [[OEoe]]
(2) [[e]]j 2 [[OEoe]]

114

APPENDIX C. PROOFS 115

ffi(w; x) = w(x)
ffi(w; *x:e) = 1 + ffi(w; e)
ffi(w; e1 e2) = ffi(w; e1) + ffi(w; e2)
ffi(w; let x = e1 in e2) = ffi(w; e1) + ffi(w[x 7! ffi(w; e1)]; e2)

Figure C.1: Measure of expression size

Proof: Please note, the assumptions ensure that OE is consistent in oe which implies
that the constraint component of OEoe is satisfiable. Then (1) follows immediately
from Lemma 7. I prove now (2) by a structural induction on typing derivations.
There are three interesting cases.

Case (Var) The last step of the derivation is:

C; \Gamma  ` x : oe (x : oe 2 \Gamma )
Therefore x : OEoe 2 OE\Gamma . Since j j= OE\Gamma , [[x]]j = j(x) 2 [[OEoe]].
Case (8 Intro) The last step of the derivation is:

C ^ D; \Gamma  ` e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  ` e : 8 _ff:D ) o/

Let OE be such that OE\Gamma  and OE(8 _ff:D ) o/ ) are closed and such that `e OE(C ^ 9 _ff:D).
Furthermore, I assume there are no name clashes between OE and _ff. Let __ be an
arbitrary vector of monotypes such that

`e 9 _ff:(( _ff = __) ^ OED)
Since C is sound there is at least one such vector __. Let OE0 = [__= _ff] ffi OE. Then since

_ff 62 fv(C), OE0(C ^ D) = OEC ^ OE0D, which expands to OEC ^ 9 _ff:((__ = _ff) ^ OED).
By our assumption this constraint is valid. Furthermore, OE0\Gamma  and OE0o/ are both
closed. By the induction hypothesis, [[e]]j 2 [[OE0o/ ]]. Since __ was arbitrary such that
`e [__= _ff](OED),

[[e]]j 2

T

f[[[__= _ff](OEo/ )]] j `e [__= _ff](OED)g

= [[OE(8 _ff:D ) o/ )]]:

Case (Sub) The last step of the derivation is:

C; \Gamma  ` e : o/ C `e (o/ _ o/ 0)

C; \Gamma  ` e : o/ 0

APPENDIX C. PROOFS 116
I know that there is a substitution OE such that OE\Gamma  and OEo/ 0 are closed and such that
`e OEC. It follows that `e (OEo/ _ OEo/ 0). It might be the case that OEo/ still contains
some free variables. I can extend OE to a substitution OE0 such that OE0o/ is closed.
Because OE0 is an extension of OE I get that OE0\Gamma  is closed and `e OE0C. Applying the
induction hypothesis, I get that [[e]]j 2 [[OE0o/ ]]. Because X is coherent I know that
[[OE0o/ ]] ` [[OE0o/ 0]]. Because OEo/ 0 is a closed type and OE0 extends OE I get that [[OE0o/ 0]] = [[OEo/ 0]]
and this yields [[e]]j 2 [[OEo/ 0]].

C.2 Proofs of Section 3.4.1
Lemma 10 The following inference rules are derivable.

(Ref-oe) C `i oe _ oe
(Weaken)

D `e C C `i oe _ oe0

D `i oe _ oe0

(Trans)

C `i oe1 _ oe2 C `i oe2 _ oe3

C `i oe1 _ oe3

Proof: I only prove the (Trans) rule. W.l.o.g. (I further assume that all derivations
are normalized as stated in Lemma 11)

oe1 = 8ff:D1 ) o/1;
oe2 = 8fi:D2 ) o/2 and
oe3 = 8fl:D3 ) o/3

where ff; fi and fl are distinct and new.
W.l.o.g.

C `i oe1 _ oe2

is derived from

C ^ D2 `i OE1o/1 _ o/2 C ^ D2 `e OE1D1

where OE1 = [o/ =ff] and

C `i oe2 _ oe3

is derived from

C ^ D3 `i OE2o/2 _ o/3 C ^ D3 `e OE2D2

where OE2 = [o/ 0=fi]:
It holds that

OE1C =e C and OE2C =e C:

APPENDIX C. PROOFS 117
Because `i and `e are closed under substitution it follows that

C ^ OE2D2 `e (OE2 ffi OE1)D1 C ^ OE2D2 `i (OE2 ffi OE1)o/1 _ OE2o/2:
Also,

C ^ D3 `e C ^ OE2D2

holds. Then it follows that

C ^ D3 `e (OE2 ffi OE1)D1 C ^ D3 `i (OE2 ffi OE1)o/1 _ o/3
and this yields

C `i oe1 _ oe3:

Lemma 11 Let C be a constraint and oe; oe0 be type schemes. Then C `i oe _ oe0 iff
C `i2 oe _ oe0.
Proof: That `i2 ` `i holds is not difficult to see.. In order to prove `i ` `i2 I
show that it is always possible to switch the order of consecutive (_ 8), (8 _) steps.
I assume there is the following derivation

C ^ D0 `i [o/ =ff]oe _ oe0 fi 62 tv([o/ =ff]oe) [ tv(C)
C ^ 9fi:D0 `i [o/ =ff]oe _ 8fi:D0 ) oe0 C ^ 9fi:D0 `e [o/ =ff]D

C ^ 9fi:D0 `i 8ff:D ) oe _ 8fi:D0 ) oe0

Starting from

C ^ D0 `i [o/ =ff]oe _ oe0:

I can perform a (8 _) step and get

C ^ D0 `i 8ff:D ) oe _ oe0:
I observe that fi 62 fv(8ff:D ) oe). That means, I can perform a (_ 8) step and
obtain

C ^ 9fi:D0 `i (8ff:D ) oe) _ (8fi:D0 ) oe0):

I have shown now that I always can delay (_ 8) steps. By a straightforward induction it can be shown that `i ` `i2 which concludes the proof.

APPENDIX C. PROOFS 118
C.3 Proofs of Section 3.4.4
Lemma 17 (Completeness of `s ) Given C0; \Gamma 0 `n e : oe0, C0 `i \Gamma  _ \Gamma 0 and \Gamma 0
is realizable in C0. Then

(a) oe0 = o/ : C; \Gamma  `s e : o/ C0 `e C
(b) otherwise : C; \Gamma  `s e : o/ C; \Gamma ; o/ `gen (oeo; Co)

C0 `e Co C0 `i oeo _ oe

Proof: I use induction on the derivation `n .
Case (Inst) I know that C0; \Gamma 0 `n x : oe0 where x : oe0 2 \Gamma 0. By assumption I know
there is a x : oe in \Gamma  such that C0 `i oe _ oe0. If oe0 = o/ then I can immediately apply
the (Inst) rule and I am done. Otherwise, w.l.o.g. I can assume that oe = 8 _ff:D ) o/ 0.
I set C = [ _fi= _ff]D and o/ = [ _fi= _ff]o/ 0 where _fi are fresh type variables. I apply again
the (Inst) rule and find C; \Gamma  `s x : o/ . I set (oeo; Co) = gen(C; \Gamma ; o/ ) where oeo is
essentially a renamed version of oe. I find that C0 `i oeo _ oe0. By assumption \Gamma 0 is
realizable in C0, hence there is a o/ such that C0 `e [_o/ = _ff]D. This leads us to the
conclusion that C0 `e Co and I am done.

Case (Abs) I find the following situation:

C0; \Gamma 0x:x : o/ 0 `n e : o/ 0
C0; \Gamma 0x `n *x:e : o/ 0 ! o/ 00

Application of the induction hypothesis yields

C; \Gamma x:x : o/ 0 `s e : o/ 00 C0 `e C
Then I can apply the (Abs) rule and get

C; \Gamma x `s *x:e : o/ 0 ! o/ 00:

Case (App) I find the following situation:

C0; \Gamma 0 `n e1 : o/1 ! o/2 C0; \Gamma 0 `n e2 : o/1

C0; \Gamma 0 `n e1e2 : o/2

I can apply the induction hypothesis to the left and right premise and get

C1; \Gamma  `s e1 : o/1 ! o/2
and

C2; \Gamma  `s e2 : o/1

APPENDIX C. PROOFS 119
where C0 `e C1 and C0 `e C2. Because `s is closed under strengthening the
constraint I get

C0; \Gamma  `s e1 : o/1 ! o/2

and

C0; \Gamma  `s e2 : o/1:

Application of the (App) yields

C0; \Gamma  `s e1e2 : o/2:

Case (Sub) I find the following situation:

C0; \Gamma 0 `n e : o/ C0 `e (o/ _ o/ 0)

C0; \Gamma 0 `n e : o/ 0

Here, only case (a) is possible. By induction I find that C; \Gamma  `s e : o/ and C0 `e C.
Then I also find C0; \Gamma  `s e : o/ . I apply the (Sub) rule and obtain C0; \Gamma  `s e : o/ 0.

Case (8 Intro) I find the following situation:

C0 ^ D; \Gamma 0 `n e : oe _ff 62 fv(C0) [ fv(\Gamma 0)

C0 ^ 9 _ff:D; \Gamma 0 `n e : 8 _ff:D ) oe

I consider two cases. First, assume oe = o/ . W.l.o.g. I can assume that _ff 62 fv(\Gamma ).
Application of the induction hypothesis yields

C; \Gamma  `s e : o/ C0 ^ D `e C
I define (oeo; Co) = gen(C; \Gamma ; o/ ). It holds that _ff 62 fv(oeo) [ fv(Co) because w.l.o.g.

_ff 62 fv(\Gamma ). Therefore, I can deduce that

C0 ^ 9 _ff:D `e Co
and

C0 ^ 9 _ff:D `i oeo _ 8 _ff:D ) o/:

Otherwise, I apply the induction hypothesis and get

C; \Gamma  `s e : o/
C0 ^ D `e Co C0 ^ D `i oeo _ oe where

C; \Gamma ; o/ `gen (oeo; Co):

Because _ff 62 fv(\Gamma ) I get that

C0 ^ 9 _ff:D `e Co

APPENDIX C. PROOFS 120
and

C0 `i oeo _ 8 _ff:D ) oe:

Then it is easy to see that

C0 ^ 9 _ff:D `i oeo _ 8 _ff:D ) oe
which establishes the induction step.
Case (Let) I find the following situation:

C0; \Gamma 0x `n e : oe C0; \Gamma 0x:x : oe `n e0 : o/ 0

C0; \Gamma 0x `n let x = e in e0 : o/ 0

First, I consider the case if oe is a type o/ . I apply the induction hypothesis to the
left premise and obtain C1; \Gamma x `s e : o/ and C0 `e C1. I find oeo; Co such that
C1; \Gamma x; o/ `gen (oeo; Co). It is an easy observation that C0 `i oeo _ o/ holds. Now,
I apply the induction hypothesis to the right premise. This yields C2; \Gamma x:x : oeo `s
e0 : o/ 0 and C0 `e C2. I weaken the constraint and find

C0; \Gamma x:x : oeo `s e0 : o/ 0:
It holds that C0 `e Co ^ C2. I apply the (Let) rule and obtain C0; \Gamma x `s let x =
e in e0 : o/ 0.

Now, let us consider the case if oe is a type scheme. Application of the induction
hypothesis to the left premise yields:

C1; \Gamma x `s e : o/ C1; \Gamma x; o/ `gen (oeo; Co)

C0 `i oeo _ oe C0 `e Co:

To apply the induction hypothesis to the right premise I have to show that \Gamma 0x:x : oe
is realizable in C0. I know that C0; \Gamma 0x:x : oe `n e : o/ 0 holds. If x does not appear
in the free variables of e it is sufficient to consider only \Gamma 0x which is by assumption
realizable. Otherwise I know that that the type of x must have been instantiated
to a monomorphic type which shows that \Gamma 0x:x : oe is realizable in C0. Then I can
apply the induction hypothesis to the right and find

C2; \Gamma x:x : oeo `s e : o/ 0 C0 `e C2:
I weaken the constraint and find

C0; \Gamma x:x : oeo `s e : o/ 0:
It holds that C0 `e Co ^ C2. I apply the (Let) rule and find

C0; \Gamma x `s let x = e in e0 : o/ 0:

APPENDIX C. PROOFS 121
Lemma 18 (Weakening) Given C; \Gamma  `s e : o/ and (C0; \Gamma 0) ^ (C; \Gamma ). Then
C0; \Gamma 0 `s e : o/ .
Proof: I use induction on the derivation `s . There is only one interesting case.

Case (Let) I find the following situation:

C1; \Gamma x `s e : o/ C1; \Gamma x; o/ `gen (C2; oe)

C3; \Gamma x:x : oe `s e0 : o/ 0
C2 ^ C3; \Gamma x `s let x = e in e0 : o/ 0

W.l.o.g. (C2; oe) = (9 _ff:C1; 8 _ff:C1 ) o/ ) where I assume that _ff are such that _ff 62
fv(\Gamma 0x). This can always be achieved through ff-renaming. It holds that (C0 ^
C1; \Gamma 0x) ^ (C1; \Gamma x). I apply the induction hypothesis to the left premise and find

C0 ^ C1; \Gamma 0x `s e : o/:
I set C00 = C0 ^ C1, (C02; oe0) = gen(C00; \Gamma 0x; o/ ) where C02 = 9 _fi:C00, oe0 = 8 _fi:C00 ) o/
and _ff 62 fv(oe0). It is an easy observation that

C0 `i oe0 _ oe:
I can apply the induction hypothesis to the right premise and obtain

C0; \Gamma 0x:x : oe0 `s e0 : o/ 0:
Because of the assumptions it holds that _ff 62 fv(\Gamma 0x) which implies that _ff ` _fi. Then
I can deduce that C0 `e C2 ^ C3. Finally, I find that C0 ^ C02 =e C0. It remains to
apply the (Let) rule and I obtain

C0; \Gamma 0x `s let x = e in e0 : o/ 0:

C.4 Proofs of Section 3.6
Theorem 7 (Transformation) Given a constraint system X over a term algebra T
and a set S of solved forms such that S is closed under projection and X t enjoys
the principal constraint property, a type environment \Gamma 0 in X t and a constraint C
in X t where C ` \Gamma  7! \Gamma 0. Then the following holds.

APPENDIX C. PROOFS 122

ffl If C; \Gamma  `X c e : o/ then C; \Gamma 0 `X t e : o/ .
ffl If C; \Gamma  `X c e : oe where oe realizable in C then C; \Gamma 0 `X t e : oe0 where C `

oe 7! oe0.

Proof: The proof proceeds by induction on the number of occurrences of (Sub),
(8 Elim) and (8 Intro) and then on the expression size. I only show the interesting
cases.

Case (Let) I find the following situation:

C; \Gamma x `X c e : oe C; \Gamma x:x : oe `X c e0 : o/ 0

C; \Gamma x `X c let x = e in e0 : o/ 0

W.l.o.g. I can assume that oe is a polymorphic type. The same argument would hold
for monomorphic types. By induction I find

C; \Gamma 0x `X t e : oe0 C ` oe 7! oe0:
Then it holds that C ` \Gamma x:x : oe 7! \Gamma 0x:x : oe0. I can now apply the induction
hypothesis and I obtain

C; \Gamma 0x:x : oe0 `X t e0 : o/ 0:

Finally, I apply the (Let) rule and I find

C; \Gamma 0x `X t let x = e in e0 : o/ 0:

Case (8 Elim) I find the following situation:

C; \Gamma  `X c e : 8 _ff:D ) o/ C `e [_o/ = _ff]D

C; \Gamma  `X c e : [_o/ = _ff]o/

By induction I find

C; \Gamma 0 `X t e : oe0

where C ` (8 _ff:D ) o/ ) 7! oe0. I also know that

C `i 8 _ff:D ) o/ _ [_o/ = _ff]o/:
Because of the properties put on 7!, it holds that C `i oe0 _ [_o/ = _ff]o/ . But then I
obtain

C; \Gamma 0 `X t e : [_o/ = _ff]o/:

APPENDIX C. PROOFS 123
Case (8 Intro) I find the following situation:

C ^ D; \Gamma  `X c e : o/ _ff 62 fv(C) [ fv(\Gamma )

C ^ 9 _ff:D; \Gamma  `X c e : 8 _ff:D ) o/

I know 8 _ff:D ) o/ is realizable in C ^ 9 _ff:D. That means, there is a OE (OE = [_o/ = _ff]
for some _o/ ) which only acts on _ff such that

C ^ 9 _ff:D `e OED:
I can conclude that

C ^ 9 _ff:D `e C ^ OED:

By assumption C ^ 9 _ff:D is in X t. But that means (C ^ 9 _ff:D; OE) (please note
OE(C ^ 9 _ff:D) = C ^ 9 _ff:D) is a normal form of (C ^ D; id). X t fulfills the principal
constraint property. This implies the principal normal form of (C ^ D; id) exists,
Then (C0; 0) = normalize(C ^ D; id) such that id ^ 0 and C0 `e 0(C ^ D).
(C0; 0) is principal, therefore 0 ^OE0 OE and C ^ 9 _ff:D `e OE0C0. It follows that 0
acts only on _ff, hence 0(C ^ D) = C ^ 0D. I apply 0 (please note, _ff 62 fv(\Gamma )) to
the premise and find

C ^ 0D; \Gamma  `X c e : 0o/:

Weakening yields

C0; \Gamma  `X c e : 0o/:

Application of the induction hypothesis yields

C0; \Gamma 0 `X t e : 0o/
where w.l.o.g. _ff 62 fv(\Gamma 0). I apply the (8 Intro) rule and I find

9 _ff:C0; \Gamma 0 `X t e : 8 _ff:C0 ) 0o/:
Please note, the set S of solved forms is closed under projection. It also holds that
C ^ 9 _ff:D `e 9 _ff:C0. Weakening yields

C ^ 9 _ff:D; \Gamma 0 `X t e : 8 _ff:C0 ) 0o/:
It remains to show that C ^ 9 _ff:D ` (8 _ff:D ) o/ ) 7! (8 _ff:C0 ) 0o/ ). There are two
cases.

1. `i (8 _ff:D ) o/ ) _ (8 _ff:C0 ) 0o/ ) because C0 `e 0D.
2. Given 8 _fi:D0 ) o/ 0 in X t such that C ^ 9 _ff:D `i (8 _ff:D ) o/ ) _ (8 _fi:D0 ) o/ 0).

Then, there exist _ such that C ^ (9 _ff:D) ^ D0 `e _D and C ^ (9 _ff:D) ^ D0 `i

_o/ _ o/ 0. That means, (C ^ (9 _ff:D) ^ D0; _) is a normal form of (C ^ D; id).

Principality yields, there exist _OE such that 0 ^ _OE _ and C^(9 _ff:D)^D0 `e _OEC0.
Then, I can conclude C ^ 9 _ff:D `i (8 _ff:C0 ) 0o/ ) _ (8 _fi:D0 ) o/ 0):

APPENDIX C. PROOFS 124

Please note, implicitly I assumed that all constraints appearing in a derviation
C `i oe _ oe0 are in solved form. A similar reasoning as in the Transformation
Theorem 7could be applied to enforce this invariant.

Theorem 8 (Full and Faithful) Given a constraint system X over a term algebra T . If X t satisfies the principal constraint property then every program typable
in X c is typable in X t and vice versa.
Proof: The proof proceeds by transforming typing judgments in X t to judgments
in X c and vice versa. I annotate derivations ` with the type system to distinguish
between derivations in X t and X c.

Given a judgment C; \Gamma  ` X

t

e : o/ . I observe that it is possible to replace

applications of the term-based elimination rule by the constraint-based elimination
rule. This is stated by Lemma 20 in Section 3.7. Furthermore, judgments can always
be put into canonical form. It is an easy observation that the above judgment can

be transformed into a judgment C ^ (ff = o/ ); \Gamma  ` X

c

e : ff in the constraint-based

fragment of HM(X).

Given a judgment C; \Gamma  ` X

c

e : o/ . I make one further simplifying assumption.

I consider only closed type environments where all type schemes are valid in the
term-based as well as the constraint-based HM(X) fragment, i.e. \Gamma  2 X t. This
omits transforming the type environment as well, and simplifies the presentation
of the essential proof parts. I also assume that the set S of solved forms is closed
under projection. As stated in Theorem 6 this does not affect the expressiveness
of the type system. I apply normalization to achieve a term-based representation.
This is possible because the underlying constraint system satisfies the principal
constraint property. I set (D; OE) = normalize(C; id). Application of the weakening

and substitution lemma to the above judgment yields D; \Gamma  ` X

c

e : OEo/ . I apply the

Transformation Theorem 7 which yields D; \Gamma  ` X

t

e : OEo/ and this concludes the

proof.

C.5 Proofs of Section 3.7
Lemma 20 Given an instance of the HM(X) system in term form. If the judgment
C; \Gamma  ` e : oe is derivable using the constraint-based (8 Elim) rule then C; \Gamma  ` e : oe
is derivable using the substitution-based formulation of the (8 Elim) rule instead.
The reverse direction holds too.
Proof: The proof proceeds by induction on the derivation. It is sufficient to
consider only applications of the elimination rules. Consider the last application of

APPENDIX C. PROOFS 125
the constraint-based (8 Elim) rule in the derivation tree:

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C `e 9 _ff:D

C ^ D; \Gamma  ` e : o/ 0

By induction, the premise can be transformed in such a way that all applications
of the constraint-based elimination rule are replaced by the term-based elimination
rule. Weakening applied to the premise yields C ^ D; \Gamma  ` e : 8 _ff:D ) o/ 0. Finally,
application of the term-based elimination rule yields C ^ D; \Gamma  ` e : o/ 0. and this
concludes the inductive proof.

For the other direction, consider the last application of the term-based elimination rule in the derivation tree:

C; \Gamma  ` e : 8 _ff:D ) o/ 0 C `e [_o/ = _ff]D

C; \Gamma  ` e : [_o/ = _ff]o/ 0

Application of the induction hypothesis to the premise allows to replace all term-
based elimination rule applications by constraint-based rule applications. It holds
that C `e [_o/ = _ff]D `e 9 _ff:D. This allows to apply the constraint-based elimination
rule which yields C ^ D; \Gamma  ` e : o/ 0. Remember, I consider equivalence of the two
formulations of the elimination rules only in the term-based fragment of HM(X).
Hence, it is possible to apply the substitution lemma. I get the judgment C ^
[_o/ = _ff]D; \Gamma  ` e : [_o/ = _ff]o/ 0 which is equivalent to C; \Gamma  ` e : [_o/ = _ff]o/ 0. This concludes
the proof.

Lemma 21 Given a constraint C, a type environment \Gamma , a term e and a type o/ .
Then C; \Gamma  ` e : o/ iff C ^ (ff = o/ ); \Gamma  ` e : ff where ff is a fresh type variable.
Proof: Given C; \Gamma  ` e : o/ . By weakening I get that C ^ (ff = o/ ); \Gamma  ` e : o/
where ff is a fresh type variable. It remains to apply the (Sub) rule which yields
C ^ (ff = o/ ); \Gamma  ` e : ff.

I consider now the other direction. Remember, that the type o/ is a member of
the type language in the HM(X) system in constraint form. A restricted substitution
lemma holds under the assumption that type o/ consists only of type variables or
function types. Hence, from C ^ (ff = o/ ); \Gamma  ` e : ff it follows that OE(C ^ (ff =
o/ )); OE\Gamma  ` e : OE(ff) where OE = [o/ =ff]. The last judgment is equivalent to C; \Gamma  ` e : o/ .

C.6 Proofs of Section 4.2
Lemma 26 Given two constraint problems (D; OE) and (D0; OE0), a principal normal
form (C; ) of (D0; OE0) and a principal normal form (C0; 0) of (D; OE) such that

APPENDIX C. PROOFS 126
(C; ) is also a normal form of (D; OE) and (C0; 0) is also a normal form of (D0; OE0).
Then (C; ) is a principal normal form of (D; OE) and (C0; 0) is principal normal
form of (D0; OE0).
Proof: I abbreviate normal form by nf and principal normal form by pnf. By
assumption, (C; ) is a pnf and (C0; 0) is a nf of (D; OE). Then (C; ) ^ (C0; 0) and
also (C0; 0) ^ (C; ). This implies (C; ) pnf of (D; OE) and (C0; 0) pnf of (D0; OE0).

Lemma 27 Given a constraint system X over a term algebra T and a set of solved
constraints S in X such that X enjoys the principal constraint property and unitary
unification. Given constraint problems (D1; OE1) and (D2; OE2) such that dom(OE1) "
codom(OE2) = ;, dom(OE2) " codom(OE1) = ;, fv(D1) " dom(OE2) = ; and fv(D2) "
dom(OE1) = ;. Let (C; ) be the principal normal form of (D1; OE1) t (D2; OE2). Then
the principal normal form (C1; 1) of (D1; OE1) exists and (C; ) is a principal normal
form of (C1; 1) t (D2; OE2).
Proof: By assumption OE1 t OE2 ^OE0  and C `e OE0((OE1 t OE2)(D1 ^ D2)). Then
OE1 ^OE01  where OE01 is defined on the following domains:

1. U1 = codom(OE1jdom(OE2)):

For each fi 2 U1 there exists a unique ff 2 dom(OE2) such that fi 2 fv(OE1(ff)).
This can be achieved by imposing an ordering relation on the variables. Then
for each fi 2 U1 define OE01(fi) = OE0 ffi OEff(fi) where OEff = (OE1 t OE2)(ff).

2. U2 = codom(OE1ndom(OE2))nU1:

Define OE01jU2 = OE0.

3. U3 = dom(OE2)ndom(OE1):

Define OE01jU3 = OE0 ffi OE2.

4. otherwise :

Define OE01 = .

Then OE01 is well-defined by construction and OE1 ^OE01 . From the assumption it
follows that C `e OE0 ffi (OE1 t OE2)D1. The conditions put on the domain, codomain
and free variables of OE1; OE2; D1 yield that (OE0 ffi (OE1 t OE2))jfv(D1) = (OE01 ffi OE1)jfv(D1).
Then I find that C `e OE01D1 (remember, OE1D1 = D1), hence (C; ) is a normal form
of (D1; OE1). The principal constraint property holds, therefore I can assume that
the principal normal form (C1; 1) of (D1; OE1) exists.

It remains to show that (D0; OE0) = (C1; 1) t (D2; OE2), OE0 ^ _OE  and C `e _OED0
for some _OE.

1. OE0 = 1 t OE2 exists:

(C1; 1) principal, hence 1 ^OE02  and C `e OE02C1 for some OE02. A similar

APPENDIX C. PROOFS 127

construction as before gives (C; ) normal form of (D2; OE2), then OE2 ^OE03 
and C `e OE03D2. 1 and OE2 have a common upper bound, hence the least
upper bound 1 t OE2 exists. 1 t OE2 ^ _OE  for some substitution _OE. Moreover,
there are ae1; ae2 such that ae1 ffi OE02 = _OE and ae2 ffi OE03 = _OE.

2. C `e ( _OE ffi OE0)C1:

( _OE ffi (1 t OE2))jfv(C1) = (ae1 ffi OE02 ffi (1 t OE2))jfv(C1)

= (ae1 ffi OE02 ffi 1)jfv(C1) (fv(C1) " dom(OE2) = ;)

I know C `e OE02C1, ae1C = C. Then C `e (ae1 ffi OE02)C1 = ( _OE ffi (1 t OE2))C1 =
( _OE ffi OE0)C1.

3. C `e ( _OE ffi OE0)D2:

( _OE ffi (1 t OE2))jfv(D2) = (ae2 ffi OE03 ffi (1 t OE2))jfv(D2)

= (ae2 ffi OE03 ffi OE2)jfv(D2) (fv(D2) " dom(1) = ;)

I know C `e OE03D2, ae2C = C. Then C `e (ae2 ffi OE03)D2 = (ae2 ffi OE03 ffi OE2)D2 =
( _OE ffi OE0)D2.

The last two proof steps showed that C `e ( _OE ffi OE0)(C1 ^ D2), therefore (C; ) is a
normal form of (D0; OE0).

Lemma 28 Given a constraint system X over a term algebra T and a set of solved
constraints S in X such that X satisfies the principal constraint property and unitary
unification. Given constraint problems (D1; OE1) and (D2; OE2) such that dom(OE1) "
codom(OE2) = ;, dom(OE2) " codom(OE1) = ;, fv(D1) " dom(OE2) = ; and fv(D2) "
dom(OE1) = ;. Let (C1; 1) be the principal normal form of (D1; OE1) and (C; ) be
the principal normal form of (C1; 1) t (D2; OE2). Then (C; ) is a normal form of
(D1; OE1) t (D2; OE2).
Proof: I set (D0; OE0) = (C1; 1) t (D2; OE2). By assumption 1 t OE2 = OE0 ^OE01 
and C `e OE01D0 for some substitution OE01 and OE1 ^OE02 1 and C1 `e OE02D1 for some
substitution OE02. I have to show that OE1 t OE2 ^ _OE  and C `e ( _OE ffi (OE1 t OE2))(D1 ^ D2)
for some substitution _OE.

1. OE1 t OE2 exists:

1 t OE2 exists, therefore (OE02 ffi OE1) ^ae1 _OE1 and OE2 ^ae1 _OE1. It follows that OE1; OE2
have a unifier because OE1 ^ae1ffiOE02 _OE1 and OE2 ^ae1 _OE1. Then OE1 t OE2 exists.
Specifically, it follows that OE1 t OE2 ^ae 1 t OE2 for some substitution ae.

2. OE1 t OE ^OE01ffiae  because OE1 t OE2 ^ae 1 t OE2 ^OE01 . Especially, it holds that

OE01 ffi ae ffi (OE1 t OE2) = OE01 ffi (1 t OE2).

APPENDIX C. PROOFS 128

3. C `e OE01 ffi ae ffi (OE1 t OE2)D2 because of C `e OE01 ffi (1 t OE2)D2 and the above

equation.

4. C `e OE01 ffi ae ffi (OE1 t OE2)D1. From the assumptions it follows that C `e OE01 ffi

(1 t OE2) ffi OE02D1. The substitution OE02 operates on codom(OE1) and dom(1)
and fv(D1) " dom(OE2) = ;. Then (OE02 ffi (1 t OE2))jfv(D1) = OE02jfv(D1). Therefore,
ae can be chosen (take ae0 = OE02 ffi ae) such that (OE01 ffi ae ffi (OE1 t OE2))jfv(D1) =
(OE01 ffi (1 t OE2) ffi OE02)jfv(D1). Then it follows that C `e OE01 ffi ae ffi (OE1 t OE2)D1.

I find that (C; ) is a normal form of (D1; OE1) t (D2; OE2).

Lemma 29 Given a constraint system X over a term algebra T and a set S of
solved forms such that X satisfies the lifting property. Given a constraint problem
(9 _ff:D; OE). Then (9 _ff:D; OE) does have a normal form iff (D; OE) does have a normal
form.
Proof: W.l.o.g. _ff 62 dom(OE) [ codom(OE).
"(" : Assume (C; ) is a normal form of (D; OE). I set C0 = 9 _ff:(ss ffi n_ff)D and
0 = ss ffi n_ff where ss = [ _fi= _ff] and _fi new. By assumption, there exist OE0 such that
OE ^OE0  and because of the assumption put on OE it follows that OE ^OE0 n_ff. Please
note, 0(9 _ff:D) = C0. It remains to show that (9 _ff:(ss ffi n_ff)D) 2 S. By assumption,
S is equation-free. Assume 9 _ff:(ss ffi n_ff)D `e (o/ = o/ 0). Then (ss ffi )D `e (o/ = o/ 0)
because [o/ =ff]D = 9ff:((ff = o/ ) ^ D) `e 9ff:D. By assumption D 2 S but then
also (ss ffi )D 2 S. It follows that `e (o/ = o/ 0), thus 9 _ff:(ss ffi n_ff)D 2 S. That
means, (C0; 0) is a normal form of (9 _ff:D; OE).
")" : Assume (C; ) normal form of (9 _ff:D; OE). Then 9 _ff:D 2 S. The lifting
property states there exist _o/ such that ([_o/ = _ff] ffi )D 2 S. This shows (D; OE) does
have a normal form as well.

Lemma 30 Given a constraint system X over a term algebra T and a set S of
solved forms such that X satisfies the lifting property. Given a constraint problem (9 _ff:D; OE). Let (C; ) be the principal normal form of (D; OE). Then (9 _ff:(ss ffi
n_ff)D; (ss ffi n_ff)) is the principal normal form of (9 _ff:D; OE) where ss = [ _fi= _ff] and _fi
are new.
Proof: Please note, w.l.o.g. _ff 62 dom(OE) [ codom(OE). I set C0 = 9 _ff:(ss ffi n_ff)D and
0 = ss ffi n_ff.

1. (C0; 0) is a normal form of (9 _ff:D; OE):

By assumption, there exist OE0 such that OE ^OE0  and because of the assumption
put on OE it follows that OE ^OE0 n_ff. Please note, 0(9 _ff:D) = C0. It remains to
show that (9 _ff:(ss ffi n_ff)D) 2 S. By assumption, S is equation-free. Assume
9 _ff:(ss ffi n_ff)D `e (o/ = o/ 0). Then (ss ffi )D `e (o/ = o/ 0) because [o/ =ff]D =

APPENDIX C. PROOFS 129

9ff:((ff = o/ ) ^ D) `e 9ff:D. By assumption D 2 S but then also (ss ffi )D 2
S. It follows that `e (o/ = o/ 0), thus 9 _ff:(ss ffi n_ff)D 2 S.

2. (C0; 0) is principal: Assume (C00; 00) is a normal form of (9 _ff:D; OE) where C00 =

00(9 _ff:D) = 9 _ff:00D (w.l.o.g. _ff 62 dom(00) [ codom(00)). Then 9 _ff:00D 2 S.
The lifting property states there exist _o/ such that ([_o/ = _ff] ffi 00)D 2 S. I
set 000 = [_o/ = _ff] ffi 00 and C000 = 000D. Then (C000; 000) is a normal form of
(D; OE). (C; ) is principal, hence there exists OE0 such that  ^OE0 000. Then
ss ffi n_ff ^OE0ffiss\Gamma 1 00 where _ff 62 dom(OE0 ffi ss\Gamma 1) [ codom(OE0 ffi ss\Gamma 1). It remains to
show that C00 `e (ss0 ffi ss\Gamma 1)C0.

(OE0 ffi ss\Gamma 1)C0 = (OE0 ffi ss\Gamma 1)9 _ff:(ss ffi n_ff)D

= 9 _ff:(OE0 ffi ss\Gamma 1) ffi (ss ffi n_ff)D

because _ff 62 dom(ss00 ffi ss\Gamma 1) [ codom(ss0 ffi ss\Gamma 1)
= 9 _ff:00D
= C00

C.7 Proofs of Section 4.3
Theorem 12 (Soundness of Inference) Given a type environment \Gamma  and a term
e. If ; C; \Gamma  `W e : o/ then C; \Gamma  ` e : o/ , C = C and o/ = o/ .
Proof: I apply induction on the derivation `W . I only consider two cases. The
other cases can be proven in a similar style.

Case (App) I find the following situation:

1; C1; \Gamma  `W e1 : o/1 2; C2; \Gamma  `W e2 : o/2
(D; 0) = (C1; 1) t (C2; 2) t ((o/1 _ o/2 ! ff); id) ff new

(C; ) = normalize(D; 0)
jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)

I apply the induction hypothesis to the left and right premise and I obtain

C1; 1\Gamma  ` e1 : o/1 1C1 = C1 1o/1 = o/1:
and

C2; 2\Gamma  ` e2 : o/2 2C2 = C2 2o/2 = o/2:

W.l.o.g. I can assume that all identifier in \Gamma  are contained in e1 and e2 and not
more. This fact and normalization ensures that  is consistent in \Gamma . Furthermore, I

APPENDIX C. PROOFS 130
know that C `e C1 and C `e C2. This ensures that C1 and C2 are in solved
form. Then I apply the Weakening/Substitution Lemma 14 and obtain

C; \Gamma  ` e1 : o/1 C; \Gamma  ` e2 : o/2:
I know that C `e (o/1 _ o/2 ! (ff)) and apply the (Sub) rule to get C; \Gamma  ` e :
o/2 ! (ff). It remains to apply the (App) rule and I find

C; \Gamma  ` e1e2 : (ff):

Case (Let)

1; C1; \Gamma x `W e : o/ C1; 1\Gamma x; o/ `gen (C2; oe)

2; C3; \Gamma x:x : oe `W e0 : o/ 0
(D; 0) = (C2; 1) t (C3; 2)

(C; ) = normalize(D; 0)
jfv(\Gamma x); C; \Gamma x `W let x = e in e0 : o/ 0

I apply the induction hypothesis to both premises and I find

C1; 1\Gamma x ` e : o/
and

C3; 2\Gamma x:x : 2 : oe ` e0 : o/ 0:

I apply the (8 Intro) rule to the first judgment and find

9 _fi:C1; 1\Gamma x ` e : oe
where oe = 8 _fi:C1: ) o/ . Please note, the set S of solved forms needs not necessarily
to be closed under projection but the conditions put on gen ensure that 9 _fi:C1 is in
solved form. Now, I transform both judgments in a similar way as in the previous
case and get

C; \Gamma x ` e : oe

and

C; \Gamma x:x : oe ` e : o/ 0:

I apply the (Let) rule and obtain

C; \Gamma x ` e : o/ 0:

I now prove completeness for HM(X) type systems in term form where X in
X reg or in X c and X satisfies the principal constraint property. In case X belongs

APPENDIX C. PROOFS 131
to X reg, I additionally require that X enjoys unitary unification. Some technical
lemmas (which I will point out) rely on the fact that X is regular. The proof for X c
is similar, but there I only need weaker versions of these technical lemmas which do
not rely on the regularity of the constraint system. First, I prove completeness for
X in X reg. Then I present a completeness proof for X in X c.

The generalization relation `gen relates a constraint C, a type environment \Gamma 
and a type o/ and to the generalized constraint and type, written C; \Gamma ; o/ `gen (C0; oe).
I use two specialized generalization versions which only relate either the specialized
constraint or the specialized type. C; \Gamma ; o/ `gen (C0; oe) iff C; \Gamma ; o/ `gen1 C0 and
C; \Gamma ; o/ `gen2 oe.

The following two lemmas rely on the fact that I only consider regular theories. I
give the proof for one lemma where one can see that X needs to be a regular theory.
The first lemma states that I can lift entailment between two constraints to the
generalized constraints. It is also essential that the set S of solved forms is closed
under projection.

Lemma 33 Given a type context \Gamma , constraints C; ~C, types o/; o/ 0 and substitutions
OE; OE0;  such that C `e OE0 ~C and  ^OE

0

fv(\Gamma ) OE. Then Co `

e OE0 ~Co where C; OE\Gamma ; o/ 0 `gen2

Co and ~C; \Gamma ; o/ `gen2 ~Co.
Proof: W.l.o.g. I assume Co = 9 _ff:C and ~Co = 9 _fi: ~C. I show that _ff 62 fv(OE0 ~Co).
Assume the contrary. W.l.o.g.

_ff 62 fv(\Gamma ) [ fv( ~Co) [ codom(OE) (C.1)
because I can always rename bound variables and during type inference always new
type variables have been introduced. That means there is a fl 2 fv( ~Co) such that

_ff 2 fv(OE0(fl)). Further it holds that fl 62 fv(\Gamma ). Assume fl 2 fv(\Gamma ) then there is a
ffi 2 fv(\Gamma ) such that ffi 2 fv((fl)). I know that OE(ffi) = OE0 ffi (ffi) (here I need the fact
that X is regular, both sides of the equation contain the same set of free variables)
and then I find _ff 2 codom(OE) which is a contradiction to C.1. I get fl 62 fv(\Gamma ) and
fl 2 fv( ~Co). But this is again a contradiction because ~Co is a generalized constraint.
Our starting assumption was false and I find that _ff 62 fv(OE0 ~Co).

Now, I can conclude that ~C `e ~Co. Then it follows that OE0 ~C `e OE0 ~Co. This
yields C `e OE0 ~Co. Finally, I obtain Co `e 9 _ff:OE0 ~Co and because _ff 62 fv(OE0 ~Co) that I
means I get Co `e OE0 ~Co as desired.

Remark 6 The proof of the previous lemma relies on the fact that X is regular. For
X in X c I only need a restricted version of this lemma. Therefore, I still can achieve
complete type inference for X in X c.

The next lemma is similar to the previous one, except that it compares types
instead of constraints.

APPENDIX C. PROOFS 132
Lemma 34 Given a type context \Gamma , constraints C; ~C, types o/; o/ 0 and substitutions
OE; OE0;  such that C `e OE0 ~C, C `i OE0o/ _ o/ 0 and  ^OE

0

fv(\Gamma ) OE. Then `

i OE0~oeo _ oeo

where C; OE\Gamma ; o/ 0 `gen1 oeo and ~C; \Gamma ; o/ `gen1 ~oeo.

The next lemma states that I can lift some properties about a constraint and a
substitution to the same constraint but extended substitution.

Lemma 35 Given a set U of variables, constraints C1; C0 and substitutions ; 1; 2; OE; OE1
such that 1C1 = C1, C0 `e OE01C1,  = 1 t 2,  ^OE

0

U OE, 1 ^

OE01
U OE, codom(2) "

fv(C1) ` U and codom(1) " fv(C2) ` U . Then C0 `e (OE0 ffi )C1.

Proof: From the assumption I can follow that there is a ae1 such that  = ae1 ffi 1.
Then I find that

OE = (OE0 ffi )jU

= (OE0 ffi ae1 ffi 1)jU
= (OE01 ffi 1)jU :

I can deduce that

(OE0 ffi ae1)jcodom(1)[(Undom(1)) = OE01jcodom(1)[(Undom(1)):
W.l.o.g. I can assume that

dom(OE01) ae codom(1) [ (U ndom(1)) and
dom(OE0 ffi ae1) ae codom(1) [ codom() [ U:

It is an easy observation that

codom() ` codom(1) [ codom(2):
Then I find that

dom(OE0 ffi ae1) ae codom(1) [ codom(2) [ U:
This leads to

dom(OE0 ffi ae1) " fv(C1) ae codom(1) [ (U nfv(1)):
Then I can deduce that

(OE0 ffi )C1 = (OE0 ffi ae1)C1 = OE01C1:
From C0 `e OE01C1 I get as desired that

C0 `e (OE0 ffi )C1:

The next Lemma is similar to the previous one but it is stated for the `i relation.

APPENDIX C. PROOFS 133
Lemma 36 Given a set U of variables, a constraint C0, type schemes ~oe; oe00 and
substitutions ; 1; 2; OE; OE1 such that 1 ~oe = ~oe, C0 `i OE01 ~oe _ oe00,  = 1 t 2,

 ^OE

0

U OE, 1 ^

OE01
U OE, codom(2) " fv(C1) ` U and codom(1) " fv(C2) ` U . Then

C0 `i (OE0 ffi )~oe _ oe00.

Lemma 37 (Completeness of `W ) Given C0; OE\Gamma  `s e : o/ 0. Then

; C; \Gamma  `W e : o/
for some substitutions , OE0, constraint C and type o/ such that,

 ^OE

0

fv(\Gamma ) OE C

0 `e OE0C C0 `i OE0o/ _ o/ 0:

Proof: In this case I can not use induction on the derivation `s . I run into problems
in case of the (Let) rule. In order to apply the induction hypothesis I have to rewrite
the right premise of the (Let) rule. But this would break the inductive proof on the
derivation `s . The trick is that first I perform induction on the size of expressions
and then on the number of (Sub) rules. In Figure C.1 I introduce a measure on the
size of expressions which is parameterized on a map w from identifiers to positive
integers. This method appears also in a technical report by Kennedy [Ken96]. He
mentions that the original idea is due to Tobias Nipkow.

The proof proceeds first by induction on ffi(w; e) and then on the number of
occurrences of rule (Sub) in the original derivation.

Case (Var) I find the following situation:

C0; OE\Gamma  `s e : o/ 0
where oe = 8 _ff:D ) o/ 2 \Gamma  and C0 `i OEoe _ o/ 0. I set ss = [ _fi= _ff] as a variable
renaming substitution where _fi are fresh type variables. I get that

C0 `e (ffi ffi OE ffi ss)D C0 `i (ffi ffi OE ffi ss)o/ _ o/ 0
where ffi is a solution to the bound type variables. Then, (C0; ffi ffi OE ffi ss) is a normal
form of (D; ss). Because HM(X) satisfies the principal constraint property I get that
(C; ) is a principal normal form of (D; ss). It holds that

 ^OE0 ffi ffi OE ffi ss C0 `e OE0C:
Furthermore, I can conclude that

C0 `i (OE0 ffi )o/ _ o/ 0 (ffi ffi OE ffi ss)jfv(\Gamma ) = OE:

APPENDIX C. PROOFS 134
I get that  ^OE

0

fv(\Gamma ) OE and I am done.

Case (Sub) I find the following situation:

C0; OE\Gamma  `s e : o/ 0 C0 `e (o/ 0 _ o/ 00)

C0; OE\Gamma  `s e : o/ 00

By induction I find that

 ^OE

0

fv(\Gamma ) OE C

0 `e OE0C C0 `i OE0o/ _ o/ 0

for some substitution OE0 and . It follows immediately that C0 `i OE0o/ _ o/ 00 and I
am done.

Case (Abs) I find the following situation:

C0; OE\Gamma x:x : o/ 0 `s e : o/ 00
C0; OE\Gamma x `s *x:e : o/ 0 ! o/ 00

I extend the substitution OE and define ~OE = OE ffi [o/ 0=ff] where ff is new. Obviously, it
holds that

`i ~OE(\Gamma :x : ff) ^ \Gamma 0:x : o/ 0:

Application of the induction hypothesis yields

; C; \Gamma x:x : ff `W e : o/  ^OE

0

fv(\Gamma )[fffg ~OE
C0 `e OE0C C0 `i OE0o/ _ o/ 0:

(C.2)

Obviously, it holds that

nfffg ^OE

0

fv(\Gamma ) OE C

0 `i OE0(ff ! o/ ) _ o/ 0 ! o/ 00:

Then, I apply the (Abs) rule and get

nfffg; C; \Gamma x `W *x:e : (ff) ! o/:

Case (App) I find the following situation:

C0; OE\Gamma  `s e1 : o/ 01 ! o/ 02 C0; OE\Gamma  `s e2 : o/ 01

C0; OE\Gamma  `s e1e2 : o/ 02

Application of the induction hypothesis yields

1; C1; \Gamma  `W e1 : o/1 1 ^OE

01

fv(\Gamma ) OE
C0 `e OE01C1 C0 `i OE01o/1 _ o/ 01 ! o/ 02:

(C.3)

APPENDIX C. PROOFS 135
and

2; C2; \Gamma  `W e2 : o/2 2 ^OE

02

fv(\Gamma ) OE
C0 `e OE02C2 C0 `i OE02o/2 _ o/ 01

By assumption, unification is unitary. Then, I can set 0 = 1 t 2 and find that
0 ^OE

0

fv(\Gamma ) OE. I want to apply Lemmas 35, 36. I identify the set U in these lemmas
with fv(\Gamma ). I assume that type variables introduced in one part of the inference tree

do not appear in the other part. Formally, this means that

codom(2) " fv(C1) ` fv(\Gamma )
and

codom(1) " fv(C2) ` fv(\Gamma ):

All preconditions of Lemmas 35, 36 are fulfilled. I can conclude that

C0 `e (OE0 ffi 0)C1 C0 `i (OE0 ffi 0)o/1 _ o/ 01 ! o/ 02

C0 `e (OE0 ffi 0)C2 C0 `i (OE0 ffi 0)o/2 _ o/ 01:

I set D = C1 ^ C2 ^ (o/1 _ o/2 ! ff) where ff is a fresh type variable. Then I obtain
that C0 `e (OE0 ffi 0 ffi [o/ 02=ff])D. I find that (C0; OE0 ffi 0 ffi [o/ 02=ff]) is a normal form of
(D; 0). By assumption HM(X) satisfies the principal constraint property. I obtain
that (C; ) is the principal normal form of (D; 0) where  ^OE00 OE0 ffi 0 ffi [o/ 02=ff].
Because (C; ) is principal I find that C0 `e OE00C. W.l.o.g. (OE0 ffi 0)o/ 02 = o/ 02. Then, I

can conclude that (OE0 ffi 0 ffi [o/ 02=ff])jfv(\Gamma ) = OE. This leads to  ^OE

00

fv(\Gamma ) OE. Furthermore,
it holds that OE00(ff) = o/ 02 because

o/ 02 = OE0 ffi 0 ffi [o/ 02=ff](ff) = OE00 ffi (ff) = OE00(ff):
The last reasoning steps holds because ff is a new type variable therefore ff 62 dom().
Finally, I apply the (App) rule and find

jfv(\Gamma ); C; \Gamma  `W e1e2 : (ff)
which establishes the induction step.
Case (Let) I find the following situation:

C1; OE\Gamma x `s e : o/ C1; OE\Gamma x; o/ `gen oe; C2

C3; OE\Gamma x:x : oe `s e0 : o/ 0
C2 ^ C3; OE\Gamma x `s let x = e in e0 : o/ 0

Induction hypothesis applied to the left part yields

1; ~C1; \Gamma x `W e : o/1 1 ^OE

01

fv(\Gamma x) OE
C1 `e OE01 ~C1 C1 `i OE01o/1 _ o/:

(C.4)

APPENDIX C. PROOFS 136
From Lemma 34 and Lemma 33 and C.4 I obtain that

C2 `e OE01 ~C2 `i OE01oe1 _ oe (C.5)
where (oe1; ~C2) = gen( ~C1; \Gamma x; o/1). I set ~OE = OE01 ffi OE. Then it holds that

`i ~OE(\Gamma x:x : oe1) _ OE\Gamma x:x : oe (C.6)
because

~OEoe1 = (OE01 ffi OE)oe1 = (OE01 ffi (OE01 ffi 1)jfv(\Gamma ))oe1 = OE01oe1:

An easy observation yields

~OEjfv(\Gamma x) = OE: (C.7)

I rewrite the right premise with the stronger type environment in C.6 and find

C3; ~OE(\Gamma x:x : oe1) `s e0 : o/ 0:
Now, I am able to apply the induction hypothesis to the right part and find

2; ~C3; \Gamma x:x : oe1 `W e0 : o/ 01

2 ^OE

02

fv(\Gamma x)[fv(oe1) ~OE
C3 `e OE02 ~C3 C3 `i OE02o/ 01 _ o/ 0:

(C.8)

From C.4 I can deduce that

1 ^OE

01

fv(\Gamma x)[fv(oe1) ~OE: (C.9)

Because of C.4 and C.7 it holds that

(OE01 ffi 1)jfv(\Gamma x) = OE = ~OEjfv(\Gamma x)
and if ff 2 fv(oe1) I can assume that ff 62 fv(\Gamma x) then I know that

OE(ff) = ff 1(ff) = ff:
I can deduce that

OE01 ffi 1(ff) = OE01(ff) = ~OE(ff):

Then from C.8 and C.9 I find that 1 and 2 have an upper bound. By assumption,
unification is unitary, hence least upper bound exists. It holds that

0 ^OE

0

fv(\Gamma x)[fv(oe) OE (C.10)

where 0 = 1 t 2. With C.7 and from C.10 I find that

0 ^OE

0

fv(\Gamma x) OE:

APPENDIX C. PROOFS 137
From C.5 and C.4 I know that

C2 `e OE01 ~C2 C3 `e OE02 ~C3 C3 `i OE02o/ 01 _ o/ 0:
As in the (App) case I can conclude from Lemmas 35, 36 that

C2 `e (OE0 ffi 0) ~C2 C3 `e (OE0 ffi 0) ~C3
and

C3 `i (OE0 ffi 0)o/ 01 _ o/ 0:

I set D = ~C2 ^ ~C3. Then I obtain that (C2 ^ C3; OE0 ffi 0) is a normal form of (D; 0).
By assumption HM(X) satisfies the principal constraint property. Assume (C; ) is
the principal normal form of (D; 0) where  ^OE00 OE0 ffi 0. Now, I can apply the (Let)
rule and find

jfv(\Gamma ); C; \Gamma x `W let x = e in e0 : o/ 01:

Furthermore, I obtain that

C2 ^ C3 `e OE00C C2 ^ C3 `i (OE00 ffi )o/ 01 _ o/ 0

where  ^OE

00

fv(\Gamma x) OE.

The following theorem states completeness of inference for the class X reg.
Theorem 24 Given C0; OE\Gamma  ` e : oe0 and OE\Gamma  is realizable in C0. Then

; C; \Gamma  `W e : o/
for some substitutions OE0, , constraints C; Co and types o/; oeo such that,

 ^OE

0

fv(\Gamma ) OE C

0 `e OE0Co C0 `i OE0oeo _ oe0 andC; \Gamma ; o/ `gen (oeo; Co):

Proof: First, I apply Lemma 15 in order to get a derivation in `n . Then, I can
apply Lemma 17 (completeness of `s ). This yields

(a) oe0 = o/ : C; OE\Gamma  `s e : o/ C0 `e C
(b) otherwise : C; OE\Gamma  `s e : o/ C; OE\Gamma ; o/ `gen (oeo; Co)

C0 `e Co C0 `i oeo _ oe0

(C.11)

After that I apply Lemma 37 (completeness of `W ) and find

; ~C; \Gamma  `W e : ~o/  ^OE

0

fv(\Gamma ) OE
C `e OE0 ~C C `i OE0~o/ _ o/

I find C; \Gamma ; o/ `gen (~oeo; ~Co) for some ~oeo; ~Co. It remains to show

APPENDIX C. PROOFS 138

1. C0 `i OE0 ~oeo _ oe0
2. C0 `e OE0 ~Co.
This fact follows by application of the Lifting Lemmas 35, 36.

I now give a completeness proof for X c. I assume that I have an HM(X) type system where X in X c and X satisfies the principal constraint property. I have already
made the observation that in this case type inference only represents a satisfiability
test and `W returns always the identity substitution. The proof follows the same
steps as in case of X reg. I show that all introduced derivations are equivalent. Most
of the work is already done, I only have to restate Lemma 37.

I have already mentioned that the Lifting Lemmas 33 and 34 do not hold in
general for non-regular theories. But I can state specialized versions of the Lifting
Lemmas which do apply in this case. I use the convention that two substitutions
are syntactically equal if they denote the same mapping. This is in contrast to the
usual definition for equality between substitutions where equality breaks down to
equality with respect to the underlying equational theory.

Lemma 38 Given a type context \Gamma , constraints C; ~C, types o/; o/ 0 and substitutions
OE; OE0 such that C `e OE0 ~C and id ^OE

0

fv(\Gamma ) OE where OE

0 is syntactically equal to OE on

fv(\Gamma ). Then Co `e OE0 ~Co where C; OE\Gamma ; o/ 0 `gen2 Co and ~C; \Gamma ; o/ `gen2 ~Co.

Lemma 39 Given a type context \Gamma , constraints C; ~C, types o/; o/ 0 and substitutions
OE; OE0 such that C `e OE0 ~C, C `i OE0o/ _ o/ 0 and id ^OE

0

fv(\Gamma ) OE where OE

0 is syntactically

equal to OE on fv(\Gamma ). Then `i OE0~oeo _ oeo where C; OE\Gamma ; o/ 0 `gen1 oeo and ~C; \Gamma ; o/ `gen1

~oeo.

Remark 7 Both original lemmas can only be proven for non-regular theories. But it
is interesting to point that both lemmas hold for arbitrary theories if the substitution
 is equal to the identity substitution. In the previous proof I showed that fl 62 fv(\Gamma ).
Assume now that  = id and fl 2 fv(\Gamma ). But then I get OE0(fl) = OE(fl) which yields that

_ff 2 codom(OE) (I can make this step because I know that OE0 and OE are syntactically
equal on fv(\Gamma )). This is a contradiction to our assumption. Hence, I find fl 62 fv(\Gamma ).
The rest of the proof remains the same.

Lemma 40 (Completeness of `W ) Given C0; OE\Gamma  `s e : o/ 0. Then

id; C; \Gamma  `W e : o/
for some constraint C, type o/ and substitution OE0 such that,

id ^OE

0

fv(\Gamma ) OE C

0 `e C C0 `i o/ _ o/ 0:

APPENDIX C. PROOFS 139
Proof: It is an easy observation that I can always choose OE0 such that OE0 and OE
are syntactically equal on fv(\Gamma ). I need this condition to apply the Lifting Lemmas.
As before the proof proceeds first by induction on ffi(w; e) and then on the number
of occurrences of rule (Sub) in the original derivation. There is only one interesting
case.

Case (Let) I find the following situation:

C1; OE\Gamma x `s e : o/ C1; OE\Gamma x; o/ `gen (oe; C2)

C2; OE\Gamma x:x : oe `s e0 : o/ 0
C2 ^ C3; \Gamma x `s let x = e in e0 : o/ 0

I apply the induction hypothesis to the right premise and obtain

id; ~C1; \Gamma x `W e : o/1
id ^OE

01

fv(\Gamma ) OE C1 `

e OE01 ~C1 C1 `i OE01o/1 _ o/

I find ~C1; \Gamma x; o/1 `gen (oe0; ~C2) for some oe0; ~C2. I get that `i OE01oe0 _ oe and C2 `e OE01 ~C2
by application of the Lifting Lemmas 38 and 39. As before I set ~OE = OE ffi OE01 I can
rewrite the left premise and find

C2; ~OE(\Gamma x:x : oe0) `s e0 : o/ 0
I apply the induction hypothesis and obtain

id; ~C3; \Gamma x:x : oe0 `W e0 : o/2
id ^OE

02

fv(\Gamma ) OE C3 `

e OE02 ~C3 C3 `i OE02o/2 _ o/ 00

I can observe that OE01 and OE02 are identical on fv(\Gamma ) otherwise they act on different
variables. Therefore, I can combine them and set OE0 = OE01 t OE02. Furthermore,
normalization succeeds because C2 ^ C3 is satisfiable. I apply the (Let) rule and find

id; ~C2 ^ ~C3; \Gamma x `W let x = e in e0 : o/2
id ^OE

0

fv(\Gamma ) OE C2 ^ C3 `

e OE0( ~C2 ^ ~C3) C2 ^ C3 `i OE0o/2 _ o/ 00

This establishes the induction step.

The following theorem can be proven similar in style as in case for X reg. It states
completeness of inference for the class X c.

Theorem 25 Given C0; OE\Gamma  ` e : oe0 and OE\Gamma  is realizable in C0. Then

id; C; \Gamma  `W e : o/
for some constraints C; Co, types o/; oeo and substitution OE0 such that,

id ^OE

0

fv(\Gamma ) OE C

0 `e OE0Co C0 `i OE0oeo _ oe0 and

C; \Gamma ; o/ `gen (oeo; Co):
Theorem 13 (Completeness of Inference) follows from Theorem 24 and 25.

APPENDIX C. PROOFS 140
C.8 Proofs of Section 4.4
I prove soundness and completeness of the revised term-based inference system,
given in Figure 4.4. The proofs relies on sound and complete inference for the
constraint-based system. I omit soundness and completeness proofs for the constraint-
based system which are straightforward and analogous to the completeness result
for the class X c in case of the term-based inference system. The technical problem lies in transforming judgments in constraint form into judgments in term form.
Remember, the inference system in term form in Section 4.4.2 performs inference
first in the purely constraint-based fragment of HM(X). Term reconstruction is performed at the end. The output is a judgment in the term-based fragment of HM(X).
Technically, I need to show how to transform judgments (derivation trees) of the
constraint-based fragment of HM(X) into judgments (derivation trees) of the term-
based fragment. This can be done by applying the Transformation Theorem 7 (see
Section 3.6).

Theorem 16 (Soundness of Inference) Given an instance of the HM(X) system
where X satisfies the principal constraint property and the set S is closed under
projection. Given a type environment \Gamma  and a term e. If ; C; \Gamma  `Wterm e : o/ then
C; \Gamma  ` e : o/ where C =e C and o/ = o/ .
Proof: I only consider the final step of the derivation `Wterm .

C; \Gamma  `Wc e : ff (D; ) = normalize(C; id)

jfv(\Gamma ); D; \Gamma  `Wterm e : (ff)

From the premise, I obtain

C; \Gamma  `X c e : ff
because constraint-based inference is sound. Furthermore, I know that D `e C
which yields that

D; \Gamma  `X c e : (ff)

Normalization ensures that \Gamma  is in X t. I apply the Transformation Theorem 7 and
obtain

D; \Gamma  `X t e : (ff)

and I am done.

Theorem 17 (Completeness of Inference) Given an instance of the HM(X)
system where X satisfies the principal constraint property. Given C; OE\Gamma  `X t e : oe

APPENDIX C. PROOFS 141
such that OE\Gamma  realizable in C. Then ; D; \Gamma  `W e : o/ for some substitution ,
constraints D; Co and types o/; oeo such that

 ^OE

0

fv(\Gamma ) OE C `

i OE0oeo _ oe C `e OE0Co

D; \Gamma ; o/ `gen (oeo; Co)

Proof: Given C; OE\Gamma  `X t e : oe. I perform type inference in X c and obtain

~C; \Gamma  `Wc e : ff

such that

id ^OE

00

fv(\Gamma ) OE C `

e OE00C0o C `i OE00oe0o _ oe

where oe0o = 8ff: ) ~C and Co = 9ff: ~C. Furthermore, I assume that oe = 8_fl:D0 ) o/ 0.
From C `i OE00oeo _ oe I can deduce that there exists ss = [o/ =ff] such that

C ^ D0 `e (ss ffi OE00) ~C C ^ D0 `i (ss ffi OE00)o/ _ o/ 0: (C.12)
But then I know the principal normal form of ~C exists. I set

(D; ) = normalize( ~C; id)
and find that

 ^OE000 (ss ffi OE00) C ^ D0 `e OE000D: (C.13)

I can apply the term reconstruction step and find that

; D; \Gamma  `Wterm e : (ff):
I find D; \Gamma ; (ff) `gen (oeo; Co) where I assume oeo = 8 _fi:D ) (ff) and Co = 9 _fi:D.
From C.12 and C.13 I follow that

C `i OE000(8 _fi:D ) (ff)) _ oe:

Furthermore, it holds that  ^OE

000

fv(\Gamma ) OE.
It remains to prove that C `e OE000Co. By assumption OE\Gamma  is realizable in C,

hence also oe is realizable in C. This implies there is a ` such that C `e `D0. I set
OE0 = ` ffi OE000. The substitution OE0 satisfies the same properties as the substitution OE000.
From C ^ D0 `e OE000D I can follow that C `e OE0Co and find that

 ^OE

0

fv(\Gamma ) OE C `

i OE0oeo _ oe C `e OE0Co

which establishes the completeness result.

APPENDIX C. PROOFS 142
Theorem 18 (Equivalence of `Wterm and `Wnormalize ) Given an HM(X)
instance where X satisfies the lifting property. Then OE; D; \Gamma  `Wterm e : o/ iff
OE; D; \Gamma  `Wnormalize e : o/ .
Proof: The right-side follows trivially from the left-side. I give a proof sketch for
the other direction. The essential observation is that application of the (Normalize)
rule can be omitted and it is sufficient to perform only the term reconstruction step
at the very end. I first make some observations about the normalization procedure.
By assumption the lifting property holds. It follows that

normalize(D ^ OE; id) = normalize(OED; OE):
This justifies to define normalize(C) = D ^ OE where (D; OE) principal normal form of
(C; id). By similar reasoning as in Lemma 30 and Theorem 9 it follows that

(1) normalize(normalize(C1) ^ normalize(C2)) = normalize(C1 ^ C2)
(2) normalize(9 _ff:normalize(C)) = normalize(9 _ff:C)

I consider now given the proof tree of a derivation C; \Gamma  `Wc e : fi with possible
applications of the (Normalize) rule. Constraints in judgments C; \Gamma  `Wc e : fi can
be of the following form:

C ::= p(_o/ ) j C ^ C j 9: _ff:C j normalize(C)
A double induction over the number of (Normalize) and (Var) rule applications
shows that judgment C; \Gamma  `Wc e : fi can be transformed into a judgment C0; \Gamma  `Wc
e : fi where all normalize functions in the constraint part of are omitted, i.e. C0 is
the constraint resulting from C by erasing all normalize functions in C. Because of
equations (1) and (2) it holds that normalize(C) = normalize(C0).

This shows given judgment OE; D; \Gamma  `Wterm e : o/ . Then I can derive the same
judgment where all applications of the (Normalize) rule are omitted.

C.9 Proofs of Chapter 5
Theorem 23 (Full and Faithful) HM(OVER) (with or without projection appearing in syntactic form in S) models SystemO fully and faithfully.
Proof: I have to show that given an expression e and a type environment \Gamma . Then
e is typable under \Gamma  in SystemO iff e is typable under \Gamma  in HM(OVER).

It is an easy observation that HM(OVER) models SystemO faithful. The (8 Intro-OVER)
rule in HM(OVER) subsumes the (8 Intro-SystemO) rule in SystemO. Hence, every
judgment in SystemO is also derivable in HM(OVER).

APPENDIX C. PROOFS 143

It remains to proof the fullness direction. Given a judgment C; \Gamma  ` e : oe in
HM(OVER), I have to show that e is typable under \Gamma  in SystemO. I apply induction
over the derivation tree of the judgment C; \Gamma  ` e : oe. I consider the number of
(8 Intro-OVER) rules with non-trivial projection. Recall, in Section 5.2 I have
already observed that the (8 Intro-OVER) rule is strictly more powerful than the
(8 Intro-SystemO) rule. There are cases where rule (8 Intro-SystemO) forbids to
quantify over a free type variable. Such cases occur if projection is non-trivial. But
this is possible under rule (8 Intro-OVER), see Example 14. The proof proceeds by
rewriting the derivation tree and omitting application of the (8 Intro-OVER) rule
with non-trivial projection. It turns out that application of the (8 Intro-OVER)
with non-trivial projection does not allow to type more programs.

I consider the last occurrence of a (8 Intro-OVER) rule with non-trivial projection in the derivation tree. Note, I assume that the sub-term in the sub-judgment is
used in a monomorphic context. That means, the polymorphic type of the sub-term
will be instantiated to a monomorphic type in a later part of the derivation tree.
Otherwise, I could immediately omit application of the (8 Intro-OVER) rule.

I examine the last (8 Intro-OVER) rule with non-trivial projection in the derivation tree of C; \Gamma  ` e : oe. I find the following situation:

C0 ^ D; \Gamma 0 ` e0 : oe0 fi 62 fv(\Gamma 0) [ fv(C0)

there is a ff such that ff ! fi
C0 ^ 9fi:D; \Gamma 0 ` e0 : 8fi:D ) oe0

I consider two cases. If ff 62 fv(\Gamma 0) I could switch the order of quantification and first
quantify over ff. Hence, I assume that I deal with a situation where I can not reorder
the order of quantification. This enforces that ff 2 fv(\Gamma 0). Note, this hold only
because I have imposed an ordering relation on the type variables in a constraint.
Then, I can consider ff as an arbitrary but fixed type variable. This observation is
important in a later part of the proof. By assumption the polymorphic type 8fi:D )
oe0 is used in a monomorphic context. I consider the possible instantiations for the
type variable fi. Assume, OE1 = [o/1=fi] and OE2 = [o/2=fi] are possible instantiations
for the type variable fi. Furthermore, I know that there must be a constraint of
the form (o :: ff ! o/ ) in D with fi 2 fv(o/ ). Note, in general there is a sequence
of constraints of the form (o1 :: ff1 ! o/1); : : : ; (on :: ffn ! o/n) with ffi 2 fv(o/i\Gamma 1)
and fi 2 fv(o/n). W.l.o.g., I only consider the simplest possible case. Remember, for
a fixed ff (I know that ff can not be a polymorphic type variable) the result type
o/ in the constraint (o :: ff ! o/ ) is uniquely determined. This is enforced by the
rules put on the constraint system OVER. Hence, I find that o/1 = o/2. Therefore,
I can omit application of the (8 Intro-OVER) rule. Because the polymorphic type
variable fi can not be instantiated to different types. Instead, I can use the sub-
judgment C0 ^ 9fi:D; \Gamma 0 ` e0 : OE1oe. This yields a derivation tree of judgment

APPENDIX C. PROOFS 144
C; \Gamma  ` e : oe where the number (8 Intro-OVER) rules with non-trivial projection
is reduced by one. Application of the induction hypothesis yields that the term e is
typable under \Gamma  in SystemO. Specifically, there is a derivation tree of the judgment
C; \Gamma  ` e : oe where all applications of the quantifier introduction rule are instances
of rule (8 Intro-SystemO). This concludes the proof.

Appendix D

HM(X) in Haskell

*------------------------------------------------
* Specification of the generic HM(X)
* type inference system in Haskell
*
* Parts which need to be filled in to obtain
* a specific instance are highlighted
*
* As an example I consider the standard
* Hindley/Milner system and the dimension
* type system in style of A.J. Kennedy
*------------------------------------------------

? module Main where
*------------------------------------------------
* Category: DATA DECLARATIONS
*------------------------------------------------

The type language
? type TVar = Int
? type Var = Int
? data Type = TV TVar
? -- Type `Fun` Type
? deriving Show

145

APPENDIX D. HM(X) IN HASKELL 146
The constraint language
? data Predicate = TRUE
? -- Type `Subsume` Type
? deriving Show

? data Constraint = C [Predicate]
? -- Proj [TVar] [Predicate]
? deriving Show

FILL IN: extend type and constraint language
Type schemes
? data TypeScheme = Mono Type
? -- Poly [TVar] Constraint Type
? deriving Show

Substitutions and type environments
? type Subst = [(TVar, Type)]
? type Typo = [(Var,TypeScheme)]

The term language
? data Term = Id Var -- Abs Var Term -- App Term Term
? -- Let Var Term Term
? deriving Show

The error monad
? data E a = Suc a -- Err String
? deriving Show

The type inference monad - a typing problem consists of a three tupel
? data TP a = TP ( (TVar, Subst, Constraint) -?
? E (TVar, Subst, Constraint, a))

*----------------------------------------
* Category: CLASS DECLARATIONS

APPENDIX D. HM(X) IN HASKELL 147
*----------------------------------------
? class TypesAndConstraints c where
? apply :: Subst -? c -? TP c
? tv :: c -? [TVar]

apply -- applies a substitution to either a type or constraint
tv -- computes the free type variables

*-----------------------------------------
* Category: INSTANCE DECLARATIONS
*-----------------------------------------

? instance TypesAndConstraints Predicate where
? apply s TRUE = return TRUE
? apply s (t1 `Subsume` t2) = do t1' !- apply s t1
? t2' !- apply s t2
? return (t1' `Subsume` t2')
? tv TRUE = []
? tv (t1 `Subsume` t2) = (tv t1) ++ (tv t2)

? instance TypesAndConstraints c =? TypesAndConstraints [c] where
? apply s = mapM (apply s)
? tv a = foldl f [] a where
? f z x = z ++ (tv x)

? instance TypesAndConstraints Constraint where
? apply s (C p) = do p' !- apply s p
? return (C p')
? apply s (Proj tvl p) = do p' !- apply s p
? return (Proj tvl p')
? tv (C p) = tv p
? tv (Proj tvl p) = without (tv p) tvl

? instance TypesAndConstraints Type where
? apply s (TV tvl) = case lookup tvl s of
? Just t -? return t
? Nothing -? return (TV tvl)
? apply s (t1 `Fun` t2) = do t1' !- apply s t1
? t2' !- apply s t2
? return (t1' `Fun` t2')

APPENDIX D. HM(X) IN HASKELL 148
? tv (TV tvl) = [tvl]
? tv (t1 `Fun` t2) = (tv t1) ++ (tv t2)

? instance TypesAndConstraints TypeScheme where
? apply s (Poly tvl c t) = do c' !- apply s c
? t' !- apply s t
? return (Poly tvl c' t')
? apply s (Mono t) = do t' !- apply s t
? return (Mono t')
? tv (Poly tvl c t) = without ((tv t) ++ (tv c)) tvl
? tv (Mono t) = tv t

FILL IN: instance declarations in case of extended type and

constraint language

*--------------------------------------------------
* Category: MONAD DECLARATIONS
*--------------------------------------------------

? unTP (TP a) = a
? instance Monad TP where
? m ??= k = TP ( " (n,s,c) -?
? case unTP (m) (n,s,c) of
? Suc (n',s',c',x) -? unTP (k x) (n',s',c')
? Err s -? Err s )
? return x = TP ( " (n,s,c) -? return (n,s,c,x) )

? instance Monad E where
? m ??= k = case m of
? Suc a -? k a
? Err s -? Err s
? return x = Suc x

? report.error :: String -? a -? TP a
? report.error msg x = TP ( " (n,s,c) -? Err msg)

*---------------------------------------
* Category: INITIALIZATIONS
*---------------------------------------

APPENDIX D. HM(X) IN HASKELL 149
? null.subst :: Subst
? null.subst = []

? init.typo :: Typo
FILL IN: initial type environment
? true.cons :: Constraint
? true.cons = C [TRUE]

? init.tvar :: TVar
? init.tvar = 0

? new.tvar :: TVar -? TVar
? new.tvar n = n + 1

*--------------------------------------
* Category: Core type inferencer
*--------------------------------------

primitives for lists
? without :: [TVar] -? [TVar] -? [TVar]
? without [] a = []
? without (x:a) b = if elem x b then without a b
? else x:(without a b)

primitives for dealing with constraints
? add.cons :: Constraint -? Constraint -? Constraint
? add.cons (C p1) (C p2) = C (p1 ++ p2)
? add.cons (C p1) (Proj tv p2) = Proj tv (p1 ++ p2)
? add.cons (Proj tv p1) (C p2) = Proj tv (p1 ++ p2)
? add.cons (Proj tv1 p1) (Proj tv2 p2) = Proj (tv1 ++ tv2) (p1 ++ p2)

? projection :: Constraint -? [TVar] -? Constraint
FILL IN: definition of projection on constraints.

Projection might vary depending on different
kinds of constraint systems. A standard
definition can be found below.

APPENDIX D. HM(X) IN HASKELL 150

projection (C p) tvl = Proj tvl p
projection (Proj tv1 p) tv2 = Proj (tv1 ++ tv2) p

lifted functions
? tv.typo :: Typo -? [TVar]
? tv.typo env = foldl f [] env where
? f z (v,ts) = z ++ (tv ts)

? add.constraint :: Constraint -? TP ()
? add.constraint c1 =
? TP (" (n,s,c) -? return (n,s,add.cons c c1,()))

handling of type variables and type environments
? newtvar :: TP TVar
? newtvar = TP (" (n,s,c) -? return (new.tvar n,s,c,n) )

? insert :: Typo -? (Var, TypeScheme) -? Typo
? insert a (x,t) = (x,t):a

? mylookup :: Typo -? Var -? E TypeScheme
? mylookup [] y =
? Err "undeclared variable"
? mylookup ((x,t):xs) y =
? if x == y then return t
? else mylookup xs y

instantiation and generalization
? rename :: TP Subst -? TVar -? TP Subst
? rename s x = do newtv !- newtvar
? s' !- s
? return ((x, TV newtv):s')

? inst :: Typo -? Var -? TP Type
? inst env x =
? case mylookup env x of
? Suc ts -? case ts of
? Mono t -? return t

APPENDIX D. HM(X) IN HASKELL 151
? Poly tvl c t -?
? do s' !- foldl rename (return null.subst) tvl
? c' !- apply s' c
? t' !- apply s' t
? add.constraint c'
? return t'
? Err . -? do ntv !- newtvar
? report.error "undeclared variable" (TV ntv)

? gen :: Typo -? Type -? TP TypeScheme
? gen env t =
? TP ( " (n,s,c) -?
? return (n,s, projection c (fv t c env), Poly (fv t c env) c t) )
? where fv t1 c1 env1 = without ((tv t1) ++ (tv c1)) (tv.typo env1)
?

constraint solver
? cs :: (Subst, Constraint) -? TP (Subst, Constraint)
FILL IN: specific constraint solver
incorporating the constraint solver into monad TP
? normalize :: Type -? TP Type
? normalize a = do s !- get.subst
? c !- get.cons
? (s',c') !- cs (s,c)
? t !- apply s' a
? return.result s' c' t

? get.subst :: TP Subst
? get.subst = TP ( " (n,s,c) -? return (n,s,c,s))

? get.cons :: TP Constraint
? get.cons = TP ( " (n,s,c) -? return (n,s,c,c))

? return.result :: Subst -? Constraint -? Type -? TP Type
? return.result s c t = TP ( " (n,s',c') -? return (n,s,c,t))

type inference

APPENDIX D. HM(X) IN HASKELL 152
? tp :: (Typo, Term) -? TP Type
? tp (env, Id x) = do a !- inst env x
? normalize a

? tp (env, Abs x e) = do a !- newtvar
? b !- tp (insert env (x, Mono (TV a)), e)
? normalize ((TV a) `Fun` b)

? tp (env, App e e') = do a !- newtvar
? t !- tp (env, e)
? t' !- tp (env, e')
? add.constraint (C [t `Subsume` (t' `Fun` TV a)])
? normalize (TV a)

? tp (env, Let x e e') = do a !- tp (env, e)
? b !- gen env a
? tp ((insert env (x, b)), e')

top-level program
? infer :: Term -? E (TVar, Subst, Constraint, Type)
? infer e = unTP (tp (init.typo, e)) (init.tvar, null.subst, true.cons)

*------------------------------------------
* Category: Hindley/Milner instance
*------------------------------------------

? init.typo = []
Invariant: all constraints are true, hence projection is always trivial
? projection . . = true.cons
Implementation of the Robinson's unification algorithm
? unify :: (Subst, Type, Type) -? TP Subst
? unify (s, TV x, TV y) =
? if x == y then return s
? else do t !- apply s (TV x)
? return ((y, t):s)

APPENDIX D. HM(X) IN HASKELL 153
? unify (s, TV x, t) =
? do t'' !- apply s t
? if elem x (tv t'')
? then report.error "occurs check fails" null.subst
? else return ((x, t''):s)
? unify (s, t, TV x) = unify (s, TV x, t)
? unify (s, t1 `Fun` t1', t2 `Fun` t2') = do s' !- unify (s, t1, t2)
? unify (s', t1', t2')

? cs (s, C ((t `Subsume` t'):c)) = do s' !- unify (s,t,t')
? c' !- apply s' (C c)
? cs (s', c')
? cs (s, C (TRUE:c)) = cs (s, C c)
? cs (s, C []) = return (s, true.cons)

test cases
? test = infer (App (Abs 1 (Id 1)) (Abs 2 (Id 2)))
? test1 = infer (Abs 1 (Abs 2 (Id 1)))
? test2 = infer (Abs 1 (Id 1))
? test3 = infer (Abs 1 (App (Id 1) (Id 1)))
? test4 = infer (Let 1 (Abs 2 (Id 2)) (App (Id 1) (Abs 3 (Id 3))))
? test5 = infer (Let 1 (Abs 2 (Id 2)) (Id 1))
? test6 = infer (Let 1 (Abs 2 (Id 2)) (App (Id 1) (Id 1)))

*------------------------------------------
* Category: Dimension type system
*
* I only mention the necessary changes
* to obtain an instance that deals
* with dimension types
*------------------------------------------

*------------------------------------------------
* Category: DATA DECLARATIONS
*------------------------------------------------

The type language
? type TVar = Int

APPENDIX D. HM(X) IN HASKELL 154
? type Var = Int
? data Type = TV TVar
? -- Type `Fun` Type
? -- Dim [(Unit,Int)]
? deriving Show

? data Unit = UnitTV TVar -- UnitMeter -- UnitSecond
? deriving Show

*-----------------------------------------
* Category: INSTANCE DECLARATIONS
*-----------------------------------------

? instance TypesAndConstraints Predicate where
? apply s TRUE = return TRUE
? apply s (t1 `Subsume` t2) = do t1' !- apply s t1
? t2' !- apply s t2
? return (t1' `Subsume` t2')
? tv TRUE = []
? tv (t1 `Subsume` t2) = (tv t1) ++ (tv t2)

? instance TypesAndConstraints c =? TypesAndConstraints [c] where
? apply s = mapM (apply s)
? tv a = foldl f [] a where
? f z x = z ++ (tv x)

? instance TypesAndConstraints Constraint where
? apply s (C p) = do p' !- apply s p
? return (C p')
? apply s (Proj tvl p) = do p' !- apply s p
? return (Proj tvl p')
? tv (C p) = tv p
? tv (Proj tvl p) = without (tv p) tvl

? instance TypesAndConstraints Type where
? apply s (TV tvl) = case lookup tvl s of
? Just t -? return t
? Nothing -? return (TV tvl)
? apply s (t1 `Fun` t2) = do t1' !- apply s t1
? t2' !- apply s t2
? return (t1' `Fun` t2')

APPENDIX D. HM(X) IN HASKELL 155
? apply s (Dim []) = return (Dim [])
? apply s (Dim ((UnitTV utv, exp):r)) =
? case lookup utv s of
? Just t -?
? case t of
? Dim u -?
? do t' !- apply s (Dim r)
? case t' of
? Dim r' -? return (Dim (normalize.unit
? (map ( " (ut, ue) -? (ut, ue * exp)) u) ++ r'))
? . -? report.error "should be a unit" (Dim [(UnitSecond,0)])
? . -? report.error "types are not allowed within units"
? (Dim [(UnitSecond,0)])
? Nothing -? do t' !- apply s (Dim r)
? case t' of
? Dim r' -? return (Dim ((UnitTV utv, exp):r'))
? . -? report.error "should be a unit"
? (Dim [(UnitSecond,0)])
? apply s (Dim ((u,exp):r)) =
? do t !- apply s (Dim r)
? case t of
? Dim r' -? return (Dim ((u,exp):r'))
? . -? report.error "should be a unit" (Dim [(UnitSecond,0)])
? tv (TV tvl) = [tvl]
? tv (t1 `Fun` t2) = (tv t1) ++ (tv t2)
? tv (Dim []) = []
? tv (Dim ((UnitTV utv, exp):r)) = [utv] ++ (tv (Dim r))
? tv (Dim ((u,exp):r)) = tv (Dim r)

? instance TypesAndConstraints TypeScheme where
? apply s (Poly tvl c t) = do c' !- apply s c
? t' !- apply s t
? return (Poly tvl c' t')
? apply s (Mono t) = do t' !- apply s t
? return (Mono t')
? tv (Poly tvl c t) = without ((tv t) ++ (tv c)) tvl
? tv (Mono t) = tv t

*------------------------------------------
* Category: Dimension constraint solver

APPENDIX D. HM(X) IN HASKELL 156
*------------------------------------------
? instance Eq Unit where
? (UnitTV tv1) == (UnitTV tv2) = tv1 == tv2
? UnitMeter == UnitMeter = True
? UnitSecond == UnitSecond = True
? . == . = False

putting a unit type into normal form
? normalize.unit :: [(Unit,Int)] -? [(Unit,Int)]
? normalize.unit [] = []
? normalize.unit ((u,exp):rest) =
? let (rest', occ) = collect.unit u ((u,exp):rest)
? rest'' = normalize.unit rest'
? in if occ == 0 then sort.unit rest''
? else sort.unit ((u,occ):rest'')

here comes the `very' normalized version, units are separated into
constants and variables

? very.normalize.unit :: [(Unit,Int)] -? [(Unit,Int)]
? very.normalize.unit ul = let (vars, const) = split.unit ul
? in (normalize.unit vars) ++ (normalize.unit const)

splits a unit into the variable and constant part
? split.unit :: [(Unit,Int)] -? ([(Unit,Int)],[(Unit,Int)])
? split.unit [] = ([],[])
? split.unit ((UnitTV tv, exp):rest) = let (vars,const) = split.unit rest
? in ((UnitTV tv, exp):vars,const)
? split.unit (u:rest) = let (vars,const) = split.unit rest
? in (vars,u:const)

sorts a list of units wrt exponent
? sort.unit :: [(Unit,Int)] -? [(Unit,Int)]
? sort.unit [] = []
? sort.unit ((u,exp):rest) =
? let l1 = [(u1,exp1) -- (u1,exp1) !- rest, (abs exp1) != (abs exp)]
? l2 = [(u2,exp2) -- (u2,exp2) !- rest, (abs exp2) ? (abs exp)]

APPENDIX D. HM(X) IN HASKELL 157
? in (sort.unit l1) ++ [(u,exp)] ++ (sort.unit l2)
takes a unit and a unit a list of units,
result is the number of occurenes in that unit, and the list of units where
all occurences have been discarded

? collect.unit :: Unit -? [(Unit,Int)] -? ([(Unit,Int)],Int)
? collect.unit u [] = ([],0)
? collect.unit u ((u',exp):rest) = if u == u'
? then let (rest', occ) = collect.unit u rest
? in (rest', occ+exp)
? else let (rest', occ) = collect.unit u rest
? in ((u',exp):rest', occ)

Invariant: all constraints are true, hence projection is always trivial
? projection . . = true.cons
Implementation of the Lankford/Butler/Brady unification algorithm for abelian groups
? unify :: (Subst, Type, Type) -? TP Subst
? unify (s, TV x, TV y) =
? if x == y then return s
? else do t !- apply s (TV x)
? return ((y, t):s)
? unify (s, TV x, t) =
? do t'' !- apply s t
? if elem x (tv t'') then report.error "occurs check fails" null.subst
? else return ((x, t''):s)
? unify (s, t, TV x) = unify (s, TV x, t)
? unify (s, t1 `Fun` t1', t2 `Fun` t2') = do s' !- unify (s, t1, t2)
? unify (s', t1', t2')
? unify (s, Dim u, Dim u') = let u'' = map ( " (ut,ue) -? (ut, -ue)) u'
? in unify.unit s (u ++ u'')
? unify (s, ., .) = report.error "not compatible type" null.subst

? unify.unit :: Subst -? [(Unit, Int)] -? TP Subst
? unify.unit s ul =
? let (vars,const) = group.it (split.unit (normalize.unit ul))
? in if (vars == []) && (const == []) then return s
? else

APPENDIX D. HM(X) IN HASKELL 158
? if vars == [] then report.error "Error" null.subst
? else
? let vars' = normalize.unit vars
? (UnitTV tv ,ue) = head vars'
? newlist = map ( " (u',e') -? (u', -(div e' ue)))
? ((tail vars')++const)
? in if (foldl ( " b -? " (.,e) -? b && (mod e ue == 0)) True
? ((tail vars')++const))
? then return ((tv, Dim newlist):s)
? else if (tail vars') == [] then report.error "Error" null.subst
? else do newtv !- newtvar
? unify.unit ((tv,Dim ([(UnitTV newtv,1)]++newlist)):s)
? ([(UnitTV newtv, ue)] ++
? (map ( " (u',e') -? (u', mod e' ue))
? ((tail vars')++const)))

ensures that first element of vars list has positive value
? group.it :: ([(Unit,Int)],[(Unit,Int)]) -? ([(Unit,Int)],[(Unit,Int)])
? group.it ([],const) = ([],const)
? group.it ((ut,ue):rest,const) = let f x = map ( " (ut,ue) -? (ut, -ue)) x
? in if ue ?= 0 then ((ut,ue):rest,const)
? else ((ut,-ue): (f rest), f const)
?

? cs (s, C ((t `Subsume` t'):c)) = do s' !- unify (s,t,t')
? c' !- apply s' (C c)
? cs (s', c')
? cs (s, C (TRUE:c)) = cs (s, C c)
? cs (s, C []) = return (s, true.cons)

primitive functions
? init.typo = [(1, Poly [300] (C [TRUE]) (Dim [(UnitTV 300, 1)] `Fun`
? (Dim [(UnitTV 300, 1)] `Fun` Dim [(UnitTV 300, 1)])))]

example addition: plus : forall a. dim(a) -? dim(a) -? dim(a)

Appendix E
A Catalogue of Notation
Naming conventions:

X type system instance
\Gamma  type environment
ff; fi type variables
o/ type
oe type scheme
C; D constraints
fv(\Delta ) free variables
_ subsumption

Judgments:

C; \Gamma  ` e : oe Figure 3.1
C; \Gamma  `n e : oe Section 3.4.4
C; \Gamma  `s e : o/ Figure 3.2
C; \Gamma  `X c e : oe Section 3.6.2
C; \Gamma  `X t e : oe Section 3.6.2
OE; C; \Gamma  `W e : o/ Figure 4.1
C; \Gamma  `Wc e : o/ Figure 4.3
OE; C; \Gamma  `Wterm e : o/ Figure 4.4
C; \Gamma  `Wc2 e : ff Figure 4.5
OE; C; \Gamma  `Wnormalize e : o/ Figure 4.5

159

APPENDIX E. A CATALOGUE OF NOTATION 160

Relations:

C `e D Definition 2

C =e D Definition 2
(o/1 = o/2) Definition 7
(o/1 _ o/2) Section 3.2
(o/1 !: o/2) Definition 6
C `i oe _ oe0 Section 3.4.1
C `i2 oe _ oe0 Section 3.4.1
C `i oe j oe0 Section 3.4.1
C ` oe 7! oe0 Definition 18
C; \Gamma ; oe `gen (C0; oe0) Sections 3.4, 4.3

Index
closed world approach, 44
comparison relation, see instance relation
consistent, 35
constraint, 23

entailment, 17
free variables of, 18
normalization, 63
problem, 68

combination of, 68
satisfiable, 18
solved, 24
solving, 63
subsumption, 63
constraint system, 16, 25

coherent, 29
cylindric, 18
dimension type, 20
herbrand, 20
simple, 17
sound, 27
strongly sound, 30
subtyping, 21
term, 19

dimension types, 20, 26, 64
entailment, see constraint
equation-free, 71
equational theory, 67

non-regular, 66, 67, 77, 82, 87
regular, 66, 67, 77, 82

full and faithful, 58, 94, 109

ideal semantic, 9, 27
inference, 11

by need, 76
completeness of, 13, 78, 82, 83
eager, 76
in constraint form, 79
in term form, 74
lazy, 44
soundness of, 13, 77, 81, 83
strict, 44
system

`W , 12, 74
`Wbyneed , 76
`Wc , 80
`Wnormalize , 85
`Wterm , 83
instance relation, 33

`i , 33
`i2 , 34

judgment, 23

projection free, 30, 53
valid, 23

let realizable, 53
lifting property, 72
Lifting Theorem, 73

mgu, see most general, unifier
monotype, 27
most general

normalizers, see normalization, most

general
unifier, 11, 99, 102

161

INDEX 162
non-regular, see equational theory
normal form, 69
normalization, 68

by need, 72
eager, 72
lifting of, 72
most general, 70

open world approach, 42, 44
polymorphism

constrained, 7, 39
parametric, 7
predicate, see constraint
principal

constraint property, 70
normal form, 69
types, 13, 78

uniqueness, 79
projection

free, 53, 72
in solved form, 42, 46, 48, 53
in syntactic form, 46, see projection, in solved form, 53, 54
non-trivial, 46, 53
operator, 18, 41
trivial, see projection, in solved form,

46, 53, 109
projection-free, 30

quantifier

elimination rule, 38, 40, 60
existential quantification, see projection
introduction rule, 38, 40
nested forall, 38, 46

realizable, 35
records, 91

concatenation, 98
extensible, 95
first-class labels, 100

regular, see equational theory
solved forms, 24
subject reduction, 32
substitution, 19, 67

in constraint form, 57
subsumption, 25, 63

relation, 25
subtyping, 26

term algebra, 23, 25, 54
Transformation Theorem, 57, 88
type case, 103
type schemes, 8, 23
type soundness, 11, 29

syntactic, 32
type system, 6

` , 8, 23, 59
`X c , 56
`s , 36
`n , 36
`X t , 56
constraint-based, 58
dimension types, 26
Hindley/Milner, 7, 25
in constraint form, 59
subtyping, 26
term-based, 58
types

constrained, 23
in constraint form, 54
in term form, 54
monomorphic, 8
polymorphic, 8
typing judgment, 8, 23

valid, 9, 23

unification

problem, 11
unitary, 68

weakening, 35