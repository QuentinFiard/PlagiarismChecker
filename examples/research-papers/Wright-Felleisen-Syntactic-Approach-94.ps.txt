

A Syntactic Approach to Type Soundness

Andrew K. Wright\Lambda  Matthias Felleisen\Lambda 

Department of Computer Science

Rice University
Houston, TX 77251-1892

June 18, 1992

Rice Technical Report TR91-160
To appear in: Information and Computation

Abstract
We present a new approach to proving type soundness for Hindley/Milner-style
polymorphic type systems. The keys to our approach are (1) an adaptation of subject
reduction theorems from combinatory logic to programming languages, and (2) the use
of rewriting techniques for the specification of the language semantics. The approach
easily extends from polymorphic functional languages to imperative languages that
provide references, exceptions, continuations, and similar features. We illustrate the
technique with a type soundness theorem for the core of Standard ML, which includes
the first type soundness proof for polymorphic exceptions and continuations.

1 Type Soundness
Static type systems for programming languages attempt to prevent the occurrence of type
errors during execution. A definition of type error depends on a specific language and
type system, but always includes the use of a function on arguments for which it is not
defined, and the attempted application of a non-function. A static type system is sound if
well-typed programs cannot cause type errors; a programming language with a sound static
type system is strongly typed [7].

While it is easy to design a sound type system for an explicitly typed monomorphic
language, the formulation of a sound type system for a language based on Hindley/Milnerstyle polymorphism and type inference is delicate [6, 8, 15, 17, 20, 37]. Although the
treatment of purely functional languages is relatively well understood in this framework,
the incorporation of imperative features such as references and exceptions requires extreme
care, and the soundness of such systems is not obvious. A formal proof of soundness is

\Lambda This research was supported in part by the United States Department of Defense under a National
Defense Science and Engineering Graduate Fellowship, by NSF grant CCR 89-17022, and by Texas Grant
ARP/ATP-91 #003604-014.

1

Syntactic Type Soundness 2
required to lend credibility to the claim that such a system prevents type errors, and may
be a crucial tool in the design of the type system.

We view a static type system for an implicitly typed language as a filter that selects
well-typed programs from a larger universe of untyped programs. A partial function eval :
Programs * Answers [ fwrongg defines the semantics of untyped programs. The result
wrong is returned for programs whose evaluation causes a type error; eval is undefined
for programs whose evaluation does not terminate. Let . e : o/ mean that the type system
assigns program e the type o/ , i.e., e is well-typed. The simplest soundness property states
that well-typed programs do not yield wrong [20].

Definition (Weak Soundness) If . e : o/ then eval (e) 6= wrong.

While weak soundness establishes that a static type system achieves its primary goal of
preventing type errors, it is often possible to demonstrate a stronger property that relates
the answer produced to the type of the program. If we view each type o/ as denoting
different subsets V o/ of the set of all answers V , then strong soundness states that an
answer v produced by a terminating program of type o/ is an element of the subset V o/ .

Definition (Strong Soundness) If . e : o/ and eval (e) = v then v 2 V o/ .
Strong soundness permits an implementation of the language to associate the representation
of a value with its type, and thereby omit the representation tags required by dynamically
typed languages. Weak soundness follows from strong soundness since wrong is not a
member of V o/ for any type o/ .

Significant effort has been invested in proving type soundness for Hindley/Milner-style
type systems, and their practical realization in the programming language Standard
ML [22, 23]. Soundness proofs exist for the functional fragment [20, 36], for extensions
including references [6, 17, 35, 37], and for a monomorphic language including first-class
continuations [8]. However, there are several drawbacks to the existing proofs. Proofs of
type soundness are sensitive to the precise formulation of the semantics of the language--
different techniques are required for denotational versus operational formulations of the semantics, and even for different languages within the same semantic framework. The proofs
for two different languages are difficult to reconcile to prove soundness for a language including features of both. The existing techniques are complicated, and the resulting proofs
are lengthy and error-prone. For an illustration of the difficulties with such proofs, we refer
the reader to Tofte's [37] discussion of Damas's [6] faulty proof of a type soundness theorem
for a polymorphic language with references.

We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result
from combinatory logic [4], and on rewriting as a means to specifying operational semantics [11, 12, 13, 14]. To demonstrate the approach, we develop a proof of soundness for
the core1 of Standard ML, which extends a functional polymorphic language with references and exceptions. We also show soundness for an extension to Standard ML with
first-class continuations. In principle, our approach is uniformly applicable to any language;

1Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML [24]. However,
the difficulties of typing references and exceptions [6, 17, 35, 37] and the fact that they cannot be expressed
by facilities of the functional core [10] indicate that they are equally important.

Syntactic Type Soundness 3
in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive
techniques.

In the next section, we describe a prototypical functional language with a polymorphic
type system, and discuss the various approaches that have previously been used to prove
type soundness. Section 3 presents the essence of our approach to proving type soundness;
the remaining sections develop illustrative proofs of type soundness for a specific functional
language and various extensions.

2 Previous Approaches to Proving Type Soundness
Any proof of type soundness is intimately tied to the formulation of the semantics of the
language. The earlier proofs relied on denotational semantics; later proofs used structural
operational semantics. The following two subsections briefly present these approaches from
a historical perspective. The third subsection discusses the problems with them. We begin
with a brief introduction to the formulation of Hindley/Milner-style type systems, in order
to introduce our notation.

Our prototypical functional language has the following (abstract) syntax:

e ::= c j x j *x:e j e1 e2 j let x be e1 in e2
where x 2 Var and c 2 Const. Constants (Const) include both data (integer, real, boolean,
etc.) and operations (+, \Xi , ^, ., etc.). Variables (Var ) are lexically scoped. Juxtaposition
denotes application and is left associative; *-expressions construct call-by-value procedural
abstractions. Semantically the let-expression behaves like ((*x:e2) e1), binding the value of
e1 to x in e2; however, the type system allows x to be polymorphic: different occurrences
of x in e2 may be assigned different types.

A polymorphic type system for this language has types of the form:

o/ ::= '1 j : : : j 'n j o/1 ! o/2
where '1; : : : ; 'n are ground types like int and bool. The type system is formulated as
a deductive proof system that assigns types to expressions. The proof system produces
conclusions, or type judgments, of the form \Gamma  . e : o/ , meaning that expression e has type
o/ in type environment \Gamma . Type environments are finite maps from variables to types, and
are used to give types to open expressions. The typing rules are:

\Gamma  . x : o/ if \Gamma (x) = o/(var)
\Gamma  . c : o/ if TypeOf (c) = o/(const)

\Gamma [x 7! o/1] . e : o/2
\Gamma  . *x:e : o/1 ! o/2(abs)
\Gamma  . e1 : o/1 ! o/2 \Gamma  . e2 : o/1

\Gamma  . e1 e2 : o/2(app)
\Gamma  . e1 : o/1 \Gamma  . e2[x 7! e1] : o/2

\Gamma  . let x be e1 in e2 : o/2(let)

Syntactic Type Soundness 4
The function TypeOf assigns types to constants. \Gamma [x 7! o/ ] denotes the functional extension
or update of map \Gamma  at x to o/ ; e[x 7! e0] means the capture-avoiding substitution of e0 for x
in e. Programs are closed expressions. A program e is well-typed if it has a type o/ in the
empty type environment; we then write . e : o/ .

2.1 Proofs based on Denotational Semantics
Milner [20]: Milner formulated and proved a type soundness theorem for a functional
language like the above based on a denotational semantics for the language of untyped
expressions. The semantic domain is the solution of the following reflexive domain equation [32]:

V = B0 \Phi  : : : \Phi  Bn \Phi  F \Phi  W

F = V ! V

B0; : : : ; Bn are basic domains (with bottom), such as integers and booleans; F is the function
domain; W is a domain consisting of the single element wrong; \Phi  is the separated sum;
and ! builds continuous functions. The meaning function E is constructed so as to assign
the denotation wrong to programs that result in type errors. To assign meanings to
expressions with free variables, the meaning function takes an environment ae : Var ffi\Gamma ! V,
a finite map from variables to denotational values.

To establish soundness, Milner introduced a semantic relation j=. This relation identifies
each type o/ with an ideal Vo/ of the domain V [18]. An ideal is simply a subset of the domain
that is closed under certain operations (subset and least upper bounds of finite consistent
subsets); each of the basic domains forms an ideal. A denotational value v 2 V possesses
type o/ , written j= v : o/ , if v is a member of the ideal corresponding to o/ , i.e.,

v 2 Vo/ iff j= v : o/:
An environment ae respects a type environment \Gamma , written j= ae : \Gamma , if the domain of ae is at
least as large as the domain of \Gamma , and for every variable x in the domain of \Gamma , j= ae(x) : \Gamma (x).
A semantic soundness theorem states that if an expression e has type o/ in type environment
\Gamma , and if environment ae respects \Gamma , then the denotation of e in ae possesses type o/ .

Theorem (Semantic Soundness) If \Gamma  . e : o/ and j= ae : \Gamma  then j= E[[e]]ae : o/ .
This theorem is proved by induction on the structure of e. Strong soundness follows by
restricting the theorem to closed expressions.

Theorem (Strong Soundness) If . e : o/ then j= E[[e]]; : o/ .
Weak soundness is a consequence of the fact that wrong does not possess any type.
Theorem (Weak Soundness) If . e : o/ then E[[e]]; 6= wrong.

Syntactic Type Soundness 5
Damas [5, 6]: Damas extended Milner's results to a language with reference cells and
destructive assignment. The proof technique is derived from Milner's technique; however,
the proof is significantly more complicated. The denotational semantics uses the following
domain construction:

V = B0 \Phi  : : : \Phi  Bn \Phi  F \Phi  L \Phi  W

F = V ! S ! V\Omega S

S = V\Lambda 
L = N?

where the domain of locations L is the flat domain of natural numbers, S is the domain
of stores (sequences of values), and \Omega  is the smash product. Procedures take both an
input value and a store, and produce a result and a new store. The meaning function is
parameterized over both a store and an environment. Due to the presence of stores, types
are no longer ideals in V, but are finite maps from store typings to subsets of V.2 A store
typing is a finite map from locations to the types of values stored there. Since the semantic
relation (j=) must involve the types of values in the store, it can no longer be defined by
induction on types; its existence must be established by a category theoretical argument
that generalizes the technique of inclusive predicates [31]. The complexity of the semantic
relation complicates the proof; indeed, Tofte found a mistake in Damas's proof, although
the theorem is not thought to be false [37: page 2].

Abadi, Cardelli, Pierce, and Plotkin [1]: Abadi et al. demonstrate type soundness
for a functional language with a dynamic type and related operations. Their proof with
respect to a denotational semantics is similar to Milner's proof, although it is complicated
by the presence of dynamic values. A dynamic value is a pair consisting of a value v and a
tag, drawn from a set TypeCode, that encodes the type of v. The domain equation includes
a domain of dynamic values D:

V = B0 \Phi  : : : \Phi  Bn \Phi  F \Phi  D \Phi  W

F = V ! V
D = TypeCode \Theta  V

As type codes correspond to types, the denotation of a type code is a type. Types, in turn,
denote ideals over V, but due to the unusual element D of the domain equation, establishing
that types denote ideals requires extending the ideal model for recursive types [18]. The
proof that the required fixed points exist in the new model involves a metric space argument,
but is a straightforward extension of the original. Although the type system Abadi et al.
use is not polymorphic, it should be possible to extend the type system and the soundness
proof to include polymorphism.

Duba, Harper, and MacQueen [8]: Duba et al. present several languages extending
a monomorphic functional core with first-class continuations in the spirit of Scheme [28].
They describe several approaches to proving type soundness for the languages. One is with

2This is an over-simplification; the reader interested in the precise definition is referred to Damas's
thesis [6].

Syntactic Type Soundness 6
respect to a continuation-passing denotational semantics, based on the following domain
equations:

V = B0 \Phi  : : : \Phi  Bn \Phi  F \Phi  K

F = V ! K ! A
K = V ! A

A = V \Phi  W

where K is the domain of continuations, and A is the domain of answers. The meaning
function E takes both an environment and a continuation. Two semantic relations state
what it means for a value v to possess a type o/ , written j= v : o/ , and for a continuation ^
to accept a value of type o/ , written j= ^ :: o/ . These relations are defined simultaneously
by induction on types. The semantic soundness theorem states that if an expression e has
type o/ in type environment \Gamma , and if ae respects \Gamma , and if continuation ^ accepts values of
type o/ , then the meaning of e in environment ae and continuation ^ is not wrong.

Theorem (Semantic Soundness) If \Gamma  . e : o/ and j= ae : \Gamma  and j= ^ :: o/ then E[[e]]ae^ 6=
wrong:

Unlike in the purely functional setting, the semantic soundness theorem only states that
well-typed programs do not go wrong (weak soundness), not that they produce answers
of the expected type. To approach strong soundness, Duba et al. give an argument based
on a continuation-passing-style (CPS) translation into the simply typed *-calculus. For
programs of ground type, the denotation of an expression is the same as the denotation of
its CPS transform with the identity function as an initial continuation, i.e.,

E[[e]]; = E[[CPS(e) (*x:x)]];:
Since strong soundness holds for the simply typed *-calculus, and (CPS(e) (*x:x)) has the
same type as e for programs of ground type, strong soundness holds for programs of ground
type. However, the argument does not extend to higher types. For further details, we refer
the reader to their paper [8: page 169].

2.2 Proofs based on Structural Operational Semantics
Tofte [36, 37]: Tofte reformulated Milner's functional language with a structural operational semantics [27]. The semantics is specified as a deductive proof system; a conclusion
E ` e ) v of a deduction states that expression e evaluates to v in value environment E. A
value environment is a finite map from variables to operational values. Values are either basic constants or closures, which result from the evaluation of *-expressions. The soundness
theorem again requires the definition of a semantic relation (j=) between operational values
and types. For basic constants, the relation is explicitly specified by the function TypeOf ;
for closures, the relation is defined by induction on types, and by evaluation at correctly
typed argument values. The semantic soundness theorem states that if an expression e has
type o/ in type environment \Gamma , and if environment E respects \Gamma , and if e evaluates to a value
v in environment E, then v possesses type o/ .

Theorem (Semantic Soundness) If \Gamma  . e : o/ and j= E : \Gamma  and E ` e ) v then j= v : o/ .

Syntactic Type Soundness 7
The proof is straightforward, and proceeds by induction on the depth of the deduction of
E ` e ) v. Strong and weak soundness follow as before.

Tofte turned to structural operational semantics in order to consider references. To
this end, he reformulated the semantics with conclusions of the form s; E ` e ) v; s0,
meaning that in environment E and store s, expression e evaluates to value v and the new
store s0. The semantic relation now involves the contents of the store and the store typing
(ST ), a map from locations to the types of values stored there. The semantic relation
s : ST j= v : o/ may be read as "given the ST -typed store s, value v possesses type o/ ."
Because of the possibility of cycles amongst references in the store, this relation is not
definable by induction, but must be defined as the maximal fixed-point of a monotonic
operator on the appropriate space. The semantic soundness theorem states that if an
expression e has type o/ in type environment \Gamma , and given store s of type ST , environment
E respecting \Gamma , and that e evaluates to v and store s0, then a typing ST 0 can be found for
s0 such that v possesses type o/ .

Theorem (Semantic Soundness) If \Gamma  . e : o/ and s : ST j= E : \Gamma  and s; E ` e ) v; s0
then there exists ST 0 such that s0 : ST 0 j= v : o/ .

The theorem is proved by induction on the depth of the deduction of s; E ` e ) v; s0.
Lemmas involving the semantic relation are proved using the technique of co-induction
that Milner and Tofte developed for this purpose [21]. Leroy and Weis have successfully
applied Tofte's technique to show soundness for a different type system for polymorphic references [17]. Talpin and Jouvelot have also applied the technique to demonstrate soundness
for a system that infers types, effects, and regions for references [35].

Duba, Harper, and MacQueen [8]: Duba et al. also present a proof of type soundness with respect to a structural operational semantics for a monomorphic language with
continuations. The proof is an adaptation of Tofte's technique; however, the semantics is
significantly restructured, as the technique of defunctionalization [30] is used to represent
the flow of control explicitly. The semantics has two judgment forms. The first kind of
conclusion, E; K ` e ) v, indicates that expression e evaluates to answer v in environment
E and continuation K. The second kind of conclusion, v ` K ) v0, indicates that continuation K evaluated at value v produces answer v0. As in the denotational case, two semantic
relations are defined, indicating what it means for a value to possess a type (j= v : o/ ), and
for a continuation to accept a type (j= K :: o/ ). Like the denotational case, the theorem
only establishes weak soundness.

Theorem (Semantic Soundness) If \Gamma  . e : o/ and j= E : \Gamma  and j= K :: o/ and
E; K ` e ) v then v 6= wrong:

It is not clear that the proof goes through in the presence of fixed-point operators [8: page
171], nor how to obtain strong soundness in this framework.

2.3 Discussion
In each case above, the proof of soundness for a language or for a different formulation
of a language's semantics involves the use of a different proof technique. The techniques

Syntactic Type Soundness 8
are often unrelated, so they provide no guidance in proving soundness for new languages
or language features. A seemingly minor extension to a language may require a complete
restructuring of its denotational or structural operational semantics, and may therefore
require a completely new approach to re-establish soundness. For example, in introducing references to Milner's functional language, Damas changed the domain equations for
the denotational semantics to accommodate a store component, necessitating a completely
different strategy for induction. In introducing type dynamic, Abadi et al. again changed
the domain equations, and extended the ideal model of types to match. To accommodate
continuations, Duba et al. changed the domain equations yet again, also foregoing the tools
developed by Milner and Damas. They used a separate argument to establish strong soundness. In introducing references to an operational formulation of the functional language,
Tofte changed the form of judgments obtained by the semantics, and used the technique of
co-induction to establish a proof. For continuations in a structural operational semantics,
Duba et al. completely altered the semantics,3 again changing the structure of the proof
dramatically.

Each of the above proofs considers a language with a single extension to a functional
core. It is natural to ask whether two extensions can be merged, such that a natural union
of the two type systems is sound. However, since each of the proofs involves a different
technique, it is generally impossible to merge the proofs. Tofte's proof for references and
Duba et al.'s proof for continuations give no direct assurance that Standard ML's type
system is sound, even if the other features of Standard ML are ignored.

3 A Syntactic Approach to Proving Type Soundness
Our approach to type soundness is based upon an operational formulation of a language's
semantics by rewriting. Each intermediate state of an evaluation of a program is itself
a program, and the evaluation of a program is performed by successive reductions into a
new state: e1 7\Gamma ! e2 7\Gamma ! : : : Reduction may either continue forever (e *), or may reach a
final state where no further evaluation is possible: e1 !7\Gamma ! ek and ek 67\Gamma ! ek+1. Such a final
state represents either an answer or a type error. Thus, proving type soundness reduces to
proving that well-typed programs yield only well-typed answers.

Programming language calculi, like the *-calculus, are the natural choice to specify
the semantics of a language such that each intermediate step of evaluation is a program.
Plotkin [26] shows how the semantics of a prototypical functional language relates to the
*-calculus. The *-calculi extensions for state [12, 14] extend this strategy to languages with
references and similar constructs. Likewise, the control calculi [13, 14] can be adapted to
address non-local control facilities such as exceptions and first-class continuations.

Since the intermediate states of evaluation are programs, we may apply the type system
to deduce a type for each state. Our strategy for proving type soundness rests upon two
fundamental observations about the types of states. The first observation is that each
intermediate state may be assigned the same type as the original program, i.e., reductions
preserve type:

3Furthermore, they take this as "evidence that the addition of [continuations] to Standard ML would be
a substantial change, rather than an incremental modification, to the language" [8: page 170]. However, we
believe that this only indicates a problem with their semantic framework.

Syntactic Type Soundness 9

if . e1 : o/ and e1 7\Gamma ! e2 then . e2 : o/ .
In combinatory logic, this property is known as subject reduction [4].

The second observation is that sound type systems do not assign a type to irreducible
expressions that are the sources of type errors, such as 1 + true. Furthermore, any expression containing such a subexpression is untypable; we call expressions containing such
irreducible subexpressions faulty:

if e is faulty, there is no o/ such that . e : o/ .
Together, these two observations imply that all final states that can be reached from a
well-typed program are well-typed answers. With a definition of eval that takes faulty
expressions to wrong, the type system is weakly sound.

As all answers produced are well-typed programs, subject reduction also establishes
strong soundness. To state that an answer v lies within the correct subset V o/ of values, we
employ the type system itself:

v 2 V o/ iff . v : o/:

This yields a soundness theorem based on a syntactic connection between answers and
types:

if . e : o/ then either e * or e !7\Gamma ! v and . v : o/ .
Again, strong soundness follows with a definition of eval that takes faulty expressions to
wrong.

In summary, proving a syntactic soundness theorem involves:

ffl demonstrating subject reduction,
ffl characterizing answers and faulty expressions, and
ffl showing that the faulty expressions are untypable.
The structure of the proof always remains the same, whether or not the language includes
some combination of references, exceptions, continuations, or other features.

3.1 Related Work
Curry and Feys [4] introduced the notion of subject reduction for combinatory logic. In the
language of combinatory logic, the CL-term e of a deduction concluding . e : o/ is called
the subject, and the type o/ is called the predicate. Subject reduction states that reduction
of the subject of a deduction preserves the predicate. Subject reduction holds for terms in
CL and the *-calculus [33].

Mitchell and Plotkin [25] present a type preservation theorem, i.e., subject reduction,
for a variant of the second order polymorphic *-calculus. This language has explicitly typed
declarations; the proof of type preservation is significantly simpler in the presence of such
declarations. They do not develop a type soundness theorem.

Abadi et al. [1] give a proof of soundness for type dynamic with respect to a structural
operational semantics, in addition to their denotationally based proof. In their structural

Syntactic Type Soundness 10
operational semantics, substitutions are carried out immediately: *-expressions evaluate to
themselves, rather than closures, and judgments do not contain an environment component.
Since answers are syntactic values, the type system can be applied to answers to show that
evaluation preserves typing. Although this proof is similar to our proof of subject reduction, its extension to references or continuations apparently involves the same difficulties as
Tofte's and Duba et al.'s proofs.

3.2 Road Map
The next three sections illustrate our approach by proving soundness for several languages.
Section 4 considers a functional language, similar to that considered by Milner [20]. Section 5
considers an extension to references, an extension to exceptions, and shows how the results
may be merged to consider a language with both. To our knowledge, this is the first proof
of soundness for exceptions. Section 6 illustrates soundness for an extension providing firstclass continuations, and is the first proof of strong type soundness for continuations in a
polymorphic language. We conclude with a discussion of our technique, and suggestions for
its application to other languages.

4 Functional ML
Functional ML is an applicative language with constants, call-by-value higher-order functions, and a Hindley/Milner-style polymorphic type system. A natural basis for a calculus
of Functional ML is Plotkin's untyped *v-calculus [26].

Let Var be a denumerable set of variables and Const be a set of constants. The expressions and values of Functional ML are:

e ::= v j e1 e2 j let x be e1 in e2(Expressions)
v ::= c j x j Y j *x:e(Values)

where x 2 Var and c 2 Const. The free variables, F V (e), and bound variables of an
expression are defined as usual, with *- and let-expressions binding their variables. The
let-expression binds x in e2 but not e1, i.e., let bindings are not recursive. The fixedpoint combinator Y provides recursion. Following Barendregt [2], we adopt the convention
that bound variables are always distinct from free variables in distinct expressions, and
we identify expressions that differ only by a consistent renaming of the bound variables.
ClosedVal is the set of values with no free variables.

4.1 Semantics
The calculus for Functional ML is based upon four relations, called notions of reduction:

c v \Gamma ! ffi(c; v) if ffi(c; v) is defined(ffi)
(*x:e) v \Gamma ! e[x 7! v](fiv)
let x be v in e \Gamma ! e[x 7! v](let)

Y v \Gamma ! v (*x:(Y v) x)(Y )

Syntactic Type Soundness 11
To abstract from the precise set of constants, we only assume the existence of a partial
function:

ffi : Const \Theta  ClosedVal * ClosedVal

that interprets the application of functional constants to closed values and yields closed
values. The fiv and let reductions use substitution: the notation e[x 7! v] means the
substitution of v for free occurrences of x in e, renaming bound variables of v as necessary
to avoid capture. The Y reduction introduces an abstraction around (Y v) as v must be
applied to a value (x does not appear free in v by the variable conventions).

We refer to the union of these relations as v, or simply \Gamma ! when there is no danger
of confusion. The notion of reduction v gives rise to a system of reductions, !\Gamma ! . The
relation !\Gamma ! is the reflexive, transitive, and compatible closure of \Gamma !:

e1 \Gamma ! e2

e1 !\Gamma ! e2 e1 !\Gamma ! e1

e1 !\Gamma ! e2 e2 !\Gamma ! e3

e1 !\Gamma ! e3

e1 !\Gamma ! e2
C[e1] !\Gamma ! C[e2]( !\Gamma !)

where

C ::= [] j C e j e C j let x be C in e j let x be e in C j *x:C:

A context C is an expression with one subexpression replaced by a hole, denoted []. The
expression C[e] results from placing an expression e in the hole of C; this operation may
involve capture of the free variables of e by C. An equational system may be constructed
as the congruence closure of v, but plays no r^ole for our work.

With an appropriate choice of ffi, the calculus satisfies Church-Rosser and Standardization properties; the proofs are variants of Plotkin's proofs for the *v-calculus [26]. By
Standardization, we know that an expression reduces to a value precisely if a reduction of
leftmost-outermost redexes outside of abstractions leads to a value. Based on this idea, we
can use the calculus to define an evaluation function [11]. Let 7\Gamma ! be the relation:

E[e] 7\Gamma ! E[e0] iff e \Gamma ! e0(7\Gamma !)
where

E ::= [] j E e j v E j let x be E in e:

The special contexts E are evaluation contexts: they ensure that the leftmost-outermost
reduction is the only applicable reduction in the entire program. Evaluating from left to
right in an application is consistent with Standard ML. Unlike with C contexts, there is
no possibility of capture when placing an expression in the hole of an evaluation context,
because the hole cannot appear inside a binding construct. Let !7\Gamma ! be the reflexive and
transitive closure of 7\Gamma !. Then the partial function eval is defined for closed expressions e
as:

eval(e) = v iff e !7\Gamma ! v:(eval)
It is easy to see that the decomposition of a program into a v-redex and an evaluation
context is unique. It follows that the stepping relation (7\Gamma !) is a function, and therefore
that eval is a function, too.

Syntactic Type Soundness 12
4.2 Typing
The type system is a deductive proof system that assigns types to expressions. The types
of Functional ML are:

o/ ::= '1 j : : : j 'n j ff j o/1 ! o/2(Types)
where '1; : : : ; 'n are ground types for basic constants (int, bool, real, etc.), and ff ranges over
a denumerable set of type variables. Type variables stand for some fixed but unknown type.
Function types, o/1 ! o/2, are right associative.

The polymorphic type system allows certain variables to be used with a set of different
types. For example, if the identity function *x:x is let-bound to the variable f , then f may
used as a function of type int ! int and applied to values of type int, or f may be used as
a function of type bool ! bool and applied to values of type bool. Type schemes represent
such sets of types (ff\Lambda  means zero or more distinct type variables):

oe ::= 8ff\Lambda :o/(TypeSchemes)
The free type variables F T V (oe) of a type or type scheme are defined as usual, where
8ff1 : : : ffn:o/ binds ff1 through ffn in o/ . We identify type schemes that differ only by a
consistent renaming of bound type variables, or by a reordering of the binding occurrences.
We also identify 8:o/ with o/ , so types may be regarded as type schemes with no bound type
variables.

A type scheme 8ff1 : : : ffn:o/ represents the set of types that may be obtained from o/ by
substituting for ff1 through ffn. This is formalized by the notion of generalization: a type
scheme oe generalizes a type o/ , written oe O/ o/ , if there is a substitution for the bound variables
of oe yielding o/ . A substitution S is a (partial) function from type variables to types. A
substitution may be applied to a type in the obvious way; we write So/ . Substitution on
type schemes respects bound type variables and is capture-avoiding. Generalization of a
type is defined as:

8ff1 : : : ffn:o/ 0 O/ o/ iff So/ 0 = o/ and Dom(S) = fff1; : : :; ffng for some S.(O/)
Generalization is extended to type schemes:

oe O/ oe0 iff whenever oe0 O/ o/ then oe O/ o/ :(O/)
Some examples are:

o/ O/ o/
8ff:ff ! ff O/ int ! int
8ff1ff2:ff1 ! ff2 O/ int ! bool

8ff:ff ! ff O/ ff2 ! ff2
8ff1ff2:ff1 ! ff2 O/ 8ff1:ff1 ! ff2

Generalization is a partial order on type schemes.

In order to assign types to open expressions, assumptions about the types of free variables are provided by type environments, denoted \Gamma . Type environments are finite maps
from variables to type schemes. The free type variables F T V (\Gamma ) of a type environment

Syntactic Type Soundness 13

\Gamma  . x : o/ if \Gamma (x) O/ o/(var)
\Gamma  . c : o/ if TypeOf (c) O/ o/(const)
\Gamma  . Y : ((o/1 ! o/2) ! o/1 ! o/2) ! o/1 ! o/2(Y)

\Gamma [x 7! o/1] . e : o/2
\Gamma  . *x:e : o/1 ! o/2(abs)
\Gamma  . e1 : o/1 ! o/2 \Gamma  . e2 : o/1

\Gamma  . e1 e2 : o/2(app)
\Gamma  . e1 : o/1 \Gamma [x 7! Close(o/1; \Gamma )] . e2 : o/2

\Gamma  . let x be e1 in e2 : o/2(let)

Close(o/; \Gamma ) = 8ff1 : : : ffn:o/ where fff1; : : :; ffng = F T V (o/ ) n F T V (\Gamma )

Figure 1: Typing rules for Functional ML

are the free type variables of the type schemes in its range. For stating and proving various lemmas, it is convenient to define substitution on type environments pointwise, i.e.,
S(fhx1; oe1i; : : : ; hxn; oenig) = fhx1; Soe1i; : : :; hxn; Soenig.

The function TypeOf : Const ! TypeSchemes associates a type scheme with every
constant. Since we have not precisely specified the set of constants, Functional ML is really
a class of languages parameterized by the set Const and the functions ffi and TypeOf . Just as
the Standardization and Church-Rosser properties restrict the admissible set of ffi functions,
a particular choice of Const, ffi, and TypeOf must satisfy a typability condition for type
soundness to hold. For every c, o/ , o/ 0, and v,

if TypeOf (c) O/ o/ 0 ! o/ and . v : o/ 0;
then ffi(c; v) is defined and . ffi(c; v) : o/:(ffi-typability)

This condition requires that ffi be defined for all constants of functional type and arguments
of matching type, and restricts the set of results that ffi may produce. This rules out, for
the moment, functional constants such as division that are not defined on all values of their
input type.

A type judgment \Gamma  . e : o/ for e an expression of Functional ML is the conclusion of a
deduction constructed according to the inference rules in Figure 1. The judgment \Gamma  . e : o/
is read "in type environment \Gamma , expression e has type o/ ". If the type environment in a
judgment is empty, we write . e : o/ . An expression e is a well-typed program if it is closed
and there is a judgment . e : o/ .

In this formulation of the typing rules, only one rule is applicable to an expression. Hence
if there is a deduction assigning an expression a specific type, that deduction is unique. This
permits proofs by induction on the structure of a deduction for a type judgment to proceed
by case analysis on the structure of the expression of the type judgment.

This type system has the important property that there is an algorithm W to determine
whether an expression has a type [20]. Given a type environment and an expression, the
algorithm computes a substitution and a type. The algorithm is sound [20] with respect to

Syntactic Type Soundness 14
the type system, meaning that it infers only valid typings.
Theorem (Soundness of W) [Milner] If (S; o/ ) = W(\Gamma ; e) succeeds then S\Gamma  . e : o/ .
The algorithm is also complete [5], meaning that if an expression has a valid typing, then
the algorithm will find a typing. Furthermore, the algorithm always terminates.

Theorem (Completeness of W) [Damas, Milner] If S1\Gamma  . e : o/1 then (S; o/ ) = W(\Gamma ; e)
succeeds and there exists S0 such that S0(S\Gamma ) = S1\Gamma  and S0Close(o/; S\Gamma ) O/ o/1. If W(\Gamma ; e)
does not succeed, then it stops with fail.

Proving completeness involves demonstrating that if an expression has a type, then it has
a principal type, of which all others are substitution instances.

Theorem (Principal Typing) If \Gamma  . e : o/1 then there exists o/ such that \Gamma  . e : o/ and
whenever \Gamma  . e : o/2 then Close(o/; \Gamma ) O/ o/2. The type o/ is principal for e in \Gamma .

The existence of a sound and complete algorithm establishes the decidability of the type
system. However, this is solely a property of the type system, and says nothing about the
relation of the type system to the semantics of the language.

4.3 Type Soundness
Our proof of type soundness rests upon the notion of subject reduction [4]. The subject
reduction property states that reductions preserve the type of expressions. Lemma 4.3
below extends subject reduction to Functional ML.

Subject reduction by itself is not sufficient for type soundness. In addition, we must
prove that programs containing type errors are not typable. Put differently, if an expression
e is irreducible due to some type error, say (/ 1 0), then the type system should not be able
to assign a type to the expression. Otherwise, a well-typed program could reduce to such
an expression without violating subject reduction, and still cause a type error to occur. We
call such expressions with type errors faulty expressions and prove that faulty expressions
cannot be typed.

Some obvious facts about deductions that we use with no more ado are:

(i ) if \Gamma  . C[e] : o/ then there exist \Gamma 0 and o/ 0 such that \Gamma 0 . e : o/ 0;
(ii ) if there are no \Gamma 0; o/ 0 such that \Gamma 0 . e : o/ 0, then there are no \Gamma ; o/ such that \Gamma  . C[e] : o/ .

These follow from the facts that (1) there is exactly one inference rule for each expression
form, and (2) each inference rule requires a proof for each subexpression of the expression
in its conclusion. Several facts about generalization follow from the definition of Close:

(i ) if oe0 O/ oe then Close(o/1; \Gamma [x 7! oe0]) O/ Close(o/1; \Gamma [x 7! oe]);
(ii ) if x =2 Dom(\Gamma ) then Close(o/1; \Gamma ) O/ Close(o/1; \Gamma [x 7! oe]).

The following lemma states that extra variables in the type environment \Gamma  of a judgment
\Gamma  . e : o/ that are not free in the expression e may be ignored.

Syntactic Type Soundness 15
Lemma 4.1 If \Gamma (x) = \Gamma 0(x) for all x 2 F V (e), then \Gamma  . e : o/ iff \Gamma 0 . e : o/ .

A key lemma that we use in the proof of Subject Reduction for Functional ML and its
extensions is the Replacement Lemma, adapted from Hindley and Seldin [16: page 181].
This allows the replacement of one of the subexpressions of a typable expression with another
subexpression of the same type, without disturbing the type of the overall expression.

Lemma 4.2 (Replacement) If :

(i ) D is a deduction concluding \Gamma  . C[e1] : o/ ,
(ii ) D1 is a subdeduction of D concluding \Gamma 0 . e1 : o/ 0,
(iii ) D1 occurs in D in the position corresponding to the hole ([]) in C, and
(iv ) \Gamma 0 . e2 : o/ 0,

then \Gamma  . C[e2] : o/ .

Proof. We think of deductions as trees with the conclusion at the root. Let D2 be the
deduction concluding \Gamma 0 . e2 : o/ 0. Cut the subtree D1 out of D and replace it with D2.
Replace all relevant occurrences of e1 in the resulting tree with e2. Then the resulting tree
is a valid deduction concluding \Gamma  . C[e2] : o/ , as may be shown by induction on the height
of the tree [16: page 181].

Subject reduction for Functional ML states that the reductions of v preserve type.

Main Lemma 4.3 (Subject Reduction) If \Gamma  . e1 : o/ and e1 \Gamma ! e2 then \Gamma  . e2 : o/ .
Proof. The proof proceeds by case analysis according to the reduction e1 \Gamma ! e2.

Case c v \Gamma ! ffi(c; v). Then \Gamma  . c : o/ 0 ! o/ and \Gamma  . v : o/ 0 follow from \Gamma  . c v : o/ by app.

Hence \Gamma  . ffi(c; v) : o/ by the ffi-typability condition.

Case (*x:e) v \Gamma ! e[x 7! v]. From \Gamma  . (*x:e) v : o/ we have \Gamma  . v : o/ 0 and \Gamma  . *x:e : o/ 0 ! o/

by app. From the latter, \Gamma [x 7! o/ 0] . e : o/ follows by abs. Hence \Gamma  . e[x 7! v] : o/ by
Lemma 4.4.

Case let x be v in e \Gamma ! e[x 7! v]. From \Gamma  . let x be v in e : o/ we have \Gamma  . v : o/ 0

and \Gamma [x 7! Close(o/ 0; \Gamma )] . e : o/ by let. As Close(o/ 0; \Gamma ) = 8ff1 : : : ffn:o/ 0 where
fff1; : : : ; ffng = F T V (o/ 0) n F T V (\Gamma ), we have \Gamma  . e[x 7! v] : o/ by Lemma 4.4.

Case Y v \Gamma ! v (*x:(Y v) x). From \Gamma  . Y v : o/ , where o/ = o/1 ! o/2, by Y and app

\Gamma  . v : (o/1 ! o/2) ! o/1 ! o/2:(1)
Then from \Gamma  . Y v : o/ ,

\Gamma [x 7! o/1] . Y v : o/1 ! o/2 by Lemma 4.1,
\Gamma [x 7! o/1] . (Y v) x : o/2 by app,
\Gamma  . *x:(Y v) x : o/1 ! o/2 by abs,
\Gamma  . v (*x:(Y v) x) : o/1 ! o/2 by app with (1).

Syntactic Type Soundness 16
This completes the essence of the proof. It remains to establish several lemmas.

A Substitution Lemma is the key to showing type preservation for reductions involving
substitution.

Lemma 4.4 (Substitution) If \Gamma [x 7! 8ff1 : : : ffn:o/ ] . e : o/ 0 and x =2 Dom(\Gamma ) and \Gamma  . v : o/
and fff1; : : :; ffng " F T V (\Gamma ) = ; then \Gamma  . e[x 7! v] : o/ 0.

Proof. We proceed by induction on the length of the proof of \Gamma [x 7! 8ff1 : : : ffn:o/ ] . e : o/ 0,
and case analysis on the last step.

Case e = c. Then TypeOf (c) O/ o/ 0 by const, and thus \Gamma  . c : o/ 0 by const. Then

\Gamma  . c[x 7! v] : o/ 0 since c[x 7! v] = c.

Case e = x0. If x0 6= x, then \Gamma x0 O/ o/ 0 by var, and \Gamma  . x0 : o/ 0 again by var. Hence

\Gamma  . x0[x 7! v] : o/ 0 since x0[x 7! v] = x0.

If x0 = x, then by var

\Gamma [x 7! 8ff1 : : : ffn:o/ ](x) O/ o/ 0
i.e. 8ff1 : : : ffn:o/ O/ o/ 0;

i.e. we can find a substitution S with domain fff1; : : :; ffng such that So/ = o/ 0. Next,
we have S\Gamma  . v : So/ by Lemma 4.5 since \Gamma  . v : o/ , and therefore S\Gamma  . v : o/ 0. But
Dom(S) " F T V (\Gamma ) = ;, so S\Gamma  = \Gamma . Also x[x 7! v] = v, hence \Gamma  . x[x 7! v] : o/ 0.

Case e = *x0:e1. By abs, it follows from the assumption \Gamma [x 7! 8ff1 : : : ffn:o/ ] . *x0:e1 : o/ 0

that o/ 0 = o/1 ! o/2, and

\Gamma [x 7! 8ff1 : : : ffn:o/ ][x0 7! o/1] . e1 : o/2
i.e. \Gamma [x0 7! o/1][x 7! 8ff1 : : : ffn:o/ ] . e1 : o/2:

Choose a substitution S : fff1; : : : ; ffng ! fff01; : : : ; ff0ng such that ff01; : : : ; ff0n,
ff1; : : : ; ffn, and F T V (\Gamma ) are all distinct. Then

\Gamma [x0 7! So/1][x 7! 8ff1 : : : ffn:o/ ] . e1 : So/2 by Lemma 4.5,(2)
\Gamma [x0 7! So/1] . v : o/ by Lemma 4.1, and(3)
F T V (\Gamma [x0 7! So/1]) " fff1; : : : ; ffng = ; by the choice of S.(4)

Thus, \Gamma [x0 7! So/1] . e1[x 7! v] : So/2 by the inductive hypothesis with (2), (3), and
(4). Since S is a bijection, S\Gamma 1 exists, hence

S\Gamma 1(\Gamma [x0 7! So/1]) . e1[x 7! v] : S\Gamma 1(So/2) by Lemma 4.5,
i.e. \Gamma [x0 7! o/1] . e1[x 7! v] : o/2:

But then

\Gamma  . *x0:e1[x 7! v] : o/1 ! o/2 by abs,
i.e. \Gamma  . (*x0:e1)[x 7! v] : o/1 ! o/2:

Syntactic Type Soundness 17

Case e = (e1 e2). From \Gamma [x 7! 8ff1 : : : ffn:o/ ] . (e1 e2) : o/ 0 by the first premise of app

\Gamma [x 7! 8ff1 : : : ffn:o/ ] . e1 : o/1 ! o/ 0
\Gamma  . e1[x 7! v] : o/1 ! o/ 0 by ind. hyp.(5)

By the second premise of app

\Gamma [x 7! 8ff1 : : : ffn:o/ ] . e2 : o/1
\Gamma  . e2[x 7! v] : o/1 by ind. hyp.(6)

Then by app with (5) and (6)

\Gamma  . (e1[x 7! v] e2[x 7! v]) : o/ 0
i.e. \Gamma  . (e1 e2)[x 7! v] : o/ 0:

Case e = let x0 be e1 in e2. By the first premise of let

\Gamma [x 7! 8ff1 : : : ffn:o/ ] . e1 : o/1
\Gamma  . e1[x 7! v] : o/1 by ind. hyp.(7)

By the second premise of let

\Gamma [x 7! 8ff1 : : : ffn:o/ ][x0 7! Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . e2 : o/ 0
i.e. \Gamma [x0 7! Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])][x 7! 8ff1 : : : ffn:o/ ] . e2 : o/ 0:(8)

Since \Gamma  . v : o/

\Gamma [x0 7! Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . v : o/ by Lemma 4.1.(9)
Now

fff1; : : : ; ffng " F T V (\Gamma [x0 7! Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])])
` fff1; : : : ; ffng " (F T V (\Gamma ) [ F T V (Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])))
= fff1; : : : ; ffng " F T V (Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ]))
= fff1; : : : ; ffng " (F T V (o/1) n (F T V (o/1) n F T V (\Gamma [x 7! 8ff1 : : : ffn:o/ ])))
= fff1; : : : ; ffng " F T V (o/1) " F T V (\Gamma [x 7! 8ff1 : : : ffn:o/ ])
` fff1; : : : ; ffng " (F T V (\Gamma ) [ F T V (8ff1 : : : ffn:o/ ))
= fff1; : : : ; ffng " F T V (8ff1 : : : ffn:o/ )
= fff1; : : : ; ffng " (F T V (o/ ) n fff1; : : : ; ffng)
= ;

so by the inductive hypothesis with (8) and (9)

\Gamma [x0 7! Close(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . e2[x 7! v] : o/ 0
\Gamma [x0 7! Close(o/1; \Gamma )] . e2[x 7! v] : o/ 0 by Lemma 4.6,
\Gamma  . let x0 be v1[x 7! v] in e2[x 7! v] : o/ 0 by let with (7),
i.e. \Gamma  . (let x0 be v1 in e2)[x 7! v] : o/ 0:

Lemma 4.5 establishes that typing is stable under substitution.

Syntactic Type Soundness 18
Lemma 4.5 If \Gamma  . e : o/ and S is a substitution then S\Gamma  . e : So/ .
Proof. The proof proceeds by induction on the length of the proof of \Gamma  . e : o/ and case
analysis on the last step. The proof is an adaptation of Tofte's proof of a similar lemma [37:
lemma 4.2].

Finally, Lemma 4.6 shows that generalizing the type of a variable in the type environment
has no impact on the conclusion of a deduction.

Lemma 4.6 If \Gamma [x 7! oe] . e : o/ and oe0 O/ oe then \Gamma [x 7! oe0] . e : o/ .
Proof. The proof proceeds by induction on the length of the proof of \Gamma [x 7! oe] . e : o/ and
case analysis on the last step. The proof is an adaptation of Damas and Milner's proof of
a similar lemma [5: lemma 1]. The only interesting case is the case for let-expressions.

Case e = let x0 be e1 in e2. By the first premise of let

\Gamma [x 7! oe] . e1 : o/1
\Gamma [x 7! oe0] . e1 : o/1 by ind. hyp.(10)

By the second premise of let

\Gamma [x 7! oe][x0 7! Close(o/1; \Gamma [x 7! oe])] . e2 : o/
\Gamma [x 7! oe0][x0 7! Close(o/1; \Gamma [x 7! oe])] . e2 : o/ by ind. hyp.
\Gamma [x 7! oe0][x0 7! Close(o/1; \Gamma [x 7! oe0])] . e2 : o/ by ind. hyp.(11)

Then \Gamma [x 7! oe0] . let x0 be e1 in e2 : o/ by let with (10) and (11).
A corollary of Subject Reduction is that standard reduction steps preserve type.
Corollary 4.7 If \Gamma  . e1 : o/ and e1 !7\Gamma ! e2 then \Gamma  . e2 : o/ .
Proof. First, if e1 7\Gamma ! e2 then e1 = E[e] and e2 = E[e0] and e \Gamma ! e0, so \Gamma  . e2 : o/ by the
Replacement Lemma. Then the result follows by induction on the length of the reduction
sequence e1 !7\Gamma ! e2.

Subject reduction ensures that if we start with a typable expression, we cannot reach
an untypable expression through any sequence of reductions. This by itself, however, does
not yield type soundness. Subject reduction simply ensures that any properties implied by
typability are preserved by reduction. The critical property we seek is that evaluation of a
typable expression cannot get stuck.

Definition 4.8 (Stuck Expressions) The evaluation of an expression e is stuck if e is
not a value and there is no e0 such that e 7\Gamma ! e0.

Of course, whether an expression eventually reduces to a stuck expression is not a
decidable property. We approximate the set of expressions that become stuck with a set of
faulty expressions.

Syntactic Type Soundness 19
Definition 4.9 (Faulty Expressions) The faulty expressions of Functional ML are the
expressions containing a subexpression (c v) where ffi(c; v) is undefined.

The idea is that any faulty expression may become stuck, i.e., the property "reduces to
a faulty expression" is a conservative approximation to "reduces to an expression that is
stuck". Thus the faulty expressions are a superset of the stuck expressions. For example,
the expression ((*y.2) (*x.+ 1 true)) is faulty because of the subexpression (+ 1 true), but
is not stuck because it reduces to 2.

The behavior of evaluation is summarized by the following lemma. Let e * mean that e
diverges, i.e., e 7\Gamma ! e0 for some e0, and for all e0 such that e !7\Gamma ! e0, there exists e00 such that
e0 7\Gamma ! e00.

Lemma 4.10 (Uniform Evaluation) For closed e, if there is no e0 such that e !7\Gamma ! e0 and
e0 is faulty, then either e * or e !7\Gamma ! v.

Proof. By induction on the length of the reduction sequence, we need only show that either
e is faulty, e 7\Gamma ! e0 and e0 is closed, or e is a value. From the definition of 7\Gamma !, e 7\Gamma ! e0 iff
e = E[e1], e0 = E[e01], and e1 \Gamma ! e01. (Recall that E ::= [] j E e j v E j let x be E in e.) We
proceed by induction on the structure of e.

Case e = c, Y, or *x:e. Then e is a value.
Case e = x. Since e is closed, this case cannot occur.
Case e = let x be e1 in e2. By the inductive hypothesis with e1, there are three cases to

consider. If e1 is faulty, then let x be e1 in e2 is faulty. If e1 = E1[e0] and e0 \Gamma ! e00
then e = E[e0] where E = let x be E1 in e2; thus e 7\Gamma ! E[e00]. Otherwise, if e1 is a
value, then let x be e1 in e2 7\Gamma ! e2[x 7! e1].

Case e = (e1 e2). By the inductive hypothesis with e1, there are three cases to consider.

If e1 is faulty, then (e1 e2) is faulty. If e1 = E1[e0] and e0 \Gamma ! e00 then e = E[e0] where
E = (E1 e2); thus e 7\Gamma ! E[e00]. Otherwise, e1 is a value. By the inductive hypothesis
with e2, there are three subcases to consider. If e2 is faulty, then (e1 e2) is faulty.
If e2 = E2[e0] and e0 \Gamma ! e00 then e = E[e0] where E = (e1 E2); thus e 7\Gamma ! E[e00].
Otherwise, both e1 and e2 are values, and the possibilities can be summarized as
follows:

e e21 c *x:e Y x

c 7\Gamma ! orfaulty 7\Gamma ! orfaulty 7\Gamma ! orfaulty \Theta 
*x:e 7\Gamma ! 7\Gamma ! 7\Gamma ! \Theta 

Y 7\Gamma ! 7\Gamma ! 7\Gamma ! \Theta 

x \Theta  \Theta  \Theta  \Theta 

Cases marked with \Theta  cannot occur because the expression is not closed. Cases marked
with 7\Gamma ! indicate that the combination reduces with E = [].

To relate faulty expressions and typability, we show that no faulty expression is typable.

Syntactic Type Soundness 20
Main Lemma 4.11 (Faulty Expressions are Untypable) If e is faulty, there are no
\Gamma ; o/ such that \Gamma  . e : o/ .

Proof. It suffices to show that the subexpressions of e that cause e to be faulty are untypable. In general, we proceed by case analysis according to the form of the subexpression,
but for Functional ML there is only one case.

Suppose (c v) is faulty and \Gamma  . c v : o/ . By app, \Gamma  . c : o/ 0 ! o/ and \Gamma  . v : o/ 0. Then by
the ffi-typability condition, ffi(c; v) is defined, but this contradicts the assumption that (c v)
is faulty.

Since the faulty expressions are untypable and we have type preservation, the property
"does not reduce to a faulty expression" is implied by typability.4

Theorem 4.12 (Syntactic Soundness) If . e : o/ then either e * or e !7\Gamma ! v and . v : o/ .
Proof. By Uniform Evaluation, either e !7\Gamma ! e0 and e0 is faulty, or e *, or e !7\Gamma ! v. Since
. e : o/ , Subject Reduction implies . v : o/ and . e0 : o/ . Suppose e !7\Gamma ! e0 and e0 is faulty.
Since faulty expressions are untypable, . e0 : o/ is a contradiction, therefore this case cannot
occur. Hence either e * or e !7\Gamma ! v and . v : o/ .

To state strong and weak soundness theorems, we must have a definition of evaluation
that differentiates between programs that diverge and those that cause type errors. Let
answers (a) be values or the special result wrong, and define eval 0 as:

eval0(e) = ( wrong if e !7\Gamma ! e

0 and e0 is faulty;

v if e !7\Gamma ! v:(eval
0)

Programs that cause a type error return the special answer wrong. Strong and weak
soundness are now corollaries of Syntactic Soundness.

Theorem 4.13 (Strong Soundness) If . e : o/ and eval 0(e) = a then . a : o/ .
Theorem 4.14 (Weak soundness) If . e : o/ then eval0(e) 6= wrong.

5 References and Exceptions
Besides functional facilities, first-class references and exceptions are the most important
core programming facilities of Standard ML and similar languages. In this section we
consider several extensions to Functional ML. The first subsection deals with Reference
ML, an extension of Functional ML with references. It uses our previous work on a calculus
of state, *v-S [12, 14], and in particular its cell-oriented variant [3]. The second subsection
addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified
version of our control calculus, *v-C [13, 14], especially its fragment with prompts [9]. The
final subsection presents Core ML, which includes both references and exceptions.

4Type preservation by itself does not guarantee type soundness. Consider the (trivial) type system where
every type is a subtype of every other type. Type preservation holds since every expression can be assigned
every type. However, the system does not prevent type errors, because it rejects no expressions.

Syntactic Type Soundness 21
5.1 Reference ML
Extending the *v-calculus to a calculus of functions and references requires extending the
syntax with a new kind of expression and several new values (underlined):

e ::= v j e1 e2 j let x be e1 in e2 j ae`:e(Expressions)
v ::= c j x j Y j *x:e j ref j ! j := j := v(Values)

` ::= f hx; vi g\Lambda 

The expression aehx1; v1i : : :hxn; vni:e binds x1; : : : ; xn in v1; : : : ; vn and e. Above, ` represents a finite function from variables to values, i.e., we treat ` as a set of pairs whose first
components are distinct. We also identify all ae-expressions that differ only by a consistent
renaming of bound variables.

The values ref, !, and := are the familiar operations of ML.5 The application of ref to
a value creates a reference cell containing that value. The application of ! to a cell returns
the value contained in that cell. The binary assignment operator := evaluates both its
operands, the first of which must evaluate to a cell, and assigns the value of the second
operand to that cell. Since all operations are curried, the application of the assignment
operator to a variable is a value. Specifically, the expression (:= c) may be thought of as
a capability to assign to the cell c. The ae-expression is semantically an abbreviation of a
let-expression:

aehx1; v1i : : : hxn; vni:e
j let x1 be ref u1 in: : :

let xn be ref un in

(*y1 : : : ynyn+1: yn+1) (:= x1 v1) : : :(:= xn vn) e

where u1; : : : ; un are arbitrary values (of the right type). In order to simplify the semantics,
we do not treat it as such [14]. Intuitively, a ae-expression plays the r^ole of a store fragment
during the reduction of a program with imperative assignment statements. A reference cell
is represented as a variable; the pair hx; vi in a ae-expression indicates that reference cell x
contains value v.

5.1.1 Semantics
In addition to the reductions for v, the reductions for references are:6

ref v \Gamma ! aehx; vi:x(ref )
ae`hx; vi:R[! x] \Gamma ! ae`hx; vi:R[v](deref )
ae`hx; v1i:R[:= x v2] \Gamma ! ae`hx; v2i:R[v2](assign)

ae`1:ae`2:e \Gamma ! ae`1`2:e(aemerge )

R[ae`:e] \Gamma ! ae`:R[e] if R 6= [](aelift)
5Introducing ref, !, and := as values rather than special forms like (ref e), (! e), and (:= e

1 e2) simplifies

the proofs of several lemmas that proceed by induction on the structure of expressions. The latter approach

requires duplicating much of the work of the case for applications.

6This semantics is due to Crank and Felleisen [3], which was derived from Felleisen and Hieb's work [14].

A similar definition of evaluation for dealing with state using rewriting techniques also appears in the work
of Mason and Talcott [19].

Syntactic Type Soundness 22
By the variable conventions, x is not free in v in the ref reduction; the domains of `1 and
`2 are disjoint in aemerge ; and the free variables of R are disjoint from the domain of ` in
aelift . We refer to the union of these five reductions as r. The notions of reduction r and v
(adapted mutatis mutandis to the full syntax) form the basis for a calculus of functions and
references. We refer to the union as vr, and write

vr\Gamma ! for a reduction in vr. The extended

notion of reduction gives rise to a system of reductions and equations with the extension of
contexts to:

C ::= [] j C e j e C j let x be C in e j let x be e in C j *x:C j ae`:C j ae`hx; Ci:e:
The calculus satisfies the same basic properties as the *v-calculus [3].

The definition of r relies on a set of R contexts:

R ::= [] j R e j v R j let x be R in e:
The use of R contexts in the new reductions reflects the additional sequencing restrictions
that the introduction of side-effects in a programming language requires for the semantics
to be deterministic. In particular, the creation, the dereferencing, and the updating operations on a reference cell must be ordered in a linear fashion, which implies some further
ordering among the operations on distinct cells. The R contexts build this minimal order of
evaluation into those reductions that refer to reference cells and their operations; following
ML, we choose to perform operations from left to right.

For r reductions, a cell is represented by an ordinary variable appearing in the domain of
a store fragment `. When a program creates a new cell via ref, the ref reduction introduces
a ae-expression that records the cell's current value. The dereference operator ! selects a
cell's value from the closest ae-expression (relative to R contexts). If the appropriate cell
is bound in a ae-expression that is not the closest one, the intervening ae-expressions must
first be merged with the outer one. This is accomplished with aelift and aemerge reductions,
which lift a partial store out of R contexts, and merge it with outer stores (by the variable
convention, cells are renamed appropriately to avoid collisions). An assignment replaces a
cell's current value in the closest ae-expression, after performing all necessary lift and merge
steps, and returns the assigned value.

For example, consider the following expression:

((let x be ref (*x.+ !x 2) in := x (*x.+ !x 3))

(let x be ref 2 in (*z.x)(:= x 4)))

In this expression, the two assignments can happen in an arbitrary order, and the system of
reductions admits both possibilities. Both assignments, however, must happen before the
outermost application is reduced. Figure 2 gives one possible reduction sequence.

The above calculus only constrains the relative ordering of ref , deref , and assign reductions. By defining extended evaluation contexts:

E ::= [] j E e j v E j let x be E in e j ae`:E
we fix the order in which reductions in v and ref , deref , and assign may be applied. The
stepping function

vr7\Gamma ! is defined as before. To show that vr7\Gamma ! is a function requires a simple

Syntactic Type Soundness 23

((let x be ref (*x.+ !x 2) in := x (*x.+ !x 3))

(let x be ref 2 in (*z.x)(:= x 4)))
!\Gamma ! (aehx; *x.+ !x 2i.:= x (*x.+ !x 3)) (aehx; 2i.(*z.x)(:= x 4)) 2 \Theta  ref ; aelift; let
!\Gamma ! (aehx; *x.+ !x 3i.*x.+ !x 3) (aehx; 2i.(*z.x)(:= x 4)) assign
!\Gamma ! (aehx; *x.+ !x 3i.*x.+ !x 3) (aehx; 4i.x) assign; fiv
!\Gamma ! aehx; *x.+ !x 3ihy; 4i.(*x.+ !x 3) y 2 \Theta  aelift; aemerge
!\Gamma ! aehx; *x.+ !x 3ihy; 4i.+ !y 3 fiv
!\Gamma ! aehx; *x.+ !x 3ihy; 4i.+ 4 3 deref
!\Gamma ! aehx; *x.+ !x 3ihy; 4i.7 ffi

Figure 2: Reducing a program with side-effects

diamond theorem, since the order in which aelift and aemerge reductions happen is not fixed,
and the context R in the aelift rule is selected in a nondeterministic fashion. The answers
returned by evaluation of a program are no longer simply closed values, since an answer
may be a reference cell. Answers are values or ae-expressions enclosing values:

a ::= v j ae`:v:(answers)
Based on these definitions, evaluation may be defined like before:

eval vr(e) = a iff e

vr!7\Gamma ! a:(eval

vr)

5.1.2 Typing
Typing reference cells in the presence of polymorphism is not straightforward, as the obvious
solution is unsound [6, 36, 37]. To assign types to reference cells, we extend the set of types
with an additional constructor:

o/ ::= '1 j : : : j 'n j ff j o/1 ! o/2 j o/ ref
The type o/ ref is the type of cells containing a value of type o/ .

The obvious types for the three operators are indicated by their semantics:

\Gamma  . ref : o/ ! o/ ref
\Gamma  . ! : o/ ref ! o/
\Gamma  . := : o/ ref ! o/ ! o/

For example, the first argument of the assignment operator (:=) must be a reference cell.
The second argument must be a value matching the type of the cell. The result is of the
same type as the second argument since our assignment operator returns the value assigned.
The following expression illustrates why this typing is unsound:

let f be ref (*y.y) in

(*z. ! f true) (:= f (*n.+ 1 n))

Syntactic Type Soundness 24
If the type of the reference bound to x is generalized to 8ff:(ff ! ff) ref , then the reference
cell can be treated as having type (int ! int) ref for the assignment, and as having type
(bool ! bool)ref for the dereference, hence this expression is typable as bool. But evaluating
this expression leads to a type error:

let f be ref (*y.y) in

(*z. ! f true) (:= f (*n.+ 1 n))

!\Gamma ! let f be aehx; *y.yi: x in

(*z. ! f true) (:= f (*n.+ 1 n))

!\Gamma ! aehx; *y.yi:

(*z. ! x true) (:= x (*n.+ 1 n))

!\Gamma ! aehx; *n.+ 1 ni: ! x true
!\Gamma ! aehx; *n.+ 1 ni: + 1 true

As Tofte [36, 37] points out, the problem with the obvious typing is the generalization of
type variables that appear free in the type of a value in the store.

The central idea of Tofte's solution is to ensure that the only storable values are those
that will not be used polymorphically at run-time. To this end, type variables are partitioned into imperative and applicative variables: the former set of type variables is named
ImpTypeVar; the latter AppTypeVar. Types are classified accordingly: an imperative type
cannot contain any applicative type variables. Only values of imperative type can be stored.
When the type of a value is generalized in a let-expression, type variables that might appear
in the types of values in the store are required to be imperative, and are not generalized.

The notion of generalization requires appropriate adaptation. We still have:

8ff1 : : : ffn:o/ 0 O/ o/ if So/ 0 = o/ and Dom(S) = fff1; : : : ; ffng for some S,(O/)
but the substitution S is required to map imperative type variables to imperative types.
Thus, if ff is an imperative type variable, we have:

8ff:ff ! ff O/ int ! int
and 8ff:ff ! ff O/ ff ! ff
but not 8ff:ff ! ff O/ ff ! ff

since ff is potentially applicative (the meta-variable ff still represents any type variable--
imperative or applicative).

Like all other techniques for typing references, Tofte's system requires modifying the
typing rule for let-expressions. The let rule is split into two rules, according to whether or
not the right-hand side of the declaration is a value. Figure 3 gives the new rules. The
second rule does not generalize over imperative type variables, and thus will not generalize
the type of a value in the store. However, if the expression bound by a let-expression is a
value, as in the first rule, then its evaluation cannot create a new cell, so generalization of
imperative type variables in its type cannot generalize the type of a value in the store. Tofte
uses the terminology expansive and non-expansive to denote this syntactic classification of
expressions into those that may create new references, and those that definitely do not
create new references. Like Tofte, we classify only values as non-expansive, but a stronger
type system is possible by classifying more expressions as non-expansive [36, 37].

Syntactic Type Soundness 25

\Gamma  . v : o/1 \Gamma [x 7! Close(o/1; \Gamma )] . e : o/2

\Gamma  . let x be v in e : o/2(let
v)

\Gamma  . e1 : o/1 \Gamma [x 7! AppClose(o/1; \Gamma )] . e2 : o/2 e1 =2 Values

\Gamma  . let x be e1 in e2 : o/2(let
e)

Close(o/; \Gamma ) = 8ff1 : : : ffn:o/ where fff1; : : :; ffng = F T V (o/ ) n F T V (\Gamma )
AppClose(o/; \Gamma ) = 8ff1 : : : ffn:o/ where fff1; : : : ; ffng = (F T V (o/ ) n F T V (\Gamma )) " AppTypeVar:

Figure 3: Modified let-expression typing rules

\Gamma  . ref : o/ ! o/ ref if o/ is imperative(ref)

\Gamma  . ! : o/ ref ! o/(deref)
\Gamma  . := : (o/ ref ! o/ ! o/ )(assign)

\Gamma [x1 7! o/1 ref ] : : : [xn 7! o/n ref ] . e : o/
\Gamma [x1 7! o/1 ref ] : : : [xn 7! o/n ref ] . vi : o/i o/i is imperative 1 ^ i ^ n

\Gamma  . aehx1; v1i : : : hxn; vni:e : o/(rho)

Figure 4: Additional typing rules for references

Figure 4 gives four additional typing rules for reference cells. The typing rules for ref
and ae-expressions ensure that any value placed in the store has an imperative type. The
typing rules for ! and := do not need to be explicitly constrained, since their use is implicitly
constrained by the type of a value already in the store.

In addition to the restrictions placed on the typing of constants by Functional ML,
we also require that there be no constants of reference type (o/ ref ). This ensures that all
values of reference type are in fact reference cells, and can be assigned or dereferenced. This
restriction is used in the proof of Theorem 5.6.

The new system assigns the same types as the old one to Functional ML expressions.

Let

f. indicate provability in the old, functional system, and let r. indicate provability in the

system with references.
Proposition 5.1 If e is an expression in Functional ML, and \Gamma  and o/ are purely applicative, then \Gamma 

f. e : o/ iff \Gamma  r. e : o/ .

Since Functional ML expressions do not contain ref or ae-expressions, no imperative type
variables need be chosen to type an expression, and Close and AppClose yield the same
type scheme for applicative types.

5.1.3 Type Soundness for References
To prove type preservation for the extended language, we must show that the notion of
reduction v extended to the new syntax preserves types, and that the reductions of r

Syntactic Type Soundness 26
preserve types. Showing that the extended v preserves types amounts to re-proving the
various lemmas used in section 4.3 for the extended system. In general, we refer to the
extension of Lemma 4:n as Lemma 4:n+. Showing that r preserves types involves adding a
case for each reduction to the proof of Subject Reduction. The cases involving R contexts
use the fact that:

if \Gamma  . R[e] : o/ then \Gamma  . e : o/ 0:

The type environment \Gamma  is the same in both the antecedent and consequent since R contexts
do not bind variables.

Main Lemma 5.2 (Subject Reduction for vr) If \Gamma 

r. e

1 : o/ and e1

vr\Gamma ! e

2 then

\Gamma  r. e2 : o/ .

Proof. The cases for the reductions of v are the same as before, using an appropriately
extended Replacement Lemma and a similarly extended Lemma 4.1.

Case ref v \Gamma ! aehx; vi:x. From \Gamma  . ref v : o/ , where o/ = o/ 0 ref and o/ 0 is imperative,

\Gamma  . v : o/ 0 by ref and app, and \Gamma [x 7! o/ 0 ref ] . v : o/ 0 by Lemma 4:1+. Since
\Gamma [x 7! o/ 0 ref ] . x : o/ 0 ref by var, \Gamma  . aehx; vi:x : o/ 0 ref by rho.

In order to satisfy the imperative restriction on the typing of ae-expressions, ref applications must yield values of imperative type, as ensured by ref.

Case ae`hx; vi:R[! x] \Gamma ! ae`hx; vi:R[v]. From \Gamma  . ae`hx; vi:R[! x] : o/ by rho

\Gamma 0 . v : o/ 0(12)
where o/ 0 is imperative and \Gamma 0x = o/ 0ref . Thus \Gamma 0 . x : o/ 0ref , hence \Gamma 0 . ! x : o/ 0 by deref
and app. With (12) by the Replacement+ Lemma, we have \Gamma  . ae`hx; vi:R[v] : o/ .

Case ae`hx; v1i:R[:= x v2] \Gamma ! ae`hx; v2i:R[v2]. From \Gamma  . ae`hx; v1i:R[:= x v2] : o/ by rho

\Gamma 0 . v1 : o/ 0(13)
where o/ 0 is imperative and \Gamma 0x = o/ 0 ref . Thus \Gamma 0 . x : o/ 0 ref , and by assign and app

\Gamma 0 . := x : o/ 0 ! o/ 0
\Gamma 0 . := x v2 : o/ 0 and \Gamma 0 . v2 : o/ 0 by app.

With (13) and using the Replacement+ Lemma twice, we have \Gamma  . ae`hx; v2i:R[v2] : o/ .
Case ae`1:ae`2:e \Gamma ! ae`1`2:e. From \Gamma  . ae`1:ae`2:e : o/ by rho

\Gamma 0 . ae`2:e : o/ and \Gamma 0 . vi : o/i(14)
where `1 = hx1; v1i : : : hxn; vni, \Gamma 0 = \Gamma [x1 7! o/1 ref ] : : : [xn 7! o/n ref ], and 1 ^ i ^ n.
Again by rho

\Gamma 00 . e : o/ and \Gamma 00 . v0j : o/ 0j(15)
where `2 = hx01; v01i : : : hx0n; v0mi, \Gamma 00 = \Gamma 0[x01 7! o/ 01ref ] : : : [x0m 7! o/ 0mref ], and 1 ^ j ^ m.
Since Dom(`1) " Dom(`2) = ; (by the variable conventions),

\Gamma 00 . vi : o/i for 1 ^ i ^ n by (14),
\Gamma  . ae`1`2:e : o/ by rho with (15).

Syntactic Type Soundness 27

Case R[ae`:e] \Gamma ! ae`:R[e]. We have \Gamma  . R[ae`:e] : o/ , and proceed by induction on the

structure of R to show \Gamma  . ae`:R[e] : o/ .

Case R = []. Then R[ae`:e] = ae`:R[e].
Case R = (R0 e0). Then \Gamma  . (R0[ae`:e] e0) : o/ , and by app

\Gamma  . R0[ae`:e] : o/ 0 ! o/(16)
and \Gamma  . e0 : o/ 0:(17)
Then \Gamma  . ae`:R0[e] : o/ 0 ! o/ by ind. hyp. with (16), and by rho

\Gamma [xi 7! o/i ref ] . vi : o/i(18)
and \Gamma [xi 7! o/i ref ] . R0[e] : o/ 0 ! o/(19)
where ` = hx1; v1i : : :hxn; vni and 1 ^ i ^ n. Since x1; : : :; xn =2 F V (e0),

\Gamma [xi 7! o/i ref ] . e0 : o/ 0 by Lemma 4:1+ with (17),
\Gamma [xi 7! o/i ref ] . R0[e] e0 : o/ by app with (19),
\Gamma  . ae`:R0[e] e0 : o/ by rho with (18).

Case R = (v R0). Similar to the previous case.
Case R = let x be R0 in e0. Then \Gamma  . let x be R0[ae`:e] in e0 : o/ , and by lete

\Gamma  . R0[ae`:e] : o/ 0(20)
and \Gamma [x 7! AppClose(o/ 0; \Gamma )] . e0 : o/:(21)

Then \Gamma  . ae`:R0[e] : o/ 0 by ind. hyp. with (20), and by rho

\Gamma [xi 7! o/i ref ] . vi : o/i(22)
and \Gamma [xi 7! o/i ref ] . R0[e] : o/ 0(23)

where ` = hx1; v1i : : : hxn; vni and each o/i is imperative for 1 ^ i ^ n. Since
x1; : : : ; xn =2 F V (e0),

\Gamma [x 7! AppClose(o/ 0; \Gamma )][xi 7! o/i ref ] . e0 : o/ by Lemma 4:1+ with (21)
i.e. \Gamma [xi 7! o/i ref ][x 7! AppClose(o/ 0; \Gamma )] . e0 : o/:

But each o/i is imperative, due to the restriction on the typing of ae-expressions,
hence

AppClose(o/ 0; \Gamma ) = AppClose(o/ 0; \Gamma [xi 7! o/i ref ]):

If R0[e] is expansive, then

\Gamma [xi 7! o/i ref ][x 7! AppClose(o/ 0; \Gamma [xi 7! o/i ref ])] . e0 : o/
\Gamma [xi 7! o/i ref ] . let x be R0[e] in e0 : o/ by lete with (23)
\Gamma  . ae`:let x be R0[e] in e0 : o/ by rho with (22).

Otherwise, R0[e] is non-expansive, and

\Gamma [xi 7! o/i ref ][x 7! Close(o/ 0; \Gamma [xi 7! o/i ref ])] . e0 : o/
\Gamma [xi 7! o/i ref ] . let x be R0[e] in e0 : o/ by letv with (23)
\Gamma  . ae`:let x be R0[e] in e0 : o/ by rho with (22).

Syntactic Type Soundness 28

Thus \Gamma  . ae`:R[e] : o/ by induction.
It remains to extend the proofs of the various lemmas. The only one that is not straightforward is the Substitution Lemma. As in the definition of generalization, substitutions S
in the following proof are required to map imperative type variables to imperative types.

Lemma 5.3 (Substitution) If \Gamma [x 7! 8ff1 : : : ffn:o/ ] r. e : o/ 0 and x =2 Dom(\Gamma ) and
\Gamma  r. v : o/ and fff1; : : : ; ffng " F T V (\Gamma ) = ; then \Gamma  r. e[x 7! v] : o/ 0.

Proof. The cases from the proof for Functional ML are unchanged, with the exception that
the let-expression case applies only when the bound expression is a value. There is one new
case for expansive let-expressions, and new cases for the additional syntax.

Case e = ref, !, or :=. In each case, \Gamma 0 . e : o/ 0 for any \Gamma 0, hence \Gamma  . e : o/ 0. Also in each

case, e[x 7! v] = e, so \Gamma  . e[x 7! v] : o/ 0.

Case e = ae`:e1. From \Gamma [x 7! 8ff1 : : : ffn:o/ ] . ae`:e1 : o/ 0 by rho

\Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! o/i ref ] . vi : o/i
and \Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! o/i ref ] . e1 : o/ 0

where ` = hx1; v1i : : : hxm; vmi, x1; : : : ; xm; x are distinct, and each o/i is imperative
for 1 ^ i ^ m. Choose a substitution S : fff1; : : : ; ffng ! fff01; : : : ; ff0ng such that
ff01; : : : ; ff0n are distinct type variables, Sffi = ff0i, and fff01; : : : ; ff0ng " (fff1; : : : ; ffng [
F T V (\Gamma ) [ F T V (o/ 0) [ Si F T V (o/i)) = ;. Then by Lemma 4:5+

S(\Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! o/i ref ]) . vi : So/i
i.e. \Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! So/i ref ] . vi : So/i
i.e. \Gamma [xi 7! So/i ref ][x 7! 8ff1 : : : ffn:o/ ] . vi : So/i:

Also by Lemma 4:5+,

S(\Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! o/i ref ]) . e1 : So/ 0
i.e. \Gamma [x 7! 8ff1 : : : ffn:o/ ][xi 7! So/i ref ] . e1 : So/ 0
i.e. \Gamma [xi 7! So/i ref ][x 7! 8ff1 : : : ffn:o/ ] . e1 : So/ 0:

By applying the inductive hypothesis to each,

\Gamma [xi 7! So/i ref ] . vi[x 7! v] : So/i
and \Gamma [xi 7! So/i ref ] . e1[x 7! v] : So/ 0:

Since S is a bijection, S\Gamma 1 exists; hence

\Gamma [xi 7! o/i ref ] . vi[x 7! v] : o/i
and \Gamma [xi 7! o/i ref ] . e1[x 7! v] : o/ 0:

Then \Gamma  . ae`[x 7! v]:e1[x 7! v] : o/ 0 by rho, thus \Gamma  . (ae`:e1)[x 7! v] : o/ 0.

Syntactic Type Soundness 29

Case e = let x0 be e1 in e2 where e1 =2 Values. By the first premise of lete

\Gamma [x 7! 8ff1 : : : ffn:o/ ] . e1 : o/1
\Gamma  . e1[x 7! v] : o/1 by ind. hyp.(24)

By the second premise of lete

\Gamma [x 7! 8ff1 : : : ffn:o/ ][x0 7! AppClose(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . e2 : o/ 0
i.e. \Gamma [x0 7! AppClose(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])][x 7! 8ff1 : : : ffn:o/ ] . e2 : o/ 0:

Choose a substitution S : fff1; : : : ; ffng " ImpTypeVar ! fff01; : : :; ff0mg such that
ff01; : : : ; ff0m are distinct imperative type variables, S is a bijection, and fff01; : : : ; ff0mg "
(F T V (\Gamma ) [ F T V (o/ ) [ fff1; : : : ; ffng) = ;. Then by Lemma 4:5+

S(\Gamma [x0 7! AppClose(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])][x 7! 8ff1 : : : ffn:o/ ]) . e2 : So/ 0
i.e. \Gamma [x0 7! SAppClose(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])][x 7! 8ff1 : : : ffn:o/ ] . e2 : So/ 0
i.e. \Gamma [x0 7! AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])][x 7! 8ff1 : : : ffn:o/ ] . e2 : So/ 0(25)

since the domain of S contains only imperative type variables. From \Gamma  . v : o/ since
x0 is not free in v

\Gamma [x0 7! AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . v : o/:(26)
Now,

fff1; : : : ; ffng " F T V (\Gamma [x0 7! AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])])
` fff1; : : : ; ffng " (F T V (\Gamma ) [ F T V (AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])))
= fff1; : : : ; ffng " F T V (AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ]))
= fff1; : : : ; ffng " F T V (8ff001 : : : ff00m:So/1)
= fff1; : : : ; ffng " (F T V (So/1) n fff001; : : : ; ff00mg)
= ;

where fff001; : : : ; ff00mg = (F T V (So/1) n F T V (\Gamma [x 7! 8ff1 : : : ffn:o/ ])) " AppTypeVar. By
the inductive hypothesis with (25) and (26), it follows that

\Gamma [x0 7! AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . e2[x 7! v] : So/ 0:
Since S is a bijection, S\Gamma 1 exists, so by Lemma 4:5+

S\Gamma 1(\Gamma [x0 7! AppClose(So/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])]) . e2[x 7! v] : S\Gamma 1(So/ 0)
i.e. \Gamma [x0 7! AppClose(o/1; \Gamma [x 7! 8ff1 : : : ffn:o/ ])] . e2[x 7! v] : o/ 0:

Then by Lemma 4:6+

\Gamma [x0 7! AppClose(o/1; \Gamma )] . e2[x 7! v] : o/ 0
and by lete with (24)

\Gamma  . let x be e1[x 7! v] in e2[x 7! v] : o/ 0
i.e. \Gamma  . (let x be e1 in e2)[x 7! v] : o/ 0:

Syntactic Type Soundness 30

The evaluation of an expression in Reference ML can become stuck for several new
reasons. The expanded definition of faulty expressions reflects this fact.

Definition 5.4 (Faulty Expressions) The faulty expressions of Reference ML are those
expressions containing a subexpression of the form:

(c v) where ffi(c; v) is undefined;
(! v) where v =2 Var ;
(:= v) where v =2 Var; or
ae`hx; v2i:C[x v1].

As before, we have a Uniform Evaluation Lemma, stating that programs either yield an
answer, diverge, or reduce to a faulty expression.

Lemma 5.5 (Uniform Evaluation) For closed e, if there is no e0 such that e

vr!7\Gamma ! e0 and

e0 is faulty, then either e * or e

vr!7\Gamma ! a.

Proof. The proof proceeds by induction on the length of the reduction sequence, and is
similar to the proof for Functional ML.

All of the expressions in the expanded definition are untypable.

Main Lemma 5.6 (Faulty Expressions are Untypable) If e is faulty, there are no \Gamma 
and o/ such that \Gamma  r. e : o/ .

Proof. Again, it suffices to show that the subexpressions of e that cause e to be faulty
are untypable. We proceed by case analysis according to the form of the subexpression,
assuming for each case that the expression can be typed, and deriving a contradiction.

Case (c v) where ffi(c; v) is undefined. As for Functional ML.
Case (! v) where v =2 Var. Assume that \Gamma  . ! v : o/ . Then \Gamma  . v : o/ ref by app and deref,

which implies v is a variable (since no other value can have type o/ ref ), contrary to
the assumption.

Case (:= v) where v =2 Var . Assume that \Gamma  . := v : o/ . Then \Gamma  . v : o/ 0 ref where

o/ = o/ 0 ! o/ 0 by app and assign, which implies v is a variable, contrary to the
assumption.

Case ae`hx; v0i:C[x v]. Assume that \Gamma  . ae`hx; v0i:C[x v] : o/ . Then \Gamma 0 . C[x v] : o/ by rho,

where \Gamma 0(x) = o/ 0 ref . Since \Gamma 00 . x v : o/2 where \Gamma 0(x) = \Gamma 00(x), \Gamma 00 . x : o/1 ! o/2 by
app, hence \Gamma 00(x) O/ o/1 ! o/2. This contradicts \Gamma 00(x) = o/ 0 ref .

Type soundness now follows as before.
Theorem 5.7 (Syntactic Soundness for Reference ML) If r. e : o/ then either e * or
e

vr!7\Gamma ! a and r. a : o/ .

Proof. Exactly as for Theorem 4.12, using the appropriately extended lemmas.

Syntactic Type Soundness 31
5.2 Exception ML
Due to ffi-typability, constant functions must be defined for all values of their input type.
This precludes constants, such as integer or real division, that are defined on all but a few
recognizable input values of correct type. Standard ML solves this problem by introducing
exceptions.

Our exception extension provides named exceptions with parameters, a means of raising
exceptions, and a means of handling exceptions. Our extension thus includes three new
phrases:

exception x1 : : : xn in e; raise e1 e2; e3 handle e1 e2:

The first phrase declares x1; : : : ; xn to be exception names lexically bound in e. The second
phrase requires e1 to evaluate to an exception name, and raises that exception with a
parameter, the value of e2. The parameter propagates along with the exception, and is used
at the site where an exception is handled. The third phrase evaluates its subexpressions
e1 and e2 first, and installs the value of e2 as an exception handler for e1 exceptions that
are raised during the evaluation of e3. The subexpression e1 must evaluate to an exception
name, and e2 must evaluate to a function that accepts parameters of e1 exceptions. When
an exception is raised, control transfers to the dynamically closest handler for that kind of
exception. The handler function is applied to the exception parameter, and the result of
the application is returned as the result of the handle-phrase. If there is no active handler
for a raised exception, evaluation terminates with an "unhandled exception" answer.

To extend Functional ML with exceptions, we add several new phrases to the syntax:

e ::= v j e1 e2 j let x be e1 in e2 j exception O/ in e(Expressions)
v ::= c j x j Y j *x:e j raise j e handle j raise v j e handle v(Values)
O/ ::= x\Lambda 

In the expression exception O/ in e, the variables in O/ are bound in e. We treat O/ as a
set of variables, and call these exception names. As raise is a curried binary operator, the
application of raise to a value is a value, and is included in the syntactic class of values (like
:= in Reference ML). Likewise, the expression e handle is a value, and receives an exception
name and handler function by ordinary application. Hence the application of e handle to a
value is also a value.

5.2.1 Semantics
Raising and handling exceptions requires several new reductions:

U [raise x v] \Gamma ! raise x v if U 6= [](raise)
(raise x v1) handle x v2 \Gamma ! v2 v1(handle)
exception O/x1x2 in

X[(raise x1 v1) handle x2 v2] \Gamma !

exception O/x1x2 in

X[raise x1 v1] x1 6= x2(reraise)

v1 handle x v2 \Gamma ! v1(unhandle)

These new notions of reduction again rely on (two different kinds of) contexts for the
enforcement of a specific order of evaluation for applications in connection with the raising

Syntactic Type Soundness 32
and handling of exceptions:

U ::= [] j U e j v U j let x be U in e(raising)
X ::= [] j X e j v X j let x be X in e j X handle x v:(handling)

When an exception is raised, raise reductions propagate the exception outwards, eliminating pending computations. As U contexts do not include the phrase U handle x v, raise
reductions propagate the exception only to the closest exception handler. If the closest handler matches the raised exception, a handle reduction applies the handler function to the
exception parameter. If the handler does not match the exception, a reraise reduction discards the handler, and the exception may continue to propagate by raise reductions. Should
an expression protected by a handler evaluate to a value without raising an exception, the
unhandle reduction discards the handler.

The exception-expression requires two additional reductions, similar to those for aeexpressions:7

exception O/1 in exception O/2 in e \Gamma ! exception O/1O/2 in e(exnmerge )

X[exception O/ in e] \Gamma ! exception O/ in X[e] if X 6= [](exnlift )

Indeed, the only difference is that the exception-expression does not bind any values to its
variables. The purpose of an exception-expression is to distinguish different exceptions in
the reraise reduction, in order that evaluation be deterministic. If x1 and x2 are different
but only *- or let-bound, subsequent reductions may substitute them to the same exceptionbound variable, making the raise reduction applicable. For example:

exception x in (*y:*z:(raise y v1) handle z v2) x x
!\Gamma ! exception x in (raise x v1) handle x v2
!\Gamma ! exception x in v2 v1:

Insisting that x1 and x2 be exception-bound in reraise ensures that they refer to distinct
exceptions. The reduction handle does not require its variables to be exception-bound,
because substitution necessarily replaces both instances of x in the handle redex with the
same exception name.

We use x to refer to the six reductions for exceptions introduced above. Taking the union
of v (extended to the full syntax) and x yields vx, the notion of reduction for Exception
ML. With evaluation contexts extended to:

E ::= [] j E e j v E j let x be E in e j exception O/ in E j E handle x v
the stepping function

vx7\Gamma ! may be defined along the same lines as before. Answers for eval

vx

are:

a ::= v j exception O/ in v j exception O/x in raise x v:(answers)
7Due to our use of the variable conventions for exnmerge, our exceptions are generative as in Standard
ML [22, 23].

Syntactic Type Soundness 33
Answers of the third form are unhandled exceptions: since handlers are dynamically bound,
it is possible for an exception to be raised when no handler for it is installed. Evaluation is
defined as:

evalvx(e) = a iff e

vx!7\Gamma ! a:(eval

vx)

We can now extend the domain of ffi to admit functions such as division, by allowing ffi
to return an expression that raises an exception:8

ffi : Const \Theta  ClosedVal * ClosedVal [ fexception x in raise x v j v is closedg:
Functions such as division can now be defined on every element of their input type, by
returning an exception when their application does not make sense.

5.2.2 Typing
We extend the set of types with an additional type constructor:

o/ ::= '1 j : : : j 'n j ff j o/1 ! o/2 j o/ exn
The type o/ exn is the type of exceptions with a parameter of type o/ .

In typing exceptions in the presence of polymorphism, one encounters similar difficulties
as in typing references. The phrase raise e1 e2 requires e1 to be an exception of type o/ exn,
and e2 to be a matching parameter of type o/ . If e3 has type o/ 0, the phrase e3 handle e1 e2
requires e1 to be an exception of type o/ exn, and e2 to be a handler for such exceptions.
The handler must be a function of type o/ ! o/ 0, since it takes the exception parameter as
input, and returns a value to be returned in place of the value of e3. The obvious typing
for exceptions allows the parameter types of exceptions to be fully polymorphic, permitting
the following expression to be typed:9

let rh be exception x in pair (raise x) (*a.*b.(a 3) handle x b)
in (snd rh) (*d.(fst rh) true) (*y.+ 1 y)
!\Gamma ! exception x in + 1 true

Here, functions to raise and handle the same x-exception are returned as a pair, bound by a
let-expression to rh, and then used. In the body of the let-expression, the expression (raise x)
has type ff1 ! ff2, and (*a.*b.(a 3) handle x b) has type (int ! ff3) ! (ff1 ! ff3) ! ff3.
If the exception parameter type ff1 is generalized, then in the body of the let-expression an
x-exception may be raised with an argument of type bool by (fst rh), and caught by (snd rh),
which is expecting an argument of type int.

Since the problems of typing exceptions and references are similar, it is not surprising
that the same modifications to the typing rules for functional expressions apply: types and
type variables are classified as imperative or applicative, and the let rule is split according
to whether the bound expression is expansive (see Figure 3). Figure 5 presents the additional typing rules for exceptions. Again, as with Reference ML, we require the additional
restriction that there be no constants of exception type (o/ exn).

8Usually a set of exceptions that may be raised by constant functions is defined in an initial environment;
we take an alternative approach to simplify the presentation.

9The constants pair, fst, and snd provide pairing and projection operations.

Syntactic Type Soundness 34

\Gamma  . raise : o/1 exn ! o/1 ! o/2(raise)

\Gamma  . e : o/2
\Gamma  . e handle : o/1 exn ! (o/1 ! o/2) ! o/2(handle)

\Gamma [x1 7! o/1 exn] : : : [xn 7! o/n exn] . e : o/ o/i is imperative 1 ^ i ^ n

\Gamma  . exception x1 : : : xn in e : o/(exn)

Figure 5: Additional typing rules for exceptions

5.2.3 Type Soundness for Exceptions
To establish soundness for the exception typing, we proceed as for references: we establish type preservation for vx, and show that the faulty expressions of Exception ML are
untypable.

Main Lemma 5.8 (Subject Reduction for vx) If \Gamma 

x. e

1 : o/ and e1

vx\Gamma ! e

2 then

\Gamma  x. e2 : o/ .

Proof. The cases for the reductions of v are the same as before.

Case U [raise x v] \Gamma ! raise x v. From \Gamma  . U [raise x v] : o/

\Gamma  . raise x v : o/ 0
by app. Hence

\Gamma  . raise x : o/1 ! o/2(27)
and \Gamma  . v : o/1(28)

by app. From (27)

\Gamma  . x : o/1 exn by app and raise,
\Gamma  . raise x : o/1 ! o/ by app and raise,
\Gamma  . raise x v : o/ by app with (28).

Case exception O/1 in exception O/2 in e \Gamma ! exception O/1O/2 in e. Similar to aemerge in

Lemma 5.2.

Case X[exception O/ in e] \Gamma ! exception O/ in X[e]. Similar to aelift in Lemma 5.2.
Case v1 handle x v2 \Gamma ! v1. \Gamma  . v1 : o/ from \Gamma  . v1 handle x v2 : o/ by handle and app.
Case (raise x v1) handle x v2 \Gamma ! v2 v1. From \Gamma  . (raise x v1) handle x v2 : o/ by handle,

app, and raise

\Gamma  . v1 : o/ 0 and \Gamma  . v2 : o/ 0 ! o/
where \Gamma x = o/ 0 exn. Then \Gamma  . v2 v1 : o/ by app.

Syntactic Type Soundness 35

Case exception O/x1x2 inX[(raise x

1 v1) handle x2 v2] \Gamma !

exception O/x1x2 in

X[raise x1 v1] . Then

\Gamma 0 . (raise x1 v1) handle x2 v2 : o/ 0
\Gamma 0 . (raise x1 v1) handle : o/2 exn ! (o/2 ! o/ 0) ! o/ 0 by app,
\Gamma 0 . raise x1 v1 : o/ 0 by handle,
\Gamma  . exception O/x1x2 in X[raise x1 v1] : o/ by Replacement+.

With the extension of the various lemmas, the proof of type preservation for Exception ML
is complete. The lemmas go through with simple adaptations to the new syntax.

There are several new kinds of faulty expressions for Exception ML.

Definition 5.9 (Faulty expressions) The faulty expressions of Exception ML are those
expressions containing a subexpression of the form:

(c v) where ffi(c; v) is undefined,
(raise v) where v =2 Var,
(e handle v) where v =2 Var , or
exception O/x in C[x v],

where C ::= [] j C e j e C j let x be C in e j let x be e in C j *x:C

j exception O/ in C j C handle :
Again, a uniform evaluation lemma can be shown, and the faulty expressions can be
proven untypable. Type soundness for Exception ML follows as before.

Theorem 5.10 (Syntactic Soundness for Exception ML) If

x. e : o/ then either e *

or e

vx!7\Gamma ! a and x. a : o/ .

5.3 Core ML
We can combine references and exceptions in one language, Core ML, that has all the
essential features of Standard ML. In combining the reference and exception extensions,
we must ensure that they interact appropriately.

5.3.1 Semantics
To combine the calculi for the two extensions, the R contexts of the reference fragment must
be extended to include phrases from the exception fragment; likewise, X contexts must be
extended to include phrases from the reference fragment:

R ::= : : : j R handle v1 v2
X ::= : : : j ae`:X

Syntactic Type Soundness 36
The phrase exception O/ in R is not included in R in order that exceptions in the store do
not escape their bindings, i.e., exception-expressions can move through ae-expressions by the
exnlift reduction, with appropriate variable renaming:

ae`:exception O/x in e \Gamma ! exception O/x in ae`:e
but not vice versa:

exception O/x in ae`hr; xi:e 6\Gamma ! ae`hr; xi:exception O/x in e:
If the second were a permissible reduction, the occurrence of x in the store would escape
its binding.

After this extension of the R and X contexts, the resulting notion of reduction for the
full syntax is vrx. The E evaluation contexts used in defining

vrx7\Gamma ! and eval

vrx must also

be extended:

E ::= [] j E e j v E j let x be E in e j E handle v1 v2 j ae`:E j exception O/ in E:
Answers are:

a ::= fexception O/ ing fae`:g v(answers)

j fexception O/x ing fae`:g raise x v

(where fphraseg means phrase may be omitted). The complete calculus for Core ML may
be found in the appendix.

5.3.2 Typing
To combine the typing rules for the two fragments is easy, since they both rely on the same
classification of types as imperative or applicative, and do not interfere. The complete
typing rules for Core ML may be found in the appendix.

5.3.3 Type Soundness for Core ML
The type soundness of the resulting calculus requires re-establishing the various lemmas and
theorems for the extended syntax and extended evaluation contexts. These proofs are all
straightforward. There is a combinatorial increase in the kinds of faulty expressions because
of the interaction between the two fragments: references cannot be raised or handled;
exceptions cannot be dereferenced nor assigned. The structure of the proof, however, stays
the same.

Definition 5.11 (Faulty Expressions) The faulty expressions of Core ML are those expressions containing a subexpression of the form:

(c v) where ffi(c; v) is undefined;
(! v) where v =2 Var,
(:= v) where v =2 Var ,
ae`hx; v2i:C[x v1],

exception O/x in C[! x],
exception O/x in C[:= x],

(raise v) where v =2 Var,
(e handle v) where v =2 Var ,
exception O/x in C[x v],

ae`hx; vi:C[raise x],
ae`hx; vi:C[e handle x],

Syntactic Type Soundness 37
where C ::= [] j C e j e C j let x be C in e j let x be e in C j *x:C

j ae`:C j ae`hx; Ci:e j exception O/ in C j C handle :
Type soundness follows from subject reduction, uniform evaluation, and faulty expressions being untypable, as before.

Theorem 5.12 (Syntactic Soundness for Core ML) If

rx. e : o/ then either e * or

e

vrx!7\Gamma ! a and rx. a : o/ .

6 Control ML
In this section we present an extension to Functional ML providing first-class continuations.
The typing of our extension is similar to that described by Duba et al. [8], and implemented
in Standard ML of New Jersey [34]. It is a simple matter to merge this extension with
Core ML.

Control ML extends Functional ML's syntax with two new constructs:

e ::= v j e1 e2 j let x be e1 in e2 j abort e(Expressions)
v ::= c j x j Y j *x:e j callcc(Values)

An abort-expression evaluates its subexpression to a value, and returns this value as the
result of the program. When the callcc operator (call-with-current-continuation) is applied
to a function f , it captures a representation of the current continuation (or program control
stack), encapsulates this continuation in an abstraction, and applies f to this abstraction.
If this abstraction is later applied to a value, control transfers to the captured continuation.

6.1 Semantics
While defining calculus reductions for first-class continuations is possible [13, 14], the resulting calculus is inappropriate for our problem. Since we are only interested in evaluation,
we take a simpler approach [11]. We give top-level evaluation rules, program reductions, for
the control operators by extending the stepping relation (7\Gamma !) directly:

E[e] 7\Gamma ! E[e0] iff e

v\Gamma ! e0(ffi; fi

v; let; Y )

E[callcc v] 7\Gamma ! E[v (*x:abort E[x])](callcc)

E[abort e] 7\Gamma ! e(abort)

where

E ::= [] j E e j v E j let x be E in e:

In this style of semantics, the evaluation context E represents the current continuation.
An abort reduction simply discards the current continuation, continuing evaluation with its
subexpression. The callcc reduction captures the current continuation, encapsulates it in a
function, and applies callcc's argument to this function. The continuations created by callcc
are abortive: when invoked, they discard the continuation surrounding their application

Syntactic Type Soundness 38

let product be *x. callcc

(*k. letrec p be *z. if nil? z then 1

else if = 0 (car z) then k 0
else * (car z) (p (cdr z))
in p x)
in product (cons 2 (cons 3 (cons 0 (cons 5 nil))))

Figure 6: A program illustrating a simple use of callcc

(via an abort reduction), installing instead the captured continuation. Answers are simply
values, and eval is defined as for Functional ML.

Figure 6 illustrates a simple use of callcc. This program computes the product of a
list of numbers, performing no multiplications if the answer is zero. The constants nil,
cons, nil?, car, and cdr are the usual constants and operations for lists. The expressions
if: : :then: : :else: : : and letrec: : :be: : :in: : : are syntactic sugar for appropriate constant applications. This program computes the product of a list of numbers, performing no multiplications if the answer is zero. The program escapes from pending multiplications by jumping
out of the recursion to the continuation of the application of product.

6.2 Typing
The obvious approach to typing callcc leads to the following rule:

\Gamma  . callcc : ((o/1 ! o/2) ! o/1) ! o/1(na"ive-callcc)
As indicated by the callcc reduction, callcc takes a function whose argument is a procedural
abstraction of the evaluation context, the continuation. If the evaluation context expects
a value of type o/1, then the continuation has type o/1 ! o/2 for any type o/2. If callcc's
argument ignores this continuation, it must produce a value of type o/1, which implies that
callcc's argument must have type (o/1 ! o/2) ! o/1. The result type of the continuation, o/2,
is arbitrary, because the application of k built into the continuation ensures that it never
returns.

However, this obvious typing is unsound, as illustrated by the following example:10

let x be callcc (*k. pair (*x.x) (*f. k (pair f (*d.5))))
in (*z. snd x (*x.+ x 1)) (fst x true)

The callcc application returns a pair of type (ff ! ff) \Theta  ((ff ! ff) ! int), consisting of
the identity function and a function that applies a continuation. Since ff is not free in the
type environment, it is closed over, and x has type scheme 8ff:(ff ! ff) \Theta  ((ff ! ff) ! int)
in the body of the let-expression. In evaluating the body, fst x is the polymorphic identity
function, so it may validly be applied to true. Then the second function of the pair is applied

10A variation of this example was discovered by Robert Harper and Mark Lillibridge [sml electronic mailing
list, July 8, 1991]. Despite widespread use of a na"ively typed callcc extension in Standard ML of New
Jersey, it took two years until this problem was discovered.

Syntactic Type Soundness 39
to (*x.+ x 1), and the continuation so invoked rebinds x to the pair consisting of (*x.+ x 1)
and (*d.5). The second evaluation of fst x true results in an attempt to add 1 to true.

As with references and exceptions, a correct typing for continuations builds upon the
classification of types as imperative or applicative, and requires the let typing rules of
Figure 3. The correct typing rules are:

\Gamma  . callcc : ((o/1 ! o/2) ! o/1) ! o/1 if o/1 is imperative.(callcc)

\Gamma  . e : o/1
\Gamma  . abort e : o/2(abort)

An abort-expression may have any type, regardless of the type of its subexpression, because
when evaluated it never returns.

6.3 Weak Type Soundness
Because abort-expressions can return a value of any type, proving type soundness for the
continuation extension is not as simple as for the previous extensions. For example, if e is
an expression of type bool, the program:

if e then 1 else (abort true)
is typable according to the above typing rules, but returns either int or bool according to
whether e is true or false. Thus subject reduction in the usual sense does not hold; however,
a weaker lemma does hold, stating that typability is preserved.

Main Lemma 6.1 (Typability Preservation) If . e1 : o/ and e1 7\Gamma ! e2 then . e2 : o/ 0.
Proof. We need only consider the additional cases for the callcc and abort reductions. The
others are simply adapted from Lemma 4.3 (Subject Reduction for Functional ML).

Case E[abort e] 7\Gamma ! e. Then \Gamma  . e : o/ 0 for some o/ 0. But since E[abort e] is closed and E

does not bind variables, e is closed, hence . e : o/ 0.

Case E[callcc v] 7\Gamma ! E[v (*x:abort E[x])]. From . E[callcc v] : o/ we have . callcc v : o/1,

and by callcc and app

. v : (o/1 ! o/2) ! o/1(29)
where o/1 is imperative.
Since E is closed, x does not appear free in E, and we claim that [x 7! o/1] . E[x] : o/ .
The proof of this claim proceeds by induction on the structure of E.

Case E = []. Then o/ = o/1, and [x 7! o/1] . x : o/ by var.
Case E = (E0 e0). Then . (E0[callcc v] e0) : o/ , and by app

. E0[callcc v] : o/3 ! o/(30)
and . e0 : o/3(31)
for some o/3. Then [x 7! o/1] . E0[x] : o/3 ! o/ by ind. hyp. with (30). Also
[x 7! o/1] . e0 : o/3 by Lemma 4:1+ with (31) since x =2 F V (E). Hence

[x 7! o/1] . E0[x] e0 : o/ by app.

Syntactic Type Soundness 40

Case E = (v E0). Similar to the previous case.
Case E = let x0 be E0 in e0. Then . let x0 be E0[callcc v] in e0 : o/ . Since (callcc v) is

expansive, E0[callcc v] is expansive. Thus by lete

. E0[callcc v] : o/3(32)
and [x0 7! AppClose(o/3; ;)] . e0 : o/(33)

for some o/3. Then

[x 7! o/1] . E0[x] : o/3 by ind. hyp. with (32),(34)
and

[x0 7! AppClose(o/3; ;)][x 7! o/1] . e0 : o/ by Lemma 4:1+ with (33)
i :e: [x 7! o/1][x0 7! AppClose(o/3; ;)] . e0 : o/:

By the critical restriction that o/1 is imperative,

AppClose(o/3; ;) = AppClose(o/3; [x 7! o/1]);
hence

[x 7! o/1][x0 7! AppClose(o/3; [x 7! o/1])] . e0 : o/
[x 7! o/1] . let x0 be E0[x] in e0 : o/ by lete with (34).

This completes the proof of the claim. Hence

[x 7! o/1] . abort E[x] : o/2 by abort,
. (*x:abort E[x]) : o/1 ! o/2 by abs,
. v (*x:abort E[x]) : o/1 by app with (29)
. E[v (*x:abort E[x])] : o/ by Replacement+.

The faulty expressions for Control ML are the same as those of Functional ML, extended
to the new syntax.

Definition 6.2 (Faulty Expressions) The faulty expressions of Control ML are the expressions containing a subexpression (c v) where ffi(c; v) is undefined.

As with Functional ML, the faulty expressions are untypable and Uniform Evaluation holds.
However, since we only have typability preservation, we obtain a weaker version of syntactic
soundness that does not indicate the type of answers.

Theorem 6.3 (Weak Syntactic Soundness) If . e : o/ then either e * or e !7\Gamma ! v.
Proof. By Uniform Evaluation, either e !7\Gamma ! e0 and e0 is faulty, or e *, or e !7\Gamma ! v. Since
. e : o/ , Typability Preservation implies . v : o/ 0 and . e0 : o/ 0. Suppose e !7\Gamma ! e0 and e0 is
faulty. Since faulty expressions are untypable, . e0 : o/ 0 is a contradiction, therefore this case
cannot occur. Hence either e * or e !7\Gamma ! v.

This weaker theorem establishes weak soundness, but does not imply strong soundness.
In fact, if the use of abort is unrestricted, it is not possible to predict the type of an answer,
as the example at the beginning of this section illustrates.

Syntactic Type Soundness 41
6.4 Strong Type Soundness
Examining the proof of Typability Preservation reveals that every reduction with the exception of abort preserves type. In particular, the callcc reduction preserves type, which
suggests that callcc by itself is strongly sound. To obtain a proof of strong soundness for
callcc, we must eliminate abort from the surface language available to programmers, but
retain it in the underlying language of evaluation for callcc reductions. Because the abort
expressions introduced by callcc applications have a restricted shape, they never return
values of other than the top-level type of the program, and do not compromise strong
soundness.

To establish a subject reduction lemma, we define an augmented type system that infers
both the ordinary type of an expression and a set of abort types. The abort types of an
expression e are the types of the immediate subexpressions of abort-expressions in e. The
augmented system does not permit abort types to be generalized, thereby ensuring that
each syntactic occurrence of abort can produce only one type of answer. This restriction
eliminates expressions such as the following:

let a be *x. abort x
in if e then a 1

else a true

Hence if a well-typed program aborts, the answer produced is one of the program's abort
types. Type judgments for this augmented system have the form \Gamma 

a. e : o/; T , meaning that

in type environment \Gamma , expression e has ordinary type o/ and abort types T , where T is a
set of types. Figure 7 presents the typing rules of the augmented system.

The augmented type system corresponds closely to our original type system for Control
ML. The rule for typing abort-expressions is the only rule that connects the ordinary type
and the abort types of an expression. In each axiom (var, const, Y, callcc) the abort
set is completely unconstrained; the inference rules simply propagate the abort set. The
let-expression rules do not generalize type variables in the set of abort types, hence the
augmented system does not permit polymorphic uses of abort, and accepts a subset of the
expressions accepted by the ordinary system. A Correspondence Lemma establishes this
connection between the ordinary system (.) and the augmented system (a.).

Lemma 6.4 (Correspondence)

(i ) If \Gamma  . e : o/ and e contains no abort-expressions then \Gamma 

a. e : o/; T for any T ;

(ii ) If \Gamma 

a. e : o/; T then \Gamma  . e : o/ .

Proof. The proof of each direction shows how to construct a deduction for the consequent
from a deduction of the antecedent. Both proofs are straightforward.

Subject Reduction for the augmented system establishes that reduction preserves the
set of abort types. As the callcc reduction introduces an abort-expression with the top-level
type of the program, the set of abort types preserved by Subject reduction includes the
top-level type.

Syntactic Type Soundness 42

\Gamma 

a. x : o/; T if \Gamma (x) O/ o/(var)

\Gamma 

a. c : o/; T if TypeOf (c) O/ o/(const)

\Gamma 

a. Y : ((o/

1 ! o/2) ! o/1 ! o/2) ! o/1 ! o/2; T(Y)

\Gamma [x 7! o/1]

a. e : o/

2; T

\Gamma 

a. *x:e : o/

1 ! o/2; T

(abs)

\Gamma 

a. e

1 : o/1 ! o/2; T \Gamma 

a. e

2 : o/1; T

\Gamma 

a. e

1 e2 : o/2; T

(app)

\Gamma 

a. v : o/

1; T \Gamma [x 7! Close(o/1; \Gamma ; T )]

a. e : o/

2; T

\Gamma 

a. let x be v in e : o/

2; T

(letv)

\Gamma 

a. e

1 : o/1; T \Gamma [x 7! AppClose(o/1; \Gamma ; T )]

a. e

2 : o/2; T e1 =2 Values

\Gamma 

a. let x be e

1 in e2 : o/2; T

(lete)

\Gamma 

a. callcc : ((o/

1 ! o/2) ! o/1) ! o/1; T if o/1 is imperative(callcc)

\Gamma 

a. e : o/

1; T o/1 2 T

\Gamma 

a. abort e : o/

2; T

(abort)

Close(o/; \Gamma ; T ) = 8ff1 : : : ffn:o/
where fff1; : : : ; ffng = F T V (o/ ) n (F T V (\Gamma ) [ F T V (T ))

AppClose(o/; \Gamma ; T ) = 8ff1 : : : ffn:o/
where fff1; : : : ; ffng = (F T V (o/ ) n (F T V (\Gamma ) [ F T V (T ))) " AppTypeVar

Figure 7: The augmented type system for Control ML

Main Lemma 6.5 (Subject Reduction) If a. e1 : o/; T and o/ 2 T and e1 7\Gamma ! e2 then

a. e

2 : o/

0; T and o/ 0 2 T .

Proof. The proof proceeds by case analysis according to the reduction e1 7\Gamma ! e2. Each
case is easily adapted from the corresponding case in the proof of Typability Preservation
with straightforward adaptations of the necessary lemmas.

With Uniform Evaluation and the fact that faulty expressions are untypable (in the
ordinary system), we obtain a syntactic soundness theorem for abort-free expressions.

Theorem 6.6 (Syntactic Soundness) If . e : o/ and e contains no abort-expressions
then either e * or e !7\Gamma ! v and . v : o/ .

Proof. By Uniform Evaluation, either e !7\Gamma ! e0 and e0 is faulty, or e *, or e !7\Gamma ! v. Since
. e : o/ and e contains no abort-expressions, by Correspondence

a. e : o/; fo/ g. Subject

Reduction then implies a. e0 : o/; fo/ g. Similarly a. v : o/; fo/ g, and by Correspondence . e0 : o/
and . v : o/ . Suppose e !7\Gamma ! e0 and e0 is faulty. Since faulty expressions are untypable, . e0 : o/
is a contradiction, therefore this case cannot occur. Hence either e * or e !7\Gamma ! v and . v : o/ .

Syntactic Type Soundness 43
7 Discussion
Subject reduction is the key lemma in our approach to proving type soundness. In order
to demonstrate subject reduction, it must be possible to assign a type to each intermediate
evaluation state of a program. This is most easily accomplished by specifying evaluation as
rewriting. Rewriting may be specified as local reductions, as our calculus for Core ML, or
as program (or top-level) rewriting, as in Control ML.

Through most of this paper, we present the semantics of the various languages with
calculi that permit local reductions. It is also possible to use our proof technique with a
semantics that specifies only program reductions (7\Gamma !), as in Control ML. Such a semantics
for Reference ML is slightly simpler, as the ref, aemerge , and aelift reductions coalesce into one
program reduction, but the structure of the proof is essentially the same. Our work on an
alternative type system for references uses this approach [38]. We chose to use calculi in
this paper as the resulting proofs are more regular in structure.

In specifying the semantics of references as a calculus, we use an additional expression
form, the ae-expression, that is not present in ML. As noted earlier, ae-expressions may be
regarded as abbreviations, both from a semantic perspective and a typing perspective (the
typing rule for ae-expressions can be derived from the abbreviation). In principle, it is possible to eliminate ae-expressions from the syntax, however the specification of redexes in the
reduction rules becomes complicated. Alternatively, ae-expressions may be considered as belonging to the state space of evaluation, and not to the language of programs that may be
written by a programmer. In a presentation of the typing rules for consumption by programmers, the typing rule for ae-expressions may be deleted. However, unlike ae-expressions, the
abort-expressions of the continuation fragment cannot be considered as abbreviations [10].
To obtain a strong soundness theorem, abort-expressions must be considered as belonging
only to the evaluation space, and not to the syntax of programs. The exception fragment
has no such additional expressions.

Other operational or denotational techniques for specifying semantics introduce additional semantic objects, such as closures and stores, rather than additional expression forms.
Since the type system does not apply to such objects, stating and proving strong type soundness requires introducing a semantic relation (j=) between semantic objects and types (see
Section 2). We believe that introducing additional expression forms and typing rules is the
simpler choice, and offer the simpler proofs produced by our method as evidence.

While in this paper we have concentrated on the essential aspects of ML, there are other
features of static type systems that we believe our technique can address. Standard ML
contains a datatype specification mechanism that allows the definition of new types and
associated data constructors. This mechanism is indispensable when writing non-trivial
ML programs. Subtyping, inheritance, and type inference for records are a strong focus
of recent research efforts to explain object-oriented languages, as many popular objectoriented languages have unsound static type systems. Reppy [29] has successfully addressed
concurrency with our technique; it should also be possible to treat nondeterminism and
distributed computing. We have used our technique to prove an alternative type system for
references sound [38]. Finally, it may be possible to adapt our technique to demonstrate
the consistency of module systems like that of Standard ML.

Syntactic Type Soundness 44
Acknowledgements
We would like to thank Bob Harper for pointing out that type preservation is known as
subject reduction in combinatory logic, and Hans Boehm and the anonymous referees for
comments on earlier drafts of this paper.

Syntactic Type Soundness 45
Appendix: The Core of Standard ML
Syntax

e ::= v j e1 e2 j let x be e1 in e2 j ae`:e j exception O/ in e
v ::= c j x j Y j *x:e j ref j ! j := j raise j e handle j := v j raise v j e handle v

` ::= f hx; vi g\Lambda 
O/ ::= x\Lambda 

a ::= fexception O/ ing fae`:g v j fexception O/x ing fae`:g raise x v

Semantics

eval(e) = a iff e !7\Gamma ! a
E[e] 7\Gamma ! E[e0] iff e \Gamma ! e0

E ::= [] j E e j v E j let x be E in e j E handle v1 v2 j ae`:E j exception O/ in E

Functional ML

c v \Gamma ! ffi(c; v) if ffi(c; v) is defined(ffi)
(*x:e) v \Gamma ! e[x 7! v](fiv)
let x be v in e \Gamma ! e[x 7! v](let)

Y v \Gamma ! v (*x:(Y v) x)(Y )

References

ref v \Gamma ! aehx; vi:x(ref )
ae`hx; vi:R[! x] \Gamma ! ae`hx; vi:R[v](deref )
ae`hx; v1i:R[:= x v2] \Gamma ! ae`hx; v2i:R[v2](assign)

ae`1:ae`2:e \Gamma ! ae`1`2:e(aemerge )

R[ae`:e] \Gamma ! ae`:R[e] if R 6= [](aelift)

R ::= [] j R e j v R j let x be R in e j R handle v1 v2

Exceptions

U [raise x v] \Gamma ! raise x v if U 6= [](raise)
(raise x v1) handle x v2 \Gamma ! v2 v1(handle)
exception O/x1x2 in

X[(raise x1 v1) handle x2 v2] \Gamma !

exception O/x1x2 in

X[raise x1 v1] x1 6= x2(reraise)

v1 handle x v2 \Gamma ! v1(unhandle)
exception O/1 in exception O/2 in e \Gamma ! exception O/1O/2 in e(exnmerge )

X[exception O/ in e] \Gamma ! exception O/ in X[e] if X 6= [](exnlift )

U ::= [] j U e j v U j let x be U in e
X ::= [] j X e j v X j let x be X in e j X handle v1 v2 j ae`:X

Syntactic Type Soundness 46
Typing

Functional ML

\Gamma  . x : o/ if \Gamma (x) O/ o/(var)
\Gamma  . c : o/ if TypeOf (c) O/ o/(const)
\Gamma  . Y : ((o/1 ! o/2) ! o/1 ! o/2) ! o/1 ! o/2(Y)

\Gamma [x 7! o/1] . e : o/2
\Gamma  . *x:e : o/1 ! o/2(abs)
\Gamma  . e1 : o/1 ! o/2 \Gamma  . e2 : o/1

\Gamma  . e1 e2 : o/2(app)
\Gamma  . v : o/1 \Gamma [x 7! Close(o/1; \Gamma )] . e : o/2

\Gamma  . let x be v in e : o/2(letv)
\Gamma  . e1 : o/1 \Gamma [x 7! AppClose(o/1; \Gamma )] . e2 : o/2 e1 =2 Values

\Gamma  . let x be e1 in e2 : o/2(lete)

Close(o/; \Gamma ) = 8ff1 : : : ffn:o/ where fff1; : : : ; ffng = F T V (o/ ) n F T V (\Gamma )
AppClose(o/; \Gamma ) = 8ff1 : : : ffn:o/ where fff1; : : : ; ffng = (F T V (o/ ) n F T V (\Gamma )) " AppTypeVar

References

\Gamma  . ref : o/ ! o/ ref if o/ is imperative(ref)

\Gamma  . ! : o/ ref ! o/(deref)
\Gamma  . := : (o/ ref ! o/ ! o/ )(assign)

\Gamma [x1 7! o/1 ref ] : : : [xn 7! o/n ref ] . e : o/
\Gamma [x1 7! o/1 ref ] : : : [xn 7! o/n ref ] . vi : o/i o/i is imperative 1 ^ i ^ n

\Gamma  . aehx1; v1i : : : hxn; vni:e : o/(rho)

Exceptions

\Gamma  . raise : o/1 exn ! o/1 ! o/2(raise)

\Gamma  . e : o/2
\Gamma  . e handle : o/1 exn ! (o/1 ! o/2) ! o/2(handle)

\Gamma [x1 7! o/1 exn] : : : [xn 7! o/n exn] . e : o/ o/i is imperative 1 ^ i ^ n

\Gamma  . exception x1 : : : xn in e : o/(exn)

Syntactic Type Soundness 47
References

[1] Abadi, M., Cardelli, L., Pierce, B., and Plotkin, G. Dynamic typing in a

statically-typed language. ACM Transactions on Programming Languages and Systems
13, 2 (April 1991), 237-268. Previously appeared in: Proceedings of the 16th Annual
Symposium on Principles of Programming Languages (January 1989), 213-227.

[2] Barendregt, H. P. The Lambda Calculus: Its Syntax and Semantics, revised ed.,

vol. 103 of Studies in Logic and the Foundations of Mathematics. North-Holland,
Amsterdam, 1984.

[3] Crank, E., and Felleisen, M. Parameter-passing and the lambda calculus. Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January
1991), 233-244.

[4] Curry, H. B., and Feys, R. Combinatory Logic, Volume I. North-Holland, Amsterdam, 1958.

[5] Damas, L., and Milner, R. Principal type schemes for functional programs. Proceedings of the 9th Annual Symposium on Principles of Programming Languages (January
1982), 207-212.

[6] Damas, L. M. M. Type Assignment in Programming Languages. PhD thesis, University of Edinburgh, 1985.

[7] Donahue, J., and Demers, A. Data types are values. ACM Transactions on Programming Languages and Systems 7, 3 (July 1985), 426-445.

[8] Duba, B. F., Harper, R., and MacQueen, D. Typing first-class continuations

in ML. Proceedings of the 18th Annual Symposium on Principles of Programming
Languages (January 1991), 163-173.

[9] Felleisen, M. The theory and practice of first-class prompts. Proceedings of the 15th

Annual Symposium on Principles of Programming Languages (1988), 180-190.

[10] Felleisen, M. On the expressive power of programming languages. Science of Computer Programming 17 (1991), 35-75. Preliminary version in: Proceedings of the European Symposium on Programming, LNCS 432 (1990), 134-151.

[11] Felleisen, M., and Friedman, D. P. Control operators, the SECD-machine, and

the *-calculus. In Formal Description of Programming Concepts III, M. Wirsing, Ed.
Elsevier Science Publishers B.V. (North-Holland), Amsterdam, 1986, pp. 193-217.

[12] Felleisen, M., and Friedman, D. P. A syntactic theory of sequential state. Theoretical Computer Science 69, 3 (1989), 243-287. Preliminary version in: Proceedings of
the 14th Annual Symposium on Principles of Programming Languages, 1987, 314-325.

[13] Felleisen, M., Friedman, D. P., Kohlbecker, E. E., and Duba, B. A syntactic

theory of sequential control. Theoretical Computer Science 52, 3 (1987), 205-237.
Preliminary version in: Proceedings of the Symposium on Logic in Computer Science,
1986, 131-141.

Syntactic Type Soundness 48
[14] Felleisen, M., and Hieb, R. The revised report on the syntactic theories of sequential control and state. Tech. Rep. TR-100, Rice University, June 1989. To appear in:
Theoretical Computer Science, 1992.

[15] Hindley, R. The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society 146 (December 1969), 29-60.

[16] Hindley, R. J., and Seldin, J. P. Introduction to Combinators and *-Calculus.

Cambridge University Press, 1986.

[17] Leroy, X., and Weis, P. Polymorphic type inference and assignment. Proceedings of

the 18th Annual Symposium on Principles of Programming Languages (January 1991),
291-302.

[18] MacQueen, D. B., Plotkin, G., and Sethi, R. An ideal model for recursive

polymorphic types. Proceedings of the 11th Annual Symposium on Principles of Programming Languages (January 1984), 165-174.

[19] Mason, I., and Talcott, C. Programming, transforming, and proving with function abstractions and memories. In Proceedings of the International Conference on
Automata, Languages, and Programming, LNCS 372 (1989), Springer-Verlag, pp. 574-
588.

[20] Milner, R. A theory of type polymorphism in programming. Journal of Computer

and System Sciences 17 (1978), 348-375.

[21] Milner, R., and Tofte, M. Co-induction in relational semantics. Theoretical Computer Science 87 (1991), 209-220.

[22] Milner, R., and Tofte, M. Commentary on Standard ML. MIT Press, Cambridge,

Massachusetts, 1991.

[23] Milner, R., Tofte, M., and Harper, R. The Definition of Standard ML. MIT

Press, Cambridge, Massachusetts, 1990.

[24] Mitchell, J. C., and Harper, R. The essence of ML. Proceedings of the 15th

Annual Symposium on Principles of Programming Languages (January 1988), 28-46.

[25] Mitchell, J. C., and Plotkin, G. D. Abstract types have existential type. ACM

Transactions on Programming Languages and Systems 10, 3 (July 1988), 470-502. Also
appeared in: Proceedings of the 11th Annual Symposium on Principles of Programming
Languages, 1984, 37-51.

[26] Plotkin, G. D. Call-by-name, call-by-value and the lambda-calculus. Theoretical

Computer Science 1 (1975), 125-159.

[27] Plotkin, G. D. A structural approach to operational semantics. Tech. Rep. DAIMI

FN-19, *Arhus University, September 1981.

[28] Rees, J., and Clinger, W. Revised3 report on the algorithmic language Scheme.

SIGPLAN Notices 21, 12 (December 1986), 37-79.

Syntactic Type Soundness 49
[29] Reppy, J. H. Higher-order Concurrency. PhD thesis, Cornell University, 1991.
[30] Reynolds, J. Definitional interpreters for higher order programming languages. ACM

Conference Proceedings (1972), 717-740.

[31] Reynolds, J. C. On the relation between direct and continuation semantics. Proceedings of the International Conference on Automata, Languages, and Programming
(1974), 141-156.

[32] Scott, D. Data types as lattices. SIAM Journal of Computing 3, 5 (1976), 522-586.
[33] Seldin, J. P. A sequent calculus for type assignment. Journal of Symbolic Logic 42

(1977), 11-28.

[34] Standard ML of New Jersey release notes (version 0.75). AT&T Bell Laboratories,

November 1991.

[35] Talpin, J.-P., and Jouvelot, P. The type and effect discipline. Tech. Rep. EMPCRI A/206, Ecole des Mines de Paris, July 1991.

[36] Tofte, M. Operational Semantics and Polymorphic Type Inference. PhD thesis,

University of Edinburgh, 1987.

[37] Tofte, M. Type inference for polymorphic references. Information and Computation

89, 1 (November 1990), 1-34.

[38] Wright, A. K. Typing references by effect inference. In Proceedings of the European

Symposium on Programming, LNCS 582 (1992), Springer-Verlag, pp. 473-491.