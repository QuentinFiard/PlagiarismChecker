

Fictional Separation Logic

Jonas Braband Jensen and Lars Birkedal

IT University of Copenhagen

Abstract. Separation logic formalizes the idea of local reasoning for
heap-manipulating programs via the frame rule and the separating conjunction P * Q, which describes states that can be split into separate
parts, with one satisfying P and the other satisfying Q. In standard separation logic, separation means physical separation. In this paper, we
introduce fictional separation logic, which includes more general forms of
fictional separating conjunctions P * Q, where * does not require physical separation, but may also be used in situations where the memory
resources described by P and Q overlap. We demonstrate, via a range
of examples, how fictional separation logic can be used to reason locally
and modularly about mutable abstract data types, possibly implemented
using sophisticated sharing. Fictional separation logic is defined on top of
standard separation logic, and both the meta-theory and the application
of the logic is much simpler than earlier related approaches.

Keywords: Separation Logic, Local Reasoning, Modularity.
1 Introduction
Separation logic is a kind of Hoare logic for local reasoning about programs withshared mutable state. Locality is achieved by use of the * connective and the
frame rule: {P } C {Q}

{P * R} C {Q * R}
Recall that in standard separation logic, P * R is satisfied by a heap if it canbe split into two separate (disjoint) parts satisfying

P and R respectively. Theframe rule expresses that if command
C is well-specified with precondition Pand postcondition
Q, then C will preserve any disjoint invariant R, intuitively(and formally in standard models) because of physical heap separation.

In many situations, however, physical separation is too strong a requirement- we would like to be able to reason locally using *-connectives and frame rules in
situations where we do not have physical separation, but where we do have someform of logical or fictional separation

1. The key idea is that fictional separation

should allow us to reason separately about updates to shared resources, as longas the updates follow some kind of discipline to guarantee that updates to one

1 The term "fictional separation" is derived from the phrase "fiction of disjointness",

which, to the best of our knowledge, was introduced by Philippa Gardner [8].

side of the * do not affect the truth of the other side. Permission accountingmodels [5, 4, 10] provide a familiar simple instance of this idea: they allow us to
reason separately about shared heaps as long as we do not update but only readthose heaps. In recent work on separation logic for concurrency [7, 11] and for
abstraction [8, 9], it is possible to describe more elaborate patterns of sharing.We return to this when we discuss related work in Section 7.

In this paper we introduce fictional separation logic and demonstrate, viaexamples, how the logic can be used to reason locally and modularly about
mutable abstract data types, possibly implemented using sophisticated sharing.Before turning to the technical presentation, we consider a simple example.

Example: Bit Pair. Consider a small library for manipulating pointers to bitpairs. It has a constructor, destructor and some accessors that conform to the
following specification in standard higher-order separation logic [2]:

9B1, B2 : loc * bool ! P(heap).{

emp} bp new() {B1(ret, false) * B2(ret, false)} ^{
B1(p, ) * B2(p, )} bp free(p) {emp} ^8

i 2 {1, 2}. (8b. {Bi(p, b)} bp geti(p) {Bi(p, b) ^ ret = b}) ^{

Bi(p, )} bp seti(p, b) {Bi(p, b)}.

Note the use of existential quantification over representation predicates B1 and
B2; they correspond to what Parkinson and Bierman call abstract predicates [18].The special variable

ret in postconditions denotes the return value. As usual, theunderscore is used for an existentially-quantified variable.

Implementing this na"ively and verifying the implementation is straightfor-ward in standard separation logic. Simply let the constructor allocate two consecutive heap cells and let the accessors dereference either their p parameter or
p + 1. For the verification, instantiate Bi(p, b) to (p + (i - 1)) 7! b.But this implementation uses at least twice as much heap space as necessary.

The least we could do is to allocate only one (integer) heap cell and store the pairof bits in its least significant bits. A possible implementation is the following,
where / denotes integer division, and % denotes modulo:

bp new() { p := alloc 1; [p] := 0; return p }
bp free(p) { free p }
bp get1(p) { x := [p]; return x % 2 }
bp get2(p) { x := [p]; return x / 2 }
bp set1(p,b) { x := [p]; [p] := b + x/2*2 }
bp set2(p,b) { x := [p]; [p] := 2*b + x%2 }

The original specification is unfortunately unprovable for this implementa-tion, even though the two implementations have completely identical behaviour

when observed by a client that cannot inspect their internal memory.The problem is that the abstract module specification is not sufficiently abstract since it requires that the constructor creates two heap chunks that are

physically disjoint. In other words, the abstract module specification revealspatterns of sharing or, as is the case here, lack of sharing, that really ought to be
internal to the module implementation. Moving to a heap model with bit-levelseparation will not solve the essence of this problem. Indeed, a third implementation could store the two bits in an integer that is divisible by 3 when B1 is trueand divisible by 5 when

B2 is true. In this case, the fictional separation comesfrom arithmetic properties of the integers.

In fictional separation logic, we existentially quantify not only over represen-tation predicates

B1 and B2, but also over the choice of separation algebra, \Sigma ,and an interpretation map

I (explained below). The abstract module specifica-tion then looks like this:

9\Sigma  : sepalg. 9I : \Sigma  % heap. 9B1, B2 : loc * bool ! P(\Sigma ).

I. {emp} bp new() {B1(ret, false) * B2(ret, false)} ^
I. {B1(p, ) * B2(p, )} bp free(p) {emp} ^8

i 2 {1, 2}. (8b. I. {Bi(p, b)} bp geti(p) {Bi(p, b) ^ ret = b}) ^

I. {Bi(p, )} bp seti(p, b) {Bi(p, b)}.

The intention is that the interpretation map I should explain how elements ofthe separation algebra

\Sigma  are represented by predicates on physical heaps.Note that the Hoare triples are now prefixed by

I - we refer to such a predi-cate
I. {P } C {Q} as an indirect Hoare triple. The intention is that I records (1)which separation algebra

P and Q should be interpreted over, and (2) how P and
Q are translated into physical heap predicates, such that the triple meaningfullycorresponds to a suitably translated triple in standard separation logic.

This module specification does not reveal information about sharing or lackof sharing, because

\Sigma  and I are abstract, i.e., existentially quantified. Clientcode can now be verified relative to this abstract module specification and since,

as we will show, fictional separation logic supports the standard proof rules (andsome additional rules), the verification of client code is as easy as it is in standard
separation logic. We return to this example in Section 3.2 and show how bothimplementations of bit pairs satisfy the above abstract specification. We will
consider an example of client code verification in Section 4.1.

Outline. The remainder of this paper is organized as follows. We first presentsome formal preliminaries in Section 2 and then go on to present four sections
on fictional separation logic. In each of these sections, we first describe sometheory and then present examples that demonstrate how to use the theory in
program verification. Basic fictional separation logic and the indirect triple aredefined in Section 3. In Section 4 we define separating products of interpretations,
which allow clients to use several modules at the same time, and in Section 5 wedefine a notion of indirect entailment and show how to use it to define fractional
permissions within fictional separation logic. We discuss how to stack severallevels of abstraction in Section 6, and we conclude and discuss related work in
Section 7. To focus on the core ideas, we present fictional separation logic for

a simple sequential imperative programming language with procedures, but itshould be clear that the ideas are applicable to richer programming languages.

Proofs and further examples can be found in the online appendix [14].

2 Formal Preliminaries
2.1 Abstract Assertion Logic
The meaning of separation logic assertions is often parametrized on a separationalgebra (SA) [6], which is an abstraction of the heap model. There are several

competing definitions of separation algebra in the literature [6, 10, 12]; we usethe one from [12]:

2

Definition 1. A separation algebra is a partial commutative monoid (\Sigma , ffi, 0).We write

oe .= oe1 ffi oe2 when the oe1 ffi oe2 is defined and has value oe.

Given a separation algebra (\Sigma , ffi, 0), the powerset P(\Sigma ) forms a completeboolean BI algebra, i.e., a model of the assertion language of classical separation

logic, where the connectives are defined in the standard way [6]:

? , \Sigma  ? , ;
P ^ Q , P " Q P . Q , P [ Q
8x : A. P (x) , "

x:A

P (x) 9x : A. P (x) , [

x:A

P (x)

P ) Q , {oe | oe 2 P ) oe 2 Q} emp , {0}

P * Q , {oe | 9oe1, oe2. oe .= oe1 ffi oe2 ^ oe1 2 P ^ oe2 2 Q}
P -* Q , {oe2 | 8oe1. 8oe .= oe1 ffi oe2. oe1 2 P ) oe 2 Q}

As usual, entailment is defined as P ` Q , P ` Q. We refer to the elements ofP(

\Sigma ) as (semantic) assertions.

2.2 Programming Language
The logic we will introduce in the next section is mostly independent of theunderlying programming language, but we will fix a particular language here

for clarity. It is a simple imperative language in the style of [20], extended withsimple procedures:

C ::= x := e | [e] := e | x := [e] | x := alloc e | free e|

C; C | if e then C else C | while e do C | call x := f (_e)

2 The original definition of SA [6] also required cancellativity: that if oe0 .= oe ffi oe1 and

oe0 .= oe ffi oe2 then oe1 = oe2. This is too restrictive for our purposes, so we do not
include it in the general definition of a SA.

The commands are, respectively, assignment, heap write, heap read, allocation,deallocation, sequencing, conditional, loop and function call. The argument to
alloc specifies how many consecutive heap locations should be allocated.

There is no module system at the language level. When we talk about amodule in this paper, it simply refers to a collection of functions.

The operational semantics of the language is defined in a standard way, usingthe following memory model:

C : cmd (see above)
x, y : var , string
f : func name , string

l : loc , N
program , func name fin* var* * cmd * expr

v : val , loc ] {null} ] Z ] {true, false}
s : stack , var ! val

e : expr , stack ! val
h : heap , loc fin* val

Verification always takes place in an implicit global context of type programthat maps each function name to a parameter list, function body and return
expression. The only type of syntactic entities in this paper is cmd. Assertions,specifications, inference rules, and even programming language expressions, are
semantic. If desired, a syntactic system could be built on top of this, but it wouldserve no purpose in this paper.

As usual, heap is a separation algebra with composition being the union ofdisjoint maps and the identity being the empty map. In addition to the connectives from Section 2.1, the separation algebra of heaps also has the points-toassertion:

l 7! v , {[l 7! v]}. We make this more precise in Section 2.4.

2.3 Specification Logic
A specification S : spec is a logical proposition about the program under consid-eration. The specification logic has the connectives (?

, ?, ^, ., 8, 9, )) as oper-ators on spec and entailment (`) as a relation on spec. These interact according

to the standard rules of intuitionistic logic.

We assume that there is a definition of the Hoare triple {P } C {Q} : spec.Intuitively, if

S ` {P } C {Q}, then under the assumptions of S, if the command
C runs in a state satisfying P , it will not fault, and if it terminates, the resultingstate satisfies

Q. The Hoare triple is assumed to satisfy the standard structuraland command-specific rules of separation logic [20].

The definition of spec and the Hoare triple, as well as the proofs that theysatisfy the rules of separation logic, are standard and not important here. See,
e.g., [1] for a definition of spec that allows for (mutually) recursive proceduresand is formalized in Coq.

The assertions P, Q used in the Hoare triple are of type asn(heap), whereasn(

\Sigma ) , stack ! P(\Sigma ). Connectives and rules for P(\Sigma ) can be lifted pointwiseto asn(

\Sigma ), so we will conflate the two in the following.

2.4 Constructing Separation Algebras
In this subsection we record some simple ways of constructing separation alge-bras, which will be useful in the following.

Given a set A and a SA (\Sigma , ffi, 0), we write A fin! \Sigma  for the set of total maps
f : A ! \Sigma  for which only a finite number of values a : A have f (a) 6= 0. Thatis,

f has finite support. The set A fin! \Sigma  is itself a SA with composition beingpointwise and only defined when the composition in

\Sigma  is defined at every point.We let [
a 7! oe] be the map in A fin! \Sigma  which maps a to oe and every otherelement to 0. Observe that [

a 7! 0] is the constant 0 map.For
f : A fin! \Sigma , define supp(f ) = {a | f(a) 6= 0}.A permission algebra (PA) [6] is a partial commutative semigroup; i.e., it is

like a SA but may not have a unit element. The product of two PAs (SAs) isalso a PA (SA); composition is pointwise, and it is defined only when defined on
both components. Any set A can be seen as the empty PA (A;) by letting thecomposition be undefined for all operands. Moreover, any set

A can be seen asthe equality PA (
A=) by letting the composition have x ffi x .= x for all x andmaking it undefined for non-equal operands. Finally, any PA

\Pi  can be madeinto a SA
\Pi ? by adding a unit element.In this terminology, the SA of heaps is heap = loc

fin! val ;?.

3 Fictional Separation Logic
The basic idea of fictional separation logic is that assertions are not just expressedin a single separation algebra, chosen in advance to match the programming
language, but instead each module may define its own domain-specific SA. Eachsuch SA is interpreted into another SA and eventually to the SA of heaps. Given
separation algebras (\Sigma , ffi\Sigma , 0\Sigma ) and (\Sigma 0, ffi\Sigma 0, 0\Sigma 0), an interpretation I is of type

\Sigma  % \Sigma 0 , {I : \Sigma  ! P(\Sigma 0) | I(0\Sigma ) = {0\Sigma 0}}.
The side condition is not strictly necessary but will ease presentation later.3The logic revolves around the indirect triple, defined as

I. {P } C {Q} , 8OE. {9oe 2 P. I(oe ffi OE)} C {9oe 2 Q. I(oe ffi OE)}.
Here I is an interpretation map of type \Sigma  % heap, and P, Q : asn(\Sigma ), for thesame SA

\Sigma . The triple and the all-quantifier on the right-hand side are the onesfrom the standard specification logic (Section 2.3).

As mentioned in Section 2.3, we implicitly lift operators and constants fromP(
\Sigma ) into asn(\Sigma ). In the definition above, the (2) operator has been lifted inthis way for brevity. Following usual practice, there is also an implicit assumption that the partial composition is well-defined. Written out in full detail, theprecondition on the right hand side above is the following element of asn(heap):

*s : stack . {h | 9oe 2 P (s). 9oe0 .= oe ffi OE. h 2 I(oe0)}.
3 It simplifies the rule CreateL from Figure 1.

The postcondition is similar, only with Q instead of P .The quantification over all possible abstract frames

OE bakes the frame ruleinto the indirect triple definition, much as in [3], except that here the frame is

in a more abstract SA.The standard specification logic structural rules of

Consequence, Existsand
Frame hold for the indirect triple. For brevity we just show the frame rule:

modifies(C) " fv (R) = ; S ` I. {P } C {Q}

S ` I. {P * R} C {Q * R} Frame

Here, modifies(C) is the set of program variables possibly assigned to by C [20].The usual rules for control flow commands (

if, while, call and (;)) also hold.Proofs and a discussion of the conjunction rule are in the online appendix [14].

The unit interpretation on \Sigma  is simply 1\Sigma  , *oe : \Sigma . {oe}; it is used to relatethe standard separation logic triple to the indirect triple, as expressed by the
following rule:4

S ` 1heap. {P } C {Q}

S ` {P } C {Q} Basic
We typically drop the subscript on 1\Sigma  since it can be inferred from the context.

3.1 Proof patterns
In this subsection we include a couple of rules and lemmas that are often usefulfor reasoning about examples in fictional separation logic.

In practice, pre- and postconditions are often singletons, possibly conjoinedwith a pure assertion, i.e., one that either contains every

oe or no oe. The followingrule relates that special case to standard separation logic. The validity of this

rule follows easily from the definition of the indirect triple.

p, q pure S ` 8OE. {I(oe ffi OE) ^ p} C {I(oe0 ffi OE) ^ q}

S ` I. {{oe} ^ p} C {{oe0} ^ q} Enter1

The name of this rule, like all other rules in this paper, suggests reading it fromthe bottom up; i.e., given a proof obligation matching its conclusion, "enter" the

abstract scope by exchanging the conclusion for its premise.We will see in examples that interpretation functions often follow a particular
pattern. The following lemma records useful facts about this pattern. It uses theiterated separating conjunction [20] operator (8*), defined as

8* a 2 {a1, . . . , an}. P (a) , P (a1) * . . . * P (an).
Lemma 1. If I : (A fin! \Sigma ) % heap with I(f ) = 8* a 2 supp(f). P (a, f(a)), then

a. I(f ) * I(g) a` I(f ffi g) if supp(f ) " supp(g) = ;.b.

I(f ) * I(g) ` I(f ffi g) if 8a. (P (a, ) * P (a, ) ` ?).c. If

p, q are pure, then the following rule is valid.

S ` 8OE. {I([a 7! oeffiOE]) ^ p} C {I([a 7! oe0ffiOE]) ^ q}

S ` I. {{[a 7! oe]} ^ p} C {{[a 7! oe0]} ^ q}
4 Double lines mean that the rule can be used both from top to bottom and vice-versa.

3.2 Example: Bit Pair
We now return to the example of bit pairs from Section 1 and explain how toprove that the implementation with sharing meets the abstract module specification. (It is obvious how the na"ive implementation meets the specification:choose

I to be 1heap and apply Basic.)
Choose the witnesses of the existentials as follows (we convert freely betweenbool and {0

, 1}).

\Sigma  = loc fin! ({1, 2} fin! bool;?)
I(f ) = 8* p 2 supp(f ). supp(f(p)) = {1, 2} ^ p 7! (f (p)(1) + 2 * f (p)(2))
Bi(p, b) = {[p 7! [i 7! b]]}

Composition and unit in \Sigma  follows from the constructions in Section 2.4. Thisresembles the SA used for object-oriented languages, where each object may
have several fields.

The intuition behind the choice of I is that by requiring the support at eachpoint to be the full set, i.e., {1

, 2}, we can control what we expect to find inthe frame
OE. For a function such as bp get1, this means that since B1(p, b) isassumed in the precondition, we are sure to find

B2(p, b0) in the frame, for some
b0. Showing that the frame is preserved then amounts to showing that the framealso contains

B2(p, b0) after executing the function body - and showing that anyother
p0 6= p mentioned in the frame is unaffected, but we will see below thatLemma 1 on pointwise interpretation functions makes that easy.

We now have to show that the implementation of each function matches itsspecification with this choice of witnesses for the existentials. This is straightforward, because every function in this example has a specification that matches acombination of

Enter1 and Lemma 1. These rules reduce the proof obligationsto statements in standard separation logic.

First note that the following saturation lemma holds for the interpretationmap for bit pairs:

I([ 7! [i 7! b]ffiOE]) ` 9b0. OE = [3-i 7! b0].
We present here the proof of bp get1. Let C = (x := [p]), i.e., the body of
bp get1.

(trivial)8b
2. {p 7! (b + 2 * b2)} C {p 7! (b + 2 * b2) ^ x%2 = b} (definition)8

b2. {I([p 7! [17!b, 27!b2]])} C {I([p 7! [17!b, 27!b2]]) ^ x%2 = b} Saturation8

OE. {I([p 7! [17!b]ffiOE])} C {I([p 7! [17!b]ffiOE]) ^ x%2 = b} Lemma 1c

I. {{[p7![17!b]]}} C {{[p7![17!b]]} ^ x%2 = b} (definition)

I. {B1(p, b)} C {B1(p, b) ^ x%2 = b}

Notice that the overhead of showing that the abstract specification is met isfairly small and straightforward.

3.3 Example: Monotonic Counter
A monotonic counter is an integer stored in the heap with operations for readingit and incrementing it but not for decrementing it. The implementation could

look like this:

mc new() { c := alloc 1; [c] := 0; return c }
mc read(c) { x := [c]; return x }
mc inc(c) { x := [c]; [c] := x+1 }

Reasoning about monotonic counters was posed as a verification challenge byPilkiewicz and Pottier [19]. They discussed the challenge in a type-and-capability

system, so the presentation is somewhat different than for separation logic, butthe idea is the same. The counter should have a representation predicate MC (

c, i)that can be freely duplicated; i.e., MC (
c, i) ` MC (c, i) * MC (c, i). It should bepossible to frame out one of the copies while the other copy is used to call the

increment function; when the first copy is later framed back in, it can soundlybe used to call the read function since its postcondition only guarantees that the
returned value is at least the value from the representation predicate.The specification in fictional separation logic looks like this:

9\Sigma  : sepalg. 9I : \Sigma  % heap. 9MC : loc * Z ! P(\Sigma ).

(8c, j. 8i <= j. (MC (c, j) a` MC (c, j) * MC (c, i))) ^
I. {emp} mc new() {MC (ret, 0)} ^
(8i. I. {MC (c, i)} mc read(c) {MC (c, i) ^ ret >= i}) ^
(8i. I. {MC (c, i)} mc inc(c) {MC (c, i + 1)}).

The fact about MC has several corollaries that are useful for clients:

MC (c, i) a` MC (c, i) * MC (c, i)
i <= j ^ MC (c, j) ` MC (c, i) * ?MC (

c, i) * MC (c, j) ` MC (c, max (i, j))

Compared to the solution by Pilkiewicz and Pottier, this solution has severaladvantages. Our solution can be specified and verified without changing the

implementation to account for limitations in the verification system [19, end ofSect. 4]. Moreover, it can be verified in the simple system of fictional separation
logic, whereas there exists no soundness proof yet for the very complicated typesystem used by Pilkiewicz and Pottier.

To verify our specification against the implementation shown above, choosethe existentials as follows:

\Sigma  = loc fin! Z? where composition in Z is max
I(f ) = 8* c 2 supp(f ). 9j >= f(c). c 7! j
MC (c, i) = {[c 7! i]}

The property about MC is straightforward to verify in the assertion logic. Veri-fication of the three functions is shown in the online appendix [14].

S ` I * J. {P L} C {QL}

S ` I. {P } C {Q} CreateL

S ` I. {P } C {Q}
S ` I * J. {P L} C {QL} ForgetL

S ` I * J. {P L} C {Q * ?}

S ` I * 1. {P L} C {Q * ?} LeakL

p pure
(p ^ P ) * Q a` p ^ (P * Q) Prod-Pure

Fig. 1. Selected inference rules for separating products, using notation P L , P *emp

There are some limitations in the specification. There can be no function todeallocate a counter because its representation predicate can be freely shared.
The absence of deallocation means that this specification is more suited fora garbage-collected language. Also, the specification does not guarantee that
consecutive calls to mc read will return the same value; it would be valid toimplement

mc read such that it has the side effect of incrementing the counter.These limitations are also present in the specification by Pilkiewicz and Pottier.

4 Clients and Separating Products
To allow clients of multiple libraries to know about more than one separationalgebra and interpretation function, we introduce separating products of interpretations.Given interpretations

I1 : \Sigma 1 % \Sigma  and I2 : \Sigma 2 % \Sigma , their separating product
I1 * I2 has type \Sigma 1*\Sigma 2 % \Sigma  and is defined as

I1 * I2 , *(oe1, oe2). I1(oe1) * I2(oe2).
Figure 1 shows a collection of inference rules about separating products. Atthe bottom of a proof tree, just above application of

Basic, a client shoulduse
CreateL for each module that will be used. In that rule, P L , P * emp,where (*) is simply the Cartesian product lifted into asn. To write that out,

P1 * P2 , *s. {(oe1, oe2) | oe1 2 P1(s) ^ oe2 2 P2(s)}.The

CreateL rule requires the command C to clean up the state abstractedby
J completely; i.e., that state must satisfy emp in the postcondition. Whenthis is not possible, for example in the Monotonic Counters example, we can

instead use the LeakL rule.Before calling a library function, a client will, as usual, have to frame out
irrelevant facts. There, it can be useful to know that (P * Q)L a` P L * QL andthat

P * Q a` P L * QR, where P R , emp * P . After applying the frame rule,the client can then ignore the irrelevant separation algebras using the

ForgetLrule, which is just the
CreateL rule inverted.Pure assertions can move in and out of products as described by the

ProdPure rule. There are of course rules CreateR, ForgetR and LeakR sym-metric to the ones in Figure 1, and further structural rules can be defined to

handle commutativity and associativity with separating products.

4.1 Example: Client of Two Modules
Assume we have a client program C that uses both the bit pair and the mono-tonic counter modules, and we want to show that it has precondition emp and
postcondition ?. We suggest ? in the postcondition because there is no deallo-cation function for monotonic counters as mentioned earlier.

The standard pattern for this is to assume the module specifications at thebottom of the tree and then move from the standard triple to the appropriate
indirect triple by applying Basic once and then Create or Leak for eachmodule, reading from the bottom up. Abbreviate the bit pair and monotonic
counter specifications, minus the existentials, as Sbp and Smc respectively. Thebottom of the proof for

C then looks like this.

Sbp ^ Smc ` Ibp * Imc. {emp * emp} C {emp * ?} LeakL

Sbp ^ Smc ` Ibp * 1. {emp * emp} C {emp * ?} CreateR

Sbp ^ Smc ` 1. {emp} C {?} Basic

Sbp ^ Smc ` {emp} C {?} 9L
(9\Sigma , Ibp, B1, B2. Sbp) ^ (9\Sigma , Imc, M C. Smc) ` {emp} C {?}

The bottom proof step applies the standard existential-left rule from sequentcalculus twice.

If C uses the heap directly, not just through the two modules, it should apply
Create once more to get the interpretation Ibp * Imc * 1 on the indirect triple.

Further up in the proof tree, there will eventually be a point where it isnecessary to call a function belonging to one of the modules, e.g., the bit pairs.

The following pattern is used to ignore irrelevant modules during the call.

S ` Ibp. {P } call f {Q} ForgetL
S ` Ibp * Imc. {P L} call f {QL} Frame
S ` Ibp * Imc. {P L * R1L * R2R} call f {QL * R1L * R2R} Consequence

S ` Ibp * Imc. {(P * R1) * R2} call f {(Q * R1) * R2}

Note that this kind of reasoning will not be so explicit in practice; a simple toolcan easily elide these steps.

In this section we considered a generic client; see the online appendix [14] fora concrete example client using bit pairs and monotonic counters.

4.2 Example: Wrapper
This example demonstrates how a module can extend the abstraction of anothermodule by using a separating product. We will see that this example gives a compelling argument against solving the fiction-of-disjointness problem by letting theclient carry around an explicit but opaque frame as done in [16, Chapter 5].

Consider first the following specification of a collection data structure.
SColl(\Sigma  : sepalg, I : \Sigma  % heap, Coll : loc * Pfin(val ) ! P(\Sigma )) , 8c, V.

(Coll (c, ) * Coll (c, ) ` ?) ^
I. {emp} coll new() {Coll (ret, ;)} ^
I. {Coll (c, V )} coll free(c) {emp} ^
I. {Coll (c, V )} coll clone(c) {Coll (c, V ) * Coll (ret, V )} ^
I. {Coll (c, V )} coll contains(c, v) {Coll (c, V ) ^ ret = (v 2 V )} ^
I. {Coll (c, V )} coll add(c, v) {Coll (c, V [ {v})} ^
I. {Coll (c, V )} coll remove(c, v) {Coll(c, V \ {v})}.

This is a standard specification of a finite collection, except for the coll clonefunction. This function could be implemented by simply copying the contents of
the collection to a new data structure; in standard separation logic, that wouldbe the only possible implementation because of the (*) in the postcondition.

In fictional separation logic, it might also be implemented by using copyon write - the reference-counting technique in which the contents are initially
shared between two collections and only copied when the need arises becauseone of them is modified [17]. The purpose of including

coll clone here is to havea reason why this library should be specified with fictional separation logic.

Consider now a wrapper module of indirect references to collections. Theimplementation could be this:

wcoll new(c) { w := alloc 1; [w] := c; return w }
wcoll contains(w,v) { c := [w]; return coll contains(c,v) } . . .

Functions wcoll add, wcoll remove and wcoll free would be implemented analo-gously to

wcoll contains, forwarding the call. A more useful wrapper modulewould, of course, add some functionality, such as caching the last query to

wcoll contains or counting the number of calls to wcoll add, but the essence re-mains the same.

We can give the following specification to this code.
8\Sigma , I, Coll . SColl(\Sigma , I, Coll ) )9

WColl : loc * Pfin(val ) ! P(heap*\Sigma ). 8V.
1 * I. {Coll (c, V )R} wcoll new(c) {WColl (ret, V )} ^
1 * I. {WColl (w, V )} wcoll contains(w, v) {WColl (w, V ) ^ ret = (v 2 V )} ^ ...

Observe that this is an example of one specification depending on another, bybeing universal in the parameters of the

SColl specification from above. (See [1]for more general cases of this design pattern, in standard higher-order separation

logic.) For the example implementation above, the proof of the specificationshould instantiate the existential as WColl(

w, V ) = 9c. w 7! c * Coll(c, V ). Asa side remark, this specification could be made more abstract, so that it would

reveal less implementation detail, by hiding the use of the 1-interpretation behindan existential.

The specification of the constructor, wcoll new, is an example of ownershiptransfer: ownership of memory described by an abstract predicate (Coll (

c, V ))is transferred from the caller to the module. The specification intentionally does

not reveal whether the transfer happened simply by storing a pointer, as in ourexample implementation, or whether the constructor allocated a new collection
(or another container data structure), manually copied the contents of the givencollection to that, and then freed the given collection.

For comparison, to mimic this in standard separation logic, one could takeinspiration from Krishnaswami's design pattern [16, Chapter 5] and let the representation predicate of the collection module describe all the collections thatmay share data; i.e., H : P

fin(loc * Pfin(val )) ! P(heap). The constructor spec-ification would then be along the lines of the following, where ] denotes union

of sets of tuples with disjoint first components, and Coll 0(c, V ) , {(c, V )}.

{H (Coll 0(c, V ) ] OE)} wcoll new(c) {9oe. H (oe ] OE) * WColl 0(ret, oe, V )}.
This specification allows the same implementation freedom as the fictional sep-aration logic version does, and the caller is guaranteed that the abstract frame

OE is preserved. But it is a completely undesirable specification in practice be-cause the WColl 0 predicate can never be detached from the H predicate that it
may share data with. This means that all the accessor functions must have bothWColl 0 and H in their pre- and postconditions. Even worse, clients need to keep
track of the opaque oe that links the two together.

5 Indirect Entailment
There is no restriction that a physical heap can only be in the image of a singleabstract

oe. Therefore we can sometimes change abstract pre- and postconditionsin a more powerful way than what the rule of consequence allows; we present an

application of this idea in the next subsection. First, we define indirect entail-ment:

P |=I Q , 8OE. \Gamma (9oe 2 P. I(oe ffi OE)) ` (9oe 2 Q. I(oe ffi OE))\Delta .
We can now state the indirect rule of consequence:

P |=I P 0 S ` I. {P 0} C {Q0} Q0 |=I Q

S ` I. {P } C {Q} ROC-Indirect

Its correctness is immediate from the definitions.The definition of indirect entailment is quite similar to the indirect triple. In

fact, if I : \Sigma  % heap for some \Sigma , then P |=I Q if and only if ` I. {P } skip {Q}.For any

I, the relation (|=I ) is reflexive and transitive and is a superrelationof (`). Judgements

P |=I Q can also be studied as a kind of degenerate assertionlogic; in that case, the standard natural-deduction introduction and elimination

rules for (?, ?, ., 9) hold, and so do ())-introduction and (^, 8)-elimination. It

is also possible to reason locally on both sides of a separating conjunction, andthe existential-left rule holds; i.e.,

P |=I P 0 Q |=I Q0

P * Q |=I P 0 * Q0 8

x. (P (x) |=I Q)9

x. P (x) |=I Q

We discuss more rules for (|=I ) in the online appendix [14].

5.1 Example: Fractional Permissions
Permission accounting [5, 4, 10] is a solution to simple sharing problems wherejust read-only data is shared. The points-to predicate is generalized to carry a

permission, so l z7! v denotes a z-permission to access heap location l. If z is aread-only permission, then there are no write permissions to

l available to others,and therefore its value stays
v. If z is a write permission, then there are no otherread or write permissions for

l available to others.A write permission can be split across the * into several read-only permissions. If it is known that all read-only permissions have been accounted for, thenthey can be re-assembled into a write permission. Permissions are clearly useful
for sharing data read-only between threads in concurrent programs, but it alsohas uses in a sequential setting [13, 15].

We will now show how fractional permissions, a particular permission ac-counting scheme, can be encoded in fictional separation logic. This allows us to
use fractional permissions where we need it, without having fractional permis-sions in the base logic! A permission

z is a rational number satisfying 0 < z <= 1.The write permission is 1, and all smaller numbers are read-only permissions. We

will define the assertion l z7! v such that the splitting and joining of permissionscan be described by the following inference rule.

Fractionsl z17! v
1 * l

z27! v

2 a` v1 = v2 ^ z1 + z2 <= 1 ^ l 7

z1+z2----! v

1

We first define the SA of heaps with fractional permissions as usual [4]:

\Sigma fp , Ptr fin! (Val = * Perm)?, where
Perm , {z : Q | 0 < z <= 1}

z1 u z2 , (z1 + z2 if z1 + z2 <= 1undefined otherwise

Since (Perm, u) is a permission algebra, \Sigma fp is a separation algebra (see Section 2.4). We define the fractional points-to predicate by l z7! v , {[l 7! (v, z)]}and can then easily verify the

Fractions rule.To make use of all this, we define an interpretation

Ifp : \Sigma fp % heap. The ideais the same as for the interpretation function in the bit pair example (Section 3.2):

assume we have the full knowledge (permission) for each described heap location.

Ifp(f ) , 8* l 2 supp(f). 9v. f(l) = (v, 1) ^ l 7! v.

We can now prove a specification of the heap read command for fractionalpermissions. For clarity, let us just consider the case where the variable name
being assigned to is fresh (formally we treat free variables as in [1]):

x /2 fv (e, e0)`
Ifp. {e z7! e0} x := [e] {e z7! e0 ^ x = e0}

Let us sketch the proof of this rule. We first expand the definition of the fractionalpoints-to predicate in the conclusion:

` Ifp. {{[e 7! (e0, z)]}} x := [e] {{[e 7! (e0, z)]} ^ x = e0}.
By applying Lemma 1c, we can reduce this to the proof obligation

` 8OE. {Ifp([e 7! (e0, z) ffi OE])} x := [e] {Ifp([e 7! (e0, z) ffi OE]) ^ x = e0},
which is now a statement in standard separation logic that can be dischargedusing a saturation lemma like in Section 3.2. Intuitively,

Ifp in the preconditiongives us the points-to predicate needed for applying the standard read rule. The

postcondition requires us to prove that Ifp holds for the same parameter, whichis easy since the heap did not change.

We can also prove the write and allocation rules using the above approach,but we will instead show how to use indirect entailment to get even simpler
proofs. The following indirect bi-entailment expresses that having the full per-mission to a location (

z = 1) is the same as having a standard points-to predicatefor it:

(l 17! v)L =||=Ifp*1 (l 7! v)R
With this lemma, proved in the online appendix [14], the write and allocationrules follow almost immediately from their standard separation logic versions.

For instance, the fractional write rule is derived as follows.

Basic, Write-std` 1. {e 7! } [e] := e0 {e 7! e0}

ForgetR` I
fp * 1. {(e 7! )R} [e] := e0 {(e 7! e0)R} ROC-Indirect`

Ifp * 1. {(e 17! )L} [e] := e0 {(e 17! e0)L} CreateL

` Ifp. {e 17! } [e] := e0 {e 17! e0}

6 Stacking
Intuitively, fictional separation logic allows us to pretend we are working in ahigh-level memory model

\Sigma  if we show how to interpret that high-level memorymodel down to heap. It is then natural to investigate whether we can stack an

even higher-level memory model \Sigma 0 on top of that construction and interpret \Sigma 0down to

\Sigma . Of course, this should generalize to arbitrary levels of stacking.In this section, we present a theory of stacking that allows this while interacting well with the features introduced in previous sections and not being

a burden on the logic when not in use. It is important to stress that it is inmany cases possible for one module to depend on and extend the abstraction of
another module without using stacking; c.f. the wrapper example in Section 4.2.The most basic way to combine two interpretations is to compose them as
relations. Given interpretations I : \Sigma 1 % \Sigma 2 and J : \Sigma 2 % \Sigma 3, their relationalcomposition (

I ; J) has type \Sigma 1 % \Sigma 3 and is defined as

I ; J , *oe1. 9oe02 2 I(oe1). J(oe02).
That is, oe3 2 (I ; J)(oe1) if and only if 9oe02 2 I(oe1). oe3 2 J(oe02).We can show the following rule for working with relational composition:

S ` 8OE. J. {9oe 2 P. I(oe ffi OE)} C {9oe 2 Q. I(oe ffi OE)} RelComp

S ` (I ; J). {P } C {Q}
Reading the rule from the bottom up, RelComp allows peeling off the top layerof a multi-layered interpretation, making its frame explicit. This is desirable

when verifying an implementation that extends upon the J-interpretation using
I. Perhaps J is opaque at the point where this rule is applied.Relational composition masks the

J-interpretation to the outside; in partic-ular, it masks the frame in
\Sigma 2 that goes into J, which means that the converseof
RelComp does not hold. In many situations, including the next example, wewant to give specifications that expose both the

\Sigma 1-algebra and the \Sigma 2-algebrain order to be useful to clients that do not have their data exclusively in

\Sigma 1. Thisdiscussion motivates our definition of the stacking composition. Given interpretations I : \Sigma 1 % \Sigma 2 and J : \Sigma 2 % \Sigma 3, their stacking I \Upsilon  J has type \Sigma 1*\Sigma 2 % \Sigma 3and is defined as

I \Upsilon  J , (I * 1) ; J.
With this definition, we now get a generalization of RelComp in the form ofthe following rule, which holds in both directions:

S ` 8OE. J. {9oe 2 P1. I(oe ffi OE) * P2} C {9oe 2 Q1. I(oe ffi OE) * Q2} StackComp

S ` I \Upsilon  J. {P1*P2} C {Q1*Q2}
The special case of this rule where P2 = Q2 = emp is similar to RelComp.The special case where

P1 = Q1 = emp leads to a rule that is more like a stackingversion of
Forget and Create (Section 4).There is a generalization of the

Enter1 rule to stacking:

S ` 8OE. J. {I(oe ffi OE) * P } C {I(oe0 ffi OE) * Q} Enter1Stack

S ` I \Upsilon  J. {{oe} * P } C {{oe0} * Q}

This rule is simply a special case of StackComp. Notice that (I \Upsilon  1) = (I * 1),so these inference rules can also be applied to separating products in some cases.

A module may use stacking internally but hide that fact if the stacking doesnot need to be visible to its clients. This can be achieved by collapsing the
stacking composition to a relational composition by the following rule:

S ` I \Upsilon  J. {P L} C {QL} StackRel

S ` (I ; J). {P } C {Q}

6.1 Example: Abstract Fractional Permissions
We saw the example of fractional permissions in Section 5.1, where the points-to predicate was extended to carry a permission. With stacking, we can use
essentially the same construction to extend the Coll predicate from Section 4.2to carry a permission. Just like the heap-read command could execute with any
partial permission, while heap write required full permission, we can prove that
coll clone and coll contains can execute with any partial permission, while theother functions require full permission.

Formally, we can prove the validity of the following specification.
8\Sigma , I, Coll . SColl(\Sigma , I, Coll ) )9

\Sigma 0 : sepalg. 9I0 : \Sigma 0 % \Sigma .9
FColl : Perm * loc * Pfin(val ) ! P(\Sigma 0). 8V, V 0, c, z, z0.

(FCollz(c, V ) * FColl z0(c, V 0) a` V = V 0 ^ z + z0 <= 1 ^ FColl z+z0(c, V )) ^
(FColl1(c, V )L =||=I0\Upsilon I Coll (c, V )R) ^
I0 \Upsilon  I. {FColl z(c, V )L} coll contains(c, v) {FCollz(c, V )L ^ ret = (v 2 V )} ^
I0 \Upsilon  I. {FColl z(c, V )L} coll clone(c) {FColl z(c, V )L * FColl 1(ret, V )L}.

The elements of the specification are all the same as for the standard fractionalpermissions in Section 5.1. It is written such that the stacking is revealed to
clients, allowing them to use the fractional and non-fractional collections togetherand convert between them using the indirect bi-entailment in the specification.
There is thus no need for specifying fractional versions of the remaining functionssince the indirect bi-entailment allows reusing the original specifications.

Notice that we can define FColl and prove fractional versions of all the func-tions without knowing their implementation or how Coll ,

I or \Sigma  are defined.In particular, the implementations of
coll clone and coll contains are allowed tomodify the underlying heap, but they still appear read-only through the indirect

specification.

If it is not necessary for fractional and non-fractional collections to coexistand share footprints from the perspective of clients, the

StackRel rule couldbe used to hide the stacking in this specification. Then the specification can

be made to look as simple as the original specification in Section 4.2 by hiding(

I0 ; I) behind an existential.

We can verify the specification by choosing the existentials as follows:

\Sigma 0 = loc fin! (Pfin(val )= * Perm)?
I0(f ) = 8* c 2 supp(f ). 9V. f (c) = (V, 1) ^ Coll (c, V )
FColl z(c, V ) = {[c 7! (V, z)]}

This is very similar to the original fractional permissions example, and theproofs are also similar.

7 Discussion and Related Work
Simplicity has been a major goal for this theory, particularly in three places:(1) clients of a module that uses fictional separation internally should be able
to reason with the same ease as in standard separation logic; (2) the overheadin verifying an implementation with fictional separation should be minimal; and
(3) correctness of the meta-theory should be easy to prove. The three goals arelisted in order of importance since they represent tasks to be carried out by a
decreasing number of people.We believe that the first simplicity goal has been achieved in most situations,
though clients of multiple modules with complex stacking patterns may benefitfrom tool support for composing the interpretations. The second goal has been
achieved in the sense that it is easy to verify examples like those presentedin this paper and, moreover, the separation algebras needed can be assembled
from standard constructions. The third goal has been reached through judiciouschoice of definitions, especially by defining the indirect triple in terms of the
standard triple - it has been possible to conduct all meta-theoretical proofswithout unfolding the definition of the standard triple [14]. Because we work
directly in the semantics of the logic, it should be natural to encode this theoryin the Coq proof assistant, extending our existing Coq formalization of separation
logic [1].A major inspiration for fictional separation logic has been the design pattern used by Krishnaswami [16, Chapter 5] for specifying data structures withfictional disjointness in standard separation logic. The technique is to define a
per-module custom separation logic (not separation algebra) and let the clientmanage the abstract frame, which is explicitly present in every function specification. Fictional separation logic makes the essential part of this design patternformal, allowing the abstract frame to be managed implicitly by the indirect
triple and enabling a general and comprehensive theory on these custom separa-tion logics, instead of scattering the theory across modules on an ad-hoc basis.
See also the discussion in Section 4.2. We ignore Krishnaswami's concept of aramification operator since it would make the resulting logic too different from
separation logic.The work on locality-breaking transformations (LBT) for context logic, a kind
of non-commutative separation logic, by Dinsdale-Young, Gardner and Wheel-house [8, 9] can also be seen as a formalization of Krishnaswami's design pattern,
though they were developed independently. LBT is in the field of program re-finement, which means that not only are pre- and postconditions of a triple
transformed across abstraction layers, like in fictional separation logic, but thecommand is also transformed. Despite that difference, the intuition and proof
obligations are similar to fictional separation logic: verifying a module implemen-tation involves showing that all atomic operations preserve an abstract frame
from a per-module context algebra. Reasoning in LBT is fundamentally in twostages, though: a client program and proof are always created at the high level
and are subsequently transformed to the low level outside the logic. In fictionalseparation logic, moving between the levels is done within the logic itself, and the

separation algebras are first-class entities in the logic. Hence, as we have seen, wecan take advantage of all the features in the specification logic, e.g., to hide the
definition of a separation algebra behind an existential quantifier. The soundnessproofs of the meta-theory in [9] are much more complicated than ours, despite
their much less expressive specification logic; it appears to be caused by theirproof-theoretic approach to soundness as opposed to our semantic approach.

In terms of what examples can be encoded, fictional separation logic is quiteclose to the concurrent abstract predicates (CAP) framework [7, 11] restricted to
sequential programs. CAP has been developed for reasoning about concurrentprograms in which several threads may work on the same shared memory; when
restricting attention to sequential programs, CAP thus allows to specify andreason about modules that are implemented using sharing. The CAP approach,
seen from our perspective, is to fix one particular separation algebra for all mod-ules, which is sufficiently powerful to handle most cases of sharing. The algebra
is specialized to each module by giving a per-module protocol definition, withaccess to the various stages in the protocol controlled by permission accounting.
These explicit protocols, describing what atomic modifications may be performedon shared memory regions, give verification tasks a completely different flavour
and intuition compared to fictional separation logic. In a sequential setting, thetwo systems are therefore very different solutions to the same problem. Concurrent abstract predicates is fundamentally rooted in a concurrent setting, though,which complicates the proof system. In particular, program verification requires
showing stability of all intermediate pre- and postconditions in a proof.Future work includes extending fictional separation logic to richer programming languages. Our preliminary investigations suggest that it is straightforwardto extend the logic to a language with function pointers, by using the idea of
nested triples [21] to specify such pointers. In fictional separation logic we will,of course, use indirect nested triples. To make it possible to call a function

fwith a function argument that uses an interpretation stacked on top of
f 's owninterpretation, one can specify both
f and its argument through a stacking ofinterpretations.

We are also interested in extending fictional separation logic to a concurrentlanguage in order to find out whether it can retain its simplicity.

Acknowledgements. We would like to thank Jesper Bengtson, Thomas Dins-dale-Young, Filip Sieczkowski, Kasper Svendsen, Peter Sestoft and Jacob Thamsborg for helpful feedback and discussions.

References

1. Bengtson, J., Jensen, J.B., Sieczkowski, F., Birkedal, L.: Verifying object-oriented

programs with higher-order separation logic in Coq. In: Proceedings of ITP (2011)
2. Biering, B., Birkedal, L., Torp-Smith, N.: BI-hyperdoctrines, higher-order separation logic, and abstraction. ACM Transactions on Programming Languages and
Systems 29(5) (2007)

3. Birkedal, L., Torp-Smith, N., Yang, H.: Semantics of separation-logic typing and

higher-order frame rules for algol-like languages. Logical Methods in Computer
Science 2(5:1) (Aug 2006)
4. Bornat, R., Calcagno, C., O'Hearn, P.W., Parkinson, M.J.: Permission accounting

in separation logic. In: Proceedings of POPL. pp. 259-270 (2005)
5. Boyland, J.: Checking interference with fractional permissions. In: Proceedings of

SAS (2003)
6. Calcagno, C., O'Hearn, P.W., Yang, H.: Local action and abstract separation logic.

In: Proceedings of LICS (2007)
7. Dinsdale-Young, T., Dodds, M., Gardner, P., Parkinson, M., Vafeiadis, V.: Concurrent abstract predicates. In: Proceedings of ECOOP (2010)
8. Dinsdale-Young, T., Gardner, P., Wheelhouse, M.: Abstraction and refinement for

local reasoning. In: Proceedings of VSTTE (2010)
9. Dinsdale-Young, T., Gardner, P., Wheelhouse, M.: Abstraction and refinement for

local reasoning (February 2011), journal submission
10. Dockins, R., Hobor, A., Appel, A.W.: A fresh look at separation algebras and share

accounting. In: Proceedings of APLAS (2009)
11. Dodds, M., Jagannathan, S., Parkinson, M.J.: Modular reasoning for deterministic

parallelism. In: Proceedings of POPL (2011)
12. Gotsman, A., Berdine, J., Cook, B.: Precision and the conjunction rule in concurrent separation logic. In: Proceedings of MFPS (2011)
13. Haack, C., Hurlin, C.: Resource usage protocols for iterators. In: Proceedings of

IWACO (2008)
14. Jensen, J.B., Birkedal, L.: Fictional separation logic: Appendix (2011),

http://itu.dk/ jobr/research/fsl-appendix.pdf
15. Jensen, J.B., Birkedal, L., Sestoft, P.: Modular verification of linked lists with views

via separation logic. Journal of Object Technology 10, 2:1-20 (2011)
16. Krishnaswami, N.R.: Verifying Higher-Order Imperative Programs with HigherOrder Separation Logic. Ph.D. thesis, Carnegie Mellon University (2011)
17. Meyers, S.: More Effective C++: 35 New Ways to Improve Your Programs and

Designs. Addison-Wesley Professional, first edn. (1996)
18. Parkinson, M.J., Bierman, G.M.: Separation logic and abstraction. In: Proceedings

of POPL. pp. 247-258 (2005)
19. Pilkiewicz, A., Pottier, F.: The essence of monotonic state. In: Proceedings of TLDI

(2011)
20. Reynolds, J.C.: Separation logic: A logic for shared mutable data structures. In:

Proceedings of LICS. pp. 55-74 (2002)
21. Schwinghammer, J., Birkedal, L., Reus, B., Yang, H.: Nested Hoare triples and

frame rules for higher-order store. In: Proceedings of CSL (2009)