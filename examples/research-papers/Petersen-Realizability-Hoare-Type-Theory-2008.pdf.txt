

A Realizability Model for Impredicative Hoare

Type Theory

Rasmus Lerchedahl Petersen1, Lars Birkedal1, Aleksandar Nanevski2, andGreg Morrisett

2

1 IT University of Copenhagen{rusmus | birkedal}@itu.dk

2 Harvard University{aleks | greg}@eecs.harvard.edu

Abstract. We present a denotational model of impredicative Hoare
Type Theory, a very expressive dependent type theory in which one can
specify and reason about mutable abstract data types.
The model ensures soundness of the extension of Hoare Type Theory with
impredicative polymorphism; makes the connections to separation logic
clear, and provides a basis for investigation of further sound extensions
of the theory, in particular equations between computations and types.

1 Introduction
Dependent types provide a powerful form of specification for higher-order, func-tional languages. For example, using dependency, one can specify the signature of
an array subscript operation as sub : 8 ff . \Pi  x:ff array.\Pi  y :{i:nat | i < x.size} . ff,where the type of the third argument,

y, refines the underlying type nat usinga predicate that ensures that
y is a valid index for the array x.Dependent types have long been used in formal mathematics, but their use in

practical programming languages has proven challenging. One of the main rea-sons is that the presence of any computational effects, including non-termination,
exceptions, access to store, or I/O - all of which are indispensable in practicalprogramming - can quickly render a dependent type system unsound.

This can be addressed by restricting dependencies to only effect-free terms(e.g. as in DML [27]). But the goal of our work is to realize the full power of
dependent types for specification of effectful programs. We have been developingthe foundations of a language that we call Hoare Type Theory or HTT [18, 17],
which we intend to be an expressive, explicitly annotated internal language, pro-viding a semantic framework for elaborating more practical external languages.

HTT starts with a pure, dependently typed core language and augments itwith an indexed monadic type of the form {

P }x:A{Q}. This type encapsulateseffectful computations that may diverge or access a mutable store. The type

can be read as a Hoare-like partial correctness specification, asserting that if thecomputation is run in a heap satisfying the pre-condition

P , then if it terminates,it will return a value
x of type A and leave a heap described by Q. ThroughHoare types, the system can enforce soundness in the presence of effects. The

Hoare type admits small footprints as in separation logic [23, 19], where the preand postconditions only describe the part of the store that the program actuallyuses; the unspecified part is automatically assumed invariant.

The most distinguishing feature of HTT in comparison with other recentproposals for Hoare- and separation logics for higher-order languages [4, 14, 28,
15] is that specifications in HTT are integrated with types. In Hoare logic, it isnot possible to abstract over specifications in the source programs, aggregate the
logical invariants of the data structures with the data itself, compute with suchinvariants or nest the specifications into larger specifications or types. These features are essential ingredients for data abstraction and information hiding, anda number of works have been proposed towards integrating Hoare-like reasoning with type checking. Examples include tools and languages like Spec# [2],SPLint [12], ESC/Java [11], and JML [10].

Our prior work on HTT [18, 17] addresses several of the main challengesfor languages for integrated programming and verification [10]: (1) we allow
effectful code in specifications by granting such code first-class status, via themonad for Hoare triples; (2) we control pointer aliasing, by employing the small
footprint approach of separation logic; and (3) we use higher-order logic to allowfor a uniform approach to programming and verification of imperative modules
(aka mutable abstract data types), as suggested for separation logic in [5, 6]. Inour earlier work on HTT we proved soundness of the type theory via mostly
operational methods, by proving progress and type preservation results. Theoperational proof was combined with a very crude denotational model, which
just served to show that the assertion logic of HTT was sound. To deal withdependent types the operational proofs relied heavily on sophisticated techniques
involving so-called hereditary substitutions [26].

In this paper we define a realizability model for an extension of Hoare TypeTheory with impredicative polymorphism. Apart from the inherent interest in

obtaining a denotational model, which provides an alternative more abstractconceptual understanding of the theory, the model serves the following purposes:

- Using the model we can prove soundness / consistency of an extension ofHoare Type Theory with impredicative polymorphism. Impredicative polymorphism is important for data abstraction (we show an example below)and for representing certain compiler transformations, such as closure conversion [16], in HTT. It is well-known that the operational methods involvinghereditary substitutions mentioned above do not easily scale to impredicative
polymorphism. We emphasize that it is highly non-trivial to devise a modelof dependent type theory combining an impredicative universe of types with
a classical logic and with computation types supporting fixed point induc-tion. We summarize the key challenges involved later on in this introduction.
- The model allows us to use syntax and typing rules that have a more naturalreading; in earlier presentations of HTT the operational techniques forced

clunkier terms (in order to get the theorems to go through). In particular,the syntax for computations is fairly close to the one employed in separation
logic. Our impredicative HTT is the first model of separation logic for suchan expressive language (higher types and impredicative polymorphism).

- We can finally introduce some non-trivial equations on computations. Theoperational approach we took before largely precluded this.
It is non-trivial to construct sound models of sophisticated dependent type the-ories such as HTT. Models for various fragments of dependent type theories
have been studied intensively in categorical type theory; see, e.g., [13] and thereferences therein. Thus we shall make use of results from categorical type theory to prove that we construct a sound model of impredicative HTT, but weshall always write out the definitions in explicit terms so as to make the paper
reasonably self contained. We now give an intuitive overview of the development.
Overview of HTT HTT is a dependent type theory with types and kinds,where types are included in the kinds, and where types and kinds can both
depend on kinds (and thus types). Thus contexts \Gamma  assign kinds to variablesand there are judgments

\Gamma  ` o/ : Type and \Gamma  ` A : Kind to conclude that o/ isa well-formed type in context

\Gamma  and that A is a well-formed kind in context
\Gamma  . Type and kind formers include dependent product (\Pi ) and dependent sum(

\Sigma ). In the extension with impredicative polymorphism that we consider in thispaper, we have that Type is a kind. Thus this part of pure impredicative HTT

is (weak) Full Higher-order Dependent Type Theory (FhoDTT) [13].In addition to types and kinds, HTT also includes a logic for reasoning about
terms in context. Thus there is a judgment \Gamma  ` P : Prop for concluding that Pis a well-formed proposition and a judgment

\Gamma  | P1, . . . , Pn ` P for logicalentailment. The logic is higher-order, so Prop is a kind. In Jacobs's terminology

we thus have a Higher-order Dependent Predicate Logic over (weak) Full Higher-order Dependent Type Theory [13]. The extra feature of HTT is that it includes a
type for computations \Gamma  ` {P } x : o/ {Q} : Type. Here P and Q are propositionsin context

\Gamma  and \Gamma , x : o/ , respectively. The intuition is that elements of thistype consist of computations, which, given a heap satisfying

P either diverges orproduces a value of type
o/ and a heap in Q. Note that computations can diverge;term formers for computations include a fixed point term.

The great benefit of impredicative polymorphism is that for any type o/ ,
\Pi  ff : Type . o/ is also a type, even if o/ depends on ff. Thus terms of thispolymorphic type can be returned by computations and stored in memory. Prop

is also a kind. So again \Pi P : Prop . o/ is a type where o/ may depend on P .This enables us to abstract over predicates in computation types. Using that
\Sigma P : Prop . o/ is a type, we can pack computations with abstract invariants andhide implementation details. As an illustration of both of these features consider
the following type of abstract stacks:

stacktype = \Pi ff:Type . \Sigma fi :Type.\Sigma  inv :fi * ff list ! Prop .

/ * new * / (-).{emp}s:fi{inv(s, [])} *
/ * push * / \Pi s:fi . \Pi x :ff . (l :ff list).{inv(s, l)}u:1{inv(s, x :: l)} *
/ * pop * / \Pi s:fi . (x:ff, l :ff list) . {inv(s, x :: l)}y :ff{inv(s, l) ^ y =ff x} *
/ * del * / \Pi s:fi . (l :ff list).{inv(s, l)}u:1{emp}

The contexts before the precondition in the computation types, e.g., (l : ff list)for

push, universally binds auxiliary / logical variables used in the specifications.

A term of type stacktype accepts a type ff and produces a stack of elements ofthis type. Such a stack consists of

- fi, an abstract type to be thought of as ff stack.-

inv, an abstract invariant that expresses that objects of type fi representfunctional stacks (as described by

ff list).- Operations
new, push, pop, and del. Notice, that push, pop, and del requirean element of type

fi, and that the only way to obtain one such is via new.

Since stacktype is by impredicativity itself a type, we can have stacks of stacks.More generally, we can compose first-class abstract data types (i.e., objects)

without needing to artificially stratify them which is necessary in modern pro-gramming. Note that in separation logic parlance the types are tight. For instance, the precondition for new is simply emp, so new does not rely on the inputheap; the frame rule ensures that

new can also be used with the following type(-)
.{emp * R}s: fi{inv(s, []) * R}, for any R. Further observe that implementorsof the above abstract stack type are free to choose both the representation type

fi and the representation predicate inv. For example, an implementation usinglinked lists could take

fi to be Nat (since we use Nat as the type of locations) and
inv(s, l) to be the predicate that holds if s points to a linked list representationof

l. A simple example client that creates a new Nat stack, pushes 4, pops itagain to return it and deletes the stack would then look like this:

C = *S :stacktype . do SNat  ret S(Nat) in

unpack SNat as (fi, inv, new, push, pop, del) in

do s  new in push(s)(4); do n4  pop(s) in del(s); ret n4

Then C has type \Pi S : stacktype . (-).{emp}n : Nat{emp ^ n =Nat 4}. We often(as in

C) abbreviate do y  M in N to M; N when y does not occur in N .Computations are not only needed for accessing the store but also for nontermination as the pure fragment does not include fixed points. As an exampleof a simple fixed point computation (not using the store), consider the factorial
function fac : T , where T = \Pi n : Nat . (-).{emp}m : Nat{emp ^ m =Nat n!}:

fac = fix f(n) in case n of

zero ) ret 1 or
succ y ) do m  f(y) in ret m * succ y

We can implement another version of factorial using the store but with thesame type, in the following manner. First we define a term

f acS : TS, where
TS = \Pi l : Nat . (n : Nat).{l 7!Nat n}u : 1{l 7!Nat n!}:

facS = fix f(l) in do t  !Nat l in case t of

zero ) l :=Nat 1 or
succ y ) do ly  allocNat y in

f(ly); do ty  !Nat ly in l :=Nat ty * succ y; dealloc ly

Given this we can implement the factorial function as

fac0 = *n :Nat . do l  allocNat n in facS(l); do r  !Nat l in dealloc l; ret r
Now f ac0 has the same type T as fac. Using the model, we can prove that
fac =T fac0, so we can use them interchangeably when reasoning in the logic.This could not be done in earlier versions of HTT.

Overview of Model Our model is a realizability model, built over a univer-sal domain

V , which is sufficiently rich to model divergent computations. Thedomain
V also includes a subdomain of computations, called T(V ).

The model for the weak FhoDTT part of HTT is mostly standard (see,e.g.,[13, Examples 11.6.5 and 11.6.7]): types are interpreted as chain-complete

partial equivalence relations (complete pers) over V and kinds are interpretedas so-called assemblies (aka

!-sets) over V . The category of assemblies is anextension of the category of sets and functions which contains the category of

complete pers as a full subcategory. The latter ensures that we soundly modelthat types are included among kinds. Moreover, the collection of all complete
pers form a set and hence an assembly, and thus we model that Type is a Kind.Terms with type

\Pi x : o/.oe are modeled as set-theoretic functions between the setof equivalence classes for the pers interpreting

o/ and oe which are realized by anelement in
V . That is, there is a continuous function from V to V that mapsrelated elements in the first per to related elements in the second per. In reality,

the model is a bit more complicated since we have to deal with families of typesand kinds to model that types and kinds depend on kinds. Hence everything is
indexed/fibred over the category of assemblies.

The propositions in HTT correspond to what is often called assertions inHoare and separation logic. We model our classical propositions using the power

set of heaps. Formally, we prove that the standard BI-hyperdoctrine [5] over Setcan be extended to one over assemblies, and this guarantees that we get a sound
model of the higher-order assertion logic (now for dependent types and kinds).

Finally, computation types are modeled roughly as follows. A computationtype

\Gamma  ` (\Delta ).{P }x : o/ {Q} : Type is modeled as an admissible per of continuousfunctions from Heap to

V * Heap (or, rather, as a family of such, indexed overthe interpretation of
\Gamma  ). A per is admissible if it relates the bottom element toitself and is complete. Admissibility is needed for interpreting fixed points. An

interesting issue is what per one should use on heaps. We have decided to use aper which equates two heaps if they have the same domain. This ensures that allocation of new heap cells, modeled here as taking the least unallocated address,will preserve the partial equivalence relation. This description is a bit rough for
the following reasons. First, the interpretation ensures that computations canonly access memory that is either described by the precondition

P or allocatedduring the computation. Second, the interpretation uses the chain-complete closure of the post-condition Q. This ensures that the computation type really isinterpreted as an admissible per. Taking the admissible closure is an alternative
to restricting propositions to a fragment that always generates admissible pers orusing test-functions/biorthogonality [9] to force admissibility. Third, the interpretation builds in the frame rule from separation logic, essentially by interpret-ing

\Gamma  ` (\Delta ).{P }x : o/ {Q} : Type as \Gamma  ` 8R : Prop.(\Delta ).{P * R}x : o/ {Q * R} : Type,at the modeling level. This idea comes from [8, 9]; type theoretically the idea

was also used in the earlier formulations of HTT [18, 17].

In HTT every pure term can also be viewed as a computation. In the modelthis holds because pure terms are modeled via continuously realized functions,

and such can be extended to continuous computations. Note that in a cruder set-theoretic model of the pure fragment of HTT, with types as sets with bounded
cardinality and kinds as all sets, we would not be able to extend every pure term(any function, not necessarily continuous) to a continuous computation.

Let us summarize our informal overview of the model by mentioning whatthe key technical challenges are in constructing a model: First, note that our
impredicative HTT combines a classical logic with an impredicative universeof types. Consistency, the very existence of a non-trivial model, is therefore
highly non-trivial. It hinges on the fact that impredicative HTT does not includefull subset types or the axiom of unique choice (that every functional relation
determines a term). Second, note that we need to model types as some kind ofdomains in order to accomodate fixed points for the computation types, and, at
the same time, types should form an impredicative universe. That is why we usechain-complete pers and not the more standard model of FhoDTT using all pers,
and thus we need to prove that we actually do get a model of HTT using suchpers. Third, we need to find chain-complete pers for modelling the computation
types. Finally, since the logic is over dependent types we need to prove that wecan get a model of separation logic over dependent types.

Related Work In the previous section we have given some pointers to relatedwork on models of separation logic and categorical models of dependent type
theory. Other very related work includes the recent step-indexed model by Ap-pel et. al. [1], where they describe a model that can be used for the types of
imperative languages. However, their model is for a much simpler type systemthan the one we consider since we deal with dependent types involving pre- and
postconditions. Appel et. al. do, however, include a treatment of recursive types;we have left that for future work. It is more challenging in our setting, since our
types are much more expressive. (Recursive types should exist, though, sinceadmissible pers do accomodate a wide range of recursive types [7].) In contrast
with Appel et. al. we further include a logic to reason about terms; so far it isnot well-understood how to model logics in step-indexed models.

Let us also emphasize the relation to the work of Honda, Yoshida, and Bergeron Hoare logics for higher-order languages (see [28] and the references therein).
One of the differences between the two approaches is that Honda et. al. donot allow for equational reasoning among functions (as we do in dependent
type theory). Instead they make use of an evaluation predicate. Intuitively, theevaluation predicate of Honda et. al. can be used to represent in the logic the
distinction between pure terms and computations that we instead capture usingthe monadic language. Honda et. al. have so far focused on total correctness
and have thus avoided the need for admissibility, which we have to deal withas we consider partial correctness and have a rule for fixed point induction.
Honda et. al. are able to deal with recursion through the store, but do not coverimpredicative polymorphism.

The remainder of the paper is organized as follows: In Section 2 we presentthe language of impredicative HTT, and in Section 3 the model. In Section 4 we

conclude and describe future work. For reasons of space the formal treatment isbrief, please see the accompanying technical report [20] for more details.
2 Language
The grammar for types, kinds, propositions, terms and computations is as fol-lows:

Types o/, oe, ae ::= Nat | 1 | \Pi T x:A . o/ | \Sigma T x:A . o/ | (\Gamma  ).{P }x :o/{P }
Kinds A, B ::= o/ | Type | Prop | \Pi K x:A . A | \Sigma K x:A . A
Prop0s P, Q, R ::= ? | ? | M =A M | P ^ P | P . P | P oe P | ~P |8

x :A . P | 9 x :A . P | emp | M 7!o/ M | P * P | P -* P
Terms M, N ::= x | zero | succ M | recNat(M, M) | () | *K x :A.M |

*T x:A.M | M M | (M, M)K | (M, M)T | fst M |
snd M | unpack M as (x, y) in M | ret M |
case M of zero ) M or succ x ) M | fix f(x) in M |

!o/ M | M :=o/ M | do x  M in M | alloco/ M | dealloc M

and there are the following judgments:

\Gamma  ` A:Kind \Gamma  ` A = A : Kind \Gamma  ` o/ :Type \Gamma  ` P :Prop

\Gamma  ` M :A \Gamma  ` M = M : A \Gamma  | \Theta  ` P

The external equality rules include fi- and j-equalities and monadic laws forcomputations.

To express the pre- and post conditions of computations in terms of proposi-tions, we often write

M 7!o/ - as a shorthand for 9x : o/.M 7!o/ x. The model thatwe present in the Section 3 also accommodates coproducts of types and kinds,

but we have omitted these from this paper.Given the explanation in the Introduction, most of the rules are standard
except for those for the computation fragment, which we include below. Thereare two kinds of sums:

\Sigma T x : A . oe (a type) is used for weak sums over familiesof types, and
\Sigma K x : A . B (a kind) is used for strong sums over families of kinds.Because of the distinction between weak and strong sums, there are two sets of

elimination rules for sums (one with unpack M as (x, y) in M and one with
fst and snd ), as is standard. In the following section describing the model weexplain why we get these different kinds of elimination rules when we show the

concrete interpretation of sums.Here are the non-structural rules for computations. Most of them are unsurprising for a tight interpretation of separation logic. The f ix rule is used todefine recursive functions and captures reasoning via fixed-point induction.

\Gamma  ` M :(\Delta ).{P }y :oe{S} \Gamma , \Delta , x :o/ ` Q:Prop \Gamma , y :oe ` N :(\Delta ).{S}x:o/{Q} seq

\Gamma  ` do y  M in N :(\Delta ).{P }x :o/{Q}

\Gamma , \Delta  ` o/ :Type \Gamma  ` M :o/ dia
\Gamma  ` ret M :(\Delta ).{emp}x:o/{emp ^ x =o/ M}

\Gamma  ` o/ :Type \Gamma  ` M :Nat lookup
\Gamma  ` !o/ M :(y :o/).{M 7!o/ y}x:o/{M 7!o/ y ^ x =o/ y}

\Gamma  ` o/ :Type \Gamma  ` M :Nat \Gamma  ` N :o/ update
\Gamma  ` M :=o/ N :(-).{M 7!oe -}x:1{M 7!o/ N}

\Gamma  ` o/ :Type \Gamma  ` M :o/ alloc
\Gamma  ` alloco/ M :(-).{emp}x :Nat{x 7!o/ M}

\Gamma  ` o/ :Type \Gamma  ` M :Nat dealloc
\Gamma  ` dealloc M :(-).{M 7!o/ -}x : 1{emp}

\Gamma  ` M1 :(\Delta ).{P ^ M =Nat zero}x :o/{Q} \Gamma  ` M :Nat
\Gamma , y :Nat ` M2 :(\Delta ).{P ^ M =Nat succ y}x:o/{Q} case

\Gamma  ` case M of zero ) M1 or succ y ) M2 :(\Delta ).{P }x :o/{Q}
\Gamma , f :\Pi T y :A . (\Delta ).{P }x:o/{Q}, y :A ` M :(\Delta ).{P }x:o/{Q} fix

\Gamma  ` fix f(x) in M :\Pi T y :A . (\Delta ).{P }x:o/{Q}
The structural rules for computations include the frame rule and the rule ofconsequence, see [20] for details.

3 Model
Universe of Realizers Let Cppo? denote the category of chain-completepointed partial orders and strict continuous functions. Recall that one can solve
recursive domain equations in Cppo? for locally continuous bifunctors on Cppo?.We take our universe of realizers to be a domain

V satisfying the following re-cursive domain equation in
Cppo?:

V ,= 1? \Phi  N? \Phi  (V * V )? \Phi  (V ! V )? \Phi  T(V )?,
where 1? is the lift of the one-element set, N? is lift of the flat natural numbers,\Phi  is smash sum, * is cartesian product,

V ! V is the set of continous functionsfrom
V to V , and T(V ) is the domain of computations:

T(V ) = H(V )? ( `(V \Omega  H(V )?) \Phi  E',
in which ( denotes strict function space, \Omega  is smash product, E = {err}? andH(

V ) is the domain of heaps: {h 2 Cppo?(N?, V ) | supp(h) is finite}, wheresupp(

h) is the set {x 2 dom(h) | h(x) 6= ?}, ordered in the following way:
h <= h0 , supp(h) = supp(h0) ^ 8n 2 supp(h).h(n) <= h0(n). Note that H is alocally continous functor whose functorial action is given by composition.

To denote elements in V we use the following injections, mapping elementsinto the appropriate summand and then, via the above isomorphism, into

V .

in1 : 1! V inN : N ! V in* : (V * V ) ! V

in! : (V ! V ) ! V inT : T(V ) ! V

Semantic Operations on Heaps Elements of H(V ) are total functions withfinite support. We wish to think of them as partial functions in order to model
separation logic. This is accomplished by interpreting h(n) = ? as "n is notallocated in

h". This works because two heaps are only related in the partialorder if they have the same support (and, moreover, are also pointwise ordered).

Here we describe some definitions reflecting this interpretation.

Firstly, for h, h0 2 H(V ) we define h #= h0 as h and h0 having the same support.We can then define the *-operator on "disjoint" heaps. For heaps

h1, h2 2 H(V )such that supp(
h1) " supp(h2) = ;, we define h1 * h2 as the heap with supportsupp(
h1) [ supp(h2) satisfying (h1 * h2)|supp(h1) = h1 ^ (h1 * h2)|supp(h2) = h2.In other words,

h1 * h2 is the (disjoint) amalgamation of h1 and h2.For
h 2 H(V ), it makes sense to ask for "the least unallocated cell of h".
leastfree(h) is defined as min{n 2 N | h(n) = ?}.Updating the heap cell

n is by redefining the value at n. For h 2 H(V ), n 2 Nand
d 2 V , we define the heap h[n 7! d] by *m 2 N . if m = n then d else h(m).Allocation is then by updating a cell that was previously unallocated with an

element different from ? and deallocation of cell n in h results in h[n 7! ?].
Types and Kinds We now describe the FhoDTT structure needed for inter-preting types and kinds, beginning with the category Asm(

V ) of assemblies over
V , which will be used for modeling contexts:

Definition (Asm(V )):

Objects: (X, E), where X is a set, and E : X ! P(V ), such that for all

x 2 X, E(x) 6= ;.Morphisms:

f : (X, E) ! (X0, E0), where f : X ! X0 is a set-theoreticfunction, such that there exists a realizer

ff for it, i.e

9 ff :V ! V . 8x 2 X . 8d 2 E(x) . ff(d) 2 E(f(x))
Note that Asm(V ) is an extension of the category of sets and functions: thereis a full and faithful functor r : Set ! Asm(

V ), which maps a set X to (X, E)with
E(x) = V . Functor r is right adjoint to \Gamma  : Asm(V ) ! Set, defined by
\Gamma  (X, E) = X, that is, there is a one-to-one correspondence between morphisms(

X, E) ! r(Y ) in Asm(V ) and functions X ! Y in Set.Kinds in context are interpreted as families of assemblies indexed over assemblies. Formally, the structure is a fibration UFam(Asm(V )) ! Asm(V ), definedas in [13]. The fibration of uniform families of assemblies is equivalent to the
standard codomain fibration over assemblies, denoted Asm(V )! ! Asm(V ).Types in context are modelled as families of chain-complete per's indexed
over assemblies. We denote the category of chain-complete per's by CPer(V ).The indexing is captured via a fibration UFam(CPer(

V )) ! Asm(V ), definedsimilarly to the one for all pers (not only chain-complete pers).

Any complete per R can be seen as an assembly (V /R, E), where V /R is theset of equivalence classes of

R and E is the identity function. This will be usedto model that types are included among the kinds. This inclusion of complete

pers into assemblies extends to families and the extension has a left adjoint:

Lemma 1. The fibred inclusion of UFam(CPer(V )) into UFam(Asm(V )) has afibred left adjoint given by chain completion.
We now present the formal statement which ensures that we can model soundlythe pure type and kind fragment of HTT. After that, we explain how types and
kinds are modeled concretely.
Theorem 1. The categories and functors in the diagram

UFam(CPer(V ))

((RRRRR
RRRRRR
RR

_ v 55 UFam(Asm(V ))uu

fflffl

' // Asm(V )!
wwnnnnnn

nnnnnn

Asm(V )
constitute a split weak FhoDTT with a fibred natural numbers object in UFam(CPer(V )),which is also a fibred natural numbers object in UFam(Asm(

V )).

Corollary 1. The pure type and kind fragment (excluding computation types)of HTT is sound wrt. the interpretation in the above FhoDTT.

The empty context is interpreted as the terminal object in Asm(V ): [[;]]Ctxs =1 = ({*}

, * 7! V ), and if [[\Gamma  ]]Ctxs = (X, E) and [[\Gamma  ` A : Kind]]Kinds =((
Ax, EAx))x2X (a family of assemblies indexed over the assembly (X, E)), then[[
\Gamma , x :A]]Ctxs is

(\Sigma x2XAx, (x, a) 7! {(d, d0) 2 V * V | d 2 E(x) ^ d0 2 EAx(a)})
Thus context formation is modeled by dependent sum. We now describe partsof the interpretation of kinds:

- the inclusion of types into kinds is modeled via the inclusion from completepers into assemblies
- Type is modeled as an object in the fibre UFam(Asm(V ))1 over the terminalobject 1 in Asm(

V ), i.e., as an object in Asm(V ), namely r(Obj(CPer(V )),where
Obj(CPer(V )) is the set of all chain-complete pers over V .
- Prop is modeled by rP(H(V )) (see the next subsection).-

\Pi K is modeled by dependent product: If [[\Gamma  ` A: Kind]]Kinds = ((Ax, EAx))x2Xand [[

\Gamma , x : A ` B : Kind]]Kinds = ((B(x,a), EB(x,a)))(x,a)2\Sigma  x:X . Ax then

[[\Gamma  ` \Pi K x : A . B : Kind]]Kinds is given by

({f 2 \Pi a2AxB(x,a) | E\Pi x(f) 6= ;}, E\Pi x )x2X,
where E\Pi x is given by

f 7! {in!(g) | 8a 2 Ax.e 2 EAx(a) ) g e 2 EB(x,a)(f(a))}.

- \Sigma K is modeled by dependent sum.
- External equality of kinds is interpreted by equality in the model.

We now describe the interpretation of the pure types:

- Nat is modeled by the flat naturals, i.e ({(inN(n), inN(n)) | n 2 N})
- 1 is modeled by the terminal object in CPer(V ), i.e., as ({(in1(*), in1(*))}).-

\Pi T is modeled by dependent product.-
\Sigma T is modeled by dependent sum: If [[\Gamma  ` A : Kind]]Kinds = ((Ax, EAx ))x2Xand [[

\Gamma , x : A ` o/ : Type]]Types = (R(x,a))(x,a)2\Sigma  x:X . Ax then [[\Gamma  ` \Sigma T x :

A . o/ :Type]]Types is given by (Bx)x2X , where Bx is

CC({(in*(d, e), in*(d0, e0)) | 9a 2 Ax.d, d0 2 EAx (a) ^ e R(x,a)e0}).
Here CC(R) denotes the chain completion of R (the reflection into UFam(CPer(V )),cf. Lemma 1). We need to use the chain-completion to get a chain-complete

per and the elements in the chain-completion are not necessarily pairs ofrealizers for the constituent types. This is why these sums are only weak.
Indeed, if we try to apply the first-projection realizer to a realizer for anelement of the above sum, then we will not be sure to end up with a realizer
for A (we only know that we'll get something in the chain-completion of A).
An external equality judgment of kinds \Gamma  ` A = B : Kind holds if A and
B are interpreted as the same objects in the fibre over the interpretation of
\Gamma  . Likewise for external equality of types \Gamma  ` o/ = oe : Type. The soundnesscorollary 1 means that any external equality judgment that can be derived holds.

The following lemma shows that any well-typed term corresponds to a propervalue in the model, even the diverging computation. The computation types
relate the least element of T(V ) to itself.
Lemma 2. For any type \Gamma  ` oe : Type, no per in the family [[\Gamma  ` oe : Type]]Typesrelates ? to itself.

We omit the description of the interpretation of pure terms. Suffice it to saythat lambda abstractions in the calculus really are interpreted via continuous
functions (realizers from V ! V ).We say that an external equality judgment of terms

\Gamma  ` M = N : A holdsif
M and N are interpreted as the same morphism. The soundness corollary 1means that any derivable external equality judgment of terms holds.

Logic As in separation logic, we really have a logic of heaps and hence propo-sitions will be modeled as subsets of H(

V ). We obtain the structure neededfor interpreting the logic as follows. The power set of heaps

P(H(V )) orderedby inclusion is a BI-algebra [21] in Set. We embed it into Asm(

V ) via thefunctor r to get r(
P(H(V ))). One can show that the object is an internallycomplete BI-algebra in Asm(

V ). Hence, as explained in [5], there is a canoni-cal BI-hyperdoctrine
P = Asm( , r(P(H(V )))), which soundly models classicalhigher-order separation logic. Note that the fibre over an object (

X, E) in P isthe set of morphisms in Asm(
V ) from (X, E) to r(P(H(V ))), which, as men-tioned earlier, is in one-to-one correspondence with functions from

X to P(H(V ))in Set. Hence, a proposition in context
\Gamma  ` P : Prop is interpreted as follows:Suppose
\Gamma  is interpreted as the assembly (X, E). Then P is interpreted as afunction from

X to P(H(V )). The propositional connectives are all interpretedin the standard way from separation logic. For instance, [[

\Gamma  ` P * Q: Prop]]Propsx

is {h | 9h1 2 [[\Gamma  ` P : Prop]]Propsx , h2 2 [[\Gamma  ` Q : Prop]]Propsx . h = h1 * h2}. Thequantifiers are also interpreted in the standard way. For instance,

[[\Gamma  ` 8y :A.P :Prop]]Propsx = {h | 8y 2 [[\Gamma  ` A:Kind]]Kindsx . h 2 [[\Gamma , y :A ` P ]]Props(x,y) }
In the display above, note that [[\Gamma  ` A : Kind]]Kinds is a uniform family ofassemblies over (

X, E), so [[\Gamma  ` A : Kind]]Kindsx is an assembly (Y, EY ). When wewrite
y 2 [[\Gamma  ` A : Kind]]Kindsx , we mean that y 2 Y . Note that y may depend on
x (we have a separation logic for a dependent type theory).Now it should also be clear why the kind Prop is interpreted as r(

P(H(V )) .

Computations As mentioned in Section 1, a computation type (\Delta ).{P }x : o/ {Q}is modeled as an admissible per of realizers in T(

V ), which given heaps satisfyingthe precondition
P do not produce error and upon termination leaves a heapsatisfying the postcondition

Q. The context \Delta  is implicitly quantified, so thatthis behaviour should be adhered to for all instantiations of

\Delta . Formally itlooks like this. Assume [[
\Gamma  ]]Ctxs = (X, E) and [[\Gamma , \Delta ]]Ctxs = (\Sigma x2X Yx, F ). Then[[
\Gamma  ` (\Delta ).{P }x : o/ {Q}: Type]]Types is the family of pers (Sx)x2X with fields givenby

d 2 |Sx| iff d = inT(f) and

8y 2 Yx.8E 2 Prop\Gamma ,\Delta .8h 2 [[\Gamma , \Delta  ` (P * E)]]Props(x,y) .(f(h) 6= err) ^"

f(h) = (vf , hf ) ) vf 2 |[[\Gamma , \Delta  ` o/ :Type]]Types(x,y) | ^

hf 2 CC([[\Gamma , \Delta , x:o/ ` (Q * E)]]Props(x,y,vf ))"

So suitable realizers are elements of T(V ) that for any extension P * E of Ptakes heaps satisfying

P * E to heaps satisfying the chain-completion of Q * Eand do not produce error. Thus the frame rule is baked into the interpretation

of computations. This does not support the law of conjunctivity. The actual peris then given by

inT(f) Sx inT(g) iff inT(f ), inT(g) 2 |Sx| and

8y 2 Yx.8E 2 Prop\Gamma ,\Delta .8h, h0 2 [[\Gamma , \Delta  ` (P * E)]]Props(x,y) .h #= h0 )

f(h) #, g(h0) # ^"f(h) = (vf , hf ) ^ g(h0) = (vg, hg) )

vf [[\Gamma , \Delta  ` o/ :Type]]Types(x,y) vg ^ hf #= hg"

So two realizers denote the same computation if they both fulfill the specificationand on heaps with equal support gives results related in the interpretation of
the return type and heaps with equal support.
Lemma 3. Let [[\Gamma  ]]Ctxs = (X, E) and [[\Gamma  ` (\Delta ).{P }x : o/ {Q} : Type]]Types =(

Sx)x2X . Then for all x 2 X, Sx is a chain-complete per with its field insideT(

V ), relating inT(*h . ?) to itself. As such it is an admissible per over T(V ).

As mentioned in the introduction, we require that computations should produceheaps with equal support (given suitable heaps with equal support) so that allocation can be modeled by taking the least unallocated address (see the semanticsof

alloc below). An unfortunate consequence of this choice is that two computa-tions that intuitively behave in the same way but allocate cells in different order

may not be equated by the model. We believe that the model can be refined by

using realizers in FM-domains [25, 24, 3], such that support would then be up toa permutation of the locations in the heap. (Indeed, FM-domains have already
been applied in a recent parametric model for separation logic [9].) We leave thisrefinement for future work, however.

We now describe how terms of computation types are interpreted in themodel. Recall that for a computation type (

\Delta ).{P }x : o/{Q}, we can give theinterpretation of
\Gamma  ` M : (\Delta ).{P }x :o/ {Q} by giving the realizer ff.
We first consider the structural rules for computations. We begin with theframe rule. Assume [[

\Gamma  ]]Ctxs = (X, E) and that [[\Gamma  ` M : (\Delta ).{P }x : o/ {Q}]]Termsis realized by
ff. Then [[\Gamma  ` M : (\Delta ).{P * R}x : o/ {Q * R}]]Terms is also realizedby
ff since, for all x 2 X, the field of [[\Gamma  ` (\Delta ).{P }x : o/ {Q} : Type]]Typesx isincluded in the field of [[

\Gamma  ` (\Delta ).{P * R}x : o/ {Q * R} : Type]]Typesx (here we usethat the frame rule is baked into the interpretation of computation types). The

remaining structural rules are also interpreted by using the same realizer. Forthe consequence rule we use that the chain-completion operation is monotone.

Now for the non-structural rules: Assume [[\Gamma  ]]Ctxs = (X, E) and that [[M ]] isgiven by

ff and [[N ]] is given by fi when they are of computation types and mand
n otherwise. Then

[[\Gamma  ` do y  M in N :(\Delta ).{P }x:o/{Q}]]Terms

= *e . *h . if ff(e)(h) = (vM , hM ) then fi(e, vM )(hM ) else ff(e)(h)

[[\Gamma  ` ret M :(\Delta ).{emp}x :o/{emp ^ x =o/ M}]]Terms = *e . *h.(m(e), h)
[[\Gamma  ` !o/ M :(y :o/).{M 7!o/ y}x:o/{M 7!o/ y ^ x =o/ y}]]Terms

= *e . *h . if h(m(e)) = ? then err else (h(m(e)), h)

[[\Gamma  ` M :=o/ N :(-).{M 7! -}x:1{M 7!o/ N}]]Terms = *e . *h.(*, h[m 7! n])
[[\Gamma  ` alloco/ M :(-).{emp}x :Nat{x 7!o/ M}]]Terms

= *e . *h . let l = leastfree(h) in (l, h[l 7! m])

[[\Gamma  ` dealloc M :(-).{M 7!o/ -}x : 1{emp}]]Terms

= *e . *h.if h(m) = ? then err else (*, h[m 7! ?])

[[\Gamma  ` case M of zero ) M1 or succ y ) M2 :(\Delta ).{P }x :o/{Q}]]Terms

= *e . *h . if m(e) = inN(0) then ff1(e)(h) else ff2(e, m - 1)(h)

[[\Gamma  ` fix f(x) in M :\Pi T y :oe . (\Delta ).{P }x :o/{Q}]]Terms

= *e . fixedpointof *f . *y . ff(e, f, y))

Note that the realizers for computations are as one would hope. Consider, for ex-ample, lookup !

M, whose realizer is *e . *h . if h(m(e)) = ? then err else (h(m(e)), h).Given a realizer

e in EX (x) (intuitively, a realizer for \Gamma  ), it produces a compu-tation that when given a heap

h yields error if the location m(e) is not allocatedin
h and otherwise the value stored in h at m(e), along with h. The realizer e isneeded, as always, because the type theory is dependent.

For fixed points, the realizer is obtained by the usual least fixed point con-struction, which applies since

*f . *y . ff(e, f, y) is indeed an endofunction of thepointed domain
V ! T (V ), when ff is the realizer for [[\Gamma , f :\Pi T y :oe . (\Delta ).{P }x :
o/{Q}, y :oe ` M :(\Delta ).{P }x : o/ {Q}]]Terms.

Theorem 2. The interpretation of computations is well-defined, i.e., any well-typed computation term

\Gamma  ` M : (\Delta ).{P }x : o/ {Q} is interpreted as a morphism

1 ! [[\Gamma  ` (\Delta ).{P }x : o/{Q} : Type]]Types in the fibre over [[\Gamma  ]]Ctxs. Moreover, theexternal equality rules for computations hold.
Notice that the above theorem expresses that well-typed programs do not produceerror : If [[

\Gamma  ]]Ctxs = (X, EX ) and [[\Gamma  ` M : (\Delta ).{P }x : o/ {Q}]]Terms = m then, forall
x 2 X, all e 2 EX (x), m(e) is in [[\Gamma  ` (\Delta ).{P }x : o/ {Q} : Type]]Typesx . Thus
m(e) is a realizer in T(V ), which given a heap satisfying P does not produce
err. If m(e) then terminates (does not give ?), it returns a value and a heap inthe chain-completion of

Q. For a discussion of the use of the chain-completion,please see the accompanying technical report.

4 Conclusion and Future Work
We have developed a realizability model for impredicative Hoare Type Theory, avery expressive dependent type theory in which one can specify and reason about
mutable abstract data types. The model is used to establish the soundness ofthe type theory. Moreover, the model can be used to discover new equations
between terms and types.Our model also accommodates certain kinds of subset kinds and types. For
a kind A we can model the subset kind {x : A | P }, for all propositions P .For a type

o/ we can model the subset kind {x : o/ | P }, for all chain-completepropositions

P ; it also seems possible to model subset types {x : o/ | P }, for allpropositions
P by using the chain-completion. The subset kinds / types will notbe full subset kinds / types, however, for the same reason that we do not have

full subset types for the standard separation logic BI-hyperdoctrine over Set [5].Future work includes investigating how to model recursive types, as needed for
the specification of programs that recurse through the store [22]. It would alsobe interesting to refine the model using, e.g., FM-domains to get a more abstract
model of allocation leading to more equalities among terms. Another avenue forfuture work is to explore the soundness of higher-order frame rules [8]. This seems
to involve a further level of indexing over a Kripke structure similar to the onein [8]. Finally, it would also be interesting to investigate relational parametricity
for the impredicative polymorphism.

References

1. A. Appel, P.-A. Melli`ees, C. Richards, and J. Vouillon. A very modal model of a

modern, major, general type system. In POPL'07, 2007.
2. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# programming system:

An overview. In CASSIS 2004, LNCS. Springer, 2004.
3. N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for

storage. In TLCA'05, pages 88-101, Nara, Japan, 2005.
4. M. Berger, K. Honda, and N. Yoshida. A logical analysis of aliasing in imperative

higher-order functions. In O. Danvy and B. C. Pierce, editors, ICFP'05, pages
280-293, Tallinn, Estonia, September 2005.
5. B. Biering, L. Birkedal, and N. Torp-Smith. Bi hyperdoctrines and higher-order

separation logic. In In ESOP"05, volume 3444 of LNCS, pages 233-247, 2005.

6. B. Biering, L. Birkedal, and N. Torp-Smith. BI hyperdoctrines, Higher-Order

Separation Logic, and Abstraction. TOPLAS, 2007. To Appear.
7. L. Birkedal, R. Mo/gelberg, and R. Petersen. Domain-theoretic models of parametric polymorphism. To Appear in TCS, 2007.
8. L. Birkedal, N. Torp-Smith, and H. Yang. Semantics of separation-logic typing

and higher-order frame rules for algol-like languages. LMCS, 2(5:1):1-33, 2006.
9. L. Birkedal and H. Yang. Relational parametricity and separation logic. In Proc.

of FOSSACS 2007, number 4423 in LNCS. Spring, 2007.
10. L. Burdy, Y. Cheon, D. Cok, M. Ernst, J. Kiniry, G. T. Leavens, K. R. M. Leino,

and E. Poll. An overview of JML tools and applications. International Journal on
Software Tools for Technology Transfer, 7(3):212-232, June 2005.
11. D. L. Detlefs, K. R. M. Leino, G. Nelson, and J. B. Saxe. Extended static checking.

Compaq Systems Research Center, Research Report 159, December 1998.
12. D. Evans and D. Larochelle. Improving security using extensible lightweight static

analysis. IEEE Software, 19(1):42-51, 2002.
13. B. Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and

the Foundations of Mathematics. Elsevier, 1999.
14. N. Krishnaswami. Separation logic for a higher-order typed language. In

SPACE'06, pages 73-82.
15. N. Krishnaswami, J. Aldrich, and L. Birkedal. Modular verification of the subjectobserver pattern via higher-order separation logic. In FTfJP 2007.
16. G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to typed assembly

language. ACM TPLS, 21(3):527-568, 1999.
17. A. Nanevski, A. Ahmed, G. Morrisett, and L. Birkedal. Abstract Predicates and

Mutable ADTs in Hoare Type Theory. In ESOP'07, volume 4421 of LNCS, pages
189-204.
18. A. Nanevski, G. Morrisett, and L. Birkedal. Polymorphism and separation in Hoare

Type Theory. In ICFP'06, pages 62-73, Portland, Oregon.
19. P. W. O'Hearn, H. Yang, and J. C. Reynolds. Separation and information hiding.

In POPL'04, pages 268-280.
20. R. Petersen, L. Birkedal, A. Nanevski, and G. Morrisett. A realizability model of impredicative hoare type theory. Technical report, IT University of Copenhagen, 2007. Available at
http://www.itu.dk/people/birkedal/papers/httmodel-tr.pdf.
21. D. Pym. The Semantics and Proof Theory of the Logic of Bunched Implications,

volume 26 of Applied Logics Series. Kluwer, 2002.
22. B. Reus and J. Schwinghammer. Separation logic for higher-order store. In CSL'06.
23. J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In

LICS'02, pages 55-74.
24. M. Shinwell. The Fresh Approach: Functional Programming with Names and

Binders. PhD thesis, Computer Laboratory, Cambridge University, Dec. 2004.
25. M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness. TCS,

342:28-55, 2005.
26. K. Watkins, I. Cervesato, F. Pfenning, and D. Walker. A concurrent logical framework: The propositional fragment. In S. Berardi, M. Coppo, and F. Damiani,
editors, TYPES'04, volume 3085 of LNCS, pages 355-377. Springer.
27. H. Xi and F. Pfenning. Dependent types in practical programming. In POPL"99,

pages 214-227, San Antonio.
28. N. Yoshida, K. Honda, and M. Berger. Local state in hoare logic for imperative

higher-order functions. In Proc. of FOSSACS 2007, number 4423 in LNCS. Spring.