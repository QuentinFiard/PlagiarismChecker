

Entailment of Non-Structural Subtyping Constraints

Joachim Niehren Tim Priesnitz
Programming Systems Lab, Universit"at des Saarlandes

66041 Saarbr"ucken, Germany
fniehren,timg@ps.uni-sb.de

Abstract. Entailment of subtyping constraints is a central problem to be solved for
constraint simplification in subtype inference systems. Recently, Rehof and Henglein
proved that the entailment problem of subtyping constraint has a surprisingly high worst
case complexity: Entailment of structural subtyping constraints is coNP-complete for
simple types and PSPACE-complete for recursive types. Entailment of non-structural
subtyping constraints is PSPACE-hard in both cases; its precise complexity is open.
It is even not known whether the entailment problem of non-structural subtyping
constraint is decidable. In this paper, we investigate the simplest possible non-trivial
fragment of non-structural subtyping constraints and prove that its entailment problem is
PSPACE-complete, both, for simple types and recursive types. 1

Keywords: constraints, subtyping, tree ordering, entailment, decidability, complexity.

1 Introduction
Subtyping is a natural concept in programming. This observation has motivated the
design of programming languages featuring a system for subtype inference [8, 11, 6,
19]. Simplification of constraints in typings turned out to be the key issue in what concerns the complexity of subtyping inference systems [7, 24, 17, 20, 18]. Entailment of
subtyping constraints is often considered as the central problem underlying constraint
simplification in subtype inference systems [1, 24, 17, 9].

Subtyping as a Tree Ordering. Following for instance [9, 21, 17], we consider types as
ordinary trees. Finite trees (i.e. ground terms) correspond to simple types and infinite
trees to recursive types. For instance, the type of an integer is represented by a constant
int and the type of a pair of integers by the finite tree int\Theta real. If the type of real
numbers is denoted by the constant real then the subtyping relationship int ^ real
expresses that every integer can be used as a real number. This naturally induces the
relationship int\Theta int ^ real\Theta real which means that every pair of integers can be used
as a pair of reals.

Many further type constructors were considered in the literature: There are the
least type ?, the greatest type ?, contra-variant function types o/ !o/ 0, record types
ff1:o/1; : : : ; fn:o/ng, but also intersection and union types. Even though all of these
types are of interest, we restrict ourselves to a minimalist set of type constructors
which is already difficult enough to treat with respect to the problem considered in
this paper. In particular, we ignore function types and record types.

1 This is an extension of a submitted paper by full proofs. The last revision was done February 9, 1999.

Subtyping Constraints. We assume a signature \Sigma  of ranked function symbol. Subtyping constraints are conjunctions of atomic ordering constraint t^t0 where t; t0 are
terms built from variables and function symbols in \Sigma .

Two kinds of subtype orderings considered in the literature and should be clearly
distinguished. Structural subtyping is induced homomorphically by relationships between constants such as int ^ real. Each two trees related by structural subtyping have
the same structure, possibly with the exception of their leaves.

The situation is different for the ordering of non-structural subtyping [17, 16]
where the constants ? and ? belong to the signature \Sigma  that represent the least type
and greatest type. In other words, non-structural subtyping is an ordering induced homomorphically by the relationships ?^o/ and o/ ^? which are assumed for for all trees
o/ over \Sigma .

Complexity. Recently, Rehof and Henglein [9, 10, 21] proved that entailment of subtyping constraints has a surprisingly high worst case complexity. Entailment of structural subtyping constraint is coNP-complete for finite trees and PSPACE-complete for
infinite trees. Entailment of non-structural subtyping constraints is PSPACE-hard in
both cases. The precise complexity of this problem is open in both cases; it is even
not known whether the entailment problem of non-structural subtyping constraint is
decidable.

Contribution. In this paper, we investigate a fragment of non-structural subtyping
constraints and prove that its entailment problem is PSPACE-complete, both, for simple types and recursive types. This fragment that we call NS2 (NS stands for "nonstructural" and 2 for "binary function symbol") is chosen to be as minimalistic as
possible but non-trivial. The structure in which constraints of NS2 are interpreted provides for trees built from the signature \Sigma 2 = ff; ?; ?g which beside of the constants
? and ? contains a single binary function symbol f only. The subtyping constraints of
NS2 are restricted to the forms u=f (u1; u2) and u1^u2 where u; u1; u2 are variables
for trees over \Sigma 2. Note that equations u=? or u=? are not provided.

The contribution of this paper can be summarized as follows: We prove for a first
time that entailment of non-structural subtyping constraints in NS2 is decidable. We
also fix the complexity of entailment for NS2 to be PSPACE-complete. Our results
apply to the case simple types and also to the case of recursive types. The proofs presented are technically involved. At the time being it remains unclear whether the given
results can be extended to any larger class of non-structural subtyping constraints. But
of course, this is the ultimate goal behind the approach chosen.

Related Entailment Problems. Several entailment problems for constraint languages
describing trees are considered in the literature. Two of them were shown PSPACEcomplete in [13, 14]. The common property of these PSPACE-compete entailment
problems is that entailment depends on regularity properties of sets of paths in the constraint graph. This insight allows in some cases to transfer lower complexity bounds
from one problem to another. Note however that the insights on which the entailment
algorithm in this paper is based are very much unrelated (and sometimes in contrast)
to those underlying [13, 14].

In the area of feature logics, a sequence of constraint languages for describing
feature trees - which can be seen as records or record types - were investigated for

entailment. Entailment for equality constraints over feature trees in FT or CFT can be
decided in quasi linear time [2, 22] even when extended with existential quantification. An algorithm for solving this entailment problem underlies the implementation
of conditional actors in the concurrent constraint programming language Oz [23].

Apart from equality constraints, ordering constraints have some tradition in feature
logics [5, 4]. Ordering constraints over feature trees can be considered as record subtyping constraints. The entailment problem of ordering constraints over feature trees
in the system FT^ can be solved in cubic time [12]. However, entailment of FT^ with
existential quantification is PSPACE-complete [13] again.

Entailment problems were also considered for set constraints (i.e. constraints
for union and intersection types). Entailment of set constraints with intersection is
proved DEXPTIME-complete in [3] for an infinite signature. Entailment of atomic
set constraints [14] is proved PSPACE-complete in case of an infinite signature and
DEXPTIME-hard for a finite signature.

Plan of the Paper. We introduce the syntax and semantics of non-structural subtyping constraints in Section 2. Section 3 illustrates some examples for entailment of
non-structural subtyping constraints which explains our choice of the fragment NS2.
Section 4 presents the satisfiability test for non-structural subtyping constraints. Section 5 introduces an algorithm for deciding entailment. A sketch of its completeness
proof follows in Section 6. For omitted proofs we refer to the extended version of this
paper [15].

2 Non-Structural Subtyping Constraints
We introduce the languages of non-structural subtyping constraints considered in this
paper. We assume a signature \Sigma  of function symbols which contains at least two constants ? and ?. Functions symbols in \Sigma  - distinct from ? and ? - are ranged over by
f; g. We also assume an infinite set of variables ranged over by u; v; w; x; y; z.

Paths. In order to define the notion of possibly infinite trees we need the notion of a
path. A path is word of natural numbers n * 1. We denote a path with ss, o, %, or oe.
The empty path is denoted by " and the free-monoid concatenation of paths ss and o
by juxtaposition sso, with the property that "o = o" = o. A prefix of a path ss is a path
o for which there exists a path ss0 such that ss = oss0. A proper prefix of ss is a prefix of
ss but not ss itself. It o is a prefix of ss then we write o ^ ss and if o is a proper prefix of
ss then we write o ! ss. The prefix closure of a set of path M is denoted as pr(M ), i.e.
pr(M ) = fss j exists ss0 2 M : ss ^ ss0g and its proper prefix closure with pr6=(M ),
i.e. pr6=(M ) = fss j exists ss0 2 M : ss ! ss0g.

Trees. A tree o/ is a pair (D; L) consisting of a tree domain D and a (total) labeling
function L : D ! \Sigma . A tree domain is a non-empty prefixed-closed set of paths. If
o/ is a tree then we denote with Do/ its domain and with Lo/ its labeling function. We
require all trees o/ to be arity consistent in that it satisfies the following property for all
ss 2 Do/ and f 2 \Sigma : If Lo/ (ss) = f and the arity of f is n then for all i * 1 it holds
that i ^ n iff ssi 2 Do/ . If ss 2 Do/ then we write o/ [ss] for the subtree of o/ at ss. i.e.
Do/[ss] = fss0 j ssss0 2 Do/ g and Lo/[ss](ss0) = Lo/ (ssss0) for all ss0 2 Do/[ss].

A tree is finite if its tree domain is finite and infinite otherwise. We denote the
set of all finite trees with Treefin\Sigma  and the set all infinite trees with Tree\Sigma . As usual

we consider Treefin\Sigma  and Tree\Sigma  also as logical structures with signature \Sigma  in which a
function symbol is interpreted as a tree constructor.

Non-Structural Subtyping. We define non-structural subtyping as the following ordering on trees. For o/1; o/2 2 Tree\Sigma  it holds that o/1^o/2 iff for all path ss and f 2 \Sigma :

1. If Lo/1 (ss) = f then either Lo/2 (ss) = f or exists ss0 ^ ss such that Lo/2 (ss0) = ?.
2. If Lo/2 (ss) = f then either Lo/1 (ss) = f or exists ss0 ^ ss such that Lo/1 (ss0) = ?.

Definition 1. The structure NS\Sigma  extends the structure Tree\Sigma  with a relation symbol
^ that is interpreted as the ordering of non-structural subtyping (also denoted with ^).
The structure NSfin\Sigma  is the restriction of NS\Sigma  to the domain of finite trees Treefin\Sigma  .

Non-Structural Subtyping Constraints. A term t over \Sigma  is either a constant, a variable
or a construction of the form f (t1; : : : ; tn) where t1; : : : ; tn are terms and n * 0 is the
arity of f 2 \Sigma .

t ::= u j ? j ? j f (t1; : : : ; tn)

A ground term over \Sigma  is a term without variables. Of course, there exists an isomorphism of the structure of all ground terms over \Sigma  and structure of all finite trees
Treefin\Sigma  .

A non-structural subtyping constraint over \Sigma  is a conjunction of atomic ordering
constraints of the form t1^t2. The semantic of non-structural subtyping constraints is
given by interpretation in one of the structures NS\Sigma  or NSfin\Sigma  . We freely overload notation, by also denoting the constraint languages of non-structural subtyping constraints
with NS\Sigma  and NSfin\Sigma  .

Satisfiability and Entailment. Let \Phi  denote a first-order formula built from ordering
constraints with the usual first order connectives and let V(\Phi ) be the set of variables
occurring free in \Phi . We write \Phi 0 in \Phi  if there exists \Phi 00 such that \Phi  = \Phi 0 ^ \Phi 00 up to
associativity and commutativity of conjunction.

Suppose that A is a structure with the signature \Sigma  [ f^g. A solution of \Phi  in A is a
variable assignment I into the domain of A such that \Phi  evaluates to true under A and
I. We call \Phi  satisfiable in A if there exists a solution for \Phi  in A. A formula \Phi  is valid
in A if all variable assignments into the domain of A are solutions of \Phi . A constraint
\Phi  entails \Phi 0 in A, written \Phi  j=A \Phi 0 if \Phi  ! \Phi 0 is valid in A.

The Constraint Languages NS2 and NSfin2 . Let \Sigma 2 be the signature \Sigma 2 = f?; ?; f g
where f is a binary function symbol. The language NS2 provides non-structural subtyping constraints ' according to the following abstract syntax and interpreted in the
structure NS\Sigma 2. The language NSfin2 provides the same constraint syntax as NS2 but
interpreted in the structure NSfin\Sigma 2.

' ::= u=f (u1; u2) j u1^u2 j '1 ^ '2
There are several syntactical restrictions to be observed. The fact that NS2 and NSfin2
do not provide for nested terms does not restrict the expressiveness of entailment since

' j= t1^t2 is equivalent to ' ^ t1^x ^ y^t2 j= x^y where x; y are fresh variables.
Of course, terms on the left hand side can be flattened by introducing new variables for
all subterms. The following restrictions matter for expressiveness and are discussed in
the following section.

1. The constraints x=? and x=? are not provided by NS2 nor NSfin2 .
2. There exists no unary function symbol in the signature of NS2 and NSfin2 .

3 Example for Entailment
In this section, we illustrate by example why entailment of non-structural subtyping is
a so difficult problem.

3.1 Encoding Finite Automata
We first show how to encode the universality of non-deterministic finite automata into
entailment of non-structural subtyping constraints. The idea was first presented in [10]
where it was used for proving the following proposition.

Proposition 2. Entailment of non-structural subtyping constraints restricted to the
languages NS2 or NSfin2 is a PSPACE-hard problem, since it can express the universality problem of non-deterministic finite automata up to a linear time translation.

For illustration, we encode the following automaton A over the alphabet f1; 2g:

A : x uffl 1

2

1

2
The set of states of A is the set of variable fx; ug, its start state is x and all its states
are final. We can encode A as the following non-structural subtyping constraint over
the signature \Sigma 2 (where each occurrence of the underscore stands for a fresh variable).

A : x 1! u; x 2! x; 'A : x^f (u; ) ^ x^f ( ; x) ^

u 1! u; u 2! x u^f (u; ) ^ u^f ( ; x)

It is not difficult to see that the language L(A) recognized by A is universal. As a
consequence each solution of 'A has to map the variable x to a tree which is labeled
in f?; f g only. The constraint f (y; y)^y requires that every tree for y is labeled in
ff; ?g only. Hence:

L(A) = f1; 2g\Lambda  iff 'A ^ f (y; y)^y j= x^y
Note in particular that 'A is satisfiable both over NS\Sigma 2 and NSfin\Sigma 2 . The infiniteness of
L(A) is expressed by the set of all solutions of 'A and not by a single solution.

3.2 Strange Loops
We next introduce the concept of a strange loop. These are loops in the constraint graph
which are really strange in that they may raise entailment in case that a unary function
symbol is available in the signature but not otherwise. Note also, that the constraints
obtained by encoding finite automata do not have strange loops in their graph.

Example 3. If g is a unary function symbol than the following entailment judgment
'1 j= x^y holds where '1 is the following constraint:

'1 : x^g(y) ^ g(x)^y ;

'1 j= x^y

G'1 :

g g

x y

1 1

We can now prove by induction that entailment ' j= x^y cannot be contradicted at
any path in 1\Lambda . This can be seen as follows: The equation x^g(y) requires that either
x=? or there x=g(x0) for some x0. Symmetrically, the equation g(x)^y entails that
either y=? or y=g(y0). In the case x=? or y=? we cannot contradict entailment at
any path. In case of x=g(x0) and y=g(y0) we cannot contradict entailment at path ffl;
by replacing x with g(x0) and y with g(y0) in '2, we obtain the constraint x0^g(y0) ^
g(x0)^y0 which is equal to '2 up to a renaming of variables. Hence, the same argument
applies recursively and shows that we cannot contradict at any path.

The constraint graph G'1 of '1 is drawn above. There is a strange loop in G'1
whose parameters are x, y, and the path 1. This loop is also strange in the sense that
the it traverses the ordering twice but in distinct directions (once in increasing and once
in decreasing manner).

Example 4. If f is a binary function symbol than the entailment judgment '2 j= x^y
is not valid:

'2 : x^f (y; u) ^ f (x; u)^y ;

'2 6j= x^y

G'2 :

f f

x u y

1 2 1 2

The following solution I of '2 contradicts the judgment '2 j= x^y at the path 12:

I(x) = f (f (?; ?); ?); I(y) = f (f (?; f (?; ?)); ?); I(u) = ?
This counter example might seem surprising in the light of the previous example. The
structures of the graphs G'1 and G'2 are fully analogous except for that '1 is built
with a unary function symbol and '2 with a binary one. In both graphs there exists a
strange loop with parameters x, y, and path 1.

Example 4 shows that strange loops do have less effect on entailment in absence
of unary function symbols. In fact, we show in this paper that strange loops have no
effect on entailment in NS2 and NSfin2 . Before doing so, we consider an example which
shows why constraints u=? or u=? contribute to entailment in a non-trivial way.

Example 5. If g is a unary function symbol than the following entailment judgment
holds:

x^g(y) ^ g(g(?))^y j= x^y

S1:1 if x 2 V() then x^x in 
S1:2 if x^y in  and y^z in  then x^z in 
S2 if x=f(x1; : : : ; xn) ^ x^y ^ y=f(y1; : : : ; yn) in  then V

n

i=1 xi^yi in 

S3:1 not x=f(x1; : : : ; xn) ^ x^y ^ y=g(y1; : : : ; yn) in  for f 6= g and n * 0

S3:2 not x=f(x1; : : : ; xn) ^ x^y ^ y=? in 
S3:3 not x=? ^ x^y ^ y=g(y1; : : : ; yn) in 
S3:4 not x=? ^ x^y ^ y=? in 
S4:1 not V

n

i=1 xi=f(: : : yi+1 : : :) ^ xi+1^yi+1 in  for xn+1 = x1 and n * 1

S4:2 not V

n

i=1 xi=f(: : : yi+1 : : :) ^ xi+1*yi+1 in  for xn+1 = x1 and n * 1

Table 1. Closure Algorithm: S1-S3 for NS\Sigma  and S1-S4:2 for NSfin\Sigma 

This can be argued as follows: In every solution of g(g(?)^y the variable y has to
denote one of the trees ?, g(?), or g(g(?)). It can be checked in all tree cases that the
denotation of x has to be smaller than the one for y.

There are also examples showing that strange loops matter for entailment in NS\Sigma 2
and NSfin\Sigma 2 , i.e. when adding the constraints x^? and x^? to NS2 or NSfin2 . Therefore,

we restrict our attention in the present paper to the simpler cases of NS2 and NSfin2 and
show that strange loops do not matter for their entailment problems.

4 Satisfiability Test
We recall a well-known closure algorithm for solving the satisfiability problem of nonstructural subtyping constraints (see also Henglein [10]).

We assume an arbitrary signature \Sigma  and consider the ordering constraints in the
structures NS\Sigma  and NSfin\Sigma  . The difference between both cases simply consists in an
additional occurs check for the case of finite trees.

In order to render the closure algorithm simple, we assume that ordering constraints are given in the following flattened syntax:

 ::= u^v j u=? j u=? j u=f (u1; : : : ; un) j  ^ 0
It is not difficult to see that every ordering constraint can be flattened in linear time
such by introducing fresh variables for every subterm.

In Table 1 a set of closure properties is given. We call a constraint closed for NS\Sigma 
if it satisfies S1-S3 and closed for NSfin\Sigma  it it satisfies S1-S4.2. The closure properties
S1-S3 or S1-S4.2 can also be considered as closure algorithms which compute the
closure of a constraint if it exists by saturation under rule application. Note that it
cannot happen that the closure of a constraint differs in NS\Sigma  and NSfin\Sigma  . It is possible

however that the closure of constraint in NS\Sigma  is not closed for NSfin\Sigma  .

It is not difficult to show that a constraint is satisfiable in NS\Sigma  if it is closed for
NS\Sigma . In analogy, a constraint is satisfiable in NSfin\Sigma  if it is closed for NSfin\Sigma  . We thus
obtain the following result.

Proposition 6 (Satisfiability). Satisfiability in NS\Sigma  and NSfin\Sigma  can be decided in cubic time and the closure of a satisfiable constraint can be computed in cubic time.

Example 7. Let us compute the closure of the following constraint '3 with respect to
NS2:

'3 : x=f (y; x) ^ x^y ^ y=f (u; u) ^ u^x

By applying the reflexivity rule S1.1, we can add the trivial constraints x^x ^ y^y ^
u^u. Next we can apply the decomposition rule S2 for adding y^u ^ x^u. The
transitivity rule S1.2 applied to y^u ^ u^x yields y^x. Hence, we can apply the
decomposition rule S2 to y=f (u; u) ^ y^x ^ x=f (y; x) for deriving u^y ^ u^x.

The constraint obtained so far is closed with respect to the S1-S3 and thus is the
closure of '3 with respect to these rules. It is not closed with respect to S4.2 since
x=f (y; x) ^ y^x belongs to it. Hence, '3 is satisfiable in NS2 but not in NSfin2 .

5 Deciding Entailment
We first introduce a semi-decision procedure which sheds some more light on the
entailment problem and then formulate an algorithm solving it. The whole section is
parametrized by a constraint language NS which can be chosen to be either NS\Sigma 2 or
NSfin\Sigma 2 . The parameter NS matters only with respect to the satisfiability test applied as
a subprocedure to our entailment test.

5.1 A Semi-Decision Procedure for Entailment
The satisfiability test of Section 4 can turn into a simple semi-decision procedure for
entailment. We have implemented this procedure and thereby gained important insights
into the nature of strange loops. In this section, we first discussing the semi-decision
algorithm and then explain what we learned from its implementation; we call this
implementation LEO (a German name of a good friend who always helps you when
you are in trouble). We assume the following strict ordering on \Sigma 2:

? ! f ! ?
We need a predicate o/ [ss]h on trees o/ for all paths ss 2 f1; 2g\Lambda , and symbols h 2 \Sigma 2
which holds iff Lo/ (ss) = h We also introduce a form of path constraints x[ss]h which
we interpret with respect to the above path relation.

Definition 8. A contradiction node for an entailment judgment ' j= x^y in NS is a
path ss 2 f1; 2g\Lambda  for which there exist symbols h1; h2 2 \Sigma 2 such that h2 ! h1 and
' ^ x[ss]h1 ^ y[ss]h2 is satisfiable in NS.

Proposition 9. Let  be a constraint of NS and x; y two variables. The entailment
judgment ' j= x^y holds in NS iff there exists no contradiction node for ' j= x^y in
NS.

Proof. This follows directly from the definition of entailment and the tree semantics
of NS.

Proposition 9 induces a semi-decision procedure for entailment. Testing ' j= x^y
can be done by searching for a path f1; 2g\Lambda  and two symbols h2 ! h1 in \Sigma 2 such that
' ^ x[ss]h1 ^ y[ss]h2 is satisfiable. Satisfiability can checked in cubic time according
to Proposition 6 since a path constraint x[ss]h1 can be translated into an existentially
quantified formula over ordering constraints.

A contradiction tree for an entailment judgment ' j= x^y is a an infinite binarytree

o/ with domain Do/ = f1; 2g\Lambda  whose labels belong to the set of binary functionsymbols

fx; s; cg. Furthermore, we require for all ss 2 f1; 2g\Lambda  that ss is a contra-diction node for

' iff Lo/ (ss) = c. All

other nodes are either labeled by x for
"safe" or s for "strange". In the next
section, we will render the latter distinction precise.
A contradiction tree for the judgment
'2 j= x^y considered in example
4 is displayed to the right. In fact,
the set of all contradiction nodes for
'2 j= x^y is the language L(1+2(1[2)\Lambda ). It is quite obvious that the paths labeled
with x - those in L(ffl[2(1[2)\Lambda ) - are not contradiction nodes of '2. Recall that there
exists a strange loop in the graph of '2 with parameters x; y and path 1. This strange
loops induces the set of strange nodes L(1+) which are labeled with s since, perhaps
surprisingly, they are not contradiction nodes of '2.

The central issues to understand for entailment are the properties of sets of strange nodes,
i.e. those nodes that are not contradiction nodes
because of some strange loop. In order to figure
out these properties, we have implemented LEO,
a semi-decision procedure for entailment of NS2.
LEO inputs an entailment judgment and output its
contradiction tree up to a limited depth (less than
13). All picture of contradiction trees given in this
paper are automatically computed by LEO.
When analyzing the contradiction tree for '2 j=
x^y - the case of a simple strange loop with a binary function symbol - one might think that the set
of strange nodes does always form a line, i.e that
strange loops cannot generate a cluster of strange
nodes. Unfortunately, this is not true. A counter
example with a cluster of strange nodes of depth
2 exists, but its definition is quite involved. We
present such a constraint below. Given this constraint, LEO computes the contradiction tree displayed to the right.

For defining a constraint with the above contradiction tree, we make use of path
constraints which we will introduce only in Section 5.2. The idea (that we do not
elaborate here) is to overlay 4 strange loops at the path ss2ss where ss = 1112:

x!ss2^y ^ x^y!ss2
^ x!ss21^x1 ^ y1^y!ss21 ^ x1!112^y1 ^ x1^y1!112
^ x!ss211^x2 ^ y2^y!ss211 ^ x2!12^y2 ^ x2^y2!12
^ x!ss2111^x3 ^ y3^y!ss2111 ^ x3!2^y3 ^ x3^y3!2

Such kinds of examples are quite tedious to explain and even more difficult to verify. However, they illustrate the usefulness of LEO. There are more interesting properties of sets of strange nodes which can be observed with the help of LEO but there is
no space for more examples here.

5.2 Path Constraints
We next turn towards a formal definition of safe nodes. We fix two variables x; y and
introduce the notions for syntactic support in order the define the set of safe nodes
Safe' for a judgment ' j= x^y. Note that the set Safe' depends on the global variables
x and y.

We need some new forms of path relations: o/1!ss^o/2, o/1^o/2!ss, o/1!ss1^o/2!ss2,
o/ !ss^f , f ^o/ !ss, and o/1[ss]o/2. These relations are define as follows:

o/1!ss^o/2 iff 9ss0 ! ss : Lo/1(ss0) = ? or o/1[ss]^o/2
o/1^o/2!ss iff 9ss0 ! ss : Lo/2(ss0) = ? or o/1^o/2[ss]
o/1!ss1^o/2!ss2 iff 9o/ : o/1!ss1^o/; and o/ ^o/2!ss2
o/ !ss^f iff 9o/1; o/2 : o/ !ss^f (o/1; o/2)
f ^o/ !ss iff 9o/1; o/2 : f (o/1; o/2)^o/ !ss
o/1[ss]o/2 iff ss 2 Do/1 and o/1[ss] = o/2

For each path relations we introduce a corresponding path constraints of the form
u!ss^v, u^v!ss, u!ss1^v!ss2, u!ss^f , f ^u!ss, and u[ss]v. Of course these path constraints are interpreted with respect to the above path relations.

Lemma 10. The following equivalence are valid in NS:

u^v!ss $ 9w(w[ss]u ^ w^v);
u!ss^v $ 9w(u^w ^ w[ss]v);
u[ss]v $ v^u!ss ^ u!ss^v

5.3 Syntactic Support
Define the following notions of syntactic support which prove that a path constraint _
is entailed by some constraint ':

' ` u!"^v if u^v in '
' ` u!ss1^v if ' ` u!ss^w; w=f (w1; w2) in '; and w1^v in '
' ` u!ss2^v if ' ` u!ss^w; w=f (w1; w2) in '; and w2^v in '

' ` u^v!" if u^v in '
' ` u^v!ss1 if ' ` w^v!ss; w=f (w1; w2) in '; and u^w1 in '
' ` u^v!ss2 if ' ` w^v!ss; w=f (w1; w2) in '; and u^w2 in '

' ` u!ss^v!ss if 9w 2 V(') : ' ` u!ss^w; and ' ` w^v!ss

' ` u!ss^f if 9v; v1; v2 2 V(') : ' ` u!ss^v; and v=f (v1; v2) in '
' ` f ^u!ss if 9v; v1; v2 2 V(') : ' ` v^u!ss; and v=f (v1; v2) in '

' ` u[ss]v if ' ` u!ss^v and ' ` v^u!ss:

Lemma 11. For all ' and path constraints _: if ' ` _ then ' j= _ in NS.
Definition 12. Given a closed constraint ' which x; y 2 V(') we define the set Safe'
of safe path for ' j= x^y as follows:

Safe' = fss j ' ` x!ss^f and ' ` f ^y!ssg

[fssss0 j ' ` x!ss^y!ss and ss0 2 f1; 2g\Lambda g

Proposition 13. No save node ss 2 Safe' is a contradiction node for ' j= x^y.
Proof. We assume ss 2 Safe' and show based on Lemma 11 that ' ^ x[ss]h1 ^ y[ss]h2
is unsatisfiable for all h2 ! h1 from \Sigma 2.

Example 14. The set of safe nodes of the constraint '2 from Example 4 with the
strange loop is Safe'2 = L(ffl[2(1[2)\Lambda ) (where '2 : x^f (y; z) ^ f (x; z)^x).

Example 15. Let '4 be the constraint x=f (z; y) ^ z=f (z; x) ^ y=f (y; z). Note that
'4 j= x^y holds in NS2. The set of safe nodes of '4 is universal, i.e. Safe'4 = f1; 2g\Lambda .

Example 16. The set of safe node for 'A for the the universal automation A given in
Section 3.1 is Safe'A = f1; 2g\Lambda .

Lemma 17. The set Safe' is prefixed-closed for all '.

5.4 An Algorithm in PSPACE
Recall that the two variables x; y are fixed globally and that is NS be either NS2 or
NSfin2 . We now present an algorithm with inputs a constraint ' and decides entailment
judgments of the from ' j= x^y.

Proposition 18 (Characterization). Let ' be a constraint with x; y 2 V(') which is
closed with respect to NS. The entailment judgment ' j= x^y holds in NS if and only
if the set Safe' is universal, i.e. Safe' = f1; 2g\Lambda .

Proof. If Safe' = f1; 2g\Lambda  then there exists no contradiction node for ' j= x^y
(Proposition 13) and hence ' j= x^y holds according to Proposition 9. The converse
is much more involved. Its is restated in Section 6 as Lemma 20 and proved there.

Theorem 19 (Decidability and Complexity). Entailment of non-structural subtyping in NS2 or NSfin2 is PSPACE-complete.

Proof. Let NS be either NS2 or NSfin2 . Proposition 2 claims that entailment for NS is
PSPACE hard. It remains to present an algorithm deciding entailment of NS in polynomial space. We consider an entailment judgement ' j= x^y such that x; y 2 '
(otherwise we add x^x ^ y^y). By Proposition 6 we can assume that ' is closed
with respect to NS. According to the characterization of entailment in Proposition 18
it remains to check whether the set Safe' (which depends on x; y) is universal. It is
easy to construct a finite automaton in linear time which recognizes Safe' and whose
size is linear in the size of '. Checking universality for finite automata can be done in
PSPACE (the problem is even PSPACE-complete).

6 Completeness Proof
The goal of this section is to prove the completeness implication of the characterization
of entailment given in Proposition 18. We restate this as the following lemma:

Lemma 20 (Completeness of the Characterization). Let ' be a constraint which is
closed with respect to NS and such that x; y 2 V('). If Safe' is not universal then the
entailment judgment ' j= x^y does not hold in NS.

Definition 21. We define the set Base' of bases of ' and Trace' of traces of ' as
follows (where x; y 2 V(') are the variables fixed for the right hand side of entailment
judgments ' j= x^y):

Base' = fss j 9u1 ' ` x!ss^u1 and 9u2 ' ` u2^y!ssg

[fssss0 j ' ` x!ss^y!ss and ss0 2 f1; 2g\Lambda g

Trace' = pr(fss0ss\Lambda  j ss0ss 2 Base'g)
The set Base' of bases of ' is a superset of Safe' which contains all building atomic
building blocks of strange loops. The set Trace' of traces of ' is a superset of all
strange nodes which is motivated by technical reasons that will show up in proofs later
on.

Lemma 22. The set pr6=(Base') is equal to the set Safe'.
Proof. We are starts with a path ss in pr6=(Base') created by ' ` x!ss^u1 and ' `
u2^y!ss. All proper prefix of ss are accepted by A'. This can be proofed by induction
on ss.

The following Proposition shows that our entailment in NS2 does not depend on
strange loops. We describe all possible strange nodes as set Trace' and show if there
is a not safe path, then there is a not safe path outside the traces.

Proposition 23 (Escape). If oe =2 Safe' then there exists path % such that oe ! % and
% =2 Trace'.

Proof. We assume oe =2 Safe' and define % := oe1joej2 where joej denotes the length of
oe and 1n a word which consists exactely of n letters 1. It is obvious that oe is a proper
prefix of %. We prove that % =2 Trace' holds. Before doing so, we enumerate some
simple properties for %:

1. It holds that % =2 Safe'. Otherwise, every prefix of % would belong to safe (Lemma

17) in contradiction that to oe ! % and oe 62 Safe'.
2. We show % 62 Trace' by contradiction. We assume % 2 Trace'. By definition there

exists paths o; ss 2 Base' such that % 2 pr(oss\Lambda ). Since pr6=(oss) ` Safe' (Lemma
22) we have the following estimations:(1)

oss^oe (otherwise oe is in Safe', because Safe'is prefix closed).
(2) jossj ^ joej (follows directly from (1))
(3) jssj ^ joej (follows directly from (2))

We have the property % is in pr(oss\Lambda ) and % = oe1joej2.
(4) There exists paths oe2,oe3 such that oe = ooe2 with ss\Lambda  = oe21joej2oe3 (follows from

(1) )
From (3) and (4) follows ss is in 1\Lambda  and have the last sign 2. But this is a
contradiction, so we have shown the contra position.

Definition 24. We call a set D ` f0; 1g\Lambda  domain closed if D is prefixed-closed and
satisfies for all ss 2 f1; 2g\Lambda : if ss1 2 D then ss2 2 D and if ss2 2 D then ss1 2 D.
The domain closure dc(D) is the least domain closed set containing D.

Definition 25 (Saturation). We assume a constraint ' which is closed with respect to
NS ,two variables x0; y0 2 V ('), and a path %. We define a constraint satx0;y0('; %)
such that it coincides with the closure of ' ^ x0[%]u ^ y0[%]f for some variable u.

Let q be a function that maps a variable x0 and a path ss to another variable qx

0

ss . Weassume that qz

ss is fresh for all z 2 fx0; y0g and all ss in dc(f%1; %2g). We define thefollowing set of variables:

W('; %) = fqzss j z 2 fx0; y0g; ss 2 dc(f%1; %2g)g
We define satx0;y0('; %) to be the constraint of minimal size which satisfies the following properties:

a. ' in satx0;y0('; %)
b. for qx

0

ss 2 W('; %) : qx

0
ss =f (qx

0
ss1; qx

0
ss2) in satx0;y0('; %) if ss ! %c. for q
y0ss 2 W('; %) : qy0ss =f (qy0ss1; qy0ss2) in satx0;y0('; %) if ss^%

d. for z 2 fx0; y0g, qzss 2 W('; %); u 2 V(') : qzss^u in satx0;y0('; %) if ' ` z!ss^u

e. for z 2 fx0; y0g, qzss 2 W('; %); u 2 V(') : u^qzss in satx0;y0('; %) if ' ` u^z!ss

f. for z; z0 2 fx0; y0g, qzoss; qz

0

o0ss 2 W('; %) : qzoss^qz

0
o0ss in satx0;y0('; %) if ' `z!o^z0!o0, ss 2 f1; 2g\Lambda .

Finally, we define the two saturations of ' at path % and with respect to the global
variables x; y by sat1('; %) = satx;y('; %) and sat2('; %) = saty;x('; %). 1

Lemma 26. If the constraint ' is closed for NS then sati('; %), i 2 f1; 2g is closed
for NS.

Lemma 27. It properties sati('; %) ` x[%]qx% and sati('; %) ` y[%]qy% hold.
Lemma 28 (Contradiction). For every given closed formula ', path o 62 Safe', and
% =2 Trace': if o^% then % is a contradiction node for ' j= x^y in NS.

1 The definition of a saturation has been slightly corrected after the submission of the paper

We prepare the proof of this contradiction lemma by two auxiliary lemmas.
Lemma 29 (Unconstrained Paths). If o 62 Safe' then the following statements hold:

1. For all ss^o. ' 6` x!ss^y!ss.
2. Either ' 6` x!o^f or ' 6` f ^y!o.

Proof. By definition of Safe'.
Lemma 30. If ' 6` x!o^f the following two properties are valid:

1. For all u in V('): ' 6` x!o1^u and ' 6` x!o2^u
2. For all u in V('): ' 6` x!oss^u with ss in f1; 2g+

Proof. Statement 1. follows from ' 6` x!o^f according to the defintion of syntactic
support. Statement 2. is a conclusion of statement 1., because the set Safe'is prefixedclosed.

Proof of the Contradiction Lemma 28. Let ' be a closed constraint, o 62 Safe', and
% =2 Trace'. We show for all o^% that % is a contadiction node for ' j= x^y in NS.
According to property 2. of Lemma 29 there are two possibilities,
either ' 6` x!o^f or ' 6` f ^y!o. Without loss of generality, we guess ' 6` x!o^f . We
show that % is a contradiction node by proving that ' ^ x[%]? ^ y[%]f is satisfiable. If
' 6` f ^y!o would hold then we could show that ' ^ x[%]f ^ y[%]? is satisfiable. In
order to prove the satisfiablity of

' ^ x[%]? ^ y[%]f
it suffices to verify according to Lemma 27 and the fact qy%=f ( ; ) in sat1('; %) that
the following formula is satisfiable:

sat1('; %) ^ qx%=?
The formula sat1('; %) is satisfiable in NS because it is closed in NS due to Lemma 26.
It is tedious to check but elaborated in the full paper that the formula sat1('; %)^qx%=?
is closed for NS. For illustration, we consider the most interesting rule which is S3:3.
Suppose that S3:3 would apply. Then there exists a w 2 V(sat1('; %)) such that:

qx%^w ^ w=f ( ; ) in sat1('; %)
There is a large case distinction which shows that this is impossible. The most interesting case to be considered here is w 2 W('; %) and w ! %: The definition of Trace'
and % =2 Trace' ensures for all v that qx%^v 62 sat1('; %). Hence qx%^w 62 sat1('; %)
holds, in contradiction to the above assumption.

Proof of Completeness of the Characterization 20. The set Safe' is not universal,
so there exists a path o not in Safe' and following the Escape Proposition 23 there is
a path % not in Trace' with the property o ! %. The precondition of the Contradiction
Lemma 28 is hold, so we can build a contradiction node for the entailment judgment
' j= x^y. Thus the entailment ' j= x^y does not hold according to Proposition 9.

References

1. A. Aiken, E. Wimmers, and J. Palsberg. Optimal representation of polymorphic types with subtyping.

In P. Degano, R. Gorrieri, and A. Marchetti-Spaccamela, editors, Proceedings of the 24th Annual
Symposium on Theoretical Aspects of Computer Software, volume 1281 of LNCS, pages 47-76,
1997.2. H. A"it-Kaci, A. Podelski, and G. Smolka. A feature-based constraint system for logic programming

with entailment. Theoretical Computer Science, 122(1-2):263-283, Jan. 1994.3. W. Charatonik and A. Podelski. Set constraints with intersection. In Proceedings of the 12

th IEEE

Symposium on Logic in Computer Science, pages 352-361, Warsaw, Poland, 1997.4. J. D"orre. Feature logics with weak subsumption constraints. In Annual Meeting of the ACL (Association of Computational Logics), pages 256-263, 1991.5. J. D"orre and W. C. Rounds. On subsumption and semiunification in feature algebras. In Proceedings
of the 5th IEEE Symposium on Logic in Computer Science, pages 300-310, 1990.6. J. Eifrig, S. Smith, and V. Trifonow. Sound polymorphic type inference for objects. In Proceedings
of the 10th ACM Conference on Object-Oriented Programming: Systems, Languages, and Applications, volume 30 of ACM SIGPLAN Notices. ACM Press, New York, 1995.7. J. Eifrig, S. Smith, and V. Trifonow. Type inference for recursively constrained types and its application to object-oriented programming. Electronic Notes in Theoretical Computer Science, 1,
1995.8. Y. Fuh and P. Mishra. Type inference with subtypes. Theoretical Computer Science, 73, 1990.

9. F. Henglein and J. Rehof. The complexity of subtype entailment for simple types. In Proceedings of

the 12th IEEE Symposium on Logic in Computer Science, pages 362-372, Warsaw, Poland, 1997.10. F. Henglein and J. Rehof. Constraint automata and the complexity of recursive subtype entailment.

In K. Larsen, editor, Proceedings of the 25th International Conference on Automata, Languages,
and Programming, LNCS, Aalborg, Denmark, 1998.11. J. C. Mitchell. Type inference with simple subtypes. The Journal of Functional Programming,

1(3):245-285, July 1991.12. M. M"uller, J. Niehren, and A. Podelski. Ordering constraints over feature trees. Constraints, an
International Journal, 1999. Special Issue on the Special Issue on the 3rd International Conference
on Principles and Practice of Constraint Programming (CP'97). To appear.13. M. M"uller, J. Niehren, and R. Treinen. The first-order theory of ordering constraints over feature

trees. In Thirteenth annual IEEE Symposium on Logic in Computer Science (LICS98), pages 432-
443, Indianapolis, Indiana, 21-24 June 1998. Extended Paper at www.ps.uni-sb.de/Papers/
abstracts/FTSubTheory-98.html.14. J. Niehren, M. M"uller, and J.-M. Talbot. Entailment of atomic set constraints is PSPACE-complete,

Dec. 1998. www.ps.uni-sb.de/Papers/abstracts/atomic:98.html.15. Niehren, Joachim and Tim Priesnitz. Entailment of Non-Structural Subtyping Constraints, 1998.
Extended Paper at http://www.ps.uni-sb.de/~tim/Entailment.ps.16. J. Palsberg, M. Wand, and P. O'Keefe. Type Inference with Non-structural Subtyping. BRICS Report
Series RS-95-33, BRICS Basic Research in Computer Science, June 1995.17. F. Pottier. Simplifying subtyping constraints. In Proceedings of the ACM SIGPLAN International
Conference on Functional Programming, pages 122-133. ACM Press, New York, May 1996.18. F. Pottier. A framework for type inference with subtyping. In Proceedings of the third ACM SIGPLAN International Conference on Functional Programming, pages 228-238, Sept. 1998.19. F. Pottier. Type inference in the presence of subtyping: from theory to practice. Technical Report
3483, INRIA, Sept. 1998.20. J. Rehof. Ninimal typings in atomic subtyping. In ACM Symposium on Principles of Programming
Languages. ACM Press, 1997.21. J. Rehof. The Complexity of Simple Subtyping Systems. PhD thesis, DIKU, University of Copenhagen, 1998.22. G. Smolka and R. Treinen. Records for logic programming. Journal of Logic Programming,
18(3):229-258, Apr. 1994.23. Smolka et al. The Oz Programming System, 1995. Programming Systems Lab, Universit"at des
Saarlandes, http://www.ps.uni-sb.de/www/oz/.24. V. Trifonov and S. Smith. Subtyping constrained types. In R. Cousot and D. A. Schmidt, editors,
Proceedings of the 3rd International Static Analysis Symposium, volume 1145 of LNCS, pages 349-
365, Aachen, 1996.

A Proofs
Lemma 31 (Analysis). Examine the construction of sati('; %), i 2 f1; 2g: We assume
the variables u, v are in V(') and qzss, qz

0

ss0 are in W('; %). Constraints of the patternu^v are not new created in sat

i('; %), constraints of the pattern qzss^v, u^qz

0

ss0 andqz

ss^qz

0
ss0 are created by exactly one rule.

1. if u^v in sati('; %), then u^v in '2. a constraint q

zss^v in sati('; %) is created by rule d.

3. a constraint u^qz

0

ss0 in sati('; %) is created by rule e.4. a constraint qz

ss^qz

0
ss0 in sati('; %) is created by rule f.

Proof. By simple inspection the definition of sati('; %).

Lemma 26 (repeat). If the constraint ' is closed for NS then sati('; %), i 2 f1; 2g
is closed for NS.

Proof. The constraint sati('; %), i 2 f1; 2g is closed for NS if it is closed for S1:1 to
S4. Following the closure algorithm NS we make a case distinction:

sati('; %) is closed for S1:1: This case will be proofed by lemma 32.sat

i('; %) is closed for S1:2: This case will be proofed by lemma 33.sat
i('; %) is closed for S2: This case will be proofed by lemma 34.sat
i('; %) is closed for S3:1, S3:2,S3:3,S3:4: There is no constraint of the form =?or

=? in ' according to the restriction of our syntax and we have added no

constraint of such a form to the saturation of ' following Definition 25. Thus the
rules S3:1, S3:2,S3:3 and S3:4 cannot fail and our constraint sati('; %) is closed
for these rules.sat
i('; %) is closed for S4:1, S4:2: We must verify this case if NS is NSfin2 . This casewill be proofed by lemma 36.

Lemma 32. . If the constraint ' is closed for reflexivity then sati('; %), i 2 f1; 2g is
closed for reflexivity S1:1.

Proof. The formula ' is already closed for reflexivity. So we must proof: for all new
intoduced variables u in W('; %) there is the constraint u^u in sati('; %). Let be z 2
fx; yg: The formula ' is closed, so z^z is in '. Following the definition of the syntatic
support ' ` z!"^z, ' ` z^z!" and thus ' ` z!"^z!" are hold. According to rule f.
the constraint qzss^qzss is in sati('; %) for all new introduced variables qzss 2 W('; %).
So sati('; %) is closed for reflexivity.

Lemma 33. . If ' is closed for transitivity and descending then the constraint
sati('; %), i 2 f1; 2g is closed for transitivity S1:2.

Proof. We make a case distinction:

1. Let the variables u, v, w in V('). To proof is: If the constraints u^v and v^w are

in sati('; %), then u^w is in sati('; %).

u^v; v^w in sati('; %) (precondition)
) u^v; v^w in ' (Lemma Analysis 31)
) u^w in ' (' is closed for transitivity)
) u^w in sati('; %) (rule a. of the definition of sati('; %))

2. Let the variables v in V(') and qzss, qz

0

ss0 in W('; %). To proof is: If the constraintsqz

ss^v and v^qz

0
ss0 are in sati('; %), then qzss^qz

0
ss0 is in sati('; %).

qzss^v; v^qz

0

ss0 in sati('; %) (precondition)) ' ` z!ss^v; ' ` v^z0!ss0 (Lemma Analysis 31)

) ' ` z!ss^z0!ss0 (definition of syntactic support)
) qzss^qz

0

ss0 in sati('; %) (rule f. of the definition of sati('; %))

3. Let the variables u, v in V(') and qzss in W('; %). To proof is: If the constraints

u^v and v^qzss are in sati('; %), then u^qzss is in sati('; %).

u^v in sati('; %) (precondition)
) (1) u^v in ' (Lemma Analysis 31)

v^qzss in sati('; %) (precondition)
) ' ` v^z!ss (Lemma Analysis 31)

We make another case distiction:
3.1. case ss = ":

) ' ` v^z!" (case distinction)
) (2) v^z in ' (definition of syntactic support)
(1) ^ (2) ) u^z in ' (' is closed for transitivity)

) ' ` u^z!" (definition of syntactic support)
) ' ` u^z!ss (case distinction)
) u^qzss in sati('; %) (definition of sati('; %))

3.2. case ss = ss01:

) ' ` v^z!ss01 (case distinction)
) (2) 9r:' ` r^z!ss0

^(3) r=f (r1; r2) in '
^(4) v^r1 in ' (definition of syntactic support)
(1) ^ (4) ) (5) u^r1 in ' (' is closed for transitivity)
(2) ^ (3) ^ (5) ) ' ` u^z!ss01 (definition of syntactic support)

) ' ` u^z!ss (case distinction)
) u^qzss in sati('; %) (definition of sati('; %))

3.3. case ss = ss02: The proof of this case is analogous to case 3.2
4. This case is similar to case 3, but not identic. The reason is the definition of the

syntatic support. Let the variables v, w in V(') and qzss in W('; %). To proof is: If
the constraints qzss^v and v^w are in sati('; %), then qzss^w is in sati('; %).

v^w in sati('; %) (precondition)
) (1) v^w in ' (Lemma Analysis 31)

qzss^v in sati('; %) (precondition)
) ' ` z!ss^v (Lemma Analysis 31)

We make another case distiction:

4.1. case ss = ":

) ' ` z!"^v (case distinction)
) (2) z^v in ' (definition of syntactic support)
(2) ^ (1) ) z^w in ' (' is closed for transitivity)

) ' ` z!"^w (definition of syntactic support)
) ' ` z!ss^w (case distinction)
) qzss^w in sati('; %) (definition of sati('; %))

4.2. case ss = ss01:

) ' ` z!ss01^v (case distinction)
) (2) 9r:' ` z!ss0^r

^(3) r=f (r1; r2) in '
^(4) r1^v in ' (definition of syntactic support)
(4) ^ (1) ) (5) r1^w in ' (' is closed for transitivity)
(2) ^ (3) ^ (5) ) ' ` z!ss01^w (definition of syntactic support)

) ' ` z!ss^w (case distinction)
) qzss^w in sati('; %) (definition of sati('; %))

4.3. case ss = ss02: The proof of this case is analogous to case 4.2
5. Let the variables u, w in V(') and qzss in W('; %). To proof is: If the constraints

u^qzss and qzss^w are in sati('; %), then u^w is in sati('; %).

u^qzss in sati('; %) (precondition)
) (1) ' ` u^z!ss (Lemma Analysis 31)

qzss^w in sati('; %) (precondition)
) (2) ' ` z!ss^w (Lemma Analysis 31)

We continue this case with an induction on the path ss:
Induction Hypothesis: u^v in sati('; %) follows from (1) and (2).Beginning of Induction

ss = ":

(1) ) ' ` u^z!" (this induction case)

) (10) u^z in ' (definition of syntactic support)
(2) ) ' ` z!"^w (case distinction )

) (20) z^w in ' (definition of syntactic support)
(10) ^ (20) ) u^w in ' (' is closed for transitivity)

) u^w in sati('; %) (rule a. of the definition of sati('; %))

Induction step from ss to ss1: Let ss be ss01.

(1) ) ' ` u^z!ss01 (this induction case)

) (3) 9p:' ` p^z!ss0

^(4) p=f (p1; p2) in '
^(5) u^p1 in ' (definition of syntactic support)
(2) ) ' ` z!ss01^w (case distinction )

) (6) 9r:' ` z!ss0^r

^(7) r=f (r1; r2) in '
^(8) r1^w in ' (definition of syntactic support)
(3) ^ (6) ) p^r in sati('; %) (follows from Induction Hypothesis)

) (9) p^r in ' (Lemma Analysis 31)
(4) ^ (9) ^ (7) ) (10) p1^r1 in ' (' is closed for descend)
(5) ^ (10) ^ (8) ) u^w in ' (' is closed for transitivity)

) u^w in sati('; %) (rule a. of the definition of sati('; %))

Induction step from ss to ss2: This step is analogous to the previous induction

step.

6. Let the variables w in V(') and qzss, qz

0

ss0 in W('; %). To proof is: If the constraintsqz

ss^qz

0
ss0 and qz

0
ss0^w are in sati('; %), then qzss^w is in sati('; %).

qzss^qz

0

ss0 in sati('; %) (precondition)) ' ` z!oe^z0!oe0 (Lemma Analysis 31)

^(1) oeo/ =ss ^ oe0o/ =ss0 (following rule f. of the saturation)
) (2) 9p:' ` z!oe^p

^(3) ' ` p^z0!oe0 (definition of syntactic support)

(4) qz

0

ss0^w in sati('; %) (precondition)

We continue this case with an induction on the path o/ :
Induction Hypothesis: qzss^w in sati('; %) follows from (1), (2), (3) and (4).Beginning of Induction

o/ = ":

(1) ) (10) oe=ss ^ oe0=ss0 (this induction case)
(2) ^ (10) ) ' ` z!ss^p

) (20) qzss^p in sati('; %) (rule d. of the saturation)
(3) ^ (10) ) ' ` p^z0!ss0

) (30) p^qz

0

ss0 in sati('; %) (rule e. of the saturation)(30) ^ (4) ) (5) p^w in sat

i('; %) (according to case 5)
(20) ^ (5) ) qzss^w in sati('; %) (according to case 4)

Induction step from o/ to o/ 1: Let o/ be o/ 01.

(1) ) (10) oeo/ 01=ss ^ oe0o/ 01=ss0 (this induction case)
(10) ) (1\Lambda ) oeo/ 0=ss\Lambda  ^ oe0o/ 0=ss0\Lambda  (definition of ss\Lambda  and ss0\Lambda )
(4) ^ (10) ) qz

0

oe0o/01^w in sati('; %)) ' ` z0!oe0o/ 01^w (Lemma Analysis 31)

) (40) 9r:' ` z0!oe0o/ 0^r

^(5) r=f (r1; r2) in '
^(6) r1^w in ' (definition of syntactic support)
(40) ) (400) qz

0

oe0o/0 ^w in sati('; %) (rule d. of the saturation)(400) ^ (1\Lambda ) ) (4\Lambda ) qz0

ss0\Lambda ^w in sati('; %)
(1\Lambda ) ^ (2) ^ (3) ^ (4\Lambda ) ) qzss\Lambda ^r in sati('; %) (follows from Induction Hypothesis)

) (7) ' ` z!ss\Lambda ^r (Lemma Analysis 31)
(7) ^ (5) ^ (6) ) (70) ' ` z!ss\Lambda 1^w (definition of syntactic support)

(70) ^ (1\Lambda ) ) (700) ' ` z!oeo/ 01^w
(700) ^ (10) ) ' ` z!ss^w

) qzss^w in sati('; %) (rule d. of the saturation)

Induction step from o/ to o/ 2: This step is analogous to the previous induction

step.

7. Let the variables u in V(') and qzss, qz

0

ss0 in W('; %). To proof is: If the constraintsu^qz

ss and qzss^qz

0
ss0 are in sati('; %), then u^qz

0
ss0 is in sati('; %).

This proof is analogous to case 6.

8. Let the variables qzss, qz

0

ss0 and qz

00
ss00 in W('; %). To proof is: If the constraints qzss^qz

0
ss0and qz0

ss0^qz

00
ss00 are in sati('; %), then qzss^qz

00
ss00 is in sati('; %).

qzss^qz

0

ss0 in sati('; %) (precondition)) ' ` z!oe

1^z0!oe2 (Lemma Analysis 31)
^(1) oe1o/ =ss ^ oe2o/ =ss0 (following rule f. of the saturation)

) (2) 9p:' ` z!oe1^p

^(3) ' ` p^z0!oe2 (definition of syntactic support)

qz

0

ss0 ^qz

00
ss00 in sati('; %) (precondition)) ' ` z0!oe

3^z00!oe4 (Lemma Analysis 31)
^(4) oe3o/ 0=ss0 ^ oe4o/ 0=ss00 (following rule f. of the saturation)

) (5) 9r:' ` z0!oe3^r

^(6) ' ` r^z00!oe4 (definition of syntactic support)

We make another case distiction:
8.1. There is a path ss\Lambda  such that o/ = ss\Lambda o/ 0:

(1) ) (10) oe1ss\Lambda o/ 0=ss ^ oe2ss\Lambda o/ 0=ss0 (precondition of this case)
(10) ^ (4) ) (7) oe3=oe2ss\Lambda 

qzss^qz

0

ss0 in sati('; %) (precondition)) ' ` z!oe

1^z0!oe2 (Lemma Analysis 31)
) (8) qzoe1ss\Lambda ^qz

0

oe2ss\Lambda  in sati('; %)if qz

oe1ss\Lambda ; qz

0
oe2ss\Lambda  2 W('; %) (following rule f. of the saturation)

(7) ^ (8) ) (80) qzoe1ss\Lambda ^qz

0

oe3 in sati('; %)if qz

oe1ss\Lambda ; qz

0
oe3 2 W('; %)

(5) ) (50) qz

0

oe3 ^r in sati('; %) (following rule d. of the saturation)

^ qz

0

oe3 2 W('; %)

(6) ) (60) r^qz

00

oe4 in sati('; %) (following rule e. of the saturation)(80) ^ (50) ) (9) qz

oe1ss\Lambda ^r in sati('; %) (according to case 6)if qz
oe1ss\Lambda  2 W('; %)
(9) ^ (60) ) qzoe1ss\Lambda ^qz

00

oe4 in sati('; %) (according to case 2)if qz

oe1ss\Lambda  2 W('; %)
) qzoe1ss\Lambda o/0 ^qz

00

oe4o/0 in sati('; %) (Lemma Analysis 31 andif qz

oe1ss\Lambda ; qzoe1ss\Lambda o/0; qz

00
oe4o/0 2 W('; %) rule f. of the saturation)

) (10) qzoe1ss\Lambda o/0 ^qz

00

oe4o/0 in sati('; %)if qz

oe1ss\Lambda o/0 ; qz

00
oe4o/0 2 W('; %) (W('; %) is domain closed)

(10) ^ (10) ) (11) qzss^qz

00

oe4o/0 in sati('; %)if qz

ss; qz

00
oe4o/0 2 W('; %)

(11) ^ (4) ) (12) qzss^qz

00

ss00 in sati('; %)if qz

ss; qz

00
ss00 2 W('; %)(13) qz

ss; qz

0
ss0; qz

00
ss00 2 W('; %) (precondition of this case)

(12) ^ (13) ) qzss^qz

00

ss00 in sati('; %)

8.2. There is a path ss\Lambda  such that o/ 0 = ss\Lambda o/ : This case is analogous to case 8.1.
8.3. There is no path ss\Lambda  such that o/ = ss\Lambda o/ 0 or o/ 0 = ss\Lambda o/ . This is a contradiction to

(1) and (4). Thus this case cannot happen.

8.4. case o/ =o/ 0: This case is redundant to case 8.1. but here is a shorter proof:

(1) ^ (4) ) (10) oe2=oe3 (precondition of this case)
(5) ^ (10) ) ' ` z0!oe2^r

(50) qz

0

oe2 ^r in sati('; %) (following rule d. of the saturation)

(3) ) (30) p^qz

0

oe2 in sati('; %) (following rule e. of the saturation)

(6) ) (60) r^qz

00

oe4 in sati('; %) (following rule e. of the saturation)(30) ^ (50) ) (7) p^r in sat

i('; %) (according to case 5)
(7) ^ (60) ) (8) p^qz

00

oe4 in sati('; %) (according to case 3)) (80) ' ` p^z00!oe

4 (Lemma Analysis 31)
(2) ^ (80) ) ' ` z!oe1^z00!oe4 (definition of syntactic support)

) (9) qzoe1o/ ^qz

00

oe4o/ in sati('; %)if qz

oe1o/ ; qz

00
oe4o/ 2 W('; %) (following rule f. of the saturation)

(9) ^ (1) ) (10) qzss^qz

00

oe4o/ in sati('; %)if qz

ss; qz

00
oe4o/ 2 W('; %)

(10) ^ (4) ) (11) qzss^qz

00

ss00 in sati('; %) (remember o/ =o/ 0)if qz

ss; qz

00
ss00 2 W('; %)(12) qz

ss; qz

0
ss0; qz

00
ss00 2 W('; %) (precondition of this case)(11) ^ (12) ) qz

ss^qz

00
ss00 in sati('; %)

Lemma 34. . If ' is closed for descending and reflexivity then the constraint
sati('; %), i 2 f1; 2g is closed for descending S2.

We prepare the proof of this lemma by another analysis:
Lemma 35 (Analysis 2). Examine the construction of sati('; %), i 2 f1; 2g: We assume the variable u is in V(') and qzss is in W('; %).

1. a constraint u=f ( ; ) is in sati('; %) if and only if u=f ( ; ) is in '
2. a constraint qzss=f ( ; ) in sati('; %) is created by rule b. or c. and have the form

qzss=f (qzss1; qzss2)

Proof. By simple inspection the definition of sati('; %).
Proof of 34. We make a case distinction:

1. Let the variables u, v in V('). To proof is: If the constraints u=f (u1; u2),

v=f (v1; v2) and u^v are in sati('; %), then u1^v1 and u2^v2 are in sati('; %).

u^v in sati('; %) (precondition)
) (1) u^v in ' (Lemma Analysis 31)

u=f (u1; u2) in sati('; %) (precondition)
) (2) u=f (u1; u2) in ' (Lemma Analysis 35)

v=f (v1; v2) in sati('; %) (precondition)
) (3) v=f (v1; v2) in ' (Lemma Analysis 35)
(2) ^ (1) ^ (3) ) u1^v1; u2^v2 in ' (' is closed for descending)

) u1^v1; u2^v2 in sati('; %) (rule a. of the definition of sati('; %))

2. Let the variables u in V(') and qzss in W('; %). If a constraint qzss=f ( ; ) is in

sati('; %) then it has the form qzss=f (qzss1; qzss2) according to Lemma 35. To proof
is: If the constraints u=f (u1; u2), qzss=f (qzss1; qzss2) and u^qzss are in sati('; %),
then u1^qzss1 and u2^qzss2 are in sati('; %).

u^qzss in sati('; %) (precondition)
) (1) ' ` u^z!ss (Lemma Analysis 31)

u=f (u1; u2) in sati('; %) (precondition)
) (2) u=f (u1; u2) in ' (Lemma Analysis 35)
) u1; u2 2 V(')
) (3) u1^u1 (' is closed for reflexivity)

^(4) u2^u2 (' is closed for reflexivity)
(1) ^ (2) ^ (3) ) ' ` u^z!ss1 (definition of syntactic support)

) u^qzss1 in sati('; %) (rule e. of the saturation)
(1) ^ (2) ^ (4) ) ' ` u^z!ss2 (definition of syntactic support)

) u^qzss2 in sati('; %) (rule e. of the saturation)

3. Let the variables v in V(') and qzss in W('; %). If a constraint qzss=f ( ; ) is in

sati('; %) then it has the form qzss=f (qzss1; qzss2) according to Lemma 35. To proof
is: If the constraints v=f (v1; v2), qzss=f (qzss1; qzss2) and qzss^v are in sati('; %), then
qzss1^v1 and qzss2^v2 are in sati('; %).
The proof is analogous to case 2.
4. Let the variables qzss and qz

0

ss0 in W('; %). First if the constraint qzss=f ( ; )is in sat

i('; %) then it has the form qzss=f (qzss1; qzss2) according to Lemma35. Second if the constraint q

z0ss

0 =f ( ; ) is in sati('; %) then it has the formq

z0ss

0=f (qz

0

ss01; qz

0
ss02) according to Lemma 35. To proof is: If the constraintsqz

ss=f (qzss1; qzss2), qz

0
ss0=f (qz

0
ss01; qz

0
ss02) and qzss^qz

0
ss0 are in sati('; %), then qzss1^qz

0
ss01and qz

ss2^qz

0
ss02 are in sati('; %).

qzss^qz

0

ss0 in sati('; %) (precondition)) (1) ' ` z!oe

1^z0!oe2 (Lemma Analysis 31)
^(2) oe1o/ =ss ^ oe2o/ =ss0 (following rule f. of the saturation)

(1) ) (3) qzoe1o/1^qz

0

oe2o/1 in sati('; %)if qz

oe1o/1; qz

0
oe2o/1 2 W('; %) (following rule f. of the saturation)

(3) ^ (2) ) (4) qzss1^qz

0

ss01 in sati('; %)if qz

ss1; qz

0
ss01 2 W('; %)(1) ) (5) qz

oe1o/2^qz

0
oe2o/2 in sati('; %)if qz

oe1o/2; qz

0
oe2o/2 2 W('; %) (following rule f. of the saturation)

(5) ^ (2) ) (6) qzss2^qz

0

ss02 in sati('; %)if qz

ss2; qz

0
ss02 2 W('; %)qz

ss=f (qzss1; qzss2) in sati('; %) (precondition)) (7) qz
ss1; qzss2 2 W('; %) (following rule b. and c. of the sat.)qz0
ss0=f (qz

0
ss01; qz

0
ss02) in sati('; %) (precondition)
) (8) qz

0

ss01; qz

0
ss02 2 W('; %) (following rule b. and c. of the sat.)(7) ^ (8) ^ (4) ) qz

ss1^qz

0
ss01 in sati('; %)(7) ^ (8) ^ (6) ) qz

ss2^qz

0
ss02 in sati('; %)

Lemma 36. . If ' is closed for occurs check S4:1, S4:2 then the constraint sati('; %),
i 2 f1; 2g is closed for occurs check.

Before we start its proof we prepare it by several auxiliary items:
Lemma 37. If ' is an arbitraray constraint the following two properties are valid:

' is closed for S4:1 , 8u2V(') 8ss6=": ' 6` u^u!ss

' is closed for S4:2 , 8u2V(') 8ss6=": ' 6` u!ss^u
Proof. By simple inspection the definition of the syntactic support.
Definition 38 (Help Saturation). We build an extension of the saturation 25: We assume a constraint ' which is closed with respect to NS and define a constraint sat\Lambda ('):

Let q be a function that maps a variable z 2 V (') and a path ss 2 f1; 2g\Lambda  to
another fresh variable qx

0

ss . The result is the following set of new introduced variables:

W \Lambda (') = fqzss j z 2 V ('); ss 2 f1; 2g\Lambda g

We define sat\Lambda (') to be the constraint of minimal size which satisfies the following
properties:

a. ' in sat\Lambda (')
b. for qzss 2 W \Lambda (') : qzss=f (qzss1; qzss2) in sat\Lambda (')

c. for qzss 2 W \Lambda ('); u 2 V(') : qzss^u in sat\Lambda (') if ' ` z!ss^u
d. for qzss 2 W \Lambda ('); u 2 V(') : u^qzss in sat\Lambda (') if ' ` u^z!ss

e. for qzoss; qz

0

o0ss 2 W \Lambda (') : qzoss^qz

0
o0ss in sat\Lambda (') if ' ` z!o^z0!o0, ss 2 f1; 2g\Lambda .

Lemma 39. The Help Saturation 38 is an extension of the Saturation 25, that means
the following statement is hold:

for i 2 f1; 2g : sati('; %) in sat\Lambda (')
Proof. By simple inspection of the definition of the saturation 25 and 38.
Lemma 40. If the constraint ' is closed for NS2 then sat\Lambda (') is closed for NS2.
Proof. Its proof is analogous to the proof of Lemma 26. Notice that this proof doesnot
include an occurs check because we restrict NS to NS2.

Proof of Lemma 36. We proof the contra position:
For i, j in f1; 2g: sati('; %) isnot closed for S4:j then ' isnot closed for S4:j.
Here is the proof of the case j=1, the proof of the other case j=2 is analogous:

sati('; %) isnot closed for S4:1 (precondition)
) 9u2V(sati('; %)) 9ss6=": sati('; %) ` u^u!ss (according to Lemma 37)
) 9u2V(sat\Lambda (')) 9ss6=": sat\Lambda (') ` u^u!ss (according to Lemma 39)

: : :
) 9u2V(') 9ss6=": ' ` u^u!ss
) ' isnot closed for S4:1

Lemma 27 (repeat). It properties sati('; %) ` x[%]qx% and sati('; %) ` y[%]qy%
hold for i 2 f1; 2g.

Proof. We prove that by induction on the path %:
Induction claim: x and y have got a subpath ss^% in sati('; %), this path ends with

the variable qxss resp. qyss. This claim is equal to sati('; %) ` x[ss]qxss and sati('; %) `
y[ss]qyss.Beginning of Induction:

The fixed variables x and y have got the path " (this
fact is hold for all variables in V(sati('; %))). Remains to be shown that
x=qx" in sati('; %) and y=qy" in sati('; %): There are x^x and y^y in ', because
' is reflexiv. It follows, that

' ` x^x!" and so x^qx" in sati('; %)
and

' ` x!"^x and so qx" ^x in sati('; %)

Furthermore there is

' ` y^y!" and so y^qy" in sati('; %)
and

' ` y!"^y and so qy"^y in sati('; %)

Induction step from (ss to ss1) or from (ss to ss2): The induction claim holds for the

path ss, this paths ends with qxss resp. qyss. We make another case distinction:

ss = %: The claim is be shown.
ss ! %: There is qxss=f (qxss1; qxss2) in sati('; %) and qyss=f (qyss1; qyss2) in sati('; %)

(in the case ss ! % follows this fact from rule b. and c.). Thus x and y have the
paths ss1 and ss2.

Definition 41. A limit node is defined to be a path ss in W('; %) with ss 6^ %.
Lemma 42 (Limit Node). For all limit nodes ss: there is no constraint qxss=f ( ; ) or
qyss=f ( ; ) in sati('; %) ,i 2 f1; 2g.

Proof. We make a case distinction:
ss ? % Following the definition of sati('; %) there are only four variables qy%1, qy%2 and

qx%1, qx%2 with this property. But these four variables have not got a f-bound of the
form qy:::=f ( ; ) according to the Defintion 25 of the saturation.
ss 6^ % and ss 6* %: First there are no new introduced variables in sati('; %) with this

property. Second according to the definition of sati('; %) we bound only variables
with the property ss^% to f ( ; ).

At this point we need a more fine grained definition of a special subset of Base':

Definition 43. We define the function \Lambda ' : ss 7! ss0 and the function \Delta ' : ss 7! ss0 as
follows (where x; y 2 V(') are the variables fixed for the right hand side of entailment
judgments ' j= x^y):

\Lambda '(oe) = max(fss j ss^oe ^ 9u:' ` x!ss^ug)

\Delta '(oe) = max(fss j ss^oe ^ 9u:' ` u^y!ssg)
Lemma 28 Contradiction (repeat). For every given closed formula ', path o 62
Safe', and % =2 Trace': if o^% then % is a contradiction node for ' j= x^y in NS.Proof of the Contradiction Lemma 28.

' is closed for NS: (precondition)
) sati('; %) is closed for NS: (according to Lemma 26)
) sati('; %) ^ ' is closed for NS: (according to rule a. of the saturation)
) sati('; %) ^ ' ^ x[%]qx% ^ y[%]qy% is closed for NS: (according to Lemma 27)

We make a case distinction: (Our case distinction is more fine grained than a case
distinction according to property 2. of Lemma 29.)

1. We assume the case \Lambda '(%1) ^ \Delta '(%1):

) sat1('; %) ^ ' ^ x[%]qx% ^ y[%]qy% ^ qy%=f (qy%1; qy%2) is closed for NS: (rule c. of the saturation)
) sat1('; %) ^ ' ^ x[%]qx% ^ y[%]f is closed for NS: (def. of syntatic support)
) sat1('; %) ^ ' ^ x[%]qx% ^ y[%]f ^ qx%=?; is closed for NS: (Lemma 44)
) sat1('; %) ^ ' ^ x[%]? ^ y[%]f is closed for NS: (def. of syntatic support)
) sat1('; %) ^ ' ^ x[%]? ^ y[%]f is satisfiable for NS: (a closed constraint is sat.)
) ' ^ x[%]? ^ y[%]f is satisfiable for NS:
) % is a contradiction node for ' j= x^y in NS: (Definitition 8)

2. We assume the case \Lambda '(%1) ? \Delta '(%1):

) sat2('; %) ^ ' ^ x[%]qx% ^ y[%]qy% ^ qx%=f (qx%1; qx%2) is closed for NS: (rule c. of the saturation)
) sat2('; %) ^ ' ^ x[%]f ^ y[%]qy% is closed for NS: (def. of syntatic support)
) sat2('; %) ^ ' ^ x[%]f ^ y[%]qy% ^ qy%=?; is closed for NS: (Lemma 46)
) sat2('; %) ^ ' ^ x[%]f ^ y[%]? is closed for NS: (def. of syntatic support)
) sat2('; %) ^ ' ^ x[%]f ^ y[%]? is satisfiable for NS: (a closed constraint is sat.)
) ' ^ x[%]f ^ y[%]? is satisfiable for NS:
) % is a contradiction node for ' j= x^y in NS: (Definitition 8)

Lemma 44. For every closed saturation sat1('; %), path o 62 Safe', and % =2 Trace':
if o^% and \Lambda '(%1) ^ \Delta '(%1) then sat1('; %) ^ qx%=? is closed for NS.

Proof. We add only one constraint of the form =? to sat1('; %), so only the rule S3.3
would apply. Thus sat1('; %) ^ qx%=? is closed for NS if the rule S3.3 would not apply.
We check this:

Suppose that S3:3 would apply. Then there exists a w 2 V(sat1('; %)) such that:

qx%^w ^ w=f ( ; ) in sat1('; %)

We make a case distinction on w to show that the upper fail rule cannot be happen.

We prepare this case distinction by an auxiliary proof: We show that the precondition of Lemma 30 is hold.

(1) o^% (precondition)
(2) fssj9u:' ` x!ss^ug is prefixed-closed (simple proof)
(3) fssj9u:' ` u^y!ssg is prefixed-closed (simple proof)

\Lambda '(%1) ^ \Delta '(%1) (precondition)
) (4) 8ss^%1:max(fssj9u:' ` x!ss^ug) ^

max(fssj9u:' ` u^y!ssg) (Definition 43)
(2) ^ (3) ^ (4) ) (5) 8ss^%1:9u:' ` x!ss^u ) 9u:' ` u^y!ss

(6) (9u:' ` x!ss1^u) ) ' ` x!ss^f (def. of syntactic support)
(7) (9u:' ` u^y!ss1) ) ' ` f ^y!ss (def. of syntactic support)
(5) ^ (6) ^ (7) ) 8ss^%:' ` x!ss^f ) ' ` f ^y!ss

) (8) 8ss^%:' 6` f ^y!ss ) ' 6` x!ss^f (contra position)
(1) ^ (8) ) ' 6` f ^y!o ) ' 6` x!o^f

(9) :(' 6` f ^y!o) . ' 6` x!o^f (propositional logic)
(10) ' 6` f ^y!o . ' 6` x!o^f (Lemma 29.2)
(9) ^ (10) ) (11) ' 6` x!o^f (propositional logic)

Case distinction on w:
1. The variable w is in V(') and o ! %:

The constraint qx%^w is created by rule d. according to Analysis 31. But the
condition for rule d. is ' ` x:%^w and this is forbidden by Lemma 30.2,
remember o ! %. So this case cannot create a failure.

2. The variable w is in V(') and o=%:

We assume there is a constraint qx%^w in sat1('; %) and a constraint
w=f ( ; ) in sat1('; %). according to our above analysis:

qx%^w in sat1('; %) (assumption)
) (12) ' ` x:%^w (Lemma Analysis 31)

w=f ( ; ) in sat1('; %) (assumption)
) (13) w=f ( ; ) in ' (Lemma Analysis 35)
(12) ^ (13) ) (14) ' ` x:%^f (def. of syntactic support)

(15) o=% (condition of this case)
(14) ^ (15) ) (16) ' ` x:o^f
(16) ^ (11) ) a contradiction

Thus this case cannot happen.

3. The variable w is in W('; %) and have the form w = qzss such that ss 6^ %:

The unequation ss 6^ % is hold, so w is a limit node according to Definition 41 and
thus there is no constraint like qzss=f ( ; ) in sat1('; %) according to Lemma 42.

4. The variable w is in W('; %) and have the form w = qxss such that ss=%:

We assume there is a reflexiv constraint qx%^qx% in sat1('; %) and a constraint
qx%=f ( ; ) in sat1('; %). But the variable qx% has not got a f-bound of the form

qx%=f ( ; ) according to the Defintion 25 of the saturation sat1('; %).
5. The variable w is in W('; %) and have the form w = qyss such that ss=%:

We assume there is a constraint qx%^qy% in sat1('; %) and a constraint
qy%=f ( ; ) in sat1('; %).

qx%^qy% in sat1('; %) (assumption)
) (12) ' ` x!oe^y!oe; oe^% (Lemma Analysis 31)

(13) 8ss^o:' 6` x!oe^y!oe (Lemma 29.1)
(12) ^ (13) ) ' ` x!oe^y!oe; o ! oe^%

) (14) 9u 2 V('):' ` x!oe^u; o ! oe^% (def. of syntatic support)

(15) 8u 2 V('):' 6` x!oe^u; o ! oe (Lemma 30.2)
(14) ^ (15) ) a contradiction

Thus this case cannot happen.

6. The variable w is in W('; %) and have the form w = qzss such that ss ! % and

z 2 fx; yg:
This is the most important case but also the most difficult case. We assume there is
a constraint qx%^qzss in sat1('; %) and a constraint qzss=f ( ; ) in sat1('; %).

(12) % =2 Trace' (precondition)

qx%^qzss in sat1('; %) (assumption)
^ ss!%
) ' ` x!%0^z!ss0 (Lemma Analysis 31)

^ %0oe=%; ss0oe=ss!%
) ' ` x!%0^z!ss0

^ %0oe=%; ss0oe=ss!%; ss0!%0
) ' ` x!ss0o/ ^z!ss0

^ ss0o/ oe=%; ss0oe=ss!%; o/ 6=" (%0 = ss0o/ )
) ' ` x!ss0o/ ^z!ss0

^ ss0o/ oe=%; oe2pr(o/ \Lambda ) (No-Escape Lemma 45)
) 9u:' ` x!ss0o/ ^u; ' ` u^z!ss0 (def. of syntactic support)

^ ss0o/ oe=%; oe2pr(o/ \Lambda )
) 9u:' ` x!ss0o/ ^u

^ ss0o/ oe=%; oe2pr(o/ \Lambda )
) 9u:' ` x!ss0o/ ^u; 9u:' ` u^y!ss0o/ (according to (5))

^ ss0o/ oe=%; oe2pr(o/ \Lambda )
) ss0o/ 2 Base' (Definition of Base)

^ ss0o/ oe=%; oe2pr(o/ \Lambda )
) ss0o/ 2 Base'

^ % 2 pr(ss0o/ o/ \Lambda )
) (13) % 2 Trace' (Definition of Trace)
(12) ^ (13) ) a contradiction

Thus this case cannot happen.
Lemma 45 (No-Escape). Let ss, oe and o/ be paths such that ssoe^sso/ oe. If o/ 6=" then oe
is a pefix of o/ \Lambda .

Proof.

(1) o/ 6=" (precondition)

ssoe^sso/ oe (precondition)
) (2) oe^o/ oe

We continue the proof with a natural induction on the length of oe:
Induction hypothesis: For all joej in N: (1) ^ (2) ) oe is a pefix of o/ \Lambda Beginning of Induction

joej^o/ : (2)) oe^o/Induction step joej ? o/ :

(3) joej ? o/ (condition of this case)
(2) ^ (3) ) (4) 9oe0:oe = o/ oe0
(1) ^ (4) ) (5) oe ? oe0
(2) ^ (4) ) o/ oe0^o/ o/ oe0

) oe0^o/ oe0
) oe 2 pr(o/ \Lambda ) (follows from induction hypothesis

with condition (5))

Lemma 46. For every closed saturation sat2('; %), path o 62 Safe', and % =2 Trace':
if o^% and \Lambda '(%1) ? \Delta '(%1) then sat2('; %) ^ qy%=? is closed for NS.

Proof. Its proof is analogous to the proof of Lemma 44.