

A Universe of Binding and Computation

Daniel R. Licata* Robert Harper *

Carnegie Mellon University

{drl,rwh}@cs.cmu.edu

Abstract
We construct a logical framework supporting datatypes that mixbinding and computation, implemented as a universe in the dependently typed programming language Agda 2. We represent bindingpronominally, using well-scoped de Bruijn indices, so that types
can be used to reason about the scoping of variables. We equipour universe with datatype-generic implementations of weakening, substitution, exchange, contraction, and subordination-basedstrengthening, so that programmers need not reimplement these operations for each individual language they define. In our mixed,pronominal setting, weakening and substitution hold only under
some conditions on types, but we show that these conditions canbe discharged automatically in many cases. Finally, we program
a variety of standard difficult test cases from the literature, suchas normalization-by-evaluation for the untyped

*-calculus, demon-strating that we can express detailed invariants about variable usage

in a program's type while still writing clean and clear code.
Categories and Subject Descriptors F.3.3 [Logics and MeaningsOf Programs]: Studies of Program Constructs--Type structure

General Terms Languages, Verification
1. Introduction
There has been a great deal of research on programming lan-guages for computing with binding and scope (bound variables,

ff-equivalence, capture-avoiding substitution). These languages areuseful for a variety of tasks, such as implementing domain-specific
languages and formalizing the metatheory of programming lan-guages. Functional programming with binding and scope involves
two different notions of function: functions-as-data and functions-as-computation. Functions-as-data, used to represent abstract syntax with variable binding, have an intensional, syntactic, character,in the sense that they can be inspected in ways other than function application. For example, many algorithms that process ab-stract syntax recur under binders, treating variables symbolically.
On the other hand, functions-as-computation, the usual functions of
* This research was sponsored in part by the National Science Foundation
under grant number CCF-0702381 and by the Pradeep Sindhu ComputerScience Fellowship. The views and conclusions contained in this document

are those of the author and should not be interpreted as representing theofficial policies, either expressed or implied, of any sponsoring institution,
the U.S. government or any other entity.

Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citationon the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.
ICFP'09, August 31-September 2, 2009, Edinburgh, Scotland, UK.Copyright cfl 2009 ACM 978-1-60558-332-7/09/08.. . $5.00

functional programming, have an extensional character--a functionfrom

A to B is a black box that, when given an A, delivers a B. Afunction-as-data determines a function-as-computation by substitution (plugging a value in for a variable), but not every function-as-computation determines a function-as-data, because the syntax
appropriate for a particular problem may not allow the expressionof every black box.

In previous work (Licata et al., 2008), we began to study aprogramming language that provides support for both functionsas-data and functions-as-computation as two different types. Ourframework provides one type constructor ) for functions-as-data,
used to represent variable binding, and another type constructoroe for functions-as-computation, used for functional programming.
This permits representations that mix the two function spaces. As asimple example of such integration, consider a syntax for arithmetic
expressions constructed out of (1) variables, (2) numeric constants,(3) let binding, and (4) arbitrary binary primitive operations, represented by functions-as-computation of type nat oe nat oe nat. InSML, we would represent this syntax with the following datatype:

datatype arith = Var of var| Num of nat

| Letbind of arith * (var * arith)| Binop of arith * (nat -> nat -> nat) * arith

We use ML functions(-as-computation) to represent the primops.However, because SML provides no support for functions-as-data,
we must represent variable binding explicitly (with a type var), andcode notions such as

ff-equivalence and substitution ourselves.In contrast, our framework naturally supports mixed datatypes

such as this one. We specify it by the following constructors:

num : arith ( nat
letbind : arith ( arith \Omega  (arith ) arith)
binop : arith ( arith \Omega  (nat oe nat oe nat) \Omega  arith

The symbol ( is used for datatype constructors, which have theform

D ( A, for a datatype name D and a type A. We use) (functions-as-data) to represent the body of the

letbind, and oe(functions-as-computation) to represent the primops.

Our framework takes a pronominal approach to the variablesintroduced by functions-as-data: variables are thought of as pronouns that refer to a designated binding site, and thus are intrinsi-cally scoped. This is in contrast to the nominal approach taken by
languages such as FreshML (Pitts and Gabbay, 2000; Pottier, 2007;Shinwell et al., 2003), where variables are thought of as nouns--
they are pieces of data that exist independently of any scope. Thepronominal approach inherently requires some notion of context
to be present in the language's type system, so that variables havesomething to refer to; we write h

\Psi i A as the classifier of a pro-gram of type
A with variables \Psi . The practical advantage of thesecontextual types is that they permit programmers to express useful

invariants about variable-manipulating code using the type system,such as the fact that a

*-calculus evaluator maps closed terms toclosed terms.

In a pronominal setting, the interaction of functions-as-dataand functions-as-computation has interesting consequences for the
structural properties of variables, such as weakening (introduc-ing a new variable that does not occur) and substitution (plugging
a value in for a variable). For example, one might expect that itwould be possible to weaken a value of type

A to a function-as-data of type
D ) A. However, this is not necessarily possiblewhen
A itself is a computational function type: Contextual com-putational functions of type h

\Psi i A oe B are essentially interpretedas functions from h
\Psi i A to h\Psi i B, and h\Psi i D ) A classifies val-ues of type
A in an extended context \Psi , x : D. Now, suppose weare given a function

f of type h\Psi i A oe B; we try to construct afunction of type h
\Psi i D ) (A oe B). This requires a function fromh
\Psi , x : Di A to h\Psi , x : Di B. Since f is a black box, we can onlyhope to achieve this by pre- and post-composing with appropriate

functions. The post-composition must take h\Psi i B to h\Psi , x : Di B,which would be a recursive application of weakening. However, the
pre-composition has a contravariant flip: we require a strengtheningfunction from h

\Psi , x : Di A to h\Psi i A in order to call f--and such astrengthening function does not in general exist, because the value

of type A might be that very variable x. Similarly, substitution ofterms for variables is not necessarily possible, because substitution requires weakening. Put differently, computational functionspermit the expression of side conditions that inspect the context,
which causes the structural properties to fail. As a concrete exam-ple, consider computational functions of type h*i

(arith oe arith),which are defined by case-analysis over closed arithmetic expressions, giving cases for constants and binops and let-binding--butnot for variables, because there are no variables in the empty context. Weakening such a function to type arith ) (arith oe arith)enlarges its domain, asking it to handle cases that it does not cover.

What are we to do about this interaction of binding and com-putation? One option is to work in a less general setting, where
it does not come up. For example, in nominal languages such asFreshML (Shinwell et al., 2003), the type of names is kept openended (it is considered to have infinitely many inhabitants). Thus,any computational function on syntax with binding must account
for arbitrarily many names, and is therefore weakenable. How-ever, many functions on syntax are only defined for certain classes
of contexts (e.g., only closed arithmetic expressions can be eval-uated to a numeral), and the nominal approach does not allow
these invariants to be expressed in a program's type (though theycan be reasoned about externally using a specification logic (Pottier, 2007)). Alternatively, in languages based on the LF logicalframework, such as Twelf (Pfenning and Schu"rmann, 1999), Delphin (Poswolsky and Schu"rmann, 2008), and Beluga (Pientka,2008), the structural properties always hold, because computational
functions cannot be used in LF representations of logical systems.In our framework, we take a more general approach, which
requires admitting that weakening and substitution may not alwaysbe defined. Thus, we should be more careful with terminology, and
say that the type D ) A classifies values of type A with a freevariable of type

D. In some cases, D ) A determines a functiongiven by substitution, but in some cases it does not. In this sense,

our approach is similar to representations of binding using well-scoped de Bruijn indices (Altenkirch and Reus, 1999; Bellegarde
and Hook, 1994; Bird and Paterson, 1999), which are pronominal,because variables are represented by pointers into a context, but
make no commitment to weakening and substitution. However,our framework improves upon such representations by observing
that weakening and substitution are in fact definable generically,not for every type

D ) A, but under certain conditions on thetypes
D and A. For example, returning to our failed attempt toweaken

A oe B above, if variables of type D could never appear interms of type

A, then the required strengthening operation would

exist. As a rough rule of thumb, one can weaken with types thatdo not appear to the left of a computational arrow in the type
being weakened, and similarly for substitution. Our frameworkimplements the structural properties generically but conditionally,
providing programmers with the structural properties "for free" inmany cases. This preserves one of the key benefits of working in
LF, where weakening and substitution are always defined.In our previous work (Licata et al., 2008), we investigated the
logical foundations of a pronominal approach to mixing bindingand computation. In the present paper, we give an implementation of (a slight variant of) our framework, and we demonstratethe viability of our approach by programming some standard difficult test cases from the literature. For example, we implementnormalization-by-evaluation (Berger and Schwichtenberg, 1991;
Martin-Lo"f, 1975) for the untyped *-calculus, an example consid-ered in FreshML by Shinwell et al. (2003). Our version of this algorithm makes essential use of a datatype mixing binding and com-putation, and our type system verifies that evaluation maps closed
terms to closed terms.Rather than implementing a new language from scratch, we construct our type theory as a universe in Agda 2 (Norell, 2007), adependently typed functional programming language that provides
good support for programming with inductive families, in the styleof Epigram (McBride and McKinna, 2004). This means that we
(a) give a syntax for the types of our type theory and (b) give afunction mapping the types of our language to certain Agda types;
the programs of our language are then the Agda programs of thosetypes. This implementation strategy allows us to reuse the considerable implementation effort that has gone into Agda, and to exploitgeneric programming within dependently typed programming (Altenkirch and McBride, 2003) to implement the structural proper-ties; additionally, it permits programs written using our framework
to interact with existing Agda code. Also, our development pro-vides a successful example of prototyping a new language with an
interesting type system using a dependently typed programminglanguage. In our Agda implementation, we have chosen to represent variable binding using well-scoped de Bruijn indices.In summary, we make the following technical contributions:
(1) We show that our previous type theory for integrating bind-ing and computation can be implemented as a universe in Agda.
The types of the universe permit concise, "point-free" descriptionsof contextual types: a type in the universe acts as a function from
contexts to Agda types. (2) We implement a variety of structuralproperties for the universe, including weakening, substitution, exchange, contraction, and subordination-based strengthening (Virga,1999), all using a single generic map function for datatypes that
mix binding and computation. (3) We define the structural prop-erties' preconditions computationally, so that our framework can
discharge these conditions automatically in many cases. This givesthe programmer free access to weakening, substitution, etc. (when
they hold). (4) We program a variety of examples, and demonstratethat we can express detailed invariants about variable usage in a
program's type while still writing clean and clear code.In this paper, we consider only a simply-typed universe, for
writing ML-like programs that manipulate binding in a well-scopedmanner; we leave dependent types to future work. Also, the companion code for this paper (see http://www.cs.cmu.edu/~drl/)is written in "Agda minus termination checking," as many of our
examples require non-termination; we discuss which parts of ourcode pass the termination checker below.

The remainder of this paper is organized as follows: In Sec-tion 2, we introduce our language and its semantics in Agda. In
Section 3, we present examples. In Section 4, we discuss the struc-tural properties. In Sections 5 and 6, we discuss related work and
conclude. Appendix A contains a brief introduction to Agda.

2. Language Definition
2.1 Types
The grammar for the types of our language is as follows:

Defined atoms D ::= . . .Var. Types

C ::= (a subset of D)Contexts

\Psi  ::= [] | (\Psi , C)Types

A ::= 0+ | 1+ | A \Omega  B | A \Phi  B | listA | A oe B

D+ D | C# | \Psi  )* A | 2A8

c .A | 9c .A | 8<=CA | 9<=CA

The language is parametrized by a class of defined atoms D,which are the names of datatypes. A subset of these names are

variable types, which are allowed to appear in contexts. This dis-tinguishes certain types

C which may be populated by variablesfrom other types
D which may not. This definition of VarTypepermits only variables of base type, rather than the full language

of higher-order rules that we considered in previous work (Licataet al., 2008). Contexts are lists of variable types, written with 'cons'
on the right.The types on the first line have their usual meaning. The type
D+ D is the datatype named by D. Following Delphin (Poswolskyand Schu"rmann, 2008), we include a type

C# classifying only thevariables of type
C. The type \Psi  )* A classifies inhabitants of
A in the current context extended with \Psi . The type 2A classifiesclosed inhabitants of

A. The types 8c and 9c classify universaland existential context quantification; 8

<=CA and 9<=CA providebounded quantification over contexts containing only the type C.

2.1.1 Agda implementation
We now represent these types in Agda. Those readers who are notfluent in dependent programming can find a review of Agda syntax,

well-scoped de Bruijn indices, and universes in Appendix A. Werepresent defined atoms, variable types and contexts as follows:

DefAtom = DefinedAtoms.Atom
data VarType : Set where

. : (D : DefAtom) {_ : Check(DefinedAtoms.world D)}-> VarType

Vars = List VarType
DefinedAtoms.Atom is a parameter that we will instantiate later.DefinedAtoms.world returns true when D is allowed to appear

in the context; Check turns this boolean into a proposition (CheckTrue is the unit type; Check False is the empty type; see Appendix A for an introduction). A VarType is thus a pair of an atomalong with the credentials allowing it to appear in contexts.

We represent the syntax of types in Agda as follows:
data Type : Set where-- types that have their usual meaning

1+ : Type_\Omega _ : Type -> Type -> Type
0+ : Type_\Phi _ : Type -> Type -> Type
list_ : Type -> Type_oe_ : Type -> Type -> Type
-- datatypes and context manipulationD+ : DefAtom -> Type
_# : VarType -> Type_)*_ : Vars -> Type -> Type2

: Type -> Type8c : (Vars -> Type) -> Type
9c : (Vars -> Type) -> Type8<= : VarType -> Type -> Type
9<= : VarType -> Type -> Type

The only subtlety in this definition is that we represent the bod-ies of 8c and 9c by computational functions in Agda. This choice
has some trade-offs: on the one hand, it means that the bodies ofquantifiers can be specified by any Agda computation (e.g. by recursion over the domain). On the other hand, it makes it difficult toanalyze the syntax of Types, because there is no way to inspect
the body of the quantifier. Indeed, this caused problems for ourimplementation of the structural properties, which we solved by
adding certain instances of the quantifiers (8) and 9), discussedbelow), which would otherwise be derived forms, as separate Type
constructors. In future work, we may pursue a more syntactic treat-ment of the quantifiers (which would of course be easier if we had
good support for variable binding. . . ).A rule, which is the type of a datatype constructor, pairs
the defined atom being constructed with a single premise type(no/multiple premises can be encoded using 1+ and \Omega ):

data Rule : Set where_(_ : DefAtom -> Type -> Rule
We will make use of a few derived forms:

* We write (8) A) for (8c \\Psi  -> \Psi  )* A), and similarly

for 9) (note that \ x -> e introduces an anonymous func-tion). This type quantifies over a context

\Psi  and immediatelybinds it around A. Similarly, we write [
\Psi  ]* A for 2 (\Psi  )*A)

* We write (C ) \Psi ) for )* with a single premise.

* We write (C +) for (D+ C) when C is a variable type.

* We write bool for 1+ \Phi  1+ and A option for A \Phi  1+.

2.2 Semantics
A universe is specified by a inductive datatype of codes for types,along with a function mapping each code to a Set. In this case,

the Types above are the codes, and the semantics is specified inFigure 1 by a function <

\Psi  > A, mapping a context and a Typeto an Agda Set. The first six cases interpret the basic types of the

simply-typed *-calculus as their Agda counterparts, pushing thecontext inside to the recursive calls.

The next two cases interpret datatypes. We define an auxiliarydatatype called Data which represents all of the data types defined
in the universe. Data is indexed by a context and a defined atom,with the idea that the Agda set Data

\Psi  D represents the valuesof datatype D in context
\Psi . For example, the values of Data \Psi arith will represent the arithmetic expressions defined by the signature given in the introduction. There are two ways to construct adatatype: (1) apply a datatype constructor to an argument and (2)
choose a variable from \Psi . Constants are declared in a signature,represented with a predicate on rules In

\Sigma  : Rule -> Set, whereIn
\Sigma  R is inhabited when the rule R is in the signature. The first con-structor, written as infix *, pairs a constant with the interpretation of

the constant's premise. The second constructor, ., injects a variablefrom

\Psi  into Data.1 See the appendix for the definition of the type2, which represents well-scoped de Bruijn indices (Altenkirch and

Reus, 1999; Bellegarde and Hook, 1994; Bird and Paterson, 1999).A DefAtom D is in the context if there exist credentials c for which
the VarType formed by (. D {c}) is in the list \Psi .Finally, we provide a collection of types that deal with the
context: \Psi  )* A extends the context (we write + for append); 2A clears the context. The quantifiers 8c and 9c are interpreted as
the corresponding Agda dependent function and pair types. Finally,
1 Agda allows overloading of datatype constructors between different types,
and we tend to use . for injections from one type to another, as withVarType above.

AllEq : Vars -> VarType -> SetAllEq

\Psi  D = Check (List.all (eqVarType D) \Psi )

mutualdata Data (

\Psi  : Vars) (D : DefAtom) : Set where_*_ : {A : Type}

-> In\Sigma  (D ( A) -> < \Psi  > A -> Data \Psi  D
. : {c : _} -> (. D {c}) 2 \Psi  -> Data \Psi  D

<_>_ : Vars -> Type -> Set-- basic types
< \Psi  > 1+ = Unit<

\Psi  > 0+ = Void<
\Psi  > (A \Omega  B) = (< \Psi  > A) * (< \Psi  > B)<
\Psi  > (A \Phi  B) = Either (< \Psi  > A) (< \Psi  > B)<
\Psi  > (list A) = List (< \Psi  > A)<
\Psi  > (A oe B) = (< \Psi  > A) -> (< \Psi  > B)-- data types

< \Psi  > (D+ D) = Data \Psi  D<

\Psi  > (D #) = D 2 \Psi -- context manipulation

< \Psi  > (\Psi new )* A) = < \Psi  + \Psi new > A< _ > (2 A) = < [] > A
< \Psi  > (9c o/) = \Sigma  \ \Psi ' -> < \Psi  > (o/ \Psi ')<

\Psi  > (8c o/) = (\Psi ' : Vars) -> < \Psi  > (o/ \Psi ')<
\Psi  > (8<= D A) =(

\Psi ' : Vars) -> AllEq \Psi ' D -> < \Psi  + \Psi ' > A<
\Psi  > (9<= D A) =
\Sigma  \ (\Psi ' : Vars) -> AllEq \Psi ' D * < \Psi  + \Psi ' > A

Figure 1. Semantics

the types 8<= D A and 9<= D A quantify over contexts \Psi ' forwhich AllEq

\Psi ' D holds. The type AllEq says that every variabletype in
\Psi  is equal to the given type D (List.all is true whenits argument is true on all elements of the list; eqVarType is a

boolean-valued equality function for variable types). (We couldinternalize AllEq

\Psi ' D as a type alleq D--given meaning by<
\Psi  > (alleq D) = AllEq \Psi  D--in which case the boundedquantifier could expressed as a derived form, but we have not

needed alleq D in a positive position in the examples we havecoded so far.)

An Agda datatype is strictly positive if it does not appear tothe left of any Agda function types (->) in its own definition; this
positivity condition ensures that the user does not define generalrecursive types (e.g.

uD.D ! D), which can be used to inhabitany type and to write non-terminating code. The above type Data

does not pass the positivity checker: it is defined mutually with<_>_, and <_>_ occurs to the left of an Agda function type in
the meaning of oe. In this paper, we wish to program with generalrecursive types, so we will ignore this failure of positivity checking.
An interesting direction for future work would be to consider a totalvariant of our framework, which admits only strictly positive types.
This would require a more refined explanation of the constructionof the defined atoms in the universe, e.g. using containers (Abbott
et al., 2005), because the positivity of a defined atom D depends onthe rules for D in the signature In

\Sigma .We also define versions of 2 and 8) that construct Agda Sets,

so that we do not need to write < [] > 2 A and so on as the Agdatype of a term. (We intentionally use a very similar notation for
these; to a first approximation, one can read our examples withoutkeeping this distinction in mind.)

\Gamma  : Type -> Set\Gamma  A = < [] > A
8)_ : Type -> Set8)_ A = (

\Psi  : Vars) -> < \Psi  > A

subst : (A : Type) {D : VarType}{_ : Check(canSubst (un

. Cut) A)}-> (8) (D ) A) oe (D +) oe A)

weaken : (A : Type) {D : VarType}{_ : Check (canWeaken (un

. D) A)}-> (8) A oe (D ) A))

strengthen : (A : Type) {D : VarType}{_ : Check (canStrengthen (un

. D) A)}-> 8) (D ) A) oe A

exchange2 : (A : Type) {D1 D2 : VarType}-> (8) (D2 ) D1 ) A) oe (D1 ) D2 ) A))
contract2 : (A : Type) {D : VarType}-> (8) (D ) D ) A) oe (D ) A))
weaken*/bounded : (A : Type) (\Psi  : Vars) {D : VarType}-> (AllEq

\Psi  D)-> {canw : Check (canWeaken (un

. D) A)}-> (8) A oe (
\Psi  )* A))

Figure 2. Type signatures of structural properties

2.3 Structural Properties
In Figure 2, we present the type signatures for the structural prop-erties; this is the interface that users of our framework see.

For example, the type of substitution should be read as follows:for any A and D, if the conditions for substitution hold, then there
is a function of type (8) (D ) A) oe (D +) oe A) (for anycontext, given a term of type A with a free variable, and something
of type D + to plug in, there is a term of type A without the freevariable). Weakening coerces a term of type A to a term with an
extra free variable; strengthening does the reverse; exchange swapstwo variables; contraction substitutes a variable for a variable.
We also include an n-ary version of weakening for use with thebounded quantifier: if A can be weakened with D, then A can be
weakened with a whole context comprised entirely of occurrencesof D.

We discuss the meaning of the conditions (canSubst, etc.)below; in all of our examples, they will be discharged automatically
by our implementation.
3. Examples
In this section, we illustrate programming in our framework, adapt-ing a number of examples that have been considered in the literature (Pientka, 2008; Poswolsky and Schu"rmann, 2008; Shinwellet al., 2003). Throughout this section, we compare the examples
coded in our framework with how they are/might be represented inTwelf, Delphin, Beluga, and FreshML. We endeavor to keep these
comparisons objective, focusing on what invariants of the code areexpressed, and what auxiliary functions the programmer needs to
define. Aside from Twelf, we are not expert users of these othersystems, and we welcome feedback from those who are. Several
additional examples are available in the companion Agda code, in-cluding a translation from

*-terms to combinators, a type checkerfor simply-typed
*-calculus terms, an evaluator for *-calculus withmutable references (using variables to represent locations), and an

alternate version of normalization-by-evaluation, which has sim-pler types at the expense of slightly more-complicated code.

To use our framework, we give a type DefAtom representing thenecessary datatypes names, along with a datatype
data In\Sigma  : Rule -> Set where
defining the datatype constructors.

We use the following naming convention: Defined atoms aregiven names that end in A; e.g., for the signature for arithmetic
expressions given in the introduction, we will define natA andarithA. For types of variables, we define <atom>C to be <atom>A
injected into VarType:
arithC = . arithA
We define <atom> to be the Type constructed by D+ <atom>A; e.g.:
nat = D+ natAarith = D+ arithA

3.1 Evaluating Arithmetic Expressions
We define a signature for the arithmetic example mentioned above:

zero : In\Sigma  (natA ( 1+)succ : In

\Sigma  (natA ( nat)

num : In\Sigma  (arithA ( nat)letbind : In

\Sigma  (arithA ( arith \Omega  (arithC ) arith))binop : In
\Sigma  (arithA ( arith \Omega (nat oe nat oe nat) \Omega 

arith)
Natural numbers are specified by zero and successor. Arithmeticexpressions are given as a mixed datatype, with ) used to represent

the body of the letbind and oe used to represent primops.Next, we define an evaluation function that reduces an expression to a number:

eval : \Gamma  (arith oe nat)eval (num * n) = n

eval (letbind * (e1 , e2)) = eval (subst arith _ e2 e1)eval (binop * (e1 , f , e2)) = f (eval e1) (eval e2)
eval (. ())
Evaluation maps closed arithmetic expressions to natural num-bers (the type expression \Gamma  (arith oe nat) reduces to the Agda

function type Data [] arithA ! Data [] natA). Constantsevaluate to themselves; binops are evaluated by applying their code
to the values of the arguments; let-binding is evaluated by substitut-ing the expression e1 into the letbind's body e22 and then evaluating the result. A simple variation would be to evaluate e1 firstand then substitute its value into e2. The final clause covers the
case for variables with a refutation pattern: there are no variables inthe empty context.

Comparison. This example provides a nice illustration of thebenefits of our approach: Substitution is provided "for free" by
the framework, which infers that it is permissible to substitute forarithC variables in arith. The type system enforces the invariant
that evaluation produces a closed natural number.It is not possible to define the type arith in Twelf/Delphin/Beluga,
as LF representations cannot use computational functions. Onecould program this example in FreshML, but it would be necessary
to implement substitution directly for arith, as FreshML does notprovide a generic substitution operation.

Agda checks that eval's pattern matching is exhaustive. How-ever, Agda is not able to verify the termination of this function, as it
recurs on a substitution-instance of one of the inputs. Setting asidethe computational functions in binop, it would be possible to get
the call-by-value version of this code to pass Twelf's termination
2 The arith argument to subst is the type A in the D ) A argument to
substitution; Agda's type reconstruction procedure requires this annotation.The underscore is the context argument instantiating the 8) in the type

of subst; this could be eliminated by adding an implicit context quantifier(whose meaning is {

\Psi  : Vars } -> ...) to the universe. The cre-dentials for performing substitution are marked as an implicit argument, so

there is no evidence of it visible in the call to subst.

checker, which recognizes certain substitution instances as smaller.We have not yet investigated how to explain this induction principle
to Agda.
3.2 Closure-based Evaluator
Next, we implement a closure-based evaluator for the untyped *-calculus.

*-terms and closures are represented by types exp andclos as follows:

lam : In\Sigma  (expA ( (expC ) exp))app : In

\Sigma  (expA ( exp \Omega  exp)

closure : In\Sigma  (closA ( (9) (expC ) exp) \Omega (expC # oe 2 clos)))

Expressions are defined by the usual signature, as in LF. The type ofclosures, clos, is a recursive type with one constructor closure.
The premise of closure should be read as follows: a closure isconstructed from a triple (

\Psi  , e , oe), where (1) \Psi  is an ex-istentially quantified context; (2) e is an expression in

\Psi  with anextra free variable, which represents the body of a
*-abstraction;and (3)
oe is a substitution of of closed closures for all the variablesin
\Psi . We represent a substitution as a function that maps each ex-pression variable in the context (classified by the type expC #) to

a closure. The type of the premise provides a succinct descriptionof all of this: 9) introduces the variables in the existentially quantified context into scope without explicitly naming the context; )extends the context with an additional variable; (expC #) ranges
over all of the variables in scope. For comparison, in \Psi  this typereduces to the Agda type

\Sigma  \(\Psi ' : Vars) -> (Data (\Psi  + \Psi ' " expC) expA) *(expC 2 (

\Psi  + \Psi ') -> Data [] closA)

(where we write " for cons on the right).In this example, unlike the above evaluator for closed arithmetic

expressions, we recur over open expressions, so eval is quantifiedover an unknown context

\Psi  using 8). Evaluation takes two furtherarguments: (1) an expression with free variables in

\Psi , and (2) anenvironment, represented by a function that yields a closed closure

for each expression variable in \Psi ; eval returns a closed closure.

env : Typeenv = expC # oe 2 clos

eval : \Gamma  (8) exp oe env oe 2 clos)eval

\Psi  (. x) oe = oe xeval
\Psi  (lam * e) oe = closure * (\Psi  , e , oe)eval
\Psi  (app * (e1 , e2)) oewith eval

\Psi  e1 oe... | closure * (

\Psi ' , e' , oe') =eval (
\Psi ' " expC) e'(extend{(2 clos)} _

oe' (eval \Psi  e2 oe))... |
. x = impossible x

A variable is evaluated by applying the substitution. A lam eval-uates to the obvious closure. To evaluate an application, we first

evaluate the function position. To a first approximation, the readermay think of Agda's with syntax as a case statement in the body
of the clause, with each branch marked by ... |. Case-analyzingthe evaluation of e1 gives two cases: (1) the value is constructed by
the constructor closure; (2) the value is a variable.In the first case, we evaluate the body of the closure in an
extended environment. The call to the function extend extends theenvironment

oe' so that the last variable is mapped to the value ofe2. The definition of extend is as follows:

extend : {A : Type} {D : VarType}-> (8) (D # oe A) oe A oe (D ) D #) oe A)
extend \Psi  oe new i0 = newextend

\Psi  oe new (iS i) = oe i

At the call site of extend, we must explicitly supply the type A (inthis case 2 clos) to help out type reconstruction. The underscore
stands for the instantiation of the 8), which is marked as anexplicit argument, but can in this case be inferred.

The second case is contradicted using the function impossible,which refutes the existence of a variable at a non-VarType--which
clos is, because we never wish to have clos variables.The context argument

\Psi  to eval does not play an interestingrole in the code, but Agda's type reconstruction requires us to

supply it explicitly at each recursive call. In future work, we mayconsider whether this argument can be inferred. Agda is unable to
verify the termination of this evaluator for the untyped *-calculus,as one would hope.

When writing this code, one mistake a programmer might makeis to evaluate the body of the closure in

oe instead of oe', whichwould give dynamic scope. If we make this mistake, Agda highlights the occurrence of oe and helpfully reports the type error that
\Psi ' != \Psi , indicating that the context of the expression does notmatch the context of the substitution.

Comparison. In Twelf, one cannot represent substitutions oe us-ing computational functions, because these are not available for
use in LF encodings. However, because the domain of the substi-tution is finite, a first-order representation of substitutions could be
used. Additionally, Twelf does not provide the 2 and 9) connec-tives that we use here to describe the contexts of closures. While
it should be possible for the programmer to express the neces-sary context invariants using explicit contexts (Crary, 2008), this
is a fairly heavy encoding technique. Because of these two limi-tations, the resulting Twelf code would be more complicated than
the above. One would hope for better Delphin and Beluga imple-mentations than a port of the Twelf code, but Delphin lacks existential context quantification and 2, and Beluga lacks the param-eter type exp #, so our definition of clos cannot be straightforwardly ported to either of these languages.3 One could implementthis example in FreshML (Shinwell et al., 2003), but the type system would not enforce the invariant that closures are in fact closed.To our knowledge, a proof of this property for this example has not
been attempted in Pure FreshML (Pottier, 2007), though we knowof no reason why it would not be possible.

3.3 Variable Manipulation
Next, we consider a suite of simple variable manipulations.

3.3.1 Size
First, we compute the size of a *-term. Addition is defined as usual,with a contradictory variable case because no natA variables are

allowed.

plus : \Gamma  (nat oe nat oe nat)plus (zero * _) m = m
plus (succ * n) m = succ * (plus n m)plus (

. ()) _

size : (8) exp oe 2 nat)size

\Psi  (. x) = succ * (zero * _)size
\Psi  (app * (e1 , e2)) = succ * (plus (size \Psi  e1)(size

\Psi  e2))size
\Psi  (lam * e) = succ * (size (\Psi  " expC) e)

Agda successfully termination-checks these functions.
3 Beluga provides a built-in type of substitutions, written [\Psi ']\Psi , so one
might hope to represent closures as 9.([, x : exp]exp) * [.]; how-ever, the second component of this pair associates an expression with each

expression variable in , whereas, in this example, we need to associate aclosure with each expression variable in

.

The type of size expresses that it returns a closed natural num-ber. For comparison, we implement a second version that does not
make this invariant explicit:

size' : \Gamma  (8<= expC (exp oe nat))size'

\Psi  bound (. x) = succ * (zero * _)size'
\Psi  bound (app * (e1 , e2)) =succ * (plus'

\Psi  bound (size' \Psi  bound e1)(size'

\Psi  bound e2)) whereplus' : \Gamma  (8<= expC (nat oe nat oe nat))

plus' \Psi  b = weaken*/bounded (nat oe nat oe nat) \Psi  b []plus
size' \Psi  bound (lam * e) =strengthen nat _ (size' (

\Psi  " expC) bound e)

Without the 2, size must return a number in context \Psi : in the ap-plication case, we must weaken plus into

\Psi , and in the lam casewe must strengthen the extra expC variable out of the recursive call.

Strengthening expression variables from natural numbers is permit-ted by our implementation of the structural properties because natural numbers cannot mention expressions; we use a subordination-like analysis to determine this (Virga, 1999). To ensure that these
weakenings and strengthenings are permitted, we type size' witha bounded quantifier over exp.

Comparison. The first version is similar to what one writes inFreshML, except in that setting there is no need to pass around a
context \Psi . In the second version, the strengthening of the recur-sive result in the lam case is analogous to the need, in FreshML
2000 (Pitts and Gabbay, 2000), to observe that nat is pure (alwayshas empty support); FreshML (Shinwell et al., 2003) does not require this.In Beluga, one can express either the first or second versions. In Twelf and Delphin, one can only express the secondvariation, as these languages do not provide 2. However, the
Twelf/Delphin/Beluga syntax for weakening and strengthening isterser than what we have been able to construct in Agda: weakening is handled by world subsumption and is not marked in the proofterm; strengthening is marked by pattern-matching the result of the
recursive call and marking those variables that do occur, which inthis case does not include the expression variable. For example, the
lam case of size in Twelf looks like this:
- : size (lam ([x] E x)) (succ N)<- ({x : exp} size (E x) N).

Twelf's coverage checker verifies that expression variables canbe strengthened out of natural numbers when checking this case.
We would like to explore a similarly terse syntax for weaken-ing/strengthening in future work.

3.3.2 Counting occurrences of a variable
A simple variation is to count the number of occurrences of a dis-tinguished free variable. The input to this function has type (expC

) exp), and we count the occurrences of the bound variable:

cnt : 8) (expC ) exp) oe 2 natcnt

\Psi  (. i0) = succ * (zero * _)cnt
\Psi  (. (iS _)) = zero * _cnt
\Psi  (app * (e1 , e2)) = plus (cnt \Psi  e1) (cnt \Psi  e2)cnt
\Psi  (lam * e) = cnt (\Psi  " expC) (exchange2 exp \Psi  e)

In the first two cases, we pattern-match on the variable: when itis the last variable, the last variable occurs once; when it is not, it

occurs zero times. The lam case recurs on the exchange of e, sothat the last variable remains the one we are looking for. Agda fails
to termination-check this example because it recurs on the resultof exchange. Because this use of exchange is a common recursion
pattern for (exp -> exp) in Twelf, we plan to consider a derivedinduction principle that covers this case in future work.

Comparison. Pattern-matching on variables is represented us-ing higher-order metavariables in Twelf/Delphin/Beluga and using
equality tests on names in FreshML. The exchange needed in thelam case is written as a substitution in the Twelf/Delphin/Beluga
version of this clause. In Twelf one would write:

- : cnt ([x] lam ([y] E x y)) N<- ({y:exp} cnt ([x] E x y) N).

In the input to this clause, the metavariable E, which stands for thebody of the function, refers to the last variable in the context (the
lam-bound variable) as y and the second-last variable (the variablebeing counted) as x. In the recursive call, y is exchanged past the
binding of x, so the instantiation E x y swaps "last" and "second-last".

3.3.3 Computing free variables
Next, we consider a function computing the free variables of anexpression, of type (8

) exp oe list (expC #))--in any con-text, this function accepts an expression in that context and produces a list of variables in that context. This typing ensures that wedo not accidentally return a bound variable.

remove : {D : VarType}-> (8) (D ) list (D #)) oe list (D #))
remove \Psi  [] = []remove

\Psi  (i0 :: ns) = (remove \Psi  ns)remove
\Psi  ((iS i) :: ns) = i :: (remove \Psi  ns)

fvs : (8) exp oe list (expC #))fvs

\Psi  (. x) = [ x ]fvs
\Psi  (lam * e) = remove \Psi  (fvs (\Psi  " expC) e)fvs
\Psi  (app * (e1 , e2)) = (fvs \Psi  e1) ++ (fvs \Psi  e2)

In the lam case, we use the helper function remove to remove thelam-bound variable from the recursive result. The function remove
takes a list of variables, itself with a distinguished free variable,and produces a list of variables without the distinguished variable.
If the programmer were to make a mistake in the second clause byaccidentally including i0 in the result, he would get a type error.
Agda successfully termination-checks this example.Comparison. For comparison with FreshML (Shinwell et al.,
2003), the type given to remove here is analogous to their Figure 6:
remove : (<name> (name list)) -> name list
where <a>o/ is a nominal abstractor. The authors comment that theyprefer the version of remove in their Figure 5:

remove : name -> (name list) -> name list
where the name to removed is specified by the first argument, ratherthan using a binder.

Using dependent types, we can type this second version ofremove as follows:

remove : (\Psi  : Vars) (i : exp 2 \Psi )-> List (exp 2

\Psi ) -> List (exp 2 (\Psi  - i))

where \Psi  - i removes the indicated element element from the list.This type is of course expressible in Agda, but we have not yet

integrated dependent types into our universe.
3.3.4 j-Contraction
In Twelf/Delphin/Beluga, one can recognize j-redices by writinga meta-variable that is not applied to all enclosing locally bound

variables. E.g. in Twelf one would write
- : contract (lam [x] app F x) F.

The metavariable F:exp is bound outside the scope of x, and thusstands only for terms that do not mention x. (To allow it to mention
x, we would bind F:exp -> exp and write (F x) in place of F.)Unfortunately, Agda does not provide this sort of pattern matching for our encoding--pattern variables are always in the scope ofall enclosing local binders--so we must explicitly call a strengthening function that checks whether the variable occurs:

strengthen? : 8) (expC ) exp) oe exp optionstrengthen?

\Psi  (. i0) = Inr _strengthen?
\Psi  (. (iS i)) = Inl (. i)strengthen?
\Psi  (app * (e1 , e2))with strengthen?

\Psi  e1 | strengthen? \Psi  e2... | Inl e1' | Inl e2' = Inl (app * (e1' , e2'))

... | _ | _ = Inr _strengthen?

\Psi  (lam * e)with strengthen? (

\Psi  " expC) (exchange2 exp \Psi  e)... | Inl e' = Inl (lam * e')

... | _ = Inr _
contract-j : 8) exp oe exp optioncontractj \Psi  (lam * (app * (f , . i0))) = strengthen? \Psi  fcontractj \Psi  _ = Inr <>

We conjecture that strengthen? could be implemented datatype-generically for all purely positive types (no oe or 8c or 8<=)--it

is not possible to decide whether a variable occurs in the valuesof these computational types (cf. FreshML, where it is not possible to decide whether a name is in the support of a function).This strengthening function is not an instance of the generic map
that we define below, as it changes the type of the term (exp toexp option); in future work, we plan to consider a more general
traversal that admits this operation.
3.4 Normalization by Evaluation

In Figure 3, we present a serious example mixing binding andcomputation,

fi-normalization-by-evaluation for the untyped *-calculus. NBE works by giving the syntax a semantics in terms

of computational functions (evaluation) and then reading backa normal form (reification). The NBE algorithm is similar to a
Kripke logical relations argument, where one defines a type- andcontext-indexed family of relations

[[A]] in \Psi . The key clause of thisdefinition is:

([[A arrow B]] in \Psi ) = 8\Psi 0. ([[A]] in \Psi ,\Psi 0) oe ([[B]] in \Psi ,\Psi 0)
That is, the meaning of A arrow B in \Psi  is a function that, for anyfuture extension of the context, maps the meaning of

A in thatextension to the meaning of
B in that extension. In our type theory,we represent (a simply-typed version of) this logical relation as a

datatype sem. The datatype constructor corresponding to the aboveclause would have the following type:

sem ( (8) sem oe sem)
However, for the argument to go through, we must ensure that thecontext extension

\Psi ' consists only of variables of a specific typeneu, so we use a bounded context quantifier below.

We represent the semantics by the datatypes neu and sem inFigure 3. The type neu (neutral terms) consists of variables or
neutral terms applied to semantic arguments (napp); these are thestandard neutral proofs in natural deduction. A sem (semantic term)
is either a neutral term or a semantic function. A semantic functionof type (8<= neuC (sem oe sem)) is a computational function
that works in any extension of the context consisting entirely ofneu variables.

We define reification first, via two mutually recursive functions,reifyn (for neutral terms) and reify (for semantic terms). It
is typical in logical relations arguments to use two independentcontexts, one for the syntax and one for the semantics. Thus, we

napp : In\Sigma  (neuA ( neu \Omega  sem)neut : In

\Sigma  (semA ( neu)slam : In
\Sigma  (semA ( (8<= neuC (sem oe sem)))

reifyn : 8) 8c \ \Psi s -> (var2var neuC \Psi s expC)oe [

\Psi s ]* neu oe expreifyn
\Psi e \Psi s oe (. x) = . (oe x)reifyn
\Psi e \Psi s oe (napp * (n , s)) =app * (reifyn

\Psi e \Psi s oe n , reify \Psi e \Psi s oe s)

reify : 8) 8c \ \Psi s -> (var2var neuC \Psi s expC)oe [

\Psi s ]* sem oe expreify
\Psi e \Psi s oe (slam * ') =lam * reify (

\Psi e " expC) (\Psi s " neuC)(extendv2v

\Psi s \Psi e oe)(
' [ neuC ] _ (neut * (. i0)))reify
\Psi e \Psi s oe (neut * n) = reifyn \Psi e \Psi s oe nreify
\Psi e \Psi s oe (. x) = impossible x

appsem : 8) sem oe sem oe semappsem _ (slam *

') s2 = ' [] _ s2appsem _ (neut * n) s2 = neut * (napp * (n , s2))

appsem _ (. x) _ = impossible x
evalenv : Vars -> Typeevalenv

\Psi s = (expC #) oe ([ \Psi s ]* sem)

eval : 8) 8c \\Psi s -> evalenv \Psi soe exp oe ([

\Psi s ]* sem)eval
\Psi e \Psi s oe (. x) = oe xeval
\Psi e \Psi s oe (app * (e1 , e2)) =appsem

\Psi s (eval \Psi e \Psi s oe e1) (eval \Psi e \Psi s oe e2)eval
\Psi e \Psi s oe (lam * e) = slam * ' where
' : < \Psi s > (8<= neuC (sem oe sem))
' \Psi ' ctxinv s' = eval (\Psi e " expC) (\Psi s + \Psi ') oe' e where

oe' : < \Psi e > (expC ) (evalenv (\Psi s + \Psi ')))
oe' i0 = s'
oe' (iS i) = weaken*/bounded sem \Psi ' ctxinv \Psi s (oe i)

Figure 3. Normalization by evaluation

parametrize these functions by two contexts, one consisting forneu variables for the semantics, and the other consisting of exp
variables for the syntax. We will write \Psi s for the former and \Psi efor the latter.

In the type of reify, we must name one of these contexts, be-cause each context scopes over two disconnected parts of the type.
We choose to name the semantic context and let the expression con-text be the ambient one. The outer 8

) thus binds the expressioncontext, whereas we use the full binding form 8c for the semantic context. The type of reify then says that, under some con-dition expressed by the type var2var, reify maps semantics in
the semantic context (recall that [ \Psi  ]* A stands for 2 (\Psi  )*A); lexically, [

\Psi  ]* A binds more tightly than oe) to expressions(in the ambient expression context). The type var2var C1

\Psi 1 C2means that every variable of type C1 in
\Psi 1 maps to a variable oftype C2 in the ambient context. It is defined in a library as follows:

var2var : VarType -> Vars -> VarType -> Typevar2var C1

\Psi 1 C2 = ([ \Psi 1 ]* (C1 #)) oe (C2 #)

Even though reify is given a precise type describing the scop-ing of variables, its code is as simple as one could want. To reify

neutral terms: The reification of a variable is the variable given inthe substitution. The reification of an application is the application of the reifications. To reify semantic terms: The reification of afunction (slam *

') is the *-abstraction of the reification of an in-stance of
'. In the recursive call, the expression context is extendedwith a new exp variable (which is bound by the lam) and the semantic context is extended with a new neu variable. We instantiatethe semantic function

', which anticipates extensions of the con-text, with this one-variable extension ([ x ] constructs a singleton

list), and apply it to the variable. The library function extendv2vmakes the "parallel" extension of a var2var in the obvious way,
mapping the one new variable to the other:

extendv2v : {D1 D2 : VarType} -> (\Psi s : Vars)-> 8) (var2var D1

\Psi s D2)oe D2 ) (var2var D1 (D1 ::

\Psi s) D2)extendv2v
\Psi s \Psi e oe (i0) = i0extendv2v
\Psi s \Psi e oe (iS i) = iS (oe i)

The neutral-to-semantic coercion is reified recursively, and we dis-allow sem variables from the context.

To define evaluation, we first define an auxiliary functionappsem that applies one semantic term to another. This requires
a case-analysis of the function term: when it is an slam (i.e. theapplication is a

fi-redex), we apply the embedded computationalfunction, choosing the nil context extension, and letting the argument be s2. When the function term is neutral, we make a longerneutral term.

The type of eval is symmetric to reify, except the environ-ment that we carry along in the induction maps expression variables
to semantic terms rather than just variables. The type evalenv
\Psi s means that every expression variable in the ambient context ismapped to a semantic value in

\Psi s. A variable is evaluated by look-ing it up; an application is evaluated by combining the recursive

results with semantic application. A lam is evaluated to an slamwhose body

' has the type indicated in the figure. When given acontext extension

\Psi ' and an argument s' in that extension, ' eval-uates the original body e in an extended substitution. The new substitution oe' maps the *-bound variable i0 to the provided seman-tic value, and defers to

oe on all other variables. However, oe pro-vides values in
\Psi s, which must be weakened into the extension \Psi '.Fortunately, the bounded quantifier provides sufficient evidence to

show that weakening can be performed in this case, because sem'scan be weakened with neu variables.

Normalization is defined by composing evaluation and reifica-tion. We define a normalizer for closed

*-terms as follows:

emptyv2v : \Gamma  (var2var neuC [] expC)emptyevalenv : \Gamma  (evalenv [])

norm : \Gamma  (exp oe exp)norm e = reify [] [] emptyv2v (eval [] [] emptyevalenv e)
Our type system has verified the scope-correctness of this code,proving that it maps closed terms to closed terms. Amusingly,
Agda accepts the termination of this evaluator for the untyped *-calculus, provided that we have told it to ignore its issues with our
universe itself--a nice illustration of the need for the positivitycheck on datatypes. Our companion code includes an alternate
version of NBE, which has simpler types (it does not maintainseparate contexts

\Psi e for expressions and \Psi s for semantics) at theexpense of more-complicated code (various appeals to weakening

and strengthening are necessary).
Comparison. The type sem is a truly mixed datatype: the premise(8<= neuC (sem oe sem)) uses both ) and oe (recall that there

is a ) buried in the definition of 8<=). Because it uses oe in a re-cursive datatype, it is not representable in LF. Because it uses ), it
would not even be representable in Delphin/Beluga extended withstandard recursive types (that did not interact with the LF part of the
language). Despite the fact that our implementation enforces stronginvariants about the scope of variables, the code is essentially as
simple as the FreshML version described by Shinwell et al. (2003),aside from the need to pass the contexts

\Psi e and \Psi s along. Invari-ants about variable scoping can be proved in Pure FreshML (Pottier, 2007), but we would like to enforce these invariants within atype system, not using an external specification logic. Relative to a
direct implementation in Agda, our framework provides the weak-ening function needed in the final case of eval for free.

4. Structural Properties
The structural properties are implemented by instantiating a generictraversal for <

\Psi  > A. The generic traversal has the followingtype:

map : (A : Type) {\Psi  \Psi ' : Vars}-> (Co A

\Psi  \Psi ') -> < \Psi  > A -> < \Psi ' > A

This should be read as follows: for every A \Psi  \Psi ', under thecondition Co A

\Psi  \Psi ', there is a map from terms of type A in \Psi to terms of type A in

\Psi '.Co : Type -> Vars -> Vars -> Set is a variable relation, a type-indexed family of relations between two contexts. Cois in fact a (module-level) parameter to the generic map; it must
provide (1) a variable or term in \Psi ' for each variable in \Psi  that thetraversal runs into; and (2) enough information to keep the traversal
going inductively. We will instantiate Co with a specific relation foreach traversal; e.g., for weakening with a variable of type D, Co will
relate \Psi  to (\Psi  " D) under appropriate conditions on D and A.For expository purposes, we present a slightly simplified version of the traversal first; the generalization is described with weak-ening below.

4.1 Compatibility
We ensure that Co provides the two pieces of information men-tioned above using the notion of compatibility. Suppose that Co and

Contra are variable relations. We say that Co and Contra are com-patible iff there is a term

compat : ({A : Type} {\Psi  \Psi ' : Vars}-> Co A

\Psi  \Psi ' -> Compat A \Psi  \Psi ')

where Compat is defined as follows:

Compat : Type -> Vars -> Vars -> SetCompat (D #)

\Psi  \Psi ' = (D 2 \Psi ) -> (D 2 \Psi ')Compat (D+ D)

\Psi  \Psi ' =({A : Type} -> (c : In

\Sigma  (D ( A)) -> Co A \Psi  \Psi ')* ({ch : _} -> (
. D {ch}) 2 \Psi  -> < \Psi ' > D+ D)Compat (A oe B)
\Psi  \Psi ' = Contra A \Psi ' \Psi  * Co B \Psi  \Psi 'Compat (
\Psi 0 )* A) \Psi  \Psi ' = Co A (\Psi  + \Psi 0) (\Psi ' + \Psi 0)Compat (list A)

\Psi  \Psi ' = Co A \Psi  \Psi 'Compat (2 A)
\Psi  \Psi ' = Unit-- ...

Compat imposes certain conditions on Co and Contra. For exam-ple, for variable types D #, it says that Co (D #)

\Psi  \Psi ' inducesa map from variables of type D in
\Psi  to variables in \Psi '. For definedatoms D+ D, Compat says that Co (D+ D)

\Psi  \Psi ' induces a mapfrom variables in
\Psi  to terms in \Psi ', and that Co A \Psi  \Psi ' holds forevery premise A of every constant inhabiting D. In all other cases,

Compat provides enough information to keep the induction goingin map below. This amounts to insisting that Co (or Contra) holds
on the subexpressions of a type in all appropriate contexts. For ex-ample, the condition for

\Psi 0 )* A is that Co holds for A in thecontexts extended with
\Psi 0.In the usual monadic traversals of syntax (Altenkirch and Reus,

1999), Co _ \Psi  \Psi ' is taken to be (D : VarType) -> D 2 \Psi -> <

\Psi ' > D--i.e. a realization of every variable in \Psi  as a termin
\Psi '. In our setting, this does not suffice to define a traversal, be-cause (1) it does not provide for the contravariant flip necessary to

process the domains of computational functions and (2) it does notallow us to express a conditional traversal, where conditions on the

map : (A : Type) {\Psi  \Psi ' : Vars}-> (Co A

\Psi  \Psi ') -> < \Psi  > A -> < \Psi ' > Amap (D+ Dat) co (

. x) = (snd (compat co) x)map (Dat #) co x = ((compat co) x)

map (A oe B) co e =\ y -> (map B (snd (compat co))

(e (map' A (fst (compat co)) y)))map (
\Psi 0 )* A) co e = map A (compat co) emap (list A) co [] = []

map (list A) co (x :: xs) =map A (compat co) x :: map (list A) co xs
map (D+ Dat) co (_*_ {A} c e) =c * map A (fst (compat co) c) e
map (2 A) co e = e-- ... more cases

Figure 4. Map (excerpt)
types ensure that the traversal will only find certain variables, andthus that only those variables need realizations. Compatibility ensures that Co provides enough information for Contra to processthe contravariant positions to the left of a computational arrow. Additionally, it permits conditional traversals: below, we will instanti-ate Co so that it is uninhabited for certain A.

4.2 Map
Suppose that Co and Contra are compatible, and assume a function

map' : (A : Type) {\Psi  \Psi ' : Vars}-> (Contra A

\Psi  \Psi ') -> < \Psi  > A -> < \Psi ' > A

that is the equivalent of map for the Contravariant positions.Then we implement map in Figure 4. In the first and second

cases, the compatibility of Co induces the map on variables that weneed. In the third case, we pre-compose the function with map' and
post-compose with map. In all other cases, map simply commuteswith constructors, or stops early if it hits a boxed term.

4.3 Exchange/Contraction
Exchange and contraction are implemented by one instantiation ofmap. In this case, we take

Co A \Psi  \Psi ' = Contra A \Psi  \Psi ' = (\Psi  ` \Psi ' * \Psi ' ` \Psi )
where ` means every variable in one context is in the other. It issimple to show that these relations are compatible, because Co (a)

provides the required action on variables directly and (b) ignores itstype argument, so the compatibility cases for the type constructors
are easy. Exchange is defined by instantiating the generic map withCo, where map' is taken be map itself, which works because Co =
Contra.
4.4 Strengthening
Next, we define a traversal that strengthens away variables that,based on type information, cannot possibly occur. The invariant for

strengthening is the following:4
Co : Type -> Vars -> Vars -> SetCo A

\Psi  \Psi ' = \Sigma  \(D : VarType) ->

\Sigma  \(i : D 2 \Psi ) ->Check(irrel (un

. D) A) * Id \Psi ' (\Psi  - i)

Here i, a pointer into the initial context \Psi  is the variable to bestrengthened away; the propositional equality constraint represented by the Identity says that the final context \Psi ' is the ini-tial context with i removed. The type Check(irrel (un

. D) A)

4 For concision, we suppress some details arising from the implementation
of irrel, which takes a visited list as an extra argument; see the companioncode for details.

computes to Unit when strengthening is possible, and Void whenit is not. Here un

. simply peels off the injection of a defined atominto a VarType.

The crucial property of irrel is that Check(irrel (un. D)(D+ D)) computes to Void. This forbids strengthening a variable
of type D out of a term of type D. This is necessary because wecannot satisfy the usual compatibility condition for (D+ D), which
would require mapping all variables--including the variable-to-be-strengthened i--to a term of type D that does not mention i.

More generally, Check(irrel (un. D) A) means that vari-ables of type D can never be used to construct terms of type A, which
ensures that strengthening never runs into variables of the type be-ing strengthened. The function irrel D A is defined by traversing
the graph structure of types (i.e., it unrolls the definitions of definedatoms) and checks not (DefinedAtoms.eq D Dat) for each defined atom Dat it finds.To account for contravariance, we must define strengthening
simultaneously with weakening by irrelevant assumptions, whichis similar. About 250 lines of Agda code shows that these two
relations together are compatible. Their traversals are then definedby instantiating map twice, mutually recursively--each is passed to
the other as map' for the contravariant recursive calls.
4.5 Weakening
In addition to weakening by irrelevant types (e.g. weakening a natwith an exp), we can weaken by types that do not appear to the left

of a computational arrow (e.g., weakening an exp with an exp).For a simple version of weakening, the variable relation is
similar to strengthening, but uses a different computed condition,and flips the role of

\Psi  and \Psi ' (now \Psi ' is bigger):

Co : Type -> Vars -> Vars -> SetCo A

\Psi  \Psi ' = \Sigma  \(D : VarType) ->

\Sigma  \(i : D 2 \Psi ') ->Check(canWeaken (un

. D) A) * Id \Psi  (\Psi ' - i)

The function canWeaken is a different graph traversal than before:this time, we check irrel (un

. D) A for the left-hand side ofeach computational arrow A oe B. Weakening can then be defined

using strengthening in contravariant positions, as irrel is exactlythe condition that strengthening requires.

This suffices for a simple version of weakening. However, wecan be more clever, and observe that types of the form 8) A are always weakenable, because their proofs are explicitly parametrizedover arbitrary extensions of the context. Similarly, 8<= C A is
weakenable with any context composed entirely of C's. Capitalizingon this observation requires a slight generalization of the traversal
described above: computationally, weakening 8) A does not re-cursively traverse the proof of A, like map usually does, but stops
the traversal and instantiates the context quantifier appropriately.Thus, our actual implementation of map is parametrized so that, for
each type A, either it is given sufficient information to transformA directly (a function <

\Psi  > A -> < \Psi ' > A), or it has enoughinformation to continue recursively, as in the compatibility conditions described above. We use the former only for weakening thequantifiers (map <

\Psi  - i > (8) A) to < \Psi  > (8) A)). Werefer the reader to our Agda code for details. All told, weakening

takes about 210 lines of Agda code to define and prove compatible.
4.6 Substitution
Substitution is similar to weakening and strengthening. Its invari-ant has the same form, using a condition canSubst (un

. D) A.This condition ensures two things: (1) that D is irrelevant to the lefthand-sides of any computational arrow, so that substitution can bedefined using weakening-with-irrelevant-assumptions in the contravariant position, and (2) that D is weakenable with all variable

types bound by A, so that the term being plugged in for the variablecan be weakened as substitution goes under binders. Substitution
takes about 220 lines to define and prove compatible.

5. Related Work
We have provided comparisons with several other systems through-out the paper: Relative to LF-based systems such as Twelf (Pfenning and Schu"rmann, 1999), Delphin (Poswolsky and Schu"r-mann, 2008), and Beluga (Pientka, 2008), our framework permits definitions that mix binding and computation; this is essen-tial for defining the datatype sem in the NBE example. Relative
to FreshML (Pottier, 2007; Shinwell et al., 2003), our frameworkenforces invariants about variable scoping in the type system. Such
invariants can be proved in Pure FreshML (Pottier, 2007), but wewould like to enforce these invariants within a type system, not
using an external specification logic.Aydemir et al. (2008) provide a nice overview of various techniques that are used to implement variable binding, includingnamed, de Bruijn, {locally / globally} {named /nameless}, and
weak higher-order abstract syntax (Bucalo et al., 2006; Despey-roux et al., 1995). More recently, Chlipala (2008) has advocated
the use of parametric higher-order abstract syntax. We have chosenwell-scoped de Bruijn indices (Altenkirch and Reus, 1999; Bellegarde and Hook, 1994; Bird and Paterson, 1999) for our Agdaimplementation, a simple representation that makes the pronoun
structure of variables explicit. It would be interesting to investigatewhether any benefits can be obtained by implementing our universe with a different representation. Relative to these techniquesfor representing binding, the advantage of our framework is that it
provides datatype-generic implementations of the structural proper-ties, including substitution. Both the Hybrid frameworks (Ambler
et al., 2002; Capretta and Felty, 2007; Momigliano et al., 2007),Hickey et al. (2006)'s work, and Lambda Tamer (Chlipala, 2007)
describe languages or tools for specifying data with binding, pro-viding generic implementations of the structural properties. However, to the best of our knowledge, these logical frameworks do notmake the computational functions of the meta-language available
for use in the framework (except inasmuch as they are, in somecases, used to represent binding itself). In contrast, our universe
includes both ) and oe.In this work, we have created a universe of contextual types in
Agda. Contextual types appear in Miller and Tiu's work (Miller andTiu, 2003), as well as in contextual modal type theory (Nanevski
et al., 2007). Miller and Tiu's self-dual r connective is closely re-lated to ), also capturing the notion of a scoped constant. However, the r proof theory adopts a logic-programming-based dis-tinction between propositions and types, and r binds a scoped term
constant in a proposition. In our setting, ) allows the meaning ofcertain propositions (defined atoms) to vary.

Fiore et al. (1999) and Hofmann (1999) give semantic accountsof variable binding. In a sense, the present paper gives a semantics
for our type theory, where binding is represented by an indexed in-ductive definition. However, this semantics does not shed any new
light on the datatype-generic definition of the structural properties;it would be interesting to explore a semantic characterization of the
conditions under which weakening and substitution are definable.

6. Conclusion
In this paper, we have constructed a logical framework supportingdatatypes that mix binding and computation: Our framework is implemented as a universe in the dependently typed programming lan-guage Agda. Binding is represented in a pronominal manner, so the
type system can be used to reason about the scoping of variables.Our implementation provides datatype-generic implementations of

the structural properties (weakening, subordination-based strength-ening, exchange, contraction, and substitution). We have used the
framework to program a number of examples, including a scope-correct version of the normalization-by-evaluation challenge problem discussed by Shinwell et al. (2003). We believe that these ex-amples demonstrate the viability of our approach for simply-typed
programming.We hope also to have clarified the gap between LF-based systems for programming with binding, such as Twelf, Delphin, andBeluga, and a generic dependently typed programming language
like Agda. For simply-typed programming, the benefits of the LF-based systems that we were unable to mimic include: (1) the ability
to write pronominal variables with a named syntax; and (2) a conve-nient syntax for applying the structural properties. For example, the
syntax of weakening and strengthening is relatively heavy in oursetting. In Twelf, weakening is silent, and strengthening (including strengthen? used in the j-contraction example) is marked bysaying which variables do occur, using a non-linear higher-order
pattern. In our Agda implementation, weakening must be markedexplicitly, and strengthening requires one to enumerate those variables that do not occur instead. However, the more convenient syn-tax seems within reach for a standalone implementation of our
framework; e.g., weakening could be implemented using a formof coercive subtyping.

Of course, one way in which all of the LF-based systems out-pace ours is that they support dependent types, which are crucial
for representing logics and for mechanizing metatheory. Our mostpressing areas of future work are to investigate a dependently typed
extension of our universe, and to address the termination issues thatwe have deferred here. One key issue for the dependently typed
version will be the equational behavior of the structural properties,which we have not yet investigated. We would hope that they have
the right behavior up to propositional equality (otherwise there is abug in the code presented here), but it remains to be seen whether
we can get Agda's definitional equality to mimic the equationsproved automatically by, e.g., Twelf. That said, the fact that the map
function defined in Section 4 commutes with all term constructorsdefinitionally in Agda gives us some hope in this regard.

A. Agda Overview
In this section, we review Agda's syntax, we show a simple ex-ample of well-scoped de Bruijn indices, and we give a simple

example of a universe. We refer the reader to the Agda Wiki(http://wiki.portal.chalmers.se/agda/) for more introductory materials.
A.1 Well-scoped de Bruijn indices in Agda
We review the representation of well-scoped de Bruijn indicesas an indexed inductive definition (Altenkirch and Reus, 1999;

Bellegarde and Hook, 1994; Bird and Paterson, 1999). Agda datatypes are introduced as follows:

data List (A : Set) : Set where[] : List A

_::_ : A -> List A -> List A
Set classifies Agda classifiers, like the kind type in ML or Haskell.Mixfix constructors are declared by using _ in an identifier; e.g., ::

can now be used infix as in Zero :: (Zero :: []).Functions are defined by pattern-matching:

append : {A : Set} -> List A -> List A -> List Aappend [] ys = ys
append (x :: xs) ys = x :: (append xs ys)

The curly-braces mark an implicit dependent function space.Applications to implicit arguments are not marked in the program;

e.g., we do not explicitly apply append to the Set argument A.Agda attempts to infer implicit function arguments and reports an
error if they cannot be reconstructed.Indexed datatypes are defined using a notation similar to
GADTs in GHC. For example, we define a datatype 2 representingindices into a list:

data _2_ {A : Set} : A -> List A -> Set wherei0 : {x : A} {xs : List A} -> x 2 (x :: xs)

iS : {x y : A} {xs : List A} -> y 2 xs -> y 2 (x :: xs)
For any Set A, and terms x and xs of type A and List A, thereis a type x 2 xs. The first constructor, i0, creates a proof of x

2 (x :: xs)--i.e. x is the first element of the list. The secondconstructor iS, creates a proof of x 2 (y :: xs) from a proof
that x is in the tail.As a simple example of dependent pattern matching, we define
an n-ary version of iS:
skip : {A : Set} (xs : List A) {ys : List A} {y : A}-> y 2 ys -> y 2 (append xs ys)

skip [] i = iskip (x :: xs) i = iS (skip xs i)

We use an implicit-quantifier for all arguments but the list xs;explicit-quantifiers are written with parentheses instead of curlybraces. The fact that this code type-checks depends on the compu-tational behavior of append; e.g., in the first case, the expression
append [] ys reduces to ys, so we can return the index i un-changed.

Well-scoped syntax for the untyped *-calculus is defined asfollows:

data Term (\Gamma  : List Unit) : Set where

. : <> 2 \Gamma  -> Term \Gamma Lam : Term (<> ::

\Gamma ) -> Term \Gamma App : Term
\Gamma  -> Term \Gamma  -> Term \Gamma 

The type Unit is defined to be the record type with no fields, withinhabitant written <>. We represent variables as indices into a list

\Gamma  containing elements of the one-element type Unit. (Such listsare isomorphic to natural numbers, but this illustrates the pattern
for variables of more than one type.) The constructor . makes aterm from an index into

\Gamma , which represents a variable. The bodyof Lam can refer to all of the variables in

\Gamma , as well as a newbound variable represented by extending
\Gamma  to (<> :: \Gamma ). The Kcombinator
*x.*y.x is represented as follows: Lam (Lam (. (iSi0))). The values of Term

\Gamma  correspond exactly to the *-termswith free variables in
\Gamma .

A.2 Universes
A universe is specified by a inductive datatype of codes for types,along with a function mapping each code to a Set. For example,

a simple universe with an empty type, a unit type, and binaryproducts is specified as follows:

data Type : Set where0+ : Type

1+ : Type_\Omega _ : Type -> Type -> Type

Element : Type -> SetElement 0+ = Void
Element 1+ = UnitElement (

o/1 \Omega  o/2) = (Element o/1) * (Element o/2)

In the right-hand side of Element, we write A * B for the Agdapair type, etc.

Datatype-generic programs are implemented by recursion overthe codes; e.g, every element of the universe can be converted to a
string:

show : (o/ : Type) -> Element o/ -> Stringshow 0+ ()
show 1+ <> = "<>"show (

o/1 \Omega  o/2) (e1 , e2) ="< " ^ (show

o/1 e1) ^ " , " ^ (show o/2 e2) ^ " >"

In the first clause, the empty parentheses are a refutation pat-tern, telling Agda to check that the type in question (in this case

Element 0+) is uninhabited, and allowing the programmer to elidethe right-hand side.

As another example, we will often view booleans as a two-element universe, with only True inhabited:

data Bool : Set whereTrue : Bool

False : Bool
Check : Bool -> SetCheck True = Unit
Check False = Void
Because Agda implements extensionality for Unit (there is onlyone record with no fields), terms of type Check True can be left

implicit and inferred.
Acknowledgements
We thank Noam Zeilberger for discussions about this work, and wethank the anonymous reviewers for their helpful feedback on an

earlier version of this article.

References
M. Abbott, T. Altenkirch, and N. Ghani. Containers: constructing strictlypositive types. Theoretic Computer Science, 342(1):3-27, 2005.

T. Altenkirch and C. McBride. Generic programming within dependentlytyped programming. In IFIP TC2 Working Conference on Generic

Programming, Schloss Dagstuhl, 2003.
T. Altenkirch and B. Reus. Monadic presentations of lambda terms usinggeneralized inductive types. In CSL 1999: Computer Science Logic.

LNCS, Springer-Verlag, 1999.
S. Ambler, R. L. Crole, and A. Momigliano. Combining higher orderabstract syntax with tactical theorem proving and (co)induction. In

International Conference on Theorem Proving in Higher-Order Logics,pages 13-30, London, UK, 2002. Springer-Verlag.

B. Aydemir, A. Chargue'raud, B. C. Pierce, R. Pollack, and S. Weirich.Engineering formal metatheory. In ACM SIGPLAN-SIGACT Symposium

on Principles of Programming Languages, pages 3-15, 2008.
F. Bellegarde and J. Hook. Substitution: A formal methods case study usingmonads and transformations. Science of Computer Programming, 23(2-

3):287-311, 1994.
U. Berger and H. Schwichtenberg. An inverse of the evaluation functionalfor typed

*-calculus. In IEEE Symposium on Logic in Computer Science,1991.

R. S. Bird and R. Paterson. De Bruijn notation as a nested datatype. Journalof Functional Programming, 9(1):77-91, 1999.
A. Bucalo, M. Hofmann, F. Honsell, M. Miculan, and I. Scagnetto. Consis-tency of the theory of contexts. Journal of Functional Programming, 16

(3):327-395, May 2006.
V. Capretta and A. Felty. Combining de Bruijn indices and higher-orderabstract syntax in Coq. In Proceedings of TYPES 2006, volume 4502

of Lecture Notes in Computer Science, pages 63-77. Springer-Verlag,2007.

A. Chlipala. A certified type-preserving compiler from *-calculus to assem-bly language. In ACM SIGPLAN Conference on Programming Language

Design and Implementation, 2007.
A. Chlipala. Parametric higher-order abstract syntax for mechanized se-mantics. In ACM SIGPLAN International Conference on Functional

Programming. ACM, 2008.
K. Crary. Explicit contexts in LF. In International Workshop on LogicalFrameworks and Meta-Languages: Theory and Practice, 2008.

J. Despeyroux, A. Felty, and A. Hirschowitz. Higher-order abstract syntaxin Coq. In M. Dezani-Ciancaglini and G. Plotkin, editors, International

Conference on Typed Lambda Calculi and Applications, volume 902 ofLecture Notes in Computer Science, pages 124-138, Edinburgh, Scotland, 1995. Springer-Verlag.
M. Fiore, G. Plotkin, and D. Turi. Abstract syntax and variable binding. InIEEE Symposium on Logic in Computer Science, 1999.

J. Hickey, A. Nogin, X. Yu, and A. Kopylov. Mechanized meta-reasoningusing a hybrid HOAS/de Bruijn representation and reflection. In ACM

SIGPLAN International Conference on Functional Programming, pages172-183, New York, NY, USA, 2006. ACM.

M. Hofmann. Semantical analysis of higher-order abstract syntax. In IEEESymposium on Logic in Computer Science, 1999.
D. R. Licata, N. Zeilberger, and R. Harper. Focusing on binding andcomputation. In IEEE Symposium on Logic in Computer Science, 2008.
P. Martin-Lo"f. An intuitionistic theory of types: Predicative part. In H. Roseand J. Shepherdson, editors, Logic Colloquium. Elsevier, 1975.
C. McBride and J. McKinna. The view from the left. Journal of FunctionalProgramming, 15(1), 2004.
D. Miller and A. F. Tiu. A proof theory for generic judgments: An extendedabstract. In IEEE Symposium on Logic in Computer Science, pages 118-

127, 2003.
A. Momigliano, A. Martin, and A. Felty. Two-level hybrid: A system forreasoning using higher-order abstract syntax. In International Workshop

on Logical Frameworks and Meta-Languages: Theory and Practice,2007.

A. Nanevski, F. Pfenning, and B. Pientka. Contextual modal type theory.Transactions on Computational Logic, 2007. To appear.
U. Norell. Towards a practical programming language based on dependenttype theory. PhD thesis, Chalmers University of Technology, 2007.
F. Pfenning and C. Schu"rmann. System description: Twelf - a meta-logicalframework for deductive systems. In H. Ganzinger, editor, International

Conference on Automated Deduction, pages 202-206, 1999.
B. Pientka. A type-theoretic foundation for programming with higher-orderabstract syntax and first-class substitutions. In ACM SIGPLAN-SIGACT

Symposium on Principles of Programming Languages, pages 371-382,2008.

A. M. Pitts and M. J. Gabbay. A metalanguage for programming with boundnames modulo renaming. In R. Backhouse and J. N. Oliveira, editors,

Mathematics of Program Construction, volume 1837 of Lecture Notes inComputer Science, pages 230-255. Springer-Verlag, Heidelberg, 2000.

A. Poswolsky and C. Schu"rmann. Practical programming with higher-order encodings and dependent types. In European Symposium on

Programming, 2008.
F. Pottier. Static name control for FreshML. In IEEE Symposium on Logicin Computer Science, 2007.

M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Programmingwith binders made simple. In ACM SIGPLAN International Conference

on Functional Programming, pages 263-274, August 2003.
R. Virga. Higher-Order Rewriting with Dependent Types. PhD thesis,Carnegie Mellon University, 1999.