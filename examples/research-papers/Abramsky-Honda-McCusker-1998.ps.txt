

A fully abstract game semantics for general references

Samson Abramsky Kohei HondaLFCS, University of Edinburgh

fsamson,koheig@dcs.ed.ac.uk

Guy McCuskerSt John's College, Oxford
mccusker@comlab.ox.ac.uk

Abstract
A games model of a programming language with higher-order store in the style of ML-references is introduced. The category
used for the model is obtained by relaxing certain behavioural conditions on a category of games previously used to providefully abstract models of pure functional languages. The model is shown to be fully abstract by means of factorization

arguments which reduce the question of definability for the language with higher-order store to that for its purely functional
fragment.

Copyright 1998 IEEE. Published in the Proceedings of LICS'98, 21-24 June 1998 in Indianapolis, Indiana. Personal useof this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes
or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component ofthis work in other works, must be obtained from the IEEE. Contact: Manager, Copyrights and Permissions / IEEE Service
Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 732-562-3966.

1

1 Introduction
Over the past few years, game semantics has been used togive the first syntax-independent constructions of fully abstract models for a number of programming languages, in-cluding the prototypical functional language

PCF [1, 8, 20],functional languages with richer type structures or different

evaluation strategies [2,3,7,12,13], and languages with im-perative features such as first-order references and non-local
control constructs [4, 5, 11]. In the present paper, we obtainthe first full abstraction result for a language with general
references.

By general references we mean references which canstore not only values of ground types (integers, booleans,

etc.) but also those of higher types (procedures, higher-order functions, or references themselves). The general reference is a useful and powerful programming construct: theability to store and pass arbitrary references is essential not
only for efficiency but also for clarity of program structuresinvolving stateful entities, as in object-oriented programming. Indeed, the behavioural aspects of object-orientedprogramming can be cleanly and directly represented once
one has general references (cf. Section 2.3). The power ofgeneral references in typed imperative languages may also
be seen from the observation that a basic feature of "mobil-ity" or "scope extrusion" in the

ss-calculus [17], namely theability to pass references to arbitrary behaviours out of the

scope in which they were created, is already present in thissetting. This feature is essential in object-oriented programming where one often needs to pass a reference to a newlycreated object to another object.

The key idea behind our model is to represent a refer-ence by a certain form of

information flow: a reference ismodelled not as a static entity, but as a dynamic behaviour

which mediates the flow of information between readersand writers, connecting them in an appropriate fashion. In
the presence of higher-order references, these connectionshave to be made dynamically, and the computations of the
multiple readers and writers may be interleaved in arbitrar-ily complex ways. The technical apparatus of game semantics provides exactly the right setting in which to for-malize this idea. The "dynamic connections" used to interpret references are modelled concretely by copy-cat behaviour, a ubiquitous notion in game semantics; and the cat-egorical structure provided by games allows this modelling

of references to be integrated smoothly and composition-ally with the interpretation of the other program phrases.
This dynamic representation of references is quite differ-ent in character to the traditional location-based models
of store [15, 21, 25] (or related denotational models of ss-calculus [6, 24]). It forms the basis of a precise semantic
account of programs with general references, as shown bythe full abstraction result.

Technically, our results follow a similar pattern to those

in [4, 5, 11], and exemplify the paradigm of the "seman-tic cube" proposed by the first author. In this paradigm,
we consider firstly a "syntactic cube" of extended typed *-calculi. The "origin" of this cube is occupied by a purely
functional language. Each "axis" of the cube correspondsto the extension of the purely functional language by some
non-functional feature, such as state or control. Corre-sponding to this syntactic cube, there is a "semantic cube"
of various categories of games and strategies. The originof the semantic cube is occupied by the category of highly
constrained strategies which correspond to the discipline ofpurely functional programming. These constraints include
"innocence" and "well-bracketing" as in [8, 20]. Each axisof the semantic cube corresponds to the relaxation of one of
these semantic constraints on strategies. Thus we get cat-egories of innocent but non-well-bracketed strategies [11],
of well-bracketed but "knowing" (i.e. non-innocent) strate-gies [4, 5], etc. Remarkably, there is a precise correspondence between these syntactic and semantic cubes. Thusfor example relaxing the constraint of innocence allows us
to model first-order references [4], while relaxing the well-bracketing constraint allows control to be modelled [11].
Moreover, these increments in expressive power are exact,as shown by factorization theorems: for example, every
knowing strategy can be factored as the composition of aground-type reference and an innocent strategy. This immediately reduces definability in the extended language withground-type references to definability of innocent strategies
by purely functional programs, as already shown in [8, 20].Thus this method is technically powerful as well as exhibiting the surprisingly modular internal structure of the gamesuniverse.

(The relaxation of constraints on strategies is by nomeans the only meaningful variation of the game semantics
setting which can be considered. In particular, the notionof game itself can be modified. A number of such modifications have already proved fruitful: allowing answersto enable questions, as in [12, 13], which is needed in order to model sum types; varying the way in which gamescan start, as in [3, 7], which allows call-by-value to be captured; and introducing a distinction between "active" and"passive" moves, used in giving a fully abstract semantics
for pure Idealized Algol [5].)

The games we use to model general references arebased on those which have been used in previous work

[4,7,8,11-13,20], with one significant difference: we aban-don the technical condition called visibility. Just as relaxing the condition of innocence corresponds to the model ofground-type references, so the additional freedom provided
by abandoning visibility precisely captures the semanticsof general references, as shown by our full abstraction result. The proof again uses factorisation arguments alongthe line of [4, 5, 11]. Each strategy in our model (which in

2

general satisfies neither innocence nor visibility) can be fac-tored into a higher-order cell and a strategy satisfying visibility; but in [4] it is shown that a strategy of the latter kindcan be factored into the combination of a first-order cell
and an innocent strategy. The definability result then fol-lows immediately from the definability of innocent strategies [3, 7, 8, 20], leading to full abstraction. Thus the (lackof) visibility corresponds precisely to the semantic difference between higher-order cells and ground cells, offeringa basic semantic analysis of general references.

2 A language with references
The language L we shall consider is the call-by-value sim-ply typed

*-calculus over the ground type of natural num-bers, extended with reference types. This is the simplest

setting in which the key ideas behind our results can be con-veyed. However, it is certainly possible to extend the model
with richer functional features as in [14], and with controloperators as in [11], yielding a model of a language with
most of the features of Core ML [18]. We believe that thetechniques used in the present paper, combined with those
in [11,14], could be used to extend our results to this setting.

The types of our language are as follows.

A ::= unitjnatjA \Theta  BjA ! Bjvar[A]:
The terms are those of the simply-typed *-calculus (withproducts) extended with the constants for arithmetic and
creation, assignment and dereferencing of program vari-ables; see Figure 1, which also contains some typing rules.
The mkvar construct allows for the creation of so-called"bad variables"--see Section 2.4. Note that we have not
included recursion combinators; as we will see, these canbe

defined.

2.1 Operational semantics
The operational semantics of the language is given interms of a countable collection of locations ranged over by

l; l1; l2; : : :. We give an inductive definition of a relation

(L; s)M + (L0; s0)V
where M is an expression, V a value of the same type(see below), and

(L; s) and (L0; s0) are stores consistingof a set
L of location-type pairs and a partial function sfrom locations in

L to values of the appropriate type. Wewrite
s(l 7! V ) for the store obtained by altering s so thatlocation

l is mapped to value V . The values of the lan-guage are:

skip, numerals, *-abstractions, pairs of values,
mkvar V V 0 where both V and V 0 are values, and locations.

A few clauses of the inductive definition are given in Fig-ure 2; the remaining clauses are the standard call-by-value

rules for function types, product types and arithmetic. We

adopt the convention that, for example,

M +V M 0+V 0

M 00+V 00

is an abbreviation for

(L; s)M +(L0; s0)V (L0; s0)M 0+(L00; s00)V 0

(L; s)M 00+(L00; s00)V 00

to aid readability. For a closed term M containing no freelocations, we write

M + to indicate that (;; ;)M + (L; s)Vfor some
L, s and V . The notion of observational equiva-lence between terms is the usual one:

M ' N iff for allcontexts
C[\Gamma ] such that C[M ] and C[N ] are closed andcontain no free locations,

C[M ]+ iff C[N ]+.

2.2 Simple examples
The constructs of a basic imperative language can be con-sidered as syntactic sugar for those of

L. The type unit,whose elements may have side-effects on the store but return no non-trivial values, is used as the type of commands.Sequential composition

C1; C2 is syntactic sugar for

(*d : unit:C2)C1
where d is a variable not appearing in C2. Note that thisonly works because evaluation in

L is call-by-value. Thisconstruct applies equally when
C2 is not of type unit,yielding side-effecting expressions at all types. A variable

declaration

new x : A in M

is sugar for

(*x : var[A]:M)newA:

Iterative constructs such as while loops are desugared us-ing recursion. We will define a

Y combinator later, but fornow let us show how a simple loop

while M 6= 0 do C end
is desugared. Intuitively, this ought to be a recursively de-fined element of type

unit, but because L is call-by-value,it is necessary to work with "thunks" of type

unit ! unitinstead. We therefore code such a loop as

Y (*f : (unit ! unit):

ifzero M then (*d : unit:skip) else

(*d : unit:C; f (skip)))

and apply the resulting value of type unit ! unit to thedummy argument

skip to execute it.So far, our examples have been very simple and have not

exploited the great power of general references. The defini-tion of the

Y combinator, on the other hand, does make use

3

M ::= x j skip j n j succ M j pred M j ifzero M M M j *x : A:M j M M

j hM; M i j fst M j snd M j newA j M := M j ! M j mkvar M M:

\Gamma  ` newA : var[A]

\Gamma  ` M : var[A]

\Gamma  ` ! M : A

\Gamma  ` M : var[A] \Gamma  ` N : A

\Gamma  ` M := N : unit

\Gamma  ` M : A ! unit \Gamma  ` N : unit ! A

\Gamma  ` mkvar M N : var[A]

Figure 1. Syntax and typing rules of L

M1 + V1 M2 + V2
mkvar M1 M2 + mkvar V1 V2 l 62 L(L; s)newA + (L [ fl : Ag; s)l

(L; s)M + (L0; s0)l (L0; s0)N + (L00; s00)V

(L; s)M := N + (L00; s(l 7! V ))skip

M + mkvar V1 V2 N + V V1(V ) + skip

M := N + skip
(L; s)M + (L0; s0)l s0(l) = V

(L; s) ! M + (L0; s)V

M + mkvar V1 V2 V2(skip) + V

! M + V

Figure 2. Operational semantics of L

of this expressiveness. It is well known that general refer-ences can be used to build cyclic structures in the store. One
consequence of this is that recursively defined functions canbe encoded by building the corresponding cyclic graph. We
can therefore define a Y combinator as follows.

*f : (A ! B) ! (A ! B):

new y : A ! B in

y := *a : A:f (! y)(a);
return ! y:

To implement a recursively defined function, this programgenerates a new reference

y, builds in it a cyclic graph, andreturns the value so created. Note that the type of this operator does not contain any reference types. This means thatit is impossible for the environment to alter the value stored
in y.
2.3 Objects
Leaving aside issues of sub-typing and inheritance, the behavioural aspects of objects can be represented in a directand general fashion in our language. The general scheme is

that an object is represented by a term of the form

new l1 := v1; : : : lk := vk in hm1; : : : ; mpi
where l1, . . . , lk are the local variables of the object, and
m1, . . . , mk are functions representing its methods; and

new x in C is syntactic sugar for (*x:C)new. The typeof such an object will simply be the product of the types of
its methods. (Later we will use a similar idea to model ref-erences themselves in our semantic universe.) For example,
a stack object might be represented thus:

new p : nat := 0; a : array[] of nat in
[push = *n : nat:p := ! p + 1; a[! p] := n;

pop = *():if ! p 6= 0 then p := ! p \Gamma  1;
: : : etc:
]

Here array[] of nat is syntactic sugar for a type of arrayobjects, which can readily be programmed in

L. Note thatthe locality of the local state of the object is enforced simply by the fact that the variables are bound by new and donot appear in its type. Moreover, any (acyclic) object hierarchy, in which objects can have objects in their local state,as above, and methods can take objects as arguments and
return objects as results, can be accommodated within theframework of simple types using this representation.

Of course, we don't claim that this offers a full analy-sis of object-oriented programming; but the way in which
the behavioural aspects can be represented so directly doessuggest the expressive power of higher-type references.

4

2.4 Equality of references and bad variables
One important aspect of reference types in languages suchas Standard ML is

not reflected in our language; namely theoperation of comparing references for equality. This operation is intimately related with the issue of bad variables, anissue first identified by Reynolds [22]. Roughly speaking, a
bad variable is a value of reference type which does not de-note a location in the store. It clearly makes no sense to test
whether two such things denote the same location! On theother hand, if all variables are "good", then equality of (nontrivial) references is definable. (The idea for ground types issimply to write different values into the two variables, and
then test if they contain the same value. This can be ex-tended to higher types using constant functions, as pointed
out to the first author by John Reynolds; although, intrigu-ingly, it does not extend to the type of references which cannot hold interesting values, var[unit], which is essentiallythe type of names of the

ss-calculus.)
We shall follow Reynolds in viewing the type var[A] asa product of a "read method" and a "write method". Once

this view is taken, then behaviours of type var[A] need looknothing like

bona fide references (for example, reads neednot be causally related to writes). Such bad variables are

created in our language using the mkvar construct, whichtakes a value of type

A ! unit (the write method), anda value of type
unit ! A (the read method), returning a"variable object" of type

var[A]. Thus mkvar makes ex-plicit the identification of the type

var[A] with the productof its method types.

The absence of equality of references from our language(or, equivalently, the presence of bad variables) may be regarded as a greater or lesser defect depending on one's viewof a number of related issues. For example, Peter O'Hearn
has pointed out that in the absence of bad variables, the con-structor

var[\Delta ] is not functorial! From the point of view ofsemantics, therefore, bad variables appear to make the path

smoother, and this is certainly the case for the present pa-per: our definability result makes essential use of

mkvar.Finding a fully abstract model for a language with equality

of references must be left as a challenge for future work.

3 A games model of references
We now define the categories of games which provide ourmodel of

L and explain how L is interpreted. Our interpre-tation is structured using a

computational monad [19] whichserves to distinguish values, that is, programs which terminate immediately without accessing the store, from compu-tations, which may read from and write to the store before
terminating, and may also fail to terminate at all.

The games and strategies we use are direct descendantsof those used by Hyland, Ong and Nickau [8, 20] to provide fully abstract models of PCF. The main differences

are that the key technical conditions of visibility and innocence (see below) are both relaxed. Another difference isthat we model call-by-value, rather than call-by-name, computation. For this we can use either the construction in [7]or that of [3], with the same effect; here we choose the latter.

3.1 Arenas
A game has two participants: Player (P) and Opponent (O).A play of the game consists of a sequence of moves, alternately by O and P. In addition, each move is explicitly
justified by an earlier move of the play, unless it is a specialkind of move, called initial, which needs no justification. In

the games we consider, O always moves first.Before embarking on a formal definition, let us fix notation for sequences and operations on them. We use s, t, . . .to range over sequences and

a, b, . . . over elements of se-quences. If
s and t are sequences, then st or s \Delta  t is theirconcatenation;

" is the empty sequence. A move a will of-ten be identified with the singleton sequence consisting just

of a.An arena is specified by a triple

A = hMA; *A; `Aiwhere

ffl MA is a set of moves.
ffl *A : MA ! fO; Pg \Theta  fQ; Ag is a labelling functionwhich indicates whether a move is by Opponent (

O)or Player (
P), and whether it is a question (Q) or ananswer (
A). We write

fO; Pg \Theta  fQ; Ag = fOQ; OA; PQ; PAg

*A = h*OPA ; *QAA i:

The function *A is *A with the O/P part reversed, sothat

*A(a) = OQ () *A(a) = PQ
and so on. If *OP(a) = O, we call a an O-move;otherwise,

a is a P-move.

ffl `A is a relation between MA + f?g and MA, calledenabling, which satisfies

- ? `A a ) *A(a) = OQ^

[b `A a () b = ?].

- a `A b ^ *QAA (b) = A ) *QAA (a) = Q.
- a `A b ^ a 6= ? ) *OPA (a) 6= *OPA (b).

The enabling relation tells us either that a move a is initialand needs no justification (

? `A a), or that it can be justifiedby another move
b, if b has been played (b `A a).A justified sequence

s of moves in an arena A is a se-quence of moves together with justification pointers: for

each move a in s which is not initial, there is a pointer toan earlier move

b of s such that b `A a. We say the move b

5

justifies a, and extend this terminology to say that a move bhereditarily justifies

a if the chain of pointers back from apasses through
b.A justified sequence is a legal position iff:

ffl s is alternating: if s = s1abs2 then *OP(a) 6= *OP(b).
ffl The bracketing condition holds. We say that a ques-tion

q in s is answered by a later answer a in s if qjustifies

a. The bracketing condition is satisfied by s iffor each prefix

t \Delta  q \Delta  u \Delta  a of s, all questions asked in
u are answered within u; in other words, when an an-swer is given, it is always to the most recent question

which has not been answered--the pending question.
The set of all legal positions of an arena A is written LA.

3.2 Strategies
A strategy for an arena A is a rule telling Player what moveto make in a given position. Formally, this can be represented as a set oe of legal positions in which P has justmoved, i.e. a set of even-length positions, such that

ffl " 2 oe
ffl sab 2 oe ) s 2 oe
ffl sab; sac 2 oe ) b = c.
For any arena A, the smallest possible strategy is f"g, whichnever makes any response. It is called the empty strategy

and denoted ?.Given a non-empty legal position

sa in an arena A, thecurrent thread
thread(sa) is the subsequence of sa con-taining all moves hereditarily justified by the same initial

move as a. A strategy oe for A is thread-independent iff

ffl if sab 2 oe then b is justified by a move in thread(sa);and

ffl if sab; t 2 oe, and ta 2 LA is such that thread(sa) =

thread(ta), then tab 2 oe, with the justification pointeron

b such that thread(tab) = thread(sab).

That is to say, a thread-independent strategy chooses itsmove at a position

sa based just on the moves in the currentthread
thread(sa). From now on we will only be interestedin thread-independent strategies. We write

oe : A to indicatethat
oe is a thread-independent strategy for A.

3.3 Constructions on arenas
Given arenas A and B, the arenas A \Theta  B and A ) B aredefined as follows.

MA\Theta B = MA + MB (disjoint union)

*A\Theta B = [*A; *B]
? `A\Theta B a () ? `A a . ? `B a

a `A\Theta B b () a `A b . a `B b

MA)B = MA + MB

*A)B = [*A; *B]
? `A)B a () ? `B a

a `A)B b () a `A b . a `B b .

[? `B a ^ ? `A b]

The idea here is that the games A and B are played in par-allel. In

A \Theta  B, labelling and enabling are inherited directlyfrom
A and B. In A ) B, the O/P roles in A are reversed,and initial moves of

A are now justified by initial moves of
B. The unit for \Theta  is the empty arena 1 = h;; ;; ;i.It is worth noting that in contrast to other games models,

it is not the case that if s is a legal position of A\Theta B, then thesubsequence

s _ A of moves from A is a legal position of
A. Indeed, s _ A may not even be alternating. This liberalapproach is necessary for our interpretation of higher-order

store.
3.4 The category C
We define a category C as follows.

Objects : Arenas.Morphisms
A ! B : Thread-independent strategiesfor

A ) B:

Identity The identity map id : A ! A on an arena A isgiven as usual by the `copycat' strategy

fs 2 PA1)A2 j 8t veven s: t _ A1 = t _ A2g:
We use subscripts on the `A's to distinguish the two occur-rences, and write

t veven s to mean that t is an even-lengthprefix of
s. This strategy responds to any move simply bycopying it to the other component.

Composition Given maps oe : A ! B and o/ : B ! C, i.e.strategies

oe : A ) B and o/ : B ) C, we define

oe k o/ = aes fifififi s _ A; B 2 oe; s _ B; C 2 o/;s _ A; C 2 L

A)C oe

where s ranges over sequences of moves from MA + MB +
MC. We then set

oe ; o/ = fs _ A; C j s 2 oe k o/ g:
This can be shown to be well-defined and associative.
3.5 C as a cartesian closed category
The operation \Theta  is the categorical product in C. The pro-jections are given by the obvious copy-cat strategies

ss1 :
A \Theta  B ! A and ss2 : A \Theta  B ! B. Given thread-independent strategies

oe : C ! A and o/ : C ! B,their pairing
hoe; o/ i : C ! A \Theta  B is defined as follows.

6

If s 2 LC)A\Theta B, write s1 for the subsequence of thosemoves hereditarily justified by an initial move of

A, and s2for those moves hereditarily justified by an initial move of

B. Then hoe; o/ i is defined by:

fs 2 LC)A\Theta B j s1 2 oe; s2 2 o/ g:
It is straightforward to check that this does indeed give riseto a product in

C.For any
oe : A \Theta  B ! C, there is a strategy \Lambda (oe) :
A ! (B ) C) defined by relabelling the moves of oe. Itcan be checked that this bijection of hom-sets makes

C intoa cartesian closed category.

3.6 Weak coproducts
In addition to its cartesian closed structure, C also has aweak coproduct which, despite not being a genuine coproduct, enjoys a universal property analogous to that of the sep-arated sum of cpos. To state this, some auxiliary definitions
are necessary.Say that an arena

A is pointed if it has exactly one initialmove. Given pointed arenas

A and B, a map oe : A ! Bof
C is strict iff it responds to the initial move of B withthe initial move of

A, which it never plays again. Pointedarenas and strict maps form a subcategory

C?. In fact C? isan exponential ideal: if
B is pointed, then so is A ) B forany
A, and if o/ is a strict map, then so is oe ) o/ for any oe.Let

fAi j i 2 Ig be a family of arenas. The pointedarena
\Sigma i2I Ai has as its set of moves

fqg + fi j i 2 Ig + \Sigma iMAi
where \Sigma iMAi denotes disjoint union of sets. The move q isthe unique initial question, asking which of the

Ai to playin. There is one answer to
q for each i 2 I; this answer inturn enables the initial moves of

Ai. For all other moves,labelling and enabling is inherited from the

Ai.For each
i there is an obvious (non-strict) strategy ini :
Ai ! \Sigma i2I Ai which responds to the initial question withthe move

i and thereafter plays copycat. The universal prop-erty of the sum can now be stated as follows.

For any family foei : Ai ! B j i 2 Ig of maps in C, with
B pointed, there is a unique map [oei j i 2 I] : \Sigma iAi ! B in
C? such that for each i, ini ;[oei j i 2 I] = oei. The strategy
[oei j i 2 I] behaves as follows. It responds to the uniqueinitial question of

B by asking q in \Sigma iAi. After O respondswith some
i, it continues to play as oei would play, ignoringthe extra two moves

q \Delta  i.The separated sum of a singleton family

fAg corre-sponds to lifting; we shall therefore write this as

A?. Theunique answer to the initial question
q will be written as \Lambda .

Remark The condition of thread-independence dependscrucially on the initial moves of an arena; since the weak

coproduct and lifting constructions add new initial moves,

they have a great effect on the available thread-independentstrategies. For example, a thread-independent strategy for
A \Theta  B must consist of a pair of thread-independent strate-gies, one for

A and one for B. Thread-independence im-plies that no information flows between these two strategies. On the other hand, a thread-independent strategy for
(A \Theta  B)? may be of a very different kind: moves madein

A may affect later moves in B and vice versa. This canbe seen as reflecting the difference between values of type

A \Theta  B, which are pairs of values for A and B, and arbi-trary terms, which may create and use store, allowing the

Aand
B parts to communicate. In the following section, thesedistinctions will be packaged in the form of a strong monad.

3.7 The category Fam(C)
The category C defined above most naturally models call-by-name programming languages, but

L is call-by-value.We therefore require certain modifications. We choose to

use the construction given in [3], so that our model of Llives not in

C but in its free completion under coproducts,which we call

Fam(C). An alternative, more direct, presen-tation of the call-by-value model could be given along the

lines of [7].The objects of

Fam(C) are families fAi j i 2 Ig of are-nas. A map from

fAi j i 2 Ig to fBj j j 2 Jg consistsof a reindexing function

f : I ! J together with a fam-ily of maps
foei : Ai ! Bf(i) j i 2 Ig of C; thus each
oei is a thread-independent strategy. As shown in [3], thecartesian closed structure of

C, together with the fact that Chas
all small products, makes Fam(C) cartesian closed, andthe weak coproduct structure gives rise to a strong monad

T on Fam(C). Given families A = fAi j i 2 Ig and
B = fBj j j 2 Jg, we set

A \Theta  B = fAi \Theta  Bj j (i; j) 2 I \Theta  Jg
A ) B = f\Pi i2I (Ai ) Bf(i)) j f : I ! Jg

T A = f\Sigma i2I Aig; a singleton family.

The family f(ini : Ai ! \Sigma iAi)i j i 2 Ig gives the unit
j : A ! T A of the monad, and the copairing operation ofthe weak coproduct is used to define the "lifting" operation

of the monad, taking a map f : A \Theta  B ! T C to f \Lambda  :
A \Theta  T B ! T C. There are two distinct ways of using thisoperation to turn the unit

j : A \Theta  B ! T (A \Theta  B) intoso-called "double strength" morphisms

dst; dst0 : T A \Theta  T B ! T (A \Theta  B):
Intuitively, dst produces a computation of type A\Theta B whichworks by evaluating its arguments, computations of type

Aand
B, in left-to-right order, while dst0 evaluates right-to-left. The inequality of

dst and dst0 reflects the fact that theorder in which side-effecting programs are evaluated is critical. In the categorical jargon, this inequality means that themonad

T is not commutative [10].

7

Fam(C) also has coproducts given by disjoint union offamilies. The object

N = f1n j n 2 !g is a natural num-bers object.

3.8 Constraining strategies
We will make use of some additional constraints which canbe applied to strategies, both of which depend on the notion of view of a justified sequence. Given an odd-lengthjustified sequence

s, its view psq is defined as follows.

ps \Delta  aq = a; if a is initial
ps \Delta  a \Delta  t \Delta  bq = psq \Delta  a \Delta  b:

A strategy oe : A satisfies the visibility condition iff for all
sab 2 oe, the move justifying b lies in psaq. Given oe : Asatisfying the visibility condition, we say

oe is innocent iff

8sab; t 2 oe:ta 2 LA ^ psaq = ptaq ) tab 2 oe;
and the justification pointer from b in tab points to the samemove of

ptaq as does the pointer from b in sab. That is tosay, an innocent strategy bases its response at a position

sajust on the view
psaq. (Note that an innocent strategy is al-ways thread-independent.) The identity strategy is innocent,

and both innocence and visibility are preserved by com-position. The subcategory of innocent strategies provides
a fully abstract model of pure functional languages like
PCF [8, 20], while strategies subject to the visibility con-dition yield full abstraction for languages with first-order

store [3, 4].
3.9 Interpretation of L
We now briefly review the standard interpretation of a call-by-value language in a CCC with strong monad [19], which

forms the backbone of our interpretation of L in Fam(C).The interpretation of the type

var[\Gamma ] and constants relatingto store is deferred to the next section.

Each type A of L will be interpreted as an object [[A]].The interpretations of

unit and nat are 1 and N respec-tively; the denotations of product and function types are defined inductively:

[[A \Theta  B]] = [[A]] \Theta  [[B]]
[[A ! B]] = [[A]] ) T [[B]]:

A term x1 : A1; : : : ; xn : An ` M : A is interpreted asa map

[[A1]] \Theta  \Delta  \Delta  \Delta  \Theta  [[An]] ! T [[A]]. A few clauses of theinterpretation are given in Figure 3, in which

succ denotesthe successor map of the natural numbers object

N, and \Gamma ranges over contexts of the form
x1 : A1; : : : ; xn : An.

3.10 Modelling store in Fam(C)
To make Fam(C) into a model of L, we must give an objectinterpreting the type

var[A], and morphisms to interpret the

terms relating to store. Following Reynolds [23] (cf. [16]),we take an "object oriented" view of variables, modelling
the type var[A] as the product of its "write method", of type
A ) T 1, and its "read method", of type T A. We thereforeset

[[var[A]]] = ([[A]] ) T 1) \Theta  T [[A]]:
The first and second projections give rise to maps

[[var[A]]] \Theta  [[A]] T [[unit]]

assign

[[var[A]]] T [[A]]deref
and hence to interpretations of assignment and dereferenc-ing, while

mkvar can be interpreted using pairing; see Fig-ure 4.

It remains to give an interpretation of newA. For each
A = fAi j i 2 Ig, we require a morphism 1 ! T var[A],that is, a strategy

cell for the game

(\Pi i2I (Ai ) 1?) \Theta  \Sigma i2I Ai)?:
We shall write the initial move of the \Sigma iAi component as
read, since it corresponds to a request to read from the vari-able; similarly, the initial question of the

ith component of
\Pi i(Ai ) T 1) will be called write(i), and its unique answeris

ok. The strategy cell has the following behaviour.

ffl It responds to the initial question q with its unique an-swer

\Lambda .

ffl If the next move is read, it makes no response (so cellcorresponds to an uninitialized variable).

ffl cell responds to each write(i) with ok.
ffl If the move read is played and the most recently playedwrite move was

write(i), cell responds with i.

ffl Suppose O plays a move a initial in some Ai in theread component. This move must be justified by some

answer i to the move read. cell copies the move a to thewrite component, justified by the most recent

write(i)which occurred before the
read. (This violates the vis-ibility condition).

ffl Thereafter, cell copies all moves hereditarily justifiedby either of these copies of

a back and forth betweenthe read and write components.

Each time O plays a read, it is establishing a new "readthread"; similarly each

write(i) establishes a "write thread".When O plays a
read, cell creates a "link" between thecurrent read thread and the most recently established write

thread. Concretely, this link is realized by copying movesbetween the read thread and the write thread, in a fashion by
now familiar in game semantics. The usual, "logical" linksinterpreted by copy-cat strategies which are used to build

8

[[\Gamma  ` xi : Ai]] = ssi ; j : [[A1]] \Theta  \Delta  \Delta  \Delta  \Theta  [[An]] ! T [[Ai]]
[[\Gamma  ` *x:M : A ! B]] = \Lambda ([[\Gamma ; x : A ` M : B]]) ; j : [[\Gamma ]] ! T ([[A]] ! T [[B]])

[[\Gamma  ` M N : B]] = h[[\Gamma  ` M : A ! B]]; [[\Gamma  ` N : A]]i ; dst ; ev\Lambda  : [[\Gamma ]] ! T [[B]]
[[\Gamma  ` succ M : nat]] = [[\Gamma  ` M ]] ; T succ : [[\Gamma ]] ! T [[nat]]

Figure 3. Interpretation of L

[[\Gamma  ` M := N : unit]] = h[[\Gamma  ` M : var[A]]]; [[\Gamma  ` N : A]]i ; dst ; assign\Lambda  : [[\Gamma ]] ! T [[unit]]

[[\Gamma  ` ! M : A]] = [[\Gamma  ` M : var[A]]] ; deref\Lambda  : [[\Gamma ]] ! T [[A]]
[[\Gamma  ` mkvar M N : var[A]]] = h[[\Gamma  ` M : A ! unit]]; [[\Gamma  ` N : unit ! N ]]i ; dst ; ,=: [[\Gamma ]] ! T [[var[A]]]

Figure 4. Semantics of store

(\Pi i (Ai ) T 1) \Theta  \Sigma iAi )?

q
\Lambda 
write(i)

ok

read

i
a1
a1
a2

a2
write(j)

ok

a3
a3

read

j
b1
b1

Figure 5. A typical play of cell
the cartesian closed structure of our model are statically de-termined by the types. By contrast, the links established by
cell are highly dynamic, and violate behavioural constraintssuch as visibility.

Figure 5 depicts a typical play of cell. An omitted justifi-cation pointer on a non-initial move indicates that the move
is justified by the immediately preceding one. Notice howthe justification pointers serve to indicate which particular
thread of writing is copied to each thread of reading.

This completes our description of the game semanticsof
L. We now state a simple lemma which shows that the

order of (disjoint) allocations and assignments of variablesdoes not matter, and that assignment to a variable

x destroysany value previously stored there.

Lemma 1 The equations given in Figure 6 hold in thegames model of

L whenever the terms concerned are well-typed.

4 Soundness and Adequacy
The first soundness result that we require is that the deno-tational semantics of

L respects its operational semantics inan appropriate way. Before stating the result, let us introduce some notation. Given a store (L; s) and a term

l1 : var[A1]; : : : ; ln : var[An] ` M : A
where the li and their types correspond to the locationsand types in

L, we write new L; s in M for the expres-sion
new l1 : A1; : : : ; ln : An in l1 := s(l1); : : : ; ln :=
s(ln); M . (The order of these allocations and assignmentsdoes not matter because of Lemma 1.) The soundness of

our model can then be stated as follows.
Proposition 2 (Soundness) If for some term M we have
(L; s)M + (L0; s0)V , then [[new L; s in (*x:N)M ]] =
[[new L0; s0 in (*x:N)V ]] for any suitably typed term N .

This is proved by a simple induction on the derivation of
(L; s)M +(L0; s0)V , using standard facts about strong mon-ads on CCCs together with the equations of Figure 6 and the

additional equation

[[\Gamma  ` new x : A in x := V ; (*y:M)(! x)]]
= [[\Gamma  ` new x : A in x := V ; (*y:M)(V )]]:

The validity of this final equation is proved by a detailedanalysis of the strategies involved, showing that the copycat

9

[[\Gamma  ` new x : A; y : B in M ]] = [[\Gamma  ` new y : B; x : A in M ]]
[[\Gamma ; x : var[A] ` new y : B in x := V ; M ]] = [[\Gamma ; x : var[A] ` x := V ; new y : B in M ]]
[[\Gamma  ` new x : A; y : B in x := V1; y := V2; M ]] = [[\Gamma  ` new x : A; y : B in y := V2; x := V1; M ]]

[[\Gamma  ` new x : A in x := V1; x := V2; M ]] = [[\Gamma  ` new x : A in x := V2; M ]]

Figure 6. Equations concerning assignments and allocations
behaviour of cell correctly feeds moves from the "writer" tothe "reader".

We also need:

Proposition 3 (Adequacy) For any closed term M , if
[[M ]] 6= ? then M +.

The (long) proof works by analysing the interactions in-volved in a given non-empty play of the strategy

[[M ]]: sucha play arises from the interaction of several plays of strategies representing subterms of M . The length of this inter-action forms the basis for an inductive proof. Putting these
results together, we have:

Theorem 4 (Equational Soundness) If M and N areterms of the same type and

[[M ]] = [[N ]], then M ' N .

5 Full abstraction
Our proof of definability, and hence full abstraction, hingeson a factorization result, which we shall now prove.

Throughout this section we will often use the syntax of Las an informal notation for the constructions on strategies
defined by the semantics, and we will identify the object
[[unit ! unit]] with the isomorphic T 1.

Proposition 5 For any arena A and any finite, thread-independent strategy

oe : 1 ! T A, there exists anatural number
k and thread-independent strategy o/ :
kz ""-- -

var[T 1] \Theta  \Delta  \Delta  \Delta  \Theta  var[T 1] ! T A such that o/ is finite andsatisfies the visibility condition, and

(new x1; : : : ; xk : unit ! unit in o/ ) = oe:
Proof We will just consider the case where oe consistsof all even-length prefixes of a single sequence

s, whichmay contain violations of the visibility condition. The argument generalizes to arbitrary finite oe straightforwardly.Suppose

s = s1as2bs3 where b is a P-move and s1as2b vi-olates visibility. Consider the following justified sequence

in var[T 1] ) T A.

((T 1 ! T 1) \Theta  T 21) ! T A.

..oe s1

a
write(\Lambda )

ok .

..oe s2

read

\Lambda 

q
q

b.

..oe s3

The play in T A is the same as s, while the play in var[T 1]follows the pattern of

cell. Most importantly, the move bno longer violates the visibility condition, since

a is in theview when
b is played. This transformation is the essence ofthe factorization result; however, the above sequence need

not satisfy the bracketing condition, and the transformationmay cause moves in

s3 to violate the visibility conditionwhere they did not before, so some care is needed.

We now describe the transformation precisely. Let k bethe number of

O-moves in s; we will produce a legal po-sition in the arena

var[T 1] \Theta  : : : \Theta  var[T 1]-- -z ""

k

! T A which

satisfies visibility and is identical to s in the T A compo-nent. First insert the segment

write(\Lambda )ok after each O-moveof
s, the nth such segment being in the nth var[T 1] com-ponent. We now insert further sequences of moves before

each P-move, starting from the first.

Case 1 Before a P-question, justified by the nth O-move,insert the segment

read \Delta  \Lambda  \Delta  q \Delta  q, in the nth var[T 1] com-ponent, as above. The final

q is justified by the write(\Lambda )inserted immediately after the

nth O-move, so the follow-ing
P-move satisfies visibility; it also satisfies bracketingsince it is a question.

10

Case 2 Before a P- answer, the play so far will take theform (writing

q for questions and a for answers)

: : : q \Delta  tn \Delta  qn \Delta  \Delta  \Delta  an \Delta  \Delta  \Delta  t2 \Delta  q2 \Delta  \Delta  \Delta  a2 \Delta  t1 \Delta  q1 \Delta  \Delta  \Delta  a1
where q is the question to be answered by the following
P-move and the ti are the moves in the var[T 1] compo-nents we have so far inserted, which therefore take the form

write(\Lambda )ok in some component, followed by read \Delta  \Lambda  \Delta  q \Delta  q insome other component. We insert the following sequence
of moves: P answers the final q of t1, then O copies this an-swer to the previous

q; this is repeated for t2, . . . , tn. Thuswhen the following
P-answer is played, neither bracketingnor visibility are violated.

Taking all even length prefixes of this sequence yieldsthe required strategy

o/ . \Lambda 

This factorization result reduces the question of defin-ability for finite strategies to that for strategies satisfying

the visibility condition. Another factorization result, takenfrom [4], is of further assistance.

Proposition 6 Let o/ : 1 ! T A be a finite, thread-independent strategy satisfying the visibility condition.
Then there is a strategy AE : var[N] ! T A such that AEis innocent, has finite view-function, and satisfies

(new x : nat in o/ ) = AE:
(The view-function of an innocent strategy is the functionfrom views to

P-moves together with justification pointerswhich determines the strategy.) The idea behind the proof

of this result is that AE uses a coding of positions as naturalnumbers to record the history of play in its storage cell, so
that it can simulate the history-sensitive strategy o/ whilestill being innocent.

The question of definability of arbitrary finite strategieshas now been reduced to that for innocent strategies with
finite view-function; but this question has been answeredin the affirmative by previous results on full abstraction for
functional languages [7,8,12,20], so we have the following.
Theorem 7 Every finite morphism oe : 1 ! T A in themodel of

L is definable.

Proof The above factorization results mean that oe can bewritten in the form

new x1; : : : ; xk : unit ! unit in new x : nat in AE
for some innocent strategy AE with finite view function. Thedefinability results for innocent strategies imply that

AE =
[[M ]] for some term M , essentially a pure PCF term. (Ouridentification of

var[A] with (A ! unit) \Theta  (unit ! A),and the
mkvar construct, are vital here.) Hence oe is defin-able by

(*x1; : : : ; xk : var[unit ! unit]:*x : var[N]:M)

newunit!unit \Delta  \Delta  \Delta  newunit!unit newN: \Lambda 

Given this result, we can now construct a fully abstractmodel of

L as follows. Define a preorder 4 on each hom-setof
Fam(C) as follows: f 4 g : A ! B iff

8ff : A ) B ! T 1:`f ' ; ff 6= ? ) `g' ; ff 6= ?;
where `f ' : 1 ! (A ) B) is obtained from f by currying.This preorder induces an equivalence relation on each homset in the usual way, and taking equivalence classes of mapsyields another category

Fam(C)= 4. This category inher-its all the relevant structure from

Fam(C) and is thereforeanother sound model of
L. The above definability resultimplies that this model is fully abstract.

Theorem 8 (Full abstraction) The model of L in
Fam(C)= 4 is fully abstract.

Proof We just need to show completeness, and in fact weprove the contrapositive. Suppose

M and N are two (wlogclosed) terms of type
A such that [[M ]] 6= [[N ]]. There mustexist a strategy
ff : (1 ) T A) ! T 1 such that (wlog)`
[[M ]]' ; ff = ? and `[[N ]]' ; ff 6= ?. The map ff can betaken to be a finite strategy, and the definability result implies that ff = [[x : 1 ! A ` C[x]]] for some term C[x].Also, `

[[M ]]' = [[*d:M ]] ; j where d is a dummy variable;and similarly for

N . It follows that [[C[*d:M ]]] = ? and
[[C[*d:N ]]] 6= ?, so by computational adequacy, C[*d:N ]+but not

C[*d:M]+. \Lambda 

References

[1] S. Abramsky, R. Jagadeesan, and P. Malacaria. Full abstraction for PCF. Accepted for publication in Information and
Computation, 1997.[2] S. Abramsky and G. McCusker. Games and full abstraction

for the lazy *-calculus. In Proceedings, Tenth Annual IEEE
Symposium on Logic in Computer Science, pages 234-243.
IEEE Computer Society Press, 1995.[3] S. Abramsky and G. McCusker. Call-by-value games. In

Proceedings of CSL '97, Lecture Notes in Computer Science. Springer-Verlag, 1997. To appear.[4] S. Abramsky and G. McCusker. Linearity, sharing and state:

a fully abstract game semantics for Idealized Algol with
active expressions. In P. W. O'Hearn and R. D. Tennent,
editors, Algol-like Languages, pages 297-329 of volume 2.
Birkha"user, 1997.[5] S. Abramsky and G. McCusker. Full abstraction for Idealized Algol with passive expressions. To appear in Theoretical Computer Science, 1998.[6] M. P. Fiore, E. Moggi, and D. Sangiorgi. A fully-abstract

model for the ss-calculus (extended abstract). In Proceedings, Eleventh Annual IEEE Symposium on Logic in Computer Science [9], pages 43-54.[7] K. Honda and N. Yoshida. Game theoretic analysis of

call-by-value computation. In P. Degano, R. Gorrieri, and
A. Marchietti-Spaccamela, editors, Proceedings, 25th International Colloquium on Automata, Languages and Programming: ICALP '97, volume 1256 of Lecture Notes in
Computer Science, pages 225-236. Springer-Verlag, 1997.

11

[8] J. M. E. Hyland and C.-H. L. Ong. On full abstraction for

PCF: I, II and III. Accepted for publication in Information
and Computation, 1997.[9] IEEE Computer Society Press. Proceedings, Eleventh Annual IEEE Symposium on Logic in Computer Science, 1996.[10] B. Jacobs. Semantics of weakening and contraction. Annals
of Pure and Applied Logic, 69:73-106, 1994.[11] J. Laird. Full abstraction for functional languages with control. In Proceedings, Twelfth Annual IEEE Symposium on
Logic in Computer Science, pages 58-67. IEEE Computer
Society Press, 1997.[12] G. McCusker. Games and Full Abstraction for a Functional

Metalanguage with Recursive Types. PhD thesis, Department of Computing, Imperial College, University of London, 1996.[13] G. McCusker. Games and full abstraction for FPC. In Proceedings, Eleventh Annual IEEE Symposium on Logic in
Computer Science [9], pages 174-183.[14] G. McCusker. Games and definability for FPC. Bulletin of

Symbolic Logic, 3(3):347-362, Sept. 1997.[15] R. Milne and C. Strachey. A Theory of Programming Language Semantics. Chapman and Hall, London, 1976.[16] R. Milner. Communication and Concurrency. Prentice Hall,
1989.[17] R. Milner, J. Parrow, and D. Walker. A calculus of mobile
processes (Parts I and II). Information and Computation,
100:1-77, 1992.[18] R. Milner, M. Tofte, and R. W. Harper. The Definition of

Standard ML. MIT Press, Cambridge, Massachusetts, 1990.[19] E. Moggi. Notions of computation and monads. Information
and Computation, 93:55-92, 1991.[20] H. Nickau. Hereditarily sequential functionals. In Proceedings of the Symposium on Logical Foundations of Computer
Science: Logic at St. Petersburg, Lecture notes in Computer
Science. Springer, 1994.[21] P. W. O'Hearn and R. D. Tennent. Semantics of local variables. In M. P. Fourman, P. T. Johnstone, and A. M. Pitts, editors, Applications of Categories in Computer Science: Proceedings of the LMS Symposium, Durham, 1991. Cambridge
University Press, 1992. LMS Lecture Notes Series, 177.[22] J. C. Reynolds. Syntactic control of interference. In Conf.

Record 5th ACM Symposium on Principles of Programming
Languages, pages 39-46, 1978.[23] J. C. Reynolds. The essence of Algol. In Proceedings of the

1981 International Symposium on Algorithmic Languages,
pages 345-372. North-Holland, 1981.[24] I. Stark. A fully abstract domain model for the

ss-calculus.
In Proceedings, Eleventh Annual IEEE Symposium on Logic
in Computer Science [9], pages 36-42.[25] J. E. Stoy. Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory, volume 1 of The
MIT Press Series in Computer Science. The MIT Press,
1977.

12