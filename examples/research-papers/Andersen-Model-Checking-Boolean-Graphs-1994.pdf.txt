

Theoretical  Computer  Science  126  (1994)  3-30 

Elsevier 

Model  checking  and  boolean 
graphs* 

Henrik  Reif  Andersen 
Department  qf Computer Science,  Building 344,  Technical University qf Denmark.  DK-2800  Lvnaby, 
Denmark 

Abstract 

Andersen,  H.R.,  Model  checking  and  boolean  graphs,  Theoretical  Computer  Science  126  (1994) 
3-30. 

We  describe  a  method  for  translating  a  satisfaction  problem  of  the  modal  p-calculus  into  a  problem 

of  finding  a  certain  marking  of  a  boolean  graph.  By  giving  algorithms  to  solve  the  graph  problem, 
we  present  a  global  model  checking  algorithm  for  a  subset  of  the  modal  p-calculus,  which 
has  time-complexity  0(  1 A 11 T I), w h ere  1 Al  is  the  size  of  the  assertion  and  17'1 is  the  size  of  the 
model  (a  labelled  transition  system).  This  algorithm  is  extended  to  an  algorithm  for  the  full 
modal  l-calculus  running  in  time  0(  I A I"`/ S Indm ' I Tl),  where  ad  is  the  alternation  depth 
and  I .S  is  the  number  of  states  in  the  transition  system,  improving  on  earlier  presented  algorithms. 

Moreover,  a  local  algorithm  is  presented  for  alternation  depth  one.  This  algorithm  runs  in  time 
0(  I A ) I TI log(  / A 11 TI)) and  is  also  an  improvement  over  earlier  algorithms. 

1.  Introduction 

Model  checking  is  the  problem  of  deciding  whether  a  given  structure  constitutes 
a  valid  model  for  a  logical  assertion.  Viewing  the  structure  as  describing  a  system  of, 
for  example,  interacting  processes  and  the  logical  assertion  as  a  specification,  model 

checking  can  be  viewed  as  the  process  of verifying  that  a  system  meets  its  specification. 
We  will  use  a  generalization  of  the  modal  p-calculus  presented  by  Kozen  [lS]  as 
the  assertion  language  and  as  models  we  take  labelled  transition  systems  (essentially 

Correspondence  to:  H.R.  Andersen,  Department  of  Computer  Science,  Building  344,  Technical  University 
of  Denmark,  DK-2800  Lyngby,  Denmark.  Email:  hra@id.dth.dk. 

*This  work  is  supported  by  the  Danish  Natural  Science  Research  Council  and  the  Danish  Research 
Academy.  An  extended  abstract  with  the  same  title  appeared  in  Proc.  of  4th  European  Symp.  on 

Programming,  ESOP'92,  B.  Krieg-Briickner,  ed.,  Lecture  Notes  in  Computer  Science,  Vol.  582  (Springer, 

Berlin,  1992).  The  main  part  of  this  work  was  carried  out  at  the  Computer  Science  Department,  Aarhus 
University  and  while  visiting  the  Computer  Laboratory,  University  of  Cambridge. 

0304-3975/94/$07.00  c  1994-Elsevier  Science  B.V.  All  rights  reserved 

SSDI  0304-3975(93)E0121-J 

4  H.R.  Andersen 
equivalent  to  labelled  Kripke  models).  The  modal  ~-calculus  is  a  very  expressive 

modal  logic  (see,  e.g.  [ 15,  14,  121)  allowing  a  wide  range  of  properties  to  be  expressed, 
including  what  is  often  called  liveness,  safety  and  fairness  properties.  Examples  of such 
expressible  properties  are  "eventually  an  a-action  will  happen",  "it  is  always  possible 

to  do  a  b-action"  and  "infinitely  often  a  c-action  can  happen".  Labelled  transition 
systems  arise  naturally  in,  for  example,  the  operational  semantics  of  process  algebras 
as  describing  the  behaviour  of  communicating  concurrent  systems. 

This  paper  presents  four  results.  First,  it  shows  that  the  problem  of finding  the  set  of 
states  in  a  finite  labelled  transition  system  satisfying  a  given  formula  with  just  one 
fixed-point  operator,  can  be  reduced  to  the  problem  of  finding  a  fixed  point  of 
a  monotone  function  on  a  boolean  lattice  consisting  of  a  product  of  simple  two-point 
lattices.  Secondly,  it  is  shown  how  this  fixed  point  can  be  found  in  linear  time  using 

a  simple  graph  algorithm,  thereby  giving  an  0(  / A ) 1 T I) model  checking  algorithm. 
Thirdly,  this  algorithm  will  be  extended  to  the  full  calculus,  giving  an  algorithm 

running  in  time  0(  1 A Iad I S Iad- ' I T I), ad being  the  alternation  depth  of  A  -  a  measure 
of  how  intertwined  minimum  and  maximum  fixed  points  are.  Finally,  a  local  algo- 
rithm,  searching  potentially  only  a  part  of  the  transition  system,  will  be  presented  for 
the  modal  ,u-calculus  of  alternation  depth  one.  This  algorithm  will  run  in  time 

0(  I A I I TI  hid I A I I T  I )I 

Previous  work  can  be  found  in  Emerson  and  Lei  [14]  which  describes  a  global 

0((  ( A ) ) Tly'+`)  algorithm  and  defines  the  notion  of alternation  depth,  and  in  Arnold 
and  Crubille  [6]  which  describes  a  global  0(  I A 1' I T I) algorithm  for  the  case  of  one 
simultaneous  fixed  point.  Independently,  Cleaveland  and  Steffen  [lo]  and  Vergauwen 
and  Lewi  [23]  discovered  a  global  algorithm  for  alternation  depth  one  running  in 

time  0(  I A I ( T I), which,  apart  from  differences  in  way  of  presentation,  is  very  similar 
to  the  global  algorithm  presented  in  this  paper. 

Local  algorithms  have  been  described  by  Larsen  [16],  Stirling  and  Walker  [21], 
Cleaveland  [S]  and  Winskel  [24],  but  they  all  have  at  least  exponential  running  time 
-  even  for  alternation  depth  one.  Larsen  [17]  has  recently  improved  his  local 

algorithm  (for  one  fixed  point)  to  run  in  polynomial  time.  However,  it  is  still  not  as 
efficient  as  the  algorithm  presented  in  this  paper. 

The  local  as  well  as  the  global  algorithm  will  be  given  in  an  Algol-like  imperative 
language.  We  use  an  imperative  language  because  complexity  of operations  in  impera- 

tive  languages  are  well-understood,  which  makes  complexity  arguments  simpler  and 
more  convincing.  For  the  same  reason  the  level  of  detail  is  very  high  compared  to  the 

previously  mentioned  papers  on  local  model  checkers  (which  do  not  contain  complex- 
ity  analyses). 

2.  Logic  and  models 

We  will  consider  a  version  of  the  modal  p-calculus  with  simultaneous  fixed  points. 
The  expressive  power  will  be  equivalent  to  the  modal  p-calculus  with  just  unary  fixed 

Model  checking  and  boolean  graphs  5 
points,  in  the  sense  that  every  assertion  in  our  calculus  has  a  logical  equivalent 
containing  only  unary  fixed  points.  The  simultaneous  fixed  points  will,  however,  be 

central  to  the  development  of efficient  model  checking  algorithms  as  they  allow  one  to 
express  sharing  of  subexpressions. 

The  version  of  the  modal  p-calculus  we  will  use  is  given  by  the  following  grammar: 

The  assertion  variable  X  ranges  over  a  set  of  variables  Var. The  usual  notions  of  free 
variables  and  open  and  closed  assertions  will  be  used.  The  notation  X  is  shorthand  for 

(X r,  . . ..X.),  4  for  (AI,...,  A,),  where  n  should  be  clear  from  context.  The  assertion 
(~~.A)i  will  denote  the  ith  component  of  the  simultaneous  minimum  fixed  point 

,@.A.  Dually,  (vX..4)i  denotes  the  ith  component  of  the  maximum  fixed  point  v&.4. 

The  usual  unary  fixed  point  ,uX.A  corresponds  to  the  case  where  n = 1,  and  for 
notational  convenience  we  simply  write  pX.A  instead  of  (pX.A)r  . 

As  models,  we  take  labelled transition  systems  T=  (S, L,  -+), where  S is a  set  of states, 
L  a  set  of  labels,  and  +  ES  x  L  x S  a  transition  relation.  We  write  (s, c(, S')E +  as 
s 5  s'. Given  a  transition  system  T,  an  assertion  A  will  denote  a  subset  of  the  states 
S  of  T. Recall  that  the  set  of  subsets  ordered  by  inclusion  (P(S),  c)  forms  a  complete 
lattice,  which,  by  taking  pointwise  ordering,  extends  to  a  complete  lattice  (P(S)",  s") 
on  the  n-ary  product  of 9(S).  Let  Zi : P(S)  -+  P(S)  denote  the  projection  onto  the  ith 
component. 

For  the  fixed  points,  recall  that  a  map  $  on  P(S)n  is  monotonic  if, for  all  g  s"  _V, we 
have  $(u)  E'  $(_V).  According  to  Tarski's  theorem  [22],  any  monotonic  $  will  have 
a  minimum  prefixed  point  given  by 

which  we  denote  &.  Similarly,  II/ will  have  a  maximum  postfixed  point  vll/ given  by 

Due  to  the  possibility  of  free  variables,  the  interpretation  of  assertions  will  be  given 
relative  to  an  environment  p  assigning  a  subset  of  S  to  each  variable.  We  will  use 
p[g/X]  to  denote  the  environment  which  is  like  p  except  that  Xi  is  mapped  to  CTi. 

The  interpretation  of  A  denoted  [Al  TV is  defined  inductively  on  the  structure  of  A  as 
follows: 

H.R.  Andersen 
C(PLx.ii)ilTP=71i(P$)>  where  $:W,,  . . . .  Un)++([AlljTp',  . . . .  [4JTp'), 

and  P'=PUJ~IX,,  . . . . U,lX,l, 

[(vX.ii)inTp=ni(v~),  where  I// is  as  above. 
Given  a  transition  system  T=(S,  L,  -+),  we  will  say  that  a  state  SES  satis$ies  the 
assertion  A  if  s~[A],p  for  all  environments  p  and  write  s I= TA. 

For  the  rest  of  this  section,  we  will  concentrate  on  unnested  fixed  points  and  finite 
transition  systems,  and  we  will  describe  how  to  transform  the  problem  of  satisfaction 
into  a  problem  of finding  a  marking  of  a  particular  kind  of graph.  The  transformation 
proceeds  in  two  steps:  First  the  unnested  fixed  point  is  transformed  into  an  equivalent 
simple  fixed  point.  Secondly,  this  fixed  point  is  transformed  into  a  modality-free  fixed 
point  from  which  we  eventually  construct  a  boolean  graph. 

We  will  say  that  @.A  is  an  unnested$xed-point  assertion  if no  fixed  points  appear 
in  the  body  4.  Furthermore,  we  will  say  that  an  unnested  fixed  point  @.  4  is  simple  if 
each  of  the  components  Aj  of  4  contains  at  most  one  operator,  i.e.  Aj  is  of  one  of  the 
forms 

F,  T,  Xj,  V  Xj,,  Xj,  A Xj,,  (C()Xj',  [E]Xj',  Xjs. 
Any  unary,  unnested  fixed-point  assertion  pX.  A  can  be  translated  into  an  equiva- 
lent  simultaneous,  simple  fixed-point  assertion,  with  n  variables,  where  n =  1 A I is  the 

size  of  A,  measured  as  the  number  of  operators  and  variables.  The  translation 
proceeds  as  follows:  To  each  subexpression,  we  associate  a  variable.  This  gives 
n  variables  {XI,  . . . . X,}.  Define  the  n-ary  fixed  point  @.A  by 

Ai =  the  expression  associated  with  Xi  where  all  proper  subexpressions  are 

replaced  by  their  associated  variables  and  X  is  replaced  by  X1, 

assuming  that  X1  is  associated  with  A.  Using  Bekic's  theorem  [7]  relating  simultan- 
eous  and  unary  fixed  points,  one  can  now  show  the  following  proposition. 

Proposition  2.1.  Let  pX.  A  be  a  closed,  unary,  unnestedjxed  point  and  let  @.  4  be  the 

translated  simple  $xed  point.  Then 

for  all  environments  p. 

Model  checking  and  boolean  graphs  I 
As  an  example  PX.  [x]  X  A  (8)  T  will  give  rise  to  the  4-ary  simple  fixed  point 

Xl  x2  A  x3 

x2  [@IX1 
P  x3  . Iii  I (8)X4  . 

x4  T 

The  translation  and  Proposition  2.1  generalises  easily  to  unnested  fixed  points  of 
arbitrary  arity.  The  number  of  variables  of  the  resulting  simple  fixed  point  will  still  be 
equal  to  the  size  of  the  original  fixed-point  assertion. 

We  now  proceed  to  the  second  part  of  the  translation.  Given  a  transition  system 
T  and  an  assertion  A,  we  will,  for  each  state  s,  describe  a  method  of  finding  an 
assertion  A/s  without  modalities,  which  intuitively  (when  ignoring  variables)  has  the 
property  that  s I= r  A  if and  only  if  A/s  denotes  true.  1 In  order  to  state  this  formally, 

we  will  interpret  assertions  without  modalities  -  assertions  built  from  the  proposi- 
tional  fragment  of  our  calculus  ~  over  the  trivial  one-state  transition  system 

8  H.R.  Andersen 
p : Var  -+ 9(S)  and  p' :  Vur  --t  0,  and 

for  all  variables  X  with  0(X)=(  Yr, . ..,  Y,).  For  two  such  appropriate  environments, 

assume  inductively  that  we  have  found  modality-free  assertions  A/si  corresponding  to 
A  such  that 

*  0 in =  in 0 0, 
where  $(U)=[A~rp[U/X]  and 

OUJI, ".,  U") 

=(u4sln.P'CUl/yl~  ".,  Un/Ynl,  .  ..~uAIhln. P'CU1IY1~ ...2  UnIYnl). 
As  in  is  an  isomorphism  of  lattices,  we  immediately  get  that  p$=in(pO).  (Alternat- 
ively,  the  reduction  lemma  from  [S]  could  be  applied.)  Hence, 

where  4  =  (A/s,,  .  . , A/s,),  and  we  have  found  modality-free  assertions  corresponding 
to  /LX.A. 

We  are  now  able  to  state  the  full  definition  of  A/s.  Define  for  each  state  s,  the 
quotient  A/s  by  structural  induction  on  A  as  follows: 

F/s  = F, 

T/s  =  T, 
(4  v A,)/s=(&/s)  v (AI/S)> 
(A., A  A,Us=(A,/4  A (AI/S), 
([cl]A)/s=~{A/s'Is&`}, 
((GI)A)/s=V(A/S'/S~S'}, 

X/s=  Yi,  where  s=si,  0(X)=(  Yt,  . . . . Y,,). 
For  the  k-ary  fixed-point  ,uX .d,  assume  that  we  have  a  change  of  variables  o  with 
a(Xj)=(Y',  . ..)  Yj),  and  let  the  nk-ary  fixed  point  pY.  B  Y=  ( Yrr,  .  , Y/,  .  , Y,"), -  -3  _ 
&I =  (B :,  .  , B/,  .  , Bi)  be  defined  by 

B{=  Aj/si, 
where  ldi<n,  l<j<k.  Take 

Model  checking  and  boolean  graphs  9 
and  similarly  for  the  maximum  fixed  point.  2 Now,  we  have  the  following  theorem. 
Theorem  2.2  (Quotienting  theorem).  For  an  arbitrary  assertion  A,  change  of  variables 

o  and  appropriate  pair  of  environments  (p,  p'),  we  have 

ITAITp=in(UAlslll.p',  . . . . 1IAls,,l.~`). 
The  original  problem  of  deciding  whether  a  particular  state  s  satisfies  the  closed 
assertion  A  can  now  be  recast  by  applying  the  quotienting  theorem: 

s~=~A  iff  sEIAJTpfor  allp 

iff  sEin([A/sll.p',  . . ..[Als.lj.p') 
iff  [A/s],p'=  1, 
where  (p,  p')  is  appropriate  for  CJ and  in.  In  other  words,  model  checking  can  be 
reduced  to  deciding  whether  the  assertion  A/s  denotes  the  top  element  of  0.  An 
important  point  about  the  quotienting  is  that  the  resulting  assertion  consists  entirely 

of disjunctions,  conjunctions,  variables  and  fixed-point  operators  (viewing  F  and  T  as 
empty  disjunctions  and  conjunctions).  In  particular,  for  an  unnested  k-ary  fixed-point 
@.A,  we  end  up  with  an  unnested  fixed  point  pY.@  in  the  lattice  Oklsl.  Moreover,  if 
,@.A  is  simple  (hence,  k =  I A I),  the  total  size  of  p Y.B  will  be  bounded  by  1 A  11 T/, 
where  1 T  I =  I S I +  I L  I +  I +  1, as  simple  calculations  show: 

lBl=CF,  c;=r  IBjl 

=~~=,~~l  IAi/sjJ 

<c;zl  ITI=klTI=IAIITI. 
If  @.A  is  not  simple,  this  bound  would  not  hold.  As  an  example  consider  the 
assertion  pX.(cc)  [cl]  . . . (CC) [cr]X  (I  modalities),  and  assume  that  T  is  a  transition 
system  with  n  states,  all  connected  to  each  other  by  a-transitions.  Then  the  size  of 
a  single  right-hand  side  of  the  resulting  assertion  will  be: 

I <a > Cal .  ( cf > [@I x/sj  I = I V A  . . . A  V  xi,  I = n*, il  iz  it-1  il 
where  all  indices  range  over  all  states.  The  significance  of  making  the  fixed  points 
simple  is that  values  of subexpressions  are  shared  across  the  disjunctions  and  conjunc- 
tions.  In  this  example,  we  will  get  a  resulting  assertion  of  size  ln2  -  and  not  n'. 

In  the  analysis  of  time  and  space  complexities  we  will  make  use  of  some  general 
assumptions  about  the  representations  of  assertions  and  transition  systems.  First, 

z We  use  double  indexing  as  a  convenient  shorthand  although  the  syntax  formally  only  allows  simple 
indexing. 

10  H.R.  Andersen 
variables  will  be  assumed  to  be  represented  by  natural  numbers,  which  in  turn  will  be 
assumed  to  be  representable  in  a  constant  amount  of  memory.3  Secondly,  functions 
from  an  interval  of  the  natural  numbers  to  a  set  of  "simple"  values,  e.g.  numbers,  will 

be  represented  efficiently  such  that  access  to  the  value  at  one  particular  element  in  the 
domain  can  be  performed  in  constant  time  (like  "arrays"  in  many  programming 
languages).  Thirdly,  the  transition  relations  are  represented  as  functions  from  the  set 

of states  (assumed  to  be  an  interval  of natural  numbers)  into  sets  of  pairs  consisting  of 
a  label  and  a  state.  Labels  are  also  assumed  to  be  represented  in  a  constant  amount  of 
memory. 

Often,  we  will  use  statements  like,  this  algorithm  runs  "in  time  and  space  K(n)", 
where  it  actually  should  be  "in  time  and  space  asymptotically  bounded  by  K(n)".  We 
will  also  use  the  notation  O(K(n))  for  this  statement.  All  these  assumptions  and  slight 
abuses  of  language  are  standard  when  analysing  complexities  of  algorithms. 

With  these  assumptions,  it  is  easy  to  see  that  the  translations  into  simple  fixed 
points  and  boolean  graphs  can  be  performed  in  time  and  space  0(  1 A 11 T I). 

3.  Boolean  graphs 

In  Section  2, we  described  how  to  transform  an  unnested  fixed  point  @`C .A  (of  arity 
1  or  more)  into  first  a  simple  k-ary  fixed-point  PX  .A  and  then,  given  a  transition -  - 
system  with  n  states,  into  an  nk-ary  fixed-point  p Y. B  consisting  of  only  conjunctions 
and  disjunctions.  By  these  transformations,  we  have  reduced  the  problem  of  finding 
a  fixed  point  over  the  lattice  P(S)  to  a  problem  of  finding  a  fixed  point  of  a  boolean 
function  over  the  lattice  Oflk.  Viewing  the  variables  as  vertices  of  a  graph  and  the 
dependencies  between  variables  as  directed  edges,  pY.B  defines  a  directed  boolean 
graph,  which  essentially  is  nothing  else  but  another  representation  of  the  function  of 

Y defined  by  @. 

Formally,  a  boolean  graph  G  is  a  triple  (V,  E,  L)  where  V  is  a  set  of  vertices, 
E  E  Vx  V a  set  of  directed  edges,  and  L:  I/+  {  v  ,  A )  is  a  total  function  labelling  the 
vertices  as  disjunctive  or  conjunctive.  The  set  S(u)  of  successors  and  the  set  P(v)  of 
predecessors  of  a  vertex  v are  defined  by  S(v)=  {w / (u, w)EE}  and  P(v)  =  {w 1 (w, u)EE}. 

Given  a  simple  k-ary  fixed  point  ,u Y. B consisting  of disjunctions  and  conjunctions,  we 
can  define  a  graph  GB=(  V, E,  L)  where 

E={(Yi,  Yj)I(Bi=V  Yl or  Bi=~  Yl)&jel}, la1  I.51 
3 As  usual  in  complexity  analysis  we  make  the  assumptions  that  integers  can  be  stored  in  a  constant 
amount  of  memory  and  that  an  arbitrary  memory  address  can  be  accessed  in  constant  time,  the  "uniform 
cost  criterion",  cf.  Aho  et  al.  [l]. 

Model  checking  and  boolean  graphs  11 I 
v  if &=A  Y,, 
L( Yi)=  ICI 

A  ifBi=VYl. lel 

Note  that  there  is  an  edge  from  i  to  j  iff  Yj  is  one  of  the  disjuncts/conjuncts  in  Bi, 
expressing  the  fact  that  the  value  of  Yi "depends"  on  the  value  of  Yj. 

A  marking  of  a  boolean  graph  G is  a  function  m : V +  0  assigning  values  0  and  1 to 
the  vertices.  The  graph  G  induces  a  function  g  taking  a  marking  m  to  a  new  marking 
g(m)  which  is  "what  can  be  computed  from  m",  i.e.  for  a  marking  m  define  the  marking 

g(m)  as  I 

1  if  L(u)=  A  &  QwES(u).m(w)=l 
s(m)(u)  =  or  L(u)=  v  &  3wES(v).m(w)=  1, 0  otherwise. 

When  G  is  constructed  from  a  fixed  point  pY.B,  the  function  g  is  exactly  the _  - 
function  defined  by  the  body  of  the  fixed  point  pY.B,  and  m  is  nothing  else  but  an 
element  of  CD"; but  thinking  of m  as  a  marking  will  be  helpful  in  the  development  of the 

algorithms.  As  the  set  of  markings  0"  is  just  an  isomorphic  copy  of  O",  0"  will  be 
a  complete  lattice  when  equipped  with  the  same  ordering  as  CD", i.e.  the  pointwise 
extension  of  the  Sierpinski  ordering.  The  problem  we  have  to  solve  now  is:  Given 
a  boolean  graph  G  defining  the  monotonic  map  g : 0"  +  CD", what  is  the  minimum 

prefixed  point  PgE CD `? 

4.  Algorithms 

In  this  section,  we  will  describe  two  algorithms  for  computing  the  minimum  fixed 
point  of  a  boolean  graph.  The  first  will  be  global  in  the  sense  that  it  computes 

the  complete  fixed  point  of  the  graph,  and,  on  a  graph  G,  it  will  have  time  and 
space  complexity  0(  1 G I).  If  G  is  constructed  from  an  unnested  fixed-point  formula 
pX.A  and  a  transition  system  T  as  described  in  the  previous  section,  the  size  of  G 

will  be  0(  ( A 11 T  I); hence,  we  have  a global  model  checking  algorithm  that  in  the  worst 
case  is  linear  in  the  size  of  the  assertion  and  linear  in  the  size  of  the  transition  system. 

The  second  will  be  local,  in  the  sense  that  starting  from  a  particular  node  x,  it  will 
only  compute  an  approximation  to  the  fixed  point,  and  in  doing  so  traverse  only 

a  necessary  subset  of  the  graph.  The  approximation  will  be  correct  on  x  and  on  all 
nodes  visited.  This  algorithm  will  have,  on  a  graph  G,  worst-case  space  complexity 
0(  I G I) and  worst-case  time  complexity  O(G  / log  / G I). 

Both  algorithms  will  be  presented  in  the  version  for  finding  minimum  fixed  points, 
the  case  of  maximum  fixed  points  being  completely  dual. 

12  H.R.  Andersen 
4.1.  A  global  algorithm 

The  global  algorithm  will  start  with  the  bottom  element  of  the  lattice  0"  and 
gradually  increase  it  until  (eventually)  the  minimum  fixed  point  is  reached.  Pictorially, 
one  can  think  of  the  algorithm  as  "chasing  ones"  around  the  graph:  Starting  with 
nodes  that  are  trivially  forced  to  be  one  (conjunctive  nodes  with  no  successors),  it  will 
look  for  dependent  nodes  that  are  forced  to  be  one,  continuing  until  no  further  nodes 
can  be  forced  to  one  -  thereby  having  found  the  minimum  fixed  point. 

Figure  1  describes  the  algorithm.  The  function  st : V +  Z,  where  Z  is  the  set  of 
integers,  denotes  the  "strength"  of  a  node,  i.e.  the  number  of  successors  that  must  be 

one  before  this  node  will  be  forced  to  be  one.  The  function  g  induced  by  G  can  be 
"extended"  to  a  function  on  strengths  by  taking,  for  all  UE I', 

ij(st)(v)  =  { lS(z;)f~st,~l  if L(u)  =  A, 1-_lS(u)nst,,j  ifL(u)=  v, 
where  st ,0  = (u 1 st(u)  > 0},  i.e.  th e  set  of  nodes  which  still  needs  some  successors  to 
become  one,  and  stGo = {u 1 st(u)  GO>,  i.e.  th e  set  of  nodes  which  have  enough  suc- 
cessors  that  are  one  (the  negative  value  indicates  the  "excess"  of  ones).  A  strength 
defines  a  marking  s^ by 

5?(u)=  i  1  if st(u)<O, 0  if st(u)>O. 
It  is  now  easy  to  see  that  (")  0 S =  g 0 (h ); hence,  if g(st) = st then  g(3)  =  2,  implying  that 
s?  is  a  fixed  point  of  g. 

The  set  A  denotes  an  "active"  set  of  nodes  marked  with  ones,  for  which  the 
consequences  of  becoming  one  has  not  yet  been  computed.  Correctness  can  be  shown 

Input:  Boolean  graph  G =  ( V, E,  L),  defining  the  function  g. 

Output:  A  marking  m : V -+  { 0,  l}  equal  to  pg. 

for  all  VE V do  st(u)  :=  1 S(u) I  if  L(v) =  A 1  if  L(u)=  v 

A:=stSO 
while  A #@  do 

choose  some  UEA;  A  := A\(v) 
for  all  w~P(u)  do 

st(w)  :=st(w)-  1 
if  st(w)=O  then  A  := Au  {wj 
m:=sZ 

Fig.  1.  A  global  algorithm:  Chasing  1's. 

Model  checking  and  boolean  graphs  13 
from  the  invariant  I: 

lW)n(st>ouA)I  if L(u)=  A 

l-IS(u)n(st,,,\A)l  ifL(u)=  v. 

Theorem  4.1.  The  algorithm  of  Fig.  1 correctly  computes  the  minimumjxed  point  pg 
and  it  can  be  implemented  to  run  in  time  0(  1 Cl). 

Proof.  It  is a  simple  exercise  to  show  that  the  invariant  I  holds  immediately  before  the 
while-loop,  and  that  it  is  preserved  by  the  body.  When  the  while-loop  terminates  we 
have  A = 0 which  from  the  invariant  implies  that  st = j(st)  and  s? is  a fixed  point,  which 
by  the  second  conjunct  of  the  invariant  is  less  than  or  equal  to  the  minimum  fixed 

point;  hence,  s^ =  pg. 

For  the  time  complexity,  first  note  that  whenever  a node  has  been  removed  from  the 
set  A, it  will  never  be  inserted  again  as  this  only  happens  when  its  strength  equals  zero, 
and  strengths  always  decrease.  Hence,  the  body  of  the  while-loop  will  be  executed  at 
most  once  for  each  node  u of  the  graph.  Each  execution  of  the  innermost  for-all-loop 
takes  time  proportional  to  the  size  of P(v),  i.e.  the  number  of predecessors  for  the  node 

u.  In  total,  the  while-loop  takes  time  proportional  to  the  sum  of  the  number  of 
predecessors,  i.e.  the  total  number  of edges  in  G,  and  is  thus  bounded  by  1 G 1. The  first 
loop  and  the  last  assignment  are  also  bounded  by  I G I. 

As  the  algorithm  looks  at  predecessors  of  nodes,  the  graph  must  initially  be 
reversed,  which  can  easily  be  done  in  linear  time  (see,  e.g.  [l  11).  0 

4.2.  A  local  algorithm 

Model  checking  is  usually  involved  with  deciding  satisfaction  for  just  one  particular 
state,  so  it  might  seem  overwhelming  to  have  to  compute  the  complete  fixed  point  in 
order  to  decide  the  value  at  just  one  particular  state.  This  observation  is  central  to  the 
development  of  local  model  checkers  with  the  idea  being  that  starting  from  one 
particular  state,  only  a  "necessary"  part  of  the  transition  system  will  be  investigated  in 

order  to  determine  satisfaction.  Larsen  [16]  describes  such  an  algorithm  for  the  case 
of  one  fixed  point,  which  in  an  improved  version  is  used  in  the  TAV  system  [lS]. 

Stirling  and  Walker  [21]  and  Cleaveland  [S]  describe  a  similar  method  for  the  full 
modal  p-calculus  based  on  tableaux,  which  has  been  used  in  the  implementation  of the 
Concurrency  Workbench  [9].  Using  a  single  key-property  of  maximum  fixed  points, 
Winskel,  in  [24],  develops  a  very  similar  and  quite  simple  model  checker.  Unfortu- 
nately,  they  all  have  very  bad  worst-case  behaviours.  Even  for  formulas  with  one  fixed 
point,  they  have  worst-case  time  complexity  at  least  exponential  in  the  number  of 
transitions. 

Model  checking  and  boolean  graphs  15 
visit(x)  = 
if  x$B  then 

B:=Bu{x} 
if  L(x)=  v  then 

ok :=false 
while  p(x)  <  1 S(x)  1 &  -I  ok do 

w := Wp(nJ fat(w) 

if  m(w)=0  then  d(w)  :=d(w)u(x}  p(x):=p(x)+  1 
IT m(w) =  1 then  ok := true 

fi 
if  ok  then  m(x)  :=  1  A  :=  A u  {x} 
R L(x)=  A  then 

fwM-4 fi 

Fig.  3.  Visit. 

fwtn(x) = 

ok :=false 

while  p(x)  <  I S(x)  1 &  1  ok do 

w := W,~,, 
visit(w) 
if  m(w) =  0  then  d(w) := d(w) u  {x}  ok := true 
ff m(w) =  1 then  p(x)  := p(x)  +  1 
fi 
if 1  ok  then  m(x)  :=  1 A := A u  {x} 

Fig.  4.  Fwtn:  "find  a  witness". 

inspected.  For  this  purpose,  we  assume  that  the  successors  of  each  node  v have  been 

numbered  from  0  to  (1 S(v))  -  l),  i.e.  S(u) =  ( S(&,  . , S(V),,~,,, _ I}.  The  function 
p : V -+ N  is  used  in  order  to  keep  track  of  which  successor  p(o) of  v is  being  examined, 
or  must  be  examined  next. 

Due  to  cycles  in  the  graph,  a  node  that  at  one  point  is found  to  be  marked  with  zero, 
can  later  be  changed  into  being  marked  with  one;  hence,  all  nodes  that  were  assigned 
a  marking  based  on  this  particular  node  being  zero  might  have  to  be  changed  as  well. 

16  H.R.  Andersen 
In  order  to  be  able  to  perform  this  updating  efficiently,  we  keep  for  each  node  u a list  of 
nodes  d(u)  that  should  be  informed  in  case  the  marking  of  u will  change  from  zero  to 
one.  Thus,  for  each  node  u, d : V +  P(V)  will  denote  a  subset  of  its  predecessors  P(u), 
and  this  set  will  grow  as  the  algorithm  proceeds. 

Like  in  the  global  case,  the  set  A  c  V contains  nodes  v that  have  changed  marking 
from  zero  to  one,  and  for  which  this  information  has  not  yet  been  spread  to  the  nodes 
in  d(v).  The  set  B  G  V contains  all  nodes  that  have  been  visited.  The  procedurefwtn 
(short  for  "find  witness")  will  for  a  conjunctive  node  u  search  the  successors  starting 
from  number  p(u)  for  one  with  a zero  marking,  that  "witnesses"  that  u should  have  the 
marking  zero.  If  no  such  exists,  the  node  u  will  have  to  be  marked  with  a  one. 

To  get  a  feeling  for  the  working  of  the  algorithm,  the  reader  is  encouraged  to  try  it 
on  the  small  example  below. 

At  any  point  in  the  execution  of the  algorithm,  the  situation  will  be  as  sketched  in  Fig.  5. 

The  complexity  of  the  algorithm  depends  on  how  B,  m,p  and  d  are  implemented. 
Implementing  B  as  an  V-indexed  array  of  boolean  flags,  and  also  m,p  and  d  as 

V-indexed  arrays,  the  operations  performed  on  these  structures  are  all  constant  time, 
but  the  initialisations  take  time  0(  1 VI).  This  gives  the  following  theorem.  (The  proof 
can  be  found  in  Appendix  A.) 

O'S 

Fig.  5.  A  typical  situation  of  avoiding  1's. 

Model  checking  and  boolean  graphs  17 
Theorem  4.2.  Given  a  boolean  graph  G  with  the  induced  function  g.  The  algorithm 
described  in Figs.  2-4  correcrly  computes  an  element  m of  0"  and  a  set  B  s  V, such  that 

and  it  can  be  implemented  to  run  in  time  0(  1 G I). 

However,  noting  that  m, p  and  d  only  need  to  be  initialised  on  a  node  when  visit  is 
called  the  first  time  at  that  node,  we  can  instead  implement  the  set  B  as  a  balanced 

search  tree  associating  nodes  of  the  graph  to  their  memory  locations,  yielding 
constant  time  initialisation  and  logarithmic  (i.e.  log(  / B I))  execution  time  when  testing 
for  membership  in  B and  performing  insertion  of  new  nodes  into  B.  Hence,  we  assume 

that  each  node  x  is  associated  with  a  memory  address  a,  on  which  the  values  of  m, 
p  and  d  at  x  will  be  stored.  This  memory  address  will  be  allocated  and  m,  p  and 

d  initialised  when  visit  is  first  called  on  x.  Thus,  we  have  the  following  sketch  of  an 
algorithm. 

The  initialisation  is  changed  to: 

B,A:=@ 
The  procedure  visit  is  changed  to: 

visit(x)=if  x$B  then 

allocate  a  new  memory  cell  with  address  a, 
initialise  d  on  x  to  0, 
p  on  x  to  0,  m  on  x  to  0 
insert  the  pair  (x,  a,.)  in  B 
find  S(x)  by  performing  the  division 
if..  . 

. . . as  before,  where  all  accesses  to  m,  d,  etc.  are  through  the 
addresses  stored  in  B . 
fi 

The  procedure  fwtn  will  not  be  changed,  except  that  all  access  to  the  variables 
m,  p,  etc.  will  be  through  their  addresses  stored  in  B.  The  number  of  primitive  steps 
performed  by  this  algorithm  will  be  as  before,  but  we  have  to  take  into  account  the 
logarithmic  factor  coming  from  the  searches  in  B.  Hence,  the  running  time  will  be 
O(IBIlogIBI),  which  in  the  worst  case  is  O(IGIlogIGI). 

It  is  important  to  observe  that  in  order  to  fully  exploit  the  possible  benefits  of  only 
investigating  a  part  of  the  boolean  graph,  the  graph  -  and  therefore  the  transition 
system  -  must  be  constructed  in  a  demand-driven  fashion  from  a  given  assertion  and, 
for  instance,  a  process  algebraic  term. 

18  H.R.  Andersen 
5.  Extensions  to  the  full  modal  p-calculus 

In  this  section,  we  will  describe  how  the  global  algorithm  Chasing  l's  can  be 
extended  to  yield  a  model  checker  for  the  full  modal  p-calculus.  Given  an  algorithm 
~  like  Chasing  l's  -  that  can  find  a  simultaneous  unnested  fixed  point  in  time 

0(  I A 11 T  I),  we  show  that  we  can  compute  the  set  of  states  satisfying  an  arbitrary 
closed  assertion  A  of  alternation  depth  ad(A)  in  time  0(  1 A Ik I S Ikml I T  I),  where 

k =  max  {ad(A),  l}.  (The  reader  is  referred  to  Appendix  B for  the  definition  of  alterna- 
tion  depth.)  As  ( T  I =  ISI  +  I LI  +  I -+ 1, the  resulting  algorithm  will  be  linear  in  the 
number  of  transitions,  although,  when  the  alternation  depth  is  unbounded,  exponen- 
tial  in  the  size  of the  assertion  and  the  number  of states.  When  the  alternation  depth  is 
bounded,  it  will  yield  a  polynomial-time  algorithm  with  a  polynomial  degree  one  less 
than  the  algorithm  of  Emerson  and  Lei  [14]. 

Theorem  5.1.  Assume  given  an  algorithm  that  can  jind  a  simultaneous  unnested  fixed 
point  (pX.  A  and  vX.A)  on  a  transition  system  T  in  rime  0(  I A I I T  I).  There  exists  an 

algorithm  that  will  compute  the  set  of  states  denoted  by  an  assertion  A  in  time 

O(IAlklSlk-lITi)and  space  O(IAlITI),  where  k=max{ad(A),  l}. 

The  algorithm  and  the  proof  can  be  found  in  Appendix  B. 
This  algorithm  only  assumes  the  presence  of  an  efficient  algorithm  for  handling  the 
unnested  case,  and  then  by  applying  this  at  appropriate  places  handles  the  general 
case.  Boolean  graphs  are  not  used,  except  perhaps  in  the  base-case.  Another  attempt 

of  extending  the  global  algorithm  to  the  full  modal  p-calculus,  could  be  through 
a  generalisation  of  the  boolean  graphs.  Assume  that  we  are  interested  in  computing 
the  set  denoted  by  the  assertion  A.  First  simplify  all  fixed  points  appearing  in  A,  then 
perform  the  divison,  and  finally  construct  a  boolean  graph  from  the  resulting  modal- 
ity-free  assertion  where  the  vertices  are  partitioned  into  disjoint  sets  V1,  , V,  -  one 
for  each  fixed  point.  Now,  a  certain  marking  of  this  partitioned  graph,  reflecting  the 

minimum  and  maximum  fixed  points,  would  correspond  to  the  element  representing 
A.  It  is  an  interesting  task  to  investigate  to  what  extent  this  approach  can  lead  to  new 
algorithms. 

However,  an  immediate  application,  which  is  described  here,  is in  the  generalisation 
of  the  local  algorithm  from  one  fixed  point  to  alternation  depth  one. 

The  construction  of  a  partitioned  boolean  graph  proceeds  as  follows.  Let  an 
assertion  A  be  given.  If  the  top-most  operator  is  not  a  minimum  or  maximum 
fixed  point,  change  A  into  pX.  A  for  an  arbitrary  variable  X  (taking  vX.  A  would 

also  do).  Transform  A  into  a  normal  form,  where  consecutive  sequences  of  minimum 
(maximum)  fixed  points  are  replaced  by  one  minimum  (maximum)  fixed  point 
(as  in  the  proof  of  Theorem  5.1  in  Appendix  B).  Simplify  all  fixed  points.  Assume 

that  all  variables  appearing  in  different  fixed  points  of  A  are  different,  other- 
wise,  rename  the  variables  so  that  this  is  the  case.  Perform  the  division  with 
respect  to  a  change  of  variables  0  and  a  labelled  transition  system  T=(S,  L,  -+). 

Model  checking  and  boolean  graphs  19 
Recall,  that  the  top-most  operator  of  A  -  and,  therefore,  of  B  -  is  a  ,u or  a  v. Assume 
that  { Yr,  . . . . Y,,,}  are  the  boolean  variables  in  B  and  let  Bi  be  the  right-hand 

side  corresponding  to  the  variable  Yi.  Define  the  boolean  graph  Gs  =(  V, E,  L)  as 
follows: 

v=  I- 

E= 

Yl, ..`>  ym> 

tyi,  Yj)I(Bi=VM  OrBi=~M)&  YjEM 

or  Bi=(~Z.C)I,  &  Yj is -  - 

the  kth  variable  in  2 _ 

or  Bi=(vZ.C),  &  Yj  is  the  kth  variable  in  z 

L( 

20  H.R.  Andersen 
We  call  ~9~ a  partitioned  boolean  graph.  Figure  6  shows  an  outline  of  a  partitioned 
boolean  graph.  If  A  has  alternation  depth  one,  cycles  in  the  graph  will  be  of  a  special 
kind  as  expressed  by  the  proposition  below. 

Proposition  5.2.  Let  A  be  an  assertion  of alternation  depth  one.  Then  the  partitioned 
boolean  graph  constructed  from  A  as  above  will  have  the  property  that  all  cycles  of  the 
underlying  boolean  graph  will  consist  of  nodes  that  are  all  consistently  labelled  with  only 
p's  or  only  v's. Moreover,  due  to  the  transformation  into  normalform,  they  will  all  belong 

to  the  same  component. 

Proof  (Sketch).  Assume  that  there  exists  a  cycle  with  a  node  labelled  p  and  a  node 
labelled  v.  These  nodes  must  belong  to  two  different  elements  of  the  partitioning, 

Vi and  Vj.  Then  either  the  ith  fixed  point  contains  thejth  fixed  point  and  thejth  fixed 
point  refers  to  a  variable  from  the  ith  fixed  point,  or  the  other  way  around.  In  both 
cases,  these  fixed  points  could  only  come  from  an  assertion  of  alternation  depth  at 
least  two. 

Assume  that  two  nodes  labelled  p  belong  to  two  different  components  of  the 
partitioning.  Then  by  arguments  similar  to  the  ones  above,  we  would  have  a  sequence 
of  two  minimum  fixed  points,  which  contradicts  the  fact  that  A  has  been  put  into 
normal  form.  0 

Using  this  property,  it  is  possible  to  give  a local  algorithm  for  alternation  depth  one 
as  in  the  following  theorem. 

Theorem  5.3.  There  exists  a  local  algorithm  which,  given  an  assertion  A  of  alternation 
depth  one  and  a  transition  system  T  with  a  state  s,  determines  whether  s  satisfies  A  in 

worst  case  time  complexity  0(  I A I I T I log(  I A I I T  I)). 

Proof  (Sketch).  Start  with  a  node  x  in  Vi.  Run  Avoiding  l's  or  Avoiding  O's (the  dual 
of  Avoiding  l's  corresponding  to  a  maximum  fixed  point)  depending  on  whether 

6p( Vi)  =  p  or  9'(  Vi)=  v,  until  at  some  point  the  marking  of  a  node  y  in  another  set 

Vj is  needed.  Suspend  the  evaluation  and  run  Avoiding  l's  or  Avoiding  O's in  Vj to  find 
the  value  of this  y.  At  some  point,  a  value  in  yet  another  set  V, might  be  needed,  and  so 
on.  However,  due  to  the  acyclic  property  of  Proposition  5.2  this  process  will  stop  at 
some  point,  when  a  node  in  some  Vi can  be  determined  without  looking  into  other 

Vi's,  and  the  suspended  evaluations  can  then  be  resumed.  Now,  when  the  value  of  the 
node  that  started  the  search  in  a  Vi has  been  determined,  all  the  nodes  visited  in  this 
search  will  have  their  correct  markings,  and  need  not  be  visited  any  more!  Hence, 
when  building  the  graph  in  a  demand-driven  fashion,  the  total  execution  time  will  be 

I B I log  I B I where  B  is  the  subset  of  the  graph  being  visited.  0 

Model  checking  and  boolean  graphs  21 
6.  Conclusion 

The  translation  of  a  model  checking  problem  into  a  problem  of finding  markings  in 
boolean  graphs  shows  the  way  to  a  rich  world  of  algorithms.  In  this  paper,  we  have 
presented  two  graph  algorithms  to  solve  the  problem,  but  considering  the  wealth  of 
graph  algorithms  around,  there  should  be  plenty  of  possibilities  for  finding  other 
interesting  algorithms.  Moreover,  the  algorithms  might  have  an  interest  on  their  own, 
as  the  graph  problem  -  equivalent  to  the  problem  of  finding  fixed  points  in  the  lattice 

CD" -  is  a very  general  problem.  As  an  example  of this,  the  global  algorithm  Chasing  l's 
has  a  very  close  resemblance  with  the  pebbling  algorithm  in  [13]  for  solving  satisfia- 
bility  of  propositional  Horn  formulas  in  linear  time.  Chasing  l's  actually  gives 
a  linear-time  algorithm  for  solving  that  problem  and  Avoiding  l's,  a  local  algorithm 
which  is  only  a  logarithmic  factor  worse.  Other  applications  have  been  investigated  in 
Andersen  [3]  and  the  local  algorithm  has  been  extended  to  alternation  depth  two  and 
above  in  Andersen  [2,  41. 

Another  area  of  application  is  suggested  by  the  reduction  lemma  from  Andersen  and 
Winskel  [S].  Suppose  D  is  a  finite  lattice,  f  a  monotonic  function  on  D,  and  in  an 
w-continuous  function  from  CD" into  D  for  an  appropriate  n.  If  it  is  possible  to  find 
a  function  g  on  0"  which  is  related  tofas  required  by  the  lemma,  i.e.  in 0 g =fi  in, then 
the  minimum  fixed  point  offcan  be  found  by  computing  pg  and  applying  in. (We  claim 
that  n  and  in can  be  chosen  so  that  such  a  g can  always  be  found.)  The  time  to  compute 
pg  will  be  bounded  by  the  size  of  the  description  of  pg  as  a  simple  fixed  point  (in  the 

sense  of  Section  2),  which  might  be  much  better  than  using  the  method  of  computing 
increasing  approximants,  as  it  certainly  was  the  case  with  the  model  checking  problem. 

The  division  idea,  which  is  the  key  step  in  the  translation  from  a  fixed  point  on 
a  powerset  into  a  fixed  point  on  the  lattice  CD'", arose  in  work  on  trying  to  find 
compositional  methods  for  reasoning  about  satisfaction.  In  [S],  a  general  version  of 
the  division  operator  is  presented.  Given  a  process  term  p  and  an  assertion  A, 
a  method  is  described,  which  computes  the  assertion  A/p  with  the  property: 

xxp:A  iff  x:  A/p, 
where  x  is  a  parallel  composition  operator  and  p:  A  is  read  as  "the  process  p  satisfies 
the  assertion  A".  The  assertion  A/p  was  constructed  such  that  it  belongs  to  the  modal 
p-calculus  with  just  unary  fixed-points,  and  for  the  fixed  points  an  exponential 

blow-up  could  result  from  the  application  of  BekiC's  theorem.  The  ideas  of  sharing 
through  n-ary  fixed  points,  as  used  in  this  paper,  can  obviously  be  used  in  improving 
on  these  results.  (A  full  account  of  these  issues  can  be  found  in  Andersen  [4].) 

Acknowledgment 

I  have  had  useful  discussions  with  Glynn  Winskel,  Kim  Skak  Larsen,  Gudmund 
Frandsen,  and  others  at  DAIMI.  Thanks  are  due  to  Rance  Cleaveland  and  Bernhard 

22  H.R.  Andersen 
Steffen  for  useful  discussions  and  for  pointing  out  some  misprints  and  ambiguities  in 
an  earlier  version;  thanks  are  also  due  to  the  anonymous  referees  for  helpful  sugges- 
tions  on  improvements. 

Appendix  A:  Proof  of  Theorem  4.2 

In  this  appendix  we  prove  correctness  of  the  local  algorithm  "Avoiding  l's" 
(Theorem  4.2).  However,  we  will  first  prove  a  simple  useful  lemma  about  fixed  points. 

Lemma  A.1.  Let  D be  a finite  lattice,  g  a  monotonic  function  on  D, and  mgD  an  element 

with  the  property  mdpg.  Then 

w=  V  s"(m). ksw 
Proof.  Recall  that  pg  =  Vkcw  g k( ID)  as  D is  finite.  From  monotonicity  of  g,  it  follows 
easily  by  mathematical  induction  that  gk( ID)<  gk(m),  hence,  ,ug =  V  gk( ID)  d  Vg"(m). 

For  the  other  direction,  from  the  assumption  m bpg  and  monotonicity  of g,  it  follows 
by  induction  that  gk(m)<pg,  hence,  //gk(m)<pg.  0 

Proof  of  Theorem  4.2  (Correctness  part).  Correctness  of  the  local  algorithm  will  be 
shown  by  informal  use  of  Hoare  logic.  It  will  be  informal  in  the  sense  that  the  formal 
semantics  of  our  programming  language  is  not  given,  nor  will  we  make  explicit 
reference  to  the  rules  of  Hoare  logic  used  in  the  reasoning.  The  intended  semantics  is 
the  usual  for  Algol-like  imperative  languages. 

Let  Q  be  defined  as  follows: 

Q (0  -def 

tlv~B\P.  m(v)=0 

-L(v)=  v  &  VweS(v).  WEB  &  (m(w)=  1  *  WEA)  &  ved(w) 

or  L(V)=  A  &  Vi(Odi<p(v)).  S(v)iEB  &  m(S(v)i)=  1 

&  S(V),W,EB 

(1) 
(2) 

&  m(S(v),(,J=  1  *  Wp(Uj=t 
&  v=W(v),,",) 
&  VVEB\P.  m(v)=  1 

-L(v)=  v  & 

Model  checking  and  boolean  graphs  23 
&  VVEA.  m(u)=  1  (6) 

&  VUEV\B.  m(u)=0  &  p(u)=0  &  d(u)=@  (7) 
&  VVE V. d(v)  c  P(u).  (8) 
The  assertion  Q  is  rather  complex,  but  it  should  be  taken  into  account  that  it  is 

supposed  to  capture  the  complete  behaviour  of  a  rather  complicated  algorithm. 
(Actually,  it  only  captures  formally  what  was  described  verbally  in  the  main  text.) 

With  small  local  modifications,  Q  is  intended  to  be  a  general  invariant  for  the 
complete  algorithm.  To  see  why  Q  is  a  good  choice,  we  assume  that  A=@  and  notice 

that  Q(o)  now  implies  the  following: 

VUEB. m(u)=0  *  L(v)=  v  &  VWES(U). WEB  &  m(w)=0 

or  L(V)=  A  &  S(~I)~(,~EB &  m(S(~),(,,)=0, 
V'vEB. m(u)=  1 *L(u)=  v  &  3WES(U).  WEB  &  m(w)=  1 

or  L(u)=  A  &  VwES(0).  WEB  &  m(w)=  1. 
Hence,  by  the  definition  of  the  function  g  induced  by  the  graph  G,  we  have 
m(,=g(m)  lB, moreover,  as  the  right-hand  side  only  depends  on  the  values  of  m  on  B, 
for  any  m'  with  m' lB=m  le  we  have 

Sw)IB=4..  (9) 
This  captures  precisely  an  important  property  of  B  of  being  "self-contained",  i.e.  all 
nodes  in  B  can  be  assigned  correct  markings  based  purely  on  other  nodes  in  B. 

Now,  using  (9) it  is  not  difficult  to  show  by  mathematical  induction  that  for  all  k~o, 

Sk(a3=4B.  (10) 
The  base  case  is  trivial.  For  the  induction  step,  we  assume  g"(m) Is=mlB.  By  (9)  with 

m' =  gk(m),  we  get 

sk+1(~)li3=s(sk(~))l~ 

=ml,. 

From  (5)  we  know  that  mdpg,  hence  by  Lemma  A.1  we  get 

= kI  (sk(m) Id,  as  ordering  is  pointwise 
=  V  ml,,  by (10) keo 
=mle. 

24  H.R.  Antlersen 
We  have  shown  that  Q(8)  &  A =8  implies  mls  =pglB,  hence,  Q  is  strong  enough  to 
prove  the  correctness  of  the  algorithm. 

Now,  let  c  denote  the  body  of  Avoiding  l's  in  Fig.  2.  The  correctness  assertion  we 
want  to  show  is  then 

{xd'}c{Q(~) &  A=@ &  XEB}, 
which,  by  the  above  discussion,  yields  the  result. 

In  doing  so,  we  will  be  involved  with  a  Hoare  Triple  capturing  the  effect  of  the 
procedure  "visit": 

{Q(P))  uisit(x){Q(P)  &  XEB}. 
In  words:  The  task  of "visit(x)"  is  to  extend  the  set  of visited  nodes  to  include  x  in  such 
a  way  that  Q(P)  is  preserved. 

Similarly,  for  the  procedure  tfwtn'  the  Hoare  Triple  is: 

{Q(Pu{x))  &  XEB  &  L(x)=  A }fwtn(x)  (Q(P)  &  XEB}. 
The  task  of  `tfwtn(x)"  is  to  ensure  that  a  conjunctive  node  x,  which  currently  might 

have  a  wrong  marking  (i.e.  lines  (l))(4)  of  Q  does  not  necessarily  hold  for  x)  is 
corrected. 

Proving  that  these  three  assertions  are  indeed  valid  is  a straightforward,  but  tedious 
task.  (Invariants  for  all  the  loops  follow  easily  from  the  pre-  and  post-conditions.)  As 
an  example,  we  sketch  the  proof  for  "visit".  Figure  7  shows  the  procedure  "visit", 
equipped  with  numbers  on  some  of  the  commands. 

if  x#B  then 

10:  B:=Bu{x} 

if  L(x)=  v  then 
11:  ok  :=false 
12:  whilep(x)<IS(x)I  &  lokdo 
13:  w :=  S(X),@, 
14:  visit(w) 
15:  if  m(w)=0  then  d(w):=d(w)u 
16:  ff m(w) =  1 then  ok  : =  true 

fi 
17:  if  ok  then  m(x):=1  A:=Au{x] 

BL(x)=  A then 

.Wn(x) fi 

1x1 P(X) := P(X) + 1 

Fig.  7.  hit(x). 

Model  checking  and  boolean  graphs  25 
We  will  argue  that  the  triple 

(Q(P)}uisit(x)  { Q(P)  &  XEB} 
is  valid.  This  will  be  done  by  cases  according  to  the  different  branches  of  the 
conditionals,  assuming  that  for  any  recursive  call  the  triple  is  indeed  valid. 

To  consider  a  nontrivial  case,  assume  that  x$B  and  L(x)=  v  As  invariant  for  the 
while-loop  (12)  we  take 

~-=,,,QV'u(x)) & J, 
where 

J  -def  ok  =  true  *  m(S(x),(,,)  =  1 

&  Vw~{S(x)o,...,S(x),(,,-1). 

WEB  &  (m(w)=  1  =  WEA)  &  x&(w). 

Due  to  the  precondition  Q(P)  and  the  initial  assignments  (10) and  (ll),  I  holds  initially. 
By  assumption,  the  triple 

{Q(Pu{x})}uisit(w){Q(Pu{x})  &  WCB} 
is  valid.  Now,  for  visit(w)  to  preserve  I,  we  would  have  to  show  that  J  is  preserved  by 

visit(w).  We  will,  however,  just  assume  that  this  is  the  case.  (An  informal  argument: 
visit(w)  never  decreases  A  or  d(w),  nor  does  it  affect  x,  hence,  will  not  violate  J.) 

Branch  (15)  preserves  Q(P  u  {x> ) ( increasing  d(w)  does  not  affect  Q),  and  preserves 
J.  Branch  (16)  also  preserves  Q(Pu{x})  and  J.  Hence,  the  body  of  the  while-loop 

satisfies  postcondition  I  under  the  precondition  (I  &  p(x)  <  1 S(x)  1 &  1  ok). 

When  the  while-loop  terminates  we  have 

I  &  (p(x)  =  1 S(x)  1 or  ok  =  true). 
If  ok  =  true  then  from  J  we  get  m(S(x),(,,)  =  1,  hence,  the  assignments  in  (17) makes 

Q(P)  lines  (l)-(4)  and  lines  (6)  and  (8)  valid.  Let  m'  be  the  value  of  m  after  the 
assignment.  Then  m' <pg  follows  from  the  fact  that  pg  =g(pg)  and 
m'(x)=g(m)(x)dg(,ug)(x)=,ug(x)  Hence,  line  (5)  of  Q(P)  holds. 

A  very  similar  argument  applies  for  the  case  ok=fulse  and  p(x)=  (S(x)/.  0 

Proof  of  Theorem  4.2  (Complexity  part).  We  will  make  informal  use  of  amortised  time 
analysis  (see,  e.g.  [ll]).  The  crucial  observation  is  that  no  edge  is  visited  more  than 
twice:  once  in  a  forward  direction,  and  once  in  a  backward  direction.  By  following  an 
edge  in  a  forward  direction,  we  mean  following  the  edge  from  a  node  to  a  successor  as 
it  is  done  in  "visit"  and  "fwtn".  Whenever  an  edge  is  followed  in  a  forward  direction 
from  a  node  x,  the  "pointer"  p(x)  is  incremented,  and  as  the  pointers  p(x)  are  never 
decremented,  that  particular  edge  will  never  again  be  visited.  As  concerns  the  back- 
ward  direction:  The  while-loop  in  the  body  of  the  algorithm  (Fig.  2)  follows  edges 
backwards  by  considering  elements  of  the  "dependency  lists"  d(y).  Such  an  edge  will 
only  be  followed  once  -  should  it  appear  in  the  list  d(y)  again,  y  would  have  changed 

26  H.R.  Andersen 
marking  from  the  present  marking  (which  is  one  as  yeA)  to  the  marking  zero.  This 

never  happens  as  markings  always  increase  from  zero  to  one  when  they  change. 

Looking  at  the  algorithm,  it  is  not  hard  to  see  that  between  two  situations  where  an 
edge  is  followed  forwards  or  backwards,  only  a  constant  amount  of  computation  is 
performed  (i.e.  the  cost  is  bounded  by  some  constant  c), hence  ~  including  the  cost  for 
initialisation  ~  the  total  cost  will  be  0(  1 G I). Actually,  ignoring  the  initialisation  and 
letting  B  be  the  nodes  visited  when  the  algorithm  terminates,  the  above  analysis  yields 

0(  1 GsI),  where  GB  is  now  the  subgraph  of  G  being  spanned  by  the  nodes  of 
B  (formally,  GB =  (B,  En  B  x  B,  L  iB)).  0 

Appendix  B: Proof  of  Theorem  5.1 

The  global  algorithm  for  the  full  modal  p-calculus  is  presented  in  Fig.  9.  To 
understand  the  algorithm,  the  following  notions  are  needed  (we  state  them  for  p,  there 
are  dual  definitions  for  v): 

Definition  B.l.  A  ,u-subexpression  of  A  is a  subexpression  of A  with  main  connective  p. 
A  top  p-subexpression  of  A  is  a  ,u-subexpression  of  A  which  is  not  contained  in 
a  v-subexpression  of  A.  A  top-level  p-subexpression  of  A  is  a  maximal  ,u-subexpression 
of  A,  i.e.  it  is  not  contained  in  other  p-subexpressions  of A.  Define  t/,(A)  (resp.,  &(A)) 
to  be  the  top-level  p-subexpressions  (resp.,  v-subexpressions)  of  A. 

Figure  8 gives  a  sketch  of  the  locations  of top  and  top-level  p-  and  v-subexpressions 
within  an  assertion.  We  shall  extend  the  syntax  to  include  constants  Q  in  the  sequel. 
These  constants  can  be  thought  of  as  "a  special  kind  of  variables",  which  we  will 
assume  to  have  size  zero  (this  does  not  affect  the  original  measure  of  size,  as  these 
constants  are  not  present  in  the  assertion  a  priori,  but  only  introduced  by  the 
algorithm).  A  constant  is,  of  course,  considered  to  be  a  closed  expression. 

r________.__: 
I 
I 

p  : 

I  Y  I 
I  I  I 
I  L__T  I 

top  p's  i 

I 

p  :  :  ' 1 

A 

I  ' I '  /A ,  : top-level  V'S 

I I  P  P  !  I  : 
L______-  m-J 

1 

no CLIV  :  ; '  I 
I--  ________  --  J  , '  v  I v  Y 

LJ  I L______--..----m-J 

Fig.  8.  Top  and  top-level  p-  and  v-subexpressions 

Compute(A,  p): 

Model  checking  and  boolean  graphs  21 

Let  {B,,  . , B,}  = mcps(A)  be  the  maximal,  closed,  proper  p/v-subexpressions 

of  A. 
m>Q  then 

Replace  B1,  . . . , B,  in  A  with  new  constants  Q1 , . . . , Q,,, yielding  A'. 

~`:=pCCowute(B~,  PI/Q,, . . ..CompW&.  P)IQ,J. 
return  Compute(A',  p') 

A=Q  then 

return  p(Q) 
A=(a)B  then 

return  (ES  I~s'ES.  s 2  s' &  s'&ompute(B,  p)} 
A=Bo  A  B1  then 

return  Compute(B,,  p) n  Compute(B,  , p) 
AE(~X.B)~  then 

Let  X1,.  , X,  be  the  variables  bound  by  top  p-subexpressions  of  A  (the 
first  n  are  assumed  to  be  X,  ,  , X,  from  pX.B),  and  let  B,  ,  . . , B,  be 

the  corresponding  right-hand  sides.a 
Define 

where  B:  is  constructed  from  Bi  by  replacing  all  occurrences  of  top 
p-subexpressions  ( ,uL_Y. C)j  of  A  by  Yj. 

if  B'  is  an  unnested  fixed  point  then 

Compute  B'  using  the  efficient  algorithm  for  unnested  fixed  points, 

returning  the  ith  component. 
else 

gO:=(&...,@)  p:=o. 
Convert  the  variables  Xi  into  constants. 
repeat 

p:=p+  1 

gP:=Compute((B;,  . . ..Bd)>  pL-Up-`/(XI,  . . ..X.)l) 
until  VP =  Up-' _ 
return  Up 
ff  All  remaining  cases  are  analogous 

fi 

a Here  variables  should  be  thought  of  as  identifying  occurrences  instead  of  just  names. 

Fig.  9.  Global  algorithm  for  the  full  calculus. 

28  H.R.  Andersen 

Correctness  of  the  algorithm  is  immediate  from  the  semantics,  the  only  non  trivial 
case  being  the  transformation  for  A =  (~8  .@)i, the  correctness  of  which  follows  from 

BekiZs  theorem  [7]. 

The  notion  of alternation  depth  will  be  used  in  the  complexity  analysis.  It  is  slightly 
tricky  to  define.  Emerson  and  Lei  [14]  gives  an  inductive  definition,  which  is  close  to 
the  definition  we  will  use.  (We  have,  however,  changed  it  slightly  to  remedy  what  we 
consider  mistakes  in  their  definition.) 

Definition  B.2  (Alternation  depth).  Assume  A  is  a  closed  assertion.  Let  mcps(4)  be  the 
maximal,  closed,  proper  p/v-subexpressions  of  A.  Then  define  the  alternation  depth 
ad(A)  of  A  as  follows  (taking  max(@)=O):  Let  Q1,  ..,  Qk be  arbitrary  constants. 

if  mcps(A)={B,,...,B,}#8  then 

if  m&A)=@  then 

0  ifA-Q 

max{ad(&),  ad(A1))  ifA-&  v  A,,A=&r\A, 
ad(A)  =  ud(A')  ifA=(u)A',  Az[u]A' 

1 +max(ud(C")I  CEtl,(B)j  if A-(@.@), 

1 +max(ud(C")~C~tl,(B)}  if A-(V&.B)i, 

where  Cc'  is  constructed  from  C  by  replacing  all  free  variables  with  arbitrary 
constants. 

The  purpose  of the  measure  ad  is  to  capture  to  what  extent  minimum  and  maximum 
fixed  points  are  nested  in  an  essential  way.  Hence,  closed  assertions  appearing  inside 
p-  and  v-assertions  do  not  increase  the  alternation  depth,  nor  does  sequences  of  fixed 

points  of  the  same  kind,  only  when  for  instance  a  v-assertion  appears  inside  some 
p-assertion  with  a  free  variable  bound  by  the  p-assertion,  will  the  alternation  depth 
increase.  The  global  algorithm  exploits  this  by  computing  all  top  p-subexpressions  (or 
top  v-subexpressions)  at  the  same  time. 

The  global  algorithm  follows  very  closely  the  definition  of  alternation  depth,  which 
simplifies  the  analysis  considerably.  Formally,  as  in  the  theorem  we  will  assume  the 
presence  of  an  algorithm  for  computing  unnested  fixed  points  A E(@.B)~  (and 
(v&.@)~)  which  runs  in  time  0(  1 Al  1 Tl),  i.e.  there  exists  a  constant  c  such  that  the 

running  time  of  the  algorithm  is  asymptotically  bounded  by  c I Al  I TI.  One  such 
algorithm  is  of course  Chasing  1's. Under  this  assumption,  we  show  by  induction  that 
the  algorithm  of  Fig.  9  runs  in  time  asymptotically  bounded  by  c I A Ik I S 1 k- 1 I TI, 
where  k =  max  {ad(A),  l}. 

Model  checking  and boolean  graphs  29 
Proof  of  Theorem  5.1.  Define  the  predicate  P  on  closed  assertions  by 

P(A)-  def for  all  p.  Compute(A,  p)  executes  in  time  asymptotically  bounded  by c14klSlk-11~I, 

where  k = max  {ad(A),  l}.  Assume  inductively  that  for  all  A',  I A'[  < I A  I a  P(A').  We 
show  by  cases  that  P(A)  holds.  In  the  sequel,  k  will  always  be  max{ad(A),  l}. 

Case  m > 0. By  the  induction  hypothesis,  Compute(Bi,  p)  takes  time  c 1 Bi I ki I S Ikzpl I TI, 
where  ki = max{ad(B,),  l}.  Hence,  letting  k' =  max{ad(A'),  l}  the  total  time  for 
computing  A  is 

clA'Ik'ISlk'-l  T  + I  I  i~~cI~iIkiISIki-lITl~CIA'~kISIk-lITI+  f  CIBilklSlk-lITI 

i=l 

by  definition  of  alternation  depth 

dc(lA'l+  f  IBiI)kISlk-lITI 

i=l 

Case  A  = Q.  Trivial. 
Case  A=  (a)B.  The  time  to  compute  the  diamond-modality  is  bounded  by  cl  TI, 
hence,thetotalcostisclTl+clBlklSlk-1lTIQc(lBI+l)kISlk-1lTI=clAlklSlk-1lTI. 

Case  A=&  A  B1.  As  for  (a)B. 
Case  A-(pX.B)i.  Observe  that  IB'l<l  AI. -  - 
Subcase  B'  unnested.  As  ad(A)=ad(B')=  1,  the  claim  follows  immediately  from  the 
assumption  about  the  efficient  algorithm  for  unnested  fixed  points. 
Subcase  B'  nested.  Let  k; = max  {ad@:),  l}.  Observe,  that  k = 

30  H.R.  Andersen 
References 

[l]  A.V.  Aho,  J.E.  Hopcroft  and  J.D.  Ullman,  The  Design  and  Analysis  ofComputer  Algorithms  (Addison- 

Wesley,  Reading,  MA,  1974). 
[2]  H.R.  Andersen,  Local  computation  of  alternating  fixed-points,  Tech.  Report  No.  260,  Computer 

Laboratory,  Univ.  of  Cambridge,  June  1992. 
[3]  H.R.  Andersen.  Local  computation  of  simultaneous  fixed-points,  Tech.  Report  PB-420,  Computer 

Science  Department,  Aarhus  Univ.,  October  1992. 
[4]  H.R.  Andersen.  Verification  of Temporal  Properties  in  Concurrent  Systems.  Ph.D.  Thesis,  PB-445, 

Department  of  Computer  Science,  Aarhus  Univ.,  Denmark,  1993. 
[S]  H.R.  Andersen  and  G.  Winskel,  Compositional  checking  of  satisfaction,  Formal  Methods  In  System 

Design  1 (4) (1992);  extended  abstract  in  [19]. 
[6]  A.  Arnold  and  P.  Crubille,  A  linear  algorithm  to  solve  fixed-point  equations  on  transitions  systems, 

Inform.  Process.  Lett.  29  (1988)  57-66. 
[7]  H.  Bekit,  Definable  operations  in  general  algebras,  and  the  theory  of  automata  and  flow  charts, 

Lecture  Notes  in  Computer  Science,  Vol.  177  (Springer,  Berlin,  1984)  30-55. 
[8]  R.  Cleaveland,  Tableau-based  model  checking  in  the  propositional  mu-calculus,  Acta  Inform.  27 

(1990)  725-747. 
[9]  R. Cleaveland,  J.  Parrow  and  B. Steffen,  The  Concurrency  Workbench:  A semantics  based  tool  for  the 

verification  of  concurrent  systems.  Tech.  Report  ECS-LFCS-89-83,  Laboratory  for  Foundations  of 
Computer  Science,  Univ.  of  Edinburgh,  August  1989. 
[lo]  R.  Cleaveland  and  B.  Steffen,  A  linear-time  model-checking  algorithm  for  the  alternation-free  modal 

mu-calculus;  in  [19]. 
[1 l]  T.H.  Cormen,  C.E.  Leiserson  and  R.L.  Rivest,  Introduction  to  Algorithms  (McGraw-Hill,  New  York, 

1990). 
[12]  M.  Dam,  Translating  CTL*  into  the  modal  p-calculus,  Tech.  Report  ECS-LFCS-90-123,  Laboratory 

for  Foundations  of  Computer  Science,  Univ.  of  Edinburgh,  November  1990. 
[13]  W.F.  Dowling  and  J.H.  Gallier,  Linear-time  algorithms  for  testing  the  satisfiability  of  propositional 

Horn  formulae,  J.  Logic  Programming 